<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="5d40086458e1b194df3ff27c332046fe8de9903b" translate="yes" xml:space="preserve">
          <source>The user name that owns the file</source>
          <target state="translated">拥有该文件的用户名</target>
        </trans-unit>
        <trans-unit id="9ab82377d9d8e711c9e229f8137ce74619a6f296" translate="yes" xml:space="preserve">
          <source>The user time is the amount of time the entire process spent on behalf of the user on this system executing this program.</source>
          <target state="translated">用户时间是指整个进程代表用户在本系统上执行本程序的时间。</target>
        </trans-unit>
        <trans-unit id="244da933c00a6b886bfc62a46ed8d2ddfb906e87" translate="yes" xml:space="preserve">
          <source>The user who wants the memoization cache to be expired according to your policy will say so by writing</source>
          <target state="translated">用户如果想根据你的策略让memoization cache过期,可以通过编写</target>
        </trans-unit>
        <trans-unit id="bb2fd16359343bc75d33118c9751a1ecbc3d3037" translate="yes" xml:space="preserve">
          <source>The usual arithmetic (+,-,+=,-=) is also available on the objects.</source>
          <target state="translated">一般的算术(+,-,+=,-=)也可以在对象上使用。</target>
        </trans-unit>
        <trans-unit id="c7334043434491bfd6d25a23b05fb6d156604749" translate="yes" xml:space="preserve">
          <source>The usual calling signature is</source>
          <target state="translated">通常的调用签名是</target>
        </trans-unit>
        <trans-unit id="72046882a8fdaf30c0521d766b5cf67d3d264433" translate="yes" xml:space="preserve">
          <source>The usual idiom is:</source>
          <target state="translated">通常的成语是。</target>
        </trans-unit>
        <trans-unit id="7ac11eaf69a957a9aa5638ad8debab406436e005" translate="yes" xml:space="preserve">
          <source>The usual method for terminating a thread is to &lt;a href=&quot;functions/return&quot;&gt;return EXPR&lt;/a&gt; from the entry point function with the appropriate return value(s).</source>
          <target state="translated">终止线程的常用方法是使用适当的返回值从入口点函数&lt;a href=&quot;functions/return&quot;&gt;返回EXPR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="189fd1d4b573f9b0c1b1794439c343e0650165ef" translate="yes" xml:space="preserve">
          <source>The usual shell redirection symbols &lt;code&gt; | &lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; are recognized by the cpan shell &lt;b&gt;only when surrounded by whitespace&lt;/b&gt;. So piping to pager or redirecting output into a file works somewhat as in a normal shell, with the stipulation that you must type extra spaces.</source>
          <target state="translated">常用的shell重定向符号 &lt;code&gt; | &lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 由CPAN壳识别&lt;b&gt;仅当由空白所包围&lt;/b&gt;。因此，用管道输送到分页器或将输出重定向到文件中的方式与在普通shell中一样，规定必须键入多余的空格。</target>
        </trans-unit>
        <trans-unit id="f5284fa656dfbed57ca832128b9046307b6a8989" translate="yes" xml:space="preserve">
          <source>The usual warnings if it can't read or write the files involved.</source>
          <target state="translated">如果不能读写相关文件,通常会发出警告。</target>
        </trans-unit>
        <trans-unit id="9c1efd4c7ee39f810e92b8d45a9ddf28889531e0" translate="yes" xml:space="preserve">
          <source>The usual warnings if it cannot read or write the files involved.</source>
          <target state="translated">如果不能读写相关文件,通常会发出警告。</target>
        </trans-unit>
        <trans-unit id="22c79ee036d08be39b9326c3b9dab69e6aa2a162" translate="yes" xml:space="preserve">
          <source>The usually available constants are</source>
          <target state="translated">通常可用的常数有</target>
        </trans-unit>
        <trans-unit id="2efc4102646dfcf9e84b807940c146f94356608b" translate="yes" xml:space="preserve">
          <source>The util.c:1716 is the source code file and line number.</source>
          <target state="translated">util.c:1716是源码文件和行号。</target>
        </trans-unit>
        <trans-unit id="e3d163a1d052b62f7d060607d4bf6b7f91f9aa60" translate="yes" xml:space="preserve">
          <source>The v-strings are portable only up to v2147483647 (0x7FFF_FFFF), that's how far EBCDIC, or more precisely UTF-EBCDIC will go.</source>
          <target state="translated">v 字符串只能移植到 v2147483647 (0x7FFF_FFFF),这就是 EBCDIC,或者更准确的说是 UTF-EBCDIC 的范围。</target>
        </trans-unit>
        <trans-unit id="84e2770182dc038d9b47afe7e9b08eec9556b081" translate="yes" xml:space="preserve">
          <source>The v5.16 release also supports a &lt;code&gt;:loose&lt;/code&gt; import for loose matching of character names, which works just like loose matching of property names: that is, it disregards case, whitespace, and underscores:</source>
          <target state="translated">v5.16发行版还支持 &lt;code&gt;:loose&lt;/code&gt; 导入，用于字符名称的松散匹配，其作用与属性名称的松散匹配相同：也就是说，它忽略大小写，空格和下划线：</target>
        </trans-unit>
        <trans-unit id="b193f0ebc1769a16dcfcc639a8401c8c00cf9c0e" translate="yes" xml:space="preserve">
          <source>The valgrind tool can be used to find out both memory leaks and illegal heap memory accesses. As of version 3.3.0, Valgrind only supports Linux on x86, x86-64 and PowerPC and Darwin (OS X) on x86 and x86-64). The special &quot;test.valgrind&quot; target can be used to run the tests under valgrind. Found errors and memory leaks are logged in files named</source>
          <target state="translated">valgrind工具可以用来查找内存泄漏和非法堆内存访问。从3.3.0版本开始,Valgrind只支持x86、x86-64版本的Linux和x86、x86-64版本的PowerPC和Darwin(OS X)。可以使用特殊的 &quot;test.valgrind &quot;目标来运行valgrind下的测试。发现的错误和内存泄漏会被记录在名为</target>
        </trans-unit>
        <trans-unit id="aa3e07c88c6113557baab8df17b4983a954a8994" translate="yes" xml:space="preserve">
          <source>The value assigned to the key &lt;code&gt;'fallback'&lt;/code&gt; tells Perl how hard it should try to find an alternative way to implement a missing operator.</source>
          <target state="translated">分配给键 &lt;code&gt;'fallback'&lt;/code&gt; 告诉Perl应该多努力尝试找到另一种方法来实现缺少的运算符。</target>
        </trans-unit>
        <trans-unit id="6f766eba2f1a65e15d6582321bc30fe9d0e0e26a" translate="yes" xml:space="preserve">
          <source>The value associated with &lt;code&gt;env&lt;/code&gt; is itself a hashref that is matched against corresponding values in the &lt;code&gt;%ENV&lt;/code&gt; hash. Keys prefixed with &lt;code&gt;not_&lt;/code&gt; negates the corresponding match.</source>
          <target state="translated">与 &lt;code&gt;env&lt;/code&gt; 关联的值本身就是一个哈希引用，它与 &lt;code&gt;%ENV&lt;/code&gt; 哈希中的相应值匹配。前缀为 &lt;code&gt;not_&lt;/code&gt; 的键会否定对应的匹配项。</target>
        </trans-unit>
        <trans-unit id="aa731dffe1d7c5a02c15e427c4d55ad58928d794" translate="yes" xml:space="preserve">
          <source>The value associated with &lt;code&gt;perlconfig&lt;/code&gt; is itself a hashref that is matched against corresponding values in the &lt;code&gt;%Config::Config&lt;/code&gt; hash living in the &lt;code&gt;Config.pm&lt;/code&gt; module. Keys prefixed with &lt;code&gt;not_&lt;/code&gt; negates the corresponding match.</source>
          <target state="translated">与 &lt;code&gt;perlconfig&lt;/code&gt; 关联的值本身就是一个hashref，它与 &lt;code&gt;Config.pm&lt;/code&gt; 模块中 &lt;code&gt;%Config::Config&lt;/code&gt; 哈希中的相应值匹配。前缀为 &lt;code&gt;not_&lt;/code&gt; 的键会否定对应的匹配项。</target>
        </trans-unit>
        <trans-unit id="86d758b44cf7d343d2636c283000a90f2b95ec68" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;$offset&lt;/code&gt; in Unix will be &lt;code&gt;0&lt;/code&gt; , but in Mac OS Classic will be some large number. &lt;code&gt;$offset&lt;/code&gt; can then be added to a Unix time value to get what should be the proper value on any system.</source>
          <target state="translated">在Unix中， &lt;code&gt;$offset&lt;/code&gt; 的值为 &lt;code&gt;0&lt;/code&gt; ，但在Mac OS Classic中，此值为较大。然后可以将 &lt;code&gt;$offset&lt;/code&gt; 添加到Unix时间值中，以在任何系统上获得正确的值。</target>
        </trans-unit>
        <trans-unit id="6a050ff582b3cdf570af43e605e700a8d71acf02" translate="yes" xml:space="preserve">
          <source>The value in each entry of the hash is what you are referring to when you use the &lt;code&gt;*name&lt;/code&gt; typeglob notation.</source>
          <target state="translated">使用 &lt;code&gt;*name&lt;/code&gt; typeglob表示法时，哈希表每个条目中的值就是您所指的内容。</target>
        </trans-unit>
        <trans-unit id="0f707479820ff9d25dbdd6e993639c9a31b93e20" translate="yes" xml:space="preserve">
          <source>The value is identical to &lt;code&gt;$Config{'osname'}&lt;/code&gt; . See also &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; and the &lt;b&gt;-V&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">该值与 &lt;code&gt;$Config{'osname'}&lt;/code&gt; 。另请参见&lt;a href=&quot;config&quot;&gt;config&lt;/a&gt;和&lt;a href=&quot;perlrun&quot;&gt;perlrun中&lt;/a&gt;记录的&lt;b&gt;-V&lt;/b&gt;命令行开关。</target>
        </trans-unit>
        <trans-unit id="70b8122c0413fdd3eed692b348862e9493d569f3" translate="yes" xml:space="preserve">
          <source>The value of $side is</source>
          <target state="translated">$side的价值是</target>
        </trans-unit>
        <trans-unit id="9f3e350bc3160e2ef2f10c200798865cfdef3abe" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$Config{sitelib}&lt;/code&gt; is also determined in C code and not read from &lt;code&gt;Config.pm&lt;/code&gt; , which is not loaded.</source>
          <target state="translated">的值 &lt;code&gt;$Config{sitelib}&lt;/code&gt; 也是在C代码确定，而不是从读 &lt;code&gt;Config.pm&lt;/code&gt; ，这是不加载。</target>
        </trans-unit>
        <trans-unit id="5ec5b14ed87db6c409cf2d38c4b2eab23f206eae" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$^O&lt;/code&gt; on OpenVMS is &quot;VMS&quot;. To determine the architecture that you are running on refer to &lt;code&gt;$Config{'archname'}&lt;/code&gt; .</source>
          <target state="translated">OpenVMS 上 &lt;code&gt;$^O&lt;/code&gt; 值为&amp;ldquo; VMS&amp;rdquo;。要确定您正在运行的体系结构，请参考 &lt;code&gt;$Config{'archname'}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a38163b3b1097c345c4ed53de76d7f29841da7e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$^O&lt;/code&gt; on VOS is &quot;vos&quot;. To determine the architecture that you are running on without resorting to loading all of &lt;code&gt;%Config&lt;/code&gt; you can examine the content of the &lt;code&gt;@INC&lt;/code&gt; array like so:</source>
          <target state="translated">VOS 上 &lt;code&gt;$^O&lt;/code&gt; 值为&amp;ldquo; vos&amp;rdquo;。要确定正在运行的体系结构而无需加载所有 &lt;code&gt;%Config&lt;/code&gt; ，可以检查 &lt;code&gt;@INC&lt;/code&gt; 数组的内容，如下所示：</target>
        </trans-unit>
        <trans-unit id="0b11ba94deca518a1e2cfb4f0d2fd72a2e75493b" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$_&lt;/code&gt; when the sub returns will be stored in the filename header field.</source>
          <target state="translated">子返回时的 &lt;code&gt;$_&lt;/code&gt; 值将存储在文件名标题字段中。</target>
        </trans-unit>
        <trans-unit id="e887b08023c56383b67ea2dd8816e1569e2d83d2" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;flags&lt;/code&gt; determines the behavior when &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; does not point to a well-formed UTF-8 character. If &lt;code&gt;flags&lt;/code&gt; is 0, when a malformation is found, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. Also, if UTF-8 warnings haven't been lexically disabled, a warning is raised.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 未指向格式正确的UTF-8字符时， &lt;code&gt;flags&lt;/code&gt; 的值确定行为。如果 &lt;code&gt;flags&lt;/code&gt; 为0，则在发现 &lt;code&gt;*retlen&lt;/code&gt; ，将返回零，并设置* retlen，以便（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ）是 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 中下一个可能会开始以非格式字符开头的位置。同样，如果未按词法禁用UTF-8警告，则会引发警告。</target>
        </trans-unit>
        <trans-unit id="6c4b4f2983d220858913f6137ac2e8d4d0fdf8f5" translate="yes" xml:space="preserve">
          <source>The value of a character (&lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;) is the corresponding Unicode code point.</source>
          <target state="translated">字符（ &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ）的值是相应的Unicode代码点。</target>
        </trans-unit>
        <trans-unit id="4e567ba2156b576b88f1e773ff7f64942df23743" translate="yes" xml:space="preserve">
          <source>The value of an attribute may itself be another object. For example, instead of returning its last mod time as a number, the &lt;code&gt;File&lt;/code&gt; class could return a &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; object representing that value.</source>
          <target state="translated">属性的值本身可以是另一个对象。例如， &lt;code&gt;File&lt;/code&gt; 类可以返回代表该值的&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;对象，而不是将其最后的mod时间作为数字返回。</target>
        </trans-unit>
        <trans-unit id="4be98eb05f5630113ca4199a823f81cc002596a7" translate="yes" xml:space="preserve">
          <source>The value of any Unicode (not including Perl extensions) character property mentioned above for any single code point is available through &lt;a href=&quot;unicode/ucd#charprop()&quot;&gt;charprop() in Unicode::UCD&lt;/a&gt;. &lt;a href=&quot;unicode/ucd#charprops_all()&quot;&gt;charprops_all() in Unicode::UCD&lt;/a&gt; returns the values of all the Unicode properties for a given code point.</source>
          <target state="translated">上面提到的任何单个代码点的任何Unicode（不包括Perl扩展名）字符属性的值都可以通过&lt;a href=&quot;unicode/ucd#charprop()&quot;&gt;Unicode :: UCD中的charprop（）获得&lt;/a&gt;。&lt;a href=&quot;unicode/ucd#charprops_all()&quot;&gt;Unicode :: UCD中的charprops_all（）&lt;/a&gt;返回给定代码点的所有Unicode属性的值。</target>
        </trans-unit>
        <trans-unit id="81fc623a108af3428235cbe74b6771e41c797430" translate="yes" xml:space="preserve">
          <source>The value of revision comes from the</source>
          <target state="translated">修订的价值来自于</target>
        </trans-unit>
        <trans-unit id="96cb89717e8339762098eca6a52dfe1d75c52296" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;flags&lt;/code&gt; hint to getaddrinfo(), or the $flags parameter to getnameinfo() contains unrecognised flags.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 的值提示给getaddrinfo（），或者$ flags参数提示给getnameinfo（），其中包含无法识别的标志。</target>
        </trans-unit>
        <trans-unit id="de2c00bdfe45ec53f217b88f118a8da5474d909d" translate="yes" xml:space="preserve">
          <source>The value of the ADLER32 field read must match the adler32 value of the uncompressed data actually contained in the file.</source>
          <target state="translated">读取的adler32字段的值必须与文件中实际包含的未压缩数据的adler32值相匹配。</target>
        </trans-unit>
        <trans-unit id="932cb4d9b33ea8ac456d8558a4c42d4644723cbc" translate="yes" xml:space="preserve">
          <source>The value of the CRC32 field read must match the crc32 value of the uncompressed data actually contained in the gzip file.</source>
          <target state="translated">读取的CRC32字段的值必须与gzip文件中实际包含的未压缩数据的crc32值一致。</target>
        </trans-unit>
        <trans-unit id="7e9f5de9a38d28729524674757f04e1cb2068248" translate="yes" xml:space="preserve">
          <source>The value of the ISIZE fields read must match the length of the uncompressed data actually read from the file.</source>
          <target state="translated">读取的ISIZE字段的值必须与实际从文件中读取的未压缩数据的长度一致。</target>
        </trans-unit>
        <trans-unit id="6975eb5b4fde16e6c94a6652320983d4f157fb4c" translate="yes" xml:space="preserve">
          <source>The value of the OP's SV, if it has one, in a short human-readable format.</source>
          <target state="translated">上位机的SV值(如果有的话),以简短的人类可读格式表示。</target>
        </trans-unit>
        <trans-unit id="335bddece83d92e99066c5c702486489e5db8aca" translate="yes" xml:space="preserve">
          <source>The value of the function is not being passed back as the function's return value, but by changing the value of the variable that was passed into the function. You might have guessed that when you saw that the return value of round is of type &quot;void&quot;.</source>
          <target state="translated">函数的值不是作为函数的返回值传回来的,而是通过改变传入函数的变量的值。当你看到round的返回值是 &quot;void &quot;类型时,你可能已经猜到了。</target>
        </trans-unit>
        <trans-unit id="332bfecdbc3324ed6709a244ef3af16edb8104ba" translate="yes" xml:space="preserve">
          <source>The value of the last evaluated expression of the &lt;code&gt;given&lt;/code&gt; block if no condition is true.</source>
          <target state="translated">如果没有条件为真，则 &lt;code&gt;given&lt;/code&gt; 块的最后一个求值表达式的值。</target>
        </trans-unit>
        <trans-unit id="77cf8495b50e92c33dbdf25b33ef15173c2d3541" translate="yes" xml:space="preserve">
          <source>The value of the last evaluated expression of the successful &lt;code&gt;when&lt;/code&gt; /&lt;code&gt;default&lt;/code&gt; clause, if there happens to be one.</source>
          <target state="translated">如果碰巧有一个成功的 &lt;code&gt;when&lt;/code&gt; / &lt;code&gt;default&lt;/code&gt; 子句，则最后计算的表达式的值。</target>
        </trans-unit>
        <trans-unit id="e9dbf107286e577746464279a9f4d776045ba7e1" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; may be compared against the encrypted password from the UAF returned by the &lt;code&gt;getpw*&lt;/code&gt; functions, in order to authenticate users. If you're going to do this, remember that the encrypted password in the UAF was generated using uppercase username and password strings; you'll have to upcase the arguments to &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; to insure that you'll get the proper value:</source>
          <target state="translated">可以将 &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; 返回的值与 &lt;code&gt;getpw*&lt;/code&gt; 函数返回的UAF的加密密码进行比较，以对用户进行身份验证。如果要执行此操作，请记住，UAF中的加密密码是使用大写的用户名和密码字符串生成的；您必须大写要 &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; 的参数，以确保获得正确的值：</target>
        </trans-unit>
        <trans-unit id="750d57c2b28689ee366bb45cb08dd596ede16734" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; may be affected after the call, and the filehandle may be flushed. (Win32)</source>
          <target state="translated">在调用之后， &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 所返回的值可能会受到影响，并且文件句柄可能会被刷新。（Win32的）</target>
        </trans-unit>
        <trans-unit id="b9eb02fecf7e78b1a88f2675d747749b95555376" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; is the offset in seconds from 01-JAN-1970 00:00:00 (just like the CRTL's times() routine), in order to make life easier for code coming in from the POSIX/Unix world.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 返回的值是从1970年1月1日00:00:00起的偏移量（以秒为单位）（就像CRTL的times（）例程一样），以便使来自POSIX / Unix世界的代码更容易使用。</target>
        </trans-unit>
        <trans-unit id="dce33a69a270de7fcb08010c8a7a1e528d7b525f" translate="yes" xml:space="preserve">
          <source>The value returned by DELETE becomes the return value of the call to delete(). If you want to emulate the normal behavior of delete(), you should return whatever FETCH would have returned for this key. In this example, we have chosen instead to return a value which tells the caller whether the file was successfully deleted.</source>
          <target state="translated">DELETE返回的值成为调用delete()的返回值。如果你想模仿delete()的正常行为,你应该返回FETCH为这个键返回的任何值。在这个例子中,我们选择返回一个值来告诉调用者文件是否被成功删除。</target>
        </trans-unit>
        <trans-unit id="6bc17f7cca700d462e95542bbd03b318a3e0be44" translate="yes" xml:space="preserve">
          <source>The value returned by the</source>
          <target state="translated">返回的值</target>
        </trans-unit>
        <trans-unit id="b1bca5853c9e5fa5adb4f19b1edc9ad3fc182540" translate="yes" xml:space="preserve">
          <source>The value returned from the</source>
          <target state="translated">返回的值</target>
        </trans-unit>
        <trans-unit id="90d9e575a1b77ab1385aca4b943feac671ed7f01" translate="yes" xml:space="preserve">
          <source>The value returned is the new-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">返回的值是新样式（请参见&lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;旧样式块名称与新样式块名称&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c04520f682b85fb43c817253d00adbc0066c3e0a" translate="yes" xml:space="preserve">
          <source>The value returned is the scalar itself, if the argument is a scalar, or a reference, if the argument is a hash, array or subroutine.</source>
          <target state="translated">如果参数是标量,返回的值是标量本身;如果参数是哈希、数组或子程序,返回的值是引用。</target>
        </trans-unit>
        <trans-unit id="942e5b04dedd3b9d9ca5012565213fea51195584" translate="yes" xml:space="preserve">
          <source>The value returned should correspond to the new text to use in its place If the empty string is returned or an undefined value is returned, then the given &lt;code&gt;$text&lt;/code&gt; is ignored (not processed).</source>
          <target state="translated">返回的值应对应于要在其位置使用的新文本。如果返回空字符串或返回未定义的值，则忽略给定的 &lt;code&gt;$text&lt;/code&gt; （不处理）。</target>
        </trans-unit>
        <trans-unit id="8dccf8bfa93428dffce75a953ae318dc76ebcb1f" translate="yes" xml:space="preserve">
          <source>The value returned should correspond to the new text to use in its place. If the empty string or an undefined value is returned then no further processing will be performed for this line.</source>
          <target state="translated">返回的值应该与新的文本相对应。如果返回的是空字符串或未定义的值,则不会对这一行进行进一步处理。</target>
        </trans-unit>
        <trans-unit id="55279d7373f25daebc72a715903f6a4795228bf8" translate="yes" xml:space="preserve">
          <source>The value returned will be true if the &lt;code&gt;$paragraph&lt;/code&gt; and the rest of the text in the same section as &lt;code&gt;$paragraph&lt;/code&gt; should be selected (included) for processing; otherwise a false value is returned.</source>
          <target state="translated">如果返回值将是真实的 &lt;code&gt;$paragraph&lt;/code&gt; ，并在同一节作为文本的其余 &lt;code&gt;$paragraph&lt;/code&gt; 应选择（含税）进行处理; 否则返回错误值。</target>
        </trans-unit>
        <trans-unit id="10aaf64078984131d35f43803e32214eb7af6f36" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. It is invoked just before leaving the currently processed directory. It is called in void context with no arguments. The name of the current directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt; . This hook is handy for summarizing a directory, such as calculating its disk usage. When</source>
          <target state="translated">该值应为代码参考。它在离开当前处理的目录之前被调用。在没有参数的空上下文中调用它。当前目录的名称在 &lt;code&gt;$File::Find::dir&lt;/code&gt; 。该钩子可用于汇总目录，例如计算其磁盘使用情况。什么时候</target>
        </trans-unit>
        <trans-unit id="ddbdffc9717f2bba2ebf5303cd71401d0bf2a249" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;The wanted function&lt;/a&gt; below. The &lt;code&gt;&amp;amp;wanted&lt;/code&gt; subroutine is mandatory.</source>
          <target state="translated">该值应为代码参考。该代码参考在下面的&lt;a href=&quot;#The-wanted-function&quot;&gt;&amp;ldquo;所需函数&amp;rdquo;&lt;/a&gt;中进行了描述。在 &lt;code&gt;&amp;amp;wanted&lt;/code&gt; 子程序是强制性的。</target>
        </trans-unit>
        <trans-unit id="444cd91bd48610204aa4348a8cd314eec59c4347" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is used to preprocess the current directory. The name of the currently processed directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt; . Your preprocessing function is called after &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, but before the loop that calls the &lt;code&gt;wanted()&lt;/code&gt; function. It is called with a list of strings (actually file/directory names) and is expected to return a list of strings. The code can be used to sort the file/directory names alphabetically, numerically, or to filter out directory entries based on their name alone. When</source>
          <target state="translated">该值应为代码参考。此代码参考用于预处理当前目录。当前处理的目录的名称位于 &lt;code&gt;$File::Find::dir&lt;/code&gt; 。您的预处理函数在 &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 之后调用，但在调用 &lt;code&gt;wanted()&lt;/code&gt; 函数的循环之前调用。它使用字符串列表（实际上是文件/目录名称）进行调用，并期望返回字符串列表。该代码可用于按字母，数字顺序对文件/目录名称进行排序，或者仅根据名称来过滤目录条目。什么时候</target>
        </trans-unit>
        <trans-unit id="4b8d0d31a50d605febd9456f0c05a144d0e549cc" translate="yes" xml:space="preserve">
          <source>The value should be the complete TAP output.</source>
          <target state="translated">该值应该是完整的TAP输出。</target>
        </trans-unit>
        <trans-unit id="977d1c1fec14dab01803e1202ad5b70915c99932" translate="yes" xml:space="preserve">
          <source>The value supplied with &lt;code&gt;-Comment&lt;/code&gt; option can contain any character except NULL.</source>
          <target state="translated">&lt;code&gt;-Comment&lt;/code&gt; 选项提供的值可以包含除NULL之外的任何字符。</target>
        </trans-unit>
        <trans-unit id="5a33beea90e0c4b3cd6d3aa1b159094d2037e800" translate="yes" xml:space="preserve">
          <source>The value supplied with &lt;code&gt;-Name&lt;/code&gt; option can contain any character except NULL.</source>
          <target state="translated">&lt;code&gt;-Name&lt;/code&gt; 选项提供的值可以包含除NULL之外的任何字符。</target>
        </trans-unit>
        <trans-unit id="f1aeb63cc4cb0e101586c3105fecbdbf9caca8c2" translate="yes" xml:space="preserve">
          <source>The value supplied with the &lt;code&gt;Comment&lt;/code&gt; option can only contain ISO 8859-1 characters plus line-feed.</source>
          <target state="translated">&lt;code&gt;Comment&lt;/code&gt; 选项提供的值只能包含ISO 8859-1字符和换行符。</target>
        </trans-unit>
        <trans-unit id="56d224f65d33c0660d7f4661847cc1e8f860019d" translate="yes" xml:space="preserve">
          <source>The value supplied with the &lt;code&gt;Name&lt;/code&gt; option can only contain ISO 8859-1 characters.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Name&lt;/code&gt; 选项提供的值只能包含ISO 8859-1字符。</target>
        </trans-unit>
        <trans-unit id="5341e40485577e6df05a609244175f85c79fb195" translate="yes" xml:space="preserve">
          <source>The values are specified on the following format line in the same order as the picture fields. The expressions providing the values must be separated by commas. They are all evaluated in a list context before the line is processed, so a single list expression could produce multiple list elements. The expressions may be spread out to more than one line if enclosed in braces. If so, the opening brace must be the first token on the first line. If an expression evaluates to a number with a decimal part, and if the corresponding picture specifies that the decimal part should appear in the output (that is, any picture except multiple &quot;#&quot; characters &lt;b&gt;without&lt;/b&gt; an embedded &quot;.&quot;), the character used for the decimal point is determined by the current LC_NUMERIC locale if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect. This means that, if, for example, the run-time environment happens to specify a German locale, &quot;,&quot; will be used instead of the default &quot;.&quot;. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;#WARNINGS&quot;&gt;WARNINGS&lt;/a&gt; for more information.</source>
          <target state="translated">在以下格式行上以与图片字段相同的顺序指定这些值。提供值的表达式必须用逗号分隔。在处理该行之前，它们都在列表上下文中求值，因此单个列表表达式可以产生多个列表元素。如果用大括号括起来，则表达式可能会扩展到多行。如果是这样，则开括号必须是第一行上的第一个标记。如果表达式的计算结果为带小数部分的数字，并且相应的图片指定小数部分应出现在输出中（即，除多个&amp;ldquo;＃&amp;rdquo;字符外&lt;b&gt;没有&lt;/b&gt;嵌入&amp;ldquo;。&amp;rdquo;的任何图片），将使用该字符如果 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 语言环境，则小数点的位置由当前LC_NUMERIC语言环境确定有效。这意味着，例如，如果运行时环境碰巧指定了德语语言环境，则将使用&amp;ldquo;，&amp;rdquo;代替默认的&amp;ldquo;。&amp;rdquo;。有关更多信息，请参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;和&lt;a href=&quot;#WARNINGS&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bcd5bfa6286ea39c4bd9487ae2b5176bb3be48be" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;$^O&lt;/code&gt; on some of these platforms includes:</source>
          <target state="translated">在某些平台上， &lt;code&gt;$^O&lt;/code&gt; 的值包括：</target>
        </trans-unit>
        <trans-unit id="540bf16e20569214e1b31e52cdcbc4ee480d311c" translate="yes" xml:space="preserve">
          <source>The values pushed onto the return stack of the XSUB are actually mortal SV's. They are made mortal so that once the values are copied by the calling program, the SV's that held the returned values can be deallocated. If they were not mortal, then they would continue to exist after the XSUB routine returned, but would not be accessible. This is a memory leak.</source>
          <target state="translated">推送到XSUB返回栈的值实际上是凡人SV。将它们变成死值是为了当值被调用程序复制后,持有返回值的SV可以被重新定位。如果它们不是死的,那么在XSUB例程返回后,它们会继续存在,但不会被访问。这就是内存泄漏。</target>
        </trans-unit>
        <trans-unit id="e474878aa7db7e96c4629326d93b845326ef064e" translate="yes" xml:space="preserve">
          <source>The values stored in config.sh may be either single-quoted or double-quoted. Double-quoted strings are handy for those cases where you need to include escape sequences in the strings. To avoid runtime variable interpolation, any &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; characters are replaced by &lt;code&gt;\$&lt;/code&gt; and &lt;code&gt;\@&lt;/code&gt; , respectively. This isn't foolproof, of course, so don't embed &lt;code&gt;\$&lt;/code&gt; or &lt;code&gt;\@&lt;/code&gt; in double-quoted strings unless you're willing to deal with the consequences. (The slashes will end up escaped and the &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; will trigger variable interpolation)</source>
          <target state="translated">config.sh中存储的值可以是单引号或双引号。在需要在字符串中包含转义序列的情况下，双引号字符串很方便。为避免运行时变量插值，任何 &lt;code&gt;$&lt;/code&gt; 和 &lt;code&gt;@&lt;/code&gt; 字符分别用 &lt;code&gt;\$&lt;/code&gt; 和 &lt;code&gt;\@&lt;/code&gt; 代替。当然，这并不是万无一失的，因此，除非您愿意处理后果，否则不要在双引号字符串中嵌入 &lt;code&gt;\$&lt;/code&gt; 或 &lt;code&gt;\@&lt;/code&gt; 。 （斜杠将最终转义，而 &lt;code&gt;$&lt;/code&gt; 或 &lt;code&gt;@&lt;/code&gt; 将触发变量插值）</target>
        </trans-unit>
        <trans-unit id="c23b5412a89e9982acfd046a606aac6df7b125a8" translate="yes" xml:space="preserve">
          <source>The values stored in the hashes above are mostly the direct equivalent of their C counterpart. Like their C counterparts, all are set to a default values - that means you don't have to set</source>
          <target state="translated">上面的哈希值中存储的值大多直接等同于它们的C对应值。和它们的C语言对应的值一样,所有的值都被设置为一个默认值--这意味着你不需要设置</target>
        </trans-unit>
        <trans-unit id="9e6700989ab1dbf25d28d4fd1b763593cc3c720f" translate="yes" xml:space="preserve">
          <source>The values supplied with the &lt;code&gt;-Name&lt;/code&gt; and &lt;code&gt;-Comment&lt;/code&gt; options can contain multiple embedded nulls. The string written to the gzip header will consist of the characters up to, but not including, the first embedded NULL.</source>
          <target state="translated">&lt;code&gt;-Name&lt;/code&gt; 和 &lt;code&gt;-Comment&lt;/code&gt; 选项提供的值可以包含多个嵌入式null。写入gzip标头的字符串将包含直到但不包括第一个嵌入式NULL的字符。</target>
        </trans-unit>
        <trans-unit id="f4d39e5aa9ce36eff93868e0e7af4d9b6a02d8ec" translate="yes" xml:space="preserve">
          <source>The values supplied with the &lt;code&gt;-Name&lt;/code&gt; and &lt;code&gt;-Comment&lt;/code&gt; options cannot contain multiple embedded nulls.</source>
          <target state="translated">&lt;code&gt;-Name&lt;/code&gt; 和 &lt;code&gt;-Comment&lt;/code&gt; 选项提供的值不能包含多个嵌入式null。</target>
        </trans-unit>
        <trans-unit id="6344a1b12727e711425a7cd0809233875bc47e54" translate="yes" xml:space="preserve">
          <source>The values to be compared are always passed by reference and should not be modified.</source>
          <target state="translated">要比较的值总是通过引用传递的,不应该被修改。</target>
        </trans-unit>
        <trans-unit id="0a3bdf6ba268c4d17126cd579eaa00987525d1a3" translate="yes" xml:space="preserve">
          <source>The variable $ref may have referred to the subroutine &lt;code&gt;fred&lt;/code&gt; whenever the call to &lt;code&gt;SaveSub1&lt;/code&gt; was made but by the time &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called it now holds the number &lt;code&gt;47&lt;/code&gt; . Because we saved only a pointer to the original SV in &lt;code&gt;SaveSub1&lt;/code&gt; , any changes to $ref will be tracked by the pointer &lt;code&gt;rememberSub&lt;/code&gt; . This means that whenever &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called, it will attempt to execute the code which is referenced by the SV* &lt;code&gt;rememberSub&lt;/code&gt; . In this case though, it now refers to the integer &lt;code&gt;47&lt;/code&gt; , so expect Perl to complain loudly.</source>
          <target state="translated">变量$ REF可能称为子程序 &lt;code&gt;fred&lt;/code&gt; 每当调用 &lt;code&gt;SaveSub1&lt;/code&gt; 制成，而是由时间 &lt;code&gt;CallSavedSub1&lt;/code&gt; 现在被调用它拥有数 &lt;code&gt;47&lt;/code&gt; 。因为我们只保存一个指向原来的SV &lt;code&gt;SaveSub1&lt;/code&gt; ，至$ REF的任何更改将通过指针进行跟踪 &lt;code&gt;rememberSub&lt;/code&gt; 。这意味着只要 &lt;code&gt;CallSavedSub1&lt;/code&gt; 被调用，它会尝试执行这是由SV *所引用的代码 &lt;code&gt;rememberSub&lt;/code&gt; 。但是，在这种情况下，它现在引用整数 &lt;code&gt;47&lt;/code&gt; ，因此希望Perl大声抱怨。</target>
        </trans-unit>
        <trans-unit id="ad1d8279ad869db1c2929300f40e329172cf94dc" translate="yes" xml:space="preserve">
          <source>The variable contains the symbols defined by the C compiler alone. The symbols defined by cpp or by cc when it calls cpp are not in this list, see cppsymbols and cppccsymbols. The list is a space-separated list of symbol=value tokens.</source>
          <target state="translated">该变量包含C编译器单独定义的符号。cpp或cc调用cpp时定义的符号不在这个列表中,参见cppsymbols和cppccsymbols。该列表是一个以空格分隔的符号=值标记的列表。</target>
        </trans-unit>
        <trans-unit id="501db733d2ef38c039a965292ca77f71bc56d687" translate="yes" xml:space="preserve">
          <source>The variable contains the symbols defined by the C compiler when it calls cpp. The symbols defined by the cc alone or cpp alone are not in this list, see ccsymbols and cppsymbols. The list is a space-separated list of symbol=value tokens.</source>
          <target state="translated">该变量包含C编译器调用cpp时定义的符号。单独的cc或单独的cpp定义的符号不在这个列表中,参见ccsymbols和cppsymbols。该列表是一个以空格分隔的符号=值标记的列表。</target>
        </trans-unit>
        <trans-unit id="00b4b60fa439030036a66d7ff80e60844c78536a" translate="yes" xml:space="preserve">
          <source>The variable contains the symbols defined by the C preprocessor alone. The symbols defined by cc or by cc when it calls cpp are not in this list, see ccsymbols and cppccsymbols. The list is a space-separated list of symbol=value tokens.</source>
          <target state="translated">该变量包含C预处理器单独定义的符号。cc定义的符号或cc调用cpp时定义的符号不在这个列表中,参见ccsymbols和cppccsymbols。该列表是一个以空格分隔的符号=值标记的列表。</target>
        </trans-unit>
        <trans-unit id="83d3f8e3698f4e666192e80e4c4c129382375649" translate="yes" xml:space="preserve">
          <source>The variables &lt;code&gt;$@&lt;/code&gt; , &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$^E&lt;/code&gt; , and &lt;code&gt;$?&lt;/code&gt; contain information about different types of error conditions that may appear during execution of a Perl program. The variables are shown ordered by the &quot;distance&quot; between the subsystem which reported the error and the Perl process. They correspond to errors detected by the Perl interpreter, C library, operating system, or an external program, respectively.</source>
          <target state="translated">变量 &lt;code&gt;$@&lt;/code&gt; ， &lt;code&gt;$!&lt;/code&gt; ， &lt;code&gt;$^E&lt;/code&gt; 和 &lt;code&gt;$?&lt;/code&gt; 包含有关在Perl程序执行期间可能出现的不同类型错误条件的信息。按照报告错误的子系统与Perl进程之间的&amp;ldquo;距离&amp;rdquo;来按顺序显示变量。它们分别对应于Perl解释器，C库，操作系统或外部程序检测到的错误。</target>
        </trans-unit>
        <trans-unit id="d61a4e2ec2fd6a9d823c4ff48f24791a3afc0a43" translate="yes" xml:space="preserve">
          <source>The variables are thousands of characters long and you know that they don't change, and you need to wring out the last little bit of speed by having Perl skip testing for that. (There is a maintenance penalty for doing this, as mentioning &lt;code&gt;/o&lt;/code&gt; constitutes a promise that you won't change the variables in the pattern. If you do change them, Perl won't even notice.)</source>
          <target state="translated">变量的长度为数千个字符，您知道它们不会更改，因此您需要通过让Perl跳过测试来消耗最后一点速度。（这样做会导致维护损失，因为提到 &lt;code&gt;/o&lt;/code&gt; 意味着您不会更改模式中的变量。如果您进行更改，Perl甚至不会注意到。）</target>
        </trans-unit>
        <trans-unit id="11544c219d80b67a63dc9e0a8e442712e549045b" translate="yes" xml:space="preserve">
          <source>The variables&amp;mdash;such as &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; , and &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%&amp;ndash; &lt;/code&gt; &amp;mdash;that hold the text remembered in a pattern match. See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">变量（例如 &lt;code&gt;$1&lt;/code&gt; 和 &lt;code&gt;$2&lt;/code&gt; 以及 &lt;code&gt;%+&lt;/code&gt; 和 &lt;code&gt;%&amp;ndash; &lt;/code&gt; )用于保存在模式匹配中记忆的文本。请参见骆驼第5章&amp;ldquo;模式匹配&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="50b54417d53e0d1cfe584f4211726c367ffae98a" translate="yes" xml:space="preserve">
          <source>The variant of OS2::_control87() with default values good for handling exception mask: if no &lt;code&gt;mask&lt;/code&gt; , uses exception mask part of &lt;code&gt;new&lt;/code&gt; only. If no &lt;code&gt;new&lt;/code&gt; , disables all the floating point exceptions.</source>
          <target state="translated">具有默认值的OS2 :: _ control87（）的变体适用于处理异常掩码：如果没有 &lt;code&gt;mask&lt;/code&gt; ，则仅使用 &lt;code&gt;new&lt;/code&gt; 的异常掩码部分。如果没有 &lt;code&gt;new&lt;/code&gt; ，则禁用所有浮点异常。</target>
        </trans-unit>
        <trans-unit id="307e90e437dd1da42b4c1389ea6c9b26886479f7" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;extract_...&lt;/code&gt; subroutines may be used to extract a delimited substring, possibly after skipping a specified prefix string. By default, that prefix is optional whitespace (&lt;code&gt;/\s*/&lt;/code&gt; ), but you can change it to whatever you wish (see below).</source>
          <target state="translated">可能在跳过指定的前缀字符串之后，可以使用各种 &lt;code&gt;extract_...&lt;/code&gt; 子例程来提取分隔的子字符串。默认情况下，该前缀是可选的空格（ &lt;code&gt;/\s*/&lt;/code&gt; ），但是您可以将其更改为所需的任何空格（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="fc16009f09e3803367ecc5c2f24dcc5baf8339c5" translate="yes" xml:space="preserve">
          <source>The various MSWin32 Perl's can distinguish the OS they are running on via the value of the fifth element of the list returned from &lt;code&gt;Win32::GetOSVersion()&lt;/code&gt; . For example:</source>
          <target state="translated">各种MSWin32 Perl可以通过 &lt;code&gt;Win32::GetOSVersion()&lt;/code&gt; 返回的列表的第五个元素的值来区分正在运行的操作系统。例如：</target>
        </trans-unit>
        <trans-unit id="b5f8a6767121d40d53463b6246a6dc21454cdfba" translate="yes" xml:space="preserve">
          <source>The various named unary operators are treated as functions with one argument, with optional parentheses.</source>
          <target state="translated">各种命名的单子运算符都是作为有一个参数的函数来处理的,可选括号。</target>
        </trans-unit>
        <trans-unit id="8d7dece5f96deb4f2078174f4b6a63435a6090e8" translate="yes" xml:space="preserve">
          <source>The various options that can be specified are:</source>
          <target state="translated">可以指定的各种选项有:</target>
        </trans-unit>
        <trans-unit id="8f2d3209693f371a4dffdf7b8f3fc9b9432bc2c1" translate="yes" xml:space="preserve">
          <source>The various types of data aggregate form a natural hierarchy that facilitates the use of inheritance and polymorphism.</source>
          <target state="translated">各种类型的数据集合形成了一个自然的层次结构,方便了继承和多态的使用。</target>
        </trans-unit>
        <trans-unit id="7dcabdd4901aed0767d31bd0d04d8aa2ce24975f" translate="yes" xml:space="preserve">
          <source>The vast majority of problems that are reported in this area boil down to the fact that C strings are NULL terminated, whilst Perl strings are not. See &lt;a href=&quot;#DBM-FILTERS&quot;&gt;DBM FILTERS&lt;/a&gt; for a generic way to work around this problem.</source>
          <target state="translated">该领域中报告的绝大多数问题归结为C字符串以NULL终止，而Perl字符串不是NULL的事实。有关解决此问题的一般方法，请参见&lt;a href=&quot;#DBM-FILTERS&quot;&gt;DBM FILTERS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c55d44dd5a799dd5be32ea5b3f1cae585e95693" translate="yes" xml:space="preserve">
          <source>The vast majority of the code was written by Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; , Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafayette.edu&amp;gt;&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;&amp;lt;A.Koenig@franz.ww.TU-Berlin.DE&amp;gt;&lt;/code&gt; , Tim Bunce &lt;code&gt;&amp;lt;Tim.Bunce@ig.co.uk&amp;gt;&lt;/code&gt; . VMS support by Charles Bailey &lt;code&gt;&amp;lt;bailey@newman.upenn.edu&amp;gt;&lt;/code&gt; . OS/2 support by Ilya Zakharevich &lt;code&gt;&amp;lt;ilya@math.ohio-state.edu&amp;gt;&lt;/code&gt; . Mac support by Paul Schinder &lt;code&gt;&amp;lt;schinder@pobox.com&amp;gt;&lt;/code&gt; , and Thomas Wegner &lt;code&gt;&amp;lt;wegner_thomas@yahoo.com&amp;gt;&lt;/code&gt; . abs2rel() and rel2abs() written by Shigio Yamaguchi &lt;code&gt;&amp;lt;shigio@tamacom.com&amp;gt;&lt;/code&gt; , modified by Barrie Slaymaker &lt;code&gt;&amp;lt;barries@slaysys.com&amp;gt;&lt;/code&gt; . splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.</source>
          <target state="translated">绝大多数代码由Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; ，Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafayette.edu&amp;gt;&lt;/code&gt; ，AndreasK&amp;ouml;nig &lt;code&gt;&amp;lt;A.Koenig@franz.ww.TU-Berlin.DE&amp;gt;&lt;/code&gt; ，Tim Bunce &lt;code&gt;&amp;lt;Tim.Bunce@ig.co.uk&amp;gt;&lt;/code&gt; 。 Charles Bailey &lt;code&gt;&amp;lt;bailey@newman.upenn.edu&amp;gt;&lt;/code&gt; 提供的 VMS支持。 Ilya Zakharevich &lt;code&gt;&amp;lt;ilya@math.ohio-state.edu&amp;gt;&lt;/code&gt; 的 OS / 2支持。 Paul &lt;code&gt;&amp;lt;schinder@pobox.com&amp;gt;&lt;/code&gt; 和Thomas Wegner &lt;code&gt;&amp;lt;wegner_thomas@yahoo.com&amp;gt;&lt;/code&gt; 支持Mac 。由Shigio Yamaguchi &lt;code&gt;&amp;lt;shigio@tamacom.com&amp;gt;&lt;/code&gt; 编写的abs2rel（）和rel2abs（），由Barrie Slaymaker &lt;code&gt;&amp;lt;barries@slaysys.com&amp;gt;&lt;/code&gt; 修改。Barrie Slaymaker编写的splitpath（），splitdir（），catpath（）和catdir（）。</target>
        </trans-unit>
        <trans-unit id="d0a3f9b4fdc58bce9dc91ad1590ca608ffcca3cf" translate="yes" xml:space="preserve">
          <source>The veil of abstraction separating the &lt;b&gt;interface&lt;/b&gt; from the &lt;b&gt;implementation&lt;/b&gt; (whether enforced or not), which mandates that all access to an &lt;b&gt;object&lt;/b&gt;&amp;rsquo;s state be through &lt;b&gt;methods&lt;/b&gt; alone.</source>
          <target state="translated">抽象的面纱将&lt;b&gt;接口&lt;/b&gt;与&lt;b&gt;实现&lt;/b&gt;（无论是否实施）分开，它要求对&lt;b&gt;对象&lt;/b&gt;状态的所有访问都只能通过&lt;b&gt;方法进行&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="20efbe7543ae8d526c7c1a14310569f9dadb6162" translate="yes" xml:space="preserve">
          <source>The version identifier for an XS module. This is usually handled automatically by &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . See &lt;code&gt;XS_VERSION_BOOTCHECK&lt;/code&gt; .</source>
          <target state="translated">XS模块的版本标识符。这通常由 &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; 自动处理。参见 &lt;code&gt;XS_VERSION_BOOTCHECK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ddac7f13e9a2dc240c79129edea2cf74e24b8cc" translate="yes" xml:space="preserve">
          <source>The version number of the installed module - this will be &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the module had no (or unparsable) version number, or if the variable &lt;code&gt;$Module::Load::Conditional::FIND_VERSION&lt;/code&gt; was set to true. (See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section below for details)</source>
          <target state="translated">已安装模块的版本号- 如果模块没有（或无法解析）版本号，或者变量 &lt;code&gt;$Module::Load::Conditional::FIND_VERSION&lt;/code&gt; 设置为true ，则此版本号为 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。（有关详细信息，请参见下面的&amp;ldquo; &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; 部分）</target>
        </trans-unit>
        <trans-unit id="c7a46a8ab62276eba4b76cf2918d64eaf428fd45" translate="yes" xml:space="preserve">
          <source>The version of PA-RISC at the time of this document's last update is 2.0, which is also the last there will be. HP PA-RISC systems are usually referred to with model description &quot;HP 9000&quot;. The last CPU in this series is the PA-8900. Support for PA-RISC architectured machines officially ends as shown in the following table:</source>
          <target state="translated">PA-RISC在本文档最后一次更新时的版本是2.0,这也是最后一次更新。HP PA-RISC系统通常用型号说明 &quot;HP 9000 &quot;来表示。这个系列的最后一款CPU是PA-8900。对PA-RISC架构机器的支持正式结束,如下表所示。</target>
        </trans-unit>
        <trans-unit id="d9cdcafc4749e48949c53b1e0f4aeffeae610286" translate="yes" xml:space="preserve">
          <source>The version of ext() which is executed under VMS differs from the Unix-OS/2 version in several respects:</source>
          <target state="translated">在VMS下执行的ext()版本与Unix-OS/2版本在几个方面有所不同。</target>
        </trans-unit>
        <trans-unit id="fa000c815a6c1f4aa9d1d3cce6270062ea44f5d2" translate="yes" xml:space="preserve">
          <source>The version of ext() which is executed under Win32 differs from the Unix-OS/2 version in several respects:</source>
          <target state="translated">在Win32下执行的ext()版本与Unix-OS/2版本在几个方面有所不同。</target>
        </trans-unit>
        <trans-unit id="04c1fecbb3d585e94f9621773c665e2e2cd3f97d" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement Vstrings, to use &lt;a href=&quot;#isvstring&quot;&gt;isvstring&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="translated">您使用的perl版本未实现Vstrings，要使用&lt;a href=&quot;#isvstring&quot;&gt;isvstring，&lt;/a&gt;您将需要使用更新版本的perl。</target>
        </trans-unit>
        <trans-unit id="f8f3dd17d141437206c98482882771da9fd578da" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement weak references, to use &lt;a href=&quot;#isweak&quot;&gt;isweak&lt;/a&gt; or &lt;a href=&quot;#weaken&quot;&gt;weaken&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="translated">您使用的perl版本不会实现弱引用，要使用&lt;a href=&quot;#isweak&quot;&gt;isweak&lt;/a&gt;或&lt;a href=&quot;#weaken&quot;&gt;弱化，&lt;/a&gt;您将需要使用更新版本的perl。</target>
        </trans-unit>
        <trans-unit id="64bb3d6c21bf2a657e7026f0eee7644697eafb33" translate="yes" xml:space="preserve">
          <source>The version of the module distributed with Perl should, whenever possible, be the latest version of the module as distributed by the author (the latest non-beta version in the case of public Perl releases), although the pumpkin holder may hold off on upgrading the version of the module distributed with Perl to the latest version until the latest version has had sufficient testing.</source>
          <target state="translated">与Perl一起发布的模块版本,应尽可能是作者发布的模块的最新版本(如果是公开的Perl版本,则是最新的非beta版本),不过,南瓜的持有者可以暂缓将与Perl一起发布的模块版本升级到最新版本,直到最新版本经过充分的测试。</target>
        </trans-unit>
        <trans-unit id="b21f22d5179989f705ed9d6a2a79b769acbc417d" translate="yes" xml:space="preserve">
          <source>The version of the module in the Perl core should still be considered the work of the original author. All patches, bug reports, and so forth should be fed back to them. Their development directions should be respected whenever possible.</source>
          <target state="translated">Perl核心中的模块版本仍然应该被认为是原作者的作品。所有的补丁、错误报告等等都应该反馈给他们。他们的开发方向应尽可能得到尊重。</target>
        </trans-unit>
        <trans-unit id="92d384762292f03ed396ad91a060564bf7d9627e" translate="yes" xml:space="preserve">
          <source>The version this module needs to be -- this is optional</source>
          <target state="translated">该模块需要的版本 ----这是可选的。</target>
        </trans-unit>
        <trans-unit id="7c293dc4ef8b29552aa12216990ef31577ac2eeb" translate="yes" xml:space="preserve">
          <source>The versions of as and ld supplied with Solaris work fine for building perl. There is normally no need to install the GNU versions to compile perl.</source>
          <target state="translated">Solaris 提供的 as 和 ld 版本可以很好地用于编译 perl。通常不需要安装GNU版本来编译perl。</target>
        </trans-unit>
        <trans-unit id="991e6e65f67b3a36b7e485bd86d8f440ac42e72f" translate="yes" xml:space="preserve">
          <source>The very end of the document:</source>
          <target state="translated">文件的最后。</target>
        </trans-unit>
        <trans-unit id="c59ec45ae7f53d6bfeaac3f5d1524ea40228db75" translate="yes" xml:space="preserve">
          <source>The very first thing you should do is look into getting the Term::ReadKey extension from CPAN. As we mentioned earlier, it now even has limited support for non-portable (read: not open systems, closed, proprietary, not POSIX, not Unix, etc.) systems.</source>
          <target state="translated">你应该做的第一件事就是研究从CPAN中获取Term::ReadKey扩展。正如我们前面提到的,它现在甚至对非可移植系统(读作:非开放系统、封闭的、专有的、非POSIX、非Unix等)系统有有限的支持。</target>
        </trans-unit>
        <trans-unit id="a54a90d3a077b2809332364bbb3b822680082301" translate="yes" xml:space="preserve">
          <source>The volume portion is always returned with a trailing &quot;:&quot;. The directory portion is always returned with a leading (to denote a relative path) and a trailing &quot;:&quot; (to denote a directory). The file portion is always returned</source>
          <target state="translated">卷的部分总是以尾部的&quot;:&quot;来返回。目录部分总是以一个前导(表示相对路径)和一个尾部的&quot;:&quot;(表示目录)返回。文件的部分总是以前面的&quot;:&quot;和后面的&quot;:&quot;(表示一个目录)返回。</target>
        </trans-unit>
        <trans-unit id="1ec332efc336ec299c7acc49f0d1e2fc497986e3" translate="yes" xml:space="preserve">
          <source>The wanted function</source>
          <target state="translated">想要的功能</target>
        </trans-unit>
        <trans-unit id="6125dd5f3b647dbf86db0b504a3821e5fb95de7e" translate="yes" xml:space="preserve">
          <source>The wanted function takes no arguments but rather does its work through a collection of variables.</source>
          <target state="translated">想要的函数不接受参数,而是通过变量集合来完成工作。</target>
        </trans-unit>
        <trans-unit id="badd12b3cb878c5659d7f27917ce9ac00752a63d" translate="yes" xml:space="preserve">
          <source>The warning is considered severe enough not to be affected by the &lt;b&gt;-w&lt;/b&gt; switch (or its absence) because previously compiled invocations of the function will still be using the old value of the function. If you need to be able to redefine the subroutine, you need to ensure that it isn't inlined, either by dropping the &lt;code&gt;()&lt;/code&gt; prototype (which changes calling semantics, so beware) or by thwarting the inlining mechanism in some other way, e.g. by adding an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;, as mentioned above:</source>
          <target state="translated">该警告被认为足够严重，不会受到&lt;b&gt;-w&lt;/b&gt;开关的影响（或其缺失），因为以前编译的函数调用仍将使用该函数的旧值。如果需要能够重新定义该子例程，则需要通过删除 &lt;code&gt;()&lt;/code&gt; 原型（更改调用语义，因此要当心）或通过以其他方式阻止该内联机制的方式，确保不对它进行内联。通过添加显式 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; ，如上所述：</target>
        </trans-unit>
        <trans-unit id="228748e063ab0367333a5d358a372ffaa2776b68" translate="yes" xml:space="preserve">
          <source>The way I see this being used is like basically this:</source>
          <target state="translated">我看到的使用方式基本上是这样的。</target>
        </trans-unit>
        <trans-unit id="bf8410bbe832531f3fd9213bd8f3ba1287e55dc6" translate="yes" xml:space="preserve">
          <source>The way Perl builds up these op trees in the parsing process can be unravelled by examining</source>
          <target state="translated">Perl在解析过程中建立这些运算树的方式,可以通过检查一下</target>
        </trans-unit>
        <trans-unit id="b9a4e5fa4cbdb6cec50f6eac70c4ad531843cef7" translate="yes" xml:space="preserve">
          <source>The way Test::More handles this is with a named block. Basically, a block of tests which can be skipped over or made todo. It's best if I just show you...</source>
          <target state="translated">Test::More 处理这个问题的方式是使用命名块。基本上,一个测试块可以被跳过或成为todo。最好的办法是我向你展示......</target>
        </trans-unit>
        <trans-unit id="3a44ce079c4bba6650cbd971c39500928ccb7c22" translate="yes" xml:space="preserve">
          <source>The way a program responds to an error. The exception-handling mechanism in Perl is the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">程序对错误的响应方式。Perl中的异常处理机制是 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="39341ae7c243431172aa717f037dcb000913133f" translate="yes" xml:space="preserve">
          <source>The way it resolves which actual method to call is:</source>
          <target state="translated">它解决实际调用哪个方法的方式是。</target>
        </trans-unit>
        <trans-unit id="2ecf3674cf5632aa049fa7e267f9fbd82a5b7877" translate="yes" xml:space="preserve">
          <source>The way it works is that when the &lt;code&gt;@{...}&lt;/code&gt; is seen in the double-quoted string, it's evaluated as a block. The block creates a reference to an anonymous array containing the results of the call to &lt;code&gt;mysub(1,2,3)&lt;/code&gt; . So the whole block returns a reference to an array, which is then dereferenced by &lt;code&gt;@{...}&lt;/code&gt; and stuck into the double-quoted string. This chicanery is also useful for arbitrary expressions:</source>
          <target state="translated">它的工作方式是，在双引号字符串中看到 &lt;code&gt;@{...}&lt;/code&gt; ，它将被视为一个块。该块创建对匿名数组的引用，该数组包含对 &lt;code&gt;mysub(1,2,3)&lt;/code&gt; 的调用结果。因此，整个块将返回对数组的引用，然后使用 &lt;code&gt;@{...}&lt;/code&gt; 将其取消引用并粘贴到双引号字符串中。此chicanery还可用于任意表达式：</target>
        </trans-unit>
        <trans-unit id="464aa10ca9c1c0eb18ad0b5fbb41c9f2af8f5587" translate="yes" xml:space="preserve">
          <source>The way this trick works is that the character with the code point &lt;code&gt;U+FFFE&lt;/code&gt; is not supposed to be in input streams, so the sequence of bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt; is unambiguously &quot;&lt;code&gt;BOM&lt;/code&gt; , represented in little-endian format&quot; and cannot be &lt;code&gt;U+FFFE&lt;/code&gt; , represented in big-endian format&quot;.</source>
          <target state="translated">此技巧的工作方式是，不应认为代码点为 &lt;code&gt;U+FFFE&lt;/code&gt; 的字符在输入流中，因此字节序列 &lt;code&gt;0xFF 0xFE&lt;/code&gt; 明确为&amp;ldquo; &lt;code&gt;BOM&lt;/code&gt; ，以小尾数格式表示&amp;rdquo;并且不能为 &lt;code&gt;U+FFFE&lt;/code&gt; ，以big-endian格式表示&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5898f48e7b39c1a379ea1247c549323ccbb46061" translate="yes" xml:space="preserve">
          <source>The way to get around this problem is to use the Berkeley DB API method called &lt;code&gt;seq&lt;/code&gt; . This method allows sequential access to key/value pairs. See &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;THE API INTERFACE&lt;/a&gt; for details of both the &lt;code&gt;seq&lt;/code&gt; method and the API in general.</source>
          <target state="translated">解决此问题的方法是使用称为 &lt;code&gt;seq&lt;/code&gt; 的Berkeley DB API方法。此方法允许顺序访问键/值对。有关 &lt;code&gt;seq&lt;/code&gt; 方法和一般&lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;API&lt;/a&gt;的详细信息，请参见API接口。</target>
        </trans-unit>
        <trans-unit id="cd500d8c20565e5f312bdd0b6574f8c8052649e9" translate="yes" xml:space="preserve">
          <source>The way to use this class is to make a new object of this class, set any options, and then call one of the search options (probably &lt;code&gt;survey&lt;/code&gt; or &lt;code&gt;find&lt;/code&gt; ). The sections below discuss the syntaxes for doing all that.</source>
          <target state="translated">使用此类的方法是创建该类的新对象，设置任何选项，然后调用搜索选项之一（可能是 &lt;code&gt;survey&lt;/code&gt; 或 &lt;code&gt;find&lt;/code&gt; ）。以下各节讨论了执行所有操作的语法。</target>
        </trans-unit>
        <trans-unit id="5268c05807fff3d270f4531a0cd21a77634cf686" translate="yes" xml:space="preserve">
          <source>The web server handling the HTTP service is assumed to be at its standard port, number 80. If the server you're trying to connect to is at a different port, like 1080 or 8080, you should specify it as the named-parameter pair, &lt;code&gt;PeerPort =&amp;gt; 8080&lt;/code&gt; . The &lt;code&gt;autoflush&lt;/code&gt; method is used on the socket because otherwise the system would buffer up the output we sent it. (If you're on a prehistoric Mac, you'll also need to change every &lt;code&gt;&quot;\n&quot;&lt;/code&gt; in your code that sends data over the network to be a &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; instead.)</source>
          <target state="translated">假定处理HTTP服务的Web服务器位于其标准端口80上。如果您要连接的服务器位于其他端口（例如1080或8080），则应将其指定为&amp;ldquo;命名参数对&amp;rdquo; ， &lt;code&gt;PeerPort =&amp;gt; 8080&lt;/code&gt; 。该 &lt;code&gt;autoflush&lt;/code&gt; 方法用于在插座上，因为否则系统缓存起来，我们送了它的输出。（如果您使用的是史前Mac，则还需要将代码中通过网络发送数据的每个 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 更改为 &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="b22573d6d6dbb31578b3c4fa9e8a17816a358dfc" translate="yes" xml:space="preserve">
          <source>The well known Unicode Byte Order Marks are as follows: if the file begins with the two literal byte values 0xFE 0xFF, this is the BOM for big-endian UTF-16. If the file begins with the two literal byte value 0xFF 0xFE, this is the BOM for little-endian UTF-16. On an ASCII platform, if the file begins with the three literal byte values 0xEF 0xBB 0xBF, this is the BOM for UTF-8. A mechanism portable to EBCDIC platforms is to:</source>
          <target state="translated">众所周知的Unicode字节序号如下:如果文件以两个文字字节值0xFE 0xFF开始,这就是大字段UTF-16的BOM,如果文件以两个文字字节值0xFF 0xFE开始,这就是小字段UTF-16的BOM。如果文件以两个字面字节值0xFF 0xFE开始,这就是小字面UTF-16的BOM。在ASCII平台上,如果文件以三个文字字节值0xEF 0xBB 0xBF开始,这就是UTF-8的BOM。一个可移植到EBCDIC平台的机制是:。</target>
        </trans-unit>
        <trans-unit id="c25fe7dd72c3069b0e017baa01097278ab17f62e" translate="yes" xml:space="preserve">
          <source>The while loop from line 14 to line 26 grabs a scalar off the input queue and checks against the prime this thread is responsible for. Line 15 checks to see if there's a remainder when we divide the number to be checked by our prime. If there is one, the number must not be evenly divisible by our prime, so we need to either pass it on to the next thread if we've created one (line 17) or create a new thread if we haven't.</source>
          <target state="translated">从第14行到第26行的while循环从输入队列中抓取一个标量,并根据这个线程负责的质数进行检查。第15行检查当我们用质数除以要检查的数字时是否有余数。如果有余数,那么这个数字一定不能被我们的质数平均分割,所以我们需要把它传递给下一个线程,如果我们已经创建了一个线程(第17行),或者创建一个新的线程,如果我们没有创建。</target>
        </trans-unit>
        <trans-unit id="a997f7e1957d2b943d666798431c61228059e247" translate="yes" xml:space="preserve">
          <source>The whole Unicode standard &lt;a href=&quot;http://www.unicode.org/unicode/uni2book/u2.html&quot;&gt;http://www.unicode.org/unicode/uni2book/u2.html&lt;/a&gt;</source>
          <target state="translated">整个Unicode标准&lt;a href=&quot;http://www.unicode.org/unicode/uni2book/u2.html&quot;&gt;http://www.unicode.org/unicode/uni2book/u2.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52ed5e8abe2195d94e62a75cf32bf369a78b18af" translate="yes" xml:space="preserve">
          <source>The whole idea of the &quot;standard C API to start applications&quot; is that the forms &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;&quot;foo&quot;&lt;/code&gt; of program arguments are completely interchangeable.</source>
          <target state="translated">&amp;ldquo;用于启动应用程序的标准C API&amp;rdquo;的整个思想是程序参数的形式 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 是完全可互换的。</target>
        </trans-unit>
        <trans-unit id="0fe54c442e0898f0c65d2e7e96e6d557275adef9" translate="yes" xml:space="preserve">
          <source>The whole scheme for interpreting two-digit years can be considered a bug.</source>
          <target state="translated">解释两位数年份的整个方案可以说是一个bug。</target>
        </trans-unit>
        <trans-unit id="d301a149055986dea057eaf7f10ce99a292fd767" translate="yes" xml:space="preserve">
          <source>The width of the left margin in spaces. Defaults to 0. This is the margin for all text, including headings, not the amount by which regular text is indented; for the latter, see &lt;b&gt;-i&lt;/b&gt; option.</source>
          <target state="translated">空格中左边距的宽度。默认值为0。这是所有文本（包括标题）的边距，而不是常规文本缩进的量；对于后者，请参见&lt;b&gt;-i&lt;/b&gt;选项。</target>
        </trans-unit>
        <trans-unit id="00b688a33a04cf250468fb3feaca19bab2ec26fc" translate="yes" xml:space="preserve">
          <source>The width of the left margin in spaces. Defaults to 0. This is the margin for all text, including headings, not the amount by which regular text is indented; for the latter, see the</source>
          <target state="translated">左边距的宽度,以空格为单位,默认为0。默认值为0,这是所有文本的页边距,包括标题,而不是常规文本的缩进量;关于后者,请参见本手册中的</target>
        </trans-unit>
        <trans-unit id="9f8ba2c52e40b69413c01ffc592fe399547fc20f" translate="yes" xml:space="preserve">
          <source>The word returned by the &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; function when you apply it to a reference to a subroutine. See also &lt;b&gt;CV&lt;/b&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 函数将其应用于子例程的引用时返回的单词。另请参阅&lt;b&gt;CV&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="28be5b370df296bc57d076e1c2849a0ebee70013" translate="yes" xml:space="preserve">
          <source>The work isn't over until the paperwork is done, and you're going to need to put in some time writing some documentation for your module. &lt;code&gt;module-starter&lt;/code&gt; or &lt;code&gt;h2xs&lt;/code&gt; will provide a stub for you to fill in; if you're not sure about the format, look at &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; for an introduction. Provide a good synopsis of how your module is used in code, a description, and then notes on the syntax and function of the individual subroutines or methods. Use Perl comments for developer notes and POD for end-user notes.</source>
          <target state="translated">文书工作完成之前，工作还没有结束，您将需要花一些时间为模块编写一些文档。 &lt;code&gt;module-starter&lt;/code&gt; 或 &lt;code&gt;h2xs&lt;/code&gt; 将提供一个存根供您填写；如果您不确定格式，请查看&lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;进行介绍。提供有关如何在代码中使用模块的简要说明，说明，然后说明各个子例程或方法的语法和功能。将Perl注释用于开发人员注释，将POD用于最终用户注释。</target>
        </trans-unit>
        <trans-unit id="1436e107c02b49fba4e33d8aaae3115ec601983a" translate="yes" xml:space="preserve">
          <source>The work of the interpreter has two main stages: compiling the code into the internal representation, or bytecode, and then executing it. &lt;a href=&quot;perlguts#Compiled-code&quot;&gt;Compiled code in perlguts&lt;/a&gt; explains exactly how the compilation stage happens.</source>
          <target state="translated">解释器的工作分为两个主要阶段：将代码编译成内部表示形式或字节码，然后执行它。&lt;a href=&quot;perlguts#Compiled-code&quot;&gt;perlguts中的编译代码&lt;/a&gt;准确地解释了编译阶段是如何发生的。</target>
        </trans-unit>
        <trans-unit id="8b1397bff51f75db954e0f3e3e1b665db01ca7e8" translate="yes" xml:space="preserve">
          <source>The world's languages are written in many different scripts. This sentence (unless you're reading it in translation) is written in Latin, while Russian is written in Cyrillic, and Greek is written in, well, Greek; Japanese mainly in Hiragana or Katakana. There are many more.</source>
          <target state="translated">世界上的语言是用许多不同的文字书写的。这句话(除非你读的是翻译)是用拉丁文写的,而俄语是用西里尔文写的,希腊文是用,嗯,希腊语写的;日语主要是用平假名或片假名。还有很多。</target>
        </trans-unit>
        <trans-unit id="85da59eaf7698f05d48c68376bdd4ba3b6dce3bd" translate="yes" xml:space="preserve">
          <source>The worst patches make use of system-specific features. It's highly unlikely that non-portable additions to the Perl language will be accepted.</source>
          <target state="translated">最糟糕的补丁利用了系统特有的功能。在Perl语言中添加不可移植的功能是不太可能被接受的。</target>
        </trans-unit>
        <trans-unit id="2affe5ea5db32cf7d355e39106992f04132aac2d" translate="yes" xml:space="preserve">
          <source>The write filehandle will have autoflush turned on.</source>
          <target state="translated">写入文件柄将开启自动刷新功能。</target>
        </trans-unit>
        <trans-unit id="f34726284c86402203e3588790fd3c449c8531b5" translate="yes" xml:space="preserve">
          <source>The yacc coming with BS2000 POSIX didn't work for us. So we had to use bison. We had to make a few changes to perl in order to use the pure (reentrant) parser of bison. We used version 1.25, but we had to add a few changes due to EBCDIC. See below for more details concerning yacc.</source>
          <target state="translated">BS2000 POSIX自带的yacc对我们不起作用。所以我们不得不使用 bison。我们不得不对perl做了一些修改,以便使用bison的纯(reentrant)解析器。我们使用的是1.25版本,但由于EBCDIC的原因,我们不得不增加了一些改动。关于yacc的更多细节请看下文。</target>
        </trans-unit>
        <trans-unit id="0aff817087165151aec8e0b6db814baaf554f377" translate="yes" xml:space="preserve">
          <source>The z/OS Unix Tools and Toys list may prove helpful and contains links to ports of much of the software helpful for building Perl. &lt;a href=&quot;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&quot;&gt;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&lt;/a&gt;</source>
          <target state="translated">z / OS Unix工具和玩具列表可能会有所帮助，并且包含指向许多有助于构建Perl的软件端口的链接。&lt;a href=&quot;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&quot;&gt;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f215722614928e4a382d634f12d1b784a861305a" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;$reg&lt;/code&gt; can be used as a regexp:</source>
          <target state="translated">然后 &lt;code&gt;$reg&lt;/code&gt; 可以用作正则表达式：</target>
        </trans-unit>
        <trans-unit id="de5ca28d4aa169910f5c4821c56dad5137cddc68" translate="yes" xml:space="preserve">
          <source>Then again, you could always use parentheses.</source>
          <target state="translated">不过,你也可以一直用括号。</target>
        </trans-unit>
        <trans-unit id="8f720f0ca68279a1e213df21b730afd59a9417d5" translate="yes" xml:space="preserve">
          <source>Then along comes Unicode which has room for over a million characters (and Perl allows for even more). This means that a character may require more than a single byte to represent it, and so the two terms are no longer equivalent. What matter are the characters as whole entities, and not usually the bytes that comprise them. That's what the term &quot;Character Semantics&quot; in the title of this section refers to.</source>
          <target state="translated">然后出现了Unicode,它有超过一百万个字符的空间(Perl允许更多的字符)。这意味着一个字符可能需要超过一个字节来表示它,因此这两个术语不再是等价的。重要的是作为整体实体的字符,而不是通常由它们组成的字节。这就是本节标题中 &quot;字符语义 &quot;一词的含义。</target>
        </trans-unit>
        <trans-unit id="48ff6c17f5c4132eb7b4e146224751484821d774" translate="yes" xml:space="preserve">
          <source>Then compile:</source>
          <target state="translated">然后编译。</target>
        </trans-unit>
        <trans-unit id="894eab3b8839b7526298878f8b7e43bb55872aae" translate="yes" xml:space="preserve">
          <source>Then copy setargv.obj to %PlatformSDKDir%\lib</source>
          <target state="translated">然后将setargv.obj复制到%PlatformSDKDir%/lib。</target>
        </trans-unit>
        <trans-unit id="939d22a5767f7f1b738027999de54521a98a4c28" translate="yes" xml:space="preserve">
          <source>Then delete every .bundle file found anywhere in the folders:</source>
          <target state="translated">然后删除文件夹中任何地方发现的所有.bundle文件。</target>
        </trans-unit>
        <trans-unit id="072381135845bbd0f86b6799cfa84f6d7fbff38f" translate="yes" xml:space="preserve">
          <source>Then go on to declare and use your variables in functions without any qualifications. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; and the &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for details on mechanics and style issues in module creation.</source>
          <target state="translated">然后继续声明并在函数中使用您的变量而没有任何限制。有关模块创建中的机制和样式问题的详细信息，请参见&lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;和&lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5bcffa804562972342cabda61bf0a405b76b432e" translate="yes" xml:space="preserve">
          <source>Then move the files (probably just the</source>
          <target state="translated">然后移动文件(可能只是</target>
        </trans-unit>
        <trans-unit id="16764d0cdf61fb44dac45d466795c94ebcc324fb" translate="yes" xml:space="preserve">
          <source>Then override the &lt;code&gt;start_for&lt;/code&gt; method in the subclass to check for when &quot;$flags-&amp;gt;{'target'}&quot; is equal to 'foo' and set a flag that marks that you're in a foo block (maybe &quot;$self-&amp;gt;{'in_foo'} = 1&quot;). Then override the &lt;code&gt;handle_text&lt;/code&gt; method to check for the flag, and pass $text to your custom subroutine to construct the HTML output for 'foo' elements, something like:</source>
          <target state="translated">然后在子类中重写 &lt;code&gt;start_for&lt;/code&gt; 方法，以检查&amp;ldquo; $ flags- &amp;gt; {'target'}&amp;rdquo;何时等于&amp;ldquo; foo&amp;rdquo;，并设置一个标志，以标记您在foo块中（也许是&amp;ldquo; $ self-&amp;gt; {'in_foo'} = 1&amp;ldquo;）。然后重写 &lt;code&gt;handle_text&lt;/code&gt; 方法以检查标志，然后将$ text传递给您的自定义子例程以构造'foo'元素的HTML输出，如下所示：</target>
        </trans-unit>
        <trans-unit id="5906927423d13fecbc7d429a1e04d7524ab55ae4" translate="yes" xml:space="preserve">
          <source>Then run the following script (or something like it):</source>
          <target state="translated">然后运行以下脚本(或类似的脚本)。</target>
        </trans-unit>
        <trans-unit id="dc813daf18229cd1ceaa147ef073875823c78936" translate="yes" xml:space="preserve">
          <source>Then that text and all remaining text up through and including a line beginning with &lt;code&gt;=cut&lt;/code&gt; will be ignored. The format of the intervening text is described in &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;.</source>
          <target state="translated">然后，该文本以及所有直到并包括以 &lt;code&gt;=cut&lt;/code&gt; 开头的行的所有剩余文本将被忽略。插入文本的格式在&lt;a href=&quot;perlpod&quot;&gt;perlpod中进行了&lt;/a&gt;描述。</target>
        </trans-unit>
        <trans-unit id="8606c2212e120ef5c1865576f0176c5b8ada5faa" translate="yes" xml:space="preserve">
          <source>Then the assignment with the indirection on the left-hand-side would use the existing reference that was already there:</source>
          <target state="translated">然后,左手边带有间接性的赋值将使用已有的引用。</target>
        </trans-unit>
        <trans-unit id="8207f190aea8ef5aad0fa43cccb20c94bdffd926" translate="yes" xml:space="preserve">
          <source>Then the handler makes absolutely no attempt to interpret the data it receives and simply passes it as a string:</source>
          <target state="translated">然后,处理程序完全不试图解释它所收到的数据,而只是将其作为一个字符串传递。</target>
        </trans-unit>
        <trans-unit id="724e763cfec8edb999475aec0cbf98b0b938163f" translate="yes" xml:space="preserve">
          <source>Then the match is executed and the remaining lines describe the process:</source>
          <target state="translated">然后执行匹配,余下的行文描述过程。</target>
        </trans-unit>
        <trans-unit id="581e9b63d178af7824ad52db20f4431ce7a1a3ec" translate="yes" xml:space="preserve">
          <source>Then use any of those as you would a normal filehandle. Anywhere that Perl is expecting a filehandle, an indirect filehandle may be used instead. An indirect filehandle is just a scalar variable that contains a filehandle. Functions like &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, or the &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; diamond operator will accept either a named filehandle or a scalar variable containing one:</source>
          <target state="translated">然后像使用普通文件句柄一样使用其中任何一个。Perl期望文件句柄的任何地方，都可以使用间接文件句柄代替。间接文件句柄只是包含文件句柄的标量变量。诸如 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; diamond运算符之类的函数将接受命名的文件句柄或包含一个的标量变量：</target>
        </trans-unit>
        <trans-unit id="be01a69ef7dc497f6d53fec0422df0742cb41c46" translate="yes" xml:space="preserve">
          <source>Then use it like:</source>
          <target state="translated">然后像这样使用。</target>
        </trans-unit>
        <trans-unit id="3068081feb5a0d3d89b7875b7ddf972f866ffeca" translate="yes" xml:space="preserve">
          <source>Then when you call $lh-&amp;gt;maketext(</source>
          <target state="translated">然后当您调用$ lh-&amp;gt; maketext（</target>
        </trans-unit>
        <trans-unit id="4174f8d83f029a8fa078cc1b0e4b602d5427b4d7" translate="yes" xml:space="preserve">
          <source>Then you can progress through any remaining notable Unicode characters in the range 0x2000-0x204D (consult the character tables at www.unicode.org), and whatever else strikes your fancy. For example, in</source>
          <target state="translated">然后,你可以通过0x2000-0x204D范围内的任何剩余的著名Unicode字符(参考www.unicode.org),以及其他任何你喜欢的字符。例如,在</target>
        </trans-unit>
        <trans-unit id="84a1243ca0e6b4d4a37040b980b310d461ab4076" translate="yes" xml:space="preserve">
          <source>Then you can use &lt;code&gt;FH&lt;/code&gt; as the filehandle, in &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; and &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; and so on. Note that it's a global variable, so this form is not recommended in new code.</source>
          <target state="translated">然后，可以将 &lt;code&gt;FH&lt;/code&gt; 用作文件句柄，并以 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; 和 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; &lt;a href=&quot;close&quot;&gt;关闭&lt;/a&gt;。请注意，这是一个全局变量，因此在新代码中不建议使用此形式。</target>
        </trans-unit>
        <trans-unit id="c81a39d78bb4e09ef8b273b017dac3466493479a" translate="yes" xml:space="preserve">
          <source>Then you can use &lt;code&gt;FH&lt;/code&gt; as the filehandle, in &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; and &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; and so on. Note that it's a global variable, so this form is not recommended in new code.</source>
          <target state="translated">然后，可以将 &lt;code&gt;FH&lt;/code&gt; 用作文件句柄，并以 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; 和 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; &lt;a href=&quot;functions/close&quot;&gt;关闭&lt;/a&gt;。请注意，这是一个全局变量，因此在新代码中不建议使用此形式。</target>
        </trans-unit>
        <trans-unit id="aceabb34e67cf540951bd4247eacd0dbbabee283" translate="yes" xml:space="preserve">
          <source>Then you'll need to know how to manipulate the Perl stack. That's described in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">然后，您将需要知道如何操作Perl堆栈。这在&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;中有所描述。</target>
        </trans-unit>
        <trans-unit id="a9e623e714cffb21ba3a72f8e67c6ce57fe9270e" translate="yes" xml:space="preserve">
          <source>Then you'll need to pass the &lt;code&gt;nocase&lt;/code&gt; option in order to recognize &quot;Name&quot;:</source>
          <target state="translated">然后，您需要传递 &lt;code&gt;nocase&lt;/code&gt; 选项以识别&amp;ldquo;名称&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="5eea4f63f47d5b222c66289e4dec5701bc66810a" translate="yes" xml:space="preserve">
          <source>Then you've just supplied an automatic &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; in front of their argument, which can be more than a bit surprising. The old &lt;code&gt;@foo&lt;/code&gt; which used to hold one thing doesn't get passed in. Instead, &lt;code&gt;func()&lt;/code&gt; now gets passed in a &lt;code&gt;1&lt;/code&gt; ; that is, the number of elements in &lt;code&gt;@foo&lt;/code&gt; . And the &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; gets called in scalar context so it starts scribbling on your &lt;code&gt;@_&lt;/code&gt; parameter list. Ouch!</source>
          <target state="translated">然后，您只需在其参数前面提供一个自动 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; ，这可能会有点令人惊讶。过去用来保存一件事的 &lt;code&gt;@foo&lt;/code&gt; 不会传递。相反， &lt;code&gt;func()&lt;/code&gt; 现在传递为 &lt;code&gt;1&lt;/code&gt; ；即 &lt;code&gt;@foo&lt;/code&gt; 中的元素数。并且 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 在标量上下文中被调用，因此它开始在您的 &lt;code&gt;@_&lt;/code&gt; 参数列表上进行书写。哎哟!</target>
        </trans-unit>
        <trans-unit id="ee85b5d75e24b7f6cf7782bfc085bcfc0c87d6f5" translate="yes" xml:space="preserve">
          <source>Then, it determines the class and method name of the context it was invoked from.</source>
          <target state="translated">然后,它确定它被调用的上下文的类和方法名。</target>
        </trans-unit>
        <trans-unit id="4d80e1f2d5ca1daef620a79f94100cd3a43dcad2" translate="yes" xml:space="preserve">
          <source>There appears to be a bug in the floating point implementation on BS2000 POSIX systems such that calling int() on the product of a number and a small magnitude number is not the same as calling int() on the quotient of that number and a large magnitude number. For example, in the following Perl code:</source>
          <target state="translated">在BS2000 POSIX系统上的浮点数实现中似乎存在一个错误,即对一个数和一个小数的乘积调用int()与对这个数和一个大数的商调用int()是不一样的。例如,在下面的Perl代码中。</target>
        </trans-unit>
        <trans-unit id="bb6e61aa6502fa98f73e845b088e443cab1a90e3" translate="yes" xml:space="preserve">
          <source>There appears to be a bug in the floating point implementation on S/390 systems such that calling int() on the product of a number and a small magnitude number is not the same as calling int() on the quotient of that number and a large magnitude number. For example, in the following Perl code:</source>
          <target state="translated">在S/390系统上,浮点运算的实现似乎存在一个错误,即对一个数和一个小数的乘积调用int()和对该数和一个大数的商调用int()是不一样的。例如,在下面的Perl代码中。</target>
        </trans-unit>
        <trans-unit id="de1cfe28fcf075678633050ad3a49243fab1a122" translate="yes" xml:space="preserve">
          <source>There are 3 kinds of items that may be populated; special patterns, #vars, and literal text, which is copied verbatim. (Yes, it's a set of s///g steps.)</source>
          <target state="translated">有3种项目可以被填充;特殊模式、#vars和逐字复制的文字。是的,这是一套s//g步骤)。</target>
        </trans-unit>
        <trans-unit id="6e9231df83ad3f347c0bf53efa7fd0781ae7adef" translate="yes" xml:space="preserve">
          <source>There are &lt;code&gt;lint&lt;/code&gt; and &amp;lt;splint&amp;gt; targets in Makefile, but you may have to diddle with the flags (see above).</source>
          <target state="translated">Makefile中有 &lt;code&gt;lint&lt;/code&gt; 和&amp;lt;splint&amp;gt;目标，但是您可能不得不使用标志（请参见上文）。</target>
        </trans-unit>
        <trans-unit id="fe9ce8188c03cc1c80382377cc03bbf3d1eefe6b" translate="yes" xml:space="preserve">
          <source>There are DECC feature logical names AND ODS-5 volume attributes that also control what values are returned for the date fields.</source>
          <target state="translated">有DECC特征逻辑名和ODS-5卷属性也控制着日期字段的返回值。</target>
        </trans-unit>
        <trans-unit id="153a01ed3dca851e07404e7b116e0f624fedd9d4" translate="yes" xml:space="preserve">
          <source>There are a couple of exceptions to the above rule. &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; is always interpreted as a Unicode code point, so that &lt;code&gt;\N{U+0050}&lt;/code&gt; is &lt;code&gt;&quot;P&quot;&lt;/code&gt; even on EBCDIC platforms. And if &lt;code&gt;&lt;a href=&quot;encoding&quot;&gt;use encoding&lt;/a&gt;&lt;/code&gt; is in effect, the number is considered to be in that encoding, and is translated from that into the platform's native encoding if there is a corresponding native character; otherwise to Unicode.</source>
          <target state="translated">上述规则有几个例外。 &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; 始终被解释为Unicode代码点，因此即使在EBCDIC平台上， &lt;code&gt;\N{U+0050}&lt;/code&gt; 也是 &lt;code&gt;&quot;P&quot;&lt;/code&gt; 。并且如果 &lt;code&gt;&lt;a href=&quot;encoding&quot;&gt;use encoding&lt;/a&gt;&lt;/code&gt; 有效，则认为该数字是该编码中的数字，并且如果存在相应的本机字符，则将其从数字转换为平台的本机编码；否则为Unicode。</target>
        </trans-unit>
        <trans-unit id="4e415da7b1ad793f82f6c66993b6dabfb03be0ae" translate="yes" xml:space="preserve">
          <source>There are a couple of macros to do very basic exception handling in XS modules. You have to define &lt;code&gt;NO_XSLOCKS&lt;/code&gt; before including</source>
          <target state="translated">XS模块中有两个宏可以执行非常基本的异常处理。您必须先定义 &lt;code&gt;NO_XSLOCKS&lt;/code&gt; ,然后再包括</target>
        </trans-unit>
        <trans-unit id="b559285d4827f1039158fa6a1c7be09bcea8695c" translate="yes" xml:space="preserve">
          <source>There are a couple of other symbols that you're likely to encounter that aren't really type specifiers:</source>
          <target state="translated">还有一些其他的符号,你可能会遇到,但这些符号并不是真正的类型指定符。</target>
        </trans-unit>
        <trans-unit id="cd28f27e3e26acb88f426d59ef73cb49b8748e10" translate="yes" xml:space="preserve">
          <source>There are a couple of special arrays too, such as &lt;code&gt;@ARGV&lt;/code&gt; (the command line arguments to your script) and &lt;code&gt;@_&lt;/code&gt; (the arguments passed to a subroutine). These are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">还有一些特殊的数组，例如 &lt;code&gt;@ARGV&lt;/code&gt; （脚本的命令行参数）和 &lt;code&gt;@_&lt;/code&gt; （传递给子例程的参数）。这些在&lt;a href=&quot;perlvar&quot;&gt;perlvar中&lt;/a&gt;有记录。</target>
        </trans-unit>
        <trans-unit id="d71c568688cddeb0974cf4c64aacf00c4a7ae0fc" translate="yes" xml:space="preserve">
          <source>There are a couple of things to note about this analysis. First, the third alternative in the second group 'de' also allows a match, but we stopped before we got to it - at a given character position, leftmost wins. Second, we were able to get a match at the first character position of the string 'a'. If there were no matches at the first position, Perl would move to the second character position 'b' and attempt the match all over again. Only when all possible paths at all possible character positions have been exhausted does Perl give up and declare &lt;code&gt;$string =~ /(abd|abc)(df|d|de)/;&lt;/code&gt; to be false.</source>
          <target state="translated">关于此分析，有两点需要注意。首先，第二组&amp;ldquo; de&amp;rdquo;中的第三个备选方案也允许进行比赛，但我们在达到目标之前就停了下来-在给定角色位置，最左边的胜利。其次，我们能够在字符串&amp;ldquo; a&amp;rdquo;的第一个字符位置获得匹配项。如果在第一个位置没有匹配，Perl将移动到第二个字符位置&amp;ldquo; b&amp;rdquo;，然后再次尝试匹配。只有在用尽所有可能的字符位置的所有可能路径时，Perl才会放弃并声明 &lt;code&gt;$string =~ /(abd|abc)(df|d|de)/;&lt;/code&gt; 是假的。</target>
        </trans-unit>
        <trans-unit id="39aecaa3926975713f4a2a65afbfb40347095ccc" translate="yes" xml:space="preserve">
          <source>There are a couple of ways that you can process an entire hash. You can get a list of keys, then go through each key, or grab a one key-value pair at a time.</source>
          <target state="translated">有几种方法可以处理整个哈希。你可以得到一个键的列表,然后通过每个键,或者一次抓取一个键值对。</target>
        </trans-unit>
        <trans-unit id="af13ea056584d18f28105e6dfb4305dd6e1f93f8" translate="yes" xml:space="preserve">
          <source>There are a few basic principles which define object oriented Perl:</source>
          <target state="translated">有几个基本原则定义了面向对象的Perl。</target>
        </trans-unit>
        <trans-unit id="6ad0df8b5bb1240ec34f94939aa27ca4c87aa9d3" translate="yes" xml:space="preserve">
          <source>There are a few exceptions though: &lt;code&gt;x&lt;/code&gt; can be either string repetition or list repetition, depending on the type of the left operand, and &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; can be either string or numeric bit operations.</source>
          <target state="translated">有几个例外，但： &lt;code&gt;x&lt;/code&gt; 可以是字符串重复或列表重复，这取决于左操作数的类型， &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; 可以是字符串或数字位操作。</target>
        </trans-unit>
        <trans-unit id="5a7bb479453f1e1c0fcfea035067e079420f6246" translate="yes" xml:space="preserve">
          <source>There are a few more things you might want to know about matching operators. The global modifier &lt;code&gt;//g&lt;/code&gt; allows the matching operator to match within a string as many times as possible. In scalar context, successive matches against a string will have &lt;code&gt;//g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; function. For example,</source>
          <target state="translated">关于匹配运算符，您可能还需要了解几件事。全局修饰符 &lt;code&gt;//g&lt;/code&gt; 允许匹配的运算符在一个字符串内尽可能多地匹配。在标量上下文中，与字符串的连续匹配将在匹配之间跳转 &lt;code&gt;//g&lt;/code&gt; ，从而跟踪字符串在字符串中的位置。您可以使用 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 函数获取或设置位置。例如，</target>
        </trans-unit>
        <trans-unit id="4300a240e517c8a51298a8d027c6fc76723dcec0" translate="yes" xml:space="preserve">
          <source>There are a few point to bear in mind if you want to change the ordering in a BTREE database:</source>
          <target state="translated">如果你想改变BTREE数据库的排序,有几点需要记住。</target>
        </trans-unit>
        <trans-unit id="7b1086e8333561d2682eac30f860ad2422dfc42d" translate="yes" xml:space="preserve">
          <source>There are a few things to bear in mind when creating your own &lt;code&gt;ResultFactory&lt;/code&gt; :</source>
          <target state="translated">创建自己的 &lt;code&gt;ResultFactory&lt;/code&gt; 时，需要牢记一些注意事项：</target>
        </trans-unit>
        <trans-unit id="378f2e66966b2788636abfdbe2bc87b5abb48ea4" translate="yes" xml:space="preserve">
          <source>There are a few things you need to know, however:</source>
          <target state="translated">不过,有几件事你需要知道。</target>
        </trans-unit>
        <trans-unit id="9cbfb29c30b87800b111898e71e11f4933f270fc" translate="yes" xml:space="preserve">
          <source>There are a lot of modules on CPAN, and it's easy to miss one that's similar to what you're planning on contributing. Have a good plough through the &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt; and make sure you're not the one reinventing the wheel!</source>
          <target state="translated">CPAN上有很多模块，很容易错过与您计划贡献的模块相似的模块。仔细浏览&lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt;并确保您不是重塑方向盘的人！</target>
        </trans-unit>
        <trans-unit id="8202fc94e9abdf77b0bbe8e0da596aca565bfbf9" translate="yes" xml:space="preserve">
          <source>There are a number of &quot;magic&quot; scalars with names that look like punctuation or line noise. These special variables are used for all kinds of purposes, and are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;. The only one you need to know about for now is &lt;code&gt;$_&lt;/code&gt; which is the &quot;default variable&quot;. It's used as the default argument to a number of functions in Perl, and it's set implicitly by certain looping constructs.</source>
          <target state="translated">有许多&amp;ldquo;魔术&amp;rdquo;标量，其名称看起来像标点符号或行噪声。这些特殊变量用于各种目的，并在&lt;a href=&quot;perlvar&quot;&gt;perlvar中进行了说明&lt;/a&gt;。您现在唯一需要了解的就是 &lt;code&gt;$_&lt;/code&gt; ，它是&amp;ldquo;默认变量&amp;rdquo;。它在Perl中用作许多函数的默认参数，并且由某些循环构造隐式设置。</target>
        </trans-unit>
        <trans-unit id="6fc3a0395d03ea21a961b5ccde55199ca19344c6" translate="yes" xml:space="preserve">
          <source>There are a number of Unicode characters that match multiple characters under &lt;code&gt;/i&lt;/code&gt;. For example, &lt;code&gt;LATIN SMALL LIGATURE FI&lt;/code&gt; should match the sequence &lt;code&gt;fi&lt;/code&gt; . Perl is not currently able to do this when the multiple characters are in the pattern and are split between groupings, or when one or more are quantified. Thus</source>
          <target state="translated">&lt;code&gt;/i&lt;/code&gt; 下有许多与多个字符匹配的Unicode字符。例如， &lt;code&gt;LATIN SMALL LIGATURE FI&lt;/code&gt; 应该匹配序列 &lt;code&gt;fi&lt;/code&gt; 。当多个字符位于模式中并且在分组之间划分时，或者对一个或多个进行量化时，Perl当前无法执行此操作。从而</target>
        </trans-unit>
        <trans-unit id="3dd2d0257d19015791fc17037d18a20e756ba477" translate="yes" xml:space="preserve">
          <source>There are a number of escape sequences and character classes that we haven't covered yet.</source>
          <target state="translated">有一些逃生序列和字符类,我们还没有介绍。</target>
        </trans-unit>
        <trans-unit id="58e8ff088e1d138c7e62589f4caba0154e035619" translate="yes" xml:space="preserve">
          <source>There are a number of flags that can be found at the end of regular expression constructs that are</source>
          <target state="translated">有一些标志可以在正则表达式构造的末尾找到,它们是</target>
        </trans-unit>
        <trans-unit id="9135b7f56d303db71c9d18be0e91860f32c7ff91" translate="yes" xml:space="preserve">
          <source>There are a number of issues with regard to case-insensitive matching in Unicode rules. See &lt;code&gt;i&lt;/code&gt; under &lt;a href=&quot;#Modifiers&quot;&gt;Modifiers&lt;/a&gt; above.</source>
          <target state="translated">关于Unicode规则中不区分大小写的匹配，存在许多问题。请参阅上面的&lt;a href=&quot;#Modifiers&quot;&gt;修饰符&lt;/a&gt;下的 &lt;code&gt;i&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="022096dd663fb452b1d41c016ae62776dae4f673" translate="yes" xml:space="preserve">
          <source>There are a number of limits on the size of the data that you can store in the NDBM file. The most important is that the length of a key, plus the length of its associated value, may not exceed 1008 bytes.</source>
          <target state="translated">您可以在 NDBM 文件中存储的数据的大小有一些限制,最重要的是一个密钥的长度加上相关值的长度不能超过 1008 字节。最重要的是,一个密钥的长度,加上其相关值的长度,不得超过1008字节。</target>
        </trans-unit>
        <trans-unit id="72d53d5198c98896d8e7795e9a89c4a433023428" translate="yes" xml:space="preserve">
          <source>There are a number of limits on the size of the data that you can store in the SDBM file. The most important is that the length of a key, plus the length of its associated value, may not exceed 1008 bytes.</source>
          <target state="translated">在SDBM文件中可以存储的数据大小有一些限制,最重要的是一个密钥的长度加上相关值的长度不能超过1008字节。最重要的是,一个密钥的长度,加上其相关值的长度,不得超过1008字节。</target>
        </trans-unit>
        <trans-unit id="52efe033e2beba5914060b25e959b1d5bcc3adec" translate="yes" xml:space="preserve">
          <source>There are a number of modules which let you write GUIs in Perl. Most GUI toolkits have a perl interface: an incomplete list follows.</source>
          <target state="translated">有很多模块可以让你用Perl编写GUI。大多数GUI工具包都有一个perl接口:下面是一个不完整的列表。</target>
        </trans-unit>
        <trans-unit id="7c6653dd731ed3a59a2ee9aba20887a251e28fb4" translate="yes" xml:space="preserve">
          <source>There are a number of new concepts introduced here, described below:</source>
          <target state="translated">这里介绍了一些新的概念,下面介绍一下。</target>
        </trans-unit>
        <trans-unit id="5042e54e451264a1c914a632ba72877f3d1fb724" translate="yes" xml:space="preserve">
          <source>There are a number of other limitations with the &lt;code&gt;Merge&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;Merge&lt;/code&gt; 选项还有许多其他限制：</target>
        </trans-unit>
        <trans-unit id="7b02972f75c4a57c97baf269f0fc3720b5f2bc53" translate="yes" xml:space="preserve">
          <source>There are a number of reasons that you might prefer &lt;code&gt;Tie::File&lt;/code&gt; . A list is available at &lt;code&gt;&lt;a href=&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;&gt;http://perl.plover.com/TieFile/why-not-DB_File&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您可能出于多种原因而偏爱 &lt;code&gt;Tie::File&lt;/code&gt; 。可以从 &lt;code&gt;&lt;a href=&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;&gt;http://perl.plover.com/TieFile/why-not-DB_File&lt;/a&gt;&lt;/code&gt; 获得列表。</target>
        </trans-unit>
        <trans-unit id="fc49fd5fe581b9df69b9289066f92c4c1dfec1b9" translate="yes" xml:space="preserve">
          <source>There are a number of security issues with the full Unicode list of word characters. See &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt;.</source>
          <target state="translated">完整的Unicode字符列表存在许多安全问题。参见&lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="34fde0bc8e68f7eb8a6a5b8c75bef1c718f91f74" translate="yes" xml:space="preserve">
          <source>There are a number of ways to handle this sort of problem. The best way is to always have all threads acquire locks in the exact same order. If, for example, you lock variables &lt;code&gt;$x&lt;/code&gt; , &lt;code&gt;$y&lt;/code&gt; , and &lt;code&gt;$z&lt;/code&gt; , always lock &lt;code&gt;$x&lt;/code&gt; before &lt;code&gt;$y&lt;/code&gt; , and &lt;code&gt;$y&lt;/code&gt; before &lt;code&gt;$z&lt;/code&gt; . It's also best to hold on to locks for as short a period of time to minimize the risks of deadlock.</source>
          <target state="translated">有很多方法可以解决此类问题。最好的方法是始终让所有线程都以完全相同的顺序获取锁。如果，例如，你锁定变量 &lt;code&gt;$x&lt;/code&gt; ， &lt;code&gt;$y&lt;/code&gt; ，和 &lt;code&gt;$z&lt;/code&gt; ，始终锁定 &lt;code&gt;$x&lt;/code&gt; 之前 &lt;code&gt;$y&lt;/code&gt; ，和 &lt;code&gt;$y&lt;/code&gt; 前 &lt;code&gt;$z&lt;/code&gt; 。最好也将锁保持较短的时间，以最大程度地降低死锁的风险。</target>
        </trans-unit>
        <trans-unit id="f32c15283e2f4c6b7705b70493695500588d21f8" translate="yes" xml:space="preserve">
          <source>There are a number of ways to hide the source to your Perl programs, with varying levels of &quot;security&quot;.</source>
          <target state="translated">有很多方法可以隐藏Perl程序的源码,其 &quot;安全 &quot;程度各不相同。</target>
        </trans-unit>
        <trans-unit id="47ea19cfdb1d50b8922388e83c50c4e47a818ebc" translate="yes" xml:space="preserve">
          <source>There are a number of ways, with varying efficiency. If you want a count of a certain single character (X) within a string, you can use the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; function like so:</source>
          <target state="translated">有很多方法，效率各不相同。如果要对字符串中的某个单个字符（X）进行计数，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="7bba5f24a6f4653ec9fc5a0573f80d18dac8d06b" translate="yes" xml:space="preserve">
          <source>There are a set of utilities which help you in developing Perl programs, and in particular, extending Perl with C.</source>
          <target state="translated">有一组实用工具可以帮助你开发Perl程序,特别是用C语言扩展Perl。</target>
        </trans-unit>
        <trans-unit id="6b1252989edb8e8176f3bcfc5773893823daccc4" translate="yes" xml:space="preserve">
          <source>There are a significant number of test failures in the CPAN modules shipped with Perl v5.22. These are only in modules not primarily maintained by Perl 5 porters. Some of these are failures in the tests only: they don't realize that it is proper to get different results on EBCDIC platforms. And some of the failures are real bugs. If you compile and do a &lt;code&gt;make test&lt;/code&gt; on Perl, all tests on the &lt;code&gt;/cpan&lt;/code&gt; directory are skipped.</source>
          <target state="translated">Perl v5.22附带的CPAN模块中有大量测试失败。这些仅在不是主要由Perl 5 porter维护的模块中。其中一些只是测试失败：他们没有意识到在EBCDIC平台上获得不同的结果是适当的。有些失败是真正的错误。如果您在Perl上编译并进行 &lt;code&gt;make test&lt;/code&gt; ，则 &lt;code&gt;/cpan&lt;/code&gt; 目录上的所有测试都将被跳过。</target>
        </trans-unit>
        <trans-unit id="9a68ba03d821b0f9ca941d8a7348ffd6b9675672" translate="yes" xml:space="preserve">
          <source>There are a variety of ways of transforming data with an intra character set mapping that serve a variety of purposes. Sorting was discussed in the previous section and a few of the other more popular mapping techniques are discussed next.</source>
          <target state="translated">用字符集内映射来转换数据的方法有很多种,可以达到各种目的。上一节讨论了排序,下一节将讨论其他几种比较流行的映射技术。</target>
        </trans-unit>
        <trans-unit id="8c243ce02550d420fdebc8e85f18f50ac8e89a64" translate="yes" xml:space="preserve">
          <source>There are actually two varieties of null strings (sometimes referred to as &quot;empty&quot; strings), a defined one and an undefined one. The defined version is just a string of length zero, such as &lt;code&gt;&quot;&quot;&lt;/code&gt; . The undefined version is the value that indicates that there is no real value for something, such as when there was an error, or at end of file, or when you refer to an uninitialized variable or element of an array or hash. Although in early versions of Perl, an undefined scalar could become defined when first used in a place expecting a defined value, this no longer happens except for rare cases of autovivification as explained in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. You can use the defined() operator to determine whether a scalar value is defined (this has no meaning on arrays or hashes), and the undef() operator to produce an undefined value.</source>
          <target state="translated">实际上，空字符串有两种（有时称为&amp;ldquo;空&amp;rdquo;字符串），一种是已定义的，另一种是未定义的。定义的版本只是一个长度为零的字符串，例如 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。未定义版本是表示某物没有实际值的值，例如发生错误时，文件末尾或引用未初始化的变量或数组或哈希元素时。尽管在Perl的早期版本中，当在需要定义值的地方首次使用时，可能会定义未定义的标量，但这种情况不再发生，除非如perlref中所述的&lt;a href=&quot;perlref&quot;&gt;极少数自动生存的情况&lt;/a&gt;。您可以使用define（）运算符来确定是否定义了标量值（这对数组或哈希值没有意义），可以使用undef（）运算符来生成未定义的值。</target>
        </trans-unit>
        <trans-unit id="547f74aebc059a529676c6646c9bed2946a0409e" translate="yes" xml:space="preserve">
          <source>There are additional macros whose values may be bitwise OR'ed with the &lt;code&gt;GV_ADD&lt;/code&gt; argument to enable certain extra features. Those bits are:</source>
          <target state="translated">还有一些其他宏，这些宏的值可以与 &lt;code&gt;GV_ADD&lt;/code&gt; 参数进行按位或运算以启用某些其他功能。这些位是：</target>
        </trans-unit>
        <trans-unit id="51046d0ad7a7252d1ce87aabe4027ffe3663a57e" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;Win32::IsWinNT()&lt;/code&gt; and &lt;code&gt;Win32::IsWin95()&lt;/code&gt; ; try &lt;code&gt;perldoc Win32&lt;/code&gt; , and as of libwin32 0.19 (not part of the core Perl distribution) &lt;code&gt;Win32::GetOSName()&lt;/code&gt; . The very portable &lt;code&gt;POSIX::uname()&lt;/code&gt; will work too:</source>
          <target state="translated">还有 &lt;code&gt;Win32::IsWinNT()&lt;/code&gt; 和 &lt;code&gt;Win32::IsWin95()&lt;/code&gt; ; 尝试使用 &lt;code&gt;perldoc Win32&lt;/code&gt; ，从libwin32 0.19开始（不是核心Perl发行版的一部分） &lt;code&gt;Win32::GetOSName()&lt;/code&gt; 。便携式 &lt;code&gt;POSIX::uname()&lt;/code&gt; 也可以使用：</target>
        </trans-unit>
        <trans-unit id="68cc104cb95d94223dc9fddad7fb75cbcb044f6c" translate="yes" xml:space="preserve">
          <source>There are also endless possibilities to use</source>
          <target state="translated">也有无限的可能性来使用</target>
        </trans-unit>
        <trans-unit id="323189fd57b85b2e190ea90f3e9bb682b3b9f2e0" translate="yes" xml:space="preserve">
          <source>There are also plenty of Perl related newsgroups located under &lt;code&gt;comp.lang.perl.*&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;comp.lang.perl.*&lt;/code&gt; 下还有很多与Perl相关的新闻组。</target>
        </trans-unit>
        <trans-unit id="527d1ab1f5f5398fbabcd044390ef4e42b5f0b60" translate="yes" xml:space="preserve">
          <source>There are also some commercial products that may work for you, although you have to buy a license for them.</source>
          <target state="translated">还有一些商业产品可能对你有用,尽管你必须购买它们的许可证。</target>
        </trans-unit>
        <trans-unit id="54ce59232e232d36fa4b243d9439f11e909759d7" translate="yes" xml:space="preserve">
          <source>There are also some commonly used modules for the task. &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; (distributed with 5.8) provides access to perl's internal function &lt;code&gt;looks_like_number&lt;/code&gt; for determining whether a variable looks like a number. &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Types&quot;&gt;Data::Types&lt;/a&gt; exports functions that validate data types using both the above and other regular expressions. Thirdly, there is &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; which has regular expressions to match various types of numbers. Those three modules are available from the CPAN.</source>
          <target state="translated">还有一些用于该任务的常用模块。&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;（随5.8一起分发）提供对perl内部函数 &lt;code&gt;looks_like_number&lt;/code&gt; 的访问，以确定变量是否看起来像数字。&lt;a href=&quot;http://search.cpan.org/perldoc/Data::Types&quot;&gt;Data :: Types&lt;/a&gt;导出使用上述正则表达式和其他正则表达式验证数据类型的函数。第三，&lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt;具有正则表达式以匹配各种类型的数字。这三个模块可从CPAN获得。</target>
        </trans-unit>
        <trans-unit id="b1ee19a63035c233ed5685ff1e3a13cd9e4a26d4" translate="yes" xml:space="preserve">
          <source>There are also some other op types: a &lt;code&gt;PMOP&lt;/code&gt; holds a regular expression, and has no children, and a &lt;code&gt;LOOP&lt;/code&gt; may or may not have children. If the &lt;code&gt;op_children&lt;/code&gt; field is non-zero, it behaves like a &lt;code&gt;LISTOP&lt;/code&gt; . To complicate matters, if a &lt;code&gt;UNOP&lt;/code&gt; is actually a &lt;code&gt;null&lt;/code&gt; op after optimization (see &lt;a href=&quot;#Compile-pass-2%3a-context-propagation&quot;&gt;Compile pass 2: context propagation&lt;/a&gt;) it will still have children in accordance with its former type.</source>
          <target state="translated">还有其他一些op类型： &lt;code&gt;PMOP&lt;/code&gt; 包含一个正则表达式，并且没有子代，而 &lt;code&gt;LOOP&lt;/code&gt; 可能有也可能没有子代。如果 &lt;code&gt;op_children&lt;/code&gt; 字段不为零，则其行为类似于 &lt;code&gt;LISTOP&lt;/code&gt; 。使问题复杂化的是，如果优化后 &lt;code&gt;UNOP&lt;/code&gt; 实际上是一个 &lt;code&gt;null&lt;/code&gt; 操作（请参阅&lt;a href=&quot;#Compile-pass-2%3a-context-propagation&quot;&gt;编译阶段2：上下文传播&lt;/a&gt;），则它仍将具有其先前类型的子代。</target>
        </trans-unit>
        <trans-unit id="d74afa3e57d8bf587dddccd05e8aa225e3034ba7" translate="yes" xml:space="preserve">
          <source>There are also some tricks that you can play with &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; and the accumulator variable &lt;code&gt;$^A&lt;/code&gt; , but you lose a lot of the value of formats since &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; won't handle paging and so on. You end up reimplementing formats when you use them.</source>
          <target state="translated">您还可以使用 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 和累加器变量 &lt;code&gt;$^A&lt;/code&gt; 玩一些技巧，但是由于 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 无法处理分页等原因，您会损失很多格式值。使用它们时，最终会重新实现格式。</target>
        </trans-unit>
        <trans-unit id="8a607b0a4fc3c7e1671b30a3b355e931c22fa4ed" translate="yes" xml:space="preserve">
          <source>There are also the two values &lt;code&gt;PL_sv_yes&lt;/code&gt; and &lt;code&gt;PL_sv_no&lt;/code&gt; , which contain boolean TRUE and FALSE values, respectively. Like &lt;code&gt;PL_sv_undef&lt;/code&gt; , their addresses can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed.</source>
          <target state="translated">还有两个值 &lt;code&gt;PL_sv_yes&lt;/code&gt; 和 &lt;code&gt;PL_sv_no&lt;/code&gt; ，分别包含布尔值TRUE和FALSE。像 &lt;code&gt;PL_sv_undef&lt;/code&gt; 一样，只要需要 &lt;code&gt;SV*&lt;/code&gt; ，就可以使用它们的地址。</target>
        </trans-unit>
        <trans-unit id="2a9975f54ba4b1444b192c3d8bfd7d71c13ebdbb" translate="yes" xml:space="preserve">
          <source>There are also versions of the functions with &quot;_hex&quot; or &quot;_base64&quot; appended to the name, which returns the digest in the indicated form.</source>
          <target state="translated">还有一些版本的函数在名称后附加&quot;_hex &quot;或&quot;_base64&quot;,以指定的形式返回摘要。</target>
        </trans-unit>
        <trans-unit id="a5a4f4a9450ec80ee122e2031504c8884d21e28d" translate="yes" xml:space="preserve">
          <source>There are at least two instance variables stored in a hash reference, {data} and {encoding}.</source>
          <target state="translated">在哈希引用中至少存储了两个实例变量,{数据}和{编码}。</target>
        </trans-unit>
        <trans-unit id="68682d3f996c5d0d4c5e2cf0ab83889b2edb3594" translate="yes" xml:space="preserve">
          <source>There are cases when you will not know beforehand how many tests your script is going to run. In this case, you can declare your tests at the end.</source>
          <target state="translated">在某些情况下,你不会事先知道你的脚本要运行多少测试,在这种情况下,你可以在最后声明你的测试。在这种情况下,你可以在最后声明你的测试。</target>
        </trans-unit>
        <trans-unit id="13a4d162b9b64ac9d632dbabef83e1cc311a2290" translate="yes" xml:space="preserve">
          <source>There are certain application spaces which are already very, very well served by CPAN. One example is templating systems, another is date and time modules, and there are many more. While it is a rite of passage to write your own version of these things, please consider carefully whether the Perl world really needs you to publish it.</source>
          <target state="translated">在某些应用领域,CPAN已经提供了非常、非常好的服务。一个例子是模板系统,另一个是日期和时间模块,还有很多。虽然写出自己版本的这些东西是一种仪式,但请仔细考虑Perl世界是否真的需要你来发布它。</target>
        </trans-unit>
        <trans-unit id="f399d82ea760be3c44c0c12193de98d98ca6c0b6" translate="yes" xml:space="preserve">
          <source>There are corresponding one-letter commands &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; for each of the four categories and another, &lt;code&gt;i&lt;/code&gt; for any of the mentioned four. Each of the four entities is implemented as a class with slightly differing methods for displaying an object.</source>
          <target state="translated">四个类别中的每个类别都有对应的单字母命令 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;d&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; ，另一个类别中的 &lt;code&gt;i&lt;/code&gt; 对应一个字母命令。四个实体中的每一个都被实现为一个类，其显示对象的方法略有不同。</target>
        </trans-unit>
        <trans-unit id="61165542c376ce1515ee946fb54e0b62bf506b50" translate="yes" xml:space="preserve">
          <source>There are currently three implementations:</source>
          <target state="translated">目前有三种实施方式。</target>
        </trans-unit>
        <trans-unit id="7082baef78129948a9aee04418c7c10c1b4d4a87" translate="yes" xml:space="preserve">
          <source>There are different classes in the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email::Folder&lt;/a&gt; namespace for supporting various mailbox types. Note that these modules are generally rather limited and only support &lt;b&gt;reading&lt;/b&gt; rather than writing.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email :: Folder&lt;/a&gt;命名空间中有不同的类，用于支持各种邮箱类型。请注意，这些模块通常相当有限，仅支持&lt;b&gt;阅读&lt;/b&gt;而不是写作。</target>
        </trans-unit>
        <trans-unit id="ed85d6fa9e5690e5659a7fcf3cc7c90a6a9abc89" translate="yes" xml:space="preserve">
          <source>There are exceptions to the above rules for dereference operations (which, if Step 1 fails, always fall back to the normal, built-in implementations - see Dereferencing), and for &lt;code&gt;~~&lt;/code&gt; (which has its own set of rules - see &lt;code&gt;Matching&lt;/code&gt; under &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; above).</source>
          <target state="translated">上面提到的用于解除引用操作的规则（如果步骤1失败，将始终退回到常规的内置实现-请参阅&amp;ldquo;解除引用&amp;rdquo;），对于 &lt;code&gt;~~&lt;/code&gt; （具有自己的规则集-请参见&amp;ldquo; &lt;code&gt;Matching&lt;/code&gt; 下的规则）有例外。以上的可&lt;a href=&quot;#Overloadable-Operations&quot;&gt;重载操作&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="129afe5f5ce43c82f8dd2611661b6c6fae2152e8" translate="yes" xml:space="preserve">
          <source>There are exceptions to the simple scalar maps. Some properties have some elements in their map list that are themselves lists of scalars; and some special strings are returned that are not to be interpreted as-is. Element [2] (placed into &lt;code&gt;$format&lt;/code&gt; in the example above) of the returned four element list tells you if the map has any of these special elements or not, as follows:</source>
          <target state="translated">简单标量映射有一些例外。一些属性的映射列表中包含一些元素，这些元素本身就是标量列表。并返回一些不按原样解释的特殊字符串。返回的四个元素列表的元素[2]（在上面的示例中放入 &lt;code&gt;$format&lt;/code&gt; 中）告诉您地图是否具有以下任何特殊元素，如下所示：</target>
        </trans-unit>
        <trans-unit id="03da32e2f08e4c55ca723ef0de464a8b0fc8a37a" translate="yes" xml:space="preserve">
          <source>There are five pattern matching operations other than a strict one-to-one match between the pattern and the source to be checked for a match.</source>
          <target state="translated">除了模式和待检查的源之间严格的一对一匹配外,还有五种模式匹配操作。</target>
        </trans-unit>
        <trans-unit id="caaaee4619b1124c4cd083d4f94b5aeee43dd52b" translate="yes" xml:space="preserve">
          <source>There are four arguments:</source>
          <target state="translated">有四个论点。</target>
        </trans-unit>
        <trans-unit id="c30d8b75df6d6d560de84db459ba9ddeaac5bfd4" translate="yes" xml:space="preserve">
          <source>There are four methods associated with DBM Filters. All work identically, and each is used to install (or uninstall) a single DBM Filter. Each expects a single parameter, namely a reference to a sub. The only difference between them is the place that the filter is installed.</source>
          <target state="translated">有四种方法与DBM过滤器有关。所有方法的工作原理都是一样的,每个方法都用来安装(或卸载)一个DBM过滤器。每种方法都需要一个参数,即一个子的引用。它们之间唯一的区别是过滤器被安装的位置。</target>
        </trans-unit>
        <trans-unit id="2b4786fe13177802911e40046450c4aa8a6b7442" translate="yes" xml:space="preserve">
          <source>There are four routines that can be used to call a Perl subroutine from within a C program. These four are:</source>
          <target state="translated">有四个例程可以用来从C程序中调用Perl子程序。这四个例程是:</target>
        </trans-unit>
        <trans-unit id="0b4c3b4907f361ea335c94a68bf5900b38774c4c" translate="yes" xml:space="preserve">
          <source>There are just two ways to make a reference, and just two ways to use it once you have it.</source>
          <target state="translated">参考的方法只有两种,有了参考后的使用方法也只有两种。</target>
        </trans-unit>
        <trans-unit id="451300c3402db478bc017d97504bbf1dc7589d4f" translate="yes" xml:space="preserve">
          <source>There are literally dozens of other OO-related modules on CPAN besides those covered here, and you're likely to run across one or more of them if you work with other people's code.</source>
          <target state="translated">除了这里介绍的模块外,CPAN上还有几十个与OO相关的模块,如果你使用别人的代码,你很可能会遇到其中的一个或多个。</target>
        </trans-unit>
        <trans-unit id="6c77d5c24285fecf2b82ebf41d5dec81876d45b0" translate="yes" xml:space="preserve">
          <source>There are lots more commands and options, but the above will do it.</source>
          <target state="translated">还有更多的命令和选项,但以上就可以了。</target>
        </trans-unit>
        <trans-unit id="837d89ccfb96f196a244bf30256b711d40a975e1" translate="yes" xml:space="preserve">
          <source>There are many Perl &lt;a href=&quot;http://search.cpan.org/perldoc/lists.perl.org&quot;&gt;mailing lists&lt;/a&gt; for various topics, specifically the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2flists.perl.org%2flist%2fbeginners.html&quot;&gt;beginners list&lt;/a&gt; may be of use.</source>
          <target state="translated">有许多关于各种主题的Perl &lt;a href=&quot;http://search.cpan.org/perldoc/lists.perl.org&quot;&gt;邮件列表&lt;/a&gt;，尤其是&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2flists.perl.org%2flist%2fbeginners.html&quot;&gt;初学者列表&lt;/a&gt;可能有用。</target>
        </trans-unit>
        <trans-unit id="9bec5519f33a4e7bdc4a53a2313d4e1bcfcd1067" translate="yes" xml:space="preserve">
          <source>There are many books on Perl and Perl-related. A few of these are good, some are OK, but many aren't worth your money. There is a list of these books, some with extensive reviews, at &lt;a href=&quot;http://books.perl.org/&quot;&gt;http://books.perl.org/&lt;/a&gt; . We list some of the books here, and while listing a book implies our endorsement, don't think that not including a book means anything.</source>
          <target state="translated">关于Perl和与Perl相关的书籍很​​多。其中一些很好，有些还可以，但是很多都不值得。在&lt;a href=&quot;http://books.perl.org/&quot;&gt;http://books.perl.org/上&lt;/a&gt;有这些书的清单，有些书有详尽的评论。我们在这里列出了一些书，虽然列出一本书意味着我们的认可，但不要认为不包括书就没有任何意义。</target>
        </trans-unit>
        <trans-unit id="c4e51ecd675e07ca3b7be0664408ec108e37de71" translate="yes" xml:space="preserve">
          <source>There are many different ftp firewall products available. But unfortunately there is no standard for how to traverse a firewall. The list below shows the sequence of commands that Net::FTP will use</source>
          <target state="translated">目前有很多不同的ftp防火墙产品。但不幸的是,如何穿越防火墙并没有一个标准。下面的列表显示了Net::FTP将使用的命令序列。</target>
        </trans-unit>
        <trans-unit id="ccca22cadfc5874b657dd6b896d963adc193de41" translate="yes" xml:space="preserve">
          <source>There are many good &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fbooks%2flibrary.html&quot;&gt;books on Perl&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fbooks%2flibrary.html&quot;&gt;关于Perl的书&lt;/a&gt;很多。</target>
        </trans-unit>
        <trans-unit id="18c010c4c2e46af9e1a3df8426bb24c3742b96b7" translate="yes" xml:space="preserve">
          <source>There are many more properties than the very basic ones described here. A complete list is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">除了这里描述的非常基本的属性以外，还有更多的属性。完整列表在&lt;a href=&quot;perluniprops&quot;&gt;perluniprops中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a8e433d3ac89e153ddbae16288b146a2a506dab" translate="yes" xml:space="preserve">
          <source>There are many other functions available since FileHandle is descended from IO::File, IO::Seekable, and IO::Handle. Please see those respective pages for documentation on more functions.</source>
          <target state="translated">由于 FileHandle 是 IO::File、IO::Seekable 和 IO::Handle 的后裔,所以还有很多其他的函数可用。更多的函数请参见相关页面的文档。</target>
        </trans-unit>
        <trans-unit id="19b014b8d66d3b187e540a67f34591fd12721782" translate="yes" xml:space="preserve">
          <source>There are many reasons, but the major one is cross-platform compatibility.</source>
          <target state="translated">原因有很多,但最主要的是跨平台兼容。</target>
        </trans-unit>
        <trans-unit id="4f22a618b10f083a38eaf97d7560bbf775ba04c7" translate="yes" xml:space="preserve">
          <source>There are many ways to ensure that values are what you expect or want to accept. Besides the specific examples that we cover in the perlfaq, you can also look at the modules with &quot;Assert&quot; and &quot;Validate&quot; in their names, along with other modules such as &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt;.</source>
          <target state="translated">有很多方法可以确保值是您期望或想要接受的。除了我们在perlfaq中介绍的特定示例外，您还可以查看名称中带有&amp;ldquo; Assert&amp;rdquo;和&amp;ldquo; Validate&amp;rdquo;的模块，以及诸如&lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp :: Common之&lt;/a&gt;类的其他模块。</target>
        </trans-unit>
        <trans-unit id="c508352f954b14145337f34025470ea842ef7b40" translate="yes" xml:space="preserve">
          <source>There are many ways to get multiline data into a string. If you want it to happen automatically while reading input, you'll want to set $/ (probably to '' for paragraphs or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for the whole file) to allow you to read more than one line at a time.</source>
          <target state="translated">有多种方法可以将多行数据转换为字符串。如果您希望它在读取输入时自动发生，则需要设置$ /（对于段落可能设置为&amp;rdquo;，对于整个文件则设置为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），以允许您一次读取多行。</target>
        </trans-unit>
        <trans-unit id="3dc3f3b5eae147e801f5f43fb6a8fbac0ae189bf" translate="yes" xml:space="preserve">
          <source>There are many, many Unicode character properties. For the full list see &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;. Most of them have synonyms with shorter names, also listed there. Some synonyms are a single character. For these, you can drop the braces. For instance, &lt;code&gt;\pM&lt;/code&gt; is the same thing as &lt;code&gt;\p{Mark}&lt;/code&gt; , meaning things like accent marks.</source>
          <target state="translated">有很多很多Unicode字符属性。有关完整列表，请参见&lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;。它们中的大多数具有短名称的同义词，也在此列出。一些同义词是单个字符。对于这些，您可以放下大括号。例如， &lt;code&gt;\pM&lt;/code&gt; 与 &lt;code&gt;\p{Mark}&lt;/code&gt; ，意味着带有重音符号的东西。</target>
        </trans-unit>
        <trans-unit id="1a61fc5e0ce0e0ef09d3d9c85a06d1ddbe46e285" translate="yes" xml:space="preserve">
          <source>There are many, many code points, but computers work with bytes, and a byte has room for only 256 values. Unicode has many more characters than that, so you need a method to make these accessible.</source>
          <target state="translated">代码点有很多很多,但计算机是用字节工作的,一个字节只能容纳256个值。Unicode有很多比这更多的字符,所以你需要一种方法来使这些字符能够被访问。</target>
        </trans-unit>
        <trans-unit id="88acdd96ec6d6927c08fab60ea3227280069d628" translate="yes" xml:space="preserve">
          <source>There are many, many sources for Solaris information. A few of the important ones for perl:</source>
          <target state="translated">关于Solaris的信息有很多很多的来源。对于perl来说,有几个重要的。</target>
        </trans-unit>
        <trans-unit id="c8f4eee710987379a0f55c604a3354e69d7b2875" translate="yes" xml:space="preserve">
          <source>There are modules to help you through the process of writing a module: &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::ModuleMaker&quot;&gt;ExtUtils::ModuleMaker&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Install&quot;&gt;Module::Install&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt;</source>
          <target state="translated">有一些模块可以帮助您完成编写模块的过程：&lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::ModuleMaker&quot;&gt;ExtUtils :: ModuleMaker&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Module::Install&quot;&gt;Module :: Install&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="61d4491371efc2ca44fd016e5d9139fc5fa773fa" translate="yes" xml:space="preserve">
          <source>There are no loops of references.</source>
          <target state="translated">没有参考的循环。</target>
        </trans-unit>
        <trans-unit id="476c776008d55428fe7585fbd0c3dce927c522c4" translate="yes" xml:space="preserve">
          <source>There are no unique methods for unknown results.</source>
          <target state="translated">对于未知的结果,没有唯一的方法。</target>
        </trans-unit>
        <trans-unit id="b571d2027807fc8b9e77b0de9129097419041bc0" translate="yes" xml:space="preserve">
          <source>There are non-obvious Unicode rules under &lt;code&gt;/i&lt;/code&gt; that can match variably, but which you might not think could. For example, the substring &lt;code&gt;&quot;ss&quot;&lt;/code&gt; can match the single character LATIN SMALL LETTER SHARP S. There are other sequences of ASCII characters that can match single ligature characters, such as LATIN SMALL LIGATURE FFI matching &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/ffi/i&lt;/a&gt;&lt;/code&gt;. Starting in Perl v5.16, if you only care about ASCII matches, adding the &lt;code&gt;/aa&lt;/code&gt; modifier to the regex will exclude all these non-obvious matches, thus getting rid of this message. You can also say &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re qw(/aa)&lt;/code&gt; to apply &lt;code&gt;/aa&lt;/code&gt; to all regular expressions compiled within its scope. See &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;/i&lt;/code&gt; 下有一些非显而易见的Unicode规则，它们可以可变地匹配，但是您可能认为不可能。例如，子字符串 &lt;code&gt;&quot;ss&quot;&lt;/code&gt; 可以匹配单个字符LATIN SMALL LETTER SHARPS。还有其他可以匹配单个连字字符的ASCII字符序列，例如，与 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/ffi/i&lt;/a&gt;&lt;/code&gt; 匹配的LATIN SMALL LIGATURE FFI 。从Perl v5.16开始，如果只关心ASCII匹配，则将 &lt;code&gt;/aa&lt;/code&gt; 修饰符添加到正则表达式中将排除所有这些非显而易见的匹配，从而消除了此消息。您也可以说 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re qw(/aa)&lt;/code&gt; 将 &lt;code&gt;/aa&lt;/code&gt; 应用于在其范围内编译的所有正则表达式。参见&lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e5ad264a4513834556a80639fe98434e6bc7fc63" translate="yes" xml:space="preserve">
          <source>There are now two nested loops in the code: the outer loop for reading the compressed data from STDIN, as before; and the inner loop to carry out the uncompression.</source>
          <target state="translated">现在,代码中有两个嵌套循环:外层循环用于从STDIN中读取压缩数据,就像之前一样;内层循环用于进行解压。</target>
        </trans-unit>
        <trans-unit id="a69e0c87595733580f5c73f14c1fdeb5543877d6" translate="yes" xml:space="preserve">
          <source>There are only a few attributes currently handled by Perl itself (or directly by this module, depending on how you look at it.) However, package-specific attributes are allowed by an extension mechanism. (See &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;Package-specific Attribute Handling&lt;/a&gt; below.)</source>
          <target state="translated">目前，Perl本身（或直接由此模块（取决于您如何看待））处理的属性只有少数。但是，扩展机制允许特定于包的属性。（请参阅下面&lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;的特定于包的属性处理&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="108ccf06b73794e0f286d42a6259562039de6c36" translate="yes" xml:space="preserve">
          <source>There are other documents which might contain the information that you're looking for:</source>
          <target state="translated">还有其他文件可能包含你要找的信息。</target>
        </trans-unit>
        <trans-unit id="ffadbd86efea8ed0c7e9318ac1bd6a93e63feaa1" translate="yes" xml:space="preserve">
          <source>There are other minor differences, particularly regarding &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;, but in general, the correspondence is extremely close.</source>
          <target state="translated">还有其他一些细微的差别，特别是关于 &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; ，但是通常，对应关系非常接近。</target>
        </trans-unit>
        <trans-unit id="e7bb3958077e624c5300c166b4aa5d1f00cfb6ff" translate="yes" xml:space="preserve">
          <source>There are other runtime options as well. You can use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">还有其他运行时选项。您可以使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fae6e762f25c5a7d9726dbb80f1e49251722d367" translate="yes" xml:space="preserve">
          <source>There are platforms where longs are 64 bits, and platforms where ints are 64 bits, and while we are out to shock you, even platforms where shorts are 64 bits. This is all legal according to the C standard. (In other words, &quot;long long&quot; is not a portable way to specify 64 bits, and &quot;long long&quot; is not even guaranteed to be any wider than &quot;long&quot;.)</source>
          <target state="translated">有的平台长线是64位,有的平台ints是64位,当我们要冲击你的时候,甚至有的平台短线是64位。根据C标准,这都是合法的。(换句话说,&quot;long长 &quot;并不是一种可移植的指定64位的方式,&quot;long长 &quot;甚至不能保证比 &quot;long &quot;更宽)。</target>
        </trans-unit>
        <trans-unit id="a1d48b6e5e54bf5c7c0f9c8f92bbb4b843c99efe" translate="yes" xml:space="preserve">
          <source>There are probably many more bugs on non-ASCII platforms (EBCDIC).</source>
          <target state="translated">在非ASCII平台(EBCDIC)上可能还有很多bug。</target>
        </trans-unit>
        <trans-unit id="6034cbb411ab9fcf9d496b60426633cf7c795bb5" translate="yes" xml:space="preserve">
          <source>There are quite a few systems out there that do worse!</source>
          <target state="translated">有不少系统做得更差!</target>
        </trans-unit>
        <trans-unit id="1d2d754395a1d1b23e17d21c745bf8aafd6b351f" translate="yes" xml:space="preserve">
          <source>There are rare cases where this package-based resolution can be a problem. If you copy a subroutine from one package to another, &lt;code&gt;SUPER&lt;/code&gt; resolution will be done based on the original package.</source>
          <target state="translated">在极少数情况下，这种基于包的解决方案可能会成为问题。如果将子例程从一个程序包复制到另一个程序包，则将基于原始程序包完成 &lt;code&gt;SUPER&lt;/code&gt; 解析。</target>
        </trans-unit>
        <trans-unit id="af62a9f4883bfebec9e4b48e9587f48259af1d0b" translate="yes" xml:space="preserve">
          <source>There are really two tracks of perl development: a maintenance version and an experimental version. The maintenance versions are stable, and have an even number as the minor release (i.e. perl5.18.x, where 18 is the minor release). The experimental versions may include features that don't make it into the stable versions, and have an odd number as the minor release (i.e. perl5.19.x, where 19 is the minor release).</source>
          <target state="translated">perl的发展其实有两个轨道:一个维护版和一个实验版。维护版本是稳定的,并且有一个偶数作为次要版本(例如perl5.18.x,其中18是次要版本)。实验版本可能包含一些没有进入稳定版本的功能,并且以奇数作为次要版本(例如 perl5.19.x,其中 19 是次要版本)。</target>
        </trans-unit>
        <trans-unit id="b1bf8726c4584d2c3d7eed2a3217ca6397579941" translate="yes" xml:space="preserve">
          <source>There are several I/O operators you should know about.</source>
          <target state="translated">有几个I/O运算符是你应该知道的。</target>
        </trans-unit>
        <trans-unit id="2fda79a606c9c0725617e5e789142491b7fdc787" translate="yes" xml:space="preserve">
          <source>There are several ambiguous cases where a conversion routine cannot determine whether an input filename is in Unix format or in VMS format, since now both VMS and Unix file specifications may have characters in them that could be mistaken for syntax delimiters of the other type. So some pathnames simply cannot be used in a mode that allows either type of pathname to be present. Perl will tend to assume that an ambiguous filename is in Unix format.</source>
          <target state="translated">有几种模棱两可的情况,转换例程无法确定输入的文件名是Unix格式还是VMS格式,因为现在VMS和Unix文件规范中都可能有一些字符,可能被误认为是另一种类型的语法定界符。所以有些路径名根本不能在允许任何一种类型的路径名存在的模式下使用。Perl会倾向于假设一个模棱两可的文件名是Unix格式的。</target>
        </trans-unit>
        <trans-unit id="dc2d6ce8616f44441a994dbb2d806ba6e4997805" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying countries. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">您可以使用几种不同的代码集来识别国家。您可以使用名称或本模块自动导出的常量来指定代码集。</target>
        </trans-unit>
        <trans-unit id="74b369e9ecdad508287761106812f2205698bcfc" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying currencies. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">您可以使用几种不同的代码集来识别货币。您可以使用名称或本模块自动导出的常量来指定代码集。</target>
        </trans-unit>
        <trans-unit id="c5df10a209c7b9d0bd6df6a76c15e47c845b73fd" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying languages. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">您可以使用几种不同的代码集来识别语言。代码集可以使用名称或本模块自动导出的常量来指定。</target>
        </trans-unit>
        <trans-unit id="357e0be22039446c2158a4027e1ee33566fa847b" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying scripts. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">您可以使用几种不同的代码集来识别脚本。代码集可以使用名称或本模块自动导出的常量来指定。</target>
        </trans-unit>
        <trans-unit id="c871d77268a0e9a3faf86ba66c7adbf672f7193a" translate="yes" xml:space="preserve">
          <source>There are several escape sequences that convert characters or strings between upper and lower case, and they are also available within patterns. &lt;code&gt;\l&lt;/code&gt; and &lt;code&gt;\u&lt;/code&gt; convert the next character to lower or upper case, respectively:</source>
          <target state="translated">有多个转义序列可在大写和小写之间转换字符或字符串，并且它们也可在模式中使用。 &lt;code&gt;\l&lt;/code&gt; 和 &lt;code&gt;\u&lt;/code&gt; 将下一个字符转换为小写或大写：</target>
        </trans-unit>
        <trans-unit id="8dd1b15a1dbfd18df05cd02be13096a5a0b828cf" translate="yes" xml:space="preserve">
          <source>There are several functions available to specify characters and code points portably in tests. The always-preloaded functions &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; and its inverse &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt; take code points and translate appropriately. The file</source>
          <target state="translated">有几种功能可以在测试中方便地指定字符和代码点。始终预加载的函数 &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; 及其逆向 &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt; 代码点并进行适当转换。文件</target>
        </trans-unit>
        <trans-unit id="324d2fa183413ecef672812d1ff51b1b76337a11" translate="yes" xml:space="preserve">
          <source>There are several great resources for locating workshops: the &lt;a href=&quot;#Websites&quot;&gt;websites&lt;/a&gt; mentioned above, the &lt;a href=&quot;#Calendar-of-Perl-Events&quot;&gt;calendar&lt;/a&gt; mentioned below, and the YAPC Europe website, &lt;a href=&quot;http://www.yapceurope.org/&quot;&gt;http://www.yapceurope.org/&lt;/a&gt;, which is probably the best resource for European Perl events.</source>
          <target state="translated">有很多资源可用于安排研讨会：上面提到的&lt;a href=&quot;#Websites&quot;&gt;网站，&lt;/a&gt;下面提到的&lt;a href=&quot;#Calendar-of-Perl-Events&quot;&gt;日历&lt;/a&gt;，以及YAPC欧洲网站&lt;a href=&quot;http://www.yapceurope.org/&quot;&gt;http://www.yapceurope.org/&lt;/a&gt;，这可能是欧洲Perl活动的最佳资源。</target>
        </trans-unit>
        <trans-unit id="70817f22a3f6a9efb5f508894682105db2aa6387" translate="yes" xml:space="preserve">
          <source>There are several of these, which are equivalents, using the &lt;code&gt;\p{}&lt;/code&gt; notation, for Posix classes and are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">对于Posix类，其中有几种使用 &lt;code&gt;\p{}&lt;/code&gt; 表示形式是等效的，并&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;在perlrecharclass&lt;/a&gt;中的POSIX字符类中进行了描述。</target>
        </trans-unit>
        <trans-unit id="1f83d1183ceda85cce3fcdc239963f72e745557e" translate="yes" xml:space="preserve">
          <source>There are several of these, which are the standard Posix classes extended to the full Unicode range. They are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">其中有几种，它们是扩展到完整Unicode范围的标准Posix类。&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;在perlrecharclass&lt;/a&gt;中的POSIX字符类中对其进行了描述。</target>
        </trans-unit>
        <trans-unit id="e3db56f779a367ad8451b62021cf957e6240bc01" translate="yes" xml:space="preserve">
          <source>There are several types of character class tests that Perl implements. The only ones described here are those that directly correspond to C library functions that operate on 8-bit characters, but there are equivalents that operate on wide characters, and UTF-8 encoded strings. All are more fully described in &lt;a href=&quot;perlapi#Character-classification&quot;&gt;Character classification in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;Character case changing in perlapi&lt;/a&gt;.</source>
          <target state="translated">Perl实现了几种类型的字符类测试。此处描述的唯一函数是直接对应于对8位字符进行操作的C库函数的函数，但是也存在与对宽字符和UTF-8编码的字符串进行操作的等效项。所有被更充分地描述&lt;a href=&quot;perlapi#Character-classification&quot;&gt;字符分类中负责填实perlapi&lt;/a&gt;和&lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;字符情况变化负责填实perlapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2e0a93aaf35e3ad5cd5182c4904a3f139cb368f" translate="yes" xml:space="preserve">
          <source>There are several ways to call the debugger:</source>
          <target state="translated">调用调试器有几种方法。</target>
        </trans-unit>
        <trans-unit id="e8db18a3a166163bfb23804a9a1202e4ece1bc54" translate="yes" xml:space="preserve">
          <source>There are several ways to wrap your Perl scripts in DCL</source>
          <target state="translated">有几种方法可以将Perl脚本包装在DCL中。</target>
        </trans-unit>
        <trans-unit id="9d4463c6ded942fe4cd0ec81ef54653fbdb5493c" translate="yes" xml:space="preserve">
          <source>There are some bugs in the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&quot;U0&quot;&lt;/code&gt; template</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&quot;U0&quot;&lt;/code&gt; 模板中存在一些错误</target>
        </trans-unit>
        <trans-unit id="5363960c51ded4425aac0c5e8d1bf8c47e9bafcf" translate="yes" xml:space="preserve">
          <source>There are some cases where Perl can't immediately tell the difference between an expression and a statement. For instance, the syntax for a block and an anonymous hash reference constructor look the same unless there's something in the braces to give Perl a hint. The ellipsis is a syntax error if Perl doesn't guess that the &lt;code&gt;{ ... }&lt;/code&gt; is a block. In that case, it doesn't think the &lt;code&gt;...&lt;/code&gt; is an ellipsis because it's expecting an expression instead of a statement:</source>
          <target state="translated">在某些情况下，Perl无法立即说出表达式和语句之间的区别。例如，块的语法和匿名哈希引用构造函数的外观相同，除非花括号中的内容可以为Perl提供提示。如果Perl没猜到 &lt;code&gt;{ ... }&lt;/code&gt; 是一个块，则省略号是语法错误。在那种情况下，它不认为 &lt;code&gt;...&lt;/code&gt; 是省略号，因为它期望使用表达式而不是语句：</target>
        </trans-unit>
        <trans-unit id="83d390e2b6c3127ccfec700a0a95db3ede4e9652" translate="yes" xml:space="preserve">
          <source>There are some caveats with the use of runtime statements like &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter&lt;/code&gt; and the assignment to package variables, which can be very subtle for the unaware programmer. This may happen for instance with mutually recursive modules, which are affected by the time the relevant constructions are executed.</source>
          <target state="translated">使用运行时语句有一些注意事项，例如 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter&lt;/code&gt; 和对程序包变量的分配，这对于不了解程序的程序员可能非常微妙。例如，这可能会在相互递归的模块中发生，这些模块受相关构造的执行时间影响。</target>
        </trans-unit>
        <trans-unit id="9d05d692911a48f923ff823586f7db33a368c559" translate="yes" xml:space="preserve">
          <source>There are some convenience functions available that can help with the destruction of xVs. These functions introduce the concept of &quot;mortality&quot;. An xV that is mortal has had its reference count marked to be decremented, but not actually decremented, until &quot;a short time later&quot;. Generally the term &quot;short time later&quot; means a single Perl statement, such as a call to an XSUB function. The actual determinant for when mortal xVs have their reference count decremented depends on two macros, SAVETMPS and FREETMPS. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; and &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for more details on these macros.</source>
          <target state="translated">有一些便利功能可以帮助销毁xV。这些功能引入了&amp;ldquo;死亡率&amp;rdquo;的概念。致命的xV已将其参考计数标记为递减，但实际上并未递减，直到&amp;ldquo;稍后&amp;rdquo;。通常，术语&amp;ldquo;稍后时间短&amp;rdquo;表示单个Perl语句，例如对XSUB函数的调用。凡人xV的参考计数递减的实际决定因素取决于两个宏SAVETMPS和FREETMPS。有关这些宏的更多详细信息，请参见&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;和&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="34b9699f0d3b28a88deb2c4c365035a0647ae160" translate="yes" xml:space="preserve">
          <source>There are some difficulties in using the tied hash interface if you want to manipulate a BTREE database with duplicate keys. Consider this code:</source>
          <target state="translated">如果你想操作一个有重复键的BTREE数据库,使用绑定哈希接口会有一些困难。考虑一下这段代码。</target>
        </trans-unit>
        <trans-unit id="c652dbfd06883d908b23bc1bfea111a0463399a9" translate="yes" xml:space="preserve">
          <source>There are some drawbacks to this approach. One is that any extension which calls any file-manipulating C function will need to be recompiled (just follow the usual &quot;perl Makefile.PL; make; make test; make install&quot; procedure).</source>
          <target state="translated">这种方法有一些缺点。其一是任何调用任何文件操纵C函数的扩展都需要重新编译(只需按照通常的 &quot;perl Makefile.PL;make;make test;make install &quot;程序)。</target>
        </trans-unit>
        <trans-unit id="0b359481d6fbdc6a6a4b31621c42bd37e3d7940e" translate="yes" xml:space="preserve">
          <source>There are some obvious disadvantages with this technique.</source>
          <target state="translated">这种技术有一些明显的缺点。</target>
        </trans-unit>
        <trans-unit id="5ca89f8811d4cbda81105708f26c4da2bc407dd8" translate="yes" xml:space="preserve">
          <source>There are some optional options you can pass to &lt;code&gt;memoize&lt;/code&gt; to change the way it behaves a little. To supply options, invoke &lt;code&gt;memoize&lt;/code&gt; like this:</source>
          <target state="translated">您可以传递一些可选选项来进行 &lt;code&gt;memoize&lt;/code&gt; 以更改其行为方式。要提供选项，请像这样调用 &lt;code&gt;memoize&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="362784bb7e407303367ae06c7f4d21b101719adc" translate="yes" xml:space="preserve">
          <source>There are some shortcuts for oneliners; see &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt; in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">有一些简单的捷径可供选择。在&lt;a href=&quot;perlrun&quot;&gt;perlrun中&lt;/a&gt;查看&lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb6709b6148bb02040a39a95e98f282835dfc33f" translate="yes" xml:space="preserve">
          <source>There are some warnings with respect to malformed hyperlinks:</source>
          <target state="translated">对于畸形的超链接,有一些警告。</target>
        </trans-unit>
        <trans-unit id="ce8df6ad608907441859c0c720df59bd6834bb9d" translate="yes" xml:space="preserve">
          <source>There are still many places where Unicode (in some encoding or another) could be given as arguments or received as results, or both in Perl, but it is not, in spite of Perl having extensive ways to input and output in Unicode, and a few other &quot;entry points&quot; like the &lt;code&gt;@ARGV&lt;/code&gt; array (which can sometimes be interpreted as UTF-8).</source>
          <target state="translated">在Perl中，仍然有很多地方可以将Unicode（以某种编码或另一种形式）作为参数或作为结果接收，或在这两者中都可以，但是，尽管Perl具有使用Unicode进行输入和输出的广泛方法，但事实并非如此。其他一些&amp;ldquo;入口点&amp;rdquo;，例如 &lt;code&gt;@ARGV&lt;/code&gt; 数组（有时可以解释为UTF-8）。</target>
        </trans-unit>
        <trans-unit id="59db2905dffb1315acaf3a1dc211ceadeec4d5cb" translate="yes" xml:space="preserve">
          <source>There are three Command Line flags that can be used to control when warnings are (or aren't) produced:</source>
          <target state="translated">有三个命令行标志可以用来控制何时产生(或不产生)警告。</target>
        </trans-unit>
        <trans-unit id="10489a4543147a152f672e9c6f67f2c24de29afb" translate="yes" xml:space="preserve">
          <source>There are three basic ways of running external commands:</source>
          <target state="translated">运行外部命令的基本方式有三种。</target>
        </trans-unit>
        <trans-unit id="ee1484d5257f2915d554120f4ce6bfb497ce1d27" translate="yes" xml:space="preserve">
          <source>There are three basic ways that you can structure a threaded program. Which model you choose depends on what you need your program to do. For many non-trivial threaded programs, you'll need to choose different models for different pieces of your program.</source>
          <target state="translated">有三种基本的方式可以构建一个线程程序。你选择哪种模型取决于你需要你的程序做什么。对于许多非平凡的线程,你需要为你的程序的不同部分选择不同的模型。</target>
        </trans-unit>
        <trans-unit id="7fc3fd61896b5d12698d6fdcfdceea06c9dc86a3" translate="yes" xml:space="preserve">
          <source>There are three distinct concepts of &quot;next&quot; in the regex engine, and it is important to keep them clear.</source>
          <target state="translated">在regex引擎中,&quot;下一个 &quot;有三个截然不同的概念,必须要明确。</target>
        </trans-unit>
        <trans-unit id="95aff53d816fd931550c2a4895fd2449f30b17c2" translate="yes" xml:space="preserve">
          <source>There are three popular ways to avoid this overhead. One solution involves running the Apache HTTP server (available from &lt;a href=&quot;http://www.apache.org/&quot;&gt;http://www.apache.org/&lt;/a&gt; ) with either of the mod_perl or mod_fastcgi plugin modules.</source>
          <target state="translated">有三种避免这种开销的流行方法。一种解决方案涉及使用带有mod_perl或mod_fastcgi插件模块的Apache HTTP服务器（可从&lt;a href=&quot;http://www.apache.org/&quot;&gt;http://www.apache.org/获得&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="99df9d7a05fef99c9f9af3d138353a09ea2aa37e" translate="yes" xml:space="preserve">
          <source>There are three types of character classes in Perl regular expressions: the dot, backslash sequences, and the form enclosed in square brackets. Keep in mind, though, that often the term &quot;character class&quot; is used to mean just the bracketed form. Certainly, most Perl documentation does that.</source>
          <target state="translated">在 Perl 正则表达式中,有三种类型的字符类:圆点、反斜杠序列和用方括号括起来的形式。但请记住,术语 &quot;字符类 &quot;通常只用来指方括号内的形式。当然,大多数Perl文档都是这样做的。</target>
        </trans-unit>
        <trans-unit id="a78a1c3edbdc828e2c5469275355a4d4c1a4e525" translate="yes" xml:space="preserve">
          <source>There are three ways to do this. First, the easy but inefficient way, which is also the default, in order to maintain source compatibility with extensions: whenever</source>
          <target state="translated">有三种方法可以做到这一点。第一,简单但效率不高的方法,这也是默认的,为了保持源码与扩展的兼容性:每当</target>
        </trans-unit>
        <trans-unit id="7d88ffa178365fa0703151483456030669a9d8af" translate="yes" xml:space="preserve">
          <source>There are three ways to write a test in the core: &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt;,</source>
          <target state="translated">可以通过三种方法在核心中编写测试：&lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt;，</target>
        </trans-unit>
        <trans-unit id="1233ca5594cc5aa5bc69145748e72c13824fb763" translate="yes" xml:space="preserve">
          <source>There are three ways to write your own source filter. You can write it in C, use an external program as a filter, or write the filter in Perl. I won't cover the first two in any great detail, so I'll get them out of the way first. Writing the filter in Perl is most convenient, so I'll devote the most space to it.</source>
          <target state="translated">有三种方法可以编写自己的源过滤器。你可以用C语言写,用外部程序做过滤器,或者用Perl写过滤器。前两种我不会很详细地介绍,所以我先把它们说出来。用Perl写过滤器是最方便的,所以我用最多的篇幅来介绍。</target>
        </trans-unit>
        <trans-unit id="4d1ca307ab6382d572650b48515269fd5ebc805c" translate="yes" xml:space="preserve">
          <source>There are times when you may find it useful to have a thread explicitly give up the CPU to another thread. You may be doing something processor-intensive and want to make sure that the user-interface thread gets called frequently. Regardless, there are times that you might want a thread to give up the processor.</source>
          <target state="translated">有些时候,你可能会发现让一个线程明确地把CPU让给另一个线程是很有用的。你可能正在做一些处理器密集型的事情,并希望确保用户接口线程被频繁调用。无论如何,有些时候,你可能会希望一个线程放弃处理器。</target>
        </trans-unit>
        <trans-unit id="aabf4548dd9ce503cb7793127ff7d0d6ca4a9258" translate="yes" xml:space="preserve">
          <source>There are two basic modes of operation (plus turning if off):</source>
          <target state="translated">有两种基本的操作模式(如果关闭则加转)。</target>
        </trans-unit>
        <trans-unit id="53b9f0a36cbfc725453b6b4804987d2d7a53bc2c" translate="yes" xml:space="preserve">
          <source>There are two callbacks, &lt;code&gt;named_buff&lt;/code&gt; is called in all the cases the FETCH, STORE, DELETE, CLEAR, EXISTS and SCALAR &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; callbacks would be on changes to &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; and &lt;code&gt;named_buff_iter&lt;/code&gt; in the same cases as FIRSTKEY and NEXTKEY.</source>
          <target state="translated">有两个回调，在所有情况下都将调用 &lt;code&gt;named_buff&lt;/code&gt; ：FETCH，STORE，DELETE，CLEAR，EXISTS和SCALAR &lt;a href=&quot;tie/hash&quot;&gt;Tie :: Hash&lt;/a&gt;回调将在与 &lt;code&gt;named_buff_iter&lt;/code&gt; 和NEXTKEY相同的情况下更改为 &lt;code&gt;%+&lt;/code&gt; 和 &lt;code&gt;%-&lt;/code&gt; 和named_buff_iter。</target>
        </trans-unit>
        <trans-unit id="85a26ce9bc0772a2a092df698289266d1f10ecae" translate="yes" xml:space="preserve">
          <source>There are two cases, multi-byte and single-byte locales. First multi-byte:</source>
          <target state="translated">有两种情况,多字节和单字节定位。先说多字节。</target>
        </trans-unit>
        <trans-unit id="3f6e50ca71fb9ef8a58634080d592b643d6be431" translate="yes" xml:space="preserve">
          <source>There are two cases:</source>
          <target state="translated">有两种情况。</target>
        </trans-unit>
        <trans-unit id="c07255028b3b5bd9a90385fc5c125ed8062cb54e" translate="yes" xml:space="preserve">
          <source>There are two commonly used techniques of profiling executables:</source>
          <target state="translated">有两种常用的剖析可执行文件的技术。</target>
        </trans-unit>
        <trans-unit id="4918f14b7918995ede690de784e45ce5b334a99c" translate="yes" xml:space="preserve">
          <source>There are two distinctive features of the dyna-linking model of OS/2: first, all the references to external functions are resolved at the compile time; second, there is no runtime fixup of the DLLs after they are loaded into memory. The first feature is an enormous advantage over other models: it avoids conflicts when several DLLs used by an application export entries with the same name. In such cases &quot;other&quot; models of dyna-linking just choose between these two entry points using some random criterion - with predictable disasters as results. But it is the second feature which requires the build of</source>
          <target state="translated">OS/2的dyna-link模型有两个明显的特点:第一,所有对外部函数的引用都在编译时解决;第二,DLL加载到内存中后,不需要在运行时对其进行修复。与其他模型相比,第一个特点有一个巨大的优势:当一个应用程序使用的几个DLL导出的条目名称相同时,它可以避免冲突。在这种情况下,dyna-link 的 &quot;其他 &quot;模型只是使用一些随机标准在这两个入口点之间进行选择--其结果是可预见的灾难。但是,正是第二个功能需要构建</target>
        </trans-unit>
        <trans-unit id="b851bdf3c81b8784e2dddc6e20b8e6c18978a571" translate="yes" xml:space="preserve">
          <source>There are two exit points from the inner uncompression loop.</source>
          <target state="translated">从内部解压循环有两个出口。</target>
        </trans-unit>
        <trans-unit id="108b59b47c97316f062b5266aff655788506a06e" translate="yes" xml:space="preserve">
          <source>There are two forms of octal escapes. Each is used to specify a character by its code point specified in octal notation.</source>
          <target state="translated">八进制转义有两种形式。每一种形式都是用八进制符号指定一个字符的码点。</target>
        </trans-unit>
        <trans-unit id="172fa4a9b4de533e56c4707adea17699b11d4a1b" translate="yes" xml:space="preserve">
          <source>There are two important points to remember:</source>
          <target state="translated">有两个重要的点要记住。</target>
        </trans-unit>
        <trans-unit id="ef6d3355d6294c0400eecec7ab06563e8c2ddc8b" translate="yes" xml:space="preserve">
          <source>There are two keys with a special meaning in the hash: &quot;read&quot; and &quot;write&quot;. These contain packlist files. After the copying is done, install() will write the list of target files to $from_to{write}. If $from_to{read} is given the contents of this file will be merged into the written file. The read and the written file may be identical, but on AFS it is quite likely that people are installing to a different directory than the one where the files later appear.</source>
          <target state="translated">在哈希中,有两个键具有特殊的意义。&quot;读 &quot;和 &quot;写&quot;。这些键包含了packlist文件。复制完成后,install()将把目标文件的列表写入$from_to{write}。如果给定了 $from_to{read},这个文件的内容将被合并到写入的文件中。读出的文件和写出的文件可能是相同的,但是在AFS上,人们很有可能安装到一个与后来出现的文件不同的目录。</target>
        </trans-unit>
        <trans-unit id="f06480546f8f7593dd6ae9d9e44d7bf0995b966a" translate="yes" xml:space="preserve">
          <source>There are two new display parameters.</source>
          <target state="translated">有两个新的显示参数。</target>
        </trans-unit>
        <trans-unit id="3c86f1c0ffd1daa198d3368c1af9e850c8735019" translate="yes" xml:space="preserve">
          <source>There are two operands, but no operator giving how you want to combine them.</source>
          <target state="translated">有两个操作数,但没有给出你想如何组合它们的操作数。</target>
        </trans-unit>
        <trans-unit id="24dc61084886e44e27660b4a97166077845b5c95" translate="yes" xml:space="preserve">
          <source>There are two package separators in Perl: A double colon (&lt;code&gt;::&lt;/code&gt; ) and a single quote (&lt;code&gt;'&lt;/code&gt;). Normal identifiers can start or end with a double colon, and can contain several parts delimited by double colons. Single quotes have similar rules, but with the exception that they are not legal at the end of an identifier: That is, &lt;code&gt;$'foo&lt;/code&gt; and &lt;code&gt;$foo'bar&lt;/code&gt; are legal, but &lt;code&gt;$foo'bar'&lt;/code&gt; is not.</source>
          <target state="translated">Perl中有两个包分隔符：双冒号（ &lt;code&gt;::&lt;/code&gt; 和单引号（ &lt;code&gt;'&lt;/code&gt; ）。普通标识符可以以双冒号开头或结尾，并且可以包含由双冒号分隔的多个部分。单引号具有相似的规则，但唯一的 &lt;code&gt;$foo'bar&lt;/code&gt; 是标识符在标识符末尾不合法：即 &lt;code&gt;$'foo&lt;/code&gt; 和$ foo'bar是合法的，但 &lt;code&gt;$foo'bar'&lt;/code&gt; 不合法。</target>
        </trans-unit>
        <trans-unit id="75895a5372bf6c78e51cf652a3ae78bb3d9b2367" translate="yes" xml:space="preserve">
          <source>There are two principal conventions (it is useful to call them &lt;code&gt;Dos*&lt;/code&gt; and &lt;code&gt;Win*&lt;/code&gt; - though this part of the function signature is not always determined by the name of the API) of reporting the error conditions of OS/2 API. Most of &lt;code&gt;Dos*&lt;/code&gt; APIs report the error code as the result of the call (so 0 means success, and there are many types of errors). Most of &lt;code&gt;Win*&lt;/code&gt; API report success/fail via the result being &lt;code&gt;TRUE&lt;/code&gt; /&lt;code&gt;FALSE&lt;/code&gt; ; to find the reason for the failure one should call WinGetLastError() API.</source>
          <target state="translated">报告OS / 2 API的错误情况有两种主要的约定（将它们称为 &lt;code&gt;Dos*&lt;/code&gt; 和 &lt;code&gt;Win*&lt;/code&gt; 是有用的-尽管函数签名的这一部分并不总是由API的名称确定）。大多数 &lt;code&gt;Dos*&lt;/code&gt; API都会将错误代码报告为调用的结果（因此0表示成功，并且错误的类型很多）。大多数 &lt;code&gt;Win*&lt;/code&gt; API通过将结果为 &lt;code&gt;TRUE&lt;/code&gt; / &lt;code&gt;FALSE&lt;/code&gt; 来报告成功/失败；要查找失败的原因，应调用WinGetLastError（）API。</target>
        </trans-unit>
        <trans-unit id="87b7ddfa19fa0f3f3b716199a0f4db35df4687cb" translate="yes" xml:space="preserve">
          <source>There are two steps to running the test suite:</source>
          <target state="translated">运行测试套件有两个步骤。</target>
        </trans-unit>
        <trans-unit id="5595b4165f441d44d1cb7724594811d46925edfc" translate="yes" xml:space="preserve">
          <source>There are two structures used to store a compiled regular expression. One, the &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is populated by the engine currently being. used and some of its fields read by perl to implement things such as the stringification of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有两种用于存储已编译正则表达式的结构。第一种，&lt;a href=&quot;perlreapi&quot;&gt;perlreapi中&lt;/a&gt;描述的 &lt;code&gt;regexp&lt;/code&gt; 结构由当前正在使用的引擎填充。使用了它，perl读取了其中的某些字段以实现诸如 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 的字符串化之类的功能。</target>
        </trans-unit>
        <trans-unit id="fc2fe23c780ba1b117d60c962e46037021ac3aa2" translate="yes" xml:space="preserve">
          <source>There are two syntaxes for formatting codes:</source>
          <target state="translated">格式化代码有两种语法。</target>
        </trans-unit>
        <trans-unit id="7371ec3e37b63adab8d04f7c4222af55c486c054" translate="yes" xml:space="preserve">
          <source>There are two that I can think off.</source>
          <target state="translated">我能想到的有两个。</target>
        </trans-unit>
        <trans-unit id="6d886c39930696ad6e408c59f68366994aaac004" translate="yes" xml:space="preserve">
          <source>There are two ways to build persistent private variables in Perl 5.10. First, you can simply use the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; feature. Or, you can use closures, if you want to stay compatible with releases older than 5.10.</source>
          <target state="translated">在Perl 5.10中有两种方法来构建持久私有变量。首先，您可以简单地使用 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 功能。或者，如果您想与5.10之前的版本保持兼容，则可以使用闭包。</target>
        </trans-unit>
        <trans-unit id="6c7079fb330c8f6fcf4a67d7d60f1f7e8ba9c961" translate="yes" xml:space="preserve">
          <source>There are two ways to create and load an AV. The first method creates an empty AV:</source>
          <target state="translated">有两种方法可以创建和加载一个AV。第一种方法是创建一个空的AV。</target>
        </trans-unit>
        <trans-unit id="48bc33b0558cf40893cd4b6a9aee4a0aeea211f9" translate="yes" xml:space="preserve">
          <source>There are two ways to enable debugging output for regular expressions.</source>
          <target state="translated">有两种方法可以启用正则表达式的调试输出。</target>
        </trans-unit>
        <trans-unit id="ad6ac5b22382be34f18ee4c2a153755024871b3a" translate="yes" xml:space="preserve">
          <source>There are two ways to load the &lt;code&gt;feature&lt;/code&gt; pragma implicitly:</source>
          <target state="translated">有两种方法可以隐式加载 &lt;code&gt;feature&lt;/code&gt; 杂注：</target>
        </trans-unit>
        <trans-unit id="f214eee3e697782835e9e4f8a448217e9a53a985" translate="yes" xml:space="preserve">
          <source>There are two ways to use Cocoa from Perl. Apple's PerlObjCBridge module, included with Mac OS X, can be used by standalone scripts to access Foundation (i.e. non-GUI) classes and objects.</source>
          <target state="translated">有两种方法可以从Perl中使用Cocoa。苹果的PerlObjCBridge模块,包含在Mac OS X中,可以被独立的脚本用来访问基金会(即非GUI)类和对象。</target>
        </trans-unit>
        <trans-unit id="409a8226f327930f82376970d0a5dd5d41e49fa0" translate="yes" xml:space="preserve">
          <source>There are undoubtedly serious bugs lurking somewhere in code this funky :-) Bug reports and other feedback are most welcome.</source>
          <target state="translated">在如此时髦的代码中,无疑潜藏着严重的bug:-)我们非常欢迎BUG报告和其他反馈。</target>
        </trans-unit>
        <trans-unit id="85be9b959b2e4ac88632b966dc97bb4a96c09ffb" translate="yes" xml:space="preserve">
          <source>There are undoubtedly serious bugs lurking somewhere in this code, if only because parts of it give the impression of understanding a great deal more about Perl than they really do.</source>
          <target state="translated">毫无疑问,这段代码中的某个地方潜藏着严重的错误,如果只是因为其中的部分内容给人的印象是他们对 Perl 的理解比实际情况要多得多。</target>
        </trans-unit>
        <trans-unit id="04b3f04345fdb786670dce0b2cea7b0b8304663e" translate="yes" xml:space="preserve">
          <source>There are useful variations on this theme. The sense of the match can be reversed by using the &lt;code&gt;!~&lt;/code&gt; operator:</source>
          <target state="translated">这个主题有很多有用的变化。可以使用 &lt;code&gt;!~&lt;/code&gt; 运算符反转匹配的含义：</target>
        </trans-unit>
        <trans-unit id="ae9efcf4d71ac56a124108c21d7833f5bea0582a" translate="yes" xml:space="preserve">
          <source>There are usually several synonyms for each possible value. Use &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; to access those.</source>
          <target state="translated">每个可能的值通常都有几个同义词。使用&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;来访问它们。</target>
        </trans-unit>
        <trans-unit id="defaf951c93d8c59c8e8c2838dbcdfdd9abafeeb" translate="yes" xml:space="preserve">
          <source>There are usually three or four interval timers (signals) available: the &lt;code&gt;$which&lt;/code&gt; can be &lt;code&gt;ITIMER_REAL&lt;/code&gt; , &lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt; , &lt;code&gt;ITIMER_PROF&lt;/code&gt; , or &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; . Note that which ones are available depends: true UNIX platforms usually have the first three, but only Solaris seems to have &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; (which is used to profile multithreaded programs). Win32 unfortunately does not have interval timers.</source>
          <target state="translated">通常有三个或四个间隔计时器（信号）可用： &lt;code&gt;$which&lt;/code&gt; 可以是 &lt;code&gt;ITIMER_REAL&lt;/code&gt; ， &lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt; ， &lt;code&gt;ITIMER_PROF&lt;/code&gt; 或 &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; 。请注意，哪些可用取决于：真正的UNIX平台通常具有前三个，但是只有Solaris似乎具有 &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; （用于配置多线程程序）。不幸的是，Win32没有间隔计时器。</target>
        </trans-unit>
        <trans-unit id="0d22a105cc916ea14dd34be71dc22f4c1bb3fd7e" translate="yes" xml:space="preserve">
          <source>There are various aspects of the pattern that can be used to facilitate optimisations along these lines:</source>
          <target state="translated">模式有很多方面,可以按照这些思路来促进优化。</target>
        </trans-unit>
        <trans-unit id="e3cedfe60646d2e7422ff8b2a7a07f8c037537db" translate="yes" xml:space="preserve">
          <source>There are various other failures, that as of SunOS 4.1.4 and gcc 3.2.2 look a lot like gcc bugs. Many of the failures happen in the Encode tests, where for example when the test expects &quot;0&quot; you get &quot;&amp;amp;#48;&quot; which should after a little squinting look very odd indeed. Another example is earlier in</source>
          <target state="translated">从SunOS 4.1.4和gcc 3.2.2开始，还有许多其他故障，它们看起来很像gcc错误。许多失败都发生在Encode测试中，例如，当测试期望&amp;ldquo; 0&amp;rdquo;时，您将获得&amp;ldquo;＆＃48;&amp;rdquo;。稍稍s起眼睛后，看起来确实很奇怪。另一个例子是在</target>
        </trans-unit>
        <trans-unit id="e93c51ec114e78593d3350d4739a1d10d41d678a" translate="yes" xml:space="preserve">
          <source>There are various other synonyms that can be used besides the names listed in the table. For example, &lt;code&gt;\p{PosixAlpha}&lt;/code&gt; can be written as &lt;code&gt;\p{Alpha}&lt;/code&gt; . All are listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;.</source>
          <target state="translated">除了表中列出的名称之外，还可以使用其他各种同义​​词。例如， &lt;code&gt;\p{PosixAlpha}&lt;/code&gt; 可以写为 &lt;code&gt;\p{Alpha}&lt;/code&gt; 。所有这些都列&lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;在perluniprops中可通过\ p {}和\ P {}访问的属性中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="20fb423bc3be57a7bce8d37147a935d047431e3f" translate="yes" xml:space="preserve">
          <source>There are various special make targets that can be used to test Perl slightly differently than the standard &quot;test&quot; target. Not all them are expected to give a 100% success rate. Many of them have several aliases, and many of them are not available on certain operating systems.</source>
          <target state="translated">有各种特殊的make target可以用来测试Perl,与标准的 &quot;测试 &quot;目标略有不同。并不是所有的目标都能给出100%的成功率。它们中的许多都有几个别名,而且其中许多在某些操作系统上是不可用的。</target>
        </trans-unit>
        <trans-unit id="7a37b656849e5abe23739ebb1083bad00e7235fc" translate="yes" xml:space="preserve">
          <source>There are various syntaxes, listed below. In the syntaxes given, &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; , and &lt;code&gt;section&lt;/code&gt; cannot contain the characters '/' and '|'; and any '&amp;lt;' or '&amp;gt;' should be matched.</source>
          <target state="translated">下面列出了各种语法。在给定的语法中， &lt;code&gt;text&lt;/code&gt; ， &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;section&lt;/code&gt; 不能包含字符'/'和'|'；并且任何&amp;ldquo; &amp;lt;&amp;rdquo;或&amp;ldquo;&amp;gt;&amp;rdquo;都应匹配。</target>
        </trans-unit>
        <trans-unit id="d37ed54ad4b4e800cd45604ce3c3818f96427db4" translate="yes" xml:space="preserve">
          <source>There are various things to note:</source>
          <target state="translated">需要注意的事项有很多种。</target>
        </trans-unit>
        <trans-unit id="b76fc3582c89676c08603c7aa65b9cc5c9b6bcec" translate="yes" xml:space="preserve">
          <source>There are various ways in which the private and public flags may differ. For example, in perl 5.16 and earlier a tied SV may have a valid underlying value in the IV slot (so SvIOKp is true), but the data should be accessed via the FETCH routine rather than directly, so SvIOK is false. (In perl 5.18 onwards, tied scalars use the flags the same way as untied scalars.) Another is when numeric conversion has occurred and precision has been lost: only the private flag is set on 'lossy' values. So when an NV is converted to an IV with loss, SvIOKp, SvNOKp and SvNOK will be set, while SvIOK wont be.</source>
          <target state="translated">私有标志和公共标志有多种不同的方式。例如,在 perl 5.16 和更早的版本中,一个绑定的 SV 可能在 IV 槽中有一个有效的底层值(所以 SvIOKp 为真),但是数据应该通过 FETCH 例程而不是直接访问,所以 SvIOK 为假。(在perl 5.18以后,绑定标量与未绑定标量的使用方式相同)。另一种情况是当数值转换已经发生,并且精度已经丢失:只有私有标志被设置在 &quot;有损 &quot;的值上。因此,当一个 NV 转换为有损失的 IV 时,SvIOKp、SvNOKp 和 SvNOK 会被设置,而 SvIOK 不会被设置。</target>
        </trans-unit>
        <trans-unit id="bf9b799d87e5a86957d5b5b84b03a08b714f7c53" translate="yes" xml:space="preserve">
          <source>There are web archives of the mailing list at:</source>
          <target state="translated">邮件列表的网络档案在:</target>
        </trans-unit>
        <trans-unit id="35625b0405457bfbc71b97ae568ca975b4ffb8db" translate="yes" xml:space="preserve">
          <source>There aren't currently any real UTF-8 locales, even though some locale names contain the string &quot;UTF-8&quot;.</source>
          <target state="translated">目前还没有任何真正的UTF-8本地化,尽管有些本地化名称包含 &quot;UTF-8 &quot;字符串。</target>
        </trans-unit>
        <trans-unit id="afc581d54ed5726e14da03dd8d1af5cdf478d3d5" translate="yes" xml:space="preserve">
          <source>There can be whitespace between the operator and the quoting characters, except when &lt;code&gt;#&lt;/code&gt; is being used as the quoting character. &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q#foo#&lt;/a&gt;&lt;/code&gt; is parsed as the string &lt;code&gt;foo&lt;/code&gt; , while &lt;code&gt;q #foo#&lt;/code&gt; is the operator &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; followed by a comment. Its argument will be taken from the next line. This allows you to write:</source>
          <target state="translated">运算符和引号字符之间可以有空格，除非将 &lt;code&gt;#&lt;/code&gt; 用作引号字符。 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q#foo#&lt;/a&gt;&lt;/code&gt; 被解析为字符串 &lt;code&gt;foo&lt;/code&gt; ，而 &lt;code&gt;q #foo#&lt;/code&gt; 是运算符 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; ,后跟一个注释。其参数将从下一行获取。这使您可以编写：</target>
        </trans-unit>
        <trans-unit id="7f8e18aa50aec43fc98b47477339b319d9bf73e8" translate="yes" xml:space="preserve">
          <source>There does not need to be whitespace at the start of the &quot;&lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; input&lt;/code&gt; &quot; line, but it is useful for improving readability. Placing a semi-colon at the end of that line is also optional. Any amount and kind of whitespace may be placed between the &quot;&lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;&quot; and &quot;&lt;code&gt;input&lt;/code&gt; &quot;.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; input&lt;/code&gt; &amp;rdquo;行的开头不需要空格，但是对于提高可读性很有用。在该行的末尾放置分号也是可选的。在&amp;ldquo; &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;input&lt;/code&gt; &amp;rdquo; 之间可以放置任何数量和种类的空格。</target>
        </trans-unit>
        <trans-unit id="674ce7b791aca3a84e36e5ed443e53056266d194" translate="yes" xml:space="preserve">
          <source>There exists a port of Perl to the ILE environment. This port, however, is based quite an old release of Perl, Perl 5.00502 (August 1998). (As of July 2002 the latest release of Perl is 5.8.0, and even 5.6.1 has been out since April 2001.) If you need to run Perl on ILE, though, you may need this older port: &lt;a href=&quot;http://www.cpan.org/ports/#os400&quot;&gt;http://www.cpan.org/ports/#os400&lt;/a&gt; Note that any Perl release later than 5.00502 has not been ported to ILE.</source>
          <target state="translated">存在一个到ILE环境的Perl端口。但是，此端口基于Perl的较旧版本，Perl 5.00502（1998年8月）。（从2002年7月开始，Perl的最新版本是5.8.0，甚至从2001年4月开始已经发布5.6.1。）但是，如果您需要在ILE上运行Perl，则可能需要此旧端口：&lt;a href=&quot;http://www.cpan.org/ports/#os400&quot;&gt;http：// www.cpan.org/ports/#os400&lt;/a&gt;注意任何Perl的后续版本比5.00502还没有被移植到ILE。</target>
        </trans-unit>
        <trans-unit id="10164fd98639a8c3044721a3ed9b1556ef825187" translate="yes" xml:space="preserve">
          <source>There is a &quot;hints&quot; file for BS2000 called hints.posix-bc (because posix-bc is the OS name given by `uname`) that specifies the correct values for most things. The major problem is (of course) the EBCDIC character set. We have german EBCDIC version.</source>
          <target state="translated">BS2000有一个名为hints.posix-bc的 &quot;提示 &quot;文件(因为posix-bc是`uname`给出的操作系统名称),它规定了大多数事情的正确值。主要的问题是(当然)EBCDIC字符集。我们有德文EBCDIC版本。</target>
        </trans-unit>
        <trans-unit id="5374f2f6990509e72c419ef45603ab27e3bc80da" translate="yes" xml:space="preserve">
          <source>There is a $diagnostics::DEBUG variable you may set if you're desperately curious what sorts of things are being intercepted.</source>
          <target state="translated">有一个$diagnostics::DEBUG变量,如果你非常好奇被拦截的是什么东西,你可以设置。</target>
        </trans-unit>
        <trans-unit id="6a13bc3171b7f184b15ada467454c70823010717" translate="yes" xml:space="preserve">
          <source>There is a CPAN module, &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt;&lt;/code&gt;, which allows you to define your own mappings to be used in &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; (or their double-quoted string inlined versions such as &lt;code&gt;\U&lt;/code&gt; ). (Prior to Perl 5.16, this functionality was partially provided in the Perl core, but suffered from a number of insurmountable drawbacks, so the CPAN module was written instead.)</source>
          <target state="translated">有一个CPAN模块 &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt;&lt;/code&gt; ，它允许您定义自己的映射以用于 &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; （或双引号的字符串内联版本）例如 &lt;code&gt;\U&lt;/code&gt; ）。（在Perl 5.16之前，此功能部分地在Perl内核中提供，但是由于存在许多无法克服的缺陷，因此改为编写CPAN模块。）</target>
        </trans-unit>
        <trans-unit id="c5d3a875427fdf261fbe25e4b0c804d418f70748" translate="yes" xml:space="preserve">
          <source>There is a Clone module available on CPAN which implements deep cloning natively, i.e. without freezing to memory and thawing the result. It is aimed to replace Storable's dclone() some day. However, it does not currently support Storable hooks to redefine the way deep cloning is performed.</source>
          <target state="translated">在CPAN上有一个Clone模块,它可以实现原生的深度克隆,即不需要冻结内存和解冻结果。它的目标是有朝一日取代Storable的dclone()。然而,它目前不支持Storable钩子来重新定义深度克隆的方式。</target>
        </trans-unit>
        <trans-unit id="d1abe7c402c9589925c2fd5cdd3fc7738d6e503b" translate="yes" xml:space="preserve">
          <source>There is a Perl interface to TrollTech's Qt toolkit, but it does not appear to be maintained.</source>
          <target state="translated">TrollTech的Qt工具包有一个Perl接口,但似乎没有维护。</target>
        </trans-unit>
        <trans-unit id="2368d7b8dd55271d773f21a14ae9eb87cfb16560" translate="yes" xml:space="preserve">
          <source>There is a bug in perl5.6.0 with UV's that are &amp;gt;= 1&amp;lt;&amp;lt;31. This will show up as tests 8 and 9 of dualvar.t failing</source>
          <target state="translated">在perl5.6.0中，有一个UV &amp;gt;&amp;gt; 1 &amp;lt;&amp;lt; 31的错误。这将显示为dualvar.t的测试8和9失败</target>
        </trans-unit>
        <trans-unit id="74ad132a2446bd3d40e9bf990b8f1b1aa2a313b3" translate="yes" xml:space="preserve">
          <source>There is a central directory for the Perl community: &lt;a href=&quot;http://perl.org&quot;&gt;http://perl.org&lt;/a&gt; maintained by the Perl Foundation (&lt;a href=&quot;http://www.perlfoundation.org/&quot;&gt;http://www.perlfoundation.org/&lt;/a&gt;), which tracks and provides services for a variety of other community sites.</source>
          <target state="translated">Perl社区有一个中央目录：&lt;a href=&quot;http://perl.org&quot;&gt;http&lt;/a&gt; : //perl.org，由Perl基金会（&lt;a href=&quot;http://www.perlfoundation.org/&quot;&gt;http://www.perlfoundation.org/&lt;/a&gt;）维护，该目录跟踪并为其他各种社区站点提供服务。</target>
        </trans-unit>
        <trans-unit id="b14e35e5c9ac344a8ff5825a4050f6c40c0d0c03" translate="yes" xml:space="preserve">
          <source>There is a class method in &lt;code&gt;PerlIO::Layer&lt;/code&gt;&lt;code&gt;find&lt;/code&gt; which is implemented as XS code. It is called by &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to validate the layers:</source>
          <target state="translated">&lt;code&gt;PerlIO::Layer&lt;/code&gt; &lt;code&gt;find&lt;/code&gt; 中有一个类方法，该方法被实现为XS代码。通过 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 调用它以验证层：</target>
        </trans-unit>
        <trans-unit id="130b2ceadd9a5f49d4085944a7e2f2612f7d6b00" translate="yes" xml:space="preserve">
          <source>There is a facility called &quot;file extension associations&quot;. This can be manipulated via the two commands &quot;assoc&quot; and &quot;ftype&quot; that come standard with Windows. Type &quot;ftype /?&quot; for a complete example of how to set this up for perl scripts (Say what? You thought Windows wasn't perl-ready? :).</source>
          <target state="translated">有一种叫做 &quot;文件扩展名关联 &quot;的设施。这可以通过Windows的标准命令 &quot;assoc &quot;和 &quot;ftype &quot;来操作。输入 &quot;ftype /?&quot;,可以看到一个完整的例子,说明如何为perl脚本设置这个功能(说什么? 你以为Windows还没有perl-ready?</target>
        </trans-unit>
        <trans-unit id="56c8b0f7b0876f90abc844b5aa213cd2600b5f4e" translate="yes" xml:space="preserve">
          <source>There is a fairly obvious gotcha included with the line directive: Debuggers and profilers will only show the last source line to appear at a particular line number in a given file. Care should be taken not to cause line number collisions in code you'd like to debug later.</source>
          <target state="translated">在行指令中包含了一个相当明显的陷阱。调试器和剖析器只会显示给定文件中最后一行出现在特定行号的源码。需要注意的是,不要在你以后要调试的代码中造成行号冲突。</target>
        </trans-unit>
        <trans-unit id="bb9de8709414ce3be99387c65eb446322517dbc7" translate="yes" xml:space="preserve">
          <source>There is a full version history in the Changes file, and the Test::More versions included as core can be found using &lt;a href=&quot;../module/corelist&quot;&gt;Module::CoreList&lt;/a&gt;:</source>
          <target state="translated">在Changes文件中有完整的版本历史记录，可以使用&lt;a href=&quot;../module/corelist&quot;&gt;Module :: CoreList&lt;/a&gt;找到包含为核心的Test :: More版本：</target>
        </trans-unit>
        <trans-unit id="8d8d363093d476f461ae875eb02ff5a19f7dc579" translate="yes" xml:space="preserve">
          <source>There is a functional programming API available for programmers to query information.</source>
          <target state="translated">有一个功能编程API可供程序员查询信息。</target>
        </trans-unit>
        <trans-unit id="2afd310e60a2687221eb36caee1877ab18ed5e49" translate="yes" xml:space="preserve">
          <source>There is a further complication with non-closure anonymous subs (i.e. those that do not refer to any lexicals outside that sub). In this case, the anonymous prototype is shared rather than being cloned. This has the consequence that the parent may be freed while there are still active children, eg</source>
          <target state="translated">非封闭式匿名子(即那些不指向该子之外的任何词汇的子)还有一个复杂的问题。在这种情况下,匿名原型是共享的,而不是被克隆的。这样做的后果是,父类可能被释放,而仍然有活跃的子类,例如</target>
        </trans-unit>
        <trans-unit id="f36a7b0d4fbbd5ecb9f7c10c28ff43dbc8a0e2c1" translate="yes" xml:space="preserve">
          <source>There is a large collection of locale definitions at:</source>
          <target state="translated">有大量的地域定义集合在。</target>
        </trans-unit>
        <trans-unit id="164a3c40b19ffea76d12a9ba083e8f9f3b80b6e7" translate="yes" xml:space="preserve">
          <source>There is a large memory overhead for each record offset and for each cache entry: about 310 bytes per cached data record, and about 21 bytes per offset table entry.</source>
          <target state="translated">每条记录偏移和每个缓存条目都有很大的内存开销:每条缓存数据记录约310字节,每个偏移表条目约21字节。</target>
        </trans-unit>
        <trans-unit id="6d613e26c7817a472a293f57a0848d067f1f9f1e" translate="yes" xml:space="preserve">
          <source>There is a lint variant called &lt;code&gt;splint&lt;/code&gt; (Secure Programming Lint) available from &lt;a href=&quot;http://www.splint.org/&quot;&gt;http://www.splint.org/&lt;/a&gt; that should compile on any Unix-like platform.</source>
          <target state="translated">从&lt;a href=&quot;http://www.splint.org/&quot;&gt;http://www.splint.org/&lt;/a&gt;有一个名为 &lt;code&gt;splint&lt;/code&gt; （安全编程棉绒）的皮棉变体，可以在任何类似Unix的平台上进行编译。</target>
        </trans-unit>
        <trans-unit id="50d5366c81be8e75e037c5167a3d288dd1f93227" translate="yes" xml:space="preserve">
          <source>There is a list &lt;code&gt;=item&lt;/code&gt; right above the flagged line that has no text contents. You probably want to delete empty items.</source>
          <target state="translated">在标记行的正上方有一个列表 &lt;code&gt;=item&lt;/code&gt; ，没有文本内容。您可能要删除空项目。</target>
        </trans-unit>
        <trans-unit id="e52de09f7d095fa1c4329ee2a9ca8823bc2d60ff" translate="yes" xml:space="preserve">
          <source>There is a partial workaround (which can be made complete with newer OS/2 kernels): create a forwarder DLL with the same name as the DLL of the older version of Perl, which forwards the entry points to the newer Perl's DLL. Make this DLL accessible on (say) the &lt;code&gt;BEGINLIBPATH&lt;/code&gt; of the new Perl executable. When the new executable accesses old Perl's extension DLLs, they would request the old Perl's DLL by name, get the forwarder instead, so effectively will link with the currently running (new) Perl DLL.</source>
          <target state="translated">有一个局部解决方法（可以使用较新的OS / 2内核来完成）：创建一个与旧版Perl的DLL具有相同名称的转发器DLL，它将入口点转发到较新的Perl的DLL。使这个DLL在（例如）新Perl可执行文件的 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 上可访问。当新的可执行文件访问旧的Perl扩展DLL时，它们将按名称请求旧的Perl DLL，而是获取转发器，从而有效地链接到当前正在运行的（新）Perl DLL。</target>
        </trans-unit>
        <trans-unit id="57ca9ff3bac6a75872d6256fe67ed0855ac24ebb" translate="yes" xml:space="preserve">
          <source>There is a potential syntactic ambiguity between signatures and prototypes (see &lt;a href=&quot;#Prototypes&quot;&gt;Prototypes&lt;/a&gt;), because both start with an opening parenthesis and both can appear in some of the same places, such as just after the name in a subroutine declaration. For historical reasons, when signatures are not enabled, any opening parenthesis in such a context will trigger very forgiving prototype parsing. Most signatures will be interpreted as prototypes in those circumstances, but won't be valid prototypes. (A valid prototype cannot contain any alphabetic character.) This will lead to somewhat confusing error messages.</source>
          <target state="translated">签名和原型之间可能存在语法上的歧义（请参见&lt;a href=&quot;#Prototypes&quot;&gt;Prototypes&lt;/a&gt;），因为两者都以开括号开头并且都可以出现在某些相同的地方，例如在子例程声明中的名称之后。由于历史原因，当未启用签名时，在这种情况下的任何左括号都将触发非常宽容的原型解析。在这种情况下，大多数签名将被解释为原型，但不是有效的原型。 （有效的原型不能包含任何字母字符。）这将导致出现一些令人困惑的错误消息。</target>
        </trans-unit>
        <trans-unit id="d27354b37f9e6840bfd23c6a2efc0450a836df2f" translate="yes" xml:space="preserve">
          <source>There is a relationship between roles and classes, as each class implies the existence of a role of the same name. There is also a relationship between inheritance and roles, in that a subclass that inherits from an ancestor class implicitly performs any roles its parent performs. Thus you can use &lt;code&gt;DOES&lt;/code&gt; in place of &lt;code&gt;isa&lt;/code&gt; safely, as it will return true in all places where &lt;code&gt;isa&lt;/code&gt; will return true (provided that any overridden &lt;code&gt;DOES&lt;/code&gt;</source>
          <target state="translated">角色和类之间存在关系，因为每个类都隐含着同名角色。继承与角色之间也存在关系，因为从祖先类继承的子类隐式执行其父级执行的任何角色。因此，您可以安全地使用 &lt;code&gt;DOES&lt;/code&gt; 代替 &lt;code&gt;isa&lt;/code&gt; ，因为它在 &lt;code&gt;isa&lt;/code&gt; 将返回true的所有地方都将返回true（前提是任何重写的 &lt;code&gt;DOES&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d92cff32e2893123d7b11efd15dfbc88dd3973f8" translate="yes" xml:space="preserve">
          <source>There is a rich ecosystem of &lt;code&gt;Moose&lt;/code&gt; extensions on CPAN under the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2fsearch%3fquery%3dMooseX%26mode%3ddist&quot;&gt;MooseX&lt;/a&gt; namespace. In addition, many modules on CPAN already use &lt;code&gt;Moose&lt;/code&gt; , providing you with lots of examples to learn from.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2fsearch%3fquery%3dMooseX%26mode%3ddist&quot;&gt;MooseX&lt;/a&gt;命名空间下在CPAN上有一个丰富的 &lt;code&gt;Moose&lt;/code&gt; 扩展生态系统。此外，CPAN上的许多模块已经在使用 &lt;code&gt;Moose&lt;/code&gt; ，为您提供了很多示例可供学习。</target>
        </trans-unit>
        <trans-unit id="0db652ab14c5e9efe4a7bcfa81f503ee955d3fa8" translate="yes" xml:space="preserve">
          <source>There is a section detected in the page name of L&amp;lt;...&amp;gt;, e.g. &lt;code&gt;L&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; . POD hyperlinks may point to POD documents only. Please write &lt;code&gt;C&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; instead. Some formatters are able to expand this to appropriate code. For links to (builtin) functions, please say &lt;code&gt;L&amp;lt;perlfunc/mkdir&amp;gt;&lt;/code&gt; , without ().</source>
          <target state="translated">在页面名称L &amp;lt;...&amp;gt;中检测到一个部分，例如 &lt;code&gt;L&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; 。 POD超链接可能仅指向POD文档。请改写 &lt;code&gt;C&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; 。一些格式化程序可以将其扩展为适当的代码。有关（内置）函数的链接，请说 &lt;code&gt;L&amp;lt;perlfunc/mkdir&amp;gt;&lt;/code&gt; ，不带（）。</target>
        </trans-unit>
        <trans-unit id="00c1ae760ee79d8ac4a3185792db70643cfa006e" translate="yes" xml:space="preserve">
          <source>There is a single stash called &lt;code&gt;PL_defstash&lt;/code&gt; that holds the items that exist in the &lt;code&gt;main&lt;/code&gt; package. To get at the items in other packages, append the string &quot;::&quot; to the package name. The items in the &lt;code&gt;Foo&lt;/code&gt; package are in the stash &lt;code&gt;Foo::&lt;/code&gt; in PL_defstash. The items in the &lt;code&gt;Bar::Baz&lt;/code&gt; package are in the stash &lt;code&gt;Baz::&lt;/code&gt; in &lt;code&gt;Bar::&lt;/code&gt; 's stash.</source>
          <target state="translated">有一个名为 &lt;code&gt;PL_defstash&lt;/code&gt; 的存储区，用于保存 &lt;code&gt;main&lt;/code&gt; 包中存在的项目。要获取其他包装中的物品，请在包装名称后附加字符串&amp;ldquo; ::&amp;rdquo;。 &lt;code&gt;Foo&lt;/code&gt; 包中的项目位于PL_defstash 中的存储 &lt;code&gt;Foo::&lt;/code&gt; 中。在这些项目 &lt;code&gt;Bar::Baz&lt;/code&gt; 包是在藏匿 &lt;code&gt;Baz::&lt;/code&gt; 在 &lt;code&gt;Bar::&lt;/code&gt; 的藏匿处。</target>
        </trans-unit>
        <trans-unit id="410d21275559c0b069f15cf1ae78b078a451978c" translate="yes" xml:space="preserve">
          <source>There is a special form of this construct, called &lt;code&gt;\K&lt;/code&gt; (available since Perl 5.10.0), which causes the regex engine to &quot;keep&quot; everything it had matched prior to the &lt;code&gt;\K&lt;/code&gt; and not include it in &lt;code&gt;$&amp;amp;&lt;/code&gt; . This effectively provides variable-length look-behind. The use of &lt;code&gt;\K&lt;/code&gt; inside of another look-around assertion is allowed, but the behaviour is currently not well defined.</source>
          <target state="translated">此构造有一种特殊形式，称为 &lt;code&gt;\K&lt;/code&gt; （自Perl 5.10.0起可用），它使正则表达式引擎&amp;ldquo;保留&amp;rdquo;它在 &lt;code&gt;\K&lt;/code&gt; 之前匹配的所有内容，而不将其包含在 &lt;code&gt;$&amp;amp;&lt;/code&gt; 中。这有效地提供了变长后向。允许在另一个环视断言中使用 &lt;code&gt;\K&lt;/code&gt; ，但是该行为目前尚未很好定义。</target>
        </trans-unit>
        <trans-unit id="0599747d66099e132ad6b9e84b12be8636f0ae4e" translate="yes" xml:space="preserve">
          <source>There is a syntax error in the /usr/include/sys/socket.h header file that IBM supplies with USS V2R7, V2R8, and possibly V2R9. The problem with the header file is that near the definition of the SO_REUSEPORT constant there is a spurious extra '/' character outside of a comment like so:</source>
          <target state="translated">在/usr/include/sys/socket.h头文件中存在一个语法错误,IBM随USS V2R7、V2R8以及可能的V2R9一起提供。该头文件的问题是,在SO_REUSEPORT常量的定义附近,有一个虚假的额外'/'字符,在注释之外,像这样。</target>
        </trans-unit>
        <trans-unit id="b527eadae01dab13ed85ec63c9837bc3c0c67bda" translate="yes" xml:space="preserve">
          <source>There is a tradeoff between taking full advantage of one particular type of computer and taking advantage of a full range of them. Naturally, as you broaden your range and become more diverse, the common factors drop, and you are left with an increasingly smaller area of common ground in which you can operate to accomplish a particular task. Thus, when you begin attacking a problem, it is important to consider under which part of the tradeoff curve you want to operate. Specifically, you must decide whether it is important that the task that you are coding has the full generality of being portable, or whether to just get the job done right now. This is the hardest choice to be made. The rest is easy, because Perl provides many choices, whichever way you want to approach your problem.</source>
          <target state="translated">在充分利用一种特定类型的计算机和利用它们的全部类型之间存在着一种权衡。自然而然,随着你的范围扩大,变得越来越多样化,共同因素就会下降,你剩下的共同领域越来越小,你可以在其中操作来完成某项任务。因此,当你开始攻克一个问题时,重要的是要考虑你要在权衡曲线的哪一部分下操作。具体来说,你必须决定你正在编码的任务是否具有可移植的完全通用性,还是只需现在就完成任务是重要的。这是最难做出的选择。剩下的就很容易了,因为Perl提供了很多选择,无论你想用哪种方式来解决你的问题。</target>
        </trans-unit>
        <trans-unit id="8ea25b9abfe4373f567bc9679e7275e7fb164486" translate="yes" xml:space="preserve">
          <source>There is a utility called &lt;a href=&quot;../corelist&quot;&gt;corelist&lt;/a&gt; provided with this module which is a convenient way of querying from the command-line.</source>
          <target state="translated">此模块提供了一个名为&lt;a href=&quot;../corelist&quot;&gt;corelist&lt;/a&gt;的实用程序，该实用程序是从命令行查询的便捷方式。</target>
        </trans-unit>
        <trans-unit id="82aef8cfd5e32e2a307fc10353cb3d2e49f98a7d" translate="yes" xml:space="preserve">
          <source>There is a variable &lt;code&gt;$File::Find::fullname&lt;/code&gt; which holds the absolute pathname of the file with all symbolic links resolved. If the link is a dangling symbolic link, then fullname will be set to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有一个变量 &lt;code&gt;$File::Find::fullname&lt;/code&gt; ，它保存文件的绝对路径名，并解析所有符号链接。如果该链接是悬挂的符号链接，则全名将设置为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b9ea31c4237da29f14d09c3e17b0abf6058f6c2" translate="yes" xml:space="preserve">
          <source>There is a way to achieve a similar task from C via Perl API: create a</source>
          <target state="translated">有一种方法可以通过Perl API从C语言实现类似的任务:创建一个</target>
        </trans-unit>
        <trans-unit id="186d9ac4ec1df84f73c4528af239edb0b67d87e7" translate="yes" xml:space="preserve">
          <source>There is a way to completely hide any modifiable globals (they are all moved to heap), the compilation setting &lt;code&gt;-DPERL_GLOBAL_STRUCT_PRIVATE&lt;/code&gt; . It is not normally used, but can be used for testing, read more about it in &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;Background and PERL_IMPLICIT_CONTEXT in perlguts&lt;/a&gt;.</source>
          <target state="translated">编译设置 &lt;code&gt;-DPERL_GLOBAL_STRUCT_PRIVATE&lt;/code&gt; 有一种方法可以完全隐藏任何可修改的全局变量（它们都移到了堆中）。它通常不使用，但是可以用于测试，请在&lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;Background和perlguts中的PERL_IMPLICIT_CONTEXT中&lt;/a&gt;了解更多信息。</target>
        </trans-unit>
        <trans-unit id="887ba5df14249dda0cf87b4c4aa3777b9fca5f36" translate="yes" xml:space="preserve">
          <source>There is a way to tell perl to do complete cleanup: set the environment variable PERL_DESTRUCT_LEVEL to a non-zero value. The t/TEST wrapper does set this to 2, and this is what you need to do too, if you don't want to see the &quot;global leaks&quot;: For example, for running under valgrind</source>
          <target state="translated">有一种方法可以告诉perl进行完全清理:将环境变量PERL_DESTRUCT_LEVEL设置为非零值。t/TEST包装器确实将其设置为2,如果你不想看到 &quot;全局泄漏&quot;,也需要这样做。例如,在valgrind下运行</target>
        </trans-unit>
        <trans-unit id="691cdea86f4db4ba9a2ac59e7fc6b55f031421ad" translate="yes" xml:space="preserve">
          <source>There is absolutely no excuse for not documenting your extension. Documentation belongs in the .pm file. This file will be fed to pod2man, and the embedded documentation will be converted to the manpage format, then placed in the blib directory. It will be copied to Perl's manpage directory when the extension is installed.</source>
          <target state="translated">绝对没有借口不记录你的扩展名。文档属于.pm文件。这个文件将被送入 pod2man,嵌入的文档将被转换为 manpage 格式,然后放在 blib 目录中。当安装扩展时,它将被复制到Perl的manpage目录中。</target>
        </trans-unit>
        <trans-unit id="d8cca778f6ffeefe438e516146882fedcff922a7" translate="yes" xml:space="preserve">
          <source>There is also &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigrat;&lt;/code&gt; which gives you big rationals:</source>
          <target state="translated">也有 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigrat;&lt;/code&gt; 这给了你很大的理由：</target>
        </trans-unit>
        <trans-unit id="43bcf99a2a57a573a071e20e50556250aa32095b" translate="yes" xml:space="preserve">
          <source>There is also a function to add magic to an &lt;code&gt;HV&lt;/code&gt; :</source>
          <target state="translated">还有一个功能可以为 &lt;code&gt;HV&lt;/code&gt; 添加魔术：</target>
        </trans-unit>
        <trans-unit id="8f310316f81fc52692e5ac947e6e74f350603233" translate="yes" xml:space="preserve">
          <source>There is also a larger form of a char class structure used to represent POSIX char classes under &lt;code&gt;/l&lt;/code&gt; matching, called &lt;code&gt;regnode_charclass_posixl&lt;/code&gt; which has an additional 32-bit bitmap indicating which POSIX char classes have been included.</source>
          <target state="translated">还有一个较大形式的char类结构，用于表示 &lt;code&gt;/l&lt;/code&gt; 匹配下的POSIX char类，称为 &lt;code&gt;regnode_charclass_posixl&lt;/code&gt; ，它具有一个附加的32位位图，用于指示已包括哪些POSIX char类。</target>
        </trans-unit>
        <trans-unit id="8c1a33cdb5c1f767d6b5b045c29afd70795ca96e" translate="yes" xml:space="preserve">
          <source>There is also a toyedit Text widget based editor written in Perl that is distributed with the Tk module on CPAN. The ptkdb ( &lt;a href=&quot;http://ptkdb.sourceforge.net/&quot;&gt;http://ptkdb.sourceforge.net/&lt;/a&gt; ) is a Perl/Tk-based debugger that acts as a development environment of sorts. Perl Composer ( &lt;a href=&quot;http://perlcomposer.sourceforge.net/&quot;&gt;http://perlcomposer.sourceforge.net/&lt;/a&gt; ) is an IDE for Perl/Tk GUI creation.</source>
          <target state="translated">还有一个用Perl编写的基于toyedit文本小部件的编辑器，与CPAN上的Tk模块一起分发。ptkdb（&lt;a href=&quot;http://ptkdb.sourceforge.net/&quot;&gt;http://ptkdb.sourceforge.net/&lt;/a&gt;）是基于Perl / Tk的调试器，可作为各种开发环境。Perl Composer（&lt;a href=&quot;http://perlcomposer.sourceforge.net/&quot;&gt;http://perlcomposer.sourceforge.net/&lt;/a&gt;）是用于创建Perl / Tk GUI的IDE。</target>
        </trans-unit>
        <trans-unit id="ace8b22bc48d6e6e8b62fe08966c97467280b304" translate="yes" xml:space="preserve">
          <source>There is an edge case when using &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; from within a subroutine which was created in a different module than the one it is called from. It sounds complicated, but it really isn't. Here is an example which will not work correctly:</source>
          <target state="translated">在子例程中使用 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 时，存在一个极端情况，该子例程是在与调用它的模块不同的模块中创建的。听起来很复杂，但实际上并非如此。这是一个无法正常工作的示例：</target>
        </trans-unit>
        <trans-unit id="407ad0e2a6f54d3dcabda775887575e4b7a50908" translate="yes" xml:space="preserve">
          <source>There is another directory ($CPAN::Config-&amp;gt;{keep_source_where}) where the original distribution files are kept. This directory is not covered by the cache manager and must be controlled by the user. If you choose to have the same directory as build_dir and as keep_source_where directory, then your sources will be deleted with the same fifo mechanism.</source>
          <target state="translated">还有另一个目录（$ CPAN :: Config-&amp;gt; {keep_source_where}），用于保存原始分发文件。该目录不受高速缓存管理器的限制，必须由用户控制。如果选择与build_dir和keep_source_where目录具有相同的目录，则将使用相同的fifo机制删除源。</target>
        </trans-unit>
        <trans-unit id="58cdb83a1e784fb0e74fd64a5af55da9c7c710fa" translate="yes" xml:space="preserve">
          <source>There is another method which can be used, namely letting Perl do it for you automatically whenever it regains control after the callback has terminated. This is done by simply not using the</source>
          <target state="translated">还有一种方法可以使用,即在回调终止后,只要Perl重新获得控制权,就会让Perl自动为你做这件事。要做到这一点,只需不使用</target>
        </trans-unit>
        <trans-unit id="259d1525b7b40afbda3635dfb60885ec2065cd0c" translate="yes" xml:space="preserve">
          <source>There is another way to trade clarity for compactness: INPUT sections allow declaration of C variables which do not appear in the parameter list of a subroutine. Thus the above code for mutate() can be rewritten as</source>
          <target state="translated">还有一种方法可以用清晰换取紧凑。INPUT部分允许声明不出现在子程序参数列表中的C变量。因此,上面的mutate()代码可以重写为</target>
        </trans-unit>
        <trans-unit id="6993af1c1a90a2fde20c8f99658cf4ef71df4e8c" translate="yes" xml:space="preserve">
          <source>There is currently no way to turn off the guesswork that tries to format unmarked text appropriately, and sometimes it isn't wanted (particularly when using POD to document something other than Perl). Most of the work toward fixing this has now been done, however, and all that's still needed is a user interface.</source>
          <target state="translated">目前还没有办法关闭试图对未标记的文本进行适当格式化的猜测工作,而且有时不希望这样做(特别是在使用 POD 来记录 Perl 以外的其他内容时)。不过,现在已经完成了大部分的修复工作,还需要的是一个用户界面。</target>
        </trans-unit>
        <trans-unit id="923e1f4510dc236d985b28a823797fd535b1836b" translate="yes" xml:space="preserve">
          <source>There is no</source>
          <target state="translated">没有</target>
        </trans-unit>
        <trans-unit id="4ac6b5cad845dedcdb84c876c16dd65a46ac7fff" translate="yes" xml:space="preserve">
          <source>There is no 2GB limit on process size.</source>
          <target state="translated">进程大小没有2GB的限制。</target>
        </trans-unit>
        <trans-unit id="4389ed97cd408884e879872fd75e0815bd058c0d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;*.bs&lt;/code&gt; file supplied with the extension. Instead, there may be a &lt;code&gt;*_BS&lt;/code&gt; file which has code for the special cases, like posix for berkeley db on the NeXT.</source>
          <target state="translated">扩展名没有提供 &lt;code&gt;*.bs&lt;/code&gt; 文件。相反，可能有一个 &lt;code&gt;*_BS&lt;/code&gt; 文件，其中包含特殊情况的代码，例如NeXT上berkeley db的posix。</target>
        </trans-unit>
        <trans-unit id="e0b489252bb15e6f1ecbef798ed7f66f86847082" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; for that.</source>
          <target state="translated">没有 &lt;code&gt;systell&lt;/code&gt; 功能。 &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; 请使用sysseek（FH，0，1）。</target>
        </trans-unit>
        <trans-unit id="6ea7c815b6a5bfae1bac221a98896771b7bb3184" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; for that.</source>
          <target state="translated">没有 &lt;code&gt;systell&lt;/code&gt; 功能。 &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; 请使用sysseek（FH，0，1）。</target>
        </trans-unit>
        <trans-unit id="76a2f2ea0128a2c9f814d14705cbf22fee6bb330" translate="yes" xml:space="preserve">
          <source>There is no BNF, but you can paw your way through the yacc grammar in perly.y in the source distribution if you're particularly brave. The grammar relies on very smart tokenizing code, so be prepared to venture into toke.c as well.</source>
          <target state="translated">虽然没有 BNF,但如果你特别勇敢的话,你可以在源码发行版的 perly.y 中摸索 yacc 语法。这个语法依赖于非常聪明的标记化代码,所以也要准备好进入 toke.c。</target>
        </trans-unit>
        <trans-unit id="32ad1aee364e105dad5b41374df7e156cb6a43e2" translate="yes" xml:space="preserve">
          <source>There is no advantage to putting subroutines which will _always_ be called after the &lt;code&gt;__DATA__&lt;/code&gt; token.</source>
          <target state="translated">将子例程放在 &lt;code&gt;__DATA__&lt;/code&gt; 令牌之后总是被调用没有好处。</target>
        </trans-unit>
        <trans-unit id="e91dc6d303227194ff188b9dc751fb889211ca0d" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; function calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method for the package used. See also &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">没有内置的 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 功能。它只是由希望将名称导出到另一个模块的模块定义（或继承）的普通方法（子例程）。在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 函数调用的 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 所使用的包装方法。另请参见&lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;，&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;和&lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe76bcf1a7a27510fd944eef657a41eda4d72a44" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; function calls the &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method for the package used. See also &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">没有内置的 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 功能。它只是由希望将名称导出到另一个模块的模块定义（或继承）的普通方法（子例程）。在 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 函数调用的 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 所使用的包装方法。另请参见&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;，&lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;和&lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05fb5ccde6fe684391b3c4f8ff40b801e9c52e40" translate="yes" xml:space="preserve">
          <source>There is no builtin way to say &quot;float this to the right hand side of the page, however wide it is.&quot; You have to specify where it goes. The truly desperate can generate their own format on the fly, based on the current number of columns, and then eval() it:</source>
          <target state="translated">没有内置的方法可以说:&quot;无论它有多宽,都要把它漂浮到页面的右侧&quot;。你必须指定它的位置。真正绝望的人可以根据当前的列数,在飞行中生成自己的格式,然后eval()它。</target>
        </trans-unit>
        <trans-unit id="5ec86a2b5c6a22a41774d9be82dd0c618a3c5c45" translate="yes" xml:space="preserve">
          <source>There is no check to assert that the filehandle passed from Perl to C was created with the right &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; mode.</source>
          <target state="translated">没有检查可以断言从Perl传递到C的文件句柄是使用正确的 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 模式创建的。</target>
        </trans-unit>
        <trans-unit id="4297cc5a425f7dacf2e1ca88cce095827acd4bc7" translate="yes" xml:space="preserve">
          <source>There is no data immediately after the compressed data stream.</source>
          <target state="translated">在压缩数据流之后,没有紧接着的数据。</target>
        </trans-unit>
        <trans-unit id="784e961111d5a1435645faa2fd65cc0510bda63f" translate="yes" xml:space="preserve">
          <source>There is no decrypt function. This function isn't all that useful for cryptography (for that, look for</source>
          <target state="translated">没有解密功能。这个函数对于加密学来说并不是那么有用(关于这个,请查找</target>
        </trans-unit>
        <trans-unit id="7d50acdbf96ea291176f3a2d7e886b2944e1f2b9" translate="yes" xml:space="preserve">
          <source>There is no description given for most non-Perl defined properties (See &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt; for that).</source>
          <target state="translated">对于大多数非Perl定义的属性，没有给出描述（有关此&lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;信息&lt;/a&gt;，请参见http://www.unicode.org/reports/tr44/）。</target>
        </trans-unit>
        <trans-unit id="efbf1382c6e11055de15bc7597f5ea124690d870" translate="yes" xml:space="preserve">
          <source>There is no double interpolation in Perl, so the &lt;code&gt;$100&lt;/code&gt; is left as is.</source>
          <target state="translated">Perl中没有双重插值法，因此 &lt;code&gt;$100&lt;/code&gt; 保持不变。</target>
        </trans-unit>
        <trans-unit id="455b851bfe4dcf94993aa6ab9485d19207a20655" translate="yes" xml:space="preserve">
          <source>There is no easy way to provide this functionality in &lt;code&gt;Archive::Tar&lt;/code&gt; , because a tarball can contain many files, and each of which could be encoded in a different way.</source>
          <target state="translated">在 &lt;code&gt;Archive::Tar&lt;/code&gt; 没有简单的方法来提供此功能，因为tarball可以包含许多文件，并且每个文件都可以以不同的方式进行编码。</target>
        </trans-unit>
        <trans-unit id="27f49800696d7a52910d2aa32267a02c4e742caa" translate="yes" xml:space="preserve">
          <source>There is no equivalent operator to force an expression to be interpolated in list context because in practice, this is never needed. If you really wanted to do so, however, you could use the construction &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt; , but usually a simple &lt;code&gt;(some expression)&lt;/code&gt; suffices.</source>
          <target state="translated">没有等效的运算符可以强制在列表上下文中插入表达式，因为实际上不需要。但是，如果您确实想这样做，可以使用结构 &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt; ，但通常只需一个简单的 &lt;code&gt;(some expression)&lt;/code&gt; 就足够了。</target>
        </trans-unit>
        <trans-unit id="6da385daea49ac6d957f9692c325e916978ed205" translate="yes" xml:space="preserve">
          <source>There is no equivalent to &lt;code&gt;fgets&lt;/code&gt; ; one should use &lt;code&gt;sv_gets&lt;/code&gt; instead:</source>
          <target state="translated">没有 &lt;code&gt;fgets&lt;/code&gt; ; 应该使用 &lt;code&gt;sv_gets&lt;/code&gt; 代替：</target>
        </trans-unit>
        <trans-unit id="56b2b22bb272d9529f5a7b2eeb648640b188c1f1" translate="yes" xml:space="preserve">
          <source>There is no firewall</source>
          <target state="translated">没有防火墙</target>
        </trans-unit>
        <trans-unit id="121835ac892ea37b942952f42c3ffe4014099c6d" translate="yes" xml:space="preserve">
          <source>There is no general solution to all of this. It is a mess.</source>
          <target state="translated">所有这些都没有一般的解决办法。这是一个混乱的问题。</target>
        </trans-unit>
        <trans-unit id="87f0999d25c4eb3604c738b2e0116726668320dd" translate="yes" xml:space="preserve">
          <source>There is no general solution to all of this. It's just a mess.</source>
          <target state="translated">这一切都没有一般的解决办法。只是一团糟。</target>
        </trans-unit>
        <trans-unit id="e2b8fcbb171cbccbd111cd2bd311ab6e6fcd1a58" translate="yes" xml:space="preserve">
          <source>There is no low precedence operator for defined-OR.</source>
          <target state="translated">定义-OR没有低优先运算符。</target>
        </trans-unit>
        <trans-unit id="a8da251185c2a49373fb6cf76b3c29c18692d780" translate="yes" xml:space="preserve">
          <source>There is no need to inherit from the &lt;b&gt;SelfLoader&lt;/b&gt;.</source>
          <target state="translated">无需从&lt;b&gt;SelfLoader&lt;/b&gt;继承。</target>
        </trans-unit>
        <trans-unit id="0d3cd63858e09b2c6b6ec38df40d5828e10651d9" translate="yes" xml:space="preserve">
          <source>There is no one DBM module available on all platforms. &lt;code&gt;SDBM_File&lt;/code&gt; and the others are generally available on all Unix and DOSish ports, but not in MacPerl, where only &lt;code&gt;NDBM_File&lt;/code&gt; and &lt;code&gt;DB_File&lt;/code&gt; are available.</source>
          <target state="translated">在所有平台上都没有一个DBM模块可用。 &lt;code&gt;SDBM_File&lt;/code&gt; 和其他文件通常在所有Unix和DOSish端口上可用，但在MacPerl中则不可用，在MacPerl中只有 &lt;code&gt;NDBM_File&lt;/code&gt; 和 &lt;code&gt;DB_File&lt;/code&gt; 可用。</target>
        </trans-unit>
        <trans-unit id="fb47afbc2311aee90586d3371f78c62b2ed90edb" translate="yes" xml:space="preserve">
          <source>There is no quantifier &lt;code&gt;{,n}&lt;/code&gt; . That's interpreted as a literal string.</source>
          <target state="translated">没有量词 &lt;code&gt;{,n}&lt;/code&gt; 。那被解释为文字字符串。</target>
        </trans-unit>
        <trans-unit id="378d1a5bc456220dab02d99326a34c6e9f3d48c2" translate="yes" xml:space="preserve">
          <source>There is no reason you should not use Perl as a language to glue Unix tools together, or to prototype a Macintosh application, or to manage the Windows registry. If it makes no sense to aim for portability for one reason or another in a given program, then don't bother.</source>
          <target state="translated">您没有理由不使用 Perl 作为一种语言将 Unix 工具粘合在一起,或者将 Macintosh 应用程序原型化,或者管理 Windows 注册表。如果出于这样或那样的原因,在一个特定的程序中追求可移植性是没有意义的,那就别费劲了。</target>
        </trans-unit>
        <trans-unit id="860dd139f43df25bd42c1af5b8706f2806229649" translate="yes" xml:space="preserve">
          <source>There is no requirement to convert anything.</source>
          <target state="translated">没有要求转换任何东西。</target>
        </trans-unit>
        <trans-unit id="5d190eab008c4161478c644351172b878f4f965a" translate="yes" xml:space="preserve">
          <source>There is no set_layers(), nor does get_layers() return a tied array mirroring the stack, or anything fancy like that. This is not accidental or unintentional. The PerlIO layer stack is a bit more complicated than just a stack (see for example the behaviour of &lt;code&gt;:raw&lt;/code&gt; ). You are supposed to use open() and binmode() to manipulate the stack.</source>
          <target state="translated">没有set_layers（），也没有get_layers（）返回镜像堆栈的绑定数组，或者类似的东西。这不是偶然的或无意的。PerlIO层堆栈比仅堆栈要复杂一些（例如，参见 &lt;code&gt;:raw&lt;/code&gt; 的行为）。您应该使用open（）和binmode（）来操纵堆栈。</target>
        </trans-unit>
        <trans-unit id="fcb140242be9c5687c6a498b3df2879f2625b5b6" translate="yes" xml:space="preserve">
          <source>There is no shell to process metacharacters, and the native standard is to pass a command line terminated by &quot;\n&quot; &quot;\r&quot; or &quot;\0&quot; to the spawned program. Redirection such as &lt;code&gt;&amp;gt; foo&lt;/code&gt; is performed (if at all) by the run time library of the spawned program. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">没有外壳程序可以处理元字符，本机标准是将以&amp;ldquo; \ n&amp;rdquo;，&amp;ldquo; \ r&amp;rdquo;或&amp;ldquo; \ 0&amp;rdquo;结尾的命令行传递给生成的程序。诸如 &lt;code&gt;&amp;gt; foo&lt;/code&gt; 重定向（如果有的话）由产生的程序的运行时库执行。 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="deba5b88e82775e19650d3712106c375f59f7e30" translate="yes" xml:space="preserve">
          <source>There is no significant speed gain between compile time and run time class creation, there is just a new, more standard order of events.</source>
          <target state="translated">在编译时和运行时创建类之间并没有明显的速度提升,有的只是一个新的、更标准的事件顺序。</target>
        </trans-unit>
        <trans-unit id="6b7801d1cfdd5c48abee3f679e368ab10b3ad8dc" translate="yes" xml:space="preserve">
          <source>There is no simple answer to this question. Perl frameworks can run everything from basic file servers and small scale intranets to massive multinational multilingual websites that are the core to international businesses.</source>
          <target state="translated">这个问题没有简单的答案。Perl框架可以运行从基本的文件服务器和小规模的内部网到大规模的多国多语言网站,这些都是国际企业的核心。</target>
        </trans-unit>
        <trans-unit id="557d02393de130217c50453e6a017ae2fadcbc8e" translate="yes" xml:space="preserve">
          <source>There is no simple solution to this because of printf()'s limited intelligence, but for many types the right format is available as with either 'f' or '_f' suffix, for example:</source>
          <target state="translated">由于printf()的智能有限,没有简单的解决方案,但对于许多类型来说,正确的格式是可用的,例如,后缀为'f'或'_f'。</target>
        </trans-unit>
        <trans-unit id="8ceb0317aba48e3a3b6cabda91010f77ae7a54b9" translate="yes" xml:space="preserve">
          <source>There is no simple way to access WPS objects. The only way I know is via &lt;code&gt;OS2::REXX&lt;/code&gt; and &lt;code&gt;SOM&lt;/code&gt; extensions (see &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/SOM&quot;&gt;SOM&lt;/a&gt;). However, we do not have access to convenience methods of Object-REXX. (Is it possible at all? I know of no Object-REXX API.) The &lt;code&gt;SOM&lt;/code&gt; extension (currently in alpha-text) may eventually remove this shortcoming; however, due to the fact that DII is not supported by the &lt;code&gt;SOM&lt;/code&gt; module, using &lt;code&gt;SOM&lt;/code&gt; is not as convenient as one would like it.</source>
          <target state="translated">没有简单的方法来访问WPS对象。我知道的唯一方法是通过 &lt;code&gt;OS2::REXX&lt;/code&gt; 和 &lt;code&gt;SOM&lt;/code&gt; 扩展（请参阅&lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2 :: REXX&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/SOM&quot;&gt;SOM&lt;/a&gt;）。但是，我们无法使用Object-REXX的便捷方法。（有可能吗？我不知道Object-REXX API。） &lt;code&gt;SOM&lt;/code&gt; 扩展名（当前为字母文本）可能最终消除了这一缺点。但是，由于 &lt;code&gt;SOM&lt;/code&gt; 模块不支持DII ，因此使用 &lt;code&gt;SOM&lt;/code&gt; 并不像人们期望的那样方便。</target>
        </trans-unit>
        <trans-unit id="06843bf4e2da3a9df3bd916b78c90fe1d32c0462" translate="yes" xml:space="preserve">
          <source>There is no special class syntax in Perl, but a package may act as a class if it provides subroutines to act as methods. Such a package may also derive some of its methods from another class (package) by listing the other package name(s) in its global @ISA array (which must be a package global, not a lexical).</source>
          <target state="translated">在Perl中没有特殊的类语法,但是如果一个包提供了作为方法的子程序,那么它可以作为一个类来使用。这样的包也可以通过在它的全局@ISA数组中列出其他包名(必须是包的全局名,而不是词法名),从另一个类(包)中派生出一些方法。</target>
        </trans-unit>
        <trans-unit id="f83d3f75f9b7673dc85f27f3287a09a764999d4c" translate="yes" xml:space="preserve">
          <source>There is no specific mailing list for Perl on VOS. You can contact the Stratus Technologies Customer Assistance Center (CAC) for your region, or you can use the contact information located in the distribution files on the Stratus Anonymous FTP site.</source>
          <target state="translated">VOS上没有专门针对Perl的邮件列表,您可以联系您所在地区的Stratus Technologies客户支持中心(CAC),或者使用Stratus匿名FTP站点上的分发文件中的联系信息。您可以联系您所在地区的Stratus Technologies客户援助中心(CAC),或者使用Stratus匿名FTP站点上的分发文件中的联系信息。</target>
        </trans-unit>
        <trans-unit id="100c2da519836111bd839e12cb2fd3dec223d870" translate="yes" xml:space="preserve">
          <source>There is no specification of the formatter after the &lt;code&gt;=for&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;=for&lt;/code&gt; 命令后没有格式化程序的规范。</target>
        </trans-unit>
        <trans-unit id="670b965fe2aed5c0a5a49c42acbad90f9fc925e9" translate="yes" xml:space="preserve">
          <source>There is no such thing as a network representation for reals, so if you want to send your real numbers across computer boundaries, you'd better stick to text representation, possibly using the hexadecimal float format (avoiding the decimal conversion loss), unless you're absolutely sure what's on the other end of the line. For the even more adventuresome, you can use the byte-order modifiers from the previous section also on floating point codes.</source>
          <target state="translated">对于实数来说,没有网络表示法这种东西,所以如果你想跨计算机边界发送你的实数,你最好坚持使用文本表示法,可能使用十六进制浮点数格式(避免十进制转换损失),除非你绝对确定线的另一端是什么。对于更冒险的人,你可以使用上一节也是关于浮点码的字节序修改器。</target>
        </trans-unit>
        <trans-unit id="485f9819a36f9757672adb9a54833a7d985d4ad2" translate="yes" xml:space="preserve">
          <source>There is no support at present for tied @ISA. There is a potential conflict between magic entries needed to notice setting of @ISA, and those needed to implement 'tie'.</source>
          <target state="translated">目前还不支持绑定的@ISA。注意到@ISA的设置所需的魔法条目和实现 &quot;绑定 &quot;所需的魔法条目之间存在潜在的冲突。</target>
        </trans-unit>
        <trans-unit id="f0d4e44dc9af068a1f923f5eebfb3439b41ed99d" translate="yes" xml:space="preserve">
          <source>There is no support for dynamically linked libraries in QNX4.</source>
          <target state="translated">QNX4 不支持动态链接库。</target>
        </trans-unit>
        <trans-unit id="73a30aae9994d5aba957137545368eea0ce0f5eb" translate="yes" xml:space="preserve">
          <source>There is no syseof() function, which is ok, since eof() doesn't work well on device files (like ttys) anyway. Use sysread() and check for a return value for 0 to decide whether you're done.</source>
          <target state="translated">没有syseof()函数,这是好的,因为eof()对设备文件(如ttys)并不好用。使用sysread()并检查返回值为0来决定是否完成。</target>
        </trans-unit>
        <trans-unit id="8fc13de7d6614c5dd033dd321c9bbd82b325da63" translate="yes" xml:space="preserve">
          <source>There is no technical reason why a Berkeley DB database cannot be shared by both a Perl and a C application.</source>
          <target state="translated">没有技术上的原因,为什么Berkeley DB数据库不能由Perl和C应用程序共享。</target>
        </trans-unit>
        <trans-unit id="79f7328788708da5a0cdbfe8c102e73defe278fc" translate="yes" xml:space="preserve">
          <source>There is no way to reliably detect the encoding automatically, so if people keep sending you data without charset indication, you may have to educate them.</source>
          <target state="translated">没有办法可靠地自动检测编码,所以如果人们一直向你发送没有标明字符集的数据,你可能不得不教育他们。</target>
        </trans-unit>
        <trans-unit id="9d4ba678fc087cfe3ed3657d1daba5422cdd5616" translate="yes" xml:space="preserve">
          <source>There is nothing special about Memoize::Expire. It is just an example. If you don't like the policy that it implements, you are free to write your own expiration policy module that implements whatever policy you desire. Here is how to do that. Let us suppose that your module will be named MyExpirePolicy.</source>
          <target state="translated">Memoize::Expire并没有什么特别之处。它只是一个例子。如果你不喜欢它所实现的策略,你可以自由地编写自己的过期策略模块,实现任何你想要的策略。下面是如何做到这一点。让我们假设你的模块将被命名为MyExpirePolicy。</target>
        </trans-unit>
        <trans-unit id="6fcd6f426861d4a9d172b0ea1e309235434fe63e" translate="yes" xml:space="preserve">
          <source>There is now a &lt;code&gt;bsstr()&lt;/code&gt; method to get the string in scientific notation aka &lt;code&gt;1e+2&lt;/code&gt; instead of &lt;code&gt;100&lt;/code&gt; . Be advised that overloaded 'eq' always uses bstr() for comparison, but Perl will represent some numbers as 100 and others as 1e+308. If in doubt, convert both arguments to Math::BigInt before comparing them as strings:</source>
          <target state="translated">现在有一个 &lt;code&gt;bsstr()&lt;/code&gt; 方法以科学记数法（即 &lt;code&gt;1e+2&lt;/code&gt; 而不是 &lt;code&gt;100&lt;/code&gt; ）获取字符串。请注意，重载的&amp;ldquo; eq&amp;rdquo;始终使用bstr（）进行比较，但是Perl会将某些数字表示为100，而其他数字表示为1e + 308。如有疑问，请将两个参数都转换为Math :: BigInt，然后将它们作为字符串进行比较：</target>
        </trans-unit>
        <trans-unit id="22f759aa48f981bff2eecdd8034d0137dd1c154a" translate="yes" xml:space="preserve">
          <source>There is of course lots more to find out about, this has just scratched the surface. The best way to learn more is to use perldoc to find out more about the language, to read the on-line help (&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; is probably the next place to go), and of course, experiment.</source>
          <target state="translated">当然，还有很多可以发现的东西，这只是表面。了解更多信息的最佳方法是使用perldoc查找有关该语言的更多信息，阅读在线帮助（&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;可能是下一个选择），当然还有实验。</target>
        </trans-unit>
        <trans-unit id="2f1fdaa6644f76210c716aac51df03a67575812a" translate="yes" xml:space="preserve">
          <source>There is often a matter of opinion and taste, and there isn't any one answer that fits everyone. In general, you want to use either the current stable release, or the stable release immediately prior to that one. Currently, those are perl5.18.x and perl5.16.x, respectively.</source>
          <target state="translated">往往是见仁见智的问题,没有任何一个答案适合所有人。一般来说,你希望使用当前的稳定版本,或者紧接着之前的稳定版本。目前,这些版本分别是perl5.18.x和perl5.16.x。</target>
        </trans-unit>
        <trans-unit id="5e0ec9ff71273582227d757a4501aa81fcc373f2" translate="yes" xml:space="preserve">
          <source>There is one caveat with INSTALL_BASE, though, since it acts differently from the PREFIX and LIB settings that older versions of &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; advocated. INSTALL_BASE does not support installing modules for multiple versions of Perl or different architectures under the same directory. You should consider whether you really want that and, if you do, use the older PREFIX and LIB settings. See the &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Makemaker&quot;&gt;ExtUtils::Makemaker&lt;/a&gt; documentation for more details.</source>
          <target state="translated">但是，INSTALL_BASE有一个警告，因为它的作用与&lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMaker的&lt;/a&gt;较早版本主张的PREFIX和LIB设置不同。 INSTALL_BASE不支持在同一目录下为Perl的多个版本或不同体系结构安装模块。您应该考虑是否确实需要，如果需要，请使用旧的PREFIX和LIB设置。有关更多详细信息，请参见&lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Makemaker&quot;&gt;ExtUtils :: Makemaker&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="97b4745ddf35dec712ea27023babefb7e0f47466" translate="yes" xml:space="preserve">
          <source>There is one exception to all this. &lt;code&gt;\p{All}&lt;/code&gt; looks like a Unicode property, but it is a Perl extension that is defined to be true for all possible code points, Unicode or not, so no warning is ever generated when matching this against a non-Unicode code point. (Prior to v5.20, it was an exact synonym for &lt;code&gt;\p{Any}&lt;/code&gt; , matching code points &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;0x10FFFF&lt;/code&gt; .)</source>
          <target state="translated">所有这些都有一个例外。 &lt;code&gt;\p{All}&lt;/code&gt; 看起来像一个Unicode属性，但这是一个Perl扩展，定义为对所有可能的代码点（无论是否为Unicode）都为true，因此，将其与非Unicode代码点进行匹配时不会生成任何警告。（在v5.20之前，它是 &lt;code&gt;\p{Any}&lt;/code&gt; 的确切同义词，匹配代码点 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;0x10FFFF&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="74416e05e81083925dbb5ceee8b9f9eabc0d1420" translate="yes" xml:space="preserve">
          <source>There is one exception to this rule:</source>
          <target state="translated">这个规则有一个例外。</target>
        </trans-unit>
        <trans-unit id="aa93104b268b1c94a90858506e09be1c5b4335fe" translate="yes" xml:space="preserve">
          <source>There is one exception, and that is base 2 with negative $x:</source>
          <target state="translated">有一个例外,那就是基数2为负数$x。</target>
        </trans-unit>
        <trans-unit id="cfa0a4472a2d7ed2b714a912f015cd1d6e2a650e" translate="yes" xml:space="preserve">
          <source>There is one exception. If you use an alphanumeric character as the delimiter of your pattern (which you probably shouldn't do for readability reasons), you have to escape the delimiter if you want to match it. Perl won't warn then. See also &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;Gory details of parsing quoted constructs in perlop&lt;/a&gt;.</source>
          <target state="translated">有一个例外。如果使用字母数字字符作为模式的定界符（出于可读性原因，您可能不应该这样做），则要匹配定界符，必须对其进行转义。Perl不会发出警告。另请参见&lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;在perlop中解析引用的构造的Gory详细信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6afd3e4f300e1185505b80a57213e90e8f05b7f4" translate="yes" xml:space="preserve">
          <source>There is one minor difference: if variables are declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; in the initialization section of the &lt;code&gt;for&lt;/code&gt; , the lexical scope of those variables is exactly the &lt;code&gt;for&lt;/code&gt; loop (the body of the loop and the control sections).</source>
          <target state="translated">有一个微小的区别：如果在 &lt;code&gt;for&lt;/code&gt; 的初始化部分中用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明了变量，则这些变量的词法作用域恰好是 &lt;code&gt;for&lt;/code&gt; 循环（循环的主体和控制部分）。</target>
        </trans-unit>
        <trans-unit id="83ea2627da96768f4457b4c193dca3613fbaa7aa" translate="yes" xml:space="preserve">
          <source>There is one small difference between &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; : the former will not affect assignments to variables and the return value of some functions. &lt;code&gt;bigint&lt;/code&gt; truncates these results to integer too:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; 之间只有一个小区别：前者不会影响变量的赋值和某些函数的返回值。 &lt;code&gt;bigint&lt;/code&gt; 也将这些结果截断为整数：</target>
        </trans-unit>
        <trans-unit id="b84dd6a42f4605e651baa6c6eefa2a08f75e64c2" translate="yes" xml:space="preserve">
          <source>There is one subtle difference between the following statements:</source>
          <target state="translated">以下说法有一个微妙的区别。</target>
        </trans-unit>
        <trans-unit id="577b4723acc7dc122f5a6c392fd693ead8ac6f77" translate="yes" xml:space="preserve">
          <source>There is one unary operator:</source>
          <target state="translated">有一个单利运算符。</target>
        </trans-unit>
        <trans-unit id="d67d211508568f3ee020a0acfadaaf645e5efa24" translate="yes" xml:space="preserve">
          <source>There is only a single &lt;code&gt;%^H&lt;/code&gt; , but arbitrarily many modules that want to use its scoping semantics. To avoid stepping on each other's toes, they need to be sure to use different keys in the hash. It is therefore conventional for a module to use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. After this module-identifying prefix, the rest of the key is entirely up to the module: it may include any characters whatsoever. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; and &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt; . Modules following this convention all play nicely with each other.</source>
          <target state="translated">只有一个 &lt;code&gt;%^H&lt;/code&gt; ，但是任意多个模块想要使用其作用域语义。为了避免踩到对方的脚趾，他们需要确保在哈希中使用不同的键。因此，常规上，模块仅使用以模块名称（其主软件包的名称）和&amp;ldquo; /&amp;rdquo;字符开头的键。在此模块标识前缀之后，密钥的其余部分完全取决于模块：它可以包含任何字符。例如，模块 &lt;code&gt;Foo::Bar&lt;/code&gt; 应该使用诸如 &lt;code&gt;Foo::Bar/baz&lt;/code&gt; 和 &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt; 。遵循此约定的模块可以很好地相互配合。</target>
        </trans-unit>
        <trans-unit id="22c0c34478d863fe370e8b15b9734da447a63b38" translate="yes" xml:space="preserve">
          <source>There is outline support for co-existence of PerlIO with stdio. Obviously if PerlIO is implemented in terms of stdio there is no problem. However in other cases then mechanisms must exist to create a FILE * which can be passed to library code which is going to use stdio calls.</source>
          <target state="translated">大纲上支持PerlIO与stdio共存。显然,如果PerlIO是用stdio实现的,就没有问题。然而在其他情况下,就必须有机制来创建一个FILE *,它可以传递给要使用stdio调用的库代码。</target>
        </trans-unit>
        <trans-unit id="a0392addc7a656cb8a34b007fdd104d3df93294e" translate="yes" xml:space="preserve">
          <source>There is some debate as to whether to say &quot;regexp&quot; or &quot;regex&quot;. In this document we will use the term &quot;regex&quot; unless there is a special reason not to, in which case we will explain why.</source>
          <target state="translated">关于 &quot;regexp &quot;还是 &quot;regex&quot;,有一些争论。在本文件中,我们将使用 &quot;regex &quot;一词,除非有特殊原因,在这种情况下,我们将解释原因。</target>
        </trans-unit>
        <trans-unit id="6f838e3edb2d3e6da973960ec694558ee6ce5470" translate="yes" xml:space="preserve">
          <source>There is some problem with the way &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;f&lt;/code&gt; works under threaded Perl, perhaps because of the lexical scoping of &lt;code&gt;@_&lt;/code&gt; . This is a bug in Perl, and until it is resolved, memoized functions will see a slightly different &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; and will perform a little more slowly on threaded perls than unthreaded perls.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;f&lt;/code&gt; 在线程Perl下工作的方式存在一些问题，可能是由于 &lt;code&gt;@_&lt;/code&gt; 的词法作用域。这是Perl中的一个错误，在解决之前，已记忆的函数将看到略有不同的 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; ,并且在线程Perl上的执行要比非线程Perl慢一些。</target>
        </trans-unit>
        <trans-unit id="25c4c8715915dd906a17ab857892228134a49607" translate="yes" xml:space="preserve">
          <source>There is some whitespace on a seemingly empty line. POD is very sensitive to such things, so this is flagged. &lt;b&gt;vi&lt;/b&gt; users switch on the &lt;b&gt;list&lt;/b&gt; option to avoid this problem.</source>
          <target state="translated">在看似空的行上有一些空格。POD对此类事物非常敏感，因此将其标记出来。&lt;b&gt;vi&lt;/b&gt;用户打开&lt;b&gt;list&lt;/b&gt;选项可以避免此问题。</target>
        </trans-unit>
        <trans-unit id="c71483f882bf4da31c0c8d8f1949a4bc637c87a4" translate="yes" xml:space="preserve">
          <source>There is still a big part of the API not supported by</source>
          <target state="translated">还有很大一部分的API不支持。</target>
        </trans-unit>
        <trans-unit id="808a7cbe8640b29d30d1f97308938be9ff6d1171" translate="yes" xml:space="preserve">
          <source>There is still a small theoretical chance that a signal will interrupt the system-level &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; operation before completion. There is also a possibility that some STDIO implementations may call multiple system level &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;s even if the buffer was empty to start. There may be some systems where this probability is reduced to zero, and this is not a concern when using &lt;code&gt;:perlio&lt;/code&gt; instead of your system's STDIO.</source>
          <target state="translated">从理论上讲，信号仍然有很小的机会会在完成之前中断系统级的 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 操作。即使缓冲区为空，某些STDIO实现也可能会调用多个系统级 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 。在某些系统中，该可能性降低为零，并且使用 &lt;code&gt;:perlio&lt;/code&gt; 而不是系统的STDIO 时无需担心。</target>
        </trans-unit>
        <trans-unit id="96312d6625c318df54bef83c86f5b35fb95ca06e" translate="yes" xml:space="preserve">
          <source>There is the &quot;next regnode&quot; from a given regnode, a value which is rarely useful except that sometimes it matches up in terms of value with one of the others, and that sometimes the code assumes this to always be so.</source>
          <target state="translated">有一个给定的regnode的 &quot;下一个regnode&quot;,这个值很少有用,只是有时它与其他的一个regnode在值上吻合,有时代码会认为总是如此。</target>
        </trans-unit>
        <trans-unit id="7b46535959966668b5c0eb95890256b8fd5dc3c4" translate="yes" xml:space="preserve">
          <source>There is the &quot;next regop&quot; from a given regop/regnode. This is the regop physically located after the current one, as determined by the size of the current regop. This is often useful, such as when dumping the structure we use this order to traverse. Sometimes the code assumes that the &quot;next regnode&quot; is the same as the &quot;next regop&quot;, or in other words assumes that the sizeof a given regop type is always going to be one regnode large.</source>
          <target state="translated">这是一个给定的regop/regnode的 &quot;下一个regop&quot;。这是由当前regop的大小决定的,物理上位于当前regop之后的regop。这通常是有用的,例如当转储结构时,我们使用这个顺序来遍历。有时,代码会假设 &quot;下一个regnode &quot;和 &quot;下一个regop &quot;是一样的,或者换句话说,假设给定的regop类型的大小总是要大一个regnode。</target>
        </trans-unit>
        <trans-unit id="e671500d0c7786e7f8681f40410ba60c12dae4fc" translate="yes" xml:space="preserve">
          <source>There is the &quot;regnext&quot; from a given regop. This is the regop which is reached by jumping forward by the value of &lt;code&gt;NEXT_OFF()&lt;/code&gt; , or in a few cases for longer jumps by the &lt;code&gt;arg1&lt;/code&gt; field of the &lt;code&gt;regnode_1&lt;/code&gt; structure. The subroutine &lt;code&gt;regnext()&lt;/code&gt; handles this transparently. This is the logical successor of the node, which in some cases, like that of the &lt;code&gt;BRANCH&lt;/code&gt; regop, has special meaning.</source>
          <target state="translated">有来自给定regop的&amp;ldquo; regnext&amp;rdquo;。这是regop，可以通过向前跳转 &lt;code&gt;NEXT_OFF()&lt;/code&gt; 的值来达到，或者在某些情况下可以通过 &lt;code&gt;regnode_1&lt;/code&gt; 结构的 &lt;code&gt;arg1&lt;/code&gt; 字段进行更长的跳转。子例程 &lt;code&gt;regnext()&lt;/code&gt; 透明地进行处理。这是节点的逻辑后继者，在某些情况下，像 &lt;code&gt;BRANCH&lt;/code&gt; regop一样，具有特殊的含义。</target>
        </trans-unit>
        <trans-unit id="d7e93b59e1cec82fb52bcc021241febda0271114" translate="yes" xml:space="preserve">
          <source>There is unfortunately no way to know whether the current emulator supports more than eight colors, which makes the choice of colors difficult. The most conservative choice is to use only the regular colors, which are at least displayed on all emulators. However, they will appear dark in sixteen-color terminal emulators, including most common emulators in UNIX X environments. If you know the display is one of those emulators, you may wish to use the bright variants instead. Even better, offer the user a way to configure the colors for a given application to fit their terminal emulator.</source>
          <target state="translated">遗憾的是,目前的仿真器是否支持八种以上的颜色,无从得知,这给颜色的选择带来了困难。最保守的选择是只使用常规颜色,至少在所有仿真器上都能显示。但是,在十六色终端仿真器中,包括UNIX X环境中最常见的仿真器中,它们会显得很暗。如果你知道显示器是这些仿真器中的一种,你可能希望使用明亮的变体来代替。更好的做法是,为用户提供一种方法来配置给定应用程序的颜色,以适应他们的终端仿真器。</target>
        </trans-unit>
        <trans-unit id="695fd95569c58aad4ef775aef68eb765f2b01d11" translate="yes" xml:space="preserve">
          <source>There is whitespace at the beginning or the end of the contents of L&amp;lt;...&amp;gt;.</source>
          <target state="translated">L &amp;lt;...&amp;gt;的内容的开头或结尾处都有空格。</target>
        </trans-unit>
        <trans-unit id="95a3b67169b42d8576a9c6b1e3142c83d233d818" translate="yes" xml:space="preserve">
          <source>There is/was a minor twist which makes this scheme fragile: what to do with DLLs loaded from</source>
          <target state="translated">有一个小的转折让这个方案变得很脆弱:如何处理从</target>
        </trans-unit>
        <trans-unit id="3224e59e3b76dce8e510a893a97e615a7718acdb" translate="yes" xml:space="preserve">
          <source>There may be a few system-dependent issues of concern to EBCDIC Perl programmers.</source>
          <target state="translated">对于EBCDIC Perl程序员来说,可能有一些系统依赖性问题值得关注。</target>
        </trans-unit>
        <trans-unit id="74512965a00a9ef27998a0f76a590e7ca4e44a5a" translate="yes" xml:space="preserve">
          <source>There may be a slight performance decrease in the filetest operations when the filetest pragma is in effect, because checking bits is very cheap.</source>
          <target state="translated">当filetest pragma生效时,filetest操作可能会有轻微的性能下降,因为检查位非常便宜。</target>
        </trans-unit>
        <trans-unit id="e5aefd712f7c17e18d56a8092421c803470327d8" translate="yes" xml:space="preserve">
          <source>There may be several other functions that have undefined behavior so this list shouldn't be considered complete.</source>
          <target state="translated">可能还有其他一些函数具有未定义的行为,所以这个列表不应该被认为是完整的。</target>
        </trans-unit>
        <trans-unit id="8f2ee1e9e100e424daf008c17d87249cb596b7da" translate="yes" xml:space="preserve">
          <source>There might be padding bytes between the fields to align the fields - the bytes can be anything</source>
          <target state="translated">字段之间可能会有填充字节来对齐字段--这些字节可以是任何东西。</target>
        </trans-unit>
        <trans-unit id="8da2d0d0ae5db5c30555083a00bfa8e94e394bba" translate="yes" xml:space="preserve">
          <source>There seem to be various problems in this long double implementation. If Configure detects this brokenness, it will disable the long double support. This can be overriden with explicit &lt;code&gt;-Duselongdouble&lt;/code&gt; (or &lt;code&gt;-Dusemorebits&lt;/code&gt; , which enables both long doubles and 64 bit integers). If you decide to enable long doubles, for most of the broken things Perl has implemented workarounds, but the handling of the special values infinity and NaN remains badly broken: for example infinity plus zero results in NaN.</source>
          <target state="translated">这种长的双重实现似乎存在各种问题。如果Configure检测到此损坏，它将禁用长期双重支持。可以使用显式的 &lt;code&gt;-Duselongdouble&lt;/code&gt; （或 &lt;code&gt;-Dusemorebits&lt;/code&gt; ，它同时启用长双精度和64位整数）来覆盖它。如果您决定启用长双精度，那么对于大多数损坏的事情，Perl都实施了变通方法，但是特殊值infinity和NaN的处理仍然严重中断：例如，NaN中的infinity加零结果。</target>
        </trans-unit>
        <trans-unit id="0335b463034771ce67a8d72b65b51f2c22f06a51" translate="yes" xml:space="preserve">
          <source>There seems to be a broken system header file in HP-UX 11.00 that breaks perl building in 32bit mode with GNU gcc-4.x causing this error. The same file for HP-UX 11.11 (even though the file is older) does not show this failure, and has the correct definition, so the best fix is to patch the header to match:</source>
          <target state="translated">在HP-UX 11.00中似乎有一个系统头文件被破坏了,它破坏了在32位模式下用GNU gcc-4.x进行perl构建,导致了这个错误。HP-UX 11.11的相同文件(尽管该文件较旧)没有显示这个故障,并且有正确的定义,所以最好的修复方法是将头文件修补为匹配。</target>
        </trans-unit>
        <trans-unit id="06ff19d7cd54ce39cc7fc4ec7d77ca64eb5bbd76" translate="yes" xml:space="preserve">
          <source>There should be a second &lt;code&gt;&quot;:&quot;&lt;/code&gt; , like this:</source>
          <target state="translated">应该有第二个 &lt;code&gt;&quot;:&quot;&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="f721ea1c84751a36c3521319fb047aa7a307e4e5" translate="yes" xml:space="preserve">
          <source>There should be an operator before the &lt;code&gt;&quot;(&quot;&lt;/code&gt; , as there's no indication as to how the digits are to be combined with the characters in the Lao and Thai scripts.</source>
          <target state="translated">在 &lt;code&gt;&quot;(&quot;&lt;/code&gt; 之前应该有一个运算符，因为没有指示如何将数字与老挝和泰语脚本中的字符组合在一起。</target>
        </trans-unit>
        <trans-unit id="b4b586b7cb9ac2ab75263a6f83deec69bb4720e3" translate="yes" xml:space="preserve">
          <source>There should be no test failures.</source>
          <target state="translated">不应出现测试失败的情况。</target>
        </trans-unit>
        <trans-unit id="6e7e045068e59967e564a49c6f93bb7b24be5931" translate="yes" xml:space="preserve">
          <source>There we're using the %USER_VARS hash instead of symbolic references. Sometimes this comes up in reading strings from the user with variable references and wanting to expand them to the values of your perl program's variables. This is also a bad idea because it conflates the program-addressable namespace and the user-addressable one. Instead of reading a string and expanding it to the actual contents of your program's own variables:</source>
          <target state="translated">在这里我们使用%USER_VARS哈希来代替符号引用。有时会出现这样的情况,从用户那里读取变量引用的字符串,并希望将它们扩展到你的perl程序的变量值。这也是一个坏主意,因为它混淆了程序可寻址的命名空间和用户可寻址的命名空间。而不是读取一个字符串并将其扩展到你的程序自己的变量的实际内容。</target>
        </trans-unit>
        <trans-unit id="42ff6f078c663dbcc013a189f161b1005798db67" translate="yes" xml:space="preserve">
          <source>There were at least two consecutive &lt;code&gt;=begin&lt;/code&gt; commands without the corresponding &lt;code&gt;=end&lt;/code&gt; . Only one &lt;code&gt;=begin&lt;/code&gt; may be active at a time.</source>
          <target state="translated">至少有两个连续的 &lt;code&gt;=begin&lt;/code&gt; 命令，没有对应的 &lt;code&gt;=end&lt;/code&gt; 。一次只能激活一个 &lt;code&gt;=begin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f453a9d5941f2f68e4cfdb1b1ca5576cad8a3040" translate="yes" xml:space="preserve">
          <source>There were race conditions 1.x implementations of File::Path's &lt;code&gt;rmtree&lt;/code&gt; function (although sometimes patched depending on the OS distribution or platform). The 2.0 version contains code to avoid the problem mentioned in CVE-2002-0435.</source>
          <target state="translated">File :: Path的 &lt;code&gt;rmtree&lt;/code&gt; 函数存在竞赛条件1.x实现（尽管有时会根据操作系统发行版或平台进行修补）。2.0版本包含避免CVE-2002-0435中提到的问题的代码。</target>
        </trans-unit>
        <trans-unit id="78c41744f80fbb19ebe5f5b692cb01709180e04c" translate="yes" xml:space="preserve">
          <source>There were two things you could do, knowing this: be paranoid or be pragmatic. The paranoid approach was to do as little as possible in your signal handler. Set an existing integer variable that already has a value, and return. This doesn't help you if you're in a slow system call, which will just restart. That means you have to &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; to longjmp(3) out of the handler. Even this is a little cavalier for the true paranoiac, who avoids &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; in a handler because the system</source>
          <target state="translated">知道这一点，您可以做两件事：偏执或务实。偏执狂的做法是在信号处理程序中尽可能少地做。设置一个已经具有值的现有整数变量，然后返回。如果您正在缓慢的系统调用中，这将对您没有帮助，这只会重新启动。这意味着你必须 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 对longjmp（3）从处理程序。即使对于真正的偏执狂来说，这也有点儿麻烦，因为系统会避免 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 处理程序</target>
        </trans-unit>
        <trans-unit id="73d8966c11e67db894b509268c4964e23520f68e" translate="yes" xml:space="preserve">
          <source>There will be less network overhead (and some efficiency in your program) if you specify either the udp or the icmp protocol. The tcp protocol will generate 2.5 times or more traffic for each ping than either udp or icmp. If many hosts are pinged frequently, you may wish to implement a small wait (e.g. 25ms or more) between each ping to avoid flooding your network with packets.</source>
          <target state="translated">如果你指定了udp或icmp协议,会有更少的网络开销(和一些效率)。tcp协议每次ping产生的流量是udp或icmp的2.5倍或更多。如果很多主机经常被ping,你可能希望在每次ping之间实现一个小的等待(例如25ms或更多),以避免你的网络被数据包淹没。</target>
        </trans-unit>
        <trans-unit id="6b418e4f885e0ed1944b1a75c443618ba49e064f" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s More Than One Way To Do It, the Perl Motto. The notion that there can be more than one valid path to solving a programming problem in context. (This doesn&amp;rsquo;t mean that more ways are always better or that all possible paths are equally desirable&amp;mdash;just that there need not be One True Way.)</source>
          <target state="translated">Perl座右铭是不止一种方法。在上下文中解决编程问题可以有多个有效途径。（这并不意味着会有更多的方法总是更好，或者所有可能的路径都是同样可取的-只是不必有一种&amp;ldquo;真正的方法&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="f28bb8331230709c36ed738881be6c54310d8343" translate="yes" xml:space="preserve">
          <source>There's More Than One Way to Do It</source>
          <target state="translated">有不止一种方法可以做到。</target>
        </trans-unit>
        <trans-unit id="2d73bf3d5d8029a31c5c535e944915e019e3d9d2" translate="yes" xml:space="preserve">
          <source>There's a corresponding &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; declaration that unimports meanings imported by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, i.e., it calls &lt;code&gt;unimport Module LIST&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;. It behaves just as &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; does with VERSION, an omitted or empty LIST, or no unimport method being found.</source>
          <target state="translated">有一个相应的 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 声明，即unimport通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 导入的含义，即调用 &lt;code&gt;unimport Module LIST&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 。它的行为与VERSION， &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; LIST省略或为空或未找到unimport方法的行为相同。</target>
        </trans-unit>
        <trans-unit id="899206f410877415c07b1eae00900c686b6ba014" translate="yes" xml:space="preserve">
          <source>There's a corresponding &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; declaration that unimports meanings imported by &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, i.e., it calls &lt;code&gt;unimport Module LIST&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;. It behaves just as &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; does with VERSION, an omitted or empty LIST, or no unimport method being found.</source>
          <target state="translated">有一个相应的 &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 声明，即unimport通过 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 导入的含义，即调用 &lt;code&gt;unimport Module LIST&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 。它的行为与VERSION， &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; LIST省略或为空或未找到unimport方法的行为相同。</target>
        </trans-unit>
        <trans-unit id="5182f679e917b06933e3121044c80451fb98d666" translate="yes" xml:space="preserve">
          <source>There's a couple of useful ones to know about straight away. You wouldn't think we're using any libraries at all at the moment, but '&lt;b&gt;M&lt;/b&gt;' will show which modules are currently loaded, and their version number, while '&lt;b&gt;m&lt;/b&gt;' will show the methods, and '&lt;b&gt;S&lt;/b&gt;' shows all subroutines (by pattern) as shown below. '&lt;b&gt;V&lt;/b&gt;' and '&lt;b&gt;X&lt;/b&gt;' show variables in the program by package scope and can be constrained by pattern.</source>
          <target state="translated">马上有一些有用的知识。您可能不会在此使用任何库，但是' &lt;b&gt;M&lt;/b&gt; '将显示当前正在加载的模块及其版本号，而' &lt;b&gt;m&lt;/b&gt; '将显示方法，而' &lt;b&gt;S&lt;/b&gt; '将显示所有子例程（按模式），如下所示。&amp;ldquo; &lt;b&gt;V&lt;/b&gt; &amp;rdquo;和&amp;ldquo; &lt;b&gt;X&lt;/b&gt; &amp;rdquo;按程序包范围显示程序中的变量，并且可以受模式约束。</target>
        </trans-unit>
        <trans-unit id="18ae2cf96b3321649a9e67b52ce3c6b5c29a8066" translate="yes" xml:space="preserve">
          <source>There's a lot more to networking than this, but this should get you started.</source>
          <target state="translated">有很多比这更多的网络,但这应该让你开始。</target>
        </trans-unit>
        <trans-unit id="7dfd5539590f938c8db0768ae08c09cb62cf9574" translate="yes" xml:space="preserve">
          <source>There's a lot to know about character sets, and text encodings. It's probably best to spend a full day learning all this, but the basics can be learned in minutes.</source>
          <target state="translated">关于字符集和文本编码,有很多东西需要了解。也许最好是花一整天的时间来学习这些,但基本的知识可以在几分钟内学会。</target>
        </trans-unit>
        <trans-unit id="99ae85d03f4b582c99ff96216db7d59e44f17f54" translate="yes" xml:space="preserve">
          <source>There's a problem with &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall(&amp;amp;SYS_pipe)&lt;/a&gt;&lt;/code&gt;: it returns the file number of the read end of the pipe it creates, but there is no way to retrieve the file number of the other end. You can avoid this problem by using &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall(&amp;amp;SYS_pipe)&lt;/a&gt;&lt;/code&gt; 有一个问题：它返回它创建的管道读取端的文件号，但是无法检索另一端的文件号。您可以通过使用 &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; 来避免此问题。</target>
        </trans-unit>
        <trans-unit id="66cd02292a787335ff912b7d35685e3ae9e8fbc4" translate="yes" xml:space="preserve">
          <source>There's a problem with &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall(&amp;amp;SYS_pipe)&lt;/a&gt;&lt;/code&gt;: it returns the file number of the read end of the pipe it creates, but there is no way to retrieve the file number of the other end. You can avoid this problem by using &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall(&amp;amp;SYS_pipe)&lt;/a&gt;&lt;/code&gt; 有一个问题：它返回它创建的管道读取端的文件号，但是无法检索另一端的文件号。您可以通过使用 &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; 来避免此问题。</target>
        </trans-unit>
        <trans-unit id="e41e3a2378d95f98d33fb21414c6067f31a384cf" translate="yes" xml:space="preserve">
          <source>There's a slight complication under the hood of &lt;code&gt;Memoize&lt;/code&gt; : There are actually</source>
          <target state="translated">在 &lt;code&gt;Memoize&lt;/code&gt; 的表象下有一点复杂：实际上有</target>
        </trans-unit>
        <trans-unit id="5de903209b03670bb7672de0c3e9635cd117f5ca" translate="yes" xml:space="preserve">
          <source>There's a subtle trap lurking in the offing: Adding another field after the Short Message (in variable &lt;code&gt;$sm&lt;/code&gt; ) is all right when packing, but this cannot be unpacked naively:</source>
          <target state="translated">有一个潜伏的陷阱：打包时可以在短消息后（在 &lt;code&gt;$sm&lt;/code&gt; 变量中）添加另一个字段，但这不能天真地解包：</target>
        </trans-unit>
        <trans-unit id="5136f0522d5206778ac4f88d48f4c827076f1a46" translate="yes" xml:space="preserve">
          <source>There's a wiki dedicated to the Test Anything Protocol:</source>
          <target state="translated">有一个维基专门用于测试任何东西协议。</target>
        </trans-unit>
        <trans-unit id="3b112374a474f8a64038b7df632984baece37394" translate="yes" xml:space="preserve">
          <source>There's also</source>
          <target state="translated">还有</target>
        </trans-unit>
        <trans-unit id="58a726895b66eba4d8724a2292f078a4d2648322" translate="yes" xml:space="preserve">
          <source>There's also a &lt;a href=&quot;http://search.cpan.org/perldoc/File::Tail&quot;&gt;File::Tail&lt;/a&gt; module from CPAN.</source>
          <target state="translated">还有来自CPAN 的&lt;a href=&quot;http://search.cpan.org/perldoc/File::Tail&quot;&gt;File :: Tail&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="035e86078ae3280a54d8fc426b353c9ce230b2ad" translate="yes" xml:space="preserve">
          <source>There's also a negated version of it:</source>
          <target state="translated">还有一个被否定的版本。</target>
        </trans-unit>
        <trans-unit id="194f92c1842e4ee102fc7a284b9e315ab368c04c" translate="yes" xml:space="preserve">
          <source>There's also a negated version, for the same reason we have &lt;code&gt;unless&lt;/code&gt; :</source>
          <target state="translated">还有一个否定的版本，出于同样的原因， &lt;code&gt;unless&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ce23f5592e874ac51b717997ee3d4abcaf17d1eb" translate="yes" xml:space="preserve">
          <source>There's an &lt;code&gt;unmemoize&lt;/code&gt; function that you can import if you want to. Why would you want to? Here's an example: Suppose you have your cache tied to a DBM file, and you want to make sure that the cache is written out to disk if someone interrupts the program. If the program exits normally, this will happen anyway, but if someone types control-C or something then the program will terminate immediately without synchronizing the database. So what you can do instead is</source>
          <target state="translated">如果需要，可以导入一个 &lt;code&gt;unmemoize&lt;/code&gt; 功能。你为什么要这是一个示例：假设您已将缓存绑定到DBM文件，并且如果某人中断程序，则要确保将缓存写到磁盘上。如果程序正常退出，则无论如何都会发生，但是如果有人键入control-C或其他内容，则程序将立即终止而不同步数据库。因此，您可以做的是</target>
        </trans-unit>
        <trans-unit id="08ec3c4ec2591dd761c5a485e08fcf45d215a5be" translate="yes" xml:space="preserve">
          <source>There's an effort going on to document the internal functions and automatically produce reference manuals from them -- &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; is one such manual which details all the functions which are available to XS writers. &lt;a href=&quot;perlintern&quot;&gt;perlintern&lt;/a&gt; is the autogenerated manual for the functions which are not part of the API and are supposedly for internal use only.</source>
          <target state="translated">目前正在努力记录内部功能并自动从中生成参考手册&lt;a href=&quot;perlapi&quot;&gt;-perlapi&lt;/a&gt;是这样的手册，其中详细介绍了XS编写器可用的所有功能。&lt;a href=&quot;perlintern&quot;&gt;perlintern&lt;/a&gt;是针对这些功能的自动生成的手册，这些功能不是API的一部分，并且仅供内部使用。</target>
        </trans-unit>
        <trans-unit id="b109c22c8125d5fbc051e5882994774c0628f7aa" translate="yes" xml:space="preserve">
          <source>There's an example of this in &lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;). First, you put the terminal into &quot;no echo&quot; mode, then just read the password normally. You may do this with an old-style &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl()&lt;/a&gt;&lt;/code&gt; function, POSIX terminal control (see &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; or its documentation the Camel Book), or a call to the &lt;b&gt;stty&lt;/b&gt; program, with varying degrees of portability.</source>
          <target state="translated">&lt;a href=&quot;functions/crypt&quot;&gt;crypt中&lt;/a&gt;有一个示例。首先，将终端设置为&amp;ldquo;无回声&amp;rdquo;模式，然后正常读取密码。您可以使用老式的 &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl()&lt;/a&gt;&lt;/code&gt; 函数，POSIX终端控件（请参阅&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;或Camel Book的文档）或对&lt;b&gt;stty&lt;/b&gt;程序的调用来实现此目的，并具有不同程度的可移植性。</target>
        </trans-unit>
        <trans-unit id="1ee734c8b4d4a5b72b07450e993a31efdfcc81d2" translate="yes" xml:space="preserve">
          <source>There's an extraordinary number of people out there who don't appear to know anything about using the perl debugger, though they use the language every day. This is for them.</source>
          <target state="translated">有很多人看起来对使用perl调试器一无所知,尽管他们每天都在使用这种语言。这是为他们准备的。</target>
        </trans-unit>
        <trans-unit id="36e675dcb566e351efbc0e3f85ec7104c90a083d" translate="yes" xml:space="preserve">
          <source>There's currently only one class that has a stable interface - CPAN::Shell. All commands that are available in the CPAN shell are methods of the class CPAN::Shell. The arguments on the commandline are passed as arguments to the method.</source>
          <target state="translated">目前只有一个类有稳定的接口--CPAN::Shell。CPAN shell中所有可用的命令都是CPAN::Shell这个类的方法。命令行上的参数作为参数传递给方法。</target>
        </trans-unit>
        <trans-unit id="f60d62cdc295d6cbdfb5f2a35e55c4e958719c10" translate="yes" xml:space="preserve">
          <source>There's even less need to distinguish between EBCDIC code pages, but to do so try looking at one or more of the characters that differ between them.</source>
          <target state="translated">更不需要区分EBCDIC码页,但要区分的话,可以试着看看它们之间的一个或多个不同的字符。</target>
        </trans-unit>
        <trans-unit id="241fd51f25450a5ab0b7ec2c19699d2410027de0" translate="yes" xml:space="preserve">
          <source>There's no builtin way to do this, but &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; has a couple of techniques to make it possible for the intrepid hacker.</source>
          <target state="translated">没有内置的方法可以执行此操作，但是&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;有两种技术可以使强悍的黑客成为可能。</target>
        </trans-unit>
        <trans-unit id="5ace2a9bc7f6a90948438c072e0ce5f8cdc2b9bc" translate="yes" xml:space="preserve">
          <source>There's no feedback from this, but you can see what breakpoints are set by using the list 'L' command:</source>
          <target state="translated">没有任何反馈,但你可以通过使用list 'L'命令查看设置了哪些断点。</target>
        </trans-unit>
        <trans-unit id="f521ff0638ee964aa0ea31d64e9248f45119c41c" translate="yes" xml:space="preserve">
          <source>There's no solution for this problem other than making the custom engine understand a construct like &lt;code&gt;(?:)&lt;/code&gt;.</source>
          <target state="translated">除了使自定义引擎理解 &lt;code&gt;(?:)&lt;/code&gt; 之类的构造之外，没有其他解决方案。</target>
        </trans-unit>
        <trans-unit id="f42438ddafc8a1bac998273822622081c6567570" translate="yes" xml:space="preserve">
          <source>There's no strong security layer in CPAN.pm. CPAN.pm helps you to install foreign, unmasked, unsigned code on your machine. We compare to a checksum that comes from the net just as the distribution file itself. But we try to make it easy to add security on demand:</source>
          <target state="translated">CPAN.pm中没有强大的安全层。CPAN.pm可以帮助你在机器上安装外来的、未屏蔽的、未签名的代码。我们与来自网络的校验和相比,就像发行文件本身一样。但我们尽量使其易于按需添加安全性。</target>
        </trans-unit>
        <trans-unit id="794fc83a38998696363c5b95bfbda5c120c0de13" translate="yes" xml:space="preserve">
          <source>There's no way to tell if a &lt;code&gt;char *&lt;/code&gt; or &lt;code&gt;U8 *&lt;/code&gt; string is UTF-8 or not. But you can tell if an SV is to be treated as UTF-8 by calling &lt;code&gt;DO_UTF8&lt;/code&gt; on it, after stringifying it with &lt;code&gt;SvPV&lt;/code&gt; or a similar macro. And, you can tell if SV is actually UTF-8 (even if it is not to be treated as such) by looking at its &lt;code&gt;SvUTF8&lt;/code&gt; flag (again after stringifying it). Don't forget to set the flag if something should be UTF-8. Treat the flag as part of the PV, even though it's not -- if you pass on the PV to somewhere, pass on the flag too.</source>
          <target state="translated">无法判断 &lt;code&gt;char *&lt;/code&gt; 或 &lt;code&gt;U8 *&lt;/code&gt; 字符串是否为UTF-8。但是，在用 &lt;code&gt;SvPV&lt;/code&gt; 或类似的宏对SV 进行字符串化处理后，可以通过在其上调用 &lt;code&gt;DO_UTF8&lt;/code&gt; 来判断SV是否被视为UTF-8 。并且，通过查看其 &lt;code&gt;SvUTF8&lt;/code&gt; 标志（再次对其进行字符串化处理），可以判断SV是否实际上是UTF-8（即使不应将其视为UTF-8 ）。如果某些内容应为UTF-8，请不要忘记设置标志。即使不将标志视为PV的一部分-如果将PV传递到某个地方，也传递标志。</target>
        </trans-unit>
        <trans-unit id="dcc25cfc8a3ec732d1d2283e554b506992b75eb5" translate="yes" xml:space="preserve">
          <source>There's not a single way to run code in the background so you don't have to wait for it to finish before your program moves on to other tasks. Process management depends on your particular operating system, and many of the techniques are covered in &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">没有在后台运行代码的单一方法，因此您无需等待程序完成就可以将程序移至其他任务。流程管理取决于您的特定操作系统，&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;涵盖了许多技术。</target>
        </trans-unit>
        <trans-unit id="d2aa5e3dbb927bd52349be7be623e623e64f5bf0" translate="yes" xml:space="preserve">
          <source>There's now some new C code that's been added to the .xs file. The purpose of the &lt;code&gt;constant&lt;/code&gt; routine is to make the values that are #define'd in the header file accessible by the Perl script (by calling either &lt;code&gt;TESTVAL&lt;/code&gt; or &lt;code&gt;&amp;amp;Mytest2::TESTVAL&lt;/code&gt; ). There's also some XS code to allow calls to the &lt;code&gt;constant&lt;/code&gt; routine.</source>
          <target state="translated">现在，.xs文件中已经添加了一些新的C代码。 &lt;code&gt;constant&lt;/code&gt; 例程的目的是使Perl脚本（通过调用 &lt;code&gt;TESTVAL&lt;/code&gt; 或 &lt;code&gt;&amp;amp;Mytest2::TESTVAL&lt;/code&gt; ）可对头文件中#define的值进行访问。还有一些XS代码允许调用 &lt;code&gt;constant&lt;/code&gt; 例程。</target>
        </trans-unit>
        <trans-unit id="e3ac8386164e4284b824a87f18c211196212c066" translate="yes" xml:space="preserve">
          <source>There's one fine point I skipped. Line 5 is unnecessary, and we can get rid of it.</source>
          <target state="translated">有一个细微的地方我跳过了。第5行是不必要的,我们可以把它去掉。</target>
        </trans-unit>
        <trans-unit id="f039a4fa9d9f10c8752271acf6c5252496665e47" translate="yes" xml:space="preserve">
          <source>There's one more item to add to this list. Do &lt;b&gt;not&lt;/b&gt; export variable names. Just because &lt;code&gt;Exporter&lt;/code&gt; lets you do that, it does not mean you should.</source>
          <target state="translated">还有一个项目要添加到此列表中。千万&lt;b&gt;不能&lt;/b&gt;导出变量名。仅仅因为 &lt;code&gt;Exporter&lt;/code&gt; 允许您这样做，并不意味着您应该这样做。</target>
        </trans-unit>
        <trans-unit id="23be60d3d8e40781087cd39d472decaae39f70d3" translate="yes" xml:space="preserve">
          <source>There, &quot;=shazbot&quot; will be parsed as a Pod command &quot;shazbot&quot;, not as a data paragraph &quot;=shazbot\n&quot;. However, you can express a data paragraph consisting of &quot;=shazbot\n&quot; using this code:</source>
          <target state="translated">在这里,&quot;=shazbot &quot;将被解析为一个Pod命令 &quot;shazbot&quot;,而不是一个数据段&quot;=shazbot\n&quot;。但是,你可以用这个代码来表达一个由&quot;=shazbot/n &quot;组成的数据段。</target>
        </trans-unit>
        <trans-unit id="d934ecae0b30d1837eb15a99e36faf1a189e093b" translate="yes" xml:space="preserve">
          <source>There, the &quot;=begin html&quot;...&quot;=end html&quot; region is nested inside the larger &quot;=begin :biblio&quot;...&quot;=end :biblio&quot; region. Note that the content of the &quot;=begin html&quot;...&quot;=end html&quot; region is data paragraph(s), because the immediately containing region's identifier (&quot;html&quot;)</source>
          <target state="translated">在这里,&quot;=begin html&quot;...&quot;=end html &quot;区域嵌套在较大的&quot;=begin :biblio&quot;...&quot;=end :biblio &quot;区域中。请注意,&quot;=begin html&quot;...&quot;=end html &quot;区域的内容是数据段,因为紧挨着该区域的标识符 (&quot;html&quot;)</target>
        </trans-unit>
        <trans-unit id="4c11e16e3b4c4d1c6c6291b739425f3d103ebc32" translate="yes" xml:space="preserve">
          <source>Therefor, we recommend to only use &lt;code&gt;lynx&lt;/code&gt; as a last resort. This is why it is at the back of our list of methods to try as well.</source>
          <target state="translated">因此，我们建议仅将 &lt;code&gt;lynx&lt;/code&gt; 作为最后的手段。这就是为什么它也在我们尝试的方法列表的后面。</target>
        </trans-unit>
        <trans-unit id="22f5648477726ba3de08027c1e14282ca2d62678" translate="yes" xml:space="preserve">
          <source>Therefore it is best to avoid &lt;code&gt;$Carp::CarpLevel&lt;/code&gt; . Instead use &lt;code&gt;@CARP_NOT&lt;/code&gt; , &lt;code&gt;%Carp::Internal&lt;/code&gt; and &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; .</source>
          <target state="translated">因此，最好避免 &lt;code&gt;$Carp::CarpLevel&lt;/code&gt; 。而是使用 &lt;code&gt;@CARP_NOT&lt;/code&gt; ， &lt;code&gt;%Carp::Internal&lt;/code&gt; 和 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d0e80030071251142bc856e7654aae9ae473e69" translate="yes" xml:space="preserve">
          <source>Therefore we can use the &lt;code&gt;O_FILES&lt;/code&gt; variable to tell MakeMaker to use these objects into the shared library.</source>
          <target state="translated">因此，我们可以使用 &lt;code&gt;O_FILES&lt;/code&gt; 变量告诉MakeMaker使用这些对象进入共享库。</target>
        </trans-unit>
        <trans-unit id="bc549460f9ec0f5ba049505f7c5226ae9e2f8140" translate="yes" xml:space="preserve">
          <source>Therefore, if you make changes to $ENV{TZ} from inside a thread other than the main thread then those changes will not be seen by strftime if you subsequently call that with the %Z formatting code. You must change $ENV{TZ} in the main thread to have the desired effect in this case (and you must also call _tzset() in the main thread to register the environment change).</source>
          <target state="translated">因此,如果您在主线程以外的线程中对 $ENV{TZ}进行了修改,那么如果您随后使用 %Z 格式化代码调用该线程,这些修改将不会被 strftime 看到。在这种情况下,你必须在主线程中修改 $ENV{TZ}才能达到预期的效果 (而且你还必须在主线程中调用 _tzset()来注册环境变化)。</target>
        </trans-unit>
        <trans-unit id="a9f8fba915c890e8c346b81a259121ea682217ff" translate="yes" xml:space="preserve">
          <source>Therefore, if you want your scripts to be able to run on all versions of Perl, you should call &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; explicitly and not rely on automatic closing.</source>
          <target state="translated">因此，如果希望脚本能够在所有版本的Perl上运行，则应显式调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; ,而不要依赖自动关闭。</target>
        </trans-unit>
        <trans-unit id="b60bd02288d8270eaef5b4fd58dd4835333cea91" translate="yes" xml:space="preserve">
          <source>Therefore, populate such variables &lt;b&gt;after&lt;/b&gt; declaring them as shared. (Scalar and scalar refs are not affected by this problem.)</source>
          <target state="translated">因此，&lt;b&gt;在&lt;/b&gt;声明这些变量为共享变量&lt;b&gt;后&lt;/b&gt;，填充它们。（标量和标量引用不受此问题的影响。）</target>
        </trans-unit>
        <trans-unit id="fd4c5f1975f02e1f013464b5926b49a349d976cd" translate="yes" xml:space="preserve">
          <source>Therefore, recursion should normally be avoided, but is nonetheless supported.</source>
          <target state="translated">因此,通常应该避免递归,但还是支持递归。</target>
        </trans-unit>
        <trans-unit id="db068f38c67a6942c06b6242bd31cfce066e66c2" translate="yes" xml:space="preserve">
          <source>Therefore, when both -f and -t are omitted, &lt;b&gt;piconv&lt;/b&gt; just acts like &lt;b&gt;cat&lt;/b&gt;.</source>
          <target state="translated">因此，当同时省略-f和-t时，&lt;b&gt;piconv的&lt;/b&gt;行为就像&lt;b&gt;cat&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2f61899aa2182fe38363f4a728d368f7dbd80080" translate="yes" xml:space="preserve">
          <source>Therefore, when serializing hooks are involved,</source>
          <target state="translated">因此,当涉及到序列化钩子时。</target>
        </trans-unit>
        <trans-unit id="c563bb79b9bbcc9436e0f964c49bd1fc0638d285" translate="yes" xml:space="preserve">
          <source>These #vars represent opcode properties that you may want as part of your rendering. The '#' is intended as a private sigil; a #var's value is interpolated into the style-line, much like &quot;read $this&quot;.</source>
          <target state="translated">这些#vars代表了你在渲染时可能需要的操作码属性。'#'是一个私人的标志;一个#var的值被插入到样式行中,就像 &quot;read $this &quot;一样。</target>
        </trans-unit>
        <trans-unit id="8f188e4230a9960392a0f6434bcd9cdb687b2105" translate="yes" xml:space="preserve">
          <source>These actually run the tests, analogous to the functions in Test::More.</source>
          <target state="translated">这些实际上是运行测试,类似于Test::More中的函数。</target>
        </trans-unit>
        <trans-unit id="47b609b8bdbe47393836decca9fbf56107eb37fe" translate="yes" xml:space="preserve">
          <source>These all match a single codepoint with the given property. Use &lt;code&gt;\P&lt;/code&gt; in place of &lt;code&gt;\p&lt;/code&gt; to match one codepoint lacking that property.</source>
          <target state="translated">这些都与具有给定属性的单个代码点匹配。使用 &lt;code&gt;\P&lt;/code&gt; 代替 &lt;code&gt;\p&lt;/code&gt; 可以匹配缺少该属性的一个代码点。</target>
        </trans-unit>
        <trans-unit id="14b0e821748bdb374700b2c0b377f04dafebe4c2" translate="yes" xml:space="preserve">
          <source>These all might have problems handling infinity right.</source>
          <target state="translated">这些可能都有问题,处理好无穷大。</target>
        </trans-unit>
        <trans-unit id="f193401280223b6d90ef40113a3483800172634b" translate="yes" xml:space="preserve">
          <source>These are Locale::Maketext's assumptions about the class hierarchy formed by all your language classes:</source>
          <target state="translated">这些是Locale::Maketext对你所有语言类所形成的类层次的假设。</target>
        </trans-unit>
        <trans-unit id="7d93f149b189abdf70833601535a585584795222" translate="yes" xml:space="preserve">
          <source>These are Perl bindings for the Gtk toolkit ( &lt;a href=&quot;http://www.gtk.org&quot;&gt;http://www.gtk.org&lt;/a&gt; ). The interface changed significantly between versions 1 and 2 so they have separate Perl modules. It runs under Unix, Win32 and Mac OS X (currently it requires an X server on Mac OS, but a 'native' port is underway), and the widgets look the same on every platform: i.e., they don't match the native widgets. As with Wx, the Perl bindings follow the C API closely, and the documentation requires you to read the C documentation to understand it.</source>
          <target state="translated">这些是Gtk工具包（&lt;a href=&quot;http://www.gtk.org&quot;&gt;http://www.gtk.org&lt;/a&gt;）的Perl绑定。接口在版本1和版本2之间发生了显着变化，因此它们具有单独的Perl模块。它可以在Unix，Win32和Mac OS X下运行（当前在Mac OS上需要X服务器，但是正在运行&amp;ldquo;本机&amp;rdquo;端口），并且在每个平台上的小部件都相同：即，它们与本机不匹配小部件。与Wx一样，Perl绑定紧密遵循C API，并且该文档要求您阅读C文档以理解它。</target>
        </trans-unit>
        <trans-unit id="06cca08d46609adb849cad691c3d195ff57274e9" translate="yes" xml:space="preserve">
          <source>These are a few notes describing features peculiar to Plan 9 Perl. As such, it is not intended to be a replacement for the rest of the Perl 5 documentation (which is both copious and excellent). If you have any questions to which you can't find answers in these man pages, contact Luther Huffman at lutherh@stratcom.com and we'll try to answer them.</source>
          <target state="translated">这是一些描述 Plan 9 Perl 特有功能的说明。因此,它并不打算取代 Perl 5 的其它文档(它的文档非常丰富和出色)。如果你有任何在这些手册中找不到答案的问题,请联系 Luther Huffman,地址是 lutherh@stratcom.com,我们会尽力解答。</target>
        </trans-unit>
        <trans-unit id="035e487505e2bd7d2a574e14eebe3b30a69fa1a9" translate="yes" xml:space="preserve">
          <source>These are a hotchpotch of opcodes still waiting to be considered</source>
          <target state="translated">这些都是尚待考虑的操作码的热点。</target>
        </trans-unit>
        <trans-unit id="ab597ea19704a4092bef6ea8610d0145fc3acd27" translate="yes" xml:space="preserve">
          <source>These are all &quot;getters&quot; which return the data set for these attributes during object construction.</source>
          <target state="translated">这些都是 &quot;获取器&quot;,在对象构建过程中返回这些属性的数据集。</target>
        </trans-unit>
        <trans-unit id="c6ad141ea95625d5f83dc60a511981417685e463" translate="yes" xml:space="preserve">
          <source>These are also the typical steps involved in writing a computer program. This makes perfect sense, because regular expressions are essentially programs written in a little computer language that specifies patterns.</source>
          <target state="translated">这些也是编写计算机程序的典型步骤。这是很有意义的,因为正则表达式本质上是用一种指定模式的小计算机语言编写的程序。</target>
        </trans-unit>
        <trans-unit id="c614a56da53c8268e03927a0382855aa589c9ffe" translate="yes" xml:space="preserve">
          <source>These are alternate syntaxes for &lt;code&gt;decode('utf8', ...)&lt;/code&gt; and &lt;code&gt;encode('utf8',
...)&lt;/code&gt; .</source>
          <target state="translated">这些是备用语法 &lt;code&gt;decode('utf8', ...)&lt;/code&gt; 和 &lt;code&gt;encode('utf8', ...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a504c2130962ba4555e63c517df7cfb6c3415a56" translate="yes" xml:space="preserve">
          <source>These are based on what command.com does on Win98. They may be wrong for other Windows shells, I don't know.</source>
          <target state="translated">这些都是基于command.com在Win98上所做的。对于其他的Windows shell,它们可能是错误的,我不知道。</target>
        </trans-unit>
        <trans-unit id="2c07d55f7a2a925e22fec82104bd39d3cabc4301" translate="yes" xml:space="preserve">
          <source>These are called mid-endian, middle-endian, mixed-endian, or just weird.</source>
          <target state="translated">这些被称为中段、中段、混合段,或者只是怪异。</target>
        </trans-unit>
        <trans-unit id="3a9105b34a20a7fdd4e6d997e3a1e1ad31f3f321" translate="yes" xml:space="preserve">
          <source>These are covered in the following section.</source>
          <target state="translated">这些内容将在下一节中介绍。</target>
        </trans-unit>
        <trans-unit id="543fcf9df34b75f159b226a9706c32a67f612f3d" translate="yes" xml:space="preserve">
          <source>These are effectively no-ops.</source>
          <target state="translated">这些实际上都是无奈之举。</target>
        </trans-unit>
        <trans-unit id="f6dbfbbee534ca87c61eabe600b034f42390dde5" translate="yes" xml:space="preserve">
          <source>These are equivalent</source>
          <target state="translated">这些都相当于</target>
        </trans-unit>
        <trans-unit id="2c34193d065093cc77699a0d9ca713a7565b5a4e" translate="yes" xml:space="preserve">
          <source>These are fetched from one or more mirrored CPAN (Comprehensive Perl Archive Network) sites and unpacked in a dedicated directory.</source>
          <target state="translated">这些都是从一个或多个CPAN(Comprehensive Perl Archive Network,综合Perl档案网)镜像站点中获取的,并在一个专用目录中解压。</target>
        </trans-unit>
        <trans-unit id="1218c4eafb2ac24b7f5a6bfc47e38d53cda6dbb8" translate="yes" xml:space="preserve">
          <source>These are fprintf()/vfprintf() equivalents.</source>
          <target state="translated">这些都是fprintf()/vfprintf()的等价物。</target>
        </trans-unit>
        <trans-unit id="c9080846b04ed2aaef61ea34f53f7101d2c5f347" translate="yes" xml:space="preserve">
          <source>These are functions for searching through directory trees doing work on each file found similar to the Unix</source>
          <target state="translated">这些功能用于搜索目录树,对找到的每个文件进行工作,类似于Unix的</target>
        </trans-unit>
        <trans-unit id="82d3c39fd0ecabf1c8dc2de9284d7be1c98f1d46" translate="yes" xml:space="preserve">
          <source>These are general guidelines for how to write POD documentation for Perl scripts and modules, based on general guidelines for writing good UNIX man pages. All of these guidelines are, of course, optional, but following them will make your documentation more consistent with other documentation on the system.</source>
          <target state="translated">这些是关于如何为Perl脚本和模块编写POD文档的一般指导原则,这些指导原则是基于编写良好的UNIX手册的一般指导原则。当然,所有这些指导原则都是可选的,但遵循它们将使你的文档与系统中的其他文档更加一致。</target>
        </trans-unit>
        <trans-unit id="dad0e81d2d1dfbeb7b354f138de6b73ae95d9158" translate="yes" xml:space="preserve">
          <source>These are instructions for building Perl from source. This version of Perl requires the dynamic linking support that is found in OpenVOS Release 17.1 and thus is not supported on OpenVOS Release 17.0 or earlier releases.</source>
          <target state="translated">这些都是关于从源码构建Perl的说明。这个版本的Perl需要OpenVOS 17.1版中的动态链接支持,因此不支持OpenVOS 17.0版或更早的版本。</target>
        </trans-unit>
        <trans-unit id="c8591b5e35cdacaa99ac7aebf4d9655f41e44d08" translate="yes" xml:space="preserve">
          <source>These are instructions for building Perl under DOS (or w??), using DJGPP v2.03 or later. Under w95 long filenames are supported.</source>
          <target state="translated">这些是在DOS(或w??)下构建Perl的说明,使用DJGPP v2.03或更高版本。在w95下,支持长文件名。</target>
        </trans-unit>
        <trans-unit id="1ebba6a1db0c9a0e274e92574c949eaf7a4b8fb7" translate="yes" xml:space="preserve">
          <source>These are instructions for building Perl under Windows 2000 and later.</source>
          <target state="translated">这些都是在Windows 2000和更高版本下构建Perl的说明。</target>
        </trans-unit>
        <trans-unit id="56039c5fbea93b2739212ecaf27c30cc3edfb9c5" translate="yes" xml:space="preserve">
          <source>These are intended to be services performed by the clients of this API.</source>
          <target state="translated">这些服务旨在由该API的客户端执行。</target>
        </trans-unit>
        <trans-unit id="6d5e58ad94dd8e12f40343c4fe00cb855a20e455" translate="yes" xml:space="preserve">
          <source>These are just the most common definitions of &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; in Perl. There may well be others. For example, on an EBCDIC implementation such as z/OS (OS/390) or OS/400 (using the ILE, the PASE is ASCII-based) the above material is similar to &quot;Unix&quot; but the code numbers change:</source>
          <target state="translated">这些只是Perl中最常见的 &lt;code&gt;\n&lt;/code&gt; 和 &lt;code&gt;\r&lt;/code&gt; 定义。可能还有其他人。例如，在诸如z / OS（OS / 390）或OS / 400之类的EBCDIC实现中（使用ILE，PASE基于ASCII），上述内容类似于&amp;ldquo; Unix&amp;rdquo;，但是代码号有所变化：</target>
        </trans-unit>
        <trans-unit id="e2a1ebead9f267c39fe9da94bb4791dac090d0bc" translate="yes" xml:space="preserve">
          <source>These are low-level functions to extract and use capabilities from a terminal capability (termcap) database.</source>
          <target state="translated">这些是从终端能力(termcap)数据库中提取和使用能力的低级函数。</target>
        </trans-unit>
        <trans-unit id="6e1b104453fcd9be9aa03bca5a6390babe809d8b" translate="yes" xml:space="preserve">
          <source>These are methods that you may find it handy to use, generally from %Lexicon routines of yours (whether expressed as Bracket Notation or not).</source>
          <target state="translated">这些都是你可能会觉得很方便使用的方法,一般来自你的%Lexicon例程(无论是否用括号表示)。</target>
        </trans-unit>
        <trans-unit id="9a95859137ef50d66689fe259453639b6dce722a" translate="yes" xml:space="preserve">
          <source>These are methods which are used in the course of writing a test but are not themselves tests.</source>
          <target state="translated">这些方法是在编写测试的过程中使用的,但其本身并不是测试。</target>
        </trans-unit>
        <trans-unit id="14859e3783966bf81d1767be73584f0ff1e6b683" translate="yes" xml:space="preserve">
          <source>These are methods which help writing cross-platform code.</source>
          <target state="translated">这些方法有助于编写跨平台代码。</target>
        </trans-unit>
        <trans-unit id="10fcdff63f0636b8e542860baaf4e1184f58638e" translate="yes" xml:space="preserve">
          <source>These are methods which produce make targets.</source>
          <target state="translated">这些都是产生使目标的方法。</target>
        </trans-unit>
        <trans-unit id="5242bfa15c97f14acba2cd2d00dbeca39084930f" translate="yes" xml:space="preserve">
          <source>These are most easily explained from the bottom up.</source>
          <target state="translated">这些都是最容易从根本上解释的。</target>
        </trans-unit>
        <trans-unit id="eff3d42df745b107b6d797477e3d4e7f8d24cab3" translate="yes" xml:space="preserve">
          <source>These are not the very basics, though. It is assumed that you already know the difference between bytes and characters, and realise (and accept!) that there are many different character sets and encodings, and that your program has to be explicit about them. Recommended reading is &quot;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&quot; by Joel Spolsky, at &lt;a href=&quot;http://joelonsoftware.com/articles/Unicode.html&quot;&gt;http://joelonsoftware.com/articles/Unicode.html&lt;/a&gt;.</source>
          <target state="translated">但是，这些都不是最基本的。假定您已经知道字节和字符之间的区别，并意识到（并接受！）有许多不同的字符集和编码，并且您的程序必须对此有明确的说明。推荐读物是Joel Spolsky的&amp;ldquo;绝对绝对肯定地，每个软件开发人员绝对必须了解Unicode和字符集（无借口！）&amp;rdquo;，网址为&lt;a href=&quot;http://joelonsoftware.com/articles/Unicode.html&quot;&gt;http://joelonsoftware.com/articles/Unicode.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3cbc1741b6d34271e2ec1a26ca7d6418baa0ebb4" translate="yes" xml:space="preserve">
          <source>These are only present when &lt;code&gt;netorder&lt;/code&gt; is FALSE. These are the sizes of various C datatypes of the perl that created this image. These must match the current perl for the image to be readable by Storable.</source>
          <target state="translated">这些仅在 &lt;code&gt;netorder&lt;/code&gt; 为FALSE时出现。这些是创建此映像的perl的各种C数据类型的大小。这些必须与当前perl匹配才能使Storable读取图像。</target>
        </trans-unit>
        <trans-unit id="920887e803f6cf14e09050db36f20df3c6ead9d1" translate="yes" xml:space="preserve">
          <source>These are only supported if your system has &amp;lt;</source>
          <target state="translated">仅当系统具有&amp;lt;</target>
        </trans-unit>
        <trans-unit id="140e31bd5bffd898fd2913825a2d2d23dcf95138" translate="yes" xml:space="preserve">
          <source>These are pairwise exclusive, i.e. compact or loose, vt or ascii.</source>
          <target state="translated">这些都是成对的,即紧凑或松散,vt或ascii。</target>
        </trans-unit>
        <trans-unit id="ee44bfea63f0502e44e3769d9962bf8126742be7" translate="yes" xml:space="preserve">
          <source>These are passed in to your plugin's &lt;code&gt;load()&lt;/code&gt; class method (if it has one), along with a reference to the &lt;code&gt;App::Prove&lt;/code&gt; object that is invoking your plugin:</source>
          <target state="translated">这些将传递给您插件的 &lt;code&gt;load()&lt;/code&gt; 类方法（如果有的话），以及对调用您插件的 &lt;code&gt;App::Prove&lt;/code&gt; 对象的引用：</target>
        </trans-unit>
        <trans-unit id="87db38161fab9301a6c38e350a75487ce9dba0c7" translate="yes" xml:space="preserve">
          <source>These are readline issues and can only be fixed by studying readline configuration on your architecture and adjusting the referenced file accordingly. Please make a backup of the &lt;code&gt;/etc/inputrc&lt;/code&gt; or &lt;code&gt;~/.inputrc&lt;/code&gt; and edit them. Quite often harmless changes like uppercasing or lowercasing some arguments solves the problem.</source>
          <target state="translated">这些是readline问题，只能通过研究体系结构上的readline配置并相应地调整引用的文件来解决。请备份 &lt;code&gt;/etc/inputrc&lt;/code&gt; 或 &lt;code&gt;~/.inputrc&lt;/code&gt; 并进行编辑。经常采用无害更改，例如使用大写或小写一些参数来解决问题。</target>
        </trans-unit>
        <trans-unit id="b38ff2c237d2189cfc8068063c988ad558800625" translate="yes" xml:space="preserve">
          <source>These are scripts which will check the source things like ANSI C violations, POD encoding issues, etc.</source>
          <target state="translated">这些脚本会检查源头的东西,比如ANSI C违规,POD编码问题等。</target>
        </trans-unit>
        <trans-unit id="08a1e3d5222d26c7ad00377b2f49dd3e19a69282" translate="yes" xml:space="preserve">
          <source>These are shortcuts for &lt;code&gt;$token-&amp;gt;tag() eq &lt;i&gt;somestring&lt;/i&gt;&lt;/code&gt;</source>
          <target state="translated">这些是 &lt;code&gt;$token-&amp;gt;tag() eq &lt;i&gt;somestring&lt;/i&gt;&lt;/code&gt; &lt;i&gt;somestring的&lt;/i&gt;快捷方式&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="34937e959a1c366f5128e5b9fde3a8ddb4bd5e6f" translate="yes" xml:space="preserve">
          <source>These are similar to article(), body() and head(), but rather than returning the requested data directly, they return a tied filehandle from which to read the article.</source>
          <target state="translated">这些方法类似于article()、body()和head(),但它们不是直接返回所请求的数据,而是返回一个绑定的filehandle,用来读取文章。</target>
        </trans-unit>
        <trans-unit id="992979db9b32df20ed312f9df292c8122981c5bf" translate="yes" xml:space="preserve">
          <source>These are the files in the Perl release that contain references to Cygwin. These very brief notes attempt to explain the reason for all conditional code. Hopefully, keeping this up to date will allow the Cygwin port to be kept as clean as possible.</source>
          <target state="translated">这些是Perl版本中包含对Cygwin的引用的文件。这些非常简短的注释试图解释所有条件代码的原因。希望保持这些文件的更新能够使 Cygwin 移植版本尽可能地保持干净。</target>
        </trans-unit>
        <trans-unit id="75ac46c3e2da8e520c552d106b13b25422f4ae84" translate="yes" xml:space="preserve">
          <source>These are the functions that are available, they may either be called as functions or class methods:</source>
          <target state="translated">这些都是可用的函数,它们可以作为函数或类方法被调用。</target>
        </trans-unit>
        <trans-unit id="da1f03a776fe8bedafea0b23935ca2ad13f5c2fe" translate="yes" xml:space="preserve">
          <source>These are the hash data structures that are available:</source>
          <target state="translated">这些都是可用的哈希数据结构。</target>
        </trans-unit>
        <trans-unit id="321abf696e1ac3f1c7e8ae4631a3e0352eed8069" translate="yes" xml:space="preserve">
          <source>These are the same as color('attribute') and can be used if you prefer typing:</source>
          <target state="translated">这些和color('attribute')一样,如果你喜欢打字,也可以使用。</target>
        </trans-unit>
        <trans-unit id="4187810dcd65ec8ff13d408cac42774a760ce9e6" translate="yes" xml:space="preserve">
          <source>These are the signals which a program might normally expect to encounter and which by default cause it to terminate. They are HUP, INT, PIPE and TERM.</source>
          <target state="translated">这些是程序通常会遇到的信号,默认情况下会导致程序终止。它们是HUP、INT、PIPE和TERM。</target>
        </trans-unit>
        <trans-unit id="50c4067312fedca516066cb81563c6787bf50478" translate="yes" xml:space="preserve">
          <source>These are the signals which were trapped by default by the old &lt;b&gt;sigtrap&lt;/b&gt; interface, they are ABRT, BUS, EMT, FPE, ILL, PIPE, QUIT, SEGV, SYS, TERM, and TRAP. If no signals or signals lists are passed to &lt;b&gt;sigtrap&lt;/b&gt;, this list is used.</source>
          <target state="translated">这些信号是旧的&lt;b&gt;sigtrap&lt;/b&gt;接口默认捕获的信号，它们是ABRT，BUS，EMT，FPE，ILL，PIPE，QUIT，SEGV，SYS，TERM和TRAP。如果没有信号或信号列表传递给&lt;b&gt;sigtrap&lt;/b&gt;，则使用此列表。</target>
        </trans-unit>
        <trans-unit id="cea91aaa564fccd3f4852969e3ebc12f20249663" translate="yes" xml:space="preserve">
          <source>These are the six methods that are exported as default.</source>
          <target state="translated">这是六种作为默认导出的方法。</target>
        </trans-unit>
        <trans-unit id="107044185540681260f831f30270844d122d9842" translate="yes" xml:space="preserve">
          <source>These are the things that you can put in the parameters to plan:</source>
          <target state="translated">这些都是你可以放在参数中规划的东西。</target>
        </trans-unit>
        <trans-unit id="cae5aa495786f78d7786c67162eeac298ded8720" translate="yes" xml:space="preserve">
          <source>These are to do with constructing a language handle:</source>
          <target state="translated">这些都与构建语言句柄有关。</target>
        </trans-unit>
        <trans-unit id="25e9dcb05d530b0eaaf353a6122269805fd5136a" translate="yes" xml:space="preserve">
          <source>These are useful shortcuts to save on the typing.</source>
          <target state="translated">这些都是有用的快捷键,可以节省打字的时间。</target>
        </trans-unit>
        <trans-unit id="20957167192887677e71195c4861c8a5596fbdd0" translate="yes" xml:space="preserve">
          <source>These are valid only on ASCII platforms. Starting in Perl v5.22, simply changing the octal constants to equivalent &lt;code&gt;\N{U+...}&lt;/code&gt; values makes them portable:</source>
          <target state="translated">这些仅在ASCII平台上有效。从Perl v5.22开始，只需将八进制常量更改为等效的 &lt;code&gt;\N{U+...}&lt;/code&gt; 值，即可使用它们：</target>
        </trans-unit>
        <trans-unit id="a8c3820acf49b8050b73972a9c61ce1cf6f1d9df" translate="yes" xml:space="preserve">
          <source>These are versions of the macros which take an explicit interpreter as an argument.</source>
          <target state="translated">这些都是宏的版本,它们以一个显式解释器作为参数。</target>
        </trans-unit>
        <trans-unit id="b056cc5f487123530dc637016a4d1c22c28e035c" translate="yes" xml:space="preserve">
          <source>These are:</source>
          <target state="translated">这些是:</target>
        </trans-unit>
        <trans-unit id="16d16f3cffc4ac9689654ee5a738c8ecadd74b82" translate="yes" xml:space="preserve">
          <source>These can all be disabled with</source>
          <target state="translated">这些都可以通过</target>
        </trans-unit>
        <trans-unit id="e41fb2d0ecca05f4e2a4a44f51aab35f28ed5c33" translate="yes" xml:space="preserve">
          <source>These can be combined into a single regexp with a three-way alternation:</source>
          <target state="translated">这些都可以组合成一个三向交替的regexp。</target>
        </trans-unit>
        <trans-unit id="70b66993a553be0939fc1c087fcb0c54c5cdbbb0" translate="yes" xml:space="preserve">
          <source>These cases below violate the &quot;remainder has the sign of the second of the two arguments&quot;, since they wouldn't match up otherwise.</source>
          <target state="translated">下面这些情况违反了 &quot;余者有二辩之征&quot;,因为不这样做就对不上号。</target>
        </trans-unit>
        <trans-unit id="1fd6f63888a958514d8ebfc5074b3f479f8a49f9" translate="yes" xml:space="preserve">
          <source>These classes correspond in the obvious way to the underlying C structures of similar names. The inheritance hierarchy mimics the underlying C &quot;inheritance&quot;:</source>
          <target state="translated">这些类以明显的方式对应于名称相似的底层C结构。继承层次结构模仿了底层C语言的 &quot;继承&quot;。</target>
        </trans-unit>
        <trans-unit id="5f11a03556aad53a0a7bc63133f793375ad1dc66" translate="yes" xml:space="preserve">
          <source>These code blocks can be prefixed with &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; to give the appearance of a subroutine (although this is not considered good style). One should note that these code blocks don't really exist as named subroutines (despite their appearance). The thing that gives this away is the fact that you can have &lt;b&gt;more than one&lt;/b&gt; of these code blocks in a program, and they will get &lt;b&gt;all&lt;/b&gt; executed at the appropriate moment. So you can't execute any of these code blocks by name.</source>
          <target state="translated">这些代码块可以使用 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 前缀，以给出子例程的外观（尽管这不是很好的样式）。应该注意的是，这些代码块实际上并不是作为命名子例程存在的（尽管它们看起来很漂亮）。解决这个问题的原因是，您在程序中可以拥有&lt;b&gt;多个&lt;/b&gt;这些代码块，并且它们将在适当的时候&lt;b&gt;全部&lt;/b&gt;执行。因此，您不能按名称执行任何这些代码块。</target>
        </trans-unit>
        <trans-unit id="97b3b7dd37ba8a222332eb2984faedc72082d594" translate="yes" xml:space="preserve">
          <source>These commands take any number of arguments and investigate what is necessary to perform the action. Argument processing is as follows:</source>
          <target state="translated">这些命令接受任何数量的参数,并调查执行动作所需的内容。参数处理方法如下。</target>
        </trans-unit>
        <trans-unit id="1935b5d017d485fb4c9165c42281556d84b0d309" translate="yes" xml:space="preserve">
          <source>These compile phase keywords are documented in &lt;a href=&quot;../perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;BEGIN, UNITCHECK, CHECK, INIT and END in perlmod&lt;/a&gt;.</source>
          <target state="translated">这些编译阶段关键字记录在&lt;a href=&quot;../perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;perlmod&lt;/a&gt;中的BEGIN，UNITCHECK，CHECK，INIT和END中。</target>
        </trans-unit>
        <trans-unit id="d7f96e99d050cd5ba24ce3555c69d5626ea1ddfe" translate="yes" xml:space="preserve">
          <source>These compile phase keywords are documented in &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;BEGIN, UNITCHECK, CHECK, INIT and END in perlmod&lt;/a&gt;.</source>
          <target state="translated">这些编译阶段关键字记录在&lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;perlmod&lt;/a&gt;中的BEGIN，UNITCHECK，CHECK，INIT和END中。</target>
        </trans-unit>
        <trans-unit id="97251eb9b01071889514a18b4c3f732daa85a7b2" translate="yes" xml:space="preserve">
          <source>These constants are not imported by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; by default.</source>
          <target state="translated">默认情况下， &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 不导入这些常量。</target>
        </trans-unit>
        <trans-unit id="4a9cdeb250fa9e2cb61227f4240cb75a90c2a763" translate="yes" xml:space="preserve">
          <source>These constants can also be used with fully qualified names, eg. &lt;code&gt;SDBM_File::PAGFEXT&lt;/code&gt; .</source>
          <target state="translated">这些常量也可以与完全限定的名称一起使用，例如。 &lt;code&gt;SDBM_File::PAGFEXT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b24ced089c50142be624d4fe7279d5e7e8267bf6" translate="yes" xml:space="preserve">
          <source>These conversions are governed by the following general rules:</source>
          <target state="translated">这些转换须遵守以下一般规则:</target>
        </trans-unit>
        <trans-unit id="8ebb9f4990eefbf7af18e7f37f2d673045cd0b59" translate="yes" xml:space="preserve">
          <source>These conversions are invoked according to context as necessary. For example, the subroutine for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; (stringify) may be used where the overloaded object is passed as an argument to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, and that for &lt;code&gt;'bool'&lt;/code&gt; where it is tested in the condition of a flow control statement (like &lt;code&gt;while&lt;/code&gt; ) or the ternary &lt;code&gt;?:&lt;/code&gt; operation.</source>
          <target state="translated">根据需要根据上下文调用这些转换。例如，在将重载对象作为 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 的参数传递时，可以使用 &lt;code&gt;'&quot;&quot;'&lt;/code&gt; （stringify）的子例程，而对于 &lt;code&gt;'bool'&lt;/code&gt; 的子例程可以在流控制语句（如 &lt;code&gt;while&lt;/code&gt; ）的条件下进行测试时使用。或三元 &lt;code&gt;?:&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="a40ed2255002784d89744404c25a8dfb75189849" translate="yes" xml:space="preserve">
          <source>These correspond (loosely) to fgetpos() and fsetpos(). Rather than stdio's Fpos_t they expect a &quot;Perl Scalar Value&quot; to be passed. What is stored there should be considered opaque. The layout of the data may vary from handle to handle. When not using stdio or if platform does not have the stdio calls then they are implemented in terms of PerlIO_tell() and PerlIO_seek().</source>
          <target state="translated">这些函数与 fgetpos()和 fsetpos()相对应 (宽泛地).它们不是 stdio 的 Fpos_t,而是期望传递 &quot;Perl Scalar Value&quot;.它们期望传递的是一个 &quot;Perl Scalar Value&quot;,而不是stdio的Fpos_t。那里存储的内容应该被认为是不透明的。数据的布局可能因句柄而异。当不使用stdio或如果平台没有stdio调用,那么它们是用PerlIO_tell()和PerlIO_seek()来实现的。</target>
        </trans-unit>
        <trans-unit id="3ab9bc2795a0ea30e5174b44302c5f3390695af2" translate="yes" xml:space="preserve">
          <source>These correspond functionally to fread() and fwrite() but the arguments and return values are different. The PerlIO_read() and PerlIO_write() signatures have been modeled on the more sane low level read() and write() functions instead: The &quot;file&quot; argument is passed first, there is only one &quot;count&quot;, and the return value can distinguish between error and &lt;code&gt;EOF&lt;/code&gt; .</source>
          <target state="translated">这些在功能上对应于fread（）和fwrite（），但参数和返回值不同。PerlIO_read（）和PerlIO_write（）签名已在更合理的低级read（）和write（）函数上建模：相反，首先传递&amp;ldquo; file&amp;rdquo;参数，只有一个&amp;ldquo; count&amp;rdquo;，并且返回值可以区分错误和 &lt;code&gt;EOF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6faed5a4522cd8b94dc864e27b779abb63c4ce78" translate="yes" xml:space="preserve">
          <source>These correspond to fopen()/fdopen() and the arguments are the same. Return &lt;code&gt;NULL&lt;/code&gt; and set &lt;code&gt;errno&lt;/code&gt; if there is an error. There may be an implementation limit on the number of open handles, which may be lower than the limit on the number of open files - &lt;code&gt;errno&lt;/code&gt; may not be set when &lt;code&gt;NULL&lt;/code&gt; is returned if this limit is exceeded.</source>
          <target state="translated">这些对应于fopen（）/ fdopen（），并且参数相同。返回 &lt;code&gt;NULL&lt;/code&gt; 并在出现错误时设置 &lt;code&gt;errno&lt;/code&gt; 。可能有一个打开句柄的实现限制，它可能低于打开文件数的限制- 如果超出此限制，则在返回 &lt;code&gt;NULL&lt;/code&gt; 时可能不会设置 &lt;code&gt;errno&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85c39d61ce18e7b09b1791e93aa8066eeef62084" translate="yes" xml:space="preserve">
          <source>These correspond to fputs() and fputc(). Note that arguments have been revised to have &quot;file&quot; first.</source>
          <target state="translated">这些对应于fputs()和fputc()。请注意,参数已被修改为先有 &quot;file&quot;。</target>
        </trans-unit>
        <trans-unit id="8e90caae28ef06f86a5a7c45f8c354bdfbb310ff" translate="yes" xml:space="preserve">
          <source>These defaults may change once perlio has been better tested and tuned.</source>
          <target state="translated">一旦perlio得到更好的测试和调整,这些默认值可能会改变。</target>
        </trans-unit>
        <trans-unit id="4b42ed96c36dd8480d16597a1b739ba48b433615" translate="yes" xml:space="preserve">
          <source>These directories get the man pages at 'make install' time if INSTALLDIRS=perl. Defaults to $Config{installman*dir}.</source>
          <target state="translated">如果INSTALLDIRS=perl,这些目录会在'make install'时获取man页面。默认为$Config{installman*dir}。</target>
        </trans-unit>
        <trans-unit id="80d2a82fca268aa8c538c7ef08b93ac2b88facef" translate="yes" xml:space="preserve">
          <source>These directories get the man pages at 'make install' time if INSTALLDIRS=site (default). Defaults to $(SITEPREFIX)/man/man$(MAN*EXT).</source>
          <target state="translated">如果INSTALLDIRS=site(默认),这些目录会在'make install'时获取man页面。默认为$(SITEPREFIX)/man/man$(MAN*EXT)。</target>
        </trans-unit>
        <trans-unit id="68e3f1b03dd4e2ce3d50494f40f9bb4bc33a9ff9" translate="yes" xml:space="preserve">
          <source>These directories get the man pages at 'make install' time if INSTALLDIRS=vendor. Defaults to $(VENDORPREFIX)/man/man$(MAN*EXT).</source>
          <target state="translated">如果INSTALLDIRS=vendor,这些目录会在 &quot;make install &quot;时获得man页面。默认为$(VENDORPREFIX)/man/man$(MAN*EXT)。</target>
        </trans-unit>
        <trans-unit id="40c3a72856e79ae11ef7788be093b884c47b09d5" translate="yes" xml:space="preserve">
          <source>These examples are realized in the code below, which could be copied to a file</source>
          <target state="translated">这些例子是在下面的代码中实现的,可以复制到一个文件中去</target>
        </trans-unit>
        <trans-unit id="ea1d8aa8b62f74ea36ff39b0b63b9774953aaca0" translate="yes" xml:space="preserve">
          <source>These examples of attempts to use an ellipsis are syntax errors:</source>
          <target state="translated">这些尝试使用省略号的例子是语法错误。</target>
        </trans-unit>
        <trans-unit id="ad269ea05e73affc724a0326dc3ecea88836b454" translate="yes" xml:space="preserve">
          <source>These examples often reflect the style and preference of the author of that piece of the documentation, and may be briefer than a corresponding line of code in a real program. Except where otherwise noted, you should assume that &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; statements appear earlier in the &quot;program&quot;, and that any variables used have already been declared, even if those declarations have been omitted to make the example easier to read.</source>
          <target state="translated">这些示例通常反映了该文档作者的风格和偏好，并且可能比实际程序中的相应代码行简短。除非另有说明，否则您应假定 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 语句出现在&amp;ldquo;程序&amp;rdquo;的前面，并且已声明了所使用的任何变量，即使已省略这些声明以使示例易于阅读。</target>
        </trans-unit>
        <trans-unit id="da4181b23484c1b0366a0256854a440c5eed9952" translate="yes" xml:space="preserve">
          <source>These examples show how to make references to variables with names. Sometimes you want to make an array or a hash that doesn't have a name. This is analogous to the way you like to be able to use the string &lt;code&gt;&quot;\n&quot;&lt;/code&gt; or the number 80 without having to store it in a named variable first.</source>
          <target state="translated">这些示例说明如何使用名称引用变量。有时您想要创建一个没有名称的数组或哈希。这类似于您希望能够使用字符串 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 或数字80而不必先将其存储在命名变量中的方式。</target>
        </trans-unit>
        <trans-unit id="7900d790c497c44a25852d75caed60efb96bb183" translate="yes" xml:space="preserve">
          <source>These features are no longer considered experimental and their functionality has disappeared. It's your own fault if you wrote production programs using these features after we explicitly told you not to (see &lt;a href=&quot;perlpolicy&quot;&gt;perlpolicy&lt;/a&gt;).</source>
          <target state="translated">这些功能不再被视为实验性功能，它们的功能已消失。如果在我们明确告诉您不要使用这些功能后编写生产程序，这是您自己的错（请参见&lt;a href=&quot;perlpolicy&quot;&gt;perlpolicy&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ecdbc29b6059151fd36541ed2cea90e388fc6071" translate="yes" xml:space="preserve">
          <source>These features were so wildly successful and played so well with others that we decided to remove their experimental status and admit them as full, stable features in the world of Perl, lavishing all the benefits and luxuries thereof. They are also awarded +5 Stability and +3 Charisma.</source>
          <target state="translated">这些特性非常成功,而且与其他特性玩得很好,所以我们决定取消它们的实验性地位,并将其作为 Perl 世界中完整、稳定的特性,并赋予其所有的好处和奢侈品。它们还被授予+5稳定性和+3魅力。</target>
        </trans-unit>
        <trans-unit id="436079f5f30dfc97a1a6d7f8ea9906fefeca2983" translate="yes" xml:space="preserve">
          <source>These fields are used to keep track of how many paren groups could be matched in the pattern, which was the last open paren to be entered, and which was the last close paren to be entered.</source>
          <target state="translated">这些字段用于跟踪模式中可以匹配多少个父母组,哪个是最后输入的开放父母,哪个是最后输入的关闭父母。</target>
        </trans-unit>
        <trans-unit id="4c8e2d7aa479f62270f36bb981c83130e3ea21ce" translate="yes" xml:space="preserve">
          <source>These files contain information on who maintains which modules. Run &lt;code&gt;perl Porting/Maintainers -M Module::Name&lt;/code&gt; to find out more information about a dual-life module.</source>
          <target state="translated">这些文件包含有关谁维护哪些模块的信息。运行 &lt;code&gt;perl Porting/Maintainers -M Module::Name&lt;/code&gt; 来查找有关双寿命模块的更多信息。</target>
        </trans-unit>
        <trans-unit id="7c3add026b4eccbc256b7dbac98ef5e6ce0ff8a8" translate="yes" xml:space="preserve">
          <source>These flags can be set during compilation to enable optimizations in the &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">可以在编译期间设置这些标志，以启用 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 运算符中的优化。</target>
        </trans-unit>
        <trans-unit id="5ad448cfc75702b92a6132746a47d8bee944a550" translate="yes" xml:space="preserve">
          <source>These flow-control keywords are documented in &lt;a href=&quot;../perlsyn#Compound-Statements&quot;&gt;Compound Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">这些流控制关键字记录&lt;a href=&quot;../perlsyn#Compound-Statements&quot;&gt;在perlsyn的Composite Statements中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f149ae07a8478e188c52361aad3ec711ed1026a" translate="yes" xml:space="preserve">
          <source>These flow-control keywords are documented in &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;Compound Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">这些流控制关键字记录&lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;在perlsyn的Composite Statements中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="309e08bc8a3175c38d05ead911b510e18b559b99" translate="yes" xml:space="preserve">
          <source>These flow-control keywords related to the experimental switch feature are documented in &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">这些与实验性开关功能相关的流量控制关键字记录&lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;在perlsyn的&amp;ldquo;开关语句&amp;rdquo;中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a272370ad05edf250f2041efdee62784d465ad39" translate="yes" xml:space="preserve">
          <source>These flow-control keywords related to the experimental switch feature are documented in &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">这些与实验性开关功能相关的流量控制关键字记录&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;在perlsyn的&amp;ldquo;开关语句&amp;rdquo;中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc4036739b5240858c0bf581399bd57e7b5e9c9e" translate="yes" xml:space="preserve">
          <source>These forms may be assigned to, and cause the right-hand side to be evaluated in scalar context:</source>
          <target state="translated">这些形式可能会被分配到,并导致右侧的标量上下文中被评估。</target>
        </trans-unit>
        <trans-unit id="b6a87abeab3fa4b07145fb59b22ed97519f70773" translate="yes" xml:space="preserve">
          <source>These free versions of Visual C++ 2008-2013 Professional contain the same compilers and linkers that ship with the full versions, and also contain everything necessary to build Perl, rather than requiring a separate download of the Windows SDK like previous versions did.</source>
          <target state="translated">这些免费版的Visual C++2008-2013 Professional包含了与完整版相同的编译器和链接器,还包含了构建Perl所需的所有内容,而不像以前的版本那样需要单独下载Windows SDK。</target>
        </trans-unit>
        <trans-unit id="efdfa79cbeb17377a5124b29f2fd31a6e8d98c48" translate="yes" xml:space="preserve">
          <source>These functions allow checksums to be merged. Refer to the</source>
          <target state="translated">这些功能允许合并校验和。请参考</target>
        </trans-unit>
        <trans-unit id="ba57dd2ab74f37811d43a497242362420e4296f0" translate="yes" xml:space="preserve">
          <source>These functions are exported only on request. They each take a single argument and return the absolute pathname for it. If no argument is given they'll use the current working directory.</source>
          <target state="translated">这些函数只有在接到请求时才会输出。它们每个函数都接受一个参数并返回绝对路径名。如果没有给定参数,它们将使用当前的工作目录。</target>
        </trans-unit>
        <trans-unit id="11a75a016614f3f6a49b489f2532217d2dc9b130" translate="yes" xml:space="preserve">
          <source>These functions are interface of character data used internally. If you want only to get Unicode normalization forms, you don't need call them yourself.</source>
          <target state="translated">这些函数是内部使用的字符数据的接口。如果你只想获得Unicode规范化形式,你不需要自己调用它们。</target>
        </trans-unit>
        <trans-unit id="a5805d5b7ed6958150825f5cb6f923e00d36788d" translate="yes" xml:space="preserve">
          <source>These functions are provided for backwards compatibility with common tempfile generation C library functions.</source>
          <target state="translated">这些函数是为了向后兼容常见的tempfile生成C库函数而提供的。</target>
        </trans-unit>
        <trans-unit id="4c85d18231511b3dd1840594c64b0cd5dd02c4fd" translate="yes" xml:space="preserve">
          <source>These functions are related to the method resolution order of perl classes</source>
          <target state="translated">这些函数与perl类的方法解析顺序有关。</target>
        </trans-unit>
        <trans-unit id="565eacfa6d391bb1e8f9b310d413202832f4d770" translate="yes" xml:space="preserve">
          <source>These functions are used by the filter to obtain either a line or block from the next filter in the chain or the actual source file if there aren't any other filters.</source>
          <target state="translated">这些函数被过滤器用于从链中的下一个过滤器或实际的源文件(如果没有任何其他过滤器)中获取行或块。</target>
        </trans-unit>
        <trans-unit id="b40856071384296779ffb96483ca0013c6d7f3df" translate="yes" xml:space="preserve">
          <source>These functions are usually used inside an &lt;code&gt;ok()&lt;/code&gt; .</source>
          <target state="translated">这些函数通常在 &lt;code&gt;ok()&lt;/code&gt; 内部使用。</target>
        </trans-unit>
        <trans-unit id="ad9ddd863a33c4087b2128f800b2bb735b670e0b" translate="yes" xml:space="preserve">
          <source>These functions control the global state of the package.</source>
          <target state="translated">这些函数控制包的全局状态。</target>
        </trans-unit>
        <trans-unit id="524d44a200305a1bdc5134c684c7bc58ebf331b8" translate="yes" xml:space="preserve">
          <source>These functions grant &lt;code&gt;&quot;SUPER&quot;&lt;/code&gt; token as a prefix of the method name. Note that if you want to keep the returned glob for a long time, you need to check for it being &quot;AUTOLOAD&quot;, since at the later time the call may load a different subroutine due to $AUTOLOAD changing its value. Use the glob created as a side effect to do this.</source>
          <target state="translated">这些函数授予 &lt;code&gt;&quot;SUPER&quot;&lt;/code&gt; 令牌作为方法名称的前缀。请注意，如果要长时间保留返回的glob，则需要检查它是否为&amp;ldquo; AUTOLOAD&amp;rdquo;，因为稍后由于$ AUTOLOAD更改其值，该调用可能会加载其他子例程。使用作为副作用创建的glob执行此操作。</target>
        </trans-unit>
        <trans-unit id="e3b1137b52cacd1fbff911e830d8d14363d490cb" translate="yes" xml:space="preserve">
          <source>These functions have the same side-effects as &lt;code&gt;gv_fetchmeth&lt;/code&gt; with &lt;code&gt;level==0&lt;/code&gt; . The warning against passing the GV returned by &lt;code&gt;gv_fetchmeth&lt;/code&gt; to &lt;code&gt;call_sv&lt;/code&gt; applies equally to these functions.</source>
          <target state="translated">这些功能与带有 &lt;code&gt;level==0&lt;/code&gt; &lt;code&gt;gv_fetchmeth&lt;/code&gt; 具有相同的副作用。禁止将 &lt;code&gt;gv_fetchmeth&lt;/code&gt; 返回的GV传递给 &lt;code&gt;call_sv&lt;/code&gt; 的警告同样适用于这些功能。</target>
        </trans-unit>
        <trans-unit id="98d4aef8dd151e8462fbb3063b8efcb68e0d87b2" translate="yes" xml:space="preserve">
          <source>These functions provide convenient and thread-safe means of manipulating hook variables.</source>
          <target state="translated">这些函数提供了方便和线程安全的方法来操作钩子变量。</target>
        </trans-unit>
        <trans-unit id="f738338a9dbfbee4b5a909220a80f41318a9f381" translate="yes" xml:space="preserve">
          <source>These functions simply print $Config{ccflags} and $Config{ccdlflags}</source>
          <target state="translated">这些函数只是简单地打印$Config{ccflags}和$Config{ccdlflags}。</target>
        </trans-unit>
        <trans-unit id="6cd020ca0f66b00dde6a2341717a3dae0fc7c828" translate="yes" xml:space="preserve">
          <source>These functions take a hash as an argument. The recognized keys of this hash are:</source>
          <target state="translated">这些函数以一个哈希值作为参数。这个哈希值的公认键是:</target>
        </trans-unit>
        <trans-unit id="d6359c7691ac9172680cb301b6768d6c5620c165" translate="yes" xml:space="preserve">
          <source>These functions take an input numeric code point in one encoding and return what its equivalent value is in the other.</source>
          <target state="translated">这些函数以一种编码方式接收一个输入的数字码点,并以另一种编码方式返回其等值。</target>
        </trans-unit>
        <trans-unit id="7ebb5ef7a942f7d31cebfd11f8de6228de926c64" translate="yes" xml:space="preserve">
          <source>These hooks are also permitted to set the %INC entry corresponding to the files they have loaded. See &lt;a href=&quot;../perlvar#%25INC&quot;&gt;%INC in perlvar&lt;/a&gt;.</source>
          <target state="translated">还允许这些挂钩设置与其已加载文件相对应的％INC条目。请参见&lt;a href=&quot;../perlvar#%25INC&quot;&gt;perlvar中的％INC&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dcbca2e2db6c0375d3253e7898e5f5abc5deaab1" translate="yes" xml:space="preserve">
          <source>These hooks are also permitted to set the %INC entry corresponding to the files they have loaded. See &lt;a href=&quot;perlvar#%25INC&quot;&gt;%INC in perlvar&lt;/a&gt;.</source>
          <target state="translated">还允许这些挂钩设置与其已加载文件相对应的％INC条目。请参见&lt;a href=&quot;perlvar#%25INC&quot;&gt;perlvar中的％INC&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ab8134e6c8ea614a58bbf4cba85fe875f47ac40" translate="yes" xml:space="preserve">
          <source>These interfaces are only available in Perl 5.9.5 and higher. See &lt;a href=&quot;http://search.cpan.org/perldoc/MRO::Compat&quot;&gt;MRO::Compat&lt;/a&gt; on CPAN for a mostly forwards compatible implementation for older Perls.</source>
          <target state="translated">这些接口仅在Perl 5.9.5及更高版本中可用。请参阅CPAN上的&lt;a href=&quot;http://search.cpan.org/perldoc/MRO::Compat&quot;&gt;MRO :: Compat&lt;/a&gt;，以了解较旧的Perls的大多数向前兼容的实现。</target>
        </trans-unit>
        <trans-unit id="800024eb93ec8e2e1c9e19ed6e58201379d4f5ea" translate="yes" xml:space="preserve">
          <source>These items are the primitives used to perform indenting, and to select text from amongst alternatives.</source>
          <target state="translated">这些项目是用于执行缩进和从其他选项中选择文本的基元。</target>
        </trans-unit>
        <trans-unit id="3dfe7afbcdb97590e1c6c0085eefd647c7035d88" translate="yes" xml:space="preserve">
          <source>These keys will be populated before any exceptions are thrown should there be an error.</source>
          <target state="translated">这些键将在任何异常抛出之前被填充,如果有错误的话。</target>
        </trans-unit>
        <trans-unit id="a901d1a803d1f1e84cb86c073bdbaefe49dcbe0f" translate="yes" xml:space="preserve">
          <source>These keywords are documented in &lt;a href=&quot;../perldata#Special-Literals&quot;&gt;Special Literals in perldata&lt;/a&gt;.</source>
          <target state="translated">这些关键字记录&lt;a href=&quot;../perldata#Special-Literals&quot;&gt;在perldata的特殊文字中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1500951fb5f2dd9eeebd6c439509f1ad3f36d4ce" translate="yes" xml:space="preserve">
          <source>These keywords are documented in &lt;a href=&quot;perldata#Special-Literals&quot;&gt;Special Literals in perldata&lt;/a&gt;.</source>
          <target state="translated">这些关键字记录&lt;a href=&quot;perldata#Special-Literals&quot;&gt;在perldata的特殊文字中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="017f89666b16c462ff4b71931d55ca635d0ecaed" translate="yes" xml:space="preserve">
          <source>These last two are only valid for pad name SVs. They only existed in the B::NV class before Perl 5.22. In 5.22 they were moved to the B::PADNAME class.</source>
          <target state="translated">后面这两个只对垫名SV有效。在 Perl 5.22 之前,它们只存在于 B::NV 类中。在 5.22 中,它们被移到了 B::PADNAME 类中。</target>
        </trans-unit>
        <trans-unit id="ee3476aee9a9c9d8b18c6d57ac8c385c0348f0d4" translate="yes" xml:space="preserve">
          <source>These look just like character names but return multiple codepoints. Notice the &lt;code&gt;%vx&lt;/code&gt; vector-print functionality in &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些看起来像字符名称，但返回多个代码点。注意 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 中的 &lt;code&gt;%vx&lt;/code&gt; vector-print功能。</target>
        </trans-unit>
        <trans-unit id="e76a83f91dda3c78158f07c2bcf605e73e782739" translate="yes" xml:space="preserve">
          <source>These loop ops are not included in :base_core because they can easily be used to implement a resource attack (e.g., consume all available CPU time).</source>
          <target state="translated">这些循环操作没有包含在:base_core中,因为它们很容易被用来实现资源攻击(例如,消耗所有可用的CPU时间)。</target>
        </trans-unit>
        <trans-unit id="a843eb74986a4e9f839472d2d8d150ea39980b05" translate="yes" xml:space="preserve">
          <source>These macros arrange things to restore the value of integer variable &lt;code&gt;i&lt;/code&gt; at the end of enclosing</source>
          <target state="translated">这些宏安排在结束时恢复整数变量 &lt;code&gt;i&lt;/code&gt; 的值的事情</target>
        </trans-unit>
        <trans-unit id="f7a2a9aebcff3586f69f55801776cb23fd4e90a9" translate="yes" xml:space="preserve">
          <source>These macros arrange things to restore the value of pointers &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; must be a pointer of a type which survives conversion to &lt;code&gt;SV*&lt;/code&gt; and back, &lt;code&gt;p&lt;/code&gt; should be able to survive conversion to &lt;code&gt;char*&lt;/code&gt; and back.</source>
          <target state="translated">这些宏安排了恢复指针 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt; 的值的事情。 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 必须是能够在转换成 &lt;code&gt;SV*&lt;/code&gt; 后返回的类型的指针， &lt;code&gt;p&lt;/code&gt; 应该能够在转换成 &lt;code&gt;char*&lt;/code&gt; 后返回的类型。</target>
        </trans-unit>
        <trans-unit id="593dfba1d3d328349b77f1588cf82c2aaffa0443" translate="yes" xml:space="preserve">
          <source>These may not necessarily cause trouble, but indicate mediocre style.</source>
          <target state="translated">这些未必会引起麻烦,但说明作风平平。</target>
        </trans-unit>
        <trans-unit id="e22b64582fc85ac43b9e96c24337a10a450121a5" translate="yes" xml:space="preserve">
          <source>These memory related ops are not included in :base_core because they can easily be used to implement a resource attack (e.g., consume all available memory).</source>
          <target state="translated">这些与内存相关的操作没有包含在:base_core中,因为它们很容易被用来实现资源攻击(例如,消耗所有可用内存)。</target>
        </trans-unit>
        <trans-unit id="77c1bb576863e90102788a1b3ffe564db0c5c144" translate="yes" xml:space="preserve">
          <source>These messages are classified as follows (listed in increasing order of desperation):</source>
          <target state="translated">这些信息分类如下(按绝望程度增加的顺序排列):</target>
        </trans-unit>
        <trans-unit id="b0bb74426f2aa2733dbc5c5a86f08523cab5f25f" translate="yes" xml:space="preserve">
          <source>These messages may safely be ignored. (Note that for a SunOS4 system, you must use -B/bin/ instead.)</source>
          <target state="translated">这些信息可以被忽略。(注意,对于SunOS4系统,你必须使用-B/bin/来代替。)</target>
        </trans-unit>
        <trans-unit id="5b9f0b892cf28755d89fe7944f868ad5bf940e68" translate="yes" xml:space="preserve">
          <source>These methods all apply to the Ptr type for the structure; additionally two methods are constructed for the structure type itself, &lt;code&gt;_to_ptr&lt;/code&gt; which returns a Ptr type pointing to the same structure, and a &lt;code&gt;new&lt;/code&gt; method to construct and return a new structure, initialised to zeroes.</source>
          <target state="translated">这些方法都适用于结构的Ptr类型。另外，针对结构类型本身构造了两种方法， &lt;code&gt;_to_ptr&lt;/code&gt; 返回指向相同结构的Ptr类型，以及构造和返回初始化为零的新结构的 &lt;code&gt;new&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="833ac724c3c333f81488114a18e12c4a9e975d1a" translate="yes" xml:space="preserve">
          <source>These methods all test the BigInt for being one specific value and return true or false depending on the input. These are faster than doing something like:</source>
          <target state="translated">这些方法都测试BigInt是否是一个特定的值,并根据输入返回true或false。这些方法比做类似的事情要快。</target>
        </trans-unit>
        <trans-unit id="92da9e899f4e8b0a6a719a6370a299d62ec6b1c8" translate="yes" xml:space="preserve">
          <source>These methods are for setting up tests and declaring how many there are. You usually only want to call one of these methods.</source>
          <target state="translated">这些方法用于设置测试和声明有多少测试。你通常只想调用其中的一个方法。</target>
        </trans-unit>
        <trans-unit id="9725043aadb2020c60801a841d8cbbe42a310c40" translate="yes" xml:space="preserve">
          <source>These methods are not intended to be called by the user, but used or over-ridden by a sub-class of &lt;code&gt;Net::Cmd&lt;/code&gt;</source>
          <target state="translated">这些方法不是要由用户调用的，而是由 &lt;code&gt;Net::Cmd&lt;/code&gt; 的子类使用或覆盖的</target>
        </trans-unit>
        <trans-unit id="c96be7d81aefe7494626f31fbf2d601d47ed4e3e" translate="yes" xml:space="preserve">
          <source>These methods are only testing the sign, and not the value.</source>
          <target state="translated">这些方法只是测试符号,而不是测试数值。</target>
        </trans-unit>
        <trans-unit id="f55156f755c79786d47317ca2de0a12228b5b4b7" translate="yes" xml:space="preserve">
          <source>These methods are useful when writing your own test methods.</source>
          <target state="translated">这些方法在编写自己的测试方法时很有用。</target>
        </trans-unit>
        <trans-unit id="1371312bc20ca6b06acc065c53943c266c38f79b" translate="yes" xml:space="preserve">
          <source>These methods control where Test::Builder will print its output. They take either an open &lt;code&gt;$filehandle&lt;/code&gt; , a &lt;code&gt;$filename&lt;/code&gt; to open and write to or a &lt;code&gt;$scalar&lt;/code&gt; reference to append to. It will always return a &lt;code&gt;$filehandle&lt;/code&gt; .</source>
          <target state="translated">这些方法控制Test :: Builder将在何处打印其输出。他们使用一个打开的 &lt;code&gt;$filehandle&lt;/code&gt; ，一个打开并写入的 &lt;code&gt;$filename&lt;/code&gt; 或一个附加的 &lt;code&gt;$scalar&lt;/code&gt; 引用。它将始终返回 &lt;code&gt;$filehandle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dabfc6c3e23d636029050966dc499c5c862fee9" translate="yes" xml:space="preserve">
          <source>These methods get the values of similarly named fields within the OP data structure. See top of &lt;code&gt;op.h&lt;/code&gt; for more info.</source>
          <target state="translated">这些方法获取OP数据结构中名称相似的字段的值。有关更多信息，请参见 &lt;code&gt;op.h&lt;/code&gt; 的顶部。</target>
        </trans-unit>
        <trans-unit id="eac0ba268e5d0e742f5c1a8121218a2683f22449" translate="yes" xml:space="preserve">
          <source>These methods guarantee fast individual tests but require a re-organization of the original list or array. They only pay off if you have to test multiple values against the same array.</source>
          <target state="translated">这些方法保证了快速的单个测试,但需要重新组织原始列表或数组。只有当你必须针对同一个数组测试多个值时,它们才会有回报。</target>
        </trans-unit>
        <trans-unit id="7cb3b559e380c719f80028fb428c3eb720e12704" translate="yes" xml:space="preserve">
          <source>These methods install a transparent filter on the I/O stream that converts data from the specified encoding when it is read in from the stream. The result is always Unicode.</source>
          <target state="translated">这些方法在I/O流上安装了一个透明的过滤器,当数据从流中读入时,它会从指定的编码中转换数据。其结果总是Unicode。</target>
        </trans-unit>
        <trans-unit id="2d0828193002db36233bc401e0a0e9c0dbb462a1" translate="yes" xml:space="preserve">
          <source>These methods provide a user interface to the &lt;code&gt;Net::Cmd&lt;/code&gt; object.</source>
          <target state="translated">这些方法为 &lt;code&gt;Net::Cmd&lt;/code&gt; 对象提供了一个用户界面。</target>
        </trans-unit>
        <trans-unit id="ff435d938391d9561763fbcab2d9f747b7f84a93" translate="yes" xml:space="preserve">
          <source>These methods set the size (in half-points, like 52 for 26-point) that these heading levels will appear as.</source>
          <target state="translated">这些方法设置了这些标题级别的大小(以半点为单位,如52为26点)。</target>
        </trans-unit>
        <trans-unit id="abcc7bd5fdde6b4a0c109a19d7071ed04915f8b9" translate="yes" xml:space="preserve">
          <source>These methods use commands that are not part of the RFC977 documentation. Some servers may not support all of them.</source>
          <target state="translated">这些方法使用的命令不属于RFC977文档的一部分。有些服务器可能不支持所有这些方法。</target>
        </trans-unit>
        <trans-unit id="31ccd9bd046a9504a4b8ad4115c9067507a8e143" translate="yes" xml:space="preserve">
          <source>These modes are all actually set via a bitmask. Here is how the &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; constants are laid out. You can import the &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; constants via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(:fallbacks)&lt;/code&gt; , and you can import the generic bitmask constants via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(:fallback_all)&lt;/code&gt; .</source>
          <target state="translated">这些模式实际上都是通过位掩码设置的。这是 &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; 常量的布局方式。您可以导入 &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; 通过常量 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(:fallbacks)&lt;/code&gt; ，并可以通过导入通用掩码常量 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(:fallback_all)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d789a994adbfeec56de6cff1edba3230c60ae5bf" translate="yes" xml:space="preserve">
          <source>These modifiers are restored at the end of the enclosing group. For example,</source>
          <target state="translated">这些修饰符在包围组的末尾被还原。例如:</target>
        </trans-unit>
        <trans-unit id="4b50f0d55e6d3bcc6eb1ad193029b6cf71ad0ceb" translate="yes" xml:space="preserve">
          <source>These modifiers do not carry over into named subpatterns called in the enclosing group. In other words, a pattern such as &lt;code&gt;((?i)(?&amp;amp;NAME))&lt;/code&gt; does not change the case-sensitivity of the &quot;NAME&quot; pattern.</source>
          <target state="translated">这些修饰符不会保留到在封闭组中调用的命名子模式中。换句话说，诸如 &lt;code&gt;((?i)(?&amp;amp;NAME))&lt;/code&gt; 之类的模式不会改变&amp;ldquo; NAME&amp;rdquo;模式的区分大小写。</target>
        </trans-unit>
        <trans-unit id="f5fbd761faf543e63a6416a5e28a730d54795855" translate="yes" xml:space="preserve">
          <source>These modifiers, all new in 5.14, affect which character-set rules (Unicode, etc.) are used, as described below in &lt;a href=&quot;#Character-set-modifiers&quot;&gt;Character set modifiers&lt;/a&gt;.</source>
          <target state="translated">这些修饰符是5.14中的新功能，它们会影响使用哪些字符集规则（Unicode等），如下面的&amp;ldquo; &lt;a href=&quot;#Character-set-modifiers&quot;&gt;字符集修饰符&amp;rdquo;中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb9708d2ade8d02334095230804c31cb6c6f062f" translate="yes" xml:space="preserve">
          <source>These names are case-insensitive. By default (if specification is omitted), 'shifted' is adopted.</source>
          <target state="translated">这些名称是不区分大小写的。默认情况下(如果省略了规格),采用'shifted'。</target>
        </trans-unit>
        <trans-unit id="a2a7bae57c0b7e47324c6368dda30c35ad91dca7" translate="yes" xml:space="preserve">
          <source>These notices must be retained in any copies of any part of this documentation and/or software.</source>
          <target state="translated">本文档和/或软件的任何部分的任何副本都必须保留这些声明。</target>
        </trans-unit>
        <trans-unit id="efbc4f1ae4d272c0d4681905f6fb23798e4783eb" translate="yes" xml:space="preserve">
          <source>These numbers was achieved Apr 2004 with ActivePerl-5.8.3 running under Linux on a P4 2.8 GHz CPU. The last 5 entries differ by being pure perl implementations of the algorithms, which explains why they are so slow.</source>
          <target state="translated">这些数字是在2004年4月用ActivePerl-5.8.3在Linux下的P4 2.8 GHz CPU上实现的。最后5个条目的不同之处在于它们是纯perl算法的实现,这也解释了为什么它们会这么慢。</target>
        </trans-unit>
        <trans-unit id="b16394db34a86c1309e6f32038763254bbfec1e7" translate="yes" xml:space="preserve">
          <source>These operators are documented in &lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">这些运算符以&lt;a href=&quot;../perlop&quot;&gt;perlop格式记录&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="902ffcf3ea51513d56fbec3ce0266f1b87291429" translate="yes" xml:space="preserve">
          <source>These operators are documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">这些运算符以&lt;a href=&quot;perlop&quot;&gt;perlop格式记录&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23835ab35bd3941ef690822a20797ba91ee28d2e" translate="yes" xml:space="preserve">
          <source>These operators are exempt from the &quot;looks like a function rule&quot; described above. That is, an opening parenthesis after the operator does not affect how much of the following code constitutes the argument. Put the opening parentheses before the operator to separate it from code that follows (this applies only to operators with higher precedence than unary operators, of course):</source>
          <target state="translated">这些运算符不受上面描述的 &quot;看起来像函数规则 &quot;的影响。也就是说,运算符后的开头括号并不影响下面的代码构成参数的多少。在运算符前加上开头的小括号,以将其与后面的代码分开(当然,这只适用于优先级高于单数运算符的运算符)。</target>
        </trans-unit>
        <trans-unit id="6b54b9bb627d1cf1404f3b5dab668ec8269f4aa6" translate="yes" xml:space="preserve">
          <source>These operators obtain the information described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, if you have the privileges necessary to retrieve the named user's UAF information via &lt;code&gt;sys$getuai&lt;/code&gt; . If not, then only the &lt;code&gt;$name&lt;/code&gt; , &lt;code&gt;$uid&lt;/code&gt; , and &lt;code&gt;$gid&lt;/code&gt; items are returned. The &lt;code&gt;$dir&lt;/code&gt; item contains the login directory in VMS syntax, while the &lt;code&gt;$comment&lt;/code&gt; item contains the login directory in Unix syntax. The &lt;code&gt;$gcos&lt;/code&gt; item contains the owner field from the UAF record. The &lt;code&gt;$quota&lt;/code&gt; item is not used.</source>
          <target state="translated">如果您具有通过 &lt;code&gt;sys$getuai&lt;/code&gt; 检索指定用户的UAF信息所必需的特权，则这些运算符将获得&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;描述的信息。如果不是，则仅返回 &lt;code&gt;$name&lt;/code&gt; ， &lt;code&gt;$uid&lt;/code&gt; 和 &lt;code&gt;$gid&lt;/code&gt; 项。在 &lt;code&gt;$dir&lt;/code&gt; 项包含在VMS语法登录目录，而 &lt;code&gt;$comment&lt;/code&gt; 项目包含在Unix中的语法登录目录。在 &lt;code&gt;$gcos&lt;/code&gt; 项目包含从UAF记录的所有者字段。在 &lt;code&gt;$quota&lt;/code&gt; 项不被使用。</target>
        </trans-unit>
        <trans-unit id="e7e657656c9789c3619d255f79ac9b3a6c835215" translate="yes" xml:space="preserve">
          <source>These ops are not included in :base_core because of the risk of them being used to generate floating point exceptions (which would have to be caught using a $SIG{FPE} handler).</source>
          <target state="translated">这些操作没有被包含在 :base_core 中,因为它们有可能被用来产生浮点异常(必须使用 $SIG{FPE}处理程序来捕获)。</target>
        </trans-unit>
        <trans-unit id="d5ea0da5f8ce978d8d492f686d44331bb4fc3946" translate="yes" xml:space="preserve">
          <source>These ops are not included in :base_core because they have an effect beyond the scope of the compartment.</source>
          <target state="translated">这些操作不包含在:base_core中,因为它们的效果超出了隔间的范围。</target>
        </trans-unit>
        <trans-unit id="dc4dfb8577c0955249e95ba26e17b894dbf4b7a2" translate="yes" xml:space="preserve">
          <source>These ops are related to multi-threading.</source>
          <target state="translated">这些操作与多线程有关。</target>
        </trans-unit>
        <trans-unit id="2901e27ec7bca28af121ed51d6417c782431820f" translate="yes" xml:space="preserve">
          <source>These ops enable</source>
          <target state="translated">这些操作使</target>
        </trans-unit>
        <trans-unit id="e55c6aacfd2933ba2a5d8d99593dbebe1787988f" translate="yes" xml:space="preserve">
          <source>These options affect which handler will be used for subsequently installed signals.</source>
          <target state="translated">这些选项会影响后续安装的信号将使用哪个处理程序。</target>
        </trans-unit>
        <trans-unit id="29c586cad3979b967f1d8c83a031669d4e85f7d5" translate="yes" xml:space="preserve">
          <source>These options control the 'vertical display' of opcodes. The display 'order' is also called 'mode' elsewhere in this document.</source>
          <target state="translated">这些选项控制操作码的 &quot;垂直显示&quot;。显示 &quot;顺序 &quot;在本文档其他地方也称为 &quot;模式&quot;。</target>
        </trans-unit>
        <trans-unit id="b5693ca212dce09ab36fc48e6272f7336e49446b" translate="yes" xml:space="preserve">
          <source>These options select the line-style (or just style) used to render each opcode, and dictates what info is actually printed into each line.</source>
          <target state="translated">这些选项选择了用于渲染每个操作码的行样式(或仅仅是样式),并决定了哪些信息被实际打印到每一行。</target>
        </trans-unit>
        <trans-unit id="822ae20d8832a94dbc806795384f0c1cb46d5024" translate="yes" xml:space="preserve">
          <source>These packages can all be downloaded by searching in the Download Center at &lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;. (Providing exact links to these packages has proven a pointless task because the links keep on changing so often.)</source>
          <target state="translated">通过在&lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;的下载中心中搜索，可以全部下载这些软件包。（事实证明，提供与这些软件包的确切链接是毫无意义的，因为链接经常更改。）</target>
        </trans-unit>
        <trans-unit id="e00985d023d49949f9c18d4b6917b5fcc1fe8b04" translate="yes" xml:space="preserve">
          <source>These packages can be downloaded by searching in the Download Center at &lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;. (Providing exact links to these packages has proven a pointless task because the links keep on changing so often.)</source>
          <target state="translated">可以在&lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=zh_cn&lt;/a&gt;下载中心中搜索来下载这些软件包。（事实证明，提供与这些软件包的确切链接是毫无意义的，因为链接经常更改。）</target>
        </trans-unit>
        <trans-unit id="ee6b901a4b16ea8fd5c1a17b0f5f523262d0ae63" translate="yes" xml:space="preserve">
          <source>These packages can both be downloaded by searching in the Download Center at &lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;. (Providing exact links to these packages has proven a pointless task because the links keep on changing so often.)</source>
          <target state="translated">通过在&lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;的下载中心中搜索，可以下载这些软件包。（事实证明，提供与这些软件包的确切链接是毫无意义的，因为链接经常更改。）</target>
        </trans-unit>
        <trans-unit id="b0b087e3db9d0ec8ccf2941b80cf3aaf473d4556" translate="yes" xml:space="preserve">
          <source>These perl routines currently (as of Perl v.5.8.6) cannot handle passed inf.</source>
          <target state="translated">目前这些perl例程(在Perl v.5.8.6中)不能处理通过的inf。</target>
        </trans-unit>
        <trans-unit id="5ee158f8c062eca4d28a3ec2d9f8d880c70ecea2" translate="yes" xml:space="preserve">
          <source>These possessive quantifiers represent a special case of a more general concept, the</source>
          <target state="translated">这些占有式定语代表了一个更一般的概念的特殊情况,也就是所谓的 &quot;占有式定语&quot;。</target>
        </trans-unit>
        <trans-unit id="bfd6c7d2c77daf624f0f4dda10d349c1b00557da" translate="yes" xml:space="preserve">
          <source>These properties are &lt;code&gt;\b&lt;/code&gt; (without braces), &lt;code&gt;\B&lt;/code&gt; (without braces), &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\W&lt;/code&gt; , and all the Posix character classes</source>
          <target state="translated">这些属性是 &lt;code&gt;\b&lt;/code&gt; （不带花括号）， &lt;code&gt;\B&lt;/code&gt; （不带花括号）， &lt;code&gt;\s&lt;/code&gt; ， &lt;code&gt;\S&lt;/code&gt; ， &lt;code&gt;\w&lt;/code&gt; ， &lt;code&gt;\W&lt;/code&gt; 和所有Posix字符类</target>
        </trans-unit>
        <trans-unit id="49d4c7299af6c451da747abf6a31ed43bc6d224c" translate="yes" xml:space="preserve">
          <source>These quantifiers will try to match as much of the string as possible, while still allowing the regex to match. So we have</source>
          <target state="translated">这些量化符会尽量匹配字符串的大部分内容,同时仍允许regex匹配。所以我们有</target>
        </trans-unit>
        <trans-unit id="26153a279914ed6ae972bab9be5035c10687695d" translate="yes" xml:space="preserve">
          <source>These results are &quot;meta&quot; information about the total results of an individual test program.</source>
          <target state="translated">这些结果是关于单个测试项目总结果的 &quot;元 &quot;信息。</target>
        </trans-unit>
        <trans-unit id="2bea10980ed9e4e8701806a5267309dec8b36b3d" translate="yes" xml:space="preserve">
          <source>These results refer to individual tests which are run.</source>
          <target state="translated">这些结果是指运行的单个测试。</target>
        </trans-unit>
        <trans-unit id="f99e408a46643ae41ce4a2a5b658c331ee2d8a0f" translate="yes" xml:space="preserve">
          <source>These routines all create system-specific portability problems. As noted elsewhere, Perl is at the mercy of your C libraries for much of its system behavior. It's probably safest to assume broken SysV semantics for signals and to stick with simple TCP and UDP socket operations; e.g., don't try to pass open file descriptors over a local UDP datagram socket if you want your code to stand a chance of being portable.</source>
          <target state="translated">这些例程都会产生系统特有的可移植性问题。正如在其他地方所提到的,Perl的大部分系统行为都要听命于你的C库。可能最安全的做法是假设信号的 SysV 语义被破坏,并坚持使用简单的 TCP 和 UDP 套接字操作;例如,如果你想让你的代码有机会被移植,就不要试图通过本地 UDP 数据报套接字传递打开的文件描述符。</target>
        </trans-unit>
        <trans-unit id="7accb91a83a147e188cfdb7ea0bdeddeb0f7f3a7" translate="yes" xml:space="preserve">
          <source>These routines allow you to parse file paths into their directory, filename and suffix.</source>
          <target state="translated">这些例程允许你将文件路径解析为它们的目录、文件名和后缀。</target>
        </trans-unit>
        <trans-unit id="b2c49f2650fd89670405ec1fbc536b94e9ae8bdf" translate="yes" xml:space="preserve">
          <source>These routines are all documented in the Locale::Codes::API man page.</source>
          <target state="translated">这些例程都在Locale::Codes::API的man page里有记载。</target>
        </trans-unit>
        <trans-unit id="5bd965d62212a6eeb3c7fb76c8f854332dc29f76" translate="yes" xml:space="preserve">
          <source>These routines are quite efficient and yet are always guaranteed to agree with &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;. We manage this by caching the start times of any months we've seen before. If we know the start time of the month, we can always calculate any time within the month. The start times are calculated using a mathematical formula. Unlike other algorithms that do multiple calls to &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些例程非常有效，但始终保证与 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 一致。我们通过缓存以前见过的任何几个月的开始时间来管理此问题。如果我们知道一个月的开始时间，我们总是可以计算该月中的任何时间。使用数学公式计算开始时间。与其他算法多次调用 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 不同。</target>
        </trans-unit>
        <trans-unit id="e296b7f9a5e96b639ca1839fa4442d3f45e92709" translate="yes" xml:space="preserve">
          <source>These routines are the same as their counterparts in the system C library. In list context, the return values from the various get routines are as follows:</source>
          <target state="translated">这些例程与系统C库中的对应例程相同。在列表上下文中,各种get例程的返回值如下。</target>
        </trans-unit>
        <trans-unit id="cc1ea3e493711677c93d92be2ec1c6ec9a5ee909" translate="yes" xml:space="preserve">
          <source>These routines used to be called &lt;code&gt;perl_call_sv&lt;/code&gt; , etc., before Perl v5.6.0, but those names are now deprecated; macros of the same name are provided for compatibility.</source>
          <target state="translated">在Perl v5.6.0之前，这些例程以前称为 &lt;code&gt;perl_call_sv&lt;/code&gt; 等，但是现在不赞成使用这些名称。提供相同名称的宏是为了兼容。</target>
        </trans-unit>
        <trans-unit id="1fb1fb969b6c77a6565b33ce0e7b7cbfccc95cfb" translate="yes" xml:space="preserve">
          <source>These rules are complicated, but the goal is for them to do what you want (even if you don't quite understand why they are doing it). For example:</source>
          <target state="translated">这些规则很复杂,但目标是让它们做你想要的事情(即使你不太明白它们为什么要这么做)。比如说</target>
        </trans-unit>
        <trans-unit id="1c39d28608973eadb707da3830a9f4611c69ff29" translate="yes" xml:space="preserve">
          <source>These select Unicode rules. That means that in double-quotish strings, the string is always converted to UTF-8 to force a Unicode interpretation (you can &lt;code&gt;utf8::downgrade()&lt;/code&gt; afterwards to convert back to non-UTF8, if possible). In regular expression patterns, the conversion isn't done, but if the character set modifier would otherwise be &lt;code&gt;/d&lt;/code&gt;, it is changed to &lt;code&gt;/u&lt;/code&gt; .</source>
          <target state="translated">这些选择Unicode规则。这意味着在双引号字符串中，该字符串始终会转换为UTF-8以强制执行Unicode解释（如果可能的话，您可以随后将 &lt;code&gt;utf8::downgrade()&lt;/code&gt; 转换回非UTF8）。在正则表达式模式中，转换不会完成，但是如果字符集修饰符否则为 &lt;code&gt;/d&lt;/code&gt; ，则将其更改为 &lt;code&gt;/u&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c33be304d6b7f8ebe4e43f5c0dfa6aefb4009eb4" translate="yes" xml:space="preserve">
          <source>These sets of one-liners are equivalent:</source>
          <target state="translated">这几组单口相声是相当的。</target>
        </trans-unit>
        <trans-unit id="52c95446c9ca7d3ffaa7ed7da6e1f21bf02cdc2e" translate="yes" xml:space="preserve">
          <source>These settings can be overridden globally too:</source>
          <target state="translated">这些设置也可以全局覆盖。</target>
        </trans-unit>
        <trans-unit id="cbc91f3641f463359dfc31290abbc3a64d30454a" translate="yes" xml:space="preserve">
          <source>These should be familiar operations, with the exception of &lt;code&gt;av_unshift&lt;/code&gt; . This routine adds &lt;code&gt;num&lt;/code&gt; elements at the front of the array with the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value. You must then use &lt;code&gt;av_store&lt;/code&gt; (described below) to assign values to these new elements.</source>
          <target state="translated">这些应该是熟悉的操作，但 &lt;code&gt;av_unshift&lt;/code&gt; 除外。此例程在数组的前面添加了 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值的 &lt;code&gt;num&lt;/code&gt; 个元素。然后，您必须使用 &lt;code&gt;av_store&lt;/code&gt; （如下所述）为这些新元素分配值。</target>
        </trans-unit>
        <trans-unit id="8f249c892c517536f796cbacefae284ca0ae8032" translate="yes" xml:space="preserve">
          <source>These should give you an overall feel for how modules are laid out and written.</source>
          <target state="translated">这些应该能让你对模块的布局和编写有一个整体的感觉。</target>
        </trans-unit>
        <trans-unit id="9a888f57551ca71c1272e83f90d05d460b30fbf3" translate="yes" xml:space="preserve">
          <source>These signal to a formatter that if it is to hyphenate &quot;sigaction&quot; or &quot;manuscript&quot;, then it should be done as &quot;sig-</source>
          <target state="translated">这些都是给格式化者的信号,如果要连字符 &quot;sigaction &quot;或 &quot;manuscript&quot;,那么就应该用 &quot;sig-&quot;。</target>
        </trans-unit>
        <trans-unit id="a76776d9b84dd64fcd8c2f12ffb416173943a78e" translate="yes" xml:space="preserve">
          <source>These signals usually indicate a serious problem with the Perl interpreter or with your script. They are ABRT, BUS, EMT, FPE, ILL, QUIT, SEGV, SYS and TRAP.</source>
          <target state="translated">这些信号通常表示Perl解释器或你的脚本有严重的问题,它们是ABRT,BUS,EMT,FPE,ILL,QUIT,SEGV,SYS和TRAP。它们是 ABRT,BUS,EMT,FPE,ILL,QUIT,SEGV,SYS 和 TRAP。</target>
        </trans-unit>
        <trans-unit id="7ee071669b1efa68f9a3156de49d5e707921d24a" translate="yes" xml:space="preserve">
          <source>These solutions can have far-reaching effects on your system and on the way you write your CGI programs, so investigate them with care.</source>
          <target state="translated">这些解决方案可能会对你的系统和你编写CGI程序的方式产生深远的影响,所以要仔细研究它们。</target>
        </trans-unit>
        <trans-unit id="af1c9d3db11663506b814ed4474ccb898e81f0dd" translate="yes" xml:space="preserve">
          <source>These special patterns are generally of the form &lt;code&gt;(*VERB:ARG)&lt;/code&gt;. Unless otherwise stated the ARG argument is optional; in some cases, it is forbidden.</source>
          <target state="translated">这些特殊模式通常采用 &lt;code&gt;(*VERB:ARG)&lt;/code&gt; 的形式。除非另有说明，否则A​​RG参数是可选的；在某些情况下，这是禁止的。</target>
        </trans-unit>
        <trans-unit id="ae6fd84e089df12e602215034c3af5ac8fb7e11a" translate="yes" xml:space="preserve">
          <source>These special variables, like the &lt;code&gt;%+&lt;/code&gt; hash and the numbered match variables (&lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; , etc.) are dynamically scoped until the end of the enclosing block or until the next successful match, whichever comes first. (See &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;Compound Statements in perlsyn&lt;/a&gt;.)</source>
          <target state="translated">这些特殊变量（如 &lt;code&gt;%+&lt;/code&gt; 哈希和编号的匹配变量（ &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ， &lt;code&gt;$3&lt;/code&gt; 等））会动态范围化，直到封闭块结束或下一次成功匹配为止，以先到者为准。 （请参阅&lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;perlsyn中的复合语句&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="ba4f20c17b5b03a6a3deb3a04503955765039642" translate="yes" xml:space="preserve">
          <source>These strengths make it especially popular with web developers and system administrators. Mathematicians, geneticists, journalists, managers and many other people also use Perl.</source>
          <target state="translated">这些优点使它特别受到网络开发人员和系统管理员的欢迎。数学家、遗传学家、记者、经理人等也都在使用Perl。</target>
        </trans-unit>
        <trans-unit id="a952f4bd002dc5bdafb796a94c6eaa4765c9b45b" translate="yes" xml:space="preserve">
          <source>These strings do not match /\Bam\B/</source>
          <target state="translated">这些字符串与/BamB/不匹配</target>
        </trans-unit>
        <trans-unit id="2125a4453223ddc6316d0fee4d859469467def9f" translate="yes" xml:space="preserve">
          <source>These strings do not match /\b'\b/.</source>
          <target state="translated">这些字符串不符合/b'b/。</target>
        </trans-unit>
        <trans-unit id="8aa64b62307f4ac9360d6b96b7d4a2888dc9ba0f" translate="yes" xml:space="preserve">
          <source>These strings do not match /\bPerl\b/.</source>
          <target state="translated">这些字符串不符合/bPerlb/。</target>
        </trans-unit>
        <trans-unit id="1ece96fea144561ec8d240482b56438a3b8cd021" translate="yes" xml:space="preserve">
          <source>These subroutines are only visible within the block in which they are declared, and only after that declaration:</source>
          <target state="translated">这些子程序只有在它们被声明的区块中才可见,而且只有在声明之后才可见。</target>
        </trans-unit>
        <trans-unit id="5002f9badee48e82e2e716cfadae24bcbea4d597" translate="yes" xml:space="preserve">
          <source>These symbolic constants are used by the &lt;code&gt;Level&lt;/code&gt; option in the constructor.</source>
          <target state="translated">这些符号常量由构造函数中的 &lt;code&gt;Level&lt;/code&gt; 选项使用。</target>
        </trans-unit>
        <trans-unit id="de652943440f246885efed6bc50624dc94d59ab4" translate="yes" xml:space="preserve">
          <source>These symbolic constants are used by the &lt;code&gt;Method&lt;/code&gt; option in the constructor.</source>
          <target state="translated">这些符号常量由构造函数中的 &lt;code&gt;Method&lt;/code&gt; 选项使用。</target>
        </trans-unit>
        <trans-unit id="4ec9419fff6178cfe016f55595d7a90364f97f63" translate="yes" xml:space="preserve">
          <source>These symbolic constants are used by the &lt;code&gt;Strategy&lt;/code&gt; option in the constructor.</source>
          <target state="translated">这些符号常量由构造函数中的 &lt;code&gt;Strategy&lt;/code&gt; 选项使用。</target>
        </trans-unit>
        <trans-unit id="09599ebf73a41d7f3fd327344d88fceb70681aab" translate="yes" xml:space="preserve">
          <source>These symbolic constants are used by the &lt;code&gt;flush&lt;/code&gt; method.</source>
          <target state="translated">这些符号常量由 &lt;code&gt;flush&lt;/code&gt; 方法使用。</target>
        </trans-unit>
        <trans-unit id="430e03746fb928435d7aa08e0e3eea945da77d4a" translate="yes" xml:space="preserve">
          <source>These symbols appear before the op-name, and indicate the B:: namespace that represents the ops in your Perl code.</source>
          <target state="translated">这些符号出现在 op-name 之前,表示在你的 Perl 代码中代表 ops 的 B::命名空间。</target>
        </trans-unit>
        <trans-unit id="2dbd7a997bbaaa84741a5e1fbd14e323c239d540" translate="yes" xml:space="preserve">
          <source>These terms are your choice of any of (1) the Perl Artistic Licence, or (2) version 2 of the GNU General Public License as published by the Free Software Foundation, or (3) any later version of the GNU General Public License.</source>
          <target state="translated">您可以选择(1)Perl Artistic License,或(2)自由软件基金会发布的GNU通用公共许可证第2版,或(3)GNU通用公共许可证的任何更新版本。</target>
        </trans-unit>
        <trans-unit id="5c298e17caacd4174da139fecae9a62cf22ed5cc" translate="yes" xml:space="preserve">
          <source>These tests are expected to succeed. Usually, most or all of your tests are in this category. If a normal test doesn't succeed, then that means that something is</source>
          <target state="translated">这些测试有望成功。通常,你的大部分或全部测试都属于这一类。如果一个正常的测试不成功,那么就意味着有些东西是</target>
        </trans-unit>
        <trans-unit id="07325952f04a521e228140b025365f61c44af25f" translate="yes" xml:space="preserve">
          <source>These three macros are used to change a memory buffer size or to free a piece of memory no longer needed. The arguments to &lt;code&gt;Renew&lt;/code&gt; and &lt;code&gt;Renewc&lt;/code&gt; match those of &lt;code&gt;New&lt;/code&gt; and &lt;code&gt;Newc&lt;/code&gt; with the exception of not needing the &quot;magic cookie&quot; argument.</source>
          <target state="translated">这三个宏用于更改内存缓冲区大小或释放不再需要的内存。 &lt;code&gt;Renew&lt;/code&gt; 和 &lt;code&gt;Renewc&lt;/code&gt; 的参数与 &lt;code&gt;New&lt;/code&gt; 和 &lt;code&gt;Newc&lt;/code&gt; 的参数匹配，但不需要&amp;ldquo;魔术cookie&amp;rdquo;参数。</target>
        </trans-unit>
        <trans-unit id="3b6ba4dd1926405bd4af1077435f09d7c0a86a11" translate="yes" xml:space="preserve">
          <source>These three macros are used to move, copy, or zero out previously allocated memory. The &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; arguments point to the source and destination starting points. Perl will move, copy, or zero out &lt;code&gt;number&lt;/code&gt; instances of the size of the &lt;code&gt;type&lt;/code&gt; data structure (using the &lt;code&gt;sizeof&lt;/code&gt; function).</source>
          <target state="translated">这三个宏用于将先前分配的内存移出，复制或归零。该 &lt;code&gt;source&lt;/code&gt; 和 &lt;code&gt;dest&lt;/code&gt; 参数指向源和目标的起点。Perl会移动，复制，或零出 &lt;code&gt;number&lt;/code&gt; 的大小的情况下， &lt;code&gt;type&lt;/code&gt; 数据结构（使用 &lt;code&gt;sizeof&lt;/code&gt; 函数）。</target>
        </trans-unit>
        <trans-unit id="335c760b89ccd866bd4e5cd7ec4e5ef4c599cbd4" translate="yes" xml:space="preserve">
          <source>These two export tags globally modify the default flags that bsd_glob() and, except on VMS, Perl's built-in &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator use. &lt;code&gt;GLOB_NOCASE&lt;/code&gt; is turned on or off, respectively.</source>
          <target state="translated">这两个导出标记会全局修改bsd_glob（）的默认标志，并且在VMS上会修改Perl的内置 &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 运算符。 &lt;code&gt;GLOB_NOCASE&lt;/code&gt; 分别打开或关闭。</target>
        </trans-unit>
        <trans-unit id="9660fc7e9efd93a7abe465c81de57e11a5045a23" translate="yes" xml:space="preserve">
          <source>These two features are available starting with Perl 5.16.</source>
          <target state="translated">这两个功能从Perl 5.16开始就可以使用。</target>
        </trans-unit>
        <trans-unit id="fa5480402538907c3c246c95ce18885b4ae5225b" translate="yes" xml:space="preserve">
          <source>These two handles are held in the array part of the GLOB until either &lt;code&gt;reader&lt;/code&gt; or &lt;code&gt;writer&lt;/code&gt; is called.</source>
          <target state="translated">这两个句柄保存在GLOB的数组部分中，直到调用 &lt;code&gt;reader&lt;/code&gt; 或 &lt;code&gt;writer&lt;/code&gt; 器为止。</target>
        </trans-unit>
        <trans-unit id="b0f87921e5dc8828d5a6d9ea360bbab6bf450027" translate="yes" xml:space="preserve">
          <source>These two lower level macros are defined, but must only be used when dealing with keys that are not &lt;code&gt;SV*&lt;/code&gt; s:</source>
          <target state="translated">这两个较低级别的宏已定义，但是仅在处理非 &lt;code&gt;SV*&lt;/code&gt; 的键时才使用：</target>
        </trans-unit>
        <trans-unit id="4ca39330e5c20e1239e2de6584e211ecc882f376" translate="yes" xml:space="preserve">
          <source>These two methods are discussed in the section &quot;Controlling Lookup Failure&quot;.</source>
          <target state="translated">这两种方法将在 &quot;控制查找失败 &quot;一节中讨论。</target>
        </trans-unit>
        <trans-unit id="0b5a74bc9d562e1d07daa7fdb3ddf9da715c3433" translate="yes" xml:space="preserve">
          <source>These two methods return the pad names, using B::SPECIAL objects for null pointers and B::PADNAME objects otherwise.</source>
          <target state="translated">这两个方法返回pad名称,对于空指针使用B::SPECIAL对象,否则使用B::PADNAME对象。</target>
        </trans-unit>
        <trans-unit id="74ded97cfff6de6cbb1491c5e4159e3babfbcd36" translate="yes" xml:space="preserve">
          <source>These two parameters are used to specify the ambient pragmas in the format used by the special variables $^H and ${^WARNING_BITS}.</source>
          <target state="translated">这两个参数是用来指定环境语法的,格式为特殊变量$^H和${^WARNING_BITS}。</target>
        </trans-unit>
        <trans-unit id="668c2e486db55d10e5d748ec32a4297d24e80364" translate="yes" xml:space="preserve">
          <source>These two values for</source>
          <target state="translated">这两个值为</target>
        </trans-unit>
        <trans-unit id="fded399d428f7e457d56603aa714f9152134fea1" translate="yes" xml:space="preserve">
          <source>These utilities help manage extra Perl modules that don't come with the perl distribution.</source>
          <target state="translated">这些实用程序可以帮助管理额外的Perl模块,这些模块并不包含在perl发行版中。</target>
        </trans-unit>
        <trans-unit id="25a3a72bd29e8059a94921c647bd6ce419cc4377" translate="yes" xml:space="preserve">
          <source>These values will not change for the duration of the tied hash</source>
          <target state="translated">这些值在绑定的哈希期间不会改变。</target>
        </trans-unit>
        <trans-unit id="32b1d023c49a0c39aa9dd2f2164ec0cee979dc1b" translate="yes" xml:space="preserve">
          <source>These variables are global to an entire process. They are shared between all interpreters and all threads in a process.</source>
          <target state="translated">这些变量对整个进程来说是全局的,它们被进程中的所有解释器和所有线程共享。它们在一个进程中的所有解释器和所有线程之间共享。</target>
        </trans-unit>
        <trans-unit id="53f5ad69f1f855f312a7f31903221b231e10b532" translate="yes" xml:space="preserve">
          <source>These variables are read-only and dynamically-scoped, unless we note otherwise.</source>
          <target state="translated">除非我们另有说明,否则这些变量是只读和动态范围的。</target>
        </trans-unit>
        <trans-unit id="2a1de91c215bb3911b0f9767ad8cb63c7c66902f" translate="yes" xml:space="preserve">
          <source>These variables are read-only and dynamically-scoped.</source>
          <target state="translated">这些变量是只读和动态范围的。</target>
        </trans-unit>
        <trans-unit id="c7b31baa2b679d0f632af8871cff4bfcc11fe664" translate="yes" xml:space="preserve">
          <source>These variables are used not only to represent Perl-space variables, but also any constants in the code, as well as some structures completely internal to Perl. The symbol table, for instance, is an ordinary Perl hash. Your code is represented by an SV as it's read into the parser; any program files you call are opened via ordinary Perl filehandles, and so on.</source>
          <target state="translated">这些变量不仅用来表示Perl空间的变量,还用来表示代码中的任何常量,以及一些完全属于Perl内部的结构。例如,符号表就是一个普通的Perl哈希。你的代码在被读入解析器时,用SV表示;你调用的任何程序文件都是通过普通的Perl文件柄打开的,以此类推。</target>
        </trans-unit>
        <trans-unit id="82a728707d8b23d45f027d3109e809864b998b05" translate="yes" xml:space="preserve">
          <source>These variables determine the default state of the object created by calling the &lt;code&gt;new&lt;/code&gt; method, but cannot be used to alter the state of the object thereafter. The equivalent method names should be used instead to query or set the internal state of the object.</source>
          <target state="translated">这些变量确定通过调用 &lt;code&gt;new&lt;/code&gt; 方法创建的对象的默认状态，但此后不能用于更改对象的状态。应该使用等效的方法名称来查询或设置对象的内部状态。</target>
        </trans-unit>
        <trans-unit id="21d06b0dd7e2966bcc2949ad21cc8cf11e259059" translate="yes" xml:space="preserve">
          <source>These variables provide information about the current interpreter state.</source>
          <target state="translated">这些变量提供了当前解释器状态的信息。</target>
        </trans-unit>
        <trans-unit id="3ee1fe032de721a344cba89480c67e716abbee89" translate="yes" xml:space="preserve">
          <source>These various prefixes correspond to the fopen(3) modes of &lt;code&gt;r&lt;/code&gt; , &lt;code&gt;r+&lt;/code&gt; , &lt;code&gt;w&lt;/code&gt; , &lt;code&gt;w+&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; , and &lt;code&gt;a+&lt;/code&gt; .</source>
          <target state="translated">这些不同的前缀对应于 &lt;code&gt;r&lt;/code&gt; ， &lt;code&gt;r+&lt;/code&gt; ， &lt;code&gt;w&lt;/code&gt; ， &lt;code&gt;w+&lt;/code&gt; ， &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;a+&lt;/code&gt; 的fopen（3）模式。</target>
        </trans-unit>
        <trans-unit id="ab874a84fee8b167d507adabcea364962ee19104" translate="yes" xml:space="preserve">
          <source>These vars take 3 forms:</source>
          <target state="translated">这些变量有3种形式。</target>
        </trans-unit>
        <trans-unit id="b607e9f6b449fd1b8f047ca8c774e440f540bc1c" translate="yes" xml:space="preserve">
          <source>These were was released in Test::More 0.82, and first shipped with Perl in 5.10.1 as part of Test::More 0.92.</source>
          <target state="translated">这些都是在 Test::More 0.82 中发布的,并在 Test::More 0.92 中作为 Perl 的一部分在 5.10.1 中首次发布。</target>
        </trans-unit>
        <trans-unit id="dbff7e2745b850ca42a72fcb2a24d874bb4460d2" translate="yes" xml:space="preserve">
          <source>These will take care of 64-bit integers and long doubles. For example:</source>
          <target state="translated">这些将处理64位整数和长双数。例如:</target>
        </trans-unit>
        <trans-unit id="ac19dfbee94adc36e2c9732558c6cd8eefc750a8" translate="yes" xml:space="preserve">
          <source>These will tell you if you truly have an integer, double, or string pointer stored in your SV. The &quot;p&quot; stands for private.</source>
          <target state="translated">这些将告诉你,你的SV中是否真的存储了一个整数、双数或字符串指针。p &quot;代表私有。</target>
        </trans-unit>
        <trans-unit id="01c10ede2ffed1b0b1b81928ac4993a2913e0a5d" translate="yes" xml:space="preserve">
          <source>These work as in normal strings.</source>
          <target state="translated">这些工作和普通字符串一样。</target>
        </trans-unit>
        <trans-unit id="38675552ee022f79a520bb1f28a37d1e98aa3227" translate="yes" xml:space="preserve">
          <source>They all return true if the test passed, false if the test failed.</source>
          <target state="translated">如果测试通过,它们都返回true,如果测试失败,则返回false。</target>
        </trans-unit>
        <trans-unit id="8c3cf570334019dd16b6da35836503ad0b730443" translate="yes" xml:space="preserve">
          <source>They also return and accept whole hash entries (&lt;code&gt;HE*&lt;/code&gt; ), making their use more efficient (since the hash number for a particular string doesn't have to be recomputed every time). See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for detailed descriptions.</source>
          <target state="translated">它们还返回并接受整个哈希条目（ &lt;code&gt;HE*&lt;/code&gt; ），从而使它们的使用效率更高（因为不必每次都重新计算特定字符串的哈希值）。有关详细说明，请参见&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a25c349a57769dbafa1bf807ae04ad1d22921bb7" translate="yes" xml:space="preserve">
          <source>They are not exported and must be addressed using the full package name.</source>
          <target state="translated">它们不会被导出,必须使用完整的包名进行处理。</target>
        </trans-unit>
        <trans-unit id="82e0433b7d59191ca9d6b5b4f7f2c32e84b80d15" translate="yes" xml:space="preserve">
          <source>They are suspected to be compiler errors (at least the shuffle.t failure is known from some IRIX 6 setups) and math library errors (the Trig.t failure), but since IRIX 5 is long since end-of-lifed, further fixes for the IRIX are unlikely. If you can get gcc for 5.3, you could try that, too, since gcc in IRIX 6 is a known workaround for at least the shuffle.t and sort.t failures.</source>
          <target state="translated">它们被怀疑是编译器错误(至少在一些IRIX 6的设置中知道shuffle.t失败)和数学库错误(Trig.t失败),但由于IRIX 5早已寿终正寝,因此不太可能对IRIX进行进一步的修复。如果你能得到5.3版的gcc,你也可以试试,因为在IRIX 6中的gcc是一个已知的解决方法,至少可以解决shuffle.t和sort.t故障。</target>
        </trans-unit>
        <trans-unit id="69688ab534f08d7044475644301b479b2c0aa07a" translate="yes" xml:space="preserve">
          <source>They are type specifiers, as detailed in &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;:</source>
          <target state="translated">它们是类型说明符，如&lt;a href=&quot;perldata&quot;&gt;perldata中所述&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="e0af70f00dfa3e42a5613047a29fed35339f3d84" translate="yes" xml:space="preserve">
          <source>They come in handy when you want to print or find the size of data.</source>
          <target state="translated">当你想打印或查找数据的大小时,它们就会派上用场。</target>
        </trans-unit>
        <trans-unit id="af45a4b37483f2a06205c7d3d09277fb7f496321" translate="yes" xml:space="preserve">
          <source>They differ in how they behave if they have the same key as the default metadata. META_ADD will override the default value with its own. META_MERGE will merge its value with the default.</source>
          <target state="translated">它们的不同之处在于,如果它们的键与默认元数据相同,它们的行为就会有所不同。META_ADD将用它自己的值覆盖默认值。META_MERGE将把它的值与默认值合并。</target>
        </trans-unit>
        <trans-unit id="38d5f7d4e163392c98f5f93a608be715596d63d6" translate="yes" xml:space="preserve">
          <source>They exist principally so that you can write code like:</source>
          <target state="translated">它们的存在主要是为了让你可以写出类似的代码。</target>
        </trans-unit>
        <trans-unit id="7317b86bbf49f550672235cb05f34f1bf614569a" translate="yes" xml:space="preserve">
          <source>They may be deprecated in future versions.</source>
          <target state="translated">它们在未来的版本中可能会被废弃。</target>
        </trans-unit>
        <trans-unit id="9d9f866ec06430c109794c0b11daa6f4be4c1816" translate="yes" xml:space="preserve">
          <source>They may be expecting something completely different.</source>
          <target state="translated">他们可能期待的是完全不同的东西。</target>
        </trans-unit>
        <trans-unit id="330c7e5216d53f5b33c24e5c7f8fd3d4ead54c44" translate="yes" xml:space="preserve">
          <source>They seem to be caused by broken system header files, and also other open source projects are seeing them. The following HP-UX patches should make the warnings go away:</source>
          <target state="translated">这些警告似乎是由系统头文件损坏引起的,其他开源项目也看到了这些警告。以下的HP-UX补丁应该可以让这些警告消失。</target>
        </trans-unit>
        <trans-unit id="b797d5622b1d1393375da6062407cd69c0ce1eae" translate="yes" xml:space="preserve">
          <source>They work somewhat like compiler directives (pragmata) in that they tend to affect the compilation of your program, and thus will usually work well only when used within a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;. Most of these are lexically scoped, so an inner BLOCK may countermand them by saying:</source>
          <target state="translated">它们的工作方式有点像编译器指令（pragmata），因为它们会影响程序的编译，因此通常仅在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 中使用时才能正常工作。其中大多数都在词法范围内，因此内部的BLOCK可以通过说出以下命令来反抗它们：</target>
        </trans-unit>
        <trans-unit id="6abf5248bc6675a47a3988cb21c2af942a4be9d1" translate="yes" xml:space="preserve">
          <source>They works like the same name operators as theirs.</source>
          <target state="translated">他们的工作原理就像他们的名字运营商一样。</target>
        </trans-unit>
        <trans-unit id="dd7133f0a4178555cc80821515a5b2265342ef9d" translate="yes" xml:space="preserve">
          <source>They're opcode specific, and occur less often than the public ones, so they're represented by short mnemonics instead of single-chars; see B::Op_private and</source>
          <target state="translated">它们是特定于操作码的,比公共的操作码出现的频率要低,所以它们用短记号来表示,而不是单字符;参见B::Op_private和</target>
        </trans-unit>
        <trans-unit id="c1537a4a381e27d6bdd2214d8f21c4c16bc119e0" translate="yes" xml:space="preserve">
          <source>Things that are broken or just don't work quite right.</source>
          <target state="translated">损坏的东西或只是不完全正确的工作。</target>
        </trans-unit>
        <trans-unit id="731699b64ef1b2479598864f867653535a2b0bbe" translate="yes" xml:space="preserve">
          <source>Things that make Perl easier to learn: Unix experience, almost any kind of programming experience, an understanding of regular expressions, and the ability to understand other people's code. If there's something you need to do, then it's probably already been done, and a working example is usually available for free. Don't forget Perl modules, either. They're discussed in Part 3 of this FAQ, along with &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;CPAN&lt;/a&gt;, which is discussed in Part 2.</source>
          <target state="translated">使Perl易于学习的东西：Unix经验，几乎任何类型的编程经验，对正则表达式的理解以及理解其他人的代码的能力。如果您需要做某事，那么可能已经完成了，通常可以免费获得一个可用的示例。也不要忘记Perl模块。它们在本常见问题解答的第3部分中进行了讨论，而&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;CPAN&lt;/a&gt;在第2部分中进行了讨论。</target>
        </trans-unit>
        <trans-unit id="d9717c58dca00ca4e0fdd51bb342bee53c9f4f98" translate="yes" xml:space="preserve">
          <source>Things that need to be done to improve this document.</source>
          <target state="translated">为改进本文件需要做的事情。</target>
        </trans-unit>
        <trans-unit id="8bbe6bf4aeb5dea432e939ae88abe2437f8000be" translate="yes" xml:space="preserve">
          <source>Things to take special care with, sometimes called WARNINGS.</source>
          <target state="translated">需要特别注意的事情,有时也叫警告。</target>
        </trans-unit>
        <trans-unit id="f330d2b9426f91894c132eec7839a297e7c3f2bb" translate="yes" xml:space="preserve">
          <source>Think about reusability. Why waste brainpower on a one-shot when you might want to do something like it again? Consider generalizing your code. Consider writing a module or object class. Consider making your code run cleanly with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; (or &lt;b&gt;-w&lt;/b&gt;) in effect. Consider giving away your code. Consider changing your whole world view. Consider... oh, never mind.</source>
          <target state="translated">考虑可重用性。当您可能想再次做类似的事情时，为什么要浪费脑力呢？考虑将代码泛化。考虑编写模块或对象类。请考虑使代码 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;严格运行，并有效 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; （或&lt;b&gt;-w&lt;/b&gt;）。考虑放弃您的代码。考虑改变您的整个世界视野。考虑...哦，没关系。</target>
        </trans-unit>
        <trans-unit id="369cf00ca2016a53c53652dbdfad94b27946d096" translate="yes" xml:space="preserve">
          <source>Think carefully about whether OO is appropriate for your module. Gratuitous object orientation results in complex APIs which are difficult for the average module user to understand or use.</source>
          <target state="translated">仔细思考OO是否适合你的模块。免费的对象导向会导致复杂的API,一般模块用户很难理解或使用。</target>
        </trans-unit>
        <trans-unit id="d05ca6e0d80ee8bcc4977d0ae97da44f7a9ad4e9" translate="yes" xml:space="preserve">
          <source>Think of these macros as working a bit like &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; in Perl to limit the scope of local variables.</source>
          <target state="translated">可以将这些宏视为类似于Perl中的 &lt;code&gt;{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; 来限制局部变量的范围。</target>
        </trans-unit>
        <trans-unit id="b798a2f7f99599171fc59b43924703f9a2be020d" translate="yes" xml:space="preserve">
          <source>Thinking of mixing &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; and threads? Please lie down and wait until the feeling passes. Be aware that the semantics of &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; vary between platforms. For example, some Unix systems copy all the current threads into the child process, while others only copy the thread that called &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;. You have been warned!</source>
          <target state="translated">想混合 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 和线程？请躺下，等到感觉消失。请注意， &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 的语义在平台之间有所不同。例如，某些Unix系统将所有当前线程复制到子进程中，而其他系统仅复制称为 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 的线程。你被警告了！</target>
        </trans-unit>
        <trans-unit id="7971e6a051104074fdae0f02322417b6eb5695a2" translate="yes" xml:space="preserve">
          <source>This</source>
          <target state="translated">This</target>
        </trans-unit>
        <trans-unit id="3b8ab74e7f407ff0613b1e22c57e79a02a3a70ca" translate="yes" xml:space="preserve">
          <source>This 'cheat sheet' is a handy reference, meant for beginning Perl programmers. Not everything is mentioned, but 195 features may already be overwhelming.</source>
          <target state="translated">这张 &quot;小抄 &quot;是一份方便的参考资料,是为初学 Perl 的程序员准备的。并非所有的功能都会被提及,但195个功能可能已经让人难以承受。</target>
        </trans-unit>
        <trans-unit id="449deebd32ed5eaf74d8aec8711aa290af1210b0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; is somewhat like &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; found in C, in that it is the opposite of read. The wrapper for the perl &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; function is called &lt;code&gt;format_write&lt;/code&gt; . However, whilst the C &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; function returns the number of bytes written, this &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; function simply returns true if successful (like &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;). A more C-like &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; (see above).</source>
          <target state="translated">这种 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 操作有点像在C中找到的 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; ，因为它与读操作相反。perl &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 函数的包装器称为 &lt;code&gt;format_write&lt;/code&gt; 。但是，尽管C &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 函数返回写入的字节数，但是如果成功（例如 &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ），则此 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 函数仅返回true 。更像C的 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; （请参见上文）。</target>
        </trans-unit>
        <trans-unit id="809a4dea69e66cbb56a6927382a1c7747ff2b245" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;POSIX::SigAction&lt;/code&gt; object is intended for use with the &lt;code&gt;POSIX::sigaction()&lt;/code&gt; function.</source>
          <target state="translated">该 &lt;code&gt;POSIX::SigAction&lt;/code&gt; 对象旨在与 &lt;code&gt;POSIX::sigaction()&lt;/code&gt; 函数一起使用。</target>
        </trans-unit>
        <trans-unit id="8a5e4636d7ee396c2538c58facc6d68cb4eb415b" translate="yes" xml:space="preserve">
          <source>This CPAN module lets you create application-level DTrace probes written in Perl.</source>
          <target state="translated">这个CPAN模块可以让您创建用Perl编写的应用级DTrace探针。</target>
        </trans-unit>
        <trans-unit id="511e2864753cd52a1ebcc75d7881ce1d9fb8ec6b" translate="yes" xml:space="preserve">
          <source>This DBM filter allows you to choose the character encoding will be store in the DBM file. The usage is</source>
          <target state="translated">这个DBM过滤器允许你选择将存储在DBM文件中的字符编码。其用法是</target>
        </trans-unit>
        <trans-unit id="8d6cf7bbaf015be1842a3503d362b5db206d9719" translate="yes" xml:space="preserve">
          <source>This DBM filter is used when interoperating with a C/C++ application that uses a C int as either the key and/or value in the DBM file.</source>
          <target state="translated">当与C/C++应用程序进行交互时,使用C int作为DBM文件中的键和/或值时,会用到这个DBM过滤器。</target>
        </trans-unit>
        <trans-unit id="b9afd96c4f0113b4f4a0ca24ef6b7ce1c1eceace" translate="yes" xml:space="preserve">
          <source>This DBM filter will compress all data before it is written to the database and uncompressed it on reading.</source>
          <target state="translated">这个DBM过滤器会在数据写入数据库之前压缩所有数据,并在读取时解压。</target>
        </trans-unit>
        <trans-unit id="b3c940c7a493363dfcc2ec46854ae2f8bf461ebc" translate="yes" xml:space="preserve">
          <source>This Filter will ensure that all data written to the DBM will be encoded in UTF-8.</source>
          <target state="translated">该过滤器将确保所有写入DBM的数据将以UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="fc3e8623db78291ea4659afa55c27a0af1b2fdc1" translate="yes" xml:space="preserve">
          <source>This IPv4-only function is provided largely for legacy reasons. Newly-written code should use getaddrinfo() or inet_pton() instead for IPv6 support.</source>
          <target state="translated">这个只支持IPv4的函数主要是由于传统的原因而提供的,新编写的代码应该使用getaddrinfo(或inet_pton()来支持IPv6。新写的代码应该使用getaddrinfo()或inet_pton()来支持IPv6。</target>
        </trans-unit>
        <trans-unit id="a1b8940a7dbf27c2770dc1f730a7a76eb668b365" translate="yes" xml:space="preserve">
          <source>This IPv4-only function is provided largely for legacy reasons. Newly-written code should use getnameinfo() or inet_ntop() instead for IPv6 support.</source>
          <target state="translated">这个只支持IPv4的函数主要是出于传统的原因。新写的代码应该使用getnameinfo()或inet_ntop()来支持IPv6。</target>
        </trans-unit>
        <trans-unit id="722a81c183f099f4bcdf928fea77c08691faed91" translate="yes" xml:space="preserve">
          <source>This MGVTBL structure is set at compile-time in</source>
          <target state="translated">这个MGVTBL结构是在编译时在</target>
        </trans-unit>
        <trans-unit id="d239471597c0b244a6c849bc4b21df8bfaf5b7db" translate="yes" xml:space="preserve">
          <source>This PerlIO layer opens a filehandle with a transparent encoding filter.</source>
          <target state="translated">这个PerlIO层打开一个带有透明编码过滤器的文件柄。</target>
        </trans-unit>
        <trans-unit id="a75ec57aa7be5f3e457676aa78fd87835feef6b5" translate="yes" xml:space="preserve">
          <source>This README was written by Sherm Pendley &amp;lt;sherm@dot-app.org&amp;gt;, and subsequently updated by Dominic Dunlop &amp;lt;domo@computer.org&amp;gt; and Breno G. de Oliveira &amp;lt;garu@cpan.org&amp;gt;. The &quot;Starting From Scratch&quot; recipe was contributed by John Montbriand &amp;lt;montbriand@apple.com&amp;gt;.</source>
          <target state="translated">该自述文件由Sherm Pendley &amp;lt;sherm@dot-app.org&amp;gt;编写，随后由Dominic Dunlop &amp;lt;domo@computer.org&amp;gt;和Breno G. de Oliveira &amp;lt;garu@cpan.org&amp;gt;进行了更新。&amp;ldquo;从头开始&amp;rdquo;食谱由John Montbriand &amp;lt;montbriand@apple.com&amp;gt;贡献。</target>
        </trans-unit>
        <trans-unit id="ebd95c4f5ef4e4618995d165e48685abb75f4895" translate="yes" xml:space="preserve">
          <source>This TODO</source>
          <target state="translated">此待办事项</target>
        </trans-unit>
        <trans-unit id="65401762a1d1713b0f2418936baae5413a27fffb" translate="yes" xml:space="preserve">
          <source>This UTF8 flag is not visible in Perl scripts, exactly for the same reason you cannot (or rather, you</source>
          <target state="translated">这个UTF8标志在Perl脚本中是不可见的,这与你不能(或者说,你不能)使用</target>
        </trans-unit>
        <trans-unit id="4052f785cdabbfe61b3039b9711ade7bde52e516" translate="yes" xml:space="preserve">
          <source>This a copy of the $md5 object. It is useful when you do not want to destroy the digests state, but need an intermediate value of the digest, e.g. when calculating digests iteratively on a continuous data stream. Example:</source>
          <target state="translated">这是$md5对象的副本。当你不想破坏摘要状态,但需要一个摘要的中间值时,它是很有用的,例如,当你在一个连续的数据流上迭代计算摘要时。例如:当在连续数据流上迭代计算摘要时,它是有用的。</target>
        </trans-unit>
        <trans-unit id="80e3860a781a3958ead624c7605f67461e6feac0" translate="yes" xml:space="preserve">
          <source>This action at a distance can be confusing, so you should be careful with your use of weaken. You should weaken the reference in the variable that will go out of scope</source>
          <target state="translated">这个动作在远处可能会引起混淆,所以你应该小心使用weaken。你应该弱化变量中的引用,因为它将超出范围</target>
        </trans-unit>
        <trans-unit id="31854231243bab283e1b65fbafa450794c35d551" translate="yes" xml:space="preserve">
          <source>This affects the &quot;udp&quot;, &quot;tcp&quot;, and &quot;syn&quot; protocols.</source>
          <target state="translated">这将影响 &quot;udp&quot;、&quot;tcp &quot;和 &quot;syn &quot;协议。</target>
        </trans-unit>
        <trans-unit id="873bbf87a172d66b10ad3b61904a0d639ca9b860" translate="yes" xml:space="preserve">
          <source>This allows Math::BigInt to correctly retrieve package globals from the subclass, like &lt;code&gt;$SubClass::precision&lt;/code&gt; . See t/Math/BigInt/Subclass.pm or t/Math/BigFloat/SubClass.pm completely functional subclass examples.</source>
          <target state="translated">这使Math :: BigInt可以从子类正确检索包全局变量，例如 &lt;code&gt;$SubClass::precision&lt;/code&gt; 。请参阅t / Math / BigInt / Subclass.pm或t / Math / BigFloat / SubClass.pm完整功能的子类示例。</target>
        </trans-unit>
        <trans-unit id="1d5501a126d7bcccb962537b6328418e9a9cd85d" translate="yes" xml:space="preserve">
          <source>This allows a user to setup a directory tree for some software with directories &lt;code&gt;&amp;lt;root&amp;gt;/bin&lt;/code&gt; and &lt;code&gt;&amp;lt;root&amp;gt;/lib&lt;/code&gt; , and then the above example will allow the use of modules in the lib directory without knowing where the software tree is installed.</source>
          <target state="translated">这允许用户为目录为 &lt;code&gt;&amp;lt;root&amp;gt;/bin&lt;/code&gt; 和 &lt;code&gt;&amp;lt;root&amp;gt;/lib&lt;/code&gt; 的某些软件设置目录树，然后上述示例将允许使用lib目录中的模块，而无需知道软件树的安装位置。</target>
        </trans-unit>
        <trans-unit id="f2d1ac05408a326c089b0ec60746ba54464b2076" translate="yes" xml:space="preserve">
          <source>This allows for a more traditional use of sockatmark() as a procedural socket function. If your system does not support sockatmark(), the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; declaration will fail at compile time.</source>
          <target state="translated">这允许将sockatmark（）更传统地用作过程套接字函数。如果您的系统不支持sockatmark（），则 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 声明将在编译时失败。</target>
        </trans-unit>
        <trans-unit id="5c4bf55b527390af875f220a6a455b96b2cc2be5" translate="yes" xml:space="preserve">
          <source>This allows one to specify the</source>
          <target state="translated">这使得人们可以指定</target>
        </trans-unit>
        <trans-unit id="dd0d07d0d3a6167b29dae996bfd8a33bb4d04031" translate="yes" xml:space="preserve">
          <source>This allows the ability to provide an extra pointer (called the &quot;host&quot; environment) for all the system calls. This makes it possible for all the system stuff to maintain their own state, broken down into seven C structures. These are thin wrappers around the usual system calls (see</source>
          <target state="translated">这使得能够为所有的系统调用提供一个额外的指针(称为 &quot;主机 &quot;环境)。这使得所有的系统东西都可以保持自己的状态,分解为七个C结构。这些都是通常的系统调用的瘦包装器(见</target>
        </trans-unit>
        <trans-unit id="f2d9de12c87f7e2eb33ce435c5af882982d468fe" translate="yes" xml:space="preserve">
          <source>This allows the engine to dupe its private data but also if necessary modify the final structure if it really must.</source>
          <target state="translated">这使得引擎可以复制其私有数据,但如果真的要修改最终结构,也可以在必要时进行修改。</target>
        </trans-unit>
        <trans-unit id="afb3f86b59b2eab9a83b014b190ee8244b9d77c6" translate="yes" xml:space="preserve">
          <source>This allows the programmer to look at the execution stack and variables to find out the cause of the exception. As the debugger is being invoked as the Perl interpreter is about to do a fatal exit, continuing the execution in debug mode is usually not practical.</source>
          <target state="translated">这使得程序员可以查看执行堆栈和变量,找出异常的原因。由于调试器是在Perl解释器即将进行致命退出时被调用的,因此在调试模式下继续执行通常是不现实的。</target>
        </trans-unit>
        <trans-unit id="1baefaa51fc7ed599ce445dad500d37cb72bf43c" translate="yes" xml:space="preserve">
          <source>This allows you to add a prefix to the backup file, instead of (or in addition to) a suffix:</source>
          <target state="translated">这允许您在备份文件中添加前缀,而不是(或附加)后缀。</target>
        </trans-unit>
        <trans-unit id="3e47154414d862007ad5f643f15fef0b3978ca2c" translate="yes" xml:space="preserve">
          <source>This allows you to intermix your source code and your documentation text freely, as in</source>
          <target state="translated">这允许你自由地混合你的源代码和你的文档文本,如在</target>
        </trans-unit>
        <trans-unit id="56e637a731a56d0d223f91be743e436a188835e3" translate="yes" xml:space="preserve">
          <source>This allows you to pass a reference to a scalar, in which the data will be stored:</source>
          <target state="translated">这允许你传递一个对标量的引用,数据将被存储在标量中。</target>
        </trans-unit>
        <trans-unit id="ae11cd12869687833116af8fabb9e16d79564d09" translate="yes" xml:space="preserve">
          <source>This allows you to specify &lt;code&gt;constants&lt;/code&gt; in your template. ie, they keys that are not allowed to be altered by the user. It pretty much allows you to keep all your &lt;code&gt;configurable&lt;/code&gt; data in one place; the &lt;code&gt;Params::Check&lt;/code&gt; template.</source>
          <target state="translated">这使您可以在模板中指定 &lt;code&gt;constants&lt;/code&gt; 。即，它们不允许用户更改键。它几乎可以让您将所有可 &lt;code&gt;configurable&lt;/code&gt; 数据保存在一个地方。在 &lt;code&gt;Params::Check&lt;/code&gt; 模板。</target>
        </trans-unit>
        <trans-unit id="ec9cd2ea84115168b54e6b0797c0f572af954da0" translate="yes" xml:space="preserve">
          <source>This almost definitely doesn't do what you expect:</source>
          <target state="translated">这几乎肯定达不到你预期的效果。</target>
        </trans-unit>
        <trans-unit id="5ba2015dbd8b7d90bb6da319e60421ccbe89f224" translate="yes" xml:space="preserve">
          <source>This also applies to integers that look like floating point constants:</source>
          <target state="translated">这也适用于看起来像浮点常数的整数。</target>
        </trans-unit>
        <trans-unit id="636185aa1476a4214e4b7454bccd1f721aa5d7e5" translate="yes" xml:space="preserve">
          <source>This also behaves similarly, but assigns to a lexical variable instead of to &lt;code&gt;$_&lt;/code&gt; :</source>
          <target state="translated">这也具有相似的行为，但是分配给词法变量而不是 &lt;code&gt;$_&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="77df2183cb5ed8fa6c016243494c2444f23d3c09" translate="yes" xml:space="preserve">
          <source>This also has a special use with XS AUTOLOAD subs. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;Autoloading with XSUBs in perlguts&lt;/a&gt;.</source>
          <target state="translated">这在XS AUTOLOAD子程序中也有特殊用途。请参见&lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;在perlguts中使用XSUB自动加载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3d548e6c0ea6757b5bd736b5e0dc177ac6e6019" translate="yes" xml:space="preserve">
          <source>This also has implications for the use of the SUPER:: qualifier (see &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;).</source>
          <target state="translated">这也对使用SUPER ::限定符&lt;a href=&quot;perlobj&quot;&gt;有影响&lt;/a&gt;（请参阅perlobj）。</target>
        </trans-unit>
        <trans-unit id="f8da07f35c437fa97e844be13f7f26224b7e80d0" translate="yes" xml:space="preserve">
          <source>This also means it is a bad idea to check for some specific package, since the actual contents of $x might be something unexpected. Due to the transparent way of bignum &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref()&lt;/a&gt;&lt;/code&gt; should not be necessary, anyway.</source>
          <target state="translated">这也意味着检查某些特定的软件包是一个坏主意，因为$ x的实际内容可能是意外的。由于bignum的透明方式，无论如何都不需要 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f046ba2ed5c45f32bb7d779ddd434216adcb9e9" translate="yes" xml:space="preserve">
          <source>This also means that a first argument hash reference now becomes the second argument:</source>
          <target state="translated">这也意味着,第一个参数的哈希引用现在变成了第二个参数。</target>
        </trans-unit>
        <trans-unit id="53e0f20ff4a10e2905e391319be8b9814ea5ca78" translate="yes" xml:space="preserve">
          <source>This also returns the file format version. If the version is &quot;2.7&quot; then major would be 2 and minor would be 7. The minor element is missing for when major is less than 2.</source>
          <target state="translated">这也返回文件格式版本。如果版本是 &quot;2.7&quot;,那么major是2,minor是7。当major小于2时,则缺少minor元素。</target>
        </trans-unit>
        <trans-unit id="61c52be3ac150c6eed66b2a1ead6f0d851e682d3" translate="yes" xml:space="preserve">
          <source>This also works for other subclasses, like Math::String.</source>
          <target state="translated">这也适用于其他子类,比如 Math::String。</target>
        </trans-unit>
        <trans-unit id="8468a87cfa0204ff52a567b1eaf4b66d1ee547eb" translate="yes" xml:space="preserve">
          <source>This always means your main memory, not your disk. Clouding the issue is the fact that your machine may implement &lt;b&gt;virtual&lt;/b&gt; memory; that is, it will pretend that it has more memory than it really does, and it&amp;rsquo;ll use disk space to hold inactive bits. This can make it seem like you have a little more memory than you really do, but it&amp;rsquo;s not a substitute for real memory. The best thing that can be said about virtual memory is that it lets your performance degrade gradually rather than suddenly when you run out of real memory. But your program can die when you run out of virtual memory, too&amp;mdash;if you haven&amp;rsquo;t thrashed your disk to death first.</source>
          <target state="translated">这始终意味着您的主内存，而不是磁盘。问题的根源在于您的计算机可能实现了&lt;b&gt;虚拟&lt;/b&gt;内存。也就是说，它会假装它具有比实际更多的内存，并且它将使用磁盘空间来保存不活动的位。这可以使您看起来好像比实际拥有更多的内存，但是它不能代替真实的内存。关于虚拟内存的最好的说法是，当您用完实际内存时，它会使性能逐渐降低，而不是突然降低。但是，如果您的虚拟内存用完了，您的程序也会死掉-如果您没有先将磁盘砸死。</target>
        </trans-unit>
        <trans-unit id="165f78228b9bb880f61927fda978ad6714cce456" translate="yes" xml:space="preserve">
          <source>This anomaly stems from Perl's attempt to not disturb older programs that didn't use Unicode, along with Perl's desire to add Unicode support seamlessly. But the result turned out to not be seamless. (By the way, you can choose to be warned when things like this happen. See &lt;code&gt;&lt;a href=&quot;encoding/warnings&quot;&gt;encoding::warnings&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">这种异常源于Perl试图不打扰未使用Unicode的旧程序的尝试，以及Perl希望无缝添加Unicode支持的愿望。但是结果却并非完美无缺。（顺便说一句，您可以选择在发生这种情况时发出警告。请参见 &lt;code&gt;&lt;a href=&quot;encoding/warnings&quot;&gt;encoding::warnings&lt;/a&gt;&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="8c246570729105a65f6bd289985b0b62d1e1f94f" translate="yes" xml:space="preserve">
          <source>This appeared in perl 5.10.0. Anything matched left of &lt;code&gt;\K&lt;/code&gt; is not included in &lt;code&gt;$&amp;amp;&lt;/code&gt; , and will not be replaced if the pattern is used in a substitution. This lets you write &lt;code&gt;s/PAT1 \K PAT2/REPL/x&lt;/code&gt; instead of &lt;code&gt;s/(PAT1) PAT2/${1}REPL/x&lt;/code&gt; or &lt;code&gt;s/(?&amp;lt;=PAT1) PAT2/REPL/x&lt;/code&gt; .</source>
          <target state="translated">这出现在perl 5.10.0中。 &lt;code&gt;\K&lt;/code&gt; 左边匹配的任何内容都不会包含在 &lt;code&gt;$&amp;amp;&lt;/code&gt; 中，如果在替换中使用了模式，则不会被替换。这使您可以写 &lt;code&gt;s/PAT1 \K PAT2/REPL/x&lt;/code&gt; 而不是 &lt;code&gt;s/(PAT1) PAT2/${1}REPL/x&lt;/code&gt; 或 &lt;code&gt;s/(?&amp;lt;=PAT1) PAT2/REPL/x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9e79001ab117c0cf333336e9232ddbb9a00de3d" translate="yes" xml:space="preserve">
          <source>This applies equally to method names, parameter names, and anything else which is visible to the user (and most things that aren't!)</source>
          <target state="translated">这同样适用于方法名,参数名,以及其他任何对用户可见的东西(以及大多数不可见的东西!)。</target>
        </trans-unit>
        <trans-unit id="70dd8476567c22ea231857d01ff4db7f81b73be8" translate="yes" xml:space="preserve">
          <source>This applies only to lexical variables, by the way. Dynamic variables continue to work as they have always worked. Closure is not something that most Perl programmers need trouble themselves about to begin with.</source>
          <target state="translated">顺便说一下,这只适用于词法变量。动态变量可以像以前一样继续工作。大多数Perl程序员一开始就不需要为关闭而烦恼。</target>
        </trans-unit>
        <trans-unit id="4e13602141364999d0474f62de688119ccaf7274" translate="yes" xml:space="preserve">
          <source>This applies to the perlio system only. For versions before 5.7, &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; is equivalent to &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; .</source>
          <target state="translated">这仅适用于perlio系统。对于5.7之前的版本， &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; 等效于 &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88ab6b9c73082204ae0542a65f9bf2f5c23ef207" translate="yes" xml:space="preserve">
          <source>This approach also works for comparing hashes. Here we'll demonstrate two different answers:</source>
          <target state="translated">这种方法同样适用于比较哈希值。这里我们将演示两种不同的答案。</target>
        </trans-unit>
        <trans-unit id="684f52e2ad132a8d50a850505a18c8cf67adca2e" translate="yes" xml:space="preserve">
          <source>This approach makes it comparatively easy to write code preprocessors without worrying about the form or contents of strings, regexes, etc.</source>
          <target state="translated">这种方法使得编写代码预处理程序比较容易,不用担心字符串、regexes等的形式和内容。</target>
        </trans-unit>
        <trans-unit id="21941c4a2190129983b70fab8729b6e9162dfa7f" translate="yes" xml:space="preserve">
          <source>This approach of treating &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; like object methods calls doesn't work for the diamond operator. That's because it's a real operator, not just a function with a comma-less argument. Assuming you've been storing typeglobs in your structure as we did above, you can use the built-in function named &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; to read a record just as &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; does. Given the initialization shown above for @fd, this would work, but only because readline() requires a typeglob. It doesn't work with objects or strings, which might be a bug we haven't fixed yet.</source>
          <target state="translated">这种将 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 像对象方法调用一样对待的方法不适用于菱形运算符。那是因为它是一个真正的运算符，而不仅仅是带有无逗号参数的函数。假设您已经像上面一样在结构中存储了typeglob，则可以像 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 一样使用名为 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 的内置函数读取记录。给定上面显示的@fd初始化，这将起作用，但这仅是因为readline（）需要一个typeglob。它不适用于对象或字符串，这可能是我们尚未修复的错误。</target>
        </trans-unit>
        <trans-unit id="f95f50481ff3516b07bb9d7865830ab6c1ff5648" translate="yes" xml:space="preserve">
          <source>This array holds the offsets of the beginnings of the last successful submatches in the currently active dynamic scope. &lt;code&gt;$-[0]&lt;/code&gt; is the offset into the string of the beginning of the entire match. The</source>
          <target state="translated">该数组保存当前活动动态范围中最后一次成功子匹配的开始的偏移量。 &lt;code&gt;$-[0]&lt;/code&gt; 是整个比赛开始处字符串的偏移量。的</target>
        </trans-unit>
        <trans-unit id="e96381bdcc284e80585b7b54b1e289040c1f9efb" translate="yes" xml:space="preserve">
          <source>This array holds the offsets of the ends of the last successful submatches in the currently active dynamic scope. &lt;code&gt;$+[0]&lt;/code&gt; is the offset into the string of the end of the entire match. This is the same value as what the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; function returns when called on the variable that was matched against. The</source>
          <target state="translated">该数组保存当前活动动态范围中最后一次成功子匹配的结尾的偏移量。 &lt;code&gt;$+[0]&lt;/code&gt; 是整个比赛结束时字符串的偏移量。该值与 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 函数在匹配的变量上调用时返回的值相同。的</target>
        </trans-unit>
        <trans-unit id="de9df0444460b118bc16cc7a6647d43831c503da" translate="yes" xml:space="preserve">
          <source>This array of function pointers is a convenient place to hook into the compilation process. An XS module can put its own custom check function in place of any of the standard ones, to influence the compilation of a particular type of op. However, a custom check function must never fully replace a standard check function (or even a custom check function from another module). A module modifying checking must instead &lt;b&gt;wrap&lt;/b&gt; the preexisting check function. A custom check function must be selective about when to apply its custom behaviour. In the usual case where it decides not to do anything special with an op, it must chain the preexisting op function. Check functions are thus linked in a chain, with the core's base checker at the end.</source>
          <target state="translated">此函数指针数组是插入编译过程的方便位置。 XS模块可以使用其自己的自定义检查功能代替任何标准功能，以影响特定类型的op的编译。但是，自定义检查功能绝对不能完全取代标准检查功能（甚至是其他模块的自定义检查功能）。相反，修改检查的模块必须&lt;b&gt;包装&lt;/b&gt;先前存在的检查功能。自定义检查功能必须对何时应用其自定义行为具有选择性。在通常情况下，如果它决定不对op执行任何特殊操作，则它必须链接先前存在的op函数。因此，检查功能是链式链接的，最后是核心的基础检查器。</target>
        </trans-unit>
        <trans-unit id="b8dc273368b99545f08bf93846a0eeb46f2d8f07" translate="yes" xml:space="preserve">
          <source>This article is about a little-known feature of Perl called</source>
          <target state="translated">本文介绍的是Perl中一个鲜为人知的特性,叫做</target>
        </trans-unit>
        <trans-unit id="31e9f3bedf523d7ebb982ebf37f1569db684a386" translate="yes" xml:space="preserve">
          <source>This article originally appeared in</source>
          <target state="translated">本文原载于</target>
        </trans-unit>
        <trans-unit id="290ae5b40be8703f5e688eadedc6451a7fcb95b4" translate="yes" xml:space="preserve">
          <source>This article originally appeared in The Perl Journal #11, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and The Perl Journal. This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">本文原载于 The Perl Journal #11,版权归 The Perl Journal 1998 所有。本文由 Jon Orwant 和 The Perl Journal 提供。本文档可以在与Perl本身相同的条款下发布。</target>
        </trans-unit>
        <trans-unit id="f5ced083e00b961f0ed9ea00cb4d87f96f2e0533" translate="yes" xml:space="preserve">
          <source>This assertion may be used as the condition in a</source>
          <target state="translated">这个断言可以作为一个条件在</target>
        </trans-unit>
        <trans-unit id="0000b51c42222ffe097e200394d62769ca419cbc" translate="yes" xml:space="preserve">
          <source>This assumes that we saw the locale &quot;en_US.ISO8859-1&quot; using the commands discussed above. We decided to try that instead of the above faulty locale &quot;En_US&quot;--and in Cshish shells (&lt;b&gt;csh&lt;/b&gt;, &lt;b&gt;tcsh&lt;/b&gt;)</source>
          <target state="translated">假设我们使用上面讨论的命令看到了语言环境&amp;ldquo; en_US.ISO8859-1&amp;rdquo;。我们决定尝试使用上述错误的语言环境&amp;ldquo; En_US&amp;rdquo;，并使用Cshish shells（&lt;b&gt;csh&lt;/b&gt;，&lt;b&gt;tcsh&lt;/b&gt;）</target>
        </trans-unit>
        <trans-unit id="c0dee2f933f09058dd9bf3765b7f846ec57f52d7" translate="yes" xml:space="preserve">
          <source>This attribute is not a search parameter, but is used to report the result of &lt;code&gt;survey&lt;/code&gt; method, as discussed in the next section.</source>
          <target state="translated">该属性不是搜索参数，而是用于报告 &lt;code&gt;survey&lt;/code&gt; 方法的结果，如下一节所述。</target>
        </trans-unit>
        <trans-unit id="9c687ced37405f8cf67c894463cfe3d86f5b0e65" translate="yes" xml:space="preserve">
          <source>This attribute is used to specify names to be imported into the extension. It is currently only used by OS/2 and Win32.</source>
          <target state="translated">此属性用于指定要导入扩展的名称。目前只在OS/2和Win32中使用。</target>
        </trans-unit>
        <trans-unit id="a3e8362900ead72447d5c4ebf2182285972d3847" translate="yes" xml:space="preserve">
          <source>This attribute is used to specify names to be imported into the extension. Takes a hash ref.</source>
          <target state="translated">此属性用于指定要导入扩展的名称。取一个哈希值。</target>
        </trans-unit>
        <trans-unit id="767e4d21fb47d7f73037ece0977c12a97d29d46d" translate="yes" xml:space="preserve">
          <source>This attribute may be most useful when specified as a string on the command line: perl Makefile.PL EXCLUDE_EXT='Socket Safe'</source>
          <target state="translated">当在命令行中指定为字符串时,这个属性可能是最有用的:perl Makefile.PL EXCLUDE_EXT='Socket Safe'。</target>
        </trans-unit>
        <trans-unit id="79f89eca0caacc11c08af6c151f34570659a105e" translate="yes" xml:space="preserve">
          <source>This attribute may be most useful when specified as a string on the command line: perl Makefile.PL INCLUDE_EXT='POSIX Socket Devel::Peek'</source>
          <target state="translated">当在命令行中指定为字符串时,这个属性可能是最有用的:perl Makefile.PL INCLUDE_EXT='POSIX Socket Devel::Peek'。</target>
        </trans-unit>
        <trans-unit id="f063de8522828eff3b84027f3f1f4329111a6d6f" translate="yes" xml:space="preserve">
          <source>This attribute means that every time this search sees a matching Pod file, it should call this callback routine. The routine is called with two parameters: the current file's filespec, and its pod name. (For example: &lt;code&gt;(&quot;/etc/perljunk/File/Crunk.pm&quot;, &quot;File::Crunk&quot;)&lt;/code&gt; would be in &lt;code&gt;@_&lt;/code&gt; .)</source>
          <target state="translated">此属性意味着，每次此搜索看到匹配的Pod文件时，都应调用此回调例程。用两个参数调用该例程：当前文件的filespec及其pod名称。（例如：（ &lt;code&gt;(&quot;/etc/perljunk/File/Crunk.pm&quot;, &quot;File::Crunk&quot;)&lt;/code&gt; 位于 &lt;code&gt;@_&lt;/code&gt; 中。）</target>
        </trans-unit>
        <trans-unit id="d1d55a165f99ccc6289583795c82aceb24ceabae" translate="yes" xml:space="preserve">
          <source>This attribute's default value is false, meaning that no callback is called.</source>
          <target state="translated">这个属性的默认值是false,意味着不调用回调。</target>
        </trans-unit>
        <trans-unit id="bcee703f93ae24f2cb5be27baf6a28edef44800c" translate="yes" xml:space="preserve">
          <source>This attribute's default value is false; and normally you won't need to turn it on.</source>
          <target state="translated">这个属性的默认值是false,一般情况下你不需要打开它。</target>
        </trans-unit>
        <trans-unit id="56b03f0333e5f7d53de3d13aaa7c296581e96eb6" translate="yes" xml:space="preserve">
          <source>This attribute, if set to a nonzero positive value, will make searches output (via &lt;code&gt;&lt;a href=&quot;../../functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt;) notes about what they're doing as they do it. This option may be useful for debugging a pod-related module. This attribute's default value is zero, meaning that no &lt;code&gt;&lt;a href=&quot;../../functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; messages are produced. (Setting verbose to 1 turns on some messages, and setting it to 2 turns on even more messages, i.e., makes the following search(es) even more verbose than 1 would make them.)</source>
          <target state="translated">如果将此属性设置为非零正值，它将使搜索输出（通过 &lt;code&gt;&lt;a href=&quot;../../functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; ）记录它们在执行操作时的状态。此选项对于调试与Pod相关的模块可能很有用。该属性的默认值为零，表示不生成任何 &lt;code&gt;&lt;a href=&quot;../../functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 消息。 （将verbose设置为1会打开某些消息，将verbose设置为2会打开更多消息，即，使以下搜索比1更加冗长。）</target>
        </trans-unit>
        <trans-unit id="9a5ab376fb5b92c88b226665b3b3189f69774bb5" translate="yes" xml:space="preserve">
          <source>This attribute, if set to a true value, means that searches should implicitly add perl's</source>
          <target state="translated">这个属性,如果设置为true,意味着搜索应该隐式地添加perl的</target>
        </trans-unit>
        <trans-unit id="b39a84ee1b444ad72be8b273ce2aa43be2362f55" translate="yes" xml:space="preserve">
          <source>This behavior can be overridden by supplying your own set of files to search. PL_FILES accepts a hash ref, the key being the file to run and the value is passed in as the first argument when the PL file is run.</source>
          <target state="translated">这个行为可以通过提供你自己的文件集来重写。PL_FILES接受一个hash ref,key是要运行的文件,当运行PL文件时,其值作为第一个参数传递进来。</target>
        </trans-unit>
        <trans-unit id="31de598976c4af9df58fa731498e0e725fcefe91" translate="yes" xml:space="preserve">
          <source>This behavior is convenient, because we usually want to ignore newlines when we count and match characters in a line. Sometimes, however, we want to keep track of newlines. We might even want &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to anchor at the beginning and end of lines within the string, rather than just the beginning and end of the string. Perl allows us to choose between ignoring and paying attention to newlines by using the &lt;code&gt;//s&lt;/code&gt; and &lt;code&gt;//m&lt;/code&gt; modifiers. &lt;code&gt;//s&lt;/code&gt; and &lt;code&gt;//m&lt;/code&gt; stand for single line and multi-line and they determine whether a string is to be treated as one continuous string, or as a set of lines. The two modifiers affect two aspects of how the regexp is interpreted: 1) how the &lt;code&gt;'.'&lt;/code&gt; character class is defined, and 2) where the anchors &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; are able to match. Here are the four possible combinations:</source>
          <target state="translated">这种行为很方便，因为当我们计算和匹配一行中的字符时，我们通常希望忽略换行符。但是，有时我们想跟踪换行符。我们甚至可能希望 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 锚定在字符串中各行的开头和结尾，而不仅仅是锚定字符串的开头和结尾。 Perl允许我们使用 &lt;code&gt;//s&lt;/code&gt; 和 &lt;code&gt;//m&lt;/code&gt; 修饰符在忽略和注意换行之间进行选择。 &lt;code&gt;//s&lt;/code&gt; 和 &lt;code&gt;//m&lt;/code&gt; 代表单行和多行，它们确定将一个字符串视为一个连续的字符串还是一组线。这两个修饰符影响着正则表达式的解释的两个方面：1） &lt;code&gt;'.'&lt;/code&gt; 定义了字符类，以及2）锚点 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 能够匹配的地方。这是四种可能的组合：</target>
        </trans-unit>
        <trans-unit id="3d6ebadd3063ef053971debc9b4e78f1e936126e" translate="yes" xml:space="preserve">
          <source>This behavior is more &quot;Do what I mean&quot; than in earlier Perls for most applications. But it catches fewer issues for code that needs to be strictly Unicode compliant. Therefore there is an additional mode of operation available to accommodate such code. This mode is enabled if a regular expression pattern is compiled within the lexical scope where the &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; warning class has been made fatal, say by:</source>
          <target state="translated">对于大多数应用程序，此行为比早期的Perls更具&amp;ldquo;执行我的意思&amp;rdquo;。但是对于需要严格遵守Unicode的代码，它捕获的问题更少。因此，存在可用于容纳此类代码的其他操作模式。如果在 &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; 警告类设为致命的词汇范围内编译了正则表达式模式，则启用此模式，例如：</target>
        </trans-unit>
        <trans-unit id="092eaaecfde2fe8092e286b99e012b8ea81cec11" translate="yes" xml:space="preserve">
          <source>This behavior of &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; is to be compatible with POSIX behavior and not traditional VMS behavior.</source>
          <target state="translated">这种 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 行为应与POSIX行为兼容，而不是与传统的VMS行为兼容。</target>
        </trans-unit>
        <trans-unit id="353b3ac3017572fed965aadb9e085377b2c9e20d" translate="yes" xml:space="preserve">
          <source>This behavior provides the semantic of lexical scoping, and is used in, for instance, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; pragma.</source>
          <target state="translated">此行为提供了词法作用域的语义，例如在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 杂注中使用。</target>
        </trans-unit>
        <trans-unit id="902d9db5da6a9d0d90bec88dd7435e3d3036822b" translate="yes" xml:space="preserve">
          <source>This behaviour is identical to that of the actual compiler.</source>
          <target state="translated">这种行为与实际编译器的行为相同。</target>
        </trans-unit>
        <trans-unit id="fd9ffc9da0934423cf7a8b2a8167c734225e00ac" translate="yes" xml:space="preserve">
          <source>This binds a dbm(3), ndbm(3), sdbm(3), gdbm(3), or Berkeley DB file to a hash. HASH is the name of the hash. (Unlike normal &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, the first argument is</source>
          <target state="translated">这会将dbm（3），ndbm（3），sdbm（3），gdbm（3）或Berkeley DB文件绑定到哈希。HASH是哈希的名称。（与常 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 不同，第一个参数是</target>
        </trans-unit>
        <trans-unit id="2616a24dba48e4df35dec143fa3cabdfd81fd386" translate="yes" xml:space="preserve">
          <source>This binds a dbm(3), ndbm(3), sdbm(3), gdbm(3), or Berkeley DB file to a hash. HASH is the name of the hash. (Unlike normal &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, the first argument is</source>
          <target state="translated">这会将dbm（3），ndbm（3），sdbm（3），gdbm（3）或Berkeley DB文件绑定到哈希。HASH是哈希的名称。（与常 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 不同，第一个参数是</target>
        </trans-unit>
        <trans-unit id="a6324526e82c2b2028f79347525bf2bc78810ebd" translate="yes" xml:space="preserve">
          <source>This block modifies all the &lt;code&gt;.c&lt;/code&gt; files in the current directory, leaving a backup of the original data from each file in a new &lt;code&gt;.c.orig&lt;/code&gt; file.</source>
          <target state="translated">此块修改当前目录中的所有 &lt;code&gt;.c&lt;/code&gt; 文件，并将来自每个文件的原始数据备份保留在新的 &lt;code&gt;.c.orig&lt;/code&gt; 文件中。</target>
        </trans-unit>
        <trans-unit id="ba453fd403a510bef4a413f0d9ec2dc3165244e0" translate="yes" xml:space="preserve">
          <source>This boilerplate uses the low-overhead &lt;code&gt;XSLoader&lt;/code&gt; if present; if used with an antique Perl which has no &lt;code&gt;XSLoader&lt;/code&gt; , it falls back to using &lt;code&gt;DynaLoader&lt;/code&gt; .</source>
          <target state="translated">该样板使用低开销的 &lt;code&gt;XSLoader&lt;/code&gt; (如果有）；如果与没有 &lt;code&gt;XSLoader&lt;/code&gt; 的古董Perl 一起使用，它将退回到使用 &lt;code&gt;DynaLoader&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="090e5f02457ce14eed85483c0b931f07be2bd405" translate="yes" xml:space="preserve">
          <source>This bug only affects closures that are generated by the block but used afterwards. Lexical variables that are only used during the lifetime of the block's execution will take their individual values for each invocation, as normal.</source>
          <target state="translated">这个bug只影响由块生成但在之后使用的闭包。只在代码块执行期间使用的词法变量将在每次调用时取各自的值,就像正常情况一样。</target>
        </trans-unit>
        <trans-unit id="3fb23a96de018295d436dfc71b478c2f496e60be" translate="yes" xml:space="preserve">
          <source>This bug was fixed in Perl 5.18, but may still trip you up if you are using older versions:</source>
          <target state="translated">这个错误在Perl 5.18中得到了修复,但如果你使用的是旧版本,可能还是会被绊倒。</target>
        </trans-unit>
        <trans-unit id="ca44502c3ed83912a6b5db8a967d8fd6b852bc6b" translate="yes" xml:space="preserve">
          <source>This bug will be rectified in future by using method lookup only for methods' &lt;code&gt;AUTOLOAD&lt;/code&gt; s. However, there is a significant base of existing code that may be using the old behavior. So, as an interim step, Perl currently issues an optional warning when non-methods use inherited &lt;code&gt;AUTOLOAD&lt;/code&gt; s.</source>
          <target state="translated">以后将通过仅对方法的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 使用方法查找来纠正此错误。但是，现有代码有相当大的基础可能在使用旧行为。因此，作为过渡步骤，当非方法使用继承的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 时，Perl当前会发出可选警告。</target>
        </trans-unit>
        <trans-unit id="3151c00be9f916508bc5bf705b67d1e4b35d8229" translate="yes" xml:space="preserve">
          <source>This call extracts the next single substring that is a valid Perl quotelike operator (and removes it from $text):</source>
          <target state="translated">这个调用提取下一个有效的Perl quotelike操作符的单个子串(并将其从$text中删除)。</target>
        </trans-unit>
        <trans-unit id="ced21c2bd0a49aeaa42731431a2edf3632b44a97" translate="yes" xml:space="preserve">
          <source>This call will allow &lt;code&gt;--l&lt;/code&gt; and &lt;code&gt;--L&lt;/code&gt; for the length option, but requires a least &lt;code&gt;--hea&lt;/code&gt; and &lt;code&gt;--hei&lt;/code&gt; for the head and height options.</source>
          <target state="translated">此调用将为长度选项允许 &lt;code&gt;--l&lt;/code&gt; 和 &lt;code&gt;--L&lt;/code&gt; ，但对于头和高度选项至少需要 &lt;code&gt;--hea&lt;/code&gt; 和 &lt;code&gt;--hei&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc74026b11403dd05d9d70bf8ec94212f671778f" translate="yes" xml:space="preserve">
          <source>This callback is where Perl untaints its own capture variables under taint mode (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;). See the &lt;code&gt;Perl_reg_numbered_buff_fetch&lt;/code&gt; function in</source>
          <target state="translated">该回调是Perl在taint模式下释放其自己的捕获变量的地方（请参见&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;）。请参见中的 &lt;code&gt;Perl_reg_numbered_buff_fetch&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="34608b82ee2af981743bfaea1702ca89b064619d" translate="yes" xml:space="preserve">
          <source>This callback will always be invoked and this will happen for each result after one of the above callbacks is invoked. For example, if &lt;a href=&quot;../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; is loaded, you could use the following to color your test output:</source>
          <target state="translated">始终将调用此回调，并且在上述回调之一被调用后，对于每个结果都会发生此回调。例如，如果加载了&lt;a href=&quot;../term/ansicolor&quot;&gt;Term :: ANSIColor，&lt;/a&gt;则可以使用以下内容为测试输出着色：</target>
        </trans-unit>
        <trans-unit id="a84240a7c3c6fb058597f6d953d7900c399c1c57" translate="yes" xml:space="preserve">
          <source>This calls &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; with the SV_GMAGIC flag. See &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; .</source>
          <target state="translated">这将使用SV_GMAGIC标志调用 &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; 。请参阅 &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86657828dc4b39c2a031e8feb96e30aa836f7063" translate="yes" xml:space="preserve">
          <source>This calls the select(2) syscall with the bit masks specified, which can be constructed using &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;, along these lines:</source>
          <target state="translated">这将使用指定的位掩码调用select（2）syscall，可以使用 &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 沿以下行进行构造：</target>
        </trans-unit>
        <trans-unit id="6030aab04889f87b188edddb787660db9b1b144a" translate="yes" xml:space="preserve">
          <source>This calls the select(2) syscall with the bit masks specified, which can be constructed using &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;, along these lines:</source>
          <target state="translated">这将使用指定的位掩码调用select（2）syscall，可以使用 &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 沿以下行进行构造：</target>
        </trans-unit>
        <trans-unit id="9bc12c1e6a592155ae29365e5d2b2a31283e6dd9" translate="yes" xml:space="preserve">
          <source>This can also be a problem with intermediate subprocesses in more complicated code, which will call waitpid() on all open filehandles during global destruction--in no predictable order.</source>
          <target state="translated">在更复杂的代码中,这也是一个中间子进程的问题,因为在全局销毁期间,所有打开的文件柄都会调用waitpid()--没有可预测的顺序。</target>
        </trans-unit>
        <trans-unit id="62869b1f9b57cb9d79e8730408b0c95ddf4b16ac" translate="yes" xml:space="preserve">
          <source>This can also be called with a null first argument to indicate that &lt;code&gt;oldstash&lt;/code&gt; has been deleted.</source>
          <target state="translated">也可以使用空的first参数来调用它，以指示 &lt;code&gt;oldstash&lt;/code&gt; 已被删除。</target>
        </trans-unit>
        <trans-unit id="d43bae30188acac82d7e357353fabe7bc6c40a81" translate="yes" xml:space="preserve">
          <source>This can be accomplished by adding a repeat specifier to the option specification. Repeat specifiers are very similar to the &lt;code&gt;{...}&lt;/code&gt; repeat specifiers that can be used with regular expression patterns. For example, the above command line would be handled as follows:</source>
          <target state="translated">这可以通过在选项规范中添加重复说明符来实现。重复说明符与可以与正则表达式模式一起使用的 &lt;code&gt;{...}&lt;/code&gt; 重复说明符非常相似。例如，上面的命令行将按以下方式处理：</target>
        </trans-unit>
        <trans-unit id="372e8345a480f344b8fa12b55e0c07a688e7200f" translate="yes" xml:space="preserve">
          <source>This can be accomplished with a destination routine:</source>
          <target state="translated">这可以通过一个目的例程来实现。</target>
        </trans-unit>
        <trans-unit id="c3e3779b19d94c38ed3503cfda1db4bf067d5a3d" translate="yes" xml:space="preserve">
          <source>This can be conveniently combined with precalculation of keys as given above.</source>
          <target state="translated">这可以方便地与上面给出的键的预计算相结合。</target>
        </trans-unit>
        <trans-unit id="dee9c9bfb944617270087476daa04080c698fb3a" translate="yes" xml:space="preserve">
          <source>This can be used to change the</source>
          <target state="translated">这可以用来改变</target>
        </trans-unit>
        <trans-unit id="d06a37a2d3a4148b6ee21e32af3a875ef2d651aa" translate="yes" xml:space="preserve">
          <source>This can be used to determine which branch of a pattern was matched without using a separate capture group for each branch, which in turn can result in a performance improvement, as perl cannot optimize &lt;code&gt;/(?:(x)|(y)|(z))/&lt;/code&gt; as efficiently as something like &lt;code&gt;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&lt;/code&gt; .</source>
          <target state="translated">这可以用于确定模式的哪个分支匹配，而无需为每个分支使用单独的捕获组，这又可以导致性能提高，因为perl无法优化 &lt;code&gt;/(?:(x)|(y)|(z))/&lt;/code&gt; 就像 &lt;code&gt;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6b6a0827f222037bfd74f5afc449218b3d32dc4" translate="yes" xml:space="preserve">
          <source>This can be used to provide overridable configuration defaults:</source>
          <target state="translated">这可以用来提供可覆盖的配置默认值。</target>
        </trans-unit>
        <trans-unit id="7302fe67fb868f202093521caa858978f0b6a28c" translate="yes" xml:space="preserve">
          <source>This can be used to see the effect of/bugs in the various layers e.g.</source>
          <target state="translated">这可以用来查看各层的效果/bug,如</target>
        </trans-unit>
        <trans-unit id="20e14da8dfc2bfdf2f71fc590d8fe2a63e1000ea" translate="yes" xml:space="preserve">
          <source>This can be used to store bytes in the string component of the SV. Here the representation of the data is irrelevant to perl and the bytes themselves are just stored in the SV. It is assumed that the C variable is a pointer (the bytes are copied from that memory location). If the pointer is pointing to something that is represented by 8 bytes then those 8 bytes are stored in the SV (and length() will report a value of 8). This entry is similar to T_OPAQUE.</source>
          <target state="translated">这可以用来在SV的字符串组件中存储字节。这里数据的表示方式与perl无关,字节本身只是存储在SV中。假设C变量是一个指针(字节是从该内存位置复制过来的)。如果指针指向一个由8个字节表示的东西,那么这8个字节就会被存储在SV中(length()会报告一个8的值)。此条目与T_OPAQUE类似。</target>
        </trans-unit>
        <trans-unit id="0410f2327d86bdf0fdae05f37687269ec62b9fe1" translate="yes" xml:space="preserve">
          <source>This can be used to store data from non-pointer types in the string part of an SV. It is similar to T_OPAQUEPTR except that the typemap retrieves the pointer directly rather than assuming it is being supplied. For example, if an integer is imported into Perl using T_OPAQUE rather than T_IV the underlying bytes representing the integer will be stored in the SV but the actual integer value will not be available. i.e. The data is opaque to perl.</source>
          <target state="translated">它可以用来在SV的字符串部分存储非指针类型的数据。它与T_OPAQUEPTR类似,只是类型映射直接检索指针,而不是假设它是被提供的。例如,如果使用 T_OPAQUE 而不是 T_IV 将一个整数导入到 Perl 中,代表整数的底层字节将被存储在 SV 中,但实际的整数值将不可用,即数据对 perl 是不透明的。</target>
        </trans-unit>
        <trans-unit id="89bc9efe11bbc18be53fe6f2369d301f92011919" translate="yes" xml:space="preserve">
          <source>This can be useful when carrying out batch operations on multiple files that have both an input filename and output filename and the output file can be derived from the input filename. Examples of operations where this can be useful include, file renaming, file copying and file compression.</source>
          <target state="translated">当对多个文件进行批处理操作时,这很有用,因为这些文件既有输入文件名,又有输出文件名,而且输出文件可以从输入文件名导出。这很有用的操作例子包括:文件重命名、文件复制和文件压缩。</target>
        </trans-unit>
        <trans-unit id="7ee5530e46592bdd5b18c5d4e4adf9c1e149be67" translate="yes" xml:space="preserve">
          <source>This can easily be demonstrated by using a module, such as the Socket module, which uses eval &quot;...&quot; as part of an AUTOLOAD function. You can 'use' the module outside the compartment and share an (autoloaded) function with the compartment. If an autoload is triggered by code in the compartment, or by any code anywhere that is called by any means from the compartment, then the eval in the Socket module's AUTOLOAD function happens in the namespace of the compartment. Any variables created or used by the eval'd code are now under the control of the code in the compartment.</source>
          <target state="translated">这可以通过使用一个模块,比如Socket模块,它使用eval&quot;...&quot;作为AUTOLOAD函数的一部分来轻松演示。你可以在隔间之外 &quot;使用 &quot;这个模块,并与隔间共享一个(自动加载)函数。如果自动加载是由隔间中的代码触发的,或者是由任何地方的代码以任何方式从隔间中调用的,那么Socket模块的AUTOLOAD函数中的eval就发生在隔间的命名空间中。由 eval'd 代码创建或使用的任何变量现在都在分格中的代码的控制之下。</target>
        </trans-unit>
        <trans-unit id="33eb1b5384e732b374fa6a2eb81b539c4ef372da" translate="yes" xml:space="preserve">
          <source>This can give a serious performance boost to your threaded program, since more than one thread will be executing at the same time. As a tradeoff, though, any of those nagging synchronization issues that might not have shown with basic kernel threads will appear with a vengeance.</source>
          <target state="translated">这可以给你的线程程序带来严重的性能提升,因为不止一个线程会同时执行。不过,作为一种权衡,任何那些在基本的内核线程中可能没有表现出来的烦人的同步问题都会报复性地出现。</target>
        </trans-unit>
        <trans-unit id="56f625d37a903c20859d631591a0773b6d672cf7" translate="yes" xml:space="preserve">
          <source>This can lead to some ambiguities. When &lt;code&gt;\N&lt;/code&gt; is not followed immediately by a left brace, Perl assumes the &lt;code&gt;[^\n]&lt;/code&gt; meaning. Also, if the braces form a valid quantifier such as &lt;code&gt;\N{3}&lt;/code&gt; or &lt;code&gt;\N{5,}&lt;/code&gt; , Perl assumes that this means to match the given quantity of non-newlines (in these examples, 3; and 5 or more, respectively). In all other case, where there is a &lt;code&gt;\N{&lt;/code&gt; and a matching &lt;code&gt;}&lt;/code&gt;, Perl assumes that a character name is desired.</source>
          <target state="translated">这可能导致一些歧义。当 &lt;code&gt;\N&lt;/code&gt; 不紧跟左括号时，Perl将采用 &lt;code&gt;[^\n]&lt;/code&gt; 含义。另外，如果括号形成有效的量词，例如 &lt;code&gt;\N{3}&lt;/code&gt; 或 &lt;code&gt;\N{5,}&lt;/code&gt; ，则Perl假定这意味着要匹配给定数量的非换行符（在这些示例中为3； 5或更多，分别）。在所有其他情况下，如果有 &lt;code&gt;\N{&lt;/code&gt; 和匹配的 &lt;code&gt;}&lt;/code&gt; ，Perl假定需要一个字符名称。</target>
        </trans-unit>
        <trans-unit id="959b6fc0ff47607dd43aa724268206e3f29dd78b" translate="yes" xml:space="preserve">
          <source>This can lead to unexpected results. For example, a string's semantics can suddenly change if a code point above 255 is appended to it, which changes the rules from ASCII to Unicode. As an example, consider the following program and its output:</source>
          <target state="translated">这可能导致意想不到的结果。例如,如果在一个字符串中附加一个高于255的码点,那么它的语义就会突然发生变化,从而改变了从ASCII到Unicode的规则。作为一个例子,考虑以下程序及其输出。</target>
        </trans-unit>
        <trans-unit id="85608589698ca117deecc9b9804cdf91bb5ea3e0" translate="yes" xml:space="preserve">
          <source>This can result from a bug in emx sprintf which was fixed in 0.9d fix 03.</source>
          <target state="translated">这可能是由于emx sprintf的一个bug造成的,这个bug在0.9d修复03中得到了修复。</target>
        </trans-unit>
        <trans-unit id="a0068e1ff0325fa89c18995ccdfd4bec0d4d0e1c" translate="yes" xml:space="preserve">
          <source>This can set either by hints files or by Configure. If using a (non-gcc) vendor cc, this variable may contain a version for the compiler.</source>
          <target state="translated">这可以通过提示文件或Configure来设置,如果使用(非gcc)厂商的cc,这个变量可能包含编译器的版本。如果使用的是(非gcc)供应商cc,这个变量可能包含编译器的版本。</target>
        </trans-unit>
        <trans-unit id="b497dc3b646a186b11a326e1c1c02e389336f453" translate="yes" xml:space="preserve">
          <source>This can set either by hints files or by Configure. If using gcc, this is gcc, and if not, usually equal to cc, unimpressive, no? Some platforms, however, make good use of this by storing the flavor of the C compiler being used here. For example if using the Sun WorkShop suite, ccname will be &lt;code&gt;workshop&lt;/code&gt; .</source>
          <target state="translated">可以通过提示文件或&amp;ldquo;配置&amp;rdquo;进行设置。如果使用gcc，则为gcc，否则，通常等于cc，效果不佳，不是吗？但是，某些平台通过存储此处使用的C编译器的样式来充分利用此功能。例如，如果使用Sun WorkShop套件，则ccname将为 &lt;code&gt;workshop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="268887449daa89d9e6e6591c09f61433e4f65428" translate="yes" xml:space="preserve">
          <source>This causes Attribute::Handlers to define the &lt;code&gt;Roo&lt;/code&gt; attribute in the package that imports the Tie::Me::Kangaroo:Down::Sport module.</source>
          <target state="translated">这将导致Attribute :: Handlers 在导入Tie :: Me :: Kangaroo：Down :: Sport模块的包中定义 &lt;code&gt;Roo&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="102ace81a524208492f6e027d89b5645163151f6" translate="yes" xml:space="preserve">
          <source>This causes perl to load your module but does not import any symbols.</source>
          <target state="translated">这将导致perl加载你的模块,但不导入任何符号。</target>
        </trans-unit>
        <trans-unit id="c30feda4a3a3684c859a87888367dce95a5f76b5" translate="yes" xml:space="preserve">
          <source>This causes the redispatcher to only visit each distinct &lt;code&gt;method&lt;/code&gt; method once. That is, to skip any classes in the hierarchy that it has already visited during redispatch. So, for example, if the previous example were rewritten:</source>
          <target state="translated">这将导致redispatcher只能访问每个不同的 &lt;code&gt;method&lt;/code&gt; ，一旦方法。也就是说，跳过重新分发期间已访问的层次结构中的任何类。因此，例如，如果先前的示例被重写：</target>
        </trans-unit>
        <trans-unit id="582cc40cbf8b3547920ee86c914be4717f134b16" translate="yes" xml:space="preserve">
          <source>This change was made because it was found that various commercial tools like editors, or for things like source code control, had been written so that they would not handle program files that used these code points, effectively precluding their use almost entirely! And that was never the intent. They've always been meant to be usable within an application, or cooperating set of applications, at will.</source>
          <target state="translated">之所以做出这样的改变,是因为发现各种商业工具,比如编辑器,或者是源代码控制之类的工具,在编写的时候,它们不会处理使用这些代码点的程序文件,实际上几乎完全排除了这些代码点的使用!而这从来都不是本意。而这从来不是我们的本意。它们一直都是为了在一个应用程序或合作的应用程序集内可以随意使用的。</target>
        </trans-unit>
        <trans-unit id="c679de889cc139bb514d15d08372653b38479f14" translate="yes" xml:space="preserve">
          <source>This changes the sentence to &quot;this is a SUcCess case.&quot;</source>
          <target state="translated">这就把句子改成了 &quot;这是一个诉讼案件&quot;。</target>
        </trans-unit>
        <trans-unit id="806d9541617fb633252bc021124ba56dfb002ae1" translate="yes" xml:space="preserve">
          <source>This changes the string that this token holds. You probably won't need to do this.</source>
          <target state="translated">这将改变这个标记所持有的字符串。你可能不需要这样做。</target>
        </trans-unit>
        <trans-unit id="1b4ce31991e674e8d238b692a9312c922759283b" translate="yes" xml:space="preserve">
          <source>This changes the tagname for this end-token object. You probably won't need to do this.</source>
          <target state="translated">这将改变这个结束标记对象的 tagname。您可能不需要这样做。</target>
        </trans-unit>
        <trans-unit id="05c1f4e6ea1fd867b5212d7916e4ce924dd15d97" translate="yes" xml:space="preserve">
          <source>This changes the tagname for this start-token object. You probably won't need to do this.</source>
          <target state="translated">这将改变这个起始标记对象的 tagname。你可能不需要这样做。</target>
        </trans-unit>
        <trans-unit id="642eb07575d1344323a97b06a777777ad1321fc4" translate="yes" xml:space="preserve">
          <source>This chart is sorted from slowest to fastest, and shows the percent speed difference between each pair of tests.</source>
          <target state="translated">这张图从最慢到最快排序,并显示每对测试之间的速度差异百分比。</target>
        </trans-unit>
        <trans-unit id="7da28c0924cf2fc297ae57e942274584c8adbeb4" translate="yes" xml:space="preserve">
          <source>This checks that every file listed in the .packlist actually exists. If an argument which evaluates to true is given, any missing files will be removed from the internal hash. The return value is a list of the missing files, which will be empty if they all exist.</source>
          <target state="translated">这将检查 .packlist 中列出的每个文件是否真实存在。如果给定一个参数为true,任何丢失的文件将从内部哈希中删除。返回值是一个缺失文件的列表,如果它们都存在,则为空。</target>
        </trans-unit>
        <trans-unit id="f55eba663917d253b044988b2b6ee903ef6a93dc" translate="yes" xml:space="preserve">
          <source>This class (which is very small -- read the source) overrides Pod::Simple's _handle_element_start, _handle_text, and _handle_element_end methods so that parser events are turned into method calls. (Otherwise, this is a subclass of &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt; and inherits all its methods.)</source>
          <target state="translated">此类（很小，请阅读源代码）重写Pod :: Simple的_handle_element_start，_handle_text和_handle_element_end方法，以便将解析器事件转换为方法调用。（否则，这是&lt;a href=&quot;../simple&quot;&gt;Pod :: Simple&lt;/a&gt;的子类，并继承其所有方法。）</target>
        </trans-unit>
        <trans-unit id="494e46870d49e2dc3a5f9a64f75952ec99423e9a" translate="yes" xml:space="preserve">
          <source>This class defines several methods for setting (and, occasionally, reading) the contents of an object. With two exceptions (discussed at the end of this section), these attributes are just for controlling the way searches are carried out.</source>
          <target state="translated">这个类定义了几种方法,用于设置(偶尔也用于读取)对象的内容。除了两个例外(在本节最后讨论),这些属性只是用来控制搜索的方式。</target>
        </trans-unit>
        <trans-unit id="1d32aad8f8251ef1db7bcc4b8f3feb324d9d1213" translate="yes" xml:space="preserve">
          <source>This class is NOT a subclass of Pod::Simple::HTML (nor of bad old Pod::Html) -- although it uses Pod::Simple::HTML for doing the conversion of each document.</source>
          <target state="translated">这个类不是Pod::Simple::HTML的子类(也不是旧的Pod::Html的子类)--尽管它使用Pod::Simple::HTML来完成每个文档的转换。</target>
        </trans-unit>
        <trans-unit id="b711767b4a974da1a1509d38f153220b0d62949c" translate="yes" xml:space="preserve">
          <source>This class is a formatter that takes Pod and renders it as RTF, good for viewing/printing in MSWord, WordPad/write.exe, TextEdit, etc.</source>
          <target state="translated">这个类是一个格式化器,它将Pod转换成RTF格式,适合在MSWord,WordPad/write.exe,TextEdit等软件中查看/打印。</target>
        </trans-unit>
        <trans-unit id="138981ec5228a60a4f53dbf829b51f5efd9f8a75" translate="yes" xml:space="preserve">
          <source>This class is a formatter that takes Pod and renders it as XHTML validating HTML.</source>
          <target state="translated">这个类是一个formatter,它接受Pod并将其渲染为XHTML验证的HTML。</target>
        </trans-unit>
        <trans-unit id="3d4c24315ad07b2a992c0858db0b7be768d0cc0b" translate="yes" xml:space="preserve">
          <source>This class is a formatter that takes Pod and renders it as wrapped plaintext.</source>
          <target state="translated">这个类是一个格式化器,它接收Pod并将其渲染为包装的明文。</target>
        </trans-unit>
        <trans-unit id="62abaee97c33098880e266351ef2fc532bf53875" translate="yes" xml:space="preserve">
          <source>This class is an internal interface only.</source>
          <target state="translated">该类只是一个内部接口。</target>
        </trans-unit>
        <trans-unit id="5e43c4bd22a6b18d8bc78626e236eaa142e2b822" translate="yes" xml:space="preserve">
          <source>This class is for checking the syntactic validity of Pod. It works by basically acting like a simple-minded version of &lt;a href=&quot;text&quot;&gt;Pod::Simple::Text&lt;/a&gt; that formats only the &quot;Pod Errors&quot; section (if Pod::Simple even generates one for the given document).</source>
          <target state="translated">此类用于检查Pod的语法有效性。它的工作原理基本上就像是&lt;a href=&quot;text&quot;&gt;Pod :: Simple :: Text的简单&lt;/a&gt;版本，仅格式化&amp;ldquo; Pod Errors&amp;rdquo;部分的格式（如果Pod :: Simple甚至为给定文档生成一个）。</target>
        </trans-unit>
        <trans-unit id="9b791e36572b7d483165e52086de0aff10cad7ba" translate="yes" xml:space="preserve">
          <source>This class is for dumping, as text, the events gotten from parsing a Pod document. This class is of interest to people writing Pod formatters based on Pod::Simple. It is useful for seeing exactly what events you get out of some Pod that you feed in.</source>
          <target state="translated">该类用于以文本形式转储从解析Pod文档中得到的事件。这个类对基于Pod::Simple编写Pod格式器的人很有兴趣。它对于查看你从一些Pod中得到的事件非常有用。</target>
        </trans-unit>
        <trans-unit id="a18cdad26fb8d235532c57fb43aa60327d80a50a" translate="yes" xml:space="preserve">
          <source>This class is for making an HTML rendering of a Pod document.</source>
          <target state="translated">该类用于制作Pod文档的HTML渲染。</target>
        </trans-unit>
        <trans-unit id="fd75675624091c3742f49bbeb8bbfb0c06a37c0a" translate="yes" xml:space="preserve">
          <source>This class is for using Pod::Simple to build a Pod processor -- but one that uses an interface based on a stream of token objects, instead of based on events.</source>
          <target state="translated">这个类是用来使用Pod::Simple来构建一个Pod处理器--但它使用的是基于token对象流的接口,而不是基于事件。</target>
        </trans-unit>
        <trans-unit id="44761047bfaa4c6cc438e77b4bb92131ad714c01" translate="yes" xml:space="preserve">
          <source>This class is inspired by XML::Parser's &quot;Tree&quot; parsing-style, although it doesn't use exactly the same LoL format.</source>
          <target state="translated">这个类的灵感来自于XML::Parser的 &quot;树 &quot;解析风格,尽管它没有使用完全相同的LoL格式。</target>
        </trans-unit>
        <trans-unit id="a9698adab813e0c4fae21452c7598015f3935b3d" translate="yes" xml:space="preserve">
          <source>This class is not of interest to general users.</source>
          <target state="translated">一般用户对这门课不感兴趣。</target>
        </trans-unit>
        <trans-unit id="2f2f6048d2f61aa8645bcc5ebd42e19fc8c8aea4" translate="yes" xml:space="preserve">
          <source>This class is of interest to people writing Pod formatters based on Pod::Simple.</source>
          <target state="translated">这门课对基于Pod::Simple编写Pod格式器的人很感兴趣。</target>
        </trans-unit>
        <trans-unit id="f63f889f338653b4ee33eb44dc0ee1133ee852ae" translate="yes" xml:space="preserve">
          <source>This class is of interest to people writing a Pod processor/formatter.</source>
          <target state="translated">这门课是编写Pod处理器/格式的人感兴趣的。</target>
        </trans-unit>
        <trans-unit id="6dca4f8907e7dbb28751ea149d9af37422c91f32" translate="yes" xml:space="preserve">
          <source>This class is that parses Pod and dumps just the text content. It is mainly meant for use by the Pod::Simple test suite, but you may find some other use for it.</source>
          <target state="translated">这个类是用来解析Pod和转储文本内容的。它主要用于Pod::Simple测试套件,但你可能会发现它的其他用途。</target>
        </trans-unit>
        <trans-unit id="5a51d38f10e103a9903a5853a79eae683ff646eb" translate="yes" xml:space="preserve">
          <source>This class is the workhorse of the &lt;a href=&quot;../../parser&quot;&gt;TAP::Parser&lt;/a&gt; system. Most TAP lines will be test lines and if &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; , then you have a bunch of methods at your disposal.</source>
          <target state="translated">此类是&lt;a href=&quot;../../parser&quot;&gt;TAP :: Parser&lt;/a&gt;系统的主力军。大多数TAP行都是测试行，如果 &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; ，那么您可以使用许多方法。</target>
        </trans-unit>
        <trans-unit id="6f581c5cd9d5c7598c0dcb3ca6436c9bd821c2c4" translate="yes" xml:space="preserve">
          <source>This class might turn out to be a temporary solution, but MM won't go away.</source>
          <target state="translated">这个班级可能会变成一个暂时的解决方案,但MM不会消失。</target>
        </trans-unit>
        <trans-unit id="24195eb4cea8857a411b60273a35c873f422dbe0" translate="yes" xml:space="preserve">
          <source>This class provides the one constructor, called &lt;code&gt;new&lt;/code&gt; . It takes no parameters:</source>
          <target state="translated">此类提供一个构造函数，称为 &lt;code&gt;new&lt;/code&gt; 。它不带任何参数：</target>
        </trans-unit>
        <trans-unit id="f30e23715125a3d5360cef7bf3e4022849622110" translate="yes" xml:space="preserve">
          <source>This class takes Pod and parses it, returning a parse tree made just of arrayrefs, and hashrefs, and strings.</source>
          <target state="translated">这个类接受Pod并对其进行解析,返回一个只由arrayrefs、hashrefs和字符串组成的解析树。</target>
        </trans-unit>
        <trans-unit id="9dbee182dfa76d92a94c69cd0858c1622ac2f770" translate="yes" xml:space="preserve">
          <source>This client is more complicated than the two we've done so far, but if you're on a system that supports the powerful &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; call, the solution isn't that rough. Once you've made the connection to whatever service you'd like to chat with, call &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; to clone your process. Each of these two identical process has a very simple job to do: the parent copies everything from the socket to standard output, while the child simultaneously copies everything from standard input to the socket. To accomplish the same thing using just one process would be</source>
          <target state="translated">这个客户端比到目前为止我们做过的两个客户端要复杂得多，但是如果您使用的系统支持强大的 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 调用，则解决方案并不那么困难。一旦建立了您想与之聊天的任何服务的连接，就可以调用 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 来克隆您的进程。这两个相同的过程中的每一个都有一个非常简单的工作：父级将所有内容从套接字复制到标准输出，而子级同时将所有内容从标准输入复制到套接字。仅使用一个过程即可完成同一件事</target>
        </trans-unit>
        <trans-unit id="ceec53b2ebb7603eb9ee71d9bde01119b83707cb" translate="yes" xml:space="preserve">
          <source>This clones the repository and makes a local copy in the</source>
          <target state="translated">这将克隆版本库,并在本机的</target>
        </trans-unit>
        <trans-unit id="5330da17cfc7cfcf64aab224d5b574c934e7ac2c" translate="yes" xml:space="preserve">
          <source>This code heavily adapted from an early version of perl5db.pl attributable to Larry Wall and the Perl Porters.</source>
          <target state="translated">这段代码大量改编自早期的 perl5db.pl 版本,归功于 Larry Wall 和 Perl Porters。</target>
        </trans-unit>
        <trans-unit id="11c4fc183eca8652881b1cb5b12c6ea249b79ebe" translate="yes" xml:space="preserve">
          <source>This code is intended for development only, and may not be portable even to all Unix variants. Also, it is an 80% solution, in that it isn't able to make all ops read only. Specifically it does not apply to op slabs belonging to &lt;code&gt;BEGIN&lt;/code&gt; blocks.</source>
          <target state="translated">该代码仅用于开发，甚至不能移植到所有Unix变体。另外，它是80％的解决方案，因为它不能使所有操作都只读。特别是，它不适用于属于 &lt;code&gt;BEGIN&lt;/code&gt; 块的操作平板。</target>
        </trans-unit>
        <trans-unit id="443071b2d9d382ee44392d30a6c9cc6944390654" translate="yes" xml:space="preserve">
          <source>This code is unusual in that most formatters completely discard this code and its content. Other formatters will render it with invisible codes that can be used in building an index of the current document.</source>
          <target state="translated">这段代码很不寻常,因为大多数格式化程序会完全丢弃这段代码及其内容。其他格式化程序会用不可见的代码来呈现它,这些代码可以用来建立当前文档的索引。</target>
        </trans-unit>
        <trans-unit id="ed77ac1105bfebc895982f70abdb5f07d0f61471" translate="yes" xml:space="preserve">
          <source>This code is unusual is that it should have no content. That is, a processor may complain if it sees &lt;code&gt;Z&amp;lt;potatoes&amp;gt;&lt;/code&gt; . Whether or not it complains, the</source>
          <target state="translated">此代码不寻常，因为它不应该包含任何内容。也就是说，如果处理器看到 &lt;code&gt;Z&amp;lt;potatoes&amp;gt;&lt;/code&gt; 则可能会抱怨。无论是否抱怨，</target>
        </trans-unit>
        <trans-unit id="9f748555f0c218e80f371f8622c90719bdf4c3e1" translate="yes" xml:space="preserve">
          <source>This code resides primarily in</source>
          <target state="translated">这个代码主要存在于</target>
        </trans-unit>
        <trans-unit id="b4ca79218fad07abe234bb2cecfbf2b9daaa8186" translate="yes" xml:space="preserve">
          <source>This code tries to return a new SV (which contains the value 42) if it should return a real value, or undef otherwise. Instead it has returned a NULL pointer which, somewhere down the line, will cause a segmentation violation, bus error, or just weird results. Change the zero to &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; in the first line and all will be well.</source>
          <target state="translated">如果此代码应返回实值，则尝试返回新的SV（包含值42），否则返回undef。取而代之的是，它返回了一个NULL指针，该指针在行的某处将导致分段违规，总线错误或只是奇怪的结果。在第一行中将零更改为 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; ，一切都会好起来。</target>
        </trans-unit>
        <trans-unit id="6b0496da28a3ec6a32260558d3028edcf275c0a4" translate="yes" xml:space="preserve">
          <source>This combination of options may also be specified thus</source>
          <target state="translated">这种选项的组合也可以这样指定</target>
        </trans-unit>
        <trans-unit id="738a4e0887c40771b0a61f4f0df6d45e56b8d5cf" translate="yes" xml:space="preserve">
          <source>This combination performs the work of the legacy functions gethostbyname() and inet_ntoa().</source>
          <target state="translated">这个组合执行了传统函数gethostbyname()和inet_ntoa()的工作。</target>
        </trans-unit>
        <trans-unit id="d728ee6330c55e20ceb083fe7c0710810e2932ca" translate="yes" xml:space="preserve">
          <source>This command indicates that an item in a list begins here. Formatting codes are processed. The semantics of the (optional) text in the remainder of this paragraph are explained in the &lt;a href=&quot;#About-%3dover...%3dback-Regions&quot;&gt;About =over...=back Regions&lt;/a&gt; section, further below. Examples:</source>
          <target state="translated">此命令指示列表中的项目从此处开始。格式化代码已处理。本段其余部分中（可选）文本的语义在下面的&amp;ldquo; &lt;a href=&quot;#About-%3dover...%3dback-Regions&quot;&gt;关于= over ... = back区域&amp;rdquo;&lt;/a&gt;部分中进行了说明。例子：</target>
        </trans-unit>
        <trans-unit id="4a355ff290cc8d5e2710e8069a06d654602bb061" translate="yes" xml:space="preserve">
          <source>This command indicates that the text in the remainder of the paragraph is a heading. That text may contain formatting codes. Examples:</source>
          <target state="translated">该命令表示该段其余部分的文字为标题。该文本可能包含格式代码。例如:</target>
        </trans-unit>
        <trans-unit id="c6da60e4854fba0e9da1ba094a38fc435654e60e" translate="yes" xml:space="preserve">
          <source>This command indicates that this is the end of the region begun by the most recent &quot;=over&quot; command. It permits no text after the &quot;=back&quot; command.</source>
          <target state="translated">该命令表示最近的&quot;=over &quot;命令开始的区域结束。在&quot;=back &quot;命令之后不允许有任何文字。</target>
        </trans-unit>
        <trans-unit id="19be29c945bbd16c098b73b780bb343e863492ff" translate="yes" xml:space="preserve">
          <source>This command indicates that this is the start of a list/indent region. If there is any text following the &quot;=over&quot;, it must consist of only a nonzero positive numeral. The semantics of this numeral is explained in the &lt;a href=&quot;#About-%3dover...%3dback-Regions&quot;&gt;About =over...=back Regions&lt;/a&gt; section, further below. Formatting codes are not expanded. Examples:</source>
          <target state="translated">此命令指示这是列表/缩进区域的开始。如果在&amp;ldquo; = over&amp;rdquo;之后有任何文本，则该文本必须仅包含一个非零的正数。该数字的语义在下面的&amp;ldquo; &lt;a href=&quot;#About-%3dover...%3dback-Regions&quot;&gt;关于= over ... = back区域&amp;rdquo;&lt;/a&gt;部分中进行了说明。格式代码不会扩展。例子：</target>
        </trans-unit>
        <trans-unit id="7ff4d3408bd7bdb5ab335d1f0aa8564e21d93c8d" translate="yes" xml:space="preserve">
          <source>This command indicates that this line is the end of this previously started Pod block. If there is any text after &quot;=cut&quot; on the line, it must be ignored. Examples:</source>
          <target state="translated">这条命令表示这一行是之前启动的这个Pod块的结束。如果该行&quot;=cut &quot;后面有任何文字,必须忽略。例子</target>
        </trans-unit>
        <trans-unit id="3f41d49fdd2a10822f19964c9959582847611ffe" translate="yes" xml:space="preserve">
          <source>This command indicates that this paragraph begins a Pod block. (If we are already in the middle of a Pod block, this command has no effect at all.) If there is any text in this command paragraph after &quot;=pod&quot;, it must be ignored. Examples:</source>
          <target state="translated">这个命令表示这一段开始一个Pod块。如果我们已经在一个Pod块的中间,这条命令就没有任何效果)。如果该命令段中&quot;=pod &quot;之后有任何文字,必须忽略。例子</target>
        </trans-unit>
        <trans-unit id="8a99ea1513aed41e6edc9e12797ae7dfeaac42f6" translate="yes" xml:space="preserve">
          <source>This command is used for declaring the encoding of a document. Most users won't need this; but if your encoding isn't US-ASCII, then put a &lt;code&gt;=encoding &lt;i&gt;encodingname&lt;/i&gt;&lt;/code&gt; command very early in the document so that pod formatters will know how to decode the document. For</source>
          <target state="translated">此命令用于声明文档的编码。大多数用户将不需要它。但是，如果您的编码不是US-ASCII，则可以在文档的最前面放置 &lt;code&gt;=encoding &lt;i&gt;encodingname&lt;/i&gt;&lt;/code&gt; 命令，以便Pod格式化程序知道如何解码文档。对于</target>
        </trans-unit>
        <trans-unit id="cc900c104077e4a6a7ca5f06e5d70661d00910f9" translate="yes" xml:space="preserve">
          <source>This command, which should occur early in the document (at least before any non-US-ASCII data!), declares that this document is encoded in the encoding</source>
          <target state="translated">这条命令应该出现在文档的早期(至少在任何非US-ASCII数据之前!),它声明这个文档是用编码的</target>
        </trans-unit>
        <trans-unit id="a044d113549cfc62bab49938c5d884a6268cf948" translate="yes" xml:space="preserve">
          <source>This commands provides a statistical overview over recent download activities. The data for this is collected in the YAML file &lt;code&gt;FTPstats.yml&lt;/code&gt; in your &lt;code&gt;cpan_home&lt;/code&gt; directory. If no YAML module is configured or YAML not installed, no stats are provided.</source>
          <target state="translated">此命令提供有关最近下载活动的统计概述。此数据收集在 &lt;code&gt;cpan_home&lt;/code&gt; 目录的YAML文件 &lt;code&gt;FTPstats.yml&lt;/code&gt; 中。如果未配置YAML模块或未安装YAML，则不会提供任何统计信息。</target>
        </trans-unit>
        <trans-unit id="8ea20acdc8121360e07a3ca6ca2abb72ed9a4374" translate="yes" xml:space="preserve">
          <source>This compiler backend prints the internal OPs of a Perl program's syntax tree in one of several space-efficient text formats suitable for debugging the inner workings of perl or other compiler backends. It can print OPs in the order they appear in the OP tree, in the order they will execute, or in a text approximation to their tree structure, and the format of the information displayed is customizable. Its function is similar to that of perl's &lt;b&gt;-Dx&lt;/b&gt; debugging flag or the &lt;b&gt;B::Terse&lt;/b&gt; module, but it is more sophisticated and flexible.</source>
          <target state="translated">该编译器后端以适合于调试Perl或其他编译器后端内部工作的几种节省空间的文本格式之一，打印Perl程序语法树的内部OP。它可以按照它们在OP树中出现的顺序，执行顺序或与它们的树结构近似的文本来打印OP，并且所显示信息的格式是可自定义的。它的功能类似于perl的&lt;b&gt;-Dx&lt;/b&gt;调试标志或&lt;b&gt;B :: Terse&lt;/b&gt;模块的功能，但是它更加复杂和灵活。</target>
        </trans-unit>
        <trans-unit id="49048e5c36c04df148e3cdcc3f896c82e8922e40" translate="yes" xml:space="preserve">
          <source>This compiler is typically run by the makefiles created by &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; or by &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Build&quot;&gt;Module::Build&lt;/a&gt; or other Perl module build tools.</source>
          <target state="translated">该编译器通常由&lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt;创建的makefile 或&lt;a href=&quot;http://search.cpan.org/perldoc/Module::Build&quot;&gt;Module :: Build&lt;/a&gt;或其他Perl模块构建工具运行。</target>
        </trans-unit>
        <trans-unit id="811fc2387a18f3ccb2c99535bb74afa37f5a7e14" translate="yes" xml:space="preserve">
          <source>This condition is called a deadlock, and it occurs whenever two or more threads are trying to get locks on resources that the others own. Each thread will block, waiting for the other to release a lock on a resource. That never happens, though, since the thread with the resource is itself waiting for a lock to be released.</source>
          <target state="translated">这种情况称为死锁,每当两个或多个线程试图获得其他线程拥有的资源的锁时,就会发生死锁。每个线程都会阻塞,等待对方释放资源上的锁。不过这种情况永远不会发生,因为拥有资源的线程本身也在等待锁被释放。</target>
        </trans-unit>
        <trans-unit id="faa53aa7f128fff59cd7dcb34623ce5e613b1979" translate="yes" xml:space="preserve">
          <source>This conditionally defines &lt;code&gt;HAS_BUILTIN_CHOOSE_EXPR&lt;/code&gt; , which indicates that the compiler supports __builtin_choose_expr(x,y,z). This built-in function is analogous to the &lt;code&gt;x?y:z&lt;/code&gt; operator in C, except that the expression returned has its type unaltered by promotion rules. Also, the built-in function does not evaluate the expression that was not chosen.</source>
          <target state="translated">这有条件地定义了 &lt;code&gt;HAS_BUILTIN_CHOOSE_EXPR&lt;/code&gt; ，这表明编译器支持__builtin_choose_expr（x，y，z）。此内置函数类似于C中的 &lt;code&gt;x?y:z&lt;/code&gt; 运算符，不同之处在于返回的表达式的类型不受升级规则的影响。此外，内置函数不会评估未选择的表达式。</target>
        </trans-unit>
        <trans-unit id="8177d32c94f6808dc1bba5e1e003e2e654d1454a" translate="yes" xml:space="preserve">
          <source>This conditionally defines &lt;code&gt;HAS_BUILTIN_EXPECT&lt;/code&gt; , which indicates that the compiler supports __builtin_expect(exp,c). You may use __builtin_expect to provide the compiler with branch prediction information.</source>
          <target state="translated">这有条件地定义了 &lt;code&gt;HAS_BUILTIN_EXPECT&lt;/code&gt; ，这表明编译器支持__builtin_expect（exp，c）。您可以使用__builtin_expect为编译器提供分支预测信息。</target>
        </trans-unit>
        <trans-unit id="3e85ff206a230f535cdc1e1b660d9e31b004675c" translate="yes" xml:space="preserve">
          <source>This construct cannot be used within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (or the &lt;code&gt;/l&lt;/code&gt; regex modifier).</source>
          <target state="translated">不能在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; （或 &lt;code&gt;/l&lt;/code&gt; regex修饰符）的范围内使用此构造。</target>
        </trans-unit>
        <trans-unit id="f8fed69726a17c92a263e748b2d7fa3336a3e37f" translate="yes" xml:space="preserve">
          <source>This construct is useful when you want to capture one of a number of alternative matches.</source>
          <target state="translated">当你想捕捉多个备选匹配中的一个时,这个结构很有用。</target>
        </trans-unit>
        <trans-unit id="89cfaa9b31ac24d949cb1a2ef0db748a527694e4" translate="yes" xml:space="preserve">
          <source>This construction is</source>
          <target state="translated">这种结构是</target>
        </trans-unit>
        <trans-unit id="78c7683a763192abf9645014c7b058753006e735" translate="yes" xml:space="preserve">
          <source>This constructor lets its parent class do the actual object construction.</source>
          <target state="translated">这个构造函数让它的父类进行实际的对象构造。</target>
        </trans-unit>
        <trans-unit id="4bf27879428ff426e547cd9ab897b5c2de43f4ae" translate="yes" xml:space="preserve">
          <source>This constructs a language handle. You usually &lt;b&gt;don't&lt;/b&gt; call this directly, but instead let &lt;code&gt;get_handle&lt;/code&gt; find a language class to &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; and to then call -&amp;gt;new on.</source>
          <target state="translated">这构造了一个语言句柄。您通常&lt;b&gt;不&lt;/b&gt;直接调用它，而是让 &lt;code&gt;get_handle&lt;/code&gt; 查找要 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 的语言类，然后调用-&amp;gt; new on。</target>
        </trans-unit>
        <trans-unit id="3edc7f7dd753392a74ab3c329050e0ec08dcdba9" translate="yes" xml:space="preserve">
          <source>This controls how verbose to be during batch conversion, as far as notes to STDOUT (or whatever is &lt;code&gt;&lt;a href=&quot;../../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;'d) about how the conversion is going. If 0, no progress information is printed. If 1 (the default value), some progress information is printed. Higher values print more information.</source>
          <target state="translated">这控制了批量转换过程中的详细程度，就STDOUT（或 &lt;code&gt;&lt;a href=&quot;../../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 'd）所做的转换进行了说明。如果为0，则不打印进度信息。如果为1（默认值），则会打印一些进度信息。较高的值将打印更多信息。</target>
        </trans-unit>
        <trans-unit id="ff7a4f63a01fbc1cdd9d161f843ad25c0052f17f" translate="yes" xml:space="preserve">
          <source>This controls whether &lt;code&gt;Module::Load::Conditional&lt;/code&gt; checks if a dual-life core module has been deprecated. If this is set to true &lt;code&gt;check_install&lt;/code&gt; will return false to &lt;code&gt;uptodate&lt;/code&gt; , if a dual-life module is found to be loaded from &lt;code&gt;$Config{privlibexp}&lt;/code&gt;</source>
          <target state="translated">这控制是否 &lt;code&gt;Module::Load::Conditional&lt;/code&gt; 检查是否已弃用双寿命核心模块。如果设置为true &lt;code&gt;check_install&lt;/code&gt; 将返回false， &lt;code&gt;uptodate&lt;/code&gt; ，如果发现双寿命模块从中加载 &lt;code&gt;$Config{privlibexp}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b4114328d4769af34ebf3741b18df472503df04" translate="yes" xml:space="preserve">
          <source>This controls whether &lt;code&gt;Module::Load::Conditional&lt;/code&gt; checks your &lt;code&gt;%INC&lt;/code&gt; hash to see if a module is available. By default, only &lt;code&gt;@INC&lt;/code&gt; is scanned to see if a module is physically on your filesystem, or available via an &lt;code&gt;@INC-hook&lt;/code&gt; . Setting this variable to &lt;code&gt;true&lt;/code&gt; will trust any entries in &lt;code&gt;%INC&lt;/code&gt; and return them for you.</source>
          <target state="translated">这控制 &lt;code&gt;Module::Load::Conditional&lt;/code&gt; 是否检查您的 &lt;code&gt;%INC&lt;/code&gt; 哈希值以查看模块是否可用。默认情况下，仅扫描 &lt;code&gt;@INC&lt;/code&gt; 来查看模块是否在文件系统上，或者可以通过 &lt;code&gt;@INC-hook&lt;/code&gt; 。将此变量设置为 &lt;code&gt;true&lt;/code&gt; 将信任 &lt;code&gt;%INC&lt;/code&gt; 中的所有条目并为您返回它们。</target>
        </trans-unit>
        <trans-unit id="9c4381fad7d89f422c37ccba3ee1b2f92eba8443" translate="yes" xml:space="preserve">
          <source>This controls whether IPC::Cmd will print any output from the commands to the screen or not. The default is 0.</source>
          <target state="translated">此项控制 IPC::Cmd 是否将命令的任何输出打印到屏幕上。默认值为 0。</target>
        </trans-unit>
        <trans-unit id="c156076360b54f8a8977c57dc77de47486be1ac3" translate="yes" xml:space="preserve">
          <source>This controls whether Module::Load::Conditional will issue warnings and explanations as to why certain things may have failed. If you set it to 0, Module::Load::Conditional will not output any warnings. The default is 0;</source>
          <target state="translated">这控制了 Module::Load::Conditional 是否会发出警告和解释,说明某些事情为什么会失败。如果将其设置为 0,则 Module::Load::Conditional 不会输出任何警告。默认值为0。</target>
        </trans-unit>
        <trans-unit id="b49fb12849ceb3c435af21ba21b9e8d24214fd70" translate="yes" xml:space="preserve">
          <source>This controls whether Module::Load::Conditional will try to parse (and eval) the version from the module you're trying to load.</source>
          <target state="translated">这控制了 Module::Load::Conditional 是否会尝试解析(和评估)您正在尝试加载的模块的版本。</target>
        </trans-unit>
        <trans-unit id="d9aae25fb78fe9990ffb44145098a21f55aa720e" translate="yes" xml:space="preserve">
          <source>This controls whether Params::Check will issue warnings and explanations as to why certain things may have failed. If you set it to 0, Params::Check will not output any warnings.</source>
          <target state="translated">这控制了Params::Check是否会发出警告和解释为什么某些事情会失败。如果你把它设置为0,Params::Check将不会输出任何警告。</target>
        </trans-unit>
        <trans-unit id="8aa3d4d74657a46a0b2bcece8a25683b9b4d5103" translate="yes" xml:space="preserve">
          <source>This controls whether all output of a command should also be printed to STDOUT/STDERR or should only be trapped in buffers (NOTE: buffers require &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC::Run&lt;/a&gt; to be installed, or your system able to work with &lt;a href=&quot;open3&quot;&gt;IPC::Open3&lt;/a&gt;).</source>
          <target state="translated">这控制了命令的所有输出是否也应该打印到STDOUT / STDERR还是仅应困在缓冲区中（注意：缓冲区需要安装&lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC :: Run&lt;/a&gt;或系统能够与&lt;a href=&quot;open3&quot;&gt;IPC :: Open3一起使用&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="732d2e4b2658c0a2ec91db3c054e26236d0390f1" translate="yes" xml:space="preserve">
          <source>This controls whether imports the functions of a loaded modules to the caller package. The default is no importing any functions.</source>
          <target state="translated">控制是否将加载模块的函数导入到调用包中。默认值是不导入任何函数。</target>
        </trans-unit>
        <trans-unit id="eb78f49655da0a3543996010fb5198aba12c2274" translate="yes" xml:space="preserve">
          <source>This controls whether or not each HTML page is liable to have a little table of contents at the top (which we call an &quot;index&quot; for historical reasons). This is true by default.</source>
          <target state="translated">这控制了每个HTML页面是否会在顶部有一个小目录(由于历史原因,我们称之为 &quot;索引&quot;)。默认情况下,这是真的。</target>
        </trans-unit>
        <trans-unit id="d18f8fcaf7759aa328d11a1f1e92e835b3d9557f" translate="yes" xml:space="preserve">
          <source>This controls whether warnings should be printed if a module failed to load. The default is to use the value of $Module::Load::Conditional::VERBOSE.</source>
          <target state="translated">控制是否在模块加载失败时打印警告。默认值是使用$Module::Load::Conditional::VERBOSE。</target>
        </trans-unit>
        <trans-unit id="4ff7f0c70685518180af334112b2fe58a44a4fdd" translate="yes" xml:space="preserve">
          <source>This copyright does not prohibit distribution of any version of Perl containing this extension under the terms of the GNU or Artistic licenses.</source>
          <target state="translated">此版权不禁止在GNU或艺术许可证的条款下发布包含此扩展的任何Perl版本。</target>
        </trans-unit>
        <trans-unit id="e07ca9a36ef5f49f5e95795b2568b38574fd37e2" translate="yes" xml:space="preserve">
          <source>This corresponds to clearerr(), i.e., clears 'error' and (usually) 'eof' flags for the &quot;stream&quot;. Does not return a value.</source>
          <target state="translated">这与clearerr()相对应,即清除 &quot;流 &quot;的'error'和(通常)'eof'标志。不返回一个值。</target>
        </trans-unit>
        <trans-unit id="a832f3c37512b00bc489449027088839617ff5af" translate="yes" xml:space="preserve">
          <source>This corresponds to feof(). Returns a true/false indication of whether the handle is at end of file. For terminal devices this may or may not be &quot;sticky&quot; depending on the implementation. The flag is cleared by PerlIO_seek(), or PerlIO_rewind().</source>
          <target state="translated">这与feof()相对应。返回句柄是否在文件末尾的真/假指示。对于终端设备来说,这可能是或不是 &quot;粘性 &quot;的,这取决于实现。这个标志会被PerlIO_seek()或PerlIO_rewind()清除。</target>
        </trans-unit>
        <trans-unit id="baeb66e5af4f3d77be2f1ed10348f03a4ed016a5" translate="yes" xml:space="preserve">
          <source>This corresponds to ferror(). Returns a true/false indication of whether there has been an IO error on the handle.</source>
          <target state="translated">这与ferror()相对应。返回句柄上是否存在IO错误的真/假指示。</target>
        </trans-unit>
        <trans-unit id="bb12a0ca3665432e7ae210e2f30b098e3c60f423" translate="yes" xml:space="preserve">
          <source>This corresponds to fflush(). Sends any buffered write data to the underlying file. If called with &lt;code&gt;NULL&lt;/code&gt; this may flush all open streams (or core dump with some USE_STDIO implementations). Calling on a handle open for read only, or on which last operation was a read of some kind may lead to undefined behaviour on some USE_STDIO implementations. The USE_PERLIO (layers) implementation tries to behave better: it flushes all open streams when passed &lt;code&gt;NULL&lt;/code&gt; , and attempts to retain data on read streams either in the buffer or by seeking the handle to the current logical position.</source>
          <target state="translated">这对应于fflush（）。将所有缓冲的写数据发送到基础文件。如果使用 &lt;code&gt;NULL&lt;/code&gt; 调用，则可能会刷新所有打开的流（或使用某些USE_STDIO实现的核心转储）。调用为只读而打开的句柄，或对其进行最后一次操作的某种类型的读取，可能会导致某些USE_STDIO实现上的未定义行为。 USE_PERLIO（层）实现尝试表现得更好：在传递 &lt;code&gt;NULL&lt;/code&gt; 时，它将刷新所有打开的流，并尝试通过缓冲区或通过查找当前逻辑位置的句柄来保留读取流上的数据。</target>
        </trans-unit>
        <trans-unit id="9e414890b7f22b1b4083f4007de6555d9d071db1" translate="yes" xml:space="preserve">
          <source>This corresponds to fileno(), note that on some platforms, the meaning of &quot;fileno&quot; may not match Unix. Returns -1 if the handle has no open descriptor associated with it.</source>
          <target state="translated">这与fileno()相对应,注意在某些平台上,&quot;fileno &quot;的含义可能与Unix不一致。如果句柄没有与之相关联的开放描述符,则返回-1。</target>
        </trans-unit>
        <trans-unit id="5f4554adde4cea2591eaa99c7438bd7a745a0b3f" translate="yes" xml:space="preserve">
          <source>This corresponds to fseek(). Sends buffered write data to the underlying file, or discards any buffered read data, then positions the file descriptor as specified by &lt;b&gt;offset&lt;/b&gt; and &lt;b&gt;whence&lt;/b&gt; (sic). This is the correct thing to do when switching between read and write on the same handle (see issues with PerlIO_flush() above). Offset is of type &lt;code&gt;Off_t&lt;/code&gt; which is a perl Configure value which may not be same as stdio's &lt;code&gt;off_t&lt;/code&gt; .</source>
          <target state="translated">这对应于fseek（）。将缓冲的写数据发送到基础文件，或丢弃所有缓冲的读数据，然后按&lt;b&gt;offset&lt;/b&gt;和&lt;b&gt;whence&lt;/b&gt;（sic）指定的位置&lt;b&gt;放置&lt;/b&gt;文件描述符。当在同一句柄上进行读写之间切换时，这是正确的做法（请参见上面的PerlIO_flush（）问题）。偏移量为 &lt;code&gt;Off_t&lt;/code&gt; 类型，这是一个Perl配置值，可能与stdio的 &lt;code&gt;off_t&lt;/code&gt; 不同。</target>
        </trans-unit>
        <trans-unit id="dd9bee6b04c387fd0085a9f7aa8ff48a5f034283" translate="yes" xml:space="preserve">
          <source>This corresponds to ftell(). Returns the current file position, or (Off_t) -1 on error. May just return value system &quot;knows&quot; without making a system call or checking the underlying file descriptor (so use on shared file descriptors is not safe without a PerlIO_seek()). Return value is of type &lt;code&gt;Off_t&lt;/code&gt; which is a perl Configure value which may not be same as stdio's &lt;code&gt;off_t&lt;/code&gt; .</source>
          <target state="translated">这对应于ftell（）。返回当前文件位置，如果出错则返回（Off_t）-1。可能只是返回值系统&amp;ldquo;知道&amp;rdquo;而没有进行系统调用或检查基础文件描述符（因此，在没有PerlIO_seek（）的情况下，在共享文件描述符上使用是不安全的）。返回值的类型为 &lt;code&gt;Off_t&lt;/code&gt; ，这是一个Perl配置值，可能与stdio的 &lt;code&gt;off_t&lt;/code&gt; 不同。</target>
        </trans-unit>
        <trans-unit id="a3583e8644f865d149cd4eb31d670f437a6e26eb" translate="yes" xml:space="preserve">
          <source>This corresponds to getc(). Despite the c in the name only byte range 0..0xFF is supported. Returns the character read or -1 (&lt;code&gt;EOF&lt;/code&gt; ) on error.</source>
          <target state="translated">这对应于getc（）。尽管名称中为c，但仅支持字节范围0..0xFF。返回读取的字符或错误时返回-1（ &lt;code&gt;EOF&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e1cbd65b62177115f422eaf8fe4754328fbc6b9b" translate="yes" xml:space="preserve">
          <source>This corresponds to rewind(). It is usually defined as being</source>
          <target state="translated">这与rewind()相对应。它通常被定义为</target>
        </trans-unit>
        <trans-unit id="93c7ee35566034261e1234fcee65abc1e334abb8" translate="yes" xml:space="preserve">
          <source>This corresponds to setlinebuf(). Does not return a value. What constitutes a &quot;line&quot; is implementation dependent but usually means that writing &quot;\n&quot; flushes the buffer. What happens with things like &quot;this\nthat&quot; is uncertain. (Perl core uses it</source>
          <target state="translated">这与setlinebuf()相对应。不返回一个值。什么是 &quot;行&quot;,取决于实现,但通常意味着写&quot;\n &quot;会刷新缓冲区。像 &quot;this/nthat &quot;这样的东西会发生什么是不确定的。(Perl核心使用它</target>
        </trans-unit>
        <trans-unit id="c130282a86007cfef5f589b0d598e97fc7e10899" translate="yes" xml:space="preserve">
          <source>This corresponds to tmpfile(), i.e., returns an anonymous PerlIO or NULL on error. The system will attempt to automatically delete the file when closed. On Unix the file is usually &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;-ed just after it is created so it does not matter how it gets closed. On other systems the file may only be deleted if closed via PerlIO_close() and/or the program exits via &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;. Depending on the implementation there may be &quot;race conditions&quot; which allow other processes access to the file, though in general it will be safer in this regard than ad. hoc. schemes.</source>
          <target state="translated">这对应于tmpfile（），即在错误时返回匿名PerlIO或NULL。关闭后，系统将尝试自动删除文件。在Unix上，文件通常在创建后立即 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 因此它的关闭方式无关紧要。在其他系统上，只有通过PerlIO_close（）关闭文件和/或通过 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 退出程序时，才可以删除文件。取决于实现方式，可能存在&amp;ldquo;竞争条件&amp;rdquo;，该条件允许其他进程访问文件，尽管通常在这方面比广告更安全。临时计划。</target>
        </trans-unit>
        <trans-unit id="327b626f972edcc8578bc2302697191125c0290f" translate="yes" xml:space="preserve">
          <source>This corresponds to ungetc(). Note that arguments have been revised to have &quot;file&quot; first. Arranges that next read operation will return the byte &lt;b&gt;c&lt;/b&gt;. Despite the implied &quot;character&quot; in the name only values in the range 0..0xFF are defined. Returns the byte &lt;b&gt;c&lt;/b&gt; on success or -1 (&lt;code&gt;EOF&lt;/code&gt; ) on error. The number of bytes that can be &quot;pushed back&quot; may vary, only 1 character is certain, and then only if it is the last character that was read from the handle.</source>
          <target state="translated">这对应于ungetc（）。请注意，参数已修改为首先具有&amp;ldquo;文件&amp;rdquo;。安排下一次读取操作将返回字节&lt;b&gt;c&lt;/b&gt;。尽管名称中暗含了&amp;ldquo;字符&amp;rdquo;，但仅定义了0..0xFF范围内的值。成功返回字节&lt;b&gt;c&lt;/b&gt;，错误返回-1（ &lt;code&gt;EOF&lt;/code&gt; ）。可以&amp;ldquo;回退&amp;rdquo;的字节数可能会有所不同，只有1个字符是确定的，然后才是从句柄中读取的最后一个字符。</target>
        </trans-unit>
        <trans-unit id="d8f57342ffddc378f45e967d08a4b40a9028441d" translate="yes" xml:space="preserve">
          <source>This could, of course, be more legibly written with the &lt;code&gt;/x&lt;/code&gt; modifier, adding whitespace and comments. Here it is expanded, courtesy of Fred Curtis.</source>
          <target state="translated">当然，可以使用 &lt;code&gt;/x&lt;/code&gt; 修饰符，添加空格和注释，使其更清晰易读。此处由Fred Curtis进行了扩展。</target>
        </trans-unit>
        <trans-unit id="ac65bf824b65194ff0a99fd92e3e036111f8e8a9" translate="yes" xml:space="preserve">
          <source>This counterintuitive behavior has been fixed in perl v5.8.1.</source>
          <target state="translated">这个反直觉的行为在perl v5.8.1中得到了修正。</target>
        </trans-unit>
        <trans-unit id="4d26884badcfad89a2f88ee752f4bee54862ec7a" translate="yes" xml:space="preserve">
          <source>This creates a handler for the attribute &lt;code&gt;:Loud&lt;/code&gt; in the class LoudDecl. Thereafter, any subroutine declared with a &lt;code&gt;:Loud&lt;/code&gt; attribute in the class LoudDecl:</source>
          <target state="translated">这将为类LoudDecl中的 &lt;code&gt;:Loud&lt;/code&gt; 属性创建一个处理程序。此后，在类LoudDecl中使用 &lt;code&gt;:Loud&lt;/code&gt; 属性声明的任何子例程：</target>
        </trans-unit>
        <trans-unit id="87fa03371108789e3d1ff265f81c30f8fb7e2b16" translate="yes" xml:space="preserve">
          <source>This creates a new thread (&lt;code&gt;$thr2&lt;/code&gt; ) that inherits the stack size from an existing thread (&lt;code&gt;$thr1&lt;/code&gt; ). This is shorthand for the following:</source>
          <target state="translated">这将创建一个新线程（ &lt;code&gt;$thr2&lt;/code&gt; ），该线程继承现有线程（ &lt;code&gt;$thr1&lt;/code&gt; ）的堆栈大小。这是以下各项的简写：</target>
        </trans-unit>
        <trans-unit id="0ee76e6a741e92139c43f1e221ed11b509991786" translate="yes" xml:space="preserve">
          <source>This database type allows arbitrary key/value pairs to be stored in data files. This is equivalent to the functionality provided by other hashing packages like DBM, NDBM, ODBM, GDBM, and SDBM. Remember though, the files created using DB_HASH are not compatible with any of the other packages mentioned.</source>
          <target state="translated">这种数据库类型允许在数据文件中存储任意的键/值对。这相当于其他哈希包提供的功能,如DBM、NDBM、ODBM、GDBM和SDBM。但请记住,使用DB_HASH创建的文件与上述任何其他包都不兼容。</target>
        </trans-unit>
        <trans-unit id="3807b81d9c773a6c5335f9e71e920114a654bcff" translate="yes" xml:space="preserve">
          <source>This debugger prints a number which increments for each statement encountered and waits for you to hit a newline before continuing to the next statement.</source>
          <target state="translated">这个调试器会打印一个数字,每遇到一条语句都会递增,并等待你打一个新行后再继续下一条语句。</target>
        </trans-unit>
        <trans-unit id="67c09da3f20ea7878643178c10aa0a6e33cc924b" translate="yes" xml:space="preserve">
          <source>This declares a block of tests that might be skipped, $how_many tests there are, $why and under what $condition to skip them. An example is the easiest way to illustrate:</source>
          <target state="translated">这声明了一个可能被跳过的测试块,$how_many测试,$why以及在什么条件下$跳过它们。一个例子是最简单的说明方式。</target>
        </trans-unit>
        <trans-unit id="44521e30f7e690cd5dc65c30814c4cee699cd60e" translate="yes" xml:space="preserve">
          <source>This decomposition may be an intermediate one whose components are also decomposable. Use &lt;a href=&quot;normalize&quot;&gt;Unicode::Normalize&lt;/a&gt; to get the final decomposition in one step.</source>
          <target state="translated">该分解可以是中间分解，其组分也可分解。使用&lt;a href=&quot;normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt;一步完成最终分解。</target>
        </trans-unit>
        <trans-unit id="97bd528541645ff3d464e572f5a4805e2ee9bc4c" translate="yes" xml:space="preserve">
          <source>This default can be overridden on a per-number basis by calling the &lt;code&gt;display_format&lt;/code&gt; method instead. As before, not supplying any argument returns the current display style for this number. Otherwise whatever you specify will be the new display style for</source>
          <target state="translated">可以通过调用 &lt;code&gt;display_format&lt;/code&gt; 方法来逐个覆盖此默认值。和以前一样，不提供任何参数将返回此数字的当前显示样式。否则，您指定的任何内容都将是的新显示样式</target>
        </trans-unit>
        <trans-unit id="b13fed4037708b058149d6d54239c3578805f852" translate="yes" xml:space="preserve">
          <source>This demonstrates how &lt;code&gt;SUPER&lt;/code&gt; is resolved. Even though the object is blessed into the &lt;code&gt;C&lt;/code&gt; class, the &lt;code&gt;speak()&lt;/code&gt; method in the &lt;code&gt;B&lt;/code&gt; class can still call &lt;code&gt;SUPER::speak()&lt;/code&gt; and expect it to correctly look in the parent class of &lt;code&gt;B&lt;/code&gt; (i.e the class the method call is in), not in the parent class of &lt;code&gt;C&lt;/code&gt; (i.e. the class the object belongs to).</source>
          <target state="translated">这说明了如何解决 &lt;code&gt;SUPER&lt;/code&gt; 。即使对象被祝福到 &lt;code&gt;C&lt;/code&gt; 类中， &lt;code&gt;B&lt;/code&gt; 类中的 &lt;code&gt;speak()&lt;/code&gt; 方法仍然可以调用 &lt;code&gt;SUPER::speak()&lt;/code&gt; 并期望它正确地查看 &lt;code&gt;B&lt;/code&gt; 的父类（即该方法调用所在的类） ），而不是在 &lt;code&gt;C&lt;/code&gt; 的父类（即对象所属的类）中。</target>
        </trans-unit>
        <trans-unit id="5a18b47e8bc86d748a4aab67a43edef686b92a3f" translate="yes" xml:space="preserve">
          <source>This depends on the tied hash's implementation of EXISTS(). For example, there isn't the concept of undef with hashes that are tied to DBM* files. It also means that exists() and defined() do the same thing with a DBM* file, and what they end up doing is not what they do with ordinary hashes.</source>
          <target state="translated">这取决于绑定的哈希对 EXISTS()的实现。例如,与DBM*文件绑定的哈希就没有undef的概念。这也就意味着,exist()和defined()对DBM*文件做的事情是一样的,它们最终做的事情和对普通哈希做的事情是不一样的。</target>
        </trans-unit>
        <trans-unit id="9d4bc0de5af18f612ccd2a5cae826c99487fcbf8" translate="yes" xml:space="preserve">
          <source>This depends on which operating system your program is running on. In the case of Unix, the serial ports will be accessible through files in &lt;code&gt;/dev&lt;/code&gt; ; on other systems, device names will doubtless differ. Several problem areas common to all device interaction are the following:</source>
          <target state="translated">这取决于您的程序在哪个操作系统上运行。对于Unix，可以通过 &lt;code&gt;/dev&lt;/code&gt; 中的文件访问串行端口。在其他系统上，设备名称无疑会有所不同。以下是所有设备交互所共有的几个问题区域：</target>
        </trans-unit>
        <trans-unit id="d5829cc9fcaba21dee6f9d7f5a98f9ac945f1487" translate="yes" xml:space="preserve">
          <source>This description is not updated often (since 5.6.1?), see</source>
          <target state="translated">这个描述不经常更新(自5.6.1?</target>
        </trans-unit>
        <trans-unit id="20322d80a32c4020d9ededc57d341d0284daf471" translate="yes" xml:space="preserve">
          <source>This directive is supported with ANSI-type function declarations only.</source>
          <target state="translated">该指令仅支持ANSI类型的函数声明。</target>
        </trans-unit>
        <trans-unit id="a18a04a1fb981c46cc90618271edcb18e99ed305" translate="yes" xml:space="preserve">
          <source>This directory contains dual-life modules where the CPAN module is canonical. Do not patch these modules directly! Changes to these modules should be submitted to the maintainer of the CPAN module. Once those changes are applied and released, the new version of the module will be incorporated into the core.</source>
          <target state="translated">本目录包含双生模块,其中CPAN模块是规范的。不要直接给这些模块打补丁! 对这些模块的修改应该提交给CPAN模块的维护者。一旦这些更改被应用并发布,新版本的模块将被纳入核心。</target>
        </trans-unit>
        <trans-unit id="8f5f151207fd145f47cd0f164782d7d714aa8988" translate="yes" xml:space="preserve">
          <source>This directory contains pure-Perl modules which are only released as part of the core. This directory contains</source>
          <target state="translated">本目录包含纯Perl模块,这些模块只作为核心的一部分发布。本目录包含</target>
        </trans-unit>
        <trans-unit id="ff88cb5fa00bc50f7151a1d4596e477618c8bcec" translate="yes" xml:space="preserve">
          <source>This directory is for dual-life modules where the blead source is canonical. Note that some modules in this directory may not yet have been released separately on CPAN. Modules under</source>
          <target state="translated">本目录是为双生模块提供的,其中blead源是规范的。请注意,这个目录中的一些模块可能还没有在CPAN上单独发布。在此目录下的模块</target>
        </trans-unit>
        <trans-unit id="62002fdbbc82dfdecab897397921252b1a422691" translate="yes" xml:space="preserve">
          <source>This directory should better be on &lt;code&gt;BOOKSHELF&lt;/code&gt; .</source>
          <target state="translated">该目录最好放在 &lt;code&gt;BOOKSHELF&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="333fd828a086a8d956340a5925aba972db5faa95" translate="yes" xml:space="preserve">
          <source>This directory should better be on &lt;code&gt;MANPATH&lt;/code&gt; . You need to have a working</source>
          <target state="translated">该目录最好放在 &lt;code&gt;MANPATH&lt;/code&gt; 上。你需要工作</target>
        </trans-unit>
        <trans-unit id="7a7d8abb15dd5ddcab335f051e15e631ee76c9a7" translate="yes" xml:space="preserve">
          <source>This directory should better be on &lt;code&gt;MANPATH&lt;/code&gt; . You need to have a working man to access these files.</source>
          <target state="translated">该目录最好放在 &lt;code&gt;MANPATH&lt;/code&gt; 上。您需要一个工作人员来访问这些文件。</target>
        </trans-unit>
        <trans-unit id="170ad9fea04adcf28e5b84faabd5cf2954a187d9" translate="yes" xml:space="preserve">
          <source>This disables &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;Magic Autogeneration&lt;/a&gt;.</source>
          <target state="translated">这将禁用&lt;a href=&quot;#Magic-Autogeneration&quot;&gt;Magic Autogeneration&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b3a0993d47177782fe70afdd82bfb741c3d7395" translate="yes" xml:space="preserve">
          <source>This disables the poetry optimization, generating a compile-time error if you try to use a bareword identifier that's not a subroutine, unless it is a simple identifier (no colons) and that it appears in curly braces or on the left hand side of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol.</source>
          <target state="translated">如果您尝试使用不是子例程的裸字标识符，除非它是一个简单的标识符（无冒号）并且出现在花括号或左手大括号中，否则这会禁用诗歌优化，并产生编译时错误。 &lt;code&gt;=&amp;gt;&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="34ff219b627159fe6cfa93920427dc7e601e7134" translate="yes" xml:space="preserve">
          <source>This document aims to provide an overview of the vast perl community, which is far too large and diverse to provide a detailed listing. If any specific niche has been forgotten, it is not meant as an insult but an omission for the sake of brevity.</source>
          <target state="translated">本文档旨在为广大的perl社区提供一个概述,这个社区太过庞大和多样化,无法提供一个详细的列表。如果忘记了任何特定的利基,这并不是一种侮辱,而是为了简洁起见而省略的。</target>
        </trans-unit>
        <trans-unit id="1ba7340d966579fbb753302864000cf7b2972014" translate="yes" xml:space="preserve">
          <source>This document assumes that the executable named &quot;perl&quot; is Perl version 5. Some systems may have installed Perl version 5 as &quot;perl5&quot;.</source>
          <target state="translated">本文档假设名为 &quot;perl &quot;的可执行文件是Perl 5版本。有些系统可能将Perl 5版安装为 &quot;perl5&quot;。</target>
        </trans-unit>
        <trans-unit id="3a2742d9b73b97368bfc5521e9515184f408ef85" translate="yes" xml:space="preserve">
          <source>This document assumes that you already understand the basics of Perl syntax, variable types, operators, and subroutine calls. If you don't understand these concepts yet, please read &lt;a href=&quot;perlintro&quot;&gt;perlintro&lt;/a&gt; first. You should also read the &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;, &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;, and &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; documents.</source>
          <target state="translated">本文档假定您已经了解Perl语法，变量类型，运算符和子例程调用的基础知识。如果您还不了解这些概念，请先阅读&lt;a href=&quot;perlintro&quot;&gt;perlintro&lt;/a&gt;。您还应该阅读&lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;，&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;和&lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="8f596bd16fedee538f262d0de64e96d996439fb3" translate="yes" xml:space="preserve">
          <source>This document attempts to describe how to use the Perl API, as well as to provide some info on the basic workings of the Perl core. It is far from complete and probably contains many errors. Please refer any questions or comments to the author below.</source>
          <target state="translated">这篇文档试图描述如何使用Perl API,以及提供一些关于Perl核心的基本工作原理的信息。它远非完整,可能包含许多错误。如果有任何问题或意见,请向下面的作者提出。</target>
        </trans-unit>
        <trans-unit id="7e01fbc0bc773f9d24734cb30bab33bda7d5f6af" translate="yes" xml:space="preserve">
          <source>This document attempts to describe the Perl Community's &quot;best practice&quot; for writing Perl modules. It extends the recommendations found in &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt; , which should be considered required reading before reading this document.</source>
          <target state="translated">本文档试图描述Perl社区编写Perl模块的&amp;ldquo;最佳实践&amp;rdquo;。它扩展了&lt;a href=&quot;perlstyle&quot;&gt;perlstyle中&lt;/a&gt;的建议，在阅读本文档之前，应将其视为必读内容。</target>
        </trans-unit>
        <trans-unit id="bab11f45369409b96d7bf2180484dc0f685d2683" translate="yes" xml:space="preserve">
          <source>This document briefly describes Perl under Mac OS X.</source>
          <target state="translated">本文档简要介绍了Mac OS X下的Perl。</target>
        </trans-unit>
        <trans-unit id="083d82552ef9adb2b16dbbdc73ee6cb2d3adb7be" translate="yes" xml:space="preserve">
          <source>This document codifies the support and maintenance commitments that the Perl community should expect from Perl's developers:</source>
          <target state="translated">本文档规定了Perl社区应该从Perl的开发者那里得到的支持和维护承诺。</target>
        </trans-unit>
        <trans-unit id="ee4356257bf892096131087eff39fae084e3b0fb" translate="yes" xml:space="preserve">
          <source>This document covers features supported by &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; (also known as &lt;code&gt;xsubpp&lt;/code&gt; ) 3.13_01.</source>
          <target state="translated">本文档介绍了 &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; （也称为 &lt;code&gt;xsubpp&lt;/code&gt; ）3.13_01支持的功能。</target>
        </trans-unit>
        <trans-unit id="5d19d436c676e82c5de62fa2d93b31ad146ee5c7" translate="yes" xml:space="preserve">
          <source>This document defines a standard generic interface to the dynamic linking mechanisms available on many platforms. Its primary purpose is to implement automatic dynamic loading of Perl modules.</source>
          <target state="translated">本文档定义了一个标准的通用接口,用于连接许多平台上的动态链接机制。其主要目的是实现Perl模块的自动动态加载。</target>
        </trans-unit>
        <trans-unit id="f9a30c0ae237ad22360e4681ed6256da44062757" translate="yes" xml:space="preserve">
          <source>This document describes Thread::Queue version 3.05</source>
          <target state="translated">本文档描述了Thread::Queue 3.05版本。</target>
        </trans-unit>
        <trans-unit id="c32625e21916315b56d3d555dca5fa14529f5283" translate="yes" xml:space="preserve">
          <source>This document describes Thread::Semaphore version 2.12</source>
          <target state="translated">本文档描述了Thread::Semaphore 2.12版本。</target>
        </trans-unit>
        <trans-unit id="0a25c4c9828d0f58970f77b7ac6aa566b68c27f1" translate="yes" xml:space="preserve">
          <source>This document describes all backslash and escape sequences. After explaining the role of the backslash, it lists all the sequences that have a special meaning in Perl regular expressions (in alphabetical order), then describes each of them.</source>
          <target state="translated">本文档介绍了所有的反斜杠和转义序列。在解释了反斜杠的作用之后,它列出了所有在Perl正则表达式中具有特殊意义的序列(按字母顺序排列),然后描述了每一个序列。</target>
        </trans-unit>
        <trans-unit id="76ff3a8588f27b8cdd8cc7d51db810e080d05732" translate="yes" xml:space="preserve">
          <source>This document describes all of Perl's object-oriented (OO) features from the ground up. If you're just looking to write some object-oriented code of your own, you are probably better served by using one of the object systems from CPAN described in &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;.</source>
          <target state="translated">本文档从头开始描述Perl的所有面向对象（OO）功能。如果您只是想编写自己的一些面向对象的代码，则最好使用&lt;a href=&quot;perlootut&quot;&gt;perlootut中&lt;/a&gt;描述的CPAN对象系统之一。</target>
        </trans-unit>
        <trans-unit id="50f134817136be6999dd57e5d22bbefe3d37d2f5" translate="yes" xml:space="preserve">
          <source>This document describes how Perl internally handles numeric values.</source>
          <target state="translated">本文档介绍了Perl内部如何处理数值。</target>
        </trans-unit>
        <trans-unit id="8453dae2d904ec94b51a4ae275d589cad1fe0302" translate="yes" xml:space="preserve">
          <source>This document describes the behavior and implementation of the PerlIO abstraction described in &lt;a href=&quot;perlapio&quot;&gt;perlapio&lt;/a&gt; when &lt;code&gt;USE_PERLIO&lt;/code&gt; is defined.</source>
          <target state="translated">本文档中描述的行为和实施中所描述的PerlIO的抽象&lt;a href=&quot;perlapio&quot;&gt;perlapio&lt;/a&gt;时 &lt;code&gt;USE_PERLIO&lt;/code&gt; 被定义。</target>
        </trans-unit>
        <trans-unit id="a866d5af85544e7e4f21ddcd952a6d5892f7ea0f" translate="yes" xml:space="preserve">
          <source>This document describes the layout of the Perl source tree. If you're hacking on the Perl core, this will help you find what you're looking for.</source>
          <target state="translated">这个文档描述了Perl源代码树的布局。如果你正在对Perl核心进行黑客攻击,这将帮助你找到你要找的东西。</target>
        </trans-unit>
        <trans-unit id="327aacce5b60fcb7f0492805932fe1dec841e5bb" translate="yes" xml:space="preserve">
          <source>This document describes threads version 2.01</source>
          <target state="translated">本文档描述了线程2.01版本</target>
        </trans-unit>
        <trans-unit id="469ac48c0f559cb018049645e8c6431b0895b43b" translate="yes" xml:space="preserve">
          <source>This document describes threads::shared version 1.48</source>
          <target state="translated">本文档介绍了线程::共享的1.48版本。</target>
        </trans-unit>
        <trans-unit id="645bafb8d9dd20a3e1fad46cb6f3fa997de6c937" translate="yes" xml:space="preserve">
          <source>This document describes various features of FreeBSD that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">这篇文档描述了FreeBSD的各种特性,这些特性将影响Perl第5版(以下简称Perl)的编译和/或运行。</target>
        </trans-unit>
        <trans-unit id="321b1b1331ddd1b908bf07373d4048f86b3fa9c7" translate="yes" xml:space="preserve">
          <source>This document describes various features of HP's (formerly Compaq's, formerly Digital's) Unix operating system (Tru64) that will affect how Perl version 5 (hereafter just Perl) is configured, compiled and/or runs.</source>
          <target state="translated">本文档描述了HP(原Compaq,原Digital)Unix操作系统(Tru64)的各种特性,这些特性将影响Perl第5版(以下简称Perl)的配置、编译和/或运行。</target>
        </trans-unit>
        <trans-unit id="d268ac5a2d19120ce76c77eb58b90ecc6824f4a2" translate="yes" xml:space="preserve">
          <source>This document describes various features of HP's Unix operating system (HP-UX) that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">本文档描述了惠普Unix操作系统(HP-UX)的各种特性,这些特性将影响Perl第5版(以下简称Perl)的编译和/或运行方式。</target>
        </trans-unit>
        <trans-unit id="2eba298a6bc6800370faf3fd81957d6c988953ae" translate="yes" xml:space="preserve">
          <source>This document describes various features of IBM's OS/400 operating system that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">本文档描述了IBM的OS/400操作系统的各种特性,这些特性将影响Perl第5版(以下简称Perl)的编译和/或运行。</target>
        </trans-unit>
        <trans-unit id="1043854dc3d305d1c7397cad00b2c0693b02060a" translate="yes" xml:space="preserve">
          <source>This document describes various features of IBM's UNIX operating system AIX that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">本文档描述了IBM的UNIX操作系统AIX的各种特性,这些特性将影响Perl第5版(以下简称Perl)的编译和/或运行方式。</target>
        </trans-unit>
        <trans-unit id="0e732732feb0181fd46f9c9188d35cc9910b00cf" translate="yes" xml:space="preserve">
          <source>This document describes various features of Irix that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">本文档描述了Irix的各种特性,这些特性将影响Perl第5版(以下简称Perl)的编译和/或运行。</target>
        </trans-unit>
        <trans-unit id="180f34cce99d47d99da56406605f0fb9ba8ddd90" translate="yes" xml:space="preserve">
          <source>This document describes various features of Linux that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">本文档描述了Linux的各种特性,这些特性将影响Perl第5版(以下简称Perl)的编译和/或运行方式。</target>
        </trans-unit>
        <trans-unit id="cd165af2963c8b766b7c027487cbd05b923f2018" translate="yes" xml:space="preserve">
          <source>This document describes various features of OpenBSD that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">这篇文档描述了OpenBSD的各种特性,这些特性将影响Perl版本5(以下简称Perl)的编译和/或运行。</target>
        </trans-unit>
        <trans-unit id="bc5bdb1f6483dddcfcf934a3487da7243a97f3cc" translate="yes" xml:space="preserve">
          <source>This document describes various features of Sun's Solaris operating system that will affect how Perl version 5 (hereafter just perl) is compiled and/or runs. Some issues relating to the older SunOS 4.x are also discussed, though they may be out of date.</source>
          <target state="translated">本文档描述了Sun公司Solaris操作系统的各种特性,这些特性将影响Perl第5版(以下简称perl)的编译和/或运行。本文档还讨论了一些与旧版SunOS 4.x有关的问题,尽管这些问题可能已经过时。</target>
        </trans-unit>
        <trans-unit id="757712086ab3b4685f19333593ba82a0d48290a1" translate="yes" xml:space="preserve">
          <source>This document describes various features of the Symbian operating system that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">本文档描述了Symbian操作系统的各种特性,这些特性将影响Perl第5版(以下简称Perl)的编译和/或运行。</target>
        </trans-unit>
        <trans-unit id="a4d121d0bfe8a3c1aa6015bd2c8760d53592dff9" translate="yes" xml:space="preserve">
          <source>This document describes version 0.18 of Locale::Maketext::Simple, released Septermber 8, 2006.</source>
          <target state="translated">本文档介绍了Locale::Maketext::Simple的0.18版本,2006年9月8日发布。</target>
        </trans-unit>
        <trans-unit id="5e0659e04f3d9f2056b337b0739a67684597732b" translate="yes" xml:space="preserve">
          <source>This document describes version 0.97 of Attribute::Handlers.</source>
          <target state="translated">本文档介绍了Attribute::Handlers的0.97版本。</target>
        </trans-unit>
        <trans-unit id="00291624b11a3514d125571e1eabaca275507a74" translate="yes" xml:space="preserve">
          <source>This document describes version 2.09 of File::Path, released 2013-01-17.</source>
          <target state="translated">本文档介绍了2013-01-17发布的File::Path的2.09版本。</target>
        </trans-unit>
        <trans-unit id="e958fa3bffae7851375960acacad749b89480be8" translate="yes" xml:space="preserve">
          <source>This document differs from &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt; in that it is a style guide rather than a tutorial on creating CPAN modules. It provides a checklist against which modules can be compared to determine whether they conform to best practice, without necessarily describing in detail how to achieve this.</source>
          <target state="translated">该文档与&lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod的&lt;/a&gt;不同之处在于，它是样式指南，而不是有关创建CPAN模块的教程。它提供了一个清单，可以将其与模块进行比较以确定它们是否符合最佳实践，而不必详细描述如何实现。</target>
        </trans-unit>
        <trans-unit id="1c365d03a0d07def2d5f697a7dff266e86bfcaee" translate="yes" xml:space="preserve">
          <source>This document explains how Perl development works. It includes details about the Perl 5 Porters email list, the Perl repository, the Perlbug bug tracker, patch guidelines, and commentary on Perl development philosophy.</source>
          <target state="translated">这篇文档解释了 Perl 的开发工作原理,包括 Perl 5 Porters 电子邮件列表、Perl 仓库、Perlbug 错误跟踪器、补丁指南以及 Perl 开发理念的评论。它包括关于 Perl 5 Porters 电子邮件列表、Perl 仓库、Perlbug 错误跟踪器、补丁指南以及关于 Perl 开发理念的评论。</target>
        </trans-unit>
        <trans-unit id="448289ec7a46caaf1d68d5b7cd3ab508bea55402" translate="yes" xml:space="preserve">
          <source>This document gives a condensed list of the features available in the POSIX module. Consult your operating system's manpages for general information on most features. Consult &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for functions which are noted as being identical to Perl's builtin functions.</source>
          <target state="translated">本文档简要列出了POSIX模块中可用的功能。有关大多数功能的常规信息，请查阅操作系统的手册页。有关与Perl的内置函数相同的功能，请咨询&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2fce74951001e7bfa538197dd8bb5ec9f0e07bc5" translate="yes" xml:space="preserve">
          <source>This document gives a general idea of Unicode and how to use Unicode in Perl. See &lt;a href=&quot;#Further-Resources&quot;&gt;Further Resources&lt;/a&gt; for references to more in-depth treatments of Unicode.</source>
          <target state="translated">本文档给出了Unicode的一般概念以及如何在Perl中使用Unicode。请参阅&amp;ldquo; &lt;a href=&quot;#Further-Resources&quot;&gt;其他资源&amp;rdquo;&lt;/a&gt;以获取对Unicode的更深入处理的参考。</target>
        </trans-unit>
        <trans-unit id="3a55afa937d8de565fbacea117f04c55c4f3d03c" translate="yes" xml:space="preserve">
          <source>This document gives instructions for building Perl for RISC OS. It is complicated by the need to cross compile. There is a binary version of perl available from &lt;a href=&quot;http://www.cp15.org/perl/&quot;&gt;http://www.cp15.org/perl/&lt;/a&gt; which you may wish to use instead of trying to compile it yourself.</source>
          <target state="translated">本文档提供了有关为RISC OS构建Perl的说明。需要交叉编译使它变得复杂。您可以使用&lt;a href=&quot;http://www.cp15.org/perl/&quot;&gt;http://www.cp15.org/perl/中&lt;/a&gt;的perl二进制版本，而不是自己尝试对其进行编译。</target>
        </trans-unit>
        <trans-unit id="15f232a362787f4ceadbadf19dad93be195a4a8a" translate="yes" xml:space="preserve">
          <source>This document gives you some suggestions about how to go about writing Perl modules, preparing them for distribution, and making them available via CPAN.</source>
          <target state="translated">这篇文档为你提供了一些关于如何编写Perl模块的建议,为发布它们做准备,并通过CPAN提供它们。</target>
        </trans-unit>
        <trans-unit id="132f8081c1f83d30c54e1dd1f8a6c29026e0459f" translate="yes" xml:space="preserve">
          <source>This document has provided several way to go about identifying hot-spots, and checking whether any modifications have improved the runtime of the code.</source>
          <target state="translated">本文档提供了几种识别热点的方法,并检查是否有任何修改改进了代码的运行时间。</target>
        </trans-unit>
        <trans-unit id="2f9e9ade072c3d9b2906bfd078f37006fde1b348" translate="yes" xml:space="preserve">
          <source>This document is an attempt to shine some light on the guts of the regex engine and how it works. The regex engine represents a significant chunk of the perl codebase, but is relatively poorly understood. This document is a meagre attempt at addressing this situation. It is derived from the author's experience, comments in the source code, other papers on the regex engine, feedback on the perl5-porters mail list, and no doubt other places as well.</source>
          <target state="translated">这篇文档试图让大家了解一下regex引擎的内涵和工作原理。regex引擎在perl代码中占了很大的比重,但人们对它的理解相对较少。本文档是针对这种情况的一个微不足道的尝试。它来自于作者的经验、源代码中的评论、其他关于 regex 引擎的论文、perl5-porters 邮件列表中的反馈,毫无疑问还有其他地方。</target>
        </trans-unit>
        <trans-unit id="e2f799b102440b11497f30f8301310792802f29f" translate="yes" xml:space="preserve">
          <source>This document is authored and maintained by Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;.</source>
          <target state="translated">本文档由Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;编写和维护。</target>
        </trans-unit>
        <trans-unit id="deb0c7f47e4494d30a1aab35b9ec321b01a2ec44" translate="yes" xml:space="preserve">
          <source>This document is available under the same terms as Perl itself. Code examples in all the perlfaq documents are in the public domain. Use them as you see fit (and at your own risk with no warranty from anyone).</source>
          <target state="translated">本文档与Perl本身的条款相同。所有 perlfaq 文档中的代码示例都是公共领域的。你可以根据自己的需要使用它们(风险自负,任何人都不保证)。</target>
        </trans-unit>
        <trans-unit id="931cd9f92a3e4b725c73c5f241d6c52b01e63f35" translate="yes" xml:space="preserve">
          <source>This document is detailed notes on the Pod markup language. Most people will only have to read &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; to know how to write in Pod, but this document may answer some incidental questions to do with parsing and rendering Pod.</source>
          <target state="translated">本文档是有关Pod标记语言的详细说明。大多数人只需要阅读&lt;a href=&quot;perlpod&quot;&gt;Perlpod&lt;/a&gt;即可知道如何用Pod编写，但是此文档可能会回答一些与解析和渲染Pod有关的附带问题。</target>
        </trans-unit>
        <trans-unit id="bf5499e713f269332b5a031b1d5ec104878d26d5" translate="yes" xml:space="preserve">
          <source>This document is intended to give you a quick overview of the Perl programming language, along with pointers to further documentation. It is intended as a &quot;bootstrap&quot; guide for those who are new to the language, and provides just enough information for you to be able to read other peoples' Perl and understand roughly what it's doing, or write your own simple scripts.</source>
          <target state="translated">这篇文档的目的是让你快速了解Perl编程语言,以及指向更多文档的指针。它的目的是为那些刚接触这门语言的人提供一个 &quot;引导 &quot;指南,并提供足够的信息,让你能够阅读其他人的Perl,并大致了解它的工作,或者编写你自己的简单脚本。</target>
        </trans-unit>
        <trans-unit id="04d450fbf5761325924f000d871533277846798f" translate="yes" xml:space="preserve">
          <source>This document is maintained by Jan Dubois.</source>
          <target state="translated">本文件由Jan Dubois维护。</target>
        </trans-unit>
        <trans-unit id="6ad1ca1a9c1e0e6df1be4b460cdb832dc533d65a" translate="yes" xml:space="preserve">
          <source>This document is meant to be a detailed but understandable treatment of the many different sorts of data structures you might want to develop. It should also serve as a cookbook of examples. That way, when you need to create one of these complex data structures, you can just pinch, pilfer, or purloin a drop-in example from here.</source>
          <target state="translated">本文档的目的是对你可能想要开发的许多不同类型的数据结构进行详细但易懂的处理。它还应该作为一个例子的烹饪书。这样一来,当你需要创建这些复杂的数据结构时,你就可以从这里摘取、偷窃或掠夺一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="9bf997dd7f7e98ee160d1fffa9d041813ac9f4bb" translate="yes" xml:space="preserve">
          <source>This document is meant to help you to find out what constitutes portable Perl code. That way once you make a decision to write portably, you know where the lines are drawn, and you can stay within them.</source>
          <target state="translated">这篇文档的目的是帮助您了解什么是可移植的 Perl 代码。这样一来,一旦你决定要写可移植的代码,你就会知道界限在哪里,而且你可以不受界限的限制。</target>
        </trans-unit>
        <trans-unit id="9d9f3d95216c84aa89657f351bb6eefc71ea99a0" translate="yes" xml:space="preserve">
          <source>This document is provided in the hope that it will be useful, but without any warranty; without even the implied warranty of accuracy, authoritativeness, completeness, merchantability, or fitness for a particular purpose.</source>
          <target state="translated">提供本文件的目的是希望本文件有用,但不作任何保证,甚至不暗示保证本文件的准确性、权威性、完整性、适销性或对某一特定目的的适用性。</target>
        </trans-unit>
        <trans-unit id="c3a1d5c913f755b58160ddd4ac8b4f8158d38b0a" translate="yes" xml:space="preserve">
          <source>This document is the master document which records all written policies about how the Perl 5 Porters collectively develop and maintain the Perl core.</source>
          <target state="translated">本文档是一份主文档,它记录了所有关于 Perl 5 Porters 如何共同开发和维护 Perl 核心的书面政策。</target>
        </trans-unit>
        <trans-unit id="6445b4e91fdc1237d3a1bc4a31d98919bdef331e" translate="yes" xml:space="preserve">
          <source>This document lists the current and past experimental features in the perl core. Although all of these are documented with their appropriate topics, this succinct listing gives you an overview and basic facts about their status.</source>
          <target state="translated">这篇文档列出了perl core中当前和过去的实验性特性。尽管所有这些特性都有相应的主题文档,但这个简洁的列表为你提供了关于它们状态的概述和基本事实。</target>
        </trans-unit>
        <trans-unit id="e04379014fdbc8385dc766fdec2dc2ab609657d0" translate="yes" xml:space="preserve">
          <source>This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">本文档可以按照与Perl本身相同的条款发布。</target>
        </trans-unit>
        <trans-unit id="68809e455146d4d0b2eb575625c0befbf01b3e91" translate="yes" xml:space="preserve">
          <source>This document may be incomplete in some respects.</source>
          <target state="translated">本文件在某些方面可能不完整。</target>
        </trans-unit>
        <trans-unit id="d40e2bd179554762718d2c8f40e4558baafd8315" translate="yes" xml:space="preserve">
          <source>This document merely lists all available properties and does not attempt to explain what each property really means. There is a brief description of each Perl extension; see &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;Other Properties in perlunicode&lt;/a&gt; for more information on these. There is some detail about Blocks, Scripts, General_Category, and Bidi_Class in &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;, but to find out about the intricacies of the official Unicode properties, refer to the Unicode standard. A good starting place is &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;.</source>
          <target state="translated">本文档仅列出所有可用的属性，而不试图解释每个属性的真正含义。每个Perl扩展都有一个简短的描述。有关这些的更多信息，请参见&lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;perlunicode中的&amp;ldquo;其他属性&amp;rdquo;&lt;/a&gt;。在perlunicode中有一些有关Blocks，Scripts，General_Category和Bidi_Class的&lt;a href=&quot;perlunicode&quot;&gt;详细信息&lt;/a&gt;，但是要了解官方Unicode属性的复杂性，请参考Unicode标准。&lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;是一个很好的起点。</target>
        </trans-unit>
        <trans-unit id="69e6772a5d46653631303f536faddc78ecd15c3a" translate="yes" xml:space="preserve">
          <source>This document mostly explains the</source>
          <target state="translated">本文件主要解释了</target>
        </trans-unit>
        <trans-unit id="a7ddd5955e611e8402df676dc922c52fe96687d9" translate="yes" xml:space="preserve">
          <source>This document needs a rewrite that separates the tutorial content from the reference content.</source>
          <target state="translated">这个文档需要重写,把教程内容和参考内容分开。</target>
        </trans-unit>
        <trans-unit id="c5434f0b9e2b7cf484cc38556a1c3be222c03edd" translate="yes" xml:space="preserve">
          <source>This document provides a general overview of the capabilities and limitations of the fork() emulation. Note that the issues discussed here are not applicable to platforms where a real fork() is available and Perl has been configured to use it.</source>
          <target state="translated">这篇文档提供了fork()仿真的功能和局限性的总体概述。请注意,这里讨论的问题并不适用于真正的fork()可用且Perl已被配置为使用它的平台。</target>
        </trans-unit>
        <trans-unit id="93c5711ad21bddf8f27384e848494d1a512f01be" translate="yes" xml:space="preserve">
          <source>This document provides a reference for Perl's object orientation features. If you're looking for an introduction to object-oriented programming in Perl, please see &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;.</source>
          <target state="translated">本文档为Perl的面向对象功能提供了参考。如果您正在寻找Perl中的面向对象编程的介绍，请参见&lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46a94276417126d2ba57635546eac62791e072d3" translate="yes" xml:space="preserve">
          <source>This document provides an introduction to object-oriented programming in Perl. It begins with a brief overview of the concepts behind object oriented design. Then it introduces several different OO systems from &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org&quot;&gt;CPAN&lt;/a&gt; which build on top of what Perl provides.</source>
          <target state="translated">本文档介绍了Perl中的面向对象编程。它首先简要介绍了面向对象设计背后的概念。然后，它介绍了基于&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org&quot;&gt;CPAN的&lt;/a&gt;几种不同的OO系统，它们基于Perl提供的功能。</target>
        </trans-unit>
        <trans-unit id="6876a82e12e5ab947f419b2c224d987985e1ad19" translate="yes" xml:space="preserve">
          <source>This document provides an overview of how the Perl interpreter works at the level of C code, along with pointers to the relevant C source code files.</source>
          <target state="translated">本文档概述了Perl解释器在C代码层面的工作方式,以及指向相关C源代码文件的指针。</target>
        </trans-unit>
        <trans-unit id="98ef42b4ebd0391f6b1eb2c007891c9540cce7bb" translate="yes" xml:space="preserve">
          <source>This document provides information about the portion of the Unicode database that deals with character properties, that is the portion that is defined on single code points. (&lt;a href=&quot;#Other-information-in-the-Unicode-data-base&quot;&gt;Other information in the Unicode data base&lt;/a&gt; below briefly mentions other data that Unicode provides.)</source>
          <target state="translated">本文档提供了有关Unicode数据库中处理字符属性的部分的信息，即在单个代码点上定义的部分。（下面&lt;a href=&quot;#Other-information-in-the-Unicode-data-base&quot;&gt;的Unicode数据库中的其他信息&lt;/a&gt;简要提到了Unicode提供的其他数据。）</target>
        </trans-unit>
        <trans-unit id="b2a79746685de57fddf566ba23eb18f1694b69ba" translate="yes" xml:space="preserve">
          <source>This document serves as both a specification for anyone wishing to implement the DynaLoader for a new platform and as a guide for anyone wishing to use the DynaLoader directly in an application.</source>
          <target state="translated">本文档既是希望在新平台上实现DynaLoader的规范,也是希望在应用程序中直接使用DynaLoader的指南。</target>
        </trans-unit>
        <trans-unit id="4c2fd7fb88b1605d6c1c01cd882956329e66498d" translate="yes" xml:space="preserve">
          <source>This document takes you through a simple patch example.</source>
          <target state="translated">本文档将带您了解一个简单的补丁示例。</target>
        </trans-unit>
        <trans-unit id="482b84044bf12cbb74ce5534dc67232a2bb4bcd3" translate="yes" xml:space="preserve">
          <source>This document varies from difficult to understand to completely and utterly opaque. The wandering prose riddled with jargon is hard to fathom in several places.</source>
          <target state="translated">这份文件从难以理解到完全和完全不透明不等。漫无边际的散文中充满了行话,有几处地方难以理解。</target>
        </trans-unit>
        <trans-unit id="e494f5a4ef902fd5cb4de9dfa1a90e73e0fc46e2" translate="yes" xml:space="preserve">
          <source>This document walks through the creation of a small patch to Perl's C code. If you're just getting started with Perl core hacking, this will help you understand how it works.</source>
          <target state="translated">本文档讲解了如何为Perl的C代码创建一个小补丁。如果你刚开始接触Perl核心黑客,这将有助于你理解它是如何工作的。</target>
        </trans-unit>
        <trans-unit id="6e368b4b82da174b5c34f4ad74472953966358bf" translate="yes" xml:space="preserve">
          <source>This document was created in February, 2011, and the last major revision was in February, 2013.</source>
          <target state="translated">本文件创建于2011年2月,最后一次重大修订是在2013年2月。</target>
        </trans-unit>
        <trans-unit id="e89c4ac20e63934f15f4f06f3bdf35dc35e9054b" translate="yes" xml:space="preserve">
          <source>This document was originally written by David Fiander for the 5.005 release of Perl.</source>
          <target state="translated">这个文档最初是由David Fiander为Perl的5.005版本编写的。</target>
        </trans-unit>
        <trans-unit id="44116b950aea8406dc1d009e3e7e8df16d0f1901" translate="yes" xml:space="preserve">
          <source>This document was originally written by Nathan Torkington, and is maintained by the perl5-porters mailing list.</source>
          <target state="translated">这个文档最初是由Nathan Torkington写的,由perl5-porters邮件列表维护。</target>
        </trans-unit>
        <trans-unit id="cb57f1783ae5d9d11a07aa4ee9a4142c141dd869" translate="yes" xml:space="preserve">
          <source>This document was originally written by Thomas Dorner for the 5.005 release of Perl.</source>
          <target state="translated">这个文档最初是由Thomas Dorner为Perl的5.005版本编写的。</target>
        </trans-unit>
        <trans-unit id="8245e0ace1fc709b9c52b2d684fbab4d872b4b6b" translate="yes" xml:space="preserve">
          <source>This document was podified for the 5.005_03 release of Perl 11 March 1999.</source>
          <target state="translated">这个文档是为1999年3月11日发布的Perl 5.005_03版本而编写的。</target>
        </trans-unit>
        <trans-unit id="01c73c6cbc6ea7a7507692f73f286583700f23f4" translate="yes" xml:space="preserve">
          <source>This document was podified for the 5.6 release of perl 11 July 2000.</source>
          <target state="translated">这个文档是为2000年7月11日发布的5.6版perl而编写的。</target>
        </trans-unit>
        <trans-unit id="e3d3763f0de441b0bf953c53b8f14562b8c6d91b" translate="yes" xml:space="preserve">
          <source>This document was revised 09-October-1996 for Perl 5.003_7.</source>
          <target state="translated">本文档于1996年10月9日针对Perl 5.003_7进行了修订。</target>
        </trans-unit>
        <trans-unit id="1ae9aedfb6e910ab590ab6a48004a6cd92829aac" translate="yes" xml:space="preserve">
          <source>This document will help you Configure, build, test and install Perl on BS2000 in the POSIX subsystem.</source>
          <target state="translated">本文档将帮助你在POSIX子系统中的BS2000上配置、构建、测试和安装Perl。</target>
        </trans-unit>
        <trans-unit id="ecb2db0bdd80184dad93c70d1f7773c61d926757" translate="yes" xml:space="preserve">
          <source>This document will help you Configure, build, test and install Perl on OS/390 (aka z/OS) Unix System Services.</source>
          <target state="translated">本文档将帮助你在OS/390(又称z/OS)Unix系统服务上配置、构建、测试和安装Perl。</target>
        </trans-unit>
        <trans-unit id="b14dd21b17eb4778756f16a28286f3080a5b52fc" translate="yes" xml:space="preserve">
          <source>This document will help you configure, make, test and install Perl on Cygwin. This document also describes features of Cygwin that will affect how Perl behaves at runtime.</source>
          <target state="translated">本文档将帮助你在Cygwin上配置、制作、测试和安装Perl。本文档还描述了Cygwin的特性,这些特性将影响Perl在运行时的表现。</target>
        </trans-unit>
        <trans-unit id="4b25a8a1d43deec5996faad1ce1066a1b7f65307" translate="yes" xml:space="preserve">
          <source>This document will help you learn the best way to go about hacking on the Perl core C code. It covers common problems, debugging, profiling, and more.</source>
          <target state="translated">本文档将帮助你学习如何对Perl核心C代码进行黑客攻击的最佳方法。它涵盖了常见问题、调试、剖析等内容。</target>
        </trans-unit>
        <trans-unit id="7b1ceac6a2e862b1ba010e29c7ba5c554256d9b3" translate="yes" xml:space="preserve">
          <source>This documentation describes version 0.08.</source>
          <target state="translated">本文档描述的是0.08版本。</target>
        </trans-unit>
        <trans-unit id="bb13bb5cc25da0a84b0ee6fe56550c8fa997e8a4" translate="yes" xml:space="preserve">
          <source>This documentation is for people who want to download CPAN modules and install them on their own computer.</source>
          <target state="translated">本文档是为想下载CPAN模块并在自己的电脑上安装的人准备的。</target>
        </trans-unit>
        <trans-unit id="f9807e2f281735ce8b4db75a087a60d39d5eaabb" translate="yes" xml:space="preserve">
          <source>This documentation is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">本文档是自由软件;您可以在与Perl本身相同的条款下重新发布它和/或修改它。</target>
        </trans-unit>
        <trans-unit id="4e1e03b9948de51dc9fc37899fb9224e953fca3a" translate="yes" xml:space="preserve">
          <source>This documentation is free; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">本文档是免费的;你可以在与Perl本身相同的条款下重新发布它和/或修改它。</target>
        </trans-unit>
        <trans-unit id="cceba8951b48c0df6a7d7a78ae98404b2be1a5f6" translate="yes" xml:space="preserve">
          <source>This documentation is maintained as part of the podlators distribution. The current version is always available from its web site at &amp;lt;&lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">该文档是Podlator分发版的一部分。当前版本始终可以从其网站上找到，网址为&amp;lt; &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt; &amp;gt;。</target>
        </trans-unit>
        <trans-unit id="ee59b544a64dcf3a8c36474bf7a745c77abd72ed" translate="yes" xml:space="preserve">
          <source>This documentation provided by Tels &amp;lt;nospam-abuse@bloodgate.com&amp;gt; 2007.</source>
          <target state="translated">该文档由Tels &amp;lt;nospam-abuse@bloodgate.com&amp;gt; 2007提供。</target>
        </trans-unit>
        <trans-unit id="d579dc02247e710bddf4fd80263160b958f95883" translate="yes" xml:space="preserve">
          <source>This does a &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref()&lt;/a&gt;&lt;/code&gt; check on the argument provided. The &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; of the argument must be the same as the &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; of the default value for this check to pass.</source>
          <target state="translated">这会对提供的参数执行 &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref()&lt;/a&gt;&lt;/code&gt; 检查。参数的 &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 必须与默认值的 &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 相同，此检查才能通过。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
