<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="670b1ddc67f6054d3b05d014236af978c695794a" translate="yes" xml:space="preserve">
          <source>Additionally,</source>
          <target state="translated">Additionally,</target>
        </trans-unit>
        <trans-unit id="d13e57a8614451ac86ee80ef497567c6c1217ddd" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;reg()&lt;/code&gt; is responsible for parsing the one or more branches from the pattern, and for &quot;finishing them off&quot; by correctly setting their next pointers. In order to do the parsing, it repeatedly calls out to &lt;code&gt;regbranch()&lt;/code&gt; , which is responsible for handling up to the first &lt;code&gt;|&lt;/code&gt; symbol it sees.</source>
          <target state="translated">另外， &lt;code&gt;reg()&lt;/code&gt; 负责从模式中解析一个或多个分支，并通过正确设置它们的下一个指针来&amp;ldquo;完成它们&amp;rdquo;。为了进行解析，它反复调出 &lt;code&gt;regbranch()&lt;/code&gt; ，它负责处理第一个 &lt;code&gt;|&lt;/code&gt; 它看到的符号。</target>
        </trans-unit>
        <trans-unit id="e0e807bcf6cc2e8c544c361c110388bef7a27722" translate="yes" xml:space="preserve">
          <source>Additionally, extra colons can be used to control formatting. A trailing colon suppresses the linefeed and terminator &quot;;&quot;, allowing you to embed queries into shell commands. (mnemonic: PATH separator &quot;:&quot;.)</source>
          <target state="translated">此外,额外的冒号可以用来控制格式。尾部的冒号抑制了换行符和终止符&quot;;&quot;,允许你将查询嵌入到shell命令中。(记号:PATH分隔符&quot;:&quot;。)</target>
        </trans-unit>
        <trans-unit id="e495cf9a286350e9c50957cc8351f8f292fd0e8c" translate="yes" xml:space="preserve">
          <source>Additionally, if the &lt;code&gt;h_errno&lt;/code&gt; variable is supported in C, its value is returned via &lt;code&gt;$?&lt;/code&gt; if any &lt;code&gt;gethost*()&lt;/code&gt; function fails.</source>
          <target state="translated">另外，如果C中支持 &lt;code&gt;h_errno&lt;/code&gt; 变量，则其值通过 &lt;code&gt;$?&lt;/code&gt; 返回。如果任何 &lt;code&gt;gethost*()&lt;/code&gt; 函数失败。</target>
        </trans-unit>
        <trans-unit id="f146d2cdc65cbc8a75b0db4de74950e484d62ea3" translate="yes" xml:space="preserve">
          <source>Additionally, if the identifier is preceded by a sigil -- that is, if the identifier is part of a variable name -- it may optionally be enclosed in braces.</source>
          <target state="translated">此外,如果标识符前面有一个符号--也就是说,如果标识符是一个变量名称的一部分,它可以选择用括号括起来。</target>
        </trans-unit>
        <trans-unit id="0a9aa35376d4ff22f823726940db699aadebfdc8" translate="yes" xml:space="preserve">
          <source>Additionally, implementations of the standard &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; tmpnam() and tmpfile() functions are provided if required.</source>
          <target state="translated">此外，如果需要，还提供标准&lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; tmpnam（）和tmpfile（）函数的实现。</target>
        </trans-unit>
        <trans-unit id="ec069a599a9fe7b608d8c7621218dba9e34959bc" translate="yes" xml:space="preserve">
          <source>Additionally, it will create META.yml and META.json module meta-data file in the distdir and add this to the distdir's MANIFEST. You can shut this behavior off with the NO_META flag.</source>
          <target state="translated">此外,它会在distdir中创建META.yml和META.json模块元数据文件,并将其添加到distdir的MANIFEST中。你可以用NO_META标志来关闭这个行为。</target>
        </trans-unit>
        <trans-unit id="fdcb47de4e9258bc110d7122692a049db6fbb22a" translate="yes" xml:space="preserve">
          <source>Additionally, on Windows NT not all the fields returned by stat() can be compared. For example, the C</source>
          <target state="translated">此外,在Windows NT上,并不是所有由stat()返回的字段都可以进行比较。例如,C</target>
        </trans-unit>
        <trans-unit id="51fffd62248577e35b4f056a4c962f40c15d81d6" translate="yes" xml:space="preserve">
          <source>Additionally, quoting rules for the end-of-string identifier are unrelated to Perl's quoting rules. &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq()&lt;/a&gt;&lt;/code&gt;, and the like are not supported in place of &lt;code&gt;''&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; , and the only interpolation is for backslashing the quoting character:</source>
          <target state="translated">此外，字符串结尾标识符的引用规则与Perl的引用规则无关。不支持使用 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq()&lt;/a&gt;&lt;/code&gt; 等代替 &lt;code&gt;''&lt;/code&gt; 和 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，唯一的插值是反斜杠引用字符：</target>
        </trans-unit>
        <trans-unit id="60224bb897c08e69d3d354606005d24af0b374cd" translate="yes" xml:space="preserve">
          <source>Additionally, the following still works:</source>
          <target state="translated">此外,以下内容仍然有效。</target>
        </trans-unit>
        <trans-unit id="03aa6ebb82309c10827e49e960c12581e1baf1dc" translate="yes" xml:space="preserve">
          <source>Additionally, the type of each element is determined from the type of the array. If the array uses type &lt;code&gt;intArray *&lt;/code&gt; xsubpp will automatically work out that it contains variables of type &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; and use that typemap entry to perform the copy of each element. All pointer '*' and 'Array' tags are removed from the name to determine the subtype.</source>
          <target state="translated">另外，每个元素的类型由数组的类型确定。如果该数组使用 &lt;code&gt;intArray *&lt;/code&gt; 类型，则 xsubpp将自动计算出它包含 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 类型的变量，并使用该typemap条目执行每个元素的副本。从名称中删除所有指针&amp;ldquo; *&amp;rdquo;和&amp;ldquo; Array&amp;rdquo;标签，以确定子类型。</target>
        </trans-unit>
        <trans-unit id="5b8c86e3562fdf5c9d82a5e93b3d4cafa347de77" translate="yes" xml:space="preserve">
          <source>Additionally, unless the &lt;code&gt;safe&lt;/code&gt; parameter is set (or the third parameter in the traditional interface is TRUE), should a &lt;code&gt;remove_tree&lt;/code&gt; be interrupted, files that were originally in read-only mode may now have their permissions set to a read-write (or &quot;delete OK&quot;) mode.</source>
          <target state="translated">此外，除非设置了 &lt;code&gt;safe&lt;/code&gt; 参数（或传统界面中的第三个参数为TRUE），否则如果 &lt;code&gt;remove_tree&lt;/code&gt; 被中断，原来处于只读模式的文件现在可以将其权限设置为可读写（或&amp;ldquo;删除确定&amp;rdquo;）模式。</target>
        </trans-unit>
        <trans-unit id="ec0f027d3baa565712bd5dc0ad0e80af4eb514d9" translate="yes" xml:space="preserve">
          <source>Additionally, you can enable and disable categories of warnings. You turn off the categories you want to ignore and you can still get other categories of warnings. See &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; for the complete details, including the category names and hierarchy.</source>
          <target state="translated">此外，您可以启用和禁用警告类别。您关闭了要忽略的类别，仍然可以获得其他警告类别。有关完整的详细信息，请参见&lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt;，包括类别名称和层次结构。</target>
        </trans-unit>
        <trans-unit id="3f10369c70dcbc4071416e4238c5876b81c9796c" translate="yes" xml:space="preserve">
          <source>Additionally, you might want to provide the following two globals to allow auto-upgrading and auto-downgrading to work correctly:</source>
          <target state="translated">此外,你可能需要提供以下两个globals来让自动升级和自动降级正确工作。</target>
        </trans-unit>
        <trans-unit id="0595fe59d92f01dd8f2cab1ee0be7afe3d67ccd0" translate="yes" xml:space="preserve">
          <source>Additionaly, on Solaris 8 and 9 you also need:</source>
          <target state="translated">另外,在Solaris 8和9上你还需要。</target>
        </trans-unit>
        <trans-unit id="bf73559c41806dc25286227ff308976c154c29de" translate="yes" xml:space="preserve">
          <source>Additive Operators</source>
          <target state="translated">加法运算符</target>
        </trans-unit>
        <trans-unit id="15668d6e15430dae7c65fa496b4f2aa5393ff6b7" translate="yes" xml:space="preserve">
          <source>Address family constants used by the socket address structures, to pass to such functions as inet_pton() or getaddrinfo(), or are returned by such functions as sockaddr_family().</source>
          <target state="translated">套接字地址结构使用的地址族常量,传递给inet_pton()或getaddrinfo()等函数,或由sockaddr_family()等函数返回。</target>
        </trans-unit>
        <trans-unit id="398491e08f855e6e51bbd01773f98e6f34b68ef0" translate="yes" xml:space="preserve">
          <source>Address to send copy of report to. Defaults to the address of the local perl administrator (recorded when perl was built).</source>
          <target state="translated">发送报告副本的地址。默认为本地perl管理员的地址(在建立perl时记录)。</target>
        </trans-unit>
        <trans-unit id="866089dee6e89f6a5b436348a98fb9411f98472d" translate="yes" xml:space="preserve">
          <source>Address to send the report to. Defaults to &lt;b&gt;perlbug@perl.org&lt;/b&gt;.</source>
          <target state="translated">将报告发送到的地址。默认为&lt;b&gt;perlbug@perl.org&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="6b59857dd57932d5d50e4861a06a2080338435ed" translate="yes" xml:space="preserve">
          <source>Address-of operator. (But see the &lt;code&gt;&quot;\&quot;&lt;/code&gt; operator for taking a reference.)</source>
          <target state="translated">地址运算符。（但是请参阅 &lt;code&gt;&quot;\&quot;&lt;/code&gt; 运算符以获取参考。）</target>
        </trans-unit>
        <trans-unit id="875b1b8e40002002efb28f1a8fa46b6af7e34564" translate="yes" xml:space="preserve">
          <source>AddressSanitizer</source>
          <target state="translated">AddressSanitizer</target>
        </trans-unit>
        <trans-unit id="97d2869e530035313b88d71ffdc660bf28a9cf95" translate="yes" xml:space="preserve">
          <source>AddressSanitizer is a clang and gcc extension, included in clang since v3.1 and gcc since v4.8. It checks illegal heap pointers, global pointers, stack pointers and use after free errors, and is fast enough that you can easily compile your debugging or optimized perl with it. It does not check memory leaks though. AddressSanitizer is available for Linux, Mac OS X and soon on Windows.</source>
          <target state="translated">AddressSanitizer是clang和gcc的扩展,从v3.1开始包含在clang中,从v4.8开始包含在gcc中。它可以检查非法的堆指针、全局指针、堆指针和空闲后的使用错误,而且速度非常快,你可以用它轻松地编译你的调试或优化的perl。不过它不检查内存泄漏。AddressSanitizer可用于Linux、Mac OS X,不久也可用于Windows。</target>
        </trans-unit>
        <trans-unit id="975fc2f37ec74ac4dc4429c1af7095af2a49e10a" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;#line&lt;/code&gt; directives to the C output so error messages will look like they came from the original XS file. Default is true.</source>
          <target state="translated">在C输出中添加 &lt;code&gt;#line&lt;/code&gt; 指令，因此错误消息看起来像是来自原始XS文件。默认为true。</target>
        </trans-unit>
        <trans-unit id="14f679936dccdbe9d754f57ef3015e396a6c5718" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; to the C code. Default is false.</source>
          <target state="translated">将 &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; 添加到C代码。默认为false。</target>
        </trans-unit>
        <trans-unit id="9fbaf45d7bbf38840f610cf2fa4335deddb3f4a7" translate="yes" xml:space="preserve">
          <source>Adds a list of items onto the end of the queue.</source>
          <target state="translated">在队列的末尾添加一个项目列表。</target>
        </trans-unit>
        <trans-unit id="973f265e0df96f52e35c5a95591ee9281a6a4277" translate="yes" xml:space="preserve">
          <source>Adds a name to a stash's internal list of effective names. See &lt;code&gt;hv_ename_delete&lt;/code&gt; .</source>
          <target state="translated">将名称添加到存储区的有效名称的内部列表中。参见 &lt;code&gt;hv_ename_delete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e689b98670881df4701aa3dac263f404709c80f2" translate="yes" xml:space="preserve">
          <source>Adds an action (Perl command) to happen after the prompt when you've just given a command to return to executing the script. A multi-line command may be entered by backslashing the newlines.</source>
          <target state="translated">当你刚下达命令时,在提示符后添加一个动作(Perl命令),以返回执行脚本。多行命令可以通过反斜杠来输入。</target>
        </trans-unit>
        <trans-unit id="6f66738644531c5b87f8955ebdca5064179de491" translate="yes" xml:space="preserve">
          <source>Adds an entry to an existing</source>
          <target state="translated">在一个现有的</target>
        </trans-unit>
        <trans-unit id="0de7670702a5255a31f66440c4b7be5b815e4074" translate="yes" xml:space="preserve">
          <source>Adds directives to point C preprocessor to the right place when handling #include &amp;lt;sys/foo.h&amp;gt; directives. Also constructs CC command line a bit differently than MM_Unix method.</source>
          <target state="translated">在处理#include &amp;lt;sys / foo.h&amp;gt;指令时，将指向C预处理程序的指令添加到正确的位置。此外，CC命令行的构造与MM_Unix方法略有不同。</target>
        </trans-unit>
        <trans-unit id="57db6ceb50b20e26da1bd06687e1abc05f545a8e" translate="yes" xml:space="preserve">
          <source>Adds exception handling stubs to the C code.</source>
          <target state="translated">在C代码中添加异常处理存根。</target>
        </trans-unit>
        <trans-unit id="75f4dd4f96db4d1994f4da6375a60458e7848772" translate="yes" xml:space="preserve">
          <source>Adds exception handling stubs to the C code. Default is false.</source>
          <target state="translated">在C代码中添加异常处理存根。默认为false。</target>
        </trans-unit>
        <trans-unit id="4af44986ac261800435ec27f11809711c0f2176e" translate="yes" xml:space="preserve">
          <source>Adds magic to a hash. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">向哈希添加魔术。参见 &lt;code&gt;sv_magic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d4c5e94cf59f9802d65e1e2f74c4b0b68104c99" translate="yes" xml:space="preserve">
          <source>Adds magic to an SV, upgrading it if necessary. Applies the supplied vtable and returns a pointer to the magic added.</source>
          <target state="translated">将魔法添加到 SV 中,如有必要可将其升级。应用所提供的 vtable,并返回一个指向所添加魔法的指针。</target>
        </trans-unit>
        <trans-unit id="28665dcfafc5d1482673492d1c1b2b0ccfb32625" translate="yes" xml:space="preserve">
          <source>Adds magic to an SV. First upgrades &lt;code&gt;sv&lt;/code&gt; to type &lt;code&gt;SVt_PVMG&lt;/code&gt; if necessary, then adds a new magic item of type &lt;code&gt;how&lt;/code&gt; to the head of the magic list.</source>
          <target state="translated">向SV添加魔力。如果需要，首先将 &lt;code&gt;sv&lt;/code&gt; 升级为 &lt;code&gt;SVt_PVMG&lt;/code&gt; 类型，然后在魔术列表的开头添加一个类型为 &lt;code&gt;how&lt;/code&gt; 的新魔术项目。</target>
        </trans-unit>
        <trans-unit id="542cadc025698f26c94694489350a3b0f8078ab7" translate="yes" xml:space="preserve">
          <source>Adds the UTF-8 representation of the native code point &lt;code&gt;uv&lt;/code&gt; to the end of the string &lt;code&gt;d&lt;/code&gt; ; &lt;code&gt;d&lt;/code&gt; should have at least &lt;code&gt;UVCHR_SKIP(uv)+1&lt;/code&gt; (up to &lt;code&gt;UTF8_MAXBYTES+1&lt;/code&gt; ) free bytes available. The return value is the pointer to the byte after the end of the new character. In other words,</source>
          <target state="translated">将本地代码点 &lt;code&gt;uv&lt;/code&gt; 的UTF-8表示形式添加到字符串 &lt;code&gt;d&lt;/code&gt; 的末尾； &lt;code&gt;d&lt;/code&gt; 应该至少具有 &lt;code&gt;UVCHR_SKIP(uv)+1&lt;/code&gt; （最多 &lt;code&gt;UTF8_MAXBYTES+1&lt;/code&gt; ）个可用字节。返回值是指向新字符末尾字节的指针。换一种说法，</target>
        </trans-unit>
        <trans-unit id="05920eaea07a3bf7b3235f61833114608d265ccb" translate="yes" xml:space="preserve">
          <source>Adds the list of items to the queue at the specified index position (0 is the head of the list). Any existing items at and beyond that position are pushed back past the newly added items:</source>
          <target state="translated">在指定的索引位置(0是列表的头部)将项目列表添加到队列中。在该位置及以后的任何现有项目都会被推回到新添加项目的后面。</target>
        </trans-unit>
        <trans-unit id="0e0d3dac3482cf17fed1b9381fe12a1473ad738e" translate="yes" xml:space="preserve">
          <source>Adds the standard Module prologue lines</source>
          <target state="translated">添加标准模块序言行</target>
        </trans-unit>
        <trans-unit id="e8de0b7636a50e6e023d32d6c6819a0178b632ba" translate="yes" xml:space="preserve">
          <source>Adds the supplied opset to the current opmask. Note that there is currently</source>
          <target state="translated">将提供的OPSET添加到当前的OMMASK中。请注意,当前有</target>
        </trans-unit>
        <trans-unit id="ad3dde36a3137b653e95b59ad8f34b7ac4e19623" translate="yes" xml:space="preserve">
          <source>Adjust the read pointer and count of bytes to match &lt;code&gt;ptr&lt;/code&gt; and/or &lt;code&gt;cnt&lt;/code&gt; . The application (or layer above) must ensure they are consistent. (Checking is allowed by the paranoid.)</source>
          <target state="translated">调整读取指针和字节数以匹配 &lt;code&gt;ptr&lt;/code&gt; 和/或 &lt;code&gt;cnt&lt;/code&gt; 。应用程序（或上面的层）必须确保它们是一致的。（偏执狂允许检查。）</target>
        </trans-unit>
        <trans-unit id="02eff1841c4085ce501a79933ae5da5167e9d1b8" translate="yes" xml:space="preserve">
          <source>Adjusting the system clock (either manually or by services like ntp) may cause problems, especially for long running programs that assume a monotonously increasing time (note that all platforms do not adjust time as gracefully as UNIX ntp does). For example in Win32 (and derived platforms like Cygwin and MinGW) the Time::HiRes::time() may temporarily drift off from the system clock (and the original time()) by up to 0.5 seconds. Time::HiRes will notice this eventually and recalibrate. Note that since Time::HiRes 1.77 the clock_gettime(CLOCK_MONOTONIC) might help in this (in case your system supports CLOCK_MONOTONIC).</source>
          <target state="translated">调整系统时钟(无论是手动还是通过像ntp这样的服务)可能会引起问题,特别是对于那些假定时间单调增长的长期运行程序(注意,所有平台都不会像UNIX ntp那样优雅地调整时间)。例如在 Win32(以及衍生平台如 Cygwin 和 MinGW)中,Time::HiRes::time()可能会暂时偏离系统时钟(以及原始 time())多达 0.5 秒。Time::HiRes 最终会注意到这一点并重新校准。请注意从 Time::HiRes 1.77 开始,clock_gettime(CLOCK_MONOTONIC)可能会对此有所帮助(如果你的系统支持 CLOCK_MONOTONIC)。</target>
        </trans-unit>
        <trans-unit id="e8d0942ed6347577c01feddee9c6edaf4ffde5a8" translate="yes" xml:space="preserve">
          <source>Adjustments are made for Borland's quirks needing -L to come first.</source>
          <target state="translated">针对博兰的怪癖需要-l先进行调整。</target>
        </trans-unit>
        <trans-unit id="b8be3d1264310c3b8c848d4b90d5206179a40cc4" translate="yes" xml:space="preserve">
          <source>Administration</source>
          <target state="translated">Administration</target>
        </trans-unit>
        <trans-unit id="1eda23758be9e36e5e0d2a6a87de584aaca0193f" translate="yes" xml:space="preserve">
          <source>Administrator</source>
          <target state="translated">Administrator</target>
        </trans-unit>
        <trans-unit id="e6a9cb58c1721e13f0512658aa83841944c325f3" translate="yes" xml:space="preserve">
          <source>Admittedly, it's a little silly to use the curlies in this case, but the BLOCK can contain any arbitrary expression, in particular, subscripted expressions:</source>
          <target state="translated">诚然,在这种情况下使用卷标有点傻,但BLOCK可以包含任何任意的表达式,尤其是下标表达式。</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">高级功能</target>
        </trans-unit>
        <trans-unit id="64e04a8cbc4193de6f65fd1544695b7f543269ac" translate="yes" xml:space="preserve">
          <source>Advanced Possibilities</source>
          <target state="translated">先进的可能性</target>
        </trans-unit>
        <trans-unit id="a79e7b92e71c562343b0e0c5c252eadade25490c" translate="yes" xml:space="preserve">
          <source>Advanced Semaphores</source>
          <target state="translated">先进的语义词</target>
        </trans-unit>
        <trans-unit id="0d7049ed333121f6ad65eac902c5a2d1cec948e8" translate="yes" xml:space="preserve">
          <source>Advanced Topics</source>
          <target state="translated">高级主题</target>
        </trans-unit>
        <trans-unit id="5646362e1c7206c24de0aa69540a4070b9eef4ad" translate="yes" xml:space="preserve">
          <source>Affects screen appearance of the command line (see &lt;a href=&quot;term/readline&quot;&gt;Term::ReadLine&lt;/a&gt;). There is currently no way to disable these, which can render some output illegible on some displays, or with some pagers. This is considered a bug.</source>
          <target state="translated">影响命令行的屏幕外观（请参阅&lt;a href=&quot;term/readline&quot;&gt;Term :: ReadLine&lt;/a&gt;）。当前无法禁用这些功能，这会使某些显示器或某些寻呼机上的某些输出变得难以辨认。这被认为是一个错误。</target>
        </trans-unit>
        <trans-unit id="7ac09ae75b5fa764eed3b6f049863915415754f4" translate="yes" xml:space="preserve">
          <source>Affects the printing of messages upon entry and exit from subroutines. If &lt;code&gt;frame &amp;amp; 2&lt;/code&gt; is false, messages are printed on entry only. (Printing on exit might be useful if interspersed with other messages.)</source>
          <target state="translated">在子例程进入和退出时影响消息的打印。如果 &lt;code&gt;frame &amp;amp; 2&lt;/code&gt; 为false，则仅在输入时打印消息。（如果与其他消息一起穿插，则在退出时打印可能会很有用。）</target>
        </trans-unit>
        <trans-unit id="1d35114b8f34bf6224a46dac8d98b4ed3594b7f5" translate="yes" xml:space="preserve">
          <source>Africa</source>
          <target state="translated">Africa</target>
        </trans-unit>
        <trans-unit id="79ba5e1b3f99abfd54ef8d839ba12bd2ac4d79cb" translate="yes" xml:space="preserve">
          <source>After</source>
          <target state="translated">After</target>
        </trans-unit>
        <trans-unit id="87099a71e0044f05a4ae4680480a6ca9151bafd1" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigFloat ':constant'&lt;/code&gt; all the floating point constants in the given scope are converted to &lt;code&gt;Math::BigFloat&lt;/code&gt; . This conversion happens at compile time.</source>
          <target state="translated">之后 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigFloat ':constant'&lt;/code&gt; 所有的浮点在给定范围常量转换为 &lt;code&gt;Math::BigFloat&lt;/code&gt; 。这种转换发生在编译时。</target>
        </trans-unit>
        <trans-unit id="809e579562da8a6c62758fa5638ee2d5856559cc" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigInt ':constant'&lt;/code&gt; all the &lt;b&gt;integer&lt;/b&gt; decimal, hexadecimal and binary constants in the given scope are converted to &lt;code&gt;Math::BigInt&lt;/code&gt; . This conversion happens at compile time.</source>
          <target state="translated">后 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigInt ':constant'&lt;/code&gt; 的所有&lt;b&gt;整数&lt;/b&gt;十进制，十六进制和二进制常数在给定范围被转换成 &lt;code&gt;Math::BigInt&lt;/code&gt; 。这种转换发生在编译时。</target>
        </trans-unit>
        <trans-unit id="dc94e5687372ef5e696852ffc210ec8b3418a842" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; has returned all entries from the hash or array, the next call to &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; returns the empty list in list context and &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context; the next call following</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 都从哈希或数组返回了所有条目之后，对 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 的下一次调用将在列表上下文中返回空列表，而在标量上下文中返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ；下一个通话</target>
        </trans-unit>
        <trans-unit id="655e7d0919e193463d83e3f9f9d5abefb149c7ea" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; has returned all entries from the hash or array, the next call to &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; returns the empty list in list context and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context; the next call following</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 都从哈希或数组返回了所有条目之后，对 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 的下一次调用将在列表上下文中返回空列表，而在标量上下文中返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ；下一个通话</target>
        </trans-unit>
        <trans-unit id="1d724f064157a1afcae77bb02216759e4c7bf880" translate="yes" xml:space="preserve">
          <source>After a match against some variable &lt;code&gt;$var&lt;/code&gt; :</source>
          <target state="translated">与某些变量 &lt;code&gt;$var&lt;/code&gt; 匹配后：</target>
        </trans-unit>
        <trans-unit id="b84c3333b0e2cfaba4160f029890fe89d06d1d06" translate="yes" xml:space="preserve">
          <source>After a proper &lt;code&gt;POSIX::setlocale()&lt;/code&gt; call, and within the scope of of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes numerics, Perl obeys the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale information, which controls an application's idea of how numbers should be formatted for human readability. In most implementations the only effect is to change the character used for the decimal point--perhaps from &quot;.&quot; to &quot;,&quot;. The functions aren't aware of such niceties as thousands separation and so on. (See &lt;a href=&quot;#The-localeconv-function&quot;&gt;The localeconv function&lt;/a&gt; if you care about these things.)</source>
          <target state="translated">在正确的 &lt;code&gt;POSIX::setlocale()&lt;/code&gt; 调用之后，并且在包含数字的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 形式的范围内，Perl遵循 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 区域设置信息，该信息控制应用程序的思想，即应如何格式化数字以使其易于阅读。在大多数实现中，唯一的效果是更改了用于小数点的字符-也许从&amp;ldquo;。&amp;rdquo;开始。至 &amp;rdquo;，&amp;rdquo;。函数没有意识到千位分隔之类的优点。（如果您关心这些事情，请参见&lt;a href=&quot;#The-localeconv-function&quot;&gt;localeconv函数&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="1775073c0fe50242e57a96b412a98f0e94cc679a" translate="yes" xml:space="preserve">
          <source>After a successful compilation, you'll be able to use</source>
          <target state="translated">编译成功后,你就可以使用</target>
        </trans-unit>
        <trans-unit id="f087a68cf0ba68c94dea17e31581c5258e5a685a" translate="yes" xml:space="preserve">
          <source>After all, the best thing about this pragma is that you don't have to resort to \x{....} just to spell your name in a native encoding. So feel free to put your strings in your encoding in quotes and regexes.</source>
          <target state="translated">毕竟,这个pragma最好的一点是,你不必为了用本地编码拼写你的名字而求助于\x{......}。所以,你可以自由地将你的字符串用引号和regex放在你的编码中。</target>
        </trans-unit>
        <trans-unit id="7593ddf636c03d07a5c407ca6961ab2d5ad931e8" translate="yes" xml:space="preserve">
          <source>After an environment variable is tied, merely use it like a normal variable. You may access its value</source>
          <target state="translated">当一个环境变量被绑定后,只需像普通变量一样使用它。你可以访问它的值</target>
        </trans-unit>
        <trans-unit id="755e56a66bf3563f2fb9151f704977af6151c9b5" translate="yes" xml:space="preserve">
          <source>After an extension has been built and before it is installed it may be desirable to test it bypassing &lt;code&gt;make test&lt;/code&gt; . By adding</source>
          <target state="translated">在构建扩展之后，在安装扩展之前，可能需要绕过 &lt;code&gt;make test&lt;/code&gt; 对其进行测试。通过添加</target>
        </trans-unit>
        <trans-unit id="82f653c370563b01ec9f101f2aaad77e03914b8a" translate="yes" xml:space="preserve">
          <source>After command line parsing the following attributes reflect the values of the corresponding command line switches. They may be altered before calling &lt;code&gt;run&lt;/code&gt; .</source>
          <target state="translated">命令行解析后，以下属性反映了相应命令行开关的值。在调用 &lt;code&gt;run&lt;/code&gt; 之前，可以更改它们。</target>
        </trans-unit>
        <trans-unit id="5e251b544ae28a039470aaf55a5b7b59f40f8190" translate="yes" xml:space="preserve">
          <source>After each &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d file is compiled, but before it is executed, &lt;code&gt;DB::postponed(*{&quot;_&amp;lt;$filename&quot;})&lt;/code&gt; is called if the subroutine &lt;code&gt;DB::postponed&lt;/code&gt; exists. Here, the $filename is the expanded name of the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d file, as found in the values of %INC.</source>
          <target state="translated">在编译每个 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; d文件之后，但在执行该文件之前，如果子例程 &lt;code&gt;DB::postponed&lt;/code&gt; 存在，则会调用 &lt;code&gt;DB::postponed(*{&quot;_&amp;lt;$filename&quot;})&lt;/code&gt; 。在这里，$ filename是 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; d文件的扩展名，如％INC的值所示。</target>
        </trans-unit>
        <trans-unit id="e73cebac8df604a03fa2c93d2c658b08259d94b6" translate="yes" xml:space="preserve">
          <source>After each subroutine &lt;code&gt;subname&lt;/code&gt; is compiled, the existence of &lt;code&gt;$DB::postponed{subname}&lt;/code&gt; is checked. If this key exists, &lt;code&gt;DB::postponed(subname)&lt;/code&gt; is called if the &lt;code&gt;DB::postponed&lt;/code&gt; subroutine also exists.</source>
          <target state="translated">编译每个子例程 &lt;code&gt;subname&lt;/code&gt; 后，将检查 &lt;code&gt;$DB::postponed{subname}&lt;/code&gt; 是否存在。如果该键存在，则如果 &lt;code&gt;DB::postponed&lt;/code&gt; 子例程也存在，则调用 &lt;code&gt;DB::postponed(subname)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e09c67a58e395afd52ffb2f20be8dce115f5694f" translate="yes" xml:space="preserve">
          <source>After each such removal you need to rerun the &lt;code&gt;Makefile.PL&lt;/code&gt; /&lt;code&gt;make&lt;/code&gt; process; usually this procedure converges soon. (But be sure to convert all the necessary external C libraries from</source>
          <target state="translated">每次删除之后，您需要重新运行 &lt;code&gt;Makefile.PL&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; 进程；通常，此过程会很快收敛。（但是请确保将所有必需的外部C库从</target>
        </trans-unit>
        <trans-unit id="eb84d48b7946333a20d799fbde5105dfdef9cef8" translate="yes" xml:space="preserve">
          <source>After extracting the archive you copy the whole directory tree to your EBCDIC filesystem. &lt;b&gt;This time you use I/O-conversion&lt;/b&gt;:</source>
          <target state="translated">解压缩档案文件后，将整个目录树复制到EBCDIC文件系统。&lt;b&gt;这次您使用I / O转换&lt;/b&gt;：</target>
        </trans-unit>
        <trans-unit id="19dac0c58c8882858862b2f71b6cf8f32d646112" translate="yes" xml:space="preserve">
          <source>After having failed to remove a directory, &lt;code&gt;remove_tree&lt;/code&gt; was unable to restore its permissions from a permissive state back to a possibly more restrictive setting. (Permissions given in octal).</source>
          <target state="translated">删除目录失败后， &lt;code&gt;remove_tree&lt;/code&gt; 无法将其权限从允许状态还原回可能更严格的设置。（权限以八进制给出）。</target>
        </trans-unit>
        <trans-unit id="82bcd3184999ba561b43a537f2cc4ce40931101a" translate="yes" xml:space="preserve">
          <source>After having failed to remove a file, &lt;code&gt;remove_tree&lt;/code&gt; was also unable to restore the permissions on the file to a possibly less permissive setting. (Permissions given in octal).</source>
          <target state="translated">删除文件失败后， &lt;code&gt;remove_tree&lt;/code&gt; 也无法将文件的权限还原为可能不太宽松的设置。（权限以八进制给出）。</target>
        </trans-unit>
        <trans-unit id="23dac87df7f1fec6e0cffc03d2d5c4ff05ad76e5" translate="yes" xml:space="preserve">
          <source>After having this in the first part of .xs file, the &quot;Perl glue&quot; part becomes as simple as</source>
          <target state="translated">在.xs文件的第一部分有了这些内容之后,&quot;Perl胶水 &quot;的部分就变得很简单了。</target>
        </trans-unit>
        <trans-unit id="2a05093cdd7b4cafe419584a2ca96b5327589ac9" translate="yes" xml:space="preserve">
          <source>After importing this module, when you use localtime or gmtime in a scalar context, rather than getting an ordinary scalar string representing the date and time, you get a Time::Piece object, whose stringification happens to produce the same effect as the localtime and gmtime functions. There is also a new() constructor provided, which is the same as localtime(), except when passed a Time::Piece object, in which case it's a copy constructor. The following methods are available on the object:</source>
          <target state="translated">导入这个模块后,当你在标量上下文中使用localtime或gmtime时,不是得到一个普通的标量字符串代表日期和时间,而是得到一个Time::Piece对象,它的字符串化恰好产生与localtime和gmtime函数相同的效果。还提供了一个new()构造函数,它和localtime()一样,只是在传递一个Time::Piece对象时,在这种情况下,它是一个复制构造函数。对象上有以下方法。</target>
        </trans-unit>
        <trans-unit id="989e7c432fe7873dedca66b4efcb012930902467" translate="yes" xml:space="preserve">
          <source>After initialisation @dl_library_path can be manipulated by an application using push and unshift before calling dl_findfile(). Unshift can be used to add directories to the front of the search order either to save search time or to override libraries with the same name in the 'normal' directories.</source>
          <target state="translated">初始化后,@dl_library_path可以在调用dl_findfile()之前被应用程序使用push和unshift进行操作。Unshift可以用来添加目录到搜索顺序的前面,以节省搜索时间或者覆盖 &quot;正常 &quot;目录中的同名库。</target>
        </trans-unit>
        <trans-unit id="384ec4e8afa39c03a7ec5ccae79ea44f50b98953" translate="yes" xml:space="preserve">
          <source>After installation &amp;amp; testing processes will stabilize, information will be more precise.</source>
          <target state="translated">在安装和测试过程稳定之后，信息将更加精确。</target>
        </trans-unit>
        <trans-unit id="2fb4a06d67a8330d3fbde3ddb1645d723c7e519d" translate="yes" xml:space="preserve">
          <source>After installing cpan-mac, drop the module archive on the &lt;b&gt;untarzipme&lt;/b&gt; droplet, which will decompress and unpack for you.</source>
          <target state="translated">安装cpan-mac之后，将模块档案文件拖放到&lt;b&gt;untarzipme小&lt;/b&gt;滴上，它将为您解压缩并解压缩。</target>
        </trans-unit>
        <trans-unit id="ebf5ce736aa7d823aae94b0fbadad820a15f7f86" translate="yes" xml:space="preserve">
          <source>After locating your program, Perl compiles the entire program to an internal form. If there are any compilation errors, execution of the program is not attempted. (This is unlike the typical shell script, which might run part-way through before finding a syntax error.)</source>
          <target state="translated">找到你的程序后,Perl会将整个程序编译成内部形式。如果有任何编译错误,就不会尝试执行程序。这与典型的 shell 脚本不同,后者可能会在发现语法错误之前运行一部分)。</target>
        </trans-unit>
        <trans-unit id="1f14adfb2016d61c246f44ef48217385e9787764" translate="yes" xml:space="preserve">
          <source>After much staring at the same piece of code and not seeing the wood for the trees for some time, we get a cup of coffee and try another approach. That is, we bring in the cavalry by giving perl the '&lt;b&gt;-d&lt;/b&gt;' switch on the command line:</source>
          <target state="translated">在盯着同一段代码并且一段时间没有看到树木的树木之后，我们喝了一杯咖啡，然后尝试另一种方法。也就是说，我们通过在命令行中为perl提供' &lt;b&gt;-d&lt;/b&gt; '开关来引入骑兵：</target>
        </trans-unit>
        <trans-unit id="88dec92da58c74e4620b3cd18d97733f553fa72c" translate="yes" xml:space="preserve">
          <source>After parsing the TAP, there are many methods available to let you dig through the results and determine what is meaningful to you.</source>
          <target state="translated">在解析TAP之后,有很多方法可以让你挖掘结果,确定对你有意义的东西。</target>
        </trans-unit>
        <trans-unit id="b702243123830daddfd7ae611e2d0a89f36745c6" translate="yes" xml:space="preserve">
          <source>After parsing, this method returns any warnings encountered during the parsing process.</source>
          <target state="translated">在解析之后,本方法返回解析过程中遇到的任何警告。</target>
        </trans-unit>
        <trans-unit id="cebf2b23cf8d6511ea00c15fa6633daadf530471" translate="yes" xml:space="preserve">
          <source>After positional parameters, additional arguments may be captured in a slurpy parameter. The simplest form of this is just an array variable:</source>
          <target state="translated">在位置参数之后,可以用一个模糊参数来捕获额外的参数。最简单的形式就是一个数组变量而已。</target>
        </trans-unit>
        <trans-unit id="79faa591ef4aa9c1048ecde8617caf4bb4f6e42f" translate="yes" xml:space="preserve">
          <source>After processing of the error using</source>
          <target state="translated">在对错误进行处理后,使用</target>
        </trans-unit>
        <trans-unit id="de441b5d72f77ccdab32c953f236dc0929b26bfe" translate="yes" xml:space="preserve">
          <source>After reading &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; explaining how to use &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; we can write this Perl function copying a file to standard output:</source>
          <target state="translated">阅读了&lt;a href=&quot;perlfunc&quot;&gt;perlfunc并&lt;/a&gt;解释了如何使用 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 后,我们可以编写将文件复制到标准输出的Perl函数：</target>
        </trans-unit>
        <trans-unit id="79b88eddec153e8e34fbe3804e13971f48b0d9e3" translate="yes" xml:space="preserve">
          <source>After reading this document, you ought to read &lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt; too, then &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">阅读此文档后，您还应该阅读&lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt;，然后阅读&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bde067e2f6a70b830351def3b30472931261a063" translate="yes" xml:space="preserve">
          <source>After that,</source>
          <target state="translated">在那之后。</target>
        </trans-unit>
        <trans-unit id="33a6f21294ecc8bfb003384c79fe3378bc362230" translate="yes" xml:space="preserve">
          <source>After the call to &lt;code&gt;inflate&lt;/code&gt;</source>
          <target state="translated">通话结束后，以 &lt;code&gt;inflate&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="82f20576e0d7a55f07ad388dd8a48aef5935809c" translate="yes" xml:space="preserve">
          <source>After the compile tree for a subroutine (or for an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or a file) is created, an additional pass over the code is performed. This pass is neither top-down or bottom-up, but in the execution order (with additional complications for conditionals). Optimizations performed at this stage are subject to the same restrictions as in the pass 2.</source>
          <target state="translated">创建子例程（或 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 或文件）的编译树后，将执行代码的附加传递。此过程既不是自上而下也不是自下而上的，而是按执行顺序进行的（附加附加条件复杂性）。在此阶段执行的优化受到与第二遍相同的限制。</target>
        </trans-unit>
        <trans-unit id="030398b98f864699ff503816f85c07e82cf00fe5" translate="yes" xml:space="preserve">
          <source>After the match fails at the letter &lt;code&gt;a&lt;/code&gt; , perl resets &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; and the next match on the same string starts at the beginning.</source>
          <target state="translated">在字母 &lt;code&gt;a&lt;/code&gt; 匹配失败后，perl重置 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; ,并且同一字符串的下一个匹配从头开始。</target>
        </trans-unit>
        <trans-unit id="293c71dbddf34e425e567a76e0a301441dc6a8bc" translate="yes" xml:space="preserve">
          <source>After the rc file is read, the debugger reads the &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; environment variable and parses this as the remainder of a &quot;O ...&quot; line as one might enter at the debugger prompt. You may place the initialization options &lt;code&gt;TTY&lt;/code&gt; , &lt;code&gt;noTTY&lt;/code&gt; , &lt;code&gt;ReadLine&lt;/code&gt; , and &lt;code&gt;NonStop&lt;/code&gt; there.</source>
          <target state="translated">读取rc文件后，调试器将读取 &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; 环境变量，并将其解析为&amp;ldquo; O ...&amp;rdquo;行的其余部分，因为可能会在调试器提示符下输入该行。您可以在其中放置初始化选项 &lt;code&gt;TTY&lt;/code&gt; ， &lt;code&gt;noTTY&lt;/code&gt; ， &lt;code&gt;ReadLine&lt;/code&gt; 和 &lt;code&gt;NonStop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e899e5cdac5e0e6b4bee21b7339405a7360957f3" translate="yes" xml:space="preserve">
          <source>After the rc file is read, the debugger reads the PERLDB_OPTS environment variable and uses it to set debugger options. The contents of this variable are treated as if they were the argument of an &lt;code&gt;o ...&lt;/code&gt; debugger command (q.v. in &lt;a href=&quot;perldebug#Configurable-Options&quot;&gt;Configurable Options in perldebug&lt;/a&gt;).</source>
          <target state="translated">读取rc文件后，调试器将读取PERLDB_OPTS环境变量，并使用它来设置调试器选项。将该变量的内容视为 &lt;code&gt;o ...&lt;/code&gt; 调试器命令（&lt;a href=&quot;perldebug#Configurable-Options&quot;&gt;perldebug的Configurable Options中的qv&lt;/a&gt;）的参数。</target>
        </trans-unit>
        <trans-unit id="48e96da87f1b22f4a662b486f469bd089c2d194f" translate="yes" xml:space="preserve">
          <source>After this you can direct your browser the file</source>
          <target state="translated">在这之后,您可以直接将您的浏览器文件</target>
        </trans-unit>
        <trans-unit id="047aa94c055cd198e88e38eec23f2d3fb520f816" translate="yes" xml:space="preserve">
          <source>After this you can either copy Perl from your operating system media (you will need at least the /System/Library/Perl and /usr/bin/perl), or rebuild Perl from the source code with &lt;code&gt;Configure -Dprefix=/usr
-Duseshrplib&lt;/code&gt; NOTE: the &lt;code&gt;-Dprefix=/usr&lt;/code&gt; to replace the system Perl works much better with Perl 5.8.1 and later, in Perl 5.8.0 the settings were not quite right.</source>
          <target state="translated">之后，您可以从操作系统介质中复制Perl（至少需要/ System / Library / Perl和/ usr / bin / perl），也可以使用 &lt;code&gt;Configure -Dprefix=/usr -Duseshrplib&lt;/code&gt; 从源代码重建Perl。注意： &lt;code&gt;-Dprefix=/usr&lt;/code&gt; 替换系统Perl在Perl 5.8.1及更高版本中的工作效果更好，在Perl 5.8.0中，设置不太正确。</target>
        </trans-unit>
        <trans-unit id="afc63f5dda4ecced4f5f45482623e56ea1f306ab" translate="yes" xml:space="preserve">
          <source>After you have built perl using the Configure script, ensure that you have modify and default write permission to &lt;code&gt;&amp;gt;system&amp;gt;ported&lt;/code&gt; and all subdirectories. Then type</source>
          <target state="translated">使用Configure脚本构建perl之后，请确保您具有对 &lt;code&gt;&amp;gt;system&amp;gt;ported&lt;/code&gt; 和所有子目录的修改和默认写权限。然后输入</target>
        </trans-unit>
        <trans-unit id="8aca2e8c01b81a07c6eb69c26b8265b8e7beb0f1" translate="yes" xml:space="preserve">
          <source>After you installed the components you needed and updated the</source>
          <target state="translated">当你安装了你需要的组件并更新了</target>
        </trans-unit>
        <trans-unit id="61179f6b3dda7b5ee08dd7ce8f69dddb876677ab" translate="yes" xml:space="preserve">
          <source>Again assuming the existence of the &lt;code&gt;tree&lt;/code&gt; database</source>
          <target state="translated">再次假设存在 &lt;code&gt;tree&lt;/code&gt; 数据库</target>
        </trans-unit>
        <trans-unit id="7c2b707160e59a8a50ca98c9028a92309952c8b9" translate="yes" xml:space="preserve">
          <source>Again like &lt;code&gt;cond_wait&lt;/code&gt; , waking up and reacquiring the lock are not atomic, and you should always check your desired condition after this function returns. Since the timeout is an absolute value, however, it does not have to be recalculated with each pass:</source>
          <target state="translated">再次像 &lt;code&gt;cond_wait&lt;/code&gt; 一样，唤醒和重新获取锁也不是原子的，因此在此函数返回后，您应始终检查所需的条件。但是，由于超时是一个绝对值，因此不必每次遍历都重新计算它：</target>
        </trans-unit>
        <trans-unit id="f1807d38160980407aafc2417f04ad9be3af89ae" translate="yes" xml:space="preserve">
          <source>Again, for elementary pieces there is no such question, since at most one match at a given position is possible. This section describes the notion of better/worse for combining operators. In the description below &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; are regular subexpressions.</source>
          <target state="translated">再次，对于基本件没有问题，因为在给定位置最多只能进行一次比赛。本节描述合并运算符的更好/更糟的概念。在下面的描述中， &lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; 是常规子表达式。</target>
        </trans-unit>
        <trans-unit id="5f5a18a4eff39b7d1528cf15b17087b5d8251fa1" translate="yes" xml:space="preserve">
          <source>Again, if you already have the data in memory or want to avoid the complexity of the above, you can use sv_setpvn().</source>
          <target state="translated">同样,如果你在内存中已经有了数据,或者想避免上述的复杂性,你可以使用sv_setpvn()。</target>
        </trans-unit>
        <trans-unit id="cf8e2e1b9b0e08a7a42ff9da61e6daf28394e96e" translate="yes" xml:space="preserve">
          <source>Again, the PERL_DL_NONLAZY thing.</source>
          <target state="translated">再说说PERL_DL_NONLAZY的事情。</target>
        </trans-unit>
        <trans-unit id="cc9355813d20c04f9885340bd38f5820f772f6ef" translate="yes" xml:space="preserve">
          <source>Again, the result is a string, now containing 2 bytes. If you print this string (which is, generally, not recommended) you might see &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;NO&lt;/code&gt; (depending on your system's byte ordering) - or something entirely different if your computer doesn't use ASCII character encoding. Unpacking &lt;code&gt;$ps&lt;/code&gt; with the same template returns the original integer value:</source>
          <target state="translated">同样，结果是一个字符串，现在包含2个字节。如果打印此字符串（通常不建议这样做），则可能会看到&amp;ldquo; &lt;code&gt;ON&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;NO&lt;/code&gt; &amp;rdquo;（取决于系统的字节顺序），或者如果您的计算机不使用ASCII字符编码，则显示完全不同的内容。使用相同的模板解包 &lt;code&gt;$ps&lt;/code&gt; 将返回原始整数值：</target>
        </trans-unit>
        <trans-unit id="1336fb8f59fe4c2604eb97dc0557c0ec454667ba" translate="yes" xml:space="preserve">
          <source>Again, the same rule about having a valid invocand applies -- use an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block or &lt;code&gt;blessed&lt;/code&gt; if you need to be extra paranoid.</source>
          <target state="translated">同样，关于拥有有效被请求者的规则也适用- 如果需要额外的偏执狂，请使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 块或 &lt;code&gt;blessed&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f032390a780d79dd005854d30b600a71dcbdee7e" translate="yes" xml:space="preserve">
          <source>Again, there is a distinction between omitting LIST (&lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; called with no arguments) and an explicit empty LIST &lt;code&gt;()&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; not called). Note that there is no comma after VERSION!</source>
          <target state="translated">同样，在省略LIST（不带参数调用的 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ）和显式的空LIST &lt;code&gt;()&lt;/code&gt; （不调用 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ）之间有区别。请注意，VERSION之后没有逗号！</target>
        </trans-unit>
        <trans-unit id="150579942e699af9662ec748d7e74bb724b4dd49" translate="yes" xml:space="preserve">
          <source>Again, there is a distinction between omitting LIST (&lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; called with no arguments) and an explicit empty LIST &lt;code&gt;()&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; not called). Note that there is no comma after VERSION!</source>
          <target state="translated">同样，在省略LIST（不带参数调用的 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ）和显式的空LIST &lt;code&gt;()&lt;/code&gt; （不调用 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ）之间有区别。请注意，VERSION之后没有逗号！</target>
        </trans-unit>
        <trans-unit id="245e36d26002b84ee14a1352ac81744d3ee557bd" translate="yes" xml:space="preserve">
          <source>Again, this allows for very dynamic code.</source>
          <target state="translated">同样,这允许非常动态的代码。</target>
        </trans-unit>
        <trans-unit id="b538a15a09c26e00740fa45cdf77f8fdb9a0d9a7" translate="yes" xml:space="preserve">
          <source>Again, this procedure should not be absolutely smooth. Some &lt;code&gt;Makefile.PL&lt;/code&gt; 's in subdirectories may be buggy, and would not run as &quot;child&quot; scripts. The interdependency of modules can strike you; however, since non-XS modules are already installed, the prerequisites of most modules have a very good chance to be present.</source>
          <target state="translated">同样，此过程不应绝对平滑。子目录中的某些 &lt;code&gt;Makefile.PL&lt;/code&gt; 可能有错误，并且不能作为&amp;ldquo;子&amp;rdquo;脚本运行。模块之间的相互依赖会打击您；但是，由于已经安装了非XS模块，因此大多数模块的前提条件都有很大的机会出现。</target>
        </trans-unit>
        <trans-unit id="d29cd93346e769552a8195aadabaa89c166d289b" translate="yes" xml:space="preserve">
          <source>Again, this should be a last resort only. Ideally, this should never happen, and every possible effort at cooperation and compromise should be made before doing this. If it does prove necessary to fork a module for the overall health of Perl, proper credit must be given to the original author in perpetuity and the decision should be constantly re-evaluated to see if a remerging of the two branches is possible down the road.</source>
          <target state="translated">同样,这应该是最后的手段。理想情况下,这种情况是绝对不应该发生的,而且在这样做之前,应该尽一切可能进行合作和妥协。如果为了Perl的整体健康发展,确实有必要对某个模块进行分叉,那么必须永久地将功劳归于原作者,并且应该不断地对这个决定进行重新评估,以确定将来是否有可能将两个分支重新合并。</target>
        </trans-unit>
        <trans-unit id="3a830cc268120c6d62fd1503dae1fe4595320a8c" translate="yes" xml:space="preserve">
          <source>Aggregate TAP::Parser results</source>
          <target state="translated">汇总TAP::解析器结果</target>
        </trans-unit>
        <trans-unit id="c99323987b877f0729176ba94246c79d0ffee75d" translate="yes" xml:space="preserve">
          <source>Ah, but what if you wanted a</source>
          <target state="translated">啊,但如果你想要一个</target>
        </trans-unit>
        <trans-unit id="fc54c7321882850cd59ca3c898a45a1866c62d48" translate="yes" xml:space="preserve">
          <source>Alan Burlison &amp;lt;Alan.Burlison@uk.sun.com&amp;gt;</source>
          <target state="translated">艾伦&amp;middot;伯里森（Alan Burlison）&amp;lt;Alan.Burlison@uk.sun.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="28819c4f1ea8b8ef6efc038b761b2ce064e6ebed" translate="yes" xml:space="preserve">
          <source>Alas, however simple this may appear, underneath it's a much more elaborate construct than meets the eye!</source>
          <target state="translated">唉,不管这看起来多么简单,在它的下面,是一个比表面上看起来更复杂的构造!</target>
        </trans-unit>
        <trans-unit id="60deebc91420b65bfc5133938fc33e7af7cddcdc" translate="yes" xml:space="preserve">
          <source>Albeit this is apt to be confusing: As a consequence of the length being implied by the string's length, a number after pack code &lt;code&gt;p&lt;/code&gt; is a repeat count, not a length as after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">尽管这容易造成混淆：由于字符串的长度暗示了长度，所以包装代码 &lt;code&gt;p&lt;/code&gt; 之后的数字是重复计数，而不是 &lt;code&gt;P&lt;/code&gt; 之后的长度。</target>
        </trans-unit>
        <trans-unit id="c375d17736d5ba75bae4628bbac2b8464ec67f67" translate="yes" xml:space="preserve">
          <source>Alex Waugh &amp;lt;alex@alexwaugh.com&amp;gt;</source>
          <target state="translated">亚历克斯&amp;middot;沃（Alex Waugh）&amp;lt;alex@alexwaugh.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="98410e18a5313b84b52dba6923f79fa84662fc78" translate="yes" xml:space="preserve">
          <source>Algorithmic Complexity Attacks</source>
          <target state="translated">算法复杂度攻击</target>
        </trans-unit>
        <trans-unit id="880e348dcb112fd7762be969b0a0f638889a7979" translate="yes" xml:space="preserve">
          <source>Alias 'great_circle_bearing' for 'great_circle_direction' is also available.</source>
          <target state="translated">也有'great_circle_bearing'的别名'great_circle_direction'。</target>
        </trans-unit>
        <trans-unit id="0898ef4b9ee98efd06a1a0a5dfd90a367c2cd721" translate="yes" xml:space="preserve">
          <source>Alias definitions to encodings</source>
          <target state="translated">编码的别名定义</target>
        </trans-unit>
        <trans-unit id="38f722ea341fc11c96b38a2a9a95013e2024c780" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/accept_codes&quot;&gt;accept_codes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/accept_codes&quot;&gt;accept_codes的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="f3ca2b4415e7c30e7f132f19403b5bffd02f19e2" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets&quot;&gt;accept_targets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets&quot;&gt;accept_targets的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="90cb0f686347b95e9bf9ac20dee8ecef9cc3e7cc" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets_as_text&quot;&gt;accept_targets_as_text&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets_as_text&quot;&gt;accept_targets_as_text的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="d8a37b728f269336ef2b0d916cf56f8cff9a7dab" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_codes&quot;&gt;unaccept_codes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_codes&quot;&gt;unaccept_codes的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="55942451ef5112cddaa2996d9b3ade198613f3aa" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_directives&quot;&gt;unaccept_directives&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_directives&quot;&gt;unaccept_directives的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="fc63b361fbc74519b267bcb5465524b93139434d" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_targets&quot;&gt;unaccept_targets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_targets&quot;&gt;unaccept_targets的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="74c2c2daa5f5a0797029a2454513a78581202693" translate="yes" xml:space="preserve">
          <source>Alias overloading</source>
          <target state="translated">别名超载</target>
        </trans-unit>
        <trans-unit id="f57cd105a2d625b230e3773e4d9ad4fd8007e4e8" translate="yes" xml:space="preserve">
          <source>Aliases are added either by the use of anonymous hashes:</source>
          <target state="translated">别名的添加要么使用匿名哈希。</target>
        </trans-unit>
        <trans-unit id="a04d03e091eed69bf0cabdf08f34999597a31b63" translate="yes" xml:space="preserve">
          <source>Aliases have no effect on the return value of uncolor().</source>
          <target state="translated">别名对uncolor()的返回值没有影响。</target>
        </trans-unit>
        <trans-unit id="bde3b653ba60660ff94a6811c58e93a5bf93107d" translate="yes" xml:space="preserve">
          <source>Aliases must begin with a character that is alphabetic. After that, each may contain any combination of word (&lt;code&gt;\w&lt;/code&gt; ) characters, SPACE (U+0020), HYPHEN-MINUS (U+002D), LEFT PARENTHESIS (U+0028), RIGHT PARENTHESIS (U+0029), and NO-BREAK SPACE (U+00A0). These last three should never have been allowed in names, and are retained for backwards compatibility only; NO-BREAK SPACE IS currently deprecated and scheduled for removal in Perl v5.26; the other two may also be deprecated and removed in future releases of Perl, so don't use them for new names. (More precisely, the first character of a name you specify must be something that matches all of &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{Alphabetic}&lt;/code&gt; , and &lt;code&gt;\p{Gc=Letter}&lt;/code&gt; . This makes sure it is what any reasonable person would view as an alphabetic character. And, the continuation characters that match &lt;code&gt;\w&lt;/code&gt; must also match &lt;code&gt;\p{ID_Continue}&lt;/code&gt; .) Starting with Perl v5.18, any Unicode characters meeting the above criteria may be used; prior to that only Latin1-range characters were acceptable.</source>
          <target state="translated">别名必须以字母字符开头。之后，每个字符都可以包含单词（ &lt;code&gt;\w&lt;/code&gt; ）字符，空格（U + 0020），连字符减号（U + 002D），左手腕（U + 0028），右手腕（U + 0029）和否的任意组合-BREAK空间（U + 00A0）。名称中绝不允许使用后三个名称，而保留它们仅是为了向后兼容。目前不建议使用NO-BREAK SPACE，并计划在Perl v5.26中将其删除。另外两个可能在Perl的将来版本中也被弃用并删除，因此不要将它们用作新名称。 （更确切地说，您指定的名称的第一个字符必须与所有 &lt;code&gt;\p{ID_Start}&lt;/code&gt; ， &lt;code&gt;\p{Alphabetic}&lt;/code&gt; 和 &lt;code&gt;\p{Gc=Letter}&lt;/code&gt; 都匹配。这确保了任何有理智的人都会将其视为字母字符。并且，与 &lt;code&gt;\w&lt;/code&gt; 匹配的延续字符也必须与 &lt;code&gt;\p{ID_Continue}&lt;/code&gt; 匹配。）从Perl v5.18开始，可以使用满足上述条件的任何Unicode字符；在此之前，只能接受Latin1范围字符。</target>
        </trans-unit>
        <trans-unit id="91f975513dec5dd8e68b29fb075833bd77c269b1" translate="yes" xml:space="preserve">
          <source>Alignment, Take 2</source>
          <target state="translated">调整,第2次</target>
        </trans-unit>
        <trans-unit id="a1ea8b54954e0fde287940a149a033befa43e6c8" translate="yes" xml:space="preserve">
          <source>Alignment, Take 3</source>
          <target state="translated">调整,第3次</target>
        </trans-unit>
        <trans-unit id="764199267e4fee8134969e2bb73e632b952ebdb3" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;--sources&lt;/code&gt; are combined into a hash, and passed to &lt;a href=&quot;tap/harness#new&quot;&gt;new in TAP::Harness&lt;/a&gt;'s &lt;code&gt;sources&lt;/code&gt; parameter.</source>
          <target state="translated">所有 &lt;code&gt;--sources&lt;/code&gt; 组合成一个哈希，然后传递给&lt;a href=&quot;tap/harness#new&quot;&gt;TAP :: Harness&lt;/a&gt;的 &lt;code&gt;sources&lt;/code&gt; 参数中的new。</target>
        </trans-unit>
        <trans-unit id="f52d6e40e6d60dfb65b7ff9829f21ad743f4c4af" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;Digest::&lt;/code&gt; modules provide the same programming interface. A functional interface for simple use, as well as an object oriented interface that can handle messages of arbitrary length and which can read files directly.</source>
          <target state="translated">所有 &lt;code&gt;Digest::&lt;/code&gt; 模块都提供相同的编程接口。简单易用的功能接口，以及可以处理任意长度的消息并可以直接读取文件的面向对象的接口。</target>
        </trans-unit>
        <trans-unit id="457b3764fb61bab63f516bcecf7b3d7be10ba056" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;TAP::*&lt;/code&gt; objects inherit from &lt;a href=&quot;object&quot;&gt;TAP::Object&lt;/a&gt;.</source>
          <target state="translated">所有 &lt;code&gt;TAP::*&lt;/code&gt; 对象都继承自&lt;a href=&quot;object&quot;&gt;TAP :: Object&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5afc429b1453c07f0d0baef120b89dcb6d31ac74" translate="yes" xml:space="preserve">
          <source>All I want to do is append a small amount of text to the end of a file. Do I still have to use locking?</source>
          <target state="translated">我只想在文件末尾添加少量文字。我还需要使用锁定吗?</target>
        </trans-unit>
        <trans-unit id="364f430073ddd95c184ef6908813da97f63c8227" translate="yes" xml:space="preserve">
          <source>All NULs, returns, and newlines are removed from the result.</source>
          <target state="translated">所有的NULs、回车和换行都会从结果中删除。</target>
        </trans-unit>
        <trans-unit id="3357b46fb83adc9becdcce6c42b795ffab969cd7" translate="yes" xml:space="preserve">
          <source>All Perl applications that make use of the script will need to be changed (slightly) if the script is converted into a module. Is it worth it unless you plan to make other changes at the same time?</source>
          <target state="translated">如果将脚本转换为模块,所有使用该脚本的Perl应用程序都需要进行修改(略)。除非你打算同时做其他改动,否则值得吗?</target>
        </trans-unit>
        <trans-unit id="c0556d5f4ef8cf5b2d75a71a511d88da552691b2" translate="yes" xml:space="preserve">
          <source>All Perl module files have the extension</source>
          <target state="translated">所有Perl模块文件的扩展名为</target>
        </trans-unit>
        <trans-unit id="c9df8c5103a954885f4c9cd5391cce1f658e5378" translate="yes" xml:space="preserve">
          <source>All Perl source filters are implemented as Perl classes and have the same basic structure as the example above.</source>
          <target state="translated">所有的Perl源码过滤器都是以Perl类的形式实现的,其基本结构与上面的例子相同。</target>
        </trans-unit>
        <trans-unit id="a24109cbe749713ab37960e5621fab63c25af84c" translate="yes" xml:space="preserve">
          <source>All SVs that contain strings should be terminated with a &lt;code&gt;NUL&lt;/code&gt; character. If it is not &lt;code&gt;NUL&lt;/code&gt; -terminated there is a risk of core dumps and corruptions from code which passes the string to C functions or system calls which expect a &lt;code&gt;NUL&lt;/code&gt; -terminated string. Perl's own functions typically add a trailing &lt;code&gt;NUL&lt;/code&gt; for this reason. Nevertheless, you should be very careful when you pass a string stored in an SV to a C function or system call.</source>
          <target state="translated">所有包含字符串的SV都应以 &lt;code&gt;NUL&lt;/code&gt; 字符结尾。如果不是以 &lt;code&gt;NUL&lt;/code&gt; 终止的字符串，则存在核心转储和代码损坏的风险，这些代码会将字符串传递给C函数或系统调用，这些函数期望以 &lt;code&gt;NUL&lt;/code&gt; 终止的字符串。为此，Perl自己的函数通常会添加一个尾随 &lt;code&gt;NUL&lt;/code&gt; 。但是，将SV中存储的字符串传递给C函数或系统调用时应格外小心。</target>
        </trans-unit>
        <trans-unit id="48a5c9b581d8c7b87b13529ddc2ea4756cd71725" translate="yes" xml:space="preserve">
          <source>All Solaris documentation is available on-line at &lt;a href=&quot;http://docs.sun.com/&quot;&gt;http://docs.sun.com/&lt;/a&gt;.</source>
          <target state="translated">所有Solaris文档均可从&lt;a href=&quot;http://docs.sun.com/&quot;&gt;http://docs.sun.com/&lt;/a&gt;在线获得。</target>
        </trans-unit>
        <trans-unit id="02a6fc4950c3ff395602f4e234c32b98fa8bbb9b" translate="yes" xml:space="preserve">
          <source>All Unicode-defined character properties may be written in these compound forms of &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; or &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;:&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt;, but Perl provides some additional properties that are written only in the single form, as well as single-form short-cuts for all binary properties and certain others described below, in which you may omit the property name and the equals or colon separator.</source>
          <target state="translated">所有Unicode定义的字符属性都可以用 &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; 或 &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;:&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; 这些复合形式编写，但是Perl提供了一些其他属性，这些属性仅以单一形式以及为所有二进制属性和下面描述的某些其他属性形成快捷方式，您可以在其中省略属性名称和等号或冒号分隔符。</target>
        </trans-unit>
        <trans-unit id="824a27b5a0842833d945bd7311a2e5202945d5f2" translate="yes" xml:space="preserve">
          <source>All above are #define'd to stdio functions or are trivial wrapper functions which call stdio. In this case</source>
          <target state="translated">以上所有函数都是#定义为stdio函数,或者是调用stdio的琐碎包装函数。在这种情况下</target>
        </trans-unit>
        <trans-unit id="480b6099af5b199261a0cc5b0a69906525b8aab5" translate="yes" xml:space="preserve">
          <source>All are zero-width assertions.</source>
          <target state="translated">都是零宽度的论断。</target>
        </trans-unit>
        <trans-unit id="ea4147392f071907aee8241573927949a9171c29" translate="yes" xml:space="preserve">
          <source>All arguments are optional. If the escape characters are not specified, every delimiter is escaped with a backslash (&lt;code&gt;\&lt;/code&gt; ). If the prefix is not specified, the pattern &lt;code&gt;'\s*'&lt;/code&gt; - optional whitespace - is used. If the delimiter set is also not specified, the set &lt;code&gt;/[&quot;'`]/&lt;/code&gt; is used. If the text to be processed is not specified either, &lt;code&gt;$_&lt;/code&gt; is used.</source>
          <target state="translated">所有参数都是可选的。如果未指定转义字符，则每个定界符都以反斜杠（ &lt;code&gt;\&lt;/code&gt; ）进行转义。如果未指定前缀，则使用模式 &lt;code&gt;'\s*'&lt;/code&gt; -可选的空格-。如果也未指定定界符集，则使用 &lt;code&gt;/[&quot;'`]/&lt;/code&gt; ；如果也未指定要处理的文本，则使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ae556487b52756ee168bee18fdadcf299ff8eb4" translate="yes" xml:space="preserve">
          <source>All arguments passed to &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; are passed onto &lt;code&gt;Your::Module-&amp;gt;builder-&amp;gt;plan()&lt;/code&gt; with the exception of &lt;code&gt;import =&amp;gt;[qw(things to import)]&lt;/code&gt; .</source>
          <target state="translated">传递给 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; 的所有参数都传递给 &lt;code&gt;Your::Module-&amp;gt;builder-&amp;gt;plan()&lt;/code&gt; ，但 &lt;code&gt;import =&amp;gt;[qw(things to import)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2e982744f4ac0300218d6f294863226187db18a" translate="yes" xml:space="preserve">
          <source>All arguments passed to the &lt;b&gt;new()&lt;/b&gt; constructor will be treated as key/value pairs in a hash-table. The newly constructed object will be initialized by copying the contents of the given hash-table (which may have been empty). The &lt;b&gt;new()&lt;/b&gt; constructor for this class and all of its subclasses returns a blessed reference to the initialized object (hash-table).</source>
          <target state="translated">传递给&lt;b&gt;new（）&lt;/b&gt;构造函数的所有参数都将被视为哈希表中的键/值对。通过复制给定哈希表的内容（可能为空）来初始化新构造的对象。此类及其所有子类的&lt;b&gt;new（）&lt;/b&gt;构造函数返回对初始化对象（哈希表）的祝福引用。</target>
        </trans-unit>
        <trans-unit id="ec83cba8a792f2692f5daa6167d2d16a27e37ea4" translate="yes" xml:space="preserve">
          <source>All arguments to bootstrap() are passed to the module's bootstrap function. The default code generated by</source>
          <target state="translated">bootstrap()的所有参数都会传递给模块的bootstrap函数。默认的代码是由</target>
        </trans-unit>
        <trans-unit id="0641330064a33946ad2abf69443076e60a765bfc" translate="yes" xml:space="preserve">
          <source>All bytes in a multi-byte UTF-8 character will have the high bit set, so you can test if you need to do something special with this character like this (the &lt;code&gt;UTF8_IS_INVARIANT()&lt;/code&gt; is a macro that tests whether the byte is encoded as a single byte even in UTF-8):</source>
          <target state="translated">多字节UTF-8字符中的所有字节都将设置高位，因此您可以测试是否需要对此字符进行特殊处理（ &lt;code&gt;UTF8_IS_INVARIANT()&lt;/code&gt; 是一个宏，用于测试该字节是否编码为即使在UTF-8中也只有一个字节）：</target>
        </trans-unit>
        <trans-unit id="3518d33b42f2dc03b1a9ce5a7bf1630a8c432554" translate="yes" xml:space="preserve">
          <source>All classes automatically inherit from the &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class, which is built-in to the Perl core. This class provides a number of methods, all of which can be called on either a class or an object. You can also choose to override some of these methods in your class. If you do so, we recommend that you follow the built-in semantics described below.</source>
          <target state="translated">所有类都自动从Perl核心内置的&lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt;类继承。此类提供了许多方法，可以在类或对象上调用所有方法。您也可以选择在类中重写其中的某些方法。如果这样做，我们建议您遵循下面描述的内置语义。</target>
        </trans-unit>
        <trans-unit id="01913ce43f34cc16d63eaaa24a00e403aac3c548" translate="yes" xml:space="preserve">
          <source>All classes inherit from the &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class implicitly. The &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class is implemented by the Perl core, and provides several default methods, such as &lt;code&gt;isa()&lt;/code&gt; , &lt;code&gt;can()&lt;/code&gt; , and &lt;code&gt;VERSION()&lt;/code&gt; . The &lt;code&gt;UNIVERSAL&lt;/code&gt; class will</source>
          <target state="translated">所有类都隐式继承自&lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt;类。将&lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt;类由Perl的芯实现，并提供了几个默认方法，如 &lt;code&gt;isa()&lt;/code&gt; ， &lt;code&gt;can()&lt;/code&gt; ，和 &lt;code&gt;VERSION()&lt;/code&gt; 。该 &lt;code&gt;UNIVERSAL&lt;/code&gt; 类意志</target>
        </trans-unit>
        <trans-unit id="d7ed55b8e4e0eb9f903d01566d45c62ffc547221" translate="yes" xml:space="preserve">
          <source>All code points that would be matched by this are matched by either &quot;Script_Extensions=Katakana&quot; or &quot;Script_Extensions=Hiragana&quot;</source>
          <target state="translated">所有与此相匹配的代码点都会被 &quot;Script_Extensions=片假名 &quot;或 &quot;Script_Extensions=平假名 &quot;所匹配。</target>
        </trans-unit>
        <trans-unit id="68b93a9f8c08d5ea78bcf3b0d94efaeadf4ebfe0" translate="yes" xml:space="preserve">
          <source>All command paragraphs (which are typically only one line long) start with &quot;=&quot;, followed by an identifier, followed by arbitrary text that the command can use however it pleases. Currently recognized commands are</source>
          <target state="translated">所有的命令段落(通常只有一行长)都以&quot;=&quot;开头,后面是一个标识符,然后是命令可以随意使用的任意文本。目前识别的命令有</target>
        </trans-unit>
        <trans-unit id="982b67a682c875ad11cfce0a29c201661fc04837" translate="yes" xml:space="preserve">
          <source>All data in Perl is a scalar, an array of scalars, or a hash of scalars. A scalar may contain one single value in any of three different flavors: a number, a string, or a reference. In general, conversion from one form to another is transparent. Although a scalar may not directly hold multiple values, it may contain a reference to an array or hash which in turn contains multiple values.</source>
          <target state="translated">在Perl中,所有的数据都是一个标量,一个标量数组,或者一个标量的哈希。一个标量可以包含一个单一的值,有三种不同的形式:一个数字、一个字符串或一个引用。一般来说,从一种形式转换到另一种形式是透明的。虽然一个标量不可能直接持有多个值,但它可能包含对一个数组或哈希的引用,而这个数组或哈希又包含多个值。</target>
        </trans-unit>
        <trans-unit id="69c2eb01381ceb109c37169bc1329fc48f7a2dca" translate="yes" xml:space="preserve">
          <source>All decryption filters work on the principle of &quot;security through obscurity.&quot; Regardless of how well you write a decryption filter and how strong your encryption algorithm is, anyone determined enough can retrieve the original source code. The reason is quite simple - once the decryption filter has decrypted the source back to its original form, fragments of it will be stored in the computer's memory as Perl parses it. The source might only be in memory for a short period of time, but anyone possessing a debugger, skill, and lots of patience can eventually reconstruct your program.</source>
          <target state="translated">所有解密过滤器的工作原理都是 &quot;通过隐蔽性保证安全&quot;。无论你的解密过滤器写得多好,你的加密算法有多强,任何有足够决心的人都可以检索到原始源代码。原因很简单--一旦解密过滤器将源码解密回原形,当Perl解析源码时,源码的碎片将存储在计算机的内存中。源码可能只在内存中停留很短的时间,但任何拥有调试器、技术和大量耐心的人最终都可以重建你的程序。</target>
        </trans-unit>
        <trans-unit id="ba741a80f2a14355d94b77c4ceb115a27afc7f18" translate="yes" xml:space="preserve">
          <source>All defaults for Configure can be used.</source>
          <target state="translated">可以使用配置的所有默认值。</target>
        </trans-unit>
        <trans-unit id="acfa01600fe34368d13dbcac106b2c8f27f49465" translate="yes" xml:space="preserve">
          <source>All development releases of perl since 5.9.0 are covered.</source>
          <target state="translated">涵盖了5.9.0以来所有的perl开发版本。</target>
        </trans-unit>
        <trans-unit id="df049cfa442a524a56259811400e36eee4811c18" translate="yes" xml:space="preserve">
          <source>All diagnostic output is sent to &lt;code&gt;STDERR&lt;/code&gt; .</source>
          <target state="translated">所有诊断输出都将发送到 &lt;code&gt;STDERR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93306c0ef9fe5f266a659b8a075c1bae7f08ce4e" translate="yes" xml:space="preserve">
          <source>All dollar signs must be doubled in the $perl_code if you expect them to be interpreted normally, otherwise it will be considered a make macro. Also remember to quote make macros else it might be used as a bareword. For example:</source>
          <target state="translated">如果你希望$perl_code能被正常解释,那么所有的美元符号必须加倍,否则将被视为make宏。另外,记得要给make宏加引号,否则可能会被当作裸词使用。例如</target>
        </trans-unit>
        <trans-unit id="7a1f8634b122edec02ff5f85c8a73c5f24ae4096" translate="yes" xml:space="preserve">
          <source>All environment vars must be stored in HKLM\Environment as strings. They are read at process startup.</source>
          <target state="translated">所有的环境变量必须以字符串的形式存储在HKLM\Environment中。它们在进程启动时被读取。</target>
        </trans-unit>
        <trans-unit id="92b87396d02d1c058e99dc606debd7ebb31b0abf" translate="yes" xml:space="preserve">
          <source>All error reporting is done with exceptions (die'ing).</source>
          <target state="translated">所有的错误报告都是在例外情况下完成的(die'ing)。</target>
        </trans-unit>
        <trans-unit id="7a3f297670f9579dd31a61d74a21533ee88a594f" translate="yes" xml:space="preserve">
          <source>All features that combine Unicode and I/O also require using the new PerlIO feature. Almost all Perl 5.8 platforms do use PerlIO, though: you can see whether yours is by running &quot;perl -V&quot; and looking for &lt;code&gt;useperlio=define&lt;/code&gt; .</source>
          <target state="translated">结合了Unicode和I / O的所有功能也都需要使用新的PerlIO功能。不过，几乎所有的Perl 5.8平台都使用PerlIO：通过运行&amp;ldquo; perl -V&amp;rdquo;并查找 &lt;code&gt;useperlio=define&lt;/code&gt; 可以查看您是否正在使用PerlIO。</target>
        </trans-unit>
        <trans-unit id="ad80d55320f9dffac4aa0255715379a201879293" translate="yes" xml:space="preserve">
          <source>All file tests (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; ) except for &lt;code&gt;-t&lt;/code&gt; , which defaults to STDIN. See &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;</source>
          <target state="translated">除 &lt;code&gt;-t&lt;/code&gt; 以外的所有文件测试（ &lt;code&gt;-f&lt;/code&gt; ， &lt;code&gt;-d&lt;/code&gt; ），默认为STDIN。参见&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="815b16d15ecd8197f8c89531e6b38bdaa59c037d" translate="yes" xml:space="preserve">
          <source>All files are stored internally as &lt;code&gt;Archive::Tar::File&lt;/code&gt; objects. Please consult the &lt;a href=&quot;tar/file&quot;&gt;Archive::Tar::File&lt;/a&gt; documentation for details.</source>
          <target state="translated">所有文件都在内部存储为 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 对象。有关详细信息，请查阅&lt;a href=&quot;tar/file&quot;&gt;Archive :: Tar :: File&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="f073482fc073c0918a2379dd16dc7865e1091f64" translate="yes" xml:space="preserve">
          <source>All files that match any regular expression in a file</source>
          <target state="translated">匹配文件中任何正则表达式的所有文件</target>
        </trans-unit>
        <trans-unit id="cfa975a72f5514a96c923193276bf554b250a3e3" translate="yes" xml:space="preserve">
          <source>All files used by the program or function, normally presented as a list, and what it uses them for. File names should be enclosed in F&amp;lt;&amp;gt;. It's particularly important to document files that will be potentially modified.</source>
          <target state="translated">程序或功能使用的所有文件（通常以列表形式显示）及其用途。文件名应放在F &amp;lt;&amp;gt;中。记录可能要修改的文件尤为重要。</target>
        </trans-unit>
        <trans-unit id="a2dd9a73e29796f6b2de6625428d9204a9270fdb" translate="yes" xml:space="preserve">
          <source>All filter methods return the existing filter, if present, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if not.</source>
          <target state="translated">所有过滤器方法都将返回现有过滤器（如果存在），否则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4139db9439a578bf12cb959a5143dbafa321c592" translate="yes" xml:space="preserve">
          <source>All filter methods return the existing filter, if present, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in not.</source>
          <target state="translated">所有过滤器方法都将返回现有过滤器（如果存在），否则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="311ff967643c4d237a819b285dc4b5880471f22d" translate="yes" xml:space="preserve">
          <source>All forms of the pragma enable use of the following 3 functions:</source>
          <target state="translated">所有形式的pragma都可以使用以下3个功能。</target>
        </trans-unit>
        <trans-unit id="74749eec650dc1a9457b607830f24533a5ba9c1c" translate="yes" xml:space="preserve">
          <source>All four routines return the number of arguments that the subroutine returned on the Perl stack.</source>
          <target state="translated">所有四个例程都返回子例程在Perl堆栈中返回的参数数。</target>
        </trans-unit>
        <trans-unit id="5e2132ad2da2d7aa2f6043aad2cc1232db0e47df" translate="yes" xml:space="preserve">
          <source>All functions have the following rules to decide what it thinks you want:</source>
          <target state="translated">所有的功能都有以下规则来决定它认为你想要什么。</target>
        </trans-unit>
        <trans-unit id="7a4768442025565f5f815b90b4d35c19d4f3c9c1" translate="yes" xml:space="preserve">
          <source>All functions return 1 on success, 0 on failure. $! will be set if an error was encountered.</source>
          <target state="translated">所有函数成功时返回1,失败时返回0。如果遇到错误,将设置$!</target>
        </trans-unit>
        <trans-unit id="6ff8d7d6682320cce258b48a2cf6142f6da6f3bb" translate="yes" xml:space="preserve">
          <source>All functions that are capable of creating filehandles (open(), opendir(), pipe(), socketpair(), sysopen(), socket(), and accept()) automatically create an anonymous filehandle if the handle passed to them is an uninitialized scalar variable. This allows the constructs such as &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh, ...)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $fh,...)&lt;/code&gt; to be used to create filehandles that will conveniently be closed automatically when the scope ends, provided there are no other references to them. This largely eliminates the need for typeglobs when opening filehandles that must be passed around, as in the following example:</source>
          <target state="translated">如果传递给它们的句柄是，所有能够创建文件句柄的函数（open（），opendir（），pipe（），socketpair（），sysopen（），socket（）和accept（））都会自动创建一个匿名文件句柄。未初始化的标量变量。这允许使用诸如 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh, ...)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $fh,...)&lt;/code&gt; 来创建文件句柄，只要没有其他引用，该文件句柄将在范围结束时方便地自动关闭给他们。这在打开必须传递的文件句柄时，很大程度上消除了对typeglob的需求，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="8c0ff391fcad9c66a86b68973a78df205636b6ef" translate="yes" xml:space="preserve">
          <source>All information required to &quot;attach&quot; back to the shared resource object &lt;b&gt;must&lt;/b&gt; be contained &lt;b&gt;only&lt;/b&gt; in the &lt;code&gt;STORABLE_freeze&lt;/code&gt; return string. Otherwise, &lt;code&gt;STORABLE_freeze&lt;/code&gt; behaves as normal for &lt;code&gt;STORABLE_attach&lt;/code&gt; classes.</source>
          <target state="translated">需要&amp;ldquo;附加&amp;rdquo;回共享资源对象的所有信息&lt;b&gt;必须&lt;/b&gt;包含&lt;b&gt;仅&lt;/b&gt;在 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 返回字符串。否则，对于 &lt;code&gt;STORABLE_attach&lt;/code&gt; 类， &lt;code&gt;STORABLE_freeze&lt;/code&gt; 的行为正常。</target>
        </trans-unit>
        <trans-unit id="0ca38b7907bcdd63b3829617b4fa2da1157cda75" translate="yes" xml:space="preserve">
          <source>All inputs to WriteMakefile are Unicode characters, not just octets. EUMM seeks to handle all of these correctly. It is currently still not possible to portably use Unicode characters in module names, because this requires Perl to handle Unicode filenames, which is not yet the case on Windows.</source>
          <target state="translated">WriteMakefile的所有输入都是Unicode字符,而不仅仅是八位数。EUMM力求正确地处理所有这些字符。目前还不能在模块名中使用Unicode字符,因为这需要Perl来处理Unicode文件名,而在Windows上还不是这样。</target>
        </trans-unit>
        <trans-unit id="d69ebadb686cb973f8c2cd133297ec1e0e33a51b" translate="yes" xml:space="preserve">
          <source>All invokes of</source>
          <target state="translated">的所有调用</target>
        </trans-unit>
        <trans-unit id="4ffd0a2ad25e2bbb80e9fa8d007272b04eac86d9" translate="yes" xml:space="preserve">
          <source>All list elements are numeric and come straight out of the C `struct tm'. &lt;code&gt;$sec&lt;/code&gt; , &lt;code&gt;$min&lt;/code&gt; , and &lt;code&gt;$hour&lt;/code&gt; are the seconds, minutes, and hours of the specified time.</source>
          <target state="translated">所有列表元素都是数字，并且直接来自C`struct tm'。 &lt;code&gt;$sec&lt;/code&gt; ， &lt;code&gt;$min&lt;/code&gt; 和 &lt;code&gt;$hour&lt;/code&gt; 是指定时间的秒，分钟和小时。</target>
        </trans-unit>
        <trans-unit id="b0cbbd027f9d74998550632f8f717d3b9830f840" translate="yes" xml:space="preserve">
          <source>All memory meant to be used with the Perl API functions should be manipulated using the macros described in this section. The macros provide the necessary transparency between differences in the actual malloc implementation that is used within perl.</source>
          <target state="translated">所有用于Perl API函数的内存都应该使用本节中描述的宏来操作。这些宏在perl内部使用的实际malloc实现的差异之间提供了必要的透明度。</target>
        </trans-unit>
        <trans-unit id="9a9e166f6a8a9986486a965b0218230a1bd88001" translate="yes" xml:space="preserve">
          <source>All methods provided are accessible in a programmer style and in an interactive shell style.</source>
          <target state="translated">所有提供的方法都可以以程序员风格和交互式shell风格访问。</target>
        </trans-unit>
        <trans-unit id="1459ac0067a9be1ca453815893a04263c9ab6fda" translate="yes" xml:space="preserve">
          <source>All modules should be tested before distribution (using &quot;make disttest&quot;), and the tests should also be available to people installing the modules (using &quot;make test&quot;). For Module::Build you would use the &lt;code&gt;make test&lt;/code&gt; equivalent &lt;code&gt;perl Build test&lt;/code&gt; .</source>
          <target state="translated">所有模块都应在分发之前进行测试（使用&amp;ldquo; make disttest&amp;rdquo;），并且安装模块的人员也应该可以使用该测试（使用&amp;ldquo; make test&amp;rdquo;）。对于Module :: Build，您将使用 &lt;code&gt;make test&lt;/code&gt; 等效于 &lt;code&gt;perl Build test&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45a75ffb3c37d77e5c140116de26483a43d3e7a6" translate="yes" xml:space="preserve">
          <source>All objects belong to a specific class. For example, our</source>
          <target state="translated">所有对象都属于一个特定的类。例如,我们的</target>
        </trans-unit>
        <trans-unit id="758a43e77b8dfcfe840782d07ab7ccfb64e67a82" translate="yes" xml:space="preserve">
          <source>All of Perl's internal functions which will be exposed to the outside world are prefixed by &lt;code&gt;Perl_&lt;/code&gt; so that they will not conflict with XS functions or functions used in a program in which Perl is embedded. Similarly, all global variables begin with &lt;code&gt;PL_&lt;/code&gt; . (By convention, static functions start with &lt;code&gt;S_&lt;/code&gt; .)</source>
          <target state="translated">暴露给外界的所有Perl内部函数都以 &lt;code&gt;Perl_&lt;/code&gt; 作为前缀，因此它们不会与XS函数或嵌入Perl的程序中使用的函数冲突。同样，所有全局变量 &lt;code&gt;PL_&lt;/code&gt; 。（按照惯例，静态函数以 &lt;code&gt;S_&lt;/code&gt; 开头。）</target>
        </trans-unit>
        <trans-unit id="f0201779d13335d0611380b1efaab78cf7d99ae8" translate="yes" xml:space="preserve">
          <source>All of Perl's source code is kept centrally in a Git repository at</source>
          <target state="translated">所有Perl的源代码都集中保存在Git仓库中,位于</target>
        </trans-unit>
        <trans-unit id="f5c3cc30932079fdea98918bb1694882d908dc3a" translate="yes" xml:space="preserve">
          <source>All of the above special cases can occasionally cause some problems. See &lt;a href=&quot;#BUGS-and-CAVEATS&quot;&gt;BUGS and CAVEATS&lt;/a&gt;.</source>
          <target state="translated">以上所有特殊情况有时都会引起一些问题。请参阅错误&lt;a href=&quot;#BUGS-and-CAVEATS&quot;&gt;和注意事项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e73d4a25ee89208a71c06aba4a44554f2676c3f" translate="yes" xml:space="preserve">
          <source>All of the core documentation intended for end users lives in</source>
          <target state="translated">所有面向终端用户的核心文档都保存在以下地方</target>
        </trans-unit>
        <trans-unit id="8bb2fabac85e17c62678907ad7293e4a29bfd44a" translate="yes" xml:space="preserve">
          <source>All of the following SvREFCNT_inc* macros are optimized versions of SvREFCNT_inc, and can be replaced with SvREFCNT_inc.</source>
          <target state="translated">以下所有的 SvREFCNT_inc*宏都是 SvREFCNT_inc 的优化版本,可以用 SvREFCNT_inc 替代。</target>
        </trans-unit>
        <trans-unit id="82ef093e61dfa9c43730994ceca5ef32106472a3" translate="yes" xml:space="preserve">
          <source>All of the following have helped. Bug reports, patches, (im)moral support, or just words of encouragement have all been forthcoming.</source>
          <target state="translated">以下所有的人都提供了帮助。错误报告、补丁、(精神)支持或仅仅是鼓励的话语,都是很乐意提供的。</target>
        </trans-unit>
        <trans-unit id="7491564d89215b867c8e0fd7859217a07aea983b" translate="yes" xml:space="preserve">
          <source>All of the following print &quot;ok&quot; or &quot;not ok&quot; depending on if the test succeeded or failed. They all also return true or false, respectively.</source>
          <target state="translated">以下所有的测试都会根据测试的成功或失败打印 &quot;ok &quot;或 &quot;not ok&quot;。它们也都分别返回 &quot;true &quot;或 &quot;false&quot;。</target>
        </trans-unit>
        <trans-unit id="41e3b701113b5066b37e3af11d04cea9cb6499ec" translate="yes" xml:space="preserve">
          <source>All of these functions will croak on read-only scalars (see the previous section for more on those).</source>
          <target state="translated">所有这些函数都会在只读标量上呱呱坠地(详见上一节)。</target>
        </trans-unit>
        <trans-unit id="4ff83273a3484775dac4d0e13bc9dfb2d37a34a0" translate="yes" xml:space="preserve">
          <source>All of these interact with or use &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; which is worth understanding the basics of when building a website in Perl (there is a lot of useful &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%253A%253Amiddleware&quot;&gt;Plack::Middleware&lt;/a&gt;).</source>
          <target state="translated">所有这些都与&lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt;交互或使用Plack，这值得在Perl中构建网站的基础知识（有很多有用的&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%253A%253Amiddleware&quot;&gt;Plack :: Middleware&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="669764792c2fd17c1b68c9548896f6adc424fb5e" translate="yes" xml:space="preserve">
          <source>All of this is especially useful when perl is embedded in some other program, where output to STDOUT and STDERR may have to be redirected in some special way. See nvi and the Apache module for examples.</source>
          <target state="translated">当perl被嵌入到其他程序中时,所有这些功能都特别有用,因为在这些程序中,输出到STDOUT和STDERR的数据可能需要以某种特殊的方式重定向。参见nvi和Apache模块的例子。</target>
        </trans-unit>
        <trans-unit id="f9469b3540381c36cb61f1bd013bbc92d5d1e0fa" translate="yes" xml:space="preserve">
          <source>All of this occurs in the routine &lt;code&gt;study_chunk()&lt;/code&gt; which uses a special structure &lt;code&gt;scan_data_t&lt;/code&gt; to store the analysis that it has performed, and does the &quot;peep-hole&quot; optimisations as it goes.</source>
          <target state="translated">所有这些都发生在例程 &lt;code&gt;study_chunk()&lt;/code&gt; 中，该例程使用特殊的结构 &lt;code&gt;scan_data_t&lt;/code&gt; 存储已执行的分析，并随其进行&amp;ldquo;窥孔&amp;rdquo;优化。</target>
        </trans-unit>
        <trans-unit id="52f1e1f474a63fabc7410cc13bd34f20b84caea7" translate="yes" xml:space="preserve">
          <source>All of those strange functions with</source>
          <target state="translated">所有这些奇怪的功能与</target>
        </trans-unit>
        <trans-unit id="bd329654decca432a697c3105f88903a2261a243" translate="yes" xml:space="preserve">
          <source>All open handles are dup()-ed in pseudo-processes, so that closing any handles in one process does not affect the others. See below for some limitations.</source>
          <target state="translated">在伪进程中,所有打开的句柄都是dup()-ed的,因此关闭一个进程中的任何句柄都不会影响其他进程。请看下面的一些限制。</target>
        </trans-unit>
        <trans-unit id="f714b09d9b62651db015cac63428a3e648501bda" translate="yes" xml:space="preserve">
          <source>All operations above are performed simultaneously, left to right.</source>
          <target state="translated">以上所有操作同时进行,从左到右。</target>
        </trans-unit>
        <trans-unit id="2c5dee63173bc6728f471c2ffbe6ede7b9622657" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) are overloaded if you declare your big floating point numbers as</source>
          <target state="translated">如果你将你的大浮点数声明为</target>
        </trans-unit>
        <trans-unit id="47240c2bd1c42148438e132fbe97c4470bd81a8b" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) are overloaded if you declare your big integers as</source>
          <target state="translated">如果你把你的大整数声明为</target>
        </trans-unit>
        <trans-unit id="8aea450e6db040db0c87b5e94c4f04af81589adb" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) are overloaded. Integer and floating-point constants are created as proper BigInts or BigFloats, respectively.</source>
          <target state="translated">所有的运算符(包括基本的数学运算)都被重载。整数和浮点常量分别被创建为合适的BigInts或BigFloats。</target>
        </trans-unit>
        <trans-unit id="97e8744f2aba4f4c5299d3315f0e922fa7662452" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) except the range operator &lt;code&gt;..&lt;/code&gt; are overloaded. Integer constants are created as proper BigInts.</source>
          <target state="translated">除范围运算符 &lt;code&gt;..&lt;/code&gt; 外的所有运算符（包括基本数学运算）都已重载。整数常量被创建为适当的BigInts。</target>
        </trans-unit>
        <trans-unit id="d94d5908e53102da28ed793d2b7b1e3aac035e25" translate="yes" xml:space="preserve">
          <source>All options are passed either via the &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, or via an explicit &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所有选项都可以通过 &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句或显式 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 传递。</target>
        </trans-unit>
        <trans-unit id="6af1c2304a59b49a5e4c4bb3624f5d7d2569e662" translate="yes" xml:space="preserve">
          <source>All other arguments are optional and should correspond to filehandles to read from or the names of input files containing POD sections. A file name of &quot;&quot;, &quot;-&quot; or &quot;&amp;lt;&amp;amp;STDIN&quot; will be interpreted to mean standard input (which is the default if no arguments are given).</source>
          <target state="translated">所有其他参数是可选的，并且应对应于要读取的文件句柄或包含POD节的输入文件的名称。文件名&amp;ldquo;&amp;rdquo;，&amp;ldquo;-&amp;rdquo;或&amp;ldquo; &amp;lt;＆STDIN&amp;rdquo;将被解释为标准输入（如果未提供任何参数，则为默认输入）。</target>
        </trans-unit>
        <trans-unit id="7f44679a6de4260413fa97b63aefa6bbb62b1b1f" translate="yes" xml:space="preserve">
          <source>All other code points corresponding to Unicode characters, including private use and those yet to be assigned, are never considered malformed and never warn.</source>
          <target state="translated">其他所有与Unicode字符相对应的码点,包括私人使用和尚未分配的码点,都不会被认为是畸形的,也不会发出警告。</target>
        </trans-unit>
        <trans-unit id="9abb59ed9447dcd04c7f87e709793152669bc13e" translate="yes" xml:space="preserve">
          <source>All other errors may be trapped using the modern interface, otherwise they will be &lt;code&gt;carp&lt;/code&gt; ed about. Program execution will not be halted.</source>
          <target state="translated">所有其他错误可以使用现代的界面被捕获，否则会 &lt;code&gt;carp&lt;/code&gt; 约版。程序执行不会停止。</target>
        </trans-unit>
        <trans-unit id="87f6ed6f32251cf3d91bc227de27a29b35179c3f" translate="yes" xml:space="preserve">
          <source>All other implemented styles of rounding attempt to round to the &quot;nearest digit.&quot; If the digit D immediately to the right of the rounding place (skipping the decimal point) is greater than 5, the number is incremented at the rounding place (possibly causing a cascade of incrementation): e.g. when rounding to units, 0.9 rounds to 1, and -19.9 rounds to -20. If D &amp;lt; 5, the number is similarly truncated at the rounding place: e.g. when rounding to units, 0.4 rounds to 0, and -19.4 rounds to -19.</source>
          <target state="translated">所有其他实现的舍入样式都尝试舍入到&amp;ldquo;最接近的数字&amp;rdquo;。如果紧靠舍入位置（跳过小数点）右边的数字D大于5，则数字在舍入位置递增（可能导致级联递增）：例如，当舍入为单位时，将0.9舍入为1 ，并将-19.9舍入为-20。如果D &amp;lt;5，则数字在舍入位置类似地被截断：例如，舍入为单位时，将0.4舍入为0，将-19.4舍入为-19。</target>
        </trans-unit>
        <trans-unit id="0673283fae5e4cb931ef195f174d0d6b1d1f68b5" translate="yes" xml:space="preserve">
          <source>All other methods upgrade themselves only when one (or all) of their arguments are of the class mentioned in $upgrade (This might change in later versions to a more sophisticated scheme):</source>
          <target state="translated">所有其他方法只有当它们的一个(或所有)参数是$upgrade中提到的类时才会升级(这在以后的版本中可能会改变为一个更复杂的方案)。</target>
        </trans-unit>
        <trans-unit id="5e2040cfcc351c3e2d5a5185b8c874a98a40126c" translate="yes" xml:space="preserve">
          <source>All other object methods and overloaded functions can be directly inherited from the parent class.</source>
          <target state="translated">其他所有的对象方法和重载函数都可以直接从父类继承。</target>
        </trans-unit>
        <trans-unit id="b83a0c68243d6a9c451b88def8620109da8b38fe" translate="yes" xml:space="preserve">
          <source>All other parameters that control the content of the gzip header will be ignored if this parameter is set to 1.</source>
          <target state="translated">如果这个参数被设置为1,其他所有控制gzip头内容的参数都将被忽略。</target>
        </trans-unit>
        <trans-unit id="6c37ee1b0941f972f146000c72b7c3b6715243db" translate="yes" xml:space="preserve">
          <source>All possible messages the program can print out and what they mean. You may wish to follow the same documentation style as the Perl documentation; see perldiag(1) for more details (and look at the POD source as well).</source>
          <target state="translated">程序可以打印出的所有可能的消息以及它们的含义。您可能希望遵循与 Perl 文档相同的文档风格;更多细节请参见 perldiag(1)(也可以查看 POD 源代码)。</target>
        </trans-unit>
        <trans-unit id="604e2a22c32db1e7a6f30a5a33e18c36a9822954" translate="yes" xml:space="preserve">
          <source>All printable characters, which is the set of all graphical characters plus those whitespace characters which are not also controls.</source>
          <target state="translated">所有可打印字符,即所有图形字符加上那些不属于控件的空白字符的集合。</target>
        </trans-unit>
        <trans-unit id="5f0cb252127c0b51324ce6af0cb1b37825719005" translate="yes" xml:space="preserve">
          <source>All questions related to building for WinCE devices could be asked in</source>
          <target state="translated">所有与WinCE设备构建相关的问题都可以在这里提出。</target>
        </trans-unit>
        <trans-unit id="af228b0481468b2f1d341e2655d2bfbf46fb813b" translate="yes" xml:space="preserve">
          <source>All references to line numbers by the program (warnings, errors, ...) will treat the &lt;code&gt;#!&lt;/code&gt; line as the first line. Thus a warning on the 2nd line of the program, which is on the 100th line in the file will be reported as line 2, not as line 100. This can be overridden by using the &lt;code&gt;#line&lt;/code&gt; directive. (See &lt;a href=&quot;perlsyn#Plain-Old-Comments-(Not!)&quot;&gt;Plain Old Comments (Not!) in perlsyn&lt;/a&gt;)</source>
          <target state="translated">程序对行号的所有引用（警告，错误等）将视为 &lt;code&gt;#!&lt;/code&gt; 行作为第一行。因此，程序第二行（文件中的第100行）的警告将报告为第2行，而不是第100行。可以使用 &lt;code&gt;#line&lt;/code&gt; 伪指令覆盖该警告。（请参阅&lt;a href=&quot;perlsyn#Plain-Old-Comments-(Not!)&quot;&gt;perlsyn中的&amp;ldquo;普通旧注释（不！）&amp;rdquo;&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="e60ba7561109a1c032c7ac0364a6dfa0ffa088bc" translate="yes" xml:space="preserve">
          <source>All results share some common attributes:</source>
          <target state="translated">所有的结果都有一些共同的属性。</target>
        </trans-unit>
        <trans-unit id="1a067ae12ba3c0d999a29e551f40bb7142e1e1b0" translate="yes" xml:space="preserve">
          <source>All rounding functions take as a second parameter a rounding mode from one of the following: 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'.</source>
          <target state="translated">所有的四舍五入函数的第二个参数都是以下几种四舍五入模式。&quot;偶数&quot;,&quot;奇数&quot;,&quot;+inf&quot;,&quot;-inf&quot;,&quot;零&quot;,&quot;截数 &quot;或 &quot;普通&quot;。</target>
        </trans-unit>
        <trans-unit id="2b331c6fdc80ccf345de0513f8a62b9eab6492a7" translate="yes" xml:space="preserve">
          <source>All routines expect to be given real or complex numbers. Don't attempt to use BigFloat, since Perl has currently no rule to disambiguate a '+' operation (for instance) between two overloaded entities.</source>
          <target state="translated">所有的例程都希望被赋予实数或复数。不要试图使用BigFloat,因为Perl目前还没有规则来区分两个重载实体之间的'+'操作(例如)。</target>
        </trans-unit>
        <trans-unit id="e55cf27d1ee5fe9a7d51e12a991cd2052b26c3ef" translate="yes" xml:space="preserve">
          <source>All single forms are Perl extensions; a few compound forms are as well, and are noted as such.</source>
          <target state="translated">所有的单一形式都是Perl的扩展;一些复合形式也是,并在此注明。</target>
        </trans-unit>
        <trans-unit id="47270bc8154b38c6bf8c6928d77cd1d441578544" translate="yes" xml:space="preserve">
          <source>All stable releases of perl since 5.6.0 are covered.</source>
          <target state="translated">涵盖了自5.6.0以来所有稳定版本的perl。</target>
        </trans-unit>
        <trans-unit id="eab81422eaa753ceb04583bd0ca24dcc4c83f889" translate="yes" xml:space="preserve">
          <source>All subpatterns, either delivered as a list-context result or as &lt;code&gt;$1&lt;/code&gt;</source>
          <target state="translated">所有子模式，以列表上下文结果或 &lt;code&gt;$1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48589ddd875d011fdf990744a29e7ccd3465ffa6" translate="yes" xml:space="preserve">
          <source>All subsequent characters can be letters, numbers (0-9), hyphens (-), underscores (_), colons (:), and periods (.).</source>
          <target state="translated">后面的字符可以是字母、数字(0-9)、连字符(-)、下划线(_)、冒号(:)和句号(.)。</target>
        </trans-unit>
        <trans-unit id="42ba1038004475ab41cd7a5ef01656aad2449ad3" translate="yes" xml:space="preserve">
          <source>All systems use the virtual &lt;code&gt;&quot;\n&quot;&lt;/code&gt; to represent a line terminator, called a &quot;newline&quot;. There is no such thing as an unvarying, physical newline character. It is only an illusion that the operating system, device drivers, C libraries, and Perl all conspire to preserve. Not all systems read &lt;code&gt;&quot;\r&quot;&lt;/code&gt; as ASCII CR and &lt;code&gt;&quot;\n&quot;&lt;/code&gt; as ASCII LF. For example, on the ancient Macs (pre-MacOS X) of yesteryear, these used to be reversed, and on systems without a line terminator, printing &lt;code&gt;&quot;\n&quot;&lt;/code&gt; might emit no actual data. In general, use &lt;code&gt;&quot;\n&quot;&lt;/code&gt; when you mean a &quot;newline&quot; for your system, but use the literal ASCII when you need an exact character. For example, most networking protocols expect and prefer a CR+LF (&lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; or &lt;code&gt;&quot;\cM\cJ&quot;&lt;/code&gt; ) for line terminators, and although they often accept just &lt;code&gt;&quot;\012&quot;&lt;/code&gt; , they seldom tolerate just &lt;code&gt;&quot;\015&quot;&lt;/code&gt; . If you get in the habit of using &lt;code&gt;&quot;\n&quot;&lt;/code&gt; for networking, you may be burned some day.</source>
          <target state="translated">所有系统都使用虚拟 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 表示行终止符，称为&amp;ldquo;换行符&amp;rdquo;。不存在不变的物理换行符。操作系统，设备驱动程序，C库和Perl都可以共同保留只是一种幻想。并非所有系统都将 &lt;code&gt;&quot;\r&quot;&lt;/code&gt; 读取为ASCII CR，将 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 读取为ASCII LF。例如，在过去的古老Mac（MacOS X之前的版本）上，这些曾经被反转，而在没有行终止符的系统上，打印 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 可能不会输出任何实际数据。通常，当您对系统表示&amp;ldquo;换行 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 时，请使用&amp;ldquo; \ n&amp;rdquo;，但在需要精确字符时，请使用文字ASCII。例如，大多数网络协议期望并喜欢CR + LF（ &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;\cM\cJ&quot;&lt;/code&gt; ）作为行终止符，尽管它们通常只接受 &lt;code&gt;&quot;\012&quot;&lt;/code&gt; ，但很少容忍 &lt;code&gt;&quot;\015&quot;&lt;/code&gt; 。如果您习惯于使用 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 进行网络连接，则有一天您可能会被淘汰。</target>
        </trans-unit>
        <trans-unit id="fb8ea7b6eceda9fa2e8d1025a7231d980eabe21a" translate="yes" xml:space="preserve">
          <source>All test functions take a name argument. It's optional, but highly suggested that you use it.</source>
          <target state="translated">所有的测试函数都需要一个名字参数。这是可选的,但强烈建议你使用它。</target>
        </trans-unit>
        <trans-unit id="08563314f6fd252cfab4add5f5d112e141d01e88" translate="yes" xml:space="preserve">
          <source>All tests are run in scalar context. So this:</source>
          <target state="translated">所有的测试都是在标量上下文中运行的。所以这个。</target>
        </trans-unit>
        <trans-unit id="9e1df8eee4a1033ecd0a19707416e97c2ada1eab" translate="yes" xml:space="preserve">
          <source>All tests should succeed (with some of them skipped). If you have the same version of Perl installed, it is crucial that you have &lt;code&gt;.&lt;/code&gt; early in your LIBPATH (or in BEGINLIBPATH), otherwise your tests will most probably test the wrong version of Perl.</source>
          <target state="translated">所有测试都应该成功（其中一些跳过）。如果您安装了相同版本的Perl，那么至关重要 &lt;code&gt;.&lt;/code&gt; 请在您的LIBPATH（或BEGINLIBPATH）的早期进行，否则您的测试很可能会测试错误版本的Perl。</target>
        </trans-unit>
        <trans-unit id="525c6957ea6de35e124ab99764227b6cdf29f16d" translate="yes" xml:space="preserve">
          <source>All tests were conducted on the oldest supported AIX technology level with the latest support package applied. If the tested AIX version is out of support (AIX 4.3.3, 5.1, 5.2) then the last available support level was used.</source>
          <target state="translated">所有测试都是在最新支持的AIX技术级别上进行的,并应用最新的支持包。如果被测试的AIX版本不受支持(AIX 4.3.3、5.1、5.2),则使用最新的支持级别。</target>
        </trans-unit>
        <trans-unit id="39ef06ab79291a214e8f7d5dbacda492f3f9bc96" translate="yes" xml:space="preserve">
          <source>All the</source>
          <target state="translated">所有</target>
        </trans-unit>
        <trans-unit id="6adc75ada238ccb6959bf3be512aa6c8d041cf3e" translate="yes" xml:space="preserve">
          <source>All the DLLs built with the current versions of Perl have ID strings identifying the name of the extension, its version, and the version of Perl required for this DLL. Run &lt;code&gt;bldlevel DLL-name&lt;/code&gt; to find this info.</source>
          <target state="translated">使用当前版本的Perl构建的所有DLL都有ID字符串，用于标识扩展名，扩展名以及此DLL所需的Perl版本。运行 &lt;code&gt;bldlevel DLL-name&lt;/code&gt; 来查找此信息。</target>
        </trans-unit>
        <trans-unit id="bf0f04a776f7c27f1c272831fed2f282bc5d62df" translate="yes" xml:space="preserve">
          <source>All the above &quot;don't&quot;:s may look daunting, and they are, but the key is to degrade gracefully if one cannot reach the particular network service one wants. Croaking or hanging do not look very professional.</source>
          <target state="translated">以上所有的 &quot;不要&quot;:看起来令人生畏,确实如此,但关键是在无法达到自己想要的特定网络服务时,要优雅地降级。呱呱坠地或挂机看起来不是很专业。</target>
        </trans-unit>
        <trans-unit id="4b15325c472386a4b2fcce8cfa22d048d90743b2" translate="yes" xml:space="preserve">
          <source>All the above operations</source>
          <target state="translated">所有上述操作</target>
        </trans-unit>
        <trans-unit id="18c65db4629a7b0de1b15db2854f6c3f0396dc3a" translate="yes" xml:space="preserve">
          <source>All the advice contained in this document has been gleaned from extensive conversations with experienced CPAN authors and users. Every piece of advice given here is the result of previous mistakes. This information is here to help you avoid the same mistakes and the extra work that would inevitably be required to fix them.</source>
          <target state="translated">本文件中包含的所有建议都是通过与有经验的CPAN作者和用户的广泛对话收集而来。这里给出的每一条建议都是以前错误的结果。这些信息是为了帮助你避免犯同样的错误,并避免为修复这些错误而不可避免地进行额外的工作。</target>
        </trans-unit>
        <trans-unit id="035cec5a0531d1b6a2296cd59ca2814d6d18a1bb" translate="yes" xml:space="preserve">
          <source>All the binary operators left associate; &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; is higher precedence than the others, which all have equal precedence. The unary operator right associates, and has highest precedence. Thus this follows the normal Perl precedence rules for logical operators. Use parentheses to override the default precedence and associativity.</source>
          <target state="translated">所有的二元运算符都离开了； &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 的优先级高于其他所有优先级均相同的优先级。一元运算符权限具有最高优先级。因此，这遵循逻辑运算符的常规Perl优先规则。使用括号可以覆盖默认的优先级和关联性。</target>
        </trans-unit>
        <trans-unit id="a6d917ce9244febe094ff576631bcd960c5f5696" translate="yes" xml:space="preserve">
          <source>All the common mathematical functions defined on real numbers that are extended to complex numbers share that same property of working</source>
          <target state="translated">所有定义在实数上的常用数学函数,在扩展到复数时,都具有同样的工作性质。</target>
        </trans-unit>
        <trans-unit id="c39940047cd8d69a382c58b19f467066fdda2d58" translate="yes" xml:space="preserve">
          <source>All the common operations that can be performed on a real number have been defined to work on complex numbers as well, and are merely</source>
          <target state="translated">所有可以在实数上进行的常用运算都被定义为也可以在复数上进行,只是</target>
        </trans-unit>
        <trans-unit id="af40a4a3889be35304f9f526d3725dd711506782" translate="yes" xml:space="preserve">
          <source>All the constants defined in &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt; for use in the flags parameters in the methods defined below are also available. Refer to the Berkeley DB documentation for the precise meaning of the flags values.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen中&lt;/a&gt;定义的所有常量（在下面定义的方法中的flags参数中使用）也可用。有关标志值的确切含义，请参考Berkeley DB文档。</target>
        </trans-unit>
        <trans-unit id="90dde32e9abf15d2dcbf6ab5b218367d1761ce60" translate="yes" xml:space="preserve">
          <source>All the data uses to generate the &lt;code&gt;%Extensions&lt;/code&gt; hash is already present in the &lt;code&gt;Config&lt;/code&gt; module, but not in such a convenient format to quickly reference.</source>
          <target state="translated">&lt;code&gt;Config&lt;/code&gt; 模块中已经存在用于生成 &lt;code&gt;%Extensions&lt;/code&gt; 哈希值的所有数据，但不是以一种方便的格式来快速引用。</target>
        </trans-unit>
        <trans-unit id="0d00162e91300896732fceff8f7c85a986709fae" translate="yes" xml:space="preserve">
          <source>All the examples so far have shown objects based on a blessed hash. However, it's possible to bless any type of data structure or referent, including scalars, globs, and subroutines. You may see this sort of thing when looking at code in the wild.</source>
          <target state="translated">到目前为止,所有的例子都显示了基于祝福哈希的对象,但它可以祝福任何类型的数据结构或引用,包括标量、globs和子程序。然而,我们可以祝福任何类型的数据结构或引用,包括标量、globs和子程序。当你在野外看代码时,你可能会看到这类事情。</target>
        </trans-unit>
        <trans-unit id="f288780205f670aaf71d07523bf6fc9a50b071fd" translate="yes" xml:space="preserve">
          <source>All the exportable functions are listed below -- you're free to import only some, or none at all. By default, none are imported. If you say:</source>
          <target state="translated">下面列出了所有可导出的函数--你可以自由地只导入一些,或者完全不导入。默认情况下,没有导入任何函数。如果你说:</target>
        </trans-unit>
        <trans-unit id="dc02c5d731db84c233601bd3b09aab07385ecc22" translate="yes" xml:space="preserve">
          <source>All the functions defined in &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt; are available except for close() and dbopen() itself. The &lt;b&gt;DB_File&lt;/b&gt; method interface to the supported functions have been implemented to mirror the way Berkeley DB works whenever possible. In particular note that:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt;中定义的所有功能均可用，但close（）和dbopen（）本身除外。已实现与受支持函数的&lt;b&gt;DB_File&lt;/b&gt;方法接口，以尽可能反映Berkeley DB的工作方式。特别注意：</target>
        </trans-unit>
        <trans-unit id="85af2ce50ee2f541004fc9d53df5f4d00e80abb3" translate="yes" xml:space="preserve">
          <source>All the functions may be imported using the &lt;code&gt;:ALL&lt;/code&gt; tag.</source>
          <target state="translated">可以使用 &lt;code&gt;:ALL&lt;/code&gt; 标记导入所有功能。</target>
        </trans-unit>
        <trans-unit id="e17de002dfef54a49f116af6d04ace151f1db1a1" translate="yes" xml:space="preserve">
          <source>All the functions return an integer. This is a count of the number of items returned by the Perl subroutine. The actual items returned by the subroutine are stored on the Perl stack.</source>
          <target state="translated">所有的函数都返回一个整数。这是对Perl子程序返回的项目数的统计。子程序返回的实际项目存储在Perl栈中。</target>
        </trans-unit>
        <trans-unit id="52532a7385f2fd6662a92f143b996eb16f224ae0" translate="yes" xml:space="preserve">
          <source>All the gzip headers defined in RFC 1952 can be created using this module.</source>
          <target state="translated">所有在 RFC 1952 中定义的 gzip 头文件都可以使用这个模块来创建。</target>
        </trans-unit>
        <trans-unit id="51037cd1e5bef0efdf785304da29a37a7b0cdc06" translate="yes" xml:space="preserve">
          <source>All the modules and switches just described can be used in v5.20 with just plain &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , and, should the input locales not be UTF-8, you'll get the less than ideal behavior, described below, that you get with pre-v5.16 Perls, or when you use the locale pragma without the &lt;code&gt;:not_characters&lt;/code&gt; parameter in v5.16 and v5.18. If you are using exclusively UTF-8 locales in v5.20 and higher, the rest of this section does not apply to you.</source>
          <target state="translated">刚刚描述的所有模块和开关都可以在v5.20中仅 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 通用语言环境，并且，如果输入语言环境不是UTF-8，您将获得以下不理想的行为，如下所述，这与使用pre -v5.16 Perls，或者在v5.16和v5.18中使用不带 &lt;code&gt;:not_characters&lt;/code&gt; 参数的语言环境编译指示时。如果您在v5.20及更高版本中仅使用UTF-8语言环境，则本节的其余部分不适用于您。</target>
        </trans-unit>
        <trans-unit id="6bcfac1e4c22e90a7b2f875c6b72f2c0d403c1be" translate="yes" xml:space="preserve">
          <source>All the operators which need an argument in the integer format treat the argument as in modular arithmetic, e.g., &lt;code&gt;mod 2**32&lt;/code&gt; on a 32-bit architecture. &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, -1&lt;/code&gt; therefore provides the same result as &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, ~0&lt;/code&gt; .</source>
          <target state="translated">所有需要整数格式参数的运算符都将其视为模数算法中的参数，例如32位体系结构上的 &lt;code&gt;mod 2**32&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, -1&lt;/code&gt; 因此提供与 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, ~0&lt;/code&gt; 相同的结果。</target>
        </trans-unit>
        <trans-unit id="a4fb9683d7bd9f1429d51b7805c318a33084783c" translate="yes" xml:space="preserve">
          <source>All the other macros which will be used in this example require you to have used this macro.</source>
          <target state="translated">在本例中使用的所有其他宏都需要您使用过这个宏。</target>
        </trans-unit>
        <trans-unit id="b08b2f77f4eeb817def95bb1cac60c09fd5e4ffe" translate="yes" xml:space="preserve">
          <source>All the others are scalar types, that is, things that can be bound to a &lt;code&gt;$&lt;/code&gt; variable. For these, the internal types are mostly orthogonal to types in the Perl language.</source>
          <target state="translated">所有其他均为标量类型，即可以绑定到 &lt;code&gt;$&lt;/code&gt; 变量的事物。对于这些，内部类型通常与Perl语言中的类型正交。</target>
        </trans-unit>
        <trans-unit id="813e0349f99be3e1ec9a99a0d6e9329cddd2f012" translate="yes" xml:space="preserve">
          <source>All the properties that begin with &lt;code&gt;\p&lt;/code&gt; (and its inverse &lt;code&gt;\P&lt;/code&gt; ) are actually character classes that are Unicode-aware. There are dozens of them, see &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">所有以 &lt;code&gt;\p&lt;/code&gt; （及其反 &lt;code&gt;\P&lt;/code&gt; ）开头的属性实际上都是可识别Unicode的字符类。其中有数十种，请参阅&lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b65a75a2da1466ad79df3a0e8287f617c933054" translate="yes" xml:space="preserve">
          <source>All the sequences and escapes</source>
          <target state="translated">所有的序列和逃逸</target>
        </trans-unit>
        <trans-unit id="6f5a47adb9e53e6ad59a65ed39b02f84d8f84ac1" translate="yes" xml:space="preserve">
          <source>All the supported functions should be called as methods, i.e., either as</source>
          <target state="translated">所有支持的函数都应该以方法的形式被调用,也就是说,既可以作为</target>
        </trans-unit>
        <trans-unit id="7e345efa9c5194482201d78c3449d77663639ae8" translate="yes" xml:space="preserve">
          <source>All the talk in the world is useless without an implementation. In almost every case, the person or people who argue for a new feature will be expected to be the ones who implement it. Porters capable of coding new features have their own agendas, and are not available to implement your (possibly good) idea.</source>
          <target state="translated">如果没有实施,世界上所有的言论都是无用的。几乎在所有的情况下,主张新功能的人都会被期望成为实现它的人。有能力为新功能编码的搬运工都有自己的议程,而且没有时间去实现你的(可能是好的)想法。</target>
        </trans-unit>
        <trans-unit id="8a484c468483007c96c3a2efbbc829000cb69672" translate="yes" xml:space="preserve">
          <source>All the usual warnings about file locking apply here. In particular, note that file locking in Perl is &lt;b&gt;advisory&lt;/b&gt;, which means that holding a lock will not prevent anyone else from reading, writing, or erasing the file; it only prevents them from getting another lock at the same time. Locks are analogous to green traffic lights: If you have a green light, that does not prevent the idiot coming the other way from plowing into you sideways; it merely guarantees to you that the idiot does not also have a green light at the same time.</source>
          <target state="translated">有关文件锁定的所有常规警告均适用于此。特别要注意的是，Perl中的文件锁定是&lt;b&gt;建议性的&lt;/b&gt;，这意味着持有锁定不会阻止其他任何人读取，写入或擦除文件。这只会阻止他们同时获得另一个锁。锁类似于绿色的交通信号灯：如果您有绿色的信号灯，那并不能防止白痴从另一侧向您翻来覆去。它只是向您保证白痴不会同时开绿灯。</target>
        </trans-unit>
        <trans-unit id="7e349ac65c026bbc32c4eb141cc9c0c2c6c1c9d7" translate="yes" xml:space="preserve">
          <source>All the work of numeric conversion is done in %subr and num(). Of course, %subr is not complete, it contains only operators used in the example below. Here is the extra-credit question: why do we need an explicit recursion in num()? (Answer is at the end of this section.)</source>
          <target state="translated">所有的数字转换工作都在%subr和num()中完成。当然,%subr并不完整,它只包含下面例子中使用的运算符。这里有一个加分问题:为什么我们需要在num()中进行显式递归?(答案在本节最后。)</target>
        </trans-unit>
        <trans-unit id="0f15e65c6cfe10e49621033c9085af7927a8ea20" translate="yes" xml:space="preserve">
          <source>All these commands are callable via method interface and have names which conform to standard conventions with the leading &lt;code&gt;rl_&lt;/code&gt; stripped.</source>
          <target state="translated">所有这些命令都可以通过方法接口调用，并具有符合标准约定的名称，且前导 &lt;code&gt;rl_&lt;/code&gt; 被去除。</target>
        </trans-unit>
        <trans-unit id="1a68fff09705709c0c5d238842991f6619aad537" translate="yes" xml:space="preserve">
          <source>All these flags require &lt;b&gt;-DDEBUGGING&lt;/b&gt; when you compile the Perl executable (but see &lt;code&gt;:opd&lt;/code&gt; in &lt;a href=&quot;devel/peek&quot;&gt;Devel::Peek&lt;/a&gt; or &lt;a href=&quot;re#'debug'-mode&quot;&gt;'debug' mode in re&lt;/a&gt; which may change this). See the</source>
          <target state="translated">所有这些标志都需要&lt;b&gt;-DDEBUGGING&lt;/b&gt;当你编译Perl可执行文件（但见 &lt;code&gt;:opd&lt;/code&gt; 在&lt;a href=&quot;devel/peek&quot;&gt;杰韦利::皮克&lt;/a&gt;或&lt;a href=&quot;re#'debug'-mode&quot;&gt;在重新&amp;ldquo;调试&amp;rdquo;模式&lt;/a&gt;可能会改变这一点）。见</target>
        </trans-unit>
        <trans-unit id="4fa65daee4b35c0bdf01aba1673c1bba399f82d9" translate="yes" xml:space="preserve">
          <source>All these lines will have the same effect on the state of the $md5 object:</source>
          <target state="translated">所有这些行将对$md5对象的状态产生同样的影响。</target>
        </trans-unit>
        <trans-unit id="9bcd9b22dce2b631b5e9d54d48830f4469977758" translate="yes" xml:space="preserve">
          <source>All these variables have no effect on a newer Perl which supports the relevant feature.</source>
          <target state="translated">所有这些变量对支持相关功能的新版Perl没有影响。</target>
        </trans-unit>
        <trans-unit id="75179ef80cbabbf7cf9ad45aff86010dedc268e1" translate="yes" xml:space="preserve">
          <source>All this obviously requires a way for the Perl internal functions to be either subroutines taking some kind of structure as the first argument, or subroutines taking nothing as the first argument. To enable these two very different ways of building the interpreter, the Perl source (as it does in so many other situations) makes heavy use of macros and subroutine naming conventions.</source>
          <target state="translated">所有这些显然都需要一种方法,使 Perl 内部函数要么是以某种结构作为第一个参数的子程序,要么是不以任何东西作为第一个参数的子程序。为了实现这两种截然不同的构建解释器的方式,Perl 源代码(就像在许多其他情况下一样)大量使用了宏和子程序的命名约定。</target>
        </trans-unit>
        <trans-unit id="05bb57d634b2fcc45dc9babcad96740ee2e8f313" translate="yes" xml:space="preserve">
          <source>All this should be handled automatically by the hints file, if requested.</source>
          <target state="translated">如果要求的话,所有这些都应该由提示文件自动处理。</target>
        </trans-unit>
        <trans-unit id="7381ecad8164c50156cc34405ade99393869ea97" translate="yes" xml:space="preserve">
          <source>All those functions (red(), blue(), green(), etc.) appear to be separate, but the real code in the closure actually was compiled only once.</source>
          <target state="translated">所有这些函数(red()、blue()、green()等)看起来是独立的,但实际上封闭中的真正代码只编译了一次。</target>
        </trans-unit>
        <trans-unit id="1eb3cfb093a32021b17dfa327362fe2a1ecb7499" translate="yes" xml:space="preserve">
          <source>All threads blocking on &lt;code&gt;dequeue()&lt;/code&gt; calls will be unblocked with any remaining items in the queue and/or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; being returned. Any subsequent calls to &lt;code&gt;dequeue()&lt;/code&gt; will behave like &lt;code&gt;dequeue_nb()&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;dequeue()&lt;/code&gt; 调用中阻塞的所有线程都将被解除阻塞，并保留队列中的所有剩余项和/或返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。随后对 &lt;code&gt;dequeue()&lt;/code&gt; 的任何调用都将类似于 &lt;code&gt;dequeue_nb()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31b59027aac85c24edba2402c4b5479124b0b5b8" translate="yes" xml:space="preserve">
          <source>All three APIs &lt;code&gt;fill_mstats($buf)&lt;/code&gt; , &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt; , and &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; are designed to allocate no memory if used</source>
          <target state="translated">所有三个API &lt;code&gt;fill_mstats($buf)&lt;/code&gt; ， &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt; 和 &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; 均设计为不分配内存（如果使用）</target>
        </trans-unit>
        <trans-unit id="93f405b3f1113c619eaa3ff8cf11a04161308e3b" translate="yes" xml:space="preserve">
          <source>All three types, namely &lt;code&gt;configure_requires&lt;/code&gt; , &lt;code&gt;build_requires&lt;/code&gt; , and &lt;code&gt;requires&lt;/code&gt; are supported in the way specified in the META.yml specification. The current implementation</source>
          <target state="translated">所有这三种类型，即 &lt;code&gt;configure_requires&lt;/code&gt; ， &lt;code&gt;build_requires&lt;/code&gt; ，并 &lt;code&gt;requires&lt;/code&gt; 在META.yml规范中规定的方式支撑。当前执行</target>
        </trans-unit>
        <trans-unit id="e69868d20db4582400a5d6cd9bcd656e5299ed1b" translate="yes" xml:space="preserve">
          <source>All variants of Unix, Mac OS (old and new), and Stream_LF files on VMS use a single character to end each line in the external representation of text (even though that single character is CARRIAGE RETURN on old, pre-Darwin flavors of Mac OS, and is LINE FEED on Unix and most VMS files). In other systems like OS/2, DOS, and the various flavors of MS-Windows, your program sees a &lt;code&gt;\n&lt;/code&gt; as a simple &lt;code&gt;\cJ&lt;/code&gt; , but what's stored in text files are the two characters &lt;code&gt;\cM\cJ&lt;/code&gt; . That means that if you don't use binmode() on these systems, &lt;code&gt;\cM\cJ&lt;/code&gt; sequences on disk will be converted to &lt;code&gt;\n&lt;/code&gt; on input, and any &lt;code&gt;\n&lt;/code&gt; in your program will be converted back to &lt;code&gt;\cM\cJ&lt;/code&gt; on output. This is what you want for text files, but it can be disastrous for binary files.</source>
          <target state="translated">VMS上Unix，Mac OS（旧的和新的）和Stream_LF文件的所有变体都使用单个字符结束文本外部表示中的每一行（即使该单个字符在旧的达尔文风格的Mac上是CARRIAGE RETURN）操作系统，在Unix和大多数VMS文件上为LINE FEED）。在OS / 2，DOS和其他各种MS-Windows系统中，您的程序将 &lt;code&gt;\n&lt;/code&gt; 视为简单的 &lt;code&gt;\cJ&lt;/code&gt; ，但是存储在文本文件中的是两个字符 &lt;code&gt;\cM\cJ&lt;/code&gt; 。这意味着，如果您在这些系统上不使用binmode（），则磁盘上的 &lt;code&gt;\cM\cJ&lt;/code&gt; 序列将在输入时转换为 &lt;code&gt;\n&lt;/code&gt; ，并且程序中的所有 &lt;code&gt;\n&lt;/code&gt; 都将转换回 &lt;code&gt;\cM\cJ&lt;/code&gt; 在输出上。这是您想要的文本文件，但是对于二进制文件可能是灾难性的。</target>
        </trans-unit>
        <trans-unit id="ad579c08df3b605d9bcdf2dd854aada4ff50f1d7" translate="yes" xml:space="preserve">
          <source>All warnings are enabled in a block by either of these:</source>
          <target state="translated">在一个区块中,所有的警告都是通过这两种方式启用的。</target>
        </trans-unit>
        <trans-unit id="ac638dedbe9b121696313ec4c1b744224313d7b2" translate="yes" xml:space="preserve">
          <source>All warnings from these class elements are fatal, as well as some practices that don't currently warn. For example you cannot say</source>
          <target state="translated">这些类元素的所有警告都是致命的,还有一些目前没有警告的做法。例如,你不能说</target>
        </trans-unit>
        <trans-unit id="370cb67fce7c69dd6b28a7668dbdd050522c81c2" translate="yes" xml:space="preserve">
          <source>All we send is -nologo to nmake to prevent it from printing its damned banner.</source>
          <target state="translated">我们只需要给nmake发送-nologo,防止它打印出该死的旗帜。</target>
        </trans-unit>
        <trans-unit id="89ae61e8070c7c0925079d83f7934e0eb3357598" translate="yes" xml:space="preserve">
          <source>All writes should be appends.</source>
          <target state="translated">所有的写法都应该是附加的。</target>
        </trans-unit>
        <trans-unit id="d673c2e10445ecd4d4244da3c2339308139938ca" translate="yes" xml:space="preserve">
          <source>All you need to be able to use this is a C compiler than generates BSD/GCC-style stabs. The &lt;b&gt;-g&lt;/b&gt; option on native BSD compilers and GCC should get this for you.</source>
          <target state="translated">您只需使用C编译器即可生成BSD / GCC样式的刺刀。本机BSD编译器和GCC上的&lt;b&gt;-g&lt;/b&gt;选项应该可以为您提供。</target>
        </trans-unit>
        <trans-unit id="3703c85b2e19a742cbffc3e68e850016eb81f530" translate="yes" xml:space="preserve">
          <source>All you need to do is post a short summary of the module, its purpose and interfaces. A few lines on each of the main methods is probably enough. (If you post the whole module it might be ignored by busy people - generally the very people you want to read it!)</source>
          <target state="translated">你需要做的就是发一个简短的模块总结,它的目的和接口。每一个主要方法的几行文字大概就够了。(如果你贴出整个模块,可能会被忙碌的人忽略--通常是你希望阅读它的人!)</target>
        </trans-unit>
        <trans-unit id="42dd47aab008353520f505d14f8982da5b7ec66c" translate="yes" xml:space="preserve">
          <source>All you need to do is turn on caching outside of the lexicon hash itself like so:</source>
          <target state="translated">你需要做的就是在词库哈希本身之外开启缓存,像这样。</target>
        </trans-unit>
        <trans-unit id="97cf0e2918a9254a0eafa0498166116f753c3eef" translate="yes" xml:space="preserve">
          <source>All-in-one interface</source>
          <target state="translated">一体化接口</target>
        </trans-unit>
        <trans-unit id="6fee78bc0546aa696412ff85a7bc963fbc9ca7d4" translate="yes" xml:space="preserve">
          <source>Allocate (if not already done so) the read buffer for this layer and return pointer to it. Return NULL on failure.</source>
          <target state="translated">为这一层分配(如果还没有分配)读取缓冲区,并返回指针。失败时返回NULL。</target>
        </trans-unit>
        <trans-unit id="3b2ee334827d425691fcbfb9ca0bc34e49168fb9" translate="yes" xml:space="preserve">
          <source>Allocates a new Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">分配一个新的Perl解释器。见&lt;a href=&quot;perlembed&quot;&gt;临危&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="204757b0500eb920f73e23856bcfacd06d0f5f77" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad (via &lt;a href=&quot;#pad_alloc&quot;&gt;pad_alloc&lt;/a&gt;) for an anonymous function that is lexically scoped inside the currently-compiling function. The function</source>
          <target state="translated">在当前编译的填充区中（通过&lt;a href=&quot;#pad_alloc&quot;&gt;pad_alloc&lt;/a&gt;）为匿名函数分配一个位置，该匿名函数按词法作用于当前编译的函数内。功能</target>
        </trans-unit>
        <trans-unit id="cbc8fd0f139e1ed3d083e8bda55cb3c680701f85" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad (via &lt;a href=&quot;perlapi#pad_alloc&quot;&gt;pad_alloc in perlapi&lt;/a&gt;) and then stores a name for that entry.</source>
          <target state="translated">在当前编译的填充中分配一个位置（通过&lt;a href=&quot;perlapi#pad_alloc&quot;&gt;perlapi中的pad_alloc&lt;/a&gt;），然后存储该条目的名称。</target>
        </trans-unit>
        <trans-unit id="5c5b44a37c6737cadc335e0a4b7b826b48bad95f" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad for a named lexical variable. Stores the name and other metadata in the name part of the pad, and makes preparations to manage the variable's lexical scoping. Returns the offset of the allocated pad slot.</source>
          <target state="translated">在当前编译垫中为一个命名的词法变量分配一个位置。将名称和其他元数据存储在pad的name部分,并为管理变量的词法范围做准备。返回所分配的pad槽的偏移量。</target>
        </trans-unit>
        <trans-unit id="b7b59f013b83c5b7e66a9f56292d13c76f0cfbe1" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad, returning the offset of the allocated pad slot. No name is initially attached to the pad slot.</source>
          <target state="translated">在当前编译的pad中分配一个位置,返回分配的pad槽的偏移量。初始没有名字附加到垫块槽中。</target>
        </trans-unit>
        <trans-unit id="1b5c021aee14bea734803bc4262d3ac794a7f664" translate="yes" xml:space="preserve">
          <source>Allocation</source>
          <target state="translated">Allocation</target>
        </trans-unit>
        <trans-unit id="2e2f6a9fe9c75300156ed8faa2846a84de58e28c" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;+&lt;/code&gt; to start options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;getopt_compat&lt;/code&gt; is disabled.</source>
          <target state="translated">允许 &lt;code&gt;+&lt;/code&gt; 启动选项。除非已设置环境变量POSIXLY_CORRECT，否则将启用默认值，在这种情况下，将禁用 &lt;code&gt;getopt_compat&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a59030efa024b93a6e819c9cb26054addbab292b" translate="yes" xml:space="preserve">
          <source>Allow option names to be abbreviated to uniqueness. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;auto_abbrev&lt;/code&gt; is disabled.</source>
          <target state="translated">允许选项名称缩写为唯一。除非已设置环境变量POSIXLY_CORRECT，否则将启用默认值，在这种情况下，将禁用 &lt;code&gt;auto_abbrev&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="daa78d2843413d350c8af8e2659c80ab1cc32bed" translate="yes" xml:space="preserve">
          <source>Allowing &quot;.&quot; as a version delimiter is simply incompatible with determining whether a pathname is in VMS format or in Unix format with extended file syntax. There is no way to know whether &quot;perl-5.8.6&quot; is a Unix &quot;perl-5.8.6&quot; or a VMS &quot;perl-5.8;6&quot; when passing it to unixify() or vmsify().</source>
          <target state="translated">允许用&quot;.&quot;作为版本分隔符,与确定一个路径名是VMS格式还是Unix格式的扩展文件语法完全不兼容。当把 &quot;perl-5.8.6 &quot;传递给unixify()或vmsify()时,无法知道它是Unix的 &quot;perl-5.8.6 &quot;还是VMS的 &quot;perl-5.8;6&quot;。</target>
        </trans-unit>
        <trans-unit id="c408189be3311ef544fc6916d88f93932d6bdffc" translate="yes" xml:space="preserve">
          <source>Allowing this could have security implications, as a malicious tar archive could alter or replace any file the extracting user has permissions to. Therefor, the default is to not allow insecure extractions.</source>
          <target state="translated">允许这样做可能会产生安全影响,因为恶意的焦油压缩包可能会改变或替换提取用户有权限的任何文件。因此,默认情况是不允许不安全的解压缩。</target>
        </trans-unit>
        <trans-unit id="ddbc44ff2a879d62f5a15a25c82d1c43a6e19ca9" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of &lt;a href=&quot;../perlpod#Formatting-Codes&quot;&gt;Formatting Codes in perlpod&lt;/a&gt;. This can be used to implement user-defined codes.</source>
          <target state="translated">允许 &lt;code&gt;$parser&lt;/code&gt; 接受&lt;a href=&quot;../perlpod#Formatting-Codes&quot;&gt;perlpod&lt;/a&gt;中的格式代码列表。这可用于实现用户定义的代码。</target>
        </trans-unit>
        <trans-unit id="101aab8a8afb357465320bb5f121a4ac661795be" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for &lt;a href=&quot;../perlpod#Verbatim-Paragraph&quot;&gt;Verbatim Paragraph in perlpod&lt;/a&gt;. A directive is the label of a &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. This can be used to implement user-defined directives.</source>
          <target state="translated">允许 &lt;code&gt;$parser&lt;/code&gt; &lt;a href=&quot;../perlpod#Verbatim-Paragraph&quot;&gt;在perlpod中&lt;/a&gt;接受Verbatim Paragraph的指令列表。指令是&lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;perlpod中命令段落&lt;/a&gt;的标签。这可用于实现用户定义的指令。</target>
        </trans-unit>
        <trans-unit id="f2a410a266e9f220f21c4f8d80b7768daa7e08ef" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for data paragraphs. A directive is the label of a &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. A data paragraph is one delimited by &lt;code&gt;=begin/=for/=end&lt;/code&gt; directives. This can be used to implement user-defined directives.</source>
          <target state="translated">允许 &lt;code&gt;$parser&lt;/code&gt; 接受数据段落的指令列表。指令是&lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;perlpod中命令段落&lt;/a&gt;的标签。数据段是由 &lt;code&gt;=begin/=for/=end&lt;/code&gt; 指令分隔的段。这可用于实现用户定义的指令。</target>
        </trans-unit>
        <trans-unit id="0abf6fb24aebd1865d65a4df47fe30a801298ce2" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for processed paragraphs. A directive is the label of a &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. A processed paragraph is also known as &lt;a href=&quot;../perlpod#Ordinary-Paragraph&quot;&gt;Ordinary Paragraph in perlpod&lt;/a&gt;. This can be used to implement user-defined directives.</source>
          <target state="translated">允许 &lt;code&gt;$parser&lt;/code&gt; 接受已处理段落的指令列表。指令是&lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;perlpod中命令段落&lt;/a&gt;的标签。处理过的&lt;a href=&quot;../perlpod#Ordinary-Paragraph&quot;&gt;段落在perlpod中&lt;/a&gt;也称为&amp;ldquo; 普通段落&amp;rdquo;。这可用于实现用户定义的指令。</target>
        </trans-unit>
        <trans-unit id="a3735b17f2c2eb4921645bcf6a4d22392282447c" translate="yes" xml:space="preserve">
          <source>Allows a pre-existing extension directory to be overwritten.</source>
          <target state="translated">允许覆盖已存在的扩展目录。</target>
        </trans-unit>
        <trans-unit id="4b9153c7965fe5ac4319d07a3a1e17ae8bc10ce3" translate="yes" xml:space="preserve">
          <source>Allows an extension to be created for a header even if that header is not found in standard include directories.</source>
          <target state="translated">允许为一个头创建扩展,即使该头在标准的include目录中找不到。</target>
        </trans-unit>
        <trans-unit id="daf02b11ffbf9506236d387546a93a50fc62cc0a" translate="yes" xml:space="preserve">
          <source>Allows files and directories to be moved to the Trashcan/Recycle Bin (where they may later be restored if necessary) if the operating system supports such functionality. This feature may one day be made available directly in &lt;code&gt;File::Path&lt;/code&gt; .</source>
          <target state="translated">如果操作系统支持，则允许将文件和目录移动到垃圾桶/回收站（如有必要，可在以后还原的位置）中。有一天，可以直接在 &lt;code&gt;File::Path&lt;/code&gt; 使用此功能。</target>
        </trans-unit>
        <trans-unit id="559ebf2a9218f8c70716cdc11eee2f4b586a5213" translate="yes" xml:space="preserve">
          <source>Allows multiple concatenated compressed streams to be treated as a single compressed stream. Decompression will stop once either the end of the file/buffer is reached, an error is encountered (premature eof, corrupt compressed data) or the end of a stream is not immediately followed by the start of another stream.</source>
          <target state="translated">允许将多个连接的压缩流作为一个压缩流处理。一旦到达文件/缓冲区的末端,遇到错误(过早的eof,损坏的压缩数据)或者一个流的末端没有紧接着另一个流的开始,解压缩就会停止。</target>
        </trans-unit>
        <trans-unit id="7e5261df1ca0e4f1432538fbf7dfbe931383691e" translate="yes" xml:space="preserve">
          <source>Allows newName to be used as an alias for ENCODING. ENCODING may be either the name of an encoding or an encoding object (as described in &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;).</source>
          <target state="translated">允许将newName用作ENCODING的别名。ENCODING可以是编码的名称，也可以是编码对象的名称（如&lt;a href=&quot;../encode&quot;&gt;Encode中所述&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="76b238c6a405ca46725f72efca71d3c55969afb7" translate="yes" xml:space="preserve">
          <source>Allows source endpoint verification to be enabled or disabled. This is useful for those remote destinations with multiples interfaces where the response may not originate from the same endpoint that the original destination endpoint was sent to. This only affects udp and icmp protocol pings.</source>
          <target state="translated">允许启用或禁用源端点验证。这对于那些有多个接口的远程目的地来说很有用,因为在这些地方,响应可能不是来自于原始目的地端点被发送到的同一个端点。这只影响udp和icmp协议的ping。</target>
        </trans-unit>
        <trans-unit id="b46332805263e8790df0747eb20b444ed87a43b7" translate="yes" xml:space="preserve">
          <source>Allows you to both load one or more modules, while setting up inheritance from those modules at the same time. Mostly similar in effect to</source>
          <target state="translated">允许你同时加载一个或多个模块,同时设置这些模块的继承。大致上类似于</target>
        </trans-unit>
        <trans-unit id="c9da0fc905ccf60ade5ca9f7c49a801a55f4a1c8" translate="yes" xml:space="preserve">
          <source>Allows you to both load one or more modules, while setting up inheritance from those modules at the same time. Roughly similar in effect to</source>
          <target state="translated">允许你同时加载一个或多个模块,同时设置这些模块的继承。大致上类似于</target>
        </trans-unit>
        <trans-unit id="22f08aec036591ac3a4e81d90d5af18a1bd7db2a" translate="yes" xml:space="preserve">
          <source>Allows you to choose the character encoding will be store in the DBM file.</source>
          <target state="translated">允许您选择将存储在DBM文件中的字符编码。</target>
        </trans-unit>
        <trans-unit id="dab85f86a937e724bd3f8c905ebc9700e2dbc47d" translate="yes" xml:space="preserve">
          <source>Allows you to write your script in non-ASCII and non-UTF-8</source>
          <target state="translated">允许你用非ASCII和非UTF-8的格式编写脚本。</target>
        </trans-unit>
        <trans-unit id="dce4c63a4fe0fe7df493313e47b4aaa4d8491416" translate="yes" xml:space="preserve">
          <source>Almost all properties are immune to case-insensitive matching. That is, adding a &lt;code&gt;/i&lt;/code&gt; regular expression modifier does not change what they match. There are two sets that are affected. The first set is &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; , and &lt;code&gt;Titlecase_Letter&lt;/code&gt; , all of which match &lt;code&gt;Cased_Letter&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. And the second set is &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; , and &lt;code&gt;Titlecase&lt;/code&gt; , all of which match &lt;code&gt;Cased&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. This set also includes its subsets &lt;code&gt;PosixUpper&lt;/code&gt; and &lt;code&gt;PosixLower&lt;/code&gt; both of which under &lt;code&gt;/i&lt;/code&gt; match &lt;code&gt;PosixAlpha&lt;/code&gt; . (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case so they are &lt;code&gt;Cased&lt;/code&gt; , but aren't considered letters, so they aren't &lt;code&gt;Cased_Letter&lt;/code&gt; 's.)</source>
          <target state="translated">几乎所有属性都不受大小写敏感匹配的影响。也就是说，添加 &lt;code&gt;/i&lt;/code&gt; 正则表达式修饰符不会更改它们的匹配项。有两个受影响的集。第一组是 &lt;code&gt;Uppercase_Letter&lt;/code&gt; ， &lt;code&gt;Lowercase_Letter&lt;/code&gt; ，和 &lt;code&gt;Titlecase_Letter&lt;/code&gt; ，所有这些匹配 &lt;code&gt;Cased_Letter&lt;/code&gt; 下 &lt;code&gt;/i&lt;/code&gt; 匹配。和所述第二组是 &lt;code&gt;Uppercase&lt;/code&gt; ， &lt;code&gt;Lowercase&lt;/code&gt; ，和 &lt;code&gt;Titlecase&lt;/code&gt; ，所有这些匹配 &lt;code&gt;Cased&lt;/code&gt; 下 &lt;code&gt;/i&lt;/code&gt; 匹配。该集合还包括其子集 &lt;code&gt;PosixUpper&lt;/code&gt; 和 &lt;code&gt;PosixLower&lt;/code&gt; ，它们都位于 &lt;code&gt;/i&lt;/code&gt; 匹配 &lt;code&gt;PosixAlpha&lt;/code&gt; 。 （这两个集合之间的区别是，某些东西（例如罗马数字）同时以大写和小写形式出现，因此它们为 &lt;code&gt;Cased&lt;/code&gt; ，但不被视为字母，因此也不是 &lt;code&gt;Cased_Letter&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="e26025e2ac0ac02421707ba70eeed5ab6641b4e6" translate="yes" xml:space="preserve">
          <source>Almost definitely only useful to people hacking on the offsets part of the debug engine.</source>
          <target state="translated">几乎肯定只对黑客在调试引擎的偏移部分有用。</target>
        </trans-unit>
        <trans-unit id="38d90c72fc98727ed772fa67692cb8b8e8e09948" translate="yes" xml:space="preserve">
          <source>Along the same lines, just because you</source>
          <target state="translated">同样的道理,就因为你</target>
        </trans-unit>
        <trans-unit id="bfe689be701eb0f2bfb705a857c3ee07252b9d77" translate="yes" xml:space="preserve">
          <source>Along with the Perl interpreter itself, the Perl distribution installs a range of utilities on your system. There are also several utilities which are used by the Perl distribution itself as part of the install process. This document exists to list all of these utilities, explain what they are for and provide pointers to each module's documentation, if appropriate.</source>
          <target state="translated">除了Perl解释器本身,Perl发行版还会在你的系统上安装一系列的实用程序。此外,还有一些实用程序是Perl发行版本身在安装过程中使用的。本文档将列出所有这些实用程序,解释它们的用途,并在适当的情况下提供指向每个模块文档的指针。</target>
        </trans-unit>
        <trans-unit id="e9e4db05fa3da393c5842e003969195c59714caf" translate="yes" xml:space="preserve">
          <source>Alphabetical Listing of Perl Functions</source>
          <target state="translated">按字母顺序排列的Perl函数</target>
        </trans-unit>
        <trans-unit id="35100f76a7dd5f19974c02f54724529e98b1eb3a" translate="yes" xml:space="preserve">
          <source>Alphabetical index of Unicode characters</source>
          <target state="translated">按字母顺序排列的Unicode字符索引</target>
        </trans-unit>
        <trans-unit id="834177335506d3ec099968dc2393bf176b00318d" translate="yes" xml:space="preserve">
          <source>Also Perl gives access to various C library functions through the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module. Some of those functions are always affected by the current locale. For example, &lt;code&gt;POSIX::strftime()&lt;/code&gt; uses &lt;code&gt;LC_TIME&lt;/code&gt; ; &lt;code&gt;POSIX::strtod()&lt;/code&gt; uses &lt;code&gt;LC_NUMERIC&lt;/code&gt; ; &lt;code&gt;POSIX::strcoll()&lt;/code&gt; and &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; use &lt;code&gt;LC_COLLATE&lt;/code&gt; ; and character classification functions like &lt;code&gt;POSIX::isalnum()&lt;/code&gt; use &lt;code&gt;LC_CTYPE&lt;/code&gt; . All such functions will behave according to the current underlying locale, even if that locale isn't exposed to Perl space.</source>
          <target state="translated">另外，Perl还可以通过&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块访问各种C库函数。其中一些功能始终受当前语言环境的影响。例如， &lt;code&gt;POSIX::strftime()&lt;/code&gt; 使用 &lt;code&gt;LC_TIME&lt;/code&gt; ； &lt;code&gt;POSIX::strtod()&lt;/code&gt; 使用 &lt;code&gt;LC_NUMERIC&lt;/code&gt; ; &lt;code&gt;POSIX::strcoll()&lt;/code&gt; 和 &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; 使用 &lt;code&gt;LC_COLLATE&lt;/code&gt; ;字符分类功能（例如 &lt;code&gt;POSIX::isalnum()&lt;/code&gt; 使用 &lt;code&gt;LC_CTYPE&lt;/code&gt; 。所有此类功能都将根据当前的基础语言环境运行，即使该语言环境未暴露给Perl空间也是如此。</target>
        </trans-unit>
        <trans-unit id="80beb22d4bec02699379f749d87a910462f32ef7" translate="yes" xml:space="preserve">
          <source>Also add the following code segment to Mytest.t while incrementing the &quot;9&quot; tests to &quot;11&quot;:</source>
          <target state="translated">同时在Mytest.t中添加以下代码段,同时将 &quot;9 &quot;测试递增为 &quot;11&quot;。</target>
        </trans-unit>
        <trans-unit id="ac140b9c3d4faf5ff89331ade5065ee26ad2ce5b" translate="yes" xml:space="preserve">
          <source>Also available in the CPAN &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::CaseFold&quot;&gt;Unicode::CaseFold&lt;/a&gt; module, the new &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; &amp;ldquo;foldcase&amp;rdquo; function from v5.16 grants access to the same Unicode casefolding as the &lt;code&gt;/i&lt;/code&gt; pattern modifier has always used:</source>
          <target state="translated">在CPAN &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::CaseFold&quot;&gt;Unicode :: CaseFold&lt;/a&gt;模块中也可用，v5.16中的新 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; &amp;ldquo; foldcase&amp;rdquo;功能可以访问 &lt;code&gt;/i&lt;/code&gt; 模式修饰符始终使用的相同Unicode大小写折叠：</target>
        </trans-unit>
        <trans-unit id="46cd58b57422283c68d064857c29c9de3e394325" translate="yes" xml:space="preserve">
          <source>Also change</source>
          <target state="translated">同时改变</target>
        </trans-unit>
        <trans-unit id="c0abeeb67d5f473db892c8e04d0607c1def48eaa" translate="yes" xml:space="preserve">
          <source>Also compare &lt;code&gt;SAVEMORTALIZESV&lt;/code&gt; .</source>
          <target state="translated">还要比较 &lt;code&gt;SAVEMORTALIZESV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05e4ad005c5681ba47d1d566b8e0cb49ffb2ad43" translate="yes" xml:space="preserve">
          <source>Also consider this valid structure:</source>
          <target state="translated">同时考虑这个有效的结构。</target>
        </trans-unit>
        <trans-unit id="a7b339961adc2d21b9a876670a45b1f1d855a3be" translate="yes" xml:space="preserve">
          <source>Also create a file mylib.c that looks like this:</source>
          <target state="translated">同时创建一个mylib.c文件,看起来像这样。</target>
        </trans-unit>
        <trans-unit id="c401faba028e376c88469287989685e42d637510" translate="yes" xml:space="preserve">
          <source>Also floating point numbers have endianness. Usually (but not always) this agrees with the integer endianness. Even though most platforms these days use the IEEE 754 binary format, there are differences, especially if the long doubles are involved. You can see the &lt;code&gt;Config&lt;/code&gt; variables &lt;code&gt;doublekind&lt;/code&gt; and &lt;code&gt;longdblkind&lt;/code&gt; (also &lt;code&gt;doublesize&lt;/code&gt; , &lt;code&gt;longdblsize&lt;/code&gt; ): the &quot;kind&quot; values are enums, unlike &lt;code&gt;byteorder&lt;/code&gt; .</source>
          <target state="translated">浮点数也具有字节顺序。通常（但不总是）这与整数字节序一致。即使当今大多数平台都使用IEEE 754二进制格式，也存在差异，尤其是在涉及长双精度的情况下。你可以看到 &lt;code&gt;Config&lt;/code&gt; 变量 &lt;code&gt;doublekind&lt;/code&gt; 和 &lt;code&gt;longdblkind&lt;/code&gt; （也 &lt;code&gt;doublesize&lt;/code&gt; ， &lt;code&gt;longdblsize&lt;/code&gt; ）：在&amp;ldquo;种&amp;rdquo;的值是枚举，不像 &lt;code&gt;byteorder&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6a0632d09aa67f7c933563807a5dc4e1be43b5e" translate="yes" xml:space="preserve">
          <source>Also good for one-liners:</source>
          <target state="translated">也很适合单口相声。</target>
        </trans-unit>
        <trans-unit id="801a4731c98561cdcf16aa86d636dfa32a54b0ca" translate="yes" xml:space="preserve">
          <source>Also keep around the old $(SAY) macro in case somebody's using it.</source>
          <target state="translated">另外,还可以保留旧的$(SAY)宏,以防有人在使用。</target>
        </trans-unit>
        <trans-unit id="2c84ea90ff2c682d2dfed6ff8b041df2e7877e52" translate="yes" xml:space="preserve">
          <source>Also like the &quot;strict&quot; pragma, if there is more than one instance of the &lt;code&gt;warnings&lt;/code&gt; pragma in a given scope the cumulative effect is additive.</source>
          <target state="translated">就像&amp;ldquo;严格&amp;rdquo;实用指示一样，如果在给定范围内有多个 &lt;code&gt;warnings&lt;/code&gt; 实用指示实例，则累积效果是累加的。</target>
        </trans-unit>
        <trans-unit id="8b1ee43d27cd54e3a73fd0b027a7a33d6ab24281" translate="yes" xml:space="preserve">
          <source>Also make sure that you have</source>
          <target state="translated">同时确保你有</target>
        </trans-unit>
        <trans-unit id="ccf329915f222131778e86ee9fd087f89f391e81" translate="yes" xml:space="preserve">
          <source>Also make sure you read &lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;BUGS AND CAVEATS&lt;/a&gt; below for the known limitations of this port.</source>
          <target state="translated">另外，请务必仔细阅读&lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;错误和CAVEATS&lt;/a&gt;下面这个端口的已知限制。</target>
        </trans-unit>
        <trans-unit id="fe06cc0daccf4654b8c81c8f1faee5e0b7783c69" translate="yes" xml:space="preserve">
          <source>Also no attention is paid to &lt;code&gt;\c\&lt;/code&gt; (multichar control char syntax) during this search. Thus the second &lt;code&gt;\&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq/\c\/&lt;/a&gt;&lt;/code&gt; is interpreted as a part of &lt;code&gt;\/&lt;/code&gt;, and the following &lt;code&gt;/&lt;/code&gt; is not recognized as a delimiter. Instead, use &lt;code&gt;\034&lt;/code&gt; or &lt;code&gt;\x1c&lt;/code&gt; at the end of quoted constructs.</source>
          <target state="translated">在此搜索期间，也不会注意 &lt;code&gt;\c\&lt;/code&gt; （多字符控制char语法）。因此，第二 &lt;code&gt;\&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq/\c\/&lt;/a&gt;&lt;/code&gt; 被解释为的一部分 &lt;code&gt;\/&lt;/code&gt; 和下面的 &lt;code&gt;/&lt;/code&gt; 不被识别为一个定界符。而是在引用的结构末尾使用 &lt;code&gt;\034&lt;/code&gt; 或 &lt;code&gt;\x1c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73a9b46957654b20ec65fb83845a1d68f2c4bbed" translate="yes" xml:space="preserve">
          <source>Also note that</source>
          <target state="translated">还注意到</target>
        </trans-unit>
        <trans-unit id="674fbb1e5f8c5ba4d4b18a90ede292ece92dabf5" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; passes command line arguments to &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;, which doesn't necessarily interpret them as file names. See &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for possible security implications.</source>
          <target state="translated">另请注意， &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 将命令行参数传递给&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;，不一定将它们解释为文件名。请参阅&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;了解可能的安全隐患。</target>
        </trans-unit>
        <trans-unit id="93e48d832329c669ef467acfbb855710b1f11c32" translate="yes" xml:space="preserve">
          <source>Also note that in order to be compatible with the shell command, &lt;code&gt;basename()&lt;/code&gt; does not strip off a suffix if it is identical to the remaining characters in the filename.</source>
          <target state="translated">还要注意，为了与shell命令兼容，如果 &lt;code&gt;basename()&lt;/code&gt; 与文件名中的其余字符相同，则不会去除后缀。</target>
        </trans-unit>
        <trans-unit id="6d4f64c4ffda1e49198c526880412a3685e89bbb" translate="yes" xml:space="preserve">
          <source>Also note that in some platforms trying to use the infinity in arithmetic operations may result in Perl crashing because using an infinity causes SIGFPE or its moral equivalent to be sent. The way to ignore this is</source>
          <target state="translated">另外需要注意的是,在某些平台上,试图在算术运算中使用无穷大,可能会导致Perl崩溃,因为使用无穷大会导致SIGFPE或其道德等价物被发送。忽略这个问题的方法是</target>
        </trans-unit>
        <trans-unit id="e93493c0471e07df3c4c3cbce58bbf69cdead50b" translate="yes" xml:space="preserve">
          <source>Also note that non-STD file handles remain unaffected. Use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to change the layers of those.</source>
          <target state="translated">另请注意，非STD文件句柄不受影响。使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 更改这些图层。</target>
        </trans-unit>
        <trans-unit id="8343e14f16aa3f23ee42ee984961cfee3da48f48" translate="yes" xml:space="preserve">
          <source>Also note that the &lt;code&gt;sv_set*()&lt;/code&gt; and &lt;code&gt;sv_cat*()&lt;/code&gt; functions described earlier do &lt;b&gt;not&lt;/b&gt; invoke 'set' magic on their targets. This must be done by the user either by calling the &lt;code&gt;SvSETMAGIC()&lt;/code&gt; macro after calling these functions, or by using one of the &lt;code&gt;sv_set*_mg()&lt;/code&gt; or &lt;code&gt;sv_cat*_mg()&lt;/code&gt; functions. Similarly, generic C code must call the &lt;code&gt;SvGETMAGIC()&lt;/code&gt; macro to invoke any 'get' magic if they use an SV obtained from external sources in functions that don't handle magic. See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for a description of these functions. For example, calls to the &lt;code&gt;sv_cat*()&lt;/code&gt; functions typically need to be followed by &lt;code&gt;SvSETMAGIC()&lt;/code&gt; , but they don't need a prior &lt;code&gt;SvGETMAGIC()&lt;/code&gt; since their implementation handles 'get' magic.</source>
          <target state="translated">还要注意，前面介绍的 &lt;code&gt;sv_set*()&lt;/code&gt; 和 &lt;code&gt;sv_cat*()&lt;/code&gt; 函数&lt;b&gt;不会&lt;/b&gt;在目标上调用&amp;ldquo;设置&amp;rdquo;魔术。这必须由用户通过在调用这些函数之后调用 &lt;code&gt;SvSETMAGIC()&lt;/code&gt; 宏或使用 &lt;code&gt;sv_set*_mg()&lt;/code&gt; 或 &lt;code&gt;sv_cat*_mg()&lt;/code&gt; 函数之一来完成。同样，如果通用C代码在无法处理魔术的函数中使用从外部来源获得的SV，则必须调用 &lt;code&gt;SvGETMAGIC()&lt;/code&gt; 宏以调用任何&amp;ldquo;获取&amp;rdquo;魔术。有关这些功能的说明，请参见&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;。例如，对 &lt;code&gt;sv_cat*()&lt;/code&gt; 函数的调用通常需要后面跟随 &lt;code&gt;SvSETMAGIC()&lt;/code&gt; ，但由于其实现可以处理&amp;ldquo;获取&amp;rdquo;魔术，因此它们不需要预先的 &lt;code&gt;SvGETMAGIC()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7be1aad912cf4ad5fcf4064cf6ab4309ca326be" translate="yes" xml:space="preserve">
          <source>Also note that the bval option only allows you to specify a single byte as a delimiter.</source>
          <target state="translated">同时注意,bval选项只允许你指定一个字节作为定界符。</target>
        </trans-unit>
        <trans-unit id="fb785a40ce237466b61cf74c58f19b12f7daa54a" translate="yes" xml:space="preserve">
          <source>Also note that there's no value for UNITCHECK-blocks. That's because those are run for each compilation unit individually, and therefore is not a global interpreter phase.</source>
          <target state="translated">同时注意,没有unitchcheck-blocks的值,这是因为那些是针对每个编译单元单独运行的,因此不是全局解释器阶段。这是因为这些是为每个编译单元单独运行的,因此不是全局解释器阶段。</target>
        </trans-unit>
        <trans-unit id="8af529a7344d9be72e889a1f3967799ba9dc98d6" translate="yes" xml:space="preserve">
          <source>Also note that these instructions are tailored for installing the module into your system's repository of Perl modules, but you can install modules into any directory you wish. For instance, where I say &lt;code&gt;perl Makefile.PL&lt;/code&gt; , you can substitute &lt;code&gt;perl Makefile.PL
PREFIX=/my/perl_directory&lt;/code&gt; to install the modules into</source>
          <target state="translated">还要注意，这些说明是为将模块安装到系统的Perl模块存储库中而量身定制的，但是您可以将模块安装到所需的任何目录中。例如，在我说 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 的地方，您可以替代 &lt;code&gt;perl Makefile.PL PREFIX=/my/perl_directory&lt;/code&gt; 来将模块安装到</target>
        </trans-unit>
        <trans-unit id="736913cda9c361fafb5f7987b822471b70893809" translate="yes" xml:space="preserve">
          <source>Also note that this does not (yet) work with all configurations, it is known to fail with 64-bit versions of GCC.</source>
          <target state="translated">另外要注意的是,并不是所有的配置都能使用,已知64位版本的GCC会失效。</target>
        </trans-unit>
        <trans-unit id="1ab79db4a65e3d1bcd26f59f38af2eeb810bbb25" translate="yes" xml:space="preserve">
          <source>Also note that under the current implementation, shared variables use a little more memory and are a little slower than ordinary variables.</source>
          <target state="translated">另外需要注意的是,在目前的实现下,共享变量使用的内存要比普通变量多一些,速度也要慢一些。</target>
        </trans-unit>
        <trans-unit id="df7301891c8738a820a79c945053b0568b895b92" translate="yes" xml:space="preserve">
          <source>Also note that whether enums are implicitly morphable to ints varies between compilers, you might need to (int).</source>
          <target state="translated">另外要注意的是,在不同的编译器中,枚举是否可以隐式地变形为ints是不同的,你可能需要(int)。</target>
        </trans-unit>
        <trans-unit id="971b7944044758dad02956ec65121b0bd485f6a2" translate="yes" xml:space="preserve">
          <source>Also note that while the order of the hash elements might be randomized, this &quot;pseudo-ordering&quot; should &lt;b&gt;not&lt;/b&gt; be used for applications like shuffling a list randomly (use &lt;code&gt;List::Util::shuffle()&lt;/code&gt; for that, see &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt;, a standard core module since Perl 5.8.0; or the CPAN module &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt; ), or for generating permutations (use e.g. the CPAN modules &lt;code&gt;Algorithm::Permute&lt;/code&gt; or &lt;code&gt;Algorithm::FastPermute&lt;/code&gt; ), or for any cryptographic applications.</source>
          <target state="translated">还要注意，尽管散列元素的顺序可能是随机的，但这种&amp;ldquo;伪顺序&amp;rdquo; &lt;b&gt;不&lt;/b&gt;应该用于随机混排列表之类的应用 &lt;code&gt;List::Util::shuffle()&lt;/code&gt; 为此，请使用List :: Util :: shuffle（），请参见&lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt;，自Perl 5.8.0起的标准核心模块；或CPAN模块 &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt; ），或用于生成置换（例如使用CPAN模块 &lt;code&gt;Algorithm::Permute&lt;/code&gt; 或 &lt;code&gt;Algorithm::FastPermute&lt;/code&gt; ），或用于任何加密应用程序。</target>
        </trans-unit>
        <trans-unit id="4516f893f396703a765e286979d300545dd3cb43" translate="yes" xml:space="preserve">
          <source>Also note that, for the superuser on the local filesystems, the &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-W&lt;/code&gt; tests always return 1, and &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a stat() to determine the actual mode of the file, or temporarily set their effective uid to something else.</source>
          <target state="translated">还要注意，对于本地文件系统上的超级用户， &lt;code&gt;-r&lt;/code&gt; ， &lt;code&gt;-R&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; 和 &lt;code&gt;-W&lt;/code&gt; 测试始终返回1，如果在模式下设置了执行位，则 &lt;code&gt;-x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 返回1。因此，由超级用户运行的脚本可能需要执行stat（）以确定文件的实际模式，或将其有效uid临时设置为其他内容。</target>
        </trans-unit>
        <trans-unit id="63277c7c7b95830e3556168d50e815433213b167" translate="yes" xml:space="preserve">
          <source>Also note that, for the superuser on the local filesystems, the &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-W&lt;/code&gt; tests always return 1, and &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a stat() to determine the actual mode of the file, or temporarily set their effective uid to something else.</source>
          <target state="translated">还要注意，对于本地文件系统上的超级用户， &lt;code&gt;-r&lt;/code&gt; ， &lt;code&gt;-R&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; 和 &lt;code&gt;-W&lt;/code&gt; 测试始终返回1，如果在模式下设置了执行位，则 &lt;code&gt;-x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 返回1。因此，由超级用户运行的脚本可能需要执行stat（）以确定文件的实际模式，或将其有效uid临时设置为其他内容。</target>
        </trans-unit>
        <trans-unit id="0d0223c3f3274398a55ed8725b06675a40efd8ef" translate="yes" xml:space="preserve">
          <source>Also note that:</source>
          <target state="translated">还注意到:</target>
        </trans-unit>
        <trans-unit id="87da44cc851ca2f3b8c127c8f7ddc08e6bd458e4" translate="yes" xml:space="preserve">
          <source>Also note, that because all ASCII characters are UTF-8 invariant (meaning they have the exact same representation (always a single byte) whether encoded in UTF-8 or not), &lt;code&gt;isASCII&lt;/code&gt; will give the correct results when called with any byte in any string encoded or not in UTF-8. And similarly &lt;code&gt;isASCII_utf8&lt;/code&gt; will work properly on any string encoded or not in UTF-8.</source>
          <target state="translated">还要注意，因为所有ASCII字符都是UTF-8不变的（意味着无论是否用UTF-8编码，它们都具有完全相同的表示形式（总是一个字节））， &lt;code&gt;isASCII&lt;/code&gt; 当以任意字节中的任何字节进行调用时，isASCII将给出正确的结果是否以UTF-8编码的字符串。同样， &lt;code&gt;isASCII_utf8&lt;/code&gt; 可以在UTF-8中编码或不编码的任何字符串上正常工作。</target>
        </trans-unit>
        <trans-unit id="523b244d1d9de0ba3f1938d9267c5634264d7182" translate="yes" xml:space="preserve">
          <source>Also notice that no matter what arguments you pass to perl_parse(), PERL_SYS_INIT3() must be invoked on the C main() argc, argv and env and only once.</source>
          <target state="translated">同时注意到,无论你传递给perl_parse()什么参数,PERL_SYS_INIT3()都必须在C语言的main()argc、argv和env上被调用,而且只能调用一次。</target>
        </trans-unit>
        <trans-unit id="e0b1e0d1886e4ff75f5ec5ef85846c4c02e181e1" translate="yes" xml:space="preserve">
          <source>Also of use is &lt;code&gt;File::Basename&lt;/code&gt; from the standard distribution, which splits a pathname into pieces (base filename, full path to directory, and file suffix).</source>
          <target state="translated">标准发行版中的 &lt;code&gt;File::Basename&lt;/code&gt; 也可以使用，它将路径名分为几部分（基本文件名，目录的完整路径和文件后缀）。</target>
        </trans-unit>
        <trans-unit id="5f72eee36e825db36f597f9decf9236b17c32472" translate="yes" xml:space="preserve">
          <source>Also parsed as terms are the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; constructs, as well as subroutine and method calls, and the anonymous constructors &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 构造，子例程和方法调用以及匿名构造函数 &lt;code&gt;[]&lt;/code&gt; 和 &lt;code&gt;{}&lt;/code&gt; 也被解析为术语。</target>
        </trans-unit>
        <trans-unit id="a2bae6f7ee0c691e590b07608d4c9653431dd798" translate="yes" xml:space="preserve">
          <source>Also read the &lt;a href=&quot;#DESCRIPTION&quot;&gt;DESCRIPTION&lt;/a&gt; section above, about how &lt;code&gt;Carp&lt;/code&gt; decides where the error is reported from.</source>
          <target state="translated">另请阅读上面的&lt;a href=&quot;#DESCRIPTION&quot;&gt;DESCRIPTION&lt;/a&gt;部分，有关 &lt;code&gt;Carp&lt;/code&gt; 如何确定从何处报告错误。</target>
        </trans-unit>
        <trans-unit id="8e594eb3334af2971f8b461e9ae7e0b95244811c" translate="yes" xml:space="preserve">
          <source>Also remember that &quot;|&quot; is interpreted as a literal within square brackets, so if you write &lt;code&gt;[fee|fie|foe]&lt;/code&gt; you're really only matching &lt;code&gt;[feio|]&lt;/code&gt; .</source>
          <target state="translated">还请记住，&amp;ldquo; |&amp;rdquo; 被解释为方括号内的文字，因此，如果您编写 &lt;code&gt;[fee|fie|foe]&lt;/code&gt; ，则实际上只匹配 &lt;code&gt;[feio|]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d930463c65b067a74fc5ff7d23d0ccb6261af74" translate="yes" xml:space="preserve">
          <source>Also remember that C doesn't allow you to safely say &lt;code&gt;foo(SvPV(s, len),
len);&lt;/code&gt;. It might work with your compiler, but it won't work for everyone. Break this sort of statement up into separate assignments:</source>
          <target state="translated">还请记住，C不允许您安全地说 &lt;code&gt;foo(SvPV(s, len), len);&lt;/code&gt; 。它可能与您的编译器一起使用，但不适用于所有人。将这种语句分解为单独的任务：</target>
        </trans-unit>
        <trans-unit id="f44fcd946ba2f23c70977904fbf45aba4b6fafca" translate="yes" xml:space="preserve">
          <source>Also remember that the &lt;code&gt;%p&lt;/code&gt; format really does require a void pointer:</source>
          <target state="translated">还请记住， &lt;code&gt;%p&lt;/code&gt; 格式确实确实需要一个void指针：</target>
        </trans-unit>
        <trans-unit id="058a190dd3d11e3f9bf93212c115f6265d98bac0" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; or &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;或&lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aa855f9ba4cde9a2842bd3fc97af3045ad2e00c0" translate="yes" xml:space="preserve">
          <source>Also see:</source>
          <target state="translated">另见:</target>
        </trans-unit>
        <trans-unit id="e8ab5cecbe34d47a3838306a541fd22a09e183f0" translate="yes" xml:space="preserve">
          <source>Also starting in v5.8.1, the &lt;code&gt;DATA&lt;/code&gt; pseudo-filehandle is translated from the encoding into UTF-8.</source>
          <target state="translated">同样从v5.8.1开始，将 &lt;code&gt;DATA&lt;/code&gt; 伪文件句柄从编码转换为UTF-8。</target>
        </trans-unit>
        <trans-unit id="ab76f7fb0dafb2fd9b645c8d2859052a429122ce" translate="yes" xml:space="preserve">
          <source>Also study &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; carefully to avoid any bad assumptions about the operating system, filesystems, character set, and so forth.</source>
          <target state="translated">还要仔细研究&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;，以避免对操作系统，文件系统，字符集等做出任何错误假设。</target>
        </trans-unit>
        <trans-unit id="330eeffd40ec44ea764cda155371e57d6de9d850" translate="yes" xml:space="preserve">
          <source>Also unchanged is the quoting of non-UTF-8 strings when outside the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; , which is to quote all characters in the upper Latin1 range. This provides complete backwards compatibility for old programs which do not use Unicode. (Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically enabled within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or greater.)</source>
          <target state="translated">当超出 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 的范围之外时，对非UTF-8字符串的引用也保持不变，该功能将引用Latin1较高范围内的所有字符。这为不使用Unicode的旧程序提供了完全的向后兼容性。（请注意， &lt;code&gt;unicode_strings&lt;/code&gt; 自动一个的范围内，使能 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; 或更大。）</target>
        </trans-unit>
        <trans-unit id="d897a47e8affb873fdb6ab1911f0d831b446c551" translate="yes" xml:space="preserve">
          <source>Also unchanged is the quoting of non-UTF-8 strings when outside the scope of a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; , which is to quote all characters in the upper Latin1 range. This provides complete backwards compatibility for old programs which do not use Unicode. (Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically enabled within the scope of a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or greater.)</source>
          <target state="translated">当超出 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 的范围之外时，对非UTF-8字符串的引用也保持不变，该功能将引用Latin1较高范围内的所有字符。这为不使用Unicode的旧程序提供了完全的向后兼容性。（请注意， &lt;code&gt;unicode_strings&lt;/code&gt; 自动一个的范围内，使能 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; 或更大。）</target>
        </trans-unit>
        <trans-unit id="77e4638580e542bd7efbc6ad1037c219e33a2a27" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;fileparse()&lt;/code&gt; , &lt;code&gt;dirname()&lt;/code&gt; does not include a trailing slash on its returned path.</source>
          <target state="translated">也不同于 &lt;code&gt;fileparse()&lt;/code&gt; ， &lt;code&gt;dirname()&lt;/code&gt; 在其返回的路径上不包含尾部斜杠。</target>
        </trans-unit>
        <trans-unit id="3cf4e79f0d2cc479a41a6179c877f4a73d453199" translate="yes" xml:space="preserve">
          <source>Also when working on Perl programs on VMS, if you need a syntax in a specific operating system format, then you need either to check the appropriate DECC$ feature logical, or call a conversion routine to force it to that format.</source>
          <target state="translated">另外,在VMS上处理Perl程序时,如果你需要一个特定操作系统格式的语法,那么你需要检查相应的DECC$特征逻辑,或者调用一个转换例程来强制转换成该格式。</target>
        </trans-unit>
        <trans-unit id="b4a91fa72735b293f0702212cc8b8ff7dd3fc1bc" translate="yes" xml:space="preserve">
          <source>Also you have to be careful when using &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a value in AVs or HVs (see &lt;a href=&quot;#AVs%2c-HVs-and-undefined-values&quot;&gt;AVs, HVs and undefined values&lt;/a&gt;).</source>
          <target state="translated">另外，在AV或HV &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 用作值时，请务必小心（请参阅&lt;a href=&quot;#AVs%2c-HVs-and-undefined-values&quot;&gt;AV，HV和未定义的值&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="88b9515cdbcd45bb30a5ed0507a9f79663403c03" translate="yes" xml:space="preserve">
          <source>Also, &lt;b&gt;in Perl 5.8.x and earlier&lt;/b&gt;, this pragma uses pseudo-hashes, the effect being that you can have objects with named fields which are as compact and as fast arrays to access, as long as the objects are accessed through properly typed variables.</source>
          <target state="translated">另外，&lt;b&gt;在Perl 5.8.x及更早版本中&lt;/b&gt;，此杂注使用伪哈希，其结果是，只要具有通过适当类型变量访问的命名字段，就可以使对象具有紧凑而又快速的数组访问。</target>
        </trans-unit>
        <trans-unit id="67b0ddab77dcdca452f298cae2c04c86ed3d38be" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; yields &lt;code&gt; chr(28) . &quot;&lt;i&gt;X&lt;/i&gt;&quot;&lt;/code&gt; for any</source>
          <target state="translated">同样， &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 产生 &lt;code&gt; chr(28) . &quot;&lt;i&gt;X&lt;/i&gt;&quot;&lt;/code&gt; 代表任何</target>
        </trans-unit>
        <trans-unit id="d7b7987422ffa4fcf0f2ef8eb8b0440e2263954b" translate="yes" xml:space="preserve">
          <source>Also, Case_Folding is accessible through the &lt;code&gt;/i&lt;/code&gt; modifier in regular expressions, the &lt;code&gt;\F&lt;/code&gt; transliteration escape, and the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">同样，可以通过 &lt;code&gt;/i&lt;/code&gt; 修饰符在正则表达式， &lt;code&gt;\F&lt;/code&gt; 音译转义符和 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 运算符中访问Case_Folding 。</target>
        </trans-unit>
        <trans-unit id="329290910e0fbb3b491e01928584618de2f21b4e" translate="yes" xml:space="preserve">
          <source>Also, Configure might abort with</source>
          <target state="translated">另外,配置可能会以</target>
        </trans-unit>
        <trans-unit id="1e804a10723cc82e329f560a2f2a4e122d8ad225" translate="yes" xml:space="preserve">
          <source>Also, a backslash followed by two or three octal digits is considered an octal number.</source>
          <target state="translated">另外,反斜杠后面的两个或三个八进制数字也被认为是一个八进制数字。</target>
        </trans-unit>
        <trans-unit id="6cc421c7386da7b14eefaf275d4a113f5c542cb3" translate="yes" xml:space="preserve">
          <source>Also, both these methods currently allow only single characters to be named. To name a sequence of characters, use a &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;custom translator&lt;/a&gt; (described below).</source>
          <target state="translated">同样，这两种方法当前都只允许命名单个字符。要命名字符序列，请使用&lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;自定义翻译器&lt;/a&gt;（如下所述）。</target>
        </trans-unit>
        <trans-unit id="0b19a92a5a63a3defc0247ff7123f75e1b423945" translate="yes" xml:space="preserve">
          <source>Also, calling &amp;amp;$coderef($lh, ...parameters...) can throw any sort of exception (if, say, code in that sub tries to divide by zero). But a very common exception occurs when you have Bracket Notation text that says to call a method &quot;foo&quot;, but there is no such method. (E.g., &quot;You have [qua&lt;b&gt;tn&lt;/b&gt;,_1,ball].&quot; will throw an exception on trying to call $lh-&amp;gt;qua&lt;b&gt;tn&lt;/b&gt;($_[1],'ball') -- you presumably meant &quot;quant&quot;.) &lt;code&gt;maketext&lt;/code&gt; catches these exceptions, but only to make the error message more readable, at which point it rethrows the exception.</source>
          <target state="translated">同样，调用＆$ coderef（$ lh，... parameters ...）可以引发任何形式的异常（例如，如果该子级中的代码试图除以零）。但是，当您有用括号括起来的文字说要调用方法&amp;ldquo; foo&amp;rdquo;时，会发生一个非常常见的异常，但是没有这样的方法。 （例如，&amp;ldquo;您有[qua &lt;b&gt;tn&lt;/b&gt;，_1，ball]。&amp;rdquo;将在尝试调用$ lh-&amp;gt; qua &lt;b&gt;tn&lt;/b&gt;（$ _ [1]，'ball' 时引发异常）-您大概是指&amp;ldquo; quant&amp;rdquo;。 ） &lt;code&gt;maketext&lt;/code&gt; 捕获这些异常，但只是使错误消息更具可读性，这时它将抛出异常。</target>
        </trans-unit>
        <trans-unit id="bd6593efc170267903ffe758130a7c9bc58d5233" translate="yes" xml:space="preserve">
          <source>Also, entries like</source>
          <target state="translated">此外,像这样的条目</target>
        </trans-unit>
        <trans-unit id="74a420b208a6c382bb28f75840a5f1acef599188" translate="yes" xml:space="preserve">
          <source>Also, every C program that uses Perl must link in the</source>
          <target state="translated">另外,每个使用Perl的C程序都必须在</target>
        </trans-unit>
        <trans-unit id="34500a88731ba3291ee1333607a6b7ca5f090a54" translate="yes" xml:space="preserve">
          <source>Also, feel free to play with experimental features. Run</source>
          <target state="translated">另外,可以自由发挥实验功能。运行</target>
        </trans-unit>
        <trans-unit id="7b8f99a26ea97ae4edab854723c19d8a2e3a7a2e" translate="yes" xml:space="preserve">
          <source>Also, for a somewhat finer-grained set of characters that are in programming language identifiers beyond the ASCII range, you may wish to instead use the more customized &lt;a href=&quot;#Unicode-Properties&quot;&gt;Unicode Properties&lt;/a&gt;, &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{ID_Continue}&lt;/code&gt; , &lt;code&gt;\p{XID_Start}&lt;/code&gt; , and &lt;code&gt;\p{XID_Continue}&lt;/code&gt; . See &lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31&lt;/a&gt;.</source>
          <target state="translated">另外，对于超出ASCII范围的编程语言标识符中的一组较细粒度​​的字符，您可能希望使用更自定义的&lt;a href=&quot;#Unicode-Properties&quot;&gt;Unicode属性&lt;/a&gt;， &lt;code&gt;\p{ID_Start}&lt;/code&gt; ， &lt;code&gt;\p{ID_Continue}&lt;/code&gt; ， &lt;code&gt;\p{XID_Start}&lt;/code&gt; 和 &lt;code&gt;\p{XID_Continue}&lt;/code&gt; 。参见&lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ccef320717b4d17e6eccfe71944895dfdb94c8a6" translate="yes" xml:space="preserve">
          <source>Also, having valid values as keys becomes very useful if you set up an _AUTO lexicon. _AUTO lexicons are discussed in a later section.</source>
          <target state="translated">另外,如果你设置了一个_AUTO词典,那么将有效值作为键就变得非常有用。_AUTO词典将在后面的章节中讨论。</target>
        </trans-unit>
        <trans-unit id="57c4e07e0cc219d38dd06e6e1bcf0b1ea8e52540" translate="yes" xml:space="preserve">
          <source>Also, if the SV passed to &lt;code&gt;mg_find&lt;/code&gt; or &lt;code&gt;mg_findext&lt;/code&gt; is not of type SVt_PVMG, Perl may core dump.</source>
          <target state="translated">另外，如果传递给 &lt;code&gt;mg_find&lt;/code&gt; 或 &lt;code&gt;mg_findext&lt;/code&gt; 的SV 不是SVt_PVMG类型，则Perl可能会进行核心转储。</target>
        </trans-unit>
        <trans-unit id="a715fbfabba33c1ab0f07edc90c111741da66e2f" translate="yes" xml:space="preserve">
          <source>Also, in binary properties, 'Yes', 'T', and 'True' are all synonyms for 'Y'. And 'No', 'F', and 'False' are all synonyms for 'N'. The table shows 'Y*' and 'N*' to indicate this, and doesn't have separate entries for the other possibilities. Note that not all properties which have values 'Yes' and 'No' are binary, and they have all their values spelled out without using this wild card, and a &lt;code&gt;NOT&lt;/code&gt; clause in their description that highlights their not being binary. These also require the compound form to match them, whereas true binary properties have both single and compound forms available.</source>
          <target state="translated">同样，在二进制属性中，&amp;ldquo; Yes&amp;rdquo;，&amp;ldquo; T&amp;rdquo;和&amp;ldquo; True&amp;rdquo;都是&amp;ldquo; Y&amp;rdquo;的同义词。 &amp;ldquo;否&amp;rdquo;，&amp;ldquo; F&amp;rdquo;和&amp;ldquo;假&amp;rdquo;都是&amp;ldquo; N&amp;rdquo;的同义词。该表显示了&amp;ldquo; Y *&amp;rdquo;和&amp;ldquo; N *&amp;rdquo;来表示这一点，而没有其他可能的单独条目。请注意，并非所有具有值&amp;ldquo;是&amp;rdquo;和&amp;ldquo;否&amp;rdquo;的属性都是二进制的，并且在不使用此通配符的情况下也将其所有值拼写了出来，并且在其说明中突出显示了它们不是二进制的 &lt;code&gt;NOT&lt;/code&gt; 子句。这些还要求化合物形式与之匹配，而真正的二元性质同时具有单一形式和化合物形式。</target>
        </trans-unit>
        <trans-unit id="a00a976f777c7c9555d5a4f1c975df6f1666beb4" translate="yes" xml:space="preserve">
          <source>Also, in the context of &lt;b&gt;Unicode&lt;/b&gt;, a writing system for a particular language or group of languages, such as Greek, Bengali, or Tengwar.</source>
          <target state="translated">同样，在&lt;b&gt;Unicode&lt;/b&gt;的上下文中，是用于特定语言或一组语言（例如希腊语，孟加拉语或Tengwar）的书写系统。</target>
        </trans-unit>
        <trans-unit id="d74824efd3c4979bad6a6f8c4e477bf4cb023fd4" translate="yes" xml:space="preserve">
          <source>Also, it's worth noting that patterns defined this way probably will not be as efficient, as the optimizer is not very clever about handling them.</source>
          <target state="translated">另外,值得注意的是,这样定义的模式可能不会有那么高的效率,因为优化器对它们的处理不是很聪明。</target>
        </trans-unit>
        <trans-unit id="487cc7057b2c00a1fbc251ce9c403787bcbb592b" translate="yes" xml:space="preserve">
          <source>Also, lines should not be split within &lt;code&gt;CRLF&lt;/code&gt; (i.e. there is no empty line between &lt;code&gt;\r&lt;/code&gt; and &lt;code&gt;\n&lt;/code&gt; ). For &lt;code&gt;CRLF&lt;/code&gt; , try the &lt;code&gt;:crlf&lt;/code&gt; layer (see &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;).</source>
          <target state="translated">另外，不应在 &lt;code&gt;CRLF&lt;/code&gt; 中分割行（即 &lt;code&gt;\r&lt;/code&gt; 和 &lt;code&gt;\n&lt;/code&gt; 之间没有空行）。对于 &lt;code&gt;CRLF&lt;/code&gt; ，请尝试 &lt;code&gt;:crlf&lt;/code&gt; &lt;a href=&quot;perlio&quot;&gt;crlf&lt;/a&gt;层（请参见PerlIO）。</target>
        </trans-unit>
        <trans-unit id="63323aa4e4ec3045e43bf822a9f6601fadcf053b" translate="yes" xml:space="preserve">
          <source>Also, negative signal values don't do anything special under VMS; they're just converted to the corresponding positive value.</source>
          <target state="translated">另外,负信号值在VMS下并没有什么特别的作用,只是转换为相应的正值。</target>
        </trans-unit>
        <trans-unit id="6a350d1c09fc9665a8e389e53064c822190440b0" translate="yes" xml:space="preserve">
          <source>Also, note that using the file tests for security purposes is a lost cause from the start: there is a window open for race conditions (who is to say that the permissions will not change between the test and the real operation?). Therefore if you are serious about security, just try the real operation and test for its success - think in terms of atomic operations. Filetests are more useful for filesystem administrative tasks, when you have no need for the content of the elements on disk.</source>
          <target state="translated">另外,请注意,为了安全而使用文件测试从一开始就失去了意义:有一个为竞赛条件打开的窗口(谁能说测试和真实操作之间的权限不会改变?)。因此,如果你对安全问题很重视,只需尝试真正的操作,并测试其成功与否--从原子操作的角度考虑。Filetests对于文件系统管理任务更有用,当你不需要磁盘上元素的内容时。</target>
        </trans-unit>
        <trans-unit id="d574d865815009daf05f1054bf415b0bf6943266" translate="yes" xml:space="preserve">
          <source>Also, note the following:</source>
          <target state="translated">另外,还要注意以下几点:</target>
        </trans-unit>
        <trans-unit id="48ddb81f1627e1f3a6389ef3f6f1aa66ba367e47" translate="yes" xml:space="preserve">
          <source>Also, once a project is otherwise complete and you start to localize it, you can scrape together all the various keys you use, and pass it to a translator; and then the translator's work will go faster if what he's presented is this:</source>
          <target state="translated">另外,当一个项目在其他方面完成后,你开始进行本地化,你可以把你使用的各种键都拼凑起来,然后交给翻译人员;然后如果他所呈现的是这个样子,那么翻译人员的工作会更快。</target>
        </trans-unit>
        <trans-unit id="25de230710079ae2e7ac75bdcf59f8719d1c3ed7" translate="yes" xml:space="preserve">
          <source>Also, perl can be recompiled to operate on an earlier version of the Unicode standard. Further information is at &lt;code&gt;$Config{privlib}&lt;/code&gt; /</source>
          <target state="translated">同样，可以将perl重新编译为在Unicode标准的早期版本上运行。有关更多信息，请 &lt;code&gt;$Config{privlib}&lt;/code&gt; /</target>
        </trans-unit>
        <trans-unit id="76997e16af65c741ca3a61aadd72db51de092e73" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;$x&lt;/code&gt; is lexical, it can't be reached or modified by any Perl code outside.</source>
          <target state="translated">同样，由于 &lt;code&gt;$x&lt;/code&gt; 是词法，因此外部的任何Perl代码都无法达到或修改它。</target>
        </trans-unit>
        <trans-unit id="38f33518e3f4f0a218000c4a9eb29242c2ff03c6" translate="yes" xml:space="preserve">
          <source>Also, since the number of opcodes in your current version of perl might not be an exact multiple of eight, there may be unused bits in the last byte of an upset. This should not cause any problems (Opcode functions ignore those extra bits) but it does mean that using the ~ operator will typically not produce the same 'physical' opset 'string' as the invert_opset function.</source>
          <target state="translated">另外,由于您当前版本的 perl 中 opcode 的数量可能不是 8 的精确倍数,所以在 upset 的最后一个字节中可能有未使用的位。这应该不会引起任何问题(Opcode函数会忽略这些额外的位),但这意味着使用~操作符通常不会产生与invert_opset函数相同的 &quot;物理 &quot;opset &quot;字符串&quot;。</target>
        </trans-unit>
        <trans-unit id="3ed7ac3c49479a3dd530e1364bfdfcfdef42d4e9" translate="yes" xml:space="preserve">
          <source>Also, some common socket &quot;newline&quot; constants are provided: the constants &lt;code&gt;CR&lt;/code&gt; , &lt;code&gt;LF&lt;/code&gt; , and &lt;code&gt;CRLF&lt;/code&gt; , as well as &lt;code&gt;$CR&lt;/code&gt; , &lt;code&gt;$LF&lt;/code&gt; , and &lt;code&gt;$CRLF&lt;/code&gt; , which map to &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; , and &lt;code&gt;\015\012&lt;/code&gt; . If you do not want to use the literal characters in your programs, then use the constants provided here. They are not exported by default, but can be imported individually, and with the &lt;code&gt;:crlf&lt;/code&gt; export tag:</source>
          <target state="translated">另外，还提供了一些常见的套接字&amp;ldquo; newline&amp;rdquo;常量：常量 &lt;code&gt;CR&lt;/code&gt; ， &lt;code&gt;LF&lt;/code&gt; 和 &lt;code&gt;CRLF&lt;/code&gt; 以及 &lt;code&gt;$CR&lt;/code&gt; ， &lt;code&gt;$LF&lt;/code&gt; 和 &lt;code&gt;$CRLF&lt;/code&gt; ，它们映射到 &lt;code&gt;\015&lt;/code&gt; ， &lt;code&gt;\012&lt;/code&gt; 和 &lt;code&gt;\015\012&lt;/code&gt; 。如果不想在程序中使用文字字符，请使用此处提供的常量。它们默认情况下不会导出，但是可以使用 &lt;code&gt;:crlf&lt;/code&gt; export标签单独导入：</target>
        </trans-unit>
        <trans-unit id="13c4a82fda1ed827381af159c98e8fcbdf05900b" translate="yes" xml:space="preserve">
          <source>Also, some special instructions for building Perl with Sun Studio on Linux. Following the normal &lt;code&gt;Configure&lt;/code&gt; , you have to run make as follows:</source>
          <target state="translated">另外，有关在Linux上使用Sun Studio构建Perl的一些特殊说明。按照正常的 &lt;code&gt;Configure&lt;/code&gt; ，您必须运行make，如下所示：</target>
        </trans-unit>
        <trans-unit id="430b83395a22758023df144cbbf527affef6a44c" translate="yes" xml:space="preserve">
          <source>Also, subroutines could be declared with the &lt;code&gt;:locked&lt;/code&gt; attribute which would serialize access to the subroutine, but allowed different threads non-simultaneous access.</source>
          <target state="translated">同样，可以使用 &lt;code&gt;:locked&lt;/code&gt; 属性声明子例程，该属性将序列化对该子例程的访问，但允许不同的线程非同时访问。</target>
        </trans-unit>
        <trans-unit id="cdb14deb83dae5ba493a96acfadaf1236cbdc5ea" translate="yes" xml:space="preserve">
          <source>Also, the object is configured such that it stringifies to the name of the temporary file and so can be compared to a filename directly. It numifies to the C</source>
          <target state="translated">此外,该对象被配置为字符串化到临时文件的名称,因此可以直接与文件名进行比较。它被命名为C</target>
        </trans-unit>
        <trans-unit id="ad7807da341a2e1187eef533ebec80cd0117d203" translate="yes" xml:space="preserve">
          <source>Also, the range 'A' - 'Z' in ASCII is an unbroken sequence of 26 upper case alphabetic characters. That is not true in EBCDIC. Nor for 'a' to 'z'. But '0' - '9' is an unbroken range in both systems. Don't assume anything about other ranges. (Note that special handling of ranges in regular expression patterns makes it appear to Perl code that the aforementioned ranges are all unbroken.)</source>
          <target state="translated">此外,ASCII中的'A'-'Z'范围是一个由26个大写字母组成的不间断序列。而在EBCDIC中却不是这样。对于'a'到'z'也是如此。但是'0'-'9'在两个系统中都是一个不间断的范围。不要对其他范围做任何假设。(注意,正则表达式模式中对范围的特殊处理,使得 Perl 代码认为上述范围都是不间断的。)</target>
        </trans-unit>
        <trans-unit id="11e213d7b8a81bd451ffb3f3ae8fa862e904a6c3" translate="yes" xml:space="preserve">
          <source>Also, the use of Unicode may present security issues that aren't obvious. Read &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;Unicode Security Considerations&lt;/a&gt;.</source>
          <target state="translated">另外，使用Unicode可能会带来不明显的安全问题。阅读&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;Unicode安全注意事项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a6ddd5f6cea51490776d1ee7aa46674933e080d" translate="yes" xml:space="preserve">
          <source>Also, under this modifier, case-insensitive matching works on the full set of Unicode characters. The &lt;code&gt;KELVIN SIGN&lt;/code&gt; , for example matches the letters &quot;k&quot; and &quot;K&quot;; and &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; matches the sequence &quot;ff&quot;, which, if you're not prepared, might make it look like a hexadecimal constant, presenting another potential security issue. See &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt; for a detailed discussion of Unicode security issues.</source>
          <target state="translated">另外，在此修饰符下，不区分大小写的匹配适用于整套Unicode字符。所述 &lt;code&gt;KELVIN SIGN&lt;/code&gt; ，例如匹配的字母&amp;ldquo;k&amp;rdquo;和&amp;ldquo;K&amp;rdquo;; 和&amp;ldquo; &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; 匹配序列&amp;ldquo; ff&amp;rdquo;，如果您不准备使用它，则可能会使它看起来像一个十六进制常量，从而带来了另一个潜在的安全问题。有关Unicode安全问题的详细讨论，请参见&lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d458ad7a020a232313ae8d56db7bcab0ded5305" translate="yes" xml:space="preserve">
          <source>Also, various synonyms like &lt;code&gt;\p{Alpha}&lt;/code&gt; for &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; ; all listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;</source>
          <target state="translated">并且，各种同义词像 &lt;code&gt;\p{Alpha}&lt;/code&gt; 为 &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; ; &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;在perluniprops中可通过\ p {}和\ P {}访问的属性中&lt;/a&gt;列出的所有属性</target>
        </trans-unit>
        <trans-unit id="3fd51e4e1d10037d178287b3c2e52d39f31c50f2" translate="yes" xml:space="preserve">
          <source>Also, when your</source>
          <target state="translated">另外,当你的</target>
        </trans-unit>
        <trans-unit id="94df63c3696c6e9f216a0b26ed643a62ffdfe44b" translate="yes" xml:space="preserve">
          <source>Also, white space, hyphens, and underscores are normally ignored everywhere between the {braces}, and hence can be freely added or removed even if the &lt;code&gt;/x&lt;/code&gt; modifier hasn't been specified on the regular expression. But in the table below a '&lt;b&gt;T&lt;/b&gt;' at the beginning of an entry means that tighter (stricter) rules are used for that entry:</source>
          <target state="translated">同样，空格，连字符和下划线通常在{花括号}之间的所有位置都被忽略，因此即使未在正则表达式上指定 &lt;code&gt;/x&lt;/code&gt; 修饰符，也可以自由添加或删除空格。但是在下表中，条目开头的&amp;ldquo; &lt;b&gt;T&lt;/b&gt; &amp;rdquo;表示该条目使用了更严格的（严格的）规则：</target>
        </trans-unit>
        <trans-unit id="87ea7db4a430030d90185495584807fc225cd906" translate="yes" xml:space="preserve">
          <source>Also:</source>
          <target state="translated">Also:</target>
        </trans-unit>
        <trans-unit id="554a943cef6b1565f2a13a13d21f280b671c0db6" translate="yes" xml:space="preserve">
          <source>Alter regular expression behaviour</source>
          <target state="translated">改变正则表达式行为</target>
        </trans-unit>
        <trans-unit id="4b26f888988c3f23411577d380346f5e87008e97" translate="yes" xml:space="preserve">
          <source>Alternate Stack Manipulation</source>
          <target state="translated">替代堆栈操作</target>
        </trans-unit>
        <trans-unit id="fd038ee8b646edddd400b75f62f9db870f503cd5" translate="yes" xml:space="preserve">
          <source>Alternately, if you have an SV that is a blessed reference, you can find out the stash pointer by using:</source>
          <target state="translated">另外,如果你有一个SV是一个祝福的参考,你可以通过使用来找出匿迹指针。</target>
        </trans-unit>
        <trans-unit id="6589e5a8ee283a61027f2499ac81f9bd22f55b5a" translate="yes" xml:space="preserve">
          <source>Alternately, if you import &lt;code&gt;:constants&lt;/code&gt; , you can use the following constants directly:</source>
          <target state="translated">或者，如果导入 &lt;code&gt;:constants&lt;/code&gt; ，则可以直接使用以下常量：</target>
        </trans-unit>
        <trans-unit id="3835ce5fac7a47f4550c37daaf24821ea36a9658" translate="yes" xml:space="preserve">
          <source>Alternately, if you use OS/2-ish shell, like CMD or 4os2, put the following at the start of your perl script:</source>
          <target state="translated">或者,如果你使用OS/2的shell,比如CMD或4os2,在你的perl脚本的开头加上以下内容。</target>
        </trans-unit>
        <trans-unit id="3c02b30c04d1bd2e064bba714a6c966f7e7001cc" translate="yes" xml:space="preserve">
          <source>Alternately, try running pod2text on</source>
          <target state="translated">或者,尝试在</target>
        </trans-unit>
        <trans-unit id="c6586bf995507ef47c1e8462c0b96f9bda48432b" translate="yes" xml:space="preserve">
          <source>Alternately, you can change to binary mode on an existing handle this way:</source>
          <target state="translated">另外,你也可以通过这种方式在现有的句柄上切换到二进制模式。</target>
        </trans-unit>
        <trans-unit id="436c604fc9e91f4036987513f30ceb0b117df526" translate="yes" xml:space="preserve">
          <source>Alternately, you can set the global variable &lt;code&gt;$Carp::Verbose&lt;/code&gt; to true. See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section below.</source>
          <target state="translated">或者，您可以将全局变量 &lt;code&gt;$Carp::Verbose&lt;/code&gt; 为true。请参阅下面的&amp;ldquo; &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="15f2c59a8b9b5baf596fabaf5af782241acbedb6" translate="yes" xml:space="preserve">
          <source>Alternately, you can specify the exact directory to place the extension's files by placing a &quot;PREFIX=/destination/directory&quot; after the make install (or in between the make and install if you have a brain-dead version of make). This can be very useful if you are building an extension that will eventually be distributed to multiple systems. You can then just archive the files in the destination directory and distribute them to your destination systems.</source>
          <target state="translated">另外,你也可以在make安装后放置 &quot;PREFIX=/destination/directory&quot;(如果你有一个脑残版的make,则在make和安装之间),来指定放置扩展文件的确切目录。如果你正在构建一个最终将被分发到多个系统的扩展,这可能非常有用。然后,你可以只将文件归档到目标目录中,然后将它们分发到你的目标系统。</target>
        </trans-unit>
        <trans-unit id="e00c3a1ce8b9e2b0c7ee0051f3ec0d7cf8bcbdb9" translate="yes" xml:space="preserve">
          <source>Alternately, you can try to get a replacement for the system's &lt;b&gt;Execute&lt;/b&gt; command that honors the #!/usr/bin/perl syntax in scripts and set the s-Bit of your scripts. Then you can invoke your scripts like under UNIX with</source>
          <target state="translated">或者，您可以尝试替换使用脚本中＃！/ usr / bin / perl语法的系统&lt;b&gt;Execute&lt;/b&gt;命令，并设置脚本的s-Bit。然后，您可以像在UNIX下使用</target>
        </trans-unit>
        <trans-unit id="70b8f05f7796eca9b3373c7ecd058a653ad0409c" translate="yes" xml:space="preserve">
          <source>Alternately, you can use &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, the regular expression quote operator (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details). It quotes and perhaps compiles the pattern, and you can apply regular expression flags to the pattern.</source>
          <target state="translated">或者，您可以使用正则表达式引用运算符 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; （有关更多详细信息，请参见&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;）。它引用并可能编译该模式，并且您可以将正则表达式标志应用于该模式。</target>
        </trans-unit>
        <trans-unit id="5b04c7a5831dedb851aed975f051c1cac400682e" translate="yes" xml:space="preserve">
          <source>Alternation</source>
          <target state="translated">Alternation</target>
        </trans-unit>
        <trans-unit id="be9a6aa6691045b50a599c27892a7efaa458c7af" translate="yes" xml:space="preserve">
          <source>Alternation allows a regexp to choose among alternatives, but by itself it is unsatisfying. The reason is that each alternative is a whole regexp, but sometime we want alternatives for just part of a regexp. For instance, suppose we want to search for housecats or housekeepers. The regexp &lt;code&gt;housecat|housekeeper&lt;/code&gt; fits the bill, but is inefficient because we had to type &lt;code&gt;house&lt;/code&gt; twice. It would be nice to have parts of the regexp be constant, like &lt;code&gt;house&lt;/code&gt; , and some parts have alternatives, like &lt;code&gt;cat|keeper&lt;/code&gt; .</source>
          <target state="translated">交替允许正则表达式在其他选择中进行选择，但其本身并不令人满意。原因是每个替代都是一个完整的正则表达式，但是有时我们只希望部分正则表达式具有替代。例如，假设我们要搜索家猫或管家。正则表达式 &lt;code&gt;housecat|housekeeper&lt;/code&gt; 很适合帐单，但效率低下，因为我们不得不两次键入 &lt;code&gt;house&lt;/code&gt; 。最好将正则表达式的某些部分保持不变，例如 &lt;code&gt;house&lt;/code&gt; ，而另一些部分具有替代项，例如 &lt;code&gt;cat|keeper&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cf43ccde7eeaee521a4a189652a63c1baacf5e0" translate="yes" xml:space="preserve">
          <source>Alternations behave the same way in groups as out of them: at a given string position, the leftmost alternative that allows the regexp to match is taken. So in the last example at the first string position, &lt;code&gt;&quot;20&quot;&lt;/code&gt; matches the second alternative, but there is nothing left over to match the next two digits &lt;code&gt;\d\d&lt;/code&gt; . So Perl moves on to the next alternative, which is the null alternative and that works, since &lt;code&gt;&quot;20&quot;&lt;/code&gt; is two digits.</source>
          <target state="translated">分组中的替代行为与分组中的替代行为相同：在给定的字符串位置，采用允许regexp匹配的最左侧替代。因此，在最后一个示例中，在第一个字符串位置处， &lt;code&gt;&quot;20&quot;&lt;/code&gt; 与第二个替代项匹配，但是没有剩余的内容与后两位 &lt;code&gt;\d\d&lt;/code&gt; 匹配。因此Perl转到下一个替代方案，它是null替代方案，并且可以工作，因为 &lt;code&gt;&quot;20&quot;&lt;/code&gt; 是两位数。</target>
        </trans-unit>
        <trans-unit id="92135acee6fb42da0402ddedc5b8263e8afa69de" translate="yes" xml:space="preserve">
          <source>Alternative capture group numbering</source>
          <target state="translated">替代的捕获组编号</target>
        </trans-unit>
        <trans-unit id="79c07200d4699b036f2138680fade3c9689f7058" translate="yes" xml:space="preserve">
          <source>Alternative math libraries</source>
          <target state="translated">其他数学库</target>
        </trans-unit>
        <trans-unit id="6aa5c766a08c26061e42a91b28e7696a27f14067" translate="yes" xml:space="preserve">
          <source>Alternative option starters</source>
          <target state="translated">备选方案启动器</target>
        </trans-unit>
        <trans-unit id="443fe46b83982a5185e410eceac3b7185f7ae257" translate="yes" xml:space="preserve">
          <source>Alternative to Test::More::use_ok</source>
          <target state="translated">Test::More::use_ok替代方案</target>
        </trans-unit>
        <trans-unit id="c7461a3c1c3204afbbfd69dbbccd1e2b59471f99" translate="yes" xml:space="preserve">
          <source>Alternative warn and die for modules</source>
          <target state="translated">模块的替代警告和死亡</target>
        </trans-unit>
        <trans-unit id="12e5972b55b252c3c9bc2d82985850d79c96249e" translate="yes" xml:space="preserve">
          <source>Alternatively edit the init file interactively via: 3rd mouse button -&amp;gt; New Display -&amp;gt; Edit Menu</source>
          <target state="translated">或者，通过以下方式交互式编辑初始化文件：第三个鼠标按钮-&amp;gt;新显示-&amp;gt;编辑菜单</target>
        </trans-unit>
        <trans-unit id="44c86b27ab468eef89d417477ce09eb4480abfb2" translate="yes" xml:space="preserve">
          <source>Alternatively look here: &lt;a href=&quot;http://www.unix.com/man-page/FreeBSD/3/strftime/&quot;&gt;http://www.unix.com/man-page/FreeBSD/3/strftime/&lt;/a&gt;</source>
          <target state="translated">或者在这里查看：&lt;a href=&quot;http://www.unix.com/man-page/FreeBSD/3/strftime/&quot;&gt;http&lt;/a&gt; : //www.unix.com/man-page/FreeBSD/3/strftime/</target>
        </trans-unit>
        <trans-unit id="5d17661d2312f06dcd6c1a5156f20af2512c469b" translate="yes" xml:space="preserve">
          <source>Alternatively the list of subfields can by supplied as a scalar, thus</source>
          <target state="translated">另外,子字段列表也可以以标量形式提供,因此</target>
        </trans-unit>
        <trans-unit id="0e3d4d311210785c85520063de48eeff7de6af69" translate="yes" xml:space="preserve">
          <source>Alternatively you can use the compiler directive our() to bring a dynamic variable into the current lexical scope.</source>
          <target state="translated">另外,你也可以使用编译器指令our()将一个动态变量带入当前的词法范围。</target>
        </trans-unit>
        <trans-unit id="2cec5cf8bbfadcf33f7e5849e13d536e2c1766e0" translate="yes" xml:space="preserve">
          <source>Alternatively you can use:</source>
          <target state="translated">或者你可以使用:</target>
        </trans-unit>
        <trans-unit id="43f0cea439a0fe2f49f0e9b79ff517dcdbec8d84" translate="yes" xml:space="preserve">
          <source>Alternatively you may be able to get these docs prebuilt from &lt;code&gt;CPAN&lt;/code&gt; .</source>
          <target state="translated">另外，您也许可以从 &lt;code&gt;CPAN&lt;/code&gt; 预先构建这些文档。</target>
        </trans-unit>
        <trans-unit id="f7f7013a74aa2034d027da86e6edefa6ad1f3b65" translate="yes" xml:space="preserve">
          <source>Alternatively you may be able to get these docs prebuilt from CPAN.</source>
          <target state="translated">另外,你也可以从CPAN获得这些预建文档。</target>
        </trans-unit>
        <trans-unit id="06dab9dc9469b67b9f013b1f7d978b8fd09b7e74" translate="yes" xml:space="preserve">
          <source>Alternatively, Berkeley DB version 1 is available at your nearest CPAN archive in</source>
          <target state="translated">另外,您也可以在离您最近的CPAN档案馆里找到Berkeley DB 1版本。</target>
        </trans-unit>
        <trans-unit id="18aa5e8fea6653b702c48738f98b3e8db633fcaf" translate="yes" xml:space="preserve">
          <source>Alternatively, an array reference of section specifications can be used:</source>
          <target state="translated">另外,也可以使用章节规格的数组引用。</target>
        </trans-unit>
        <trans-unit id="89c6743b65649f02ac7d006f9c75c999b8c0f7a0" translate="yes" xml:space="preserve">
          <source>Alternatively, as of version 2.24, the configuration options may be passed together with the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement:</source>
          <target state="translated">或者，从版本2.24开始，可以将配置选项与 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句一起传递：</target>
        </trans-unit>
        <trans-unit id="e9aa6c54c04158a408f2c0b76a7a51f158187ce5" translate="yes" xml:space="preserve">
          <source>Alternatively, if you don't need perlglob.exe and don't need to enable the USE_SETARGV option then you can safely just remove all mention of $(GLOBEXE) from win32/Makefile and setargv.obj won't be required anyway.</source>
          <target state="translated">另外,如果您不需要 perlglob.exe,也不需要启用 USE_SETARGV 选项,您可以从 win32/Makefile 中删除所有提及 $(GLOBEXE)的内容,而 setargv.obj 则不需要。</target>
        </trans-unit>
        <trans-unit id="068fceff1e33e5da627a6b110b456936f6082b0c" translate="yes" xml:space="preserve">
          <source>Alternatively, if you have the &lt;code&gt;gunzip&lt;/code&gt; program available, you can use this to read compressed files</source>
          <target state="translated">或者，如果您有 &lt;code&gt;gunzip&lt;/code&gt; 程序可用，则可以使用它来读取压缩文件</target>
        </trans-unit>
        <trans-unit id="4d16466752d2c087e599f1526f5793b26a5e2b0a" translate="yes" xml:space="preserve">
          <source>Alternatively, if you want to read the &lt;code&gt;&quot;data1&quot;&lt;/code&gt; member into memory, use a scalar reference for the &lt;code&gt;output&lt;/code&gt; parameter.</source>
          <target state="translated">或者，如果要将 &lt;code&gt;&quot;data1&quot;&lt;/code&gt; 成员读入内存，请对 &lt;code&gt;output&lt;/code&gt; 参数使用标量引用。</target>
        </trans-unit>
        <trans-unit id="742c3c00178ebe72a9bfad0e3ef29810b62b04e9" translate="yes" xml:space="preserve">
          <source>Alternatively, put this as the first line of your script:</source>
          <target state="translated">或者,将此作为你脚本的第一行。</target>
        </trans-unit>
        <trans-unit id="daefa0329439a8224d52050e5214c48286284b22" translate="yes" xml:space="preserve">
          <source>Alternatively, rather than having to explicitly name each of the files that you want to compress, you could use a fileglob to select all the &lt;code&gt;txt&lt;/code&gt; files in the current directory, as follows</source>
          <target state="translated">另外，不必显式命名要压缩的每个文件，您可以使用fileglob选择当前目录中的所有 &lt;code&gt;txt&lt;/code&gt; 文件，如下所示</target>
        </trans-unit>
        <trans-unit id="c44b1aed9efe7eda393df0bd7f553f139ab03a17" translate="yes" xml:space="preserve">
          <source>Alternatively, simply use &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; for comparisons, this will get it always right. There is not yet a way to get a number automatically represented as a string that matches exactly the way Perl represents it.</source>
          <target state="translated">另外，只需使用 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 进行比较，即可始终正确。还没有一种方法来自动将数字表示为与Perl表示方式完全匹配的字符串。</target>
        </trans-unit>
        <trans-unit id="8ad4e77e5423588b083e2af8975456f597a84a91" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;text/parsewords&quot;&gt;Text::ParseWords&lt;/a&gt; module (part of the standard Perl distribution) lets you say:</source>
          <target state="translated">另外，&lt;a href=&quot;text/parsewords&quot;&gt;Text :: ParseWords&lt;/a&gt;模块（标准Perl发行版的一部分）允许您说：</target>
        </trans-unit>
        <trans-unit id="e3f5b7f0771697b931c8ecd89602848a9590421e" translate="yes" xml:space="preserve">
          <source>Alternatively, the crypt libraries in GNU libc have been ported to Cygwin.</source>
          <target state="translated">另外,GNU libc中的加密库也被移植到Cygwin中。</target>
        </trans-unit>
        <trans-unit id="996763dc438b824d04ceb178a7d6d2de1f4e3617" translate="yes" xml:space="preserve">
          <source>Alternatively, using a customized typemap for your purposes in the first place is probably preferable.</source>
          <target state="translated">另外,首先使用定制的排版图来达到你的目的可能是比较好的。</target>
        </trans-unit>
        <trans-unit id="818d3daf2781969164beb46d939858b0992b14b8" translate="yes" xml:space="preserve">
          <source>Alternatively, we could have used &lt;code&gt;C&lt;/code&gt; to unpack the individually accessible byte registers FL, FH, AL, AH, etc.:</source>
          <target state="translated">或者，我们可以使用 &lt;code&gt;C&lt;/code&gt; 来解包可单独访问的字节寄存器FL，FH，AL，AH等：</target>
        </trans-unit>
        <trans-unit id="973c34c798c56bb32a7153f1be5f39dd390df9c7" translate="yes" xml:space="preserve">
          <source>Alternatively, you can fiddle with the stack directly: &lt;code&gt;SP&lt;/code&gt; gives you the first element in your portion of the stack, and &lt;code&gt;TOP*&lt;/code&gt; gives you the top SV/IV/NV/etc. on the stack. So, for instance, to do unary negation of an integer:</source>
          <target state="translated">或者，您可以直接摆弄堆栈： &lt;code&gt;SP&lt;/code&gt; 为您提供堆栈中第一个元素，而 &lt;code&gt;TOP*&lt;/code&gt; 为您提供顶部的SV / IV / NV / etc。在堆栈上。因此，例如，对整数进行一元求反：</target>
        </trans-unit>
        <trans-unit id="4486c955e53dc63730c2501b04fe03ec6d1fb66c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can quote the class name:</source>
          <target state="translated">另外,你也可以引用类名。</target>
        </trans-unit>
        <trans-unit id="9393a15204a23768f5fb6e120d832da535fff827" translate="yes" xml:space="preserve">
          <source>Alternatively, you can specify that the option can have multiple values by adding a &quot;@&quot;, and pass a scalar reference as the destination:</source>
          <target state="translated">另外,你也可以通过添加&quot;@&quot;来指定选项可以有多个值,并传递一个标量引用作为目标。</target>
        </trans-unit>
        <trans-unit id="86794ed15412a1fa79e33d4ba8f3e04841c9eebc" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the &lt;code&gt;plan()&lt;/code&gt; function. Useful for when you have to calculate the number of tests.</source>
          <target state="translated">另外，您可以使用 &lt;code&gt;plan()&lt;/code&gt; 函数。在必须计算测试次数时很有用。</target>
        </trans-unit>
        <trans-unit id="bd695ed1549655fbf2b6a69e34efa112b5887ecd" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the GCC_EXEC_PREFIX environment variable to ensure that Sun's as and ld are used. Consult your gcc documentation for further information on the -B option and the GCC_EXEC_PREFIX variable.</source>
          <target state="translated">或者,你可以使用GCC_EXEC_PREFIX环境变量来确保使用Sun的as和ld。关于-B选项和GCC_EXEC_PREFIX变量的更多信息,请查阅gcc文档。</target>
        </trans-unit>
        <trans-unit id="5e3eb7cca34a1ce6ec3422f81caa582587938fc9" translate="yes" xml:space="preserve">
          <source>Alternatively, you may inspect the value of &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; with the &lt;code&gt;W*()&lt;/code&gt; calls from the POSIX module.</source>
          <target state="translated">或者，您可以通过POSIX模块的 &lt;code&gt;W*()&lt;/code&gt; 调用检查 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="efc46e4aa2514a5747d9e66b804729fd4f6f91eb" translate="yes" xml:space="preserve">
          <source>Alternatives are tried from left to right, so the first alternative found for which the entire expression matches, is the one that is chosen. This means that alternatives are not necessarily greedy. For example: when matching &lt;code&gt;foo|foot&lt;/code&gt; against &quot;barefoot&quot;, only the &quot;foo&quot; part will match, as that is the first alternative tried, and it successfully matches the target string. (This might not seem important, but it is important when you are capturing matched text using parentheses.)</source>
          <target state="translated">从左到右尝试替代方案，因此找到与整个表达式匹配的第一个替代方案。这意味着替代方案不一定是贪婪的。例如：将 &lt;code&gt;foo|foot&lt;/code&gt; 与&amp;ldquo; barefoot&amp;rdquo; 匹配时，只有&amp;ldquo; foo&amp;rdquo;部分将匹配，因为这是第一个尝试的方法，它成功匹配了目标字符串。（这似乎并不重要，但是在使用括号捕获匹配的文本时，这一点很重要。）</target>
        </trans-unit>
        <trans-unit id="178ef3c8a39076052130de80299d367dd5e6090f" translate="yes" xml:space="preserve">
          <source>Alternatives to raw</source>
          <target state="translated">生的替代品</target>
        </trans-unit>
        <trans-unit id="895965b31db8e4bfa4de954e884b587830b4927d" translate="yes" xml:space="preserve">
          <source>Alternativly look at &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Auth::Basic&quot;&gt;Plack::Middleware::Auth::Basic&lt;/a&gt;, or one of the other &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%2bauth&quot;&gt;Plack authentication&lt;/a&gt; options.</source>
          <target state="translated">或者，查看&lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Auth::Basic&quot;&gt;Plack :: Middleware :: Auth :: Basic&lt;/a&gt;或其他&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%2bauth&quot;&gt;Plack身份验证&lt;/a&gt;选项之一。</target>
        </trans-unit>
        <trans-unit id="083655cd712cf57272ed2f0a7a5805f36d9802f0" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; cannot do this directly, there is a module which can layer transparently over &lt;b&gt;DB_File&lt;/b&gt; to accomplish this feat.</source>
          <target state="translated">尽管&lt;b&gt;DB_File&lt;/b&gt;无法直接执行此操作，但是有一个模块可以透明地在&lt;b&gt;DB_File&lt;/b&gt;上分层以完成此功能。</target>
        </trans-unit>
        <trans-unit id="3768f14455445c5980f80214d4ffa65dc7a14002" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; is covered by the Perl license, the library it makes use of, namely Berkeley DB, is not. Berkeley DB has its own copyright and its own license. Please take the time to read it.</source>
          <target state="translated">尽管&lt;b&gt;DB_File&lt;/b&gt;受Perl许可证的保护，但它使用的库（即Berkeley DB）却没有。Berkeley DB具有自己的版权和许可证。请花时间阅读它。</target>
        </trans-unit>
        <trans-unit id="73b1840016122f68e05350fe0f1ab0303bd2fd8b" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; is intended to be used with Berkeley DB version 1, it can also be used with version 2, 3 or 4. In this case the interface is limited to the functionality provided by Berkeley DB 1.x. Anywhere the version 2 or greater interface differs, &lt;b&gt;DB_File&lt;/b&gt; arranges for it to work like version 1. This feature allows &lt;b&gt;DB_File&lt;/b&gt; scripts that were built with version 1 to be migrated to version 2 or greater without any changes.</source>
          <target state="translated">尽管&lt;b&gt;DB_File&lt;/b&gt;打算与Berkeley DB版本1一起使用，但也可以与版本2、3或4一起使用。在这种情况下，接口仅限于Berkeley DB 1.x提供的功能。无论版本2或更高版本的接口有何不同，&lt;b&gt;DB_File都会&lt;/b&gt;安排它像版本1一样工作。此功能允许将使用版本1构建的&lt;b&gt;DB_File&lt;/b&gt;脚本迁移到版本2或更高版本，而无需进行任何更改。</target>
        </trans-unit>
        <trans-unit id="a4ee4e9c8be6f9bb865a03f9dd6635b3149d28d3" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;$_&lt;/code&gt; doesn't actually appear explicitly in the sample filters above, it is implicitly used in a number of places.</source>
          <target state="translated">尽管 &lt;code&gt;$_&lt;/code&gt; 实际上并未显式出现在上面的示例过滤器中，但是它在许多地方都隐式使用。</target>
        </trans-unit>
        <trans-unit id="80dfb6d994a40fa49e44520920eac36d9fa1f16f" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; is false on a plain not-yet-used hash, it becomes true in several non-obvious circumstances, including iterators, weak references, stash names, even remaining true after &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; . These things make &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; fairly useless in practice, so it now generates a fatal error.</source>
          <target state="translated">尽管已 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; 在尚未使用的普通哈希中为false，但在几种非显而易见的情况下（包括迭代器，弱引用，存储名称），它变为true，甚至在 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; 之后仍为 true 。这些事情使已 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; 在实践中相当无用，因此现在会产生致命错误。</target>
        </trans-unit>
        <trans-unit id="df1f79335b5e25baa8b910d3ca247a13fd7eda4e" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;cmp_ok()&lt;/code&gt; was introduced in 0.40, 0.86 fixed an important bug to make it safe for overloaded objects; the fixed first shipped with Perl in 5.10.1 as part of Test::More 0.92.</source>
          <target state="translated">尽管 &lt;code&gt;cmp_ok()&lt;/code&gt; 是在0.40中引入的，但0.86修复了一个重要的错误，以使其对于重载的对象而言是安全的；作为Test :: More 0.92的一部分，Perl在5.10.1中首次提供的固定版本。</target>
        </trans-unit>
        <trans-unit id="1c4fc726a9484b19113d6eedd6d8805f1968eb73" translate="yes" xml:space="preserve">
          <source>Although FileCache can be used with piped opens ('-|' or '|-') doing so is strongly discouraged. If FileCache finds it necessary to close and then reopen a pipe, the command at the far end of the pipe will be reexecuted - the results of performing IO on FileCache'd pipes is unlikely to be what you expect. The ability to use FileCache on pipes may be removed in a future release.</source>
          <target state="translated">尽管FileCache可以使用管道打开('-|'或'|-'),但强烈不推荐这样做。如果FileCache发现有必要关闭然后重新打开管道,那么管道末端的命令将被重新执行--在FileCache'd管道上执行IO的结果很可能不是你所期望的。在管道上使用FileCache的功能可能会在未来的版本中被移除。</target>
        </trans-unit>
        <trans-unit id="077804ce34db1c72deaf81a9a83f1e62f8a114a7" translate="yes" xml:space="preserve">
          <source>Although I have made use of only the &lt;code&gt;POP*&lt;/code&gt; macros to access values returned from Perl subroutines, it is also possible to bypass these macros and read the stack using the &lt;code&gt;ST&lt;/code&gt; macro (See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for a full description of the &lt;code&gt;ST&lt;/code&gt; macro).</source>
          <target state="translated">虽然我已经仅使用的 &lt;code&gt;POP*&lt;/code&gt; 宏从Perl的子程序返回访问值，还可以绕过这些宏并使用读出栈 &lt;code&gt;ST&lt;/code&gt; 宏（见&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;为的完整说明， &lt;code&gt;ST&lt;/code&gt; 宏）。</target>
        </trans-unit>
        <trans-unit id="ebf0c3d2a317483257bd5985b5509d45e615f5a4" translate="yes" xml:space="preserve">
          <source>Although PA-RISC binaries can run on Itanium systems, you should not attempt to use a PA-RISC version of Perl on an Itanium system. This is because shared libraries created on an Itanium system cannot be loaded while running a PA-RISC executable.</source>
          <target state="translated">虽然PA-RISC二进制文件可以在Itanium系统上运行,但你不应该尝试在Itanium系统上使用PA-RISC版本的Perl。这是因为在Itanium系统上创建的共享库不能在运行PA-RISC可执行文件时被加载。</target>
        </trans-unit>
        <trans-unit id="2b071251c66f97d7a5a833d31d9bbb833fc948ef" translate="yes" xml:space="preserve">
          <source>Although Perl will automatically grow strings for you, if you need to force Perl to allocate more memory for your SV, you can use the macro</source>
          <target state="translated">虽然Perl会自动为你增长字符串,但如果你需要强制Perl为你的SV分配更多的内存,你可以使用宏</target>
        </trans-unit>
        <trans-unit id="3fece6ab5bd6d283eb840842e215942103cb610e" translate="yes" xml:space="preserve">
          <source>Although Plan 9 Perl currently only provides static loading, it is built with a number of useful extensions. These include Opcode, FileHandle, Fcntl, and POSIX. Expect to see others (and DynaLoading!) in the future.</source>
          <target state="translated">虽然Plan 9 Perl目前只提供静态加载,但它内置了许多有用的扩展。这些扩展包括 Opcode、FileHandle、Fcntl 和 POSIX。期待未来能看到其他的扩展(还有DynaLoading!)。</target>
        </trans-unit>
        <trans-unit id="e4e6f6df84571e93788f39ee96ef2a5f0752bec2" translate="yes" xml:space="preserve">
          <source>Although Test::More has been a core module in versions of Perl since 5.6.2, Test::More has evolved since then, and not all of the features you're used to will be present in the shipped version of Test::More. If you are writing a module, don't forget to indicate in your package metadata the minimum version of Test::More that you require. For instance, if you want to use &lt;code&gt;done_testing()&lt;/code&gt; but want your test script to run on Perl 5.10.0, you will need to explicitly require Test::More &amp;gt; 0.88.</source>
          <target state="translated">尽管自5.6.2版以来，Test :: More一直是Perl版本的核心模块，但自那时起Test :: More已经得到了发展，并非您习惯的所有功能都会出现在Test ::的发行版中。更多。如果您正在编写模块，请不要忘记在包元数据中指出所需的最低Test :: More版本。例如，如果要使用 &lt;code&gt;done_testing()&lt;/code&gt; 但要使测试脚本在Perl 5.10.0上运行，则需要明确要求Test :: More&amp;gt; 0.88。</target>
        </trans-unit>
        <trans-unit id="a0cac5f469f6b90c62f4e56ab4bfa747637957a2" translate="yes" xml:space="preserve">
          <source>Although as of 5.14, that can be also be accomplished this way:</source>
          <target state="translated">虽然截至5.14日,也可以通过这种方式来实现。</target>
        </trans-unit>
        <trans-unit id="b446ed3017bd4a5c94fd715dbc357d36cd8b9eae" translate="yes" xml:space="preserve">
          <source>Although if your manager accused you of seeking job security (or rapid insecurity) through inscrutable code, it would be hard to argue. :-) If I were you, I'd put that in a function:</source>
          <target state="translated">虽然如果你的经理指责你通过难以捉摸的代码来寻求工作的安全性(或快速的不安全性),那就很难辩解了。 :-)如果我是你,我会把它放在一个函数里。</target>
        </trans-unit>
        <trans-unit id="4a4e26bb6dd1017566ef68d6d6d4ea499d6e917f" translate="yes" xml:space="preserve">
          <source>Although it has no direct equivalent in C, Perl's &lt;code&gt;//&lt;/code&gt; operator is related to its C-style &quot;or&quot;. In fact, it's exactly the same as &lt;code&gt;||&lt;/code&gt;, except that it tests the left hand side's definedness instead of its truth. Thus, &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; returns the value of &lt;code&gt;EXPR1&lt;/code&gt; if it's defined, otherwise, the value of &lt;code&gt;EXPR2&lt;/code&gt; is returned. (&lt;code&gt;EXPR1&lt;/code&gt; is evaluated in scalar context, &lt;code&gt;EXPR2&lt;/code&gt; in the context of &lt;code&gt;//&lt;/code&gt; itself). Usually, this is the same result as &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; (except that the ternary-operator form can be used as a lvalue, while &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; cannot). This is very useful for providing default values for variables. If you actually want to test if at least one of &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; is defined, use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;($x // $y)&lt;/code&gt; .</source>
          <target state="translated">尽管它在C中没有直接等效项，但是Perl的 &lt;code&gt;//&lt;/code&gt; 运算符与其C样式的&amp;ldquo;或&amp;rdquo;相关。实际上，它与 &lt;code&gt;||&lt;/code&gt; 完全相同，除了它测试左侧的定义而不是其真实性。因此， &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; 返回的值 &lt;code&gt;EXPR1&lt;/code&gt; ，如果它的定义，否则，价值 &lt;code&gt;EXPR2&lt;/code&gt; 返回。 （ &lt;code&gt;EXPR1&lt;/code&gt; 在标量上下文中评估， &lt;code&gt;EXPR2&lt;/code&gt; 在 &lt;code&gt;//&lt;/code&gt; 自身上下文中评估）。通常，这与 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; 结果（EXPR1）是相同的？ EXPR1：EXPR2（除了三元运算符形式可以用作左值，而 &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; 不能）。这对于提供变量的默认值非常有用。如果您实际上想测试是否已定义 &lt;code&gt;$x&lt;/code&gt; 和 &lt;code&gt;$y&lt;/code&gt; 中的至少一个，请使用 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;($x // $y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d57a21b7f19f0f3f2ceca275a472340c6e4e3a5" translate="yes" xml:space="preserve">
          <source>Although it has the same precedence as in C, Perl's &lt;code&gt;?:&lt;/code&gt; operator produces an lvalue. This assigns $x to either $if_true or $if_false, depending on the trueness of $maybe:</source>
          <target state="translated">尽管它的优先级与C中相同，但是Perl的 &lt;code&gt;?:&lt;/code&gt; 运算符会产生一个左值。这将$ x分配给$ if_true或$ if_false，这取决于$ maybe的真实性：</target>
        </trans-unit>
        <trans-unit id="5ee0b4360c14601bcb250b62e156bc4ae2010689" translate="yes" xml:space="preserve">
          <source>Although it is a bit confusing and some people object to the terminology, it is worth taking a look at a comment that has been in</source>
          <target state="translated">虽然它有点混乱,有些人反对这个术语,但值得一看的是,有评论说,在</target>
        </trans-unit>
        <trans-unit id="da1e430c6e0d63cde26c5c8c71827f0d44bf6196" translate="yes" xml:space="preserve">
          <source>Although it is not illegal, the use of &lt;code&gt;MultiHomed&lt;/code&gt; on a socket which is in non-blocking mode is of little use. This is because the first connect will never fail with a timeout as the connect call will not block.</source>
          <target state="translated">尽管不是非法的，但在非阻塞模式下的套接字上使用 &lt;code&gt;MultiHomed&lt;/code&gt; 几乎没有用。这是因为第一个连接将不会因超时而失败，因为连接调用不会阻塞。</target>
        </trans-unit>
        <trans-unit id="e93362b29f52a34d35cc322a788d526233d087a7" translate="yes" xml:space="preserve">
          <source>Although it is possible (with some effort on your part) to use this module to access .zip files, there are other perl modules available that will do all the hard work for you. Check out &lt;code&gt;Archive::Zip&lt;/code&gt; , &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; , &lt;code&gt;IO::Compress::Zip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt; .</source>
          <target state="translated">尽管可以（需要您一些努力）使用此模块来访问.zip文件，但是还有其他可用的perl模块可以为您完成所有艰苦的工作。检出 &lt;code&gt;Archive::Zip&lt;/code&gt; ， &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; ， &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 和 &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt; Uncompress :: Unzip。</target>
        </trans-unit>
        <trans-unit id="7a135fdb236629c700a0674370bcc8d9bb97bd72" translate="yes" xml:space="preserve">
          <source>Although it may be considered internal, the class hierarchy does matter for both users and programmer. CPAN.pm deals with the four classes mentioned above, and those classes all share a set of methods. Classical single polymorphism is in effect. A metaclass object registers all objects of all kinds and indexes them with a string. The strings referencing objects have a separated namespace (well, not completely separated):</source>
          <target state="translated">虽然可能被认为是内部的,但类的层次结构对用户和程序员来说确实很重要。CPAN.pm处理的是上述四个类,这些类都共享一组方法。经典的单多态是有效的。一个元类对象注册了所有的各类对象,并以字符串为索引。引用对象的字符串有一个分离的命名空间(好吧,不是完全分离)。</target>
        </trans-unit>
        <trans-unit id="c770d25bc14389e491ccd1785ab555be61626cb8" translate="yes" xml:space="preserve">
          <source>Although it may not be immediately obvious from the code above, the associative array interface can be used to write values with duplicate keys, but it cannot be used to read them back from the database.</source>
          <target state="translated">虽然从上面的代码中可能不会立即显现出来,但关联数组接口可以用来写入带有重复键的值,但不能用来从数据库中读回它们。</target>
        </trans-unit>
        <trans-unit id="180ef42cd3ef3f7ed108e6700423675760cce278" translate="yes" xml:space="preserve">
          <source>Although it might seem like a real pain, it is really worth the effort of having a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; in all your scripts.</source>
          <target state="translated">尽管看起来确实很痛苦，但是在所有脚本中 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;确实值得付出努力。</target>
        </trans-unit>
        <trans-unit id="7eddb5fd279be6b295018b9f9f42e02ddccfda46" translate="yes" xml:space="preserve">
          <source>Although memory overhead of bigger buckets is kept inside the bucket, for smaller buckets, it is kept in separate areas. This field gives the total size of these areas.</source>
          <target state="translated">虽然较大的桶的内存开销被保存在桶内,但对于较小的桶,它被保存在单独的区域中。这个字段给出了这些区域的总大小。</target>
        </trans-unit>
        <trans-unit id="5fe78f913ab3f5713143fe4461404c36ff017beb" translate="yes" xml:space="preserve">
          <source>Although no warning is currently raised, the results are not well defined when these operations are performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;).</source>
          <target state="translated">尽管当前未发出警告，但是当对既不是数字（请参阅&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;）又不是&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;位字符串&lt;/a&gt;（请参见按位字符串运算符）的操作数执行这些操作时，结果定义不明确。</target>
        </trans-unit>
        <trans-unit id="c94501363b8d49d883be5ef00569dcb0d5283b0f" translate="yes" xml:space="preserve">
          <source>Although not for the faint of heart, Perl does support a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; statement. There are three forms: &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-LABEL, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-EXPR, and &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-&amp;amp;NAME. A loop's LABEL is not actually a valid target for a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;; it's just the name of the loop.</source>
          <target state="translated">尽管不是出于胆小，Perl确实支持 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 语句。有三种形式： &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -label， &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -expr，并 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -与命名。循环的LABEL实际上并不是 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 的有效目标；它只是循环的名称。</target>
        </trans-unit>
        <trans-unit id="c556c081516373f750515951f1b9a5217dc9bdfc" translate="yes" xml:space="preserve">
          <source>Although one can already do quite a lot with the literal string regexps above, we've only scratched the surface of regular expression technology. In this and subsequent sections we will introduce regexp concepts (and associated metacharacter notations) that will allow a regexp to represent not just a single character sequence, but a</source>
          <target state="translated">虽然人们已经可以用上面的字面字符串regexps做很多事情,但我们只是触及了正则表达式技术的表面。在本节和后续章节中,我们将介绍 regexp 的概念(以及相关的元字符符号),这些概念将允许 regexp 不仅仅代表一个单一的字符序列,而是代表一个</target>
        </trans-unit>
        <trans-unit id="18a0eac57e1c4484372ccab28955e18fb02ea640" translate="yes" xml:space="preserve">
          <source>Although one would expect the quantities $y and $z to be the same and equal to 100000 they will differ and instead will be 0 and 100000 respectively.</source>
          <target state="translated">虽然人们期望数量$y和$z是相同的,等于100000,但它们会有所不同,而是分别为0和100000。</target>
        </trans-unit>
        <trans-unit id="5829c5fcc8ce3b64df01881896b3b15fd774741a" translate="yes" xml:space="preserve">
          <source>Although only a single value was expected to be returned from</source>
          <target state="translated">虽然预计只有一个值会从</target>
        </trans-unit>
        <trans-unit id="2a2b97db7310124d07426632d32011d83ef42107" translate="yes" xml:space="preserve">
          <source>Although primarily designed for use with multi-threaded Perl, the macros have been designed so that they will work with non-threaded Perl as well.</source>
          <target state="translated">虽然这些宏主要是为多线程Perl设计的,但它们也可以在非线程Perl中使用。</target>
        </trans-unit>
        <trans-unit id="797e69b4382557ebf9cc947a771d199448156185" translate="yes" xml:space="preserve">
          <source>Although similar, file path specifications differ between Unix, Windows, Mac OS, OS/2, VMS, VOS, RISC OS, and probably others. Unix, for example, is one of the few OSes that has the elegant idea of a single root directory.</source>
          <target state="translated">虽然相似,但Unix、Windows、Mac OS、OS/2、VMS、VOS、RISC OS以及其他操作系统之间的文件路径规范有所不同。例如,Unix是为数不多的具有单一根目录这一优雅理念的操作系统之一。</target>
        </trans-unit>
        <trans-unit id="d6190ff15955860c6c9fdd297f5be90390874780" translate="yes" xml:space="preserve">
          <source>Although test failures should be enough, extra diagnostics can be triggered at the end of a test run. &lt;code&gt;onfail&lt;/code&gt; is passed an array ref of hash refs that describe each test failure. Each hash will contain at least the following fields: &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;repetition&lt;/code&gt; , and &lt;code&gt;result&lt;/code&gt; . (You shouldn't rely on any other fields being present.) If the test had an expected value or a diagnostic (or &quot;note&quot;) string, these will also be included.</source>
          <target state="translated">尽管测试失败应该足够，但是在测试运行结束时仍可以触发额外的诊断。 &lt;code&gt;onfail&lt;/code&gt; 传递了描述每个测试失败的哈希引用的数组引用。每个哈希至少包含以下字段： &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;repetition&lt;/code&gt; 和 &lt;code&gt;result&lt;/code&gt; 。（您不应依赖于其他任何存在的字段。）如果测试具有期望值或诊断（或&amp;ldquo;注释&amp;rdquo;）字符串，则还将包括这些内容。</target>
        </trans-unit>
        <trans-unit id="224e863badf25248ea988718d8bd34cef72cce5a" translate="yes" xml:space="preserve">
          <source>Although that form may run into trouble in network transit (due to the presence of 8 bit characters) or on non ISO-Latin character sets. But it does allow &lt;code&gt;Is_c1&lt;/code&gt; to be rewritten so it works on Perls that don't have &lt;code&gt;'unicode_strings'&lt;/code&gt; (earlier than v5.14):</source>
          <target state="translated">尽管这种形式可能会在网络传输中遇到麻烦（由于存在8位字符）或在非ISO拉丁字符集上。但是它确实允许重写 &lt;code&gt;Is_c1&lt;/code&gt; ，因此它可以在没有 &lt;code&gt;'unicode_strings'&lt;/code&gt; （低于v5.14的版本）的Perls上运行：</target>
        </trans-unit>
        <trans-unit id="99123ea723cf2a29473e47c091f28928ebbdafd8" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;%&lt;/code&gt; code is documented as returning a &quot;checksum&quot;: don't put your trust in such values! Even when applied to a small number of bytes, they won't guarantee a noticeable Hamming distance.</source>
          <target state="translated">尽管 &lt;code&gt;%&lt;/code&gt; 代码记录为返回&amp;ldquo;校验和&amp;rdquo;：请不要相信这些值！即使将其应用于少量字节，也无法保证明显的汉明距离。</target>
        </trans-unit>
        <trans-unit id="6834c0c595f466c17dc9377b6377ec111fa7e11c" translate="yes" xml:space="preserve">
          <source>Although the above may seem a bit confusing at first, it generally does &quot;the right thing&quot; in most situations. This determination of the default values to use is based upon the following typical Unix conventions:</source>
          <target state="translated">虽然上面的内容一开始看起来有些混乱,但一般来说,在大多数情况下它都是 &quot;正确的&quot;。这种默认值的确定是基于以下典型的Unix惯例。</target>
        </trans-unit>
        <trans-unit id="a0b752b8fd0002195999a4940b4a67ff51de0cf2" translate="yes" xml:space="preserve">
          <source>Although the error message above refers to the second tie() statement in the script, the source of the problem is really with the untie() statement that precedes it.</source>
          <target state="translated">虽然上面的错误信息指的是脚本中的第二条 tie()语句,但问题的根源其实是前面的 untie()语句。</target>
        </trans-unit>
        <trans-unit id="050771d84c3ebf7bfb6e4438000d2961a2adc2a7" translate="yes" xml:space="preserve">
          <source>Although the functionality provided by this flag may seem straightforward, it should be used only if there is a good reason to do so. The reason for being cautious is that, even if you have specified the G_NOARGS flag, it is still possible for the Perl subroutine that has been called to think that you have passed it parameters.</source>
          <target state="translated">虽然这个标志所提供的功能看起来很简单,但只有在有充分理由的情况下才能使用。谨慎的原因是,即使你指定了G_NOARGS标志,被调用的Perl子程序仍然有可能认为你给它传递了参数。</target>
        </trans-unit>
        <trans-unit id="0019a6a5066bef3137d87deda446668085e7063b" translate="yes" xml:space="preserve">
          <source>Although the ignored argument doesn't go into a variable, it is still mandatory for the caller to pass it.</source>
          <target state="translated">虽然被忽略的参数不会进入变量中,但对调用者来说,它仍然是必须传递的。</target>
        </trans-unit>
        <trans-unit id="35ed9f698c7272524026c7a45834a834a74d7bb0" translate="yes" xml:space="preserve">
          <source>Although the main discussion of Perl security issues can be found in &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;, a discussion of Perl's locale handling would be incomplete if it did not draw your attention to locale-dependent security issues. Locales--particularly on systems that allow unprivileged users to build their own locales--are untrustworthy. A malicious (or just plain broken) locale can make a locale-aware application give unexpected results. Here are a few possibilities:</source>
          <target state="translated">尽管可以在&lt;a href=&quot;perlsec&quot;&gt;perlsec中&lt;/a&gt;找到有关Perl安全性问题的主要讨论，但是，如果没有引起您对依赖于语言环境的安全性问题的关注，对Perl的语言环境处理的讨论将是不完整的。语言环境（尤其是在允许无特权用户建立自己的语言环境的系统上）是不可信的。恶意（或仅是普通破坏）的语言环境可能会使支持语言环境的应用程序产生意外的结果。这里有一些可能性：</target>
        </trans-unit>
        <trans-unit id="6ad8f5d884e3bfe99068d75f61c2b91c556f88ba" translate="yes" xml:space="preserve">
          <source>Although the most deeply nested array or hash element will not spring into existence just because its existence was tested, any intervening ones will. Thus &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; and &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; will spring into existence due to the existence test for the $key element above. This happens anywhere the arrow operator is used, including even here:</source>
          <target state="translated">尽管最深层嵌套的数组或哈希元素不会仅仅因为已经测试过其存在而出现，但任何中间元素都可以。因此，由于上面$ key元素的存在性测试， &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; 和 &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; 将会出现。这发生在使用箭头运算符的任何地方，甚至包括以下位置：</target>
        </trans-unit>
        <trans-unit id="ece6731e40fd98f25883ef891976cdd74d8b5353" translate="yes" xml:space="preserve">
          <source>Although the optree is read-only, there is an overlay facility that allows you to override what values the various B::*OP methods return for a particular op. &lt;code&gt;$B::overlay&lt;/code&gt; should be set to reference a two-deep hash: indexed by OP address, then method name. Whenever a an op method is called, the value in the hash is returned if it exists. This facility is used by B::Deparse to &quot;undo&quot; some optimisations. For example:</source>
          <target state="translated">尽管optree是只读的，但是有一个覆盖工具允许您重写各种B :: * OP方法为特定op返回的值。 &lt;code&gt;$B::overlay&lt;/code&gt; 应该设置为引用两个深度的哈希值：按OP地址索引，然后按方法名称索引。每当调用op方法时，如果哈希值存在，则返回该值。B :: Deparse使用此功能来&amp;ldquo;撤消&amp;rdquo;某些优化。例如：</target>
        </trans-unit>
        <trans-unit id="4006666c099c71fba2fd95778e8d769cab92e521" translate="yes" xml:space="preserve">
          <source>Although the primary purpose for the existence of &lt;code&gt;Compress::Raw::Bzip2&lt;/code&gt; is for use by the &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; and &lt;code&gt;IO::Compress::Bunzip2&lt;/code&gt; modules, it can be used on its own for simple compression/uncompression tasks.</source>
          <target state="translated">尽管存在 &lt;code&gt;Compress::Raw::Bzip2&lt;/code&gt; 的主要目的是由 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 和 &lt;code&gt;IO::Compress::Bunzip2&lt;/code&gt; 模块使用，但它可以单独用于简单的压缩/解压缩任务。</target>
        </trans-unit>
        <trans-unit id="73cce3599d213093393a3d6545498d75ae280481" translate="yes" xml:space="preserve">
          <source>Although the techniques described here are applicable when embedding Perl in a C program, this is not the primary goal of this document. There are other details that must be considered and are specific to embedding Perl. For details on embedding Perl in C refer to &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">尽管此处描述的技术适用于将Perl嵌入C程序中，但这不是本文档的主要目标。还必须考虑其他细节，这些细节特定于嵌入Perl。有关将Perl嵌入C的详细信息，请参考&lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14e1e99a665303302472280aa271e6e7551860a9" translate="yes" xml:space="preserve">
          <source>Although there can be any number of source streams in existence at any given time, only one will be active.</source>
          <target state="translated">虽然在任何时候都可以有任何数量的源流存在,但只有一个源流是活跃的。</target>
        </trans-unit>
        <trans-unit id="c84534656a685169f0194cbbe1e16531f562b033" translate="yes" xml:space="preserve">
          <source>Although these are grouped by family, they all have the precedence of assignment. These combined assignment operators can only operate on scalars, whereas the ordinary assignment operator can assign to arrays, hashes, lists and even references. (See &lt;a href=&quot;perldata#Context&quot;&gt;Context&lt;/a&gt; and &lt;a href=&quot;perldata#List-value-constructors&quot;&gt;List value constructors in perldata&lt;/a&gt;, and &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Assigning to References in perlref&lt;/a&gt;.)</source>
          <target state="translated">尽管这些是按家庭分组的，但它们都具有分配的优先权。这些组合的赋值运算符只能对标量进行运算，而普通的赋值运算符可以赋给数组，哈希，列表甚至引用。（请参阅&lt;a href=&quot;perldata#List-value-constructors&quot;&gt;perldata中的&lt;/a&gt;&lt;a href=&quot;perldata#Context&quot;&gt;Context&lt;/a&gt;和List值构造函数，以及perlref中的&lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;分配给引用&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="459be48ccfdeb87ea73fbd1fbec51d1410292106" translate="yes" xml:space="preserve">
          <source>Although this function returns its values on the perl argument stack, it doesn't take any parameters from that stack (and thus in particular there's no need to do a PUSHMARK before calling it, unlike &lt;a href=&quot;#call_pv&quot;&gt;call_pv&lt;/a&gt; for example).</source>
          <target state="translated">尽管此函数在perl参数堆栈上返回其值，但它不从该堆栈中获取任何参数（因此，特别是，在调用它之前无需执行&lt;a href=&quot;#call_pv&quot;&gt;PUSHMARK&lt;/a&gt;，例如，与call_pv不同）。</target>
        </trans-unit>
        <trans-unit id="9ecb9099e922e4493577adbe3649de5e0005a135" translate="yes" xml:space="preserve">
          <source>Although this keyword is optional and in some cases provides redundant information it should always be used. This keyword will ensure that the XSUBs appear in the desired package.</source>
          <target state="translated">虽然这个关键字是可选的,而且在某些情况下它提供了多余的信息,但它应该始终被使用。这个关键字将确保XSUB出现在所需的包中。</target>
        </trans-unit>
        <trans-unit id="66fb31ad783a8264f17dab51f3aa1ad011017a08" translate="yes" xml:space="preserve">
          <source>Although this option can be used with the OO interface, it is of most use with the one-shot interface. For example, the code below shows how &lt;code&gt;FilterName&lt;/code&gt; can be used to remove the path component from a series of filenames before they are stored in &lt;code&gt;$zipfile&lt;/code&gt; .</source>
          <target state="translated">尽管此选项可与OO界面一起使用，但最常用于单发界面。例如，以下代码显示了在将文件名存储在 &lt;code&gt;$zipfile&lt;/code&gt; 之前，如何使用 &lt;code&gt;FilterName&lt;/code&gt; 从一系列文件名中删除路径组件。</target>
        </trans-unit>
        <trans-unit id="2398658140451226b4cd3f1886215ebf8c65091f" translate="yes" xml:space="preserve">
          <source>Although this stuff is easier to explain using examples, you first need be aware of a few important definitions.</source>
          <target state="translated">虽然这个东西用例子解释起来比较容易,但你首先需要了解几个重要的定义。</target>
        </trans-unit>
        <trans-unit id="5d6b9d5e42d7a86677e3f471c1e47e328daf1dc8" translate="yes" xml:space="preserve">
          <source>Although very useful, the big problem with using &lt;b&gt;-w&lt;/b&gt; on the command line to enable warnings is that it is all or nothing. Take the typical scenario when you are writing a Perl program. Parts of the code you will write yourself, but it's very likely that you will make use of pre-written Perl modules. If you use the &lt;b&gt;-w&lt;/b&gt; flag in this case, you end up enabling warnings in pieces of code that you haven't written.</source>
          <target state="translated">尽管非常有用，但是在命令行上使用&lt;b&gt;-w&lt;/b&gt;启用警告的主要问题是它全部或全部都不存在。在编写Perl程序时采用典型情况。您将自己编写部分代码，但是很有可能会使用预先编写的Perl模块。如果在这种情况下使用&lt;b&gt;-w&lt;/b&gt;标志，则最终会在尚未编写的代码段中启用警告。</target>
        </trans-unit>
        <trans-unit id="560edbbb945d8ba093edcea345708feb744a0493" translate="yes" xml:space="preserve">
          <source>Although we do suggest that you always build your own Perl from the source code, both for maximal configurability and for security, in case you are in a hurry you can check &lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html&lt;/a&gt; for binary distributions.</source>
          <target state="translated">尽管我们确实建议您始终从源代码中构建自己的Perl，以实现最大的可配置性和安全性，但是如果您急着需要，可以&lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;访问http://www.cpan.org/ports/index.html&lt;/a&gt;以获得帮助。二进制分布。</target>
        </trans-unit>
        <trans-unit id="46ce08a44dd2ba4f6ce9e91fa3d420e93dff144d" translate="yes" xml:space="preserve">
          <source>Although write can work with lexical or package variables, whatever variables you use have to scope in the format. That most likely means you'll want to localize some package variables:</source>
          <target state="translated">尽管write可以使用词法变量或包变量,但无论你使用什么变量,都必须以格式化的方式进行作用域。这很可能意味着你要本地化一些包变量。</target>
        </trans-unit>
        <trans-unit id="e1e9346790d51b0db2514b5ac70a5da4526349c7" translate="yes" xml:space="preserve">
          <source>Although, for historical reasons, the &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; distribution takes its name from this module it now exists only to provide &lt;a href=&quot;../tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; with an interface that is somewhat backwards compatible with &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; 2.xx. If you're writing new code consider using &lt;a href=&quot;../tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; directly instead.</source>
          <target state="translated">尽管出于历史原因，&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt;发行版从此模块中获得了名称，但它现在仅存在于为&lt;a href=&quot;../tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt;提供一个与&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; 2.xx 向下兼容的接口。如果要编写新代码，请考虑直接使用&lt;a href=&quot;../tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f966b3ea336af8830bc18236a5389bd937c78b7c" translate="yes" xml:space="preserve">
          <source>Always be civil.</source>
          <target state="translated">要时刻保持文明。</target>
        </trans-unit>
        <trans-unit id="c369c01b27ace1a743bc3e37d378c5dbbf093f50" translate="yes" xml:space="preserve">
          <source>Always check the return codes of system calls. Good error messages should go to &lt;code&gt;STDERR&lt;/code&gt; , include which program caused the problem, what the failed system call and arguments were, and (VERY IMPORTANT) should contain the standard system error message for what went wrong. Here's a simple but sufficient example:</source>
          <target state="translated">始终检查系统调用的返回码。好的错误消息应该发送到 &lt;code&gt;STDERR&lt;/code&gt; ，包括引起问题的程序，失败的系统调用和参数是什么，并且（非常重要）应包含发生错误的标准系统错误消息。这是一个简单但足够的示例：</target>
        </trans-unit>
        <trans-unit id="5844f1a31b652c47f84d0aaae5c714b741011321" translate="yes" xml:space="preserve">
          <source>Always commit changes to config variables to disk?</source>
          <target state="translated">总是将对配置变量的更改提交到磁盘上?</target>
        </trans-unit>
        <trans-unit id="cd2fdc72c972de55363038192e944aae07f2f5ef" translate="yes" xml:space="preserve">
          <source>Always decompose on the way in, then recompose on the way out.</source>
          <target state="translated">总是在进来的时候分解,然后在出去的时候重新分解。</target>
        </trans-unit>
        <trans-unit id="8c61fff2e0b1e2b49630e69bc2a2e99ec24ecff3" translate="yes" xml:space="preserve">
          <source>Always explicitly and immediately call close() on the writable end of any pipe, unless that process is actually writing to it. Even if you don't explicitly call close(), Perl will still close() all filehandles during global destruction. As previously discussed, if those filehandles have been opened with Safe Pipe Open, this will result in calling waitpid(), which may again deadlock.</source>
          <target state="translated">总是显式地立即调用任何管道的可写端close(),除非该进程确实在向它写东西。即使不显式地调用close(),Perl仍然会在全局销毁期间关闭()所有文件柄。正如前面所讨论的,如果这些文件柄已经用Safe Pipe Open打开了,这将导致调用waitpid(),这可能会再次出现死锁。</target>
        </trans-unit>
        <trans-unit id="242eddbfa115df236054209d0570301b5af3c68e" translate="yes" xml:space="preserve">
          <source>Always place the START_MY_CXT macro directly after the declaration of &lt;code&gt;my_cxt_t&lt;/code&gt; .</source>
          <target state="translated">始终在声明 &lt;code&gt;my_cxt_t&lt;/code&gt; 之后直接放置START_MY_CXT宏。</target>
        </trans-unit>
        <trans-unit id="33f26e154493acc9e3d45671d863271e7464d39e" translate="yes" xml:space="preserve">
          <source>Always strive to remain compatible with previous released versions. Otherwise try to add a mechanism to revert to the old behavior if people rely on it. Document incompatible changes.</source>
          <target state="translated">总是努力保持与以前发布的版本兼容。否则,如果人们依赖旧的行为,尽量添加一个机制来恢复它。记录不兼容的变化。</target>
        </trans-unit>
        <trans-unit id="1c41f11cd18971bbdb3e2ef9969d459e5296677c" translate="yes" xml:space="preserve">
          <source>Always try to check and verify signatures if a SIGNATURE file is in the package and Module::Signature is installed (yes/no)?</source>
          <target state="translated">如果包中有SIGNATURE文件并且安装了Module::Signature,总是尝试检查和验证签名(是/否)?</target>
        </trans-unit>
        <trans-unit id="24f1e77216b2edc00da08bfb70769a17a94800b4" translate="yes" xml:space="preserve">
          <source>Always try to show upload date with 'd' and 'm' command (yes/no)?</source>
          <target state="translated">总是尝试用'd'和'm'命令显示上传日期(是/否)?</target>
        </trans-unit>
        <trans-unit id="ab3692e008452cea5b34a3fe52ad03c81207161c" translate="yes" xml:space="preserve">
          <source>Always use &lt;b&gt;-w&lt;/b&gt;.</source>
          <target state="translated">始终使用&lt;b&gt;-w&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="8367b54257a55d960e03d572f3ffce6e4f988276" translate="yes" xml:space="preserve">
          <source>Always use with a subtag. Notable forms: {sgn-gb} British Sign Language (BSL); {sgn-ie} Irish Sign Language (ESL); {sgn-ni} Nicaraguan Sign Language (ISN); {sgn-us} American Sign Language (ASL).</source>
          <target state="translated">一定要和子标签一起使用。值得注意的形式:{sgn-gb}。{sgn-gb}英国手语(BSL);{sgn-ie}。爱尔兰手语(ESL);{sgn-ni}。尼加拉瓜手语(ISN);{sgn-us}。美国手语(ASL);</target>
        </trans-unit>
        <trans-unit id="d7fc26ae93e0cf00af5e88a1fe69971068f3bf0a" translate="yes" xml:space="preserve">
          <source>Ambiguous Local Times (DST)</source>
          <target state="translated">模糊的当地时间(DST)</target>
        </trans-unit>
        <trans-unit id="b61e588022eb4910c7d278a411480210f9347590" translate="yes" xml:space="preserve">
          <source>Ambulation.pm</source>
          <target state="translated">Ambulation.pm</target>
        </trans-unit>
        <trans-unit id="7dec8f79f324daec9e2bc3cec19154d9b44d20cf" translate="yes" xml:space="preserve">
          <source>Amiga Developers Environment</source>
          <target state="translated">Amiga开发者环境</target>
        </trans-unit>
        <trans-unit id="7eb77f842d900a2dedf7fde5ab4f77cd221a01f3" translate="yes" xml:space="preserve">
          <source>Amiga,</source>
          <target state="translated">Amiga,</target>
        </trans-unit>
        <trans-unit id="3c76575f93cf9b6439e5c8c228d14871841f2be6" translate="yes" xml:space="preserve">
          <source>Among IBM EBCDIC character code sets there are 13 characters that are often mapped to different integer values. Those characters are known as the 13 &quot;variant&quot; characters and are:</source>
          <target state="translated">在IBM EBCDIC字符代码集中,有13个字符经常被映射成不同的整数值。这些字符被称为13个 &quot;变体 &quot;字符,它们是:</target>
        </trans-unit>
        <trans-unit id="dc547e0c079def6202bb164de4204e6fef69df9c" translate="yes" xml:space="preserve">
          <source>Amongst the changes made for OS/2 are...</source>
          <target state="translated">在为OS/2所做的改变中,有...</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="a57b3b45aeac822e093194b4bfd981f0e59fb655" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing no &quot;=item&quot; paragraphs at all, and containing only some number of ordinary/verbatim paragraphs, and possibly also some nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions. Such an itemless &quot;=over&quot; ... &quot;=back&quot; region in Pod is equivalent in meaning to a &quot;&amp;lt;blockquote&amp;gt;...&amp;lt;/blockquote&amp;gt;&quot; element in HTML.</source>
          <target state="translated">一个&amp;ldquo; = over&amp;rdquo; ...&amp;ldquo; = back&amp;rdquo;区域，根本不包含任何&amp;ldquo; = item&amp;rdquo;段落，并且仅包含一些普通/普通段落，还可能包含一些嵌套的&amp;ldquo; = over&amp;rdquo; ...&amp;ldquo; = back&amp;rdquo;区域，&amp;ldquo; = for ...&amp;rdquo;段落和&amp;ldquo; = begin&amp;rdquo; ...&amp;ldquo; = end&amp;rdquo;区域。Pod中这种无项目的&amp;ldquo; = over&amp;rdquo; ...&amp;ldquo; = back&amp;rdquo;区域在含义上等同于HTML中的&amp;ldquo; &amp;lt;blockquote&amp;gt; ... &amp;lt;/ blockquote&amp;gt;&amp;rdquo;元素。</target>
        </trans-unit>
        <trans-unit id="a1fa998f4d85fe0a03c929b0df6c0b9a9c55bdd0" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &quot;=item *&quot; commands, each followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions.</source>
          <target state="translated">一个&quot;=over&quot;...&quot;=back &quot;区域只包含&quot;=item *&quot;命令,每个命令后面都有一些普通/逐字段,其他嵌套的&quot;=over&quot;...。&quot;=back &quot;区域只包含&quot;=item *&quot;命令,每个命令后面都有一些普通/逐字段,其他嵌套的&quot;=over&quot;.&quot;=back &quot;区域,&quot;=for...&quot;段,以及&quot;=begin&quot;.&quot;=end &quot;区域。&quot;=回 &quot;区域、&quot;=for.&quot;段落和&quot;=begin&quot;...&quot;=end &quot;区域。</target>
        </trans-unit>
        <trans-unit id="f7c11a0a43a54d0c5011769a3613a3b8e32e4b7f" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &quot;=item [text]&quot; commands, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, or &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions.</source>
          <target state="translated">一个&quot;=over&quot;.&quot;=back &quot;区域,只包含&quot;=item[text]&quot;命令,每个命令(或每组命令)后面是一些普通/逐字段,其他嵌套的&quot;=over&quot;.。&quot;=back &quot;区域只包含&quot;=项[案文]&quot;命令,每个命令(或每组命令)后面都有一些普通/逐字段,其他嵌套的&quot;=over&quot;.&quot;=back &quot;区域,或&quot;=for.&quot;段落,以及&quot;=begin&quot;.&quot;=end &quot;区域。&quot;=back &quot;区域,或&quot;=for.&quot;段落,以及&quot;=begin&quot;.&quot;=end &quot;区域。</target>
        </trans-unit>
        <trans-unit id="bf06369b3eb3e5c957377be368c2f7244136f0a8" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; paragraphs, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and/or &quot;=begin&quot;...&quot;=end&quot; codes. Note that the numbers must start at 1 in each section, and must proceed in order and without skipping numbers.</source>
          <target state="translated">一个&amp;ldquo; = over&amp;rdquo; ...&amp;ldquo; = back&amp;rdquo;区域，仅包含 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; 段落，每个段落（或其每组）后跟一些普通/普通段落，其他嵌套的&amp;ldquo; = over&amp;rdquo; ...&amp;ldquo; = back&amp;rdquo;区域，&amp;ldquo; = for ...&amp;rdquo;段落和/或&amp;ldquo; = begin&amp;rdquo; ...&amp;ldquo; = end&amp;rdquo;代码。请注意，每个部分中的数字必须从1开始，并且必须按顺序进行且不能跳过数字。</target>
        </trans-unit>
        <trans-unit id="9c821406e2ce644bf837234397ad75d8f26b35cf" translate="yes" xml:space="preserve">
          <source>An &quot;independent&quot; subexpression, one which matches the substring that a</source>
          <target state="translated">一个 &quot;独立 &quot;的子表达式,它与一个 &quot;独立 &quot;的子串相匹配。</target>
        </trans-unit>
        <trans-unit id="3a02e2541679357b758fec91e5c00ccb84d49cd8" translate="yes" xml:space="preserve">
          <source>An &quot;internal&quot; derivative of &quot;perlio&quot; which can be used to provide Unread() function for layers which have no buffer or cannot be bothered. (Basically this layer's &lt;code&gt;Fill()&lt;/code&gt; pops itself off the stack and so resumes reading from layer below.)</source>
          <target state="translated">&amp;ldquo; perlio&amp;rdquo;的&amp;ldquo;内部&amp;rdquo;派生词，可用于为没有缓冲区或无法打扰的图层提供Unread（）函数。（基本上，该层的 &lt;code&gt;Fill()&lt;/code&gt; 将自身弹出堆栈，因此可以从下面的层继续读取。）</target>
        </trans-unit>
        <trans-unit id="94f93318c67b8e306fa7a939182b6dc1a8d99788" translate="yes" xml:space="preserve">
          <source>An &quot;internal&quot; method, subject to change, currently called to allow an overriding class to cache information that will then be passed into all the &lt;code&gt;*param*&lt;/code&gt; calls. (Yes, having to read the source to make sense of this is considered a known bug).</source>
          <target state="translated">可能会更改的&amp;ldquo;内部&amp;rdquo;方法，当前会被调用以允许覆盖的类缓存信息，这些信息随后将传递给所有 &lt;code&gt;*param*&lt;/code&gt; 调用。（是的，必须阅读源代码才能理解这是一个已知的错误）。</target>
        </trans-unit>
        <trans-unit id="c723dc089a4e0462d0565d4c223eb6a79ebcd3aa" translate="yes" xml:space="preserve">
          <source>An $eol of &quot;&quot; (the empty string) is special. In this case, no &quot;soft line breaks&quot; are introduced and binary mode is effectively enabled so that any &quot;\n&quot; in the original data is encoded as well.</source>
          <target state="translated">一个$eol为&quot;&quot;(空字符串)是特殊的。在这种情况下,没有引入 &quot;软换行&quot;,二进制模式被有效地启用,因此原始数据中的任何&quot;\n &quot;也会被编码。</target>
        </trans-unit>
        <trans-unit id="7efa71e97154f5e1c53935b4d4b0410d3433b623" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;XSUB&lt;/b&gt; forms the basic unit of the XS interface. After compilation by the &lt;b&gt;xsubpp&lt;/b&gt; compiler, each XSUB amounts to a C function definition which will provide the glue between Perl calling conventions and C calling conventions.</source>
          <target state="translated">一个&lt;b&gt;XSUB&lt;/b&gt;形成XS接口的基本单元。由&lt;b&gt;xsubpp&lt;/b&gt;编译器编译后，每个XSUB等于一个C函数定义，它将提供Perl调用约定和C调用约定之间的粘合。</target>
        </trans-unit>
        <trans-unit id="09718e49ee8b20061f562ba9e5c34673e940b8ad" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;anonymous&lt;/b&gt; subroutine that, when a reference to it is generated at runtime, keeps track of the identities of externally visible &lt;b&gt;lexical variables&lt;/b&gt;, even after those lexical variables have supposedly gone out of &lt;b&gt;scope&lt;/b&gt;. They&amp;rsquo;re called &amp;ldquo;closures&amp;rdquo; because this sort of behavior gives mathematicians a sense of closure.</source>
          <target state="translated">一个&lt;b&gt;匿名&lt;/b&gt;子例程，当在运行时生成对它的引用时，即使在那些词法变量超出&lt;b&gt;范围的情况下&lt;/b&gt;，它也跟踪外部可见的&lt;b&gt;词法变量&lt;/b&gt;的标识。之所以称为&amp;ldquo;封闭&amp;rdquo;，是因为这种行为使数学家感到封闭。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9e2f49be17e25fca915fffd9825b7a69527fa78a" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;argument&lt;/b&gt;-passing mechanism in which the &lt;b&gt;formal arguments&lt;/b&gt; refer directly to the &lt;b&gt;actual arguments&lt;/b&gt;, and the &lt;b&gt;subroutine&lt;/b&gt; can change the actual arguments by changing the formal arguments. That is, the formal argument is an &lt;b&gt;alias&lt;/b&gt; for the actual argument. See also &lt;b&gt;call by value&lt;/b&gt;.</source>
          <target state="translated">一种&lt;b&gt;参数&lt;/b&gt;传递机制，其中&lt;b&gt;形式参数&lt;/b&gt;直接引用&lt;b&gt;实际参数&lt;/b&gt;，&lt;b&gt;子例程&lt;/b&gt;可以通过更改形式参数来更改实际参数。也就是说，形式参数是实际参数的&lt;b&gt;别名&lt;/b&gt;。另请参见&lt;b&gt;按值调用&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="4e9ca74e5eb3ceca0031d5a290a9926f188e9f44" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;argument&lt;/b&gt;-passing mechanism in which the &lt;b&gt;formal arguments&lt;/b&gt; refer to a copy of the &lt;b&gt;actual arguments&lt;/b&gt;, and the &lt;b&gt;subroutine&lt;/b&gt; cannot change the actual arguments by changing the formal arguments. See also &lt;b&gt;call by reference&lt;/b&gt;.</source>
          <target state="translated">一种&lt;b&gt;说法&lt;/b&gt; -passing机构，其中，&lt;b&gt;形式参数&lt;/b&gt;指的副本&lt;b&gt;实际参数&lt;/b&gt;和&lt;b&gt;子程序&lt;/b&gt;不能改变形式参数改变实际参数。另请参阅&lt;b&gt;按引用致电&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="3ae7537da81b89a37f1fba19db52f45ea5a64265" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that peeks at the string to the left of the current match location.</source>
          <target state="translated">在当前匹配位置左侧偷看字符串的&lt;b&gt;断言&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="9186a718ac3c2fd4c0066859c2036b1188f86bf7" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that peeks at the string to the right of the current match location.</source>
          <target state="translated">在当前匹配位置右侧偷看字符串的&lt;b&gt;断言&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="fccd6c0eca3ee2fd48a0479b2f7467ef677a981b" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that states something exists and perhaps describes what it&amp;rsquo;s like, without giving any commitment as to how or where you&amp;rsquo;ll use it. A declaration is like the part of your recipe that says, &amp;ldquo;two cups flour, one large egg, four or five tadpoles&amp;hellip;&amp;rdquo; See &lt;b&gt;statement&lt;/b&gt; for its opposite. Note that some declarations also function as statements. Subroutine declarations also act as definitions if a body is supplied.</source>
          <target state="translated">&lt;b&gt;声明&lt;/b&gt;某事物存在的&lt;b&gt;断言&lt;/b&gt;，也许描述了它的样子，但未对使用方式或使用地点做出任何承诺。声明就像食谱中的部分一样：&amp;ldquo;两杯面粉，一个大鸡蛋，四个或五个t&amp;hellip;&amp;hellip;&amp;rdquo;参见相反的&lt;b&gt;说法&lt;/b&gt;。请注意，某些声明也可以用作语句。如果提供了主体，则子例程声明也可以用作定义。</target>
        </trans-unit>
        <trans-unit id="a79df62ffe9655f3bb9b573a11129a38c97d9727" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;attribute&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;; data stored with the particular object rather than with the class as a whole.</source>
          <target state="translated">一个&lt;b&gt;属性&lt;/b&gt;的的&lt;b&gt;对象&lt;/b&gt; ; 与特定对象而不是整个类一起存储的数据。</target>
        </trans-unit>
        <trans-unit id="6b5c38c6212536b2650f8fd4b5e6e9c46fa7ac78" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;expression&lt;/b&gt; that evaluates to something that can be used as a &lt;b&gt;filehandle&lt;/b&gt;: a &lt;b&gt;string&lt;/b&gt; (filehandle name), a &lt;b&gt;typeglob&lt;/b&gt;, a typeglob &lt;b&gt;reference&lt;/b&gt;, or a low-level &lt;b&gt;IO&lt;/b&gt; object.</source>
          <target state="translated">该&lt;b&gt;表达式的&lt;/b&gt;计算结果可以用作&lt;b&gt;文件句柄&lt;/b&gt;：&lt;b&gt;字符串&lt;/b&gt;（文件句柄名称），&lt;b&gt;typeglob&lt;/b&gt;，typeglob &lt;b&gt;引用&lt;/b&gt;或低级&lt;b&gt;IO&lt;/b&gt;对象。</target>
        </trans-unit>
        <trans-unit id="a9ea33da0846dba2dfc2c719e640a6b936943a76" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;expression&lt;/b&gt; that yields a &lt;b&gt;value&lt;/b&gt; that an &lt;b&gt;operator&lt;/b&gt; operates on. See also &lt;b&gt;precedence&lt;/b&gt;.</source>
          <target state="translated">的&lt;b&gt;表达&lt;/b&gt;能产生一个&lt;b&gt;值&lt;/b&gt;，一个&lt;b&gt;操作者&lt;/b&gt;进行操作。另请参见&lt;b&gt;priority&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="cc6a827ebadd37467385c749c36afe5cfe5a720e" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;increment&lt;/b&gt; operator that knows how to bump up ASCII alphabetics as well as numbers.</source>
          <target state="translated">知道如何增加ASCII字母和数字的&lt;b&gt;增量&lt;/b&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="6e6a46de7223236ab22a0ae8657b922fe424257e" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;instance&lt;/b&gt; of a &lt;b&gt;class&lt;/b&gt;. Something that &amp;ldquo;knows&amp;rdquo; what user-defined type (class) it is, and what it can do because of what class it is. Your program can request an object to do things, but the object gets to decide whether it wants to do them or not. Some objects are more accommodating than others.</source>
          <target state="translated">一个&lt;b&gt;类&lt;/b&gt;的&lt;b&gt;实例&lt;/b&gt;。&amp;ldquo;知道&amp;rdquo;用户定义的类型（类）以及由于其是什么类而可以执行的操作。您的程序可以请求一个对象执行操作，但是该对象可以决定是否要执行操作。有些物体比其他物体更容易容纳。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="193974eee4df69740e47a6c9868c573734e793d8" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;object&lt;/b&gt; is a data structure that bundles together data and subroutines which operate on that data. An object's data is called &lt;b&gt;attributes&lt;/b&gt;, and its subroutines are called &lt;b&gt;methods&lt;/b&gt;. An object can be thought of as a noun (a person, a web service, a computer).</source>
          <target state="translated">一个&lt;b&gt;对象&lt;/b&gt;是一个数据结构捆绑数据和子程序，其在该数据一起操作。对象的数据称为&lt;b&gt;属性&lt;/b&gt;，其子例程称为&lt;b&gt;方法&lt;/b&gt;。可以将对象视为名词（一个人，一个Web服务，一台计算机）。</target>
        </trans-unit>
        <trans-unit id="9f3264403f458576129fd753f7da0132d1126157" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; X&lt;code&gt;that looks something like a &lt;b&gt;literal&lt;/b&gt;,
such as the output-grabbing operator, &amp;lt;literal
moreinfo=&quot;none&quot;&lt;/code&gt;`&amp;gt;</source>
          <target state="translated">&lt;code&gt;that looks something like a &lt;b&gt;literal&lt;/b&gt;, such as the output-grabbing operator, &amp;lt;literal moreinfo=&quot;none&quot;&lt;/code&gt; &lt;b&gt;文字&lt;/b&gt;的&lt;b&gt;运算符&lt;/b&gt; X ，例如输出抓取运算符&amp;lt;literal moreinfo =&amp;ldquo; none&amp;rdquo; `&amp;gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e3876b6031a7c1f940174f56c5f7362a7f615429" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; taking three &lt;b&gt;operands&lt;/b&gt;. Sometimes pronounced &lt;b&gt;trinary&lt;/b&gt;.</source>
          <target state="translated">一个&lt;b&gt;运算符&lt;/b&gt;取三个&lt;b&gt;操作数&lt;/b&gt;。有时发音为&lt;b&gt;三元&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="209f1fbbc9e85cade5ad6da705d3c26984c35559" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that comes in between its &lt;b&gt;operands&lt;/b&gt;, such as multiplication in &lt;code&gt;24 * 7&lt;/code&gt; .</source>
          <target state="translated">的&lt;b&gt;操作者&lt;/b&gt;，其之间进来&lt;b&gt;的操作数&lt;/b&gt;，如在乘法 &lt;code&gt;24 * 7&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="463ba99d535672eaf8355ca19021da8d2cf33452" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that does something with a list of values, such as &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;. Usually used for named built-in operators (such as &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;) that do not require parentheses around their &lt;b&gt;argument&lt;/b&gt; list.</source>
          <target state="translated">使用值列表（例如 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; )执行某些&lt;b&gt;操作的运算符&lt;/b&gt;。通常用于命名的内置运算符（例如 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ），这些运算符不需要在&lt;b&gt;参数&lt;/b&gt;列表中加括号。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="de2a4670adc782be015d0bb2ea5ffee02ea42397" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that follows its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;$x++&lt;/code&gt; .</source>
          <target state="translated">一个&lt;b&gt;运营商&lt;/b&gt;遵循它的&lt;b&gt;操作&lt;/b&gt;，如 &lt;code&gt;$x++&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f7f1151c5c90e6fb1284f5e0bc779ad8ed2e33c" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that precedes its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;++$x&lt;/code&gt; .</source>
          <target state="translated">一个&lt;b&gt;运营商&lt;/b&gt;先于它的&lt;b&gt;操作数&lt;/b&gt;，如 &lt;code&gt;++$x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dabe188f0a1b9c27289c477dd8047df3b523cb5a" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that says whether a particular ordering relationship is &lt;b&gt;true&lt;/b&gt; about a pair of &lt;b&gt;operands&lt;/b&gt;. Perl has both numeric and string relational operators. See &lt;b&gt;collating sequence&lt;/b&gt;.</source>
          <target state="translated">一个&lt;b&gt;运算符&lt;/b&gt;，它对一对&lt;b&gt;操作数&lt;/b&gt;说出特定的排序关系是否&lt;b&gt;成立&lt;/b&gt;。Perl同时具有数字和字符串关系运算符。请参阅&lt;b&gt;整理顺序&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="717a4af81f7132fc96e1d23c981f1ff3401e5290" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that surrounds its &lt;b&gt;operand&lt;/b&gt;, like the angle operator, or parentheses, or a hug.</source>
          <target state="translated">一个&lt;b&gt;操作者&lt;/b&gt;围绕其&lt;b&gt;操作数&lt;/b&gt;，如操作者的角度，或括号，或一个拥抱。</target>
        </trans-unit>
        <trans-unit id="355f7096b65520d72731600341dac924b0bb6aad" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that takes two &lt;b&gt;operands&lt;/b&gt;.</source>
          <target state="translated">带有两个&lt;b&gt;操作数&lt;/b&gt;的&lt;b&gt;运算符&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b7885e2c7085b9ecc7bc4fd21946e64edd22e910" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; whose assigned mission in life is to change the value of a &lt;b&gt;variable&lt;/b&gt;.</source>
          <target state="translated">一个&lt;b&gt;运营商&lt;/b&gt;，其分配的任务在生活中改变的价值&lt;b&gt;变量&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="7b3959ebca99af56cd591ab2c731b4edab6ffa5f" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;ordinary paragraph&lt;/b&gt;. A paragraph is an ordinary paragraph if its first line matches neither &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; nor &lt;code&gt;m/\A[ \t]/&lt;/code&gt; ,</source>
          <target state="translated">一个&lt;b&gt;普通款&lt;/b&gt;。如果段落的第一行既不匹配 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; 也不匹配 &lt;code&gt;m/\A[ \t]/&lt;/code&gt; ，则为普通段落。</target>
        </trans-unit>
        <trans-unit id="d98f8de412a14cfe117cc1f33fdf08a188a327cd" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without an argument uses the last file read. Using &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; with empty parentheses is different. It refers to the pseudo file formed from the files listed on the command line and accessed via the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. Since &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn't explicitly opened, as a normal filehandle is, an &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; before &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has been used will cause &lt;code&gt;@ARGV&lt;/code&gt; to be examined to determine if input is available. Similarly, an &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; after &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has returned end-of-file will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from &lt;code&gt;STDIN&lt;/code&gt; ; see &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">没有参数的 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 使用最后读取的文件。将 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 与空括号一起使用是不同的。它是指由命令行上列出的文件形成并通过 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符访问的伪文件。由于未显式打开 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ，因此就像正常的文件句柄一样，使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 之前的 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 将导致检查 &lt;code&gt;@ARGV&lt;/code&gt; 以确定输入是否可用。同样， &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 返回文件结束后的 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 会假定您正在处理另一个 &lt;code&gt;@ARGV&lt;/code&gt; 列表，如果未设置 &lt;code&gt;@ARGV&lt;/code&gt; ，则会从 &lt;code&gt;STDIN&lt;/code&gt; 读取输入; 请参阅&lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;perlop中的I / O运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b538c9784366b2a5b380fc1646cd6d2c36676cbb" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; executed within a subroutine defined in the &lt;code&gt;DB&lt;/code&gt; package doesn't see the usual surrounding lexical scope, but rather the scope of the first non-DB piece of code that called it. You don't normally need to worry about this unless you are writing a Perl debugger.</source>
          <target state="translated">在 &lt;code&gt;DB&lt;/code&gt; 包中定义的子例程中执行的 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; 不会看到通常的周围词汇范围，而是看到了调用它的第一个非DB代码段的范围。除非您正在编写Perl调试器，否则通常不必担心这一点。</target>
        </trans-unit>
        <trans-unit id="9638cc264773db141fdbff9966aa75b61a42b264" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without an argument uses the last file read. Using &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; with empty parentheses is different. It refers to the pseudo file formed from the files listed on the command line and accessed via the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. Since &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn't explicitly opened, as a normal filehandle is, an &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; before &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has been used will cause &lt;code&gt;@ARGV&lt;/code&gt; to be examined to determine if input is available. Similarly, an &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; after &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has returned end-of-file will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from &lt;code&gt;STDIN&lt;/code&gt; ; see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">没有参数的 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 使用最后读取的文件。将 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 与空括号一起使用是不同的。它是指由命令行上列出的文件形成并通过 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符访问的伪文件。由于未显式打开 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ，因此就像正常的文件句柄一样，使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 之前的 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 将导致检查 &lt;code&gt;@ARGV&lt;/code&gt; 以确定输入是否可用。同样， &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 返回文件结束后的 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 会假定您正在处理另一个 &lt;code&gt;@ARGV&lt;/code&gt; 列表，如果未设置 &lt;code&gt;@ARGV&lt;/code&gt; ，则会从 &lt;code&gt;STDIN&lt;/code&gt; 读取输入; 请参阅&lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;perlop中的I / O运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f39d8054296556b4b922794a4d5a34f617f1fc94" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;, however, can see lexical variables of the scope it is being evaluated in, so long as the names aren't hidden by declarations within the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; itself. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 函数，但是，可以看到它是在被评估的范围的词法变量，只要名字被声明的内不隐藏 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 函数本身。参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6342bae4fda60017077e5c45e326240a9752de8d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; executed within a subroutine defined in the &lt;code&gt;DB&lt;/code&gt; package doesn't see the usual surrounding lexical scope, but rather the scope of the first non-DB piece of code that called it. You don't normally need to worry about this unless you are writing a Perl debugger.</source>
          <target state="translated">在 &lt;code&gt;DB&lt;/code&gt; 包中定义的子例程中执行的 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; 不会看到通常的周围词汇范围，而是看到了调用它的第一个非DB代码段的范围。除非您正在编写Perl调试器，否则通常不必担心这一点。</target>
        </trans-unit>
        <trans-unit id="e98b3b90e3045dc3b637b5a6dd09b73503e89407" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares an alias for a package variable that will be visible across its entire lexical scope, even across package boundaries. The package in which the variable is entered is determined at the point of the declaration, not at the point of use. This means the following behavior holds:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明声明了一个包变量，这将是在其整个词法范围可见，甚至可以跨越边界包的别名。输入变量的包是在声明时确定的，而不是在使用时确定的。这意味着以下行为成立：</target>
        </trans-unit>
        <trans-unit id="b85b4821ea02e10c76868c61d73ce67c03c3c58f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration may also have a list of attributes associated with it.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明也可能有与之相关的属性列表。</target>
        </trans-unit>
        <trans-unit id="0e6a38b5837351a0fa7ad12169129c95c04803d4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares an alias for a package variable that will be visible across its entire lexical scope, even across package boundaries. The package in which the variable is entered is determined at the point of the declaration, not at the point of use. This means the following behavior holds:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明声明了一个包变量，这将是在其整个词法范围可见，甚至可以跨越边界包的别名。输入变量的包是在声明时确定的，而不是在使用时确定的。这意味着以下行为成立：</target>
        </trans-unit>
        <trans-unit id="ff67756e1b83b8c246879fd06b2405feac998276" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration may also have a list of attributes associated with it.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明也可能有与之相关的属性列表。</target>
        </trans-unit>
        <trans-unit id="09f284e34c7193100513bdbf0c748168a131c400" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;=item&lt;/code&gt; or &lt;code&gt;=back&lt;/code&gt; command has been found outside a &lt;code&gt;=over&lt;/code&gt; /&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="translated">一个 &lt;code&gt;=item&lt;/code&gt; 或 &lt;code&gt;=back&lt;/code&gt; 命令已经发现外 &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="66cb1e02933a96ffc4b888e742e11e5e2a0810c8" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;END&lt;/code&gt; code block is executed as late as possible, that is, after perl has finished running the program and just before the interpreter is being exited, even if it is exiting as a result of a die() function. (But not if it's morphing into another program via &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, or being blown out of the water by a signal--you have to trap that yourself (if you can).) You may have multiple &lt;code&gt;END&lt;/code&gt; blocks within a file--they will execute in reverse order of definition; that is: last in, first out (LIFO). &lt;code&gt;END&lt;/code&gt; blocks are not executed when you run perl with the &lt;code&gt;-c&lt;/code&gt; switch, or if compilation fails.</source>
          <target state="translated">一个 &lt;code&gt;END&lt;/code&gt; 码块被尽可能晚地，即，是perl的已经完成运行程序和要退出的解释之前之后执行，即使它离开作为模具（）函数的结果。 （但是如果通过 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 转换为另一个程序，或者被信号吹走，则不是（您必须自己捕获（如果可以）。）文件中可能有多个 &lt;code&gt;END&lt;/code&gt; 块，它们将以相反的顺序执行；即：后进先出（LIFO）。使用 &lt;code&gt;-c&lt;/code&gt; 开关运行perl 或编译失败时，将不执行 &lt;code&gt;END&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="2106dcfb583dc95f2d7d0a7530b5308a6cea8ccd" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IO::Handle&lt;/code&gt; object is a reference to a symbol/GLOB reference (see the &lt;code&gt;Symbol&lt;/code&gt; package). Some modules that inherit from &lt;code&gt;IO::Handle&lt;/code&gt; may want to keep object related variables in the hash table part of the GLOB. In an attempt to prevent modules trampling on each other I propose the that any such module should prefix its variables with its own name separated by _'s. For example the IO::Socket module keeps a &lt;code&gt;timeout&lt;/code&gt; variable in 'io_socket_timeout'.</source>
          <target state="translated">一个 &lt;code&gt;IO::Handle&lt;/code&gt; 目的是一个符号/ GLOB基准的基准（参见 &lt;code&gt;Symbol&lt;/code&gt; 包）。继承自 &lt;code&gt;IO::Handle&lt;/code&gt; 某些模块可能希望将与对象相关的变量保留在GLOB的哈希表部分中。为了防止模块相互踩踏，我建议任何这样的模块都应在其变量前加上用_分隔的自己的名称。例如，IO :: Socket模块将 &lt;code&gt;timeout&lt;/code&gt; 变量保留在&amp;ldquo; io_socket_timeout&amp;rdquo;中。</target>
        </trans-unit>
        <trans-unit id="8d4bdf476b3365f09a887c13f6c40076ebfaf6c1" translate="yes" xml:space="preserve">
          <source>An Aside About Smarter and Safer Code</source>
          <target state="translated">关于更智能、更安全的代码的补充说明</target>
        </trans-unit>
        <trans-unit id="dcd29613666219a97f2491f0610be4945ceed298" translate="yes" xml:space="preserve">
          <source>An Example</source>
          <target state="translated">一个例子</target>
        </trans-unit>
        <trans-unit id="f8c1ce33e34656d389a163577db68ecf2ef0ded0" translate="yes" xml:space="preserve">
          <source>An Example -- the NULL termination problem.</source>
          <target state="translated">一个例子--NULL终止问题。</target>
        </trans-unit>
        <trans-unit id="b0338e71cce0b4ccb879ecd4b7099e83ebe3be92" translate="yes" xml:space="preserve">
          <source>An Example: the NULL termination problem.</source>
          <target state="translated">一个例子:NULL终止问题。</target>
        </trans-unit>
        <trans-unit id="8c00947f1047eee3af23c94728ed5ad710d9cb2f" translate="yes" xml:space="preserve">
          <source>An INSTALL file should be included, and should contain simple installation instructions. When using ExtUtils::MakeMaker this will usually be:</source>
          <target state="translated">应该包含一个INSTALL文件,并且应该包含简单的安装说明。当使用ExtUtils::MakeMaker时,这通常是。</target>
        </trans-unit>
        <trans-unit id="c6d4eb0ecab7adc479ea3b6eef3a6aca32ccbec3" translate="yes" xml:space="preserve">
          <source>An OFFSET may be specified to place the read data at some place in the string other than the beginning. A negative OFFSET specifies placement at that many characters counting backwards from the end of the string. A positive OFFSET greater than the length of SCALAR results in the string being padded to the required size with &lt;code&gt;&quot;\0&quot;&lt;/code&gt; bytes before the result of the read is appended.</source>
          <target state="translated">可以指定一个OFFSET以将读取的数据放置在字符串中除开头之外的其他位置。负OFFSET指定从字符串末尾开始倒数的许多字符的位置。大于SCALAR长度的正OFFSET会导致在追加读取结果之前，使用 &lt;code&gt;&quot;\0&quot;&lt;/code&gt; 字节将字符串填充为所需的大小。</target>
        </trans-unit>
        <trans-unit id="0dc3cbd84029f4f613840045b9422510efa87d84" translate="yes" xml:space="preserve">
          <source>An OFFSET may be specified to write the data from some part of the string other than the beginning. A negative OFFSET specifies writing that many characters counting backwards from the end of the string. If SCALAR is of length zero, you can only use an OFFSET of 0.</source>
          <target state="translated">可以指定一个OFFSET,从字符串的某些部分而不是开头写入数据。负的OFFSET指定从字符串的结尾向后数写那么多的字符,如果SCALAR长度为0,则只能使用0的OFFSET。如果SCALAR的长度为0,则只能使用0的OFFSET。</target>
        </trans-unit>
        <trans-unit id="bd9383fdee820dfd7a79259db8339a2ec8fb85d9" translate="yes" xml:space="preserve">
          <source>An Object is Simply a Data Structure</source>
          <target state="translated">对象只是一个数据结构</target>
        </trans-unit>
        <trans-unit id="e69ceb552111cae999e0e9d8f79c888a4e18b2ab" translate="yes" xml:space="preserve">
          <source>An SV (or AV, HV, etc.) is allocated in two parts: the head (struct sv, av, hv...) contains type and reference count information, and for many types, a pointer to the body (struct xrv, xpv, xpviv...), which contains fields specific to each type. Some types store all they need in the head, so don't have a body.</source>
          <target state="translated">一个SV(或AV、HV等)是由两部分分配的:头部(struct sv,av,hv...)包含类型和引用计数信息,对于许多类型来说,还有一个指向主体(struct xrv,xpv,xpviv...)的指针,它包含每个类型特有的字段。有些类型在头部存储了所有需要的信息,所以没有主体。</target>
        </trans-unit>
        <trans-unit id="0db48295b7cb634bd39479ea9baf6751db33420c" translate="yes" xml:space="preserve">
          <source>An SV can be created and loaded with one command. There are five types of values that can be loaded: an integer value (IV), an unsigned integer value (UV), a double (NV), a string (PV), and another scalar (SV). (&quot;PV&quot; stands for &quot;Pointer Value&quot;. You might think that it is misnamed because it is described as pointing only to strings. However, it is possible to have it point to other things. For example, it could point to an array of UVs. But, using it for non-strings requires care, as the underlying assumption of much of the internals is that PVs are just for strings. Often, for example, a trailing &lt;code&gt;NUL&lt;/code&gt; is tacked on automatically. The non-string use is documented only in this paragraph.)</source>
          <target state="translated">可以使用一个命令创建并加载SV。可以加载五种类型的值：整数（IV），无符号整数（UV），双精度（NV），字符串（PV）和另一个标量（SV）。（&amp;ldquo; PV&amp;rdquo;代表&amp;ldquo;指针值&amp;rdquo;。您可能会误认为它是因为它被描述为仅指向字符串。但是，也可能使它指向其他东西。例如，它可以指向一个数组。但是，将其用于非字符串需要特别小心，因为许多内部结构的基本假设是PV仅用于字符串，例如，通常会自动添加尾随的 &lt;code&gt;NUL&lt;/code&gt; 。仅在本段中记录。）</target>
        </trans-unit>
        <trans-unit id="e49daf61f2f4bab338dc0435e2098c4740ae32f6" translate="yes" xml:space="preserve">
          <source>An SV may be passed as a second argument. If so, the name will be assigned to it and it will be returned. Otherwise the returned SV will be a new mortal.</source>
          <target state="translated">SV可以作为第二个参数传递。如果是这样,将为其分配名称,并将其返回。否则,返回的SV将是一个新的凡人。</target>
        </trans-unit>
        <trans-unit id="35a93457850bdbb33ca102c024544fcdc99dd999" translate="yes" xml:space="preserve">
          <source>An XSUB section continues until another section-start keyword is found.</source>
          <target state="translated">一个XSUB节继续进行,直到找到另一个节开始的关键字。</target>
        </trans-unit>
        <trans-unit id="db98408a971f988d838aae97c21a88cbfeff498b" translate="yes" xml:space="preserve">
          <source>An abstract character&amp;rsquo;s integer value. Same thing as &lt;b&gt;codepoint&lt;/b&gt;.</source>
          <target state="translated">抽象字符的整数值。与&lt;b&gt;codepoint&lt;/b&gt;相同。</target>
        </trans-unit>
        <trans-unit id="bd8526c4f7f2f82dc46961c40bfa270781cafa7e" translate="yes" xml:space="preserve">
          <source>An accessor function can be redefined in order to provide additional checking of values, etc. Here, we want the &lt;code&gt;count&lt;/code&gt; element always to be nonnegative, so we redefine the &lt;code&gt;count&lt;/code&gt; accessor accordingly.</source>
          <target state="translated">可以重新定义访问器函数，以提供对值的附加检查，等等。在这里，我们希望 &lt;code&gt;count&lt;/code&gt; 元素始终为非负数，因此我们重新定义了 &lt;code&gt;count&lt;/code&gt; 访问器。</target>
        </trans-unit>
        <trans-unit id="76864d299088548272113a8d31dd2510d163d674" translate="yes" xml:space="preserve">
          <source>An accessor lets you add additional code around attribute access. For example, you could apply a default to an attribute that wasn't set in the constructor, or you could validate that a new value for the attribute is acceptable.</source>
          <target state="translated">访问器让你可以围绕属性访问添加额外的代码。例如,你可以对一个没有在构造函数中设置的属性应用一个默认值,或者你可以验证一个新的属性值是可以接受的。</target>
        </trans-unit>
        <trans-unit id="7f7dfcb0e79b76d6607a032d4c42004b6d846b72" translate="yes" xml:space="preserve">
          <source>An action that terminates a process will terminate</source>
          <target state="translated">终止流程的操作将终止</target>
        </trans-unit>
        <trans-unit id="3d55486b7ae618b0c9e5822b88065546dbd8b09b" translate="yes" xml:space="preserve">
          <source>An actual piece of data, in contrast to all the variables, references, keys, indices, operators, and whatnot that you need to access the value.</source>
          <target state="translated">一个实际的数据,相对于所有的变量、引用、键、索引、运算符什么的,你需要访问这个值。</target>
        </trans-unit>
        <trans-unit id="1e18a14c7435e1ad99b33d06cb67211ccd6f13ff" translate="yes" xml:space="preserve">
          <source>An adjectival pseudofunction that warps the meaning of an &lt;b&gt;lvalue&lt;/b&gt; in some declarative fashion. Currently there are three lvalue modifiers: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一个形容词伪函数，以某种声明方式扭曲&lt;b&gt;左值&lt;/b&gt;的含义。当前有三个左值修饰符： &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ddce428631d662b65df938a0ab59dc6d26df5c3" translate="yes" xml:space="preserve">
          <source>An alias can map to either an official Unicode character name (not a loose matched name) or to a numeric code point (ordinal). The latter is useful for assigning names to code points in Unicode private use areas such as U+E800 through U+F8FF. A numeric code point must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; , it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="translated">别名可以映射到正式的Unicode字符名称（而不是宽松的匹配名称）或数字代码点（常规）。后者对于将名称分配给Unicode专用区域（例如U + E800至U + F8FF）中的代码点很有用。数字代码点必须是非负整数，或者以 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 开头的字符串，其余部分视为十六进制整数。文字数字常量必须是无符号的；如果前导零或包含非十进制十六进制数字，则将其解释为十六进制；否则将被解释为十进制。如果以 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 开头，则将其解释为Unicode代码点；否则，将其解释为Unicode代码点。否则，它将被解释为本地的。 （只有256以下的代码点在Unicode和本机之间可以有所不同。）因此 &lt;code&gt;U+41&lt;/code&gt; 始终是拉丁字母&amp;ldquo; A&amp;rdquo;；但是 &lt;code&gt;0x41&lt;/code&gt; 在EBCDIC平台上可以是&amp;ldquo; NO-BREAK SPACE&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2346eaad655197a010139149e8271c64c649a891" translate="yes" xml:space="preserve">
          <source>An alias for fullname</source>
          <target state="translated">全名的别称</target>
        </trans-unit>
        <trans-unit id="7fe1e0c1ce121b1e661962490b3a8d17f0df008e" translate="yes" xml:space="preserve">
          <source>An alias for hostfqdn ().</source>
          <target state="translated">hostfqdn()的别称。</target>
        </trans-unit>
        <trans-unit id="fa449dd40ff0246bd3a833083086ff6fe9ea989c" translate="yes" xml:space="preserve">
          <source>An alternate (and possibly simpler) method to pushing values on the stack is to use the macro:</source>
          <target state="translated">另一种在堆栈上推送值的方法(可能更简单)是使用宏。</target>
        </trans-unit>
        <trans-unit id="490e5f218f41d502acc0f80b9b4c03244664bdb6" translate="yes" xml:space="preserve">
          <source>An alternate delimiter may be specified using &lt;b&gt;-F&lt;/b&gt;.</source>
          <target state="translated">可以使用&lt;b&gt;-F&lt;/b&gt;指定替代分隔符。</target>
        </trans-unit>
        <trans-unit id="a3cee96423e82840fff05ec16e3bc4bd5558bd28" translate="yes" xml:space="preserve">
          <source>An alternate filename that points to the real &lt;b&gt;filename&lt;/b&gt;, which in turn points to the real &lt;b&gt;file&lt;/b&gt;. Whenever the &lt;b&gt;operating system&lt;/b&gt; is trying to parse a &lt;b&gt;pathname&lt;/b&gt; containing a symbolic link, it merely substitutes the new name and continues parsing.</source>
          <target state="translated">备用文件名，它指向真实&lt;b&gt;文件名&lt;/b&gt;，而真实&lt;b&gt;文件名&lt;/b&gt;又指向真实&lt;b&gt;文件&lt;/b&gt;。每当&lt;b&gt;操作系统&lt;/b&gt;尝试解析包含符号链接的&lt;b&gt;路径名时&lt;/b&gt;，它仅替换新名称并继续解析。</target>
        </trans-unit>
        <trans-unit id="567849086db2a3773d0ebaa265c330619cbbb371" translate="yes" xml:space="preserve">
          <source>An alternate interface to Filter::Util::Call is now available. See &lt;a href=&quot;../simple&quot;&gt;Filter::Simple&lt;/a&gt; for more details.</source>
          <target state="translated">Filter :: Util :: Call的备用接口现在可用。有关更多详细信息，请参见&lt;a href=&quot;../simple&quot;&gt;Filter :: Simple&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="675501f93d17028172930c214a15945683c8e504" translate="yes" xml:space="preserve">
          <source>An alternative approach to cache flushing is to use the &lt;code&gt;HASH&lt;/code&gt; option (see above) to request that &lt;code&gt;Memoize&lt;/code&gt; use a particular hash variable as its cache. Then you can examine or modify the hash at any time in any way you desire. You may flush the cache by using &lt;code&gt;%hash = ()&lt;/code&gt; .</source>
          <target state="translated">缓存刷新的另一种方法是使用 &lt;code&gt;HASH&lt;/code&gt; 选项（请参见上文）来请求 &lt;code&gt;Memoize&lt;/code&gt; 使用特定的哈希变量作为其缓存。然后，您可以随时以所需的任何方式检查或修改哈希。您可以使用 &lt;code&gt;%hash = ()&lt;/code&gt; 刷新缓存。</target>
        </trans-unit>
        <trans-unit id="b2fe156c5b22968eab0fbdde266b1268db8760ef" translate="yes" xml:space="preserve">
          <source>An alternative is CamelBones, a framework that allows access to both Foundation and AppKit classes and objects, so that full GUI applications can be built in Perl. CamelBones can be found on SourceForge, at &lt;a href=&quot;http://www.sourceforge.net/projects/camelbones/&quot;&gt;http://www.sourceforge.net/projects/camelbones/&lt;/a&gt;.</source>
          <target state="translated">另一种选择是CamelBones，该框架允许访问Foundation和AppKit类和对象，从而可以在Perl中构建完整的GUI应用程序。可以在SourceForge的&lt;a href=&quot;http://www.sourceforge.net/projects/camelbones/&quot;&gt;http://www.sourceforge.net/projects/camelbones/&lt;/a&gt;上找到CamelBones 。</target>
        </trans-unit>
        <trans-unit id="adf70c06c68960fa2b5ce48b474675e096b9430d" translate="yes" xml:space="preserve">
          <source>An alternative method of debugging regexps is to embed &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; statements within the regexp. This provides a blow-by-blow account of the backtracking in an alternation:</source>
          <target state="translated">调试正则表达式的另一种方法是将 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 语句嵌入正则表达式中。这提供了轮流回溯的交替介绍：</target>
        </trans-unit>
        <trans-unit id="bf78a032596f44477dfca0392a1f37e462bfc42f" translate="yes" xml:space="preserve">
          <source>An alternative to using substr() as an lvalue is to specify the replacement string as the 4th argument. This allows you to replace parts of the EXPR and return what was there before in one operation, just as you can with splice().</source>
          <target state="translated">使用substr()作为l值的替代方法是指定替换字符串作为第4个参数。这允许您替换EXPR的部分内容,并在一次操作中返回之前的内容,就像您使用splice()一样。</target>
        </trans-unit>
        <trans-unit id="25b5286961be13762e984cfd1189ea7a9bb06d7a" translate="yes" xml:space="preserve">
          <source>An alternative to writing the filter in C is to create a separate executable in the language of your choice. The separate executable reads from standard input, does whatever processing is necessary, and writes the filtered data to standard output. &lt;code&gt;Filter::cpp&lt;/code&gt; is an example of a source filter implemented as a separate executable - the executable is the C preprocessor bundled with your C compiler.</source>
          <target state="translated">用C语言编写过滤器的另一种方法是使用您选择的语言创建一个单独的可执行文件。单独的可执行文件从标准输入读取，进行必要的处理，然后将过滤后的数据写入标准输出。 &lt;code&gt;Filter::cpp&lt;/code&gt; 是作为独立可执行文件实现的源过滤器的示例-可执行文件是与C编译器捆绑在一起的C预处理程序。</target>
        </trans-unit>
        <trans-unit id="9216315bb2214d5ed94f6db6fec42532477a8283" translate="yes" xml:space="preserve">
          <source>An alternative way of writing something more easily; a shortcut.</source>
          <target state="translated">一种比较容易写出东西的另一种方式;一种捷径。</target>
        </trans-unit>
        <trans-unit id="f6ef70866e892e0391f54f3f0e595fde0691ccb0" translate="yes" xml:space="preserve">
          <source>An anchor useful in basic regexps is the</source>
          <target state="translated">一个在基本的regexps中有用的锚是</target>
        </trans-unit>
        <trans-unit id="a941741e26d01bf48e71deca7cfe67d745df0d18" translate="yes" xml:space="preserve">
          <source>An anonymous array of alternative library specifications to be searched for (in order) until at least one library is found. E.g.</source>
          <target state="translated">一个匿名的备选库规格数组,用于搜索(按顺序),直到至少找到一个库。例如</target>
        </trans-unit>
        <trans-unit id="c253698bf9e4f75c2b5d0a18558b851f2d3f6b5e" translate="yes" xml:space="preserve">
          <source>An application that takes the trouble to use information in &lt;code&gt;LC_MONETARY&lt;/code&gt; may format debits as if they were credits and vice versa if that locale has been subverted. Or it might make payments in US dollars instead of Hong Kong dollars.</source>
          <target state="translated">麻烦使用 &lt;code&gt;LC_MONETARY&lt;/code&gt; 中的信息的应用程序可能会格式化借方，就好像它们是贷方，反之亦然，如果该语言环境已被颠覆。或者，它可能以美元而不是港元付款。</target>
        </trans-unit>
        <trans-unit id="01ac9da7b76fdd816e4e95bf07e705af326d0f2c" translate="yes" xml:space="preserve">
          <source>An application using Module can say something like:</source>
          <target state="translated">一个使用Module的应用程序可以说这样的话。</target>
        </trans-unit>
        <trans-unit id="a335ab967a8e1f5c521e6fbf8a762d039a0699ab" translate="yes" xml:space="preserve">
          <source>An archaic expression for what is more correctly referred to as &lt;b&gt;list context&lt;/b&gt;.</source>
          <target state="translated">一种更正确的&lt;b&gt;列表上下文&lt;/b&gt;的过时表达。</target>
        </trans-unit>
        <trans-unit id="7dd0ff3c6abfb69f462a62c5017ae088c797d806" translate="yes" xml:space="preserve">
          <source>An argument can be ignored by omitting the main part of the name from a parameter declaration, leaving just a bare &lt;code&gt;$&lt;/code&gt; sigil. For example,</source>
          <target state="translated">可以通过在参数声明中省略名称的主要部分来忽略自变量，仅留下 &lt;code&gt;$&lt;/code&gt; sigil。例如，</target>
        </trans-unit>
        <trans-unit id="3f5cfd48537bc41203499ec678c7f8d1ffcc4184" translate="yes" xml:space="preserve">
          <source>An argument line supplying values to plug into the previous picture line.</source>
          <target state="translated">一个参数行,提供插入前一个图片行的值。</target>
        </trans-unit>
        <trans-unit id="e1318b0f2b2dd2f7e8a55cad33c819c262a23ea1" translate="yes" xml:space="preserve">
          <source>An array can also change its length:</source>
          <target state="translated">一个数组也可以改变其长度。</target>
        </trans-unit>
        <trans-unit id="a7633012ecb371a2113d013c22d2c030bb2a3192" translate="yes" xml:space="preserve">
          <source>An array can be accessed one scalar at a time by specifying a dollar sign (&lt;code&gt;$&lt;/code&gt; ), then the name of the array (without the leading &lt;code&gt;@&lt;/code&gt; ), then the subscript inside square brackets. For example:</source>
          <target state="translated">通过指定美元符号（ &lt;code&gt;$&lt;/code&gt; ），数组名称（不带 &lt;code&gt;@&lt;/code&gt; ），方括号内的下标，可以一次访问一个标量。例如：</target>
        </trans-unit>
        <trans-unit id="015711954685a7b3ea99a44f6e657f520fa53416" translate="yes" xml:space="preserve">
          <source>An array of an array is just a regular old array @AoA that you can get at with two subscripts, like &lt;code&gt;$AoA[3][2]&lt;/code&gt; . Here's a declaration of the array:</source>
          <target state="translated">数组的数组只是一个常规的旧数组@AoA，您可以使用两个下标来获取它们，例如 &lt;code&gt;$AoA[3][2]&lt;/code&gt; 。这是数组的声明：</target>
        </trans-unit>
        <trans-unit id="9aee3421650400587ce5406d39d397928a2add0e" translate="yes" xml:space="preserve">
          <source>An array of constants' names, either scalars containing names, or hashrefs as detailed in &lt;a href=&quot;#C_constant&quot;&gt;C_constant&lt;/a&gt;.</source>
          <target state="translated">常量名称的数组，常量可以是包含名称的标量，也可以是C_constant中详细说明的&lt;a href=&quot;#C_constant&quot;&gt;hashrefs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4dbdb6c0876baa594d12d6a72f40a78381bda16" translate="yes" xml:space="preserve">
          <source>An array of file names for the shared objects that were loaded.</source>
          <target state="translated">被加载的共享对象的文件名数组。</target>
        </trans-unit>
        <trans-unit id="26930aebfa1fee021fd440dae3cf343080566995" translate="yes" xml:space="preserve">
          <source>An array of module (package) names that have been bootstrap'ed.</source>
          <target state="translated">已被引导的模块(包)名称的数组。</target>
        </trans-unit>
        <trans-unit id="792d37106ab796a9da516b2cfe4619175268f4f1" translate="yes" xml:space="preserve">
          <source>An array of patches on CPAN or on the local disk to be applied in order via an external patch program. If the value for the &lt;code&gt;-p&lt;/code&gt; parameter is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; is determined by reading the patch beforehand. The path to each patch is either an absolute path on the local filesystem or relative to a patch directory specified in the &lt;code&gt;patches_dir&lt;/code&gt; configuration variable or in the format of a canonical distro name. For examples please consult the distroprefs/ directory in the CPAN.pm distribution (these examples are not installed by default).</source>
          <target state="translated">CPAN或本地磁盘上的修补程序阵列，可通过外部修补程序按顺序应用。 &lt;code&gt;-p&lt;/code&gt; 参数的值是 &lt;code&gt;0&lt;/code&gt; 还是 &lt;code&gt;1&lt;/code&gt; 是通过事先阅读补丁来确定的。每个补丁程序的路径要么是本地文件系统上的绝对路径，要么是相对于 &lt;code&gt;patches_dir&lt;/code&gt; 配置变量中指定的补丁程序目录的相对路径，或者是规范发行版名称的格式。有关示例，请查阅CPAN.pm发行版中的distroprefs /目录（默认情况下未安装这些示例）。</target>
        </trans-unit>
        <trans-unit id="b89f1be8b64b665e2888aa36341ca67f3fc8a573" translate="yes" xml:space="preserve">
          <source>An array of the handles returned by successful calls to dl_load_file(), made by bootstrap, in the order in which they were loaded. Can be used with dl_find_symbol() to look for a symbol in any of the loaded files.</source>
          <target state="translated">由bootstrap成功调用dl_load_file()后返回的句柄数组,按照加载顺序排列。可以和dl_find_symbol()一起使用,在任何一个加载的文件中寻找一个符号。</target>
        </trans-unit>
        <trans-unit id="2042400b9cf51420ca0bb02f4a95651f7d9e0fc1" translate="yes" xml:space="preserve">
          <source>An array represents a list of values:</source>
          <target state="translated">一个数组代表一个值的列表。</target>
        </trans-unit>
        <trans-unit id="d58bf09473fcb443f32238cd3f343fe1cb52e884" translate="yes" xml:space="preserve">
          <source>An array with multiple subscripts for finding a single element. Perl implements these using &lt;b&gt;references&lt;/b&gt;&amp;mdash;see Camel chapter 9, &amp;ldquo;Data Structures&amp;rdquo;.</source>
          <target state="translated">具有多个下标的数组，用于查找单个元素。Perl使用&lt;b&gt;参考来&lt;/b&gt;实现这些功能，请&lt;b&gt;参见&lt;/b&gt; Camel第9章&amp;ldquo;数据结构&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e730b7563caa7a9a3615b79242bd88575f2b5d2f" translate="yes" xml:space="preserve">
          <source>An attempt to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require $module&quot;&lt;/code&gt; failed, even though the list of extensions indicated that it should succeed. Correct by conducting a proper installation.</source>
          <target state="translated">尝试 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require $module&quot;&lt;/code&gt; 失败，即使扩展列表表明应该成功。通过进行正确的安装进行纠正。</target>
        </trans-unit>
        <trans-unit id="8668d93103d45211068cbb7aa1991bd63b959bd9" translate="yes" xml:space="preserve">
          <source>An attempt to allocate memory failed.</source>
          <target state="translated">试图分配内存失败。</target>
        </trans-unit>
        <trans-unit id="4965e597a6abdfe2d520970b55b8363275b2a451" translate="yes" xml:space="preserve">
          <source>An attempt to set an unrecognized attribute is a fatal error. (The error is trappable, but it still stops the compilation within that &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;.) Setting an attribute with a name that's all lowercase letters that's not a built-in attribute (such as &quot;foo&quot;) will result in a warning with &lt;b&gt;-w&lt;/b&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'reserved'&lt;/code&gt; .</source>
          <target state="translated">尝试设置无法识别的属性是一个致命错误。（该错误是可捕获的，但仍会在该 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 中停止编译。）将属性设置为全都是小写字母的名称，而不是内置属性（例如&amp;ldquo; foo&amp;rdquo;），将导致显示&lt;b&gt;-w&lt;/b&gt;或警告。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'reserved'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93c1784b7ddee55af5b75a4bf233031106bc926c" translate="yes" xml:space="preserve">
          <source>An attribute handler was specified with an &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt;, but the type of referent it was defined to handle wasn't one of the five permitted: &lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; , &lt;code&gt;CODE&lt;/code&gt; , or &lt;code&gt;ANY&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt; 指定了一个属性处理程序，但是定义为处理的引用对象的类型不是所允许的五种之一： &lt;code&gt;SCALAR&lt;/code&gt; ， &lt;code&gt;ARRAY&lt;/code&gt; ， &lt;code&gt;HASH&lt;/code&gt; ， &lt;code&gt;CODE&lt;/code&gt; 或 &lt;code&gt;ANY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ed24a1addfea7e1a18f9560990ecafe644b6003" translate="yes" xml:space="preserve">
          <source>An attribute is a piece of data belonging to a particular object. Unlike most object-oriented languages, Perl provides no special syntax or support for declaring and manipulating attributes.</source>
          <target state="translated">属性是属于一个特定对象的一段数据。与大多数面向对象的语言不同,Perl并没有为属性的声明和操作提供特殊的语法或支持。</target>
        </trans-unit>
        <trans-unit id="4774fb20b25b2c00d90761710a32f25902ad2435" translate="yes" xml:space="preserve">
          <source>An attribute list is a sequence of attribute specifications, separated by whitespace or a colon (with optional whitespace). Each attribute specification is a simple name, optionally followed by a parenthesised parameter list. If such a parameter list is present, it is scanned past as for the rules for the &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; operator. (See &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;.) The parameter list is passed as it was found, however, and not as per &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">属性列表是一系列属性说明，用空格或冒号（带有可选的空格）分隔。每个属性规范都是一个简单的名称，可以选择后面跟一个带括号的参数列表。如果存在这样的参数列表，则按照 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; 运算符的规则进行扫描。 （请参阅&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;perlop中的Quote和类似Quote的运算符&lt;/a&gt;。）但是，参数列表是按发现时传递的，而不是按照 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; 传递。</target>
        </trans-unit>
        <trans-unit id="b6ff4a009f82a7cfb00247fff66222df5571297d" translate="yes" xml:space="preserve">
          <source>An effect similar to &lt;code&gt;(?&amp;gt;pattern)&lt;/code&gt; may be achieved by writing &lt;code&gt;(?=(pattern))\g{-1}&lt;/code&gt; . This matches the same substring as a standalone &lt;code&gt;a+&lt;/code&gt; , and the following &lt;code&gt;\g{-1}&lt;/code&gt; eats the matched string; it therefore makes a zero-length assertion into an analogue of &lt;code&gt;(?&amp;gt;...)&lt;/code&gt;. (The difference between these two constructs is that the second one uses a capturing group, thus shifting ordinals of backreferences in the rest of a regular expression.)</source>
          <target state="translated">通过写 &lt;code&gt;(?=(pattern))\g{-1}&lt;/code&gt; 可以达到类似于 &lt;code&gt;(?&amp;gt;pattern)&lt;/code&gt; 的效果。它与独立的 &lt;code&gt;a+&lt;/code&gt; 匹配相同的子字符串，随后的 &lt;code&gt;\g{-1}&lt;/code&gt; 将使用匹配的字符串；因此，它将零长度断言声明为 &lt;code&gt;(?&amp;gt;...)&lt;/code&gt; 的类似物。（这两种构造之间的区别在于，第二种构造使用捕获组，因此会在正则表达式的其余部分中移动反向引用的序数。）</target>
        </trans-unit>
        <trans-unit id="e5eb41f6f24dfa906c0da1eda1f150cd75892a06" translate="yes" xml:space="preserve">
          <source>An empty leading field is produced when there is a positive-width match at the beginning of EXPR. For instance:</source>
          <target state="translated">当EXPR的开头有一个正宽度的匹配时,会产生一个空的前导字段。例如:</target>
        </trans-unit>
        <trans-unit id="7c1d0be8e8ca70fd2b14e62fb21989504ef1df2a" translate="yes" xml:space="preserve">
          <source>An empty list as soon as an explicit &lt;code&gt;break&lt;/code&gt; is encountered.</source>
          <target state="translated">遇到明确的 &lt;code&gt;break&lt;/code&gt; 便会清空一个列表。</target>
        </trans-unit>
        <trans-unit id="afbf0f80f22fc5d795da7f111754a1b9ed2a4fe4" translate="yes" xml:space="preserve">
          <source>An empty trailing field, on the other hand, is produced when there is a match at the end of EXPR, regardless of the length of the match (of course, unless a non-zero LIMIT is given explicitly, such fields are removed, as in the last example). Thus:</source>
          <target state="translated">另一方面,当EXPR的末尾有一个匹配时,就会产生一个空的尾部字段,而不管匹配的长度如何(当然,除非明确给出一个非零的LIMIT,否则这种字段会被删除,就像上一个例子一样)。因此。</target>
        </trans-unit>
        <trans-unit id="cd562f569c7a192c547c6c2160f193f3f97949c6" translate="yes" xml:space="preserve">
          <source>An enchantment, illusion, phantasm, or jugglery. Said when Perl&amp;rsquo;s magical &lt;b&gt;dwimmer&lt;/b&gt; effects don&amp;rsquo;t do what you expect, but rather seem to be the product of arcane</source>
          <target state="translated">附魔，幻觉，幻象或魔术 说到Perl神奇的&lt;b&gt;微光&lt;/b&gt;效果没有达到您的预期，而是奥秘的产物</target>
        </trans-unit>
        <trans-unit id="5a1e64f9893fb69df07a9e0956194fcfd71ca286" translate="yes" xml:space="preserve">
          <source>An endpoint for network communication among multiple &lt;b&gt;processes&lt;/b&gt; that works much like a telephone or a post office box. The most important thing about a socket is its &lt;b&gt;network address&lt;/b&gt; (like a phone number). Different kinds of sockets have different kinds of addresses&amp;mdash;some look like filenames, and some don&amp;rsquo;t.</source>
          <target state="translated">在多个&lt;b&gt;进程&lt;/b&gt;之间进行网络通信的端点，其工作原理类似于电话或邮政信箱。套接字最重要的是它的&lt;b&gt;网络地址&lt;/b&gt;（如电话号码）。不同种类的套接字具有不同种类的地址-有些看起来像文件名，有些却没有。</target>
        </trans-unit>
        <trans-unit id="84340afb233fc1ed2c36b5178d0bb87bc821d3fd" translate="yes" xml:space="preserve">
          <source>An entire computer program crammed into one line of text.</source>
          <target state="translated">整个计算机程序挤在一行文字里。</target>
        </trans-unit>
        <trans-unit id="0b89a9a0affedc51570a8afe57fcceb747dbf5fe" translate="yes" xml:space="preserve">
          <source>An entity specified by number (dec, hex, oct) is out of range (1-255).</source>
          <target state="translated">由数字(十进制、十六进制、八进制)指定的实体超出范围(1-255)。</target>
        </trans-unit>
        <trans-unit id="e4a99f74cee987dba72920fbff7e10dc623de69d" translate="yes" xml:space="preserve">
          <source>An entry of the form &lt;code&gt;-La:\foo&lt;/code&gt; specifies the &lt;code&gt;a:\foo&lt;/code&gt; directory to look for the libraries that follow.</source>
          <target state="translated">形式为 &lt;code&gt;-La:\foo&lt;/code&gt; 的条目指定 &lt;code&gt;a:\foo&lt;/code&gt; 目录以查找后面的库。</target>
        </trans-unit>
        <trans-unit id="e872c91a08d6535bc529f64f8ec25e1266b0facd" translate="yes" xml:space="preserve">
          <source>An entry of the form &lt;code&gt;-lfoo&lt;/code&gt; specifies the library &lt;code&gt;foo&lt;/code&gt; , which may be spelled differently depending on what kind of compiler you are using. If you are using GCC, it gets translated to &lt;code&gt;libfoo.a&lt;/code&gt; , but for other win32 compilers, it becomes &lt;code&gt;foo.lib&lt;/code&gt; . If no files are found by those translated names, one more attempt is made to find them using either &lt;code&gt;foo.a&lt;/code&gt; or &lt;code&gt;libfoo.lib&lt;/code&gt; , depending on whether GCC or some other win32 compiler is being used, respectively.</source>
          <target state="translated">形式 &lt;code&gt;-lfoo&lt;/code&gt; 的条目指定库 &lt;code&gt;foo&lt;/code&gt; ，库的拼写可能有所不同，具体取决于您使用的是哪种编译器。如果使用的是GCC，它将转换为 &lt;code&gt;libfoo.a&lt;/code&gt; ，但对于其他win32编译器，它将变为 &lt;code&gt;foo.lib&lt;/code&gt; 。如果这些转换后的名称未找到文件，则分别尝试使用 &lt;code&gt;foo.a&lt;/code&gt; 或 &lt;code&gt;libfoo.lib&lt;/code&gt; 来查找它们，具体取决于使用的是GCC还是其他Win32编译器。</target>
        </trans-unit>
        <trans-unit id="542b3550714b3908eea8d8c13ea7256018c9e930" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:nodefault/i&lt;/code&gt; disables the appending of default libraries found in &lt;code&gt;$Config{perllibs}&lt;/code&gt; (this should be only needed very rarely).</source>
          <target state="translated">匹配 &lt;code&gt;/:nodefault/i&lt;/code&gt; 的条目将禁用附加在 &lt;code&gt;$Config{perllibs}&lt;/code&gt; 找到的默认库（应该很少使用）。</target>
        </trans-unit>
        <trans-unit id="54596c2d41917bea50cab186303f4d27d58e3783" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:nosearch/i&lt;/code&gt; disables all searching for the libraries specified after it. Translation of &lt;code&gt;-Lfoo&lt;/code&gt; and &lt;code&gt;-lfoo&lt;/code&gt; still happens as appropriate (depending on compiler being used, as reflected by &lt;code&gt;$Config{cc}&lt;/code&gt; ), but the entries are not verified to be valid files or directories.</source>
          <target state="translated">匹配 &lt;code&gt;/:nosearch/i&lt;/code&gt; 的条目将禁用所有在其后指定的库的搜索。 &lt;code&gt;-Lfoo&lt;/code&gt; 和 &lt;code&gt;-lfoo&lt;/code&gt; 的翻译仍然会适当地进行（取决于所使用的编译器，如 &lt;code&gt;$Config{cc}&lt;/code&gt; 所反映），但是未验证条目是否为有效的文件或目录。</target>
        </trans-unit>
        <trans-unit id="341641ec8dfdfc884739074e9d2b0f226cf6a1e7" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:search/i&lt;/code&gt; reenables searching for the libraries specified after it. You can put it at the end to enable searching for default libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt; .</source>
          <target state="translated">匹配 &lt;code&gt;/:search/i&lt;/code&gt; 的条目可重新搜索其后指定的库。您可以将其放在最后以启用搜索 &lt;code&gt;$Config{perllibs}&lt;/code&gt; 指定的默认库。</target>
        </trans-unit>
        <trans-unit id="eac77ebce5cb434a4347aeb52157baf13e86e68f" translate="yes" xml:space="preserve">
          <source>An enum of flags for Perl types. These are found in the file &lt;b&gt;sv.h&lt;/b&gt; in the &lt;code&gt;svtype&lt;/code&gt; enum. Test these flags with the &lt;code&gt;SvTYPE&lt;/code&gt; macro.</source>
          <target state="translated">Perl类型的标志的枚举。这些在文件中找到&lt;b&gt;sv.h&lt;/b&gt;在 &lt;code&gt;svtype&lt;/code&gt; 枚举。使用 &lt;code&gt;SvTYPE&lt;/code&gt; 宏测试这些标志。</target>
        </trans-unit>
        <trans-unit id="a352e1f402bd0b0688137a6b2ecc0dfb6c13f18b" translate="yes" xml:space="preserve">
          <source>An enum value. Used to transfer an enum component from C. There is no reason to pass an enum value to C since it is stored as an IV inside perl.</source>
          <target state="translated">一个枚举值。用于从C中传输一个枚举组件。没有理由将一个枚举值传给C,因为它在perl中是作为IV存储的。</target>
        </trans-unit>
        <trans-unit id="85b348ed9fe24e3e5ab044fd0ea208d3866c0f50" translate="yes" xml:space="preserve">
          <source>An environment variable is used, rather than parallel make itself, because &lt;a href=&quot;tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; needs to be able to schedule individual non-conflicting test scripts itself, and there is no standard interface to &lt;code&gt;make&lt;/code&gt; utilities to interact with their job schedulers.</source>
          <target state="translated">使用环境变量，而不是使用并行变量本身，因为&lt;a href=&quot;tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt;需要能够自己计划各个不冲突的测试脚本，并且没有标准接口可以 &lt;code&gt;make&lt;/code&gt; 实用程序与其作业计划程序进行交互。</target>
        </trans-unit>
        <trans-unit id="066862fe86f40b5704d122b8bfa39f1462669702" translate="yes" xml:space="preserve">
          <source>An error has occurred (for &lt;code&gt;PerlIO_error()&lt;/code&gt; ).</source>
          <target state="translated">发生错误（对于 &lt;code&gt;PerlIO_error()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bf25473c20a4c33f096f0b4023a99e2a049e0b27" translate="yes" xml:space="preserve">
          <source>An essential part of any good development process is appropriate error handling with appropriately informative messages, however there exists a school of thought which suggests that log files should be</source>
          <target state="translated">任何良好的开发过程的一个重要部分是适当的错误处理,并提供适当的信息,然而有一派观点认为,日志文件应该是</target>
        </trans-unit>
        <trans-unit id="66bdaa16d0763f3a76de0b4a13d35f1b3d80f29a" translate="yes" xml:space="preserve">
          <source>An even stranger template code is &lt;code&gt;%&lt;/code&gt; &amp;lt;</source>
          <target state="translated">甚至更陌生的模板代码是 &lt;code&gt;%&lt;/code&gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="8a5463243357a8ee13bfd32810dc057038bf9e07" translate="yes" xml:space="preserve">
          <source>An event that causes a &lt;b&gt;handler&lt;/b&gt; to be run.</source>
          <target state="translated">导致&lt;b&gt;处理程序&lt;/b&gt;运行的事件。</target>
        </trans-unit>
        <trans-unit id="aa855332f899b198338c3e15641312b3dfa643e8" translate="yes" xml:space="preserve">
          <source>An example conversion function for a typemapped struct &lt;code&gt;foo_t *&lt;/code&gt; might be:</source>
          <target state="translated">类型映射的结构 &lt;code&gt;foo_t *&lt;/code&gt; 的转换函数示例可能是：</target>
        </trans-unit>
        <trans-unit id="ec7aaa34ffb73c97f6ed68693695810184b33f37" translate="yes" xml:space="preserve">
          <source>An example disabling Nagle's algorithm on a socket:</source>
          <target state="translated">一个在socket上禁用Nagle算法的例子。</target>
        </trans-unit>
        <trans-unit id="370a61094a87b707b90886b80eccf424717c5430" translate="yes" xml:space="preserve">
          <source>An example for Russian and some languages using the Cyrillic script:</source>
          <target state="translated">以俄语和一些使用西里尔字母的语言为例。</target>
        </trans-unit>
        <trans-unit id="562686eabf6589e6760dcb870fbc2918a4b18229" translate="yes" xml:space="preserve">
          <source>An example of all of the phases Perl code can see:</source>
          <target state="translated">一个Perl代码可以看到的所有阶段的例子。</target>
        </trans-unit>
        <trans-unit id="5242beac10407637f4a4b464517825d71718f4a4" translate="yes" xml:space="preserve">
          <source>An example of how this might be used is as follows:</source>
          <target state="translated">以下是一个如何使用这种方法的例子:</target>
        </trans-unit>
        <trans-unit id="ab9dc32ca31441503bc05feea6fc9cf1b0dfb98e" translate="yes" xml:space="preserve">
          <source>An example output might be:</source>
          <target state="translated">例如,输出可以是:</target>
        </trans-unit>
        <trans-unit id="516a8fafa09adceb915093c484c5d89d031db306" translate="yes" xml:space="preserve">
          <source>An example usage looks like:</source>
          <target state="translated">一个例子的用法是这样的。</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">一个例子:</target>
        </trans-unit>
        <trans-unit id="b3e01d95d4f7169aa36a737a1211243d324cf5ef" translate="yes" xml:space="preserve">
          <source>An exception</source>
          <target state="translated">一个例外</target>
        </trans-unit>
        <trans-unit id="eb08b0a2e1d46bb5d472e490ea7b28d5dd9e956d" translate="yes" xml:space="preserve">
          <source>An exception to this is that you may assign to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in a list. This is useful for throwing away some of the return values of a function:</source>
          <target state="translated">例外情况是您可以在列表中分配给 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。这对于丢弃函数的某些返回值很有用：</target>
        </trans-unit>
        <trans-unit id="0fc1d98cce4c241de46d33d676c33734f841fc89" translate="yes" xml:space="preserve">
          <source>An executable compiled on a PA-RISC 2.0 platform will not execute on a PA-RISC 1.1 platform, even if they are running the same version of HP-UX. If you are building Perl on a PA-RISC 2.0 platform and want that Perl to also run on a PA-RISC 1.1, the compiler flags +DAportable and +DS32 should be used.</source>
          <target state="translated">在 PA-RISC 2.0 平台上编译的可执行文件不会在 PA-RISC 1.1 平台上执行,即使它们运行的是相同版本的 HP-UX。如果您在PA-RISC 2.0平台上构建Perl,并希望该Perl也能在PA-RISC 1.1平台上运行,则应使用编译器标志+DAportable和+DS32。</target>
        </trans-unit>
        <trans-unit id="089b36ce65cddba1918a51ae6a46d8831ee39956" translate="yes" xml:space="preserve">
          <source>An exit status of 0 implies &quot;success&quot;. For example, &lt;b&gt;diff(1)&lt;/b&gt; exits with a status of 0 if the two files have the same contents.</source>
          <target state="translated">退出状态为0表示&amp;ldquo;成功&amp;rdquo;。例如，如果两个文件具有相同的内容，则&lt;b&gt;diff（1）&lt;/b&gt;的状态为0退出。</target>
        </trans-unit>
        <trans-unit id="bbd4429d08a5ebe605cc6bfbbfa2eaacec53a0f9" translate="yes" xml:space="preserve">
          <source>An exit status of 1 implies possibly abnormal, but non-defective, program termination. For example, &lt;b&gt;grep(1)&lt;/b&gt; exits with a status of 1 if it did</source>
          <target state="translated">退出状态为1表示可能异常终止，但程序完好无损。例如，&lt;b&gt;grep（1）&lt;/b&gt;退出时状态为1</target>
        </trans-unit>
        <trans-unit id="e246081e6327d64a230056100ee6a6d47e29ef00" translate="yes" xml:space="preserve">
          <source>An exit status of 2 or more implies a fatal error. For example, &lt;b&gt;ls(1)&lt;/b&gt; exits with a status of 2 if you specify an illegal (unknown) option on the command line.</source>
          <target state="translated">退出状态为2或更大意味着存在致命错误。例如，如果您在命令行上指定了非法（未知）选项，&lt;b&gt;ls（1）&lt;/b&gt;将以状态2退出。</target>
        </trans-unit>
        <trans-unit id="1ff1cef51589fc8dbb6faba666f12b831fe6b899" translate="yes" xml:space="preserve">
          <source>An experimental pseudolayer that removes the topmost layer. Use with the same care as is reserved for nitroglycerine.</source>
          <target state="translated">一种实验性的假层,可去除最上层。使用时应注意与硝酸甘油相同。</target>
        </trans-unit>
        <trans-unit id="846db25d0ecc19ed2c5fd44070c00f6f8a9c0772" translate="yes" xml:space="preserve">
          <source>An explanation of VMS file specs can be found at &lt;a href=&quot;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&quot;&gt;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&lt;/a&gt;.</source>
          <target state="translated">有关VMS文件规范的说明，请访问&lt;a href=&quot;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&quot;&gt;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b85172cf7a158b615a4c1e4c610cfa79b7fa2c51" translate="yes" xml:space="preserve">
          <source>An explicit format parameter index, such as &lt;code&gt;2$&lt;/code&gt;. By default sprintf will format the next unused argument in the list, but this allows you to take the arguments out of order:</source>
          <target state="translated">显式格式参数索引，例如 &lt;code&gt;2$&lt;/code&gt; 。默认情况下，sprintf将格式化列表中下一个未使用的参数，但这使您可以使参数乱序：</target>
        </trans-unit>
        <trans-unit id="52691b6df07cdbefee8cb7a498d3dc93b2c8dd90" translate="yes" xml:space="preserve">
          <source>An exploration of some of the issues facing Perl programmers on EBCDIC based computers.</source>
          <target state="translated">探讨基于EBCDIC计算机的Perl程序员面临的一些问题。</target>
        </trans-unit>
        <trans-unit id="372a1e4ea54335151ba75e3cd2ea53899b760f24" translate="yes" xml:space="preserve">
          <source>An expression which, when its value changes, causes a breakpoint in the Perl debugger.</source>
          <target state="translated">一个表达式,当其值发生变化时,会在Perl调试器中引起一个断点。</target>
        </trans-unit>
        <trans-unit id="d16dfa398c1840b695b36040deeba3088ca6a02a" translate="yes" xml:space="preserve">
          <source>An extension is a way of calling compiled C code from Perl. Reading &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; is a good place to learn more about extensions.</source>
          <target state="translated">扩展是从Perl调用已编译的C代码的一种方式。阅读&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;是学习更多有关扩展的好地方。</target>
        </trans-unit>
        <trans-unit id="9164cae08d37bdf18edf58e540f0e6c559fb27cc" translate="yes" xml:space="preserve">
          <source>An extension that is built with the above steps is ready to use on systems supporting dynamic loading. On systems that do not support dynamic loading, any newly created extension has to be linked together with the available resources. MakeMaker supports the linking process by creating appropriate targets in the Makefile whenever an extension is built. You can invoke the corresponding section of the makefile with</source>
          <target state="translated">通过上述步骤建立的扩展可以在支持动态加载的系统上使用。在不支持动态加载的系统上,任何新创建的扩展都必须与可用资源链接在一起。MakeMaker通过在Makefile中创建相应的目标来支持链接过程,每当建立一个扩展时。您可以在Makefile中调用相应的部分,用</target>
        </trans-unit>
        <trans-unit id="62fe96c831d4e5434f2a2484c5da0d22ce2c69d7" translate="yes" xml:space="preserve">
          <source>An external &lt;b&gt;subroutine&lt;/b&gt; defined in &lt;b&gt;XS&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;XS中&lt;/b&gt;定义的外部&lt;b&gt;子例程&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7422ed8b7617c92670f322946ad1f9ad0f35ee57" translate="yes" xml:space="preserve">
          <source>An extra field consists of zero or more subfields. Each subfield consists of a two byte header followed by the subfield data.</source>
          <target state="translated">额外字段由零个或多个子字段组成。每个子字段由一个两个字节的标题和子字段数据组成。</target>
        </trans-unit>
        <trans-unit id="18c0e84026650565acf5b36d62e6093af36330f9" translate="yes" xml:space="preserve">
          <source>An extraordinarily exported, expeditiously excellent, expressly eXternal Subroutine, executed in existing C or C++ or in an exciting extension language called (exasperatingly) XS.</source>
          <target state="translated">一个格外导出的、迅速优秀的、明确的eXternal子程序,用现有的C或C++或一个叫(令人气愤的)XS的激动人心的扩展语言执行。</target>
        </trans-unit>
        <trans-unit id="5ae0ec1c420230a4b9a6f6f5a35cd2c66a33eeb2" translate="yes" xml:space="preserve">
          <source>An extremely lightweight &lt;b&gt;DB_File&lt;/b&gt; wrapper that simply flocks a lockfile before tie-ing the database and drops the lock after the untie. Allows one to use the same lockfile for multiple databases to avoid deadlock problems, if desired. Use for databases where updates are reads are quick and simple flock locking semantics are enough.</source>
          <target state="translated">一个非常轻量级的&lt;b&gt;DB_File&lt;/b&gt;包装器，在绑定数据库之前简单地锁定一个锁定文件，并在解开之后丢弃该锁定。如果需要，允许一个人对多个数据库使用相同的锁定文件，以避免死锁问题。用于读取更新的数据库非常快速，并且简单的集群锁定语义就足够了。</target>
        </trans-unit>
        <trans-unit id="6c7aaf1b9af23250eb8ede6f4c91ca5fbe3ad083" translate="yes" xml:space="preserve">
          <source>An identifier (not necessarily related to the real name of a file) that represents a particular instance of opening a file, until you close it. If you&amp;rsquo;re going to open and close several different files in succession, it&amp;rsquo;s fine to open each of them with the same filehandle, so you don&amp;rsquo;t have to write out separate code to process each file.</source>
          <target state="translated">标识符（不一定与文件的真实名称相关），表示打开文件的特定实例，直到您将其关闭。如果您要连续打开和关闭几个不同的文件，则可以使用相同的文件句柄打开每个文件，因此不必不必编写单独的代码来处理每个文件。</target>
        </trans-unit>
        <trans-unit id="2ca4f6f5a018c6a780d2f920105ee21e87c135e6" translate="yes" xml:space="preserve">
          <source>An immediate filter allows you to specify the filter code to be used at the point where the filter is applied to a dbm. In this mode the Filter_*_Push methods expects to receive exactly two parameters.</source>
          <target state="translated">即时过滤器允许您指定在过滤器应用于dbm时使用的过滤器代码。在这种模式下,Filter_*_Push方法需要接收两个参数。</target>
        </trans-unit>
        <trans-unit id="854d43de9440512807e67ff18407c545a932b325" translate="yes" xml:space="preserve">
          <source>An imperfect standard</source>
          <target state="translated">不完善的标准</target>
        </trans-unit>
        <trans-unit id="20af74febdbf871248a6b2f4c417ca9aaffe6f3f" translate="yes" xml:space="preserve">
          <source>An important property of the digest algorithms is that the digest is</source>
          <target state="translated">文摘算法的一个重要特性是文摘是</target>
        </trans-unit>
        <trans-unit id="5358f4c4e85e881620623ef0fa458c651c57bf92" translate="yes" xml:space="preserve">
          <source>An incremental option is specified with a plus &lt;code&gt;+&lt;/code&gt; after the option name:</source>
          <target state="translated">在选项名称后用加号 &lt;code&gt;+&lt;/code&gt; 指定增量选项：</target>
        </trans-unit>
        <trans-unit id="eff14445a69700081714d1ed9ff369fb4f2bc735" translate="yes" xml:space="preserve">
          <source>An index of character names is available on-line from the Unicode Consortium, &lt;a href=&quot;http://www.unicode.org/charts/charindex.html&quot;&gt;http://www.unicode.org/charts/charindex.html&lt;/a&gt;; explanatory material with links to other resources at &lt;a href=&quot;http://www.unicode.org/standard/where&quot;&gt;http://www.unicode.org/standard/where&lt;/a&gt;.</source>
          <target state="translated">可以从Unicode联盟（&lt;a href=&quot;http://www.unicode.org/charts/charindex.html&quot;&gt;http://www.unicode.org/charts/charindex.html）&lt;/a&gt;在线获得字符名称索引。带有其他资源链接的说明性材料，&lt;a href=&quot;http://www.unicode.org/standard/where&quot;&gt;网址&lt;/a&gt;为http://www.unicode.org/standard/where。</target>
        </trans-unit>
        <trans-unit id="ef770a25a15f3c0ce63ccdcd24649733fd026bd0" translate="yes" xml:space="preserve">
          <source>An indirect filehandle is the use of something other than a symbol in a place that a filehandle is expected. Here are ways to get indirect filehandles:</source>
          <target state="translated">间接文件柄是指在需要文件柄的地方使用符号以外的东西。以下是获取间接文件柄的方法。</target>
        </trans-unit>
        <trans-unit id="858451a2efc846133fcc1f6e934e6a48b50f2e8c" translate="yes" xml:space="preserve">
          <source>An informative hash, accessible via &lt;code&gt;details()&lt;/code&gt; , is stored for each test you perform. So memory usage will scale linearly with each test run. Although this is not a problem for most test suites, it can become an issue if you do large (hundred thousands to million) combinatorics tests in the same run.</source>
          <target state="translated">可为您执行的每个测试存储一个可通过 &lt;code&gt;details()&lt;/code&gt; 访问的信息性哈希。因此，内存使用量将随着每次测试运行而线性扩展。尽管对于大多数测试套件而言这不是问题，但是如果您在同一运行中进行大型（数十万至百万）组合测试，则可能会成为问题。</target>
        </trans-unit>
        <trans-unit id="a9e6a3af85651e42bfa391fe495fc3734c02ae8b" translate="yes" xml:space="preserve">
          <source>An input file that uses source filtering probably won't be deparsed into runnable code, because it will still include the &lt;b&gt;use&lt;/b&gt; declaration for the source filtering module, even though the code that is produced is already ordinary Perl which shouldn't be filtered again.</source>
          <target state="translated">使用源过滤的输入文件可能不会被解析为可运行的代码，因为即使生成的代码已经是普通的Perl，也不应再次对其进行过滤，但它仍将包含源过滤模块的&lt;b&gt;use&lt;/b&gt;声明。</target>
        </trans-unit>
        <trans-unit id="aa16b38820f7deb5595d1bc31e5c4264a804f15b" translate="yes" xml:space="preserve">
          <source>An installation can choose to allow any of these to be matched by downloading the Unicode database from &lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt; to &lt;code&gt;$Config{privlib}&lt;/code&gt; /</source>
          <target state="translated">通过将Unicode数据库从&lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt;下载到 &lt;code&gt;$Config{privlib}&lt;/code&gt; /，安装程序可以选择允许其中任何一个匹配</target>
        </trans-unit>
        <trans-unit id="a014f84e1453ef226d46effcd0a9cbfe569a9f81" translate="yes" xml:space="preserve">
          <source>An instance of a running program. Under multitasking systems like Unix, two or more separate processes could be running the same program independently at the same time&amp;mdash;in fact, the &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; function is designed to bring about this happy state of affairs. Under other operating systems, processes are sometimes called &amp;ldquo;threads&amp;rdquo;, &amp;ldquo;tasks&amp;rdquo;, or &amp;ldquo;jobs&amp;rdquo;, often with slight nuances in meaning.</source>
          <target state="translated">正在运行的程序的实例。在像Unix这样的多任务系统下，两个或多个单独的进程可以同时独立运行同一程序-实际上， &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 函数旨在实现这种愉快的状态。在其他操作系统下，进程有时称为&amp;ldquo;线程&amp;rdquo;，&amp;ldquo;任务&amp;rdquo;或&amp;ldquo;作业&amp;rdquo;，其含义通常略有细微差别。</target>
        </trans-unit>
        <trans-unit id="0214de560f2556559c172656f6d4683531a40229" translate="yes" xml:space="preserve">
          <source>An integer divisor when you&amp;rsquo;re interested in the remainder instead of the quotient.</source>
          <target state="translated">对余数感兴趣而不是商数的整数除数。</target>
        </trans-unit>
        <trans-unit id="ef97a772df2ab33140914238f0dfa09aa1f2481c" translate="yes" xml:space="preserve">
          <source>An integer in the range from 0 to 1, inclusive. The smallest possible unit of information storage. An eighth of a &lt;b&gt;byte&lt;/b&gt; or of a dollar. (The term &amp;ldquo;Pieces of Eight&amp;rdquo; comes from being able to split the old Spanish dollar into 8 bits, each of which still counted for money. That&amp;rsquo;s why a 25- cent piece today is still &amp;ldquo;two bits&amp;rdquo;.)</source>
          <target state="translated">范围从0到1（含）的整数。信息存储的最小单位。八分之一&lt;b&gt;字节&lt;/b&gt;或一美元。（&amp;ldquo;八分之一&amp;rdquo;一词的含义是能够将旧的西班牙元分成8位，每位仍然算作货币。这就是为什么今天的25美分仍然是&amp;ldquo;两位&amp;rdquo;的原因。）</target>
        </trans-unit>
        <trans-unit id="487c5ee86805465c96baeca407a9f1d4e496a654" translate="yes" xml:space="preserve">
          <source>An interesting property of the 32 C0 control characters in the ASCII table is that they can &quot;literally&quot; be constructed as control characters in Perl, e.g. &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt; )&amp;gt; &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt; )&amp;gt;, and so on. Perl on EBCDIC platforms has been ported to take &lt;code&gt;\c@&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;\cA&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt;, etc. as well, but the characters that result depend on which code page you are using. The table below uses the standard acronyms for the controls. The POSIX-BC and 1047 sets are identical throughout this range and differ from the 0037 set at only one spot (21 decimal). Note that the line terminator character may be generated by &lt;code&gt;\cJ&lt;/code&gt; on ASCII platforms but by &lt;code&gt;\cU&lt;/code&gt; on 1047 or POSIX-BC platforms and cannot be generated as a &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; control character on 0037 platforms. Note also that &lt;code&gt;\c\&lt;/code&gt; cannot be the final element in a string or regex, as it will absorb the terminator. But &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; is a &lt;code&gt;FILE
SEPARATOR&lt;/code&gt; concatenated with</source>
          <target state="translated">ASCII表中的32个C0控制字符的一个有趣特性是，它们可以在Perl中&amp;ldquo;按字面意义&amp;rdquo;构造为控制字符，例如 &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt; ）&amp;gt; &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt; ）&amp;gt; ， 等等。已将EBCDIC平台上的Perl移植到 &lt;code&gt;\c@&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0)&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;\cA&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt; 等等），但是产生的字符取决于您所使用的代码页。下表使用控件的标准首字母缩写词。 POSIX-BC和1047集在此范围内完全相同，而0037集仅在一个点（十进制21个）不同。注意，行终止字符可以由产生 &lt;code&gt;\cJ&lt;/code&gt; 上ASCII平台，但通过 &lt;code&gt;\cU&lt;/code&gt; 1047或POSIX-BC平台和不能被作为生成 &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; 0037平台上的控制字符。还要注意 &lt;code&gt;\c\&lt;/code&gt; 不能是字符串或正则表达式中的最后一个元素，因为它将吸收终止符。但是 &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 是一个 &lt;code&gt;FILE SEPARATOR&lt;/code&gt; 与</target>
        </trans-unit>
        <trans-unit id="aef88cb460d98eb7a1821664038bd8e659735536" translate="yes" xml:space="preserve">
          <source>An internal &amp;ldquo;glob value&amp;rdquo; typedef, holding a &lt;b&gt;typeglob&lt;/b&gt;. The &lt;code&gt;GV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">内部的&amp;ldquo; glob值&amp;rdquo; typedef，保存一个&lt;b&gt;typeglob&lt;/b&gt;。的 &lt;code&gt;GV&lt;/code&gt; 类型是子类&lt;b&gt;SV&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="365d20928561014537aae861944e88c7698c35b5" translate="yes" xml:space="preserve">
          <source>An internal I/O object. Can also mean &lt;b&gt;indirect object&lt;/b&gt;.</source>
          <target state="translated">内部I / O对象。也可以表示&lt;b&gt;间接对象&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="56ae7164116e23d92fc781838b142ca53874c36a" translate="yes" xml:space="preserve">
          <source>An internal function to generate the embedded perl code that will regenerate the constant subroutines.</source>
          <target state="translated">一个内部函数,用于生成嵌入的perl代码,该代码将再生常量子程序。</target>
        </trans-unit>
        <trans-unit id="7baaf8aedf397c98d596c2159887aa7f484b6db4" translate="yes" xml:space="preserve">
          <source>An internal function to generate the embedded perl code that will regenerate the constant subroutines. Parameters are the same as for C_constant.</source>
          <target state="translated">一个内部函数,用于生成嵌入的perl代码,以重新生成常量子程序。参数与C_constant相同。</target>
        </trans-unit>
        <trans-unit id="85667dd393cb7f2981dedf066accff60dc1411e5" translate="yes" xml:space="preserve">
          <source>An internal method to generate a suitable &lt;code&gt;switch&lt;/code&gt; clause, called by &lt;code&gt;C_constant&lt;/code&gt;</source>
          <target state="translated">生成合适的 &lt;code&gt;switch&lt;/code&gt; 子句的内部方法，由 &lt;code&gt;C_constant&lt;/code&gt; 调用</target>
        </trans-unit>
        <trans-unit id="69e28cd04a2779fc9d5742eab6b3a6ded1892dd3" translate="yes" xml:space="preserve">
          <source>An internal representation of your program wherein lower-level &lt;b&gt;constructs&lt;/b&gt; dangle off the higher-level constructs enclosing them.</source>
          <target state="translated">程序的内部表示，其中较低级别的&lt;b&gt;构造物&lt;/b&gt;与包围它们的较高级别的构造物无关。</target>
        </trans-unit>
        <trans-unit id="ce42a8cc64b6b6a7bf11b4b312683fee15a303f0" translate="yes" xml:space="preserve">
          <source>An internal shorthand for a &amp;ldquo;push- pop&amp;rdquo; code; that is, C code implementing Perl&amp;rsquo;s stack machine.</source>
          <target state="translated">&amp;ldquo; push-pop&amp;rdquo;代码的内部简写；也就是说，C代码实现了Perl的堆栈机。</target>
        </trans-unit>
        <trans-unit id="07d1d6d772129317410071c249632c5b5382b664" translate="yes" xml:space="preserve">
          <source>An internal variable used by PerlIO. A string in two parts, separated by a &lt;code&gt;\0&lt;/code&gt; byte, the first part describes the input layers, the second part describes the output layers.</source>
          <target state="translated">PerlIO使用的内部变量。一个字符串，分为两个部分，用 &lt;code&gt;\0&lt;/code&gt; 字节分隔，第一部分描述输入层，第二部分描述输出层。</target>
        </trans-unit>
        <trans-unit id="30d4f93cd3d13081a21910a8e9e9a9f2e19354af" translate="yes" xml:space="preserve">
          <source>An invalid POD command has been found. Valid are &lt;code&gt;=head1&lt;/code&gt; , &lt;code&gt;=head2&lt;/code&gt; , &lt;code&gt;=head3&lt;/code&gt; , &lt;code&gt;=head4&lt;/code&gt; , &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; , &lt;code&gt;=back&lt;/code&gt; , &lt;code&gt;=begin&lt;/code&gt; , &lt;code&gt;=end&lt;/code&gt; , &lt;code&gt;=for&lt;/code&gt; , &lt;code&gt;=pod&lt;/code&gt; , &lt;code&gt;=cut&lt;/code&gt;</source>
          <target state="translated">找到了无效的POD命令。有效的是 &lt;code&gt;=head1&lt;/code&gt; &lt;code&gt;=head2&lt;/code&gt; ，= head2， &lt;code&gt;=head3&lt;/code&gt; ， &lt;code&gt;=head4&lt;/code&gt; ， &lt;code&gt;=over&lt;/code&gt; ， &lt;code&gt;=item&lt;/code&gt; ， &lt;code&gt;=back&lt;/code&gt; ， &lt;code&gt;=begin&lt;/code&gt; ， &lt;code&gt;=end&lt;/code&gt; ， &lt;code&gt;=for&lt;/code&gt; ， &lt;code&gt;=pod&lt;/code&gt; ， &lt;code&gt;=cut&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8cf1c0648159d8ce5ec8b307b5ed4c7e4b2df3c9" translate="yes" xml:space="preserve">
          <source>An invalid markup command has been encountered. Valid are: &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">遇到无效的标记命令。有效的是： &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee1262d5508556d2b36a24c42f3e9a2dee57cb72" translate="yes" xml:space="preserve">
          <source>An item &quot;_*&quot; is interpreted to mean &quot;all of @_ except $_[0]&quot;. I.e., &lt;code&gt;@_[1..$#_]&lt;/code&gt; . Note that this is an empty list in the case of calls like $lh-&amp;gt;maketext(</source>
          <target state="translated">项目&amp;ldquo; _ *&amp;rdquo;被解释为表示&amp;ldquo;除$ _ [0]之外的所有@_&amp;rdquo;。即 &lt;code&gt;@_[1..$#_]&lt;/code&gt; 。请注意，在调用$ lh-&amp;gt; maketext（</target>
        </trans-unit>
        <trans-unit id="9af9ff7e003c973fa83a18c634e0daee75f8051b" translate="yes" xml:space="preserve">
          <source>An item that is &quot;_</source>
          <target state="translated">一个项目是&quot;_&quot;。</target>
        </trans-unit>
        <trans-unit id="7b5f2c15e59a54bf0587db95d2a9b094a2521830" translate="yes" xml:space="preserve">
          <source>An number specifying the maximum number of fields to return. If this argument is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), split continues as long as possible.</source>
          <target state="translated">一个数字，指定要返回的最大字段数。如果省略此参数（或 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），则拆分将继续尽可能长的时间。</target>
        </trans-unit>
        <trans-unit id="eabc404e0d4e219ccc6748ea24d333aab485d543" translate="yes" xml:space="preserve">
          <source>An object belonging to a language class is called a &quot;language handle&quot;; it's typically a flyweight object.</source>
          <target state="translated">一个属于语言类的对象被称为 &quot;语言句柄&quot;;它通常是一个重量级对象。</target>
        </trans-unit>
        <trans-unit id="49f2fe3106e7ff8ff917e823e3eefb2822882e64" translate="yes" xml:space="preserve">
          <source>An object corresponding to a paragraph of POD input text. It may be a plain paragraph, a verbatim paragraph, or a command paragraph (see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;).</source>
          <target state="translated">与POD输入文本的段落相对应的对象。它可以是普通段落，逐字段落或命令段落（请参见&lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8c3786be4e01790b87960925526e572088af640f" translate="yes" xml:space="preserve">
          <source>An object corresponding to a tree of parsed POD text. Each &quot;node&quot; in a parse-tree (or</source>
          <target state="translated">对应于解析后的POD文本树的对象。解析树中的每一个 &quot;节点&quot;(或称</target>
        </trans-unit>
        <trans-unit id="7e0998ddd63a38891699bf9ec1b0ac44c576baee" translate="yes" xml:space="preserve">
          <source>An object corresponding to an interior sequence command from the POD input text (see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;).</source>
          <target state="translated">与来自POD输入文本的内部序列命令相对应的对象（请参见&lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9a21e67f15a49134056700786cd13ad755082aac" translate="yes" xml:space="preserve">
          <source>An object is simply a data structure that knows to which class it belongs.</source>
          <target state="translated">一个对象只是一个数据结构,知道它属于哪个类。</target>
        </trans-unit>
        <trans-unit id="a359cbcceea3057766a3859aec9166b89f1082b5" translate="yes" xml:space="preserve">
          <source>An object method that initializes the first and last name to its two arguments. If called as a class method, &lt;code&gt;init()&lt;/code&gt; creates an object in the given class and initializes that.</source>
          <target state="translated">一个对象方法，用于将名字和姓氏初始化为其两个参数。如果作为类方法调用，则 &lt;code&gt;init()&lt;/code&gt; 将在给定的类中创建一个对象并将其初始化。</target>
        </trans-unit>
        <trans-unit id="2624824193fa16111d4b98614c9c89fd43601093" translate="yes" xml:space="preserve">
          <source>An object of a class created by the first and third forms is based on an array, whereas an object of a class created by the second form is based on a hash. The array-based forms will be somewhat faster and smaller; the hash-based forms are more flexible.</source>
          <target state="translated">第一和第三种形式创建的类的对象是基于数组的,而第二种形式创建的类的对象是基于哈希的。基于数组的形式会更快、更小;基于哈希的形式则更灵活。</target>
        </trans-unit>
        <trans-unit id="439e33121717fb8b3802d4a57550afd4a17f81f5" translate="yes" xml:space="preserve">
          <source>An object of class Archive::Tar represents a .tar(.gz) archive full of files and things.</source>
          <target state="translated">Archive::Tar类的对象表示一个充满文件和事物的.tar(.gz)存档。</target>
        </trans-unit>
        <trans-unit id="fcd5621c0c225a91e3f7d06ac2a91fa4ab613367" translate="yes" xml:space="preserve">
          <source>An object representing a POD interior sequence command. It has the following methods/attributes:</source>
          <target state="translated">一个代表POD内部序列命令的对象。它有以下方法/属性。</target>
        </trans-unit>
        <trans-unit id="c24cc2e914ce53bfd778879fef27948d64904b08" translate="yes" xml:space="preserve">
          <source>An object representing a paragraph of POD input text. It has the following methods/attributes:</source>
          <target state="translated">一个代表POD输入文本段落的对象。它有以下方法/属性:</target>
        </trans-unit>
        <trans-unit id="6fdb094e1018942aa0eb673bb8c92b50838eeb01" translate="yes" xml:space="preserve">
          <source>An object represents a single discrete thing. For example, an object might represent a file. The attributes for a file object might include its path, content, and last modification time. If we created an object to represent</source>
          <target state="translated">一个对象代表一个单一的离散事物。例如,一个对象可以代表一个文件。文件对象的属性可能包括它的路径、内容和最后修改时间。如果我们创建一个对象来表示</target>
        </trans-unit>
        <trans-unit id="ca7e61e203c4b11d26a8c4d45f16575384df7da5" translate="yes" xml:space="preserve">
          <source>An object that overloads an assignment operator does so only in respect of assignments to that object. In other words, Perl never calls the corresponding methods with the third argument (the &quot;swap&quot; argument) set to TRUE. For example, the operation</source>
          <target state="translated">重载赋值操作符的对象只在对该对象的赋值方面进行重载。换句话说,Perl从来不会调用第三个参数(&quot;swap &quot;参数)设置为TRUE的相应方法。例如,操作</target>
        </trans-unit>
        <trans-unit id="5dcc2b27aa012d9c72429af38062f2b4f54986c2" translate="yes" xml:space="preserve">
          <source>An object's members cannot be made accessible as variables. The closest Perl equivalent to &lt;code&gt;with(object) { method() }&lt;/code&gt; is &lt;code&gt;for&lt;/code&gt; , which can alias &lt;code&gt;$_&lt;/code&gt; to the object:</source>
          <target state="translated">无法将对象的成员作为变量进行访问。 &lt;code&gt;with(object) { method() }&lt;/code&gt; 最接近的Perl 是 &lt;code&gt;for&lt;/code&gt; ，它可以将 &lt;code&gt;$_&lt;/code&gt; 别名为对象：</target>
        </trans-unit>
        <trans-unit id="b940725a20a5223e137a3da755a048d1310c8a3b" translate="yes" xml:space="preserve">
          <source>An object, however, is a reference to blessed data, so if &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are objects then the assignment &lt;code&gt;$a = $b&lt;/code&gt; copies only the reference, leaving &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; referring to the same object data. One might therefore expect the operation &lt;code&gt;--$a&lt;/code&gt; to decrement &lt;code&gt;$b&lt;/code&gt; as well as &lt;code&gt;$a&lt;/code&gt; . However, this would not be consistent with how we expect the mathematical operators to work.</source>
          <target state="translated">但是，对象是对祝福数据的引用，因此，如果 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 是对象，则赋值 &lt;code&gt;$a = $b&lt;/code&gt; 仅复制引用，而 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 引用同一对象数据。因此，人们可能期望的操作 &lt;code&gt;--$a&lt;/code&gt; 递减 &lt;code&gt;$b&lt;/code&gt; 和 &lt;code&gt;$a&lt;/code&gt; 。但是，这与我们期望数学运算符的工作方式不一致。</target>
        </trans-unit>
        <trans-unit id="cee679c1ad7f71a88f44d59f19712e4063863e7e" translate="yes" xml:space="preserve">
          <source>An older style is to use a bareword as the filehandle, as</source>
          <target state="translated">旧的风格是使用裸词作为文件柄,如</target>
        </trans-unit>
        <trans-unit id="60dc562d58d05afda178b352ef3aa2e15f8841ff" translate="yes" xml:space="preserve">
          <source>An op is a fundamental operation that Perl can perform: all the built-in functions and operators are ops, and there are a series of ops which deal with concepts the interpreter needs internally - entering and leaving a block, ending a statement, fetching a variable, and so on.</source>
          <target state="translated">运算符是Perl可以执行的基本操作:所有内置的函数和运算符都是运算符,还有一系列的运算符,这些运算符处理的是解释器内部需要的概念--进入和离开一个块,结束一个语句,获取一个变量等等。</target>
        </trans-unit>
        <trans-unit id="7d7b9e438ab0eb414e5789ea7e5ffe93395e4dff" translate="yes" xml:space="preserve">
          <source>An operator with only one &lt;b&gt;operand&lt;/b&gt;, like &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;. Unary operators are usually prefix operators; that is, they precede their operand. The &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; operators can be either prefix or postfix. (Their position</source>
          <target state="translated">一个只有一个&lt;b&gt;操作数的运算符&lt;/b&gt;，例如 &lt;code&gt;!&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 。一元运算符通常是前缀运算符；也就是说，它们在其操作数之前。该 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; 运营商可以是前缀或后缀。（他们的位置</target>
        </trans-unit>
        <trans-unit id="9f9db1e29b16d48958d935e90ad14b3aea77dc3c" translate="yes" xml:space="preserve">
          <source>An opname or optag can be prefixed with an exclamation mark, e.g., !mkdir. Negating an opname or optag means remove the corresponding ops from the accumulated set of ops at that point.</source>
          <target state="translated">opname 或 optag 可以用感叹号作为前缀,例如 !mkdir。否定一个 opname 或 optag 意味着在该点上将相应的 ops 从累计的 ops 集中删除。</target>
        </trans-unit>
        <trans-unit id="dd9db1bae968b2ebc8590123585766603b6be162" translate="yes" xml:space="preserve">
          <source>An option on a pattern or substitution, such as &lt;code&gt;/i&lt;/code&gt; to render the pattern case- insensitive.</source>
          <target state="translated">模式或替代项的选项，例如 &lt;code&gt;/i&lt;/code&gt; ,以使模式不区分大小写。</target>
        </trans-unit>
        <trans-unit id="1a49163e236ca9288cd8e7003ee1066226da4567" translate="yes" xml:space="preserve">
          <source>An option you give on a command line to influence the way your program works, usually introduced with a minus sign. The word is also used as a nickname for a &lt;b&gt;switch statement&lt;/b&gt;.</source>
          <target state="translated">您在命令行上提供的一个选项可以影响程序的工作方式，通常以减号开头。这个单词也用作&lt;b&gt;switch语句&lt;/b&gt;的昵称。</target>
        </trans-unit>
        <trans-unit id="e2561efefd0f2b6e16416b85a2d7a359b74ad024" translate="yes" xml:space="preserve">
          <source>An optional feature provided by a CPAN distribution</source>
          <target state="translated">CPAN发行版提供的可选功能</target>
        </trans-unit>
        <trans-unit id="9645245b8e6172ce42528bd667596edb4e44c226" translate="yes" xml:space="preserve">
          <source>An optional filehandle (or IO::Handle ) that output will be printed to.</source>
          <target state="translated">一个可选的文件柄(或 IO::Handle ),输出将被打印到。</target>
        </trans-unit>
        <trans-unit id="bcc5a81df3ac1dbb29e0b23ff110e8ac5f546061" translate="yes" xml:space="preserve">
          <source>An optional filehandle (or IO::Handle ) to which the output string will be printed.</source>
          <target state="translated">一个可选的filehandle (或IO::Handle ),输出字符串将被打印到这个文件。</target>
        </trans-unit>
        <trans-unit id="2f9901f0f16239239419edd137f25118d48c58b4" translate="yes" xml:space="preserve">
          <source>An optional parameter can be nameless just like a mandatory parameter. For example,</source>
          <target state="translated">可选参数可以像强制参数一样是无名的。例如:</target>
        </trans-unit>
        <trans-unit id="c0d6b2a0df46d7d7fb341e1412dc44bcca1bf51c" translate="yes" xml:space="preserve">
          <source>An optional part of a &lt;b&gt;subroutine&lt;/b&gt; declaration telling the Perl compiler how many and what flavor of arguments may be passed as &lt;b&gt;actual arguments&lt;/b&gt;, so you can write subroutine calls that parse much like built-in functions. (Or don&amp;rsquo;t parse, as the case may be.)</source>
          <target state="translated">&lt;b&gt;子例程&lt;/b&gt;声明的可选部分，它告诉Perl编译器可以作为&lt;b&gt;实际参数&lt;/b&gt;传递多少个参数以及哪种形式的参数可以作为&lt;b&gt;实际参数&lt;/b&gt;传递，因此您可以编写类似于内置函数一样进行分析的子例程调用。（或者视情况而定，不进行解析。）</target>
        </trans-unit>
        <trans-unit id="a21eb72be8656b34c88984249eec6f0bab32e544" translate="yes" xml:space="preserve">
          <source>An optional third parameter can be used to specify the buffer size used for copying. This is the number of bytes from the first file, that will be held in memory at any given time, before being written to the second file. The default buffer size depends upon the file, but will generally be the whole file (up to 2MB), or 1k for filehandles that do not reference files (eg. sockets).</source>
          <target state="translated">可选的第三个参数可以用来指定用于复制的缓冲区大小。这是第一个文件的字节数,在写入第二个文件之前,在任何给定的时间都会被保存在内存中。默认的缓冲区大小取决于文件,但一般是整个文件(最大2MB),或者对于不引用文件的文件句柄(例如套接字)来说是1k。</target>
        </trans-unit>
        <trans-unit id="0ba928fdaea76c696564501e58ec48f20c5c9dc1" translate="yes" xml:space="preserve">
          <source>An ordered sequence of &lt;b&gt;values&lt;/b&gt;, stored such that you can easily access any of the values using an</source>
          <target state="translated">存储有序的&lt;b&gt;值&lt;/b&gt;序列，以便您可以轻松地使用</target>
        </trans-unit>
        <trans-unit id="2b793fb04f1842403dcb9eae8e630daf85625e60" translate="yes" xml:space="preserve">
          <source>An ordered set of scalar values.</source>
          <target state="translated">一组有序的标量值。</target>
        </trans-unit>
        <trans-unit id="93d009c1cdb4335605c0d3fe2975d2046a8496a5" translate="yes" xml:space="preserve">
          <source>An overview of the Perl interpreter source code and some details on how Perl does what it does.</source>
          <target state="translated">概述Perl解释器的源代码和一些关于Perl如何做的细节。</target>
        </trans-unit>
        <trans-unit id="bfd206b59d07c02456cd04b8e043a98488117f17" translate="yes" xml:space="preserve">
          <source>An overview of the Perl source tree. This will help you find the files you're looking for.</source>
          <target state="translated">Perl源代码树的概述。这将帮助你找到你要找的文件。</target>
        </trans-unit>
        <trans-unit id="a982a39a2d5d6b9f37342b5e83c23e1f0856fa85" translate="yes" xml:space="preserve">
          <source>An uncaught &lt;b&gt;exception&lt;/b&gt;, which causes termination of the &lt;b&gt;process&lt;/b&gt; after printing a message on your &lt;b&gt;standard error&lt;/b&gt; stream. Errors that happen inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; are not fatal. Instead, the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; terminates after placing the exception message in the &lt;code&gt;$@&lt;/code&gt; (&lt;code&gt;$EVAL_ERROR&lt;/code&gt; ) variable. You can try to provoke a fatal error with the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; operator (known as throwing or raising an exception), but this may be caught by a dynamically enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. If not caught, the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; becomes a fatal error.</source>
          <target state="translated">未捕获的&lt;b&gt;异常&lt;/b&gt;，它会在&lt;b&gt;标准错误&lt;/b&gt;流上打印消息后导致&lt;b&gt;进程&lt;/b&gt;终止。 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 内发生的错误不是致命的。而是，将异常消息放入 &lt;code&gt;$@&lt;/code&gt; （ &lt;code&gt;$EVAL_ERROR&lt;/code&gt; ）变量后， &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 终止。您可以尝试通过 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 运算符引发致命错误（称为引发或引发异常），但是动态封闭 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 可能会捕获此错误。如果未捕获，则 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 将成为致命错误。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="54365bc1044b88eb77fbf7f1b4c0664f5bcb036c" translate="yes" xml:space="preserve">
          <source>An undefined value is not permitted as a record separator. Perl's special &quot;paragraph mode&quot; semantics (&amp;agrave; la &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt; ) are not emulated.</source>
          <target state="translated">未定义的值不允许用作记录分隔符。不模仿Perl的特殊&amp;ldquo;段落模式&amp;rdquo;语义（la &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b64166e760d6e4e08cfb550598a86717021fc931" translate="yes" xml:space="preserve">
          <source>An unnamed list of temporary scalar values that may be passed around within a program from any list-generating function to any function or construct that provides a &lt;b&gt;list context&lt;/b&gt;.</source>
          <target state="translated">临时标量值的未命名列表，可以在程序内从任何列表生成函数传递到提供&lt;b&gt;列表上下文的&lt;/b&gt;任何函数或构造。</target>
        </trans-unit>
        <trans-unit id="b7a4ac1dececd2f0138b0d9e87eae14a3bf0f323" translate="yes" xml:space="preserve">
          <source>An unordered association of &lt;b&gt;key&lt;/b&gt;/&lt;b&gt;value&lt;/b&gt; pairs, stored such that you can easily use a string &lt;b&gt;key&lt;/b&gt; to look up its associated data &lt;b&gt;value&lt;/b&gt;. This glossary is like a hash, where the word to be defined is the key and the definition is the value. A hash is also sometimes septisyllabically called an &amp;ldquo;associative array&amp;rdquo;, which is a pretty good reason for simply calling it a &amp;ldquo;hash&amp;rdquo; instead.</source>
          <target state="translated">&lt;b&gt;键&lt;/b&gt; / &lt;b&gt;值&lt;/b&gt;对的无序关联，存储起来使得您可以轻松地使用字符串&lt;b&gt;键&lt;/b&gt;来查找其关联的数据&lt;b&gt;值&lt;/b&gt;。该词汇表就像一个哈希，其中要定义的单词是键，而定义是值。哈希有时有时也被单独称为&amp;ldquo;关联数组&amp;rdquo;，这是将其简单地称为&amp;ldquo;哈希&amp;rdquo;的一个很好的理由。</target>
        </trans-unit>
        <trans-unit id="b718389bf63428a7f7a0b8e8cfc5e0574b25619d" translate="yes" xml:space="preserve">
          <source>An unset or empty PERLIO is equivalent to the default set of layers for your platform; for example, &lt;code&gt;:unix:perlio&lt;/code&gt; on Unix-like systems and &lt;code&gt;:unix:crlf&lt;/code&gt; on Windows and other DOS-like systems.</source>
          <target state="translated">未设置或为空的PERLIO等效于平台的默认层集；例如 &lt;code&gt;:unix:perlio&lt;/code&gt; 类Unix系统 &lt;code&gt;:unix:crlf&lt;/code&gt; 在Windows和其他类似DOS系统。</target>
        </trans-unit>
        <trans-unit id="1b2099e63b3baac079849a311cb94bc9726d2b6a" translate="yes" xml:space="preserve">
          <source>An unsigned byte.</source>
          <target state="translated">一个无符号字节。</target>
        </trans-unit>
        <trans-unit id="17f8abaddabc70c518443c4340875b6f3d1f87f6" translate="yes" xml:space="preserve">
          <source>An unsigned integer.</source>
          <target state="translated">一个无符号整数。</target>
        </trans-unit>
        <trans-unit id="6dc9fd633e86a9f8c5100a5a45701b6dac466c39" translate="yes" xml:space="preserve">
          <source>An upgrade to the PA-RISC design, it shipped for many years in many different system.</source>
          <target state="translated">作为PA-RISC设计的升级版,它在许多不同的系统中出货多年。</target>
        </trans-unit>
        <trans-unit id="abd7bedc3ca5ffad7ed1a2379448571632c9a196" translate="yes" xml:space="preserve">
          <source>Analogously to &lt;code&gt;pTHX&lt;/code&gt; , there are equivalent forms for when the macro is the first or last in multiple arguments, where an underscore represents a comma, i.e. &lt;code&gt;_aMY_CXT&lt;/code&gt; , &lt;code&gt;aMY_CXT_&lt;/code&gt; , &lt;code&gt;_pMY_CXT&lt;/code&gt; and &lt;code&gt;pMY_CXT_&lt;/code&gt; .</source>
          <target state="translated">与 &lt;code&gt;pTHX&lt;/code&gt; 类似，当宏是多个参数中的第一个或最后一个时，存在等效形式，其中下划线表示逗号，即 &lt;code&gt;_aMY_CXT&lt;/code&gt; ， &lt;code&gt;aMY_CXT_&lt;/code&gt; ， &lt;code&gt;_pMY_CXT&lt;/code&gt; 和 &lt;code&gt;pMY_CXT_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="edf45b9159d8cf5fded0f359396c02baabcce4fe" translate="yes" xml:space="preserve">
          <source>Analyses the string in order to make fast searches on it using fbm_instr() -- the Boyer-Moore algorithm.</source>
          <target state="translated">使用fbm_instr()--Boyer-Moore算法分析字符串,以便对其进行快速搜索。</target>
        </trans-unit>
        <trans-unit id="b23a158b83cb28ac3361aeaadb0ea701f833add8" translate="yes" xml:space="preserve">
          <source>Anantha Kesari H Y (hyanantha@novell.com) Aditya C (caditya@novell.com)</source>
          <target state="translated">Anantha Kesari H Y (hyanantha@novell.com)Aditya C (caditya@novell.com)</target>
        </trans-unit>
        <trans-unit id="e7694709c56de3564de85fb7f6b62bf3f9d5a2dd" translate="yes" xml:space="preserve">
          <source>Anatomy of .xs file</source>
          <target state="translated">.xs文件的解剖</target>
        </trans-unit>
        <trans-unit id="c371090fde9f09dd68fd0c025b019139f11c3b43" translate="yes" xml:space="preserve">
          <source>Anatomy of a typemap</source>
          <target state="translated">类型图的解剖</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="56126a3ba8ff8d615bfc883458ff2ad74c4445f8" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; supports odd bit counts:</source>
          <target state="translated">而&lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;位:: vector的&lt;/a&gt;支持奇数位计数：</target>
        </trans-unit>
        <trans-unit id="0fdb46cc394058268f8370b027acd6f7507ad5af" translate="yes" xml:space="preserve">
          <source>And a print to show what values we're currently using:</source>
          <target state="translated">并打印出我们当前使用的数值。</target>
        </trans-unit>
        <trans-unit id="3e6cfdab3639e924ccc0236d51702eea17278fbe" translate="yes" xml:space="preserve">
          <source>And add the following code to Mytest.t, while incrementing the &quot;11&quot; tests to &quot;13&quot;:</source>
          <target state="translated">并在Mytest.t中添加以下代码,同时将 &quot;11 &quot;项测试递增为 &quot;13 &quot;项。</target>
        </trans-unit>
        <trans-unit id="7e934152fc5094b95aee4b1e3cfca4dfe3b716a5" translate="yes" xml:space="preserve">
          <source>And also add the following function definition to the end of the .xs file:</source>
          <target state="translated">并在.xs文件的末尾添加以下函数定义。</target>
        </trans-unit>
        <trans-unit id="e095a5f2bc9f3ebef8eb601baecde5aacc183619" translate="yes" xml:space="preserve">
          <source>And an even parity bit can be determined like this:</source>
          <target state="translated">而偶数位可以这样确定。</target>
        </trans-unit>
        <trans-unit id="fa65fe1d258f3efe5fa4b14f6a4bdf869e0bca12" translate="yes" xml:space="preserve">
          <source>And don't forget, all commands but &lt;code&gt;=encoding&lt;/code&gt; last up until the end of its</source>
          <target state="translated">而且请不要忘记，除 &lt;code&gt;=encoding&lt;/code&gt; 之外的所有命令都将持续到其结束</target>
        </trans-unit>
        <trans-unit id="d49f8a3fb63a02de3bc96673eb479046741fcd21" translate="yes" xml:space="preserve">
          <source>And elsewhere:</source>
          <target state="translated">和其他地方。</target>
        </trans-unit>
        <trans-unit id="0d86ebfaa42125fcbf7621caf9b51d0d516488b0" translate="yes" xml:space="preserve">
          <source>And even if you take all the above into account, ANSI still lets this:</source>
          <target state="translated">即使你考虑到以上所有因素,ANSI仍然让这。</target>
        </trans-unit>
        <trans-unit id="7a24c6f39dbf571ec01b5431e8552ecca7394253" translate="yes" xml:space="preserve">
          <source>And finally create a file Makefile.PL that looks like this:</source>
          <target state="translated">最后创建一个Makefile.PL文件,看起来像这样。</target>
        </trans-unit>
        <trans-unit id="ae77b129ec8a4042483f52a6f594546db002727e" translate="yes" xml:space="preserve">
          <source>And finally we'll test that we don't make Unicode strings if &lt;code&gt;U&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; the first active format:</source>
          <target state="translated">最后我们来测试，我们不作Unicode字符串，如果 &lt;code&gt;U&lt;/code&gt; 是&lt;b&gt;不是&lt;/b&gt;第一个活跃格式：</target>
        </trans-unit>
        <trans-unit id="a3e1249d44e165c645bd656a34581eba0f8a1e5b" translate="yes" xml:space="preserve">
          <source>And finally, END OF CHARMAP ends the section.</source>
          <target state="translated">最后,END OF CHARMAP结束本节。</target>
        </trans-unit>
        <trans-unit id="0fa08a28d9fbfd1e04544d3cbe387157894102ef" translate="yes" xml:space="preserve">
          <source>And finally, the &lt;code&gt;//&lt;/code&gt; default delimiters for a match can be changed to arbitrary delimiters by putting an &lt;code&gt;'m'&lt;/code&gt; out front:</source>
          <target state="translated">最后， &lt;code&gt;//&lt;/code&gt; 匹配的默认定界符可以通过在前面加上 &lt;code&gt;'m'&lt;/code&gt; 来更改为任意定界符：</target>
        </trans-unit>
        <trans-unit id="8bfb479933b19ce9cc3cdcd7ea52e1ab56622323" translate="yes" xml:space="preserve">
          <source>And finally, the flag UNICODE_WARN_ILLEGAL_INTERCHANGE selects all four of the above WARN flags; and UNICODE_DISALLOW_ILLEGAL_INTERCHANGE selects all four DISALLOW flags.</source>
          <target state="translated">最后,标志UNICODE_WARN_ILLEGAL_INTERCHANGE选择上述所有四个WARN标志;UNICODE_DISALLOW_ILLEGAL_INTERCHANGE选择所有四个DISALLOW标志。</target>
        </trans-unit>
        <trans-unit id="805a895ac4ae294cb6372936f60badec42431ba0" translate="yes" xml:space="preserve">
          <source>And get the correct results.</source>
          <target state="translated">并得到正确的结果。</target>
        </trans-unit>
        <trans-unit id="e2f2205f3663f3c210b60bce452eee7ce9387b44" translate="yes" xml:space="preserve">
          <source>And have a look at the return value:</source>
          <target state="translated">并看一下返回值。</target>
        </trans-unit>
        <trans-unit id="fbc4c3241647a832011ec07f9650e675a0c500ca" translate="yes" xml:space="preserve">
          <source>And here are some alternative portable ways to write them:</source>
          <target state="translated">而这里有一些可供选择的便携方式来编写它们。</target>
        </trans-unit>
        <trans-unit id="dd7d82addca3d88c7a2654bf3c9e6dcef14475a8" translate="yes" xml:space="preserve">
          <source>And here is an example of</source>
          <target state="translated">下面是一个例子</target>
        </trans-unit>
        <trans-unit id="d607f0d907db7da1691c33f97b8d6b2f2769c71d" translate="yes" xml:space="preserve">
          <source>And here is some Perl to test it.</source>
          <target state="translated">这里有一些Perl来测试它。</target>
        </trans-unit>
        <trans-unit id="97a015e04d33b93191e1790b436d13c5a1d0ec08" translate="yes" xml:space="preserve">
          <source>And here is the previous example modified to use the &lt;code&gt;comment&lt;/code&gt; method (which requires the tied object):</source>
          <target state="translated">这是修改为使用 &lt;code&gt;comment&lt;/code&gt; 方法（需要绑定对象）的先前示例：</target>
        </trans-unit>
        <trans-unit id="949c884471ed5b1d107f6efb48c3d4a2b28f9c98" translate="yes" xml:space="preserve">
          <source>And here it is as a subroutine, modeled after the above:</source>
          <target state="translated">而这里是作为一个子程序,仿照上面的样子。</target>
        </trans-unit>
        <trans-unit id="33110031311636694f867a410fcd13fa8bb80c0c" translate="yes" xml:space="preserve">
          <source>And here's a corresponding server to go along with it. We'll leave the address as &lt;code&gt;INADDR_ANY&lt;/code&gt; so that the kernel can choose the appropriate interface on multihomed hosts. If you want sit on a particular interface (like the external side of a gateway or firewall machine), fill this in with your real address instead.</source>
          <target state="translated">这是与之配套的相应服务器。我们将地址保留为 &lt;code&gt;INADDR_ANY&lt;/code&gt; ,以便内核可以在多宿主主机上选择适当的接口。如果您想坐在一个特定的接口上（例如网关或防火墙机器的外部），请用您的真实地址填写。</target>
        </trans-unit>
        <trans-unit id="dbd6a4af2108db6ae982ecf10d7522ed7e526a16" translate="yes" xml:space="preserve">
          <source>And here's a corresponding server. You don't have to worry about silly network terminators here because Unix domain sockets are guaranteed to be on the localhost, and thus everything works right.</source>
          <target state="translated">而这里是对应的服务器。在这里你不必担心愚蠢的网络终结器,因为Unix域名套接字保证在本地主机上,因此一切都能正常工作。</target>
        </trans-unit>
        <trans-unit id="944b5652f25ab675361c7efd6d5681a5765fc752" translate="yes" xml:space="preserve">
          <source>And here's a multitasking version. It's multitasked in that like most typical servers, it spawns (fork()s) a slave server to handle the client request so that the master server can quickly go back to service a new client.</source>
          <target state="translated">这是一个多任务的版本。它的多任务性在于,像大多数典型的服务器一样,它产生(fork()s)一个从属服务器来处理客户的请求,这样主服务器就可以快速地回去服务一个新的客户。</target>
        </trans-unit>
        <trans-unit id="412d21e904b4a5d9be299f9e46dd7d8fb8650015" translate="yes" xml:space="preserve">
          <source>And here's a reimplementation of the Perl &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; operator:</source>
          <target state="translated">这是Perl &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 运算符的重新实现：</target>
        </trans-unit>
        <trans-unit id="a39e0321aadc55f074a271968aaa41d7162f8c6f" translate="yes" xml:space="preserve">
          <source>And here's a safe pipe open for writing:</source>
          <target state="translated">而这里有一个安全的管子开着写。</target>
        </trans-unit>
        <trans-unit id="e0737e576532a52571f2f02f804f1b9fffb668de" translate="yes" xml:space="preserve">
          <source>And here's how it could be (ab)used:</source>
          <target state="translated">下面是它的使用方法。</target>
        </trans-unit>
        <trans-unit id="9d8d64c2d75cb873a59d78e68255422a53fcc02a" translate="yes" xml:space="preserve">
          <source>And here's how to start up a child process you intend to read from:</source>
          <target state="translated">而在这里,如何启动一个孩子的过程,你打算从。</target>
        </trans-unit>
        <trans-unit id="4c941c96c3f11d53f1f07f2e00498b7a8046f1f0" translate="yes" xml:space="preserve">
          <source>And here's the &lt;code&gt;HotKey&lt;/code&gt; module, which hides the somewhat mystifying calls to manipulate the POSIX termios structures.</source>
          <target state="translated">这是 &lt;code&gt;HotKey&lt;/code&gt; 模块，它隐藏了一些令人迷惑的调用来操纵POSIX termios结构。</target>
        </trans-unit>
        <trans-unit id="c1de37a9a564348e268bb7765797260079df1212" translate="yes" xml:space="preserve">
          <source>And if it's an integer</source>
          <target state="translated">如果它是一个整数</target>
        </trans-unit>
        <trans-unit id="1e83d880ce4037fe2787ac7496582407c6b33838" translate="yes" xml:space="preserve">
          <source>And if the protocol you're using supports a way of letting the recipient know which character encoding you used, please help the receiving end by using that feature! For example, E-mail and HTTP support MIME headers, so you can use the &lt;code&gt;Content-Type&lt;/code&gt; header. They can also have &lt;code&gt;Content-Length&lt;/code&gt; to indicate the number of</source>
          <target state="translated">并且，如果您使用的协议支持让接收者知道您使用了哪种字符编码的方式，请使用该功能来帮助接收方！例如，电子邮件和HTTP支持MIME标头，因此您可以使用 &lt;code&gt;Content-Type&lt;/code&gt; 标头。他们还可以使用 &lt;code&gt;Content-Length&lt;/code&gt; 来指示</target>
        </trans-unit>
        <trans-unit id="530bb41f401dd9a37c76bab8cac0844cf9ab82e0" translate="yes" xml:space="preserve">
          <source>And if you used &lt;code&gt;*&lt;/code&gt; 's in the internal groups instead of limiting them to 0 through 5 matches, then it would take forever--or until you ran out of stack space. Moreover, these internal optimizations are not always applicable. For example, if you put &lt;code&gt;{0,5}&lt;/code&gt; instead of &lt;code&gt;*&lt;/code&gt; on the external group, no current optimization is applicable, and the match takes a long time to finish.</source>
          <target state="translated">而且，如果您在内部组中使用 &lt;code&gt;*&lt;/code&gt; 而不是将它们限制为0到5个匹配项，那将需要花费很长的时间，或者直到耗尽堆栈空间为止。而且，这些内部优化并不总是适用。例如，如果将 &lt;code&gt;{0,5}&lt;/code&gt; 而不是 &lt;code&gt;*&lt;/code&gt; 放在外部组上，则当前的优化不适用，并且匹配需要很长时间才能完成。</target>
        </trans-unit>
        <trans-unit id="85fb030d5b378f589d8d5a1abf4a0effa17a51ec" translate="yes" xml:space="preserve">
          <source>And if you want to repeat any previous command, use the exclamation: '&lt;b&gt;!&lt;/b&gt;':</source>
          <target state="translated">而且，如果您想重复任何先前的命令，请使用感叹号：' &lt;b&gt;！&lt;/b&gt; '：</target>
        </trans-unit>
        <trans-unit id="81ee0ae161979dc9986599ac47ae17f4297a5e95" translate="yes" xml:space="preserve">
          <source>And if you wanted to list line 5 again, type 'l 5', (note the space):</source>
          <target state="translated">如果你想再次列出第5行,输入'l 5',(注意空格)。</target>
        </trans-unit>
        <trans-unit id="749d2869c6a2cd1160d264bfc5684c9df865e407" translate="yes" xml:space="preserve">
          <source>And if you're not writing a formatter class, but are instead just writing a program that does something simple with a Pod::PullParser object (and not an object of a subclass), then there's no reason to bother subclassing to add a &lt;code&gt;run&lt;/code&gt; method.</source>
          <target state="translated">而且，如果您不是在编写格式化程序类，而是在编写一个使用Pod :: PullParser对象（而不是子类的对象）执行简单操作的程序，那么就没有理由费心子类来添加 &lt;code&gt;run&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="a90e884faa57a601f440de65c751d0540510d763" translate="yes" xml:space="preserve">
          <source>And in gdb do:</source>
          <target state="translated">而在gdb做。</target>
        </trans-unit>
        <trans-unit id="81cf331b9c5b31a88becd7901f7891213a4ee929" translate="yes" xml:space="preserve">
          <source>And in gdb:</source>
          <target state="translated">而在gdb中。</target>
        </trans-unit>
        <trans-unit id="46441ba6d0d6e8d0a7cff3ad4e65de9157fcaa3a" translate="yes" xml:space="preserve">
          <source>And in the special case of Unix value 1 the encoding is:</source>
          <target state="translated">而在Unix值1的特殊情况下,编码是。</target>
        </trans-unit>
        <trans-unit id="c703bcbb84cf0b00ade16c5fcf17098b7ecf2788" translate="yes" xml:space="preserve">
          <source>And it worked; nowadays, those legacy standards are rarely used. Most everyone uses Unicode.</source>
          <target state="translated">而且它是有效的;现在,这些传统标准很少被使用。大多数人都在使用Unicode。</target>
        </trans-unit>
        <trans-unit id="54037314563b22510a39098497cd62d4a291d5ca" translate="yes" xml:space="preserve">
          <source>And it'll be faster, too, since we can begin processing the program's stdout immediately, rather than waiting for the program to finish.</source>
          <target state="translated">而且速度也会更快,因为我们可以立即开始处理程序的stdout,而不是等待程序完成。</target>
        </trans-unit>
        <trans-unit id="05b8d44f52c6cb1137bdef7406a03b86305390f3" translate="yes" xml:space="preserve">
          <source>And just before we start the loop, we'll set &lt;code&gt;patcopy&lt;/code&gt; to be the start of &lt;code&gt;pat&lt;/code&gt; :</source>
          <target state="translated">在开始循环之前，我们将 &lt;code&gt;patcopy&lt;/code&gt; 设置为 &lt;code&gt;pat&lt;/code&gt; 的开始：</target>
        </trans-unit>
        <trans-unit id="5d9997bbf1b12f8dbc675ed04e53a7e01c218a79" translate="yes" xml:space="preserve">
          <source>And just use a multilevel hash to start with.</source>
          <target state="translated">而且只要使用多级哈希开始。</target>
        </trans-unit>
        <trans-unit id="6f762806ee86000a08af1e9120bb69dbd27df3b8" translate="yes" xml:space="preserve">
          <source>And let's have a look at it:</source>
          <target state="translated">让我们一起来看看吧。</target>
        </trans-unit>
        <trans-unit id="3304a768e2182435437e989432d9119802e93fc2" translate="yes" xml:space="preserve">
          <source>And locally for months:</source>
          <target state="translated">而在当地几个月。</target>
        </trans-unit>
        <trans-unit id="a3a5e5aaccae80b6482e3c73484c3e27d16e3695" translate="yes" xml:space="preserve">
          <source>And make sure the '|1' or '|3' entry FOLLOWS the '|0' entry.</source>
          <target state="translated">并确保'|1'或'|3'条目在'|0'条目之后。</target>
        </trans-unit>
        <trans-unit id="13b0bb554f54abc8fbffc8c8994d2d663c4a335c" translate="yes" xml:space="preserve">
          <source>And make the &lt;code&gt;SHELL&lt;/code&gt; environment variable point to this</source>
          <target state="translated">并使 &lt;code&gt;SHELL&lt;/code&gt; 环境变量指向此</target>
        </trans-unit>
        <trans-unit id="be7020a4d943fe59e561bee80058c6fdc65ab9a2" translate="yes" xml:space="preserve">
          <source>And more miscellaneous functions:</source>
          <target state="translated">还有更多的杂牌功能。</target>
        </trans-unit>
        <trans-unit id="d2abac4d1c06c7d4176cadc5fbb88490348f44bd" translate="yes" xml:space="preserve">
          <source>And now some examples as a list operator:</source>
          <target state="translated">而现在作为列表操作符的一些例子。</target>
        </trans-unit>
        <trans-unit id="325f253298d4946260db0eee17abb5d004c58cf0" translate="yes" xml:space="preserve">
          <source>And now the Perl program calling &lt;code&gt;tzname&lt;/code&gt; , the two values will be assigned as in:</source>
          <target state="translated">现在，Perl程序调用 &lt;code&gt;tzname&lt;/code&gt; ，这两个值的分配方式如下：</target>
        </trans-unit>
        <trans-unit id="22d6d0f0cc9d0f09a7a155f9b933e949a3d93b8d" translate="yes" xml:space="preserve">
          <source>And now when we run it, we get &quot;\n&quot; still, but at least we know why. Just getting this script to compile has exposed the '$varl' (with the letter 'l') variable, and simply changing $varl to $var1 solves the problem.</source>
          <target state="translated">而现在当我们运行它的时候,我们得到的仍然是&quot;\n&quot;,但至少我们知道为什么。只要让这个脚本编译,就已经暴露了'$varl'(带字母'l')变量,只要把$varl改成$var1就能解决问题。</target>
        </trans-unit>
        <trans-unit id="5ed144a58c9fd20df52c8636158ebb39098e1299" translate="yes" xml:space="preserve">
          <source>And now whenever either of those variables is accessed, its current system priority is retrieved and returned. If those variables are set, then the process's priority is changed!</source>
          <target state="translated">而现在每当访问其中任何一个变量时,都会检索并返回其当前的系统优先级。如果这些变量被设置了,那么进程的优先级就会被改变!</target>
        </trans-unit>
        <trans-unit id="f9560789fd59b77ec60e56d7ede2c768c8b84e1a" translate="yes" xml:space="preserve">
          <source>And now you will only have duplicates when the keys themselves are truly the same. (note: in versions of the db library prior to about November 1996, such duplicate keys were retained so it was possible to recover the original keys in sets of keys that compared as equal).</source>
          <target state="translated">而现在只有当键本身真正相同时,你才会有重复的键。(注意:在大约1996年11月之前的db库版本中,这种重复的键被保留了下来,所以可以在比较相同的键组中恢复原始键)。</target>
        </trans-unit>
        <trans-unit id="5a5750ab899553015c34706ef7f35d79aa761c9c" translate="yes" xml:space="preserve">
          <source>And of course a very basic test:</source>
          <target state="translated">当然也是一个很基础的测试。</target>
        </trans-unit>
        <trans-unit id="892ba36b3022eacc3edbb4c21af99c36c593d715" translate="yes" xml:space="preserve">
          <source>And on the off chance you need a literal tilde in a bracket expression, you get it with &quot;~~&quot;.</source>
          <target state="translated">如果你需要在括号内的表达式中使用文字符号,你可以用&quot;~~&quot;来实现。</target>
        </trans-unit>
        <trans-unit id="7c31eaf7ebf6ce5c72185594ad0e1b74e04b6fe1" translate="yes" xml:space="preserve">
          <source>And only on Solaris 8 you also need:</source>
          <target state="translated">而只有在Solaris 8上你还需要。</target>
        </trans-unit>
        <trans-unit id="15fba9c4eb39007661b94becfb32901d56aa6cd3" translate="yes" xml:space="preserve">
          <source>And only the last two of these match:</source>
          <target state="translated">而且只有最后两个符合。</target>
        </trans-unit>
        <trans-unit id="96df95971f3fa6b1c473a349d8884984b667322b" translate="yes" xml:space="preserve">
          <source>And other assignment variations are analogous to &lt;code&gt;'+='&lt;/code&gt; and &lt;code&gt;'-='&lt;/code&gt; (and similar to &lt;code&gt;'.='&lt;/code&gt; and &lt;code&gt;'x='&lt;/code&gt; above):</source>
          <target state="translated">其他分配变体类似于 &lt;code&gt;'+='&lt;/code&gt; 和 &lt;code&gt;'-='&lt;/code&gt; （并类似于上面的 &lt;code&gt;'.='&lt;/code&gt; 和 &lt;code&gt;'x='&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="efa161d50be827f153878be8fe5d6eeddd3f9aab" translate="yes" xml:space="preserve">
          <source>And perhaps most importantly, keep the items consistent: either use &quot;=item *&quot; for all of them, to produce bullets; or use &quot;=item 1.&quot;, &quot;=item 2.&quot;, etc., to produce numbered lists; or use &quot;=item foo&quot;, &quot;=item bar&quot;, etc.--namely, things that look nothing like bullets or numbers.</source>
          <target state="translated">也许最重要的是,保持项目的一致性:要么对所有项目使用&quot;=项目*&quot;,以产生子弹;要么使用&quot;=项目1.&quot;、&quot;=项目2.&quot;等,以产生数字列表;要么使用&quot;=项目foo&quot;、&quot;=项目bar &quot;等 ----即那些看起来完全不像子弹或数字的东西。</target>
        </trans-unit>
        <trans-unit id="f91e4f8b7302927647ddce5513c00f7d31bca99b" translate="yes" xml:space="preserve">
          <source>And since we're on that subject ...</source>
          <target state="translated">既然说到这个话题......</target>
        </trans-unit>
        <trans-unit id="787438686ae95a1032fa3a9e1aa177c6c4fd8565" translate="yes" xml:space="preserve">
          <source>And so do these:</source>
          <target state="translated">这些也是如此。</target>
        </trans-unit>
        <trans-unit id="58a765d6600ae95d5f3b4bad120d6d7aba62ac6d" translate="yes" xml:space="preserve">
          <source>And success is always the value 0 in all behaviors.</source>
          <target state="translated">而在所有行为中,成功的值总是0。</target>
        </trans-unit>
        <trans-unit id="438bed71f720bad1480f9f02fbee09a0688495fa" translate="yes" xml:space="preserve">
          <source>And suppose then that you answer client requests for language $wanted by just looking up $greetings{$wanted}.</source>
          <target state="translated">那么假设你只需查找$greetings{$wanted}就可以回答客户对语言$wanted的请求。</target>
        </trans-unit>
        <trans-unit id="2669b5893403010caa914594080405bbbce0ff5c" translate="yes" xml:space="preserve">
          <source>And suppose you write a program that reads that file and then runs as a daemon, answering client requests that specify a language tag and then expect the string that says how to greet in that language. So an interaction looks like:</source>
          <target state="translated">假设你写了一个程序,读取该文件,然后作为守护进程运行,回答客户指定语言标签的请求,然后期待该语言的字符串,说明如何打招呼。那么一个交互的样子是这样的。</target>
        </trans-unit>
        <trans-unit id="2df99fba715f8ad036f73439b0d1c572a25bb0d8" translate="yes" xml:space="preserve">
          <source>And that does the Right Thing.</source>
          <target state="translated">而这也是正确的做法。</target>
        </trans-unit>
        <trans-unit id="f185ef04d67f1d1642dde1d5aaeb827268181df4" translate="yes" xml:space="preserve">
          <source>And that's where the first quirk strikes: &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; templates have to be stuffed with &lt;code&gt;x&lt;/code&gt; codes to get those extra fill bytes.</source>
          <target state="translated">而这也正是第一个怪癖罢工： &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 的模板都必须得到塞 &lt;code&gt;x&lt;/code&gt; 代码来获得这些额外的补字节。</target>
        </trans-unit>
        <trans-unit id="69c7d2fddd9456e1d45eb87fbe318da0c23d0419" translate="yes" xml:space="preserve">
          <source>And the removal of:</source>
          <target state="translated">而除去。</target>
        </trans-unit>
        <trans-unit id="6321b918eecf63aae95252ec27d4a4007661cbea" translate="yes" xml:space="preserve">
          <source>And then at least you can use the values(), which will be real refs, instead of the keys(), which won't.</source>
          <target state="translated">然后至少你可以使用value(),这将是真正的参考,而不是keys(),后者不会。</target>
        </trans-unit>
        <trans-unit id="4c721f20845157aa106a3ca5329f5d50475f12f2" translate="yes" xml:space="preserve">
          <source>And then hard-code it, leaving porting as an exercise to your successor.</source>
          <target state="translated">然后硬编码,把移植作为一种练习留给你的接班人。</target>
        </trans-unit>
        <trans-unit id="47e6e2e5fec5f13213aa3c81c38b973ca1f59e41" translate="yes" xml:space="preserve">
          <source>And then instead of storing the compiled value in the lexicon hash it will store it in $lh-&amp;gt;{'_external_lex_cache'}</source>
          <target state="translated">然后，将编译后的值存储在$ lh-&amp;gt; {'_ external_lex_cache'}中，而不是将编译后的值存储在词典哈希中</target>
        </trans-unit>
        <trans-unit id="4ddb0364527af5ee5b5762f819c0ea16f6ac0a17" translate="yes" xml:space="preserve">
          <source>And then open as before, choosing &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; , or &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; as needed:</source>
          <target state="translated">然后像以前一样打开，根据需要选择 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; ， &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="733e92d2677896a5105fc9334a5547dcbabc4286" translate="yes" xml:space="preserve">
          <source>And then provide a typemap entry &lt;code&gt;T_PTROBJ_SPECIAL&lt;/code&gt; that maps underscores to double-colons (::), and declare &lt;code&gt;Net_Config&lt;/code&gt; to be of that type:</source>
          <target state="translated">然后提供一个 &lt;code&gt;T_PTROBJ_SPECIAL&lt;/code&gt; 映射项T_PTROBJ_SPECIAL，它将下划线映射到双冒号（：:)，并声明 &lt;code&gt;Net_Config&lt;/code&gt; 为该类型：</target>
        </trans-unit>
        <trans-unit id="0b78c6f57eb325a818fb40b5bb64b41ae51db883" translate="yes" xml:space="preserve">
          <source>And then replace the hash name with the reference:</source>
          <target state="translated">然后将哈希名称替换为引用。</target>
        </trans-unit>
        <trans-unit id="1482b41f1c8c23a1b6f51e392e8562858f488f4e" translate="yes" xml:space="preserve">
          <source>And then set PERL5LIB to</source>
          <target state="translated">然后将PERL5LIB设置为</target>
        </trans-unit>
        <trans-unit id="e66399c5da24330a870822849d8e76cf4cddfe41" translate="yes" xml:space="preserve">
          <source>And then step until you hit what you're looking for. This works well in a loop if you want to only break at certain iterations:</source>
          <target state="translated">然后一步步走,直到你找到你要找的东西。如果你想只在某些迭代时中断,这在循环中很好用。</target>
        </trans-unit>
        <trans-unit id="4fa5c1cdc4927fc4a1301e4902474775669ad62e" translate="yes" xml:space="preserve">
          <source>And these conditions hold</source>
          <target state="translated">而这些条件都成立</target>
        </trans-unit>
        <trans-unit id="d5d9b0ee41acfcea7375d0a36877f181aee3c098" translate="yes" xml:space="preserve">
          <source>And they all mean exactly the same as this:</source>
          <target state="translated">而且他们的意思都和这个一模一样。</target>
        </trans-unit>
        <trans-unit id="8536c300c45ef5952d0313ea8b714a35911f6d2e" translate="yes" xml:space="preserve">
          <source>And this example uses anonymous subroutines to create separate counters:</source>
          <target state="translated">而这个例子使用匿名子程序来创建单独的计数器。</target>
        </trans-unit>
        <trans-unit id="2e09b2a3ab0575b70e3e084aed68993db1ebce78" translate="yes" xml:space="preserve">
          <source>And this is the XS code:</source>
          <target state="translated">而这是XS码。</target>
        </trans-unit>
        <trans-unit id="1e0a495178fdf07510ea88975dd8d193311ceae6" translate="yes" xml:space="preserve">
          <source>And this is what the script above will print:</source>
          <target state="translated">这就是上面脚本的打印效果。</target>
        </trans-unit>
        <trans-unit id="35194f4922bc124f887493e5a4a0600918a32f35" translate="yes" xml:space="preserve">
          <source>And this isn't the whole story. Starting in Perl v5.12, strings that aren't encoded in UTF-8 may also be treated as Unicode under various conditions (see &lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII Rules versus Unicode Rules in perlunicode&lt;/a&gt;). This is only really a problem for characters whose ordinals are between 128 and 255, and their behavior varies under ASCII versus Unicode rules in ways that your code cares about (see &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug in perlunicode&lt;/a&gt;). There is no published API for dealing with this, as it is subject to change, but you can look at the code for &lt;code&gt;pp_lc&lt;/code&gt; in</source>
          <target state="translated">这还不是全部。从Perl v5.12开始，未使用UTF-8编码的字符串在各种情况下也可以被视为Unicode（请参阅&lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;perlunicode中的ASCII规则与Unicode规则&lt;/a&gt;）。这仅对于序数在128到255之间的字符确实是一个问题，并且它们的行为在ASCII和Unicode规则下以代码关心的方式变化（请参阅&lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicode中的Unicode错误&lt;/a&gt;）。有没有发布的API来处理这个问题，因为它是可能发生变化，但你可以看看代码 &lt;code&gt;pp_lc&lt;/code&gt; 在</target>
        </trans-unit>
        <trans-unit id="04dc4562232363a5a2cdcef5ad0c57a632cc4d72" translate="yes" xml:space="preserve">
          <source>And this one reads from the child:</source>
          <target state="translated">而这个是从孩子身上读出来的。</target>
        </trans-unit>
        <trans-unit id="22fab1b1ab24735dd2f54767a6ec2977de574611" translate="yes" xml:space="preserve">
          <source>And this too is valid:</source>
          <target state="translated">而这也是有道理的。</target>
        </trans-unit>
        <trans-unit id="ca100b799213c6d95d191edf790bdf80dab3cf7a" translate="yes" xml:space="preserve">
          <source>And this:</source>
          <target state="translated">还有这个</target>
        </trans-unit>
        <trans-unit id="ca54ab72a0f62623ded9fadca0c4ae598b7f81fe" translate="yes" xml:space="preserve">
          <source>And to check the sequence in which the library directories are searched by perl, run</source>
          <target state="translated">要检查perl搜索库目录的顺序,运行</target>
        </trans-unit>
        <trans-unit id="362fec7b951a6425bfa81311e580eeb12dfb603d" translate="yes" xml:space="preserve">
          <source>And to desurrogate;</source>
          <target state="translated">而代孕。</target>
        </trans-unit>
        <trans-unit id="2615ff8743f40d3114fe04e3d5a96ce87c8f4c9d" translate="yes" xml:space="preserve">
          <source>And try again:</source>
          <target state="translated">然后再试一次。</target>
        </trans-unit>
        <trans-unit id="92794ee0d6f5c6f795ca92dffa6111092171b2bc" translate="yes" xml:space="preserve">
          <source>And we end up with the program:</source>
          <target state="translated">而我们最终的方案。</target>
        </trans-unit>
        <trans-unit id="397d92a7cd41c0dad432b26c8f27299cae1c6b41" translate="yes" xml:space="preserve">
          <source>And with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding &quot;euc-jp&quot;&lt;/code&gt; in effect, it is the same thing as that code in UTF-8:</source>
          <target state="translated">而随着 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding &quot;euc-jp&quot;&lt;/code&gt; 的效果，这是同样的事情在UTF-8的代码：</target>
        </trans-unit>
        <trans-unit id="e0cc2408ca05432d5f7face5b62924a44acb8f84" translate="yes" xml:space="preserve">
          <source>And your caller module would be something like this:</source>
          <target state="translated">而你的呼叫器模块应该是这样的。</target>
        </trans-unit>
        <trans-unit id="f429519c2ad8f6db43559b6df0122aa7e92ef582" translate="yes" xml:space="preserve">
          <source>And, as you'll have noticed from the previous example, if you override &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob operator is overridden as well.</source>
          <target state="translated">而且，从上一个示例中您已经注意到，如果您覆盖 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; ，那么 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob运算符也会被覆盖。</target>
        </trans-unit>
        <trans-unit id="0872d4a5d2061a3d40ffa31b9853ff607e66e0c5" translate="yes" xml:space="preserve">
          <source>And, the Name and Name_Aliases properties are accessible through the &lt;code&gt;\N{}&lt;/code&gt; interpolation in double-quoted strings and regular expressions; and functions &lt;code&gt;charnames::viacode()&lt;/code&gt; , &lt;code&gt;charnames::vianame()&lt;/code&gt; , and &lt;code&gt;charnames::string_vianame()&lt;/code&gt; (which require a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames ();&lt;/code&gt; to be specified.</source>
          <target state="translated">而且，可以通过 &lt;code&gt;\N{}&lt;/code&gt; 插值在双引号字符串和正则表达式中访问Name和Name_Aliases属性。和功能 &lt;code&gt;charnames::viacode()&lt;/code&gt; ， &lt;code&gt;charnames::vianame()&lt;/code&gt; 和 &lt;code&gt;charnames::string_vianame()&lt;/code&gt; （需要指定 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames ();&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b49cf0754660175d0a77b4c857d087e651cbf367" translate="yes" xml:space="preserve">
          <source>And, with Perl 5.10 and later, you don't have to check for an inheritance to see if the object can handle a role. For that, you can use &lt;code&gt;DOES&lt;/code&gt; , which comes from &lt;code&gt;UNIVERSAL&lt;/code&gt; :</source>
          <target state="translated">而且，在Perl 5.10及更高版本中，您不必检查继承即可查看对象是否可以处理角色。为此，您可以使用来自 &lt;code&gt;UNIVERSAL&lt;/code&gt; 的 &lt;code&gt;DOES&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5b41c9a4e6f27e4cb868723e388d3e3baf23ec77" translate="yes" xml:space="preserve">
          <source>Andreas Koenig &lt;code&gt;&amp;lt;andk@cpan.org&amp;gt;&lt;/code&gt;</source>
          <target state="translated">安德烈亚斯&amp;middot;科尼格（Andreas Koenig） &lt;code&gt;&amp;lt;andk@cpan.org&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17721a7a6efc10cf2782e06109ae542e5e371c5d" translate="yes" xml:space="preserve">
          <source>Andreas Koenig &lt;code&gt;andreas.koenig@anima.de&lt;/code&gt;</source>
          <target state="translated">安德烈亚斯&amp;middot;科尼格（Andreas Koenig） &lt;code&gt;andreas.koenig@anima.de&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2f8905b2465e6f0ad9cfd91b9febf4156adfa14" translate="yes" xml:space="preserve">
          <source>Andy Armstong &amp;lt;andy@hexten.net&amp;gt;</source>
          <target state="translated">安迪&amp;middot;阿姆斯通&amp;lt;andy@hexten.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d272317e48a940ed9b68adfad919572635019ce3" translate="yes" xml:space="preserve">
          <source>Andy Armstrong &lt;code&gt;&amp;lt;andy@hexten.net&amp;gt;&lt;/code&gt;</source>
          <target state="translated">安迪&amp;middot;阿姆斯特朗 &lt;code&gt;&amp;lt;andy@hexten.net&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b85b5eb312e6917fec0aa730c7d70660252958f" translate="yes" xml:space="preserve">
          <source>Andy Armstrong, &amp;lt;andy@hexten.net&amp;gt;</source>
          <target state="translated">安迪&amp;middot;阿姆斯特朗（Andy Armstrong），&amp;lt;andy@hexten.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8e9ef1486d01c7ad977376f692dc981d906e478c" translate="yes" xml:space="preserve">
          <source>Andy Dougherty &lt;code&gt;doughera@lafayette.edu&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt; , Tim Bunce &lt;code&gt;timb@cpan.org&lt;/code&gt; . VMS support by Charles Bailey &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt; . OS/2 support by Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; .</source>
          <target state="translated">安迪&amp;middot;多尔蒂 &lt;code&gt;doughera@lafayette.edu&lt;/code&gt; ，安德烈亚斯&amp;middot;柯尼希 &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt; ，蒂姆&amp;middot;邦斯 &lt;code&gt;timb@cpan.org&lt;/code&gt; 。VMS支持由Charles Bailey &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt; 提供。OS / 2支持由Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; 提供。</target>
        </trans-unit>
        <trans-unit id="f309e7ea03de47735dc8e5cfc8cc01f796755634" translate="yes" xml:space="preserve">
          <source>Anecdotal estimates of source-to-compiled code bloat suggest an eightfold increase. This means that the compiled form of reasonable (normally commented, properly indented etc.) code will take about eight times more space in memory than the code took on disk.</source>
          <target state="translated">据传闻估计,源码到编译后的代码膨胀率增加了八倍。这意味着合理的编译形式(通常有注释、适当缩进等)的代码在内存中占用的空间将比代码在磁盘上占用的空间多八倍。</target>
        </trans-unit>
        <trans-unit id="dd5ff38fa4ac27c93c3c6622ac77c49ca0b0e6b7" translate="yes" xml:space="preserve">
          <source>Angle brackets not written as &lt;code&gt;&amp;lt;lt&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;gt&amp;gt;&lt;/code&gt; can potentially cause errors as they could be misinterpreted as markup commands. This is only printed when the -warnings level is greater than 1.</source>
          <target state="translated">不写为 &lt;code&gt;&amp;lt;lt&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;gt&amp;gt;&lt;/code&gt; 的尖括号可能会引起错误，因为它们可能会被误解为标记命令。仅当-warnings级别大于1时才打印。</target>
        </trans-unit>
        <trans-unit id="4a0daf5f778b84f7d47324f4951f69110d4d48b4" translate="yes" xml:space="preserve">
          <source>Anno Siegel (ANNO) wrote the xs code and the changes in perl proper Jerry Hedden (JDHEDDEN) made it faster</source>
          <target state="translated">Anno Siegel(ANNO)写了xs代码,perl适当的改动Jerry Hedden(JDHEDDEN)让它更快。</target>
        </trans-unit>
        <trans-unit id="4fa7bfd58b194e39ca2dde6c48f032e168048d8e" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt;: &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&lt;/a&gt;</source>
          <target state="translated">带注释的POD &lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;：&lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;http&lt;/a&gt; : //annocpan.org/? mode=search&amp;amp;field=Module&amp;amp;name= threads</target>
        </trans-unit>
        <trans-unit id="ba63b983b01c370d674ecdc009b4d7bcd13f4f33" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;: &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&lt;/a&gt;</source>
          <target state="translated">带&lt;a href=&quot;threads/shared&quot;&gt;螺纹的&lt;/a&gt;注释POD :: shared：&lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;http&lt;/a&gt; : //annocpan.org/? mode=search&amp;amp;field=Module&amp;amp;name= threads%3A% 3Ashared</target>
        </trans-unit>
        <trans-unit id="4d0700dd0d246c337cd6fa922a92caa253e25b21" translate="yes" xml:space="preserve">
          <source>Annotated list of characters</source>
          <target state="translated">附加说明的人物名单</target>
        </trans-unit>
        <trans-unit id="911169a23e106a872e476c8d2fa5935672c571c0" translate="yes" xml:space="preserve">
          <source>Anonymous hash and array composers like these can be intermixed freely to produce as complicated a structure as you want. The multidimensional syntax described below works for these too. The values above are literals, but variables and expressions would work just as well, because assignment operators in Perl (even within local() or my()) are executable statements, not compile-time declarations.</source>
          <target state="translated">像这样的匿名哈希和数组合成器可以自由混合,产生你想要的复杂结构。下面描述的多维语法也适用于这些结构。上面的值是字面值,但变量和表达式也同样适用,因为Perl中的赋值运算符(甚至在local()或my()中)是可执行的语句,而不是编译时的声明。</target>
        </trans-unit>
        <trans-unit id="ddd265fb1f3b46963f4185e092c2f56d761a6e96" translate="yes" xml:space="preserve">
          <source>Anonymous subroutines act as closures with respect to my() variables, that is, variables lexically visible within the current scope. Closure is a notion out of the Lisp world that says if you define an anonymous function in a particular lexical context, it pretends to run in that context even when it's called outside the context.</source>
          <target state="translated">匿名子程序相对于my()变量,也就是当前作用域内词法可见的变量,起到了闭包的作用。闭包是Lisp世界中的一个概念,它说如果你在一个特定的词法上下文中定义了一个匿名函数,那么即使在上下文外调用它,它也会假装在这个上下文中运行。</target>
        </trans-unit>
        <trans-unit id="3eb95879a615d5ea34c741b40bf67030c1977968" translate="yes" xml:space="preserve">
          <source>Anonymous subroutines get to capture each time you execute the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; operator, as they are created on the fly. If you are accustomed to using nested subroutines in other programming languages with their own private variables, you'll have to work at it a bit in Perl. The intuitive coding of this type of thing incurs mysterious warnings about &quot;will not stay shared&quot; due to the reasons explained above. For example, this won't work:</source>
          <target state="translated">匿名子程序得到每次执行时捕获 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 运营商，因为它们是动态创建。如果习惯于在其他编程语言中将嵌套子例程与它们自己的私有变量一起使用，则必须在Perl中进行一些处理。由于上述原因，这种类型的事物的直观编码会引发关于&amp;ldquo;将不会保持共享&amp;rdquo;的神秘警告。例如，这将不起作用：</target>
        </trans-unit>
        <trans-unit id="c0878cc2f5c4c23ed0c52c0dfcedfeb6916f96a7" translate="yes" xml:space="preserve">
          <source>Another Example</source>
          <target state="translated">另一个例子</target>
        </trans-unit>
        <trans-unit id="58127100a894b61eeb7ff5e87057e807d55c8b96" translate="yes" xml:space="preserve">
          <source>Another Example -- Key is a C int.</source>
          <target state="translated">另一个例子 --Key是一个C int。</target>
        </trans-unit>
        <trans-unit id="60d38257f9d2129e1058114b1893e74a3db974bb" translate="yes" xml:space="preserve">
          <source>Another Example: Key is a C int.</source>
          <target state="translated">另一个例子。钥匙是一个Cint。</target>
        </trans-unit>
        <trans-unit id="be5842d0c6f0b2a32d5a2aac4ce0ec4bcd453989" translate="yes" xml:space="preserve">
          <source>Another Portable Binary Encoding</source>
          <target state="translated">另一种便携式二进制编码</target>
        </trans-unit>
        <trans-unit id="a3a811e6345c52a72030025da749e7378837c8a7" translate="yes" xml:space="preserve">
          <source>Another brief debugger, slightly more useful, can be created with only the line:</source>
          <target state="translated">另一个简短的调试器,稍微有用一点,可以只用行创建。</target>
        </trans-unit>
        <trans-unit id="723c39858f051ddac15e8257e9c5bc5481712afe" translate="yes" xml:space="preserve">
          <source>Another common error is to use ordinary parentheses to construct a list reference when you should be using square or curly brackets, for example, if you say</source>
          <target state="translated">另一个常见的错误是,当你应该使用方括号或大括号时,却使用普通括号来构建列表引用,例如,如果你说</target>
        </trans-unit>
        <trans-unit id="989f6c267d1aa6631d47641c01947fa297495517" translate="yes" xml:space="preserve">
          <source>Another common use for this construct is when you need to execute something without the shell's interference. With system(), it's straightforward, but you can't use a pipe open or backticks safely. That's because there's no way to stop the shell from getting its hands on your arguments. Instead, use lower-level control to call exec() directly.</source>
          <target state="translated">这个构造的另一个常见用途是当你需要在没有shell干扰的情况下执行一些东西。使用system(),这很直接,但你不能安全地使用管道打开或回标。这是因为没有办法阻止shell对你的参数动手脚。相反,使用低级控制直接调用exec()。</target>
        </trans-unit>
        <trans-unit id="9e79a0e3805beb03c075ab9c59ea2fd3f85cbbe5" translate="yes" xml:space="preserve">
          <source>Another complication is that the representation used for the program differs if it needs to store Unicode, but it's not always possible to know for sure whether it does until midway through parsing. The Unicode representation for the program is larger, and cannot be matched as efficiently. (See &lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;Unicode and Localisation Support&lt;/a&gt; below for more details as to why.) If the pattern contains literal Unicode, it's obvious that the program needs to store Unicode. Otherwise, the parser optimistically assumes that the more efficient representation can be used, and starts sizing on this basis. However, if it then encounters something in the pattern which must be stored as Unicode, such as an &lt;code&gt;\x{...}&lt;/code&gt; escape sequence representing a character literal, then this means that all previously calculated sizes need to be redone, using values appropriate for the Unicode representation. Currently, all regular expression constructions which can trigger this are parsed by code in &lt;code&gt;regatom()&lt;/code&gt; .</source>
          <target state="translated">另一个复杂之处是，如果程序需要存储Unicode，则表示该程序所用的表示形式会有所不同，但是，直到解析过程中途，始终无法确定它是否会存储。该程序的Unicode表示形式较大，无法有效匹配。 （有关原因的更多详细信息，请参见下面的&lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;Unicode和本地化支持&lt;/a&gt;。）如果模式包含文字Unicode，则很明显程序需要存储Unicode。否则，解析器乐观地假定可以使用更有效的表示形式，并在此基础上开始调整大小。但是，如果它随后遇到模式中必须存储为Unicode的某些内容，例如 &lt;code&gt;\x{...}&lt;/code&gt; 转义序列表示一个字符文字，那么这意味着需要使用适合Unicode表示的值来重做所有先前计算的大小。当前，所有可触发此操作的正则表达式构造都通过 &lt;code&gt;regatom()&lt;/code&gt; 中的代码进行解析。</target>
        </trans-unit>
        <trans-unit id="8b313efb71a57a4464cb94a659a9e8b90c24250e" translate="yes" xml:space="preserve">
          <source>Another confusion with both these properties is that the definition is not that the code point has been</source>
          <target state="translated">这两个属性的另一个困惑是,定义并不是说代码点已被</target>
        </trans-unit>
        <trans-unit id="a7643f36484ae100d2da2d3c144ef9dbeaed949e" translate="yes" xml:space="preserve">
          <source>Another consequence of using binmode() (on some systems) is that special end-of-file markers will be seen as part of the data stream. For systems from the Microsoft family this means that, if your binary data contain &lt;code&gt;\cZ&lt;/code&gt; , the I/O subsystem will regard it as the end of the file, unless you use binmode().</source>
          <target state="translated">（在某些系统上）使用binmode（）的另一个结果是，特殊的文件结束标记将被视为数据流的一部分。对于Microsoft系列的系统，这意味着，如果您的二进制数据包含 &lt;code&gt;\cZ&lt;/code&gt; ，则I / O子系统会将其视为文件的末尾，除非您使用binmode（）。</target>
        </trans-unit>
        <trans-unit id="3cc44056a9f339f4466b010a8b6a440f514bb627" translate="yes" xml:space="preserve">
          <source>Another construct to be wary of is the inappropriate use of hex (unless you use &lt;code&gt;\N{U+...}&lt;/code&gt; ) or octal constants in regular expressions. Consider the following set of subs:</source>
          <target state="translated">另一个需要警惕的构造是在正则表达式中不适当地使用十六进制（除非使用 &lt;code&gt;\N{U+...}&lt;/code&gt; ）或八进制常量。考虑以下子集：</target>
        </trans-unit>
        <trans-unit id="dd580d9d1c12fa08ea2d8378d289e2825dd48a0c" translate="yes" xml:space="preserve">
          <source>Another description starts with notions of &quot;better&quot;/&quot;worse&quot;. All the substrings which may be matched by the given regular expression can be sorted from the &quot;best&quot; match to the &quot;worst&quot; match, and it is the &quot;best&quot; match which is chosen. This substitutes the question of &quot;what is chosen?&quot; by the question of &quot;which matches are better, and which are worse?&quot;.</source>
          <target state="translated">另一种描述是从 &quot;更好&quot;/&quot;更差 &quot;的概念开始的。所有可能被给定正则表达式匹配的子串都可以从 &quot;最佳 &quot;匹配到 &quot;最差 &quot;匹配进行排序,选择的是 &quot;最佳 &quot;匹配。这就把 &quot;选择什么 &quot;的问题改为 &quot;哪些匹配更好,哪些更差 &quot;的问题。</target>
        </trans-unit>
        <trans-unit id="856a6f6c8652259321cab00a9ad8f033dc81e6f4" translate="yes" xml:space="preserve">
          <source>Another drawback is only valid for Perl versions before 5.6.0. This drawback is that the seek and tell functions (both the builtin version and POSIX module version) will not perform correctly.</source>
          <target state="translated">另一个缺点是只对5.6.0之前的Perl版本有效。这个缺点是,seek和tell函数(包括内置版本和POSIX模块版本)将无法正确执行。</target>
        </trans-unit>
        <trans-unit id="d8eeb28f49e1f9d89b4e036aaf71838ed7700dd9" translate="yes" xml:space="preserve">
          <source>Another dummy layer. When pushed it pops itself and sets the &lt;code&gt;PERLIO_F_UTF8&lt;/code&gt; flag on the layer which was (and now is once more) the top of the stack.</source>
          <target state="translated">另一个虚拟层。按下该按钮时，它会自行弹出并在（现在又是现在）堆栈顶部的层上设置 &lt;code&gt;PERLIO_F_UTF8&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="d9e8985e4a56d117b356dcbeb0c42c3cbcba847b" translate="yes" xml:space="preserve">
          <source>Another example of a data paragraph:</source>
          <target state="translated">又是一个数据段的例子。</target>
        </trans-unit>
        <trans-unit id="b5c62d28b9310748f7a00e0cde763766b0ceff47" translate="yes" xml:space="preserve">
          <source>Another example switched the first &quot;latin1&quot; encoding it finds to &quot;utf8&quot; in a pod file:</source>
          <target state="translated">另一个例子将它发现的第一个 &quot;latin1 &quot;编码切换为pod文件中的 &quot;utf8&quot;。</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">另一个例子:</target>
        </trans-unit>
        <trans-unit id="ece934d7c44856dd3f545147d03b2aa737a1de6d" translate="yes" xml:space="preserve">
          <source>Another form of code expression is the</source>
          <target state="translated">代码表达式的另一种形式是</target>
        </trans-unit>
        <trans-unit id="48b78ab1e531e9b3794c2d43c0589ca792ae0b42" translate="yes" xml:space="preserve">
          <source>Another form of optimisation that can occur is the post-parse &quot;peep-hole&quot; optimisation, where inefficient constructs are replaced by more efficient constructs. The &lt;code&gt;TAIL&lt;/code&gt; regops which are used during parsing to mark the end of branches and the end of groups are examples of this. These regops are used as place-holders during construction and &quot;always match&quot; so they can be &quot;optimised away&quot; by making the things that point to the &lt;code&gt;TAIL&lt;/code&gt; point to the thing that &lt;code&gt;TAIL&lt;/code&gt; points to, thus &quot;skipping&quot; the node.</source>
          <target state="translated">可能发生的另一种优化形式是解析后的&amp;ldquo;窥孔&amp;rdquo;优化，其中将无效的构造替换为更有效的构造。在解析过程中用来标记分支结束和组结束的 &lt;code&gt;TAIL&lt;/code&gt; regops就是这样的示例。这些regops用作施工期间占位和&amp;ldquo;总是一致&amp;rdquo;，使他们能够&amp;ldquo;优化掉&amp;rdquo;通过使东西点到 &lt;code&gt;TAIL&lt;/code&gt; 点的东西， &lt;code&gt;TAIL&lt;/code&gt; 点，因此&amp;ldquo;退出&amp;rdquo;的节点。</target>
        </trans-unit>
        <trans-unit id="6a81857ae4b443a44f359782c057cbbbeb457048" translate="yes" xml:space="preserve">
          <source>Another good reason in addition to readability and maintainability for using relative backreferences is illustrated by the following example, where a simple pattern for matching peculiar strings is used:</source>
          <target state="translated">除了可读性和可维护性之外,下面的例子还说明了使用相对回溯引用的另一个很好的理由,其中使用了一个简单的模式来匹配奇特的字符串。</target>
        </trans-unit>
        <trans-unit id="bfac64b9584bc828981db16d0cc4e6658be646cc" translate="yes" xml:space="preserve">
          <source>Another interesting approach to IPC is making your single program go multiprocess and communicate between--or even amongst--yourselves. The open() function will accept a file argument of either &lt;code&gt;&quot;-|&quot;&lt;/code&gt; or &lt;code&gt;&quot;|-&quot;&lt;/code&gt; to do a very interesting thing: it forks a child connected to the filehandle you've opened. The child is running the same program as the parent. This is useful for safely opening a file when running under an assumed UID or GID, for example. If you open a pipe</source>
          <target state="translated">IPC的另一种有趣的方法是使您的单个程序进行多进程处理，并在自己之间甚至之间进行通信。open（）函数将接受文件参数 &lt;code&gt;&quot;-|&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;|-&quot;&lt;/code&gt; 来做一件非常有趣的事情：它派生一个与您打开的文件句柄连接的孩子。子进程与父进程运行相同的程序。例如，这对于在假定的UID或GID下运行时安全地打开文件很有用。如果您打开管道</target>
        </trans-unit>
        <trans-unit id="075cc903bac6f7e2aa6bd64ab5e44c58b488750c" translate="yes" xml:space="preserve">
          <source>Another interesting signal to send is signal number zero. This doesn't actually affect a child process, but instead checks whether it's alive or has changed its UIDs.</source>
          <target state="translated">另一个有趣的信号是零号信号。这实际上并不影响子进程,而是检查子进程是否还活着或者是否改变了UID。</target>
        </trans-unit>
        <trans-unit id="5625c9da79ea74fa11d7487b4856a60b8a448f5c" translate="yes" xml:space="preserve">
          <source>Another interface for querying locale-dependent information is the &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; function, available at least in Unix-like systems and VMS.</source>
          <target state="translated">用于查询与语言环境相关的信息的另一个接口是 &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; 函数，至少在类似Unix的系统和VMS中可用。</target>
        </trans-unit>
        <trans-unit id="7cdba3e1788bc415b19d9a9a11cdf704cabf535e" translate="yes" xml:space="preserve">
          <source>Another kind of client-server setup is one that uses not connections, but messages. UDP communications involve much lower overhead but also provide less reliability, as there are no promises that messages will arrive at all, let alone in order and unmangled. Still, UDP offers some advantages over TCP, including being able to &quot;broadcast&quot; or &quot;multicast&quot; to a whole bunch of destination hosts at once (usually on your local subnet). If you find yourself overly concerned about reliability and start building checks into your message system, then you probably should use just TCP to start with.</source>
          <target state="translated">另一种客户端-服务器的设置是不使用连接,而是使用消息。UDP通信涉及到的开销要低得多,但也提供了较低的可靠性,因为没有承诺消息会完全到达,更不用说按顺序和不纠缠了。不过,UDP还是比TCP有一些优势,包括可以一次向一大堆目标主机(通常是在你的本地子网)&quot;广播 &quot;或 &quot;多播&quot;。如果你发现自己过分关注可靠性,并开始在你的消息系统中建立检查,那么你可能应该一开始就只使用TCP。</target>
        </trans-unit>
        <trans-unit id="15bc936b8bd7810df3b41eba0889fe66dfa9061e" translate="yes" xml:space="preserve">
          <source>Another memory limiting item to check is your MAXASSIZE parameter in your 'SYS1.PARMLIB(BPXPRMxx)' data set (note too that as of V2R8 address space limits can be set on a per user ID basis in the USS segment of a RACF profile). People have reported successful builds of Perl with MAXASSIZE parameters as small as 503316480 (and it may be possible to build Perl with a MAXASSIZE smaller than that).</source>
          <target state="translated">另一个需要检查的内存限制项目是'SYS1.PARMLIB(BPXPRMxx)'数据集中的MAXASSIZE参数(也请注意,从V2R8开始,地址空间限制可以在RACF配置文件的USS段中根据每个用户ID来设置)。有人报告说,Perl的MAXASSIZE参数小到503316480,就可以成功地构建Perl(也可以用比MAXASSIZE更小的MAXASSIZE构建Perl)。</target>
        </trans-unit>
        <trans-unit id="ce05ce9dfc0d776de0b8b42183a9011dbca61f46" translate="yes" xml:space="preserve">
          <source>Another mnemonic for this modifier is &quot;Depends&quot;, as the rules actually used depend on various things, and as a result you can get unexpected results. See &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug in perlunicode&lt;/a&gt;. The Unicode Bug has become rather infamous, leading to yet another (printable) name for this modifier, &quot;Dodgy&quot;.</source>
          <target state="translated">此修饰符的另一个助记符是&amp;ldquo; Depends&amp;rdquo;，因为实际使用的规则取决于各种因素，因此您可能会得到意外的结果。请参见&lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicode中的Unicode错误&lt;/a&gt;。 Unicode错误已经声名狼藉，导致该修饰符&amp;ldquo; Dodgy&amp;rdquo;的另一个（可打印的）名称。</target>
        </trans-unit>
        <trans-unit id="3cfb16782780267975128af9b462f0c7f8f09971" translate="yes" xml:space="preserve">
          <source>Another odd-man-out in the template alphabet is &lt;code&gt;u&lt;/code&gt; , which packs a &quot;uuencoded string&quot;. (&quot;uu&quot; is short for Unix-to-Unix.) Chances are that you won't ever need this encoding technique which was invented to overcome the shortcomings of old-fashioned transmission mediums that do not support other than simple ASCII data. The essential recipe is simple: Take three bytes, or 24 bits. Split them into 4 six-packs, adding a space (0x20) to each. Repeat until all of the data is blended. Fold groups of 4 bytes into lines no longer than 60 and garnish them in front with the original byte count (incremented by 0x20) and a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at the end. - The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; chef will prepare this for you, a la minute, when you select pack code &lt;code&gt;u&lt;/code&gt; on the menu:</source>
          <target state="translated">模板字母中的另一个奇数符号是 &lt;code&gt;u&lt;/code&gt; ，其中包含&amp;ldquo; uuencoded字符串&amp;rdquo;。 （&amp;ldquo; uu&amp;rdquo;是Unix到Unix的缩写。）您可能永远不需要这种编码技术，该编码技术是为了克服不支持简单ASCII数据之外的老式传输介质的缺点而发明的。基本配方很简单：占用三个字节或24位。将它们分成4个六包装，每个包装加一个（0x20）空间。重复直到所有数据混合在一起。将4个字节的组折叠成不超过60行，并在其前面加上原始字节数（增加0x20），并在末尾加 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 。 - 当您在菜单上选择包装代码 &lt;code&gt;u&lt;/code&gt; 时， &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 厨师将为您准备点菜：</target>
        </trans-unit>
        <trans-unit id="f3b90d55edc9bd711b381039fe4df0f81ca8e910" translate="yes" xml:space="preserve">
          <source>Another operator with surprising precedence is exponentiation. It binds more tightly even than unary minus, making &lt;code&gt;-2**2&lt;/code&gt; produce a negative four and not a positive one. It is also right-associating, meaning that &lt;code&gt;2**3**2&lt;/code&gt; is two raised to the ninth power, not eight squared.</source>
          <target state="translated">另一个具有令人惊讶的优先级的运算符是幂运算。它甚至比一元负号更紧密地结合，从而使 &lt;code&gt;-2**2&lt;/code&gt; 产生负4而不是正1。它也是右关联的，这意味着 &lt;code&gt;2**3**2&lt;/code&gt; 是2升到9的幂，而不是8的平方。</target>
        </trans-unit>
        <trans-unit id="0a8ead7308fc061719df6bc244f6348d6cfaf232" translate="yes" xml:space="preserve">
          <source>Another optimisation that can occur is that of &quot;&lt;code&gt;EXACT&lt;/code&gt; merging&quot; which is where two consecutive &lt;code&gt;EXACT&lt;/code&gt; nodes are merged into a single regop. An even more aggressive form of this is that a branch sequence of the form &lt;code&gt;EXACT BRANCH ... EXACT&lt;/code&gt; can be converted into a &lt;code&gt;TRIE-EXACT&lt;/code&gt; regop.</source>
          <target state="translated">可能发生的另一种优化是&amp;ldquo; &lt;code&gt;EXACT&lt;/code&gt; 合并&amp;rdquo;的优化，其中两个连续的 &lt;code&gt;EXACT&lt;/code&gt; 节点被合并到一个单独的regop中。甚至更积极的形式是，可以将 &lt;code&gt;EXACT BRANCH ... EXACT&lt;/code&gt; 形式的分支序列转换为 &lt;code&gt;TRIE-EXACT&lt;/code&gt; regop。</target>
        </trans-unit>
        <trans-unit id="6aabd99f333ab712e259e5fbe14c5365c3fb3eb5" translate="yes" xml:space="preserve">
          <source>Another option is to use the &lt;code&gt;iter&lt;/code&gt; class method to iterate over the files in the tarball without reading them all in memory at once.</source>
          <target state="translated">另一种选择是使用 &lt;code&gt;iter&lt;/code&gt; 类方法来遍历tarball中的文件，而无需一次读取它们在内存中的所有内容。</target>
        </trans-unit>
        <trans-unit id="82d37f84faabd12d777cc2ff160de45bc66b098d" translate="yes" xml:space="preserve">
          <source>Another option is to use the make written in Perl, available from CPAN.</source>
          <target state="translated">另一个选择是使用Perl编写的make,可从CPAN获得。</target>
        </trans-unit>
        <trans-unit id="655a86d88b6839dd2179128ff91b78ce22ba6c96" translate="yes" xml:space="preserve">
          <source>Another peculiarity of urllist is that the site that we could successfully fetch the last file from automatically gets a preference token and is tried as the first site for the next request. So if you add a new site at runtime it may happen that the previously preferred site will be tried another time. This means that if you want to disallow a site for the next transfer, it must be explicitly removed from urllist.</source>
          <target state="translated">urllist 的另一个特点是,我们可以成功地从最后一个文件中获取的站点会自动获得一个偏好标记,并作为下一次请求的第一个站点进行尝试。因此,如果你在运行时添加了一个新的站点,可能会发生之前的首选站点会在下一次被尝试的情况。这意味着,如果你想在下一次传输中不允许使用某个站点,必须明确地从urllist中删除它。</target>
        </trans-unit>
        <trans-unit id="ce6cb12c61e008cd3f2b006405f6306cfa9808f3" translate="yes" xml:space="preserve">
          <source>Another point worth noting is that in the first series of examples I have made use of only the</source>
          <target state="translated">还有一点值得注意的是,在第一个系列的例子中,我只使用了 &quot;我的&quot;。</target>
        </trans-unit>
        <trans-unit id="4398365ad3174110f099b9553fe6a9ab1f982409" translate="yes" xml:space="preserve">
          <source>Another popular use for &lt;code&gt;recompile&lt;/code&gt; is to act as a rescue in case your perl breaks binary compatibility. If one of the modules that CPAN uses is in turn depending on binary compatibility (so you cannot run CPAN commands), then you should try the CPAN::Nox module for recovery.</source>
          <target state="translated">&lt;code&gt;recompile&lt;/code&gt; 另一个流行用途是在您的perl破坏二进制兼容性时充当抢救工具。如果CPAN使用的模块之一又取决于二进制兼容性（因此您不能运行CPAN命令），则应尝试使用CPAN :: Nox模块进行恢复。</target>
        </trans-unit>
        <trans-unit id="9d8cd00450b93b9762fe1f4860bcee6a18ea20de" translate="yes" xml:space="preserve">
          <source>Another possibility is that you forgot a backslash. Perl isn't smart enough to figure out what you really meant.</source>
          <target state="translated">另一种可能是你忘记了一个反斜杠。Perl不够聪明,无法理解你真正的意思。</target>
        </trans-unit>
        <trans-unit id="385e095c764654e0fb183ec8deedb8c0e3232a76" translate="yes" xml:space="preserve">
          <source>Another possible reason for problems is that you've used the indirect object syntax (eg, &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt; ) on a class name before Perl has seen that such a package exists. It's wisest to make sure your packages are all defined before you start using them, which will be taken care of if you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement instead of &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;. If not, make sure to use arrow notation (eg., &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt; ) instead. Object notation is explained in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">出现问题的另一个可能原因是，在Perl看到这样的包存在之前，您已经在类名上使用了间接对象语法（例如， &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt; ）。最明智的做法是在开始使用它们之前确保所有软件包都已定义，如果您使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句而不是 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ，将会很注意。如果不是，请确保使用箭头符号（例如 &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt; ）。对象表示法在&lt;a href=&quot;perlobj&quot;&gt;perlobj中进行了&lt;/a&gt;说明。</target>
        </trans-unit>
        <trans-unit id="c972997167e011df9a56046ecd4a5023cc5037ca" translate="yes" xml:space="preserve">
          <source>Another problem that occurs with inside-out classes is serialization. Since the object data is not in its usual place, standard routines like &lt;code&gt;Storable::freeze()&lt;/code&gt; , &lt;code&gt;Storable::thaw()&lt;/code&gt; and &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; can't deal with it on their own. Both &lt;code&gt;Data::Dumper&lt;/code&gt; and &lt;code&gt;Storable&lt;/code&gt; provide the necessary hooks to make things work, but the functions or methods used by the hooks must be provided by each inside-out class.</source>
          <target state="translated">由内而外的类发生的另一个问题是序列化。由于对象数据不在通常的位置，因此诸如 &lt;code&gt;Storable::freeze()&lt;/code&gt; ， &lt;code&gt;Storable::thaw()&lt;/code&gt; 和 &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; 类的标准例程无法自行处理。这两个 &lt;code&gt;Data::Dumper&lt;/code&gt; 和 &lt;code&gt;Storable&lt;/code&gt; 提供必要的钩子把事情的工作，而是由钩使用的函数或方法必须由每个内而外的类来提供。</target>
        </trans-unit>
        <trans-unit id="4838334963e3cee1c557a4f6afcd664375d054be" translate="yes" xml:space="preserve">
          <source>Another problem with this approach is that operations that cross the single byte/multiple byte boundary are not well-defined, and so are disallowed. (This boundary is between the codepoints at 255/256.) For example, lower casing LATIN CAPITAL LETTER Y WITH DIAERESIS (U+0178) should return LATIN SMALL LETTER Y WITH DIAERESIS (U+00FF). But in the Greek locale, for example, there is no character at 0xFF, and Perl has no way of knowing what the character at 0xFF is really supposed to represent. Thus it disallows the operation. In this mode, the lowercase of U+0178 is itself.</source>
          <target state="translated">这种方法的另一个问题是,越过单字节/多字节边界的操作没有很好的定义,所以是不允许的。(这个边界是在255/256的代码点之间。)例如,小写字母LATIN CAPITAL LETTER Y WITH DIAERESIS (U+0178)应该返回LATIN SMALL LETTER Y WITH DIAERESIS (U+00FF)。但是在希腊语中,比如说,0xFF处没有字符,Perl也无法知道0xFF处的字符到底应该代表什么。因此,它不允许该操作。在这种模式下,U+0178的小写就是自己。</target>
        </trans-unit>
        <trans-unit id="1d25e58d1b57cecb55c387a5dd5c52709e7a7cf9" translate="yes" xml:space="preserve">
          <source>Another reason that folks sometimes think they want a variable to contain the name of a variable is that they don't know how to build proper data structures using hashes. For example, let's say they wanted two hashes in their program: %fred and %barney, and that they wanted to use another scalar variable to refer to those by name.</source>
          <target state="translated">大家有时会认为他们希望一个变量包含一个变量的名称,另一个原因是他们不知道如何使用哈希值建立正确的数据结构。例如,假设他们想在程序中使用两个哈希值。%fred和%barney 他们想用另一个标量变量来指代这两个变量的名字。</target>
        </trans-unit>
        <trans-unit id="0421a2fa7b166fbdb782231a9f8dbd1fd87115e8" translate="yes" xml:space="preserve">
          <source>Another reason to use &lt;code&gt;HASH&lt;/code&gt; is to provide your own hash variable. You can then inspect or modify the contents of the hash to gain finer control over the cache management.</source>
          <target state="translated">使用 &lt;code&gt;HASH&lt;/code&gt; 的另一个原因是提供您自己的哈希变量。然后，您可以检查或修改哈希的内容，以更好地控制缓存管理。</target>
        </trans-unit>
        <trans-unit id="8b8bed8e10e25cfa736414741ddf1e9e2d2b9072" translate="yes" xml:space="preserve">
          <source>Another sample module, &lt;a href=&quot;http://search.cpan.org/perldoc/Memoize::Saves&quot;&gt;Memoize::Saves&lt;/a&gt;, is available in a separate distribution on CPAN. It implements a policy that allows you to specify that certain function values would always be looked up afresh. See the documentation for details.</source>
          <target state="translated">另一个示例模块&lt;a href=&quot;http://search.cpan.org/perldoc/Memoize::Saves&quot;&gt;Memoize :: Saves&lt;/a&gt;在CPAN上的单独发行版中可用。它实现了一个策略，允许您指定始终要重新查找某些函数值。有关详细信息，请参见文档。</target>
        </trans-unit>
        <trans-unit id="f67a475c6b156df5eac51c84854028a80181079b" translate="yes" xml:space="preserve">
          <source>Another thing to try is learning whether your Perl was compiled with the system malloc or with Perl's builtin malloc. Whichever one it is, try using the other one and see whether this makes a difference. Information about malloc is in the</source>
          <target state="translated">另一个可以尝试的方法是了解你的Perl是用系统的malloc还是用Perl内置的malloc编译的。不管是哪一种,都可以尝试使用另一种,看看是否会有不同。关于 malloc 的信息可以在</target>
        </trans-unit>
        <trans-unit id="a1cb48749447600d090febf98d3e4d0e00ee484e" translate="yes" xml:space="preserve">
          <source>Another thing you should bear in mind is that the UNINST parameter can be dangerous when you are installing into a private area because you might accidentally remove modules that other people depend on that are not using the private area.</source>
          <target state="translated">另外需要注意的是,当你在私人区域安装时,UNINST参数可能会很危险,因为你可能会不小心删除其他人依赖的、没有使用私人区域的模块。</target>
        </trans-unit>
        <trans-unit id="fc7600b26c92e308f5a7b9737781947f5e033b05" translate="yes" xml:space="preserve">
          <source>Another thorough remedy to that runtime vs. compile-time trap is to use &lt;a href=&quot;http://search.cpan.org/perldoc/Exporter::Easy&quot;&gt;Exporter::Easy&lt;/a&gt;, which is a wrapper of Exporter that allows all boilerplate code at a single gulp in the use statement.</source>
          <target state="translated">对于运行时与编译时陷阱的另一种彻底的补救方法是使用&lt;a href=&quot;http://search.cpan.org/perldoc/Exporter::Easy&quot;&gt;Exporter :: Easy&lt;/a&gt;，它是Exporter的包装，允许在use语句中的单个gulp中使用所有样板代码。</target>
        </trans-unit>
        <trans-unit id="8f128db16727c4206b263e3f2e5e2f91028aada1" translate="yes" xml:space="preserve">
          <source>Another typical use of redispatch would be in &lt;code&gt;AUTOLOAD&lt;/code&gt; 'ed methods. If such a method determined that it was not able to handle a particular call, it might choose to redispatch that call, in the hope that some other &lt;code&gt;AUTOLOAD&lt;/code&gt; (above it, or to its left) might do better.</source>
          <target state="translated">重新分配的另一种典型用法是在 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法中。如果这样的方法确定它无法处理特定的调用，则它可能会选择重新分派该调用，以希望其他一些 &lt;code&gt;AUTOLOAD&lt;/code&gt; （在其上方或左侧）可以做得更好。</target>
        </trans-unit>
        <trans-unit id="28f35e8d306941d11adce5505a92ca2044351acf" translate="yes" xml:space="preserve">
          <source>Another unofficial source of data. Currently, it is not used to get data, but the notes and explanatory material were very useful for understanding discrepancies between the sources.</source>
          <target state="translated">另一个非官方数据来源。目前,它没有被用来获取数据,但注释和解释材料对于理解来源之间的差异非常有用。</target>
        </trans-unit>
        <trans-unit id="a159ba74ceaa166e4b6d8831134290b3cd8265be" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;MERGE&lt;/code&gt; is when you want both kinds of return values stored in the same disk file; this saves you from having to deal with two disk files instead of one. You can use a normalizer function to keep the two sets of return values separate. For example:</source>
          <target state="translated">&lt;code&gt;MERGE&lt;/code&gt; 的另一种用途是当您希望两种返回值都存储在同一磁盘文件中时；这使您不必处理两个磁盘文件，而不必处理一个。您可以使用规范化函数将两组返回值保持分开。例如：</target>
        </trans-unit>
        <trans-unit id="3dd7e16e7ef3fb6df50c7af26f6bc9d68c338053" translate="yes" xml:space="preserve">
          <source>Another use for a closure is to make a variable</source>
          <target state="translated">闭包的另一个用途是将一个可变的</target>
        </trans-unit>
        <trans-unit id="a46f51ca5d9afdb7291b96d0559a5eecba4e7c63" translate="yes" xml:space="preserve">
          <source>Another use for normalizers is when the function depends on data other than those in its arguments. Suppose you have a function which returns a value which depends on the current hour of the day:</source>
          <target state="translated">正常化器的另一个用途是当函数依赖于其参数以外的数据时。假设你有一个函数,它的返回值取决于一天中的当前小时。</target>
        </trans-unit>
        <trans-unit id="62444c7bc781846313fe8302369f08d7688eae95" translate="yes" xml:space="preserve">
          <source>Another use for the INIT: section is to check for preconditions before making a call to the C function:</source>
          <target state="translated">INIT:部分的另一个用途是在调用C函数之前检查前提条件。</target>
        </trans-unit>
        <trans-unit id="3a9f1ae19985a41ad9db3a10b2882d84afcc8d3c" translate="yes" xml:space="preserve">
          <source>Another use for typeglobs is to pass filehandles into a function or to create new filehandles. If you need to use a typeglob to save away a filehandle, do it this way:</source>
          <target state="translated">typeglobs 的另一个用途是将文件柄传递到一个函数中或创建新的文件柄。如果你需要使用 typeglob 来保存一个文件柄,可以这样做。</target>
        </trans-unit>
        <trans-unit id="385eea7f2546356b9012fe969f08ace72fffebdd" translate="yes" xml:space="preserve">
          <source>Another use of symbol tables is for making &quot;constant&quot; scalars.</source>
          <target state="translated">符号表的另一个用途是用于制作 &quot;常数 &quot;标量。</target>
        </trans-unit>
        <trans-unit id="7e444bc856c81853904c1c90381dc826b2163cfa" translate="yes" xml:space="preserve">
          <source>Another use of the generic object would be as a template. It is a convenient place to store class-specific defaults for various fields to be used in actual object initialization.</source>
          <target state="translated">通用对象的另一个用途是作为模板。它是一个方便的地方,可以存储各种字段的类特定默认值,以便在实际对象初始化中使用。</target>
        </trans-unit>
        <trans-unit id="03d707d0fcf79e0d7b50ca27287f1758fef3a3d9" translate="yes" xml:space="preserve">
          <source>Another useful shortcut is that, if you use a literal array or hash as the argument to &lt;code&gt;given&lt;/code&gt; , it is turned into a reference. So &lt;code&gt;given(@foo)&lt;/code&gt; is the same as &lt;code&gt;given(\@foo)&lt;/code&gt; , for example.</source>
          <target state="translated">另一种有用的快捷方式是，如果使用一个文字数组或哈希作为参数 &lt;code&gt;given&lt;/code&gt; ，它变成一个参考。因此，例如， &lt;code&gt;given(@foo)&lt;/code&gt; 与Given &lt;code&gt;given(\@foo)&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="4a05112cda91b50dc34bb4913074b7fa53fabce3" translate="yes" xml:space="preserve">
          <source>Another variation on a theme. This time we will modify the &lt;code&gt;Subst&lt;/code&gt; filter to allow a starting and stopping pattern to be specified as well as the</source>
          <target state="translated">主题的另一种变化。这次我们将修改 &lt;code&gt;Subst&lt;/code&gt; 过滤器，以允许指定开始和停止模式以及</target>
        </trans-unit>
        <trans-unit id="95d0ad8589b46d03f061e120707df66c84d9cbde" translate="yes" xml:space="preserve">
          <source>Another version uses a global match in list context, then assigns the result to a scalar, producing a count of the number of matches.</source>
          <target state="translated">另一个版本在列表上下文中使用全局匹配,然后将结果分配给一个标量,产生一个匹配数的计数。</target>
        </trans-unit>
        <trans-unit id="a0589db0a4f4f29bef401c1107ff7696f0cffdbb" translate="yes" xml:space="preserve">
          <source>Another way is to assign to a substr() that's off the end of the string.</source>
          <target state="translated">另一种方法是赋值给字符串末尾的substr()。</target>
        </trans-unit>
        <trans-unit id="3c83abcaae94dfa04aa0d7e9c83f8b2a9880cd1b" translate="yes" xml:space="preserve">
          <source>Another way is to use the &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; module, which treats the entire file as an array. Simply access a random array element.</source>
          <target state="translated">另一种方法是使用&lt;a href=&quot;tie/file&quot;&gt;Tie :: File&lt;/a&gt;模块，该模块将整个文件视为一个数组。只需访问随机数组元素。</target>
        </trans-unit>
        <trans-unit id="360771e8bfe1eade19d5dbc8ea8baae5f8a955ef" translate="yes" xml:space="preserve">
          <source>Another way is to use undef as an element on the left-hand-side:</source>
          <target state="translated">另一种方法是在左侧使用undef作为元素。</target>
        </trans-unit>
        <trans-unit id="f81299a8407385b954919f2cec05019d576de6e8" translate="yes" xml:space="preserve">
          <source>Another way to create anonymous filehandles is with the Symbol module or with the IO::Handle module and its ilk. These modules have the advantage of not hiding different types of the same name during the local(). See the bottom of &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for an example.</source>
          <target state="translated">创建匿名文件句柄的另一种方法是使用Symbol模块或IO :: Handle模块及其类似项。这些模块的优点是不会在local（）期间隐藏相同名称的不同类型。有关示例，请参见&lt;a href=&quot;functions/open&quot;&gt;打开&lt;/a&gt;底部。</target>
        </trans-unit>
        <trans-unit id="e614c6db5b38b002f45562db1a27e62289c42947" translate="yes" xml:space="preserve">
          <source>Another way to debug compile-time code is to start the debugger, set a breakpoint on the</source>
          <target state="translated">调试编译时代码的另一种方法是启动调试器,将断点设置在</target>
        </trans-unit>
        <trans-unit id="9901f72c76524abdcc53f059c75aff5db9ab2a29" translate="yes" xml:space="preserve">
          <source>Another way to declare &lt;code&gt;host&lt;/code&gt; is to use a C block in the CODE: section:</source>
          <target state="translated">声明 &lt;code&gt;host&lt;/code&gt; 另一种方法是在CODE：部分中使用C块：</target>
        </trans-unit>
        <trans-unit id="205baf27defe296be93a335acebfa113cc8193c2" translate="yes" xml:space="preserve">
          <source>Another way to disable the safe signal behavior locally is to use the &lt;code&gt;Perl::Unsafe::Signals&lt;/code&gt; module from CPAN, which affects all signals.</source>
          <target state="translated">在本地禁用安全信号行为的另一种方法是使用CPAN 的 &lt;code&gt;Perl::Unsafe::Signals&lt;/code&gt; 模块，该模块会影响所有信号。</target>
        </trans-unit>
        <trans-unit id="68459b39b80a3326501665280a8d6df2de3c0dc3" translate="yes" xml:space="preserve">
          <source>Another way to examine the tree is to use a compiler back-end module, such as &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="translated">检查树的另一种方法是使用编译器后端模块，例如&lt;a href=&quot;b/concise&quot;&gt;B :: Concise&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1475dee12421b2759f280ec12406b6a9a8686bb7" translate="yes" xml:space="preserve">
          <source>Another way to lay hands on a reference to the underlying object is to use the tied() function, so they might alternately have set clobber using:</source>
          <target state="translated">另一种对底层对象的引用下手的方式是使用tied()函数,所以他们可能会交替使用设置clobber。</target>
        </trans-unit>
        <trans-unit id="00149c3d1137c9330feb23e2fe36062f95ccc0ba" translate="yes" xml:space="preserve">
          <source>Another way to look at it is via bits:</source>
          <target state="translated">另一种方式是通过比特来看。</target>
        </trans-unit>
        <trans-unit id="87cb792899401773acea6f65b31b31644b7caaf0" translate="yes" xml:space="preserve">
          <source>Another way to modify &lt;code&gt;@INC&lt;/code&gt; without modifying the program, is to use the &lt;code&gt;lib&lt;/code&gt; pragma, e.g.:</source>
          <target state="translated">无需修改程序即可修改 &lt;code&gt;@INC&lt;/code&gt; 的另一种方法是使用 &lt;code&gt;lib&lt;/code&gt; pragma，例如：</target>
        </trans-unit>
        <trans-unit id="53f5ac93c7a0f074f16d88622079abd1a07b9541" translate="yes" xml:space="preserve">
          <source>Another way to see the output of a PM program is to run it as</source>
          <target state="translated">另一种查看PM程序输出的方法是将其运行为</target>
        </trans-unit>
        <trans-unit id="60d4191bfc5b5a27fe1df7d104bb0fb301db392c" translate="yes" xml:space="preserve">
          <source>Another way to skip over characters in a UTF-8 string is to use &lt;code&gt;utf8_hop&lt;/code&gt; , which takes a string and a number of characters to skip over. You're on your own about bounds checking, though, so don't use it lightly.</source>
          <target state="translated">跳过UTF-8字符串中字符的另一种方法是使用 &lt;code&gt;utf8_hop&lt;/code&gt; ，它需要一个字符串和许多字符来跳过。但是，您只需要进行边界检查，因此请不要轻易使用它。</target>
        </trans-unit>
        <trans-unit id="ebbeb1bfc20bbb2eabb0051011fd1f94e30bfced" translate="yes" xml:space="preserve">
          <source>Another way to specify many INSTALL directories with a single parameter is LIB.</source>
          <target state="translated">另一种用一个参数指定许多INSTALL目录的方法是LIB。</target>
        </trans-unit>
        <trans-unit id="ab320674027c2ae8c6c6ac4c9c8202490be618cd" translate="yes" xml:space="preserve">
          <source>Another way to write &lt;code&gt;Is_latin_1()&lt;/code&gt; would be to use the characters in the range explicitly:</source>
          <target state="translated">编写 &lt;code&gt;Is_latin_1()&lt;/code&gt; 的另一种方法是显式使用范围内的字符：</target>
        </trans-unit>
        <trans-unit id="697b561300a9259946d1254bc1d65f626fe87539" translate="yes" xml:space="preserve">
          <source>Any $(FOO) used in the examples are make variables, not Perl.</source>
          <target state="translated">例子中使用的$(FOO)都是make变量,不是Perl。</target>
        </trans-unit>
        <trans-unit id="bea7ca75aae1ff5f6e730010d46af50a09d7d1c8" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;user-defined property&lt;/a&gt; used must be already defined by the time the regular expression is compiled (but note that this construct can be used instead of such properties).</source>
          <target state="translated">使用的任何&lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;用户定义属性&lt;/a&gt;必须在编译正则表达式时已经定义（但请注意，可以使用此构造代替此类属性）。</target>
        </trans-unit>
        <trans-unit id="31e755c53eda86352ddd4b11acb45031c2d27960" translate="yes" xml:space="preserve">
          <source>Any &lt;b&gt;class method&lt;/b&gt;, &lt;b&gt;instance&lt;/b&gt;, or &lt;b&gt;subroutine&lt;/b&gt; that composes, initializes, blesses, and returns an &lt;b&gt;object&lt;/b&gt;. Sometimes we use the term loosely to mean a &lt;b&gt;composer&lt;/b&gt;.</source>
          <target state="translated">组成，初始化，祝福并返回&lt;b&gt;object的&lt;/b&gt;任何&lt;b&gt;类方法&lt;/b&gt;，&lt;b&gt;实例&lt;/b&gt;或&lt;b&gt;子例程&lt;/b&gt;。有时我们用宽松的术语来指&lt;b&gt;作曲家&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ebc443723afa597f0f46ae7e71ea2b268b18eec2" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;\&lt;/code&gt; (backslashes) are converted to &lt;code&gt;/&lt;/code&gt; (forward slashes), and then File::Spec::Unix canonpath() is called on the result.</source>
          <target state="translated">任何 &lt;code&gt;\&lt;/code&gt; （反斜杠）都将转换为 &lt;code&gt;/&lt;/code&gt; （正斜杠），然后在结果上调用File :: Spec :: Unix canonpath（）。</target>
        </trans-unit>
        <trans-unit id="0297ad87a59e1b9acfbd34804e1d88eb60665363" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;make&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; is run unconditionally. An</source>
          <target state="translated">任何 &lt;code&gt;make&lt;/code&gt; 或 &lt;code&gt;test&lt;/code&gt; 都是无条件运行的。一个</target>
        </trans-unit>
        <trans-unit id="3cd3503f8d612240a0cdcfcf3958cd4b47fd1bc1" translate="yes" xml:space="preserve">
          <source>Any SV may be magical, that is, it has special features that a normal SV does not have. These features are stored in the SV structure in a linked list of &lt;code&gt;struct magic&lt;/code&gt; 's, typedef'ed to &lt;code&gt;MAGIC&lt;/code&gt; .</source>
          <target state="translated">任何SV可能都是神奇的，也就是说，它具有普通SV没有的特殊功能。这些功能存储在SV结构中的 &lt;code&gt;struct magic&lt;/code&gt; （已定义为 &lt;code&gt;MAGIC&lt;/code&gt; )的链接列表中。</target>
        </trans-unit>
        <trans-unit id="3990dd07c484552abc78d056ff16c2e2a8e23114" translate="yes" xml:space="preserve">
          <source>Any additional arguments are expected to be names of modules to generate code for.</source>
          <target state="translated">任何附加参数都应该是要生成代码的模块名称。</target>
        </trans-unit>
        <trans-unit id="33e9e1331c3f51ebe91a9bc05248aec433c1afce" translate="yes" xml:space="preserve">
          <source>Any additional arguments found before the &lt;b&gt;--&lt;/b&gt; token are expected to be names of modules to generate code for.</source>
          <target state="translated">在&lt;b&gt;-&lt;/b&gt;标记之前找到的所有其他参数都应该是为其生成代码的模块的名称。</target>
        </trans-unit>
        <trans-unit id="c6e53a3422c150f8910984634fe5fc4926bb37bc" translate="yes" xml:space="preserve">
          <source>Any additional flags you wish to pass to the linker.</source>
          <target state="translated">任何你想传递给链接器的附加标志。</target>
        </trans-unit>
        <trans-unit id="28fc9753c4799266fbd1d9873fa8ed5292bbf609" translate="yes" xml:space="preserve">
          <source>Any argument which looks like a signal name (that is, &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt; ) indicates that &lt;b&gt;sigtrap&lt;/b&gt; should install a handler for that name.</source>
          <target state="translated">任何看起来像信号名称的参数（即 &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt; ）都表明&lt;b&gt;sigtrap&lt;/b&gt;应该为该名称安装一个处理程序。</target>
        </trans-unit>
        <trans-unit id="669f46fd59266a6910f9368caa3825ce94a0d579" translate="yes" xml:space="preserve">
          <source>Any arguments after the second '--' token are additional linker arguments that will be examined for potential conflict. If there is no conflict, the additional arguments will be part of the output.</source>
          <target state="translated">第二个'--'标记后的任何参数都是附加的链接器参数,它们将被检查是否有潜在的冲突。如果没有冲突,附加参数将成为输出的一部分。</target>
        </trans-unit>
        <trans-unit id="b8ba7c975cc3879d276e04e3e9eb8ad2f669d5cb" translate="yes" xml:space="preserve">
          <source>Any arguments passed in show up in the array &lt;code&gt;@_&lt;/code&gt; . (They may also show up in lexical variables introduced by a signature; see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt; below.) Therefore, if you called a function with two arguments, those would be stored in &lt;code&gt;$_[0]&lt;/code&gt; and &lt;code&gt;$_[1]&lt;/code&gt; . The array &lt;code&gt;@_&lt;/code&gt; is a local array, but its elements are aliases for the actual scalar parameters. In particular, if an element &lt;code&gt;$_[0]&lt;/code&gt; is updated, the corresponding argument is updated (or an error occurs if it is not updatable). If an argument is an array or hash element which did not exist when the function was called, that element is created only when (and if) it is modified or a reference to it is taken. (Some earlier versions of Perl created the element whether or not the element was assigned to.) Assigning to the whole array &lt;code&gt;@_&lt;/code&gt; removes that aliasing, and does not update any arguments.</source>
          <target state="translated">传入的所有参数都显示在数组 &lt;code&gt;@_&lt;/code&gt; 中。（它们也可能显示在签名引入的词法变量中；请参阅下面的&lt;a href=&quot;#Signatures&quot;&gt;签名&lt;/a&gt;。）因此，如果您调用带有两个参数的函数，则这些参数将存储在 &lt;code&gt;$_[0]&lt;/code&gt; 和 &lt;code&gt;$_[1]&lt;/code&gt; 中。数组 &lt;code&gt;@_&lt;/code&gt; 是本地数组，但是其元素是实际标量参数的别名。特别是如果元素 &lt;code&gt;$_[0]&lt;/code&gt; 更新，相应的参数也将更新（如果不可更新，则会发生错误）。如果参数是在调用函数时不存在的数组或哈希元素，则仅在（如果有）对其进行修改或对其进行引用时才创建该元素。 （一些早期版本的Perl不管是否分配了元素都创建了该元素。）分配给整个数组 &lt;code&gt;@_&lt;/code&gt; 会删除该别名，并且不会更新任何参数。</target>
        </trans-unit>
        <trans-unit id="ff6247c19341895e60632e62b6ff63ef2ca7a1ee" translate="yes" xml:space="preserve">
          <source>Any attempt by the code in STRING to use an operator which is not permitted by the compartment will cause an error (at run-time of the main program but at compile-time for the code in STRING). The error is of the form &quot;'%s' trapped by operation mask...&quot;.</source>
          <target state="translated">STRING中的代码如果试图使用一个不被隔层允许的操作符,就会引起一个错误(在主程序运行时,但STRING中的代码在编译时)。错误的形式是&quot;'%s'被操作掩码所困...&quot;。</target>
        </trans-unit>
        <trans-unit id="813cebd9a54eacff09b02a5f15b34a12df0ec8d1" translate="yes" xml:space="preserve">
          <source>Any backslashed prototype character represents an actual argument that must start with that character (optionally preceded by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;), with the exception of &lt;code&gt;$&lt;/code&gt; , which will accept any scalar lvalue expression, such as &lt;code&gt;$foo = 7&lt;/code&gt; or &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt; . The value passed as part of &lt;code&gt;@_&lt;/code&gt; will be a reference to the actual argument given in the subroutine call, obtained by applying &lt;code&gt;\&lt;/code&gt; to that argument.</source>
          <target state="translated">任何反斜杠原型字符都代表一个实际参数，该参数必须以该字符开头（可选地以 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 开头）， &lt;code&gt;$&lt;/code&gt; 除外，它将接受任何标量左值表达式，例如 &lt;code&gt;$foo = 7&lt;/code&gt; 或 &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt; 。作为 &lt;code&gt;@_&lt;/code&gt; 的一部分传递的值将是对子例程调用中给定的实际参数的引用，该子参数是通过将 &lt;code&gt;\&lt;/code&gt; 应用于该参数而获得的。</target>
        </trans-unit>
        <trans-unit id="e8738a2a75fb40cb2ee10b2d9e2137a995a5cab3" translate="yes" xml:space="preserve">
          <source>Any call from a package to itself is safe.</source>
          <target state="translated">任何包对自己的调用都是安全的。</target>
        </trans-unit>
        <trans-unit id="4b72ee9b0cb5399c6a83f5d4a70d821be8027231" translate="yes" xml:space="preserve">
          <source>Any call from an internal Perl module is safe. (Nothing keeps user modules from marking themselves as internal to Perl, but this practice is discouraged.)</source>
          <target state="translated">任何来自 Perl 内部模块的调用都是安全的。(没有什么能阻止用户模块将自己标记为Perl的内部模块,但这种做法是不鼓励的。)</target>
        </trans-unit>
        <trans-unit id="32561ad60b0d62ef81eb27f4c0654f92745f16b5" translate="yes" xml:space="preserve">
          <source>Any call to Perl's warning system (eg Carp itself) is safe. (This rule is what keeps it from reporting the error at the point where you call &lt;code&gt;carp&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt; .)</source>
          <target state="translated">调用Perl的警告系统（例如Carp本身）都是安全的。（此规则使它无法在您称为 &lt;code&gt;carp&lt;/code&gt; 或 &lt;code&gt;croak&lt;/code&gt; 的位置报告错误。）</target>
        </trans-unit>
        <trans-unit id="6be54b4dca13888b86e758e818195dea970243c9" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\d&lt;/code&gt; is matched by &lt;code&gt;\D&lt;/code&gt; .</source>
          <target state="translated">与 &lt;code&gt;\d&lt;/code&gt; 不匹配的任何字符都由 &lt;code&gt;\D&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="072286fccc69e711078f97acb3c710b733c38c10" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\s&lt;/code&gt; is matched by &lt;code&gt;\S&lt;/code&gt; .</source>
          <target state="translated">与 &lt;code&gt;\s&lt;/code&gt; 不匹配的任何字符都由 &lt;code&gt;\S&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="edd14be74c570e6d8f1d353ef998bd9cdb853857" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\w&lt;/code&gt; is matched by &lt;code&gt;\W&lt;/code&gt; .</source>
          <target state="translated">任何字符不匹配 &lt;code&gt;\w&lt;/code&gt; 由匹配 &lt;code&gt;\W&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e45bb18b3ba9ff92c60226f6eef9c2b785d393ac" translate="yes" xml:space="preserve">
          <source>Any character not part of the 65-character base64 subset is silently ignored. Characters occurring after a '=' padding character are never decoded.</source>
          <target state="translated">任何不属于65个字符的base64子集的字符都会被忽略。'='填充字符之后的字符永远不会被解码。</target>
        </trans-unit>
        <trans-unit id="fdc4fb7a943f332e78ce7564ebae9fbe7a142c7e" translate="yes" xml:space="preserve">
          <source>Any character that is</source>
          <target state="translated">任何角色,都是</target>
        </trans-unit>
        <trans-unit id="d1ae992eb64cfaf05e3391f63560921ed6515ef6" translate="yes" xml:space="preserve">
          <source>Any character with the General Category of Combining Mark (&lt;code&gt;\p{GC=M}&lt;/code&gt; ), which may be spacing or nonspacing. Some are even invisible. A sequence of combining characters following a grapheme base character together make up a single user-visible character called a &lt;b&gt;grapheme&lt;/b&gt;. Most but not all diacritics are combining characters, and vice versa.</source>
          <target state="translated">具有组合标记常规类别（ &lt;code&gt;\p{GC=M}&lt;/code&gt; ）的任何字符，可以是空格或非空格。有些甚至是看不见的。组合字符的跟随字形基字符的序列一起组成称为单用户可见的字符&lt;b&gt;字形&lt;/b&gt;。大多数但并非全部变音符号都结合了字符，反之亦然。</target>
        </trans-unit>
        <trans-unit id="f47500f097947cd7ef6b655a33fe0adeaed93c8c" translate="yes" xml:space="preserve">
          <source>Any class derived from an overloaded class is also overloaded and inherits its operator implementations. If the same operator is overloaded in more than one ancestor then the implementation is determined by the usual inheritance rules.</source>
          <target state="translated">任何从重载类派生出来的类也是重载的,并继承其操作符实现。如果同一个操作符在一个以上的祖先中被重载,那么其实现是由通常的继承规则决定的。</target>
        </trans-unit>
        <trans-unit id="82762c13b8c241690349f9ba71914d3aafcada68" translate="yes" xml:space="preserve">
          <source>Any class for which this function returns true is &quot;universal&quot; in the sense that all classes potentially inherit methods from it.</source>
          <target state="translated">任何这个函数返回true的类都是 &quot;通用 &quot;的,即所有的类都有可能继承它的方法。</target>
        </trans-unit>
        <trans-unit id="4c366c83fbe5661336d1ed5dad628d12372f6675" translate="yes" xml:space="preserve">
          <source>Any class may define hooks that will be called during the serialization and deserialization process on objects that are instances of that class. Those hooks can redefine the way serialization is performed (and therefore, how the symmetrical deserialization should be conducted).</source>
          <target state="translated">任何类都可以定义钩子,这些钩子将在序列化和反序列化过程中对作为该类实例的对象进行调用。这些钩子可以重新定义序列化的执行方式(因此,对称的反序列化应该如何进行)。</target>
        </trans-unit>
        <trans-unit id="6e6281f412687ca7280049212c9dd37d5f605837" translate="yes" xml:space="preserve">
          <source>Any command not recognized by the debugger is directly executed (&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;'d) as Perl code in the current package. (The debugger uses the DB package for keeping its own state information.)</source>
          <target state="translated">调试器无法识别的任何命令都将作为当前包中的Perl代码直接执行（ &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 'd）。（调试器使用数据库包来保留其自身的状态信息。）</target>
        </trans-unit>
        <trans-unit id="a8dc7e3add242376e935c5e7dec68c1bf0f28dae" translate="yes" xml:space="preserve">
          <source>Any committer may cherry-pick any commit from blead to a maint branch if they send mail to perl5-porters announcing their intent to cherry-pick a specific commit along with a rationale for doing so and at least two other committers respond to the list giving their assent. (This policy applies to current and former pumpkings, as well as other committers.)</source>
          <target state="translated">任何提交者都可以从 blead 分支中挑选任何一个提交到主分支,只要他们向 perl5-porters 发出邮件,宣布他们想挑选一个特定的提交,并说明这样做的理由,并且至少有两个其他提交者回复名单表示同意。(这个政策适用于现在的、以前的、以及其他提交者。)</target>
        </trans-unit>
        <trans-unit id="b95f0a7c9cbc43fb72281273ec465950ff501fea" translate="yes" xml:space="preserve">
          <source>Any contained POSIX character classes, including things like &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\D&lt;/code&gt; respect the &lt;code&gt;/a&lt;/code&gt; (and &lt;code&gt;/aa&lt;/code&gt; ) modifiers.</source>
          <target state="translated">任何包含的POSIX字符类，包括 &lt;code&gt;\w&lt;/code&gt; 和 &lt;code&gt;\D&lt;/code&gt; 类的东西都遵循 &lt;code&gt;/a&lt;/code&gt; （和 &lt;code&gt;/aa&lt;/code&gt; ）修饰符。</target>
        </trans-unit>
        <trans-unit id="5db2df3ee56bd2a814ccc5209f324c5b3591842c" translate="yes" xml:space="preserve">
          <source>Any data types supported by &lt;a href=&quot;../threads/shared&quot;&gt;threads::shared&lt;/a&gt; can be passed via queues:</source>
          <target state="translated">&lt;a href=&quot;../threads/shared&quot;&gt;thread :: shared&lt;/a&gt;支持的任何数据类型都可以通过队列传递：</target>
        </trans-unit>
        <trans-unit id="500c84c6a69d3cbc0070a804d35fd877c67e676d" translate="yes" xml:space="preserve">
          <source>Any directory to prefix to the extraction path, if any</source>
          <target state="translated">如果有的话,提取路径前缀的任何目录。</target>
        </trans-unit>
        <trans-unit id="fe63280e6a478a3a4b2a298d74baf468659f885a" translate="yes" xml:space="preserve">
          <source>Any existing</source>
          <target state="translated">任何现有的</target>
        </trans-unit>
        <trans-unit id="910f15fcdac4d39c624eb5925c6aedfca05cbd8f" translate="yes" xml:space="preserve">
          <source>Any extension to Perl, including those containing XSUBs, should have a Perl module to serve as the bootstrap which pulls the extension into Perl. This module will export the extension's functions and variables to the Perl program and will cause the extension's XSUBs to be linked into Perl. The following module will be used for most of the examples in this document and should be used from Perl with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; command as shown earlier. Perl modules are explained in more detail later in this document.</source>
          <target state="translated">对Perl的任何扩展，包括那些包含XSUB的扩展，都应该有一个Perl模块作为引导程序，将扩展引入Perl。此模块将扩展的功能和变量导出到Perl程序，并使扩展的XSUB链接到Perl。以下模块将用于本文档中的大多数示例，并且应通过Perl与 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 命令一起使用，如先前所示。Perl模块将在本文档的后面部分更详细地说明。</target>
        </trans-unit>
        <trans-unit id="25a23450424903dcd5fa1cc3d1a014ad157de4c5" translate="yes" xml:space="preserve">
          <source>Any extra arguments which shouldn't be passed on to &lt;code&gt;plan()&lt;/code&gt; should be stripped off by this method.</source>
          <target state="translated">此方法应删除不应传递给 &lt;code&gt;plan()&lt;/code&gt; 的所有其他参数。</target>
        </trans-unit>
        <trans-unit id="e812c3c14740bd790df37fd5ab976ff0e033c047" translate="yes" xml:space="preserve">
          <source>Any filehandles open at the time of the fork() will be dup()-ed. Thus, the files can be closed independently in the parent and child, but beware that the dup()-ed handles will still share the same seek pointer. Changing the seek position in the parent will change it in the child and vice-versa. One can avoid this by opening files that need distinct seek pointers separately in the child.</source>
          <target state="translated">任何在fork()时打开的文件句柄都会被dup()-ed。因此,文件可以在父文件和子文件中独立关闭,但要注意 dup()-ed 句柄仍然会共享同一个 seek 指针。改变父文件中的寻求位置会改变子文件中的寻求位置,反之亦然。可以通过在子程序中分别打开需要不同的寻求指针的文件来避免这种情况。</target>
        </trans-unit>
        <trans-unit id="187558535ccb5da9eca3826ba8e4d8b30ca76bc1" translate="yes" xml:space="preserve">
          <source>Any function in the list below may be used either with or without parentheses around its arguments. (The syntax descriptions omit the parentheses.) If you use parentheses, the simple but occasionally surprising rule is this: It</source>
          <target state="translated">下面列表中的任何函数都可以在其参数周围使用或不使用括号。(语法描述省略了括号)。(语法描述省略了括号。)如果你使用括号,简单但有时令人惊讶的规则是这样的。它</target>
        </trans-unit>
        <trans-unit id="24c8f5e2946c066d9a62168dcf66b92198c6784a" translate="yes" xml:space="preserve">
          <source>Any keys for which the value is &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be ignored.</source>
          <target state="translated">值为 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 的所有键都将被忽略。</target>
        </trans-unit>
        <trans-unit id="0c7f27e33616c341daf05c0b6c508f0fa8fdbd74" translate="yes" xml:space="preserve">
          <source>Any keys for which the value is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be ignored.</source>
          <target state="translated">值为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 的所有键都将被忽略。</target>
        </trans-unit>
        <trans-unit id="204edb5197689fcdc449ffc64469cd176c221d73" translate="yes" xml:space="preserve">
          <source>Any large IRC network (Dalnet, EFnet) is also likely to have a #perl channel, with varying activity levels.</source>
          <target state="translated">任何一个大型的IRC网络(Dalnet、EFnet)也都可能有一个#perl频道,活跃度不一。</target>
        </trans-unit>
        <trans-unit id="44271c2c405bf35e52ab0041e6847e60ca1ca0c2" translate="yes" xml:space="preserve">
          <source>Any letters between &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt; act as flags modifiers as with &lt;code&gt;(?adluimsx-imsx)&lt;/code&gt; . For example,</source>
          <target state="translated">之间有字母 &lt;code&gt;?&lt;/code&gt; 和 &lt;code&gt;:&lt;/code&gt; 与 &lt;code&gt;(?adluimsx-imsx)&lt;/code&gt; 一样用作标志修饰符。例如，</target>
        </trans-unit>
        <trans-unit id="5618684dee489724ebf8f57ba00718b3f30e3494" translate="yes" xml:space="preserve">
          <source>Any method calls on an object created with &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; will be dispatched to the package as a normal object.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 创建的对象上的任何方法调用都将作为常规对象分派到程序包。</target>
        </trans-unit>
        <trans-unit id="125ade77b67e2c4cd7a637af74e96e943bde8b70" translate="yes" xml:space="preserve">
          <source>Any methods marked</source>
          <target state="translated">任何标记的方法</target>
        </trans-unit>
        <trans-unit id="c1aa612608eba8166ce338b4b530d56d4e20399c" translate="yes" xml:space="preserve">
          <source>Any methods not listed here are derived from Math::BigFloat (or Math::BigInt), so make sure you check these two modules for further information.</source>
          <target state="translated">这里没有列出的任何方法都是从Math::BigFloat(或Math::BigInt)派生出来的,所以请务必查看这两个模块以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="9782a834fd90fe5d5545a24d61a39706e25bf926" translate="yes" xml:space="preserve">
          <source>Any mixture is possible. For example, the most frequently used options could be stored in variables while all other options get stored in the hash:</source>
          <target state="translated">任何混合都是可能的。例如,最常用的选项可以存储在变量中,而所有其他选项则存储在哈希中。</target>
        </trans-unit>
        <trans-unit id="d9afc9d2e9f12a7ae747d6b9bda2062ad21b9fd2" translate="yes" xml:space="preserve">
          <source>Any names which are not tags are added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; unchanged but will trigger a warning (with &lt;code&gt;-w&lt;/code&gt; ) to avoid misspelt tags names being silently added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; . Future versions may make this a fatal error.</source>
          <target state="translated">任何不是标签的名称都将 &lt;code&gt;@EXPORT&lt;/code&gt; 添加到@EXPORT或 &lt;code&gt;@EXPORT_OK&lt;/code&gt; ,但会触发警告（带有 &lt;code&gt;-w&lt;/code&gt; ），以避免将拼写错误的标签名称默默添加到 &lt;code&gt;@EXPORT&lt;/code&gt; 或 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 。将来的版本可能会导致此致命错误。</target>
        </trans-unit>
        <trans-unit id="485a3dceff3fe3343086f55cd7ded47422eb7429" translate="yes" xml:space="preserve">
          <source>Any newlines in $perl_code will be escaped. Leading and trailing newlines will be stripped. Makes this idiom much easier:</source>
          <target state="translated">$perl_code中的任何换行符都将被转义。前导和尾部的换行符将被删除。这让这个成语变得更加简单。</target>
        </trans-unit>
        <trans-unit id="85505e3e03d4cfb2c5d76c353aad39b235819057" translate="yes" xml:space="preserve">
          <source>Any non-whitespace delimiter may replace the slashes. Add space after the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; when using a character allowed in identifiers. If single quotes are used, no interpretation is done on the replacement string (the &lt;code&gt;/e&lt;/code&gt; modifier overrides this, however). Note that Perl treats backticks as normal delimiters; the replacement text is not evaluated as a command. If the</source>
          <target state="translated">任何非空格分隔符都可以替换斜杠。使用标识符允许的字符时，在 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 后添加空格。如果使用单引号，则不会对替换字符串进行任何解释（但是 &lt;code&gt;/e&lt;/code&gt; 修饰符会覆盖此内容）。请注意，Perl将反引号视为常规定界符；替换文本不作为命令求值。如果</target>
        </trans-unit>
        <trans-unit id="21321c35f59a007bf7dcddd13bebabd646dd3b58" translate="yes" xml:space="preserve">
          <source>Any number of &lt;code&gt;(*PRUNE)&lt;/code&gt; assertions may be used in a pattern.</source>
          <target state="translated">模式中可以使用任意数量的 &lt;code&gt;(*PRUNE)&lt;/code&gt; 断言。</target>
        </trans-unit>
        <trans-unit id="8bc2478d6a5974c2f338a393e6f6ea8ec88b251c" translate="yes" xml:space="preserve">
          <source>Any number of arguments can occur in the list before the array but the input and output arrays must be the last elements in the list.</source>
          <target state="translated">在数组之前的列表中可以出现任何数量的参数,但输入和输出数组必须是列表中的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="637eecabf535d7591a4a05a68e784539a4cbb56d" translate="yes" xml:space="preserve">
          <source>Any number of tildes and surrounding whitespace will be collapsed to a single space.</source>
          <target state="translated">任何数量的tildes和周围的whitespace将被折叠成一个空间。</target>
        </trans-unit>
        <trans-unit id="799d3a594ea06ab8f69431e4521092706a0ca250" translate="yes" xml:space="preserve">
          <source>Any of the bit masks can also be undef. The timeout, if specified, is in seconds, which may be fractional. Note: not all implementations are capable of returning the $timeleft. If not, they always return $timeleft equal to the supplied $timeout.</source>
          <target state="translated">任何一个位掩码也可以是undef。如果指定了超时,则以秒为单位,可以是小数。注意:并非所有的实现都能返回$timeleft。如果不能,它们总是返回$timeleft等于提供的$timeout。</target>
        </trans-unit>
        <trans-unit id="96dac77ef4a45d1d47b4f15ad920f1efda518fb4" translate="yes" xml:space="preserve">
          <source>Any of these modifiers can be set to apply globally to all regular expressions compiled within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; . See &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;'/flags' mode in re&lt;/a&gt;.</source>
          <target state="translated">可以将这些修饰符中的任何一个设置为全局应用于在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; 范围内编译的所有正则表达式。请参见&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;re中的&amp;ldquo; / flags&amp;rdquo;模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d72e7a2b4416a01397ed95a3d69723c275ceb3de" translate="yes" xml:space="preserve">
          <source>Any of these statements are nice replacements for &lt;code&gt;BEGIN { &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter; @ISA = qw(Exporter); }&lt;/code&gt; with the same compile-time effect. The basic difference is that &lt;code&gt;base&lt;/code&gt; code interacts with declared &lt;code&gt;fields&lt;/code&gt; while &lt;code&gt;parent&lt;/code&gt; is a streamlined version of the older &lt;code&gt;base&lt;/code&gt; code to just establish the IS-A relationship.</source>
          <target state="translated">这些语句中的任何一个都可以很好地替代 &lt;code&gt;BEGIN { &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter; @ISA = qw(Exporter); }&lt;/code&gt; 用相同的编译时的效果。基本区别是 &lt;code&gt;base&lt;/code&gt; 代码与声明的 &lt;code&gt;fields&lt;/code&gt; 进行交互，而 &lt;code&gt;parent&lt;/code&gt; 是旧版本 &lt;code&gt;base&lt;/code&gt; 代码的简化版本，仅用于建立IS-A关系。</target>
        </trans-unit>
        <trans-unit id="54d3e07363608f1d20995e0548f7b8658feed7f4" translate="yes" xml:space="preserve">
          <source>Any omitted or empty regular expressions will default to &quot;.*&quot;. Please note that each regular expression given is implicitly anchored by adding &quot;^&quot; and &quot;$&quot; to the beginning and end. Also, if a given regular expression starts with a &quot;!&quot; character, then the expression is</source>
          <target state="translated">任何省略或空的正则表达式将默认为&quot;.*&quot;。请注意,每个给定的正则表达式都会在开头和结尾处添加&quot;^&quot;和&quot;$&quot;,从而隐式锚定。此外,如果给定的正则表达式以&quot;!&quot;字符开头,那么表达式就是</target>
        </trans-unit>
        <trans-unit id="0f87f06eba2caf7b827d1f8e16065d83ac575560" translate="yes" xml:space="preserve">
          <source>Any other character it taken literally.</source>
          <target state="translated">任何其他的角色,它从字面上看。</target>
        </trans-unit>
        <trans-unit id="3effb550cd8c77527aa9de81743828a3b7722f93" translate="yes" xml:space="preserve">
          <source>Any other parameters specific to the method</source>
          <target state="translated">与该方法有关的任何其他参数</target>
        </trans-unit>
        <trans-unit id="c9c0186423c77aa8d8e97bed87ca7acf745a240d" translate="yes" xml:space="preserve">
          <source>Any other return code means that a flush point was not found. If more data is available, &lt;code&gt;inflateSync&lt;/code&gt; can be called repeatedly with more compressed data until the flush point is found.</source>
          <target state="translated">任何其他返回代码意味着未找到刷新点。如果有更多数据可用， &lt;code&gt;inflateSync&lt;/code&gt; 可以使用更多压缩数据重复调用inflateSync，直到找到刷新点为止。</target>
        </trans-unit>
        <trans-unit id="26c9cefe7b574f70d77490b40ef9d059faa47f0c" translate="yes" xml:space="preserve">
          <source>Any parameters to be pushed onto the stack should be bracketed by the &lt;code&gt;PUSHMARK&lt;/code&gt; and &lt;code&gt;PUTBACK&lt;/code&gt; macros. The purpose of these two macros, in this context, is to count the number of parameters you are pushing automatically. Then whenever Perl is creating the &lt;code&gt;@_&lt;/code&gt; array for the subroutine, it knows how big to make it.</source>
          <target state="translated">任何要压入堆栈的参数都应在 &lt;code&gt;PUSHMARK&lt;/code&gt; 和 &lt;code&gt;PUTBACK&lt;/code&gt; 宏后面加上括号。在这种情况下，这两个宏的目的是计算您自动推送的参数数量。然后，每当Perl为子例程创建 &lt;code&gt;@_&lt;/code&gt; 数组时，它就会知道要创建多大的数组。</target>
        </trans-unit>
        <trans-unit id="393576095a8de6bc0086f7597df6e48f941f115a" translate="yes" xml:space="preserve">
          <source>Any pattern containing a special backtracking verb that allows an argument has the special behaviour that when executed it sets the current package's &lt;code&gt;$REGERROR&lt;/code&gt; and &lt;code&gt;$REGMARK&lt;/code&gt; variables. When doing so the following rules apply:</source>
          <target state="translated">包含允许参数的特殊回溯动词的任何模式都具有特殊的行为，即在执行时会设置当前包的 &lt;code&gt;$REGERROR&lt;/code&gt; 和 &lt;code&gt;$REGMARK&lt;/code&gt; 变量。这样做时，以下规则适用：</target>
        </trans-unit>
        <trans-unit id="0f7c0d8ab3a57bbfaec5da2f59e5489aaf2f7ee1" translate="yes" xml:space="preserve">
          <source>Any references that are the same as one of those passed in will be named &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">与传入的引用之一相同的任何引用将被命名为 &lt;code&gt;$VAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0947cd6471d04a9e9e7aba2d6ed254ce36b6a65" translate="yes" xml:space="preserve">
          <source>Any regular expression special characters in &lt;code&gt;$regex&lt;/code&gt; are still special, and the pattern still has to be valid or Perl will complain. For instance, in this pattern there is an unpaired parenthesis.</source>
          <target state="translated">&lt;code&gt;$regex&lt;/code&gt; 中的任何正则表达式特殊字符仍然是特殊字符，该模式仍然必须有效，否则Perl会抱怨。例如，在此模式中，存在不成对的括号。</target>
        </trans-unit>
        <trans-unit id="fe7f6f318181e1a9721562694a44d98bb9f0d89c" translate="yes" xml:space="preserve">
          <source>Any scalar value that doesn&amp;rsquo;t evaluate to 0 or &lt;code&gt;&quot;&quot;&lt;/code&gt; .</source>
          <target state="translated">任何不等于0或 &lt;code&gt;&quot;&quot;&lt;/code&gt; 标量值。</target>
        </trans-unit>
        <trans-unit id="b9848f5389028c0e6f897c58baee24bbe4b4452b" translate="yes" xml:space="preserve">
          <source>Any scalar variable may carry PERL_MAGIC_collxfrm magic that contains the scalar data of the variable, but transformed to such a format that a normal memory comparison can be used to compare the data according to the locale settings.</source>
          <target state="translated">任何标量变量都可以携带PERL_MAGIC_collxfrm魔法,该魔法包含变量的标量数据,但转换为这样一种格式,即可以根据locale设置使用正常的内存比较来比较数据。</target>
        </trans-unit>
        <trans-unit id="38fbec488780a53c892b68c97c1898064ef5cf3c" translate="yes" xml:space="preserve">
          <source>Any simple statement may optionally be followed by a</source>
          <target state="translated">任何简单的语句后面都可以选择加一个</target>
        </trans-unit>
        <trans-unit id="d57ad08ad6b4b977666be8da12ed7e9b3597a3e6" translate="yes" xml:space="preserve">
          <source>Any single character matches itself, unless it is a</source>
          <target state="translated">任何单个字符都与自己匹配,除非它是一个。</target>
        </trans-unit>
        <trans-unit id="f581a0aac4749093894a9605cfac9a184c97919e" translate="yes" xml:space="preserve">
          <source>Any special flags that might need to be passed to ld to create a shared library suitable for dynamic loading. It is up to the makefile to use it. (See &lt;a href=&quot;../config#lddlflags&quot;&gt;lddlflags in Config&lt;/a&gt;)</source>
          <target state="translated">可能需要将任何特殊标志传递给ld，以创建适合于动态加载的共享库。使用它取决于makefile。（请参阅&lt;a href=&quot;../config#lddlflags&quot;&gt;Config中的lddlflags&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="cae1c49f6637fcf58ae140f395f043a2e193fb5a" translate="yes" xml:space="preserve">
          <source>Any statement within the body of a loop that can make a loop prematurely stop looping or skip an &lt;b&gt;iteration&lt;/b&gt;. Generally, you shouldn&amp;rsquo;t try this on roller coasters.</source>
          <target state="translated">循环体内任何可以使循环过早停止循环或跳过&lt;b&gt;迭代的&lt;/b&gt;语句。通常，您不应该在过山车上尝试此操作。</target>
        </trans-unit>
        <trans-unit id="a7b963c94b597f0a356b5a56744621822590c340" translate="yes" xml:space="preserve">
          <source>Any string eval which is executed by code executing in a compartment, or by code called from code executing in a compartment, will be eval'd in the namespace of the compartment. This is potentially a serious problem.</source>
          <target state="translated">任何被在隔间中执行的代码所执行的字符串eval,或者被在隔间中执行的代码所调用的代码,都会在隔间的命名空间中被eval。这是个潜在的严重问题。</target>
        </trans-unit>
        <trans-unit id="8a7a9db7b2a7d9c3bc4a0371b24f090bb005ce01" translate="yes" xml:space="preserve">
          <source>Any switches in the &lt;code&gt;PERLDOC&lt;/code&gt; environment variable will be used before the command line arguments.</source>
          <target state="translated">&lt;code&gt;PERLDOC&lt;/code&gt; 环境变量中的所有开关都将在命令行参数之前使用。</target>
        </trans-unit>
        <trans-unit id="c697d8a2e427d5d56c9e1028dbc399fcc4b347e2" translate="yes" xml:space="preserve">
          <source>Any time after Perl starts running your main program. See also &lt;b&gt;compile phase&lt;/b&gt;. Run phase is mostly spent in &lt;b&gt;runtime&lt;/b&gt; but may also be spent in &lt;b&gt;compile time&lt;/b&gt; when &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Perl开始运行主程序后的任何时间。另请参见&lt;b&gt;编译阶段&lt;/b&gt;。运行阶段主要是花费在&lt;b&gt;运行&lt;/b&gt;，但也可以在花费&lt;b&gt;编译时间&lt;/b&gt;的时候 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00807e0e44bec9e684bd05f5d6ca841ffb6f513c" translate="yes" xml:space="preserve">
          <source>Any time before Perl starts running your main program. See also &lt;b&gt;run phase&lt;/b&gt;. Compile phase is mostly spent in &lt;b&gt;compile time&lt;/b&gt;, but may also be spent in &lt;b&gt;runtime&lt;/b&gt; when &lt;code&gt;BEGIN&lt;/code&gt; blocks, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; declarations, or constant subexpressions are being evaluated. The startup and import code of any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; declaration is also run during compile phase.</source>
          <target state="translated">Perl开始运行主程序之前的任何时间。另请参见&lt;b&gt;运行阶段&lt;/b&gt;。编译阶段主要花费在&lt;b&gt;编译时&lt;/b&gt;，但是也可能花费在&lt;b&gt;运行&lt;/b&gt;时，当 &lt;code&gt;BEGIN&lt;/code&gt; 块， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 使用声明，或评估常量子表达式时。任何 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 声明的启动和导入代码也在编译阶段运行。</target>
        </trans-unit>
        <trans-unit id="5bea195cc0120bd58a5f6ddfad70e861a932bba8" translate="yes" xml:space="preserve">
          <source>AnyDBM_File</source>
          <target state="translated">AnyDBM_File</target>
        </trans-unit>
        <trans-unit id="abf989fc06a7a8552843b93b1474a012067198d8" translate="yes" xml:space="preserve">
          <source>AnyDBM_File - provide framework for multiple DBMs</source>
          <target state="translated">AnyDBM_File-为多个DBM提供框架。</target>
        </trans-unit>
        <trans-unit id="29c9b5ccd4a8843ac06d93de6db98a168d9747a5" translate="yes" xml:space="preserve">
          <source>Anyone interested in resurrecting this file should pull the old version from the MakeMaker CVS repository and contact makemaker@perl.org.</source>
          <target state="translated">任何对复活这个文件感兴趣的人都应该从MakeMaker CVS仓库中提取旧版本,并联系makemaker@perl.org。</target>
        </trans-unit>
        <trans-unit id="f1313a33b13e0ad302add61f009e5344735237ef" translate="yes" xml:space="preserve">
          <source>Anything after this line is the description of XSUB functions. These descriptions are translated by &lt;b&gt;xsubpp&lt;/b&gt; into C code which implements these functions using Perl calling conventions, and which makes these functions visible from Perl interpreter.</source>
          <target state="translated">此行之后的所有内容都是XSUB函数的描述。&lt;b&gt;xsubpp&lt;/b&gt;将这些描述转换为C代码，该代码使用Perl调用约定来实现这些功能，并使这些功能在Perl解释器中可见。</target>
        </trans-unit>
        <trans-unit id="7767ddde79c4e54f955f8a8770af897489800878" translate="yes" xml:space="preserve">
          <source>Anything before this line is plain C code which describes which headers to include, and defines some convenience functions. No translations are performed on this part, apart from having embedded POD documentation skipped over (see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;) it goes into the generated output C file as is.</source>
          <target state="translated">这行之前的所有内容都是纯C代码，它描述了要包含的标头，并定义了一些便利功能。此部分不执行任何翻译，除了跳过嵌入式POD文档（请参阅&lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;）之外，它直接进入生成的输出C文件。</target>
        </trans-unit>
        <trans-unit id="9e010e0ae6e0590e5e1834d00dd2ae5e4328a555" translate="yes" xml:space="preserve">
          <source>Anything between white space and an end of line within a &lt;code&gt;MANIFEST&lt;/code&gt; file is considered to be a comment. Any line beginning with # is also a comment. Beginning with ExtUtils::Manifest 1.52, a filename may contain whitespace characters if it is enclosed in single quotes; single quotes or backslashes in that filename must be backslash-escaped.</source>
          <target state="translated">空格和 &lt;code&gt;MANIFEST&lt;/code&gt; 文件中的行尾之间的任何内容均视为注释。以＃开头的任何行也是注释。从ExtUtils :: Manifest 1.52开始，如果文件名用单引号引起来，则文件名可能包含空格字符；该文件名中的单引号或反斜杠必须使用反斜杠转义。</target>
        </trans-unit>
        <trans-unit id="d23663e502213da0e6ba19093e62429d22e02845" translate="yes" xml:space="preserve">
          <source>Anything else is a Perl-specific convenience abbreviation. Specify one or more scripts by names if you want short names that are script-specific.</source>
          <target state="translated">其他的都是Perl专用的方便缩写。如果你想用脚本专用的短名来指定一个或多个脚本的名字。</target>
        </trans-unit>
        <trans-unit id="7d749de0de5c93aeb0a7eeebe5226cb0dd35304d" translate="yes" xml:space="preserve">
          <source>Anything in EXPR that matches PATTERN is taken to be a separator that separates the EXPR into substrings (called &quot;</source>
          <target state="translated">EXPR中任何与PATTERN匹配的内容都会被视为分隔符,将EXPR分隔成子串(称为 &quot;</target>
        </trans-unit>
        <trans-unit id="beac50162375e06d01167c42cce2dc5426c4e092" translate="yes" xml:space="preserve">
          <source>Anything marked as BE is Big Endian (or network byte order) and LE is Little Endian (aka VAX byte order). For anything not marked either BE or LE, a character called Byte Order Mark (BOM) indicating the endianness is prepended to the string.</source>
          <target state="translated">凡是标记为BE的都是Big Endian(或网络字节序),LE是Little Endian(又称VAX字节序)。对于没有标记为BE或LE的任何东西,一个称为字节顺序标记(BOM)的字符将被预置到字符串中,以表示恩典性。</target>
        </trans-unit>
        <trans-unit id="595fc50992e17250599953061722960b35607014" translate="yes" xml:space="preserve">
          <source>Anything put here will be passed to MY::postamble() if you have one.</source>
          <target state="translated">如果你有MY::postamble()的话,放在这里的任何东西都会被传递给它。</target>
        </trans-unit>
        <trans-unit id="eb489bfffc02c3f32a21cb7909eae48c47e3d9b4" translate="yes" xml:space="preserve">
          <source>Anything that follows &lt;code&gt;#&lt;/code&gt; is treated as a comment.</source>
          <target state="translated">下面任何 &lt;code&gt;#&lt;/code&gt; 被视为注释。</target>
        </trans-unit>
        <trans-unit id="aaea73d52ae0a47a220342d260ea4c54a027d322" translate="yes" xml:space="preserve">
          <source>Anything you can legally say in a spot where a &lt;b&gt;value&lt;/b&gt; is required. Typically composed of &lt;b&gt;literals&lt;/b&gt;, &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;operators&lt;/b&gt;, &lt;b&gt;functions&lt;/b&gt;, and &lt;b&gt;subroutine&lt;/b&gt; calls, not necessarily in that order.</source>
          <target state="translated">您可以在需要&lt;b&gt;值&lt;/b&gt;的地方合法地说出任何话。通常由&lt;b&gt;文字&lt;/b&gt;，&lt;b&gt;变量&lt;/b&gt;，&lt;b&gt;运算符&lt;/b&gt;，&lt;b&gt;函数&lt;/b&gt;和&lt;b&gt;子例程&lt;/b&gt;调用组成，不一定&lt;b&gt;按此&lt;/b&gt;顺序。</target>
        </trans-unit>
        <trans-unit id="90ac4d3777dbcf43ec0f981e70e6cb4230e6e6f9" translate="yes" xml:space="preserve">
          <source>Anyway, here it is. Should run on perl v4 or greater. Maybe less.</source>
          <target state="translated">总之,它在这里。应该在perl v4或更高版本上运行。也许更少。</target>
        </trans-unit>
        <trans-unit id="2e755b3358691db1161de932e3c7e74daf5374dd" translate="yes" xml:space="preserve">
          <source>Anyway, this is what you can do if you can't help yourself.</source>
          <target state="translated">不管怎么说,这是你情不自禁的时候可以做的。</target>
        </trans-unit>
        <trans-unit id="61fbeb450419f819d1d3fb527e61bbd77f1f245b" translate="yes" xml:space="preserve">
          <source>Anywhere you'd put an identifier (or chain of identifiers) as part of a variable or subroutine name, you can replace the identifier with a BLOCK returning a reference of the correct type. In other words, the previous examples could be written like this:</source>
          <target state="translated">在你把一个标识符(或标识符链)作为变量或子程序名称的一部分的地方,你可以用一个返回正确类型引用的BLOCK来替换标识符。换句话说,前面的例子可以这样写。</target>
        </trans-unit>
        <trans-unit id="c4897c70becad60eb583b067e9239c22c138553c" translate="yes" xml:space="preserve">
          <source>Anywhere you'd put an identifier (or chain of identifiers) as part of a variable or subroutine name, you can replace the identifier with a simple scalar variable containing a reference of the correct type:</source>
          <target state="translated">在你将标识符(或标识符链)作为变量或子程序名称的一部分的地方,你可以用一个包含正确类型引用的简单标量变量来替换标识符。</target>
        </trans-unit>
        <trans-unit id="1152548ba48e279bc989a0c42814e21456001922" translate="yes" xml:space="preserve">
          <source>Apache::GZip Revisited</source>
          <target state="translated">Apache::GZip重温</target>
        </trans-unit>
        <trans-unit id="eef8ccdc1b5028a7590e9e7eb6807d9775169439" translate="yes" xml:space="preserve">
          <source>Apart from being non-portable to some operating systems, this made it difficult to use &lt;code&gt;gzopen&lt;/code&gt; in situations where you wanted to extract/create a gzip data stream that is embedded in a larger file, without having to resort to opening and closing the file multiple times.</source>
          <target state="translated">除了无法移植到某些操作系统之外，这使得在您要提取/创建嵌入到较大文件中的gzip数据流而不必求助于打开和关闭多个文件的情况下，很难使用 &lt;code&gt;gzopen&lt;/code&gt; 次。</target>
        </trans-unit>
        <trans-unit id="4e3144b6ad1fe422c840b3431e9e995cf1a334a3" translate="yes" xml:space="preserve">
          <source>Apart from discussing the C interface provided by Perl for writing callbacks the document uses a series of examples to show how the interface actually works in practice. In addition some techniques for coding callbacks are covered.</source>
          <target state="translated">除了讨论Perl提供的用于编写回调的C语言接口外,本文还使用了一系列的例子来展示该接口在实践中是如何工作的。此外,本文还介绍了一些回调的编码技术。</target>
        </trans-unit>
        <trans-unit id="6c594049f559b0aa030aaa7fc2712868c419ba1f" translate="yes" xml:space="preserve">
          <source>Apart from now being a boolean, the &lt;code&gt;$^W&lt;/code&gt; variable operates in exactly the same horrible uncontrolled global way, except that it cannot disable/enable default warnings.</source>
          <target state="translated">除了现在是布尔值之外， &lt;code&gt;$^W&lt;/code&gt; 变量以完全相同的可怕的不受控制的全局方式运行，除了它不能禁用/启用默认警告。</target>
        </trans-unit>
        <trans-unit id="177ebac14cb8719946f6e7935d5609a89f70ecb3" translate="yes" xml:space="preserve">
          <source>Apart from the behavior described above, Perl does not expand multiple levels of interpolation. In particular, contrary to the expectations of shell programmers, back-quotes do</source>
          <target state="translated">除了上述行为外,Perl并没有展开多级插值。特别是,与shell程序员的期望相反,反引号并没有</target>
        </trans-unit>
        <trans-unit id="5e5b5fcfebfb49c5cb95c4adedad19fe315234ce" translate="yes" xml:space="preserve">
          <source>Apart from the first parameter, import can accept an optional list of parameters. These can be used to pass parameters to the filter. For example:</source>
          <target state="translated">除了第一个参数之外,import还可以接受一个可选的参数列表。这些参数可以用来向过滤器传递参数。例如</target>
        </trans-unit>
        <trans-unit id="ea290b2592c04a29efbf4275fbffd4e15c783ad7" translate="yes" xml:space="preserve">
          <source>Apart from the overstrike, it in all ways functions like Pod::Text. See &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">除了过度罢工，它在所有方面都类似于Pod :: Text。有关详细信息和可用选项，请参见&lt;a href=&quot;../text&quot;&gt;Pod :: Text&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="59fd50fcdac085cfabfc65f7db775038f8cecc31" translate="yes" xml:space="preserve">
          <source>App::Prove</source>
          <target state="translated">App::Prove</target>
        </trans-unit>
        <trans-unit id="3a1656ea85b06be3923d0763368c6414c09514c6" translate="yes" xml:space="preserve">
          <source>App::Prove - Implements the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">App :: Prove-实现 &lt;code&gt;prove&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="7174791288d36e70929f8c68ba39037f796046e4" translate="yes" xml:space="preserve">
          <source>App::Prove::State</source>
          <target state="translated">App::Prove::State</target>
        </trans-unit>
        <trans-unit id="39ce25b85982de5bdaced90b86fd5469adc9a51a" translate="yes" xml:space="preserve">
          <source>App::Prove::State - State storage for the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">App :: Prove :: State- &lt;code&gt;prove&lt;/code&gt; 命令的状态存储。</target>
        </trans-unit>
        <trans-unit id="96f79883bf2f299a489c18241a0f9c3ce22137d2" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result</source>
          <target state="translated">App::Prove::State::Result</target>
        </trans-unit>
        <trans-unit id="604c79e231e51591da6ce53e73549980b6c066b2" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result - Individual test suite results.</source>
          <target state="translated">App::Prove::State::Result-单个测试套件的结果。</target>
        </trans-unit>
        <trans-unit id="83a53d94c22845a17e42b81ff706d21b9d9578b9" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result::Test</source>
          <target state="translated">App::Prove::State::Result::Test</target>
        </trans-unit>
        <trans-unit id="dcd1440850fc9e2913d7cf105103afc698a85230" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result::Test - Individual test results.</source>
          <target state="translated">App::Prove::State::Result::Test-单个测试结果。</target>
        </trans-unit>
        <trans-unit id="a04f6596455dd68a60a8ad9f2a7176ca7fb0ee44" translate="yes" xml:space="preserve">
          <source>Apparently, IBM used a compiler (for some period of time around '95?) which changes FP mask right and left. This is not</source>
          <target state="translated">显然,IBM使用的编译器(95年左右的一段时间?)会左右改变FP掩码。这不是</target>
        </trans-unit>
        <trans-unit id="3c4496c4495e5c99d047e29d461a211122789431" translate="yes" xml:space="preserve">
          <source>Appeal to their self interest! If Perl is new (and thus scary) to them, find something that Perl can do to solve one of their problems. That might mean that Perl either saves them something (time, headaches, money) or gives them something (flexibility, power, testability).</source>
          <target state="translated">吸引他们的自身利益! 如果Perl对他们来说是新的(因此也是可怕的),那么就找一些Perl可以解决他们的问题。这可能意味着Perl要么为他们节省了一些东西(时间、头痛、金钱),要么给了他们一些东西(灵活性、功能强大、可测试性)。</target>
        </trans-unit>
        <trans-unit id="b71dbc9f1f2c8f41b80953098f3e95dfa1012f02" translate="yes" xml:space="preserve">
          <source>Append an item to the list of ops contained directly within a list-type op, returning the lengthened list.</source>
          <target state="translated">将一个项目追加到直接包含在列表型操作中的操作列表中,返回加长后的列表。</target>
        </trans-unit>
        <trans-unit id="becdeb6adee05d280a8a50e1526a1a849bef0624" translate="yes" xml:space="preserve">
          <source>Append elements of</source>
          <target state="translated">添加以下元素</target>
        </trans-unit>
        <trans-unit id="7b02fe45aa574073ed825bd38be9577b88d0ca63" translate="yes" xml:space="preserve">
          <source>Append elements of LIST to the array.</source>
          <target state="translated">将LIST的元素追加到数组中。</target>
        </trans-unit>
        <trans-unit id="89394607a467e98868ad0332e6c7061404a979e4" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;../../time/hires&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">附加运行时间以输出每个测试。使用&lt;a href=&quot;../../time/hires&quot;&gt;Time :: HiRes（&lt;/a&gt;如果可用）。</target>
        </trans-unit>
        <trans-unit id="f3320c1303317ee828f35f641012da0ef7ad78b8" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;../time/hires&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">附加运行时间以输出每个测试。使用&lt;a href=&quot;../time/hires&quot;&gt;Time :: HiRes（&lt;/a&gt;如果可用）。</target>
        </trans-unit>
        <trans-unit id="115b06d7e965b2c8ec031641d6914969c4847565" translate="yes" xml:space="preserve">
          <source>Appending the G_KEEPERR flag, so that the</source>
          <target state="translated">添加G_KEEPERR标志,这样就可以使</target>
        </trans-unit>
        <trans-unit id="112a3bb05c1aa885c550b6193e7eaea408add2b6" translate="yes" xml:space="preserve">
          <source>Appends the given string or parse-tree or sequence object to the parse-tree of this interior sequence.</source>
          <target state="translated">将给定的字符串或解析树或序列对象附加到这个内部序列的解析树上。</target>
        </trans-unit>
        <trans-unit id="6dd82bd12d46344a2006677b750f75da928a5f51" translate="yes" xml:space="preserve">
          <source>Application of the patches</source>
          <target state="translated">补丁的应用</target>
        </trans-unit>
        <trans-unit id="e91f35534bce18d06e39334fde833d8a1d0115a1" translate="yes" xml:space="preserve">
          <source>Application release September 2001, HP-UX 11.00 is the first to ship with Perl. By the time it was perl-5.6.1 in /opt/perl. The first occurrence is on CD 5012-7954 and can be installed using</source>
          <target state="translated">应用发布2001年9月,HP-UX 11.00是第一个搭载Perl的版本。到时是perl-5.6.1在/opt/perl中。第一次出现在CD 5012-7954上,可以用它来安装。</target>
        </trans-unit>
        <trans-unit id="70dcb259ecf9216f358dc0f66966f145bfe54f70" translate="yes" xml:space="preserve">
          <source>Applies a syntactic context to an op tree representing an expression.</source>
          <target state="translated">将语法上下文应用到表示表达式的运算树上。</target>
        </trans-unit>
        <trans-unit id="d5ed3f5653497e355ed136e0b7c54a5982ace7b4" translate="yes" xml:space="preserve">
          <source>Applies dl_find_symbol() to the members of @dl_librefs and returns the first match found.</source>
          <target state="translated">将 dl_find_symbol()应用于 @dl_librefs 的成员,并返回找到的第一个匹配项。</target>
        </trans-unit>
        <trans-unit id="197e68ad33f090de266ab7a82716d4dcf0c6223c" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; to the value returned by &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">应用 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; 被返回的值 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; ，如果你想随机整数，而不是随机小数。例如，</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
