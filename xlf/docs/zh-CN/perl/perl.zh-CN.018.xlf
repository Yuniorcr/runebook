<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="99b9fdd9de86d1d00f397b16abef1b9cafbc97c4" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;variable&lt;/b&gt; in a language like C that contains the exact memory location of some other item. Perl handles pointers internally so you don&amp;rsquo;t have to worry about them. Instead, you just use symbolic pointers in the form of &lt;b&gt;keys&lt;/b&gt; and &lt;b&gt;variable&lt;/b&gt; names, or &lt;b&gt;hard references&lt;/b&gt;, which aren&amp;rsquo;t pointers (but act like pointers and do in fact contain pointers).</source>
          <target state="translated">像C这样的语言中的&lt;b&gt;变量&lt;/b&gt;，它包含某些其他项的确切存储位置。Perl在内部处理指针，因此您不必担心它们。取而代之的是，您仅使用&lt;b&gt;键&lt;/b&gt;和&lt;b&gt;变量&lt;/b&gt;名形式的符号指针，或&lt;b&gt;硬引用&lt;/b&gt;（不是指针）（而是像指针一样工作，实际上包含指针）。</target>
        </trans-unit>
        <trans-unit id="51c90d619538801ef4598602775b97c77a42912f" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;variable&lt;/b&gt; prefixed with &lt;code&gt;$&lt;/code&gt; that holds a single value.</source>
          <target state="translated">以 &lt;code&gt;$&lt;/code&gt; 开头的&lt;b&gt;变量&lt;/b&gt;包含单个值。</target>
        </trans-unit>
        <trans-unit id="a036ff35f0b4159168ba2281ee65e4b238ac5692" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;variable&lt;/b&gt; subject to &lt;b&gt;lexical scoping&lt;/b&gt;, declared by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. Often just called a &amp;ldquo;lexical&amp;rdquo;. (The &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares a lexically scoped name for a global variable, which is not itself a lexical variable.)</source>
          <target state="translated">一个&lt;b&gt;变量&lt;/b&gt;服从&lt;b&gt;词汇范围&lt;/b&gt;，宣布 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 。通常被称为&amp;ldquo;词汇&amp;rdquo;。（ &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明为全局变量声明了一个词法范围的名称，它本身并不是词法变量。）</target>
        </trans-unit>
        <trans-unit id="d364f02d6990848dc623c28306b3b67cfe16a460" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;verbatim paragraph&lt;/b&gt;. The first line of this paragraph must be a literal space or tab, and this paragraph must not be inside a &quot;=begin</source>
          <target state="translated">一个&lt;b&gt;逐字段落&lt;/b&gt;。该段的第一行必须是文字空间或制表符，并且该段不得位于&amp;ldquo; = begin&amp;rdquo;之内</target>
        </trans-unit>
        <trans-unit id="6c2475be186a7213d2a980a851a800269b2e5a86" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;()&lt;/code&gt; group is a sub-TEMPLATE enclosed in parentheses. A group may take a repeat count either as postfix, or for unpack(), also via the &lt;code&gt;/&lt;/code&gt; template character. Within each repetition of a group, positioning with &lt;code&gt;@&lt;/code&gt; starts over at 0. Therefore, the result of</source>
          <target state="translated">甲 &lt;code&gt;()&lt;/code&gt; 基团是子模板括号括起来。组也可以通过 &lt;code&gt;/&lt;/code&gt; 模板字符作为后缀或对于unpack（）进行重复计数。在一个组的每个重复中，用 &lt;code&gt;@&lt;/code&gt; 定位从0开始。因此，</target>
        </trans-unit>
        <trans-unit id="a287ce1841efe5bc899e4207e715388b0c45e263" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; allows the subroutine to accept a bareword, constant, scalar expression, typeglob, or a reference to a typeglob in that slot. The value will be available to the subroutine either as a simple scalar, or (in the latter two cases) as a reference to the typeglob. If you wish to always convert such arguments to a typeglob reference, use Symbol::qualify_to_ref() as follows:</source>
          <target state="translated">甲 &lt;code&gt;*&lt;/code&gt; 允许子程序接受裸词，常量，标量表达式，类型团，或在该时隙到一个类型团的引用。该值可以作为简单标量或（对于后两种情况）作为对typeglob的引用提供给子例程。如果希望始终将此类参数转换为typeglob引用，请按如下方式使用Symbol :: qualify_to_ref（）：</target>
        </trans-unit>
        <trans-unit id="61da191aeee246a70549905e1a2b4d958c2fd1c9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; for the repeat count uses all characters of the input field. For unpack(), nybbles are converted to a string of hexadecimal digits.</source>
          <target state="translated">一 &lt;code&gt;*&lt;/code&gt; 为重复计数使用输入字段的所有字符。对于unpack（），将四位字节转换为十六进制数字字符串。</target>
        </trans-unit>
        <trans-unit id="815c847c3d1b9e3c91a01ec8d23807326737a6a0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; for the repeat count uses all characters of the input field. On unpacking, bits are converted to a string of &lt;code&gt;0&lt;/code&gt; s and &lt;code&gt;1&lt;/code&gt; s.</source>
          <target state="translated">一 &lt;code&gt;*&lt;/code&gt; 为重复计数使用输入字段的所有字符。拆包时，位将转换为 &lt;code&gt;0&lt;/code&gt; s和 &lt;code&gt;1&lt;/code&gt; s 的字符串。</target>
        </trans-unit>
        <trans-unit id="89c65ec9d77b183c5b39e5d9c73a8c71422dfc22" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;--&lt;/code&gt; signals the end of options and disables further option processing. Any arguments after the &lt;code&gt;--&lt;/code&gt; are treated as filenames and arguments.</source>
          <target state="translated">甲 &lt;code&gt;--&lt;/code&gt; 信号的选项和禁止进一步的选择处理结束。 &lt;code&gt;--&lt;/code&gt; 后面的任何参数均被视为文件名和参数。</target>
        </trans-unit>
        <trans-unit id="bde6ae184752daa5e5b6a5c7417008782a0b714a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; failure may result in the following tests failing:</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 失败可能会导致下面的测试失败的：</target>
        </trans-unit>
        <trans-unit id="290859ef4b0199eb4b067a5c07f38a6730cc7301" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; is simply a modifier on an lvalue expression. When you assign to a &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized variable, the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; doesn't change whether its list is viewed as a scalar or an array. So</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 是简单地在左值表达式的改性剂。当你分配给 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 化的变量，在 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 并没有改变它的列表是否被视为一个标量或数组。所以</target>
        </trans-unit>
        <trans-unit id="1ac670f70b9818c1a06875d85552011a54fbdd94" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; modifies its listed variables to be &quot;local&quot; to the enclosing block, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; FILE&lt;/code&gt; --and to</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 修改其上市的变量是&amp;ldquo;本地&amp;rdquo;的封闭块， &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，或 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; FILE&lt;/code&gt; --and到</target>
        </trans-unit>
        <trans-unit id="5e64f0ec46a4ae84b19fc32e43ef29768338a5a4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declares the listed variables to be local (lexically) to the enclosing block, file, or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. If more than one variable is listed, the list must be placed in parentheses.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明列出的变量是本地（词汇）给封闭块，文件或 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 。如果列出了多个变量，则该列表必须放在括号中。</target>
        </trans-unit>
        <trans-unit id="f1479b4bde8f3dbb0c16d564288196fd25f56ff5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; has both a compile-time and a run-time effect. At compile time, the compiler takes notice of it. The principal usefulness of this is to quiet &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , but it is also essential for generation of closures as detailed in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Actual initialization is delayed until run time, though, so it gets executed at the appropriate time, such as each time through a loop, for example.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 既具有编译时和运行时的效果。在编译时，编译器会注意到它。这样做的主要用途是安静 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; ，但对于生成闭包也很重要，如&lt;a href=&quot;perlref&quot;&gt;perlref所述&lt;/a&gt;。但是，实际的初始化会延迟到运行时，因此它会在适当的时间执行，例如每次通过循环执行一次。</target>
        </trans-unit>
        <trans-unit id="31962f6029a8a1eb17179745d335b5ef4fc0067e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; statement may be used to exit a subroutine, optionally specifying the returned value, which will be evaluated in the appropriate context (list, scalar, or void) depending on the context of the subroutine call. If you specify no return value, the subroutine returns an empty list in list context, the undefined value in scalar context, or nothing in void context. If you return one or more aggregates (arrays and hashes), these will be flattened together into one large indistinguishable list.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 语句可用于退出子程序，任选指定取决于子程序调用的上下文返回值，这将在适当的上下文（列表中，标量，或空隙）进行评估。如果不指定返回值，则子例程在列表上下文中返回一个空列表，在标量上下文中返回未定义的值，或者在void上下文中不返回任何值。如果返回一个或多个聚合（数组和散列），则这些聚合将被平整为一个无法区分的大列表。</target>
        </trans-unit>
        <trans-unit id="0e88bf889822c4c5cba2a75e272c3a1e9aeaadd3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declares the listed variables to be local (lexically) to the enclosing block, file, or &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. If more than one variable is listed, the list must be placed in parentheses.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明列出的变量是本地（词汇）给封闭块，文件或 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 。如果列出了多个变量，则该列表必须放在括号中。</target>
        </trans-unit>
        <trans-unit id="4e47480cd5deac560f9564740a3fdd3588ea30d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=begin&lt;/code&gt; command was found that is not followed by the formatter specification.</source>
          <target state="translated">甲 &lt;code&gt;=begin&lt;/code&gt; 命令被发现没有随后由格式化规范。</target>
        </trans-unit>
        <trans-unit id="5a9827f3a3a35194fce6eb84ce82e990f6ef9b53" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=cut&lt;/code&gt; command was found without a preceding POD paragraph.</source>
          <target state="translated">甲 &lt;code&gt;=cut&lt;/code&gt; 命令被发现没有前述POD段落。</target>
        </trans-unit>
        <trans-unit id="4af95277282f9dbbdb980c39fe078720a20bab01" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=pod&lt;/code&gt; command was found after a preceding POD paragraph.</source>
          <target state="translated">甲 &lt;code&gt;=pod&lt;/code&gt; 命令前一段落POD后发现。</target>
        </trans-unit>
        <trans-unit id="31f4edd1c949bdbda291e425d6bef6044643ffd6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BEGIN&lt;/code&gt; code block is executed as soon as possible, that is, the moment it is completely defined, even before the rest of the containing file (or string) is parsed. You may have multiple &lt;code&gt;BEGIN&lt;/code&gt; blocks within a file (or eval'ed string); they will execute in order of definition. Because a &lt;code&gt;BEGIN&lt;/code&gt; code block executes immediately, it can pull in definitions of subroutines and such from other files in time to be visible to the rest of the compile and run time. Once a &lt;code&gt;BEGIN&lt;/code&gt; has run, it is immediately undefined and any code it used is returned to Perl's memory pool.</source>
          <target state="translated">一个 &lt;code&gt;BEGIN&lt;/code&gt; 代码块将尽快执行，即在完全定义它的那一刻开始执行，甚至在解析包含文件的其余部分（或字符串）之前也是如此。一个文件（或评估字符串）中可能有多个 &lt;code&gt;BEGIN&lt;/code&gt; 块；它们将按定义顺序执行。因为 &lt;code&gt;BEGIN&lt;/code&gt; 代码块可以立即执行，所以它可以及时从其他文件中提取子例程等的定义，以使其余的编译和运行时可见。 &lt;code&gt;BEGIN&lt;/code&gt; 一旦运行，便立即被取消定义，并将其使用的任何代码返回到Perl的内存池。</target>
        </trans-unit>
        <trans-unit id="3948c72682ed13a39df444bd90a131ad77b87fa0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;File::Fetch&lt;/code&gt; object has the following accessors</source>
          <target state="translated">一个 &lt;code&gt;File::Fetch&lt;/code&gt; 对象有下列访问</target>
        </trans-unit>
        <trans-unit id="a0df5f12010c9e2a341950853965986995045017" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MAYBE&lt;/code&gt; string should contain at least one combining character or the like. For example, &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; has the MAYBE_NFC/MAYBE_NFKC property.</source>
          <target state="translated">一个 &lt;code&gt;MAYBE&lt;/code&gt; 字符串应该至少包含一个组合字符等。例如， &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; ACUTE ACCENT具有MAYBE_NFC / MAYBE_NFKC属性。</target>
        </trans-unit>
        <trans-unit id="d9aa930129748b8e7f36983538600e4ef3003dd2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NUL&lt;/code&gt; character will be written after the end of the string.</source>
          <target state="translated">字符串末尾将写入一个 &lt;code&gt;NUL&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="14e49abd4463a2df704c3d0c251781f20f08e519" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;PerlIOl *&lt;/code&gt; is a pointer to the struct, and the</source>
          <target state="translated">甲 &lt;code&gt;PerlIOl *&lt;/code&gt; 是一个指向该结构，并且</target>
        </trans-unit>
        <trans-unit id="e73ed792e4d7284609d9e1372b30eccc321faca0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SelectSaver&lt;/code&gt; object contains a reference to the file handle that was selected when it was created. If its &lt;code&gt;new&lt;/code&gt; method gets an extra parameter, then that parameter is selected; otherwise, the selected file handle remains unchanged.</source>
          <target state="translated">甲 &lt;code&gt;SelectSaver&lt;/code&gt; 对象包含到它被创建时所选择的文件句柄的引用。如果其 &lt;code&gt;new&lt;/code&gt; 方法获得一个额外的参数，则选择该参数；否则，所选文件句柄将保持不变。</target>
        </trans-unit>
        <trans-unit id="57c30b7d6b5dae1d9e52bc3dfa57d215caf5d862" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;[&lt;/code&gt; is not special inside a character class, unless it's the start of a POSIX character class (see &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX Character Classes&lt;/a&gt; below). It normally does not need escaping.</source>
          <target state="translated">一 &lt;code&gt;[&lt;/code&gt; 是不是一个字符类中特殊的，除非它是一个POSIX字符类的开始（见&lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX字符类&lt;/a&gt;下文）。通常不需要转义。</target>
        </trans-unit>
        <trans-unit id="6776cbbe11f1658efaaee2f3dd38010bf8c93b32" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;\L&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; indicates a lasting conversion of case, until terminated by &lt;code&gt;\E&lt;/code&gt; or thrown over by another &lt;code&gt;\U&lt;/code&gt; or &lt;code&gt;\L&lt;/code&gt; :</source>
          <target state="translated">甲 &lt;code&gt;\L&lt;/code&gt; 或 &lt;code&gt;\U&lt;/code&gt; 表示箱子持久转换，直到通过终止 &lt;code&gt;\E&lt;/code&gt; 或通过另一扔过 &lt;code&gt;\U&lt;/code&gt; 或 &lt;code&gt;\L&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="eb525767ec147f71507ec3fe5c0bbfd43e23622a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;\w&lt;/code&gt; matches a single alphanumeric character (an alphabetic character, or a decimal digit); or a connecting punctuation character, such as an underscore (&quot;_&quot;); or a &quot;mark&quot; character (like some sort of accent) that attaches to one of those. It does not match a whole word. To match a whole word, use &lt;code&gt;\w+&lt;/code&gt; . This isn't the same thing as matching an English word, but in the ASCII range it is the same as a string of Perl-identifier characters.</source>
          <target state="translated">甲 &lt;code&gt;\w&lt;/code&gt; 匹配的单个字母数字字符（字母字符，或一个十进制数）; 或连接的标点字符，例如下划线（&amp;ldquo; _&amp;rdquo;）；或附加在其中一个字符上的&amp;ldquo;标记&amp;rdquo;字符（如某种重音符号）。它与整个单词不匹配。要匹配整个单词，请使用 &lt;code&gt;\w+&lt;/code&gt; 。这与匹配英语单词不同，但是在ASCII范围内，它与一串Perl标识符字符相同。</target>
        </trans-unit>
        <trans-unit id="387f0590ce374c162a12f59ad2a352b45a0b6a2e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;]&lt;/code&gt; is normally either the end of a POSIX character class (see &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX Character Classes&lt;/a&gt; below), or it signals the end of the bracketed character class. If you want to include a &lt;code&gt;]&lt;/code&gt; in the set of characters, you must generally escape it.</source>
          <target state="translated">甲 &lt;code&gt;]&lt;/code&gt; 通常是要么一个POSIX字符类的端部（参见&lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX字符类&lt;/a&gt;下文），或它标志着方括号内的字符类的末尾。如果要在字符集中包含 &lt;code&gt;]&lt;/code&gt; ，则通常必须对其进行转义。</target>
        </trans-unit>
        <trans-unit id="2a086836899301702e84e6ebfd5a64e6e1514ec1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;clean&lt;/code&gt; command results in a</source>
          <target state="translated">一个 &lt;code&gt;clean&lt;/code&gt; 命令导致</target>
        </trans-unit>
        <trans-unit id="f82e2956ae874578dae0b862a6205fc9ad9a10d8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;quiet&lt;/code&gt; parameter tells &lt;code&gt;CBuilder&lt;/code&gt; to not print its &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; commands before executing them:</source>
          <target state="translated">一个 &lt;code&gt;quiet&lt;/code&gt; 参数告诉 &lt;code&gt;CBuilder&lt;/code&gt; 在执行命令之前不打印其 &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="537fa0e7c3fc8f4f2ff13df46f07e5efa8b0d873" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;regexp_paren_pair&lt;/code&gt; structure which defines offsets into the string being matched which correspond to the &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; etc. captures, the &lt;code&gt;regexp_paren_pair&lt;/code&gt; struct is defined as follows:</source>
          <target state="translated">甲 &lt;code&gt;regexp_paren_pair&lt;/code&gt; 其限定的偏移到串结构相匹配，其对应于 &lt;code&gt;$&amp;amp;&lt;/code&gt; 及 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等捕获，所述 &lt;code&gt;regexp_paren_pair&lt;/code&gt; 结构定义如下：</target>
        </trans-unit>
        <trans-unit id="9187cecc86ed031f1a1d91cbbf85586329ad9482" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;typedef&lt;/code&gt; will be created for &lt;code&gt;struct netconfig&lt;/code&gt; . The Perl object will be blessed in a class matching the name of the C type, with the tag &lt;code&gt;Ptr&lt;/code&gt; appended, and the name should not have embedded spaces if it will be a Perl package name. The destructor will be placed in a class corresponding to the class of the object and the PREFIX keyword will be used to trim the name to the word DESTROY as Perl will expect.</source>
          <target state="translated">将为 &lt;code&gt;struct netconfig&lt;/code&gt; 创建一个 &lt;code&gt;typedef&lt;/code&gt; 。 Perl对象将在与C类型名称匹配的类中得到祝福，并附加标签 &lt;code&gt;Ptr&lt;/code&gt; ，并且如果该名称是Perl包名称，则该名称不应包含嵌入式空格。析构函数将放置在与对象的类相对应的类中，并且正如Perl期望的那样，将使用PREFIX关键字将名称修剪为DESTROY。</target>
        </trans-unit>
        <trans-unit id="91a29e0934f06be58e8f45f6ccaf516ef19ec003" translate="yes" xml:space="preserve">
          <source>A B::HV object representing the stash for 'our' variables.</source>
          <target state="translated">一个 B::HV 对象,代表 &quot;我们 &quot;变量的储藏库。</target>
        </trans-unit>
        <trans-unit id="f45e12c8a06cbfbc829397737665446dbd9373fc" translate="yes" xml:space="preserve">
          <source>A B::HV object representing the stash for a typed lexical.</source>
          <target state="translated">一个B::HV对象,表示一个类型化词汇的储藏库。</target>
        </trans-unit>
        <trans-unit id="42fcd5050adf426bbdb7192c3683fb606974ed22" translate="yes" xml:space="preserve">
          <source>A BLOCK by itself (labeled or not) is semantically equivalent to a loop that executes once. Thus you can use any of the loop control statements in it to leave or restart the block. (Note that this is</source>
          <target state="translated">一个BLOCK本身(无论是否有标签)在语义上等同于一个执行一次的循环。因此,你可以使用其中的任何一个循环控制语句来离开或重新启动该块。(注意,这是</target>
        </trans-unit>
        <trans-unit id="0b3fa7a6472c1947a3e3fb9a265bfaa097653d2a" translate="yes" xml:space="preserve">
          <source>A Build.PL is run by perl in a separate process. Likewise we run './Build' and './Build install' in separate processes. If you have any parameters you want to pass to the calls, please specify them here.</source>
          <target state="translated">Build.PL是由perl在一个单独的进程中运行的。同样的,我们也在单独的进程中运行'./Build'和'./Build install'。如果你有任何你想传递给调用的参数,请在这里指定它们。</target>
        </trans-unit>
        <trans-unit id="2b8f77588c05a56fb0aa83c01416be422180616b" translate="yes" xml:space="preserve">
          <source>A C expression for the value of the constant, or a list of C expressions if the type is aggregate. This defaults to the</source>
          <target state="translated">常量值的C表达式,如果类型为集合,则为C表达式的列表。默认情况下,该表达式为</target>
        </trans-unit>
        <trans-unit id="c9bca895b6521acf14049f748fb255c795b1e71c" translate="yes" xml:space="preserve">
          <source>A CASE: might switch via a parameter of the XSUB, via the &lt;code&gt;ix&lt;/code&gt; ALIAS: variable (see &lt;a href=&quot;#The-ALIAS%3a-Keyword&quot;&gt;The ALIAS: Keyword&lt;/a&gt;), or maybe via the &lt;code&gt;items&lt;/code&gt; variable (see &lt;a href=&quot;#Variable-length-Parameter-Lists&quot;&gt;Variable-length Parameter Lists&lt;/a&gt;). The last CASE: becomes the &lt;b&gt;default&lt;/b&gt; case if it is not associated with a conditional. The following example shows CASE switched via &lt;code&gt;ix&lt;/code&gt; with a function &lt;code&gt;rpcb_gettime()&lt;/code&gt; having an alias &lt;code&gt;x_gettime()&lt;/code&gt; . When the function is called as &lt;code&gt;rpcb_gettime()&lt;/code&gt; its parameters are the usual &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; , but when the function is called as &lt;code&gt;x_gettime()&lt;/code&gt; its parameters are reversed, &lt;code&gt;(time_t *timep, char *host)&lt;/code&gt; .</source>
          <target state="translated">一个CASE：可能通过XSUB的参数，通过 &lt;code&gt;ix&lt;/code&gt; ALIAS：变量（请参阅&lt;a href=&quot;#The-ALIAS%3a-Keyword&quot;&gt;ALIAS：Keyword&lt;/a&gt;）或通过 &lt;code&gt;items&lt;/code&gt; 变量（请参见&lt;a href=&quot;#Variable-length-Parameter-Lists&quot;&gt;可变长度参数列表&lt;/a&gt;）进行切换。如果不与条件关联，则最后一个CASE：成为&lt;b&gt;默认&lt;/b&gt;情况。下面的示例示出了通过CASE切换 &lt;code&gt;ix&lt;/code&gt; 与函数 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 具有一个别名 &lt;code&gt;x_gettime()&lt;/code&gt; 。当函数被称为 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 时,其参数是通常的 &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; ，但是当函数被称为 &lt;code&gt;x_gettime()&lt;/code&gt; 时,其参数被反转， &lt;code&gt;(time_t *timep, char *host)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c55f978db59708209a54d8bfb17d98c3ae019b46" translate="yes" xml:space="preserve">
          <source>A CPAN mirror that includes just the latest versions for each distribution, probably created with &lt;code&gt;CPAN::Mini&lt;/code&gt; . See Camel chapter 19, &amp;ldquo;CPAN&amp;rdquo;.</source>
          <target state="translated">一个CPAN镜像，其中仅包括每个发行版的最新版本，可能是使用 &lt;code&gt;CPAN::Mini&lt;/code&gt; 创建的。请参阅骆驼第19章&amp;ldquo; CPAN&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d79fea87c96ec94013ff8e4540cf4e641c3aa0b8" translate="yes" xml:space="preserve">
          <source>A Class is Simply a Package</source>
          <target state="translated">一个班级只是一个套餐</target>
        </trans-unit>
        <trans-unit id="59bd5b6c5b1f4d50bad57e4bae0c86bf7e63ff03" translate="yes" xml:space="preserve">
          <source>A Complete Example</source>
          <target state="translated">一个完整的例子</target>
        </trans-unit>
        <trans-unit id="9f22eaf2aa717bb5924e306e9ab40bd24eefc92a" translate="yes" xml:space="preserve">
          <source>A DBM Filter allows the keys and/or values in a tied hash to be modified by some user-defined code just before it is written to the DBM file and just after it is read back from the DBM file. For example, this snippet of code</source>
          <target state="translated">一个DBM过滤器允许在一个绑定哈希中的键和/或值在写入DBM文件之前和从DBM文件读回之后被一些用户定义的代码修改。例如,这段代码</target>
        </trans-unit>
        <trans-unit id="a3dd10dc1183e2df3ed7ea791b7d9b7560ba9d95" translate="yes" xml:space="preserve">
          <source>A DBM Filter is a piece of code that is be used when you</source>
          <target state="translated">DBM过滤器是一段代码,它在你的</target>
        </trans-unit>
        <trans-unit id="74127e4dc0844d9e1d0d37669c77b5e1d7d7dc1c" translate="yes" xml:space="preserve">
          <source>A GV is a structure which corresponds to to a Perl typeglob, ie *foo. It is a structure that holds a pointer to a scalar, an array, a hash etc, corresponding to $foo, @foo, %foo.</source>
          <target state="translated">GV 是一个对应于 Perl typeglob 的结构,即 *foo。它是一个持有指向标量、数组、哈希等的指针的结构,对应于 $foo、@foo、%foo。</target>
        </trans-unit>
        <trans-unit id="13db893228041bbd750755e5ceeab1edf73eb3b3" translate="yes" xml:space="preserve">
          <source>A Graeco-Roman word meaning &amp;ldquo;to bring oneself to life&amp;rdquo;. In Perl, storage locations (&lt;b&gt;lvalues&lt;/b&gt;) spontaneously generate themselves as needed, including the creation of any &lt;b&gt;hard reference&lt;/b&gt; values to point to the next level of storage. The assignment &lt;code&gt;$a[5][5][5][5][5] = &quot;quintet&quot;&lt;/code&gt; potentially creates five scalar storage locations, plus four references (in the first four scalar locations) pointing to four new anonymous arrays (to hold the last four scalar locations). But the point of autovivification is that you don&amp;rsquo;t have to worry about it.</source>
          <target state="translated">Graeco-Roman（希腊罗马字母）一词，意思是&amp;ldquo;使自己栩栩如生&amp;rdquo;。在Perl中，存储位置（&lt;b&gt;lvalues&lt;/b&gt;）会根据需要自动生成自身，包括创建任何&lt;b&gt;硬参考&lt;/b&gt;值以指向下一个存储级别。赋值 &lt;code&gt;$a[5][5][5][5][5] = &quot;quintet&quot;&lt;/code&gt; 可能会创建五个标量存储位置，外加指向四个新匿名数组（以保留）的四个引用（在前四个标量位置）最后四个标量位置）。但是，自动生存的关键是您不必为此担心。</target>
        </trans-unit>
        <trans-unit id="644fba68887f0f6c83a3c9ad6b03efeafe64485f" translate="yes" xml:space="preserve">
          <source>A HV structure represents a Perl hash. It consists mainly of an array of pointers, each of which points to a linked list of HE structures. The array is indexed by the hash function of the key, so each linked list represents all the hash entries with the same hash value. Each HE contains a pointer to the actual value, plus a pointer to a HEK structure which holds the key and hash value.</source>
          <target state="translated">一个HV结构表示一个Perl哈希。它主要由一个指针数组组成,每个指针指向一个HE结构的链接列表。数组以键的哈希函数为索引,因此每个链接列表代表所有具有相同哈希值的哈希条目。每个HE都包含一个指向实际值的指针,加上一个指向HEK结构的指针,HEK结构持有密钥和哈希值。</target>
        </trans-unit>
        <trans-unit id="01232ff6c4ca9ea380827b743047b1207b0966c9" translate="yes" xml:space="preserve">
          <source>A Method is Simply a Subroutine</source>
          <target state="translated">方法只是一个子程序</target>
        </trans-unit>
        <trans-unit id="4fc1e89e0ebaf9800ac39a369b83b7a80fc77ec4" translate="yes" xml:space="preserve">
          <source>A Note about the Examples</source>
          <target state="translated">关于例子的说明</target>
        </trans-unit>
        <trans-unit id="0d72d9979807c702328842043bb2529c640d1c5d" translate="yes" xml:space="preserve">
          <source>A Notify parameter of 'DELAY' &quot;indicates the sender's willingness to receive delayed DSNs. Delayed DSNs may be issued if delivery of a message has been delayed for an unusual amount of time (as determined by the Message Transfer Agent (MTA) at which the message is delayed), but the final delivery status (whether successful or failure) cannot be determined. The absence of the DELAY keyword in a NOTIFY parameter requests that a &quot;delayed&quot; DSN NOT be issued under any conditions.&quot;</source>
          <target state="translated">通知参数'DELAY'&quot;表示发送方愿意接收延迟的DSN。如果消息的传递被延迟了不寻常的时间(由消息传输代理(MTA)决定),但最终的传递状态(是成功还是失败)无法确定,则可以发出延迟DSN。NOTIFY参数中如果没有DELAY关键字,则要求在任何条件下都不发出 &quot;延迟 &quot;的DSN。&quot;</target>
        </trans-unit>
        <trans-unit id="9dbcef065eab9753a6c0d2e89dd406c9f007951b" translate="yes" xml:space="preserve">
          <source>A Notify parameter of 'SUCCESS' or 'FAILURE' &quot;requests that a DSN be issued on successful delivery or delivery failure, respectively.&quot;</source>
          <target state="translated">'SUCCESS'或'FAILURE'的Notify参数 &quot;分别请求在成功交付或交付失败时发出DSN&quot;。</target>
        </trans-unit>
        <trans-unit id="c3f40c0f83e1e526b0b0b6c66a8b36e802555138" translate="yes" xml:space="preserve">
          <source>A Perl extension to the POSIX character class is the ability to negate it. This is done by prefixing the class name with a caret (&lt;code&gt;^&lt;/code&gt;). Some examples:</source>
          <target state="translated">对POSIX字符类的Perl扩展是否定它的能力。这是通过在类名前面加上插入符号（ &lt;code&gt;^&lt;/code&gt; ）来完成的。一些例子：</target>
        </trans-unit>
        <trans-unit id="0d2d7129fe49ff692643bf989abc3c8db9550c7a" translate="yes" xml:space="preserve">
          <source>A Perl floating point number. Similar to T_IV and T_UV in that the return type is cast to the requested numeric type rather than to a specific type.</source>
          <target state="translated">一个Perl浮点数。类似于T_IV和T_UV,返回类型是投向所要求的数值类型,而不是投向特定的类型。</target>
        </trans-unit>
        <trans-unit id="baf019a8a8ab4371dcf7bafbfc9ccbe01c8c24c2" translate="yes" xml:space="preserve">
          <source>A Perl module that also pulls in &lt;b&gt;compiled&lt;/b&gt; C or C++ code. More generally, any experimental option that can be &lt;b&gt;compiled&lt;/b&gt; into Perl, such as multithreading.</source>
          <target state="translated">一个Perl模块，也引入已&lt;b&gt;编译的&lt;/b&gt; C或C ++代码。更一般而言，可以&lt;b&gt;编译&lt;/b&gt;到Perl中的任何实验性选项，例如多线程。</target>
        </trans-unit>
        <trans-unit id="d50862820d3a8aab33b93133b7d33cb935834ef5" translate="yes" xml:space="preserve">
          <source>A Perl pattern that allows the disambiguation of long and short prefixes. Default is &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">一种Perl模式，可以消除长前缀和短前缀的歧义。默认值为 &lt;code&gt;--&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e904ead9b94d6204fd6b39a939871c992e738f5" translate="yes" xml:space="preserve">
          <source>A Perl pattern that identifies the strings that introduce options. Default is &lt;code&gt;--|-|\+&lt;/code&gt; unless environment variable POSIXLY_CORRECT has been set, in which case it is &lt;code&gt;--|-&lt;/code&gt;.</source>
          <target state="translated">一个Perl模式，标识引入选项的字符串。除非设置了环境变量POSIXLY_CORRECT，否则默认值为 &lt;code&gt;--|-|\+&lt;/code&gt; ，在这种情况下为 &lt;code&gt;--|-&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45c72c917209e7e654e9e53f35f4bca27fd858cf" translate="yes" xml:space="preserve">
          <source>A Perl program consists of a sequence of declarations and statements which run from the top to the bottom. Loops, subroutines, and other control structures allow you to jump around within the code.</source>
          <target state="translated">一个Perl程序由一连串的声明和语句组成,这些声明和语句从上到下运行。循环、子程序和其他控制结构允许你在代码中跳转。</target>
        </trans-unit>
        <trans-unit id="8f1d991ccec8e09953b3e8579dace5ef70ea0563" translate="yes" xml:space="preserve">
          <source>A Perl program executes only once, not once for each input line. You can do an implicit loop with &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; .</source>
          <target state="translated">Perl程序仅执行一次，而不是对每个输入行执行一次。您可以使用 &lt;code&gt;-n&lt;/code&gt; 或 &lt;code&gt;-p&lt;/code&gt; 进行隐式循环。</target>
        </trans-unit>
        <trans-unit id="b05351cbee8badd4677882f72f83a69a3c04e972" translate="yes" xml:space="preserve">
          <source>A Perl program to do these tasks takes the basic form of opening a file, printing its lines, then closing the file:</source>
          <target state="translated">一个Perl程序来完成这些任务的基本形式是打开一个文件,打印它的行,然后关闭文件。</target>
        </trans-unit>
        <trans-unit id="9f85dbe5a418fb4bcdecb47b2f0b2cac2a377668" translate="yes" xml:space="preserve">
          <source>A Perl script or program consists of one or more statements. These statements are simply written in the script in a straightforward fashion. There is no need to have a &lt;code&gt;main()&lt;/code&gt; function or anything of that kind.</source>
          <target state="translated">Perl脚本或程序由一个或多个语句组成。这些语句以简单的方式简单地写在脚本中。不需要 &lt;code&gt;main()&lt;/code&gt; 函数或任何此类函数。</target>
        </trans-unit>
        <trans-unit id="ab689318c03ebde720ae51176a11effea3a569dc" translate="yes" xml:space="preserve">
          <source>A Perl user group, taking the form of its name from the New York Perl mongers, the first Perl user group. Find one near you at &lt;a href=&quot;http://www.pm.org&quot;&gt;http://www.pm.org&lt;/a&gt;.</source>
          <target state="translated">一个Perl用户组，其名称形式来自第一个Perl用户组New York Perl商人。在&lt;a href=&quot;http://www.pm.org&quot;&gt;http://www.pm.org上&lt;/a&gt;找到您附近的人。</target>
        </trans-unit>
        <trans-unit id="eefc3e21c06e6017f8c10a8bb69ea540ab281b02" translate="yes" xml:space="preserve">
          <source>A Pod formatter may also note, in a comment or warning, a list of what unrenderable characters were encountered.</source>
          <target state="translated">Pod格式化器还可以在注释或警告中注明遇到了哪些不可渲染的字符。</target>
        </trans-unit>
        <trans-unit id="90bcd0d55b890352044335ec7ff338d09cd4b9d1" translate="yes" xml:space="preserve">
          <source>A Pod processor may signal that the above (specifically the &quot;=head1&quot; paragraph) is an error. Note, however, that the following should</source>
          <target state="translated">花苞处理器可能会发出信号,说明上述(特别是&quot;=head1 &quot;段)是一个错误。但请注意,以下内容应该是</target>
        </trans-unit>
        <trans-unit id="185a19a7a82d49a0358676fb031bca8138fc5f0d" translate="yes" xml:space="preserve">
          <source>A Rename script</source>
          <target state="translated">重命名脚本</target>
        </trans-unit>
        <trans-unit id="bb0e1d56b4fab0cf7a60aa29b48524e0458e7730" translate="yes" xml:space="preserve">
          <source>A Simple Client</source>
          <target state="translated">一个简单的客户端</target>
        </trans-unit>
        <trans-unit id="b671ac0d028246c423146116e7e15964cde16b69" translate="yes" xml:space="preserve">
          <source>A Simple Example</source>
          <target state="translated">一个简单的例子</target>
        </trans-unit>
        <trans-unit id="35d2688dd60f4771865d489a975386b1e2e85efc" translate="yes" xml:space="preserve">
          <source>A Social Contract about Artistic Control</source>
          <target state="translated">关于艺术控制的社会契约</target>
        </trans-unit>
        <trans-unit id="ce9f49f53bf8557e68c16a6cb0cab50ed319c852" translate="yes" xml:space="preserve">
          <source>A Solution</source>
          <target state="translated">解决方案</target>
        </trans-unit>
        <trans-unit id="33b832366f848ffdd1c9a8efe9f8d3f20e39c539" translate="yes" xml:space="preserve">
          <source>A TAP</source>
          <target state="translated">A TAP</target>
        </trans-unit>
        <trans-unit id="f5889f236a4188d2629daf331b9d72acfd600c43" translate="yes" xml:space="preserve">
          <source>A TAP parser consumes input from a single</source>
          <target state="translated">TAP解析器消耗来自单一的</target>
        </trans-unit>
        <trans-unit id="7010880f6ae20816985e9d146f66cebdc5b3456f" translate="yes" xml:space="preserve">
          <source>A TAP parser creates &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt;s as it iterates through the input</source>
          <target state="translated">TAP解析器在遍历输入时创建&lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cbc0d3fb42afd0ba8dd15a85a63c440071f45982" translate="yes" xml:space="preserve">
          <source>A TAP parser uses</source>
          <target state="translated">TAP解析器使用</target>
        </trans-unit>
        <trans-unit id="c7adba530805a495085a55a74870dea40f6e16bc" translate="yes" xml:space="preserve">
          <source>A TAP source &amp;amp; meta data about it</source>
          <target state="translated">TAP源和有关它的元数据</target>
        </trans-unit>
        <trans-unit id="92ce2bc3533d042b851a960d43bdd7c40fb70ee1" translate="yes" xml:space="preserve">
          <source>A TERM has the highest precedence in Perl. They include variables, quote and quote-like operators, any expression in parentheses, and any function whose arguments are parenthesized. Actually, there aren't really functions in this sense, just list operators and unary operators behaving as functions because you put parentheses around the arguments. These are all documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">TERM在Perl中具有最高优先级。它们包括变量，加引号和类似引号的运算符，括号中的任何表达式以及带括号的参数的任何函数。实际上，从这个意义上说，并没有真正的函数，只是列表运算符和一元运算符表现为函数，因为您在参数周围加上了括号。这些都记录在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83c2c3a67955f622ae2a621c93e51552fb8bf822" translate="yes" xml:space="preserve">
          <source>A Thread Pitfall: Deadlocks</source>
          <target state="translated">一个线程陷阱。僵局</target>
        </trans-unit>
        <trans-unit id="54dda450dbc946f563a52bcd0e2371c672a57c0d" translate="yes" xml:space="preserve">
          <source>A UCM file looks like this.</source>
          <target state="translated">UCM文件是这样的。</target>
        </trans-unit>
        <trans-unit id="311a8f73aa0632dde20a979ee931fae45488ea90" translate="yes" xml:space="preserve">
          <source>A Unicode</source>
          <target state="translated">一个Unicode</target>
        </trans-unit>
        <trans-unit id="636617240302996a8f020159cb2e15c959a81dd5" translate="yes" xml:space="preserve">
          <source>A Unicode boundary (&lt;code&gt;\b{}&lt;/code&gt; ), available starting in v5.22, is a spot between two characters, or before the first character in the string, or after the final character in the string where certain criteria defined by Unicode are met. See &lt;a href=&quot;perlrebackslash#%5cb%7b%7d%2c-%5cb%2c-%5cB%7b%7d%2c-%5cB&quot;&gt;\b{}, \b, \B{}, \B in perlrebackslash&lt;/a&gt; for details.</source>
          <target state="translated">从v5.22开始可用的Unicode边界（ &lt;code&gt;\b{}&lt;/code&gt; ）是两个字符之间，字符串中第一个字符之前，字符串中最后一个字符之后，满足Unicode定义的某些条件的位置。见&lt;a href=&quot;perlrebackslash#%5cb%7b%7d%2c-%5cb%2c-%5cB%7b%7d%2c-%5cB&quot;&gt;\ B {}，\ B，\ B {}，\乙在perlrebackslash&lt;/a&gt;的详细信息。</target>
        </trans-unit>
        <trans-unit id="fd6ccb5c3173a4892e5e2944faba0f70f7b55ac3" translate="yes" xml:space="preserve">
          <source>A Unicode linebreak matches the two-character CRLF grapheme or any of seven vertical whitespace characters. Good for dealing with textfiles coming from different operating systems.</source>
          <target state="translated">Unicode换行符与两个字符的CRLF字符或七个垂直空白字符中的任何一个相匹配。适用于处理来自不同操作系统的文本文件。</target>
        </trans-unit>
        <trans-unit id="d796a3e99a29b5e8798e5ee8787d53dec284ccde" translate="yes" xml:space="preserve">
          <source>A Webget Client</source>
          <target state="translated">一个Webget客户端</target>
        </trans-unit>
        <trans-unit id="625ef9e7e1c1fa35b033333425cc32cf0c3ed6bf" translate="yes" xml:space="preserve">
          <source>A backslash sequence is a sequence of characters, the first one of which is a backslash. Perl ascribes special meaning to many such sequences, and some of these are character classes. That is, they match a single character each, provided that the character belongs to the specific set of characters defined by the sequence.</source>
          <target state="translated">反斜线序列是一个字符序列,其中第一个是反斜线。Perl 给许多这样的序列赋予了特殊的含义,其中有些序列是字符类。也就是说,它们各自匹配一个字符,只要该字符属于序列所定义的特定字符集。</target>
        </trans-unit>
        <trans-unit id="0a7351fee5999f66ec79553b15a43f5d86c41d6e" translate="yes" xml:space="preserve">
          <source>A backward-compatibility alias for TYPE.</source>
          <target state="translated">TYPE的一个向后兼容的别名。</target>
        </trans-unit>
        <trans-unit id="f7fb814e1c2c79d0e734419e57ea9495c267d50e" translate="yes" xml:space="preserve">
          <source>A backward-compatible version of &lt;code&gt;GIMME_V&lt;/code&gt; which can only return &lt;code&gt;G_SCALAR&lt;/code&gt; or &lt;code&gt;G_ARRAY&lt;/code&gt; ; in a void context, it returns &lt;code&gt;G_SCALAR&lt;/code&gt; . Deprecated. Use &lt;code&gt;GIMME_V&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;GIMME_V&lt;/code&gt; 的向后兼容版本，只能返回 &lt;code&gt;G_SCALAR&lt;/code&gt; 或 &lt;code&gt;G_ARRAY&lt;/code&gt; ；在无效上下文中，它返回 &lt;code&gt;G_SCALAR&lt;/code&gt; 。不推荐使用。请改用 &lt;code&gt;GIMME_V&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="825d3b4cdbdd793ff6bcae81fea3eedc9476aefd" translate="yes" xml:space="preserve">
          <source>A bare declaration like that declares the function to be a list operator, not a unary operator, so you have to be careful to use parentheses (or &lt;code&gt;or&lt;/code&gt; instead of &lt;code&gt;||&lt;/code&gt;.) The &lt;code&gt;||&lt;/code&gt; operator binds too tightly to use after list operators; it becomes part of the last element. You can always use parentheses around the list operators arguments to turn the list operator back into something that behaves more like a function call. Alternatively, you can use the prototype &lt;code&gt;($)&lt;/code&gt; to turn the subroutine into a unary operator:</source>
          <target state="translated">像那样的裸声明声明函数是一个列表操作符，而不是一元运算符，所以你必须要小心使用括号（或 &lt;code&gt;or&lt;/code&gt; 代替 &lt;code&gt;||&lt;/code&gt; ）的 &lt;code&gt;||&lt;/code&gt; 操作符绑定太紧，无法在列表操作符之后使用；它成为最后一个元素的一部分。您始终可以在列表运算符参数周围使用括号，以将列表运算符重新转换为更类似于函数调用的行为。另外，您可以使用原型 &lt;code&gt;($)&lt;/code&gt; 将子例程转换为一元运算符：</target>
        </trans-unit>
        <trans-unit id="79d7fc67720af71225bb992fc841089461a260dd" translate="yes" xml:space="preserve">
          <source>A bare, single &lt;b&gt;statement&lt;/b&gt;, without any braces, hanging off an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; conditional. C allows them. Perl doesn&amp;rsquo;t.</source>
          <target state="translated">裸露的，单一的&lt;b&gt;声明&lt;/b&gt;，没有任何括号，挂了一个 &lt;code&gt;if&lt;/code&gt; 或 &lt;code&gt;while&lt;/code&gt; 条件。C允许他们。Perl没有。</target>
        </trans-unit>
        <trans-unit id="7c021cbe956d43771e93a19ff22791f5da1edc86" translate="yes" xml:space="preserve">
          <source>A basic building block. When you&amp;rsquo;re talking about an &lt;b&gt;array&lt;/b&gt;, it&amp;rsquo;s one of the items that make up the array.</source>
          <target state="translated">一个基本的构建块。当您谈论&lt;b&gt;数组时&lt;/b&gt;，它是构成&lt;b&gt;数组&lt;/b&gt;的项目之一。</target>
        </trans-unit>
        <trans-unit id="dc24770c94125e3eea533d29f62a33f6fca11b44" translate="yes" xml:space="preserve">
          <source>A basic example</source>
          <target state="translated">一个基本的例子</target>
        </trans-unit>
        <trans-unit id="f7282a24ce95eed40d8f1f24671950459bbf71d8" translate="yes" xml:space="preserve">
          <source>A basic non-buffered layer which calls Unix/POSIX &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;lseek()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;. No buffering. Even on platforms that distinguish between O_TEXT and O_BINARY this layer is always O_BINARY.</source>
          <target state="translated">一个基本的非缓冲层，它调用Unix / POSIX &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;lseek()&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 。没有缓冲。即使在区分O_TEXT和O_BINARY的平台上，该层也始终是O_BINARY。</target>
        </trans-unit>
        <trans-unit id="3269aa1ef3bfcd123309b115096aa27b3b0a0aa8" translate="yes" xml:space="preserve">
          <source>A bigger, fancier sort of &lt;b&gt;program&lt;/b&gt; with a fancier name so people don&amp;rsquo;t realize they are using a program.</source>
          <target state="translated">一个更大，更高级的&lt;b&gt;程序&lt;/b&gt;，名称更高级，所以人们不会意识到自己正在使用程序。</target>
        </trans-unit>
        <trans-unit id="1395a44d1527cd51acf9f72e88e221dc5e7a43dc" translate="yes" xml:space="preserve">
          <source>A binary search such as that provided by &lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist()&lt;/a&gt;, can be used to quickly find a code point in the inversion list, and hence its corresponding mapping.</source>
          <target state="translated">诸如&lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist（）&lt;/a&gt;提供的二进制搜索之类的二进制搜索可用于快速在反演列表中找到一个代码点，从而找到其对应的映射。</target>
        </trans-unit>
        <trans-unit id="a3982f0643b548a46d27f9bb45d706ffed3877fd" translate="yes" xml:space="preserve">
          <source>A bit of magic: executing Perl code in a regular expression</source>
          <target state="translated">有点神奇:用正则表达式执行Perl代码</target>
        </trans-unit>
        <trans-unit id="a21b7a38b7737dbecfe5abeb569d1f5e67680088" translate="yes" xml:space="preserve">
          <source>A bitfield containing &lt;code&gt;AI_*&lt;/code&gt; constants; see below.</source>
          <target state="translated">包含 &lt;code&gt;AI_*&lt;/code&gt; 常量的位域；见下文。</target>
        </trans-unit>
        <trans-unit id="5315c3bf863fe0d813794db09004e209616806a3" translate="yes" xml:space="preserve">
          <source>A bolt out of the blue; that is, an event triggered by the &lt;b&gt;operating system&lt;/b&gt;, probably when you&amp;rsquo;re least expecting it.</source>
          <target state="translated">螺栓掉了出来；也就是说，由&lt;b&gt;操作系统&lt;/b&gt;触发的事件，可能是您最不期望的事件。</target>
        </trans-unit>
        <trans-unit id="37f6985b23fa2a35e2960a3080f908d1bc2f10c9" translate="yes" xml:space="preserve">
          <source>A boolean comparison operator such as &lt;code&gt;$_ &amp;lt; 10&lt;/code&gt; or &lt;code&gt;$x eq &quot;abc&quot;&lt;/code&gt; . The relational operators that this applies to are the six numeric comparisons (&lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; , and &lt;code&gt;!=&lt;/code&gt; ), and the six string comparisons (&lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; , and &lt;code&gt;ne&lt;/code&gt; ).</source>
          <target state="translated">布尔比较运算符，例如 &lt;code&gt;$_ &amp;lt; 10&lt;/code&gt; 或 &lt;code&gt;$x eq &quot;abc&quot;&lt;/code&gt; 。适用于此的关系运算符是六个数字比较（ &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; ， &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; ）和六个字符串比较（ &lt;code&gt;lt&lt;/code&gt; ， &lt;code&gt;gt&lt;/code&gt; ， &lt;code&gt;le&lt;/code&gt; ， &lt;code&gt;ge&lt;/code&gt; ， &lt;code&gt;eq&lt;/code&gt; 和 &lt;code&gt;ne&lt;/code&gt; ） 。</target>
        </trans-unit>
        <trans-unit id="5784bf453d1712122e0236fafc88e209e3c6adfe" translate="yes" xml:space="preserve">
          <source>A boolean flag that indicates if this argument was a required argument. If marked as required and not provided, check() will fail.</source>
          <target state="translated">一个布尔标志,表示这个参数是否为必填参数。如果标记为必填参数而没有提供,check()将失败。</target>
        </trans-unit>
        <trans-unit id="806d4e84607ce29c56416e6b774c66e8a0e936b0" translate="yes" xml:space="preserve">
          <source>A boolean to indicate whether &lt;code&gt;check&lt;/code&gt; should be verbose and warn about what went wrong in a check or not.</source>
          <target state="translated">一个布尔值，指示 &lt;code&gt;check&lt;/code&gt; 是否应冗长，并警告支票出了什么问题。</target>
        </trans-unit>
        <trans-unit id="75de768f80b992cf9735e1b55771968cbd72780f" translate="yes" xml:space="preserve">
          <source>A boolean type. This can be used to pass true and false values to and from C.</source>
          <target state="translated">一个布尔类型。它可以用来向C语言传递真值和假值。</target>
        </trans-unit>
        <trans-unit id="aaea9ae3f33d9df07a73532337b752e2bd4004dd" translate="yes" xml:space="preserve">
          <source>A boolean value indicating whether or not the module was found to be at least the version you specified. If you did not specify a version, uptodate will always be true if the module was found. If no parsable version was found in the module, uptodate will also be true, since &lt;code&gt;check_install&lt;/code&gt; had no way to verify clearly.</source>
          <target state="translated">一个布尔值，指示是否发现该模块至少是您指定的版本。如果未指定版本，则在找到模块时uptodate始终为true。如果在模块中未找到可解析的版本，则 &lt;code&gt;check_install&lt;/code&gt; 也将为true，因为check_install无法清楚地进行验证。</target>
        </trans-unit>
        <trans-unit id="f4da841a146cb38a789f449f32f4b854b9d0c640" translate="yes" xml:space="preserve">
          <source>A built-in unary operator that you use to determine whether something is &lt;b&gt;true&lt;/b&gt; about a file, such as &lt;code&gt;&amp;ndash;o
$filename&lt;/code&gt; to test whether you&amp;rsquo;re the owner of the file.</source>
          <target state="translated">一个内置的一元运算符，用于确定某个文件是否&lt;b&gt;正确&lt;/b&gt;，例如 &lt;code&gt;&amp;ndash;o $filename&lt;/code&gt; 以测试您是否是该文件的所有者。</target>
        </trans-unit>
        <trans-unit id="7359d066cd43a6821cadbf98e46de3780a2f14da" translate="yes" xml:space="preserve">
          <source>A bundle is just a perl module in the namespace Bundle:: that does not define any functions or methods. It usually only contains documentation.</source>
          <target state="translated">bundle只是命名空间Bundle::中的一个perl模块,它不定义任何函数或方法。它通常只包含文档。</target>
        </trans-unit>
        <trans-unit id="dcefaccadd4fc0b82966dd6fe0502b4a54a13075" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&lt;/a&gt; must have been made to declare at compile time a private variable used by this macro and the two &lt;code&gt;STORE&lt;/code&gt; ones. This macro should be called as a single statement, not an expression, but with an empty argument list, like this:</source>
          <target state="translated">必须对&lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;DECLARATION_FOR_LC_NUMERIC_MANIPULATION进行&lt;/a&gt;调用，以在编译时声明此宏和两个 &lt;code&gt;STORE&lt;/code&gt; 所使用的私有变量。该宏应作为单个语句而不是表达式来调用，但应具有一个空的参数列表，如下所示：</target>
        </trans-unit>
        <trans-unit id="85dcd887c15b971af653f15a54e47c2790e7a16c" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&lt;/a&gt; must have been made to declare at compile time a private variable used by this macro. This macro should be called as a single statement, not an expression, but with an empty argument list, like this:</source>
          <target state="translated">必须已调用&lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&lt;/a&gt;，以在编译时声明此宏使用的私有变量。该宏应作为单个语句而不是表达式来调用，但应具有一个空的参数列表，如下所示：</target>
        </trans-unit>
        <trans-unit id="6d081cdfc1719628de161b242cc46c6122417557" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will cause Perl to exit, and to invoke the command given as an argument to &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; via &lt;code&gt;lib$do_command&lt;/code&gt; . If the argument begins with '@' or '$' (other than as part of a filespec), then it is executed as a DCL command. Otherwise, the first token on the command line is treated as the filespec of an image to run, and an attempt is made to invoke it (using</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 将导致Perl退出，并通过 &lt;code&gt;lib$do_command&lt;/code&gt; 调用作为 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 参数提供的命令。如果参数以'@'或'$'开头（不是作为文件规范的一部分），则它将作为DCL命令执行。否则，将命令行上的第一个标记视为要运行的图像的文件规范，并尝试调用它（使用</target>
        </trans-unit>
        <trans-unit id="9b1310b4d6c00ffc23a2f0bae5e7870ed9e6ede4" translate="yes" xml:space="preserve">
          <source>A character class is a way of denoting a set of characters in such a way that one character of the set is matched. It's important to remember that: matching a character class consumes exactly one character in the source string. (The source string is the string the regular expression is matched against.)</source>
          <target state="translated">字符类是一种表示字符集的方式,以匹配该字符集的一个字符。重要的是要记住:匹配一个字符类正好消耗源字符串中的一个字符。源字符串就是正则表达式所匹配的字符串)。</target>
        </trans-unit>
        <trans-unit id="2d7e4b0e3a328dba3c81ba02d01a3c0f782c72a5" translate="yes" xml:space="preserve">
          <source>A character encoding form plus byte serialization. There are Seven character encoding schemes in Unicode: UTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32 (UCS-4), UTF-32BE (UCS-4BE) and UTF-32LE (UCS-4LE), and UTF-7.</source>
          <target state="translated">一种字符编码形式加上字节序列化。在Unicode中,有七种字符编码方案。UTF-8、UTF-16、UTF-16BE、UTF-16LE、UTF-32(UCS-4)、UTF-32BE(UCS-4BE)和UTF-32LE(UCS-4LE),以及UTF-7。</target>
        </trans-unit>
        <trans-unit id="e2b2859306209b5e788c7205519699be5962c3a1" translate="yes" xml:space="preserve">
          <source>A character entity was found that does not belong to the standard ISO set or the POD specials &lt;code&gt;verbar&lt;/code&gt; and &lt;code&gt;sol&lt;/code&gt; .</source>
          <target state="translated">发现一个字符实体，该字符实体不属于标准ISO集合或POD特殊 &lt;code&gt;verbar&lt;/code&gt; 和 &lt;code&gt;sol&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b3facef3525988e61e4c03673d831959bbb24fc" translate="yes" xml:space="preserve">
          <source>A character in the range 0 .. 2**32-1 (or more); what Perl's strings are made of.</source>
          <target state="translated">0 ...2**32-1 (或更多)范围内的字符;Perl的字符串就是由这些字符组成的。</target>
        </trans-unit>
        <trans-unit id="4c66dbdd31c41ff8290d5b9e5b84c42f44091393" translate="yes" xml:space="preserve">
          <source>A character in the range 0..255; a special case of a Perl character.</source>
          <target state="translated">范围为0...255的字符;Perl字符的一种特殊情况。</target>
        </trans-unit>
        <trans-unit id="deb99f697e889e229888732646e1d9a4b2cd77a6" translate="yes" xml:space="preserve">
          <source>A character range may be specified with a hyphen, so &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/A-J/0-9/&lt;/a&gt;&lt;/code&gt; does the same replacement as &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/ACEGIBDFHJ/0246813579/&lt;/a&gt;&lt;/code&gt;. For &lt;b&gt;sed&lt;/b&gt; devotees, &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; is provided as a synonym for &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;. If the</source>
          <target state="translated">字符范围可以用连字符指定，因此 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/A-J/0-9/&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/ACEGIBDFHJ/0246813579/&lt;/a&gt;&lt;/code&gt; 了相同的替换。对于&lt;b&gt;sed的&lt;/b&gt;奉献者， &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 的同义词。如果</target>
        </trans-unit>
        <trans-unit id="62e5445beeff56a35c0dc5ca65bde86d53c27ebb" translate="yes" xml:space="preserve">
          <source>A character set comprising all the major character sets of the world, more or less. See &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;.</source>
          <target state="translated">一个或多或少包含世界上所有主要字符集的字符集。参见&lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c07be0779b2376c619d1a65316d136daa5c26ab" translate="yes" xml:space="preserve">
          <source>A character symbolizing the type of IO Handle.</source>
          <target state="translated">一个象征IO手柄类型的字符。</target>
        </trans-unit>
        <trans-unit id="ad2f4627442f7e9e5cdd45c11902cca0d8325c3b" translate="yes" xml:space="preserve">
          <source>A character with the numeric value of zero. It&amp;rsquo;s used by C to terminate strings, but Perl allows strings to contain a null.</source>
          <target state="translated">数值为零的字符。C使用它终止字符串，但是Perl允许字符串包含null。</target>
        </trans-unit>
        <trans-unit id="a98fe200a320861843965673193461dc42788194" translate="yes" xml:space="preserve">
          <source>A check is made to make sure that the file that is found does contain some pod documentation.</source>
          <target state="translated">会进行检查,以确保找到的文件确实包含一些 pod 文档。</target>
        </trans-unit>
        <trans-unit id="dff052af6a3279311d539bddc8b2f4ffb4c3bccf" translate="yes" xml:space="preserve">
          <source>A check routine is called when the node is fully constructed except for the execution-order thread. Since at this time there are no back-links to the currently constructed node, one can do most any operation to the top-level node, including freeing it and/or creating new nodes above/below it.</source>
          <target state="translated">当节点除执行顺序线程外全部构造完成时,会调用一个检查例程。由于此时没有与当前构造的节点的反向链接,所以可以对顶层节点进行大部分的操作,包括释放它和/或在它上面/下面创建新的节点。</target>
        </trans-unit>
        <trans-unit id="ffb83db9b043670ff139e922da8f6f1ecd3cdb22" translate="yes" xml:space="preserve">
          <source>A class implementing a filehandle should have the following methods:</source>
          <target state="translated">一个实现filehandle的类应该有以下方法。</target>
        </trans-unit>
        <trans-unit id="78efc3f39c8e446fbaac2a63562d8cf90bbe3489" translate="yes" xml:space="preserve">
          <source>A class implementing a hash should have the following methods:</source>
          <target state="translated">一个实现哈希的类应该有以下方法。</target>
        </trans-unit>
        <trans-unit id="c29da3bd78457adcea44e08fd7ad308e312eac90" translate="yes" xml:space="preserve">
          <source>A class implementing a scalar should have the following methods:</source>
          <target state="translated">一个实现标量的类应该有以下方法。</target>
        </trans-unit>
        <trans-unit id="63533b67267a9fe7a63e719b4e79f437e64bb6e7" translate="yes" xml:space="preserve">
          <source>A class implementing a tied filehandle should define the following methods: TIEHANDLE, at least one of PRINT, PRINTF, WRITE, READLINE, GETC, READ, and possibly CLOSE, UNTIE and DESTROY. The class can also provide: BINMODE, OPEN, EOF, FILENO, SEEK, TELL - if the corresponding perl operators are used on the handle.</source>
          <target state="translated">一个实现绑定文件柄的类应该定义以下方法。TIEHANDLE、PRINT、PRINTF、WRITE、READLINE、GETC、READ中的至少一个方法,可能还有CLOSE、UNTIE和DESTROY。该类还可以提供。BINMODE,OPEN,EOF,FILENO,SEEK,TELL --如果在句柄上使用了相应的perl运算符。</target>
        </trans-unit>
        <trans-unit id="860765a0ff8cee1341ccc04233da280b71701cf8" translate="yes" xml:space="preserve">
          <source>A class implementing a tied ordinary array should define the following methods: TIEARRAY, FETCH, STORE, FETCHSIZE, STORESIZE, CLEAR and perhaps UNTIE and/or DESTROY.</source>
          <target state="translated">一个实现绑定普通数组的类应该定义以下方法。TIEARRAY、FETCH、STORE、FETCHSIZE、STORESIZE、CLEAR以及可能的UNTIE和/或DESTROY。</target>
        </trans-unit>
        <trans-unit id="bf2fe5249c3fde4bdfb3247a51b433da9021cc26" translate="yes" xml:space="preserve">
          <source>A class implementing a tied scalar should define the following methods: TIESCALAR, FETCH, STORE, and possibly UNTIE and/or DESTROY.</source>
          <target state="translated">一个实现绑定标量的类应该定义以下方法:TIESCALAR,FETCH,STORE,以及可能的UNTIE和/或DESTROY。TIESCALAR,FETCH,STORE,可能还有UNTIE和/或DESTROY。</target>
        </trans-unit>
        <trans-unit id="172ef2f1ff718aa5d74e2eddddd8780306842005" translate="yes" xml:space="preserve">
          <source>A class implementing an ordinary array should have the following methods:</source>
          <target state="translated">一个实现普通数组的类应该有以下方法。</target>
        </trans-unit>
        <trans-unit id="7a3aaef4b6bdc65044d6cee8905b655c826b75aa" translate="yes" xml:space="preserve">
          <source>A class is simply a package. A class provides methods that expect to operate on objects.</source>
          <target state="translated">一个类就是一个简单的包。一个类提供了期望对对象进行操作的方法。</target>
        </trans-unit>
        <trans-unit id="db991666cef49d40c1a8876d8e678d10cc5c5920" translate="yes" xml:space="preserve">
          <source>A class providing an object based interface to SysV IPC message queues.</source>
          <target state="translated">一个为SysV IPC消息队列提供基于对象的接口的类。</target>
        </trans-unit>
        <trans-unit id="4b371730a083c396c011c1644f5fee33b2fe22c7" translate="yes" xml:space="preserve">
          <source>A class providing an object based interface to SysV IPC semaphores.</source>
          <target state="translated">一个为SysV IPC semaphores提供基于对象的接口的类。</target>
        </trans-unit>
        <trans-unit id="937b26fb80fdcafceefce4e180073ce7c0d23781" translate="yes" xml:space="preserve">
          <source>A class providing an object based interface to SysV IPC shared memory.</source>
          <target state="translated">一个为SysV IPC共享内存提供基于对象的接口的类。</target>
        </trans-unit>
        <trans-unit id="fa2558ecb874a35a0f9b83568f215824db4e665c" translate="yes" xml:space="preserve">
          <source>A cleaner interface.</source>
          <target state="translated">一个更简洁的界面。</target>
        </trans-unit>
        <trans-unit id="551df32d5b94297e0a676020a161e26c925fb485" translate="yes" xml:space="preserve">
          <source>A command &quot;=begin</source>
          <target state="translated">命令&quot;=begin</target>
        </trans-unit>
        <trans-unit id="4b51cb486fb82b1f8836c9909ccc915ba4671256" translate="yes" xml:space="preserve">
          <source>A command paragraph (also called a &quot;directive&quot;). The first line of this paragraph must match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt;. Command paragraphs are typically one line, as in:</source>
          <target state="translated">命令段落（也称为&amp;ldquo;指令&amp;rdquo;）。本段的第一行必须与 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; 相匹配。命令段落通常为一行，如下所示：</target>
        </trans-unit>
        <trans-unit id="a63e70d9d65f24f45184b420c514e63650be0655" translate="yes" xml:space="preserve">
          <source>A command paragraph is used for special treatment of whole chunks of text, usually as headings or parts of lists.</source>
          <target state="translated">命令段用于对整块文字进行特殊处理,通常作为标题或列表的一部分。</target>
        </trans-unit>
        <trans-unit id="d9ff878c605ee9fd388f0b2eb88f5ce5a0c8f433" translate="yes" xml:space="preserve">
          <source>A command such as this can vastly reduce the volume of material to actually sort through in the first place, and should not be too lightly disregarded purely on the basis of its simplicity. The &lt;code&gt;KISS&lt;/code&gt; principle is too often overlooked - the next example uses the simple system &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; utility to demonstrate. Let's take a look at an actual example of sorting the contents of a large file, an apache logfile would do. This one has over a quarter of a million lines, is 50M in size, and a snippet of it looks like this:</source>
          <target state="translated">这样的命令首先可以大大减少实际要分拣的物料的数量，并且不应纯粹出于其简单性而过分忽略它。该 &lt;code&gt;KISS&lt;/code&gt; 原则是常常被忽视-在下面的例子中使用了简单的系统 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 效用来证明。让我们看一个实际的示例，该示例对一个大文件的内容进行排序，而apache日志文件可以做到。该行有四分之一的行，超过一百万行，大小为5000万，其摘要如下所示：</target>
        </trans-unit>
        <trans-unit id="950be6f2b3fd35cd65faf61436fcb9557d03c11d" translate="yes" xml:space="preserve">
          <source>A command which has ended up in the middle of a paragraph or other command, such as</source>
          <target state="translated">在一段话或其他命令中结束的命令,如</target>
        </trans-unit>
        <trans-unit id="dfc138f19fcb5bcbc53f0752d4f1867a8fa0e913" translate="yes" xml:space="preserve">
          <source>A command-line front-end to &lt;code&gt;Module::CoreList&lt;/code&gt; , to query what modules were shipped with given versions of perl.</source>
          <target state="translated">在 &lt;code&gt;Module::CoreList&lt;/code&gt; 的命令行前端，用于查询给定版本的perl附带了哪些模块。</target>
        </trans-unit>
        <trans-unit id="9cbae24479d2e6391e2d1be21dd08d1626f00360" translate="yes" xml:space="preserve">
          <source>A comment</source>
          <target state="translated">一条评论</target>
        </trans-unit>
        <trans-unit id="79414afc2393f5f2f467ceef02de3748e14d7a7a" translate="yes" xml:space="preserve">
          <source>A comment, indicated by putting a '#' in the first column.</source>
          <target state="translated">一条评论,在第一栏加个 &quot;#&quot;表示。</target>
        </trans-unit>
        <trans-unit id="ee091682ad4b542f16ac50d991bfff2ba6d1e9a6" translate="yes" xml:space="preserve">
          <source>A comment. The text is ignored. Note that Perl closes the comment as soon as it sees a &lt;code&gt;)&lt;/code&gt;, so there is no way to put a literal &lt;code&gt;)&lt;/code&gt; in the comment. The pattern's closing delimiter must be escaped by a backslash if it appears in the comment.</source>
          <target state="translated">一条评论。文本将被忽略。请注意，Perl看到 &lt;code&gt;)&lt;/code&gt; 就会立即关闭注释，因此无法在注释中添加文字 &lt;code&gt;)&lt;/code&gt; 。如果模式的结束定界符出现在注释中，则必须使用反斜杠对其进行转义。</target>
        </trans-unit>
        <trans-unit id="1efe142409d27cde9607bba9f906e0c889b26956" translate="yes" xml:space="preserve">
          <source>A commit message isn't intended to take the place of comments in your code. Commit messages should describe the change you made, while code comments should describe the current state of the code.</source>
          <target state="translated">提交信息并不是要取代代码中的注释,提交信息应该描述你所做的修改,而代码注释应该描述代码的当前状态。提交信息应该描述你所做的修改,而代码注释应该描述代码的当前状态。</target>
        </trans-unit>
        <trans-unit id="bf7ad1fec29a3549dc58ded16ba4af5fb14c45da" translate="yes" xml:space="preserve">
          <source>A common abuse of this power stems from the ability to make infinite loops using regular expressions, with something as innocuous as:</source>
          <target state="translated">对这一能力的常见滥用源于使用正则表达式进行无限循环的能力,比如一些无害的东西。</target>
        </trans-unit>
        <trans-unit id="80ff7af3da26f57aaa8f224ec06b92247a2ede78" translate="yes" xml:space="preserve">
          <source>A common bit of code &lt;b&gt;NOT TO USE&lt;/b&gt; is this:</source>
          <target state="translated">&lt;b&gt;不使用的&lt;/b&gt;常见代码是：</target>
        </trans-unit>
        <trans-unit id="bcd3e6faa389885dcad88118cf027340603a19e2" translate="yes" xml:space="preserve">
          <source>A common misconception in socket programming is that &lt;code&gt;\n &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; \012&lt;/code&gt; everywhere. When using protocols such as common Internet protocols, &lt;code&gt;\012&lt;/code&gt; and &lt;code&gt;\015&lt;/code&gt; are called for specifically, and the values of the logical &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; (carriage return) are not reliable.</source>
          <target state="translated">套接字编程中一个常见的误解是，到处都是 &lt;code&gt;\n &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; \012&lt;/code&gt; 。当使用诸如通用Internet协议之类的协议时，将特别要求 &lt;code&gt;\012&lt;/code&gt; 和 &lt;code&gt;\015&lt;/code&gt; ，并且逻辑 &lt;code&gt;\n&lt;/code&gt; 和 &lt;code&gt;\r&lt;/code&gt; （回车）的值不可靠。</target>
        </trans-unit>
        <trans-unit id="b9e9593af1f1c680a3827d8f5e0edca15a66c226" translate="yes" xml:space="preserve">
          <source>A common mistake is to try to separate the words with commas or to put comments into a multi-line &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt;-string. For this reason, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma and the &lt;b&gt;-w&lt;/b&gt; switch (that is, the &lt;code&gt;$^W&lt;/code&gt; variable) produces warnings if the</source>
          <target state="translated">一个常见的错误是尝试用逗号分隔单词或将注释放入多行 &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt; -string中。由于这个原因，如果 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ，则使用警告编译指示和&lt;b&gt;-w&lt;/b&gt;开关（即 &lt;code&gt;$^W&lt;/code&gt; 变量）会产生警告。</target>
        </trans-unit>
        <trans-unit id="aad5d9b3c5a0d882bf3ecc970194923dc4421054" translate="yes" xml:space="preserve">
          <source>A common mistake is to write:</source>
          <target state="translated">一个常见的错误是写。</target>
        </trans-unit>
        <trans-unit id="2a1998491c1e38cb900464f10bbb2d155c01472d" translate="yes" xml:space="preserve">
          <source>A common pitfall is to use &lt;a href=&quot;#precision()&quot;&gt;precision()&lt;/a&gt; when you want to round a result to a certain number of digits:</source>
          <target state="translated">一个常见的陷阱是，当您想将结果四舍五入到一定位数时，使用&lt;a href=&quot;#precision()&quot;&gt;precision（）&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="008944edbc996e59046c342b9a5abf856d868927" translate="yes" xml:space="preserve">
          <source>A common sight is code which looks something like this:</source>
          <target state="translated">一个常见的景象是,代码看起来像这样。</target>
        </trans-unit>
        <trans-unit id="7a1613d252216a78f3f6c4f13b80070f584c7ea5" translate="yes" xml:space="preserve">
          <source>A common value you might want would be just &quot;.&quot; for the current directory:</source>
          <target state="translated">你可能想要的一个常见的值就是当前目录的&quot;.&quot;。</target>
        </trans-unit>
        <trans-unit id="0c241c23e5c55b1df65f14fa3926fd6466b90d17" translate="yes" xml:space="preserve">
          <source>A complete list of Perl's error messages and warnings with explanatory text can be found in &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;. You can also use the splain program (distributed with Perl) to explain the error messages:</source>
          <target state="translated">在&lt;a href=&quot;perldiag&quot;&gt;perldiag中&lt;/a&gt;可以找到Perl错误消息和警告的完整列表以及说明性文字。您还可以使用splain程序（与Perl一起分发）来解释错误消息：</target>
        </trans-unit>
        <trans-unit id="2766232819d1e10808eb2c0fa9745fbc9935b0e0" translate="yes" xml:space="preserve">
          <source>A complete list of blocks and their shortcuts is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">块及其快捷方式的完整列表在&lt;a href=&quot;perluniprops&quot;&gt;perluniprops中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c9c8e1e2ba56e67cb98e64490d656c0331322db" translate="yes" xml:space="preserve">
          <source>A complete list of models at the time the OS was built is in the file /usr/sam/lib/mo/sched.models. The first column corresponds to the last part of the output of the &quot;model&quot; command. The second column is the PA-RISC version and the third column is the exact chip type used. (Start browsing at the bottom to prevent confusion ;-)</source>
          <target state="translated">操作系统建立时的完整模型列表在文件/usr/sam/lib/mo/sched.models中。第一列对应于 &quot;model &quot;命令输出的最后一部分。第二列是PA-RISC版本,第三列是所使用的准确芯片类型。(从底部开始浏览,防止混淆;-)</target>
        </trans-unit>
        <trans-unit id="57f247bd806924e603c825d46c359f392e5225bb" translate="yes" xml:space="preserve">
          <source>A complete list of scripts and their shortcuts is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">脚本及其快捷方式的完整列表在&lt;a href=&quot;perluniprops&quot;&gt;perluniprops中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="352eea5d492543a075b98638f01aabee71fa53f5" translate="yes" xml:space="preserve">
          <source>A complete thread tutorial could fill a book (and has, many times), but with what we've covered in this introduction, you should be well on your way to becoming a threaded Perl expert.</source>
          <target state="translated">一个完整的线程教程可以写满一本书(而且已经写了很多次),但是有了我们在本篇介绍中所涉及的内容,你应该可以顺利地成为一个线程的Perl专家。</target>
        </trans-unit>
        <trans-unit id="018d8cf23f3e4a65b253a6e3de9afa4ba28bc385" translate="yes" xml:space="preserve">
          <source>A component of a &lt;b&gt;regular expression&lt;/b&gt; pattern.</source>
          <target state="translated">&lt;b&gt;正则表达式&lt;/b&gt;模式的组成部分。</target>
        </trans-unit>
        <trans-unit id="f5c9d218e3a29ce718317121d0020d3ccf6b9e88" translate="yes" xml:space="preserve">
          <source>A component of a &lt;b&gt;regular expression&lt;/b&gt; specifying how many times the foregoing &lt;b&gt;atom&lt;/b&gt; may occur.</source>
          <target state="translated">&lt;b&gt;正则表达式的&lt;/b&gt;组成部分，指定上述&lt;b&gt;原子&lt;/b&gt;可能出现多少次。</target>
        </trans-unit>
        <trans-unit id="ca17448c2b0615d183e89c2b8af18e1466ef0123" translate="yes" xml:space="preserve">
          <source>A component of a &lt;b&gt;regular expression&lt;/b&gt; that must be true for the pattern to match but does not necessarily match any characters itself. Often used specifically to mean a &lt;b&gt;zero-width&lt;/b&gt; assertion.</source>
          <target state="translated">&lt;b&gt;正则表达式的&lt;/b&gt;组成部分，必须为true才能使模式匹配，但不一定与任何字符本身匹配。通常专门用于表示&lt;b&gt;零宽度&lt;/b&gt;断言。</target>
        </trans-unit>
        <trans-unit id="e4b110fd2e9cb16d7f0633f61d623ac063cd7727" translate="yes" xml:space="preserve">
          <source>A comprehensive list of Perl-related mailing lists can be found at &lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt;</source>
          <target state="translated">可以在&lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt;找到与Perl相关的邮件列表的完整列表。</target>
        </trans-unit>
        <trans-unit id="6ffdc43a299a7177f53314c9b7e876aeb0c84ac8" translate="yes" xml:space="preserve">
          <source>A consequence of this is that &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=number&lt;/b&gt; never does a version check, unless &lt;code&gt;&lt;i&gt;MODULE&lt;/i&gt;::import()&lt;/code&gt; itself is set up to do a version check, which could happen for example if</source>
          <target state="translated">其结果是，&lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = number&lt;/b&gt;永远不会进行版本检查，除非将 &lt;code&gt;&lt;i&gt;MODULE&lt;/i&gt;::import()&lt;/code&gt; 本身设置为进行版本检查，例如</target>
        </trans-unit>
        <trans-unit id="350e3e899dba4b57e7486366f0fbf9264f9b61f7" translate="yes" xml:space="preserve">
          <source>A constant with a name in the list &lt;code&gt;STDIN STDOUT STDERR ARGV ARGVOUT
ENV INC SIG&lt;/code&gt; is not allowed anywhere but in package &lt;code&gt;main::&lt;/code&gt; , for technical reasons.</source>
          <target state="translated">出于技术原因，除了包 &lt;code&gt;main::&lt;/code&gt; ，任何地方都不允许使用名称在 &lt;code&gt;STDIN STDOUT STDERR ARGV ARGVOUT ENV INC SIG&lt;/code&gt; 列表中的常量。</target>
        </trans-unit>
        <trans-unit id="78f90a10d8180ed5dc542d1b277136194356a682" translate="yes" xml:space="preserve">
          <source>A construct that performs something repeatedly, like a roller coaster.</source>
          <target state="translated">一种重复执行某事的构造,就像过山车一样。</target>
        </trans-unit>
        <trans-unit id="98c376c5464a7cbd0f7597422425141a29b3dc1e" translate="yes" xml:space="preserve">
          <source>A construct that sometimes looks like a function but really isn&amp;rsquo;t. Usually reserved for &lt;b&gt;lvalue&lt;/b&gt; modifiers like &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, for &lt;b&gt;context&lt;/b&gt; modifiers like &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt;, and for the pick-your-own-quotes constructs, &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有时看起来像函数但实际上不是的构造。通常保留给像 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 这样的&lt;b&gt;左值&lt;/b&gt;修饰符，像 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 这样的&lt;b&gt;上下文&lt;/b&gt;修饰符以及 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 的pick-your-own-quotes构造。 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b8552f673941f3d1978946011be4253061336584" translate="yes" xml:space="preserve">
          <source>A contact email address for the author/maintainer</source>
          <target state="translated">作者/维护者的联系电子邮件地址。</target>
        </trans-unit>
        <trans-unit id="1e9afcf85fc0132156a56c6d8cb4ffccff6b369d" translate="yes" xml:space="preserve">
          <source>A convenience function which combines creating an object and calling &lt;code&gt;isa_ok()&lt;/code&gt; on that object.</source>
          <target state="translated">一个便捷函数，将创建对象和 &lt;code&gt;isa_ok()&lt;/code&gt; 对象调用isa_ok（）结合在一起。</target>
        </trans-unit>
        <trans-unit id="53128330b7badc08928ea23290fdacf578eb391d" translate="yes" xml:space="preserve">
          <source>A convenience variable which is typically used with &lt;code&gt;SvPV&lt;/code&gt; when one doesn't care about the length of the string. It is usually more efficient to either declare a local variable and use that instead or to use the &lt;code&gt;SvPV_nolen&lt;/code&gt; macro.</source>
          <target state="translated">一个方便变量，通常在不关心字符串长度的情况下与 &lt;code&gt;SvPV&lt;/code&gt; 一起使用。通常，声明局部变量并使用它或使用 &lt;code&gt;SvPV_nolen&lt;/code&gt; 宏通常更为有效。</target>
        </trans-unit>
        <trans-unit id="638f854b99669da73bce286ea189e697af8d4b5f" translate="yes" xml:space="preserve">
          <source>A convenient shortcut to operating on even-sized lists of pairs, this function returns a list of ARRAY references, each containing two items from the given list. It is a more efficient version of</source>
          <target state="translated">这个函数是对偶数大小的对列表进行操作的便捷捷径,它返回一个ARRAY引用的列表,每个列表包含给定列表中的两个项目。它是一个更有效的版本</target>
        </trans-unit>
        <trans-unit id="1166e931ea27a942799d52c7c1f3e445e7d6efa2" translate="yes" xml:space="preserve">
          <source>A convenient shortcut to operating on even-sized lists of pairs, this function returns a list of the the first values of each of the pairs in the given list. It is a more efficient version of</source>
          <target state="translated">这个函数是对偶数对列表进行操作的一个便捷的捷径,它返回给定列表中每个对的首值列表。它是一个更有效的版本</target>
        </trans-unit>
        <trans-unit id="0dbcf107b79ffefab41fba2fbb5cf9a734cd1746" translate="yes" xml:space="preserve">
          <source>A convenient shortcut to operating on even-sized lists of pairs, this function returns a list of the the second values of each of the pairs in the given list. It is a more efficient version of</source>
          <target state="translated">这个函数是对偶数对列表进行操作的一个便捷的捷径,它返回给定列表中每个对的第二个值的列表。它是一个更有效的版本</target>
        </trans-unit>
        <trans-unit id="77f68a02d61a77d7eed2d175da1b876e8aceace1" translate="yes" xml:space="preserve">
          <source>A convenient way to set up your tests. Call this and Test::Builder will print the appropriate headers and take the appropriate actions.</source>
          <target state="translated">一个设置测试的便捷方法。调用它,Test::Builder将打印适当的标题并采取适当的行动。</target>
        </trans-unit>
        <trans-unit id="d87e8f492879ce02bf236daf94692483d0fd4b5c" translate="yes" xml:space="preserve">
          <source>A conventional (not inside-out) implementation where an object is a hash that stores the field values, without support by &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; . This implementation doesn't allow arbitrary inheritance.</source>
          <target state="translated">一种常规（不是由内而外）的实现，其中对象是存储字段值的 &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; ，而不受Hash :: Util :: FieldHash的支持。此实现不允许任意继承。</target>
        </trans-unit>
        <trans-unit id="646b8162acfbdd090f426555f4c9a32ee73eeb01" translate="yes" xml:space="preserve">
          <source>A copy of IO::Scalar for Test::Builder</source>
          <target state="translated">Test::Builder的IO::Scalar副本。</target>
        </trans-unit>
        <trans-unit id="5a070156d8ac581b1ec13fda608b6d3f5d95a087" translate="yes" xml:space="preserve">
          <source>A copy of a Win* viewer is contained in the &quot;Just add OS/2 Warp&quot; package</source>
          <target state="translated">在 &quot;只需添加OS/2 Warp &quot;软件包中包含一个Win*查看器的副本。</target>
        </trans-unit>
        <trans-unit id="6e407ab7758af4150015ce0b8baf63576cf02a27" translate="yes" xml:space="preserve">
          <source>A copyright notice - see below.</source>
          <target state="translated">版权声明 ----见下文。</target>
        </trans-unit>
        <trans-unit id="d687cc7b81ffa630de399555f3a224dda7b56cfa" translate="yes" xml:space="preserve">
          <source>A correct CPAN version number is a floating point number with at least 2 digits after the decimal. You can test whether it conforms to CPAN by using</source>
          <target state="translated">正确的CPAN版本号是一个小数点后至少有2位的浮点数。您可以通过以下方法测试它是否符合CPAN</target>
        </trans-unit>
        <trans-unit id="8295d6831975ca50ed9530db07dca19a25c715be" translate="yes" xml:space="preserve">
          <source>A count passed to Tpad to modify the padding applied to the output string. If $cnt is zero or one then the resulting string will be cached.</source>
          <target state="translated">传递给Tpad的一个计数,用于修改应用于输出字符串的padding。如果$cnt为0或1,那么输出的字符串将被缓存。</target>
        </trans-unit>
        <trans-unit id="3ca2814f3e720b9b1b346f0c76354ef75ff06f2d" translate="yes" xml:space="preserve">
          <source>A crude table of contents for the Perl manpage set is found in &lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc中&lt;/a&gt;可以找到Perl联机帮助集的原始目录。</target>
        </trans-unit>
        <trans-unit id="03adc2f14ebb3d0a7a9ba21528d13d42030133f9" translate="yes" xml:space="preserve">
          <source>A data debugging tool for the XS programmer</source>
          <target state="translated">XS程序员的数据调试工具。</target>
        </trans-unit>
        <trans-unit id="07e1664c3b50241d29a1670852c2daa101e50db7" translate="yes" xml:space="preserve">
          <source>A data repository. Instead of computing expensive answers several times, compute it once and save the result.</source>
          <target state="translated">一个数据仓库。与其多次计算昂贵的答案,不如计算一次并保存结果。</target>
        </trans-unit>
        <trans-unit id="40b9a92df275c1cef5fb6a4e3d00cf2b3d4203b3" translate="yes" xml:space="preserve">
          <source>A data structure used internally by Perl for implementing associative arrays (hashes) efficiently. See also &lt;b&gt;bucket&lt;/b&gt;.</source>
          <target state="translated">Perl内部使用的一种数据结构，用于有效地实现关联数组（哈希）。另请参见&lt;b&gt;bucket&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="b6431d472e1b30028a75ba55229126e2e191ae3c" translate="yes" xml:space="preserve">
          <source>A declaration can be put anywhere a statement can, but has no effect on the execution of the primary sequence of statements: declarations all take effect at compile time. All declarations are typically put at the beginning or the end of the script. However, if you're using lexically-scoped private variables created with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt;, you'll have to make sure your format or subroutine definition is within the same block scope as the my if you expect to be able to access those private variables.</source>
          <target state="translated">声明可以放在语句可以放置的任何位置，但对语句的主要顺序的执行没有影响：声明全部在编译时生效。通常将所有声明放在脚本的开头或结尾。但是，如果您使用的是用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt; 创建的词法范围私有变量，则必须确保格式或子例程定义与my处于同一块范围内，如果您希望能够访问那些私有变量。</target>
        </trans-unit>
        <trans-unit id="753d1d91d799e4e070ffae305c67c5e3d698281a" translate="yes" xml:space="preserve">
          <source>A default hashing algorithm, which will be adequate for most applications, is built into Berkeley DB. If you do need to use your own hashing algorithm it is possible to write your own in Perl and have &lt;b&gt;DB_File&lt;/b&gt; use it instead.</source>
          <target state="translated">Berkeley DB中内置了适用于大多数应用程序的默认哈希算法。如果确实需要使用自己的哈希算法，则可以在Perl中编写自己的哈希算法，并使用&lt;b&gt;DB_File&lt;/b&gt;代替。</target>
        </trans-unit>
        <trans-unit id="b9828da4e803d376a194bd30931557a328ae046c" translate="yes" xml:space="preserve">
          <source>A default site INSTALL.SKIP may be provided by setting then environment variable EU_INSTALL_SITE_SKIPFILE, this will only be used when there isn't a distribution specific INSTALL.SKIP. If the environment variable EU_INSTALL_IGNORE_SKIP is true then no install file filtering will be performed.</source>
          <target state="translated">可以通过设置环境变量EU_INSTALL_SITE_SKIPFILE来提供一个默认的INSTALL.SKIP站点,这只有在没有特定的INSTALL.SKIP发行版时才会被使用,如果环境变量EU_INSTALL_IGNORE_SKIP为true,那么就不会进行安装文件过滤。如果环境变量EU_INSTALL_IGNORE_SKIP为true,那么将不执行安装文件过滤。</target>
        </trans-unit>
        <trans-unit id="0e649d4a2c7d23eccbd6705217dd0baed80106ea" translate="yes" xml:space="preserve">
          <source>A deferred action like this:</source>
          <target state="translated">这样的推迟行动。</target>
        </trans-unit>
        <trans-unit id="c7b7b32d1f43857ac978062d5529fcaa75b008c1" translate="yes" xml:space="preserve">
          <source>A description of how C types may be transformed to and from Perl types within an &lt;b&gt;extension&lt;/b&gt; module written in &lt;b&gt;XS&lt;/b&gt;.</source>
          <target state="translated">在&lt;b&gt;XS&lt;/b&gt;编写的&lt;b&gt;扩展&lt;/b&gt;模块中，如何将C类型转换为Perl类型以及从Perl类型转换为C的描述。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="152e62c7af6a3030011c43a7ed3a060f156647cc" translate="yes" xml:space="preserve">
          <source>A description of the callable function in each module</source>
          <target state="translated">每个模块中可调用函数的说明。</target>
        </trans-unit>
        <trans-unit id="a361777f63c2dac8a5f187498445ea69ff2e5fd2" translate="yes" xml:space="preserve">
          <source>A description of the module/package/extension etc.</source>
          <target state="translated">模块/包件/扩展等的说明;</target>
        </trans-unit>
        <trans-unit id="2d3ff2a56a13511ba72ba40a6fa6a2c401a75cdb" translate="yes" xml:space="preserve">
          <source>A detailed document on Encode and PerlIO</source>
          <target state="translated">关于Encode和PerlIO的详细文档</target>
        </trans-unit>
        <trans-unit id="6acb6151fda2f69cbd4a7ea5c8537d8c57875e5a" translate="yes" xml:space="preserve">
          <source>A device you can put things on the top of, and later take them back off in the opposite order in which you put them on. See &lt;b&gt;LIFO&lt;/b&gt;.</source>
          <target state="translated">您可以将设备放在上面的设备，然后以相反的顺序将它们取下。参见&lt;b&gt;LIFO&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="ce6d3879a0b885e4f02b96959f6d870d8f5b1fa8" translate="yes" xml:space="preserve">
          <source>A different approach is to autoload seldom-used Perl code. See the AutoSplit and AutoLoader modules in the standard distribution for that. Or you could locate the bottleneck and think about writing just that part in C, the way we used to take bottlenecks in C code and write them in assembler. Similar to rewriting in C, modules that have critical sections can be written in C (for instance, the PDL module from CPAN).</source>
          <target state="translated">另一种方法是自动加载很少使用的Perl代码。参见标准发行版中的 AutoSplit 和 AutoLoader 模块。或者你可以找到瓶颈,然后考虑只用C语言写那部分,就像我们以前把C代码中的瓶颈用汇编器写出来一样。与用C语言重写类似,有关键部分的模块也可以用C语言写(比如CPAN的PDL模块)。</target>
        </trans-unit>
        <trans-unit id="fd02787c52da0901c066d4ccff09232fd888e22e" translate="yes" xml:space="preserve">
          <source>A different type of portability issue arises when writing XS code: availability of a C compiler on the end-user's system. C brings with it its own portability issues, and writing XS code will expose you to some of those. Writing purely in Perl is an easier way to achieve portability.</source>
          <target state="translated">在编写XS代码时,会出现另一种类型的可移植性问题:终端用户系统上是否有C编译器。C语言会带来它自己的可移植性问题,而编写XS代码会让你面临其中的一些问题。纯粹用Perl编写是实现可移植性的一个比较简单的方法。</target>
        </trans-unit>
        <trans-unit id="7549e9114a09a619af3acd4b50c3c4a53ce35871" translate="yes" xml:space="preserve">
          <source>A direct &lt;b&gt;connection&lt;/b&gt; that carries the output of one &lt;b&gt;process&lt;/b&gt; to the input of another without an intermediate temporary file. Once the pipe is set up, the two processes in question can read and write as if they were talking to a normal file, with some caveats.</source>
          <target state="translated">直接&lt;b&gt;连接&lt;/b&gt;，将一个&lt;b&gt;过程&lt;/b&gt;的输出传递到另一个&lt;b&gt;过程&lt;/b&gt;的输入，而无需中间临时文件。设置好管道之后，有两个注意事项，有问题的两个进程可以像对待普通文件一样进行读写。</target>
        </trans-unit>
        <trans-unit id="4b845b5f598804539b9d3429d1e0dde292769ef5" translate="yes" xml:space="preserve">
          <source>A distribution of modules to handle locale codes</source>
          <target state="translated">处理区域代码的模块分布</target>
        </trans-unit>
        <trans-unit id="3e6b7ccc64e5147f1acc2484c6d3b919c5bc2282" translate="yes" xml:space="preserve">
          <source>A document having more than one &quot;=encoding&quot; line should be considered an error. Pod processors may silently tolerate this if the not-first &quot;=encoding&quot; lines are just duplicates of the first one (e.g., if there's a &quot;=encoding utf8&quot; line, and later on another &quot;=encoding utf8&quot; line). But Pod processors should complain if there are contradictory &quot;=encoding&quot; lines in the same document (e.g., if there is a &quot;=encoding utf8&quot; early in the document and &quot;=encoding big5&quot; later). Pod processors that recognize BOMs may also complain if they see an &quot;=encoding&quot; line that contradicts the BOM (e.g., if a document with a UTF-16LE BOM has an &quot;=encoding shiftjis&quot; line).</source>
          <target state="translated">一个文档有一个以上的&quot;=encoding &quot;行应被视为一个错误。如果不是第一行的&quot;=encoding &quot;只是第一行的重复,Pod处理器可能会默默地容忍这一点(例如,如果有一个&quot;=encoding utf8 &quot;行,后来又有一个&quot;=encoding utf8 &quot;行)。但是,如果在同一个文档中出现了矛盾的&quot;=编码 &quot;行,Pod处理器应该抱怨(例如,如果在文档的早期有一个&quot;=编码utf8&quot;,而后面有一个&quot;=编码big5&quot;)。识别BOM的花苞处理器如果看到与BOM相矛盾的&quot;=编码 &quot;行,也可能会抱怨(例如,如果一个UTF-16LE BOM的文档有&quot;=编码shiftjis &quot;行)。</target>
        </trans-unit>
        <trans-unit id="4df78e410296e2b3f4b712de1ae484fe7cd130b2" translate="yes" xml:space="preserve">
          <source>A document type tag for the file. This option is not set by default.</source>
          <target state="translated">文件的文件类型标签。默认情况下不设置此选项。</target>
        </trans-unit>
        <trans-unit id="d80c6e485dc27886043d9d72950290e87158018b" translate="yes" xml:space="preserve">
          <source>A domain of names. You needn&amp;rsquo;t worry about whether the names in one such domain have been used in another. See &lt;b&gt;package&lt;/b&gt;.</source>
          <target state="translated">名称域。您不必担心一个域中的名称是否已在另一个域中使用。参见&lt;b&gt;package&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="7598f11ff5b1103678a9d5639c3dfc75e6d4a5e6" translate="yes" xml:space="preserve">
          <source>A double precision floating point number. This typemap guarantees to return a variable cast to a &lt;code&gt;double&lt;/code&gt; .</source>
          <target state="translated">双精度浮点数。此类型映射保证将变量强制转换为 &lt;code&gt;double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="102050331265d60ae1056cdc3a0d24fd9e06376e" translate="yes" xml:space="preserve">
          <source>A double-quoted, interpolated string.</source>
          <target state="translated">一个双引号、插值的字符串。</target>
        </trans-unit>
        <trans-unit id="faeb399a5d08eaa739b873af03a2a402dd907834" translate="yes" xml:space="preserve">
          <source>A dummy layer which never exists on the layer stack. Instead when &quot;pushed&quot; it actually pops the stack removing itself, it then calls Binmode function table entry on all the layers in the stack - normally this (via PerlIOBase_binmode) removes any layers which do not have &lt;code&gt;PERLIO_K_RAW&lt;/code&gt; bit set. Layers can modify that behaviour by defining their own Binmode entry.</source>
          <target state="translated">在层堆栈上永远不存在的虚拟层。取而代之的是，当&amp;ldquo;推&amp;rdquo;它实际上弹出堆栈时，它会自己删除，然后在堆栈中的所有层上调用Binmode函数表条目-通常，这（通过PerlIOBase_binmode）会删除任何未设置 &lt;code&gt;PERLIO_K_RAW&lt;/code&gt; 位的层。图层可以通过定义自己的Binmode条目来修改该行为。</target>
        </trans-unit>
        <trans-unit id="f90a52847d42c09984d572f3b595cda347017f00" translate="yes" xml:space="preserve">
          <source>A failed match or changing the target string resets the position. If you don't want the position reset after failure to match, add the &lt;code&gt;//c&lt;/code&gt; , as in &lt;code&gt;/regex/gc&lt;/code&gt; .</source>
          <target state="translated">匹配失败或更改目标字符串将重置位置。如果您不希望在匹配失败后重置位置，请添加 &lt;code&gt;//c&lt;/code&gt; ，如 &lt;code&gt;/regex/gc&lt;/code&gt; 所示。</target>
        </trans-unit>
        <trans-unit id="d5efee2d4f79d8ba35cf758e77756920ee770903" translate="yes" xml:space="preserve">
          <source>A failed match or changing the target string resets the position. If you don't want the position reset after failure to match, add the &lt;code&gt;//c&lt;/code&gt; , as in &lt;code&gt;/regexp/gc&lt;/code&gt; . The current position in the string is associated with the string, not the regexp. This means that different strings have different positions and their respective positions can be set or read independently.</source>
          <target state="translated">匹配失败或更改目标字符串将重置位置。如果您不希望在匹配失败后重置位置，请添加 &lt;code&gt;//c&lt;/code&gt; ，如 &lt;code&gt;/regexp/gc&lt;/code&gt; 所示。字符串中的当前位置与字符串关联，而不与regexp关联。这意味着不同的字符串具有不同的位置，并且它们各自的位置可以独立设置或读取。</target>
        </trans-unit>
        <trans-unit id="656a7d55b2753fa751b87d85db4a4654a61963c4" translate="yes" xml:space="preserve">
          <source>A fairly common feature in applications is to allow you to define a C function that will be called whenever something nasty occurs. What we would like is to be able to specify a Perl subroutine that will be called instead.</source>
          <target state="translated">在应用程序中,一个相当常见的功能是允许你定义一个C函数,每当发生一些令人讨厌的事情时就会被调用。我们希望能够指定一个Perl子程序来代替调用。</target>
        </trans-unit>
        <trans-unit id="e27669facce8e75680a82515ceb4a7dde4554488" translate="yes" xml:space="preserve">
          <source>A fancy computer science term meaning &amp;ldquo;to follow a &lt;b&gt;reference&lt;/b&gt; to what it points to&amp;rdquo;. The &amp;ldquo;de&amp;rdquo; part of it refers to the fact that you&amp;rsquo;re taking away one level of &lt;b&gt;indirection&lt;/b&gt;.</source>
          <target state="translated">奇特的计算机科学术语，意为&amp;ldquo;遵循对其所指内容的&lt;b&gt;引用&lt;/b&gt; &amp;rdquo;。它的&amp;ldquo; de&amp;rdquo;部分是指您正在剥夺一个&lt;b&gt;间接&lt;/b&gt;层的事实。</target>
        </trans-unit>
        <trans-unit id="8f4dde098cc45c330d3e8fa85a502fc0eae6cde3" translate="yes" xml:space="preserve">
          <source>A fancy kind of interlock that prevents multiple &lt;b&gt;threads&lt;/b&gt; or &lt;b&gt;processes&lt;/b&gt; from using up the same resources simultaneously.</source>
          <target state="translated">一种奇特的互锁，可防止多个&lt;b&gt;线程&lt;/b&gt;或&lt;b&gt;进程&lt;/b&gt;同时用完相同的资源。</target>
        </trans-unit>
        <trans-unit id="2f52178a4e9cc243237404e962bb98cf1d11d03e" translate="yes" xml:space="preserve">
          <source>A fancy term for an error. See &lt;b&gt;fatal error&lt;/b&gt;.</source>
          <target state="translated">一个错误的花哨术语。看到&lt;b&gt;致命错误&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="d130552cd3247973054cf88d786bc01b68b3a6e5" translate="yes" xml:space="preserve">
          <source>A fatal error will be thrown if the Compress::Zlib module is not available.</source>
          <target state="translated">如果 Compress::Zlib 模块不可用,将会产生一个致命的错误。</target>
        </trans-unit>
        <trans-unit id="c1f172aa731045204a1719d56bb2cc8625060274" translate="yes" xml:space="preserve">
          <source>A fatal error will be thrown if:</source>
          <target state="translated">如果出现以下情况,将引发一个致命的错误:</target>
        </trans-unit>
        <trans-unit id="206dcfa56d21a53d3ca90835f2da1335f0ce9141" translate="yes" xml:space="preserve">
          <source>A feature of &lt;b&gt;operator overloading&lt;/b&gt; of &lt;b&gt;objects&lt;/b&gt;, whereby the behavior of certain &lt;b&gt;operators&lt;/b&gt; can be reasonably deduced using more fundamental operators. This assumes that the overloaded operators will often have the same relationships as the regular operators. See Camel chapter 13, &amp;ldquo;Overloading&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;对象&lt;/b&gt;的&lt;b&gt;运算符重载&lt;/b&gt;的特征，从而可以使用更基本的运算符来合理地推导出某些&lt;b&gt;运算符&lt;/b&gt;的行为。假设重载运算符通常与常规运算符具有相同的关系。请参见骆驼第13章，&amp;ldquo;过载&amp;rdquo;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="96f7456dc10c0f5e5c69de568de641b9d361467e" translate="yes" xml:space="preserve">
          <source>A few dir-vs-file optimizations result in glob importation being 10 times faster than using perlglob.exe, and using perlglob.bat is only twice as slow as perlglob.exe (GSAR 28-MAY-97)</source>
          <target state="translated">通过对dir-vs-file的优化,glob导入比使用perlglob.exe快10倍,而使用perlglob.bat只比perlglob.exe慢两倍(GSAR 28-MAY-97)</target>
        </trans-unit>
        <trans-unit id="29b977997a9e174d5b0509df5c6aa92021e1d1e4" translate="yes" xml:space="preserve">
          <source>A few example globmaps</source>
          <target state="translated">一些示例性的globmaps</target>
        </trans-unit>
        <trans-unit id="4079515a56f3376aa599af18d3ce02d4fa762708" translate="yes" xml:space="preserve">
          <source>A few functions are not implemented because they are C specific. If you attempt to call these, they will print a message telling you that they aren't implemented, and suggest using the Perl equivalent, should one exist. For example, trying to access the &lt;code&gt;setjmp()&lt;/code&gt; call will elicit the message &quot;&lt;code&gt;setjmp() is C-specific: &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {} instead&lt;/code&gt; &quot;.</source>
          <target state="translated">由于它们是C特定的，因此未实现某些功能。如果您尝试调用它们，它们将打印一条消息，告诉您它们尚未实现，并建议使用等效的Perl。例如，尝试访问 &lt;code&gt;setjmp()&lt;/code&gt; 调用将引发消息&amp;ldquo; &lt;code&gt;setjmp() is C-specific: &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {} instead&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="dcd9feea0227978a722652bf64b2da3e239d9119" translate="yes" xml:space="preserve">
          <source>A few functions take no arguments at all, and therefore work as neither unary nor list operators. These include such functions as &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/endpwent&quot;&gt;endpwent&lt;/a&gt;&lt;/code&gt;. For example, &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time+86_400&lt;/a&gt;&lt;/code&gt; always means &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;() + 86_400&lt;/code&gt; .</source>
          <target state="translated">一些函数根本不带参数，因此既不是一元运算符也不是列表运算符。这些功能包括 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/endpwent&quot;&gt;endpwent&lt;/a&gt;&lt;/code&gt; 时间。例如， &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time+86_400&lt;/a&gt;&lt;/code&gt; 始终表示 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;() + 86_400&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18d4ec4509605bbb34d201f389b34f426f595148" translate="yes" xml:space="preserve">
          <source>A few general-purpose tools are shipped with perl, mostly because they came along modules included in the perl distribution.</source>
          <target state="translated">一些通用的工具是随perl一起发布的,主要是因为它们在perl发行版中附带了模块。</target>
        </trans-unit>
        <trans-unit id="6c69ec260ad056301204f0c643b8c2696665eb7e" translate="yes" xml:space="preserve">
          <source>A few methods are provided to do the &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; Your::Module tests =&amp;gt; 23&lt;/code&gt; part for you.</source>
          <target state="translated">提供了一些方法来帮助 &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; Your::Module tests =&amp;gt; 23&lt;/code&gt; &lt;a href=&quot;../../functions/use&quot;&gt;使用&lt;/a&gt; Your :: Module tests =&amp;gt; 23部分。</target>
        </trans-unit>
        <trans-unit id="aa6d4c905f963b3015f8686516337be08979225b" translate="yes" xml:space="preserve">
          <source>A few more:</source>
          <target state="translated">还有一些。</target>
        </trans-unit>
        <trans-unit id="6eb9b3626d6aeb9e84350d1131ed3080f1617e37" translate="yes" xml:space="preserve">
          <source>A few of the options need extra discussion here. When used, the C equivalent of the keys &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;compare&lt;/code&gt; and &lt;code&gt;prefix&lt;/code&gt; store pointers to C functions. In &lt;b&gt;DB_File&lt;/b&gt; these keys are used to store references to Perl subs. Below are templates for each of the subs:</source>
          <target state="translated">这里有一些选项需要额外讨论。使用时，键H的C等效项 &lt;code&gt;hash&lt;/code&gt; ， &lt;code&gt;compare&lt;/code&gt; 和 &lt;code&gt;prefix&lt;/code&gt; 存储指向C函数的指针。在&lt;b&gt;DB_File中，&lt;/b&gt;这些键用于存储对Perl子对象的引用。以下是每个子模块的模板：</target>
        </trans-unit>
        <trans-unit id="c283830e9199de7049f4c9e9b8481f0f4f024e4c" translate="yes" xml:space="preserve">
          <source>A few of these variables are considered &quot;read-only&quot;. This means that if you try to assign to this variable, either directly or indirectly through a reference, you'll raise a run-time exception.</source>
          <target state="translated">其中有几个变量被认为是 &quot;只读 &quot;变量。这意味着,如果你试图直接或通过引用间接地分配给这个变量,你会引发一个运行时异常。</target>
        </trans-unit>
        <trans-unit id="8090aa705fafbfcbe40caa6a39d4969f2ffa75f0" translate="yes" xml:space="preserve">
          <source>A few points to note about this example:</source>
          <target state="translated">关于这个例子,有几点需要注意。</target>
        </trans-unit>
        <trans-unit id="5940abb3e966e0e3ab0e5074976963a86d9bf337" translate="yes" xml:space="preserve">
          <source>A few special SV heads are not allocated from an arena, but are instead directly created in the interpreter structure, eg PL_sv_undef. The size of arenas can be changed from the default by setting PERL_ARENA_SIZE appropriately at compile time.</source>
          <target state="translated">一些特殊的SV头不是从竞技场中分配的,而是直接在解释器结构中创建的,例如PL_sv_undef。竞技场的大小可以通过在编译时适当地设置PERL_ARENA_SIZE来改变默认值。</target>
        </trans-unit>
        <trans-unit id="99bc1dc13c67f6154f44d88464d4083e5ca5c87d" translate="yes" xml:space="preserve">
          <source>A fifo is convenient when you want to connect a process to an unrelated one. When you open a fifo, the program will block until there's something on the other end.</source>
          <target state="translated">当你想把一个进程和一个不相关的进程连接起来的时候,一个fifo是很方便的。当你打开一个fifo时,程序会阻塞,直到另一端有东西。</target>
        </trans-unit>
        <trans-unit id="0034cae2f50c204559522cfff1ceebd6deb989fa" translate="yes" xml:space="preserve">
          <source>A file containing certain required definitions that you must include &amp;ldquo;ahead&amp;rdquo; of the rest of your program to do certain obscure operations. A C header file has a</source>
          <target state="translated">包含某些必需定义的文件，您必须在程序的其余部分之前&amp;ldquo;包含&amp;rdquo;某些特定的定义才能进行某些晦涩的操作。AC标头文件有一个</target>
        </trans-unit>
        <trans-unit id="731000aad647991373ca7dfb79bf96ee23280bc2" translate="yes" xml:space="preserve">
          <source>A file full of regular expressions to exclude when using 'make manifest' to generate the MANIFEST. These regular expressions are checked against each file path found in the distribution (so you're matching against &quot;t/foo.t&quot; not &quot;foo.t&quot;).</source>
          <target state="translated">当使用'make manifest'生成manifest时,需要排除的正则表达式的文件。这些正则表达式会根据发行版中找到的每个文件路径进行检查(所以你要匹配的是 &quot;t/foo.t &quot;而不是 &quot;foo.t&quot;)。</target>
        </trans-unit>
        <trans-unit id="a17865a45ecaf1ad63bbdbb5dd8742ba69a071dc" translate="yes" xml:space="preserve">
          <source>A file in XS format starts with a C language section which goes until the first &lt;code&gt;MODULE =&lt;/code&gt; directive. Other XS directives and XSUB definitions may follow this line. The &quot;language&quot; used in this part of the file is usually referred to as the XS language. &lt;b&gt;xsubpp&lt;/b&gt; recognizes and skips POD (see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;) in both the C and XS language sections, which allows the XS file to contain embedded documentation.</source>
          <target state="translated">XS格式的文件以C语言部分开头，直到第一个 &lt;code&gt;MODULE =&lt;/code&gt; 指令为止。其他XS指令和XSUB定义可能会遵循此行。在文件的此部分中使用的&amp;ldquo;语言&amp;rdquo;通常称为XS语言。&lt;b&gt;xsubpp可以&lt;/b&gt;识别和跳过C和XS语言部分中的POD（请参阅&lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;），这允许XS文件包含嵌入式文档。</target>
        </trans-unit>
        <trans-unit id="51841b4270c479a7cdbc29c3d5f66446edf393a3" translate="yes" xml:space="preserve">
          <source>A file test, where X is one of the letters listed below. This unary operator takes one argument, either a filename, a filehandle, or a dirhandle, and tests the associated file to see if something is true about it. If the argument is omitted, tests &lt;code&gt;$_&lt;/code&gt; , except for &lt;code&gt;-t&lt;/code&gt; , which tests STDIN. Unless otherwise documented, it returns &lt;code&gt;1&lt;/code&gt; for true and &lt;code&gt;''&lt;/code&gt; for false. If the file doesn't exist or can't be examined, it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Despite the funny names, precedence is the same as any other named unary operator. The operator may be any of:</source>
          <target state="translated">文件测试，其中X是下面列出的字母之一。此一元运算符采用一个参数（文件名，文件句柄或目录句柄），并测试关联的文件以查看其是否正确。如果省略该参数，则测试 &lt;code&gt;$_&lt;/code&gt; ，但 &lt;code&gt;-t&lt;/code&gt; 除外，后者测试STDIN。除非另有说明，否则它返回 &lt;code&gt;1&lt;/code&gt; 表示true，返回 &lt;code&gt;''&lt;/code&gt; 表示false。如果该文件不存在或无法检查，它将返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 并设置 &lt;code&gt;$!&lt;/code&gt; （errno）。尽管名称很有趣，但优先级与任何其他命名的一元运算符相同。运营商可以是以下任何一家：</target>
        </trans-unit>
        <trans-unit id="1c04b0088e704fdeb38d1fecd8838e16e9a29f09" translate="yes" xml:space="preserve">
          <source>A file test, where X is one of the letters listed below. This unary operator takes one argument, either a filename, a filehandle, or a dirhandle, and tests the associated file to see if something is true about it. If the argument is omitted, tests &lt;code&gt;$_&lt;/code&gt; , except for &lt;code&gt;-t&lt;/code&gt; , which tests STDIN. Unless otherwise documented, it returns &lt;code&gt;1&lt;/code&gt; for true and &lt;code&gt;''&lt;/code&gt; for false. If the file doesn't exist or can't be examined, it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Despite the funny names, precedence is the same as any other named unary operator. The operator may be any of:</source>
          <target state="translated">文件测试，其中X是下面列出的字母之一。此一元运算符采用一个参数（文件名，文件句柄或目录句柄），并测试关联的文件以查看其是否正确。如果省略该参数，则测试 &lt;code&gt;$_&lt;/code&gt; ，但 &lt;code&gt;-t&lt;/code&gt; 除外，后者测试STDIN。除非另有说明，否则它返回 &lt;code&gt;1&lt;/code&gt; 表示true，返回 &lt;code&gt;''&lt;/code&gt; 表示false。如果该文件不存在或无法检查，它将返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 并设置 &lt;code&gt;$!&lt;/code&gt; （errno）。尽管名称很有趣，但优先级与任何其他命名的一元运算符相同。运营商可以是以下任何一家：</target>
        </trans-unit>
        <trans-unit id="85304934df21007f1e6dacead79952e515167d3e" translate="yes" xml:space="preserve">
          <source>A file that controls the compilation of a program. Perl programs don&amp;rsquo;t usually need a &lt;b&gt;Makefile&lt;/b&gt; because the Perl compiler has plenty of self-control.</source>
          <target state="translated">控制程序编译的文件。Perl程序通常不需要&lt;b&gt;Makefile，&lt;/b&gt;因为Perl编译器具有很多自我控制功能。</target>
        </trans-unit>
        <trans-unit id="0ef0646f1946010fd71391d670cdd7f3f2cde9ba" translate="yes" xml:space="preserve">
          <source>A filehandle for catching standard output.</source>
          <target state="translated">一个用于捕获标准输出的文件柄。</target>
        </trans-unit>
        <trans-unit id="dddbea875ae221e63e546196812256d3f13f54a9" translate="yes" xml:space="preserve">
          <source>A filehandle is opened but the file operations are performed &quot;in-memory&quot; on a scalar variable. All the normal file operations can be performed on the handle. The scalar is considered a stream of bytes. Currently fileno($fh) returns -1.</source>
          <target state="translated">一个文件柄被打开,但文件操作是在一个标量变量上 &quot;在内存中 &quot;进行的。所有正常的文件操作都可以在句柄上进行。标量被认为是一个字节流,目前fileno($fh)返回-1。目前fileno($fh)返回-1。</target>
        </trans-unit>
        <trans-unit id="2ead9b8d6ddfb62275b7ebf2bc90be0c9e8b9ced" translate="yes" xml:space="preserve">
          <source>A filehandle that should read or write UTF-8</source>
          <target state="translated">一个应读或写UTF-8的文件柄。</target>
        </trans-unit>
        <trans-unit id="c2227149e71cd22222d8c43a50c19d04660c6c2c" translate="yes" xml:space="preserve">
          <source>A filehandle to write the C code to. If not given, then</source>
          <target state="translated">一个要写入C代码的文件柄。如果没有给定,那么</target>
        </trans-unit>
        <trans-unit id="51118efef78727e7eccbadc9f314bd7f4afcf597" translate="yes" xml:space="preserve">
          <source>A filehandle to write the XS code to. If not given, then</source>
          <target state="translated">一个要写入XS代码的文件柄。如果没有给定,那么</target>
        </trans-unit>
        <trans-unit id="94e7ed7be4ff1750888b6ea45dc5effd2b37d94d" translate="yes" xml:space="preserve">
          <source>A filehandle, from which the file will be read.</source>
          <target state="translated">一个文件柄,从这里读取文件。</target>
        </trans-unit>
        <trans-unit id="c34303a3b313a718df7cf274a0efcf1c25994c0c" translate="yes" xml:space="preserve">
          <source>A filetest operator, with exactly 4 exceptions: &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-A&lt;/code&gt; , and &lt;code&gt;-C&lt;/code&gt; , as these return numerical values, not boolean ones. The &lt;code&gt;-z&lt;/code&gt; filetest operator is not included in the exception list.</source>
          <target state="translated">一个filetest运算符，有4个例外： &lt;code&gt;-s&lt;/code&gt; ， &lt;code&gt;-M&lt;/code&gt; ， &lt;code&gt;-A&lt;/code&gt; 和 &lt;code&gt;-C&lt;/code&gt; ，因为它们返回数值，而不是布尔值。该 &lt;code&gt;-z&lt;/code&gt; filetest操作不包含在例外列表中。</target>
        </trans-unit>
        <trans-unit id="571b7a68e22aaaa36cb39947748347ab43ae89aa" translate="yes" xml:space="preserve">
          <source>A filter program, in the traditional Unix sense (input from stdin, output to stdout) that is passed on each .pm file during the build (in the pm_to_blib() phase). It is empty by default, meaning no filtering is done.</source>
          <target state="translated">一个传统Unix意义上的过滤程序 (输入来自stdin,输出到stdout),在构建过程中(在pm_to_blib()阶段)传递给每个.pm文件。默认情况下它是空的,这意味着没有进行过滤。</target>
        </trans-unit>
        <trans-unit id="fb35ae131a8a2012ab4bde2210fbfdcbd7023aa3" translate="yes" xml:space="preserve">
          <source>A fix for Proc::ProcessTable is to edit Makefile to explicitly remove the largefile flags from the ones MakeMaker picks up from Config.pm. This will result in Proc::ProcessTable being built under the correct environment. Everything should then be OK as long as Proc::ProcessTable doesn't try to share off_t's with the rest of perl, or if it does they should be explicitly specified as off64_t.</source>
          <target state="translated">对Proc::ProcessTable的修正是编辑Makefile,明确地从MakeMaker从Config.pm中获取的大文件标志中删除。这将导致 Proc::ProcessTable 在正确的环境下构建。只要 Proc::ProcessTable 不试图与 perl 的其它部分共享 off_t,一切都应该是正常的,如果要共享 off_t,则应该将其明确指定为 off64_t。</target>
        </trans-unit>
        <trans-unit id="a9d22545c3578b64eb5fa290d40cfb8cd3124e35" translate="yes" xml:space="preserve">
          <source>A fix for that problem is scheduled to be released in the following levels of AIX, all of which should be coming out in the 4th quarter of 2009:</source>
          <target state="translated">该问题的修复计划在以下级别的AIX中发布,所有这些版本都将在2009年第四季度推出。</target>
        </trans-unit>
        <trans-unit id="fbcd311c30c802b9eee4a011f2523c74bbb4eeb7" translate="yes" xml:space="preserve">
          <source>A fixed length thing, given as a [pointer, length] pair. If you know the length of a string at compile time you may use this instead of</source>
          <target state="translated">一个固定长度的东西,以[指针,长度]对的形式给出。如果你在编译时知道一个字符串的长度,你可以用这个来代替</target>
        </trans-unit>
        <trans-unit id="2dd9070969808d13493b31f8533aee2df5f82471" translate="yes" xml:space="preserve">
          <source>A fixed number of digits before (positive) or after (negative) the decimal point. For example, 123.45 has a precision of -2. 0 means an integer like 123 (or 120). A precision of 2 means two digits to the left of the decimal point are zero, so 123 with P = 1 becomes 120. Note that numbers with zeros before the decimal point may have different precisions, because 1200 can have p = 0, 1 or 2 (depending on what the initial value was). It could also have p &amp;lt; 0, when the digits after the decimal point are zero.</source>
          <target state="translated">小数点前（正）或后（负）的固定位数。例如，123.45的精度为-2。0表示整数，例如123（或120）。精度2表示小数点左边的两位数字为零，因此P = 1的123变为120。请注意，小数点前带有零的数字可能具有不同的精度，因为1200可以具有p = 0、1或2（取决于初始值）。当小数点后的数字为零时，它也可能具有p &amp;lt;0。</target>
        </trans-unit>
        <trans-unit id="27aa36567c7de687c1256c668f8713e83fe0a789" translate="yes" xml:space="preserve">
          <source>A flag for whether item 3 (if present) is a URL (like &quot;&lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt;&quot; is), in which case there should be no section attribute; a Pod name (like &quot;perldoc&quot; and &quot;Getopt::Std&quot; are); or possibly a man page name (like &quot;crontab(5)&quot; is).</source>
          <target state="translated">一个标志，指示第3项（如果存在）是否是URL（例如&amp;ldquo; &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt; &amp;rdquo;），在这种情况下，应该没有section属性；Pod名称（例如&amp;ldquo; perldoc&amp;rdquo;和&amp;ldquo; Getopt :: Std&amp;rdquo;）；或手册页名称（例如&amp;ldquo; crontab（5）&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="aa81fd53ffda939e60f21a6a48bc3fd1ecb33421" translate="yes" xml:space="preserve">
          <source>A floating point number potentially has a sign, an integral part, a decimal point, a fractional part, and an exponent. One or more of these parts is optional, so we need to check out the different possibilities. Floating point numbers which are in proper form include 123., 0.345, .34, -1e6, and 25.4E-72. As with integers, the sign out front is completely optional and can be matched by &lt;code&gt;[+-]?&lt;/code&gt;. We can see that if there is no exponent, floating point numbers must have a decimal point, otherwise they are integers. We might be tempted to model these with &lt;code&gt;\d*\.\d*&lt;/code&gt;, but this would also match just a single decimal point, which is not a number. So the three cases of floating point number without exponent are</source>
          <target state="translated">浮点数可能具有符号，整数部分，小数点，小数部分和指数。这些部分中的一个或多个是可选的，因此我们需要检查各种可能性。正确形式的浮点数包括123.，0.345，.34，-1e6和25.4E-72。与整数一样，签出前面完全是可选的，可以由 &lt;code&gt;[+-]?&lt;/code&gt; 匹配吗？。我们可以看到，如果没有指数，则浮点数必须带有小数点，否则为整数。我们可能会想用 &lt;code&gt;\d*\.\d*&lt;/code&gt; 为它们建模，但这也只会匹配一个小数点，而不是数字。因此，没有指数的浮点数的三种情况是</target>
        </trans-unit>
        <trans-unit id="ff8a1f9e295a3b368fdb0bcb2f6682d3f1a7706d" translate="yes" xml:space="preserve">
          <source>A floating point number. This typemap guarantees to return a variable cast to a &lt;code&gt;float&lt;/code&gt; .</source>
          <target state="translated">浮点数。此类型映射保证将变量强制类型转换为 &lt;code&gt;float&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb62089bcb14b38f0a60a1ce278c6aa2cfaf6aec" translate="yes" xml:space="preserve">
          <source>A flow of data into or out of a process as a steady sequence of bytes or characters, without the appearance of being broken up into packets. This is a kind of &lt;b&gt;interface&lt;/b&gt;&amp;mdash;the underlying &lt;b&gt;implementation&lt;/b&gt; may well break your data up into separate packets for delivery, but this is hidden from you.</source>
          <target state="translated">数据以稳定的字节或字符序列序列流入或流出进程，而不会被分解为数据包。这是一种&lt;b&gt;接口&lt;/b&gt; -基础&lt;b&gt;实现&lt;/b&gt;可能会将您的数据分解为单独的数据包进行传递，但这对您而言是隐藏的。</target>
        </trans-unit>
        <trans-unit id="f7f93ab55d0cd5dedac331be7a34ca8ef2c56a43" translate="yes" xml:space="preserve">
          <source>A form name &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; accepts will be applied as &lt;code&gt;$normalization_form&lt;/code&gt; . Acceptable names include &lt;code&gt;'NFD'&lt;/code&gt; , &lt;code&gt;'NFC'&lt;/code&gt; , &lt;code&gt;'NFKD'&lt;/code&gt; , and &lt;code&gt;'NFKC'&lt;/code&gt; . See &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; for detail. If omitted, &lt;code&gt;'NFD'&lt;/code&gt; is used.</source>
          <target state="translated">接受的格式名称 &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; 将用作 &lt;code&gt;$normalization_form&lt;/code&gt; 。可接受的名称包括 &lt;code&gt;'NFD'&lt;/code&gt; ， &lt;code&gt;'NFC'&lt;/code&gt; ， &lt;code&gt;'NFKD'&lt;/code&gt; 和 &lt;code&gt;'NFKC'&lt;/code&gt; 。有关详细信息，请参见 &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; 。如果省略，则使用 &lt;code&gt;'NFD'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c49b8a933b39ce175d6f4d01ed275b88dda586c3" translate="yes" xml:space="preserve">
          <source>A form of &lt;b&gt;scalar context&lt;/b&gt; in which an &lt;b&gt;expression&lt;/b&gt; is not expected to return any &lt;b&gt;value&lt;/b&gt; at all and is evaluated for its &lt;b&gt;side effects&lt;/b&gt; alone.</source>
          <target state="translated">&lt;b&gt;标量上下文的&lt;/b&gt;一种形式，在该形式中，&lt;b&gt;表达式&lt;/b&gt;完全不希望返回任何&lt;b&gt;值&lt;/b&gt;，并且仅对其&lt;b&gt;副作用&lt;/b&gt;进行评估。</target>
        </trans-unit>
        <trans-unit id="95b8b92c738006a6a5118bef738de47b796e9ea2" translate="yes" xml:space="preserve">
          <source>A formal grammar would look similar to the following:</source>
          <target state="translated">一个正式的语法将类似于以下内容:</target>
        </trans-unit>
        <trans-unit id="8f6424f6bb5e3764fd5434bcd18cd75bdd7582fd" translate="yes" xml:space="preserve">
          <source>A format name of &quot;comment&quot; is common for just making notes (presumably to yourself) that won't appear in any formatted version of the Pod document:</source>
          <target state="translated">&quot;评论 &quot;的格式名称很常见,只是做笔记(大概是给自己的),不会出现在任何格式化的Pod文档版本中。</target>
        </trans-unit>
        <trans-unit id="d26b5fa96c287794c375f977fd86d1fe4bad1833" translate="yes" xml:space="preserve">
          <source>A formatting code starts with a capital letter (just US-ASCII [A-Z]) followed by a &quot;&amp;lt;&quot;, any number of characters, and ending with the first matching &quot;&amp;gt;&quot;. Examples:</source>
          <target state="translated">格式代码以大写字母（仅是US-ASCII [AZ]）开头，后跟&amp;ldquo; &amp;lt;&amp;rdquo;，任意数量的字符，并以第一个匹配的&amp;ldquo;&amp;gt;&amp;rdquo;结尾。例子：</target>
        </trans-unit>
        <trans-unit id="e1ebaf29b6e50a9147fa41854529f9f91464bbca" translate="yes" xml:space="preserve">
          <source>A formatting code starts with a capital letter (just US-ASCII [A-Z]) followed by two or more &quot;&amp;lt;&quot;'s, one or more whitespace characters, any number of characters, one or more whitespace characters, and ending with the first matching sequence of two or more &quot;&amp;gt;&quot;'s, where the number of &quot;&amp;gt;&quot;'s equals the number of &quot;&amp;lt;&quot;'s in the opening of this formatting code. Examples:</source>
          <target state="translated">格式代码以大写字母（仅US-ASCII [AZ]）开头，后跟两个或多个&amp;ldquo; &amp;lt;&amp;rdquo;，一个或多个空格字符，任意数量的字符，一个或多个空格字符，并以第一个结尾两个或多个&amp;ldquo;&amp;gt;&amp;rdquo;的匹配序列，其中&amp;ldquo;&amp;gt;&amp;rdquo;的数量等于此格式代码开头的&amp;ldquo; &amp;lt;&amp;rdquo;的数量。例子：</target>
        </trans-unit>
        <trans-unit id="ee13838be926e942481224190d1b48d665a53c86" translate="yes" xml:space="preserve">
          <source>A free perl5-based PERL.NLM for Novell Netware is available in precompiled binary and source code form from &lt;a href=&quot;http://www.novell.com/&quot;&gt;http://www.novell.com/&lt;/a&gt; as well as from CPAN.</source>
          <target state="translated">可从&lt;a href=&quot;http://www.novell.com/&quot;&gt;http://www.novell.com/&lt;/a&gt;以及CPAN 以预编译的二进制和源代码形式获得针对Novell Netware的免费的基于Perl5的PERL.NLM 。</target>
        </trans-unit>
        <trans-unit id="601ccb979c895092a89a9db855c8bb290abdfbb7" translate="yes" xml:space="preserve">
          <source>A from scratch implementation of buffering for PerlIO. Provides fast access to the buffer for &lt;code&gt;sv_gets&lt;/code&gt; which implements perl's readline/&amp;lt;&amp;gt; and in general attempts to minimize data copying.</source>
          <target state="translated">从头开始的PerlIO缓冲实现。提供对 &lt;code&gt;sv_gets&lt;/code&gt; 缓冲区的快速访问，该缓冲区实现了perl的readline / &amp;lt;&amp;gt;，并且通常会尝试最大程度地减少数据复制。</target>
        </trans-unit>
        <trans-unit id="0f062561102eb36fb52de67c711e92bb30c79c71" translate="yes" xml:space="preserve">
          <source>A full commandline to run via &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;. During execution, the environment variable PERL is set to $^X (but with an absolute path). If &lt;code&gt;commandline&lt;/code&gt; is specified, &lt;code&gt;args&lt;/code&gt; is not used.</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 运行的完整命令行。在执行期间，环境变量PERL设置为$ ^ X（但具有绝对路径）。如果指定了 &lt;code&gt;commandline&lt;/code&gt; ，则不使用 &lt;code&gt;args&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14cec31abd2e629547d353d78977abf26c0ffa5f" translate="yes" xml:space="preserve">
          <source>A full set of HTML documentation is installed, so you should be able to use it if you have a web browser installed on your system.</source>
          <target state="translated">安装了一套完整的HTML文档,所以如果你的系统中安装了Web浏览器,应该可以使用它。</target>
        </trans-unit>
        <trans-unit id="6a2c1a54fe4430e99127181c7879f97150ac83b4" translate="yes" xml:space="preserve">
          <source>A fully qualified filename such as</source>
          <target state="translated">一个完全合格的文件名,如</target>
        </trans-unit>
        <trans-unit id="66350a7ced5e0598bbaa01d95aa21c1aa8b64d66" translate="yes" xml:space="preserve">
          <source>A function named &lt;code&gt;new&lt;/code&gt; must not be explicitly defined in a class created by &lt;code&gt;struct&lt;/code&gt; .</source>
          <target state="translated">不能在 &lt;code&gt;struct&lt;/code&gt; 创建的类中显式定义名为 &lt;code&gt;new&lt;/code&gt; 的函数。</target>
        </trans-unit>
        <trans-unit id="2945149f02dd35ba51bde27d2145bb414391b9dd" translate="yes" xml:space="preserve">
          <source>A function returning a single scalar with &lt;code&gt;#define&lt;/code&gt; definitions for the constants used internally between the generated C and XS functions.</source>
          <target state="translated">一个函数，返回一个带有 &lt;code&gt;#define&lt;/code&gt; 定义的标量，用于在生成的C和XS函数之间内部使用的常量。</target>
        </trans-unit>
        <trans-unit id="b69855856bd43ed93ca10429f84d959193788fea" translate="yes" xml:space="preserve">
          <source>A function that needs a filehandle of its own must use &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; on a complete typeglob. This can be used to create new symbol table entries:</source>
          <target state="translated">需要自己的文件句柄的函数必须在完整的typeglob上使用 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; 。这可以用来创建新的符号表条目：</target>
        </trans-unit>
        <trans-unit id="074e275ec83817fc8f7919a77c7d1bc574268f70" translate="yes" xml:space="preserve">
          <source>A function that returns a &lt;b&gt;list&lt;/b&gt; of C subroutine definitions that return the value and type of constants when passed the name by the XS wrapper.</source>
          <target state="translated">该函数返回C子例程定义的&lt;b&gt;列表&lt;/b&gt;，当XS包装器传递名称时，该子例程定义返回常量的值和类型。</target>
        </trans-unit>
        <trans-unit id="16f5ca42729ef594d519db59b85f9698b43a3153" translate="yes" xml:space="preserve">
          <source>A function to generate perl code for Makefile.PL that will regenerate the constant subroutines. Parameters are named as passed to &lt;code&gt;WriteConstants&lt;/code&gt; , with the addition of &lt;code&gt;INDENT&lt;/code&gt; to specify the number of leading spaces (default 2).</source>
          <target state="translated">生成用于Makefile.PL的perl代码的函数，该代码将重新生成常量子例程。参数被命名为传递给 &lt;code&gt;WriteConstants&lt;/code&gt; ，并加上 &lt;code&gt;INDENT&lt;/code&gt; 来指定前导空格的数量（默认为2）。</target>
        </trans-unit>
        <trans-unit id="6f1112f59bf733c8ebebfbb190c9c3efe0aeac9b" translate="yes" xml:space="preserve">
          <source>A function to generate the AUTOLOAD subroutine for the module</source>
          <target state="translated">为模块生成AUTOLOAD子程序的函数。</target>
        </trans-unit>
        <trans-unit id="b0a02614782733bf06479ea297bf790f7927505f" translate="yes" xml:space="preserve">
          <source>A function to generate the XS code to implement the perl subroutine</source>
          <target state="translated">生成XS代码以实现perl子程序的函数。</target>
        </trans-unit>
        <trans-unit id="94d15a8aa6cbd7f8b0a2a414f5a5f7d2b35f7284" translate="yes" xml:space="preserve">
          <source>A function which returns a 7 bit ASCII correctly \ escaped version of the string passed suitable for C's &quot;&quot; or ''. It will die if passed Unicode characters.</source>
          <target state="translated">一个函数,它返回一个7位ASCII码的正确转义版本,适用于C的&quot;&quot;或''。如果传入Unicode字符,它将死亡。</target>
        </trans-unit>
        <trans-unit id="c45b17fcb375003bf4d5bd87967dc1245beb7fd4" translate="yes" xml:space="preserve">
          <source>A function which returns a 7 bit ASCII correctly \ escaped version of the string passed suitable for a perl &quot;&quot; string.</source>
          <target state="translated">一个函数,它返回一个7位ASCII码的正确转义版本,适合perl&quot;&quot;字符串。</target>
        </trans-unit>
        <trans-unit id="5e16a22c3d8b0f460cffd4d274f2db99a8a3ae51" translate="yes" xml:space="preserve">
          <source>A fundamental feature of regular expression matching involves the notion called</source>
          <target state="translated">正则表达式匹配的一个基本特征涉及到一个叫做</target>
        </trans-unit>
        <trans-unit id="2100c9b6a5bc83c2e9c2b9fd7c9dc09b08c1aad2" translate="yes" xml:space="preserve">
          <source>A general function for editing the structure of an existing chain of op_sibling nodes. By analogy with the perl-level splice() function, allows you to delete zero or more sequential nodes, replacing them with zero or more different nodes. Performs the necessary op_first/op_last housekeeping on the parent node and op_sibling manipulation on the children. The last deleted node will be marked as as the last node by updating the op_sibling/op_sibparent or op_moresib field as appropriate.</source>
          <target state="translated">一个编辑现有的 op_sibling 节点链结构的通用函数,与 perl 级别的 splice()函数类似,允许你删除零个或多个连续节点,替换成零个或多个不同的节点。类似于perl级别的splice()函数,允许你删除0个或更多的顺序节点,用0个或更多不同的节点替换。在父节点上执行必要的 op_first/op_last 内务管理,在子节点上执行 op_sibling 操作。通过更新op_sibling/op_sibparent或op_moresib字段,最后删除的节点将被标记为最后一个节点。</target>
        </trans-unit>
        <trans-unit id="16b0d3e317f9f7b5ddb72b16cb53e05b583e9133" translate="yes" xml:space="preserve">
          <source>A general solution to the serialization problem would require another level of registry, one that associates</source>
          <target state="translated">序列化问题的一般解决方案将需要另一个层次的登记处,一个将以下内容关联起来的登记处。</target>
        </trans-unit>
        <trans-unit id="ed526677b5c541991128da9f35ea30909114035f" translate="yes" xml:space="preserve">
          <source>A generic &lt;b&gt;object&lt;/b&gt; type; that is, a &lt;b&gt;class&lt;/b&gt; from which other, more specific classes are derived genetically by &lt;b&gt;inheritance&lt;/b&gt;. Also called a &amp;ldquo;superclass&amp;rdquo; by people who respect their ancestors.</source>
          <target state="translated">通用&lt;b&gt;对象&lt;/b&gt;类型；即，&lt;b&gt;类&lt;/b&gt;从其它更特定的类是通过遗传衍生&lt;b&gt;继承&lt;/b&gt;。尊敬祖先的人也称其为&amp;ldquo;超阶级&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0a9918e5dda4793cf3ecc366ce8266f117c17195" translate="yes" xml:space="preserve">
          <source>A generic file fetching mechanism</source>
          <target state="translated">一个通用的文件获取机制</target>
        </trans-unit>
        <trans-unit id="a625d1d6246943bf40d50608e758f2319151f17b" translate="yes" xml:space="preserve">
          <source>A generic input parsing/checking mechanism.</source>
          <target state="translated">一个通用的输入解析/检查机制。</target>
        </trans-unit>
        <trans-unit id="af15d07731a55a9ecedf87f6009285e2acc4ef80" translate="yes" xml:space="preserve">
          <source>A git GUI shell extension for Windows such as TortoiseGit will cause the build and later &lt;code&gt;make test&lt;/code&gt; to run much slower since every file is checked for its git status as soon as it is created and/or modified. TortoiseGit doesn't cause any test failures or build problems unlike the antivirus software described above, but it does cause similar slowness. It is suggested to use Task Manager to look for background processes which use high CPU amounts during the building process.</source>
          <target state="translated">Windows的git GUI shell扩展（例如TortoiseGit）将导致构建和以后的 &lt;code&gt;make test&lt;/code&gt; 运行缓慢得多，因为每个文件在创建和/或修改后都会立即检查其git状态。与上述防病毒软件不同，TortoiseGit不会导致任何测试失败或构建问题，但确实会导致类似的缓慢情况。建议使用任务管理器查找在构建过程中占用大量CPU的后台进程。</target>
        </trans-unit>
        <trans-unit id="ca6613321ff6c370136985bf48b668224b2f6734" translate="yes" xml:space="preserve">
          <source>A gizmo that transforms some number of input values to some number of output values, often built into a language with a special syntax or symbol. A given operator may have specific expectations about what &lt;b&gt;types&lt;/b&gt; of data you give as its arguments (&lt;b&gt;operands&lt;/b&gt;) and what type of data you want back from it.</source>
          <target state="translated">将小数目的输入值转换为小数目的输出值的小控件，通常将其内置到具有特殊语法或符号的语言中。给定的运算符可能对您将其作为参数（&lt;b&gt;操作数&lt;/b&gt;）给出的数据类型以及要从中返回的数据&lt;b&gt;类型&lt;/b&gt;有特定的期望。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b0da5e61aa8557d6b28694e8c5217513361c3a66" translate="yes" xml:space="preserve">
          <source>A glossary of terms (technical and otherwise) used in the Perl documentation, derived from the Glossary of</source>
          <target state="translated">Perl文档中使用的术语(技术和其他方面)的词汇表,来源于《Perl术语表》。</target>
        </trans-unit>
        <trans-unit id="b29b7f7af6cfd5aa471dc4da158609e558212777" translate="yes" xml:space="preserve">
          <source>A glyph used in magic. Or, for Perl, the symbol in front of a variable name, such as &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , and &lt;code&gt;%&lt;/code&gt; .</source>
          <target state="translated">魔术中使用的字形。或者，对于Perl，在变量名前面的符号，例如 &lt;code&gt;$&lt;/code&gt; ， &lt;code&gt;@&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="010767009a82e3c3f2315997ed16da6d8fa110ca" translate="yes" xml:space="preserve">
          <source>A good book on OO on Perl is the &quot;Object-Oriented Perl&quot; by Damian Conway from Manning Publications, or &quot;Intermediate Perl&quot; by Randal Schwartz, brian d foy, and Tom Phoenix from O'Reilly Media.</source>
          <target state="translated">关于Perl的OO的好书是Manning Publications的Damian Conway的 &quot;Object-Oriented Perl&quot;,或者是O'Reilly Media的Randal Schwartz、brian d foy和Tom Phoenix的 &quot;Intermediate Perl&quot;。</target>
        </trans-unit>
        <trans-unit id="b82c3e9cadf17adecf1d24dc6cb64a89ca8103d6" translate="yes" xml:space="preserve">
          <source>A good place to start is &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;, and you can use &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for reference.</source>
          <target state="translated">&lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;是一个很好的起点，您可以使用&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;作为参考。</target>
        </trans-unit>
        <trans-unit id="878d4536576dbff5139c196eb475074b04b81dfd" translate="yes" xml:space="preserve">
          <source>A good test case has most of these attributes: short, simple code; few dependencies on external commands, modules, or libraries; no platform-dependent code (unless it's a platform-specific bug); clear, simple documentation.</source>
          <target state="translated">一个好的测试用例具有这些属性中的大部分:短小、简单的代码;对外部命令、模块或库的依赖性小;没有平台依赖性的代码(除非是平台特有的错误);清晰、简单的文档。</target>
        </trans-unit>
        <trans-unit id="819fe6a0aff125bab30e82da5634d29a9188e255" translate="yes" xml:space="preserve">
          <source>A good test case is almost always a good candidate to be included in Perl's test suite. If you have the time, consider writing your test case so that it can be easily included into the standard test suite.</source>
          <target state="translated">一个好的测试用例几乎总是可以被包含在Perl的测试套件中。如果你有时间,可以考虑编写你的测试用例,使它可以很容易地被包含在标准测试套件中。</target>
        </trans-unit>
        <trans-unit id="6800c5039fcfc25d3805f20efcfc998a8922a07e" translate="yes" xml:space="preserve">
          <source>A grab bag of methods to generate specific macros and commands.</source>
          <target state="translated">生成特定宏和命令的方法的抓包。</target>
        </trans-unit>
        <trans-unit id="52f74d52da3fd8ec9d4b9513d833d3c381a80abc" translate="yes" xml:space="preserve">
          <source>A grammar for the Test Anything Protocol.</source>
          <target state="translated">测试任何东西协议的语法。</target>
        </trans-unit>
        <trans-unit id="4068f0366f48575a0048eca3205a24ad39495e7b" translate="yes" xml:space="preserve">
          <source>A grammar form might be something like this:</source>
          <target state="translated">语法形式可能是这样的。</target>
        </trans-unit>
        <trans-unit id="19193405de37cb91769fc940baebbd6ae904906a" translate="yes" xml:space="preserve">
          <source>A graphene is an allotrope of carbon arranged in a hexagonal crystal lattice one atom thick. A &lt;b&gt;grapheme&lt;/b&gt;, or more fully, a</source>
          <target state="translated">石墨烯是一种碳的同素异形体，它排列在一个原子厚的六边形晶格中。一&lt;b&gt;字形&lt;/b&gt;，或更充分，一</target>
        </trans-unit>
        <trans-unit id="07663ed8c039244f1bbba8bbd0f2248a550eeeb7" translate="yes" xml:space="preserve">
          <source>A graphical representation of complex numbers is possible in a plane (also called the</source>
          <target state="translated">在平面上可以用图形来表示复数(也叫作</target>
        </trans-unit>
        <trans-unit id="b2a17fedc722e35cf530893f218ec96ab466a1ef" translate="yes" xml:space="preserve">
          <source>A great circle is section of a circle that contains the circle diameter: the shortest distance between two (non-antipodal) points on the spherical surface goes along the great circle connecting those two points.</source>
          <target state="translated">大圆是包含圆直径的圆的截面:球面上两点(非对角)之间的最短距离沿连接这两点的大圆走。</target>
        </trans-unit>
        <trans-unit id="cf830d0f970841c8b5873e5f5dc448f292f1330c" translate="yes" xml:space="preserve">
          <source>A group of related modules on &lt;b&gt;CPAN&lt;/b&gt;. (Also sometimes refers to a group of command-line switches grouped into one &lt;b&gt;switch cluster&lt;/b&gt;.)</source>
          <target state="translated">&lt;b&gt;CPAN&lt;/b&gt;上的一组相关模块。 （有时也指将一组命令行开关分组为一个&lt;b&gt;开关集群&lt;/b&gt;。）</target>
        </trans-unit>
        <trans-unit id="d92a635a2c1e502bba680458b972125c4a0be466" translate="yes" xml:space="preserve">
          <source>A group that is required to bundle a set of alternatives may or may not be useful as a capturing group. If it isn't, it just creates a superfluous addition to the set of available capture group values, inside as well as outside the regexp. Non-capturing groupings, denoted by &lt;code&gt;(?:regexp)&lt;/code&gt;, still allow the regexp to be treated as a single unit, but don't establish a capturing group at the same time. Both capturing and non-capturing groupings are allowed to co-exist in the same regexp. Because there is no extraction, non-capturing groupings are faster than capturing groupings. Non-capturing groupings are also handy for choosing exactly which parts of a regexp are to be extracted to matching variables:</source>
          <target state="translated">捆绑一组备选方案所必需的组作为捕获组可能有用也可能没有用。如果不是这样，它只会在正则表达式的内部和外部为可用捕获组值的集合创建多余的内容。以 &lt;code&gt;(?:regexp)&lt;/code&gt; 表示的非捕获组仍然可以将正则表达式视为一个单元，但不能同时建立捕获组。捕获组和非捕获组都可以共存于同一正则表达式中。因为没有提取，所以非捕获分组比捕获分组要快。非捕获分组对于准确选择正则表达式的哪些部分要提取到匹配变量也很方便：</target>
        </trans-unit>
        <trans-unit id="e98254b9797c79a405fb849ceb15e69b1be1e9de" translate="yes" xml:space="preserve">
          <source>A handful of characters have a dedicated</source>
          <target state="translated">少数角色有专门的</target>
        </trans-unit>
        <trans-unit id="f93caa5208bfa6818a90d520fb7ad0e15665c128" translate="yes" xml:space="preserve">
          <source>A handler for an attributes with an all-lowercase name was declared. An attribute with an all-lowercase name might have a meaning to Perl itself some day, even though most don't yet. Use a mixed-case attribute name, instead.</source>
          <target state="translated">声明了一个全小写的属性的处理程序。一个全小写的属性名也许有一天会对 Perl 本身有意义,尽管大多数属性名还没有。请使用混合大写的属性名。</target>
        </trans-unit>
        <trans-unit id="c3e6d55f9badd1667902eb5523efa20bcbd3e70c" translate="yes" xml:space="preserve">
          <source>A handler for attributes of the specified name</source>
          <target state="translated">对指定名称的属性进行处理</target>
        </trans-unit>
        <trans-unit id="49edbe08e4bfabb8ba065c602451240e8c0f2a33" translate="yes" xml:space="preserve">
          <source>A handy tag name for a</source>
          <target state="translated">一个方便的标签名称,用于</target>
        </trans-unit>
        <trans-unit id="3aa757aa90e3b991f02cc566dd247ec484d84771" translate="yes" xml:space="preserve">
          <source>A hash &lt;code&gt;%DB::sub&lt;/code&gt; is maintained, whose keys are subroutine names and whose values have the form &lt;code&gt;filename:startline-endline&lt;/code&gt; . &lt;code&gt;filename&lt;/code&gt; has the form &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; for subroutines defined inside &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">保留哈希 &lt;code&gt;%DB::sub&lt;/code&gt; ，其键为子例程名称，其值的格式为 &lt;code&gt;filename:startline-endline&lt;/code&gt; 。 &lt;code&gt;filename&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; s中定义的子例程的格式为 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44b55c7f5cfe4830cdb1fa796511bc1073b11348" translate="yes" xml:space="preserve">
          <source>A hash can be initialized using a literal list holding pairs of items to be interpreted as a key and a value:</source>
          <target state="translated">哈希可以使用一个字面列表来初始化,该列表中的项目对被解释为一个键和一个值。</target>
        </trans-unit>
        <trans-unit id="8a814541e8cdf1052da6ce7b4056b3b5847f1f69" translate="yes" xml:space="preserve">
          <source>A hash is an ideal mechanism to store the mapping between C and Perl.</source>
          <target state="translated">哈希是存储C和Perl之间映射的理想机制。</target>
        </trans-unit>
        <trans-unit id="70381f72f3a7fd8e9863739e409cd4fabcba3c1e" translate="yes" xml:space="preserve">
          <source>A hash of array references in list context. Each entry of the hash has the fully qualified method name as its key and a reference to an array containing the method's list-context return values as its value.</source>
          <target state="translated">列表上下文中数组引用的哈希。哈希的每个条目都以完全限定的方法名作为键,并以包含该方法的列表上下文返回值的数组引用作为值。</target>
        </trans-unit>
        <trans-unit id="5ea60218a99582e9bc2b801ff2d5e8c50e9c5afa" translate="yes" xml:space="preserve">
          <source>A hash of hashes keyed on perl version and on module name. If a module is defined it indicates that that module is deprecated in that perl version and is scheduled for removal from core at some future point.</source>
          <target state="translated">一个以perl版本和模块名称为关键字的哈希值。如果定义了一个模块,则表示该模块在该perl版本中已被废弃,并计划在未来某个时间从核心中移除。</target>
        </trans-unit>
        <trans-unit id="3ce60ae7ced566f5220eb260ad49e428425ac3a8" translate="yes" xml:space="preserve">
          <source>A hash of hashes that is keyed on perl version as indicated in $]. The second level hash is module =&amp;gt; version pairs.</source>
          <target state="translated">散列的哈希值，按$]中的说明在perl版本上键入。第二层哈希是模块=&amp;gt;版本对。</target>
        </trans-unit>
        <trans-unit id="5c605211961bb9e43df625e92f911448dae2ef07" translate="yes" xml:space="preserve">
          <source>A hash of modules that are needed to build your module but not run it.</source>
          <target state="translated">构建模块所需的模块的散列,但不能运行它。</target>
        </trans-unit>
        <trans-unit id="e6392db0e8aa8a4e0a54f37942aac32926d2e82c" translate="yes" xml:space="preserve">
          <source>A hash of modules that are needed to run your module. The keys are the module names ie. Test::More, and the minimum version is the value. If the required version number is 0 any version will do.</source>
          <target state="translated">运行你的模块所需模块的哈希值。键是模块的名称,例如:Test::More,最小版本是模块的值。如果所需的版本号是0,那么任何版本都可以。</target>
        </trans-unit>
        <trans-unit id="922e915de9e8740eca506cd44d1ed8c10a9b1671" translate="yes" xml:space="preserve">
          <source>A hash of modules that are needed to test your module but not run or build it.</source>
          <target state="translated">需要测试你的模块,但不需要运行或构建它的模块的哈希。</target>
        </trans-unit>
        <trans-unit id="cd4d1c09ebac99b02cf9a7c9fa8cd90d4f94f599" translate="yes" xml:space="preserve">
          <source>A hash of modules that are required to run Makefile.PL itself, but not to run your distribution.</source>
          <target state="translated">运行Makefile.PL本身所需的模块的散列,但不是运行你的发行版。</target>
        </trans-unit>
        <trans-unit id="f704787fb624926417400f97106f18daa25dcf15" translate="yes" xml:space="preserve">
          <source>A hash of the POSIX realtime signal handlers. It is an extension of the standard &lt;code&gt;%SIG&lt;/code&gt; , the &lt;code&gt;$POSIX::SIGRT{SIGRTMIN}&lt;/code&gt; is roughly equivalent to &lt;code&gt;$SIG{SIGRTMIN}&lt;/code&gt; , but the right POSIX moves (see below) are made with the &lt;code&gt;POSIX::SigSet&lt;/code&gt; and &lt;code&gt;POSIX::sigaction&lt;/code&gt; instead of accessing the &lt;code&gt;%SIG&lt;/code&gt; .</source>
          <target state="translated">POSIX实时信号处理程序的哈希。它是标准 &lt;code&gt;%SIG&lt;/code&gt; 的扩展， &lt;code&gt;$POSIX::SIGRT{SIGRTMIN}&lt;/code&gt; 大致等同于 &lt;code&gt;$SIG{SIGRTMIN}&lt;/code&gt; ，但是正确的POSIX移动（见下文）是由 &lt;code&gt;POSIX::SigSet&lt;/code&gt; 和 &lt;code&gt;POSIX::sigaction&lt;/code&gt; 而不是访问 &lt;code&gt;%SIG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60ab26088a220041ec5c97911d9e6f565f5cbd7a" translate="yes" xml:space="preserve">
          <source>A hash or array element can be true only if it's defined and defined only if it exists, but the reverse doesn't necessarily hold true.</source>
          <target state="translated">一个哈希或数组元素只有在它被定义的情况下才能为真,只有在它存在的情况下才能被定义,但反之则不一定成立。</target>
        </trans-unit>
        <trans-unit id="0bf79c7c035d7be8a20888854f2234466da28ff7" translate="yes" xml:space="preserve">
          <source>A hash reference containing various parsing options (see below)</source>
          <target state="translated">一个包含各种解析选项的哈希引用(见下文)。</target>
        </trans-unit>
        <trans-unit id="71468d46c3d10b4d4aab17a5abca352e48601869" translate="yes" xml:space="preserve">
          <source>A hash represents a set of key/value pairs:</source>
          <target state="translated">哈希表示一组键/值对。</target>
        </trans-unit>
        <trans-unit id="10f78a1f223b35e25505609f4916f6f91875834d" translate="yes" xml:space="preserve">
          <source>A hash that contains information on the appropriate bug tracker for each core module.</source>
          <target state="translated">一个包含每个核心模块的相应错误跟踪器信息的哈希值。</target>
        </trans-unit>
        <trans-unit id="567327a8b7280b6715ced030a81d31782682314b" translate="yes" xml:space="preserve">
          <source>A hash that contains information on where patches should be directed for each core module.</source>
          <target state="translated">一个哈希值,包含每个核心模块的补丁应指向何处的信息。</target>
        </trans-unit>
        <trans-unit id="9f6e2604d963e87b1664555e25f241bb06bae1e9" translate="yes" xml:space="preserve">
          <source>A hash that maps from each Pod filespec to its pod-name (like &quot;/whatever/plib/Stuff/Thing.pm&quot; =&amp;gt; &quot;Stuff::Thing&quot;)</source>
          <target state="translated">从每个Pod文件规范映射到其pod名称的哈希（例如&amp;ldquo; /whatever/plib/Stuff/Thing.pm&amp;rdquo; =&amp;gt;&amp;ldquo; Stuff :: Thing&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="215fe982a4e5c65f0b82e82b7b97c0bfc5c0deef" translate="yes" xml:space="preserve">
          <source>A hash that maps from each pod-name to the filespec (like &quot;Stuff::Thing&quot; =&amp;gt; &quot;/whatever/plib/Stuff/Thing.pm&quot;)</source>
          <target state="translated">从每个容器名称映射到文件规范的哈希（例如&amp;ldquo; Stuff :: Thing&amp;rdquo; =&amp;gt;&amp;ldquo; /whatever/plib/Stuff/Thing.pm&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="bb3108415359d307ae0dd29af4dd93824067960c" translate="yes" xml:space="preserve">
          <source>A hashref of items to add to the CPAN Meta file (</source>
          <target state="translated">要添加到CPAN元文件中的项目的哈希福德(</target>
        </trans-unit>
        <trans-unit id="039b44468fab1aa4f939b768b655c31c005e5690" translate="yes" xml:space="preserve">
          <source>A hashref with one or more of the keys &lt;code&gt;distribution&lt;/code&gt; , &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;perl&lt;/code&gt; , &lt;code&gt;perlconfig&lt;/code&gt; , and &lt;code&gt;env&lt;/code&gt; that specify whether a document is targeted at a specific CPAN distribution or installation. Keys prefixed with &lt;code&gt;not_&lt;/code&gt; negates the corresponding match.</source>
          <target state="translated">具有一个或多个键 &lt;code&gt;distribution&lt;/code&gt; ， &lt;code&gt;module&lt;/code&gt; ， &lt;code&gt;perl&lt;/code&gt; ， &lt;code&gt;perlconfig&lt;/code&gt; 和 &lt;code&gt;env&lt;/code&gt; 的hashref，它们指定文档是针对特定的CPAN发行版还是安装。前缀为 &lt;code&gt;not_&lt;/code&gt; 的键会否定对应的匹配项。</target>
        </trans-unit>
        <trans-unit id="8c60ca8fe75e29a9dfda50be5b6bb79ab9c86c02" translate="yes" xml:space="preserve">
          <source>A heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt; ) without any text? That ain't no heading!</source>
          <target state="translated">没有任何文本的标题（ &lt;code&gt;=head1&lt;/code&gt; &lt;code&gt;=head2&lt;/code&gt; 或= head2）？那不是标题！</target>
        </trans-unit>
        <trans-unit id="f9832f7772423825e7be09c103f042abd3956ccc" translate="yes" xml:space="preserve">
          <source>A hex dump of &lt;code&gt;$berbuf&lt;/code&gt; , with spaces inserted at the right places, shows 01 8100 8101 81807F. Since the last byte is always less than 128, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; knows where to stop.</source>
          <target state="translated">&lt;code&gt;$berbuf&lt;/code&gt; 十六进制转储（在正确的位置插入空格）显示01 8100 8101 81807F。由于最后一个字节始终小于128，因此 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 知道在哪里停止。</target>
        </trans-unit>
        <trans-unit id="38e7070b1f249f379f9a778af2f10d3b11497505" translate="yes" xml:space="preserve">
          <source>A hierarchy of &quot;categories&quot; have been defined to allow groups of warnings to be enabled/disabled in isolation.</source>
          <target state="translated">定义了一个 &quot;类别 &quot;的层次结构,以允许单独启用/禁用一组警告。</target>
        </trans-unit>
        <trans-unit id="536684f67238bfdb66acbda52de51ea79291a12f" translate="yes" xml:space="preserve">
          <source>A is the root class, B is a subclass of A, C is a subclass of B, and D is another subclass of A.</source>
          <target state="translated">A是根类,B是A的一个子类,C是B的一个子类,D是A的另一个子类。</target>
        </trans-unit>
        <trans-unit id="8f3e40034aa0308d28f4dfc54288a8825f6cfd1e" translate="yes" xml:space="preserve">
          <source>A kind of &lt;b&gt;overloading&lt;/b&gt; that you can do on built-in &lt;b&gt;operators&lt;/b&gt; to make them work on &lt;b&gt;objects&lt;/b&gt; as if the objects were ordinary scalar values, but with the actual semantics supplied by the object class. This is set up with the overload &lt;b&gt;pragma&lt;/b&gt;&amp;mdash;see Camel chapter 13, &amp;ldquo;Overloading&amp;rdquo;.</source>
          <target state="translated">A类&lt;b&gt;超载&lt;/b&gt;，你可以内置在做&lt;b&gt;运营商&lt;/b&gt;，使他们的工作&lt;b&gt;对象&lt;/b&gt;，如同对象是普通的标值，但该对象类提供的实际语义。这是通过过载&lt;b&gt;编译指令设置的&lt;/b&gt; &amp;mdash;请参见Camel第13章&amp;ldquo;过载&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e9cfe5685ea0ecd4847a06232a077cb874b35be7" translate="yes" xml:space="preserve">
          <source>A kind of action that an &lt;b&gt;object&lt;/b&gt; can take if you tell it to. See Camel chapter 12, &amp;ldquo;Objects&amp;rdquo;.</source>
          <target state="translated">如果您告诉&lt;b&gt;对象&lt;/b&gt;，则该&lt;b&gt;对象&lt;/b&gt;可以执行的一种操作。请参见骆驼第12章&amp;ldquo;对象&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="dfe222b0c92a8225eafa0e0da38f08258e2a6e75" translate="yes" xml:space="preserve">
          <source>A kind of key or name attached to a loop (or roller coaster) so that loop control statements can talk about which loop they want to control.</source>
          <target state="translated">一种附加在循环(或过山车)上的键或名称,以便循环控制语句可以谈论他们想要控制的循环。</target>
        </trans-unit>
        <trans-unit id="e7d72d06babc67750c6b28a2b28bed949fa33a88" translate="yes" xml:space="preserve">
          <source>A kinder, gentler tutorial on object-oriented programming in Perl can be found in &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;. You should also check out &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for some style guides on constructing both modules and classes.</source>
          <target state="translated">在&lt;a href=&quot;perlootut&quot;&gt;perlootut中&lt;/a&gt;可以找到有关Perl中面向对象编程的更友好，更柔和的教程。您还应该查看&lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt;以获取有关构造模块和类的一些样式指南。</target>
        </trans-unit>
        <trans-unit id="b68c5f288b44308b58cb523d3e60b493b484f9c4" translate="yes" xml:space="preserve">
          <source>A language beloved by many for its inside-out &lt;b&gt;type&lt;/b&gt; definitions, inscrutable &lt;b&gt;precedence&lt;/b&gt; rules, and heavy &lt;b&gt;overloading&lt;/b&gt; of the function-call mechanism. (Well, actually, people first switched to C because they found lowercase identifiers easier to read than upper.) Perl is written in C, so it&amp;rsquo;s not surprising that Perl borrowed a few ideas from it.</source>
          <target state="translated">一种由内而外的&lt;b&gt;类型&lt;/b&gt;定义，难以理解的&lt;b&gt;优先级&lt;/b&gt;规则以及函数调用机制的大量&lt;b&gt;重载&lt;/b&gt;而受到许多人喜爱的语言。（实际上，人们首先使用C是因为他们发现小写标识符比大写字母更容易阅读。）Perl是用C编写的，因此Perl借鉴了一些想法也就不足为奇了。</target>
        </trans-unit>
        <trans-unit id="7a70c2d1db9e3781c948c3f568d555da43db83b2" translate="yes" xml:space="preserve">
          <source>A language class is a class containing a lexicon of phrases as class data, and possibly also some methods that are of use in interpreting phrases in the lexicon, or otherwise dealing with text in that language.</source>
          <target state="translated">一个语言类是一个包含一个短语词典作为类数据的类,还可能包含一些方法,这些方法在解释词典中的短语,或以其他方式处理该语言的文本时使用。</target>
        </trans-unit>
        <trans-unit id="c64c47113f6df7e33ad198a5fed1bb8f3af6d13f" translate="yes" xml:space="preserve">
          <source>A language handle is a flyweight object -- i.e., it doesn't (necessarily) carry any data of interest, other than just being a member of whatever class it belongs to.</source>
          <target state="translated">语言句柄是一个轻量级对象--也就是说,它除了是它所属的任何类的成员之外,并不(一定)携带任何感兴趣的数据。</target>
        </trans-unit>
        <trans-unit id="c3a083f1f9c38b9c0d77465662a942c4c5d48d8d" translate="yes" xml:space="preserve">
          <source>A language handle is implemented as a blessed hash. Subclasses of yours can store whatever data you want in the hash. Currently the only hash entry used by any crucial Maketext method is &quot;fail&quot;, so feel free to use anything else as you like.</source>
          <target state="translated">一个语言句柄是以祝福哈希的形式实现的。你的子类可以在哈希中存储任何你想要的数据。目前,任何关键的Maketext方法使用的唯一的哈希条目是 &quot;fail&quot;,所以你可以随意使用其他任何你喜欢的东西。</target>
        </trans-unit>
        <trans-unit id="9fb1cb589c473c75eb212d9b744da125c770bad8" translate="yes" xml:space="preserve">
          <source>A language such as Perl that is good at hooking things together that weren&amp;rsquo;t intended to be hooked together.</source>
          <target state="translated">像Perl这样的语言，擅长将不希望被钩在一起的东西钩在一起。</target>
        </trans-unit>
        <trans-unit id="7ea3dfebe2530a429cde54a5f0bc78f862792455" translate="yes" xml:space="preserve">
          <source>A large scalar that you know can only contain ASCII</source>
          <target state="translated">一个大标量,你知道它只能包含ASCII码。</target>
        </trans-unit>
        <trans-unit id="8078fbdb7cd614c0fbe18240c94f727ccdf4ed5e" translate="yes" xml:space="preserve">
          <source>A layer can be added that does &quot;\n&quot; to CRLF translation. This layer can be used on any platform, not just those that normally do such things.</source>
          <target state="translated">可以添加一个层,进行&quot;/n &quot;到CRLF的翻译。这个层可以在任何平台上使用,而不仅仅是那些通常做这种事情的平台。</target>
        </trans-unit>
        <trans-unit id="c418f05188c75b7cf5ccc4221979555d292c85f1" translate="yes" xml:space="preserve">
          <source>A layer contains a &quot;vtable&quot;, the table of I/O operations (at C level a table of function pointers), and status flags. The functions in the vtable implement operations like &quot;open&quot;, &quot;read&quot;, and &quot;write&quot;.</source>
          <target state="translated">一个层包含一个 &quot;vtable&quot;,I/O操作表(在C层是一个函数指针表),以及状态标志。vtable中的函数实现了 &quot;打开&quot;、&quot;读取 &quot;和 &quot;写入 &quot;等操作。</target>
        </trans-unit>
        <trans-unit id="4f0330995dfa2fce16816cd443c9581a48699cf3" translate="yes" xml:space="preserve">
          <source>A layer derived using &quot;perlio&quot; as a base class. It provides Win32-like &quot;\n&quot; to CR,LF translation. Can either be applied above &quot;perlio&quot; or serve as the buffer layer itself. &quot;crlf&quot; over &quot;unix&quot; is the default if system distinguishes between &lt;code&gt;O_TEXT&lt;/code&gt; and &lt;code&gt;O_BINARY&lt;/code&gt; opens. (At some point &quot;unix&quot; will be replaced by a &quot;native&quot; Win32 IO layer on that platform, as Win32's read/write layer has various drawbacks.) The &quot;crlf&quot; layer is a reasonable model for a layer which transforms data in some way.</source>
          <target state="translated">使用&amp;ldquo; perlio&amp;rdquo;作为基类派生的图层。它提供了类似于Win32的&amp;ldquo; \ n&amp;rdquo;来进行CR，LF转换。可以应用在&amp;ldquo; perlio&amp;rdquo;上方，也可以用作缓冲层本身。如果系统区分 &lt;code&gt;O_TEXT&lt;/code&gt; 和 &lt;code&gt;O_BINARY&lt;/code&gt; 打开，则&amp;ldquo; unif &amp;rdquo;上的&amp;ldquo; crlf &amp;rdquo;是默认设置。（在某些时候，&amp;ldquo; unix&amp;rdquo;将被该平台上的&amp;ldquo;本机&amp;rdquo; Win32 IO层替换，因为Win32的读/写层具有各种缺点。）&amp;ldquo; crlf&amp;rdquo;层是在某些情况下转换数据的层的合理模型。方式。</target>
        </trans-unit>
        <trans-unit id="c575f3b4bff37dcf26ab538523523b73298b17f9" translate="yes" xml:space="preserve">
          <source>A layer does not have to implement all the functions, but the whole table has to be present. Unimplemented slots can be NULL (which will result in an error when called) or can be filled in with stubs to &quot;inherit&quot; behaviour from a &quot;base class&quot;. This &quot;inheritance&quot; is fixed for all instances of the layer, but as the layer chooses which stubs to populate the table, limited &quot;multiple inheritance&quot; is possible.</source>
          <target state="translated">一个层不一定要实现所有的功能,但整个表必须存在。未实现的槽可以是NULL(当调用时将导致错误),也可以用存根来填充,以 &quot;继承 &quot;一个 &quot;基类 &quot;的行为。这种 &quot;继承 &quot;对于层的所有实例来说是固定的,但由于层选择哪些存根来填充表,有限的 &quot;多重继承 &quot;是可能的。</target>
        </trans-unit>
        <trans-unit id="7f64a4152a5af0c9ac4baa66afb914d700fb3ea6" translate="yes" xml:space="preserve">
          <source>A layer that implements &quot;reading&quot; of files by using</source>
          <target state="translated">实现 &quot;读取 &quot;文件的层,通过使用</target>
        </trans-unit>
        <trans-unit id="29bee167ef354a3d46f2326d367f6d5e9ab52d50" translate="yes" xml:space="preserve">
          <source>A layer that implements DOS/Windows like CRLF line endings. On read converts pairs of CR,LF to a single &quot;\n&quot; newline character. On write converts each &quot;\n&quot; to a CR,LF pair. Note that this layer will silently refuse to be pushed on top of itself.</source>
          <target state="translated">一个实现DOS/Windows类似CRLF行尾的层。读取时将CR,LF对转换为一个&quot;/n &quot;新行字符。写入时将每个&quot;/n &quot;转换为一对CR,LF。请注意,这一层会默默地拒绝被推到自己的上面。</target>
        </trans-unit>
        <trans-unit id="a9b39500363434cc0ff0f52b520ce130f3b3a554" translate="yes" xml:space="preserve">
          <source>A layer which does CRLF to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; translation distinguishing &quot;text&quot; and &quot;binary&quot; files in the manner of MS-DOS and similar operating systems. (It currently does</source>
          <target state="translated">以MS-DOS和类似操作系统的方式执行CRLF到 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 转换以区分&amp;ldquo;文本&amp;rdquo;和&amp;ldquo;二进制&amp;rdquo;文件的层。（目前</target>
        </trans-unit>
        <trans-unit id="d99ca2d73d6bc9954c1f5d38358ae63b3448d053" translate="yes" xml:space="preserve">
          <source>A layer which implements &quot;reading&quot; of files by using &lt;code&gt;mmap()&lt;/code&gt; to make a (whole) file appear in the process's address space, and then using that as PerlIO's &quot;buffer&quot;. This</source>
          <target state="translated">通过使用 &lt;code&gt;mmap()&lt;/code&gt; 使（整个）文件出现在进程的地址空间中，然后将其用作PerlIO的&amp;ldquo;缓冲区&amp;rdquo; ，来实现文件的&amp;ldquo;读取&amp;rdquo;层。这个</target>
        </trans-unit>
        <trans-unit id="fd687d324576d9173f6d5752bc85ac325e3d235f" translate="yes" xml:space="preserve">
          <source>A layer which provides the PerlIO API via the layer scheme, but implements it by calling system's stdio. This is (currently) the default if system's stdio provides sufficient access to allow perl's &quot;fast gets&quot; access and which do not distinguish between &lt;code&gt;O_TEXT&lt;/code&gt; and &lt;code&gt;O_BINARY&lt;/code&gt; .</source>
          <target state="translated">通过层方案提供PerlIO API的层，但是通过调用系统的stdio来实现它。（当前）如果系统的stdio提供足够的访问权限以允许perl的&amp;ldquo;快速获取&amp;rdquo;访问并且不区分 &lt;code&gt;O_TEXT&lt;/code&gt; 和 &lt;code&gt;O_BINARY&lt;/code&gt; ，则这是默认设置。</target>
        </trans-unit>
        <trans-unit id="1841e889a880ebb77b0a2697210c6744f8df031b" translate="yes" xml:space="preserve">
          <source>A leading ! indicates that matching names should be deleted from the list of names to import. If the first specification is a deletion it is treated as though preceded by :DEFAULT. If you just want to import extra names in addition to the default set you will still need to include :DEFAULT explicitly.</source>
          <target state="translated">前面的 !表示应该从要导入的名称列表中删除匹配的名称。如果第一个规范是删除,则会被视为前面有 :DEFAULT。如果您只是想在默认设置之外导入额外的名称,您仍然需要明确包含 :DEFAULT。</target>
        </trans-unit>
        <trans-unit id="f747bcc2647296135613b88a3e62cca47b6c1dc6" translate="yes" xml:space="preserve">
          <source>A leading colon removes the &quot;name=&quot; part of the response, this allows you to map to the name you need. (mnemonic: empty label)</source>
          <target state="translated">前面的冒号去掉了响应中的 &quot;name=&quot;部分,这样就可以映射到你需要的名称。(提示语:空标签)</target>
        </trans-unit>
        <trans-unit id="96fa00367bcfdb4784c34a4a3babbe9475afc22d" translate="yes" xml:space="preserve">
          <source>A legally formed name for most anything in which a computer program might be interested. Many languages (including Perl) allow identifiers to start with an alphabetic character, and then contain alphabetics and digits. Perl also allows connector punctuation like the underscore character wherever it allows alphabetics. (Perl also has more complicated names, like &lt;b&gt;qualified&lt;/b&gt; names.)</source>
          <target state="translated">电脑程序可能感兴趣的大多数事物的合法名称。许多语言（包括Perl）都允许标识符以字母字符开头，然后包含字母和数字。Perl允许在允许字母的任何地方使用连接符标点，例如下划线字符。（Perl还具有更复杂的名称，如&lt;b&gt;限定&lt;/b&gt;名称。）</target>
        </trans-unit>
        <trans-unit id="69d4d84a09fc968a07bdda5a53812534fa74783b" translate="yes" xml:space="preserve">
          <source>A library only needs to deal with unsigned big integers. Testing of input parameter validity is done by the caller, so there is no need to worry about underflow (e.g., in &lt;code&gt;_sub()&lt;/code&gt; and &lt;code&gt;_dec()&lt;/code&gt; ) nor about division by zero (e.g., in &lt;code&gt;_div()&lt;/code&gt; ) or similar cases.</source>
          <target state="translated">一个库只需要处理无符号的大整数。输入参数有效性的测试是由主叫方完成的，所以没有必要对溢忧（例如，在 &lt;code&gt;_sub()&lt;/code&gt; 和 &lt;code&gt;_dec()&lt;/code&gt; ），也没有关于除零（例如，在 &lt;code&gt;_div()&lt;/code&gt; ）或类似的情况。</target>
        </trans-unit>
        <trans-unit id="0b89fa4e541f30b4e921956619e05676831d4d1c" translate="yes" xml:space="preserve">
          <source>A line number may be prefixed by a single letter:</source>
          <target state="translated">行号前可加一个字母。</target>
        </trans-unit>
        <trans-unit id="2d89336c3df3636aebec0ee20d5e9be98d7da075" translate="yes" xml:space="preserve">
          <source>A line-oriented form of quoting is based on the shell &quot;here-document&quot; syntax. Following a &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; you specify a string to terminate the quoted material, and all lines following the current line down to the terminating string are the value of the item.</source>
          <target state="translated">面向行的引用形式基于外壳程序&amp;ldquo; here-document&amp;rdquo;语法。在 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 之后,您可以指定一个字符串来终止引用的材料，当前行之后直到终止字符串的所有行都是该项的值。</target>
        </trans-unit>
        <trans-unit id="75e8b52d2267761231a600214a302dc93a9097e4" translate="yes" xml:space="preserve">
          <source>A list introduced by &lt;code&gt;=over&lt;/code&gt; starts with a text or verbatim paragraph, but continues with &lt;code&gt;=item&lt;/code&gt; s. Move the non-item paragraph out of the &lt;code&gt;=over&lt;/code&gt; /&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;=over&lt;/code&gt; 引入的列表以文本或逐字段落开头，但以 &lt;code&gt;=item&lt;/code&gt; 开头。将非项目段落移出 &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="9aee76ae2469acd57d2557387480876b03411474" translate="yes" xml:space="preserve">
          <source>A list is a fixed collection of scalars. An array is a variable that holds a variable collection of scalars. An array can supply its collection for list operations, so list operations also work on arrays:</source>
          <target state="translated">列表是一个固定的标量集合。数组是一个变量,它容纳了一个可变的标量集合。数组可以为列表操作提供它的集合,所以列表操作也可以在数组上进行。</target>
        </trans-unit>
        <trans-unit id="b201394353dbcc6ef2561ba6cd863dea90b88222" translate="yes" xml:space="preserve">
          <source>A list of additional libraries or other shared objects which can be used to resolve any undefined symbols that might be generated by a later call to load_file().</source>
          <target state="translated">附加库或其他共享对象的列表,可以用来解决任何未定义的符号,这些符号可能会在以后调用load_file()时产生。</target>
        </trans-unit>
        <trans-unit id="e216fd26bc604e567680be656aeb4002407fb587" translate="yes" xml:space="preserve">
          <source>A list of all the INSTALL* variables without the INSTALL prefix. Useful for iteration or building related variable sets.</source>
          <target state="translated">所有不带INSTALL前缀的INSTALL*变量的列表。用于迭代或建立相关的变量集。</target>
        </trans-unit>
        <trans-unit id="94957d0f7514017339244da4cc1607583b5fc84e" translate="yes" xml:space="preserve">
          <source>A list of directories in which to look for Perl library files before looking in the standard library and the current directory. Any architecture-specific and version-specific directories, such as</source>
          <target state="translated">在查找标准库和当前目录之前,要在其中查找Perl库文件的目录列表。任何特定架构和特定版本的目录,如</target>
        </trans-unit>
        <trans-unit id="7103902d7143d091cfd2b7d907958a451f56b4e9" translate="yes" xml:space="preserve">
          <source>A list of directories in which to look for Perl library files before looking in the standard library and the current directory. If PERL5LIB is defined, PERLLIB is not used.</source>
          <target state="translated">在查找标准库和当前目录之前,寻找Perl库文件的目录列表。如果定义了PERL5LIB,则不使用PERLLIB。</target>
        </trans-unit>
        <trans-unit id="f3cc07c6f57898b2ef6aaadd57be04cf61845061" translate="yes" xml:space="preserve">
          <source>A list of directory paths. If the input file does not exist, then it will be searched for in the given directory list (in the order the directories appear in the list). It defaults to the list of directories implied by &lt;code&gt;$ENV{PATH}&lt;/code&gt; . The list may be specified either by a reference to an array, or by a string of directory paths which use the same path separator as &lt;code&gt;$ENV{PATH}&lt;/code&gt; on your system (e.g., &lt;code&gt;:&lt;/code&gt; for Unix, &lt;code&gt;;&lt;/code&gt; for MSWin32 and DOS).</source>
          <target state="translated">目录路径列表。如果输入文件不存在，则将在给定目录列表中搜索该文件（目录在列表中的显示顺序）。它默认为 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 隐含的目录列表。该列表可以通过对数组的引用来指定，也可以通过目录路径字符串来指定，这些目录路径使用与系统上 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 相同的路径分隔符（例如 &lt;code&gt;:&lt;/code&gt; 对于Unix ， &lt;code&gt;;&lt;/code&gt; 对于MSWin32和DOS）。</target>
        </trans-unit>
        <trans-unit id="337601b93965c28568bbedd0632699f2eefded6b" translate="yes" xml:space="preserve">
          <source>A list of files in the distribution, one file per line. The MANIFEST always uses Unix filepath conventions even if you're not on Unix. This means</source>
          <target state="translated">发行版中的文件列表,每行一个文件。MANIFEST 总是使用 Unix 文件路径约定,即使你不是在 Unix 上。这意味着</target>
        </trans-unit>
        <trans-unit id="0555d0b38c03024b415a75a77593c5880fa79206" translate="yes" xml:space="preserve">
          <source>A list of one or more symbol names that are in the library/object file to be dynamically loaded. This is only required on some platforms.</source>
          <target state="translated">动态加载库/对象文件中的一个或多个符号名称的列表。只有在某些平台上才需要。</target>
        </trans-unit>
        <trans-unit id="681b6abf464391de8dd3a7916ae06f2d521a9817" translate="yes" xml:space="preserve">
          <source>A list of pads. The first one contains the names.</source>
          <target state="translated">垫子的列表。第一个包含名字。</target>
        </trans-unit>
        <trans-unit id="02f9cb55d32eb52f68051c89a619f41d785a1129" translate="yes" xml:space="preserve">
          <source>A list of possible choices from which you may select only one, as in, &amp;ldquo;Would you like door A, B, or C?&amp;rdquo; Alternatives in regular expressions are separated with a single vertical bar: &lt;code&gt;|&lt;/code&gt;. Alternatives in normal Perl expressions are separated with a double vertical bar: &lt;code&gt;||&lt;/code&gt;. Logical alternatives in &lt;b&gt;Boolean&lt;/b&gt; expressions are separated with either &lt;code&gt;||&lt;/code&gt; or &lt;code&gt;or&lt;/code&gt; .</source>
          <target state="translated">可能选择的列表，您只能从中选择一个，例如&amp;ldquo;您要门A，B还是C？&amp;rdquo;。在正则表达式替代分离与单个竖线： &lt;code&gt;|&lt;/code&gt; 。常规Perl表达式中的替代项用双竖线分隔： &lt;code&gt;||&lt;/code&gt; 。&lt;b&gt;布尔&lt;/b&gt;表达式中的逻辑替代项用 &lt;code&gt;||&lt;/code&gt; 分隔 或 &lt;code&gt;or&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="346e1107e8ac97822d23a43881fe3f608701a635" translate="yes" xml:space="preserve">
          <source>A list of signal names supported by the current platform can be found in &lt;code&gt;$Config{sig_name}&lt;/code&gt; , which is provided by the &lt;code&gt;Config&lt;/code&gt; module. See &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; for more details.</source>
          <target state="translated">当前平台支持的信号名称列表可在 &lt;code&gt;Config&lt;/code&gt; 模块提供的 &lt;code&gt;$Config{sig_name}&lt;/code&gt; 找到。有关更多详细信息，请参见&lt;a href=&quot;../config&quot;&gt;配置&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9eb54a7b38bb34c8e5e028a36e767398adf41e8" translate="yes" xml:space="preserve">
          <source>A list of signal names supported by the current platform can be found in &lt;code&gt;$Config{sig_name}&lt;/code&gt; , which is provided by the &lt;code&gt;Config&lt;/code&gt; module. See &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; for more details.</source>
          <target state="translated">当前平台支持的信号名称列表可在 &lt;code&gt;Config&lt;/code&gt; 模块提供的 &lt;code&gt;$Config{sig_name}&lt;/code&gt; 找到。有关更多详细信息，请参见&lt;a href=&quot;config&quot;&gt;配置&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6a6ca6e50a55d219bc744f957b355e8b7592c8a" translate="yes" xml:space="preserve">
          <source>A list of the built-in functions in Perl can be found in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;可以找到Perl中内置函数的列表。</target>
        </trans-unit>
        <trans-unit id="35384fe66627b2cc2fb84aa2b93b3f9464bdd2e5" translate="yes" xml:space="preserve">
          <source>A list started with e.g. a bullet-like &lt;code&gt;=item&lt;/code&gt; and continued with a numbered one. This is obviously inconsistent. For most translators the type of the</source>
          <target state="translated">列表以类似 &lt;code&gt;=item&lt;/code&gt; 符号的= item开头，并以编号1 开头。这显然是不一致的。对于大多数翻译人员而言，</target>
        </trans-unit>
        <trans-unit id="aa018bd7e5de867ce0e0e74c715e38d76832212f" translate="yes" xml:space="preserve">
          <source>A list value may also be subscripted like a normal array. You must put the list in parentheses to avoid ambiguity. For example:</source>
          <target state="translated">列表值也可以像普通数组一样进行下标。你必须把列表放在括号里,以避免歧义。例如</target>
        </trans-unit>
        <trans-unit id="6d0412d7581939fe7cd594904f6d1f6283358f69" translate="yes" xml:space="preserve">
          <source>A list-type op is usually constructed one kid at a time via &lt;code&gt;newLISTOP&lt;/code&gt; , &lt;code&gt;op_prepend_elem&lt;/code&gt; and &lt;code&gt;op_append_elem&lt;/code&gt; . Then finally it is passed to &lt;code&gt;op_convert_list&lt;/code&gt; to make it the right type.</source>
          <target state="translated">通常通过 &lt;code&gt;newLISTOP&lt;/code&gt; ， &lt;code&gt;op_prepend_elem&lt;/code&gt; 和 &lt;code&gt;op_append_elem&lt;/code&gt; 一次构造一个列表类型的op 。然后，最后将其传递给 &lt;code&gt;op_convert_list&lt;/code&gt; 以使其成为正确的类型。</target>
        </trans-unit>
        <trans-unit id="9f682c29d99c6edee87a4e2c8b480a19c081d9f4" translate="yes" xml:space="preserve">
          <source>A literal of the form &lt;code&gt;v1.20.300.4000&lt;/code&gt; is parsed as a string composed of characters with the specified ordinals. This form, known as v-strings, provides an alternative, more readable way to construct strings, rather than use the somewhat less readable interpolation form &lt;code&gt;&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;&lt;/code&gt; . This is useful for representing Unicode strings, and for comparing version &quot;numbers&quot; using the string comparison operators, &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; etc. If there are two or more dots in the literal, the leading &lt;code&gt;v&lt;/code&gt; may be omitted.</source>
          <target state="translated">&lt;code&gt;v1.20.300.4000&lt;/code&gt; 形式的文字被解析为由具有指定序数的字符组成的字符串。这种称为v-strings的形式提供了一种替代的，更易读的方式来构造字符串，而不是使用可读性较差的内插形式 &lt;code&gt;&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;&lt;/code&gt; 。这对于表示Unicode字符串以及使用字符串比较运算符 &lt;code&gt;cmp&lt;/code&gt; ， &lt;code&gt;gt&lt;/code&gt; ， &lt;code&gt;lt&lt;/code&gt; 等比较版本&amp;ldquo;数字&amp;rdquo;很有用。如果文字中有两个或多个点，则可以省略前导 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59f7e21c905ecc7463ec1c2d73cca6ccc870ec21" translate="yes" xml:space="preserve">
          <source>A little bit less simple options</source>
          <target state="translated">简单一点的选择</target>
        </trans-unit>
        <trans-unit id="1cd2ad667ca8cebc07144e83ae02050c5a406af0" translate="yes" xml:space="preserve">
          <source>A little builtin syntactic sugar means you can also say &lt;b&gt;-m&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; or &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; as a shortcut for &lt;b&gt;'-M&lt;i&gt;MODULE&lt;/i&gt; qw(foo bar)'&lt;/b&gt;. This avoids the need to use quotes when importing symbols. The actual code generated by &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; is &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; module &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(/,/,q{foo,bar})&lt;/code&gt; . Note that the &lt;code&gt;=&lt;/code&gt; form removes the distinction between &lt;b&gt;-m&lt;/b&gt; and &lt;b&gt;-M&lt;/b&gt;; that is, &lt;b&gt;-m&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; is the same as &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt;.</source>
          <target state="translated">一点点内置语法糖意味着您还可以说&lt;b&gt;-m &lt;i&gt;MODULE&lt;/i&gt; = foo，bar&lt;/b&gt;或&lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = foo，bar&lt;/b&gt;作为&lt;b&gt;'-M &lt;i&gt;MODULE&lt;/i&gt; qw（foo bar）'&lt;/b&gt;的快捷方式。这样可以避免在导入符号时使用引号。&lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = foo，bar&lt;/b&gt;生成的实际代码是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; module &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(/,/,q{foo,bar})&lt;/code&gt; 。注意， &lt;code&gt;=&lt;/code&gt; 形式消除了&lt;b&gt;-m&lt;/b&gt;和&lt;b&gt;-M&lt;/b&gt;之间的区别；即&lt;b&gt;-m &lt;i&gt;MODULE&lt;/i&gt; = foo，bar&lt;/b&gt;与&lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = foo，bar相同&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="b161330532dd0ec0afc3fa6fafbca99d0e5e09ac" translate="yes" xml:space="preserve">
          <source>A little funky, because VOS's notion of ownership is a little funky (VOS).</source>
          <target state="translated">有点时髦,因为VOS的所有权概念有点时髦(VOS)。</target>
        </trans-unit>
        <trans-unit id="fe38aea6f56711cc8a09262301b75b1d00f515d0" translate="yes" xml:space="preserve">
          <source>A little interface to ExtUtils::Installed to examine installed modules, validate your packlists and even create a tarball from an installed module.</source>
          <target state="translated">一个ExtUtils::Installed的小接口,用于检查已安装的模块,验证你的打包列表,甚至从已安装的模块中创建一个tarball。</target>
        </trans-unit>
        <trans-unit id="fab5a9063d3279beff24f900f22a1e9be454b440" translate="yes" xml:space="preserve">
          <source>A little-known feature of &lt;a href=&quot;../test/harness&quot;&gt;Test::Harness&lt;/a&gt; is that it supported TODO lists in the plan:</source>
          <target state="translated">&lt;a href=&quot;../test/harness&quot;&gt;Test :: Harness的&lt;/a&gt;一个鲜为人知的功能是它支持计划中的TODO列表：</target>
        </trans-unit>
        <trans-unit id="18dd594cfef1216511213db962d79c422701e3a6" translate="yes" xml:space="preserve">
          <source>A local modifies the listed variables to be local to the enclosing block, file, or eval. If more than one value is listed, the list must be placed in parentheses. See &lt;a href=&quot;../perlsub#Temporary-Values-via-local()&quot;&gt;Temporary Values via local() in perlsub&lt;/a&gt; for details, including issues with tied arrays and hashes.</source>
          <target state="translated">局部变量将列出的变量修改为对于封闭块，文件或评估变量而言是局部的。如果列出了多个值，则该列表必须放在括号中。有关详细信息，包括绑定数组和哈希的问题，请参见&lt;a href=&quot;../perlsub#Temporary-Values-via-local()&quot;&gt;perlsub中通过local（）的临时值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9869654ca036fa59fd44e2a08b434b738df4df1" translate="yes" xml:space="preserve">
          <source>A local modifies the listed variables to be local to the enclosing block, file, or eval. If more than one value is listed, the list must be placed in parentheses. See &lt;a href=&quot;perlsub#Temporary-Values-via-local()&quot;&gt;Temporary Values via local() in perlsub&lt;/a&gt; for details, including issues with tied arrays and hashes.</source>
          <target state="translated">局部变量将列出的变量修改为对于封闭块，文件或评估变量而言是局部的。如果列出了多个值，则该列表必须放在括号中。有关详细信息，包括绑定数组和哈希的问题，请参见&lt;a href=&quot;perlsub#Temporary-Values-via-local()&quot;&gt;perlsub中通过local（）的临时值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="851216238693688504d3297975d3a9648a0c15ac" translate="yes" xml:space="preserve">
          <source>A locale is a set of data that describes various aspects of how various communities in the world categorize their world. These categories are broken down into the following types (some of which include a brief note here):</source>
          <target state="translated">地域是一组数据,它描述了世界上各种社区如何对其世界进行分类的各个方面。这些分类可分为以下几种类型(其中一些包括这里的简要说明)。</target>
        </trans-unit>
        <trans-unit id="13e5d1d67a5e143b58f5105851151e51a7ee96cb" translate="yes" xml:space="preserve">
          <source>A location in a &lt;b&gt;hash table&lt;/b&gt; containing (potentially) multiple entries whose keys &amp;ldquo;hash&amp;rdquo; to the same hash value according to its hash function. (As internal policy, you don&amp;rsquo;t have to worry about it unless you&amp;rsquo;re into internals, or policy.)</source>
          <target state="translated">&lt;b&gt;哈希表&lt;/b&gt;中的一个位置，包含（可能）多个条目，这些条目的键根据其哈希函数&amp;ldquo;哈希&amp;rdquo;到相同的哈希值。（作为内部政策，除非您了解内部政策或政策，否则不必担心。）</target>
        </trans-unit>
        <trans-unit id="62c12399ed6b551ce7f2dd44832d843392fa0233" translate="yes" xml:space="preserve">
          <source>A lock can either be used to guard the data contained within the variable being locked, or it can be used to guard something else, like a section of code. In this latter case, the variable in question does not hold any useful data, and exists only for the purpose of being locked. In this respect, the variable behaves like the mutexes and basic semaphores of traditional thread libraries.</source>
          <target state="translated">鎖可以用來保護被鎖定的變數中包含的數據,也可以用來保護其他東西,比如一段代碼。在后一种情况下,相关的变量并不持有任何有用的数据,只是为了被锁定而存在。在这方面,变量的行为就像传统线程库中的mutexes和基本semaphores。</target>
        </trans-unit>
        <trans-unit id="e53273bd96405d6a9351857fe0d8e6743bfe42f3" translate="yes" xml:space="preserve">
          <source>A log of changes you've made to this module. The layout is free-form. Here's an example:</source>
          <target state="translated">你对这个模块所做的修改的日志。布局是自由式的。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="e77a6f13193bcd6e24d605469f11ccf9737a2eb7" translate="yes" xml:space="preserve">
          <source>A lone dash on the command line will now be a legal option, and using it will set variable &lt;code&gt;$stdio&lt;/code&gt; .</source>
          <target state="translated">命令行上的破折号现在将是合法选项，使用它将设置变量 &lt;code&gt;$stdio&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ebb7eb8448d50869adcfaf8c37d6e3e449e059f" translate="yes" xml:space="preserve">
          <source>A lot of Git tools (Gitweb, GitHub, git log --pretty=oneline, ...) will only display the first line (cut off at 50 characters) when presenting commit summaries.</source>
          <target state="translated">很多 Git 工具(Gitweb、GitHub、git log --pretty=oneline,......)在显示提交摘要时,只会显示第一行(以 50 个字符为限)。</target>
        </trans-unit>
        <trans-unit id="02a8d66dfb847fc32e205ee4aa1e54636c91fd8e" translate="yes" xml:space="preserve">
          <source>A lot of opcodes (this is an elementary operation in the internal perl stack machine) put an SV* on the stack. However, as an optimization the corresponding SV is (usually) not recreated each time. The opcodes reuse specially assigned SVs (</source>
          <target state="translated">很多操作码(这是perl内部堆栈机的一个基本操作)在堆栈上放一个SV*。然而,作为一种优化,对应的SV并不是每次都重新创建。操作码会重复使用专门分配的SVs (</target>
        </trans-unit>
        <trans-unit id="afe9679193e46dcbc5b397149b0a40382533461a" translate="yes" xml:space="preserve">
          <source>A lot of the behaviour of &lt;code&gt;check()&lt;/code&gt; can be altered by setting package variables. See the section on &lt;code&gt;Global Variables&lt;/code&gt; for details on this.</source>
          <target state="translated">可以通过设置包变量来更改 &lt;code&gt;check()&lt;/code&gt; 的许多行为。有关详细信息，请参见&amp;ldquo; &lt;code&gt;Global Variables&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="fc40634e762614784aeafebfe726c582b35ad008" translate="yes" xml:space="preserve">
          <source>A lot of the methods in this package are accessors to the various fields in the tar header:</source>
          <target state="translated">这个包中的很多方法都是对 tar 头中各种字段的访问器。</target>
        </trans-unit>
        <trans-unit id="565ddf2f41fdaae2f6c398d4a9fce10061d3fdb0" translate="yes" xml:space="preserve">
          <source>A map to the empty string means that there is no alias defined for the code point.</source>
          <target state="translated">映射到空字符串意味着没有为代码点定义别名。</target>
        </trans-unit>
        <trans-unit id="962035547fe5a8c87c148cca16aad0a4071407ed" translate="yes" xml:space="preserve">
          <source>A mask of those &lt;b&gt;permission bits&lt;/b&gt; that should be forced off when creating files or directories, in order to establish a policy of whom you&amp;rsquo;ll ordinarily deny access to. See the &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">这些&lt;b&gt;权限位的&lt;/b&gt;掩码，在创建文件或目录时应将其强制关闭，以建立通常拒绝访问谁的策略。请参见 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="dfb92546e7ee6f466e3b9ad9b8c6c91db11b1f74" translate="yes" xml:space="preserve">
          <source>A meaningless value will currently be returned if the input is not an unsigned integer.</source>
          <target state="translated">如果输入不是无符号整数,当前将返回一个无意义的值。</target>
        </trans-unit>
        <trans-unit id="46b7f4ae99fce16ec6771e2703c08b126f8c5237" translate="yes" xml:space="preserve">
          <source>A mechanism by which some high-level agent such as a user can pass its preferences down to its future offspring (child &lt;b&gt;processes&lt;/b&gt;, grandchild processes, great-grandchild processes, and so on). Each environment variable is a &lt;b&gt;key&lt;/b&gt;/&lt;b&gt;value&lt;/b&gt; pair, like one entry in a &lt;b&gt;hash&lt;/b&gt;.</source>
          <target state="translated">一种机制，通过该机制，诸如用户之类的某些高级代理可以将其偏好传递给其未来的后代（子&lt;b&gt;进程&lt;/b&gt;，孙进程，曾孙进程等）。每个环境变量都是一个&lt;b&gt;键&lt;/b&gt; / &lt;b&gt;值&lt;/b&gt;对，就像&lt;b&gt;hash中的&lt;/b&gt;一个条目一样。</target>
        </trans-unit>
        <trans-unit id="2a69447aeea5209e44940fc7462f35a5d6ac88b2" translate="yes" xml:space="preserve">
          <source>A mechanism in Perl that lets you store up the output of each Perl &lt;b&gt;command&lt;/b&gt; and then flush it out as a single request to the &lt;b&gt;operating system&lt;/b&gt;. It&amp;rsquo;s enabled by setting the &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; ) variable to a true value. It&amp;rsquo;s used when you don&amp;rsquo;t want data sitting around, not going where it&amp;rsquo;s supposed to, which may happen because the default on a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;pipe&lt;/b&gt; is to use &lt;b&gt;block buffering&lt;/b&gt;.</source>
          <target state="translated">Perl中的一种机制，使您可以存储每个Perl &lt;b&gt;命令&lt;/b&gt;的输出，然后将其作为单个请求刷新到&lt;b&gt;操作系统&lt;/b&gt;。通过设置 &lt;code&gt;$|&lt;/code&gt; 启用 （ &lt;code&gt;$AUTOFLUSH&lt;/code&gt; ）变量为真实值。当您不希望数据乱七八糟，不去预期的位置时使用它，因为&lt;b&gt;文件&lt;/b&gt;或&lt;b&gt;管道&lt;/b&gt;的默认设置是使用&lt;b&gt;块缓冲&lt;/b&gt;，因此可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="51120e7f8481f25cf88f8c7a272aee4be9724200" translate="yes" xml:space="preserve">
          <source>A memory address (pointer). Typically associated with a &lt;code&gt;void *&lt;/code&gt; type.</source>
          <target state="translated">内存地址（指针）。通常与 &lt;code&gt;void *&lt;/code&gt; 类型关联。</target>
        </trans-unit>
        <trans-unit id="3a89278430a1f2647d19e07faa6dcd5ce49e8cc5" translate="yes" xml:space="preserve">
          <source>A message of the form:</source>
          <target state="translated">一种形式的信息。</target>
        </trans-unit>
        <trans-unit id="f4fff5e041e8ffd1750d8230d717d49c7140db99" translate="yes" xml:space="preserve">
          <source>A message printed to the &lt;code&gt;STDERR&lt;/code&gt; stream to the effect that something might be wrong but isn&amp;rsquo;t worth blowing up over. See &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo; and the &lt;code&gt;warnings&lt;/code&gt; pragma in Camel chapter 28, &amp;ldquo;Pragmantic Modules&amp;rdquo;.</source>
          <target state="translated">一条消息打印到 &lt;code&gt;STDERR&lt;/code&gt; 流上，表示可能有问题，但不值得吹嘘。见 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 骆驼第27章，&amp;ldquo;功能&amp;rdquo;和 &lt;code&gt;warnings&lt;/code&gt; 骆驼28章编译&amp;ldquo; Pragmantic模块&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6a6e29399630661da9d8d4454f316b8b579ac7c9" translate="yes" xml:space="preserve">
          <source>A message to print prior to &lt;code&gt;@args&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;@args&lt;/code&gt; 之前打印的消息。</target>
        </trans-unit>
        <trans-unit id="cd1e82245324d77d7c4b1f38686539fbc87f4207" translate="yes" xml:space="preserve">
          <source>A metacharacter can be matched by putting a backslash before it:</source>
          <target state="translated">一个元字符可以通过在它前面加上反斜杠来匹配。</target>
        </trans-unit>
        <trans-unit id="fb23d39b57fee733dc53600af45c98c9b288bdde" translate="yes" xml:space="preserve">
          <source>A method is simply a subroutine that expects a reference to an object (or a package name, for class methods) as the first argument.</source>
          <target state="translated">方法是一个简单的子程序,它期望一个对象的引用(或者一个包名,对于类方法)作为第一个参数。</target>
        </trans-unit>
        <trans-unit id="8b793382672991d71fa4d5891acf893cacd7e306" translate="yes" xml:space="preserve">
          <source>A method of making input and output efficient by passing one &lt;b&gt;block&lt;/b&gt; at a time. By default, Perl does block buffering to disk files. See &lt;b&gt;buffer&lt;/b&gt; and &lt;b&gt;command buffering&lt;/b&gt;.</source>
          <target state="translated">一种通过一次传递一个&lt;b&gt;块&lt;/b&gt;来提高输入和输出效率的方法。默认情况下，Perl会阻止对磁盘文件的缓冲。请参阅&lt;b&gt;缓冲区&lt;/b&gt;和&lt;b&gt;命令缓冲&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="caf2b56be7a3ef3288ab77eb65ba11acb464aa6d" translate="yes" xml:space="preserve">
          <source>A method of storing numbers in &amp;ldquo;scientific notation&amp;rdquo;, such that the precision of the number is independent of its magnitude (the decimal point &amp;ldquo;floats&amp;rdquo;). Perl does its numeric work with floating-point numbers (sometimes called &amp;ldquo;floats&amp;rdquo;) when it can&amp;rsquo;t get away with using &lt;b&gt;integers&lt;/b&gt;. Floating-point numbers are mere approximations of real numbers.</source>
          <target state="translated">一种以&amp;ldquo;科学计数法&amp;rdquo;存储数字的方法，以使数字的精度独立于其大小（小数点&amp;ldquo;浮点数&amp;rdquo;）。当无法使用&lt;b&gt;整数&lt;/b&gt;时，Perl会使用浮点数（有时称为&amp;ldquo;浮点数&amp;rdquo;）进行数字运算。浮点数仅是实数的近似值。</target>
        </trans-unit>
        <trans-unit id="944278d690e3fc7e64864c32faa75a96c4fa698a" translate="yes" xml:space="preserve">
          <source>A method returning a scalar containing definitions needed, typically for a C header file.</source>
          <target state="translated">返回一个包含所需定义的标量的方法,通常用于C头文件。</target>
        </trans-unit>
        <trans-unit id="b261259b0ea34efe663b89fa4a355d967119ff59" translate="yes" xml:space="preserve">
          <source>A method to return a suitable &lt;code&gt;#ifdef&lt;/code&gt; clause.</source>
          <target state="translated">返回合适的 &lt;code&gt;#ifdef&lt;/code&gt; 子句的方法。</target>
        </trans-unit>
        <trans-unit id="e298259952faa9b6dc589a73a54938eb75e8b9ca" translate="yes" xml:space="preserve">
          <source>A method to return a suitable C &lt;code&gt;if&lt;/code&gt; statement to check whether</source>
          <target state="translated">一种返回合适的C &lt;code&gt;if&lt;/code&gt; 语句以检查是否存在的方法</target>
        </trans-unit>
        <trans-unit id="b8d289dec370b10085acc876037d4a80d75d741c" translate="yes" xml:space="preserve">
          <source>A method to return a suitable assignment clause. If</source>
          <target state="translated">返回一个合适的赋值条款的方法。如果</target>
        </trans-unit>
        <trans-unit id="b7330449bff2c39517a4e897b762ab9507a795d4" translate="yes" xml:space="preserve">
          <source>A minimal required perl version, if present, will look like this:</source>
          <target state="translated">如果存在的话,一个最小的所需的perl版本会是这样的。</target>
        </trans-unit>
        <trans-unit id="e9a3539678256349db8d3cedb932d5bd4be41d3e" translate="yes" xml:space="preserve">
          <source>A misnamed feature&amp;mdash;it should be called, &amp;ldquo;expecting your mother to pick up after you&amp;rdquo;. Strictly speaking, Perl doesn&amp;rsquo;t do this, but it relies on a reference-counting mechanism to keep things tidy. However, we rarely speak strictly and will often refer to the reference-counting scheme as a form of garbage collection. (If it&amp;rsquo;s any comfort, when your interpreter exits, a &amp;ldquo;real&amp;rdquo; garbage collector runs to make sure everything is cleaned up if you&amp;rsquo;ve been messy with circular references and such.)</source>
          <target state="translated">一个名称不正确的功能-应该称为&amp;ldquo;希望您的母亲在您之后接送&amp;rdquo;。严格来说，Perl不会这样做，但是它依靠引用计数机制来使事情保持整洁。但是，我们很少严格讲，经常将引用计数方案称为垃圾收集的一种形式。 （如果可以的话，当您的解释器退出时，运行&amp;ldquo;真正的&amp;rdquo;垃圾收集器，以确保如果您对循环引用等杂乱无章的话，可以清除所有内容。）</target>
        </trans-unit>
        <trans-unit id="b76b41563e694ef10941bc1da1406e4e19d640cf" translate="yes" xml:space="preserve">
          <source>A modifier available specifically to search and replace is the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; evaluation modifier. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; treats the replacement text as Perl code, rather than a double-quoted string. The value that the code returns is substituted for the matched substring. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; is useful if you need to do a bit of computation in the process of replacing text. This example counts character frequencies in a line:</source>
          <target state="translated">专门用于搜索和替换的修饰符是 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; 评估修饰符。 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; 将替换文本视为Perl代码，而不是双引号字符串。代码返回的值替换为匹配的子字符串。如果在替换文本的过程中需要进行一些计算，则 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; 很有用。本示例计算一行中的字符频率：</target>
        </trans-unit>
        <trans-unit id="68d67d7e195f6e0fb6e2bd79bf9224c3c8d1e2fd" translate="yes" xml:space="preserve">
          <source>A module for loading must be quoted.</source>
          <target state="translated">必须引用一个加载模块。</target>
        </trans-unit>
        <trans-unit id="8d98e6118bd0f23607596b779080678b5a48db1b" translate="yes" xml:space="preserve">
          <source>A module is a file that (by convention) provides a class of the same name (sans the .pm), plus an import method in that class that can be called to fetch exported symbols. This module may implement some of its methods by loading dynamic C or C++ objects, but that should be totally transparent to the user of the module. Likewise, the module might set up an AUTOLOAD function to slurp in subroutine definitions on demand, but this is also transparent. Only the</source>
          <target state="translated">一个模块是一个文件,它(按照惯例)提供了一个同名的类(去掉.pm),再加上该类中的一个导入方法,该方法可以被调用来获取导出的符号。这个模块可能会通过加载动态的C或C++对象来实现它的一些方法,但这对模块的用户来说应该是完全透明的。同样,该模块可能会设置一个AUTOLOAD函数,以根据需求吞吐子程序定义,但这也是透明的。只有</target>
        </trans-unit>
        <trans-unit id="22a73f9dccbade36d652d965f87a8dc414d1002a" translate="yes" xml:space="preserve">
          <source>A module is just a set of related functions in a library file, i.e., a Perl package with the same name as the file. It is specifically designed to be reusable by other modules or programs. It may do this by providing a mechanism for exporting some of its symbols into the symbol table of any package using it, or it may function as a class definition and make its semantics available implicitly through method calls on the class and its objects, without explicitly exporting anything. Or it can do a little of both.</source>
          <target state="translated">模块只是一个库文件中的一组相关函数,即与文件同名的Perl包。它被专门设计成可以被其他模块或程序重复使用。它可以通过提供一种机制来将它的一些符号导出到任何使用它的包的符号表中,或者它可以作为一个类定义,通过对类及其对象的方法调用来隐式地提供它的语义,而不显式地导出任何东西。或者它可以两者兼而有之。</target>
        </trans-unit>
        <trans-unit id="e2c608d01740d058ca105f502acc61136af2e317" translate="yes" xml:space="preserve">
          <source>A module that breaks a program text into a sequence of &lt;b&gt;tokens&lt;/b&gt; for later analysis by a parser.</source>
          <target state="translated">将程序文本分解为&lt;b&gt;令牌&lt;/b&gt;序列以供解析器稍后分析的模块。</target>
        </trans-unit>
        <trans-unit id="a247d01be7fadaf27f2b9413690f6e9d188b0db4" translate="yes" xml:space="preserve">
          <source>A module that helps you test testing modules that are built with &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;.</source>
          <target state="translated">一个模块，可以帮助您测试使用&lt;a href=&quot;../builder&quot;&gt;Test :: Builder构建的&lt;/a&gt;测试模块。</target>
        </trans-unit>
        <trans-unit id="3605e1a22b2192fa5aa9baada403491f3d035bb2" translate="yes" xml:space="preserve">
          <source>A module that implements DOS-like globbing with a few enhancements. It is largely compatible with perlglob.exe (the M$ setargv.obj version) in all but one respect--it understands wildcards in directory components.</source>
          <target state="translated">一个实现类似于DOS的globbing的模块,并做了一些改进。除了一个方面之外,它在很大程度上与perlglob.exe(M$ setargv.obj版本)兼容--它能理解目录组件中的通配符。</target>
        </trans-unit>
        <trans-unit id="28b02d8f461ab26400c63c168a94b3b2407585a9" translate="yes" xml:space="preserve">
          <source>A module's code has to be warning and strict-clean, since you can't guarantee the conditions that it'll be used under. Besides, you wouldn't want to distribute code that wasn't warning or strict-clean anyway, right?</source>
          <target state="translated">一个模块的代码必须是警告和严格清洁的,因为你不能保证它在什么条件下被使用。此外,你也不会想发布不是警告或严格清洁的代码,对吧?</target>
        </trans-unit>
        <trans-unit id="c91f5a59bb26aa2af0fbaed73706b37f93fe9a63" translate="yes" xml:space="preserve">
          <source>A more complete and flexible interface for reading/writing gzip files/buffers is included with the module &lt;code&gt;IO-Compress-Zlib&lt;/code&gt; . See &lt;a href=&quot;../io/compress/gzip&quot;&gt;IO::Compress::Gzip&lt;/a&gt; and &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;IO-Compress-Zlib&lt;/code&gt; 模块包含用于读取/写入gzip文件/缓冲区的更完整，更灵活的界面。有关更多详细信息，请参见&lt;a href=&quot;../io/compress/gzip&quot;&gt;IO :: Compress :: Gzip&lt;/a&gt;和&lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO :: Uncompress :: Gunzip&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a47893a0d4c8d8763c8f1003ea95b492858375e4" translate="yes" xml:space="preserve">
          <source>A more complete example of this is the Shell module on CPAN, which can treat undefined subroutine calls as calls to external programs.</source>
          <target state="translated">比较完整的例子是CPAN上的Shell模块,它可以把未定义的子程序调用当作对外部程序的调用。</target>
        </trans-unit>
        <trans-unit id="548a58ac3a8a4f644d16e2322da948be053c0188" translate="yes" xml:space="preserve">
          <source>A more dangerous version of getcwd(), but potentially faster.</source>
          <target state="translated">getcwd()的一个更危险的版本,但可能更快。</target>
        </trans-unit>
        <trans-unit id="9c501a7097bf538c4d236187aed836b438d78d12" translate="yes" xml:space="preserve">
          <source>A more dangerous, but potentially faster version of abs_path.</source>
          <target state="translated">一个更危险,但可能更快的abs_path版本。</target>
        </trans-unit>
        <trans-unit id="ac7a13ddb80b2e7ad5a52fa1664ac4bd3c5aef4e" translate="yes" xml:space="preserve">
          <source>A more direct work around is to change the filehandles used by &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt;.</source>
          <target state="translated">更直接的解决方法是更改&lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt;使用的文件句柄。</target>
        </trans-unit>
        <trans-unit id="3f085d06d504bc04c8c1f364c54e3b2d32d488c0" translate="yes" xml:space="preserve">
          <source>A more elegant (and safer) interface is needed.</source>
          <target state="translated">需要一个更优雅(更安全)的界面。</target>
        </trans-unit>
        <trans-unit id="d906501834bb08ebb1263e2b0973fc289f4c913f" translate="yes" xml:space="preserve">
          <source>A more general approach is to intervene manually, as with an example for the DB_File module, which requires SleepyCat's libdb.sl:</source>
          <target state="translated">比较通用的方法是手动干预,比如DB_File模块的例子,需要SleepyCat的libdb.sl。</target>
        </trans-unit>
        <trans-unit id="a0a3703fe588fb0e60a0c01fcfb0d140fe8770a1" translate="yes" xml:space="preserve">
          <source>A more readable, and perhaps more &quot;plain&quot; way is to use an alternate set of delimiters that doesn't require a single &quot;&amp;gt;&quot; to be escaped. Doubled angle brackets (&quot;&amp;lt;&amp;lt;&quot; and &quot;&amp;gt;&amp;gt;&quot;) may be used</source>
          <target state="translated">更具可读性，也许更简单的方法是使用另一组定界符，不需要转义单个&amp;ldquo;&amp;gt;&amp;rdquo;。可以使用双尖括号（&amp;ldquo; &amp;lt;&amp;lt;&amp;rdquo;和&amp;ldquo; &amp;gt;&amp;gt;&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="4f3108171bdddd798db1e9b26d8d770fd7116c20" translate="yes" xml:space="preserve">
          <source>A morpheme in a programming language, the smallest unit of text with semantic significance.</source>
          <target state="translated">编程语言中的一个语素,是具有语义意义的最小文本单位。</target>
        </trans-unit>
        <trans-unit id="2790cfc68a916af917f3cc04e172e9586561a9c1" translate="yes" xml:space="preserve">
          <source>A naive, but often sufficient heuristic on ASCII platforms, for testing the first highbit byte-sequence in a BOM-less file (whether in code or in Pod!), to see whether that sequence is valid as UTF-8 (RFC 2279) is to check whether that the first byte in the sequence is in the range 0xC2 - 0xFD</source>
          <target state="translated">在ASCII平台上,为了测试一个无BOM文件中的第一个高位字节序列(无论是代码还是Pod!),以确定该序列是否是有效的UTF-8(RFC 2279),一个天真的,但通常是充分的启发式方法是检查序列中的第一个字节是否在0xC2-0xFD的范围内。</target>
        </trans-unit>
        <trans-unit id="826c2733de66381609264a147718bd8a6dee2df5" translate="yes" xml:space="preserve">
          <source>A name for a concrete set of behaviors. A role is a way to add behavior to a class without inheritance.</source>
          <target state="translated">一组具体行为的名称。角色是将行为添加到类中而不需要继承的一种方式。</target>
        </trans-unit>
        <trans-unit id="6cc90f6ad3d71e4b26203e2d58a28aac467dba0f" translate="yes" xml:space="preserve">
          <source>A name that represents a particular instance of opening a directory to read it, until you close it. See the &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">代表打开目录以读取它直到关闭它的特定实例的名称。请参见 &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="57d4f638a5f1b060674c6232dbb757e9b9e2d99e" translate="yes" xml:space="preserve">
          <source>A name you give to a &lt;b&gt;statement&lt;/b&gt; so that you can talk about that statement elsewhere in the program.</source>
          <target state="translated">您为&lt;b&gt;语句指定的&lt;/b&gt;名称，以便您可以在程序的其他地方讨论该语句。</target>
        </trans-unit>
        <trans-unit id="9e963f1a0b66c9a6c01f8278ff2607d7847c7265" translate="yes" xml:space="preserve">
          <source>A named array in scalar context is quite different from what would at first glance appear to be a list in scalar context. You can't get a list like &lt;code&gt;(1,2,3)&lt;/code&gt; into being in scalar context, because the compiler knows the context at compile time. It would generate the scalar comma operator there, not the list construction version of the comma. That means it was never a list to start with.</source>
          <target state="translated">标量上下文中的命名数组与乍看之下似乎是标量上下文中的列表有很大不同。您不能将像 &lt;code&gt;(1,2,3)&lt;/code&gt; 这样的列表放入标量上下文中，因为编译器在编译时就知道该上下文。它将在此处生成标量逗号运算符，而不是逗号的列表构造版本。这意味着它从来都不是一个列表。</target>
        </trans-unit>
        <trans-unit id="75daf7108ed110da5eff87e476f0ddf2290f10b8" translate="yes" xml:space="preserve">
          <source>A named capture group. Identical in every respect to normal capturing parentheses &lt;code&gt;()&lt;/code&gt; but for the additional fact that the group can be referred to by name in various regular expression constructs (like &lt;code&gt;\g{NAME}&lt;/code&gt; ) and can be accessed by name after a successful match via &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%-&lt;/code&gt; . See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more details on the &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; hashes.</source>
          <target state="translated">命名捕获组。在各个方面与常规捕获括号 &lt;code&gt;()&lt;/code&gt; 相同，但另外一个事实是，该组可以在各种正则表达式构造中按名称引用（例如 &lt;code&gt;\g{NAME}&lt;/code&gt; ），并且可以通过 &lt;code&gt;%+&lt;/code&gt; 成功匹配后按名称进行访问或 &lt;code&gt;%-&lt;/code&gt; 。有关 &lt;code&gt;%+&lt;/code&gt; 和 &lt;code&gt;%-&lt;/code&gt; 哈希的更多详细信息，请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="184923b65ef8ae0c8a3e87da3ade2989c9cad4ca" translate="yes" xml:space="preserve">
          <source>A named collection of data, usually stored on disk in a &lt;b&gt;directory&lt;/b&gt; in a &lt;b&gt;filesystem&lt;/b&gt;. Roughly like a document, if you&amp;rsquo;re into office metaphors. In modern filesystems, you can actually give a file more than one name. Some files have special properties, like directories and devices.</source>
          <target state="translated">命名数据集合，通常存储在磁盘上&lt;b&gt;文件系统&lt;/b&gt;&lt;b&gt;目录&lt;/b&gt;中。如果您喜欢办公室的隐喻，则大致像文档。在现代文件系统中，您实际上可以为一个文件指定多个名称。一些文件具有特殊的属性，例如目录和设备。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6a9ab3c01eb064a3661e1bb7b921e5b073d19ecd" translate="yes" xml:space="preserve">
          <source>A named or otherwise accessible piece of program that can be invoked from elsewhere in the program in order to accomplish some subgoal of the program. A subroutine is often parameterized to accomplish different but related things depending on its input &lt;b&gt;arguments&lt;/b&gt;. If the subroutine returns a meaningful &lt;b&gt;value&lt;/b&gt;, it is also called a &lt;b&gt;function&lt;/b&gt;.</source>
          <target state="translated">可以从程序中的其他地方调用的已命名或可访问的一段程序，以完成程序的某些子目标。子例程通常根据其输入&lt;b&gt;参数&lt;/b&gt;被参数化以完成不同但相关的事情。如果子例程返回有意义的&lt;b&gt;值&lt;/b&gt;，则它也称为&lt;b&gt;函数&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="fd84ea80f8d7433a1aa60b125a9e6b4dc8885ca9" translate="yes" xml:space="preserve">
          <source>A named pipe (often referred to as a FIFO) is an old Unix IPC mechanism for processes communicating on the same machine. It works just like regular anonymous pipes, except that the processes rendezvous using a filename and need not be related.</source>
          <target state="translated">命名管道(通常被称为FIFO)是一种古老的Unix IPC机制,用于在同一台机器上进行通信的进程。它的工作原理和普通的匿名管道一样,只是进程之间使用一个文件名进行会合,而且不需要相关。</target>
        </trans-unit>
        <trans-unit id="e0d06a3ea39fd5acfb66f824c51baebd59e34891" translate="yes" xml:space="preserve">
          <source>A named storage location that can hold any of various kinds of &lt;b&gt;value&lt;/b&gt;, as your program sees fit.</source>
          <target state="translated">程序认为合适的名称存储位置，可以保存各种&lt;b&gt;值&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="092b494909d87658298161632e734b7420bfadba" translate="yes" xml:space="preserve">
          <source>A negatable option is specified with an exclamation mark &lt;code&gt;!&lt;/code&gt; after the option name:</source>
          <target state="translated">可否指定的选项带有感叹号 &lt;code&gt;!&lt;/code&gt; 选项名称后：</target>
        </trans-unit>
        <trans-unit id="99e2aec2990f88ba3867f8f52b0dfe7ccc80feb8" translate="yes" xml:space="preserve">
          <source>A negated expression, whether &lt;code&gt;!(EXPR)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/not&quot;&gt;not(EXPR)&lt;/a&gt;&lt;/code&gt;, or a logical exclusive-or, &lt;code&gt;(EXPR1) &lt;a href=&quot;functions/xor&quot;&gt;xor&lt;/a&gt; (EXPR2)&lt;/code&gt; . The bitwise versions (&lt;code&gt;~&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt;) are not included.</source>
          <target state="translated">甲否定表达，是否 &lt;code&gt;!(EXPR)&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/not&quot;&gt;not(EXPR)&lt;/a&gt;&lt;/code&gt; ，或逻辑异或， &lt;code&gt;(EXPR1) &lt;a href=&quot;functions/xor&quot;&gt;xor&lt;/a&gt; (EXPR2)&lt;/code&gt; 。不包括按位版本（ &lt;code&gt;~&lt;/code&gt; 和 &lt;code&gt;^&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="854efffaefa787b0da74283032eac82589c1370b" translate="yes" xml:space="preserve">
          <source>A negative signal name is the same as a negative signal number, killing process groups instead of processes. For example, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; will send &lt;code&gt;SIGKILL&lt;/code&gt; to the entire process group specified. That means you usually want to use positive not negative signals.</source>
          <target state="translated">负信号名称与负信号号相同，杀死进程组而不是进程。例如， &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; 并 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; 会将 &lt;code&gt;SIGKILL&lt;/code&gt; 发送到指定的整个进程组。这意味着您通常要使用正信号而不是负信号。</target>
        </trans-unit>
        <trans-unit id="489423251916154fc8d55b14cad49fcf24beefc2" translate="yes" xml:space="preserve">
          <source>A negative signal name is the same as a negative signal number, killing process groups instead of processes. For example, &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; will send &lt;code&gt;SIGKILL&lt;/code&gt; to the entire process group specified. That means you usually want to use positive not negative signals.</source>
          <target state="translated">负信号名称与负信号号相同，杀死进程组而不是进程。例如， &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; 并 &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; 会将 &lt;code&gt;SIGKILL&lt;/code&gt; 发送到指定的整个进程组。这意味着您通常要使用正信号而不是负信号。</target>
        </trans-unit>
        <trans-unit id="ea7af62eb6dd0992f67ddc428ca2b71250ece618" translate="yes" xml:space="preserve">
          <source>A nested code block was found that started with a delimiter that was specified as being only to be used as an outermost bracket.</source>
          <target state="translated">发现了一个嵌套的代码块,该代码块以一个定界符开始,该定界符被指定为只能用作最外层的括号。</target>
        </trans-unit>
        <trans-unit id="adfb1c2f0e03b3f5c0a88fd5a3243fdba91d6307" translate="yes" xml:space="preserve">
          <source>A new Net::POP3 object must be created with the</source>
          <target state="translated">一个新的Net::POP3对象必须通过使用</target>
        </trans-unit>
        <trans-unit id="a6942aa9b1458599174d5fd62309534ead314562" translate="yes" xml:space="preserve">
          <source>A new Net::SMTP object must be created with the</source>
          <target state="translated">新的 Net::SMTP 对象必须用</target>
        </trans-unit>
        <trans-unit id="a156df59890d9311b601d33944f7c60f5c525f91" translate="yes" xml:space="preserve">
          <source>A new dumper is created by a call</source>
          <target state="translated">通过调用</target>
        </trans-unit>
        <trans-unit id="ce307d445764b039e813c87b536bf4d7ae071734" translate="yes" xml:space="preserve">
          <source>A new executable loads an extension compiled for the old executable when an old perl executable is running. In this case the extension will not pick up the forwarder - with fatal results.</source>
          <target state="translated">当一个旧的perl可执行文件运行时,新的可执行文件会加载为旧的可执行文件编译的扩展。在这种情况下,扩展将无法拾取转发器--结果是致命的。</target>
        </trans-unit>
        <trans-unit id="ebbd18c3575dd80f81d435a80fe2d3c8ed42ba76" translate="yes" xml:space="preserve">
          <source>A new feature that allows the declaration of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; with modifiers, as in &lt;code&gt;sub foo : locked
method&lt;/code&gt; . Also another name for an &lt;b&gt;instance variable&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;.</source>
          <target state="translated">一种新功能，允许使用修饰符声明&lt;b&gt;变量&lt;/b&gt;和&lt;b&gt;子例程&lt;/b&gt;，如 &lt;code&gt;sub foo : locked method&lt;/code&gt; 。也是&lt;b&gt;对象&lt;/b&gt;的&lt;b&gt;实例变量&lt;/b&gt;的另一个名称。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e164afa95fb2ed837b476e0b8fef0b485a678f9f" translate="yes" xml:space="preserve">
          <source>A new version of the output file is always created, which inherits the structure and RMS attributes of the input file, except for owner and protections (and possibly timestamps; see below). All data from the input file is copied to the output file; if either of the first two parameters to &lt;code&gt;rmscopy&lt;/code&gt; is a file handle, its position is unchanged. (Note that this means a file handle pointing to the output file will be associated with an old version of that file after &lt;code&gt;rmscopy&lt;/code&gt; returns, not the newly created version.)</source>
          <target state="translated">始终创建一个新版本的输出文件，该文件继承了输入文件的结构和RMS属性，但所有者和保护（以及可能的时间戳；请参阅下文）除外。输入文件中的所有数据都将复制到输出文件中；如果 &lt;code&gt;rmscopy&lt;/code&gt; 的前两个参数之一是文件句柄，则其位置不变。 （请注意，这意味着指向输出文件的文件句柄将在 &lt;code&gt;rmscopy&lt;/code&gt; 返回后与该文件的旧版本相关联，而不是与新创建的版本相关联。）</target>
        </trans-unit>
        <trans-unit id="c0eacc7ea97ca14f2375b6edf715d33122368ca7" translate="yes" xml:space="preserve">
          <source>A nice general-purpose fixer-upper function for indented here documents follows. It expects to be called with a here document as its argument. It looks to see whether each line begins with a common substring, and if so, strips that substring off. Otherwise, it takes the amount of leading whitespace found on the first line and removes that much off each subsequent line.</source>
          <target state="translated">下面是一个很好的针对缩进 here 文档的通用固定器上位函数。它期望以一个 here 文档作为参数被调用。它查看每行是否以一个共同的子串开始,如果是,则将该子串剥离。否则,它将取第一行中的前导空格的数量,并从后面的每一行中删除该数量。</target>
        </trans-unit>
        <trans-unit id="0198bb3fbec60180f4c0bac09f0a4bb94105a46c" translate="yes" xml:space="preserve">
          <source>A nickname for something, which behaves in all ways as though you&amp;rsquo;d used the original name instead of the nickname. Temporary aliases are implicitly created in the loop variable for &lt;code&gt;foreach&lt;/code&gt; loops, in the &lt;code&gt;$_&lt;/code&gt; variable for &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; operators, in &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; during &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;&amp;rsquo;s comparison function, and in each element of &lt;code&gt;@_&lt;/code&gt; for the &lt;b&gt;actual arguments&lt;/b&gt; of a subroutine call. Permanent aliases are explicitly created in &lt;b&gt;packages&lt;/b&gt; by &lt;b&gt;importing&lt;/b&gt; symbols or by assignment to &lt;b&gt;typeglobs&lt;/b&gt;. Lexically scoped aliases for package variables are explicitly created by the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration.</source>
          <target state="translated">某事物的昵称，其行为在所有方面都好像您使用的是原始名称而不是昵称一样。临时别名为循环变量隐式创建 &lt;code&gt;foreach&lt;/code&gt; 循环，在 &lt;code&gt;$_&lt;/code&gt; 变量 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 的运营商，在 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 期间 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 的比较函数，并且在各元件 &lt;code&gt;@_&lt;/code&gt; 用于&lt;b&gt;实际参数&lt;/b&gt; a的子程序调用。永久别名是通过&lt;b&gt;导入&lt;/b&gt;符号或通过分配给&lt;b&gt;typeglob&lt;/b&gt;在&lt;b&gt;包&lt;/b&gt;中显式创建的&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;。包变量的词法范围别名由 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 明显式创建。</target>
        </trans-unit>
        <trans-unit id="c1173dc0bd47411653c3329572e8d27b49fadacc" translate="yes" xml:space="preserve">
          <source>A no-op job.</source>
          <target state="translated">一个不靠谱的工作。</target>
        </trans-unit>
        <trans-unit id="fb1ec4028a0ac13b58d2706d78d6f0e42a16b590" translate="yes" xml:space="preserve">
          <source>A no-op job. Returned by &lt;code&gt;TAP::Parser::Scheduler&lt;/code&gt; as an instruction to the harness to spin (keep executing tests) while the scheduler can't return a real job.</source>
          <target state="translated">没工作 由 &lt;code&gt;TAP::Parser::Scheduler&lt;/code&gt; 返回，作为在调度程序无法返回实际作业时旋转（保持执行测试）的线束的指令。</target>
        </trans-unit>
        <trans-unit id="3187ac42757f3c2b53340569d4306b0db3207981" translate="yes" xml:space="preserve">
          <source>A non-optional prefix was specified but wasn't found at the start of the text.</source>
          <target state="translated">指定了一个非可选的前缀,但在文本的开头没有找到。</target>
        </trans-unit>
        <trans-unit id="f9ce11826e25a9f2a78731b7ee2ed1865f372e1a" translate="yes" xml:space="preserve">
          <source>A not so obvious caveat with this (see [RT #79908]) is that the variable will be immediately inlined, and will stop behaving like a normal lexical variable, e.g. this will print &lt;code&gt;79907&lt;/code&gt; , not &lt;code&gt;79908&lt;/code&gt; :</source>
          <target state="translated">一个不太明显的警告（请参见[RT＃79908]）是该变量将立即内联，并且将停止像普通词法变量那样运行，例如，它将输出 &lt;code&gt;79907&lt;/code&gt; 而不是 &lt;code&gt;79908&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="33aa5e0c48db29d1cb8a94c57d888257eb0656f5" translate="yes" xml:space="preserve">
          <source>A notable and rather unavoidable problem with this method: &quot;x-mingo-tom&quot; has an &quot;x&quot; because the whole tag isn't an IANA-registered tag -- but super_languages('x-mingo-tom') is ('x-mingo') -- which isn't really right, since 'i-mingo' is registered. But this module has no way of knowing that. (But note that same_language_tag('x-mingo', 'i-mingo') is TRUE.)</source>
          <target state="translated">这个方法有一个显著的、不可避免的问题。&quot;x-mingo-tom &quot;有一个 &quot;x&quot;,因为整个标签不是IANA注册的标签 --但super_languages('x-mingo-tom')是('x-mingo')--这其实并不正确,因为'i-mingo'已经注册了。但这个模块没有办法知道。(但请注意,same_language_tag('x-mingo','i-mingo')是TRUE。)</target>
        </trans-unit>
        <trans-unit id="11f822ddf21914cec4db6b8a6e4ef4d83bd0921c" translate="yes" xml:space="preserve">
          <source>A note about prefixes</source>
          <target state="translated">关于前缀的说明</target>
        </trans-unit>
        <trans-unit id="0a3c02a71990e114ae348bdc123412980dc80cfc" translate="yes" xml:space="preserve">
          <source>A note on freshness</source>
          <target state="translated">关于新鲜度的说明</target>
        </trans-unit>
        <trans-unit id="b0e5798976260679942afb564efdac5fe47bc36f" translate="yes" xml:space="preserve">
          <source>A note: to save time, 'regular expression' is often abbreviated as regexp or regex. Regexp is a more natural abbreviation than regex, but is harder to pronounce. The Perl pod documentation is evenly split on regexp vs regex; in Perl, there is more than one way to abbreviate it. We'll use regexp in this tutorial.</source>
          <target state="translated">注意:为了节省时间,&quot;正则表达式 &quot;通常被缩写为regexp或regex。Regexp是比regex更自然的缩写,但比较难发音。Perl pod 文档中对 regexp 与 regex 是平分秋色的,在 Perl 中,有不止一种缩写方式。在本教程中,我们将使用 regexp。</target>
        </trans-unit>
        <trans-unit id="7a28dfd2dad981af662c7cb062386ed614bc87a3" translate="yes" xml:space="preserve">
          <source>A notional &amp;ldquo;baton&amp;rdquo; handed around the Perl community indicating who is the lead integrator in some arena of development.</source>
          <target state="translated">在Perl社区周围有一个概念性的&amp;ldquo;警棍&amp;rdquo;，指示谁是某些开发领域的主要集成商。</target>
        </trans-unit>
        <trans-unit id="ab0d25629a9f27d8e2343a6d3ae7ea4be0af2ea6" translate="yes" xml:space="preserve">
          <source>A number in base 16, &amp;ldquo;hex&amp;rdquo; for short. The digits for 10 through 15 are customarily represented by the letters &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt; . Hexadecimal constants in Perl start with &lt;code&gt;0x&lt;/code&gt; . See also the &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">以16为底的数字，简称&amp;ldquo;十六进制&amp;rdquo;。10至15的数字通常由字母 &lt;code&gt;a&lt;/code&gt; 至 &lt;code&gt;f&lt;/code&gt; 表示。Perl中的十六进制常量以 &lt;code&gt;0x&lt;/code&gt; 开头。另请参见Camel第27章&amp;ldquo;函数&amp;rdquo;中的 &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="a2e5df9d465cc20aefe1124101a063a27122315b" translate="yes" xml:space="preserve">
          <source>A number in base 8. Only the digits 0 through 7 are allowed. Octal constants in Perl start with 0, as in 013. See also the &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">以8为底​​的数字。仅允许使用数字0到7。Perl中的八进制常量从0开始，如013中所示。另请参见 &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="a69cd7220ef5a1c647fe095901d92bd9cd440d40" translate="yes" xml:space="preserve">
          <source>A number of backslash sequences have to do with changing the character, or characters following them. &lt;code&gt;\l&lt;/code&gt; will lowercase the character following it, while &lt;code&gt;\u&lt;/code&gt; will uppercase (or, more accurately, titlecase) the character following it. They provide functionality similar to the functions &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">许多反斜杠序列与更改字符或跟随其后的字符有关。 &lt;code&gt;\l&lt;/code&gt; 将其后的字符小写，而 &lt;code&gt;\u&lt;/code&gt; 将其后的字符大写（或更准确地说，标题大写）。它们提供的功能类似于 &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; 的功能。</target>
        </trans-unit>
        <trans-unit id="459b7ae43dc0118e5f951dff6050b593d0645ae4" translate="yes" xml:space="preserve">
          <source>A number of canned filers are provided with this module. They cover a number of the main areas that filters are needed when interfacing with DBM files. They also act as templates for your own filters.</source>
          <target state="translated">本模块提供了一些预制的过滤程序,它们涵盖了与DBM文件接口时需要过滤的一些主要领域。它们涵盖了与DBM文件接口时需要过滤器的一些主要领域。它们还可以作为您自己的过滤器的模板。</target>
        </trans-unit>
        <trans-unit id="f165970578836ece242fb56057dfca4b475f795a" translate="yes" xml:space="preserve">
          <source>A number of functions are supplied in</source>
          <target state="translated">中提供了一些函数。</target>
        </trans-unit>
        <trans-unit id="6be56084a39af168e51355bee3d9a2b6a1443404" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 某些方法需要许多符号常量。默认情况下不会导入任何内容。</target>
        </trans-unit>
        <trans-unit id="f171c4c952b5198d03d74dd09582818a3af3ac23" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 某些方法需要许多符号常量。默认情况下不会导入任何内容。</target>
        </trans-unit>
        <trans-unit id="8444a37c81d8d0b0573487ab107c561cc0dcc2fd" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 某些方法需要许多符号常量。默认情况下不会导入任何内容。</target>
        </trans-unit>
        <trans-unit id="2b8207ded75c4eb74b9b2506733acf10f3db4dee" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Zip&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::Zip&lt;/code&gt; 某些方法需要许多符号常量。默认情况下不会导入任何内容。</target>
        </trans-unit>
        <trans-unit id="13520cd60b01e1d5b0a654b3de30cd8d691bfd72" translate="yes" xml:space="preserve">
          <source>A number of the perl self-tests fails for various reasons; generally these are minor and due to subtle differences between common POSIX-based environments and the OpenVOS POSIX environment. Ensure that you conduct sufficient testing of your code to guarantee that it works properly in the OpenVOS environment.</source>
          <target state="translated">一些perl自检失败的原因有很多,一般来说这些都是小问题,是由于常见的基于POSIX的环境和OpenVOS POSIX环境之间的微妙差异。确保你对你的代码进行充分的测试,以保证它在OpenVOS环境下正常工作。</target>
        </trans-unit>
        <trans-unit id="6938035226ed22bf21a82d2591890e65b71e1814" translate="yes" xml:space="preserve">
          <source>A number or quoted &lt;b&gt;string&lt;/b&gt;&amp;mdash;an actual &lt;b&gt;value&lt;/b&gt; in the text of your program, as opposed to a &lt;b&gt;variable&lt;/b&gt;.</source>
          <target state="translated">数字或带引号的&lt;b&gt;字符串&lt;/b&gt; - 程序文本中的实际&lt;b&gt;值&lt;/b&gt;，而不是&lt;b&gt;变量&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="817e0a226397234bf07db9517946a4f73aedf564" translate="yes" xml:space="preserve">
          <source>A number with no fractional (decimal) part. A counting number, like 1, 2, 3, and so on, but including 0 and the negatives.</source>
          <target state="translated">一个没有小数(十进制)的数字。一个数数,如1、2、3等,但包括0和负数。</target>
        </trans-unit>
        <trans-unit id="c7326b507f702c91b1651bab340f7fd9d1233ba7" translate="yes" xml:space="preserve">
          <source>A numeric value corresponding to the desired exit status</source>
          <target state="translated">与期望的退出状态相对应的数值。</target>
        </trans-unit>
        <trans-unit id="516dd9f40fab20fab164bbcf97c01e41beccb620" translate="yes" xml:space="preserve">
          <source>A numeric value corresponding to the desired exit status.</source>
          <target state="translated">与期望的退出状态相对应的数值。</target>
        </trans-unit>
        <trans-unit id="f65805b27975bd2ea9ebc728a7ffd9aba1dc2684" translate="yes" xml:space="preserve">
          <source>A one- or two-character abbreviation for the OP's name.</source>
          <target state="translated">上位者姓名的一个或两个字符的缩写。</target>
        </trans-unit>
        <trans-unit id="3834679d6aeef19dae7b1ac9263711aa538649cc" translate="yes" xml:space="preserve">
          <source>A opposite problem occurs if you extract a UTF8-encoded file from a tarball. Using &lt;code&gt;get_content()&lt;/code&gt; on the &lt;code&gt;Archive::Tar::File&lt;/code&gt; object will return its content as a bytestring, not as a Unicode string.</source>
          <target state="translated">如果从压缩包中提取UTF8编码的文件，则会出现相反的问题。在 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 对象上使用 &lt;code&gt;get_content()&lt;/code&gt; 会将其内容作为字节字符串而不是Unicode字符串返回。</target>
        </trans-unit>
        <trans-unit id="7d591c8e0c3b224f857fbffdd8e1cd395cd343c4" translate="yes" xml:space="preserve">
          <source>A package statement affects dynamic variables only, including those you've used &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; on, but</source>
          <target state="translated">package语句仅影响动态变量，包括您在 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 使用的变量，但是</target>
        </trans-unit>
        <trans-unit id="fb0a21b3a9fa52dc9e4b76474cd2a329094bf2cb" translate="yes" xml:space="preserve">
          <source>A package statement affects dynamic variables only, including those you've used &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; on, but</source>
          <target state="translated">package语句仅影响动态变量，包括您在 &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 使用的变量，但是</target>
        </trans-unit>
        <trans-unit id="17811bc7788393455d0445378861485836290fe5" translate="yes" xml:space="preserve">
          <source>A packet of data, such as a &lt;b&gt;UDP&lt;/b&gt; message, that (from the viewpoint of the programs involved) can be sent independently over the network. (In fact, all packets are sent independently at the &lt;b&gt;IP&lt;/b&gt; level, but &lt;b&gt;stream&lt;/b&gt; protocols such as &lt;b&gt;TCP&lt;/b&gt; hide this from your program.)</source>
          <target state="translated">数据包，例如&lt;b&gt;UDP&lt;/b&gt;消息，可以从网络上独立发送（从所涉及程序的角度来看）。（实际上，所有数据包都是在&lt;b&gt;IP&lt;/b&gt;级别上独立发送的，但是&lt;b&gt;TCP&lt;/b&gt;等&lt;b&gt;流&lt;/b&gt;协议&lt;b&gt;会将其&lt;/b&gt;隐藏在程序中。）</target>
        </trans-unit>
        <trans-unit id="a8fade7e7e6957062a1ff55f1cde07bb98b07451" translate="yes" xml:space="preserve">
          <source>A parenthesized &lt;b&gt;subpattern&lt;/b&gt; used to group parts of a &lt;b&gt;regular expression&lt;/b&gt; into a single &lt;b&gt;atom&lt;/b&gt;.</source>
          <target state="translated">括号内的&lt;b&gt;子模式，&lt;/b&gt;用于将&lt;b&gt;正则表达式的&lt;/b&gt;部分分组为一个&lt;b&gt;原子&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="d31a105759b488881233b964b8bc299b268f919f" translate="yes" xml:space="preserve">
          <source>A particular 8-bit extension to ASCII that includes grave and acute accented Latin characters. Languages that can employ ISO 8859-1 include all the languages covered by ASCII as well as Afrikaans, Albanian, Basque, Catalan, Danish, Faroese, Finnish, Norwegian, Portuguese, Spanish, and Swedish. Dutch is covered albeit without the ij ligature. French is covered too but without the oe ligature. German can use ISO 8859-1 but must do so without German-style quotation marks. This set is based on Western European extensions to ASCII and is commonly encountered in world wide web work. In IBM character code set identification terminology, ISO 8859-1 is also known as CCSID 819 (or sometimes 0819 or even 00819).</source>
          <target state="translated">ASCII码的一种特殊的8位扩展,包括重音和锐音拉丁字符。可以使用ISO 8859-1的语言包括ASCII所涵盖的所有语言,以及南非荷兰语、阿尔巴尼亚语、巴斯克语、加泰罗尼亚语、丹麦语、法罗语、芬兰语、挪威语、葡萄牙语、西班牙语和瑞典语。荷兰语也被覆盖了,尽管没有ij连接符。法文也包括在内,但没有oe连接符。德语可以使用ISO 8859-1,但必须不使用德式引号。这套字符集是基于西欧对ASCII的扩展,在世界范围内的网络工作中经常遇到。在IBM字符码集识别术语中,ISO 8859-1也被称为CCSID 819(有时也称为0819甚至00819)。</target>
        </trans-unit>
        <trans-unit id="e0e8dc4da39b64602467413f10af7327c1334e77" translate="yes" xml:space="preserve">
          <source>A past developer of this module once said that it was no longer being actively developed. However, rumors of its demise were greatly exaggerated. Feedback and suggestions are quite welcome.</source>
          <target state="translated">该模块过去的一位开发者曾经说过,它已经不再积极开发了。然而,关于它消亡的传言被大大夸大了。我们相当欢迎反馈和建议。</target>
        </trans-unit>
        <trans-unit id="8c54ff10ac1e2c9e724650394df49761e14faa10" translate="yes" xml:space="preserve">
          <source>A patch is likely to be rejected if it closes off future avenues of development. For instance, a patch that placed a true and final interpretation on prototypes is likely to be rejected because there are still options for the future of prototypes that haven't been addressed.</source>
          <target state="translated">如果一个补丁关闭了未来的发展途径,那么它很可能会被拒绝。例如,一个对原型进行真实和最终解释的补丁很可能被拒绝,因为仍有关于原型的未来选择没有得到解决。</target>
        </trans-unit>
        <trans-unit id="8b84380ed4a63c4a53b35f4fed5c94c1acb30451" translate="yes" xml:space="preserve">
          <source>A pattern that contains one or more variables to be interpolated before parsing the pattern as a &lt;b&gt;regular expression&lt;/b&gt;, and that therefore cannot be analyzed at compile time, but must be reanalyzed each time the pattern match operator is evaluated. Runtime patterns are useful but expensive.</source>
          <target state="translated">一种模式，该模式包含一个或多个要在将模式解析为&lt;b&gt;正则表达式&lt;/b&gt;之前要进行插值的变量，因此无法在编译时进行分析，但是每次对模式匹配运算符进行求值时都必须重新分析。运行时模式有用但很昂贵。</target>
        </trans-unit>
        <trans-unit id="e54b749fa56abf529dd225e42a12bbcecb4cb20e" translate="yes" xml:space="preserve">
          <source>A pattern that is compiled with the &lt;code&gt;/u&lt;/code&gt; or &lt;code&gt;/a&lt;/code&gt; modifiers is treated as Unicode (though there are some restrictions with &lt;code&gt;/a&lt;/code&gt; ). Under the &lt;code&gt;/d&lt;/code&gt; and &lt;code&gt;/l&lt;/code&gt; modifiers, there are several other indications for Unicode; see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;/u&lt;/code&gt; 或 &lt;code&gt;/a&lt;/code&gt; 修饰符编译的模式被视为Unicode（尽管 &lt;code&gt;/a&lt;/code&gt; 有所限制）。在 &lt;code&gt;/d&lt;/code&gt; 和 &lt;code&gt;/l&lt;/code&gt; 修饰符下，还有其他几种Unicode指示：请参见&lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre中的字符集修饰符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac81362ffb97f570e29dfbe7c502b0eb97a9aae0" translate="yes" xml:space="preserve">
          <source>A person with permissions to index a &lt;b&gt;namespace&lt;/b&gt; in &lt;b&gt;PAUSE&lt;/b&gt;. Anyone can upload any namespace, but only primary and co-maintainers get their contributions indexed.</source>
          <target state="translated">有权在&lt;b&gt;PAUSE中&lt;/b&gt;索引&lt;b&gt;名称空间&lt;/b&gt;的人。任何人都可以上载任何名称空间，但只有主要和共同维护者才能对其贡献进行索引。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bdf584f5364a06bf31c21ab092ad59923872f304" translate="yes" xml:space="preserve">
          <source>A pidgin-like lingo spoken among &amp;rsquo;droids when they don&amp;rsquo;t wish to reveal their orientation (see &lt;b&gt;endian&lt;/b&gt;). Named after some similar languages spoken (for similar reasons) between compilers and interpreters in the late 20ᵗʰ century. These languages are characterized by representing everything as a nonarchitecture-dependent sequence of bytes.</source>
          <target state="translated">当机器人不希望透露自己的方位时，它们会在&amp;ldquo;机器人&amp;rdquo;中说出一种类似pidgin的术语（请参见&lt;b&gt;endian&lt;/b&gt;）。以20世纪末期在编译器和解释器之间（出于类似原因）使用的一些类似语言命名。这些语言的特征是将所有内容都表示为与体系结构无关的字节序列。</target>
        </trans-unit>
        <trans-unit id="d44cad0ebf83404ba135e65877b0a7348740b15c" translate="yes" xml:space="preserve">
          <source>A piece of &lt;b&gt;memory&lt;/b&gt; accessible by two different &lt;b&gt;processes&lt;/b&gt; who otherwise would not see each other&amp;rsquo;s memory.</source>
          <target state="translated">由两个不同&lt;b&gt;进程&lt;/b&gt;访问的一块&lt;b&gt;内存&lt;/b&gt;，否则它们将不会看到彼此的内存。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ae75b42221a978d2300d9bbb31da21cdb6583f30" translate="yes" xml:space="preserve">
          <source>A piece of data supplied to a &lt;b&gt;program&lt;/b&gt;, &lt;b&gt;subroutine&lt;/b&gt;, &lt;b&gt;function&lt;/b&gt;, or &lt;b&gt;method&lt;/b&gt; to tell it what it&amp;rsquo;s supposed to do. Also called a &amp;ldquo;parameter&amp;rdquo;.</source>
          <target state="translated">提供给&lt;b&gt;program&lt;/b&gt;，&lt;b&gt;subroutine&lt;/b&gt;，&lt;b&gt;function&lt;/b&gt;或&lt;b&gt;method&lt;/b&gt;的一段数据，告诉它应该做什么。也称为&amp;ldquo;参数&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="94f70c32cf9b02415f8a7273bc9818046dbf12f7" translate="yes" xml:space="preserve">
          <source>A piece of data worth eight &lt;b&gt;bits&lt;/b&gt; in most places.</source>
          <target state="translated">一个数据值得八个&lt;b&gt;位&lt;/b&gt;最多的地方。</target>
        </trans-unit>
        <trans-unit id="b577f26c3053457a977acc838db8d07639cc6ac7" translate="yes" xml:space="preserve">
          <source>A pitfall when fallback is TRUE and Perl resorts to a built-in implementation of an operator is that some operators have more than one semantic, for example &lt;code&gt;|&lt;/code&gt;:</source>
          <target state="translated">当fallback为TRUE并且Perl求助于运算符的内置实现时，一个陷阱是某些运算符具有多个语义，例如 &lt;code&gt;|&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d50a84892f70340bd3a9931b241841288e99df2a" translate="yes" xml:space="preserve">
          <source>A plain &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie&lt;/code&gt; implies &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie qw(:default)&lt;/code&gt; . Note that &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; are not enabled by default. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; requires the optional &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; module to be installed, and enabling &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will invalidate their exotic forms. See &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt; below for more details.</source>
          <target state="translated">普通 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie&lt;/code&gt; 意味着 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie qw(:default)&lt;/code&gt; 。请注意，默认情况下未启用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 需要安装可选的&lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC :: System :: Simple&lt;/a&gt;模块，并且启用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 将使它们的奇特形式无效。见&lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt;以下更多的细节。</target>
        </trans-unit>
        <trans-unit id="b5112ffa79f8fbea8b85cd379c0dac6621cfbb1b" translate="yes" xml:space="preserve">
          <source>A port of SysV IPC is available for Cygwin.</source>
          <target state="translated">SysV IPC的移植版可用于Cygwin。</target>
        </trans-unit>
        <trans-unit id="608e0fee3c4504f82197f6257599cc064afc0c33" translate="yes" xml:space="preserve">
          <source>A port of dmake for Windows is available from:</source>
          <target state="translated">Windows 的 dmake 移植版可以从以下地方获得。</target>
        </trans-unit>
        <trans-unit id="107ead699a34a6b92016575e257f6bfde51b2d06" translate="yes" xml:space="preserve">
          <source>A portion of a &lt;b&gt;string&lt;/b&gt;, starting at a certain &lt;b&gt;character&lt;/b&gt; position (&lt;b&gt;offset&lt;/b&gt;) and proceeding for a certain number of characters.</source>
          <target state="translated">&lt;b&gt;字符串&lt;/b&gt;的一部分，从某个&lt;b&gt;字符&lt;/b&gt;位置（&lt;b&gt;offset&lt;/b&gt;）开始并进行一定数量的字符。</target>
        </trans-unit>
        <trans-unit id="2df08b2dab9ca8b1fdefb915b96c623e0200cba0" translate="yes" xml:space="preserve">
          <source>A positional parameter is made optional by giving a default value, separated from the parameter name by &lt;code&gt;=&lt;/code&gt; :</source>
          <target state="translated">通过提供默认值使位置参数成为可选参数，该默认值与参数名称之间用 &lt;code&gt;=&lt;/code&gt; 分隔：</target>
        </trans-unit>
        <trans-unit id="b85d6bf4f6c4fdd5d60e077f21d5dcceb61dc47f" translate="yes" xml:space="preserve">
          <source>A possibly-threaded program using a possibly-threaded module might have code like this:</source>
          <target state="translated">一个使用可能线程模块的可能线程程序可能有这样的代码。</target>
        </trans-unit>
        <trans-unit id="6b3a72b5c10540ed557a8982bdee312dd7a07842" translate="yes" xml:space="preserve">
          <source>A powerful tool for optimizing such beasts is what is known as an &quot;independent group&quot;, which does not backtrack (see &lt;a href=&quot;#(%3f%3epattern)&quot;&gt;(?&amp;gt;pattern)&lt;/a&gt;). Note also that zero-length look-ahead/look-behind assertions will not backtrack to make the tail match, since they are in &quot;logical&quot; context: only whether they match is considered relevant. For an example where side-effects of look-ahead</source>
          <target state="translated">用于优化此类野兽的强大工具是所谓的&amp;ldquo;独立组&amp;rdquo;，它不会回溯（请参阅&lt;a href=&quot;#(%3f%3epattern)&quot;&gt;（？&amp;gt; pattern）&lt;/a&gt;）。还要注意，零长度的超前/后向断言不会回溯以使尾部匹配，因为它们处于&amp;ldquo;逻辑&amp;rdquo;上下文中：仅认为它们是否匹配才有意义。例如，前瞻的副作用</target>
        </trans-unit>
        <trans-unit id="f8090f10d3e078e45a1b56ad19ca0993e67735bf" translate="yes" xml:space="preserve">
          <source>A pragma is a module which influences some aspect of the compile time or run time behaviour of Perl, such as &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;warnings&lt;/code&gt; . With Perl 5.10 you are no longer limited to the built in pragmata; you can now create user pragmata that modify the behaviour of user functions within a lexical scope.</source>
          <target state="translated">编译指示是一个模块，它会影响Perl的编译时或运行时行为的某些方面，例如 &lt;code&gt;strict&lt;/code&gt; 或 &lt;code&gt;warnings&lt;/code&gt; 。使用Perl 5.10，您将不再局限于内置的编译指示。您现在可以创建用户语用表，以在词法范围内修改用户功能的行为。</target>
        </trans-unit>
        <trans-unit id="3adf63746ff6644ce7bf5f35f924e0b644796838" translate="yes" xml:space="preserve">
          <source>A precomputed hash value for the MRO's name, or 0.</source>
          <target state="translated">MRO名称的预计算哈希值,或0。</target>
        </trans-unit>
        <trans-unit id="fef186fd41bd258794b7d0075ad4e261c2b3c05f" translate="yes" xml:space="preserve">
          <source>A predefined &lt;b&gt;character class&lt;/b&gt; matchable by the &lt;code&gt;\p&lt;/code&gt; or &lt;code&gt;\P&lt;/code&gt;&lt;b&gt;metasymbol&lt;/b&gt;. &lt;b&gt;Unicode&lt;/b&gt; defines hundreds of standard properties for every possible codepoint, and Perl defines a few of its own, too.</source>
          <target state="translated">可通过 &lt;code&gt;\p&lt;/code&gt; 或 &lt;code&gt;\P&lt;/code&gt; &lt;b&gt;元符号&lt;/b&gt;匹配的预定义&lt;b&gt;字符类&lt;/b&gt;。&lt;b&gt;Unicode&lt;/b&gt;为每个可能的代码点定义了数百个标准属性，而Perl也定义了一些它自己的属性。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="753111eab29b1d3a3d48d9bfe5c8e1db8a75f990" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvIVx&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">&lt;code&gt;SvIVx&lt;/code&gt; 宏的私有实现，用于无法应付复杂的宏表达式的编译器。始终改用宏。</target>
        </trans-unit>
        <trans-unit id="194c1f16db6963ad188c9a67ab4a97692452c7d0" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvNVx&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">&lt;code&gt;SvNVx&lt;/code&gt; 宏的私有实现，用于无法应付复杂的宏表达式的编译器。始终改用宏。</target>
        </trans-unit>
        <trans-unit id="45f81efd0665fe345ae1ff71f7dc78b1d8a8b9cf" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvPV&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 宏的私有实现，用于无法应付复杂的宏表达式的编译器。始终改用宏。</target>
        </trans-unit>
        <trans-unit id="28ff9ef13649ddfcf7cbf759240331fcc05c09ec" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvPVbyte&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">&lt;code&gt;SvPVbyte&lt;/code&gt; 宏的私有实现，用于无法应对复杂的宏表达式的编译器。始终改用宏。</target>
        </trans-unit>
        <trans-unit id="4c48a8487b346d5dd9b069a77af5f464c4aaa911" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvPVutf8&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">&lt;code&gt;SvPVutf8&lt;/code&gt; 宏的私有实现，用于无法应付复杂的宏表达式的编译器。始终改用宏。</target>
        </trans-unit>
        <trans-unit id="ccefc2a8adb4ddac3b369c74930a6dbb95e32f5b" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvUVx&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">&lt;code&gt;SvUVx&lt;/code&gt; 宏的私有实现，用于无法应付复杂的宏表达式的编译器。始终改用宏。</target>
        </trans-unit>
        <trans-unit id="daa3f361ccd92e0c8c69a72e7a450ec455f808bd" translate="yes" xml:space="preserve">
          <source>A process that has died (exited) but whose parent has not yet received proper notification of its demise by virtue of having called &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;. If you &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, you must clean up after your child processes when they exit; otherwise, the process table will fill up and your system administrator will Not Be Happy with you.</source>
          <target state="translated">已死（退出）但其父进程尚未通过调用 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 来接收其死亡的适当通知的进程。如果 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; ，则必须在子进程退出后清理。否则，进程表将填满，您的系统管理员将对您不满意。</target>
        </trans-unit>
        <trans-unit id="8efafe66eae216a82a4ad38f05565ca385de1f6b" translate="yes" xml:space="preserve">
          <source>A process that usually starts when the system boots and shuts down when the system is shut down is called a daemon (Disk And Execution MONitor). If a daemon process has a configuration file which is modified after the process has been started, there should be a way to tell that process to reread its configuration file without stopping the process. Many daemons provide this mechanism using a &lt;code&gt;SIGHUP&lt;/code&gt; signal handler. When you want to tell the daemon to reread the file, simply send it the &lt;code&gt;SIGHUP&lt;/code&gt; signal.</source>
          <target state="translated">通常在系统启动时启动，而在系统关闭时关闭的进程称为守护程序（磁盘和执行监视器）。如果守护进程具有在启动进程后被修改的配置文件，则应该有一种方法告诉该进程在不停止该进程的情况下重新读取其配置文件。许多守护程序使用 &lt;code&gt;SIGHUP&lt;/code&gt; 信号处理程序提供此机制。当您要告诉守护程序重新读取文件时，只需发送 &lt;code&gt;SIGHUP&lt;/code&gt; 信号即可。</target>
        </trans-unit>
        <trans-unit id="2cb736d823d351c183302791cfaf0e9b2bb8195b" translate="yes" xml:space="preserve">
          <source>A program designed to take a &lt;b&gt;stream&lt;/b&gt; of input and transform it into a stream of output.</source>
          <target state="translated">一种旨在获取输入&lt;b&gt;流&lt;/b&gt;并将其转换为输出流的程序。</target>
        </trans-unit>
        <trans-unit id="0e57854f673e33842a3f502762fb9daa3a8e1f70" translate="yes" xml:space="preserve">
          <source>A program or subroutine that runs some other program or subroutine for you, modifying some of its input or output to better suit your purposes.</source>
          <target state="translated">一个为你运行其他程序或子程序的程序或子程序,修改它的一些输入或输出以更好地满足你的目的。</target>
        </trans-unit>
        <trans-unit id="d4949b399696681050e02e3aa6d195b375c7c318" translate="yes" xml:space="preserve">
          <source>A program technique that lets you evaluate an &lt;b&gt;expression&lt;/b&gt; and then, based on the value of the expression, do a multiway branch to the appropriate piece of code for that value. Also called a &amp;ldquo;case structure&amp;rdquo;, named after the similar Pascal construct. Most switch statements in Perl are spelled &lt;code&gt;given&lt;/code&gt; . See &amp;ldquo;The &lt;code&gt;given&lt;/code&gt; statement&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="translated">一种编程技术，可让您评估&lt;b&gt;表达式&lt;/b&gt;，然后根据&lt;b&gt;表达式&lt;/b&gt;的值对该值执行适当的代码多路跳转。也称为&amp;ldquo;案例结构&amp;rdquo;，以类似的Pascal构造命名。Perl中的大多数switch语句都是拼写 &lt;code&gt;given&lt;/code&gt; 。请参见骆驼第4章&amp;ldquo;声明和声明&amp;rdquo;中的&amp;ldquo; &lt;code&gt;given&lt;/code&gt; 声明&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5911c3911da879ac96181b5190227b6bb058fcf1" translate="yes" xml:space="preserve">
          <source>A program that lets you step through the &lt;b&gt;execution&lt;/b&gt; of your program, stopping or printing things out here and there to see whether anything has gone wrong, and, if so, what. The &amp;ldquo;symbolic&amp;rdquo; part just means that you can talk to the debugger using the same symbols with which your program is written.</source>
          <target state="translated">一个程序，可让您逐步&lt;b&gt;执行&lt;/b&gt;程序，在此处或此处停止或打印内容，以查看是否出了什么问题，如果出了错，怎么办。&amp;ldquo;符号&amp;rdquo;部分仅表示您可以使用与编写程序时相同的符号与调试器对话。</target>
        </trans-unit>
        <trans-unit id="8959e21bc141d47a80e97a7ffb793dfa86254ad0" translate="yes" xml:space="preserve">
          <source>A property named 'var' is assumed to exist for the opcodes, and is interpolated into the rendering.</source>
          <target state="translated">一个名为'var'的属性被假定为存在于操作码中,并被内插到渲染中。</target>
        </trans-unit>
        <trans-unit id="7afee4b0974cba3382e7bb4183222667ce915680" translate="yes" xml:space="preserve">
          <source>A property of certain characters. Originally, typesetter stored capital letters in the upper of two cases and small letters in the lower one. Unicode recognizes three cases: &lt;b&gt;lowercase&lt;/b&gt; (&lt;b&gt;character property&lt;/b&gt;&lt;code&gt;\p{lower}&lt;/code&gt; ), &lt;b&gt;titlecase&lt;/b&gt; (&lt;code&gt;\p{title}&lt;/code&gt; ), and &lt;b&gt;uppercase&lt;/b&gt; (&lt;code&gt;\p{upper}&lt;/code&gt; ). A fourth casemapping called &lt;b&gt;foldcase&lt;/b&gt; is not itself a distinct case, but it is used internally to implement &lt;b&gt;casefolding&lt;/b&gt;. Not all letters have case, and some nonletters have case.</source>
          <target state="translated">某些字符的属性。最初，排字员在两种情况的上部存储大写字母，在下部的情况下存储小写字母。 Unicode的识别三种情况：&lt;b&gt;小写&lt;/b&gt;（&lt;b&gt;字符属性&lt;/b&gt; &lt;code&gt;\p{lower}&lt;/code&gt; ），&lt;b&gt;首字母大写&lt;/b&gt;（ &lt;code&gt;\p{title}&lt;/code&gt; ），和&lt;b&gt;大写&lt;/b&gt;（ &lt;code&gt;\p{upper}&lt;/code&gt; ）。第四种名为&lt;b&gt;foldcase的casemapping&lt;/b&gt;本身并不是一个不同的情况，但是在内部用于实现&lt;b&gt;casefolding&lt;/b&gt;。并非所有字母都有大小写，有些非字母也有大小写。</target>
        </trans-unit>
        <trans-unit id="992dca0adb9b646b76591cb61fee4cdfffebc9ec" translate="yes" xml:space="preserve">
          <source>A pseudo layer that removes the top-most layer. Gives perl code a way to manipulate the layer stack. Note that &lt;code&gt;:&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; only works on real layers and will not undo the effects of pseudo layers like &lt;code&gt;:utf8&lt;/code&gt; . An example of a possible use might be:</source>
          <target state="translated">删除最顶层的伪层。为perl代码提供一种操纵层堆栈的方法。请注意 &lt;code&gt;:&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 仅在真实图层上起作用，并且不会撤消伪图层如 &lt;code&gt;:utf8&lt;/code&gt; 的影响。可能的用法示例如下：</target>
        </trans-unit>
        <trans-unit id="ff419cc31e5dd99b3e00b537155bcea526bbe610" translate="yes" xml:space="preserve">
          <source>A pseudolayer that enables a flag in the layer below to tell Perl that output should be in utf8 and that input should be regarded as already in valid utf8 form. &lt;b&gt;WARNING: It does not check for validity and as such should be handled with extreme caution for input, because security violations can occur with non-shortest UTF-8 encodings, etc.&lt;/b&gt; Generally &lt;code&gt;:encoding(utf8)&lt;/code&gt; is the best option when reading UTF-8 encoded data.</source>
          <target state="translated">一个伪层，它使下面一层中的标记能够告诉Perl输出应该在utf8中，并且应该认为输入已经是有效的utf8形式。&lt;b&gt;警告：它不会检查有效性，因此输入时应格外谨慎，因为使用非最短的UTF-8编码等可能会发生安全违规。&lt;/b&gt;通常 &lt;code&gt;:encoding(utf8)&lt;/code&gt; 是读取UTF-时的最佳选择8个编码数据。</target>
        </trans-unit>
        <trans-unit id="c46a1417af942e441ec740293a77160106782547" translate="yes" xml:space="preserve">
          <source>A pseudolayer that manipulates other layers. Applying the &lt;code&gt;:raw&lt;/code&gt; layer is equivalent to calling &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode($fh)&lt;/a&gt;&lt;/code&gt;. It makes the stream pass each byte as-is without translation. In particular, both CRLF translation and intuiting &lt;code&gt;:utf8&lt;/code&gt; from the locale are disabled.</source>
          <target state="translated">操纵其他层的伪层。应用 &lt;code&gt;:raw&lt;/code&gt; 层等效于调用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode($fh)&lt;/a&gt;&lt;/code&gt; 。它使流按原样传递每个字节而无需转换。特别是，CRLF转换和从区域设置intuiting &lt;code&gt;:utf8&lt;/code&gt; 均被禁用。</target>
        </trans-unit>
        <trans-unit id="fefe2bbba2d7bf83c98ed3d05237098307bf7f4b" translate="yes" xml:space="preserve">
          <source>A pseudolayer that turns the &lt;code&gt;:utf8&lt;/code&gt; flag</source>
          <target state="translated">伪造的 &lt;code&gt;:utf8&lt;/code&gt; 标志</target>
        </trans-unit>
        <trans-unit id="ecc09e716a2c2d18e2be806f7183c30c2f3b51c2" translate="yes" xml:space="preserve">
          <source>A psychoactive drug, popular in the &amp;rsquo;80s, probably developed at UC Berkeley or thereabouts. Similar in many ways to the prescription-only medication called &amp;ldquo;System V&amp;rdquo;, but infinitely more useful. (Or, at least, more fun.) The full chemical name is &amp;ldquo;Berkeley Standard Distribution&amp;rdquo;.</source>
          <target state="translated">一种在80年代流行的精神活性药物，很可能是在加州大学伯克利分校或其附近开发的。在许多方面与称为&amp;ldquo;系统V&amp;rdquo;的仅处方药相似，但无限有用。（或者至少更有趣。）化学名称的全称是&amp;ldquo;伯克利标准分布&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b62f9f104139d9b8c4e453ea5b9cd7a8ac0140f4" translate="yes" xml:space="preserve">
          <source>A public function (i.e. part of the internal API, but not necessarily sanctioned for use in extensions) begins like this:</source>
          <target state="translated">一个公共函数(即内部API的一部分,但不一定允许在扩展中使用)像这样开始。</target>
        </trans-unit>
        <trans-unit id="1fcfaef1b89a51f30ffb896e8c738cde9ef6077c" translate="yes" xml:space="preserve">
          <source>A pull-parser interface to parsing Pod</source>
          <target state="translated">一个用于解析Pod的拉式解析器接口。</target>
        </trans-unit>
        <trans-unit id="ce01020c3704b898a0c0774b915a9978c7a43b90" translate="yes" xml:space="preserve">
          <source>A question mark was chosen for this and for the minimal-matching construct because 1) question marks are rare in older regular expressions, and 2) whenever you see one, you should stop and &quot;question&quot; exactly what is going on. That's psychology....</source>
          <target state="translated">之所以选择问号和最小匹配构造,是因为:1)问号在旧的正则表达式中很少见,2)每当看到问号,你就应该停下来,&quot;质疑 &quot;到底发生了什么。这就是心理学....</target>
        </trans-unit>
        <trans-unit id="7af52ef72c21fce506c2fc73241d0f35d841b4ef" translate="yes" xml:space="preserve">
          <source>A queue is a special thread-safe object that lets you put data in one end and take it out the other without having to worry about synchronization issues. They're pretty straightforward, and look like this:</source>
          <target state="translated">队列是一个特殊的线程安全对象,它可以让你把数据放在一端,然后从另一端取出,而不必担心同步问题。它们很直接,看起来像这样。</target>
        </trans-unit>
        <trans-unit id="ce5a6f66f06330588b1d9e78cc960a0c4ce6fd02" translate="yes" xml:space="preserve">
          <source>A quick and dirty fix involves a little bit of code, but this may be all you need to figure out the problem.</source>
          <target state="translated">一个快速和肮脏的修复涉及到一点代码,但这可能是你需要找出问题的全部。</target>
        </trans-unit>
        <trans-unit id="a1f4c66121a13dbcd4a35fcb46d7559bf401584e" translate="yes" xml:space="preserve">
          <source>A quick fix to the offending line (insert the missing parentheses) in the actual program and we're finished.</source>
          <target state="translated">在实际程序中快速修复违规行(插入缺失的括号),我们就完成了。</target>
        </trans-unit>
        <trans-unit id="caf25dde2a598596295bb7a94644c4b4622cf06c" translate="yes" xml:space="preserve">
          <source>A quick flag check to see whether an sv should be passed to sv_force_normal to be &quot;downgraded&quot; before SvIVX or SvPVX can be modified directly.</source>
          <target state="translated">一个快速的标志检查,以查看是否应该在直接修改 SvIVX 或 SvPVX 之前将 sv 传给 sv_force_normal 进行 &quot;降级&quot;。</target>
        </trans-unit>
        <trans-unit id="5714e693202d7afa5eda5b56d0aae30074e97131" translate="yes" xml:space="preserve">
          <source>A quick note on terms</source>
          <target state="translated">关于术语的简要说明</target>
        </trans-unit>
        <trans-unit id="1d94544d51208195a231709cf1963af0c4de7162" translate="yes" xml:space="preserve">
          <source>A race condition exists when the result of several interrelated events depends on the ordering of those events, but that order cannot be guaranteed due to nondeterministic timing effects. If two or more programs, or parts of the same program, try to go through the same series of events, one might interrupt the work of the other. This is a good way to find an &lt;b&gt;exploit&lt;/b&gt;.</source>
          <target state="translated">当几个相互关联的事件的结果取决于这些事件的顺序时，便存在竞争条件，但由于不确定的时序影响，无法保证该顺序。如果两个或多个程序或同一程序的一部分尝试经历相同的一系列事件，则一个事件可能会中断另一个事件的工作。这是发现&lt;b&gt;漏洞&lt;/b&gt;的好方法。</target>
        </trans-unit>
        <trans-unit id="b4fd04892bbded81531e522d3212286340ec1840" translate="yes" xml:space="preserve">
          <source>A read-write accessor will allow the caller to set the value as well as get it:</source>
          <target state="translated">读写访问器将允许调用者设置值以及获取值。</target>
        </trans-unit>
        <trans-unit id="caaace35cefc12e27812e75c68a502f8caf0f7cf" translate="yes" xml:space="preserve">
          <source>A recent net or commercial release of Cygwin is required.</source>
          <target state="translated">需要一个最近的Cygwin的网络或商业版本。</target>
        </trans-unit>
        <trans-unit id="279e88205b97d17edeab01fe3aebcdc1b843db2f" translate="yes" xml:space="preserve">
          <source>A recent version of perl for the Amiga can be found at the Geek Gadgets section of the Aminet:</source>
          <target state="translated">在Aminet的Geek Gadgets部分,可以找到一个最新版本的perl for the Amiga。</target>
        </trans-unit>
        <trans-unit id="091b3fb1a508c2d701cd7e6f7c6e6e5c3add3716" translate="yes" xml:space="preserve">
          <source>A recipe book for programming with CPAN.pm</source>
          <target state="translated">使用CPAN.pm进行编程的秘诀书</target>
        </trans-unit>
        <trans-unit id="2d7c582850510d1397c7e76f17b16cc5d91e6066" translate="yes" xml:space="preserve">
          <source>A recreational vehicle, not to be confused with vehicular recreation. RV also means an internal Reference Value of the type a &lt;b&gt;scalar&lt;/b&gt; can hold. See also &lt;b&gt;IV&lt;/b&gt; and &lt;b&gt;NV&lt;/b&gt; if you&amp;rsquo;re not confused yet.</source>
          <target state="translated">一种休闲车，不要与车辆休闲相混淆。RV也表示&lt;b&gt;标量&lt;/b&gt;可以容纳的内部参考值。如果尚未感到困惑，另请参阅&lt;b&gt;IV&lt;/b&gt;和&lt;b&gt;NV&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="ad0a627886d7457b4c1bf3b7879c79721531858f" translate="yes" xml:space="preserve">
          <source>A reference can be blessed into a package with the following function:</source>
          <target state="translated">可以通过以下函数将一个引用祝福到一个包中。</target>
        </trans-unit>
        <trans-unit id="b9d8f8326d44e724663f7d05cf4610dd9fa3fff9" translate="yes" xml:space="preserve">
          <source>A reference can be created by using a special syntax, lovingly known as the *foo{THING} syntax. *foo{THING} returns a reference to the THING slot in *foo (which is the symbol table entry which holds everything known as foo).</source>
          <target state="translated">可以通过使用一种特殊的语法来创建一个引用,这种语法被爱称为*foo{THING}语法。*foo{THING}返回对*foo中THING槽的引用(这是符号表的条目,其中包含了所有已知的foo)。</target>
        </trans-unit>
        <trans-unit id="aa895f94ce4272825894257bb4b5f46a12e2a648" translate="yes" xml:space="preserve">
          <source>A reference is a scalar value and can refer to any other Perl data type. So by storing a reference as the value of an array or hash element, you can easily create lists and hashes within lists and hashes. The following example shows a 2 level hash of hash structure using anonymous hash references.</source>
          <target state="translated">引用是一个标量值,可以引用任何其他Perl数据类型。因此,通过存储一个引用作为数组或哈希元素的值,你可以轻松地在列表和哈希中创建列表和哈希。下面的例子显示了一个使用匿名哈希引用的2层哈希结构。</target>
        </trans-unit>
        <trans-unit id="31756567f0b0edb207ae4b6d556e511492c04f15" translate="yes" xml:space="preserve">
          <source>A reference is a scalar value that</source>
          <target state="translated">引用是一个标量值,它</target>
        </trans-unit>
        <trans-unit id="9246f92f3034b3a452a0afe45331277281745beb" translate="yes" xml:space="preserve">
          <source>A reference that doesn&amp;rsquo;t get counted normally. When all the normal references to data disappear, the data disappears. These are useful for circular references that would never disappear otherwise.</source>
          <target state="translated">引用不正常计数。当所有对数据的普通引用都消失时，数据也消失了。这些对于循环引用很有用，否则将永远不会消失。</target>
        </trans-unit>
        <trans-unit id="5bbf68c2e549802b044298b09b378b5fd28092c9" translate="yes" xml:space="preserve">
          <source>A reference to a filehandle, or the pathname of a file from which the invoking script's pod documentation should be read. It defaults to the file indicated by &lt;code&gt;$0&lt;/code&gt; (&lt;code&gt;$PROGRAM_NAME&lt;/code&gt; for users of</source>
          <target state="translated">对文件句柄的引用，或应从中读取调用脚本的pod文档的文件的路径名。默认使用 &lt;code&gt;$0&lt;/code&gt; 指示的文件（ &lt;code&gt;$PROGRAM_NAME&lt;/code&gt; 对于以下用户</target>
        </trans-unit>
        <trans-unit id="f5b22d93dc114d0a0d964dd5bfa61e077311cb6a" translate="yes" xml:space="preserve">
          <source>A reference to a filehandle, or the pathname of a file to which the usage message should be written. The default is &lt;code&gt;\*STDERR&lt;/code&gt; unless the exit value is less than 2 (in which case the default is &lt;code&gt;\*STDOUT&lt;/code&gt; ).</source>
          <target state="translated">对文件句柄的引用，或应该向其中写入使用消息的文件的路径名。除非出口值小于2，否则默认值为 &lt;code&gt;\*STDERR&lt;/code&gt; （在这种情况下，默认值为 &lt;code&gt;\*STDOUT&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1be21fde0d5a369b6626dd71f37562d95b7a892a" translate="yes" xml:space="preserve">
          <source>A reference to a hash</source>
          <target state="translated">对哈希值的引用</target>
        </trans-unit>
        <trans-unit id="caf281724b21daca5b76b0ce26ffdceb6ed5b592" translate="yes" xml:space="preserve">
          <source>A reference to a hash of rules that control which tests may be executed in parallel. If no rules are declared and &lt;a href=&quot;../cpan/meta/yaml&quot;&gt;CPAN::Meta::YAML&lt;/a&gt; is available, &lt;code&gt;TAP::Harness&lt;/code&gt; attempts to load rules from a YAML file specified by the &lt;code&gt;rulesfile&lt;/code&gt; parameter. If no rules file exists, the default is for all tests to be eligible to be run in parallel.</source>
          <target state="translated">对控制可以并行执行哪些测试的规则的哈希的引用。如果未声明任何规则且&lt;a href=&quot;../cpan/meta/yaml&quot;&gt;CPAN :: Meta :: YAML&lt;/a&gt;可用，则 &lt;code&gt;TAP::Harness&lt;/code&gt; 尝试从 &lt;code&gt;rulesfile&lt;/code&gt; 参数指定的YAML文件中加载规则。如果不存在任何规则文件，则默认为所有测试都可以并行运行。</target>
        </trans-unit>
        <trans-unit id="cd42c7f4f6784f49153b357722a869874cd7cab5" translate="yes" xml:space="preserve">
          <source>A reference to a hash of scalar values in scalar context. Each entry of the hash has the fully qualified method name as its key and the method's scalar-context return values as its value.</source>
          <target state="translated">一个对标量上下文中标量值的哈希的引用。该哈希的每个条目都以完全限定的方法名称作为其键,并以该方法的标量上下文返回值作为其值。</target>
        </trans-unit>
        <trans-unit id="c3a87c12004d018bcf7a69155be997af1914286c" translate="yes" xml:space="preserve">
          <source>A reference to a hash.</source>
          <target state="translated">对哈希的引用。</target>
        </trans-unit>
        <trans-unit id="9c7f4017cfb229c284c5327072ab9da27410d7df" translate="yes" xml:space="preserve">
          <source>A reference to a list of netmask strings in the form &lt;code&gt;&quot;134.99.4.0/24&quot;&lt;/code&gt; . These are used by the &lt;code&gt;requires_firewall&lt;/code&gt; function to determine if a given host is inside or outside your firewall.</source>
          <target state="translated">对形式为 &lt;code&gt;&quot;134.99.4.0/24&quot;&lt;/code&gt; 的网络掩码字符串列表的引用。这些由 &lt;code&gt;requires_firewall&lt;/code&gt; 函数用于确定给定主机是在防火墙内部还是外部。</target>
        </trans-unit>
        <trans-unit id="30ea49a873c1ff374f329e97efef0ff346dccc25" translate="yes" xml:space="preserve">
          <source>A reference to a list of subroutine references and/or qr// objects and/or literal strings and/or hash references, specifying the extractors to be used to split the string. If this argument is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) the list:</source>
          <target state="translated">对子例程引用和/或qr //对象和/或文字字符串和/或散列引用的列表的引用，指定要用于拆分字符串的提取器。如果省略此参数（或 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），则列表：</target>
        </trans-unit>
        <trans-unit id="c0f47fcb868f1bdb2ed44c13b2967f53238fb92e" translate="yes" xml:space="preserve">
          <source>A reference to a list of tests which are allowed to fail. See &lt;a href=&quot;#TODO-TESTS&quot;&gt;TODO TESTS&lt;/a&gt;.</source>
          <target state="translated">对允许失败的测试列表的引用。请参阅&lt;a href=&quot;#TODO-TESTS&quot;&gt;待办事项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a16beaf14f9ebf81709ac7687142e7324bffbcbc" translate="yes" xml:space="preserve">
          <source>A reference to a scalar, containing any initial source code to prepend to the file or generator output.</source>
          <target state="translated">一个对标量的引用,包含任何初始的源代码,以预置到文件或生成器输出。</target>
        </trans-unit>
        <trans-unit id="ca57032a4acbb0f04dd265f2403ba03843451cb5" translate="yes" xml:space="preserve">
          <source>A reference to a simple scalar</source>
          <target state="translated">参考一个简单的标量</target>
        </trans-unit>
        <trans-unit id="2f7717bc46f8882825267f8fb5ae31ad534d8604" translate="yes" xml:space="preserve">
          <source>A reference to a subroutine</source>
          <target state="translated">对子程序的引用</target>
        </trans-unit>
        <trans-unit id="b60540604d1e514c1059c3b516595d77c9c95f5f" translate="yes" xml:space="preserve">
          <source>A reference to a subroutine. If there is no filehandle (previous item), then this subroutine is expected to generate one line of source code per call, writing the line into &lt;code&gt;$_&lt;/code&gt; and returning 1, then finally at end of file returning 0. If there is a filehandle, then the subroutine will be called to act as a simple source filter, with the line as read in &lt;code&gt;$_&lt;/code&gt; . Again, return 1 for each valid line, and 0 after all lines have been returned.</source>
          <target state="translated">对子例程的引用。如果没有文件句柄（上一个项目），则该子例程将为每次调用生成一行源代码，将该行写入 &lt;code&gt;$_&lt;/code&gt; 并返回1，最后在文件末尾返回0。如果存在文件句柄，然后将调用该子例程以充当简单的源过滤器，其行如 &lt;code&gt;$_&lt;/code&gt; 。再次，为每条有效行返回1，在所有行返回后返回0。</target>
        </trans-unit>
        <trans-unit id="69d2c7af1b1feb58183b6cd3ab9665d62ba3318e" translate="yes" xml:space="preserve">
          <source>A reference to an &lt;code&gt;@INC&lt;/code&gt; style array of arguments to be passed to each test program.</source>
          <target state="translated">对要传递给每个测试程序的 &lt;code&gt;@INC&lt;/code&gt; 样式参数数组的引用。</target>
        </trans-unit>
        <trans-unit id="c036eaf04cdd3c79b7e1454ebb2a945c2a1cd7fe" translate="yes" xml:space="preserve">
          <source>A reference to an SV which holds a C pointer</source>
          <target state="translated">对持有C指针的SV的引用。</target>
        </trans-unit>
        <trans-unit id="23549f2151bb51628d2f58bbcf1156a64c3296ce" translate="yes" xml:space="preserve">
          <source>A reference to an anonymous array can be created using square brackets:</source>
          <target state="translated">可以使用方括号创建对匿名数组的引用。</target>
        </trans-unit>
        <trans-unit id="227fa37704dcf65c895f6b48accf114132dd71b4" translate="yes" xml:space="preserve">
          <source>A reference to an anonymous hash can be created using curly brackets:</source>
          <target state="translated">可以使用大括号创建对匿名哈希的引用。</target>
        </trans-unit>
        <trans-unit id="75f71bb1e5a64ddcdb9e050cbea388199a1108b3" translate="yes" xml:space="preserve">
          <source>A reference to an anonymous subroutine can be created by using &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; without a subname:</source>
          <target state="translated">可以使用不带子名称的 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 来创建对匿名子例程的引用：</target>
        </trans-unit>
        <trans-unit id="8b1d9fe90cb9aed401ad78a9cb46511d34021ee8" translate="yes" xml:space="preserve">
          <source>A reference to an array</source>
          <target state="translated">对数组的引用</target>
        </trans-unit>
        <trans-unit id="e31779df8d209b3542cc04e2be4c9b32f5d08f2c" translate="yes" xml:space="preserve">
          <source>A reference to an array of sections specifications (as described in &lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS&lt;/a&gt;) which indicate the desired set of POD sections and subsections to be selected from input. If no section specifications are given, then all sections of the PODs are used.</source>
          <target state="translated">对部分规范的数组的引用（如&lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS中所述&lt;/a&gt;），指示要从输入中选择的POD部分和子部分的所需集合。如果未提供任何部分规范，则将使用POD的所有部分。</target>
        </trans-unit>
        <trans-unit id="c89226f4c3258d3bce7e696eba292fd5daa132bc" translate="yes" xml:space="preserve">
          <source>A reference to the object for a virtual method or the name of the class for a static method</source>
          <target state="translated">对虚拟方法的对象的引用,或者对静态方法的类名的引用。</target>
        </trans-unit>
        <trans-unit id="21f30d908543711c9f728d7de0ea1261250a9055" translate="yes" xml:space="preserve">
          <source>A regression in AIX 7 causes a failure in make test in Time::Piece during daylight savings time. APAR IV16514 provides the fix for this. A quick test to see if it's required, assuming it is currently daylight savings in Eastern Time, would be to run &lt;code&gt; TZ=EST5 date +%Z &lt;/code&gt; . This will come back with &lt;code&gt;EST&lt;/code&gt; normally, but nothing if you have the problem.</source>
          <target state="translated">在夏时制期间，AIX 7中的回归会导致Time :: Piece中的make测试失败。APAR IV16514为此提供了修复程序。假设当前是美国东部时间的夏令时，进行一次快速测试（如果需要），将运行 &lt;code&gt; TZ=EST5 date +%Z &lt;/code&gt; 。正常情况下，这将与 &lt;code&gt;EST&lt;/code&gt; 一起返回，但如果有问题，则什么也不会。</target>
        </trans-unit>
        <trans-unit id="0fc4dbf2e586369f7ce889ec848c85dffcc1c599" translate="yes" xml:space="preserve">
          <source>A regular expression engine is a program that takes a set of constraints specified in a mini-language, and then applies those constraints to a target string, and determines whether or not the string satisfies the constraints. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; for a full definition of the language.</source>
          <target state="translated">正则表达式引擎是一个程序，该程序采用一组以迷你语言指定的约束，然后将这些约束应用于目标字符串，并确定字符串是否满足约束。有关&lt;a href=&quot;perlre&quot;&gt;语言&lt;/a&gt;的完整定义，请参见perlre。</target>
        </trans-unit>
        <trans-unit id="898d96d1a86448c10c01fff6d7c680ca19e7f093" translate="yes" xml:space="preserve">
          <source>A regular expression match in the form of &lt;code&gt;/REGEX/&lt;/code&gt; , &lt;code&gt;$foo =~ /REGEX/&lt;/code&gt; , or &lt;code&gt;$foo =~ EXPR&lt;/code&gt; . Also, a negated regular expression match in the form &lt;code&gt;!/REGEX/&lt;/code&gt; , &lt;code&gt;$foo !~ /REGEX/&lt;/code&gt; , or &lt;code&gt;$foo !~ EXPR&lt;/code&gt; .</source>
          <target state="translated">以 &lt;code&gt;/REGEX/&lt;/code&gt; ， &lt;code&gt;$foo =~ /REGEX/&lt;/code&gt; 或 &lt;code&gt;$foo =~ EXPR&lt;/code&gt; 〜EXPR形式的正则表达式匹配。而且，否定的正则表达式匹配形式为 &lt;code&gt;!/REGEX/&lt;/code&gt; ， &lt;code&gt;$foo !~ /REGEX/&lt;/code&gt; 或 &lt;code&gt;$foo !~ EXPR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b61a0c27a77da1e69f8478b8fd9175ff4c338f9" translate="yes" xml:space="preserve">
          <source>A regular expression that otherwise would compile using &lt;code&gt;/d&lt;/code&gt; rules, and which uses this construct will instead use &lt;code&gt;/u&lt;/code&gt; . Thus this construct tells Perl that you don't want &lt;code&gt;/d&lt;/code&gt; rules for the entire regular expression containing it.</source>
          <target state="translated">否则将使用 &lt;code&gt;/d&lt;/code&gt; 规则进行编译并使用此构造的正则表达式将改用 &lt;code&gt;/u&lt;/code&gt; 。因此，此结构告诉Perl您不希望 &lt;code&gt;/d&lt;/code&gt; 规则包含整个正则表达式。</target>
        </trans-unit>
        <trans-unit id="8052f2558ed14ca1695f0756ea843781532061f7" translate="yes" xml:space="preserve">
          <source>A related issue is thread-safety. When a new thread is created, the Perl interpreter is cloned, which implies that all reference addresses in use will be replaced with new ones. Thus, if a class tries to access a field of a cloned object its (cloned) data will still be stored under the now invalid reference address of the original in the parent thread. A general &lt;code&gt;CLONE&lt;/code&gt; method must be provided to re-establish the association.</source>
          <target state="translated">一个相关的问题是线程安全。创建新线程时，将克隆Perl解释器，这意味着所有使用中的引用地址都将被新的引用地址替换。因此，如果类试图访问克隆对象的字段，则其（克隆）数据仍将存储在父线程中原始对象的现在无效的引用地址下。必须提供通用的 &lt;code&gt;CLONE&lt;/code&gt; 方法来重新建立关联。</target>
        </trans-unit>
        <trans-unit id="c5a4d830992a6346407400c2bf4e88b4a6e3e575" translate="yes" xml:space="preserve">
          <source>A related issue is use with perl's malloc. Perl's malloc uses &lt;code&gt;sbrk()&lt;/code&gt; to get memory, and &lt;code&gt;sbrk()&lt;/code&gt; is limited to the first allocation so in this case something like:</source>
          <target state="translated">一个相关的问题是与perl的malloc一起使用。Perl的malloc使用 &lt;code&gt;sbrk()&lt;/code&gt; 来获取内存，而 &lt;code&gt;sbrk()&lt;/code&gt; 限于第一次分配，因此在这种情况下，类似于：</target>
        </trans-unit>
        <trans-unit id="773c247356b687b3912aff9a0cf7c1a25f2fade5" translate="yes" xml:space="preserve">
          <source>A related strategy that's less open to forgery is to give them a PIN (personal ID number). Record the address and PIN (best that it be a random one) for later processing. In the mail you send, include a link to your site with the PIN included. If the mail bounces, you know it's not valid. If they don't click on the link, either they forged the address or (assuming they got the message) following through wasn't important so you don't need to worry about it.</source>
          <target state="translated">一个相关的不易伪造的策略是给他们一个PIN码(个人身份号码)。记录地址和PIN码(最好是随机的),以便以后处理。在你发送的邮件中,包括一个指向你网站的链接,并附上PIN码。如果邮件跳转,你就知道它无效。如果他们没有点击链接,要么是他们伪造了地址,要么是(假设他们收到了信息)跟进并不重要,所以你不需要担心这个问题。</target>
        </trans-unit>
        <trans-unit id="1b0e6d749250f42dda0dbf4bdf376cdb3adb5626" translate="yes" xml:space="preserve">
          <source>A relationship between two &lt;b&gt;objects&lt;/b&gt; in which one object is considered to be a more specific version of the other, generic object: &amp;ldquo;A camel is a mammal.&amp;rdquo; Since the generic object really only exists in a Platonic sense, we usually add a little abstraction to the notion of objects and think of the relationship as being between a generic &lt;b&gt;base class&lt;/b&gt; and a specific &lt;b&gt;derived class&lt;/b&gt;. Oddly enough, Platonic classes don&amp;rsquo;t always have Platonic relationships&amp;mdash;see &lt;b&gt;inheritance&lt;/b&gt;.</source>
          <target state="translated">两个&lt;b&gt;对象&lt;/b&gt;之间的关系，其中一个对象被视为另一个通用对象的更特定版本：&amp;ldquo;骆驼是哺乳动物。&amp;rdquo;由于泛型对象实际上仅在柏拉图意义上存在，因此我们通常在对象的概念上添加一些抽象，并将关系视为泛型&lt;b&gt;基类&lt;/b&gt;与特定&lt;b&gt;派生类&lt;/b&gt;之间的关系。奇怪的是，柏拉图类并不总是具有柏拉图关系-请参见&lt;b&gt;继承&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="9cc57b74bcbf78eacbd6b02d09950f83d1e82c98" translate="yes" xml:space="preserve">
          <source>A relatively new conference franchise with a large Perl portion is the Open Source Developers Conference or OSDC. First held in Australia it has recently also spread to Israel and France. More information can be found at: &lt;a href=&quot;http://www.osdc.com.au/&quot;&gt;http://www.osdc.com.au/&lt;/a&gt; for Australia, &lt;a href=&quot;http://www.osdc.org.il&quot;&gt;http://www.osdc.org.il&lt;/a&gt; for Israel, and &lt;a href=&quot;http://www.osdc.fr/&quot;&gt;http://www.osdc.fr/&lt;/a&gt; for France.</source>
          <target state="translated">Open Source Developers Conference或OSDC是一个相对较新的，具有很大Perl份额的会议专营权。首次在澳大利亚举行，最近也传播到以色列和法国。更多信息可以在这里找到：&lt;a href=&quot;http://www.osdc.com.au/&quot;&gt;http://www.osdc.com.au/&lt;/a&gt;澳大利亚，&lt;a href=&quot;http://www.osdc.org.il&quot;&gt;http://www.osdc.org.il&lt;/a&gt;以色列和&lt;a href=&quot;http://www.osdc.fr/&quot;&gt;http://www.osdc.fr/&lt;/a&gt;法国。</target>
        </trans-unit>
        <trans-unit id="125bb83bd0e2557d465d8cae2a201d255865cfc8" translate="yes" xml:space="preserve">
          <source>A relatively recent addition to socket functions, may not be implemented even in Unix platforms.</source>
          <target state="translated">一个相对较新的套接字函数,即使在Unix平台上也可能无法实现。</target>
        </trans-unit>
        <trans-unit id="0fb2c7925dc01622384910beb32c259581a32e6c" translate="yes" xml:space="preserve">
          <source>A remark that doesn&amp;rsquo;t affect the meaning of the program. In Perl, a comment is introduced by a &lt;code&gt;#&lt;/code&gt; character and continues to the end of the line.</source>
          <target state="translated">备注不影响程序的含义。在Perl中，注释由 &lt;code&gt;#&lt;/code&gt; 字符引起，并一直持续到行尾。</target>
        </trans-unit>
        <trans-unit id="05ceaec7b64c7ce9cdeec60b39e51b96ddb09fbd" translate="yes" xml:space="preserve">
          <source>A repeat count after &lt;code&gt;u&lt;/code&gt; sets the number of bytes to put into an uuencoded line, which is the maximum of 45 by default, but could be set to some (smaller) integer multiple of three. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; simply ignores the repeat count.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 设置了要放入uuencoded行中的字节数后的重复计数，默认情况下最大为45，但可以将其设置为3的某个（较小的）整数倍。 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 只会忽略重复计数。</target>
        </trans-unit>
        <trans-unit id="3a53eb20270176512fa5bd8bf4b4f1be0776d385" translate="yes" xml:space="preserve">
          <source>A return code of 1 means that the requested key was not in the database.</source>
          <target state="translated">返回码为1表示请求的键不在数据库中。</target>
        </trans-unit>
        <trans-unit id="ed4d8a6dc7b98d70bce7c0cb5069c17fe03ce939" translate="yes" xml:space="preserve">
          <source>A rudimentary command-line completion is also available, including lexical variables in the current scope if the &lt;code&gt;PadWalker&lt;/code&gt; module is installed.</source>
          <target state="translated">如果安装了 &lt;code&gt;PadWalker&lt;/code&gt; 模块，还可以使用基本的命令行完成功能，包括当前作用域中的词法变量。</target>
        </trans-unit>
        <trans-unit id="195465d41845715cc8feeb944d84d82eca7db90c" translate="yes" xml:space="preserve">
          <source>A safe filename for the package.</source>
          <target state="translated">包的安全文件名。</target>
        </trans-unit>
        <trans-unit id="e965283a692e93e5f3c352fa50ba572d5ad94533" translate="yes" xml:space="preserve">
          <source>A sample Configure invocation looks something like this:</source>
          <target state="translated">配置调用的示例看起来像这样。</target>
        </trans-unit>
        <trans-unit id="c38c9f9afa364c973ff5615c1cc8f4fc08593cdb" translate="yes" xml:space="preserve">
          <source>A sanitized VERSION with . replaced by _. For places where . has special meaning (some filesystems, RCS labels, etc...)</source>
          <target state="translated">一个用_代替.的消毒后的VERSION。对于那些有特殊含义的地方(一些文件系统,RCS标签,等等...)。</target>
        </trans-unit>
        <trans-unit id="854d2d0c342e6a9cd9c52af8350f79c5b69ee115" translate="yes" xml:space="preserve">
          <source>A sanity check is done to ensure that the versions of the</source>
          <target state="translated">进行安全检查,以确保各版本的</target>
        </trans-unit>
        <trans-unit id="52b0650d241bfe8b8773b0c925166a2b232578a5" translate="yes" xml:space="preserve">
          <source>A sanity check that what Perl thinks the architecture is and what Config thinks the architecture is are the same. If they're not it will return false and show a diagnostic message.</source>
          <target state="translated">检验Perl认为的架构和Config认为的架构是否相同。如果它们不一样,它将返回 false 并显示诊断信息。</target>
        </trans-unit>
        <trans-unit id="13eb257f5c15cd87da91e7109e5621a0b92dd55a" translate="yes" xml:space="preserve">
          <source>A scalar represents a single value:</source>
          <target state="translated">一个标量代表一个单值。</target>
        </trans-unit>
        <trans-unit id="63bf2744d770c46d6894e17a03796eb6868d8317" translate="yes" xml:space="preserve">
          <source>A scalar that is going to be passed to some extension</source>
          <target state="translated">一个将被传递给某个扩展的标量。</target>
        </trans-unit>
        <trans-unit id="b892a705ca325c138b52905f099e8858ffbdfac0" translate="yes" xml:space="preserve">
          <source>A scalar value is interpreted as FALSE in the Boolean sense if it is undefined, the null string or the number 0 (or its string equivalent, &quot;0&quot;), and TRUE if it is anything else. The Boolean context is just a special kind of scalar context where no conversion to a string or a number is ever performed.</source>
          <target state="translated">一个标量值如果是未定义、空字符串或数字0(或其字符串等价物 &quot;0&quot;),在布尔语境中被解释为FALSE,如果是其他任何东西,则解释为TRUE。布尔语境只是一种特殊的标量语境,在这种语境中,从来没有进行过向字符串或数字的转换。</target>
        </trans-unit>
        <trans-unit id="ecf273fc6dfd9742bd76d45138d207f0b0c7c11c" translate="yes" xml:space="preserve">
          <source>A scalar we got back from an extension</source>
          <target state="translated">我们从扩展中得到的一个标量</target>
        </trans-unit>
        <trans-unit id="7153eab5e3c20636ca530d5dc26c52e39ac43559" translate="yes" xml:space="preserve">
          <source>A scratchpad keeps SVs which are lexicals for the current unit and are targets for opcodes. A previous version of this document stated that one can deduce that an SV lives on a scratchpad by looking on its flags: lexicals have &lt;code&gt;SVs_PADMY&lt;/code&gt; set, and</source>
          <target state="translated">暂存器保留SV，这些SV是当前单元的词汇，并且是操作码的目标。该文档的先前版本指出，可以通过查看其标志来推断SV &lt;code&gt;SVs_PADMY&lt;/code&gt; 在暂存器上：词汇已设置SVs_PADMY，并且</target>
        </trans-unit>
        <trans-unit id="9b4b51a187f878ac1e93c009ee393256c5f3fed7" translate="yes" xml:space="preserve">
          <source>A script called &quot;runperl.bat&quot; is available that can be copied to any filename (along with the .bat suffix). For example, if you call it &quot;foo.bat&quot;, it will run the file &quot;foo&quot; when it is executed. Since you can run batch files on Windows platforms simply by typing the name (without the extension), this effectively runs the file &quot;foo&quot;, when you type either &quot;foo&quot; or &quot;foo.bat&quot;. With this method, &quot;foo.bat&quot; can even be in a different location than the file &quot;foo&quot;, as long as &quot;foo&quot; is available somewhere on the PATH. If your scripts are on a filesystem that allows symbolic links, you can even avoid copying &quot;runperl.bat&quot;.</source>
          <target state="translated">有一个名为 &quot;runperl.bat &quot;的脚本,可以复制到任何文件名中(连同.bat后缀)。例如,如果你把它称为 &quot;foo.bat&quot;,它将在执行时运行文件 &quot;foo&quot;。由于在Windows平台上只需键入名称(不含扩展名)就可以运行批处理文件,所以当你键入 &quot;foo &quot;或 &quot;foo.bat &quot;时,这就有效地运行了 &quot;foo &quot;文件。使用这种方法,&quot;foo.bat &quot;甚至可以在与 &quot;foo &quot;不同的位置,只要 &quot;foo &quot;在PATH的某个地方可用。如果你的脚本是在一个允许符号链接的文件系统上,你甚至可以避免复制 &quot;runperl.bat&quot;。</target>
        </trans-unit>
        <trans-unit id="6e410531e148f9094643156d14e90843980c3dfe" translate="yes" xml:space="preserve">
          <source>A script that emulates the standard unix archive (aka library) utility. Under Watcom 10.6, ar is linked to wlib and provides the expected interface. With Watcom 9.5, a cover function is required. This one is fairly crude but has proved adequate for compiling perl.</source>
          <target state="translated">一个模拟标准 unix 存档(又称库)工具的脚本。在Watcom 10.6下,ar与wlib相连,并提供预期的接口。在Watcom 9.5下,需要一个封面函数。这个函数相当粗糙,但已被证明足以编译perl。</target>
        </trans-unit>
        <trans-unit id="e8eda0c28ba2fe483ef84daa3f54b909c119dec0" translate="yes" xml:space="preserve">
          <source>A script that provides C preprocessing functionality. Configure can generate a similar cover, but it doesn't handle all the command-line options that perl throws at it. This might be reasonably placed in /usr/local/bin.</source>
          <target state="translated">一个提供C语言预处理功能的脚本。Configure可以生成一个类似的封面,但它并没有处理perl抛出的所有命令行选项。可以把它放在/usr/local/bin中。</target>
        </trans-unit>
        <trans-unit id="f63efe767441f9b6cae7b2dee9e50e81364ad873" translate="yes" xml:space="preserve">
          <source>A searchable archive of the list is available at &lt;a href=&quot;http://markmail.org/search/?q=perl5-porters&quot;&gt;http://markmail.org/search/?q=perl5-porters&lt;/a&gt;. There is also an archive at &lt;a href=&quot;http://archive.develooper.com/perl5-porters@perl.org/&quot;&gt;http://archive.develooper.com/perl5-porters@perl.org/&lt;/a&gt;.</source>
          <target state="translated">可从&lt;a href=&quot;http://markmail.org/search/?q=perl5-porters&quot;&gt;http://markmail.org/search/?q=perl5-porters&lt;/a&gt;获得该列表的可搜索存档。在&lt;a href=&quot;http://archive.develooper.com/perl5-porters@perl.org/&quot;&gt;http://archive.develooper.com/perl5-porters@perl.org/上&lt;/a&gt;也有一个档案。</target>
        </trans-unit>
        <trans-unit id="1598e0f0cd8f36f911067e3fef88a3cdc16b3aed" translate="yes" xml:space="preserve">
          <source>A section is started by the named heading or item. For example, &lt;code&gt;L&amp;lt;perlvar/$.&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;perlvar/&quot;$.&quot;&amp;gt;&lt;/code&gt; both link to the section started by &quot;&lt;code&gt;=item $.&lt;/code&gt; &quot; in perlvar. And &lt;code&gt;L&amp;lt;perlsyn/For Loops&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt; both link to the section started by &quot;&lt;code&gt;=head2 For Loops&lt;/code&gt; &quot; in perlsyn.</source>
          <target state="translated">一个节由命名的标题或项目开始。例如， &lt;code&gt;L&amp;lt;perlvar/$.&amp;gt;&lt;/code&gt; 或 &lt;code&gt;L&amp;lt;perlvar/&quot;$.&quot;&amp;gt;&lt;/code&gt; 都链接到perlvar中以&amp;ldquo; &lt;code&gt;=item $.&lt;/code&gt; &amp;rdquo; 开头的部分。和 &lt;code&gt;L&amp;lt;perlsyn/For Loops&amp;gt;&lt;/code&gt; 或 &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt; 两个链路被启动&amp;ldquo;的一节 &lt;code&gt;=head2 For Loops&lt;/code&gt; 中perlsyn&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2bd968f32a9ca757550679bcb38ba91ae56c38c6" translate="yes" xml:space="preserve">
          <source>A selection of any number of &lt;b&gt;elements&lt;/b&gt; from a &lt;b&gt;list&lt;/b&gt;, &lt;b&gt;array&lt;/b&gt;, or &lt;b&gt;hash&lt;/b&gt;.</source>
          <target state="translated">从&lt;b&gt;列表&lt;/b&gt;，&lt;b&gt;数组&lt;/b&gt;或&lt;b&gt;哈希中&lt;/b&gt;选择任意数量的&lt;b&gt;元素&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c8bb7e9a293c6c000ed25150f0f4d86b8b09ae48" translate="yes" xml:space="preserve">
          <source>A selection of general-utility hash subroutines</source>
          <target state="translated">通用哈希子程序的选择。</target>
        </trans-unit>
        <trans-unit id="7f015133979033409d91eedccc2323e573bc6368" translate="yes" xml:space="preserve">
          <source>A selection of general-utility list subroutines</source>
          <target state="translated">一般实用性列表子程序的选择。</target>
        </trans-unit>
        <trans-unit id="28d3d211918b04ba8766082d56a39fef4fdf3700" translate="yes" xml:space="preserve">
          <source>A selection of general-utility scalar subroutines</source>
          <target state="translated">通用标量子程序的选择。</target>
        </trans-unit>
        <trans-unit id="6c2a22b80753e149c4a3e936da6e37252cc4db3f" translate="yes" xml:space="preserve">
          <source>A selection of utility subroutines for subs and CODE references</source>
          <target state="translated">用于子程序和CODE参考的实用子程序的选择。</target>
        </trans-unit>
        <trans-unit id="047fc7c9d2dc1ac28d49429eb7bc7a3322abc4af" translate="yes" xml:space="preserve">
          <source>A semicolon (&lt;code&gt;;&lt;/code&gt; ) separates mandatory arguments from optional arguments. It is redundant before &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; , which gobble up everything else.</source>
          <target state="translated">分号（ &lt;code&gt;;&lt;/code&gt; ）将强制参数与可选参数分开。 &lt;code&gt;@&lt;/code&gt; 或 &lt;code&gt;%&lt;/code&gt; 之前是多余的，它将吞噬其他所有内容。</target>
        </trans-unit>
        <trans-unit id="f511bb1ccbd67c6c6ca9d2e6f48560176d03c2b5" translate="yes" xml:space="preserve">
          <source>A sequence of &lt;b&gt;bits&lt;/b&gt; that is actually being thought of as a sequence of bits, for once.</source>
          <target state="translated">的序列&lt;b&gt;位&lt;/b&gt;，实际上是被认为是比特序列，对一次。</target>
        </trans-unit>
        <trans-unit id="cae9f6dde987a755ec3121175496d8328940bd06" translate="yes" xml:space="preserve">
          <source>A sequence of characters such as &amp;ldquo;He said !@#*&amp;amp;%@#*?!&amp;rdquo;. A string does not have to be entirely printable.</source>
          <target state="translated">一系列字符，例如&amp;ldquo;他说！@＃*＆％@＃* ?!&amp;rdquo;。字符串不必完全可打印。</target>
        </trans-unit>
        <trans-unit id="fec7ee11f629dd8914f5fb3939fa45a8d0ac8f26" translate="yes" xml:space="preserve">
          <source>A sequence, such as &lt;code&gt;=head1&lt;/code&gt; , that denotes the start of a &lt;b&gt;pod&lt;/b&gt; section.</source>
          <target state="translated">一个序列，例如 &lt;code&gt;=head1&lt;/code&gt; ，它指示&lt;b&gt;吊舱&lt;/b&gt;节的开始。</target>
        </trans-unit>
        <trans-unit id="615050343b7872b60001479c7e1e5357ce76b3e7" translate="yes" xml:space="preserve">
          <source>A series of &lt;b&gt;processes&lt;/b&gt; all in a row, linked by &lt;b&gt;pipes&lt;/b&gt;, where each passes its output stream to the next.</source>
          <target state="translated">一连串由&lt;b&gt;管道&lt;/b&gt;连接的一系列&lt;b&gt;过程&lt;/b&gt;，每个过程将其输出流传递到下一个。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5e7b6708245b79eaeed5d38bcac016afddbd6e09" translate="yes" xml:space="preserve">
          <source>A series of characters matches that series of characters in the target string, so the pattern &lt;code&gt;blurfl&lt;/code&gt; would match &quot;blurfl&quot; in the target string.</source>
          <target state="translated">一系列字符与目标字符串中的那一系列字符匹配，因此模式 &lt;code&gt;blurfl&lt;/code&gt; 将与目标字符串中的&amp;ldquo; blurfl&amp;rdquo;匹配。</target>
        </trans-unit>
        <trans-unit id="cb6d59d3792163250639b9090bf480c17ab2f55e" translate="yes" xml:space="preserve">
          <source>A set of &lt;b&gt;directories&lt;/b&gt; and &lt;b&gt;files&lt;/b&gt; residing on a partition of the disk. Sometimes known as a &amp;ldquo;partition&amp;rdquo;. You can change the file&amp;rsquo;s name or even move a file around from directory to directory within a filesystem without actually moving the file itself, at least under Unix.</source>
          <target state="translated">磁盘分区上的一组&lt;b&gt;目录&lt;/b&gt;和&lt;b&gt;文件&lt;/b&gt;。有时称为&amp;ldquo;分区&amp;rdquo;。您可以更改文件名，甚至可以在文件系统内的目录之间移动文件，而不必实际移动文件本身（至少在Unix下）。</target>
        </trans-unit>
        <trans-unit id="a5ce6ae6f62d942a0f2702d5475445785e80396f" translate="yes" xml:space="preserve">
          <source>A set of criteria used to validate a particular piece of data if it has to adhere to particular rules.</source>
          <target state="translated">用于验证某项数据是否必须遵守特定规则的一套标准。</target>
        </trans-unit>
        <trans-unit id="abcc0ff1d11111cc38f19c5047e331b6ce4f3ede" translate="yes" xml:space="preserve">
          <source>A set of distribution prerequisites by phase and type</source>
          <target state="translated">按阶段和类型分列的一套分配先决条件;</target>
        </trans-unit>
        <trans-unit id="2054435ebeb82c104e8cc6baf030893f06d8bca6" translate="yes" xml:space="preserve">
          <source>A set of macros makes accessing the fields easier and more consistent. These include &lt;code&gt;OP()&lt;/code&gt; , which is used to determine the type of a &lt;code&gt;regnode&lt;/code&gt; -like structure; &lt;code&gt;NEXT_OFF()&lt;/code&gt; , which is the offset to the next node (more on this later); &lt;code&gt;ARG()&lt;/code&gt; , &lt;code&gt;ARG1()&lt;/code&gt; , &lt;code&gt;ARG2()&lt;/code&gt; , &lt;code&gt;ARG_SET()&lt;/code&gt; , and equivalents for reading and setting the arguments; and &lt;code&gt;STR_LEN()&lt;/code&gt; , &lt;code&gt;STRING()&lt;/code&gt; and &lt;code&gt;OPERAND()&lt;/code&gt; for manipulating strings and regop bearing types.</source>
          <target state="translated">一组宏使访问字段更容易且更一致。其中包括 &lt;code&gt;OP()&lt;/code&gt; ，用于确定 &lt;code&gt;regnode&lt;/code&gt; 的结构的类型； &lt;code&gt;NEXT_OFF()&lt;/code&gt; ，它是到下一个节点的偏移量（稍后会详细介绍）； &lt;code&gt;ARG()&lt;/code&gt; ， &lt;code&gt;ARG1()&lt;/code&gt; ， &lt;code&gt;ARG2()&lt;/code&gt; ， &lt;code&gt;ARG_SET()&lt;/code&gt; 以及用于读取和设置参数的等效项；和 &lt;code&gt;STR_LEN()&lt;/code&gt; ， &lt;code&gt;STRING()&lt;/code&gt; 和 &lt;code&gt;OPERAND()&lt;/code&gt; 来操纵字符串和重载轴承类型。</target>
        </trans-unit>
        <trans-unit id="5b89ed012267a41a30013b79a6117c49ce7fdacf" translate="yes" xml:space="preserve">
          <source>A set of possible values, together with all the operations that know how to deal with those values. For example, a numeric data type has a certain set of numbers that you can work with, as well as various mathematical operations that you can do on the numbers, but would make little sense on, say, a string such as &lt;code&gt;&quot;Kilroy&quot;&lt;/code&gt; . Strings have their own operations, such as &lt;b&gt;concatenation&lt;/b&gt;. Compound types made of a number of smaller pieces generally have operations to compose and decompose them, and perhaps to rearrange them. &lt;b&gt;Objects&lt;/b&gt; that model things in the real world often have operations that correspond to real activities. For instance, if you model an elevator, your elevator object might have an &lt;code&gt;open_door&lt;/code&gt;&lt;b&gt;method&lt;/b&gt;.</source>
          <target state="translated">一组可能的值，以及所有知道如何处理这些值的操作。例如，数字数据类型具有可以使用的一组特定数字，以及可以对数字进行的各种数学运算，但是对于诸如 &lt;code&gt;&quot;Kilroy&quot;&lt;/code&gt; 类的字符串却毫无意义。字符串具有自己的操作，例如&lt;b&gt;concatenation&lt;/b&gt;。由许多较小的片段组成的复合类型通常具有组成和分解它们，甚至可能重新排列它们的操作。在现实世界中对事物建模的&lt;b&gt;对象&lt;/b&gt;通常具有与真实活动相对应的操作。例如，如果您对电梯建模，则您的电梯对象可能具有 &lt;code&gt;open_door&lt;/code&gt; &lt;b&gt;方法&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="af57cf3203f1cd3e2de0a1965dff9d274c21ca2b" translate="yes" xml:space="preserve">
          <source>A set of related data values in a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;stream&lt;/b&gt;, often associated with a unique &lt;b&gt;key&lt;/b&gt; field. In Unix, often commensurate with a &lt;b&gt;line&lt;/b&gt;, or a blank-line&amp;ndash;terminated set of lines (a &amp;ldquo;paragraph&amp;rdquo;). Each line of the</source>
          <target state="translated">&lt;b&gt;文件&lt;/b&gt;或&lt;b&gt;流&lt;/b&gt;中的一组相关数据值，通常与唯一&lt;b&gt;键&lt;/b&gt;字段关联。在Unix中，通常与&lt;b&gt;一行&lt;/b&gt;或一组以空行终止的行（&amp;ldquo;段落&amp;rdquo;）相对应。每行</target>
        </trans-unit>
        <trans-unit id="1e3ce769bdcb624305623c0e39fad86b6550d415" translate="yes" xml:space="preserve">
          <source>A set of users of which you are a member. In some operating systems (like Unix), you can give certain file access permissions to other members of your group.</source>
          <target state="translated">你是其中一员的一组用户。在某些操作系统中(如Unix),你可以给你的组的其他成员一定的文件访问权限。</target>
        </trans-unit>
        <trans-unit id="a3f080c404572d6a66e864a2fec8d37666d88fa5" translate="yes" xml:space="preserve">
          <source>A set of version requirements for a CPAN dist</source>
          <target state="translated">一套CPAN dist的版本要求。</target>
        </trans-unit>
        <trans-unit id="a023ae4922155fc45ad5e15036082f2112e5376d" translate="yes" xml:space="preserve">
          <source>A seven-bit safe (non-eight-bit) encoding, which is useful if the transport or storage is not eight-bit safe. Defined by RFC 2152.</source>
          <target state="translated">七位安全(非八位)编码,在传输或存储不是八位安全的情况下很有用。由RFC 2152定义。</target>
        </trans-unit>
        <trans-unit id="a600cb53b0fe3c2106640728c33066b8be46fd29" translate="yes" xml:space="preserve">
          <source>A short description of the function of the op.</source>
          <target state="translated">简要说明行动纲领的功能;</target>
        </trans-unit>
        <trans-unit id="d96648e3b3628e3e472e306b3dd3028622349739" translate="yes" xml:space="preserve">
          <source>A short description of your module, what it does, why someone would use it and its limitations. CPAN automatically pulls your README file out of the archive and makes it available to CPAN users, it is the first thing they will read to decide if your module is right for them.</source>
          <target state="translated">简短的描述你的模块,它的作用,为什么有人会使用它,以及它的限制。CPAN会自动从档案中提取您的README文件,并将其提供给CPAN用户,这是他们决定您的模块是否适合他们的第一件事。</target>
        </trans-unit>
        <trans-unit id="7054451d8531a19f5986333d608566f0e421b059" translate="yes" xml:space="preserve">
          <source>A short name for your op. This will be included in some error messages, and will also be returned as &lt;code&gt;$op-&amp;gt;name&lt;/code&gt; by the &lt;a href=&quot;b&quot;&gt;B&lt;/a&gt; module, so it will appear in the output of module like &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="translated">您的操作的简称。这将包含在某些错误消息中，并且还将由&lt;a href=&quot;b&quot;&gt;B&lt;/a&gt;模块作为 &lt;code&gt;$op-&amp;gt;name&lt;/code&gt; 返回，因此它将出现在模块&lt;a href=&quot;b/concise&quot;&gt;B :: Concise之&lt;/a&gt;类的输出中。</target>
        </trans-unit>
        <trans-unit id="659172f97956f35000461e8175c3ae20d404aec4" translate="yes" xml:space="preserve">
          <source>A short usage summary for programs and functions. This section is mandatory for section 3 pages. For Perl module documentation, it's usually convenient to have the contents of this section be a verbatim block showing some (brief) examples of typical ways the module is used.</source>
          <target state="translated">程序和功能的简短使用总结。在第3节的页面中,本节是必须的。对于Perl模块文档来说,通常方便的做法是将本节的内容作为一个逐字块,展示一些(简要的)模块的典型使用方法的例子。</target>
        </trans-unit>
        <trans-unit id="ecd576fa5b368299ace3b5dd153caef33335850b" translate="yes" xml:space="preserve">
          <source>A shortcut for $token-&amp;gt;tagname(...)</source>
          <target state="translated">$ token-&amp;gt; tagname（...）的快捷方式</target>
        </trans-unit>
        <trans-unit id="889d9060f1528398717f26dcafe44f09ac88a287" translate="yes" xml:space="preserve">
          <source>A shortcut to return Math::BigInt-&amp;gt;binf(). Useful because Perl does not always handle bareword &lt;code&gt;inf&lt;/code&gt; properly.</source>
          <target state="translated">返回Math :: BigInt-&amp;gt; binf（）的快捷方式。很有用，因为Perl并不总是正确地处理裸字 &lt;code&gt;inf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c597d44b686300cfd664e15765135328081ac79a" translate="yes" xml:space="preserve">
          <source>A shortcut to return Math::BigInt-&amp;gt;bnan(). Useful because Perl does not always handle bareword &lt;code&gt;NaN&lt;/code&gt; properly.</source>
          <target state="translated">返回Math :: BigInt-&amp;gt; bnan（）的快捷方式。很有用，因为Perl并不总是正确处理准字 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c2bf7bb028dd860429a797ea74f61d6f6006cc5" translate="yes" xml:space="preserve">
          <source>A side effect of this representation is that you can use &lt;code&gt;eq&lt;/code&gt; to see if two references refer to the same thing. (But you should usually use &lt;code&gt;==&lt;/code&gt; instead because it's much faster.)</source>
          <target state="translated">这种表示的副作用是您可以使用 &lt;code&gt;eq&lt;/code&gt; 来查看两个引用是否引用同一事物。 （但是您通常应该使用 &lt;code&gt;==&lt;/code&gt; 代替，因为它快得多。）</target>
        </trans-unit>
        <trans-unit id="521c212b6a17d7bb672fae4188d350c73713a7f4" translate="yes" xml:space="preserve">
          <source>A sigil followed by a single character matching the &lt;code&gt;\p{POSIX_Punct}&lt;/code&gt; property, like &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt; , except the character &lt;code&gt;&quot;{&quot;&lt;/code&gt; doesn't work.</source>
          <target state="translated">印记，后跟与 &lt;code&gt;\p{POSIX_Punct}&lt;/code&gt; 属性匹配的单个字符，例如 &lt;code&gt;$!&lt;/code&gt; 或 &lt;code&gt;%+&lt;/code&gt; ，但字符 &lt;code&gt;&quot;{&quot;&lt;/code&gt; 不起作用。</target>
        </trans-unit>
        <trans-unit id="2cc8d7ea546cfbfc32e7048bc99953161b5c5af3" translate="yes" xml:space="preserve">
          <source>A sigil, followed by either a caret and a single POSIX uppercase letter, like &lt;code&gt;$^V&lt;/code&gt; or &lt;code&gt;$^W&lt;/code&gt; , or a sigil followed by a literal non-space, non-&lt;code&gt;NUL&lt;/code&gt; control character matching the &lt;code&gt;\p{POSIX_Cntrl}&lt;/code&gt; property. Due to a historical oddity, if not running under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , the 128 characters in the &lt;code&gt;[0x80-0xff]&lt;/code&gt; range are considered to be controls, and may also be used in length-one variables. However, the use of non-graphical characters is deprecated as of v5.22, and support for them will be removed in a future version of perl. ASCII space characters and &lt;code&gt;NUL&lt;/code&gt; already aren't allowed, so this means that a single-character variable name with that name being any other C0 control &lt;code&gt;[0x01-0x1F]&lt;/code&gt; , or &lt;code&gt;DEL&lt;/code&gt; will generate a deprecated warning. Already, under &lt;code&gt;&quot;use
utf8&quot;&lt;/code&gt; , non-ASCII characters must match &lt;code&gt;Perl_XIDS&lt;/code&gt; . As of v5.22, when not under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; C1 controls &lt;code&gt;[0x80-0x9F]&lt;/code&gt; , NO BREAK SPACE, and SOFT HYPHEN (&lt;code&gt;SHY&lt;/code&gt; )) generate a deprecated warning.</source>
          <target state="translated">标记，后跟插入符号和单个POSIX大写字母（例如 &lt;code&gt;$^V&lt;/code&gt; 或 &lt;code&gt;$^W&lt;/code&gt; ，或 &lt;code&gt;\p{POSIX_Cntrl}&lt;/code&gt; 与\ p {POSIX_Cntrl}属性匹配的文字非空格，非 &lt;code&gt;NUL&lt;/code&gt; 字符。由于历史原因，如果未在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; utf8的情况下运行，则 &lt;code&gt;[0x80-0xff]&lt;/code&gt; 范围内的128个字符将被视为控件，并且也可以在长度为1的变量中使用。但是，从v5.22开始，不再使用非图形字符，并且在以后的perl版本中将不再支持它们。 ASCII空格字符和 &lt;code&gt;NUL&lt;/code&gt; 已经不允许使用，因此这意味着一个单字符变量名称（该名称是任何其他C0控件 &lt;code&gt;[0x01-0x1F]&lt;/code&gt; 或 &lt;code&gt;DEL&lt;/code&gt; )将生成已弃用的警告。在 &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; ，非ASCII字符必须已经与 &lt;code&gt;Perl_XIDS&lt;/code&gt; 匹配。从v5.22开始，当不在 &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; C1控件 &lt;code&gt;[0x80-0x9F]&lt;/code&gt; ，NO BREAK SPACE和SOFT HYPHEN（ &lt;code&gt;SHY&lt;/code&gt; ））会生成不建议使用的警告。</target>
        </trans-unit>
        <trans-unit id="25c7b41e2f3083fca5663c24cdf9d0f7721da4bb" translate="yes" xml:space="preserve">
          <source>A sigil, followed solely by digits matching &lt;code&gt;\p{POSIX_Digit}&lt;/code&gt; , like &lt;code&gt;$0&lt;/code&gt; , &lt;code&gt;$1&lt;/code&gt; , or &lt;code&gt;$10000&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;\p{POSIX_Digit}&lt;/code&gt; ，仅跟\ p {POSIX_Digit}匹配的数字，例如 &lt;code&gt;$0&lt;/code&gt; ， &lt;code&gt;$1&lt;/code&gt; 或 &lt;code&gt;$10000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c803de64703554f9c3355b0bb0b711df0025cdae" translate="yes" xml:space="preserve">
          <source>A sign of 'NaN' is used to represent the result when input arguments are not numbers or as a result of 0/0. '+inf' and '-inf' represent plus respectively minus infinity. You will get '+inf' when dividing a positive number by 0, and '-inf' when dividing any negative number by 0.</source>
          <target state="translated">当输入的参数不是数字或结果是0/0时,用'NaN'符号来表示结果。当一个正数除以0时,你将得到'+inf',而当任何负数除以0时,将得到'-inf'。</target>
        </trans-unit>
        <trans-unit id="acfa2fff17c2c760f059166beff68ca97cf27024" translate="yes" xml:space="preserve">
          <source>A signature may be entirely empty, in which case all it does is check that the caller passed no arguments:</source>
          <target state="translated">一个签名可能是完全空的,在这种情况下,它所做的就是检查调用者没有传递任何参数。</target>
        </trans-unit>
        <trans-unit id="a3b7bfaadf566cb42bb060b59ab39877bdce37fb" translate="yes" xml:space="preserve">
          <source>A signed integer. This is cast to the required integer type when passed to C and converted to an IV when passed back to Perl.</source>
          <target state="translated">一个有符号的整数。当传递到C语言时,会被转换为所需的整数类型,当传递回Perl时,会被转换为IV。</target>
        </trans-unit>
        <trans-unit id="1575087c19c9eb3e9ca21e23f5fecff11363ecdb" translate="yes" xml:space="preserve">
          <source>A signed integer. This typemap converts the Perl value to a native integer type (the &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; type on the current platform). When returning the value to perl it is processed in the same way as for T_IV.</source>
          <target state="translated">有符号整数。此类型映射将Perl值转换为本地整数类型（当前平台上的 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 类型）。当将值返回给perl时，其处理方式与T_IV相同。</target>
        </trans-unit>
        <trans-unit id="9a6e260265e056207c62a15cda251b7b04ab7de2" translate="yes" xml:space="preserve">
          <source>A significant number of the bug reports we get turn out to be documented features in Perl. Make sure the issue you've run into isn't intentional by glancing through the documentation that comes with the Perl distribution.</source>
          <target state="translated">我们收到的大量错误报告都是Perl中的文档功能。通过浏览一下Perl发行版附带的文档,确保你遇到的问题不是故意的。</target>
        </trans-unit>
        <trans-unit id="80837079263cda7d0c48b62c5a2b8e0aa29ed989" translate="yes" xml:space="preserve">
          <source>A similar but more subtle problem is illustrated with this code:</source>
          <target state="translated">一个类似但更微妙的问题用这段代码来说明。</target>
        </trans-unit>
        <trans-unit id="81ab11bae0fce0f2612a231d95d1eecf127ccce2" translate="yes" xml:space="preserve">
          <source>A similar effect applies to</source>
          <target state="translated">类似的效果也适用于</target>
        </trans-unit>
        <trans-unit id="a23425aa80f51fe5db313d5664fb7ac8f4d286d0" translate="yes" xml:space="preserve">
          <source>A similar strategy would work for wildcard expansion via &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, although you can use &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">尽管可以使用 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 代替，但是类似的策略也可以通过 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 进行通配符扩展。</target>
        </trans-unit>
        <trans-unit id="eb1349e3e7bc2ad99052d135eb76b4bea7da2dc2" translate="yes" xml:space="preserve">
          <source>A similar task is to find words consisting of two identical parts:</source>
          <target state="translated">一个类似的任务是找到由两个相同部分组成的单词。</target>
        </trans-unit>
        <trans-unit id="ee2213ceffd8c1f2a6f17c3aee8ab7cdf3d4092c" translate="yes" xml:space="preserve">
          <source>A similar trick involves the</source>
          <target state="translated">类似的技巧还包括</target>
        </trans-unit>
        <trans-unit id="8848997a2920d88084bbf780cebe39466ec879ee" translate="yes" xml:space="preserve">
          <source>A simple API to convert seconds to other date values</source>
          <target state="translated">一个简单的API,将秒数转换为其他日期值。</target>
        </trans-unit>
        <trans-unit id="c123404763bd10d42cf8e7c2eaf59ecc97ce202f" translate="yes" xml:space="preserve">
          <source>A simple boolean indicating if the command executed without errors or not.</source>
          <target state="translated">一个简单的布尔值,表示命令是否无误执行。</target>
        </trans-unit>
        <trans-unit id="5bd4089058361e948e8b28ab1128c297a0f82d9e" translate="yes" xml:space="preserve">
          <source>A simple call to &lt;code&gt;isnt()&lt;/code&gt; usually does not provide a strong test but there are cases when you cannot say much more about a value than that it is different from some other value:</source>
          <target state="translated">对 &lt;code&gt;isnt()&lt;/code&gt; 的简单调用通常不会提供强大的测试，但是在某些情况下，您不能说出太多关于某个值与该值与其他值的不同之处：</target>
        </trans-unit>
        <trans-unit id="4fbcc760723f31ac561f9cef482138111eb6931b" translate="yes" xml:space="preserve">
          <source>A simple checking routine, which will return true if &lt;code&gt;Archive::Tar&lt;/code&gt; is able to uncompress compressed archives on the fly with &lt;code&gt;IO::Zlib&lt;/code&gt; and &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; or false if not both are installed.</source>
          <target state="translated">一个简单的检查例程，如果 &lt;code&gt;Archive::Tar&lt;/code&gt; 能够使用 &lt;code&gt;IO::Zlib&lt;/code&gt; 和 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 快速解压缩压缩的存档，则返回true；如果未同时安装两个，则返回false。</target>
        </trans-unit>
        <trans-unit id="afc5b3faec4a3f9f01b28a9e7d12132d66ab6e1d" translate="yes" xml:space="preserve">
          <source>A simple listing of all the files in your distribution.</source>
          <target state="translated">一个简单的列表,列出你的发行版中的所有文件。</target>
        </trans-unit>
        <trans-unit id="372959c464065982896bbbe2c2818eb6cad5f8a5" translate="yes" xml:space="preserve">
          <source>A simple mapping of the op type number to its type (like 'COP' or 'BINOP').</source>
          <target state="translated">一个简单的操作类型号到其类型的映射(如'COP'或'BINOP')。</target>
        </trans-unit>
        <trans-unit id="d472680931a17874166dba160d7f69e6352eb56b" translate="yes" xml:space="preserve">
          <source>A simple read-only accessor simply gets the value of a single attribute:</source>
          <target state="translated">一个简单的只读访问器只是简单地获取一个单一属性的值。</target>
        </trans-unit>
        <trans-unit id="681ff201b3498a43f7a62245e78650fd37d86b77" translate="yes" xml:space="preserve">
          <source>A simple scalar number</source>
          <target state="translated">一个简单的标量数</target>
        </trans-unit>
        <trans-unit id="1b93dcb8f21d326777ddc52bfa4bdd011dd04c4a" translate="yes" xml:space="preserve">
          <source>A simple scalar string</source>
          <target state="translated">一个简单的标量字符串</target>
        </trans-unit>
        <trans-unit id="5776d9f23e070178afac4296b05b65fd1f748404" translate="yes" xml:space="preserve">
          <source>A simple scalar with an extra reference</source>
          <target state="translated">一个带有额外参考的简单标量</target>
        </trans-unit>
        <trans-unit id="f593aa1a652c40c9b2c700bcf9bdc1dacfbe433a" translate="yes" xml:space="preserve">
          <source>A simple summary of the tests so far. True for pass, false for fail. This is a logical pass/fail, so todos are passes.</source>
          <target state="translated">简单总结一下目前的测试情况。True代表通过,false代表失败。这是一个逻辑上的通过/失败,所以todos是通过。</target>
        </trans-unit>
        <trans-unit id="e9ed86741cb6e707485ef431b1b242bee25c8fe1" translate="yes" xml:space="preserve">
          <source>A simple, singular value; a number, &lt;b&gt;string&lt;/b&gt;, or &lt;b&gt;reference&lt;/b&gt;.</source>
          <target state="translated">一个简单的奇异值；数字，&lt;b&gt;字符串&lt;/b&gt;或&lt;b&gt;参考&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="5a7d12449647b7d47425008bd7d9de56b3bffa22" translate="yes" xml:space="preserve">
          <source>A single character that represents the end of a line, with the ASCII value of 012 octal under Unix (but 015 on a Mac), and represented by &lt;code&gt;\n&lt;/code&gt; in Perl strings. For Windows machines writing text files, and for certain physical devices like terminals, the single newline gets automatically translated by your C library into a line feed and a carriage return, but normally, no translation is done.</source>
          <target state="translated">一个代表行尾的单个字符，Unix下为ASCII八进制012值（在Mac上为015），在Perl字符串中用 &lt;code&gt;\n&lt;/code&gt; 表示。对于编写文本文件的Windows计算机以及某些物理设备（如终端机），单个换行符将由C库自动转换为换行符和回车符，但通常不进行任何转换。</target>
        </trans-unit>
        <trans-unit id="2a1618c928b45217b1ecfab89b72e2f9c62e981a" translate="yes" xml:space="preserve">
          <source>A single entity with various interpretations, like an elephant. To a computer scientist, it&amp;rsquo;s a grammar for a little language in which some strings are legal and others aren&amp;rsquo;t. To normal people, it&amp;rsquo;s a pattern you can use to find what you&amp;rsquo;re looking for when it varies from case to case. Perl&amp;rsquo;s regular expressions are far from regular in the theoretical sense, but in regular use they work quite well. Here&amp;rsquo;s a regular expression: &lt;code&gt;/Oh s.*t./&lt;/code&gt; . This will match strings like &amp;ldquo;&lt;code&gt;Oh &lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt; can you see by the dawn's early light&lt;/code&gt; &amp;rdquo; and &amp;ldquo;&lt;code&gt;Oh sit!&lt;/code&gt; &amp;rdquo;. See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">具有多种解释的单个实体，例如大象。对于计算机科学家来说，这是一种小语言的语法，其中有些字符串合法，而有些则不合法。对于普通人来说，这是一种模式，您可以使用它来找到所要查找的内容，具体情况视情况而定。 Perl的正则表达式在理论上远非正则，但在正则使用中它们工作得很好。这是一个正则表达式： &lt;code&gt;/Oh s.*t./&lt;/code&gt; 。这将匹配诸如&amp;ldquo; &lt;code&gt;Oh &lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt; can you see by the dawn's early light&lt;/code&gt; &amp;rdquo;之类的字符串，以及&amp;ldquo; &lt;code&gt;Oh sit!&lt;/code&gt; &amp;rdquo;。请参见骆驼第5章&amp;ldquo;模式匹配&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="829152f3dcb1ed16bfc3e8ca36bfa63ebf05d7eb" translate="yes" xml:space="preserve">
          <source>A single hexadecimal number denoting a code point to include.</source>
          <target state="translated">一个单一的十六进制数字,表示要包括的代码点。</target>
        </trans-unit>
        <trans-unit id="27a4bf6aaf65d7e6150de844a569f0f9a5f667a4" translate="yes" xml:space="preserve">
          <source>A single piece of numeric or string data that is part of a longer &lt;b&gt;string&lt;/b&gt;, &lt;b&gt;record&lt;/b&gt;, or &lt;b&gt;line&lt;/b&gt;. Variable-width fields are usually split up by &lt;b&gt;separators&lt;/b&gt; (so use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; to extract the fields), while fixed-width fields are usually at fixed positions (so use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;). &lt;b&gt;Instance variables&lt;/b&gt; are also known as &amp;ldquo;fields&amp;rdquo;.</source>
          <target state="translated">单个数字或字符串数​​据，是较长的&lt;b&gt;字符串&lt;/b&gt;，&lt;b&gt;记录&lt;/b&gt;或&lt;b&gt;行的一部分&lt;/b&gt;。宽度可变的字段通常由&lt;b&gt;分隔符&lt;/b&gt;分开（因此请使用 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 提取字段），而宽度固定的字段通常位于固定位置（因此请使用 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ）。&lt;b&gt;实例变量&lt;/b&gt;也称为&amp;ldquo;字段&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3ff4db73bde7c1d7cfd3e2062dd1951912b9e366" translate="yes" xml:space="preserve">
          <source>A single symbol abbreviating the class of the OP.</source>
          <target state="translated">单一符号缩写的上位机类。</target>
        </trans-unit>
        <trans-unit id="ed641668fea177eedad336e7089851d18b828e16" translate="yes" xml:space="preserve">
          <source>A single testing job.</source>
          <target state="translated">单项测试工作。</target>
        </trans-unit>
        <trans-unit id="41bf4051bfbbef3d6c2986f2065087b05c2359b5" translate="yes" xml:space="preserve">
          <source>A single-quoted, literal string. A backslash represents a backslash unless followed by the delimiter or another backslash, in which case the delimiter or backslash is interpolated.</source>
          <target state="translated">一个单引号的字符串。反斜杠代表反斜杠,除非后面有定界符或另一个反斜杠,在这种情况下,定界符或反斜杠将被插入。</target>
        </trans-unit>
        <trans-unit id="8add36465a616cf6d47e4a5aef01fb690927c1f3" translate="yes" xml:space="preserve">
          <source>A slice accesses several elements of a list, an array, or a hash simultaneously using a list of subscripts. It's more convenient than writing out the individual elements as a list of separate scalar values.</source>
          <target state="translated">分片使用一个下标列表同时访问一个列表、一个数组或一个哈希中的多个元素。这比将单个元素写成一个独立的标量值列表要方便得多。</target>
        </trans-unit>
        <trans-unit id="7f8a4967d94ac75566470d147a5f123047048bbb" translate="yes" xml:space="preserve">
          <source>A slight modification also removes C++ comments, possibly spanning multiple lines using a continuation character:</source>
          <target state="translated">稍微修改一下,还可以删除C++注释,可能使用延续字符跨越多行。</target>
        </trans-unit>
        <trans-unit id="e99cb7094afcbc76a76c4efa1f4eefdffe5bff51" translate="yes" xml:space="preserve">
          <source>A slightly larger piece of code will provide something on which a profiler can produce more extensive reporting statistics. This example uses the simplistic &lt;code&gt;wordmatch&lt;/code&gt; program which parses a given input file and spews out a short report on the contents.</source>
          <target state="translated">稍大一些的代码将提供一些信息，探查器可以在这些信息上生成更广泛的报告统计信息。本示例使用简单的 &lt;code&gt;wordmatch&lt;/code&gt; 程序，该程序解析给定的输入文件，并针对内容弹出简短的报告。</target>
        </trans-unit>
        <trans-unit id="03934c7f98da92e385e9ea42d12c3ed3bec3632f" translate="yes" xml:space="preserve">
          <source>A slurpy hash parameter may be nameless just like other kinds of parameter. It still insists that the number of arguments available to it be even, even though they're not being put into a variable.</source>
          <target state="translated">稀疏的哈希参数可以像其他种类的参数一样是无名的。它仍然坚持它可用的参数数量是偶数,即使它们没有被放入一个变量中。</target>
        </trans-unit>
        <trans-unit id="30988eefa9eacb81270153c8608fad35b31b7f98" translate="yes" xml:space="preserve">
          <source>A slurpy parameter may instead be a hash, in which case the arguments available to it are interpreted as alternating keys and values. There must be as many keys as values: if there is an odd argument then an exception will be thrown. Keys will be stringified, and if there are duplicates then the later instance takes precedence over the earlier, as with standard hash construction.</source>
          <target state="translated">稀疏参数可以是一个哈希值,在这种情况下,它的可用参数被解释为交替的键和值。键和值的数量必须一样多:如果有一个奇数参数,那么将抛出一个异常。键将被串联,如果有重复,那么后面的实例将优先于前面的,就像标准的哈希结构一样。</target>
        </trans-unit>
        <trans-unit id="76d8ab783e8ae2210ac2fb7506feb3637ad91b4b" translate="yes" xml:space="preserve">
          <source>A slurpy parameter, either array or hash, must be the last thing in the signature. It may follow mandatory and optional positional parameters; it may also be the only thing in the signature. Slurpy parameters cannot have default values: if no arguments are supplied for them then you get an empty array or empty hash.</source>
          <target state="translated">一个模糊参数,无论是数组还是散列,必须是签名中的最后一件东西。它可以跟在强制参数和可选的位置参数后面;它也可以是签名中唯一的东西。稀疏参数不能有默认值:如果没有提供任何参数,那么你会得到一个空数组或空哈希。</target>
        </trans-unit>
        <trans-unit id="c7ed55a78ba712132c2ae6c86e583e8efc503821" translate="yes" xml:space="preserve">
          <source>A small example demonstrating SysV message queues:</source>
          <target state="translated">一个演示SysV消息队列的小例子。</target>
        </trans-unit>
        <trans-unit id="b0014acccc6b5556fca51e530830260283cc77d0" translate="yes" xml:space="preserve">
          <source>A small script which yields the problem will probably be of help. It would also be useful if this script was run with the extra options &lt;code&gt;Debug =&lt;/code&gt; 1&amp;gt; passed to the constructor, and the output sent with the bug report. If you cannot include a small script then please include a Debug trace from a run of your program which does yield the problem.</source>
          <target state="translated">产生问题的小脚本可能会有所帮助。如果在运行此脚本时将额外的选项 &lt;code&gt;Debug =&lt;/code&gt; 1&amp;gt;传递给构造函数，并且将输出与错误报告一起发送，则将很有用。如果您不能包含小的脚本，则请包含程序运行中的调试跟踪，这确实会产生问题。</target>
        </trans-unit>
        <trans-unit id="c165dd6d48bb6848a9c96904378fd915f9518c69" translate="yes" xml:space="preserve">
          <source>A small, simple, correct HTTP/1.1 client</source>
          <target state="translated">一个小巧、简单、正确的HTTP/1.1客户端。</target>
        </trans-unit>
        <trans-unit id="27545b929364aeeb83be800c720a5090d4d35630" translate="yes" xml:space="preserve">
          <source>A smart match that uses an explicit &lt;code&gt;~~&lt;/code&gt; operator, such as &lt;code&gt;EXPR ~~ EXPR&lt;/code&gt; .</source>
          <target state="translated">使用显式 &lt;code&gt;~~&lt;/code&gt; 运算符（例如 &lt;code&gt;EXPR ~~ EXPR&lt;/code&gt; )的智能匹配。</target>
        </trans-unit>
        <trans-unit id="5ee7049b5826d72a2f103072d053d50784d7d0da" translate="yes" xml:space="preserve">
          <source>A sneaky &lt;code&gt;LC_COLLATE&lt;/code&gt; locale could result in the names of students with &quot;D&quot; grades appearing ahead of those with &quot;A&quot;s.</source>
          <target state="translated">偷偷摸摸的 &lt;code&gt;LC_COLLATE&lt;/code&gt; 语言环境可能会导致&amp;ldquo; D&amp;rdquo;级学生的名字出现在&amp;ldquo; A&amp;rdquo;级学生的名字之前。</target>
        </trans-unit>
        <trans-unit id="5bd3117b0bc435a9ddefeeeda5fe0b0754edfcc4" translate="yes" xml:space="preserve">
          <source>A solution to this is to use a library which uses pseudottys to make your program behave more reasonably. This way you don't have to have control over the source code of the program you're using. The &lt;code&gt;Expect&lt;/code&gt; module from CPAN also addresses this kind of thing. This module requires two other modules from CPAN, &lt;code&gt;IO::Pty&lt;/code&gt; and &lt;code&gt;IO::Stty&lt;/code&gt; . It sets up a pseudo terminal to interact with programs that insist on talking to the terminal device driver. If your system is supported, this may be your best bet.</source>
          <target state="translated">解决方案是使用使用伪脚本的库，使程序的行为更合理。这样，您不必控制正在使用的程序的源代码。CPAN 的 &lt;code&gt;Expect&lt;/code&gt; 模块也解决了这类问题。该模块需要来自CPAN的其他两个模块： &lt;code&gt;IO::Pty&lt;/code&gt; 和 &lt;code&gt;IO::Stty&lt;/code&gt; 。它设置了一个伪终端，以与坚持与终端设备驱动程序对话的程序进行交互。如果您的系统受支持，那么这也许是最好的选择。</target>
        </trans-unit>
        <trans-unit id="0b80c1598a0b057abd1403fd2b9a7dc757cff1ce" translate="yes" xml:space="preserve">
          <source>A source filter is a special kind of Perl module that intercepts and modifies a source stream before it reaches the parser. A source filter changes our diagram like this:</source>
          <target state="translated">源过滤器是一种特殊的Perl模块,它可以在源流到达解析器之前对其进行拦截和修改。源过滤器改变了我们的图表,就像这样。</target>
        </trans-unit>
        <trans-unit id="8b0be58db42e648ec049b8d1ddee43ac5d107082" translate="yes" xml:space="preserve">
          <source>A space (or colon) separated list of PerlIO layers. If perl is built to use PerlIO system for IO (the default) these layers affect Perl's IO.</source>
          <target state="translated">用空格(或冒号)分隔的PerlIO层列表。如果perl是为了使用PerlIO系统进行IO而构建的(默认情况下),这些层会影响Perl的IO。</target>
        </trans-unit>
        <trans-unit id="0badf9ed68d3af0c4f3cd1c0a7af9f9020afc01b" translate="yes" xml:space="preserve">
          <source>A special &lt;b&gt;method&lt;/b&gt; that is called when an &lt;b&gt;object&lt;/b&gt; is thinking about &lt;b&gt;destroying&lt;/b&gt; itself. A Perl program&amp;rsquo;s &lt;code&gt;DESTROY&lt;/code&gt; method doesn&amp;rsquo;t do the actual destruction; Perl just &lt;b&gt;triggers&lt;/b&gt; the method in case the &lt;b&gt;class&lt;/b&gt; wants to do any associated cleanup.</source>
          <target state="translated">当&lt;b&gt;对象&lt;/b&gt;考虑&lt;b&gt;销毁&lt;/b&gt;自身时调用的一种特殊&lt;b&gt;方法&lt;/b&gt;。Perl程序的 &lt;code&gt;DESTROY&lt;/code&gt; 方法不会进行实际的销毁。如果&lt;b&gt;类&lt;/b&gt;想要进行任何关联的清理，Perl只会&lt;b&gt;触发&lt;/b&gt;该方法。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ef35c437c5c84fa1b46b5dc38d46f6fde11ec243" translate="yes" xml:space="preserve">
          <source>A special case is if the expression is a subroutine reference (in either &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; syntax or &lt;code&gt;\&amp;amp;foo&lt;/code&gt; syntax). In that case, it is executed and its value (true or false) determines if the test passes or fails. For example,</source>
          <target state="translated">特殊情况是表达式是子例程引用（使用 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; 语法或 &lt;code&gt;\&amp;amp;foo&lt;/code&gt; 语法）。在这种情况下，它会被执行，其值（真或假）确定测试是否通过。例如，</target>
        </trans-unit>
        <trans-unit id="4d4bdb3b56feee845f988c80b59a2de393b4d25c" translate="yes" xml:space="preserve">
          <source>A special entry &lt;code&gt;GetOptionsFromString&lt;/code&gt; can be used to parse options from an arbitrary string.</source>
          <target state="translated">特殊条目 &lt;code&gt;GetOptionsFromString&lt;/code&gt; 可用于解析任意字符串中的选项。</target>
        </trans-unit>
        <trans-unit id="f5f25c2de52c4c00b53b25ba03c614f087fa031c" translate="yes" xml:space="preserve">
          <source>A special file that contains other files. Some &lt;b&gt;operating systems&lt;/b&gt; call these &amp;ldquo;folders&amp;rdquo;, &amp;ldquo;drawers&amp;rdquo;, &amp;ldquo;catalogues&amp;rdquo;, or &amp;ldquo;catalogs&amp;rdquo;.</source>
          <target state="translated">包含其他文件的特殊文件。一些&lt;b&gt;操作系统将其&lt;/b&gt;称为&amp;ldquo;文件夹&amp;rdquo;，&amp;ldquo;抽屉&amp;rdquo;，&amp;ldquo;目录&amp;rdquo;或&amp;ldquo;目录&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9d4dee1bf51d9988b7b651c7e34b5ae56c3d23f3" translate="yes" xml:space="preserve">
          <source>A special form is the &lt;code&gt;(DEFINE)&lt;/code&gt; predicate, which never executes its yes-pattern directly, and does not allow a no-pattern. This allows one to define subpatterns which will be executed only by the recursion mechanism. This way, you can define a set of regular expression rules that can be bundled into any pattern you choose.</source>
          <target state="translated">&lt;code&gt;(DEFINE)&lt;/code&gt; 谓词是一种特殊形式，它从不直接执行其yes-pattern，并且不允许使用no-pattern。这样就可以定义只能由递归机制执行的子模式。这样，您可以定义一组正则表达式规则，这些规则规则可以捆绑到您选择的任何模式中。</target>
        </trans-unit>
        <trans-unit id="098ae82dbb47389fd0f04911d56700422f9e1bbd" translate="yes" xml:space="preserve">
          <source>A special internal spot in which Perl keeps the information about the last &lt;b&gt;file&lt;/b&gt; on which you requested information.</source>
          <target state="translated">一个特殊的内部位置，Perl在其中保留有关您请求信息的最后一个&lt;b&gt;文件的&lt;/b&gt;信息。</target>
        </trans-unit>
        <trans-unit id="79eddc4100fb4306d07fc838a90fb71a102a9485" translate="yes" xml:space="preserve">
          <source>A special kind of &lt;b&gt;module&lt;/b&gt; that does &lt;b&gt;preprocessing&lt;/b&gt; on your script just before it gets to the &lt;b&gt;tokener&lt;/b&gt;.</source>
          <target state="translated">一种特殊的&lt;b&gt;模块&lt;/b&gt;，它&lt;b&gt;预处理&lt;/b&gt;对你的脚本它到达之前&lt;b&gt;tokener&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="0c845e10d2c5e7d853c713ce339e272a56f03f5c" translate="yes" xml:space="preserve">
          <source>A special kind of &lt;b&gt;scalar context&lt;/b&gt; used in conditionals to decide whether the &lt;b&gt;scalar value&lt;/b&gt; returned by an expression is &lt;b&gt;true&lt;/b&gt; or &lt;b&gt;false&lt;/b&gt;. Does not evaluate as either a string or a number. See &lt;b&gt;context&lt;/b&gt;.</source>
          <target state="translated">一种条件条件&lt;b&gt;中&lt;/b&gt;使用的特殊类型的&lt;b&gt;标量上下文，&lt;/b&gt;用于确定表达式返回的&lt;b&gt;标量值&lt;/b&gt;是&lt;b&gt;true&lt;/b&gt;还是&lt;b&gt;false&lt;/b&gt;。既不算字符串也不算数字。参见&lt;b&gt;上下文&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="89b7b57b006b340679bccefff3860259f11cee5d" translate="yes" xml:space="preserve">
          <source>A special note about fetching files from an ftp uri:</source>
          <target state="translated">关于从ftp uri中获取文件的特别说明。</target>
        </trans-unit>
        <trans-unit id="2a568b09a052a4fda0da31a9dd45e8de43daae28" translate="yes" xml:space="preserve">
          <source>A special option 'name' &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; can be used to designate a subroutine to handle non-option arguments. When GetOptions() encounters an argument that does not look like an option, it will immediately call this subroutine and passes it one parameter: the argument name. Well, actually it is an object that stringifies to the argument name.</source>
          <target state="translated">特殊选项'name' &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 可用于指定子例程来处理非选项参数。当GetOptions（）遇到一个看起来不像选项的参数时，它将立即调用此子例程并将一个参数传递给它：参数名称。好吧，实际上这是一个字符串化为参数名称的对象。</target>
        </trans-unit>
        <trans-unit id="9bb864d2ebf5f6403ee2f29fbe30d0ca7cb3bbfc" translate="yes" xml:space="preserve">
          <source>A special program that runs on the bare machine and hides the gory details of managing &lt;b&gt;processes&lt;/b&gt; and &lt;b&gt;devices&lt;/b&gt;. Usually used in a looser sense to indicate a particular culture of programming. The loose sense can be used at varying levels of specificity. At one extreme, you might say that all versions of Unix and Unix-lookalikes are the same operating system (upsetting many people, especially lawyers and other advocates). At the other extreme, you could say this particular version of this particular vendor&amp;rsquo;s operating system is different from any other version of this or any other vendor&amp;rsquo;s operating system. Perl is much more portable across operating systems than many other languages. See also &lt;b&gt;architecture&lt;/b&gt; and &lt;b&gt;platform&lt;/b&gt;.</source>
          <target state="translated">一个在裸机上运行的特殊程序，隐藏了管理&lt;b&gt;进程&lt;/b&gt;和&lt;b&gt;设备的&lt;/b&gt;细节。通常以较宽松的含义使用，表示特定的编程文化。松散感可以用于不同的特异性水平。在一个极端情况下，您可能会说所有版本的Unix和类似Unix的东西都是相同的操作系统（使很多人感到不适，尤其是律师和其他提倡者）。在另一个极端，您可以说此特定供应商的操作系统的特定版本不同于该特定供应商的操作系统的任何其他版本。与许多其他语言相比，Perl在操作系统之间的可移植性要强得多。另请参阅&lt;b&gt;体系结构&lt;/b&gt;和&lt;b&gt;平台&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="b03867324ba36517f3a9d0e823f68ebcc5db216b" translate="yes" xml:space="preserve">
          <source>A special programming gizmo that keeps track of where you are in something that you&amp;rsquo;re trying to iterate over. The &lt;code&gt;foreach&lt;/code&gt; loop in Perl contains an iterator; so does a hash, allowing you to &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; through it.</source>
          <target state="translated">一个特殊的编程小控件，它可以跟踪您要迭代的内容的位置。该 &lt;code&gt;foreach&lt;/code&gt; 在Perl环路含有迭代器; 所以做了哈希，让你 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 穿过。</target>
        </trans-unit>
        <trans-unit id="cb2ae230ab87141b90e09da012ca49eb173d1f62" translate="yes" xml:space="preserve">
          <source>A special thanks to Damian Conway, who didn't only suggest important changes, but also took the time to count the number of listed features and make a Perl 6 version to show that Perl will stay Perl.</source>
          <target state="translated">特别感谢Damian Conway,他不仅提出了重要的修改建议,还花时间统计了列出的功能数量,并做了一个Perl 6版本,以表明Perl将继续保持Perl。</target>
        </trans-unit>
        <trans-unit id="dbd3a98639e4de23b8ab5b1ce7e392825e327157" translate="yes" xml:space="preserve">
          <source>A special token that compiles to the current line number.</source>
          <target state="translated">编译成当前行号的特殊标记。</target>
        </trans-unit>
        <trans-unit id="f8db7e23c364c11a426f9d30c1e28cd4da6326e7" translate="yes" xml:space="preserve">
          <source>A special token that returns a reference to the current subroutine, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; outside of a subroutine.</source>
          <target state="translated">一个特殊的令牌，它返回对当前子例程的引用，或者在子例程之外返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6eea162b97cdf5937cc80c12d97f68b73850c69" translate="yes" xml:space="preserve">
          <source>A special token that returns a reference to the current subroutine, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; outside of a subroutine.</source>
          <target state="translated">一个特殊的令牌，它返回对当前子例程的引用，或者在子例程之外返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c26f3ebdbb02dd6bf3cbae9d5ef0c2e36ca2b14" translate="yes" xml:space="preserve">
          <source>A special token that returns the name of the file in which it occurs.</source>
          <target state="translated">一个特殊的令牌,返回其所在文件的名称。</target>
        </trans-unit>
        <trans-unit id="48496bf275cb62c80b11546a66125c1e011d6e73" translate="yes" xml:space="preserve">
          <source>A special token that returns the name of the package in which it occurs.</source>
          <target state="translated">一个特殊的令牌,返回它出现的包的名称。</target>
        </trans-unit>
        <trans-unit id="07395fd97ce6a28d8015ab2eaad3eae19ab86b6e" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;croak()&lt;/code&gt; for emitting the usage message for xsubs</source>
          <target state="translated">&lt;code&gt;croak()&lt;/code&gt; 的一个特殊变体，用于发出xsubs的使用情况消息</target>
        </trans-unit>
        <trans-unit id="89a1130f5dbd32f8addbfbf8cc52dc9647058465" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;a href=&quot;#newHVhv&quot;&gt;newHVhv&lt;/a&gt; for copying &lt;code&gt;%^H&lt;/code&gt; .</source>
          <target state="translated">的专用版本&lt;a href=&quot;#newHVhv&quot;&gt;newHVhv&lt;/a&gt;复印 &lt;code&gt;%^H&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e58efa1c2b3f0ec95f611bcd359aa9037253ccf" translate="yes" xml:space="preserve">
          <source>A specification of how many spaces and digits and things to put somewhere so that whatever you&amp;rsquo;re printing comes out nice and pretty.</source>
          <target state="translated">一个关于在某处放置多少空格和数字以及事物的规范，以便您要打印的内容都变得漂亮。</target>
        </trans-unit>
        <trans-unit id="ece2ff0c58aaa5372289e45e695e7991badd8557" translate="yes" xml:space="preserve">
          <source>A spoonerism of &amp;ldquo;creeping featurism&amp;rdquo;, noting the biological urge to add just one more feature to a program.</source>
          <target state="translated">&amp;ldquo;爬行的特征主义&amp;rdquo;的尖锐主义，指出生物学的冲动，希望在程序中再增加一个功能。</target>
        </trans-unit>
        <trans-unit id="d575cbf3544d0e35868eb03520f7ba9dff410b04" translate="yes" xml:space="preserve">
          <source>A spot in your program where you&amp;rsquo;ve told the debugger to stop &lt;b&gt;execution&lt;/b&gt; so you can poke around and see whether anything is wrong yet.</source>
          <target state="translated">程序中的一个地方，您已告知调试器停止&lt;b&gt;执行，&lt;/b&gt;以便您可以四处查看并查看是否有任何问题。</target>
        </trans-unit>
        <trans-unit id="c8d0045954f55c0ef11ccdf21fdc1fefc0f23ff1" translate="yes" xml:space="preserve">
          <source>A square-bracketed list of characters used in a &lt;b&gt;regular expression&lt;/b&gt; to indicate that any character of the set may occur at a given point. Loosely, any predefined set of characters so used.</source>
          <target state="translated">&lt;b&gt;正则表达式中&lt;/b&gt;使用的方括号字符列表，用于指示集合中的任何字符都可以在给定点出现。松散地使用任何预定义的字符集。</target>
        </trans-unit>
        <trans-unit id="a4537030d9c45923983b601a7f64bbae6c4af141" translate="yes" xml:space="preserve">
          <source>A stable sort means that for records that compare equal, the original input ordering is preserved. Mergesort is stable, quicksort is not. Stability will matter only if elements that compare equal can be distinguished in some other way. That means that simple numerical and lexical sorts do not profit from stability, since equal elements are indistinguishable. However, with a comparison such as</source>
          <target state="translated">稳定的排序是指对于比较相等的记录,会保留原来的输入排序。Mergesort是稳定的,quicksort不是。只有当比较相等的元素可以用其他方式区分时,稳定性才会重要。这意味着简单的数字和词法排序不能从稳定性中获益,因为相等的元素是无法区分的。然而,对于像这样的比较</target>
        </trans-unit>
        <trans-unit id="0bc56d9c1394b0fa0321168c0b37750c90b88391" translate="yes" xml:space="preserve">
          <source>A standalone &lt;code&gt;=end&lt;/code&gt; command was found.</source>
          <target state="translated">找到一个独立的 &lt;code&gt;=end&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="90d81dc6a3e1d8ac5702b6911f4d25957cbc4616" translate="yes" xml:space="preserve">
          <source>A standard C library for doing &lt;b&gt;buffered&lt;/b&gt; input and output to the &lt;b&gt;operating system&lt;/b&gt;. (The &amp;ldquo;standard&amp;rdquo; of standard I/O is at most marginally related to the &amp;ldquo;standard&amp;rdquo; of standard input and output.) In general, Perl relies on whatever implementation of standard I/O a given operating system supplies, so the buffering characteristics of a Perl program on one machine may not exactly match those on another machine. Normally this only influences efficiency, not semantics. If your standard I/O package is doing block buffering and you want it to &lt;b&gt;flush&lt;/b&gt; the buffer more often, just set the &lt;code&gt;$|&lt;/code&gt; variable to a true value.</source>
          <target state="translated">一个标准的C库，用于对&lt;b&gt;操作系统&lt;/b&gt;进行&lt;b&gt;缓冲的&lt;/b&gt;输入和输出。 （标准I / O的&amp;ldquo;标准&amp;rdquo;最多与标准输入和输出的&amp;ldquo;标准&amp;rdquo;相关。）通常，Perl依赖于给定操作系统提供的标准I / O的任何实现，因此缓冲特性一台机器上的Perl程序的代码可能与另一台机器上的不完全匹配。通常，这仅影响效率，而不影响语义。如果您的标准I / O包正在执行块缓冲，并且您希望它更频繁地&lt;b&gt;刷新&lt;/b&gt;缓冲区，则只需设置 &lt;code&gt;$|&lt;/code&gt; 可变为真实值。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ffe116dcbea9e5d21815e3d329637659dd6eec04" translate="yes" xml:space="preserve">
          <source>A standard module whose practical hints and suggestions are received (and possibly ignored) at compile time. Pragmas are named in all lowercase.</source>
          <target state="translated">一个标准模块,在编译时,它的实用提示和建议被接收(可能被忽略)。Pragmas的名字都是小写的。</target>
        </trans-unit>
        <trans-unit id="3042ccfccce8001b84bc5b8d8019cf025a6017d9" translate="yes" xml:space="preserve">
          <source>A standard, bundled release of a system of software. The default usage implies source code is included. If that is not the case, it will be called a &amp;ldquo;binary-only&amp;rdquo; distribution.</source>
          <target state="translated">软件系统的标准捆绑发行版。默认用法表示包含源代码。如果不是这种情况，则将其称为&amp;ldquo;仅二进制&amp;rdquo;分发。</target>
        </trans-unit>
        <trans-unit id="c6647b8f10e57534f902ddf1aa4bccf61236fd6c" translate="yes" xml:space="preserve">
          <source>A statement sequence may contain declarations of lexically-scoped variables, but apart from declaring a variable name, the declaration acts like an ordinary statement, and is elaborated within the sequence of statements as if it were an ordinary statement. That means it actually has both compile-time and run-time effects.</source>
          <target state="translated">一个语句序列可能包含词法范围变量的声明,但除了声明一个变量名外,声明的作用就像一个普通的语句,在语句序列中就像普通的语句一样被阐述。也就是说,它实际上同时具有编译时和运行时的效果。</target>
        </trans-unit>
        <trans-unit id="fa46e467d8cdc232f6a66d28e35057665324ee9f" translate="yes" xml:space="preserve">
          <source>A string (char *).</source>
          <target state="translated">一个字符串(char *)。</target>
        </trans-unit>
        <trans-unit id="75e5df3441233543315a78a7205a2debb8ad739c" translate="yes" xml:space="preserve">
          <source>A string &lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt; parses its expression as standard Perl. It is therefore expecting the decimal point to be a dot. If &lt;code&gt;LC_NUMERIC&lt;/code&gt; is set to have this be a comma instead, the parsing will be confused, perhaps silently.</source>
          <target state="translated">字符串&lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt;将其表达式解析为标准Perl。因此，期望小数点是点。如果将 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 设置为逗号，则解析将被混淆，可能是无声的。</target>
        </trans-unit>
        <trans-unit id="b9568afdc53a4a7f1711d767a18a8d9f968593e6" translate="yes" xml:space="preserve">
          <source>A string beginning with &lt;code&gt;CLISYM_&lt;/code&gt; tells Perl to consult the CLI's symbol tables, using</source>
          <target state="translated">以 &lt;code&gt;CLISYM_&lt;/code&gt; 开头的字符串告诉Perl使用以下命令查询CLI的符号表</target>
        </trans-unit>
        <trans-unit id="afb88c9d62f1cca49157633840f22b59a116a8ab" translate="yes" xml:space="preserve">
          <source>A string containing all characters that should be encoded as HTML entities, specified using the regular expression character class syntax (what you find within brackets in regular expressions). This value will be passed as the second argument to the &lt;code&gt;encode_entities&lt;/code&gt; function of &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt;. If &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt; is not installed, then any characters other than &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt; &quot;'&amp;gt; will be encoded numerically.</source>
          <target state="translated">一个字符串，其中包含所有应编码为HTML实体的字符，使用正则表达式字符类语法（在正则表达式的方括号中找到的内容）指定。该值将作为第二个参数传递给&lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML :: Entities&lt;/a&gt;的 &lt;code&gt;encode_entities&lt;/code&gt; 函数。如果未安装&lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML :: Entities&lt;/a&gt;，则 &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt; &amp;ldquo;'&amp;gt; 以外的任何其他字符都将以数字方式编码。</target>
        </trans-unit>
        <trans-unit id="2c6988b512688bb605e69e65500198db5054baa8" translate="yes" xml:space="preserve">
          <source>A string containing the text of a message to print</source>
          <target state="translated">包含要打印的信息文本的字符串。</target>
        </trans-unit>
        <trans-unit id="bf5bf16fd07f45d581debfd5241308f05f5b876d" translate="yes" xml:space="preserve">
          <source>A string corresponding to the desired output file (or &quot;&amp;gt;&amp;amp;STDOUT&quot; or &quot;&amp;gt;&amp;amp;STDERR&quot;), or a filehandle to write on. The default is to use standard output.</source>
          <target state="translated">与所需的输出文件（或&amp;ldquo;&amp;gt;＆STDOUT&amp;rdquo;或&amp;ldquo;&amp;gt;＆STDERR&amp;rdquo;）相对应的字符串，或要写入的文件句柄。默认为使用标准输出。</target>
        </trans-unit>
        <trans-unit id="e81c48705eb13d4df1f22c2acd8523f46384c993" translate="yes" xml:space="preserve">
          <source>A string enclosed by backticks (grave accents) first undergoes double-quote interpolation. It is then interpreted as an external command, and the output of that command is the value of the backtick string, like in a shell. In scalar context, a single string consisting of all output is returned. In list context, a list of values is returned, one per line of output. (You can set &lt;code&gt;$/&lt;/code&gt; to use a different line terminator.) The command is executed each time the pseudo-literal is evaluated. The status value of the command is returned in &lt;code&gt;$?&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for the interpretation of &lt;code&gt;$?&lt;/code&gt; ). Unlike in &lt;b&gt;csh&lt;/b&gt;, no translation is done on the return data--newlines remain newlines. Unlike in any of the shells, single quotes do not hide variable names in the command from interpretation. To pass a literal dollar-sign through to the shell you need to hide it with a backslash. The generalized form of backticks is &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;. (Because backticks always undergo shell expansion as well, see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for security concerns.)</source>
          <target state="translated">先用反引号（重音符号）括起来的字符串进行双引号内插。然后将其解释为外部命令，并且该命令的输出是反引号字符串的值，就像在shell中一样。在标量上下文中，返回包含所有输出的单个字符串。在列表上下文中，返回值列表，每行输出一个。 （可以将 &lt;code&gt;$/&lt;/code&gt; 设置为使用不同的行终止符。）每次评估伪文字时，都会执行该命令。命令的状态值以 &lt;code&gt;$?&lt;/code&gt; 返回。（有关 &lt;code&gt;$?&lt;/code&gt; 的解释，请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;）。与&lt;b&gt;csh&lt;/b&gt;不同&lt;b&gt;&lt;/b&gt;，则不会对返回数据进行转换-换行符仍然是换行符。与在任何shell中不同，单引号不会从解释中隐藏命令中的变量名称。要将字面的美元符号传递到外壳，您需要使用反斜杠将其隐藏。反引号的一般形式是 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; 。（由于反引号也总是经历shell扩展，因此出于安全方面的考虑，请参见&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="8188c86cb7ff03c08e73a3bf26c2466b54d74c0a" translate="yes" xml:space="preserve">
          <source>A string encoded in UTF-EBCDIC may be longer (but never shorter) than one encoded in UTF-8. Perl extends UTF-8 so that it can encode code points above the Unicode maximum of U+10FFFF. It extends UTF-EBCDIC as well, but due to the inherent limitations in UTF-EBCDIC, the maximum code point expressible is U+7FFF_FFFF, even if the word size is more than 32 bits.</source>
          <target state="translated">用UTF-EBCDIC编码的字符串可能比用UTF-8编码的字符串长(但绝不会短)。Perl 对 UTF-8 进行了扩展,因此它可以对超过 Unicode 最大值 U+10FFFF 的码点进行编码。它也扩展了UTF-EBCDIC,但由于UTF-EBCDIC的固有限制,即使字的大小超过32位,可表达的最大码点也是U+7FFF_FFFFFFFF。</target>
        </trans-unit>
        <trans-unit id="f4917965ca44eb0c4faae94a841c4f89027d6938" translate="yes" xml:space="preserve">
          <source>A string of alternative option starter characters may be passed as the first argument (or the first argument after a leading hash reference argument).</source>
          <target state="translated">可以传递一串备选选项起始字符作为第一个参数(或前导哈希引用参数后的第一个参数)。</target>
        </trans-unit>
        <trans-unit id="46c47b9481cf147721b670360f462acc06f6b68e" translate="yes" xml:space="preserve">
          <source>A string of portable printable characters. This is the base64 encoded representation of the digest with any trailing padding removed. The string will be about 30% longer than the binary version. &lt;a href=&quot;mime/base64&quot;&gt;MIME::Base64&lt;/a&gt; tells you more about this encoding.</source>
          <target state="translated">一串可移植的可打印字符。这是摘要的base64编码表示形式，其中删除了所有尾随填充。该字符串将比二进制版本长30％左右。&lt;a href=&quot;mime/base64&quot;&gt;MIME :: Base64&lt;/a&gt;告诉您有关此编码的更多信息。</target>
        </trans-unit>
        <trans-unit id="5b5f076887ce0597a3fa01a1ea06dacb7c8fe5ad" translate="yes" xml:space="preserve">
          <source>A string representing a selection list for sections to be printed when -verbose is set to 99, e.g. &lt;code&gt;&quot;NAME|SYNOPSIS|DESCRIPTION|VERSION&quot;&lt;/code&gt; .</source>
          <target state="translated">表示当-verbose设置为99时要打印的部分的选择列表的字符串，例如 &lt;code&gt;&quot;NAME|SYNOPSIS|DESCRIPTION|VERSION&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="308056f61edbce292af89589357f11ee44fd726d" translate="yes" xml:space="preserve">
          <source>A string specifying a pattern to be matched as a prefix (which is to be skipped). If omitted, optional whitespace is skipped.</source>
          <target state="translated">一个字符串,指定要匹配的模式作为前缀(要跳过)。如果省略,则会跳过可选的空格。</target>
        </trans-unit>
        <trans-unit id="e9bc4f6bfc82a7d474c7f1ed6bc1a706c74a685f" translate="yes" xml:space="preserve">
          <source>A string specifying a pattern to be matched as the opening tag. If the pattern string is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) then a pattern that matches any standard XML tag is used.</source>
          <target state="translated">一个字符串，指定要匹配的模式作为开始标签。如果省略了模式字符串（或 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），则使用与任何标准XML标记匹配的模式。</target>
        </trans-unit>
        <trans-unit id="048410179c1d880e31b42e6134fee925ec940ae9" translate="yes" xml:space="preserve">
          <source>A string specifying a pattern to be matched at the closing tag. If the pattern string is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) then the closing tag is constructed by inserting a &lt;code&gt;/&lt;/code&gt; after any leading bracket characters in the actual opening tag that was matched (</source>
          <target state="translated">一个字符串，指定要在结束标记处匹配的模式。如果省略了模式字符串（或 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），则通过在匹配的实际开始标记中的任何前括号字符之后插入 &lt;code&gt;/&lt;/code&gt; 来构造结束标记（</target>
        </trans-unit>
        <trans-unit id="4ddc15672e491fc997c3e75cb530fdf3735fbd3c" translate="yes" xml:space="preserve">
          <source>A string that can suppress Perl's warning about failed locale settings at startup. Failure can occur if the locale support in the operating system is lacking (broken) in some way--or if you mistyped the name of a locale when you set up your environment. If this environment variable is absent, or has a value other than &quot;0&quot; or &quot;&quot;, Perl will complain about locale setting failures.</source>
          <target state="translated">一个可以抑制Perl在启动时对失败的locale设置的警告的字符串。如果操作系统中缺乏对locale的支持,或者你在设置环境时打错了locale的名称,就会发生失败。如果这个环境变量不存在,或者它的值不是 &quot;0 &quot;或&quot;&quot;,Perl就会抱怨locale设置失败。</target>
        </trans-unit>
        <trans-unit id="a2db67434e3c04d01083072b7b914ae53b6902d9" translate="yes" xml:space="preserve">
          <source>A string to be processed (&lt;code&gt;$_&lt;/code&gt; if the string is omitted or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">要处理的字符串（如果省略或 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; &lt;code&gt;$_&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6e51f4c9fde9edecc0936ad5478d06f35a15c4b1" translate="yes" xml:space="preserve">
          <source>A string which is (possibly) interpolated and then executed as a system command with</source>
          <target state="translated">一个字符串,它(可能)被内插,然后作为系统命令执行,并带有</target>
        </trans-unit>
        <trans-unit id="f332e2ab827e7ad888e10e40f020c6f2638261a6" translate="yes" xml:space="preserve">
          <source>A subclass for in-memory extracted file from Archive::Tar</source>
          <target state="translated">Archive::Tar中内存提取文件的子类。</target>
        </trans-unit>
        <trans-unit id="abd458b754cc911d966797f7f9e904a5bf421ea9" translate="yes" xml:space="preserve">
          <source>A subclass of Pod::Simple::PullParser should define a &lt;code&gt;run&lt;/code&gt; method that calls &lt;code&gt;$token = $parser-&amp;gt;get_token&lt;/code&gt; to pull tokens.</source>
          <target state="translated">Pod :: Simple :: PullParser的子类应定义一个 &lt;code&gt;run&lt;/code&gt; 方法，该方法调用 &lt;code&gt;$token = $parser-&amp;gt;get_token&lt;/code&gt; 提取令牌。</target>
        </trans-unit>
        <trans-unit id="6da5549484c85ec07cefefac0b04929e1e4b68b4" translate="yes" xml:space="preserve">
          <source>A subdirectory</source>
          <target state="translated">一个子目录</target>
        </trans-unit>
        <trans-unit id="f3c131323abddd429496c2a4e94519d28ee7cce1" translate="yes" xml:space="preserve">
          <source>A subform of &quot;Eskimo&quot;.</source>
          <target state="translated">&quot;爱斯基摩人 &quot;的一种亚型。</target>
        </trans-unit>
        <trans-unit id="2185f5ee89fe302e7bad5c0ce031b9136fe1881e" translate="yes" xml:space="preserve">
          <source>A subpattern &lt;b&gt;assertion&lt;/b&gt; matching the &lt;b&gt;null string&lt;/b&gt; between &lt;b&gt;characters&lt;/b&gt;.</source>
          <target state="translated">子模式&lt;b&gt;断言&lt;/b&gt;匹配&lt;b&gt;空字符串&lt;/b&gt;之间&lt;b&gt;的字符&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="dcb76fdf91425256508047ecf8357fd1c432b0b3" translate="yes" xml:space="preserve">
          <source>A subroutine declaration or definition may have a list of attributes associated with it. If such an attribute list is present, it is broken up at space or colon boundaries and treated as though a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attributes&lt;/code&gt; had been seen. See &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; for details about what attributes are currently supported. Unlike the limitation with the obsolescent &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attrs&lt;/code&gt; , the &lt;code&gt;sub : ATTRLIST&lt;/code&gt; syntax works to associate the attributes with a pre-declaration, and not just with a subroutine definition.</source>
          <target state="translated">子例程声明或定义可能具有与其关联的属性列表。如果存在这样的属性列表，则将其在空间或冒号边界处分解，并视为已看到 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attributes&lt;/code&gt; 。有关当前支持哪些属性的详细信息，请参见&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;。与过时 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attrs&lt;/code&gt; 的限制不同， &lt;code&gt;sub : ATTRLIST&lt;/code&gt; 语法可将属性与预声明关联，而不仅是与子例程定义关联。</target>
        </trans-unit>
        <trans-unit id="d523fe66bca5199af0174d9a0e394a363dbbca6f" translate="yes" xml:space="preserve">
          <source>A subroutine may be called using an explicit &lt;code&gt;&amp;amp;&lt;/code&gt; prefix. The &lt;code&gt;&amp;amp;&lt;/code&gt; is optional in modern Perl, as are parentheses if the subroutine has been predeclared. The &lt;code&gt;&amp;amp;&lt;/code&gt; is</source>
          <target state="translated">可以使用显式 &lt;code&gt;&amp;amp;&lt;/code&gt; 前缀调用子例程。该 &lt;code&gt;&amp;amp;&lt;/code&gt; 是现代的Perl可选的，因为有括号，如果子程序已预先声明。在 &lt;code&gt;&amp;amp;&lt;/code&gt; IS</target>
        </trans-unit>
        <trans-unit id="472af3789d6b7cf851a695ddbea3171cb9f6d23e" translate="yes" xml:space="preserve">
          <source>A subroutine reference to be run at the end of the test script, if any of the tests fail. See &lt;a href=&quot;#ONFAIL&quot;&gt;ONFAIL&lt;/a&gt;.</source>
          <target state="translated">如果任何测试失败，将在测试脚本的末尾运行一个子例程引用。参见&lt;a href=&quot;#ONFAIL&quot;&gt;ONFAIL&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a8138bb418c6dab14df47bdb5b98c794bb069d9" translate="yes" xml:space="preserve">
          <source>A subroutine stub (or forward declaration) looks like</source>
          <target state="translated">一个子程序存根(或正向声明)的样子是这样的</target>
        </trans-unit>
        <trans-unit id="5c6644152e307dff88d95b419866126c49ada182" translate="yes" xml:space="preserve">
          <source>A substitution can do this for you. For a single line, you want to replace all the leading or trailing whitespace with nothing. You can do that with a pair of substitutions:</source>
          <target state="translated">替换可以帮你做到这一点。对于一行,你想把所有的前导空格或尾部空格都替换成空白。你可以通过一对替换来实现。</target>
        </trans-unit>
        <trans-unit id="c348ffb20315d847f6359bc6cf9c39166e27bc60" translate="yes" xml:space="preserve">
          <source>A substring &lt;b&gt;captured&lt;/b&gt; by a subpattern within unadorned parentheses in a &lt;b&gt;regex&lt;/b&gt;. Backslashed decimal numbers (&lt;code&gt;\1&lt;/code&gt; , &lt;code&gt;\2&lt;/code&gt; , etc.) later in the same pattern refer back to the corresponding subpattern in the current match. Outside the pattern, the numbered variables (&lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc.) continue to refer to these same values, as long as the pattern was the last successful match of the current &lt;b&gt;dynamic scope&lt;/b&gt;.</source>
          <target state="translated">由&lt;b&gt;正则表达式中&lt;/b&gt;未修饰括号内的子模式&lt;b&gt;捕获&lt;/b&gt;的子字符串。稍后，在同一模式中反斜杠十进制数字（ &lt;code&gt;\1&lt;/code&gt; ， &lt;code&gt;\2&lt;/code&gt; 等）将参考当前匹配项中的相应子模式。在模式之外，带编号的变量（ &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等）继续引用这些相同的值，只要模式是当前&lt;b&gt;动态范围&lt;/b&gt;的最后成功匹配。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="315d0303e3aef241562f12b55669ceb9dfe96eb1" translate="yes" xml:space="preserve">
          <source>A subtest may call &lt;code&gt;skip_all&lt;/code&gt; . No tests will be run, but the subtest is considered a skip.</source>
          <target state="translated">子测试可以调用 &lt;code&gt;skip_all&lt;/code&gt; 。不会运行任何测试，但是子测试被视为跳过。</target>
        </trans-unit>
        <trans-unit id="37458279bba72a238643fe5627f2676bd36cfdcd" translate="yes" xml:space="preserve">
          <source>A subtest of the</source>
          <target state="translated">一个子测试</target>
        </trans-unit>
        <trans-unit id="ddbd7203825cf4784baaa474ee9dd57475c72727" translate="yes" xml:space="preserve">
          <source>A subtlety of the parsing process means that a regex like &lt;code&gt;/foo/&lt;/code&gt; is originally parsed into an alternation with a single branch. It is only afterwards that the optimiser converts single branch alternations into the simpler form.</source>
          <target state="translated">解析过程的微妙之处在于，像 &lt;code&gt;/foo/&lt;/code&gt; 这样的正则表达式最初被解析为具有单个分支的替代项。只有在此之后，优化器才能将单分支交替转换为更简单的形式。</target>
        </trans-unit>
        <trans-unit id="ca8ecc01810919d80818935b434bfbed09194445" translate="yes" xml:space="preserve">
          <source>A sufficiently complicated module using XS would have both Perl code (defined in</source>
          <target state="translated">一个使用XS的足够复杂的模块将同时拥有Perl代码(定义在XS中)和XS模块。</target>
        </trans-unit>
        <trans-unit id="ec7ba027499434cb4ad8ba5cfec6aea4c41ca3a7" translate="yes" xml:space="preserve">
          <source>A superset of stdio's &lt;code&gt;ungetc()&lt;/code&gt; . Should arrange for future reads to see the bytes in &lt;code&gt;vbuf&lt;/code&gt; . If there is no obviously better implementation then &lt;code&gt;PerlIOBase_unread()&lt;/code&gt; provides the function by pushing a &quot;fake&quot; &quot;pending&quot; layer above the calling layer.</source>
          <target state="translated">stdio的 &lt;code&gt;ungetc()&lt;/code&gt; 的超集。应该安排将来的读取以查看 &lt;code&gt;vbuf&lt;/code&gt; 中的字节。如果没有明显更好的实现，则 &lt;code&gt;PerlIOBase_unread()&lt;/code&gt; 通过在调用层之上推送&amp;ldquo; fake&amp;rdquo;&amp;ldquo; pending&amp;rdquo;层来提供该功能。</target>
        </trans-unit>
        <trans-unit id="c626abd78031b8aca6600ea0c2440d7fd00d78cd" translate="yes" xml:space="preserve">
          <source>A synonym for abs_path().</source>
          <target state="translated">abs_path()的同义词。</target>
        </trans-unit>
        <trans-unit id="e1b37e0c283299b17772ecb39d63c354cb1c21a5" translate="yes" xml:space="preserve">
          <source>A synopsis of the common uses of the module</source>
          <target state="translated">该模块的常见用途概要。</target>
        </trans-unit>
        <trans-unit id="cbedc357c1a8c0f556eb0ada80454f902c9b0495" translate="yes" xml:space="preserve">
          <source>A syntactic construct consisting of a sequence of Perl &lt;b&gt;statements&lt;/b&gt; that is delimited by braces. The &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt; statements are defined in terms of</source>
          <target state="translated">由由括号括起来的Perl &lt;b&gt;语句&lt;/b&gt;序列组成的语法构造。在 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;while&lt;/code&gt; 报表是来定义</target>
        </trans-unit>
        <trans-unit id="ad7124750e36065dd8c98d176b7da5958dc7cdde" translate="yes" xml:space="preserve">
          <source>A syntactic construct representing a comma- separated list of expressions, evaluated to produce a &lt;b&gt;list value&lt;/b&gt;. Each &lt;b&gt;expression&lt;/b&gt; in a</source>
          <target state="translated">表示以逗号分隔的表达式列表的语法构造，经评估可产生&lt;b&gt;列表值&lt;/b&gt;。一个中的每个&lt;b&gt;表达式&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7291be1f4b56b7d225866ff464ea491e8b919184" translate="yes" xml:space="preserve">
          <source>A system that algorithmically writes code for you in a high-level language. See also &lt;b&gt;code generator&lt;/b&gt;.</source>
          <target state="translated">一种系统地以高级语言为您编写代码的系统。另请参见&lt;b&gt;代码生成器&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="87ef544f16a30a02ca093ea233165dcf6ff6a52e" translate="yes" xml:space="preserve">
          <source>A system that writes code for you in a low-level language, such as code to implement the backend of a compiler. See &lt;b&gt;program generator&lt;/b&gt;.</source>
          <target state="translated">一种以低级语言为您编写代码的系统，例如用于实现编译器后端的代码。请参阅&lt;b&gt;程序生成器&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="57d745713dbf91df8c6f9ba2a699dab6d83ae07a" translate="yes" xml:space="preserve">
          <source>A template may be specified either with a leading template or with a TEMPLATE argument.</source>
          <target state="translated">可以用前导模板或TEMPLATE参数来指定模板。</target>
        </trans-unit>
        <trans-unit id="becc5a1b25927d1909dc38d940b77e72a5cc23a0" translate="yes" xml:space="preserve">
          <source>A template used in &lt;b&gt;pattern matching&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;模式匹配中&lt;/b&gt;使用的模板。</target>
        </trans-unit>
        <trans-unit id="460ed5b4079db2b66835c9fa0b74f3db75b6b725" translate="yes" xml:space="preserve">
          <source>A temporary failure occurred during name resolution. The operation may be successful if it is retried later.</source>
          <target state="translated">在名称解析过程中发生暂时性失败。如果以后再试,操作可能会成功。</target>
        </trans-unit>
        <trans-unit id="36377f90ac483d31142c52a673f24ea229719c46" translate="yes" xml:space="preserve">
          <source>A temporary holding location for data. Data that are &lt;b&gt;Block buffering&lt;/b&gt; means that the data is passed on to its destination whenever the buffer is full. &lt;b&gt;Line buffering&lt;/b&gt; means that it&amp;rsquo;s passed on whenever a complete line is received. &lt;b&gt;Command buffering&lt;/b&gt; means that it&amp;rsquo;s passed every time you do a &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; command (or equivalent). If your output is unbuffered, the system processes it one byte at a time without the use of a holding area. This can be rather inefficient.</source>
          <target state="translated">数据的临时存放位置。数据被&lt;b&gt;块缓冲&lt;/b&gt;装置，该数据被传递到其目的地每当缓冲器已满。&lt;b&gt;行缓冲&lt;/b&gt;意味着每当收到完整行时就继续传递。&lt;b&gt;命令缓冲&lt;/b&gt;意味着每次执行 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 命令（或等效命令）时都会传递&lt;b&gt;命令缓冲&lt;/b&gt;。如果您的输出是未缓冲的，则系统一次处理一个字节，而不使用保留区。这可能是相当低效的。</target>
        </trans-unit>
        <trans-unit id="f18ef7078604acdbaf428768e9818f7cd824fdb3" translate="yes" xml:space="preserve">
          <source>A temporary value scheduled to die when the current statement finishes.</source>
          <target state="translated">一个临时值,计划在当前语句结束后失效。</target>
        </trans-unit>
        <trans-unit id="be309ca808fdd70439ad47732767ff0fa5bc7488" translate="yes" xml:space="preserve">
          <source>A text &lt;b&gt;file&lt;/b&gt; that is a program intended to be &lt;b&gt;executed&lt;/b&gt; directly rather than &lt;b&gt;compiled&lt;/b&gt; to another form of file before &lt;b&gt;execution&lt;/b&gt;.</source>
          <target state="translated">一个文本&lt;b&gt;文件&lt;/b&gt;，是旨在直接&lt;b&gt;执行&lt;/b&gt;而不是在&lt;b&gt;执行&lt;/b&gt;前&lt;b&gt;编译&lt;/b&gt;为另一种文件形式的&lt;b&gt;程序&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="69f7603a0e21614f40b6c5bdc945d53c623ea439" translate="yes" xml:space="preserve">
          <source>A third argument is also passed to the handler, which contains a copy of the raw binary contents of the &lt;code&gt;siginfo&lt;/code&gt; structure: if a system has some non-POSIX fields, this third argument is where to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; them from.</source>
          <target state="translated">第三个参数也传递给处理程序，该处理程序包含 &lt;code&gt;siginfo&lt;/code&gt; 结构的原始二进制内容的副本：如果系统具有某些非POSIX字段，则该第三个参数是从中 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 它们的位置。</target>
        </trans-unit>
        <trans-unit id="6401a363806a46dc3a276adc43e53feeed2b394c" translate="yes" xml:space="preserve">
          <source>A third style of bundling allows only values to be bundled with options. It can be enabled with:</source>
          <target state="translated">第三种捆绑方式只允许将值与选项捆绑。它可以通过以下方式启用:</target>
        </trans-unit>
        <trans-unit id="ec67162265d799cee7ba073ea5ae61361a099a71" translate="yes" xml:space="preserve">
          <source>A thread is a flow of control through a program with a single execution point.</source>
          <target state="translated">线程是指通过一个程序的控制流,只有一个执行点。</target>
        </trans-unit>
        <trans-unit id="e05fa4d94d725ab6d1467a08643ac53ed8a48ab5" translate="yes" xml:space="preserve">
          <source>A thread terminated in some manner other than just returning from its entry point function, or by using &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; . For example, the thread may have terminated because of an error, or by using &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">线程以某种方式终止，而不仅仅是从其入口点函数返回，或者通过使用 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; 。例如，线程可能由于错误或使用 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="d5f8dc4f0e564ede193fccb0795b819fd8f8f455" translate="yes" xml:space="preserve">
          <source>A tied hash can have any semantics at all. It is typically tied to an on-disk database, so that cached values are stored in the database and retrieved from it again when needed, and the disk file typically persists after your program has exited. See &lt;code&gt;perltie&lt;/code&gt; for more complete details about &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">绑定散列可以具有任何语义。它通常与磁盘数据库绑定，以便将缓存的值存储在数据库中，并在需要时再次从数据库中检索，并且磁盘文件通常在程序退出后仍然存在。请参阅 &lt;code&gt;perltie&lt;/code&gt; 以获取有关 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 的更多完整详细信息。</target>
        </trans-unit>
        <trans-unit id="88fb398954c23d545a218b6f24145de7bcc79c9d" translate="yes" xml:space="preserve">
          <source>A token in a programming language, such as a number or &lt;b&gt;string&lt;/b&gt;, that gives you an actual &lt;b&gt;value&lt;/b&gt; instead of merely representing possible values as a &lt;b&gt;variable&lt;/b&gt; does.</source>
          <target state="translated">编程语言中的令牌，例如数字或&lt;b&gt;字符串&lt;/b&gt;，它为您提供实际&lt;b&gt;值，&lt;/b&gt;而不是像&lt;b&gt;变量&lt;/b&gt;那样仅表示可能的值。</target>
        </trans-unit>
        <trans-unit id="49a82ac17323d56d44189291d63111e25b7240b2" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;anyinflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了顶层函数 &lt;code&gt;anyinflate&lt;/code&gt; 来执行缓冲区和/或文件之间的&amp;ldquo;一次性&amp;rdquo;解压缩。要对解压缩过程进行更好的控制，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="87c7fedbb8115b85609fa9659aa296d9a84a6510" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;anyuncompress&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了顶层函数 &lt;code&gt;anyuncompress&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;解压缩。要对解压缩过程进行更好的控制，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="e389addc6410d492c7bd5a5e3cf1e11884bdfd29" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;bunzip2&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了顶级功能 &lt;code&gt;bunzip2&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;解压缩。要对解压缩过程进行更好的控制，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="fb0024f5a7eefa6e10161c1ed9db11d9ebbc931e" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;bzip2&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了一个顶级功能 &lt;code&gt;bzip2&lt;/code&gt; 来在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;压缩。要更好地控制压缩过程，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="565743b74071fd71d3b79fbb653796a00d3b13c8" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;deflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了顶级函数 &lt;code&gt;deflate&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;压缩。要更好地控制压缩过程，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="9810b58473f41aaf89cef15b62322dda3e22aea6" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;gunzip&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了顶层功能 &lt;code&gt;gunzip&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;解压缩。要对解压缩过程进行更好的控制，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="e6e391619962954b4fb420d746dbc210bda397a8" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;gzip&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了顶级功能 &lt;code&gt;gzip&lt;/code&gt; 来在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;压缩。要更好地控制压缩过程，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="cb09dcc8a8a7122c93016ac58ef7ca78f87815eb" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;inflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了一个顶级功能 &lt;code&gt;inflate&lt;/code&gt; 来执行缓冲区和/或文件之间的&amp;ldquo;一次性&amp;rdquo;解压缩。要对解压缩过程进行更好的控制，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="e6ff8dd50fc057dd45574766e64ed1ef729e4475" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;rawdeflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了顶级函数 &lt;code&gt;rawdeflate&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;压缩。要更好地控制压缩过程，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="da007ab4cef02cbdbebe645067fd56f8debb93a1" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;rawinflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了一个顶级函数 &lt;code&gt;rawinflate&lt;/code&gt; 来执行缓冲区和/或文件之间的&amp;ldquo;一次性&amp;rdquo;解压缩。要对解压缩过程进行更好的控制，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="522a8c4c8a64b09e73f7b19d33d186f1963c38ba" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;unzip&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了顶级功能 &lt;code&gt;unzip&lt;/code&gt; ，以在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;解压缩。要对解压缩过程进行更好的控制，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="cf0562aa58382ee4296c753a78a1efd86d792dc1" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;zip&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">提供了一个顶级功能 &lt;code&gt;zip&lt;/code&gt; 来在缓冲区和/或文件之间执行&amp;ldquo;一次性&amp;rdquo;压缩。要更好地控制压缩过程，请参见&amp;ldquo; &lt;a href=&quot;#OO-Interface&quot;&gt;OO接口&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="8b8620967b93bad58d8aa8f79801bf38881ee8c9" translate="yes" xml:space="preserve">
          <source>A totally different approach is to create a hash of function references.</source>
          <target state="translated">一种完全不同的方法是创建一个函数引用的哈希。</target>
        </trans-unit>
        <trans-unit id="980ba3b61619e7f53950a6b31a7df9b45b72edfd" translate="yes" xml:space="preserve">
          <source>A trailing colon is added automatically to the resulting path, to denote a directory.</source>
          <target state="translated">后面的冒号会自动添加到生成的路径中,表示一个目录。</target>
        </trans-unit>
        <trans-unit id="7b8da94bbc0623b636921b1bb640e93b774abc6e" translate="yes" xml:space="preserve">
          <source>A translation-concealed rooted logical name that contains Perl and the logical device for the @INC path on VMS only. Other logical names that affect Perl on VMS include PERLSHR, PERL_ENV_TABLES, and SYS$TIMEZONE_DIFFERENTIAL, but are optional and discussed further in &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt; and in</source>
          <target state="translated">转换隐蔽的根逻辑名称，仅包含Perl和VMS上@INC路径的逻辑设备。在VMS上影响Perl的其他逻辑名称包括PERLSHR，PERL_ENV_TABLES和SYS $ TIMEZONE_DIFFERENTIAL，但它们是可选的，并将在&lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt;和</target>
        </trans-unit>
        <trans-unit id="2dde805e9629b528928f950f1faf5f6602f0b7c5" translate="yes" xml:space="preserve">
          <source>A trivial application of this mechanism is to implement options that are related to each other. For example:</source>
          <target state="translated">这种机制的一个微不足道的应用是实现相互关联的选项。例如:</target>
        </trans-unit>
        <trans-unit id="a063d28faa82402e5b2d3d1ed31d0f1ad9c9dea3" translate="yes" xml:space="preserve">
          <source>A tutorial about writing really basic tests</source>
          <target state="translated">关于编写真正的基础测试的教程</target>
        </trans-unit>
        <trans-unit id="e89f1de21c226b59a1d42d1a18c10afa08b69645" translate="yes" xml:space="preserve">
          <source>A twice as long string of lowercase hexadecimal digits.</source>
          <target state="translated">一串两倍长的十六进制小写数字。</target>
        </trans-unit>
        <trans-unit id="d607f495a88ea6528e8578b9888418a4ffea3288" translate="yes" xml:space="preserve">
          <source>A type definition in the C and C++ languages.</source>
          <target state="translated">C和C++语言的类型定义。</target>
        </trans-unit>
        <trans-unit id="b268ce7d38ddd4cca20a237c3776e2eb1ce567ea" translate="yes" xml:space="preserve">
          <source>A typeglob may be dereferenced the same way a reference can, because the dereference syntax always indicates the type of reference desired. So &lt;code&gt;${*foo}&lt;/code&gt; and &lt;code&gt;${\$foo}&lt;/code&gt; both indicate the same scalar variable.</source>
          <target state="translated">可以通过引用相同的方式取消对typeglob的引用，因为取消引用语法始终表示所需引用的类型。因此 &lt;code&gt;${*foo}&lt;/code&gt; 和 &lt;code&gt;${\$foo}&lt;/code&gt; 都表示相同的标量变量。</target>
        </trans-unit>
        <trans-unit id="0bd7e8fb31d877d634438bee94398cae29fcf8b9" translate="yes" xml:space="preserve">
          <source>A typical %Lexicon entry is meant to signify a phrase, taking some number (0 or more) of parameters. An entry is meant to be accessed by via a string</source>
          <target state="translated">一个典型的 %Lexicon 条目是用来表示一个短语,需要一些数量(0 或更多)的参数。一个条目可以通过一个字符串来访问</target>
        </trans-unit>
        <trans-unit id="8cc65df0ae9490ead8aa8320483d71f0467ec4f8" translate="yes" xml:space="preserve">
          <source>A typical example is:</source>
          <target state="translated">一个典型的例子是:</target>
        </trans-unit>
        <trans-unit id="c800528a6e2ea28289c5fcbc08ec77553e110ecf" translate="yes" xml:space="preserve">
          <source>A typical invocation of &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; for a pure Perl module is:</source>
          <target state="translated">对于纯Perl模块，&lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;的典型调用是：</target>
        </trans-unit>
        <trans-unit id="74d9b7c164412a45025b12444007449586d960a8" translate="yes" xml:space="preserve">
          <source>A typical module using &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; starts like this:</source>
          <target state="translated">使用&lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt;的典型模块开始如下：</target>
        </trans-unit>
        <trans-unit id="42c5cd07f5670bfc29c548d8b58ba2ec35dd0a0d" translate="yes" xml:space="preserve">
          <source>A typical one is the version number of your OS specific module. (ie. MM_Unix_VERSION or MM_VMS_VERSION).</source>
          <target state="translated">一个典型的例子是你的操作系统特定模块的版本号,即MM_Unix_VERSION或MM_VMS_VERSION。(即 MM_Unix_VERSION 或 MM_VMS_VERSION)。</target>
        </trans-unit>
        <trans-unit id="11ed3b2a4b5cffbd69ae6d23ab2fd650fceaafba" translate="yes" xml:space="preserve">
          <source>A typical use of &lt;code&gt;gen_delimited_pat&lt;/code&gt; would be to build special purpose tags for &lt;code&gt;extract_tagged&lt;/code&gt; . For example, to properly ignore &quot;empty&quot; XML elements (which might contain quoted strings):</source>
          <target state="translated">&lt;code&gt;gen_delimited_pat&lt;/code&gt; 的典型用法是为 &lt;code&gt;extract_tagged&lt;/code&gt; 构建专用标签。例如，正确忽略&amp;ldquo;空&amp;rdquo; XML元素（其中可能包含带引号的字符串）：</target>
        </trans-unit>
        <trans-unit id="5f737b1553f7b6183bb539125409a9e3f04fb617" translate="yes" xml:space="preserve">
          <source>A typical use of the returned seed is for a test program which has too many combinations to test comprehensively in the time available to it each run. It can test a random subset each time, and should there be a failure, log the seed used for that run so that it can later be used to reproduce the same results.</source>
          <target state="translated">返回的种子的一个典型用途是用于测试程序,该程序有太多的组合,无法在每次运行的时间内进行全面的测试。它可以每次测试一个随机的子集,如果出现失败,则记录该运行中使用的种子,以便以后可以用来重现同样的结果。</target>
        </trans-unit>
        <trans-unit id="51560cf43fd833f1ac94f4446b3a3eeb2bb8e520" translate="yes" xml:space="preserve">
          <source>A typical use would be in the destructors of a class hierarchy, as illustrated in the synopsis above. Each class in the hierarchy has a DESTROY method that performs some class-specific action and then redispatches the call up the hierarchy. As a result, when an object of class D is destroyed, the destructors of</source>
          <target state="translated">一个典型的用法是在类层次结构的desttructors中,如上面的简介所示。层次结构中的每个类都有一个DESTROY方法,该方法执行一些特定于类的操作,然后在层次结构中重新发送调用。因此,当一个类D的对象被销毁时,类D的析构器的</target>
        </trans-unit>
        <trans-unit id="7966b50132f33654989f9cc4d535a23f71af99df" translate="yes" xml:space="preserve">
          <source>A typical way to define a collation element table without any file of table:</source>
          <target state="translated">一个典型的定义整理元素表的方法,不需要任何表的文件。</target>
        </trans-unit>
        <trans-unit id="ef22865cf4abb8e03f585fab66316610e54ceffa" translate="yes" xml:space="preserve">
          <source>A useful construct you might consider using is:</source>
          <target state="translated">你可以考虑使用的一个有用的结构是:</target>
        </trans-unit>
        <trans-unit id="c66028a80a3f2cbd725150b289e7fb5dace10a6d" translate="yes" xml:space="preserve">
          <source>A useful idiom for &lt;code&gt;lex&lt;/code&gt; -like scanners is &lt;code&gt;/\G.../gc&lt;/code&gt; . You can combine several regexps like this to process a string part-by-part, doing different actions depending on which regexp matched. Each regexp tries to match where the previous one leaves off.</source>
          <target state="translated">对于 &lt;code&gt;/\G.../gc&lt;/code&gt; &lt;code&gt;lex&lt;/code&gt; 的扫描器，一个有用的习惯用法是/\G.../gc。您可以像这样组合多个正则表达式来部分地处理一个字符串，根据匹配的正则表达式执行不同的操作。每个正则表达式都尝试匹配上一个正则表达式所在的位置。</target>
        </trans-unit>
        <trans-unit id="6c232601ef6ab32c7a06536b5534313e59c1adfb" translate="yes" xml:space="preserve">
          <source>A useful variation of the above is the target &lt;code&gt;testdb&lt;/code&gt; . It runs the test under the Perl debugger (see &lt;a href=&quot;../perldebug&quot;&gt;perldebug&lt;/a&gt;). If the file</source>
          <target state="translated">上面的一个有用的变化是目标 &lt;code&gt;testdb&lt;/code&gt; 。它在Perl调试器下运行测试（请参阅&lt;a href=&quot;../perldebug&quot;&gt;perldebug&lt;/a&gt;）。如果文件</target>
        </trans-unit>
        <trans-unit id="260c8a8479b809c6dd9a69c354f54517ffc43b32" translate="yes" xml:space="preserve">
          <source>A user ID. Often used in the context of &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;process&lt;/b&gt; ownership.</source>
          <target state="translated">用户ID。通常在&lt;b&gt;文件&lt;/b&gt;或&lt;b&gt;进程&lt;/b&gt;所有权的上下文中使用。</target>
        </trans-unit>
        <trans-unit id="c3c861709ec338f51d30ce5477159ff491c5825e" translate="yes" xml:space="preserve">
          <source>A user of Perl does not normally need to know nor care how Perl happens to encode its internal strings, but it becomes relevant when outputting Unicode strings to a stream without a PerlIO layer (one with the &quot;default&quot; encoding). In such a case, the raw bytes used internally (the native character set or UTF-8, as appropriate for each string) will be used, and a &quot;Wide character&quot; warning will be issued if those strings contain a character beyond 0x00FF.</source>
          <target state="translated">通常Perl的用户不需要知道也不关心Perl如何对内部字符串进行编码,但是当将Unicode字符串输出到没有PerlIO层的流中时(使用 &quot;默认 &quot;编码的流),这就变得很重要了。在这种情况下,将使用内部使用的原始字节(本机字符集或UTF-8,视每个字符串的情况而定),如果这些字符串包含一个超过0x00FF的字符,将发出 &quot;宽字符 &quot;警告。</target>
        </trans-unit>
        <trans-unit id="58e51e01dfdc97593c823ef9c32c82bf5b645a0e" translate="yes" xml:space="preserve">
          <source>A user-defined &lt;b&gt;type&lt;/b&gt;, implemented in Perl via a &lt;b&gt;package&lt;/b&gt; that provides (either directly or by inheritance) &lt;b&gt;methods&lt;/b&gt; (that is, &lt;b&gt;subroutines&lt;/b&gt;) to handle &lt;b&gt;instances&lt;/b&gt; of the class (its &lt;b&gt;objects&lt;/b&gt;). See also &lt;b&gt;inheritance&lt;/b&gt;.</source>
          <target state="translated">用户定义的&lt;b&gt;类型&lt;/b&gt;，通过Perl在一个&lt;b&gt;包&lt;/b&gt;中实现，该&lt;b&gt;包&lt;/b&gt;提供（直接或通过继承）&lt;b&gt;方法&lt;/b&gt;（即&lt;b&gt;子例程&lt;/b&gt;）来处理类（其&lt;b&gt;对象&lt;/b&gt;）的&lt;b&gt;实例&lt;/b&gt;。另请参见&lt;b&gt;继承&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="049b62081eecdd58978da0961ea176048425ca09" translate="yes" xml:space="preserve">
          <source>A user-defined subroutine call or a method invocation.</source>
          <target state="translated">用户定义的子程序调用或方法调用。</target>
        </trans-unit>
        <trans-unit id="0655aa7eaac426bb455567c21c49258161952382" translate="yes" xml:space="preserve">
          <source>A utility function that returns the line number that the function was called on. You can pass it an offset which will be added to the result. This is very useful for working out the correct text of diagnostic functions that contain line numbers.</source>
          <target state="translated">一个实用函数,返回函数被调用的行号。你可以传给它一个偏移量,这个偏移量将被添加到结果中。这对于找出包含行号的诊断函数的正确文本非常有用。</target>
        </trans-unit>
        <trans-unit id="62abf9744bbb54e44124db26e468de26dab74a60" translate="yes" xml:space="preserve">
          <source>A value indicating whether unmatched substrings (see below) within the text should be skipped or returned as fields. If the value is true, such substrings are skipped. Otherwise, they are returned.</source>
          <target state="translated">表示是否应跳过文本中未匹配的子串(见下文)或作为字段返回的值。如果该值为真,则跳过这些子串。否则,它们将被返回。</target>
        </trans-unit>
        <trans-unit id="9cb7aeb0b53152f8df982c234ecceb419398cf71" translate="yes" xml:space="preserve">
          <source>A value that happens to be a &lt;b&gt;scalar&lt;/b&gt; as opposed to a &lt;b&gt;list&lt;/b&gt;.</source>
          <target state="translated">恰好是&lt;b&gt;标量&lt;/b&gt;而不是&lt;b&gt;列表的值&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="6cfc7b273de973b6dc0aacfe92aeb280b49228f1" translate="yes" xml:space="preserve">
          <source>A value that is either &lt;b&gt;true&lt;/b&gt; or &lt;b&gt;false&lt;/b&gt;.</source>
          <target state="translated">值为&lt;b&gt;true&lt;/b&gt;或&lt;b&gt;false的值&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="a8f81a2763e41d6e30e66f64538647929ee6a4a5" translate="yes" xml:space="preserve">
          <source>A variable whose value is the name of another variable or subroutine. By &lt;b&gt;dereferencing&lt;/b&gt; the first variable, you can get at the second one. Symbolic references are illegal under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; .</source>
          <target state="translated">一个变量，其值为另一个变量或子例程的名称。通过&lt;b&gt;取消引用&lt;/b&gt;第一个变量，您可以获得第二个。符号引用正在非法 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca6ffd45b1cb28ce9dd386af1f375ee5391518d5" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;save_item&lt;/code&gt; which takes multiple arguments via an array &lt;code&gt;sarg&lt;/code&gt; of &lt;code&gt;SV*&lt;/code&gt; of length &lt;code&gt;maxsarg&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;save_item&lt;/code&gt; 的变体，它通过长度为 &lt;code&gt;maxsarg&lt;/code&gt; 的 &lt;code&gt;SV*&lt;/code&gt; 的数组 &lt;code&gt;sarg&lt;/code&gt; 接受多个参数。</target>
        </trans-unit>
        <trans-unit id="7ccb1828da7b95bb5a049529fa23b72700a0cdfc" translate="yes" xml:space="preserve">
          <source>A venerable Stream EDitor from which Perl derives some of its ideas.</source>
          <target state="translated">一个古老的 Stream EDitor,Perl 的一些理念就来源于此。</target>
        </trans-unit>
        <trans-unit id="695b604bb0917e749e0123615e9c577cb0315edf" translate="yes" xml:space="preserve">
          <source>A venerable typesetting language from which Perl derives the name of its &lt;code&gt;$%&lt;/code&gt; variable and which is secretly used in the production of Camel books.</source>
          <target state="translated">Perl是一种古老的排版语言，Perl从中衍生出它的 &lt;code&gt;$%&lt;/code&gt; 变量的名称，并被秘密地用于生产骆驼书。</target>
        </trans-unit>
        <trans-unit id="c02ac9d5e79aa52379337adc725d78150bf24188" translate="yes" xml:space="preserve">
          <source>A verbatim paragraph is distinguished by having its first character be a space or a tab. (And commonly, all its lines begin with spaces and/or tabs.) It should be reproduced exactly, with tabs assumed to be on 8-column boundaries. There are no special formatting codes, so you can't italicize or anything like that. A \ means \, and nothing else.</source>
          <target state="translated">一段逐字记录的区别在于其第一个字符是空格或制表符。(通常情况下,它的所有行都是以空格和/或制表符开头的。)它应该准确地复制,制表符假定在8列边界上。没有特殊的格式代码,所以你不能用斜体或类似的东西。a/是指/的意思,而不是其他。</target>
        </trans-unit>
        <trans-unit id="b4ee89b787aaa148bf4a7c02399965cde2c89e83" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;SvPV&lt;/code&gt; which guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once. Only use this if &lt;code&gt;sv&lt;/code&gt; is an expression with side effects, otherwise use the more efficient &lt;code&gt;SvPV&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 的版本，保证只评估一次 &lt;code&gt;sv&lt;/code&gt; 。仅当 &lt;code&gt;sv&lt;/code&gt; 是具有副作用的表达式时才使用此选项，否则请使用更有效的 &lt;code&gt;SvPV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="800c2c1c70843eecf0d954a2a74fcb4ffc03b783" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepv()&lt;/code&gt; /&lt;code&gt;savepvn()&lt;/code&gt; which gets the string to duplicate from the passed in SV using &lt;code&gt;SvPV()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;savepv()&lt;/code&gt; / &lt;code&gt;savepvn()&lt;/code&gt; 的版本，它使用 &lt;code&gt;SvPV()&lt;/code&gt; 从传入的SV中获取要复制的字符串</target>
        </trans-unit>
        <trans-unit id="89a4a2fa99f32dbf2c67191e1f912497d7b97772" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepv()&lt;/code&gt; which allocates the duplicate string in memory which is shared between threads.</source>
          <target state="translated">&lt;code&gt;savepv()&lt;/code&gt; 的一个版本，该版本在内存之间分配重复的字符串，该字符串在线程之间共享。</target>
        </trans-unit>
        <trans-unit id="5d7f6a9127b04f3a28923aa726cf029e923caeca" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepvn()&lt;/code&gt; which allocates the duplicate string in memory which is shared between threads. (With the specific difference that a NULL pointer is not acceptable)</source>
          <target state="translated">&lt;code&gt;savepvn()&lt;/code&gt; 的一个版本，它在内存中分配线程之间共享的重复字符串。（具体区别是不接受NULL指针）</target>
        </trans-unit>
        <trans-unit id="d9a7ac8d6bb6f23e5af260b2b68521de71f4974c" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepvs()&lt;/code&gt; which allocates the duplicate string in memory which is shared between threads.</source>
          <target state="translated">&lt;code&gt;savepvs()&lt;/code&gt; 的一个版本，该版本在内存之间分配重复的字符串，该字符串在线程之间共享。</target>
        </trans-unit>
        <trans-unit id="f84e0230ffdad6c151bf74824e07538ecfccd8ed" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savesharedpv()&lt;/code&gt; which allocates the duplicate string in memory which is shared between threads.</source>
          <target state="translated">&lt;code&gt;savesharedpv()&lt;/code&gt; 的一个版本，它在内存中分配线程之间共享的重复字符串。</target>
        </trans-unit>
        <trans-unit id="8ab5e633d2c66281cffd9c60de281036938368fe" translate="yes" xml:space="preserve">
          <source>A very complete generic buffering layer which provides the whole of PerlIO API. It is also intended to be used as a &quot;base class&quot; for other layers. (For example its &lt;code&gt;Read()&lt;/code&gt; method is implemented in terms of the &lt;code&gt;Get_cnt()&lt;/code&gt; /&lt;code&gt;Get_ptr()&lt;/code&gt; /&lt;code&gt;Set_ptrcnt()&lt;/code&gt; methods).</source>
          <target state="translated">一个非常完整的通用缓冲层，提供了整个PerlIO API。它也打算用作其他层的&amp;ldquo;基类&amp;rdquo;。 （例如，其 &lt;code&gt;Read()&lt;/code&gt; 方法是根据 &lt;code&gt;Get_cnt()&lt;/code&gt; / &lt;code&gt;Get_ptr()&lt;/code&gt; / &lt;code&gt;Set_ptrcnt()&lt;/code&gt; 方法实现的）。</target>
        </trans-unit>
        <trans-unit id="cff43b9c47bd071d2d320e539e7c2ec5b836b1af" translate="yes" xml:space="preserve">
          <source>A very large and constantly evolving language with several alternative and largely incompatible syntaxes, in which anyone can define anything any way they choose, and usually do. Speakers of this language think it&amp;rsquo;s easy to learn because it&amp;rsquo;s so easily twisted to one&amp;rsquo;s own ends, but dialectical differences make tribal intercommunication nearly impossible, and travelers are often reduced to a pidgin-like subset of the language. To be universally understood, a Unix shell programmer must spend years of study in the art. Many have abandoned this discipline and now communicate via an Esperanto-like language called Perl.</source>
          <target state="translated">这是一种非常庞大且不断发展的语言，具有多种可供选择且很大程度上不兼容的语法，任何人都可以用自己选择的方式定义任何内容，并且通常可以这样做。讲这种语言的人认为它很容易学习，因为它很容易被扭曲到自己的目的，但是辩证性差异使得部落之间的交流几乎变得不可能，旅行者通常被简化为一种类似于pidgin的语言。为了得到普遍的理解，Unix Shell程序员必须花费数年的时间进行本领域的研究。许多人已经放弃了这一学科，现在通过一种类似世界语的语言称为Perl进行交流。</target>
        </trans-unit>
        <trans-unit id="b75485a79ff1cabe11e71e2c78ee68045837b121" translate="yes" xml:space="preserve">
          <source>A very thin wrapper around Config.pm so MakeMaker is easier to test.</source>
          <target state="translated">围绕Config.pm的一个非常薄的包装,所以MakeMaker更容易测试。</target>
        </trans-unit>
        <trans-unit id="3816dce510c914716ac16326960ce66f1b1eab28" translate="yes" xml:space="preserve">
          <source>A void* pointing to an engine-defined data structure. The Perl engine uses the &lt;code&gt;regexp_internal&lt;/code&gt; structure (see &lt;a href=&quot;perlreguts#Base-Structures&quot;&gt;Base Structures in perlreguts&lt;/a&gt;) but a custom engine should use something else.</source>
          <target state="translated">指向引擎定义的数据结构的void *。Perl引擎使用 &lt;code&gt;regexp_internal&lt;/code&gt; 结构（请参阅perlreguts中的&lt;a href=&quot;perlreguts#Base-Structures&quot;&gt;基本结构&lt;/a&gt;），但是自定义引擎应使用其他内容。</target>
        </trans-unit>
        <trans-unit id="199fcb36f761477b8bc11025866dc8da66f59cd6" translate="yes" xml:space="preserve">
          <source>A walled off area that&amp;rsquo;s not supposed to affect beyond its walls. You let kids play in the sandbox instead of running in the road. See Camel chapter 20, &amp;ldquo;Security&amp;rdquo;.</source>
          <target state="translated">隔离墙，不应影响其墙外。您可以让孩子们在沙盒中玩耍，而不是在路上奔跑。参见骆驼第20章，&amp;ldquo;安全性&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="52bce4e77f028ccf4be5e2732e6cc0cda9d45ce4" translate="yes" xml:space="preserve">
          <source>A warning is issued if an attempt is made to register an operator not found above.</source>
          <target state="translated">如果试图注册一个没有在上面找到的操作员,就会发出警告。</target>
        </trans-unit>
        <trans-unit id="a18ef0b74f65545d966263b3d3c2472e8453a59c" translate="yes" xml:space="preserve">
          <source>A warning is printed if more than one POD file with the same POD name is found, e.g.</source>
          <target state="translated">如果发现一个以上的POD文件有相同的POD名称,就会打印一个警告,如</target>
        </trans-unit>
        <trans-unit id="700f87e210bceec8357a7b2e426634dd3d25de48" translate="yes" xml:space="preserve">
          <source>A well-defined sequence of steps, explained clearly enough that even a computer could do them.</source>
          <target state="translated">一个定义明确的步骤序列,解释得足够清楚,甚至计算机也能做到。</target>
        </trans-unit>
        <trans-unit id="69583ba800841309993f3cd8027c2138231fdd98" translate="yes" xml:space="preserve">
          <source>A whiz-bang hardware gizmo (like a disk or tape drive or a modem or a joystick or a mouse) attached to your computer, which the &lt;b&gt;operating system&lt;/b&gt; tries to make look like a &lt;b&gt;file&lt;/b&gt; (or a bunch of files). Under Unix, these fake files tend to live in the</source>
          <target state="translated">连接到您计算机上的超速硬件小控件（例如磁盘或磁带驱动器，调制解调器，操纵杆或鼠标），&lt;b&gt;操作系统会&lt;/b&gt;尝试使它看起来像一个&lt;b&gt;文件&lt;/b&gt;（或一堆文件）。在Unix下，这些伪造文件往往存在于</target>
        </trans-unit>
        <trans-unit id="90dbb683e595bd8a442976ee525366f34cadb549" translate="yes" xml:space="preserve">
          <source>A word boundary (&lt;code&gt;\b&lt;/code&gt; ) is a spot between two characters that has a &lt;code&gt;\w&lt;/code&gt; on one side of it and a &lt;code&gt;\W&lt;/code&gt; on the other side of it (in either order), counting the imaginary characters off the beginning and end of the string as matching a &lt;code&gt;\W&lt;/code&gt; . (Within character classes &lt;code&gt;\b&lt;/code&gt; represents backspace rather than a word boundary, just as it normally does in any double-quoted string.) The &lt;code&gt;\A&lt;/code&gt; and &lt;code&gt;\Z&lt;/code&gt; are just like &quot;^&quot; and &quot;$&quot;, except that they won't match multiple times when the &lt;code&gt;/m&lt;/code&gt; modifier is used, while &quot;^&quot; and &quot;$&quot; will match at every internal line boundary. To match the actual end of the string and not ignore an optional trailing newline, use &lt;code&gt;\z&lt;/code&gt; .</source>
          <target state="translated">单词边界（ &lt;code&gt;\b&lt;/code&gt; ）是两个字符之间的一个点，该字符的一侧是 &lt;code&gt;\w&lt;/code&gt; ，另一侧是 &lt;code&gt;\W&lt;/code&gt; （以任一顺序排列），从假想字符的开头和结尾算起匹配 &lt;code&gt;\W&lt;/code&gt; 字符串。 （在字符类中， &lt;code&gt;\b&lt;/code&gt; 表示退格，而不是单词边界，就像通常在任何双引号字符串中一样。） &lt;code&gt;\A&lt;/code&gt; 和 &lt;code&gt;\Z&lt;/code&gt; 与&amp;ldquo; ^&amp;rdquo;和&amp;ldquo; $&amp;rdquo;一样，除了它们不会使用 &lt;code&gt;/m&lt;/code&gt; 修饰符时，匹配多次，而&amp;ldquo; ^&amp;rdquo;和&amp;ldquo; $&amp;rdquo;将在每个内部行边界匹配。为了匹配字符串的实际结尾并且不忽略可选的尾随换行符，用 &lt;code&gt;\z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9f5130c323d4b84b2e0887ec7513db659cf437f" translate="yes" xml:space="preserve">
          <source>A word on terminology: I shall use the term</source>
          <target state="translated">关于术语问题。我将使用这个词</target>
        </trans-unit>
        <trans-unit id="b1c5343ffbdad1e7ce4b8c849341bcb5442f07e1" translate="yes" xml:space="preserve">
          <source>A word sufficiently ambiguous to be deemed illegal under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'subs'&lt;/code&gt; . In the absence of that stricture, a bareword is treated as if quotes were around it.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'subs'&lt;/code&gt; 足够模糊的单词被视为非法。在没有这种限制的情况下，将裸词视为引号引起来。</target>
        </trans-unit>
        <trans-unit id="310f40f7f3f90c12a6b195eedcb48c5f8026ea77" translate="yes" xml:space="preserve">
          <source>A word that has no other interpretation in the grammar will be treated as if it were a quoted string. These are known as &quot;barewords&quot;. As with filehandles and labels, a bareword that consists entirely of lowercase letters risks conflict with future reserved words, and if you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; switch, Perl will warn you about any such words. Perl limits barewords (like identifiers) to about 250 characters. Future versions of Perl are likely to eliminate these arbitrary limitations.</source>
          <target state="translated">语法中没有其他解释的单词将被视为带引号的字符串。这些被称为&amp;ldquo;流行词&amp;rdquo;。与文件句柄和标签一样，一个完全由小写字母组成的裸字可能会与将来的保留字冲突，如果您使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 编译指示或&lt;b&gt;-w&lt;/b&gt;开关，Perl会警告您任何此类字。Perl将裸字（如标识符）限制为大约250个字符。Perl的未来版本可能会消除这些任意限制。</target>
        </trans-unit>
        <trans-unit id="41517852ad5f31fc26a5aada0fdb82adad0543c7" translate="yes" xml:space="preserve">
          <source>A word with a specific, built-in meaning to a &lt;b&gt;compiler&lt;/b&gt;, such as &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;. In many languages (not Perl), it&amp;rsquo;s illegal to use reserved words to name anything else. (Which is why they&amp;rsquo;re reserved, after all.) In Perl, you just can&amp;rsquo;t use them to name &lt;b&gt;labels&lt;/b&gt; or &lt;b&gt;filehandles&lt;/b&gt;. Also called &amp;ldquo;keywords&amp;rdquo;.</source>
          <target state="translated">对&lt;b&gt;编译器&lt;/b&gt;具有特定的内置含义的单词，例如 &lt;code&gt;if&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 。在许多语言（不是Perl）中，使用保留字来命名其他名称都是非法的。（毕竟，这就是为什么要保留它们的原因。）在Perl中，您不能使用它们来命名&lt;b&gt;标签&lt;/b&gt;或&lt;b&gt;文件句柄&lt;/b&gt;。也称为&amp;ldquo;关键字&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="435e32d3ce964aedd25193932afab04e1daf13f7" translate="yes" xml:space="preserve">
          <source>A work-around is the following:</source>
          <target state="translated">一个变通的办法是:</target>
        </trans-unit>
        <trans-unit id="07daf0448b91b826afed53a20124ecc976475c82" translate="yes" xml:space="preserve">
          <source>A workaround for this is to call the constants once in a &lt;code&gt;BEGIN&lt;/code&gt; block:</source>
          <target state="translated">一种解决方法是在 &lt;code&gt;BEGIN&lt;/code&gt; 块中一次调用常量：</target>
        </trans-unit>
        <trans-unit id="c5d091eede565087a31db8b62e48d4dd20b23599" translate="yes" xml:space="preserve">
          <source>A working knowledge of XSUB programming is incredibly useful for core hacking; XSUBs use techniques drawn from the PP code, the portion of the guts that actually executes a Perl program. It's a lot gentler to learn those techniques from simple examples and explanation than from the core itself.</source>
          <target state="translated">XSUB编程知识对于核心黑客来说是非常有用的;XSUB使用的技术来自PP代码,也就是实际执行Perl程序的内脏部分。从简单的例子和解释中学习这些技术比从核心本身学习要温和得多。</target>
        </trans-unit>
        <trans-unit id="ecdab41b6d91aa8f615325452505a14f3756b711" translate="yes" xml:space="preserve">
          <source>A wrapper around ExtUtils::Install::uninstall(). Warns that uninstallation is deprecated and doesn't actually perform the uninstallation.</source>
          <target state="translated">ExtUtils::Install::uninstall()的封装器。警告卸载已被废弃,但并不实际执行卸载。</target>
        </trans-unit>
        <trans-unit id="7b1bd466739a9d9dd8c4b1931d422a782c699350" translate="yes" xml:space="preserve">
          <source>A wrapper for &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt;&lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt;的包装 &lt;code&gt;fetchrow_array&lt;/code&gt; 和 &lt;code&gt;fetchrow_hashref&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1d7f5dea12f6359a6636612f15ad99428ef6c1b4" translate="yes" xml:space="preserve">
          <source>A wrapper for the combination of &lt;code&gt;normalize()&lt;/code&gt; and &lt;code&gt;splitOnLastStarter()&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">包装 &lt;code&gt;normalize()&lt;/code&gt; 和 &lt;code&gt;splitOnLastStarter()&lt;/code&gt; 的包装。请注意， &lt;code&gt;$unprocessed&lt;/code&gt; 将被修改为副作用。</target>
        </trans-unit>
        <trans-unit id="9a971835f0cc905c4c81e0e15a1789f5da379aa1" translate="yes" xml:space="preserve">
          <source>A wrapper of pack_sockaddr_in() or unpack_sockaddr_in(). In list context, unpacks its argument and returns a list consisting of the port and IP address. In scalar context, packs its port and IP address arguments as a &lt;code&gt;sockaddr_in&lt;/code&gt; and returns it.</source>
          <target state="translated">pack_sockaddr_in（）或unpack_sockaddr_in（）的包装。在列表上下文中，解压缩其参数并返回由端口和IP地址组成的列表。在标量上下文中，将其端口和IP地址参数打包为 &lt;code&gt;sockaddr_in&lt;/code&gt; 并返回它。</target>
        </trans-unit>
        <trans-unit id="7da94d0b3d719c597383180b871afe1e809e7e59" translate="yes" xml:space="preserve">
          <source>A wrapper of pack_sockaddr_in6() or unpack_sockaddr_in6(). In list context, unpacks its argument according to unpack_sockaddr_in6(). In scalar context, packs its arguments according to pack_sockaddr_in6().</source>
          <target state="translated">pack_sockaddr_in6()或unpack_sockaddr_in6()的封装器。在list上下文中,根据unpack_sockaddr_in6()来解包它的参数。在标量上下文中,根据pack_sockaddr_in6()来打包它的参数。</target>
        </trans-unit>
        <trans-unit id="53a1600cfdb74295cdddc3a0923b5ac6c8e36129" translate="yes" xml:space="preserve">
          <source>A wrapper of pack_sockaddr_un() or unpack_sockaddr_un(). In a list context, unpacks its argument and returns a list consisting of the pathname. In a scalar context, packs its pathname as a &lt;code&gt;sockaddr_un&lt;/code&gt; and returns it.</source>
          <target state="translated">pack_sockaddr_un（）或unpack_sockaddr_un（）的包装。在列表上下文中，解压缩其参数并返回包含路径名的列表。在标量上下文中，将其路径名打包为 &lt;code&gt;sockaddr_un&lt;/code&gt; 并返回它。</target>
        </trans-unit>
        <trans-unit id="7fe6b1e666d9c00f78d39c2310ecc107997b967e" translate="yes" xml:space="preserve">
          <source>A zero is represented and returned as &lt;code&gt;0E1&lt;/code&gt; , &lt;b&gt;not&lt;/b&gt;&lt;code&gt;0E0&lt;/code&gt; (after Knuth).</source>
          <target state="translated">零表示为 &lt;code&gt;0E1&lt;/code&gt; ，&lt;b&gt;而不是&lt;/b&gt; &lt;code&gt;0E0&lt;/code&gt; （在Knuth之后）。</target>
        </trans-unit>
        <trans-unit id="779899a127457434de92416389106f3b75e672b1" translate="yes" xml:space="preserve">
          <source>A zero return value of &amp;amp;Time::HiRes::d_hires_stat means that Time::HiRes::stat is a no-op passthrough for CORE::stat() (and likewise for lstat), and therefore the timestamps will stay integers. The same thing will happen if the filesystem does not do subsecond timestamps, even if the &amp;amp;Time::HiRes::d_hires_stat is non-zero.</source>
          <target state="translated">＆Time :: HiRes :: d_hires_stat的零返回值表示Time :: HiRes :: stat是CORE :: stat（）的无操作通过（对于lstat同样），因此时间戳将保持整数。如果文件系统不执行亚秒级时间戳，即使＆Time :: HiRes :: d_hires_stat不为零，也会发生同样的事情。</target>
        </trans-unit>
        <trans-unit id="8e38756e4b48f666771b0184686ead868d8da345" translate="yes" xml:space="preserve">
          <source>A zero-width negative look-ahead assertion. For example &lt;code&gt;/foo(?!bar)/&lt;/code&gt; matches any occurrence of &quot;foo&quot; that isn't followed by &quot;bar&quot;. Note however that look-ahead and look-behind are NOT the same thing. You cannot use this for look-behind.</source>
          <target state="translated">零宽度否定超前声明。例如， &lt;code&gt;/foo(?!bar)/&lt;/code&gt; 匹配出现的所有&amp;ldquo; foo&amp;rdquo;，而不是&amp;ldquo; bar&amp;rdquo;。但是请注意，向前看和向后看不是同一回事。您不能将其用作后视。</target>
        </trans-unit>
        <trans-unit id="d3ff01c027bf2326d7c975449071a13cc0fdc9c3" translate="yes" xml:space="preserve">
          <source>A zero-width negative look-behind assertion. For example &lt;code&gt;/(?&amp;lt;!bar)foo/&lt;/code&gt; matches any occurrence of &quot;foo&quot; that does not follow &quot;bar&quot;. Works only for fixed-width look-behind.</source>
          <target state="translated">零宽度负向后看断言。例如， &lt;code&gt;/(?&amp;lt;!bar)foo/&lt;/code&gt; 匹配出现在&amp;ldquo; bar&amp;rdquo;之后的&amp;ldquo; foo&amp;rdquo;。仅适用于固定宽度的后向搜索。</target>
        </trans-unit>
        <trans-unit id="31c71ae629ab72f59da90b044b041a0f3f38fe68" translate="yes" xml:space="preserve">
          <source>A zero-width positive look-ahead assertion. For example, &lt;code&gt;/\w+(?=\t)/&lt;/code&gt; matches a word followed by a tab, without including the tab in &lt;code&gt;$&amp;amp;&lt;/code&gt; .</source>
          <target state="translated">零宽度正向超前断言。例如， &lt;code&gt;/\w+(?=\t)/&lt;/code&gt; 匹配一个单词，后跟一个制表符，而不在 &lt;code&gt;$&amp;amp;&lt;/code&gt; 中包括该制表符。</target>
        </trans-unit>
        <trans-unit id="65fa5c05e8082d01af830ede3afa1f43dd6607a8" translate="yes" xml:space="preserve">
          <source>A zero-width positive look-behind assertion. For example, &lt;code&gt;/(?&amp;lt;=\t)\w+/&lt;/code&gt; matches a word that follows a tab, without including the tab in &lt;code&gt;$&amp;amp;&lt;/code&gt; . Works only for fixed-width look-behind.</source>
          <target state="translated">零宽度正向后断言。例如， &lt;code&gt;/(?&amp;lt;=\t)\w+/&lt;/code&gt; 匹配选项卡后面的单词，但不包括 &lt;code&gt;$&amp;amp;&lt;/code&gt; 中的选项卡。仅适用于固定宽度的后向搜索。</target>
        </trans-unit>
        <trans-unit id="34bdd106971288a6d920c5cf05705981d574d0c4" translate="yes" xml:space="preserve">
          <source>A. DECOMPRESS</source>
          <target state="translated">A.减压</target>
        </trans-unit>
        <trans-unit id="1ff759f92b74a05e1658516dbd8457b5a3483f7c" translate="yes" xml:space="preserve">
          <source>ABBREVIATIONS</source>
          <target state="translated">ABBREVIATIONS</target>
        </trans-unit>
        <trans-unit id="673a41f0cf51b17cfeaeef5b1ad0748f98430d4f" translate="yes" xml:space="preserve">
          <source>ABOUT EXTENDING POD</source>
          <target state="translated">关于扩展POD</target>
        </trans-unit>
        <trans-unit id="dd2cb5069032eb76d119d2ed0164eb2a9e7c70ab" translate="yes" xml:space="preserve">
          <source>ABOUT LANGUAGE TAGS</source>
          <target state="translated">关于语言标签</target>
        </trans-unit>
        <trans-unit id="848db58438feb5d786eb1289cbafc6268e9d9307" translate="yes" xml:space="preserve">
          <source>ABOUT LOWERCASING</source>
          <target state="translated">关于小写字母</target>
        </trans-unit>
        <trans-unit id="0bdf7f8075cb4fb7b28aefb1a128e561b3a0c204" translate="yes" xml:space="preserve">
          <source>ABOUT UNICODE PLAINTEXT LANGUAGE TAGS</source>
          <target state="translated">关于UNICODE PLAINTEXT语言标签。</target>
        </trans-unit>
        <trans-unit id="e29c6cbd184a79deb8c1a9f477b3e3ad1f42e851" translate="yes" xml:space="preserve">
          <source>ABSTRACT</source>
          <target state="translated">ABSTRACT</target>
        </trans-unit>
        <trans-unit id="8e85cf5fbe6cfb533ae13301a76848fd25437a12" translate="yes" xml:space="preserve">
          <source>ACCESS</source>
          <target state="translated">ACCESS</target>
        </trans-unit>
        <trans-unit id="5250769dfb1b93d9576c113491830191c4db1d11" translate="yes" xml:space="preserve">
          <source>ACCESSING ZIP FILES</source>
          <target state="translated">访问ZIP文件</target>
        </trans-unit>
        <trans-unit id="fcc3d0a1b75c8feef5b7b1c653cf0ea340c392c6" translate="yes" xml:space="preserve">
          <source>ACCESSOR METHODS</source>
          <target state="translated">附件方法</target>
        </trans-unit>
        <trans-unit id="60a7c20aebd64a886444bdd90a1b11f97a4a1e06" translate="yes" xml:space="preserve">
          <source>ACCESSORS</source>
          <target state="translated">ACCESSORS</target>
        </trans-unit>
        <trans-unit id="0ba6c220aaa591706073278a9ad280fa2fd653a4" translate="yes" xml:space="preserve">
          <source>ACCURACY and PRECISION</source>
          <target state="translated">准确性和精确性</target>
        </trans-unit>
        <trans-unit id="2cdc7ae734b454aa9217c09256c5559e6d697319" translate="yes" xml:space="preserve">
          <source>ACKNOWLEDGEMENTS</source>
          <target state="translated">ACKNOWLEDGEMENTS</target>
        </trans-unit>
        <trans-unit id="923060090571fbfd68775d7a6ad521d2f148ca46" translate="yes" xml:space="preserve">
          <source>ACKNOWLEDGMENTS</source>
          <target state="translated">ACKNOWLEDGMENTS</target>
        </trans-unit>
        <trans-unit id="44d15b33e9bdfa8cf1ced5727e4a50f9110eab0b" translate="yes" xml:space="preserve">
          <source>ADDITIONAL FUNCTIONS</source>
          <target state="translated">附加功能</target>
        </trans-unit>
        <trans-unit id="377c8694e808f226461dfc561f7463499e97731b" translate="yes" xml:space="preserve">
          <source>ADDITIONAL LIBRARIES</source>
          <target state="translated">附加图书馆</target>
        </trans-unit>
        <trans-unit id="97b832ba91bb860f61c453123e346196e469e726" translate="yes" xml:space="preserve">
          <source>ADDR should be &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; unless you really know what you're doing.</source>
          <target state="translated">除非您真的知道自己在做什么，否则ADDR应该是 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55ecbd212eaf4944bfe6cc43f71cd52a01caf60b" translate="yes" xml:space="preserve">
          <source>ADDRESSES</source>
          <target state="translated">ADDRESSES</target>
        </trans-unit>
        <trans-unit id="64ec98c40972fdf68514c8da070992ffcab12ce8" translate="yes" xml:space="preserve">
          <source>ADVANCED METHODS</source>
          <target state="translated">先进的方法</target>
        </trans-unit>
        <trans-unit id="afb2b77214c93a1bf72d1a922cac35289d58c3c4" translate="yes" xml:space="preserve">
          <source>ADVISORY LOCKING</source>
          <target state="translated">建议性锁定</target>
        </trans-unit>
        <trans-unit id="97e745db372f952a45b14d78a0e017557b75da5f" translate="yes" xml:space="preserve">
          <source>AFS users</source>
          <target state="translated">AFS用户</target>
        </trans-unit>
        <trans-unit id="aedfd73052985c2f41211e623add2af653060807" translate="yes" xml:space="preserve">
          <source>AFTER</source>
          <target state="translated">AFTER</target>
        </trans-unit>
        <trans-unit id="496da957ccecd43014881eeb7de2e7be00a8b83f" translate="yes" xml:space="preserve">
          <source>AF_INET, AF_INET6, AF_UNIX, ...</source>
          <target state="translated">AF_INET,AF_INET6,AF_UNIX,...</target>
        </trans-unit>
        <trans-unit id="8270308dd6281a640520a3b86d9717dc1578cb66" translate="yes" xml:space="preserve">
          <source>AIX 4.2 and extensions using C++ with statics</source>
          <target state="translated">AIX 4.2和使用C++与静态的扩展</target>
        </trans-unit>
        <trans-unit id="cc22d23e0b7ef1b2efab2cb46a1e42c8fa854e52" translate="yes" xml:space="preserve">
          <source>AIX 5L 5.3 documentation on syslog, &lt;a href=&quot;http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm&quot;&gt;http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm&lt;/a&gt;</source>
          <target state="translated">syslog上的AIX 5L 5.3文档，&lt;a href=&quot;http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm&quot;&gt;http：//publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp？topic = / com.ibm.aix.basetechref / doc / basetrf2 / syslog.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bbc183716848102da5675f12c481c22f2bbe872f" translate="yes" xml:space="preserve">
          <source>AIX specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_Unix的AIX特定子类。</target>
        </trans-unit>
        <trans-unit id="b844fff26ef204487899d430c3a31df1b5cc17d0" translate="yes" xml:space="preserve">
          <source>AIX supports dynamically loadable objects as well as shared libraries. Shared libraries by convention end with the suffix .a, which is a bit misleading, as an archive can contain static as well as dynamic members. For Perl dynamically loaded objects we use the .so suffix also used on many other platforms.</source>
          <target state="translated">AIX支持动态加载对象以及共享库。共享库按照惯例以.a作为后缀,这有点误导,因为一个归档库既可以包含静态成员,也可以包含动态成员。对于Perl动态加载的对象,我们使用.so后缀,这在许多其他平台上也使用。</target>
        </trans-unit>
        <trans-unit id="c930119fca1aaac13c47275f88a8f54f317dcf6d" translate="yes" xml:space="preserve">
          <source>ALIASES</source>
          <target state="translated">ALIASES</target>
        </trans-unit>
        <trans-unit id="6b42874e3cd20771d93096ec5ce36307a1f2ba14" translate="yes" xml:space="preserve">
          <source>ALL</source>
          <target state="translated">ALL</target>
        </trans-unit>
        <trans-unit id="212ac4dd3c12194a505f91dc67c3c92083d6b847" translate="yes" xml:space="preserve">
          <source>ALTERNATIVES</source>
          <target state="translated">ALTERNATIVES</target>
        </trans-unit>
        <trans-unit id="a4406ec237fefa2186cbfcb898374ca2b35f123f" translate="yes" xml:space="preserve">
          <source>ANCHORS</source>
          <target state="translated">ANCHORS</target>
        </trans-unit>
        <trans-unit id="c2f934cb8cab6c1b3af0d4f2fdd824eabafb6bf4" translate="yes" xml:space="preserve">
          <source>AND</source>
          <target state="translated">AND</target>
        </trans-unit>
        <trans-unit id="f00aef29ec0d70fa98911d7d5c3619473dc02a1d" translate="yes" xml:space="preserve">
          <source>ANOTHER STEP SIDEWAYS</source>
          <target state="translated">再走一步路</target>
        </trans-unit>
        <trans-unit id="dc8b5a685a1f3dfa4a578835317ceecf19e71828" translate="yes" xml:space="preserve">
          <source>ANSI C prototypes</source>
          <target state="translated">ANSI C原型</target>
        </trans-unit>
        <trans-unit id="dfbdf15f452a4b9784443e1ff8b670a57ee46040" translate="yes" xml:space="preserve">
          <source>API CHANGES</source>
          <target state="translated">API变化</target>
        </trans-unit>
        <trans-unit id="4f15dd61e10f028874d8ba2639996e9123298e0e" translate="yes" xml:space="preserve">
          <source>API Listing originally by Dean Roehrich &amp;lt;roehrich@cray.com&amp;gt;.</source>
          <target state="translated">API列表最初由Dean Roehrich &amp;lt;roehrich@cray.com&amp;gt;提出。</target>
        </trans-unit>
        <trans-unit id="df325db8b77f500b6cdf947d62422aad373e0aea" translate="yes" xml:space="preserve">
          <source>API Methods</source>
          <target state="translated">API方法</target>
        </trans-unit>
        <trans-unit id="8454ac15101bc16638e3fcbf0a95ef8d316e2b31" translate="yes" xml:space="preserve">
          <source>API documentation corrected and extended by Peter John Acklam, &amp;lt;pjacklam@online.no&amp;gt;</source>
          <target state="translated">API文档已由Peter John Acklam更正并扩展，&amp;lt;pjacklam@online.no&amp;gt;</target>
        </trans-unit>
        <trans-unit id="277a0cf94bbf499b3b1ef2e01755b635f3035e77" translate="yes" xml:space="preserve">
          <source>API optional methods</source>
          <target state="translated">API可选方法</target>
        </trans-unit>
        <trans-unit id="9062babed18f073234a690694e7bfa973c074eed" translate="yes" xml:space="preserve">
          <source>API should be understandable by the average programmer</source>
          <target state="translated">API应该是普通程序员可以理解的。</target>
        </trans-unit>
        <trans-unit id="0dd3839d0c79b29685b54d3a4a1e4fbc6f050c94" translate="yes" xml:space="preserve">
          <source>API version</source>
          <target state="translated">API版本</target>
        </trans-unit>
        <trans-unit id="a7438834ae98ed5eab86e235ece4b52b96a7675f" translate="yes" xml:space="preserve">
          <source>API version 1</source>
          <target state="translated">API版本1</target>
        </trans-unit>
        <trans-unit id="a0960ab95be5d294c9ff103e037a981d112d54d9" translate="yes" xml:space="preserve">
          <source>API version 2</source>
          <target state="translated">API版本2</target>
        </trans-unit>
        <trans-unit id="f6db2b825c2703e26c1c6b659f77956e578c5caf" translate="yes" xml:space="preserve">
          <source>ARGS</source>
          <target state="translated">ARGS</target>
        </trans-unit>
        <trans-unit id="253fb8ce8cc421dd2ece69eec435a50b11f94cfb" translate="yes" xml:space="preserve">
          <source>ARGUMENTS</source>
          <target state="translated">ARGUMENTS</target>
        </trans-unit>
        <trans-unit id="3669288cabd0e6c21385584c21cb897733b8578f" translate="yes" xml:space="preserve">
          <source>ARGV</source>
          <target state="translated">ARGV</target>
        </trans-unit>
        <trans-unit id="58f29c4a3f70f6c5783cb6f812b7570e0f5a35fa" translate="yes" xml:space="preserve">
          <source>ARGVOUT</source>
          <target state="translated">ARGVOUT</target>
        </trans-unit>
        <trans-unit id="939f4f9b79e0d63ec8eb10a421a9e30ccdc8ba12" translate="yes" xml:space="preserve">
          <source>ARRAYS OF ARRAYS</source>
          <target state="translated">数组的数组</target>
        </trans-unit>
        <trans-unit id="a25c873f10f6ead60f25f2f80304660b76114969" translate="yes" xml:space="preserve">
          <source>ARRAYS OF HASHES</source>
          <target state="translated">排列式洗碗机</target>
        </trans-unit>
        <trans-unit id="54523fd188916df915063049c7391f98e0ecb17d" translate="yes" xml:space="preserve">
          <source>AS/400 Perl information at &lt;a href=&quot;http://as400.rochester.ibm.com/&quot;&gt;http://as400.rochester.ibm.com/&lt;/a&gt; as well as on CPAN in the</source>
          <target state="translated">&lt;a href=&quot;http://as400.rochester.ibm.com/&quot;&gt;http://as400.rochester.ibm.com/上的&lt;/a&gt; AS / 400 Perl信息，以及</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="095009cc6353c09fd2d522eaac28b52d2906738f" translate="yes" xml:space="preserve">
          <source>ASCII Rules versus Unicode Rules</source>
          <target state="translated">ASCII规则与Unicode规则</target>
        </trans-unit>
        <trans-unit id="05b06e21b242818c80ba48f1806ad24f7869b69b" translate="yes" xml:space="preserve">
          <source>ASCII is a 7 bit encoding, but bytes have 8 bits in them. The 128 extra characters have different meanings depending on the locale. Absent a locale, currently these extra characters are generally considered to be unassigned, and this has presented some problems. This has being changed starting in 5.12 so that these characters can be considered to be Latin-1 (ISO-8859-1).</source>
          <target state="translated">ASCII是7位编码,但字节中有8位。这128个额外的字符根据不同的区域设置有不同的含义。如果没有本地语言,目前这些额外的字符通常被认为是未分配的,这带来了一些问题。从5.12开始,这种情况将被改变,因此这些字符可以被认为是Latin-1(ISO-8859-1)。</target>
        </trans-unit>
        <trans-unit id="d77e7b08ca6fa993505fba8c81b3ac5f801abc6f" translate="yes" xml:space="preserve">
          <source>ASCII rules are used for the case change. The lowercase of any character outside the ASCII range is the character itself.</source>
          <target state="translated">ASCII规则用于改变大小写。ASCII范围外的任何字符的小写就是字符本身。</target>
        </trans-unit>
        <trans-unit id="ece7d85b8cf901827daa3241607fc8b13d846059" translate="yes" xml:space="preserve">
          <source>ATTRIBUTION</source>
          <target state="translated">ATTRIBUTION</target>
        </trans-unit>
        <trans-unit id="8b61f8355a2ccf4ace40fd469d2de5233617a66b" translate="yes" xml:space="preserve">
          <source>AUTHOR</source>
          <target state="translated">AUTHOR</target>
        </trans-unit>
        <trans-unit id="57dab403a72cbeaee26142a3b342afaf3f988255" translate="yes" xml:space="preserve">
          <source>AUTHOR AND COPYRIGHT</source>
          <target state="translated">作者和版权</target>
        </trans-unit>
        <trans-unit id="612f07ef18eeaf3398b36342703c907f1f498930" translate="yes" xml:space="preserve">
          <source>AUTHOR and COPYRIGHT</source>
          <target state="translated">作者和版权</target>
        </trans-unit>
        <trans-unit id="d5195f9e1e4e9d40c97901347bc70f8c519bf1be" translate="yes" xml:space="preserve">
          <source>AUTHOR, COPYRIGHT AND LICENSE</source>
          <target state="translated">作者、版权和授权许可</target>
        </trans-unit>
        <trans-unit id="41d9cfc9cdf402f68e3f8ff8a8e41c4254e5f24e" translate="yes" xml:space="preserve">
          <source>AUTHOR, COPYRIGHT, AND LICENSE</source>
          <target state="translated">作者、版权和许可权</target>
        </trans-unit>
        <trans-unit id="dad57a4c245a8007c90257aef0514c8b6a0f600c" translate="yes" xml:space="preserve">
          <source>AUTHORS</source>
          <target state="translated">AUTHORS</target>
        </trans-unit>
        <trans-unit id="10ca6d2dbfbe263ce3d2447e713540dbee649dd1" translate="yes" xml:space="preserve">
          <source>AUTHORS &amp;amp; ACKNOWLEDGEMENTS</source>
          <target state="translated">作者和致谢</target>
        </trans-unit>
        <trans-unit id="85e022793224f31daf1d3314f296447a1c347850" translate="yes" xml:space="preserve">
          <source>AUTHORS / CONTRIBUTORS</source>
          <target state="translated">作者/撰稿人</target>
        </trans-unit>
        <trans-unit id="14d07abb959cf3e3fd8f53cf02fd844e461b3f7b" translate="yes" xml:space="preserve">
          <source>AUTHORS AND CONTRIBUTORS</source>
          <target state="translated">作者和撰稿人</target>
        </trans-unit>
        <trans-unit id="a7c000e8a87845b58cc629ac11fab313f86076cc" translate="yes" xml:space="preserve">
          <source>AUTO LEXICONS</source>
          <target state="translated">AUTO LEXICONS</target>
        </trans-unit>
        <trans-unit id="ba657d4270e0ee84198dc3f12f7f53cb0c332d2f" translate="yes" xml:space="preserve">
          <source>AUTOLOAD</source>
          <target state="translated">AUTOLOAD</target>
        </trans-unit>
        <trans-unit id="43af5166b3e71bcdd670318e774158ceaf10a942" translate="yes" xml:space="preserve">
          <source>AUTOLOADER</source>
          <target state="translated">AUTOLOADER</target>
        </trans-unit>
        <trans-unit id="886a23f1067d5ffd81046b592349f27bd44a8216" translate="yes" xml:space="preserve">
          <source>AUTOLOADed Constants</source>
          <target state="translated">自动加载的常量</target>
        </trans-unit>
        <trans-unit id="68570adadeeae5fdaad94d20b4200b8cf0e0c4f0" translate="yes" xml:space="preserve">
          <source>AVAILABILITY</source>
          <target state="translated">AVAILABILITY</target>
        </trans-unit>
        <trans-unit id="9669bc4871af0ed7e9d16166bb30c227929eda52" translate="yes" xml:space="preserve">
          <source>AVAILABLE FEATURES</source>
          <target state="translated">现有功能</target>
        </trans-unit>
        <trans-unit id="302ba7dc5c280998e54c1d7ee821e9c0c27afd54" translate="yes" xml:space="preserve">
          <source>AVs and HVs are more complicated, but SVs are by far the most common variable type being thrown around. Having seen something of how we manipulate these, let's go on and look at how the op tree is constructed.</source>
          <target state="translated">AVs和HV比较复杂,但SVs是目前最常见的变量类型。在了解了一些我们如何操作这些变量之后,我们再来看看运算树是如何构造的。</target>
        </trans-unit>
        <trans-unit id="97658a3aca1866999e545fb8e0d412280826a4d3" translate="yes" xml:space="preserve">
          <source>AVs, HVs and undefined values</source>
          <target state="translated">AVs、HVs和未定义值</target>
        </trans-unit>
        <trans-unit id="1ca83b983f42527b4fed4dd004cb7ec8d4f4a6f6" translate="yes" xml:space="preserve">
          <source>Abandon the tmp in the current pad at offset po and replace with a new one.</source>
          <target state="translated">在偏移po处放弃当前pad中的tmp,换上新的tmp。</target>
        </trans-unit>
        <trans-unit id="57c67b6004d41befa99fa526f57a6625af549efe" translate="yes" xml:space="preserve">
          <source>Abbrev - create an abbreviation table from a list</source>
          <target state="translated">Abbrev-从列表中创建一个缩写表。</target>
        </trans-unit>
        <trans-unit id="953787278f84160153e00df3d74bff332f0acc7b" translate="yes" xml:space="preserve">
          <source>Abigail &amp;lt;abigail@foad.org&amp;gt;, Charles Bailey &amp;lt;bailey@newman.upenn.edu&amp;gt;, Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt;, Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;, Thomas Dorner &amp;lt;Thomas.Dorner@start.de&amp;gt;, Andy Dougherty &amp;lt;doughera@lafayette.edu&amp;gt;, Dominic Dunlop &amp;lt;domo@computer.org&amp;gt;, Neale Ferguson &amp;lt;neale@vma.tabnsw.com.au&amp;gt;, David J. Fiander &amp;lt;davidf@mks.com&amp;gt;, Paul Green &amp;lt;Paul.Green@stratus.com&amp;gt;, M.J.T. Guy &amp;lt;mjtg@cam.ac.uk&amp;gt;, Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;, Luther Huffman &amp;lt;lutherh@stratcom.com&amp;gt;, Nick Ing-Simmons &amp;lt;nick@ing-simmons.net&amp;gt;, Andreas J. K&amp;ouml;nig &amp;lt;a.koenig@mind.de&amp;gt;, Markus Laker &amp;lt;mlaker@contax.co.uk&amp;gt;, Andrew M. Langmead &amp;lt;aml@world.std.com&amp;gt;, Larry Moore &amp;lt;ljmoore@freespace.net&amp;gt;, Paul Moore &amp;lt;Paul.Moore@uk.origin-it.com&amp;gt;, Chris Nandor &amp;lt;pudge@pobox.com&amp;gt;, Matthias Neeracher &amp;lt;neeracher@mac.com&amp;gt;, Philip Newton &amp;lt;pne@cpan.org&amp;gt;, Gary Ng &amp;lt;71564.1743@CompuServe.COM&amp;gt;, Tom Phoenix &amp;lt;rootbeer@teleport.com&amp;gt;, Andr&amp;eacute; Pirard &amp;lt;A.Pirard@ulg.ac.be&amp;gt;, Peter Prymmer &amp;lt;pvhp@forte.com&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;, Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;, Paul J. Schinder &amp;lt;schinder@pobox.com&amp;gt;, Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;, Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;, Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;, John Malmberg &amp;lt;wb8tyw@qsl.net&amp;gt;</source>
          <target state="translated">阿比盖尔&amp;lt;abigail@foad.org&amp;gt;，查尔斯&amp;middot;贝利&amp;lt;bailey@newman.upenn.edu&amp;gt;，格雷厄姆&amp;middot;巴尔&amp;lt;gbarr@pobox.com&amp;gt;，汤姆&amp;middot;克里斯蒂安森&amp;lt;tchrist@perl.com&amp;gt;，尼古拉斯&amp;middot;克拉克&amp;lt;nick@ccl4.org&amp;gt; ，托马斯&amp;middot;多纳（Thomas Dorner）&amp;lt;Thomas.Dorner@start.de&amp;gt;，安迪&amp;middot;多尔蒂（Andy Dougherty）&amp;lt;doughera@lafayette.edu&amp;gt;，多米尼克&amp;middot;邓洛普（Dominic Dunlop）&amp;lt;domo@computer.org&amp;gt;，尼尔&amp;middot;弗格森（Neale Ferguson）&amp;lt;neale@vma.tabnsw.com.au&amp;gt;，大卫&amp;middot;J。 Fiander &amp;lt;davidf@mks.com&amp;gt;，Paul Green &amp;lt;Paul.Green@stratus.com&amp;gt;，MJT Guy &amp;lt;mjtg@cam.ac.uk&amp;gt;，Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;，Luther Huffman &amp;lt;lutherh @ stratcom。 com&amp;gt;，Nick Ing-Simmons &amp;lt;nick@ing-simmons.net&amp;gt;，AndreasJ.K&amp;ouml;nig&amp;lt;a.koenig@mind.de&amp;gt;，Markus Laker &amp;lt;mlaker@contax.co.uk&amp;gt;，Andrew M.Langmead &amp;lt;aml @ world.std.com&amp;gt;，拉里&amp;middot;摩尔&amp;lt;ljmoore@freespace.net&amp;gt;，保罗&amp;middot;摩尔&amp;lt;Paul.Moore@uk.origin-it.com&amp;gt;，克里斯&amp;middot;南多（Chris Nandor）&amp;lt;pudge@pobox.com&amp;gt;，马蒂亚斯&amp;middot;内拉赫（Matthias Neeracher）&amp;lt;neeracher@mac.com&amp;gt;，菲利普&amp;middot;牛顿（Philip Newton）&amp;lt;pne@cpan.org&amp;gt;，吴家瑞（Nary Ng）&amp;lt;71564.1743@CompuServe.COM&amp;gt;，汤姆&amp;middot;菲尼克斯（Tom Phoenix）&amp;lt;rootbeer@teleport.com&amp;gt;， Andr&amp;eacute;Pirard &amp;lt;A.Pirard@ulg.ac.be&amp;gt;，Peter Prymmer &amp;lt;pvhp@forte.com&amp;gt;，Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;，Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;， Paul J.Schinder &amp;lt;schinder@pobox.com&amp;gt;，Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;，Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;，Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;，John Malmberg &amp;lt;wb8tyw @ qsl。网络&amp;gt;com&amp;gt;，Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;，Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;，Paul J.Schinder &amp;lt;schinder@pobox.com&amp;gt;，Michael G Schwern &amp;lt;schwern@pobox.com &amp;gt;，Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;，Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;，John Malmberg &amp;lt;wb8tyw@qsl.net&amp;gt;com&amp;gt;，Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;，Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;，Paul J.Schinder &amp;lt;schinder@pobox.com&amp;gt;，Michael G Schwern &amp;lt;schwern@pobox.com &amp;gt;，Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;，Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;，John Malmberg &amp;lt;wb8tyw@qsl.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="272ef4d46b3c0dabd3e502b3dc11c532d79932f2" translate="yes" xml:space="preserve">
          <source>Able to serve as an &lt;b&gt;lvalue&lt;/b&gt;.</source>
          <target state="translated">能够作为&lt;b&gt;左值&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="a3f9c8141ea275b67bac5cb6c2da96e6b983db25" translate="yes" xml:space="preserve">
          <source>Abort the current data transfer.</source>
          <target state="translated">中止当前的数据传输。</target>
        </trans-unit>
        <trans-unit id="f7989aafbbb3a9f050ae7d85ebd582349680eb97" translate="yes" xml:space="preserve">
          <source>About =over...=back Regions</source>
          <target state="translated">关于...=返回地区</target>
        </trans-unit>
        <trans-unit id="5766587271d36ba046e7fb9efb21f9b7e662efb7" translate="yes" xml:space="preserve">
          <source>About Compiler Versions of Irix</source>
          <target state="translated">关于Irix的编译器版本</target>
        </trans-unit>
        <trans-unit id="bcf14899785f94972e5296a53e65daa2fad1f95c" translate="yes" xml:space="preserve">
          <source>About Data Paragraphs and &quot;=begin/=end&quot; Regions</source>
          <target state="translated">关于数据段和&quot;=begin/=end &quot;区域。</target>
        </trans-unit>
        <trans-unit id="f134fee2fd6f61ab2515d5dfb15b7bc4b2f583f5" translate="yes" xml:space="preserve">
          <source>About L&amp;lt;...&amp;gt; Codes</source>
          <target state="translated">关于L &amp;lt;...&amp;gt;代码</target>
        </trans-unit>
        <trans-unit id="027e45f66497afa47c6fd09d682b0e1e7a6cedb2" translate="yes" xml:space="preserve">
          <source>Above the optimizer section is the list of</source>
          <target state="translated">在优化器部分的上方是</target>
        </trans-unit>
        <trans-unit id="6d3fc598c606132c619a12609173fe6e49201e22" translate="yes" xml:space="preserve">
          <source>Absolute referencing</source>
          <target state="translated">绝对引用</target>
        </trans-unit>
        <trans-unit id="d79da395b5d7a09c6439a5f2660d8c568186ab7e" translate="yes" xml:space="preserve">
          <source>Abstract</source>
          <target state="translated">Abstract</target>
        </trans-unit>
        <trans-unit id="fd1c863c80384ee83334b3b3ad71ce0af37947bc" translate="yes" xml:space="preserve">
          <source>Abstract base class for harness output delegate</source>
          <target state="translated">harness输出委托的抽象基类</target>
        </trans-unit>
        <trans-unit id="becdf5f42e43b7273698e72d5f4213f7c0a68cc4" translate="yes" xml:space="preserve">
          <source>Accepted before Perl 5.20.0. The Socket library is now primarily maintained on CPAN, rather than in the perl core.</source>
          <target state="translated">在Perl 5.20.0之前接受。Socket 库现在主要在 CPAN 上维护,而不是在 perl 核心中。</target>
        </trans-unit>
        <trans-unit id="4dd1bc893614ac8f9bec65c912481578e5103c07" translate="yes" xml:space="preserve">
          <source>Accepted features</source>
          <target state="translated">接受的特点</target>
        </trans-unit>
        <trans-unit id="56a28ff20a71c3e8ac9c196f290eef557747b624" translate="yes" xml:space="preserve">
          <source>Accepted in Perl 5.20.0</source>
          <target state="translated">在Perl 5.20.0中被接受</target>
        </trans-unit>
        <trans-unit id="1576bf43d8822dbdd55b1f1ab39311d28be28187" translate="yes" xml:space="preserve">
          <source>Accepted in Perl 5.22.0</source>
          <target state="translated">在Perl 5.22.0中被接受</target>
        </trans-unit>
        <trans-unit id="675dec52d56b1b7035fe24d4e72f28a346a787af" translate="yes" xml:space="preserve">
          <source>Accepted in Perl 5.8.0</source>
          <target state="translated">在Perl 5.8.0中被接受</target>
        </trans-unit>
        <trans-unit id="90c2a9a8eb85f455955167b397c89e9d89539a74" translate="yes" xml:space="preserve">
          <source>Accepted in Perl 5.8.1</source>
          <target state="translated">在Perl 5.8.1中被接受</target>
        </trans-unit>
        <trans-unit id="ad21c5596b645ba9637173674a45823b09fa37af" translate="yes" xml:space="preserve">
          <source>Accepts a hashref with the following key/value pairs:</source>
          <target state="translated">接受以下键/值对的哈希夫。</target>
        </trans-unit>
        <trans-unit id="3cab88715458f5eb0aafb0a8b41682d6e4711e8a" translate="yes" xml:space="preserve">
          <source>Accepts a scalar value or array ref of scalar values indicating which paths to allowed libraries should be included if Perl tests are executed. Naturally, this only makes sense in the context of tests written in Perl.</source>
          <target state="translated">接受一个标量值或标量值的数组 ref,表示在执行 Perl 测试时,应该包含哪些允许的库的路径。当然,这只有在用 Perl 写的测试中才有意义。</target>
        </trans-unit>
        <trans-unit id="fd709042dcc776319515489b90b122d3454c0825" translate="yes" xml:space="preserve">
          <source>Accepts a scalar value or array ref of scalar values indicating which switches should be included if Perl tests are executed. Naturally, this only makes sense in the context of tests written in Perl.</source>
          <target state="translated">接受一个标量值或标量值的数组 ref,表示在执行 Perl 测试时应该包含哪些开关。当然,这只有在用 Perl 写的测试中才有意义。</target>
        </trans-unit>
        <trans-unit id="410a58b5c50383c8e3e3efac6ca6d02323a2e404" translate="yes" xml:space="preserve">
          <source>Accepts a version object and returns the normalized floating point representation. Call like:</source>
          <target state="translated">接受一个版本对象并返回归一化的浮点表示。调用像。</target>
        </trans-unit>
        <trans-unit id="6925cd73aca9469cc1ca4115afb36b07a4f628be" translate="yes" xml:space="preserve">
          <source>Accepts a version object and returns the normalized string representation. Call like:</source>
          <target state="translated">接受一个版本对象并返回规范化的字符串表示。调用喜欢。</target>
        </trans-unit>
        <trans-unit id="2dc796d2ce674a48fb65979328ffb56b5f53f1a2" translate="yes" xml:space="preserve">
          <source>Accepts an array of &lt;code&gt;@tests&lt;/code&gt; to be run. This should generally be the names of test files, but this is not required. Each element in &lt;code&gt;@tests&lt;/code&gt; will be passed to &lt;code&gt;TAP::Parser::new()&lt;/code&gt; as a &lt;code&gt;source&lt;/code&gt; . See &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; for more information.</source>
          <target state="translated">接受要运行的 &lt;code&gt;@tests&lt;/code&gt; 数组。通常，这应该是测试文件的名称，但这不是必需的。 &lt;code&gt;@tests&lt;/code&gt; 中的每个元素都将作为 &lt;code&gt;source&lt;/code&gt; 传递给 &lt;code&gt;TAP::Parser::new()&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2eb4b3520f8d8fe3fca980121310995272cd8962" translate="yes" xml:space="preserve">
          <source>Accepts an incoming socket connect, just as accept(2) does. Returns the packed address if it succeeded, false otherwise. See the example in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">就像accept（2）一样，接受传入的套接字连接。如果成功，则返回打包的地址，否则返回false。请参阅&lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的套接字：客户端/服务器通信中的示例。</target>
        </trans-unit>
        <trans-unit id="9fa11f18dc906995a6c93c465d60382e345c0a77" translate="yes" xml:space="preserve">
          <source>Accepts an incoming socket connect, just as accept(2) does. Returns the packed address if it succeeded, false otherwise. See the example in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">就像accept（2）一样，接受传入的套接字连接。如果成功，则返回打包的地址，否则返回false。请参阅&lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的套接字：客户端/服务器通信中的示例。</target>
        </trans-unit>
        <trans-unit id="37a976454ef0a6eae01758cd57c59bf29e52a50c" translate="yes" xml:space="preserve">
          <source>Accepts targets for &lt;code&gt;=begin/=for/=end&lt;/code&gt; sections of the POD.</source>
          <target state="translated">接受POD的 &lt;code&gt;=begin/=for/=end&lt;/code&gt; 部分的目标。</target>
        </trans-unit>
        <trans-unit id="cede5a1af37a1d62c15ab2a9566e9d886f5d7670" translate="yes" xml:space="preserve">
          <source>Accepts targets for &lt;code&gt;=begin/=for/=end&lt;/code&gt; sections that should be parsed as POD. For details, see &lt;a href=&quot;../perlpodspec#About-Data-Paragraphs&quot;&gt;About Data Paragraphs in perlpodspec&lt;/a&gt;.</source>
          <target state="translated">接受 &lt;code&gt;=begin/=for/=end&lt;/code&gt; 部分的目标，这些目标应解析为POD。有关详细信息，请参见&lt;a href=&quot;../perlpodspec#About-Data-Paragraphs&quot;&gt;perlpodspec中的关于数据段落&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e56694c4d8d029e1bdf7a642cc8826a85758929" translate="yes" xml:space="preserve">
          <source>Access Perl configuration information</source>
          <target state="translated">访问Perl配置信息</target>
        </trans-unit>
        <trans-unit id="8347e5dd48478a10f6aa983449d4b21d1a1af03b" translate="yes" xml:space="preserve">
          <source>Access and Printing</source>
          <target state="translated">访问和打印</target>
        </trans-unit>
        <trans-unit id="6e5e899f8f49475c30613c0d5e03d1268e31be2c" translate="yes" xml:space="preserve">
          <source>Access and Printing of a HASH OF ARRAYS</source>
          <target state="translated">获取和打印 &quot;哈希数组&quot;。</target>
        </trans-unit>
        <trans-unit id="0a3d910a71354dc1a13d0c6e24e7384a561b0108" translate="yes" xml:space="preserve">
          <source>Access and Printing of a HASH OF HASHES</source>
          <target state="translated">获取和打印一个HASH OF HASHES的文件</target>
        </trans-unit>
        <trans-unit id="7eae78c7526db834fa9958c243fe41a5cb62ea03" translate="yes" xml:space="preserve">
          <source>Access and Printing of an ARRAY OF ARRAYS</source>
          <target state="translated">阵列的访问和打印。</target>
        </trans-unit>
        <trans-unit id="5c93728a9e35642c958c51c0f97be500a59df202" translate="yes" xml:space="preserve">
          <source>Access and Printing of an ARRAY OF HASHES</source>
          <target state="translated">获取和打印数组散列的数据</target>
        </trans-unit>
        <trans-unit id="f42ea96011d2554db1787fd6d4c92a4571864cb4" translate="yes" xml:space="preserve">
          <source>Access methods correspond to the underlying C macros for field access, usually with the leading &quot;class indication&quot; prefix removed (Sv, Av, Hv, ...). The leading prefix is only left in cases where its removal would cause a clash in method name. For example, &lt;code&gt;GvREFCNT&lt;/code&gt; stays as-is since its abbreviation would clash with the &quot;superclass&quot; method &lt;code&gt;REFCNT&lt;/code&gt; (corresponding to the C function &lt;code&gt;SvREFCNT&lt;/code&gt; ).</source>
          <target state="translated">访问方法与用于现场访问的基础C宏相对应，通常删除了开头的&amp;ldquo;类指示&amp;rdquo;前缀（Sv，Av，Hv等）。仅在删除前导前缀会导致方法名称冲突的情况下才保留前导前缀。例如， &lt;code&gt;GvREFCNT&lt;/code&gt; 保持原样，因为它的缩写将与&amp;ldquo;超类&amp;rdquo;方法 &lt;code&gt;REFCNT&lt;/code&gt; （对应于C函数 &lt;code&gt;SvREFCNT&lt;/code&gt; ）冲突。</target>
        </trans-unit>
        <trans-unit id="add7e6bb00f6c276fc0702f5d9311fd702f4d0cd" translate="yes" xml:space="preserve">
          <source>Access methods correspond to the underlying C structure field names, with the leading &quot;class indication&quot; prefix (&lt;code&gt;&quot;op_&quot;&lt;/code&gt; ) removed.</source>
          <target state="translated">访问方法与基础C结构字段名称相对应，其中删除了 &lt;code&gt;&quot;op_&quot;&lt;/code&gt; 类指示&amp;rdquo;前缀（&amp;ldquo; op_&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="9396a41f14cddbeb41d4b7aa1b84d15e3d72d6c2" translate="yes" xml:space="preserve">
          <source>Access permissions are mapped onto VOS access-control list changes. (VOS)</source>
          <target state="translated">访问权限映射到VOS访问控制列表的变化。(VOS)</target>
        </trans-unit>
        <trans-unit id="cf06121dd11c83b8ba81397ecad6cc2b95e65336" translate="yes" xml:space="preserve">
          <source>Access the SV at offset po in the saved current pad in the given context block structure (can be used as an lvalue).</source>
          <target state="translated">在给定的上下文块结构中,访问保存的当前垫中偏移量po的SV(可以作为l值使用)。</target>
        </trans-unit>
        <trans-unit id="2cb44963f6bed203bb471252102ea353cd9644e0" translate="yes" xml:space="preserve">
          <source>Access the lines of a disk file via a Perl array</source>
          <target state="translated">通过Perl数组访问磁盘文件的行数。</target>
        </trans-unit>
        <trans-unit id="dfa61e115e0e8ce23ca07250a4a3499d896cdbc1" translate="yes" xml:space="preserve">
          <source>Access to Unicode character names and named character sequences; also define character names</source>
          <target state="translated">访问Unicode字符名和命名的字符序列;也可以定义字符名。</target>
        </trans-unit>
        <trans-unit id="3f2a46103156b0b5a62f34c4352c1666092f35bc" translate="yes" xml:space="preserve">
          <source>Access to lexicals that change over time--like those in the &lt;code&gt;for&lt;/code&gt; loop above, basically aliases to elements from the surrounding lexical scopes-- only works with anonymous subs, not with named subroutines. Generally said, named subroutines do not nest properly and should only be declared in the main package scope.</source>
          <target state="translated">可以访问随时间变化的词汇（例如上面的 &lt;code&gt;for&lt;/code&gt; 循环中的词汇，基本上是周围词汇范围中元素的别名），仅适用于匿名子，而不适用于命名子例程。一般说来，命名子例程不能正确嵌套，只能在主程序包范围内声明。</target>
        </trans-unit>
        <trans-unit id="7bc448fbe13d49ff8ac45ad2ec5aee25fed2364d" translate="yes" xml:space="preserve">
          <source>Accessing .tar.Z files</source>
          <target state="translated">访问.tar.Z文件</target>
        </trans-unit>
        <trans-unit id="c5656ffc833d5bac0703673d7cf0135c7d41a0d7" translate="yes" xml:space="preserve">
          <source>Accessing Formatting Internals</source>
          <target state="translated">访问格式化内部</target>
        </trans-unit>
        <trans-unit id="1370d87d951a33ab05354cde2d7a32967a2dbeb2" translate="yes" xml:space="preserve">
          <source>Accessing documentation</source>
          <target state="translated">访问文件</target>
        </trans-unit>
        <trans-unit id="e54a40f7d6dbbb802431fdba39190e9b3cbe3ecd" translate="yes" xml:space="preserve">
          <source>Accessing socket options</source>
          <target state="translated">访问插座选项</target>
        </trans-unit>
        <trans-unit id="ee8cacdba63cbccd984c19db609590e2c60f68e6" translate="yes" xml:space="preserve">
          <source>Accessor functions are available for all existing object hash keys and should be used instead of directly accessing the internal hash keys. The reason for this is that Math::BigInt itself has a pluggable interface which permits it to support different storage methods.</source>
          <target state="translated">Accessor函数可用于所有现有的对象哈希键,应该使用该函数而不是直接访问内部哈希键。原因是 Math::BigInt 本身有一个可插拔的接口,允许它支持不同的存储方法。</target>
        </trans-unit>
        <trans-unit id="f5b0e226ed894764db92e76b6c1f1203c0b805bb" translate="yes" xml:space="preserve">
          <source>Accessors</source>
          <target state="translated">Accessors</target>
        </trans-unit>
        <trans-unit id="4bc2c6535b52b04314dc544d8a82eac93deb00cf" translate="yes" xml:space="preserve">
          <source>Accuracy A</source>
          <target state="translated">准确度A</target>
        </trans-unit>
        <trans-unit id="938afbd35a75ae9b5871a66f02d0250f1479aaac" translate="yes" xml:space="preserve">
          <source>Accuracy vs. Precision</source>
          <target state="translated">精度与精度</target>
        </trans-unit>
        <trans-unit id="3e804ac1bc11e330fa5eacd1be133ab843f79bee" translate="yes" xml:space="preserve">
          <source>Accustomed &lt;b&gt;awk&lt;/b&gt; users should take special note of the following:</source>
          <target state="translated">习惯的&lt;b&gt;awk&lt;/b&gt;用户应特别注意以下几点：</target>
        </trans-unit>
        <trans-unit id="b0ebcfe59f276beb7f6238d812ac61ce48d3d9c0" translate="yes" xml:space="preserve">
          <source>Acknowledgements</source>
          <target state="translated">Acknowledgements</target>
        </trans-unit>
        <trans-unit id="5d9540ff93a75d47409d6a0aa37491da117ecdf8" translate="yes" xml:space="preserve">
          <source>Acknowledgments</source>
          <target state="translated">Acknowledgments</target>
        </trans-unit>
        <trans-unit id="708327daa641b57f7797d675f864c6465f65ebf5" translate="yes" xml:space="preserve">
          <source>Acorn RISC OS</source>
          <target state="translated">Acorn RISC OS</target>
        </trans-unit>
        <trans-unit id="8661bdb9b88159cdbca0d1b472228de45e5e9630" translate="yes" xml:space="preserve">
          <source>Actions in current file (keys are line numbers). The values are strings that have the sprintf(3) format &lt;code&gt;(&quot;%s\000%s&quot;, breakcondition, actioncode)&lt;/code&gt; .</source>
          <target state="translated">当前文件中的操作（键是行号）。这些值是具有sprintf（3）格式的字符串 &lt;code&gt;(&quot;%s\000%s&quot;, breakcondition, actioncode)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74456291abea501ae7538be3d3218d24479cf1b8" translate="yes" xml:space="preserve">
          <source>Actions, watch variables, stack traces etc.: on the TODO list.</source>
          <target state="translated">动作、观察变量、堆栈痕迹等:在TODO列表中。</target>
        </trans-unit>
        <trans-unit id="0e67e479302a0fbdd5f8f5323bb053fb5c4640b0" translate="yes" xml:space="preserve">
          <source>ActiveState's cross-platform (as of October 2004, that's Windows, Linux, and Solaris), multi-language IDE has Perl support, including a regular expression debugger and remote debugging.</source>
          <target state="translated">ActiveState的跨平台(截至2004年10月,即Windows、Linux和Solaris)、多语言IDE支持Perl,包括正则表达式调试器和远程调试。</target>
        </trans-unit>
        <trans-unit id="3c54dc62dfe34bf8e3127c0ce1e38a91208c3d94" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;FB_PERLQQ&lt;/code&gt; but U+</source>
          <target state="translated">行为类似于 &lt;code&gt;FB_PERLQQ&lt;/code&gt; 但U +</target>
        </trans-unit>
        <trans-unit id="548322587aa8642fc346684844907ab3ffec74e4" translate="yes" xml:space="preserve">
          <source>Actual math is done by using the class defined with &lt;code&gt;with =&amp;gt; Class;&lt;/code&gt; (which defaults to BigInts) to represent the mantissa and exponent.</source>
          <target state="translated">通过使用 &lt;code&gt;with =&amp;gt; Class;&lt;/code&gt; 定义的类来完成实际的数学运算；（默认为BigInts）表示尾数和指数。</target>
        </trans-unit>
        <trans-unit id="defa153aecf01309cb026d878c1991031baa4a07" translate="yes" xml:space="preserve">
          <source>Actually &lt;code&gt;Term::ReadLine&lt;/code&gt; can use some other package, that will support a richer set of commands.</source>
          <target state="translated">实际上 &lt;code&gt;Term::ReadLine&lt;/code&gt; 可以使用其他一些程序包，该程序包将支持更丰富的命令集。</target>
        </trans-unit>
        <trans-unit id="3803c01d8a976c5bf1f723681cc4bf39bad12043" translate="yes" xml:space="preserve">
          <source>Actually Perl will not</source>
          <target state="translated">其实Perl不会</target>
        </trans-unit>
        <trans-unit id="795eded018f6ab011486134b18f32e5ab2a7c100" translate="yes" xml:space="preserve">
          <source>Actually performs the output check testing the tests, comparing the data (with &lt;code&gt;eq&lt;/code&gt; ) that we have captured from &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; against what was declared with &lt;code&gt;test_out&lt;/code&gt; and &lt;code&gt;test_err&lt;/code&gt; .</source>
          <target state="translated">实际执行输出检查以测试测试，将我们从&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;捕获的数据（带有 &lt;code&gt;eq&lt;/code&gt; ）与用 &lt;code&gt;test_out&lt;/code&gt; 和 &lt;code&gt;test_err&lt;/code&gt; 声明的内容进行比较。</target>
        </trans-unit>
        <trans-unit id="5e55c0ee05ca269c1127b8a0393a10c58d229a08" translate="yes" xml:space="preserve">
          <source>Actually, on Mac OS, the &lt;code&gt;getcwd()&lt;/code&gt; , &lt;code&gt;fastgetcwd()&lt;/code&gt; and &lt;code&gt;fastcwd()&lt;/code&gt; functions are all aliases for the &lt;code&gt;cwd()&lt;/code&gt; function, which, on Mac OS, calls `pwd`. Likewise, the &lt;code&gt;abs_path()&lt;/code&gt; function is an alias for &lt;code&gt;fast_abs_path()&lt;/code&gt; .</source>
          <target state="translated">实际上，在Mac OS上， &lt;code&gt;getcwd()&lt;/code&gt; ， &lt;code&gt;fastgetcwd()&lt;/code&gt; 和 &lt;code&gt;fastcwd()&lt;/code&gt; 函数都是 &lt;code&gt;cwd()&lt;/code&gt; 函数的别名，在Mac OS上，它们称为`pwd`。同样地， &lt;code&gt;abs_path()&lt;/code&gt; 函数是一个别名 &lt;code&gt;fast_abs_path()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db3073222c40a74ba3591ee6ba65b3b3cd91207d" translate="yes" xml:space="preserve">
          <source>Actually, the log output of</source>
          <target state="translated">实际上,日志输出的</target>
        </trans-unit>
        <trans-unit id="af7244e5a9d564e8f0d5e7e9d10e38f4ccd63f70" translate="yes" xml:space="preserve">
          <source>Actually, they don't. All C operators that Perl copies have the same precedence in Perl as they do in C. The problem is with operators that C doesn't have, especially functions that give a list context to everything on their right, eg. print, chmod, exec, and so on. Such functions are called &quot;list operators&quot; and appear as such in the precedence table in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">实际上，他们没有。Perl复制的所有C运算符在Perl中的优先级与在C中的优先级相同。问题在于C所没有的运算符，尤其是为右侧所有内容提供列表上下文的函数。打印，chmod，执行，等等。这些函数称为&amp;ldquo;列表运算符&amp;rdquo;，并在&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;的优先级表中显示。</target>
        </trans-unit>
        <trans-unit id="07d8d521acda78914bf8936bc58119c26500077c" translate="yes" xml:space="preserve">
          <source>Actually, this was generated by a particular set of options. You can control the formatting of each column, whether you prefer wide or fat, hex or decimal, leading zeroes or whatever.</source>
          <target state="translated">其实,这是由一组特殊的选项生成的。你可以控制每一列的格式,是喜欢宽的还是胖的,是喜欢十六进制还是十进制,是喜欢前导零还是什么。</target>
        </trans-unit>
        <trans-unit id="860c250cdfa0ae37812255641a707082591aa037" translate="yes" xml:space="preserve">
          <source>Adam Kennedy &amp;lt;adamk@cpan.org&amp;gt;</source>
          <target state="translated">亚当&amp;middot;肯尼迪&amp;lt;adamk@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1a5c118dabaa69a69c89ab79443c5334f9b230a2" translate="yes" xml:space="preserve">
          <source>Adam Kennedy wrote &lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt; which provided the template and many of the YAML matching regular expressions for this module.</source>
          <target state="translated">亚当&amp;middot;肯尼迪（Adam Kennedy）编写了&lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML :: Tiny&lt;/a&gt;，它为该模块提供了模板以及许多与YAML匹配的正则表达式。</target>
        </trans-unit>
        <trans-unit id="bac28a1890b03ac016be9f9de8d1c17394eeee83" translate="yes" xml:space="preserve">
          <source>Add '#line' declarations to the output based on the line and file locations of the original code.</source>
          <target state="translated">根据原代码的行和文件位置,在输出中加入'#行'声明。</target>
        </trans-unit>
        <trans-unit id="c4e7cfdfcf41d796fe22ef22535d39bf89e10e73" translate="yes" xml:space="preserve">
          <source>Add (if argument specified) and retrieve the hyperlinks (as defined by &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; ) of the current POD. They consist of a 2-item array: line number and &lt;code&gt;Pod::Hyperlink&lt;/code&gt; object.</source>
          <target state="translated">添加（如果指定了参数）并检索当前POD 的超链接（由 &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; 定义）。它们由2个项目组成：行号和 &lt;code&gt;Pod::Hyperlink&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="593bc3c347e611284226398e8eb5446a2cdf167c" translate="yes" xml:space="preserve">
          <source>Add (if argument specified) and retrieve the index entries (as defined by &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ) of the current POD. They consist of plain text, each piece of whitespace is collapsed to a single blank.</source>
          <target state="translated">添加（如果指定了参数）并检索当前POD 的索引条目（由 &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; 定义）。它们由纯文本组成，每个空格都折叠为一个空白。</target>
        </trans-unit>
        <trans-unit id="7205abf0d37c1a800710d7689075b8b7e0097f10" translate="yes" xml:space="preserve">
          <source>Add (if argument specified) and retrieve the nodes (as defined by &lt;code&gt;=headX&lt;/code&gt; and &lt;code&gt;=item&lt;/code&gt; ) of the current POD. The nodes are returned in the order of their occurrence. They consist of plain text, each piece of whitespace is collapsed to a single blank.</source>
          <target state="translated">添加（如果指定了参数）并检索当前POD 的节点（由 &lt;code&gt;=headX&lt;/code&gt; 和 &lt;code&gt;=item&lt;/code&gt; 定义）。节点按其出现的顺序返回。它们由纯文本组成，每个空格都折叠为一个空白。</target>
        </trans-unit>
        <trans-unit id="874122d1d027ce488479a1cec7aca152094478e4" translate="yes" xml:space="preserve">
          <source>Add .USESHELL target for dmake.</source>
          <target state="translated">为dmake添加.USESHELL目标。</target>
        </trans-unit>
        <trans-unit id="d7fd295b806f9c0832ab6e0fa24fc58d699dd9d2" translate="yes" xml:space="preserve">
          <source>Add .err files corresponding to each .c file.</source>
          <target state="translated">为每个.c文件添加对应的.err文件。</target>
        </trans-unit>
        <trans-unit id="c4281d681d2b8d4904dd68ad15e4dae704a1bf89" translate="yes" xml:space="preserve">
          <source>Add Collate Transform magic to an SV if it doesn't already have it. If the flags contain SV_GMAGIC, it handles get-magic.</source>
          <target state="translated">如果SV中还没有 Collate Transform 魔法,则将其添加到SV中。如果flag中包含SV_GMAGIC,它就会处理get-magic。</target>
        </trans-unit>
        <trans-unit id="047c96ad9c325d237f1a6a46bb8af3410dff2f9a" translate="yes" xml:space="preserve">
          <source>Add MAXLINELENGTH for dmake before all the constants are output.</source>
          <target state="translated">在输出所有常量之前,为dmake添加MAXLINELENGTH。</target>
        </trans-unit>
        <trans-unit id="94f0a7f38a5195aa6f33946dfa8058f9d2a857a9" translate="yes" xml:space="preserve">
          <source>Add MM_Unix_VERSION.</source>
          <target state="translated">增加MM_Unix_VERSION。</target>
        </trans-unit>
        <trans-unit id="eca289eb94f4122a1cb7f5b2bdff3d6769040fa8" translate="yes" xml:space="preserve">
          <source>Add MM_Win32_VERSION.</source>
          <target state="translated">增加 MM_Win32_VERSION。</target>
        </trans-unit>
        <trans-unit id="8460c3bd39da428c04164ab6f8557a6dee2cb9dc" translate="yes" xml:space="preserve">
          <source>Add Netware macros initialized above to the Makefile.</source>
          <target state="translated">将上面初始化的Netware宏添加到Makefile中。</target>
        </trans-unit>
        <trans-unit id="b10d0c59d7d5f8f07519cfec5e7d10053270677d" translate="yes" xml:space="preserve">
          <source>Add Netware macros.</source>
          <target state="translated">添加网件宏。</target>
        </trans-unit>
        <trans-unit id="7a597e48edd2e108c64afde5e11638f77279428f" translate="yes" xml:space="preserve">
          <source>Add PERL_VMS, MM_VMS_REVISION and MM_VMS_VERSION.</source>
          <target state="translated">增加PERL_VMS、MM_VMS_REVISION和MM_VMS_VERSION。</target>
        </trans-unit>
        <trans-unit id="fb8b21b933335774c30773ac556f87eff4a5d7e6" translate="yes" xml:space="preserve">
          <source>Add a TAP::Parser to the multiplexer. &lt;code&gt;$stash&lt;/code&gt; is an optional opaque reference that will be returned from &lt;code&gt;&lt;a href=&quot;../../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; along with the parser and the next result.</source>
          <target state="translated">将TAP :: Parser添加到多路复用器。 &lt;code&gt;$stash&lt;/code&gt; 是一个可选的不透明引用，将从 &lt;code&gt;&lt;a href=&quot;../../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 连同解析器和下一个结果一起返回。</target>
        </trans-unit>
        <trans-unit id="9047e2284dc63577e7faf2c89a8809b765789014" translate="yes" xml:space="preserve">
          <source>Add a filter to filter stack for the database, &lt;code&gt;$db&lt;/code&gt; . The three formats vary only in whether they apply to the DBM key, the DBM value or both.</source>
          <target state="translated">添加一个过滤器以过滤数据库 &lt;code&gt;$db&lt;/code&gt; 堆栈。这三种格式仅在它们适用于DBM密钥，DBM值或同时适用于两者方面有所不同。</target>
        </trans-unit>
        <trans-unit id="8ccc393bac52be3d964bfe9d752d1239af48b643" translate="yes" xml:space="preserve">
          <source>Add a global watch-expression. Whenever a watched global changes the debugger will stop and display the old and new values.</source>
          <target state="translated">增加一个全局监视表达式。每当一个被监视的全局变化时,调试器将停止并显示新旧值。</target>
        </trans-unit>
        <trans-unit id="53d906e02ac64f82dea46944febfd026f128fa47" translate="yes" xml:space="preserve">
          <source>Add a new item to the cache. Without arguments, this method returns a list of all cache elements.</source>
          <target state="translated">添加一个新的项目到缓存中。在没有参数的情况下,本方法返回所有缓存元素的列表。</target>
        </trans-unit>
        <trans-unit id="a7863f951963cec6a01e64fc9352ec7f1fe9c51d" translate="yes" xml:space="preserve">
          <source>Add a node (or a list of nodes) to the document's node list. Note that the order is kept, i.e. start with the first node and end with the last. If no argument is given, the current list of nodes is returned in the same order the nodes have been added. A node can be any scalar, but usually is a pair of node string and unique id for the &lt;code&gt;find_node&lt;/code&gt; method to work correctly.</source>
          <target state="translated">将一个节点（或节点列表）添加到文档的节点列表中。注意，顺序保持不变，即从第一个节点开始，最后一个节点结束。如果未提供任何参数，则以添加节点的相同顺序返回当前节点列表。一个节点可以是任何标量，但通常是一对节点字符串和唯一ID，以使 &lt;code&gt;find_node&lt;/code&gt; 方法正常工作。</target>
        </trans-unit>
        <trans-unit id="db481968c59a6adf87aa66b0a382f55c4cfeb499" translate="yes" xml:space="preserve">
          <source>Add a pretty-printer method to the module</source>
          <target state="translated">在模块中增加一个pretty-printer方法。</target>
        </trans-unit>
        <trans-unit id="b48e494719a297be81c5a3a9a30374bc318e93d9" translate="yes" xml:space="preserve">
          <source>Add a signal to a SigSet object.</source>
          <target state="translated">向SigSet对象添加信号。</target>
        </trans-unit>
        <trans-unit id="70b454679f6454970d507782ded710647bf0cf50" translate="yes" xml:space="preserve">
          <source>Add additional meta tags here, or blocks of inline CSS or JavaScript (wrapped in the appropriate tags).</source>
          <target state="translated">在这里添加额外的元标签,或内联CSS或JavaScript块(用适当的标签包装)。</target>
        </trans-unit>
        <trans-unit id="97aac284feaa85ca8cb91bcc63adaf65d2ec487a" translate="yes" xml:space="preserve">
          <source>Add an action (Perl command) to happen before every debugger prompt. A multi-line command may be entered by backwhacking the newlines.</source>
          <target state="translated">在每个调试器提示符前添加一个动作(Perl命令)。可以通过反击换行符来输入多行命令。</target>
        </trans-unit>
        <trans-unit id="8abdf94b4d37de8dda8c5f5f2c3f6875f8d6cc2b" translate="yes" xml:space="preserve">
          <source>Add an action (debugger command) to happen before every debugger prompt. A multi-line command may be entered, if you can guess how: see above.</source>
          <target state="translated">在每个调试器提示符前添加一个动作(调试器命令)来发生。可以输入一个多行命令,如果你能猜到如何输入:见上文。</target>
        </trans-unit>
        <trans-unit id="f54d96a7a4eeff516086a73ed0f2969f141d74af" translate="yes" xml:space="preserve">
          <source>Add an index entry (or a list of them) to the document's index list. Note that the order is kept, i.e. start with the first node and end with the last. If no argument is given, the current list of index entries is returned in the same order the entries have been added. An index entry can be any scalar, but usually is a pair of string and unique id.</source>
          <target state="translated">在文档的索引列表中添加一个索引条目(或它们的列表)。需要注意的是,顺序是保持的,即从第一个节点开始,最后一个节点结束。如果没有给定参数,当前索引条目列表将按照条目被添加的顺序返回。一个索引条目可以是任何标量,但通常是一对字符串和唯一的id。</target>
        </trans-unit>
        <trans-unit id="590b7a309d0f6d30b6eb1e4e5ab86b934b9e4cae" translate="yes" xml:space="preserve">
          <source>Add blib/* directories to @INC</source>
          <target state="translated">将blib/*目录添加到@INC中。</target>
        </trans-unit>
        <trans-unit id="169a520f5b682ca9f865299c14fd2b5069cb099b" translate="yes" xml:space="preserve">
          <source>Add comments to the code explaining what you are testing for.</source>
          <target state="translated">在代码中添加注释,解释你要测试的内容。</target>
        </trans-unit>
        <trans-unit id="de73e94e79dc3842d720fa32f69c99c36f54b7ec" translate="yes" xml:space="preserve">
          <source>Add data to hash when needed</source>
          <target state="translated">需要时将数据添加到哈希值</target>
        </trans-unit>
        <trans-unit id="72d8179b381afab6c39843333e65697de042456c" translate="yes" xml:space="preserve">
          <source>Add the following to the end of Mytest.xs:</source>
          <target state="translated">在Mytest.xs的末尾添加以下内容。</target>
        </trans-unit>
        <trans-unit id="9f9a937939c6d51d4a74436ba1cd4f9a4a86f81c" translate="yes" xml:space="preserve">
          <source>Add the list of handles to the &lt;code&gt;IO::Select&lt;/code&gt; object. It is these values that will be returned when an event occurs. &lt;code&gt;IO::Select&lt;/code&gt; keeps these values in a cache which is indexed by the &lt;code&gt;&lt;a href=&quot;../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; of the handle, so if more than one handle with the same &lt;code&gt;&lt;a href=&quot;../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; is specified then only the last one is cached.</source>
          <target state="translated">将句柄列表添加到 &lt;code&gt;IO::Select&lt;/code&gt; 对象。事件发生时将返回这些值。 &lt;code&gt;IO::Select&lt;/code&gt; 将这些值 &lt;code&gt;&lt;a href=&quot;../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 在由句柄的文件编号索引的缓存中，因此，如果指定了多个具有相同 &lt;code&gt;&lt;a href=&quot;../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 句柄，则仅缓存最后一个。</target>
        </trans-unit>
        <trans-unit id="19f0b9a66897495c95aa10ee537c78ed856fd477" translate="yes" xml:space="preserve">
          <source>Add to your standard heading the following line:</source>
          <target state="translated">在您的标准标题下添加以下一行:</target>
        </trans-unit>
        <trans-unit id="08fc6af7d08fe5cff7ab3490908c8640f386f6f4" translate="yes" xml:space="preserve">
          <source>AddSubtract</source>
          <target state="translated">AddSubtract</target>
        </trans-unit>
        <trans-unit id="0a13f7aff584c83ebd1f9e84aae7b2d05d441e1f" translate="yes" xml:space="preserve">
          <source>Added &lt;code&gt;gztell&lt;/code&gt; .</source>
          <target state="translated">添加了 &lt;code&gt;gztell&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1095a22478b4b66c2ae56250f944a8bfc247cdff" translate="yes" xml:space="preserve">
          <source>Added in perl 5.18.0, this flag indicates that a regular expression might perform an operation that would interfere with inplace substitution. For instance it might contain lookbehind, or assign to non-magical variables (such as $REGMARK and $REGERROR) during matching. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; will skip certain optimisations when this is set.</source>
          <target state="translated">在Perl 5.18.0中添加的此标志指示正则表达式可能执行会干扰就地替换的操作。例如，它可能包含向后查找，或者在匹配期间分配给非魔术变量（例如$ REGMARK和$ REGERROR）。设置此项时， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 将跳过某些优化。</target>
        </trans-unit>
        <trans-unit id="b1d56423c29f7196bca0ef1618ba2dd3e888861c" translate="yes" xml:space="preserve">
          <source>Added in perl 5.22, this method returns the B::REGEXP associated with the op. While PMOPs do not actually have &lt;code&gt;pmregexp&lt;/code&gt; fields under threaded builds, this method returns the regexp under threads nonetheless, for convenience.</source>
          <target state="translated">在Perl 5.22中添加的此方法返回与op关联的B :: REGEXP。尽管PMOP 在线程构建下实际上没有 &lt;code&gt;pmregexp&lt;/code&gt; 字段，但为方便起见，此方法仍在线程下返回regexp。</target>
        </trans-unit>
        <trans-unit id="2ba88f457f4acc695f5bcc5b53d0aed8e9a2a045" translate="yes" xml:space="preserve">
          <source>Adder</source>
          <target state="translated">Adder</target>
        </trans-unit>
        <trans-unit id="6d548b5512a4a3be1ad17c320cc40231db228d55" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;\W*&lt;/code&gt; at either end to eliminate what is to be ignored, we already have the full pattern:</source>
          <target state="translated">在任一端添加 &lt;code&gt;\W*&lt;/code&gt; 以消除要忽略的内容，我们已经有了完整的模式：</target>
        </trans-unit>
        <trans-unit id="75c6e513c1fb807d0884fb4286f8d06fe79494da" translate="yes" xml:space="preserve">
          <source>Adding a Copyright Notice.</source>
          <target state="translated">添加版权声明。</target>
        </trans-unit>
        <trans-unit id="303fa6167f30afc58e107870ab55bef298f595d5" translate="yes" xml:space="preserve">
          <source>Adding a Perl interpreter to your C program</source>
          <target state="translated">在你的C程序中添加一个Perl解释器</target>
        </trans-unit>
        <trans-unit id="3494708836bea1e13cb2fb34de6c0bb041485662" translate="yes" xml:space="preserve">
          <source>Adding a colon &quot;:&quot; or empty string &quot;&quot; to a path at</source>
          <target state="translated">在路径中添加冒号&quot;:&quot;或空字符串&quot;&quot;。</target>
        </trans-unit>
        <trans-unit id="a53e4c0ef202bbd1f27920e920bc75f378ee45c9" translate="yes" xml:space="preserve">
          <source>Adding directories to @INC</source>
          <target state="translated">为@INC添加目录</target>
        </trans-unit>
        <trans-unit id="b8ef134eb6c634200333aedff61c4a77cc1d0006" translate="yes" xml:space="preserve">
          <source>Adding new core tests</source>
          <target state="translated">增加新的核心测试</target>
        </trans-unit>
        <trans-unit id="b80f8c556c16b44d25bfbabc5e3f14bb1ae5d40d" translate="yes" xml:space="preserve">
          <source>Adding non-comment stuff after #endif or #else</source>
          <target state="translated">在#endif或#else后面添加非注释的内容。</target>
        </trans-unit>
        <trans-unit id="65ffd7a09837afed5bf94ab1e1f31e15cc6844fb" translate="yes" xml:space="preserve">
          <source>Adding, deprecating, or removing core features</source>
          <target state="translated">增加、废止或删除核心功能。</target>
        </trans-unit>
        <trans-unit id="dd881a1fe5170572b503d70ad2a1b006df408296" translate="yes" xml:space="preserve">
          <source>Adding, deprecating, removing, or upgrading core or dual-life modules</source>
          <target state="translated">增加、废止、删除或升级核心或双寿命模块。</target>
        </trans-unit>
        <trans-unit id="aa19c6fc6789672e5ea06b36cec0c6ea7c8038fa" translate="yes" xml:space="preserve">
          <source>Adding, removing, or significantly changing documentation in the</source>
          <target state="translated">增加、删除或显著改变文件中的内容。</target>
        </trans-unit>
        <trans-unit id="1d418e4d86845beab5da12aea1ba94a51ff3bc29" translate="yes" xml:space="preserve">
          <source>Addition of &lt;code&gt;gzseek&lt;/code&gt; to provide a restricted &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">添加 &lt;code&gt;gzseek&lt;/code&gt; 以提供受限的 &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 接口。</target>
        </trans-unit>
        <trans-unit id="21cbac17404588ed0f4a75e1ba94b2723810229c" translate="yes" xml:space="preserve">
          <source>Additional allowable exit values can be supplied as an optional first argument to autodying &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">可以将其他允许的退出值作为自动染色 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 的可选第一个参数提供：</target>
        </trans-unit>
        <trans-unit id="95fcc23a5989c1d4707ef062b9c48e30e43e8eea" translate="yes" xml:space="preserve">
          <source>Additional arbitrary HTML tags for the header of the document. The default value is just a content type header tag:</source>
          <target state="translated">用于文档头部的附加任意HTML标签。默认值只是一个内容类型的头标签。</target>
        </trans-unit>
        <trans-unit id="93ccf6b3b0fed7eda8c1cf492ae71f85cc3c2416" translate="yes" xml:space="preserve">
          <source>Additional behaviors can be added to your &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; method by overriding &lt;code&gt;import_extra()&lt;/code&gt; .</source>
          <target state="translated">可以通过覆盖 &lt;code&gt;import_extra()&lt;/code&gt; 将其他行为添加到 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; 方法中。</target>
        </trans-unit>
        <trans-unit id="b69974bf6d56e57936d88d6a5f708b80a863eea6" translate="yes" xml:space="preserve">
          <source>Additional code by Yves Orton.</source>
          <target state="translated">Yves Orton的额外代码。</target>
        </trans-unit>
        <trans-unit id="07c4a7582a6b085c26b5bc77e2d781374f6214f8" translate="yes" xml:space="preserve">
          <source>Additional context-dependent optimizations are performed at this time. Since at this moment the compile tree contains back-references (via &quot;thread&quot; pointers), nodes cannot be free()d now. To allow optimized-away nodes at this stage, such nodes are null()ified instead of free()ing (i.e. their type is changed to OP_NULL).</source>
          <target state="translated">此时会进行额外的上下文相关的优化。由于此时编译树包含了反向引用(通过 &quot;线程 &quot;指针),所以现在不能对节点进行free()d。为了在这个阶段允许优化后的节点,这些节点被null()ified而不是free()ing(即它们的类型被改为OP_NULL)。</target>
        </trans-unit>
        <trans-unit id="31fd46d11c3bbe73ad92eebf33f7553ded695d16" translate="yes" xml:space="preserve">
          <source>Additional contributions by The Perl 5 Porters.</source>
          <target state="translated">Perl 5 移植者的额外贡献。</target>
        </trans-unit>
        <trans-unit id="65d277fbf8e91201355e93559429e2b46f057ea7" translate="yes" xml:space="preserve">
          <source>Additional flags to specify to C preprocessor when scanning header for function declarations. Writes these options in the generated</source>
          <target state="translated">当扫描头部的函数声明时,向C预处理器指定的附加标志。将这些选项写入生成的</target>
        </trans-unit>
        <trans-unit id="8fab7fe5b84df4c38b3df13c3aab585166d6f79c" translate="yes" xml:space="preserve">
          <source>Additional flags:</source>
          <target state="translated">其他旗帜:</target>
        </trans-unit>
        <trans-unit id="224b8dd98beb03b9721f84cf4768d8e500e8a1d7" translate="yes" xml:space="preserve">
          <source>Additional functions not exported by default:</source>
          <target state="translated">默认不导出的附加功能。</target>
        </trans-unit>
        <trans-unit id="c00e0d54188b0a52cda35b7ee1e5c81c6e17488d" translate="yes" xml:space="preserve">
          <source>Additional linker arguments to be considered.</source>
          <target state="translated">需要考虑的其他链接器参数。</target>
        </trans-unit>
        <trans-unit id="c75d2357555d61500cb561ea756aab492ce04979" translate="yes" xml:space="preserve">
          <source>Additional lowercase attributes</source>
          <target state="translated">额外的小写属性</target>
        </trans-unit>
        <trans-unit id="62669130426d053245d54e15329b7bbb244bddc3" translate="yes" xml:space="preserve">
          <source>Additional methods that are provided are:</source>
          <target state="translated">提供的其他方法有:</target>
        </trans-unit>
        <trans-unit id="c9f0c499a9f295c841e5042dc5fcae68b2718736" translate="yes" xml:space="preserve">
          <source>Additional modules:</source>
          <target state="translated">其他模块:</target>
        </trans-unit>
        <trans-unit id="5cb0cfaa4bee3834bdbab722883416b06bf0e1b8" translate="yes" xml:space="preserve">
          <source>Additional option files may be specified with the &lt;code&gt;--rc&lt;/code&gt; option. Default option file processing is disabled by the &lt;code&gt;--norc&lt;/code&gt; option.</source>
          <target state="translated">可以使用 &lt;code&gt;--rc&lt;/code&gt; 选项指定其他选项文件。默认选项文件处理被 &lt;code&gt;--norc&lt;/code&gt; 选项禁用。</target>
        </trans-unit>
        <trans-unit id="a9910904f4a1f818c8f8c0fa7217add5b79e193c" translate="yes" xml:space="preserve">
          <source>Additional supported functions</source>
          <target state="translated">额外支持的功能</target>
        </trans-unit>
        <trans-unit id="62f57b1281983cef6c2785663a1426c055f3a73b" translate="yes" xml:space="preserve">
          <source>Additional thanks to: Edward Avis / Mattia Barbon / Tom Christiansen / Gerrit Haase / Gurusamy Sarathy / Jarkko Hietaniemi (again) / Nikola Knezevic / John Kominetz / Nick Ing-Simmons / Tassilo von Parseval / H. Dieter Pearcey / Slaven Rezic / Eric Roode / Peter Scott / Peter Somu / Autrijus Tang (again) / Tels (again) / Juerd Waalboer / Todd Rinaldo</source>
          <target state="translated">额外感谢:Edward Avis/Mattia Barbon/Tom Christiansen/Gerrit Haase/Gurusamy Sarathy/Jarkko Hietaniemi(再次)/Nikola Knezevic/John Kominetz。Edward Avis/Mattia Barbon/Tom Christiansen/Gerrit Haase/Gurusamy Sarathy/Jarkko Hietaniemi(再次)/Nikola Knezevic/John Kominetz/Nick Ing-Simmons/Tassilo von Parseval/H.Dieter Pearcey/Slaven Rezic/Eric Roode/Peter Scott/Peter Somu/Autrijus Tang(再次)/Tels(再次)/Juerd Waalboer/Todd Rinaldo。</target>
        </trans-unit>
        <trans-unit id="0faa935c5b1efc0ef2a1c52135455cd6a03aa947" translate="yes" xml:space="preserve">
          <source>Additionally &lt;a href=&quot;#weaken&quot;&gt;weaken&lt;/a&gt; and &lt;a href=&quot;#isweak&quot;&gt;isweak&lt;/a&gt; which are</source>
          <target state="translated">另外&lt;a href=&quot;#weaken&quot;&gt;削弱&lt;/a&gt;和&lt;a href=&quot;#isweak&quot;&gt;弱化&lt;/a&gt;是</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
