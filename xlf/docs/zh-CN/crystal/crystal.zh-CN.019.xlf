<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="crystal">
    <body>
      <group id="crystal">
        <trans-unit id="0448efad7e7e9e9d6b2b2403e407507671bde6b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crystal eval&lt;/code&gt; command reads Crystal source code from command line or stdin, compiles it to a binary executable and immediately runs it.</source>
          <target state="translated">该 &lt;code&gt;crystal eval&lt;/code&gt; 命令读取命令行或标准输入晶源代码，对其进行编译为二进制可执行文件，并立即运行它。</target>
        </trans-unit>
        <trans-unit id="b4766b0e054c96a1444b51194810fba9b9ca962d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crystal init&lt;/code&gt; command initializes a Crystal project folder.</source>
          <target state="translated">该 &lt;code&gt;crystal init&lt;/code&gt; 命令初始化水晶项目文件夹。</target>
        </trans-unit>
        <trans-unit id="314bbca54f3cda66d2f8a21d16cd2b1ddb8452d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crystal play&lt;/code&gt; command starts a webserver serving an interactive Crystal playground.</source>
          <target state="translated">该 &lt;code&gt;crystal play&lt;/code&gt; 命令启动服务的交互式水晶游乐场的网络服务器。</target>
        </trans-unit>
        <trans-unit id="079101a55486986035bb64f5bf65982ae4a436f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crystal spec&lt;/code&gt; command compiles and runs a Crystal spec suite.</source>
          <target state="translated">该 &lt;code&gt;crystal spec&lt;/code&gt; 命令编译和运行一个晶体规格套件。</target>
        </trans-unit>
        <trans-unit id="5b9dd66653d154a0ea34d6e3ef2e24d3481cc389" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crystal tool format&lt;/code&gt; command applies default format to Crystal source files.</source>
          <target state="translated">该 &lt;code&gt;crystal tool format&lt;/code&gt; 命令应用默认格式，以晶源文件。</target>
        </trans-unit>
        <trans-unit id="59a50dec667b4c30684788f9d54879f6a7c8ef68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crystal version&lt;/code&gt; command prints the Crystal version, LLVM version and default target triple.</source>
          <target state="translated">该 &lt;code&gt;crystal version&lt;/code&gt; 命令打印水晶版，LLVM版本，默认目标三倍。</target>
        </trans-unit>
        <trans-unit id="0344dc160755c1bdcfefcc0e04e8d1c88539a83f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finalize&lt;/code&gt; method will only be invoked once the object has been fully initialized via the &lt;code&gt;initialize&lt;/code&gt; method. If an exception is raised inside the &lt;code&gt;initialize&lt;/code&gt; method, &lt;code&gt;finalize&lt;/code&gt; won't be invoked. If your class defines a &lt;code&gt;finalize&lt;/code&gt; method, be sure to catch any exceptions that might be raised in the &lt;code&gt;initialize&lt;/code&gt; methods and free resources.</source>
          <target state="translated">在 &lt;code&gt;finalize&lt;/code&gt; 一旦对象已经通过完全初始化方法只会被调用 &lt;code&gt;initialize&lt;/code&gt; 方法。如果在 &lt;code&gt;initialize&lt;/code&gt; 方法内引发了异常，则不会调用 &lt;code&gt;finalize&lt;/code&gt; 。如果您的类定义了 &lt;code&gt;finalize&lt;/code&gt; 方法，请确保捕获在 &lt;code&gt;initialize&lt;/code&gt; 方法和可用资源中可能引发的所有异常。</target>
        </trans-unit>
        <trans-unit id="2dc586d8c7772c2c755777f82871627e4adcf488" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index&lt;/code&gt; variable in the above example is optional.</source>
          <target state="translated">上例中的 &lt;code&gt;index&lt;/code&gt; 变量是可选的。</target>
        </trans-unit>
        <trans-unit id="828105cb7c8e8451e77576d83d5623cb1be400bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initial_capacity&lt;/code&gt; is useful to avoid unnecessary reallocations of the internal buffer in case of growth. If you have an estimate of the maximum number of elements a deque will hold, you should initialize it with that capacity for improved execution performance.</source>
          <target state="translated">如果增长， &lt;code&gt;initial_capacity&lt;/code&gt; 可以避免不必要地重新分配内部缓冲区。如果您估算了双端队列的最大元素数量，则应使用该容量对其进行初始化，以提高执行性能。</target>
        </trans-unit>
        <trans-unit id="04b8e83cea5b8056c015a394838a2e84063296b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instance_sizeof&lt;/code&gt; expression returns an &lt;code&gt;Int32&lt;/code&gt; with the instance size of a given class. For example:</source>
          <target state="translated">所述 &lt;code&gt;instance_sizeof&lt;/code&gt; 表达返回 &lt;code&gt;Int32&lt;/code&gt; 与给定类的实例大小。例如：</target>
        </trans-unit>
        <trans-unit id="86e9f68437efb6eb33253ee818d7638c1e457ac7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;named_args&lt;/code&gt; method can be used to read all key/value pairs on an annotation as a &lt;code&gt;NamedTupleLiteral&lt;/code&gt;. This method is defined on all annotations by default, and is unique to each applied annotation.</source>
          <target state="translated">该 &lt;code&gt;named_args&lt;/code&gt; 方法可用于以读取的注释作为所有键/值对 &lt;code&gt;NamedTupleLiteral&lt;/code&gt; 。默认情况下，此方法在所有注释上定义，并且对于每个应用的注释都是唯一的。</target>
        </trans-unit>
        <trans-unit id="5d1ce040c9328b66d9cae0bb66bf2d14c5a09455" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; expression accepts arguments, and these give the value of the &lt;code&gt;yield&lt;/code&gt; expression that invoked the block:</source>
          <target state="translated">的 &lt;code&gt;next&lt;/code&gt; 表达式接受参数，这些给出的值 &lt;code&gt;yield&lt;/code&gt; 调用该块表达式：</target>
        </trans-unit>
        <trans-unit id="f4ede1d2e182ddeaf133f3b20cd92f8fe7ba0c4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; expression inside a block exits early from the block (not the method). For example:</source>
          <target state="translated">块中的 &lt;code&gt;next&lt;/code&gt; 表达式早于该块退出（不是方法）。例如：</target>
        </trans-unit>
        <trans-unit id="59f8b8a3b88edee4251d8666694afb2946c6ee92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pointerof&lt;/code&gt; expression returns a &lt;a href=&quot;http://crystal-lang.org/api/Pointer.html&quot;&gt;Pointer&lt;/a&gt; that points to the contents of a variable or instance variable.</source>
          <target state="translated">该 &lt;code&gt;pointerof&lt;/code&gt; 表达式返回一个&lt;a href=&quot;http://crystal-lang.org/api/Pointer.html&quot;&gt;Pointer&lt;/a&gt;，该Pointer指向变量或实例变量的内容。</target>
        </trans-unit>
        <trans-unit id="640e2f0e04734dc60523f591a269ce6ea2deeb35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;print_methods&lt;/code&gt; macro will be run as soon as it is encountered - and will print an empty list as there are no methods defined at that point. Once the second declaration of &lt;code&gt;Foo&lt;/code&gt; is compiled the &lt;code&gt;finished&lt;/code&gt; macro will be run, which will print &lt;code&gt;[bar]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;print_methods&lt;/code&gt; 宏后，print_methods宏将立即运行-由于此时未定义任何方法，因此将打印一个空列表。编译 &lt;code&gt;finished&lt;/code&gt; &lt;code&gt;Foo&lt;/code&gt; 的第二个声明后，将运行完成的宏，该宏将显示 &lt;code&gt;[bar]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7769a33217f60d148a4093f91a18ee3f3d9cb487" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; command compiles a source file to a binary executable and immediately runs it.</source>
          <target state="translated">在 &lt;code&gt;run&lt;/code&gt; 命令编译源文件，二进制可执行文件，并立即运行它。</target>
        </trans-unit>
        <trans-unit id="9b6626f886032f0831007e66731f4767216020a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; command compiles the source file &lt;code&gt;hello_world.cr&lt;/code&gt; to a binary executable in a temporary location and immediately executes it.</source>
          <target state="translated">在 &lt;code&gt;run&lt;/code&gt; 命令编译源文件 &lt;code&gt;hello_world.cr&lt;/code&gt; 在一个临时位置的二进制可执行文件，并立即执行。</target>
        </trans-unit>
        <trans-unit id="476c39fdfd41c30f38a5774c70eeba5ebe895ef6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send&lt;/code&gt; methods may sporadically fail with &lt;code&gt;&lt;a href=&quot;errno#ECONNREFUSED&quot;&gt;Errno::ECONNREFUSED&lt;/a&gt;&lt;/code&gt; when sending datagrams to a non-listening server. Wrap with an exception handler to prevent raising. Example:</source>
          <target state="translated">将数据报发送到非侦听服务器时， &lt;code&gt;send&lt;/code&gt; 方法可能会因 &lt;code&gt;&lt;a href=&quot;errno#ECONNREFUSED&quot;&gt;Errno::ECONNREFUSED&lt;/a&gt;&lt;/code&gt; 偶尔失败。用异常处理程序包装以防止引发。例：</target>
        </trans-unit>
        <trans-unit id="a36cde71d7e58f2803f86c4457bfeab51950dc07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sizeof&lt;/code&gt; expression returns an &lt;code&gt;Int32&lt;/code&gt; with the size in bytes of a given type. For example:</source>
          <target state="translated">所述 &lt;code&gt;sizeof&lt;/code&gt; 表达式返回 &lt;code&gt;Int32&lt;/code&gt; 在给定的类型的字节大小。例如：</target>
        </trans-unit>
        <trans-unit id="050175522f85efb6178a3193491b00060fcd72c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; expression returns the type of an expression:</source>
          <target state="translated">所述 &lt;code&gt;typeof&lt;/code&gt; 表达式返回表达式的类型：</target>
        </trans-unit>
        <trans-unit id="c494b62b15d69a92665ae4b4ff266e06fe21f5bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; expression is similar to a call and can receive arguments. For example:</source>
          <target state="translated">的 &lt;code&gt;yield&lt;/code&gt; 表达类似于呼叫和可以接收参数。例如：</target>
        </trans-unit>
        <trans-unit id="d0274a3410c672dca60fd3803cdf66a4f06d7a20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; expression itself has a value: the last expression of the block. For example:</source>
          <target state="translated">的 &lt;code&gt;yield&lt;/code&gt; 表达本身具有值：块的最后一个表达式。例如：</target>
        </trans-unit>
        <trans-unit id="84f2a4702b412b7487dc6196411fce9ee9b4f5e8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initial_capacity&lt;/em&gt; is useful to avoid unnecessary reallocations of the internal buffer in case of growth. If the number of elements a hash will hold is known, the hash should be initialized with that capacity for improved performance. Otherwise, the default is 11 and inputs less than 11 are ignored.</source>
          <target state="translated">如果增长，&lt;em&gt;initial_capacity&lt;/em&gt;可以避免不必要地重新分配内部缓冲区。如果知道哈希将保留的元素数，则应使用该容量初始化哈希以提高性能。否则，默认值为11，小于11的输入将被忽略。</target>
        </trans-unit>
        <trans-unit id="2ed78875a62987193980f5047120cbd761267d03" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initial_capacity&lt;/em&gt; is useful to avoid unnecessary reallocations of the internal buffer in case of growth. If you have an estimate of the maximum number of elements an array will hold, the array should be initialized with that capacity for improved performance.</source>
          <target state="translated">如果增长，&lt;em&gt;initial_capacity&lt;/em&gt;可以避免不必要地重新分配内部缓冲区。如果您估计数组将容纳的最大元素数，则应使用该容量初始化数组以提高性能。</target>
        </trans-unit>
        <trans-unit id="7baf271fb624856a3469e176c34f8fa3b89283f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initial_capacity&lt;/em&gt; is useful to avoid unnecessary reallocations of the internal buffers in case of growth. If you have an estimate of the maximum number of elements the pool will hold it should be initialized with that capacity for improved performance.</source>
          <target state="translated">如果增长，&lt;em&gt;initial_capacity&lt;/em&gt;可以避免不必要地重新分配内部缓冲区。如果您估计池将容纳的最大元素数，则应使用该容量进行初始化以提高性能。</target>
        </trans-unit>
        <trans-unit id="082a9afbda2cb1b0f6552fd53000193048db0545" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;invalid&lt;/em&gt; argument can be:</source>
          <target state="translated">该&lt;em&gt;无效&lt;/em&gt;参数可以是：</target>
        </trans-unit>
        <trans-unit id="116ceb0ceef4ca1cee47533c2e118c6a52fb9b9a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;other&lt;/em&gt; must have the same or fewer elements than this set, and all of elements in the &lt;em&gt;other&lt;/em&gt; set must be present in this set.</source>
          <target state="translated">在&lt;em&gt;其他&lt;/em&gt;必须具有比该组相同的或更少的元件，并且所有的元素的&lt;em&gt;其他&lt;/em&gt;组必须存在于该集合。</target>
        </trans-unit>
        <trans-unit id="6ffc77fd23d96be3ef2345da029c01227c05e67f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;padding&lt;/em&gt; parameter defaults to &lt;code&gt;true&lt;/code&gt;. When &lt;code&gt;false&lt;/code&gt;, enough &lt;code&gt;=&lt;/code&gt; characters are not added to make the output divisible by 4.</source>
          <target state="translated">该&lt;em&gt;填充&lt;/em&gt;参数默认为 &lt;code&gt;true&lt;/code&gt; 。如果为 &lt;code&gt;false&lt;/code&gt; ，则不添加足够的 &lt;code&gt;=&lt;/code&gt; 字符以使输出可被4整除。</target>
        </trans-unit>
        <trans-unit id="45ed0a950ff4677992ea3425dd1059324956f95b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;start&lt;/em&gt; argument can be negative to start counting from the end of the string.</source>
          <target state="translated">在&lt;em&gt;启动&lt;/em&gt;参数可以是负数，从字符串的结尾开始计数。</target>
        </trans-unit>
        <trans-unit id="26c74a8102f56eb2c014c035dc7e9ffee86aa61e" translate="yes" xml:space="preserve">
          <source>The Benchmark module provides methods for benchmarking Crystal code, giving detailed reports on the time and memory taken for each task.</source>
          <target state="translated">基准模块提供了对Crystal代码进行基准测试的方法,给出了每个任务所需时间和内存的详细报告。</target>
        </trans-unit>
        <trans-unit id="43eea8c10c8c90a84f34a4b4355976aab9f9896e" translate="yes" xml:space="preserve">
          <source>The C name can be put in quotes to be able to write a name that is not a valid identifier:</source>
          <target state="translated">C名可以加引号,能够写一个不是有效标识符的名字。</target>
        </trans-unit>
        <trans-unit id="ebded078f2c9bc998559ff22d6a51ef0c260511f" translate="yes" xml:space="preserve">
          <source>The Crystal &lt;a href=&quot;https://crystal-lang.org/api&quot;&gt;Standard Library&lt;/a&gt; provides macros which simplify the definition of getter and setter methods:</source>
          <target state="translated">Crystal &lt;a href=&quot;https://crystal-lang.org/api&quot;&gt;标准库&lt;/a&gt;提供了可以简化getter和setter方法定义的宏：</target>
        </trans-unit>
        <trans-unit id="11bcce27589af8645d623b8e1591692cd37533a1" translate="yes" xml:space="preserve">
          <source>The Crystal compiler doesn't run on Windows &lt;em&gt;yet&lt;/em&gt;. But Crystal can be used with the &lt;a href=&quot;https://msdn.microsoft.com/en-us/commandline/wsl/about&quot;&gt;Windows Subsystem for Linux&lt;/a&gt;, a compatibility-layer for Linux executables running natively on Windows 10.</source>
          <target state="translated">Crystal编译器&lt;em&gt;尚未&lt;/em&gt;在Windows上运行。但是Crystal可以与&lt;a href=&quot;https://msdn.microsoft.com/en-us/commandline/wsl/about&quot;&gt;Windows Subsystem for Linux&lt;/a&gt;一起使用，Windows Subsystem是Linux可执行文件的兼容性层，该兼容性层本机运行在Windows 10上。</target>
        </trans-unit>
        <trans-unit id="246a934abe5eec85f56c980a571d87666319f371" translate="yes" xml:space="preserve">
          <source>The Crystal compiler has a &lt;code&gt;spec&lt;/code&gt; command with tools to constrain which examples get run and tailor the output.</source>
          <target state="translated">Crystal编译器具有一个带有工具的 &lt;code&gt;spec&lt;/code&gt; 命令，该工具可以约束运行哪些示例并调整输出。</target>
        </trans-unit>
        <trans-unit id="ac9f8bc907d9554b2d118c48b43c52ba78e9435e" translate="yes" xml:space="preserve">
          <source>The Crystal compiler has a &lt;code&gt;spec&lt;/code&gt; command with tools to constrain which examples get run and tailor the output. All specs of a project are compiled and executed through the command &lt;code&gt;crystal spec&lt;/code&gt;.</source>
          <target state="translated">Crystal编译器具有一个带有工具的 &lt;code&gt;spec&lt;/code&gt; 命令，该工具可以约束运行哪些示例并调整输出。项目的所有规范都是通过命令 &lt;code&gt;crystal spec&lt;/code&gt; 编译和执行的。</target>
        </trans-unit>
        <trans-unit id="d2853e9df7bba5ea8d57e5fe8ef5ae7ad099086e" translate="yes" xml:space="preserve">
          <source>The Crystal compiler will by default use pkg-config to find the locations of libraries to link with.</source>
          <target state="translated">Crystal编译器默认会使用pkg-config来查找要链接的库的位置。</target>
        </trans-unit>
        <trans-unit id="496565dce03820f56e8fc9474e24b5e134107258" translate="yes" xml:space="preserve">
          <source>The Crystal standard library includes some pre-defined annotations:</source>
          <target state="translated">Crystal标准库包括一些预定义的注释。</target>
        </trans-unit>
        <trans-unit id="5aaa7997408fd8ef83f3611fed91d6c095d4826b" translate="yes" xml:space="preserve">
          <source>The Event Loop, which is just another fiber, being in charge of async tasks, like for example files, sockets, pipes, signals and timers (like doing a &lt;code&gt;sleep&lt;/code&gt;).</source>
          <target state="translated">事件循环（Event Loop）只是另一根光纤，它负责异步任务，例如文件，套接字，管道，信号和计时器（例如进行 &lt;code&gt;sleep&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2932829212c0aedee2b68bf1bf885f260e8e48c8" translate="yes" xml:space="preserve">
          <source>The Flate module contains readers and writers of DEFLATE format compressed data, as specified in &lt;a href=&quot;https://www.ietf.org/rfc/rfc1951.txt&quot;&gt;RFC 1951&lt;/a&gt;.</source>
          <target state="translated">Flate模块包含&lt;a href=&quot;https://www.ietf.org/rfc/rfc1951.txt&quot;&gt;RFC 1951中&lt;/a&gt;指定的DEFLATE格式压缩数据的读取器和写入器。</target>
        </trans-unit>
        <trans-unit id="d1a3a6862df64d2244b0c478f207f1efd99cc6a8" translate="yes" xml:space="preserve">
          <source>The Gzip module contains readers and writers of gzip format compressed data, as specified in &lt;a href=&quot;https://www.ietf.org/rfc/rfc1952.txt&quot;&gt;RFC 1952&lt;/a&gt;.</source>
          <target state="translated">Gzip模块包含&lt;a href=&quot;https://www.ietf.org/rfc/rfc1952.txt&quot;&gt;RFC 1952中&lt;/a&gt;指定的gzip格式压缩数据的读取器和写入器。</target>
        </trans-unit>
        <trans-unit id="80874a7a6067509ab808ed784692c5048c982967" translate="yes" xml:space="preserve">
          <source>The HTTP module contains &lt;code&gt;&lt;a href=&quot;http/client&quot;&gt;HTTP::Client&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;http/server&quot;&gt;HTTP::Server&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http/websocket&quot;&gt;HTTP::WebSocket&lt;/a&gt;&lt;/code&gt; implementations.</source>
          <target state="translated">HTTP模块包含 &lt;code&gt;&lt;a href=&quot;http/client&quot;&gt;HTTP::Client&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;http/server&quot;&gt;HTTP::Server&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;http/websocket&quot;&gt;HTTP::WebSocket&lt;/a&gt;&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="7210a8d45812f1f6ad2d64962710554d301159a0" translate="yes" xml:space="preserve">
          <source>The IEC standard prefixes (&lt;code&gt;Ki&lt;/code&gt;, &lt;code&gt;Mi&lt;/code&gt;, &lt;code&gt;Gi&lt;/code&gt;, &lt;code&gt;Ti&lt;/code&gt;, &lt;code&gt;Pi&lt;/code&gt;, &lt;code&gt;Ei&lt;/code&gt;, &lt;code&gt;Zi&lt;/code&gt;, &lt;code&gt;Yi&lt;/code&gt;) based on powers of 1000.</source>
          <target state="translated">IEC标准前缀（ &lt;code&gt;Ki&lt;/code&gt; ， &lt;code&gt;Mi&lt;/code&gt; ， &lt;code&gt;Gi&lt;/code&gt; ， &lt;code&gt;Ti&lt;/code&gt; ， &lt;code&gt;Pi&lt;/code&gt; ， &lt;code&gt;Ei&lt;/code&gt; ， &lt;code&gt;Zi&lt;/code&gt; ， &lt;code&gt;Yi&lt;/code&gt; ）基于1000的幂。</target>
        </trans-unit>
        <trans-unit id="17b7c182b134c533f4686ee776344c3a59482ff5" translate="yes" xml:space="preserve">
          <source>The IO starts at position zero for reading.</source>
          <target state="translated">IO从零位开始读取。</target>
        </trans-unit>
        <trans-unit id="6bafde48904d0ae0de3bcde7c34c01518d44c6c9" translate="yes" xml:space="preserve">
          <source>The ISO 8601 date format.</source>
          <target state="translated">ISO 8601日期格式。</target>
        </trans-unit>
        <trans-unit id="a04d481795c047179a2ee48089b718eba567f7e5" translate="yes" xml:space="preserve">
          <source>The ISO 8601 date time format.</source>
          <target state="translated">ISO 8601日期时间格式。</target>
        </trans-unit>
        <trans-unit id="1c961e8e18cc38295c61b2a7222c42aefba3c770" translate="yes" xml:space="preserve">
          <source>The ISO 8601 time format.</source>
          <target state="translated">ISO 8601时间格式。</target>
        </trans-unit>
        <trans-unit id="43ed1dc44d29b51880fe516a3a988e2cf78bc72f" translate="yes" xml:space="preserve">
          <source>The ISO calendar year to which the week belongs is not always in the same as the year of the regular calendar date. The first three days of January sometimes belong to week 52 (or 53) of the previous year; equally the last three days of December sometimes are already in week 1 of the following year.</source>
          <target state="translated">该周所属的国际标准化组织日历年并不总是与正常日历日期的年份相同。1月的前三天有时属于上一年的第52周(或53周);同样,12月的最后三天有时已经是下一年的第1周。</target>
        </trans-unit>
        <trans-unit id="228dafd6179d5875e92d7f01e81f1934d3aa42c8" translate="yes" xml:space="preserve">
          <source>The JSON format itself does not specify a time data type, this method just assumes that a string holding a ISO 8601 time format can be interpreted as a time value.</source>
          <target state="translated">JSON格式本身并没有指定时间数据类型,本方法只是假设持有ISO 8601时间格式的字符串可以解释为时间值。</target>
        </trans-unit>
        <trans-unit id="1185e96419d9d1ed2f07417c50469963555dc1b6" translate="yes" xml:space="preserve">
          <source>The JSON format itself does not specify a time data type, this method just assumes that a string holding a RFC 3339 time format will be interpreted as a time value.</source>
          <target state="translated">JSON格式本身并没有指定时间数据类型,这个方法只是假设一个持有RFC 3339时间格式的字符串将被解释为一个时间值。</target>
        </trans-unit>
        <trans-unit id="e3f3b7b16cf17dc7e84258d17d1db205edf18511" translate="yes" xml:space="preserve">
          <source>The JSON module allows parsing and generating &lt;a href=&quot;http://json.org/&quot;&gt;JSON&lt;/a&gt; documents.</source>
          <target state="translated">JSON模块允许解析和生成&lt;a href=&quot;http://json.org/&quot;&gt;JSON&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="9f5c6c0766cb92bf425f36b14da6f837c49d4740" translate="yes" xml:space="preserve">
          <source>The OAuth module provides an &lt;code&gt;&lt;a href=&quot;oauth/consumer&quot;&gt;OAuth::Consumer&lt;/a&gt;&lt;/code&gt; as specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc5849&quot;&gt;RFC 5849&lt;/a&gt;.</source>
          <target state="translated">OAuth模块提供了&lt;a href=&quot;https://tools.ietf.org/html/rfc5849&quot;&gt;RFC 5849&lt;/a&gt;指定的 &lt;code&gt;&lt;a href=&quot;oauth/consumer&quot;&gt;OAuth::Consumer&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e0019e40cebf225476af7fc5485763fd0ab22a9" translate="yes" xml:space="preserve">
          <source>The OAuth module provides an &lt;code&gt;&lt;a href=&quot;oauth2/client&quot;&gt;OAuth2::Client&lt;/a&gt;&lt;/code&gt; as specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc6749&quot;&gt;RFC 6749&lt;/a&gt;.</source>
          <target state="translated">OAuth模块提供了&lt;a href=&quot;https://tools.ietf.org/html/rfc6749&quot;&gt;RFC 6749&lt;/a&gt;指定的 &lt;code&gt;&lt;a href=&quot;oauth2/client&quot;&gt;OAuth2::Client&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3d5ad4cc469d2e7b77356056225510ee84b1bf1" translate="yes" xml:space="preserve">
          <source>The Proc type</source>
          <target state="translated">Proc类型</target>
        </trans-unit>
        <trans-unit id="fce18036495868d9659f03df3d44dfcec351c534" translate="yes" xml:space="preserve">
          <source>The Program</source>
          <target state="translated">该计划</target>
        </trans-unit>
        <trans-unit id="3f4b331987b1aaf724056fe853e6d70f80673e09" translate="yes" xml:space="preserve">
          <source>The Runtime Scheduler</source>
          <target state="translated">运行时调度程序</target>
        </trans-unit>
        <trans-unit id="102e2b07fdae53df53734526fd9c2db526c4e21b" translate="yes" xml:space="preserve">
          <source>The Runtime Scheduler, in charge of executing all fibers when the time is right.</source>
          <target state="translated">Runtime Scheduler,负责在时机成熟时执行所有光纤。</target>
        </trans-unit>
        <trans-unit id="e127a192f2256e22ef64756febf709a2977a36a8" translate="yes" xml:space="preserve">
          <source>The SSL server wraps a &lt;code&gt;&lt;a href=&quot;../tcpserver&quot;&gt;TCPServer&lt;/a&gt;&lt;/code&gt; listening on &lt;code&gt;host:port&lt;/code&gt;.</source>
          <target state="translated">SSL服务器包装在 &lt;code&gt;host:port&lt;/code&gt; 上侦听的 &lt;code&gt;&lt;a href=&quot;../tcpserver&quot;&gt;TCPServer&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="993cd52af8f852fbc873f8473c1d225a3a5acc7e" translate="yes" xml:space="preserve">
          <source>The SSL server wraps a &lt;code&gt;&lt;a href=&quot;../tcpserver&quot;&gt;TCPServer&lt;/a&gt;&lt;/code&gt; listening on an unused port on &lt;em&gt;host&lt;/em&gt;.</source>
          <target state="translated">SSL服务器包装在&lt;em&gt;主机&lt;/em&gt;上未使用的端口上侦听的 &lt;code&gt;&lt;a href=&quot;../tcpserver&quot;&gt;TCPServer&lt;/a&gt;&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1595db4bc4b8523c7b00f405e76d7d591c1dd0a" translate="yes" xml:space="preserve">
          <source>The String version just creates a new &lt;a href=&quot;http://crystal-lang.org/api/Exception.html&quot;&gt;Exception&lt;/a&gt; instance with that message.</source>
          <target state="translated">字符串版本仅使用该消息创建一个新的&lt;a href=&quot;http://crystal-lang.org/api/Exception.html&quot;&gt;Exception&lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="8c80d2df18a6198b85456576a2042aee2a69b82d" translate="yes" xml:space="preserve">
          <source>The XML module allows parsing and generating &lt;a href=&quot;https://www.w3.org/XML/&quot;&gt;XML&lt;/a&gt; documents.</source>
          <target state="translated">XML模块允许解析和生成&lt;a href=&quot;https://www.w3.org/XML/&quot;&gt;XML&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="8fb09953e062ea577b5ddb247457a645d3fb45fa" translate="yes" xml:space="preserve">
          <source>The YAML module provides serialization and deserialization of YAML version 1.1 to/from native Crystal data structures, with the additional independent types specified in http://yaml.org/type/</source>
          <target state="translated">YAML模块提供了YAML 1.1版本对本地Crystal数据结构的序列化和反序列化,以及在http://yaml.org/type/中指定的附加独立类型。</target>
        </trans-unit>
        <trans-unit id="a44017a79d04272fe9a78e56baad945f7ca46c5b" translate="yes" xml:space="preserve">
          <source>The YAML::Nodes module provides an implementation of an in-memory YAML document tree. This tree can be generated with the &lt;code&gt;&lt;a href=&quot;nodes#parse(string_or_io:String%7CIO):Document-class-method&quot;&gt;YAML::Nodes.parse&lt;/a&gt;&lt;/code&gt; method or created with a &lt;code&gt;&lt;a href=&quot;nodes/builder&quot;&gt;YAML::Nodes::Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">YAML :: Nodes模块提供了内存中YAML文档树的实现。该树可以使用 &lt;code&gt;&lt;a href=&quot;nodes#parse(string_or_io:String%7CIO):Document-class-method&quot;&gt;YAML::Nodes.parse&lt;/a&gt;&lt;/code&gt; 方法生成，也可以使用 &lt;code&gt;&lt;a href=&quot;nodes/builder&quot;&gt;YAML::Nodes::Builder&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c8dbee7cb1cee8bef1459835cb0aff74e8e33f2" translate="yes" xml:space="preserve">
          <source>The Zip module contains readers and writers of the zip file format, described at &lt;a href=&quot;https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.3.3.TXT&quot;&gt;PKWARE's site&lt;/a&gt;.</source>
          <target state="translated">Zip模块包含zip文件格式的读取器和写入器，在&lt;a href=&quot;https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.3.3.TXT&quot;&gt;PKWARE的网站上有介绍&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ce59e4bdd57d98f027a247e2e6e5544e94683b0" translate="yes" xml:space="preserve">
          <source>The Zlib module contains readers and writers of zlib format compressed data, as specified in &lt;a href=&quot;https://www.ietf.org/rfc/rfc1950.txt&quot;&gt;RFC 1950&lt;/a&gt;.</source>
          <target state="translated">Zlib模块包含&lt;a href=&quot;https://www.ietf.org/rfc/rfc1950.txt&quot;&gt;RFC 1950中&lt;/a&gt;指定的zlib格式压缩数据的读取器和写入器。</target>
        </trans-unit>
        <trans-unit id="4b5f00738405f1ed3933e935ceb50dd3dea27652" translate="yes" xml:space="preserve">
          <source>The above &lt;strong&gt;doesn&amp;rsquo;t&lt;/strong&gt; work with instance variables or class variables. To work with these, first assign them to a variable:</source>
          <target state="translated">上面的方法&lt;strong&gt;不适&lt;/strong&gt;用于实例变量或类变量。要使用它们，首先将它们分配给变量：</target>
        </trans-unit>
        <trans-unit id="a804ccbb78c43a03510970e8c8f2e9338d5413d2" translate="yes" xml:space="preserve">
          <source>The above also works if there are ands (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;) in the condition:</source>
          <target state="translated">如果条件中包含ands（ &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ），则以上内容也适用：</target>
        </trans-unit>
        <trans-unit id="54c602bba78ff08495ac576d900850a987bc8493" translate="yes" xml:space="preserve">
          <source>The above code captures the block of code passed to &lt;code&gt;int_to_int&lt;/code&gt; in the &lt;code&gt;block&lt;/code&gt; variable, and returns it from the method. The type of &lt;code&gt;proc&lt;/code&gt; is &lt;a href=&quot;http://crystal-lang.org/api/Proc.html&quot;&gt;Proc(Int32, Int32)&lt;/a&gt;, a function that accepts a single &lt;code&gt;Int32&lt;/code&gt; argument and returns an &lt;code&gt;Int32&lt;/code&gt;.</source>
          <target state="translated">上面的代码捕获的代码块传递给 &lt;code&gt;int_to_int&lt;/code&gt; 在 &lt;code&gt;block&lt;/code&gt; 可变的，并且从该方法返回它。 &lt;code&gt;proc&lt;/code&gt; 的类型为&lt;a href=&quot;http://crystal-lang.org/api/Proc.html&quot;&gt;Proc（Int32，Int32）&lt;/a&gt;，该函数接受单个 &lt;code&gt;Int32&lt;/code&gt; 参数并返回 &lt;code&gt;Int32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="482726665ac9e182f65bd69d3da115ac7a67df13" translate="yes" xml:space="preserve">
          <source>The above code gives this compile error:</source>
          <target state="translated">上面的代码给出了这个编译错误。</target>
        </trans-unit>
        <trans-unit id="a6405d5019e9bc272db6cdff6739c053f2522b0b" translate="yes" xml:space="preserve">
          <source>The above code will make sense once you read the whole language reference, but we can already learn some things.</source>
          <target state="translated">上面的代码只要看完整个语言参考就会有意义,但我们已经可以学到一些东西。</target>
        </trans-unit>
        <trans-unit id="5706d80d8aec1ab71b41a3a63a014d3965e051b9" translate="yes" xml:space="preserve">
          <source>The above could also be implemented with a Symbol:</source>
          <target state="translated">以上也可以用Symbol来实现。</target>
        </trans-unit>
        <trans-unit id="2c83f99c41c0bff6b77243fc1d08e0f9b2324ef9" translate="yes" xml:space="preserve">
          <source>The above examples use unbuffered channels: when sending a value, if a fiber is waiting on that channel then execution continues on that fiber.</source>
          <target state="translated">上面的例子使用的是无缓冲通道:当发送一个值时,如果有光纤在该通道上等待,那么在该光纤上继续执行。</target>
        </trans-unit>
        <trans-unit id="656d5d691a11dc89cab934b727b7b657f2a26bf2" translate="yes" xml:space="preserve">
          <source>The above generates a program that will have the contents of &lt;code&gt;some_file.txt&lt;/code&gt;. The file, however, is read at compile time and will not be needed at runtime.</source>
          <target state="translated">上面生成的程序将包含 &lt;code&gt;some_file.txt&lt;/code&gt; 的内容。但是，该文件在编译时读取，并且在运行时不需要。</target>
        </trans-unit>
        <trans-unit id="e6c433adda1b56a97e3e970be41047634b01806e" translate="yes" xml:space="preserve">
          <source>The above happens even if &lt;code&gt;something_dangerous_that_returns_Int32&lt;/code&gt; never raises, or if &lt;code&gt;a&lt;/code&gt; was assigned a value and then a method that potentially raises is executed:</source>
          <target state="translated">上述情况发生，即使 &lt;code&gt;something_dangerous_that_returns_Int32&lt;/code&gt; 从未加注，或者如果 &lt;code&gt;a&lt;/code&gt; 被分配的值，然后将该潜在引发被执行的方法：</target>
        </trans-unit>
        <trans-unit id="bcb9caec3740c65229c0b2a54051836485d126ee" translate="yes" xml:space="preserve">
          <source>The above is mostly useful with flag enums.</source>
          <target state="translated">上面的内容主要是对标志枚举有用。</target>
        </trans-unit>
        <trans-unit id="1621fe8a8f7d10296061ab3f96abd962a66da91a" translate="yes" xml:space="preserve">
          <source>The above is simply rewritten to:</source>
          <target state="translated">以上只是改写为:</target>
        </trans-unit>
        <trans-unit id="9768279392033a963a63cadc30475985e7e4b6bb" translate="yes" xml:space="preserve">
          <source>The above is simply syntax sugar of this:</source>
          <target state="translated">以上就是这个的简单语法糖。</target>
        </trans-unit>
        <trans-unit id="2a07a4b43f1d70c3a43cc842b0248805bbd090f0" translate="yes" xml:space="preserve">
          <source>The above is the same as this:</source>
          <target state="translated">上面的内容与此相同。</target>
        </trans-unit>
        <trans-unit id="57a8c9f43fefd72d2d0f7808adbb754a2c6bc9c7" translate="yes" xml:space="preserve">
          <source>The above is useful for providing overloads based on types, not instances:</source>
          <target state="translated">以上对于提供基于类型而非实例的重载是有用的。</target>
        </trans-unit>
        <trans-unit id="dbbbdd4bb540a3091716b8351544904cd0edd01b" translate="yes" xml:space="preserve">
          <source>The above logic works &lt;strong&gt;only for local variables&lt;/strong&gt;. It doesn&amp;rsquo;t work with instance variables, class variables, or variables bound in a closure. The value of these kinds of variables could potentially be affected by another fiber after the condition was checked, rendering it &lt;code&gt;nil&lt;/code&gt;. It also does not work with constants.</source>
          <target state="translated">以上逻辑&lt;strong&gt;仅适用于局部变量&lt;/strong&gt;。它不适用于实例变量，类变量或闭包中绑定的变量。检查条件后，另一类光纤可能会影响这些变量的值，使其变为 &lt;code&gt;nil&lt;/code&gt; 。它也不适用于常量。</target>
        </trans-unit>
        <trans-unit id="2a6b864cceaad721862897225ec878ce0958f539" translate="yes" xml:space="preserve">
          <source>The above methods delegate to a &lt;code&gt;&lt;a href=&quot;random&quot;&gt;Random&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">上面的方法委托给 &lt;code&gt;&lt;a href=&quot;random&quot;&gt;Random&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="b46c5f49ab483965caa577aae8f803d42b87ba7e" translate="yes" xml:space="preserve">
          <source>The above might not seem to be useful, but it is when, for example, mapping an array of elements:</source>
          <target state="translated">上面的内容看起来似乎并没有什么用处,但是当,例如,映射一个元素数组的时候。</target>
        </trans-unit>
        <trans-unit id="2832d8248ae199f774368b1d496760735fcebca3" translate="yes" xml:space="preserve">
          <source>The above prints &quot;2&quot; and &quot;3&quot;.</source>
          <target state="translated">上面打印的是 &quot;2 &quot;和 &quot;3&quot;。</target>
        </trans-unit>
        <trans-unit id="d90554e7b062fa330c4bc308bb8a055de1f577ae" translate="yes" xml:space="preserve">
          <source>The above prints &quot;Before 1&quot; and &quot;Before 2&quot;. The &lt;code&gt;thrice&lt;/code&gt; method didn't execute the &lt;code&gt;puts &quot;Before 3&quot;&lt;/code&gt; expression because of the &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="translated">上面打印&amp;ldquo; 1之前&amp;rdquo;和&amp;ldquo; 2之前&amp;rdquo;。由于 &lt;code&gt;break&lt;/code&gt; ， &lt;code&gt;thrice&lt;/code&gt; 方法未执行 &lt;code&gt;puts &quot;Before 3&quot;&lt;/code&gt; 表达式。</target>
        </trans-unit>
        <trans-unit id="3beb91c1e0a6c3144834c6803392d4652beaa01a" translate="yes" xml:space="preserve">
          <source>The above prints &quot;Got 1&quot; and &quot;Got 2&quot;.</source>
          <target state="translated">上面打印的是 &quot;得1 &quot;和 &quot;得2&quot;。</target>
        </trans-unit>
        <trans-unit id="b44d7fd3b0fe5efd71b4f239ad69d0fc010d3afb" translate="yes" xml:space="preserve">
          <source>The above produces:</source>
          <target state="translated">以上产生。</target>
        </trans-unit>
        <trans-unit id="5ca4589dcb158eaa50f8ae74813c4cf8260fdaa6" translate="yes" xml:space="preserve">
          <source>The above program prints &quot;10&quot; ten times. The problem is that there's only one variable &lt;code&gt;i&lt;/code&gt; that all spawned fibers refer to, and when &lt;code&gt;Fiber.yield&lt;/code&gt; is executed its value is 10.</source>
          <target state="translated">上面的程序打印&amp;ldquo; 10&amp;rdquo;十次。问题是所有生成的光纤 &lt;code&gt;Fiber.yield&lt;/code&gt; 引用一个变量 &lt;code&gt;i&lt;/code&gt; ，执行Fiber.yield时其值为10。</target>
        </trans-unit>
        <trans-unit id="54d023ab647646c46ff7e0e093c24819eab0a23a" translate="yes" xml:space="preserve">
          <source>The above program prints &quot;Hello!&quot; twice, once for each &lt;code&gt;yield&lt;/code&gt;.</source>
          <target state="translated">上面的程序打印&amp;ldquo; Hello！&amp;rdquo;。两次，每次 &lt;code&gt;yield&lt;/code&gt; 一次。</target>
        </trans-unit>
        <trans-unit id="078b0861ba82af5a528dc088249014a70f5efb1d" translate="yes" xml:space="preserve">
          <source>The above program spawns two fibers. The first one creates a TCPServer, accepts one connection and reads lines from it, sending them to the channel. There's a second fiber reading lines from standard input. The main fiber reads the first 3 messages sent to the channel, either from the socket or stdin, then the program exits. The &lt;code&gt;gets&lt;/code&gt; calls will block the fibers and tell the Event Loop to continue from there if data comes.</source>
          <target state="translated">上面的程序产生了两条光纤。第一个创建一个TCPServer，接受一个连接并从中读取行，然后将它们发送到通道。标准输入有第二条光纤读取线。主光纤从套接字或stdin读取发送到通道的前3条消息，然后程序退出。在 &lt;code&gt;gets&lt;/code&gt; 调用将阻止纤维和告知事件循环，如果数据涉及到从那里继续。</target>
        </trans-unit>
        <trans-unit id="11999f0a14eb703100105bc7165779496f6db462" translate="yes" xml:space="preserve">
          <source>The above program works but has a big performance problem: on every iteration a new array is created for &lt;code&gt;[&quot;crystal&quot;, &quot;ruby&quot;, &quot;java&quot;]&lt;/code&gt;. Remember: an array literal is just syntax sugar for creating an instance of an array and adding some values to it, and this will happen over and over on each iteration.</source>
          <target state="translated">上面的程序可以运行，但是存在很大的性能问题：在每次迭代中，都会为 &lt;code&gt;[&quot;crystal&quot;, &quot;ruby&quot;, &quot;java&quot;]&lt;/code&gt; 创建一个新数组。请记住：数组文字只是用于创建数组实例并向其中添加一些值的语法糖，并且这种情况将在每次迭代中反复发生。</target>
        </trans-unit>
        <trans-unit id="7a7ff822add2855066bbeb49a4b5413bd1d285fb" translate="yes" xml:space="preserve">
          <source>The above works, but creates many intermediate arrays: one for the &lt;em&gt;select&lt;/em&gt; call, one for the &lt;em&gt;map&lt;/em&gt; call and one for the &lt;em&gt;take&lt;/em&gt; call. A more efficient way is to invoke &lt;code&gt;&lt;a href=&quot;range#each(&amp;amp;block):Nil-instance-method&quot;&gt;Range#each&lt;/a&gt;&lt;/code&gt; without a block, which gives us an &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;Iterator&lt;/a&gt;&lt;/code&gt; so we can process the operations lazily:</source>
          <target state="translated">上面的方法有效，但是创建了许多中间数组：一个用于&lt;em&gt;select&lt;/em&gt;调用，一个用于&lt;em&gt;map&lt;/em&gt;调用，一个用于&lt;em&gt;take&lt;/em&gt;调用。一种更有效的方法是在不带任何块的情况下调用 &lt;code&gt;&lt;a href=&quot;range#each(&amp;amp;block):Nil-instance-method&quot;&gt;Range#each&lt;/a&gt;&lt;/code&gt; ，这为我们提供了 &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;Iterator&lt;/a&gt;&lt;/code&gt; 因此我们可以延迟处理操作：</target>
        </trans-unit>
        <trans-unit id="4319040e3f3e88a7eb1830b2d394e99ce08e01cf" translate="yes" xml:space="preserve">
          <source>The advantage of being cooperative is that a lot of the overhead of doing a context switch (switching between threads) is gone.</source>
          <target state="translated">合作的好处是,做上下文切换(线程间切换)的很多开销都没有了。</target>
        </trans-unit>
        <trans-unit id="a0483a1a0c683c09f20ecc1fd6d2bcfd420e1d72" translate="yes" xml:space="preserve">
          <source>The algorithm has a maximum password length limit of 71 characters (see &lt;a href=&quot;https://security.stackexchange.com/questions/39849/does-bcrypt-have-a-maximum-password-length#answer-39851&quot;&gt;this comment&lt;/a&gt; on stackoverflow).</source>
          <target state="translated">该算法的最大密码长度限制为71个字符（请参阅有关stackoverflow的&lt;a href=&quot;https://security.stackexchange.com/questions/39849/does-bcrypt-have-a-maximum-password-length#answer-39851&quot;&gt;此注释&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3294db75e75614f5dd83452e28cedbf76148708a" translate="yes" xml:space="preserve">
          <source>The alphabet uses &lt;code&gt;'-'&lt;/code&gt; instead of &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;'_'&lt;/code&gt; instead of &lt;code&gt;'/'&lt;/code&gt;.</source>
          <target state="translated">字母使用 &lt;code&gt;'-'&lt;/code&gt; 代替 &lt;code&gt;'+'&lt;/code&gt; 和 &lt;code&gt;'_'&lt;/code&gt; 代替 &lt;code&gt;'/'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="035793fc19fac18085aa0de163c96552ee327c1a" translate="yes" xml:space="preserve">
          <source>The amount of time in seconds between keepalive probes.</source>
          <target state="translated">以秒为单位的保持生命探测的时间。</target>
        </trans-unit>
        <trans-unit id="33aeecac47306b5c4fc40f7e0d08938931d0cd08" translate="yes" xml:space="preserve">
          <source>The amount of time in seconds the connection must be idle before sending keepalive probes.</source>
          <target state="translated">在发送keepalive探针之前,连接必须空闲的时间,以秒为单位。</target>
        </trans-unit>
        <trans-unit id="3194bc97bbc1a908e06eeb6fcf94b91e73e87ffb" translate="yes" xml:space="preserve">
          <source>The annotation can then be applied to various items, including:</source>
          <target state="translated">然后,该注释可以应用于各种项目,包括:</target>
        </trans-unit>
        <trans-unit id="d085207e361cfeb24b4e38a7420e6c26047be8ad" translate="yes" xml:space="preserve">
          <source>The answer is that when we defined an &lt;code&gt;initialize&lt;/code&gt; method Crystal defined a &lt;code&gt;new&lt;/code&gt; method for us, like this:</source>
          <target state="translated">答案是，当我们定义一个 &lt;code&gt;initialize&lt;/code&gt; 方法时，Crystal 为我们定义了一个 &lt;code&gt;new&lt;/code&gt; 方法，如下所示：</target>
        </trans-unit>
        <trans-unit id="f5ee68dc06a5633f096fb966481951f55ea2e0bc" translate="yes" xml:space="preserve">
          <source>The argument to sizeof is a &lt;a href=&quot;type_grammar&quot;&gt;type&lt;/a&gt; and is often combined with &lt;a href=&quot;typeof&quot;&gt;typeof&lt;/a&gt;:</source>
          <target state="translated">sizeof的参数是一种&lt;a href=&quot;type_grammar&quot;&gt;类型&lt;/a&gt;，通常与&lt;a href=&quot;typeof&quot;&gt;typeof&lt;/a&gt;结合使用：</target>
        </trans-unit>
        <trans-unit id="323085345e91d82985e77cff6266ff2095686196" translate="yes" xml:space="preserve">
          <source>The argument to the expression is a &lt;a href=&quot;type_grammar&quot;&gt;type&lt;/a&gt;.</source>
          <target state="translated">表达式的参数是&lt;a href=&quot;type_grammar&quot;&gt;type&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da9759706afb143256972cc4ed251794bf1313f8" translate="yes" xml:space="preserve">
          <source>The arguments are packed into an &lt;a href=&quot;https://crystal-lang.org/api/Crystal/Macros/ArrayLiteral.html&quot;&gt;&lt;code&gt;ArrayLiteral&lt;/code&gt;&lt;/a&gt; and passed to the macro.</source>
          <target state="translated">参数打包到&lt;a href=&quot;https://crystal-lang.org/api/Crystal/Macros/ArrayLiteral.html&quot;&gt; &lt;code&gt;ArrayLiteral&lt;/code&gt; 中&lt;/a&gt;并传递给宏。</target>
        </trans-unit>
        <trans-unit id="a91dcd292727eb9f345153e9183d1ce699549f42" translate="yes" xml:space="preserve">
          <source>The arguments can be string literals, symbol literals or plain names:</source>
          <target state="translated">参数可以是字符串文字、符号文字或普通名称。</target>
        </trans-unit>
        <trans-unit id="a636e8953678708ca0f21117f0ec983b750f49f3" translate="yes" xml:space="preserve">
          <source>The array's generic type argument &lt;code&gt;T&lt;/code&gt; is inferred from the types of the elements inside the literal. When all elements of the array have the same type, &lt;code&gt;T&lt;/code&gt; equals to that. Otherwise it will be a union of all element types.</source>
          <target state="translated">数组的泛型类型参数 &lt;code&gt;T&lt;/code&gt; 是从文字内部的元素类型推断出来的。当数组的所有元素都具有相同的类型时， &lt;code&gt;T&lt;/code&gt; 等于该类型。否则它将是所有元素类型的并集。</target>
        </trans-unit>
        <trans-unit id="02666c97b2fb79ea47a69ae6a189d86846914eff" translate="yes" xml:space="preserve">
          <source>The backslash character \ can be used to escape ^ or - and is otherwise ignored unless it appears at the end of a range or set.</source>
          <target state="translated">反斜杠字符&quot;/&quot;可以用来转义&quot;^&quot;或&quot;-&quot;,否则会被忽略,除非它出现在一个范围或集合的末尾。</target>
        </trans-unit>
        <trans-unit id="5d86a5e86d7e691edfb9db88221d3ee7f764eb3b" translate="yes" xml:space="preserve">
          <source>The begin and end values do not necessarily need to be of the same type: &lt;code&gt;true..1&lt;/code&gt; is a valid range, although pretty useless &lt;code&gt;Enumerable&lt;/code&gt; methods won't work with incompatible types. They need at least to be comparable.</source>
          <target state="translated">begin和end值不必一定是同一类型： &lt;code&gt;true..1&lt;/code&gt; 是有效范围，尽管相当无用的 &lt;code&gt;Enumerable&lt;/code&gt; 方法不适用于不兼容的类型。他们至少需要具有可比性。</target>
        </trans-unit>
        <trans-unit id="cd4ddc951b26d069c0e772446bd498bd0bee508a" translate="yes" xml:space="preserve">
          <source>The behavior of the pool can be configured from a set of parameters that can appear as query string in the connection URI.</source>
          <target state="translated">池的行为可以通过一组参数进行配置,这些参数可以作为查询字符串出现在连接URI中。</target>
        </trans-unit>
        <trans-unit id="669ab7eefaa697304280f141aa155d3622171703" translate="yes" xml:space="preserve">
          <source>The binary representation of this enum is defined to be same representation as the permission bits of a unix &lt;code&gt;st_mode&lt;/code&gt; field. &lt;code&gt;&lt;a href=&quot;permissions&quot;&gt;File::Permissions&lt;/a&gt;&lt;/code&gt; can also be compared to its underlying bitset, for example &lt;code&gt;File::Permissions::All == 0o777&lt;/code&gt; will always be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">将该枚举的二进制表示形式定义为与unix &lt;code&gt;st_mode&lt;/code&gt; 字段的允许位相同的表示形式。 &lt;code&gt;&lt;a href=&quot;permissions&quot;&gt;File::Permissions&lt;/a&gt;&lt;/code&gt; 也可以与其底层位进行比较，例如 &lt;code&gt;File::Permissions::All == 0o777&lt;/code&gt; 将始终为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ab2f00524963337e2687e919d2ba4266b9852d6" translate="yes" xml:space="preserve">
          <source>The block is called for each ascii character (codepoint less than &lt;code&gt;0x80&lt;/code&gt;) and determines whether the value is to be encoded. When the return value is falsey, the character is encoded. Non-ASCII characters are always encoded.</source>
          <target state="translated">将为每个ascii字符（代码点小于 &lt;code&gt;0x80&lt;/code&gt; ）调用该块，并确定是否要对该值进行编码。当返回值为false时，将对字符进行编码。非ASCII字符始终被编码。</target>
        </trans-unit>
        <trans-unit id="8735c5f0fae248dce7382e805df5c3e5cb97abe9" translate="yes" xml:space="preserve">
          <source>The block is called for each percent-encoded ASCII character and determines whether the value is to be decoded. When the return value is falsey, the character is decoded. Non-ASCII characters are always decoded.</source>
          <target state="translated">该块对每个百分数编码的ASCII字符进行调用,并决定是否对该值进行解码。当返回值为falsey时,该字符将被解码。非ASCII字符总是被解码。</target>
        </trans-unit>
        <trans-unit id="b40db3eab6d1f82e10559b92e03e896430461fe8" translate="yes" xml:space="preserve">
          <source>The block must implement a comparison between two elements &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, where &lt;code&gt;a &amp;lt; b&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;a == b&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;a &amp;gt; b&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;. The comparison operator &lt;code&gt;&lt;a href=&quot;array#(other:Array)-instance-method&quot;&gt;#&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt; can be used for this.</source>
          <target state="translated">该块必须实现两个元素&lt;em&gt;a&lt;/em&gt;和&lt;em&gt;b&lt;/em&gt;之间的比较，其中 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 返回 &lt;code&gt;-1&lt;/code&gt; ， &lt;code&gt;a == b&lt;/code&gt; 返回 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;a &amp;gt; b&lt;/code&gt; 返回 &lt;code&gt;1&lt;/code&gt; 。比较运算符 &lt;code&gt;&lt;a href=&quot;array#(other:Array)-instance-method&quot;&gt;#&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt; 可以用于此目的。</target>
        </trans-unit>
        <trans-unit id="aa9315c1524c78e7c0ddfc771ed7729a661d31c6" translate="yes" xml:space="preserve">
          <source>The block must implement a comparison between two elements &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, where &lt;code&gt;a &amp;lt; b&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;a == b&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;a &amp;gt; b&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;. The comparison operator &lt;code&gt;&lt;a href=&quot;slice#(other:Slice(U))forallU-instance-method&quot;&gt;#&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt; can be used for this.</source>
          <target state="translated">该块必须实现两个元素&lt;em&gt;a&lt;/em&gt;和&lt;em&gt;b&lt;/em&gt;之间的比较，其中 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 返回 &lt;code&gt;-1&lt;/code&gt; ， &lt;code&gt;a == b&lt;/code&gt; 返回 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;a &amp;gt; b&lt;/code&gt; 返回 &lt;code&gt;1&lt;/code&gt; 。比较运算符 &lt;code&gt;&lt;a href=&quot;slice#(other:Slice(U))forallU-instance-method&quot;&gt;#&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt; 可以用于此目的。</target>
        </trans-unit>
        <trans-unit id="d4af3fea31bddb946015db5a49cbbc1446d44eaf" translate="yes" xml:space="preserve">
          <source>The block variable &lt;code&gt;second&lt;/code&gt; also includes the &lt;code&gt;Nil&lt;/code&gt; type because the last &lt;code&gt;yield&lt;/code&gt; expression didn't include a second argument.</source>
          <target state="translated">块变量 &lt;code&gt;second&lt;/code&gt; 还包含 &lt;code&gt;Nil&lt;/code&gt; 类型，因为最后一个 &lt;code&gt;yield&lt;/code&gt; 表达式不包含第二个参数。</target>
        </trans-unit>
        <trans-unit id="65004e032fc6f16412331ec9e39888aa714ed45c" translate="yes" xml:space="preserve">
          <source>The buffer is allocated on the stack, avoiding a heap allocation.</source>
          <target state="translated">缓冲区是在栈上分配的,避免了堆分配。</target>
        </trans-unit>
        <trans-unit id="5e281794f250e6bc9b7f49810850e5b085ce50f5" translate="yes" xml:space="preserve">
          <source>The buffering behaviour can be turned on/off with the &lt;code&gt;&lt;a href=&quot;buffered#sync=(sync)-instance-method&quot;&gt;#sync=&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;buffered#read_buffering=(read_buffering)-instance-method&quot;&gt;#read_buffering=&lt;/a&gt;&lt;/code&gt; methods.</source>
          <target state="translated">缓冲行为可以开/关断与 &lt;code&gt;&lt;a href=&quot;buffered#sync=(sync)-instance-method&quot;&gt;#sync=&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;buffered#read_buffering=(read_buffering)-instance-method&quot;&gt;#read_buffering=&lt;/a&gt;&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="c5fac4f5ddc22b92b6edab3ab53e0bf3578ea340" translate="yes" xml:space="preserve">
          <source>The build metadata of this semantic version</source>
          <target state="translated">该语义版本的构建元数据。</target>
        </trans-unit>
        <trans-unit id="8c028c8d7c168ec897f0714ce745b6b98bb2fdf8" translate="yes" xml:space="preserve">
          <source>The byte following the end of this slice (but not included in it) is defined to be zero. This allows passing the result of this function into C functions that expect a null-terminated &lt;code&gt;&lt;a href=&quot;uint16&quot;&gt;UInt16&lt;/a&gt;*&lt;/code&gt;.</source>
          <target state="translated">该切片末尾的字节（但不包含在其中）被定义为零。这允许将此函数的结果传递到期望以null结尾的 &lt;code&gt;&lt;a href=&quot;uint16&quot;&gt;UInt16&lt;/a&gt;*&lt;/code&gt; C函数中。</target>
        </trans-unit>
        <trans-unit id="12a7044b83e5b65e1f3f0799be7549d67873e29d" translate="yes" xml:space="preserve">
          <source>The bytes are encoded into a string of two-digit hexadecimal number (00-ff) per byte.</source>
          <target state="translated">字节被编码成一串每字节两位数的十六进制数字(00-ff)。</target>
        </trans-unit>
        <trans-unit id="b1dc181c589c2c81315127fbf5bd01314efb8a97" translate="yes" xml:space="preserve">
          <source>The bytesize returned by the block must be less than or equal to the capacity given to this String, otherwise &lt;code&gt;&lt;a href=&quot;argumenterror&quot;&gt;ArgumentError&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">该块返回的字节大小必须小于或等于为此String赋予的容量，否则 &lt;code&gt;&lt;a href=&quot;argumenterror&quot;&gt;ArgumentError&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ac8f2a086d4777e7a9b6e99489d3c44dad2d5b4" translate="yes" xml:space="preserve">
          <source>The calculation defaults to 5 seconds. During this stage we run the block in sets of the size calculated in the warmup stage. The measurements for those sets are then used to calculate the mean and standard deviation, which are then reported. Additionally we compare the means to that of the fastest.</source>
          <target state="translated">计算的默认值为5秒。在这一阶段,我们以热身阶段计算出的大小为单位运行该块。这些组的测量结果被用来计算平均值和标准差,然后报告。此外,我们将平均值与最快的平均值进行比较。</target>
        </trans-unit>
        <trans-unit id="59713a7aaa52a5d1c1bd0110014985176aee3f58" translate="yes" xml:space="preserve">
          <source>The calendaric calculations are based on the rules of the proleptic Gregorian calendar as specified in &lt;a href=&quot;http://xml.coverpages.org/ISO-FDIS-8601.pdf&quot;&gt;ISO 8601&lt;/a&gt;. Leap seconds are ignored.</source>
          <target state="translated">日历计算是基于&lt;a href=&quot;http://xml.coverpages.org/ISO-FDIS-8601.pdf&quot;&gt;ISO 8601中&lt;/a&gt;规定的格里高利历日历的规则。ap秒将被忽略。</target>
        </trans-unit>
        <trans-unit id="e3e66a336341e952658cec3e2d3462555ba10f88" translate="yes" xml:space="preserve">
          <source>The chained assignment is not only available to &lt;a href=&quot;local_variables&quot;&gt;local variables&lt;/a&gt; but also to &lt;a href=&quot;methods_and_instance_variables&quot;&gt;instance variables&lt;/a&gt;, &lt;a href=&quot;class_variables&quot;&gt;class variables&lt;/a&gt; and setter methods (methods that end with &lt;code&gt;=&lt;/code&gt;).</source>
          <target state="translated">链式分配不仅适用于&lt;a href=&quot;local_variables&quot;&gt;局部变量&lt;/a&gt;，还适用于&lt;a href=&quot;methods_and_instance_variables&quot;&gt;实例变量&lt;/a&gt;，&lt;a href=&quot;class_variables&quot;&gt;类变量&lt;/a&gt;和设置方法（以 &lt;code&gt;=&lt;/code&gt; 结尾的方法）。</target>
        </trans-unit>
        <trans-unit id="35a8e6b73f0e3868ba4897491ad122eaaa7fc6aa" translate="yes" xml:space="preserve">
          <source>The character representing the end of a C string.</source>
          <target state="translated">代表C字符串结束的字符。</target>
        </trans-unit>
        <trans-unit id="208619b92138c118ddc080424dc40dd23a936289" translate="yes" xml:space="preserve">
          <source>The class that signals that there are no more elements in an &lt;code&gt;&lt;a href=&quot;../iterator&quot;&gt;Iterator&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">表示 &lt;code&gt;&lt;a href=&quot;../iterator&quot;&gt;Iterator&lt;/a&gt;&lt;/code&gt; 中没有更多元素的类。</target>
        </trans-unit>
        <trans-unit id="246e83a0b2cce47050e6415df87dfb215152ad82" translate="yes" xml:space="preserve">
          <source>The classic &quot;hello world&quot; program looks like this in Crystal:</source>
          <target state="translated">经典的 &quot;hello world &quot;程序在Crystal中是这样的。</target>
        </trans-unit>
        <trans-unit id="14e81c614990e3fc64f551193ff5594abcd10c89" translate="yes" xml:space="preserve">
          <source>The closing delimiter may be followed by a number of optional modifiers to adjust the matching behaviour of the regular expression.</source>
          <target state="translated">结尾定界符后面可以跟一些可选的修饰符来调整正则表达式的匹配行为。</target>
        </trans-unit>
        <trans-unit id="7486c68cd22b715cee9aba70b79ecf03143997ff" translate="yes" xml:space="preserve">
          <source>The code you write is up to you, but how you write it impacts whether people want to use your library and/or help you maintain it.</source>
          <target state="translated">你写的代码由你自己决定,但你如何写它会影响人们是否愿意使用你的库和/或帮助你维护它。</target>
        </trans-unit>
        <trans-unit id="60347285fa183e9559a829be9b82c53c06646d0f" translate="yes" xml:space="preserve">
          <source>The codepoint is the integer representation. The Universal Coded Character Set (UCS) standard, commonly known as Unicode, assigns names and meanings to numbers, these numbers are called codepoints.</source>
          <target state="translated">编码点是整数的表示方法。通用编码字符集(UCS)标准,通常被称为Unicode,为数字指定名称和含义,这些数字被称为码点。</target>
        </trans-unit>
        <trans-unit id="330d01950261d11e512866b0d0ec968a379ddfe6" translate="yes" xml:space="preserve">
          <source>The color &lt;code&gt;:default&lt;/code&gt; will just leave the object as it is (but it's an &lt;code&gt;&lt;a href=&quot;colorize/object&quot;&gt;Colorize::Object&lt;/a&gt;(&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;)&lt;/code&gt; then). That's handy in for example conditions:</source>
          <target state="translated">&lt;code&gt;:default&lt;/code&gt; 的颜色只会使对象保持原样（但是它是 &lt;code&gt;&lt;a href=&quot;colorize/object&quot;&gt;Colorize::Object&lt;/a&gt;(&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;)&lt;/code&gt; ）。在以下情况下很方便：</target>
        </trans-unit>
        <trans-unit id="abea7844f29e40b2cc5ce68386f0a7ee86b755a3" translate="yes" xml:space="preserve">
          <source>The column where this node ends.</source>
          <target state="translated">此节点结束的栏目。</target>
        </trans-unit>
        <trans-unit id="660441ea48991c5819506361f40f8e3d2e10c1f2" translate="yes" xml:space="preserve">
          <source>The column where this node starts.</source>
          <target state="translated">此节点开始的列。</target>
        </trans-unit>
        <trans-unit id="6ec5d7f24e502f7603f8d48f715a8f383deed6ff" translate="yes" xml:space="preserve">
          <source>The command creates a static website in &lt;code&gt;output_dir&lt;/code&gt; (default &lt;code&gt;./docs&lt;/code&gt;), consisting of HTML files for each Crystal type, in a folder structure mirroring the Crystal namespaces. The entrypoint &lt;code&gt;docs/index.html&lt;/code&gt; can be opened by any web browser. The entire API docs are also stored as a JSON document in &lt;code&gt;$output_dir/index.json&lt;/code&gt;.</source>
          <target state="translated">该命令将在 &lt;code&gt;output_dir&lt;/code&gt; （默认为 &lt;code&gt;./docs&lt;/code&gt; ）中创建一个静态网站，该网站由每种Crystal类型的HTML文件组成，该网站位于镜像Crystal名称空间的文件夹结构中。入口点 &lt;code&gt;docs/index.html&lt;/code&gt; 可以通过任何Web浏览器打开。整个API文档也作为JSON文档存储在 &lt;code&gt;$output_dir/index.json&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d213795e162c8a7f9cc897850b304185dc131844" translate="yes" xml:space="preserve">
          <source>The comparison is based on the instant time-line, even if the local date-time representation (wall clock) would compare differently.</source>
          <target state="translated">这种比较是基于即时时间线的,即使本地的日期-时间表示(挂钟)也会有不同的比较。</target>
        </trans-unit>
        <trans-unit id="bccff557d651a67be956e45704f6c6d9373e2852" translate="yes" xml:space="preserve">
          <source>The comparison is performed strictly lexically: &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;./foo&lt;/code&gt; are &lt;em&gt;not&lt;/em&gt; treated as equal. To compare paths semantically, they need to be normalized and converted to the same kind.</source>
          <target state="translated">该比较严格词法执行： &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;./foo&lt;/code&gt; 被&lt;em&gt;不&lt;/em&gt;视为相等。为了从语义上比较路径，需要对其进行规范化并将其转换为相同的路径。</target>
        </trans-unit>
        <trans-unit id="9c5e704caf82b468bda81e87129e91c0a1ad8163" translate="yes" xml:space="preserve">
          <source>The comparison operator is usually used to sort values:</source>
          <target state="translated">比较运算符通常用于对值进行排序。</target>
        </trans-unit>
        <trans-unit id="8f30e226d5c7e4d38dd234fed09b1a41dc52b2ae" translate="yes" xml:space="preserve">
          <source>The comparison operator.</source>
          <target state="translated">比较运算符。</target>
        </trans-unit>
        <trans-unit id="0fa25ea08f80503e909fd965e8fb970b9b1b0f4e" translate="yes" xml:space="preserve">
          <source>The comparison operator. Returns &lt;code&gt;0&lt;/code&gt; if the two objects are equal, a negative number if this object is considered less than &lt;em&gt;other&lt;/em&gt;, a positive number if this object is considered greter than &lt;em&gt;other&lt;/em&gt;, or &lt;code&gt;nil&lt;/code&gt; if the two objects are not comparable.</source>
          <target state="translated">比较运算符。返回 &lt;code&gt;0&lt;/code&gt; ，如果两个对象是相等的，如果该对象被认为是小于一个负数&lt;em&gt;其它&lt;/em&gt;，如果该对象被认为比greter的正数&lt;em&gt;其他&lt;/em&gt;，或 &lt;code&gt;nil&lt;/code&gt; 如果两个对象是不可比的。</target>
        </trans-unit>
        <trans-unit id="0b20f37bebb82e98c5c70ee9f85d2cc23547b285" translate="yes" xml:space="preserve">
          <source>The compile-time type can be seen by using &lt;a href=&quot;typeof&quot;&gt;typeof&lt;/a&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;typeof&quot;&gt;typeof&lt;/a&gt;可以看到编译时类型：</target>
        </trans-unit>
        <trans-unit id="901b23955e8f736b478daa8b55c41b490c08a203" translate="yes" xml:space="preserve">
          <source>The compiler infers this attribute for a method if it invokes a method that is marked as &lt;code&gt;@[Raises]&lt;/code&gt; or raises (recursively).</source>
          <target state="translated">如果编译器调用标记为 &lt;code&gt;@[Raises]&lt;/code&gt; 或抬高（递归）的方法，则该方法将为该方法推断此属性。</target>
        </trans-unit>
        <trans-unit id="4f88ccffd3e268d871f2056efb1090cfcf65873f" translate="yes" xml:space="preserve">
          <source>The compiler is usually moderately smart about the type of local variables. For example:</source>
          <target state="translated">编译器对局部变量的类型通常是适度聪明的。例如:</target>
        </trans-unit>
        <trans-unit id="e296b93503486e9e50ffce4c0ba5d7e1f49d91f4" translate="yes" xml:space="preserve">
          <source>The compiler knows that after the block, &lt;code&gt;x&lt;/code&gt; can be Int32 or String (it could know that it will always be String because the method always yields; this may improve in the future).</source>
          <target state="translated">编译器知道在该块之后， &lt;code&gt;x&lt;/code&gt; 可以是Int32或String（它可以知道它将始终是String，因为该方法始终会屈服；将来可能会有所改善）。</target>
        </trans-unit>
        <trans-unit id="53f8ad6624549840c274a29bc1f7426230ff0a0e" translate="yes" xml:space="preserve">
          <source>The compiler knows what types are in each key, so when indexing a named tuple with a symbol literal the compiler will return the value for that key and with the expected type, like in the above snippet. Indexing with a symbol literal for which there's no key will give a compile-time error.</source>
          <target state="translated">编译器知道每个键中的类型,所以当用符号文字索引一个命名元组时,编译器将返回该键的值,并且是预期的类型,就像上面的片段一样。如果使用一个没有键的符号文字索引,将给出一个编译时错误。</target>
        </trans-unit>
        <trans-unit id="1bc6bfc0d4c299392bdbd27356b3219c7f083103" translate="yes" xml:space="preserve">
          <source>The compiler knows what types are in each position, so when indexing a tuple with an integer literal the compiler will return the value in that index and with the expected type, like in the above snippet. Indexing with an integer literal outside the bounds of the tuple will give a compile-time error.</source>
          <target state="translated">编译器知道每个位置上有什么类型,所以当用整数文字索引一个元组时,编译器将返回该索引中的值和预期的类型,就像上面的片段一样。用一个整数文字索引在元组的边界之外时,将给出一个编译时错误。</target>
        </trans-unit>
        <trans-unit id="bbe6a33fa8b555c81cd9d23de5cc4566013ad8b2" translate="yes" xml:space="preserve">
          <source>The compiler recognizes that in case &lt;code&gt;string&lt;/code&gt; is &lt;code&gt;Nil&lt;/code&gt;, the right hand side of the expression &lt;code&gt;string || raise&lt;/code&gt; will be evaluated. Since &lt;code&gt;typeof(raise &quot;Empty input&quot;)&lt;/code&gt; is &lt;code&gt;NoReturn&lt;/code&gt; the execution would not return to the current scope in that case. That leaves only &lt;code&gt;String&lt;/code&gt; as resulting type of the expression.</source>
          <target state="translated">编译器识别出如果 &lt;code&gt;string&lt;/code&gt; 为 &lt;code&gt;Nil&lt;/code&gt; ，则表达式 &lt;code&gt;string || raise&lt;/code&gt; 的右侧 加薪将被评估。由于 &lt;code&gt;typeof(raise &quot;Empty input&quot;)&lt;/code&gt; 为 &lt;code&gt;NoReturn&lt;/code&gt; ，在这种情况下，执行不会返回到当前作用域。剩下的只有 &lt;code&gt;String&lt;/code&gt; 作为表达式的结果类型。</target>
        </trans-unit>
        <trans-unit id="9fd63548bcd1f9432f120809cb637de7949597f1" translate="yes" xml:space="preserve">
          <source>The compiler uses the &lt;code&gt;CRYSTAL_LIBRARY_PATH&lt;/code&gt; environment variable as a first lookup destination for static and dynamic libraries that are to be linked. This can be used to provide static versions of libraries that are also available as dynamic libraries.</source>
          <target state="translated">编译器使用 &lt;code&gt;CRYSTAL_LIBRARY_PATH&lt;/code&gt; 环境变量作为要链接的静态和动态库的第一个查找目标。这可以用来提供静态版本的库，这些版本也可以作为动态库使用。</target>
        </trans-unit>
        <trans-unit id="d112ea3968e90628ecef4e96c3f030557bcc29d4" translate="yes" xml:space="preserve">
          <source>The compiler will always do this for classes and structs under the same hierarchy: it will find the first superclass from which all types inherit from (excluding &lt;code&gt;Reference&lt;/code&gt;, &lt;code&gt;Value&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Float&lt;/code&gt;). If it can't find one, the type union remains.</source>
          <target state="translated">编译器将始终对同一层次结构下的类和结构执行此操作：它将找到所有类型都从其继承的第一个超类（不包括 &lt;code&gt;Reference&lt;/code&gt; ， &lt;code&gt;Value&lt;/code&gt; ， &lt;code&gt;Int&lt;/code&gt; 和 &lt;code&gt;Float&lt;/code&gt; ）。如果找不到，则类型联合保留。</target>
        </trans-unit>
        <trans-unit id="9aa42ab2fbe7576856d80d14142091ab932b6491" translate="yes" xml:space="preserve">
          <source>The compiler will always resolve a type union to a virtual type if they are under the same hierarchy:</source>
          <target state="translated">如果它们在同一个层次结构下,编译器将始终把类型联合解析为虚拟类型。</target>
        </trans-unit>
        <trans-unit id="f6a828022c5a606925e47b002f9dc2a5f92de454" translate="yes" xml:space="preserve">
          <source>The compiler will automatically declare a &lt;code&gt;status_ptr&lt;/code&gt; variable of type &lt;code&gt;Int32&lt;/code&gt;, because the argument is an &lt;code&gt;Int32*&lt;/code&gt;.</source>
          <target state="translated">编译器将自动声明 &lt;code&gt;Int32&lt;/code&gt; 类型的 &lt;code&gt;status_ptr&lt;/code&gt; 变量，因为该参数是 &lt;code&gt;Int32*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7116ec73e25c2ce43e86e6ce030554ec2d346a16" translate="yes" xml:space="preserve">
          <source>The compiler will try to be as smart as possible to require less explicit type restrictions. For example, if assigning an &lt;code&gt;if&lt;/code&gt; expression, type will be inferred from the &lt;code&gt;then&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; branches:</source>
          <target state="translated">编译器将尝试变得尽可能聪明，以要求较少的显式类型限制。例如，如果分配一个 &lt;code&gt;if&lt;/code&gt; 表达式，则将从 &lt;code&gt;then&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 分支中推断出type ：</target>
        </trans-unit>
        <trans-unit id="a27fbf176c173a4869ddaa838718beb1520d753e" translate="yes" xml:space="preserve">
          <source>The condition is first tested and, if &lt;em&gt;truthy&lt;/em&gt;, the body is executed. That is, the body might never be executed.</source>
          <target state="translated">首先测试条件，如果&lt;em&gt;是&lt;/em&gt;，则执行身体。也就是说，尸体可能永远不会被执行。</target>
        </trans-unit>
        <trans-unit id="45d26e86bf874f16afbe8a5db86b9dcf4fbd0f35" translate="yes" xml:space="preserve">
          <source>The current event kind.</source>
          <target state="translated">当前事件种。</target>
        </trans-unit>
        <trans-unit id="e5b5bca50bbcb72e98e43922b4012518a5698ff3" translate="yes" xml:space="preserve">
          <source>The data format must follow the format of &lt;code&gt;mime.types&lt;/code&gt;: Each line declares a MIME type followed by a whitespace-separated list of extensions mapped to this type. Everything following a &lt;code&gt;#&lt;/code&gt; is considered a comment until the end of line. Empy line are ignored.</source>
          <target state="translated">数据格式必须遵循 &lt;code&gt;mime.types&lt;/code&gt; 的格式：每行声明一个MIME类型，后跟一个以空格分隔的映射到该类型的扩展列表。直到 &lt;code&gt;#&lt;/code&gt; 为止的所有内容都被视为注释。空行被忽略。</target>
        </trans-unit>
        <trans-unit id="b6ac557b14252defbc297671bb0f85f77d4fcb5f" translate="yes" xml:space="preserve">
          <source>The default PRNG is &lt;code&gt;&lt;a href=&quot;random/pcg32&quot;&gt;Random::PCG32&lt;/a&gt;&lt;/code&gt; which has a good overall statistical distribution (low bias of generated numbers) and is fast for overall usages on different platforms, but isn't cryptographically secure. If a third party has access to some generated numbers, she may deduce incoming numbers, putting your application at risk.</source>
          <target state="translated">默认的PRNG是 &lt;code&gt;&lt;a href=&quot;random/pcg32&quot;&gt;Random::PCG32&lt;/a&gt;&lt;/code&gt; ，它具有良好的总体统计分布（生成的数字的偏差较小），并且在不同平台上的总体使用速度很快，但并不安全。如果第三方可以访问某些生成的号码，则她可能会推断出传入的号码，从而使您的应用程序处于危险之中。</target>
        </trans-unit>
        <trans-unit id="bdd51ac360b10bcd84b0c8f91e4e2989fd2773ff" translate="yes" xml:space="preserve">
          <source>The default behaviour is to load the internal defaults as well as the OS-provided MIME database. This can be disabled with &lt;em&gt;load_defaults&lt;/em&gt; set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">默认行为是加载内部默认值以及操作系统提供的MIME数据库。可以通过将&lt;em&gt;load_defaults&lt;/em&gt;设置为 &lt;code&gt;false&lt;/code&gt; 来禁用它。</target>
        </trans-unit>
        <trans-unit id="dad7af7b0f876da9aa949c42f24000929273f588" translate="yes" xml:space="preserve">
          <source>The default formatter outputs the file and line style command for failing specs which makes it easy to rerun just this individual spec.</source>
          <target state="translated">默认的formatter会输出失败规格的文件和行式命令,这使得它很容易地重新运行只是这个单独的规格。</target>
        </trans-unit>
        <trans-unit id="25b8cc0309c25e817367b59837ebb7571042e378" translate="yes" xml:space="preserve">
          <source>The default receiver within a captured block can't be changed by using &lt;code&gt;with ... yield&lt;/code&gt;.</source>
          <target state="translated">不能通过 &lt;code&gt;with ... yield&lt;/code&gt; 使用来更改捕获块中的默认接收器。</target>
        </trans-unit>
        <trans-unit id="f44188190e8ff07b62a15512f4e2653bbf1da67d" translate="yes" xml:space="preserve">
          <source>The default value can also be a &lt;code&gt;Type.new(...)&lt;/code&gt; method or a class method with a return type restriction.</source>
          <target state="translated">默认值也可以是 &lt;code&gt;Type.new(...)&lt;/code&gt; 方法或具有返回类型限制的类方法。</target>
        </trans-unit>
        <trans-unit id="af976fa886c4f7b664fc57e291778fd6b49e246c" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2405836e0455b607d437f1441a12ee51443e3dfc" translate="yes" xml:space="preserve">
          <source>The definitions of &quot;concurrency&quot; and &quot;parallelism&quot; sometimes get mixed up, but they are not the same.</source>
          <target state="translated">&quot;并发 &quot;和 &quot;并行 &quot;的定义有时会混淆,但它们是不一样的。</target>
        </trans-unit>
        <trans-unit id="56cc8132a44e585c5a836cac7589ad9dd027f5da" translate="yes" xml:space="preserve">
          <source>The delimiter character &lt;code&gt;/&lt;/code&gt; must be escaped inside slash-delimited regular expression literals. Note that special characters of the PCRE syntax need to be escaped if they are intended as literal characters.</source>
          <target state="translated">分隔符 &lt;code&gt;/&lt;/code&gt; 必须在斜杠分隔的正则表达式文字中进行转义。请注意，如果要将PCRE语法的特殊字符用作文字字符，则需要对其进行转义。</target>
        </trans-unit>
        <trans-unit id="005cdeadc39a856e459e5bd8473d96fd7f82d81a" translate="yes" xml:space="preserve">
          <source>The development is possible thanks to the community's effort, &lt;a href=&quot;https://www.84codes.com/&quot;&gt;84codes&lt;/a&gt;' support, and every &lt;a href=&quot;https://crystal-lang.org/sponsors&quot;&gt;BountySource supporter&lt;/a&gt;.</source>
          <target state="translated">感谢社区的努力，&lt;a href=&quot;https://www.84codes.com/&quot;&gt;84codes&lt;/a&gt;的支持以及每个&lt;a href=&quot;https://crystal-lang.org/sponsors&quot;&gt;BountySource支持者&lt;/a&gt;的支持，才有可能进行开发。</target>
        </trans-unit>
        <trans-unit id="e7896d2ab08699e91d14ae92a8d97f1b60ffffbf" translate="yes" xml:space="preserve">
          <source>The difference between using &lt;code&gt;do ... end&lt;/code&gt; and &lt;code&gt;{ ... }&lt;/code&gt; is that &lt;code&gt;do ... end&lt;/code&gt; binds to the left-most call, while &lt;code&gt;{ ... }&lt;/code&gt; binds to the right-most call:</source>
          <target state="translated">两者的区别 &lt;code&gt;do ... end&lt;/code&gt; 和 &lt;code&gt;{ ... }&lt;/code&gt; 的是， &lt;code&gt;do ... end&lt;/code&gt; 结合到最左边的通话，而 &lt;code&gt;{ ... }&lt;/code&gt; 绑定到最右边的电话：</target>
        </trans-unit>
        <trans-unit id="d932293ad1229ee6d59947cbf56bffd1ddfe6045" translate="yes" xml:space="preserve">
          <source>The directives are:</source>
          <target state="translated">这些指令是:</target>
        </trans-unit>
        <trans-unit id="d3bece92e462e673997e5de7aea3061108ec3fdb" translate="yes" xml:space="preserve">
          <source>The directory used in these examples contains the two regular files (&lt;code&gt;config.h&lt;/code&gt; and &lt;code&gt;main.rb&lt;/code&gt;), the parent directory (&lt;code&gt;..&lt;/code&gt;), and the directory itself (&lt;code&gt;.&lt;/code&gt;).</source>
          <target state="translated">这些示例中使用的目录包含两个常规文件（ &lt;code&gt;config.h&lt;/code&gt; 和 &lt;code&gt;main.rb&lt;/code&gt; ），父目录（ &lt;code&gt;..&lt;/code&gt; ）和目录本身（ &lt;code&gt;.&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8c6593ecc33a17f47a51d532e371454d0a2e960a" translate="yes" xml:space="preserve">
          <source>The document this builder builds.</source>
          <target state="translated">这个构建者构建的文档。</target>
        </trans-unit>
        <trans-unit id="a72fae4adb9e9233849f2511abb367174fc0113f" translate="yes" xml:space="preserve">
          <source>The documentation of a method is included into the method summary and the method details. The former includes only the first line, the latter includes the entire documentation. In short, it is preferred to:</source>
          <target state="translated">一种方法的文件包括在方法摘要和方法细节中。前者只包括第一行,后者包括整个文件。总之,最好是:</target>
        </trans-unit>
        <trans-unit id="0937a36b3d81ac8458f6ad89ee30d846b74b3e12" translate="yes" xml:space="preserve">
          <source>The documentation of the function says:</source>
          <target state="translated">该功能的文档中说:</target>
        </trans-unit>
        <trans-unit id="672cec25fd6cd4f425093ea7d30c2cab847d8cd3" translate="yes" xml:space="preserve">
          <source>The duration amounts to the actual time elapsed between both instances, on the instant time-line. The difference between local date-time representations may equal to a different duration, depending on time zone transitions.</source>
          <target state="translated">持续时间相当于两个实例之间在即时时间线上的实际时间。当地日期-时间表示之间的差异可能等于不同的持续时间,这取决于时区转换。</target>
        </trans-unit>
        <trans-unit id="c37ea0ffdf358cedefc364ad6f8b92588cd577ca" translate="yes" xml:space="preserve">
          <source>The easiest, but probably most tedious, way is to use explicit type restrictions.</source>
          <target state="translated">最简单,但可能最乏味的方法是使用显式类型限制。</target>
        </trans-unit>
        <trans-unit id="63bbeb85167187d17ca0803b3e824665527089f0" translate="yes" xml:space="preserve">
          <source>The empty node. Similar to a &lt;code&gt;&lt;a href=&quot;nilliteral&quot;&gt;NilLiteral&lt;/a&gt;&lt;/code&gt; but its textual representation is the empty string. This corresponds, for example, to the missing &lt;code&gt;else&lt;/code&gt; branch of an &lt;code&gt;if&lt;/code&gt; without an &lt;code&gt;else&lt;/code&gt;.</source>
          <target state="translated">空节点。与 &lt;code&gt;&lt;a href=&quot;nilliteral&quot;&gt;NilLiteral&lt;/a&gt;&lt;/code&gt; 类似，但其文本表示形式是空字符串。这相当于，例如，缺少 &lt;code&gt;else&lt;/code&gt; 的分支 &lt;code&gt;if&lt;/code&gt; 没有 &lt;code&gt;else&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f0e9c0ed65ebb143261ec014d66c5e246230b63" translate="yes" xml:space="preserve">
          <source>The encoded string returned from this method can be used as name or value components for a &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; format serialization. &lt;code&gt;&lt;a href=&quot;http/params&quot;&gt;HTTP::Params&lt;/a&gt;&lt;/code&gt; provides a higher-level API for this use case.</source>
          <target state="translated">从此方法返回的编码字符串可以用作 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 格式序列化的名称或值组成部分。 &lt;code&gt;&lt;a href=&quot;http/params&quot;&gt;HTTP::Params&lt;/a&gt;&lt;/code&gt; 为此用例提供了更高级别的API。</target>
        </trans-unit>
        <trans-unit id="19a501ac3170a7625cc3d06fca03beaa27abcd04" translate="yes" xml:space="preserve">
          <source>The enumeration follows the order the keys were inserted.</source>
          <target state="translated">按照插入键的顺序进行列举。</target>
        </trans-unit>
        <trans-unit id="334b8883ac89ea1d46fa3c575e4dc24d15abe6b9" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;&lt;a href=&quot;../env&quot;&gt;ENV&lt;/a&gt;[&quot;TZ&quot;]&lt;/code&gt; is consulted for finding the time zone to use.</source>
          <target state="translated">参考环境变量 &lt;code&gt;&lt;a href=&quot;../env&quot;&gt;ENV&lt;/a&gt;[&quot;TZ&quot;]&lt;/code&gt; 查找要使用的时区。</target>
        </trans-unit>
        <trans-unit id="289939042a809d4b4c05c5f43058ca29ae965fdf" translate="yes" xml:space="preserve">
          <source>The event loop: which is another fiber. When there are no other fibers ready to be executed, the event loop checks if there is any async operation that is ready, and then executes the fiber waiting for that operation. The event loop is currently implemented with &lt;code&gt;libevent&lt;/code&gt;, which is an abstraction of other event mechanisms like &lt;code&gt;epoll&lt;/code&gt; and &lt;code&gt;kqueue&lt;/code&gt;.</source>
          <target state="translated">事件循环：这是另一根光纤。当没有其他光纤准备就绪时，事件循环将检查是否有任何异步操作就绪，然后执行光纤以等待该操作。目前，事件循环是通过 &lt;code&gt;libevent&lt;/code&gt; 实现的，libevent是 &lt;code&gt;epoll&lt;/code&gt; 和 &lt;code&gt;kqueue&lt;/code&gt; 等其他事件机制的抽象。</target>
        </trans-unit>
        <trans-unit id="dfbe06a290759cb035c2f02fdd4943aed0c8dcec" translate="yes" xml:space="preserve">
          <source>The executable path will be canonicalized (all symlinks and relative paths will be expanded).</source>
          <target state="translated">可执行路径将被规范化(所有的符号链接和相对路径将被扩展)。</target>
        </trans-unit>
        <trans-unit id="1bfa0e0ddd888170dfb91065ef7f439d633802bf" translate="yes" xml:space="preserve">
          <source>The execution time of a block can be measured using &lt;code&gt;&lt;a href=&quot;time#measure(&amp;amp;block):Time::Span-class-method&quot;&gt;.measure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;time#measure(&amp;amp;block):Time::Span-class-method&quot;&gt;.measure&lt;/a&gt;&lt;/code&gt; 来测量块的执行时间。</target>
        </trans-unit>
        <trans-unit id="89a823a74578974bd0a0c7713f0c6c71b0b85cc0" translate="yes" xml:space="preserve">
          <source>The execution time of a block can be measured using &lt;code&gt;&lt;a href=&quot;time#measure(&amp;amp;block):Time::Span-class-method&quot;&gt;.measure&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;time#measure(&amp;amp;block):Time::Span-class-method&quot;&gt;.measure&lt;/a&gt;&lt;/code&gt; 来测量块的执行时间：</target>
        </trans-unit>
        <trans-unit id="d9fd89c2a234ddba0ffc9a9f1fae9c1be8096dcb" translate="yes" xml:space="preserve">
          <source>The exit status code that will be returned by this program is passed to the block as its first argument. In case of any unhandled exception, it is passed as the second argument to the block, if the program terminates normally or &lt;code&gt;&lt;a href=&quot;toplevel#exit(status=0):NoReturn-class-method&quot;&gt;exit(status)&lt;/a&gt;&lt;/code&gt; is called explicitly, then the second argument will be nil.</source>
          <target state="translated">该程序将返回的退出状态代码作为其第一个参数传递给该块。如果有任何未处理的异常，它将作为第二个参数传递给该块，如果程序正常终止或显式调用 &lt;code&gt;&lt;a href=&quot;toplevel#exit(status=0):NoReturn-class-method&quot;&gt;exit(status)&lt;/a&gt;&lt;/code&gt; ，则第二个参数将为nil。</target>
        </trans-unit>
        <trans-unit id="9f46241c26ff01da7f3b3d6385013f970c5e0bdc" translate="yes" xml:space="preserve">
          <source>The fiber's proc has terminated, and the fiber is now considered dead.</source>
          <target state="translated">光纤的proc已经终止,现在认为该光纤已经死亡。</target>
        </trans-unit>
        <trans-unit id="0f4c121cdb610ad81756083bed036f80561110e6" translate="yes" xml:space="preserve">
          <source>The fiber's proc has terminated, and the fiber is now considered dead. The fiber is impossible to resume, ever.</source>
          <target state="translated">该光纤的proc已经终止,该光纤现在被认为是死的。该光纤不可能恢复,永远不可能。</target>
        </trans-unit>
        <trans-unit id="d0d403944bf6fed71d4adbaf5d43a604d67a030f" translate="yes" xml:space="preserve">
          <source>The fiber's proc is currently not running and fully saved its context.</source>
          <target state="translated">目前光纤的proc没有运行,完全保存了其上下文。</target>
        </trans-unit>
        <trans-unit id="50ad807d3af39a32f5f08b0259dde9b52a3b978b" translate="yes" xml:space="preserve">
          <source>The fiber's proc is currently not running and fully saved its context. The fiber can be resumed safely.</source>
          <target state="translated">目前光纤的proc没有运行,完全保存了它的上下文。该光纤可以安全恢复。</target>
        </trans-unit>
        <trans-unit id="0c6f5ccd21c6daa06fd34c08cdb6f256203067ea" translate="yes" xml:space="preserve">
          <source>The fiber's proc is currently running or didn't fully save its context.</source>
          <target state="translated">光纤的proc当前正在运行或没有完全保存其上下文。</target>
        </trans-unit>
        <trans-unit id="a786767a12553cf62d379e1ba32bb2dc888b542c" translate="yes" xml:space="preserve">
          <source>The fiber's proc is currently running or didn't fully save its context. The fiber can't be resumed.</source>
          <target state="translated">光纤的proc当前正在运行或没有完全保存其上下文。该光纤无法恢复。</target>
        </trans-unit>
        <trans-unit id="1bee5d440fe98063654d400b6134543e61b6bc0d" translate="yes" xml:space="preserve">
          <source>The field type characters are:</source>
          <target state="translated">字段类型的字符是:</target>
        </trans-unit>
        <trans-unit id="afe1f9f4b67401c1810db8891ab5bbcec3861b72" translate="yes" xml:space="preserve">
          <source>The field type controls how the corresponding &lt;code&gt;&lt;a href=&quot;toplevel#sprintf(format_string,args:Array%7CTuple):String-class-method&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; argument is to be interpreted, while the flags modify that interpretation.</source>
          <target state="translated">字段类型控制如何解释相应的 &lt;code&gt;&lt;a href=&quot;toplevel#sprintf(format_string,args:Array%7CTuple):String-class-method&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 参数，而标志则修改该解释。</target>
        </trans-unit>
        <trans-unit id="3d0cabb0dec3924f84ac20c0ab88719a5fa4fc4b" translate="yes" xml:space="preserve">
          <source>The field width is an optional integer, followed optionally by a period and a precision. The width specifies the minimum number of characters that will be written to the result for this field.</source>
          <target state="translated">字段宽度是一个可选的整数,后面跟着一个句号和一个精度。字段宽度指定了这个字段要写入结果的最小字符数。</target>
        </trans-unit>
        <trans-unit id="4b6d10aefdcc16f0633d9b2f1665f19c6f5de57f" translate="yes" xml:space="preserve">
          <source>The file denoted by &lt;em&gt;filename&lt;/em&gt; must be a valid Crystal program. This macro invocation passes &lt;em&gt;args&lt;/em&gt; to the program as regular program arguments. The program must output a valid Crystal expression. This output is the result of this macro invocation, as a &lt;code&gt;&lt;a href=&quot;macros/macroid&quot;&gt;MacroId&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">文件&lt;em&gt;名&lt;/em&gt;表示的&lt;em&gt;文件&lt;/em&gt;必须是有效的Crystal程序。该宏调用将&lt;em&gt;args&lt;/em&gt;作为常规程序参数传递给程序。程序必须输出有效的Crystal表达式。此输出是此宏调用的结果，作为 &lt;code&gt;&lt;a href=&quot;macros/macroid&quot;&gt;MacroId&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bb08622a576d8d4f5169eceb64b0143f36aba6f" translate="yes" xml:space="preserve">
          <source>The file will be placed in &lt;em&gt;dir&lt;/em&gt; which defaults to the standard temporary directory &lt;code&gt;&lt;a href=&quot;dir#tempdir:String-class-method&quot;&gt;Dir.tempdir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该文件将放置在&lt;em&gt;dir&lt;/em&gt;中，该&lt;em&gt;目录&lt;/em&gt;默认为标准临时目录 &lt;code&gt;&lt;a href=&quot;dir#tempdir:String-class-method&quot;&gt;Dir.tempdir&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7f1640403d9f182a77e3019950bddcdb6697b5b" translate="yes" xml:space="preserve">
          <source>The file/directory separator character. &lt;code&gt;'/'&lt;/code&gt; on all platforms.</source>
          <target state="translated">文件/目录分隔符。在所有平台上为 &lt;code&gt;'/'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30c3dc3998a9c5f84132da6d3eec00f1eb4d2eba" translate="yes" xml:space="preserve">
          <source>The file/directory separator characters of the current platform. &lt;code&gt;{'/'}&lt;/code&gt; on POSIX, &lt;code&gt;{'\\', '/'}&lt;/code&gt; on Windows.</source>
          <target state="translated">当前平台的文件/目录分隔符。 &lt;code&gt;{'/'}&lt;/code&gt; 在POSIX， &lt;code&gt;{'\\', '/'}&lt;/code&gt; 在Windows上。</target>
        </trans-unit>
        <trans-unit id="ef624ff911ca746c85289883981086d69233acc2" translate="yes" xml:space="preserve">
          <source>The file/directory separator string. &lt;code&gt;&quot;/&quot;&lt;/code&gt; on all platforms.</source>
          <target state="translated">文件/目录分隔符字符串。在所有平台上均为 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3d50190f7ff29511807626569fb6160233f5396" translate="yes" xml:space="preserve">
          <source>The first alternative is long and cumbersome, while the second one is much easier.</source>
          <target state="translated">第一种选择时间长,手续繁琐,而第二种选择则简单得多。</target>
        </trans-unit>
        <trans-unit id="31061b68dd407b09235c7c1ef9a26c76d6b04315" translate="yes" xml:space="preserve">
          <source>The first argument is either &lt;code&gt;lib&lt;/code&gt; or &lt;code&gt;app&lt;/code&gt;. A &lt;code&gt;lib&lt;/code&gt; is a reusable library whereas &lt;code&gt;app&lt;/code&gt; describes an application not intended to be used as a dependency. A library doesn't have a &lt;code&gt;shard.lock&lt;/code&gt; file in its repository and no build target in &lt;code&gt;shard.yml&lt;/code&gt;, but instructions for using it as a dependency.</source>
          <target state="translated">第一个参数是 &lt;code&gt;lib&lt;/code&gt; 或 &lt;code&gt;app&lt;/code&gt; 。甲 &lt;code&gt;lib&lt;/code&gt; 是一个可重复使用的库，而 &lt;code&gt;app&lt;/code&gt; 描述不旨在被用作依赖的应用程序。库在其存储库中没有 &lt;code&gt;shard.lock&lt;/code&gt; 文件，在 &lt;code&gt;shard.yml&lt;/code&gt; 中没有构建目标，但有使用它作为依赖项的说明。</target>
        </trans-unit>
        <trans-unit id="4f2b0f830f3e3c9d2c0fadd8f67d8f7eed5680ed" translate="yes" xml:space="preserve">
          <source>The first call's value is 3 because the last expression of the &lt;code&gt;twice&lt;/code&gt; method is &lt;code&gt;yield&lt;/code&gt;, which gets the value of the block. The second call's value is &quot;hello&quot; because a &lt;code&gt;break&lt;/code&gt; was performed.</source>
          <target state="translated">第一次调用的值为3，因为 &lt;code&gt;twice&lt;/code&gt; 方法的最后一个表达式为 &lt;code&gt;yield&lt;/code&gt; ，它获取块的值。第二个调用的值为&amp;ldquo; hello&amp;rdquo;，因为已执行 &lt;code&gt;break&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fbfa33b37cfbb072d1b127aa2dce98fa6f5e510" translate="yes" xml:space="preserve">
          <source>The first column number in a line is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">行中的第一列号是 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cf05659ff2d94c8303ab1881055ee47c442c275" translate="yes" xml:space="preserve">
          <source>The first line number in a file is 1.</source>
          <target state="translated">文件中的第一个行号是1。</target>
        </trans-unit>
        <trans-unit id="29746ec8cc3c8ed07d200a43767fe0becddc922c" translate="yes" xml:space="preserve">
          <source>The first line number in a file is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">文件中的第一行号是 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7282b6d781cdedc397bb9f92b08cb71c689472a6" translate="yes" xml:space="preserve">
          <source>The first use case is using keywords as named arguments:</source>
          <target state="translated">第一个用例是使用关键字作为命名参数。</target>
        </trans-unit>
        <trans-unit id="944607c5718cd118bb1cd25f452f563fd505d548" translate="yes" xml:space="preserve">
          <source>The flags modifies the behavior of the formats. The flag characters are:</source>
          <target state="translated">标志可以修改格式的行为。标志字符有:</target>
        </trans-unit>
        <trans-unit id="e6efa2cf6ab96201c82623d35b55f95ec36e4f81" translate="yes" xml:space="preserve">
          <source>The following environment variables are used by the Crystal compiler if set in the environment. Otherwise the compiler will populate them with default values. Their values can be inspected using &lt;a href=&quot;#crystal-env&quot;&gt;&lt;code&gt;crystal env&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果在环境中设置了Crystal编译器使用的以下环境变量。否则，编译器将使用默认值填充它们。可以使用&lt;a href=&quot;#crystal-env&quot;&gt; &lt;code&gt;crystal env&lt;/code&gt; &lt;/a&gt;检查它们的值。</target>
        </trans-unit>
        <trans-unit id="9cc7eb726ec3a5d3307d840aa0563e35c2723422" translate="yes" xml:space="preserve">
          <source>The following key values have special meaning:</source>
          <target state="translated">以下键值具有特殊意义:</target>
        </trans-unit>
        <trans-unit id="d7023ad60a85970889177c2463c53776a3c26ce2" translate="yes" xml:space="preserve">
          <source>The following normalizations are applied to the individual components (if available):</source>
          <target state="translated">下列标准化适用于各个组成部分(如果有的话):</target>
        </trans-unit>
        <trans-unit id="0016c7b15769c3e1fd83dd79375297c7acf71246" translate="yes" xml:space="preserve">
          <source>The following packages are compliant with crystal-db</source>
          <target state="translated">以下是符合crystal-db的软件包</target>
        </trans-unit>
        <trans-unit id="ed4a566b4ccf42840a4e12dadfcc10d7098e35b2" translate="yes" xml:space="preserve">
          <source>The following packages are not required, but recommended for using the respective features in the standard library:</source>
          <target state="translated">以下是不需要的包,但建议使用标准库中的相应功能。</target>
        </trans-unit>
        <trans-unit id="df2f6f226ab11b061d48e88e2f779470aed4df0a" translate="yes" xml:space="preserve">
          <source>The following program will print the current time from MySQL but if the connection is lost or the whole server is down for a few seconds the program will still run without raising exceptions.</source>
          <target state="translated">下面的程序将从MySQL中打印出当前时间,但如果连接丢失或整个服务器瘫痪几秒钟,程序仍将运行,不会引起异常。</target>
        </trans-unit>
        <trans-unit id="f65de8007c538aaa6706cdfae0b7fef84f90beff" translate="yes" xml:space="preserve">
          <source>The following rules only mention instance variables, but they apply to class variables as well. They are:</source>
          <target state="translated">下面的规则只提到了实例变量,但它们也适用于类变量。这些规则是:</target>
        </trans-unit>
        <trans-unit id="0dbd1e5907988d5a9b86e8a44f0b23026d0438da" translate="yes" xml:space="preserve">
          <source>The format follows that of &lt;code&gt;mime.types&lt;/code&gt;: Each line is list of MIME type and zero or more extensions, separated by whitespace.</source>
          <target state="translated">格式遵循 &lt;code&gt;mime.types&lt;/code&gt; 的格式：每行是MIME类型和零个或多个扩展名的列表，用空格分隔。</target>
        </trans-unit>
        <trans-unit id="4236b918ce2dedb4ff39d640ea5ef84abf8e19ea" translate="yes" xml:space="preserve">
          <source>The formatted &lt;em&gt;offset&lt;/em&gt; is used as name.</source>
          <target state="translated">格式化的&lt;em&gt;偏移量&lt;/em&gt;用作名称。</target>
        </trans-unit>
        <trans-unit id="5e9084c0683429eb40329f37c13c0d6d200d202a" translate="yes" xml:space="preserve">
          <source>The formatter is also fast, so very little time is lost if you format the entire project instead of a single file.</source>
          <target state="translated">格式化的速度也很快,所以如果你格式化整个项目而不是单个文件,损失的时间非常少。</target>
        </trans-unit>
        <trans-unit id="05b48edc5cca42e2789ffc8837a2004918c00d01" translate="yes" xml:space="preserve">
          <source>The fourth rule is the second rule applied to the third rule.</source>
          <target state="translated">第四规则是第二规则应用于第三规则。</target>
        </trans-unit>
        <trans-unit id="bc894b0b17eb5fe1f8d04334d39d3eabd11f375d" translate="yes" xml:space="preserve">
          <source>The general type-safe interface for parsing JSON is to invoke &lt;code&gt;T.from_json&lt;/code&gt; on a target type &lt;code&gt;T&lt;/code&gt; and pass either a &lt;code&gt;&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; as an argument.</source>
          <target state="translated">解析JSON的通用类型安全接口是在目标类型 &lt;code&gt;T&lt;/code&gt; 上调用 &lt;code&gt;T.from_json&lt;/code&gt; 并传递 &lt;code&gt;&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 作为参数。</target>
        </trans-unit>
        <trans-unit id="e33ed10eb7e2b4410d4055c2b4e5f7f6dff7cad5" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;&lt;a href=&quot;object#==(other)-instance-method&quot;&gt;#==&lt;/a&gt;&lt;/code&gt; method has a &lt;code&gt;self&lt;/code&gt; restriction.</source>
          <target state="translated">生成的 &lt;code&gt;&lt;a href=&quot;object#==(other)-instance-method&quot;&gt;#==&lt;/a&gt;&lt;/code&gt; 方法具有 &lt;code&gt;self&lt;/code&gt; 限制。</target>
        </trans-unit>
        <trans-unit id="161b9b9b4d7ee5f3338616ad526cac2a1b891f99" translate="yes" xml:space="preserve">
          <source>The generated code is the result of translating the contents of the ECR file to Crystal, a program that appends to an IO and returns a string.</source>
          <target state="translated">生成的代码是将ECR文件的内容翻译成Crystal的结果,Crystal是一个附加到IO并返回字符串的程序。</target>
        </trans-unit>
        <trans-unit id="850640a99607c250d09463c5d4d44a7952067ec8" translate="yes" xml:space="preserve">
          <source>The generated code is the result of translating the contents of the ECR file to Crystal, a program that appends to an IO.</source>
          <target state="translated">生成的代码是将ECR文件的内容翻译成Crystal的结果,Crystal是一个附加到IO的程序。</target>
        </trans-unit>
        <trans-unit id="d2927bf521c3240a458f018c8d8c7f2666a4b79c" translate="yes" xml:space="preserve">
          <source>The generated struct has a constructor with the given properties in the same order as declared. The struct only provides getters, not setters, making it immutable by default.</source>
          <target state="translated">生成的结构体有一个构造函数,其给定的属性与声明的顺序相同。该结构只提供getter,不提供setter,因此默认情况下它是不可变的。</target>
        </trans-unit>
        <trans-unit id="7ea3417d731136bbc84a172b8a9ec5bb44115268" translate="yes" xml:space="preserve">
          <source>The generic argument type &lt;code&gt;N&lt;/code&gt; is a special case in the type grammar as it doesn't specify a type but a size. Its value can be an &lt;code&gt;&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; literal or constant.</source>
          <target state="translated">通用参数类型 &lt;code&gt;N&lt;/code&gt; 在类型语法中是一种特殊情况，因为它不指定类型而是指定大小。它的值可以是 &lt;code&gt;&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 文字或常量。</target>
        </trans-unit>
        <trans-unit id="83da50509ca833b11f166b7098db606858beaa10" translate="yes" xml:space="preserve">
          <source>The generic type arguments for keys &lt;code&gt;K&lt;/code&gt; and values &lt;code&gt;V&lt;/code&gt; are inferred from the types of the keys or values inside the literal, respectively. When all have the same type, &lt;code&gt;K&lt;/code&gt;/&lt;code&gt;V&lt;/code&gt; equals to that. Otherwise it will be a union of all key types or value types respectively.</source>
          <target state="translated">键 &lt;code&gt;K&lt;/code&gt; 和值 &lt;code&gt;V&lt;/code&gt; 的通用类型参数分别从文字中的键或值的类型中推论得出。当所有类型相同时， &lt;code&gt;K&lt;/code&gt; / &lt;code&gt;V&lt;/code&gt; 等于该值。否则，它将分别是所有键类型或值类型的并集。</target>
        </trans-unit>
        <trans-unit id="c0f491fd27dcca34e08785bd778bcdd9fbc7d310" translate="yes" xml:space="preserve">
          <source>The given block must implement a comparison between two elements &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, where &lt;code&gt;a &amp;lt; b&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;a == b&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;a &amp;gt; b&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;. The comparison operator &lt;code&gt;&lt;a href=&quot;array#(other:Array)-instance-method&quot;&gt;#&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt; can be used for this.</source>
          <target state="translated">给定的块必须实现两个元素&lt;em&gt;a&lt;/em&gt;和&lt;em&gt;b&lt;/em&gt;之间的比较，其中 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 返回 &lt;code&gt;-1&lt;/code&gt; ， &lt;code&gt;a == b&lt;/code&gt; 返回 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;a &amp;gt; b&lt;/code&gt; 返回 &lt;code&gt;1&lt;/code&gt; 。比较运算符 &lt;code&gt;&lt;a href=&quot;array#(other:Array)-instance-method&quot;&gt;#&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt; 可以用于此目的。</target>
        </trans-unit>
        <trans-unit id="ba2c2765b46b6a78d9039aea25933b142ce4dcdb" translate="yes" xml:space="preserve">
          <source>The given block must implement a comparison between two elements &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, where &lt;code&gt;a &amp;lt; b&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;a == b&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;a &amp;gt; b&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;. The comparison operator &lt;code&gt;&lt;a href=&quot;slice#(other:Slice(U))forallU-instance-method&quot;&gt;#&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt; can be used for this.</source>
          <target state="translated">给定的块必须实现两个元素&lt;em&gt;a&lt;/em&gt;和&lt;em&gt;b&lt;/em&gt;之间的比较，其中 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 返回 &lt;code&gt;-1&lt;/code&gt; ， &lt;code&gt;a == b&lt;/code&gt; 返回 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;a &amp;gt; b&lt;/code&gt; 返回 &lt;code&gt;1&lt;/code&gt; 。比较运算符 &lt;code&gt;&lt;a href=&quot;slice#(other:Slice(U))forallU-instance-method&quot;&gt;#&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt; 可以用于此目的。</target>
        </trans-unit>
        <trans-unit id="aba3c60d8e4ce8ec19e0181810c4cfbaaedf9003" translate="yes" xml:space="preserve">
          <source>The group ID that the file belongs to.</source>
          <target state="translated">文件所属的组ID。</target>
        </trans-unit>
        <trans-unit id="1d63cffc2e9e719f4e3ebd2eeb037ae1637a0fb0" translate="yes" xml:space="preserve">
          <source>The group's identifier.</source>
          <target state="translated">该组的标识符;</target>
        </trans-unit>
        <trans-unit id="f305e58025f637bd1bb3abad3fefbca0047ef4dc" translate="yes" xml:space="preserve">
          <source>The group's name.</source>
          <target state="translated">集团的名字。</target>
        </trans-unit>
        <trans-unit id="2052a3c1bb6b28b6bc273e30084593c5dba96709" translate="yes" xml:space="preserve">
          <source>The handler chain receives an instance of &lt;code&gt;&lt;a href=&quot;server/context&quot;&gt;HTTP::Server::Context&lt;/a&gt;&lt;/code&gt; that holds the &lt;code&gt;&lt;a href=&quot;request&quot;&gt;HTTP::Request&lt;/a&gt;&lt;/code&gt; to process and a &lt;code&gt;&lt;a href=&quot;server/response&quot;&gt;HTTP::Server::Response&lt;/a&gt;&lt;/code&gt; which it can configure and write to.</source>
          <target state="translated">处理程序链接收一个 &lt;code&gt;&lt;a href=&quot;server/context&quot;&gt;HTTP::Server::Context&lt;/a&gt;&lt;/code&gt; 实例，该实例保存要处理的 &lt;code&gt;&lt;a href=&quot;request&quot;&gt;HTTP::Request&lt;/a&gt;&lt;/code&gt; 和一个 &lt;code&gt;&lt;a href=&quot;server/response&quot;&gt;HTTP::Server::Response&lt;/a&gt;&lt;/code&gt; ，可以配置和写入该实例。</target>
        </trans-unit>
        <trans-unit id="3281389107b6c7f72f81900bfaa5b500e9cdeb5a" translate="yes" xml:space="preserve">
          <source>The handler given to a server can simply be a block that receives an &lt;code&gt;&lt;a href=&quot;server/context&quot;&gt;HTTP::Server::Context&lt;/a&gt;&lt;/code&gt;, or it can be an instance of &lt;code&gt;&lt;a href=&quot;handler&quot;&gt;HTTP::Handler&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;&lt;a href=&quot;handler&quot;&gt;HTTP::Handler&lt;/a&gt;&lt;/code&gt; has a &lt;code&gt;#next&lt;/code&gt; method to forward processing to the next handler in the chain.</source>
          <target state="translated">提供给服务器的处理程序可以仅仅是接收 &lt;code&gt;&lt;a href=&quot;server/context&quot;&gt;HTTP::Server::Context&lt;/a&gt;&lt;/code&gt; 的块，也可以是 &lt;code&gt;&lt;a href=&quot;handler&quot;&gt;HTTP::Handler&lt;/a&gt;&lt;/code&gt; 的实例。一个 &lt;code&gt;&lt;a href=&quot;handler&quot;&gt;HTTP::Handler&lt;/a&gt;&lt;/code&gt; 具有 &lt;code&gt;#next&lt;/code&gt; 方法前进到处理链中的下一个处理程序。</target>
        </trans-unit>
        <trans-unit id="e7fca7732240d34903abd174e4d0486dc5880a17" translate="yes" xml:space="preserve">
          <source>The hash value is used along with &lt;code&gt;&lt;a href=&quot;object#==(other)-instance-method&quot;&gt;#==&lt;/a&gt;&lt;/code&gt; by the &lt;code&gt;&lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt;&lt;/code&gt; class to determine if two objects reference the same hash key.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt;&lt;/code&gt; 类将哈希值与 &lt;code&gt;&lt;a href=&quot;object#==(other)-instance-method&quot;&gt;#==&lt;/a&gt;&lt;/code&gt; 一起使用，以确定两个对象是否引用相同的哈希键。</target>
        </trans-unit>
        <trans-unit id="4296f7705e65b93fe2d747f546b9085bc93e071d" translate="yes" xml:space="preserve">
          <source>The hash value is used along with &lt;code&gt;==&lt;/code&gt; by the &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;Hash&lt;/a&gt;&lt;/code&gt; class to determine if two objects reference the same hash key.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;Hash&lt;/a&gt;&lt;/code&gt; 类将哈希值与 &lt;code&gt;==&lt;/code&gt; 一起使用，以确定两个对象是否引用相同的哈希键。</target>
        </trans-unit>
        <trans-unit id="16d3793c30a780cf4f54bb683fa465b418aa48f7" translate="yes" xml:space="preserve">
          <source>The header to write to the gzip stream.</source>
          <target state="translated">要写入gzip流的头。</target>
        </trans-unit>
        <trans-unit id="fcc96ce881395326c49c3bd18847ce9208819136" translate="yes" xml:space="preserve">
          <source>The header to write to the gzip stream. It will be written just before the first write to this writer. Changes to the header after the first write are ignored.</source>
          <target state="translated">要写到gzip流的头。它将在第一次写入该写入器之前写入。第一次写入后对头的更改将被忽略。</target>
        </trans-unit>
        <trans-unit id="22aee03c041742fe85df9b9e026008d04cf773b8" translate="yes" xml:space="preserve">
          <source>The implementation uses a list of system-specifc paths to look for a time zone database. The first time zone database entry matching the given name that is successfully loaded and parsed is returned. Typical paths on Unix-based operating systems are &lt;code&gt;/usr/share/zoneinfo/&lt;/code&gt;, &lt;code&gt;/usr/share/lib/zoneinfo/&lt;/code&gt;, or &lt;code&gt;/usr/lib/locale/TZ/&lt;/code&gt;.</source>
          <target state="translated">该实现使用系统特定路径的列表来查找时区数据库。返回与给定名称成功匹配和解析的第一个时区数据库条目。在基于Unix的操作系统上，典型路径是 &lt;code&gt;/usr/share/zoneinfo/&lt;/code&gt; ， &lt;code&gt;/usr/share/lib/zoneinfo/&lt;/code&gt; 或 &lt;code&gt;/usr/lib/locale/TZ/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="551883aa2990efd8eb5d4be92ebed96eae1f59aa" translate="yes" xml:space="preserve">
          <source>The initial value depends on the current application environment, see &lt;code&gt;&lt;a href=&quot;location#load_local:Location-class-method&quot;&gt;.load_local&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">初始值取决于当前应用程序环境，有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;location#load_local:Location-class-method&quot;&gt;.load_local&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7029c3307fafac8110eb16f73429676ca35bcb88" translate="yes" xml:space="preserve">
          <source>The integers must be uniformly distributed between &lt;code&gt;0&lt;/code&gt; and the maximal value for the chosen type.</source>
          <target state="translated">整数必须均匀地分布在 &lt;code&gt;0&lt;/code&gt; 和所选类型的最大值之间。</target>
        </trans-unit>
        <trans-unit id="926dd5e448113cba2500b56bfc57b8b5d6768ae8" translate="yes" xml:space="preserve">
          <source>The internal bindings to the &lt;code&gt;LibCrypto&lt;/code&gt; digest operations sometimes require a hash algorithm implementation to be passed as one of the arguments.</source>
          <target state="translated">对 &lt;code&gt;LibCrypto&lt;/code&gt; 摘要操作的内部绑定有时需要将散列算法实现作为参数之一传递。</target>
        </trans-unit>
        <trans-unit id="25f7c6863f521bdd9ec42e3a206a1f95cdfc1cf8" translate="yes" xml:space="preserve">
          <source>The internal buffer can be resizeable and/or writeable depending on how an &lt;code&gt;&lt;a href=&quot;memory&quot;&gt;IO::Memory&lt;/a&gt;&lt;/code&gt; is constructed.</source>
          <target state="translated">内部缓冲区的大小和/或可写性取决于 &lt;code&gt;&lt;a href=&quot;memory&quot;&gt;IO::Memory&lt;/a&gt;&lt;/code&gt; 的构造方式。</target>
        </trans-unit>
        <trans-unit id="45606955e8cce931909a6c69d5ede679a4b15aee" translate="yes" xml:space="preserve">
          <source>The iteration will be stopped once the block returns something that isn't an &lt;code&gt;&lt;a href=&quot;../exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; (e.g. a &lt;code&gt;&lt;a href=&quot;../socket&quot;&gt;Socket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;).</source>
          <target state="translated">一旦该块返回不是 &lt;code&gt;&lt;a href=&quot;../exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 的值（例如 &lt;code&gt;&lt;a href=&quot;../socket&quot;&gt;Socket&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; ），迭代就会停止。</target>
        </trans-unit>
        <trans-unit id="3de70595cf93069e85ebe84d6457f06c459c743c" translate="yes" xml:space="preserve">
          <source>The label associated with this measure</source>
          <target state="translated">与此措施相关的标签</target>
        </trans-unit>
        <trans-unit id="0c961f49abfbcb5c3bb290b23e0091e5688b3672" translate="yes" xml:space="preserve">
          <source>The language and the standard library provide short, readable, easy ways to deal with &lt;code&gt;nil&lt;/code&gt;, such as &lt;code&gt;&lt;a href=&quot;object#try(&amp;amp;block)-instance-method&quot;&gt;Object#try&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;object#not_nil!-instance-method&quot;&gt;Object#not_nil!&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">该语言和标准库提供了简短，易读，简单的方法来处理 &lt;code&gt;nil&lt;/code&gt; ，例如 &lt;code&gt;&lt;a href=&quot;object#try(&amp;amp;block)-instance-method&quot;&gt;Object#try&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;object#not_nil!-instance-method&quot;&gt;Object#not_nil!&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="627158d44810f0a6c7e5859fc56380ad01ee04a5" translate="yes" xml:space="preserve">
          <source>The last time this file was modified.</source>
          <target state="translated">这个文件最后一次修改的时间。</target>
        </trans-unit>
        <trans-unit id="c51aa65ff430b4020b0598581342b2d9c53c76cc" translate="yes" xml:space="preserve">
          <source>The last two definitions are invalid and so will give a compile-time error.</source>
          <target state="translated">最后两个定义是无效的,所以会给出一个编译时错误。</target>
        </trans-unit>
        <trans-unit id="3d46ef3cd6d700f9d2f8be43c61a3e6f036414ea" translate="yes" xml:space="preserve">
          <source>The latest files can be found on the Releases page at GitHub: &lt;a href=&quot;https://github.com/crystal-lang/crystal/releases&quot;&gt;https://github.com/crystal-lang/crystal/releases&lt;/a&gt;</source>
          <target state="translated">可以在GitHub的Releases页面上找到最新文件：&lt;a href=&quot;https://github.com/crystal-lang/crystal/releases&quot;&gt;https&lt;/a&gt; : //github.com/crystal-lang/crystal/releases</target>
        </trans-unit>
        <trans-unit id="35dbb84b4256926f3ab51300c4ed1ac0f729b277" translate="yes" xml:space="preserve">
          <source>The line where this node ends.</source>
          <target state="translated">这个节点结束的线。</target>
        </trans-unit>
        <trans-unit id="4a892453dc7603d33c3517f69db5942483971c7d" translate="yes" xml:space="preserve">
          <source>The line where this node starts.</source>
          <target state="translated">这个节点开始的线路。</target>
        </trans-unit>
        <trans-unit id="bedd54aa13c2cb76927bb6b0d17610a9102fc5b2" translate="yes" xml:space="preserve">
          <source>The list of secure ciphers (intermediate security) as of May 2016 as per https://wiki.mozilla.org/Security/Server_Side_TLS</source>
          <target state="translated">截至2016年5月的安全密码(中间安全)清单,根据https://wiki.mozilla.org/Security/Server_Side_TLS。</target>
        </trans-unit>
        <trans-unit id="2f7f1512675cd07ffa18f48d9a4fccdb4ae2ec35" translate="yes" xml:space="preserve">
          <source>The list of valid call conventions is:</source>
          <target state="translated">有效的调用惯例清单是:</target>
        </trans-unit>
        <trans-unit id="837ef61d38d181f259cc57a7840d151fb3ec7fb2" translate="yes" xml:space="preserve">
          <source>The literal &lt;code&gt;x..y&lt;/code&gt; is semantically equivalent to the explicit constructor &lt;code&gt;Range.new(x, y)&lt;/code&gt; and &lt;code&gt;x...y&lt;/code&gt; to &lt;code&gt;Range.new(x, y, true)&lt;/code&gt;.</source>
          <target state="translated">字面量 &lt;code&gt;x..y&lt;/code&gt; 在语义上等效于显式构造函数 &lt;code&gt;Range.new(x, y)&lt;/code&gt; 而 &lt;code&gt;x...y&lt;/code&gt; &lt;code&gt;Range.new(x, y, true)&lt;/code&gt; 于Range.new（x，y，true）。</target>
        </trans-unit>
        <trans-unit id="443382cb3c25faa904e8e39d00f50b9475f6c0fc" translate="yes" xml:space="preserve">
          <source>The local date-time is formatted as date string &lt;code&gt;YYYY-MM-DD HH:mm:ss +ZZ:ZZ:ZZ&lt;/code&gt;. Nanoseconds are always omitted. When the location is &lt;code&gt;UTC&lt;/code&gt;, the offset is replaced with the string &lt;code&gt;UTC&lt;/code&gt;. Offset seconds are omitted if &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">本地日期时间格式为日期字符串 &lt;code&gt;YYYY-MM-DD HH:mm:ss +ZZ:ZZ:ZZ&lt;/code&gt; 。纳秒总是被省略。当位置为 &lt;code&gt;UTC&lt;/code&gt; 时，偏移量将替换为字符串 &lt;code&gt;UTC&lt;/code&gt; 。如果为 &lt;code&gt;0&lt;/code&gt; ,则省略偏移秒。</target>
        </trans-unit>
        <trans-unit id="b65b3c1c821ed13bb28df926804f32c12f3596c8" translate="yes" xml:space="preserve">
          <source>The local date-time is formatted as date string &lt;code&gt;YYYY-MM-DD HH:mm:ss.nnnnnnnnn +ZZ:ZZ:ZZ&lt;/code&gt;. Nanoseconds are omitted if &lt;em&gt;with_nanoseconds&lt;/em&gt; is &lt;code&gt;false&lt;/code&gt;. When the location is &lt;code&gt;UTC&lt;/code&gt;, the offset is omitted. Offset seconds are omitted if &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">本地日期时间格式为日期字符串 &lt;code&gt;YYYY-MM-DD HH:mm:ss.nnnnnnnnn +ZZ:ZZ:ZZ&lt;/code&gt; 。如果&lt;em&gt;with_nanoseconds&lt;/em&gt;为 &lt;code&gt;false&lt;/code&gt; ,则忽略纳秒。当位置为 &lt;code&gt;UTC&lt;/code&gt; 时，省略偏移量。如果为 &lt;code&gt;0&lt;/code&gt; ,则省略偏移秒。</target>
        </trans-unit>
        <trans-unit id="184d719b08c2753a11c73738ee57380c402105b8" translate="yes" xml:space="preserve">
          <source>The local date-time representation is resolved to a single instant based on the offset observed in the &lt;em&gt;location&lt;/em&gt; at this time.</source>
          <target state="translated">基于此时在该&lt;em&gt;位置&lt;/em&gt;观察到的偏移量，本地日期时间表示被解析为单个时刻。</target>
        </trans-unit>
        <trans-unit id="d2875926d172f8d83bdeccbac97d0322873b8baa" translate="yes" xml:space="preserve">
          <source>The local time zone can be accessed as &lt;code&gt;&lt;a href=&quot;location#local-class-method&quot;&gt;Time::Location.local&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">本地时区可以作为 &lt;code&gt;&lt;a href=&quot;location#local-class-method&quot;&gt;Time::Location.local&lt;/a&gt;&lt;/code&gt; 访问。</target>
        </trans-unit>
        <trans-unit id="90eeed6293d92c74a1e69b07b8426101885fd4b8" translate="yes" xml:space="preserve">
          <source>The lookup goes like this:</source>
          <target state="translated">查询的结果是这样的。</target>
        </trans-unit>
        <trans-unit id="bb7ce699e9b0bc8557c425725e6e5fe9464c66ee" translate="yes" xml:space="preserve">
          <source>The machine epsilon (difference between 1.0 and the next representable value)</source>
          <target state="translated">机器的epsilon(1.0和下一个可代表值之间的差值)。</target>
        </trans-unit>
        <trans-unit id="c390bce9391403d5c083998ebdf467a8babab09a" translate="yes" xml:space="preserve">
          <source>The macro basically defines a constructor accepting a &lt;code&gt;&lt;a href=&quot;json/pullparser&quot;&gt;JSON::PullParser&lt;/a&gt;&lt;/code&gt; that reads from it and initializes this type's instance variables. It also defines a &lt;code&gt;to_json(&lt;a href=&quot;json/builder&quot;&gt;JSON::Builder&lt;/a&gt;)&lt;/code&gt; method by invoking &lt;code&gt;to_json(&lt;a href=&quot;json/builder&quot;&gt;JSON::Builder&lt;/a&gt;)&lt;/code&gt; on each of the properties (unless a converter is specified, in which case &lt;code&gt;to_json(value, &lt;a href=&quot;json/builder&quot;&gt;JSON::Builder&lt;/a&gt;)&lt;/code&gt; is invoked).</source>
          <target state="translated">宏基本上定义了一个接受 &lt;code&gt;&lt;a href=&quot;json/pullparser&quot;&gt;JSON::PullParser&lt;/a&gt;&lt;/code&gt; 的构造函数，该构造函数从中读取并初始化此类型的实例变量。它还通过在每个属性上调用 &lt;code&gt;to_json(&lt;a href=&quot;json/builder&quot;&gt;JSON::Builder&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;json/builder&quot;&gt;JSON :: Builder&lt;/a&gt;）来定义 &lt;code&gt;to_json(&lt;a href=&quot;json/builder&quot;&gt;JSON::Builder&lt;/a&gt;)&lt;/code&gt; 方法（除非指定了转换器，否则将调用 &lt;code&gt;to_json(value, &lt;a href=&quot;json/builder&quot;&gt;JSON::Builder&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;json/builder&quot;&gt;JSON :: Builder&lt;/a&gt;））。</target>
        </trans-unit>
        <trans-unit id="613f7556e399e351df8b8582fba7c1a7af627c5d" translate="yes" xml:space="preserve">
          <source>The macro basically defines a constructor accepting a &lt;code&gt;&lt;a href=&quot;yaml/pullparser&quot;&gt;YAML::PullParser&lt;/a&gt;&lt;/code&gt; that reads from it and initializes this type's instance variables.</source>
          <target state="translated">宏基本上定义了一个接受 &lt;code&gt;&lt;a href=&quot;yaml/pullparser&quot;&gt;YAML::PullParser&lt;/a&gt;&lt;/code&gt; 的构造函数，该构造函数从中读取并初始化此类型的实例变量。</target>
        </trans-unit>
        <trans-unit id="66bec5e4d79d31c55fd05c99468c37789fb1e9e9" translate="yes" xml:space="preserve">
          <source>The macro basically translates the text inside the given file to Crystal code that appends to the IO:</source>
          <target state="translated">这个宏基本上是把给定文件里面的文字翻译成Crystal代码,追加到IO中。</target>
        </trans-unit>
        <trans-unit id="24cc5d7baa9f7f8a604002182c5829a497d36738" translate="yes" xml:space="preserve">
          <source>The main difference is that &lt;code&gt;&lt;a href=&quot;uri#encode_www_form(string:String,*,space_to_plus:Bool=true):String-class-method&quot;&gt;.encode_www_form&lt;/a&gt;&lt;/code&gt; encodes reserved characters (see &lt;code&gt;&lt;a href=&quot;uri#reserved?(byte):Bool-class-method&quot;&gt;.reserved?&lt;/a&gt;&lt;/code&gt;), while &lt;code&gt;&lt;a href=&quot;uri#encode(string:String,io:IO,*,space_to_plus:Bool=false):Nil-class-method&quot;&gt;.encode&lt;/a&gt;&lt;/code&gt; does not. The decode methods are identical except for the handling of &lt;code&gt;+&lt;/code&gt; characters.</source>
          <target state="translated">主要区别在于 &lt;code&gt;&lt;a href=&quot;uri#encode_www_form(string:String,*,space_to_plus:Bool=true):String-class-method&quot;&gt;.encode_www_form&lt;/a&gt;&lt;/code&gt; 对保留字符进行编码（请参阅 &lt;code&gt;&lt;a href=&quot;uri#reserved?(byte):Bool-class-method&quot;&gt;.reserved?&lt;/a&gt;&lt;/code&gt; ），而 &lt;code&gt;&lt;a href=&quot;uri#encode(string:String,io:IO,*,space_to_plus:Bool=false):Nil-class-method&quot;&gt;.encode&lt;/a&gt;&lt;/code&gt; 则不对。除处理 &lt;code&gt;+&lt;/code&gt; 字符外，解码方法相同。</target>
        </trans-unit>
        <trans-unit id="0fd8c5f9386095d91293b8f358c5e30735f376f5" translate="yes" xml:space="preserve">
          <source>The main differences between Windows and POSIX paths:</source>
          <target state="translated">Windows和POSIX路径的主要区别。</target>
        </trans-unit>
        <trans-unit id="92b88c577a0a19817b0fd3b6204cf9c516c60358" translate="yes" xml:space="preserve">
          <source>The major version of this semantic version</source>
          <target state="translated">这个语义版本的主要版本</target>
        </trans-unit>
        <trans-unit id="a542a8312c005e7f8ee22608266bfa27fba9017c" translate="yes" xml:space="preserve">
          <source>The maximum character.</source>
          <target state="translated">的最大特点。</target>
        </trans-unit>
        <trans-unit id="2e7ee3b80c77b27f4c54e9f5e5f26120adf74568" translate="yes" xml:space="preserve">
          <source>The maximum possible normal power of 2 exponent</source>
          <target state="translated">2指数的最大可能法向功率</target>
        </trans-unit>
        <trans-unit id="5d749b04f26091a11fffc09985e539c3f4376a94" translate="yes" xml:space="preserve">
          <source>The maximum possible power of 10 exponent (such that 10**MAX_10_EXP is representable)</source>
          <target state="translated">10的最大可能的指数幂(如10**MAX_10_EXP可表示)。</target>
        </trans-unit>
        <trans-unit id="efacea0a3e6d127c843098e6e5a8441a58d7fe7e" translate="yes" xml:space="preserve">
          <source>The maximum valid codepoint for a character.</source>
          <target state="translated">一个字符的最大有效编码点。</target>
        </trans-unit>
        <trans-unit id="4f1540445e5df2982cad31413cb4389367488faa" translate="yes" xml:space="preserve">
          <source>The measurement relies on the monotonic clock and is not affected by fluctuations of the system clock (see &lt;code&gt;&lt;a href=&quot;time#monotonic:Time::Span-class-method&quot;&gt;#monotonic&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">该测量依赖于单调时钟，不受系统时钟波动的影响（请参阅 &lt;code&gt;&lt;a href=&quot;time#monotonic:Time::Span-class-method&quot;&gt;#monotonic&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9785cceeff3afbae34b0159f6356ee230b9c1dbf" translate="yes" xml:space="preserve">
          <source>The memory is allocated by the &lt;code&gt;&lt;a href=&quot;gc&quot;&gt;GC&lt;/a&gt;&lt;/code&gt;, so when there are no pointers to this memory, it will be automatically freed.</source>
          <target state="translated">内存是由 &lt;code&gt;&lt;a href=&quot;gc&quot;&gt;GC&lt;/a&gt;&lt;/code&gt; 分配的，因此当没有指向该内存的指针时，它将自动释放。</target>
        </trans-unit>
        <trans-unit id="2a9acbe90587d703a07c3a5d3669e351d458e4b9" translate="yes" xml:space="preserve">
          <source>The messages have associated levels, such as &lt;code&gt;&lt;a href=&quot;logger#INFO&quot;&gt;INFO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#ERROR&quot;&gt;ERROR&lt;/a&gt;&lt;/code&gt; that indicate their importance. You can then give the &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger&lt;/a&gt;&lt;/code&gt; a level, and only messages at that level or higher will be printed.</source>
          <target state="translated">消息具有关联级别，例如 &lt;code&gt;&lt;a href=&quot;logger#INFO&quot;&gt;INFO&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;logger#ERROR&quot;&gt;ERROR&lt;/a&gt;&lt;/code&gt; ，指示它们的重要性。然后，您可以为 &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger&lt;/a&gt;&lt;/code&gt; 设置一个级别，并且只会打印该级别或更高级别的消息。</target>
        </trans-unit>
        <trans-unit id="79059b37ccde55e0de51ec59b6bc7015df02202c" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;time#to_s(format:String):String-instance-method&quot;&gt;#to_s&lt;/a&gt;&lt;/code&gt; formats the date-time according to a specified pattern.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time#to_s(format:String):String-instance-method&quot;&gt;#to_s&lt;/a&gt;&lt;/code&gt; 方法根据指定的格式格式化日期时间。</target>
        </trans-unit>
        <trans-unit id="b5f1647fa4d472453be3476f0555d8c316c55797" translate="yes" xml:space="preserve">
          <source>The minimum possible normal power of 2 exponent</source>
          <target state="translated">2指数的最小可能法向功率</target>
        </trans-unit>
        <trans-unit id="26806f6ed283af57d43319fb6240eff3c52738e3" translate="yes" xml:space="preserve">
          <source>The minimum possible power of 10 exponent (such that 10**MIN_10_EXP is representable)</source>
          <target state="translated">10指数的最小可能的幂(如10**MIN_10_EXP可表示)</target>
        </trans-unit>
        <trans-unit id="02879b0ef4ab29b6647d81af88e6c64df344a41b" translate="yes" xml:space="preserve">
          <source>The minor version of this semantic version</source>
          <target state="translated">这个语义版本的小版本</target>
        </trans-unit>
        <trans-unit id="699d0fce28e9c2d7583b258bd7c662d9d3baaac5" translate="yes" xml:space="preserve">
          <source>The most typical use case of a Deque is a queue: use &lt;code&gt;&lt;a href=&quot;deque#push(value:T)-instance-method&quot;&gt;#push&lt;/a&gt;&lt;/code&gt; to add items to the end of the queue and &lt;code&gt;&lt;a href=&quot;deque#shift-instance-method&quot;&gt;#shift&lt;/a&gt;&lt;/code&gt; to get and remove the item at the beginning of the queue.</source>
          <target state="translated">Deque最典型的用例是队列：使用 &lt;code&gt;&lt;a href=&quot;deque#push(value:T)-instance-method&quot;&gt;#push&lt;/a&gt;&lt;/code&gt; 将项目添加到队列的末尾，并使用 &lt;code&gt;&lt;a href=&quot;deque#shift-instance-method&quot;&gt;#shift&lt;/a&gt;&lt;/code&gt; 在队列的开头获取和删除项。</target>
        </trans-unit>
        <trans-unit id="ab75b012f87e2f58693175b5170d0957e5f7aa7a" translate="yes" xml:space="preserve">
          <source>The multicast hops option controls the &lt;code&gt;hoplimit&lt;/code&gt; field on uni-cast packets.</source>
          <target state="translated">multicast hops选项控制单播数据包上的 &lt;code&gt;hoplimit&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="376fe9ebc2a1cd19b33ca38e7c489c42078eb66c" translate="yes" xml:space="preserve">
          <source>The multicast hops option controls the &lt;code&gt;hoplimit&lt;/code&gt; field on uni-cast packets. If &lt;code&gt;-1&lt;/code&gt; is specified, the kernel will use a default value. If a value of &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt; is specified, the packet will have the specified value as &lt;code&gt;hoplimit&lt;/code&gt;. Other values are considered invalid and &lt;code&gt;&lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; will be raised. Datagrams with a &lt;code&gt;hoplimit&lt;/code&gt; of &lt;code&gt;1&lt;/code&gt; are not forwarded beyond the local network. Multicast datagrams with a &lt;code&gt;hoplimit&lt;/code&gt; of &lt;code&gt;0&lt;/code&gt; will not be transmitted on any network, but may be delivered locally if the sending host belongs to the destination group and multicast loopback is enabled.</source>
          <target state="translated">multicast hops选项控制单播数据包上的 &lt;code&gt;hoplimit&lt;/code&gt; 字段。如果指定 &lt;code&gt;-1&lt;/code&gt; ，则内核将使用默认值。如果指定的值为 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;255&lt;/code&gt; ，则数据包将具有指定的值作为 &lt;code&gt;hoplimit&lt;/code&gt; 。其他值将被视为无效，并且将引发 &lt;code&gt;&lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;hoplimit&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; 的数据报不会转发到本地网络之外。 &lt;code&gt;hoplimit&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; 的组播数据报将不会在任何网络上传输，但如果发送主机属于目标组并且启用了组播环回，则可以在本地传递。</target>
        </trans-unit>
        <trans-unit id="4e758fd8fecf2be686c56b541c8c809b3067485d" translate="yes" xml:space="preserve">
          <source>The name of the location is appended unless it is a fixed zone offset.</source>
          <target state="translated">除非是固定区域偏移,否则会附加位置名称。</target>
        </trans-unit>
        <trans-unit id="bb028927b758c34b9bde7df608f21b7744ef223a" translate="yes" xml:space="preserve">
          <source>The name of the null device on the host platform. &lt;code&gt;/dev/null&lt;/code&gt; on UNIX and &lt;code&gt;NUL&lt;/code&gt; on win32.</source>
          <target state="translated">主机平台上的空设备的名称。在UNIX上为 &lt;code&gt;/dev/null&lt;/code&gt; ，在Win32 上为 &lt;code&gt;NUL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03761e66dc106f1ff0d2f9d8bf80811bd74655c6" translate="yes" xml:space="preserve">
          <source>The name, the program was called with.</source>
          <target state="translated">这个名字,程序是用叫的。</target>
        </trans-unit>
        <trans-unit id="998e11cdecb726392509593efacde54c0ef63c06" translate="yes" xml:space="preserve">
          <source>The names of required named arguments</source>
          <target state="translated">所需命名参数的名称</target>
        </trans-unit>
        <trans-unit id="fe3101e5381913cbe1fe94ba506dd0a8d9967d33" translate="yes" xml:space="preserve">
          <source>The network address that sent the request to an HTTP server.</source>
          <target state="translated">向HTTP服务器发送请求的网络地址。</target>
        </trans-unit>
        <trans-unit id="eeaf65de799d8a96e82b49ec64d24bf6f6adcc89" translate="yes" xml:space="preserve">
          <source>The newly created fiber doesn't run as soon as spawned.</source>
          <target state="translated">新创建的光纤并不是一产出来就能运行的。</target>
        </trans-unit>
        <trans-unit id="78546fe92ed6fb2bc339f577731c0dfa103602db" translate="yes" xml:space="preserve">
          <source>The next sections will assume you know what &lt;a href=&quot;http://en.wikipedia.org/wiki/Object-oriented_programming&quot;&gt;object oriented programming&lt;/a&gt; is, as well as the concepts of &lt;a href=&quot;http://en.wikipedia.org/wiki/Class_%28computer_programming%29&quot;&gt;classes&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Method_%28computer_programming%29&quot;&gt;methods&lt;/a&gt;.</source>
          <target state="translated">下一节将假设您知道什么是&lt;a href=&quot;http://en.wikipedia.org/wiki/Object-oriented_programming&quot;&gt;面向对象的编程&lt;/a&gt;，以及&lt;a href=&quot;http://en.wikipedia.org/wiki/Class_%28computer_programming%29&quot;&gt;类&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/Method_%28computer_programming%29&quot;&gt;方法&lt;/a&gt;的概念。</target>
        </trans-unit>
        <trans-unit id="84b6a8ec5662f00d33bad19190ac9fa3fe3b584b" translate="yes" xml:space="preserve">
          <source>The nil literal.</source>
          <target state="translated">无的字面意思。</target>
        </trans-unit>
        <trans-unit id="9b372dff10b7db41b2b38e60b2637ac657fa7e7d" translate="yes" xml:space="preserve">
          <source>The node this alias points to.</source>
          <target state="translated">这个别名指向的节点。</target>
        </trans-unit>
        <trans-unit id="a5d79ff59503ed5a2b6e2a0095ca398a969d5aed" translate="yes" xml:space="preserve">
          <source>The node this alias points to. This is set by &lt;code&gt;&lt;a href=&quot;../nodes#parse(string_or_io:String%7CIO):Document-class-method&quot;&gt;YAML::Nodes.parse&lt;/a&gt;&lt;/code&gt;, and is &lt;code&gt;nil&lt;/code&gt; by default.</source>
          <target state="translated">该别名指向的节点。这是由 &lt;code&gt;&lt;a href=&quot;../nodes#parse(string_or_io:String%7CIO):Document-class-method&quot;&gt;YAML::Nodes.parse&lt;/a&gt;&lt;/code&gt; 设置的，默认情况下为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28778dee70b04f98759125cf3fc5bb7f4cbd09e0" translate="yes" xml:space="preserve">
          <source>The nodes in this sequence.</source>
          <target state="translated">这个序列中的节点。</target>
        </trans-unit>
        <trans-unit id="4f34511776ef20fe5fe37858e9a7500523697d6f" translate="yes" xml:space="preserve">
          <source>The nodes inside this document.</source>
          <target state="translated">这个文件里面的节点。</target>
        </trans-unit>
        <trans-unit id="2e01fbb822b433fee2ee41c5d94d65e6bee0ae25" translate="yes" xml:space="preserve">
          <source>The nodes inside this mapping, stored linearly as key1 - value1 - key2 - value2 - etc.</source>
          <target state="translated">这个映射里面的节点,线性存储为key1-value1-key2-value2-等。</target>
        </trans-unit>
        <trans-unit id="3d8239dccc739a59a3b15148a539406e9882bd09" translate="yes" xml:space="preserve">
          <source>The number of arguments</source>
          <target state="translated">论据的数量</target>
        </trans-unit>
        <trans-unit id="2d7047afe7f2ecf95be173685099de7fb2d47de5" translate="yes" xml:space="preserve">
          <source>The number of bits the BitArray stores</source>
          <target state="translated">BitArray存储的位数</target>
        </trans-unit>
        <trans-unit id="932f50d2358bc832f13ffe65aea2d8ccd4f87f12" translate="yes" xml:space="preserve">
          <source>The number of decimal digits that can be represented without losing precision</source>
          <target state="translated">在不损失精度的情况下,可以表示的小数位数的数量</target>
        </trans-unit>
        <trans-unit id="149402a56e543f699a338dcf5bd5983e726d28d9" translate="yes" xml:space="preserve">
          <source>The number of digits that can be represented without losing precision (in base RADIX)</source>
          <target state="translated">在不损失精度的情况下可以表示的数字数量(以RADIX为基准)</target>
        </trans-unit>
        <trans-unit id="d7af8f92e80d575a308150c0f91dc9b8fb13e781" translate="yes" xml:space="preserve">
          <source>The number of months.</source>
          <target state="translated">月数。</target>
        </trans-unit>
        <trans-unit id="c16a1a82cd0e589217f9fa691b14825aefa0cf34" translate="yes" xml:space="preserve">
          <source>The number of probes sent, without response before dropping the connection.</source>
          <target state="translated">发送的探测次数,在放弃连接前没有响应。</target>
        </trans-unit>
        <trans-unit id="d3811a0131b55024431ec7bed658225d7b97cb55" translate="yes" xml:space="preserve">
          <source>The number of remaining bytes to be read.</source>
          <target state="translated">要读取的剩余字节数。</target>
        </trans-unit>
        <trans-unit id="f338fe73db5a49e1625a8e98ce8a3f1c3f45295a" translate="yes" xml:space="preserve">
          <source>The only difference is that the first error message is a little more clear, but both definitions are safe in that you will get a compile time error anyway. So, in general, it's preferable not to specify type restrictions and almost only use them to define different method overloads. This results in more generic, reusable code. For example, if we define a class that has a &lt;code&gt;+&lt;/code&gt; method but isn't a &lt;code&gt;Number&lt;/code&gt;, we can use the &lt;code&gt;add&lt;/code&gt; method that doesn't have type restrictions, but we can't use the &lt;code&gt;add&lt;/code&gt; method that has restrictions.</source>
          <target state="translated">唯一的区别是第一个错误消息更加清晰，但是两个定义都是安全的，因为无论如何您都会遇到编译时错误。因此，通常最好不要指定类型限制，而仅使用它们来定义不同的方法重载。这将导致更通用，可重用的代码。例如，如果我们定义一个拥有类 &lt;code&gt;+&lt;/code&gt; 方法，但不是一个 &lt;code&gt;Number&lt;/code&gt; ，我们可以使用 &lt;code&gt;add&lt;/code&gt; 不具有类型限制的方法，但我们不能使用 &lt;code&gt;add&lt;/code&gt; 有限制方法。</target>
        </trans-unit>
        <trans-unit id="f16ae79b25ed11b7aa9209daf53be8357e5448f0" translate="yes" xml:space="preserve">
          <source>The only falsey values are &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; and null pointers (pointers whose memory address is zero). Any other value is truthy.</source>
          <target state="translated">唯一的falsey值是 &lt;code&gt;nil&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; 和null指针（内存地址为零的指针）。任何其他值都是真实的。</target>
        </trans-unit>
        <trans-unit id="d2ba520fa51fd8d8b9e4a636c0e3159d95a00a2a" translate="yes" xml:space="preserve">
          <source>The only requirement for a type including the &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; module is to define these two methods:</source>
          <target state="translated">对于包括 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 模块的类型的唯一要求是定义以下两种方法：</target>
        </trans-unit>
        <trans-unit id="35c3020364682ec2b277f82b96428ea6e1c5b328" translate="yes" xml:space="preserve">
          <source>The only time zone offset in this location is &lt;code&gt;&lt;a href=&quot;location/zone#UTC&quot;&gt;Zone::UTC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在此位置的唯一时区偏移是 &lt;code&gt;&lt;a href=&quot;location/zone#UTC&quot;&gt;Zone::UTC&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bad3c4ba1e595dfe6ef41f8dda662776cbc13df2" translate="yes" xml:space="preserve">
          <source>The optional anchor of a node.</source>
          <target state="translated">节点的可选锚点。</target>
        </trans-unit>
        <trans-unit id="a23d3869181b7966eed7da248d4c565267255680" translate="yes" xml:space="preserve">
          <source>The optional parameters &lt;em&gt;calculation&lt;/em&gt; and &lt;em&gt;warmup&lt;/em&gt; set the duration of those stages in seconds. For more detail on these stages see &lt;code&gt;&lt;a href=&quot;benchmark/ips&quot;&gt;Benchmark::IPS&lt;/a&gt;&lt;/code&gt;. When the &lt;em&gt;interactive&lt;/em&gt; parameter is &lt;code&gt;true&lt;/code&gt;, results are displayed and updated as they are calculated, otherwise all at once.</source>
          <target state="translated">可选参数&lt;em&gt;计算&lt;/em&gt;和&lt;em&gt;预热&lt;/em&gt;以秒为单位设置这些阶段的持续时间。有关这些阶段的更多详细信息，请参见 &lt;code&gt;&lt;a href=&quot;benchmark/ips&quot;&gt;Benchmark::IPS&lt;/a&gt;&lt;/code&gt; 。当&lt;em&gt;交互式&lt;/em&gt;参数为 &lt;code&gt;true&lt;/code&gt; 时，将在计算结果时显示并更新结果，否则将一次显示所有结果。</target>
        </trans-unit>
        <trans-unit id="908488df9900589a734ddda7befd0be561a2bb36" translate="yes" xml:space="preserve">
          <source>The optional tag of a node.</source>
          <target state="translated">节点的可选标签。</target>
        </trans-unit>
        <trans-unit id="bcd1e063d92bbe1e8714e2ac9c830c4af18736b0" translate="yes" xml:space="preserve">
          <source>The parser doesn't create this nodes. Instead, you create them by invoking &lt;code&gt;&lt;a href=&quot;macroid#id:MacroId-instance-method&quot;&gt;#id&lt;/a&gt;&lt;/code&gt; on some nodes. For example, invoking &lt;code&gt;&lt;a href=&quot;macroid#id:MacroId-instance-method&quot;&gt;#id&lt;/a&gt;&lt;/code&gt; on a &lt;code&gt;&lt;a href=&quot;stringliteral&quot;&gt;StringLiteral&lt;/a&gt;&lt;/code&gt; returns a &lt;code&gt;&lt;a href=&quot;macroid&quot;&gt;MacroId&lt;/a&gt;&lt;/code&gt; for the string's content. Similarly, invoking ID on a &lt;code&gt;&lt;a href=&quot;symbolliteral&quot;&gt;SymbolLiteral&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;call&quot;&gt;Call&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;var&quot;&gt;Var&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;path&quot;&gt;Path&lt;/a&gt;&lt;/code&gt; return MacroIds for the node's content.</source>
          <target state="translated">解析器不会创建此节点。相反，您可以通过在某些节点上调用 &lt;code&gt;&lt;a href=&quot;macroid#id:MacroId-instance-method&quot;&gt;#id&lt;/a&gt;&lt;/code&gt; 来创建它们。例如，在 &lt;code&gt;&lt;a href=&quot;stringliteral&quot;&gt;StringLiteral&lt;/a&gt;&lt;/code&gt; 上调用 &lt;code&gt;&lt;a href=&quot;macroid#id:MacroId-instance-method&quot;&gt;#id&lt;/a&gt;&lt;/code&gt; 将返回字符串内容的 &lt;code&gt;&lt;a href=&quot;macroid&quot;&gt;MacroId&lt;/a&gt;&lt;/code&gt; 。同样，在 &lt;code&gt;&lt;a href=&quot;symbolliteral&quot;&gt;SymbolLiteral&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;call&quot;&gt;Call&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;var&quot;&gt;Var&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;path&quot;&gt;Path&lt;/a&gt;&lt;/code&gt; 上调用ID会返回该节点内容的MacroIds。</target>
        </trans-unit>
        <trans-unit id="9c6ed999e32833699167efee30205c6dfdd62852" translate="yes" xml:space="preserve">
          <source>The passed arguments become a &lt;a href=&quot;http://crystal-lang.org/api/Tuple.html&quot;&gt;Tuple&lt;/a&gt; in the method's body:</source>
          <target state="translated">传递的参数成为方法主体中的&lt;a href=&quot;http://crystal-lang.org/api/Tuple.html&quot;&gt;元组&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a7cc3f4b05b7a37abb5d8eddb88666e0d6ce2da3" translate="yes" xml:space="preserve">
          <source>The patch version of this semantic version</source>
          <target state="translated">这个语义版本的补丁版本</target>
        </trans-unit>
        <trans-unit id="abef7a9a36ac8826e0db03a19e466cedc6f95840" translate="yes" xml:space="preserve">
          <source>The path will be placed in &lt;em&gt;dir&lt;/em&gt; which defaults to the standard temporary directory &lt;code&gt;&lt;a href=&quot;dir#tempdir:String-class-method&quot;&gt;Dir.tempdir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">路径将放置在&lt;em&gt;dir&lt;/em&gt;中，该&lt;em&gt;目录&lt;/em&gt;默认为标准临时目录 &lt;code&gt;&lt;a href=&quot;dir#tempdir:String-class-method&quot;&gt;Dir.tempdir&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a42b6a28a3631b4b8690c59ec23c2cf33ba5461" translate="yes" xml:space="preserve">
          <source>The pattern of a format is a &lt;code&gt;&lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with directives. Directives being with a percent (&lt;code&gt;%&lt;/code&gt;) character. Any text not listed as a directive will be passed/parsed through the output/input string.</source>
          <target state="translated">格式的模式是带有指令的 &lt;code&gt;&lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。指令具有百分比（ &lt;code&gt;%&lt;/code&gt; ）字符。未列为指令的任何文本都将通过输出/输入字符串传递/解析。</target>
        </trans-unit>
        <trans-unit id="63fcbfebaa791ff8cd52d2e73c34aadd82558129" translate="yes" xml:space="preserve">
          <source>The pattern syntax is similar to shell filename globbing, see &lt;code&gt;&lt;a href=&quot;file#match?(pattern:String,path:Path%7CString)-class-method&quot;&gt;File.match?&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">模式语法类似于外壳程序文件名通配，请参见 &lt;code&gt;&lt;a href=&quot;file#match?(pattern:String,path:Path%7CString)-class-method&quot;&gt;File.match?&lt;/a&gt;&lt;/code&gt; 有关详细信息。</target>
        </trans-unit>
        <trans-unit id="b8c653ef61db759eaee9f377523533373a490dfb" translate="yes" xml:space="preserve">
          <source>The pattern syntax is similar to shell filename globbing. It may contain the following metacharacters:</source>
          <target state="translated">该模式的语法与shell文件名globbing类似。它可能包含以下元字符。</target>
        </trans-unit>
        <trans-unit id="81cfa925e735950ad01227d0c7931b35b21fdca9" translate="yes" xml:space="preserve">
          <source>The permissions of the file.</source>
          <target state="translated">文件的权限。</target>
        </trans-unit>
        <trans-unit id="2cb51394b11ccdeba5fb3a77769718aec470abb3" translate="yes" xml:space="preserve">
          <source>The pipe (&lt;code&gt;|&lt;/code&gt;) in types creates a union type. &lt;code&gt;Int32 | String&lt;/code&gt; is read &quot;Int32 or String&quot;. In regular code, &lt;code&gt;Int32 | String&lt;/code&gt; means invoking the method &lt;code&gt;|&lt;/code&gt; on &lt;code&gt;Int32&lt;/code&gt; with &lt;code&gt;String&lt;/code&gt; as an argument.</source>
          <target state="translated">类型中的管道（ &lt;code&gt;|&lt;/code&gt; ）创建联合类型。 &lt;code&gt;Int32 | String&lt;/code&gt; 读取为&amp;ldquo; Int32或字符串&amp;rdquo;。在常规代码中， &lt;code&gt;Int32 | String&lt;/code&gt; 表示调用方法 &lt;code&gt;|&lt;/code&gt; 在 &lt;code&gt;Int32&lt;/code&gt; 上,使用 &lt;code&gt;String&lt;/code&gt; 作为参数。</target>
        </trans-unit>
        <trans-unit id="233339fd0b1f8ab1f56c72f3df860dc75ecd12fd" translate="yes" xml:space="preserve">
          <source>The port of the HTTP server is set by using the method bind_tcp on the object HTTP::Server (the port set to 8080).</source>
          <target state="translated">HTTP服务器的端口是通过使用对象HTTP::Server上的bind_tcp方法设置的(端口设置为8080)。</target>
        </trans-unit>
        <trans-unit id="32fc4b8244c63bfc760d47d4cab241e356f6f852" translate="yes" xml:space="preserve">
          <source>The pre-release version of this semantic version</source>
          <target state="translated">该语义版本的预发布版本。</target>
        </trans-unit>
        <trans-unit id="05a899a7976a7c20096dbfcb3e00d17266d2e22d" translate="yes" xml:space="preserve">
          <source>The primary purpose of this method is to &quot;tap into&quot; a method chain, in order to perform operations on intermediate results within the chain.</source>
          <target state="translated">该方法的主要目的是 &quot;挖掘 &quot;一个方法链,以便对链中的中间结果进行操作。</target>
        </trans-unit>
        <trans-unit id="ff2bfab5292b6da8c94127d4e62ad66fb860ebee" translate="yes" xml:space="preserve">
          <source>The program is a global object in which you can define types, methods and file-local variables.</source>
          <target state="translated">该程序是一个全局对象,你可以在其中定义类型、方法和文件本地变量。</target>
        </trans-unit>
        <trans-unit id="410f4045bdc9aa8c631b549d702681603bdcd1db" translate="yes" xml:space="preserve">
          <source>The program&amp;rsquo;s source code must be encoded in UTF-8.</source>
          <target state="translated">程序的源代码必须使用UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="d2b5672b6507164d54702ad6643e33f901bb8b66" translate="yes" xml:space="preserve">
          <source>The properties can be type declarations or assignments.</source>
          <target state="translated">属性可以是类型声明或赋值。</target>
        </trans-unit>
        <trans-unit id="41aac7aa54673bdaa8c5b39c8053f16352cd59e1" translate="yes" xml:space="preserve">
          <source>The pseudo-method &lt;code&gt;is_a?&lt;/code&gt; determines whether an expression's runtime type inherits or includes another type. For example:</source>
          <target state="translated">伪方法 &lt;code&gt;is_a?&lt;/code&gt; 确定表达式的运行时类型是继承还是包含另一个类型。例如：</target>
        </trans-unit>
        <trans-unit id="1f507cd5dd906a5abf05bd1ee75a2fac5c1c15a6" translate="yes" xml:space="preserve">
          <source>The pseudo-method &lt;code&gt;nil?&lt;/code&gt; determines whether an expression's runtime type is &lt;code&gt;Nil&lt;/code&gt;. For example:</source>
          <target state="translated">伪方法 &lt;code&gt;nil?&lt;/code&gt; 确定表达式的运行时类型是否为 &lt;code&gt;Nil&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="932b82bb016d54d7c862b35543ed93ac64fae6f3" translate="yes" xml:space="preserve">
          <source>The pseudo-method &lt;code&gt;responds_to?&lt;/code&gt; determines whether a type has a method with the given name. For example:</source>
          <target state="translated">伪方法 &lt;code&gt;responds_to?&lt;/code&gt; 确定类型是否具有具有给定名称的方法。例如：</target>
        </trans-unit>
        <trans-unit id="f110f55fd959c5e5afa44c1cdba8507d00eed545" translate="yes" xml:space="preserve">
          <source>The purpose of using base64 to encode data is that it translates any binary data into purely printable characters.</source>
          <target state="translated">使用base64对数据进行编码的目的是,它将任何二进制数据转化为纯粹的可打印字符。</target>
        </trans-unit>
        <trans-unit id="20db04bff4ecb2dbf646dff1c64a3b517788a585" translate="yes" xml:space="preserve">
          <source>The radix or integer base used by the internal representation</source>
          <target state="translated">内部表示法使用的弧度或整数基数。</target>
        </trans-unit>
        <trans-unit id="d428f13bac087ac4e3400df32671a4193fd24329" translate="yes" xml:space="preserve">
          <source>The raw file-descriptor.</source>
          <target state="translated">原始文件描述符。</target>
        </trans-unit>
        <trans-unit id="b778b37dfbc8f3ee7e3ed2bdf2dd7305706404db" translate="yes" xml:space="preserve">
          <source>The raw file-descriptor. It is defined to be an &lt;code&gt;&lt;a href=&quot;../int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, but its size is platform-specific.</source>
          <target state="translated">原始文件描述符。它定义为 &lt;code&gt;&lt;a href=&quot;../int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ，但是其大小是特定于平台的。</target>
        </trans-unit>
        <trans-unit id="8db9410acd7129114bee57055d831caef51f8eca" translate="yes" xml:space="preserve">
          <source>The real reason the compiler does this is to be able to compile programs faster by not creating all kinds of different similar unions, also making the generated code smaller in size. But, on the other hand, it makes sense: classes under the same hierarchy should behave in a similar way.</source>
          <target state="translated">编译器这样做的真正原因是为了能够更快地编译程序,不创建各种不同的类似联合,也使得生成的代码体积更小。但另一方面,这也是合理的:同一层次结构下的类应该以类似的方式表现。</target>
        </trans-unit>
        <trans-unit id="76a389bb689114456985a25fbbce6ca4de3e5f74" translate="yes" xml:space="preserve">
          <source>The reason for allowing strings that don't have a valid UTF-8 sequence is that the world is full of content that isn't properly encoded, and having a program raise an exception or stop because of this is not good. It's better if programs are more resilient, but show a replacement character when there's an error in incoming data.</source>
          <target state="translated">之所以允许没有有效UTF-8序列的字符串,是因为这个世界上有很多没有正确编码的内容,让程序因此引发异常或停止是不好的。如果程序的弹性比较大,但在传入的数据出现错误时,显示一个替换字符,那就更好了。</target>
        </trans-unit>
        <trans-unit id="32f40650fb7ccf8892e0237620999a8152370e25" translate="yes" xml:space="preserve">
          <source>The reason for this is that a fiber is not executed as soon as it is spawned. So, the main fiber, the one that spawns the above fiber, finishes its execution and the program exits.</source>
          <target state="translated">原因是,一个光纤不是一产生就执行的。所以,催生上述光纤的主光纤,完成执行,程序退出。</target>
        </trans-unit>
        <trans-unit id="ff10dcb440a08b16e31eefc8ffaede37d73590f0" translate="yes" xml:space="preserve">
          <source>The reason for this is to allow creating Domain Specific Languages (DSLs) using &lt;code&gt;do ... end&lt;/code&gt; to have them be read as plain English:</source>
          <target state="translated">这样做的原因是允许使用 &lt;code&gt;do ... end&lt;/code&gt; 创建域特定语言（DSL），以便将它们读为纯英文：</target>
        </trans-unit>
        <trans-unit id="d78935ddfd4649c6aa2826ace20fab5bbc112bc0" translate="yes" xml:space="preserve">
          <source>The reason why &lt;code&gt;socket.gets&lt;/code&gt; and &lt;code&gt;sleep&lt;/code&gt; behave like this is because their implementations talk directly with the Runtime Scheduler and the Event Loop, there's nothing magical about it. In general, the standard library already takes care of doing all of this so you don't have to.</source>
          <target state="translated">之所以 &lt;code&gt;socket.gets&lt;/code&gt; 和 &lt;code&gt;sleep&lt;/code&gt; 这样的表现是因为他们的实现直接与运行调度和事件循环谈话，有关于它的什么魔力。通常，标准库已经做好了所有这些工作，因此您不必这样做。</target>
        </trans-unit>
        <trans-unit id="871034b7273a5a75ceafcc5e70590aba4b1c957a" translate="yes" xml:space="preserve">
          <source>The recommended thing to do is to use enums whenever possible, only use symbols for the internal implementation of an API, and avoid symbols for public APIs. But you are free to do what you want.</source>
          <target state="translated">推荐的做法是尽可能使用枚举,只使用API内部实现的符号,避免使用公共API的符号。但你可以自由地做你想做的事情。</target>
        </trans-unit>
        <trans-unit id="ed914447670b399ebc6cc6e220541dba265b2d70" translate="yes" xml:space="preserve">
          <source>The registry will be populated with some default values (see &lt;code&gt;&lt;a href=&quot;mime#DEFAULT_TYPES&quot;&gt;DEFAULT_TYPES&lt;/a&gt;&lt;/code&gt;) as well as the operating system's MIME database.</source>
          <target state="translated">该注册表将填充一些默认值（请参阅 &lt;code&gt;&lt;a href=&quot;mime#DEFAULT_TYPES&quot;&gt;DEFAULT_TYPES&lt;/a&gt;&lt;/code&gt; ）以及操作系统的MIME数据库。</target>
        </trans-unit>
        <trans-unit id="4b847bda892ee576c2c6d6db160250aaf567ab70" translate="yes" xml:space="preserve">
          <source>The regular expression language can be used to match much more than just the static substrings in the above examples. Certain characters, called &lt;a href=&quot;http://www.pcre.org/original/doc/html/pcrepattern.html#SEC4&quot;&gt;metacharacters&lt;/a&gt;, are given special treatment in regular expressions, and can be used to describe more complex patterns. To match metacharacters literally in a regular expression, they must be escaped by being preceded with a backslash (&lt;code&gt;\&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;regex#escape(str):String-class-method&quot;&gt;.escape&lt;/a&gt;&lt;/code&gt; will do this automatically for a given String.</source>
          <target state="translated">在上述示例中，除了静态子字符串之外，正则表达式语言还可以用于匹配更多内容。某些称为&lt;a href=&quot;http://www.pcre.org/original/doc/html/pcrepattern.html#SEC4&quot;&gt;元字符的字符&lt;/a&gt;会在正则表达式中得到特殊处理，并可用于描述更复杂的模式。要在正则表达式中按字面值匹配元字符，必须在它们前面加反斜杠（ &lt;code&gt;\&lt;/code&gt; ）进行转义。 &lt;code&gt;&lt;a href=&quot;regex#escape(str):String-class-method&quot;&gt;.escape&lt;/a&gt;&lt;/code&gt; 将针对给定的String自动执行此操作。</target>
        </trans-unit>
        <trans-unit id="e24cf27decc46c3ee89d81610dfaa54465672459" translate="yes" xml:space="preserve">
          <source>The replacement character, used on invalid UTF-8 byte sequences.</source>
          <target state="translated">替换字符,用于无效的UTF-8字节序列。</target>
        </trans-unit>
        <trans-unit id="d1b8275b80e6086dd1f4f8d0cc0a9b6f3288eaa7" translate="yes" xml:space="preserve">
          <source>The request line is the first line of a request, consisting of method, resource and HTTP version and the delimiting line break. If the request line has a larger byte size than the permitted size, the server responds with the status code &lt;code&gt;414 &lt;a href=&quot;../uri&quot;&gt;URI&lt;/a&gt; Too Long&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;status#URI_TOO_LONG&quot;&gt;HTTP::Status::URI_TOO_LONG&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">请求行是请求的第一行，由方法，资源和HTTP版本以及分隔行组成。如果请求行的字节大小大于允许的大小，则服务器将以状态代码 &lt;code&gt;414 &lt;a href=&quot;../uri&quot;&gt;URI&lt;/a&gt; Too Long&lt;/code&gt; 做出响应（请参阅 &lt;code&gt;&lt;a href=&quot;status#URI_TOO_LONG&quot;&gt;HTTP::Status::URI_TOO_LONG&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e105b4ab54d3af5634616d46ec5b245306ef0d26" translate="yes" xml:space="preserve">
          <source>The request processor supports reusing a connection for subsequent requests. This is used by default for HTTP/1.1 or when requested by the &lt;code&gt;Connection: keep-alive&lt;/code&gt; header. This is signalled by this header being set on the &lt;code&gt;&lt;a href=&quot;server/response&quot;&gt;HTTP::Server::Response&lt;/a&gt;&lt;/code&gt; when it's passed into the handler chain.</source>
          <target state="translated">请求处理器支持为后续请求重用连接。默认情况下，这用于HTTP / 1.1或在 &lt;code&gt;Connection: keep-alive&lt;/code&gt; 标头要求时使用。这是通过在将 &lt;code&gt;&lt;a href=&quot;server/response&quot;&gt;HTTP::Server::Response&lt;/a&gt;&lt;/code&gt; 传递到处理程序链中时设置的此标头表示的。</target>
        </trans-unit>
        <trans-unit id="b88ba33ed5a8577d60c284544ff80c1a4e44897f" translate="yes" xml:space="preserve">
          <source>The response &lt;code&gt;&lt;a href=&quot;response#status:HTTP::Status-instance-method&quot;&gt;#status&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;response#headers:HTTP::Headers-instance-method&quot;&gt;#headers&lt;/a&gt;&lt;/code&gt; must be configured before writing the response body. Once response output is written, changing the &lt;code&gt;&lt;a href=&quot;response#status:HTTP::Status-instance-method&quot;&gt;#status&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;response#headers:HTTP::Headers-instance-method&quot;&gt;#headers&lt;/a&gt;&lt;/code&gt; properties has no effect.</source>
          <target state="translated">在编写响应正文之前，必须先配置响应 &lt;code&gt;&lt;a href=&quot;response#status:HTTP::Status-instance-method&quot;&gt;#status&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;response#headers:HTTP::Headers-instance-method&quot;&gt;#headers&lt;/a&gt;&lt;/code&gt; 。写入响应输出后，更改 &lt;code&gt;&lt;a href=&quot;response#status:HTTP::Status-instance-method&quot;&gt;#status&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;response#headers:HTTP::Headers-instance-method&quot;&gt;#headers&lt;/a&gt;&lt;/code&gt; 属性无效。</target>
        </trans-unit>
        <trans-unit id="47dfc21a6b581b0ebea4ce9ed874b44dcdaf9b21" translate="yes" xml:space="preserve">
          <source>The response headers (&lt;code&gt;&lt;a href=&quot;../headers&quot;&gt;HTTP::Headers&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">响应头（ &lt;code&gt;&lt;a href=&quot;../headers&quot;&gt;HTTP::Headers&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ea18b79598116138833c1343a63330dce641f749" translate="yes" xml:space="preserve">
          <source>The response headers (&lt;code&gt;&lt;a href=&quot;../headers&quot;&gt;HTTP::Headers&lt;/a&gt;&lt;/code&gt;). These must be set before writing to the response.</source>
          <target state="translated">响应头（ &lt;code&gt;&lt;a href=&quot;../headers&quot;&gt;HTTP::Headers&lt;/a&gt;&lt;/code&gt; ）。必须在写入响应之前进行设置。</target>
        </trans-unit>
        <trans-unit id="8b8a7f07b6cad51f233e3cc0b531514a07faa6f1" translate="yes" xml:space="preserve">
          <source>The response to configure and write to in an &lt;code&gt;&lt;a href=&quot;../server&quot;&gt;HTTP::Server&lt;/a&gt;&lt;/code&gt; handler.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;../server&quot;&gt;HTTP::Server&lt;/a&gt;&lt;/code&gt; 处理程序中配置和写入的响应。</target>
        </trans-unit>
        <trans-unit id="e077049fc5824d3c9902b59488bdf5a911e88436" translate="yes" xml:space="preserve">
          <source>The result of the last expression is &lt;code&gt;2&lt;/code&gt; because the last expression of the &lt;code&gt;transform&lt;/code&gt; method is &lt;code&gt;yield&lt;/code&gt;, whose value is the last expression of the block.</source>
          <target state="translated">最后一个表达式的结果是 &lt;code&gt;2&lt;/code&gt; ,这是因为 &lt;code&gt;transform&lt;/code&gt; 方法的最后一个表达式是 &lt;code&gt;yield&lt;/code&gt; ，其值是该块的最后一个表达式。</target>
        </trans-unit>
        <trans-unit id="733d3c8c44e34a101276d18fb937671155352537" translate="yes" xml:space="preserve">
          <source>The result will be of the same type as &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">结果将与 &lt;code&gt;self&lt;/code&gt; 具有相同的类型。</target>
        </trans-unit>
        <trans-unit id="01be55a0c09b1d115faa58cff213ed7e949d0a99" translate="yes" xml:space="preserve">
          <source>The result:</source>
          <target state="translated">结果是:</target>
        </trans-unit>
        <trans-unit id="5a1e8d996521c557bb0b6c523dcd3bbfc54c3cbb" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;&lt;a href=&quot;time/span&quot;&gt;Time::Span&lt;/a&gt;&lt;/code&gt; could be anything, even negative, if the computer's wall clock has changed between both calls.</source>
          <target state="translated">如果两次调用之间计算机的挂钟都已更改，则生成的 &lt;code&gt;&lt;a href=&quot;time/span&quot;&gt;Time::Span&lt;/a&gt;&lt;/code&gt; 可以是任何值，甚至可以是负数。</target>
        </trans-unit>
        <trans-unit id="1374f2a214fc29ec026b6560950190d2f27a5380" translate="yes" xml:space="preserve">
          <source>The retry logic only happens when the statement is sent through the &lt;code&gt;DB::Database&lt;/code&gt; . If it is sent through a &lt;code&gt;DB::Connection&lt;/code&gt; or &lt;code&gt;DB::Transaction&lt;/code&gt; no retry is performed since the code will state that certain connection object was expected to be used.</source>
          <target state="translated">重试逻辑仅在通过 &lt;code&gt;DB::Database&lt;/code&gt; 发送语句时发生。如果通过 &lt;code&gt;DB::Connection&lt;/code&gt; 或 &lt;code&gt;DB::Transaction&lt;/code&gt; 不会重试，因为该代码将指出应使用某些连接对象。</target>
        </trans-unit>
        <trans-unit id="a8540bd690510195f15e7931fe703f354a5f3b1d" translate="yes" xml:space="preserve">
          <source>The return type (&lt;code&gt;R&lt;/code&gt;) is inferred from the proc's body.</source>
          <target state="translated">从proc的主体推断返回类型（ &lt;code&gt;R&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="758c3df4fe5522cca716f4959d3984d4de00a83d" translate="yes" xml:space="preserve">
          <source>The return type always matches the supplied argument.</source>
          <target state="translated">返回类型总是与提供的参数相匹配。</target>
        </trans-unit>
        <trans-unit id="3448118a3edd919f25ef0f0dc09cb242f5fb6078" translate="yes" xml:space="preserve">
          <source>The return type follows the &lt;a href=&quot;type_grammar&quot;&gt;type grammar&lt;/a&gt;.</source>
          <target state="translated">返回类型遵循&lt;a href=&quot;type_grammar&quot;&gt;语法类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6e8f1d3f064b877d12e7e77276c1b261bc1301c" translate="yes" xml:space="preserve">
          <source>The return type is inferred from the proc's body.</source>
          <target state="translated">返回类型是从proc的主体中推断出来的。</target>
        </trans-unit>
        <trans-unit id="ba15146dddd3805e6aafd90ca92392fc02411153" translate="yes" xml:space="preserve">
          <source>The return value is URL encoded (see &lt;code&gt;&lt;a href=&quot;uri#encode_www_form(string:String,*,space_to_plus:Bool=true):String-class-method&quot;&gt;#encode_www_form&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">返回值是URL编码的（请参阅 &lt;code&gt;&lt;a href=&quot;uri#encode_www_form(string:String,*,space_to_plus:Bool=true):String-class-method&quot;&gt;#encode_www_form&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a41b98c60f13bd33f50de5987af41c1bc1f24355" translate="yes" xml:space="preserve">
          <source>The returned bytes are only valid data until a next call to any method that reads from this IO is invoked.</source>
          <target state="translated">返回的字节是唯一有效的数据,直到下一次调用任何从这个IO读取的方法。</target>
        </trans-unit>
        <trans-unit id="ca10f5bd23d19910cc3b5a5821662339a7fc01fd" translate="yes" xml:space="preserve">
          <source>The returned iterator keeps a reference to &lt;code&gt;self&lt;/code&gt;. If the array changes, the returned values of the iterator will change as well.</source>
          <target state="translated">返回的迭代器保留对 &lt;code&gt;self&lt;/code&gt; 的引用。如果数组更改，则迭代器的返回值也将更改。</target>
        </trans-unit>
        <trans-unit id="c163c2e4a8684eaec7ec7ef40e2ef6f82f70a679" translate="yes" xml:space="preserve">
          <source>The returned iterator keeps a reference to &lt;code&gt;self&lt;/code&gt;: if the array changes, the returned values of the iterator change as well.</source>
          <target state="translated">返回的迭代器保留对 &lt;code&gt;self&lt;/code&gt; 的引用：如果数组更改，则迭代器的返回值也将更改。</target>
        </trans-unit>
        <trans-unit id="eaaf8298a043e29b9f15d7afcbed3821bc33033d" translate="yes" xml:space="preserve">
          <source>The returned path ends in a slash only if it is the root (&lt;code&gt;&quot;/&quot;&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, or &lt;code&gt;C:\&lt;/code&gt;).</source>
          <target state="translated">仅当返回的路径是根目录（ &lt;code&gt;&quot;/&quot;&lt;/code&gt; ， &lt;code&gt;\&lt;/code&gt; 或 &lt;code&gt;C:\&lt;/code&gt; ）时，才以斜杠结尾。</target>
        </trans-unit>
        <trans-unit id="7ba84998e4083bf39c469e9128922bd4627ee050" translate="yes" xml:space="preserve">
          <source>The returned slice is read-only.</source>
          <target state="translated">返回的片断是只读的。</target>
        </trans-unit>
        <trans-unit id="b0aa3484b0f403290cf3456d517f45e1f05be144" translate="yes" xml:space="preserve">
          <source>The returned value is either &lt;code&gt;28&lt;/code&gt;, &lt;code&gt;29&lt;/code&gt;, &lt;code&gt;30&lt;/code&gt; or &lt;code&gt;31&lt;/code&gt; depending on the month and whether &lt;em&gt;year&lt;/em&gt; is leap.</source>
          <target state="translated">返回的值是 &lt;code&gt;28&lt;/code&gt; ， &lt;code&gt;29&lt;/code&gt; ， &lt;code&gt;30&lt;/code&gt; 或 &lt;code&gt;31&lt;/code&gt; 取决于月份以及是否&lt;em&gt;今年&lt;/em&gt;是闰年。</target>
        </trans-unit>
        <trans-unit id="60f43ae195a0414e9e0d780a03fd061aa5077ba3" translate="yes" xml:space="preserve">
          <source>The returned value is the memory address of this object.</source>
          <target state="translated">返回值是该对象的内存地址。</target>
        </trans-unit>
        <trans-unit id="817be2696fc8bda33f1d0dfcf9b344691071ceb3" translate="yes" xml:space="preserve">
          <source>The rollback place in the &lt;code&gt;outer_tx&lt;/code&gt; block, rolled back all the changes including the ones in the &lt;code&gt;inner_tx&lt;/code&gt; block (the same happens if we use an &lt;strong&gt;explicit&lt;/strong&gt; rollback).</source>
          <target state="translated">在 &lt;code&gt;outer_tx&lt;/code&gt; 块中的回滚位置回滚了所有更改，包括在 &lt;code&gt;inner_tx&lt;/code&gt; 块中的更改（如果我们使用&lt;strong&gt;显式&lt;/strong&gt;回滚，也会发生同样的情况）。</target>
        </trans-unit>
        <trans-unit id="4aaf57eeda40665f5d6ffd28fb9d4804a63cc6dc" translate="yes" xml:space="preserve">
          <source>The rules are many, but usually the first three are most used. There's no need to remember them all. If the compiler gives an error saying that the type of an instance variable can't be inferred you can always add an explicit type restriction.</source>
          <target state="translated">规则很多,但通常前三条是最常用的。没有必要全部记住它们。如果编译器给出一个错误,说不能推断实例变量的类型,你总是可以添加一个显式类型限制。</target>
        </trans-unit>
        <trans-unit id="7fbfc3c71a4a49bb24ab10244af977b1a02a7857" translate="yes" xml:space="preserve">
          <source>The same &lt;a href=&quot;string#escaping&quot;&gt;escaping&lt;/a&gt; and &lt;a href=&quot;string#interpolation&quot;&gt;interpolation rules&lt;/a&gt; apply as for regular strings.</source>
          <target state="translated">相同的&lt;a href=&quot;string#escaping&quot;&gt;转义&lt;/a&gt;和&lt;a href=&quot;string#interpolation&quot;&gt;插值规则&lt;/a&gt;适用于常规字符串。</target>
        </trans-unit>
        <trans-unit id="2b5de9d90094355e321e66335957f0ad9d297b31" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;iterator#chain(other:Iterator(U))forallU-instance-method&quot;&gt;#chain&lt;/a&gt;&lt;/code&gt;, but have better performance when the quantity of iterators to chain is large (usually greater than 4) or undetermined.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;iterator#chain(other:Iterator(U))forallU-instance-method&quot;&gt;#chain&lt;/a&gt;&lt;/code&gt; 相同，但是当要迭代的迭代器数量很大（通常大于4）或不确定时，性能会更好。</target>
        </trans-unit>
        <trans-unit id="d0a69615b60b24353d9e889ae458216733c9db37" translate="yes" xml:space="preserve">
          <source>The same happens if a &lt;code&gt;DB::Rollback&lt;/code&gt; exception is raised in the &lt;code&gt;inner-transaction&lt;/code&gt; block.</source>
          <target state="translated">如果在 &lt;code&gt;inner-transaction&lt;/code&gt; 块中引发 &lt;code&gt;DB::Rollback&lt;/code&gt; 异常，则会发生相同的情况。</target>
        </trans-unit>
        <trans-unit id="aa6a16ecf1926d76b19dc30a2621c84ff610a5f5" translate="yes" xml:space="preserve">
          <source>The scheduler has a queue of:</source>
          <target state="translated">调度器有一个队列的。</target>
        </trans-unit>
        <trans-unit id="e5faa60b79497768401699ecbc6952402943aa59" translate="yes" xml:space="preserve">
          <source>The second point has a reason to it: a struct has a very well defined memory layout. For example, the above &lt;code&gt;Point&lt;/code&gt; struct occupies 8 bytes. If you have an array of points the points are embedded inside the array's buffer:</source>
          <target state="translated">第二点是有原因的：结构具有定义良好的内存布局。例如，上面的 &lt;code&gt;Point&lt;/code&gt; 结构占用8个字节。如果您有一个点数组，则这些点将嵌入在该数组的缓冲区内：</target>
        </trans-unit>
        <trans-unit id="58837c746502875a30ca81ecee4f35665f085248" translate="yes" xml:space="preserve">
          <source>The second rule means that in addition to having this:</source>
          <target state="translated">第二条规则的意思是,除了有这。</target>
        </trans-unit>
        <trans-unit id="280264e5f00aefda967a507dcc2d0993a8f297f0" translate="yes" xml:space="preserve">
          <source>The second use case is making a method argument more readable inside a method body:</source>
          <target state="translated">第二个用例是让方法参数在方法体中更易读。</target>
        </trans-unit>
        <trans-unit id="7815aa7b63e5cf450e5da058b4fe88113046ac95" translate="yes" xml:space="preserve">
          <source>The server can be bound to one ore more server sockets (see &lt;code&gt;&lt;a href=&quot;server#bind(socket:Socket::Server):Nil-instance-method&quot;&gt;#bind&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">该服务器可以绑定到一个或多个服务器套接字（请参阅 &lt;code&gt;&lt;a href=&quot;server#bind(socket:Socket::Server):Nil-instance-method&quot;&gt;#bind&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3c269eabfaf8d5876dd6cce873c27fe43e504a55" translate="yes" xml:space="preserve">
          <source>The server is closed after the block returns.</source>
          <target state="translated">块返回后,服务器被关闭。</target>
        </trans-unit>
        <trans-unit id="8e2c928c628330386116b324976d603f532b3d1e" translate="yes" xml:space="preserve">
          <source>The server is of stream type by default, but this can be changed for another type. For example datagram messages:</source>
          <target state="translated">服务器默认为流类型,但可以更改为其他类型。例如数据报消息。</target>
        </trans-unit>
        <trans-unit id="1d8d131af24fedcb05379bb424565311ccabb7b4" translate="yes" xml:space="preserve">
          <source>The set of possible valid body types.</source>
          <target state="translated">一组可能的有效体型;</target>
        </trans-unit>
        <trans-unit id="e0a0f26cd8826d6609eb76ff98b7304117eb9322" translate="yes" xml:space="preserve">
          <source>The shards command</source>
          <target state="translated">碎片指令</target>
        </trans-unit>
        <trans-unit id="d360149d4d7970bf59a8f5f65d6616a53b982bb0" translate="yes" xml:space="preserve">
          <source>The slice is allocated on the heap.</source>
          <target state="translated">分片在堆上分配。</target>
        </trans-unit>
        <trans-unit id="6a6e46f46717c7f49e7376a0bdbcc3ffb03b2720" translate="yes" xml:space="preserve">
          <source>The special flags this file has set.</source>
          <target state="translated">本文件设置的特殊标志。</target>
        </trans-unit>
        <trans-unit id="115ebf7822765608fcd39b3ed96add2129447699" translate="yes" xml:space="preserve">
          <source>The special variable &lt;code&gt;$?&lt;/code&gt; holds the exit status of the command as a &lt;a href=&quot;https://crystal-lang.org/api/0.27.0/Process/Status.html&quot;&gt;&lt;code&gt;Process::Status&lt;/code&gt;&lt;/a&gt;. It is only available in the same scope as the command literal.</source>
          <target state="translated">特殊变量 &lt;code&gt;$?&lt;/code&gt; 将命令的退出状态保存为&lt;a href=&quot;https://crystal-lang.org/api/0.27.0/Process/Status.html&quot;&gt; &lt;code&gt;Process::Status&lt;/code&gt; &lt;/a&gt;。它仅在与命令文字相同的作用域中可用。</target>
        </trans-unit>
        <trans-unit id="3e3557d004003192cd5542d3fc51ebf51e51916e" translate="yes" xml:space="preserve">
          <source>The splat argument can also be left unnamed, with the meaning &quot;after this, named arguments follow&quot;:</source>
          <target state="translated">溅射参数也可以不命名,其含义是 &quot;在这之后,命名的参数随之而来&quot;。</target>
        </trans-unit>
        <trans-unit id="e1dc669a05db5c0342be9ec8b5a7d8be9bb1fd07" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; configuration of a process.</source>
          <target state="translated">进程的标准 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 配置。</target>
        </trans-unit>
        <trans-unit id="06ccce70ab599789110874bf990f283bccb902c9" translate="yes" xml:space="preserve">
          <source>The standard error file descriptor.</source>
          <target state="translated">标准错误文件描述符。</target>
        </trans-unit>
        <trans-unit id="ed95cff6c55ece7cd2f7db46939b98071cc0bd1d" translate="yes" xml:space="preserve">
          <source>The standard input file descriptor. Contains data piped to the program.</source>
          <target state="translated">标准输入文件描述符。包含传送到程序的数据。</target>
        </trans-unit>
        <trans-unit id="0647c890a1da53d6297b74b407afd68f13114f12" translate="yes" xml:space="preserve">
          <source>The standard library defines the &lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/lib_c.cr&quot;&gt;LibC&lt;/a&gt; lib with aliases for common C types, like &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;size_t&lt;/code&gt;. Use them in bindings like this:</source>
          <target state="translated">标准库使用常见C类型（如 &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;size_t&lt;/code&gt; )的别名定义&lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/lib_c.cr&quot;&gt;LibC&lt;/a&gt;库。像这样在绑定中使用它们：</target>
        </trans-unit>
        <trans-unit id="b7487ca8fa2486d67a8aee18fce65b6a02c53afb" translate="yes" xml:space="preserve">
          <source>The standard library provides a useful &lt;code&gt;&lt;a href=&quot;toplevel#record(name,*properties)-macro&quot;&gt;record&lt;/a&gt;&lt;/code&gt; macro that allows you to create immutable structs with some fields, similar to a &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;Tuple&lt;/a&gt;&lt;/code&gt; but using names instead of indices.</source>
          <target state="translated">标准库提供了一个有用的 &lt;code&gt;&lt;a href=&quot;toplevel#record(name,*properties)-macro&quot;&gt;record&lt;/a&gt;&lt;/code&gt; 宏，它允许您使用某些字段创建不可变的结构，类似于 &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;Tuple&lt;/a&gt;&lt;/code&gt; 但使用名称而不是索引。</target>
        </trans-unit>
        <trans-unit id="9ad70d1504d698d2fa851744f3b13ca5f52cdae4" translate="yes" xml:space="preserve">
          <source>The standard library provides iterators for many classes, like &lt;code&gt;&lt;a href=&quot;array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;. Usually to get an iterator you invoke a method that would usually yield elements to a block, but without passing a block: &lt;code&gt;Array#each&lt;/code&gt;, &lt;code&gt;Array#each_index&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;hash#each(&amp;amp;block):Nil-instance-method&quot;&gt;Hash#each&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;string#each_char-instance-method&quot;&gt;String#each_char&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io#each_line(*args,**options,&amp;amp;block:String-%3E):Nil-instance-method&quot;&gt;IO#each_line&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">标准库为许多类提供了迭代器，例如 &lt;code&gt;&lt;a href=&quot;array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 。通常，要获取迭代器，您需要调用通常会向一个块产生元素但不传递块的方法： &lt;code&gt;Array#each&lt;/code&gt; ， &lt;code&gt;Array#each_index&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;hash#each(&amp;amp;block):Nil-instance-method&quot;&gt;Hash#each&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;string#each_char-instance-method&quot;&gt;String#each_char&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;io#each_line(*args,**options,&amp;amp;block:String-%3E):Nil-instance-method&quot;&gt;IO#each_line&lt;/a&gt;&lt;/code&gt; each_line等。</target>
        </trans-unit>
        <trans-unit id="f60661aded41cff7237ed66bcbec411c36098f17" translate="yes" xml:space="preserve">
          <source>The standard library usually provides a couple of methods to accomplish something: one raises, one returns &lt;code&gt;nil&lt;/code&gt;. For example:</source>
          <target state="translated">标准库通常提供几种方法来完成某项任务：一个引发，一个返回 &lt;code&gt;nil&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="515a59cec9777bfc48a2ecc2cc13aa8b380be2d0" translate="yes" xml:space="preserve">
          <source>The standard output file descriptor.</source>
          <target state="translated">标准输出文件描述符。</target>
        </trans-unit>
        <trans-unit id="85ba3435f5bade942bd58c3feaaf3b56970c4fd2" translate="yes" xml:space="preserve">
          <source>The status code of this response, which must be set before writing the response body.</source>
          <target state="translated">本次响应的状态码,必须在编写响应主体之前设置。</target>
        </trans-unit>
        <trans-unit id="c59be19bf92d9ab26cce394a18e174fd9a969f08" translate="yes" xml:space="preserve">
          <source>The status code of this response, which must be set before writing the response body. If not set, the default value is 200 (OK).</source>
          <target state="translated">该响应的状态码,在写响应正文之前必须设置。如果没有设置,默认值为200(OK)。</target>
        </trans-unit>
        <trans-unit id="3a11fe500e3f850f00e6cd9e0bba9dd68f20ab69" translate="yes" xml:space="preserve">
          <source>The status of a terminated process.</source>
          <target state="translated">终止进程的状态。</target>
        </trans-unit>
        <trans-unit id="6b860b97ae2648994958ff5f145b7575c2d21991" translate="yes" xml:space="preserve">
          <source>The string value.</source>
          <target state="translated">字符串值。</target>
        </trans-unit>
        <trans-unit id="abd29b3ac753265d0c8451b4c56af4a5829cf90f" translate="yes" xml:space="preserve">
          <source>The string value. Only makes sense for a &lt;code&gt;Cell&lt;/code&gt;.</source>
          <target state="translated">字符串值。仅对 &lt;code&gt;Cell&lt;/code&gt; 有意义。</target>
        </trans-unit>
        <trans-unit id="bef8dbcb6094fea728ae1348a427a648823eaecf" translate="yes" xml:space="preserve">
          <source>The style of this scalar.</source>
          <target state="translated">这个标量的样式。</target>
        </trans-unit>
        <trans-unit id="61ed4a1fd638ad01f7858319d3a71c8d51e79551" translate="yes" xml:space="preserve">
          <source>The style of this sequence.</source>
          <target state="translated">这个序列的风格。</target>
        </trans-unit>
        <trans-unit id="5b14384994a6a3814e57411408f7f21ea58ef302" translate="yes" xml:space="preserve">
          <source>The supported date range is &lt;code&gt;0001-01-01 00:00:00.0&lt;/code&gt; to &lt;code&gt;9999-12-31 23:59:59.999_999_999&lt;/code&gt; in any local time zone.</source>
          <target state="translated">在任何本地时区，支持的日期范围是 &lt;code&gt;0001-01-01 00:00:00.0&lt;/code&gt; 到 &lt;code&gt;9999-12-31 23:59:59.999_999_999&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4503a73f7c127c408ab781d1b0fac75a8017a56c" translate="yes" xml:space="preserve">
          <source>The supported flag keywords are:</source>
          <target state="translated">支持的标志关键字有:</target>
        </trans-unit>
        <trans-unit id="6e218ceebba6ea54e2006ba0c7c6e7def70ac615" translate="yes" xml:space="preserve">
          <source>The syntax for a format specifier is:</source>
          <target state="translated">格式指定器的语法是:。</target>
        </trans-unit>
        <trans-unit id="55bd38b7daa1bdf9cc8a6ed62f94bd5f0ddb042f" translate="yes" xml:space="preserve">
          <source>The techniques described above for instance variables will also work for proc and method calls.</source>
          <target state="translated">上面描述的实例变量的技术也将适用于proc和方法调用。</target>
        </trans-unit>
        <trans-unit id="a5f08511b105744daa389a7297da93cef97ae79c" translate="yes" xml:space="preserve">
          <source>The ternary &lt;code&gt;if&lt;/code&gt; allows writing an &lt;code&gt;if&lt;/code&gt; in a shorter way:</source>
          <target state="translated">三元 &lt;code&gt;if&lt;/code&gt; 允许以较短的方式编写 &lt;code&gt;if&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8bd92a9a3ced6519c7c84778a4996693c92e674e" translate="yes" xml:space="preserve">
          <source>The test is performed by the block supplied to &lt;em&gt;&amp;amp;block&lt;/em&gt;.</source>
          <target state="translated">该测试由提供给&lt;em&gt;＆block的模块执行&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="30e4b606f413274e66088db5b0b29adc0fbe5ce6" translate="yes" xml:space="preserve">
          <source>The third rule is very convenient because of the typical directory structure of a project:</source>
          <target state="translated">第三条规则非常方便,因为一个项目的典型目录结构。</target>
        </trans-unit>
        <trans-unit id="a8fa55a537511eec3a9b51c9a830cf74f0aa2604" translate="yes" xml:space="preserve">
          <source>The time span is negative if &lt;code&gt;self&lt;/code&gt; is before &lt;em&gt;other&lt;/em&gt;.</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 在&lt;em&gt;其他人&lt;/em&gt;之前，则时间跨度为负。</target>
        </trans-unit>
        <trans-unit id="741a69c6248954ce047ac81f471742b0273d79f3" translate="yes" xml:space="preserve">
          <source>The time zone is always UTC.</source>
          <target state="translated">时区始终是UTC。</target>
        </trans-unit>
        <trans-unit id="cebb87b4a01c495d99b26ca4cb0c3f1e5a6a37dd" translate="yes" xml:space="preserve">
          <source>The time-of-day can be omitted and defaults to midnight (start of day):</source>
          <target state="translated">一天的时间可以省略,默认为午夜(一天的开始)。</target>
        </trans-unit>
        <trans-unit id="64ebdf1f1b3c564f37485bf9df3d06ef472ab0fb" translate="yes" xml:space="preserve">
          <source>The top-level number type.</source>
          <target state="translated">顶层的数字类型。</target>
        </trans-unit>
        <trans-unit id="1b33f83ef6cfe3aff507232296b953456b923ac8" translate="yes" xml:space="preserve">
          <source>The type after the &lt;code&gt;uninitialized&lt;/code&gt; keyword follows the &lt;a href=&quot;type_grammar&quot;&gt;type grammar&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;uninitialized&lt;/code&gt; 关键字之后的&lt;a href=&quot;type_grammar&quot;&gt;类型&lt;/a&gt;遵循grammar类型。</target>
        </trans-unit>
        <trans-unit id="15070dd3707e9d802a1fc0d25b1367c6f1003eef" translate="yes" xml:space="preserve">
          <source>The type arguments can be explicitly specified as part of the type name:</source>
          <target state="translated">类型参数可以被显式指定为类型名称的一部分。</target>
        </trans-unit>
        <trans-unit id="02c4c08c93b67fc8ff8e11b395e7bcf85287380e" translate="yes" xml:space="preserve">
          <source>The type declaration can also include an initial value:</source>
          <target state="translated">类型声明也可以包含一个初始值。</target>
        </trans-unit>
        <trans-unit id="6319b04ab143b210e9d97f792b86ed20bfe9f3d5" translate="yes" xml:space="preserve">
          <source>The type is not obvious for a human reading the code: they would also have to check all uses of &lt;code&gt;Person&lt;/code&gt; to find this out.</source>
          <target state="translated">对于阅读代码的人来说，这种类型并不明显：他们还必须检查 &lt;code&gt;Person&lt;/code&gt; 的所有用法才能找到答案。</target>
        </trans-unit>
        <trans-unit id="108c562214c93f386be1f162f0a0650b00bb7835" translate="yes" xml:space="preserve">
          <source>The type of a proc or block argument, like &lt;code&gt;&lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt; -&amp;gt; &lt;a href=&quot;../../int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">proc或block参数的类型，例如 &lt;code&gt;&lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt; -&amp;gt; &lt;a href=&quot;../../int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c42ac6401595769255c826b0b78eead029847e3" translate="yes" xml:space="preserve">
          <source>The type of a variable after a &lt;code&gt;while&lt;/code&gt; depends on the type it had before the &lt;code&gt;while&lt;/code&gt; and the type it had before leaving the &lt;code&gt;while&lt;/code&gt;'s body:</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 之后的变量的类型取决于 &lt;code&gt;while&lt;/code&gt; 之前的类型和离开 &lt;code&gt;while&lt;/code&gt; 的身体之前的类型：</target>
        </trans-unit>
        <trans-unit id="259c38c35a5373fad42e97eeb369785d902a0de1" translate="yes" xml:space="preserve">
          <source>The type of a variable or expression can consist of multiple types. This is called a union type. For example, when assigning to a same variable inside different &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; branches:</source>
          <target state="translated">变量或表达式的类型可以包含多种类型。这称为联合类型。例如，当在不同的&lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;分支中分配给同一变量时：</target>
        </trans-unit>
        <trans-unit id="857e9dd350d838b33e88e5bbd6617c80d3f3dee6" translate="yes" xml:space="preserve">
          <source>The type of an enum member is &lt;code&gt;Int32&lt;/code&gt; by default, even if you specify a different type in a constant value:</source>
          <target state="translated">默认情况下，枚举成员的类型为 &lt;code&gt;Int32&lt;/code&gt; ，即使您在常量值中指定了其他类型也是如此：</target>
        </trans-unit>
        <trans-unit id="22138fae9fc7f0f887fdce6335e5ef6cec7cbfa5" translate="yes" xml:space="preserve">
          <source>The type of the block in a method that uses &lt;code&gt;yield&lt;/code&gt; can be restricted using the &lt;code&gt;&amp;amp;block&lt;/code&gt; syntax. For example:</source>
          <target state="translated">可以使用 &lt;code&gt;&amp;amp;block&lt;/code&gt; 语法限制使用 &lt;code&gt;yield&lt;/code&gt; 的方法中的块类型。例如：</target>
        </trans-unit>
        <trans-unit id="fb4be47d081c9f00e1e008293842739b1e591c97" translate="yes" xml:space="preserve">
          <source>The type of the file.</source>
          <target state="translated">文件的类型。</target>
        </trans-unit>
        <trans-unit id="f81c742ee16652716e8606c185384a6c25c4887b" translate="yes" xml:space="preserve">
          <source>The type of the literal: &lt;code&gt;:i32&lt;/code&gt;, &lt;code&gt;:u16&lt;/code&gt;, &lt;code&gt;:f32&lt;/code&gt;, &lt;code&gt;:f64&lt;/code&gt;, etc.</source>
          <target state="translated">文字的类型 &lt;code&gt;:i32&lt;/code&gt; ， &lt;code&gt;:u16&lt;/code&gt; ， &lt;code&gt;:f32&lt;/code&gt; ， &lt;code&gt;:f64&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="7aae3e7ec12ca924c59121098a0fb5438695876c" translate="yes" xml:space="preserve">
          <source>The type of the value is &lt;code&gt;Int32&lt;/code&gt; by default but can be changed:</source>
          <target state="translated">值的类型默认为 &lt;code&gt;Int32&lt;/code&gt; ，但可以更改：</target>
        </trans-unit>
        <trans-unit id="d710c89f96aa8fa61f94c283654a65cfc9df9fb9" translate="yes" xml:space="preserve">
          <source>The type restrictions applied to arguments</source>
          <target state="translated">适用于参数的类型限制</target>
        </trans-unit>
        <trans-unit id="781e05338a9f46dedea33ad16c1f22747e5115a6" translate="yes" xml:space="preserve">
          <source>The types of the arguments (&lt;code&gt;T&lt;/code&gt;) are mandatory, except when directly sending a proc literal to a lib fun in C bindings.</source>
          <target state="translated">参数（ &lt;code&gt;T&lt;/code&gt; ）的类型是强制性的，除非直接在C绑定中将proc文字直接发送给lib fun。</target>
        </trans-unit>
        <trans-unit id="754e54b54ea2a8a8e371a7eb0db016dac368170a" translate="yes" xml:space="preserve">
          <source>The types of the arguments are mandatory, except when directly sending a proc literal to a lib &lt;code&gt;fun&lt;/code&gt; in C bindings.</source>
          <target state="translated">参数的类型是强制性的，除非在C绑定中将proc文字直接发送给lib &lt;code&gt;fun&lt;/code&gt; 时除外。</target>
        </trans-unit>
        <trans-unit id="ba85644bef24b13fb47d42733d7413b1308f1b35" translate="yes" xml:space="preserve">
          <source>The typical time representation provided by the operating system is based on a &quot;wall clock&quot; which is subject to changes for clock synchronization. This can result in discontinuous jumps in the time-line making it not suitable for accurately measuring elapsed time.</source>
          <target state="translated">操作系统提供的典型时间表示方式是基于 &quot;挂钟&quot;,而挂钟会因时钟同步而发生变化,这可能导致时间线的不连续跳动,从而不适合准确测量经过的时间。这可能导致时间线的不连续跳动,使其不适合准确测量经过的时间。</target>
        </trans-unit>
        <trans-unit id="2f96074085125d1425fe1b8d9419c01d3ff9fddb" translate="yes" xml:space="preserve">
          <source>The underscore &lt;code&gt;_&lt;/code&gt; before the suffix is optional.</source>
          <target state="translated">后缀前的下划线 &lt;code&gt;_&lt;/code&gt; 是可选的。</target>
        </trans-unit>
        <trans-unit id="067ddac2edd17a7efd366d05bd39d5795ee39b9c" translate="yes" xml:space="preserve">
          <source>The union of two named tuples with the same keys (regardless of their order) results in a named tuple type that has the union of the types in each key. The order of the keys will be the ones from the tuple on the left hand side.</source>
          <target state="translated">具有相同键的两个命名元组的结合(不管它们的顺序如何)会导致一个命名元组类型,该类型具有每个键中类型的结合。键的顺序将是左手边的元组中的键。</target>
        </trans-unit>
        <trans-unit id="4f2e60460d67626b22b346567f965156512777d3" translate="yes" xml:space="preserve">
          <source>The union of two tuples of the same size results in a tuple type that has the union of the types in each position.</source>
          <target state="translated">两个相同大小的元组的结合,会产生一个元组类型,该类型在每个位置都有类型的结合。</target>
        </trans-unit>
        <trans-unit id="8afd92c5041f6e9ec4f4074058c75c942c73b7bb" translate="yes" xml:space="preserve">
          <source>The user ID of the file's owner.</source>
          <target state="translated">文件所有者的用户ID。</target>
        </trans-unit>
        <trans-unit id="2b0c36a0d949f9008775425905192f1ed66ad726" translate="yes" xml:space="preserve">
          <source>The user's home directory.</source>
          <target state="translated">用户的主目录。</target>
        </trans-unit>
        <trans-unit id="69297ec8c8b14f2c05921e647c9fc36149e74468" translate="yes" xml:space="preserve">
          <source>The user's identifier.</source>
          <target state="translated">用户的标识符。</target>
        </trans-unit>
        <trans-unit id="168516e5f12f280f75fdcbfbaef516955a0c5e4c" translate="yes" xml:space="preserve">
          <source>The user's login shell.</source>
          <target state="translated">用户的登录外壳。</target>
        </trans-unit>
        <trans-unit id="f398a07d224999258456b0de430a4e0072f6caf7" translate="yes" xml:space="preserve">
          <source>The user's primary group identifier.</source>
          <target state="translated">用户的主组标识符。</target>
        </trans-unit>
        <trans-unit id="4ff9593149ef2ba9900fb804c6007eb3805c2cb2" translate="yes" xml:space="preserve">
          <source>The user's real or full name.</source>
          <target state="translated">用户的真实姓名或全名。</target>
        </trans-unit>
        <trans-unit id="1ca94ead58af110ad6f863fda49b90f7d5569c70" translate="yes" xml:space="preserve">
          <source>The user's username.</source>
          <target state="translated">用户的用户名。</target>
        </trans-unit>
        <trans-unit id="b7ab44265ee3c1a2128b252ac0fbcaf236e9b12e" translate="yes" xml:space="preserve">
          <source>The usual convention is to provide an alternative &quot;question&quot; method to signal that this variant of the method returns &lt;code&gt;nil&lt;/code&gt; instead of raising. This lets the user choose whether she wants to deal with exceptions or with &lt;code&gt;nil&lt;/code&gt;. Note, however, that this is not available for every method out there, as exceptions are still the preferred way because they don't pollute the code with error handling logic.</source>
          <target state="translated">通常的约定是提供一种替代的&amp;ldquo;问题&amp;rdquo;方法，以表示该方法的此变体返回 &lt;code&gt;nil&lt;/code&gt; 而不是引发。这使用户可以选择是要处理异常还是要处理 &lt;code&gt;nil&lt;/code&gt; 。但是请注意，并非所有方法都可用，因为异常仍然是首选的方式，因为它们不会使用错误处理逻辑来污染代码。</target>
        </trans-unit>
        <trans-unit id="59ce3a47e8cc9701295cd89ed345c7526071cbbd" translate="yes" xml:space="preserve">
          <source>The valid types to use in C bindings are:</source>
          <target state="translated">在C语言绑定中使用的有效类型是。</target>
        </trans-unit>
        <trans-unit id="a20a0d836d43b221dba43e371e3ece40ad64b317" translate="yes" xml:space="preserve">
          <source>The value assigned to the variable, if any.</source>
          <target state="translated">分配给变量的值,如果有的话。</target>
        </trans-unit>
        <trans-unit id="fcfa57e04fde68f0ab4098abfb5554b71327e65b" translate="yes" xml:space="preserve">
          <source>The value can also be another hash literal with the following options:</source>
          <target state="translated">该值也可以是另一个哈希文字,其选项如下。</target>
        </trans-unit>
        <trans-unit id="913440c9a45b0fb480154450d045729b273b2aef" translate="yes" xml:space="preserve">
          <source>The value can be changed to overwrite the system default:</source>
          <target state="translated">该值可以改变以覆盖系统默认值。</target>
        </trans-unit>
        <trans-unit id="fc06e0ddb6f726f165264966f85aba06f284c6aa" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; for &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;true&lt;/code&gt; ，值为 &lt;code&gt;1&lt;/code&gt; ；对于 &lt;code&gt;false&lt;/code&gt; ，值为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf5b165e811f3256ead60c619f132cce199cb310" translate="yes" xml:space="preserve">
          <source>The value of an &lt;code&gt;if&lt;/code&gt; is the value of the last expression found in each of its branches:</source>
          <target state="translated">的值 &lt;code&gt;if&lt;/code&gt; 是最后一个表达式的值在其每个分支的发现：</target>
        </trans-unit>
        <trans-unit id="5eed3fa4c0b1823d58a8c6bf72da684208a7433b" translate="yes" xml:space="preserve">
          <source>The value of each key can be a type. Primitive types (numbers, string, boolean and nil) are supported, as well as custom objects which use &lt;code&gt;&lt;a href=&quot;json#mapping(**_properties_)-macro&quot;&gt;JSON.mapping&lt;/a&gt;&lt;/code&gt; or define a &lt;code&gt;new&lt;/code&gt; method that accepts a &lt;code&gt;&lt;a href=&quot;json/pullparser&quot;&gt;JSON::PullParser&lt;/a&gt;&lt;/code&gt; and returns an object from it. Union types are supported, if multiple types in the union can be mapped from the JSON, it is undefined which one will be chosen.</source>
          <target state="translated">每个键的值可以是一种类型。支持原始类型（数字，字符串，布尔值和nil），以及使用 &lt;code&gt;&lt;a href=&quot;json#mapping(**_properties_)-macro&quot;&gt;JSON.mapping&lt;/a&gt;&lt;/code&gt; 或定义一个接受 &lt;code&gt;&lt;a href=&quot;json/pullparser&quot;&gt;JSON::PullParser&lt;/a&gt;&lt;/code&gt; 并从中返回对象的 &lt;code&gt;new&lt;/code&gt; 方法的自定义对象。支持联合类型，如果可以从JSON映射联合中的多种类型，则不确定将选择哪种类型。</target>
        </trans-unit>
        <trans-unit id="5d00003fd331dd99edd991c23f3a360f8d0b8a9c" translate="yes" xml:space="preserve">
          <source>The value of this scalar.</source>
          <target state="translated">这个标量的值。</target>
        </trans-unit>
        <trans-unit id="506a8109e608aea8ae4ab3b097dd3374dd8ab16e" translate="yes" xml:space="preserve">
          <source>The value range is &lt;code&gt;1..365&lt;/code&gt; in normal yars and &lt;code&gt;1..366&lt;/code&gt; in leap years.</source>
          <target state="translated">正常范围内，该值范围是 &lt;code&gt;1..366&lt;/code&gt; ，leap年中是 &lt;code&gt;1..365&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="737d355efb7ce1fb61687ce2dd59678f249b6230" translate="yes" xml:space="preserve">
          <source>The values of annotation key/value pairs can be accessed at compile time via the &lt;a href=&quot;https://crystal-lang.org/api/Crystal/Macros/Annotation.html#%5B%5D%28name%3ASymbolLiteral%7CStringLiteral%7CMacroId%29%3AASTNode-instance-method&quot;&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">注释键/值对的值可以在编译时通过&lt;a href=&quot;https://crystal-lang.org/api/Crystal/Macros/Annotation.html#%5B%5D%28name%3ASymbolLiteral%7CStringLiteral%7CMacroId%29%3AASTNode-instance-method&quot;&gt; &lt;code&gt;[]&lt;/code&gt; &lt;/a&gt;方法访问。</target>
        </trans-unit>
        <trans-unit id="069c7c9593f2e7c47e6a8c7723ea194ef1eba5fb" translate="yes" xml:space="preserve">
          <source>The version of the HTTP::Request that created this response.</source>
          <target state="translated">创建此响应的HTTP::Request的版本。</target>
        </trans-unit>
        <trans-unit id="22c5f3a3c46bff9cadece027c89e96d0529eb330" translate="yes" xml:space="preserve">
          <source>The warmup phase defaults to 2 seconds. During this stage we figure out how many cycles are needed to run the block for roughly 100ms, and record it.</source>
          <target state="translated">预热阶段默认为2秒。在这个阶段,我们计算出运行这个区块大概需要多少个周期,大概100ms,并记录下来。</target>
        </trans-unit>
        <trans-unit id="46266782916c37f0489de1ece340ef09c81505e3" translate="yes" xml:space="preserve">
          <source>The way to improve performance in this case is to either use one of the iteration methods (&lt;code&gt;each_char&lt;/code&gt;, &lt;code&gt;each_byte&lt;/code&gt;, &lt;code&gt;each_codepoint&lt;/code&gt;), or use the more low-level &lt;code&gt;Char::Reader&lt;/code&gt; struct. For example, using &lt;code&gt;each_char&lt;/code&gt;:</source>
          <target state="translated">在这种情况下，提高性能的方法是使用一种迭代方法（ &lt;code&gt;each_char&lt;/code&gt; ， &lt;code&gt;each_byte&lt;/code&gt; ， &lt;code&gt;each_codepoint&lt;/code&gt; ），或者使用更底层的 &lt;code&gt;Char::Reader&lt;/code&gt; 结构。例如，使用 &lt;code&gt;each_char&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="337ea97d4e3978ad9ffa54460e9435b596c6f608" translate="yes" xml:space="preserve">
          <source>The yielded object has an &lt;code&gt;&lt;a href=&quot;params#add(name,value)-instance-method&quot;&gt;#add&lt;/a&gt;&lt;/code&gt; method that accepts two arguments, a key (&lt;code&gt;&lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt;) and a value (&lt;code&gt;&lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../nil&quot;&gt;Nil&lt;/a&gt;&lt;/code&gt;). Keys and values are escaped using &lt;code&gt;&lt;a href=&quot;../uri#encode_www_form(string:String,*,space_to_plus:Bool=true):String-class-method&quot;&gt;URI.encode_www_form&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">产生的对象具有 &lt;code&gt;&lt;a href=&quot;params#add(name,value)-instance-method&quot;&gt;#add&lt;/a&gt;&lt;/code&gt; 方法，该方法接受两个参数，一个键（ &lt;code&gt;&lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ）和一个值（ &lt;code&gt;&lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../nil&quot;&gt;Nil&lt;/a&gt;&lt;/code&gt; ）。键和值使用 &lt;code&gt;&lt;a href=&quot;../uri#encode_www_form(string:String,*,space_to_plus:Bool=true):String-class-method&quot;&gt;URI.encode_www_form&lt;/a&gt;&lt;/code&gt; 进行转义。</target>
        </trans-unit>
        <trans-unit id="aaad6ca40d977cb492cea395430d88e3875865bb" translate="yes" xml:space="preserve">
          <source>Their type is inferred from their usage, not only from their initializer. In general, they are just value holders associated with the type that the programmer expects them to have according to their location and usage on the program.</source>
          <target state="translated">它们的类型是由它们的用法推断出来的,而不仅仅是由它们的初始化器推断出来的。一般来说,它们只是与程序员根据它们在程序中的位置和用法所期望的类型相关联的值持有者。</target>
        </trans-unit>
        <trans-unit id="ed36c8d7efa814982a1bcb38f471b6e7b33b12f3" translate="yes" xml:space="preserve">
          <source>Their type is inferred using the &lt;a href=&quot;type_inference&quot;&gt;global type inference algorithm&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;type_inference&quot;&gt;全局类型推断算法&lt;/a&gt;来推断它们的类型。</target>
        </trans-unit>
        <trans-unit id="a596befb5ab412bfec59b1ee23ba998b1572a8fb" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;add&lt;/code&gt; &amp;amp; &lt;code&gt;commit&lt;/code&gt; to start tracking the files with Git:</source>
          <target state="translated">然后 &lt;code&gt;add&lt;/code&gt; 并 &lt;code&gt;commit&lt;/code&gt; 以使用Git开始跟踪文件：</target>
        </trans-unit>
        <trans-unit id="53aa884bdfb9b146ca586b2f1bff6004bcea5458" translate="yes" xml:space="preserve">
          <source>Then it can be get and set:</source>
          <target state="translated">那么就可以得到和设置。</target>
        </trans-unit>
        <trans-unit id="5e7ac9a6a4d85e91d8fdcbb9eda94da14e4434ce" translate="yes" xml:space="preserve">
          <source>Then named arguments are matched, by name, with any argument in the method (it can be before or after the splat method argument). If an argument was already filled by a positional argument then it's an error.</source>
          <target state="translated">然后将命名的参数按名称与方法中的任何参数进行匹配(可以在split方法参数之前或之后)。如果一个参数已经被位置参数填满了,那么就是一个错误。</target>
        </trans-unit>
        <trans-unit id="7fb23335a8cb62994b6de5487ae6e83d8d3c186a" translate="yes" xml:space="preserve">
          <source>Then you can invoke the compiler by just typing &lt;code&gt;crystal&lt;/code&gt;.</source>
          <target state="translated">然后，您可以通过键入 &lt;code&gt;crystal&lt;/code&gt; 来调用编译器。</target>
        </trans-unit>
        <trans-unit id="e37e885ec74c274941734c4f9ff31dd391af29e2" translate="yes" xml:space="preserve">
          <source>Then you can pass a function (a &lt;a href=&quot;http://crystal-lang.org/api/Proc.html&quot;&gt;Proc&lt;/a&gt;) like this:</source>
          <target state="translated">然后，您可以像这样传递一个函数（&lt;a href=&quot;http://crystal-lang.org/api/Proc.html&quot;&gt;Proc&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="3d4a5cfd422762c83f968181fb2673335ae29b56" translate="yes" xml:space="preserve">
          <source>There are  and  syntax. The former will render returned values. The latter will not, but instead serve to control the structure as we do in Crystal.</source>
          <target state="translated">有和语法。前者会呈现返回值。后者不会,而是像我们在Crystal中那样控制结构。</target>
        </trans-unit>
        <trans-unit id="1bacc9714424057814e44c792dedc8e0a456c143" translate="yes" xml:space="preserve">
          <source>There are also two special methods for converting to UTC and local time zone:</source>
          <target state="translated">还有两种特殊的方法可以转换为UTC和当地时区。</target>
        </trans-unit>
        <trans-unit id="842520affd12c1e57a52e3ffbca245c2ee663233" translate="yes" xml:space="preserve">
          <source>There are alternative ways to change the foreground color:</source>
          <target state="translated">有其他方法可以改变前景色。</target>
        </trans-unit>
        <trans-unit id="922c400cf5752073dc87977a7821e90bef8e3f64" translate="yes" xml:space="preserve">
          <source>There are four signed integer types, and four unsigned integer types:</source>
          <target state="translated">有四种有符号整数类型,和四种无符号整数类型。</target>
        </trans-unit>
        <trans-unit id="f6ef70215a67446a14d9e7e800fc787c86aba718" translate="yes" xml:space="preserve">
          <source>There are four signed integer types: &lt;code&gt;&lt;a href=&quot;int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;, being able to represent numbers of 8, 16, 32 and 64 bits respectively. There are four unsigned integer types: &lt;code&gt;&lt;a href=&quot;uint8&quot;&gt;UInt8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;uint16&quot;&gt;UInt16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;uint32&quot;&gt;UInt32&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;uint64&quot;&gt;UInt64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有四种有符号整数类型： &lt;code&gt;&lt;a href=&quot;int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; ，分别可以表示8位，16位，32位和64位的数字。有四种无符号整数类型： &lt;code&gt;&lt;a href=&quot;uint8&quot;&gt;UInt8&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;uint16&quot;&gt;UInt16&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;uint32&quot;&gt;UInt32&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;uint64&quot;&gt;UInt64&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="512b0b0a764ab382af28ad714d03b3b1b5f90a88" translate="yes" xml:space="preserve">
          <source>There are many convenient query methods built on top of &lt;code&gt;#query&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;#query&lt;/code&gt; 之上构建了许多方便的查询方法。</target>
        </trans-unit>
        <trans-unit id="0540a12666f72e39d5c840798fd1cf96d9186e81" translate="yes" xml:space="preserve">
          <source>There are methods to create expectations which test for equivalence (&lt;code&gt;eq&lt;/code&gt;), identity (&lt;code&gt;be&lt;/code&gt;), type (&lt;code&gt;be_a&lt;/code&gt;), and nil (&lt;code&gt;be_nil&lt;/code&gt;). Note that the identity expectation uses &lt;code&gt;.same?&lt;/code&gt; which tests if &lt;a href=&quot;https://crystal-lang.org/api/latest/Reference.html#object_id%3AUInt64-instance-method&quot;&gt;&lt;code&gt;#object_id&lt;/code&gt;&lt;/a&gt; are identical. This is only true if the expected value points to &lt;em&gt;the same object&lt;/em&gt; instead of &lt;em&gt;an equivalent one&lt;/em&gt;. This is only possible for reference types and won't work for value types like structs or numbers.</source>
          <target state="translated">有一些方法可以创建期望值，以测试等价性（ &lt;code&gt;eq&lt;/code&gt; ），同一性（ &lt;code&gt;be&lt;/code&gt; ），类型（ &lt;code&gt;be_a&lt;/code&gt; ）和nil（ &lt;code&gt;be_nil&lt;/code&gt; ）。请注意，身份期望使用 &lt;code&gt;.same?&lt;/code&gt; 测试&lt;a href=&quot;https://crystal-lang.org/api/latest/Reference.html#object_id%3AUInt64-instance-method&quot;&gt; &lt;code&gt;#object_id&lt;/code&gt; &lt;/a&gt;是否相同。仅当期望值指向&lt;em&gt;同一个对象&lt;/em&gt;而不是&lt;em&gt;等效&lt;/em&gt;&lt;em&gt;对象时&lt;/em&gt;，才如此。这仅适用于引用类型，不适用于结构或数字之类的值类型。</target>
        </trans-unit>
        <trans-unit id="8665b9ce7005cbef306e0775d40ccc93ff049b72" translate="yes" xml:space="preserve">
          <source>There are people looking for the &lt;em&gt;exact&lt;/em&gt; functionality of our library and the &lt;em&gt;general&lt;/em&gt; functionality of our library. e.g. Bob needs a palindrome library, but Felipe is just looking for libraries involving text and Susan is looking for libraries involving spelling.</source>
          <target state="translated">有人在寻找我们库的&lt;em&gt;确切&lt;/em&gt;功能以及我们库的&lt;em&gt;一般&lt;/em&gt;功能。例如，鲍勃需要一个回文库，但菲利普只是在寻找涉及文本的图书馆，而苏珊则在寻找涉及拼写的图书馆。</target>
        </trans-unit>
        <trans-unit id="15833e4fae44677e5aef19597668e8b099aa34dd" translate="yes" xml:space="preserve">
          <source>There are several methods to retrieve a &lt;code&gt;&lt;a href=&quot;time&quot;&gt;Time&lt;/a&gt;&lt;/code&gt; instance representing the current time:</source>
          <target state="translated">有几种方法可以检索表示当前时间的 &lt;code&gt;&lt;a href=&quot;time&quot;&gt;Time&lt;/a&gt;&lt;/code&gt; 实例：</target>
        </trans-unit>
        <trans-unit id="e831d0e1ff9abcb6d2f8ca9921871d9cff763b05" translate="yes" xml:space="preserve">
          <source>There are several ways to avoid heap memory allocations. The standard library is designed in a way to help you do that.</source>
          <target state="translated">有几种方法可以避免堆内存分配。标准库的设计就是为了帮助你做到这一点。</target>
        </trans-unit>
        <trans-unit id="2975438e927a4d7f9683bb1a51e8eb7ce9c022ce" translate="yes" xml:space="preserve">
          <source>There are several ways to let Crystal know this.</source>
          <target state="translated">有几种方法可以让Crystal知道这一点。</target>
        </trans-unit>
        <trans-unit id="8a72b96ca552df5e83dc14ec3a46f7f9ea7c5609" translate="yes" xml:space="preserve">
          <source>There are two floating point types, &lt;a href=&quot;http://crystal-lang.org/api/Float32.html&quot;&gt;Float32&lt;/a&gt; and &lt;a href=&quot;http://crystal-lang.org/api/Float64.html&quot;&gt;Float64&lt;/a&gt;, which correspond to the &lt;a href=&quot;http://en.wikipedia.org/wiki/Single_precision_floating-point_format&quot;&gt;binary32&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Double_precision_floating-point_format&quot;&gt;binary64&lt;/a&gt; types defined by IEEE.</source>
          <target state="translated">有两种浮点类型，&lt;a href=&quot;http://crystal-lang.org/api/Float32.html&quot;&gt;Float32&lt;/a&gt;和&lt;a href=&quot;http://crystal-lang.org/api/Float64.html&quot;&gt;Float64&lt;/a&gt;，它们与IEEE定义的&lt;a href=&quot;http://en.wikipedia.org/wiki/Single_precision_floating-point_format&quot;&gt;binary32&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/Double_precision_floating-point_format&quot;&gt;binary64&lt;/a&gt;类型相对应。</target>
        </trans-unit>
        <trans-unit id="35b8024484d51c08919d7d33510f5de3f987837e" translate="yes" xml:space="preserve">
          <source>There are two floating point types, &lt;code&gt;&lt;a href=&quot;float32&quot;&gt;Float32&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;float64&quot;&gt;Float64&lt;/a&gt;&lt;/code&gt;, which correspond to the &lt;a href=&quot;http://en.wikipedia.org/wiki/Single_precision_floating-point_format&quot;&gt;binary32&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Double_precision_floating-point_format&quot;&gt;binary64&lt;/a&gt; types defined by IEEE.</source>
          <target state="translated">有两种浮点类型， &lt;code&gt;&lt;a href=&quot;float32&quot;&gt;Float32&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;float64&quot;&gt;Float64&lt;/a&gt;&lt;/code&gt; ，它们与IEEE定义的&lt;a href=&quot;http://en.wikipedia.org/wiki/Single_precision_floating-point_format&quot;&gt;binary32&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/Double_precision_floating-point_format&quot;&gt;binary64&lt;/a&gt;类型相对应。</target>
        </trans-unit>
        <trans-unit id="697020fc37bddf0093745ab213eb084879041a18" translate="yes" xml:space="preserve">
          <source>There are two ways to solve this:</source>
          <target state="translated">有两种方法可以解决这个问题。</target>
        </trans-unit>
        <trans-unit id="b372dc0271f26d904bde368ff92af43659289eda" translate="yes" xml:space="preserve">
          <source>There is a way to rollback the changes in the &lt;code&gt;inner-transaction&lt;/code&gt; but keep the ones in the &lt;code&gt;outer-transaction&lt;/code&gt;. Use &lt;code&gt;rollback&lt;/code&gt; in the &lt;code&gt;inner_tx&lt;/code&gt; object. This will rollback &lt;strong&gt;only&lt;/strong&gt; then inner-transaction. Here is the example:</source>
          <target state="translated">有一种方法可以回滚 &lt;code&gt;inner-transaction&lt;/code&gt; 的更改，但将其保留在 &lt;code&gt;outer-transaction&lt;/code&gt; 。在 &lt;code&gt;inner_tx&lt;/code&gt; 对象中使用 &lt;code&gt;rollback&lt;/code&gt; 。&lt;strong&gt;仅&lt;/strong&gt;在进行内部事务处理&lt;strong&gt;时才&lt;/strong&gt;回滚。这是示例：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1fc1a4586629630f7e45274573602d5fbf3b217" translate="yes" xml:space="preserve">
          <source>There is no explicit limit on the input values but the addition must result in a valid time between &lt;code&gt;0001-01-01 00:00:00.0&lt;/code&gt; and &lt;code&gt;9999-12-31 23:59:59.999_999_999&lt;/code&gt;. Otherwise &lt;code&gt;&lt;a href=&quot;argumenterror&quot;&gt;ArgumentError&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">输入值没有明确限制，但相加必须导致介于 &lt;code&gt;0001-01-01 00:00:00.0&lt;/code&gt; 和 &lt;code&gt;9999-12-31 23:59:59.999_999_999&lt;/code&gt; 之间的有效时间。否则 &lt;code&gt;&lt;a href=&quot;argumenterror&quot;&gt;ArgumentError&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb5bf545a7e2854b2d0be84ded507a04958791e2" translate="yes" xml:space="preserve">
          <source>There is no explicit limit on the input values but the shift must result in a valid time between &lt;code&gt;0001-01-01 00:00:00.0&lt;/code&gt; and &lt;code&gt;9999-12-31 23:59:59.999_999_999&lt;/code&gt;. Otherwise &lt;code&gt;&lt;a href=&quot;argumenterror&quot;&gt;ArgumentError&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">输入值没有明确限制，但移位必须导致 &lt;code&gt;0001-01-01 00:00:00.0&lt;/code&gt; 和 &lt;code&gt;9999-12-31 23:59:59.999_999_999&lt;/code&gt; 之间的有效时间。否则 &lt;code&gt;&lt;a href=&quot;argumenterror&quot;&gt;ArgumentError&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f38cee4e5f6d302c1d80d85a1a600c40b70cebce" translate="yes" xml:space="preserve">
          <source>There is no need to explicitly require &lt;code&gt;crystal-lang/crystal-db&lt;/code&gt;</source>
          <target state="translated">无需明确要求 &lt;code&gt;crystal-lang/crystal-db&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06b30029a569ea96f99cdff82bb1a1a33f5f5175" translate="yes" xml:space="preserve">
          <source>There is one &lt;code&gt;exception&lt;/code&gt; with a different behaviour. If a &lt;code&gt;DB::Rollback&lt;/code&gt; is raised within the block, the implicit rollback will happen, but the exception will not be raised outside the block.</source>
          <target state="translated">有一种 &lt;code&gt;exception&lt;/code&gt; 是行为不同。如果在块内引发 &lt;code&gt;DB::Rollback&lt;/code&gt; ，则会发生隐式回滚，但不会在块外引发异常。</target>
        </trans-unit>
        <trans-unit id="5d04f34bb755ae26b5dfd48d5d9baf367179e79c" translate="yes" xml:space="preserve">
          <source>There's a second problem with the above: computing the &lt;code&gt;size&lt;/code&gt; of a String is also slow, because it's not simply the number of bytes in the string (the &lt;code&gt;bytesize&lt;/code&gt;). However, once a String's size has been computed, it is cached.</source>
          <target state="translated">上面还有第二个问题：计算字符串的 &lt;code&gt;size&lt;/code&gt; 也很慢，因为它不仅是字符串中的字节数（ &lt;code&gt;bytesize&lt;/code&gt; ）。但是，一旦计算出字符串的大小，就会对其进行缓存。</target>
        </trans-unit>
        <trans-unit id="4704a94ef37f1a3b7256f98864eae80e83c79302" translate="yes" xml:space="preserve">
          <source>There's a simpler way to write the above by using an &lt;code&gt;out&lt;/code&gt; parameter:</source>
          <target state="translated">有一种更简单的方法，可以使用 &lt;code&gt;out&lt;/code&gt; 参数来编写上述代码：</target>
        </trans-unit>
        <trans-unit id="833d4e9abecd6e3e8399fe0f3887e1d1cf701417" translate="yes" xml:space="preserve">
          <source>There's also the possibility of making a method only receive named arguments (and list them), by placing the star at the beginning:</source>
          <target state="translated">还有一种可能是让一个方法只接收命名的参数(并列出它们),把星号放在开头。</target>
        </trans-unit>
        <trans-unit id="f16baa65237c3959bd05d621bb9f4b7195f62a93" translate="yes" xml:space="preserve">
          <source>Therefore structs are mostly useful for immutable data types and/or stateless wrappers of other types, usually for performance reasons to avoid lots of small memory allocations when passing small copies might be more efficient (for more details, see the &lt;a href=&quot;../guides/performance#use-structs-when-possible&quot;&gt;performance guide&lt;/a&gt;).</source>
          <target state="translated">因此，结构对于不可变数据类型和/或其他类型的无状态包装器最有用，通常是出于性能方面的考虑，以避免在传递小副本时更有效地避免大量小内存分配（有关更多详细信息，请参见&lt;a href=&quot;../guides/performance#use-structs-when-possible&quot;&gt;性能指南&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="eee92756be584f64d5bc56365f0f367ad17d2a42" translate="yes" xml:space="preserve">
          <source>These alternate between &lt;code&gt;&lt;a href=&quot;stringliteral&quot;&gt;StringLiteral&lt;/a&gt;&lt;/code&gt; for the plaintext parts and &lt;code&gt;&lt;a href=&quot;astnode&quot;&gt;ASTNode&lt;/a&gt;&lt;/code&gt;s of any type for the interpolated expressions.</source>
          <target state="translated">这些在明文部分的 &lt;code&gt;&lt;a href=&quot;stringliteral&quot;&gt;StringLiteral&lt;/a&gt;&lt;/code&gt; 和内插表达式的任何类型的 &lt;code&gt;&lt;a href=&quot;astnode&quot;&gt;ASTNode&lt;/a&gt;&lt;/code&gt; 之间交替。</target>
        </trans-unit>
        <trans-unit id="52462b1c60032326e14014f4c5bfcae1c58f65f3" translate="yes" xml:space="preserve">
          <source>These are defined without arguments. For example</source>
          <target state="translated">这些定义没有参数。例如</target>
        </trans-unit>
        <trans-unit id="e8180d4636bc06ee71ab5679ae69e58040058d3e" translate="yes" xml:space="preserve">
          <source>These are handy to write regular expressions that include slashes which would have to be escaped in slash-delimited literals.</source>
          <target state="translated">在编写包含斜线的正则表达式时,这些正则表达式很方便,因为这些正则表达式必须在斜线限制的文字中进行转义。</target>
        </trans-unit>
        <trans-unit id="dc10ca4e01d7a135d8ffb35a404ded61daa207f4" translate="yes" xml:space="preserve">
          <source>These are handy to write strings that include double quotes which would have to be escaped in double-quoted strings.</source>
          <target state="translated">这些都是方便编写包含双引号的字符串,而双引号的字符串必须要进行转义。</target>
        </trans-unit>
        <trans-unit id="0d3ba592af6e825f0110f0417c77a0807b693560" translate="yes" xml:space="preserve">
          <source>These can be included into classes:</source>
          <target state="translated">这些都可以纳入课堂。</target>
        </trans-unit>
        <trans-unit id="c5ac138599d0a4f2720ae8403888c676ba7af7ba" translate="yes" xml:space="preserve">
          <source>These flags are generally used in C bindings to conditionally define types and functions. For example, the very well known &lt;code&gt;size_t&lt;/code&gt; type is defined like this in Crystal:</source>
          <target state="translated">这些标志通常用于C绑定中，以有条件地定义类型和功能。例如，众所周知的 &lt;code&gt;size_t&lt;/code&gt; 类型在Crystal中定义如下：</target>
        </trans-unit>
        <trans-unit id="3328184f79d428d1cdba1a7b601e49684f8db2d1" translate="yes" xml:space="preserve">
          <source>These matchers run a block and pass if it raises a certain exception.</source>
          <target state="translated">这些匹配器运行一个块,如果它引发某个异常,就会传递。</target>
        </trans-unit>
        <trans-unit id="0c9e9b99ed1db33822e0001fe19d63beb30df5f0" translate="yes" xml:space="preserve">
          <source>These methods usually imply a side effect.</source>
          <target state="translated">这些方法通常意味着一种副作用。</target>
        </trans-unit>
        <trans-unit id="ec6ca5f54090a8947e07a52adbdec5ff5edfd58a" translate="yes" xml:space="preserve">
          <source>These parts of the language are considered unsafe:</source>
          <target state="translated">这些部分的语言被认为是不安全的。</target>
        </trans-unit>
        <trans-unit id="6d2b6a3e66f06b30694b98b640803a3ea88b27ad" translate="yes" xml:space="preserve">
          <source>They allow communicating data between fibers without sharing memory and without having to worry about locks, semaphores or other special structures.</source>
          <target state="translated">它们允许在光纤之间进行数据通信,无需共享内存,也无需担心锁、信号灯或其他特殊结构。</target>
        </trans-unit>
        <trans-unit id="7f394867a5d293f5b8d8a58cc4a912b45c6a8578" translate="yes" xml:space="preserve">
          <source>They are explained &lt;a href=&quot;http://llvm.org/docs/LangRef.html#calling-conventions&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">他们在&lt;a href=&quot;http://llvm.org/docs/LangRef.html#calling-conventions&quot;&gt;这里&lt;/a&gt;解释。</target>
        </trans-unit>
        <trans-unit id="6a79d299bb92be8426f3c6903a9d162db6534c06" translate="yes" xml:space="preserve">
          <source>They can also be defined in classes and modules, and are visible in those scopes. Macros are also looked-up in the ancestors chain (superclasses and included modules).</source>
          <target state="translated">它们也可以在类和模块中定义,并在这些作用域中可见。宏也可以在祖先链(超类和包含的模块)中查询。</target>
        </trans-unit>
        <trans-unit id="804bc537ae6f4a7386c98efeb9e2fc19229f8bd5" translate="yes" xml:space="preserve">
          <source>They return the rescued exception so it can be used for further expectations, for example to verify specific properties of the exception.</source>
          <target state="translated">它们返回被拯救的异常,因此可以用于进一步的期望,例如验证异常的特定属性。</target>
        </trans-unit>
        <trans-unit id="940284502d1ed20ae98c767eff3b9d5f29075a3e" translate="yes" xml:space="preserve">
          <source>This Deque is implemented with a &lt;a href=&quot;http://en.wikipedia.org/wiki/Dynamic_array&quot;&gt;dynamic array&lt;/a&gt; used as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Circular_buffer&quot;&gt;circular buffer&lt;/a&gt;.</source>
          <target state="translated">此双端&lt;a href=&quot;http://en.wikipedia.org/wiki/Dynamic_array&quot;&gt;队列&lt;/a&gt;是通过将动态数组用作&lt;a href=&quot;https://en.wikipedia.org/wiki/Circular_buffer&quot;&gt;循环缓冲区来实现的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a893c0c045eb46234c00e09d1504b97ad0f7082" translate="yes" xml:space="preserve">
          <source>This allocates a new object and copies the contents of &lt;code&gt;self&lt;/code&gt; into it.</source>
          <target state="translated">这将分配一个新对象，并将 &lt;code&gt;self&lt;/code&gt; 的内容复制到其中。</target>
        </trans-unit>
        <trans-unit id="8772cd98aed338697c76d9394bc311fe22b0e008" translate="yes" xml:space="preserve">
          <source>This allocates the struct on the stack.</source>
          <target state="translated">这将在栈上分配结构体。</target>
        </trans-unit>
        <trans-unit id="45a0cdda2fbf946e775052aa4818961d112501a1" translate="yes" xml:space="preserve">
          <source>This allocates the union on the stack.</source>
          <target state="translated">这将在栈上分配联合体。</target>
        </trans-unit>
        <trans-unit id="cd5b485625c53ffbb51fbc1a22e7e9d6dde6937a" translate="yes" xml:space="preserve">
          <source>This allows you to define arrays and methods based on module type instead of class:</source>
          <target state="translated">这允许你基于模块类型而不是类来定义数组和方法。</target>
        </trans-unit>
        <trans-unit id="89252758af63a847860957aa9da7700be5c4f8f0" translate="yes" xml:space="preserve">
          <source>This allows you to define helper methods in a file that will only be known in that file.</source>
          <target state="translated">这允许你在一个文件中定义只有在该文件中才能知道的帮助方法。</target>
        </trans-unit>
        <trans-unit id="43896ca6eada4a6a152d7197dc01153de171de19" translate="yes" xml:space="preserve">
          <source>This allows you to easily pass a hash as individual named arguments to a method.</source>
          <target state="translated">这允许你轻松地将一个哈希作为单独的命名参数传递给一个方法。</target>
        </trans-unit>
        <trans-unit id="48bda246c4232e755a841e76ef71277dbce3590e" translate="yes" xml:space="preserve">
          <source>This allows you to easily pass an array as individual arguments to a method.</source>
          <target state="translated">这允许你轻松地将一个数组作为单独的参数传递给一个方法。</target>
        </trans-unit>
        <trans-unit id="11c1f0225f2fc4dc9ae274431682ca45cbdc6094" translate="yes" xml:space="preserve">
          <source>This allows you to treat strings, symbols, variables and calls uniformly. For example:</source>
          <target state="translated">这允许你统一处理字符串、符号、变量和调用。例如</target>
        </trans-unit>
        <trans-unit id="985c89bbce1f242112f0eea387ee135995956f57" translate="yes" xml:space="preserve">
          <source>This also applies when a variable is assigned in an &lt;code&gt;if&lt;/code&gt;'s condition:</source>
          <target state="translated">当在 &lt;code&gt;if&lt;/code&gt; 条件中分配变量时，这也适用：</target>
        </trans-unit>
        <trans-unit id="7525704cb029c1388cb3009876fa72ad59abdf42" translate="yes" xml:space="preserve">
          <source>This also happens with regular proc literals, even if it's evident that the proc wasn't invoked or stored:</source>
          <target state="translated">这种情况也会发生在普通的proc字面上,即使很明显该proc没有被调用或存储。</target>
        </trans-unit>
        <trans-unit id="9988407bcb9d63feae9fc976466e9bdd7ad12705" translate="yes" xml:space="preserve">
          <source>This also is applied to generic types. Here &lt;code&gt;@values&lt;/code&gt; is inferred to be &lt;code&gt;Array(Int32)&lt;/code&gt;.</source>
          <target state="translated">这也适用于泛型类型。这里 &lt;code&gt;@values&lt;/code&gt; 推断为 &lt;code&gt;Array(Int32)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a59ff08fc13601d64759154db5c0018630125c45" translate="yes" xml:space="preserve">
          <source>This annotations marks methods, classes, constants, and macros as deprecated.</source>
          <target state="translated">这个注解将方法、类、常量和宏标记为废弃的。</target>
        </trans-unit>
        <trans-unit id="81bec1181a948a798dc2a1e99836a1c9b7bcc142" translate="yes" xml:space="preserve">
          <source>This appends this char's bytes as encoded by UTF-8 to the given &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这会将由UTF-8编码的此char字节附加到给定的 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="248796d8d9934bbe14e20f2b2504914ba28d35bf" translate="yes" xml:space="preserve">
          <source>This builder is similar to &lt;code&gt;&lt;a href=&quot;../builder&quot;&gt;YAML::Builder&lt;/a&gt;&lt;/code&gt;, but instead of directly emitting the output to an IO it builds a YAML document tree in memory.</source>
          <target state="translated">该构建器类似于 &lt;code&gt;&lt;a href=&quot;../builder&quot;&gt;YAML::Builder&lt;/a&gt;&lt;/code&gt; ，但不是直接将输出发送到IO，而是在内存中构建YAML文档树。</target>
        </trans-unit>
        <trans-unit id="d2fa87d3879858b4853188bf95255ef603ec97a9" translate="yes" xml:space="preserve">
          <source>This can also be used to give shorter, nicer names to C functions, as these tend to be long and are usually prefixed with the library name.</source>
          <target state="translated">这也可以用来给C函数起一个更短、更漂亮的名字,因为这些函数往往比较长,通常都是以库名为前缀。</target>
        </trans-unit>
        <trans-unit id="507eacbc1bf0d16243a0bb3a476918e772e63734" translate="yes" xml:space="preserve">
          <source>This can be circumvented by assigning the value to a new local variable:</source>
          <target state="translated">这可以通过将值分配给一个新的局部变量来规避。</target>
        </trans-unit>
        <trans-unit id="1f2bc8c72bc0aa46c1e0d9852985b434e6d7d9a8" translate="yes" xml:space="preserve">
          <source>This can be found at &lt;code&gt;https://github.com/&amp;lt;YOUR-GITHUB-NAME&amp;gt;/&amp;lt;YOUR-REPOSITORY-NAME&amp;gt;/releases&lt;/code&gt;</source>
          <target state="translated">可以在 &lt;code&gt;https://github.com/&amp;lt;YOUR-GITHUB-NAME&amp;gt;/&amp;lt;YOUR-REPOSITORY-NAME&amp;gt;/releases&lt;/code&gt; 中找到</target>
        </trans-unit>
        <trans-unit id="ffd27003f6f34584a3555328bd566670a8fde55d" translate="yes" xml:space="preserve">
          <source>This can be mitigated by using the nilable version of the above: $N?, (e.g., $1? $2?, $3?, ...). Changing the above to use &lt;code&gt;$2?&lt;/code&gt; instead of &lt;code&gt;$2&lt;/code&gt; would return &lt;code&gt;nil&lt;/code&gt;. &lt;code&gt;$2?.nil?&lt;/code&gt; would return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">这可以通过使用上面的无效版本来缓解：$ N？（例如，$ 1？$ 2？，$ 3？，...）。更改上面以使用 &lt;code&gt;$2?&lt;/code&gt; 而不是 &lt;code&gt;$2&lt;/code&gt; 将返回 &lt;code&gt;nil&lt;/code&gt; 。 &lt;code&gt;$2?.nil?&lt;/code&gt; 将返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12b21e5f6bdac9d403b7334eaf4f7413aa131f10" translate="yes" xml:space="preserve">
          <source>This can be used either to stub out method bodies, or when the method is not implemented on the current platform.</source>
          <target state="translated">这可以用来支取方法体,或者当方法在当前平台上没有实现时。</target>
        </trans-unit>
        <trans-unit id="290297a08de042185c1c84c038c10066109d7785" translate="yes" xml:space="preserve">
          <source>This can be used to prevent many memory allocations when each slice of interest is to be used in a read-only fashion.</source>
          <target state="translated">当每个感兴趣的片断都要以只读方式使用时,可以用这个方法来防止多次内存分配。</target>
        </trans-unit>
        <trans-unit id="cb50edfa23bcef6f6011e63d4071b8d122b296f0" translate="yes" xml:space="preserve">
          <source>This can sometimes be useful to avoid repetitive code by deliberately reading/writing local variables, but can also overwrite local variables by mistake. To avoid this, fresh variables can be declared with &lt;code&gt;%name&lt;/code&gt;:</source>
          <target state="translated">有时通过故意读取/写入局部变量来避免重复代码很有用，但也可能会错误地覆盖局部变量。为了避免这种情况，可以使用 &lt;code&gt;%name&lt;/code&gt; 声明新鲜变量：</target>
        </trans-unit>
        <trans-unit id="9d0016fb953e5977cad8c4754588413f0a3ed185" translate="yes" xml:space="preserve">
          <source>This class allows you to consume JSON on demand, token by token.</source>
          <target state="translated">该类允许你按需消费JSON,逐个标记。</target>
        </trans-unit>
        <trans-unit id="fddc331d6ec149095268659cb395c5d85a698137" translate="yes" xml:space="preserve">
          <source>This class also provides methods to build authorize URIs and get access tokens with different methods, as specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc6749&quot;&gt;RFC 6749&lt;/a&gt;.</source>
          <target state="translated">此类还提供了一些方法来构建授权URI并使用&lt;a href=&quot;https://tools.ietf.org/html/rfc6749&quot;&gt;RFC 6749&lt;/a&gt;所指定的不同方法获取访问令牌。</target>
        </trans-unit>
        <trans-unit id="51830efb40e10d23f3abf190c9ab320a6da39cdd" translate="yes" xml:space="preserve">
          <source>This class also provides methods to get request tokens, build authorize URIs and get access tokens, as specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc5849&quot;&gt;RFC 5849&lt;/a&gt;.</source>
          <target state="translated">此类还提供了获取请求令牌，构建授权URI和获取访问令牌的方法，如&lt;a href=&quot;https://tools.ietf.org/html/rfc5849&quot;&gt;RFC 5849&lt;/a&gt;所指定。</target>
        </trans-unit>
        <trans-unit id="005e91e2755cb7746b08c1fd6a1089edd3980f74" translate="yes" xml:space="preserve">
          <source>This class implements a pretty printing algorithm. It finds line breaks and nice indentations for grouped structure.</source>
          <target state="translated">这个类实现了一个漂亮的打印算法。它为分组结构找到换行符和漂亮的缩进符。</target>
        </trans-unit>
        <trans-unit id="7b193332d3e7ac21a2ef720c48e8a13290f8da7e" translate="yes" xml:space="preserve">
          <source>This class is inherited by types like &lt;code&gt;&lt;a href=&quot;file&quot;&gt;File&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;io/memory&quot;&gt;IO::Memory&lt;/a&gt;&lt;/code&gt; and provides many useful methods for reading from and writing to an IO, like &lt;code&gt;&lt;a href=&quot;io#print(*objects:UNDERSCORE):Nil-instance-method&quot;&gt;#print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io#puts:Nil-instance-method&quot;&gt;#puts&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io#gets(delimiter:Char,limit:Int,chomp=false):String?-instance-method&quot;&gt;#gets&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;io#printf(format_string,*args):Nil-instance-method&quot;&gt;#printf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此类由 &lt;code&gt;&lt;a href=&quot;file&quot;&gt;File&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;io/memory&quot;&gt;IO::Memory&lt;/a&gt;&lt;/code&gt; 类的类型继承，并提供了许多用于读取和写入IO的有用方法，例如 &lt;code&gt;&lt;a href=&quot;io#print(*objects:UNDERSCORE):Nil-instance-method&quot;&gt;#print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;io#puts:Nil-instance-method&quot;&gt;#puts&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;io#gets(delimiter:Char,limit:Int,chomp=false):String?-instance-method&quot;&gt;#gets&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;io#printf(format_string,*args):Nil-instance-method&quot;&gt;#printf&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31bbc4cb995f23a911d22e5e5e2b913518e6c310" translate="yes" xml:space="preserve">
          <source>This class is the exception thrown when errno errors are encountered.</source>
          <target state="translated">这个类是遇到errno错误时抛出的异常。</target>
        </trans-unit>
        <trans-unit id="5abeadb5bb3efabaad829e19c08976dd58b3d9fd" translate="yes" xml:space="preserve">
          <source>This class provides a number of methods for encoding and decoding strings using URL Encoding (also known as Percent Encoding) as defined in &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt; as well as &lt;a href=&quot;https://url.spec.whatwg.org/#urlencoded-serializing&quot;&gt;&lt;code&gt;x-www-form-urlencoded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此类提供了许多使用&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;和&lt;a href=&quot;https://url.spec.whatwg.org/#urlencoded-serializing&quot;&gt; &lt;code&gt;x-www-form-urlencoded&lt;/code&gt; &lt;/a&gt;定义的URL编码（也称为百分比编码）对字符串进行编码和解码的方法。</target>
        </trans-unit>
        <trans-unit id="176d7dbe8031aa71aff24aca941ce1ab05a1d3d0" translate="yes" xml:space="preserve">
          <source>This class provides constructors for creating URI instances from their components or by parsing their string forms and methods for accessing the various components of an instance.</source>
          <target state="translated">该类提供了用于从组件中创建URI实例的构造函数,或通过解析它们的字符串形式创建URI实例,以及用于访问实例中各种组件的方法。</target>
        </trans-unit>
        <trans-unit id="82500e146b4ef44a1f1dda0397e58e0120ec75b0" translate="yes" xml:space="preserve">
          <source>This class represents a URI reference as defined by &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986: Uniform Resource Identifier (URI): Generic Syntax&lt;/a&gt;.</source>
          <target state="translated">此类表示&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;定义的URI参考：统一资源标识符（URI）：通用语法。</target>
        </trans-unit>
        <trans-unit id="d92467a1ebd54ee2626a8826007b25b0ab9f1b59" translate="yes" xml:space="preserve">
          <source>This class staples together two unidirectional &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;s to form a single, bidirectional &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此类将两个单向 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 装订在一起以形成单个双向 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e73af425ad3a2ff6fa73d0afa1e584f684932012" translate="yes" xml:space="preserve">
          <source>This class wraps another &lt;code&gt;&lt;a href=&quot;../../socket/server&quot;&gt;::Socket::Server&lt;/a&gt;&lt;/code&gt; in an SSL layer.</source>
          <target state="translated">此类在SSL层中包装了另一个 &lt;code&gt;&lt;a href=&quot;../../socket/server&quot;&gt;::Socket::Server&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1776e307c121681e53f8c19a0a7a184cfe531a3e" translate="yes" xml:space="preserve">
          <source>This clock should be independent from discontinuous jumps in the system time, such as leap seconds, time zone adjustments or manual changes to the computer's clock.</source>
          <target state="translated">此时钟应独立于系统时间的不连续跳动,如闰秒、时区调整或手动改变计算机的时钟。</target>
        </trans-unit>
        <trans-unit id="d28537f2d1d725c35f1636b8d0c2dfbe4ba0c293" translate="yes" xml:space="preserve">
          <source>This command will write &lt;code&gt;hello&lt;/code&gt; and subsequently delete all files and folders in the current working directory.</source>
          <target state="translated">此命令将打个 &lt;code&gt;hello&lt;/code&gt; ，然后删除当前工作目录中的所有文件和文件夹。</target>
        </trans-unit>
        <trans-unit id="e7ff54e18af98cd3ffdf3df24c6450032d8767e8" translate="yes" xml:space="preserve">
          <source>This constant is defined to be &quot;1970-01-01 00:00:00 UTC&quot;. Can be used to create a &lt;code&gt;&lt;a href=&quot;time/span&quot;&gt;Time::Span&lt;/a&gt;&lt;/code&gt; that represents an Unix Epoch time duration.</source>
          <target state="translated">该常数定义为&amp;ldquo; 1970-01-01 00:00:00 UTC&amp;rdquo;。可用于创建代表Unix纪元持续时间的 &lt;code&gt;&lt;a href=&quot;time/span&quot;&gt;Time::Span&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a45bd7af59946b2a334031775a47a6e9a021531c" translate="yes" xml:space="preserve">
          <source>This constructor will &lt;em&gt;ignore&lt;/em&gt; any path or query segments in the URI as those will need to be passed to the client when a request is made.</source>
          <target state="translated">此构造函数将&lt;em&gt;忽略&lt;/em&gt; URI中的任何路径或查询段，因为在发出请求时需要将这些路径或查询段传递给客户端。</target>
        </trans-unit>
        <trans-unit id="a3406bd6a5b767e93fac04fc21d6da07c89f17e6" translate="yes" xml:space="preserve">
          <source>This constructor will raise an exception if any scheme but HTTP or HTTPS is used.</source>
          <target state="translated">如果使用了HTTP或HTTPS以外的任何方案,这个构造函数将引发异常。</target>
        </trans-unit>
        <trans-unit id="fd7237b6baa5ece029d338b82602580b42a87ed0" translate="yes" xml:space="preserve">
          <source>This covers two uses cases.</source>
          <target state="translated">这包括两种使用情况。</target>
        </trans-unit>
        <trans-unit id="d71e26587af83aa7ce2d4b43555f5703ec675c25" translate="yes" xml:space="preserve">
          <source>This creates a new instance with the same string representation but with &lt;code&gt;&lt;a href=&quot;path/kind#WINDOWS&quot;&gt;Kind::WINDOWS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这将创建一个具有相同字符串表示形式但具有 &lt;code&gt;&lt;a href=&quot;path/kind#WINDOWS&quot;&gt;Kind::WINDOWS&lt;/a&gt;&lt;/code&gt; 的新实例。</target>
        </trans-unit>
        <trans-unit id="29b9aa4580cc6ed55353a8702da056f1635f9be3" translate="yes" xml:space="preserve">
          <source>This document tree can then be converted to YAML be invoking &lt;code&gt;to_yaml&lt;/code&gt; on the document object.</source>
          <target state="translated">然后可以通过在文档对象上调用 &lt;code&gt;to_yaml&lt;/code&gt; 将该文档树转换为YAML 。</target>
        </trans-unit>
        <trans-unit id="39154e3473a0dc991c568ac27b3f2440313ad34a" translate="yes" xml:space="preserve">
          <source>This ends up invoking &lt;code&gt;&lt;a href=&quot;object#to_s(io:IO):Nil-instance-method&quot;&gt;Object#to_s(IO)&lt;/a&gt;&lt;/code&gt; on each expression enclosed by &lt;code&gt;#{...}&lt;/code&gt;.</source>
          <target state="translated">这最终在 &lt;code&gt;#{...}&lt;/code&gt; 所包围的每个表达式上调用 &lt;code&gt;&lt;a href=&quot;object#to_s(io:IO):Nil-instance-method&quot;&gt;Object#to_s(IO)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="060c58baa29e1fcb98dcf6a86e23ec4c882ea63c" translate="yes" xml:space="preserve">
          <source>This ends up invoking &lt;code&gt;object.to_io(self, format)&lt;/code&gt;, so any object defining a &lt;code&gt;to_io(io : &lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;, format : &lt;a href=&quot;io/byteformat&quot;&gt;IO::ByteFormat&lt;/a&gt; = &lt;a href=&quot;io/byteformat/systemendian&quot;&gt;IO::ByteFormat::SystemEndian&lt;/a&gt;)&lt;/code&gt; method can be written in this way.</source>
          <target state="translated">这样最终会调用 &lt;code&gt;object.to_io(self, format)&lt;/code&gt; ，因此任何定义 &lt;code&gt;to_io(io : &lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;, format : &lt;a href=&quot;io/byteformat&quot;&gt;IO::ByteFormat&lt;/a&gt; = &lt;a href=&quot;io/byteformat/systemendian&quot;&gt;IO::ByteFormat::SystemEndian&lt;/a&gt;)&lt;/code&gt; 方法的对象都可以以这种方式编写。</target>
        </trans-unit>
        <trans-unit id="cb5dc44fe685bf23c6f2a42b59ae9f6d1d4af375" translate="yes" xml:space="preserve">
          <source>This ends up invoking &lt;code&gt;type.from_io(self, format)&lt;/code&gt;, so any type defining a &lt;code&gt;from_io(io : &lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;, format : &lt;a href=&quot;io/byteformat&quot;&gt;IO::ByteFormat&lt;/a&gt; = &lt;a href=&quot;io/byteformat/systemendian&quot;&gt;IO::ByteFormat::SystemEndian&lt;/a&gt;)&lt;/code&gt; method can be read in this way.</source>
          <target state="translated">这样最终会调用 &lt;code&gt;type.from_io(self, format)&lt;/code&gt; ，因此任何定义 &lt;code&gt;from_io(io : &lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;, format : &lt;a href=&quot;io/byteformat&quot;&gt;IO::ByteFormat&lt;/a&gt; = &lt;a href=&quot;io/byteformat/systemendian&quot;&gt;IO::ByteFormat::SystemEndian&lt;/a&gt;)&lt;/code&gt; 方法的类型都可以读取。</target>
        </trans-unit>
        <trans-unit id="848435bb3324ae976c11c3cb776d5fc697e9bd2d" translate="yes" xml:space="preserve">
          <source>This equates to the results from &lt;code&gt;&lt;a href=&quot;time#calendar_week:Tuple(Int32,Int32)-instance-method&quot;&gt;#calendar_week&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;time#day_of_week:Time::DayOfWeek-instance-method&quot;&gt;#day_of_week&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这等于 &lt;code&gt;&lt;a href=&quot;time#calendar_week:Tuple(Int32,Int32)-instance-method&quot;&gt;#calendar_week&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;time#day_of_week:Time::DayOfWeek-instance-method&quot;&gt;#day_of_week&lt;/a&gt;&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="afbaccbf56819a8b62afa62f6cd2562c851e8ae5" translate="yes" xml:space="preserve">
          <source>This essentially scaps off &lt;code&gt;nanoseconds&lt;/code&gt;.</source>
          <target state="translated">这实质上是 &lt;code&gt;nanoseconds&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffc1b3edbbf38b05a0ee3f094ab36d4fb3ce5295" translate="yes" xml:space="preserve">
          <source>This explanation should include a few examples along with subheadings.</source>
          <target state="translated">这种解释应包括几个例子以及小标题。</target>
        </trans-unit>
        <trans-unit id="8aa426b4a863c63113851317019c903a9b399921" translate="yes" xml:space="preserve">
          <source>This expression is also available in the &lt;a href=&quot;type_grammar&quot;&gt;type grammar&lt;/a&gt;.</source>
          <target state="translated">该表达式在&lt;a href=&quot;type_grammar&quot;&gt;grammar类型中&lt;/a&gt;也可用。</target>
        </trans-unit>
        <trans-unit id="2b72baa812d61ece5decfb24ec25e9c34062d798" translate="yes" xml:space="preserve">
          <source>This extra rule is very convenient because it's very common to have &quot;constructor-like&quot; class methods in addition to &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">这个额外的规则非常方便，因为除了 &lt;code&gt;new&lt;/code&gt; 之外，还具有&amp;ldquo;类似于构造函数&amp;rdquo;的类方法非常普遍。</target>
        </trans-unit>
        <trans-unit id="88a8efe3fa756c00e20ace6147aa9004dfe45bf9" translate="yes" xml:space="preserve">
          <source>This file is used to require &lt;code&gt;spec&lt;/code&gt; and other includes like code from the project needed for every spec file. This is also a good place to define global helper methods that make writing specs easier and avoid code duplication.</source>
          <target state="translated">该文件用于要求 &lt;code&gt;spec&lt;/code&gt; ，其他包括类似项目中每个规格文件所需的代码。这也是定义全局帮助程序方法的好地方，这些方法可以简化编写规范并避免代码重复。</target>
        </trans-unit>
        <trans-unit id="c68257bbe42e4b6932347e56617681dc1006cd33" translate="yes" xml:space="preserve">
          <source>This form allows you to specify the return type and to check it against the proc's body.</source>
          <target state="translated">通过此表单可以指定返回类型,并与proc的主体进行核对。</target>
        </trans-unit>
        <trans-unit id="685485e2edc62b0420c3e833489e240b8333d814" translate="yes" xml:space="preserve">
          <source>This generates the following output showing the mean iterations per second, the mean times per iteration, the standard deviation relative to the mean, and a comparison:</source>
          <target state="translated">这将产生以下输出,显示每秒的平均迭代次数、每次迭代的平均时间、相对于平均值的标准差以及比较。</target>
        </trans-unit>
        <trans-unit id="cef42efc62c5a598403b41b6864adca576c540ce" translate="yes" xml:space="preserve">
          <source>This generates the following output:</source>
          <target state="translated">这将产生以下输出。</target>
        </trans-unit>
        <trans-unit id="8563101441b8caea1f946cd2dcc00e0fff6fd76e" translate="yes" xml:space="preserve">
          <source>This guide presents the api of crystal-db, the sql commands might need to be adapted for the concrete driver due to differences between postgres, mysql and sqlite.</source>
          <target state="translated">本指南介绍了crystal-db的api,由于postgres、mysql和sqlite的不同,sql命令可能需要针对具体的驱动进行调整。</target>
        </trans-unit>
        <trans-unit id="96ed9d68319f2b0bd7158dce5969429c473b2c10" translate="yes" xml:space="preserve">
          <source>This implementation of Bcrypt is currently 50% slower than pure C solutions, so keep this in mind when selecting your cost. It may be wise to test with Ruby's &lt;a href=&quot;https://github.com/codahale/bcrypt-ruby&quot;&gt;bcrypt gem&lt;/a&gt; which is a binding to OpenBSD's implementation.</source>
          <target state="translated">目前，Bcrypt的这种实现方式比纯C解决方案慢50％，因此在选择成本时请记住这一点。使用Ruby的&lt;a href=&quot;https://github.com/codahale/bcrypt-ruby&quot;&gt;bcrypt gem&lt;/a&gt;（与OpenBSD的实现绑定）进行测试可能是明智的。</target>
        </trans-unit>
        <trans-unit id="67d51a88c6db05098f9b5a707ccc79ae0d34eaf5" translate="yes" xml:space="preserve">
          <source>This implementation supports both IPv4 and IPv6 addresses. For IPv4 addresses you must use &lt;code&gt;&lt;a href=&quot;socket/family#INET&quot;&gt;Socket::Family::INET&lt;/a&gt;&lt;/code&gt; family (default) or &lt;code&gt;&lt;a href=&quot;socket/family#INET6&quot;&gt;Socket::Family::INET6&lt;/a&gt;&lt;/code&gt; for IPv6 # addresses.</source>
          <target state="translated">此实现同时支持IPv4和IPv6地址。对于IPv4地址，必须将 &lt;code&gt;&lt;a href=&quot;socket/family#INET&quot;&gt;Socket::Family::INET&lt;/a&gt;&lt;/code&gt; 系列（默认）或 &lt;code&gt;&lt;a href=&quot;socket/family#INET6&quot;&gt;Socket::Family::INET6&lt;/a&gt;&lt;/code&gt; 用于IPv6＃地址。</target>
        </trans-unit>
        <trans-unit id="e6ce8e3e44aae5b88d2909e4c16dca95dba30407" translate="yes" xml:space="preserve">
          <source>This is &lt;a href=&quot;unsafe&quot;&gt;unsafe&lt;/a&gt; code and is almost always used in low-level code for declaring uninitialized &lt;a href=&quot;http://crystal-lang.org/api/StaticArray.html&quot;&gt;StaticArray&lt;/a&gt; buffers without a performance penalty:</source>
          <target state="translated">这是&lt;a href=&quot;unsafe&quot;&gt;不安全的&lt;/a&gt;代码，几乎总是在低级代码中用于声明未初始化的&lt;a href=&quot;http://crystal-lang.org/api/StaticArray.html&quot;&gt;StaticArray&lt;/a&gt;缓冲区，而不会降低性能：</target>
        </trans-unit>
        <trans-unit id="632a34c3007c26c97734bd84e5e0be3f30f8d0e3" translate="yes" xml:space="preserve">
          <source>This is &lt;code&gt;Int#times&lt;/code&gt; definition:</source>
          <target state="translated">这是 &lt;code&gt;Int#times&lt;/code&gt; 的定义：</target>
        </trans-unit>
        <trans-unit id="c668fa989e55efeeecfc94f0c60618b6423f1d4d" translate="yes" xml:space="preserve">
          <source>This is a convenience method to allow invoking &lt;code&gt;&lt;a href=&quot;json#mapping(**_properties_)-macro&quot;&gt;JSON.mapping&lt;/a&gt;&lt;/code&gt; with named arguments instead of with a hash/named-tuple literal.</source>
          <target state="translated">这是允许使用命名参数而不是哈希/命名元组文字调用 &lt;code&gt;&lt;a href=&quot;json#mapping(**_properties_)-macro&quot;&gt;JSON.mapping&lt;/a&gt;&lt;/code&gt; 的便捷方法。</target>
        </trans-unit>
        <trans-unit id="6ef92f89c3db410d172018d00077e09a212a4874" translate="yes" xml:space="preserve">
          <source>This is a convenience method to allow invoking &lt;code&gt;&lt;a href=&quot;yaml#mapping(**_properties_)-macro&quot;&gt;YAML.mapping&lt;/a&gt;&lt;/code&gt; with named arguments instead of with a hash/named-tuple literal.</source>
          <target state="translated">这是一种方便的方法，允许使用命名参数而不是哈希/命名元组文字来调用 &lt;code&gt;&lt;a href=&quot;yaml#mapping(**_properties_)-macro&quot;&gt;YAML.mapping&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30d559b41aae00e4148c999f88a873b235e4915a" translate="yes" xml:space="preserve">
          <source>This is a low-level primitive and only useful if a C API needs to directly interface with the data layout of a Crystal type.</source>
          <target state="translated">这是一个低级基元,只有在C API需要直接与Crystal类型的数据布局接口时才有用。</target>
        </trans-unit>
        <trans-unit id="73ddca3219f717b051a6ded485d83b6fa803e12f" translate="yes" xml:space="preserve">
          <source>This is also compatible to &lt;a href=&quot;https://tools.ietf.org/html/rfc882&quot;&gt;RFC 882&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc1123#page-55&quot;&gt;RFC 1123&lt;/a&gt;.</source>
          <target state="translated">这也与&lt;a href=&quot;https://tools.ietf.org/html/rfc882&quot;&gt;RFC 882&lt;/a&gt;和&lt;a href=&quot;https://tools.ietf.org/html/rfc1123#page-55&quot;&gt;RFC 1123&lt;/a&gt;兼容。</target>
        </trans-unit>
        <trans-unit id="c68376c0667e18f7a382b86a544065d7e53d580b" translate="yes" xml:space="preserve">
          <source>This is because a Reference's memory is allocated on the heap and a pointer to it is passed around. To get the effective size of a class, use &lt;a href=&quot;instance_sizeof&quot;&gt;instance_sizeof&lt;/a&gt;.</source>
          <target state="translated">这是因为在堆上分配了引用的内存，并传递了指向它的指针。要获取类的有效大小，请使用&lt;a href=&quot;instance_sizeof&quot;&gt;instance_sizeof&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4eca2fa8fad65eb1231ee4c3f04f7c430eebc7ac" translate="yes" xml:space="preserve">
          <source>This is because in the first case all spawned fibers refer to the same local variable, while in the second example copies of &lt;em&gt;i&lt;/em&gt; are passed to a &lt;code&gt;&lt;a href=&quot;proc&quot;&gt;Proc&lt;/a&gt;&lt;/code&gt; that eventually invokes the call.</source>
          <target state="translated">这是因为在第一种情况下，所有生成的纤维都引用相同的局部变量，而在第二种示例中，&lt;em&gt;i的&lt;/em&gt;副本将传递给最终调用该调用的 &lt;code&gt;&lt;a href=&quot;proc&quot;&gt;Proc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcd7f3ba18ba9e17570b1b0e53cc1b5e8d8b9512" translate="yes" xml:space="preserve">
          <source>This is because the captured block could have been potentially stored in a class or instance variable and invoked in a separate thread in between the instructions. The compiler doesn't do an exhaustive analysis of this: it just assumes that if a variable is captured by a proc, the time of that proc invocation is unknown.</source>
          <target state="translated">这是因为被捕获的块有可能被存储在一个类或实例变量中,并在指令之间的单独线程中被调用。编译器并没有对此进行详尽的分析:它只是假设如果一个变量被proc捕获,那么该proc的调用时间是未知的。</target>
        </trans-unit>
        <trans-unit id="fd54023c6204f1d90016305f2a3d17147b84f8e2" translate="yes" xml:space="preserve">
          <source>This is because when you invoke &lt;code&gt;add&lt;/code&gt;, it is instantiated with the types of the arguments: every method invocation with a different type combination results in a different method instantiation.</source>
          <target state="translated">这是因为当您调用 &lt;code&gt;add&lt;/code&gt; 时，它将使用参数的类型实例化：具有不同类型组合的每个方法调用都会导致不同的方法实例化。</target>
        </trans-unit>
        <trans-unit id="af7abaf72beea84936719d7cea52eba04777347e" translate="yes" xml:space="preserve">
          <source>This is better understood with an example:</source>
          <target state="translated">这一点用一个例子比较好理解。</target>
        </trans-unit>
        <trans-unit id="b18c7290adfec84504b1a4877c69b353776ca115" translate="yes" xml:space="preserve">
          <source>This is done automatically when &lt;code&gt;crystal tool format&lt;/code&gt; is invoked, which will automatically format all &lt;code&gt;.cr&lt;/code&gt; files in current directory.</source>
          <target state="translated">调用 &lt;code&gt;crystal tool format&lt;/code&gt; 时，此操作自动完成，这将自动格式化当前目录中的所有 &lt;code&gt;.cr&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="91073a8ebd255c745f3396ef35b162c27b3bb870" translate="yes" xml:space="preserve">
          <source>This is equivalent to creating a &lt;code&gt;&lt;a href=&quot;time/span&quot;&gt;Time::Span&lt;/a&gt;&lt;/code&gt; from the time-of-day fields:</source>
          <target state="translated">这等效于从时间字段中创建 &lt;code&gt;&lt;a href=&quot;time/span&quot;&gt;Time::Span&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dfca88e8493ed6d6c8920bcc9d7e06f379cc0d79" translate="yes" xml:space="preserve">
          <source>This is everything you can know about an object: its type and whether it responds to some method.</source>
          <target state="translated">这是你能知道的关于一个对象的一切:它的类型以及它是否响应某个方法。</target>
        </trans-unit>
        <trans-unit id="664081d7cf972a751025c22c5dc7255042548b08" translate="yes" xml:space="preserve">
          <source>This is for example useful for deconstructing union types:</source>
          <target state="translated">例如,这对解构联合类型很有用。</target>
        </trans-unit>
        <trans-unit id="79f0d29001d1769f206501b875fe2a4be959d263" translate="yes" xml:space="preserve">
          <source>This is implemented with &lt;code&gt;&lt;a href=&quot;http/client#before_request(&amp;amp;callback:HTTP::Request-%3E)-instance-method&quot;&gt;HTTP::Client#before_request&lt;/a&gt;&lt;/code&gt; to add an authorization header to every request.</source>
          <target state="translated">这是通过 &lt;code&gt;&lt;a href=&quot;http/client#before_request(&amp;amp;callback:HTTP::Request-%3E)-instance-method&quot;&gt;HTTP::Client#before_request&lt;/a&gt;&lt;/code&gt; 实现的，以向每个请求添加授权标头。</target>
        </trans-unit>
        <trans-unit id="93c98b3533b696f4b265f2ddae4194beb8d972a7" translate="yes" xml:space="preserve">
          <source>This is just one type (Array) and one operation (assignment), the logic of the above will be applied differently for other types and assignments, in general &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;Covariance and Contravariance&lt;/a&gt; is not fully supported.</source>
          <target state="translated">这只是一种类型（数组）和一种操作（赋值），上述逻辑将以其他方式应用于其他类型和赋值，通常不完全支持&lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;协方差和相反&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce0c6cf5aa7169f819d2d736ee90776ca387cefc" translate="yes" xml:space="preserve">
          <source>This is mostly useful with local variables that change at iterations. This doesn't happen with block arguments. For example, this works as expected:</source>
          <target state="translated">这对于在迭代时发生变化的局部变量来说是非常有用的。而块参数则不会出现这种情况。例如,这和预期的一样。</target>
        </trans-unit>
        <trans-unit id="5a0992e1a80d3e4aab5a27e49eddb6a4c8048563" translate="yes" xml:space="preserve">
          <source>This is particularly useful if a number can have a wide value range and the &lt;em&gt;exact&lt;/em&gt; value is less relevant.</source>
          <target state="translated">如果数字的取值范围很广，而&lt;em&gt;确切的&lt;/em&gt;值不太重要，则这特别有用。</target>
        </trans-unit>
        <trans-unit id="5364ea4cf5554cdeb55193ac67c0fb4222bb4698" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;&lt;a href=&quot;time#parse_rfc3339(time:String)-class-method&quot;&gt;.parse_rfc3339&lt;/a&gt;&lt;/code&gt; but RFC 3339 defines a more strict format. In ISO 8601 for examples, field delimiters (&lt;code&gt;&lt;a href=&quot;time#-(other:Time):Time::Span-instance-method&quot;&gt;#-&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;:&lt;/code&gt;) are optional.</source>
          <target state="translated">这类似于 &lt;code&gt;&lt;a href=&quot;time#parse_rfc3339(time:String)-class-method&quot;&gt;.parse_rfc3339&lt;/a&gt;&lt;/code&gt; ,但RFC 3339定义了更严格的格式。在ISO 8601为例子，字段分隔符（ &lt;code&gt;&lt;a href=&quot;time#-(other:Time):Time::Span-instance-method&quot;&gt;#-&lt;/a&gt;&lt;/code&gt; ,： &lt;code&gt;:&lt;/code&gt; 是可选的。</target>
        </trans-unit>
        <trans-unit id="250bf5a8b00d1f7cd791eee40b73a5cf04cfc0a2" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;&lt;a href=&quot;zone#UTC&quot;&gt;UTC&lt;/a&gt;&lt;/code&gt; time zone with offset &lt;code&gt;+00:00&lt;/code&gt;.</source>
          <target state="translated">这是偏移时间 &lt;code&gt;+00:00&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;zone#UTC&quot;&gt;UTC&lt;/a&gt;&lt;/code&gt; 时区。</target>
        </trans-unit>
        <trans-unit id="8048727c8234993d8a5603cf23d4eb243123a864" translate="yes" xml:space="preserve">
          <source>This is the base class of all AST nodes. This methods are available to all AST nodes.</source>
          <target state="translated">这是所有AST节点的基础类。这个方法对所有AST节点都是可用的。</target>
        </trans-unit>
        <trans-unit id="98b840bba8d77d2469d9697df6f696e784ce6c1c" translate="yes" xml:space="preserve">
          <source>This is the formal specification of method and call arguments.</source>
          <target state="translated">这是方法和调用参数的形式规范。</target>
        </trans-unit>
        <trans-unit id="3a96f07459b7208207e134ed71189ac50df50dea" translate="yes" xml:space="preserve">
          <source>This is the language reference for the Crystal programming language.</source>
          <target state="translated">这是Crystal编程语言的语言参考。</target>
        </trans-unit>
        <trans-unit id="545dbbaa58655b1b054f6a7d8c72f5c89bb6c9d0" translate="yes" xml:space="preserve">
          <source>This is the only unsafe type in Crystal. If you are using a pointer, you are writing unsafe code because a pointer doesn't know where it's pointing to nor how much memory starting from it is valid. However, pointers make it possible to interface with C and to implement efficient data structures. For example, both &lt;code&gt;&lt;a href=&quot;array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt;&lt;/code&gt; are implemented using pointers.</source>
          <target state="translated">这是Crystal中唯一不安全的类型。如果您使用的是指针，那么您将编写不安全的代码，因为指针既不知道指针指向何处，也不知道从其开始有多少内存有效。但是，指针使与C进行接口并实现有效的数据结构成为可能。例如， &lt;code&gt;&lt;a href=&quot;array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt;&lt;/code&gt; 都使用指针实现。</target>
        </trans-unit>
        <trans-unit id="4515edf50a067229e0e7eda1b93dee9d3077b41c" translate="yes" xml:space="preserve">
          <source>This is the same as using &lt;code&gt;as&lt;/code&gt;, but allows the class to be passed around as an argument. See the &lt;a href=&quot;../../docs/syntax_and_semantics/as&quot;&gt;documentation on as&lt;/a&gt; for more information.</source>
          <target state="translated">这与使用 &lt;code&gt;as&lt;/code&gt; 相同，但是允许将类作为参数传递。有关更多信息，请参见上的&lt;a href=&quot;../../docs/syntax_and_semantics/as&quot;&gt;文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="39052dac05dacfea2b321976622c6881f8fee6d2" translate="yes" xml:space="preserve">
          <source>This is useful for exposing part of an underlying stream to a client.</source>
          <target state="translated">这对于将底层流的一部分暴露给客户端很有用。</target>
        </trans-unit>
        <trans-unit id="40d1de068db96b91cef4b055764a503963b9cf23" translate="yes" xml:space="preserve">
          <source>This is useful for two reasons:</source>
          <target state="translated">这有两个原因。</target>
        </trans-unit>
        <trans-unit id="d89f4023c0e9b9c432dcbf2c74989c25293766ca" translate="yes" xml:space="preserve">
          <source>This is very convenient in &lt;code&gt;case&lt;/code&gt; expressions:</source>
          <target state="translated">这在 &lt;code&gt;case&lt;/code&gt; 表达式中非常方便：</target>
        </trans-unit>
        <trans-unit id="0a50b57903b64f2c7c8a3d039dbee7449f283aac" translate="yes" xml:space="preserve">
          <source>This is very useful for defining wrappers of C types without having to explicitly transform them to their wrapped values.</source>
          <target state="translated">这对于定义C类型的封装器非常有用,无需显式地将它们转换为封装值。</target>
        </trans-unit>
        <trans-unit id="cf97a41abfcb211c83d6d5b49f2e738fde8a0d1a" translate="yes" xml:space="preserve">
          <source>This literal can be used with any type as long as it has an argless constructor and responds to &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">该文字可以用于任何类型，只要它具有无参构造函数并响应 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 即可。</target>
        </trans-unit>
        <trans-unit id="f3b7949166254a30289854bd34a8746a15f08640" translate="yes" xml:space="preserve">
          <source>This literal can be used with any type as long as it has an argless constructor and responds to &lt;code&gt;[]=&lt;/code&gt;.</source>
          <target state="translated">只要具有无参构造函数并响应 &lt;code&gt;[]=&lt;/code&gt; ,此文字就可以用于任何类型。</target>
        </trans-unit>
        <trans-unit id="4e04e4dfcae0f1da86f93f68805a481ead2f3cf3" translate="yes" xml:space="preserve">
          <source>This logic also applies if there are ands (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;) in the condition:</source>
          <target state="translated">如果条件中包含ands（ &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ），则此逻辑也适用：</target>
        </trans-unit>
        <trans-unit id="1e0d40403d0fb3af87493347eb75affb4d82e65c" translate="yes" xml:space="preserve">
          <source>This looks up &quot;filename&quot; in the require path.</source>
          <target state="translated">这将在require路径中查找 &quot;文件名&quot;。</target>
        </trans-unit>
        <trans-unit id="02b666351739e8df630e195dd5876f8ab2fbf2d7" translate="yes" xml:space="preserve">
          <source>This looks up &quot;filename&quot; relative to the file containing the require expression.</source>
          <target state="translated">这将查找相对于包含require表达式的文件的 &quot;filename&quot;。</target>
        </trans-unit>
        <trans-unit id="2ab59e555766a52026ea5b3d2c2a19fd4e20a6af" translate="yes" xml:space="preserve">
          <source>This looks very fancy, but is it as fast as a C for loop? The answer is: yes!</source>
          <target state="translated">这个看起来很花哨,但是它的速度有C for loop快吗?答案是:是的!</target>
        </trans-unit>
        <trans-unit id="8b6184f21171f25107a2ac683d8c6894f82542b9" translate="yes" xml:space="preserve">
          <source>This macro also declares instance variables of the types given in the mapping.</source>
          <target state="translated">这个宏还声明了映射中给定类型的实例变量。</target>
        </trans-unit>
        <trans-unit id="b2d0d78d660060de2cbed03d7173e382c1204b9d" translate="yes" xml:space="preserve">
          <source>This macro also provides a &lt;code&gt;copy_with&lt;/code&gt; method which returns a copy of the record with the provided properties altered.</source>
          <target state="translated">此宏还提供了 &lt;code&gt;copy_with&lt;/code&gt; 方法，该方法返回更改了提供的属性的记录的副本。</target>
        </trans-unit>
        <trans-unit id="d81c22d82ab054ab6073357b0043598ce14efbcc" translate="yes" xml:space="preserve">
          <source>This macro by default defines getters and setters for each variable (this can be overrided with &lt;em&gt;setter&lt;/em&gt; and &lt;em&gt;getter&lt;/em&gt;). The mapping doesn't define a constructor accepting these variables as arguments, but you can provide an overload.</source>
          <target state="translated">默认情况下，此宏为每个变量定义getter和setter（可以使用&lt;em&gt;setter&lt;/em&gt;和&lt;em&gt;getter&lt;/em&gt;覆盖）。映射没有定义接受这些变量作为参数的构造函数，但是您可以提供重载。</target>
        </trans-unit>
        <trans-unit id="a49b61072cd1f4d994675e912b4c5252a36758cb" translate="yes" xml:space="preserve">
          <source>This method allocates memory for the slice copy and duplicates the values.</source>
          <target state="translated">此方法为切片复制分配内存并复制值。</target>
        </trans-unit>
        <trans-unit id="1fc1ff3b014b53619b8bfb952dda2082d153d03a" translate="yes" xml:space="preserve">
          <source>This method allocates memory for the slice copy and stores the return values from calling &lt;code&gt;&lt;a href=&quot;slice#clone-instance-method&quot;&gt;#clone&lt;/a&gt;&lt;/code&gt; on each item.</source>
          <target state="translated">此方法为切片副本分配内存，并存储在每个项目上调用 &lt;code&gt;&lt;a href=&quot;slice#clone-instance-method&quot;&gt;#clone&lt;/a&gt;&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="3ffc762b0fa54672474374b2e8dff624af1fbed0" translate="yes" xml:space="preserve">
          <source>This method allows creating a &lt;code&gt;&lt;a href=&quot;range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt; of chars.</source>
          <target state="translated">此方法允许创建一个字符 &lt;code&gt;&lt;a href=&quot;range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de40eee84880ab1581a5f5076ca5d5b101ef5a29" translate="yes" xml:space="preserve">
          <source>This method also accepts &lt;code&gt;0&lt;/code&gt; to identify &lt;code&gt;&lt;a href=&quot;dayofweek#Sunday&quot;&gt;Sunday&lt;/a&gt;&lt;/code&gt; in order to be compliant with the &lt;code&gt;&lt;a href=&quot;dayofweek#Sunday&quot;&gt;Sunday&lt;/a&gt; = 0&lt;/code&gt; numbering. All other days are equal in both formats.</source>
          <target state="translated">此方法还接受 &lt;code&gt;0&lt;/code&gt; 来标识 &lt;code&gt;&lt;a href=&quot;dayofweek#Sunday&quot;&gt;Sunday&lt;/a&gt;&lt;/code&gt; ，以便与 &lt;code&gt;&lt;a href=&quot;dayofweek#Sunday&quot;&gt;Sunday&lt;/a&gt; = 0&lt;/code&gt; 编号兼容。两种格式的所有其他日子都相同。</target>
        </trans-unit>
        <trans-unit id="a804975c90be266f4bd9934431ac6b0117a7a3c1" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;#reset&lt;/code&gt; to remove any previous settings and writes the given &lt;em&gt;status&lt;/em&gt; and &lt;em&gt;message&lt;/em&gt; to the response IO. Finally, it closes the response.</source>
          <target state="translated">此方法调用 &lt;code&gt;#reset&lt;/code&gt; 删除所有先前的设置，并将给定的&lt;em&gt;状态&lt;/em&gt;和&lt;em&gt;消息&lt;/em&gt;写入响应IO。最后，它关闭响应。</target>
        </trans-unit>
        <trans-unit id="876ed2a7e2571907a92804ebfdfb5c32fcf2d101" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;@wrapped&lt;a href=&quot;server#accept:OpenSSL::SSL::Socket::Server-instance-method&quot;&gt;.accept&lt;/a&gt;&lt;/code&gt; and wraps the resulting IO in a SSL socket (&lt;code&gt;&lt;a href=&quot;socket/server&quot;&gt;OpenSSL::SSL::Socket::Server&lt;/a&gt;&lt;/code&gt;) with &lt;code&gt;&lt;a href=&quot;server#context:OpenSSL::SSL::Context::Server-instance-method&quot;&gt;#context&lt;/a&gt;&lt;/code&gt; configuration.</source>
          <target state="translated">此方法调用 &lt;code&gt;@wrapped&lt;a href=&quot;server#accept:OpenSSL::SSL::Socket::Server-instance-method&quot;&gt;.accept&lt;/a&gt;&lt;/code&gt; 并将生成的IO封装在具有 &lt;code&gt;&lt;a href=&quot;server#context:OpenSSL::SSL::Context::Server-instance-method&quot;&gt;#context&lt;/a&gt;&lt;/code&gt; 配置的SSL套接字（ &lt;code&gt;&lt;a href=&quot;socket/server&quot;&gt;OpenSSL::SSL::Socket::Server&lt;/a&gt;&lt;/code&gt; ）中。</target>
        </trans-unit>
        <trans-unit id="80fa8b3ce296002e2382ec789a479a1aec82c056" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;@wrapped&lt;a href=&quot;server#accept?:OpenSSL::SSL::Socket::Server?-instance-method&quot;&gt;.accept?&lt;/a&gt;&lt;/code&gt; and wraps the resulting IO in a SSL socket (&lt;code&gt;&lt;a href=&quot;socket/server&quot;&gt;OpenSSL::SSL::Socket::Server&lt;/a&gt;&lt;/code&gt;) with &lt;code&gt;&lt;a href=&quot;server#context:OpenSSL::SSL::Context::Server-instance-method&quot;&gt;#context&lt;/a&gt;&lt;/code&gt; configuration.</source>
          <target state="translated">此方法调用 &lt;code&gt;@wrapped&lt;a href=&quot;server#accept?:OpenSSL::SSL::Socket::Server?-instance-method&quot;&gt;.accept?&lt;/a&gt;&lt;/code&gt; 并将产生的IO封装在具有 &lt;code&gt;&lt;a href=&quot;server#context:OpenSSL::SSL::Context::Server-instance-method&quot;&gt;#context&lt;/a&gt;&lt;/code&gt; 配置的SSL套接字（ &lt;code&gt;&lt;a href=&quot;socket/server&quot;&gt;OpenSSL::SSL::Socket::Server&lt;/a&gt;&lt;/code&gt; ）中。</target>
        </trans-unit>
        <trans-unit id="110bbb23114f80368a621ef48c06272849dba2f9" translate="yes" xml:space="preserve">
          <source>This method can also be used to write the name of an object field.</source>
          <target state="translated">这个方法也可以用来写一个对象字段的名称。</target>
        </trans-unit>
        <trans-unit id="f43eccd5c568a2a2f76820b8c8229fa24a237d06" translate="yes" xml:space="preserve">
          <source>This method can be invoked if you need to define a custom main (as in C main) function, doing all the above steps.</source>
          <target state="translated">如果你需要定义一个自定义的main(如C主)函数,可以调用这个方法,完成以上所有步骤。</target>
        </trans-unit>
        <trans-unit id="07c49154a6dfeb600685b04ea81731ffbadfa9d7" translate="yes" xml:space="preserve">
          <source>This method can be used to manually fail an example defined in an &lt;code&gt;#it&lt;/code&gt; block.</source>
          <target state="translated">此方法可用于手动使 &lt;code&gt;#it&lt;/code&gt; 块中定义的示例失败。</target>
        </trans-unit>
        <trans-unit id="8a3b403803b3e2898c855162b3d133ab7e6aaad3" translate="yes" xml:space="preserve">
          <source>This method changes the time zone and retains the instant, which will usually result in a different representation of local date-time (unless both locations have the same offset).</source>
          <target state="translated">这种方法改变了时区,保留了即时性,这通常会导致本地日期-时间的不同表示(除非两个地点有相同的偏移)。</target>
        </trans-unit>
        <trans-unit id="71254f8f1f1ac03231cb7a3a2658052200785c63" translate="yes" xml:space="preserve">
          <source>This method enables some customization, but typical use cases can be implemented by either &lt;code&gt;&lt;a href=&quot;uri#decode(string:String,*,plus_to_space:Bool=false):String-class-method&quot;&gt;.decode(string : String, *, plus_to_space : Bool = false)&lt;/a&gt; : &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;.deode_www_form(string : String, *, plus_to_space : Bool = true) : &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此方法使一些定制，但是典型的使用情况下，可以通过实现 &lt;code&gt;&lt;a href=&quot;uri#decode(string:String,*,plus_to_space:Bool=false):String-class-method&quot;&gt;.decode(string : String, *, plus_to_space : Bool = false)&lt;/a&gt; : &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;.deode_www_form(string : String, *, plus_to_space : Bool = true) : &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66fb97869fc5212ab96dadd23532f875642eb2d8" translate="yes" xml:space="preserve">
          <source>This method enables some customization, but typical use cases can be implemented by either &lt;code&gt;&lt;a href=&quot;uri#encode(string:String,*,space_to_plus:Bool=false):String-class-method&quot;&gt;.encode(string : String, *, space_to_plus : Bool = false)&lt;/a&gt; : &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;uri#encode_www_form(string:String,*,space_to_plus:Bool=true):String-class-method&quot;&gt;.encode_www_form(string : String, *, space_to_plus : Bool = true)&lt;/a&gt; : &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此方法可以进行一些自定义，但是典型的用例可以通过 &lt;code&gt;&lt;a href=&quot;uri#encode(string:String,*,space_to_plus:Bool=false):String-class-method&quot;&gt;.encode(string : String, *, space_to_plus : Bool = false)&lt;/a&gt; : &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;uri#encode_www_form(string:String,*,space_to_plus:Bool=true):String-class-method&quot;&gt;.encode_www_form(string : String, *, space_to_plus : Bool = true)&lt;/a&gt; : &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="543c64a9546cd1816d1a00aa3905da29065cb26c" translate="yes" xml:space="preserve">
          <source>This method is &lt;strong&gt;unsafe&lt;/strong&gt; because it behaves unpredictably when the given &lt;code&gt;type&lt;/code&gt; doesn't have the same bytesize as the receiver, or when the given &lt;code&gt;type&lt;/code&gt; representation doesn't semantically match the underlying bytes.</source>
          <target state="translated">此方法是&lt;strong&gt;不安全的，&lt;/strong&gt;因为当给定 &lt;code&gt;type&lt;/code&gt; 的字节大小与接收者的字节大小不同时，或者当给定 &lt;code&gt;type&lt;/code&gt; 表示形式在语义上与基础字节不匹配时，此方法的行为将无法预测。</target>
        </trans-unit>
        <trans-unit id="b5cbc5a629094572b5cae34df050919f9fe50bca" translate="yes" xml:space="preserve">
          <source>This method is &lt;strong&gt;unsafe&lt;/strong&gt; because it returns a pointer, and the pointed might eventually not be that of &lt;code&gt;self&lt;/code&gt; if the array grows and its internal buffer is reallocated.</source>
          <target state="translated">此方法是&lt;strong&gt;不安全的，&lt;/strong&gt;因为它返回一个指针，并且如果数组增长并且其内部缓冲区已重新分配，则指针最终可能不是 &lt;code&gt;self&lt;/code&gt; 的指针。</target>
        </trans-unit>
        <trans-unit id="9bcfc5121e3fcaeeab6ad40e3bd6aee85d973a99" translate="yes" xml:space="preserve">
          <source>This method is &lt;strong&gt;unsafe&lt;/strong&gt;, but is usually used to initialize the buffer by passing it to a C function.</source>
          <target state="translated">此方法&lt;strong&gt;不安全&lt;/strong&gt;，但通常用于通过将缓冲区传递给C函数来初始化缓冲区。</target>
        </trans-unit>
        <trans-unit id="14321e39d197f6c1679a31b60eb9fba345489c89" translate="yes" xml:space="preserve">
          <source>This method is &lt;strong&gt;unsafe&lt;/strong&gt;: the pointer must point to data that eventually contains a zero byte that indicates the ends of the string. Otherwise, the result of this method is undefined and might cause a segmentation fault.</source>
          <target state="translated">此方法是&lt;strong&gt;不安全的&lt;/strong&gt;：指针必须指向最终包含零字节的数据，该零字节指示字符串的结尾。否则，该方法的结果不确定，并可能导致分段错误。</target>
        </trans-unit>
        <trans-unit id="6ab980b8075db8f065c8f6c51a0c2bd59a577ec5" translate="yes" xml:space="preserve">
          <source>This method is always safe to call, and the resulting string will have the contents and size of the slice.</source>
          <target state="translated">这个方法的调用总是安全的,所得到的字符串将有分片的内容和大小。</target>
        </trans-unit>
        <trans-unit id="cf8c7ff1e18f6211fa80b57a21af687888058dc1" translate="yes" xml:space="preserve">
          <source>This method is automatically invoked for you, so you don't need to invoke it.</source>
          <target state="translated">这个方法是自动帮你调用的,所以你不需要调用它。</target>
        </trans-unit>
        <trans-unit id="1d83bafe31e3643b12d002caba871495df77db30" translate="yes" xml:space="preserve">
          <source>This method is mainly intended to convert integers from C to enums in Crystal.</source>
          <target state="translated">这个方法主要是为了在Crystal中把C语言的整数转换为枚举。</target>
        </trans-unit>
        <trans-unit id="10fc8f745b12a33607325325d055ac6d307f9324" translate="yes" xml:space="preserve">
          <source>This method is the inverse operation to &lt;code&gt;&lt;a href=&quot;uri#relativize(uri:URI%7CString):URI-instance-method&quot;&gt;#relativize&lt;/a&gt;&lt;/code&gt; (see &lt;a href=&quot;#Resolution%20and%20Relativization&quot;&gt;Resolution and Relativization&lt;/a&gt;).</source>
          <target state="translated">此方法是 &lt;code&gt;&lt;a href=&quot;uri#relativize(uri:URI%7CString):URI-instance-method&quot;&gt;#relativize&lt;/a&gt;&lt;/code&gt; 的逆操作（请参见&lt;a href=&quot;#Resolution%20and%20Relativization&quot;&gt;解析和相对化&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="79f2ef5ab90e3a8738a37aed767115a397e15aba" translate="yes" xml:space="preserve">
          <source>This method is the inverse operation to &lt;code&gt;&lt;a href=&quot;uri#resolve(uri:URI%7CString):URI-instance-method&quot;&gt;#resolve&lt;/a&gt;&lt;/code&gt; (see &lt;a href=&quot;#Resolution%20and%20Relativization&quot;&gt;Resolution and Relativization&lt;/a&gt;).</source>
          <target state="translated">此方法是 &lt;code&gt;&lt;a href=&quot;uri#resolve(uri:URI%7CString):URI-instance-method&quot;&gt;#resolve&lt;/a&gt;&lt;/code&gt; 的逆操作（请参阅&lt;a href=&quot;#Resolution%20and%20Relativization&quot;&gt;解析和相对化&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a666cc527ca8b43282f1ede4f1744600df5f756b" translate="yes" xml:space="preserve">
          <source>This method is the same as &lt;code&gt;&lt;a href=&quot;stringscanner#scan(pattern)-instance-method&quot;&gt;#scan&lt;/a&gt;&lt;/code&gt;, but without returning the matched string.</source>
          <target state="translated">此方法与 &lt;code&gt;&lt;a href=&quot;stringscanner#scan(pattern)-instance-method&quot;&gt;#scan&lt;/a&gt;&lt;/code&gt; 相同，但不返回匹配的字符串。</target>
        </trans-unit>
        <trans-unit id="6c8c40735837bf50315a9cfb6667abdad0d7f275" translate="yes" xml:space="preserve">
          <source>This method is the same as &lt;code&gt;&lt;a href=&quot;stringscanner#scan_until(pattern)-instance-method&quot;&gt;#scan_until&lt;/a&gt;&lt;/code&gt;, but without returning the matched string.</source>
          <target state="translated">此方法与 &lt;code&gt;&lt;a href=&quot;stringscanner#scan_until(pattern)-instance-method&quot;&gt;#scan_until&lt;/a&gt;&lt;/code&gt; 相同，但不返回匹配的字符串。</target>
        </trans-unit>
        <trans-unit id="0bb21be8b188c3a362afbdf538e490cfff2b5a0a" translate="yes" xml:space="preserve">
          <source>This method is typically used in C bindings, where you get a &lt;code&gt;char*&lt;/code&gt; from a library and the library guarantees that this pointer eventually has an ending zero byte.</source>
          <target state="translated">此方法通常在C绑定中使用，在C绑定中，您从库中获取 &lt;code&gt;char*&lt;/code&gt; ，并且该库保证此指针最终具有结尾的零字节。</target>
        </trans-unit>
        <trans-unit id="bc47d62663f52dafb03da6c2b69547adb50f68fa" translate="yes" xml:space="preserve">
          <source>This method is useful for dealing with nilable types, to safely perform operations only when the value is not &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">此方法对于处理nilable类型很有用，仅在值不为 &lt;code&gt;nil&lt;/code&gt; 时安全地执行操作。</target>
        </trans-unit>
        <trans-unit id="d52e6cffffcfea09e2979e5b48f2c15d49e1eac0" translate="yes" xml:space="preserve">
          <source>This method is useful in macros and generic code because with it you can create empty tuples, something that you can't do with a tuple literal.</source>
          <target state="translated">这个方法在宏和通用代码中很有用,因为有了它,你可以创建空的元组,这是用元组的文字形式无法做到的。</target>
        </trans-unit>
        <trans-unit id="9e189ba2199c84eed3718c288cd96471cb504b30" translate="yes" xml:space="preserve">
          <source>This method is useful in macros and generic code because with it you can creates empty named tuples, something that you can't do with a tuple literal.</source>
          <target state="translated">这个方法在宏和通用代码中是很有用的,因为有了它,你可以创建空的命名元组,这是用元组的文字形式无法做到的。</target>
        </trans-unit>
        <trans-unit id="c912bee98c99ac38403dfcb10a3bd634650f827b" translate="yes" xml:space="preserve">
          <source>This method is useful to treat a type that is represented as a chunk of bytes as another type where those bytes convey useful information. As an example, you can check the individual bytes of an &lt;code&gt;&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">此方法对于将表示为字节块的类型视为另一种类型（这些字节传达有用信息）很有用。例如，您可以检查 &lt;code&gt;&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 的各个字节：</target>
        </trans-unit>
        <trans-unit id="19eea505855cc0210c1b92472e2a60293b570c37" translate="yes" xml:space="preserve">
          <source>This method isn't usually used directly. Instead, &lt;code&gt;&lt;a href=&quot;box#box(r:Reference?):Pointer(Void)-class-method&quot;&gt;Box.box&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">通常不直接使用此方法。而是使用 &lt;code&gt;&lt;a href=&quot;box#box(r:Reference?):Pointer(Void)-class-method&quot;&gt;Box.box&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1197afc812e6fc70baa998134563bed7f2085c44" translate="yes" xml:space="preserve">
          <source>This method must have the property that &lt;code&gt;a == b&lt;/code&gt; implies &lt;code&gt;a&lt;a href=&quot;entry#hash-instance-method&quot;&gt;.hash&lt;/a&gt; == b&lt;a href=&quot;entry#hash-instance-method&quot;&gt;.hash&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此方法必须具有该属性 &lt;code&gt;a == b&lt;/code&gt; 意味着 &lt;code&gt;a&lt;a href=&quot;entry#hash-instance-method&quot;&gt;.hash&lt;/a&gt; == b&lt;a href=&quot;entry#hash-instance-method&quot;&gt;.hash&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47729461eef607d08960810a64f22def6ef8a562" translate="yes" xml:space="preserve">
          <source>This method must have the property that &lt;code&gt;a == b&lt;/code&gt; implies &lt;code&gt;a&lt;a href=&quot;object#hash-instance-method&quot;&gt;.hash&lt;/a&gt; == b&lt;a href=&quot;object#hash-instance-method&quot;&gt;.hash&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此方法必须具有该属性 &lt;code&gt;a == b&lt;/code&gt; 意味着 &lt;code&gt;a&lt;a href=&quot;object#hash-instance-method&quot;&gt;.hash&lt;/a&gt; == b&lt;a href=&quot;object#hash-instance-method&quot;&gt;.hash&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a90186c6146674e3e7ef361cc7cc1b26068df08" translate="yes" xml:space="preserve">
          <source>This method only performs a read to return peek data if the current buffer is empty: otherwise no read is performed and whatever is in the buffer is returned.</source>
          <target state="translated">只有在当前缓冲区为空的情况下,该方法才会执行读取以返回peek数据:否则不执行读取,而是返回缓冲区中的任何数据。</target>
        </trans-unit>
        <trans-unit id="ed2a383fb699dde9e1533f4af7a6692504f3bb02" translate="yes" xml:space="preserve">
          <source>This method returns the same namespaces as &lt;code&gt;&lt;a href=&quot;node#namespace_scopes-instance-method&quot;&gt;#namespace_scopes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此方法返回与 &lt;code&gt;&lt;a href=&quot;node#namespace_scopes-instance-method&quot;&gt;#namespace_scopes&lt;/a&gt;&lt;/code&gt; 相同的名称空间。</target>
        </trans-unit>
        <trans-unit id="b2d1ee8cd64f3b3676979d7591c596fc8ed6d870" translate="yes" xml:space="preserve">
          <source>This method should only be directly invoked if you are absolutely sure the index is in bounds, to avoid a bounds check for a small boost of performance.</source>
          <target state="translated">只有在你绝对确定索引在边界内的情况下,才应该直接调用这个方法,以避免边界检查对性能的小幅提升。</target>
        </trans-unit>
        <trans-unit id="c5b1576a5fca213095e97f27f1bbc043c9560882" translate="yes" xml:space="preserve">
          <source>This method should sometimes be called before passing a &lt;code&gt;&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to a C function.</source>
          <target state="translated">有时应在将 &lt;code&gt;&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 传递给C函数之前调用此方法。</target>
        </trans-unit>
        <trans-unit id="a4e0deb49c8f4340fdd9a131432eaf0af24b6109" translate="yes" xml:space="preserve">
          <source>This method takes into account the possibility that an downcase version of a char might result in multiple chars, like for 'İ', which results in 'i' and a dot mark.</source>
          <target state="translated">这种方法考虑到一个字符的降大写版本可能会导致多个字符,比如'İ',结果是'i'和一个点号。</target>
        </trans-unit>
        <trans-unit id="cc68b5f7db9e81404c09ccaa273be5676eccd6d8" translate="yes" xml:space="preserve">
          <source>This method takes into account the possibility that an upcase version of a char might result in multiple chars, like for 'ﬄ', which results in 'F', 'F' and 'L'.</source>
          <target state="translated">这个方法考虑到一个字符的大写版本可能会导致多个字符,比如'ﬄ',结果是'F'、'F'和'L'。</target>
        </trans-unit>
        <trans-unit id="1e00cd560926f03ce357aa52106e39137e95ab6c" translate="yes" xml:space="preserve">
          <source>This method usually doesn't need to be called explicitly when the default behaviour is expected. It will be called implicitly with &lt;code&gt;load_defaults: true&lt;/code&gt; when a query method is called and the MIME database has not been initialized before.</source>
          <target state="translated">当期望默认行为时，通常不需要显式调用此方法。当调用查询方法并且之前尚未初始化MIME数据库时，将使用 &lt;code&gt;load_defaults: true&lt;/code&gt; 隐式调用它。</target>
        </trans-unit>
        <trans-unit id="3a5edfda3cb0e0e647d156b5a991a6b768edd899" translate="yes" xml:space="preserve">
          <source>This method yields once instead of returning the values, because the IO object yielded to the block is only valid while the block is executing. The IO object will be closed as soon as the block returns. To store the content of the body part for longer than the block, the IO must be read into memory.</source>
          <target state="translated">这个方法只产生一次而不是返回值,因为产生给块的IO对象只在块执行时有效。一旦块返回,IO对象就会被关闭。如果要将主体部分的内容存储的时间比块长,必须将IO读入内存。</target>
        </trans-unit>
        <trans-unit id="51e8c2a0cd5329af392ba2518f88ca9cf8a35b80" translate="yes" xml:space="preserve">
          <source>This methods yields the order of magnitude and &lt;code&gt;self&lt;/code&gt; and expects the block to return a &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;Tuple&lt;/a&gt;(&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;, _)&lt;/code&gt; containing the (adjusted) magnitude and unit. The magnitude is typically adjusted to a multiple of &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">此方法产生量级和 &lt;code&gt;self&lt;/code&gt; 量级，并期望该块返回包含（已调整的）量级和单位的 &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;Tuple&lt;/a&gt;(&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;, _)&lt;/code&gt; 。通常将幅度调整为 &lt;code&gt;3&lt;/code&gt; 的倍数。</target>
        </trans-unit>
        <trans-unit id="62426ddc1b8c4721acf93078455ae0f39d239320" translate="yes" xml:space="preserve">
          <source>This module also defines a global method &lt;code&gt;&lt;a href=&quot;random#rand:Float64-instance-method&quot;&gt;#rand&lt;/a&gt;&lt;/code&gt;, which &lt;code&gt;&lt;a href=&quot;array#sample(n:Int,random=Random::DEFAULT)-instance-method&quot;&gt;Array#sample&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;array#shuffle(random=Random::DEFAULT)-instance-method&quot;&gt;Array#shuffle&lt;/a&gt;&lt;/code&gt; delegates.</source>
          <target state="translated">该模块还定义了一个全局方法 &lt;code&gt;&lt;a href=&quot;random#rand:Float64-instance-method&quot;&gt;#rand&lt;/a&gt;&lt;/code&gt; ，该方法由 &lt;code&gt;&lt;a href=&quot;array#sample(n:Int,random=Random::DEFAULT)-instance-method&quot;&gt;Array#sample&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;array#shuffle(random=Random::DEFAULT)-instance-method&quot;&gt;Array#shuffle&lt;/a&gt;&lt;/code&gt; 委托。</target>
        </trans-unit>
        <trans-unit id="75bda1245302220c674f57b233bbd6c1619cbf1b" translate="yes" xml:space="preserve">
          <source>This module conforms to &lt;a href=&quot;https://tools.ietf.org/html/rfc4180&quot;&gt;RFC 4180&lt;/a&gt;.</source>
          <target state="translated">该模块符合&lt;a href=&quot;https://tools.ietf.org/html/rfc4180&quot;&gt;RFC 4180&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f36bf7fc88f3d7e2acf2d7488c604ff22c154e16" translate="yes" xml:space="preserve">
          <source>This module defines a number of methods to create expectations, which are automatically included into the top level namespace.</source>
          <target state="translated">该模块定义了一些创建期望的方法,这些方法会自动包含在顶层命名空间中。</target>
        </trans-unit>
        <trans-unit id="8ef2aac295915a70eb298437ad90c977a8e82a34" translate="yes" xml:space="preserve">
          <source>This module implements a global MIME registry.</source>
          <target state="translated">这个模块实现了一个全局的MIME注册表。</target>
        </trans-unit>
        <trans-unit id="97ee9e8267f97333d03d6d7ac70d5aec355de137" translate="yes" xml:space="preserve">
          <source>This monotonic clock should always be used for measuring elapsed time.</source>
          <target state="translated">这种单调时钟应始终用于测量经过的时间。</target>
        </trans-unit>
        <trans-unit id="76eed7e1078f4676da5877d91557fa7850731a4a" translate="yes" xml:space="preserve">
          <source>This of course also works with the short syntax:</source>
          <target state="translated">当然这也适用于短句法。</target>
        </trans-unit>
        <trans-unit id="bb9ed4011966335dc5ee5afee070bdb3ee3a010c" translate="yes" xml:space="preserve">
          <source>This operates on the instant time-line, such that adding the equivalent of one hour will always be a duration of one hour later. The local date-time representation may change by a different amount, depending on time zone transitions.</source>
          <target state="translated">这是在即时时间线上操作的,因此,加上相当于一小时的时间总是一小时后的持续时间。根据时区的转换,当地的日期-时间表示可能会有不同程度的变化。</target>
        </trans-unit>
        <trans-unit id="689b61b343ffbccdbdcb0fa7201504543e3cd9c8" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, such that the local date-time represenation of the result will be apart by the specified amounts, but the elapsed time between both instances might not equal to the combined default durations This is the case for example when adding a day over a daylight-savings time change:</source>
          <target state="translated">这是在本地时间线上的操作,这样本地日期-时间代表的结果将以指定的数量相隔,但两个实例之间的经过时间可能不等于合并的默认持续时间。</target>
        </trans-unit>
        <trans-unit id="8054f1719741cee4f425263c3995947f7fa96063" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, such that the local date-time represenations of month and year are decreased by the specified amount.</source>
          <target state="translated">这是在本地时间线上的操作,使本地的月份和年份的日期-时间代表按指定的数量减少。</target>
        </trans-unit>
        <trans-unit id="f79406c77945d14f81970afd66d037ffdbb5eda0" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, such that the local date-time represenations of month and year are increased by the specified amount.</source>
          <target state="translated">这是在本地时间线上操作的,这样本地的月份和年份的日期-时间代表就会增加指定的数量。</target>
        </trans-unit>
        <trans-unit id="4dcf0ee2f6fdf3917e32df47707c61c1e54afb89" translate="yes" xml:space="preserve">
          <source>This operation is often useful when constructing a document containing URIs that must be made relative to the base URI of the document wherever possible.</source>
          <target state="translated">当构建一个包含URI的文档时,这个操作往往是有用的,因为在可能的情况下,这个文档必须相对于文档的基本URI。</target>
        </trans-unit>
        <trans-unit id="0358a14c793d7b599d3ce27a3c57a46685678281" translate="yes" xml:space="preserve">
          <source>This philosophy of appending to an IO instead of returning an intermediate string results in better performance than handling intermediate strings. You should use this strategy in your API definitions too.</source>
          <target state="translated">这种对一个IO进行追加而不是返回一个中间字符串的理念,比处理中间字符串的性能更好。你也应该在你的API定义中使用这种策略。</target>
        </trans-unit>
        <trans-unit id="345205710c1209079bdf05b4d146f25fe0a01f36" translate="yes" xml:space="preserve">
          <source>This prints:</source>
          <target state="translated">这个指纹。</target>
        </trans-unit>
        <trans-unit id="0731dc79f56c5a5399cdd125c11e0e16381f03fa" translate="yes" xml:space="preserve">
          <source>This procedure is usually done with the compiler itself to port it to new platforms where a compiler is not yet available. Because in order to compile a Crystal compiler we need an older Crystal compiler, the only two ways to generate a compiler for a system where there isn't a compiler yet are:</source>
          <target state="translated">这个过程通常是用编译器本身来完成的,以便把它移植到还没有编译器的新平台上。因为要编译一个Crystal编译器,我们需要一个旧的Crystal编译器,所以在还没有编译器的系统中,只有两种方法可以生成一个编译器。</target>
        </trans-unit>
        <trans-unit id="f4f30c3e0066d3a8e63a8ffbeed56fdd87c8d84a" translate="yes" xml:space="preserve">
          <source>This process can sometimes be ambiguous, mostly due skipping or repeating times at time zone transitions. For example, in &lt;code&gt;America/New_York&lt;/code&gt; the date-time &lt;code&gt;2011-03-13 02:15:00&lt;/code&gt; never occurred, there is a gap between time zones. In return, &lt;code&gt;2011-11-06 01:15:00&lt;/code&gt; occurred twice because of overlapping time zones.</source>
          <target state="translated">此过程有时可能是模棱两可的，主要是由于在时区转换时跳过或重复了一些时间。例如，在 &lt;code&gt;America/New_York&lt;/code&gt; ，日期时间 &lt;code&gt;2011-03-13 02:15:00&lt;/code&gt; 从未发生，时区之间存在间隙。作为回报，由于时区重叠，两次发生了 &lt;code&gt;2011-11-06 01:15:00&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7da89f81a6359e1270db436a8688ea3526540d3d" translate="yes" xml:space="preserve">
          <source>This program will now print &quot;Hello!&quot; for one second and then exit. This is because the &lt;code&gt;sleep&lt;/code&gt; call will schedule the main fiber to be executed in a second, and then executes another &quot;ready to execute&quot; fiber, which in this case is the one above.</source>
          <target state="translated">该程序现在将打印&amp;ldquo; Hello！&amp;rdquo;。一秒钟，然后退出。这是因为 &lt;code&gt;sleep&lt;/code&gt; 调用将安排主光纤在第二秒内执行，然后执行另一条&amp;ldquo;准备执行&amp;rdquo;光纤，在本例中为上面的光纤。</target>
        </trans-unit>
        <trans-unit id="74c0ac4de62bc9d3b7a85cce5fd828fd7bb4a2b0" translate="yes" xml:space="preserve">
          <source>This property is not used by &lt;code&gt;&lt;a href=&quot;client&quot;&gt;HTTP::Client&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;client&quot;&gt;HTTP::Client&lt;/a&gt;&lt;/code&gt; 不使用此属性。</target>
        </trans-unit>
        <trans-unit id="c8794cafe5b797061ff826222c6c552391384571" translate="yes" xml:space="preserve">
          <source>This refers to the key type after brackets in &lt;code&gt;{} of &lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt; =&amp;gt; &lt;a href=&quot;../../int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是指 &lt;code&gt;{} of &lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt; =&amp;gt; &lt;a href=&quot;../../int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; =&amp;gt; &lt;a href=&quot;../../int32&quot;&gt;Int32的&lt;/a&gt; {}中括号后的键类型。</target>
        </trans-unit>
        <trans-unit id="c7278b89ebc4f3fabb567a7bd24e0a5313fc445f" translate="yes" xml:space="preserve">
          <source>This refers to the part after brackets in &lt;code&gt;[] of &lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是指 &lt;code&gt;[] of &lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; []中括号后的部分。</target>
        </trans-unit>
        <trans-unit id="697d7116d5f364c69ea8f55b62982b8f1f4059b9" translate="yes" xml:space="preserve">
          <source>This refers to the part before brackets in &lt;code&gt;MyArray{1, 2, 3}&lt;/code&gt;</source>
          <target state="translated">这是指 &lt;code&gt;MyArray{1, 2, 3}&lt;/code&gt; 括号之前的部分</target>
        </trans-unit>
        <trans-unit id="7bc977bb2fc0b4c01d75516a5a45dde31530727e" translate="yes" xml:space="preserve">
          <source>This refers to the part before brackets in &lt;code&gt;MyHash{'a' =&amp;gt; 1, 'b' =&amp;gt; 2}&lt;/code&gt;</source>
          <target state="translated">这是指 &lt;code&gt;MyHash{'a' =&amp;gt; 1, 'b' =&amp;gt; 2}&lt;/code&gt; 括号之前的部分</target>
        </trans-unit>
        <trans-unit id="e5f920536af30024ac5594d12b099fada1081a08" translate="yes" xml:space="preserve">
          <source>This refers to the value type after brackets in &lt;code&gt;{} of &lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt; =&amp;gt; &lt;a href=&quot;../../int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是指 &lt;code&gt;{} of &lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt; =&amp;gt; &lt;a href=&quot;../../int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; =&amp;gt; &lt;a href=&quot;../../int32&quot;&gt;Int32的&lt;/a&gt; {}中括号后的值类型。</target>
        </trans-unit>
        <trans-unit id="2e61f408c66d2ef06ad806d64eaa7b58ca292228" translate="yes" xml:space="preserve">
          <source>This relative is mostly used inside a project to refer to other files inside it. It is also used to refer to code from &lt;a href=&quot;../guides/testing&quot;&gt;specs&lt;/a&gt;:</source>
          <target state="translated">此相对对象通常在项目内部使用，以引用其中的其他文件。它也用于引用&lt;a href=&quot;../guides/testing&quot;&gt;specs中的&lt;/a&gt;代码：</target>
        </trans-unit>
        <trans-unit id="9ea34ae3b77ad69c508d28fc2b46f4924528c9b8" translate="yes" xml:space="preserve">
          <source>This report shows the user CPU time, system CPU time, the sum of the user and system CPU times, and the elapsed real time. The unit of time is seconds.</source>
          <target state="translated">该报告显示了用户CPU时间、系统CPU时间、用户和系统CPU时间之和以及经过的真实时间。时间的单位是秒。</target>
        </trans-unit>
        <trans-unit id="28c2258bbc71d1f49bb9629ab15d81f27a6243cb" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;true&lt;/code&gt; if this string has &lt;code&gt;'\\'&lt;/code&gt; in it.</source>
          <target state="translated">如果此字符串中包含 &lt;code&gt;'\\'&lt;/code&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d63ed5386acee7fbcae7bcc58193fbf54c6d7a4" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;true&lt;/code&gt; if this string has &lt;code&gt;'\\'&lt;/code&gt; in it. It might not be a back reference, but &lt;code&gt;'\\'&lt;/code&gt; is probably used for back references, so this check is faster than parsing the whole thing.</source>
          <target state="translated">如果此字符串中包含 &lt;code&gt;'\\'&lt;/code&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; 。它可能不是反向引用，但 &lt;code&gt;'\\'&lt;/code&gt; 可能用于反向引用，因此此检查比解析整个对象要快。</target>
        </trans-unit>
        <trans-unit id="be08ec13ad9411238deedacbc59aa2fdcd06dff9" translate="yes" xml:space="preserve">
          <source>This rule, and every following rule, will also be applied in methods other than &lt;code&gt;initialize&lt;/code&gt;. For example:</source>
          <target state="translated">该规则以及随后的所有规则也将应用于 &lt;code&gt;initialize&lt;/code&gt; 以外的方法。例如：</target>
        </trans-unit>
        <trans-unit id="35fd6a2d0fbee4824cffb18179c1cc6fe1309793" translate="yes" xml:space="preserve">
          <source>This set must have fewer elements than the &lt;em&gt;other&lt;/em&gt; set, and all of elements in this set must be present in the &lt;em&gt;other&lt;/em&gt; set.</source>
          <target state="translated">该集合必须具有比&lt;em&gt;另一个&lt;/em&gt;集合更少的元素，并且该集合中的所有元素都必须存在于&lt;em&gt;另一个&lt;/em&gt;集合中。</target>
        </trans-unit>
        <trans-unit id="4e39714594b95b24fdb97211c25e93b7a6033812" translate="yes" xml:space="preserve">
          <source>This set must have the same or fewer elements than the &lt;em&gt;other&lt;/em&gt; set, and all of elements in this set must be present in the &lt;em&gt;other&lt;/em&gt; set.</source>
          <target state="translated">该集合必须具有与&lt;em&gt;另一个&lt;/em&gt;集合相同或更少的元素，并且该集合中的所有元素都必须存在于&lt;em&gt;另一个&lt;/em&gt;集合中。</target>
        </trans-unit>
        <trans-unit id="cd46145a937322b3092ef850ea2e72579163510e" translate="yes" xml:space="preserve">
          <source>This setups up the GC, invokes your program, rescuing any handled exception, and then runs &lt;code&gt;at_exit&lt;/code&gt; handlers.</source>
          <target state="translated">这将设置GC，调用您的程序，抢救所有已处理的异常，然后运行 &lt;code&gt;at_exit&lt;/code&gt; 处理程序。</target>
        </trans-unit>
        <trans-unit id="4d49f58b302655fd388385ae9fd8b219fde17efe" translate="yes" xml:space="preserve">
          <source>This sometimes leads to code that is more natural to read.</source>
          <target state="translated">这有时会导致代码读起来更自然。</target>
        </trans-unit>
        <trans-unit id="93bbe2592bf3a8fdab8e221dd33651441190a20c" translate="yes" xml:space="preserve">
          <source>This style is used in the standard library. You can use it in your own project to make it familiar to other developers.</source>
          <target state="translated">这种风格在标准库中使用。你可以在你自己的项目中使用它,使它为其他开发者所熟悉。</target>
        </trans-unit>
        <trans-unit id="f79ff816778bb65cd18c1cfa96c8948218bf293e" translate="yes" xml:space="preserve">
          <source>This tells Travis CI to generate your documentation.</source>
          <target state="translated">这告诉Travis CI要生成你的文档。</target>
        </trans-unit>
        <trans-unit id="359fdc4110e121a56bf92d5d6db9ba14ec114d47" translate="yes" xml:space="preserve">
          <source>This tells Travis CI to run your tests. Accordingly with the outcome of this command, Travis CI will return a &lt;a href=&quot;https://docs.travis-ci.com/user/for-beginners/#breaking-the-build&quot;&gt;build status&lt;/a&gt; of &quot;passed&quot;, &quot;errored&quot;, &quot;failed&quot; or &quot;canceled&quot;.</source>
          <target state="translated">这告诉Travis CI运行您的测试。因此，根据该命令的结果，Travis CI将返回&amp;ldquo;通过&amp;rdquo;，&amp;ldquo;错误&amp;rdquo;，&amp;ldquo;失败&amp;rdquo;或&amp;ldquo;取消&amp;rdquo; 的&lt;a href=&quot;https://docs.travis-ci.com/user/for-beginners/#breaking-the-build&quot;&gt;构建状态&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="35c7ea27f4db8675a4d025c0b83e21b4e148643b" translate="yes" xml:space="preserve">
          <source>This time &lt;code&gt;Fiber.yield&lt;/code&gt; will tell the scheduler to execute the other fiber. This will print &quot;Hello!&quot; until the standard output blocks (the system call will tell us we have to wait until the output is ready), and then execution continues with the main fiber and the program exits. Here the standard output &lt;em&gt;might&lt;/em&gt; never block so the program will continue executing forever.</source>
          <target state="translated">这次， &lt;code&gt;Fiber.yield&lt;/code&gt; 将告诉调度程序执行另一根光纤。这将打印&amp;ldquo; Hello！&amp;rdquo;。直到标准输出块（系统调用将告诉我们我们必须等到输出准备好为止），然后继续在主光纤上执行并退出程序。在这里，标准输出&lt;em&gt;可能&lt;/em&gt;永远不会阻塞，因此程序将永远继续执行。</target>
        </trans-unit>
        <trans-unit id="a01b739b2d64e03fccf6df0598fa7fde0aa0b5d2" translate="yes" xml:space="preserve">
          <source>This type can also be expressed as &lt;code&gt;&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;[3]&lt;/code&gt; (only in type grammar). A typical use case is in combination with &lt;code&gt;uninitialized&lt;/code&gt;:</source>
          <target state="translated">此类型也可以表示为 &lt;code&gt;&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;[3]&lt;/code&gt; （仅在类型语法中）。典型的用例是与 &lt;code&gt;uninitialized&lt;/code&gt; 结合使用：</target>
        </trans-unit>
        <trans-unit id="6229a1a148d5519da2a6720bbf382ade9765c401" translate="yes" xml:space="preserve">
          <source>This uses floored division.</source>
          <target state="translated">这采用浮动式划分。</target>
        </trans-unit>
        <trans-unit id="b7718aa3828a878d42553e8a71799c5eb9b69d5f" translate="yes" xml:space="preserve">
          <source>This uses truncated division.</source>
          <target state="translated">这使用了截断的除法。</target>
        </trans-unit>
        <trans-unit id="16aca72f740ab8cf3e740de83d1220c1fdd6dc05" translate="yes" xml:space="preserve">
          <source>This way, you can group the different options in an easier to read way.</source>
          <target state="translated">这样一来,你就可以将不同的选项以一种更容易阅读的方式进行分组。</target>
        </trans-unit>
        <trans-unit id="eaa64b75c35bfed1e3e6a283a8c2f966dab1cb82" translate="yes" xml:space="preserve">
          <source>This will generate a &lt;code&gt;.o&lt;/code&gt; (&lt;a href=&quot;http://en.wikipedia.org/wiki/Object_file&quot;&gt;Object file&lt;/a&gt;) and will print a line with a command to execute on the system we are trying to cross-compile to. For example:</source>
          <target state="translated">这将生成一个 &lt;code&gt;.o&lt;/code&gt; （&lt;a href=&quot;http://en.wikipedia.org/wiki/Object_file&quot;&gt;目标文件&lt;/a&gt;），并打印一条带有命令的行，以在我们尝试交叉编译的系统上执行。例如：</target>
        </trans-unit>
        <trans-unit id="8a3848df82fc2fd9b15053b5a8fb1d53ba4f2d64" translate="yes" xml:space="preserve">
          <source>This will initialize &lt;code&gt;@age&lt;/code&gt; to zero in every constructor. This is useful to avoid duplication, but also to avoid the &lt;code&gt;Nil&lt;/code&gt; type when reopening a class and adding instance variables to it.</source>
          <target state="translated">这将在每个构造函数 &lt;code&gt;@age&lt;/code&gt; 初始化为零。这对于避免重复很有用，而且在重新打开类并向其添加实例变量时也可以避免使用 &lt;code&gt;Nil&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="f6862c62808e64a2961983e12fec5639b646a395" translate="yes" xml:space="preserve">
          <source>This will neither load the internal defaults nor the OS-provided MIME database, only the database at &lt;em&gt;filename&lt;/em&gt; (using &lt;code&gt;&lt;a href=&quot;mime#load_mime_database(io:IO):Nil-class-method&quot;&gt;.load_mime_database&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">这既不会加载内部默认值，也不会加载操作系统提供的MIME数据库，仅 &lt;code&gt;&lt;a href=&quot;mime#load_mime_database(io:IO):Nil-class-method&quot;&gt;.load_mime_database&lt;/a&gt;&lt;/code&gt; &lt;em&gt;文件&lt;/em&gt;名下的数据库（使用.load_mime_database）。</target>
        </trans-unit>
        <trans-unit id="8e4a064d6bf07aff1893264ade18bd386c01f8fd" translate="yes" xml:space="preserve">
          <source>This will raise &lt;code&gt;&lt;a href=&quot;divisionbyzeroerror&quot;&gt;DivisionByZeroError&lt;/a&gt;&lt;/code&gt; if rational is 0 and &lt;em&gt;other&lt;/em&gt; is negative.</source>
          <target state="translated">如果有理数为0而&lt;em&gt;其他&lt;/em&gt;为负数，则将引发 &lt;code&gt;&lt;a href=&quot;divisionbyzeroerror&quot;&gt;DivisionByZeroError&lt;/a&gt;&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="540e962c82e56e9933ab55514ce46937307ada13" translate="yes" xml:space="preserve">
          <source>This will raise an exception if rational is 0.</source>
          <target state="translated">如果rational为0,这将引发一个异常。</target>
        </trans-unit>
        <trans-unit id="0d0cf7b07e430ad34c34e0cf85d620cc7694ee5a" translate="yes" xml:space="preserve">
          <source>This will set the exception's callstack if it hasn't been already. Re-raising a previously catched exception won't replace the callstack.</source>
          <target state="translated">这将设置异常的callstack(如果还没有)。重新引发先前捕获的异常不会替换调用栈。</target>
        </trans-unit>
        <trans-unit id="809c1055c5940964d4d7581463d92e0e6d06f1df" translate="yes" xml:space="preserve">
          <source>This will work for any type, as long as the argument is a pointer of that type (and, of course, as long as the function does fill the value the pointer is pointing to).</source>
          <target state="translated">这将适用于任何类型,只要参数是该类型的指针(当然,只要函数确实填充了指针指向的值)。</target>
        </trans-unit>
        <trans-unit id="cf5b7c750a4b16617dfd7cff20be48990a9d7985" translate="yes" xml:space="preserve">
          <source>This:</source>
          <target state="translated">This:</target>
        </trans-unit>
        <trans-unit id="8a77bfd3db44e0aeb0a80c2f055eea2ff97f89d4" translate="yes" xml:space="preserve">
          <source>ThreadLocal</source>
          <target state="translated">ThreadLocal</target>
        </trans-unit>
        <trans-unit id="fbf56acd9949ce8c53320dc8f269c4b59f93aa99" translate="yes" xml:space="preserve">
          <source>ThreadLocal is used in the standard library to implement the runtime and shouldn't be needed or used outside it.</source>
          <target state="translated">ThreadLocal是在标准库中用来实现运行时的,不应该在标准库之外需要或使用。</target>
        </trans-unit>
        <trans-unit id="998f079f3e9b6086578875da92b3d4bf7fe6c208" translate="yes" xml:space="preserve">
          <source>Thus, a &lt;code&gt;type&lt;/code&gt; declaration is useful for opaque types that are created by the C library you are wrapping. An example of this is the C &lt;code&gt;FILE&lt;/code&gt; type, which you can obtain with &lt;code&gt;fopen&lt;/code&gt;.</source>
          <target state="translated">因此， &lt;code&gt;type&lt;/code&gt; 声明对于要包装的C库创建的不透明类型很有用。C &lt;code&gt;FILE&lt;/code&gt; 类型就是一个例子，可以通过 &lt;code&gt;fopen&lt;/code&gt; 获得。</target>
        </trans-unit>
        <trans-unit id="6c82e6dd86807ee3db07e3c82bec1ae1ce00b08b" translate="yes" xml:space="preserve">
          <source>Time</source>
          <target state="translated">Time</target>
        </trans-unit>
        <trans-unit id="fd6da341ee1e31055bdb0caea844b3bc49547757" translate="yes" xml:space="preserve">
          <source>Time Zones</source>
          <target state="translated">时区</target>
        </trans-unit>
        <trans-unit id="45f7f84e23d3cbf45aa1ad361f6150ffb2c92505" translate="yes" xml:space="preserve">
          <source>Time#+</source>
          <target state="translated">Time#+</target>
        </trans-unit>
        <trans-unit id="82f05dbf9bd40d142582cbabaf13c9ec714f7fc8" translate="yes" xml:space="preserve">
          <source>Time#-</source>
          <target state="translated">Time#-</target>
        </trans-unit>
        <trans-unit id="59b32578d4ec6a3cc2791de03553ad374274f316" translate="yes" xml:space="preserve">
          <source>Time#==</source>
          <target state="translated">Time#==</target>
        </trans-unit>
        <trans-unit id="f2feb8d3a9f9729c7dd237750cf97897794db323" translate="yes" xml:space="preserve">
          <source>Time#date</source>
          <target state="translated">Time#date</target>
        </trans-unit>
        <trans-unit id="0b05268d69de72bf3cf71eb5d37bad28df9f4d08" translate="yes" xml:space="preserve">
          <source>Time#day</source>
          <target state="translated">Time#day</target>
        </trans-unit>
        <trans-unit id="05b0096476e0652794d07097242aab93643f47d1" translate="yes" xml:space="preserve">
          <source>Time#hash</source>
          <target state="translated">Time#hash</target>
        </trans-unit>
        <trans-unit id="bbe5b4f8a1918bd78d0f9bd714e6515621591498" translate="yes" xml:space="preserve">
          <source>Time#hour</source>
          <target state="translated">Time#hour</target>
        </trans-unit>
        <trans-unit id="f49e737bf31856a03111c5200f6835d9c041ed09" translate="yes" xml:space="preserve">
          <source>Time#in</source>
          <target state="translated">Time#in</target>
        </trans-unit>
        <trans-unit id="9a4fe8b3bc5da5b531b4d49404f6219c94b730de" translate="yes" xml:space="preserve">
          <source>Time#to_s</source>
          <target state="translated">Time#to_s</target>
        </trans-unit>
        <trans-unit id="d9d23eef1492cd8ad949d2ff8fad84b96a1a3b02" translate="yes" xml:space="preserve">
          <source>Time#utc?</source>
          <target state="translated">Time#utc?</target>
        </trans-unit>
        <trans-unit id="040f33dd2545d6fa394e0ef9c046c373098a5df7" translate="yes" xml:space="preserve">
          <source>Time#year</source>
          <target state="translated">Time#year</target>
        </trans-unit>
        <trans-unit id="31815efc02346bf97f32722d1e3c12ed1375078e" translate="yes" xml:space="preserve">
          <source>Time#zone</source>
          <target state="translated">Time#zone</target>
        </trans-unit>
        <trans-unit id="d69c277d397226ffd5d29be1efa076fab3595c89" translate="yes" xml:space="preserve">
          <source>Time.new</source>
          <target state="translated">Time.new</target>
        </trans-unit>
        <trans-unit id="e767cb22ffdfe0fac52dd6a3515aa1c63ca17a9f" translate="yes" xml:space="preserve">
          <source>Time.now</source>
          <target state="translated">Time.now</target>
        </trans-unit>
        <trans-unit id="21e0e4ac341fddd059f695dd40bcae69f90c407a" translate="yes" xml:space="preserve">
          <source>Time.unix</source>
          <target state="translated">Time.unix</target>
        </trans-unit>
        <trans-unit id="a9fcd04edaf1c5d8460989020bfddb6579a8bdbd" translate="yes" xml:space="preserve">
          <source>Time.utc</source>
          <target state="translated">Time.utc</target>
        </trans-unit>
        <trans-unit id="f44b0e0a08860f6a162180fdf57208b3bcce3d0d" translate="yes" xml:space="preserve">
          <source>Time::FloatingTimeConversionError</source>
          <target state="translated">Time::FloatingTimeConversionError</target>
        </trans-unit>
        <trans-unit id="7a098ad63e917713957bcae62de5cd5c1c449249" translate="yes" xml:space="preserve">
          <source>Time::Format</source>
          <target state="translated">Time::Format</target>
        </trans-unit>
        <trans-unit id="56710586bed64419abaf48d0f831ee9464ec508c" translate="yes" xml:space="preserve">
          <source>Time::Format::Error</source>
          <target state="translated">Time::Format::Error</target>
        </trans-unit>
        <trans-unit id="baa031128f6b2507a115abee138b00d81a633515" translate="yes" xml:space="preserve">
          <source>Time::Location</source>
          <target state="translated">Time::Location</target>
        </trans-unit>
        <trans-unit id="dc6a2efc72278c880fc60060c2d08d93e23c1e28" translate="yes" xml:space="preserve">
          <source>Time::Location::InvalidLocationNameError</source>
          <target state="translated">Time::Location::InvalidLocationNameError</target>
        </trans-unit>
        <trans-unit id="f91332a9279dc7d848b29b5473e36752d4953473" translate="yes" xml:space="preserve">
          <source>Time::Location::InvalidLocationNameError#name</source>
          <target state="translated">Time::Location::InvalidLocationNameError#name</target>
        </trans-unit>
        <trans-unit id="a948227bdbd25b65a4e9af5b7b937de5629c59d7" translate="yes" xml:space="preserve">
          <source>Time::Location::InvalidLocationNameError#source</source>
          <target state="translated">Time::Location::InvalidLocationNameError#source</target>
        </trans-unit>
        <trans-unit id="4ea7211d3230d3f1ecdc1167c8550e981df7a4db" translate="yes" xml:space="preserve">
          <source>Time::Location::InvalidLocationNameError.new</source>
          <target state="translated">Time::Location::InvalidLocationNameError.new</target>
        </trans-unit>
        <trans-unit id="0fdcacac6a1e9187d91ce20efc85545810f229dd" translate="yes" xml:space="preserve">
          <source>Time::Location::InvalidTZDataError</source>
          <target state="translated">Time::Location::InvalidTZDataError</target>
        </trans-unit>
        <trans-unit id="bc216615b11bf27a3151249129f35639ad5d24a5" translate="yes" xml:space="preserve">
          <source>Time::Location::InvalidTZDataError.initialize</source>
          <target state="translated">Time::Location::InvalidTZDataError.initialize</target>
        </trans-unit>
        <trans-unit id="65d4d84ecc4be644dad457ad4fafa880dd536fb7" translate="yes" xml:space="preserve">
          <source>Time::Location::InvalidTimezoneOffsetError</source>
          <target state="translated">Time::Location::InvalidTimezoneOffsetError</target>
        </trans-unit>
        <trans-unit id="19f9453978106d020ce7026eeab03b75ae3add7c" translate="yes" xml:space="preserve">
          <source>Time::Location::InvalidTimezoneOffsetError.new</source>
          <target state="translated">Time::Location::InvalidTimezoneOffsetError.new</target>
        </trans-unit>
        <trans-unit id="29a9bbf22513f625f690aa9a2dd33414751923ef" translate="yes" xml:space="preserve">
          <source>Time::Location::Zone</source>
          <target state="translated">Time::Location::Zone</target>
        </trans-unit>
        <trans-unit id="2be65a98e315e2bb7f266f763512cf37b737e902" translate="yes" xml:space="preserve">
          <source>Time::MonthSpan</source>
          <target state="translated">Time::MonthSpan</target>
        </trans-unit>
        <trans-unit id="8583045f3f38250efb8a738945625c5346eda8aa" translate="yes" xml:space="preserve">
          <source>Time::Span</source>
          <target state="translated">Time::Span</target>
        </trans-unit>
        <trans-unit id="5b1360323be02bac91d3fb16b5e60a2642cebe3c" translate="yes" xml:space="preserve">
          <source>Tms#clone</source>
          <target state="translated">Tms#clone</target>
        </trans-unit>
        <trans-unit id="b6b38b40d8ade3a34b035c71c1043de1e9b15483" translate="yes" xml:space="preserve">
          <source>Tms#copy_with</source>
          <target state="translated">Tms#copy_with</target>
        </trans-unit>
        <trans-unit id="237d7decf7e22ee908bb0f7d2580488ded837f85" translate="yes" xml:space="preserve">
          <source>Tms#cstime</source>
          <target state="translated">Tms#cstime</target>
        </trans-unit>
        <trans-unit id="2fc0591049ba9e9822a714f7d969af278d50111d" translate="yes" xml:space="preserve">
          <source>Tms#cutime</source>
          <target state="translated">Tms#cutime</target>
        </trans-unit>
        <trans-unit id="8422313ae0bab325ba717d9618a6e293996e28c7" translate="yes" xml:space="preserve">
          <source>Tms#stime</source>
          <target state="translated">Tms#stime</target>
        </trans-unit>
        <trans-unit id="5662c42e96a18176be559403c86b70887bc97b8f" translate="yes" xml:space="preserve">
          <source>Tms#utime</source>
          <target state="translated">Tms#utime</target>
        </trans-unit>
        <trans-unit id="f34a4c31f00cf9686ba812c79c21089d8e554f3b" translate="yes" xml:space="preserve">
          <source>Tms.new</source>
          <target state="translated">Tms.new</target>
        </trans-unit>
        <trans-unit id="3e157859d37349b0562be4bb6321220fc506e6b4" translate="yes" xml:space="preserve">
          <source>To access a relational database you will need a shard designed for the database server you want to use. The package &lt;a href=&quot;https://github.com/crystal-lang/crystal-db&quot;&gt;crystal-lang/crystal-db&lt;/a&gt; offers a unified api across different drivers.</source>
          <target state="translated">要访问关系数据库，您将需要一个为要使用的数据库服务器设计的分片。软件包&lt;a href=&quot;https://github.com/crystal-lang/crystal-db&quot;&gt;crystal-lang / crystal-db&lt;/a&gt;提供了跨不同驱动程序的统一api。</target>
        </trans-unit>
        <trans-unit id="afd01e7ef4d7b6612c6ee2c6d02466e6f5171167" translate="yes" xml:space="preserve">
          <source>To access the rescued exception you can specify a variable in the &lt;code&gt;rescue&lt;/code&gt; clause:</source>
          <target state="translated">要访问获救的异常，您可以在 &lt;code&gt;rescue&lt;/code&gt; 子句中指定一个变量：</target>
        </trans-unit>
        <trans-unit id="d11efe79bc139c0303e61a991e7d650d3715247a" translate="yes" xml:space="preserve">
          <source>To achieve concurrency, Crystal has fibers. A fiber is in a way similar to an operating system thread except that it's much more lightweight and its execution is managed internally by the process. So, a program will spawn multiple fibers and Crystal will make sure to execute them when the time is right.</source>
          <target state="translated">为了实现并发,Crystal有光纤。纤维在某种程度上类似于操作系统的线程,只是它更加轻量级,它的执行是由进程内部管理的。所以,一个程序会衍生出多个纤维,Crystal会确保在合适的时候执行它们。</target>
        </trans-unit>
        <trans-unit id="67026b084ea2754e35875e26a4f20b44f35af95e" translate="yes" xml:space="preserve">
          <source>To add a page, create a markdown file in the desired location. Example: &lt;code&gt;overview/hello_world.md&lt;/code&gt;. Then, add a link in the &lt;code&gt;SUMMARY.md&lt;/code&gt; file which acts as the navigation for the language reference.</source>
          <target state="translated">要添加页面，请在所需位置创建一个markdown文件。示例： &lt;code&gt;overview/hello_world.md&lt;/code&gt; 。然后，在 &lt;code&gt;SUMMARY.md&lt;/code&gt; 文件中添加一个链接，该链接充当语言参考的导航。</target>
        </trans-unit>
        <trans-unit id="1fcf706c2c28fa515134ca8b1587dbba1a669bda" translate="yes" xml:space="preserve">
          <source>To address this issues usually a connection pool is a neat solution.</source>
          <target state="translated">为了解决这个问题通常连接池是一个整洁的解决方案。</target>
        </trans-unit>
        <trans-unit id="f68c28137aed34c8af3b6b0d8658e573eb903aa1" translate="yes" xml:space="preserve">
          <source>To automatically link to methods in other types, do &lt;code&gt;OtherType#method(arg1, arg2)&lt;/code&gt; or just &lt;code&gt;OtherType#method&lt;/code&gt;, and enclose it with single backticks.</source>
          <target state="translated">要自动链接到其他类型的方法，请执行 &lt;code&gt;OtherType#method(arg1, arg2)&lt;/code&gt; 或仅执行 &lt;code&gt;OtherType#method&lt;/code&gt; ，并将其用单个反引号引起来。</target>
        </trans-unit>
        <trans-unit id="581260c43f5d38d9836815f60285c1c4b50711b8" translate="yes" xml:space="preserve">
          <source>To automatically link to methods of the currently documented type, use a hash like &lt;code&gt;#horns&lt;/code&gt; or &lt;code&gt;#index(char)&lt;/code&gt;, and enclose it with single backticks.</source>
          <target state="translated">要自动链接到当前记录的类型的方法，请使用 &lt;code&gt;#horns&lt;/code&gt; 或 &lt;code&gt;#index(char)&lt;/code&gt; 之类的哈希，并用单个反引号将其引起来。</target>
        </trans-unit>
        <trans-unit id="1b0c5080015c4d51b4b12f087aef38376e409c4f" translate="yes" xml:space="preserve">
          <source>To automatically link to other types, enclose them with single backticks.</source>
          <target state="translated">要自动链接到其他类型,请用单个背标将它们包围起来。</target>
        </trans-unit>
        <trans-unit id="4c0b6097d8e06f6d4ca904661bd25a30521d1f51" translate="yes" xml:space="preserve">
          <source>To avoid all this boilerplate, the standard library provides a &lt;code&gt;spawn&lt;/code&gt; macro that accepts a call expression and basically rewrites it to do the above. Using it, we end up with:</source>
          <target state="translated">为了避免所有这些样板，标准库提供了一个 &lt;code&gt;spawn&lt;/code&gt; 宏，该宏接受一个调用表达式，并基本上将其重写以完成上述操作。使用它，我们最终得到：</target>
        </trans-unit>
        <trans-unit id="ba2c1ad65898fb4badaeeacba3a01797c503475c" translate="yes" xml:space="preserve">
          <source>To avoid building LLVM from source (which can take a long time), you can first install it from binary packages if you don't have it installed yet:</source>
          <target state="translated">为了避免从源码中构建LLVM(这可能需要很长时间),如果你还没有安装LLVM,可以先从二进制包中安装它。</target>
        </trans-unit>
        <trans-unit id="f7f543192a4e6afdf161421377c7d153c8ec5f89" translate="yes" xml:space="preserve">
          <source>To avoid sql injection use parameters to submit data</source>
          <target state="translated">为了避免sql注入,使用参数来提交数据。</target>
        </trans-unit>
        <trans-unit id="8b6fd1bdb4498ebccf26ab096a8e4ad5d4c1e3fe" translate="yes" xml:space="preserve">
          <source>To avoid this initialization you can use &lt;code&gt;uninitialized&lt;/code&gt;:</source>
          <target state="translated">为了避免这种初始化，您可以使用 &lt;code&gt;uninitialized&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3b407f439ed92707a8a3b7a8453a6a3a14dbcf57" translate="yes" xml:space="preserve">
          <source>To avoid this, command literals should generally not be used with interpolated user input. &lt;a href=&quot;https://crystal-lang.org/api/latest/Process.html&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; from the standard library offers a safe way to provide user input as command arguments:</source>
          <target state="translated">为避免这种情况，命令文字通常不应与插值用户输入一起使用。标准库中的&lt;a href=&quot;https://crystal-lang.org/api/latest/Process.html&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt;提供了一种安全的方式来提供用户输入作为命令参数：</target>
        </trans-unit>
        <trans-unit id="b62a2f24708e08a5a378dfd1f86978c3a1616b1b" translate="yes" xml:space="preserve">
          <source>To capture a block you must specify it as a method's block argument, give it a name and specify the input and output types. For example:</source>
          <target state="translated">要捕获一个块,你必须把它指定为方法的块参数,给它一个名字,并指定输入和输出类型。例如</target>
        </trans-unit>
        <trans-unit id="160feb3e042b4da9fdc2ead43043bf7e99340f12" translate="yes" xml:space="preserve">
          <source>To change how individual instance variables are parsed and serialized, the annotation &lt;code&gt;&lt;a href=&quot;field&quot;&gt;JSON::Field&lt;/a&gt;&lt;/code&gt; can be placed on the instance variable. Annotating property, getter and setter macros is also allowed.</source>
          <target state="translated">要更改单个实例变量的解析和序列化方式，可以将注释 &lt;code&gt;&lt;a href=&quot;field&quot;&gt;JSON::Field&lt;/a&gt;&lt;/code&gt; 放在实例变量上。还允许注释属性，getter和setter宏。</target>
        </trans-unit>
        <trans-unit id="1ee29fe879b2d99217a00125d95417eef2ee23ca" translate="yes" xml:space="preserve">
          <source>To change how individual instance variables are parsed and serialized, the annotation &lt;code&gt;&lt;a href=&quot;field&quot;&gt;YAML::Field&lt;/a&gt;&lt;/code&gt; can be placed on the instance variable. Annotating property, getter and setter macros is also allowed.</source>
          <target state="translated">要更改单个实例变量的解析和序列化方式，可以将注释 &lt;code&gt;&lt;a href=&quot;field&quot;&gt;YAML::Field&lt;/a&gt;&lt;/code&gt; 放在实例变量上。还允许注释属性，getter和setter宏。</target>
        </trans-unit>
        <trans-unit id="a8ab23358f7d8d3dae6e24847de5cb10278825ac" translate="yes" xml:space="preserve">
          <source>To change the background color, the following methods are available:</source>
          <target state="translated">要改变背景颜色,可采用以下方法。</target>
        </trans-unit>
        <trans-unit id="dcf9239dd07dc7a3b710ae0004aa9dd56dd5b6c3" translate="yes" xml:space="preserve">
          <source>To check if your code is formatted correctly, or to check if using the formatter wouldn't produce any changes, simply add &lt;code&gt;--check&lt;/code&gt; to the end of this command.</source>
          <target state="translated">要检查代码的格式是否正确，或使用格式化程序不会产生任何变化，只需在此命令的末尾添加 &lt;code&gt;--check&lt;/code&gt; 即可。</target>
        </trans-unit>
        <trans-unit id="0bd470d9cfaf6bbd3411722b1e8f56b0dd5d4031" translate="yes" xml:space="preserve">
          <source>To compile and run a program in a single shot, invoke &lt;a href=&quot;#crystal-run&quot;&gt;&lt;code&gt;crystal run&lt;/code&gt;&lt;/a&gt; with a single filename:</source>
          <target state="translated">要一次性生成并运行程序，请使用单个文件名调用&lt;a href=&quot;#crystal-run&quot;&gt; &lt;code&gt;crystal run&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="44f2e55e263cca82d33245736b0aa7d4658e8c9f" translate="yes" xml:space="preserve">
          <source>To create CSV data, check &lt;code&gt;&lt;a href=&quot;csv#build(separator:Char=DEFAULT_SEPARATOR,quote_char:Char=DEFAULT_QUOTE_CHAR,quoting:Builder::Quoting=Builder::Quoting::RFC,&amp;amp;block):String-class-method&quot;&gt;CSV#build&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;csv/builder&quot;&gt;CSV::Builder&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">要创建CSV数据，请检查 &lt;code&gt;&lt;a href=&quot;csv#build(separator:Char=DEFAULT_SEPARATOR,quote_char:Char=DEFAULT_QUOTE_CHAR,quoting:Builder::Quoting=Builder::Quoting::RFC,&amp;amp;block):String-class-method&quot;&gt;CSV#build&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;csv/builder&quot;&gt;CSV::Builder&lt;/a&gt;&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="1da599af8bc9b4e0cbb7f31d925a8a7cb6b6a0f3" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with embedded expressions, you can use string interpolation:</source>
          <target state="translated">要创建带有嵌入式表达式的 &lt;code&gt;&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ，可以使用字符串插值：</target>
        </trans-unit>
        <trans-unit id="74bff9cf19307860dba9215ea04d96d1210e0995" translate="yes" xml:space="preserve">
          <source>To create a method that accepts a type name, rather than an instance of a type, append &lt;code&gt;.class&lt;/code&gt; to a free variable in the type restriction:</source>
          <target state="translated">若要创建一个接受类型名称而不是类型实例的方法，请将 &lt;code&gt;.class&lt;/code&gt; 附加到类型限制中的自由变量上：</target>
        </trans-unit>
        <trans-unit id="c822a10e2a69e24f65e61788603a1e03389c38e6" translate="yes" xml:space="preserve">
          <source>To create an empty tuple use &lt;a href=&quot;https://crystal-lang.org/api/Tuple.html#new%28%2Aargs%3A%2AT%29-class-method&quot;&gt;Tuple.new&lt;/a&gt;.</source>
          <target state="translated">要创建一个空的元组，请使用&lt;a href=&quot;https://crystal-lang.org/api/Tuple.html#new%28%2Aargs%3A%2AT%29-class-method&quot;&gt;Tuple.new&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8875b0739c4c85a3fbe08d2001dc0bd7dd888845" translate="yes" xml:space="preserve">
          <source>To create an instance of a struct use &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="translated">要创建结构的实例，请使用 &lt;code&gt;new&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ff87c259e02405c350bf039b75adf461c67217e4" translate="yes" xml:space="preserve">
          <source>To create an instance of a union use &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="translated">要创建一个联合实例，请使用 &lt;code&gt;new&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="350576382e03e71cf1d7dddb1d7d574b2c7d0619" translate="yes" xml:space="preserve">
          <source>To define a custom exception type, just subclass from &lt;a href=&quot;http://crystal-lang.org/api/Exception.html&quot;&gt;Exception&lt;/a&gt;:</source>
          <target state="translated">要定义自定义异常类型，只需从&lt;a href=&quot;http://crystal-lang.org/api/Exception.html&quot;&gt;Exception继承&lt;/a&gt;子类：</target>
        </trans-unit>
        <trans-unit id="99d09b37f33a49d1e11a96eff487e9e19489b722" translate="yes" xml:space="preserve">
          <source>To define a flag, simply use the &lt;code&gt;--define&lt;/code&gt; or &lt;code&gt;-D&lt;/code&gt; option, like so:</source>
          <target state="translated">要定义标志，只需使用 &lt;code&gt;--define&lt;/code&gt; 或 &lt;code&gt;-D&lt;/code&gt; 选项，如下所示：</target>
        </trans-unit>
        <trans-unit id="157c11d641b035bf1f8f85fd5664cf15e55f25af" translate="yes" xml:space="preserve">
          <source>To define a method that receives a block, simply use &lt;code&gt;yield&lt;/code&gt; inside it and the compiler will know. You can make this more evident by declaring a dummy block argument, indicated as a last argument prefixed with ampersand (&lt;code&gt;&amp;amp;&lt;/code&gt;):</source>
          <target state="translated">要定义一个接收块的方法，只需在其中使用 &lt;code&gt;yield&lt;/code&gt; ，编译器就会知道。您可以通过声明一个模型块的说法，表示与符号（前缀最后的说法使这更明显的 &lt;code&gt;&amp;amp;&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="8b22016984dbb7347b880cb3c69445ba7cb4dd72" translate="yes" xml:space="preserve">
          <source>To denote a Proc type you can write:</source>
          <target state="translated">要表示一个Proc类型,你可以写。</target>
        </trans-unit>
        <trans-unit id="7550aab501a1c8caaa7d7d6ad482e4e9849b0dc6" translate="yes" xml:space="preserve">
          <source>To denote a heredoc without interpolation or escapes, the opening heredoc identifier is enclosed in single quotes:</source>
          <target state="translated">为了表示一个没有插值或转义的遗传基因,开头的遗传基因标识符用单引号括起来。</target>
        </trans-unit>
        <trans-unit id="867f43768b0ef892faffb539b98358d23d37336f" translate="yes" xml:space="preserve">
          <source>To denote a named tuple type you can write:</source>
          <target state="translated">为了表示一个命名的元组类型,你可以写。</target>
        </trans-unit>
        <trans-unit id="bfcf8fce49c52dfd01caebb8edf932202a5222a3" translate="yes" xml:space="preserve">
          <source>To denote a tuple type you can write:</source>
          <target state="translated">要表示一个元组类型,你可以写。</target>
        </trans-unit>
        <trans-unit id="874d6e0e60d2b081647b4a3151910755d832a726" translate="yes" xml:space="preserve">
          <source>To easily install Crystal on Mac you can use &lt;a href=&quot;http://brew.sh/&quot;&gt;Homebrew&lt;/a&gt;.</source>
          <target state="translated">要在Mac上轻松安装Crystal，可以使用&lt;a href=&quot;http://brew.sh/&quot;&gt;Homebrew&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a3fa055e9dd3433646539ae53ec5d897352e5be" translate="yes" xml:space="preserve">
          <source>To easily install Crystal on a Linux distribution you can use &lt;a href=&quot;http://linuxbrew.sh/&quot;&gt;Linuxbrew&lt;/a&gt;.</source>
          <target state="translated">要在Linux发行版上轻松安装Crystal，可以使用&lt;a href=&quot;http://linuxbrew.sh/&quot;&gt;Linuxbrew&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c154d82a6009b78a7be6f3cf9c32009f998413fd" translate="yes" xml:space="preserve">
          <source>To easily install Crystal on a Linux distribution you can use &lt;a href=&quot;https://snapcraft.io/crystal&quot;&gt;Snap&lt;/a&gt;. See the &lt;a href=&quot;https://crystal-lang.org/2019/06/19/snapcraft-summit-montreal.html&quot;&gt;blog post&lt;/a&gt; for additional information.</source>
          <target state="translated">要在Linux发行版上轻松安装Crystal，可以使用&lt;a href=&quot;https://snapcraft.io/crystal&quot;&gt;Snap&lt;/a&gt;。有关其他信息，请参见&lt;a href=&quot;https://crystal-lang.org/2019/06/19/snapcraft-summit-montreal.html&quot;&gt;博客文章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="28c3747ada5d17d819f9d3db87e61e5c3e1bcc22" translate="yes" xml:space="preserve">
          <source>To ensure the comparison is also true for local wall clock, both date-times need to be transformed to the same time zone.</source>
          <target state="translated">为了确保本地挂钟的比较也是如此,需要将两个日期时间转换为同一时区。</target>
        </trans-unit>
        <trans-unit id="650afee4ead30a5ced59297b61e986072d1af295" translate="yes" xml:space="preserve">
          <source>To establish certain contexts - think &lt;em&gt;empty array&lt;/em&gt; versus &lt;em&gt;array with elements&lt;/em&gt; - the &lt;code&gt;context&lt;/code&gt; method may be used to communicate this to the reader. It has a different name, but behaves exactly like &lt;code&gt;describe&lt;/code&gt;.</source>
          <target state="translated">要建立某些上下文-考虑&lt;em&gt;空数组&lt;/em&gt;与&lt;em&gt;元素数组&lt;/em&gt; - &lt;code&gt;context&lt;/code&gt; 方法可用于将其传达给读者。它具有不同的名称，但行为与 &lt;code&gt;describe&lt;/code&gt; 完全相同。</target>
        </trans-unit>
        <trans-unit id="a8d04d4c0059669e92d410cfdc7170b492ceca11" translate="yes" xml:space="preserve">
          <source>To execute sql statements you can use &lt;code&gt;Database#exec&lt;/code&gt;</source>
          <target state="translated">要执行sql语句，可以使用 &lt;code&gt;Database#exec&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f3c3d6cbb8ad73ed8673d578519609dac05fb0b" translate="yes" xml:space="preserve">
          <source>To format a single file:</source>
          <target state="translated">要格式化单个文件。</target>
        </trans-unit>
        <trans-unit id="dd173ad1b26365da78f9985ee0d8bc437bbc72e8" translate="yes" xml:space="preserve">
          <source>To format all &lt;code&gt;.cr&lt;/code&gt; files within a directory:</source>
          <target state="translated">要格式化目录中的所有 &lt;code&gt;.cr&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="d47e60f3725574c7685439648f00bc798ba7db18" translate="yes" xml:space="preserve">
          <source>To forward captured blocks, you use a block argument, prefixing an expression with &lt;code&gt;&amp;amp;&lt;/code&gt;:</source>
          <target state="translated">要转发捕获的块，请使用块参数，在表达式前加上 &lt;code&gt;&amp;amp;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ff327c417e5ee0740965ae1df0f9c2cc10df560e" translate="yes" xml:space="preserve">
          <source>To forward non-captured blocks, you must use &lt;code&gt;yield&lt;/code&gt;:</source>
          <target state="translated">要转发未捕获的块，必须使用 &lt;code&gt;yield&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ef3de580f601e1866d1a7c3fc757cd95fea67d7b" translate="yes" xml:space="preserve">
          <source>To generate documentation for a project, invoke &lt;code&gt;crystal docs&lt;/code&gt;. By default this will create a &lt;code&gt;docs&lt;/code&gt; directory, with a &lt;code&gt;docs/index.html&lt;/code&gt; entry point. For more details see &lt;a href=&quot;../using_the_compiler#crystal-docs&quot;&gt;Using the compiler &amp;ndash; Creating documentation&lt;/a&gt;.</source>
          <target state="translated">要生成项目的文档，请调用 &lt;code&gt;crystal docs&lt;/code&gt; 。默认情况下，这将创建一个带有 &lt;code&gt;docs/index.html&lt;/code&gt; 入口点的 &lt;code&gt;docs&lt;/code&gt; 目录。有关更多详细信息，请参见《&lt;a href=&quot;../using_the_compiler#crystal-docs&quot;&gt;使用编译器-创建文档》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="248654c867c4cd2b5e014eb06664ec1f3e491240" translate="yes" xml:space="preserve">
          <source>To get the &lt;code&gt;--target&lt;/code&gt; flags you can execute &lt;code&gt;llvm-config --host-target&lt;/code&gt; using an installed LLVM 3.5. For example on a Linux it could say &quot;x86_64-unknown-linux-gnu&quot;.</source>
          <target state="translated">要获取 &lt;code&gt;--target&lt;/code&gt; 标志，可以使用已安装的LLVM 3.5 执行 &lt;code&gt;llvm-config --host-target&lt;/code&gt; 。例如，在Linux上，它可能会显示&amp;ldquo; x86_64-unknown-linux-gnu&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e1140041b350e878a7ace6222c96112b7b9f8fd1" translate="yes" xml:space="preserve">
          <source>To get the underlying value you invoke &lt;code&gt;value&lt;/code&gt; on it:</source>
          <target state="translated">要获取基础值，请在其上调用 &lt;code&gt;value&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a2ed1097eb466585fe9e191ffed061144745c522" translate="yes" xml:space="preserve">
          <source>To get the underlying value you invoke value on it:</source>
          <target state="translated">要想得到底层的价值,你要对它调用价值。</target>
        </trans-unit>
        <trans-unit id="1f7d011bd62bfc3a881899fea0b04442b2c5f1d9" translate="yes" xml:space="preserve">
          <source>To have something returned, either specify the return type or use an underscore to allow any return type:</source>
          <target state="translated">如果要返回某些东西,要么指定返回类型,要么使用下划线来允许任何返回类型。</target>
        </trans-unit>
        <trans-unit id="cffc6af7d2caf539b014cbd60280db9027e87ed1" translate="yes" xml:space="preserve">
          <source>To implement an &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;Iterator&lt;/a&gt;&lt;/code&gt; you need to define a &lt;code&gt;&lt;a href=&quot;iterator#next-instance-method&quot;&gt;#next&lt;/a&gt;&lt;/code&gt; method that must return the next element in the sequence or &lt;code&gt;&lt;a href=&quot;iterator/stop#INSTANCE&quot;&gt;Iterator::Stop::INSTANCE&lt;/a&gt;&lt;/code&gt;, which signals the end of the sequence (you can invoke &lt;code&gt;&lt;a href=&quot;iterator#stop-instance-method&quot;&gt;#stop&lt;/a&gt;&lt;/code&gt; inside an iterator as a shortcut).</source>
          <target state="translated">要实现 &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;Iterator&lt;/a&gt;&lt;/code&gt; ,您需要定义 &lt;code&gt;&lt;a href=&quot;iterator#next-instance-method&quot;&gt;#next&lt;/a&gt;&lt;/code&gt; 方法，该方法必须返回序列中的下一个元素或 &lt;code&gt;&lt;a href=&quot;iterator/stop#INSTANCE&quot;&gt;Iterator::Stop::INSTANCE&lt;/a&gt;&lt;/code&gt; ，该信号表示序列的结束（您可以在迭代器内部调用 &lt;code&gt;&lt;a href=&quot;iterator#stop-instance-method&quot;&gt;#stop&lt;/a&gt;&lt;/code&gt; 作为快捷方式） 。</target>
        </trans-unit>
        <trans-unit id="f4fe39b7728eb47d6e1caa2547de31807a3cdf50" translate="yes" xml:space="preserve">
          <source>To install from source, download or clone &lt;a href=&quot;https://github.com/crystal-lang/shards&quot;&gt;the repository&lt;/a&gt; and run &lt;code&gt;make CRFLAGS=--release&lt;/code&gt;. The compiled binary is in &lt;code&gt;bin/shards&lt;/code&gt; and should be added to &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">要从源代码安装，请下载或克隆&lt;a href=&quot;https://github.com/crystal-lang/shards&quot;&gt;存储库，&lt;/a&gt;然后运行 &lt;code&gt;make CRFLAGS=--release&lt;/code&gt; 。编译后的二进制文件位于 &lt;code&gt;bin/shards&lt;/code&gt; 中，应添加到 &lt;code&gt;PATH&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="fadaa3d53eae8935a4ae8c1d26caff6cc0eeacdc" translate="yes" xml:space="preserve">
          <source>To invoke a Proc, you invoke the &lt;code&gt;call&lt;/code&gt; method on it. The number of arguments must match the proc's type:</source>
          <target state="translated">要调用Proc，请在其上调用 &lt;code&gt;call&lt;/code&gt; 方法。参数的数量必须与proc的类型匹配：</target>
        </trans-unit>
        <trans-unit id="727bae5340494da603d5e1ee3f857c54bc1e0f53" translate="yes" xml:space="preserve">
          <source>To invoke a method and pass a block, you use &lt;code&gt;do ... end&lt;/code&gt; or &lt;code&gt;{ ... }&lt;/code&gt;. All of these are equivalent:</source>
          <target state="translated">要调用方法并传递块，请使用 &lt;code&gt;do ... end&lt;/code&gt; 或 &lt;code&gt;{ ... }&lt;/code&gt; 。所有这些都是等效的：</target>
        </trans-unit>
        <trans-unit id="c1261081dc0aed6d942e1635fc8e72e85dcb6bfa" translate="yes" xml:space="preserve">
          <source>To iterate a &lt;a href=&quot;https://crystal-lang.org/api/Crystal/Macros/HashLiteral.html&quot;&gt;&lt;code&gt;HashLiteral&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要迭代&lt;a href=&quot;https://crystal-lang.org/api/Crystal/Macros/HashLiteral.html&quot;&gt; &lt;code&gt;HashLiteral&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="b7cdf18a9a50a75deff88f7987d095f62acaf389" translate="yes" xml:space="preserve">
          <source>To iterate an &lt;a href=&quot;https://crystal-lang.org/api/Crystal/Macros/ArrayLiteral.html&quot;&gt;&lt;code&gt;ArrayLiteral&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要迭代&lt;a href=&quot;https://crystal-lang.org/api/Crystal/Macros/ArrayLiteral.html&quot;&gt; &lt;code&gt;ArrayLiteral&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="dcdcd4f5025f01cc6bd68254afdb203a18abe523" translate="yes" xml:space="preserve">
          <source>To load a custom MIME database, &lt;code&gt;&lt;a href=&quot;mime#load_mime_database(io:IO):Nil-class-method&quot;&gt;.load_mime_database&lt;/a&gt;&lt;/code&gt; can be called with an &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; to read the database from.</source>
          <target state="translated">要加载自定义MIME数据库，可以使用 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;mime#load_mime_database(io:IO):Nil-class-method&quot;&gt;.load_mime_database&lt;/a&gt;&lt;/code&gt; 来读取数据库。</target>
        </trans-unit>
        <trans-unit id="a9d586ad9a3f3a11302d206a41a30e2de70ae3f7" translate="yes" xml:space="preserve">
          <source>To make date-time instances exchangeable between different computer systems or readable to humans, they are usually converted to and from a string representation.</source>
          <target state="translated">为了使日期-时间实例能够在不同的计算机系统之间进行交换,或者让人能够读懂,通常会将其转换为字符串表示法,并从字符串表示法中转换出来。</target>
        </trans-unit>
        <trans-unit id="62f08f3614272636ba328403e5b5b95a15d91b34" translate="yes" xml:space="preserve">
          <source>To make it appear in documentation comments</source>
          <target state="translated">要让它出现在文档注释中</target>
        </trans-unit>
        <trans-unit id="a018c8727d46091a749a9a7c72774cc49a12f392" translate="yes" xml:space="preserve">
          <source>To make it more explicit that an &lt;code&gt;Animal&lt;/code&gt; must define a &lt;code&gt;talk&lt;/code&gt; method, we can add it to &lt;code&gt;Animal&lt;/code&gt; as an abstract method:</source>
          <target state="translated">为了更明确地表明 &lt;code&gt;Animal&lt;/code&gt; 必须定义 &lt;code&gt;talk&lt;/code&gt; 方法，我们可以将其作为抽象方法添加到 &lt;code&gt;Animal&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="e838d807157c0c216a557a02e8791944341a904c" translate="yes" xml:space="preserve">
          <source>To make it simpler to use, you can create a symbolic link available in the path:</source>
          <target state="translated">为了简化使用,你可以在路径中创建一个可用的符号链接。</target>
        </trans-unit>
        <trans-unit id="84e56e7d982e727b8efdaec27e50d073b21555a3" translate="yes" xml:space="preserve">
          <source>To make sure that the method returns the type that you want</source>
          <target state="translated">要确保该方法返回的类型是你想要的</target>
        </trans-unit>
        <trans-unit id="e18e86a8ee0876d3e85736a18888d23b54e9ec6b" translate="yes" xml:space="preserve">
          <source>To make the compiler process other files you use &lt;code&gt;require &quot;...&quot;&lt;/code&gt;. It accepts a single argument, a string literal, and it can come in many flavors.</source>
          <target state="translated">要使编译器处理您使用的其他文件， &lt;code&gt;require &quot;...&quot;&lt;/code&gt; 使用&amp;ldquo; ...&amp;rdquo;。它接受单个参数，字符串文字，并且可以有多种形式。</target>
        </trans-unit>
        <trans-unit id="3c490ef83c83d8cde412be2d4b0ce1919c2a8f36" translate="yes" xml:space="preserve">
          <source>To parse a CSV in an efficient way, optionally being able to access row values from header names, create an instance of a &lt;code&gt;&lt;a href=&quot;csv&quot;&gt;CSV&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要以高效的方式解析CSV（可选地能够从标头名称访问行值），请创建 &lt;code&gt;&lt;a href=&quot;csv&quot;&gt;CSV&lt;/a&gt;&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="52203019ab16fe64462b71ebbcafca3fc553e030" translate="yes" xml:space="preserve">
          <source>To parse and get an &lt;code&gt;&lt;a href=&quot;array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt;, use the block-less overload.</source>
          <target state="translated">要解析并获取 &lt;code&gt;&lt;a href=&quot;array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; ，请使用无块重载。</target>
        </trans-unit>
        <trans-unit id="ab29093970d13acb8d97742fb04af5b62b673fae" translate="yes" xml:space="preserve">
          <source>To perform a query and get the result set use &lt;code&gt;Database#query&lt;/code&gt;, arguments can be used as in &lt;code&gt;Database#exec&lt;/code&gt;.</source>
          <target state="translated">要执行查询并使用 &lt;code&gt;Database#query&lt;/code&gt; 获取结果集，可以在 &lt;code&gt;Database#exec&lt;/code&gt; 中使用自变量。</target>
        </trans-unit>
        <trans-unit id="00a19595f306c6540d920f1a69b4294225e2b20c" translate="yes" xml:space="preserve">
          <source>To print a number to the standard output you write:</source>
          <target state="translated">要打印一个数字到标准输出,你要写。</target>
        </trans-unit>
        <trans-unit id="97c76781da7eebfc5ea1337f129276882395075e" translate="yes" xml:space="preserve">
          <source>To properly define a wrapper for this function we must send the &lt;code&gt;&lt;a href=&quot;proc&quot;&gt;Proc&lt;/a&gt;&lt;/code&gt; as the callback data, and then convert that callback data to the &lt;code&gt;&lt;a href=&quot;proc&quot;&gt;Proc&lt;/a&gt;&lt;/code&gt; and finally invoke it.</source>
          <target state="translated">为了正确地为此函数定义包装，我们必须将 &lt;code&gt;&lt;a href=&quot;proc&quot;&gt;Proc&lt;/a&gt;&lt;/code&gt; 发送为回调数据，然后将该回调数据转换为 &lt;code&gt;&lt;a href=&quot;proc&quot;&gt;Proc&lt;/a&gt;&lt;/code&gt; 并最终调用它。</target>
        </trans-unit>
        <trans-unit id="caa9d763bb22b3320770353054692e18f01408eb" translate="yes" xml:space="preserve">
          <source>To properly define a wrapper for this function we must send the Proc as the callback data, and then convert that callback data to the Proc and finally invoke it.</source>
          <target state="translated">为了正确定义这个函数的包装器,我们必须发送Proc作为回调数据,然后将该回调数据转换为Proc,最后调用它。</target>
        </trans-unit>
        <trans-unit id="6f00b4a1fc6440105d7c1a5bd08dc07fc67c647f" translate="yes" xml:space="preserve">
          <source>To read a file relative to where the macro is defined, use:</source>
          <target state="translated">要读取与定义宏的地方相关的文件,使用:</target>
        </trans-unit>
        <trans-unit id="50b99d4c097d2ca1857411e52eccf76e190c65e4" translate="yes" xml:space="preserve">
          <source>To reduce the binary size for distributable files, the &lt;code&gt;--no-debug&lt;/code&gt; flag can be used. This removes debug symbols reducing file size, but obviously making debugging more difficult.</source>
          <target state="translated">为了减小可分发文件的二进制大小，可以使用 &lt;code&gt;--no-debug&lt;/code&gt; 标志。这消除了调试符号，从而减小了文件大小，但显然使调试更加困难。</target>
        </trans-unit>
        <trans-unit id="34c625702ae15f9abda81ae4dc740dd2d4f61545" translate="yes" xml:space="preserve">
          <source>To rescue any exception use a &lt;code&gt;begin ... rescue ... end&lt;/code&gt; expression:</source>
          <target state="translated">要挽救任何异常，请使用 &lt;code&gt;begin ... rescue ... end&lt;/code&gt; 表达式：</target>
        </trans-unit>
        <trans-unit id="38e0d8a6b1edffe2a3499f0ea80fd4de2f3c4b84" translate="yes" xml:space="preserve">
          <source>To rescue just one type of exception (or any of its subclasses):</source>
          <target state="translated">只拯救一种类型的异常(或它的任何子类)。</target>
        </trans-unit>
        <trans-unit id="de1a957059f77f9b151934d63ec30dd084b5a782" translate="yes" xml:space="preserve">
          <source>To see the available options for a particular command, use &lt;code&gt;--help&lt;/code&gt; after a command.</source>
          <target state="translated">要查看特定命令的可用选项，请在命令后使用 &lt;code&gt;--help&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abea0f3f8704b252835992cf74a7b160fd5dca6b" translate="yes" xml:space="preserve">
          <source>To see the available options for a particular command, use &lt;code&gt;--help&lt;/code&gt; after a command:</source>
          <target state="translated">要查看特定命令的可用选项，请在命令后使用 &lt;code&gt;--help&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bc556fd1593f459d4e76eb134a04736eab2ee31d" translate="yes" xml:space="preserve">
          <source>To show the value of an expression inside code blocks, use &lt;code&gt;# =&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">要在代码块内显示表达式的值，请使用 &lt;code&gt;# =&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5197526bb89db50ae33697f518e18c00cd24f7c2" translate="yes" xml:space="preserve">
          <source>To solve this, we can do this:</source>
          <target state="translated">为了解决这个问题,我们可以这样做。</target>
        </trans-unit>
        <trans-unit id="5446868b005c13d5d7b309de1bd1152d9a70bc94" translate="yes" xml:space="preserve">
          <source>To spawn a fiber you use &lt;code&gt;spawn&lt;/code&gt; with a block:</source>
          <target state="translated">要生成光纤，请使用带有块的 &lt;code&gt;spawn&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="da33071868fade85d0fe07f4580a14e41e9a2a15" translate="yes" xml:space="preserve">
          <source>To specify a Proc without arguments:</source>
          <target state="translated">指定一个没有参数的Proc。</target>
        </trans-unit>
        <trans-unit id="afd1c83afd3d5a833f4853a56d5f08a35feb7737" translate="yes" xml:space="preserve">
          <source>To specify multiple arguments:</source>
          <target state="translated">要指定多个参数。</target>
        </trans-unit>
        <trans-unit id="088c3e80b57c909c8767e72f28da62eb02f87994" translate="yes" xml:space="preserve">
          <source>To switch to &lt;code&gt;latest&lt;/code&gt; for quicker updates, create a file &lt;code&gt;/usr/local/etc/pkg/repos/FreeBSD.conf&lt;/code&gt; with the following contents:</source>
          <target state="translated">要切换到 &lt;code&gt;latest&lt;/code&gt; 以进行更快的更新，请创建文件 &lt;code&gt;/usr/local/etc/pkg/repos/FreeBSD.conf&lt;/code&gt; ，其内容如下：</target>
        </trans-unit>
        <trans-unit id="52c20d34160a9b32c0b4c932b0bee8121b1c10f9" translate="yes" xml:space="preserve">
          <source>To test the server, use the curl command below.</source>
          <target state="translated">要测试服务器,请使用下面的curl命令。</target>
        </trans-unit>
        <trans-unit id="09f10fcb8b3a6c3a4fb5c4cea8db86560eaefebe" translate="yes" xml:space="preserve">
          <source>To the extent possible under law, the persons who contributed to this workhave waived</source>
          <target state="translated">在法律允许的范围内,为这项工作做出贡献的人已经放弃了他们的权利。</target>
        </trans-unit>
        <trans-unit id="31217910df272b1f25ece09faa304c39aefdc3a5" translate="yes" xml:space="preserve">
          <source>To this:</source>
          <target state="translated">对此:</target>
        </trans-unit>
        <trans-unit id="fd18bcd9d849c73003b6bfe85fe99d038af363d3" translate="yes" xml:space="preserve">
          <source>To use a module as a partial type you use &lt;code&gt;include&lt;/code&gt; or &lt;code&gt;extend&lt;/code&gt;.</source>
          <target state="translated">要将模块用作部分类型，请使用 &lt;code&gt;include&lt;/code&gt; 或 &lt;code&gt;extend&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3341895f45bd304e9e010d592eace0f802d01add" translate="yes" xml:space="preserve">
          <source>To use a value:</source>
          <target state="translated">要使用一个值。</target>
        </trans-unit>
        <trans-unit id="40d041eb687c5d9c41332d8805009da93eeabd18" translate="yes" xml:space="preserve">
          <source>To use it, include this module in your iterator and make sure that the wrapped iterator is stored in the &lt;code&gt;@iterator&lt;/code&gt; instance variable.</source>
          <target state="translated">要使用它，请将此模块包含在迭代器中，并确保将包装的迭代器存储在 &lt;code&gt;@iterator&lt;/code&gt; 实例变量中。</target>
        </trans-unit>
        <trans-unit id="da553b1420ac33bfd3b0e4ce859b7b021ea74786" translate="yes" xml:space="preserve">
          <source>To use the spec module and DSL, you need to add &lt;code&gt;require &quot;spec&quot;&lt;/code&gt; to your spec files. Many projects use a custom &lt;a href=&quot;#spec-helper&quot;&gt;spec helper&lt;/a&gt; which organizes these includes.</source>
          <target state="translated">要使用规格模块和DSL，您需要在规格文件中添加 &lt;code&gt;require &quot;spec&quot;&lt;/code&gt; 。许多项目使用自定义的&lt;a href=&quot;#spec-helper&quot;&gt;规范帮助器&lt;/a&gt;来组织这些包含项。</target>
        </trans-unit>
        <trans-unit id="1296b2b434113e871db7177e5a43c2f292a8a353" translate="yes" xml:space="preserve">
          <source>To wait for it to finish, invoke &lt;code&gt;&lt;a href=&quot;process#wait:Process::Status-instance-method&quot;&gt;#wait&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要等待它完成，请调用 &lt;code&gt;&lt;a href=&quot;process#wait:Process::Status-instance-method&quot;&gt;#wait&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f177b9ae2819b53c30fb23a3369899b07f15a314" translate="yes" xml:space="preserve">
          <source>To write a chain of if-else-if you use &lt;code&gt;elsif&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;elsif&lt;/code&gt; 编写if-else-if链：</target>
        </trans-unit>
        <trans-unit id="be6716112727391fe917c145b829f2ba915eba9e" translate="yes" xml:space="preserve">
          <source>Together with &lt;code&gt;&lt;a href=&quot;time#day_of_week:Time::DayOfWeek-instance-method&quot;&gt;#day_of_week&lt;/a&gt;&lt;/code&gt; this represents a specific day as commercial or week date format &lt;code&gt;year, week, day_of_week&lt;/code&gt; in the same way as the typical format &lt;code&gt;year, month, day&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;time#week_date(year:Int32,week:Int32,day_of_week:Int32%7CDayOfWeek,hour:Int32=0,minute:Int32=0,second:Int32=0,*,nanosecond:Int32=0,location:Location=Location.local):self-class-method&quot;&gt;.week_date&lt;/a&gt;&lt;/code&gt; creates a &lt;code&gt;&lt;a href=&quot;time&quot;&gt;Time&lt;/a&gt;&lt;/code&gt; instance from a week date.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;time#day_of_week:Time::DayOfWeek-instance-method&quot;&gt;#day_of_week&lt;/a&gt;&lt;/code&gt; 一起，将特定日期表示为商业或星期日期格式的 &lt;code&gt;year, week, day_of_week&lt;/code&gt; ，其方式与典型的格式 &lt;code&gt;year, month, day&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;time#week_date(year:Int32,week:Int32,day_of_week:Int32%7CDayOfWeek,hour:Int32=0,minute:Int32=0,second:Int32=0,*,nanosecond:Int32=0,location:Location=Location.local):self-class-method&quot;&gt;.week_date&lt;/a&gt;&lt;/code&gt; 从一周的日期创建一个 &lt;code&gt;&lt;a href=&quot;time&quot;&gt;Time&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="a1f392b8b5ec3e60f49fefbec4147b99fae2de08" translate="yes" xml:space="preserve">
          <source>Toggles the bit at the given &lt;em&gt;index&lt;/em&gt;.</source>
          <target state="translated">在给定&lt;em&gt;索引&lt;/em&gt;处切换该位。</target>
        </trans-unit>
        <trans-unit id="0245b740561399d7d6391e6c13b4b6c4f785ce9c" translate="yes" xml:space="preserve">
          <source>Toggles the bit at the given &lt;em&gt;index&lt;/em&gt;. A false bit becomes a &lt;code&gt;true&lt;/code&gt; bit, and vice versa. Negative indices can be used to start counting from the end of the array. Raises &lt;code&gt;&lt;a href=&quot;indexerror&quot;&gt;IndexError&lt;/a&gt;&lt;/code&gt; if trying to access a bit outside the array's range.</source>
          <target state="translated">在给定&lt;em&gt;索引&lt;/em&gt;处切换该位。错误的位变为 &lt;code&gt;true&lt;/code&gt; 位，反之亦然。负索引可用于从数组末尾开始计数。如果尝试访问数组范围之外的位，则引发 &lt;code&gt;&lt;a href=&quot;indexerror&quot;&gt;IndexError&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd6413c51a2682c3fc71e1e55728f7a0d5fc6168" translate="yes" xml:space="preserve">
          <source>Token kinds.</source>
          <target state="translated">象征性的孩子。</target>
        </trans-unit>
        <trans-unit id="a8d651139915c982a0b3682ed05931830cbc6c96" translate="yes" xml:space="preserve">
          <source>Token#column_number</source>
          <target state="translated">Token#column_number</target>
        </trans-unit>
        <trans-unit id="8ec5045436899dd388aa1e7fc879c39da59e262b" translate="yes" xml:space="preserve">
          <source>Token#column_number=</source>
          <target state="translated">Token#column_number=</target>
        </trans-unit>
        <trans-unit id="d39b811b08f82972dd235985343deaaa58f35c2b" translate="yes" xml:space="preserve">
          <source>Token#float_value</source>
          <target state="translated">Token#float_value</target>
        </trans-unit>
        <trans-unit id="d342122f36d8b6d8811f0494ad27ff6b590794dd" translate="yes" xml:space="preserve">
          <source>Token#float_value=</source>
          <target state="translated">Token#float_value=</target>
        </trans-unit>
        <trans-unit id="5dee9f081919dd845e1ff2e0f5b8c13a5b48f46e" translate="yes" xml:space="preserve">
          <source>Token#int_value</source>
          <target state="translated">Token#int_value</target>
        </trans-unit>
        <trans-unit id="ec620ba967a2b92b4ee8eff86dda4b0baf4978eb" translate="yes" xml:space="preserve">
          <source>Token#int_value=</source>
          <target state="translated">Token#int_value=</target>
        </trans-unit>
        <trans-unit id="c2e204c23faca8bb6370e1f51ef9203d99341a52" translate="yes" xml:space="preserve">
          <source>Token#kind</source>
          <target state="translated">Token#kind</target>
        </trans-unit>
        <trans-unit id="0544e63aaf05664475d71b90f1a1f71e39da6b17" translate="yes" xml:space="preserve">
          <source>Token#kind=</source>
          <target state="translated">Token#kind=</target>
        </trans-unit>
        <trans-unit id="832350d7582bb9914ec219c2cbf5287e5764dc96" translate="yes" xml:space="preserve">
          <source>Token#line_number</source>
          <target state="translated">Token#line_number</target>
        </trans-unit>
        <trans-unit id="fea18a586a4238217c56f770e6bfcda4223dcecf" translate="yes" xml:space="preserve">
          <source>Token#line_number=</source>
          <target state="translated">Token#line_number=</target>
        </trans-unit>
        <trans-unit id="49955717130865e9b711c81801a573db2917d445" translate="yes" xml:space="preserve">
          <source>Token#raw_value</source>
          <target state="translated">Token#raw_value</target>
        </trans-unit>
        <trans-unit id="6793f0b4c84e3891c93500ae8ef1a128e57724e9" translate="yes" xml:space="preserve">
          <source>Token#raw_value=</source>
          <target state="translated">Token#raw_value=</target>
        </trans-unit>
        <trans-unit id="e5e5b69ff19589f626f983a5dbd4a48b9a076b73" translate="yes" xml:space="preserve">
          <source>Token#string_value</source>
          <target state="translated">Token#string_value</target>
        </trans-unit>
        <trans-unit id="31380e9a9615e0e4947d968c30bf17dfdb3c45cd" translate="yes" xml:space="preserve">
          <source>Token#string_value=</source>
          <target state="translated">Token#string_value=</target>
        </trans-unit>
        <trans-unit id="c29acfefaadea10b896c4e948c662ab0fe3d7fcb" translate="yes" xml:space="preserve">
          <source>Token#to_s</source>
          <target state="translated">Token#to_s</target>
        </trans-unit>
        <trans-unit id="e967866007e83dd722d7f399bb22b3d73b115b29" translate="yes" xml:space="preserve">
          <source>Token#type</source>
          <target state="translated">Token#type</target>
        </trans-unit>
        <trans-unit id="0cca11231e4aae6fdb9208f5155bfe548d1d4c49" translate="yes" xml:space="preserve">
          <source>Token#value</source>
          <target state="translated">Token#value</target>
        </trans-unit>
        <trans-unit id="3e213d1ad9eaf396e0063d04d53364a45e1a7e59" translate="yes" xml:space="preserve">
          <source>Token#value=</source>
          <target state="translated">Token#value=</target>
        </trans-unit>
        <trans-unit id="79aa63524071d6f0f823efe02ddada725d91d487" translate="yes" xml:space="preserve">
          <source>Token.new</source>
          <target state="translated">Token.new</target>
        </trans-unit>
        <trans-unit id="1293bf23ef24e04fa5c2c767e67f480ffa2970c4" translate="yes" xml:space="preserve">
          <source>Token::Kind</source>
          <target state="translated">Token::Kind</target>
        </trans-unit>
        <trans-unit id="8a9df1737e14bed611821c5c6a7bb49e08881c86" translate="yes" xml:space="preserve">
          <source>Token::Kind#begin_array?</source>
          <target state="translated">Token::Kind#begin_array?</target>
        </trans-unit>
        <trans-unit id="8ce0a3ad70273e4cbae5d86b667ce7ddc8e3f912" translate="yes" xml:space="preserve">
          <source>Token::Kind#begin_object?</source>
          <target state="translated">Token::Kind#begin_object?</target>
        </trans-unit>
        <trans-unit id="36ff623509700df57fba8e5f79a74ebad6766755" translate="yes" xml:space="preserve">
          <source>Token::Kind#cell?</source>
          <target state="translated">Token::Kind#cell?</target>
        </trans-unit>
        <trans-unit id="78f78e6b5d965aaeb9a40d049f48a0707a191421" translate="yes" xml:space="preserve">
          <source>Token::Kind#colon?</source>
          <target state="translated">Token::Kind#colon?</target>
        </trans-unit>
        <trans-unit id="d4d08b1ea2df2d60ed242748d9df8edcb9e99501" translate="yes" xml:space="preserve">
          <source>Token::Kind#comma?</source>
          <target state="translated">Token::Kind#comma?</target>
        </trans-unit>
        <trans-unit id="7e1bb779501a45a67fa9a1460f45f7e90cd2b77b" translate="yes" xml:space="preserve">
          <source>Token::Kind#end_array?</source>
          <target state="translated">Token::Kind#end_array?</target>
        </trans-unit>
        <trans-unit id="611fc5ca01384d55e5a020093af3ca146da76c08" translate="yes" xml:space="preserve">
          <source>Token::Kind#end_object?</source>
          <target state="translated">Token::Kind#end_object?</target>
        </trans-unit>
        <trans-unit id="48fb6d2269dabee0fe90e8775be6845c4a6b7355" translate="yes" xml:space="preserve">
          <source>Token::Kind#eof?</source>
          <target state="translated">Token::Kind#eof?</target>
        </trans-unit>
        <trans-unit id="944db045166ec019417239fd43bd95e283c65f21" translate="yes" xml:space="preserve">
          <source>Token::Kind#false?</source>
          <target state="translated">Token::Kind#false?</target>
        </trans-unit>
        <trans-unit id="9f4155fa8527f8bec9397f598cd6f3602ab3051b" translate="yes" xml:space="preserve">
          <source>Token::Kind#float?</source>
          <target state="translated">Token::Kind#float?</target>
        </trans-unit>
        <trans-unit id="a0aa0b867edf8dca2daf05da4e43e50effc68dcc" translate="yes" xml:space="preserve">
          <source>Token::Kind#int?</source>
          <target state="translated">Token::Kind#int?</target>
        </trans-unit>
        <trans-unit id="a3e39dcfc2c8a5ef00385dc40b681e4c0df8ffb7" translate="yes" xml:space="preserve">
          <source>Token::Kind#newline?</source>
          <target state="translated">Token::Kind#newline?</target>
        </trans-unit>
        <trans-unit id="87efb5ddec5fd77d8624c7853b00a2c6f45d8a15" translate="yes" xml:space="preserve">
          <source>Token::Kind#null?</source>
          <target state="translated">Token::Kind#null?</target>
        </trans-unit>
        <trans-unit id="6b8ce8d201ded9e6586fdf708d3db90aceeb0a73" translate="yes" xml:space="preserve">
          <source>Token::Kind#string?</source>
          <target state="translated">Token::Kind#string?</target>
        </trans-unit>
        <trans-unit id="84814a93b8737ad0c89eb3a7316f096f83cdc6f9" translate="yes" xml:space="preserve">
          <source>Token::Kind#true?</source>
          <target state="translated">Token::Kind#true?</target>
        </trans-unit>
        <trans-unit id="ac1a3f17be132231992609f745b8e71046a0d818" translate="yes" xml:space="preserve">
          <source>Too many levels of remote in path</source>
          <target state="translated">路径中的远程级别太多</target>
        </trans-unit>
        <trans-unit id="2e0d2eef3cc8719301cd02a8aeecb9e956e88cf1" translate="yes" xml:space="preserve">
          <source>Too many levels of symbolic links</source>
          <target state="translated">象征性联系层次太多</target>
        </trans-unit>
        <trans-unit id="4113b4c9ebd053469430304ab17dc16ea1d01df9" translate="yes" xml:space="preserve">
          <source>Too many links</source>
          <target state="translated">链接太多</target>
        </trans-unit>
        <trans-unit id="c8452b0c049e050b8a8d8e298315154b410bb14f" translate="yes" xml:space="preserve">
          <source>Too many open files</source>
          <target state="translated">打开的文件太多</target>
        </trans-unit>
        <trans-unit id="417e34e2aa5093ac47926281cd6f8fd908eaf673" translate="yes" xml:space="preserve">
          <source>Too many open files in system</source>
          <target state="translated">系统中打开的文件太多</target>
        </trans-unit>
        <trans-unit id="282e2b703da2ac14021b09f04b30fd7f814e033a" translate="yes" xml:space="preserve">
          <source>Too many references: can't splice</source>
          <target state="translated">参考文献太多:无法拼接</target>
        </trans-unit>
        <trans-unit id="21b53b1f02559d44a4e57d2971766159ebf6282f" translate="yes" xml:space="preserve">
          <source>Too many users</source>
          <target state="translated">用户太多</target>
        </trans-unit>
        <trans-unit id="7385935aabe6125e8b99fb2e65fcc07ed1c1c515" translate="yes" xml:space="preserve">
          <source>Top Level Namespace</source>
          <target state="translated">顶级命名空间</target>
        </trans-unit>
        <trans-unit id="ccdd98e2a34ced0a55822961d427463b5d0f93a8" translate="yes" xml:space="preserve">
          <source>Total time, that is utime + stime + cutime + cstime</source>
          <target state="translated">总时间,即utime+stime+cutime+cstime。</target>
        </trans-unit>
        <trans-unit id="0218a80c98589360ba5ac7757f0c2883080fe242" translate="yes" xml:space="preserve">
          <source>Trailing zeros are omitted if &lt;em&gt;only_significant&lt;/em&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果&lt;em&gt;only_significant&lt;/em&gt;为 &lt;code&gt;true&lt;/code&gt; ,则省略尾随零。</target>
        </trans-unit>
        <trans-unit id="1e3281a962e6db2e54e787f796eb7d2b1582389a" translate="yes" xml:space="preserve">
          <source>Transactions</source>
          <target state="translated">Transactions</target>
        </trans-unit>
        <trans-unit id="abc6595069886ccbf51180b5b603a92ea6e60ef9" translate="yes" xml:space="preserve">
          <source>Traverses the depth of a structure and returns the value, otherwise raises &lt;code&gt;&lt;a href=&quot;indexerror&quot;&gt;IndexError&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">遍历结构的深度并返回值，否则引发 &lt;code&gt;&lt;a href=&quot;indexerror&quot;&gt;IndexError&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac1f2a14f5e91615fd0eb5a0fdbb66aebab6f9e2" translate="yes" xml:space="preserve">
          <source>Traverses the depth of a structure and returns the value, otherwise raises &lt;code&gt;&lt;a href=&quot;keyerror&quot;&gt;KeyError&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">遍历结构的深度并返回值，否则引发 &lt;code&gt;&lt;a href=&quot;keyerror&quot;&gt;KeyError&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bde3d3267a22901990828c6eb889c56e903a986" translate="yes" xml:space="preserve">
          <source>Traverses the depth of a structure and returns the value, otherwise raises.</source>
          <target state="translated">遍历结构的深度并返回值,否则引发。</target>
        </trans-unit>
        <trans-unit id="b29414c314b430b56df8b5984d8c9c5cdd23e9d5" translate="yes" xml:space="preserve">
          <source>Traverses the depth of a structure and returns the value.</source>
          <target state="translated">遍历结构的深度并返回值。</target>
        </trans-unit>
        <trans-unit id="919d796f73d780d626472e9c1f88248da0e0fb1a" translate="yes" xml:space="preserve">
          <source>Traverses the depth of a structure and returns the value. Returns &lt;code&gt;nil&lt;/code&gt; if not found.</source>
          <target state="translated">遍历结构的深度并返回值。如果找不到，则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b99042b44e7391a6b0defadada50f0b6201bdf41" translate="yes" xml:space="preserve">
          <source>Travis CI and &lt;code&gt;.travis.yml&lt;/code&gt;</source>
          <target state="translated">Travis CI和 &lt;code&gt;.travis.yml&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd87295302bd319fadfea95972e799cb48e9c4f4" translate="yes" xml:space="preserve">
          <source>Tries to bind the socket to a local address.</source>
          <target state="translated">试图将套接字绑定到本地地址。</target>
        </trans-unit>
        <trans-unit id="0981beef07505f2072a89247290b8739810c1570" translate="yes" xml:space="preserve">
          <source>Tries to bind the socket to a local address. Yields an &lt;code&gt;&lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; if the binding failed.</source>
          <target state="translated">尝试将套接字绑定到本地地址。如果绑定失败，则产生 &lt;code&gt;&lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72b484638c124da821744ff789b992b29ca5f03a" translate="yes" xml:space="preserve">
          <source>Tries to change the size of the allocation pointed to by this pointer to &lt;em&gt;size&lt;/em&gt;, and returns that pointer.</source>
          <target state="translated">尝试将此指针指向的分配大小更改为&lt;em&gt;size&lt;/em&gt;，并返回该指针。</target>
        </trans-unit>
        <trans-unit id="955e90eb1946abc8ec8e6910b54428fab53277a7" translate="yes" xml:space="preserve">
          <source>Tries to connect to a remote address.</source>
          <target state="translated">试图连接到一个远程地址。</target>
        </trans-unit>
        <trans-unit id="bef0ffffe0b0091e0b43d0413ff4ec3a598b1437" translate="yes" xml:space="preserve">
          <source>Tries to connect to a remote address. Yields an &lt;code&gt;&lt;a href=&quot;io/timeout&quot;&gt;IO::Timeout&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; error if the connection failed.</source>
          <target state="translated">尝试连接到远程地址。如果连接失败，则产生 &lt;code&gt;&lt;a href=&quot;io/timeout&quot;&gt;IO::Timeout&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="0946d1944e1c285d81afe9e6edee621bdffab9f7" translate="yes" xml:space="preserve">
          <source>Tries to listen for connections on the previously bound socket.</source>
          <target state="translated">尝试监听之前绑定的socket上的连接。</target>
        </trans-unit>
        <trans-unit id="31766155333d92de24fe197f8192ac22523d0b9d" translate="yes" xml:space="preserve">
          <source>Tries to listen for connections on the previously bound socket. Yields an &lt;code&gt;&lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">尝试侦听先前绑定的套接字上的连接。失败时产生 &lt;code&gt;&lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2e37e1047d1d8a1b1b55bcb1fcf3ec93787cdb7" translate="yes" xml:space="preserve">
          <source>Tries to match with &lt;em&gt;pattern&lt;/em&gt; at the current position.</source>
          <target state="translated">尝试与当前位置的&lt;em&gt;图案&lt;/em&gt;匹配。</target>
        </trans-unit>
        <trans-unit id="54b8fe310750b609ca9e3c5b4e6346314f885b3a" translate="yes" xml:space="preserve">
          <source>Tries to match with &lt;em&gt;pattern&lt;/em&gt; at the current position. If there's a match, the scanner advances the scan offset, the last match is saved, and it returns the matched string. Otherwise, the scanner returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">尝试与当前位置的&lt;em&gt;图案&lt;/em&gt;匹配。如果存在匹配项，则扫描程序将前进扫描偏移，保存最后一个匹配项，然后返回匹配的字符串。否则，扫描仪将返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc6b47ae6c8fba7e495458bb9a710f09bf601b13" translate="yes" xml:space="preserve">
          <source>Tries to read an alias from &lt;code&gt;node&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">尝试从类型为 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;node&lt;/code&gt; 读取别名。</target>
        </trans-unit>
        <trans-unit id="8104be14d56f1684daf010c1e14f98828123c3e8" translate="yes" xml:space="preserve">
          <source>Tries to read an alias from &lt;code&gt;node&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;. Invokes the block if successful, and invokers must return this object instead of deserializing their members.</source>
          <target state="translated">尝试从类型为 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;node&lt;/code&gt; 读取别名。如果成功，则调用该块，并且调用者必须返回此对象，而不是反序列化其成员。</target>
        </trans-unit>
        <trans-unit id="2af896f5cde03437fc5713b172787926b02c255a" translate="yes" xml:space="preserve">
          <source>Tries to read exactly &lt;code&gt;slice.size&lt;/code&gt; bytes from this &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; into &lt;em&gt;slice&lt;/em&gt;.</source>
          <target state="translated">尝试从此 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 精确地读取 &lt;code&gt;slice.size&lt;/code&gt; 字节到&lt;em&gt;slice中&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5695559484bdf04eeceac7f24deb4afc4dfae30" translate="yes" xml:space="preserve">
          <source>Tries to read exactly &lt;code&gt;slice.size&lt;/code&gt; bytes from this &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; into &lt;em&gt;slice&lt;/em&gt;. Raises &lt;code&gt;&lt;a href=&quot;io/eoferror&quot;&gt;EOFError&lt;/a&gt;&lt;/code&gt; if there aren't &lt;code&gt;slice.size&lt;/code&gt; bytes of data.</source>
          <target state="translated">尝试从此 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 精确地读取 &lt;code&gt;slice.size&lt;/code&gt; 字节到&lt;em&gt;slice中&lt;/em&gt;。如果没有 &lt;code&gt;slice.size&lt;/code&gt; 字节的数据，则引发 &lt;code&gt;&lt;a href=&quot;io/eoferror&quot;&gt;EOFError&lt;/a&gt;&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6af2e3fab3d8a40c85b9f4b178ed9ac4f04fcef9" translate="yes" xml:space="preserve">
          <source>Tries to read exactly &lt;code&gt;slice.size&lt;/code&gt; bytes from this &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; into &lt;em&gt;slice&lt;/em&gt;. Returns &lt;code&gt;nil&lt;/code&gt; if there aren't &lt;code&gt;slice.size&lt;/code&gt; bytes of data, otherwise returns the number of bytes read.</source>
          <target state="translated">尝试从此 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 精确地读取 &lt;code&gt;slice.size&lt;/code&gt; 字节到&lt;em&gt;slice中&lt;/em&gt;。如果没有 &lt;code&gt;slice.size&lt;/code&gt; 字节的数据，则返回 &lt;code&gt;nil&lt;/code&gt; ，否则返回读取的字节数。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5f219c8374282246576fd543ea2493462bf75487" translate="yes" xml:space="preserve">
          <source>Troubleshooting on OSX 10.11 (El Capitan)</source>
          <target state="translated">OSX 10.11 (El Capitan)上的故障排除</target>
        </trans-unit>
        <trans-unit id="5ce60aa4eff6f7e98c3b9dd356b516b45ccf87b3" translate="yes" xml:space="preserve">
          <source>Troubleshooting on macOS MacOS 10.14.2 (Mojave)</source>
          <target state="translated">MacOS上的故障排除 MacOS 10.14.2 (Mojave)</target>
        </trans-unit>
        <trans-unit id="062c0166b43a14d41e7d7ea05d1bb211a724ea70" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;&lt;a href=&quot;parser#next(&amp;amp;block)-instance-method&quot;&gt;#next&lt;/a&gt;&lt;/code&gt; can be called legally.</source>
          <target state="translated">如果可以合法调用 &lt;code&gt;&lt;a href=&quot;parser#next(&amp;amp;block)-instance-method&quot;&gt;#next&lt;/a&gt;&lt;/code&gt; ,则为 true 。</target>
        </trans-unit>
        <trans-unit id="eb0801f86a19c09e96d299a0a32aec772dca2a57" translate="yes" xml:space="preserve">
          <source>Truncates the file to the specified &lt;em&gt;size&lt;/em&gt;.</source>
          <target state="translated">将文件截断为指定的&lt;em&gt;大小&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d21319b8bd458e65141b69abff82047b9dc40ed9" translate="yes" xml:space="preserve">
          <source>Truncates the file to the specified &lt;em&gt;size&lt;/em&gt;. Requires that the current file is opened for writing.</source>
          <target state="translated">将文件截断为指定的&lt;em&gt;大小&lt;/em&gt;。要求打开当前文件进行写入。</target>
        </trans-unit>
        <trans-unit id="9a02428b2ce5edfe4a952ba3e66ede7b538c678d" translate="yes" xml:space="preserve">
          <source>Truthiness</source>
          <target state="translated">Truthiness</target>
        </trans-unit>
        <trans-unit id="9480a08d6217458ab374f2324a5b3788014da2b6" translate="yes" xml:space="preserve">
          <source>Truthy and falsey values</source>
          <target state="translated">真值和假值</target>
        </trans-unit>
        <trans-unit id="c4296d5cacea78b4c8d0f3b89f49546d745186f0" translate="yes" xml:space="preserve">
          <source>Try it online</source>
          <target state="translated">在线试用</target>
        </trans-unit>
        <trans-unit id="493fdce7827dfed273a7f0d0d7fb441956465d2f" translate="yes" xml:space="preserve">
          <source>Try to avoid forwarding blocks like this if doing &lt;code&gt;yield&lt;/code&gt; is enough. There's also the issue that &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; are not allowed inside captured blocks, so the following won't work when using &lt;code&gt;&amp;amp;block&lt;/code&gt; forwarding:</source>
          <target state="translated">尽量避免这样的转发块，如果这样做 &lt;code&gt;yield&lt;/code&gt; 是足够的。还有一个问题是捕获的块中不允许使用 &lt;code&gt;break&lt;/code&gt; 和 &lt;code&gt;next&lt;/code&gt; ，因此在使用 &lt;code&gt;&amp;amp;block&lt;/code&gt; 转发时，以下内容将不起作用：</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="3dd77eb7db4e2b6c2fbbe4e0e8a616d7b0a5ae20" translate="yes" xml:space="preserve">
          <source>Tuple literal</source>
          <target state="translated">元组字面意义</target>
        </trans-unit>
        <trans-unit id="db9abbfa9874c87894f52363a3e038037ad7adbd" translate="yes" xml:space="preserve">
          <source>Tuple size must match</source>
          <target state="translated">元组大小必须匹配</target>
        </trans-unit>
        <trans-unit id="7e121f1048042d1a96fccaa4fe2d50ee9a8665eb" translate="yes" xml:space="preserve">
          <source>Tuple#+</source>
          <target state="translated">Tuple#+</target>
        </trans-unit>
        <trans-unit id="4dbbb7699bad75b09c2fadadbe5570c137946469" translate="yes" xml:space="preserve">
          <source>Tuple#==</source>
          <target state="translated">Tuple#==</target>
        </trans-unit>
        <trans-unit id="11b9ffdb90e63ff6f2e9744eef22e66bba768efd" translate="yes" xml:space="preserve">
          <source>Tuple#===</source>
          <target state="translated">Tuple#===</target>
        </trans-unit>
        <trans-unit id="ea768c8efdd3f71495f04a1c761b8b56486a90d1" translate="yes" xml:space="preserve">
          <source>Tuple#[]</source>
          <target state="translated">Tuple#[]</target>
        </trans-unit>
        <trans-unit id="a4522ece5a6415a9975adbc298e4a74be1b677a7" translate="yes" xml:space="preserve">
          <source>Tuple#[]?</source>
          <target state="translated">Tuple#[]?</target>
        </trans-unit>
        <trans-unit id="242aa7b9ad4c8ff55374671ae9984c024260bc86" translate="yes" xml:space="preserve">
          <source>Tuple#at</source>
          <target state="translated">Tuple#at</target>
        </trans-unit>
        <trans-unit id="11dfb4dab4cfe91139e8c54a0f9d0ebb57cadadb" translate="yes" xml:space="preserve">
          <source>Tuple#each</source>
          <target state="translated">Tuple#each</target>
        </trans-unit>
        <trans-unit id="c7b0589ac4e743c12fff663133183ae3f2b33363" translate="yes" xml:space="preserve">
          <source>Tuple#from</source>
          <target state="translated">Tuple#from</target>
        </trans-unit>
        <trans-unit id="04d72b5792e6acf797636fc4c4c0fb48071de52c" translate="yes" xml:space="preserve">
          <source>Tuple#hash</source>
          <target state="translated">Tuple#hash</target>
        </trans-unit>
        <trans-unit id="6bdcdb980b4f1ec68299341a00f82d17d4543250" translate="yes" xml:space="preserve">
          <source>Tuple#last</source>
          <target state="translated">Tuple#last</target>
        </trans-unit>
        <trans-unit id="3c6c591502c8fc3b6e0b18c287fc10e0fbf87d80" translate="yes" xml:space="preserve">
          <source>Tuple#map</source>
          <target state="translated">Tuple#map</target>
        </trans-unit>
        <trans-unit id="043f4a2ff148b3d5d81c2873726a2cb03605e2f0" translate="yes" xml:space="preserve">
          <source>Tuple#size</source>
          <target state="translated">Tuple#size</target>
        </trans-unit>
        <trans-unit id="1df72674265b898aa356dd01f3fe6c8f8eecb24e" translate="yes" xml:space="preserve">
          <source>Tuple#to_s</source>
          <target state="translated">Tuple#to_s</target>
        </trans-unit>
        <trans-unit id="952642d60d65e618402230ff206e167721f597b6" translate="yes" xml:space="preserve">
          <source>Tuple(*T)</source>
          <target state="translated">Tuple(*T)</target>
        </trans-unit>
        <trans-unit id="0bf27f3a7ca88db55038cac28704db2b3d46ff68" translate="yes" xml:space="preserve">
          <source>Tuple.from</source>
          <target state="translated">Tuple.from</target>
        </trans-unit>
        <trans-unit id="871e8e63a55124c0309905c36f2f7e94eb4e5556" translate="yes" xml:space="preserve">
          <source>Tuple.new</source>
          <target state="translated">Tuple.new</target>
        </trans-unit>
        <trans-unit id="9575fdc0215d60cb07b09ea99d99076ed5b7306c" translate="yes" xml:space="preserve">
          <source>Tuples are compared in an &quot;element-wise&quot; manner; the first element of this tuple is compared with the first one of &lt;em&gt;other&lt;/em&gt; using the &lt;code&gt;&lt;a href=&quot;tuple#(other:self)-instance-method&quot;&gt;#&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt; operator, then each of the second elements, etc. As soon as the result of any such comparison is non-zero (i.e. the two corresponding elements are not equal), that result is returned for the whole tuple comparison.</source>
          <target state="translated">元组以&amp;ldquo;元素方式&amp;rdquo;进行比较；使用 &lt;code&gt;&lt;a href=&quot;tuple#(other:self)-instance-method&quot;&gt;#&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt; 运算符将该元组的第一个元素与&lt;em&gt;其他&lt;/em&gt;第一个元素进行比较，然后将每个第二个元素进行比较，依此类推。一旦任何这样的比较结果为非零（即两个对应的元素）不相等），则返回整个元组比较的结果。</target>
        </trans-unit>
        <trans-unit id="cf672de1711f2dfd015bbd3877cf41ea33bbd2ea" translate="yes" xml:space="preserve">
          <source>Tuples are the preferred way to return fixed-size multiple return values because no memory is needed to be allocated for them:</source>
          <target state="translated">Tuples是返回固定大小的多个返回值的首选方式,因为不需要为它们分配内存。</target>
        </trans-unit>
        <trans-unit id="933c70e539f645b538d4356ea7b605cfee182be9" translate="yes" xml:space="preserve">
          <source>Tuples can be splat with the &lt;code&gt;*&lt;/code&gt; operator and passed to methods:</source>
          <target state="translated">可以使用 &lt;code&gt;*&lt;/code&gt; 运算符对元组进行splat 并传递给方法：</target>
        </trans-unit>
        <trans-unit id="c1f595179e349661fb79cbb4cf94ec823bdbfaa3" translate="yes" xml:space="preserve">
          <source>Turns a &lt;code&gt;&lt;a href=&quot;../time&quot;&gt;Time&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;../time&quot;&gt;Time&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c6e0a7be2cb0ef1bd0a963510462d526ef35501" translate="yes" xml:space="preserve">
          <source>Turns off character echoing for the duration of the given block.</source>
          <target state="translated">在给定块的持续时间内关闭字符回声。</target>
        </trans-unit>
        <trans-unit id="216ea237154843e21e52841fd4bc23bb771f70c9" translate="yes" xml:space="preserve">
          <source>Turns off character echoing for the duration of the given block. This will prevent displaying back to the user what they enter on the terminal. Only call this when this IO is a TTY, such as a not redirected stdin.</source>
          <target state="translated">在给定块的持续时间内关闭字符回声。这将防止向用户显示他们在终端上输入的内容。只有当这个IO是TTY时才调用这个功能,比如一个没有重定向的stdin。</target>
        </trans-unit>
        <trans-unit id="393b49c50cc37cc6a39bd3964ceb6fd97c1c42cc" translate="yes" xml:space="preserve">
          <source>Turns off character echoing for this IO.</source>
          <target state="translated">关闭该IO的字符回声。</target>
        </trans-unit>
        <trans-unit id="0f8c597f259581297aca0072d96839a06378417c" translate="yes" xml:space="preserve">
          <source>Turns off character echoing for this IO. This will prevent displaying back to the user what they enter on the terminal. Only call this when this IO is a TTY, such as a not redirected stdin.</source>
          <target state="translated">关闭该IO的字符回声。这将防止向用户显示他们在终端上输入的内容。只有当该IO是TTY时才调用该功能,例如没有重定向的stdin。</target>
        </trans-unit>
        <trans-unit id="a333876aff8c45250c080ef5d29f574b6989e0b4" translate="yes" xml:space="preserve">
          <source>Turns on/off &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;&lt;strong&gt;read&lt;/strong&gt; buffering.</source>
          <target state="translated">打开/关闭 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; &lt;strong&gt;读取&lt;/strong&gt;缓冲。</target>
        </trans-unit>
        <trans-unit id="be9064b724b5047e939d11455e515b0a0ca78909" translate="yes" xml:space="preserve">
          <source>Turns on/off &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;&lt;strong&gt;write&lt;/strong&gt; buffering.</source>
          <target state="translated">打开/关闭 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; &lt;strong&gt;写&lt;/strong&gt;缓冲。</target>
        </trans-unit>
        <trans-unit id="37a912c3c738189757687174aacd1bd8f9d166d6" translate="yes" xml:space="preserve">
          <source>Turns on/off &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;&lt;strong&gt;write&lt;/strong&gt; buffering. When &lt;em&gt;sync&lt;/em&gt; is set to &lt;code&gt;true&lt;/code&gt;, no buffering will be done (that is, writing to this &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; is immediately synced to the underlying &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">打开/关闭 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; &lt;strong&gt;写&lt;/strong&gt;缓冲。当&lt;em&gt;sync&lt;/em&gt;设置为 &lt;code&gt;true&lt;/code&gt; 时，将不执行任何缓冲（即，对该 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 的写入将立即同步到基础 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="02a38d28e568d7f9b05820f44ead1b6bd270d5c9" translate="yes" xml:space="preserve">
          <source>Two headers are considered the same if their downcase representation is the same (in which &lt;code&gt;_&lt;/code&gt; is the downcase version of &lt;code&gt;-&lt;/code&gt;).</source>
          <target state="translated">两个标题被认为是相同的，如果他们的downcase表示是相同的（其中 &lt;code&gt;_&lt;/code&gt; 是的downcase版本 &lt;code&gt;-&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b0ab4d96d611346f0089f77a1daac7ace3bf7f25" translate="yes" xml:space="preserve">
          <source>Two instances are considered equal if they represent the same date-time in the instant time-line, even if they show a different local date-time.</source>
          <target state="translated">如果两个实例在即时时间线中代表相同的日期时间,即使它们显示不同的本地日期时间,也被认为是相等的。</target>
        </trans-unit>
        <trans-unit id="d43d937c7710777e97a5a53154be9fcccb8a1e90" translate="yes" xml:space="preserve">
          <source>Two methods with different required named arguments overload between each other:</source>
          <target state="translated">两个具有不同所需命名参数的方法之间相互重载。</target>
        </trans-unit>
        <trans-unit id="6ae191baa42a93c903e6c345c921dddfd326f8c7" translate="yes" xml:space="preserve">
          <source>Two methods, one that yields and another that doesn't, are considered different overloads, as explained in the &lt;a href=&quot;overloading&quot;&gt;overloading&lt;/a&gt; section.</source>
          <target state="translated">如&lt;a href=&quot;overloading&quot;&gt;重载&lt;/a&gt;部分所述，两种方法（一种会产生结果，另一种不会产生结果）被视为不同的重载。</target>
        </trans-unit>
        <trans-unit id="53eb8996b68f6ada92981bfe8955de0b65edfbd4" translate="yes" xml:space="preserve">
          <source>Two types are provided to read from zip files:</source>
          <target state="translated">提供了两种类型的压缩文件读取方式。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="3d007038ca42c28b38d85162af3678fda3d64700" translate="yes" xml:space="preserve">
          <source>Type Grammar</source>
          <target state="translated">语法类型</target>
        </trans-unit>
        <trans-unit id="25fb34e0226e23d09fbc35edffc871595228758d" translate="yes" xml:space="preserve">
          <source>Type Reflection</source>
          <target state="translated">反射类型</target>
        </trans-unit>
        <trans-unit id="f4fd140aa1ac5809b6e0e0e2158e77d4f7bbf5e8" translate="yes" xml:space="preserve">
          <source>Type grammar</source>
          <target state="translated">语法类型</target>
        </trans-unit>
        <trans-unit id="4635ff32ceb845d41fbb05ef04eddaf92ee315d6" translate="yes" xml:space="preserve">
          <source>Type inference</source>
          <target state="translated">类型推理</target>
        </trans-unit>
        <trans-unit id="6dce0107ce06419ab2948b0df54410a6ad499cd9" translate="yes" xml:space="preserve">
          <source>Type information</source>
          <target state="translated">类型信息</target>
        </trans-unit>
        <trans-unit id="ea5ff39fc9723d3ce261f7386588e613b8a1f158" translate="yes" xml:space="preserve">
          <source>Type of closured variables</source>
          <target state="translated">封闭式变量的类型</target>
        </trans-unit>
        <trans-unit id="5d4a8336b9549dcb9cabf0fa086cb349797de79b" translate="yes" xml:space="preserve">
          <source>Type reflection</source>
          <target state="translated">反映类型</target>
        </trans-unit>
        <trans-unit id="d6a3d1365f965efa1ad264795b271bcb2fd8682a" translate="yes" xml:space="preserve">
          <source>Type restrictions</source>
          <target state="translated">类型限制</target>
        </trans-unit>
        <trans-unit id="d2027c772c97a36b7177f0e8feae3afa1be467b7" translate="yes" xml:space="preserve">
          <source>Type restrictions are applied to method arguments to restrict the types accepted by that method.</source>
          <target state="translated">类型限制被应用于方法参数,以限制该方法接受的类型。</target>
        </trans-unit>
        <trans-unit id="fefe434d86fff3c36b26ec6e0643570f06e96ee8" translate="yes" xml:space="preserve">
          <source>Type restrictions in a generic type's constructor are free variables when type arguments were not specified, and then are used to infer them. For example:</source>
          <target state="translated">通用类型的构造函数中的类型限制是在没有指定类型参数时的自由变量,然后用来推断它们。例如</target>
        </trans-unit>
        <trans-unit id="1edd4e3e5132b8f114b3a94c66baa6eb135b060d" translate="yes" xml:space="preserve">
          <source>Type restrictions in splats</source>
          <target state="translated">溅射中的类型限制</target>
        </trans-unit>
        <trans-unit id="839562c72eef764245b7aaa688de9fb42e81d7aa" translate="yes" xml:space="preserve">
          <source>Type variables inference</source>
          <target state="translated">类型变量推断</target>
        </trans-unit>
        <trans-unit id="90ca08511d69bcb8b33c55b9371f837b0597fb34" translate="yes" xml:space="preserve">
          <source>Type#array</source>
          <target state="translated">Type#array</target>
        </trans-unit>
        <trans-unit id="f6687aa75438cee7790b91d71f73cd03f5102244" translate="yes" xml:space="preserve">
          <source>Type#array_size</source>
          <target state="translated">Type#array_size</target>
        </trans-unit>
        <trans-unit id="20ed7771514810cca5c909077339d40910df6831" translate="yes" xml:space="preserve">
          <source>Type#block_device?</source>
          <target state="translated">Type#block_device?</target>
        </trans-unit>
        <trans-unit id="ff22c66e5764a8599274261fcecfaca04db2d0fb" translate="yes" xml:space="preserve">
          <source>Type#character_device?</source>
          <target state="translated">Type#character_device?</target>
        </trans-unit>
        <trans-unit id="589662eda2d664a797fe159f855b34c76b7d1084" translate="yes" xml:space="preserve">
          <source>Type#const_array</source>
          <target state="translated">Type#const_array</target>
        </trans-unit>
        <trans-unit id="1385ff3fad5b3030802df193bc16378b87143cb0" translate="yes" xml:space="preserve">
          <source>Type#const_double</source>
          <target state="translated">Type#const_double</target>
        </trans-unit>
        <trans-unit id="e6169b8f4ea178ea983cf1459e6ac9eb52320344" translate="yes" xml:space="preserve">
          <source>Type#const_float</source>
          <target state="translated">Type#const_float</target>
        </trans-unit>
        <trans-unit id="24e92f5c3dc1ea04ea5bf8219162781b23bfff78" translate="yes" xml:space="preserve">
          <source>Type#const_inline_asm</source>
          <target state="translated">Type#const_inline_asm</target>
        </trans-unit>
        <trans-unit id="fcb573168de52a95f28bd41dda6b42a03aaee889" translate="yes" xml:space="preserve">
          <source>Type#const_int</source>
          <target state="translated">Type#const_int</target>
        </trans-unit>
        <trans-unit id="67af81bd3b83cc62f662b1a355b8332c598555f9" translate="yes" xml:space="preserve">
          <source>Type#context</source>
          <target state="translated">Type#context</target>
        </trans-unit>
        <trans-unit id="dc24dd0e52ce2087b86d79f4067e9eedcfe1b656" translate="yes" xml:space="preserve">
          <source>Type#device?</source>
          <target state="translated">Type#device?</target>
        </trans-unit>
        <trans-unit id="08e2f47a8aecc31225e36c4d58ccc7891e0023ff" translate="yes" xml:space="preserve">
          <source>Type#dgram?</source>
          <target state="translated">Type#dgram?</target>
        </trans-unit>
        <trans-unit id="2f77f7889ce72c7412fc50b0602177cdd37d1550" translate="yes" xml:space="preserve">
          <source>Type#directory?</source>
          <target state="translated">Type#directory?</target>
        </trans-unit>
        <trans-unit id="043ac38e185d5b451b74fadaaeff2ca022798150" translate="yes" xml:space="preserve">
          <source>Type#element_type</source>
          <target state="translated">Type#element_type</target>
        </trans-unit>
        <trans-unit id="76a75e763598ca7ffd5d90dc2576f2b53e160dcf" translate="yes" xml:space="preserve">
          <source>Type#file?</source>
          <target state="translated">Type#file?</target>
        </trans-unit>
        <trans-unit id="9a54e644578d9729e9314ea881de3efb7f3f10dc" translate="yes" xml:space="preserve">
          <source>Type#inspect</source>
          <target state="translated">Type#inspect</target>
        </trans-unit>
        <trans-unit id="72ab5b34fe9186e76bfc2b0c1f5c28ae707081ff" translate="yes" xml:space="preserve">
          <source>Type#int_width</source>
          <target state="translated">Type#int_width</target>
        </trans-unit>
        <trans-unit id="4b4e815c4a8a74296e90b739e439c12f992e5702" translate="yes" xml:space="preserve">
          <source>Type#kind</source>
          <target state="translated">Type#kind</target>
        </trans-unit>
        <trans-unit id="76c65a00484c6d9f6e9db34248dd2ea3c2800e04" translate="yes" xml:space="preserve">
          <source>Type#null</source>
          <target state="translated">Type#null</target>
        </trans-unit>
        <trans-unit id="b4467c94dd8a193507f32bff52b656d9c3cc3c55" translate="yes" xml:space="preserve">
          <source>Type#null_pointer</source>
          <target state="translated">Type#null_pointer</target>
        </trans-unit>
        <trans-unit id="52ded6e945f9c857d3c699bcfbdaa99f18c261e4" translate="yes" xml:space="preserve">
          <source>Type#packed_struct?</source>
          <target state="translated">Type#packed_struct?</target>
        </trans-unit>
        <trans-unit id="456ca7f53e60241e3e4b9e86ac95d6dfce217f01" translate="yes" xml:space="preserve">
          <source>Type#params_size</source>
          <target state="translated">Type#params_size</target>
        </trans-unit>
        <trans-unit id="ab1c2c2375fc22b0703e2add5fff022124523283" translate="yes" xml:space="preserve">
          <source>Type#params_types</source>
          <target state="translated">Type#params_types</target>
        </trans-unit>
        <trans-unit id="4bd8f1b34e4ec5881994fe34d465ce2ad803a44e" translate="yes" xml:space="preserve">
          <source>Type#pipe?</source>
          <target state="translated">Type#pipe?</target>
        </trans-unit>
        <trans-unit id="3cdcca18731083e412186c43d0393182fa02ed62" translate="yes" xml:space="preserve">
          <source>Type#pointer</source>
          <target state="translated">Type#pointer</target>
        </trans-unit>
        <trans-unit id="2ca98ceef33a4d0f1d3bbdb3936321f10f0a172c" translate="yes" xml:space="preserve">
          <source>Type#raw?</source>
          <target state="translated">Type#raw?</target>
        </trans-unit>
        <trans-unit id="ad1a5c0fceb21654ffa56bedcc902346c3cee9f2" translate="yes" xml:space="preserve">
          <source>Type#return_type</source>
          <target state="translated">Type#return_type</target>
        </trans-unit>
        <trans-unit id="74bab7bea827bba94f4a722c7401ccad69a3f4f3" translate="yes" xml:space="preserve">
          <source>Type#seqpacket?</source>
          <target state="translated">Type#seqpacket?</target>
        </trans-unit>
        <trans-unit id="b566f1df73cca8bbfd27cae0b853d1dfbcc12449" translate="yes" xml:space="preserve">
          <source>Type#size</source>
          <target state="translated">Type#size</target>
        </trans-unit>
        <trans-unit id="0782e8f0ce9d9126c150d89af1280517e87541d5" translate="yes" xml:space="preserve">
          <source>Type#socket?</source>
          <target state="translated">Type#socket?</target>
        </trans-unit>
        <trans-unit id="4b1e8c638a825ee3b1d660d8fafdcd5c03276d58" translate="yes" xml:space="preserve">
          <source>Type#stream?</source>
          <target state="translated">Type#stream?</target>
        </trans-unit>
        <trans-unit id="a04f4efc7cccd2ee1ba0fad341973e1650a6733b" translate="yes" xml:space="preserve">
          <source>Type#struct_element_types</source>
          <target state="translated">Type#struct_element_types</target>
        </trans-unit>
        <trans-unit id="36d219f2e6af1a7d422889f2b4c5f8f8b9f88cb8" translate="yes" xml:space="preserve">
          <source>Type#struct_name</source>
          <target state="translated">Type#struct_name</target>
        </trans-unit>
        <trans-unit id="719741cbec61fcf867239cab7515af40f14299c8" translate="yes" xml:space="preserve">
          <source>Type#symlink?</source>
          <target state="translated">Type#symlink?</target>
        </trans-unit>
        <trans-unit id="fd6c85d6b7b31f94b012faad52835d2c3a0cd543" translate="yes" xml:space="preserve">
          <source>Type#to_unsafe</source>
          <target state="translated">Type#to_unsafe</target>
        </trans-unit>
        <trans-unit id="ea25e74f63ce1a683117a323e380f2a16f671c25" translate="yes" xml:space="preserve">
          <source>Type#undef</source>
          <target state="translated">Type#undef</target>
        </trans-unit>
        <trans-unit id="55d26d2807258be0919cf4ad835ebebf8d275717" translate="yes" xml:space="preserve">
          <source>Type#unknown?</source>
          <target state="translated">Type#unknown?</target>
        </trans-unit>
        <trans-unit id="14b732d91aa025572ed4b16942fca5b10c79d2fc" translate="yes" xml:space="preserve">
          <source>Type#unwrap</source>
          <target state="translated">Type#unwrap</target>
        </trans-unit>
        <trans-unit id="19741911cebe04d35e3d168402de5ce15d4352f7" translate="yes" xml:space="preserve">
          <source>Type#varargs?</source>
          <target state="translated">Type#varargs?</target>
        </trans-unit>
        <trans-unit id="280dd6a1cc7fdff8c604180a304659bdc58cb9ae" translate="yes" xml:space="preserve">
          <source>Type#vector</source>
          <target state="translated">Type#vector</target>
        </trans-unit>
        <trans-unit id="ccc9b679e615cfcc61ef85ea06627f6300afe0d8" translate="yes" xml:space="preserve">
          <source>Type#vector_size</source>
          <target state="translated">Type#vector_size</target>
        </trans-unit>
        <trans-unit id="8de7e0f5a0893a5da3c71605da55953ca53d7ff8" translate="yes" xml:space="preserve">
          <source>Type#void?</source>
          <target state="translated">Type#void?</target>
        </trans-unit>
        <trans-unit id="ae6e0bbb82199bf2f9bbaa1eab68f7c5669345f2" translate="yes" xml:space="preserve">
          <source>Type.function</source>
          <target state="translated">Type.function</target>
        </trans-unit>
        <trans-unit id="1cb3ba201ea3a0b53221a1a9129b1126826ecfab" translate="yes" xml:space="preserve">
          <source>Type.new</source>
          <target state="translated">Type.new</target>
        </trans-unit>
        <trans-unit id="c3fed42f5c02b7b6956096d3455794923bfcdae0" translate="yes" xml:space="preserve">
          <source>Type::Kind</source>
          <target state="translated">Type::Kind</target>
        </trans-unit>
        <trans-unit id="3dbcf392dd7974496e3d4b40dc2bf2dc5fb3bc7e" translate="yes" xml:space="preserve">
          <source>Type::Kind#array?</source>
          <target state="translated">Type::Kind#array?</target>
        </trans-unit>
        <trans-unit id="7d7a6948a15ce0b21d1264e8c36043f3ba6c5488" translate="yes" xml:space="preserve">
          <source>Type::Kind#double?</source>
          <target state="translated">Type::Kind#double?</target>
        </trans-unit>
        <trans-unit id="0cea354bd141f026df63904c12032dcc615488a8" translate="yes" xml:space="preserve">
          <source>Type::Kind#float?</source>
          <target state="translated">Type::Kind#float?</target>
        </trans-unit>
        <trans-unit id="6458d81606455dcdb0a6a4a87570fd6419e6e425" translate="yes" xml:space="preserve">
          <source>Type::Kind#fp128?</source>
          <target state="translated">Type::Kind#fp128?</target>
        </trans-unit>
        <trans-unit id="d73452e09e88069aa5cde73211831f210dafe984" translate="yes" xml:space="preserve">
          <source>Type::Kind#function?</source>
          <target state="translated">Type::Kind#function?</target>
        </trans-unit>
        <trans-unit id="2f3197d03bede1e3bcad23faf451ccc14b8211be" translate="yes" xml:space="preserve">
          <source>Type::Kind#half?</source>
          <target state="translated">Type::Kind#half?</target>
        </trans-unit>
        <trans-unit id="2716d4fc1dc8e4a996afe55a87f5fad2d06ea5ad" translate="yes" xml:space="preserve">
          <source>Type::Kind#integer?</source>
          <target state="translated">Type::Kind#integer?</target>
        </trans-unit>
        <trans-unit id="9c99934a0cfee026440026059ebf0f885196193e" translate="yes" xml:space="preserve">
          <source>Type::Kind#label?</source>
          <target state="translated">Type::Kind#label?</target>
        </trans-unit>
        <trans-unit id="49815f001b18013e2b5f4a4d29fa71bfae83a407" translate="yes" xml:space="preserve">
          <source>Type::Kind#metadata?</source>
          <target state="translated">Type::Kind#metadata?</target>
        </trans-unit>
        <trans-unit id="ef3fe1a582869e1ad36889a830054bf99900bea1" translate="yes" xml:space="preserve">
          <source>Type::Kind#pointer?</source>
          <target state="translated">Type::Kind#pointer?</target>
        </trans-unit>
        <trans-unit id="37f0ea8347abfa31b42fbd73afe60d39af27c7df" translate="yes" xml:space="preserve">
          <source>Type::Kind#ppc_fp128?</source>
          <target state="translated">Type::Kind#ppc_fp128?</target>
        </trans-unit>
        <trans-unit id="3772fabd242871fcbdad1dd99eec9cbee4b14887" translate="yes" xml:space="preserve">
          <source>Type::Kind#struct?</source>
          <target state="translated">Type::Kind#struct?</target>
        </trans-unit>
        <trans-unit id="407762eba8474a42a0456fe49456b45e7c62c6a9" translate="yes" xml:space="preserve">
          <source>Type::Kind#vector?</source>
          <target state="translated">Type::Kind#vector?</target>
        </trans-unit>
        <trans-unit id="2fd256675eb81144d0ccc1e4f315b868dcb3f08a" translate="yes" xml:space="preserve">
          <source>Type::Kind#void?</source>
          <target state="translated">Type::Kind#void?</target>
        </trans-unit>
        <trans-unit id="d3e28755e72167e30772368ba4804fd6fcefa687" translate="yes" xml:space="preserve">
          <source>Type::Kind#x86_fp80?</source>
          <target state="translated">Type::Kind#x86_fp80?</target>
        </trans-unit>
        <trans-unit id="d39be1171c5217cddb2f802e110755035b06b813" translate="yes" xml:space="preserve">
          <source>Type::Kind#x86_mmx?</source>
          <target state="translated">Type::Kind#x86_mmx?</target>
        </trans-unit>
        <trans-unit id="19cc5b2c242881b1ef5b12bc33728a92b83c1d5d" translate="yes" xml:space="preserve">
          <source>TypeCastError</source>
          <target state="translated">TypeCastError</target>
        </trans-unit>
        <trans-unit id="83ce81e7118d69ceed4a0baf8102c8b7f8dd5655" translate="yes" xml:space="preserve">
          <source>TypeCastError.new</source>
          <target state="translated">TypeCastError.new</target>
        </trans-unit>
        <trans-unit id="b0d53b6120593aeedf51891aa9f7735c6f25d1e1" translate="yes" xml:space="preserve">
          <source>Types and methods</source>
          <target state="translated">类型和方法</target>
        </trans-unit>
        <trans-unit id="9c1e6a91e1057d81afc46a89e790e79fb8701f9f" translate="yes" xml:space="preserve">
          <source>Types in C Bindings</source>
          <target state="translated">C语言绑定中的类型</target>
        </trans-unit>
        <trans-unit id="5c2e4209669d8e4c094bdcff164da40fa9f436f5" translate="yes" xml:space="preserve">
          <source>Types including this module are typically &lt;code&gt;&lt;a href=&quot;array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt;-like types.</source>
          <target state="translated">包括此模块的类型通常是类似 &lt;code&gt;&lt;a href=&quot;array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="8fdda74f52dcdd95a3bf8b356cb0dda3841039b7" translate="yes" xml:space="preserve">
          <source>Types, methods and generally any part of your code can be conditionally defined based on some flags available at compile time. These flags are by default read from the hosts &lt;a href=&quot;http://llvm.org/docs/LangRef.html#target-triple&quot;&gt;LLVM Target Triple&lt;/a&gt;, split on &lt;code&gt;-&lt;/code&gt;. To get the target you can execute &lt;code&gt;llvm-config --host-target&lt;/code&gt;.</source>
          <target state="translated">可以根据编译时可用的一些标志有条件地定义类型，方法以及代码的任何部分。默认情况下，这些标志是从主机&lt;a href=&quot;http://llvm.org/docs/LangRef.html#target-triple&quot;&gt;LLVM Target Triple&lt;/a&gt;（在 &lt;code&gt;-&lt;/code&gt; 上拆分）读取的。要获取目标，可以执行 &lt;code&gt;llvm-config --host-target&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f00a15c8c28b40d4502cc2c6c389da7fe6d44b14" translate="yes" xml:space="preserve">
          <source>Typical examples for non-returning methods and keywords are &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, &lt;code&gt;raise&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, and &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="translated">非返回方法和关键字的典型示例是 &lt;code&gt;return&lt;/code&gt; ， &lt;code&gt;exit&lt;/code&gt; ， &lt;code&gt;raise&lt;/code&gt; ， &lt;code&gt;next&lt;/code&gt; 和 &lt;code&gt;break&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="translated">典型用途:</target>
        </trans-unit>
        <trans-unit id="36852b319b2b549c1097f9bfa0e971e58e0b09fa" translate="yes" xml:space="preserve">
          <source>Typically used to output data and information.</source>
          <target state="translated">通常用于输出数据和信息。</target>
        </trans-unit>
        <trans-unit id="d89287599c0e49847a7257a2a6f06fca2281d22b" translate="yes" xml:space="preserve">
          <source>Typically used to output error messages and diagnostics.</source>
          <target state="translated">通常用于输出错误信息和诊断程序。</target>
        </trans-unit>
        <trans-unit id="63bf0b0d2ea109d8e4a9bb3fc2e371edb13ab9f3" translate="yes" xml:space="preserve">
          <source>UDP is a very simple protocol. Messages, so called datagrams, are sent to other hosts on an IP network without the need to set up special transmission channels or data paths beforehand. The UDP socket only needs to be opened for communication. It listens for incoming messages and sends outgoing messages on request.</source>
          <target state="translated">UDP是一个非常简单的协议。信息,即所谓的数据报,在IP网络上发送给其他主机,而不需要事先设置特殊的传输通道或数据路径。只需要打开UDP套接字就可以进行通信。它监听传入的消息,并按要求发送传出的消息。</target>
        </trans-unit>
        <trans-unit id="933ab75614121ba9f074a0b082a253c60752b5ae" translate="yes" xml:space="preserve">
          <source>UDP runs on top of the Internet Protocol (IP) and was developed for applications that do not require reliability, acknowledgement, or flow control features at the transport layer. This simple protocol provides transport layer addressing in the form of UDP ports and an optional checksum capability.</source>
          <target state="translated">UDP运行在互联网协议(IP)之上,是为不需要传输层的可靠性、确认或流量控制功能的应用而开发的。这个简单的协议以UDP端口和可选的校验功能的形式提供传输层寻址。</target>
        </trans-unit>
        <trans-unit id="5091bc2101291836700b05e5a46a52b6a0f263d9" translate="yes" xml:space="preserve">
          <source>UDPSocket</source>
          <target state="translated">UDPSocket</target>
        </trans-unit>
        <trans-unit id="e67152fd7d80d9c8bd94e0ab69e4f4db48b0f5f2" translate="yes" xml:space="preserve">
          <source>UDPSocket.new</source>
          <target state="translated">UDPSocket.new</target>
        </trans-unit>
        <trans-unit id="9b81a5f58a08d125439c4fe920735e6f93f6c26f" translate="yes" xml:space="preserve">
          <source>UInt</source>
          <target state="translated">UInt</target>
        </trans-unit>
        <trans-unit id="a314e0179bfc11f078094a1453edfe519ba82dfa" translate="yes" xml:space="preserve">
          <source>UInt128</source>
          <target state="translated">UInt128</target>
        </trans-unit>
        <trans-unit id="5085621745bbcf90f0a3b05448eaf550e68cbb27" translate="yes" xml:space="preserve">
          <source>UInt128#*</source>
          <target state="translated">UInt128#*</target>
        </trans-unit>
        <trans-unit id="aab1247a4deecbe516d1021889ee2ca2c6e7d2e1" translate="yes" xml:space="preserve">
          <source>UInt128#+</source>
          <target state="translated">UInt128#+</target>
        </trans-unit>
        <trans-unit id="5d2541018d9901fd7215762f4f12b89e2207733a" translate="yes" xml:space="preserve">
          <source>UInt128#-</source>
          <target state="translated">UInt128#-</target>
        </trans-unit>
        <trans-unit id="4707447d152b923c9c7f8f64494035d047d2599f" translate="yes" xml:space="preserve">
          <source>UInt128#/</source>
          <target state="translated">UInt128#/</target>
        </trans-unit>
        <trans-unit id="e7f49a6cb148315e3040f86b704826c409828f5b" translate="yes" xml:space="preserve">
          <source>UInt128#^</source>
          <target state="translated">UInt128#^</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
