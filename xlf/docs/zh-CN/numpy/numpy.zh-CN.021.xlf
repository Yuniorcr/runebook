<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="95260188435af534996db3e9c839aec2ec1973f1" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays horizontally (column wise)</source>
          <target state="translated">将数组水平分割成多个子数组(列式)。</target>
        </trans-unit>
        <trans-unit id="51dd8171b04c2b0c76ba9d323ee327eabec86d47" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays horizontally (column wise).</source>
          <target state="translated">将数组水平分割成多个子数组(列式)。</target>
        </trans-unit>
        <trans-unit id="4a58d1a7c17bf5b26ef79c3a68ad7dfd39dc14fd" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays horizontally (column-wise).</source>
          <target state="translated">将数组水平分割成多个子数组(以列为单位)。</target>
        </trans-unit>
        <trans-unit id="aaa399416b95737d5812be5e3aafc40e1bde329d" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays of equal size.</source>
          <target state="translated">将数组分割成多个大小相等的子数组。</target>
        </trans-unit>
        <trans-unit id="32200fb547976d9cdce1bf0123e79ad3d01d45c6" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays vertically (row wise)</source>
          <target state="translated">将数组垂直分割成多个子数组(以行为单位)。</target>
        </trans-unit>
        <trans-unit id="5e2072ff967b60fe048397bbdc922e037ef75e9d" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays vertically (row wise).</source>
          <target state="translated">将数组垂直分割成多个子数组(以行为单位)。</target>
        </trans-unit>
        <trans-unit id="d638a6c0e1614240bc1fdb2bb9a33a3845eee28f" translate="yes" xml:space="preserve">
          <source>Splitting arrays</source>
          <target state="translated">拆分数组</target>
        </trans-unit>
        <trans-unit id="e788a54fb6fdb2a43a1ae31294a2bfe96a83c4a8" translate="yes" xml:space="preserve">
          <source>Splitting one array into several smaller ones</source>
          <target state="translated">将一个数组分割成多个小数组</target>
        </trans-unit>
        <trans-unit id="154e3ad24baea0d9af086340b67288378fdfe64f" translate="yes" xml:space="preserve">
          <source>Splitting the lines into columns</source>
          <target state="translated">把线分成几列</target>
        </trans-unit>
        <trans-unit id="4d58ebaf799f88b14e5a55e0738d2ff6431f8e7d" translate="yes" xml:space="preserve">
          <source>Square identity matrix.</source>
          <target state="translated">平方身份矩阵。</target>
        </trans-unit>
        <trans-unit id="3613d80d3881f6e72e0182c8791baa68e9f04486" translate="yes" xml:space="preserve">
          <source>Square root (of data size) estimator, used by Excel and other programs for its speed and simplicity.</source>
          <target state="translated">平方根(数据大小)估计器,Excel和其他程序使用的速度和简单性。</target>
        </trans-unit>
        <trans-unit id="bf5a12657392766edfc9adfbf010a7c69c0ce01d" translate="yes" xml:space="preserve">
          <source>Squashing commits or cleaning up commit messages of a PR that you consider too messy is OK. Remember to retain the original author&amp;rsquo;s name when doing this. Make sure commit messages follow the &lt;a href=&quot;development_workflow#writing-the-commit-message&quot;&gt;rules for NumPy&lt;/a&gt;.</source>
          <target state="translated">压缩您认为过于混乱的PR的提交或清理提交消息是可以的。执行此操作时，请记住保留原始作者的姓名。确保提交消息遵循&lt;a href=&quot;development_workflow#writing-the-commit-message&quot;&gt;NumPy&lt;/a&gt;的规则。</target>
        </trans-unit>
        <trans-unit id="0a4dd332ee1cc0f34be7b423ca38b3a124b358e2" translate="yes" xml:space="preserve">
          <source>St&amp;eacute;fan van der Walt</source>
          <target state="translated">斯特凡&amp;middot;范德华特</target>
        </trans-unit>
        <trans-unit id="a20f5de17a778177c1d20a924357600fac4e355d" translate="yes" xml:space="preserve">
          <source>Stack 1-D arrays as columns into a 2-D array.</source>
          <target state="translated">将一维数组作为列堆叠成二维数组。</target>
        </trans-unit>
        <trans-unit id="22aff824a88fb9e372dada7709040605bdecb795" translate="yes" xml:space="preserve">
          <source>Stack a sequence of arrays along a new axis.</source>
          <target state="translated">沿着新的轴堆叠一个数组序列。</target>
        </trans-unit>
        <trans-unit id="b708f3f441cf8b7881ef5ae7003def9a89be1321" translate="yes" xml:space="preserve">
          <source>Stack along first axis.</source>
          <target state="translated">沿着第一轴线叠加。</target>
        </trans-unit>
        <trans-unit id="4e6821d485f2c248408d2340ce48afc4638994d9" translate="yes" xml:space="preserve">
          <source>Stack along second axis.</source>
          <target state="translated">沿着第二轴线堆积。</target>
        </trans-unit>
        <trans-unit id="654d38ec444eb1ee8c9c4cb4064b5c34d10ed04b" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence along a new dimension.</source>
          <target state="translated">沿着一个新的维度依次堆叠数组。</target>
        </trans-unit>
        <trans-unit id="8075374116f55fd4a715fc7ce7ce68e6a94d1c6b" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence depth wise (along third axis).</source>
          <target state="translated">按顺序深度堆叠数组(沿第三轴)。</target>
        </trans-unit>
        <trans-unit id="49771b17dcab7c55c17889eac7ab065c2d3411f8" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence depth wise (along third dimension)</source>
          <target state="translated">按深度顺序堆栈数组(沿第三维)。</target>
        </trans-unit>
        <trans-unit id="d03609f09d0072b17b53d7c9e81abc547dbe26af" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence depth wise (along third dimension).</source>
          <target state="translated">按顺序深度堆叠数组(沿第三维)。</target>
        </trans-unit>
        <trans-unit id="9d4bdc812ef44d6a84449088558f278a7a04fd89" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence horizontally (column wise)</source>
          <target state="translated">依次水平堆叠数组(列式)。</target>
        </trans-unit>
        <trans-unit id="ab9d3847a31919c576029d377c5a503add8ffa12" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence horizontally (column wise).</source>
          <target state="translated">依次水平堆叠数组(以列为单位)。</target>
        </trans-unit>
        <trans-unit id="6895241ba9b7ce75e412efb0b37cc740ec4c6f5a" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence vertically (row wise)</source>
          <target state="translated">依次垂直堆叠数组(以行为单位)。</target>
        </trans-unit>
        <trans-unit id="d3ccf82c78c83570433d65f4d8ae10b7fd8977b2" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence vertically (row wise).</source>
          <target state="translated">按顺序垂直堆叠数组(以行为单位)。</target>
        </trans-unit>
        <trans-unit id="32995c381170a7cab2370b6bab49aaf95973692d" translate="yes" xml:space="preserve">
          <source>Stacking together different arrays</source>
          <target state="translated">将不同的数组堆叠在一起</target>
        </trans-unit>
        <trans-unit id="8085e023a3bd83539ee52ab6920d2f5d11c78066" translate="yes" xml:space="preserve">
          <source>Stacks of matrices are broadcast together as if the matrices were elements, respecting the signature &lt;code&gt;(n,k),(k,m)-&amp;gt;(n,m)&lt;/code&gt;:</source>
          <target state="translated">将矩阵堆栈一起广播，就好像矩阵是元素一样，同时尊重签名 &lt;code&gt;(n,k),(k,m)-&amp;gt;(n,m)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d04797e8ae7899c2001f6f6340094625d64a3d75" translate="yes" xml:space="preserve">
          <source>Stacks of object matrices are not currently supported.</source>
          <target state="translated">目前不支持对象矩阵的堆栈。</target>
        </trans-unit>
        <trans-unit id="67bfee426b8f29b7c1b147b264c4ea92422abbce" translate="yes" xml:space="preserve">
          <source>Stadlober, Ernst, &amp;ldquo;The ratio of uniforms approach for generating discrete random variates&amp;rdquo;, Journal of Computational and Applied Mathematics, 31, pp. 181-189 (1990).</source>
          <target state="translated">Stadlober，Ernst，&amp;ldquo;用于生成离散随机变量的均匀法方法&amp;rdquo;，《计算与应用数学学报》，第31卷，第181-189页（1990）。</target>
        </trans-unit>
        <trans-unit id="f35d3ef365b37da6958be17fda8b07fc8d89e22e" translate="yes" xml:space="preserve">
          <source>Standard Binary Formats</source>
          <target state="translated">标准二进制格式</target>
        </trans-unit>
        <trans-unit id="6555192e9f6da8cd095b33f3c4f7b71a9783ffae" translate="yes" xml:space="preserve">
          <source>Standard Exponentials (&lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">标准指数（&lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="a76b8a339223d559651cacde3723ee6065b8680a" translate="yes" xml:space="preserve">
          <source>Standard FFTs</source>
          <target state="translated">标准FFTs</target>
        </trans-unit>
        <trans-unit id="8a50b57204e2e599132c00b62a1be1df8baa7ef4" translate="yes" xml:space="preserve">
          <source>Standard Gammas (&lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">标准伽玛（&lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="f24592e2f6f33fdf5fc1ae7710b26e85d05408ff" translate="yes" xml:space="preserve">
          <source>Standard acronyms to start the commit message with are:</source>
          <target state="translated">提交信息开头的标准缩略语是:</target>
        </trans-unit>
        <trans-unit id="6acbc6354e507f6042f5f9e2e8ed73fc0f0df274" translate="yes" xml:space="preserve">
          <source>Standard array subclasses</source>
          <target state="translated">标准数组子类</target>
        </trans-unit>
        <trans-unit id="cc94a4125e37461a7eb45a58071de9b78020fdd7" translate="yes" xml:space="preserve">
          <source>Standard container class</source>
          <target state="translated">标准容器类</target>
        </trans-unit>
        <trans-unit id="d97a83beb388d3e9a736d669dd24314ad1c4c05d" translate="yes" xml:space="preserve">
          <source>Standard container-class for easy multiple-inheritance.</source>
          <target state="translated">标准容器类,便于多继承。</target>
        </trans-unit>
        <trans-unit id="fd746f492ad659d3f7460598edb734faace83b3c" translate="yes" xml:space="preserve">
          <source>Standard deviation</source>
          <target state="translated">标准偏差</target>
        </trans-unit>
        <trans-unit id="abfc13a248e3a8f054556e98e30f2c835c7640af" translate="yes" xml:space="preserve">
          <source>Standard deviation (spread or &amp;ldquo;width&amp;rdquo;) of the distribution. Must be non-negative.</source>
          <target state="translated">分布的标准偏差（展开或&amp;ldquo;宽度&amp;rdquo;）。必须为非负数。</target>
        </trans-unit>
        <trans-unit id="353ecc8b9a821fe897c9828f33c52edee66e1903" translate="yes" xml:space="preserve">
          <source>Standard deviation of the underlying normal distribution. Must be non-negative. Default is 1.</source>
          <target state="translated">基本正态分布的标准差。必须为非负值。默认值为1。</target>
        </trans-unit>
        <trans-unit id="23af397f01a5349c3364864801bdaded9c9fd69b" translate="yes" xml:space="preserve">
          <source>Standard division.</source>
          <target state="translated">标准划分:</target>
        </trans-unit>
        <trans-unit id="41e65f8d183f4a9b208031a1e27c9fa561f1fc26" translate="yes" xml:space="preserve">
          <source>Standard iterator method, returns the index tuple and array value.</source>
          <target state="translated">标准迭代器方法,返回索引元组和数组值。</target>
        </trans-unit>
        <trans-unit id="5dc1c8c87cf79f5d6e41fc7b3d5b58a53840de0c" translate="yes" xml:space="preserve">
          <source>Standard iterator method, updates the index and returns the index tuple.</source>
          <target state="translated">标准迭代器方法,更新索引并返回索引元组。</target>
        </trans-unit>
        <trans-unit id="705c64e14cad8de0cc699306d0ca12c91eb54644" translate="yes" xml:space="preserve">
          <source>Standards for behaviour in the NumPy community are detailed in the Code of Conduct above. Participants in our community should uphold these standards in all their interactions and help others to do so as well (see next section).</source>
          <target state="translated">NumPy社区的行为标准在上面的行为准则中详细说明。我们社区的参与者应该在所有的互动中坚持这些标准,并帮助其他人也这样做(见下一节)。</target>
        </trans-unit>
        <trans-unit id="dfc6bedfe760398884b530bf566a3b19e904ba58" translate="yes" xml:space="preserve">
          <source>Start a new &lt;em&gt;feature branch&lt;/em&gt; for each set of edits that you do. See &lt;a href=&quot;#making-a-new-feature-branch&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">为您执行的每组编辑启动一个新的&lt;em&gt;功能分支&lt;/em&gt;。见&lt;a href=&quot;#making-a-new-feature-branch&quot;&gt;下文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e86c7fa9ebee31bc3e748ec98755eaa91eec7ff" translate="yes" xml:space="preserve">
          <source>Start and stop arrays for &lt;code&gt;linspace&lt;/code&gt;, &lt;code&gt;logspace&lt;/code&gt; and &lt;code&gt;geomspace&lt;/code&gt;</source>
          <target state="translated">开始和停止 &lt;code&gt;linspace&lt;/code&gt; ， &lt;code&gt;logspace&lt;/code&gt; 和 &lt;code&gt;geomspace&lt;/code&gt; 的数组</target>
        </trans-unit>
        <trans-unit id="3dd4f400b2542c4291d804ded14e6f7d8e21e239" translate="yes" xml:space="preserve">
          <source>Start here for an overview of NumPy features and syntax</source>
          <target state="translated">从这里开始了解NumPy的功能和语法。</target>
        </trans-unit>
        <trans-unit id="df808e9a53d2f9ad1713cebd06d023de29058b1f" translate="yes" xml:space="preserve">
          <source>Start of interval. The interval includes this value. The default start value is 0.</source>
          <target state="translated">区间的开始。间隔包括这个值。默认的起始值为0。</target>
        </trans-unit>
        <trans-unit id="e3d56ccfa43387f906331b5afa2c49c8c391ba34" translate="yes" xml:space="preserve">
          <source>Start reading buffer (&lt;code&gt;buf&lt;/code&gt;) from this offset onwards.</source>
          <target state="translated">从此偏移量开始读取缓冲区（ &lt;code&gt;buf&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8a8f60afc4e5d9508e376d3a267b217a51489d68" translate="yes" xml:space="preserve">
          <source>Start reading the buffer from this offset (in bytes); default: 0.</source>
          <target state="translated">从这个偏移量开始读取缓冲区(单位:字节);默认:0。</target>
        </trans-unit>
        <trans-unit id="ddcac8bcdcee9d908ef620776b7aaacfebecb3f8" translate="yes" xml:space="preserve">
          <source>Start search at this level.</source>
          <target state="translated">从这个层面开始搜索。</target>
        </trans-unit>
        <trans-unit id="1b68451d2955d61b15e001c6fdcdc0d7038975d3" translate="yes" xml:space="preserve">
          <source>Starting from numpy 1.3.0, we are working on separating the pure C, &amp;ldquo;computational&amp;rdquo; code from the python dependent code. The goal is twofolds: making the code cleaner, and enabling code reuse by other extensions outside numpy (scipy, etc&amp;hellip;).</source>
          <target state="translated">从numpy 1.3.0开始，我们正在将纯C&amp;ldquo;计算&amp;rdquo;代码与python依赖代码分开。目标是双重的：使代码更整洁，并使numpy之外的其他扩展（scipy等）实现代码重用。</target>
        </trans-unit>
        <trans-unit id="190bfe8a8e41d4d3adc0d8967b2fb6cda62c785e" translate="yes" xml:space="preserve">
          <source>Starting guess for solving the rate of interest, default 0.1</source>
          <target state="translated">解利率的起始猜测,默认0.1。</target>
        </trans-unit>
        <trans-unit id="1998183b3f42c5d604f45eee6e025b0b95e779c9" translate="yes" xml:space="preserve">
          <source>Starting in NumPy 1.7, there are core array data types which natively support datetime functionality. The data type is called &amp;ldquo;datetime64&amp;rdquo;, so named because &amp;ldquo;datetime&amp;rdquo; is already taken by the datetime library included in Python.</source>
          <target state="translated">从NumPy 1.7开始，有些核心数组数据类型本身支持日期时间功能。数据类型称为&amp;ldquo; datetime64&amp;rdquo;，之所以这样命名是因为Python中包含的datetime库已经采用了&amp;ldquo; datetime&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e4430717cba93d1575e5d9028fa5b9735d7a5640" translate="yes" xml:space="preserve">
          <source>Starting in NumPy 1.9 it returns a read-only view on the original array. Attempting to write to the resulting array will produce an error.</source>
          <target state="translated">从NumPy 1.9开始,它返回一个只读的原始数组视图。试图对结果数组进行写入将产生一个错误。</target>
        </trans-unit>
        <trans-unit id="03579e07c4a86e15aa2daa8e0ee5d8b2de28c77b" translate="yes" xml:space="preserve">
          <source>Starting in NumPy 1.9, promote_types function now returns a valid string length when given an integer or float dtype as one argument and a string dtype as another argument. Previously it always returned the input string dtype, even if it wasn&amp;rsquo;t long enough to store the max integer/float value converted to a string.</source>
          <target state="translated">从NumPy 1.9开始，promote_types函数现在会在给定整数或浮点dtype作为一个参数而给定字符串dtype作为另一个参数时返回有效的字符串长度。以前，它总是返回输入字符串dtype，即使它的时间不足以存储转换为字符串的最大整数/浮点值。</target>
        </trans-unit>
        <trans-unit id="48acaf98f98fb538de8401c0548aec9b9591fd70" translate="yes" xml:space="preserve">
          <source>Starting value for the sum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">总和的起始值。有关详细信息，请参见&lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b2aae9c414bf14230f85547c67e7be26bffec39" translate="yes" xml:space="preserve">
          <source>Starting with this array:</source>
          <target state="translated">从这个数组开始。</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="2086b21f8f49274138c38d476bee317a84a8aecc" translate="yes" xml:space="preserve">
          <source>Statistics</source>
          <target state="translated">Statistics</target>
        </trans-unit>
        <trans-unit id="7d6d3c7e587c7e68d91b665ed9a95bf9852d4a61" translate="yes" xml:space="preserve">
          <source>Steering Council</source>
          <target state="translated">指导委员会</target>
        </trans-unit>
        <trans-unit id="33ead70d43f6e06f674323c3d94bcc353904043d" translate="yes" xml:space="preserve">
          <source>Steering council</source>
          <target state="translated">指导委员会</target>
        </trans-unit>
        <trans-unit id="64897d13af61fe94427b3180ce50b9b970318112" translate="yes" xml:space="preserve">
          <source>Stefan van der Walt</source>
          <target state="translated">Stefan van der Walt</target>
        </trans-unit>
        <trans-unit id="fa99ded051e65cfde097e3a6929d1b68ade9d957" translate="yes" xml:space="preserve">
          <source>Step-by-Step Directions</source>
          <target state="translated">步驟說明</target>
        </trans-unit>
        <trans-unit id="b0ef44a7ef3024cbe8a08b7dc9dc3bf5ebcd97a8" translate="yes" xml:space="preserve">
          <source>Stephan Hoyer</source>
          <target state="translated">Stephan Hoyer</target>
        </trans-unit>
        <trans-unit id="55fdc4e46b10f8815926e76cd96fd99504aad94e" translate="yes" xml:space="preserve">
          <source>Store compressed data to disk, and load it again:</source>
          <target state="translated">将压缩后的数据存储到磁盘上,然后再加载。</target>
        </trans-unit>
        <trans-unit id="c40b4ecf74fcdef0fac2e2b3e7ed1b00b25b3fa6" translate="yes" xml:space="preserve">
          <source>Store data to disk, and load it again:</source>
          <target state="translated">将数据存储到磁盘上,然后再加载。</target>
        </trans-unit>
        <trans-unit id="e1c52dc3262f206eabc8e2236b28e7c92720ec86" translate="yes" xml:space="preserve">
          <source>Stores all of the necessary information to reconstruct the array including shape and dtype on a machine of a different architecture. Both little-endian and big-endian arrays are supported, and a file with little-endian numbers will yield a little-endian array on any machine reading the file. The types are described in terms of their actual sizes. For example, if a machine with a 64-bit C &amp;ldquo;long int&amp;rdquo; writes out an array with &amp;ldquo;long ints&amp;rdquo;, a reading machine with 32-bit C &amp;ldquo;long ints&amp;rdquo; will yield an array with 64-bit integers.</source>
          <target state="translated">存储所有必要的信息以在不同体系结构的计算机上重建包括shape和dtype的数组。little-endian和big-endian数组均受支持，并且具有little-endian编号的文件将在读取该文件的任何计算机上生成一个little-endian数组。这些类型根据其实际大小进行描述。例如，如果一台具有64位C&amp;ldquo; long int&amp;rdquo;的机器写出一个具有&amp;ldquo; long ints&amp;rdquo;的数组，那么一台具有32位C&amp;ldquo; long int&amp;rdquo;的读取机将产生一个具有64位整数的数组。</target>
        </trans-unit>
        <trans-unit id="4be1432cfaeaa9150a93183cf4c2899fcef7c724" translate="yes" xml:space="preserve">
          <source>Stores object arrays, i.e. arrays containing elements that are arbitrary Python objects. Files with object arrays are not to be mmapable, but can be read and written to disk.</source>
          <target state="translated">存储对象数组,即包含任意 Python 对象元素的数组。带有对象数组的文件是不可mmap的,但可以读和写到磁盘。</target>
        </trans-unit>
        <trans-unit id="f27167d2cff299e4b6bdced9e8ba574539ece3ec" translate="yes" xml:space="preserve">
          <source>Strided Loop</source>
          <target state="translated">步行圈</target>
        </trans-unit>
        <trans-unit id="0229721b8100825a2747d58dc18cba748992b615" translate="yes" xml:space="preserve">
          <source>Strided copy code: Here, &amp;ldquo;uint alignment&amp;rdquo; is used instead. If the itemsize of an array is equal to 1, 2, 4, 8 or 16 bytes and the array is uint aligned then instead numpy will do &lt;code&gt;*(uintN*)dst) = *(uintN*)src)&lt;/code&gt; for appropriate N. Otherwise numpy copies by doing &lt;code&gt;memcpy(dst, src, N)&lt;/code&gt;.</source>
          <target state="translated">交错的复制代码：在这里，使用&amp;ldquo;统一对齐&amp;rdquo;。如果数组的项目大小等于1、2、4、8或16个字节，并且数组是uint对齐的，那么numpy会对适当的N 做 &lt;code&gt;*(uintN*)dst) = *(uintN*)src)&lt;/code&gt; 。通过执行 &lt;code&gt;memcpy(dst, src, N)&lt;/code&gt; 进行numpy复制。</target>
        </trans-unit>
        <trans-unit id="f1c72d03ba013d5a43f8687bb5c241e852fd854a" translate="yes" xml:space="preserve">
          <source>Strides are computed automatically from an array&amp;rsquo;s dtype and shape, but can be directly specified using &lt;a href=&quot;reference/generated/numpy.lib.stride_tricks.as_strided&quot;&gt;as_strided.&lt;/a&gt;</source>
          <target state="translated">步长是根据数组的dtype和形状自动计算的，但可以使用&lt;a href=&quot;reference/generated/numpy.lib.stride_tricks.as_strided&quot;&gt;as_strided&lt;/a&gt;直接指定。</target>
        </trans-unit>
        <trans-unit id="416989873d1bb367de9329586677a513ca98acbb" translate="yes" xml:space="preserve">
          <source>Strides for the array (see &lt;a href=&quot;numpy.ndarray.strides#numpy.ndarray.strides&quot;&gt;&lt;code&gt;ndarray.strides&lt;/code&gt;&lt;/a&gt; for full description). Default is None.</source>
          <target state="translated">数组的&lt;a href=&quot;numpy.ndarray.strides#numpy.ndarray.strides&quot;&gt; &lt;code&gt;ndarray.strides&lt;/code&gt; &lt;/a&gt;有关完整说明，请参见ndarray.strides）。默认为无。</target>
        </trans-unit>
        <trans-unit id="abe83ed756895533bb0aacd0ff6c133f19d2f819" translate="yes" xml:space="preserve">
          <source>Strides for the array (see &lt;code&gt;ndarray.strides&lt;/code&gt; for full description). Default is None.</source>
          <target state="translated">数组的 &lt;code&gt;ndarray.strides&lt;/code&gt; 有关完整说明，请参见ndarray.strides）。默认为无。</target>
        </trans-unit>
        <trans-unit id="715d0f58588cad2551c57b871fab2907378f7743" translate="yes" xml:space="preserve">
          <source>Strides of data in memory.</source>
          <target state="translated">内存中的数据步数。</target>
        </trans-unit>
        <trans-unit id="4afc193de85ea729f32e1a7419493e9d11ac22a1" translate="yes" xml:space="preserve">
          <source>String (fixed-length sequence of char)</source>
          <target state="translated">字符串</target>
        </trans-unit>
        <trans-unit id="f12af9aa3dd629be8a9ae33b8570944039c84f2e" translate="yes" xml:space="preserve">
          <source>String Parsing</source>
          <target state="translated">字符串解析</target>
        </trans-unit>
        <trans-unit id="50f87962b3ace37596528a4245b60309cd75dbef" translate="yes" xml:space="preserve">
          <source>String appended to the names of the fields of r1 that are present in r2 but absent of the key.</source>
          <target state="translated">附加在r1的字段名后面的字符串,这些字段在r2中存在,但没有键。</target>
        </trans-unit>
        <trans-unit id="db01bd7e0ba81f6c4e00a0e50e0f3454439e8ce9" translate="yes" xml:space="preserve">
          <source>String appended to the names of the fields of r2 that are present in r1 but absent of the key.</source>
          <target state="translated">附加到r2中存在于r1中但键不存在的字段名的字符串。</target>
        </trans-unit>
        <trans-unit id="2e9197f99b1939b8ff77cd228aa2b591342615e8" translate="yes" xml:space="preserve">
          <source>String arguments</source>
          <target state="translated">字符串参数</target>
        </trans-unit>
        <trans-unit id="34123bf351844b619c4dbfc6727ace35b50b4db7" translate="yes" xml:space="preserve">
          <source>String containing words to look for.</source>
          <target state="translated">包含要找的词的字符串。</target>
        </trans-unit>
        <trans-unit id="4df4e94946ef158e4c1e5b716aaee91f272b4a7e" translate="yes" xml:space="preserve">
          <source>String formatting</source>
          <target state="translated">字符串格式化</target>
        </trans-unit>
        <trans-unit id="92531b336e4e7bb6a1d7d30a01f8111947fec115" translate="yes" xml:space="preserve">
          <source>String information</source>
          <target state="translated">字符串信息</target>
        </trans-unit>
        <trans-unit id="c2b35fa4d37ee8a6b4bd38cea3798cc9fbf4cba7" translate="yes" xml:space="preserve">
          <source>String integers specify the axis to concatenate along or the minimum number of dimensions to force entries into.</source>
          <target state="translated">字符串整数指定了要连接的轴或强制输入的最小尺寸数。</target>
        </trans-unit>
        <trans-unit id="f501c85c352da3ec100086db122d9f22d122b32e" translate="yes" xml:space="preserve">
          <source>String of length &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">长度为 &lt;code&gt;length&lt;/code&gt; 的字符串。</target>
        </trans-unit>
        <trans-unit id="766f45c1227c8c7d13e31b3c8218c7c441dc99b1" translate="yes" xml:space="preserve">
          <source>String operations</source>
          <target state="translated">字符串操作</target>
        </trans-unit>
        <trans-unit id="b92216b3243250ff57b76e23d2f013b608ec0972" translate="yes" xml:space="preserve">
          <source>String or character separating columns.</source>
          <target state="translated">分列的字符串或字符。</target>
        </trans-unit>
        <trans-unit id="791d1bdb2ea8c1e1e2ac650ffdc82b6e091407c9" translate="yes" xml:space="preserve">
          <source>String or character separating lines.</source>
          <target state="translated">分隔线的字符串或字符。</target>
        </trans-unit>
        <trans-unit id="5bf0b490a78803009321c9fbedd01bde002ba5bc" translate="yes" xml:space="preserve">
          <source>String or sequence of strings corresponding to the names of the fields to drop.</source>
          <target state="translated">与要删除的字段名称相对应的字符串或字符串序列。</target>
        </trans-unit>
        <trans-unit id="3963028df99dc7715d5baee7dd3364c748e67766" translate="yes" xml:space="preserve">
          <source>String or sequence of strings corresponding to the names of the new fields.</source>
          <target state="translated">与新字段名称相对应的字符串或字符串序列。</target>
        </trans-unit>
        <trans-unit id="b2c574a7189a987a1b45d751ffbabcb3c43118c9" translate="yes" xml:space="preserve">
          <source>String representation of &lt;a href=&quot;../arrays.scalars#numpy.number&quot;&gt;&lt;code&gt;number&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;base&lt;/code&gt; system.</source>
          <target state="translated">的字符串表示&lt;a href=&quot;../arrays.scalars#numpy.number&quot;&gt; &lt;code&gt;number&lt;/code&gt; &lt;/a&gt;在 &lt;code&gt;base&lt;/code&gt; 系统。</target>
        </trans-unit>
        <trans-unit id="070445e0a7bd458bdad35ce8dcb2d1d0173ff69e" translate="yes" xml:space="preserve">
          <source>String representation of &lt;code&gt;number&lt;/code&gt; in &lt;code&gt;base&lt;/code&gt; system.</source>
          <target state="translated">的字符串表示 &lt;code&gt;number&lt;/code&gt; 在 &lt;code&gt;base&lt;/code&gt; 系统。</target>
        </trans-unit>
        <trans-unit id="2e31e8b091806f3d1f281cc4ba782be9fda82868" translate="yes" xml:space="preserve">
          <source>String representation of floating point infinity (default inf).</source>
          <target state="translated">浮点无穷大的字符串表示(默认为inf)。</target>
        </trans-unit>
        <trans-unit id="01373c57fb8fe982545c8617e4790c9bba32d3bd" translate="yes" xml:space="preserve">
          <source>String representation of floating point not-a-number (default nan).</source>
          <target state="translated">浮点数not-a-number的字符串表示(默认为nan)。</target>
        </trans-unit>
        <trans-unit id="9f3842d201b21eb0e7888c9c3d9a2c881516b8c4" translate="yes" xml:space="preserve">
          <source>String representation of the array.</source>
          <target state="translated">数组的字符串表示。</target>
        </trans-unit>
        <trans-unit id="4db97d521f52ac6d93080543eb6b74577ba23cc3" translate="yes" xml:space="preserve">
          <source>String representations:</source>
          <target state="translated">字符串表示。</target>
        </trans-unit>
        <trans-unit id="e0d061a82ce8af858bef95987cfb2e899639d475" translate="yes" xml:space="preserve">
          <source>String that will be prepended to the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;footer&lt;/code&gt; strings, to mark them as comments. Default: &amp;lsquo;# &amp;lsquo;, as expected by e.g. &lt;code&gt;numpy.loadtxt&lt;/code&gt;.</source>
          <target state="translated">将在 &lt;code&gt;header&lt;/code&gt; 和 &lt;code&gt;footer&lt;/code&gt; 字符串之前添加的字符串，以将其标记为注释。默认值：&amp;ldquo;＃&amp;rdquo;，例如 &lt;code&gt;numpy.loadtxt&lt;/code&gt; 所期望的。</target>
        </trans-unit>
        <trans-unit id="29161ee7a7a15a1abaf0f1612beb0eae4baa01d7" translate="yes" xml:space="preserve">
          <source>String that will be written at the beginning of the file.</source>
          <target state="translated">写在文件开头的字符串。</target>
        </trans-unit>
        <trans-unit id="5c5d64e1c727d0403596e9c5ea3308951b6f9d69" translate="yes" xml:space="preserve">
          <source>String that will be written at the end of the file.</source>
          <target state="translated">将写在文件末尾的字符串。</target>
        </trans-unit>
        <trans-unit id="65875ffed7d9c75f6fe284ddd93f194bd7eecd53" translate="yes" xml:space="preserve">
          <source>String used in lieu of missing data when a masked array is printed. By default, this string is &lt;code&gt;'--'&lt;/code&gt;.</source>
          <target state="translated">打印掩码数组时使用的字符串代替丢失的数据。默认情况下，此字符串为 &lt;code&gt;'--'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e619565781aeac87df5988755d8308bf2c9d2598" translate="yes" xml:space="preserve">
          <source>String with comma-separated fields</source>
          <target state="translated">逗号分隔的字符串</target>
        </trans-unit>
        <trans-unit id="70f2192ce102bd881643cbec0959f90e05d94515" translate="yes" xml:space="preserve">
          <source>Strings are also a scalar type:</source>
          <target state="translated">字符串也是一种标量类型。</target>
        </trans-unit>
        <trans-unit id="025562ddbed3dad7a75bf305224aa0613cc95adf" translate="yes" xml:space="preserve">
          <source>Structural indexing tools</source>
          <target state="translated">结构性索引工具</target>
        </trans-unit>
        <trans-unit id="e3ede8ae87a5a729acffafa15db76210d17aa723" translate="yes" xml:space="preserve">
          <source>Structure Comparison</source>
          <target state="translated">结构比较</target>
        </trans-unit>
        <trans-unit id="c475f22df4d51f1c694f4e8b82c1dd74e7d4395b" translate="yes" xml:space="preserve">
          <source>Structured &lt;a href=&quot;#numpy.void&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/a&gt; scalars can only be constructed via extraction from &lt;a href=&quot;../user/basics.rec#structured-arrays&quot;&gt;Structured arrays&lt;/a&gt;:</source>
          <target state="translated">结构化&lt;a href=&quot;#numpy.void&quot;&gt; &lt;code&gt;void&lt;/code&gt; &lt;/a&gt;标量只能通过从&lt;a href=&quot;../user/basics.rec#structured-arrays&quot;&gt;结构化数组中&lt;/a&gt;提取来构造：</target>
        </trans-unit>
        <trans-unit id="ee01ace9a33011b4e2e528c088a784d76eaefcf9" translate="yes" xml:space="preserve">
          <source>Structured &lt;code&gt;dtype&lt;/code&gt; objects can be indexed with multiple fields names</source>
          <target state="translated">可以使用多个字段名称来索引结构化 &lt;code&gt;dtype&lt;/code&gt; 对象</target>
        </trans-unit>
        <trans-unit id="1520da6d2d936a8bd0f22ba817625147b591a57d" translate="yes" xml:space="preserve">
          <source>Structured Datatype Creation</source>
          <target state="translated">结构化数据类型创建</target>
        </trans-unit>
        <trans-unit id="4f59e528dc3bc2a58ccace788dd71fad8e33ad21" translate="yes" xml:space="preserve">
          <source>Structured Datatypes</source>
          <target state="translated">结构化数据类型</target>
        </trans-unit>
        <trans-unit id="7896426a8d21b91891b59c18e2d68b7b2a456f68" translate="yes" xml:space="preserve">
          <source>Structured array for which to apply func.</source>
          <target state="translated">适用于func的结构化数组。</target>
        </trans-unit>
        <trans-unit id="9017b7fa0fc7c65db95140441edbe12b0b3b19e5" translate="yes" xml:space="preserve">
          <source>Structured array or dtype to convert. Cannot contain object datatype.</source>
          <target state="translated">要转换的结构化数组或dtype。不能包含对象数据类型。</target>
        </trans-unit>
        <trans-unit id="c5690b1975e9db6337f5e8803f19ce3e684e4c7f" translate="yes" xml:space="preserve">
          <source>Structured array with fewer dimensions.</source>
          <target state="translated">结构化的数组,维度较少。</target>
        </trans-unit>
        <trans-unit id="100bd7609a857d45a4a47e5a45ddd93a22acfb34" translate="yes" xml:space="preserve">
          <source>Structured arrays</source>
          <target state="translated">结构化数组</target>
        </trans-unit>
        <trans-unit id="6bec79a6913cf5ec32ba9f585d2c682833361c77" translate="yes" xml:space="preserve">
          <source>Structured arrays are ndarrays whose datatype is a composition of simpler datatypes organized as a sequence of named &lt;a href=&quot;../glossary#term-field&quot;&gt;fields&lt;/a&gt;. For example,</source>
          <target state="translated">结构化数组是ndarray，其数据类型是由一些简单的数据类型组成的结构，这些数据类型组织为一系列命名&lt;a href=&quot;../glossary#term-field&quot;&gt;字段&lt;/a&gt;。例如，</target>
        </trans-unit>
        <trans-unit id="abee4933ed6df48a826b4ec24a053bf896cc2409" translate="yes" xml:space="preserve">
          <source>Structured arrays are sorted lexically by &lt;code&gt;argsort&lt;/code&gt;:</source>
          <target state="translated">结构化数组由 &lt;code&gt;argsort&lt;/code&gt; 按词法排序：</target>
        </trans-unit>
        <trans-unit id="5159a7dd665ced2e100370992bcf1539f3126846" translate="yes" xml:space="preserve">
          <source>Structured arrays can also be assigned to unstructured arrays, but only if the structured datatype has just a single field:</source>
          <target state="translated">结构化数组也可以分配给非结构化数组,但前提是结构化数据类型只有一个字段。</target>
        </trans-unit>
        <trans-unit id="f67ef4d80561aaaf60344e6fb29a5ab9f31295d6" translate="yes" xml:space="preserve">
          <source>Structured arrays indexed with non-existent fields raise &lt;code&gt;KeyError&lt;/code&gt; not &lt;code&gt;ValueError&lt;/code&gt;</source>
          <target state="translated">用不存在的字段索引的结构化数组引发 &lt;code&gt;KeyError&lt;/code&gt; 而不是 &lt;code&gt;ValueError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b043e88113de27795d789deafd7320abb4b7fdb" translate="yes" xml:space="preserve">
          <source>Structured arrays.</source>
          <target state="translated">结构化数组。</target>
        </trans-unit>
        <trans-unit id="3afe855ad262a7516ddbebc2077f0e2c93c19240" translate="yes" xml:space="preserve">
          <source>Structured data types are formed by creating a data type whose &lt;a href=&quot;../glossary#term-field&quot;&gt;field&lt;/a&gt; contain other data types. Each field has a name by which it can be &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;accessed&lt;/a&gt;. The parent data type should be of sufficient size to contain all its fields; the parent is nearly always based on the &lt;a href=&quot;arrays.scalars#numpy.void&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/a&gt; type which allows an arbitrary item size. Structured data types may also contain nested structured sub-array data types in their fields.</source>
          <target state="translated">通过创建其&lt;a href=&quot;../glossary#term-field&quot;&gt;字段&lt;/a&gt;包含其他数据类型的数据类型来形成结构化数据类型。每个字段都有一个可以&lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;访问&lt;/a&gt;的名称。父数据类型的大小应足以容纳其所有字段。父对象几乎总是基于可以允许任意项目大小的&lt;a href=&quot;arrays.scalars#numpy.void&quot;&gt; &lt;code&gt;void&lt;/code&gt; &lt;/a&gt;类型。结构化数据类型还可以在其字段中包含嵌套的结构化子数组数据类型。</target>
        </trans-unit>
        <trans-unit id="83f9bc65f5fce31cd776de3d718987b80efd194a" translate="yes" xml:space="preserve">
          <source>Structured data types are formed by creating a data type whose &lt;a href=&quot;../glossary#term-field&quot;&gt;field&lt;/a&gt; contain other data types. Each field has a name by which it can be &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;accessed&lt;/a&gt;. The parent data type should be of sufficient size to contain all its fields; the parent is nearly always based on the &lt;code&gt;void&lt;/code&gt; type which allows an arbitrary item size. Structured data types may also contain nested structured sub-array data types in their fields.</source>
          <target state="translated">通过创建其&lt;a href=&quot;../glossary#term-field&quot;&gt;字段&lt;/a&gt;包含其他数据类型的数据类型来形成结构化数据类型。每个字段都有一个可以&lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;访问&lt;/a&gt;的名称。父数据类型的大小应足以容纳其所有字段。父对象几乎总是基于可以允许任意项目大小的 &lt;code&gt;void&lt;/code&gt; 类型。结构化数据类型还可以在其字段中包含嵌套的结构化子数组数据类型。</target>
        </trans-unit>
        <trans-unit id="f15140621e0cd4e0f0fe72960c228d9f03950ae6" translate="yes" xml:space="preserve">
          <source>Structured data types are formed by creating a data type whose &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;field&lt;/a&gt; contain other data types. Each field has a name by which it can be &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;accessed&lt;/a&gt;. The parent data type should be of sufficient size to contain all its fields; the parent is nearly always based on the &lt;code&gt;void&lt;/code&gt; type which allows an arbitrary item size. Structured data types may also contain nested structured sub-array data types in their fields.</source>
          <target state="translated">通过创建其&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;字段&lt;/a&gt;包含其他数据类型的数据类型来形成结构化数据类型。每个字段都有一个可以&lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;访问&lt;/a&gt;的名称。父数据类型的大小应足以容纳其所有字段；父级几乎总是基于允许任意项目大小的 &lt;code&gt;void&lt;/code&gt; 类型。结构化数据类型还可以在其字段中包含嵌套的结构化子数组数据类型。</target>
        </trans-unit>
        <trans-unit id="1db5d72ed0ef809181a6b4792660521a677761d3" translate="yes" xml:space="preserve">
          <source>Structured datatypes are designed to be able to mimic &amp;lsquo;structs&amp;rsquo; in the C language, and share a similar memory layout. They are meant for interfacing with C code and for low-level manipulation of structured buffers, for example for interpreting binary blobs. For these purposes they support specialized features such as subarrays, nested datatypes, and unions, and allow control over the memory layout of the structure.</source>
          <target state="translated">结构化数据类型旨在模仿C语言中的&amp;ldquo;结构&amp;rdquo;，并共享相似的内存布局。它们旨在与C代码接口以及对结构化缓冲区的低级操作，例如，用于解释二进制Blob。为此，它们支持特殊功能，例如子数组，嵌套数据类型和联合，并允许控制结构的内存布局。</target>
        </trans-unit>
        <trans-unit id="6430d9960863ffd1da1c228ca6625d7a868c86b1" translate="yes" xml:space="preserve">
          <source>Structured datatypes are implemented in numpy to have base type &lt;a href=&quot;../reference/arrays.scalars#numpy.void&quot;&gt;&lt;code&gt;numpy.void&lt;/code&gt;&lt;/a&gt; by default, but it is possible to interpret other numpy types as structured types using the &lt;code&gt;(base_dtype, dtype)&lt;/code&gt; form of dtype specification described in &lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes-constructing&quot;&gt;Data Type Objects&lt;/a&gt;. Here, &lt;code&gt;base_dtype&lt;/code&gt; is the desired underlying dtype, and fields and flags will be copied from &lt;code&gt;dtype&lt;/code&gt;. This dtype is similar to a &amp;lsquo;union&amp;rsquo; in C.</source>
          <target state="translated">默认情况下，结构化数据类型在numpy中实现为具有基本类型&lt;a href=&quot;../reference/arrays.scalars#numpy.void&quot;&gt; &lt;code&gt;numpy.void&lt;/code&gt; &lt;/a&gt;，但是可以使用&lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes-constructing&quot;&gt;数据类型对象中&lt;/a&gt;描述的 &lt;code&gt;(base_dtype, dtype)&lt;/code&gt; 规范的（base_dtype，dtype）形式将其他numpy类型解释为结构化类型。这里， &lt;code&gt;base_dtype&lt;/code&gt; 是所需的底层D型细胞，和字段和标志将从复制 &lt;code&gt;dtype&lt;/code&gt; 。此dtype类似于C中的&amp;ldquo;联合&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="35ae44b4e9475697a4a50339f6e2ae5fa9e282a4" translate="yes" xml:space="preserve">
          <source>Structured datatypes are implemented in numpy to have base type &lt;code&gt;numpy.void&lt;/code&gt; by default, but it is possible to interpret other numpy types as structured types using the &lt;code&gt;(base_dtype, dtype)&lt;/code&gt; form of dtype specification described in &lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes-constructing&quot;&gt;Data Type Objects&lt;/a&gt;. Here, &lt;code&gt;base_dtype&lt;/code&gt; is the desired underlying dtype, and fields and flags will be copied from &lt;code&gt;dtype&lt;/code&gt;. This dtype is similar to a &amp;lsquo;union&amp;rsquo; in C.</source>
          <target state="translated">默认情况下，结构化数据类型在numpy中实现为具有基本类型 &lt;code&gt;numpy.void&lt;/code&gt; ，但是可以使用&lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes-constructing&quot;&gt;数据类型对象中&lt;/a&gt;描述的 &lt;code&gt;(base_dtype, dtype)&lt;/code&gt; 规范的（base_dtype，dtype）形式将其他numpy类型解释为结构化类型。这里， &lt;code&gt;base_dtype&lt;/code&gt; 是所需的底层D型细胞，和字段和标志将从复制 &lt;code&gt;dtype&lt;/code&gt; 。此dtype类似于C中的&amp;ldquo;联合&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c5f3d86c3ad0938e801983471d9d88dc5223acd7" translate="yes" xml:space="preserve">
          <source>Structured datatypes may be created using the function &lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt;. There are 4 alternative forms of specification which vary in flexibility and conciseness. These are further documented in the &lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes-constructing&quot;&gt;Data Type Objects&lt;/a&gt; reference page, and in summary they are:</source>
          <target state="translated">可以使用函数&lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;numpy.dtype&lt;/code&gt; &lt;/a&gt;创建结构化数据类型。规范有4种替代形式，其灵活性和简洁性各不相同。这些在&amp;ldquo;&lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes-constructing&quot;&gt;数据类型对象&amp;rdquo;&lt;/a&gt;参考页面中有进一步的记录，概括而言，它们是：</target>
        </trans-unit>
        <trans-unit id="6624b07c38a844e59271b0a0c26ed454ac19dbe9" translate="yes" xml:space="preserve">
          <source>Structured type, one field name &amp;lsquo;f1&amp;rsquo;, containing int16:</source>
          <target state="translated">结构化类型，一个字段名称'f1'，包含int16：</target>
        </trans-unit>
        <trans-unit id="d2e117ca328d87720528f1cfaf8d8960167ffb11" translate="yes" xml:space="preserve">
          <source>Structured type, one field named &amp;lsquo;f1&amp;rsquo;, in itself containing a structured type with one field:</source>
          <target state="translated">结构化类型，一个名为&amp;ldquo; f1&amp;rdquo;的字段，其本身包含具有一个字段的结构化类型：</target>
        </trans-unit>
        <trans-unit id="58f4a5191b04c275b13b1266e03ae0e69f92c2c1" translate="yes" xml:space="preserve">
          <source>Structured type, two fields: the first field contains an unsigned int, the second an int32:</source>
          <target state="translated">结构化类型,两个字段:第一个字段包含一个无符号int,第二个字段包含一个int32。</target>
        </trans-unit>
        <trans-unit id="ca4456203ca66897ff0941bbafc31276906d7671" translate="yes" xml:space="preserve">
          <source>Structured view(s) of &lt;a href=&quot;numpy.nditer.operands#numpy.nditer.operands&quot;&gt;&lt;code&gt;operands&lt;/code&gt;&lt;/a&gt; in memory, matching the reordered and optimized iterator access pattern. Valid only before the iterator is closed.</source>
          <target state="translated">内存中&lt;a href=&quot;numpy.nditer.operands#numpy.nditer.operands&quot;&gt; &lt;code&gt;operands&lt;/code&gt; &lt;/a&gt;结构化视图，与重新排序和优化的迭代器访问模式匹配。仅在关闭迭代器之前有效。</target>
        </trans-unit>
        <trans-unit id="64b82b877494406e2f3a32e02b06a27f71eea3a4" translate="yes" xml:space="preserve">
          <source>Style Guide for C Code</source>
          <target state="translated">C代码风格指南</target>
        </trans-unit>
        <trans-unit id="01d5cb7a8cd071c4380d4985485547b9c9160ad6" translate="yes" xml:space="preserve">
          <source>Style Guide for Python Code</source>
          <target state="translated">Python代码风格指南</target>
        </trans-unit>
        <trans-unit id="0404cfe2117190faccc065f3c4e76c4322b57e18" translate="yes" xml:space="preserve">
          <source>Stylistic Guidelines</source>
          <target state="translated">风格准则</target>
        </trans-unit>
        <trans-unit id="803fd087e54001bfefdde2c389864825258535d4" translate="yes" xml:space="preserve">
          <source>Sub-arrays always have a C-contiguous memory layout.</source>
          <target state="translated">子数组的内存布局总是C型连续的。</target>
        </trans-unit>
        <trans-unit id="b5f988ec613aba03f62b8fb5c8cfc27a7a1a6d0f" translate="yes" xml:space="preserve">
          <source>Sub-optimal &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (due to repeated path calculation time): ~330ms</source>
          <target state="translated">次优&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;（由于重复的路径计算时间）：〜330ms</target>
        </trans-unit>
        <trans-unit id="55af143d1bbc195dac68e528a5caca790b79468f" translate="yes" xml:space="preserve">
          <source>Subclasses of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; are preserved except for the &amp;lsquo;raw&amp;rsquo; mode. So if &lt;code&gt;a&lt;/code&gt; is of type &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, all the return values will be matrices too.</source>
          <target state="translated">除&amp;ldquo;原始&amp;rdquo;模式外，保留&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 的&lt;/a&gt;子类。因此，如果 &lt;code&gt;a&lt;/code&gt; 为&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;类型，则所有返回值也将为矩阵。</target>
        </trans-unit>
        <trans-unit id="fa0a23c0a00071a5375730590cb136590b810c95" translate="yes" xml:space="preserve">
          <source>Subclasses of &lt;code&gt;ndarray&lt;/code&gt; are preserved except for the &amp;lsquo;raw&amp;rsquo; mode. So if &lt;code&gt;a&lt;/code&gt; is of type &lt;code&gt;matrix&lt;/code&gt;, all the return values will be matrices too.</source>
          <target state="translated">除&amp;ldquo;原始&amp;rdquo;模式外，保留 &lt;code&gt;ndarray&lt;/code&gt; 的子类。因此，如果 &lt;code&gt;a&lt;/code&gt; 为 &lt;code&gt;matrix&lt;/code&gt; 类型，则所有返回值也将为矩阵。</target>
        </trans-unit>
        <trans-unit id="a9ce918753c36dd7a183b105790cb0ccc1e3d737" translate="yes" xml:space="preserve">
          <source>Subclassing a &lt;code&gt;numpy.ndarray&lt;/code&gt; is possible but if your goal is to create an array with &lt;em&gt;modified&lt;/em&gt; behavior, as do dask arrays for distributed computation and cupy arrays for GPU-based computation, subclassing is discouraged. Instead, using numpy&amp;rsquo;s &lt;a href=&quot;../user/basics.dispatch#basics-dispatch&quot;&gt;dispatch mechanism&lt;/a&gt; is recommended.</source>
          <target state="translated">可以对 &lt;code&gt;numpy.ndarray&lt;/code&gt; 进行子类化，但是如果您的目标是创建具有&lt;em&gt;修改后&lt;/em&gt;行为的数组（例如，用于分布式计算的dask数组和用于基于GPU的计算的cupy数组），则不建议使用子类化。相反，建议使用numpy的&lt;a href=&quot;../user/basics.dispatch#basics-dispatch&quot;&gt;调度机制&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d147ab8047bc6066411af552791a9504b59a189" translate="yes" xml:space="preserve">
          <source>Subclassing a &lt;code&gt;numpy.ndarray&lt;/code&gt; is possible but if your goal is to create an array with &lt;em&gt;modified&lt;/em&gt; behavior, as do dask arrays for distributed computation and cupy arrays for GPU-based computation, subclassing is discouraged. Instead, using numpy&amp;rsquo;s &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.dispatch.html#basics-dispatch&quot;&gt;dispatch mechanism&lt;/a&gt; is recommended.</source>
          <target state="translated">可以对 &lt;code&gt;numpy.ndarray&lt;/code&gt; 进行子类化，但是如果您的目标是创建具有&lt;em&gt;经过修改的&lt;/em&gt;行为的数组（例如，用于分布式计算的dask数组和用于基于GPU的计算的cupy数组），则不建议使用子类化。相反，建议使用numpy的&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.dispatch.html#basics-dispatch&quot;&gt;调度机制&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="272f065bb249898427d153b9ddec706f4a4c8ea8" translate="yes" xml:space="preserve">
          <source>Subclassing and Downstream Compatibility</source>
          <target state="translated">子类化和下游兼容性</target>
        </trans-unit>
        <trans-unit id="cee47368b2544d06d66a7be14203632ad1161eec" translate="yes" xml:space="preserve">
          <source>Subclassing is preserved. This means that if, e.g., the data part of the masked array is a recarray, &lt;a href=&quot;#numpy.ma.MaskedArray.filled&quot;&gt;&lt;code&gt;filled&lt;/code&gt;&lt;/a&gt; returns a recarray:</source>
          <target state="translated">子类保留。这意味着，如果，例如，掩蔽阵列的数据部分是一个recarray，&lt;a href=&quot;#numpy.ma.MaskedArray.filled&quot;&gt; &lt;code&gt;filled&lt;/code&gt; &lt;/a&gt;返回一个recarray：</target>
        </trans-unit>
        <trans-unit id="33bc88cf96b41fa0646c461894f505af99f67ac1" translate="yes" xml:space="preserve">
          <source>Subclassing is preserved. This means that if, e.g., the data part of the masked array is a recarray, &lt;a href=&quot;numpy.ma.filled#numpy.ma.filled&quot;&gt;&lt;code&gt;filled&lt;/code&gt;&lt;/a&gt; returns a recarray:</source>
          <target state="translated">子类保留。这意味着，如果，例如，掩蔽阵列的数据部分是一个recarray，&lt;a href=&quot;numpy.ma.filled#numpy.ma.filled&quot;&gt; &lt;code&gt;filled&lt;/code&gt; &lt;/a&gt;返回一个recarray：</target>
        </trans-unit>
        <trans-unit id="dcd026d87f16ab5d865099378d38748e1049d4d8" translate="yes" xml:space="preserve">
          <source>Subclassing ndarray</source>
          <target state="translated">ndarray的子类</target>
        </trans-unit>
        <trans-unit id="b7c286e3d93f3ece394b3827e135e8a12233cdf1" translate="yes" xml:space="preserve">
          <source>Subclassing ndarray is complicated by the fact that new instances of ndarray classes can come about in three different ways. These are:</source>
          <target state="translated">由于ndarray类的新实例可以通过三种不同的方式产生,所以对ndarray进行子类化是很复杂的。这三种方式是:</target>
        </trans-unit>
        <trans-unit id="9a44ddbc8fd0076edc9e53d1235eba11c7929dc0" translate="yes" xml:space="preserve">
          <source>Subclassing ndarray is relatively simple, but it has some complications compared to other Python objects. On this page we explain the machinery that allows you to subclass ndarray, and the implications for implementing a subclass.</source>
          <target state="translated">子类化ndarray相对简单,但与其他Python对象相比,它有一些复杂的地方。在本页中,我们将解释允许您对ndarray进行子类化的机制,以及实现子类的意义。</target>
        </trans-unit>
        <trans-unit id="63f32464b42a864e77739b2bee513b261ea02191" translate="yes" xml:space="preserve">
          <source>Subcommittees</source>
          <target state="translated">Subcommittees</target>
        </trans-unit>
        <trans-unit id="d9952117e8cb53d0fd7ca6ba7d99ad537965d8c9" translate="yes" xml:space="preserve">
          <source>Subdivide &lt;code&gt;int16&lt;/code&gt; into 2 &lt;code&gt;int8&lt;/code&gt;&amp;rsquo;s, called x and y. 0 and 1 are the offsets in bytes:</source>
          <target state="translated">将 &lt;code&gt;int16&lt;/code&gt; 细分为2个 &lt;code&gt;int8&lt;/code&gt; ，分别称为x和y。0和1是字节偏移量：</target>
        </trans-unit>
        <trans-unit id="7cd760711c541e202c788fb098af0b33b391721e" translate="yes" xml:space="preserve">
          <source>Subsequence with trailing zeros removed. If the resulting sequence would be empty, return the first element. The returned sequence may or may not be a view.</source>
          <target state="translated">去掉尾部零的子序列。如果生成的序列为空,返回第一个元素。返回的序列可能是也可能不是视图。</target>
        </trans-unit>
        <trans-unit id="97ff96af5de437e8628eccf16dfbbe360cbfcf72" translate="yes" xml:space="preserve">
          <source>Substantial portions of this document were adapted from the &lt;a href=&quot;https://github.com/jupyter/governance&quot;&gt;Jupyter/IPython project&amp;rsquo;s governance document&lt;/a&gt;</source>
          <target state="translated">本文档的大部分内容摘自&lt;a href=&quot;https://github.com/jupyter/governance&quot;&gt;Jupyter / IPython项目的管理文档&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c763109714f2536fc1c4a6c89fdf2646454177e1" translate="yes" xml:space="preserve">
          <source>Substantial portions of this document were adapted from the &lt;a href=&quot;https://github.com/jupyter/governance/blob/master/governance.md&quot;&gt;Jupyter/IPython project&amp;rsquo;s governance document&lt;/a&gt;.</source>
          <target state="translated">本文档的大部分内容摘自&lt;a href=&quot;https://github.com/jupyter/governance/blob/master/governance.md&quot;&gt;Jupyter / IPython项目的管理文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="259ff26648e77d2b9a5ec16a4f186ec8e1c65753" translate="yes" xml:space="preserve">
          <source>Substitute a polynomial for x and expand the result. Here we substitute p in itself leading to a new polynomial of degree 4 after expansion. If the polynomials are regarded as functions this is composition of functions:</source>
          <target state="translated">将一个多项式代入x,然后展开结果。这里我们将p代入本身,展开后得到一个新的4度多项式。如果将多项式视为函数,这就是函数的组成。</target>
        </trans-unit>
        <trans-unit id="8d18e7a773fc8ec030ec151dbf7cd596c836697a" translate="yes" xml:space="preserve">
          <source>Substitution:</source>
          <target state="translated">Substitution:</target>
        </trans-unit>
        <trans-unit id="976370d3324e5eaaec19ed99a261ec090486b0fa" translate="yes" xml:space="preserve">
          <source>Subtract arguments, element-wise.</source>
          <target state="translated">减去参数,元素方面。</target>
        </trans-unit>
        <trans-unit id="8567fbb4d729f4cd5b7fbe5674c01c465635fa47" translate="yes" xml:space="preserve">
          <source>Subtract one Chebyshev series from another.</source>
          <target state="translated">从另一个切比雪夫数列中减去一个。</target>
        </trans-unit>
        <trans-unit id="a494f472ea255a2aaa4f1c8f52b90c62196690f5" translate="yes" xml:space="preserve">
          <source>Subtract one Hermite series from another.</source>
          <target state="translated">从另一个Hermite系列中减去一个。</target>
        </trans-unit>
        <trans-unit id="60b31c93b32c6d82ec367e99b58e2a7fd1690435" translate="yes" xml:space="preserve">
          <source>Subtract one Laguerre series from another.</source>
          <target state="translated">从另一个Laguerre系列中减去一个。</target>
        </trans-unit>
        <trans-unit id="09477810015d786e3a1ce0d9827bfd9d00039de6" translate="yes" xml:space="preserve">
          <source>Subtract one Legendre series from another.</source>
          <target state="translated">从另一个Legendre系列中减去一个。</target>
        </trans-unit>
        <trans-unit id="a2407a57a6647eba13b915586134c7e1d7534217" translate="yes" xml:space="preserve">
          <source>Subtract one polynomial from another.</source>
          <target state="translated">用一个多项式减去另一个多项式。</target>
        </trans-unit>
        <trans-unit id="5de67be97d964e12a293477e154e8fa146741938" translate="yes" xml:space="preserve">
          <source>Subtract other from self in-place.</source>
          <target state="translated">从自己身上原地减去其他。</target>
        </trans-unit>
        <trans-unit id="b3957443ea74659d4523c7bc9e466d304ba155cf" translate="yes" xml:space="preserve">
          <source>Subtract other from self, and return a new masked array.</source>
          <target state="translated">从self中减去other,并返回一个新的掩码数组。</target>
        </trans-unit>
        <trans-unit id="6cf676697a4c117ec3074a618da8a2b0fca9cd14" translate="yes" xml:space="preserve">
          <source>Subtract self from other, and return a new masked array.</source>
          <target state="translated">从other中减去self,并返回一个新的掩码数组。</target>
        </trans-unit>
        <trans-unit id="77a74ccf7fd60ada9c57d2300edad576a2eb6285" translate="yes" xml:space="preserve">
          <source>Subtyping the ndarray in C</source>
          <target state="translated">在C语言中对ndarray进行子类型化。</target>
        </trans-unit>
        <trans-unit id="d0b818b7784e48b243d98be89f763b62cb9fc7bd" translate="yes" xml:space="preserve">
          <source>Successfully tested on:</source>
          <target state="translated">成功测试上。</target>
        </trans-unit>
        <trans-unit id="7f477dc5121884706ef8fed21e4d11c24e6db091" translate="yes" xml:space="preserve">
          <source>Sum across array propagating NaNs.</source>
          <target state="translated">整个阵列传播NaNs的总和。</target>
        </trans-unit>
        <trans-unit id="b2cc82eaee79a7562889de3502bb827b013693aa" translate="yes" xml:space="preserve">
          <source>Sum along diagonals.</source>
          <target state="translated">沿对角线求和。</target>
        </trans-unit>
        <trans-unit id="b221abad8e52361732192c7acb9613f67b076ac3" translate="yes" xml:space="preserve">
          <source>Sum array elements.</source>
          <target state="translated">数组元素之和。</target>
        </trans-unit>
        <trans-unit id="96c00e26cd369dd11b081a1035d4633225e7965d" translate="yes" xml:space="preserve">
          <source>Sum of array elements over a given axis.</source>
          <target state="translated">给定轴上的数组元素之和。</target>
        </trans-unit>
        <trans-unit id="6302a8aa98d30db8a3e7186cb73eb9e4337d618b" translate="yes" xml:space="preserve">
          <source>Sum over an axis (requires explicit form):</source>
          <target state="translated">在一个轴上求和(需要明确的形式)。</target>
        </trans-unit>
        <trans-unit id="1c979daf2b6e4cef98bd537ad236de258dbc0d5a" translate="yes" xml:space="preserve">
          <source>Sum over axes 0 and 2. The result has same number of dimensions as the original array:</source>
          <target state="translated">在0轴和2轴上求和。结果与原数组的维数相同。</target>
        </trans-unit>
        <trans-unit id="1103f1f7acbd2c5b9349bcbddbb45121fae537eb" translate="yes" xml:space="preserve">
          <source>Sum products over arbitrary axes.</source>
          <target state="translated">在任意轴上求积。</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="bf661fd6213ae079ce34c2c9dd00db526c359e2b" translate="yes" xml:space="preserve">
          <source>Sums of residuals; squared Euclidean 2-norm for each column in &lt;code&gt;b - a*x&lt;/code&gt;. If the rank of &lt;code&gt;a&lt;/code&gt; is &amp;lt; N or M &amp;lt;= N, this is an empty array. If &lt;code&gt;b&lt;/code&gt; is 1-dimensional, this is a (1,) shape array. Otherwise the shape is (K,).</source>
          <target state="translated">残差之和； &lt;code&gt;b - a*x&lt;/code&gt; 每一列的平方欧几里德2-范数。如果秩 &lt;code&gt;a&lt;/code&gt; 是&amp;lt;N或M &amp;lt;= N，这是一个空数组。如果 &lt;code&gt;b&lt;/code&gt; 为一维，则为（1，）形状数组。否则，形状为（K，）。</target>
        </trans-unit>
        <trans-unit id="2f33a7a1cb4338af5c5245b28f2bd71c178caccc" translate="yes" xml:space="preserve">
          <source>Sums of squared residuals: Squared Euclidean 2-norm for each column in &lt;code&gt;b - a @ x&lt;/code&gt;. If the rank of &lt;code&gt;a&lt;/code&gt; is &amp;lt; N or M &amp;lt;= N, this is an empty array. If &lt;code&gt;b&lt;/code&gt; is 1-dimensional, this is a (1,) shape array. Otherwise the shape is (K,).</source>
          <target state="translated">残差平方和： &lt;code&gt;b - a @ x&lt;/code&gt; 每列的平方欧几里德2-范数。如果秩 &lt;code&gt;a&lt;/code&gt; 是&amp;lt;N或M &amp;lt;= N，这是一个空数组。如果 &lt;code&gt;b&lt;/code&gt; 为一维，则为（1，）形状数组。否则，形状为（K，）。</target>
        </trans-unit>
        <trans-unit id="b6c71b95244ccde5ac8df906b9633b9278b04563" translate="yes" xml:space="preserve">
          <source>Sums, products, differences</source>
          <target state="translated">总和、产品、差异</target>
        </trans-unit>
        <trans-unit id="56cedb0b6384ebe895f048d3113a97e19adce9ed" translate="yes" xml:space="preserve">
          <source>SunOS 5.9, Python 2.2, 2.3.2</source>
          <target state="translated">SunOS 5.9,Python 2.2,2.3.2.</target>
        </trans-unit>
        <trans-unit id="67fd60fec12a23f41f4967a1b913d9c8325a3d58" translate="yes" xml:space="preserve">
          <source>Superposes arrays fields by fields</source>
          <target state="translated">将数组按字段叠加</target>
        </trans-unit>
        <trans-unit id="a1f3a3e0dca6bfb201866f4e02f7f0f252f0503d" translate="yes" xml:space="preserve">
          <source>Supplying additional compiler flags</source>
          <target state="translated">提供额外的编译器标志</target>
        </trans-unit>
        <trans-unit id="bd465d5e53c115d109beacd89675429e7fe9e2eb" translate="yes" xml:space="preserve">
          <source>Support for 64-bit OpenBLAS</source>
          <target state="translated">支持64位OpenBLAS</target>
        </trans-unit>
        <trans-unit id="05979ff1799bf4b31c7aaaf6575b3a44600e6938" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;decimal.Decimal&lt;/code&gt; in &lt;code&gt;np.lib.financial&lt;/code&gt;</source>
          <target state="translated">支持 &lt;code&gt;decimal.Decimal&lt;/code&gt; 中的 &lt;code&gt;np.lib.financial&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="94bf5963bbdc6b1a3677d96a194c63df08cc0ebe" translate="yes" xml:space="preserve">
          <source>Support for PGI flang compiler on Windows</source>
          <target state="translated">在Windows上支持PGI flang编译器。</target>
        </trans-unit>
        <trans-unit id="8dcbec54e843ff9113eeef63ba5ba94427429af2" translate="yes" xml:space="preserve">
          <source>Support for cross-platform builds for iOS</source>
          <target state="translated">支持iOS的跨平台构建</target>
        </trans-unit>
        <trans-unit id="d4312602ded392453d6506535641b2fe8fc3f434" translate="yes" xml:space="preserve">
          <source>Support for linear algebra on stacked arrays</source>
          <target state="translated">支持堆栈数组上的线性代数。</target>
        </trans-unit>
        <trans-unit id="d1486bb007dde41a6cd27d40051180a9824cbf65" translate="yes" xml:space="preserve">
          <source>Support for median and percentile in nanfunctions</source>
          <target state="translated">支持纳米函数的中位数和百分位数。</target>
        </trans-unit>
        <trans-unit id="5732c875d678ed7bc376f8bdb01c865cd0e57b5f" translate="yes" xml:space="preserve">
          <source>Support for multiple insertions when &lt;code&gt;obj&lt;/code&gt; is a single scalar or a sequence with one element (similar to calling insert multiple times).</source>
          <target state="translated">当 &lt;code&gt;obj&lt;/code&gt; 是单个标量或具有一个元素的序列时，支持多次插入（类似于多次调用insert）。</target>
        </trans-unit>
        <trans-unit id="4c2c6be525f6d9a610c57848f9ef0612672209f9" translate="yes" xml:space="preserve">
          <source>Support for reading lzma compressed text files in Python 3</source>
          <target state="translated">支持在Python 3中读取lzma压缩文本文件。</target>
        </trans-unit>
        <trans-unit id="57ebd340f9cd250715efd00bc82361318ecaf77c" translate="yes" xml:space="preserve">
          <source>Support for returning arrays of arbitrary dimensions in &lt;code&gt;apply_along_axis&lt;/code&gt;</source>
          <target state="translated">支持在 &lt;code&gt;apply_along_axis&lt;/code&gt; 中返回任意维的数组</target>
        </trans-unit>
        <trans-unit id="2d5e2188fd70bec3fdf433ddaeea9f504cb04b41" translate="yes" xml:space="preserve">
          <source>Support for the &amp;lsquo;@&amp;rsquo; operator in Python 3.5+</source>
          <target state="translated">在Python 3.5+中支持'@'运算符</target>
        </trans-unit>
        <trans-unit id="96793ccd7b743fcb4b68f47fc4a80f55eade2824" translate="yes" xml:space="preserve">
          <source>Support for the &lt;strong&gt;Yields&lt;/strong&gt; section was added in &lt;a href=&quot;https://github.com/numpy/numpydoc&quot;&gt;numpydoc&lt;/a&gt; version 0.6.</source>
          <target state="translated">在&lt;a href=&quot;https://github.com/numpy/numpydoc&quot;&gt;numpydoc&lt;/a&gt;版本0.6中添加了对&lt;strong&gt;Yields&lt;/strong&gt;部分的支持。</target>
        </trans-unit>
        <trans-unit id="729714232faf9c660ac35de89eac7db896893cb6" translate="yes" xml:space="preserve">
          <source>Support for tracemalloc in Python 3.6</source>
          <target state="translated">在Python 3.6中支持tracemalloc。</target>
        </trans-unit>
        <trans-unit id="08bf3021612bda0edd29ed3bce556141bfaab8f8" translate="yes" xml:space="preserve">
          <source>Support of object arrays in &lt;code&gt;matmul&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;matmul&lt;/code&gt; 支持对象数组</target>
        </trans-unit>
        <trans-unit id="738f921dd6d285f914885c453cfc677ad8fc0e6b" translate="yes" xml:space="preserve">
          <source>Support path-like objects for more functions</source>
          <target state="translated">支持更多功能的类路径对象</target>
        </trans-unit>
        <trans-unit id="6d95257e0d6b5ee52701ed6e60955d7b5cf2355f" translate="yes" xml:space="preserve">
          <source>Supported BitGenerators</source>
          <target state="translated">支持的位元发生器</target>
        </trans-unit>
        <trans-unit id="35d1294934e4cc4b101779bccdbe627fdf3b5b49" translate="yes" xml:space="preserve">
          <source>Supported platforms and versions</source>
          <target state="translated">支持的平台和版本</target>
        </trans-unit>
        <trans-unit id="090678b79c24d0799aa7434df5ba4e013c0ea2ff" translate="yes" xml:space="preserve">
          <source>Supports Fortran-contiguous arrays directly.</source>
          <target state="translated">直接支持Fortran连续数组。</target>
        </trans-unit>
        <trans-unit id="62c4a407a3644c899b58964ef70d8d5ea099dfdd" translate="yes" xml:space="preserve">
          <source>Supports full broadcasting of the inputs.</source>
          <target state="translated">支持输入的全部广播。</target>
        </trans-unit>
        <trans-unit id="12f46de9102cae348756a951378fba972f726b07" translate="yes" xml:space="preserve">
          <source>Supports rolling over multiple dimensions simultaneously.</source>
          <target state="translated">支持同时在多个尺寸上滚动。</target>
        </trans-unit>
        <trans-unit id="c531221221ae570c082e108201b731a1c902860f" translate="yes" xml:space="preserve">
          <source>Supports the method &lt;a href=&quot;generated/numpy.random.pcg64.advance#numpy.random.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt; to advance the RNG an arbitrary number of steps. The state of the PCG-64 RNG is represented by 2 128-bit unsigned integers.</source>
          <target state="translated">支持方法&lt;a href=&quot;generated/numpy.random.pcg64.advance#numpy.random.PCG64.advance&quot;&gt; &lt;code&gt;advance&lt;/code&gt; &lt;/a&gt;将RNG前进任意步数。PCG-64 RNG的状态由2个128位无符号整数表示。</target>
        </trans-unit>
        <trans-unit id="d97b0cce7cf0a1a8ea78834b26b7eaa1e93207d9" translate="yes" xml:space="preserve">
          <source>Supports the method &lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt; to advance the RNG an arbitrary number of steps. The state of the PCG-64 RNG is represented by 2 128-bit unsigned integers.</source>
          <target state="translated">支持方法&lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt; &lt;code&gt;advance&lt;/code&gt; &lt;/a&gt;将RNG前进任意步数。PCG-64 RNG的状态由2个128位无符号整数表示。</target>
        </trans-unit>
        <trans-unit id="7316bd03b503c1032cc14acdf4020a574c762c3f" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;x.shape&lt;/code&gt; is (10,20,30) and &lt;code&gt;ind&lt;/code&gt; is a (2,3,4)-shaped indexing &lt;a href=&quot;arrays.scalars#numpy.intp&quot;&gt;&lt;code&gt;intp&lt;/code&gt;&lt;/a&gt; array, then &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; has shape (10,2,3,4,30) because the (20,)-shaped subspace has been replaced with a (2,3,4)-shaped broadcasted indexing subspace. If we let &lt;em&gt;i, j, k&lt;/em&gt; loop over the (2,3,4)-shaped subspace then &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt;. This example produces the same result as &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">假设 &lt;code&gt;x.shape&lt;/code&gt; 为（10,20,30）并且 &lt;code&gt;ind&lt;/code&gt; 为（2,3,4）形索引&lt;a href=&quot;arrays.scalars#numpy.intp&quot;&gt; &lt;code&gt;intp&lt;/code&gt; &lt;/a&gt;数组，则 &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; 形状为（10,2,3 ，4,30），因为（20，）形子空间已被（2,3,4）形广播索引子空间替换。如果让&lt;em&gt;i，j，k&lt;/em&gt;在（2,3,4）形子空间上循环，则 &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt; 。本示例产生的结果与&lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt; &lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="34c5f00d14223115d609ab63804b8bf6dbd38059" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;x.shape&lt;/code&gt; is (10,20,30) and &lt;code&gt;ind&lt;/code&gt; is a (2,3,4)-shaped indexing &lt;code&gt;intp&lt;/code&gt; array, then &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; has shape (10,2,3,4,30) because the (20,)-shaped subspace has been replaced with a (2,3,4)-shaped broadcasted indexing subspace. If we let &lt;em&gt;i, j, k&lt;/em&gt; loop over the (2,3,4)-shaped subspace then &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt;. This example produces the same result as &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">假设 &lt;code&gt;x.shape&lt;/code&gt; 为（10,20,30）并且 &lt;code&gt;ind&lt;/code&gt; 为（2,3,4）形索引 &lt;code&gt;intp&lt;/code&gt; 数组，则 &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; 形状为（10,2,3 ，4,30），因为（20，）形状的子空间已被（2,3,4）形状的广播索引子空间替换。如果我们让&lt;em&gt;i，j，k&lt;/em&gt;在（2,3,4）形子空间上循环，则 &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt; 。本示例产生的结果与&lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt; &lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab6e03b971eeb9906907892d695f98f70c00c465" translate="yes" xml:space="preserve">
          <source>Suppose I have two files coolmodule.c and coolhelper.c which need to be compiled and linked into a single extension module. Suppose coolmodule.c contains the required initcool module initialization function (with the import_array() function called). Then, coolmodule.c would have at the top:</source>
          <target state="translated">假设我有两个文件coolmodule.c和coolhelper.c,它们需要被编译并链接到一个扩展模块中。假设coolmodule.c包含所需的initcool模块初始化函数(调用import_array()函数)。那么,coolmodule.c的顶部就会有以下内容。</target>
        </trans-unit>
        <trans-unit id="1a06be2cc716b778d6a1c32b124922e42d2cce52" translate="yes" xml:space="preserve">
          <source>Suppose now that we wish to print that same data, but with the missing values replaced by the average value.</source>
          <target state="translated">假设现在我们想打印同样的数据,但用平均值代替缺失值。</target>
        </trans-unit>
        <trans-unit id="c30e0906e4415225d057040ed0740bd62f0ab08e" translate="yes" xml:space="preserve">
          <source>Suppose that the commit history looks like this:</source>
          <target state="translated">假设提交历史是这样的。</target>
        </trans-unit>
        <trans-unit id="5dca6dc181cc53601add013bc2ada72709458943" translate="yes" xml:space="preserve">
          <source>Suppose the first operand is one dimensional and the second operand is two dimensional. The iterator will have three dimensions, so &lt;code&gt;op_axes&lt;/code&gt; will have two 3-element lists. The first list picks out the one axis of the first operand, and is -1 for the rest of the iterator axes, with a final result of [0, -1, -1]. The second list picks out the two axes of the second operand, but shouldn&amp;rsquo;t overlap with the axes picked out in the first operand. Its list is [-1, 0, 1]. The output operand maps onto the iterator axes in the standard manner, so we can provide None instead of constructing another list.</source>
          <target state="translated">假设第一个操作数是一维的，第二个操作数是二维的。迭代器将具有三个维度，因此 &lt;code&gt;op_axes&lt;/code&gt; 将具有两个3元素列表。第一个列表挑选出第一个操作数的一个轴，其余迭代器轴为-1，最终结果为[0，-1，-1]。第二个列表选择第二个操作数的两个轴，但不应与第一个操作数中选择的轴重叠。它的列表是[-1，0，1]。输出操作数以标准方式映射到迭代器轴，因此我们可以提供None而不是构造另一个列表。</target>
        </trans-unit>
        <trans-unit id="94712928e34f9dfa7af3b9cd6b14ec949c85f00d" translate="yes" xml:space="preserve">
          <source>Suppose you have a NumPy module &lt;code&gt;numpy/xxx/yyy.py&lt;/code&gt; containing a function &lt;code&gt;zzz()&lt;/code&gt;. To test this function you would create a test module called &lt;code&gt;test_yyy.py&lt;/code&gt;. If you only need to test one aspect of &lt;code&gt;zzz&lt;/code&gt;, you can simply add a test function:</source>
          <target state="translated">假设您有一个NumPy模块 &lt;code&gt;numpy/xxx/yyy.py&lt;/code&gt; ,其中包含一个函数 &lt;code&gt;zzz()&lt;/code&gt; 。要测试此功能，您将创建一个名为 &lt;code&gt;test_yyy.py&lt;/code&gt; 的测试模块。如果只需要测试 &lt;code&gt;zzz&lt;/code&gt; 的一个方面，则只需添加一个测试功能即可：</target>
        </trans-unit>
        <trans-unit id="ffbff519fe81519b5859278de1db83d3776384bb" translate="yes" xml:space="preserve">
          <source>Suppose you have a SciPy module &lt;code&gt;scipy/xxx/yyy.py&lt;/code&gt; containing a function &lt;code&gt;zzz()&lt;/code&gt;. To test this function you would create a test module called &lt;code&gt;test_yyy.py&lt;/code&gt;. If you only need to test one aspect of &lt;code&gt;zzz&lt;/code&gt;, you can simply add a test function:</source>
          <target state="translated">假设你有一个SciPy的模块 &lt;code&gt;scipy/xxx/yyy.py&lt;/code&gt; 包含函数 &lt;code&gt;zzz()&lt;/code&gt; 。要测试此功能，您将创建一个名为 &lt;code&gt;test_yyy.py&lt;/code&gt; 的测试模块。如果只需要测试 &lt;code&gt;zzz&lt;/code&gt; 的一个方面，则只需添加一个测试功能即可：</target>
        </trans-unit>
        <trans-unit id="561e62ec5d03ac50c21e0a257548d3eb990ac028" translate="yes" xml:space="preserve">
          <source>Suppose you have an urn with 15 white and 15 black marbles. If you pull 15 marbles at random, how likely is it that 12 or more of them are one color?</source>
          <target state="translated">假设你有一个瓮,里面有15个白色和15个黑色的弹珠。如果你随机抽取15个弹珠,那么其中12个或更多的弹珠是一种颜色的可能性有多大?</target>
        </trans-unit>
        <trans-unit id="7c7cd36a0c21d430e2827a371600cad0b35b80b7" translate="yes" xml:space="preserve">
          <source>Suppress the rows and/or columns of a 2-D array that contain masked values.</source>
          <target state="translated">抑制包含屏蔽值的二维数组的行和/或列。</target>
        </trans-unit>
        <trans-unit id="00f54cf02ad98c4bd3014ede43830053636d4545" translate="yes" xml:space="preserve">
          <source>Suppress whole columns of a 2-D array that contain masked values.</source>
          <target state="translated">抑制包含屏蔽值的二维数组的整列。</target>
        </trans-unit>
        <trans-unit id="685b0c43425911b6f904fe6d170e96c0345d4cbf" translate="yes" xml:space="preserve">
          <source>Suppress whole rows of a 2-D array that contain masked values.</source>
          <target state="translated">抑制包含屏蔽值的二维数组的整行。</target>
        </trans-unit>
        <trans-unit id="b11d9a95741366c39b17b9d4fd94445d808b15b4" translate="yes" xml:space="preserve">
          <source>Swap the bytes of the array elements</source>
          <target state="translated">交换数组元素的字节</target>
        </trans-unit>
        <trans-unit id="bbdcf90ffec6f9d47a9ac51cf19b00a93a140fa9" translate="yes" xml:space="preserve">
          <source>Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned.</source>
          <target state="translated">决定返回值性质的开关。当为False(默认)时,只返回系数,当为True时,也会返回奇异值分解的诊断信息。</target>
        </trans-unit>
        <trans-unit id="6b3384dea957229bd45073ab4c8cae823f791969" translate="yes" xml:space="preserve">
          <source>Switch determining the nature of the return value. When &lt;code&gt;False&lt;/code&gt; (the default) just the coefficients are returned; when &lt;code&gt;True&lt;/code&gt;, diagnostic information from the singular value decomposition (used to solve the fit&amp;rsquo;s matrix equation) is also returned.</source>
          <target state="translated">开关确定返回值的性质。如果为 &lt;code&gt;False&lt;/code&gt; （默认值），则仅返回系数。如果为 &lt;code&gt;True&lt;/code&gt; ，则还返回来自奇异值分解（用于求解拟合矩阵方程）的诊断信息。</target>
        </trans-unit>
        <trans-unit id="7af38070c59fd5383f5319f90871324cb011240a" translate="yes" xml:space="preserve">
          <source>System Entropy</source>
          <target state="translated">熵系统</target>
        </trans-unit>
        <trans-unit id="1b1430441b7b7dd5a90d83f42f914deacc5fd0e5" translate="yes" xml:space="preserve">
          <source>System configuration</source>
          <target state="translated">系统配置</target>
        </trans-unit>
        <trans-unit id="47e68638ef3b94e3c34563e1179f97e827fb9bec" translate="yes" xml:space="preserve">
          <source>SystemError</source>
          <target state="translated">SystemError</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="29f1b70dfc7cd7e2755985e321ea4063c37e7f58" translate="yes" xml:space="preserve">
          <source>T (numpy.char.chararray attribute)</source>
          <target state="translated">T(numpy.char.chararray属性)</target>
        </trans-unit>
        <trans-unit id="08fb6d4b20d17768263265c26a0d6392cfb83ed1" translate="yes" xml:space="preserve">
          <source>T() (numpy.ma.masked_array property)</source>
          <target state="translated">T()(numpy.ma.masked_array属性)</target>
        </trans-unit>
        <trans-unit id="494db6c744e0093634443456957eafcc51937e81" translate="yes" xml:space="preserve">
          <source>THE RESULTING LOGIT FUNCTION IS NOT FAST! numpy.vectorize simply loops over spam.logit. The loop is done at the C level, but the numpy array is constantly being parsed and build back up. This is expensive. When the author compared numpy.vectorize(spam.logit) against the logit ufuncs constructed below, the logit ufuncs were almost exactly 4 times faster. Larger or smaller speedups are, of course, possible depending on the nature of the function.</source>
          <target state="translated">结果logit函数并不快!numpy.vectorize只是简单地在spam.logit上循环。循环是在C层完成的,但是numpy数组会不断地被解析并建立起来。这是很昂贵的。当笔者将numpy.vectorize(spam.logit)与下面构造的logit ufuncs进行对比时,logit ufuncs几乎整整快了4倍。当然,根据函数的性质,更大或更小的提速都是可能的。</target>
        </trans-unit>
        <trans-unit id="8d06ee651a160babb28eda47548bd9fad2ca6df2" translate="yes" xml:space="preserve">
          <source>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &amp;ldquo;AS IS&amp;rdquo; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</source>
          <target state="translated">版权持有者和贡献者按&amp;ldquo;原样&amp;rdquo;提供此软件，不提供任何明示或暗示的担保，包括但不限于针对特定目的的适销性和适用性的暗示担保。版权拥有者或贡献者在任何情况下均不对任何直接，间接，偶发，特殊，专有或后果性的损害（包括但不限于，替代商品或服务的购买，使用，数据，或业务中断），无论基于合同，严格责任或侵权行为（包括疏忽或其他方式），无论是出于任何责任，都应通过使用本软件的任何方式（即使已经事先告知）进行。</target>
        </trans-unit>
        <trans-unit id="8e0d354392fe3fc9d2a5d83e7fd5a6f24a2b815a" translate="yes" xml:space="preserve">
          <source>TODO: Maybe it would be better to introduce a function &lt;code&gt;NpyIter_GetWrappedOutput&lt;/code&gt; and remove this flag?</source>
          <target state="translated">TODO：也许最好引入一个函数 &lt;code&gt;NpyIter_GetWrappedOutput&lt;/code&gt; 并删除该标志？</target>
        </trans-unit>
        <trans-unit id="c398f641b79127cbb5368a052c9c18ee4b191edd" translate="yes" xml:space="preserve">
          <source>TODO: This feature can be easily extended for Fortran 90 codes as well. Let us know if you would need such a feature.</source>
          <target state="translated">TODO:这个功能也可以很容易地扩展到Fortran 90代码。如果您需要这一功能,请告诉我们。</target>
        </trans-unit>
        <trans-unit id="8cfd932f7721749006331a6f950d4068e186ddf4" translate="yes" xml:space="preserve">
          <source>Table of Rough MATLAB-NumPy Equivalents</source>
          <target state="translated">MATLAB-NumPy粗略等价物表</target>
        </trans-unit>
        <trans-unit id="b2e0fad2c7303a14e3d40f2816778e4a945515d7" translate="yes" xml:space="preserve">
          <source>Tag the release</source>
          <target state="translated">标记发布</target>
        </trans-unit>
        <trans-unit id="d2bf59208074c19e062d597b69c91e24c1b3f65d" translate="yes" xml:space="preserve">
          <source>Take a sequence of 1-D arrays and stack them as columns to make a single 2-D array. 2-D arrays are stacked as-is, just like with &lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;. 1-D arrays are turned into 2-D columns first.</source>
          <target state="translated">采取一系列一维数组并将其堆叠为列以构成单个二维数组。二维数组按原样堆叠，就像使用&lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; 一样&lt;/a&gt;。首先将一维数组转换为二维列。</target>
        </trans-unit>
        <trans-unit id="a7063ff9c282b69776d4b6c1965ce5cc8d3d21f1" translate="yes" xml:space="preserve">
          <source>Take a sequence of 1-D arrays and stack them as columns to make a single 2-D array. 2-D arrays are stacked as-is, just like with &lt;a href=&quot;numpy.ma.hstack#numpy.ma.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;. 1-D arrays are turned into 2-D columns first.</source>
          <target state="translated">采取一系列一维数组并将其堆叠为列以构成单个二维数组。二维数组按原样堆叠，就像使用&lt;a href=&quot;numpy.ma.hstack#numpy.ma.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; 一样&lt;/a&gt;。首先将一维数组转换为二维列。</target>
        </trans-unit>
        <trans-unit id="948650b27c1b2b9784a79436cafe48d7d653c938" translate="yes" xml:space="preserve">
          <source>Take along an axis, using the same indices for every 1d slice</source>
          <target state="translated">沿着轴线,对每一个1d的片子使用相同的指数。</target>
        </trans-unit>
        <trans-unit id="750d821c9fa304621f4be0f3b88564bf9278e152" translate="yes" xml:space="preserve">
          <source>Take elements by matching the array and the index arrays</source>
          <target state="translated">通过匹配数组和索引数组来获取元素。</target>
        </trans-unit>
        <trans-unit id="e11fd16230a195030272e04871b014d038eef9ab" translate="yes" xml:space="preserve">
          <source>Take elements from an array along an axis.</source>
          <target state="translated">从一个数组中沿轴取元素。</target>
        </trans-unit>
        <trans-unit id="2bd0abec8d18fb4f628e5467a962eaf329bb6905" translate="yes" xml:space="preserve">
          <source>Take elements using a boolean mask</source>
          <target state="translated">使用布尔掩码获取元素</target>
        </trans-unit>
        <trans-unit id="17496f471ffa9e41a2e92dd83c6a717d70cae831" translate="yes" xml:space="preserve">
          <source>Take log base n of x.</source>
          <target state="translated">取x的对数基数n。</target>
        </trans-unit>
        <trans-unit id="b8cd92f0049ea13b3db726f84fc3411287caeddf" translate="yes" xml:space="preserve">
          <source>Take the fields dictionary, &lt;em&gt;dict&lt;/em&gt;, such as the one attached to a data-type object and construct an ordered-list of field names such as is stored in the names field of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">拿字段字典&lt;em&gt;dict&lt;/em&gt;（例如附加到数据类型对象的字典），构造字段名称的有序列表，例如存储在&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;对象的names字段中。</target>
        </trans-unit>
        <trans-unit id="8588b385cd332763c111b95b02976dcd4b8a50f6" translate="yes" xml:space="preserve">
          <source>Take the fields dictionary, &lt;em&gt;dict&lt;/em&gt;, such as the one attached to a data-type object and construct an ordered-list of field names such as is stored in the names field of the &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">拿字段字典&lt;em&gt;dict&lt;/em&gt;（例如连接到数据类型对象的字典）构建一个字段名称的有序列表，例如存储在&lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;对象的names字段中。</target>
        </trans-unit>
        <trans-unit id="673397230d0da22f7147b4eeece871fd1294c5ff" translate="yes" xml:space="preserve">
          <source>Take values from the input array by matching 1d index and data slices</source>
          <target state="translated">通过匹配1d索引和数据片,从输入数组中取值。</target>
        </trans-unit>
        <trans-unit id="7f4b8f1ca46302f3d1aba5fbdc3749dad60f0480" translate="yes" xml:space="preserve">
          <source>Take values from the input array by matching 1d index and data slices.</source>
          <target state="translated">通过匹配1d索引和数据片从输入数组中取值。</target>
        </trans-unit>
        <trans-unit id="567aaaa85050a78f736c937e4e349477825e7c6c" translate="yes" xml:space="preserve">
          <source>Takes an arbitrary Python function and returns a NumPy ufunc.</source>
          <target state="translated">读取一个任意的Python函数并返回一个NumPy ufunc。</target>
        </trans-unit>
        <trans-unit id="ad884a5ab2796ce61beab25497caa48a0c350a18" translate="yes" xml:space="preserve">
          <source>Takes an arbitrary Python function and returns a ufunc</source>
          <target state="translated">读取一个任意的Python函数并返回一个ufunc。</target>
        </trans-unit>
        <trans-unit id="4fe8421f7b4bac2910c2919a03e01d32f910e006" translate="yes" xml:space="preserve">
          <source>Taking an example cited in Wikipedia, this distribution can be used if one wanted to cut strings (each of initial length 1.0) into K pieces with different lengths, where each piece had, on average, a designated average length, but allowing some variation in the relative sizes of the pieces.</source>
          <target state="translated">以维基百科中引用的一个例子为例,如果想把字符串(每个初始长度为1.0)切割成K个不同长度的片段,其中每个片段平均有一个指定的平均长度,但允许片段的相对大小有一些变化,就可以使用这种分布。</target>
        </trans-unit>
        <trans-unit id="a8980c440e8f502e5c59dc6cdcc36215481bcc7e" translate="yes" xml:space="preserve">
          <source>Taking no further action</source>
          <target state="translated">不采取进一步行动</target>
        </trans-unit>
        <trans-unit id="af1237aaefe517f485a7a53e6bb8a3bb8a86a6a4" translate="yes" xml:space="preserve">
          <source>Target array.</source>
          <target state="translated">目标阵列:</target>
        </trans-unit>
        <trans-unit id="29750e559748752bfadb381caa3f9398aa376d70" translate="yes" xml:space="preserve">
          <source>Target groups: pre-configured configuration statements used for managing the required optimizations from outside the dispatch-able source.</source>
          <target state="translated">目标组:预先配置的配置语句,用于管理可调度源外的所需优化。</target>
        </trans-unit>
        <trans-unit id="51038a1a794fec6114fafbb47a8bce902f23294f" translate="yes" xml:space="preserve">
          <source>Target indices, interpreted as integers.</source>
          <target state="translated">目标指数,解释为整数。</target>
        </trans-unit>
        <trans-unit id="695f8bb0287f4fc300e17fa93e5262f0b53e9bb1" translate="yes" xml:space="preserve">
          <source>Temporary directories are deleted when the DataSource is deleted.</source>
          <target state="translated">当DataSource被删除时,临时目录会被删除。</target>
        </trans-unit>
        <trans-unit id="b3d2d960e69084c198868bb0c51081b279e6d57d" translate="yes" xml:space="preserve">
          <source>Temporary elision</source>
          <target state="translated">暂时洗脱</target>
        </trans-unit>
        <trans-unit id="6701dda5ea2a62c52d8395d7a5c8f390a0ab64df" translate="yes" xml:space="preserve">
          <source>Tensor contraction:</source>
          <target state="translated">张量收缩。</target>
        </trans-unit>
        <trans-unit id="7e786b6ecaa33c3bfa2a663250579b348bbb6678" translate="yes" xml:space="preserve">
          <source>Tensor contractions, &lt;a href=&quot;numpy.tensordot#numpy.tensordot&quot;&gt;&lt;code&gt;numpy.tensordot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">张量收缩&lt;a href=&quot;numpy.tensordot#numpy.tensordot&quot;&gt; &lt;code&gt;numpy.tensordot&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8aa53899fcc2f4722e3aaa13b02a9f0c21a58b0c" translate="yes" xml:space="preserve">
          <source>Tensor to &amp;lsquo;invert&amp;rsquo;. Its shape must be &amp;lsquo;square&amp;rsquo;, i. e., &lt;code&gt;prod(a.shape[:ind]) == prod(a.shape[ind:])&lt;/code&gt;.</source>
          <target state="translated">张量&amp;ldquo;反转&amp;rdquo;。它的形状必须为&amp;ldquo;正方形&amp;rdquo;，即 &lt;code&gt;prod(a.shape[:ind]) == prod(a.shape[ind:])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a7912060e7ae8d981d410c16692b658bc5a8653" translate="yes" xml:space="preserve">
          <source>Tensors to &amp;ldquo;dot&amp;rdquo;.</source>
          <target state="translated">张量为&amp;ldquo;点&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="71218d40834bc4913fe2fbb95e52de19a584b43a" translate="yes" xml:space="preserve">
          <source>Test Running</source>
          <target state="translated">测试运行</target>
        </trans-unit>
        <trans-unit id="2ec99dbb44d0090912e3c4ddf71222f3cee61914" translate="yes" xml:space="preserve">
          <source>Test Support (&lt;code&gt;numpy.testing&lt;/code&gt;)</source>
          <target state="translated">测试支持（ &lt;code&gt;numpy.testing&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c35554b04739c6c6869f7c83d9841e0dda4c5073" translate="yes" xml:space="preserve">
          <source>Test Support (numpy.testing)</source>
          <target state="translated">测试支持 (numpy.testing)</target>
        </trans-unit>
        <trans-unit id="a0b0d520e3181fa7765d42a80050b97cb70dbe30" translate="yes" xml:space="preserve">
          <source>Test coverage</source>
          <target state="translated">测试范围</target>
        </trans-unit>
        <trans-unit id="59afddee1692b59da457c30d92a5b65f5e31115a" translate="yes" xml:space="preserve">
          <source>Test element-wise for NaN and return result as a boolean array.</source>
          <target state="translated">对NaN进行逐元素测试,并以布尔数组形式返回结果。</target>
        </trans-unit>
        <trans-unit id="ed391a308f11ca7f40c17a765e9b20cc4e1035a2" translate="yes" xml:space="preserve">
          <source>Test element-wise for NaT (not a time) and return result as a boolean array.</source>
          <target state="translated">对NaT(不是时间)进行元素测试,并以布尔数组的形式返回结果。</target>
        </trans-unit>
        <trans-unit id="9f34997c659f4457d18a667e13e9b54ff7ea7b5d" translate="yes" xml:space="preserve">
          <source>Test element-wise for finiteness (not infinity or not Not a Number).</source>
          <target state="translated">从元素上测试有限性(不是无穷大,也不是Not a Number)。</target>
        </trans-unit>
        <trans-unit id="b73482f0dd7c13ea3e95362c875b37244def5b6c" translate="yes" xml:space="preserve">
          <source>Test element-wise for negative infinity, return result as bool array.</source>
          <target state="translated">逐元素测试负无穷大,返回结果为bool数组。</target>
        </trans-unit>
        <trans-unit id="f441420173d81baeaa59a4fb443d5293972df75a" translate="yes" xml:space="preserve">
          <source>Test element-wise for positive infinity, return result as bool array.</source>
          <target state="translated">逐元素测试是否为正无穷大,返回结果为bool数组。</target>
        </trans-unit>
        <trans-unit id="f76286ad13fcd1d6939365b38ad9443c5711054b" translate="yes" xml:space="preserve">
          <source>Test element-wise for positive or negative infinity.</source>
          <target state="translated">从元素上检验正负无穷大。</target>
        </trans-unit>
        <trans-unit id="a54ae1b5fd87138bbeb065cc5056362be6e773bd" translate="yes" xml:space="preserve">
          <source>Test if &lt;code&gt;path&lt;/code&gt; exists as (and in this order):</source>
          <target state="translated">测试 &lt;code&gt;path&lt;/code&gt; 存在（以该顺序）：</target>
        </trans-unit>
        <trans-unit id="6db21c53daecd81068cb27c5716c17cf9ec8f853" translate="yes" xml:space="preserve">
          <source>Test if path exists.</source>
          <target state="translated">测试路径是否存在。</target>
        </trans-unit>
        <trans-unit id="ab9c97d91f47360ac72bf2e9386f7b26c75db7d2" translate="yes" xml:space="preserve">
          <source>Test if two strings are equal.</source>
          <target state="translated">测试两个字符串是否相等。</target>
        </trans-unit>
        <trans-unit id="90c99592ef3a4e369f5b8438543a142bc4a6d8c8" translate="yes" xml:space="preserve">
          <source>Test support</source>
          <target state="translated">测试支持</target>
        </trans-unit>
        <trans-unit id="fe6e53750db930a15ff2a9eb0786f6b4b0dd49e8" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;ary&lt;/code&gt; is contiguous. If so, return 1. Otherwise, set a Python error and return 0.</source>
          <target state="translated">测试 &lt;code&gt;ary&lt;/code&gt; 是否连续。如果是，则返回1。否则，设置Python错误并返回0。</target>
        </trans-unit>
        <trans-unit id="e52099e2b541a96f27cc77aa438f266ac05e538f" translate="yes" xml:space="preserve">
          <source>Test whether all array elements along a given axis evaluate to True.</source>
          <target state="translated">测试是否所有沿给定轴的数组元素都为True。</target>
        </trans-unit>
        <trans-unit id="7d4c1c04414d7af36c37c81837979d62019dac75" translate="yes" xml:space="preserve">
          <source>Test whether all elements along a given axis evaluate to True.</source>
          <target state="translated">测试是否所有沿给定轴的元素都为True。</target>
        </trans-unit>
        <trans-unit id="8dcb7ed405671230192b179ae33bab118c7f5996" translate="yes" xml:space="preserve">
          <source>Test whether all matrix elements along a given axis evaluate to True.</source>
          <target state="translated">测试是否所有的矩阵元素沿着给定的轴计算为True。</target>
        </trans-unit>
        <trans-unit id="a8cd365e47952360dc676cadf55d3bc2ecae44b5" translate="yes" xml:space="preserve">
          <source>Test whether any array element along a given axis evaluates to True.</source>
          <target state="translated">测试沿给定轴的任何数组元素是否为True。</target>
        </trans-unit>
        <trans-unit id="e54011a9e26f7c9e97e1ca23a771785990f7e7d4" translate="yes" xml:space="preserve">
          <source>Test whether any element along a given axis evaluates to True.</source>
          <target state="translated">测试沿给定轴的任何元素是否为True。</target>
        </trans-unit>
        <trans-unit id="3c5d24b0586eac0954dbcb6d49897a1641c89d36" translate="yes" xml:space="preserve">
          <source>Test whether each element of a 1-D array is also present in a second array.</source>
          <target state="translated">测试一个一维数组的每个元素是否也存在于第二个数组中。</target>
        </trans-unit>
        <trans-unit id="025a700084bfede250ccd79227b915c047f7f35d" translate="yes" xml:space="preserve">
          <source>Test whether input is an instance of MaskedArray.</source>
          <target state="translated">测试输入是否是MaskedArray的实例。</target>
        </trans-unit>
        <trans-unit id="5904fc9bcfebbe0d053c7cdc88d0d4fdd88cf00c" translate="yes" xml:space="preserve">
          <source>Tester (in module numpy.testing)</source>
          <target state="translated">测试者(在模块numpy.testing中)。</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="43d2fa7f4fbc625f4df01f08ea6653e49f950cbd" translate="yes" xml:space="preserve">
          <source>Testing Guidelines</source>
          <target state="translated">测试指南</target>
        </trans-unit>
        <trans-unit id="ef9606fae34bdb52d82ad257949ec42aea0b9b12" translate="yes" xml:space="preserve">
          <source>Testing Header Files</source>
          <target state="translated">测试头文件</target>
        </trans-unit>
        <trans-unit id="8c4816453a13f4ed79fdc1f72aaf2f8bbcc370cd" translate="yes" xml:space="preserve">
          <source>Testing NumPy</source>
          <target state="translated">测试NumPy</target>
        </trans-unit>
        <trans-unit id="d322a0e8fe52f19dbe7d5bd52156ee63071b90d8" translate="yes" xml:space="preserve">
          <source>Testing Organization</source>
          <target state="translated">测试机构</target>
        </trans-unit>
        <trans-unit id="e3148b0ff766bdb8347a198898838253aab4da96" translate="yes" xml:space="preserve">
          <source>Testing Python Scripts</source>
          <target state="translated">测试Python脚本</target>
        </trans-unit>
        <trans-unit id="8c3a61a48bb499744371cb7fc30761102d86f229" translate="yes" xml:space="preserve">
          <source>Testing SWIG Interface Files</source>
          <target state="translated">测试SWIG接口文件</target>
        </trans-unit>
        <trans-unit id="34d08d85bddb11f11da76ad84dab43a94d74c7ed" translate="yes" xml:space="preserve">
          <source>Testing Source Files</source>
          <target state="translated">测试源文件</target>
        </trans-unit>
        <trans-unit id="01135c69ed3ceb06607a7ed768bb69a01b974feb" translate="yes" xml:space="preserve">
          <source>Testing a subset of NumPy:</source>
          <target state="translated">测试NumPy的一个子集。</target>
        </trans-unit>
        <trans-unit id="ad0aa0ce3fefa4686bfefac5eb7c9ff2df0a50c6" translate="yes" xml:space="preserve">
          <source>Testing builds</source>
          <target state="translated">测试构建</target>
        </trans-unit>
        <trans-unit id="7704b172077f920ddd46d5adbcffe86730e58a19" translate="yes" xml:space="preserve">
          <source>Testing looks for module-level or class-level setup and teardown functions by name; thus:</source>
          <target state="translated">测试按名称查找模块级或类级的设置和拆卸函数;因此。</target>
        </trans-unit>
        <trans-unit id="45ece46e91d1fe305feeee99aed2fad182be7b30" translate="yes" xml:space="preserve">
          <source>Testing the numpy.i Typemaps</source>
          <target state="translated">测试 numpy.i Typemaps</target>
        </trans-unit>
        <trans-unit id="00774e7f83f997b0fda8acccd1c59071701a2ddf" translate="yes" xml:space="preserve">
          <source>Tests can also be run with &lt;code&gt;pytest numpy&lt;/code&gt;, however then the NumPy-specific plugin is not found which causes strange side effects</source>
          <target state="translated">也可以使用 &lt;code&gt;pytest numpy&lt;/code&gt; 运行测试，但是然后找不到特定于NumPy的插件，这会导致奇怪的副作用</target>
        </trans-unit>
        <trans-unit id="7f86100126c53e2e34ca1a3d91679a3a06b6d132" translate="yes" xml:space="preserve">
          <source>Tests for a module should ideally cover all code in that module, i.e., statement coverage should be at 100%.</source>
          <target state="translated">一个模块的测试最好能覆盖该模块的所有代码,即语句覆盖率应达到100%。</target>
        </trans-unit>
        <trans-unit id="417d130b240483956f423e540d6cb689832b6f9e" translate="yes" xml:space="preserve">
          <source>Tests on random data</source>
          <target state="translated">随机数据的测试</target>
        </trans-unit>
        <trans-unit id="f3d72180c504c070f745ad049bd21c11042867d1" translate="yes" xml:space="preserve">
          <source>Tests on random data are good, but since test failures are meant to expose new bugs or regressions, a test that passes most of the time but fails occasionally with no code changes is not helpful. Make the random data deterministic by setting the random number seed before generating it. Use either Python&amp;rsquo;s &lt;code&gt;random.seed(some_number)&lt;/code&gt; or NumPy&amp;rsquo;s &lt;code&gt;numpy.random.seed(some_number)&lt;/code&gt;, depending on the source of random numbers.</source>
          <target state="translated">对随机数据进行测试是好的，但是由于测试失败是为了暴露新的错误或回归，因此在大多数情况下通过但偶尔失败且没有代码更改的测试无济于事。通过在生成随机数种子之前对其进行设置，使随机数据具有确定性。使用Python的 &lt;code&gt;random.seed(some_number)&lt;/code&gt; 或NumPy的 &lt;code&gt;numpy.random.seed(some_number)&lt;/code&gt; ，具体取决于随机数的来源。</target>
        </trans-unit>
        <trans-unit id="927f696caa5bf0529c4f0991bbe8b99afb2fa55b" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float has a value equal to zero. This may be slightly faster than calling npy_half_eq(h, NPY_ZERO).</source>
          <target state="translated">测试半精度的浮点数是否等于零,这比调用npy_half_eq(h,NPY_ZERO)稍快。这可能比调用npy_half_eq(h,NPY_ZERO)稍快。</target>
        </trans-unit>
        <trans-unit id="b3be553d33f0513a6775eaa86f3391147a1aac09" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is a NaN.</source>
          <target state="translated">测试半精度浮点数是否为NaN。</target>
        </trans-unit>
        <trans-unit id="6424a62751d70065c8ad2d16d22d5e29e4d2e45c" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is finite (not NaN or Inf).</source>
          <target state="translated">测试半精度浮点数是否有限(不是NaN或Inf)。</target>
        </trans-unit>
        <trans-unit id="b796fd95ec3aee28c84902e310b3fcc5e87bd087" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is plus or minus Inf.</source>
          <target state="translated">测试半精度浮点数是正还是负Inf。</target>
        </trans-unit>
        <trans-unit id="9cad929af9630184e2ec9f960cd674271afcf718" translate="yes" xml:space="preserve">
          <source>Tests, that send messages to stderr, fail when executed from MSYS prompt because the messages are lost at some point.</source>
          <target state="translated">向stderr发送消息的测试,在MSYS提示下执行时失败,因为消息在某些时候丢失了。</target>
        </trans-unit>
        <trans-unit id="d627254d7ccb3ce266ce9cf0341eff8096cd2a09" translate="yes" xml:space="preserve">
          <source>Texlive (or MikTeX on Windows)</source>
          <target state="translated">Texlive(或MikTeX在Windows上)</target>
        </trans-unit>
        <trans-unit id="0a988a505d4f9bd1f41a57f4c2458a2423baedc7" translate="yes" xml:space="preserve">
          <source>Text files</source>
          <target state="translated">文本文件</target>
        </trans-unit>
        <trans-unit id="4ba343aecd438b7c22876dbbd27f537f09be5607" translate="yes" xml:space="preserve">
          <source>Text formatting options</source>
          <target state="translated">文本格式选项</target>
        </trans-unit>
        <trans-unit id="839b1da5d3ca352faa5ce69a674d5b04a8fa489d" translate="yes" xml:space="preserve">
          <source>Thanks to Yarik Halchenko for this explanation.</source>
          <target state="translated">感谢亚里克-哈尔琴科的解释。</target>
        </trans-unit>
        <trans-unit id="5219411122630dca47bf818c11bfaef89c8f5266" translate="yes" xml:space="preserve">
          <source>That also takes extra arguments, like &lt;code&gt;--pdb&lt;/code&gt; which drops you into the Python debugger when a test fails or an exception is raised.</source>
          <target state="translated">这还需要额外的参数，例如 &lt;code&gt;--pdb&lt;/code&gt; ，当测试失败或引发异常时，它将带您进入Python调试器。</target>
        </trans-unit>
        <trans-unit id="90e8faeace432448f3522160a796443560f628f2" translate="yes" xml:space="preserve">
          <source>That can be one of 12 different scalar types: &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;unsigned long long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">那可以是12种不同的标量类型之一：有 &lt;code&gt;signed char&lt;/code&gt; ， &lt;code&gt;unsigned char&lt;/code&gt; ， &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;unsigned short&lt;/code&gt; ， &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;unsigned int&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; ， &lt;code&gt;unsigned long&lt;/code&gt; ， &lt;code&gt;long long&lt;/code&gt; ， &lt;code&gt;unsigned long long&lt;/code&gt; ， &lt;code&gt;float&lt;/code&gt; 和 &lt;code&gt;double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be4b72468f984c83d93633e8f8bf75388e94a047" translate="yes" xml:space="preserve">
          <source>That is a looser test than originally documented, but agrees with what the actual implementation did up to rounding vagaries. An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">这是一个比最初记录的更宽松的测试,但与实际执行的情况一致,直到四舍五入的变化。在形状不匹配或值冲突时,会引发一个异常。与 numpy 中的标准用法不同,NaNs 是像数字一样进行比较的,如果两个对象的 NaNs 在相同的位置,则不会引发断言。</target>
        </trans-unit>
        <trans-unit id="31ca174a88927a9e0e7f8f15283f8ce9b3459f51" translate="yes" xml:space="preserve">
          <source>That is a looser test than originally documented, but agrees with what the actual implementation in &lt;a href=&quot;numpy.testing.assert_array_almost_equal#numpy.testing.assert_array_almost_equal&quot;&gt;&lt;code&gt;assert_array_almost_equal&lt;/code&gt;&lt;/a&gt; did up to rounding vagaries. An exception is raised at conflicting values. For ndarrays this delegates to assert_array_almost_equal</source>
          <target state="translated">这是一个比最初记录的测试宽松的测试，但与&lt;a href=&quot;numpy.testing.assert_array_almost_equal#numpy.testing.assert_array_almost_equal&quot;&gt; &lt;code&gt;assert_array_almost_equal&lt;/code&gt; 中&lt;/a&gt;的实际实现对舍入变幻莫测的结果是一致的。值冲突时会引发异常。对于ndarray，这委托给assert_array_almost_equal</target>
        </trans-unit>
        <trans-unit id="78c7ba93686b82a275a0b9b502ec9d6d238b4d32" translate="yes" xml:space="preserve">
          <source>That is better: no more negative values. However, we can still see that for some days, the cumulative number of cases seems to go down (from 835 to 10, for example), which does not agree with the definition of &amp;ldquo;cumulative data&amp;rdquo;. If we look more closely at the data, we can see that in the period where there was missing data in mainland China, there was valid data for Hong Kong, Taiwan, Macau and &amp;ldquo;Unspecified&amp;rdquo; regions of China. Maybe we can remove those from the total sum of cases in China, to get a better understanding of the data.</source>
          <target state="translated">那更好：不再有负值。但是，我们仍然可以看到，几天以来，案件的累计数量似乎有所下降（例如，从835下降到10），这与&amp;ldquo;累积数据&amp;rdquo;的定义不符。如果我们更仔细地查看数据，可以看到在中国大陆缺少数据的时期内，香港，台湾，澳门和中国&amp;ldquo;未指定&amp;rdquo;地区都有有效数据。也许我们可以将这些病例从中国的病例总数中删除，以更好地了解数据。</target>
        </trans-unit>
        <trans-unit id="89910f6f21cfa928fbf09ccc006fad6eb4f77601" translate="yes" xml:space="preserve">
          <source>That is, each index specified selects the array corresponding to the rest of the dimensions selected. In the above example, choosing 0 means that the remaining dimension of length 5 is being left unspecified, and that what is returned is an array of that dimensionality and size. It must be noted that the returned array is not a copy of the original, but points to the same values in memory as does the original array. In this case, the 1-D array at the first position (0) is returned. So using a single index on the returned array, results in a single element being returned. That is:</source>
          <target state="translated">也就是说,每指定一个索引,就会选择其余维度所对应的数组。在上面的例子中,选择0意味着剩下的长度为5的维度没有被指定,返回的是该维度和大小的数组。必须注意的是,返回的数组并不是原始数组的副本,而是和原始数组一样指向内存中的值。在这种情况下,返回的是第一个位置(0)的1-D数组。所以在返回的数组上使用单一索引,结果是返回一个元素。也就是</target>
        </trans-unit>
        <trans-unit id="9424a0780491d95b42071bfcb7519b4471231e07" translate="yes" xml:space="preserve">
          <source>That solves the problem of returning views of the same type, but now we have a new problem. The machinery of ndarray can set the class this way, in its standard methods for taking views, but the ndarray &lt;code&gt;__new__&lt;/code&gt; method knows nothing of what we have done in our own &lt;code&gt;__new__&lt;/code&gt; method in order to set attributes, and so on. (Aside - why not call &lt;code&gt;obj = subdtype.__new__(...&lt;/code&gt; then? Because we may not have a &lt;code&gt;__new__&lt;/code&gt; method with the same call signature).</source>
          <target state="translated">这解决了返回相同类型的视图的问题，但是现在我们有了一个新问题。ndarray的机制可以在其用于获取视图的标准方法中以这种方式设置类，但是ndarray &lt;code&gt;__new__&lt;/code&gt; 方法 &lt;code&gt;__new__&lt;/code&gt; 为设置属性而在自己的__new__方法中所做的事情，依此类推。（此外-为什么不调用 &lt;code&gt;obj = subdtype.__new__(...&lt;/code&gt; 那么？因为我们可能没有具有相同调用签名的 &lt;code&gt;__new__&lt;/code&gt; 方法）。</target>
        </trans-unit>
        <trans-unit id="b5240cf478eeccab2d778da09495ef32dd780cc8" translate="yes" xml:space="preserve">
          <source>That support 74 different argument signatures for each data type, including:</source>
          <target state="translated">这支持每个数据类型的74种不同的论点签名,包括:</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="5c4c1c79691cc97764af36fe5679519dac98f423" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;busday&amp;rdquo; functions can additionally check a list of &amp;ldquo;holiday&amp;rdquo; dates, specific dates that are not valid days.</source>
          <target state="translated">&amp;ldquo; busday&amp;rdquo;功能还可以检查&amp;ldquo;假期&amp;rdquo;列表，这些日期不是有效日期。</target>
        </trans-unit>
        <trans-unit id="b6c70d4694de1c6fa7fc40232e3591d1a1b102a5" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;count&amp;rdquo; algorithm is roughly equivalent to the following numpy code:</source>
          <target state="translated">&amp;ldquo;计数&amp;rdquo;算法大致等效于以下numpy代码：</target>
        </trans-unit>
        <trans-unit id="6a2e889671201d8619d4999f2673b8d825f07526" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;count&amp;rdquo; algorithm uses a temporary array of integers with length &lt;code&gt;sum(colors)&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo;计数&amp;rdquo;算法使用长度为 &lt;code&gt;sum(colors)&lt;/code&gt; 的整数临时数组。</target>
        </trans-unit>
        <trans-unit id="701df984a45b35c07efc7a2ab11dc3b2d9004e29" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;four quadrant&amp;rdquo; arctan of the angle formed by (&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;) and the positive &lt;code&gt;x&lt;/code&gt;-axis.</source>
          <target state="translated">由（ &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; ）和正 &lt;code&gt;x&lt;/code&gt; 轴形成的角度的&amp;ldquo;四象限&amp;rdquo;反正切。</target>
        </trans-unit>
        <trans-unit id="7af7d8f19766359bdf4ea2069305031d08b0663c" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;marginals&amp;rdquo; algorithm generates a variate by using repeated calls to the univariate hypergeometric sampler. It is roughly equivalent to:</source>
          <target state="translated">&amp;ldquo;边际&amp;rdquo;算法通过重复调用单变量超几何采样器来生成变量。它大致等效于：</target>
        </trans-unit>
        <trans-unit id="72e5831aa41d1e2f9af8c987044c60e05af0be5f" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;smart way&amp;rdquo; of wrapping Fortran functions, as explained above, is suitable for wrapping (e.g. third party) Fortran codes for which modifications to their source codes are not desirable nor even possible.</source>
          <target state="translated">如上所述，包装Fortran函数的&amp;ldquo;智能方式&amp;rdquo;适用于包装（例如第三方）Fortran代码，对于这些代码而言，对其源代码进行修改是不希望的，甚至是不可能的。</target>
        </trans-unit>
        <trans-unit id="2adc5d4e116d43dd248737cacbfac03ed3ef63f9" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;y-intercept&amp;rdquo; and &amp;ldquo;slope&amp;rdquo; of the line, respectively.</source>
          <target state="translated">线的&amp;ldquo; y截距&amp;rdquo;和&amp;ldquo;斜率&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e4a0235cef14b392c275cecc105837cde82d5723" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;a&amp;rsquo; variable is unstripped from c[1] because whitespace leading.</source>
          <target state="translated">因为空格领先，所以'a'变量未从c [1]中剥离。</target>
        </trans-unit>
        <trans-unit id="bda37a7da4e6885245e567c4fedb24dc646e8a1c" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;out&amp;rsquo; keyword argument is expected to be a tuple with one entry per output (which can be &lt;code&gt;None&lt;/code&gt; for arrays to be allocated by the ufunc). For ufuncs with a single output, passing a single array (instead of a tuple holding a single array) is also valid.</source>
          <target state="translated">关键字'out'参数应为每个输出只有一个条目的元组（对于由ufunc分配的数组，可以为 &lt;code&gt;None&lt;/code&gt; ）。对于具有单个输出的ufunc，传递单个数组（而不是包含单个数组的元组）也是有效的。</target>
        </trans-unit>
        <trans-unit id="db204a13b36f2cf86d7bd1794820137a1ac066ee" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;out&amp;rsquo; keyword argument is expected to be a tuple with one entry per output (which can be None for arrays to be allocated by the ufunc). For ufuncs with a single output, passing a single array (instead of a tuple holding a single array) is also valid.</source>
          <target state="translated">关键字'out'参数应为每个输出只有一个条目的元组（对于由ufunc分配的数组，可以为None）。对于具有单个输出的ufunc，传递单个数组（而不是包含单个数组的元组）也是有效的。</target>
        </trans-unit>
        <trans-unit id="34701f78458bf915d5b828bf9386058d6824fbe4" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;per&amp;rsquo; variable represents the periods of the loan. Remember that financial equations start the period count at 1!</source>
          <target state="translated">&amp;ldquo;每&amp;rdquo;变量代表贷款的期限。请记住，财务方程式从1开始计算期间！</target>
        </trans-unit>
        <trans-unit id="cb090179fdd970838b19c1b214a4530cfcd16ee3" translate="yes" xml:space="preserve">
          <source>The (non-conjugated) transpose of the matrix.</source>
          <target state="translated">矩阵的(非共轭)转置。</target>
        </trans-unit>
        <trans-unit id="2c0a3ac18c0e35ff547f3a4005419b0e018f9e8e" translate="yes" xml:space="preserve">
          <source>The 1.6 implementation of datetime does not convert between units correctly.:</source>
          <target state="translated">1.6实现的datetime不能正确转换单位。</target>
        </trans-unit>
        <trans-unit id="f72725eb7318a896f41cd0cf447d8c91f324fb0d" translate="yes" xml:space="preserve">
          <source>The 1.6 implementation of datetime only works correctly for a small subset of arithmetic operations. Here we show some simple cases.:</source>
          <target state="translated">1.6版本的datetime只在一小部分算术运算中正确运行。这里我们展示了一些简单的案例。</target>
        </trans-unit>
        <trans-unit id="887cfe3b8a793575511e5fe48982dbd8c7813d6e" translate="yes" xml:space="preserve">
          <source>The 2-D output array.</source>
          <target state="translated">二维输出阵列。</target>
        </trans-unit>
        <trans-unit id="8d40d72287619706da0622aa60cf9b527faa81be" translate="yes" xml:space="preserve">
          <source>The 24 built-in &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;array scalar type objects&lt;/a&gt; all convert to an associated data-type object. This is true for their sub-classes as well.</source>
          <target state="translated">24个内置&lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;数组标量类型对象&lt;/a&gt;都转换为关联的数据类型对象。他们的子类别也是如此。</target>
        </trans-unit>
        <trans-unit id="3182f1dfa2639174f8b34fe5f092a96393f1cf6d" translate="yes" xml:space="preserve">
          <source>The 64-bit OpenBLAS with &lt;code&gt;64_&lt;/code&gt; symbol suffix is obtained by compiling OpenBLAS with settings:</source>
          <target state="translated">带有 &lt;code&gt;64_&lt;/code&gt; 符号后缀的64位OpenBLAS是通过使用以下设置编译OpenBLAS来获得的：</target>
        </trans-unit>
        <trans-unit id="44abfc0b778e06539587a775fdc8b33ee9085231" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; array flags can be &amp;ldquo;calculated&amp;rdquo; from the array object itself. This routine updates one or more of these flags of &lt;em&gt;arr&lt;/em&gt; as specified in &lt;em&gt;flagmask&lt;/em&gt; by performing the required calculation.</source>
          <target state="translated">的&lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;从阵列对象本身阵列标志可&amp;ldquo;计算&amp;rdquo;。此例程通过执行所需的计算来更新标志&lt;em&gt;掩码中&lt;/em&gt;指定的&lt;em&gt;arr&lt;/em&gt;标志中的一个或多个。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5ab1d9e20a833c167142777c07717d8769b7541" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the built-in type of the data-type-descriptor objects used to describe how the bytes comprising the array are to be interpreted. There are 21 statically-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects for the built-in data-types. While these participate in reference counting, their reference count should never reach zero. There is also a dynamic table of user-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects that is also maintained. Once a data-type-descriptor object is &amp;ldquo;registered&amp;rdquo; it should never be deallocated either. The function &lt;a href=&quot;array#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to retrieve a &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object from an enumerated type-number (either built-in or user- defined).</source>
          <target state="translated">该&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt;是内置型的数据类型描述符的对象用于描述包含在阵列中的字节是如何被解释。内置数据类型有21个静态定义的&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;对象。尽管这些都参与了参考计数，但它们的参考计数绝不能达到零。还有一个动态表，其中包含用户定义的&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;对象。一旦数据类型描述符对象被&amp;ldquo;注册&amp;rdquo;，它也绝不能被释放。函数&lt;a href=&quot;array#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）可用于从枚举的类型号（内置的或用户定义的）中检索&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="83e501c171dddeb86862ef16beddd704b5bc114a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the built-in type of the data-type-descriptor objects used to describe how the bytes comprising the array are to be interpreted. There are 21 statically-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects for the built-in data-types. While these participate in reference counting, their reference count should never reach zero. There is also a dynamic table of user-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects that is also maintained. Once a data-type-descriptor object is &amp;ldquo;registered&amp;rdquo; it should never be deallocated either. The function &lt;a href=&quot;c-api.array#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to retrieve a &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object from an enumerated type-number (either built-in or user- defined).</source>
          <target state="translated">该&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt;是内置型的数据类型描述符的对象用于描述包含在阵列中的字节是如何被解释。内置数据类型有21个静态定义的&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;对象。尽管这些都参与了参考计数，但它们的参考计数绝不能达到零。还存在一个用户定义的&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;对象的动态表。一旦数据类型描述符对象被&amp;ldquo;注册&amp;rdquo;，它也绝不能被释放。函数&lt;a href=&quot;c-api.array#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）可用于从枚举的类型号（内置的或用户定义的）中检索&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="97cab03f1f33635249cbaecab51bab4753bac00b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure is defined so that NumPy and other extension modules can use the rapid array interface protocol. The &lt;a href=&quot;../arrays.interface#object.__array_struct__&quot;&gt;&lt;code&gt;__array_struct__&lt;/code&gt;&lt;/a&gt; method of an object that supports the rapid array interface protocol should return a &lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt;&lt;code&gt;PyCapsule&lt;/code&gt;&lt;/a&gt; that contains a pointer to a &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure with the relevant details of the array. After the new array is created, the attribute should be &lt;code&gt;DECREF&lt;/code&gt;&amp;rsquo;d which will free the &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure. Remember to &lt;code&gt;INCREF&lt;/code&gt; the object (whose &lt;a href=&quot;../arrays.interface#object.__array_struct__&quot;&gt;&lt;code&gt;__array_struct__&lt;/code&gt;&lt;/a&gt; attribute was retrieved) and point the base member of the new &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; to this same object. In this way the memory for the array will be managed correctly.</source>
          <target state="translated">该&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;结构被限定为使得NumPy的和其它的扩展模块可以使用快速阵列接口协议。所述&lt;a href=&quot;../arrays.interface#object.__array_struct__&quot;&gt; &lt;code&gt;__array_struct__&lt;/code&gt; &lt;/a&gt;一个对象，该支撑件的快速阵列接口协议应返回的方法&lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt; &lt;code&gt;PyCapsule&lt;/code&gt; &lt;/a&gt;包含一个指向&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;与阵列的相关细节结构。创建新数组后，该属性应为 &lt;code&gt;DECREF&lt;/code&gt; ，这将释放&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;结构。记得 &lt;code&gt;INCREF&lt;/code&gt; 对象（其&lt;a href=&quot;../arrays.interface#object.__array_struct__&quot;&gt; &lt;code&gt;__array_struct__&lt;/code&gt; &lt;/a&gt;属性被检索）和指向新的基体构件&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;到同一对象。这样，将正确管理阵列的内存。</target>
        </trans-unit>
        <trans-unit id="3bd6fb4bf6c794847df919e4e53f9f40e8a12e37" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure is defined so that NumPy and other extension modules can use the rapid array interface protocol. The &lt;code&gt;__array_struct__&lt;/code&gt; method of an object that supports the rapid array interface protocol should return a &lt;code&gt;PyCObject&lt;/code&gt; that contains a pointer to a &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure with the relevant details of the array. After the new array is created, the attribute should be &lt;code&gt;DECREF&lt;/code&gt;&amp;rsquo;d which will free the &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure. Remember to &lt;code&gt;INCREF&lt;/code&gt; the object (whose &lt;code&gt;__array_struct__&lt;/code&gt; attribute was retrieved) and point the base member of the new &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; to this same object. In this way the memory for the array will be managed correctly.</source>
          <target state="translated">该&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;结构被限定为使得NumPy的和其它的扩展模块可以使用快速阵列接口协议。所述 &lt;code&gt;__array_struct__&lt;/code&gt; 的对象的方法，该方法支持快速阵列接口协议应返回 &lt;code&gt;PyCObject&lt;/code&gt; 包含一个指向&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;与阵列的相关细节结构。创建新数组后，该属性应为 &lt;code&gt;DECREF&lt;/code&gt; ，这将释放&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;结构。记得 &lt;code&gt;INCREF&lt;/code&gt; 对象（其 &lt;code&gt;__array_struct__&lt;/code&gt; 属性被检索）和指向新的基体构件&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;到同一对象。这样，将正确管理阵列的内存。</target>
        </trans-unit>
        <trans-unit id="e1afd7f4d29ab170c9bd7906c54475c6dcf363f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; C-structure contains all of the required information for an array. All instances of an ndarray (and its subclasses) will have this structure. For future compatibility, these structure members should normally be accessed using the provided macros. If you need a shorter name, then you can make use of &lt;a href=&quot;#c.NPY_AO&quot;&gt;&lt;code&gt;NPY_AO&lt;/code&gt;&lt;/a&gt; (deprecated) which is defined to be equivalent to &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;. Direct access to the struct fields are deprecated. Use the &lt;code&gt;PyArray_*(arr)&lt;/code&gt; form instead. As of NumPy 1.20, the size of this struct is not considered part of the NumPy ABI (see note at the end of the member list).</source>
          <target state="translated">所述&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; C-结构包含所有用于阵列所需的信息。ndarray（及其子类）的所有实例都将具有此结构。为了将来的兼容性，通常应使用提供的宏来访问这些结构成员。如果您需要一个较短的名称，则可以使用&lt;a href=&quot;#c.NPY_AO&quot;&gt; &lt;code&gt;NPY_AO&lt;/code&gt; &lt;/a&gt;（已弃用），它被定义为与&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;等效。不建议直接访问struct字段。请改用 &lt;code&gt;PyArray_*(arr)&lt;/code&gt; 形式。从NumPy 1.20开始，此结构的大小不被视为NumPy ABI的一部分（请参阅成员列表末尾的注释）。</target>
        </trans-unit>
        <trans-unit id="cd84e3bef1191839ce6ab3739e785dd2e1559188" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; C-structure contains all of the required information for an array. All instances of an ndarray (and its subclasses) will have this structure. For future compatibility, these structure members should normally be accessed using the provided macros. If you need a shorter name, then you can make use of &lt;code&gt;NPY_AO&lt;/code&gt; (deprecated) which is defined to be equivalent to &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; C-结构包含所有用于阵列所需的信息。ndarray（及其子类）的所有实例都将具有此结构。为了将来的兼容性，通常应使用提供的宏来访问这些结构成员。如果您需要一个较短的名称，则可以使用 &lt;code&gt;NPY_AO&lt;/code&gt; （已弃用），其定义与&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;等效。</target>
        </trans-unit>
        <trans-unit id="ef190e5abe2d8e5d647d302d7a90a94792c8ed21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; C-structure contains all of the required information for an array. All instances of an ndarray (and its subclasses) will have this structure. For future compatibility, these structure members should normally be accessed using the provided macros. If you need a shorter name, then you can make use of &lt;code&gt;NPY_AO&lt;/code&gt; (deprecated) which is defined to be equivalent to &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;. Direct access to the struct fields are deprecated. Use the &lt;code&gt;PyArray_*(arr)&lt;/code&gt; form instead.</source>
          <target state="translated">所述&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; C-结构包含所有用于阵列所需的信息。ndarray（及其子类）的所有实例都将具有此结构。为了将来的兼容性，通常应使用提供的宏来访问这些结构成员。如果您需要一个较短的名称，则可以使用 &lt;code&gt;NPY_AO&lt;/code&gt; （已弃用），它被定义为与&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;等效。不建议直接访问struct字段。请改用 &lt;code&gt;PyArray_*(arr)&lt;/code&gt; 形式。</target>
        </trans-unit>
        <trans-unit id="9d2c044849f6b8be8bb6f06a8ac4ced885f369cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure lies at the heart of the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt;. While it is described here for completeness, it should be considered internal to NumPy and manipulated via &lt;code&gt;PyArrayDescr_*&lt;/code&gt; or &lt;code&gt;PyDataType*&lt;/code&gt; functions and macros. The size of this structure is subject to change across versions of NumPy. To ensure compatibility:</source>
          <target state="translated">该&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;结构熟记于的心脏&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt;。尽管此处出于完整性的目的对其进行了说明，但应将其视为NumPy的内部内容，并通过 &lt;code&gt;PyArrayDescr_*&lt;/code&gt; 或 &lt;code&gt;PyDataType*&lt;/code&gt; 函数和宏进行操作。此结构的大小可能会在NumPy的各个版本中发生变化。为确保兼容性：</target>
        </trans-unit>
        <trans-unit id="2e3e60e01ee7ee0a4514d09bc8a1e601d0467625" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; typeobject implements many of the features of &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyTypeObject&quot;&gt;&lt;code&gt;Python objects&lt;/code&gt;&lt;/a&gt; including the &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_number&quot;&gt;&lt;code&gt;tp_as_number&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence&quot;&gt;&lt;code&gt;tp_as_sequence&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping&quot;&gt;&lt;code&gt;tp_as_mapping&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer&quot;&gt;&lt;code&gt;tp_as_buffer&lt;/code&gt;&lt;/a&gt; interfaces. The &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.richcmpfunc&quot;&gt;&lt;code&gt;rich comparison&lt;/code&gt;&lt;/a&gt;) is also used along with new-style attribute lookup for member (&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_members&quot;&gt;&lt;code&gt;tp_members&lt;/code&gt;&lt;/a&gt;) and properties (&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_getset&quot;&gt;&lt;code&gt;tp_getset&lt;/code&gt;&lt;/a&gt;). The &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; can also be sub-typed.</source>
          <target state="translated">该&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; typeobject实现了许多的功能&lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyTypeObject&quot;&gt; &lt;code&gt;Python objects&lt;/code&gt; &lt;/a&gt;包括&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_number&quot;&gt; &lt;code&gt;tp_as_number&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence&quot;&gt; &lt;code&gt;tp_as_sequence&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping&quot;&gt; &lt;code&gt;tp_as_mapping&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer&quot;&gt; &lt;code&gt;tp_as_buffer&lt;/code&gt; &lt;/a&gt;接口。在&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.richcmpfunc&quot;&gt; &lt;code&gt;rich comparison&lt;/code&gt; &lt;/a&gt;）也与新样式属性查找会员（用于沿&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_members&quot;&gt; &lt;code&gt;tp_members&lt;/code&gt; &lt;/a&gt;）和属性（&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_getset&quot;&gt; &lt;code&gt;tp_getset&lt;/code&gt; &lt;/a&gt;）。该&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;也可以是子类型。</target>
        </trans-unit>
        <trans-unit id="aa6c6f999e9bb42f4a925a834755e66032534d3b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.bitgen_t&quot;&gt;&lt;code&gt;bitgen_t&lt;/code&gt;&lt;/a&gt; holds the current state of the BitGenerator and pointers to functions that return standard C types while advancing the state.</source>
          <target state="translated">所述&lt;a href=&quot;#c.bitgen_t&quot;&gt; &lt;code&gt;bitgen_t&lt;/code&gt; &lt;/a&gt;保持BitGenerator和指针到返回标准的C类型而前进的状态的功能的当前状态。</target>
        </trans-unit>
        <trans-unit id="a7f3033ad68411cb4e323558e1cdf3cb92ca263d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module provides a set of vectorized string operations for arrays of type &lt;a href=&quot;arrays.scalars#numpy.str_&quot;&gt;&lt;code&gt;numpy.str_&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;arrays.scalars#numpy.bytes_&quot;&gt;&lt;code&gt;numpy.bytes_&lt;/code&gt;&lt;/a&gt;. All of them are based on the string methods in the Python standard library.</source>
          <target state="translated">所述&lt;a href=&quot;#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;模块提供类型的数组的一组矢量的字符串操作的&lt;a href=&quot;arrays.scalars#numpy.str_&quot;&gt; &lt;code&gt;numpy.str_&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;arrays.scalars#numpy.bytes_&quot;&gt; &lt;code&gt;numpy.bytes_&lt;/code&gt; &lt;/a&gt;。它们全部基于Python标准库中的字符串方法。</target>
        </trans-unit>
        <trans-unit id="f2f36b5d156bf75520af226984583d62ec445b7c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module provides a set of vectorized string operations for arrays of type &lt;code&gt;numpy.string_&lt;/code&gt; or &lt;code&gt;numpy.unicode_&lt;/code&gt;. All of them are based on the string methods in the Python standard library.</source>
          <target state="translated">所述&lt;a href=&quot;#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;模块提供类型的数组的一组矢量的字符串操作的 &lt;code&gt;numpy.string_&lt;/code&gt; 或 &lt;code&gt;numpy.unicode_&lt;/code&gt; 。它们全部基于Python标准库中的字符串方法。</target>
        </trans-unit>
        <trans-unit id="2314014335c763a38d9f2613dc7158883ea47e7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module can be used as an addition to &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">所述&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt;模块可以被用作除了&lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; 的&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="bc31921d14e06fe1077c1cf00e508c39081a2db7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module comes with a specific implementation of most ufuncs. Unary and binary functions that have a validity domain (such as &lt;a href=&quot;generated/numpy.log#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.divide#numpy.divide&quot;&gt;&lt;code&gt;divide&lt;/code&gt;&lt;/a&gt;) return the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; constant whenever the input is masked or falls outside the validity domain:</source>
          <target state="translated">该&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt;模块配备了一个具体实施最ufuncs的。具有有效域（例如&lt;a href=&quot;generated/numpy.log#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;generated/numpy.divide#numpy.divide&quot;&gt; &lt;code&gt;divide&lt;/code&gt; &lt;/a&gt;）的一元和二进制函数在输入被屏蔽或超出有效域范围时返回&lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;常量：</target>
        </trans-unit>
        <trans-unit id="fa3b79ebc7390f266094dfbaf9c2d9e50cf1ca20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.bool_&quot;&gt;&lt;code&gt;bool_&lt;/code&gt;&lt;/a&gt; data type is very similar to the Python &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; but does not inherit from it because Python&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; does not allow itself to be inherited from, and on the C-level the size of the actual bool data is not the same as a Python Boolean scalar.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.bool_&quot;&gt; &lt;code&gt;bool_&lt;/code&gt; &lt;/a&gt;数据类型非常相似，Python的&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;，但不继承它，因为Python的&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;不允许自己被继承，并在C级的实际布尔数据的大小是不一样的一个Python布尔标量。</target>
        </trans-unit>
        <trans-unit id="8bb6355ecaeb41d5fc25266f7c26f41c7ee5179d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.bool_&quot;&gt;&lt;code&gt;bool_&lt;/code&gt;&lt;/a&gt; type is not a subclass of the &lt;a href=&quot;#numpy.int_&quot;&gt;&lt;code&gt;int_&lt;/code&gt;&lt;/a&gt; type (the &lt;a href=&quot;#numpy.bool_&quot;&gt;&lt;code&gt;bool_&lt;/code&gt;&lt;/a&gt; is not even a number type). This is different than Python&amp;rsquo;s default implementation of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; as a sub-class of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.bool_&quot;&gt; &lt;code&gt;bool_&lt;/code&gt; &lt;/a&gt;类型不是的一个子类&lt;a href=&quot;#numpy.int_&quot;&gt; &lt;code&gt;int_&lt;/code&gt; &lt;/a&gt;类型（&lt;a href=&quot;#numpy.bool_&quot;&gt; &lt;code&gt;bool_&lt;/code&gt; &lt;/a&gt;甚至不是一个数类型）。这与Python默认将&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;作为&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;的子类实现不同。</target>
        </trans-unit>
        <trans-unit id="b2581729cb5a508c4225155bce5e9d0c211d34fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;存在与Numarray向后兼容类，所以不推荐在新的发展。从numpy的1.4开始，如果字符串中的一个需要数组，建议使用数组&lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; ， &lt;code&gt;string_&lt;/code&gt; 或 &lt;code&gt;unicode_&lt;/code&gt; ，以及在使用免费的功能&lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;快速矢量字符串操作模块。</target>
        </trans-unit>
        <trans-unit id="bfd56b98bdff55bc0967f4255e8d608e0cada88c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.char.chararray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.char.chararray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;物可类似于字典的（如在被访问 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ），或通过使用小写属性名称（如在 &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短标志名仅在字典访问中受支持。</target>
        </trans-unit>
        <trans-unit id="09be04e2f9d7e3507979d5970697a0d5b8afb3bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;../arrays.scalars#numpy.object_&quot;&gt;&lt;code&gt;object_&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../arrays.scalars#numpy.string_&quot;&gt;&lt;code&gt;string_&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../arrays.scalars#numpy.unicode_&quot;&gt;&lt;code&gt;unicode_&lt;/code&gt;&lt;/a&gt;, and use the free functions in the &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;存在与Numarray向后兼容类，所以不推荐在新的发展。从numpy的1.4开始，如果字符串中的一个需要数组，建议使用数组&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../arrays.scalars#numpy.object_&quot;&gt; &lt;code&gt;object_&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../arrays.scalars#numpy.string_&quot;&gt; &lt;code&gt;string_&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../arrays.scalars#numpy.unicode_&quot;&gt; &lt;code&gt;unicode_&lt;/code&gt; &lt;/a&gt;，以及在使用免费的功能&lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;快速矢量字符串操作模块。</target>
        </trans-unit>
        <trans-unit id="5b3e9186bfdffbf3c12bbb5a751b0411b0862a0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;存在与Numarray向后兼容类，所以不推荐在新的发展。从numpy的1.4开始，如果字符串中的一个需要数组，建议使用数组&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; ， &lt;code&gt;string_&lt;/code&gt; 或 &lt;code&gt;unicode_&lt;/code&gt; ，以及在使用免费的功能&lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;快速矢量字符串操作模块。</target>
        </trans-unit>
        <trans-unit id="680a1891b2c8f5bcdb98b3e8673e99320813b4a5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.chararray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.chararray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;物可类似于字典的（如在被访问 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ），或通过使用小写属性名称（如在 &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短标志名仅在字典访问中受支持。</target>
        </trans-unit>
        <trans-unit id="fd3c89bd69aef7cd1fbb65d37b473ebbe78ede31" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.divmod&quot;&gt;&lt;code&gt;divmod&lt;/code&gt;&lt;/a&gt; function can be used as a shorthand for &lt;code&gt;np.divmod&lt;/code&gt; on ndarrays.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.divmod&quot;&gt; &lt;code&gt;divmod&lt;/code&gt; &lt;/a&gt;函数可以用作速记 &lt;code&gt;np.divmod&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="a4b36fc0eface1e15cca304b6a430b16f1e89759" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.int_&quot;&gt;&lt;code&gt;int_&lt;/code&gt;&lt;/a&gt; type does &lt;strong&gt;not&lt;/strong&gt; inherit from the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; built-in under Python 3, because type &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; is no longer a fixed-width integer type.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.int_&quot;&gt; &lt;code&gt;int_&lt;/code&gt; &lt;/a&gt;类型并&lt;strong&gt;没有&lt;/strong&gt;从继承&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;内置Python 3下，因为型&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;不再是固定宽度的整数类型。</target>
        </trans-unit>
        <trans-unit id="3c48c115471617c80e93a7432dc970b4f61e8b90" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.MaskedArray.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt;, as a regular &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt; of any shape or datatype (the data).</source>
          <target state="translated">的&lt;a href=&quot;#numpy.ma.MaskedArray.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt;，作为常规&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt;任何形状或数据类型（数据）的。</target>
        </trans-unit>
        <trans-unit id="a0df6452154474f3f899180d65ac301d22c1fea9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.MaskedArray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.ma.MaskedArray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;物可类似于字典的（如在被访问 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ），或通过使用小写属性名称（如在 &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短标志名仅在字典访问中受支持。</target>
        </trans-unit>
        <trans-unit id="768878a0d288c4cac805d022d60e3e5c74cdd571" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; constant is a special case of &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, with a float datatype and a null shape. It is used to test whether a specific entry of a masked array is masked, or to mask one or several entries of a masked array:</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;常数的特殊情况&lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;，具有float数据类型和一个空的形状。它用于测试是否屏蔽了掩码数组的特定条目，或掩码了掩码数组的一个或多个条目：</target>
        </trans-unit>
        <trans-unit id="7aed7dc2945cfed4e354b7948f5becc4b487bdfa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.masked_array.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.ma.masked_array.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;物可类似于字典的（如在被访问 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ），或通过使用小写属性名称（如在 &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短标志名仅在字典访问中受支持。</target>
        </trans-unit>
        <trans-unit id="146a5b50c3ebb2fb745630d24192949df345a171" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.matrix.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.matrix.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;物可类似于字典的（如在被访问 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ），或通过使用小写属性名称（如在 &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短标志名仅在字典访问中受支持。</target>
        </trans-unit>
        <trans-unit id="3f13797b1afe52954d80b3598ced06b92d07000d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.memmap.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.memmap.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;物可类似于字典的（如在被访问 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ），或通过使用小写属性名称（如在 &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短标志名仅在字典访问中受支持。</target>
        </trans-unit>
        <trans-unit id="59336961ce31b9039ac38b42d5319606fa0f917b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ndarray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.ndarray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;物可类似于字典的（如在被访问 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ），或通过使用小写属性名称（如在 &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短标志名仅在字典访问中受支持。</target>
        </trans-unit>
        <trans-unit id="6d0bd00bbf169f78d9e7d2f8db44466c1472859d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; provides access to a wide range of distributions, and served as a replacement for &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. The main difference between the two is that &lt;code&gt;Generator&lt;/code&gt; relies on an additional BitGenerator to manage state and generate the random bits, which are then transformed into random values from useful distributions. The default BitGenerator used by &lt;code&gt;Generator&lt;/code&gt; is &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt;. The BitGenerator can be changed by passing an instantized BitGenerator to &lt;code&gt;Generator&lt;/code&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;可以访问广泛分布的，并作为一个替换&lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;。两者之间的主要区别是 &lt;code&gt;Generator&lt;/code&gt; 依赖于附加的BitGenerator来管理状态并生成随机位，然后将这些随机位从有用的分布转换为随机值。 &lt;code&gt;Generator&lt;/code&gt; 使用的默认BitGenerator为&lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;。可以通过将实例化的BitGenerator传递给 &lt;code&gt;Generator&lt;/code&gt; 来更改BitGenerator 。</target>
        </trans-unit>
        <trans-unit id="550894140eb6b413b0c8bb49cded0a5d50198b4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; provides access to a wide range of distributions, and served as a replacement for &lt;code&gt;RandomState&lt;/code&gt;. The main difference between the two is that &lt;code&gt;Generator&lt;/code&gt; relies on an additional BitGenerator to manage state and generate the random bits, which are then transformed into random values from useful distributions. The default BitGenerator used by &lt;code&gt;Generator&lt;/code&gt; is &lt;code&gt;PCG64&lt;/code&gt;. The BitGenerator can be changed by passing an instantized BitGenerator to &lt;code&gt;Generator&lt;/code&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;可以访问广泛分布的，并作为一个替换 &lt;code&gt;RandomState&lt;/code&gt; 。两者之间的主要区别在于 &lt;code&gt;Generator&lt;/code&gt; 依赖于附加的BitGenerator来管理状态并生成随机位，然后将这些随机位从有用的分布转换为随机值。 &lt;code&gt;Generator&lt;/code&gt; 使用的默认BitGenerator 为 &lt;code&gt;PCG64&lt;/code&gt; 。可以通过将实例化的BitGenerator传递给 &lt;code&gt;Generator&lt;/code&gt; 来更改BitGenerator 。</target>
        </trans-unit>
        <trans-unit id="f79d27f6e9c849366cec196aa3ca02a3888f3ef3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; provides access to legacy generators. This generator is considered frozen and will have no further improvements. It is guaranteed to produce the same values as the final point release of NumPy v1.16. These all depend on Box-Muller normals or inverse CDF exponentials or gammas. This class should only be used if it is essential to have randoms that are identical to what would have been produced by previous versions of NumPy.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;提供访问旧式发电机。该生成器被认为是冻结的，将没有进一步的改进。保证产生与NumPy v1.16的最终版本相同的值。这些都取决于Box-Muller法线或反CDF指数或伽马。仅当必须具有与以前版本的NumPy产生的随机数相同的随机数时，才应使用此类。</target>
        </trans-unit>
        <trans-unit id="c4a823e24105a263472e6db5aa11ef1abc5d69b0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; provides access to legacy generators. This generator is considered frozen and will have no further improvements. It is guaranteed to produce the same values as the final point release of NumPy v1.16. These all depend on Box-Muller normals or inverse CDF exponentials or gammas. This class should only be used if it is essential to have randoms that are identical to what would have been produced by previous versions of NumPy.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;提供访问旧式发电机。该生成器被认为是冻结的，将没有进一步的改进。保证产生与NumPy v1.16的最终版本相同的值。这些都取决于Box-Muller法线或反CDF指数或伽马。仅当必须具有与以前版本的NumPy产生的随机数相同的随机数时，才应使用此类。</target>
        </trans-unit>
        <trans-unit id="81979ac862ad90b476e52b55f8477208f98b95b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.recarray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.recarray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;物可类似于字典的（如在被访问 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ），或通过使用小写属性名称（如在 &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短标志名仅在字典访问中受支持。</target>
        </trans-unit>
        <trans-unit id="84da36ced33272fa147152f5a355ea7313e10b52" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.sign&quot;&gt;&lt;code&gt;sign&lt;/code&gt;&lt;/a&gt; function returns &lt;code&gt;-1 if x &amp;lt; 0, 0 if x==0, 1 if x &amp;gt; 0&lt;/code&gt;. nan is returned for nan inputs.</source>
          <target state="translated">的&lt;a href=&quot;#numpy.sign&quot;&gt; &lt;code&gt;sign&lt;/code&gt; &lt;/a&gt;函数返回 &lt;code&gt;-1 if x &amp;lt; 0, 0 if x==0, 1 if x &amp;gt; 0&lt;/code&gt; 。返回nan作为nan输入。</target>
        </trans-unit>
        <trans-unit id="158d36e54da803a47a7693e104765168fbd40d0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.testing.dec.deprecated&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt; decorator itself.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.testing.dec.deprecated&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;装饰本身。</target>
        </trans-unit>
        <trans-unit id="c8f5bdf7e480a14edfbd94978da2fd35d2b6fd26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.testing.decorators.deprecated&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt; decorator itself.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.testing.decorators.deprecated&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;装饰本身。</target>
        </trans-unit>
        <trans-unit id="bc50ca3a4518970647f9ac3d39890db20ed25800" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.typing.ArrayLike&quot;&gt;&lt;code&gt;ArrayLike&lt;/code&gt;&lt;/a&gt; type tries to avoid creating object arrays. For example,</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.typing.ArrayLike&quot;&gt; &lt;code&gt;ArrayLike&lt;/code&gt; &lt;/a&gt;类型试图避免创建对象阵列。例如，</target>
        </trans-unit>
        <trans-unit id="da249e1d126343fd0059e721337a79a20ba3ee7c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.typing.DTypeLike&quot;&gt;&lt;code&gt;DTypeLike&lt;/code&gt;&lt;/a&gt; type tries to avoid creation of dtype objects using dictionary of fields like below:</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.typing.DTypeLike&quot;&gt; &lt;code&gt;DTypeLike&lt;/code&gt; &lt;/a&gt;类型试图避免产生D型细胞的对象使用类似下面字段的词典：</target>
        </trans-unit>
        <trans-unit id="f00c158e6b19c749648df9ba6c6e65d03c7d496b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.vectorize&quot;&gt;&lt;code&gt;vectorize&lt;/code&gt;&lt;/a&gt; function is provided primarily for convenience, not for performance. The implementation is essentially a for loop.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.vectorize&quot;&gt; &lt;code&gt;vectorize&lt;/code&gt; &lt;/a&gt;功能主要是为了方便而提供，而不是性能。该实现实质上是一个for循环。</target>
        </trans-unit>
        <trans-unit id="5870961c86339efdff46c3532a51705af2f592f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;datetime unit&lt;/a&gt; on which this dtype is based.</source>
          <target state="translated">此dtype所基于的&lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;datetime单位&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a8f8d0455dbf7ee235ddf8ac19ee0fef4868e46" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/c-api/array#c.PyArray_IterAllButAxis&quot;&gt;&lt;code&gt;PyArray_IterAllButAxis&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;array&lt;/code&gt;, &lt;code&gt;&amp;amp;dim&lt;/code&gt; ) constructs an iterator object that is modified so that it will not iterate over the dimension indicated by dim. The only restriction on this iterator object, is that the &lt;a href=&quot;../reference/c-api/array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;it&lt;/code&gt;, &lt;code&gt;ind&lt;/code&gt; ) macro cannot be used (thus flat indexing won&amp;rsquo;t work either if you pass this object back to Python &amp;mdash; so you shouldn&amp;rsquo;t do this). Note that the returned object from this routine is still usually cast to PyArrayIterObject *. All that&amp;rsquo;s been done is to modify the strides and dimensions of the returned iterator to simulate iterating over array[&amp;hellip;,0,&amp;hellip;] where 0 is placed on the</source>
          <target state="translated">所述&lt;a href=&quot;../reference/c-api/array#c.PyArray_IterAllButAxis&quot;&gt; &lt;code&gt;PyArray_IterAllButAxis&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;array&lt;/code&gt; ， &lt;code&gt;&amp;amp;dim&lt;/code&gt; ）构造被修改，使得它不会遍历尺寸表示在昏暗的迭代器对象。对该迭代器对象的唯一限制是，不能使用&lt;a href=&quot;../reference/c-api/array#c.PyArray_ITER_GOTO1D&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;it&lt;/code&gt; ， &lt;code&gt;ind&lt;/code&gt; ）宏（因此，如果将此对象传递回Python，则平面索引也将不起作用-因此不应该这样做）。请注意，从该例程返回的对象通常仍转换为PyArrayIterObject *。完成的所有操作都是修改返回的迭代器的步幅和尺寸，以模拟对array [&amp;hellip;，0，&amp;hellip;]进行迭代，其中将0放在</target>
        </trans-unit>
        <trans-unit id="3bf8c2953924a9568aac6e665e279dc1312c55ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/c-api/array#c.PyArray_IterAllButAxis&quot;&gt;&lt;code&gt;PyArray_IterAllButAxis&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;array&lt;/code&gt;, &lt;code&gt;&amp;amp;dim&lt;/code&gt; ) constructs an iterator object that is modified so that it will not iterate over the dimension indicated by dim. The only restriction on this iterator object, is that the &lt;code&gt;PyArray_Iter_GOTO1D&lt;/code&gt; ( &lt;code&gt;it&lt;/code&gt;, &lt;code&gt;ind&lt;/code&gt; ) macro cannot be used (thus flat indexing won&amp;rsquo;t work either if you pass this object back to Python &amp;mdash; so you shouldn&amp;rsquo;t do this). Note that the returned object from this routine is still usually cast to PyArrayIterObject *. All that&amp;rsquo;s been done is to modify the strides and dimensions of the returned iterator to simulate iterating over array[&amp;hellip;,0,&amp;hellip;] where 0 is placed on the</source>
          <target state="translated">所述&lt;a href=&quot;../reference/c-api/array#c.PyArray_IterAllButAxis&quot;&gt; &lt;code&gt;PyArray_IterAllButAxis&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;array&lt;/code&gt; ， &lt;code&gt;&amp;amp;dim&lt;/code&gt; ）构造被修改，使得它不会遍历尺寸表示在昏暗的迭代器对象。对该迭代器对象的唯一限制是，不能使用 &lt;code&gt;PyArray_Iter_GOTO1D&lt;/code&gt; （ &lt;code&gt;it&lt;/code&gt; ， &lt;code&gt;ind&lt;/code&gt; ）宏（因此，如果将此对象传递回Python，则平面索引也将不起作用-因此不应该这样做）。请注意，从该例程返回的对象通常仍转换为PyArrayIterObject *。完成的所有操作都是修改返回的迭代器的步幅和尺寸，以模拟对array [&amp;hellip;，0，&amp;hellip;]进行迭代，其中将0放在</target>
        </trans-unit>
        <trans-unit id="bdc8c909824e69cdd63045d775139e4bf32c31d6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; function provides two other complementary mechanisms: the &lt;code&gt;missing_values&lt;/code&gt; argument is used to recognize missing data and a second argument, &lt;code&gt;filling_values&lt;/code&gt;, is used to process these missing data.</source>
          <target state="translated">所述&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;功能提供了其它两个互补机制： &lt;code&gt;missing_values&lt;/code&gt; 参数用于识别丢失的数据和第二个参数， &lt;code&gt;filling_values&lt;/code&gt; ，用于处理这些丢失的数据。</target>
        </trans-unit>
        <trans-unit id="26c941be06c3bf21e3b8632eab293bedde5eb0c6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; function can be used to combine different vectors so as to obtain the result for each n-uplet. For example, if you want to compute all the a+b*c for all the triplets taken from each of the vectors a, b and c:</source>
          <target state="translated">该&lt;a href=&quot;../reference/generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt;函数可用于不同的载体结合，以便获得对于每一个n-uplet结果。例如，如果要计算从向量a，b和c中的每一个获取的所有三元组的所有a + b * c：</target>
        </trans-unit>
        <trans-unit id="7647b692ad78d569f80f8f518b4edab8e65fa5cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/generated/numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;reshape&lt;/code&gt;&lt;/a&gt; function returns its argument with a modified shape, whereas the &lt;a href=&quot;../reference/generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt;&lt;code&gt;ndarray.resize&lt;/code&gt;&lt;/a&gt; method modifies the array itself:</source>
          <target state="translated">的&lt;a href=&quot;../reference/generated/numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;reshape&lt;/code&gt; &lt;/a&gt;函数返回其参数与经修饰的形状，而&lt;a href=&quot;../reference/generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt; &lt;code&gt;ndarray.resize&lt;/code&gt; &lt;/a&gt;方法修改阵列本身：</target>
        </trans-unit>
        <trans-unit id="28dfdb3c00777ce3fdb3f61c50c67ab257910e81" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/routines.linalg#module-numpy.linalg&quot;&gt;&lt;code&gt;linalg&lt;/code&gt;&lt;/a&gt; module includes a &lt;code&gt;norm&lt;/code&gt; function, which computes the norm of a vector or matrix represented in a NumPy array. For example, from the SVD explanation above, we would expect the norm of the difference between &lt;code&gt;img_gray&lt;/code&gt; and the reconstructed SVD product to be small. As expected, you should see something like</source>
          <target state="translated">所述&lt;a href=&quot;../reference/routines.linalg#module-numpy.linalg&quot;&gt; &lt;code&gt;linalg&lt;/code&gt; &lt;/a&gt;模块包括 &lt;code&gt;norm&lt;/code&gt; 函数，其计算在一个NumPy的阵列表示向量或矩阵的范数。例如，从上面的SVD解释中，我们期望 &lt;code&gt;img_gray&lt;/code&gt; 与重构的SVD产品之间的差异范数较小。不出所料，您应该会看到类似</target>
        </trans-unit>
        <trans-unit id="a98bd2e9d383259ba90aad2f3b46a4c0ddbbec99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../routines.testing#module-numpy.testing&quot;&gt;&lt;code&gt;numpy.testing&lt;/code&gt;&lt;/a&gt; module includes &lt;code&gt;import decorators as dec&lt;/code&gt;. A test can be decorated as slow like this:</source>
          <target state="translated">该&lt;a href=&quot;../routines.testing#module-numpy.testing&quot;&gt; &lt;code&gt;numpy.testing&lt;/code&gt; &lt;/a&gt;模块包括 &lt;code&gt;import decorators as dec&lt;/code&gt; 。可以像这样缓慢地装饰测试：</target>
        </trans-unit>
        <trans-unit id="de30aba764dee819e88bbb9fb0c475c23aa5f7b0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;arrays.scalars#numpy.timedelta64&quot;&gt;&lt;code&gt;timedelta64&lt;/code&gt;&lt;/a&gt; class is not considered a subclass of &lt;a href=&quot;arrays.scalars#numpy.signedinteger&quot;&gt;&lt;code&gt;signedinteger&lt;/code&gt;&lt;/a&gt;, the former only inheriting from &lt;a href=&quot;arrays.scalars#numpy.generic&quot;&gt;&lt;code&gt;generic&lt;/code&gt;&lt;/a&gt; while static type checking.</source>
          <target state="translated">该&lt;a href=&quot;arrays.scalars#numpy.timedelta64&quot;&gt; &lt;code&gt;timedelta64&lt;/code&gt; &lt;/a&gt;类不被认为的子类&lt;a href=&quot;arrays.scalars#numpy.signedinteger&quot;&gt; &lt;code&gt;signedinteger&lt;/code&gt; &lt;/a&gt;，前者只继承&lt;a href=&quot;arrays.scalars#numpy.generic&quot;&gt; &lt;code&gt;generic&lt;/code&gt; &lt;/a&gt;，而静态类型检查。</target>
        </trans-unit>
        <trans-unit id="081ce1a530a1e04a18f2e8f054e26ae81b0c4d57" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; has a limited set of responsibilities. It manages state and provides functions to produce random doubles and random unsigned 32- and 64-bit values.</source>
          <target state="translated">该&lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt;有一组有限的责任。它管理状态并提供产生随机双精度数和随机无符号32位和64位值的功能。</target>
        </trans-unit>
        <trans-unit id="c4d94d478ef39d11efc586cafc38818b04af19cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; function takes the iterators that have already been defined and uses them to determine the broadcast shape in each dimension (to create the iterators at the same time that broadcasting occurs then use the &lt;code&gt;PyMultiIter_New&lt;/code&gt; function). Then, the iterators are adjusted so that each iterator thinks it is iterating over an array with the broadcast size. This is done by adjusting the iterators number of dimensions, and the shape in each dimension. This works because the iterator strides are also adjusted. Broadcasting only adjusts (or adds) length-1 dimensions. For these dimensions, the strides variable is simply set to 0 so that the data-pointer for the iterator over that array doesn&amp;rsquo;t move as the broadcasting operation operates over the extended dimension.</source>
          <target state="translated">所述&lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt;函数采用已定义的迭代器和使用它们来确定在每个维度广播形状（在同一时间创建迭代器广播发生然后使用 &lt;code&gt;PyMultiIter_New&lt;/code&gt; 功能）。然后，调整迭代器，以便每个迭代器都认为它正在广播大小的数组上进行迭代。这可以通过调整迭代器的维数以及每个维中的形状来完成。这是可行的，因为还调整了迭代器的步幅。广播仅调整（或添加）长度为1的尺寸。对于这些维度，将strides变量简单地设置为0，以便当广播操作在扩展维度上进行操作时，该数组上迭代器的数据指针不会移动。</target>
        </trans-unit>
        <trans-unit id="c97c8834f84b1e523aa39964fc0db10088004e6f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; function takes the iterators that have already been defined and uses them to determine the broadcast shape in each dimension (to create the iterators at the same time that broadcasting occurs then use the &lt;a href=&quot;c-api/array#c.PyArray_MultiIterNew&quot;&gt;&lt;code&gt;PyArray_MultiIterNew&lt;/code&gt;&lt;/a&gt; function). Then, the iterators are adjusted so that each iterator thinks it is iterating over an array with the broadcast size. This is done by adjusting the iterators number of dimensions, and the shape in each dimension. This works because the iterator strides are also adjusted. Broadcasting only adjusts (or adds) length-1 dimensions. For these dimensions, the strides variable is simply set to 0 so that the data-pointer for the iterator over that array doesn&amp;rsquo;t move as the broadcasting operation operates over the extended dimension.</source>
          <target state="translated">所述&lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt;函数采用已定义的迭代器和使用它们来确定在每个维度广播形状（在同一时间创建迭代器广播发生然后使用&lt;a href=&quot;c-api/array#c.PyArray_MultiIterNew&quot;&gt; &lt;code&gt;PyArray_MultiIterNew&lt;/code&gt; &lt;/a&gt;功能）。然后，调整迭代器，以使每个迭代器都认为它正在广播大小的数组上进行迭代。这可以通过调整迭代器的维数以及每个维中的形状来完成。这是有效的，因为迭代器的步幅也已调整。广播仅调整（或添加）长度为1的尺寸。对于这些维度，将strides变量简单地设置为0，以便当广播操作在扩展维度上进行操作时，该数组上迭代器的数据指针不会移动。</target>
        </trans-unit>
        <trans-unit id="725a4957fd19b096134c24b6194f54dd74c72c01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; function takes the iterators that have already been defined and uses them to determine the broadcast shape in each dimension (to create the iterators at the same time that broadcasting occurs then use the &lt;code&gt;PyMultiIter_New&lt;/code&gt; function). Then, the iterators are adjusted so that each iterator thinks it is iterating over an array with the broadcast size. This is done by adjusting the iterators number of dimensions, and the shape in each dimension. This works because the iterator strides are also adjusted. Broadcasting only adjusts (or adds) length-1 dimensions. For these dimensions, the strides variable is simply set to 0 so that the data-pointer for the iterator over that array doesn&amp;rsquo;t move as the broadcasting operation operates over the extended dimension.</source>
          <target state="translated">所述&lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt;函数采用已定义的迭代器和使用它们来确定在每个维度广播形状（在同一时间创建迭代器广播发生然后使用 &lt;code&gt;PyMultiIter_New&lt;/code&gt; 功能）。然后，调整迭代器，以使每个迭代器都认为它正在广播大小的数组上进行迭代。这可以通过调整迭代器的维数以及每个维中的形状来完成。这是有效的，因为迭代器的步幅也已调整。广播仅调整（或添加）长度为1的尺寸。对于这些维度，将strides变量简单地设置为0，以便当广播操作在扩展维度上进行操作时，该数组上迭代器的数据指针不会移动。</target>
        </trans-unit>
        <trans-unit id="ebbc509274309886438bbf3a6fbee60f4ccccb56" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure is defined in &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; as:</source>
          <target state="translated">该&lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;结构定义在 &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; 为：</target>
        </trans-unit>
        <trans-unit id="d36f842f2997c8193b726b30df3debd673ecb729" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object can be used in all slicing operations to create an axis of length one. &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; is an alias for &amp;lsquo;None&amp;rsquo;, and &amp;lsquo;None&amp;rsquo; can be used in place of this with the same result.</source>
          <target state="translated">所述&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;对象可以在所有的限幅操作被用来创建一个长度的轴线。&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;是'None'的别名，可以使用'None'代替它并得到相同的结果。</target>
        </trans-unit>
        <trans-unit id="cc1b8dc088cfaeaf7d1c0a0d0771b79ef43d8e56" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;arrays.scalars#numpy.object_&quot;&gt;&lt;code&gt;object_&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;arrays.scalars#numpy.bytes_&quot;&gt;&lt;code&gt;bytes_&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;arrays.scalars#numpy.str_&quot;&gt;&lt;code&gt;str_&lt;/code&gt;&lt;/a&gt;, and use the free functions in the &lt;a href=&quot;routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">该&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;存在与Numarray向后兼容类，所以不推荐在新的发展。从numpy的1.4开始，如果字符串中的一个需要数组，则建议使用数组&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;arrays.scalars#numpy.object_&quot;&gt; &lt;code&gt;object_&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;arrays.scalars#numpy.bytes_&quot;&gt; &lt;code&gt;bytes_&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;arrays.scalars#numpy.str_&quot;&gt; &lt;code&gt;str_&lt;/code&gt; &lt;/a&gt;，以及在使用免费的功能&lt;a href=&quot;routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;快速矢量字符串操作模块。</target>
        </trans-unit>
        <trans-unit id="149f4058a1754093961b02f9ea6b9d5dd9c10925" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">该&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;存在与Numarray向后兼容类，所以不推荐在新的发展。从numpy的1.4开始，如果字符串中的一个需要数组，建议使用数组&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; ， &lt;code&gt;string_&lt;/code&gt; 或 &lt;code&gt;unicode_&lt;/code&gt; ，以及在使用免费的功能&lt;a href=&quot;routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;快速矢量字符串操作模块。</target>
        </trans-unit>
        <trans-unit id="f9537bf435fae2ec4edc2520b8aeb23abd0ca21e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; can be inherited from (in Python or in C) if desired. Therefore, it can form a foundation for many useful classes. Often whether to sub-class the array object or to simply use the core array component as an internal part of a new class is a difficult decision, and can be simply a matter of choice. NumPy has several tools for simplifying how your new object interacts with other array objects, and so the choice may not be significant in the end. One way to simplify the question is by asking yourself if the object you are interested in can be replaced as a single array or does it really require two or more arrays at its core.</source>
          <target state="translated">如果&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;可以从（在Python或C语言中）继承ndarray。因此，它可以为许多有用的类奠定基础。通常是对数组对象进行子类化还是将核心数组组件简单地用作新类的内部部分是一个困难的决定，并且可能只是选择问题。 NumPy有几个工具可以简化新对象与其他数组对象的交互方式，因此最终选择可能并不重要。简化问题的一种方法是问自己是否可以将感兴趣的对象替换为单个数组，或者它的核心确实需要两个或多个数组。</target>
        </trans-unit>
        <trans-unit id="c0cd171dc2a149543f352698d4bc596e7f8afac8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; will try to provide chunks that are as large as possible to the inner loop. By forcing &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; order, we get different external loop sizes. This mode is enabled by specifying an iterator flag.</source>
          <target state="translated">该&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;将尝试提供尽可能大的内循环块。通过强制执行&amp;ldquo; C&amp;rdquo;和&amp;ldquo; F&amp;rdquo;顺序，我们获得了不同的外部循环大小。通过指定迭代器标志启用此模式。</target>
        </trans-unit>
        <trans-unit id="60bea32ad7ce3442c75308b468830ac8ceb23fe9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; is the user-facing object that is nearly identical to &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. The canonical method to initialize a generator passes a &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; bit generator as the sole argument.</source>
          <target state="translated">该&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;是面向用户的对象，它是几乎相同的&lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;。初始化生成器的规范方法将&lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;位生成器作为唯一参数。</target>
        </trans-unit>
        <trans-unit id="f0287b2a9be936e86bf33e5d1e69557ad4042b14" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; is the user-facing object that is nearly identical to &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. The canonical method to initialize a generator passes a &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; bit generator as the sole argument.</source>
          <target state="translated">该&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;是面向用户的对象，它是几乎相同的&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;。初始化生成器的规范方法将&lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;位生成器作为唯一参数。</target>
        </trans-unit>
        <trans-unit id="3f1db6cd813b8bcecf8e6a0fb5885a478eae7000" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; is the user-facing object that is nearly identical to the legacy &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. It accepts a bit generator instance as an argument. The default is currently &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; but this may change in future versions. As a convenience NumPy provides the &lt;a href=&quot;generator#numpy.random.default_rng&quot;&gt;&lt;code&gt;default_rng&lt;/code&gt;&lt;/a&gt; function to hide these details:</source>
          <target state="translated">该&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;是面向用户的对象，它是几乎相同于传统&lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;。它接受一个位生成器实例作为参数。当前默认值为&lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; ,&lt;/a&gt;但是在将来的版本中可能会更改。为了方便起见，NumPy提供了&lt;a href=&quot;generator#numpy.random.default_rng&quot;&gt; &lt;code&gt;default_rng&lt;/code&gt; &lt;/a&gt;函数来隐藏以下详细信息：</target>
        </trans-unit>
        <trans-unit id="a44536d85a990a438123d796af5725162190334f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;random generator&lt;/code&gt;&lt;/a&gt; takes the bit generator-provided stream and transforms them into more useful distributions, e.g., simulated normal random values. This structure allows alternative bit generators to be used with little code duplication.</source>
          <target state="translated">所述&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;random generator&lt;/code&gt; &lt;/a&gt;取位发生器提供的流，并将它们转换成更加有用的分布，例如，模拟正常的随机值。这种结构允许使用很少的代码重复就可以使用替代位生成器。</target>
        </trans-unit>
        <trans-unit id="65fbb3e3590895ec54d650742d5a8544c871fca6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tom.preston-werner.com/2009/05/19/the-git-parable.html&quot;&gt;git parable&lt;/a&gt; is an easy read explaining the concepts behind git.</source>
          <target state="translated">该&lt;a href=&quot;http://tom.preston-werner.com/2009/05/19/the-git-parable.html&quot;&gt;git的比喻&lt;/a&gt;是很容易看懂解释背后的git的概念。</target>
        </trans-unit>
        <trans-unit id="f7f755efceb36d8200d20dc31c04e76cd3c9faf2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; type checking and conversion system is a complicated combination of C macros, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; macros, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemaps and &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; fragments. Fragments are a way to conditionally insert code into your wrapper file if it is needed, and not insert it if not needed. If multiple typemaps require the same fragment, the fragment only gets inserted into your wrapper code once.</source>
          <target state="translated">所述&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;类型检查和转换系统是C宏的复杂组合&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;宏&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemaps和&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;片段。片段是一种在需要时有条件地将代码插入包装文件的方法，而在不需要时则不插入代码。如果多个类型映射需要相同的片段，则该片段仅被插入到您的包装器代码中一次。</target>
        </trans-unit>
        <trans-unit id="03230fc37f6936da8ac6bdd751efc6bea8b56636" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://book.git-scm.com/&quot;&gt;git community book&lt;/a&gt;</source>
          <target state="translated">该&lt;a href=&quot;https://book.git-scm.com/&quot;&gt;混帐社区书&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5936a1cdd9fb41f86db8cb5d458a0fab18964b44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt; function can be used as a shorthand for &lt;code&gt;np.absolute&lt;/code&gt; on ndarrays.</source>
          <target state="translated">所述&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#abs&quot;&gt; &lt;code&gt;abs&lt;/code&gt; &lt;/a&gt;函数可以用作速记 &lt;code&gt;np.absolute&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="2a0a2b61ac5cec04459e6745c23a016af8875dce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#bltin-boolean-values&quot;&gt;boolean objects&lt;/a&gt; in Python are &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;, as opposed to MATLAB logical types of &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Python中的&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#bltin-boolean-values&quot;&gt;布尔对象&lt;/a&gt;为 &lt;code&gt;True&lt;/code&gt; 和 &lt;code&gt;False&lt;/code&gt; ，与MATLAB逻辑类型 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;0&lt;/code&gt; 相反。</target>
        </trans-unit>
        <trans-unit id="81e8045e59daf616aee34810d48dbb7db178f9f3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python tutorial&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python的教程&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e3ce3d1a866c8fe3ec8d4e7bfc02ebc4b98d4d1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://git-scm.com/book/&quot;&gt;pro git book&lt;/a&gt; is a good in-depth book on git.</source>
          <target state="translated">该&lt;a href=&quot;https://git-scm.com/book/&quot;&gt;亲混帐本书&lt;/a&gt;是一个很好的深入书饭桶。</target>
        </trans-unit>
        <trans-unit id="c5b683753cdf3b551962126ba95310173bb4c1cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/gittutorial.html&quot;&gt;git tutorial&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/gittutorial.html&quot;&gt;git的教程&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bccf408a44196396f7493f86e249b28e7b329b3e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/user-manual.html&quot;&gt;git user manual&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/user-manual.html&quot;&gt;git的用户手册。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="249ba57d44afc37bc099ea38dc52d2396ce8f064" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; parameter defines the underlying data type.</source>
          <target state="translated">的&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;参数定义的底层数据的类型。</target>
        </trans-unit>
        <trans-unit id="1a20426fc7bb4d929b1ae303283b379020fbc254" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;numpy.polynomial.polynomial.polynomial.fit#numpy.polynomial.polynomial.Polynomial.fit&quot;&gt;&lt;code&gt;Polynomial.fit&lt;/code&gt;&lt;/a&gt; class method is recommended for new code as it is more stable numerically. See the documentation of the method for more information.</source>
          <target state="translated">对于新代码，建议使用&lt;a href=&quot;numpy.polynomial.polynomial.polynomial.fit#numpy.polynomial.polynomial.Polynomial.fit&quot;&gt; &lt;code&gt;Polynomial.fit&lt;/code&gt; &lt;/a&gt;类方法，因为它在数值上更稳定。有关更多信息，请参见该方法的文档。</target>
        </trans-unit>
        <trans-unit id="2106750b1623894aaf03937b68ff34531437daf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.not_equal&lt;/code&gt; on ndarrays.</source>
          <target state="translated">该 &lt;code&gt;!=&lt;/code&gt; 运算符可以用作速记 &lt;code&gt;np.not_equal&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="17ec1581f01c72c941c4dc77fd68463096a8bba3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.remainder&lt;/code&gt; on ndarrays.</source>
          <target state="translated">的 &lt;code&gt;%&lt;/code&gt; 运算符可以用作速记 &lt;code&gt;np.remainder&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="fedbb2e901febe4e3a84316b4d8ddf825237dddb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.bitwise_and&lt;/code&gt; on ndarrays.</source>
          <target state="translated">该 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符可以用作速记 &lt;code&gt;np.bitwise_and&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="3618bbea51263c31902b2474f8c1ec0676a4715a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.logical_and&lt;/code&gt; on boolean ndarrays.</source>
          <target state="translated">该 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符可以用作速记 &lt;code&gt;np.logical_and&lt;/code&gt; 上布尔ndarrays。</target>
        </trans-unit>
        <trans-unit id="30fd69974271e0304c5c6131b9dcfd6fed219f24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.right_shift&lt;/code&gt; on ndarrays.</source>
          <target state="translated">该 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 操作符可以用来作为一个速记 &lt;code&gt;np.right_shift&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="3ffa04e0143b8eff0d77a2fbb55cf86a562838af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.greater&lt;/code&gt; on ndarrays.</source>
          <target state="translated">所述 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符可以用作速记 &lt;code&gt;np.greater&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="ba583585bd7f53f4136770b0b1a134a6605b81d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;=&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.greater_equal&lt;/code&gt; on ndarrays.</source>
          <target state="translated">所述 &lt;code&gt;&amp;gt;=&lt;/code&gt; 操作符可以用作速记 &lt;code&gt;np.greater_equal&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="f87484d0d314be662c174caa809586486bdddc0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.left_shift&lt;/code&gt; on ndarrays.</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 运算符可以用作速记 &lt;code&gt;np.left_shift&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="3210c2d9abaca33a8760be87735591310e75c5cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; operators always return &lt;code&gt;False&lt;/code&gt; when comparing void structured arrays, and arithmetic and bitwise operations are not supported.</source>
          <target state="translated">该 &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符总是返回 &lt;code&gt;False&lt;/code&gt; 比较空洞结构阵列时，与算术和位操作不被支持。</target>
        </trans-unit>
        <trans-unit id="03f43c01c8d4047248089bbb2b583edb9535d173" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.less&lt;/code&gt; on ndarrays.</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符可以用作速记 &lt;code&gt;np.less&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="f2e166673f9235ba15062d40c69beb65946de696" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;=&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.less_equal&lt;/code&gt; on ndarrays.</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;=&lt;/code&gt; 操作符可以用作速记 &lt;code&gt;np.less_equal&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="7efea03dca2b9d161f9ef2bba68b5604f07ac3fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;argument/variable attribute statement&amp;gt;&lt;/code&gt; is &lt;code&gt;&amp;lt;argument/variable type declaration&amp;gt;&lt;/code&gt; without &lt;code&gt;&amp;lt;typespec&amp;gt;&lt;/code&gt;. In addition, in an attribute statement one cannot use other attributes, also &lt;code&gt;&amp;lt;entitydecl&amp;gt;&lt;/code&gt; can be only a list of names.</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;argument/variable attribute statement&amp;gt;&lt;/code&gt; 是 &lt;code&gt;&amp;lt;argument/variable type declaration&amp;gt;&lt;/code&gt; 不 &lt;code&gt;&amp;lt;typespec&amp;gt;&lt;/code&gt; 。另外，在一个属性语句中，一个人不能使用其他属性， &lt;code&gt;&amp;lt;entitydecl&amp;gt;&lt;/code&gt; 也只能是一个名称列表。</target>
        </trans-unit>
        <trans-unit id="7fa4578e6de9d14302f059bb642ff99cac46413e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;other statement&amp;gt;&lt;/code&gt; part refers to any other Fortran language constructs that are not described above. F2PY ignores most of them except</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;other statement&amp;gt;&lt;/code&gt; 部分指的是上面没有描述的任何其它的Fortran语言构造。F2PY会忽略其中的大多数，除了</target>
        </trans-unit>
        <trans-unit id="03b1c818206b030797e65b1fc6d22265a88666ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.power&lt;/code&gt; on ndarrays.</source>
          <target state="translated">该 &lt;code&gt;**&lt;/code&gt; 运算符可以用作速记 &lt;code&gt;np.power&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="db80fa3dd1381ab36565d5142bc02d5226e4a0a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.multiply&lt;/code&gt; on ndarrays.</source>
          <target state="translated">在 &lt;code&gt;*&lt;/code&gt; 运算符可以作为一个速记 &lt;code&gt;np.multiply&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="4eef4b12a58a37d37f227dee3b5581f18cebb5c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.add&lt;/code&gt; on ndarrays.</source>
          <target state="translated">的 &lt;code&gt;+&lt;/code&gt; 运算符可以用作速记 &lt;code&gt;np.add&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="955ea5ea660ef432dc046daf72c13f161af64749" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--cpu-baseline&lt;/code&gt; argument force-enables implied features, e.g. &lt;code&gt;--cpu-baseline&lt;/code&gt;=&amp;rdquo;sse42&amp;rdquo; is equivalent to &lt;code&gt;--cpu-baseline&lt;/code&gt;=&amp;rdquo;sse sse2 sse3 ssse3 sse41 popcnt sse42&amp;rdquo;</source>
          <target state="translated">所述 &lt;code&gt;--cpu-baseline&lt;/code&gt; 参数力使得能够暗示特征，例如 &lt;code&gt;--cpu-baseline&lt;/code&gt; =&amp;rdquo; sse42&amp;rdquo;等同于 &lt;code&gt;--cpu-baseline&lt;/code&gt; =&amp;rdquo; SSE SSE2 SSE3 SSSE3 sse41 POPCNT sse42&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="99fbc9561d840478417c6519c6d2fb97f9a66f14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.subtract&lt;/code&gt; on ndarrays.</source>
          <target state="translated">本 &lt;code&gt;-&lt;/code&gt; 运算符可以用作速记 &lt;code&gt;np.subtract&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="03addd0e1d3adac1696638d2556f4f3e8a49b2fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-s&lt;/code&gt; flag makes a PGP (usually GPG) signed tag. Please do sign the release tags.</source>
          <target state="translated">该 &lt;code&gt;-s&lt;/code&gt; 标志使得PGP（通常GPG）签名的标签。请对发布标签进行签名。</target>
        </trans-unit>
        <trans-unit id="a1f02257b982558ed0038cd836405c4aaec01705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-v&lt;/code&gt; flag gives verbose feedback, &lt;code&gt;-s&lt;/code&gt; causes the script to sign the wheels with your GPG key before upload. Don&amp;rsquo;t forget to upload the wheels before the source tarball, so there is no period for which people switch from an expected binary install to a source install from PyPI.</source>
          <target state="translated">该 &lt;code&gt;-v&lt;/code&gt; 标志给出详细的反馈， &lt;code&gt;-s&lt;/code&gt; 使脚本签订上传前您的GPG密钥的车轮。别忘了在源代码压缩包之前上载这些轮子，因此没有时间让人们从预期的二进制安装切换到从PyPI进行源安装。</target>
        </trans-unit>
        <trans-unit id="1ea1937064d555fd6f04fc2b57ae9e905ce9bf17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npy&lt;/code&gt; format is the standard binary file format in NumPy for persisting a &lt;em&gt;single&lt;/em&gt; arbitrary NumPy array on disk. The format stores all of the shape and dtype information necessary to reconstruct the array correctly even on another machine with a different architecture. The format is designed to be as simple as possible while achieving its limited goals.</source>
          <target state="translated">所述 &lt;code&gt;.npy&lt;/code&gt; 格式是在NumPy的用于持久化一个标准二进制文件格式&lt;em&gt;单&lt;/em&gt;上磁盘任意NumPy的阵列。该格式存储正确地重建阵列所需的所有形状和dtype信息，即使在具有不同体系结构的另一台机器上也是如此。该格式旨在在达到其有限目标的同时尽可能地简单。</target>
        </trans-unit>
        <trans-unit id="2c04852673cf174afe38ae3c6a6dffb2c948ac9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npy&lt;/code&gt; format, including motivation for creating it and a comparison of alternatives, is described in the &lt;a href=&quot;https://numpy.org/neps/nep-0001-npy-format.html&quot;&gt;&amp;ldquo;npy-format&amp;rdquo; NEP&lt;/a&gt;, however details have evolved with time and this document is more current.</source>
          <target state="translated">该 &lt;code&gt;.npy&lt;/code&gt; 格式，包括动机，创造它和替代的比较，在描述&lt;a href=&quot;https://numpy.org/neps/nep-0001-npy-format.html&quot;&gt;&amp;ldquo;NPY格式&amp;rdquo; NEP&lt;/a&gt;，但细节已经演变随着时间的推移而这个文件是更大的电流。</target>
        </trans-unit>
        <trans-unit id="d25fde9120bc920bdf839700f32d6b700adf8720" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npy&lt;/code&gt; format, including motivation for creating it and a comparison of alternatives, is described in the &lt;a href=&quot;https://www.numpy.org/neps/nep-0001-npy-format.html&quot;&gt;&amp;ldquo;npy-format&amp;rdquo; NEP&lt;/a&gt;, however details have evolved with time and this document is more current.</source>
          <target state="translated">该 &lt;code&gt;.npy&lt;/code&gt; 格式，包括动机，创造它和替代的比较，在描述&lt;a href=&quot;https://www.numpy.org/neps/nep-0001-npy-format.html&quot;&gt;&amp;ldquo;NPY格式&amp;rdquo; NEP&lt;/a&gt;，但细节已经演变随着时间的推移而这个文件是更大的电流。</target>
        </trans-unit>
        <trans-unit id="22e53f126c53ee44cfae93fe323456796e3a7525" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; file format is a zipped archive of files named after the variables they contain. The archive is compressed with &lt;code&gt;zipfile.ZIP_DEFLATED&lt;/code&gt; and each file in the archive contains one variable in &lt;code&gt;.npy&lt;/code&gt; format. For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;.npz&lt;/code&gt; 文件格式是它们所包含的变量命名的文件的压缩文档。压缩文件使用 &lt;code&gt;zipfile.ZIP_DEFLATED&lt;/code&gt; 压缩，并且压缩文件中的每个文件都包含一个 &lt;code&gt;.npy&lt;/code&gt; 格式的变量。有关 &lt;code&gt;.npy&lt;/code&gt; 格式的说明，请参见&lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b51e4d01309ff5a759f392af08bb39d1e99043e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; file format is a zipped archive of files named after the variables they contain. The archive is not compressed and each file in the archive contains one variable in &lt;code&gt;.npy&lt;/code&gt; format. For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;.npz&lt;/code&gt; 文件格式是它们所包含的变量命名的文件的压缩文档。档案未压缩，档案中的每个文件都包含一个 &lt;code&gt;.npy&lt;/code&gt; 格式的变量。有关 &lt;code&gt;.npy&lt;/code&gt; 格式的说明，请参见&lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5c00dd2aa73f26e18024a200e3875179deacef9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; format is the standard format for persisting &lt;em&gt;multiple&lt;/em&gt; NumPy arrays on disk. A &lt;code&gt;.npz&lt;/code&gt; file is a zip file containing multiple &lt;code&gt;.npy&lt;/code&gt; files, one for each array.</source>
          <target state="translated">所述 &lt;code&gt;.npz&lt;/code&gt; 格式是用于持久化的标准格式&lt;em&gt;的多个&lt;/em&gt;磁盘上NumPy的阵列。甲 &lt;code&gt;.npz&lt;/code&gt; 文件是包含多个压缩文件 &lt;code&gt;.npy&lt;/code&gt; 文件，一个用于每个阵列。</target>
        </trans-unit>
        <trans-unit id="49926d6e6d5a1cf1d353c4c16bd799098aac6cff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.wav&lt;/code&gt; file header as a NumPy structured dtype:</source>
          <target state="translated">所述 &lt;code&gt;.wav&lt;/code&gt; 文件头作为NumPy的结构D型：</target>
        </trans-unit>
        <trans-unit id="101d581073e2abaa90459f2609e076c53bbb6672" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.wav&lt;/code&gt; file header is a 44-byte block preceding &lt;code&gt;data_size&lt;/code&gt; bytes of the actual sound data:</source>
          <target state="translated">所述 &lt;code&gt;.wav&lt;/code&gt; 文件头是前面的44字节的块 &lt;code&gt;data_size&lt;/code&gt; 实际的声音数据的字节数：</target>
        </trans-unit>
        <trans-unit id="b48c3ed20fe9905219c0e18e9a68879ea305c96f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;//&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.floor_divide&lt;/code&gt; on ndarrays.</source>
          <target state="translated">该 &lt;code&gt;//&lt;/code&gt; 运算符可以用作速记 &lt;code&gt;np.floor_divide&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="8d0d9c3e4a778f5248a1356d5526d29630bde5db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.true_divide&lt;/code&gt; on ndarrays.</source>
          <target state="translated">的 &lt;code&gt;/&lt;/code&gt; 操作员可以用作速记 &lt;code&gt;np.true_divide&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="c632b7dc98e3f058a1b177bc4932a231dc8f4b56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.equal&lt;/code&gt; on ndarrays.</source>
          <target state="translated">在 &lt;code&gt;==&lt;/code&gt; 操作符可以用来作为一个速记 &lt;code&gt;np.equal&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="d940227ec40cbafe833315ddae39bbf8b8dfa835" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.matmul&lt;/code&gt; on ndarrays.</source>
          <target state="translated">该 &lt;code&gt;@&lt;/code&gt; 运算符可以用作速记 &lt;code&gt;np.matmul&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="19658579206ac4f8753c064c0302ad76f2f72a46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ALIGNED&lt;/code&gt; flag of an ndarray, computed in &lt;code&gt;IsAligned&lt;/code&gt; and checked by &lt;code&gt;PyArray_ISALIGNED&lt;/code&gt;. This is computed from &lt;code&gt;dtype.alignment&lt;/code&gt;. It is set to &lt;code&gt;True&lt;/code&gt; if every item in the array is at a memory location consistent with &lt;code&gt;dtype.alignment&lt;/code&gt;, which is the case if the data ptr and all strides of the array are multiples of that alignment.</source>
          <target state="translated">所述 &lt;code&gt;ALIGNED&lt;/code&gt; 一个ndarray的标志，计算在 &lt;code&gt;IsAligned&lt;/code&gt; 和通过检查 &lt;code&gt;PyArray_ISALIGNED&lt;/code&gt; 。这是从 &lt;code&gt;dtype.alignment&lt;/code&gt; 计算的。如果数组中的每个项目都位于与 &lt;code&gt;dtype.alignment&lt;/code&gt; 一致的内存位置，则将其设置为 &lt;code&gt;True&lt;/code&gt; ,如果数据ptr和数组的所有跨度是该对齐的倍数，则为true。</target>
        </trans-unit>
        <trans-unit id="85388f353d8827d53025cb4498ec7c4f7175db9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BitGenerator&lt;/code&gt; has a limited set of responsibilities. It manages state and provides functions to produce random doubles and random unsigned 32- and 64-bit values.</source>
          <target state="translated">该 &lt;code&gt;BitGenerator&lt;/code&gt; 有一组有限的责任。它管理状态并提供产生随机双精度数和随机无符号32位和64位值的功能。</target>
        </trans-unit>
        <trans-unit id="29642d4a46e1b1f330f5d899a27d8931b3675855" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Configuration&lt;/code&gt; constructor has a fourth optional argument, &lt;code&gt;package_path&lt;/code&gt;, that can be used when package files are located in a different location than the directory of the &lt;code&gt;setup.py&lt;/code&gt; file.</source>
          <target state="translated">该 &lt;code&gt;Configuration&lt;/code&gt; 构造有第四个可选参数， &lt;code&gt;package_path&lt;/code&gt; ，当包文件位于不同的位置比所在的目录可以使用 &lt;code&gt;setup.py&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="831e4b75031bb8f9a8d29e89a9890ddda53ce469" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LibraryInfo&lt;/code&gt; instance containing the build information.</source>
          <target state="translated">包含构建信息的 &lt;code&gt;LibraryInfo&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="d942d62411c592ee85272583cee21a0d612eb9cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MT19937&lt;/code&gt; state vector consists of a 624-element array of 32-bit unsigned integers plus a single integer value between 0 and 624 that indexes the current position within the main array.</source>
          <target state="translated">所述 &lt;code&gt;MT19937&lt;/code&gt; 状态向量由32位无符号整数一个624个元素的数组加一个整数值的0和624的索引主阵列内的当前位置。</target>
        </trans-unit>
        <trans-unit id="a95fd45cabac9b94aa97772f024779835dc306b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Makefile&lt;/code&gt; calls &lt;code&gt;swig&lt;/code&gt; to generate &lt;code&gt;Vector.py&lt;/code&gt; and &lt;code&gt;Vector_wrap.cxx&lt;/code&gt;, and also executes the &lt;code&gt;setup.py&lt;/code&gt; script that compiles &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; and links together the extension module &lt;code&gt;_Vector.so&lt;/code&gt; or &lt;code&gt;_Vector.dylib&lt;/code&gt;, depending on the platform. This extension module and the proxy file &lt;code&gt;Vector.py&lt;/code&gt; are both placed in a subdirectory under the &lt;code&gt;build&lt;/code&gt; directory.</source>
          <target state="translated">在 &lt;code&gt;Makefile&lt;/code&gt; 文件调用 &lt;code&gt;swig&lt;/code&gt; 生成 &lt;code&gt;Vector.py&lt;/code&gt; 和 &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; ，并执行 &lt;code&gt;setup.py&lt;/code&gt; ，编译脚本 &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; 和链接在一起的扩展模块 &lt;code&gt;_Vector.so&lt;/code&gt; 或 &lt;code&gt;_Vector.dylib&lt;/code&gt; ，根据不同的平台上。该扩展模块和代理文件 &lt;code&gt;Vector.py&lt;/code&gt; 都位于 &lt;code&gt;build&lt;/code&gt; 目录下的子目录中。</target>
        </trans-unit>
        <trans-unit id="a509290375510505b589158f3b8f2b07b506f6b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MaskedArray&lt;/code&gt; class</source>
          <target state="translated">该 &lt;code&gt;MaskedArray&lt;/code&gt; 类</target>
        </trans-unit>
        <trans-unit id="b55e755e6d26d2135c464a8b79f8ff9c154dcada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; constants are defined so that sizeof information is available to the pre-processor.</source>
          <target state="translated">所述 &lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; 常数定义为使得的sizeof信息是提供给预处理器。</target>
        </trans-unit>
        <trans-unit id="d0911aba3c1681f9c5a1ccf39d3f2fd5866ac6b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NpzFile&lt;/code&gt; returned by &lt;code&gt;np.savez&lt;/code&gt; is now a &lt;code&gt;collections.abc.Mapping&lt;/code&gt;</source>
          <target state="translated">该 &lt;code&gt;NpzFile&lt;/code&gt; 通过返回 &lt;code&gt;np.savez&lt;/code&gt; 现在是一个 &lt;code&gt;collections.abc.Mapping&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d918fc830e6f124f45ecb19bab96030d1a7583a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PCG64&lt;/code&gt; state vector consists of 2 unsigned 128-bit values, which are represented externally as Python ints. One is the state of the PRNG, which is advanced by a linear congruential generator (LCG). The second is a fixed odd increment used in the LCG.</source>
          <target state="translated">所述 &lt;code&gt;PCG64&lt;/code&gt; 状态矢量由2无符号的128位值，其在外部表示为整数的Python的。一种是PRNG的状态，它由线性同余生成器（LCG）进行高级处理。第二个是LCG中使用的固定奇数增量。</target>
        </trans-unit>
        <trans-unit id="c1a90ac63bb863a062bb153b73df1e64c4857aff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Philox&lt;/code&gt; state vector consists of a 256-bit value encoded as a 4-element uint64 array and a 128-bit value encoded as a 2-element uint64 array. The former is a counter which is incremented by 1 for every 4 64-bit randoms produced. The second is a key which determined the sequence produced. Using different keys produces independent sequences.</source>
          <target state="translated">所述 &lt;code&gt;Philox&lt;/code&gt; 状态向量由编码为4元件阵列UINT64一个256位的值的和一个128位的值编码为2元件UINT64阵列。前者是一个计数器，每产生4个64位随机数，计数器就会增加1。第二个是确定生成顺序的键。使用不同的键会产生独立的序列。</target>
        </trans-unit>
        <trans-unit id="77835deaa4168f146eec7ddf2548bcb524ae4254" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PyArray_DescrCheck&lt;/code&gt; macro is modified</source>
          <target state="translated">所述 &lt;code&gt;PyArray_DescrCheck&lt;/code&gt; 宏被修改</target>
        </trans-unit>
        <trans-unit id="4d1f94165781d8145f1fd80c467f6bd0f760f0b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SFC64&lt;/code&gt; state vector consists of 4 unsigned 64-bit values. The last is a 64-bit counter that increments by 1 each iteration.</source>
          <target state="translated">所述 &lt;code&gt;SFC64&lt;/code&gt; 状态向量由4无符号的64位值。最后一个是64位计数器，每次迭代递增1。</target>
        </trans-unit>
        <trans-unit id="1c61cd8903722b01c74a952853626a7fa047bc24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;See the sights&lt;/code&gt; how-to should link to a set of narrower how-tos:</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;See the sights&lt;/code&gt; 方法&amp;rdquo;应该链接到一组较窄的方法：</target>
        </trans-unit>
        <trans-unit id="f2597c1ce05865ef5dc6c1fd54908d9266820030" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;^&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.bitwise_xor&lt;/code&gt; on ndarrays.</source>
          <target state="translated">该 &lt;code&gt;^&lt;/code&gt; 运算符可以用作速记 &lt;code&gt;np.bitwise_xor&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="a79e711795f6e28c85d83994efa93c2930d50249" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__array_ufunc__&lt;/code&gt; receives:</source>
          <target state="translated">该 &lt;code&gt;__array_ufunc__&lt;/code&gt; 接收：</target>
        </trans-unit>
        <trans-unit id="7be3375866469167b9378a498844a5222b829ab9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__complex__&lt;/code&gt; method has been implemented for the ndarrays</source>
          <target state="translated">该 &lt;code&gt;__complex__&lt;/code&gt; 方法已实施的ndarrays</target>
        </trans-unit>
        <trans-unit id="395b8858a352467f67b6a09c4a5fc424e26cfad2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__init__.py&lt;/code&gt; file</source>
          <target state="translated">该 &lt;code&gt;__init__.py&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="55e0b71eae2cfd6e566258a88d10c513a1a5a113" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; keyword of the dtype constructor, which only affects structured arrays. If the structure&amp;rsquo;s field offsets are not manually provided numpy determines offsets automatically. In that case, &lt;code&gt;align=True&lt;/code&gt; pads the structure so that each field is &amp;ldquo;true&amp;rdquo; aligned in memory and sets &lt;code&gt;dtype.alignment&lt;/code&gt; to be the largest of the field &amp;ldquo;true&amp;rdquo; alignments. This is like what C-structs usually do. Otherwise if offsets or itemsize were manually provided &lt;code&gt;align=True&lt;/code&gt; simply checks that all the fields are &amp;ldquo;true&amp;rdquo; aligned and that the total itemsize is a multiple of the largest field alignment. In either case &lt;code&gt;dtype.isalignedstruct&lt;/code&gt; is also set to True.</source>
          <target state="translated">dtype构造函数的 &lt;code&gt;align&lt;/code&gt; 关键字，仅影响结构化数组。如果未手动提供结构的字段偏移量，则numpy会自动确定偏移量。在这种情况下， &lt;code&gt;align=True&lt;/code&gt; &lt;code&gt;dtype.alignment&lt;/code&gt; 结构，以便每个字段在内存中都是&amp;ldquo; true&amp;rdquo;对齐的，并将dtype.alignment设置为字段&amp;ldquo; true&amp;rdquo;对齐中的最大对齐。这就像C结构通常所做的那样。否则，如果手动提供了偏移量或项目大小，则 &lt;code&gt;align=True&lt;/code&gt; 仅检查所有字段是否为&amp;ldquo; true&amp;rdquo;对齐，并且总项目大小为最大字段对齐的倍数。无论哪种情况， &lt;code&gt;dtype.isalignedstruct&lt;/code&gt; 也都设置为True。</target>
        </trans-unit>
        <trans-unit id="ed305f750328762db1dc6ead8c6be67eaf77ffcb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;array&lt;/code&gt; constructor &lt;strong&gt;takes (nested) Python sequences as initializers&lt;/strong&gt;. As in, &lt;code&gt;array([[1,2,3],[4,5,6]])&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;array&lt;/code&gt; 构造&lt;strong&gt;为（嵌套的）的Python序列初始化&lt;/strong&gt;。就像在 &lt;code&gt;array([[1,2,3],[4,5,6]])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7af29f13d56d1534071fc5be1d8e6902e6aa373" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;array&lt;/code&gt; is thus much more advisable to use. Indeed, we intend to deprecate &lt;code&gt;matrix&lt;/code&gt; eventually.</source>
          <target state="translated">因此，更建议使用该 &lt;code&gt;array&lt;/code&gt; 。实际上，我们打算最终弃用 &lt;code&gt;matrix&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd27c9fa716237737a1b850fd84a88e9e84db97b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt;-clause of the &lt;code&gt;with&lt;/code&gt;-statement gives the current print options:</source>
          <target state="translated">该 &lt;code&gt;as&lt;/code&gt; 的-clause &lt;code&gt;with&lt;/code&gt; 语句来给出当前打印选项：</target>
        </trans-unit>
        <trans-unit id="2c28e104a97f1a1f15fc38cbcd9f731be438b4c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autostrip&lt;/code&gt; argument</source>
          <target state="translated">该 &lt;code&gt;autostrip&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="ad906fe89b0c268cf5fd9b3376621745175a9a41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; argument to &lt;code&gt;numpy.ma.mask_cols&lt;/code&gt; and &lt;code&gt;numpy.ma.mask_row&lt;/code&gt; is deprecated</source>
          <target state="translated">不推荐使用 &lt;code&gt;numpy.ma.mask_cols&lt;/code&gt; 和 &lt;code&gt;numpy.ma.mask_row&lt;/code&gt; 的 &lt;code&gt;axis&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="caa858c948295450c18bcef4c572e68d7eda67a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; keyword can be used to specify a subset of axes of which the gradient is calculated</source>
          <target state="translated">所述 &lt;code&gt;axis&lt;/code&gt; 关键字可以被用来指定一个被计算的梯度轴的一个子集</target>
        </trans-unit>
        <trans-unit id="c68a2d64e2aeed4fdf4077c45259bb4b7c07822e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; parameter specifies the index of the new axis in the dimensions of the result. For example, if &lt;code&gt;axis=0&lt;/code&gt; it will be the first dimension and if &lt;code&gt;axis=-1&lt;/code&gt; it will be the last dimension.</source>
          <target state="translated">所述 &lt;code&gt;axis&lt;/code&gt; 参数指定新轴的在结果的尺寸的索引。例如，如果 &lt;code&gt;axis=0&lt;/code&gt; ，它将是第一个尺寸；如果 &lt;code&gt;axis=-1&lt;/code&gt; ，它将是最后的尺寸。</target>
        </trans-unit>
        <trans-unit id="285d55a28a1a269db45a5f84582658fc7e3a43b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base&lt;/code&gt; attribute is useful in being able to tell whether we have a view or the original array. This in turn can be useful if we need to know whether or not to do some specific cleanup when the subclassed array is deleted. For example, we may only want to do the cleanup if the original array is deleted, but not the views. For an example of how this can work, have a look at the &lt;code&gt;memmap&lt;/code&gt; class in &lt;code&gt;numpy.core&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;base&lt;/code&gt; 的属性是在能够告诉我们是否有一个视图或原始数组是有用的。如果我们需要知道在删除子类数组时是否需要进行一些特定的清理，那么这反过来会很有用。例如，我们可能只想在原始数组被删除但不删除视图的情况下进行清理。有关如何工作的示例，请查看 &lt;code&gt;numpy.core&lt;/code&gt; 中的 &lt;code&gt;memmap&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="7d4cb66724d02c13ff5f50a065c67d6d75a20a6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool_&lt;/code&gt; data type is very similar to the Python &lt;code&gt;BooleanType&lt;/code&gt; but does not inherit from it because Python&amp;rsquo;s &lt;code&gt;BooleanType&lt;/code&gt; does not allow itself to be inherited from, and on the C-level the size of the actual bool data is not the same as a Python Boolean scalar.</source>
          <target state="translated">该 &lt;code&gt;bool_&lt;/code&gt; 数据类型是非常相似的Python &lt;code&gt;BooleanType&lt;/code&gt; 但不继承它，因为Python的 &lt;code&gt;BooleanType&lt;/code&gt; 不允许自己被继承，并在C级的实际布尔数据的大小是不一样的一个Python布尔标量。</target>
        </trans-unit>
        <trans-unit id="1a9ec4df6ec3fb7357baf90864b29d969f59440a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool_&lt;/code&gt; type is not a subclass of the &lt;code&gt;int_&lt;/code&gt; type (the &lt;code&gt;bool_&lt;/code&gt; is not even a number type). This is different than Python&amp;rsquo;s default implementation of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; as a sub-class of int.</source>
          <target state="translated">所述 &lt;code&gt;bool_&lt;/code&gt; 类型不是的一个子类 &lt;code&gt;int_&lt;/code&gt; 类型（ &lt;code&gt;bool_&lt;/code&gt; 甚至不是一个数类型）。这与Python 作为int的子类的&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;的默认实现不同。</target>
        </trans-unit>
        <trans-unit id="3f5c3b6d52d4becfb53cc5a7dd0ae6b04cdb9085" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a prefix or suffix; rather, all combinations of its values are stripped.</source>
          <target state="translated">的 &lt;code&gt;chars&lt;/code&gt; 参数是要除去的字符串指定的字符集。如果省略或为None，则 &lt;code&gt;chars&lt;/code&gt; 参数默认为删除空格。该 &lt;code&gt;chars&lt;/code&gt; 参数不是前缀或后缀; 而是删除其值的所有组合。</target>
        </trans-unit>
        <trans-unit id="44ca716c299a61027880c154634feb6b89178fc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a prefix; rather, all combinations of its values are stripped.</source>
          <target state="translated">的 &lt;code&gt;chars&lt;/code&gt; 参数是要除去的字符串指定的字符集。如果省略或为None，则 &lt;code&gt;chars&lt;/code&gt; 参数默认为删除空格。该 &lt;code&gt;chars&lt;/code&gt; 参数不是前缀; 而是删除其值的所有组合。</target>
        </trans-unit>
        <trans-unit id="3ab81d1fe754db2126af526470043294b9859fdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a suffix; rather, all combinations of its values are stripped.</source>
          <target state="translated">的 &lt;code&gt;chars&lt;/code&gt; 参数是要除去的字符串指定的字符集。如果省略或为None，则 &lt;code&gt;chars&lt;/code&gt; 参数默认为删除空格。该 &lt;code&gt;chars&lt;/code&gt; 参数不是后缀; 而是删除其值的所有组合。</target>
        </trans-unit>
        <trans-unit id="c5f389d1809eca65fc531558b3a6934398b93db5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;code.c&lt;/code&gt; file also contains the function &lt;code&gt;dfilter2d&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;code.c&lt;/code&gt; 文件还包含功能 &lt;code&gt;dfilter2d&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1062b010a751d11306d8dd6990fc1281fafefff6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;comments&lt;/code&gt; argument</source>
          <target state="translated">该 &lt;code&gt;comments&lt;/code&gt; 的说法</target>
        </trans-unit>
        <trans-unit id="49098bbf1639e574a8a45e0dbe1faacda5a0f942" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;context&lt;/code&gt; member of the &lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt;&lt;code&gt;PyCapsule&lt;/code&gt;&lt;/a&gt; (formally the &lt;code&gt;desc&lt;/code&gt; member of the &lt;code&gt;PyCObject&lt;/code&gt;) returned from &lt;code&gt;__array_struct__&lt;/code&gt; was not specified. Usually, it was the object exposing the array (so that a reference to it could be kept and destroyed when the C-object was destroyed). It is now an explicit requirement that this field be used in some way to hold a reference to the owning object.</source>
          <target state="translated">的 &lt;code&gt;context&lt;/code&gt; 中的构件&lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt; &lt;code&gt;PyCapsule&lt;/code&gt; &lt;/a&gt;（正式的 &lt;code&gt;desc&lt;/code&gt; 所述的构件 &lt;code&gt;PyCObject&lt;/code&gt; 从返回） &lt;code&gt;__array_struct__&lt;/code&gt; 未指定。通常，它是暴露数组的对象（以便在销毁C对象时可以保留和销毁对它的引用）。现在明确要求以某种方式使用此字段来保存对拥有对象的引用。</target>
        </trans-unit>
        <trans-unit id="b3f924ee1f48ac861086d833eab7f0e461342200" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;converters&lt;/code&gt; argument</source>
          <target state="translated">该 &lt;code&gt;converters&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="1bf25618f0e89873a8966e075d9cc930c281ddb2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; method makes a complete copy of the array and its data.</source>
          <target state="translated">该 &lt;code&gt;copy&lt;/code&gt; 方法使阵列及其数据的完整副本。</target>
        </trans-unit>
        <trans-unit id="04c7d601eb1b28391adc5c0db2ef77348e27c0e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defaultfmt&lt;/code&gt; argument</source>
          <target state="translated">该 &lt;code&gt;defaultfmt&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="a534898d388f95602366c3e92d612246a0ec8f63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delimiter&lt;/code&gt; argument</source>
          <target state="translated">在 &lt;code&gt;delimiter&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="961750d0f31ee27657eeda3c0b92ff071d0d3872" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doc/swig&lt;/code&gt; directory moved</source>
          <target state="translated">该 &lt;code&gt;doc/swig&lt;/code&gt; 目录移动</target>
        </trans-unit>
        <trans-unit id="c5f33c0fec12debe8698b9f3d00999bb3fb759ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype.alignment&lt;/code&gt; attribute (&lt;code&gt;descr-&amp;gt;alignment&lt;/code&gt; in C). This is meant to reflect the &amp;ldquo;true alignment&amp;rdquo; of the type. It has arch-dependent default values for all datatypes, with the exception of structured types created with &lt;code&gt;align=True&lt;/code&gt; as described below.</source>
          <target state="translated">所述 &lt;code&gt;dtype.alignment&lt;/code&gt; 属性（ &lt;code&gt;descr-&amp;gt;alignment&lt;/code&gt; 在C）。这是为了反映类型的&amp;ldquo;真实对齐&amp;rdquo;。对于所有数据类型，它都有与拱有关的默认值，但使用 &lt;code&gt;align=True&lt;/code&gt; 创建的结构化类型除外，如下所述。</target>
        </trans-unit>
        <trans-unit id="323a6b614fe91ba8419451439d97b4868d61c2a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype.fields&lt;/code&gt; dictionary will contain titles as keys, if any titles are used. This means effectively that a field with a title will be represented twice in the fields dictionary. The tuple values for these fields will also have a third element, the field title. Because of this, and because the &lt;code&gt;names&lt;/code&gt; attribute preserves the field order while the &lt;code&gt;fields&lt;/code&gt; attribute may not, it is recommended to iterate through the fields of a dtype using the &lt;code&gt;names&lt;/code&gt; attribute of the dtype, which will not list titles, as in:</source>
          <target state="translated">该 &lt;code&gt;dtype.fields&lt;/code&gt; 字典将包含标题作为键，如果使用任何头衔。这实际上意味着具有标题的字段将在字段字典中两次表示。这些字段的元组值还将具有第三个元素，即字段标题。因此，并且由于 &lt;code&gt;names&lt;/code&gt; 属性保留字段顺序，而 &lt;code&gt;fields&lt;/code&gt; 属性可能不保留，因此建议使用dtype的 &lt;code&gt;names&lt;/code&gt; 属性遍历dtype的字段，该属性不会列出标题，如下所示：</target>
        </trans-unit>
        <trans-unit id="4e0428300bbf21ef1b533ffa3e86adb5ceddd8dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype&lt;/code&gt; parameter defines the underlying data type.</source>
          <target state="translated">的 &lt;code&gt;dtype&lt;/code&gt; 参数定义的底层数据的类型。</target>
        </trans-unit>
        <trans-unit id="93f7d511e2846b265125fabe4d5030e15709832e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;excluded&lt;/code&gt; argument can be used to prevent vectorizing over certain arguments. This can be useful for array-like arguments of a fixed length such as the coefficients for a polynomial as in &lt;a href=&quot;numpy.polyval#numpy.polyval&quot;&gt;&lt;code&gt;polyval&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在 &lt;code&gt;excluded&lt;/code&gt; 参数可以用来防止向量化对某些参数。这对于固定长度的类似数组的参数很有用，例如在&lt;a href=&quot;numpy.polyval#numpy.polyval&quot;&gt; &lt;code&gt;polyval&lt;/code&gt; 中&lt;/a&gt;的多项式系数：</target>
        </trans-unit>
        <trans-unit id="359c30915e6710377793414f9e99d77e6eeeea63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;f2py -c&lt;/code&gt; option must be applied either to an existing &lt;code&gt;.pyf&lt;/code&gt; file (plus the source/object/library files) or one must specify the &lt;code&gt;-m &amp;lt;modulename&amp;gt;&lt;/code&gt; option (plus the sources/object/library files). Use one of the following options:</source>
          <target state="translated">所述 &lt;code&gt;f2py -c&lt;/code&gt; 选项必须要么应用于现有 &lt;code&gt;.pyf&lt;/code&gt; 文件（加在源极/对象/库文件），或一个必须指定 &lt;code&gt;-m &amp;lt;modulename&amp;gt;&lt;/code&gt; 选项（加上源/对象/库文件）。使用以下选项之一：</target>
        </trans-unit>
        <trans-unit id="2beff53e54fda1bd096a7e81c4708f352287d275" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; attribute of the &lt;code&gt;PyArrayObject&lt;/code&gt; structure contains important information about the memory used by the array (pointed to by the data member) This flag information must be kept accurate or strange results and even segfaults may result.</source>
          <target state="translated">&lt;code&gt;PyArrayObject&lt;/code&gt; 结构的 &lt;code&gt;flags&lt;/code&gt; 属性包含有关数组使用的内存的重要信息（由数据成员指向）。必须保留此标志信息的准确性或奇怪的结果，甚至可能导致段错误。</target>
        </trans-unit>
        <trans-unit id="8cff4dd26e77da7e42ef944b6a6e55860dbd33d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;genfromtxt&lt;/code&gt; function provides two other complementary mechanisms: the &lt;code&gt;missing_values&lt;/code&gt; argument is used to recognize missing data and a second argument, &lt;code&gt;filling_values&lt;/code&gt;, is used to process these missing data.</source>
          <target state="translated">所述 &lt;code&gt;genfromtxt&lt;/code&gt; 功能提供了其它两个互补机制： &lt;code&gt;missing_values&lt;/code&gt; 参数用于识别丢失的数据和第二个参数， &lt;code&gt;filling_values&lt;/code&gt; ，用于处理这些丢失的数据。</target>
        </trans-unit>
        <trans-unit id="8b08d522b6b1cfd800cd6bda4d86b04d644f1baf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int_&lt;/code&gt; type does &lt;strong&gt;not&lt;/strong&gt; inherit from the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; built-in under Python 3, because type &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; is no longer a fixed-width integer type.</source>
          <target state="translated">所述 &lt;code&gt;int_&lt;/code&gt; 类型并&lt;strong&gt;没有&lt;/strong&gt;从继承&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;内置Python 3下，因为型&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;不再是固定宽度的整数类型。</target>
        </trans-unit>
        <trans-unit id="5032550323e57bc7dec27d8af2d8f9df18642750" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;itershape&lt;/code&gt; parameter allows you to force the iterator to have a specific iteration shape. It is an array of length &lt;code&gt;oa_ndim&lt;/code&gt;. When an entry is negative, its value is determined from the operands. This parameter allows automatically allocated outputs to get additional dimensions which don&amp;rsquo;t match up with any dimension of an input.</source>
          <target state="translated">使用 &lt;code&gt;itershape&lt;/code&gt; 参数可以强制迭代器具有特定的迭代形状。它是一个长度为 &lt;code&gt;oa_ndim&lt;/code&gt; 的数组。当条目为负数时，其值由操作数确定。此参数允许自动分配的输出获得与输入的任何尺寸都不匹配的其他尺寸。</target>
        </trans-unit>
        <trans-unit id="d1b139e99319cf8723f8471165f727072e0de12d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;k&lt;/code&gt; different &amp;ldquo;columns&amp;rdquo; to be sorted. The last column (or row if &lt;code&gt;keys&lt;/code&gt; is a 2D array) is the primary sort key.</source>
          <target state="translated">要排序的 &lt;code&gt;k&lt;/code&gt; 个不同的&amp;ldquo;列&amp;rdquo;。最后一列（如果 &lt;code&gt;keys&lt;/code&gt; 是2D数组，则为行）是主排序键。</target>
        </trans-unit>
        <trans-unit id="1a2dff01d273bbb026a37bec4c9c698a3a5dbb3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;like&lt;/code&gt; keyword is an experimental feature pending on acceptance of &lt;a href=&quot;https://numpy.org/neps/nep-0035-array-creation-dispatch-with-array-function.html#nep35&quot;&gt;NEP 35&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;like&lt;/code&gt; 的关键字是关于接受的待决的实验性功能&lt;a href=&quot;https://numpy.org/neps/nep-0035-array-creation-dispatch-with-array-function.html#nep35&quot;&gt;NEP 35&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bf501ea6ca94cccfb99a424407f3991a7fe0b23a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mask&lt;/code&gt; can be initialized with an array of boolean values with the same shape as &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;mask&lt;/code&gt; 可以用布尔值的阵列具有相同的形状进行初始化 &lt;code&gt;data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7a81ce30e9985e9cc6aff4a084478e80352aabd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;matrix&lt;/code&gt; constructor additionally &lt;strong&gt;takes a convenient string initializer&lt;/strong&gt;. As in &lt;code&gt;matrix(&quot;[1&amp;nbsp;2&amp;nbsp;3;&amp;nbsp;4&amp;nbsp;5&amp;nbsp;6]&quot;)&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;matrix&lt;/code&gt; 构造另外&lt;strong&gt;需要方便串初始化&lt;/strong&gt;。如在 &lt;code&gt;matrix(&quot;[1&amp;nbsp;2&amp;nbsp;3;&amp;nbsp;4&amp;nbsp;5&amp;nbsp;6]&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab61433b884d13cbf28918d009f77e172c843e81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt; arrays of indices corresponding to the locations where &lt;code&gt;mask_func(np.ones((n, n)), k)&lt;/code&gt; is True.</source>
          <target state="translated">对应于 &lt;code&gt;mask_func(np.ones((n, n)), k)&lt;/code&gt; 为True 的位置的索引的 &lt;code&gt;n&lt;/code&gt; 个数组。</target>
        </trans-unit>
        <trans-unit id="69bba282bdcb3fd4a040d50fe46e42c40f81a639" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;names&lt;/code&gt; argument</source>
          <target state="translated">该 &lt;code&gt;names&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="68e43d8a15f5f97ea384a5e71f1342015a6bc434" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ndarray&lt;/code&gt; is an object that provide a python array interface to data in memory.</source>
          <target state="translated">所述 &lt;code&gt;ndarray&lt;/code&gt; 是一个对象，在存储器提供一个python阵列接口到数据。</target>
        </trans-unit>
        <trans-unit id="77729f42697ab0235a0349b2968dd91c608b2d96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ndincr&lt;/code&gt; method of &lt;code&gt;ndindex&lt;/code&gt; is deprecated</source>
          <target state="translated">弃用 &lt;code&gt;ndindex&lt;/code&gt; 的 &lt;code&gt;ndincr&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="68dcfe0b1fdf3a267f300958e2039277e48ae02c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new_order&lt;/code&gt; code can be any from the following:</source>
          <target state="translated">该 &lt;code&gt;new_order&lt;/code&gt; 代码可以是任何从以下方面：</target>
        </trans-unit>
        <trans-unit id="8693a0f592844bcf9978c5fbaa78f4621036206e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nonzero&lt;/code&gt; method of the condition array can also be called.</source>
          <target state="translated">也可以调用条件数组的 &lt;code&gt;nonzero&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="119598850fcb719f758c8505ecbfd545e55a9647" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;np.einsum&lt;/code&gt; function will use BLAS when possible and optimize by default</source>
          <target state="translated">该 &lt;code&gt;np.einsum&lt;/code&gt; 功能将使用BLAS如果可能，优化默认</target>
        </trans-unit>
        <trans-unit id="e03ccb4d87ad4f35f1ad3c43da765c8e7da17640" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;np.percentile&lt;/code&gt; &amp;lsquo;midpoint&amp;rsquo; interpolation method fixed for exact indices</source>
          <target state="translated">所述 &lt;code&gt;np.percentile&lt;/code&gt; &amp;ldquo;中点&amp;rdquo;插值方法固定以精确指数</target>
        </trans-unit>
        <trans-unit id="eabf6694e45f9bef7f8445dcaf6ddb978e5e6f05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;npy_3kcompat.h&lt;/code&gt; header changed</source>
          <target state="translated">该 &lt;code&gt;npy_3kcompat.h&lt;/code&gt; 头变</target>
        </trans-unit>
        <trans-unit id="d18c665ad6cff39ded6fc90bc8648963ab9ee138" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; file contains several macros and routines that it uses internally to build its typemaps. However, these functions may be useful elsewhere in your interface file. These macros and routines are implemented as fragments, which are described briefly in the previous section. If you try to use one or more of the following macros or functions, but your compiler complains that it does not recognize the symbol, then you need to force these fragments to appear in your code using:</source>
          <target state="translated">该 &lt;code&gt;numpy.i&lt;/code&gt; 文件包含几个宏和例程，它在内部使用，以建立自己的typemaps。但是，这些功能在界面文件中的其他位置可能很有用。这些宏和例程作为片段实现，在上一节中进行了简要描述。如果尝试使用以下一个或多个宏或函数，但是编译器抱怨它无法识别该符号，则需要使用以下命令强制这些片段出现在代码中：</target>
        </trans-unit>
        <trans-unit id="9f4cb37fdc51e8b1f5c2b248e5fd15fdd94aa9b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; file is currently located in the &lt;code&gt;tools/swig&lt;/code&gt; sub-directory under the &lt;code&gt;numpy&lt;/code&gt; installation directory. Typically, you will want to copy it to the directory where you are developing your wrappers.</source>
          <target state="translated">该 &lt;code&gt;numpy.i&lt;/code&gt; 当前文件位于 &lt;code&gt;tools/swig&lt;/code&gt; 下子目录 &lt;code&gt;numpy&lt;/code&gt; 的安装目录。通常，您需要将其复制到开发包装程序的目录中。</target>
        </trans-unit>
        <trans-unit id="96831ff16133b13c87cfe870992604959917c570" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file also provides additional tools for wrapper developers, including:</source>
          <target state="translated">该 &lt;code&gt;numpy.i&lt;/code&gt; 接口文件还提供了额外的工具，用于包装的开发，其中包括：</target>
        </trans-unit>
        <trans-unit id="d04832f55eba99f2bc4cc0dceb3d718f68b6cac8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file does not support typemaps for output arrays, for several reasons. First, C/C++ return arguments are limited to a single value. This prevents obtaining dimension information in a general way. Second, arrays with hard-coded lengths are not permitted as return arguments. In other words:</source>
          <target state="translated">该 &lt;code&gt;numpy.i&lt;/code&gt; 接口文件不支持typemaps输出数组，有几个原因。首先，C / C ++返回参数限制为单个值。这阻止了以一般方式获得尺寸信息。其次，不允许将具有硬编码长度的数组作为返回参数。换一种说法：</target>
        </trans-unit>
        <trans-unit id="65e8b572ae6dc55c16aea9abc0f0766e897fe055" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file uses the &lt;code&gt;%numpy_typemaps&lt;/code&gt; macro to implement typemaps for the following C data types and &lt;code&gt;int&lt;/code&gt; dimension types:</source>
          <target state="translated">所述 &lt;code&gt;numpy.i&lt;/code&gt; 接口文件使用 &lt;code&gt;%numpy_typemaps&lt;/code&gt; 宏实施typemaps为下面的C数据类型和 &lt;code&gt;int&lt;/code&gt; 尺寸类型：</target>
        </trans-unit>
        <trans-unit id="d99e0e96fa984690444350c5bb3087380beb5586" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.ma&lt;/code&gt; module</source>
          <target state="translated">该 &lt;code&gt;numpy.ma&lt;/code&gt; 模块</target>
        </trans-unit>
        <trans-unit id="1f4db4ab31f145b9bac6edb4b0915cc64c0ea3a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.ndarray&lt;/code&gt; constructor no longer interprets &lt;code&gt;strides=()&lt;/code&gt; as &lt;code&gt;strides=None&lt;/code&gt;</source>
          <target state="translated">所述 &lt;code&gt;numpy.ndarray&lt;/code&gt; 构造不再解释 &lt;code&gt;strides=()&lt;/code&gt; 为 &lt;code&gt;strides=None&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70a302d51ef0fc934fa61a7faa2fee138940dfc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.rec&lt;/code&gt; module provides a number of other convenience functions for creating record arrays, see &lt;a href=&quot;../reference/routines.array-creation#routines-array-creation-rec&quot;&gt;record array creation routines&lt;/a&gt;.</source>
          <target state="translated">所述 &lt;code&gt;numpy.rec&lt;/code&gt; 模块提供了许多用于创建记录阵列其他方便的功能，请参阅&lt;a href=&quot;../reference/routines.array-creation#routines-array-creation-rec&quot;&gt;记录阵列创建例程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65de759e5fe00055883d5521d08146904c48c69b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operator.concat&lt;/code&gt; function now raises TypeError for array arguments</source>
          <target state="translated">现在， &lt;code&gt;operator.concat&lt;/code&gt; 函数会为数组参数引发TypeError。</target>
        </trans-unit>
        <trans-unit id="4c8ade543f0e1c46d97cf061c562c3116b9639d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;order&lt;/code&gt; keyword gives the index ordering both for &lt;em&gt;fetching&lt;/em&gt; the values from &lt;code&gt;a&lt;/code&gt;, and then &lt;em&gt;placing&lt;/em&gt; the values into the output array. For example, let&amp;rsquo;s say you have an array:</source>
          <target state="translated">的 &lt;code&gt;order&lt;/code&gt; 关键字给出的索引用于订购两者&lt;em&gt;取&lt;/em&gt;从值 &lt;code&gt;a&lt;/code&gt; ，然后&lt;em&gt;把&lt;/em&gt;该值代入输出阵列。例如，假设您有一个数组：</target>
        </trans-unit>
        <trans-unit id="b38e6e5718f484c9be916df67070a4920d8e24c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repr&lt;/code&gt; of &lt;code&gt;np.polynomial&lt;/code&gt; classes is more explicit</source>
          <target state="translated">在 &lt;code&gt;repr&lt;/code&gt; 的 &lt;code&gt;np.polynomial&lt;/code&gt; 类是更明确</target>
        </trans-unit>
        <trans-unit id="7075c0200f067381f77164e531b354de40ba5d19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;savetxt()&lt;/code&gt; and &lt;code&gt;loadtxt()&lt;/code&gt; functions accept additional optional parameters such as header, footer, and delimiter. While text files can be easier for sharing, .npy and .npz files are smaller and faster to read. If you need more sophisticated handling of your text file (for example, if you need to work with lines that contain missing values), you will want to use the &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">所述 &lt;code&gt;savetxt()&lt;/code&gt; 和 &lt;code&gt;loadtxt()&lt;/code&gt; 函数接受附加的可选参数，如页眉，页脚，和分隔符。虽然文本文件更易于共享，但.npy和.npz文件更小且读取速度更快。如果需要对文本文件进行更复杂的处理（例如，如果需要处理包含缺少值的行），则需要使用&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="022ed8cd0b6cf9d8c83ca5b8b482f20886ea6324" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;series&lt;/code&gt; is expected to be an instance of some polynomial series of one of the types supported by by the numpy.polynomial module, but could be some other class that supports the convert method.</source>
          <target state="translated">该 &lt;code&gt;series&lt;/code&gt; 应为numpy.polynomial模块支持的一种类型的多项式系列的实例，但也可以是其他支持convert方法的类。</target>
        </trans-unit>
        <trans-unit id="f4910f2b9024b32efada1e65d4c1134f65374f1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setup.py&lt;/code&gt; file</source>
          <target state="translated">该 &lt;code&gt;setup.py&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="0948550106d7d72b97910c4e4918bcddbe3d6d6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;signature&lt;/code&gt; argument allows for vectorizing functions that act on non-scalar arrays of fixed length. For example, you can use it for a vectorized calculation of Pearson correlation coefficient and its p-value:</source>
          <target state="translated">的 &lt;code&gt;signature&lt;/code&gt; 参数允许向量化上的固定长度的非标量阵列作用的功能。例如，可以将其用于皮尔逊相关系数及其p值的矢量化计算：</target>
        </trans-unit>
        <trans-unit id="692ace7013c4ccf7dfcd73ad9c88abfaeb03c00c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip_header&lt;/code&gt; and &lt;code&gt;skip_footer&lt;/code&gt; arguments</source>
          <target state="translated">该 &lt;code&gt;skip_header&lt;/code&gt; 和 &lt;code&gt;skip_footer&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="19cc10b9b9bd6104c6aeb8b9be441a8dc8445028" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; argument must be a sequence that contains the following elements:</source>
          <target state="translated">的 &lt;code&gt;state&lt;/code&gt; 参数必须是包含下列元素的序列：</target>
        </trans-unit>
        <trans-unit id="28db18b99085783cc1cb19c430887ae4c1bd2dc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; tuple has the following items:</source>
          <target state="translated">该 &lt;code&gt;state&lt;/code&gt; 元组有以下三个项目：</target>
        </trans-unit>
        <trans-unit id="0e4c35736a2eec986972a33d172a5be16d326f7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tp_as_number&lt;/code&gt; methods use a generic approach to call whatever function has been registered for handling the operation. When the &lt;code&gt;_multiarray_umath module&lt;/code&gt; is imported, it sets the numeric operations for all arrays to the corresponding ufuncs. This choice can be changed with &lt;a href=&quot;c-api.ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt;&lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt;&lt;/a&gt; The &lt;code&gt;tp_str&lt;/code&gt; and &lt;code&gt;tp_repr&lt;/code&gt; methods can also be altered using &lt;a href=&quot;c-api.array#c.PyArray_SetStringFunction&quot;&gt;&lt;code&gt;PyArray_SetStringFunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;tp_as_number&lt;/code&gt; 方法使用一个通用的方法来调用函数的任何已登记处理操作。当 &lt;code&gt;_multiarray_umath module&lt;/code&gt; 被导入，它为所有阵列到相应ufuncs数字操作。这种选择可以改变&lt;a href=&quot;c-api.ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt; &lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;tp_str&lt;/code&gt; 和 &lt;code&gt;tp_repr&lt;/code&gt; 方法也可以使用改变&lt;a href=&quot;c-api.array#c.PyArray_SetStringFunction&quot;&gt; &lt;code&gt;PyArray_SetStringFunction&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="008291952c69e3c178208fe3d11495f165132897" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tp_as_number&lt;/code&gt; methods use a generic approach to call whatever function has been registered for handling the operation. When the &lt;code&gt;_multiarray_umath module&lt;/code&gt; is imported, it sets the numeric operations for all arrays to the corresponding ufuncs. This choice can be changed with &lt;a href=&quot;ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt;&lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt;&lt;/a&gt; The &lt;code&gt;tp_str&lt;/code&gt; and &lt;code&gt;tp_repr&lt;/code&gt; methods can also be altered using &lt;a href=&quot;array#c.PyArray_SetStringFunction&quot;&gt;&lt;code&gt;PyArray_SetStringFunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;tp_as_number&lt;/code&gt; 方法使用一个通用的方法来调用函数的任何已登记处理操作。当 &lt;code&gt;_multiarray_umath module&lt;/code&gt; 被导入，它为所有阵列到相应ufuncs数字操作。这种选择可以改变&lt;a href=&quot;ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt; &lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;tp_str&lt;/code&gt; 和 &lt;code&gt;tp_repr&lt;/code&gt; 方法也可以使用改变&lt;a href=&quot;array#c.PyArray_SetStringFunction&quot;&gt; &lt;code&gt;PyArray_SetStringFunction&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed5f797071b24065d3a9e203b1fcea474546397a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usecols&lt;/code&gt; argument</source>
          <target state="translated">该 &lt;code&gt;usecols&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="dacc9a6ff7c4ed92c303c098ba1201530567896c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.bitwise_or&lt;/code&gt; on ndarrays.</source>
          <target state="translated">的 &lt;code&gt;|&lt;/code&gt; 运算符可用作 &lt;code&gt;np.bitwise_or&lt;/code&gt; 上np.bitwise_or的简写。</target>
        </trans-unit>
        <trans-unit id="64f414452963f507b1ec195fd0751843c6eb8871" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.logical_or&lt;/code&gt; on boolean ndarrays.</source>
          <target state="translated">的 &lt;code&gt;|&lt;/code&gt; 操作者可以用作速记 &lt;code&gt;np.logical_or&lt;/code&gt; 上布尔ndarrays。</target>
        </trans-unit>
        <trans-unit id="db182f9eeb35e8d962f93ac7e0672564ab9219b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.invert&lt;/code&gt; on ndarrays.</source>
          <target state="translated">该 &lt;code&gt;~&lt;/code&gt; 运算符可以用作速记 &lt;code&gt;np.invert&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="5186f89054917ad06c4418d857ded8a6ad552d9f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Documentation&lt;/em&gt; for a software project is the set of reference, instructional, educational, informative material generated by the project developers and contributors, as well as discussions, presentations, videos and other user-generated content. It may include learning-oriented content (such as tutorials and how-tos), use-cases or in-depth explanations and reference for developers.</source>
          <target state="translated">软件项目的&lt;em&gt;文档&lt;/em&gt;是由项目开发人员和贡献者生成的参考，指导，教育，信息材料集，以及讨论，演示，视频和其他用户生成的内容。它可能包括面向学习的内容（例如教程和操作方法），用例或深入的说明以及供开发人员参考。</target>
        </trans-unit>
        <trans-unit id="88a54cde186ec5ee99014b55275737fd8ded4abc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;bounds&lt;/em&gt; argument is expected to be a (2 * iter-&amp;gt;ao-&amp;gt;nd) arrays, such as the range bound[2*i]-&amp;gt;bounds[2*i+1] defines the range where to walk for dimension i (both bounds are included in the walked coordinates). The bounds should be ordered for each dimension (bounds[2*i] &amp;lt;= bounds[2*i+1]).</source>
          <target state="translated">的&lt;em&gt;边界&lt;/em&gt;参数预期为一个（2 * iter-&amp;gt; AO-&amp;gt; ND）阵列，诸如结合的范围[2 * I] - &amp;gt;界[2 * I + 1]定义的范围内，其中以步行尺寸我（两个边界都包含在行走坐标中）。每个维度的边界应排序（bounds [2 * i] &amp;lt;= bounds [2 * i + 1]）。</target>
        </trans-unit>
        <trans-unit id="167173497ff130611588ae9a0a550c00ffde124f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;compile-time&lt;/em&gt; environment variables:</source>
          <target state="translated">在&lt;em&gt;编译时&lt;/em&gt;环境变量：</target>
        </trans-unit>
        <trans-unit id="ea1fe523a0552e237800f38d8997bfcb72c8d0f5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;func&lt;/em&gt;, &lt;em&gt;data&lt;/em&gt;, &lt;em&gt;types&lt;/em&gt;, &lt;em&gt;name&lt;/em&gt;, and &lt;em&gt;doc&lt;/em&gt; arguments are not copied by &lt;a href=&quot;#c.PyUFunc_FromFuncAndData&quot;&gt;&lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt;&lt;/a&gt;. The caller must ensure that the memory used by these arrays is not freed as long as the ufunc object is alive.</source>
          <target state="translated">该&lt;em&gt;FUNC&lt;/em&gt;，&lt;em&gt;数据&lt;/em&gt;，&lt;em&gt;类型&lt;/em&gt;，&lt;em&gt;名称&lt;/em&gt;，和&lt;em&gt;文档&lt;/em&gt;参数不被复制&lt;a href=&quot;#c.PyUFunc_FromFuncAndData&quot;&gt; &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; &lt;/a&gt;。只要ufunc对象处于活动状态，调用者必须确保不释放这些数组使用的内存。</target>
        </trans-unit>
        <trans-unit id="20c9d63d4d93167ef641a021fb26c115a182b092" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;itemsize&lt;/em&gt; key allows the total size of the dtype to be set, and must be an integer large enough so all the fields are within the dtype. If the dtype being constructed is aligned, the &lt;em&gt;itemsize&lt;/em&gt; must also be divisible by the struct alignment. Total dtype &lt;em&gt;itemsize&lt;/em&gt; is limited to &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt;&lt;code&gt;ctypes.c_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">项目&lt;em&gt;大小&lt;/em&gt;键允许设置&lt;em&gt;dtype&lt;/em&gt;的总大小，并且必须是足够大的整数，以便所有字段都在dtype内。如果正在构造的&lt;em&gt;dtype&lt;/em&gt;是对齐的，则&lt;em&gt;itemsize&lt;/em&gt;也必须可以被struct对齐整除。&lt;em&gt;dtype项的&lt;/em&gt;总&lt;em&gt;大小&lt;/em&gt;限制为&lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt; &lt;code&gt;ctypes.c_int&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ed9f0881461d81b2f7af8ce5229589ca6d28abd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-dimensional FFT of real input.</source>
          <target state="translated">实数输入的&lt;em&gt;n&lt;/em&gt;维FFT。</target>
        </trans-unit>
        <trans-unit id="35066a9f7cb50260dfe6cd2d771163f62f1011ce" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">在&lt;em&gt;&amp;ntilde;&lt;/em&gt;维FFT。</target>
        </trans-unit>
        <trans-unit id="1f82e353fb8bee88c46f056efaf0e1b9b205e05a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;out&lt;/em&gt; argument to &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt; is not supported, &lt;code&gt;third&lt;/code&gt; has to be None.</source>
          <target state="translated">不支持&lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt;的&lt;em&gt;out&lt;/em&gt;参数， &lt;code&gt;third&lt;/code&gt; 必须为None。</target>
        </trans-unit>
        <trans-unit id="17d0c90784f11b0394d45b1939c2a01c10fdf407" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;shape&lt;/em&gt; is the fixed shape of the sub-array described by this data type, and &lt;em&gt;item_dtype&lt;/em&gt; the data type of the array.</source>
          <target state="translated">该&lt;em&gt;形状&lt;/em&gt;是由该数据类型所描述的子阵列的固定形状，并且&lt;em&gt;item_dtype&lt;/em&gt;阵列的数据类型。</target>
        </trans-unit>
        <trans-unit id="aec9eb1678f53d31cf0a922b19885b55fcafd16e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;side&lt;/em&gt; argument indicates whether the index returned should be that of the first suitable location (if &lt;a href=&quot;#c.NPY_SEARCHLEFT&quot;&gt;&lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt;&lt;/a&gt;) or of the last (if &lt;a href=&quot;#c.NPY_SEARCHRIGHT&quot;&gt;&lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">所述&lt;em&gt;侧&lt;/em&gt;参数指示返回的索引是否应该是第一合适的位置的（如果&lt;a href=&quot;#c.NPY_SEARCHLEFT&quot;&gt; &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt; &lt;/a&gt;）或最后的（如果&lt;a href=&quot;#c.NPY_SEARCHRIGHT&quot;&gt; &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e35e90d2e4f0ba849a49c1795babe3ab2a9f08fe" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;side&lt;/em&gt; argument indicates whether the index returned should be that of the first suitable location (if &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt;) or of the last (if &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt;).</source>
          <target state="translated">所述&lt;em&gt;侧&lt;/em&gt;参数指示返回的索引是否应该是第一合适的位置的（如果 &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt; ）或最后的（如果 &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="099bc64f90d3db4f6c006d553b07493bf40349bd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sorter&lt;/em&gt; argument, if not &lt;code&gt;NULL&lt;/code&gt;, must be a 1D array of integer indices the same length as &lt;em&gt;self&lt;/em&gt;, that sorts it into ascending order. This is typically the result of a call to &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt;&lt;code&gt;PyArray_ArgSort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) Binary search is used to find the required insertion points.</source>
          <target state="translated">在&lt;em&gt;分选器&lt;/em&gt;的参数，如果不是 &lt;code&gt;NULL&lt;/code&gt; ，必须是整数索引的一维数组的长度相同&lt;em&gt;自我&lt;/em&gt;，即排序成升序排列。这通常是调用&lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt; &lt;code&gt;PyArray_ArgSort&lt;/code&gt; &lt;/a&gt;（...）的结果。二进制搜索用于查找所需的插入点。</target>
        </trans-unit>
        <trans-unit id="9171c42e0d10b56599a94002523d8b2e0c0e8b3e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;.npy&lt;/strong&gt; and &lt;strong&gt;.npz&lt;/strong&gt; files store data, shape, dtype, and other information required to reconstruct the ndarray in a way that allows the array to be correctly retrieved, even when the file is on another machine with different architecture.</source>
          <target state="translated">的&lt;strong&gt;.npy&lt;/strong&gt;和&lt;strong&gt;.npz&lt;/strong&gt;文件存储数据，形状，D型细胞，和所需的其它信息来重构ndarray的方式，允许阵列被正确检索，即使当该文件是具有不同体系结构另一台机器上。</target>
        </trans-unit>
        <trans-unit id="a635945c029e67349a5e1c329cf33ef8efa9b4ec" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;dots&lt;/strong&gt; (&lt;code&gt;...&lt;/code&gt;) represent as many colons as needed to produce a complete indexing tuple. For example, if &lt;code&gt;x&lt;/code&gt; is an array with 5 axes, then</source>
          <target state="translated">该&lt;strong&gt;点&lt;/strong&gt;（ &lt;code&gt;...&lt;/code&gt; 根据需要产生一个完整的索引元组）代表尽可能多的冒号。例如，如果 &lt;code&gt;x&lt;/code&gt; 是具有5个轴的数组，则</target>
        </trans-unit>
        <trans-unit id="7fad9b84d117a49a76f66aa7359451abb9299209" translate="yes" xml:space="preserve">
          <source>The API exposed by NumPy for third-party extensions has grown over years of releases, and has allowed programmers to directly access NumPy functionality from C. This API can be best described as &amp;ldquo;organic&amp;rdquo;. It has emerged from multiple competing desires and from multiple points of view over the years, strongly influenced by the desire to make it easy for users to move to NumPy from Numeric and Numarray. The core API originated with Numeric in 1995 and there are patterns such as the heavy use of macros written to mimic Python&amp;rsquo;s C-API as well as account for compiler technology of the late 90&amp;rsquo;s. There is also only a small group of volunteers who have had very little time to spend on improving this API.</source>
          <target state="translated">NumPy公开的用于第三方扩展的API已经增长了许多年，并且允许程序员直接从C访问NumPy功能。此API最好描述为&amp;ldquo;有机&amp;rdquo;。多年来，它已经从多种竞争需求和多种观点中脱颖而出，强烈地受到了使用户易于从Numeric和Numarray迁移到NumPy的渴望的影响。核心API起源于Numeric于1995年，其模式有很多，例如大量使用模仿Python的C-API编写的宏以及90年代后期的编译器技术。也只有一小部分志愿者花很少的时间来改善此API。</target>
        </trans-unit>
        <trans-unit id="00284168716cc312202174053f58f3f176efd9f0" translate="yes" xml:space="preserve">
          <source>The Array Interface</source>
          <target state="translated">阵列接口</target>
        </trans-unit>
        <trans-unit id="0126a67e2a45442b450ea70b10470e175bf968af" translate="yes" xml:space="preserve">
          <source>The Bartlett window is defined as</source>
          <target state="translated">Bartlett窗口定义为</target>
        </trans-unit>
        <trans-unit id="937ca2e1b9d54c371bf73ce20e57493839ccf829" translate="yes" xml:space="preserve">
          <source>The Bartlett window is very similar to a triangular window, except that the end points are at zero. It is often used in signal processing for tapering a signal, without generating too much ripple in the frequency domain.</source>
          <target state="translated">巴特利特窗与三角窗非常相似,只是端点在零点。在信号处理中,它经常被用来对信号进行渐变,而不会在频域内产生过多的波纹。</target>
        </trans-unit>
        <trans-unit id="a093f7952b1838c4dd6aeda28ea5e1fc38030960" translate="yes" xml:space="preserve">
          <source>The Basics</source>
          <target state="translated">基础知识</target>
        </trans-unit>
        <trans-unit id="9c87b609239622a7f33fd7054a79bbe3b69d99bf" translate="yes" xml:space="preserve">
          <source>The Beta distribution is a special case of the Dirichlet distribution, and is related to the Gamma distribution. It has the probability distribution function</source>
          <target state="translated">Beta分布是Dirichlet分布的一种特例,与Gamma分布有关。它的概率分布函数为</target>
        </trans-unit>
        <trans-unit id="2fd0f76d8d8eab0518886bc71aed9b0148fca33e" translate="yes" xml:space="preserve">
          <source>The BitGenerator can also be directly accessed using the members of the &lt;code&gt;bitgen_t&lt;/code&gt; struct.</source>
          <target state="translated">也可以使用 &lt;code&gt;bitgen_t&lt;/code&gt; 结构的成员直接访问BitGenerator。</target>
        </trans-unit>
        <trans-unit id="b111fe41355b271c80f9d028d2e71b1df692e910" translate="yes" xml:space="preserve">
          <source>The BitGenerator can also be directly accessed using the members of the basic RNG structure.</source>
          <target state="translated">也可以使用基本RNG结构的成员直接访问BitGenerator。</target>
        </trans-unit>
        <trans-unit id="fe9a0ff0e1aba5f3307dd340548f412e309bd12d" translate="yes" xml:space="preserve">
          <source>The BitGenerators have been designed to be extendable using standard tools for high-performance Python &amp;ndash; numba and Cython. The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; object can also be used with user-provided BitGenerators as long as these export a small set of required functions.</source>
          <target state="translated">BitGenerators设计为可使用用于高性能Python的标准工具numba和Cython进行扩展。该&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;目的也可以使用用户提供的BitGenerators使用，只要这些出口一小部分的所需功能。</target>
        </trans-unit>
        <trans-unit id="d038e7d7a9d5b6013d6bf710bb0f42c26b9ffb86" translate="yes" xml:space="preserve">
          <source>The Blackman window is a taper formed by using the first three terms of a summation of cosines. It was designed to have close to the minimal leakage possible. It is close to optimal, only slightly worse than a Kaiser window.</source>
          <target state="translated">布莱克曼窗是利用余弦相加的前三个项形成的锥度。它被设计为具有接近于最小的泄漏可能。它接近于最佳状态,只比凯撒窗稍差。</target>
        </trans-unit>
        <trans-unit id="df8aff554aa2b04bd579ded0666721d3f45ae21e" translate="yes" xml:space="preserve">
          <source>The Blackman window is defined as</source>
          <target state="translated">布莱克曼窗口定义为</target>
        </trans-unit>
        <trans-unit id="b108efac05f697f2e430596f72b3bb61068c8903" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using &lt;code&gt;Generator&lt;/code&gt; for the normal distribution or any other distribution that relies on the normal such as the &lt;a href=&quot;generated/numpy.random.generator.gamma#numpy.random.Generator.gamma&quot;&gt;&lt;code&gt;Generator.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.generator.standard_t#numpy.random.Generator.standard_t&quot;&gt;&lt;code&gt;Generator.standard_t&lt;/code&gt;&lt;/a&gt;. If you require bitwise backward compatible streams, use &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, i.e., &lt;a href=&quot;generated/numpy.random.randomstate.gamma#numpy.random.RandomState.gamma&quot;&gt;&lt;code&gt;RandomState.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.randomstate.standard_t#numpy.random.RandomState.standard_t&quot;&gt;&lt;code&gt;RandomState.standard_t&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于生成NumPy法线的Box-Muller方法在&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 中&lt;/a&gt;不再可用。使用 &lt;code&gt;Generator&lt;/code&gt; 对于正态分布或任何其他依赖于正态的分布（例如&lt;a href=&quot;generated/numpy.random.generator.gamma#numpy.random.Generator.gamma&quot;&gt; &lt;code&gt;Generator.gamma&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;generated/numpy.random.generator.standard_t#numpy.random.Generator.standard_t&quot;&gt; &lt;code&gt;Generator.standard_t&lt;/code&gt; ),&lt;/a&gt;无法再现精确的随机值。如果需要按位向后兼容的流，请使用&lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;，即&lt;a href=&quot;generated/numpy.random.randomstate.gamma#numpy.random.RandomState.gamma&quot;&gt; &lt;code&gt;RandomState.gamma&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;generated/numpy.random.randomstate.standard_t#numpy.random.RandomState.standard_t&quot;&gt; &lt;code&gt;RandomState.standard_t&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="201133c822c73c7e6eedbd7735bf455db76c868e" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using &lt;code&gt;Generator&lt;/code&gt; for the normal distribution or any other distribution that relies on the normal such as the &lt;code&gt;gamma&lt;/code&gt; or &lt;code&gt;standard_t&lt;/code&gt;. If you require bitwise backward compatible streams, use &lt;code&gt;RandomState&lt;/code&gt;.</source>
          <target state="translated">用于生成NumPy法线的Box-Muller方法在&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 中&lt;/a&gt;不再可用。使用 &lt;code&gt;Generator&lt;/code&gt; 不能针对正态分布或依赖于法线的任何其他分布（例如 &lt;code&gt;gamma&lt;/code&gt; 或 &lt;code&gt;standard_t&lt;/code&gt; )使用精确的随机值进行再现。如果需要按位向后兼容的流，请使用 &lt;code&gt;RandomState&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="530afb1a91925fe435a9294f8360e96b319ffb64" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using Generator for the normal distribution or any other distribution that relies on the normal such as the &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.gamma#numpy.random.mtrand.RandomState.gamma&quot;&gt;&lt;code&gt;RandomState.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.standard_t#numpy.random.mtrand.RandomState.standard_t&quot;&gt;&lt;code&gt;RandomState.standard_t&lt;/code&gt;&lt;/a&gt;. If you require bitwise backward compatible streams, use &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于生成NumPy法线的Box-Muller方法在&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 中&lt;/a&gt;不再可用。使用Generator不能为正态分布或任何其他依赖于正态的分布（例如&lt;a href=&quot;generated/numpy.random.mtrand.randomstate.gamma#numpy.random.mtrand.RandomState.gamma&quot;&gt; &lt;code&gt;RandomState.gamma&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;generated/numpy.random.mtrand.randomstate.standard_t#numpy.random.mtrand.RandomState.standard_t&quot;&gt; &lt;code&gt;RandomState.standard_t&lt;/code&gt; )&lt;/a&gt;再现精确的随机值。如果需要按位向后兼容的流，请使用&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21ca435d6d38aadf77947319cb2cc6cd824fa4fc" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using Generator for the normal distribution or any other distribution that relies on the normal such as the &lt;a href=&quot;generated/numpy.random.randomstate.gamma#numpy.random.RandomState.gamma&quot;&gt;&lt;code&gt;RandomState.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.randomstate.standard_t#numpy.random.RandomState.standard_t&quot;&gt;&lt;code&gt;RandomState.standard_t&lt;/code&gt;&lt;/a&gt;. If you require bitwise backward compatible streams, use &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于生成NumPy法线的Box-Muller方法在&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 中&lt;/a&gt;不再可用。使用Generator不能为正态分布或任何其他依赖于正态的分布（例如&lt;a href=&quot;generated/numpy.random.randomstate.gamma#numpy.random.RandomState.gamma&quot;&gt; &lt;code&gt;RandomState.gamma&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;generated/numpy.random.randomstate.standard_t#numpy.random.RandomState.standard_t&quot;&gt; &lt;code&gt;RandomState.standard_t&lt;/code&gt; )&lt;/a&gt;再现精确的随机值。如果需要按位向后兼容的流，请使用&lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="08ca8f1d4aa8ba16007dde802489e6ef41f52bf0" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available.</source>
          <target state="translated">用于生成NumPy法线的Box-Muller方法不再可用。</target>
        </trans-unit>
        <trans-unit id="2ae4a149c67359ea20a856b43946c0a1b6f16635" translate="yes" xml:space="preserve">
          <source>The Broadcasting Rule</source>
          <target state="translated">广播规则</target>
        </trans-unit>
        <trans-unit id="9895a5af5b1d937c582f3977255f2f51e2fa8cde" translate="yes" xml:space="preserve">
          <source>The C ABI version number in numpy/core/setup_common.py should only be updated for a major release.</source>
          <target state="translated">numpy/core/setup_common.py中的C ABI版本号应该只为主要版本更新。</target>
        </trans-unit>
        <trans-unit id="9f1ca425ef21b0d3713606817fa90d6d2d43ef46" translate="yes" xml:space="preserve">
          <source>The C API version needs to be tracked in three places</source>
          <target state="translated">C API的版本需要在三个地方进行跟踪。</target>
        </trans-unit>
        <trans-unit id="12c85becd504bcc9e1840ed9b25393915f66f319" translate="yes" xml:space="preserve">
          <source>The C code to be wrapped for argoutview arrays are characterized by pointers: pointers to the dimensions and double pointers to the data, so that these values can be passed back to the user. The argoutview typemap signatures are therefore</source>
          <target state="translated">argoutview数组要封装的C代码的特点是指针:指向维度的指针和指向数据的双指针,因此这些值可以传回给用户。因此,argoutview的类型映射签名为</target>
        </trans-unit>
        <trans-unit id="21de11f0f6aeb101275d43918daa34e6c36dce23" translate="yes" xml:space="preserve">
          <source>The C file is given below.</source>
          <target state="translated">下面给出的是C文件。</target>
        </trans-unit>
        <trans-unit id="ce59a78e88c7f509dea5f34f975be44fdfb7e3ba" translate="yes" xml:space="preserve">
          <source>The C file is given below. The ufunc generated takes two arguments A and B. It returns a tuple whose first element is A*B and whose second element is logit(A*B). Note that it automatically supports broadcasting, as well as all other properties of a ufunc.</source>
          <target state="translated">下面给出了C文件。生成的ufunc需要两个参数A和B,它返回一个元组,其第一个元素是A*B,第二个元素是logit(A*B)。请注意,它自动支持广播,以及其他所有ufunc的属性。</target>
        </trans-unit>
        <trans-unit id="3b86dcfa016c911d4342c93c728710eb6da34647" translate="yes" xml:space="preserve">
          <source>The C-API is actually an array of function pointers. This array is created (and pointed to by a global variable) by import_ufunc. The global variable is either statically defined or allowed to be seen by other files depending on the state of &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt;&lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C-API实际上是一个函数指针数组。此数组由import_ufunc创建（并由全局变量指向）。根据&lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt; &lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt; &lt;/a&gt;的状态，全局变量是静态定义的，还是允许其他文件查看。</target>
        </trans-unit>
        <trans-unit id="96e666c1c0b5a663da4c4f946173e189e8d49d4f" translate="yes" xml:space="preserve">
          <source>The C-code generated by Cython is hard to read and modify (and typically compiles with annoying but harmless warnings).</source>
          <target state="translated">Cython生成的C代码很难阅读和修改(通常在编译的时候会有恼人但无害的警告)。</target>
        </trans-unit>
        <trans-unit id="27ac48dd933ed72b23987767613d8001cf662454" translate="yes" xml:space="preserve">
          <source>The C-structure corresponding to an object of &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; is used to keep track of a pointer into an N-dimensional array. It contains associated information used to quickly march through the array. The pointer can be adjusted in three basic ways: 1) advance to the &amp;ldquo;next&amp;rdquo; position in the array in a C-style contiguous fashion, 2) advance to an arbitrary N-dimensional coordinate in the array, and 3) advance to an arbitrary one-dimensional index into the array. The members of the &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure are used in these calculations. Iterator objects keep their own dimension and strides information about an array. This can be adjusted as needed for &amp;ldquo;broadcasting,&amp;rdquo; or to loop over only specific dimensions.</source>
          <target state="translated">对应于&lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; &lt;/a&gt;对象的C结构是&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;。所述&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;被用于跟踪的指针的成N维阵列。它包含用于快速遍历阵列的关联信息。可以通过三种基本方式来调整指针：1）以C样式的连续方式前进到数组中的&amp;ldquo;下一个&amp;rdquo;位置； 2）前进到数组中任意N维坐标，以及3）前进到数组中的任意N维坐标。数组中的任意一维索引。&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;的成员这些计算中使用结构。迭代器对象保留其自己的尺寸，并遍历有关数组的信息。可以根据需要进行&amp;ldquo;广播&amp;rdquo;调整，也可以仅在特定尺寸上循环播放。</target>
        </trans-unit>
        <trans-unit id="5b65035b5e2ef1f9ddd680e8269d8b6e8cd78edf" translate="yes" xml:space="preserve">
          <source>The C-structure corresponding to an object of &lt;a href=&quot;#c.PyArrayNeighborhoodIter_Type&quot;&gt;&lt;code&gt;PyArrayNeighborhoodIter_Type&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;#c.PyArrayNeighborhoodIterObject&quot;&gt;&lt;code&gt;PyArrayNeighborhoodIterObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对应于&lt;a href=&quot;#c.PyArrayNeighborhoodIter_Type&quot;&gt; &lt;code&gt;PyArrayNeighborhoodIter_Type&lt;/code&gt; &lt;/a&gt;对象的C结构是&lt;a href=&quot;#c.PyArrayNeighborhoodIterObject&quot;&gt; &lt;code&gt;PyArrayNeighborhoodIterObject&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b70a592ea3e52c944c4250fca143b3a7150ee3c2" translate="yes" xml:space="preserve">
          <source>The Cauchy distribution arises in the solution to the driven harmonic oscillator problem, and also describes spectral line broadening. It also describes the distribution of values at which a line tilted at a random angle will cut the x axis.</source>
          <target state="translated">Cauchy分布是在解决驱动谐波振荡器问题时产生的,也描述了谱线拓宽。它还描述了以随机角度倾斜的线将切断x轴的值的分布。</target>
        </trans-unit>
        <trans-unit id="7e16b7bac76fd95a18826e75104c29f03fcae229" translate="yes" xml:space="preserve">
          <source>The Chebyshev class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the methods listed below.</source>
          <target state="translated">Chebyshev类提供标准的Python数值方法'+'，'-'，'*'，'//'，'％'，'divmod'，'**'和'（）'以及列出的方法下面。</target>
        </trans-unit>
        <trans-unit id="c6a112ce3f849b264d8d346313df28993dc02ff9" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the first kind are the points &lt;code&gt;cos(x)&lt;/code&gt;, where &lt;code&gt;x = [pi*(k + .5)/npts for k in range(npts)]&lt;/code&gt;.</source>
          <target state="translated">第一种Chebyshev点是点 &lt;code&gt;cos(x)&lt;/code&gt; ，其中 &lt;code&gt;x = [pi*(k + .5)/npts for k in range(npts)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b0a900a5e45540387f1b83ea73e67c934d19eae" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the first kind.</source>
          <target state="translated">第一类的切比雪夫点。</target>
        </trans-unit>
        <trans-unit id="ca4f0f30abc65b046f7d9e6e691b51c78603fec0" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the second kind are the points &lt;code&gt;cos(x)&lt;/code&gt;, where &lt;code&gt;x = [pi*k/(npts - 1) for k in range(npts)]&lt;/code&gt;.</source>
          <target state="translated">第二种Chebyshev点是点 &lt;code&gt;cos(x)&lt;/code&gt; ，其中 &lt;code&gt;x = [pi*k/(npts - 1) for k in range(npts)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="196d20b8bbd6f4729eb062a203e433edbc71fdcc" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the second kind.</source>
          <target state="translated">第二种的切比雪夫点。</target>
        </trans-unit>
        <trans-unit id="18aa36d5e6637359f0f8c985312900157e497010" translate="yes" xml:space="preserve">
          <source>The Chebyshev polynomials used in the interpolation are orthogonal when sampled at the Chebyshev points of the first kind. If it is desired to constrain some of the coefficients they can simply be set to the desired value after the interpolation, no new interpolation or fit is needed. This is especially useful if it is known apriori that some of coefficients are zero. For instance, if the function is even then the coefficients of the terms of odd degree in the result can be set to zero.</source>
          <target state="translated">内插中使用的切比雪夫多项式在第一种切比雪夫点采样时是正交的。如果需要约束一些系数,可以在插值后简单地将其设置为所需的值,不需要进行新的插值或拟合。如果事先知道某些系数为零,这一点特别有用。例如,如果函数是偶数,那么结果中奇数项的系数可以设置为零。</target>
        </trans-unit>
        <trans-unit id="993466511b9f370f4f72797c543b0fe46fcac4af" translate="yes" xml:space="preserve">
          <source>The Chebyshev series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Chebyshev系列基础多项式不是 &lt;code&gt;x&lt;/code&gt; 的幂，因此此函数的结果似乎不直观。</target>
        </trans-unit>
        <trans-unit id="46d5d357969a2c2d8e943734dcd70f209f532e7d" translate="yes" xml:space="preserve">
          <source>The Cholesky decomposition is often used as a fast way of solving</source>
          <target state="translated">Cholesky分解法经常被用来作为快速解决</target>
        </trans-unit>
        <trans-unit id="794b3c9b410012bd85aeaac5a58c341f1529d513" translate="yes" xml:space="preserve">
          <source>The Code of Conduct Committee should aim to have a resolution agreed upon within two weeks. In the event that a resolution can&amp;rsquo;t be determined in that time, the committee will respond to the reporter(s) with an update and projected timeline for resolution.</source>
          <target state="translated">行为守则委员会的目标应该是在两周内达成一致的解决方案。如果在此期间无法确定解决方案，则委员会将以更新和预计的解决方案时间表回应记者。</target>
        </trans-unit>
        <trans-unit id="df5489514988058a36fb9ae08de6595979ec21a6" translate="yes" xml:space="preserve">
          <source>The Code of Conduct Committee will formally review and sign off on all cases where this mechanism has been applied to make sure it is not being used to control ordinary heated disagreement.</source>
          <target state="translated">行为守则委员会将正式审查并签署所有适用该机制的案例,以确保该机制没有被用来控制普通的激烈分歧。</target>
        </trans-unit>
        <trans-unit id="4e3bda4dc5a743a992fdb89cad8080af0867b844" translate="yes" xml:space="preserve">
          <source>The Council can create subcommittees that provide leadership and guidance for specific aspects of the project. Like the Council as a whole, subcommittees should conduct their business in an open and public manner unless privacy is specifically called for. Private subcommittee communications should happen on the main private mailing list of the Council unless specifically called for.</source>
          <target state="translated">理事会可以设立小组委员会,为项目的具体方面提供领导和指导。与整个理事会一样,各小组委员会应以公开的方式开展工作,除非特别要求保密。除非有特别要求,否则小组委员会的私人通信应在理事会的主要私人邮件列表上进行。</target>
        </trans-unit>
        <trans-unit id="7cca4e29456fdc96aaa3058f6b88f125bd4fb528" translate="yes" xml:space="preserve">
          <source>The Council reserves the right to eject current Members, if they are deemed to be actively harmful to the project&amp;rsquo;s well-being, and attempts at communication and conflict resolution have failed. This requires the consensus of the remaining Members.</source>
          <target state="translated">如果认为现任成员对项目的福祉有积极损害，而沟通和解决冲突的尝试均告失败，则理事会保留罢免其权利。这需要其余成员达成共识。</target>
        </trans-unit>
        <trans-unit id="777c1bc322cb9c22bf40b3217235aef27f1cd1cf" translate="yes" xml:space="preserve">
          <source>The Council will maintain one narrowly focused subcommittee to manage its interactions with NumFOCUS.</source>
          <target state="translated">理事会将保留一个重点突出的小组委员会,以管理其与NumFOCUS的互动。</target>
        </trans-unit>
        <trans-unit id="7319ec02e3cbbaab7add308cd0a417516f369a3b" translate="yes" xml:space="preserve">
          <source>The DFT is defined, with the conventions used in this implementation, in the documentation for the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">使用此实现中使用的约定在&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt;模块的文档中定义了DFT。</target>
        </trans-unit>
        <trans-unit id="c850428d828f95dc2c92af14d3b7a369fbb6f873" translate="yes" xml:space="preserve">
          <source>The DFT is in general defined for complex inputs and outputs, and a single-frequency component at linear frequency</source>
          <target state="translated">一般来说,DFT是针对复杂的输入和输出而定义的,在线性频率下的单频分量。</target>
        </trans-unit>
        <trans-unit id="e1f0dbe8081449397bad0aa2cc6ad0fe41215d23" translate="yes" xml:space="preserve">
          <source>The Datetime and Timedelta data types support a large number of time units, as well as generic units which can be coerced into any of the other units based on input data.</source>
          <target state="translated">Datetime和Timedelta数据类型支持大量的时间单位,以及通用单位,这些单位可以根据输入数据被强制成任何其他单位。</target>
        </trans-unit>
        <trans-unit id="fcc8fbde1f068047c588e86f64b1d9bca100dc12" translate="yes" xml:space="preserve">
          <source>The Dirichlet distribution is a distribution over vectors</source>
          <target state="translated">Dirichlet分布是一个在向量上的分布。</target>
        </trans-unit>
        <trans-unit id="a4edf1637ded5c0257b8e49c407baa1302046498" translate="yes" xml:space="preserve">
          <source>The Einstein summation convention can be used to compute many multi-dimensional, linear algebraic array operations. &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; provides a succinct way of representing these.</source>
          <target state="translated">爱因斯坦求和约定可用于计算许多多维的线性代数数组运算。&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;提供了一种简洁的表示方式。</target>
        </trans-unit>
        <trans-unit id="28b073ac0a61d366802edc13aac74cfca673e0d2" translate="yes" xml:space="preserve">
          <source>The Euler constant</source>
          <target state="translated">欧拉常数</target>
        </trans-unit>
        <trans-unit id="e516b8e0c93fdf83378c5af74b4c3f11ab8b2eec" translate="yes" xml:space="preserve">
          <source>The F statistic is used to compare in-group variances to between-group variances. Calculating the distribution depends on the sampling, and so it is a function of the respective degrees of freedom in the problem. The variable &lt;code&gt;dfnum&lt;/code&gt; is the number of samples minus one, the between-groups degrees of freedom, while &lt;code&gt;dfden&lt;/code&gt; is the within-groups degrees of freedom, the sum of the number of samples in each group minus the number of groups.</source>
          <target state="translated">F统计量用于比较组内方差与组间方差。计算分布取决于采样，因此它是问题中各个自由度的函数。变量 &lt;code&gt;dfnum&lt;/code&gt; 是样本数减去一，即组间自由度，而 &lt;code&gt;dfden&lt;/code&gt; 是组内自由度，即每组样本数的总和减去组数。</target>
        </trans-unit>
        <trans-unit id="ec341083311bc5d9e93dc0e719289499e7876f9f" translate="yes" xml:space="preserve">
          <source>The F2PY interface to Fortran 90 module data is similar to Fortran 77 common blocks.</source>
          <target state="translated">F2PY对Fortran 90模块数据的接口与Fortran 77通用块类似。</target>
        </trans-unit>
        <trans-unit id="255611abe871551a6f0d10449c721d9ac320d3a5" translate="yes" xml:space="preserve">
          <source>The Frobenius norm is given by &lt;a href=&quot;#rac1c834adb66-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="translated">Frobenius范数由&lt;a href=&quot;#rac1c834adb66-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;给出：</target>
        </trans-unit>
        <trans-unit id="4ebf7b4a74f003f8630476569ef53bec8c91caed" translate="yes" xml:space="preserve">
          <source>The GIL is released for all &lt;code&gt;np.einsum&lt;/code&gt; variations</source>
          <target state="translated">释放所有 &lt;code&gt;np.einsum&lt;/code&gt; 变体的GIL</target>
        </trans-unit>
        <trans-unit id="7783b7563d5c19477bd0cec8f560b128f37ead00" translate="yes" xml:space="preserve">
          <source>The Gamma distribution is often used to model the times to failure of electronic components, and arises naturally in processes for which the waiting times between Poisson distributed events are relevant.</source>
          <target state="translated">Gamma分布经常被用来模拟电子元件的失效时间,并且自然而然地出现在与泊松分布事件之间的等待时间相关的过程中。</target>
        </trans-unit>
        <trans-unit id="9c990e445bfb7966adc1e3b9adac640f1e0e9113" translate="yes" xml:space="preserve">
          <source>The Generator&amp;rsquo;s normal, exponential and gamma functions use 256-step Ziggurat methods which are 2-10 times faster than NumPy&amp;rsquo;s Box-Muller or inverse CDF implementations.</source>
          <target state="translated">Generator的常规，指数和伽马函数使用256步Ziggurat方法，比NumPy的Box-Muller或CDF逆实现快2-10倍。</target>
        </trans-unit>
        <trans-unit id="5fd129bc188ef44c6bd32a38b068d9f3ddc783f7" translate="yes" xml:space="preserve">
          <source>The Gumbel (named for German mathematician Emil Julius Gumbel) was used very early in the hydrology literature, for modeling the occurrence of flood events. It is also used for modeling maximum wind speed and rainfall rates. It is a &amp;ldquo;fat-tailed&amp;rdquo; distribution - the probability of an event in the tail of the distribution is larger than if one used a Gaussian, hence the surprisingly frequent occurrence of 100-year floods. Floods were initially modeled as a Gaussian process, which underestimated the frequency of extreme events.</source>
          <target state="translated">Gumbel（以德国数学家Emil Julius Gumbel的名字命名）在水文学中很早就被用来模拟洪水事件的发生。它也用于建模最大风速和降雨量。这是一种&amp;ldquo;肥尾&amp;rdquo;分布-分布尾部发生事件的可能性大于使用高斯分布的情况，因此令人惊讶地频繁发生了100年的洪水。洪水最初被建模为高斯过程，这高估了极端事件的发生频率。</target>
        </trans-unit>
        <trans-unit id="aa1cbdb34f4d0d2f5ba482222c9284e53a83897b" translate="yes" xml:space="preserve">
          <source>The Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme Value Type I) distribution is one of a class of Generalized Extreme Value (GEV) distributions used in modeling extreme value problems. The Gumbel is a special case of the Extreme Value Type I distribution for maximums from distributions with &amp;ldquo;exponential-like&amp;rdquo; tails.</source>
          <target state="translated">Gumbel（或最小极值（SEV）或I最小极值类型）分布是用于建模极值问题的一类广义极值（GEV）分布之一。Gumbel是I极值类型分布的一种特例，用于从带有&amp;ldquo;指数状&amp;rdquo;尾部的分布中获得最大值。</target>
        </trans-unit>
        <trans-unit id="d38e3c533241c1cffef7a77e2fb316d839d0e953" translate="yes" xml:space="preserve">
          <source>The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and is described in Blackman and Tukey. It was recommended for smoothing the truncated autocovariance function in the time domain. Most references to the Hamming window come from the signal processing literature, where it is used as one of many windowing functions for smoothing values. It is also known as an apodization (which means &amp;ldquo;removing the foot&amp;rdquo;, i.e. smoothing discontinuities at the beginning and end of the sampled signal) or tapering function.</source>
          <target state="translated">Hamming以JW Tukey的合伙人RW Hamming的名字命名，并在Blackman和Tukey中进行了描述。建议在时域中平滑截断的自协方差函数。对汉明窗的大多数参考来自信号处理文献，在该文献中，汉明窗用作平滑值的许多窗函数之一。这也被称为切趾（apodization）（意思是&amp;ldquo;移开脚&amp;rdquo;，即在采样信号的开始和结束处平滑不连续点）或渐缩功能。</target>
        </trans-unit>
        <trans-unit id="f6f99a10c7b1d0ed496e360cabc47ad0e8b4f95f" translate="yes" xml:space="preserve">
          <source>The Hamming window is a taper formed by using a weighted cosine.</source>
          <target state="translated">汉明窗是利用加权余弦形成的锥度。</target>
        </trans-unit>
        <trans-unit id="c543c8775de7884a498fb8d25199a6da7865f313" translate="yes" xml:space="preserve">
          <source>The Hamming window is defined as</source>
          <target state="translated">汉明窗口定义为</target>
        </trans-unit>
        <trans-unit id="c53c036c06b914f30dfda36ac484fab584082b10" translate="yes" xml:space="preserve">
          <source>The Hanning was named for Julius von Hann, an Austrian meteorologist. It is also known as the Cosine Bell. Some authors prefer that it be called a Hann window, to help avoid confusion with the very similar Hamming window.</source>
          <target state="translated">汉宁号是以奥地利气象学家Julius von Hann的名字命名的。它也被称为余弦钟。有些作者喜欢把它称为汉恩窗,以避免与非常相似的汉明窗相混淆。</target>
        </trans-unit>
        <trans-unit id="ff9ff54dbcac5fb28018a438cebbfd23097afaae" translate="yes" xml:space="preserve">
          <source>The Hanning window is a taper formed by using a weighted cosine.</source>
          <target state="translated">汉宁窗是利用加权余弦形成的锥度。</target>
        </trans-unit>
        <trans-unit id="7063e81cb7e74fa0cdbf05d1c6333c059e7c5e09" translate="yes" xml:space="preserve">
          <source>The Hanning window is defined as</source>
          <target state="translated">汉宁窗口定义为</target>
        </trans-unit>
        <trans-unit id="48a86546760e1edd4295f33a270bba0337fe9c75" translate="yes" xml:space="preserve">
          <source>The Heaviside step function is defined as:</source>
          <target state="translated">Heaviside阶梯函数定义为:</target>
        </trans-unit>
        <trans-unit id="a4ab8a335073ed439b508ce34550cc0419ac6836" translate="yes" xml:space="preserve">
          <source>The Hermite class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Hermite类提供标准的Python数值方法'+'，'-'，'*'，'//'，'％'，'divmod'，'**'和'（）'以及属性和 &lt;code&gt;ABCPolyBase&lt;/code&gt; 文档中列出的方法。</target>
        </trans-unit>
        <trans-unit id="18c51c2fe8d0823ca52707c91973d012f1770684" translate="yes" xml:space="preserve">
          <source>The Hermite series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Hermite系列基础多项式不是 &lt;code&gt;x&lt;/code&gt; 的幂，因此此函数的结果似乎不直观。</target>
        </trans-unit>
        <trans-unit id="29f886dede3063b00d8467b1f756a147bc393097" translate="yes" xml:space="preserve">
          <source>The HermiteE class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">HermiteE类提供标准的Python数值方法'+'，'-'，'*'，'//'，'％'，'divmod'，'**'和'（）'以及属性和 &lt;code&gt;ABCPolyBase&lt;/code&gt; 文档中列出的方法。</target>
        </trans-unit>
        <trans-unit id="8cc8b1724a44c8d63d2cfd0d81bc585f17fc260c" translate="yes" xml:space="preserve">
          <source>The HermiteE series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">HermiteE系列基础多项式不是 &lt;code&gt;x&lt;/code&gt; 的幂，因此此函数的结果似乎不直观。</target>
        </trans-unit>
        <trans-unit id="d4c697a75ca6fe93876f5946baa1a9463872c64a" translate="yes" xml:space="preserve">
          <source>The IRR is perhaps best understood through an example (illustrated using np.irr in the Examples section below). Suppose one invests 100 units and then makes the following withdrawals at regular (fixed) intervals: 39, 59, 55, 20. Assuming the ending value is 0, one&amp;rsquo;s 100 unit investment yields 173 units; however, due to the combination of compounding and the periodic withdrawals, the &amp;ldquo;average&amp;rdquo; rate of return is neither simply 0.73/4 nor (1.73)^0.25-1. Rather, it is the solution (for</source>
          <target state="translated">可以通过一个示例（在下面的&amp;ldquo;示例&amp;rdquo;部分中使用np.irr进行说明）来最好地理解IRR。假设某人投资100个单位，然后以固定的（固定的）时间间隔进行以下提取：39、59、55、20。假设最终值为0，则某人的100个单位投资产生173个单位；然而，由于复利和定期提款的结合，&amp;ldquo;平均&amp;rdquo;回报率既不是简单的0.73 / 4也不是（1.73）^ 0.25-1。而是解决方案</target>
        </trans-unit>
        <trans-unit id="ddbfb62d79e442dbada344aa5b0b7d3f75bd62fd" translate="yes" xml:space="preserve">
          <source>The Kaiser can approximate many other windows by varying the beta parameter.</source>
          <target state="translated">凯撒可以通过改变β参数来近似其他许多窗口。</target>
        </trans-unit>
        <trans-unit id="61a6a7b7c0a7a3c07a636b9187a5aa5c8ed22e80" translate="yes" xml:space="preserve">
          <source>The Kaiser was named for Jim Kaiser, who discovered a simple approximation to the DPSS window based on Bessel functions. The Kaiser window is a very good approximation to the Digital Prolate Spheroidal Sequence, or Slepian window, which is the transform which maximizes the energy in the main lobe of the window relative to total energy.</source>
          <target state="translated">Kaiser是以Jim Kaiser命名的,他发现了一个基于Bessel函数的DPSS窗口的简单近似。Kaiser窗是数字普罗尔球体序列的一个非常好的近似,或者说是Slepian窗,它是相对于总能量而言,使窗口主叶的能量最大化的变换。</target>
        </trans-unit>
        <trans-unit id="3c47d6f84b8a7a5230ef01c3b24f485faf045505" translate="yes" xml:space="preserve">
          <source>The Kaiser window is a taper formed by using a Bessel function.</source>
          <target state="translated">凯撒窗是利用贝塞尔函数形成的锥度。</target>
        </trans-unit>
        <trans-unit id="d40317952ac62ac63be6a7eb42d8bb031447a844" translate="yes" xml:space="preserve">
          <source>The Kaiser window is defined as</source>
          <target state="translated">凯撒窗的定义为</target>
        </trans-unit>
        <trans-unit id="de389ba4bc7accb91ca973f3199d4d09bb36d074" translate="yes" xml:space="preserve">
          <source>The Laguerre class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Laguerre类提供标准的Python数值方法'+'，'-'，'*'，'//'，'％'，'divmod'，'**'和'（）'以及属性和 &lt;code&gt;ABCPolyBase&lt;/code&gt; 文档中列出的方法。</target>
        </trans-unit>
        <trans-unit id="673da347447c32096475798f43cd3eae37f1e962" translate="yes" xml:space="preserve">
          <source>The Laguerre series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Laguerre系列基础多项式不是 &lt;code&gt;x&lt;/code&gt; 的幂，因此此函数的结果似乎不直观。</target>
        </trans-unit>
        <trans-unit id="beacaa427ac9dd11f90d057bc9c94b6f47608f00" translate="yes" xml:space="preserve">
          <source>The Laplace distribution is similar to the Gaussian/normal distribution, but is sharper at the peak and has fatter tails. It represents the difference between two independent, identically distributed exponential random variables.</source>
          <target state="translated">拉普拉斯分布类似于高斯/正态分布,但其峰值更尖锐,尾部更粗。它表示两个独立的、相同分布的指数随机变量之间的差异。</target>
        </trans-unit>
        <trans-unit id="9f6965544802824fa340cc542a5a8e5ec41b1a8a" translate="yes" xml:space="preserve">
          <source>The Legendre class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Legendre类提供标准的Python数值方法'+'，'-'，'*'，'//'，'％'，'divmod'，'**'和'（）'以及属性和 &lt;code&gt;ABCPolyBase&lt;/code&gt; 文档中列出的方法。</target>
        </trans-unit>
        <trans-unit id="083c119f1df4d844bfc4b2160deea854a1daea76" translate="yes" xml:space="preserve">
          <source>The Legendre series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">勒让德级数基础多项式不是 &lt;code&gt;x&lt;/code&gt; 的幂，因此此函数的结果似乎不直观。</target>
        </trans-unit>
        <trans-unit id="191a6c01d66efbf4468b0c4b76d708edbb3efb30" translate="yes" xml:space="preserve">
          <source>The Logistic distribution is used in Extreme Value problems where it can act as a mixture of Gumbel distributions, in Epidemiology, and by the World Chess Federation (FIDE) where it is used in the Elo ranking system, assuming the performance of each player is a logistically distributed random variable.</source>
          <target state="translated">Logistic分布被用于极值问题中,它可以作为Gumbel分布的混合物,在流行病学中,世界棋联(FIDE)在Elo排名系统中使用它,假设每个棋手的表现是一个逻辑分布的随机变量。</target>
        </trans-unit>
        <trans-unit id="7e46f1b490ad93ea0aa4b70cea1c8217c1eeec4d" translate="yes" xml:space="preserve">
          <source>The Lomax or Pareto II distribution is a shifted Pareto distribution. The classical Pareto distribution can be obtained from the Lomax distribution by adding 1 and multiplying by the scale parameter &lt;code&gt;m&lt;/code&gt; (see Notes). The smallest value of the Lomax distribution is zero while for the classical Pareto distribution it is &lt;code&gt;mu&lt;/code&gt;, where the standard Pareto distribution has location &lt;code&gt;mu = 1&lt;/code&gt;. Lomax can also be considered as a simplified version of the Generalized Pareto distribution (available in SciPy), with the scale set to one and the location set to zero.</source>
          <target state="translated">Lomax或Pareto II分布是移位的Pareto分布。可以通过将Lomax分布加1并乘以比例参数 &lt;code&gt;m&lt;/code&gt; 来获得经典的Pareto分布（请参见注释）。Lomax分布的最小值为零，而经典Pareto分布的最小值为 &lt;code&gt;mu&lt;/code&gt; ，而标准Pareto分布的位置为 &lt;code&gt;mu = 1&lt;/code&gt; 。Lomax也可以被视为Generalized Pareto分布的简化版本（在SciPy中可用），比例设置为1，位置设置为零。</target>
        </trans-unit>
        <trans-unit id="913eec14ed443e489cdc77c2f2c24950a32724fd" translate="yes" xml:space="preserve">
          <source>The MATLAB &lt;code&gt;rem&lt;/code&gt; function and or the C &lt;code&gt;%&lt;/code&gt; operator which is the complement to &lt;code&gt;int(x1 / x2)&lt;/code&gt;.</source>
          <target state="translated">MATLAB &lt;code&gt;rem&lt;/code&gt; 函数和/或C &lt;code&gt;%&lt;/code&gt; 运算符，它是 &lt;code&gt;int(x1 / x2)&lt;/code&gt; 的补充。</target>
        </trans-unit>
        <trans-unit id="accc4f84d711af6e82c6efbbd034211d91d17fc7" translate="yes" xml:space="preserve">
          <source>The MaskedArray class</source>
          <target state="translated">MaskedArray类</target>
        </trans-unit>
        <trans-unit id="5110aa799914ad12dc0bd211beae0c5585bdbc96" translate="yes" xml:space="preserve">
          <source>The Matrix class</source>
          <target state="translated">矩阵类</target>
        </trans-unit>
        <trans-unit id="aae8587a9f8f2d6d760d4e3f9211a40fc1df3fef" translate="yes" xml:space="preserve">
          <source>The N-dimensional array (&lt;code&gt;ndarray&lt;/code&gt;)</source>
          <target state="translated">N维数组（ &lt;code&gt;ndarray&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ebbab7ca4ee7572bcfa080543866bf18ac7ca419" translate="yes" xml:space="preserve">
          <source>The N-dimensional array (ndarray)</source>
          <target state="translated">N维数组(ndarray)</target>
        </trans-unit>
        <trans-unit id="9062ffe94800b2d5eac1ade12a3d3195e3fb90d9" translate="yes" xml:space="preserve">
          <source>The NPV of the input cash flow series &lt;code&gt;values&lt;/code&gt; at the discount &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">输入现金流系列的NPV &lt;code&gt;values&lt;/code&gt; 的折现&lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5866f74403500e7f4919cdc811cc2cfc492bf57b" translate="yes" xml:space="preserve">
          <source>The NVIDIA HPC SDK nvfortran compiler is now supported</source>
          <target state="translated">英伟达HPC SDK nvfortran编译器现在已被支持。</target>
        </trans-unit>
        <trans-unit id="cb50b084062a9f4384d9b2a21c7bda6e285e1c12" translate="yes" xml:space="preserve">
          <source>The NumFOCUS Subcommittee is comprised of 5 persons who manage project funding that comes through NumFOCUS. It is expected that these funds will be spent in a manner that is consistent with the non-profit mission of NumFOCUS and the direction of the Project as determined by the full Council.</source>
          <target state="translated">NumFOCUS小组委员会由5人组成,负责管理通过NumFOCUS提供的项目资金。预计这些资金的使用方式将符合NumFOCUS的非营利使命和理事会全体决定的项目方向。</target>
        </trans-unit>
        <trans-unit id="06341e3da348b45983c3d2e0a0cf15e91944f0fa" translate="yes" xml:space="preserve">
          <source>The NumPy 1.6 release includes a more primitive datetime data type than 1.7. This section documents many of the changes that have taken place.</source>
          <target state="translated">NumPy 1.6版本包含了比1.7更原始的数据时间类型。本节记录了许多已经发生的变化。</target>
        </trans-unit>
        <trans-unit id="5b56ea0dc221ea864b938eecd7f439b2151cafda" translate="yes" xml:space="preserve">
          <source>The NumPy &lt;code&gt;histogram&lt;/code&gt; function applied to an array returns a pair of vectors: the histogram of the array and a vector of the bin edges. Beware: &lt;code&gt;matplotlib&lt;/code&gt; also has a function to build histograms (called &lt;code&gt;hist&lt;/code&gt;, as in Matlab) that differs from the one in NumPy. The main difference is that &lt;code&gt;pylab.hist&lt;/code&gt; plots the histogram automatically, while &lt;code&gt;numpy.histogram&lt;/code&gt; only generates the data.</source>
          <target state="translated">应用于数组的NumPy &lt;code&gt;histogram&lt;/code&gt; 函数返回一对向量：数组的直方图和bin边的向量。注意： &lt;code&gt;matplotlib&lt;/code&gt; 也具有构建直方图的功能（在Matlab中称为 &lt;code&gt;hist&lt;/code&gt; ），该功能不同于NumPy中的直方图。主要区别在于 &lt;code&gt;pylab.hist&lt;/code&gt; 自动绘制直方图，而 &lt;code&gt;numpy.histogram&lt;/code&gt; 仅生成数据。</target>
        </trans-unit>
        <trans-unit id="7115851ea78ca88c35b2190db524dfdbfb383870" translate="yes" xml:space="preserve">
          <source>The NumPy C coding conventions are based on Python PEP-0007 by Guido van Rossum with a few added strictures. There are many C coding conventions and it must be emphasized that the primary goal of the NumPy conventions isn&amp;rsquo;t to choose the &amp;lsquo;best&amp;rsquo;, about which there is certain to be disagreement, but to achieve uniformity. Because the NumPy conventions are very close to those in PEP-0007, that PEP is used as a template below with the NumPy additions and variations in the appropriate spots.</source>
          <target state="translated">NumPy C编码约定基于Guido van Rossum的Python PEP-0007，并增加了一些限制。有很多C编码约定，必须强调的是，NumPy约定的主要目标不是选择&amp;ldquo;最佳&amp;rdquo;（肯定会有分歧），而是要实现统一性。由于NumPy约定与PEP-0007中的约定非常接近，因此该PEP在以下用作模板，并在适当位置添加了NumPy并进行了更改。</target>
        </trans-unit>
        <trans-unit id="04034fa7b7a5e94b567d768903257e06b83fadc3" translate="yes" xml:space="preserve">
          <source>The NumPy Project (The Project) is an open source software project affiliated with the 501(c)3 NumFOCUS Foundation. The goal of The Project is to develop open source software for array-based computing in Python, and in particular the &lt;code&gt;numpy&lt;/code&gt; package, along with related software such as &lt;code&gt;f2py&lt;/code&gt; and the NumPy Sphinx extensions. The Software developed by The Project is released under the BSD (or similar) open source license, developed openly and hosted on public GitHub repositories under the &lt;code&gt;numpy&lt;/code&gt; GitHub organization.</source>
          <target state="translated">NumPy项目（该项目）是隶属于501（c）3 NumFOCUS基金会的开源软件项目。该项目的目标是开发用于Python中基于数组的计算的开源软件，尤其是 &lt;code&gt;numpy&lt;/code&gt; 软件包，以及相关软件，例如 &lt;code&gt;f2py&lt;/code&gt; 和NumPy Sphinx扩展。由The Project开发的软件是在BSD（或类似的）开源许可证下发布的，是公开开发的，并托管在 &lt;code&gt;numpy&lt;/code&gt; GitHub组织下的公共GitHub存储库中。</target>
        </trans-unit>
        <trans-unit id="e7fe9a4dc07ec7ee2f30fa5e00a09db0b807ddfc" translate="yes" xml:space="preserve">
          <source>The NumPy community has set a firm goal of improving its documentation. We hold regular documentation meetings on Zoom (dates are announced on the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion mailing list&lt;/a&gt;), and everyone is welcome. Reach out if you have questions or need someone to guide you through your first steps &amp;ndash; we&amp;rsquo;re happy to help. Minutes are taken &lt;a href=&quot;https://hackmd.io/oB_boakvRqKR-_2jRV-Qjg&quot;&gt;on hackmd.io&lt;/a&gt; and stored in the &lt;a href=&quot;https://github.com/numpy/archive&quot;&gt;NumPy Archive repository&lt;/a&gt;.</source>
          <target state="translated">NumPy社区已经设定了改善其文档的坚定目标。我们定期举行有关Zoom的文档会议（日期在&lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion邮件列表&lt;/a&gt;中宣布），欢迎大家。如果您有任何疑问或需要其他人指导您完成第一步，请与我们联系&amp;ndash;我们很乐意为您提供帮助。会议纪要&lt;a href=&quot;https://hackmd.io/oB_boakvRqKR-_2jRV-Qjg&quot;&gt;在hackmd.io上&lt;/a&gt;保存，并存储在&lt;a href=&quot;https://github.com/numpy/archive&quot;&gt;NumPy存档存储库中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="318543629420726d92de226b61b0ea2568472ff7" translate="yes" xml:space="preserve">
          <source>The NumPy library contains multidimensional array and matrix data structures (you&amp;rsquo;ll find more information about this in later sections). It provides &lt;strong&gt;ndarray&lt;/strong&gt;, a homogeneous n-dimensional array object, with methods to efficiently operate on it. NumPy can be used to perform a wide variety of mathematical operations on arrays. It adds powerful data structures to Python that guarantee efficient calculations with arrays and matrices and it supplies an enormous library of high-level mathematical functions that operate on these arrays and matrices.</source>
          <target state="translated">NumPy库包含多维数组和矩阵数据结构（您将在后面的部分中找到有关此信息的更多信息）。它为&lt;strong&gt;ndarray&lt;/strong&gt;（一个均匀的n维数组对象）提供有效地对其进行操作的方法。NumPy可用于对数组执行各种数学运算。它向Python添加了强大的数据结构，以确保使用数组和矩阵进行高效的计算，并且提供了可在这些数组和矩阵上运行的大量高级数学函数库。</target>
        </trans-unit>
        <trans-unit id="22808a8257a77bd3771514110cd88913c8cbfe31" translate="yes" xml:space="preserve">
          <source>The NumPy linear algebra functions rely on BLAS and LAPACK to provide efficient low level implementations of standard linear algebra algorithms. Those libraries may be provided by NumPy itself using C versions of a subset of their reference implementations but, when possible, highly optimized libraries that take advantage of specialized processor functionality are preferred. Examples of such libraries are &lt;a href=&quot;https://www.openblas.net/&quot;&gt;OpenBLAS&lt;/a&gt;, MKL (TM), and ATLAS. Because those libraries are multithreaded and processor dependent, environmental variables and external packages such as &lt;a href=&quot;https://github.com/joblib/threadpoolctl&quot;&gt;threadpoolctl&lt;/a&gt; may be needed to control the number of threads or specify the processor architecture.</source>
          <target state="translated">NumPy线性代数函数依靠BLAS和LAPACK提供标准线性代数算法的有效低层实现。这些库可以由NumPy本身使用其参考实现的子集的C版本提供，但在可能的情况下，最好使用充分利用专用处理器功能的高度优化的库。此类库的示例是&lt;a href=&quot;https://www.openblas.net/&quot;&gt;OpenBLAS&lt;/a&gt;，MKL（TM）和ATLAS。由于这些库是多线程的，并且取决于处理器，因此可能需要环境变量和外部程序包（例如&lt;a href=&quot;https://github.com/joblib/threadpoolctl&quot;&gt;threadpoolctl）&lt;/a&gt;来控制线程数或指定处理器体系结构。</target>
        </trans-unit>
        <trans-unit id="d47a0c6ae88af6350c5a45d963a159c319eddcab" translate="yes" xml:space="preserve">
          <source>The NumPy project welcomes and encourages participation by everyone. We are committed to being a community that everyone enjoys being part of. Although we may not always be able to accommodate each individual&amp;rsquo;s preferences, we try our best to treat everyone kindly.</source>
          <target state="translated">NumPy项目欢迎并鼓励每个人的参与。我们致力于成为每个人都乐于参与的社区。尽管我们不一定总是能够适应每个人的喜好，但我们会尽力对待每个人。</target>
        </trans-unit>
        <trans-unit id="d3df208d2d18d19aa23dcbfeea9ad1c54e2544eb" translate="yes" xml:space="preserve">
          <source>The NumPy source code includes an example of a custom data-type as part of its test suite. The file &lt;code&gt;_rational_tests.c.src&lt;/code&gt; in the source code directory &lt;code&gt;numpy/numpy/core/src/umath/&lt;/code&gt; contains an implementation of a data-type that represents a rational number as the ratio of two 32 bit integers.</source>
          <target state="translated">NumPy源代码在其测试套件中包括一个自定义数据类型的示例。源代码目录 &lt;code&gt;numpy/numpy/core/src/umath/&lt;/code&gt; 中的文件 &lt;code&gt;_rational_tests.c.src&lt;/code&gt; 包含一个数据类型的实现，该数据类型表示有理数为两个32位整数之比。</target>
        </trans-unit>
        <trans-unit id="5abe575872513074969d9820a4d531c3d12a22f7" translate="yes" xml:space="preserve">
          <source>The Pareto distribution must be greater than zero, and is unbounded above. It is also known as the &amp;ldquo;80-20 rule&amp;rdquo;. In this distribution, 80 percent of the weights are in the lowest 20 percent of the range, while the other 20 percent fill the remaining 80 percent of the range.</source>
          <target state="translated">帕累托分布必须大于零，并且在上方无界。它也被称为&amp;ldquo; 80-20规则&amp;rdquo;。在此分布中，80％的权重在范围的最低20％中，而其他20％占其余的80％。</target>
        </trans-unit>
        <trans-unit id="b64969899a77da87dee3d04492ed6838966132f3" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#r3973533a530a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">以意大利经济学家维尔弗雷多&amp;middot;帕累托（Vilfredo Pareto）的名字命名的帕累托分布是一种幂律概率分布，可用于许多现实世界中的问题。在经济学领域之外，通常将其称为Bradford分布。帕累托（Pareto）建立了分布来描述经济中财富的分布。它也已用于保险，网页访问统计，油田规模和许多其他问题，包括Sourceforge &lt;a href=&quot;#r3973533a530a-1&quot; id=&quot;id1&quot;&gt;[1]中&lt;/a&gt;项目的下载频率。它是所谓的&amp;ldquo;胖尾&amp;rdquo;分布之一。</target>
        </trans-unit>
        <trans-unit id="7bc6e3f7c2b1acfa8159e10332ced928c3809746" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#r4338a4b3d731-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">以意大利经济学家维尔弗雷多&amp;middot;帕累托（Vilfredo Pareto）的名字命名的帕累托分布是一种幂律概率分布，可用于许多现实世界中的问题。在经济学领域之外，通常将其称为Bradford分布。帕累托（Pareto）建立了分布来描述经济中财富的分布。它也已用于保险，网页访问统计，油田规模和许多其他问题，包括Sourceforge &lt;a href=&quot;#r4338a4b3d731-1&quot; id=&quot;id1&quot;&gt;[1]中&lt;/a&gt;项目的下载频率。它是所谓的&amp;ldquo;胖尾&amp;rdquo;分布之一。</target>
        </trans-unit>
        <trans-unit id="ed5b998678bc3c838f5d54a5f0beb5816b99470d" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#r8689274e67cd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">以意大利经济学家维尔弗雷多&amp;middot;帕累托（Vilfredo Pareto）的名字命名的帕累托分布是一种幂律概率分布，可用于许多现实世界中的问题。在经济学领域之外，通常将其称为Bradford分布。帕累托（Pareto）建立了分布来描述经济中财富的分布。还发现它可用于保险，网页访问统计，油田规模以及许多其他问题，包括Sourceforge &lt;a href=&quot;#r8689274e67cd-1&quot; id=&quot;id1&quot;&gt;[1]中&lt;/a&gt;项目的下载频率。它是所谓的&amp;ldquo;胖尾&amp;rdquo;分布之一。</target>
        </trans-unit>
        <trans-unit id="2867a07ee69e6406fe64c658305fdda7fb7b8075" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#rc338d9f74bfc-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">以意大利经济学家维尔弗雷多&amp;middot;帕累托（Vilfredo Pareto）的名字命名的帕累托分布是一种幂律概率分布，可用于许多现实世界中的问题。在经济学领域之外，通常将其称为Bradford分布。帕累托（Pareto）建立了分布来描述经济中财富的分布。还发现它可用于保险，网页访问统计，油田规模以及许多其他问题，包括Sourceforge &lt;a href=&quot;#rc338d9f74bfc-1&quot; id=&quot;id1&quot;&gt;[1]中&lt;/a&gt;项目的下载频率。它是所谓的&amp;ldquo;胖尾&amp;rdquo;分布之一。</target>
        </trans-unit>
        <trans-unit id="8aa87161535a17c7b4517b9679a26277a14402b5" translate="yes" xml:space="preserve">
          <source>The Poisson distribution</source>
          <target state="translated">泊松分布</target>
        </trans-unit>
        <trans-unit id="0ebdde94b2528198e1aa6a1394f362ff4a94706c" translate="yes" xml:space="preserve">
          <source>The Poisson distribution is the limit of the binomial distribution for large N.</source>
          <target state="translated">泊松分布是大N时二项分布的极限。</target>
        </trans-unit>
        <trans-unit id="9280ad29766a65718d4060a0ccabd4c148a5c905" translate="yes" xml:space="preserve">
          <source>The Polynomial class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Polynomial类提供标准的Python数值方法'+'，'-'，'*'，'//'，'％'，'divmod'，'**'和'（）'以及属性和 &lt;code&gt;ABCPolyBase&lt;/code&gt; 文档中列出的方法。</target>
        </trans-unit>
        <trans-unit id="ababcd2092c790cd48094defea5bb6fa5036c0d6" translate="yes" xml:space="preserve">
          <source>The Project</source>
          <target state="translated">该项目</target>
        </trans-unit>
        <trans-unit id="9cd0ae31276093703b68264061cf438be92cd228" translate="yes" xml:space="preserve">
          <source>The Project Community consists of all Contributors and Users of the Project. Contributors work on behalf of and are responsible to the larger Project Community and we strive to keep the barrier between Contributors and Users as low as possible.</source>
          <target state="translated">项目社区由项目的所有贡献者和用户组成。贡献者代表项目社区工作并对其负责,我们努力使贡献者和用户之间的障碍尽可能小。</target>
        </trans-unit>
        <trans-unit id="5d50f5379e9d76b5e7242532277a2b9c64fd49c0" translate="yes" xml:space="preserve">
          <source>The Project is developed by a team of distributed developers, called Contributors. Contributors are individuals who have contributed code, documentation, designs or other work to the Project. Anyone can be a Contributor. Contributors can be affiliated with any legal entity or none. Contributors participate in the project by submitting, reviewing and discussing GitHub Pull Requests and Issues and participating in open and public Project discussions on GitHub, mailing lists, and other channels. The foundation of Project participation is openness and transparency.</source>
          <target state="translated">本项目是由一个分布式开发团队开发的,称为贡献者。贡献者是指为项目贡献代码、文档、设计或其他工作的个人。任何人都可以成为贡献者。贡献者可以隶属于任何法律实体,也可以不隶属于任何实体。贡献者通过提交、审查和讨论GitHub上的Pull Request和Issues,以及参与GitHub、邮件列表和其他渠道的公开讨论来参与项目。项目参与的基础是公开和透明。</target>
        </trans-unit>
        <trans-unit id="c1c2647aef99f143f4382e220b44eada277008ef" translate="yes" xml:space="preserve">
          <source>The Project is formally affiliated with the 501(c)3 NumFOCUS Foundation (&lt;a href=&quot;http://numfocus.org&quot;&gt;http://numfocus.org&lt;/a&gt;), which serves as its fiscal sponsor, may hold project trademarks and other intellectual property, helps manage project donations and acts as a parent legal entity. NumFOCUS is the only legal entity that has a formal relationship with the project (see Institutional Partners section below).</source>
          <target state="translated">该项目正式隶属于501（c）3 NumFOCUS基金会（&lt;a href=&quot;http://numfocus.org&quot;&gt;http://numfocus.org&lt;/a&gt;），NumFOCUS基金会是其财政赞助商，可以持有项目商标和其他知识产权，帮助管理项目捐赠并作为母公司法律实体。NumFOCUS是唯一与该项目有正式关系的法律实体（请参阅下面的&amp;ldquo;机构合作伙伴&amp;rdquo;部分）。</target>
        </trans-unit>
        <trans-unit id="3f211023ee392fd3cd9d9691f710a52d06a9bae2" translate="yes" xml:space="preserve">
          <source>The Project will have a Steering Council that consists of Project Contributors who have produced contributions that are substantial in quality and quantity, and sustained over at least one year. The overall role of the Council is to ensure, with input from the Community, the long-term well-being of the project, both technically and as a community.</source>
          <target state="translated">该项目将有一个指导委员会,由项目贡献者组成,这些贡献在质量和数量上都很可观,并且至少持续了一年。理事会的总体作用是在社区的投入下,确保项目在技术上和作为一个社区的长期福祉。</target>
        </trans-unit>
        <trans-unit id="827ba55564ba45b324c36aacf3e17c27674e9dcd" translate="yes" xml:space="preserve">
          <source>The PyArrayInterface structure had no descr member at the end (and therefore no flag ARR_HAS_DESCR)</source>
          <target state="translated">PyArrayInterface结构的最后没有descr成员(因此没有标志ARR_HAS_DESCR)</target>
        </trans-unit>
        <trans-unit id="41d158f9c0cb59631db3742cfa40b5047248d25c" translate="yes" xml:space="preserve">
          <source>The PyArrayInterface structure is defined in &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; as:</source>
          <target state="translated">PyArrayInterface结构在 &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; 中定义为：</target>
        </trans-unit>
        <trans-unit id="e6049ecf431eb4a7049f3f47b3c4c1bf1fc4e575" translate="yes" xml:space="preserve">
          <source>The Python &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-slice&quot;&gt;slice&lt;/a&gt; operator. In ndarrays, slicing can be applied to every axis:</source>
          <target state="translated">Python &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-slice&quot;&gt;slice&lt;/a&gt;运算符。在ndarray中，切片可应用于每个轴：</target>
        </trans-unit>
        <trans-unit id="5f9e4e5af356a67d9cce5fec6bebfc002a3fe5b0" translate="yes" xml:space="preserve">
          <source>The Python exposure supplies two iteration interfaces, one which follows the Python iterator protocol, and another which mirrors the C-style do-while pattern. The native Python approach is better in most cases, but if you need the coordinates or index of an iterator, use the C-style pattern.</source>
          <target state="translated">Python暴露提供了两个迭代接口,一个是遵循Python迭代器协议,另一个是镜像C风格的do-while模式。在大多数情况下,原生的Python方法更好,但如果你需要迭代器的坐标或索引,请使用C风格模式。</target>
        </trans-unit>
        <trans-unit id="52c071d4e6dd56561ca8fc870ab3c5e829454e91" translate="yes" xml:space="preserve">
          <source>The Python function &lt;code&gt;max()&lt;/code&gt; will find the maximum over a one-dimensional array, but it will do so using a slower sequence interface. The reduce method of the maximum ufunc is much faster. Also, the &lt;code&gt;max()&lt;/code&gt; method will not give answers you might expect for arrays with greater than one dimension. The reduce method of minimum also allows you to compute a total minimum over an array.</source>
          <target state="translated">Python函数 &lt;code&gt;max()&lt;/code&gt; 将在一维数组中找到最大值，但是它将使用较慢的序列接口来找到最大值。最大ufunc的reduce方法要快得多。另外， &lt;code&gt;max()&lt;/code&gt; 方法不会提供您对大于一维的数组可能期望的答案。最小值的reduce方法还允许您计算数组的总最小值。</target>
        </trans-unit>
        <trans-unit id="faf8bfa039d6b92e8c05db35a7f948162088fe3f" translate="yes" xml:space="preserve">
          <source>The Python interactive interpreter unfortunately prints out the values of expressions inside the while loop during each iteration of the loop. We have modified the output in the examples using this looping construct in order to be more readable.</source>
          <target state="translated">遗憾的是,Python交互式解释器在每次循环迭代的过程中,都会打印出while循环里面的表达式的值。我们使用这种循环结构修改了示例中的输出,以便使其更易读。</target>
        </trans-unit>
        <trans-unit id="4b9b366242a59401489f5a3a46b627dbab76f505" translate="yes" xml:space="preserve">
          <source>The Python interface that we want is:</source>
          <target state="translated">我们想要的Python接口是。</target>
        </trans-unit>
        <trans-unit id="a4e789fdc99a292c8a541209ecbc17b1d6c5f8c7" translate="yes" xml:space="preserve">
          <source>The Python iterator protocol doesn&amp;rsquo;t have a natural way to query these additional values from the iterator, so we introduce an alternate syntax for iterating with an &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;. This syntax explicitly works with the iterator object itself, so its properties are readily accessible during iteration. With this looping construct, the current value is accessible by indexing into the iterator, and the index being tracked is the property &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;multi_index&lt;/code&gt; depending on what was requested.</source>
          <target state="translated">Python迭代器协议没有从迭代器中查询这些&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;的自然方法，因此我们引入了另一种语法，用于使用nditer进行迭代。该语法显式地与迭代器对象本身一起使用，因此在迭代过程中可以轻松访问其属性。使用这种循环结构，可以通过索引到迭代器中来访问当前值，并且所跟踪的索引是属性 &lt;code&gt;index&lt;/code&gt; 或 &lt;code&gt;multi_index&lt;/code&gt; ,具体取决于所请求的内容。</target>
        </trans-unit>
        <trans-unit id="6867d7144d35416337495ca1b602061770d80f10" translate="yes" xml:space="preserve">
          <source>The Python list representation of the masked array.</source>
          <target state="translated">掩码数组的Python列表表示。</target>
        </trans-unit>
        <trans-unit id="10730a9ceb03252e7c33bf729de07821aa7c70e5" translate="yes" xml:space="preserve">
          <source>The Python object this chunk of memory comes from. Needed so that memory can be accounted for properly.</source>
          <target state="translated">这块内存来自的 Python 对象。需要,这样才能正确计算内存。</target>
        </trans-unit>
        <trans-unit id="0d4a1c83a85c3f9ef90edda93dbe3641642446d4" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator with a number of methods that are similar to the ones available in &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Python stdlib模块&amp;ldquo;随机&amp;rdquo;还包含Mersenne Twister伪随机数生成器，该生成器具有许多与&lt;a href=&quot;#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; 中&lt;/a&gt;可用的方法相似的方法。除了对NumPy有所了解之外，&lt;a href=&quot;#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;还具有以下优点：它提供了大量的概率分布供您选择。</target>
        </trans-unit>
        <trans-unit id="8a0585dac865895f74c0e37d281119c6e2073a73" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator with a number of methods that are similar to the ones available in &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Python stdlib模块&amp;ldquo;随机&amp;rdquo;还包含Mersenne Twister伪随机数生成器，该生成器具有许多与&lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; 中&lt;/a&gt;可用的方法相似的方法。除了具有NumPy感知能力外，&lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;还具有以下优点：它提供了更多的概率分布供您选择。</target>
        </trans-unit>
        <trans-unit id="e2bba830daa553cb7faa782d38dcb55b1552bd1f" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator.</source>
          <target state="translated">Python stdlib模块&amp;ldquo;随机&amp;rdquo;还包含Mersenne Twister伪随机数生成器。</target>
        </trans-unit>
        <trans-unit id="d16bb9351563ad26c9ac5328e3a25381d78f799b" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; contains pseudo-random number generator with a number of methods that are similar to the ones available in &lt;code&gt;Generator&lt;/code&gt;. It uses Mersenne Twister, and this bit generator can be accessed using &lt;code&gt;MT19937&lt;/code&gt;. &lt;code&gt;Generator&lt;/code&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Python stdlib模块&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt;包含伪随机数生成器，其中的许多方法类似于 &lt;code&gt;Generator&lt;/code&gt; 中可用的方法。它使用Mersenne Twister，并且可以使用 &lt;code&gt;MT19937&lt;/code&gt; 访问此位生成器。 &lt;code&gt;Generator&lt;/code&gt; 除了具有NumPy感知能力外，还具有提供大量概率分布可供选择的优势。</target>
        </trans-unit>
        <trans-unit id="da363cfdc7ce6e2caf650d00ffad698f370feca3" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &lt;a href=&quot;generated/numpy.random.random#numpy.random.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; contains pseudo-random number generator with a number of methods that are similar to the ones available in &lt;code&gt;Generator&lt;/code&gt;. It uses Mersenne Twister, and this bit generator can be accessed using &lt;code&gt;MT19937&lt;/code&gt;. &lt;code&gt;Generator&lt;/code&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Python stdlib模块&lt;a href=&quot;generated/numpy.random.random#numpy.random.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt;包含伪随机数生成器，其中的许多方法类似于 &lt;code&gt;Generator&lt;/code&gt; 中可用的方法。它使用Mersenne Twister，并且可以使用 &lt;code&gt;MT19937&lt;/code&gt; 访问此位生成器。 &lt;code&gt;Generator&lt;/code&gt; 除了具有NumPy感知能力外，还具有提供大量概率分布可供选择的优势。</target>
        </trans-unit>
        <trans-unit id="bbfe8c34ab4f057b17acc33f18a11bfdb2e17b46" translate="yes" xml:space="preserve">
          <source>The Python type of the ndarray is &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. In C, every ndarray is a pointer to a &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure. The ob_type member of this structure contains a pointer to the &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; typeobject.</source>
          <target state="translated">ndarray的Python类型是&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;。在C语言中，每个ndarray都是指向&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;结构的指针。此结构的ob_type成员包含一个指向&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; 类型&lt;/a&gt;对象的指针。</target>
        </trans-unit>
        <trans-unit id="92e614f1f8b5e40429cf0717c65db8d5a132db4d" translate="yes" xml:space="preserve">
          <source>The Rayleigh distribution would arise, for example, if the East and North components of the wind velocity had identical zero-mean Gaussian distributions. Then the wind speed would have a Rayleigh distribution.</source>
          <target state="translated">例如,如果风速的东、北两部分具有相同的零均值高斯分布,就会出现雷利分布。那么风速就会有雷利分布。</target>
        </trans-unit>
        <trans-unit id="d73f8fe753523f4db33185ee7a9f4cc2e7b4d46f" translate="yes" xml:space="preserve">
          <source>The SciPy Code of Conduct</source>
          <target state="translated">SciPy行为守则</target>
        </trans-unit>
        <trans-unit id="43e766ac17c08bb4c8b9b072ff682fb439dd2765" translate="yes" xml:space="preserve">
          <source>The SciPy library also contains a &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt;&lt;code&gt;linalg&lt;/code&gt;&lt;/a&gt; submodule, and there is overlap in the functionality provided by the SciPy and NumPy submodules. SciPy contains functions not found in &lt;a href=&quot;#module-numpy.linalg&quot;&gt;&lt;code&gt;numpy.linalg&lt;/code&gt;&lt;/a&gt;, such as functions related to LU decomposition and the Schur decomposition, multiple ways of calculating the pseudoinverse, and matrix transcendentals such as the matrix logarithm. Some functions that exist in both have augmented functionality in &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt;&lt;code&gt;scipy.linalg&lt;/code&gt;&lt;/a&gt;. For example, &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eig.html#scipy.linalg.eig&quot;&gt;&lt;code&gt;scipy.linalg.eig&lt;/code&gt;&lt;/a&gt; can take a second matrix argument for solving generalized eigenvalue problems. Some functions in NumPy, however, have more flexible broadcasting options. For example, &lt;a href=&quot;generated/numpy.linalg.solve#numpy.linalg.solve&quot;&gt;&lt;code&gt;numpy.linalg.solve&lt;/code&gt;&lt;/a&gt; can handle &amp;ldquo;stacked&amp;rdquo; arrays, while &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve.html#scipy.linalg.solve&quot;&gt;&lt;code&gt;scipy.linalg.solve&lt;/code&gt;&lt;/a&gt; accepts only a single square array as its first argument.</source>
          <target state="translated">SciPy库还包含一个&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt; &lt;code&gt;linalg&lt;/code&gt; &lt;/a&gt;子模块，并且SciPy和NumPy子模块提供的功能存在重叠。 SciPy包含&lt;a href=&quot;#module-numpy.linalg&quot;&gt; &lt;code&gt;numpy.linalg&lt;/code&gt; 中&lt;/a&gt;找不到的函数，例如与LU分解和Schur分解有关的函数，多种计算伪逆的方法以及矩阵先验（例如矩阵对数）。两者中都存在的某些功能在&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt; &lt;code&gt;scipy.linalg&lt;/code&gt; 中&lt;/a&gt;具有增强的功能。例如，&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eig.html#scipy.linalg.eig&quot;&gt; &lt;code&gt;scipy.linalg.eig&lt;/code&gt; &lt;/a&gt;可以采用第二个矩阵参数来解决广义特征值问题。但是，NumPy中的某些功能具有更灵活的广播选项。例如，&lt;a href=&quot;generated/numpy.linalg.solve#numpy.linalg.solve&quot;&gt; &lt;code&gt;numpy.linalg.solve&lt;/code&gt; &lt;/a&gt;可以处理&amp;ldquo;堆栈&amp;rdquo;数组，而&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve.html#scipy.linalg.solve&quot;&gt; &lt;code&gt;scipy.linalg.solve&lt;/code&gt; &lt;/a&gt;仅接受一个正方形数组作为其第一个参数。</target>
        </trans-unit>
        <trans-unit id="6b5319e40dafd8caa389916efd26acade11e750d" translate="yes" xml:space="preserve">
          <source>The SciPy module &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/fft.html#module-scipy.fft&quot;&gt;&lt;code&gt;scipy.fft&lt;/code&gt;&lt;/a&gt; is a more comprehensive superset of &lt;code&gt;numpy.fft&lt;/code&gt;, which includes only a basic set of routines.</source>
          <target state="translated">SciPy模块&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/fft.html#module-scipy.fft&quot;&gt; &lt;code&gt;scipy.fft&lt;/code&gt; &lt;/a&gt;是numpy.fft的更全面的超集，其中仅 &lt;code&gt;numpy.fft&lt;/code&gt; 基本例程。</target>
        </trans-unit>
        <trans-unit id="0175f443d47358199cf2723ff7e49526482ab828" translate="yes" xml:space="preserve">
          <source>The Simple Wrapper and Interface Generator (or &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;) is a powerful tool for generating wrapper code for interfacing to a wide variety of scripting languages. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; can parse header files, and using only the code prototypes, create an interface to the target language. But &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; is not omnipotent. For example, it cannot know from the prototype:</source>
          <target state="translated">Simple Wrapper和Interface Generator（或&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;）是一个强大的工具，用于生成用于与各种脚本语言接口的包装器代码。&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;可以解析头文件，并且仅使用代码原型创建目标语言的接口。但是&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;并不是万能的。例如，它不能从原型中知道：</target>
        </trans-unit>
        <trans-unit id="50fd73730ba7e10c720fa72fd00d9f7e0810994f" translate="yes" xml:space="preserve">
          <source>The Steering Council and its Members play a special role in certain situations. In particular, the Council may, if necessary:</source>
          <target state="translated">指导委员会及其成员在某些情况下发挥特殊作用。特别是,必要时,理事会可以:</target>
        </trans-unit>
        <trans-unit id="fd611f012e4b731c3416db83b8b9fa4821f6de96" translate="yes" xml:space="preserve">
          <source>The Steering Council are the primary leadership for the project. No outside institution, individual or legal entity has the ability to own, control, usurp or influence the project other than by participating in the Project as Contributors and Council Members. However, because institutions can be an important funding mechanism for the project, it is important to formally acknowledge institutional participation in the project. These are Institutional Partners.</source>
          <target state="translated">指导委员会是项目的主要领导。除了作为捐助方和理事会成员参与项目外,任何外部机构、个人或法律实体都没有能力拥有、控制、篡夺或影响项目。然而,由于机构可以成为项目的重要筹资机制,因此正式承认机构参与项目是很重要的。这些机构是机构伙伴。</target>
        </trans-unit>
        <trans-unit id="3486112e5f71acaa9b7cc7fff52d1dbfa7f50dd3" translate="yes" xml:space="preserve">
          <source>The Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where the last index is the power of &lt;code&gt;x&lt;/code&gt;. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">范德蒙矩阵。返回矩阵的形状为 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; ，其中最后一个索引是 &lt;code&gt;x&lt;/code&gt; 的幂。dtype将与转换后的 &lt;code&gt;x&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="39a7c567f58b9f21ca516451a55bb90e053dd395" translate="yes" xml:space="preserve">
          <source>The Weibull (or Type III asymptotic extreme value distribution for smallest values, SEV Type III, or Rosin-Rammler distribution) is one of a class of Generalized Extreme Value (GEV) distributions used in modeling extreme value problems. This class includes the Gumbel and Frechet distributions.</source>
          <target state="translated">Weibull(或最小值的III型渐进极值分布,SEV III型,或Rosin-Rammler分布)是一类用于极值问题建模的广义极值(GEV)分布之一。这类分布包括Gumbel分布和Frechet分布。</target>
        </trans-unit>
        <trans-unit id="201b34b560ffa9f638b13b95cb2b860322d162bb" translate="yes" xml:space="preserve">
          <source>The Zipf distribution (also known as the zeta distribution) is a continuous probability distribution that satisfies Zipf&amp;rsquo;s law: the frequency of an item is inversely proportional to its rank in a frequency table.</source>
          <target state="translated">Zipf分布（也称为zeta分布）是满足Zipf定律的连续概率分布：某项的频率与它在频率表中的排名成反比。</target>
        </trans-unit>
        <trans-unit id="9f96ae0b2c3d21dc0c18c679782e710a2d562c21" translate="yes" xml:space="preserve">
          <source>The __array_finalize__ method</source>
          <target state="translated">__array_finalize__方法。</target>
        </trans-unit>
        <trans-unit id="b8acfe985a2bfa5e5957d0281e0418889b56a0c2" translate="yes" xml:space="preserve">
          <source>The __array_priority__ attribute</source>
          <target state="translated">数组的__array_priority__属性。</target>
        </trans-unit>
        <trans-unit id="8c8638dacd7dbc859e55b29c8e0ee5d2ee1f9573" translate="yes" xml:space="preserve">
          <source>The __array_wrap__ method</source>
          <target state="translated">__array_wrap__方法</target>
        </trans-unit>
        <trans-unit id="cb048510e93bd94f0172757e215cb9cb29cef573" translate="yes" xml:space="preserve">
          <source>The ability to be used as a context manager is new in NumPy v1.11.0.</source>
          <target state="translated">NumPy v1.11.0中新增了作为上下文管理器使用的功能。</target>
        </trans-unit>
        <trans-unit id="10ff963859461b5262a67238fd0cc7b697172b26" translate="yes" xml:space="preserve">
          <source>The above does not hold for in-place operators, for which &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; never returns &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt;. Hence, &lt;code&gt;arr += obj&lt;/code&gt; would always lead to a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. This is because for arrays in-place operations cannot generically be replaced by a simple reverse operation. (For instance, by default, &lt;code&gt;arr += obj&lt;/code&gt; would be translated to &lt;code&gt;arr =
arr + obj&lt;/code&gt;, i.e., &lt;code&gt;arr&lt;/code&gt; would be replaced, contrary to what is expected for in-place array operations.)</source>
          <target state="translated">上面的内容不适用于就地运算符，对于这些运算符，&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;永远不会返回&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt;。因此， &lt;code&gt;arr += obj&lt;/code&gt; 总是会导致&lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;。这是因为对于数组，就地操作通常不能用简单的反向操作代替。（例如，默认情况下， &lt;code&gt;arr += obj&lt;/code&gt; 将被转换为 &lt;code&gt;arr = arr + obj&lt;/code&gt; ，即，将 &lt;code&gt;arr&lt;/code&gt; 替换，这与就地数组操作所期望的相反。）</target>
        </trans-unit>
        <trans-unit id="68e86910bcee8988f5fee730ecb24162fd22e6a7" translate="yes" xml:space="preserve">
          <source>The above equation is not symmetric in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, so that &lt;code&gt;allclose(a, b)&lt;/code&gt; might be different from &lt;code&gt;allclose(b, a)&lt;/code&gt; in some rare cases.</source>
          <target state="translated">上面的方程在 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 中不是对称的，因此 &lt;code&gt;allclose(a, b)&lt;/code&gt; &lt;code&gt;allclose(b, a)&lt;/code&gt; 在某些罕见情况下可能与allclose（b，a）不同。</target>
        </trans-unit>
        <trans-unit id="6185045f653324c861d3553f34d55db24911888b" translate="yes" xml:space="preserve">
          <source>The above is &lt;strong&gt;not&lt;/strong&gt; true for advanced indexing.</source>
          <target state="translated">对于高级索引，以上内容&lt;strong&gt;不&lt;/strong&gt;适用。</target>
        </trans-unit>
        <trans-unit id="21db79b1f2f5936ea0ef3cfbbfc9697c308c56be" translate="yes" xml:space="preserve">
          <source>The above rules may be clearer in the following template source example:</source>
          <target state="translated">在下面的模板源例中,上述规则可能更加清晰。</target>
        </trans-unit>
        <trans-unit id="bbd30ffed27aefb02b7cc5cbecba164ede0884a8" translate="yes" xml:space="preserve">
          <source>The absolute tolerance parameter (see Notes).</source>
          <target state="translated">绝对公差参数(见注释)。</target>
        </trans-unit>
        <trans-unit id="b410151dc56a82d87375b78c87d1aad1438a967a" translate="yes" xml:space="preserve">
          <source>The absolute values of &lt;code&gt;x&lt;/code&gt;, the returned values are always floats. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的绝对值，返回值始终是浮点型的。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="a714cd42c4750db7daf108e375247bf95502ae46" translate="yes" xml:space="preserve">
          <source>The accumulate function is very similar to the reduce function in that the output and the second input both point to the output. The difference is that the second input points to memory one stride behind the current output pointer. Thus, the operation performed is</source>
          <target state="translated">累积函数与reduce函数非常相似,输出和第二个输入都指向输出。不同的是,第二个输入指向的内存比当前输出指针晚一个步长。因此,执行的操作是</target>
        </trans-unit>
        <trans-unit id="09fde86411dc88385ee0c9001b20e47aa778341c" translate="yes" xml:space="preserve">
          <source>The accumulated values. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">累计值。如果提供 &lt;code&gt;out&lt;/code&gt; ，则 &lt;code&gt;r&lt;/code&gt; 是对 &lt;code&gt;out&lt;/code&gt; 的引用。</target>
        </trans-unit>
        <trans-unit id="ea47ba00873e187022bea737541efbc8a18ba099" translate="yes" xml:space="preserve">
          <source>The actual object to check.</source>
          <target state="translated">要检查的实际对象。</target>
        </trans-unit>
        <trans-unit id="2c2156efeae8cdcc13e079cd68ed8ee62442ae55" translate="yes" xml:space="preserve">
          <source>The actual testing takes place with a Python script named:</source>
          <target state="translated">实际测试是通过一个名为Python的脚本进行的。</target>
        </trans-unit>
        <trans-unit id="b137bb987f3be59004e7fe6c03cebc2b50e503bc" translate="yes" xml:space="preserve">
          <source>The addition of an &lt;code&gt;axis&lt;/code&gt; keyword argument to methods such as &lt;a href=&quot;generated/numpy.random.generator.choice#numpy.random.Generator.choice&quot;&gt;&lt;code&gt;Generator.choice&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt;&lt;code&gt;Generator.permutation&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt;&lt;code&gt;Generator.shuffle&lt;/code&gt;&lt;/a&gt; improves support for sampling from and shuffling multi-dimensional arrays.</source>
          <target state="translated">在诸如&lt;a href=&quot;generated/numpy.random.generator.choice#numpy.random.Generator.choice&quot;&gt; &lt;code&gt;Generator.choice&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt; &lt;code&gt;Generator.permutation&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt; &lt;code&gt;Generator.shuffle&lt;/code&gt; 之类的&lt;/a&gt;方法中添加 &lt;code&gt;axis&lt;/code&gt; 关键字参数可以改善对多维数组采样和改组的支持。</target>
        </trans-unit>
        <trans-unit id="e611ef52ce3f87e2cae1cb595f38cf187d2711d5" translate="yes" xml:space="preserve">
          <source>The advanced indexes are all next to each other. For example &lt;code&gt;x[..., arr1, arr2, :]&lt;/code&gt; but &lt;em&gt;not&lt;/em&gt;&lt;code&gt;x[arr1, :, 1]&lt;/code&gt; since &lt;code&gt;1&lt;/code&gt; is an advanced index in this regard.</source>
          <target state="translated">高级索引彼此相邻。例如 &lt;code&gt;x[..., arr1, arr2, :]&lt;/code&gt; 但&lt;em&gt;不是&lt;/em&gt; &lt;code&gt;x[arr1, :, 1]&lt;/code&gt; 因为 &lt;code&gt;1&lt;/code&gt; 在这方面是高级索引。</target>
        </trans-unit>
        <trans-unit id="8562f49387be48296682139d8c90e489ffc329b9" translate="yes" xml:space="preserve">
          <source>The advanced indexes are separated by a slice, &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#Ellipsis&quot;&gt;&lt;code&gt;Ellipsis&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;. For example &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt;.</source>
          <target state="translated">先进的指标是通过切片，分离&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#Ellipsis&quot;&gt; &lt;code&gt;Ellipsis&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;。例如 &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31c1e1991e0db334efbc077fcf4425ba78851bf7" translate="yes" xml:space="preserve">
          <source>The advanced indexes are separated by a slice, &lt;code&gt;Ellipsis&lt;/code&gt; or &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;. For example &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt;.</source>
          <target state="translated">先进的指标是通过切片，分离 &lt;code&gt;Ellipsis&lt;/code&gt; 或&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;。例如 &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0943937a225e08eb4e31b510a59e3603b58c132" translate="yes" xml:space="preserve">
          <source>The advantage of the hand-generated wrapper is that you have complete control over how the C-library gets used and called which can lead to a lean and tight interface with minimal over-head. The disadvantage is that you have to write, debug, and maintain C-code, although most of it can be adapted using the time-honored technique of &amp;ldquo;cutting-pasting-and-modifying&amp;rdquo; from other extension modules. Because, the procedure of calling out to additional C-code is fairly regimented, code-generation procedures have been developed to make this process easier. One of these code-generation techniques is distributed with NumPy and allows easy integration with Fortran and (simple) C code. This package, f2py, will be covered briefly in the next section.</source>
          <target state="translated">手工生成的包装器的优点是，您可以完全控制C库的使用和调用方式，从而可以以最小的开销实现精益和紧密的界面。缺点是您必须编写，调试和维护C代码，尽管大多数代码都可以使用来自其他扩展模块的&amp;ldquo;剪切，粘贴和修改&amp;rdquo;的悠久技术来进行修改。因为调用附加C代码的过程相当合理，所以已经开发了代码生成过程来简化此过程。这些代码生成技术之一随NumPy一起分发，并允许与Fortran和（简单）C代码轻松集成。下一部分将简要介绍该软件包f2py。</target>
        </trans-unit>
        <trans-unit id="d764668c927e5f32ce22801332fbd537f1d04076" translate="yes" xml:space="preserve">
          <source>The advantage of this creation function is that one can guarantee the number of elements and the starting and end point, which arange() generally will not do for arbitrary start, stop, and step values.</source>
          <target state="translated">这个创建函数的优点是可以保证元素的数量和起止点,一般来说,range()对于任意的开始、停止和步长值是做不到的。</target>
        </trans-unit>
        <trans-unit id="0930947f097a3d759f1db1653e4d8d773b593cd3" translate="yes" xml:space="preserve">
          <source>The advantage of this version of reduce compared to the normal ufunc.reduce is that it makes use of the &lt;a href=&quot;#broadcasting-rules&quot;&gt;broadcasting rules&lt;/a&gt; in order to avoid creating an argument array the size of the output times the number of vectors.</source>
          <target state="translated">与普通的ufunc.reduce相比，该版本的reduce的优点在于，它利用&lt;a href=&quot;#broadcasting-rules&quot;&gt;广播规则&lt;/a&gt;来避免创建一个参数数组，该参数数组的大小乘以输出的数量乘以向量的数量。</target>
        </trans-unit>
        <trans-unit id="51620b35cf3af304da0134bf0e98ad6e2d38905c" translate="yes" xml:space="preserve">
          <source>The advantage of this version of reduce compared to the normal ufunc.reduce is that it makes use of the &lt;a href=&quot;tentative_numpy_tutorial#head-c43f3f81719d84f09ae2b33a22eaf50b26333db8&quot;&gt;Broadcasting Rules&lt;/a&gt; in order to avoid creating an argument array the size of the output times the number of vectors.</source>
          <target state="translated">与普通的ufunc.reduce相比，该版本的reduce的优点在于，它利用&lt;a href=&quot;tentative_numpy_tutorial#head-c43f3f81719d84f09ae2b33a22eaf50b26333db8&quot;&gt;广播规则&lt;/a&gt;来避免创建一个参数数组，该参数数组的大小乘以输出的数量乘以向量的数量。</target>
        </trans-unit>
        <trans-unit id="cbeaf56d095a4acc2c96fd5080608f5dcf659b8a" translate="yes" xml:space="preserve">
          <source>The advantages over random generation include tools to replay and share failures without requiring a fixed seed, reporting &lt;em&gt;minimal&lt;/em&gt; examples for each failure, and better-than-naive-random techniques for triggering bugs.</source>
          <target state="translated">与随机生成相比，其优势包括无需固定种子即可重播和共享故障的工具，报告每个故障的&lt;em&gt;最少&lt;/em&gt;示例以及触发漏洞的优于天真的随机技术。</target>
        </trans-unit>
        <trans-unit id="e14666a8704d081387416d669f25517240f5f545" translate="yes" xml:space="preserve">
          <source>The aim of this document is to describe how to add new tools to SciPy.</source>
          <target state="translated">本文档的目的是描述如何向SciPy添加新工具。</target>
        </trans-unit>
        <trans-unit id="ddbe83e4c507cabc5c6e4f89a6b5af846c612df5" translate="yes" xml:space="preserve">
          <source>The algorithm is carefully designed to eliminate a number of possible ways to collide. For example, if one only does one level of spawning, it is guaranteed that all states will be unique. But it&amp;rsquo;s easier to estimate the naive upper bound on a napkin and take comfort knowing that the probability is actually lower.</source>
          <target state="translated">该算法经过精心设计，消除了多种可能的碰撞方式。例如，如果仅执行一个级别的生成，则可以保证所有状态都是唯一的。但是，更容易估计餐巾纸上的天真上限，并知道该概率实际上较低，这会让您感到宽慰。</target>
        </trans-unit>
        <trans-unit id="31b40688fb93dbcbc32e9b43e4ccf1abfa448a2d" translate="yes" xml:space="preserve">
          <source>The algorithm relies on computing the eigenvalues of the companion matrix &lt;a href=&quot;#r01a8f58ef25b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">该算法依赖于计算伴随矩阵的特征值&lt;a href=&quot;#r01a8f58ef25b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ddd22305ce6ff69cc69c0e35a34dfdaaddbe6b6d" translate="yes" xml:space="preserve">
          <source>The algorithm works by first finding a &amp;ldquo;running dimension&amp;rdquo;, along which the blocks will be extracted. Given an array of dimensions &lt;code&gt;(d1, d2, ..., dn)&lt;/code&gt;, e.g. if &lt;code&gt;buf_size&lt;/code&gt; is smaller than &lt;code&gt;d1&lt;/code&gt;, the first dimension will be used. If, on the other hand, &lt;code&gt;d1 &amp;lt; buf_size &amp;lt; d1*d2&lt;/code&gt; the second dimension will be used, and so on. Blocks are extracted along this dimension, and when the last block is returned the process continues from the next dimension, until all elements have been read.</source>
          <target state="translated">该算法通过首先找到一个&amp;ldquo;运行维&amp;rdquo;来工作，沿着该维将提取块。给定维度数组 &lt;code&gt;(d1, d2, ..., dn)&lt;/code&gt; ，例如，如果 &lt;code&gt;buf_size&lt;/code&gt; 小于 &lt;code&gt;d1&lt;/code&gt; ，则将使用第一个维度。另一方面，如果 &lt;code&gt;d1 &amp;lt; buf_size &amp;lt; d1*d2&lt;/code&gt; ，则将使用第二维，依此类推。沿该维度提取块，并在返回最后一个块时，过程将从下一个维度继续进行，直到已读取所有元素。</target>
        </trans-unit>
        <trans-unit id="bddd09a9de7b4e7a6ce50c8c2ab936314f5f7ae0" translate="yes" xml:space="preserve">
          <source>The angle of the ray intersecting the unit circle at the given &lt;code&gt;x&lt;/code&gt;-coordinate in radians [0, pi]. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">在给定的 &lt;code&gt;x&lt;/code&gt; 坐标（弧度[0，pi]）下，射线与单位圆相交的角度。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="a13da23a8343744c8c54019aa364c899333968f0" translate="yes" xml:space="preserve">
          <source>The anti-diagonal can be filled by reversing the order of elements using either &lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt;&lt;code&gt;numpy.flipud&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt;&lt;code&gt;numpy.fliplr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt; &lt;code&gt;numpy.flipud&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt; &lt;code&gt;numpy.fliplr&lt;/code&gt; &lt;/a&gt;反转元素的顺序来填充反对角线。</target>
        </trans-unit>
        <trans-unit id="900a13fc7d937db8f345df515885761fbb0acd80" translate="yes" xml:space="preserve">
          <source>The anti-diagonal can be obtained by reversing the order of elements using either &lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt;&lt;code&gt;numpy.flipud&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt;&lt;code&gt;numpy.fliplr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以通过使用&lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt; &lt;code&gt;numpy.flipud&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt; &lt;code&gt;numpy.fliplr&lt;/code&gt; &lt;/a&gt;反转元素的顺序来获得反对角线。</target>
        </trans-unit>
        <trans-unit id="bdd6673496c6fd17d43bfb63694d67b1a23e7074" translate="yes" xml:space="preserve">
          <source>The approximate decimal resolution of this type, i.e., &lt;code&gt;10**-precision&lt;/code&gt;.</source>
          <target state="translated">此类型的近似十进制分辨率，即 &lt;code&gt;10**-precision&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6b2d49779da2fb225e5136c9ad3c68e119d3fee" translate="yes" xml:space="preserve">
          <source>The approximate number of decimal digits to which this kind of float is precise.</source>
          <target state="translated">这类浮点数精确到小数点后的约数。</target>
        </trans-unit>
        <trans-unit id="8617d617458fa70c05d4242aac245212778759db" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;norm&lt;/code&gt; indicates which direction of the pair of direct/inverse transforms is scaled and with what normalization factor. The default normalization (&lt;code&gt;&quot;backward&quot;&lt;/code&gt;) has the direct (forward) transforms unscaled and the inverse (backward) transforms scaled by</source>
          <target state="translated">参数 &lt;code&gt;norm&lt;/code&gt; 指示成对的正向/逆向变换的哪个方向以及哪个归一化因子。默认规范化（ &lt;code&gt;&quot;backward&quot;&lt;/code&gt; ）具有未缩放的直接（正向）变换，而具有</target>
        </trans-unit>
        <trans-unit id="179dbf39b5fae7c06c4d27f6dfe6017b20eda9b8" translate="yes" xml:space="preserve">
          <source>The argument is considered as a return variable. It is appended to the &lt;code&gt;&amp;lt;returned variables&amp;gt;&lt;/code&gt; list. Using &lt;code&gt;intent(out)&lt;/code&gt; sets &lt;code&gt;intent(hide)&lt;/code&gt; automatically, unless also &lt;code&gt;intent(in)&lt;/code&gt; or &lt;code&gt;intent(inout)&lt;/code&gt; were used.</source>
          <target state="translated">该参数被视为返回变量。它被附加到 &lt;code&gt;&amp;lt;returned variables&amp;gt;&lt;/code&gt; 列表中。使用 &lt;code&gt;intent(out)&lt;/code&gt; 会自动设置 &lt;code&gt;intent(hide)&lt;/code&gt; ，除非也使用了 &lt;code&gt;intent(in)&lt;/code&gt; 或 &lt;code&gt;intent(inout)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c118204e070c804541b682daff7d70c7213a6696" translate="yes" xml:space="preserve">
          <source>The argument is considered as an input-only argument. It means that the value of the argument is passed to Fortran/C function and that function is expected not to change the value of an argument.</source>
          <target state="translated">该参数被认为是一个只输入的参数,这意味着参数的值被传递给Fortran/C函数,而该函数不会改变参数的值。这意味着参数的值被传递给Fortran/C函数,并且该函数预计不会改变参数的值。</target>
        </trans-unit>
        <trans-unit id="7586639cfc35e105e2ea737d69664cf533fb71d1" translate="yes" xml:space="preserve">
          <source>The argument is considered as an input/output or &lt;em&gt;in situ&lt;/em&gt; output argument. &lt;code&gt;intent(inout)&lt;/code&gt; arguments can be only &amp;ldquo;contiguous&amp;rdquo; NumPy arrays with proper type and size. Here &amp;ldquo;contiguous&amp;rdquo; can be either in Fortran or C sense. The latter one coincides with the contiguous concept used in NumPy and is effective only if &lt;code&gt;intent(c)&lt;/code&gt; is used. Fortran contiguity is assumed by default.</source>
          <target state="translated">该自变量被视为输入/输出或&lt;em&gt;原位&lt;/em&gt;输出自变量。 &lt;code&gt;intent(inout)&lt;/code&gt; 参数只能是具有适当类型和大小的&amp;ldquo;连续&amp;rdquo; NumPy数组。在此，&amp;ldquo;连续&amp;rdquo;可以是Fortran或C形式。后者与NumPy中使用的连续概念相吻合，并且仅在使用 &lt;code&gt;intent(c)&lt;/code&gt; 时有效。默认情况下，假定Fortran连续性。</target>
        </trans-unit>
        <trans-unit id="958b7637686a26352441daf916242ddf2818e972" translate="yes" xml:space="preserve">
          <source>The argument is considered as an input/output or &lt;em&gt;in situ&lt;/em&gt; output argument. &lt;code&gt;intent(inplace)&lt;/code&gt; arguments must be NumPy arrays with proper size. If the type of an array is not &amp;ldquo;proper&amp;rdquo; or the array is non-contiguous then the array will be changed in-place to fix the type and make it contiguous.</source>
          <target state="translated">该自变量被视为输入/输出或&lt;em&gt;原位&lt;/em&gt;输出自变量。 &lt;code&gt;intent(inplace)&lt;/code&gt; 参数必须是具有适当大小的NumPy数组。如果数组的类型不正确，或者数组不连续，则将就地更改数组以修复该类型并使其连续。</target>
        </trans-unit>
        <trans-unit id="f19b8026a1e189b122954edffa090fdbeb3a72f0" translate="yes" xml:space="preserve">
          <source>The argument is removed from the list of required or optional arguments. Typically &lt;code&gt;intent(hide)&lt;/code&gt; is used with &lt;code&gt;intent(out)&lt;/code&gt; or when &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; completely determines the value of the argument like in the following example:</source>
          <target state="translated">该自变量将从必选或可选自变量列表中删除。通常， &lt;code&gt;intent(hide)&lt;/code&gt; 与 &lt;code&gt;intent(out)&lt;/code&gt; 一起使用，或者当 &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; 完全确定参数的值时，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="898b40f4d53206c78d6c1d07150f357243064d8d" translate="yes" xml:space="preserve">
          <source>The argument is treated as a C scalar or C array argument. In the case of a scalar argument, its value is passed to C function as a C scalar argument (recall that Fortran scalar arguments are actually C pointer arguments). In the case of an array argument, the wrapper function is assumed to treat multidimensional arrays as C-contiguous arrays.</source>
          <target state="translated">该参数被当作C标量或C数组参数处理。如果是标量参数,它的值作为C标量参数传递给C函数(请记住Fortran标量参数实际上是C指针参数)。在数组参数的情况下,包装函数被假定为将多维数组作为C-连续数组处理。</target>
        </trans-unit>
        <trans-unit id="f859808cd7ae59bcb9315c9be074383ed18866fa" translate="yes" xml:space="preserve">
          <source>The argument is treated as a junk of memory. No Fortran nor C contiguity checks are carried out. Using &lt;code&gt;intent(cache)&lt;/code&gt; makes sense only for array arguments, also in connection with &lt;code&gt;intent(hide)&lt;/code&gt; or &lt;code&gt;optional&lt;/code&gt; attributes.</source>
          <target state="translated">该参数被视为内存的垃圾。不执行Fortran或C连续性检查。使用 &lt;code&gt;intent(cache)&lt;/code&gt; 仅对数组参数有意义，也与 &lt;code&gt;intent(hide)&lt;/code&gt; 或 &lt;code&gt;optional&lt;/code&gt; 属性有关。</target>
        </trans-unit>
        <trans-unit id="0fe8c5bbb5b2bd70ddad0ccf0217bddc268f6835" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;ngood&lt;/code&gt; and &lt;code&gt;nbad&lt;/code&gt; each must be less than &lt;code&gt;10**9&lt;/code&gt;. For extremely large arguments, the algorithm that is used to compute the samples &lt;a href=&quot;#r688e4aa3bfc3-4&quot; id=&quot;id1&quot;&gt;[4]&lt;/a&gt; breaks down because of loss of precision in floating point calculations. For such large values, if &lt;code&gt;nsample&lt;/code&gt; is not also large, the distribution can be approximated with the binomial distribution, &lt;code&gt;binomial(n=nsample, p=ngood/(ngood + nbad))&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;ngood&lt;/code&gt; 和 &lt;code&gt;nbad&lt;/code&gt; 都必须小于 &lt;code&gt;10**9&lt;/code&gt; 。对于极大的论点，由于浮点计算的精度损失，用于计算样本&lt;a href=&quot;#r688e4aa3bfc3-4&quot; id=&quot;id1&quot;&gt;[4]&lt;/a&gt;的算法崩溃了。对于这样的大值，如果 &lt;code&gt;nsample&lt;/code&gt; 也不太大，则可以使用二项式分布 &lt;code&gt;binomial(n=nsample, p=ngood/(ngood + nbad))&lt;/code&gt; 近似该分布。</target>
        </trans-unit>
        <trans-unit id="2d355dbffda7b60d25c8fd14c77261de1c537b59" translate="yes" xml:space="preserve">
          <source>The arguments of the &lt;code&gt;configuration&lt;/code&gt; function specify the name of parent SciPy package (&lt;code&gt;parent_package&lt;/code&gt;) and the directory location of the main &lt;code&gt;setup.py&lt;/code&gt; script (&lt;code&gt;top_path&lt;/code&gt;). These arguments, along with the name of the current package, should be passed to the &lt;code&gt;Configuration&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;configuration&lt;/code&gt; 函数的参数指定父SciPy包的名称（ &lt;code&gt;parent_package&lt;/code&gt; ）和主 &lt;code&gt;setup.py&lt;/code&gt; 脚本的目录位置（ &lt;code&gt;top_path&lt;/code&gt; ）。这些参数以及当前包的名称应传递给 &lt;code&gt;Configuration&lt;/code&gt; 构造函数。</target>
        </trans-unit>
        <trans-unit id="5e50719893eed3edf2e32e25c59bbd130545cd4a" translate="yes" xml:space="preserve">
          <source>The arguments that &lt;code&gt;__array_finalize__&lt;/code&gt; receives differ for the three methods of instance creation above.</source>
          <target state="translated">&lt;code&gt;__array_finalize__&lt;/code&gt; 接收的自变量与上述实例创建的三种方法不同。</target>
        </trans-unit>
        <trans-unit id="9b1212b40ba5f9b8205d7b64e2e9c20d35b415b3" translate="yes" xml:space="preserve">
          <source>The arithmetic mean is the sum of the elements along the axis divided by the number of elements.</source>
          <target state="translated">算术平均值是沿轴线的元素之和除以元素数。</target>
        </trans-unit>
        <trans-unit id="149dc5ada110e245afebc011f82badc7bfaf2c21" translate="yes" xml:space="preserve">
          <source>The arithmetic mean is the sum of the non-NaN elements along the axis divided by the number of non-NaN elements.</source>
          <target state="translated">算术平均数是沿轴线的非纳米元素之和除以非纳米元素的数量。</target>
        </trans-unit>
        <trans-unit id="893ac85ca56066bc9e23a82ef1519d73c4482726" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;v&lt;/code&gt; of eigenvectors may not be of maximum rank, that is, some of the columns may be linearly dependent, although round-off error may obscure that fact. If the eigenvalues are all different, then theoretically the eigenvectors are linearly independent and &lt;code&gt;a&lt;/code&gt; can be diagonalized by a similarity transformation using &lt;code&gt;v&lt;/code&gt;, i.e, &lt;code&gt;inv(v) @ a @ v&lt;/code&gt; is diagonal.</source>
          <target state="translated">特征向量的数组 &lt;code&gt;v&lt;/code&gt; 可能不会具有最大秩，也就是说，某些列可能是线性相关的，尽管舍入误差可能会掩盖这一事实。如果特征值都不同，那么理论上本征矢量是线性无关的和 &lt;code&gt;a&lt;/code&gt; 可通过相似变换使用对角化 &lt;code&gt;v&lt;/code&gt; ，即， &lt;code&gt;inv(v) @ a @ v&lt;/code&gt; 是对角线。</target>
        </trans-unit>
        <trans-unit id="a686d6fd794f1b48b235aeae1a3e22a10c775aa4" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;v&lt;/code&gt; of eigenvectors may not be of maximum rank, that is, some of the columns may be linearly dependent, although round-off error may obscure that fact. If the eigenvalues are all different, then theoretically the eigenvectors are linearly independent. Likewise, the (complex-valued) matrix of eigenvectors &lt;code&gt;v&lt;/code&gt; is unitary if the matrix &lt;code&gt;a&lt;/code&gt; is normal, i.e., if &lt;code&gt;dot(a, a.H) = dot(a.H, a)&lt;/code&gt;, where &lt;code&gt;a.H&lt;/code&gt; denotes the conjugate transpose of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">特征向量的数组 &lt;code&gt;v&lt;/code&gt; 可能没有最大秩，也就是说，某些列可能是线性相关的，尽管舍入误差可能会掩盖这一事实。如果特征值都不同，则理论上特征向量是线性独立的。同样，特征向量的（复值）矩阵 &lt;code&gt;v&lt;/code&gt; 是酉如果基质 &lt;code&gt;a&lt;/code&gt; 是正常的，即，如果 &lt;code&gt;dot(a, a.H) = dot(a.H, a)&lt;/code&gt; ，其中 &lt;code&gt;a.H&lt;/code&gt; 表示的共轭转置 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="539630988d5b7ef9eff53456e4a77b468fdbbd35" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;x&lt;/code&gt; is prefilled with its filling value.</source>
          <target state="translated">数组 &lt;code&gt;x&lt;/code&gt; 会预先填充其填充值。</target>
        </trans-unit>
        <trans-unit id="048ae46227673b90cff5c0388062d4ed48f2b030" translate="yes" xml:space="preserve">
          <source>The array assembled from the given blocks.</source>
          <target state="translated">由给定的块组合而成的数组。</target>
        </trans-unit>
        <trans-unit id="f6532b7ade94739e158787e37c1d9655afff859b" translate="yes" xml:space="preserve">
          <source>The array can be indexed using Python container-like syntax:</source>
          <target state="translated">数组可以使用类似Python容器的语法进行索引。</target>
        </trans-unit>
        <trans-unit id="a7b308d78b11f2c07c75c1db0756393dc3ae53a1" translate="yes" xml:space="preserve">
          <source>The array data-type or scalar for which the default fill value is returned.</source>
          <target state="translated">返回默认填充值的数组数据类型或标量。</target>
        </trans-unit>
        <trans-unit id="3821c84ea0df179e936beb82ec9c4a845023032b" translate="yes" xml:space="preserve">
          <source>The array element of the current iteration.</source>
          <target state="translated">当前迭代的数组元素。</target>
        </trans-unit>
        <trans-unit id="930ed301b34bfc297be655fe9a537d3e2971d137" translate="yes" xml:space="preserve">
          <source>The array flags cannot be set arbitrarily:</source>
          <target state="translated">阵列标志不能任意设置。</target>
        </trans-unit>
        <trans-unit id="67bdbd5d8bcbe5caab95cc4d4f8dabba43280775" translate="yes" xml:space="preserve">
          <source>The array for which the string representation of the pickle is returned.</source>
          <target state="translated">返回pickle的字符串表示的数组。</target>
        </trans-unit>
        <trans-unit id="2a33c6111cdd8f36d42a5e94437f624d1b58746f" translate="yes" xml:space="preserve">
          <source>The array for which to count non-zeros.</source>
          <target state="translated">要计算非零的数组。</target>
        </trans-unit>
        <trans-unit id="ceccbd318dae2746e4f8b98dac923588a6a52441" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays, will be at least 2-D.</source>
          <target state="translated">将给定的数组堆叠形成的数组,将至少是二维的。</target>
        </trans-unit>
        <trans-unit id="2568bf2e437e715b60f945dc9695881ce8ef667f" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays, will be at least 3-D.</source>
          <target state="translated">将给定的数组堆叠形成的数组,将至少是三维的。</target>
        </trans-unit>
        <trans-unit id="b2c061ec289a87d3c0d4e9e7c64e5126014d42ed" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays.</source>
          <target state="translated">由给定数组堆叠而成的数组。</target>
        </trans-unit>
        <trans-unit id="8e505b1ebbfcf9d9aa6a8f699f88f4ba40304f40" translate="yes" xml:space="preserve">
          <source>The array from which values are copied.</source>
          <target state="translated">复制值的数组。</target>
        </trans-unit>
        <trans-unit id="2d987760deb151bcafba733adc9b3a186c4d7f93" translate="yes" xml:space="preserve">
          <source>The array function protocol which allows array-like objects to hook into the NumPy API is currently enabled by default. This option exists since NumPy 1.16 and is enabled by default since NumPy 1.17. It can be disabled using:</source>
          <target state="translated">数组函数协议允许类似数组的对象挂接到NumPy API,目前默认启用。这个选项从NumPy 1.16开始存在,并且从NumPy 1.17开始默认启用。它可以通过以下方式被禁用。</target>
        </trans-unit>
        <trans-unit id="7c8fb39bbbe950fa5ba32f6dec4764ff1752adf1" translate="yes" xml:space="preserve">
          <source>The array h contains the Householder reflectors that generate q along with r. The tau array contains scaling factors for the reflectors. In the deprecated &amp;lsquo;economic&amp;rsquo; mode only h is returned.</source>
          <target state="translated">数组h包含与q一起生成q的Householder反射器。 tau数组包含反射器的比例因子。在已弃用的&amp;ldquo;经济&amp;rdquo;模式下，仅返回h。</target>
        </trans-unit>
        <trans-unit id="d2932d4203636051c0cde3cab914ac5caf308f90" translate="yes" xml:space="preserve">
          <source>The array interface (sometimes called array protocol) was created in 2005 as a means for array-like Python objects to re-use each other&amp;rsquo;s data buffers intelligently whenever possible. The homogeneous N-dimensional array interface is a default mechanism for objects to share N-dimensional array memory and information. The interface consists of a Python-side and a C-side using two attributes. Objects wishing to be considered an N-dimensional array in application code should support at least one of these attributes. Objects wishing to support an N-dimensional array in application code should look for at least one of these attributes and use the information provided appropriately.</source>
          <target state="translated">数组接口（有时称为数组协议）创建于2005年，目的是使类似数组的Python对象在可能的情况下智能地重用彼此的数据缓冲区。同构N维数组接口是对象共享N维数组内存和信息的默认机制。该接口由使用两个属性的Python端和C端组成。希望在应用程序代码中被视为N维数组的对象应支持这些属性中的至少一个。希望在应用程序代码中支持N维数组的对象应查找这些属性中的至少一个，并使用适当提供的信息。</target>
        </trans-unit>
        <trans-unit id="3b7adbdac3eaf5c6305f1f61b91018f4287bec67" translate="yes" xml:space="preserve">
          <source>The array into which values are copied.</source>
          <target state="translated">复制值的数组。</target>
        </trans-unit>
        <trans-unit id="8a281d694c98742955f6444ee26a08d74603ea7a" translate="yes" xml:space="preserve">
          <source>The array is filled with a fill value before the string conversion.</source>
          <target state="translated">在字符串转换之前,数组中会填充一个填充值。</target>
        </trans-unit>
        <trans-unit id="fba8708c42061e69f757d72f0e5d1d004653f4bc" translate="yes" xml:space="preserve">
          <source>The array is rotated in the plane defined by the axes. Axes must be different.</source>
          <target state="translated">阵列在轴所定义的平面上旋转。轴必须是不同的。</target>
        </trans-unit>
        <trans-unit id="9a1223a8243cbae9aaa7753c7ea500a550cf52c0" translate="yes" xml:space="preserve">
          <source>The array iterator encapsulates many of the key features in ufuncs, allowing user code to support features like output parameters, preservation of memory layouts, and buffering of data with the wrong alignment or type, without requiring difficult coding.</source>
          <target state="translated">数组迭代器封装了ufuncs中的许多关键特性,允许用户代码支持输出参数、保存内存布局、缓冲错误对齐或类型的数据等特性,而不需要困难的编码。</target>
        </trans-unit>
        <trans-unit id="c6e1241b8c7d132ea91621f870c2bd3aaf572b4c" translate="yes" xml:space="preserve">
          <source>The array may be recreated via &lt;code&gt;a = np.array(a.tolist())&lt;/code&gt;, although this may sometimes lose precision.</source>
          <target state="translated">可以通过 &lt;code&gt;a = np.array(a.tolist())&lt;/code&gt; 重新创建数组，尽管有时可能会失去精度。</target>
        </trans-unit>
        <trans-unit id="1eee9d9d69514705c81523ac5b902691363a28a0" translate="yes" xml:space="preserve">
          <source>The array of UTC timestamps to format.</source>
          <target state="translated">要格式化的UTC时间戳数组。</target>
        </trans-unit>
        <trans-unit id="c75d57d539a00e02934380f0ab251d1c277b5e1c" translate="yes" xml:space="preserve">
          <source>The array of dates to process.</source>
          <target state="translated">要处理的日期数组。</target>
        </trans-unit>
        <trans-unit id="cc2f192e213603a4bcf402844b3339c10f79380e" translate="yes" xml:space="preserve">
          <source>The array of numbers for which the absolute values are required. If &lt;code&gt;x&lt;/code&gt; is a scalar, the result &lt;code&gt;y&lt;/code&gt; will also be a scalar.</source>
          <target state="translated">需要绝对值的数字数组。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则结果 &lt;code&gt;y&lt;/code&gt; 也将是标量。</target>
        </trans-unit>
        <trans-unit id="f9c4960d6bbbc8f2591cc039cfe68db4d8e24d90" translate="yes" xml:space="preserve">
          <source>The array of offsets, which is broadcast with &lt;code&gt;dates&lt;/code&gt;.</source>
          <target state="translated">偏移量数组，以 &lt;code&gt;dates&lt;/code&gt; 广播。</target>
        </trans-unit>
        <trans-unit id="2d674fe1383c12f697c52fd3b5198eb57b81bcb7" translate="yes" xml:space="preserve">
          <source>The array of rounded numbers</source>
          <target state="translated">四舍五入的数字阵列</target>
        </trans-unit>
        <trans-unit id="202adb7679573040b63e561db69df0e93b9eb75e" translate="yes" xml:space="preserve">
          <source>The array of the end dates for counting, which are excluded from the count themselves.</source>
          <target state="translated">计数的结束日期数组,该数组不包括计数本身。</target>
        </trans-unit>
        <trans-unit id="f508cbbca81c78d6c3819b4c01ca29622bef56f6" translate="yes" xml:space="preserve">
          <source>The array of the first dates for counting.</source>
          <target state="translated">用于计数的第一个日期的数组。</target>
        </trans-unit>
        <trans-unit id="a4e03a6eeebaef72c6a7e32f280b123bbf142ff2" translate="yes" xml:space="preserve">
          <source>The array or list to be shuffled.</source>
          <target state="translated">要洗牌的数组或列表。</target>
        </trans-unit>
        <trans-unit id="1f6abc9406bedaa275a3843a6290b585462b97a3" translate="yes" xml:space="preserve">
          <source>The array or matrix to be repeated.</source>
          <target state="translated">要重复的数组或矩阵。</target>
        </trans-unit>
        <trans-unit id="53aead7fb32cb3de7311369b48d13d4953d0adc5" translate="yes" xml:space="preserve">
          <source>The array owns the memory it uses or borrows it from another object.</source>
          <target state="translated">数组拥有它所使用的内存,或者从另一个对象那里借来。</target>
        </trans-unit>
        <trans-unit id="8df4e8232db4a79568062cac77624a670d547db6" translate="yes" xml:space="preserve">
          <source>The array scalar objects have an &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;array priority&lt;/code&gt;&lt;/a&gt; of &lt;a href=&quot;c-api/array#c.NPY_SCALAR_PRIORITY&quot;&gt;&lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt;&lt;/a&gt; (-1,000,000.0). They also do not (yet) have a &lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; attribute. Otherwise, they share the same attributes as arrays:</source>
          <target state="translated">数组标量对象的&lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;array priority&lt;/code&gt; &lt;/a&gt;为&lt;a href=&quot;c-api/array#c.NPY_SCALAR_PRIORITY&quot;&gt; &lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt; &lt;/a&gt;（-1,000,000.0）。它们也没有&lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt;属性。否则，它们与数组共享相同的属性：</target>
        </trans-unit>
        <trans-unit id="8abf01fdd64396d234195c26c60e850e4a12a8d7" translate="yes" xml:space="preserve">
          <source>The array scalar objects have an &lt;code&gt;array priority&lt;/code&gt; of &lt;a href=&quot;c-api.array#c.NPY_SCALAR_PRIORITY&quot;&gt;&lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt;&lt;/a&gt; (-1,000,000.0). They also do not (yet) have a &lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; attribute. Otherwise, they share the same attributes as arrays:</source>
          <target state="translated">数组标量对象的 &lt;code&gt;array priority&lt;/code&gt; 为&lt;a href=&quot;c-api.array#c.NPY_SCALAR_PRIORITY&quot;&gt; &lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt; &lt;/a&gt;（-1,000,000.0）。它们也还没有&lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt;属性。否则，它们与数组共享相同的属性：</target>
        </trans-unit>
        <trans-unit id="5774b39bb119ab7d3a197a6eee5e164f12892112" translate="yes" xml:space="preserve">
          <source>The array scalar objects have an &lt;code&gt;array priority&lt;/code&gt; of &lt;a href=&quot;c-api/array#c.NPY_SCALAR_PRIORITY&quot;&gt;&lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt;&lt;/a&gt; (-1,000,000.0). They also do not (yet) have a &lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; attribute. Otherwise, they share the same attributes as arrays:</source>
          <target state="translated">数组标量对象的 &lt;code&gt;array priority&lt;/code&gt; 为&lt;a href=&quot;c-api/array#c.NPY_SCALAR_PRIORITY&quot;&gt; &lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt; &lt;/a&gt;（-1,000,000.0）。它们也没有&lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt;属性。否则，它们与数组共享相同的属性：</target>
        </trans-unit>
        <trans-unit id="8c0162c81e2783b3bcbb0dd799de5c3ba91aba6a" translate="yes" xml:space="preserve">
          <source>The array scalars also offer the same methods and attributes as arrays with the intent that the same code can be used to support arbitrary dimensions (including 0-dimensions). The array scalars are read-only (immutable) with the exception of the void scalar which can also be written to so that structured array field setting works more naturally (a[0][&amp;lsquo;f1&amp;rsquo;] = &lt;code&gt;value&lt;/code&gt; ).</source>
          <target state="translated">数组标量还提供与数组相同的方法和属性，目的是可以使用相同的代码来支持任意维（包括0维）。数组标量是只读的（不可变的），除了void标量也可以写入，使得结构化数组字段设置更自然地工作（a [0] ['f1'] = &lt;code&gt;value&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d0afa5fdfdf427a8322c75c5712091eca91eabac" translate="yes" xml:space="preserve">
          <source>The array scalars offer a hierarchy of Python types that allow a one- to-one correspondence between the data-type stored in an array and the Python-type that is returned when an element is extracted from the array. An exception to this rule was made with object arrays. Object arrays are heterogeneous collections of arbitrary Python objects. When you select an item from an object array, you get back the original Python object (and not an object array scalar which does exist but is rarely used for practical purposes).</source>
          <target state="translated">数组标量提供了一个Python类型的层次结构,它允许存储在数组中的数据类型和从数组中提取元素时返回的Python类型之间有一对一的对应关系。这个规则的例外是对象数组。对象数组是任意 Python 对象的异构集合。当你从一个对象数组中选择一个项目时,你会得到原始的 Python 对象 (而不是对象数组标量,后者确实存在,但很少用于实际目的)。</target>
        </trans-unit>
        <trans-unit id="4e947f26c0ecf6d9ff639e9f27b5b5f852135d7e" translate="yes" xml:space="preserve">
          <source>The array to act on.</source>
          <target state="translated">要执行的数组。</target>
        </trans-unit>
        <trans-unit id="7000ca786d20479930ea43aa17e050c42578abc2" translate="yes" xml:space="preserve">
          <source>The array to be pickled.</source>
          <target state="translated">要腌制的数组。</target>
        </trans-unit>
        <trans-unit id="25694c63a056a35911c5654e87ce1708648d0cd3" translate="yes" xml:space="preserve">
          <source>The array to broadcast.</source>
          <target state="translated">要广播的数组。</target>
        </trans-unit>
        <trans-unit id="61fa35e69f8b8bb03ffef7462ad7cef9c9cdddeb" translate="yes" xml:space="preserve">
          <source>The array to mask. If not a MaskedArray instance (or if no array elements are masked). The result is a MaskedArray with &lt;code&gt;mask&lt;/code&gt; set to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (False). Must be a 2D array.</source>
          <target state="translated">要屏蔽的数组。如果不是MaskedArray实例（或者没有掩码的数组元素）。结果是MaskedArray，其 &lt;code&gt;mask&lt;/code&gt; 设置为&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;（False）。必须是2D数组。</target>
        </trans-unit>
        <trans-unit id="9a0afda668850edc1a593d4069db9a58418e2d74" translate="yes" xml:space="preserve">
          <source>The array to operate on. If not a MaskedArray instance (or if no array elements are masked), &lt;code&gt;x&lt;/code&gt; is interpreted as a MaskedArray with &lt;code&gt;mask&lt;/code&gt; set to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;. Must be a 2D array.</source>
          <target state="translated">要操作的阵列。如果不是一个MaskedArray实例（或如果没有数组元素被掩蔽）， &lt;code&gt;x&lt;/code&gt; 被解释为与MaskedArray &lt;code&gt;mask&lt;/code&gt; 设置为&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;。必须是2D数组。</target>
        </trans-unit>
        <trans-unit id="da7df7a6420823a6b7e45bca218ba68631febc25" translate="yes" xml:space="preserve">
          <source>The array to pad.</source>
          <target state="translated">要垫的数组。</target>
        </trans-unit>
        <trans-unit id="8966af5b1934b124717f0c80ec9988807e784cf9" translate="yes" xml:space="preserve">
          <source>The array to perform in place operation on.</source>
          <target state="translated">要执行就地操作的数组。</target>
        </trans-unit>
        <trans-unit id="1a2586a66b67a305c2797e7e06685302608f4ea4" translate="yes" xml:space="preserve">
          <source>The array whose axes should be reordered.</source>
          <target state="translated">数组的轴应该重新排序。</target>
        </trans-unit>
        <trans-unit id="81f5ca8ebafc1afb8a9d51589c5e138b4b807e19" translate="yes" xml:space="preserve">
          <source>The array(s) to be iterated over. Valid only before the iterator is closed.</source>
          <target state="translated">迭代的数组。仅在迭代器关闭前有效。</target>
        </trans-unit>
        <trans-unit id="8c52ea12181e4277b350926a7c51f79608004cd5" translate="yes" xml:space="preserve">
          <source>The array(s) to iterate over.</source>
          <target state="translated">迭代的数组。</target>
        </trans-unit>
        <trans-unit id="44ee88d0d0ad997d1f49ea29b7557e01d238c30a" translate="yes" xml:space="preserve">
          <source>The array, list or mutable sequence to be shuffled.</source>
          <target state="translated">要洗牌的数组、列表或可变序列。</target>
        </trans-unit>
        <trans-unit id="ae34a0f5008cfcf7a204a6ae1b41350a0a8ffea9" translate="yes" xml:space="preserve">
          <source>The array-protocol typestring of this data-type object.</source>
          <target state="translated">该数据类型对象的数组-协议类型字符串。</target>
        </trans-unit>
        <trans-unit id="342be16484b97c95949f88958c455899735a9596" translate="yes" xml:space="preserve">
          <source>The arrays all have exactly the same shape.</source>
          <target state="translated">阵列都有完全相同的形状。</target>
        </trans-unit>
        <trans-unit id="d48d7d91bb3512b8a648b512669295a09d607ddf" translate="yes" xml:space="preserve">
          <source>The arrays all have the same number of dimensions and the length of each dimensions is either a common length or 1.</source>
          <target state="translated">数组的维数都是一样的,而且每个维数的长度都是共同长度或1。</target>
        </trans-unit>
        <trans-unit id="3b32b95e95ce590daa0a88406a7282f0b6f9ae1f" translate="yes" xml:space="preserve">
          <source>The arrays holding the elements to be compared. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">包含要比较的元素的数组。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="b72974524c2659f265dc742386bd383e243bc4a6" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the first axis. 1-D arrays must have the same length.</source>
          <target state="translated">除第一轴外,所有阵列必须具有相同的形状。一维阵列必须具有相同的长度。</target>
        </trans-unit>
        <trans-unit id="9548b85aa3e636c88bbbc65cfcdf4e6b5fff4585" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the second axis, except 1-D arrays which can be any length.</source>
          <target state="translated">除第二轴外,阵列必须沿所有轴线具有相同的形状,但一维阵列可以是任何长度。</target>
        </trans-unit>
        <trans-unit id="34736140b85990281116cda8321b303d602cfb2e" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the third axis. 1-D or 2-D arrays must have the same shape.</source>
          <target state="translated">除第三轴外,所有阵列必须具有相同的形状。一维或二维阵列必须具有相同的形状。</target>
        </trans-unit>
        <trans-unit id="250d7318b7910004f5ade9c6bf7fa2a62b2d0aa6" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape, except in the dimension corresponding to &lt;code&gt;axis&lt;/code&gt; (the first, by default).</source>
          <target state="translated">数组必须具有相同的形状，除了对应于 &lt;code&gt;axis&lt;/code&gt; 的尺寸（默认为第一个）。</target>
        </trans-unit>
        <trans-unit id="3650412314ab8d0d6cc595877979b22653a06cac" translate="yes" xml:space="preserve">
          <source>The arrays that have too few dimensions can have their shapes prepended with a dimension of length 1 to satisfy property 2.</source>
          <target state="translated">维度太少的数组,其形状可以用长度为1的维度前置,以满足属性2。</target>
        </trans-unit>
        <trans-unit id="3c7fb6624c1c578e967064538473cd4324bc56b1" translate="yes" xml:space="preserve">
          <source>The arrays to be added. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">要添加的数组。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="61831d63f8eb03ec54ea81f37b4edf92245e6861" translate="yes" xml:space="preserve">
          <source>The arrays to be subtracted from each other. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">彼此相减的数组。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="b989bf28be4c34813d52a00110756329cfab3199" translate="yes" xml:space="preserve">
          <source>The arrays to broadcast.</source>
          <target state="translated">要广播的数组。</target>
        </trans-unit>
        <trans-unit id="4bc127992ac15b346e5ebc50b22b2084cc253474" translate="yes" xml:space="preserve">
          <source>The available functions are defined in &amp;lt;numpy/npy_math.h&amp;gt; - please refer to this header when in doubt.</source>
          <target state="translated">可用的函数在&amp;lt;numpy / npy_math.h&amp;gt;中定义-如有疑问，请参考此头文件。</target>
        </trans-unit>
        <trans-unit id="686cb4c9f84e6a825a4dffab12a90e362cecd993" translate="yes" xml:space="preserve">
          <source>The average along the specified axis. When returned is &lt;code&gt;True&lt;/code&gt;, return a tuple with the average as the first element and the sum of the weights as the second element. The return type is &lt;code&gt;np.float64&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is of integer type and floats smaller than &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;float64&lt;/code&gt;&lt;/a&gt;, or the input data-type, otherwise. If returned, &lt;code&gt;sum_of_weights&lt;/code&gt; is always &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;float64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">沿指定轴的平均值。当返回 &lt;code&gt;True&lt;/code&gt; 时，返回一个以平均值为第一个元素，权重之和为第二个元素的元组。如果 &lt;code&gt;a&lt;/code&gt; 为整数类型，并且浮点数小于&lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt; &lt;code&gt;float64&lt;/code&gt; &lt;/a&gt;或输入数据类型，则返回类型为 &lt;code&gt;np.float64&lt;/code&gt; 。如果返回， &lt;code&gt;sum_of_weights&lt;/code&gt; 始终为&lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt; &lt;code&gt;float64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c1200844d5256d1bf5c45cf0a767eb7723d9e5e" translate="yes" xml:space="preserve">
          <source>The average along the specified axis. When returned is &lt;code&gt;True&lt;/code&gt;, return a tuple with the average as the first element and the sum of the weights as the second element. The return type is &lt;code&gt;np.float64&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is of integer type and floats smaller than &lt;code&gt;float64&lt;/code&gt;, or the input data-type, otherwise. If returned, &lt;code&gt;sum_of_weights&lt;/code&gt; is always &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">沿指定轴的平均值。当返回 &lt;code&gt;True&lt;/code&gt; 时，返回一个以平均值为第一个元素，权重之和为第二个元素的元组。如果 &lt;code&gt;a&lt;/code&gt; 为整数类型，并且浮点数小于 &lt;code&gt;float64&lt;/code&gt; 或输入数据类型，则返回类型为 &lt;code&gt;np.float64&lt;/code&gt; 。如果返回， &lt;code&gt;sum_of_weights&lt;/code&gt; 始终为 &lt;code&gt;float64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="542875b084a7c351a7a1f8a6d2d600675ca4d2a7" translate="yes" xml:space="preserve">
          <source>The average squared deviation is normally calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of the infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables. The standard deviation computed in this function is the square root of the estimated variance, so even with &lt;code&gt;ddof=1&lt;/code&gt;, it will not be an unbiased estimate of the standard deviation per se.</source>
          <target state="translated">均方差通常计算为 &lt;code&gt;x.sum() / N&lt;/code&gt; ，其中 &lt;code&gt;N = len(x)&lt;/code&gt; 。然而，如果 &lt;code&gt;ddof&lt;/code&gt; 指定，除数 &lt;code&gt;N - ddof&lt;/code&gt; 代替。在标准的统计实践中， &lt;code&gt;ddof=1&lt;/code&gt; 提供了无穷总体方差的无偏估计量。 &lt;code&gt;ddof=0&lt;/code&gt; 为正态分布变量提供方差的最大似然估计。在此函数中计算的标准偏差是估计方差的平方根，因此即使 &lt;code&gt;ddof=1&lt;/code&gt; ，也不会是标准偏差本身的无偏估计。</target>
        </trans-unit>
        <trans-unit id="e5371b975bd9a5aa7f9f30c169b220e1eedba6bf" translate="yes" xml:space="preserve">
          <source>The average squared deviation is typically calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of the infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables. The standard deviation computed in this function is the square root of the estimated variance, so even with &lt;code&gt;ddof=1&lt;/code&gt;, it will not be an unbiased estimate of the standard deviation per se.</source>
          <target state="translated">平均平方偏差通常计算为 &lt;code&gt;x.sum() / N&lt;/code&gt; ，其中 &lt;code&gt;N = len(x)&lt;/code&gt; 。然而，如果 &lt;code&gt;ddof&lt;/code&gt; 指定，除数 &lt;code&gt;N - ddof&lt;/code&gt; 代替。在标准的统计实践中， &lt;code&gt;ddof=1&lt;/code&gt; 提供了无穷总体方差的无偏估计量。 &lt;code&gt;ddof=0&lt;/code&gt; 为正态分布变量提供方差的最大似然估计。在此函数中计算的标准偏差是估计方差的平方根，因此即使 &lt;code&gt;ddof=1&lt;/code&gt; ，它也不是标准偏差本身的无偏估计。</target>
        </trans-unit>
        <trans-unit id="21ebdcee890d352b954472165e15ea262b078aa8" translate="yes" xml:space="preserve">
          <source>The axes over which to compute the inverse fft. Default is the last two axes.</source>
          <target state="translated">计算反FFT的轴。默认为最后两个轴。</target>
        </trans-unit>
        <trans-unit id="3f6da36d69c95a72b5592c0677dd407fdc9cfa2c" translate="yes" xml:space="preserve">
          <source>The axis along which &lt;code&gt;v&lt;/code&gt; are appended. If &lt;code&gt;axis&lt;/code&gt; is not given, both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are flattened before use.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 所沿的轴。如果未指定 &lt;code&gt;axis&lt;/code&gt; ，则在使用前将 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 展平。</target>
        </trans-unit>
        <trans-unit id="071585631d8d75cc42162ae0da0a1b91474572d1" translate="yes" xml:space="preserve">
          <source>The axis along which &lt;code&gt;values&lt;/code&gt; are appended. If &lt;code&gt;axis&lt;/code&gt; is not given, both &lt;code&gt;arr&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; are flattened before use.</source>
          <target state="translated">沿其 &lt;code&gt;values&lt;/code&gt; 的轴。如果未指定 &lt;code&gt;axis&lt;/code&gt; ，则在使用前将 &lt;code&gt;arr&lt;/code&gt; 和 &lt;code&gt;values&lt;/code&gt; 都展平。</target>
        </trans-unit>
        <trans-unit id="d25eb0541fd006d52dcbebc548c80309c583cc52" translate="yes" xml:space="preserve">
          <source>The axis along which the arrays will be joined. Default is 0.</source>
          <target state="translated">连接数组的轴线。默认为0。</target>
        </trans-unit>
        <trans-unit id="ab324f8b42b072f0ce80303066858390de817e59" translate="yes" xml:space="preserve">
          <source>The axis along which the arrays will be joined. If axis is None, arrays are flattened before use. Default is 0.</source>
          <target state="translated">连接数组的轴线。如果坐标轴为None,则在使用前对数组进行扁平化处理。默认值为0。</target>
        </trans-unit>
        <trans-unit id="b85856e591095eebb92c2f542dccaa68776b00c8" translate="yes" xml:space="preserve">
          <source>The axis along which the difference is taken, default is the last axis.</source>
          <target state="translated">取差的轴线,默认为最后一个轴线。</target>
        </trans-unit>
        <trans-unit id="848f8430ea7a17384babb0b6d388a2e2e8bda711" translate="yes" xml:space="preserve">
          <source>The axis along which the selection is performed. The default, 0, selects by row.</source>
          <target state="translated">执行选择的轴。默认值0,按行选择。</target>
        </trans-unit>
        <trans-unit id="db9105950615faa8709d8dba888767b4f466811c" translate="yes" xml:space="preserve">
          <source>The axis along which to apply the accumulation; default is zero.</source>
          <target state="translated">应用累积的轴,默认为零。</target>
        </trans-unit>
        <trans-unit id="b45496da67ff059714d0b1ae6911029e831dd2fd" translate="yes" xml:space="preserve">
          <source>The axis along which to apply the reduceat.</source>
          <target state="translated">缩小的轴线。</target>
        </trans-unit>
        <trans-unit id="ef9dbd3a8e7509325fd10ad7183022f46facda83" translate="yes" xml:space="preserve">
          <source>The axis along which to delete the subarray defined by &lt;code&gt;obj&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;obj&lt;/code&gt; is applied to the flattened array.</source>
          <target state="translated">删除 &lt;code&gt;obj&lt;/code&gt; 定义的子数组所沿的轴。如果 &lt;code&gt;axis&lt;/code&gt; 为None，则 &lt;code&gt;obj&lt;/code&gt; 将应用于扁平化数组。</target>
        </trans-unit>
        <trans-unit id="3c27f5e5d6b589ff51ec356603f9f33684d0e877" translate="yes" xml:space="preserve">
          <source>The axis along which to find the minima. Default is None, in which case the minimum value in the whole array is returned.</source>
          <target state="translated">寻找最小值的轴。默认值是None,在这种情况下,返回整个数组的最小值。</target>
        </trans-unit>
        <trans-unit id="5932d4cf836b6b58485bd9f15e2f20474363c36f" translate="yes" xml:space="preserve">
          <source>The axis along which to integrate.</source>
          <target state="translated">沿着这个轴线进行整合。</target>
        </trans-unit>
        <trans-unit id="0011917dec1b66b996673fed4476058c1c23ee6e" translate="yes" xml:space="preserve">
          <source>The axis along which to repeat values. By default, use the flattened input array, and return a flat output array.</source>
          <target state="translated">重复值的轴。默认情况下,使用扁平化的输入数组,并返回一个扁平的输出数组。</target>
        </trans-unit>
        <trans-unit id="407371d3199afc3105f3e75619a63b4981063028" translate="yes" xml:space="preserve">
          <source>The axis along which to split, default is 0.</source>
          <target state="translated">分割的轴线,默认为0。</target>
        </trans-unit>
        <trans-unit id="6c8aa23aca8c1dff0d85e03c9e665e89973587d4" translate="yes" xml:space="preserve">
          <source>The axis can be specified explicitly:</source>
          <target state="translated">可以明确地指定轴。</target>
        </trans-unit>
        <trans-unit id="40f4cb16df8166b16f689cc3f6a27ceb034ca2a8" translate="yes" xml:space="preserve">
          <source>The axis currently being calculated.</source>
          <target state="translated">当前正在计算的轴。</target>
        </trans-unit>
        <trans-unit id="779396c94c96c008627d39cce908fca96b699246" translate="yes" xml:space="preserve">
          <source>The axis in the result array along which the input arrays are stacked.</source>
          <target state="translated">结果数组中的轴,输入数组沿此轴堆叠。</target>
        </trans-unit>
        <trans-unit id="f53c3f1c70993fc128dae4ee501fb80cbace06f6" translate="yes" xml:space="preserve">
          <source>The axis in the result to store the samples. Relevant only if start or stop are array-like. By default (0), the samples will be along a new axis inserted at the beginning. Use -1 to get an axis at the end.</source>
          <target state="translated">结果中存储样本的轴。只有当start或stop是类似数组的时候才有意义。默认情况下(0),样本将沿着在开始时插入的新轴。使用-1可以在最后得到一个轴。</target>
        </trans-unit>
        <trans-unit id="5d9b30084a3b37c792a839c94c54a5cdb7a8cfce" translate="yes" xml:space="preserve">
          <source>The axis is rolled until it lies before this position. The default, 0, results in a &amp;ldquo;complete&amp;rdquo; roll.</source>
          <target state="translated">轴将滚动直到其位于该位置之前。默认值为0，将导致&amp;ldquo;完成&amp;rdquo;滚动。</target>
        </trans-unit>
        <trans-unit id="bb67daef266f9ea49c20107e1bf4911d74a22608" translate="yes" xml:space="preserve">
          <source>The axis over which to select values. By default, the flattened input array is used.</source>
          <target state="translated">选择值的轴。默认情况下,使用扁平化的输入数组。</target>
        </trans-unit>
        <trans-unit id="6a2ce88413f2bc22b3ef2d3c9420680ad19eebe6" translate="yes" xml:space="preserve">
          <source>The axis to be rolled. The positions of the other axes do not change relative to one another.</source>
          <target state="translated">要滚动的轴。其他轴的位置不会相对改变。</target>
        </trans-unit>
        <trans-unit id="d0edfc48d57e03c356c790b28b9213c10fc98a8b" translate="yes" xml:space="preserve">
          <source>The axis to operate on. If None, &lt;code&gt;ar&lt;/code&gt; will be flattened. If an integer, the subarrays indexed by the given axis will be flattened and treated as the elements of a 1-D array with the dimension of the given axis, see the notes for more details. Object arrays or structured arrays that contain objects are not supported if the &lt;code&gt;axis&lt;/code&gt; kwarg is used. The default is None.</source>
          <target state="translated">要运行的轴。如果为None，则 &lt;code&gt;ar&lt;/code&gt; 将被展平。如果为整数，则由给定轴索引的子数组将被展平并视为具有给定轴尺寸的一维数组的元素，有关更多详细信息，请参见注释。如果使用 &lt;code&gt;axis&lt;/code&gt; kwarg，则不支持对象数组或包含对象的结构化数组。默认为无。</target>
        </trans-unit>
        <trans-unit id="b9493a9f29cafe569828c852de6864aa7f5d0ff6" translate="yes" xml:space="preserve">
          <source>The axis to roll backwards. The positions of the other axes do not change relative to one another.</source>
          <target state="translated">向后滚动的轴。其他轴的位置不会相对改变。</target>
        </trans-unit>
        <trans-unit id="340d3fc196833339a77972eea60efcdfd52ba73c" translate="yes" xml:space="preserve">
          <source>The axis to take 1d slices along. If axis is None, the destination array is treated as if a flattened 1d view had been created of it.</source>
          <target state="translated">沿着1d切片的轴。如果轴为None,目标数组将被视为已创建的扁平化1d视图。</target>
        </trans-unit>
        <trans-unit id="a049beb1044c250e5951941014a3acba639cb49d" translate="yes" xml:space="preserve">
          <source>The axis to take 1d slices along. If axis is None, the input array is treated as if it had first been flattened to 1d, for consistency with &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">沿其取一维切片的轴。如果axis为None，则将输入数组视为首先被展平为1d，以与&lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt;保持一致。</target>
        </trans-unit>
        <trans-unit id="a5f8cd862df0c3dc198b03cdec5c823ff5bfd3ca" translate="yes" xml:space="preserve">
          <source>The axis which &lt;code&gt;x&lt;/code&gt; is shuffled along. Default is 0.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 沿其移动的轴。默认值为0。</target>
        </trans-unit>
        <trans-unit id="b08fd6e477a7b8aeeb4332f420687b1d376d9496" translate="yes" xml:space="preserve">
          <source>The axis which &lt;code&gt;x&lt;/code&gt; is shuffled along. Default is 0. It is only supported on &lt;a href=&quot;../../generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 沿其移动的轴。默认值为0。仅在&lt;a href=&quot;../../generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;对象上受支持。</target>
        </trans-unit>
        <trans-unit id="24f5f1b01f9d6c3c18ebf1e91b8c1b0eb06217c1" translate="yes" xml:space="preserve">
          <source>The axis which &lt;code&gt;x&lt;/code&gt; is shuffled along. Default is 0. It is only supported on &lt;code&gt;ndarray&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 沿其移动的轴。默认值为0。仅在 &lt;code&gt;ndarray&lt;/code&gt; 对象上受支持。</target>
        </trans-unit>
        <trans-unit id="8262154fa6203f128694759e7e2ae715f81f6fa1" translate="yes" xml:space="preserve">
          <source>The base BitGenerator.state must be overridden by a subclass</source>
          <target state="translated">基本的BitGenerator.state必须被一个子类覆盖</target>
        </trans-unit>
        <trans-unit id="98787e1071b5327d0b2e07537c81bb27588db08e" translate="yes" xml:space="preserve">
          <source>The base case for this recursion is a 0D array:</source>
          <target state="translated">这个递归的基本情况是一个0D数组。</target>
        </trans-unit>
        <trans-unit id="88d21dfd4e25736b7184078ba7f33b64bea753e0" translate="yes" xml:space="preserve">
          <source>The base of an array that owns its memory is None:</source>
          <target state="translated">拥有其内存的数组的基数是None。</target>
        </trans-unit>
        <trans-unit id="074b16b582d8ec2099beaee8dcbc987839646a35" translate="yes" xml:space="preserve">
          <source>The base of the log space. The step size between the elements in &lt;code&gt;ln(samples) / ln(base)&lt;/code&gt; (or &lt;code&gt;log_base(samples)&lt;/code&gt;) is uniform. Default is 10.0.</source>
          <target state="translated">日志空间的基础。 &lt;code&gt;ln(samples) / ln(base)&lt;/code&gt; （或 &lt;code&gt;log_base(samples)&lt;/code&gt; ）中元素之间的步长是均匀的。默认值为10.0。</target>
        </trans-unit>
        <trans-unit id="7276467b8228c2e569c11964caa906fd33040a07" translate="yes" xml:space="preserve">
          <source>The baseline</source>
          <target state="translated">基线</target>
        </trans-unit>
        <trans-unit id="535897fba7f592c8b7dd04c68596d9a31edf2e11" translate="yes" xml:space="preserve">
          <source>The bases in &lt;code&gt;x1&lt;/code&gt; raised to the exponents in &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 中的基数上升到 &lt;code&gt;x2&lt;/code&gt; 中的指数。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="707f28b031c35e2bf30d29bbd42946a1e8c7dc8c" translate="yes" xml:space="preserve">
          <source>The bases.</source>
          <target state="translated">基地。</target>
        </trans-unit>
        <trans-unit id="5bc92f7e413935d311df16000ae397f9e815d85b" translate="yes" xml:space="preserve">
          <source>The basic data element&amp;rsquo;s size in bytes</source>
          <target state="translated">基本数据元素的大小（以字节为单位）</target>
        </trans-unit>
        <trans-unit id="68fe9eda4da762f1f4d04299c59c07412dcd5a69" translate="yes" xml:space="preserve">
          <source>The basic slice syntax is &lt;code&gt;i:j:k&lt;/code&gt; where &lt;em&gt;i&lt;/em&gt; is the starting index, &lt;em&gt;j&lt;/em&gt; is the stopping index, and &lt;em&gt;k&lt;/em&gt; is the step (</source>
          <target state="translated">基本切片语法为 &lt;code&gt;i:j:k&lt;/code&gt; ，其中&lt;em&gt;i&lt;/em&gt;是起始索引，&lt;em&gt;j&lt;/em&gt;是终止索引，&lt;em&gt;k&lt;/em&gt;是步骤（</target>
        </trans-unit>
        <trans-unit id="aeeddb45e8f2002e147b881df220bd44abec802b" translate="yes" xml:space="preserve">
          <source>The basic type character codes are:</source>
          <target state="translated">基本类型字符代码为:</target>
        </trans-unit>
        <trans-unit id="94f38793f86bdba698e5ca03402c847550f50738" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is a Chebyshev basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">缩放基本多项式，以便当 &lt;code&gt;c&lt;/code&gt; 是Chebyshev基本多项式时，伴随矩阵对称。与未缩放的情况相比，这提供了更好的特征值估计，对于基本多项式，如果使用&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;来获得特征值，则可以保证它们是实数。</target>
        </trans-unit>
        <trans-unit id="fd443fcafad8cfc7235ab73b5edb8fa2361feb5f" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an Hermite basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">缩放基础多项式，以便当 &lt;code&gt;c&lt;/code&gt; 是Hermite基础多项式时，伴随矩阵对称。与未缩放的情况相比，这提供了更好的特征值估计，对于基本多项式，如果使用&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;来获得特征值，则可以保证它们是实数。</target>
        </trans-unit>
        <trans-unit id="e1520a86bfcd397936d59363e21a13733e7a71b7" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an HermiteE basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">缩放基本多项式，以便当 &lt;code&gt;c&lt;/code&gt; 是HermiteE基本多项式时，伴随矩阵对称。与未缩放的情况相比，这提供了更好的特征值估计，对于基本多项式，如果使用&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;来获得特征值，则可以保证它们是实数。</target>
        </trans-unit>
        <trans-unit id="31e8496a7482cd5cd28cb680bd285957a80df61e" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an Legendre basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">缩放基本多项式，以便当 &lt;code&gt;c&lt;/code&gt; 是Legendre基本多项式时，伴随矩阵对称。与未缩放的情况相比，这提供了更好的特征值估计，对于基本多项式，如果使用&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;来获得特征值，则可以保证它们是实数。</target>
        </trans-unit>
        <trans-unit id="f437318ff72364f761b90a9b7cf38009e657db81" translate="yes" xml:space="preserve">
          <source>The behavior depends on the arguments in the following way.</source>
          <target state="translated">其行为取决于以下方式的参数。</target>
        </trans-unit>
        <trans-unit id="52cedd9e4737e7d41b9c0573b9212f2735c44e68" translate="yes" xml:space="preserve">
          <source>The behavior of multi-field indexes changed from Numpy 1.15 to Numpy 1.16.</source>
          <target state="translated">从Numpy 1.15到Numpy 1.16,多字段索引的行为有所改变。</target>
        </trans-unit>
        <trans-unit id="7c61d26e0bac97d24671e4708fc43eaa9dd53127" translate="yes" xml:space="preserve">
          <source>The behaviour of NumPy and Python integer types differs significantly for integer overflows and may confuse users expecting NumPy integers to behave similar to Python&amp;rsquo;s &lt;code&gt;int&lt;/code&gt;. Unlike NumPy, the size of Python&amp;rsquo;s &lt;code&gt;int&lt;/code&gt; is flexible. This means Python integers may expand to accommodate any integer and will not overflow.</source>
          <target state="translated">NumPy和Python整数类型的行为对于整数溢出有显着不同，并且可能会使期望NumPy整数的行为类似于Python &lt;code&gt;int&lt;/code&gt; 的用户感到困惑。与NumPy不同，Python的 &lt;code&gt;int&lt;/code&gt; 大小很灵活。这意味着Python整数可以扩展以容纳任何整数，并且不会溢出。</target>
        </trans-unit>
        <trans-unit id="226707a677bb2dfd051d5e6d30579822a26a8454" translate="yes" xml:space="preserve">
          <source>The benchmark parameters etc. should not depend on which NumPy version is installed.</source>
          <target state="translated">基准参数等不应该取决于安装的NumPy版本。</target>
        </trans-unit>
        <trans-unit id="52a11e20913e7d4cf3019155d32cde05064b5abf" translate="yes" xml:space="preserve">
          <source>The benchmark suite should be importable with any NumPy version.</source>
          <target state="translated">基准套件应该可以导入任何NumPy版本。</target>
        </trans-unit>
        <trans-unit id="e2bdcfca6c07efc9e236b5653fc2391d3452350a" translate="yes" xml:space="preserve">
          <source>The best practice is to &lt;strong&gt;not&lt;/strong&gt; reseed a BitGenerator, rather to recreate a new one. This method is here for legacy reasons. This example demonstrates best practice.</source>
          <target state="translated">最佳实践是&lt;strong&gt;不要&lt;/strong&gt;播种BitGenerator，而要重新创建一个新的BitGenerator。由于遗留原因，此处使用此方法。此示例演示了最佳实践。</target>
        </trans-unit>
        <trans-unit id="c109a555c27db42b8f7688c8df998553f8ab7653" translate="yes" xml:space="preserve">
          <source>The best strategy to better understand the code base is to pick something you want to change and start reading the code to figure out how it works. When in doubt, you can ask questions on the mailing list. It is perfectly okay if your pull requests aren&amp;rsquo;t perfect, the community is always happy to help. As a volunteer project, things do sometimes get dropped and it&amp;rsquo;s totally fine to ping us if something has sat without a response for about two to four weeks.</source>
          <target state="translated">更好地理解代码库的最佳策略是选择要更改的内容，然后开始阅读代码以了解其工作原理。如有疑问，您可以在邮件列表中提问。如果您的拉取请求不完美，那是完全可以的，社区总是很乐意为您提供帮助。作为一个志愿者项目，有时候事情确实会掉下来，并且如果我们坐了大约两到四个星期没有任何反应，那么对我们进行ping完全正常。</target>
        </trans-unit>
        <trans-unit id="aae59e3eb6aeca266807eb2b03def986d4d70e96" translate="yes" xml:space="preserve">
          <source>The best way to become familiar with the iterator is to look at its usage within the NumPy codebase itself. For example, here is a slightly tweaked version of the code for &lt;a href=&quot;array#c.PyArray_CountNonzero&quot;&gt;&lt;code&gt;PyArray_CountNonzero&lt;/code&gt;&lt;/a&gt;, which counts the number of non-zero elements in an array.</source>
          <target state="translated">熟悉迭代器的最佳方法是查看其在NumPy代码库本身中的用法。例如，这是&lt;a href=&quot;array#c.PyArray_CountNonzero&quot;&gt; &lt;code&gt;PyArray_CountNonzero&lt;/code&gt; &lt;/a&gt;的代码的略微调整版本，该版本对数组中非零元素的数量进行计数。</target>
        </trans-unit>
        <trans-unit id="b917d701e1031f727f4614d1e3412a655c750b99" translate="yes" xml:space="preserve">
          <source>The best way to become familiar with the iterator is to look at its usage within the NumPy codebase itself. For example, here is a slightly tweaked version of the code for &lt;a href=&quot;c-api.array#c.PyArray_CountNonzero&quot;&gt;&lt;code&gt;PyArray_CountNonzero&lt;/code&gt;&lt;/a&gt;, which counts the number of non-zero elements in an array.</source>
          <target state="translated">熟悉迭代器的最佳方法是在NumPy代码库本身中查看其用法。例如，这是&lt;a href=&quot;c-api.array#c.PyArray_CountNonzero&quot;&gt; &lt;code&gt;PyArray_CountNonzero&lt;/code&gt; &lt;/a&gt;的代码的略微调整版本，该版本对数组中非零元素的数量进行计数。</target>
        </trans-unit>
        <trans-unit id="de71d7b03048d0ddf7e9d872a2d91138dd227be5" translate="yes" xml:space="preserve">
          <source>The best way to encode the options required to link against the specified C libraries is to use a &amp;ldquo;libname.ini&amp;rdquo; file, and use &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt; to retrieve the required options (see &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt;&lt;code&gt;add_npy_pkg_config&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="translated">编码链接到指定C库所需的选项的最佳方法是使用&amp;ldquo; libname.ini&amp;rdquo;文件，并使用&lt;a href=&quot;#numpy.distutils.misc_util.Configuration.get_info&quot;&gt; &lt;code&gt;get_info&lt;/code&gt; &lt;/a&gt;检索所需的选项（有关更多信息，请参见&lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt; &lt;code&gt;add_npy_pkg_config&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bd068dc6ad18c4bdc86034d17ab908d7b76c4670" translate="yes" xml:space="preserve">
          <source>The best way to encode the options required to link against the specified C libraries is to use a &amp;ldquo;libname.ini&amp;rdquo; file, and use &lt;a href=&quot;distutils/misc_util#numpy.distutils.misc_util.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt; to retrieve the required options (see &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt;&lt;code&gt;add_npy_pkg_config&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="translated">编码链接到指定C库所需的选项的最佳方法是使用&amp;ldquo; libname.ini&amp;rdquo;文件，并使用&lt;a href=&quot;distutils/misc_util#numpy.distutils.misc_util.get_info&quot;&gt; &lt;code&gt;get_info&lt;/code&gt; &lt;/a&gt;检索所需的选项（有关更多信息，请参见&lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt; &lt;code&gt;add_npy_pkg_config&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1969d49698b808b6d276d97e5d8d4c69483e3b58" translate="yes" xml:space="preserve">
          <source>The bi-dimensional histogram of samples &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Values in &lt;code&gt;x&lt;/code&gt; are histogrammed along the first dimension and values in &lt;code&gt;y&lt;/code&gt; are histogrammed along the second dimension.</source>
          <target state="translated">样本 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的二维直方图。 &lt;code&gt;x&lt;/code&gt; 中的值沿第一维直方图， &lt;code&gt;y&lt;/code&gt; 中的值沿第二维直方图。</target>
        </trans-unit>
        <trans-unit id="ccfae57716d7eef7191c06c0e81d2ccf59d9fed0" translate="yes" xml:space="preserve">
          <source>The biggest difficulty when writing extension modules is reference counting. It is an important reason for the popularity of f2py, weave, Cython, ctypes, etc&amp;hellip;. If you mis-handle reference counts you can get problems from memory-leaks to segmentation faults. The only strategy I know of to handle reference counts correctly is blood, sweat, and tears. First, you force it into your head that every Python variable has a reference count. Then, you understand exactly what each function does to the reference count of your objects, so that you can properly use DECREF and INCREF when you need them. Reference counting can really test the amount of patience and diligence you have towards your programming craft. Despite the grim depiction, most cases of reference counting are quite straightforward with the most common difficulty being not using DECREF on objects before exiting early from a routine due to some error. In second place, is the common error of not owning the reference on an object that is passed to a function or macro that is going to steal the reference ( &lt;em&gt;e.g.&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/dev/c-api/tuple.html#c.PyTuple_SET_ITEM&quot;&gt;&lt;code&gt;PyTuple_SET_ITEM&lt;/code&gt;&lt;/a&gt;, and most functions that take &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects).</source>
          <target state="translated">编写扩展模块时最大的困难是引用计数。这是f2py，weave，Cython，ctypes等流行的重要原因。如果您错误地处理了引用计数，则可能会遇到从内存泄漏到分段错误的问题。我知道正确处理参考计数的唯一策略是血液，汗水和眼泪。首先，您必须让每个Python变量都有一个引用计数。然后，您可以准确地了解每个函数对对象的引用计数的作用，以便在需要它们时可以正确使用DECREF和INCREF。引用计数可以真正测试您对编程技巧的耐心和勤奋程度。尽管描写得很残酷，大多数引用计数情况非常简单，最常见的困难是由于某些错误而在从例程中提前退出之前不对对象使用DECREF。其次，常见的错误是在传递给要窃取引用的函数或宏的对象上不拥有引用（&lt;em&gt;例如&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/dev/c-api/tuple.html#c.PyTuple_SET_ITEM&quot;&gt; &lt;code&gt;PyTuple_SET_ITEM&lt;/code&gt; &lt;/a&gt;，以及大多数&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;对象的函数）。</target>
        </trans-unit>
        <trans-unit id="14050b2975e92118c403ebf94bd3985c0b813e9c" translate="yes" xml:space="preserve">
          <source>The bin edges along the first dimension.</source>
          <target state="translated">仓边沿第一维。</target>
        </trans-unit>
        <trans-unit id="4350d5e237c7d985f1cac8ee28f6158f7c836a6a" translate="yes" xml:space="preserve">
          <source>The bin edges along the second dimension.</source>
          <target state="translated">仓边沿二维。</target>
        </trans-unit>
        <trans-unit id="a2867162a2727e5c2d9c039d549ef3ce42449ec8" translate="yes" xml:space="preserve">
          <source>The bin specification:</source>
          <target state="translated">仓规格。</target>
        </trans-unit>
        <trans-unit id="60d93abeda71712ad2c6a79ef8adc26f40d2aa9b" translate="yes" xml:space="preserve">
          <source>The binwidth is proportional to the interquartile range (IQR) and inversely proportional to cube root of a.size. Can be too conservative for small datasets, but is quite good for large datasets. The IQR is very robust to outliers.</source>
          <target state="translated">二进制宽度与四分位数范围(IQR)成正比,与a.size的立方根成反比。对于小数据集来说可能过于保守,但对于大数据集来说是相当不错的。IQR对离群值的影响非常大。</target>
        </trans-unit>
        <trans-unit id="fcdd8e437719df337fcbc4c74083d021a1773472" translate="yes" xml:space="preserve">
          <source>The binwidth is proportional to the standard deviation of the data and inversely proportional to cube root of &lt;code&gt;x.size&lt;/code&gt;. Can be too conservative for small datasets, but is quite good for large datasets. The standard deviation is not very robust to outliers. Values are very similar to the Freedman-Diaconis estimator in the absence of outliers.</source>
          <target state="translated">binwidth与数据的标准偏差成正比，与 &lt;code&gt;x.size&lt;/code&gt; 的立方根成反比。对于小型数据集可能过于保守，但对于大型数据集则相当不错。标准偏差对异常值不是很稳健。在没有异常值的情况下，值与Freedman-Diaconis估计量非常相似。</target>
        </trans-unit>
        <trans-unit id="4bfe7be4cfb5e7ee31495fab431c2ade90ea37b4" translate="yes" xml:space="preserve">
          <source>The bit generator instance used by the generator</source>
          <target state="translated">生成器使用的位生成器实例</target>
        </trans-unit>
        <trans-unit id="1c9ceb11680f6c0c1b9aff1a5015653854b99511" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via &lt;a href=&quot;extending#random-cython&quot;&gt;Cython&lt;/a&gt;.</source>
          <target state="translated">比特发生器可以通过&lt;a href=&quot;extending#random-cython&quot;&gt;Cython&lt;/a&gt;在下游项目中使用。</target>
        </trans-unit>
        <trans-unit id="c5d3462c76522066d7ff9beefce9a7effa7d1a7a" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via &lt;a href=&quot;extending#randomgen-cython&quot;&gt;Cython&lt;/a&gt;.</source>
          <target state="translated">可以通过&lt;a href=&quot;extending#randomgen-cython&quot;&gt;Cython&lt;/a&gt;在下游项目中使用位生成器。</target>
        </trans-unit>
        <trans-unit id="bb60b63a1d593f422d320c08f605d5c913dee609" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via Cython.</source>
          <target state="translated">位生成器可以通过Cython在下游项目中使用。</target>
        </trans-unit>
        <trans-unit id="6e4e6fbd0cb3401b8c573dd3679e44e3f4f81dbf" translate="yes" xml:space="preserve">
          <source>The bit-width names can also be used (e.g. &lt;a href=&quot;c-api.dtype#c.NPY_INT32&quot;&gt;&lt;code&gt;NPY_INT32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_COMPLEX128&quot;&gt;&lt;code&gt;NPY_COMPLEX128&lt;/code&gt;&lt;/a&gt; ) if desired.</source>
          <target state="translated">如果需要，也可以使用位宽名称（例如&lt;a href=&quot;c-api.dtype#c.NPY_INT32&quot;&gt; &lt;code&gt;NPY_INT32&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.dtype#c.NPY_COMPLEX128&quot;&gt; &lt;code&gt;NPY_COMPLEX128&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bc2ab75ee612016fcf37354aa06f319d50bc9810" translate="yes" xml:space="preserve">
          <source>The bit-width names can also be used (e.g. &lt;a href=&quot;dtype#c.NPY_INT32&quot;&gt;&lt;code&gt;NPY_INT32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_COMPLEX128&quot;&gt;&lt;code&gt;NPY_COMPLEX128&lt;/code&gt;&lt;/a&gt; ) if desired.</source>
          <target state="translated">如果需要，也可以使用位宽名称（例如&lt;a href=&quot;dtype#c.NPY_INT32&quot;&gt; &lt;code&gt;NPY_INT32&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;dtype#c.NPY_COMPLEX128&quot;&gt; &lt;code&gt;NPY_COMPLEX128&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="81d10a070991358c5aabcf2c4a0f8549725777dd" translate="yes" xml:space="preserve">
          <source>The bit-wise operators &amp;amp; and | are the proper way to perform element-by-element array comparisons. Be sure you understand the operator precedence: &lt;code&gt;(a &amp;gt; 2) &amp;amp; (a &amp;lt; 5)&lt;/code&gt; is the proper syntax because &lt;code&gt;a &amp;gt; 2 &amp;amp; a &amp;lt; 5&lt;/code&gt; will result in an error due to the fact that &lt;code&gt;2 &amp;amp; a&lt;/code&gt; is evaluated first.</source>
          <target state="translated">按位运算符＆和| 是执行逐元素数组比较的正确方法。请确保您了解运算符的优先级： &lt;code&gt;(a &amp;gt; 2) &amp;amp; (a &amp;lt; 5)&lt;/code&gt; 是正确的语法，因为 &lt;code&gt;a &amp;gt; 2 &amp;amp; a &amp;lt; 5&lt;/code&gt; 会由于首先计算 &lt;code&gt;2 &amp;amp; a&lt;/code&gt; 而导致错误。</target>
        </trans-unit>
        <trans-unit id="023be86065ffa72daa5873059c9ec3d6c37210a4" translate="yes" xml:space="preserve">
          <source>The bits that are inherited for the parent data-type if these bits are set in any field of the data-type. Currently ( &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt;&lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt;&lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt;&lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt;&lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">如果在数据类型的任何字段中设置了这些位，则为父数据类型继承的位。当前（&lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt; &lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt; &lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt; &lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt; &lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="66bf7e5c5d6cdd2845e962d8640e4eedc7ddbd7e" translate="yes" xml:space="preserve">
          <source>The branches shown by &lt;code&gt;git branch -a&lt;/code&gt; will include</source>
          <target state="translated">&lt;code&gt;git branch -a&lt;/code&gt; 显示的分支将包括</target>
        </trans-unit>
        <trans-unit id="eec4adb38715609db3c28173012b3acac012a710" translate="yes" xml:space="preserve">
          <source>The broadcasting mechanism permits index arrays to be combined with scalars for other indices. The effect is that the scalar value is used for all the corresponding values of the index arrays:</source>
          <target state="translated">广播机制允许索引数组与其他索引的标量相结合。其效果是,标量值被用于索引数组的所有相应值。</target>
        </trans-unit>
        <trans-unit id="04bf04fd5bcca4e99a8d9955edaad658791a1949" translate="yes" xml:space="preserve">
          <source>The broadcasting rules are:</source>
          <target state="translated">广播规则是:</target>
        </trans-unit>
        <trans-unit id="4cdfeeb979f5beeacca8e8ed28ded2c7c6f59236" translate="yes" xml:space="preserve">
          <source>The buffer size. If &lt;code&gt;buf_size&lt;/code&gt; is supplied, the maximum amount of data that will be read into memory is &lt;code&gt;buf_size&lt;/code&gt; elements. Default is None, which will read as many element as possible into memory.</source>
          <target state="translated">缓冲区大小。如果提供 &lt;code&gt;buf_size&lt;/code&gt; ，则将读入内存的最大数据量为 &lt;code&gt;buf_size&lt;/code&gt; 元素。默认值为&amp;ldquo;无&amp;rdquo;，它将把尽可能多的元素读入内存。</target>
        </trans-unit>
        <trans-unit id="2e41256de81634e573afba6a93755e0b3e1dcc73" translate="yes" xml:space="preserve">
          <source>The built-in scalar types are shown below. Along with their (mostly) C-derived names, the integer, float, and complex data-types are also available using a bit-width convention so that an array of the right size can always be ensured (e.g. &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;). Two aliases (&lt;code&gt;intp&lt;/code&gt; and &lt;code&gt;uintp&lt;/code&gt;) pointing to the integer type that is sufficiently large to hold a C pointer are also provided. The C-like names are associated with character codes, which are shown in the table. Use of the character codes, however, is discouraged.</source>
          <target state="translated">内置标量类型如下所示。除了它们（主要是C派生的名称）之外，还可以使用位宽约定来使用整数，浮点数和复杂数据类型，以便始终确保大小正确的数组（例如 &lt;code&gt;int8&lt;/code&gt; ， &lt;code&gt;float64&lt;/code&gt; ， &lt;code&gt;complex128&lt;/code&gt; ） 。还提供了两个别名（ &lt;code&gt;intp&lt;/code&gt; 和 &lt;code&gt;uintp&lt;/code&gt; ），它们分别指向足够容纳C指针的整数类型。类似于C的名称与字符代码相关联，如表所示。但是，不建议使用字符代码。</target>
        </trans-unit>
        <trans-unit id="c4c8520f0fdeec5c9624ae64d988b36f0b68f100" translate="yes" xml:space="preserve">
          <source>The built-in scalar types are shown below. The C-like names are associated with character codes, which are shown in their descriptions. Use of the character codes, however, is discouraged.</source>
          <target state="translated">内置的标量类型如下所示。C类名称与字符代码相关联,在其描述中显示。但不鼓励使用字符代码。</target>
        </trans-unit>
        <trans-unit id="c0f5f929adb8df8a6adc766b8c78557ffdeb6dfb" translate="yes" xml:space="preserve">
          <source>The byte offset of element &lt;code&gt;(i[0], i[1], ..., i[n])&lt;/code&gt; in an array &lt;code&gt;a&lt;/code&gt; is:</source>
          <target state="translated">数组 &lt;code&gt;a&lt;/code&gt; 中元素 &lt;code&gt;(i[0], i[1], ..., i[n])&lt;/code&gt; 的字节偏移为：</target>
        </trans-unit>
        <trans-unit id="4e1d8f651723be5f774ab2e5c504d861c7a87264" translate="yes" xml:space="preserve">
          <source>The byte offsets of the fields within the structure and the total structure itemsize are determined automatically.</source>
          <target state="translated">结构中各字段的字节偏移量和结构项目的总大小是自动确定的。</target>
        </trans-unit>
        <trans-unit id="a157c5730d5626d8d468cb6666e1e8a306635908" translate="yes" xml:space="preserve">
          <source>The byte order of the data (which may not be the native byte order)</source>
          <target state="translated">数据的字节顺序(可能不是本地字节顺序)。</target>
        </trans-unit>
        <trans-unit id="54750603ecbabb9e0fbfb396fe440127b1696b3c" translate="yes" xml:space="preserve">
          <source>The byteswapped array. If &lt;code&gt;inplace&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this is a view to self.</source>
          <target state="translated">字节数组。如果 &lt;code&gt;inplace&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则这是对自身的看法。</target>
        </trans-unit>
        <trans-unit id="50ca95011c00b72a055aafd7f7fd748d3ee5666f" translate="yes" xml:space="preserve">
          <source>The calculation based on the Einstein summation convention.</source>
          <target state="translated">基于爱因斯坦求和惯例的计算。</target>
        </trans-unit>
        <trans-unit id="f28022cc3c759ea7fff9649dace591b586e47f2a" translate="yes" xml:space="preserve">
          <source>The call function takes two arguments. The first is a string describing the type of error (such as &amp;ldquo;divide by zero&amp;rdquo;, &amp;ldquo;overflow&amp;rdquo;, &amp;ldquo;underflow&amp;rdquo;, or &amp;ldquo;invalid value&amp;rdquo;), and the second is the status flag. The flag is a byte, whose four least-significant bits indicate the type of error, one of &amp;ldquo;divide&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, &amp;ldquo;invalid&amp;rdquo;:</source>
          <target state="translated">调用函数有两个参数。第一个是描述错误类型的字符串（例如&amp;ldquo;除以零&amp;rdquo;，&amp;ldquo;上溢&amp;rdquo;，&amp;ldquo;下溢&amp;rdquo;或&amp;ldquo;无效值&amp;rdquo;），第二个是状态标志。该标志是一个字节，其四个最低有效位指示错误的类型，即&amp;ldquo;除&amp;rdquo;，&amp;ldquo;上&amp;rdquo;，&amp;ldquo;下&amp;rdquo;，&amp;ldquo;无效&amp;rdquo;之一：</target>
        </trans-unit>
        <trans-unit id="65bfb33c8f536eca2e334a181b45563504281f94" translate="yes" xml:space="preserve">
          <source>The callable to test.</source>
          <target state="translated">要测试的callable。</target>
        </trans-unit>
        <trans-unit id="a3a1c9abf4ffccd45f5331c5f42edc1f3d2d1d9d" translate="yes" xml:space="preserve">
          <source>The callback function may also be explicitly set in the module. Then it is not necessary to pass the function in the argument list to the Fortran function. This may be desired if the Fortran function calling the python callback function is itself called by another Fortran function.</source>
          <target state="translated">也可以在模块中明确设置回调函数。那么就不需要将参数列表中的函数传递给Fortran函数。如果调用python回调函数的Fortran函数本身也被另一个Fortran函数调用,则可能需要这样做。</target>
        </trans-unit>
        <trans-unit id="431e9b7795bdf48241d6bec5990fb4a0130d071a" translate="yes" xml:space="preserve">
          <source>The ceil of the scalar &lt;code&gt;x&lt;/code&gt; is the smallest integer &lt;code&gt;i&lt;/code&gt;, such that &lt;code&gt;i &amp;gt;= x&lt;/code&gt;. It is often denoted as</source>
          <target state="translated">标量 &lt;code&gt;x&lt;/code&gt; 的ceil 是最小的整数 &lt;code&gt;i&lt;/code&gt; ，使得 &lt;code&gt;i &amp;gt;= x&lt;/code&gt; 。它通常表示为</target>
        </trans-unit>
        <trans-unit id="e9d3cf326f9a7a53ec955615e43eb638c61eb8ef" translate="yes" xml:space="preserve">
          <source>The ceiling of each element in &lt;code&gt;x&lt;/code&gt;, with &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; dtype. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 中每个元素的上限，带有&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; dtype。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="39a8dcb488a9fc6fc34cf5a558688abf07d39d3f" translate="yes" xml:space="preserve">
          <source>The character representing the minimum-size type that was found.</source>
          <target state="translated">代表找到的最小尺寸类型的字符。</target>
        </trans-unit>
        <trans-unit id="97cbe8e263bc4b6b77075dcb6bab028e565a01e7" translate="yes" xml:space="preserve">
          <source>The character to use for padding</source>
          <target state="translated">用于填充的字符</target>
        </trans-unit>
        <trans-unit id="6c4bf24ea0f35b24c677f85fded0fd7b09f23149" translate="yes" xml:space="preserve">
          <source>The character used to indicate the start of a comment. All the characters occurring on a line after a comment are discarded</source>
          <target state="translated">用来表示注释的开始的字符。注释之后的行上出现的所有字符都将被丢弃。</target>
        </trans-unit>
        <trans-unit id="d85f382686a835461ae276491d1cc1f7d794fafc" translate="yes" xml:space="preserve">
          <source>The characteristic polynomial,</source>
          <target state="translated">特征多项式。</target>
        </trans-unit>
        <trans-unit id="95fe0ca98cff261937758debf60dec87c78a570a" translate="yes" xml:space="preserve">
          <source>The characters or list of characters used to indicate the start of a comment. None implies no comments. For backwards compatibility, byte strings will be decoded as &amp;lsquo;latin1&amp;rsquo;. The default is &amp;lsquo;#&amp;rsquo;.</source>
          <target state="translated">用于指示注释开始的字符或字符列表。无表示无评论。为了向后兼容，字节字符串将被解码为&amp;ldquo; latin1&amp;rdquo;。默认值为&amp;ldquo;＃&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="16535da2d1a6378c09b05298f374b6373da93c3c" translate="yes" xml:space="preserve">
          <source>The choice and location of linked libraries such as BLAS and LAPACK as well as include paths and other such build options can be specified in a &lt;code&gt;site.cfg&lt;/code&gt; file located in the NumPy root repository or a &lt;code&gt;.numpy-site.cfg&lt;/code&gt; file in your home directory. See the &lt;code&gt;site.cfg.example&lt;/code&gt; example file included in the NumPy repository or sdist for documentation.</source>
          <target state="translated">可以在NumPy根存储库中的 &lt;code&gt;site.cfg&lt;/code&gt; 文件或主目录中的 &lt;code&gt;.numpy-site.cfg&lt;/code&gt; 文件中指定链接库（例如BLAS和LAPACK）以及包含路径和其他此类构建选项的选择和位置。。请参阅NumPy存储库或sdist中包含的 &lt;code&gt;site.cfg.example&lt;/code&gt; 示例文件以获取文档。</target>
        </trans-unit>
        <trans-unit id="5b3f50108009441cc91c801c6a0d50e7f118400f" translate="yes" xml:space="preserve">
          <source>The class defining the warning that &lt;code&gt;func&lt;/code&gt; is expected to throw.</source>
          <target state="translated">定义警告预期 &lt;code&gt;func&lt;/code&gt; 引发的类。</target>
        </trans-unit>
        <trans-unit id="da74e7889b120a1d89220abab914f35b23ca6ac5" translate="yes" xml:space="preserve">
          <source>The clear choice to wrap Fortran code is &lt;a href=&quot;https://docs.scipy.org/doc/numpy/f2py/&quot;&gt;f2py&lt;/a&gt;.</source>
          <target state="translated">包装Fortran代码的明确选择是&lt;a href=&quot;https://docs.scipy.org/doc/numpy/f2py/&quot;&gt;f2py&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3182c5f9b369539a27f1bc7716b92f10416add66" translate="yes" xml:space="preserve">
          <source>The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for these alternatives. For example, any of &amp;lsquo;&amp;gt;&amp;rsquo; or &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;brian&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">对于这些替代方案， &lt;code&gt;new_order&lt;/code&gt; 对new_order的第一个字母进行不区分大小写的检查。例如，&amp;ldquo;&amp;gt;&amp;rdquo;或&amp;ldquo; B&amp;rdquo;或&amp;ldquo; b&amp;rdquo;或&amp;ldquo; brian&amp;rdquo;中的任何一个都可以有效地指定big-endian。</target>
        </trans-unit>
        <trans-unit id="80380a308ceba94a9432deb39fde76dbd31d736a" translate="yes" xml:space="preserve">
          <source>The code in the second example is more efficient than that in the first because broadcasting moves less memory around during the multiplication (&lt;code&gt;b&lt;/code&gt; is a scalar rather than an array).</source>
          <target state="translated">第二个示例中的代码比第一个示例中的代码更有效，因为广播在乘法过程中会移动较少的内存（ &lt;code&gt;b&lt;/code&gt; 是标量而不是数组）。</target>
        </trans-unit>
        <trans-unit id="b154e2d8d3173f85d365231f520eaf5d3d14ed4d" translate="yes" xml:space="preserve">
          <source>The code to produce the figures is part of the &lt;a href=&quot;http://www.astroml.org/book_figures/appendix/fig_broadcast_visual.html&quot;&gt;AstroML book&lt;/a&gt;</source>
          <target state="translated">产生图形的代码是&lt;a href=&quot;http://www.astroml.org/book_figures/appendix/fig_broadcast_visual.html&quot;&gt;AstroML书的&lt;/a&gt;一部分</target>
        </trans-unit>
        <trans-unit id="3d7fde77cc6d2864c99d7d852dc9654a8a2c232a" translate="yes" xml:space="preserve">
          <source>The coefficient array representing their sum.</source>
          <target state="translated">代表其总和的系数数组。</target>
        </trans-unit>
        <trans-unit id="8877be945db0e0267ce25ed710aea10434e74470" translate="yes" xml:space="preserve">
          <source>The coefficient matrix of the coefficients &lt;code&gt;p&lt;/code&gt; is a Vandermonde matrix.</source>
          <target state="translated">系数 &lt;code&gt;p&lt;/code&gt; 的系数矩阵是范德蒙德矩阵。</target>
        </trans-unit>
        <trans-unit id="1749ca10e1fd82b0f81734b8e3040c222ba10138" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is 1 for monic polynomials in this form.</source>
          <target state="translated">对于这种形式的一元多项式,最后一项的系数为1。</target>
        </trans-unit>
        <trans-unit id="7f518b8b3d036f3e65aa1004d0ce4c9fe4f469f2" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Chebyshev form.</source>
          <target state="translated">对于切比雪夫形式的一元多项式,最后一项的系数一般不为1。</target>
        </trans-unit>
        <trans-unit id="c6e27aff7bd03298a7abe7cdd24c2851e78ffc19" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Hermite form.</source>
          <target state="translated">对于赫尔米特形式的一元多项式,最后一项的系数一般不为1。</target>
        </trans-unit>
        <trans-unit id="d8180193920e1d179284839e524518471959f55d" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in HermiteE form.</source>
          <target state="translated">对于HermiteE形式的一元多项式,最后一项的系数一般不为1。</target>
        </trans-unit>
        <trans-unit id="870417532aa77b335abb3ff61d44b3280649b54a" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Laguerre form.</source>
          <target state="translated">对于Laguerre形式的一元多项式,最后一项的系数一般不为1。</target>
        </trans-unit>
        <trans-unit id="d2eb9fcb4c7fc816e015e2f1263164865a84ea2c" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Legendre form.</source>
          <target state="translated">对于Legendre形式的一元多项式,最后一项的系数一般不为1。</target>
        </trans-unit>
        <trans-unit id="c0eab4462e93f35863c8383ff656ddde3733b00b" translate="yes" xml:space="preserve">
          <source>The coefficients are determined by multiplying together linear factors of the form &lt;code&gt;(x - r_i)&lt;/code&gt;, i.e.</source>
          <target state="translated">系数是通过将 &lt;code&gt;(x - r_i)&lt;/code&gt; 形式的线性因子相乘来确定的，即</target>
        </trans-unit>
        <trans-unit id="96b42532f49d3b3a4358a0737c1292c860f167f7" translate="yes" xml:space="preserve">
          <source>The column &lt;code&gt;v[:, i]&lt;/code&gt; is the normalized eigenvector corresponding to the eigenvalue &lt;code&gt;w[i]&lt;/code&gt;. Will return a matrix object if &lt;code&gt;a&lt;/code&gt; is a matrix object.</source>
          <target state="translated">列 &lt;code&gt;v[:, i]&lt;/code&gt; 是对应于特征值 &lt;code&gt;w[i]&lt;/code&gt; 的归一化特征向量。如果 &lt;code&gt;a&lt;/code&gt; 是矩阵对象，将返回一个矩阵对象。</target>
        </trans-unit>
        <trans-unit id="05afae6f6316038b8a077ed2d79753233c9700ab" translate="yes" xml:space="preserve">
          <source>The column dimension of the arrays for which the returned arrays will be valid. By default &lt;code&gt;m&lt;/code&gt; is taken equal to &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">返回数组将对其有效的数组的列维。默认情况下， &lt;code&gt;m&lt;/code&gt; 等于 &lt;code&gt;n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="049227627bd4dfed2d2a3d0a02023afddf2ece4d" translate="yes" xml:space="preserve">
          <source>The columns of the output matrix are powers of the input vector. The order of the powers is determined by the &lt;code&gt;increasing&lt;/code&gt; boolean argument. Specifically, when &lt;code&gt;increasing&lt;/code&gt; is False, the &lt;code&gt;i&lt;/code&gt;-th output column is the input vector raised element-wise to the power of &lt;code&gt;N - i - 1&lt;/code&gt;. Such a matrix with a geometric progression in each row is named for Alexandre- Theophile Vandermonde.</source>
          <target state="translated">输出矩阵的列是输入向量的幂。幂的顺序由 &lt;code&gt;increasing&lt;/code&gt; 布尔参数确定。具体来说，当 &lt;code&gt;increasing&lt;/code&gt; 为False时，第 &lt;code&gt;i&lt;/code&gt; 个输出列是逐元素提高到 &lt;code&gt;N - i - 1&lt;/code&gt; 的幂的输入向量。每行中具有几何级数的矩阵以Alexandre-Theophile Vandermonde的名字命名。</target>
        </trans-unit>
        <trans-unit id="fd5ff7ed1e1b0436ec4f4722206a381ca973b853" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;make test&lt;/code&gt; will ensure that all of the test software is built and then run all three test scripts.</source>
          <target state="translated">命令 &lt;code&gt;make test&lt;/code&gt; 将确保已构建所有测试软件，然后运行所有三个测试脚本。</target>
        </trans-unit>
        <trans-unit id="16227b68a1418fc90dc494649e7c543fabd7409c" translate="yes" xml:space="preserve">
          <source>The command arguments are available in &lt;code&gt;build&lt;/code&gt;, &lt;code&gt;build_clib&lt;/code&gt;, and &lt;code&gt;build_ext&lt;/code&gt;. if &lt;code&gt;build_clib&lt;/code&gt; or &lt;code&gt;build_ext&lt;/code&gt; are not specified by the user, the arguments of &lt;code&gt;build&lt;/code&gt; will be used instead, which also holds the default values.</source>
          <target state="translated">命令参数在 &lt;code&gt;build&lt;/code&gt; ， &lt;code&gt;build_clib&lt;/code&gt; 和 &lt;code&gt;build_ext&lt;/code&gt; 中可用。如果用户未指定 &lt;code&gt;build_clib&lt;/code&gt; 或 &lt;code&gt;build_ext&lt;/code&gt; ，则将改用 &lt;code&gt;build&lt;/code&gt; 参数，该参数也保留默认值。</target>
        </trans-unit>
        <trans-unit id="e66bb28254c2c47afebe31be29c7f178c6baf9ce" translate="yes" xml:space="preserve">
          <source>The committee must agree on a resolution by consensus. If the group cannot reach consensus and deadlocks for over a week, the group will turn the matter over to the Steering Council for resolution.</source>
          <target state="translated">委员会必须以协商一致的方式商定一项决议。如果小组不能达成共识,僵持一周以上,小组将把该事项提交指导委员会解决。</target>
        </trans-unit>
        <trans-unit id="f296a348ca6c5f048bde7ff72475becfa99bfb54" translate="yes" xml:space="preserve">
          <source>The committee will never publicly discuss the issue; all public statements will be made by the chair of the Code of Conduct Committee or the NumPy Steering Council.</source>
          <target state="translated">委员会永远不会公开讨论这个问题;所有的公开声明将由行为准则委员会主席或NumPy指导委员会发表。</target>
        </trans-unit>
        <trans-unit id="1da455687a62d6eecd2b4975d23b71811215c8f1" translate="yes" xml:space="preserve">
          <source>The committee will respond to any report as soon as possible, and at most within 72 hours.</source>
          <target state="translated">委员会将尽快,最多在72小时内对任何报告作出答复。</target>
        </trans-unit>
        <trans-unit id="b080620b2cb81b4501691bc62009a0f3cdee2b1d" translate="yes" xml:space="preserve">
          <source>The committee will then review the incident and determine, to the best of their ability:</source>
          <target state="translated">然后,委员会将对该事件进行审查,并尽其所能地确定:</target>
        </trans-unit>
        <trans-unit id="24aa155f0fb452987333532fc0871b6b96e25258" translate="yes" xml:space="preserve">
          <source>The common data type, which is the maximum of &lt;code&gt;array_types&lt;/code&gt; ignoring &lt;code&gt;scalar_types&lt;/code&gt;, unless the maximum of &lt;code&gt;scalar_types&lt;/code&gt; is of a different kind (&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt;&lt;code&gt;dtype.kind&lt;/code&gt;&lt;/a&gt;). If the kind is not understood, then None is returned.</source>
          <target state="translated">所述公共数据类型，这是最大的 &lt;code&gt;array_types&lt;/code&gt; 忽略 &lt;code&gt;scalar_types&lt;/code&gt; ，除非最大的 &lt;code&gt;scalar_types&lt;/code&gt; 是不同种类的（的&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt; &lt;code&gt;dtype.kind&lt;/code&gt; &lt;/a&gt;）。如果不了解种类，则返回None。</target>
        </trans-unit>
        <trans-unit id="6557c9bc2aa7a334ee156279cd2e6ed26882b290" translate="yes" xml:space="preserve">
          <source>The common fill value, or None.</source>
          <target state="translated">常用的填充值,或无。</target>
        </trans-unit>
        <trans-unit id="792a2de181f669c74b9db5a5aeebd6abe9c93185" translate="yes" xml:space="preserve">
          <source>The common situations in which you need to change byte ordering are:</source>
          <target state="translated">常见的需要改变字节排序的情况有。</target>
        </trans-unit>
        <trans-unit id="c7c4929011c41aa057f46d2bc4e51aaccf9a85a1" translate="yes" xml:space="preserve">
          <source>The companion matrix for power series cannot be made symmetric by scaling the basis, so this function differs from those for the orthogonal polynomials.</source>
          <target state="translated">幂级数的伴生矩阵不能通过缩放基数使其对称,所以这个函数与正交多项式的函数不同。</target>
        </trans-unit>
        <trans-unit id="50728cc7411772baf0d23ae9dab7a04fd085919c" translate="yes" xml:space="preserve">
          <source>The comparison of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; uses standard broadcasting, which means that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; need not have the same shape in order for &lt;code&gt;allclose(a, b)&lt;/code&gt; to evaluate to True. The same is true for &lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/a&gt; but not &lt;a href=&quot;numpy.array_equal#numpy.array_equal&quot;&gt;&lt;code&gt;array_equal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的比较使用标准广播，这意味着 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 不必具有相同的形状即可使 &lt;code&gt;allclose(a, b)&lt;/code&gt; 评估为True。对于&lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt; &lt;code&gt;equal&lt;/code&gt; ,&lt;/a&gt;但不是&lt;a href=&quot;numpy.array_equal#numpy.array_equal&quot;&gt; &lt;code&gt;array_equal&lt;/code&gt; ,&lt;/a&gt;这同样适用。</target>
        </trans-unit>
        <trans-unit id="ed9a376f5659e4753c56a46ffbea586e1c5b762b" translate="yes" xml:space="preserve">
          <source>The complex conjugate of &lt;code&gt;x&lt;/code&gt;, with same dtype as &lt;code&gt;y&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的复共轭，与 &lt;code&gt;y&lt;/code&gt; 的 dtype相同。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="d1ca0ff74dd3394813701dd385de23f306fa9c69" translate="yes" xml:space="preserve">
          <source>The complex conjugate of a complex number is obtained by changing the sign of its imaginary part.</source>
          <target state="translated">一个复数的复共轭是通过改变其虚部的符号得到的。</target>
        </trans-unit>
        <trans-unit id="41eb6fa093181f73897902c7f0874292edf29e51" translate="yes" xml:space="preserve">
          <source>The compressed array.</source>
          <target state="translated">压缩阵列。</target>
        </trans-unit>
        <trans-unit id="5eb5823a400c379807aed8ab125dee97f320721d" translate="yes" xml:space="preserve">
          <source>The concatenated array with any masked entries preserved.</source>
          <target state="translated">保留了任何掩码条目的连接数组。</target>
        </trans-unit>
        <trans-unit id="a37868502a5a0d6add95945d1a64803e757adeaa" translate="yes" xml:space="preserve">
          <source>The concatenated array.</source>
          <target state="translated">串联的数组。</target>
        </trans-unit>
        <trans-unit id="3af59c1bb124d9d3dff66fb6d58de527a5027e82" translate="yes" xml:space="preserve">
          <source>The concept of a behaved segment is used in the description of the function pointers. A behaved segment is one that is aligned and in native machine byte-order for the data-type. The &lt;code&gt;nonzero&lt;/code&gt;, &lt;code&gt;copyswap&lt;/code&gt;, &lt;code&gt;copyswapn&lt;/code&gt;, &lt;code&gt;getitem&lt;/code&gt;, and &lt;code&gt;setitem&lt;/code&gt; functions can (and must) deal with mis-behaved arrays. The other functions require behaved memory segments.</source>
          <target state="translated">行为段的概念在函数指针的描述中使用。正常运行的段是对齐的段，并按本机字节顺序排列为数据类型。的 &lt;code&gt;nonzero&lt;/code&gt; ， &lt;code&gt;copyswap&lt;/code&gt; ， &lt;code&gt;copyswapn&lt;/code&gt; ， &lt;code&gt;getitem&lt;/code&gt; 和 &lt;code&gt;setitem&lt;/code&gt; 功能可以（而且必须）处理误表现阵列。其他功能需要正常运行的内存段。</target>
        </trans-unit>
        <trans-unit id="46e686c81ff0f33a7ee42cbdb148b2206e722231" translate="yes" xml:space="preserve">
          <source>The condition number of &lt;code&gt;x&lt;/code&gt; is defined as the norm of &lt;code&gt;x&lt;/code&gt; times the norm of the inverse of &lt;code&gt;x&lt;/code&gt;&lt;a href=&quot;#r611900c44d60-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;; the norm can be the usual L2-norm (root-of-sum-of-squares) or one of a number of other matrix norms.</source>
          <target state="translated">的条件数 &lt;code&gt;x&lt;/code&gt; 被定义为的范数 &lt;code&gt;x&lt;/code&gt; 次的逆的范数 &lt;code&gt;x&lt;/code&gt; &lt;a href=&quot;#r611900c44d60-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; ; 范数可以是通常的L2范数（平方和），也可以是许多其他矩阵范数之一。</target>
        </trans-unit>
        <trans-unit id="7ed508e4defcab357510ceacda28d2924496cd06" translate="yes" xml:space="preserve">
          <source>The condition number of the matrix. May be infinite.</source>
          <target state="translated">矩阵的条件数。可能是无限的。</target>
        </trans-unit>
        <trans-unit id="c901451fe41cf6f1482465c84b6a4c739cbccbff" translate="yes" xml:space="preserve">
          <source>The config file generated from &lt;code&gt;template&lt;/code&gt; is installed in the given install directory, using &lt;code&gt;subst_dict&lt;/code&gt; for variable substitution.</source>
          <target state="translated">从 &lt;code&gt;template&lt;/code&gt; 生成的配置文件安装在给定的安装目录中，使用 &lt;code&gt;subst_dict&lt;/code&gt; 进行变量替换。</target>
        </trans-unit>
        <trans-unit id="2fe0070d6ccb31708b92b4e4ed2caabdfe3d249d" translate="yes" xml:space="preserve">
          <source>The constants &lt;strong&gt;NPY_INTP&lt;/strong&gt; and &lt;strong&gt;NPY_UINTP&lt;/strong&gt; refer to an enumerated integer type that is large enough to hold a pointer on the platform. Index arrays should always be converted to &lt;strong&gt;NPY_INTP&lt;/strong&gt; , because the dimension of the array is of type npy_intp.</source>
          <target state="translated">常量&lt;strong&gt;NPY_INTP&lt;/strong&gt;和&lt;strong&gt;NPY_UINTP&lt;/strong&gt;引用枚举的整数类型，该类型足够大以将指针保持在平台上。索引数组应始终转换为&lt;strong&gt;NPY_INTP&lt;/strong&gt;，因为数组的维类型为npy_intp。</target>
        </trans-unit>
        <trans-unit id="fd8a200b77c06e1513f552e8d61858be6438182d" translate="yes" xml:space="preserve">
          <source>The constructed array.</source>
          <target state="translated">构建的数组。</target>
        </trans-unit>
        <trans-unit id="8c8c3ae23d3b8b9d4c2965f608e114605317b1d2" translate="yes" xml:space="preserve">
          <source>The constructed extension module is saved as &lt;code&gt;&amp;lt;modulename&amp;gt;module.c&lt;/code&gt; to the current directory.</source>
          <target state="translated">构造的扩展模块将作为 &lt;code&gt;&amp;lt;modulename&amp;gt;module.c&lt;/code&gt; 保存到当前目录。</target>
        </trans-unit>
        <trans-unit id="1564bd8e09196ae3556506f90562583aff6d8fc2" translate="yes" xml:space="preserve">
          <source>The content of a modified version of &lt;code&gt;fib1.pyf&lt;/code&gt; (saved as &lt;code&gt;fib2.pyf&lt;/code&gt;) is as follows:</source>
          <target state="translated">&lt;code&gt;fib1.pyf&lt;/code&gt; 的修改版本（保存为 &lt;code&gt;fib2.pyf&lt;/code&gt; ）的内容如下：</target>
        </trans-unit>
        <trans-unit id="6f12164e316c899cbeec8a520db14b994fa35a8e" translate="yes" xml:space="preserve">
          <source>The contiguous constraint applies only to the inner loop, successive inner loops may have arbitrary pointer changes.</source>
          <target state="translated">连续约束只适用于内循环,连续的内循环可能有任意的指针变化。</target>
        </trans-unit>
        <trans-unit id="a28f32d0e2528be0855bfa01e7539cc0e939d215" translate="yes" xml:space="preserve">
          <source>The convenience classes provided by the polynomial package are:</source>
          <target state="translated">多项式包提供的方便类有:。</target>
        </trans-unit>
        <trans-unit id="5a4e9570e8f8bcacc96f206106a01eefad39bd6f" translate="yes" xml:space="preserve">
          <source>The convert method can also convert domain and window:</source>
          <target state="translated">转换方法还可以转换域和窗口。</target>
        </trans-unit>
        <trans-unit id="60131768e228b843852dbff6de95273c5e8b7bcb" translate="yes" xml:space="preserve">
          <source>The converted data-type.</source>
          <target state="translated">转换后的数据类型。</target>
        </trans-unit>
        <trans-unit id="1fc6b89fce1f12a34477c12a69d7cd751ad23c91" translate="yes" xml:space="preserve">
          <source>The convolution operator is often seen in signal processing, where it models the effect of a linear time-invariant system on a signal &lt;a href=&quot;#r95849f33d2b1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. In probability theory, the sum of two independent random variables is distributed according to the convolution of their individual distributions.</source>
          <target state="translated">卷积算子在信号处理中经常见到，它在信号上模拟了线性时不变系统的效果&lt;a href=&quot;#r95849f33d2b1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。在概率论中，两个独立随机变量之和是根据它们各自分布的卷积分布的。</target>
        </trans-unit>
        <trans-unit id="1b7a113f553d13745aed52a84f8c20493ad427e3" translate="yes" xml:space="preserve">
          <source>The coordinates member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure maintains the current N-d counter unless the underlying array is C-contiguous in which case the coordinate counting is by-passed. The index member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the current flat index of the iterator. It is updated by the &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">除非基础数组是C连续的，否则&lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;结构的坐标成员将维护当前的Nd计数器，在这种情况下，绕过坐标计数。&lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;的索引成员跟踪迭代器的当前平面索引。它由&lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt;宏更新。</target>
        </trans-unit>
        <trans-unit id="a60368fcddf184df8cd7ef5081ac979bc50c50f2" translate="yes" xml:space="preserve">
          <source>The coordinates member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure maintains the current N-d counter unless the underlying array is C-contiguous in which case the coordinate counting is by-passed. The index member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the current flat index of the iterator. It is updated by the &lt;a href=&quot;c-api/array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">除非基础数组是C连续的，否则&lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;结构的坐标成员将维护当前的Nd计数器，在这种情况下，将绕过坐标计数。&lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;的索引成员跟踪迭代器的当前平面索引。它由&lt;a href=&quot;c-api/array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt;宏更新。</target>
        </trans-unit>
        <trans-unit id="893c6dfe4a5a151e44d6687fac35fbd3b646a45a" translate="yes" xml:space="preserve">
          <source>The core dimensions are removed from all inputs and the remaining dimensions are broadcast together, defining the loop dimensions.</source>
          <target state="translated">核心维度从所有输入中移除,其余维度一起广播,定义循环维度。</target>
        </trans-unit>
        <trans-unit id="72b350bebf37a78a10162e24af07cb3168e9e839" translate="yes" xml:space="preserve">
          <source>The core of the ufunc is the &lt;a href=&quot;#c.PyUFuncObject&quot;&gt;&lt;code&gt;PyUFuncObject&lt;/code&gt;&lt;/a&gt; which contains all the information needed to call the underlying C-code loops that perform the actual work. While it is described here for completeness, it should be considered internal to NumPy and manipulated via &lt;code&gt;PyUFunc_*&lt;/code&gt; functions. The size of this structure is subject to change across versions of NumPy. To ensure compatibility:</source>
          <target state="translated">&lt;a href=&quot;#c.PyUFuncObject&quot;&gt; &lt;code&gt;PyUFuncObject&lt;/code&gt; &lt;/a&gt;的核心是PyUFuncObject，它包含调用执行实际工作的基础C代码循环所需的所有信息。虽然此处出于完整性考虑对其进行了描述，但应将其视为NumPy的内部内容，并通过 &lt;code&gt;PyUFunc_*&lt;/code&gt; 函数进行操作。此结构的大小可能会在NumPy的各个版本中发生变化。为确保兼容性：</target>
        </trans-unit>
        <trans-unit id="773b5bb85bcdc60b3e588df5ec27ee1692be9141" translate="yes" xml:space="preserve">
          <source>The correct interpretation of the hermitian input depends on the length of the original data, as given by &lt;code&gt;n&lt;/code&gt;. This is because each input shape could correspond to either an odd or even length signal. By default, &lt;a href=&quot;#numpy.fft.hfft&quot;&gt;&lt;code&gt;hfft&lt;/code&gt;&lt;/a&gt; assumes an even output length which puts the last entry at the Nyquist frequency; aliasing with its symmetric counterpart. By Hermitian symmetry, the value is thus treated as purely real. To avoid losing information, the shape of the full signal &lt;strong&gt;must&lt;/strong&gt; be given.</source>
          <target state="translated">厄米输入的正确解释取决于原始数据的长度，如 &lt;code&gt;n&lt;/code&gt; 所示。这是因为每种输入形状可能对应于奇数或偶数长度的信号。默认情况下，&lt;a href=&quot;#numpy.fft.hfft&quot;&gt; &lt;code&gt;hfft&lt;/code&gt; &lt;/a&gt;假定输出长度为偶数，这会将最后一个条目置于奈奎斯特频率下。与其对称对应物混叠。通过埃尔米特对称性，该值因此被视为纯实数。为了避免丢失信息，&lt;strong&gt;必须&lt;/strong&gt;给出完整信号的形状。</target>
        </trans-unit>
        <trans-unit id="b5b1507243ebb36968e1fec7c90425484cafd21a" translate="yes" xml:space="preserve">
          <source>The correct interpretation of the hermitian input depends on the length of the original data, as given by &lt;code&gt;n&lt;/code&gt;. This is because each input shape could correspond to either an odd or even length signal. By default, &lt;a href=&quot;#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; assumes an even output length which puts the last entry at the Nyquist frequency; aliasing with its symmetric counterpart. By Hermitian symmetry, the value is thus treated as purely real. To avoid losing information, the correct length of the real input &lt;strong&gt;must&lt;/strong&gt; be given.</source>
          <target state="translated">厄米输入的正确解释取决于原始数据的长度，如 &lt;code&gt;n&lt;/code&gt; 所示。这是因为每种输入形状可能对应于奇数或偶数长度的信号。默认情况下，&lt;a href=&quot;#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt;假定输出长度为偶数，这将最后一个条目置于奈奎斯特频率下。与其对称对应物混叠。通过埃尔米特对称性，该值因此被视为纯实数。为了避免丢失信息，&lt;strong&gt;必须&lt;/strong&gt;给出真实输入的正确长度。</target>
        </trans-unit>
        <trans-unit id="37beab5b2e24a56105c7c01133a885f5a78e9481" translate="yes" xml:space="preserve">
          <source>The correct interpretation of the hermitian input depends on the shape of the original data, as given by &lt;code&gt;s&lt;/code&gt;. This is because each input shape could correspond to either an odd or even length signal. By default, &lt;a href=&quot;#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt; assumes an even output length which puts the last entry at the Nyquist frequency; aliasing with its symmetric counterpart. When performing the final complex to real transform, the last value is thus treated as purely real. To avoid losing information, the correct shape of the real input &lt;strong&gt;must&lt;/strong&gt; be given.</source>
          <target state="translated">厄米输入的正确解释取决于 &lt;code&gt;s&lt;/code&gt; 给出的原始数据的形状。这是因为每种输入形状可能对应于奇数或偶数长度的信号。默认情况下，&lt;a href=&quot;#numpy.fft.irfftn&quot;&gt; &lt;code&gt;irfftn&lt;/code&gt; &lt;/a&gt;假定输出长度为偶数，这将最后一个条目置于奈奎斯特频率下。与其对称对应物混叠。当执行最终的复数到实数转换时，最后一个值因此被视为纯实数。为了避免丢失信息，&lt;strong&gt;必须&lt;/strong&gt;给出真实输入的正确形状。</target>
        </trans-unit>
        <trans-unit id="76b4be14cc8fe5491309195ba608e3525321fc00" translate="yes" xml:space="preserve">
          <source>The correlation coefficient matrix of the variables.</source>
          <target state="translated">变量的相关系数矩阵。</target>
        </trans-unit>
        <trans-unit id="f4e710373f0588180cd5157b94f36ff64a509ad5" translate="yes" xml:space="preserve">
          <source>The corresponding angle in degrees. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的角度（以度为单位）。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="a2c63fcb50ab2a66bb9a9ad01ce9f4ff69c1d271" translate="yes" xml:space="preserve">
          <source>The corresponding angle in radians. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的角度（以弧度为单位）。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="1f2189e088542b025710d6c9de389530dc9fecea" translate="yes" xml:space="preserve">
          <source>The corresponding argument is a function provided by user. The signature of this so-called call-back function can be defined</source>
          <target state="translated">相应的参数是用户提供的一个函数。这个所谓的回调函数的签名可以定义为</target>
        </trans-unit>
        <trans-unit id="f35b3b067b2fb40c400d505d2d253ac20a239da1" translate="yes" xml:space="preserve">
          <source>The corresponding argument is considered as a required one. This is default. You need to specify &lt;code&gt;required&lt;/code&gt; only if there is a need to disable automatic &lt;code&gt;optional&lt;/code&gt; setting when &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; is used.</source>
          <target state="translated">相应的参数被认为是必需的。这是默认值。仅当使用 &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; 时需要禁用自动 &lt;code&gt;optional&lt;/code&gt; 设置时，才需要指定&amp;ldquo; &lt;code&gt;required&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b483a77dd25e17d676f790b212de11141a0187e" translate="yes" xml:space="preserve">
          <source>The corresponding argument is moved to the end of &lt;code&gt;&amp;lt;optional
arguments&amp;gt;&lt;/code&gt; list. A default value for an optional argument can be specified &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt;, see &lt;code&gt;entitydecl&lt;/code&gt; definition. Note that the default value must be given as a valid C expression.</source>
          <target state="translated">相应的参数将移动到 &lt;code&gt;&amp;lt;optional arguments&amp;gt;&lt;/code&gt; 列表的末尾。可选参数的默认值可以指定为 &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; ，请参见 &lt;code&gt;entitydecl&lt;/code&gt; 定义。请注意，默认值必须作为有效的C表达式给出。</target>
        </trans-unit>
        <trans-unit id="1050e106455b1ea647f4b0ec3bf8ddb674675631" translate="yes" xml:space="preserve">
          <source>The corresponding array scalar type is &lt;a href=&quot;arrays.scalars#numpy.int32&quot;&gt;&lt;code&gt;int32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对应的数组标量类型为&lt;a href=&quot;arrays.scalars#numpy.int32&quot;&gt; &lt;code&gt;int32&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2babda63010514076aef395fac45645683b9564" translate="yes" xml:space="preserve">
          <source>The corresponding array scalar type is &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="translated">对应的数组标量类型为 &lt;code&gt;int32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd11fa4205dd5b33a3e2b183413534954599bad7" translate="yes" xml:space="preserve">
          <source>The corresponding cosine values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">对应的余弦值。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="6d98f6605847a59a64fcad02a0b3d4fdfd44ca3d" translate="yes" xml:space="preserve">
          <source>The corresponding degree values; if &lt;code&gt;out&lt;/code&gt; was supplied this is a reference to it. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的度值；如果 &lt;code&gt;out&lt;/code&gt; 供给，这是它的一个引用。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="2584010810109879710934f24451582df80fa088" translate="yes" xml:space="preserve">
          <source>The corresponding hyperbolic sine values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的双曲正弦值。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="2f46b05f80b785698faf42d321e3104fa7625e8a" translate="yes" xml:space="preserve">
          <source>The corresponding hyperbolic tangent values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的双曲正切值。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="d9ca95035c9f509708b9e99487c1ebe9e3ab11bd" translate="yes" xml:space="preserve">
          <source>The corresponding radian values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的弧度值。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="c1e4a7360c69977ad10edc5bee560d5ac06dcf90" translate="yes" xml:space="preserve">
          <source>The corresponding tangent values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的切线值。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="794da0dacd34a3a537b8957b7fa2b5dd6a0fb954" translate="yes" xml:space="preserve">
          <source>The corresponding user-provided Python function are then:</source>
          <target state="translated">相应的用户提供的Python函数则是。</target>
        </trans-unit>
        <trans-unit id="b0e664cdf4ef8fa1adefc68661d3976d497abf20" translate="yes" xml:space="preserve">
          <source>The corresponding variable is Fortran 90 allocatable array defined as Fortran 90 module data.</source>
          <target state="translated">对应的变量是Fortran 90可分配数组,定义为Fortran 90模块数据。</target>
        </trans-unit>
        <trans-unit id="48e42f957c48b62c124f0261112a23bae77caa2c" translate="yes" xml:space="preserve">
          <source>The corresponding variable is a parameter and it must have a fixed value. F2PY replaces all parameter occurrences by their corresponding values.</source>
          <target state="translated">对应的变量是一个参数,它必须有一个固定的值。F2PY用相应的值代替所有参数的出现。</target>
        </trans-unit>
        <trans-unit id="c2320966ba7c65e57cb9263bdefeef1fa1cb2d7e" translate="yes" xml:space="preserve">
          <source>The corresponding variable is considered as an array with given dimensions in &lt;code&gt;&amp;lt;arrayspec&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">相应的变量被视为 &lt;code&gt;&amp;lt;arrayspec&amp;gt;&lt;/code&gt; 中具有给定尺寸的数组。</target>
        </trans-unit>
        <trans-unit id="f1763b6e0e62ea8d29f68696fab1bd4ea96474d4" translate="yes" xml:space="preserve">
          <source>The cost for a matrix multiplication can be calculated with the following function:</source>
          <target state="translated">矩阵乘法的成本可以用以下函数计算:</target>
        </trans-unit>
        <trans-unit id="6933bada15117031adec212786a3dbdf77a91aff" translate="yes" xml:space="preserve">
          <source>The costs for the two different parenthesizations are as follows:</source>
          <target state="translated">两种不同括号的费用如下:</target>
        </trans-unit>
        <trans-unit id="71417050531966fa2bba7739241abcc4b67310e0" translate="yes" xml:space="preserve">
          <source>The counterclockwise angle from the positive real axis on the complex plane in the range &lt;code&gt;(-pi, pi]&lt;/code&gt;, with dtype as numpy.float64.</source>
          <target state="translated">与复平面上的正实轴的逆时针角度在 &lt;code&gt;(-pi, pi]&lt;/code&gt; 范围内， dtype为numpy.float64。</target>
        </trans-unit>
        <trans-unit id="1b6aacea9be65b883730cfcba5386d3d1b9a0223" translate="yes" xml:space="preserve">
          <source>The cov input is used to compute a factor matrix A such that &lt;code&gt;A @ A.T = cov&lt;/code&gt;. This argument is used to select the method used to compute the factor matrix A. The default method &amp;lsquo;svd&amp;rsquo; is the slowest, while &amp;lsquo;cholesky&amp;rsquo; is the fastest but less robust than the slowest method. The method &lt;code&gt;eigh&lt;/code&gt; uses eigen decomposition to compute A and is faster than svd but slower than cholesky.</source>
          <target state="translated">cov输入用于计算因子矩阵A，使得 &lt;code&gt;A @ A.T = cov&lt;/code&gt; 。此参数用于选择用于计算因子矩阵A的方法。默认方法&amp;ldquo; svd&amp;rdquo;是最慢的方法，而&amp;ldquo; cholestsky&amp;rdquo;是最快但较慢的方法更不可靠的方法。该方法 &lt;code&gt;eigh&lt;/code&gt; 使用特征分解来计算A，比svd更快，但比cholesky慢。</target>
        </trans-unit>
        <trans-unit id="703b92f1857fec3346f55e95a27ed079fdf918ac" translate="yes" xml:space="preserve">
          <source>The covariance matrix of the variables.</source>
          <target state="translated">变量的协方差矩阵。</target>
        </trans-unit>
        <trans-unit id="f56bfc3801b5981a49e90ddd94a5011933b03e11" translate="yes" xml:space="preserve">
          <source>The cross product of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in</source>
          <target state="translated">的叉积 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 中</target>
        </trans-unit>
        <trans-unit id="430c46a913654deeda9ef3928a00e710ee9f7b73" translate="yes" xml:space="preserve">
          <source>The ctypes attribute of an ndarray is also endowed with additional attributes that may be convenient when passing additional information about the array into a ctypes function. The attributes &lt;strong&gt;data&lt;/strong&gt;, &lt;strong&gt;shape&lt;/strong&gt;, and &lt;strong&gt;strides&lt;/strong&gt; can provide ctypes compatible types corresponding to the data-area, the shape, and the strides of the array. The data attribute returns a &lt;code&gt;c_void_p&lt;/code&gt; representing a pointer to the data area. The shape and strides attributes each return an array of ctypes integers (or None representing a NULL pointer, if a 0-d array). The base ctype of the array is a ctype integer of the same size as a pointer on the platform. There are also methods &lt;code&gt;data_as({ctype})&lt;/code&gt;, &lt;code&gt;shape_as(&amp;lt;base ctype&amp;gt;)&lt;/code&gt;, and &lt;code&gt;strides_as(&amp;lt;base
ctype&amp;gt;)&lt;/code&gt;. These return the data as a ctype object of your choice and the shape/strides arrays using an underlying base type of your choice. For convenience, the &lt;code&gt;ctypeslib&lt;/code&gt; module also contains &lt;code&gt;c_intp&lt;/code&gt; as a ctypes integer data-type whose size is the same as the size of &lt;code&gt;c_void_p&lt;/code&gt; on the platform (its value is None if ctypes is not installed).</source>
          <target state="translated">ndarray的ctypes属性还具有其他属性，当将有关数组的其他信息传递给ctypes函数时，这些属性可能很方便。属性&lt;strong&gt;data&lt;/strong&gt;，&lt;strong&gt;shape&lt;/strong&gt;和&lt;strong&gt;stride&lt;/strong&gt;可以提供与数组的数据区域，形状和步幅相对应的ctype兼容类型。数据属性返回一个 &lt;code&gt;c_void_p&lt;/code&gt; ,表示指向数据区域的指针。 shape和stride属性每个都返回一个ctypes整数数组（如果为0-d数组，则返回None表示NULL指针）。数组的基本ctype是与平台上的指针大小相同的ctype整数。还有方法 &lt;code&gt;data_as({ctype})&lt;/code&gt; ， &lt;code&gt;shape_as(&amp;lt;base ctype&amp;gt;)&lt;/code&gt; 和 &lt;code&gt;strides_as(&amp;lt;base ctype&amp;gt;)&lt;/code&gt; 。这些返回数据作为您选择的ctype对象，并使用您选择的基础基本类型返回shape / strides数组。为了方便起见， &lt;code&gt;ctypeslib&lt;/code&gt; 模块还包含 &lt;code&gt;c_intp&lt;/code&gt; 作为ctypes整数数据类型，其大小与平台上 &lt;code&gt;c_void_p&lt;/code&gt; 的大小相同（如果未安装ctypes，则其值为None）。</target>
        </trans-unit>
        <trans-unit id="d70737d8a9b599cea578eef90e469f4ec5cade8d" translate="yes" xml:space="preserve">
          <source>The cumulative product for each column (i.e., over the rows) of &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">对于每列（即，在所述行）所述累积产 &lt;code&gt;a&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4974aaba8d216c55c50471b0bc56ddd6323d0ebc" translate="yes" xml:space="preserve">
          <source>The cumulative product for each row (i.e. over the columns) of &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">对于每一行（即在列）累计产品 &lt;code&gt;a&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="50631d91282d5f6763c8dcfd14a90d74339342d9" translate="yes" xml:space="preserve">
          <source>The current (1-d) index into the broadcasted result.</source>
          <target state="translated">当前(1-d)索引进入广播结果。</target>
        </trans-unit>
        <trans-unit id="8c233acaa927b0b3ae6437f9077a3fae3621ed5f" translate="yes" xml:space="preserve">
          <source>The current 1-d index into the array.</source>
          <target state="translated">数组中当前的1-d索引。</target>
        </trans-unit>
        <trans-unit id="2fbbd9d31a318df9bc191ffa89f350440a39a71f" translate="yes" xml:space="preserve">
          <source>The current Python interface to the &lt;code&gt;f2py&lt;/code&gt; module is not mature and may change in the future.</source>
          <target state="translated">&lt;code&gt;f2py&lt;/code&gt; 模块的当前Python接口尚未成熟，将来可能会更改。</target>
        </trans-unit>
        <trans-unit id="cbb3baf8a681bbb5337a5050d23b30de4d838c39" translate="yes" xml:space="preserve">
          <source>The current error handler. If no handler was set through &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">当前的错误处理程序。如果没有通过&lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt;设置处理程序，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67a8fb2d19e8571c91416871498dce96f7ad1021" translate="yes" xml:space="preserve">
          <source>The current info on building and releasing NumPy and SciPy is scattered in several places. It should be summarized in one place, updated, and where necessary described in more detail. The sections below list all places where useful info can be found.</source>
          <target state="translated">目前关于构建和发布NumPy和SciPy的信息分散在几个地方。应该将其归纳在一个地方,进行更新,并在必要时进行更详细的描述。以下部分列出了所有可以找到有用信息的地方。</target>
        </trans-unit>
        <trans-unit id="fcd1e82b97c62204928be3c1426e12c2f8f2093c" translate="yes" xml:space="preserve">
          <source>The current interface remains unchanged, and &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; can still be used to implement (specialized) ufuncs, consisting of scalar elementary functions.</source>
          <target state="translated">当前接口保持不变，并且 &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; 仍可用于实现（特殊的）ufunc，它由标量基本函数组成。</target>
        </trans-unit>
        <trans-unit id="0ec2778c22d5d6f2fae8e55f79998855331eeed7" translate="yes" xml:space="preserve">
          <source>The current membership of the NumFOCUS Subcommittee is listed at the page &lt;a href=&quot;people#governance-people&quot;&gt;Current steering council and institutional partners&lt;/a&gt;.</source>
          <target state="translated">NumFOCUS小组委员会的当前成员资格在&amp;ldquo;&lt;a href=&quot;people#governance-people&quot;&gt;当前指导委员会和机构合作伙伴&lt;/a&gt;&amp;rdquo;页面中列出。</target>
        </trans-unit>
        <trans-unit id="6ddf5c702a9dae519e990225b8843e9d50a71303" translate="yes" xml:space="preserve">
          <source>The current version of the C-API.</source>
          <target state="translated">当前版本的C-API。</target>
        </trans-unit>
        <trans-unit id="c61490656f67eede266b093f71fb6862a43e638d" translate="yes" xml:space="preserve">
          <source>The current version of the ndarray object (check to see if this variable is defined to guarantee the &lt;code&gt;numpy/arrayobject.h&lt;/code&gt; header is being used).</source>
          <target state="translated">ndarray对象的当前版本（检查是否已定义此变量以确保使用了 &lt;code&gt;numpy/arrayobject.h&lt;/code&gt; 标头）。</target>
        </trans-unit>
        <trans-unit id="4809e84f7d3a9eb68e3d6e9384c7ac43b19e108c" translate="yes" xml:space="preserve">
          <source>The current version of the ndarray object (check to see if this variable is defined to guarantee the numpy/arrayobject.h header is being used).</source>
          <target state="translated">ndarray对象的当前版本(检查是否定义了这个变量以保证numpy/arrayobject.h头被使用)。</target>
        </trans-unit>
        <trans-unit id="5a1853977173afb941f37a0bea064ac890d366c2" translate="yes" xml:space="preserve">
          <source>The data actually stored in object arrays (&lt;em&gt;i.e.&lt;/em&gt;, arrays having dtype &lt;a href=&quot;#numpy.object_&quot;&gt;&lt;code&gt;object_&lt;/code&gt;&lt;/a&gt;) are references to Python objects, not the objects themselves. Hence, object arrays behave more like usual Python &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt;&lt;code&gt;lists&lt;/code&gt;&lt;/a&gt;, in the sense that their contents need not be of the same Python type.</source>
          <target state="translated">实际存储在对象数组（&lt;em&gt;即&lt;/em&gt;，具有&lt;a href=&quot;#numpy.object_&quot;&gt; &lt;code&gt;object_&lt;/code&gt; &lt;/a&gt;数组）中的数据是对Python对象的引用，而不是对象本身。因此，对象数组的行为更像是普通的Python&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt; &lt;code&gt;lists&lt;/code&gt; &lt;/a&gt;，从某种意义上说，它们的内容不必是同一Python类型。</target>
        </trans-unit>
        <trans-unit id="d02692cc2b9183733a0e1ac33e907e722f2cb651" translate="yes" xml:space="preserve">
          <source>The data actually stored in object arrays (&lt;em&gt;i.e.&lt;/em&gt;, arrays having dtype &lt;code&gt;object_&lt;/code&gt;) are references to Python objects, not the objects themselves. Hence, object arrays behave more like usual Python &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt;&lt;code&gt;lists&lt;/code&gt;&lt;/a&gt;, in the sense that their contents need not be of the same Python type.</source>
          <target state="translated">实际上存储在对象数组（&lt;em&gt;即&lt;/em&gt;，具有 &lt;code&gt;object_&lt;/code&gt; 数组）中的数据是对Python对象的引用，而不是对象本身。因此，对象数组的行为更像是普通的Python &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt; &lt;code&gt;lists&lt;/code&gt; &lt;/a&gt;，从某种意义上说，它们的内容不必是相同的Python类型。</target>
        </trans-unit>
        <trans-unit id="2b8f4fa1516918fd8297afcfb360ffa13708823d" translate="yes" xml:space="preserve">
          <source>The data and all elements are aligned appropriately for the hardware.</source>
          <target state="translated">数据和所有的元素都是针对硬件进行适当的排列。</target>
        </trans-unit>
        <trans-unit id="3286aa81b485c3d7add58cb76776a5c44fcb4bf2" translate="yes" xml:space="preserve">
          <source>The data area and all array elements are aligned appropriately.</source>
          <target state="translated">数据区和所有的数组元素都适当地对齐。</target>
        </trans-unit>
        <trans-unit id="c1365a86184a90bddcccd2199d804c180d307014" translate="yes" xml:space="preserve">
          <source>The data area can be written to.</source>
          <target state="translated">可以写入数据区。</target>
        </trans-unit>
        <trans-unit id="539587e7a7889df8e80a73151cc3ac06f87c111c" translate="yes" xml:space="preserve">
          <source>The data area can be written to. Setting this to False locks the data, making it read-only. A view (slice, etc.) inherits WRITEABLE from its base array at creation time, but a view of a writeable array may be subsequently locked while the base array remains writeable. (The opposite is not true, in that a view of a locked array may not be made writeable. However, currently, locking a base object does not lock any views that already reference it, so under that circumstance it is possible to alter the contents of a locked array via a previously created writeable view onto it.) Attempting to change a non-writeable array raises a RuntimeError exception.</source>
          <target state="translated">数据区域可以被写入。将此设置为False会锁定数据,使其成为只读数据。视图(片等)在创建时从它的基数组继承WRITEABLE,但一个可写数组的视图可能随后被锁定,而基数组仍可写。(反之则不然,一个被锁定的数组的视图可能不会被变成可写的)。然而,目前,锁定一个基础对象并不会锁定任何已经引用它的视图,所以在这种情况下,可以通过先前创建的可写视图来改变一个锁定数组的内容。)试图改变一个非可写数组会引发一个RuntimeError异常。</target>
        </trans-unit>
        <trans-unit id="dfe7ced9a654feaf927f01f408558bf43f63134c" translate="yes" xml:space="preserve">
          <source>The data area is in C-style contiguous order (last index varies the fastest).</source>
          <target state="translated">数据区采用C式连续顺序(最后一个索引变化最快)。</target>
        </trans-unit>
        <trans-unit id="28271e4f2d83215b5c3293be14583eebd0638934" translate="yes" xml:space="preserve">
          <source>The data area is in Fortran-style contiguous order (first index varies the fastest).</source>
          <target state="translated">数据区按Fortran式的连续顺序(第一索引变化最快)。</target>
        </trans-unit>
        <trans-unit id="a2e621a0b9254b737a1faf535f1456a6f33c01ae" translate="yes" xml:space="preserve">
          <source>The data area is owned by this array.</source>
          <target state="translated">数据区由这个数组拥有。</target>
        </trans-unit>
        <trans-unit id="ca9e054ad351441ecdb18cea4952500858e11b12" translate="yes" xml:space="preserve">
          <source>The data area represents a (well-behaved) copy whose information should be transferred back to the original when &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">数据区域表示一个（行为良好的）副本，当&lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;时，其信息应传输回原始文件。</target>
        </trans-unit>
        <trans-unit id="ffc8a46da91112c07e5b1f8d0c8b1ad0c0413487" translate="yes" xml:space="preserve">
          <source>The data file contains data of different types and is organized as follows:</source>
          <target state="translated">数据文件包含不同类型的数据,组织结构如下:</target>
        </trans-unit>
        <trans-unit id="15eb3cf2a1c1abdf07a79e9fe9ea7b5a63c62afd" translate="yes" xml:space="preserve">
          <source>The data in the array is returned as a single string. This function is similar to &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt;, the difference being that &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt; also returns information on the kind of array and its data type.</source>
          <target state="translated">数组中的数据作为单个字符串返回。此函数类似于&lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt;，不同之处在于&lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt;还返回有关数组类型及其数据类型的信息。</target>
        </trans-unit>
        <trans-unit id="4cbbe8ca710f692f60ad1bfe0fc2af00b27f6fa9" translate="yes" xml:space="preserve">
          <source>The data in the same field can be heterogeneous, they will be promoted to the highest data type. This method is intended for creating smaller record arrays. If used to create large array without formats defined</source>
          <target state="translated">同一字段中的数据可以是异构的,它们将被提升到最高的数据类型。此方法用于创建较小的记录数组。如果用于创建没有定义格式的大数组</target>
        </trans-unit>
        <trans-unit id="f030fb38724d73d189a884d6cd4eaca4e1c69e90" translate="yes" xml:space="preserve">
          <source>The data is in a single, C-style contiguous segment.</source>
          <target state="translated">数据是在一个单一的C型连续段中。</target>
        </trans-unit>
        <trans-unit id="5f1d8da4b437441472e9916d9ae01c496d02e5d4" translate="yes" xml:space="preserve">
          <source>The data is in a single, Fortran-style contiguous segment.</source>
          <target state="translated">数据是在一个单一的、Fortran式的连续段中。</target>
        </trans-unit>
        <trans-unit id="56a1a480524e7bf67ab594cb10c3c6101b00713c" translate="yes" xml:space="preserve">
          <source>The data of the resulting array will not be byteswapped, but will be interpreted correctly.</source>
          <target state="translated">结果数组的数据不会被字节交换,但会被正确解释。</target>
        </trans-unit>
        <trans-unit id="b88d2dbaff9987ad87362817ef4a120d93a6244e" translate="yes" xml:space="preserve">
          <source>The data to be histogrammed.</source>
          <target state="translated">要进行直方图测量的数据。</target>
        </trans-unit>
        <trans-unit id="5386b778229b14d65914edc6d972b4efb28b5001" translate="yes" xml:space="preserve">
          <source>The data type object associated with the array can be found in the &lt;a href=&quot;generated/numpy.ndarray.dtype#numpy.ndarray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; attribute:</source>
          <target state="translated">与数组关联的数据类型对象可以在&lt;a href=&quot;generated/numpy.ndarray.dtype#numpy.ndarray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;属性中找到：</target>
        </trans-unit>
        <trans-unit id="1c7886ffa6332318e280aa7625497d4df1ee7f24" translate="yes" xml:space="preserve">
          <source>The data type of &lt;code&gt;rep&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rep&lt;/code&gt; 的数据类型。</target>
        </trans-unit>
        <trans-unit id="4b822d3fbc39f811ebad48ba4194f76d214d3123" translate="yes" xml:space="preserve">
          <source>The data type of an operand with this flag should be either &lt;a href=&quot;c-api.dtype#c.NPY_BOOL&quot;&gt;&lt;code&gt;NPY_BOOL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_MASK&quot;&gt;&lt;code&gt;NPY_MASK&lt;/code&gt;&lt;/a&gt;, or a struct dtype whose fields are all valid mask dtypes. In the latter case, it must match up with a struct operand being WRITEMASKED, as it is specifying a mask for each field of that array.</source>
          <target state="translated">具有此标志的操作数的数据类型应为&lt;a href=&quot;c-api.dtype#c.NPY_BOOL&quot;&gt; &lt;code&gt;NPY_BOOL&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.dtype#c.NPY_MASK&quot;&gt; &lt;code&gt;NPY_MASK&lt;/code&gt; &lt;/a&gt;或结构dtype，其字段均为有效的掩码dtype。在后一种情况下，它必须与结构操作数WRITEMASKED相匹配，因为它正在为该数组的每个字段指定一个掩码。</target>
        </trans-unit>
        <trans-unit id="ba40ae5f60c6c9bf8317272fcf427a71c0e5f01a" translate="yes" xml:space="preserve">
          <source>The data type of an operand with this flag should be either &lt;a href=&quot;dtype#c.NPY_BOOL&quot;&gt;&lt;code&gt;NPY_BOOL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_MASK&quot;&gt;&lt;code&gt;NPY_MASK&lt;/code&gt;&lt;/a&gt;, or a struct dtype whose fields are all valid mask dtypes. In the latter case, it must match up with a struct operand being WRITEMASKED, as it is specifying a mask for each field of that array.</source>
          <target state="translated">具有此标志的操作数的数据类型应为&lt;a href=&quot;dtype#c.NPY_BOOL&quot;&gt; &lt;code&gt;NPY_BOOL&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;dtype#c.NPY_MASK&quot;&gt; &lt;code&gt;NPY_MASK&lt;/code&gt; &lt;/a&gt;或结构dtype，其字段均为有效的掩码dtype。在后一种情况下，它必须与结构操作数WRITEMASKED匹配，因为它正在为该数组的每个字段指定一个掩码。</target>
        </trans-unit>
        <trans-unit id="7bb62a4898d6e5e76b1d210de9cba3c87352d927" translate="yes" xml:space="preserve">
          <source>The data type of the array if we are creating a new file in &amp;ldquo;write&amp;rdquo; mode, if not, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is ignored. The default value is None, which results in a data-type of &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;float64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要在&amp;ldquo;写入&amp;rdquo;模式下创建新文件，则为数组的数据类型，否则，将忽略&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;。默认值为None，这将导致数据类型为&lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt; &lt;code&gt;float64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11db59fda83e28216c250b45f855268127882d3e" translate="yes" xml:space="preserve">
          <source>The data type of the array; default: float. For binary input data, the data must be in exactly this format.</source>
          <target state="translated">数组的数据类型,默认:float。对于二进制输入数据,数据必须是这种格式。</target>
        </trans-unit>
        <trans-unit id="7ef4dd0c7cf28c23f4cb2015d84e3c63ca538a1e" translate="yes" xml:space="preserve">
          <source>The data type of the array; default: float. For binary input data, the data must be in exactly this format. Most builtin numeric types are supported and extension types may be supported.</source>
          <target state="translated">数组的数据类型,默认:float。对于二进制输入数据,数据必须是这种格式。支持大多数内置的数字类型,也可以支持扩展类型。</target>
        </trans-unit>
        <trans-unit id="6121c8d9cd39c4f61e9ffef0d098e3b7d36639d6" translate="yes" xml:space="preserve">
          <source>The data type of the output of &lt;code&gt;vectorized&lt;/code&gt; is determined by calling the function with the first element of the input. This can be avoided by specifying the &lt;code&gt;otypes&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;vectorized&lt;/code&gt; 输出的数据类型是通过使用输入的第一个元素调用函数来确定的。通过指定 &lt;code&gt;otypes&lt;/code&gt; 参数可以避免这种情况。</target>
        </trans-unit>
        <trans-unit id="bc2814a7f847db35d30b7458174ec64d03a7e7a5" translate="yes" xml:space="preserve">
          <source>The data type of the view. The dtype size of the view can not be larger than that of the array itself.</source>
          <target state="translated">视图的数据类型。视图的dtype大小不能大于数组本身。</target>
        </trans-unit>
        <trans-unit id="99643c3f7e25f9a00992f90ee5d0bdd7cb79f63e" translate="yes" xml:space="preserve">
          <source>The data types of the values provided in &lt;a href=&quot;numpy.nditer.value#numpy.nditer.value&quot;&gt;&lt;code&gt;value&lt;/code&gt;&lt;/a&gt;. This may be different from the operand data types if buffering is enabled. Valid only before the iterator is closed.</source>
          <target state="translated">value中提供的&lt;a href=&quot;numpy.nditer.value#numpy.nditer.value&quot;&gt; &lt;code&gt;value&lt;/code&gt; &lt;/a&gt;的数据类型。如果启用了缓冲，这可能与操作数数据类型不同。仅在关闭迭代器之前有效。</target>
        </trans-unit>
        <trans-unit id="9d016fef105a6db00651ac782a1c7e9c999e6600" translate="yes" xml:space="preserve">
          <source>The data-type is an important abstraction of the ndarray. Operations will look to the data-type to provide the key functionality that is needed to operate on the array. This functionality is provided in the list of function pointers pointed to by the &amp;lsquo;f&amp;rsquo; member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure. In this way, the number of data-types can be extended simply by providing a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure with suitable function pointers in the &amp;lsquo;f&amp;rsquo; member. For built-in types there are some optimizations that by-pass this mechanism, but the point of the data- type abstraction is to allow new data-types to be added.</source>
          <target state="translated">数据类型是ndarray的重要抽象。操作将寻找数据类型，以提供对阵列进行操作所需的关键功能。在&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;结构的'f'成员指向的函数指针列表中提供了此功能。这样，只需在&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;结构中为'f'成员提供适当的函数指针，即可扩展数据类型的数量。对于内置类型，有一些绕过此机制的优化，但是数据类型抽象的要点是允许添加新的数据类型。</target>
        </trans-unit>
        <trans-unit id="3bc7ca60ba414cbf4855ce7f1e99de3ef90f6929" translate="yes" xml:space="preserve">
          <source>The data-type is an important abstraction of the ndarray. Operations will look to the data-type to provide the key functionality that is needed to operate on the array. This functionality is provided in the list of function pointers pointed to by the &amp;lsquo;f&amp;rsquo; member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure. In this way, the number of data-types can be extended simply by providing a &lt;a href=&quot;c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure with suitable function pointers in the &amp;lsquo;f&amp;rsquo; member. For built-in types there are some optimizations that by-pass this mechanism, but the point of the data- type abstraction is to allow new data-types to be added.</source>
          <target state="translated">数据类型是ndarray的重要抽象。操作将着眼于数据类型，以提供对阵列进行操作所需的关键功能。在&lt;a href=&quot;c-api/types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;结构的'f'成员指向的函数指针列表中提供了此功能。这样，只需在&lt;a href=&quot;c-api/types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;结构中为'f'成员提供合适的函数指针，即可扩展数据类型的数量。对于内置类型，有一些绕过此机制的优化，但是数据类型抽象的要点是允许添加新的数据类型。</target>
        </trans-unit>
        <trans-unit id="b58fbdafeaa8107e58c408c096a3cb8ca5d659d7" translate="yes" xml:space="preserve">
          <source>The data-type of the returned array.</source>
          <target state="translated">返回数组的数据类型。</target>
        </trans-unit>
        <trans-unit id="2fa997f7f869fcd4a6074bb94b595bafa78357ab" translate="yes" xml:space="preserve">
          <source>The data-type used to interpret the file contents. Default is &lt;a href=&quot;../arrays.scalars#numpy.uint8&quot;&gt;&lt;code&gt;uint8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于解释文件内容的数据类型。默认值为&lt;a href=&quot;../arrays.scalars#numpy.uint8&quot;&gt; &lt;code&gt;uint8&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c8d679fa5d2836b35d4e189ea3c3c42c4a9bfcc" translate="yes" xml:space="preserve">
          <source>The data-type used to interpret the file contents. Default is &lt;code&gt;uint8&lt;/code&gt;.</source>
          <target state="translated">用于解释文件内容的数据类型。默认值为 &lt;code&gt;uint8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1e17b816f5aa8d3b539033dd4f8579bd040ce7c" translate="yes" xml:space="preserve">
          <source>The data-type used to represent the intermediate results. Defaults to the data-type of the output array if such is provided, or the the data-type of the input array if no output array is provided.</source>
          <target state="translated">用于表示中间结果的数据类型。如果有输出数组,默认为输出数组的数据类型,如果没有输出数组,默认为输入数组的数据类型。</target>
        </trans-unit>
        <trans-unit id="932e882a29033e270334b0a0ca27c7a0b749d38c" translate="yes" xml:space="preserve">
          <source>The data-type-descriptor object of the base-type.</source>
          <target state="translated">基类型的数据类型描述符对象。</target>
        </trans-unit>
        <trans-unit id="4cbb5795026a8150753d0425fdbf885e8015baf4" translate="yes" xml:space="preserve">
          <source>The datatype describing the (identically typed) elements in an ndarray. It can be changed to reinterpret the array contents. For details, see &lt;a href=&quot;reference/arrays.dtypes&quot;&gt;Data type objects (dtype).&lt;/a&gt;</source>
          <target state="translated">描述ndarray中（相同类型的）元素的数据类型。可以更改它以重新解释数组内容。有关详细信息，请参见&lt;a href=&quot;reference/arrays.dtypes&quot;&gt;数据类型对象（dtype）。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6987a7425e0ff97a8320c32ec6abc8ee62f4f4d" translate="yes" xml:space="preserve">
          <source>The datatype determines which of &amp;lsquo;mergesort&amp;rsquo; or &amp;lsquo;timsort&amp;rsquo; is actually used, even if &amp;lsquo;mergesort&amp;rsquo; is specified. User selection at a finer scale is not currently available.</source>
          <target state="translated">即使指定了&amp;ldquo; mergesort&amp;rdquo;，数据类型也会确定实际使用的是&amp;ldquo; mergesort&amp;rdquo;还是&amp;ldquo; timsort&amp;rdquo;。目前尚无法进行更精细的用户选择。</target>
        </trans-unit>
        <trans-unit id="f8494cadb009486b1d5ee5b6a13352cbf85e331c" translate="yes" xml:space="preserve">
          <source>The datetime API is &lt;em&gt;experimental&lt;/em&gt; in 1.7.0, and may undergo changes in future versions of NumPy.</source>
          <target state="translated">datetime API 在1.7.0中处于&lt;em&gt;试验阶段&lt;/em&gt;，在以后的NumPy版本中可能会发生更改。</target>
        </trans-unit>
        <trans-unit id="5a29e38fde2fbef6d304ea68f9f28e90e826577d" translate="yes" xml:space="preserve">
          <source>The datetime object represents a single moment in time. If two datetimes have different units, they may still be representing the same moment of time, and converting from a bigger unit like months to a smaller unit like days is considered a &amp;lsquo;safe&amp;rsquo; cast because the moment of time is still being represented exactly.</source>
          <target state="translated">datetime对象表示单个时刻。如果两个日期时间具有不同的单位，则它们可能仍代表相同的时间，从较大的单位（如月份）转换为较小的单位（如日期）被认为是&amp;ldquo;安全&amp;rdquo;转换，因为时间段仍可以精确表示。</target>
        </trans-unit>
        <trans-unit id="96194d206533dca35ec887829a70fc8982e7d450" translate="yes" xml:space="preserve">
          <source>The datetime string parser in NumPy 1.6 is very liberal in what it accepts, and silently allows invalid input without raising errors. The parser in NumPy 1.7 is quite strict about only accepting ISO 8601 dates, with a few convenience extensions. 1.6 always creates microsecond (us) units by default, whereas 1.7 detects a unit based on the format of the string. Here is a comparison.:</source>
          <target state="translated">NumPy 1.6中的日期时间字符串解析器在接受的内容上非常自由,它允许无效的输入而不引起错误。NumPy 1.7中的解析器非常严格,只接受ISO 8601日期,并做了一些方便的扩展。1.6总是默认创建微秒(us)单位,而1.7则根据字符串的格式检测单位。下面是一个比较..:</target>
        </trans-unit>
        <trans-unit id="1369383d5a514fcfed8df04d6ed924de54d6f3b1" translate="yes" xml:space="preserve">
          <source>The datetime type works with many common NumPy functions, for example &lt;a href=&quot;generated/numpy.arange#numpy.arange&quot;&gt;&lt;code&gt;arange&lt;/code&gt;&lt;/a&gt; can be used to generate ranges of dates.</source>
          <target state="translated">datetime类型可与许多常见的NumPy函数一起使用，例如&lt;a href=&quot;generated/numpy.arange#numpy.arange&quot;&gt; &lt;code&gt;arange&lt;/code&gt; &lt;/a&gt;可用于生成日期范围。</target>
        </trans-unit>
        <trans-unit id="60d7f83834880a987611358eebe758ac593dc7d2" translate="yes" xml:space="preserve">
          <source>The decomposition is performed using LAPACK routine &lt;code&gt;_gesdd&lt;/code&gt;.</source>
          <target state="translated">使用LAPACK例程 &lt;code&gt;_gesdd&lt;/code&gt; 执行分解。</target>
        </trans-unit>
        <trans-unit id="e1516fc7b62e4a0344208958aa595053689db869" translate="yes" xml:space="preserve">
          <source>The decorated test &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">装饰性测试 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9657b7f30a96eb6a9709525e36cff8e84658cbb" translate="yes" xml:space="preserve">
          <source>The decorator itself is decorated with the &lt;code&gt;nose.tools.make_decorator&lt;/code&gt; function in order to transmit function name, and various other metadata.</source>
          <target state="translated">装饰器本身使用 &lt;code&gt;nose.tools.make_decorator&lt;/code&gt; 函数进行装饰，以传输函数名称以及其他各种元数据。</target>
        </trans-unit>
        <trans-unit id="4a37da8a9aa52a4088272dd54ccf6dae2a209ad8" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;atol&lt;/code&gt; is not appropriate for comparing numbers that are much smaller than one (see Notes).</source>
          <target state="translated">默认的 &lt;code&gt;atol&lt;/code&gt; 不适用于比较比1小得多的数字（请参见注释）。</target>
        </trans-unit>
        <trans-unit id="cb5293865f62263e0a19bbfa34c77f6486814f1d" translate="yes" xml:space="preserve">
          <source>The default __array_priority__ of matrix objects is 10.0, and therefore mixed operations with ndarrays always produce matrices.</source>
          <target state="translated">矩阵对象的默认__array_priority__是10.0,因此与ndarrays的混合操作总是产生矩阵。</target>
        </trans-unit>
        <trans-unit id="cd69cae26ca025156d4d72a557a24e650bb3e040" translate="yes" xml:space="preserve">
          <source>The default character, this is returned if none of the characters in &lt;code&gt;typechars&lt;/code&gt; matches a character in &lt;code&gt;typeset&lt;/code&gt;.</source>
          <target state="translated">默认的字符，如果没有在此字符返回 &lt;code&gt;typechars&lt;/code&gt; 在字符匹配 &lt;code&gt;typeset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5464337fdab09809b32b82a7eac52309846c7ea" translate="yes" xml:space="preserve">
          <source>The default data type in NumPy is &lt;a href=&quot;#numpy.float_&quot;&gt;&lt;code&gt;float_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPy中的默认数据类型为&lt;a href=&quot;#numpy.float_&quot;&gt; &lt;code&gt;float_&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
