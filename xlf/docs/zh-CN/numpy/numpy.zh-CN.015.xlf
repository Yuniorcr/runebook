<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="cdf699c411308f89c9b3b067e51b1e307dfb7a9f" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;flags = divide + 2*over + 4*under + 8*invalid&lt;/code&gt;.</source>
          <target state="translated">换句话说， &lt;code&gt;flags = divide + 2*over + 4*under + 8*invalid&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f91eee16dbc3f050fa038e2c5209d53822e69e47" translate="yes" xml:space="preserve">
          <source>In other words, each entry &lt;code&gt;out[i,j,...,:]&lt;/code&gt; is an N-dimensional value drawn from the distribution.</source>
          <target state="translated">换句话说，每个入口 &lt;code&gt;out[i,j,...,:]&lt;/code&gt; 是从分布中得出的N维值。</target>
        </trans-unit>
        <trans-unit id="b7dcdc5e279e7f5cb5fcdbe1eac1b3a0742ee26b" translate="yes" xml:space="preserve">
          <source>In other words, the usage of info is exactly the same as when using blas_info and co.</source>
          <target state="translated">换句话说,info的用法与使用blas_info和co时完全一样。</target>
        </trans-unit>
        <trans-unit id="84851d19bec7dda86a1de5ddcd1548f32366d2fa" translate="yes" xml:space="preserve">
          <source>In our case,</source>
          <target state="translated">在我们的案例中:</target>
        </trans-unit>
        <trans-unit id="d08ff7590113d034602ad8a932c13f96f4f84856" translate="yes" xml:space="preserve">
          <source>In our case, we are approximating the grayscale portion of the image, so we will use the colormap &lt;code&gt;gray&lt;/code&gt;:</source>
          <target state="translated">在我们的例子中，我们正在逼近图像的灰度部分，所以我们将使用颜色映射 &lt;code&gt;gray&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="41f0de1dccddf6867cedf88d3dd90186911881e1" translate="yes" xml:space="preserve">
          <source>In our examples, we will treat the input array with a complex data type, so that we can take square roots of negative numbers. Without enabling copies or buffering mode, the iterator will raise an exception if the data type doesn&amp;rsquo;t match precisely.</source>
          <target state="translated">在我们的示例中，我们将使用复杂的数据类型来处理输入数组，以便我们可以取负数的平方根。如果不启用复制或缓冲模式，则如果数据类型不完全匹配，则迭代器将引发异常。</target>
        </trans-unit>
        <trans-unit id="f3aea51c3c320aa437734a573490879eb2569913" translate="yes" xml:space="preserve">
          <source>In place fancy indexing for ufuncs</source>
          <target state="translated">为ufuncs建立花哨的索引。</target>
        </trans-unit>
        <trans-unit id="f02a14688f33a1cd645cff2ad5ad3ea73913fd03" translate="yes" xml:space="preserve">
          <source>In place operations will perform the calculation using the precision decided by the data type of the two operands, but will silently downcast the result (if necessary) so it can fit back into the array. Therefore, for mixed precision calculations, &lt;code&gt;A {op}=
B&lt;/code&gt; can be different than &lt;code&gt;A = A {op} B&lt;/code&gt;. For example, suppose &lt;code&gt;a = ones((3,3))&lt;/code&gt;. Then, &lt;code&gt;a += 3j&lt;/code&gt; is different than &lt;code&gt;a = a +
3j&lt;/code&gt;: while they both perform the same computation, &lt;code&gt;a += 3&lt;/code&gt; casts the result to fit back in &lt;code&gt;a&lt;/code&gt;, whereas &lt;code&gt;a = a + 3j&lt;/code&gt; re-binds the name &lt;code&gt;a&lt;/code&gt; to the result.</source>
          <target state="translated">就地操作将使用由两个操作数的数据类型决定的精度执行计算，但是会静默向下转换结果（如果需要），以便可以放回到数组中。因此，对于混合精度计算， &lt;code&gt;A {op}= B&lt;/code&gt; 可不同于 &lt;code&gt;A = A {op} B&lt;/code&gt; 。例如，假设 &lt;code&gt;a = ones((3,3))&lt;/code&gt; 。然后， &lt;code&gt;a += 3j&lt;/code&gt; 与 &lt;code&gt;a = a + 3j&lt;/code&gt; ：虽然它们都执行相同的计算， &lt;code&gt;a += 3&lt;/code&gt; 会将结果强制转换为适合 &lt;code&gt;a&lt;/code&gt; ，而 &lt;code&gt;a = a + 3j&lt;/code&gt; 将名称 &lt;code&gt;a&lt;/code&gt; 重新绑定到结果。</target>
        </trans-unit>
        <trans-unit id="3ffbc219d4925b162d68445ad04161e81b80a2ae" translate="yes" xml:space="preserve">
          <source>In practice, we anticipate that for most Steering Council decisions (e.g., voting in new members) a more informal process will suffice.</source>
          <target state="translated">在实践中,我们预计,对于大多数指导委员会的决定(如投票选举新成员),一个较为非正式的程序就足够了。</target>
        </trans-unit>
        <trans-unit id="211d3795b0d3cedf14ae00bfdd7e3e38d86df021" translate="yes" xml:space="preserve">
          <source>In prior versions of NumPy, the datetime64 type always stored times in UTC. By default, creating a datetime64 object from a string or printing it would convert from or to local time:</source>
          <target state="translated">在NumPy之前的版本中,datetime64类型总是以UTC存储时间。默认情况下,从一个字符串创建一个datetime64对象或打印它将从当地时间转换为当地时间。</target>
        </trans-unit>
        <trans-unit id="bb94af890255a1752661e16a2eacce9c1ad12713" translate="yes" xml:space="preserve">
          <source>In row-major, C-style order, in two dimensions, the row index varies the slowest, and the column index the quickest. This can be generalized to multiple dimensions, where row-major order implies that the index along the first axis varies slowest, and the index along the last quickest. The opposite holds for column-major, Fortran-style index ordering.</source>
          <target state="translated">在行-大,C式顺序中,在两个维度中,行指数变化最慢,列指数变化最快。这可以推广到多个维度,其中行-主序意味着沿第一个轴的索引变化最慢,而沿最后一个轴的索引变化最快。而列大数、Fortran式的索引排序则相反。</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="translated">简而言之:</target>
        </trans-unit>
        <trans-unit id="507aaff0e5cc21d7011bc819d2bd20f0b309484f" translate="yes" xml:space="preserve">
          <source>In single precision, &lt;a href=&quot;#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; can be inaccurate:</source>
          <target state="translated">以单精度表示，&lt;a href=&quot;#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;可能不准确：</target>
        </trans-unit>
        <trans-unit id="9b1dbcac5dd55e1c7b0ed7b38aff1c0737c2f620" translate="yes" xml:space="preserve">
          <source>In single precision, std() can be inaccurate:</source>
          <target state="translated">在单一精度下,std()可能不准确。</target>
        </trans-unit>
        <trans-unit id="ca04a495cdff9e1119115547af374f5b2a4d64ac" translate="yes" xml:space="preserve">
          <source>In single precision, var() can be inaccurate:</source>
          <target state="translated">在单一精度下,var()可能不准确。</target>
        </trans-unit>
        <trans-unit id="568553829625c2078673593fe2ee401327874ad7" translate="yes" xml:space="preserve">
          <source>In some cases, an appropriate use of the roll and the offset is necessary to get a desired answer.</source>
          <target state="translated">在某些情况下,为了得到理想的答案,适当地使用卷筒和偏移是必要的。</target>
        </trans-unit>
        <trans-unit id="bac6ec658cf559e360b3f959f986ce1e7d727c27" translate="yes" xml:space="preserve">
          <source>In some cases, broadcasting stretches both arrays to form an output array larger than either of the initial arrays.*</source>
          <target state="translated">在某些情况下,广播会将两个数组都拉长,形成一个比初始数组更大的输出数组。</target>
        </trans-unit>
        <trans-unit id="ac0960cf0185d8fe7d74b182c3299905c5bc5818" translate="yes" xml:space="preserve">
          <source>In some cases, such as structured arrays and the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; interface, a data type needs to be used to make sense of the object. When this is needed, provide a Descr for &amp;lsquo;requested_dtype&amp;rsquo;, otherwise provide NULL. This reference is not stolen. Also, if the requested dtype doesn&amp;rsquo;t modify the interpretation of the input, out_dtype will still get the &amp;ldquo;innate&amp;rdquo; dtype of the object, not the dtype passed in &amp;lsquo;requested_dtype&amp;rsquo;.</source>
          <target state="translated">在某些情况下，例如结构化数组和&lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;接口，需要使用数据类型来理解对象。需要时，为&amp;ldquo; requested_dtype&amp;rdquo;提供一个Descr，否则提供NULL。此引用未被盗。另外，如果请求的dtype不修改输入的解释，则out_dtype仍将获得对象的&amp;ldquo;先天&amp;rdquo; dtype，而不是在&amp;ldquo; requested_dtype&amp;rdquo;中传递的dtype。</target>
        </trans-unit>
        <trans-unit id="facb6bd6062bf723ed24036374202b109145e308" translate="yes" xml:space="preserve">
          <source>In some cases, we are not interested in all the columns of the data but only a few of them. We can select which columns to import with the &lt;code&gt;usecols&lt;/code&gt; argument. This argument accepts a single integer or a sequence of integers corresponding to the indices of the columns to import. Remember that by convention, the first column has an index of 0. Negative integers behave the same as regular Python negative indexes.</source>
          <target state="translated">在某些情况下，我们对数据的所有列都不感兴趣，但仅对其中的一些感兴趣。我们可以使用 &lt;code&gt;usecols&lt;/code&gt; 参数选择要导入的列。此参数接受与要导入的列的索引相对应的单个整数或整数序列。请记住，按照惯例，第一列的索引为0。负整数的行为与常规Python负索引相同。</target>
        </trans-unit>
        <trans-unit id="ef2ea8dc139c52f2365b3742b195c7e8c88faf3c" translate="yes" xml:space="preserve">
          <source>In some cases, you will see this form of the commit command: &lt;code&gt;git commit
-a&lt;/code&gt;. The extra &lt;code&gt;-a&lt;/code&gt; flag automatically commits all modified files and removes all deleted files. This can save you some typing of numerous &lt;code&gt;git
add&lt;/code&gt; commands; however, it can add unwanted changes to a commit if you&amp;rsquo;re not careful. For more information, see &lt;a href=&quot;http://www.gitready.com/beginner/2009/01/18/the-staging-area.html&quot;&gt;why the -a flag?&lt;/a&gt; - and the helpful use-case description in the &lt;a href=&quot;https://tomayko.com/writings/the-thing-about-git&quot;&gt;tangled working copy problem&lt;/a&gt;.</source>
          <target state="translated">在某些情况下，您将看到以下形式的commit命令： &lt;code&gt;git commit -a&lt;/code&gt; 。额外的 &lt;code&gt;-a&lt;/code&gt; 标志自动提交所有修改过的文件，并删除所有删除的文件。这样可以节省许多 &lt;code&gt;git add&lt;/code&gt; 命令的输入。但是，如果您不小心，可能会在提交中添加不必要的更改。有关更多信息，请参见&lt;a href=&quot;http://www.gitready.com/beginner/2009/01/18/the-staging-area.html&quot;&gt;为什么使用-a标志？&lt;/a&gt; -以及&lt;a href=&quot;https://tomayko.com/writings/the-thing-about-git&quot;&gt;复杂的工作副本问题中&lt;/a&gt;有用的用例描述。</target>
        </trans-unit>
        <trans-unit id="341cdd9b0329316960c0e4cc444da230117b1062" translate="yes" xml:space="preserve">
          <source>In some future release, it will return a read/write view and writing to the returned array will alter your original array. The returned array will have the same type as the input array.</source>
          <target state="translated">在未来的一些版本中,它将返回一个读/写视图,对返回的数组进行写入将改变你原来的数组。返回的数组将具有与输入数组相同的类型。</target>
        </trans-unit>
        <trans-unit id="f5ee90b2a39e9fa80b16d394e14dd0a33a028120" translate="yes" xml:space="preserve">
          <source>In some situations, it is possible that you could use the &lt;code&gt;%numpy_typemaps&lt;/code&gt; macro to implement typemaps for your own types. See the &lt;a href=&quot;#other-common-types-bool&quot;&gt;Other Common Types: bool&lt;/a&gt; or &lt;a href=&quot;#other-common-types-complex&quot;&gt;Other Common Types: complex&lt;/a&gt; sections for examples. Another situation is if your dimensions are of a type other than &lt;code&gt;int&lt;/code&gt; (say &lt;code&gt;long&lt;/code&gt; for example):</source>
          <target state="translated">在某些情况下，可能可以使用 &lt;code&gt;%numpy_typemaps&lt;/code&gt; 宏为您自己的类型实现类型映射。有关示例，请参见&lt;a href=&quot;#other-common-types-bool&quot;&gt;其他常见类型：布尔值&lt;/a&gt;或&lt;a href=&quot;#other-common-types-complex&quot;&gt;其他常见类型：复杂&lt;/a&gt;部分。另一种情况是，如果您的尺寸不是 &lt;code&gt;int&lt;/code&gt; 类型（例如， &lt;code&gt;long&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="6637a461a29946a77554fd519e0c6357a75130bb" translate="yes" xml:space="preserve">
          <source>In specifying the repeat rule for a named variable, &lt;code&gt;item*N&lt;/code&gt; is short- hand for &lt;code&gt;item, item, ..., item&lt;/code&gt; repeated N times. In addition, parenthesis in combination with &lt;code&gt;*N&lt;/code&gt; can be used for grouping several items that should be repeated. Thus, &lt;code&gt;#name=(item1, item2)*4#&lt;/code&gt; is equivalent to &lt;code&gt;#name=item1, item2, item1, item2, item1, item2, item1,
item2#&lt;/code&gt;.</source>
          <target state="translated">在为命名变量指定重复规则时， &lt;code&gt;item*N&lt;/code&gt; 是重复重复N次的 &lt;code&gt;item, item, ..., item&lt;/code&gt; 简写。此外，圆括号与 &lt;code&gt;*N&lt;/code&gt; 结合可用于对应重复的几个项目进行分组。因此， &lt;code&gt;#name=(item1, item2)*4#&lt;/code&gt; 等效于 &lt;code&gt;#name=item1, item2, item1, item2, item1, item2, item1, item2#&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef54aceba82e6cd0b5d227cf1545504de22cdfa8" translate="yes" xml:space="preserve">
          <source>In that case, each item is associated to a column, in order.</source>
          <target state="translated">在这种情况下,每个项目依次关联到一个列。</target>
        </trans-unit>
        <trans-unit id="4128e61e6436506814002ae295957c7fd56f0e0e" translate="yes" xml:space="preserve">
          <source>In that repository edit the files:</source>
          <target state="translated">在该存储库中编辑文件。</target>
        </trans-unit>
        <trans-unit id="3d0c88a0902d8f4e29b2260087b409a1f0c6bbf0" translate="yes" xml:space="preserve">
          <source>In the 1-D and 0-D case, the indexing and sparse keywords have no effect.</source>
          <target state="translated">在1-D和0-D的情况下,索引和稀疏的关键词没有影响。</target>
        </trans-unit>
        <trans-unit id="82b4d34298ee4da5c6486a950c439f010b328116" translate="yes" xml:space="preserve">
          <source>In the above example F2PY was able to guess accurately the signature of a call-back function. However, sometimes F2PY cannot establish the signature as one would wish and then the signature of a call-back function must be modified in the signature file manually. Namely, signature files may contain special modules (the names of such modules contain a substring &lt;code&gt;__user__&lt;/code&gt;) that collect various signatures of call-back functions. Callback arguments in routine signatures have attribute &lt;code&gt;external&lt;/code&gt; (see also &lt;code&gt;intent(callback)&lt;/code&gt; attribute). To relate a callback argument and its signature in &lt;code&gt;__user__&lt;/code&gt; module block, use &lt;code&gt;use&lt;/code&gt; statement as illustrated below. The same signature of a callback argument can be referred in different routine signatures.</source>
          <target state="translated">在上面的示例中，F2PY能够准确地猜测回调函数的签名。但是，有时F2PY无法建立签名，因此必须在签名文件中手动修改回调函数的签名。即，签名文件可能包含特殊模块（此类模块的名称包含子字符串 &lt;code&gt;__user__&lt;/code&gt; ），这些模块收集回调函数的各种签名。例程签名中的回调参数具有 &lt;code&gt;external&lt;/code&gt; 属性（另请参见 &lt;code&gt;intent(callback)&lt;/code&gt; 属性）。要在 &lt;code&gt;__user__&lt;/code&gt; 模块块中关联回调参数及其签名，请使用 &lt;code&gt;use&lt;/code&gt; 如下图所示。回调参数的相同签名可以在不同的例程签名中引用。</target>
        </trans-unit>
        <trans-unit id="e263de7df2b576cf438fac441850586c983ab809" translate="yes" xml:space="preserve">
          <source>In the case of double precision tests, this will return the python function &lt;code&gt;Vector.doubleLength&lt;/code&gt;.</source>
          <target state="translated">在双精度测试的情况下，这将返回python函数 &lt;code&gt;Vector.doubleLength&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0240da2483005a9c53b4aad1de6618f577c43aa" translate="yes" xml:space="preserve">
          <source>In the common 2-D case (N=1), the block structure can be visualized:</source>
          <target state="translated">在常见的二维情况下(N=1),块状结构可以可视化。</target>
        </trans-unit>
        <trans-unit id="4a985ec6ae1b21c700d18be39de4f40c82d97f8b" translate="yes" xml:space="preserve">
          <source>In the directory where you want the copy created, run</source>
          <target state="translated">在你想创建副本的目录下,运行</target>
        </trans-unit>
        <trans-unit id="e138055380190b3c93b794e532e7d0c34dce613a" translate="yes" xml:space="preserve">
          <source>In the end, which you do for Fortran or C depends on which is more important, not reordering data or preserving the indexing convention. For large images, reordering data is potentially expensive, and often the indexing convention is inverted to avoid that.</source>
          <target state="translated">最后,对于Fortran和C来说,你做哪个取决于哪个更重要,不重新排序数据和保留索引惯例。对于大图像来说,重新排序数据有可能是昂贵的,通常为了避免这种情况,会将索引惯例倒置。</target>
        </trans-unit>
        <trans-unit id="8930375040ab76aae34fb47c1b34d1c268b41dae" translate="yes" xml:space="preserve">
          <source>In the event of any conflict of interest, a committee member must immediately notify the other members, and recuse themselves if necessary.</source>
          <target state="translated">如果出现任何利益冲突,委员会成员必须立即通知其他成员,并在必要时回避。</target>
        </trans-unit>
        <trans-unit id="b1d5a2c6f7d9d2516af28db041f10097409dc991" translate="yes" xml:space="preserve">
          <source>In the example above, we used the fact that by default, &lt;code&gt;dtype=float&lt;/code&gt;. By giving a sequence of names, we are forcing the output to a structured dtype.</source>
          <target state="translated">在上面的示例中，我们使用了默认情况下 &lt;code&gt;dtype=float&lt;/code&gt; 的事实。通过提供一系列名称，我们将输出强制为结构化dtype。</target>
        </trans-unit>
        <trans-unit id="6eb66ccf87f3461ec66b2cc1735ef182a062917a" translate="yes" xml:space="preserve">
          <source>In the file, array data starts at this offset. Since &lt;code&gt;offset&lt;/code&gt; is measured in bytes, it should normally be a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;. When &lt;code&gt;mode != 'r'&lt;/code&gt;, even positive offsets beyond end of file are valid; The file will be extended to accommodate the additional data. By default, &lt;code&gt;memmap&lt;/code&gt; will start at the beginning of the file, even if &lt;code&gt;filename&lt;/code&gt; is a file pointer &lt;code&gt;fp&lt;/code&gt; and &lt;code&gt;fp.tell() != 0&lt;/code&gt;.</source>
          <target state="translated">在文件中，数组数据从此偏移量开始。由于 &lt;code&gt;offset&lt;/code&gt; 以字节为单位，因此通常应为&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;的字节大小的倍数。当 &lt;code&gt;mode != 'r'&lt;/code&gt; ，甚至超出文件末尾的正偏移量也有效；该文件将被扩展以容纳其他数据。默认情况下，即使 &lt;code&gt;filename&lt;/code&gt; 是文件指针 &lt;code&gt;fp&lt;/code&gt; 和 &lt;code&gt;fp.tell() != 0&lt;/code&gt; ， &lt;code&gt;memmap&lt;/code&gt; 也将从文件的开头开始。</target>
        </trans-unit>
        <trans-unit id="6d51d7e744b66162bcb271fa8e86dbafebc0e214" translate="yes" xml:space="preserve">
          <source>In the first case the lower bound of the integration is set to -1 and the integration constant is 0. In the second the constant of integration is set to 1 as well. Differentiation is simpler since the only option is the number of times the polynomial is differentiated:</source>
          <target state="translated">在第一种情况下,积分的下界设为-1,积分常数为0,在第二种情况下,积分常数也设为1。微分比较简单,因为唯一的选项是多项式的微分次数。</target>
        </trans-unit>
        <trans-unit id="39042dbdcabf0496e03a08644bb7e129fe61d278" translate="yes" xml:space="preserve">
          <source>In the first case, the dimensions resulting from the advanced indexing operation come first in the result array, and the subspace dimensions after that. In the second case, the dimensions from the advanced indexing operations are inserted into the result array at the same spot as they were in the initial array (the latter logic is what makes simple advanced indexing behave just like slicing).</source>
          <target state="translated">在第一种情况下,高级索引操作产生的维度首先出现在结果数组中,子空间的维度在其后。在第二种情况下,高级索引操作产生的维度被插入到结果数组中与初始数组中的位置相同(后一种逻辑是使简单的高级索引表现得像切片一样的原因)。</target>
        </trans-unit>
        <trans-unit id="fee9951c9cac899e8dc4b73ca21eaf580eee1e11" translate="yes" xml:space="preserve">
          <source>In the following descriptions, we reference a generic &lt;code&gt;DATA_TYPE&lt;/code&gt;, which could be any of the C data types listed above, and &lt;code&gt;DIM_TYPE&lt;/code&gt; which should be one of the many types of integers.</source>
          <target state="translated">在以下描述中，我们引用通用 &lt;code&gt;DATA_TYPE&lt;/code&gt; ，它可以是上面列出的任何C数据类型，而 &lt;code&gt;DIM_TYPE&lt;/code&gt; 则应该是许多整数类型之一。</target>
        </trans-unit>
        <trans-unit id="0a77a218f61bf2d19822ca93ebcee58f5aa1e669" translate="yes" xml:space="preserve">
          <source>In the following example, both the &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; arrays have axes with length one that are expanded to a larger size during the broadcast operation:</source>
          <target state="translated">在以下示例中， &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 数组均具有长度为1的轴，这些轴在广播操作期间会扩展为更大的大小：</target>
        </trans-unit>
        <trans-unit id="56c7aa7e2fe12577360a1a373c78ed632827aefd" translate="yes" xml:space="preserve">
          <source>In the following example, both the &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; arrays have axes with length one that are expanded to a larger size in a broadcast operation.</source>
          <target state="translated">在下面的示例中， &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 数组均具有长度为1的轴，这些轴在广播操作中扩展为更大的大小。</target>
        </trans-unit>
        <trans-unit id="7b0aabec281905f99f49d1bbd6f2c64a2c3c69d5" translate="yes" xml:space="preserve">
          <source>In the following example, the second column is converted from as string representing a percentage to a float between 0 and 1:</source>
          <target state="translated">在下面的例子中,第二列从代表百分比的字符串转换为0和1之间的浮点数。</target>
        </trans-unit>
        <trans-unit id="4b029336d8b412b884840fa6a1fbeb3e45d0f30b" translate="yes" xml:space="preserve">
          <source>In the following example, we suppose that the missing values are flagged with &lt;code&gt;&quot;N/A&quot;&lt;/code&gt; in the first column and by &lt;code&gt;&quot;???&quot;&lt;/code&gt; in the third column. We wish to transform these missing values to 0 if they occur in the first and second column, and to -999 if they occur in the last column:</source>
          <target state="translated">在下面的示例中，我们假设丢失的值在第一列中用 &lt;code&gt;&quot;N/A&quot;&lt;/code&gt; 标记，在 &lt;code&gt;&quot;???&quot;&lt;/code&gt; 中标记 在第三栏中。如果这些缺失值出现在第一列和第二列中，我们希望将它们转换为0，如果它们出现在最后一列中则转换为-999：</target>
        </trans-unit>
        <trans-unit id="fceed6223bcf512a691c7903c36d65343ab22b97" translate="yes" xml:space="preserve">
          <source>In the graph, we can see that although we have 768 singular values in &lt;code&gt;s&lt;/code&gt;, most of those (after the 150th entry or so) are pretty small. So it might make sense to use only the information related to the first (say, 50) &lt;em&gt;singular values&lt;/em&gt; to build a more economical approximation to our image.</source>
          <target state="translated">在图中，我们可以看到，尽管 &lt;code&gt;s&lt;/code&gt; 中有768个奇异值，但是其中大多数（大约在第150个条目之后）都很小。因此，仅使用与第一个（例如50个）&lt;em&gt;奇异值&lt;/em&gt;有关的信息来建立与我们的图像更经济的近似值可能是有意义的。</target>
        </trans-unit>
        <trans-unit id="66d2fff5a851e4221aa19362249b2b84c5964134" translate="yes" xml:space="preserve">
          <source>In the next several sections we give example code that can be easily modified to create your own ufuncs. The examples are successively more complete or complicated versions of the logit function, a common function in statistical modeling. Logit is also interesting because, due to the magic of IEEE standards (specifically IEEE 754), all of the logit functions created below automatically have the following behavior.</source>
          <target state="translated">在接下来的几节中,我们给出了一些例子代码,这些代码可以很容易地进行修改以创建自己的ufuncs。这些例子是对数函数的连续更完整或更复杂的版本,对数函数是统计建模中常见的函数。对数也很有趣,因为由于IEEE标准(特别是IEEE 754)的神奇,下面创建的所有对数函数都会自动具有以下行为。</target>
        </trans-unit>
        <trans-unit id="1dc319444395eeb97927a05649519246dd32d72d" translate="yes" xml:space="preserve">
          <source>In the past most implementations used the &amp;ldquo;desc&amp;rdquo; member of the &lt;code&gt;PyCObject&lt;/code&gt; itself (do not confuse this with the &amp;ldquo;descr&amp;rdquo; member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure above &amp;mdash; they are two separate things) to hold the pointer to the object exposing the interface. This is now an explicit part of the interface. Be sure to own a reference to the object when the &lt;code&gt;PyCObject&lt;/code&gt; is created using &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt;.</source>
          <target state="translated">在过去，大多数实现都使用 &lt;code&gt;PyCObject&lt;/code&gt; 本身的&amp;ldquo; desc&amp;rdquo;成员（不要将其与上面的&lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;结构的&amp;ldquo; descr&amp;rdquo;成员混淆-它们是两个不同的东西）来保存指向暴露接口的对象的指针。现在，这是界面的显式部分。一定要自己去当对象的引用 &lt;code&gt;PyCObject&lt;/code&gt; 使用创建 &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cb71d475f8be6120fc976bd353b076b792b7f77" translate="yes" xml:space="preserve">
          <source>In the past most implementations used the &amp;ldquo;desc&amp;rdquo; member of the &lt;code&gt;PyCObject&lt;/code&gt; itself (do not confuse this with the &amp;ldquo;descr&amp;rdquo; member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure above &amp;mdash; they are two separate things) to hold the pointer to the object exposing the interface. This is now an explicit part of the interface. Be sure to own a reference to the object when the &lt;code&gt;PyCObject&lt;/code&gt; is created using &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt;.</source>
          <target state="translated">在过去，大多数实现都使用 &lt;code&gt;PyCObject&lt;/code&gt; 本身的&amp;ldquo; desc&amp;rdquo;成员（不要将其与上面的&lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;结构的&amp;ldquo; descr&amp;rdquo;成员混淆-它们是两个不同的东西）来保存指向暴露接口的对象的指针。现在，这是界面的显式部分。一定要自己去当对象的引用 &lt;code&gt;PyCObject&lt;/code&gt; 使用创建 &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd96631acab4a4c78f25e82e30e4074e25691d52" translate="yes" xml:space="preserve">
          <source>In the past most implementations used the &lt;code&gt;desc&lt;/code&gt; member of the &lt;code&gt;PyCObject&lt;/code&gt; (now &lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt;&lt;code&gt;PyCapsule&lt;/code&gt;&lt;/a&gt;) itself (do not confuse this with the &amp;ldquo;descr&amp;rdquo; member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure above &amp;mdash; they are two separate things) to hold the pointer to the object exposing the interface. This is now an explicit part of the interface. Be sure to take a reference to the object and call &lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule_SetContext&quot;&gt;&lt;code&gt;PyCapsule_SetContext&lt;/code&gt;&lt;/a&gt; before returning the &lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt;&lt;code&gt;PyCapsule&lt;/code&gt;&lt;/a&gt;, and configure a destructor to decref this reference.</source>
          <target state="translated">在过去的大多数实现中，使用 &lt;code&gt;PyCObject&lt;/code&gt; （现在为&lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt; &lt;code&gt;PyCapsule&lt;/code&gt; &lt;/a&gt;）本身的 &lt;code&gt;desc&lt;/code&gt; 成员（不要将其与上面的&lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;结构的&amp;ldquo; descr&amp;rdquo;成员相混淆-它们是两个不同的东西）来保存指向暴露接口的对象的指针。 。现在，这是界面的显式部分。在返回&lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule_SetContext&quot;&gt; &lt;code&gt;PyCapsule_SetContext&lt;/code&gt; &lt;/a&gt;之前，请确保对对象进行引用并调用&lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt; &lt;code&gt;PyCapsule&lt;/code&gt; _SetContext&lt;/a&gt;，并配置析构函数以对该引用进行解引用。</target>
        </trans-unit>
        <trans-unit id="cfcf82ced52f76044f84d6258de886b7808506ff" translate="yes" xml:space="preserve">
          <source>In the range -1 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 1 they are nice, equiripple functions lying between +/- 1. The same plots over the range -2 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 2 look very different:</source>
          <target state="translated">在-1 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 1 范围内，它们是不错的，等波动函数介于+/- 1之间。在-2 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 2 范围内的相同图看起来非常不同：</target>
        </trans-unit>
        <trans-unit id="8d2fb588d0d5207847c4495ec3e5ed9b60e1f12d" translate="yes" xml:space="preserve">
          <source>In the same way, if we don&amp;rsquo;t give enough names to match the length of the dtype, the missing names will be defined with this default template:</source>
          <target state="translated">同样，如果我们没有提供足够的名称来匹配dtype的长度，则会使用此默认模板来定义缺少的名称：</target>
        </trans-unit>
        <trans-unit id="9664dec4c702af778eb236a77580a7bb3b836b54" translate="yes" xml:space="preserve">
          <source>In the simplest case, there is only a &lt;em&gt;single&lt;/em&gt; advanced index. A single advanced index can for example replace a slice and the result array will be the same, however, it is a copy and may have a different memory layout. A slice is preferable when it is possible.</source>
          <target state="translated">在最简单的情况下，只有一个&lt;em&gt;单一的&lt;/em&gt;指标先进。单个高级索引可以例如替换切片，并且结果数组将相同，但是，它是一个副本，并且可能具有不同的内存布局。如果可能的话，切片是优选的。</target>
        </trans-unit>
        <trans-unit id="eaceaaeb778efa3a74e32f0e07667ae3c3a1ce24" translate="yes" xml:space="preserve">
          <source>In the source code, be sure to preface any issue or PR reference with &lt;code&gt;gh-xxxx&lt;/code&gt;.</source>
          <target state="translated">在源代码中，请确保以 &lt;code&gt;gh-xxxx&lt;/code&gt; 开头任何问题或PR参考。</target>
        </trans-unit>
        <trans-unit id="c94924098b3009fa708b6c1aec49764e87be7477" translate="yes" xml:space="preserve">
          <source>In the table below, it is assumed that you have executed the following commands in Python:</source>
          <target state="translated">在下面的表格中,假设您已经在Python中执行了以下命令。</target>
        </trans-unit>
        <trans-unit id="d8a45b3135fa0c84b41da4d210f43fe96826517e" translate="yes" xml:space="preserve">
          <source>In the tables below, &lt;code&gt;platform?&lt;/code&gt; means that the type may not be available on all platforms. Compatibility with different C or Python types is indicated: two types are compatible if their data is of the same size and interpreted in the same way.</source>
          <target state="translated">在下表中， &lt;code&gt;platform?&lt;/code&gt; 表示该类型可能并非在所有平台上都可用。指出了与不同C或Python类型的兼容性：如果两种类型的数据大小相同且以相同的方式解释，则这两种类型是兼容的。</target>
        </trans-unit>
        <trans-unit id="97b2743d166cdad8253bc15ad591949789d4af86" translate="yes" xml:space="preserve">
          <source>In the worst case, if a Contributor is genuinely misusing their veto in an obstructive fashion to the detriment of the project, then they can be ejected from the project by consensus of the Steering Council &amp;ndash; see below.</source>
          <target state="translated">在最坏的情况下，如果贡献者真正以阻碍性方式滥用其否决权，从而损害了项目，则可以通过指导委员会的共识将其从项目中驱逐出局（请参阅下文）。</target>
        </trans-unit>
        <trans-unit id="3a7fe7582d8015e2df7c05da1f3a915ff663edd3" translate="yes" xml:space="preserve">
          <source>In this calculation, we can ignore the amount of numbers drawn from each stream. Each of the PRNGs we provide has some extra protection built in that avoids overlaps if the &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; pools differ in the slightest bit. &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; has</source>
          <target state="translated">在此计算中，我们可以忽略从每个流中抽取的数字数量。我们提供的每个PRNG都有一些内置的额外保护措施，如果&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;池的差异很小，就可以避免重叠。&lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;有</target>
        </trans-unit>
        <trans-unit id="65a0a52b3e0dac0b940f22ccbd59e595b0b91828" translate="yes" xml:space="preserve">
          <source>In this calculation, we can ignore the amount of numbers drawn from each stream. Each of the PRNGs we provide has some extra protection built in that avoids overlaps if the &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; pools differ in the slightest bit. &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; has</source>
          <target state="translated">在此计算中，我们可以忽略从每个流中提取的数字量。我们提供的每个PRNG都有一些内置的额外保护措施，如果&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;池的差异最小，则可以避免重叠。&lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;有</target>
        </trans-unit>
        <trans-unit id="fcdf80c260003d781b3489e23716b20d73cd0927" translate="yes" xml:space="preserve">
          <source>In this case, if the index arrays have a matching shape, and there is an index array for each dimension of the array being indexed, the resultant array has the same shape as the index arrays, and the values correspond to the index set for each position in the index arrays. In this example, the first index value is 0 for both index arrays, and thus the first value of the resultant array is y[0,0]. The next value is y[2,1], and the last is y[4,2].</source>
          <target state="translated">在这种情况下,如果索引数组具有匹配的形状,并且被索引数组的每个维度都有一个索引数组,则结果数组的形状与索引数组相同,其值对应于索引数组中每个位置的索引集。在本例中,两个索引数组的第一个索引值都是0,因此结果数组的第一个值是y[0,0]。下一个值是y[2,1],最后一个值是y[4,2]。</target>
        </trans-unit>
        <trans-unit id="89c8dba17ad2bf90a54597788476417de6721a53" translate="yes" xml:space="preserve">
          <source>In this case, we wanted to test solving a linear algebra problem using matrices of several data types, using &lt;code&gt;linalg.solve&lt;/code&gt; and &lt;code&gt;linalg.inv&lt;/code&gt;. The common test cases (for single-precision, double-precision, etc. matrices) are collected in &lt;code&gt;LinalgTestCase&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，我们想使用 &lt;code&gt;linalg.solve&lt;/code&gt; 和 &lt;code&gt;linalg.inv&lt;/code&gt; 使用几种数据类型的矩阵来测试解决线性代数问题。在 &lt;code&gt;LinalgTestCase&lt;/code&gt; 中收集了常见的测试用例（用于单精度，双精度等矩阵）。</target>
        </trans-unit>
        <trans-unit id="a876e5a0c738a8e265b4a962587a67aa3cabc3ca" translate="yes" xml:space="preserve">
          <source>In this chapter routine docstrings are presented, grouped by functionality. Many docstrings contain example code, which demonstrates basic usage of the routine. The examples assume that NumPy is imported with:</source>
          <target state="translated">在这一章中,例行程序docstrings按功能分组。许多 docstrings 包含示例代码,演示了例程的基本用法。这些例子假定NumPy是通过以下方式导入的。</target>
        </trans-unit>
        <trans-unit id="4030b7d01040d7db2670bc21cd8e6f75987d1ae6" translate="yes" xml:space="preserve">
          <source>In this context, consensus does &lt;em&gt;not&lt;/em&gt; require:</source>
          <target state="translated">在此背景下，共识也&lt;em&gt;不能&lt;/em&gt;要求：</target>
        </trans-unit>
        <trans-unit id="fb82fb6aef1a39fd7c11a037068f12eca825f3ae" translate="yes" xml:space="preserve">
          <source>In this example if &lt;code&gt;a&lt;/code&gt; is an ndarray, &amp;ldquo;fancy&amp;rdquo; indexing can be used.</source>
          <target state="translated">在此示例中，如果 &lt;code&gt;a&lt;/code&gt; 是ndarray，则可以使用&amp;ldquo;花式&amp;rdquo;索引。</target>
        </trans-unit>
        <trans-unit id="8f824e9ad2dd27432acf7adb45ed2442b89417d6" translate="yes" xml:space="preserve">
          <source>In this example the spacing is also specified: uniform for axis=0 and non uniform for axis=1</source>
          <target state="translated">在这个例子中,还指定了间距:轴线=0时为统一,轴线=1时为非统一。</target>
        </trans-unit>
        <trans-unit id="6f53f611701fca845a45b96236c3247acdc3fe03" translate="yes" xml:space="preserve">
          <source>In this example we generate two random arrays, &lt;code&gt;xarr&lt;/code&gt; and &lt;code&gt;yarr&lt;/code&gt;, and compute the row-wise and column-wise Pearson correlation coefficients, &lt;code&gt;R&lt;/code&gt;. Since &lt;code&gt;rowvar&lt;/code&gt; is true by default, we first find the row-wise Pearson correlation coefficients between the variables of &lt;code&gt;xarr&lt;/code&gt;.</source>
          <target state="translated">在这个例子中，我们生成两个随机阵列， &lt;code&gt;xarr&lt;/code&gt; 和 &lt;code&gt;yarr&lt;/code&gt; ，并计算在行和列方向的Pearson相关系数， &lt;code&gt;R&lt;/code&gt; 。由于默认情况下 &lt;code&gt;rowvar&lt;/code&gt; 为true，因此我们首先找到 &lt;code&gt;xarr&lt;/code&gt; 变量之间的按行Pearson相关系数。</target>
        </trans-unit>
        <trans-unit id="328c265783b83eb29747b7db6d81add31503c3ba" translate="yes" xml:space="preserve">
          <source>In this example, I will show how the addition function and the filter function implemented previously using the other approaches can be implemented using ctypes. First, the C code which implements the algorithms contains the functions &lt;code&gt;zadd&lt;/code&gt;, &lt;code&gt;dadd&lt;/code&gt;, &lt;code&gt;sadd&lt;/code&gt;, &lt;code&gt;cadd&lt;/code&gt;, and &lt;code&gt;dfilter2d&lt;/code&gt;. The &lt;code&gt;zadd&lt;/code&gt; function is:</source>
          <target state="translated">在此示例中，我将展示如何使用ctypes来实现以前使用其他方法实现的加法函数和过滤器函数。首先，实现算法的C代码包含函数 &lt;code&gt;zadd&lt;/code&gt; ， &lt;code&gt;dadd&lt;/code&gt; ， &lt;code&gt;sadd&lt;/code&gt; ， &lt;code&gt;cadd&lt;/code&gt; 和 &lt;code&gt;dfilter2d&lt;/code&gt; 。该 &lt;code&gt;zadd&lt;/code&gt; 功能是：</target>
        </trans-unit>
        <trans-unit id="97c094638bd844d3fa04f0e228195eec44c93a4f" translate="yes" xml:space="preserve">
          <source>In this example, a tuple of arrays was returned: one for each dimension. The first array represents the row indices where these values are found, and the second array represents the column indices where the values are found.</source>
          <target state="translated">在这个例子中,返回了一个数组的元组:每个维度一个。第一个数组代表找到这些值的行索引,第二个数组代表找到这些值的列索引。</target>
        </trans-unit>
        <trans-unit id="2729241cb81ad5eb6d0653ad987658266f4094e0" translate="yes" xml:space="preserve">
          <source>In this example, both the predictions and labels vectors contain three values, meaning &lt;code&gt;n&lt;/code&gt; has a value of three. After we carry out subtractions the values in the vector are squared. Then NumPy sums the values, and your result is the error value for that prediction and a score for the quality of the model.</source>
          <target state="translated">在此示例中，预测向量和标签向量都包含三个值，这意味着 &lt;code&gt;n&lt;/code&gt; 的值为三个。在执行减法后，向量中的值将平方。然后NumPy将这些值相加，结果就是该预测的误差值和模型质量的分数。</target>
        </trans-unit>
        <trans-unit id="e415859b6bc51789a95cf9e8d4d1433827763e1d" translate="yes" xml:space="preserve">
          <source>In this example, real input has an FFT which is Hermitian, i.e., symmetric in the real part and anti-symmetric in the imaginary part, as described in the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; documentation:</source>
          <target state="translated">在此示例中，实际输入具有FFT，即FFT，即厄米（Hermitian），即在实部是对称的，而在虚部是反对称的，如&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt;文档中所述：</target>
        </trans-unit>
        <trans-unit id="29fea9a7cda62d1da60b8f6659f247ccebc09681" translate="yes" xml:space="preserve">
          <source>In this example, the values within each row (i.e. the values along &lt;code&gt;axis=1&lt;/code&gt;) have been shuffled independently. This is not a &amp;ldquo;bulk&amp;rdquo; shuffle of the columns.</source>
          <target state="translated">在此示例中，每行内的值（即，沿 &lt;code&gt;axis=1&lt;/code&gt; 的值）已独立进行混洗。这不是列的&amp;ldquo;批量&amp;rdquo;洗牌。</target>
        </trans-unit>
        <trans-unit id="ceae5efa8d3a6692e49c8c2886b52adb07addf1c" translate="yes" xml:space="preserve">
          <source>In this example, weight has more impact on the distance calculation than height because of the larger values. In practice, it is important to normalize the height and weight, often by their standard deviation across the data set, so that both have equal influence on the distance calculation.</source>
          <target state="translated">在这个例子中,由于数值较大,重量对距离计算的影响比身高大。在实践中,对身高和体重进行归一化是很重要的,通常是通过它们在整个数据集中的标准差来进行归一化,从而使两者对距离计算的影响相等。</target>
        </trans-unit>
        <trans-unit id="621a7738a5786c3d0bc05ac14226a4d89a893dbf" translate="yes" xml:space="preserve">
          <source>In this part, we check the compiler and platform architecture and cache some of the intermediary results to speed up rebuilding.</source>
          <target state="translated">在这部分,我们检查编译器和平台架构,并缓存一些中间结果,以加快重建速度。</target>
        </trans-unit>
        <trans-unit id="2c3e40fb7708f540adaa0b760c857b87aaa0e15a" translate="yes" xml:space="preserve">
          <source>In this shorthand notation any of the &lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes-constructing&quot;&gt;string dtype specifications&lt;/a&gt; may be used in a string and separated by commas. The itemsize and byte offsets of the fields are determined automatically, and the field names are given the default names &lt;code&gt;f0&lt;/code&gt;, &lt;code&gt;f1&lt;/code&gt;, etc.</source>
          <target state="translated">在这种简写形式中，可以在&lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes-constructing&quot;&gt;字符串&lt;/a&gt;中使用任何字符串dtype规范，并用逗号分隔。字段的项目大小和字节偏移量是自动确定的，并且字段名称被赋予默认名称 &lt;code&gt;f0&lt;/code&gt; ， &lt;code&gt;f1&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="03bc9d15047b673ea201dcf5663747af818d9b11" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will use a &lt;a href=&quot;https://en.wikipedia.org/wiki/Matrix_decomposition&quot;&gt;matrix decomposition&lt;/a&gt; from linear algebra, the Singular Value Decomposition, to generate a compressed approximation of an image. We&amp;rsquo;ll use the &lt;code&gt;face&lt;/code&gt; image from the &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/misc.html#module-scipy.misc&quot;&gt;&lt;code&gt;scipy.misc&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">在本教程中，我们将使用线性代数的&lt;a href=&quot;https://en.wikipedia.org/wiki/Matrix_decomposition&quot;&gt;矩阵分解&lt;/a&gt;（奇异值分解）来生成图像的压缩近似值。我们将使用来自&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/misc.html#module-scipy.misc&quot;&gt; &lt;code&gt;scipy.misc&lt;/code&gt; &lt;/a&gt;模块的 &lt;code&gt;face&lt;/code&gt; 图像：</target>
        </trans-unit>
        <trans-unit id="7b71631798c22c7379ee16411ed600d40ef635fc" translate="yes" xml:space="preserve">
          <source>In two dimensions, the DFT is defined as</source>
          <target state="translated">在二维中,DFT定义为</target>
        </trans-unit>
        <trans-unit id="e78643ae03c902815fce8ed7873dad947453bab7" translate="yes" xml:space="preserve">
          <source>In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_ macro namespace in them. That form of the constant names is deprecated in 1.7.</source>
          <target state="translated">在NumPy的1.6及更早的版本中,以下标志中没有_ARRAY_宏命名空间。这种形式的常量名称在1.7中已经被废弃。</target>
        </trans-unit>
        <trans-unit id="2eb3748bd4c40ee385c34a340546b34ff09c6d0f" translate="yes" xml:space="preserve">
          <source>In versions of NumPy prior to 1.7, this function always returned a new, independent array containing a copy of the values in the diagonal.</source>
          <target state="translated">在1.7之前的NumPy版本中,这个函数总是返回一个新的、独立的数组,其中包含对角线中数值的副本。</target>
        </trans-unit>
        <trans-unit id="0dd37ad2fb32e65c87fa0dbb4334407e5e86a994" translate="yes" xml:space="preserve">
          <source>In what NumPy version the object was deprecated, and when it will be removed.</source>
          <target state="translated">该对象在哪个NumPy版本中被废弃,何时会被删除。</target>
        </trans-unit>
        <trans-unit id="7e3012fb521e71655f173862b6d8385b1b505394" translate="yes" xml:space="preserve">
          <source>In-Place Arrays</source>
          <target state="translated">原位阵列</target>
        </trans-unit>
        <trans-unit id="4515cac8ae9188e7e6a2adf0d7162014d11595d3" translate="yes" xml:space="preserve">
          <source>In-place arrays are defined as arrays that are modified in-place. The input values may or may not be used, but the values at the time the function returns are significant. The provided Python argument must therefore be a NumPy array of the required type. The in-place signatures are</source>
          <target state="translated">就地数组定义为就地修改的数组。输入的值可能被使用,也可能不被使用,但函数返回时的值是重要的。因此,所提供的 Python 参数必须是所需类型的 NumPy 数组。就地修改的签名是</target>
        </trans-unit>
        <trans-unit id="e156e5cac1a2d58a18cbdda52494e20ca1917186" translate="yes" xml:space="preserve">
          <source>In-place sort.</source>
          <target state="translated">就地排序。</target>
        </trans-unit>
        <trans-unit id="1b17facd69825957b71025146a41a688f572e12c" translate="yes" xml:space="preserve">
          <source>In-place vs. copy</source>
          <target state="translated">原地与复制</target>
        </trans-unit>
        <trans-unit id="79b98df32c7e9b7cb0e464788719f6ba70f3ff64" translate="yes" xml:space="preserve">
          <source>Incident reporting resolution &amp;amp; Code of Conduct enforcement</source>
          <target state="translated">事件报告解决和行为准则执行</target>
        </trans-unit>
        <trans-unit id="39926c846ddd25391c819a29fabc7871561feccd" translate="yes" xml:space="preserve">
          <source>Include subheadings. They help readers grasp what&amp;rsquo;s coming and return where they left off.</source>
          <target state="translated">包括副标题。它们可以帮助读者了解即将发生的事情，并返回到上次停止的地方。</target>
        </trans-unit>
        <trans-unit id="b4bca44476188a1ecb19a525fa3cea9a4f2c6b0a" translate="yes" xml:space="preserve">
          <source>Included in the &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;numpy.genfromtxt&lt;/code&gt;&lt;/a&gt; function call, we have selected the &lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt; for each subset of the data (either an integer - &lt;a href=&quot;../reference/arrays.scalars#numpy.int_&quot;&gt;&lt;code&gt;numpy.int_&lt;/code&gt;&lt;/a&gt; - or a string of characters - &lt;a href=&quot;../reference/arrays.scalars#numpy.unicode_&quot;&gt;&lt;code&gt;numpy.unicode_&lt;/code&gt;&lt;/a&gt;). We have also used the &lt;code&gt;encoding&lt;/code&gt; argument to select &lt;code&gt;utf-8-sig&lt;/code&gt; as the encoding for the file (read more about encoding in the &lt;a href=&quot;https://docs.python.org/3/library/codecs.html#encodings-and-unicode&quot;&gt;official Python documentation&lt;/a&gt;). You can read more about the &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;numpy.genfromtxt&lt;/code&gt;&lt;/a&gt; function from the &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;Reference Documentation&lt;/code&gt;&lt;/a&gt; or from the &lt;a href=&quot;basics.io.genfromtxt&quot;&gt;Basic IO tutorial&lt;/a&gt;.</source>
          <target state="translated">包括在&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;numpy.genfromtxt&lt;/code&gt; &lt;/a&gt;函数调用，我们选择了&lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;numpy.dtype&lt;/code&gt; &lt;/a&gt;为数据的每个子集（一个整数- &lt;a href=&quot;../reference/arrays.scalars#numpy.int_&quot;&gt; &lt;code&gt;numpy.int_&lt;/code&gt; &lt;/a&gt; -或字符的字符串- &lt;a href=&quot;../reference/arrays.scalars#numpy.unicode_&quot;&gt; &lt;code&gt;numpy.unicode_&lt;/code&gt; &lt;/a&gt;）。我们还使用了 &lt;code&gt;encoding&lt;/code&gt; 参数来选择 &lt;code&gt;utf-8-sig&lt;/code&gt; 作为文件的编码（在&lt;a href=&quot;https://docs.python.org/3/library/codecs.html#encodings-and-unicode&quot;&gt;Python官方文档中&lt;/a&gt;了解有关编码的更多信息）。您可以从&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;Reference Documentation&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;basics.io.genfromtxt&quot;&gt;基本IO教程中&lt;/a&gt;了解有关&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;numpy.genfromtxt&lt;/code&gt; &lt;/a&gt;函数的更多信息。</target>
        </trans-unit>
        <trans-unit id="0c1195d8c8b6b9e2d6ec4d935a14c881a29bcc75" translate="yes" xml:space="preserve">
          <source>Incorrect &lt;code&gt;threshold&lt;/code&gt; in &lt;code&gt;np.set_printoptions&lt;/code&gt; raises &lt;code&gt;TypeError&lt;/code&gt; or &lt;code&gt;ValueError&lt;/code&gt;</source>
          <target state="translated">不正确 &lt;code&gt;threshold&lt;/code&gt; 在 &lt;code&gt;np.set_printoptions&lt;/code&gt; 引发 &lt;code&gt;TypeError&lt;/code&gt; 或 &lt;code&gt;ValueError&lt;/code&gt; 异常</target>
        </trans-unit>
        <trans-unit id="2070997d3a1215cd23a07fdeb2caa1389920935f" translate="yes" xml:space="preserve">
          <source>Increased performance in &lt;code&gt;random.permutation&lt;/code&gt; for multidimensional arrays</source>
          <target state="translated">提高多维数组 &lt;code&gt;random.permutation&lt;/code&gt; 的性能</target>
        </trans-unit>
        <trans-unit id="e7086e912a42ead51516c8a8180bf48b02a02ed8" translate="yes" xml:space="preserve">
          <source>Incremement the index and the dataptr members of the &lt;em&gt;iterator&lt;/em&gt; to point to the next element of the array. If the array is not (C-style) contiguous, also increment the N-dimensional coordinates array.</source>
          <target state="translated">增加&lt;em&gt;迭代器&lt;/em&gt;的索引和dataptr成员以指向数组的下一个元素。如果数组不是（C样式）连续的，则还要增加N维坐标数组。</target>
        </trans-unit>
        <trans-unit id="7a7d2f744a7296cdaea426008f157d69008c6d52" translate="yes" xml:space="preserve">
          <source>Increment items 0 and 1, and increment item 2 twice:</source>
          <target state="translated">将项目0和1递增,项目2递增两次。</target>
        </trans-unit>
        <trans-unit id="aa0f6e205ff77646c8e4c26a5cd802d06b0ed1ab" translate="yes" xml:space="preserve">
          <source>Increment the multi-dimensional index by one.</source>
          <target state="translated">将多维指数递增1。</target>
        </trans-unit>
        <trans-unit id="1431536c5cec1e86a2b496f9aea15a2431b6da9a" translate="yes" xml:space="preserve">
          <source>Increment the release number in setup.py. Release candidates should have &amp;ldquo;rc1&amp;rdquo; (or &amp;ldquo;rc2&amp;rdquo;, &amp;ldquo;rcN&amp;rdquo;) appended to the X.Y.Z format.</source>
          <target state="translated">增加setup.py中的发行版号。候选发布版本应在XYZ格式后附加&amp;ldquo; rc1&amp;rdquo;（或&amp;ldquo; rc2&amp;rdquo;，&amp;ldquo; rcN&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="47bbbc7bbd392dc811939b0ca8df290ae66b6625" translate="yes" xml:space="preserve">
          <source>Indeed, the fact is that Python indexing on lists and other sequences naturally leads to an outside-to inside ordering (the first index gets the largest grouping, the next the next largest, and the last gets the smallest element). Since image data are normally stored by rows, this corresponds to position within rows being the last item indexed.</source>
          <target state="translated">事实上,Python 在列表和其他序列上的索引自然会导致从外到内的排序(第一个索引得到最大的分组,下一个索引得到下一个最大的分组,最后一个索引得到最小的元素)。由于图像数据通常是按行来存储的,这就相当于行内的位置是最后一个索引的项目。</target>
        </trans-unit>
        <trans-unit id="a955748860a9401904eff7aeb318142866860450" translate="yes" xml:space="preserve">
          <source>Independent Streams</source>
          <target state="translated">独立流</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="9362b6e75e3f28d4a83666c8ba00890a4d410bc7" translate="yes" xml:space="preserve">
          <source>Index arrays</source>
          <target state="translated">索引数组</target>
        </trans-unit>
        <trans-unit id="8b7ef6cce7547dfa6d1e0bda509869536452ee0c" translate="yes" xml:space="preserve">
          <source>Index arrays may be combined with slices. For example:</source>
          <target state="translated">索引数组可以与切片相结合。例如:</target>
        </trans-unit>
        <trans-unit id="c44a201623d0e3d087173369dce55b524d144281" translate="yes" xml:space="preserve">
          <source>Index arrays must be of integer type. Each value in the array indicates which value in the array to use in place of the index. To illustrate:</source>
          <target state="translated">索引数组必须是整数类型。数组中的每个值都表示要用数组中的哪个值来代替索引。举例说明:</target>
        </trans-unit>
        <trans-unit id="1a35691c6c1bb32304626e5515963a9a6c7ec2da" translate="yes" xml:space="preserve">
          <source>Index of the diagonal: 0 (the default) refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal.</source>
          <target state="translated">对角线的索引:0(默认)表示主对角线,正值表示上对角线,负值表示下对角线。</target>
        </trans-unit>
        <trans-unit id="119920061dcb691e0fcbed0a1783c9e871f11ec5" translate="yes" xml:space="preserve">
          <source>Index of the diagonal: 0 refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal.</source>
          <target state="translated">对角线的指数:0表示主对角线,正值表示上对角线,负值表示下对角线。</target>
        </trans-unit>
        <trans-unit id="383b324a3291b51f1e54ef9c0d763010fbc5e171" translate="yes" xml:space="preserve">
          <source>IndexError</source>
          <target state="translated">IndexError</target>
        </trans-unit>
        <trans-unit id="57f71bf775773f532dceb2dabadcde07069670df" translate="yes" xml:space="preserve">
          <source>Indexes of the maximal elements of a N-dimensional array:</source>
          <target state="translated">N维数组中最大元素的索引。</target>
        </trans-unit>
        <trans-unit id="c30b085b29907fc8dd1fcc4ba9d8f5fab779ff0b" translate="yes" xml:space="preserve">
          <source>Indexes of the maximum values along an axis.</source>
          <target state="translated">沿轴的最大值的索引。</target>
        </trans-unit>
        <trans-unit id="f9b599db4bf0df8d9bbcf7c5db6a037f6e6e69aa" translate="yes" xml:space="preserve">
          <source>Indexes of the minimum values along an axis.</source>
          <target state="translated">沿轴的最小值的索引。</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="ca22a585bfdf222b22aaead59f3666212fc40ce0" translate="yes" xml:space="preserve">
          <source>Indexing &lt;code&gt;x['field-name']&lt;/code&gt; returns a new &lt;a href=&quot;../glossary#term-view&quot;&gt;view&lt;/a&gt; to the array, which is of the same shape as &lt;em&gt;x&lt;/em&gt; (except when the field is a sub-array) but of data type &lt;code&gt;x.dtype['field-name']&lt;/code&gt; and contains only the part of the data in the specified field. Also &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record array&lt;/a&gt; scalars can be &amp;ldquo;indexed&amp;rdquo; this way.</source>
          <target state="translated">索引 &lt;code&gt;x['field-name']&lt;/code&gt; 会将新&lt;a href=&quot;../glossary#term-view&quot;&gt;视图&lt;/a&gt;返回到数组，该视图与&lt;em&gt;x&lt;/em&gt;具有相同的形状（当字段是子数组时除外），但数据类型为 &lt;code&gt;x.dtype['field-name']&lt;/code&gt; 并且仅包含指定字段中的部分数据。还&lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;记录阵列&lt;/a&gt;标量可以被&amp;ldquo;索引&amp;rdquo;这种方式。</target>
        </trans-unit>
        <trans-unit id="b59c12801d6fa741bd0be2abcd90167bf71d161c" translate="yes" xml:space="preserve">
          <source>Indexing &lt;code&gt;x['field-name']&lt;/code&gt; returns a new &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;view&lt;/a&gt; to the array, which is of the same shape as &lt;em&gt;x&lt;/em&gt; (except when the field is a sub-array) but of data type &lt;code&gt;x.dtype['field-name']&lt;/code&gt; and contains only the part of the data in the specified field. Also &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record array&lt;/a&gt; scalars can be &amp;ldquo;indexed&amp;rdquo; this way.</source>
          <target state="translated">索引 &lt;code&gt;x['field-name']&lt;/code&gt; 返回数组的新&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;视图&lt;/a&gt;，该视图与&lt;em&gt;x&lt;/em&gt;具有相同的形状（当字段是子数组时除外），但数据类型为 &lt;code&gt;x.dtype['field-name']&lt;/code&gt; 并且仅包含指定字段中的部分数据。还&lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;记录阵列&lt;/a&gt;标量可以被&amp;ldquo;索引&amp;rdquo;这种方式。</target>
        </trans-unit>
        <trans-unit id="9542b665971d159d6c17d4f34752698e601626e8" translate="yes" xml:space="preserve">
          <source>Indexing MaskedArrays/Constants with &lt;code&gt;...&lt;/code&gt; (ellipsis) now returns MaskedArray</source>
          <target state="translated">现在使用 &lt;code&gt;...&lt;/code&gt; （省略号）索引MaskedArrays /常量的索引将返回MaskedArray</target>
        </trans-unit>
        <trans-unit id="a956de2c65434dac2e3f2395af98a63c09e0e921" translate="yes" xml:space="preserve">
          <source>Indexing Multi-dimensional arrays</source>
          <target state="translated">多维数组的索引</target>
        </trans-unit>
        <trans-unit id="d29f8c2cdcd3c7159d7617a4b4b26d63a3389924" translate="yes" xml:space="preserve">
          <source>Indexing Structured Arrays</source>
          <target state="translated">结构化数组的索引</target>
        </trans-unit>
        <trans-unit id="370bbc588e0d38b8f416d5dcc2dcf3fc93d26630" translate="yes" xml:space="preserve">
          <source>Indexing a single element of a structured array (with an integer index) returns a structured scalar:</source>
          <target state="translated">对结构化数组的单个元素进行索引(带整数索引),返回一个结构化标量。</target>
        </trans-unit>
        <trans-unit id="1544ebdc7ceef1dd43c207ab5e502bb881e63b2a" translate="yes" xml:space="preserve">
          <source>Indexing and Assignment to Structured arrays</source>
          <target state="translated">索引和对结构化数组的赋值</target>
        </trans-unit>
        <trans-unit id="3b75e279fb5c7684c193076341ad2da99a787445" translate="yes" xml:space="preserve">
          <source>Indexing and slicing</source>
          <target state="translated">索引和切片</target>
        </trans-unit>
        <trans-unit id="c620de8536d4e92665cc1da6338b0e3c9ccd772a" translate="yes" xml:space="preserve">
          <source>Indexing and slicing operations are useful when you&amp;rsquo;re manipulating matrices:</source>
          <target state="translated">在处理矩阵时，索引和切片操作非常有用：</target>
        </trans-unit>
        <trans-unit id="9f16e8a5deb5dca320283bcd174b16dd9a73b2c2" translate="yes" xml:space="preserve">
          <source>Indexing arrays</source>
          <target state="translated">索引数组</target>
        </trans-unit>
        <trans-unit id="32cfd79e57bf8a3877f833f091f428533e7b10d7" translate="yes" xml:space="preserve">
          <source>Indexing basics</source>
          <target state="translated">索引编制基础知识</target>
        </trans-unit>
        <trans-unit id="1462dc0b9b6cce394c3657c4670ba55a345bb68a" translate="yes" xml:space="preserve">
          <source>Indexing errors will be reported even when index result is empty</source>
          <target state="translated">即使索引结果为空,也会报告索引错误。</target>
        </trans-unit>
        <trans-unit id="43bc37d1483f275b849fa10b51ee75dd7340e249" translate="yes" xml:space="preserve">
          <source>Indexing into a structured array can also be done with a list of field names, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt;. As of NumPy 1.16 this returns a view containing only those fields. In older versions of numpy it returned a copy. See the user guide section on &lt;a href=&quot;../user/basics.rec#structured-arrays&quot;&gt;Structured arrays&lt;/a&gt; for more information on multifield indexing.</source>
          <target state="translated">也可以使用字段名称列表来完成对结构化数组的索引，&lt;em&gt;例如&lt;/em&gt; &lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt; 。从NumPy 1.16开始，它将返回仅包含这些字段的视图。在旧版本的numpy中，它返回了一个副本。有关多字段索引的更多信息，请参见&lt;a href=&quot;../user/basics.rec#structured-arrays&quot;&gt;结构化数组&lt;/a&gt;的用户指南部分。</target>
        </trans-unit>
        <trans-unit id="287cc46fe81b17127e826e2dc4d460f956256411" translate="yes" xml:space="preserve">
          <source>Indexing into a structured array can also be done with a list of field names, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt;. As of NumPy 1.16 this returns a view containing only those fields. In older versions of numpy it returned a copy. See the user guide section on &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#structured-arrays&quot;&gt;Structured arrays&lt;/a&gt; for more information on multifield indexing.</source>
          <target state="translated">也可以使用字段名称列表（&lt;em&gt;例如&lt;/em&gt; &lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt; 索引到结构化数组中。从NumPy 1.16开始，它将返回仅包含这些字段的视图。在旧版本的numpy中，它返回了一个副本。有关多字段索引的更多信息，请参见&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#structured-arrays&quot;&gt;结构化数组&lt;/a&gt;的用户指南部分。</target>
        </trans-unit>
        <trans-unit id="f9931083a6e7f53e9bc486a3df5e5e7c8488e9d6" translate="yes" xml:space="preserve">
          <source>Indexing routines</source>
          <target state="translated">索引程序</target>
        </trans-unit>
        <trans-unit id="6e79a0e3c54ea0ceb91b9669283adab9f2147f0b" translate="yes" xml:space="preserve">
          <source>Indexing with Arrays of Indices</source>
          <target state="translated">使用索引数组进行索引</target>
        </trans-unit>
        <trans-unit id="a5b7926d0e1062fbea55528bbcec6310b0c56043" translate="yes" xml:space="preserve">
          <source>Indexing with Boolean Arrays</source>
          <target state="translated">使用布尔数组进行索引</target>
        </trans-unit>
        <trans-unit id="3484dfe82dee2e7bac292b6534b5cbe2647cd408" translate="yes" xml:space="preserve">
          <source>Indexing with an Integer to get a Structured Scalar</source>
          <target state="translated">用整数进行索引以获得结构化的标量。</target>
        </trans-unit>
        <trans-unit id="090d4c4fc948bc8eed34fc6e8ddf8e7bd5be023c" translate="yes" xml:space="preserve">
          <source>Indexing with strings</source>
          <target state="translated">用字符串做索引</target>
        </trans-unit>
        <trans-unit id="2794b9b37dd0d88704ab33758cd5ea559027c74f" translate="yes" xml:space="preserve">
          <source>Indexing, Slicing and Iterating</source>
          <target state="translated">索引、切片和迭代。</target>
        </trans-unit>
        <trans-unit id="a0b6ddf08f9938b1aef1c27a89f039c34d4ed175" translate="yes" xml:space="preserve">
          <source>Indexing-like operations</source>
          <target state="translated">类似索引的操作</target>
        </trans-unit>
        <trans-unit id="0454b105259e523f13a84d0a1ff2499fbf44bf18" translate="yes" xml:space="preserve">
          <source>Indicate how the user of the iterator will read or write to &lt;code&gt;op[i]&lt;/code&gt;. Exactly one of these flags must be specified per operand. Using &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; or &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; for a user-provided operand may trigger &lt;code&gt;WRITEBACKIFCOPY`&lt;/code&gt; semantics. The data will be written back to the original array when &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; is called.</source>
          <target state="translated">指示迭代器的用户如何读取或写入 &lt;code&gt;op[i]&lt;/code&gt; 。必须为每个操作数指定这些标志之一。对用户提供的操作数使用 &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; 或 &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; 可能会触发 &lt;code&gt;WRITEBACKIFCOPY`&lt;/code&gt; 语义。调用 &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; 时，数据将写回到原始数组。</target>
        </trans-unit>
        <trans-unit id="ba89764e8d83fcb18f052ec54405d196f55000ee" translate="yes" xml:space="preserve">
          <source>Indicate indices of sub-arrays to remove along the specified axis.</source>
          <target state="translated">指明要沿着指定的轴删除的子数组的指数。</target>
        </trans-unit>
        <trans-unit id="ff289ba1c19ab34e00eb1d52160a46b6efb2713b" translate="yes" xml:space="preserve">
          <source>Indicates arrays of this data-type must be converted to a list before pickling.</source>
          <target state="translated">表示该数据类型的数组在拣选前必须转换为列表。</target>
        </trans-unit>
        <trans-unit id="327748da6a9d945d96e091b8e7383b60afba1da7" translate="yes" xml:space="preserve">
          <source>Indicates memory for this data-type must be initialized (set to 0) on creation.</source>
          <target state="translated">表示该数据类型的内存必须在创建时被初始化(设置为0)。</target>
        </trans-unit>
        <trans-unit id="4bc4530525549adc3e6afe819ca6b79c82a0ab71" translate="yes" xml:space="preserve">
          <source>Indicates that arrays with a size of zero should be permitted. Since the typical iteration loop does not naturally work with zero-sized arrays, you must check that the IterSize is larger than zero before entering the iteration loop. Currently only the operands are checked, not a forced shape.</source>
          <target state="translated">表示应该允许使用大小为零的数组。由于典型的迭代循环并不能自然地使用零大小的数组,所以在进入迭代循环之前必须检查IterSize是否大于零。目前只检查操作数,不检查强制形状。</target>
        </trans-unit>
        <trans-unit id="3f20ca03a166ca2b12eed667d0c9d43d498dcabe" translate="yes" xml:space="preserve">
          <source>Indicates that arrays with reference types (object arrays or structured arrays containing an object type) may be accepted and used in the iterator. If this flag is enabled, the caller must be sure to check whether &lt;code&gt;NpyIter_IterationNeedsAPI(iter)&lt;/code&gt; is true, in which case it may not release the GIL during iteration.</source>
          <target state="translated">指示在迭代器中可以接受和使用具有引用类型的数组（对象数组或包含对象类型的结构化数组）。如果启用此标志，则调用者必须确保检查 &lt;code&gt;NpyIter_IterationNeedsAPI(iter)&lt;/code&gt; 是否为true，在这种情况下，它可能不会在迭代过程中释放GIL。</target>
        </trans-unit>
        <trans-unit id="e809396a40c3ec96fdae3328ed0a31c66576c7c0" translate="yes" xml:space="preserve">
          <source>Indicates that items of this data-type must be reference counted (using &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">指示此数据类型的项目必须是参照（使用计数&lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt; &lt;code&gt;Py_DECREF&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="03ad2756a493f01508378680f8d907e50dad0e86" translate="yes" xml:space="preserve">
          <source>Indicates that this operand is the mask to use for selecting elements when writing to operands which have the &lt;a href=&quot;#c.NPY_ITER_WRITEMASKED&quot;&gt;&lt;code&gt;NPY_ITER_WRITEMASKED&lt;/code&gt;&lt;/a&gt; flag applied to them. Only one operand may have &lt;a href=&quot;#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; flag applied to it.</source>
          <target state="translated">指示此操作数是在写入应用了&lt;a href=&quot;#c.NPY_ITER_WRITEMASKED&quot;&gt; &lt;code&gt;NPY_ITER_WRITEMASKED&lt;/code&gt; &lt;/a&gt;标志的操作数时用于选择元素的掩码。只有一个操作数可以应用&lt;a href=&quot;#c.NPY_ITER_ARRAYMASK&quot;&gt; &lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt; &lt;/a&gt;标志。</target>
        </trans-unit>
        <trans-unit id="613ac9b34fa48eda3d48ba0a932ba15f0204a86f" translate="yes" xml:space="preserve">
          <source>Indicates the item is a pointer to some other data-type</source>
          <target state="translated">表示该项目是指向其他数据类型的指针。</target>
        </trans-unit>
        <trans-unit id="6f07bb702873a42eecec00d6bf9d09bfd0c31b06" translate="yes" xml:space="preserve">
          <source>Indicates this data-type requires the Python C-API during access (so don&amp;rsquo;t give up the GIL if array access is going to be needed).</source>
          <target state="translated">指示此数据类型在访问期间需要Python C-API（因此，如果需要数组访问，请不要放弃GIL）。</target>
        </trans-unit>
        <trans-unit id="d5ca13d01e4aee97ba5ebf7dbc18794ab7e82eae" translate="yes" xml:space="preserve">
          <source>Indicating whether the intervals include the right or the left bin edge. Default behavior is (right==False) indicating that the interval does not include the right edge. The left bin end is open in this case, i.e., bins[i-1] &amp;lt;= x &amp;lt; bins[i] is the default behavior for monotonically increasing bins.</source>
          <target state="translated">指示间隔是包括右边还是左边的边沿。默认行为是（right == False），指示间隔不包括右边缘。在这种情况下，左侧料斗末端是敞开的，即bins [i-1] &amp;lt;= x &amp;lt;bins [i]是单调递增料斗的默认行为。</target>
        </trans-unit>
        <trans-unit id="ca9cfe4e704c12c6c1fa5c4b576973839a44850c" translate="yes" xml:space="preserve">
          <source>Indices can also be grouped by element.</source>
          <target state="translated">指数也可以按元素分组。</target>
        </trans-unit>
        <trans-unit id="14ad131012032e9e04ca04f6d1ddd8fbcaa3e2c0" translate="yes" xml:space="preserve">
          <source>Indices for the upper-triangle of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 的上三角符号。</target>
        </trans-unit>
        <trans-unit id="05056f495c02c0b518e0436ff12d0703c782c034" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero.</source>
          <target state="translated">非零元素的指数。</target>
        </trans-unit>
        <trans-unit id="91841f1f82f1c15d4b5be121831bfdfa7d539a5a" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero. Indices are grouped by element.</source>
          <target state="translated">非零元素的指数。指数按元素分组。</target>
        </trans-unit>
        <trans-unit id="7756fd7ee8f7161ab914664d39dc9bedefea080d" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero. Indices are grouped by element. This array will have shape &lt;code&gt;(N, a.ndim)&lt;/code&gt; where &lt;code&gt;N&lt;/code&gt; is the number of non-zero items.</source>
          <target state="translated">非零元素的索引。索引按元素分组。此数组将具有形状 &lt;code&gt;(N, a.ndim)&lt;/code&gt; ，其中 &lt;code&gt;N&lt;/code&gt; 是非零项目的数量。</target>
        </trans-unit>
        <trans-unit id="b94c56d6a6bfbdfee7bbd9db799f4cac5be86fa1" translate="yes" xml:space="preserve">
          <source>Indices of the minimum elements of a N-dimensional array:</source>
          <target state="translated">N维数组中最小元素的指数。</target>
        </trans-unit>
        <trans-unit id="764406c1c2d21f5c9a93e6d3d66afbc9de92b722" translate="yes" xml:space="preserve">
          <source>Indices of the sorted elements of a N-dimensional array:</source>
          <target state="translated">N维数组的排序元素的指数。</target>
        </trans-unit>
        <trans-unit id="d010fa85fcc511735fc1ba118d8c9fa77c46fb33" translate="yes" xml:space="preserve">
          <source>Indices to change along each 1d slice of &lt;code&gt;arr&lt;/code&gt;. This must match the dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast against &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">沿 &lt;code&gt;arr&lt;/code&gt; 的每个1d切片变化的指标。这必须匹配arr的尺寸，但是要针对 &lt;code&gt;arr&lt;/code&gt; 广播，Ni和Nj中的尺寸可能为1 。</target>
        </trans-unit>
        <trans-unit id="bd4ed66b25e3e81f7c09020b3e15317e8ebab751" translate="yes" xml:space="preserve">
          <source>Indices to take along each 1d slice of &lt;code&gt;arr&lt;/code&gt;. This must match the dimension of arr, but dimensions Ni and Nj only need to broadcast against &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">沿 &lt;code&gt;arr&lt;/code&gt; 的每一1d切片取的指数。这必须匹配arr的尺寸，但是尺寸Ni和Nj仅需要针对 &lt;code&gt;arr&lt;/code&gt; 广播。</target>
        </trans-unit>
        <trans-unit id="7dfac1d76acfef8a43ec3bb5c63e278bd2c2aa5a" translate="yes" xml:space="preserve">
          <source>Indirect partial sort.</source>
          <target state="translated">间接部分排序。</target>
        </trans-unit>
        <trans-unit id="67b91131b038b258475621be16da6d4bad633d9d" translate="yes" xml:space="preserve">
          <source>Indirect partition.</source>
          <target state="translated">间接分区。</target>
        </trans-unit>
        <trans-unit id="ceed8c74919b3d66cbcd799fe2d4bb252d0af6a7" translate="yes" xml:space="preserve">
          <source>Indirect sort.</source>
          <target state="translated">间接排序。</target>
        </trans-unit>
        <trans-unit id="7a7f09efc9fe3734b3bf1afc86adc2e542a21680" translate="yes" xml:space="preserve">
          <source>Indirect stable sort on multiple keys.</source>
          <target state="translated">多键间接稳定排序。</target>
        </trans-unit>
        <trans-unit id="80cc0e6eec2203fc2c38742d008a3fb864036a7b" translate="yes" xml:space="preserve">
          <source>Indirect stable sort with multiple keys.</source>
          <target state="translated">多键间接稳定排序。</target>
        </trans-unit>
        <trans-unit id="f2d326af87bc022a272e7d1fdc4716803c23e396" translate="yes" xml:space="preserve">
          <source>Individual fields of a structured array may be accessed and modified by indexing the array with the field name.</source>
          <target state="translated">结构化数组的各个字段可以通过字段名的索引来访问和修改。</target>
        </trans-unit>
        <trans-unit id="8e9e048443c76eaece9af376ed6551264b94a4e9" translate="yes" xml:space="preserve">
          <source>Individual values are not stripped of spaces by default. When using a custom converter, make sure the function does remove spaces.</source>
          <target state="translated">默认情况下,单个值不会去掉空格。当使用自定义转换器时,请确保该函数能去除空格。</target>
        </trans-unit>
        <trans-unit id="5888912f1820a7f863f2cf1064c7ab5b1a9a9baa" translate="yes" xml:space="preserve">
          <source>Individuals come from different cultural backgrounds and native languages. Try to identify any honest misunderstandings caused by a non-native speaker and help them understand the issue and what they can change to avoid causing offence. Complex discussion in a foreign language can be very intimidating, and we want to grow our diversity also across nationalities and cultures.</source>
          <target state="translated">个人来自不同的文化背景和母语。试着找出由非母语者造成的任何诚实的误解,并帮助他们理解这个问题,以及他们可以改变什么以避免造成冒犯。用外语进行复杂的讨论可能会让人望而生畏,而我们也希望在不同的民族和文化中发展我们的多样性。</target>
        </trans-unit>
        <trans-unit id="f5284e6b831163b2d6ffbcfab454c705546fdd5b" translate="yes" xml:space="preserve">
          <source>Inexact matches for &lt;code&gt;mode&lt;/code&gt; and &lt;code&gt;searchside&lt;/code&gt; are deprecated</source>
          <target state="translated">不 &lt;code&gt;searchside&lt;/code&gt; 使用 &lt;code&gt;mode&lt;/code&gt; 和searchside的不精确匹配</target>
        </trans-unit>
        <trans-unit id="6e461615b9c8d1c487d2584ede06e5dc724ae1a4" translate="yes" xml:space="preserve">
          <source>Inexact types</source>
          <target state="translated">非精确类型</target>
        </trans-unit>
        <trans-unit id="a28ed132c608e3b4681e944b25690757eebfc33f" translate="yes" xml:space="preserve">
          <source>Inf (in module numpy)</source>
          <target state="translated">Inf</target>
        </trans-unit>
        <trans-unit id="5b675f1c2537bc4e7587a11173af58141e3f3972" translate="yes" xml:space="preserve">
          <source>Infinity (in module numpy)</source>
          <target state="translated">无限</target>
        </trans-unit>
        <trans-unit id="fbf064be21246c8a34df5396396140e055f24f53" translate="yes" xml:space="preserve">
          <source>Info are easily retrieved from the &lt;a href=&quot;distutils/misc_util#numpy.distutils.misc_util.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt; function in &lt;a href=&quot;distutils/misc_util#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">可以从&lt;a href=&quot;distutils/misc_util#module-numpy.distutils.misc_util&quot;&gt; &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; 中&lt;/a&gt;的&lt;a href=&quot;distutils/misc_util#numpy.distutils.misc_util.get_info&quot;&gt; &lt;code&gt;get_info&lt;/code&gt; &lt;/a&gt;函数轻松检索信息：</target>
        </trans-unit>
        <trans-unit id="ecae1f8d30472c9a7f54d4130dc7c3b85605f125" translate="yes" xml:space="preserve">
          <source>Info are easily retrieved from the &lt;code&gt;get_info&lt;/code&gt; function in &lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">可以从&lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt; &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; 中&lt;/a&gt;的 &lt;code&gt;get_info&lt;/code&gt; 函数轻松检索信息：</target>
        </trans-unit>
        <trans-unit id="ce47f6aad749dde8c374d70dfb4bb3378d690b1b" translate="yes" xml:space="preserve">
          <source>Information (via the dtype object) about the interpretation of the basic data element. The basic data element may be as simple as a int or a float, or it may be a compound object (e.g., struct-like), a fixed character field, or Python object pointers.</source>
          <target state="translated">关于基本数据元素的解释的信息 (通过 dtype 对象)。基本数据元素可以是简单的int或float,也可以是一个复合对象(例如,类似结构体)、一个固定的字符域或Python对象指针。</target>
        </trans-unit>
        <trans-unit id="bfbba3e12af5ea2c7741d834d66f7c560456f725" translate="yes" xml:space="preserve">
          <source>Information about sub-data-types in a &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;:</source>
          <target state="translated">有关&lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;结构化数据&lt;/a&gt;类型中的子数据类型的信息：</target>
        </trans-unit>
        <trans-unit id="87749b5a0427424240dbd899baaf24bccac8d963" translate="yes" xml:space="preserve">
          <source>Information about sub-data-types in a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;:</source>
          <target state="translated">有关&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;结构化数据&lt;/a&gt;类型中的子数据类型的信息：</target>
        </trans-unit>
        <trans-unit id="feb91fe9e3a82284bbc774141950eade27079231" translate="yes" xml:space="preserve">
          <source>Information about the memory layout of the array.</source>
          <target state="translated">阵列的内存布局信息。</target>
        </trans-unit>
        <trans-unit id="6c6da40785b1a9277377a0ac6b35aa661e1efec5" translate="yes" xml:space="preserve">
          <source>Information may include:</source>
          <target state="translated">资料可能包括:</target>
        </trans-unit>
        <trans-unit id="dd3e4c562ef15584e2226342046a4759c392aba8" translate="yes" xml:space="preserve">
          <source>Inherits?</source>
          <target state="translated">Inherits?</target>
        </trans-unit>
        <trans-unit id="b590718892221849c4b4d49b1a5feaa2b8ce90e3" translate="yes" xml:space="preserve">
          <source>Initialize all function pointers and members to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">将所有函数指针和成员初始化为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32bc5b2fd4039aefa8f94877a70e63431f9d15f4" translate="yes" xml:space="preserve">
          <source>Inner product</source>
          <target state="translated">内部产品</target>
        </trans-unit>
        <trans-unit id="1dba54e0b565dd813bcf7f4dd26137c8252036b6" translate="yes" xml:space="preserve">
          <source>Inner product of two arrays.</source>
          <target state="translated">两个数组的内积。</target>
        </trans-unit>
        <trans-unit id="064057f93ed4cdc0c2704e960d9c6d25cbbcac22" translate="yes" xml:space="preserve">
          <source>Inplace partition.</source>
          <target state="translated">Inplace partition.</target>
        </trans-unit>
        <trans-unit id="5afc0baf08aba247f1b2f3cdc0980c0ea2b6e83d" translate="yes" xml:space="preserve">
          <source>Inplace sort.</source>
          <target state="translated">Inplace out.</target>
        </trans-unit>
        <trans-unit id="d72a097ccb9c0003ebff6189ebb422b954b438f2" translate="yes" xml:space="preserve">
          <source>Input 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">输入一维&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80930bf11175241ae29fe59d0d272e2dd3fda246" translate="yes" xml:space="preserve">
          <source>Input &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; for which the mask is required.</source>
          <target state="translated">输入需要掩码的&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abfa0de453f55ea46910c5cb072561c46c566eda" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;MaskedArray&lt;/code&gt;, alternatively a ndarray or a subclass thereof.</source>
          <target state="translated">输入 &lt;code&gt;MaskedArray&lt;/code&gt; ，或者ndarray或其子类。</target>
        </trans-unit>
        <trans-unit id="ef6caaf1ffac65c55e3879237f23b9e4cd5b35fe" translate="yes" xml:space="preserve">
          <source>Input Arrays</source>
          <target state="translated">输入数组</target>
        </trans-unit>
        <trans-unit id="c77783bb0c7d4d2f9b2b8bd6478b069981c0866f" translate="yes" xml:space="preserve">
          <source>Input and output</source>
          <target state="translated">输入和输出</target>
        </trans-unit>
        <trans-unit id="43fab0b785a955e5195e8f3f11f33f3ad7b432bc" translate="yes" xml:space="preserve">
          <source>Input argument, can be of any type and shape.</source>
          <target state="translated">输入参数,可以是任何类型和形状。</target>
        </trans-unit>
        <trans-unit id="df78d5709935001a8bf74fe47ed30fca9beafae5" translate="yes" xml:space="preserve">
          <source>Input array</source>
          <target state="translated">输入阵列</target>
        </trans-unit>
        <trans-unit id="d573fb86d82f5065edfc4ca49f5112f03928d672" translate="yes" xml:space="preserve">
          <source>Input array in degrees.</source>
          <target state="translated">输入阵列的度数。</target>
        </trans-unit>
        <trans-unit id="c7b020a842b9509ee12f3acbb189d43b5a5c8e2b" translate="yes" xml:space="preserve">
          <source>Input array in radians.</source>
          <target state="translated">以弧度为单位的输入阵列。</target>
        </trans-unit>
        <trans-unit id="f139b5d61b47039d6645fe901089b8d7348e059e" translate="yes" xml:space="preserve">
          <source>Input array of size 1.</source>
          <target state="translated">输入数组大小为1。</target>
        </trans-unit>
        <trans-unit id="4fabb62ebf0299b3a11dc8870c6ebb3a76ef6ff9" translate="yes" xml:space="preserve">
          <source>Input array of strings to capitalize.</source>
          <target state="translated">输入要大写的字符串数组。</target>
        </trans-unit>
        <trans-unit id="8088eb90e795502e434844cfa6cdf9e95d4c9437" translate="yes" xml:space="preserve">
          <source>Input array of the same size as &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">输入数组的大小与 &lt;code&gt;condition&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="f46407fd3e6fc3c69904fb1af7940d31883ac983" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array, containing nan values to be ignored</source>
          <target state="translated">输入数组或可转换为数组的对象,包含要忽略的nan值。</target>
        </trans-unit>
        <trans-unit id="49d0fb63038b2721f65a3fb79be1b2a9aa62e9d2" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array, containing nan values to be ignored.</source>
          <target state="translated">输入数组或可转换为数组的对象,包含要忽略的nan值。</target>
        </trans-unit>
        <trans-unit id="1e12f84194e4961e84959b469b0f8a65e2620351" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array.</source>
          <target state="translated">输入数组或可转换为数组的对象。</target>
        </trans-unit>
        <trans-unit id="a14df91a899a43d15ec0d5b0ebc8a2a56f832cef" translate="yes" xml:space="preserve">
          <source>Input array to be binned. Prior to NumPy 1.10.0, this array had to be 1-dimensional, but can now have any shape.</source>
          <target state="translated">要进行分层的输入数组,在NumPy 1.10.0之前,这个数组必须是一维的,但现在可以是任何形状。在NumPy 1.10.0之前,这个数组必须是一维的,但现在可以有任何形状。</target>
        </trans-unit>
        <trans-unit id="bf15a8f66c7dacebdd89b7241fd4d11919829ad3" translate="yes" xml:space="preserve">
          <source>Input array to compute determinants for.</source>
          <target state="translated">用于计算行列式的输入数组。</target>
        </trans-unit>
        <trans-unit id="9eff9d201dcac2141e1679ca23a312d5c7800681" translate="yes" xml:space="preserve">
          <source>Input array to extend.</source>
          <target state="translated">要扩展的输入数组。</target>
        </trans-unit>
        <trans-unit id="7e287445198fc945368949e1412f5d8cb686139f" translate="yes" xml:space="preserve">
          <source>Input array to integrate.</source>
          <target state="translated">要整合的输入数组。</target>
        </trans-unit>
        <trans-unit id="85b9cb3f5f032dd1e9e0718bbfaa4576f72e78eb" translate="yes" xml:space="preserve">
          <source>Input array whose fields must be modified.</source>
          <target state="translated">输入数组,其字段必须被修改。</target>
        </trans-unit>
        <trans-unit id="42226304be73817a4e285cb433d2b7bb659c59a4" translate="yes" xml:space="preserve">
          <source>Input array with datetime or timedelta data type.</source>
          <target state="translated">输入数据类型为datetime或timedelta的数组。</target>
        </trans-unit>
        <trans-unit id="7c1847566b14607f43160463914cca58e1d1e0d6" translate="yes" xml:space="preserve">
          <source>Input array, a (subclass of) ndarray.</source>
          <target state="translated">输入数组,一个(ndarray的子类)。</target>
        </trans-unit>
        <trans-unit id="a4f57e9a75e6d26f7e8f35eb55623a7c6ae8a1b9" translate="yes" xml:space="preserve">
          <source>Input array, can be complex</source>
          <target state="translated">输入阵列,可以是复杂的</target>
        </trans-unit>
        <trans-unit id="1b7a137c8182cfa54895f3372cda87fe7e3932e7" translate="yes" xml:space="preserve">
          <source>Input array, can be complex.</source>
          <target state="translated">输入数组,可以很复杂。</target>
        </trans-unit>
        <trans-unit id="6d76cf24117a4b5288f54769d468e637657f37e2" translate="yes" xml:space="preserve">
          <source>Input array, from which the diagonals are taken.</source>
          <target state="translated">输入数组,从中提取对角线。</target>
        </trans-unit>
        <trans-unit id="2204886fc1fe79484a18e95229b508e3a16d8a88" translate="yes" xml:space="preserve">
          <source>Input array, has to be a square 2-D array.</source>
          <target state="translated">输入数组,必须是一个正方形的二维数组。</target>
        </trans-unit>
        <trans-unit id="4e7ee35a9b27cc189fd5faf36b937d455a1aa919" translate="yes" xml:space="preserve">
          <source>Input array, must be at least 2-D.</source>
          <target state="translated">输入阵列,必须至少是二维的。</target>
        </trans-unit>
        <trans-unit id="b7ba46399772c3a420055c71f8f5dda1e65da7f0" translate="yes" xml:space="preserve">
          <source>Input array, taken to be real.</source>
          <target state="translated">输入数组,取为实数。</target>
        </trans-unit>
        <trans-unit id="16ca749420dd58126c1f3f4ccf95ce2fc49387c9" translate="yes" xml:space="preserve">
          <source>Input array.</source>
          <target state="translated">输入阵列。</target>
        </trans-unit>
        <trans-unit id="05370e4965d51e56f1347351509792a8c2d8443c" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;x&lt;/code&gt; must be 1-D or 2-D, unless &lt;code&gt;ord&lt;/code&gt; is None. If both &lt;code&gt;axis&lt;/code&gt; and &lt;code&gt;ord&lt;/code&gt; are None, the 2-norm of &lt;code&gt;x.ravel&lt;/code&gt; will be returned.</source>
          <target state="translated">输入数组。如果 &lt;code&gt;axis&lt;/code&gt; 为None，则 &lt;code&gt;x&lt;/code&gt; 必须为1-D或2-D，除非 &lt;code&gt;ord&lt;/code&gt; 为None。如果 &lt;code&gt;axis&lt;/code&gt; 和 &lt;code&gt;ord&lt;/code&gt; 均为None，则将返回 &lt;code&gt;x.ravel&lt;/code&gt; 的2范数。</target>
        </trans-unit>
        <trans-unit id="e22a13f0e68b42a409027fe2f016234b4ec5feb3" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;x&lt;/code&gt; must be 1-D or 2-D.</source>
          <target state="translated">输入数组。如果 &lt;code&gt;axis&lt;/code&gt; 为&amp;ldquo;无&amp;rdquo;，则 &lt;code&gt;x&lt;/code&gt; 必须为一维或二维。</target>
        </trans-unit>
        <trans-unit id="a823c846105b9c9719fbae89a64d485cac5a4b66" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;sorter&lt;/code&gt; is None, then it must be sorted in ascending order, otherwise &lt;code&gt;sorter&lt;/code&gt; must be an array of indices that sort it.</source>
          <target state="translated">输入数组。如果 &lt;code&gt;sorter&lt;/code&gt; 为None，则必须按升序排序，否则 &lt;code&gt;sorter&lt;/code&gt; 必须是对其进行排序的索引数组。</target>
        </trans-unit>
        <trans-unit id="9358104d5c139fb6025e6e3c499456297f4494b9" translate="yes" xml:space="preserve">
          <source>Input array. It must conform to the Python-side of the array interface.</source>
          <target state="translated">输入数组。它必须符合数组接口的Pyth侧。</target>
        </trans-unit>
        <trans-unit id="6eef0d989b2fd6fdf464d508f694dc4a0a6a6caa" translate="yes" xml:space="preserve">
          <source>Input array. The elements in &lt;code&gt;a&lt;/code&gt; are read in the order specified by &lt;code&gt;order&lt;/code&gt;, and packed as a 1-D array.</source>
          <target state="translated">输入数组。中的元素 &lt;code&gt;a&lt;/code&gt; 被读入由指定的顺序 &lt;code&gt;order&lt;/code&gt; ，并包装为1-d阵列。</target>
        </trans-unit>
        <trans-unit id="88c5aa449f45fc85917596c4004dffe23e0b86ac" translate="yes" xml:space="preserve">
          <source>Input array. Unless &lt;code&gt;axis&lt;/code&gt; is specified, this will be flattened if it is not already 1-D.</source>
          <target state="translated">输入数组。除非指定了 &lt;code&gt;axis&lt;/code&gt; ，否则如果它不是一维的，它将被展平。</target>
        </trans-unit>
        <trans-unit id="c937c57a4f225878ef9dec01334ff4466710291e" translate="yes" xml:space="preserve">
          <source>Input arrays</source>
          <target state="translated">输入数组</target>
        </trans-unit>
        <trans-unit id="d4ab162cfec9e7e5f511b1323f2a38dced9855a6" translate="yes" xml:space="preserve">
          <source>Input arrays are defined as arrays of data that are passed into a routine but are not altered in-place or returned to the user. The Python input array is therefore allowed to be almost any Python sequence (such as a list) that can be converted to the requested type of array. The input array signatures are</source>
          <target state="translated">输入数组被定义为数据的数组,这些数据被传递到一个例程中,但不会被就地改变或返回给用户。因此,Python输入数组几乎可以是任何Python序列(如一个列表),可以转换为所请求的数组类型。输入数组的签名是</target>
        </trans-unit>
        <trans-unit id="098168471a46df6606b6ff9c9cd3ead3422de613" translate="yes" xml:space="preserve">
          <source>Input arrays of the same shape.</source>
          <target state="translated">输入相同形状的数组。</target>
        </trans-unit>
        <trans-unit id="27f64d53a246ed11a85c01a61d0a931b1d50a817" translate="yes" xml:space="preserve">
          <source>Input arrays to be compared.</source>
          <target state="translated">要比较的输入数组。</target>
        </trans-unit>
        <trans-unit id="6fed91f1bcdfc2569325e9089bbd325328b5c5e9" translate="yes" xml:space="preserve">
          <source>Input arrays to be multiplied. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">要相乘的输入数组。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="4a8e2cbe86fa87773992dad5fc91ec0f376d5ef6" translate="yes" xml:space="preserve">
          <source>Input arrays to compare.</source>
          <target state="translated">输入数组进行比较。</target>
        </trans-unit>
        <trans-unit id="66d649cf79701276da2a390f23e474c6ab2aff7f" translate="yes" xml:space="preserve">
          <source>Input arrays, scalars not allowed.</source>
          <target state="translated">输入数组,不允许输入标量。</target>
        </trans-unit>
        <trans-unit id="556a7ea15ff0974e693ba20b38993284bf2034ec" translate="yes" xml:space="preserve">
          <source>Input arrays.</source>
          <target state="translated">输入数组。</target>
        </trans-unit>
        <trans-unit id="ad9b94d855384626461316d89dd8037bff8db7bd" translate="yes" xml:space="preserve">
          <source>Input arrays. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">输入数组。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="d784452f6247a01f2c79aa8a172590665da159e0" translate="yes" xml:space="preserve">
          <source>Input arrays. They are flattened if they are not already 1D.</source>
          <target state="translated">输入数组。如果它们还不是1D,就会被扁平化。</target>
        </trans-unit>
        <trans-unit id="e48eae13547040a1f74bd1dc543d4762a4b7970d" translate="yes" xml:space="preserve">
          <source>Input arrays. Will be flattened if not already 1D.</source>
          <target state="translated">输入数组。如果还不是1D,将被扁平化。</target>
        </trans-unit>
        <trans-unit id="670ce16c58ae415abf92889322038709e2fa68ca" translate="yes" xml:space="preserve">
          <source>Input cash flows per time period. By convention, net &amp;ldquo;deposits&amp;rdquo; are negative and net &amp;ldquo;withdrawals&amp;rdquo; are positive. Thus, for example, at least the first element of &lt;code&gt;values&lt;/code&gt;, which represents the initial investment, will typically be negative.</source>
          <target state="translated">每个时间段的输入现金流量。按照惯例，净&amp;ldquo;存款&amp;rdquo;为负，净&amp;ldquo;取款&amp;rdquo;为正。因此，例如，至少代表初始投资的 &lt;code&gt;values&lt;/code&gt; 的第一要素通常为负。</target>
        </trans-unit>
        <trans-unit id="00f0d4d4fb6b101c2c16fbc5749470d99cd4de8c" translate="yes" xml:space="preserve">
          <source>Input class. If a tuple of classes, True is returned if &lt;code&gt;arg1&lt;/code&gt; is a subclass of any of the tuple elements.</source>
          <target state="translated">输入类别。如果是类的元组，则当 &lt;code&gt;arg1&lt;/code&gt; 是任何元组元素的子类时，则返回True 。</target>
        </trans-unit>
        <trans-unit id="2bad44bea0aeffb47c89150e3263bb8f1abd9181" translate="yes" xml:space="preserve">
          <source>Input class. True is returned if &lt;code&gt;arg1&lt;/code&gt; is a subclass of &lt;code&gt;arg2&lt;/code&gt;.</source>
          <target state="translated">输入类别。如果 &lt;code&gt;arg1&lt;/code&gt; 是 &lt;code&gt;arg2&lt;/code&gt; 的子类，则返回True。</target>
        </trans-unit>
        <trans-unit id="56f0cc662add4c7f0901841588673883d4d29d17" translate="yes" xml:space="preserve">
          <source>Input comparison array.</source>
          <target state="translated">输入比较数组。</target>
        </trans-unit>
        <trans-unit id="64be30841013bc47e9c3850c4b6a7fded4a86ac4" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to a masked array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists, ndarrays and masked arrays.</source>
          <target state="translated">输入数据,以任何形式可以转换为掩码数组。这包括列表、元组列表、元组、元组的元组、列表的元组、ndarrays和掩码数组。</target>
        </trans-unit>
        <trans-unit id="81eacae9b22a55fbd594cc3dd8bc53a24b4e16f7" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array.</source>
          <target state="translated">输入数据,任何形式的数据都可以转换为一个数组。</target>
        </trans-unit>
        <trans-unit id="2ed4e1316aa603c005ccf7b9b354de1cad7aa423" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays.</source>
          <target state="translated">输入数据,以任何可以转换为数组的形式。这包括列表、元组列表、元组、元组的元组、列表的元组和ndarrays。</target>
        </trans-unit>
        <trans-unit id="c935f3a4d2949a1b2d5a11eb7de8a0fed4bd8dc0" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays. Success requires no NaNs or Infs.</source>
          <target state="translated">输入数据,以任何可以转换为数组的形式。这包括列表、元组列表、元组、元组的元组、列表的元组和ndarrays。成功要求不需要NaNs或Infs。</target>
        </trans-unit>
        <trans-unit id="ebe3314c250fe9acc710492a54a53defc42ce5bf" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes scalars, lists, lists of tuples, tuples, tuples of tuples, tuples of lists, and ndarrays.</source>
          <target state="translated">输入数据,以任何可以转换为数组的形式。这包括标量、列表、元组列表、元组、元组的元组、列表的元组和ndarrays。</target>
        </trans-unit>
        <trans-unit id="d430a3ba769bee8e9797da35defb2f32aa2749a3" translate="yes" xml:space="preserve">
          <source>Input data, which is flattened and set as the &lt;code&gt;k&lt;/code&gt;-th diagonal of the output.</source>
          <target state="translated">输入数据被展平并设置为输出的第 &lt;code&gt;k&lt;/code&gt; 个对角线。</target>
        </trans-unit>
        <trans-unit id="260753716624ad2077f13f38ada17a33c0f48cba" translate="yes" xml:space="preserve">
          <source>Input data.</source>
          <target state="translated">输入数据:</target>
        </trans-unit>
        <trans-unit id="110e3a721161e503e06852d0b67d62808bcf14b0" translate="yes" xml:space="preserve">
          <source>Input data. If a string, variables in the current scope may be referenced by name.</source>
          <target state="translated">输入数据。如果是字符串,当前作用域中的变量可以通过名称引用。</target>
        </trans-unit>
        <trans-unit id="50ef3fe01b042bdbfb18f290684475887aff6e69" translate="yes" xml:space="preserve">
          <source>Input data. The histogram is computed over the flattened array.</source>
          <target state="translated">输入数据。直方图是在扁平化的数组上计算出来的。</target>
        </trans-unit>
        <trans-unit id="479157011c9bc4b0c174d6c627dd634e47f423a6" translate="yes" xml:space="preserve">
          <source>Input datatype</source>
          <target state="translated">输入数据类型</target>
        </trans-unit>
        <trans-unit id="c3661c49bb4714e36d1ea68c6778013ac4b2c966" translate="yes" xml:space="preserve">
          <source>Input masks.</source>
          <target state="translated">输入掩码。</target>
        </trans-unit>
        <trans-unit id="49c6112477838697a8b42892713d1ff818dab05e" translate="yes" xml:space="preserve">
          <source>Input must be an ndarray (or have similar attributes) for it to be considered a valid mask.</source>
          <target state="translated">输入必须是一个ndarray(或具有类似的属性),才能被认为是一个有效的掩码。</target>
        </trans-unit>
        <trans-unit id="cdda590be17222720d3dca31ac32ec20a4bd2027" translate="yes" xml:space="preserve">
          <source>Input object or name to get information about. If &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; is a numpy object, its docstring is given. If it is a string, available modules are searched for matching objects. If None, information about &lt;a href=&quot;#numpy.info&quot;&gt;&lt;code&gt;info&lt;/code&gt;&lt;/a&gt; itself is returned.</source>
          <target state="translated">输入对象或名称以获取有关的信息。如果&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt;是一个numpy对象，则给出其文档字符串。如果是字符串，则在可用模块中搜索匹配的对象。如果为None，则返回有关&lt;a href=&quot;#numpy.info&quot;&gt; &lt;code&gt;info&lt;/code&gt; &lt;/a&gt;本身的信息。</target>
        </trans-unit>
        <trans-unit id="1412dec2d6e9b98e67083c400ddbdc1693058e9a" translate="yes" xml:space="preserve">
          <source>Input object. See Notes for details on how various input types are treated.</source>
          <target state="translated">输入对象。关于如何处理各种输入类型,请参见 &quot;注意事项&quot;。</target>
        </trans-unit>
        <trans-unit id="884c8a0c5d0944c72ee0463c3eae0abb376b5e70" translate="yes" xml:space="preserve">
          <source>Input object. This can be any object (function, class, module, &amp;hellip;).</source>
          <target state="translated">输入对象。这可以是任何对象（函数，类，模块等）。</target>
        </trans-unit>
        <trans-unit id="5bf2f1c9ba1965ca26f274218714e854f9f8439e" translate="yes" xml:space="preserve">
          <source>Input parameters.</source>
          <target state="translated">输入参数:</target>
        </trans-unit>
        <trans-unit id="f281e3f644ef1c6e22e0e862f4156eee5c382d75" translate="yes" xml:space="preserve">
          <source>Input polynomials.</source>
          <target state="translated">输入多项式。</target>
        </trans-unit>
        <trans-unit id="d68cab221829e2198b605b4996fba557e5ff14b8" translate="yes" xml:space="preserve">
          <source>Input sequences.</source>
          <target state="translated">输入序列:</target>
        </trans-unit>
        <trans-unit id="103b73f8b8612de7f92ed544d130aab2ccb3dead" translate="yes" xml:space="preserve">
          <source>Input value.</source>
          <target state="translated">输入值:</target>
        </trans-unit>
        <trans-unit id="cf14e71217c8a7f10324a53bd5825d3d1b8701ee" translate="yes" xml:space="preserve">
          <source>Input values</source>
          <target state="translated">输入值</target>
        </trans-unit>
        <trans-unit id="4191049318f63b6c3a85211b91a5c1cecb649bdb" translate="yes" xml:space="preserve">
          <source>Input values.</source>
          <target state="translated">输入值:</target>
        </trans-unit>
        <trans-unit id="07feb5a3916677b58c8f1860e3f940ccc64ab2f3" translate="yes" xml:space="preserve">
          <source>Input values. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">输入值。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="75826edc2e28e338fe2b7ee2851bc98b65454f08" translate="yes" xml:space="preserve">
          <source>Input vector or stack of matrices.</source>
          <target state="translated">输入矢量或矩阵堆栈。</target>
        </trans-unit>
        <trans-unit id="31df6d6470f1b56cda7e136be4be3e1c6dd63188" translate="yes" xml:space="preserve">
          <source>Input-only, in-place, argout, argoutview, and memory managed argoutview behavior.</source>
          <target state="translated">只输入、就地、argout、argoutview和内存管理的argoutview行为。</target>
        </trans-unit>
        <trans-unit id="f0c077a272f1db74eb4547826e2fa78b80131915" translate="yes" xml:space="preserve">
          <source>Inputs array.</source>
          <target state="translated">输入阵列。</target>
        </trans-unit>
        <trans-unit id="35b236db313f77f4ec031a91db5c8c986efb6cc5" translate="yes" xml:space="preserve">
          <source>Inputs arrays.</source>
          <target state="translated">输入数组。</target>
        </trans-unit>
        <trans-unit id="b698f1874b3f648c9ca7483478e5a5187dbc4214" translate="yes" xml:space="preserve">
          <source>Insert a new axis that will appear at the &lt;code&gt;axis&lt;/code&gt; position in the expanded array shape.</source>
          <target state="translated">插入一个新轴，该 &lt;code&gt;axis&lt;/code&gt; 将出现在扩展数组形状的轴位置上。</target>
        </trans-unit>
        <trans-unit id="af781fb10a00be46a34d9311756bc61e0afddfa8" translate="yes" xml:space="preserve">
          <source>Insert elements into an array.</source>
          <target state="translated">在一个数组中插入元素。</target>
        </trans-unit>
        <trans-unit id="62cc157d912a7ebc384c4d505230255340ab3ae0" translate="yes" xml:space="preserve">
          <source>Insert scalar into an array (scalar is cast to array&amp;rsquo;s dtype, if possible)</source>
          <target state="translated">将标量插入数组（如果可能，将标量强制转换为数组的dtype）</target>
        </trans-unit>
        <trans-unit id="6f263a0b1fde8fabbe156179a3331b4bc254ecbf" translate="yes" xml:space="preserve">
          <source>Insert values along the given axis before the given indices.</source>
          <target state="translated">沿着给定的轴在给定的指数前插入数值。</target>
        </trans-unit>
        <trans-unit id="6c05692f04b1e8c9bcb190b107c8a7b51796744b" translate="yes" xml:space="preserve">
          <source>Insert, remove, and combine dimensions, and resize existing ones</source>
          <target state="translated">插入、移除、合并尺寸,以及调整现有尺寸的大小。</target>
        </trans-unit>
        <trans-unit id="5ca6174fce3b04b3d69345d6264017af5ed2d820" translate="yes" xml:space="preserve">
          <source>Inserted between elements.</source>
          <target state="translated">插入元素之间。</target>
        </trans-unit>
        <trans-unit id="e6afa88e6a63d5a7ba7fb743473b463e1d9a17d0" translate="yes" xml:space="preserve">
          <source>Inserting data into arrays</source>
          <target state="translated">在数组中插入数据</target>
        </trans-unit>
        <trans-unit id="0f2b8c85b4203c61d3146e95e582c267d771f003" translate="yes" xml:space="preserve">
          <source>Inserting directives in Fortran source</source>
          <target state="translated">在Fortran源代码中插入指令</target>
        </trans-unit>
        <trans-unit id="d078b8bceaffb54addedcd30ef388e1bc3bf477b" translate="yes" xml:space="preserve">
          <source>Inserts newlines if text is longer than &lt;code&gt;max_line_width&lt;/code&gt;. Defaults to &lt;code&gt;numpy.get_printoptions()['linewidth']&lt;/code&gt;.</source>
          <target state="translated">如果文本长于 &lt;code&gt;max_line_width&lt;/code&gt; ,则插入换行符。默认为 &lt;code&gt;numpy.get_printoptions()['linewidth']&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="512c14336bae01c78c358939c0fa3a2e95db7538" translate="yes" xml:space="preserve">
          <source>Inside the block to be repeated, the variables that should be expanded are specified as &lt;code&gt;@name@&lt;/code&gt;.</source>
          <target state="translated">在要重复的块内，应扩展的变量指定为 &lt;code&gt;@name@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e503f860ac4f65121fead950747f4fcea390ed6" translate="yes" xml:space="preserve">
          <source>Inspecting the array</source>
          <target state="translated">检查阵列</target>
        </trans-unit>
        <trans-unit id="60da80156a5d0a6bae59ac9116ec4cab69c6184c" translate="yes" xml:space="preserve">
          <source>Install git</source>
          <target state="translated">安装git</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="b8e853cc56e81f34b9860e59d86983f00754c7d4" translate="yes" xml:space="preserve">
          <source>Installation of the new package is easy using:</source>
          <target state="translated">新包的安装很简单,使用。</target>
        </trans-unit>
        <trans-unit id="2b894e265fdd7f5a67dff5c1fc33dcfbd31481f9" translate="yes" xml:space="preserve">
          <source>Installing NumPy</source>
          <target state="translated">安装NumPy</target>
        </trans-unit>
        <trans-unit id="aee4fe0a13da73153ed829e66d85c46397091399" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; subclasses are passed through as-is:</source>
          <target state="translated">&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;子类的实例按原样传递：</target>
        </trans-unit>
        <trans-unit id="449be076c28f2ad0824dc5cabdcb20c6b823dcf2" translate="yes" xml:space="preserve">
          <source>Instances of classes that are part of the NumPy API (for example &lt;code&gt;np.r_&lt;/code&gt;&lt;code&gt;np,c_&lt;/code&gt;, &lt;code&gt;np.index_exp&lt;/code&gt;, etc.) may require some care. To give these instances a useful docstring, we do the following:</source>
          <target state="translated">属于NumPy API的类的实例（例如 &lt;code&gt;np.r_&lt;/code&gt; &lt;code&gt;np,c_&lt;/code&gt; ， &lt;code&gt;np.index_exp&lt;/code&gt; 等）可能需要格外小心。为了给这些实例一个有用的文档字符串，我们执行以下操作：</target>
        </trans-unit>
        <trans-unit id="e39a6352ce81aec018b2a3acbf6b2a0e689c1611" translate="yes" xml:space="preserve">
          <source>Instead of plain &lt;code&gt;gdb&lt;/code&gt; you can of course use your favourite alternative debugger; run it on the python binary with arguments &lt;code&gt;runtests.py -g --python mytest.py&lt;/code&gt;.</source>
          <target state="translated">当然，除了普通的 &lt;code&gt;gdb&lt;/code&gt; 之外,您还可以使用您喜欢的替代调试器。使用参数 &lt;code&gt;runtests.py -g --python mytest.py&lt;/code&gt; 在python二进制文件上运行它。</target>
        </trans-unit>
        <trans-unit id="eb90e39d52c4ed3cde5408270177895a426f7a11" translate="yes" xml:space="preserve">
          <source>Instead of special method names which define behavior for Python classes, there are &amp;ldquo;function tables&amp;rdquo; which point to functions that implement the desired results. Since Python 2.2, the PyTypeObject itself has become dynamic which allows C types that can be &amp;ldquo;sub-typed &amp;ldquo;from other C-types in C, and sub-classed in Python. The children types inherit the attributes and methods from their parent(s).</source>
          <target state="translated">代替定义Python类行为的特殊方法名称，有&amp;ldquo;函数表&amp;rdquo;指向实现所需结果的函数。从Python 2.2开始，PyTypeObject本身就变得动态起来，它允许C类型可以从C中的其他C类型&amp;ldquo;子类型化&amp;rdquo;，并在Python中进行子分类。子类型从其父类继承属性和方法。</target>
        </trans-unit>
        <trans-unit id="1a76aa17748f84d4f0a3ce05629dc02de8fc5860" translate="yes" xml:space="preserve">
          <source>Instead of specifying the full covariance matrix, popular approximations include:</source>
          <target state="translated">常用的近似方法包括,不指定完整的协方差矩阵,而是:</target>
        </trans-unit>
        <trans-unit id="569af2f9677e0019350ea2c63399c035e782231b" translate="yes" xml:space="preserve">
          <source>Instead of the Python traditional &amp;lsquo;floor division&amp;rsquo;, this returns a true division. True division adjusts the output type to present the best answer, regardless of input types.</source>
          <target state="translated">而不是Python传统的&amp;ldquo;地板分割&amp;rdquo;，它返回一个真正的分割。真除法调整输出类型以提供最佳答案，而与输入类型无关。</target>
        </trans-unit>
        <trans-unit id="2a07db57033cceb88c4be20433a8c922b8ebe578" translate="yes" xml:space="preserve">
          <source>Instead of the above, you can also do:</source>
          <target state="translated">与其说是上述,还不如说是。</target>
        </trans-unit>
        <trans-unit id="50b73dbdc0cbb3f8f1706a51e59d5b72389beaee" translate="yes" xml:space="preserve">
          <source>Instead of this function &lt;code&gt;PyObject_Call(ufunc, args, kwds)&lt;/code&gt; should be used. The above function differs from this because it ignores support for non-array, or array subclasses as inputs. To ensure identical behaviour, it may be necessary to convert all inputs using &lt;code&gt;PyArray_FromAny(obj, NULL, 0, 0, NPY_ARRAY_ENSUREARRAY, NULL)&lt;/code&gt;.</source>
          <target state="translated">不应使用此函数 &lt;code&gt;PyObject_Call(ufunc, args, kwds)&lt;/code&gt; 。上面的函数与此不同，因为它忽略了对非数组或数组子类作为输入的支持。为了确保行为相同，可能有必要使用 &lt;code&gt;PyArray_FromAny(obj, NULL, 0, 0, NPY_ARRAY_ENSUREARRAY, NULL)&lt;/code&gt; 转换所有输入。</target>
        </trans-unit>
        <trans-unit id="93d352d3764b7602f9edf496f491993157b0351d" translate="yes" xml:space="preserve">
          <source>Institutional Neutrality</source>
          <target state="translated">机构中立性</target>
        </trans-unit>
        <trans-unit id="6e8f68e1ce3b53a860ea6246ace5d16aba4fb2d5" translate="yes" xml:space="preserve">
          <source>Institutional Partner benefits are:</source>
          <target state="translated">机构伙伴的好处是:</target>
        </trans-unit>
        <trans-unit id="36318fd5786e4e1f35ed034e1d3f5b6a4d87922c" translate="yes" xml:space="preserve">
          <source>Institutional Partners</source>
          <target state="translated">机构合作伙伴</target>
        </trans-unit>
        <trans-unit id="228367a5efa47fc0ca88237f73f231005624c438" translate="yes" xml:space="preserve">
          <source>Institutional Partners and Funding</source>
          <target state="translated">机构伙伴和资金</target>
        </trans-unit>
        <trans-unit id="415e24116e418ab9260b5d4870a4577bbf2a9dc5" translate="yes" xml:space="preserve">
          <source>Institutions become eligible to become an Institutional Partner by employing individuals who actively contribute to The Project as part of their official duties. To state this another way, the only way for a Partner to influence the project is by actively contributing to the open development of the project, in equal terms to any other member of the community of Contributors and Council Members. Merely using Project Software in institutional context does not allow an entity to become an Institutional Partner. Financial gifts do not enable an entity to become an Institutional Partner. Once an institution becomes eligible for Institutional Partnership, the Steering Council must nominate and approve the Partnership.</source>
          <target state="translated">机构通过雇用积极为本项目做贡献的个人作为其公务的一部分,就有资格成为机构合作伙伴。换句话说,合作伙伴影响项目的唯一方式是积极地对项目的开放开发做出贡献,与其他贡献者和理事会成员平等。仅仅在机构范围内使用项目软件并不能使一个实体成为机构合作伙伴。财政赠与也不能使一个实体成为机构合作伙伴。一旦一个机构有资格成为机构合作伙伴,指导委员会必须提名并批准该合作伙伴。</target>
        </trans-unit>
        <trans-unit id="ed58f29743f8e14b9c8e13d41e070a1cc1d1c9f5" translate="yes" xml:space="preserve">
          <source>Instructions</source>
          <target state="translated">Instructions</target>
        </trans-unit>
        <trans-unit id="987d64b35cc2b94395724f62d16f3a187b63fb14" translate="yes" xml:space="preserve">
          <source>Insufficient bit width parameter to &lt;code&gt;binary_repr&lt;/code&gt;</source>
          <target state="translated">位宽参数不足， &lt;code&gt;binary_repr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="5796f99d3f819f045b29a1c73196d8c40b12d9d3" translate="yes" xml:space="preserve">
          <source>Integer (-2147483648 to 2147483647)</source>
          <target state="translated">整数(-2147483648至2147483647)</target>
        </trans-unit>
        <trans-unit id="4710e6c81ea3d854c2dc7806935816c50a107107" translate="yes" xml:space="preserve">
          <source>Integer (-32768 to 32767)</source>
          <target state="translated">整数(-32768至32767)</target>
        </trans-unit>
        <trans-unit id="d944b6a3d689ab2dee3e16b0c8d8d941fd887e9b" translate="yes" xml:space="preserve">
          <source>Integer (-9223372036854775808 to 9223372036854775807)</source>
          <target state="translated">整数(-9223372036854775808至9223372036854775807)</target>
        </trans-unit>
        <trans-unit id="e8fe5938766ae937144b5f55575793bff2ec8f88" translate="yes" xml:space="preserve">
          <source>Integer and Void scalars are now unaffected by &lt;code&gt;np.set_string_function&lt;/code&gt;</source>
          <target state="translated">整数和虚空标量现在不受 &lt;code&gt;np.set_string_function&lt;/code&gt; 的影响</target>
        </trans-unit>
        <trans-unit id="a61c09200238e7c60e4949f4f742cd3529f52bfd" translate="yes" xml:space="preserve">
          <source>Integer array indexing</source>
          <target state="translated">整数数组索引</target>
        </trans-unit>
        <trans-unit id="a764d9440def338d1a721af2c9bc3cf9203fd57a" translate="yes" xml:space="preserve">
          <source>Integer array indexing allows selection of arbitrary items in the array based on their &lt;em&gt;N&lt;/em&gt;-dimensional index. Each integer array represents a number of indexes into that dimension.</source>
          <target state="translated">整数数组索引允许基于数组的&lt;em&gt;N&lt;/em&gt;维索引选择数组中的任意项。每个整数数组代表该维度的多个索引。</target>
        </trans-unit>
        <trans-unit id="a46c6037b6ed3e2034603c23c6f4211c22a945c1" translate="yes" xml:space="preserve">
          <source>Integer exponents of 2. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">2的整数指数。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="a3173b86433d0db1fb5b647328822672be728221" translate="yes" xml:space="preserve">
          <source>Integer indicating how this dtype relates to the built-in dtypes.</source>
          <target state="translated">表示该dtype与内置dtype关系的整数。</target>
        </trans-unit>
        <trans-unit id="201042a920a1327277fe1dda0e55cd37046acf9f" translate="yes" xml:space="preserve">
          <source>Integer large enough to hold a pointer</source>
          <target state="translated">大到足以容纳一个指针的整数。</target>
        </trans-unit>
        <trans-unit id="c0ad68cb65f108515f3a5b364ab814f280978530" translate="yes" xml:space="preserve">
          <source>Integer performance has a similar ordering.</source>
          <target state="translated">整数性能有类似的排序。</target>
        </trans-unit>
        <trans-unit id="006c632da5c7b1582b36540c57330b631facab3d" translate="yes" xml:space="preserve">
          <source>Integer that can hold a pointer</source>
          <target state="translated">可容纳指针的整数</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">整数类型</target>
        </trans-unit>
        <trans-unit id="b13be07f7abad8e811e3c73cea1a525a627e0bc2" translate="yes" xml:space="preserve">
          <source>Integer ufuncs vectorized with AVX2</source>
          <target state="translated">用AVX2矢量化的整数ufuncs。</target>
        </trans-unit>
        <trans-unit id="a334f0e07c1be58e6996ea133d59f4da9faac7a9" translate="yes" xml:space="preserve">
          <source>Integer used for indexing, typically the same as &lt;code&gt;ssize_t&lt;/code&gt;</source>
          <target state="translated">用于索引的整数，通常与 &lt;code&gt;ssize_t&lt;/code&gt; 相同</target>
        </trans-unit>
        <trans-unit id="654f37af768fdf3bb70ca69e758a2fe80f1abf09" translate="yes" xml:space="preserve">
          <source>Integers:</source>
          <target state="translated">Integers:</target>
        </trans-unit>
        <trans-unit id="84cede945b07b48bcb97421b3eb8bd4f5bd269e0" translate="yes" xml:space="preserve">
          <source>Integral part of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的整数部分。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="1ea3c0d26d1c5d1b53eb099b2c1cf7972b99ebe8" translate="yes" xml:space="preserve">
          <source>Integrate &lt;code&gt;y&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) along given axis.</source>
          <target state="translated">沿给定轴积分 &lt;code&gt;y&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cc54f713576053888447a5aa6f2b6660db759e79" translate="yes" xml:space="preserve">
          <source>Integrate a Chebyshev series.</source>
          <target state="translated">整合一个切比雪夫系列。</target>
        </trans-unit>
        <trans-unit id="f7e0820ca3cf5b80cf75499d63a15279548b4395" translate="yes" xml:space="preserve">
          <source>Integrate a Hermite series.</source>
          <target state="translated">整合一个赫米特系列。</target>
        </trans-unit>
        <trans-unit id="09cdc33ab9232f32b3ffa23eec0555fd0aad884d" translate="yes" xml:space="preserve">
          <source>Integrate a Hermite_e series.</source>
          <target state="translated">整合一个Hermite_e系列。</target>
        </trans-unit>
        <trans-unit id="28e01e90e39bcd5c5a200d36b330a9fb8a0cc2c8" translate="yes" xml:space="preserve">
          <source>Integrate a Laguerre series.</source>
          <target state="translated">并入拉盖尔系列。</target>
        </trans-unit>
        <trans-unit id="e45d1046a79d8f27551599eaeb79cbfa5c322286" translate="yes" xml:space="preserve">
          <source>Integrate a Legendre series.</source>
          <target state="translated">集成到传奇系列。</target>
        </trans-unit>
        <trans-unit id="51617b9fadb594aa47fc197fa4afb1a0d12a97e3" translate="yes" xml:space="preserve">
          <source>Integrate a polynomial.</source>
          <target state="translated">对一个多项式进行积分。</target>
        </trans-unit>
        <trans-unit id="1b28e42d25bb1781655bdbd732badc274759c37c" translate="yes" xml:space="preserve">
          <source>Integrate along the given axis using the composite trapezoidal rule.</source>
          <target state="translated">利用复合梯形法则沿给定轴线进行积分。</target>
        </trans-unit>
        <trans-unit id="f6bc7be2c5b5072601573fb92ccbc047dff88160" translate="yes" xml:space="preserve">
          <source>Integrate.</source>
          <target state="translated">Integrate.</target>
        </trans-unit>
        <trans-unit id="a77970f26b3a19856dc6d676e2149a78243716b5" translate="yes" xml:space="preserve">
          <source>Integrated squared error (ISE) estimator added to &lt;code&gt;histogram&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;histogram&lt;/code&gt; 增加了积分平方误差（ISE）估计器</target>
        </trans-unit>
        <trans-unit id="24640b86177ce52879242a4e3855fb7330a6f367" translate="yes" xml:space="preserve">
          <source>Integration constant(s). The value of the first integral at &lt;code&gt;lbnd&lt;/code&gt; is the first value in the list, the value of the second integral at &lt;code&gt;lbnd&lt;/code&gt; is the second value, etc. If &lt;code&gt;k == []&lt;/code&gt; (the default), all constants are set to zero. If &lt;code&gt;m == 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">积分常数。 &lt;code&gt;lbnd&lt;/code&gt; 处的第一个整数的值是列表中的第一个值， &lt;code&gt;lbnd&lt;/code&gt; 处的第二个整数的值是第二个值，依此类推。如果 &lt;code&gt;k == []&lt;/code&gt; （默认值），则所有常数都设置为零。如果 &lt;code&gt;m == 1&lt;/code&gt; ，则可以给出单个标量而不是列表。</target>
        </trans-unit>
        <trans-unit id="faa7aa2d13f47c8dc8e8d870349e9f9bbf12fee6" translate="yes" xml:space="preserve">
          <source>Integration constant(s). The value of the first integral at zero is the first value in the list, the value of the second integral at zero is the second value, etc. If &lt;code&gt;k == []&lt;/code&gt; (the default), all constants are set to zero. If &lt;code&gt;m == 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">积分常数。第一个整数为零的值是列表中的第一个值，第二个整数为零的值是第二个值， &lt;code&gt;k == []&lt;/code&gt; 。如果k == []（默认值），则所有常数都设置为零。如果 &lt;code&gt;m == 1&lt;/code&gt; ，则可以给出单个标量而不是列表。</target>
        </trans-unit>
        <trans-unit id="79199da79d91b1fb5aeec3ae95134c32578dd203" translate="yes" xml:space="preserve">
          <source>Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to &lt;code&gt;m&lt;/code&gt; in length and any missing values are set to zero.</source>
          <target state="translated">积分常数。第一个常量应用于第一个积分，第二个常量应用于第二个，依此类推。值列表的长度必须小于或等于 &lt;code&gt;m&lt;/code&gt; ，并且所有缺少的值都将设置为零。</target>
        </trans-unit>
        <trans-unit id="99a973b23f26b788591e237471230a61bc42bfca" translate="yes" xml:space="preserve">
          <source>Integration constants. They are given in the order of integration: those corresponding to highest-order terms come first.</source>
          <target state="translated">整合常数。它们按积分顺序给出:与最高阶项相对应的常数在前。</target>
        </trans-unit>
        <trans-unit id="f1b63b1b837d115daafc12c34b184fde445bf116" translate="yes" xml:space="preserve">
          <source>Integration of array values using the composite trapezoidal rule.</source>
          <target state="translated">利用复合梯形规则对数组值进行积分。</target>
        </trans-unit>
        <trans-unit id="272bd8e11d9a2557b005814cbc8295b6bce05913" translate="yes" xml:space="preserve">
          <source>Interaction with &lt;code&gt;scipy.sparse&lt;/code&gt; is a bit cleaner.</source>
          <target state="translated">与 &lt;code&gt;scipy.sparse&lt;/code&gt; 的交互更加干净。</target>
        </trans-unit>
        <trans-unit id="cf5308846512dd05b3fe349862b884d3dad34184" translate="yes" xml:space="preserve">
          <source>Interchange two axes of an array.</source>
          <target state="translated">互换一个数组的两个轴。</target>
        </trans-unit>
        <trans-unit id="487fafdb343a2fa07aa1e904de9985413e377451" translate="yes" xml:space="preserve">
          <source>Interest paid against the loan changes during the life or the loan. The &lt;code&gt;per&lt;/code&gt; is the payment period to calculate the interest amount.</source>
          <target state="translated">借贷所支付的利息在存续期间或贷款中发生变化。在 &lt;code&gt;per&lt;/code&gt; 是支付周期来计算的利息金额。</target>
        </trans-unit>
        <trans-unit id="94a1603aa26be2dbffaf8cf5c3954f0266df1988" translate="yes" xml:space="preserve">
          <source>Interest portion of payment. If all input is scalar, returns a scalar float. If any input is array_like, returns interest payment for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="translated">支付的利息部分。如果所有输入都是标量,返回一个标量浮点数。如果任何输入是array_like,返回每个输入元素的利息支付。如果多个输入是array_like,它们必须具有相同的形状。</target>
        </trans-unit>
        <trans-unit id="fae2c1a639317094eef5fc0747acae252e47559d" translate="yes" xml:space="preserve">
          <source>Interest rate paid on the cash flows</source>
          <target state="translated">现金流支付的利率</target>
        </trans-unit>
        <trans-unit id="bac9f8f12cdd23938b9506adf721b640d1387b0f" translate="yes" xml:space="preserve">
          <source>Interest rate received on the cash flows upon reinvestment</source>
          <target state="translated">再投资时收到的现金流量利息率</target>
        </trans-unit>
        <trans-unit id="acbc7801b292b22fd84bb969c2c0f9ee879becf9" translate="yes" xml:space="preserve">
          <source>Interfacing to C</source>
          <target state="translated">与C的接口</target>
        </trans-unit>
        <trans-unit id="5669f1ef998cb57e98a6c7c64ced935f3a20e1ba" translate="yes" xml:space="preserve">
          <source>Interfacing to C++:</source>
          <target state="translated">与C++的接口。</target>
        </trans-unit>
        <trans-unit id="0ef0659c2c669af8efd19f667b98f55614307e8e" translate="yes" xml:space="preserve">
          <source>Interfacing to Fortran:</source>
          <target state="translated">与Fortran的接口。</target>
        </trans-unit>
        <trans-unit id="5a1eb29a8757da9ba26cf2dfef44ad676331c673" translate="yes" xml:space="preserve">
          <source>Internal Flexibility</source>
          <target state="translated">内部灵活性</target>
        </trans-unit>
        <trans-unit id="ac2251ff80e959c9a76b1d8e25426050ad978681" translate="yes" xml:space="preserve">
          <source>Internal Rate of Return for periodic input values.</source>
          <target state="translated">定期输入值的内部收益率。</target>
        </trans-unit>
        <trans-unit id="70e52d12f616579455cc3db6303a1fc61cf8ea38" translate="yes" xml:space="preserve">
          <source>Internal changes</source>
          <target state="translated">内部变化</target>
        </trans-unit>
        <trans-unit id="811920182b71e4d6c39f62829f0533afa24b5bfb" translate="yes" xml:space="preserve">
          <source>Internal functions</source>
          <target state="translated">内部职能</target>
        </trans-unit>
        <trans-unit id="ecdbace78f65adf7ab79aea820093f0235b38c83" translate="yes" xml:space="preserve">
          <source>Internal memory layout of an ndarray</source>
          <target state="translated">ndarray的内部内存布局</target>
        </trans-unit>
        <trans-unit id="4c771d77fd8a74b74dbd14733dbe89a221191139" translate="yes" xml:space="preserve">
          <source>Internal organization of numpy arrays</source>
          <target state="translated">numpy数组的内部组织</target>
        </trans-unit>
        <trans-unit id="8693ac81d62075b90be2f5012ceac7d5e0960c71" translate="yes" xml:space="preserve">
          <source>Internally used structures</source>
          <target state="translated">内部使用的结构</target>
        </trans-unit>
        <trans-unit id="353f9272117a257bd48156e257afe86724ce335c" translate="yes" xml:space="preserve">
          <source>Internally, buffers are used for misaligned data, swapped data, and data that has to be converted from one data type to another. The size of internal buffers is settable on a per-thread basis. There can be up to</source>
          <target state="translated">在内部,缓冲区用于错位数据、交换数据和必须从一种数据类型转换到另一种数据类型的数据。内部缓冲区的大小是可以按线程设置的。内部缓冲区的大小可以按线程设置,最多可以有</target>
        </trans-unit>
        <trans-unit id="0b9562a5febab6388bcaad8af8913734a30e5c69" translate="yes" xml:space="preserve">
          <source>Internally, the code uses some additional Python objects primarily for memory management. These types are not accessible directly from Python, and are not exposed to the C-API. They are included here only for completeness and assistance in understanding the code.</source>
          <target state="translated">在内部,代码使用了一些额外的 Python 对象,主要用于内存管理。这些类型不能直接从Python中访问,也没有暴露在C-API中。这里包含它们只是为了完整和帮助理解代码。</target>
        </trans-unit>
        <trans-unit id="88c585f236f03e4d85467407665675347bdfa2c1" translate="yes" xml:space="preserve">
          <source>Internally, these #defines work as follows:</source>
          <target state="translated">在内部,这些#定义的工作原理如下。</target>
        </trans-unit>
        <trans-unit id="2e02d69fdcfa7dd47d4e20a9c3718e372f145dcc" translate="yes" xml:space="preserve">
          <source>Interoperability-Related Options</source>
          <target state="translated">与互操作性相关的选项</target>
        </trans-unit>
        <trans-unit id="b400cd2b32800b89445114d966c1ee1e1e2f5b22" translate="yes" xml:space="preserve">
          <source>Interpolate a function at the Chebyshev points of the first kind.</source>
          <target state="translated">在第一种切比雪夫点上插值一个函数。</target>
        </trans-unit>
        <trans-unit id="b0124a6fa4961521e8ff39aa6c372018194a4ebf" translate="yes" xml:space="preserve">
          <source>Interpolating Chebyshev instance.</source>
          <target state="translated">穿插切比雪夫实例。</target>
        </trans-unit>
        <trans-unit id="1427e61ed742cbf9aa91a5c0cf7909917aab75eb" translate="yes" xml:space="preserve">
          <source>Interpolation with periodic x-coordinates:</source>
          <target state="translated">用周期性X坐标进行插值。</target>
        </trans-unit>
        <trans-unit id="437831e765e33b0f2fa769dfde52d2c581b5cfbf" translate="yes" xml:space="preserve">
          <source>Interpret a buffer as a 1-dimensional array.</source>
          <target state="translated">将缓冲区解释为一维数组。</target>
        </trans-unit>
        <trans-unit id="9feed02e3d661ed814b67ed529ab9195e31b0cb4" translate="yes" xml:space="preserve">
          <source>Interpret the input as a matrix.</source>
          <target state="translated">将输入的内容解释为矩阵。</target>
        </trans-unit>
        <trans-unit id="a0422cc647bba954b177a29fbf1305b2895860e3" translate="yes" xml:space="preserve">
          <source>Interrupt Handling</source>
          <target state="translated">中断处理</target>
        </trans-unit>
        <trans-unit id="e5f5d0f73f8dc2d6363a75fe32ba76d7d8dff9cc" translate="yes" xml:space="preserve">
          <source>Intrinsic NumPy Array Creation</source>
          <target state="translated">内在的NumPy阵列创建</target>
        </trans-unit>
        <trans-unit id="7e2ea7ccd882296e2e16cdecb01f04008d30cfc7" translate="yes" xml:space="preserve">
          <source>Intrinsic numpy array creation objects (e.g., arange, ones, zeros, etc.)</source>
          <target state="translated">固有的numpy数组创建对象(如arrange、一、零等)</target>
        </trans-unit>
        <trans-unit id="dcd3fd94e72c882e4eaa006cb5da780542c07011" translate="yes" xml:space="preserve">
          <source>Introduce yourself to Git:</source>
          <target state="translated">介绍一下自己的Git。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="b6ab6d57043280ab296716031275867d148d3ca7" translate="yes" xml:space="preserve">
          <source>Introduction to byte ordering and ndarrays</source>
          <target state="translated">字节排序和ndarrays介绍</target>
        </trans-unit>
        <trans-unit id="24583ffa86b443c7a55325e4b25e34083f63ac92" translate="yes" xml:space="preserve">
          <source>Invalid arguments for array ordering</source>
          <target state="translated">数组排序的无效参数</target>
        </trans-unit>
        <trans-unit id="8a8e0797ccef44760e0a1c564f5097faaf0a6cb9" translate="yes" xml:space="preserve">
          <source>Invalid data means values of &lt;a href=&quot;../constants#numpy.nan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../constants#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt;, etc.</source>
          <target state="translated">无效的数据表示&lt;a href=&quot;../constants#numpy.nan&quot;&gt; &lt;code&gt;nan&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../constants#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; &lt;/a&gt;等的值。</target>
        </trans-unit>
        <trans-unit id="46dbc8721ef190eab06879ef282ac69a2d11056b" translate="yes" xml:space="preserve">
          <source>Invalid data means values of &lt;code&gt;nan&lt;/code&gt;, &lt;code&gt;inf&lt;/code&gt;, etc.</source>
          <target state="translated">无效数据表示 &lt;code&gt;nan&lt;/code&gt; ， &lt;code&gt;inf&lt;/code&gt; 等值。</target>
        </trans-unit>
        <trans-unit id="b66a9668314f5851a31b3926b89142340d67c1e0" translate="yes" xml:space="preserve">
          <source>Invalid fill value exceptions</source>
          <target state="translated">无效填充值异常</target>
        </trans-unit>
        <trans-unit id="6dd811ad3cf2203333b0468d5361ce3f92b716aa" translate="yes" xml:space="preserve">
          <source>Invalid operation: result is not an expressible number, typically indicates that a NaN was produced.</source>
          <target state="translated">无效操作:结果不是一个可表示的数字,通常表示产生了一个NaN。</target>
        </trans-unit>
        <trans-unit id="dfed6b5bd73798f6efbc4f77cde7ac568bd5cdfb" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine, element-wise.</source>
          <target state="translated">逆双曲余弦,元素方面。</target>
        </trans-unit>
        <trans-unit id="21de990f2f734fbb43aa31870f6cebb10139a34e" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine element-wise.</source>
          <target state="translated">逆双曲正弦元的方式。</target>
        </trans-unit>
        <trans-unit id="ae6bb16d1805cc3ebef5cfaf633f1f868061a8dc" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent element-wise.</source>
          <target state="translated">逆双曲正切元素方面。</target>
        </trans-unit>
        <trans-unit id="2c6d3ed37e9c36a516eafee4d6cf6bce8fa583e5" translate="yes" xml:space="preserve">
          <source>Inverse sine, element-wise.</source>
          <target state="translated">反正弦,元素方面。</target>
        </trans-unit>
        <trans-unit id="9b049bc33b3f3b47e868bbdc217dc4db5fb5be2d" translate="yes" xml:space="preserve">
          <source>Inverses of several matrices can be computed at once:</source>
          <target state="translated">可以同时计算多个矩阵的反值。</target>
        </trans-unit>
        <trans-unit id="bafff722f42fe9db3b595ab6ea0bb84953a6e8ad" translate="yes" xml:space="preserve">
          <source>Investigate. Change directory to your new repo: &lt;code&gt;cd numpy&lt;/code&gt;. Then &lt;code&gt;git branch -a&lt;/code&gt; to show you all branches. You&amp;rsquo;ll get something like:</source>
          <target state="translated">调查。将目录更改为新的仓库： &lt;code&gt;cd numpy&lt;/code&gt; 。然后 &lt;code&gt;git branch -a&lt;/code&gt; 向您显示所有分支。您会得到类似以下内容的信息：</target>
        </trans-unit>
        <trans-unit id="525b73c1bc26402f8fe2106a7fc0623195c4b729" translate="yes" xml:space="preserve">
          <source>Is equivalent to &lt;code&gt;np.delete(arr, [0,2,4], axis=0)&lt;/code&gt;, but allows further use of &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;np.delete(arr, [0,2,4], axis=0)&lt;/code&gt; ，但允许进一步使用 &lt;code&gt;mask&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24c5caf7c1723177101292b0ec91f3f69f7573df" translate="yes" xml:space="preserve">
          <source>Is straightforward to reverse engineer. Datasets often live longer than the programs that created them. A competent developer should be able to create a solution in their preferred programming language to read most &lt;code&gt;.npy&lt;/code&gt; files that he has been given without much documentation.</source>
          <target state="translated">对逆向工程师很简单。数据集的寿命通常比创建它们的程序更长。一个有能力的开发人员应该能够使用他们喜欢的编程语言创建一个解决方案，以读取他在没有太多文档的情况下获得的大多数 &lt;code&gt;.npy&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="4ba294d10b61eb96747cb70e6af5cde8e38ba66a" translate="yes" xml:space="preserve">
          <source>Is straightforward to reverse engineer. Datasets often live longer than the programs that created them. A competent developer should be able to create a solution in their preferred programming language to read most &lt;code&gt;.npy&lt;/code&gt; files that they have been given without much documentation.</source>
          <target state="translated">对逆向工程师很简单。数据集的寿命通常比创建它们的程序更长。一个称职的开发人员应该能够使用他们喜欢的编程语言创建一个解决方案，以读取大多数 &lt;code&gt;.npy&lt;/code&gt; 文件，而这些文件在没有太多文档的情况下就已经给出了。</target>
        </trans-unit>
        <trans-unit id="1a81d4101d801108adb8aad8206475022e2e35b0" translate="yes" xml:space="preserve">
          <source>Is the given function something that we know how to overload?</source>
          <target state="translated">给定的函数是我们知道如何重载的吗?</target>
        </trans-unit>
        <trans-unit id="90d345365af762034873b91bc86108d3934ff16a" translate="yes" xml:space="preserve">
          <source>Is the intended behavior clear under all conditions? Some things to watch:</source>
          <target state="translated">在所有条件下,预期行为是否明确?一些需要注意的事情。</target>
        </trans-unit>
        <trans-unit id="cc7ae1466afcaa0ca1796c357dfcb90adbea07a4" translate="yes" xml:space="preserve">
          <source>Is this page an example of a how-to?</source>
          <target state="translated">这个页面是否是一个怎样的例子?</target>
        </trans-unit>
        <trans-unit id="b10180fbee8cac98fb1ea7940ed518f48a70dee3" translate="yes" xml:space="preserve">
          <source>Issued by &lt;a href=&quot;generated/numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; when the Vandermonde matrix is rank deficient.</source>
          <target state="translated">当Vandermonde矩阵秩不足时，由&lt;a href=&quot;generated/numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt;发出。</target>
        </trans-unit>
        <trans-unit id="2c7da8ef717a7e944f5132cdc9e7ea084630c1b8" translate="yes" xml:space="preserve">
          <source>Issued by &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; when the Vandermonde matrix is rank deficient.</source>
          <target state="translated">当Vandermonde矩阵秩不足时，由&lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt;发出。</target>
        </trans-unit>
        <trans-unit id="62ecce1ee2f04057e107579d5bef99ec7e6758b0" translate="yes" xml:space="preserve">
          <source>Issued by chebfit when the design matrix is rank deficient.</source>
          <target state="translated">当设计矩阵存在等级缺失时,由chebfit发出。</target>
        </trans-unit>
        <trans-unit id="ed3a53b09f923a24c6dd04195732883fc05144f5" translate="yes" xml:space="preserve">
          <source>Issued by the generic Poly class when two domains don&amp;rsquo;t match.</source>
          <target state="translated">当两个域不匹配时，由通用Poly类发出。</target>
        </trans-unit>
        <trans-unit id="f00ecef77fb41ae5e26098e89f064e811f1d6ae9" translate="yes" xml:space="preserve">
          <source>Issues Fixed</source>
          <target state="translated">修正的问题</target>
        </trans-unit>
        <trans-unit id="b19e94cfda274542200371fca470c64546558300" translate="yes" xml:space="preserve">
          <source>Issues a DeprecationWarning, adds warning to &lt;code&gt;old_name&lt;/code&gt;&amp;rsquo;s docstring, rebinds &lt;code&gt;old_name.__name__&lt;/code&gt; and returns the new function object.</source>
          <target state="translated">发出DeprecationWarning，向 &lt;code&gt;old_name&lt;/code&gt; 的文档字符串添加警告，重新绑定 &lt;code&gt;old_name.__name__&lt;/code&gt; 并返回新的函数对象。</target>
        </trans-unit>
        <trans-unit id="9ddf288870dda342df98b4b9313d3dcfea4defcb" translate="yes" xml:space="preserve">
          <source>Issues fixed</source>
          <target state="translated">修正的问题</target>
        </trans-unit>
        <trans-unit id="671076d691ff47550497ef45340afd4f09d3d6a6" translate="yes" xml:space="preserve">
          <source>It also contains extra C definitions that are used for defining NumPy&amp;rsquo;s Python-level module attributes &lt;code&gt;__cpu_baseline__&lt;/code&gt; and &lt;code&gt;__cpu_dispaٍtch__&lt;/code&gt;.</source>
          <target state="translated">它还包含用于定义NumPy的Python级模块属性 &lt;code&gt;__cpu_baseline__&lt;/code&gt; 和 &lt;code&gt;__cpu_dispaٍtch__&lt;/code&gt; C定义。</target>
        </trans-unit>
        <trans-unit id="dee1de34f5e6dfdd4c0e68ce69b1f31528f724f6" translate="yes" xml:space="preserve">
          <source>It can also be used in places of &lt;a href=&quot;numpy.atleast_1d#numpy.atleast_1d&quot;&gt;&lt;code&gt;atleast_1d&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.atleast_2d#numpy.atleast_2d&quot;&gt;&lt;code&gt;atleast_2d&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">也可以在&lt;a href=&quot;numpy.atleast_1d#numpy.atleast_1d&quot;&gt; &lt;code&gt;atleast_1d&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.atleast_2d#numpy.atleast_2d&quot;&gt; &lt;code&gt;atleast_2d&lt;/code&gt; 的&lt;/a&gt;地方使用</target>
        </trans-unit>
        <trans-unit id="378d5136b02c66ae2366b0871c9dc87a59e458eb" translate="yes" xml:space="preserve">
          <source>It can be considered as a generalization of EPS: &lt;code&gt;spacing(np.float64(1)) == np.finfo(np.float64).eps&lt;/code&gt;, and there should not be any representable number between &lt;code&gt;x + spacing(x)&lt;/code&gt; and x for any finite x.</source>
          <target state="translated">可以将其视为EPS的一般化： &lt;code&gt;spacing(np.float64(1)) == np.finfo(np.float64).eps&lt;/code&gt; ，并且 &lt;code&gt;x + spacing(x)&lt;/code&gt; interval （x）和x 之间不应有任何可表示的数字任何有限的x。</target>
        </trans-unit>
        <trans-unit id="1ef0650f598bd8c46d6488dc9e1ecf7f36a57c12" translate="yes" xml:space="preserve">
          <source>It can be shown that a convolution</source>
          <target state="translated">可以证明,卷积</target>
        </trans-unit>
        <trans-unit id="3a39f7205319edd1c303f4671f99c8c35d8b49e6" translate="yes" xml:space="preserve">
          <source>It can be shown that if</source>
          <target state="translated">可以看出,如果</target>
        </trans-unit>
        <trans-unit id="c085102ad00314d621def87ff2d6f64f13992fcf" translate="yes" xml:space="preserve">
          <source>It can be used at most once; &lt;code&gt;a[...,0,...]&lt;/code&gt; raises an &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#IndexError&quot;&gt;&lt;code&gt;IndexError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">最多只能使用一次； &lt;code&gt;a[...,0,...]&lt;/code&gt; 引发&lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#IndexError&quot;&gt; &lt;code&gt;IndexError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6680413ecf8178af7a6bc1c7bc275bc8809885e1" translate="yes" xml:space="preserve">
          <source>It differs from the forward transform by the sign of the exponential argument and the default normalization by</source>
          <target state="translated">它与正向变换的不同之处在于指数参数的符号和默认的归一化。</target>
        </trans-unit>
        <trans-unit id="d2a43fea3528f404f8930330d870fe7079aa62c4" translate="yes" xml:space="preserve">
          <source>It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true.</source>
          <target state="translated">它并&lt;em&gt;没有&lt;/em&gt;普遍认为， &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; 为C语言风格的连续阵列或 &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; Fortran的风格的连续阵列是真实的。</target>
        </trans-unit>
        <trans-unit id="47be37fff5f8f22af765f82be2c6bfbaf9c3032a" translate="yes" xml:space="preserve">
          <source>It has the following structure:</source>
          <target state="translated">它的结构如下:</target>
        </trans-unit>
        <trans-unit id="9d66b7021aa904bae4cfae41aeb4ea6450db47e9" translate="yes" xml:space="preserve">
          <source>It has the probability density function</source>
          <target state="translated">它的概率密度函数为</target>
        </trans-unit>
        <trans-unit id="8df067c80d1dbac7caebbaa192d51d71072198f4" translate="yes" xml:space="preserve">
          <source>It helps to understand a bit about how numpy arrays are handled under the covers to help understand numpy better. This section will not go into great detail. Those wishing to understand the full details are referred to Travis Oliphant&amp;rsquo;s book &amp;ldquo;Guide to NumPy&amp;rdquo;.</source>
          <target state="translated">它有助于您了解一些有关如何处理numpy数组的知识，以帮助您更好地理解numpy。本节将不会详细介绍。那些希望了解所有详细信息的人，请参考Travis Oliphant的书&amp;ldquo; NumPy指南&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2fbb89405ce29cc8160fa307e221950fa152cd3e" translate="yes" xml:space="preserve">
          <source>It is also possible to select more than one item at a time, using &lt;em&gt;slicing&lt;/em&gt;:</source>
          <target state="translated">也可以使用&lt;em&gt;切片&lt;/em&gt;一次选择一个以上的项目：</target>
        </trans-unit>
        <trans-unit id="c6785902c796379d2b6f1ca680d1350c037d297a" translate="yes" xml:space="preserve">
          <source>It is an error to have index values out of bounds:</source>
          <target state="translated">指数值出界是一个错误。</target>
        </trans-unit>
        <trans-unit id="9bd3e350ace36c053f4770c254bc8bbc0ed59492" translate="yes" xml:space="preserve">
          <source>It is assumed that all indices of &lt;code&gt;x&lt;/code&gt; are summed over in the product, together with the rightmost indices of &lt;code&gt;a&lt;/code&gt;, as is done in, for example, &lt;code&gt;tensordot(a, x, axes=b.ndim)&lt;/code&gt;.</source>
          <target state="translated">假定所有索引 &lt;code&gt;x&lt;/code&gt; 被求和在产物中，用的最右索引一起 &lt;code&gt;a&lt;/code&gt; ，如在完成，例如， &lt;code&gt;tensordot(a, x, axes=b.ndim)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58008c74c97fe4d3ae3f9ae78ab47043dddec099" translate="yes" xml:space="preserve">
          <source>It is available from:</source>
          <target state="translated">它可以从:</target>
        </trans-unit>
        <trans-unit id="ca7dcbab26b74b24d5b23e3d1dfbaa7bb550a61f" translate="yes" xml:space="preserve">
          <source>It is convenient to use &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; objects for dealing with polynomials:</source>
          <target state="translated">使用&lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt;对象处理多项式很方便：</target>
        </trans-unit>
        <trans-unit id="ee3d89b7c311757a10611a623afead7359a99d73" translate="yes" xml:space="preserve">
          <source>It is convenient to use &lt;code&gt;poly1d&lt;/code&gt; objects for dealing with polynomials:</source>
          <target state="translated">使用 &lt;code&gt;poly1d&lt;/code&gt; 对象处理多项式很方便：</target>
        </trans-unit>
        <trans-unit id="f0b5d505c1b6aa0449adcda591bae28c54d28b79" translate="yes" xml:space="preserve">
          <source>It is difficult to distribute an extension module made using ctypes because of a lack of support for building shared libraries in distutils (but I suspect this will change in time).</source>
          <target state="translated">由于缺乏对在distutils中构建共享库的支持,所以很难发布使用ctypes制作的扩展模块(但我怀疑这一点会随着时间的推移而改变)。</target>
        </trans-unit>
        <trans-unit id="f6233db9ea353c629e411da73701b45f43b34d4b" translate="yes" xml:space="preserve">
          <source>It is easy to lose a clean separation between Python and C which makes re-using your C-code for other non-Python-related projects more difficult.</source>
          <target state="translated">在Python和C语言之间很容易失去一个清晰的分离,这使得你的C代码在其他非Python相关的项目中重用变得更加困难。</target>
        </trans-unit>
        <trans-unit id="09772c45572066c0ab1839c5da61b341c459c08d" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;reshape(-1, order=order)&lt;/code&gt;.</source>
          <target state="translated">它等效于 &lt;code&gt;reshape(-1, order=order)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8649182deb90f9e5b82c97ccd124c9f5e91bbefa" translate="yes" xml:space="preserve">
          <source>It is expected that function &lt;code&gt;func&lt;/code&gt; has been defined externally. In order to use a Python function as &lt;code&gt;func&lt;/code&gt;, it must have an attribute &lt;code&gt;intent(callback)&lt;/code&gt; (it must be specified before the &lt;code&gt;external&lt;/code&gt; statement).</source>
          <target state="translated">预期函数 &lt;code&gt;func&lt;/code&gt; 已在外部定义。为了将Python函数用作 &lt;code&gt;func&lt;/code&gt; ，它必须具有 &lt;code&gt;intent(callback)&lt;/code&gt; 属性（必须在 &lt;code&gt;external&lt;/code&gt; 语句之前指定）。</target>
        </trans-unit>
        <trans-unit id="41074d06eaa1aca6cfcc81add0a6d4a0de1496e0" translate="yes" xml:space="preserve">
          <source>It is expected that the Council Members will be employed at a wide range of companies, universities and non-profit organizations. Because of this, it is possible that Members will have conflict of interests. Such conflict of interests include, but are not limited to:</source>
          <target state="translated">预计理事会成员将受雇于不同的公司、大学和非营利组织。正因如此,成员可能会有利益冲突。这些利益冲突包括但不限于:</target>
        </trans-unit>
        <trans-unit id="e897ba8d8d1e35fdbcdafccfd6dd8ffccaf71314" translate="yes" xml:space="preserve">
          <source>It is good practice to tell &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; who you are, for labeling any changes you make to the code. The simplest way to do this is from the command line:</source>
          <target state="translated">最好告诉&lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;您是谁，以标记您对代码所做的任何更改。最简单的方法是从命令行：</target>
        </trans-unit>
        <trans-unit id="9c72b281ec77874c2a8219572de87ebec10916f2" translate="yes" xml:space="preserve">
          <source>It is important to keep in mind that you get a &lt;em&gt;borrowed&lt;/em&gt; reference to the object when using the &amp;ldquo;O&amp;rdquo; format string. However, the converter functions usually require some form of memory handling. In this example, if the conversion is successful, &lt;em&gt;dtype&lt;/em&gt; will hold a new reference to a &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; object, while &lt;em&gt;input&lt;/em&gt; will hold a borrowed reference. Therefore, if this conversion were mixed with another conversion (say to an integer) and the data-type conversion was successful but the integer conversion failed, then you would need to release the reference count to the data-type object before returning. A typical way to do this is to set &lt;em&gt;dtype&lt;/em&gt; to &lt;code&gt;NULL&lt;/code&gt; before calling &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; and then use &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_XDECREF&quot;&gt;&lt;code&gt;Py_XDECREF&lt;/code&gt;&lt;/a&gt; on &lt;em&gt;dtype&lt;/em&gt; before returning.</source>
          <target state="translated">重要的是要记住，在使用&amp;ldquo; O&amp;rdquo;格式字符串时，您会获得一个对该对象的&lt;em&gt;借用&lt;/em&gt;引用。但是，转换器功能通常需要某种形式的内存处理。在此示例中，如果转换成功，则&lt;em&gt;dtype&lt;/em&gt;将保存对&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr *&lt;/code&gt; &lt;/a&gt;对象的新引用，而&lt;em&gt;input&lt;/em&gt;将保存借用的引用。因此，如果此转换与另一个转换（例如，转换为整数）混合在一起，并且数据类型转换成功，但是整数转换失败，那么您需要在返回之前将引用计数释放到数据类型对象。一种典型的方法是在调用之前将&lt;em&gt;dtype&lt;/em&gt;设置为 &lt;code&gt;NULL&lt;/code&gt; 。&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt;然后用&lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_XDECREF&quot;&gt; &lt;code&gt;Py_XDECREF&lt;/code&gt; &lt;/a&gt;对&lt;em&gt;D类&lt;/em&gt;返回之前。</target>
        </trans-unit>
        <trans-unit id="68e5e295697e350544ce52515eda2757f41a1612" translate="yes" xml:space="preserve">
          <source>It is important to keep the flags updated (using &lt;a href=&quot;#c.PyArray_UpdateFlags&quot;&gt;&lt;code&gt;PyArray_UpdateFlags&lt;/code&gt;&lt;/a&gt; can help) whenever a manipulation with an array is performed that might cause them to change. Later calculations in NumPy that rely on the state of these flags do not repeat the calculation to update them.</source>
          <target state="translated">每当对数组执行可能会导致其更改的标志时，保持标志更新（使用&lt;a href=&quot;#c.PyArray_UpdateFlags&quot;&gt; &lt;code&gt;PyArray_UpdateFlags&lt;/code&gt; &lt;/a&gt;会有所帮助）很重要。以后依赖于这些标志状态的NumPy中的计算不会重复计算以更新它们。</target>
        </trans-unit>
        <trans-unit id="6dd28e38486b7b23cc628bcffec168f7a3e2908d" translate="yes" xml:space="preserve">
          <source>It is important to note that once the iterator is exited, dangling references (like &lt;code&gt;x&lt;/code&gt; in the example) may or may not share data with the original data &lt;code&gt;a&lt;/code&gt;. If writeback semantics were active, i.e. if &lt;code&gt;x.base.flags.writebackifcopy&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then exiting the iterator will sever the connection between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, writing to &lt;code&gt;x&lt;/code&gt; will no longer write to &lt;code&gt;a&lt;/code&gt;. If writeback semantics are not active, then &lt;code&gt;x.data&lt;/code&gt; will still point at some part of &lt;code&gt;a.data&lt;/code&gt;, and writing to one will affect the other.</source>
          <target state="translated">重要的是要注意，一旦退出迭代器，悬空引用（例如示例中的 &lt;code&gt;x&lt;/code&gt; ）可能会或可能不会与原始数据 &lt;code&gt;a&lt;/code&gt; 共享数据。如果写回语义处于活动状态，即 &lt;code&gt;x.base.flags.writebackifcopy&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则退出迭代器将切断 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;a&lt;/code&gt; 之间的连接，写给 &lt;code&gt;x&lt;/code&gt; 将不再写给 &lt;code&gt;a&lt;/code&gt; 。如果写回语义不处于活动状态，则 &lt;code&gt;x.data&lt;/code&gt; 仍将指向 &lt;code&gt;a.data&lt;/code&gt; 的某些部分，而写一个将影响另一个。</target>
        </trans-unit>
        <trans-unit id="63bda28ddda57fde741844f509673a49e4004752" translate="yes" xml:space="preserve">
          <source>It is important to retain an archive of all activities of this committee to ensure consistency in behavior and provide institutional memory for the project. To assist in this, the default channel of discussion for this committee will be a private mailing list accessible to current and future members of the committee as well as members of the Steering Council upon justified request. If the Committee finds the need to use off-list communications (e.g. phone calls for early/rapid response), it should in all cases summarize these back to the list so there&amp;rsquo;s a good record of the process.</source>
          <target state="translated">重要的是要保留该委员会所有活动的档案，以确保行为的一致性并为项目提供机构记忆。为了帮助实现这一目标，该委员会的默认讨论渠道将是私人邮件列表，供委员会的现任和未来成员以及根据合理要求的指导委员会成员访问。如果委员会发现需要使用列表外通信（例如，电话进行早期/快速响应），则在所有情况下都应将这些信息汇总到列表中，以便对该过程进行良好记录。</target>
        </trans-unit>
        <trans-unit id="a263f6ef91dbde8a42fa624ef445c812e662a622" translate="yes" xml:space="preserve">
          <source>It is intended that all polynomial instances are immutable, therefore augmented operations (&lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, etc.) and any other functionality that would violate the immutablity of a polynomial instance are intentionally unimplemented.</source>
          <target state="translated">意图是所有多项式实例都是不可变的，因此有意地未实现增强操作（ &lt;code&gt;+=&lt;/code&gt; ， &lt;code&gt;-=&lt;/code&gt; 等）以及任何违反多项式实例的不变性的功能。</target>
        </trans-unit>
        <trans-unit id="8b8f2e17893170efcb86b57f32479a3f40a7b944" translate="yes" xml:space="preserve">
          <source>It is named for the American linguist George Kingsley Zipf, who noted that the frequency of any word in a sample of a language is inversely proportional to its rank in the frequency table.</source>
          <target state="translated">它是以美国语言学家乔治-金斯利-齐普夫的名字命名的,他指出,在一种语言的样本中,任何一个词的频率与它在频率表中的等级成反比。</target>
        </trans-unit>
        <trans-unit id="21e4b23be2d40c69036b3d2e468ea13e53868304" translate="yes" xml:space="preserve">
          <source>It is no longer recommended to use this class, even for linear</source>
          <target state="translated">我们不再推荐使用这个类,即使是线性的。</target>
        </trans-unit>
        <trans-unit id="c8350ce47be17c20baa97fc4d0754bec81b2f208" translate="yes" xml:space="preserve">
          <source>It is no longer recommended to use this class, even for linear algebra. Instead use regular arrays. The class may be removed in the future.</source>
          <target state="translated">即使是线性代数,也不建议再使用这个类。取而代之的是使用常规数组。该类将来可能会被删除。</target>
        </trans-unit>
        <trans-unit id="8c5239a5bff654c37cc55078706d5d6b20118c0c" translate="yes" xml:space="preserve">
          <source>It is not always possible to change the shape of an array without copying the data. If you want an error to be raised when the data is copied, you should assign the new shape to the shape attribute of the array:</source>
          <target state="translated">并非总是可以在不复制数据的情况下改变数组的形状。如果你希望在复制数据时出现错误,你应该将新的形状分配给数组的形状属性。</target>
        </trans-unit>
        <trans-unit id="656bf2f4ae8187e5defb4f5552faf2fbd1f5fad1" translate="yes" xml:space="preserve">
          <source>It is not difficult to create your own ufunc. All that is required is a 1-d loop for each data-type you want to support. Each 1-d loop must have a specific signature, and only ufuncs for fixed-size data-types can be used. The function call used to create a new ufunc to work on built-in data-types is given below. A different mechanism is used to register ufuncs for user-defined data-types.</source>
          <target state="translated">要创建自己的ufunc并不难。所有需要做的就是为每一个你想支持的数据类型建立一个1-d循环,每个1-d循环必须有特定的签名,并且只能使用固定大小的数据类型的ufuncs。每个1-d循环都必须有一个特定的签名,并且只能使用固定大小的数据类型的ufunc。下面给出了用于创建一个新的ufunc来工作于内置数据类型的函数调用。另一种机制用于为用户定义的数据类型注册ufuncs。</target>
        </trans-unit>
        <trans-unit id="d8b548648b06bad09d9ab843a8e5797d1798c5b5" translate="yes" xml:space="preserve">
          <source>It is not necessary to use the doctest markup &lt;code&gt;&amp;lt;BLANKLINE&amp;gt;&lt;/code&gt; to indicate empty lines in the output. Note that the option to run the examples through &lt;code&gt;numpy.test&lt;/code&gt; is provided for checking if the examples work, not for making the examples part of the testing framework.</source>
          <target state="translated">不必使用doctest标记 &lt;code&gt;&amp;lt;BLANKLINE&amp;gt;&lt;/code&gt; 来指示输出中的空行。请注意，提供了通过 &lt;code&gt;numpy.test&lt;/code&gt; 运行示例的选项，用于检查示例是否正常运行，而不是使示例成为测试框架的一部分。</target>
        </trans-unit>
        <trans-unit id="b37f77a2246e7fcb1e0b4774efe6b903d4205875" translate="yes" xml:space="preserve">
          <source>It is often seen in Bayesian inference and order statistics.</source>
          <target state="translated">它经常出现在贝叶斯推理和顺序统计中。</target>
        </trans-unit>
        <trans-unit id="7bef780e922069dd57c2e5a08856175d82409e4f" translate="yes" xml:space="preserve">
          <source>It is one of a class of extreme value distributions, the Generalized Extreme Value (GEV) distributions, which also includes the Weibull and Frechet.</source>
          <target state="translated">它是一类极值分布,即广义极值(GEV)分布中的一种,它还包括Weibull和Frechet。</target>
        </trans-unit>
        <trans-unit id="5071b59a11ab8c54d2368dbe31b14e825424a9ec" translate="yes" xml:space="preserve">
          <source>It is possible to index arrays with other arrays for the purposes of selecting lists of values out of arrays into new arrays. There are two different ways of accomplishing this. One uses one or more arrays of index values. The other involves giving a boolean array of the proper shape to indicate the values to be selected. Index arrays are a very powerful tool that allow one to avoid looping over individual elements in arrays and thus greatly improve performance.</source>
          <target state="translated">可以将数组与其他数组进行索引,以达到将数组中的值列表选入新数组的目的。有两种不同的方法来实现这个目的。一种是使用一个或多个索引值的数组。另一种是给出一个适当形状的布尔数组来表示要选择的值。索引数组是一个非常强大的工具,它允许人们避免在数组中的单个元素上进行循环,从而大大提高了性能。</target>
        </trans-unit>
        <trans-unit id="36000cdc40cdbba3e0e5f28ba7dcb30e267b4506" translate="yes" xml:space="preserve">
          <source>It is possible to load a library using &amp;gt;&amp;gt;&amp;gt; lib = ctypes.cdll[&amp;lt;full_path_name&amp;gt;] # doctest: +SKIP</source>
          <target state="translated">可以使用&amp;gt;&amp;gt;&amp;gt; lib = ctypes.cdll [&amp;lt;full_path_name&amp;gt;]＃doctest：+ SKIP加载库</target>
        </trans-unit>
        <trans-unit id="38fbbd2c67dc08fbfcb5c5de50ecf788043a91ae" translate="yes" xml:space="preserve">
          <source>It is possible to slice and stride arrays to extract arrays of the same number of dimensions, but of different sizes than the original. The slicing and striding works exactly the same way it does for lists and tuples except that they can be applied to multiple dimensions as well. A few examples illustrates best:</source>
          <target state="translated">可以对数组进行分片和跨步,以提取具有相同维数,但与原始维数不同大小的数组。分片和跨步的工作方式与列表和tuple的工作方式完全相同,只是它们也可以应用于多个维度。几个例子最能说明问题。</target>
        </trans-unit>
        <trans-unit id="0a211923eef6c9018ec875b45f1ee8aa7feb24f0" translate="yes" xml:space="preserve">
          <source>It is possible to specify config_fc options in setup.py scripts. For example, using</source>
          <target state="translated">可以在setup.py脚本中指定config_fc选项。例如,使用</target>
        </trans-unit>
        <trans-unit id="3af7692eade07c544a49c1e0a3fa2b4f67d86e02" translate="yes" xml:space="preserve">
          <source>It is possible to specify how boundaries are treated using &lt;code&gt;edge_order&lt;/code&gt;</source>
          <target state="translated">可以指定使用 &lt;code&gt;edge_order&lt;/code&gt; 处理边界的方式</target>
        </trans-unit>
        <trans-unit id="425695dd90c5cd68dc182714b9d0871e6107582e" translate="yes" xml:space="preserve">
          <source>It is possible to use methods from linear algebra to approximate an existing set of data. Here, we will use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Singular_value_decomposition&quot;&gt;SVD (Singular Value Decomposition)&lt;/a&gt; to try to rebuild an image that uses less singular value information than the original one, while still retaining some of its features.</source>
          <target state="translated">可以使用线性代数中的方法来近似现有数据集。在这里，我们将使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Singular_value_decomposition&quot;&gt;SVD（奇异值分解）&lt;/a&gt;来尝试重建使用比原始图像少的奇异值信息的图像，同时仍保留其某些功能。</target>
        </trans-unit>
        <trans-unit id="9279d7909405dcb9e4e547b0701fbd4a212eac71" translate="yes" xml:space="preserve">
          <source>It is possible to use special features to effectively increase the number of dimensions in an array through indexing so the resulting array acquires the shape needed for use in an expression or with a specific function.</source>
          <target state="translated">可以使用特殊功能,通过索引有效地增加数组的维数,使生成的数组获得表达式或特定函数所需的形状。</target>
        </trans-unit>
        <trans-unit id="006848dc30e65d20b3919e74b2fa41c8170663f6" translate="yes" xml:space="preserve">
          <source>It is recommended to use one of &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt;&lt;code&gt;assert_allclose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.testing.assert_array_almost_equal_nulp#numpy.testing.assert_array_almost_equal_nulp&quot;&gt;&lt;code&gt;assert_array_almost_equal_nulp&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.testing.assert_array_max_ulp#numpy.testing.assert_array_max_ulp&quot;&gt;&lt;code&gt;assert_array_max_ulp&lt;/code&gt;&lt;/a&gt; instead of this function for more consistent floating point comparisons.</source>
          <target state="translated">为了更一致的浮点比较，建议使用&lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt; &lt;code&gt;assert_allclose&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.testing.assert_array_almost_equal_nulp#numpy.testing.assert_array_almost_equal_nulp&quot;&gt; &lt;code&gt;assert_array_almost_equal_nulp&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;numpy.testing.assert_array_max_ulp#numpy.testing.assert_array_max_ulp&quot;&gt; &lt;code&gt;assert_array_max_ulp&lt;/code&gt; 之一&lt;/a&gt;代替此函数。</target>
        </trans-unit>
        <trans-unit id="e411ddee11ac634d5c4281835040dc7466b061ac" translate="yes" xml:space="preserve">
          <source>It is strongly advised &lt;em&gt;not&lt;/em&gt; to use the matrix subclass. As described below, it makes writing functions that deal consistently with matrices and regular arrays very difficult. Currently, they are mainly used for interacting with &lt;code&gt;scipy.sparse&lt;/code&gt;. We hope to provide an alternative for this use, however, and eventually remove the &lt;code&gt;matrix&lt;/code&gt; subclass.</source>
          <target state="translated">强烈建议&lt;em&gt;不要&lt;/em&gt;使用矩阵子类。如下所述，这使得编写处理矩阵和规则数组的函数非常困难。当前，它们主要用于与 &lt;code&gt;scipy.sparse&lt;/code&gt; 进行交互。但是，我们希望为此提供一种替代方法，并最终删除 &lt;code&gt;matrix&lt;/code&gt; 子类。</target>
        </trans-unit>
        <trans-unit id="7669de0e65d605729606ade6c00d09dc551353c4" translate="yes" xml:space="preserve">
          <source>It is used, for example, in modeling the over-reporting of insurance claims.</source>
          <target state="translated">例如,它被用于模拟保险索赔的过度报告。</target>
        </trans-unit>
        <trans-unit id="ca0ecc89a435e5703a52f043959e28e66dbb2433" translate="yes" xml:space="preserve">
          <source>It is useful for writing classes that do not inherit from &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, but that should support arithmetic and numpy universal functions like arrays as described in &lt;a href=&quot;../../neps/nep-0013-ufunc-overrides&quot;&gt;A Mechanism for Overriding Ufuncs&lt;/a&gt;.</source>
          <target state="translated">对于编写不继承自&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; 的类&lt;/a&gt;，但应支持算术和numpy通用函数（如数组，如&lt;a href=&quot;../../neps/nep-0013-ufunc-overrides&quot;&gt;覆盖Ufuncs的机制中&lt;/a&gt;所述的数组），该类很有用。</target>
        </trans-unit>
        <trans-unit id="e32c0ef1527073446df56f2f6fdb74c9774fe25a" translate="yes" xml:space="preserve">
          <source>It is useful for writing classes that do not inherit from &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, but that should support arithmetic and numpy universal functions like arrays as described in &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/neps/nep-0013-ufunc-overrides.html&quot;&gt;A Mechanism for Overriding Ufuncs&lt;/a&gt;.</source>
          <target state="translated">这对于编写不继承自&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; 的&lt;/a&gt;类很有用，但该类应支持算术和numpy通用函数，例如数组，如&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/neps/nep-0013-ufunc-overrides.html&quot;&gt;覆盖Ufuncs的机制中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9bbe090da186f95bac0feca86884d8bee85c4509" translate="yes" xml:space="preserve">
          <source>It is useful for writing classes that do not inherit from &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, but that should support arithmetic and numpy universal functions like arrays as described in &lt;a href=&quot;https://numpy.org/neps/nep-0013-ufunc-overrides.html&quot;&gt;A Mechanism for Overriding Ufuncs&lt;/a&gt;.</source>
          <target state="translated">对于编写不继承自&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; 的类&lt;/a&gt;，但应支持算术和numpy通用函数（如数组，如&lt;a href=&quot;https://numpy.org/neps/nep-0013-ufunc-overrides.html&quot;&gt;覆盖Ufuncs的机制中&lt;/a&gt;所述的数组），该类很有用。</target>
        </trans-unit>
        <trans-unit id="d3b8ad76686cc18b830ba552fba24082c4f933e5" translate="yes" xml:space="preserve">
          <source>It is worth noting that if</source>
          <target state="translated">值得注意的是,如果</target>
        </trans-unit>
        <trans-unit id="29b82dd1d6f270f96b8bc45104bc41a8e589f966" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t always convenient to explicitly use Polynomial instances, so tuples, lists, arrays, and scalars are automatically cast in the arithmetic operations:</source>
          <target state="translated">显式使用多项式实例并不总是很方便，因此元组，列表，数组和标量会在算术运算中自动进行转换：</target>
        </trans-unit>
        <trans-unit id="cf495221779c2163a5e7a39d1bf1b540324c978b" translate="yes" xml:space="preserve">
          <source>It landed 4 times on 1, once on 2, etc.</source>
          <target state="translated">1上落地4次,2上落地1次等。</target>
        </trans-unit>
        <trans-unit id="d1653963d10a9096aa75746f96dbe0fd1387381e" translate="yes" xml:space="preserve">
          <source>It may also be convenient to define a custom decorators (&lt;code&gt;implements&lt;/code&gt; below) for registering &lt;code&gt;__array_function__&lt;/code&gt; implementations.</source>
          <target state="translated">定义用于注册 &lt;code&gt;__array_function__&lt;/code&gt; 实现的自定义装饰器（下面的 &lt;code&gt;implements&lt;/code&gt; ）也可能很方便。</target>
        </trans-unit>
        <trans-unit id="15b8b5878ae11de1a6686f5f6b72cb728b7b2d6b" translate="yes" xml:space="preserve">
          <source>It may be helpful to have a copy of the pull request code checked out on your own machine so that you can play with it locally. You can use the &lt;a href=&quot;https://docs.github.com/en/github/getting-started-with-github/github-cli&quot;&gt;GitHub CLI&lt;/a&gt; to do this by clicking the &lt;code&gt;Open with&lt;/code&gt; button in the upper right-hand corner of the PR page.</source>
          <target state="translated">在您自己的计算机上检出拉取请求代码的副本可能会有所帮助，以便您可以在本地使用它。您可以通过单击PR页面右上角的 &lt;code&gt;Open with&lt;/code&gt; 按钮来使用&lt;a href=&quot;https://docs.github.com/en/github/getting-started-with-github/github-cli&quot;&gt;GitHub CLI&lt;/a&gt;来执行此操作。</target>
        </trans-unit>
        <trans-unit id="3598c5e5543d6be85e81adfe21a8be7084de89d0" translate="yes" xml:space="preserve">
          <source>It may be preferable to split the projected cashflow into an initial investment and expected future cashflows. In this case, the value of the initial cashflow is zero and the initial investment is later added to the future cashflows net present value:</source>
          <target state="translated">将预计的现金流分成初始投资和预期的未来现金流可能比较好。在这种情况下,初始现金流的价值为零,初始投资随后加到未来现金流的净现值中。</target>
        </trans-unit>
        <trans-unit id="0c144448b26d1bb5e1e573955f886137b35b8bc6" translate="yes" xml:space="preserve">
          <source>It may be the case that while you were working on your edits, new commits have been added to &lt;code&gt;upstream&lt;/code&gt; that affect your work. In this case, follow the &lt;a href=&quot;#rebasing-on-master&quot;&gt;Rebasing on master&lt;/a&gt; section of this document to apply those changes to your branch.</source>
          <target state="translated">可能是在您进行编辑时，新的提交已添加到 &lt;code&gt;upstream&lt;/code&gt; ，从而影响了您的工作。在这种情况下，请按照本文档的&amp;ldquo;在&lt;a href=&quot;#rebasing-on-master&quot;&gt;基础上重新建立基础&amp;rdquo;&lt;/a&gt;部分的说明，将这些更改应用于您的分支机构。</target>
        </trans-unit>
        <trans-unit id="61a2cf7173d1c99310b82e23b09fc16ccfa711fb" translate="yes" xml:space="preserve">
          <source>It often happens that the memory that you want to view with an array is not of the same byte ordering as the computer on which you are running Python.</source>
          <target state="translated">经常会发生这样的情况:您要用数组查看的内存与您运行Python的计算机的字节顺序不一样。</target>
        </trans-unit>
        <trans-unit id="72a7758d8c4a1616265a421ff54b57ab65811e7b" translate="yes" xml:space="preserve">
          <source>It permits an elegant do-what-I-mean behavior where, for instance, adding a scalar to a vector adds the scalar value to every element.</source>
          <target state="translated">它允许一种优雅的我行我素行为,例如,向一个向量添加一个标量,将标量值添加到每个元素上。</target>
        </trans-unit>
        <trans-unit id="eaadd007be7687e8c25f3eb461c4399e71de7888" translate="yes" xml:space="preserve">
          <source>It should be clear that any structured type could be described using this interface.</source>
          <target state="translated">应该清楚的是,任何结构化类型都可以用这个接口来描述。</target>
        </trans-unit>
        <trans-unit id="40b700e9c3136bc2579dd22e6d2f087fce1952e9" translate="yes" xml:space="preserve">
          <source>It should be emphasized at this point that you may not need the array iterator if your array is already contiguous (using an array iterator will work but will be slower than the fastest code you could write). The major purpose of array iterators is to encapsulate iteration over N-dimensional arrays with arbitrary strides. They are used in many, many places in the NumPy source code itself. If you already know your array is contiguous (Fortran or C), then simply adding the element- size to a running pointer variable will step you through the array very efficiently. In other words, code like this will probably be faster for you in the contiguous case (assuming doubles).</source>
          <target state="translated">此时需要强调的是,如果你的数组已经是连续的,你可能不需要数组迭代器(使用数组迭代器也可以,但会比你能写的最快的代码慢)。数组迭代器的主要目的是封装在N维数组上进行任意步长的迭代。它们在NumPy源代码本身的很多很多地方都有使用。如果你已经知道你的数组是连续的(Fortran或C),那么只需将元素大小添加到运行指针变量中,就可以非常有效地对数组进行步长。换句话说,在连续的情况下,这样的代码对你来说可能会更快(假设是双数)。</target>
        </trans-unit>
        <trans-unit id="026d73ab6dffc63b48ab1902fa6d889c8def5bcb" translate="yes" xml:space="preserve">
          <source>It uses a &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; rather than the more modern &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">它使用&lt;a href=&quot;#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;而不是更现代的&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18504c66aebcc566a9cf5db146c843b0920c0fed" translate="yes" xml:space="preserve">
          <source>It uses global state, which means results will change as the code changes</source>
          <target state="translated">它使用全局状态,这意味着结果会随着代码的改变而改变。</target>
        </trans-unit>
        <trans-unit id="f377563feb8e5b75d15a1cc4f00304a3153cefc3" translate="yes" xml:space="preserve">
          <source>It works in 2-D as well:</source>
          <target state="translated">它在2-D中也可以使用。</target>
        </trans-unit>
        <trans-unit id="61cf279216973943c4725d4d79877589268acf41" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s clear that masked arrays are the right solution here. We cannot represent the missing data without mischaracterizing the evolution of the curve.</source>
          <target state="translated">显然，掩码数组是此处的正确解决方案。如果不对曲线的演变进行错误描述，我们就无法表示缺失的数据。</target>
        </trans-unit>
        <trans-unit id="e168152d8a6d565c340c6f98aabefe43987e5068" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to need to transpose your matrices. NumPy arrays have the property &lt;code&gt;T&lt;/code&gt; that allows you to transpose a matrix.</source>
          <target state="translated">通常需要转置矩阵。NumPy数组具有属性 &lt;code&gt;T&lt;/code&gt; ，该属性允许您转置矩阵。</target>
        </trans-unit>
        <trans-unit id="2a604443bcd6724527af1c5d434ed815a21fd057" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to save and load and array with &lt;code&gt;np.save()&lt;/code&gt;. Just make sure to specify the array you want to save and a file name. For example, if you create this array:</source>
          <target state="translated">使用 &lt;code&gt;np.save()&lt;/code&gt; 可以很容易地保存和加载数组。只需确保指定要保存的阵列和文件名即可。例如，如果创建此数组：</target>
        </trans-unit>
        <trans-unit id="bb5dacd50e546c91bb0023917cb217930a8f4581" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to assign to copy-on-write array, but values are only written into the memory copy of the array, and not written to disk:</source>
          <target state="translated">可以分配给写时复制数组，但是值仅写入数组的内存副本，而不写入磁盘：</target>
        </trans-unit>
        <trans-unit id="2a0ce98ff31bde352ed1c0c91f62805b6675f308" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to do a parallel build with &lt;code&gt;numpy.distutils&lt;/code&gt; with the &lt;code&gt;-j&lt;/code&gt; option; see &lt;a href=&quot;../user/building#parallel-builds&quot;&gt;Parallel builds&lt;/a&gt; for more details.</source>
          <target state="translated">可以使用带有 &lt;code&gt;-j&lt;/code&gt; 选项的 &lt;code&gt;numpy.distutils&lt;/code&gt; 进行并行构建。有关更多详细信息，请参见&lt;a href=&quot;../user/building#parallel-builds&quot;&gt;并行构建&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4121d3718e690b8fea8d720656c256ae8ee8cf80" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to do a parallel build with:</source>
          <target state="translated">可以使用以下方式进行并行构建：</target>
        </trans-unit>
        <trans-unit id="964de6d6253a84ec110383e1255be2951c5d85d8" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to mutate the dtype of an array at runtime. For example, the following code is valid:</source>
          <target state="translated">在运行时可以更改数组的dtype。例如，以下代码是有效的：</target>
        </trans-unit>
        <trans-unit id="2a92fc5de8c1d7511c762594edc421f16b236424" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s recommended to specify only those config_fc options in such a way that are compiler independent.</source>
          <target state="translated">建议仅以与编译器无关的方式指定那些config_fc选项。</target>
        </trans-unit>
        <trans-unit id="d6aa98a684b303867919f656c9319be29d7ca44f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s simple to read in a CSV that contains existing information. The best and easiest way to do this is to use &lt;a href=&quot;https://pandas.pydata.org&quot;&gt;Pandas&lt;/a&gt;.</source>
          <target state="translated">读取包含现有信息的CSV很简单。最好的和最简单的方法是使用&lt;a href=&quot;https://pandas.pydata.org&quot;&gt;Pandas&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0753c18f0b1243f25af624a4511a2035947276c3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s simple to read in a CSV that contains existing information. The best and easiest way to do this is to use &lt;a href=&quot;https://pandas.pydata.org/getpandas.html&quot;&gt;Pandas&lt;/a&gt;.</source>
          <target state="translated">读取包含现有信息的CSV很简单。最好的和最简单的方法是使用&lt;a href=&quot;https://pandas.pydata.org/getpandas.html&quot;&gt;Pandas&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14495a2289a19a1e28ed57bed5a4a3a49edf0b4e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s simple to use Pandas in order to export your array as well. If you are new to NumPy, you may want to create a Pandas dataframe from the values in your array and then write the data frame to a CSV file with Pandas.</source>
          <target state="translated">使用Pandas导出数组也很简单。如果您不熟悉NumPy，则可能要根据数组中的值创建Pandas数据框，然后使用Pandas将数据框写入CSV文件。</target>
        </trans-unit>
        <trans-unit id="060cec9479c0c03cb8146120d17fc1e1fd50e074" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s usually a good idea to use the &lt;code&gt;-n&lt;/code&gt; flag to &lt;code&gt;git push&lt;/code&gt; to check first that you&amp;rsquo;re about to push the changes you want to the place you want.</source>
          <target state="translated">通常，最好使用 &lt;code&gt;-n&lt;/code&gt; 标志进行 &lt;code&gt;git push&lt;/code&gt; 来首先检查您是否要将要进行的更改推送到所需的位置。</target>
        </trans-unit>
        <trans-unit id="85be1e8acbcf441a36b9c0c869cff5476c693c32" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s very common to want to aggregate along a row or column. By default, every NumPy aggregation function will return the aggregate of the entire array. To find the sum or the minimum of the elements in your array, run:</source>
          <target state="translated">要沿行或列进行聚合是很常见的。默认情况下，每个NumPy聚合函数都将返回整个数组的聚合。要查找数组中元素的总和或最小值，请运行：</target>
        </trans-unit>
        <trans-unit id="c3a9e71b0cabb8c3a03cd16e13045b08078788b6" translate="yes" xml:space="preserve">
          <source>Item selection and manipulation</source>
          <target state="translated">项目选择和操作</target>
        </trans-unit>
        <trans-unit id="867490709f6ff3383fa1fcfac4368fffd68d75ba" translate="yes" xml:space="preserve">
          <source>Items of an array of this data type are wrapped in an &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar&lt;/a&gt; type that also has two fields:</source>
          <target state="translated">此数据类型的数组的项目包装在也有两个字段的&lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;数组标量&lt;/a&gt;类型中：</target>
        </trans-unit>
        <trans-unit id="7b5cbf04c6d27c2ce2fa2026bd76b8e62a482e6d" translate="yes" xml:space="preserve">
          <source>Iterating Over Arrays</source>
          <target state="translated">在数组上迭代</target>
        </trans-unit>
        <trans-unit id="61c7e36ee871033d37342fea4c9a477a22a3ad15" translate="yes" xml:space="preserve">
          <source>Iterating as a Specific Data Type</source>
          <target state="translated">迭代作为一个特定的数据类型</target>
        </trans-unit>
        <trans-unit id="d0332abd31d07a7d02dd3e33350dc402dcd2926d" translate="yes" xml:space="preserve">
          <source>Iterating over all but one axis</source>
          <target state="translated">除一个轴外,在所有轴上迭代</target>
        </trans-unit>
        <trans-unit id="1844648c4af60a1a170cdaf38688443ce7ba666d" translate="yes" xml:space="preserve">
          <source>Iterating over arrays</source>
          <target state="translated">迭代数组</target>
        </trans-unit>
        <trans-unit id="b05284699d8fb62b19954c2a16145ceb83ef59a3" translate="yes" xml:space="preserve">
          <source>Iterating over elements in the array</source>
          <target state="translated">迭代数组中的元素</target>
        </trans-unit>
        <trans-unit id="ab8467929e39862040c3a1bba747525fbb89952c" translate="yes" xml:space="preserve">
          <source>Iterating over multiple arrays</source>
          <target state="translated">迭代多个数组</target>
        </trans-unit>
        <trans-unit id="3c8101d6360b4040707379e2577c7a16fa0bf84e" translate="yes" xml:space="preserve">
          <source>Iteration is done in row-major, C-style order (the last index varying the fastest). The iterator can also be indexed using basic slicing or advanced indexing.</source>
          <target state="translated">迭代是按照行主、C式的顺序进行的(最后一个索引变化最快)。迭代器也可以使用基本分片或高级索引进行索引。</target>
        </trans-unit>
        <trans-unit id="acbcdc45d250ba7dd26edab06186cf3962745972" translate="yes" xml:space="preserve">
          <source>Iterator Data Types</source>
          <target state="translated">迭代器数据类型</target>
        </trans-unit>
        <trans-unit id="21aa412ed70b91ee6a2ff89a4abea36c2af42360" translate="yes" xml:space="preserve">
          <source>Iterator flag &lt;a href=&quot;#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">迭代器标志&lt;a href=&quot;#c.NPY_ITER_COMMON_DTYPE&quot;&gt; &lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1116d7dda5125208b276ad5471ddd5d08e64ba8" translate="yes" xml:space="preserve">
          <source>Iterator flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">迭代器标志&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b6f69b38ac0228e9245d67b9b1d09ee42bc5dcb" translate="yes" xml:space="preserve">
          <source>Iterator for broadcasting</source>
          <target state="translated">广播用迭代器</target>
        </trans-unit>
        <trans-unit id="6425854ab104811d699d59fa557478463a96d42e" translate="yes" xml:space="preserve">
          <source>Iterator-Allocated Output Arrays</source>
          <target state="translated">迭代器分配的输出数组</target>
        </trans-unit>
        <trans-unit id="3ea20b9878659e33fbac6ee844497cef84a926f4" translate="yes" xml:space="preserve">
          <source>Iterators are a powerful concept for array processing. Essentially, iterators implement a generalized for-loop. If &lt;em&gt;myiter&lt;/em&gt; is an iterator object, then the Python code:</source>
          <target state="translated">迭代器是数组处理的强大概念。本质上，迭代器实现了通用的for循环。如果&lt;em&gt;myiter&lt;/em&gt;是迭代器对象，则Python代码：</target>
        </trans-unit>
        <trans-unit id="796f6321f3f35af9085ef4cf35c1d4e6f0e4b4dc" translate="yes" xml:space="preserve">
          <source>Its disadvantages include</source>
          <target state="translated">其缺点包括</target>
        </trans-unit>
        <trans-unit id="57d54f82f4390510a92d95c53ba668fb5b8d3f93" translate="yes" xml:space="preserve">
          <source>Its probability density function is</source>
          <target state="translated">其概率密度函数为</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="a2cbec366193e4ee99c0016c5fe79f216b41e583" translate="yes" xml:space="preserve">
          <source>J. F. Kaiser, &amp;ldquo;Digital Filters&amp;rdquo; - Ch 7 in &amp;ldquo;Systems analysis by digital computer&amp;rdquo;, Editors: F.F. Kuo and J.F. Kaiser, p 218-285. John Wiley and Sons, New York, (1966).</source>
          <target state="translated">JF Kaiser，&amp;ldquo;数字滤波器&amp;rdquo;-&amp;ldquo;数字计算机的系统分析&amp;rdquo;中的第7章，编辑：FF Kuo和JF Kaiser，第218-285页。约翰&amp;middot;威利父子出版社，纽约，（1966年）。</target>
        </trans-unit>
        <trans-unit id="f458212a67f9dc847550889da59b7be8169fde2a" translate="yes" xml:space="preserve">
          <source>Jaime Fern&amp;aacute;ndez del R&amp;iacute;o</source>
          <target state="translated">海梅&amp;middot;费尔南德斯&amp;middot;德尔里奥</target>
        </trans-unit>
        <trans-unit id="ac739039ef04b0889d2ee40b8300f86d60f0119f" translate="yes" xml:space="preserve">
          <source>January 31, 2021</source>
          <target state="translated">2021年1月31日</target>
        </trans-unit>
        <trans-unit id="d85b6dd0eee475b31af984e7ef5b76c826173395" translate="yes" xml:space="preserve">
          <source>John K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw, &amp;ldquo;Parallel Random Numbers: As Easy as 1, 2, 3,&amp;rdquo; Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (SC11), New York, NY: ACM, 2011.</source>
          <target state="translated">John K. Salmon，Mark A. Moraes，Ron O. Dror和David E. Shaw，&amp;ldquo;并行随机数：1、2、3一样容易&amp;rdquo;，高性能计算，网络，存储和存储国际会议论文集分析（SC11），纽约，纽约：ACM，2011年。</target>
        </trans-unit>
        <trans-unit id="5955c7d39672a39a399f419793e9d4b2998a0ae1" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays along a new axis.</source>
          <target state="translated">沿着一个新的轴连接一个数组序列。</target>
        </trans-unit>
        <trans-unit id="4ea1c9ee9a15b3dcbf6e5bf8c6f47b37d396752b" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays along an existing axis.</source>
          <target state="translated">沿着一个现有的轴连接一个数组序列。</target>
        </trans-unit>
        <trans-unit id="c169b65bb5e75fcaa26f3cb74e710ac8d05e200a" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays together.</source>
          <target state="translated">将一个数组序列连接在一起。</target>
        </trans-unit>
        <trans-unit id="a0cbf31ae389d3a2da5d14e49f527c1cd6c82518" translate="yes" xml:space="preserve">
          <source>Join arrays &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; on key &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">加入阵列 &lt;code&gt;r1&lt;/code&gt; 和 &lt;code&gt;r2&lt;/code&gt; 上的关键 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23191121c5e72da7ca4394cebd036d5824a4bf84" translate="yes" xml:space="preserve">
          <source>Join arrays &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; on keys. Alternative to join_by, that always returns a np.recarray.</source>
          <target state="translated">连接键上的数组 &lt;code&gt;r1&lt;/code&gt; 和 &lt;code&gt;r2&lt;/code&gt; 。替代join_by的方法，该方法始终返回np.recarray。</target>
        </trans-unit>
        <trans-unit id="ace77e0ad40f2680b6aa7f69f4dfbec0108a72b3" translate="yes" xml:space="preserve">
          <source>Join the sequence of objects in &lt;em&gt;obj&lt;/em&gt; together along &lt;em&gt;axis&lt;/em&gt; into a single array. If the dimensions or types are not compatible an error is raised.</source>
          <target state="translated">将&lt;em&gt;obj中&lt;/em&gt;的对象序列沿&lt;em&gt;轴连接&lt;/em&gt;到一个数组中。如果尺寸或类型不兼容，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="0b145a058f4f708ddeea141e56d4c1c7cea2454f" translate="yes" xml:space="preserve">
          <source>Join two or more pathname components + - convert a /-separated pathname to one using the OS&amp;rsquo;s path separator. - resolve  and  from path.</source>
          <target state="translated">连接两个或多个路径名组件+-使用OS的路径分隔符将/分隔的路径名转换为一个。-从路径解决。</target>
        </trans-unit>
        <trans-unit id="930021877100c692fce1a3c6407a5fca82ef8115" translate="yes" xml:space="preserve">
          <source>Joining arrays</source>
          <target state="translated">连接数组</target>
        </trans-unit>
        <trans-unit id="853683e5afe4c33d14d4fe25be2e7a31fcdb24ae" translate="yes" xml:space="preserve">
          <source>Julian Taylor</source>
          <target state="translated">Julian Taylor</target>
        </trans-unit>
        <trans-unit id="1ad4711cdf3c76bf58efbbfffae229363be1de78" translate="yes" xml:space="preserve">
          <source>July 26, 2019</source>
          <target state="translated">2019年7月26日</target>
        </trans-unit>
        <trans-unit id="0ea4fce60f72408c555e74c1176fd49b9f6f546a" translate="yes" xml:space="preserve">
          <source>Jump Size</source>
          <target state="translated">跳跃尺寸</target>
        </trans-unit>
        <trans-unit id="2f4eece64596ae5728be928b098daa67afdcbd49" translate="yes" xml:space="preserve">
          <source>Jumping the BitGenerator state</source>
          <target state="translated">跳转到BitGenerator状态</target>
        </trans-unit>
        <trans-unit id="edaececa3ce78905da5d0c8d3e5c155d40b3049c" translate="yes" xml:space="preserve">
          <source>Jumping to the next level of complexity, it is possible to only partially index an array with index arrays. It takes a bit of thought to understand what happens in such cases. For example if we just use one index array with y:</source>
          <target state="translated">跳到下一个复杂程度,可以只用索引数组部分索引。要了解这种情况下会发生什么,需要花点心思。例如,如果我们只用一个索引数组与y。</target>
        </trans-unit>
        <trans-unit id="d3780087bf4b8552cfaeefd4ae432b76ab3d8ec4" translate="yes" xml:space="preserve">
          <source>Jumps the state as-if jumps * 210306068529402873165736369884012333109 random numbers have been generated.</source>
          <target state="translated">跳转状态为如果跳转*210306068529402873165736369884012333109 随机数已经生成。</target>
        </trans-unit>
        <trans-unit id="e66b5685b9897c71dad3170faecd2518dfadece3" translate="yes" xml:space="preserve">
          <source>June 29, 2020</source>
          <target state="translated">2020年6月29日</target>
        </trans-unit>
        <trans-unit id="f9d305a937478453054f4a6c27158c776273985e" translate="yes" xml:space="preserve">
          <source>Just for your own satisfaction, show yourself that you now have a new &amp;lsquo;remote&amp;rsquo;, with &lt;code&gt;git remote -v show&lt;/code&gt;, giving you something like:</source>
          <target state="translated">只是为了您自己的满意，请使用 &lt;code&gt;git remote -v show&lt;/code&gt; 向您表明自己现在有了一个新的'remote' ，给您这样的东西：</target>
        </trans-unit>
        <trans-unit id="f8882074cfd8e824bd17a6e53a5a926e124e1b9b" translate="yes" xml:space="preserve">
          <source>Just like in other Python container objects, the contents of an array can be accessed and modified by indexing or slicing the array. Unlike the typical container objects, different arrays can share the same data, so changes made on one array might be visible in another.</source>
          <target state="translated">就像在其他Python容器对象中一样,数组的内容可以通过对数组进行索引或切片来访问和修改。与典型的容器对象不同的是,不同的数组可以共享相同的数据,所以在一个数组上所做的更改可能在另一个数组中可见。</target>
        </trans-unit>
        <trans-unit id="c5a2ccc2c43427a5df3aae2525cebca91213ce58" translate="yes" xml:space="preserve">
          <source>Just like the case for builtin special methods like &lt;code&gt;__add__&lt;/code&gt;, properly written &lt;code&gt;__array_function__&lt;/code&gt; methods should always return &lt;code&gt;NotImplemented&lt;/code&gt; when an unknown type is encountered. Otherwise, it will be impossible to correctly override NumPy functions from another object if the operation also includes one of your objects.</source>
          <target state="translated">就像案例内建的特殊方法，如 &lt;code&gt;__add__&lt;/code&gt; ，正确编写 &lt;code&gt;__array_function__&lt;/code&gt; 方法应该总是返回 &lt;code&gt;NotImplemented&lt;/code&gt; 遇到一个未知类型时。否则，如果操作还包含一个对象，则将无法从另一个对象正确覆盖NumPy函数。</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="fea9c97b23d277bbc25a4ecec464e976ad73c9d8" translate="yes" xml:space="preserve">
          <source>Key to use in the Philox state. Unlike &lt;code&gt;seed&lt;/code&gt;, the value in key is directly set. Can be either a Python int in [0, 2**128) or a 2-element uint64 array. &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;seed&lt;/code&gt; cannot both be used.</source>
          <target state="translated">在Philox状态下使用的密钥。与 &lt;code&gt;seed&lt;/code&gt; 不同，key中的值是直接设置的。可以是[0，2 ** 128）中的Python int或2元素的uint64数组。 &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;seed&lt;/code&gt; 不能同时使用。</target>
        </trans-unit>
        <trans-unit id="04e171a322d7a93c71ab2aebd91bfaf316577346" translate="yes" xml:space="preserve">
          <source>Key to use in the Philox state. Unlike seed, the value in key is directly set. Can be either a Python int in [0, 2**128) or a 2-element uint64 array. &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;seed&lt;/code&gt; cannot both be used.</source>
          <target state="translated">在Philox状态下使用的密钥。与种子不同，键中的值是直接设置的。可以是[0，2 ** 128）中的Python int或2元素的uint64数组。 &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;seed&lt;/code&gt; 不能同时使用。</target>
        </trans-unit>
        <trans-unit id="14feafb160591699224306cc83a22ae926c4f9db" translate="yes" xml:space="preserve">
          <source>Keyword arguments for &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 的关键字参数。</target>
        </trans-unit>
        <trans-unit id="a4f25f4e01bab825ac7968a35cf2573aecf46441" translate="yes" xml:space="preserve">
          <source>Keyword arguments passed to &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">关键字参数传递给 &lt;code&gt;func&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="936d17141932bddd8cdbe3cf3d8e6417d18816b5" translate="yes" xml:space="preserve">
          <source>Keyword arguments used in calling &lt;a href=&quot;#numpy.piecewise&quot;&gt;&lt;code&gt;piecewise&lt;/code&gt;&lt;/a&gt; are passed to the functions upon execution, i.e., if called &lt;code&gt;piecewise(..., ..., alpha=1)&lt;/code&gt;, then each function is called as &lt;code&gt;f(x, alpha=1)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.piecewise&quot;&gt; &lt;code&gt;piecewise&lt;/code&gt; &lt;/a&gt;调用中使用的关键字参数在执行时传递给函数，即，如果调用了 &lt;code&gt;piecewise(..., ..., alpha=1)&lt;/code&gt; ，则每个函数都称为 &lt;code&gt;f(x, alpha=1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94796302f2d6010802da8fc83c102abd3d91e59b" translate="yes" xml:space="preserve">
          <source>Keyword arguments with the value &lt;code&gt;None&lt;/code&gt; are not checked. Specifying a keyword enforces checking of that aspect of the ndarray on conversion to a ctypes-compatible object. The dtype keyword can be any object understood as a data-type object. The ndim keyword should be an integer, and the shape keyword should be an integer or a sequence of integers. The flags keyword specifies the minimal flags that are required on any array passed in. This can be specified as a string of comma separated requirements, an integer indicating the requirement bits OR&amp;rsquo;d together, or a flags object returned from the flags attribute of an array with the necessary requirements.</source>
          <target state="translated">不检查值为 &lt;code&gt;None&lt;/code&gt; 的关键字参数。指定关键字可在转换为ctypes兼容对象时强制检查ndarray的这一方面。dtype关键字可以是任何理解为数据类型对象的对象。ndim关键字应为整数，shape关键字应为整数或整数序列。flags关键字指定传入的任何数组上所需的最小标志。可以将其指定为以逗号分隔的要求字符串，指示要求位或的整数，或从ans的flags属性返回的flags对象。具有必要要求的阵列。</target>
        </trans-unit>
        <trans-unit id="7b38351b3da46b01757fe5df0b763a6ba88d3175" translate="yes" xml:space="preserve">
          <source>Keyword arguments. The valid keywords are the possible floating-point exceptions. Each keyword should have a string value that defines the treatment for the particular error. Possible values are {&amp;lsquo;ignore&amp;rsquo;, &amp;lsquo;warn&amp;rsquo;, &amp;lsquo;raise&amp;rsquo;, &amp;lsquo;call&amp;rsquo;, &amp;lsquo;print&amp;rsquo;, &amp;lsquo;log&amp;rsquo;}.</source>
          <target state="translated">关键字参数。有效的关键字是可能的浮点异常。每个关键字应具有一个字符串值，该字符串值定义对特定错误的处理方式。可能的值为{'ignore'，'warn'，'raise'，'call'，'print'，'log'}。</target>
        </trans-unit>
        <trans-unit id="cca3dd937ca64fcc731c3b76e10a3a59e197b380" translate="yes" xml:space="preserve">
          <source>Keywords other than &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;以外的关键字传递给 &lt;code&gt;function&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd51c0cf5320b73d3ff55b2176ad245d2d7397b1" translate="yes" xml:space="preserve">
          <source>Keywords other than &lt;code&gt;dtype&lt;/code&gt; are passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; 以外的关键字传递给 &lt;code&gt;function&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c23ce94abbcda9863c972bac23c6a2a76bdd7d1" translate="yes" xml:space="preserve">
          <source>Kind of floating point data-type about which to get information.</source>
          <target state="translated">一种浮点数据类型,要获取相关信息。</target>
        </trans-unit>
        <trans-unit id="31be8fd23c00b4b851fa5f224f6fd4dac29e08c9" translate="yes" xml:space="preserve">
          <source>Known bugs:</source>
          <target state="translated">已知的错误。</target>
        </trans-unit>
        <trans-unit id="26db35f7eb95d8b793f4df612e64a0ce6b5afd47" translate="yes" xml:space="preserve">
          <source>Known failures &amp;amp; skipping tests</source>
          <target state="translated">已知故障和跳过测试</target>
        </trans-unit>
        <trans-unit id="d54ed0ae4c90f25216ec62895c50ba0c59603696" translate="yes" xml:space="preserve">
          <source>Kotz, Samuel, et. al. &amp;ldquo;The Laplace Distribution and Generalizations, &amp;rdquo; Birkhauser, 2001.</source>
          <target state="translated">Kotz，Samuel等。等 &amp;ldquo;拉普拉斯分布与归纳&amp;rdquo;，Birkhauser，2001年。</target>
        </trans-unit>
        <trans-unit id="9b54aa8ed101113f4ff654653787cb490d5956f9" translate="yes" xml:space="preserve">
          <source>Kronecker product of two arrays.</source>
          <target state="translated">两个数组的克朗克积。</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="0c5ca7c9489e795d6e344494ca6012e6c5e6c94a" translate="yes" xml:space="preserve">
          <source>L. J. Gitman, &amp;ldquo;Principles of Managerial Finance, Brief,&amp;rdquo; 3rd ed., Addison-Wesley, 2003, pg. 346.</source>
          <target state="translated">LJ Gitman，&amp;ldquo;管理财务原理，简介&amp;rdquo;，第3版，Addison-Wesley，2003年，第13页。346。</target>
        </trans-unit>
        <trans-unit id="dad744be14f4bac6567fee2e00e8179f1cafc777" translate="yes" xml:space="preserve">
          <source>L. J. Gitman, &amp;ldquo;Principles of Managerial Finance, Brief,&amp;rdquo; 3rd ed., Addison-Wesley, 2003, pg. 348.</source>
          <target state="translated">LJ Gitman，&amp;ldquo;管理财务原理，简介&amp;rdquo;，第3版，Addison-Wesley，2003年，第13页。348。</target>
        </trans-unit>
        <trans-unit id="c9abe91342431b93d138f7615d16985673f94ddb" translate="yes" xml:space="preserve">
          <source>L2 norm of vector &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">向量 &lt;code&gt;v&lt;/code&gt; 的L2范数</target>
        </trans-unit>
        <trans-unit id="cf9e7dcbce935737e3132c8567095e62b32e357d" translate="yes" xml:space="preserve">
          <source>LAPACK</source>
          <target state="translated">LAPACK</target>
        </trans-unit>
        <trans-unit id="a3fb459b8d25a6646ccd3006470636c4394d2fa7" translate="yes" xml:space="preserve">
          <source>LAPACK (NetLIB)</source>
          <target state="translated">LAPACK (NetLIB)</target>
        </trans-unit>
        <trans-unit id="21d5b247623a47d3ffff1da535ef4461b811d560" translate="yes" xml:space="preserve">
          <source>LSB integer 1</source>
          <target state="translated">LSB整数1</target>
        </trans-unit>
        <trans-unit id="17bcd0c5595da0e7eb910f67673f577b1f83f0f7" translate="yes" xml:space="preserve">
          <source>LSB integer 2</source>
          <target state="translated">LSB整数2</target>
        </trans-unit>
        <trans-unit id="ee3f4ac8c9031369c0019ec76911e81f54ff04c4" translate="yes" xml:space="preserve">
          <source>LU decomposition (note: P(MATLAB) == transpose(P(NumPy)))</source>
          <target state="translated">LU分解(注:P(MATLAB)==transpose(P(NumPy)))</target>
        </trans-unit>
        <trans-unit id="eec57c77bc60eb78065b6605060bb41430b8e7ce" translate="yes" xml:space="preserve">
          <source>LU decomposition (note: P(Matlab) == transpose(P(numpy)) )</source>
          <target state="translated">LU分解(注:P(Matlab)==transpose(P(numpy)))</target>
        </trans-unit>
        <trans-unit id="f50beb264ce7d144bf1ce0f2f4d3f272a300b7de" translate="yes" xml:space="preserve">
          <source>Label a test as &amp;lsquo;slow&amp;rsquo;.</source>
          <target state="translated">将测试标记为&amp;ldquo;慢&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="369c34c1729b62dec5c01c92266ffbd20a59873d" translate="yes" xml:space="preserve">
          <source>Labeling tests</source>
          <target state="translated">标签测试</target>
        </trans-unit>
        <trans-unit id="4bebfc5e6e36da81205979cf627ca2083b60eab7" translate="yes" xml:space="preserve">
          <source>Laguerre</source>
          <target state="translated">Laguerre</target>
        </trans-unit>
        <trans-unit id="e97fc7286288e61e2979e3135f28bb8c533a9b55" translate="yes" xml:space="preserve">
          <source>Laguerre (class in numpy.polynomial.laguerre)</source>
          <target state="translated">拉盖尔(numpy.polynomial.laguerre中的类)</target>
        </trans-unit>
        <trans-unit id="5e57606aead53cf91effb25cd081645a48be4c71" translate="yes" xml:space="preserve">
          <source>Laguerre Class</source>
          <target state="translated">Laguerre级</target>
        </trans-unit>
        <trans-unit id="ba379f482d893a166d54a2acffc47cc917ce664e" translate="yes" xml:space="preserve">
          <source>Laguerre Module (&lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt;)</source>
          <target state="translated">Laguerre模块（ &lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="1fa1d2e4107d4f18290f33c4164e9ffd20858112" translate="yes" xml:space="preserve">
          <source>Laguerre Module (numpy.polynomial.laguerre)</source>
          <target state="translated">拉盖尔模块 (numpy.polynomial.laguerre)</target>
        </trans-unit>
        <trans-unit id="2a936707907aefc2336791e67e0a362c7a6f2893" translate="yes" xml:space="preserve">
          <source>Laguerre Series (&lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt;)</source>
          <target state="translated">Laguerre系列（ &lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="df257db6a3d424bc3a9e921bbaaa3ba0ba50dac3" translate="yes" xml:space="preserve">
          <source>Laguerre Series (numpy.polynomial.laguerre)</source>
          <target state="translated">拉格尔系列 (numpy.polynomial.laguerre)</target>
        </trans-unit>
        <trans-unit id="99466c13dff878e880a6ce449247757d575c46d1" translate="yes" xml:space="preserve">
          <source>Laguerre coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*L_0(x) + 2*L_1(X) + 3*L_2(x)&lt;/code&gt;.</source>
          <target state="translated">Laguerre系数按递增的顺序排列，即 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 给出 &lt;code&gt;1*L_0(x) + 2*L_1(X) + 3*L_2(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96781eb22440929e4bf56e8413b2c4b2ee004cfa" translate="yes" xml:space="preserve">
          <source>Laguerre coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">拉盖尔系数从低到高排序。如果 &lt;code&gt;y&lt;/code&gt; 为2-d，在的k列中的数据的系数 &lt;code&gt;y&lt;/code&gt; 在柱 &lt;code&gt;k&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="203d5e91f105ffb95930f626e1d302a193aeaa68" translate="yes" xml:space="preserve">
          <source>Laguerre series</source>
          <target state="translated">拉盖尔系列</target>
        </trans-unit>
        <trans-unit id="a347ea54d317cc577991ec7bf8e660f33b29ea5f" translate="yes" xml:space="preserve">
          <source>Laguerre series coefficients of the integral.</source>
          <target state="translated">拉格尔系列系数的积分。</target>
        </trans-unit>
        <trans-unit id="d470a6ac507868056b6fb97be3c38f8e66fd3f73" translate="yes" xml:space="preserve">
          <source>Laguerre series of power.</source>
          <target state="translated">拉盖尔系列电。</target>
        </trans-unit>
        <trans-unit id="077697f66c66782d4ef98066ee75e7065a9fd35e" translate="yes" xml:space="preserve">
          <source>Laguerre series of the derivative.</source>
          <target state="translated">导数的拉格列。</target>
        </trans-unit>
        <trans-unit id="9a5deb2e7228ec3244f92981a2f639bd0074c61e" translate="yes" xml:space="preserve">
          <source>Laguerre series whose graph is a straight line.</source>
          <target state="translated">拉盖尔数列的图形是一条直线。</target>
        </trans-unit>
        <trans-unit id="40be499dbcfef954b53f79728a280796ea6c4f1b" translate="yes" xml:space="preserve">
          <source>Laguerre weight function.</source>
          <target state="translated">拉格尔权重函数。</target>
        </trans-unit>
        <trans-unit id="19b66881a109c4450aeadcaedc080b0375d2ecf9" translate="yes" xml:space="preserve">
          <source>Laguerre.__call__()</source>
          <target state="translated">Laguerre.__call__()</target>
        </trans-unit>
        <trans-unit id="b79eed7b566471b5b98d5403131d5fcccb9ccdd6" translate="yes" xml:space="preserve">
          <source>Laguerre.basis()</source>
          <target state="translated">Laguerre.basis()</target>
        </trans-unit>
        <trans-unit id="8450b9cd56cfc84841f9b6a7b3ce8b6553391224" translate="yes" xml:space="preserve">
          <source>Laguerre.cast()</source>
          <target state="translated">Laguerre.cast()</target>
        </trans-unit>
        <trans-unit id="27a50de57a0c19215d0a40ab26d7fc3244818104" translate="yes" xml:space="preserve">
          <source>Laguerre.convert()</source>
          <target state="translated">Laguerre.convert()</target>
        </trans-unit>
        <trans-unit id="ba2566270efed850de8b718e7293f07a260b676d" translate="yes" xml:space="preserve">
          <source>Laguerre.copy()</source>
          <target state="translated">Laguerre.copy()</target>
        </trans-unit>
        <trans-unit id="3b52ca7dceafcdacc78576d128623ad1866249fc" translate="yes" xml:space="preserve">
          <source>Laguerre.cutdeg()</source>
          <target state="translated">Laguerre.cutdeg()</target>
        </trans-unit>
        <trans-unit id="d2b6b76b4b9ee361106b2c94187d00faaf8bec52" translate="yes" xml:space="preserve">
          <source>Laguerre.degree()</source>
          <target state="translated">Laguerre.degree()</target>
        </trans-unit>
        <trans-unit id="00ba5991cdfe21416f272ddb4e2fd2ee48ba1e73" translate="yes" xml:space="preserve">
          <source>Laguerre.deriv()</source>
          <target state="translated">Laguerre.deriv()</target>
        </trans-unit>
        <trans-unit id="3774c67b9a36d28184dc80e1b4d2486ea1e1f36a" translate="yes" xml:space="preserve">
          <source>Laguerre.domain</source>
          <target state="translated">Laguerre.domain</target>
        </trans-unit>
        <trans-unit id="b85b503244ce55e050a887342980da72b2e9ad78" translate="yes" xml:space="preserve">
          <source>Laguerre.fit()</source>
          <target state="translated">Laguerre.fit()</target>
        </trans-unit>
        <trans-unit id="23af0332e2c429442e5afb68340fa4aeef4545dc" translate="yes" xml:space="preserve">
          <source>Laguerre.fromroots()</source>
          <target state="translated">Laguerre.fromroots()</target>
        </trans-unit>
        <trans-unit id="a2a6581abb5a91aaeac7e93a2a256734282432d3" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samecoef()</source>
          <target state="translated">Laguerre.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="7dd4d8134966100274e963f0060bfab576b5fddf" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samedomain()</source>
          <target state="translated">Laguerre.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="e5e59e81443c19ac8f19e8c2fdccb120a1c9224f" translate="yes" xml:space="preserve">
          <source>Laguerre.has_sametype()</source>
          <target state="translated">Laguerre.has_sametype()</target>
        </trans-unit>
        <trans-unit id="3d138070a5021011806b89098bbe766378b10e7e" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samewindow()</source>
          <target state="translated">Laguerre.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="6f69d4698823efec4ccf07af22829cc894b0b98c" translate="yes" xml:space="preserve">
          <source>Laguerre.identity()</source>
          <target state="translated">Laguerre.identity()</target>
        </trans-unit>
        <trans-unit id="f1f6d872a178e7692b45f4ccbfd34fbbf6ed5f91" translate="yes" xml:space="preserve">
          <source>Laguerre.integ()</source>
          <target state="translated">Laguerre.integ()</target>
        </trans-unit>
        <trans-unit id="068cb46402017cfb3dd18164c9b41f89c700f799" translate="yes" xml:space="preserve">
          <source>Laguerre.linspace()</source>
          <target state="translated">Laguerre.linspace()</target>
        </trans-unit>
        <trans-unit id="100d51943018ffa8eadce404d26cfaa31b915872" translate="yes" xml:space="preserve">
          <source>Laguerre.mapparms()</source>
          <target state="translated">Laguerre.mapparms()</target>
        </trans-unit>
        <trans-unit id="de9dd46ebdab9f670b65d8cedb81c132ac30c276" translate="yes" xml:space="preserve">
          <source>Laguerre.roots()</source>
          <target state="translated">Laguerre.roots()</target>
        </trans-unit>
        <trans-unit id="9779fb4f29c73da5d6cee5ec234239b97271c1ae" translate="yes" xml:space="preserve">
          <source>Laguerre.trim()</source>
          <target state="translated">Laguerre.trim()</target>
        </trans-unit>
        <trans-unit id="76a59bb3d54a6db3b464f00c41f8b5a8b4767c11" translate="yes" xml:space="preserve">
          <source>Laguerre.truncate()</source>
          <target state="translated">Laguerre.truncate()</target>
        </trans-unit>
        <trans-unit id="36198a8897031e87556aee045b29805731052142" translate="yes" xml:space="preserve">
          <source>Laplaces</source>
          <target state="translated">Laplaces</target>
        </trans-unit>
        <trans-unit id="82f5e1511892c7fb01c75144ac000d62f83d5a77" translate="yes" xml:space="preserve">
          <source>Large allocations marked as suitable for transparent hugepages</source>
          <target state="translated">标记为适合透明大页的大额拨款</target>
        </trans-unit>
        <trans-unit id="b681a7171a5bce2d6bad9d307b09a9ccc2c281db" translate="yes" xml:space="preserve">
          <source>Large arrays</source>
          <target state="translated">大型阵列</target>
        </trans-unit>
        <trans-unit id="5be94f77cefc792ba9a8a12749b2ab34d4d7de5d" translate="yes" xml:space="preserve">
          <source>Large parts of the NumPy API have PEP-484-style type annotations. In addition a number of type aliases are available to users, most prominently the two below:</source>
          <target state="translated">NumPy API的大部分内容都有PEP-484式的类型注释。此外,用户还可以使用一些类型别名,最主要的是下面两个。</target>
        </trans-unit>
        <trans-unit id="da46491a1118285dbcf5975a2a3f36f864e4e6eb" translate="yes" xml:space="preserve">
          <source>Large parts of this manual originate from Travis E. Oliphant&amp;rsquo;s book &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;Guide to NumPy&lt;/a&gt; (which generously entered Public Domain in August 2008). The reference documentation for many of the functions are written by numerous contributors and developers of NumPy.</source>
          <target state="translated">本手册的大部分内容来自Travis E. Oliphant的&lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;《 NumPy指南》&lt;/a&gt;（该指南于2008年8月慷慨地进入了Public Domain）。许多功能的参考文档由NumPy的许多贡献者和开发人员编写。</target>
        </trans-unit>
        <trans-unit id="eab5c44c0f0e22a5c5510649d34e17cb192d1603" translate="yes" xml:space="preserve">
          <source>Large parts of this manual originate from Travis E. Oliphant's book &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;&quot;Guide to NumPy&quot;&lt;/a&gt; (which generously entered Public Domain in August 2008). The reference documentation for many of the functions are written by numerous contributors and developers of NumPy.</source>
          <target state="translated">本手册的大部分内容来自Travis E. Oliphant的书&lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;&amp;ldquo; NumPy指南&amp;rdquo;&lt;/a&gt;（该书于2008年8月慷慨地进入了Public Domain）。许多功能的参考文档由NumPy的众多贡献者和开发人员编写。</target>
        </trans-unit>
        <trans-unit id="461e005b11043acdc64bcd7d33f04e9a4a706ce0" translate="yes" xml:space="preserve">
          <source>Large parts of this manual originate from Travis E. Oliphant's book &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;&quot;Guide to NumPy&quot;&lt;/a&gt; (which generously entered public domain in August 2008). The reference documentation for many of the functions are written by numerous contributors and developers of NumPy.</source>
          <target state="translated">本手册的大部分内容来自Travis E. Oliphant的书&lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;&amp;ldquo; NumPy指南&amp;rdquo;&lt;/a&gt;（该书于2008年8月慷慨地进入了公共领域）。许多功能的参考文档由NumPy的众多贡献者和开发人员编写。</target>
        </trans-unit>
        <trans-unit id="2fdae5c61df170eabed81dff27bfb3678199f99b" translate="yes" xml:space="preserve">
          <source>Largest size allowed for the user-settable buffers.</source>
          <target state="translated">允许用户设置缓冲区的最大尺寸。</target>
        </trans-unit>
        <trans-unit id="8da87d373f111f7e103693ae24e8a07ffa7a91e2" translate="yes" xml:space="preserve">
          <source>Last processed field name (used internally during recursion).</source>
          <target state="translated">最后处理的字段名(在递归过程中内部使用)。</target>
        </trans-unit>
        <trans-unit id="688c183c0553e7f8897c3da631ac608e3281e20b" translate="yes" xml:space="preserve">
          <source>Learn about concepts and submodules</source>
          <target state="translated">了解概念和子模块</target>
        </trans-unit>
        <trans-unit id="7e1c2c8a281b93c2a756aa5c5b0dde7c93d58559" translate="yes" xml:space="preserve">
          <source>Learn about what NumPy is and how to install it</source>
          <target state="translated">了解什么是NumPy以及如何安装它。</target>
        </trans-unit>
        <trans-unit id="1893b40e2e74ded8d87e7668bb8ea0e85b265882" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;../reference/routines.io#routines-io&quot;&gt;input and output routines here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../reference/routines.io#routines-io&quot;&gt;在此处&lt;/a&gt;了解有关输入和输出例程的更多信息。</target>
        </trans-unit>
        <trans-unit id="42d6db2ec75c1bd30bb52b2e73819209cb308cc1" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;quickstart#quickstart-indexing-slicing-and-iterating&quot;&gt;indexing and slicing here&lt;/a&gt; and &lt;a href=&quot;basics.indexing#basics-indexing&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;quickstart#quickstart-indexing-slicing-and-iterating&quot;&gt;在此处&lt;/a&gt;和&lt;a href=&quot;basics.indexing#basics-indexing&quot;&gt;此处&lt;/a&gt;了解有关索引和切片的更多信息。</target>
        </trans-unit>
        <trans-unit id="2a595050bddab4e4c46cb1e0dc7dff5874ac8e5f" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;whatisnumpy#whatisnumpy&quot;&gt;NumPy here&lt;/a&gt;!</source>
          <target state="translated">&lt;a href=&quot;whatisnumpy#whatisnumpy&quot;&gt;在此处&lt;/a&gt;了解有关NumPy的更多信息！</target>
        </trans-unit>
        <trans-unit id="eccf892e3b309e4f27b805fda73ba6310c691f1f" translate="yes" xml:space="preserve">
          <source>Learn more about creating arrays here</source>
          <target state="translated">在这里了解更多关于创建数组的信息</target>
        </trans-unit>
        <trans-unit id="98c632c8b787bef56a52b5a8399e5f77771145f9" translate="yes" xml:space="preserve">
          <source>Learner profile</source>
          <target state="translated">学员简介</target>
        </trans-unit>
        <trans-unit id="1394be7b7b406c4f13516595eb91b7dcfd8ff79c" translate="yes" xml:space="preserve">
          <source>Learning Objectives</source>
          <target state="translated">学习目标</target>
        </trans-unit>
        <trans-unit id="e9f285095a214517cc70148a152aa9ce3bfb1555" translate="yes" xml:space="preserve">
          <source>Least squares fit of Chebyshev series to data.</source>
          <target state="translated">Chebyshev序列与数据的最小二乘拟合。</target>
        </trans-unit>
        <trans-unit id="5eede6c92597c6ad1ec14f2a50e868bfa8dbcef5" translate="yes" xml:space="preserve">
          <source>Least squares fit of Hermite series to data.</source>
          <target state="translated">Hermite系列与数据的最小二乘拟合。</target>
        </trans-unit>
        <trans-unit id="f9834397596bb1c91a60ebd7bed6c56b93f210b5" translate="yes" xml:space="preserve">
          <source>Least squares fit of Laguerre series to data.</source>
          <target state="translated">Laguerre序列与数据的最小二乘拟合。</target>
        </trans-unit>
        <trans-unit id="60abe6780ea6293285c10210c3c968485e58937b" translate="yes" xml:space="preserve">
          <source>Least squares fit of Legendre series to data.</source>
          <target state="translated">Legendre序列与数据的最小二乘拟合。</target>
        </trans-unit>
        <trans-unit id="f70b890f268681837dd642a40e85f47d99c8ef5c" translate="yes" xml:space="preserve">
          <source>Least squares fit to data.</source>
          <target state="translated">对数据进行最小二乘拟合。</target>
        </trans-unit>
        <trans-unit id="82d4ad107d684ab9ad44770f05b7a2542d27bae6" translate="yes" xml:space="preserve">
          <source>Least squares polynomial fit.</source>
          <target state="translated">最小二乘多项式拟合。</target>
        </trans-unit>
        <trans-unit id="66b99a01120f0770d01e2e70f30aa7b3e6d8760b" translate="yes" xml:space="preserve">
          <source>Least-squares fit of a polynomial to data.</source>
          <target state="translated">多项式与数据的最小二乘拟合。</target>
        </trans-unit>
        <trans-unit id="004f7153cd5215d911c25b804b9cb64fc053135e" translate="yes" xml:space="preserve">
          <source>Least-squares solution. If &lt;code&gt;b&lt;/code&gt; is two-dimensional, the solutions are in the &lt;code&gt;K&lt;/code&gt; columns of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">最小二乘解。如果 &lt;code&gt;b&lt;/code&gt; 是二维的，则解在 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;K&lt;/code&gt; 列中。</target>
        </trans-unit>
        <trans-unit id="8e3bf79d3ac96cdf89ed0ca352f8850960c3aecf" translate="yes" xml:space="preserve">
          <source>Leg of the triangle(s). If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">三角形的边。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="a3da3f26242bb8617087ec4d4fb9fafcb77635dc" translate="yes" xml:space="preserve">
          <source>Legacy Generator (RandomState)</source>
          <target state="translated">遗产生成器(RandomState)</target>
        </trans-unit>
        <trans-unit id="7a03f0fe89c9579b9b2b236650c98185edc2fe62" translate="yes" xml:space="preserve">
          <source>Legacy Random Generation</source>
          <target state="translated">遗产随机生成</target>
        </trans-unit>
        <trans-unit id="47a5d89b5a8a2f363ca5b4a1476eb173fc07ab11" translate="yes" xml:space="preserve">
          <source>Legendre</source>
          <target state="translated">Legendre</target>
        </trans-unit>
        <trans-unit id="358ed7a487a2a55bfa9556bbf8f4fe1f6f4c1094" translate="yes" xml:space="preserve">
          <source>Legendre (class in numpy.polynomial.legendre)</source>
          <target state="translated">图例法</target>
        </trans-unit>
        <trans-unit id="4120cea9b471c879abda7b1336aba3d61c52e3bc" translate="yes" xml:space="preserve">
          <source>Legendre Class</source>
          <target state="translated">Legendre级</target>
        </trans-unit>
        <trans-unit id="b4a47072941f51eec5be92fa7536302b1cd27189" translate="yes" xml:space="preserve">
          <source>Legendre Module (&lt;code&gt;numpy.polynomial.legendre&lt;/code&gt;)</source>
          <target state="translated">Legendre模块（ &lt;code&gt;numpy.polynomial.legendre&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="a6b7c39b7f03fb5bf1916b89cb05334bb7660fc8" translate="yes" xml:space="preserve">
          <source>Legendre Module (numpy.polynomial.legendre)</source>
          <target state="translated">Legendre模块 (numpy.polynomial.legadre)</target>
        </trans-unit>
        <trans-unit id="5cf0b728017026cd3633f8023ba22356ac49e8e9" translate="yes" xml:space="preserve">
          <source>Legendre Series (&lt;code&gt;numpy.polynomial.legendre&lt;/code&gt;)</source>
          <target state="translated">Legendre系列（ &lt;code&gt;numpy.polynomial.legendre&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3fc1f7294028d411cdbd64652dfec514ea719176" translate="yes" xml:space="preserve">
          <source>Legendre Series (numpy.polynomial.legendre)</source>
          <target state="translated">Legendre系列 (numpy.polynomial.legendre)</target>
        </trans-unit>
        <trans-unit id="72a4b81826e99e6fe744c1d98416a1d24f591803" translate="yes" xml:space="preserve">
          <source>Legendre coefficients in order of increasing degree, i.e., &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*P_0(x) + 2*P_1(x) + 3*P_2(x)&lt;/code&gt;.</source>
          <target state="translated">勒让德系数按递增的顺序排列，即 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 给出 &lt;code&gt;1*P_0(x) + 2*P_1(x) + 3*P_2(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd1aecb7d54479faf64417ed750dd54dbc48134e" translate="yes" xml:space="preserve">
          <source>Legendre coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;. If &lt;code&gt;deg&lt;/code&gt; is specified as a list, coefficients for terms not included in the fit are set equal to zero in the returned &lt;code&gt;coef&lt;/code&gt;.</source>
          <target state="translated">勒让德系数从低到高排序。如果 &lt;code&gt;y&lt;/code&gt; 为2-d，在的k列中的数据的系数 &lt;code&gt;y&lt;/code&gt; 在柱 &lt;code&gt;k&lt;/code&gt; 。如果将 &lt;code&gt;deg&lt;/code&gt; 指定为列表，则不包含在拟合中的项的 &lt;code&gt;coef&lt;/code&gt; 在返回的coef中设置为零。</target>
        </trans-unit>
        <trans-unit id="36661c8b6df50f0810e8abcd38c911e37700210a" translate="yes" xml:space="preserve">
          <source>Legendre series</source>
          <target state="translated">Legendre系列</target>
        </trans-unit>
        <trans-unit id="cff0f8c14f012c4d84feceb1b721e76e38f2b7e7" translate="yes" xml:space="preserve">
          <source>Legendre series coefficient array of the integral.</source>
          <target state="translated">Legendre系列系数阵的积分。</target>
        </trans-unit>
        <trans-unit id="e423b1233d9fcd2c8894e66b68b4670d1797fcf6" translate="yes" xml:space="preserve">
          <source>Legendre series of power.</source>
          <target state="translated">传奇系列的力量。</target>
        </trans-unit>
        <trans-unit id="cbfaa0f2130ef078276a68c292602bd146355698" translate="yes" xml:space="preserve">
          <source>Legendre series of the derivative.</source>
          <target state="translated">Legendre系列的衍生物。</target>
        </trans-unit>
        <trans-unit id="0c94fd4bbecdfa33cfa2085e96aaf27eb258cb91" translate="yes" xml:space="preserve">
          <source>Legendre series whose graph is a straight line.</source>
          <target state="translated">Legendre系列的图形是一条直线。</target>
        </trans-unit>
        <trans-unit id="9c6dd8780cca130b14ebf98dc6a58e0b8fde7f4f" translate="yes" xml:space="preserve">
          <source>Legendre weight function (= 1).</source>
          <target state="translated">Legendre权重函数(=1)。</target>
        </trans-unit>
        <trans-unit id="11838d713a7ca74c36db28fb9741ab01b38fc2f4" translate="yes" xml:space="preserve">
          <source>Legendre, Laguerre, Hermite, HermiteE polynomials in &lt;code&gt;numpy.polynomial&lt;/code&gt;</source>
          <target state="translated">勒让德，拉盖尔，埃尔米特，HermiteE多项式 &lt;code&gt;numpy.polynomial&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4086e8682b0af8e09d2dfa82cd2fdc76b5bc8f8d" translate="yes" xml:space="preserve">
          <source>Legendre.__call__()</source>
          <target state="translated">Legendre.__call__()</target>
        </trans-unit>
        <trans-unit id="38dffd4eba846de64c001288fae359b48ca7be06" translate="yes" xml:space="preserve">
          <source>Legendre.basis()</source>
          <target state="translated">Legendre.basis()</target>
        </trans-unit>
        <trans-unit id="03d79bdd0c244e4a8685e0cc2ed8f9bba14f2e75" translate="yes" xml:space="preserve">
          <source>Legendre.cast()</source>
          <target state="translated">Legendre.cast()</target>
        </trans-unit>
        <trans-unit id="c3757be303c19145dd4cdc1f1fdbe7778af7a9b8" translate="yes" xml:space="preserve">
          <source>Legendre.convert()</source>
          <target state="translated">Legendre.convert()</target>
        </trans-unit>
        <trans-unit id="30694a9a60e1750eef89dd48cd213d03dc835778" translate="yes" xml:space="preserve">
          <source>Legendre.copy()</source>
          <target state="translated">Legendre.copy()</target>
        </trans-unit>
        <trans-unit id="67fd9bca2a23484298ecfc5a44e6dbe767f8deee" translate="yes" xml:space="preserve">
          <source>Legendre.cutdeg()</source>
          <target state="translated">Legendre.cutdeg()</target>
        </trans-unit>
        <trans-unit id="de6280bafa05de1ba0dc2f4ee315b2f1c3f376c2" translate="yes" xml:space="preserve">
          <source>Legendre.degree()</source>
          <target state="translated">Legendre.degree()</target>
        </trans-unit>
        <trans-unit id="065d87c76a899767772e29e52989a91f8e7a3c94" translate="yes" xml:space="preserve">
          <source>Legendre.deriv()</source>
          <target state="translated">Legendre.deriv()</target>
        </trans-unit>
        <trans-unit id="dc4f96a4666e84f37c719b2fad25d196a612cc45" translate="yes" xml:space="preserve">
          <source>Legendre.domain</source>
          <target state="translated">Legendre.domain</target>
        </trans-unit>
        <trans-unit id="11c2423446ff507ce6eb98675dde94c735489c69" translate="yes" xml:space="preserve">
          <source>Legendre.fit()</source>
          <target state="translated">Legendre.fit()</target>
        </trans-unit>
        <trans-unit id="e21bd7963e9b515a9f4b47a6bcd09e263e8089ee" translate="yes" xml:space="preserve">
          <source>Legendre.fromroots()</source>
          <target state="translated">Legendre.fromroots()</target>
        </trans-unit>
        <trans-unit id="d5d912a486cc7b8f50ccecabe4f025c8e6390336" translate="yes" xml:space="preserve">
          <source>Legendre.has_samecoef()</source>
          <target state="translated">Legendre.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="6666d87ba29b4b8ae40e97a1bf2868d699324607" translate="yes" xml:space="preserve">
          <source>Legendre.has_samedomain()</source>
          <target state="translated">Legendre.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="3760f41cb73e83c63c3b041fb1850faaf75fa051" translate="yes" xml:space="preserve">
          <source>Legendre.has_sametype()</source>
          <target state="translated">Legendre.has_sametype()</target>
        </trans-unit>
        <trans-unit id="776a3387bba3bfaabfedc34f80f56441350be257" translate="yes" xml:space="preserve">
          <source>Legendre.has_samewindow()</source>
          <target state="translated">Legendre.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="d270c39a15f9cf84d450407eca8d04e34120a21a" translate="yes" xml:space="preserve">
          <source>Legendre.identity()</source>
          <target state="translated">Legendre.identity()</target>
        </trans-unit>
        <trans-unit id="a025b9af1289248a2a7d813cd3249b6c59a1b90e" translate="yes" xml:space="preserve">
          <source>Legendre.integ()</source>
          <target state="translated">Legendre.integ()</target>
        </trans-unit>
        <trans-unit id="b1309f9dd6fba8397cba7645c87fd874d753067f" translate="yes" xml:space="preserve">
          <source>Legendre.linspace()</source>
          <target state="translated">Legendre.linspace()</target>
        </trans-unit>
        <trans-unit id="3b41ed00816bbf0ea94cb8ce7b846f9374dce867" translate="yes" xml:space="preserve">
          <source>Legendre.mapparms()</source>
          <target state="translated">Legendre.mapparms()</target>
        </trans-unit>
        <trans-unit id="498206cc30a61e0936daddec7420065e1fb22906" translate="yes" xml:space="preserve">
          <source>Legendre.roots()</source>
          <target state="translated">Legendre.roots()</target>
        </trans-unit>
        <trans-unit id="c917ded9bfb105e1d1214678489c4d2d643e0789" translate="yes" xml:space="preserve">
          <source>Legendre.trim()</source>
          <target state="translated">Legendre.trim()</target>
        </trans-unit>
        <trans-unit id="4b818047b63ac1fb3abbf9ee09b84ccf39af0370" translate="yes" xml:space="preserve">
          <source>Legendre.truncate()</source>
          <target state="translated">Legendre.truncate()</target>
        </trans-unit>
        <trans-unit id="c92dc32e98f74178230da6c9cf3f1619baf0cae9" translate="yes" xml:space="preserve">
          <source>Length &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; array of &lt;code&gt;char&lt;/code&gt; encoding the &lt;a href=&quot;../generated/numpy.dtype.num#numpy.dtype.num&quot;&gt;&lt;code&gt;numpy.dtype.num&lt;/code&gt;&lt;/a&gt; (built-in only) that the corresponding function in the &lt;code&gt;func&lt;/code&gt; array accepts. For instance, for a comparison ufunc with three &lt;code&gt;ntypes&lt;/code&gt;, two &lt;code&gt;nin&lt;/code&gt; and one &lt;code&gt;nout&lt;/code&gt;, where the first function accepts &lt;a href=&quot;../arrays.scalars#numpy.int32&quot;&gt;&lt;code&gt;numpy.int32&lt;/code&gt;&lt;/a&gt; and the the second &lt;a href=&quot;../arrays.scalars#numpy.int64&quot;&gt;&lt;code&gt;numpy.int64&lt;/code&gt;&lt;/a&gt;, with both returning &lt;a href=&quot;../arrays.scalars#numpy.bool_&quot;&gt;&lt;code&gt;numpy.bool_&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;types&lt;/code&gt; would be &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; since &lt;code&gt;NPY_INT32&lt;/code&gt; is 5, &lt;code&gt;NPY_INT64&lt;/code&gt; is 7, and &lt;code&gt;NPY_BOOL&lt;/code&gt; is 0.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 长度 &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; 数组，对 &lt;code&gt;func&lt;/code&gt; 数组中的相应函数接受的&lt;a href=&quot;../generated/numpy.dtype.num#numpy.dtype.num&quot;&gt; &lt;code&gt;numpy.dtype.num&lt;/code&gt; &lt;/a&gt;（仅内置）进行编码。例如，对于具有三个 &lt;code&gt;ntypes&lt;/code&gt; ，两个 &lt;code&gt;nin&lt;/code&gt; 和一个 &lt;code&gt;nout&lt;/code&gt; 的比较ufunc，其中第一个函数接受&lt;a href=&quot;../arrays.scalars#numpy.int32&quot;&gt; &lt;code&gt;numpy.int32&lt;/code&gt; &lt;/a&gt;，第二个&lt;a href=&quot;../arrays.scalars#numpy.int64&quot;&gt; &lt;code&gt;numpy.int64&lt;/code&gt; &lt;/a&gt;都返回&lt;a href=&quot;../arrays.scalars#numpy.bool_&quot;&gt; &lt;code&gt;numpy.bool_&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;types&lt;/code&gt; 将是 &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; &lt;code&gt;NPY_INT32&lt;/code&gt; }，因为NPY_INT32为5， &lt;code&gt;NPY_INT64&lt;/code&gt; 为7，而 &lt;code&gt;NPY_BOOL&lt;/code&gt; 为0。</target>
        </trans-unit>
        <trans-unit id="d96ebfedf4c36cbda183cd7a457b02a6edaca923" translate="yes" xml:space="preserve">
          <source>Length &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; array of &lt;code&gt;char&lt;/code&gt; encoding the &lt;a href=&quot;../generated/numpy.dtype.num#numpy.dtype.num&quot;&gt;&lt;code&gt;numpy.dtype.num&lt;/code&gt;&lt;/a&gt; (built-in only) that the corresponding function in the &lt;code&gt;func&lt;/code&gt; array accepts. For instance, for a comparison ufunc with three &lt;code&gt;ntypes&lt;/code&gt;, two &lt;code&gt;nin&lt;/code&gt; and one &lt;code&gt;nout&lt;/code&gt;, where the first function accepts &lt;code&gt;numpy.int32&lt;/code&gt; and the the second &lt;code&gt;numpy.int64&lt;/code&gt;, with both returning &lt;code&gt;numpy.bool_&lt;/code&gt;, &lt;code&gt;types&lt;/code&gt; would be &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; since &lt;code&gt;NPY_INT32&lt;/code&gt; is 5, &lt;code&gt;NPY_INT64&lt;/code&gt; is 7, and &lt;code&gt;NPY_BOOL&lt;/code&gt; is 0.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 长度 &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; 数组，对 &lt;code&gt;func&lt;/code&gt; 数组中的相应函数接受的&lt;a href=&quot;../generated/numpy.dtype.num#numpy.dtype.num&quot;&gt; &lt;code&gt;numpy.dtype.num&lt;/code&gt; &lt;/a&gt;（仅内置）进行编码。例如，对于具有三个 &lt;code&gt;ntypes&lt;/code&gt; ，两个 &lt;code&gt;nin&lt;/code&gt; 和一个 &lt;code&gt;nout&lt;/code&gt; 的比较ufunc，其中第一个函数接受 &lt;code&gt;numpy.int32&lt;/code&gt; ，第二个 &lt;code&gt;numpy.int64&lt;/code&gt; 都返回 &lt;code&gt;numpy.bool_&lt;/code&gt; ， &lt;code&gt;types&lt;/code&gt; 将是 &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; &lt;code&gt;NPY_INT32&lt;/code&gt; }，因为NPY_INT32为5， &lt;code&gt;NPY_INT64&lt;/code&gt; 为7，而 &lt;code&gt;NPY_BOOL&lt;/code&gt; 为0。</target>
        </trans-unit>
        <trans-unit id="a0ba05a259a8b34022dc6e1b217b0390cf104e0b" translate="yes" xml:space="preserve">
          <source>Length &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; array of &lt;code&gt;char&lt;/code&gt; encoding the &lt;a href=&quot;generated/numpy.dtype.num#numpy.dtype.num&quot;&gt;&lt;code&gt;numpy.dtype.num&lt;/code&gt;&lt;/a&gt; (built-in only) that the corresponding function in the &lt;code&gt;func&lt;/code&gt; array accepts. For instance, for a comparison ufunc with three &lt;code&gt;ntypes&lt;/code&gt;, two &lt;code&gt;nin&lt;/code&gt; and one &lt;code&gt;nout&lt;/code&gt;, where the first function accepts &lt;code&gt;numpy.int32&lt;/code&gt; and the the second &lt;code&gt;numpy.int64&lt;/code&gt;, with both returning &lt;code&gt;numpy.bool_&lt;/code&gt;, &lt;code&gt;types&lt;/code&gt; would be &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; since &lt;code&gt;NPY_INT32&lt;/code&gt; is 5, &lt;code&gt;NPY_INT64&lt;/code&gt; is 7, and &lt;code&gt;NPY_BOOL&lt;/code&gt; is 0.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 长度 &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; 数组，对 &lt;code&gt;func&lt;/code&gt; 数组中的相应函数接受的&lt;a href=&quot;generated/numpy.dtype.num#numpy.dtype.num&quot;&gt; &lt;code&gt;numpy.dtype.num&lt;/code&gt; &lt;/a&gt;（仅内置）进行编码。例如，对于具有三个 &lt;code&gt;ntypes&lt;/code&gt; ，两个 &lt;code&gt;nin&lt;/code&gt; 和一个 &lt;code&gt;nout&lt;/code&gt; 的比较ufunc，其中第一个函数接受 &lt;code&gt;numpy.int32&lt;/code&gt; ，第二个 &lt;code&gt;numpy.int64&lt;/code&gt; 都返回 &lt;code&gt;numpy.bool_&lt;/code&gt; ， &lt;code&gt;types&lt;/code&gt; 将是 &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; &lt;code&gt;NPY_INT32&lt;/code&gt; }，因为NPY_INT32为5， &lt;code&gt;NPY_INT64&lt;/code&gt; 为7，而 &lt;code&gt;NPY_BOOL&lt;/code&gt; 为0。</target>
        </trans-unit>
        <trans-unit id="e599dfd0500969f55b8c9d010461f8e1fcc41925" translate="yes" xml:space="preserve">
          <source>Length of each array element, in number of characters. Default is 1.</source>
          <target state="translated">每个数组元素的长度,以字符数为单位。默认为1。</target>
        </trans-unit>
        <trans-unit id="6dbef5ea0e7b53958b8a2d75b0863dd2996ea77a" translate="yes" xml:space="preserve">
          <source>Length of one array element in bytes.</source>
          <target state="translated">一个数组元素的长度,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="ebd0316d087a92fa193507d4dfe490f6483edcaf" translate="yes" xml:space="preserve">
          <source>Length of the inverse FFT, the number of points along transformation axis in the input to use. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used.</source>
          <target state="translated">逆FFT的长度，输入中沿变换轴使用的点数。如果 &lt;code&gt;n&lt;/code&gt; 小于输入的长度，则裁剪输入。如果较大，则输入将填充零。如果未指定 &lt;code&gt;n&lt;/code&gt; ，则使用输入沿由axis指定的 &lt;code&gt;axis&lt;/code&gt; 长度。</target>
        </trans-unit>
        <trans-unit id="c0386e146b5b66f11c90240baf5f54bbd4a84b7b" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2 + 1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is determined from the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">输出的转换轴的长度。对于 &lt;code&gt;n&lt;/code&gt; 个输出点，需要 &lt;code&gt;n//2 + 1&lt;/code&gt; 输入点。如果输入长于此长度，则将对其进行裁剪。如果比这短，则用零填充。如果未给出 &lt;code&gt;n&lt;/code&gt; ，则由输入沿沿着axis指定的 &lt;code&gt;axis&lt;/code&gt; 的长度确定。</target>
        </trans-unit>
        <trans-unit id="4f13f9612cce3a275a1186d10417cbf86f8f9b46" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2 + 1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is taken to be &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">输出的转换轴的长度。对于 &lt;code&gt;n&lt;/code&gt; 个输出点，需要 &lt;code&gt;n//2 + 1&lt;/code&gt; 输入点。如果输入长于此长度，则将对其进行裁剪。如果比这短，则用零填充。如果 &lt;code&gt;n&lt;/code&gt; 没有给出，它被取为 &lt;code&gt;2*(m-1)&lt;/code&gt; 其中， &lt;code&gt;m&lt;/code&gt; 是沿着由指定的轴输入的长度 &lt;code&gt;axis&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef669ab3a842002f9a1fb7bac5550ccceaa27247" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2+1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is determined from the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">输出的转换轴的长度。对于 &lt;code&gt;n&lt;/code&gt; 个输出点，需要 &lt;code&gt;n//2+1&lt;/code&gt; 输入点。如果输入长于此长度，则将对其进行裁剪。如果比这短，则用零填充。如果未给出 &lt;code&gt;n&lt;/code&gt; ，则由输入沿沿着axis指定的 &lt;code&gt;axis&lt;/code&gt; 的长度确定。</target>
        </trans-unit>
        <trans-unit id="1393d388a3302d35f0092d404b2ba089179672a7" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2+1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is taken to be &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">输出的转换轴的长度。对于 &lt;code&gt;n&lt;/code&gt; 个输出点，需要 &lt;code&gt;n//2+1&lt;/code&gt; 输入点。如果输入长于此长度，则将对其进行裁剪。如果比这短，则用零填充。如果 &lt;code&gt;n&lt;/code&gt; 没有给出，它被取为 &lt;code&gt;2*(m-1)&lt;/code&gt; 其中， &lt;code&gt;m&lt;/code&gt; 是沿着由指定的轴输入的长度 &lt;code&gt;axis&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9649fc48731a6d9a87c71452f8efbcb7f76b78d4" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used.</source>
          <target state="translated">输出的转换轴的长度。如果 &lt;code&gt;n&lt;/code&gt; 小于输入的长度，则裁剪输入。如果较大，则输入将填充零。如果未指定 &lt;code&gt;n&lt;/code&gt; ，则使用输入沿由axis指定的 &lt;code&gt;axis&lt;/code&gt; 长度。</target>
        </trans-unit>
        <trans-unit id="838e5e82eb9b3c833687dc387dbd43309bd32602" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used. See notes about padding issues.</source>
          <target state="translated">输出的转换轴的长度。如果 &lt;code&gt;n&lt;/code&gt; 小于输入的长度，则裁剪输入。如果较大，则输入将填充零。如果未指定 &lt;code&gt;n&lt;/code&gt; ，则使用输入沿由axis指定的 &lt;code&gt;axis&lt;/code&gt; 长度。请参阅有关填充问题的注释。</target>
        </trans-unit>
        <trans-unit id="20b7b6096b899f364abc1b0ab113ac1d88c95817" translate="yes" xml:space="preserve">
          <source>Lentner, Marvin, &amp;ldquo;Elementary Applied Statistics&amp;rdquo;, Bogden and Quigley, 1972.</source>
          <target state="translated">马文&amp;middot;伦特纳（Lentner，Marvin），&amp;ldquo;基本应用统计学&amp;rdquo;，博格登和奎格利，1972年。</target>
        </trans-unit>
        <trans-unit id="ad48dd4be642df433d10c28592cb939dc42a109f" translate="yes" xml:space="preserve">
          <source>Less Basic</source>
          <target state="translated">不太基本的</target>
        </trans-unit>
        <trans-unit id="e99e5b627f7ed42d45bd8cf2acdec386f4c6174c" translate="yes" xml:space="preserve">
          <source>Less robust estimator that that takes into account data variability and data size.</source>
          <target state="translated">考虑到数据变异性和数据大小的稳健性较低的估计器。</target>
        </trans-unit>
        <trans-unit id="ef5fe1edf37940bd463fee8eda068dc8d66b0f8a" translate="yes" xml:space="preserve">
          <source>Let</source>
          <target state="translated">Let</target>
        </trans-unit>
        <trans-unit id="a718bc5ba689b0611826e8a00c42db91a4cc33c1" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;M = A.ndim&lt;/code&gt;, &lt;code&gt;N = B.ndim&lt;/code&gt;. Then the result, &lt;code&gt;C&lt;/code&gt;, of &lt;code&gt;op.outer(A, B)&lt;/code&gt; is an array of dimension M + N such that:</source>
          <target state="translated">令 &lt;code&gt;M = A.ndim&lt;/code&gt; ， &lt;code&gt;N = B.ndim&lt;/code&gt; 。那么结果， &lt;code&gt;C&lt;/code&gt; ，的 &lt;code&gt;op.outer(A, B)&lt;/code&gt; 是尺寸M + N，使得阵列：</target>
        </trans-unit>
        <trans-unit id="c21492f5c1039f68826ed62d8fddcbe2ecf43d60" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;x.shape&lt;/code&gt; be (10,20,30,40,50) and suppose &lt;code&gt;ind_1&lt;/code&gt; and &lt;code&gt;ind_2&lt;/code&gt; can be broadcast to the shape (2,3,4). Then &lt;code&gt;x[:,ind_1,ind_2]&lt;/code&gt; has shape (10,2,3,4,40,50) because the (20,30)-shaped subspace from X has been replaced with the (2,3,4) subspace from the indices. However, &lt;code&gt;x[:,ind_1,:,ind_2]&lt;/code&gt; has shape (2,3,4,10,30,50) because there is no unambiguous place to drop in the indexing subspace, thus it is tacked-on to the beginning. It is always possible to use &lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt;&lt;code&gt;.transpose()&lt;/code&gt;&lt;/a&gt; to move the subspace anywhere desired. Note that this example cannot be replicated using &lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">令 &lt;code&gt;x.shape&lt;/code&gt; 为（10,20,30,40,50）并假定 &lt;code&gt;ind_1&lt;/code&gt; 和 &lt;code&gt;ind_2&lt;/code&gt; 可以广播为形状（2,3,4）。然后 &lt;code&gt;x[:,ind_1,ind_2]&lt;/code&gt; 形状为（10,2,3,4,40,50），因为X的（20,30）形状的子空间已被X的（2,3,4）子空间替换索引。但是， &lt;code&gt;x[:,ind_1,:,ind_2]&lt;/code&gt; 形状为（2,3,4,10,30,50），因为在索引子空间中没有明确的放置位置，因此将其固定在开始位置。始终可以使用&lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt; &lt;code&gt;.transpose()&lt;/code&gt; &lt;/a&gt;将子空间移动到所需的任何位置。请注意，无法使用&lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;复制此示例。</target>
        </trans-unit>
        <trans-unit id="c5de9d97cc2b507966a716e78a84203d66bead94" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s apply the steps of wrapping Fortran functions to Python one by one.</source>
          <target state="translated">让我们应用将Fortran函数一个接一个地包装到Python的步骤。</target>
        </trans-unit>
        <trans-unit id="91c6bd95be9fba42070138c60bc544f63be79cf2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s check that this is what we expected:</source>
          <target state="translated">让我们检查一下这是否是我们所期望的：</target>
        </trans-unit>
        <trans-unit id="d53ca7c39e959075c64a326e51c71e27bb307d6d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider a list of elements, &lt;code&gt;x&lt;/code&gt;, where values of -9999. represent missing data. We wish to compute the average value of the data and the vector of anomalies (deviations from the average):</source>
          <target state="translated">让我们考虑元素列表 &lt;code&gt;x&lt;/code&gt; ，其中-9999的值。代表缺少的数据。我们希望计算数据的平均值和异常向量（与平均值的偏差）：</target>
        </trans-unit>
        <trans-unit id="2913bcf139d6f47d02c0ac2f1be4a80f4a447c13" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider an array &lt;code&gt;d&lt;/code&gt; of floats between 0 and 1. We wish to compute the average of the values of &lt;code&gt;d&lt;/code&gt; while ignoring any data outside the range &lt;code&gt;[0.2, 0.9]&lt;/code&gt;:</source>
          <target state="translated">让我们考虑一个介于0和1之间的float数组 &lt;code&gt;d&lt;/code&gt; 。我们希望计算 &lt;code&gt;d&lt;/code&gt; 值的平均值，而忽略范围 &lt;code&gt;[0.2, 0.9]&lt;/code&gt; 之外的任何数据：</target>
        </trans-unit>
        <trans-unit id="ab1ea5de1d1447221ec240c0905b303173635736" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider an array &lt;code&gt;d&lt;/code&gt; of random floats between 0 and 1. We wish to compute the average of the values of &lt;code&gt;d&lt;/code&gt; while ignoring any data outside the range &lt;code&gt;[0.1, 0.9]&lt;/code&gt;:</source>
          <target state="translated">让我们考虑一个介于0和1之间的随机浮点数 &lt;code&gt;d&lt;/code&gt; 。我们希望计算 &lt;code&gt;d&lt;/code&gt; 值的平均值，而忽略范围 &lt;code&gt;[0.1, 0.9]&lt;/code&gt; 之外的任何数据：</target>
        </trans-unit>
        <trans-unit id="39281dff86138ded282e6212c34eb9cda8834f15" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do 20,000 trials of the model, and count the number that generate zero positive results.</source>
          <target state="translated">让我们对模型进行20,000次试验，并计算产生零阳性结果的数目。</target>
        </trans-unit>
        <trans-unit id="1b9b5278ac2afa5e3136c310885e0f8fd06a8be2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s explore a more advanced concept in numpy called broadcasting. The term broadcasting describes how numpy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is &amp;ldquo;broadcast&amp;rdquo; across the larger array so that they have compatible shapes. Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. It does this without making needless copies of data and usually leads to efficient algorithm implementations. There are also cases where broadcasting is a bad idea because it leads to inefficient use of memory that slows computation. This article provides a gentle introduction to broadcasting with numerous examples ranging from simple to involved. It also provides hints on when and when not to use broadcasting.</source>
          <target state="translated">让我们探索numpy中一个更高级的概念，称为广播。术语广播描述了numpy在算术运算期间如何处理具有不同形状的数组。受到某些约束，较小的阵列将在较大的阵列上&amp;ldquo;广播&amp;rdquo;，以使它们具有兼容的形状。广播提供了一种对数组操作进行矢量化的方法，从而使循环在C而不是Python中发生。它无需复制不必要的数据即可完成此操作，并且通常可以实现高效的算法实现。在某些情况下，广播不是一个好主意，因为广播会导致内存使用效率低下，从而减慢计算速度。本文通过简单到涉及的众多示例，对广播进行了详尽的介绍。它还提供有关何时以及何时不使用广播的提示。</target>
        </trans-unit>
        <trans-unit id="dc7e8c8d4a2c6c3d30346acb9b8c343d014c9595" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s explore the data inside this file for the first 14 days of records. To gather data from the &lt;code&gt;.csv&lt;/code&gt; file, we will use the &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;numpy.genfromtxt&lt;/code&gt;&lt;/a&gt; function, making sure we select only the columns with actual numbers instead of the first three columns which contain location data. We also skip the first 7 rows of this file, since they contain other data we are not interested in. Separately, we will extract the information about dates and location for this data.</source>
          <target state="translated">让我们探索记录的前14天中该文件中的数据。要从 &lt;code&gt;.csv&lt;/code&gt; 文件中收集数据，我们将使用&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;numpy.genfromtxt&lt;/code&gt; &lt;/a&gt;函数，确保仅选择具有实际数字的列，而不选择包含位置数据的前三列。我们还将跳过此文件的前7行，因为它们包含我们不感兴趣的其他数据。另外，我们将提取有关此数据的日期和位置的信息。</target>
        </trans-unit>
        <trans-unit id="f8b59fac8428f8c1733e5af773d6cbf876149f27" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at two examples we&amp;rsquo;ve seen before to see how they might be implemented using Cython. These examples were compiled into extension modules using Cython 0.21.1.</source>
          <target state="translated">让我们看一下我们之前看到的两个示例，看看如何使用Cython来实现它们。这些示例使用Cython 0.21.1编译到扩展模块中。</target>
        </trans-unit>
        <trans-unit id="ddfef2ee46e1e4256e10013c995a2b4530178cef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say the two integers were in fact 1 and 770. Because 770 = 256 * 3 + 2, the 4 bytes in memory would contain respectively: 0, 1, 3, 2. The bytes I have loaded from the file would have these contents:</source>
          <target state="translated">假设两个整数实际上是1和770。因为770 = 256 * 3 + 2，所以内存中的4个字节将分别包含：0、1、3、2。我从文件中加载的字节将具有以下内容：</target>
        </trans-unit>
        <trans-unit id="95938c655542a69cb7228f0ca9c4b635920085cc" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you create this array:</source>
          <target state="translated">假设您创建了以下数组：</target>
        </trans-unit>
        <trans-unit id="6b85caabf5e3eeb59af1ba993281156e38d2a215" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have this array:</source>
          <target state="translated">假设您有以下数组：</target>
        </trans-unit>
        <trans-unit id="d641e5a95c4dff41b3615beef8a44670fd8d8071" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this goes for our array:</source>
          <target state="translated">让我们看看这对我们的数组如何：</target>
        </trans-unit>
        <trans-unit id="663e98c256d28e922f69b08f25c6c3b896decad0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this works in practice with just one matrix first. Note that according to &lt;a href=&quot;https://en.wikipedia.org/wiki/Grayscale#Colorimetric_(perceptual_luminance-preserving)_conversion_to_grayscale&quot;&gt;colorimetry&lt;/a&gt;, it is possible to obtain a fairly reasonable grayscale version of our color image if we apply the formula</source>
          <target state="translated">让我们看看这是如何在实践中首先使用一个矩阵的。请注意，根据&lt;a href=&quot;https://en.wikipedia.org/wiki/Grayscale#Colorimetric_(perceptual_luminance-preserving)_conversion_to_grayscale&quot;&gt;比色法&lt;/a&gt;，如果应用以下公式，则可以获得彩色图像的相当合理的灰度版本</target>
        </trans-unit>
        <trans-unit id="ba48f83aec5246b87728fc21ac0f71842c7f7846" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with this array, called &amp;ldquo;a&amp;rdquo;</source>
          <target state="translated">让我们从这个叫做&amp;ldquo; a&amp;rdquo;的数组开始</target>
        </trans-unit>
        <trans-unit id="b44d168c64d4a917f033ec6ef3339ce41baeaa0e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try and see what the data looks like excluding the first row (data from the Hubei province in China) so we can look at the missing data more closely:</source>
          <target state="translated">让我们尝试看看排除第一行的数据是什么样的（来自中国湖北省的数据），以便我们可以更仔细地查看丢失的数据：</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="8be2fdf380d9d18148fd2ad94dc354c20768a219" translate="yes" xml:space="preserve">
          <source>License of NumPy</source>
          <target state="translated">NumPy的授权</target>
        </trans-unit>
        <trans-unit id="538c09161b8497f998404cafc34964ed3a445575" translate="yes" xml:space="preserve">
          <source>Licensed under the 3-clause BSD License.</source>
          <target state="translated">采用3-clause BSD授权。</target>
        </trans-unit>
        <trans-unit id="b0484b837c9aac64b9b4f0cbb8a409c60f826cd6" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#c.PyArray_DescrConverter&quot;&gt;&lt;code&gt;PyArray_DescrConverter&lt;/code&gt;&lt;/a&gt; except it aligns C-struct-like objects on word-boundaries as the compiler would.</source>
          <target state="translated">像&lt;a href=&quot;#c.PyArray_DescrConverter&quot;&gt; &lt;code&gt;PyArray_DescrConverter&lt;/code&gt; &lt;/a&gt;一样，除了它像编译器一样在字边界上对齐类似于C结构的对象。</target>
        </trans-unit>
        <trans-unit id="2bf9a983b58a3025088acd0d34cc34c35bed8eba" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#c.PyArray_DescrConverter2&quot;&gt;&lt;code&gt;PyArray_DescrConverter2&lt;/code&gt;&lt;/a&gt; except it aligns C-struct-like objects on word-boundaries as the compiler would.</source>
          <target state="translated">像&lt;a href=&quot;#c.PyArray_DescrConverter2&quot;&gt; &lt;code&gt;PyArray_DescrConverter2&lt;/code&gt; &lt;/a&gt;一样，除了它像编译器一样在字边界上对齐C结构对象。</target>
        </trans-unit>
        <trans-unit id="98e8d5db12d0ec6df75e2b77dc6308321b737245" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;generated/numpy.char.find#numpy.char.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">类似于&lt;a href=&quot;generated/numpy.char.find#numpy.char.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt;，但是在未找到子字符串时引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cac4055aba9315ef35a508ccbff6fd2fccbce50" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;generated/numpy.char.rfind#numpy.char.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">类似于&lt;a href=&quot;generated/numpy.char.rfind#numpy.char.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt;，但是在未找到子字符串 &lt;code&gt;sub&lt;/code&gt; 时引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bfb637364ad5b206ba50bed21f3142c132fe9341" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.find.html#numpy.chararray.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.find.html#numpy.chararray.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt;，但是在未找到子字符串时引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f8c624e10b2f68f4700be90af9ceef9f419abcf" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.rfind.html#numpy.chararray.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.rfind.html#numpy.chararray.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt;，但是在未找到子字符串 &lt;code&gt;sub&lt;/code&gt; 时引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a6f4f4130f44366224ec12564a5bb81c67b452b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.char.chararray.find#numpy.char.chararray.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">类似于&lt;a href=&quot;numpy.char.chararray.find#numpy.char.chararray.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt;，但是在未找到子字符串时引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7dc3c1cf09460e0fca6be797b8cde3f51564be9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.char.chararray.rfind#numpy.char.chararray.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">类似于&lt;a href=&quot;numpy.char.chararray.rfind#numpy.char.chararray.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt;，但是在未找到子字符串 &lt;code&gt;sub&lt;/code&gt; 时引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74d7df04563822c7d8ad24dbe267870b77fbb351" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.char.find#numpy.char.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">类似于&lt;a href=&quot;numpy.char.find#numpy.char.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt;，但是在未找到子字符串时引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b35ea9f95fe9a083c883dcd6041e1ed2b46d8192" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.char.rfind#numpy.char.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">类似于&lt;a href=&quot;numpy.char.rfind#numpy.char.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt;，但是在未找到子字符串 &lt;code&gt;sub&lt;/code&gt; 时引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1381300ae7e04647799c4d29476d81d2674e1d00" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.chararray.find#numpy.chararray.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">类似于&lt;a href=&quot;numpy.chararray.find#numpy.chararray.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt;，但是在未找到子字符串时引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6baf9238888e49aa859d8fb862f39242936cfbf" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.chararray.rfind#numpy.chararray.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">类似于&lt;a href=&quot;numpy.chararray.rfind#numpy.chararray.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt;，但是在未找到子字符串 &lt;code&gt;sub&lt;/code&gt; 时引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f6786bbc0e6826ccf967ce3d26832cec08da525" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;catch_warnings&lt;/code&gt; this context manager is not threadsafe.</source>
          <target state="translated">像 &lt;code&gt;catch_warnings&lt;/code&gt; 一样，此上下文管理器也不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="4988e06267fc3ad462b8b1372828e98aa6abe4ae" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;recfromtxt&lt;/code&gt;, but with a default &lt;code&gt;delimiter=&quot;,&quot;&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;recfromtxt&lt;/code&gt; ，但具有默认的 &lt;code&gt;delimiter=&quot;,&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0fa83334e9080fab8905202d2a0b49831c3f225" translate="yes" xml:space="preserve">
          <source>Like for other types, NumPy includes a typedef npy_half for the 16 bit float. Unlike for most of the other types, you cannot use this as a normal type in C, since it is a typedef for npy_uint16. For example, 1.0 looks like 0x3c00 to C, and if you do an equality comparison between the different signed zeros, you will get -0.0 != 0.0 (0x8000 != 0x0000), which is incorrect.</source>
          <target state="translated">和其他类型一样,NumPy包含了一个类型定义npy_half,用于16位浮点。与大多数其他类型不同的是,在C语言中你不能将其作为普通类型使用,因为它是npy_uint16的类型定义。例如,1.0在C语言中看起来像0x3c00,如果你在不同的有符号的0之间做一个等价比较,你将得到-0.0 !=0.0 (0x8000 !=0x0000),这是不正确的。</target>
        </trans-unit>
        <trans-unit id="e112999c2cd378720fa09f5bf6d3cb8761f7e014" translate="yes" xml:space="preserve">
          <source>Like with some other special methods in python, such as &lt;code&gt;__hash__&lt;/code&gt; and &lt;code&gt;__iter__&lt;/code&gt;, it is possible to indicate that your class does &lt;em&gt;not&lt;/em&gt; support ufuncs by setting &lt;code&gt;__array_ufunc__ = None&lt;/code&gt;. Ufuncs always raise &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; when called on an object that sets &lt;code&gt;__array_ufunc__ = None&lt;/code&gt;.</source>
          <target state="translated">像Python中其他一些特殊的方法，如 &lt;code&gt;__hash__&lt;/code&gt; 和 &lt;code&gt;__iter__&lt;/code&gt; ，有可能表明你的类并&lt;em&gt;没有&lt;/em&gt;通过设置支持ufuncs &lt;code&gt;__array_ufunc__ = None&lt;/code&gt; 。当对设置 &lt;code&gt;__array_ufunc__ = None&lt;/code&gt; 的对象进行调用时，Ufunc始终会引发&lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4aa7900482808a9df749231293505b57d3e3de9c" translate="yes" xml:space="preserve">
          <source>Likewise, ellipsis can be specified by code by using the Ellipsis object:</source>
          <target state="translated">同样,可以通过代码使用Ellipsis对象来指定省略号。</target>
        </trans-unit>
        <trans-unit id="3297842e50729fb77f4f0545de2f9ff7aa3909b6" translate="yes" xml:space="preserve">
          <source>Likewise, slicing can be combined with broadcasted boolean indices:</source>
          <target state="translated">同样,切片也可以与广播的布尔指数相结合。</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="aed0f783a12a4ca0992442cfbd711f6845a91b7b" translate="yes" xml:space="preserve">
          <source>Limpert, E., Stahel, W. A., and Abbt, M., &amp;ldquo;Log-normal Distributions across the Sciences: Keys and Clues,&amp;rdquo; BioScience, Vol. 51, No. 5, May, 2001. &lt;a href=&quot;https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf&quot;&gt;https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf&lt;/a&gt;</source>
          <target state="translated">Limpert，E.，Stahel，WA和Abbt，M。，&amp;ldquo;整个科学的对数正态分布：键和线索&amp;rdquo;，《生物科学》，第1卷。51，第5号，2001年5月&lt;a href=&quot;https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf&quot;&gt;.https：//stat.ethz.ch/~stahel/lognormal/bioscience.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2c6327e28944d450d23eb12c3f0eb10b95ac744a" translate="yes" xml:space="preserve">
          <source>LinAlgError</source>
          <target state="translated">LinAlgError</target>
        </trans-unit>
        <trans-unit id="fbfdf4025591ea0589baa96d7f54fd5d7f0a5dbd" translate="yes" xml:space="preserve">
          <source>Line breaks are not included in the resulting list unless keepends is given and true.</source>
          <target state="translated">除非给定了keepends且为真,否则换行符不会包含在结果列表中。</target>
        </trans-unit>
        <trans-unit id="fd8f1853d29d8157d704e36102bd70d85ec315bd" translate="yes" xml:space="preserve">
          <source>Line spacing and indentation are significant and should be carefully followed.</source>
          <target state="translated">行距和缩进都很重要,应认真遵守。</target>
        </trans-unit>
        <trans-unit id="fcb739908d0a50031f680d3b4fffc6749c4002d3" translate="yes" xml:space="preserve">
          <source>Linear Algebra</source>
          <target state="translated">线性代数</target>
        </trans-unit>
        <trans-unit id="4c2d7925777b262f78b0ed1ceeb1f07eef61acc7" translate="yes" xml:space="preserve">
          <source>Linear Algebra Equivalents</source>
          <target state="translated">线性代数等价物</target>
        </trans-unit>
        <trans-unit id="c77bb2c05a2dcf0461045da9b6109d509594fc9a" translate="yes" xml:space="preserve">
          <source>Linear Algebra libraries</source>
          <target state="translated">线性代数库</target>
        </trans-unit>
        <trans-unit id="06d74260ba46e8ed76ff22dda956f18a7b66203c" translate="yes" xml:space="preserve">
          <source>Linear algebra</source>
          <target state="translated">线性代数</target>
        </trans-unit>
        <trans-unit id="ef4be3efd16d5b211ab89b5efbf030ca1bafba61" translate="yes" xml:space="preserve">
          <source>Linear algebra (&lt;code&gt;numpy.linalg&lt;/code&gt;)</source>
          <target state="translated">线性代数（ &lt;code&gt;numpy.linalg&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e2be6b18cf91c04a7b6c400bd00876f94a2389cb" translate="yes" xml:space="preserve">
          <source>Linear algebra (numpy.linalg)</source>
          <target state="translated">线性代数 (numpy.linalg)</target>
        </trans-unit>
        <trans-unit id="1e4376126e3fa3a9245e1b149d174565d532409e" translate="yes" xml:space="preserve">
          <source>Linear algebra equivalents</source>
          <target state="translated">线性代数等价物</target>
        </trans-unit>
        <trans-unit id="b624aab78757a9b353883b1449d6df824049976b" translate="yes" xml:space="preserve">
          <source>Linear algebra on several matrices at once</source>
          <target state="translated">在多个矩阵上同时进行线性代数运算。</target>
        </trans-unit>
        <trans-unit id="991cbbcb4b1ecb2172a95ff800353dc3c4b54edd" translate="yes" xml:space="preserve">
          <source>Linear map parameters between domains.</source>
          <target state="translated">域间线性映射参数。</target>
        </trans-unit>
        <trans-unit id="eb36eb210c8667bae908d8f0d19ef3098c4c1701" translate="yes" xml:space="preserve">
          <source>Link extension module with &amp;lt;resource&amp;gt; as defined by &lt;code&gt;numpy_distutils/system_info.py&lt;/code&gt;. E.g. to link with optimized LAPACK libraries (vecLib on MacOSX, ATLAS elsewhere), use &lt;code&gt;--link-lapack_opt&lt;/code&gt;. See also &lt;code&gt;--help-link&lt;/code&gt; switch.</source>
          <target state="translated">使用 &lt;code&gt;numpy_distutils/system_info.py&lt;/code&gt; 定义的&amp;lt;resource&amp;gt;链接扩展模块。例如，要链接优化的LAPACK库（在MacOSX上为vecLib，在其他地方为ATLAS），请使用 &lt;code&gt;--link-lapack_opt&lt;/code&gt; 。另请参阅 &lt;code&gt;--help-link&lt;/code&gt; 开关。</target>
        </trans-unit>
        <trans-unit id="26958b7c786c621d84d02830a0b14f77df5b2d9e" translate="yes" xml:space="preserve">
          <source>Linking against the core math library in an extension</source>
          <target state="translated">在扩展中针对核心数学库进行链接。</target>
        </trans-unit>
        <trans-unit id="f9ddb8c3deec44cd98e047bb68bdaf188f3b72f8" translate="yes" xml:space="preserve">
          <source>Linking your repository to the upstream repo</source>
          <target state="translated">将你的仓库链接到上游仓库</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="2d54756ca8573af092113bb3435c0903eeb35dd6" translate="yes" xml:space="preserve">
          <source>Links : If you need to include hyperlinks in your docstring, note that some docstring sections are not parsed as standard reST, and in these sections, numpydoc may become confused by hyperlink targets such as:</source>
          <target state="translated">链接:如果你需要在你的docstring中包含超链接,请注意,有些docstring的部分不是以标准的reST来解析的,在这些部分,numpydoc可能会被超链接目标所迷惑,比如。</target>
        </trans-unit>
        <trans-unit id="518ed7ba947b32b000717c46a46d61dd856bd112" translate="yes" xml:space="preserve">
          <source>Linus Torvalds on &lt;a href=&quot;http://kerneltrap.org/Linux/Git_Management&quot;&gt;git management&lt;/a&gt;</source>
          <target state="translated">Linus Torvalds在&lt;a href=&quot;http://kerneltrap.org/Linux/Git_Management&quot;&gt;git管理上&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6cf86d6b89c993ef56513045443e84088de16799" translate="yes" xml:space="preserve">
          <source>Linus Torvalds on &lt;a href=&quot;https://web.archive.org/web/20090328043540/http://kerneltrap.org/Linux/Git_Management&quot;&gt;git management&lt;/a&gt;</source>
          <target state="translated">Linus Torvalds在&lt;a href=&quot;https://web.archive.org/web/20090328043540/http://kerneltrap.org/Linux/Git_Management&quot;&gt;git管理上&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="965d93d3a9947030cc756b2db0fcacc76437a993" translate="yes" xml:space="preserve">
          <source>Linus Torvalds on &lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;linux git workflow&lt;/a&gt; . Summary; use the git tools to make the history of your edits as clean as possible; merge from upstream edits as little as possible in branches where you are doing active development.</source>
          <target state="translated">&lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;Linux git工作流&lt;/a&gt;上的Linus Torvalds 。概括; 使用git工具使您的编辑历史尽可能清晰；在进行主动开发的分支中，尽可能少地从上游编辑中合并。</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="d1400c37d080d60eab76dbcb84834f7292aae696" translate="yes" xml:space="preserve">
          <source>Linux timings used Ubuntu 18.04 and GCC 7.4. Windows timings were made on Windows 10 using Microsoft C/C++ Optimizing Compiler Version 19 (Visual Studio 2015). All timings were produced on a i5-3570 processor.</source>
          <target state="translated">Linux定时使用Ubuntu 18.04和GCC 7.4。Windows定时是在Windows 10上使用Microsoft C/C++优化编译器19版(Visual Studio 2015)制作的。所有计时都是在i5-3570处理器上制作的。</target>
        </trans-unit>
        <trans-unit id="56d0cc5c207ff297b983e9b52ef59aa241b28b67" translate="yes" xml:space="preserve">
          <source>Linux timings used Ubuntu 18.04 and GCC 7.4. Windows timings were made on Windows 10 using Microsoft C/C++ Optimizing Compiler Version 19 (Visual Studio 2015). All timings were produced on an i5-3570 processor.</source>
          <target state="translated">Linux定时使用Ubuntu 18.04和GCC 7.4。Windows定时是在Windows 10上使用Microsoft C/C++优化编译器19版(Visual Studio 2015)制作的。所有计时都是在i5-3570处理器上制作的。</target>
        </trans-unit>
        <trans-unit id="87860891be4cddda593f0fa03126f25fb568db9f" translate="yes" xml:space="preserve">
          <source>Linux: 32-bit and 64-bit Manylinux1 wheels built using travis-ci.</source>
          <target state="translated">Linux。32位和64位Manylinux1轮子使用travis-ci构建。</target>
        </trans-unit>
        <trans-unit id="97d9791ab8737c4211f3e78630cca56638f02eb1" translate="yes" xml:space="preserve">
          <source>List available Fortran compilers.</source>
          <target state="translated">列出可用的Fortran编译器。</target>
        </trans-unit>
        <trans-unit id="eb5d7118db68e7b8996c3d0844e8e2d779102b13" translate="yes" xml:space="preserve">
          <source>List of array-like objects (such as lists, tuples, and ndarrays).</source>
          <target state="translated">类似数组的对象列表(如list、tuple和ndarrays)。</target>
        </trans-unit>
        <trans-unit id="decb4e37dac06b0a04b2b5a1ce16d06dbaf9430d" translate="yes" xml:space="preserve">
          <source>List of maximum degrees of the form [x_deg, y_deg, z_deg].</source>
          <target state="translated">表格[x_deg,y_deg,z_deg]的最大度数列表。</target>
        </trans-unit>
        <trans-unit id="16b40ddc35115642a1ebd2b343c063499d9e736a" translate="yes" xml:space="preserve">
          <source>List of maximum degrees of the form [x_deg, y_deg].</source>
          <target state="translated">表格[x_deg,y_deg]的最大度数列表。</target>
        </trans-unit>
        <trans-unit id="3946ce7ee00307be1e56a351d33b3682868445a4" translate="yes" xml:space="preserve">
          <source>List of roots.</source>
          <target state="translated">根的清单。</target>
        </trans-unit>
        <trans-unit id="4e5a894ae66af5e5eb828b13d596e0e9298ff835" translate="yes" xml:space="preserve">
          <source>List of source file locations relative to the top directory of the package.</source>
          <target state="translated">相对于软件包顶部目录的源文件位置列表。</target>
        </trans-unit>
        <trans-unit id="2c7afb1b33d8f0bf102c5fdc5f3bfa27a81be1cb" translate="yes" xml:space="preserve">
          <source>List of the library&amp;rsquo;s source files. See &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_library&quot;&gt;&lt;code&gt;add_library&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">库的源文件列表。有关详细信息，请参见&lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_library&quot;&gt; &lt;code&gt;add_library&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5754e63d6ae44ac265c0defe49c460674a2539b7" translate="yes" xml:space="preserve">
          <source>List of the most important terms</source>
          <target state="translated">最重要的术语清单</target>
        </trans-unit>
        <trans-unit id="6519aa721c25f67c763afcfac03293aba9cab8a8" translate="yes" xml:space="preserve">
          <source>List of the sources. The list of sources may contain functions (called source generators) which must take an extension instance and a build directory as inputs and return a source file or list of source files or None. If None is returned then no sources are generated. If the Extension instance has no sources after processing all source generators, then no extension module is built.</source>
          <target state="translated">源文件列表。源文件列表可以包含函数(称为源文件生成器),这些函数必须以扩展实例和构建目录作为输入,并返回一个源文件或源文件列表或None。如果返回None,则不生成源文件。如果Extension实例在处理完所有源文件生成器后没有源文件,那么就不会构建扩展模块。</target>
        </trans-unit>
        <trans-unit id="2485a7cc99c4617bf66ce59e5b75a2d0c1ccfb4b" translate="yes" xml:space="preserve">
          <source>List system resources found by &lt;code&gt;numpy_distutils/system_info.py&lt;/code&gt;. For example, try &lt;code&gt;f2py --help-link lapack_opt&lt;/code&gt;.</source>
          <target state="translated">列出 &lt;code&gt;numpy_distutils/system_info.py&lt;/code&gt; 找到的系统资源。例如，尝试 &lt;code&gt;f2py --help-link lapack_opt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50800b4f18e2a927baac61501f7e23170e957be0" translate="yes" xml:space="preserve">
          <source>List with any extra arguments to pass to nosetests.</source>
          <target state="translated">含有任何额外参数的列表传递给nosetests。</target>
        </trans-unit>
        <trans-unit id="70836ea6cfbd010e5c69675c6ed9768657e90763" translate="yes" xml:space="preserve">
          <source>Literal string representation.</source>
          <target state="translated">字符串表示。</target>
        </trans-unit>
        <trans-unit id="d40f76f0ffb9625ea51482e91de953541d5c3201" translate="yes" xml:space="preserve">
          <source>Load MATLAB variables saved to the file &lt;code&gt;data.mat&lt;/code&gt;. (Note: When saving arrays to &lt;code&gt;data.mat&lt;/code&gt; in MATLAB/Octave, use a recent binary format. &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.loadmat.html#scipy.io.loadmat&quot;&gt;&lt;code&gt;scipy.io.loadmat&lt;/code&gt;&lt;/a&gt; will create a dictionary with the saved arrays and further information.)</source>
          <target state="translated">将保存的MATLAB变量加载到文件 &lt;code&gt;data.mat&lt;/code&gt; 中。（注意：在MATLAB / Octave &lt;code&gt;data.mat&lt;/code&gt; 数组保存到data.mat时，请使用最新的二进制格式&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.loadmat.html#scipy.io.loadmat&quot;&gt; &lt;code&gt;scipy.io.loadmat&lt;/code&gt; &lt;/a&gt;将使用保存的数组和更多信息创建字典。）</target>
        </trans-unit>
        <trans-unit id="d75a54184aa53b5be4e832c635455d88f3cdc5e6" translate="yes" xml:space="preserve">
          <source>Load a pickle from the current string.</source>
          <target state="translated">从当前字符串中加载一个泡菜。</target>
        </trans-unit>
        <trans-unit id="3a504cdc1122f04029c4d408c355532536995f45" translate="yes" xml:space="preserve">
          <source>Load arrays or pickled objects from &lt;code&gt;.npy&lt;/code&gt;, &lt;code&gt;.npz&lt;/code&gt; or pickled files.</source>
          <target state="translated">从 &lt;code&gt;.npy&lt;/code&gt; ， &lt;code&gt;.npz&lt;/code&gt; 或腌制的文件中加载数组或腌制的对象。</target>
        </trans-unit>
        <trans-unit id="9d2a30e3c587d0309a2b15e920e2381e52d3b73a" translate="yes" xml:space="preserve">
          <source>Load data from a text file, with missing values handled as specified.</source>
          <target state="translated">从文本文件加载数据,缺失值按指定处理。</target>
        </trans-unit>
        <trans-unit id="671e399a95a295b1b112f2ec88bde3aa682ce01d" translate="yes" xml:space="preserve">
          <source>Load data from a text file.</source>
          <target state="translated">从文本文件加载数据。</target>
        </trans-unit>
        <trans-unit id="ede7696890a000813048b7b45d0ec4e8eaa41ac3" translate="yes" xml:space="preserve">
          <source>Load data with missing values handled as specified.</source>
          <target state="translated">加载数据的缺失值按指定处理。</target>
        </trans-unit>
        <trans-unit id="0fb4575d68b4fb0f498f6ef6cd58ad29dfef99ec" translate="yes" xml:space="preserve">
          <source>Load the files created by savez_compressed.</source>
          <target state="translated">装入由savez_compressed创建的文件。</target>
        </trans-unit>
        <trans-unit id="00e2276e50083512489893c74a3667bfb2f8d261" translate="yes" xml:space="preserve">
          <source>Load the memmap and verify data was stored:</source>
          <target state="translated">加载memmap并验证数据是否被存储。</target>
        </trans-unit>
        <trans-unit id="f5bde0422e688546d3fcbda903a1675bdef859be" translate="yes" xml:space="preserve">
          <source>Load the shared library.</source>
          <target state="translated">加载共享库。</target>
        </trans-unit>
        <trans-unit id="4f1b35f9beeb82ff23b55bdd7e4bccbaa09655da" translate="yes" xml:space="preserve">
          <source>Loading files that contain object arrays uses the &lt;code&gt;pickle&lt;/code&gt; module, which is not secure against erroneous or maliciously constructed data. Consider passing &lt;code&gt;allow_pickle=False&lt;/code&gt; to load data that is known not to contain object arrays for the safer handling of untrusted sources.</source>
          <target state="translated">加载包含对象数组的文件时，会使用 &lt;code&gt;pickle&lt;/code&gt; 模块，该模块对于错误或恶意构建的数据并不安全。考虑传递 &lt;code&gt;allow_pickle=False&lt;/code&gt; 来加载已知不包含对象数组的数据，以便更安全地处理不受信任的源。</target>
        </trans-unit>
        <trans-unit id="dc43ff557f7299b63c00a5f98241bc55534a0318" translate="yes" xml:space="preserve">
          <source>Loading the shared library</source>
          <target state="translated">加载共享库</target>
        </trans-unit>
        <trans-unit id="dcd21227c7ed1f7628c4569c3c3b1f97f5e4a3e0" translate="yes" xml:space="preserve">
          <source>Local file path or URL to open.</source>
          <target state="translated">本地文件路径或打开的URL。</target>
        </trans-unit>
        <trans-unit id="399e1ff0ce348a172dad0b088afb4891c55b0357" translate="yes" xml:space="preserve">
          <source>Lock instance that is shared so that the same BitGenerator can be used in multiple Generators without corrupting the state. Code that generates values from a bit generator should hold the bit generator&amp;rsquo;s lock.</source>
          <target state="translated">共享的锁实例，以便同一BitGenerator可以在多个Generator中使用，而不会破坏状态。从位生成器生成值的代码应持有位生成器的锁。</target>
        </trans-unit>
        <trans-unit id="2d415fb960b72005c6491287e9aedba95abd331c" translate="yes" xml:space="preserve">
          <source>Lock instance that is shared so that the same bit git generator can be used in multiple Generators without corrupting the state. Code that generates values from a bit generator should hold the bit generator&amp;rsquo;s lock.</source>
          <target state="translated">共享的锁实例，以便同一位git generator可以在多个Generator中使用，而不会破坏状态。从位生成器生成值的代码应持有位生成器的锁。</target>
        </trans-unit>
        <trans-unit id="107cbe58cd70b9b9564b7a980ec9a134ba83ff37" translate="yes" xml:space="preserve">
          <source>Log error message:</source>
          <target state="translated">记录错误信息。</target>
        </trans-unit>
        <trans-unit id="4eb269913863abecf02addc638fee893d2c7588f" translate="yes" xml:space="preserve">
          <source>Log into your &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; account.</source>
          <target state="translated">登录到您的&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;帐户。</target>
        </trans-unit>
        <trans-unit id="68562d9439407512f691d4a23d6d20e4c6852435" translate="yes" xml:space="preserve">
          <source>Log into your GitHub account.</source>
          <target state="translated">登录你的GitHub账户。</target>
        </trans-unit>
        <trans-unit id="5b18e27bd081f5e88f5467d9d05245be1522ecbd" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;10**z = x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">对数是一个多值函数：每个 &lt;code&gt;x&lt;/code&gt; 都有无限个 &lt;code&gt;z&lt;/code&gt; ，使得 &lt;code&gt;10**z = x&lt;/code&gt; 。惯例是返回虚部在 &lt;code&gt;[-pi, pi]&lt;/code&gt; 的 &lt;code&gt;z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a52fe88f1d34f63b32537a63132c16ed59948f4" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;2**z = x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">对数是一个多值函数：每个 &lt;code&gt;x&lt;/code&gt; 都有无限个 &lt;code&gt;z&lt;/code&gt; ，使得 &lt;code&gt;2**z = x&lt;/code&gt; 。惯例是返回虚部在 &lt;code&gt;[-pi, pi]&lt;/code&gt; 的 &lt;code&gt;z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04517496328a3b4c1d39612790fc59d3b950de57" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;exp(z) = 1 + x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">对数是一个多值函数：每个 &lt;code&gt;x&lt;/code&gt; 都有无限多个 &lt;code&gt;z&lt;/code&gt; ，使得 &lt;code&gt;exp(z) = 1 + x&lt;/code&gt; 。惯例是返回虚部在 &lt;code&gt;[-pi, pi]&lt;/code&gt; 的 &lt;code&gt;z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f044358a356b12f8f04d65ec46fba2c711db9ca" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;exp(z) = x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">对数是一个多值函数：每个 &lt;code&gt;x&lt;/code&gt; 都有无限个 &lt;code&gt;z&lt;/code&gt; ，使得 &lt;code&gt;exp(z) = x&lt;/code&gt; 。惯例是返回虚部在 &lt;code&gt;[-pi, pi]&lt;/code&gt; 的 &lt;code&gt;z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="166930005429709b3b373125970bc9f001b57f22" translate="yes" xml:space="preserve">
          <source>Logarithm of &lt;code&gt;exp(x1) + exp(x2)&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;exp(x1) + exp(x2)&lt;/code&gt; 对数。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="0df50307c119146d5dc714638f54a5eccd592099" translate="yes" xml:space="preserve">
          <source>Logarithm of the sum of exponentiations of inputs in base 2.</source>
          <target state="translated">基数2的投入指数之和的对数。</target>
        </trans-unit>
        <trans-unit id="3a29b9b1054fef950824734dd96565e57e322c96" translate="yes" xml:space="preserve">
          <source>Logarithm of the sum of exponentiations of the inputs in base-2.</source>
          <target state="translated">基数2中的投入指数之和的对数。</target>
        </trans-unit>
        <trans-unit id="273c857a62012f5708232560c688d9c8f7c28ba5" translate="yes" xml:space="preserve">
          <source>Logarithm of the sum of exponentiations of the inputs.</source>
          <target state="translated">输入的指数之和的对数。</target>
        </trans-unit>
        <trans-unit id="e7b8fad3893b278189df782f86ba4d32084ced17" translate="yes" xml:space="preserve">
          <source>Logarithm to base 10 of the Euler constant (</source>
          <target state="translated">欧拉常数的10基对数(</target>
        </trans-unit>
        <trans-unit id="80963c1ddcee26932e512e1ef164c3f919eb6773" translate="yes" xml:space="preserve">
          <source>Logarithm to base 2 of the Euler constant (</source>
          <target state="translated">欧拉常数的基数2的对数(</target>
        </trans-unit>
        <trans-unit id="dca3308567585813d8c4516ae0b5df7d6382aa24" translate="yes" xml:space="preserve">
          <source>Logic functions</source>
          <target state="translated">逻辑功能</target>
        </trans-unit>
        <trans-unit id="acdcdb17721480a7efeeb33b0138faad218dbf31" translate="yes" xml:space="preserve">
          <source>Logical NOT is applied to the elements of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">逻辑非应用于 &lt;code&gt;x&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="98ddc2178009c7731c8ae53ab405983c8f38c802" translate="yes" xml:space="preserve">
          <source>Logical OR is applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">逻辑或应用于 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 的元素。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="f5bd72920a8d92e6480e74978ed9235cd1d3ad95" translate="yes" xml:space="preserve">
          <source>Logical XOR is applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">逻辑XOR应用于 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 的元素。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="ab411408fbd29ad68b53700b2e7826c03e6703f0" translate="yes" xml:space="preserve">
          <source>Logical operations</source>
          <target state="translated">逻辑运算</target>
        </trans-unit>
        <trans-unit id="f9360627c5984485d4c34bec86c9dfebc0835bd0" translate="yes" xml:space="preserve">
          <source>Logspace is equivalent to the code</source>
          <target state="translated">日志空间相当于以下代码</target>
        </trans-unit>
        <trans-unit id="05614c0010510d48dea6823d792acc33ba6daeb2" translate="yes" xml:space="preserve">
          <source>Long answer</source>
          <target state="translated">长答案</target>
        </trans-unit>
        <trans-unit id="cfff3eff895eee45ffb53c164dd9129e264c6241" translate="yes" xml:space="preserve">
          <source>Long arrays can be summarised:</source>
          <target state="translated">可以对长数组进行总结。</target>
        </trans-unit>
        <trans-unit id="57c8d49665e2668f2033281dda387f2cad2ecde8" translate="yes" xml:space="preserve">
          <source>Look it over</source>
          <target state="translated">仔细看看</target>
        </trans-unit>
        <trans-unit id="985f144664017939330de9e8e7013e16b8babbcb" translate="yes" xml:space="preserve">
          <source>Looking at the data, here&amp;rsquo;s what we find: there is a period with &lt;strong&gt;missing data&lt;/strong&gt;:</source>
          <target state="translated">查看数据，这是我们发现的内容：有一段时间&lt;strong&gt;缺少数据&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="8677f57b867596167599f15cd53463b229e648c6" translate="yes" xml:space="preserve">
          <source>Lots of learning overhead:</source>
          <target state="translated">大量的学习开销。</target>
        </trans-unit>
        <trans-unit id="dcabfd17cd19c7e1ebdad9125ee467aec3f27671" translate="yes" xml:space="preserve">
          <source>Low-level floating point manipulation</source>
          <target state="translated">低级浮点操作</target>
        </trans-unit>
        <trans-unit id="20bd4a379661919ac01507844a8735e9e7029b21" translate="yes" xml:space="preserve">
          <source>Low-level function which converts a 16-bit half-precision float into a 32-bit single-precision float, stored as a uint32.</source>
          <target state="translated">低级函数,将16位半精度浮点数转换为32位单精度浮点数,存储为uint32。</target>
        </trans-unit>
        <trans-unit id="e475f5fc68e395b56437c0cdf65cca2d5aa08147" translate="yes" xml:space="preserve">
          <source>Low-level function which converts a 16-bit half-precision float into a 64-bit double-precision float, stored as a uint64.</source>
          <target state="translated">低级函数,将16位半精度浮点数转换为64位双精度浮点数,存储为uint64。</target>
        </trans-unit>
        <trans-unit id="96bea3d344730e551ebce7080101c44ce0f90690" translate="yes" xml:space="preserve">
          <source>Low-level function which converts a 32-bit single-precision float, stored as a uint32, into a 16-bit half-precision float.</source>
          <target state="translated">低级函数,将存储为uint32的32位单精度浮点数转换为16位半精度浮点数。</target>
        </trans-unit>
        <trans-unit id="ff645f12bfda22b17ebed86ab48b65f035e74b8d" translate="yes" xml:space="preserve">
          <source>Low-level function which converts a 64-bit double-precision float, stored as a uint64, into a 16-bit half-precision float.</source>
          <target state="translated">低级函数,它将一个64位的双精度浮点数(存储为uint64)转换为一个16位的半精度浮点数。</target>
        </trans-unit>
        <trans-unit id="352aca4d37f9444dfec5d82c349a1052e7d84651" translate="yes" xml:space="preserve">
          <source>Lower boundary of the output interval. All values generated will be greater than or equal to low. The default value is 0.</source>
          <target state="translated">输出区间的下界。所有生成的值都将大于或等于低。默认值为0。</target>
        </trans-unit>
        <trans-unit id="4bf35d3bbb54e1377461549a2939f7d0b3e69b61" translate="yes" xml:space="preserve">
          <source>Lower limit.</source>
          <target state="translated">下限:</target>
        </trans-unit>
        <trans-unit id="7de9677832dcede5ad99fb5a80acb920b62eed43" translate="yes" xml:space="preserve">
          <source>Lower triangle of &lt;code&gt;m&lt;/code&gt;, of same shape and data-type as &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; 的下三角形，其形状和数据类型与 &lt;code&gt;m&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="2daaaf38d1f5ab90fa4560a3de14f582045a565c" translate="yes" xml:space="preserve">
          <source>Lower triangle of an array.</source>
          <target state="translated">阵列的下角三角形。</target>
        </trans-unit>
        <trans-unit id="83251c72d4ba0cc804bd754996e879943acb761e" translate="yes" xml:space="preserve">
          <source>Lowest (signed) integer to be drawn from the distribution (unless &lt;code&gt;high=None&lt;/code&gt;, in which case this parameter is the &lt;em&gt;highest&lt;/em&gt; such integer).</source>
          <target state="translated">从分布中得出的最低（带符号）整数（除非 &lt;code&gt;high=None&lt;/code&gt; ，在这种情况下此参数是&lt;em&gt;最高的&lt;/em&gt;整数）。</target>
        </trans-unit>
        <trans-unit id="b68fc5877ebf9c93e957bc6591a72c392406bb37" translate="yes" xml:space="preserve">
          <source>Lowest (signed) integers to be drawn from the distribution (unless &lt;code&gt;high=None&lt;/code&gt;, in which case this parameter is 0 and this value is used for &lt;code&gt;high&lt;/code&gt;).</source>
          <target state="translated">从分布中得出的最低（带符号）整数（除非 &lt;code&gt;high=None&lt;/code&gt; ，在这种情况下此参数为0且该值用于 &lt;code&gt;high&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b948a7f8849519063c3bff20a99bb0099ed30eea" translate="yes" xml:space="preserve">
          <source>Lowest (signed) integers to be drawn from the distribution (unless &lt;code&gt;high=None&lt;/code&gt;, in which case this parameter is one above the &lt;em&gt;highest&lt;/em&gt; such integer).</source>
          <target state="translated">从分布中得出的最低（带符号）整数（除非 &lt;code&gt;high=None&lt;/code&gt; ，在这种情况下，此参数比&lt;em&gt;最高&lt;/em&gt;整数高1）。</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="796395a2ce2426bed5b8f2309da7f84c477d5434" translate="yes" xml:space="preserve">
          <source>M. Abramovitz and I. A. Stegun, &amp;ldquo;Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical Tables,&amp;rdquo; Dover, 1964, p. 69, &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/page_69.htm&quot;&gt;http://www.math.sfu.ca/~cbm/aands/page_69.htm&lt;/a&gt;</source>
          <target state="translated">M. Abramovitz和IA Stegun，&amp;ldquo;带有公式，图形和数学表的数学函数手册&amp;rdquo;，Dover，1964年，第1页。69，&lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/page_69.htm&quot;&gt;http：//www.math.sfu.ca/~cbm/aands/page_69.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14d9022ecb1d459d96a2cc474aaed3bd680af3c4" translate="yes" xml:space="preserve">
          <source>M. Abramowitz and I. A. Stegun, &lt;em&gt;Handbook of Mathematical Functions&lt;/em&gt;, 10th printing, New York: Dover, 1964, pp. 379. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/page_379.htm&quot;&gt;http://www.math.sfu.ca/~cbm/aands/page_379.htm&lt;/a&gt;</source>
          <target state="translated">M. Abramowitz和IA Stegun，&lt;em&gt;《数学函数手册》&lt;/em&gt;，第10版，纽约：多佛，1964年，第379页&lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/page_379.htm&quot;&gt;。http://www.math.sfu.ca/~cbm/aands/page_379.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0cb7cd22c76edc78df8480ba3d6f4832ff91ded4" translate="yes" xml:space="preserve">
          <source>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions. New York, NY: Dover, 1972, pg. 83.</source>
          <target state="translated">M.Abramowitz and I.A.Stegun,Handbook of Mathematical Functions.New York,NY:多佛,1972年,第83页。</target>
        </trans-unit>
        <trans-unit id="43e43bd133d6863cb7a9de2d689e513b6c81217e" translate="yes" xml:space="preserve">
          <source>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions. New York, NY: Dover, 1972, pg. 83. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</source>
          <target state="translated">M. Abramowitz和IA Stegun，《数学函数手册》。纽约，纽约：多佛（Dover），1972年，第3页。83. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53b1c9c8eb0cf262b57729e4b91b33dc7f1eea81" translate="yes" xml:space="preserve">
          <source>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions. New York, NY: Dover, 1972.</source>
          <target state="translated">M.Abramowitz and I.A.Stegun,Handbook of Mathematical Functions.纽约州纽约市。多佛,1972年。</target>
        </trans-unit>
        <trans-unit id="ee284bd1edf39da7accb49887b022f2a6880ffff" translate="yes" xml:space="preserve">
          <source>M. Abramowitz and I.A. Stegun, &amp;ldquo;Handbook of Mathematical Functions&amp;rdquo;, 10th printing, 1964, pp. 67. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</source>
          <target state="translated">M. Abramowitz和IA Stegun，&amp;ldquo;数学函数手册&amp;rdquo;，第10版，1964年，第67页&lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;。http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4d7af77e2474b1e03deb4c841c43fa44b4fa670" translate="yes" xml:space="preserve">
          <source>M. Abramowitz and I.A. Stegun, &amp;ldquo;Handbook of Mathematical Functions&amp;rdquo;, 10th printing, 1964, pp. 79. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</source>
          <target state="translated">M. Abramowitz和IA Stegun，&amp;ldquo;数学函数手册&amp;rdquo;，第10版，1964年，第79页&lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;。http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1000d3b7bf23c3293db40f1e12e55a155eb71f88" translate="yes" xml:space="preserve">
          <source>M. Abramowitz and I.A. Stegun, &amp;ldquo;Handbook of Mathematical Functions&amp;rdquo;, 10th printing, 1964, pp. 86. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</source>
          <target state="translated">M. Abramowitz和IA Stegun，&amp;ldquo;数学函数手册&amp;rdquo;，第10版，1964年，第86页&lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;。http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="10401d4904a530878ef500d4c01e13971fc1a5ec" translate="yes" xml:space="preserve">
          <source>M. Matsumoto and T. Nishimura, &amp;ldquo;Mersenne Twister: A 623-dimensionally equidistributed uniform pseudorandom number generator,&amp;rdquo; &lt;em&gt;ACM Trans. on Modeling and Computer Simulation&lt;/em&gt;, Vol. 8, No. 1, pp. 3-30, Jan. 1998.</source>
          <target state="translated">M. Matsumoto和T. Nishimura，&amp;ldquo;梅森&amp;middot;扭曲（Mersenne Twister）：一个623维均匀分布的均匀伪随机数发生器&amp;rdquo;，&lt;em&gt;ACM Trans。建模与计算机仿真&lt;/em&gt;，Vol。1998年1月，第8卷，第1期，第3-30页。</target>
        </trans-unit>
        <trans-unit id="a563fa6014f9030bc1091eda42860c70e53a75fd" translate="yes" xml:space="preserve">
          <source>M. Sullivan and M. Sullivan, III, &amp;ldquo;Algebra and Trignometry, Enhanced With Graphing Utilities,&amp;rdquo; Prentice-Hall, pg. 318, 1996.</source>
          <target state="translated">M. Sullivan和M. Sullivan，III，&amp;ldquo;代数和三角学，使用绘图实用程序进行了增强&amp;rdquo;，Prentice-Hall，第13页。318，1996。</target>
        </trans-unit>
        <trans-unit id="57cfa503fff95bbc068ee0b81926d66666383d31" translate="yes" xml:space="preserve">
          <source>M.S. Bartlett, &amp;ldquo;Periodogram Analysis and Continuous Spectra&amp;rdquo;, Biometrika 37, 1-16, 1950.</source>
          <target state="translated">MS Bartlett，&amp;ldquo;周期图分析和连续光谱&amp;rdquo;，Biometrika 37，1-16，1950年。</target>
        </trans-unit>
        <trans-unit id="07c4259d5179cff418840e647fb277f309829dc5" translate="yes" xml:space="preserve">
          <source>MATLAB</source>
          <target state="translated">MATLAB</target>
        </trans-unit>
        <trans-unit id="4f18c8e8809688b9c079f7f16f35ca10cf7359eb" translate="yes" xml:space="preserve">
          <source>MATLAB array slicing uses pass-by-value semantics, with a lazy copy-on-write scheme to prevent creating copies until they are needed. Slicing operations copy parts of the array.</source>
          <target state="translated">MATLAB数组切片采用逐值传递的语义,采用懒惰的写上复制方案,防止在需要之前创建副本。分片操作会复制数组的部分内容。</target>
        </trans-unit>
        <trans-unit id="117ac3761ded4c3563f6597cdc0e0c754c1f485f" translate="yes" xml:space="preserve">
          <source>MATLAB numbers indices from 1; &lt;code&gt;a(1)&lt;/code&gt; is the first element. &lt;a href=&quot;#numpy-for-matlab-users-notes&quot;&gt;See note INDEXING&lt;/a&gt;</source>
          <target state="translated">MATLAB编号索引从1开始； &lt;code&gt;a(1)&lt;/code&gt; 是第一个元素。&lt;a href=&quot;#numpy-for-matlab-users-notes&quot;&gt;请参阅说明INDEXING&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6774190d7f255e538acfbf2555afa1d8c09f5542" translate="yes" xml:space="preserve">
          <source>MATLAB reference documention, &amp;ldquo;Rank&amp;rdquo; &lt;a href=&quot;https://www.mathworks.com/help/techdoc/ref/rank.html&quot;&gt;https://www.mathworks.com/help/techdoc/ref/rank.html&lt;/a&gt;</source>
          <target state="translated">MATLAB参考文献&amp;ldquo; Rank&amp;rdquo; &lt;a href=&quot;https://www.mathworks.com/help/techdoc/ref/rank.html&quot;&gt;https://www.mathworks.com/help/techdoc/ref/rank.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9af4fc7b8138d2f8740cae99324e5b71bdbe2bdd" translate="yes" xml:space="preserve">
          <source>MATLAB work-a-like for 1-D and 2-D arrays.</source>
          <target state="translated">一维和二维阵列的MATLAB工作样板。</target>
        </trans-unit>
        <trans-unit id="808ffbf65afa62d125344d9b3e8790439801c809" translate="yes" xml:space="preserve">
          <source>MATLAB work-alike for 1-D and 2-D arrays.</source>
          <target state="translated">一维和二维阵列的MATLAB工作样板。</target>
        </trans-unit>
        <trans-unit id="f85414cd1f82e383cd03828ac004e023cb0d7588" translate="yes" xml:space="preserve">
          <source>MATLAB&amp;reg; and NumPy have a lot in common, but NumPy was created to work with Python, not to be a MATLAB clone. This guide will help MATLAB users get started with NumPy.</source>
          <target state="translated">MATLAB&amp;reg;和NumPy有很多共同点，但是NumPy的创建是为了与Python一起使用，而不是成为MATLAB的克隆。本指南将帮助MATLAB用户开始使用NumPy。</target>
        </trans-unit>
        <trans-unit id="36217387e89303860875aacac815f82055244ac7" translate="yes" xml:space="preserve">
          <source>MATLAB&amp;reg; and NumPy/SciPy have a lot in common. But there are many differences. NumPy and SciPy were created to do numerical and scientific computing in the most natural way with Python, not to be MATLAB&amp;reg; clones. This page is intended to be a place to collect wisdom about the differences, mostly for the purpose of helping proficient MATLAB&amp;reg; users become proficient NumPy and SciPy users.</source>
          <target state="translated">MATLAB&amp;reg;和NumPy / SciPy有很多共同点。但是有很多差异。创建NumPy和SciPy的目的是使用Python（不是MATLAB&amp;reg;克隆）以最自然的方式进行数值和科学计算。此页面旨在收集有关差异的知识，主要目的是帮助熟练的MATLAB&amp;reg;用户成为熟练的NumPy和SciPy用户。</target>
        </trans-unit>
        <trans-unit id="4949e46f6b446cc2d4c1cff7ce5d91bf57727683" translate="yes" xml:space="preserve">
          <source>MATLAB&amp;reg; and SimuLink&amp;reg; are registered trademarks of The MathWorks, Inc.</source>
          <target state="translated">MATLAB&amp;reg;和SimuLink&amp;reg;是The MathWorks，Inc.的注册商标。</target>
        </trans-unit>
        <trans-unit id="348e38df00b7a1cc73c6aa94f3dd10f19504f95a" translate="yes" xml:space="preserve">
          <source>MATLAB&amp;reg; and SimuLink&amp;reg; are registered trademarks of The MathWorks.</source>
          <target state="translated">MATLAB&amp;reg;和SimuLink&amp;reg;是The MathWorks的注册商标。</target>
        </trans-unit>
        <trans-unit id="23e174a57119e5a3f04b46115861ffc425aa73cd" translate="yes" xml:space="preserve">
          <source>MATLAB&amp;reg; uses 1 (one) based indexing. The initial element of a sequence is found using a(1). &lt;a href=&quot;#numpy-for-matlab-users-notes&quot;&gt;See note INDEXING&lt;/a&gt;</source>
          <target state="translated">MATLAB&amp;reg;使用基于1（一）的索引。序列的初始元素可使用a（1）找到。&lt;a href=&quot;#numpy-for-matlab-users-notes&quot;&gt;请参阅说明INDEXING&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="37a37fef1923ff7adb20853a92ca72292154b746" translate="yes" xml:space="preserve">
          <source>MATLAB&amp;reg;&amp;rsquo;s scripting language was created for doing linear algebra. The syntax for basic matrix operations is nice and clean, but the API for adding GUIs and making full-fledged applications is more or less an afterthought.</source>
          <target state="translated">MATLAB&amp;reg;的脚本语言是为执行线性代数而创建的。基本矩阵操作的语法很好看，但是添加GUI并创建完整应用程序的API或多或少是事后的想法。</target>
        </trans-unit>
        <trans-unit id="234b442375293b94744d2c885f1d43fdb8320c37" translate="yes" xml:space="preserve">
          <source>MATLAB&amp;rsquo;s scripting language was created for linear algebra so the syntax for some array manipulations is more compact than NumPy&amp;rsquo;s. On the other hand, the API for adding GUIs and creating full-fledged applications is more or less an afterthought.</source>
          <target state="translated">MATLAB的脚本语言是为线性代数创建的，因此某些数组操作的语法比NumPy的语法更紧凑。另一方面，用于添加GUI和创建功能完善的应用程序的API或多或少是事后的想法。</target>
        </trans-unit>
        <trans-unit id="33379c640ef1bcb7b4dbc3ceb61d0f9854342e44" translate="yes" xml:space="preserve">
          <source>MKL</source>
          <target state="translated">MKL</target>
        </trans-unit>
        <trans-unit id="664ffa3bb754768f0d60ca47af28fa5f412d2bcd" translate="yes" xml:space="preserve">
          <source>MSB integer 1</source>
          <target state="translated">MSB整数1</target>
        </trans-unit>
        <trans-unit id="a80ef4b2a5180584bd6aa3ad3c6bf4d8c37965ae" translate="yes" xml:space="preserve">
          <source>MSB integer 2</source>
          <target state="translated">MSB整数2</target>
        </trans-unit>
        <trans-unit id="e6d7ea525d9c1cb77d6dada4577419a88b5aaac1" translate="yes" xml:space="preserve">
          <source>MT19937</source>
          <target state="translated">MT19937</target>
        </trans-unit>
        <trans-unit id="6717e938ed840001469fd51dfb2c139d0adfb7ae" translate="yes" xml:space="preserve">
          <source>MT19937 (class in numpy.random)</source>
          <target state="translated">MT19937 (numpy.random中的类)</target>
        </trans-unit>
        <trans-unit id="88d75e50800aeca584cabd974a5a06de32fe6777" translate="yes" xml:space="preserve">
          <source>MT19937 - The standard Python BitGenerator. Adds a &lt;a href=&quot;generated/numpy.random.mt19937.jumped#numpy.random.MT19937.jumped&quot;&gt;&lt;code&gt;MT19937.jumped&lt;/code&gt;&lt;/a&gt; function that returns a new generator with state as-if</source>
          <target state="translated">MT19937-标准的Python BitGenerator。添加一个&lt;a href=&quot;generated/numpy.random.mt19937.jumped#numpy.random.MT19937.jumped&quot;&gt; &lt;code&gt;MT19937.jumped&lt;/code&gt; &lt;/a&gt;函数，该函数返回状态为as-if的新生成器</target>
        </trans-unit>
        <trans-unit id="7bce0d7ca3c21db35ede8db2f12fac05579372a1" translate="yes" xml:space="preserve">
          <source>MT19937 - The standard Python BitGenerator. Adds a &lt;a href=&quot;generated/numpy.random.mt19937.mt19937.jumped#numpy.random.mt19937.MT19937.jumped&quot;&gt;&lt;code&gt;jumped&lt;/code&gt;&lt;/a&gt; function that returns a new generator with state as-if</source>
          <target state="translated">MT19937-标准的Python BitGenerator。添加一个&lt;a href=&quot;generated/numpy.random.mt19937.mt19937.jumped#numpy.random.mt19937.MT19937.jumped&quot;&gt; &lt;code&gt;jumped&lt;/code&gt; &lt;/a&gt;函数，该函数返回状态为-if的新生成器</target>
        </trans-unit>
        <trans-unit id="f07c8771fb3a7c7f33effbe38f0f59fb2b7a1664" translate="yes" xml:space="preserve">
          <source>MT19937.cffi</source>
          <target state="translated">MT19937.cffi</target>
        </trans-unit>
        <trans-unit id="4b48a5628ec9fca0df3fd9eaa04078cf1112d33c" translate="yes" xml:space="preserve">
          <source>MT19937.ctypes</source>
          <target state="translated">MT19937.ctypes</target>
        </trans-unit>
        <trans-unit id="d3960fe8caf716caa3faa711048f8eaf2c190c8f" translate="yes" xml:space="preserve">
          <source>MT19937.jumped()</source>
          <target state="translated">MT19937.jumped()</target>
        </trans-unit>
        <trans-unit id="70c54bc2b37814767b0b16267d4e49e0eaa1c1c3" translate="yes" xml:space="preserve">
          <source>MT19937.state</source>
          <target state="translated">MT19937.state</target>
        </trans-unit>
        <trans-unit id="0740034935988e0ce2668a5cf091a9adb98836bf" translate="yes" xml:space="preserve">
          <source>MachAr (class in numpy)</source>
          <target state="translated">马赫阿尔</target>
        </trans-unit>
        <trans-unit id="b222baa318eb3fe2118a721645104a17a2e12508" translate="yes" xml:space="preserve">
          <source>Machine epsilon varies from machine to machine and between data types but Python floats on most platforms have a machine epsilon equal to 2.2204460492503131e-16. You can use &amp;lsquo;np.finfo(float).eps&amp;rsquo; to print out the machine epsilon for floats.</source>
          <target state="translated">机器epsilon随机器和数据类型的不同而不同，但是大多数平台上的Python浮点数的机器epsilon等于2.2204460492503131e-16。您可以使用&amp;ldquo; np.finfo（float）.eps&amp;rdquo;来打印机器epsilon的浮点数。</target>
        </trans-unit>
        <trans-unit id="9bdb316446a309b3484ba517636f47e09d947903" translate="yes" xml:space="preserve">
          <source>Machine limits for floating point types.</source>
          <target state="translated">浮点类型的机器限制。</target>
        </trans-unit>
        <trans-unit id="73e3d143745510a6549d96b020546b5898bd3c32" translate="yes" xml:space="preserve">
          <source>Machine limits for integer types.</source>
          <target state="translated">整数类型的机器限制。</target>
        </trans-unit>
        <trans-unit id="368e3c884a3e6998248ff9097641dc2397f91307" translate="yes" xml:space="preserve">
          <source>Macro form of &lt;a href=&quot;#c.PyArray_Empty&quot;&gt;&lt;code&gt;PyArray_Empty&lt;/code&gt;&lt;/a&gt; which takes a type-number, &lt;em&gt;typenum&lt;/em&gt;, instead of a data-type object.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArray_Empty&quot;&gt; &lt;code&gt;PyArray_Empty&lt;/code&gt; 的&lt;/a&gt;宏形式，它使用类型编号&lt;em&gt;typenum&lt;/em&gt;而不是数据类型对象。</target>
        </trans-unit>
        <trans-unit id="d915b8d6481f66730d8c850695157c13eec17e68" translate="yes" xml:space="preserve">
          <source>Macro form of &lt;a href=&quot;#c.PyArray_Zeros&quot;&gt;&lt;code&gt;PyArray_Zeros&lt;/code&gt;&lt;/a&gt; which takes a type-number instead of a data-type object.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArray_Zeros&quot;&gt; &lt;code&gt;PyArray_Zeros&lt;/code&gt; 的&lt;/a&gt;宏形式，它使用类型编号而不是数据类型对象。</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="8bebd0ebb56dc9f842a18e7b970fa8970cc84b64" translate="yes" xml:space="preserve">
          <source>Macros to allocate, free, and reallocate dimension and strides memory.</source>
          <target state="translated">用于分配、释放和重新分配尺寸和步长内存的宏。</target>
        </trans-unit>
        <trans-unit id="992eddad2fa60737c0e7d9f0d9c8fd77cb0a2291" translate="yes" xml:space="preserve">
          <source>Macros to allocate, free, and reallocate memory. These macros are used internally to create arrays.</source>
          <target state="translated">用于分配、释放和重新分配内存的宏。这些宏在内部用于创建数组。</target>
        </trans-unit>
        <trans-unit id="e8ab07caca0e626b10ef9247265ea63e24ca5cd9" translate="yes" xml:space="preserve">
          <source>Madvise Hugepage on Linux</source>
          <target state="translated">Madvise Hugepage on Linux</target>
        </trans-unit>
        <trans-unit id="a5772095bad3f5f510b46aeea40178c90cb9d2f9" translate="yes" xml:space="preserve">
          <source>Mailing lists</source>
          <target state="translated">邮件列表</target>
        </trans-unit>
        <trans-unit id="41c3032490e05b7582198a7d382a11e14cafbdbb" translate="yes" xml:space="preserve">
          <source>Main difference between &lt;a href=&quot;#numpy.linalg.eigvals&quot;&gt;&lt;code&gt;eigvals&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.linalg.eig#numpy.linalg.eig&quot;&gt;&lt;code&gt;eig&lt;/code&gt;&lt;/a&gt;: the eigenvectors aren&amp;rsquo;t returned.</source>
          <target state="translated">&lt;a href=&quot;#numpy.linalg.eigvals&quot;&gt; &lt;code&gt;eigvals&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.linalg.eig#numpy.linalg.eig&quot;&gt; &lt;code&gt;eig&lt;/code&gt; &lt;/a&gt;之间的主要区别：不返回特征向量。</target>
        </trans-unit>
        <trans-unit id="17f0481e62f92478758daba6f45708b9902f91ce" translate="yes" xml:space="preserve">
          <source>Main difference from eigh: the eigenvectors are not computed.</source>
          <target state="translated">与八的主要区别:不计算特征向量。</target>
        </trans-unit>
        <trans-unit id="589abefef4e6719e397197cb478d2737f78ba6e4" translate="yes" xml:space="preserve">
          <source>Mainly for backwards compatibility to the Numeric C-API and for simple casts to non-flexible types. Return a new array object with the elements of &lt;em&gt;arr&lt;/em&gt; cast to the data-type &lt;em&gt;typenum&lt;/em&gt; which must be one of the enumerated types and not a flexible type.</source>
          <target state="translated">主要是为了向后兼容数字C-API，以及将类型简单转换为非弹性类型。返回一个新数组对象，该对象的&lt;em&gt;arr&lt;/em&gt;元素&lt;em&gt;强制&lt;/em&gt;转换为数据类型&lt;em&gt;typenum&lt;/em&gt;，该类型必须是枚举类型之一，而不是灵活类型。</target>
        </trans-unit>
        <trans-unit id="1131b2784624bc64cf6e16859feb39fadf3df101" translate="yes" xml:space="preserve">
          <source>Major additions to the documentation (e.g. new tutorials) should be proposed to the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;mailing list&lt;/a&gt;.</source>
          <target state="translated">应在&lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;邮件列表中&lt;/a&gt;建议对文档进行主要补充（例如，新教程）。</target>
        </trans-unit>
        <trans-unit id="7f52e3105dfcc1e64146f131b70d4ac8a75b94c2" translate="yes" xml:space="preserve">
          <source>Make N-D coordinate arrays for vectorized evaluations of N-D scalar/vector fields over N-D grids, given one-dimensional coordinate arrays x1, x2,&amp;hellip;, xn.</source>
          <target state="translated">给定一维坐标数组x1，x2，&amp;hellip;，xn，制作ND坐标数组以对ND网格上的ND标量/矢量场进行矢量化评估。</target>
        </trans-unit>
        <trans-unit id="a9929b5560d41717cc4e17b183714853c07910d6" translate="yes" xml:space="preserve">
          <source>Make a (&lt;em&gt;very&lt;/em&gt; coarse) grid for computing a Mandelbrot set:</source>
          <target state="translated">制作一个（&lt;em&gt;非常&lt;/em&gt;粗糙的）网格来计算Mandelbrot集：</target>
        </trans-unit>
        <trans-unit id="793de80198f3e7d633a262558162ceb1ded1e015" translate="yes" xml:space="preserve">
          <source>Make a new copy of the data-type object. If &lt;code&gt;False&lt;/code&gt;, the result may just be a reference to a built-in data-type object.</source>
          <target state="translated">制作数据类型对象的新副本。如果为 &lt;code&gt;False&lt;/code&gt; ，则结果可能只是对内置数据类型对象的引用。</target>
        </trans-unit>
        <trans-unit id="f6031db018f8e5da7675cd178a0678a4fc3fce08" translate="yes" xml:space="preserve">
          <source>Make decisions about specific technical issues, features, bugs and pull requests. They are the primary mechanism of guiding the code review process and merging pull requests.</source>
          <target state="translated">对具体的技术问题、功能、bug和拉取请求做出决定。他们是指导代码审查过程和合并拉取请求的主要机制。</target>
        </trans-unit>
        <trans-unit id="906c28c76e31c9a492cffb57b2a16103952d3b9a" translate="yes" xml:space="preserve">
          <source>Make decisions about strategic collaborations with other organizations or individuals.</source>
          <target state="translated">就与其他组织或个人的战略合作作出决定。</target>
        </trans-unit>
        <trans-unit id="67dbbe53e453467605499ccb2835fb3c7302eb10" translate="yes" xml:space="preserve">
          <source>Make decisions about the Services that are run by The Project and manage those Services for the benefit of the Project and Community.</source>
          <target state="translated">就项目所提供的服务作出决定,并为项目和社区的利益管理这些服务。</target>
        </trans-unit>
        <trans-unit id="755abc90a42cd2d1d43291c25413e31792f6e799" translate="yes" xml:space="preserve">
          <source>Make decisions about the overall scope, vision and direction of the project.</source>
          <target state="translated">对项目的总体范围、愿景和方向作出决定;</target>
        </trans-unit>
        <trans-unit id="09da7faa6aced59b5226e61d16a4d476b63512be" translate="yes" xml:space="preserve">
          <source>Make decisions when regular community discussion doesn&amp;rsquo;t produce consensus on an issue in a reasonable time frame.</source>
          <target state="translated">当定期的社区讨论未能在合理的时间范围内就某个问题达成共识时，请做出决策。</target>
        </trans-unit>
        <trans-unit id="a831e4a92979555625b23c66a3d09803048cd6ec" translate="yes" xml:space="preserve">
          <source>Make function raise KnownFailureException exception if given condition is true.</source>
          <target state="translated">当给定条件为真时,使函数引发KnownFailureException异常。</target>
        </trans-unit>
        <trans-unit id="9a732c043a4153afa349bff5ecfd6f57666bdf5e" translate="yes" xml:space="preserve">
          <source>Make function raise SkipTest exception if a given condition is true.</source>
          <target state="translated">当给定的条件为真时,使函数引发SkipTest异常。</target>
        </trans-unit>
        <trans-unit id="9e9f63f3d661cfbb8ace1436845ed7a6bc72848c" translate="yes" xml:space="preserve">
          <source>Make some changes. When you feel that you&amp;rsquo;ve made a complete, working set of related changes, move on to the next steps.</source>
          <target state="translated">进行一些更改。当您感觉到已经完成了一套完整的，有效的相关更改时，请继续执行下一步。</target>
        </trans-unit>
        <trans-unit id="6858d151467d19f1cb2875295def91538137e0f5" translate="yes" xml:space="preserve">
          <source>Make sure a copy is made of &lt;em&gt;op&lt;/em&gt;. If this flag is not present, data is not copied if it can be avoided.</source>
          <target state="translated">确保使用&lt;em&gt;op&lt;/em&gt;制作副本。如果不存在此标志，则可以避免不复制数据。</target>
        </trans-unit>
        <trans-unit id="760b0011b94d0a23e85b76c7cd06e7ecba5cf0b4" translate="yes" xml:space="preserve">
          <source>Make sure all automated CI tests pass before merging a PR, and that the &lt;a href=&quot;index#building-docs&quot;&gt;documentation builds&lt;/a&gt; without any errors.</source>
          <target state="translated">合并PR之前，请确保所有自动化CI测试都通过了，并且该&lt;a href=&quot;index#building-docs&quot;&gt;文档的构建&lt;/a&gt;没有任何错误。</target>
        </trans-unit>
        <trans-unit id="9640026add93a577095656e1a0ba0914c72a1267" translate="yes" xml:space="preserve">
          <source>Make sure current branch builds a package correctly</source>
          <target state="translated">确保当前分支正确地构建了一个包</target>
        </trans-unit>
        <trans-unit id="fa253a65eff13dcd45a6381940ea3d563851c87f" translate="yes" xml:space="preserve">
          <source>Make sure that &lt;code&gt;actual_type&lt;/code&gt; is compatible with &lt;code&gt;desired_type&lt;/code&gt;. For example, this allows character and byte types, or int and long types, to match. This is now equivalent to &lt;code&gt;PyArray_EquivTypenums()&lt;/code&gt;.</source>
          <target state="translated">确保 &lt;code&gt;actual_type&lt;/code&gt; 与 &lt;code&gt;desired_type&lt;/code&gt; 兼容。例如，这允许字符和字节类型或int和long类型匹配。现在，这等效于 &lt;code&gt;PyArray_EquivTypenums()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d395ece8635aaa0e36d9dc4023c7fb1cb5ed9a09" translate="yes" xml:space="preserve">
          <source>Make sure that the release tag has been pushed.</source>
          <target state="translated">确保释放标签已经被推送。</target>
        </trans-unit>
        <trans-unit id="9b2a551f742bd2a7cf675451084c5fbd575db246" translate="yes" xml:space="preserve">
          <source>Make sure the result is a base-class ndarray. By default, if &lt;em&gt;op&lt;/em&gt; is an instance of a subclass of ndarray, an instance of that same subclass is returned. If this flag is set, an ndarray object will be returned instead.</source>
          <target state="translated">确保结果是基类ndarray。默认情况下，如果&lt;em&gt;op&lt;/em&gt;是ndarray的子​​类的实例，则返回相同子类的实例。如果设置了此标志，则将返回ndarray对象。</target>
        </trans-unit>
        <trans-unit id="a66f646163bc787161e9da29b0a054fbc6624c6d" translate="yes" xml:space="preserve">
          <source>Make sure the resulting array is a copy of the original.</source>
          <target state="translated">确保生成的数组是原始数组的副本。</target>
        </trans-unit>
        <trans-unit id="8fc11ce7d79cdf71bcb67e124e7fa1c1b139a0a5" translate="yes" xml:space="preserve">
          <source>Make sure the resulting object is an actual ndarray and not a sub- class.</source>
          <target state="translated">确保生成的对象是一个实际的ndarray,而不是一个子类。</target>
        </trans-unit>
        <trans-unit id="39d90f5a018cb286b90a3644f5e4eda749a94075" translate="yes" xml:space="preserve">
          <source>Make sure the resulting object is an actual ndarray, and not a sub-class.</source>
          <target state="translated">确保生成的对象是一个实际的ndarray,而不是一个子类。</target>
        </trans-unit>
        <trans-unit id="dc2a4442b24ed7738f50875398d3eedbc2d1aafc" translate="yes" xml:space="preserve">
          <source>Make sure the returned array can be written to.</source>
          <target state="translated">确保返回的数组可以写入。</target>
        </trans-unit>
        <trans-unit id="f2cb8de0de4ac461ccef8b3f6699d7773164c9a7" translate="yes" xml:space="preserve">
          <source>Make sure the returned array has a data-type descriptor that is in machine byte-order, over-riding any specification in the &lt;em&gt;dtype&lt;/em&gt; argument. Normally, the byte-order requirement is determined by the &lt;em&gt;dtype&lt;/em&gt; argument. If this flag is set and the dtype argument does not indicate a machine byte-order descriptor (or is NULL and the object is already an array with a data-type descriptor that is not in machine byte- order), then a new data-type descriptor is created and used with its byte-order field set to native.</source>
          <target state="translated">确保返回的数组具有机器字节顺序的数据类型描述符，该描述符覆盖&lt;em&gt;dtype&lt;/em&gt;参数中的任何规范。通常，字节顺序要求由&lt;em&gt;dtype&lt;/em&gt;参数确定。如果设置了此标志，并且dtype参数未指示机器字节顺序的描述符（或者为NULL，并且对象已经是具有数据类型描述符的数组，但该数据类型的描述符不在机器字节顺序中），则使用新的data-创建类型描述符，并将其字节序字段设置为native。</target>
        </trans-unit>
        <trans-unit id="cc7b28e40eab8c8cfe24c22e8e90c3868c988c89" translate="yes" xml:space="preserve">
          <source>Make sure the returned array has strides that are multiples of the element size.</source>
          <target state="translated">确保返回的数组的步长是元素大小的倍数。</target>
        </trans-unit>
        <trans-unit id="ff416e45483051472f44c5631669234da57230ad" translate="yes" xml:space="preserve">
          <source>Make sure the returned array is C-style contiguous</source>
          <target state="translated">确保返回的数组是C风格的连续数组。</target>
        </trans-unit>
        <trans-unit id="76ac22505382624e9142f85a5dd50a913b6940a1" translate="yes" xml:space="preserve">
          <source>Make sure the returned array is Fortran-style contiguous.</source>
          <target state="translated">确保返回的数组是Fortran式的连续。</target>
        </trans-unit>
        <trans-unit id="a3fb7cfe1b008b6ba165b89e7102a19142fa050d" translate="yes" xml:space="preserve">
          <source>Make sure the returned array is aligned on proper boundaries for its data type. An aligned array has the data pointer and every strides factor as a multiple of the alignment factor for the data-type- descriptor.</source>
          <target state="translated">确保返回的数组是在其数据类型的正确边界上对齐的。一个对齐数组的数据指针和每个步长因子都是数据类型描述符对齐因子的倍数。</target>
        </trans-unit>
        <trans-unit id="69b378647f1ea83317efaa51bb3b654effbedd36" translate="yes" xml:space="preserve">
          <source>Make sure to test your builds. To ensure everything stays in shape, see if all tests pass:</source>
          <target state="translated">确保测试你的构建。为了确保一切都保持在状态,看看是否所有测试都通过了。</target>
        </trans-unit>
        <trans-unit id="62da4918e5f62625894d937e2e3a7fe6b005b2b9" translate="yes" xml:space="preserve">
          <source>Make the local copy</source>
          <target state="translated">制作本地副本</target>
        </trans-unit>
        <trans-unit id="c48a45c41752973d88a462b08b11d9bc755ea64e" translate="yes" xml:space="preserve">
          <source>Make the release</source>
          <target state="translated">释放</target>
        </trans-unit>
        <trans-unit id="e191446d7cb1daa2fc91f55d604a91404a3bfcc4" translate="yes" xml:space="preserve">
          <source>Make the window functions exactly symmetric</source>
          <target state="translated">使窗口功能完全对称</target>
        </trans-unit>
        <trans-unit id="8243dc037100f878288a764547cbc0e678b232cd" translate="yes" xml:space="preserve">
          <source>Makes a copy of the given iterator. This function is provided primarily to enable multi-threaded iteration of the data.</source>
          <target state="translated">对给定的迭代器进行复制。提供这个函数主要是为了实现数据的多线程迭代。</target>
        </trans-unit>
        <trans-unit id="024d1b814e91d1479a513e542438675be42871e1" translate="yes" xml:space="preserve">
          <source>Making a new feature branch</source>
          <target state="translated">建立一个新的功能分支</target>
        </trans-unit>
        <trans-unit id="9994f58a6845d6543e990f0db03b5691b328bb3d" translate="yes" xml:space="preserve">
          <source>Making changes to the view changes the underlying array</source>
          <target state="translated">对视图进行更改会改变底层数组</target>
        </trans-unit>
        <trans-unit id="7a8542defa1f2f46558700bed760e59b4ae9473a" translate="yes" xml:space="preserve">
          <source>Making proper sets</source>
          <target state="translated">制作适当的套装</target>
        </trans-unit>
        <trans-unit id="1f882dac1dece4867b9fd6e24e50469f91a6a8c5" translate="yes" xml:space="preserve">
          <source>Making your own copy (fork) of NumPy</source>
          <target state="translated">制作你自己的NumPy副本(fork)</target>
        </trans-unit>
        <trans-unit id="f072320f52e480cd4cee7848612d896de0342201" translate="yes" xml:space="preserve">
          <source>Manipulating a MaskedArray</source>
          <target state="translated">操纵蒙版数组</target>
        </trans-unit>
        <trans-unit id="b69b809ef0c7c1f9959ac303f434b38d1178af50" translate="yes" xml:space="preserve">
          <source>Manipulating and Displaying Structured Datatypes</source>
          <target state="translated">操纵和显示结构化数据类型。</target>
        </trans-unit>
        <trans-unit id="37cb8d5fc1a8a147eb37587df7287a57d2924596" translate="yes" xml:space="preserve">
          <source>Manipulations</source>
          <target state="translated">Manipulations</target>
        </trans-unit>
        <trans-unit id="8d9fbdf134eaac3b76a99337507116859ebbef42" translate="yes" xml:space="preserve">
          <source>Manual pages online</source>
          <target state="translated">手册页面在线</target>
        </trans-unit>
        <trans-unit id="186df05b293e739802129eb3df4baaf8fda61676" translate="yes" xml:space="preserve">
          <source>Manually adding two vectors, using broadcasting:</source>
          <target state="translated">手动添加两个向量,使用广播。</target>
        </trans-unit>
        <trans-unit id="24b85b2e484e6f827cf479e7935e6715b5367776" translate="yes" xml:space="preserve">
          <source>Many changes to array printing, disableable with the new &amp;ldquo;legacy&amp;rdquo; printing mode</source>
          <target state="translated">阵列打印的许多更改，可以通过新的&amp;ldquo;旧版&amp;rdquo;打印模式禁用</target>
        </trans-unit>
        <trans-unit id="30ff36cb17e64d96a4194df0b29c86b8a889d3aa" translate="yes" xml:space="preserve">
          <source>Many of the RandomState methods above are exported as functions in &lt;a href=&quot;index#module-numpy.random&quot;&gt;&lt;code&gt;numpy.random&lt;/code&gt;&lt;/a&gt; This usage is discouraged, as it is implemented via a global &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; instance which is not advised on two counts:</source>
          <target state="translated">上面的许多RandomState方法都是作为&lt;a href=&quot;index#module-numpy.random&quot;&gt; &lt;code&gt;numpy.random&lt;/code&gt; 中的&lt;/a&gt;函数导出的，不建议使用此用法，因为它是通过全局&lt;a href=&quot;#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;实例实现的，不建议在以下两个方面进行建议：</target>
        </trans-unit>
        <trans-unit id="7ff15d6fb98077a9b63faafb800abb9fe78fcf46" translate="yes" xml:space="preserve">
          <source>Many of these methods take an argument named &lt;em&gt;axis&lt;/em&gt;. In such cases,</source>
          <target state="translated">这些方法很多都采用名为&lt;em&gt;axis&lt;/em&gt;的参数。在这种情况下</target>
        </trans-unit>
        <trans-unit id="baf4a8743470327c4600513b810018ef2c55fcf7" translate="yes" xml:space="preserve">
          <source>Many operations can take place along one of these axes. For example, we can sum each row of an array, in which case we operate along columns, or axis 1:</source>
          <target state="translated">许多操作可以沿着这些轴之一进行。例如,我们可以对数组的每一行进行求和,在这种情况下,我们沿着列或轴1进行操作。</target>
        </trans-unit>
        <trans-unit id="9ede0036fbda2644b0badedec4f5663550b9b1ac" translate="yes" xml:space="preserve">
          <source>Many other distributions are also supported.</source>
          <target state="translated">此外,还支持许多其他发行版。</target>
        </trans-unit>
        <trans-unit id="bf803fbf10619fd778459bc01e332b6ee0d8b941" translate="yes" xml:space="preserve">
          <source>Many people like to say that Python is a fantastic glue language. Hopefully, this Chapter will convince you that this is true. The first adopters of Python for science were typically people who used it to glue together large application codes running on super-computers. Not only was it much nicer to code in Python than in a shell script or Perl, in addition, the ability to easily extend Python made it relatively easy to create new classes and types specifically adapted to the problems being solved. From the interactions of these early contributors, Numeric emerged as an array-like object that could be used to pass data between these applications.</source>
          <target state="translated">很多人喜欢说Python是一种神奇的胶水语言。希望本章能让你相信这是真的。科学界最早采用Python的人通常是用它来粘合在超级计算机上运行的大型应用代码的人。用 Python 来编写代码不仅比用 shell 脚本或 Perl 好用得多,此外,Python 易于扩展的能力使得创建专门适应所要解决的问题的新类和类型变得相对容易。从这些早期贡献者的互动中,Numeric 作为一个类似数组的对象出现了,它可以用来在这些应用程序之间传递数据。</target>
        </trans-unit>
        <trans-unit id="5b80222964fcc4594c09147e0b7ae65980724b47" translate="yes" xml:space="preserve">
          <source>Many unary operations, such as computing the sum of all the elements in the array, are implemented as methods of the &lt;code&gt;ndarray&lt;/code&gt; class.</source>
          <target state="translated">许多一元运算（例如计算数组中所有元素的总和）都作为 &lt;code&gt;ndarray&lt;/code&gt; 类的方法实现。</target>
        </trans-unit>
        <trans-unit id="a73bcf30ee540d20aa6caf9854834e68102f531d" translate="yes" xml:space="preserve">
          <source>Manylinux1 wheels use the gcc provided on the Manylinux docker images.</source>
          <target state="translated">Manylinux1轮子使用Manylinux docker镜像上提供的gcc。</target>
        </trans-unit>
        <trans-unit id="e0c534a05742cb00dc61fd7a287ca60edf0922d2" translate="yes" xml:space="preserve">
          <source>Marketing</source>
          <target state="translated">Marketing</target>
        </trans-unit>
        <trans-unit id="b6a9029c64b412740bceba8fc1ba7afc803f28fd" translate="yes" xml:space="preserve">
          <source>Marten van Kerkwijk</source>
          <target state="translated">Marten van Kerkwijk</target>
        </trans-unit>
        <trans-unit id="60df02e5f0d607ed31f13075db7cca76392b09be" translate="yes" xml:space="preserve">
          <source>Marten van Kerkwijk (2017-2019)</source>
          <target state="translated">Marten van Kerkwijk(2017-2019)</target>
        </trans-unit>
        <trans-unit id="8e22a4dd259d1679b0a51f9039d6bfdead73e93b" translate="yes" xml:space="preserve">
          <source>Mask an array inside a given interval.</source>
          <target state="translated">在给定的区间内屏蔽一个数组。</target>
        </trans-unit>
        <trans-unit id="da9a1c569bf731b67119f643ede378ad4e3f1519" translate="yes" xml:space="preserve">
          <source>Mask an array outside a given interval.</source>
          <target state="translated">在给定的区间外屏蔽一个数组。</target>
        </trans-unit>
        <trans-unit id="6cfe071d1d905293fc1a86d3d41da5c8b38fd4a8" translate="yes" xml:space="preserve">
          <source>Mask an array where &lt;code&gt;not&lt;/code&gt; equal to a given value.</source>
          <target state="translated">屏蔽 &lt;code&gt;not&lt;/code&gt; 等于给定值的数组。</target>
        </trans-unit>
        <trans-unit id="bfd71c8af0182463deeb8b929bb8db010e999aa1" translate="yes" xml:space="preserve">
          <source>Mask an array where a condition is met.</source>
          <target state="translated">屏蔽一个满足条件的数组。</target>
        </trans-unit>
        <trans-unit id="745c1555706e0f77e6ffe2c2813a3fb36374ff35" translate="yes" xml:space="preserve">
          <source>Mask an array where equal to a given value.</source>
          <target state="translated">屏蔽一个数组,其中等于一个给定值。</target>
        </trans-unit>
        <trans-unit id="f9729990c0e40052af76c9e13494e2abd95504a0" translate="yes" xml:space="preserve">
          <source>Mask an array where greater than a given value.</source>
          <target state="translated">屏蔽一个大于给定值的数组。</target>
        </trans-unit>
        <trans-unit id="ec4efca3f5e96d9a3bd62aaca7a5391e583c37d0" translate="yes" xml:space="preserve">
          <source>Mask an array where greater than or equal to a given value.</source>
          <target state="translated">屏蔽大于或等于给定值的数组。</target>
        </trans-unit>
        <trans-unit id="c0c78b88c4cc26e562d4c01312db539d600c13b8" translate="yes" xml:space="preserve">
          <source>Mask an array where invalid values occur (NaNs or infs).</source>
          <target state="translated">屏蔽一个出现无效值的数组(NaNs或infs)。</target>
        </trans-unit>
        <trans-unit id="bafddbcc3a701d825f4b8c81b4a6586eda8f72f6" translate="yes" xml:space="preserve">
          <source>Mask an array where less than a given value.</source>
          <target state="translated">屏蔽一个小于给定值的数组。</target>
        </trans-unit>
        <trans-unit id="cf298275c5da246fc15e63b817a590139fdfaf20" translate="yes" xml:space="preserve">
          <source>Mask an array where less than or equal to a given value.</source>
          <target state="translated">屏蔽一个小于或等于给定值的数组。</target>
        </trans-unit>
        <trans-unit id="f25a93425a69cec34a64e945a78ff3354d106c87" translate="yes" xml:space="preserve">
          <source>Mask array &lt;code&gt;b&lt;/code&gt; conditional on &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">掩模阵列 &lt;code&gt;b&lt;/code&gt; 有条件的 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6351290c3e2bd1325051b50aa84be0096715800" translate="yes" xml:space="preserve">
          <source>Mask cols of a 2D array that contain masked values.</source>
          <target state="translated">掩码包含掩码值的2D数组的列。</target>
        </trans-unit>
        <trans-unit id="5989c0ba273f4fa26213980d7a2122d0b5463f7a" translate="yes" xml:space="preserve">
          <source>Mask columns of a 2D array that contain masked values.</source>
          <target state="translated">屏蔽一个包含屏蔽值的二维数组的列。</target>
        </trans-unit>
        <trans-unit id="888fa953c6e1c3b95fb32020739a8fb7290b6a16" translate="yes" xml:space="preserve">
          <source>Mask inside a given interval.</source>
          <target state="translated">在给定的区间内屏蔽。</target>
        </trans-unit>
        <trans-unit id="8875894bb1277ca00fff30f310af81531740e9e5" translate="yes" xml:space="preserve">
          <source>Mask invalid values (NaNs or infs).</source>
          <target state="translated">屏蔽无效值(NaNs或infs)。</target>
        </trans-unit>
        <trans-unit id="3c5cc469c703297ad73e0cbd2085f332b3c12da4" translate="yes" xml:space="preserve">
          <source>Mask outside a given interval.</source>
          <target state="translated">屏蔽在给定的区间外。</target>
        </trans-unit>
        <trans-unit id="00af5e48341996dadc0cdb5fdf0842273fe5b864" translate="yes" xml:space="preserve">
          <source>Mask rows and/or columns of a 2D array that contain masked values.</source>
          <target state="translated">屏蔽包含屏蔽值的二维数组的行或列。</target>
        </trans-unit>
        <trans-unit id="036b308dd6f036875453ed63e39c90f458b31d97" translate="yes" xml:space="preserve">
          <source>Mask rows and/or columns of a 2D array.</source>
          <target state="translated">屏蔽一个二维阵列的行和/或列。</target>
        </trans-unit>
        <trans-unit id="fa07a97e90fa3a048da5dc5176f7f8f08808a1e7" translate="yes" xml:space="preserve">
          <source>Mask rows of a 2D array that contain masked values.</source>
          <target state="translated">屏蔽包含屏蔽值的二维数组的行。</target>
        </trans-unit>
        <trans-unit id="cdcf6bd79fa7623a0f0d4537e494029fd7cec8d6" translate="yes" xml:space="preserve">
          <source>Mask the array &lt;code&gt;x&lt;/code&gt; where the data are exactly equal to value.</source>
          <target state="translated">在数据完全等于值的地方屏蔽数组 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d4dbf0aaf4fae78661a0147024893bc953fbf99" translate="yes" xml:space="preserve">
          <source>Mask using floating point equality.</source>
          <target state="translated">屏蔽使用浮点平等。</target>
        </trans-unit>
        <trans-unit id="1a7c6742714332311a709c878556f33860c1ca12" translate="yes" xml:space="preserve">
          <source>Mask where &lt;code&gt;not&lt;/code&gt; equal to a given value.</source>
          <target state="translated">掩码 &lt;code&gt;not&lt;/code&gt; 等于给定值的地方。</target>
        </trans-unit>
        <trans-unit id="6a25717d456c673a4a868df938fb9bd46105d77b" translate="yes" xml:space="preserve">
          <source>Mask where a condition is met.</source>
          <target state="translated">满足条件的屏蔽。</target>
        </trans-unit>
        <trans-unit id="2e77dd6d757e07506b660bea8d79d9b375bb9e96" translate="yes" xml:space="preserve">
          <source>Mask where equal to a given value (integers).</source>
          <target state="translated">掩码其中等于一个给定值(整数)。</target>
        </trans-unit>
        <trans-unit id="819bdc07b0b19e7e594b197983e674371983eb93" translate="yes" xml:space="preserve">
          <source>Mask where equal to a given value.</source>
          <target state="translated">掩码其中等于一个给定值。</target>
        </trans-unit>
        <trans-unit id="99e92ea0dacc268463873d122e4916bac3c6166d" translate="yes" xml:space="preserve">
          <source>Mask where greater than a given value.</source>
          <target state="translated">掩码其中大于给定值。</target>
        </trans-unit>
        <trans-unit id="377f44d52c44c29b0aa5a55900c31b4b9e499dd4" translate="yes" xml:space="preserve">
          <source>Mask where greater than or equal to a given value.</source>
          <target state="translated">掩码大于或等于给定值的地方。</target>
        </trans-unit>
        <trans-unit id="f0e79008b6bfb135c14c930dd9b5fa3a89ff7ec3" translate="yes" xml:space="preserve">
          <source>Mask where less than a given value.</source>
          <target state="translated">在小于给定值的情况下,屏蔽。</target>
        </trans-unit>
        <trans-unit id="c86db9f027cb5e25560c169de275edc638940064" translate="yes" xml:space="preserve">
          <source>Mask where less than or equal to a given value.</source>
          <target state="translated">小于或等于给定值的掩码。</target>
        </trans-unit>
        <trans-unit id="0d15a34ef50017c16ffef8d56380f0190f6e4176" translate="yes" xml:space="preserve">
          <source>Mask whole rows and/or columns of a 2D array that contain masked values. The masking behavior is selected using the &lt;code&gt;axis&lt;/code&gt; parameter.</source>
          <target state="translated">对包含掩码值的2D数组的整个行和/或列进行掩码。使用 &lt;code&gt;axis&lt;/code&gt; 参数选择屏蔽行为。</target>
        </trans-unit>
        <trans-unit id="fcd2fc9f9e2cbbcb1423bbce02ea7377a87d9394" translate="yes" xml:space="preserve">
          <source>Mask. Must be convertible to an array of booleans with the same shape as &lt;code&gt;data&lt;/code&gt;. True indicates a masked (i.e. invalid) data.</source>
          <target state="translated">面具。必须可转换为与 &lt;code&gt;data&lt;/code&gt; 形状相同的布尔数组。True表示被屏蔽（即无效）的数据。</target>
        </trans-unit>
        <trans-unit id="56d91486aefab83c4b7a8aafb6822eb7b0d14e2c" translate="yes" xml:space="preserve">
          <source>MaskType (in module numpy.ma)</source>
          <target state="translated">MaskType (在模块numpy.ma中)</target>
        </trans-unit>
        <trans-unit id="77690385e03cf5be1602ed7d25dbb1c74983e23a" translate="yes" xml:space="preserve">
          <source>Masked array interpretation of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">的掩蔽阵列解释 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2736171df63d3cbe517f0bae324f23b6232dfa60" translate="yes" xml:space="preserve">
          <source>Masked array operations</source>
          <target state="translated">屏蔽数组操作</target>
        </trans-unit>
        <trans-unit id="2d4d75f30e0b052c284673be22985a3e26fd2369" translate="yes" xml:space="preserve">
          <source>Masked arrays</source>
          <target state="translated">屏蔽数组</target>
        </trans-unit>
        <trans-unit id="26652000ec64c331ba43c810f4acf18412b0f68b" translate="yes" xml:space="preserve">
          <source>Masked arrays (&lt;code&gt;numpy.ma&lt;/code&gt;)</source>
          <target state="translated">蒙版数组（ &lt;code&gt;numpy.ma&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="078e11437b77503c6af41321e9f5a89af35fcaa3" translate="yes" xml:space="preserve">
          <source>Masked arrays (numpy.ma)</source>
          <target state="translated">屏蔽数组(numpy.ma)</target>
        </trans-unit>
        <trans-unit id="52d21a15b7bc961fe34264bd95fc89878c193c0a" translate="yes" xml:space="preserve">
          <source>Masked arrays &lt;a href=&quot;../reference/generated/numpy.ma.maskedarray.tofile#numpy.ma.MaskedArray.tofile&quot;&gt;&lt;code&gt;can't currently be saved&lt;/code&gt;&lt;/a&gt;, nor can other arbitrary array subclasses.</source>
          <target state="translated">掩码数组&lt;a href=&quot;../reference/generated/numpy.ma.maskedarray.tofile#numpy.ma.MaskedArray.tofile&quot;&gt; &lt;code&gt;can't currently be saved&lt;/code&gt; &lt;/a&gt;，其他任意数组子类也无法保存。</target>
        </trans-unit>
        <trans-unit id="7153e6f35343b699d95430ff8793f79f62547cd2" translate="yes" xml:space="preserve">
          <source>Masked arrays also support standard numpy ufuncs. The output is then a masked array. The result of a unary ufunc is masked wherever the input is masked. The result of a binary ufunc is masked wherever any of the input is masked. If the ufunc also returns the optional context output (a 3-element tuple containing the name of the ufunc, its arguments and its domain), the context is processed and entries of the output masked array are masked wherever the corresponding input fall outside the validity domain:</source>
          <target state="translated">屏蔽数组也支持标准的numpy ufuncs。然后输出的是一个掩码数组。一元ufunc的结果在任何输入被掩码的地方都会被掩码,二元ufunc的结果在任何输入被掩码的地方都会被掩码。二进制ufunc的结果在任何输入被掩码的地方都会被掩码。如果ufunc还返回了可选的上下文输出(一个包含ufunc名称、参数和域的3元素元组),那么上下文将被处理,并且输出的掩码数组中的条目将被掩码,只要相应的输入在有效域之外。</target>
        </trans-unit>
        <trans-unit id="65927f39316e88f57788fd2eb5136f42b5cf0bdc" translate="yes" xml:space="preserve">
          <source>Masked arrays are also a good idea since the &lt;a href=&quot;../reference/maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module also comes with a specific implementation of most &lt;a href=&quot;../glossary#term-ufunc&quot;&gt;NumPy universal functions (ufuncs)&lt;/a&gt;, which means that you can still apply fast vectorized functions and operations on masked data. The output is then a masked array. We&amp;rsquo;ll see some examples of how this works in practice below.</source>
          <target state="translated">屏蔽数组也是一个好主意，因为&lt;a href=&quot;../reference/maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt;模块还附带了大多数&lt;a href=&quot;../glossary#term-ufunc&quot;&gt;NumPy通用函数（ufuncs）&lt;/a&gt;的特定实现，这意味着您仍然可以对屏蔽数据应用快速矢量化函数和操作。然后输出是一个掩码数组。我们将在下面看到一些有关如何在实际中工作的示例。</target>
        </trans-unit>
        <trans-unit id="2feff57b9d5e5a78c57621737acc9551d5fb918f" translate="yes" xml:space="preserve">
          <source>Masked arrays are arrays that may have missing or invalid entries. The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module provides a nearly work-alike replacement for numpy that supports data arrays with masks.</source>
          <target state="translated">掩码数组是可能缺少条目或无效条目的数组。所述&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt;模块提供numpy的一个近工作都置换，与掩模支撑件数据数组。</target>
        </trans-unit>
        <trans-unit id="3f5b01b275571ce9babfb349e3e312bc47fa839e" translate="yes" xml:space="preserve">
          <source>Masked arrays are arrays that may have missing or invalid entries. The &lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module provides a nearly work-alike replacement for numpy that supports data arrays with masks.</source>
          <target state="translated">掩码数组是可能缺少条目或无效条目的数组。所述&lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt;模块提供numpy的一个近工作都置换，与掩模支撑件数据数组。</target>
        </trans-unit>
        <trans-unit id="95c3a7b724956ad14eb8d4eaa01adbe13df7006e" translate="yes" xml:space="preserve">
          <source>Masked arrays are often used when operating on arrays containing missing or invalid entries.</source>
          <target state="translated">当对含有缺失或无效条目的数组进行操作时,经常使用屏蔽数组。</target>
        </trans-unit>
        <trans-unit id="0540687eb24d38593064d3dec8d6776ae8362128" translate="yes" xml:space="preserve">
          <source>Masked arrays arithmetics</source>
          <target state="translated">屏蔽的数组算术</target>
        </trans-unit>
        <trans-unit id="1b98b3e1595ab0387c4f0bf412ece270fde73e27" translate="yes" xml:space="preserve">
          <source>Masked arrays containing objects with arrays</source>
          <target state="translated">屏蔽的数组,包含有数组的对象。</target>
        </trans-unit>
        <trans-unit id="9bb05590ea9fc4f5a59f3cc6510307a040a1ef71" translate="yes" xml:space="preserve">
          <source>Masked dot product of two arrays. Note that &lt;code&gt;out&lt;/code&gt; and &lt;code&gt;strict&lt;/code&gt; are located in different positions than in &lt;code&gt;ma.dot&lt;/code&gt;. In order to maintain compatibility with the functional version, it is recommended that the optional arguments be treated as keyword only. At some point that may be mandatory.</source>
          <target state="translated">两个数组的蒙版点积。请注意， &lt;code&gt;out&lt;/code&gt; 和 &lt;code&gt;strict&lt;/code&gt; 的位置与 &lt;code&gt;ma.dot&lt;/code&gt; 的位置不同。为了保持与功能版本的兼容性，建议将可选参数仅视为关键字。在某些时候这可能是强制性的。</target>
        </trans-unit>
        <trans-unit id="2a10f17f192630fac9e2659b01202ca989fcde7d" translate="yes" xml:space="preserve">
          <source>Masked elements are ignored.</source>
          <target state="translated">屏蔽的元素会被忽略。</target>
        </trans-unit>
        <trans-unit id="a1ab6894299ae6aae7ef94e3acf9c5526b0895b9" translate="yes" xml:space="preserve">
          <source>Masked elements are set to 0 internally.</source>
          <target state="translated">屏蔽的元素在内部设置为0。</target>
        </trans-unit>
        <trans-unit id="97b5ab568e51a37efa7e81ef1c6b7490d9852f4c" translate="yes" xml:space="preserve">
          <source>Masked elements are set to 1 internally for computation.</source>
          <target state="translated">屏蔽元素在计算时内部设为1。</target>
        </trans-unit>
        <trans-unit id="f459802409051eaa7a4da3a38b8b3e649cb95c03" translate="yes" xml:space="preserve">
          <source>Masked entries are ignored, and result elements which are not finite will be masked.</source>
          <target state="translated">屏蔽的条目会被忽略,而不是有限的结果元素将被屏蔽。</target>
        </trans-unit>
        <trans-unit id="b67c6e592961bc4088100d1e724368d014dd740f" translate="yes" xml:space="preserve">
          <source>Masked entries are ignored.</source>
          <target state="translated">屏蔽的条目会被忽略。</target>
        </trans-unit>
        <trans-unit id="a553f9a17153e944aa3ccf0663ddf7bdd834bdc5" translate="yes" xml:space="preserve">
          <source>Masked values are considered as False during computation.</source>
          <target state="translated">在计算过程中,屏蔽值被视为False。</target>
        </trans-unit>
        <trans-unit id="6c8cae7fd974732de54350b0ecabf2b49f4bd07f" translate="yes" xml:space="preserve">
          <source>Masked values are not compared directly.</source>
          <target state="translated">屏蔽值不直接比较。</target>
        </trans-unit>
        <trans-unit id="8b7bd1ffbc4df578f27392c4f72e5f827148711a" translate="yes" xml:space="preserve">
          <source>Masked values are replaced by 0.</source>
          <target state="translated">屏蔽的值用0代替。</target>
        </trans-unit>
        <trans-unit id="594673afbc6460668c76a5b5a60900b4eb69ed4e" translate="yes" xml:space="preserve">
          <source>Masked values are set to 0 internally during the computation. However, their position is saved, and the result will be masked at the same locations.</source>
          <target state="translated">在计算过程中,屏蔽值在内部被设置为0。但是,它们的位置会被保存,结果会在相同的位置被屏蔽。</target>
        </trans-unit>
        <trans-unit id="c62cda838d0dd89db4f7db7a848bed90b8a35029" translate="yes" xml:space="preserve">
          <source>Masked values are set to 1 internally during the computation. However, their position is saved, and the result will be masked at the same locations.</source>
          <target state="translated">在计算过程中,屏蔽值在内部被设置为1。但是,它们的位置会被保存,结果会在相同的位置被屏蔽。</target>
        </trans-unit>
        <trans-unit id="0d54b7cdcf2aacde324dff6e5bfaee0441c90af7" translate="yes" xml:space="preserve">
          <source>Masked values in the input array result in rows of zeros.</source>
          <target state="translated">输入数组中的屏蔽值会导致零的行。</target>
        </trans-unit>
        <trans-unit id="46f85aa5a353da87d3752c17130ba68a2f9115ff" translate="yes" xml:space="preserve">
          <source>Masked values of True exclude the corresponding element from any computation.</source>
          <target state="translated">屏蔽值为True时,将对应的元素排除在任何计算之外。</target>
        </trans-unit>
        <trans-unit id="c4e097b58ceb08dc3f974c8e6307eeef8e3013c5" translate="yes" xml:space="preserve">
          <source>Masked-array output</source>
          <target state="translated">屏蔽阵列输出</target>
        </trans-unit>
        <trans-unit id="d841064c28c03dbff8c2613367c727f3c3c8975a" translate="yes" xml:space="preserve">
          <source>MaskedArray</source>
          <target state="translated">MaskedArray</target>
        </trans-unit>
        <trans-unit id="3df5c7bf77a07f0823127c257a4194f48584b074" translate="yes" xml:space="preserve">
          <source>MaskedArray (class in numpy.ma)</source>
          <target state="translated">MaskedArray (class in numpy.ma)</target>
        </trans-unit>
        <trans-unit id="e483ca2e474474c0115e70cf1df3652e7e71e77d" translate="yes" xml:space="preserve">
          <source>MaskedArray interpretation of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">的MaskedArray诠释 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20350351979da6675c245e446543b5c06d79da69" translate="yes" xml:space="preserve">
          <source>MaskedArray methods</source>
          <target state="translated">MaskedArray方法</target>
        </trans-unit>
        <trans-unit id="9be96da49a55b5657adb2ecea5fac909f3ac8f8e" translate="yes" xml:space="preserve">
          <source>MaskedArray support for more complicated base classes</source>
          <target state="translated">为更复杂的基类提供MaskedArray支持。</target>
        </trans-unit>
        <trans-unit id="36eef88f9e59e296f6ba9abe6367cd57b8fabee2" translate="yes" xml:space="preserve">
          <source>MaskedArray.T</source>
          <target state="translated">MaskedArray.T</target>
        </trans-unit>
        <trans-unit id="e17190e574e1c6de156753c9b065e38a9376c85f" translate="yes" xml:space="preserve">
          <source>MaskedArray.__abs__()</source>
          <target state="translated">MaskedArray.__abs__()</target>
        </trans-unit>
        <trans-unit id="4c5beb6649fcf04681433a7ebdca9956aed5ec6d" translate="yes" xml:space="preserve">
          <source>MaskedArray.__add__()</source>
          <target state="translated">MaskedArray.__add__()</target>
        </trans-unit>
        <trans-unit id="421e10c77680329d49bb9737bb7abc28463207e4" translate="yes" xml:space="preserve">
          <source>MaskedArray.__and__()</source>
          <target state="translated">MaskedArray.__and__()</target>
        </trans-unit>
        <trans-unit id="fada5de9b74bd344d17ff17846c4bd7d09dc8ec5" translate="yes" xml:space="preserve">
          <source>MaskedArray.__array__()</source>
          <target state="translated">MaskedArray.__array__()</target>
        </trans-unit>
        <trans-unit id="090520da30f28f47ff34b0675dc4cfba52313678" translate="yes" xml:space="preserve">
          <source>MaskedArray.__array_priority__</source>
          <target state="translated">MaskedArray.__array_priority__</target>
        </trans-unit>
        <trans-unit id="3850984710cdf39034ba996313c98f23d5b2df9a" translate="yes" xml:space="preserve">
          <source>MaskedArray.__array_wrap__()</source>
          <target state="translated">MaskedArray.__array_wrap__()</target>
        </trans-unit>
        <trans-unit id="777801a9212371f85a428b465acd2c96402cbfb0" translate="yes" xml:space="preserve">
          <source>MaskedArray.__bool__()</source>
          <target state="translated">MaskedArray.__bool__()</target>
        </trans-unit>
        <trans-unit id="efb175793e0186c34683a4fcb1d1cf5491acc106" translate="yes" xml:space="preserve">
          <source>MaskedArray.__contains__()</source>
          <target state="translated">MaskedArray.__contains__()</target>
        </trans-unit>
        <trans-unit id="05bac951e4103953d43b28841001972c2c09a472" translate="yes" xml:space="preserve">
          <source>MaskedArray.__copy__()</source>
          <target state="translated">MaskedArray.__copy__()</target>
        </trans-unit>
        <trans-unit id="48e8b4072b356b5f6fb2ea3cc4a44eb836ce6d39" translate="yes" xml:space="preserve">
          <source>MaskedArray.__deepcopy__()</source>
          <target state="translated">MaskedArray.__deepcopy__()</target>
        </trans-unit>
        <trans-unit id="2e0879e5e2662c5b7bec6d8240c414de65e1878a" translate="yes" xml:space="preserve">
          <source>MaskedArray.__delitem__()</source>
          <target state="translated">MaskedArray.__delitem__()</target>
        </trans-unit>
        <trans-unit id="ab799a52b2b144674a2920b57d6fb16fd77e185f" translate="yes" xml:space="preserve">
          <source>MaskedArray.__div__()</source>
          <target state="translated">MaskedArray.__div__()</target>
        </trans-unit>
        <trans-unit id="c40d7cec7bfe9dd6ab450d46b504989d029ed2f1" translate="yes" xml:space="preserve">
          <source>MaskedArray.__divmod__()</source>
          <target state="translated">MaskedArray.__divmod__()</target>
        </trans-unit>
        <trans-unit id="31b2f1c182adb284ba514a01be32170ad7fca9d8" translate="yes" xml:space="preserve">
          <source>MaskedArray.__eq__()</source>
          <target state="translated">MaskedArray.__eq__()</target>
        </trans-unit>
        <trans-unit id="c0a1ce4250661dd853b1e06f87ab8dac408d08ad" translate="yes" xml:space="preserve">
          <source>MaskedArray.__float__()</source>
          <target state="translated">MaskedArray.__float__()</target>
        </trans-unit>
        <trans-unit id="c760fe1447ecc3aa37cfb9102932a85018b3dafc" translate="yes" xml:space="preserve">
          <source>MaskedArray.__floordiv__()</source>
          <target state="translated">MaskedArray.__floordiv__()</target>
        </trans-unit>
        <trans-unit id="ee7563ffce3b171861962dcda9493c8d6ea3ed49" translate="yes" xml:space="preserve">
          <source>MaskedArray.__ge__()</source>
          <target state="translated">MaskedArray.__ge__()</target>
        </trans-unit>
        <trans-unit id="82fcceeb833f853fcf31878a9b2755ca3b83dad5" translate="yes" xml:space="preserve">
          <source>MaskedArray.__getitem__()</source>
          <target state="translated">MaskedArray.__getitem__()</target>
        </trans-unit>
        <trans-unit id="9ed68261ffa77dc15fd5c9bb460e16946aa3df57" translate="yes" xml:space="preserve">
          <source>MaskedArray.__getstate__()</source>
          <target state="translated">MaskedArray.__getstate__()</target>
        </trans-unit>
        <trans-unit id="5a94e729c8538503cbcb25ba506eda001f10eef6" translate="yes" xml:space="preserve">
          <source>MaskedArray.__gt__()</source>
          <target state="translated">MaskedArray.__gt__()</target>
        </trans-unit>
        <trans-unit id="5bf01a17a65fea68034c80a57ef6ea67f24bf648" translate="yes" xml:space="preserve">
          <source>MaskedArray.__iadd__()</source>
          <target state="translated">MaskedArray.__iadd__()</target>
        </trans-unit>
        <trans-unit id="3f290bfa30bdb27d86e902d735f6bd7a3ebdd997" translate="yes" xml:space="preserve">
          <source>MaskedArray.__iand__()</source>
          <target state="translated">MaskedArray.__iand__()</target>
        </trans-unit>
        <trans-unit id="a013bde0bc2086e80993b2e6453749be7566713a" translate="yes" xml:space="preserve">
          <source>MaskedArray.__idiv__()</source>
          <target state="translated">MaskedArray.__idiv__()</target>
        </trans-unit>
        <trans-unit id="6b16248d7544de200904fad546fc0e0bf49d5d30" translate="yes" xml:space="preserve">
          <source>MaskedArray.__ifloordiv__()</source>
          <target state="translated">MaskedArray.__ifloordiv__()</target>
        </trans-unit>
        <trans-unit id="e867a020a9a28fcaaaeebcd0b9a09276f34baacb" translate="yes" xml:space="preserve">
          <source>MaskedArray.__ilshift__()</source>
          <target state="translated">MaskedArray.__ilshift__()</target>
        </trans-unit>
        <trans-unit id="a6177a6fe00279423505c3d2049817ef902c9f89" translate="yes" xml:space="preserve">
          <source>MaskedArray.__imod__()</source>
          <target state="translated">MaskedArray.__imod__()</target>
        </trans-unit>
        <trans-unit id="b2c2e20491238cbe7365526c778bb2bbeb1a9d92" translate="yes" xml:space="preserve">
          <source>MaskedArray.__imul__()</source>
          <target state="translated">MaskedArray.__imul__()</target>
        </trans-unit>
        <trans-unit id="8a9abb4f5e69b652a91dedbea90a17391081121c" translate="yes" xml:space="preserve">
          <source>MaskedArray.__int__()</source>
          <target state="translated">MaskedArray.__int__()</target>
        </trans-unit>
        <trans-unit id="89500ad2db959507c40e092a4338242970ecf920" translate="yes" xml:space="preserve">
          <source>MaskedArray.__ior__()</source>
          <target state="translated">MaskedArray.__ior__()</target>
        </trans-unit>
        <trans-unit id="f6e0374c35f94019edb4b446250c41ffb2f2fed6" translate="yes" xml:space="preserve">
          <source>MaskedArray.__ipow__()</source>
          <target state="translated">MaskedArray.__ipow__()</target>
        </trans-unit>
        <trans-unit id="464e0df1d1343a8a83ded812b19b8824e3be674f" translate="yes" xml:space="preserve">
          <source>MaskedArray.__irshift__()</source>
          <target state="translated">MaskedArray.__irshift__()</target>
        </trans-unit>
        <trans-unit id="93662970a9f68651b0f13dddd859eee1c0cc852a" translate="yes" xml:space="preserve">
          <source>MaskedArray.__isub__()</source>
          <target state="translated">MaskedArray.__isub__()</target>
        </trans-unit>
        <trans-unit id="97afb01534849ce41926c144adb54602527c52de" translate="yes" xml:space="preserve">
          <source>MaskedArray.__itruediv__()</source>
          <target state="translated">MaskedArray.__itruediv__()</target>
        </trans-unit>
        <trans-unit id="e96f966e7a5dbcf51d23a0d0e3ddedabf690b6a0" translate="yes" xml:space="preserve">
          <source>MaskedArray.__ixor__()</source>
          <target state="translated">MaskedArray.__ixor__()</target>
        </trans-unit>
        <trans-unit id="bfe0157861dd1f9b0a231126eaf62a9189b87c49" translate="yes" xml:space="preserve">
          <source>MaskedArray.__le__()</source>
          <target state="translated">MaskedArray.__le__()</target>
        </trans-unit>
        <trans-unit id="dfcf580e54d121ccd612e4d1a45624b4bf8d1bc1" translate="yes" xml:space="preserve">
          <source>MaskedArray.__len__()</source>
          <target state="translated">MaskedArray.__len__()</target>
        </trans-unit>
        <trans-unit id="7d5ce46d9782038b232fd02c47b999130a7413d8" translate="yes" xml:space="preserve">
          <source>MaskedArray.__long__()</source>
          <target state="translated">MaskedArray.__long__()</target>
        </trans-unit>
        <trans-unit id="663699b5db72d62ee50222aef2e15e6ad8befaa7" translate="yes" xml:space="preserve">
          <source>MaskedArray.__lshift__()</source>
          <target state="translated">MaskedArray.__lshift__()</target>
        </trans-unit>
        <trans-unit id="981e3ec8c47bf66b67cbcfc222695e682740ef5c" translate="yes" xml:space="preserve">
          <source>MaskedArray.__lt__()</source>
          <target state="translated">MaskedArray.__lt__()</target>
        </trans-unit>
        <trans-unit id="e012d6b8cd5b77bcbe0a7677af22fead34c5e6bc" translate="yes" xml:space="preserve">
          <source>MaskedArray.__mod__()</source>
          <target state="translated">MaskedArray.__mod__()</target>
        </trans-unit>
        <trans-unit id="621981dba1b2c2c21d05b7718ab7bc6b94dde4de" translate="yes" xml:space="preserve">
          <source>MaskedArray.__mul__()</source>
          <target state="translated">MaskedArray.__mul__()</target>
        </trans-unit>
        <trans-unit id="451a40eda1d0439b5952565ebd5be0b93178765b" translate="yes" xml:space="preserve">
          <source>MaskedArray.__ne__()</source>
          <target state="translated">MaskedArray.__ne__()</target>
        </trans-unit>
        <trans-unit id="449fa0f7176203d64b7688836d07d289af8aaada" translate="yes" xml:space="preserve">
          <source>MaskedArray.__or__()</source>
          <target state="translated">MaskedArray.__or__()</target>
        </trans-unit>
        <trans-unit id="74a1bdc16196c2ca4cb42e9ddf2dfa11e81379c0" translate="yes" xml:space="preserve">
          <source>MaskedArray.__pow__()</source>
          <target state="translated">MaskedArray.__pow__()</target>
        </trans-unit>
        <trans-unit id="628ddbd485b2a3c762a1acfa9b1ed8ea95f6ae2a" translate="yes" xml:space="preserve">
          <source>MaskedArray.__radd__()</source>
          <target state="translated">MaskedArray.__radd__()</target>
        </trans-unit>
        <trans-unit id="e614928ac12233029fee60e611f9fd93534a1549" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rand__()</source>
          <target state="translated">MaskedArray.__rand__()</target>
        </trans-unit>
        <trans-unit id="60d56dcc3079a28858f7341d86340a9f6456c4ae" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rdivmod__()</source>
          <target state="translated">MaskedArray.__rdivmod__()</target>
        </trans-unit>
        <trans-unit id="58cfbddeeee8f3d20b2cb0a7c8e4b95d69260328" translate="yes" xml:space="preserve">
          <source>MaskedArray.__reduce__()</source>
          <target state="translated">MaskedArray.__reduce__()</target>
        </trans-unit>
        <trans-unit id="22bff568add5c50c81a9b76411f74a0165340bc3" translate="yes" xml:space="preserve">
          <source>MaskedArray.__repr__()</source>
          <target state="translated">MaskedArray.__repr__()</target>
        </trans-unit>
        <trans-unit id="37da21dfefb5612acac5c5b158edd891d71eaa33" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rfloordiv__()</source>
          <target state="translated">MaskedArray.__rfloordiv__()</target>
        </trans-unit>
        <trans-unit id="ba081ab522355f8c737fc96eeefb42e5ff706d35" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rlshift__()</source>
          <target state="translated">MaskedArray.__rlshift__()</target>
        </trans-unit>
        <trans-unit id="556c4be401c91f224ede894f1fd54e9f20d1b10a" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rmod__()</source>
          <target state="translated">MaskedArray.__rmod__()</target>
        </trans-unit>
        <trans-unit id="d258f963823807ebafdac4bd7b4899a4ad5b3d81" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rmul__()</source>
          <target state="translated">MaskedArray.__rmul__()</target>
        </trans-unit>
        <trans-unit id="6c3504184a32bdc300bf50151f75a50cfb6319e8" translate="yes" xml:space="preserve">
          <source>MaskedArray.__ror__()</source>
          <target state="translated">MaskedArray.__ror__()</target>
        </trans-unit>
        <trans-unit id="b16d994e6cc6bacd92021c5be6a1f21c448c82be" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rpow__()</source>
          <target state="translated">MaskedArray.__rpow__()</target>
        </trans-unit>
        <trans-unit id="c263bb6b6626def1b808e0fb37da7db4a0ebdd03" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rrshift__()</source>
          <target state="translated">MaskedArray.__rrshift__()</target>
        </trans-unit>
        <trans-unit id="2024b9cd2546c77971dd14447cc764030b99e828" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rshift__()</source>
          <target state="translated">MaskedArray.__rshift__()</target>
        </trans-unit>
        <trans-unit id="9b18fd997fad99869943ae5ae86581115d42c76a" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rsub__()</source>
          <target state="translated">MaskedArray.__rsub__()</target>
        </trans-unit>
        <trans-unit id="1f99227921386926b66e1c80505362e37c730585" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rtruediv__()</source>
          <target state="translated">MaskedArray.__rtruediv__()</target>
        </trans-unit>
        <trans-unit id="f78ffc8f65b81494cb55cee0002a4b0ada2f7ea9" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rxor__()</source>
          <target state="translated">MaskedArray.__rxor__()</target>
        </trans-unit>
        <trans-unit id="e2418f087c527a32587d4136ae5e11918bd6852f" translate="yes" xml:space="preserve">
          <source>MaskedArray.__setitem__()</source>
          <target state="translated">MaskedArray.__setitem__()</target>
        </trans-unit>
        <trans-unit id="fd4da74423f8b70de86f76a2c1393f4543b02dca" translate="yes" xml:space="preserve">
          <source>MaskedArray.__setmask__()</source>
          <target state="translated">MaskedArray.__setmask__()</target>
        </trans-unit>
        <trans-unit id="3f08573f36e15c86d5119deeed078db9cf2f9c35" translate="yes" xml:space="preserve">
          <source>MaskedArray.__setstate__()</source>
          <target state="translated">MaskedArray.__setstate__()</target>
        </trans-unit>
        <trans-unit id="bf1a7de4e02395cb1d82eb3102a1b212087fb9cc" translate="yes" xml:space="preserve">
          <source>MaskedArray.__str__()</source>
          <target state="translated">MaskedArray.__str__()</target>
        </trans-unit>
        <trans-unit id="36b295d86fb340a017c207e36c8ebf83a6e16a78" translate="yes" xml:space="preserve">
          <source>MaskedArray.__sub__()</source>
          <target state="translated">MaskedArray.__sub__()</target>
        </trans-unit>
        <trans-unit id="a89d7e18e21d53f656570951adaedf72a5d05f92" translate="yes" xml:space="preserve">
          <source>MaskedArray.__truediv__()</source>
          <target state="translated">MaskedArray.__truediv__()</target>
        </trans-unit>
        <trans-unit id="a9754cec53ed0199a3d0e11dd63f20ddf46718a9" translate="yes" xml:space="preserve">
          <source>MaskedArray.__xor__()</source>
          <target state="translated">MaskedArray.__xor__()</target>
        </trans-unit>
        <trans-unit id="e5c6d58a06d7326fe5c3b8675bf582f779908979" translate="yes" xml:space="preserve">
          <source>MaskedArray.all()</source>
          <target state="translated">MaskedArray.all()</target>
        </trans-unit>
        <trans-unit id="8e1c2703f802467d9be6b41fd4750421b30e4e78" translate="yes" xml:space="preserve">
          <source>MaskedArray.anom()</source>
          <target state="translated">MaskedArray.anom()</target>
        </trans-unit>
        <trans-unit id="ceaaae3b924788c52bbc3430b2ea479db323a8fa" translate="yes" xml:space="preserve">
          <source>MaskedArray.any()</source>
          <target state="translated">MaskedArray.any()</target>
        </trans-unit>
        <trans-unit id="b63e7e734845f2e2d00786798d483b6f14625034" translate="yes" xml:space="preserve">
          <source>MaskedArray.argmax()</source>
          <target state="translated">MaskedArray.argmax()</target>
        </trans-unit>
        <trans-unit id="1d5ecf97f71ab691cf38b6c6ce5d2340f025638f" translate="yes" xml:space="preserve">
          <source>MaskedArray.argmin()</source>
          <target state="translated">MaskedArray.argmin()</target>
        </trans-unit>
        <trans-unit id="5f36204da3705060bd71f1d51d51b88f55d27d4b" translate="yes" xml:space="preserve">
          <source>MaskedArray.argsort()</source>
          <target state="translated">MaskedArray.argsort()</target>
        </trans-unit>
        <trans-unit id="553ea17b1dc12eebdf6169924b18d2d2f67e5e36" translate="yes" xml:space="preserve">
          <source>MaskedArray.astype()</source>
          <target state="translated">MaskedArray.astype()</target>
        </trans-unit>
        <trans-unit id="8b903ed2f76d12382ddb4618a18e0d58c21ed045" translate="yes" xml:space="preserve">
          <source>MaskedArray.base</source>
          <target state="translated">MaskedArray.base</target>
        </trans-unit>
        <trans-unit id="a41536928c95f5bbcde8ddd69d27b894c4f41213" translate="yes" xml:space="preserve">
          <source>MaskedArray.baseclass</source>
          <target state="translated">MaskedArray.baseclass</target>
        </trans-unit>
        <trans-unit id="e9f76b44c9ca3946a8973c001ef5105ca5c0a87a" translate="yes" xml:space="preserve">
          <source>MaskedArray.byteswap()</source>
          <target state="translated">MaskedArray.byteswap()</target>
        </trans-unit>
        <trans-unit id="6d6d5940ea9cd2aa53d30efb8451b5d30eb2cde7" translate="yes" xml:space="preserve">
          <source>MaskedArray.choose()</source>
          <target state="translated">MaskedArray.choose()</target>
        </trans-unit>
        <trans-unit id="15f1f394124b62be99d1e91448f88c1ef69b9f14" translate="yes" xml:space="preserve">
          <source>MaskedArray.clip()</source>
          <target state="translated">MaskedArray.clip()</target>
        </trans-unit>
        <trans-unit id="cf476639b180537cbfa338fde8bb6d05c515b926" translate="yes" xml:space="preserve">
          <source>MaskedArray.compress()</source>
          <target state="translated">MaskedArray.compress()</target>
        </trans-unit>
        <trans-unit id="2ee7894999c452973a3887d5a0c1ffb1b8b3389f" translate="yes" xml:space="preserve">
          <source>MaskedArray.compressed()</source>
          <target state="translated">MaskedArray.compressed()</target>
        </trans-unit>
        <trans-unit id="35832e57568e0633c816ac034fbb4ab85736d2c2" translate="yes" xml:space="preserve">
          <source>MaskedArray.conj()</source>
          <target state="translated">MaskedArray.conj()</target>
        </trans-unit>
        <trans-unit id="8161480b13b89c370614b9b7777fdfda08ce6c7d" translate="yes" xml:space="preserve">
          <source>MaskedArray.conjugate()</source>
          <target state="translated">MaskedArray.conjugate()</target>
        </trans-unit>
        <trans-unit id="cb7ea380c906751da3d908d0bc4c7d88be3c4655" translate="yes" xml:space="preserve">
          <source>MaskedArray.copy()</source>
          <target state="translated">MaskedArray.copy()</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
