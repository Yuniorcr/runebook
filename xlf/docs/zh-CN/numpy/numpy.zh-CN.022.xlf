<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="a9f67bac25f1e9fa1addb151018aeaf9def3b945" translate="yes" xml:space="preserve">
          <source>The default data type in NumPy is &lt;code&gt;float_&lt;/code&gt;.</source>
          <target state="translated">NumPy中的默认数据类型为 &lt;code&gt;float_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50b3a1f2cd19d600f3d2675b9e6ec25082ab0d35" translate="yes" xml:space="preserve">
          <source>The default data type: &lt;a href=&quot;arrays.scalars#numpy.float_&quot;&gt;&lt;code&gt;float_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">默认数据类型：&lt;a href=&quot;arrays.scalars#numpy.float_&quot;&gt; &lt;code&gt;float_&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1cb916c2a199dec22e3c7d35ff5ca943ade2af02" translate="yes" xml:space="preserve">
          <source>The default data type: &lt;code&gt;float_&lt;/code&gt;.</source>
          <target state="translated">默认数据类型： &lt;code&gt;float_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="585140e706eb572d257d276596c7c62733d99ac8" translate="yes" xml:space="preserve">
          <source>The default fill value.</source>
          <target state="translated">默认的填充值。</target>
        </trans-unit>
        <trans-unit id="a6dbb84bde95674721b5026ade7be2a1d41460db" translate="yes" xml:space="preserve">
          <source>The default filling value depends on the datatype of the input array or the type of the input scalar:</source>
          <target state="translated">默认的填充值取决于输入数组的数据类型或输入标量的类型。</target>
        </trans-unit>
        <trans-unit id="d172f7f7da97c607ca46d821dc996e8763c04a60" translate="yes" xml:space="preserve">
          <source>The default for busday functions is that the only valid days are Monday through Friday (the usual business days). The implementation is based on a &amp;ldquo;weekmask&amp;rdquo; containing 7 Boolean flags to indicate valid days; custom weekmasks are possible that specify other sets of valid days.</source>
          <target state="translated">busday功能的默认设置是唯一有效的日期是星期一至星期五（通常的工作日）。该实现基于包含7个布尔值标志的&amp;ldquo;周掩码&amp;rdquo;，以指示有效日期；可以使用自定义周掩码来指定其他有效日期集。</target>
        </trans-unit>
        <trans-unit id="b9e6f3b39a9841c2072fe28c903a4873d59b58cf" translate="yes" xml:space="preserve">
          <source>The default for most operations, raises an exception if an index is out of bounds.</source>
          <target state="translated">大多数操作的默认值,如果索引出界会引发异常。</target>
        </trans-unit>
        <trans-unit id="b1071130df37f1589932b92836294305fd9d0ff9" translate="yes" xml:space="preserve">
          <source>The default interface is a very literal translation of the Fortran code into Python. The Fortran array arguments must now be NumPy arrays and the integer argument should be an integer. The interface will attempt to convert all arguments to their required types (and shapes) and issue an error if unsuccessful. However, because it knows nothing about the semantics of the arguments (such that C is an output and n should really match the array sizes), it is possible to abuse this function in ways that can cause Python to crash. For example:</source>
          <target state="translated">默认的接口是将Fortran代码翻译成Python的字面意思。Fortran 数组参数现在必须是 NumPy 数组,整数参数应该是一个整数。接口会尝试将所有参数转换为它们所需的类型 (和形状),如果不成功就会发出一个错误。然而,由于它对参数的语义一无所知(比如C是一个输出,而n应该真正与数组大小相匹配),因此有可能以导致Python崩溃的方式滥用这个函数。例如</target>
        </trans-unit>
        <trans-unit id="f01d70d1a58c31eb28ef483c3e412b7730114894" translate="yes" xml:space="preserve">
          <source>The default interface is a very literal translation of the fortran code into Python. The Fortran array arguments must now be NumPy arrays and the integer argument should be an integer. The interface will attempt to convert all arguments to their required types (and shapes) and issue an error if unsuccessful. However, because it knows nothing about the semantics of the arguments (such that C is an output and n should really match the array sizes), it is possible to abuse this function in ways that can cause Python to crash. For example:</source>
          <target state="translated">默认的接口是将fortran代码翻译成Python的字面意思。Fortran 数组参数现在必须是 NumPy 数组,整数参数应该是一个整数。该接口会尝试将所有参数转换为它们所需的类型 (和形状),如果不成功就会发出一个错误。然而,由于它对参数的语义一无所知(比如C是一个输出,而n应该真正与数组大小相匹配),因此有可能以导致Python崩溃的方式滥用这个函数。例如</target>
        </trans-unit>
        <trans-unit id="0b3aadfe669f7dc7282a8bf3bc7021b967d5f363" translate="yes" xml:space="preserve">
          <source>The default is not to change the current behavior.</source>
          <target state="translated">默认情况是不改变当前行为。</target>
        </trans-unit>
        <trans-unit id="35460c572d36a32620dc9fa812780440e2fcffff" translate="yes" xml:space="preserve">
          <source>The default is to &lt;code&gt;'warn'&lt;/code&gt; for &lt;code&gt;invalid&lt;/code&gt;, &lt;code&gt;divide&lt;/code&gt;, and &lt;code&gt;overflow&lt;/code&gt; and &lt;code&gt;'ignore'&lt;/code&gt; for &lt;code&gt;underflow&lt;/code&gt;. But this can be changed, and it can be set individually for different kinds of exceptions. The different behaviors are:</source>
          <target state="translated">默认值是 &lt;code&gt;'warn'&lt;/code&gt; 表示 &lt;code&gt;invalid&lt;/code&gt; ， &lt;code&gt;divide&lt;/code&gt; 和 &lt;code&gt;overflow&lt;/code&gt; 而 &lt;code&gt;'ignore'&lt;/code&gt; 表示 &lt;code&gt;underflow&lt;/code&gt; 。但这可以更改，并且可以针对不同种类的异常分别设置。不同的行为是：</target>
        </trans-unit>
        <trans-unit id="13f5430198109332da2b945e817fa963554a0039" translate="yes" xml:space="preserve">
          <source>The default iterator of an ndarray object is the default Python iterator of a sequence type. Thus, when the array object itself is used as an iterator. The default behavior is equivalent to:</source>
          <target state="translated">ndarray对象的默认迭代器是一个序列类型的默认Python迭代器。因此,当数组对象本身被用作迭代器时。默认行为等同于。</target>
        </trans-unit>
        <trans-unit id="aac361851a1a42c7bb314d3f5e868ac753b52020" translate="yes" xml:space="preserve">
          <source>The default method is &amp;ldquo;marginals&amp;rdquo;. For some cases (e.g. when &lt;code&gt;colors&lt;/code&gt; contains relatively small integers), the &amp;ldquo;count&amp;rdquo; method can be significantly faster than the &amp;ldquo;marginals&amp;rdquo; method. If performance of the algorithm is important, test the two methods with typical inputs to decide which works best.</source>
          <target state="translated">默认方法是&amp;ldquo;边际&amp;rdquo;。在某些情况下（例如，当 &lt;code&gt;colors&lt;/code&gt; 包含相对较小的整数时），&amp;ldquo;计数&amp;rdquo;方法可能比&amp;ldquo;边距&amp;rdquo;方法快得多。如果算法的性能很重要，请使用典型输入来测试这两种方法，以确定哪种方法最有效。</target>
        </trans-unit>
        <trans-unit id="d0a1e3c85492f9a28cfa2d6a52018d6303212281" translate="yes" xml:space="preserve">
          <source>The default normalization has the direct transforms unscaled and the inverse transforms are scaled by</source>
          <target state="translated">默认的归一化使直接变换不按比例放大,反变换按以下比例放大</target>
        </trans-unit>
        <trans-unit id="294bd9e52acfdc133dee5d5ce445aefb23018ef1" translate="yes" xml:space="preserve">
          <source>The default order for the libraries are:</source>
          <target state="translated">库的默认顺序是:</target>
        </trans-unit>
        <trans-unit id="d79f5666dde2a74098ca71f007435f35059e5b3e" translate="yes" xml:space="preserve">
          <source>The default threshold to detect rank deficiency is a test on the magnitude of the singular values of &lt;code&gt;M&lt;/code&gt;. By default, we identify singular values less than &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; as indicating rank deficiency (with the symbols defined above). This is the algorithm MATLAB uses [1]. It also appears in &lt;em&gt;Numerical recipes&lt;/em&gt; in the discussion of SVD solutions for linear least squares [2].</source>
          <target state="translated">检测秩不足的默认阈值是对 &lt;code&gt;M&lt;/code&gt; 的奇异值的大小的测试。默认情况下，我们将小于 &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; 奇异值标识为秩不足（使用上面定义的符号）。这是MATLAB使用的算法[1]。在有关线性最小二乘的SVD解决方案的讨论中，它也出现在&lt;em&gt;数值配方&lt;/em&gt;中[2]。</target>
        </trans-unit>
        <trans-unit id="fabcee56c3086c9123fae22826809a0d986ec9e3" translate="yes" xml:space="preserve">
          <source>The default type to use when no dtype is explicitly specified, for example when calling np.zero(shape). This is equivalent to &lt;a href=&quot;#c.NPY_DOUBLE&quot;&gt;&lt;code&gt;NPY_DOUBLE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当未显式指定dtype时（例如，在调用np.zero（shape）时）使用的默认类型。这等效于&lt;a href=&quot;#c.NPY_DOUBLE&quot;&gt; &lt;code&gt;NPY_DOUBLE&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a62d7fdf404d547735e1b655e9c601557613abc2" translate="yes" xml:space="preserve">
          <source>The default valid days are Monday through Friday (&amp;ldquo;business days&amp;rdquo;). A busdaycalendar object can be specified with any set of weekly valid days, plus an optional &amp;ldquo;holiday&amp;rdquo; dates that always will be invalid.</source>
          <target state="translated">默认的有效日期为星期一至星期五（&amp;ldquo;工作日&amp;rdquo;）。可以使用任何一组每周有效日期以及一个可选的&amp;ldquo;假日&amp;rdquo;日期来指定一个busdaycalendar对象，该日期总是无效的。</target>
        </trans-unit>
        <trans-unit id="c0b43ef4693453ebdb4d72174da4b3e8ae831417" translate="yes" xml:space="preserve">
          <source>The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order.</source>
          <target state="translated">默认值（'S'）导致交换当前字节顺序。</target>
        </trans-unit>
        <trans-unit id="203757e2bdf5bbe5e651d506c476783cf6e50edd" translate="yes" xml:space="preserve">
          <source>The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for the alternatives above. For example, any of &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;biggish&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">默认值（'S'）导致交换当前字节顺序。对于上述替代方案，代码对 &lt;code&gt;new_order&lt;/code&gt; 的第一个字母进行不区分大小写的检查。例如，&amp;ldquo; B&amp;rdquo;或&amp;ldquo; b&amp;rdquo;或&amp;ldquo; biggish&amp;rdquo;中的任何一个都可以有效地指定big-endian。</target>
        </trans-unit>
        <trans-unit id="86906072113e4cc2809d8408fb9acbe0a4443ef7" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;names&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;. If we give any other value to the keyword, the new names will overwrite the field names we may have defined with the dtype:</source>
          <target state="translated">的默认值 &lt;code&gt;names&lt;/code&gt; 是 &lt;code&gt;None&lt;/code&gt; 。如果我们给关键字赋予其他任何值，则新名称将覆盖我们可能已经用dtype定义的字段名称：</target>
        </trans-unit>
        <trans-unit id="19a5ab6c7c39a905e845eb64d8df075515c15636" translate="yes" xml:space="preserve">
          <source>The defining property of the antiderivative:</source>
          <target state="translated">反衍生物的定义属性。</target>
        </trans-unit>
        <trans-unit id="7a4397ef8c9f537d85068ef5bbb9a575412a21fb" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;C&lt;/code&gt; is the same as before, but for &lt;code&gt;D&lt;/code&gt;, the &lt;code&gt;__new__&lt;/code&gt; method returns an instance of class &lt;code&gt;C&lt;/code&gt; rather than &lt;code&gt;D&lt;/code&gt;. Note that the &lt;code&gt;__init__&lt;/code&gt; method of &lt;code&gt;D&lt;/code&gt; does not get called. In general, when the &lt;code&gt;__new__&lt;/code&gt; method returns an object of class other than the class in which it is defined, the &lt;code&gt;__init__&lt;/code&gt; method of that class is not called.</source>
          <target state="translated">的定义 &lt;code&gt;C&lt;/code&gt; 是和以前一样，但对于 &lt;code&gt;D&lt;/code&gt; ，所述 &lt;code&gt;__new__&lt;/code&gt; 方法返回类的实例 &lt;code&gt;C&lt;/code&gt; 而非 &lt;code&gt;D&lt;/code&gt; 。请注意，不会调用 &lt;code&gt;D&lt;/code&gt; 的 &lt;code&gt;__init__&lt;/code&gt; 方法。通常，当 &lt;code&gt;__new__&lt;/code&gt; 方法返回其定义所在类之外的其他类的对象时，不会调用该类的 &lt;code&gt;__init__&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="a1b5640a64fc73d8755c0223b335feaa121479d8" translate="yes" xml:space="preserve">
          <source>The definition of advanced indexing means that &lt;code&gt;x[(1,2,3),]&lt;/code&gt; is fundamentally different than &lt;code&gt;x[(1,2,3)]&lt;/code&gt;. The latter is equivalent to &lt;code&gt;x[1,2,3]&lt;/code&gt; which will trigger basic selection while the former will trigger advanced indexing. Be sure to understand why this occurs.</source>
          <target state="translated">高级索引的定义意味着 &lt;code&gt;x[(1,2,3),]&lt;/code&gt; 与 &lt;code&gt;x[(1,2,3)]&lt;/code&gt; 根本不同。后者等效于 &lt;code&gt;x[1,2,3]&lt;/code&gt; ，它将触发基本选择，而前者将触发高级索引。确保了解为什么会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="61496dee2f3816bd693a7ce0398282c8ea47a960" translate="yes" xml:space="preserve">
          <source>The definition of correlation above is not unique and sometimes correlation may be defined differently. Another common definition is:</source>
          <target state="translated">以上关于相关性的定义并不是唯一的,有时候相关性的定义可能会有所不同。另一种常见的定义是:</target>
        </trans-unit>
        <trans-unit id="938e670c022b166026c1f3d97b60b6e6eed3f831" translate="yes" xml:space="preserve">
          <source>The definition of the &lt;code&gt;&amp;lt;argument/variable type declaration&amp;gt;&lt;/code&gt; part is</source>
          <target state="translated">所述的定义 &lt;code&gt;&amp;lt;argument/variable type declaration&amp;gt;&lt;/code&gt; 部分是</target>
        </trans-unit>
        <trans-unit id="f1f4801e8c8f57fdee23b9a4f5485bae04f50607" translate="yes" xml:space="preserve">
          <source>The definition of the &lt;code&gt;&amp;lt;common block statement&amp;gt;&lt;/code&gt; part is</source>
          <target state="translated">&lt;code&gt;&amp;lt;common block statement&amp;gt;&lt;/code&gt; 部分的定义是</target>
        </trans-unit>
        <trans-unit id="d5ed0cf6ae14e241898a603f2c9052eee0f3ff8c" translate="yes" xml:space="preserve">
          <source>The definition of the &lt;code&gt;&amp;lt;use statement&amp;gt;&lt;/code&gt; part is</source>
          <target state="translated">&lt;code&gt;&amp;lt;use statement&amp;gt;&lt;/code&gt; 部分的定义是</target>
        </trans-unit>
        <trans-unit id="e5f33fe407bab51cea8bacccfd88b8a5036810dc" translate="yes" xml:space="preserve">
          <source>The degree of the series.</source>
          <target state="translated">系列的程度。</target>
        </trans-unit>
        <trans-unit id="155faa0de8c44a325761ca30fe7a5e7dbf74e6e4" translate="yes" xml:space="preserve">
          <source>The depends list contains paths to files or directories that the sources of the extension module depend on. If any path in the depends list is newer than the extension module, then the module will be rebuilt.</source>
          <target state="translated">依赖列表中包含了扩展模块的源代码所依赖的文件或目录的路径。如果依赖列表中的任何路径比扩展模块更新,那么该模块将被重建。</target>
        </trans-unit>
        <trans-unit id="8add200746bc778285c2910a22d91b2b8b258c85" translate="yes" xml:space="preserve">
          <source>The deprecated function.</source>
          <target state="translated">废弃的功能。</target>
        </trans-unit>
        <trans-unit id="63644093036e4f3b360649808afd2f026edeffe7" translate="yes" xml:space="preserve">
          <source>The derivation of the t-distribution was first published in 1908 by William Gosset while working for the Guinness Brewery in Dublin. Due to proprietary issues, he had to publish under a pseudonym, and so he used the name Student.</source>
          <target state="translated">1908年,威廉-戈塞特在都柏林的吉尼斯啤酒厂工作时,首次发表了t分布的推导。由于专利问题,他不得不用假名发表,所以他使用了学生这个名字。</target>
        </trans-unit>
        <trans-unit id="7db2e5319fb072c88d575bc92b04bca324abdb47" translate="yes" xml:space="preserve">
          <source>The derivative of the polynomial</source>
          <target state="translated">多项式的导数</target>
        </trans-unit>
        <trans-unit id="e38da7322eec5dfeb19db7a40e7e799054f3e9fa" translate="yes" xml:space="preserve">
          <source>The desc member of the PyCObject returned from __array_struct__ was not specified. Usually, it was the object exposing the array (so that a reference to it could be kept and destroyed when the C-object was destroyed). Now it must be a tuple whose first element is a string with &amp;ldquo;PyArrayInterface Version #&amp;rdquo; and whose second element is the object exposing the array.</source>
          <target state="translated">未指定从__array_struct__返回的PyCObject的desc成员。通常，它是暴露数组的对象（以便在销毁C对象时可以保留和销毁对它的引用）。现在，它必须是一个元组，其第一个元素是带有&amp;ldquo; PyArrayInterface Version＃&amp;rdquo;的字符串，第二个元素是暴露数组的对象。</target>
        </trans-unit>
        <trans-unit id="d7dbcb2541cf001d7b26e25e4170575fd900c8ee" translate="yes" xml:space="preserve">
          <source>The description of the fourth element of the header therefore has become: &amp;ldquo;The next 4 bytes form a little-endian unsigned int: the length of the header data HEADER_LEN.&amp;rdquo;</source>
          <target state="translated">标头的第四个元素的描述因此变为：&amp;ldquo;接下来的4个字节形成一个低位无符号int：标头数据HEADER_LEN的长度。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="877e58bc0c85ccf0ef190f149115500e0d385da1" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array The default, None, means</source>
          <target state="translated">数组所需的数据类型。</target>
        </trans-unit>
        <trans-unit id="35a7d4b1a08d0cc477bdaa0f984f65c664ce2e77" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array, e.g., &lt;a href=&quot;../arrays.scalars#numpy.int8&quot;&gt;&lt;code&gt;numpy.int8&lt;/code&gt;&lt;/a&gt;. Default is &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;numpy.float64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">数组的所需数据类型，例如&lt;a href=&quot;../arrays.scalars#numpy.int8&quot;&gt; &lt;code&gt;numpy.int8&lt;/code&gt; &lt;/a&gt;。默认值为&lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt; &lt;code&gt;numpy.float64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4a52cabb32fca3b74ad0388e9c1cbe1cf8d25b1" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array, e.g., &lt;code&gt;numpy.int8&lt;/code&gt;. Default is &lt;code&gt;numpy.float64&lt;/code&gt;.</source>
          <target state="translated">数组的所需数据类型，例如 &lt;code&gt;numpy.int8&lt;/code&gt; 。默认值为 &lt;code&gt;numpy.float64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0a8a7651b0b383e3707246aaf8cd38e2e169098" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array. If not given, then the type will be determined as the minimum type required to hold the objects in the sequence.</source>
          <target state="translated">数组所需的数据类型。如果没有给定,那么类型将被确定为序列中对象所需的最小类型。</target>
        </trans-unit>
        <trans-unit id="f7534f7cefc524ae1e988328a3c98ad10f344592" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array. If not given, then the type will be determined as the minimum type required to hold the objects in the sequence. This argument can only be used to &amp;lsquo;upcast&amp;rsquo; the array. For downcasting, use the .astype(t) method.</source>
          <target state="translated">数组所需的数据类型。如果未给出，则将类型确定为在序列中保存对象所需的最小类型。此参数只能用于&amp;ldquo;上载&amp;rdquo;阵列。对于向下转换，请使用.astype（t）方法。</target>
        </trans-unit>
        <trans-unit id="50dd3f94578e7376ef4b1fc5b09b342ebb1fed2e" translate="yes" xml:space="preserve">
          <source>The desired data-type for the matrix, default is float.</source>
          <target state="translated">矩阵的数据类型,默认为float。</target>
        </trans-unit>
        <trans-unit id="07d678da86d17478a0143d6947f08f3fa51a5f65" translate="yes" xml:space="preserve">
          <source>The desired data-type for the matrix, default is np.float64.</source>
          <target state="translated">矩阵的数据类型,默认为np.float64。</target>
        </trans-unit>
        <trans-unit id="d07509f4b4964e751a91c8805000083d2ee4926c" translate="yes" xml:space="preserve">
          <source>The desired data-type. By default, the data-type is determined from &lt;code&gt;formats&lt;/code&gt;, &lt;code&gt;names&lt;/code&gt;, &lt;code&gt;titles&lt;/code&gt;, &lt;code&gt;aligned&lt;/code&gt; and &lt;code&gt;byteorder&lt;/code&gt;.</source>
          <target state="translated">所需的数据类型。默认情况下，数据类型由 &lt;code&gt;formats&lt;/code&gt; ， &lt;code&gt;names&lt;/code&gt; ， &lt;code&gt;titles&lt;/code&gt; ， &lt;code&gt;aligned&lt;/code&gt; 和 &lt;code&gt;byteorder&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c998f357ef80cf65beb1c4220aff1c69081dd53" translate="yes" xml:space="preserve">
          <source>The desired shape of the array. If &lt;code&gt;mode == 'r'&lt;/code&gt; and the number of remaining bytes after &lt;code&gt;offset&lt;/code&gt; is not a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, you must specify &lt;a href=&quot;numpy.memmap.shape#numpy.memmap.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. By default, the returned array will be 1-D with the number of elements determined by file size and data-type.</source>
          <target state="translated">所需的阵列形状。如果 &lt;code&gt;mode == 'r'&lt;/code&gt; 和剩余字节后面的数字 &lt;code&gt;offset&lt;/code&gt; 不是字节大小的倍数&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;，你必须指定&lt;a href=&quot;numpy.memmap.shape#numpy.memmap.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;。默认情况下，返回的数组将为一维，其元素数由文件大小和数据类型确定。</target>
        </trans-unit>
        <trans-unit id="c217d27d3179585b289f1730298cd76c28917559" translate="yes" xml:space="preserve">
          <source>The desired shape of the array. If &lt;code&gt;mode == 'r'&lt;/code&gt; and the number of remaining bytes after &lt;code&gt;offset&lt;/code&gt; is not a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, you must specify &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. By default, the returned array will be 1-D with the number of elements determined by file size and data-type.</source>
          <target state="translated">所需的阵列形状。如果 &lt;code&gt;mode == 'r'&lt;/code&gt; 和剩余字节后面的数字 &lt;code&gt;offset&lt;/code&gt; 不是字节大小的倍数&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;，你必须指定&lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;。默认情况下，返回的数组将为一维，其元素数由文件大小和数据类型确定。</target>
        </trans-unit>
        <trans-unit id="cdd86af715375b55e1d483d875bf1753af5d922f" translate="yes" xml:space="preserve">
          <source>The desired shape of the iterator. This allows &lt;code&gt;allocate&lt;/code&gt; operands with a dimension mapped by op_axes not corresponding to a dimension of a different operand to get a value not equal to 1 for that dimension.</source>
          <target state="translated">所需的迭代器形状。这允许 &lt;code&gt;allocate&lt;/code&gt; 操作数具有与op_axes映射的维度不对应于另一个操作数的维度的操作数，以获取该维度的不等于1的值。</target>
        </trans-unit>
        <trans-unit id="84971317bba10bc74f9aaf650dccf1acca028d13" translate="yes" xml:space="preserve">
          <source>The desired, expected object.</source>
          <target state="translated">所需的、预期的对象。</target>
        </trans-unit>
        <trans-unit id="40c65673e654df212bffc77b7c4cf508b802ea94" translate="yes" xml:space="preserve">
          <source>The determinant is computed via LU factorization using the LAPACK routine &lt;code&gt;z/dgetrf&lt;/code&gt;.</source>
          <target state="translated">行列式使用LAPACK例程 &lt;code&gt;z/dgetrf&lt;/code&gt; 通过LU分解进行计算。</target>
        </trans-unit>
        <trans-unit id="94f9591a378d3f5d467509648f89e89bcee5af83" translate="yes" xml:space="preserve">
          <source>The determinant of a 2-D array &lt;code&gt;[[a, b], [c, d]]&lt;/code&gt; is &lt;code&gt;ad - bc&lt;/code&gt;:</source>
          <target state="translated">二维数组 &lt;code&gt;[[a, b], [c, d]]&lt;/code&gt; 的行列式为 &lt;code&gt;ad - bc&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="67af8ebad34e1dbafff04ba3dd64dccd7934523b" translate="yes" xml:space="preserve">
          <source>The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:</source>
          <target state="translated">二维数组[[a,b],[c,d]]的行列式为ad-bc。</target>
        </trans-unit>
        <trans-unit id="e56bde2e38a2da31d0e2d0f24b802753579a52ca" translate="yes" xml:space="preserve">
          <source>The determinant of a square Vandermonde matrix is the product of the differences between the values of the input vector:</source>
          <target state="translated">方范德蒙德矩阵的行列式是输入向量值之间的差值的乘积。</target>
        </trans-unit>
        <trans-unit id="60279460274321ba74cf96556a38bac9a87c73c6" translate="yes" xml:space="preserve">
          <source>The diagonal and diag functions return readonly views.</source>
          <target state="translated">diagonal和diag函数返回只读视图。</target>
        </trans-unit>
        <trans-unit id="34c13c034ad3086185d61530fb01b7940b4e4527" translate="yes" xml:space="preserve">
          <source>The dictionary contains three keys:</source>
          <target state="translated">该字典包含三个键。</target>
        </trans-unit>
        <trans-unit id="7980c83ed9b10778dab7b594015b0c4b8c1b820c" translate="yes" xml:space="preserve">
          <source>The dictionary has two required keys, &amp;lsquo;names&amp;rsquo; and &amp;lsquo;formats&amp;rsquo;, and four optional keys, &amp;lsquo;offsets&amp;rsquo;, &amp;lsquo;itemsize&amp;rsquo;, &amp;lsquo;aligned&amp;rsquo; and &amp;lsquo;titles&amp;rsquo;. The values for &amp;lsquo;names&amp;rsquo; and &amp;lsquo;formats&amp;rsquo; should respectively be a list of field names and a list of dtype specifications, of the same length. The optional &amp;lsquo;offsets&amp;rsquo; value should be a list of integer byte-offsets, one for each field within the structure. If &amp;lsquo;offsets&amp;rsquo; is not given the offsets are determined automatically. The optional &amp;lsquo;itemsize&amp;rsquo; value should be an integer describing the total size in bytes of the dtype, which must be large enough to contain all the fields.</source>
          <target state="translated">该词典有两个必需的键：&amp;ldquo;名称&amp;rdquo;和&amp;ldquo;格式&amp;rdquo;，以及四个可选键，&amp;ldquo;偏移&amp;rdquo;，&amp;ldquo; itemsize&amp;rdquo;，&amp;ldquo; aligned&amp;rdquo;和&amp;ldquo; titles&amp;rdquo;。&amp;ldquo;名称&amp;rdquo;和&amp;ldquo;格式&amp;rdquo;的值应分别是字段名称的列表和dtype规范的列表，且长度相同。可选的&amp;ldquo;偏移量&amp;rdquo;值应该是整数字节偏移量的列表，该偏移量对应于结构中的每个字段。如果未给出&amp;ldquo;偏移&amp;rdquo;，则自动确定偏移。可选的&amp;ldquo; itemsize&amp;rdquo;值应为整数，以dtype为单位描述总大小，该大小必须足够大以包含所有字段。</target>
        </trans-unit>
        <trans-unit id="bd944e951e9799c3343f288ae6c347a06ac11e23" translate="yes" xml:space="preserve">
          <source>The dictionary is indexed by keys that are the names of the fields. Each entry in the dictionary is a tuple fully describing the field:</source>
          <target state="translated">该字典以字段名称的键为索引。字典中的每个条目都是一个元组,全面描述了该字段。</target>
        </trans-unit>
        <trans-unit id="fc72cbc84ea7846d80156db81f03031e6342d2d0" translate="yes" xml:space="preserve">
          <source>The dictionary with build information.</source>
          <target state="translated">构建信息的字典。</target>
        </trans-unit>
        <trans-unit id="88918f47eb3cf48e5a0737e099c91aa35bc38894" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the next smallest representable float larger than 1.0. For example, for 64-bit binary floats in the IEEE-754 standard, &lt;code&gt;eps = 2**-52&lt;/code&gt;, approximately 2.22e-16.</source>
          <target state="translated">1.0与下一个最小可表示浮点之间的差大于1.0。例如，对于IEEE-754标准中的64位二进制浮点数， &lt;code&gt;eps = 2**-52&lt;/code&gt; ，大约为2.22e-16。</target>
        </trans-unit>
        <trans-unit id="c1d6f22ac980a152a56489087bf48f813ef3afe4" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the next smallest representable float less than 1.0. For example, for 64-bit binary floats in the IEEE-754 standard, &lt;code&gt;epsneg = 2**-53&lt;/code&gt;, approximately 1.11e-16.</source>
          <target state="translated">1.0与下一个最小可表示浮点之间的差小于1.0。例如，对于IEEE-754标准中的64位二进制浮点数， &lt;code&gt;epsneg = 2**-53&lt;/code&gt; ，大约为1.11e-16。</target>
        </trans-unit>
        <trans-unit id="162f606f6e0310c46fbb8198beb3cd00b92c6224" translate="yes" xml:space="preserve">
          <source>The difference of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 之差，按元素进行。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="07942ea7f660d79ad7e6e73de1169306977fb28a" translate="yes" xml:space="preserve">
          <source>The differences between consecutive elements of an array.</source>
          <target state="translated">数组中连续元素之间的差异。</target>
        </trans-unit>
        <trans-unit id="f62761da3d9dc37e999ceb43677343bc26056903" translate="yes" xml:space="preserve">
          <source>The differences. Loosely, this is &lt;code&gt;ary.flat[1:] - ary.flat[:-1]&lt;/code&gt;.</source>
          <target state="translated">差异。 &lt;code&gt;ary.flat[1:] - ary.flat[:-1]&lt;/code&gt; 地，这是ary.flat [1：]-ary.flat [：-1]。</target>
        </trans-unit>
        <trans-unit id="e2f3cc77955898f687e1a89336e253a34038e978" translate="yes" xml:space="preserve">
          <source>The different types of interpolation can be visualized graphically:</source>
          <target state="translated">不同类型的插值可以用图形可视化。</target>
        </trans-unit>
        <trans-unit id="0f5b79f9447070c03232c2c0b7664e2645b9b9cd" translate="yes" xml:space="preserve">
          <source>The dimension over which bit-packing is done. &lt;code&gt;None&lt;/code&gt; implies packing the flattened array.</source>
          <target state="translated">完成位打包的尺寸。 &lt;code&gt;None&lt;/code&gt; 表示打包扁平化数组。</target>
        </trans-unit>
        <trans-unit id="dfa565d5af13bd83cac275f338d5f2b3b4b7544c" translate="yes" xml:space="preserve">
          <source>The dimension over which bit-unpacking is done. &lt;code&gt;None&lt;/code&gt; implies unpacking the flattened array.</source>
          <target state="translated">展开位的尺寸。 &lt;code&gt;None&lt;/code&gt; 表示解压缩展平的数组。</target>
        </trans-unit>
        <trans-unit id="db3013243a57c5e7a96cffb61f2f631ca09ac6ac" translate="yes" xml:space="preserve">
          <source>The dimensionality of each input/output of an elementary function is defined by its core dimensions (zero core dimensions correspond to a scalar input/output). The core dimensions are mapped to the last dimensions of the input/output arrays.</source>
          <target state="translated">一个基本函数的每个输入/输出的维度由它的核心维度定义(核心维度为零对应一个标量输入/输出)。核心维度被映射到输入/输出数组的最后维度。</target>
        </trans-unit>
        <trans-unit id="bbd2ce0767215831bee7913f7b1f8113fac9632a" translate="yes" xml:space="preserve">
          <source>The dimensionality of the output is equal to the greatest of: * the dimensionality of all the inputs * the depth to which the input list is nested</source>
          <target state="translated">输出的维度等于以下两项中的最大一项。*所有输入的维度*输入列表的嵌套深度。</target>
        </trans-unit>
        <trans-unit id="169b189aee12891e66fa6116bc6ee28490426b80" translate="yes" xml:space="preserve">
          <source>The dimensions beyond the core dimensions are called &amp;ldquo;loop&amp;rdquo; dimensions. In the above example, this corresponds to &lt;code&gt;(3, 5)&lt;/code&gt;.</source>
          <target state="translated">超出核心尺寸的尺寸称为&amp;ldquo;环形&amp;rdquo;尺寸。在上面的示例中，这对应于 &lt;code&gt;(3, 5)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f513b3b85fff0b6f84da786029bafd05ba0e618b" translate="yes" xml:space="preserve">
          <source>The dimensions of the iterator.</source>
          <target state="translated">迭代器的尺寸。</target>
        </trans-unit>
        <trans-unit id="5ecf20054a40c0975aa34c7a074c143c2ad5eb76" translate="yes" xml:space="preserve">
          <source>The dimensions of the returned array, must be non-negative. If no argument is given a single Python float is returned.</source>
          <target state="translated">返回数组的维数,必须是非负数。如果没有给出参数,则返回一个Python float。</target>
        </trans-unit>
        <trans-unit id="1962b62fe3553b6c10eaad6d82d38bd0027b1eca" translate="yes" xml:space="preserve">
          <source>The direction where to look for the next representable value of &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">查找 &lt;code&gt;x1&lt;/code&gt; 的下一个可表示值的方向。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="712dcab95da2336dfeef7d45bac02b258dccf977" translate="yes" xml:space="preserve">
          <source>The discount rate.</source>
          <target state="translated">贴现率;</target>
        </trans-unit>
        <trans-unit id="0706686baa5fd5b913d978e6a5e5bd325098b037" translate="yes" xml:space="preserve">
          <source>The discrete convolution operation is defined as</source>
          <target state="translated">离散卷积运算定义为</target>
        </trans-unit>
        <trans-unit id="0c3ebfde94166d29a8529279eac1b981ebfd74c7" translate="yes" xml:space="preserve">
          <source>The distance between a value and the nearest adjacent number</source>
          <target state="translated">一个值与最近的相邻数之间的距离。</target>
        </trans-unit>
        <trans-unit id="eb9069c190fd0543a41e23dc5a8c21be130414b2" translate="yes" xml:space="preserve">
          <source>The docstring consists of a number of sections separated by headings (except for the deprecation warning). Each heading should be underlined in hyphens, and the section ordering should be consistent with the description below.</source>
          <target state="translated">docstring 由一些由标题分隔的章节组成(除了废弃警告)。每个标题都应该用连字符下划线,章节顺序应该与下面的描述一致。</target>
        </trans-unit>
        <trans-unit id="12a1ae320e29367bfe14ad50414fe949007c38e7" translate="yes" xml:space="preserve">
          <source>The docstring for the function. If &lt;code&gt;None&lt;/code&gt;, the docstring will be the &lt;code&gt;pyfunc.__doc__&lt;/code&gt;.</source>
          <target state="translated">该函数的文档字符串。如果为 &lt;code&gt;None&lt;/code&gt; ，则文档字符串将为 &lt;code&gt;pyfunc.__doc__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f20cb6df02e7c9d27955f240a3eb4c2a8d28a69" translate="yes" xml:space="preserve">
          <source>The docstring for the function. If None, the docstring will be the &lt;code&gt;pyfunc.__doc__&lt;/code&gt;.</source>
          <target state="translated">该函数的文档字符串。如果为None，则文档字符串将为 &lt;code&gt;pyfunc.__doc__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72a23a7f9d3c84d9ccb7d9d4e76905cf07195965" translate="yes" xml:space="preserve">
          <source>The docstring is taken from the input function to &lt;a href=&quot;#numpy.vectorize&quot;&gt;&lt;code&gt;vectorize&lt;/code&gt;&lt;/a&gt; unless it is specified:</source>
          <target state="translated">除非已指定，否则从输入函数获取文档字符串以进行&lt;a href=&quot;#numpy.vectorize&quot;&gt; &lt;code&gt;vectorize&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="023ac00b221ccc43e93743f0d35932950774168c" translate="yes" xml:space="preserve">
          <source>The doctests are run as if they are in a fresh Python instance which has executed &lt;code&gt;import numpy as np&lt;/code&gt;. Tests that are part of a NumPy subpackage will have that subpackage already imported. E.g. for a test in &lt;code&gt;numpy/linalg/tests/&lt;/code&gt;, the namespace will be created such that &lt;code&gt;from numpy import linalg&lt;/code&gt; has already executed.</source>
          <target state="translated">doctest的运行就像在新的Python实例中一样，该实例已执行 &lt;code&gt;import numpy as np&lt;/code&gt; 。作为NumPy子程序包一部分的测试将具有已导入的子程序包。例如，对于 &lt;code&gt;numpy/linalg/tests/&lt;/code&gt; 中的测试，将创建名称空间，以便已经 &lt;code&gt;from numpy import linalg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82bd10e4e262158659ec5e27575297c3e33fb51b" translate="yes" xml:space="preserve">
          <source>The doctests are run as if they are in a fresh Python instance which has executed &lt;code&gt;import numpy as np&lt;/code&gt;. Tests that are part of a SciPy subpackage will have that subpackage already imported. E.g. for a test in &lt;code&gt;scipy/linalg/tests/&lt;/code&gt;, the namespace will be created such that &lt;code&gt;from scipy import linalg&lt;/code&gt; has already executed.</source>
          <target state="translated">像运行doctest一样，就像在新的Python实例中一样，该实例已执行 &lt;code&gt;import numpy as np&lt;/code&gt; 。作为SciPy子程序包一部分的测试将具有已导入的子程序包。例如，对于 &lt;code&gt;scipy/linalg/tests/&lt;/code&gt; 中的测试，将创建名称空间， &lt;code&gt;from scipy import linalg&lt;/code&gt; 已经从scipy导入linalg。</target>
        </trans-unit>
        <trans-unit id="4e34de0083248d68455464ce3b6cb6cff4a615e4" translate="yes" xml:space="preserve">
          <source>The doctests can be run by adding the &lt;code&gt;doctests&lt;/code&gt; argument to the &lt;code&gt;test()&lt;/code&gt; call; for example, to run all tests (including doctests) for numpy.lib:</source>
          <target state="translated">可以通过将 &lt;code&gt;doctests&lt;/code&gt; 参数添加到 &lt;code&gt;test()&lt;/code&gt; 调用来运行doctest。例如，运行numpy.lib的所有测试（包括doctests）：</target>
        </trans-unit>
        <trans-unit id="914dd900bd888e0ac2a856c709956c6c77b685df" translate="yes" xml:space="preserve">
          <source>The doctests can be run by the user/developer by adding the &lt;code&gt;doctests&lt;/code&gt; argument to the &lt;code&gt;test()&lt;/code&gt; call. For example, to run all tests (including doctests) for &lt;code&gt;numpy.lib&lt;/code&gt;:</source>
          <target state="translated">通过将 &lt;code&gt;doctests&lt;/code&gt; 参数添加到 &lt;code&gt;test()&lt;/code&gt; 调用，用户/开发人员可以运行doctest。例如，运行所有测试（包括文档测试）为 &lt;code&gt;numpy.lib&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f8aa7b1eda9c3eb10663105fc5334308467be1f5" translate="yes" xml:space="preserve">
          <source>The documentation for NumPy distributed at &lt;a href=&quot;https://numpy.org/doc&quot;&gt;https://numpy.org/doc&lt;/a&gt; in html and pdf format is also built with &lt;code&gt;make dist&lt;/code&gt;. See &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/HOWTO_RELEASE.rst.txt&quot;&gt;HOWTO RELEASE&lt;/a&gt; for details on how to update &lt;a href=&quot;https://numpy.org/doc&quot;&gt;https://numpy.org/doc&lt;/a&gt;.</source>
          <target state="translated">NumPy的文档也以 &lt;code&gt;make dist&lt;/code&gt; 的形式在&lt;a href=&quot;https://numpy.org/doc&quot;&gt;https://numpy.org/doc上&lt;/a&gt;以html和pdf格式分发。有关如何更新&lt;a href=&quot;https://numpy.org/doc&quot;&gt;https://numpy.org/doc的&lt;/a&gt;详细信息，请参见&lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/HOWTO_RELEASE.rst.txt&quot;&gt;HOWTO RELEASE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b422de92d847bc36480d44f7ae27cfbb5060f6f" translate="yes" xml:space="preserve">
          <source>The documentation includes mathematical formulae with LaTeX formatting. A working LaTeX document production system (e.g. &lt;a href=&quot;https://www.tug.org/texlive/&quot;&gt;texlive&lt;/a&gt;) is required for the proper rendering of the LaTeX math in the documentation.</source>
          <target state="translated">该文档包含LaTeX格式的数学公式。需要正确运行LaTeX文档生产系统（例如&lt;a href=&quot;https://www.tug.org/texlive/&quot;&gt;texlive&lt;/a&gt;），才能正确呈现文档中的LaTeX数学。</target>
        </trans-unit>
        <trans-unit id="400ca1ed6dc999bcaec7408745f9b97e9991d699" translate="yes" xml:space="preserve">
          <source>The documentation is written in restructuredText, which is the format required by Sphinx, the tool most Python projects use to automatically build and link the documentation within the project. You can read the &lt;a href=&quot;https://docutils.sourceforge.io/docs/user/rst/quickref.html&quot;&gt;Quick reStructuredText Guide&lt;/a&gt; or the &lt;a href=&quot;http://www.sphinx-doc.org/en/stable/usage/restructuredtext/basics.html&quot;&gt;reStructuredText Primer&lt;/a&gt; for more information.</source>
          <target state="translated">该文档以restructuredText编写，这是Sphinx所需的格式，Sphinx是大多数Python项目用来在项目内自动构建和链接文档的工具。您可以阅读《&lt;a href=&quot;https://docutils.sourceforge.io/docs/user/rst/quickref.html&quot;&gt;快速reStructuredText指南》&lt;/a&gt;或《&lt;a href=&quot;http://www.sphinx-doc.org/en/stable/usage/restructuredtext/basics.html&quot;&gt;reStructuredText入门》&lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="b01857d163ce7be746891e6a1ddb4df8d280228b" translate="yes" xml:space="preserve">
          <source>The domain of the converted series. If the value is None, the default domain of &lt;code&gt;kind&lt;/code&gt; is used.</source>
          <target state="translated">转换后的系列的域。如果值为&amp;ldquo;无&amp;rdquo;，则使用默认的 &lt;code&gt;kind&lt;/code&gt; 域。</target>
        </trans-unit>
        <trans-unit id="3910d27792e65700eaf0cb459a12293f622c5605" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape (size, alpha.ndim).</source>
          <target state="translated">绘制的样本,形状(大小,alpha.ndim)。</target>
        </trans-unit>
        <trans-unit id="3a196841b4dbf99e3d83d366571811ca5768d106" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape &lt;code&gt;(size, k)&lt;/code&gt;.</source>
          <target state="translated">绘制的样本，形状为 &lt;code&gt;(size, k)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="caba47af25cacb65ea654dc8b3910b7df6c6afc4" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape &lt;em&gt;size&lt;/em&gt;, if that was provided. If not, the shape is &lt;code&gt;(N,)&lt;/code&gt;.</source>
          <target state="translated">如果提供的话，抽取的样品的形状为&lt;em&gt;大小&lt;/em&gt;。如果不是，则形状为 &lt;code&gt;(N,)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40b0e929b6fe8b38b46b38ce838182fe7c7332dc" translate="yes" xml:space="preserve">
          <source>The drawn samples.</source>
          <target state="translated">抽到的样品。</target>
        </trans-unit>
        <trans-unit id="7c49825e402bb2a6069cc023cee23e3ad1ab0d7c" translate="yes" xml:space="preserve">
          <source>The dtype object also has a dictionary-like attribute, &lt;code&gt;fields&lt;/code&gt;, whose keys are the field names (and &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt;, see below) and whose values are tuples containing the dtype and byte offset of each field.</source>
          <target state="translated">dtype对象还具有类似于字典的属性， &lt;code&gt;fields&lt;/code&gt; ，其键是字段名称（和&lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt;，请参见下文），其值是包含每个字段的dtype和字节偏移量的元组。</target>
        </trans-unit>
        <trans-unit id="c6189579f1415b7585848cd7c90a8ab21f324db6" translate="yes" xml:space="preserve">
          <source>The dtype object, which must be a &lt;a href=&quot;../arrays.scalars#numpy.datetime64&quot;&gt;&lt;code&gt;datetime64&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../arrays.scalars#numpy.timedelta64&quot;&gt;&lt;code&gt;timedelta64&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">dtype对象，必须是&lt;a href=&quot;../arrays.scalars#numpy.datetime64&quot;&gt; &lt;code&gt;datetime64&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../arrays.scalars#numpy.timedelta64&quot;&gt; &lt;code&gt;timedelta64&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="aa44e17b8461776ae7df4f43d6abddd8f6a24f76" translate="yes" xml:space="preserve">
          <source>The dtype object, which must be a &lt;code&gt;datetime64&lt;/code&gt; or &lt;code&gt;timedelta64&lt;/code&gt; type.</source>
          <target state="translated">dtype对象，必须是 &lt;code&gt;datetime64&lt;/code&gt; 或 &lt;code&gt;timedelta64&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="8fb6faafe66ffccb238a2fd43e44c5a7f5fbd5ca" translate="yes" xml:space="preserve">
          <source>The dtype of the masked array matches the dtype of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">掩码数组的dtype与 &lt;code&gt;arr&lt;/code&gt; 的dtype相匹配。</target>
        </trans-unit>
        <trans-unit id="1cb33880062e286521366b55fc98dd4daef4b644" translate="yes" xml:space="preserve">
          <source>The dtype of the output unstructured array.</source>
          <target state="translated">非结构化数组的输出类型。</target>
        </trans-unit>
        <trans-unit id="a55d71e165e1e48cb124a8472e43c4880e17aca7" translate="yes" xml:space="preserve">
          <source>The dtype to convert</source>
          <target state="translated">要转换的dtype</target>
        </trans-unit>
        <trans-unit id="5ecd0c1cb739e638a2efc7fc65026ccc752fcf9a" translate="yes" xml:space="preserve">
          <source>The dtype to convert.</source>
          <target state="translated">要转换的dtype。</target>
        </trans-unit>
        <trans-unit id="0d0946ed17f6fb426bc55c84df183c8474945340" translate="yes" xml:space="preserve">
          <source>The dummy argument is not used in this context and can be safely ignored. The &lt;em&gt;args&lt;/em&gt; argument contains all of the arguments passed in to the function as a tuple. You can do anything you want at this point, but usually the easiest way to manage the input arguments is to call &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; (args, format_string, addresses_to_C_variables&amp;hellip;) or &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_UnpackTuple&quot;&gt;&lt;code&gt;PyArg_UnpackTuple&lt;/code&gt;&lt;/a&gt; (tuple, &amp;ldquo;name&amp;rdquo;, min, max, &amp;hellip;). A good description of how to use the first function is contained in the Python C-API reference manual under section 5.5 (Parsing arguments and building values). You should pay particular attention to the &amp;ldquo;O&amp;amp;&amp;rdquo; format which uses converter functions to go between the Python object and the C object. All of the other format functions can be (mostly) thought of as special cases of this general rule. There are several converter functions defined in the NumPy C-API that may be of use. In particular, the &lt;a href=&quot;../reference/c-api/array#c.PyArray_DescrConverter&quot;&gt;&lt;code&gt;PyArray_DescrConverter&lt;/code&gt;&lt;/a&gt; function is very useful to support arbitrary data-type specification. This function transforms any valid data-type Python object into a &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; object. Remember to pass in the address of the C-variables that should be filled in.</source>
          <target state="translated">在此上下文中不使用dummy参数，可以安全地将其忽略。该&lt;em&gt;ARGS&lt;/em&gt;参数包含所有的到的功能作为一个元组传递的参数。您现在可以执行任何操作，但通常最简单的管理输入参数的方法是调用&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt;（args，format_string，&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_UnpackTuple&quot;&gt; &lt;code&gt;PyArg_UnpackTuple&lt;/code&gt; &lt;/a&gt; &amp;hellip;）或PyArg_UnpackTuple（元组，&amp;ldquo;名称&amp;rdquo;，最小，最大...）。 Python C-API参考手册第5.5节（解析参数和构建值）中包含有关如何使用第一个函数的详细说明。您应该特别注意&amp;ldquo; O＆&amp;rdquo;格式，该格式使用转换器函数在Python对象和C对象之间移动。所有其他格式函数都可以（通常）被视为该通用规则的特殊情况。在NumPy C-API中定义了一些可能有用的转换器函数。特别是，&lt;a href=&quot;../reference/c-api/array#c.PyArray_DescrConverter&quot;&gt; &lt;code&gt;PyArray_DescrConverter&lt;/code&gt; &lt;/a&gt;函数对于支持任意数据类型规范非常有用。此函数将任何有效的数据类型Python对象转换为&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr *&lt;/code&gt; &lt;/a&gt;对象。切记传递应填写的C变量的地址。</target>
        </trans-unit>
        <trans-unit id="dcd01c48a9de1d18adee046a1ef49445b20e2304" translate="yes" xml:space="preserve">
          <source>The ease of implementing mathematical formulas that work on arrays is one of the things that make NumPy so widely used in the scientific Python community.</source>
          <target state="translated">在数组上轻松实现数学公式是NumPy在科学Python社区中广泛使用的原因之一。</target>
        </trans-unit>
        <trans-unit id="0624587fa2f7d6454c0f9d5829dab19d01e4bd1b" translate="yes" xml:space="preserve">
          <source>The easiest way to understand the situation may be to think in terms of the result shape. There are two parts to the indexing operation, the subspace defined by the basic indexing (excluding integers) and the subspace from the advanced indexing part. Two cases of index combination need to be distinguished:</source>
          <target state="translated">最简单的理解方式可能是从结果形状来考虑。索引操作有两个部分,一个是基本索引定义的子空间(不包括整数),一个是来自高级索引部分的子空间。需要区分索引组合的两种情况。</target>
        </trans-unit>
        <trans-unit id="f92b730683a3cb47168faa379ee22ac3235eed0f" translate="yes" xml:space="preserve">
          <source>The easy way to do conversions between polynomial basis sets is to use the convert method of a class instance.</source>
          <target state="translated">在多项式基集之间进行转换的简单方法是使用类实例的转换方法。</target>
        </trans-unit>
        <trans-unit id="7ad876c221bb9757cd689d05f17e08510f826f3e" translate="yes" xml:space="preserve">
          <source>The edges retuned by &lt;code&gt;histogram`&lt;/code&gt; and &lt;code&gt;histogramdd&lt;/code&gt; now match the data float type</source>
          <target state="translated">通过 &lt;code&gt;histogram`&lt;/code&gt; 和 &lt;code&gt;histogramdd&lt;/code&gt; 重新调整的边现在与数据浮动类型匹配</target>
        </trans-unit>
        <trans-unit id="2fc5d8b78173f52a2c49af3f59f052a25e59fb4f" translate="yes" xml:space="preserve">
          <source>The edges to pass into &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt;的边缘</target>
        </trans-unit>
        <trans-unit id="d2d8a6b76e19500caa5bf07c8a328b68c38bc616" translate="yes" xml:space="preserve">
          <source>The editing workflow</source>
          <target state="translated">编辑工作流程</target>
        </trans-unit>
        <trans-unit id="b6f1be0a37063a8a4026cc94c7cf86f62cf5bdd8" translate="yes" xml:space="preserve">
          <source>The effect of broadcasting.</source>
          <target state="translated">广播的效果。</target>
        </trans-unit>
        <trans-unit id="a34abd23a6e4bdf2596a3b4673affad53721777d" translate="yes" xml:space="preserve">
          <source>The eigenvalues are computed using LAPACK routines &lt;code&gt;_syevd&lt;/code&gt;, &lt;code&gt;_heevd&lt;/code&gt;.</source>
          <target state="translated">使用LAPACK例程 &lt;code&gt;_syevd&lt;/code&gt; ， &lt;code&gt;_heevd&lt;/code&gt; 计算特征值。</target>
        </trans-unit>
        <trans-unit id="7701e5ef9799c4995d19bac48ad9fa82db4dc5c5" translate="yes" xml:space="preserve">
          <source>The eigenvalues in ascending order, each repeated according to its multiplicity.</source>
          <target state="translated">按升序排列的特征值,每个特征值按其倍数重复。</target>
        </trans-unit>
        <trans-unit id="af42e28434cbe95fe6890df4d996c2c99e9b2481" translate="yes" xml:space="preserve">
          <source>The eigenvalues of real symmetric or complex Hermitian matrices are always real. &lt;a href=&quot;#rc702e98a756a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; The array &lt;code&gt;v&lt;/code&gt; of (column) eigenvectors is unitary and &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;dot(a, v[:, i]) = w[i] * v[:, i]&lt;/code&gt;.</source>
          <target state="translated">实对称或复Hermitian矩阵的特征值始终为实。&lt;a href=&quot;#rc702e98a756a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;（列）特征向量的数组 &lt;code&gt;v&lt;/code&gt; 是单一的，并且 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;w&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 满足等式 &lt;code&gt;dot(a, v[:, i]) = w[i] * v[:, i]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ff4d23698273b360b1d6366e444e95ea540f28f" translate="yes" xml:space="preserve">
          <source>The eigenvalues, each repeated according to its multiplicity. The eigenvalues are not necessarily ordered. The resulting array will be of complex type, unless the imaginary part is zero in which case it will be cast to a real type. When &lt;code&gt;a&lt;/code&gt; is real the resulting eigenvalues will be real (0 imaginary part) or occur in conjugate pairs</source>
          <target state="translated">特征值，每个特征值根据其多重性重复。特征值不一定是有序的。除非虚部为零，否则所得数组将为复杂类型，在这种情况下，它将被强制转换为实型。当 &lt;code&gt;a&lt;/code&gt; 为实数时，所得特征值将为实数（虚部为0）或出现在共轭对中</target>
        </trans-unit>
        <trans-unit id="9cfc7ae7c9df4df4270a01f781a7985d0061b823" translate="yes" xml:space="preserve">
          <source>The eigenvalues, each repeated according to its multiplicity. They are not necessarily ordered, nor are they necessarily real for real matrices.</source>
          <target state="translated">的特征值,每个特征值按其倍数重复。它们不一定是有序的,也不一定是实数矩阵的实数。</target>
        </trans-unit>
        <trans-unit id="fedbdf07c41c58b01420971d15b808683a8a1612" translate="yes" xml:space="preserve">
          <source>The eigenvalues/eigenvectors are computed using LAPACK routines &lt;code&gt;_syevd&lt;/code&gt;, &lt;code&gt;_heevd&lt;/code&gt;.</source>
          <target state="translated">使用LAPACK例程 &lt;code&gt;_syevd&lt;/code&gt; ， &lt;code&gt;_heevd&lt;/code&gt; 计算特征值/特征向量。</target>
        </trans-unit>
        <trans-unit id="672eac8f0267740479f9ff389b02d40f57b3ff35" translate="yes" xml:space="preserve">
          <source>The element inserted in &lt;code&gt;output&lt;/code&gt; when all conditions evaluate to False.</source>
          <target state="translated">当所有条件评估为False时，元素将插入 &lt;code&gt;output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c154db2e01512028a28319b3317262699278c799" translate="yes" xml:space="preserve">
          <source>The element size of this data-type object.</source>
          <target state="translated">该数据类型对象的元素大小。</target>
        </trans-unit>
        <trans-unit id="100849a009dc981ce005b4c12bbdd30342f43ac6" translate="yes" xml:space="preserve">
          <source>The element-wise remainder of the quotient &lt;code&gt;floor_divide(x1, x2)&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">商 &lt;code&gt;floor_divide(x1, x2)&lt;/code&gt; 的按元素的余数。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="55f57b3f397334c809b04b980612f0a5ab349a62" translate="yes" xml:space="preserve">
          <source>The elements are binary-valued (0 or 1).</source>
          <target state="translated">元素为二进制值(0或1)。</target>
        </trans-unit>
        <trans-unit id="4e3cc7c953fc2e3ea61645fad74045ef41161886" translate="yes" xml:space="preserve">
          <source>The elements in a NumPy array are all required to be of the same data type, and thus will be the same size in memory. The exception: one can have arrays of (Python, including NumPy) objects, thereby allowing for arrays of different sized elements.</source>
          <target state="translated">NumPy 数组中的元素都必须是相同的数据类型,因此在内存中的大小是相同的。例外的情况是:可以有(Python,包括NumPy)对象的数组,从而允许有不同大小的元素的数组。</target>
        </trans-unit>
        <trans-unit id="18d658a71c2e23e5ce04fb215c6cdc657f3c41d2" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;a&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;m&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">使用此索引顺序读取 &lt;code&gt;a&lt;/code&gt; 的元素。 &amp;ldquo; C&amp;rdquo;表示以类似C的顺序索引元素，最后一个轴索引更改最快，而返回到第一个轴索引更改最慢。 &amp;ldquo; F&amp;rdquo;表示以类似Fortran的索引顺序索引元素，第一个索引更改最快，最后一个索引更改最慢。请注意，&amp;ldquo; C&amp;rdquo;和&amp;ldquo; F&amp;rdquo;选项不考虑基础数组的内存布局，仅参考轴索引的顺序。如果 &lt;code&gt;m&lt;/code&gt; 在内存中是&lt;em&gt;连续的&lt;/em&gt; Fortran，则&amp;ldquo; A&amp;rdquo;表示以类似于Fortran的索引顺序读取元素，否则为类似于C的顺序。 &amp;ldquo; K&amp;rdquo;表示按顺序在内存中读取元素，但当步幅为负时反转数据除外。默认情况下，使用&amp;ldquo; C&amp;rdquo;索引顺序。</target>
        </trans-unit>
        <trans-unit id="27ccf6e9acce055e532ad81d9bdd8638f9a4a262" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;a&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in row-major, C-style order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in column-major, Fortran-style order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;a&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">使用此索引顺序读取 &lt;code&gt;a&lt;/code&gt; 的元素。&amp;ldquo; C&amp;rdquo;表示以行优先，C样式的顺序索引元素，最后一个轴索引更改最快，回到第一个轴索引更改最慢。&amp;ldquo; F&amp;rdquo;表示以Fortran样式的列主顺序索引元素，第一个索引变化最快，最后一个索引变化最慢。请注意，&amp;ldquo; C&amp;rdquo;和&amp;ldquo; F&amp;rdquo;选项不考虑基础数组的内存布局，仅参考轴索引的顺序。如果 &lt;code&gt;a&lt;/code&gt; 是&lt;em&gt;连续的&lt;/em&gt; Fortran，则&amp;ldquo; A&amp;rdquo;表示以类似于Fortran的索引顺序读取元素&lt;em&gt;&lt;/em&gt;在内存中，否则类似C的顺序。&amp;ldquo; K&amp;rdquo;表示按步在内存中的顺序读取元素，但步幅为负时反转数据除外。默认情况下，使用&amp;ldquo; C&amp;rdquo;索引顺序。</target>
        </trans-unit>
        <trans-unit id="8bfe90d8bb9b3a44603b03bac0e42210874e7808" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;m&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;m&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">使用此索引顺序读取 &lt;code&gt;m&lt;/code&gt; 的元素。 &amp;ldquo; C&amp;rdquo;表示以类似C的顺序索引元素，最后一个轴索引更改最快，而返回到第一个轴索引更改最慢。 &amp;ldquo; F&amp;rdquo;表示以类似Fortran的索引顺序索引元素，第一个索引更改最快，最后一个索引更改最慢。请注意，&amp;ldquo; C&amp;rdquo;和&amp;ldquo; F&amp;rdquo;选项不考虑基础数组的内存布局，仅参考轴索引的顺序。如果 &lt;code&gt;m&lt;/code&gt; 在内存中是&lt;em&gt;连续的&lt;/em&gt; Fortran，则&amp;ldquo; A&amp;rdquo;表示以类似于Fortran的索引顺序读取元素，否则为类似于C的顺序。 &amp;ldquo; K&amp;rdquo;表示按顺序在内存中读取元素，但当步幅为负时反转数据除外。默认情况下，使用&amp;ldquo; C&amp;rdquo;索引顺序。</target>
        </trans-unit>
        <trans-unit id="d8d7a05ea4e76ed025da3efb7e37c3722ae9fddb" translate="yes" xml:space="preserve">
          <source>The elements of both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;a.T&lt;/code&gt; get traversed in the same order, namely the order they are stored in memory, whereas the elements of &lt;code&gt;a.T.copy(order=&amp;rsquo;C&amp;rsquo;)&lt;/code&gt; get visited in a different order because they have been put into a different memory layout.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;a.T&lt;/code&gt; 的元素以相同的顺序遍历，即它们存储在内存中的顺序，而 &lt;code&gt;a.T.copy(order=&amp;rsquo;C&amp;rsquo;)&lt;/code&gt; 的元素以不同的顺序访问，因为它们已放入不同的内存中布局。</target>
        </trans-unit>
        <trans-unit id="7c09282fb5ba8925fe26507ed54970dbeacf3bc3" translate="yes" xml:space="preserve">
          <source>The elements of the shape tuple give the lengths of the corresponding array dimensions.</source>
          <target state="translated">形状元组的元素给出了相应阵列尺寸的长度。</target>
        </trans-unit>
        <trans-unit id="d08dc6baf6d1de4ff7af87aa1f35d18925c1f47b" translate="yes" xml:space="preserve">
          <source>The elements of this structure are:</source>
          <target state="translated">这一结构的要素是:</target>
        </trans-unit>
        <trans-unit id="c3ccba03f1b5d3bd5cacb97014f1795b1e1620ff" translate="yes" xml:space="preserve">
          <source>The ellipsis syntax maybe used to indicate selecting in full any remaining unspecified dimensions. For example:</source>
          <target state="translated">省略号语法可以用来表示选择任何剩余的未指定的尺寸。例如:</target>
        </trans-unit>
        <trans-unit id="d0777cee700edf703f03cd8f123c44ac46b607f9" translate="yes" xml:space="preserve">
          <source>The end value of the sequence, unless &lt;code&gt;endpoint&lt;/code&gt; is set to False. In that case, the sequence consists of all but the last of &lt;code&gt;num + 1&lt;/code&gt; evenly spaced samples, so that &lt;code&gt;stop&lt;/code&gt; is excluded. Note that the step size changes when &lt;code&gt;endpoint&lt;/code&gt; is False.</source>
          <target state="translated">序列的最终值，除非将 &lt;code&gt;endpoint&lt;/code&gt; 设置为False。在这种情况下，该序列由除 &lt;code&gt;num + 1&lt;/code&gt; 均匀间隔的采样之外的所有采样组成，因此排除了 &lt;code&gt;stop&lt;/code&gt; 。请注意，当 &lt;code&gt;endpoint&lt;/code&gt; 为False 时，步长会更改。</target>
        </trans-unit>
        <trans-unit id="61c8a67ac747d5eb7d80852565d6317e805901a1" translate="yes" xml:space="preserve">
          <source>The endpoint of the interval can optionally be excluded.</source>
          <target state="translated">区间的端点可以选择排除。</target>
        </trans-unit>
        <trans-unit id="7c70e4957abd94f2cb0f87772d68554c90cbe5b2" translate="yes" xml:space="preserve">
          <source>The entropy for creating a &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">创建&lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;的熵。</target>
        </trans-unit>
        <trans-unit id="0807164c2e58b526f47d2a17d970242e2786a8ed" translate="yes" xml:space="preserve">
          <source>The enumeration value for ASCII strings of a selectable size. The strings have a fixed maximum size within a given array.</source>
          <target state="translated">可选择大小的ASCII字符串的枚举值。在一个给定的数组中,字符串有一个固定的最大尺寸。</target>
        </trans-unit>
        <trans-unit id="4486c486e9b2ccc0519632048cae0af33e6f2bea" translate="yes" xml:space="preserve">
          <source>The enumeration value for UCS4 strings of a selectable size. The strings have a fixed maximum size within a given array.</source>
          <target state="translated">可选择大小的UCS4字符串的枚举值。在给定的数组中,字符串有一个固定的最大尺寸。</target>
        </trans-unit>
        <trans-unit id="ceb80d4c945347bb465d428088d951fae89cf7e9" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 128-bit/16-byte complex type made up of two NPY_DOUBLE values.</source>
          <target state="translated">由两个NPY_DOUBLE值组成的128位/16字节复杂类型的枚举值。</target>
        </trans-unit>
        <trans-unit id="022dd3242a4f7ab9f354ab53434df9783dde262d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte IEEE 754-2008 compatible floating point type.</source>
          <target state="translated">16位/2字节IEEE 754-2008兼容浮点类型的枚举值。</target>
        </trans-unit>
        <trans-unit id="54200391c747968ffe444d868d0f00fe22c905a7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte signed integer.</source>
          <target state="translated">16位/2字节有符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="24e698054b91536d27ff27c354d21704b0ff5fa7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte unsigned integer.</source>
          <target state="translated">16位/2字节无符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="48c93b25a09888099a2fa0e8cc423bbdd97aec51" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte IEEE 754 compatible floating point type.</source>
          <target state="translated">32位/4字节IEEE 754兼容浮点类型的枚举值。</target>
        </trans-unit>
        <trans-unit id="0767688f1013b974d66b67bec323cce162186c28" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte signed integer.</source>
          <target state="translated">32位/4字节有符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="61e002f4aaa6d35ff73356572d5e52edd07749bc" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte unsigned integer.</source>
          <target state="translated">32位/4字节无符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="13bb2de2cc37c2d6613c3c408dc1f6c1a04bcaf7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte IEEE 754 compatible floating point type.</source>
          <target state="translated">64位/8字节IEEE 754兼容浮点类型的枚举值。</target>
        </trans-unit>
        <trans-unit id="712e85738302795b01166defaa51ce15d788398b" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte complex type made up of two NPY_FLOAT values.</source>
          <target state="translated">由两个NPY_FLOAT值组成的64位/8字节复杂类型的枚举值。</target>
        </trans-unit>
        <trans-unit id="6fcce91d25d23bb25fdb72e7335d026c8e38fbfa" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte signed integer.</source>
          <target state="translated">64位/8字节有符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="d2fd87ac5f2fe419cf576e3d1240b873a7fd353f" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte unsigned integer.</source>
          <target state="translated">64位/8字节无符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="7aee8554ea2f116b0ced362cc168497aed3b5e7d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a data type which holds dates or datetimes with a precision based on selectable date or time units.</source>
          <target state="translated">数据类型的枚举值,该数据类型持有日期或日期时间,其精度基于可选择的日期或时间单位。</target>
        </trans-unit>
        <trans-unit id="81373e1b16d0b1374953b29f2c2ce84e5c1e7ca6" translate="yes" xml:space="preserve">
          <source>The enumeration value for a data type which holds lengths of times in integers of selectable date or time units.</source>
          <target state="translated">数据类型的枚举值,它以可选择的日期或时间单位的整数来保存时间长度。</target>
        </trans-unit>
        <trans-unit id="025565ff9d1efa7089189ec4ae9c78d4afba6baf" translate="yes" xml:space="preserve">
          <source>The enumeration value for a platform-specific complex floating point type which is made up of two NPY_LONGDOUBLE values.</source>
          <target state="translated">平台特有的复杂浮点类型的枚举值,它由两个NPY_LONGDOUBLE值组成。</target>
        </trans-unit>
        <trans-unit id="02ee59a76dc8246cf577894e400f4aef4b3c2cdb" translate="yes" xml:space="preserve">
          <source>The enumeration value for a platform-specific floating point type which is at least as large as NPY_DOUBLE, but larger on many platforms.</source>
          <target state="translated">平台特定浮点类型的枚举值,它至少和NPY_DOUBLE一样大,但在许多平台上更大。</target>
        </trans-unit>
        <trans-unit id="12bd9d6078665b062a610e653e29b9b8b5cd0f4d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a signed integer type which is the same size as a (void *) pointer. This is the type used by all arrays of indices.</source>
          <target state="translated">有符号整数类型的枚举值,其大小与(void *)指针相同。这是所有指数数组使用的类型。</target>
        </trans-unit>
        <trans-unit id="1915b2aac968e6b707b08a802a86e659f6b7b54c" translate="yes" xml:space="preserve">
          <source>The enumeration value for an 8-bit/1-byte signed integer.</source>
          <target state="translated">8位/1字节有符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="e2cde6e55c74a7eec76c04ac7971b58aabed014c" translate="yes" xml:space="preserve">
          <source>The enumeration value for an 8-bit/1-byte unsigned integer.</source>
          <target state="translated">8位/1字节无符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="3bc60c39b304a6beb211c263d892c90730d59bf2" translate="yes" xml:space="preserve">
          <source>The enumeration value for an unsigned integer type which is the same size as a (void *) pointer.</source>
          <target state="translated">无符号整数类型的枚举值,其大小与(void *)指针相同。</target>
        </trans-unit>
        <trans-unit id="00cb2e716adb7d63188da00709d01e2a11b34089" translate="yes" xml:space="preserve">
          <source>The enumeration value for references to arbitrary Python objects.</source>
          <target state="translated">对任意 Python 对象引用的枚举值。</target>
        </trans-unit>
        <trans-unit id="dbec8c6917cdb1fb9cc672eba6fd415b762d7774" translate="yes" xml:space="preserve">
          <source>The enumeration value for the boolean type, stored as one byte. It may only be set to the values 0 and 1.</source>
          <target state="translated">布尔类型的枚举值,以一个字节的形式存储。它只能被设置为0和1。</target>
        </trans-unit>
        <trans-unit id="f6d7694b75b473ad222039c05e89641ad1c019cb" translate="yes" xml:space="preserve">
          <source>The enumeration value of the type used for masks, such as with the &lt;a href=&quot;c-api.iterator#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; iterator flag. This is equivalent to &lt;a href=&quot;#c.NPY_UINT8&quot;&gt;&lt;code&gt;NPY_UINT8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于掩码的类型的枚举值，例如带有&lt;a href=&quot;c-api.iterator#c.NPY_ITER_ARRAYMASK&quot;&gt; &lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt; &lt;/a&gt;迭代器标志的值。这等效于&lt;a href=&quot;#c.NPY_UINT8&quot;&gt; &lt;code&gt;NPY_UINT8&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="470c7c6a0fdea0ae871ac319202aa3679b0d2b38" translate="yes" xml:space="preserve">
          <source>The enumeration value of the type used for masks, such as with the &lt;a href=&quot;iterator#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; iterator flag. This is equivalent to &lt;a href=&quot;#c.NPY_UINT8&quot;&gt;&lt;code&gt;NPY_UINT8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于掩码的类型的枚举值，例如带有&lt;a href=&quot;iterator#c.NPY_ITER_ARRAYMASK&quot;&gt; &lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt; &lt;/a&gt;迭代器标志的枚举值。这等效于&lt;a href=&quot;#c.NPY_UINT8&quot;&gt; &lt;code&gt;NPY_UINT8&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="60104b59eca7223d2be466212e148860409e987c" translate="yes" xml:space="preserve">
          <source>The equivalent for floating point data types.</source>
          <target state="translated">浮点数据类型的等价物。</target>
        </trans-unit>
        <trans-unit id="4e36288c483218b6153f62263e1c19e0918537e1" translate="yes" xml:space="preserve">
          <source>The equivalent for integer data types.</source>
          <target state="translated">整数数据类型的等价物。</target>
        </trans-unit>
        <trans-unit id="f007c7cbd53c8448e809d2bc2019ae342707c904" translate="yes" xml:space="preserve">
          <source>The error also has additional information to help you troubleshoot:</source>
          <target state="translated">该错误还有额外的信息来帮助你排除故障。</target>
        </trans-unit>
        <trans-unit id="7c428e56ed9d259c349566498573b0b72cf82c45" translate="yes" xml:space="preserve">
          <source>The error mask is a single integer that holds the treatment information on all four floating point errors. The information for each error type is contained in three bits of the integer. If we print it in base 8, we can see what treatment is set for &amp;ldquo;invalid&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, and &amp;ldquo;divide&amp;rdquo; (in that order). The printed string can be interpreted with</source>
          <target state="translated">错误掩码是一个整数，其中包含所有四个浮点错误的处理信息。每种错误类型的信息都包含在整数的三位中。如果将其打印在基数8中，则可以看到对&amp;ldquo;无效&amp;rdquo;，&amp;ldquo;不足&amp;rdquo;，&amp;ldquo;上方&amp;rdquo;和&amp;ldquo;分隔&amp;rdquo;（按该顺序）设置了什么处理。打印的字符串可以用</target>
        </trans-unit>
        <trans-unit id="6236f64a81230ccb9458bf1fe006ba3279baed6f" translate="yes" xml:space="preserve">
          <source>The error message to be printed in case of failure.</source>
          <target state="translated">失败时要打印的错误信息。</target>
        </trans-unit>
        <trans-unit id="46e36d39518380daadad6b1e62b8973365b854c8" translate="yes" xml:space="preserve">
          <source>The error object contains all information that defines the error handling behavior in NumPy. &lt;a href=&quot;#numpy.geterrobj&quot;&gt;&lt;code&gt;geterrobj&lt;/code&gt;&lt;/a&gt; is used internally by the other functions that get and set error handling behavior (&lt;a href=&quot;numpy.geterr#numpy.geterr&quot;&gt;&lt;code&gt;geterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.geterrcall#numpy.geterrcall&quot;&gt;&lt;code&gt;geterrcall&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">错误对象包含所有在NumPy中定义错误处理行为的信息。&lt;a href=&quot;#numpy.geterrobj&quot;&gt; &lt;code&gt;geterrobj&lt;/code&gt; &lt;/a&gt;由获取和设置错误处理行为的其他函数（&lt;a href=&quot;numpy.geterr#numpy.geterr&quot;&gt; &lt;code&gt;geterr&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.geterrcall#numpy.geterrcall&quot;&gt; &lt;code&gt;geterrcall&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt;）在内部使用。</target>
        </trans-unit>
        <trans-unit id="d7bceac49145568dab2a83ccab3ab1eea9b12faf" translate="yes" xml:space="preserve">
          <source>The error object contains all information that defines the error handling behavior in NumPy. &lt;a href=&quot;#numpy.seterrobj&quot;&gt;&lt;code&gt;seterrobj&lt;/code&gt;&lt;/a&gt; is used internally by the other functions that set error handling behavior (&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">错误对象包含所有在NumPy中定义错误处理行为的信息。&lt;a href=&quot;#numpy.seterrobj&quot;&gt; &lt;code&gt;seterrobj&lt;/code&gt; &lt;/a&gt;由设置错误处理行为的其他函数（&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt;）在内部使用。</target>
        </trans-unit>
        <trans-unit id="717ffb083d9a010e39e00d26ae4cbb3686fdec82" translate="yes" xml:space="preserve">
          <source>The error object, a list containing three elements: [internal numpy buffer size, error mask, error callback function].</source>
          <target state="translated">错误对象,一个包含三个元素的列表。[内部numpy缓冲区大小,错误掩码,错误回调函数]。</target>
        </trans-unit>
        <trans-unit id="9f5b3632192f41c961bfe841ce3532fd1faa0967" translate="yes" xml:space="preserve">
          <source>The evaluation uses Clenshaw recursion, aka synthetic division.</source>
          <target state="translated">评价使用了克伦肖递归,也就是合成除法。</target>
        </trans-unit>
        <trans-unit id="9a7486fe20eefd44f8d5d46a29c17743d8baf71d" translate="yes" xml:space="preserve">
          <source>The evaluation uses Horner&amp;rsquo;s method.</source>
          <target state="translated">评估使用霍纳法。</target>
        </trans-unit>
        <trans-unit id="db5640fe4648623a565ed032ffc116fcc6e293bd" translate="yes" xml:space="preserve">
          <source>The exact definition of a slow test is obviously both subjective and hardware-dependent, but in general any individual test that requires more than a second or two should be labeled as slow (the whole suite consists of thousands of tests, so even a second is significant).</source>
          <target state="translated">对慢速测试的准确定义显然既是主观的,也是取决于硬件的,但一般来说,任何单个测试如果需要一两秒以上的时间,都应该被贴上慢速的标签(整个套件由数千个测试组成,所以即使是一秒也是很重要的)。</target>
        </trans-unit>
        <trans-unit id="0fe09946a84bc00c7ff87cc3c4856ae88e30a696" translate="yes" xml:space="preserve">
          <source>The example also demonstrates Cython&amp;rsquo;s &amp;ldquo;typed memoryviews&amp;rdquo;, which are like NumPy arrays at the C level, in the sense that they are shaped and strided arrays that know their own extent (unlike a C array addressed through a bare pointer). The syntax &lt;code&gt;double complex[:]&lt;/code&gt; denotes a one-dimensional array (vector) of doubles, with arbitrary strides. A contiguous array of ints would be &lt;code&gt;int[::1]&lt;/code&gt;, while a matrix of floats would be &lt;code&gt;float[:, :]&lt;/code&gt;.</source>
          <target state="translated">该示例还演示了Cython的&amp;ldquo;类型化内存视图&amp;rdquo;，类似于C级别的NumPy数组，从某种意义上来说，它们是形状和跨步的数组，它们知道自己的范围（与通过裸指针寻址的C数组不同）。语法 &lt;code&gt;double complex[:]&lt;/code&gt; 表示具有任意跨度的double的一维数组（向量）。一个连续的int数组将是 &lt;code&gt;int[::1]&lt;/code&gt; ，而一个 &lt;code&gt;float[:, :]&lt;/code&gt; 矩阵将是float [:,：]。</target>
        </trans-unit>
        <trans-unit id="d3927b62f1cd7d72e0062722877a649b50aac359" translate="yes" xml:space="preserve">
          <source>The example code may be split across multiple lines, with each line after the first starting with &amp;lsquo;&amp;hellip; &amp;lsquo;:</source>
          <target state="translated">示例代码可以分为多行，第一行之后的每一行均以&amp;ldquo; ...&amp;rdquo;开头：</target>
        </trans-unit>
        <trans-unit id="8115e6a09b482f0c6358ae004c18cbcff8dc56e9" translate="yes" xml:space="preserve">
          <source>The example header was dynamically generated by gcc on an X86 machine. The compiler supports &lt;code&gt;--cpu-baseline=&quot;sse sse2 sse3&quot;&lt;/code&gt; and &lt;code&gt;--cpu-dispatch=&quot;ssse3 sse41&quot;&lt;/code&gt;, and the result is below.</source>
          <target state="translated">示例标头是由X86计算机上的gcc动态生成的。编译器支持 &lt;code&gt;--cpu-baseline=&quot;sse sse2 sse3&quot;&lt;/code&gt; 和 &lt;code&gt;--cpu-dispatch=&quot;ssse3 sse41&quot;&lt;/code&gt; ，结果如下。</target>
        </trans-unit>
        <trans-unit id="3c6b68db229268c95185c669cea481b3a1f2e9b2" translate="yes" xml:space="preserve">
          <source>The examples may assume that &lt;code&gt;import numpy as np&lt;/code&gt; is executed before the example code in &lt;em&gt;numpy&lt;/em&gt;. Additional examples may make use of &lt;em&gt;matplotlib&lt;/em&gt; for plotting, but should import it explicitly, e.g., &lt;code&gt;import matplotlib.pyplot as plt&lt;/code&gt;. All other imports, including the demonstrated function, must be explicit.</source>
          <target state="translated">这些示例可以假定在&lt;em&gt;numpy中&lt;/em&gt;的示例代码之前执行了 &lt;code&gt;import numpy as np&lt;/code&gt; 。其他示例可能会使用&lt;em&gt;matplotlib&lt;/em&gt;进行绘图，但应显式导入它，例如， &lt;code&gt;import matplotlib.pyplot as plt&lt;/code&gt; 。所有其他导入（包括已演示的功能）必须是明确的。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a28216e8d502daba2aa9f77ed97bda4ac746a41" translate="yes" xml:space="preserve">
          <source>The exceptions to the above rules are given below:</source>
          <target state="translated">以下是上述规则的例外情况。</target>
        </trans-unit>
        <trans-unit id="ea2c7bd23b14b815638891431083c6a5af9b6f5a" translate="yes" xml:space="preserve">
          <source>The execution will now stop at the corresponding C function and you can step through it as usual. A number of useful Python-specific commands are available. For example to see where in the Python code you are, use &lt;code&gt;py-list&lt;/code&gt;. For more details, see &lt;a href=&quot;https://wiki.python.org/moin/DebuggingWithGdb&quot;&gt;DebuggingWithGdb&lt;/a&gt;. Here are some commonly used commands:</source>
          <target state="translated">现在，执行将在相应的C函数处停止，您可以照常单步执行。有许多有用的特定于Python的命令。例如，要查看您在Python代码中的位置，请使用 &lt;code&gt;py-list&lt;/code&gt; 。有关更多详细信息，请参见&lt;a href=&quot;https://wiki.python.org/moin/DebuggingWithGdb&quot;&gt;DebuggingWithGdb&lt;/a&gt;。以下是一些常用命令：</target>
        </trans-unit>
        <trans-unit id="8953035a1ae2630eb8257139de6a8432deef2d8b" translate="yes" xml:space="preserve">
          <source>The expected object.</source>
          <target state="translated">预期的对象。</target>
        </trans-unit>
        <trans-unit id="ec4e2a0cf38710bdb603b5d339066519f8b6c301" translate="yes" xml:space="preserve">
          <source>The expected string.</source>
          <target state="translated">预期的字符串。</target>
        </trans-unit>
        <trans-unit id="59f101f805e4afd5d4f5aac41091912e82f52cce" translate="yes" xml:space="preserve">
          <source>The exponent can be any integer or long integer, positive, negative, or zero.</source>
          <target state="translated">指数可以是任何整数或长整数,正数、负数或零。</target>
        </trans-unit>
        <trans-unit id="48bfe58fce3c9524a47514144118fc15384f8ce9" translate="yes" xml:space="preserve">
          <source>The exponent that yields &lt;code&gt;eps&lt;/code&gt;.</source>
          <target state="translated">产生 &lt;code&gt;eps&lt;/code&gt; 的指数。</target>
        </trans-unit>
        <trans-unit id="8728d1625b1f4800f5da44ea73eddec8a90b29f7" translate="yes" xml:space="preserve">
          <source>The exponent that yields &lt;code&gt;epsneg&lt;/code&gt;.</source>
          <target state="translated">产生 &lt;code&gt;epsneg&lt;/code&gt; 的指数。</target>
        </trans-unit>
        <trans-unit id="3d2aac84d1e998e3af66433136551e2122fcd6db" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#r0dbb9b01ef9c-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#r0dbb9b01ef9c-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">指数分布是几何分布的连续模拟。它描述了许多常见的情况，例如在多次暴风雨中测得的雨滴的大小&lt;a href=&quot;#r0dbb9b01ef9c-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;或到Wikipedia的页面请求之间的时间&lt;a href=&quot;#r0dbb9b01ef9c-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="379909a59d38e5f49bfe83c94188ec2a18000b03" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#r3cbd6af2d0d3-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#r3cbd6af2d0d3-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">指数分布是几何分布的连续类似物。它描述了许多常见的情况，例如在多次暴风雨中测得的雨滴的大小&lt;a href=&quot;#r3cbd6af2d0d3-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;或到Wikipedia的页面请求之间的时间&lt;a href=&quot;#r3cbd6af2d0d3-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae0234d51209697de2e3092417cea04cdd633ab5" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#rcf497e7bc958-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#rcf497e7bc958-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">指数分布是几何分布的连续模拟。它描述了许多常见的情况，例如在多次暴风雨中测得的雨滴的大小&lt;a href=&quot;#rcf497e7bc958-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;或到Wikipedia的页面请求之间的时间&lt;a href=&quot;#rcf497e7bc958-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d68d926a5db1e2f83fa605bc0a4678131d567b9" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#rcfd3e98ffb09-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#rcfd3e98ffb09-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">指数分布是几何分布的连续类似物。它描述了许多常见的情况，例如在多次暴风雨中测得的雨滴的大小&lt;a href=&quot;#rcfd3e98ffb09-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;或到Wikipedia的页面请求之间的时间&lt;a href=&quot;#rcfd3e98ffb09-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33ed180d63f4fd6bda2a99808d388e4ba0b2acb0" translate="yes" xml:space="preserve">
          <source>The exponents. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">指数。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="4a0678b00019c9d465c7278be4782e4ae402fa1c" translate="yes" xml:space="preserve">
          <source>The expression within brackets in &lt;code&gt;b[i]&lt;/code&gt; is treated as an &lt;code&gt;i&lt;/code&gt; followed by as many instances of &lt;code&gt;:&lt;/code&gt; as needed to represent the remaining axes. NumPy also allows you to write this using dots as &lt;code&gt;b[i,...]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b[i]&lt;/code&gt; 括号内的表达式被视为 &lt;code&gt;i&lt;/code&gt; ,后跟 &lt;code&gt;:&lt;/code&gt; 以表示其余轴所需的数量的：实例。NumPy还允许您使用点将其写为 &lt;code&gt;b[i,...]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="330beb4f458d2c8c447ab8cdae27158e06bf7cb9" translate="yes" xml:space="preserve">
          <source>The extracted diagonal or constructed diagonal array.</source>
          <target state="translated">提取的对角线或构造的对角线阵列。</target>
        </trans-unit>
        <trans-unit id="53a8a2b8a609081b147379c06e4ca152c3e8819c" translate="yes" xml:space="preserve">
          <source>The f2py method of linking compiled code is currently the most sophisticated and integrated approach. It allows clean separation of Python with compiled code while still allowing for separate distribution of the extension module. The only draw-back is that it requires the existence of a Fortran compiler in order for a user to install the code. However, with the existence of the free-compilers g77, gfortran, and g95, as well as high-quality commercial compilers, this restriction is not particularly onerous. In my opinion, Fortran is still the easiest way to write fast and clear code for scientific computing. It handles complex numbers, and multi-dimensional indexing in the most straightforward way. Be aware, however, that some Fortran compilers will not be able to optimize code as well as good hand- written C-code.</source>
          <target state="translated">f2py链接编译代码的方法是目前最成熟、最集成的方法。它可以将Python与编译后的代码干净地分开,同时还可以单独发布扩展模块。唯一的缺点是,它需要存在一个Fortran编译器,以便用户安装代码。不过,由于存在免费编译器g77、gfortran和g95,以及高质量的商业编译器,这个限制并不是特别繁琐。在我看来,Fortran仍然是编写快速、清晰的科学计算代码的最简单方法。它以最直接的方式处理复杂的数字,以及多维索引。不过要注意,有些Fortran编译器在优化代码方面会不如好的手写C代码。</target>
        </trans-unit>
        <trans-unit id="555daf4232eb1ce31031f68a76fe276dbf717736" translate="yes" xml:space="preserve">
          <source>The f2py program is written in Python and can be run from inside your code to compile Fortran code at runtime, as follows:</source>
          <target state="translated">f2py程序是用Python编写的,可以从你的代码内部运行,在运行时编译Fortran代码,如下所示。</target>
        </trans-unit>
        <trans-unit id="06e74a78df99ca864f56978dd8124a3fb8da4ff4" translate="yes" xml:space="preserve">
          <source>The field names may be modified by assigning to the &lt;code&gt;names&lt;/code&gt; attribute using a sequence of strings of the same length.</source>
          <target state="translated">可以通过使用相同长度的字符串序列分配给 &lt;code&gt;names&lt;/code&gt; 属性来修改字段名称。</target>
        </trans-unit>
        <trans-unit id="c76b262eba97deb65c7a5b3c9fb6314561e8e763" translate="yes" xml:space="preserve">
          <source>The field names, either specified as a comma-separated string in the form &lt;code&gt;'col1, col2, col3'&lt;/code&gt;, or as a list or tuple of strings in the form &lt;code&gt;['col1', 'col2', 'col3']&lt;/code&gt;. An empty list can be used, in that case default field names (&amp;lsquo;f0&amp;rsquo;, &amp;lsquo;f1&amp;rsquo;, &amp;hellip;) are used.</source>
          <target state="translated">字段名称，可以以逗号分隔的字符串形式 &lt;code&gt;'col1, col2, col3'&lt;/code&gt; 或以 &lt;code&gt;['col1', 'col2', 'col3']&lt;/code&gt; 形式的字符串列表或元组形式指定。可以使用一个空列表，在这种情况下，将使用默认字段名称（&amp;ldquo; f0&amp;rdquo;，&amp;ldquo; f1&amp;rdquo;，&amp;hellip;）。</target>
        </trans-unit>
        <trans-unit id="abdb8363ba033add56efe121cf142ecd7ff5e4f2" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;doc/changelog/1.14.5-changelog.rst&lt;/code&gt; should be updated to reflect the final list of changes and contributors. This text can be generated by:</source>
          <target state="translated">应该更新文件 &lt;code&gt;doc/changelog/1.14.5-changelog.rst&lt;/code&gt; 以反映更改和贡献者的最终列表。可以通过以下方式生成此文本：</target>
        </trans-unit>
        <trans-unit id="e585d8ab818b06a0b3f2cb8c9a47272f794e8c3d" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;doc/changelog/1.19.0-changelog.rst&lt;/code&gt; should be updated to reflect the final list of changes and contributors. This text can be generated by:</source>
          <target state="translated">应该更新文件 &lt;code&gt;doc/changelog/1.19.0-changelog.rst&lt;/code&gt; 以反映更改和贡献者的最终列表。可以通过以下方式生成此文本：</target>
        </trans-unit>
        <trans-unit id="0a3f62236ba0b0b8ce93c2fc463e81343db95a91" translate="yes" xml:space="preserve">
          <source>The file contains an object array, but allow_pickle=False given.</source>
          <target state="translated">文件中包含一个对象数组,但allow_pickle=False给定。</target>
        </trans-unit>
        <trans-unit id="cd858c6c51a98e96ec8ac35aea8fe45863b797ca" translate="yes" xml:space="preserve">
          <source>The file is opened in this mode:</source>
          <target state="translated">文件是在这种模式下打开的。</target>
        </trans-unit>
        <trans-unit id="5b33f093bafabe18517ca8ac91b17b43d100f40c" translate="yes" xml:space="preserve">
          <source>The file name or file object to be used as the array data buffer.</source>
          <target state="translated">要作为数组数据缓冲区的文件名或文件对象。</target>
        </trans-unit>
        <trans-unit id="26bdea2d86889049bdd7c48c4150155a14c6f9d5" translate="yes" xml:space="preserve">
          <source>The file or file name to load.</source>
          <target state="translated">要加载的文件或文件名。</target>
        </trans-unit>
        <trans-unit id="410bba1d09731e6c1884743045c51541ebe57e5e" translate="yes" xml:space="preserve">
          <source>The file to pickle &lt;code&gt;a&lt;/code&gt; to. If a string, the full path to the file.</source>
          <target state="translated">该文件咸菜 &lt;code&gt;a&lt;/code&gt; 对。如果是字符串，则为文件的完整路径。</target>
        </trans-unit>
        <trans-unit id="48b7a50cb95566779f051ba6cb8275f9d03a7f05" translate="yes" xml:space="preserve">
          <source>The file to read. File-like objects must support the &lt;code&gt;seek()&lt;/code&gt; and &lt;code&gt;read()&lt;/code&gt; methods. Pickled files require that the file-like object support the &lt;code&gt;readline()&lt;/code&gt; method as well.</source>
          <target state="translated">要读取的文件。类文件对象必须支持 &lt;code&gt;seek()&lt;/code&gt; 和 &lt;code&gt;read()&lt;/code&gt; 方法。腌制的文件要求类似文件的对象也支持 &lt;code&gt;readline()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="68f5b58fd976e02c0c3bbbefcb6355b0422acf86" translate="yes" xml:space="preserve">
          <source>The fill_value is set to &lt;code&gt;value&lt;/code&gt; and the mask is set to &lt;code&gt;nomask&lt;/code&gt; if possible.</source>
          <target state="translated">如果可能，将fill_value设置为 &lt;code&gt;value&lt;/code&gt; 并将mask设置为 &lt;code&gt;nomask&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac0cc14c76ce415edde3f9c0f5c15cc239b98f83" translate="yes" xml:space="preserve">
          <source>The filled array.</source>
          <target state="translated">填充数组。</target>
        </trans-unit>
        <trans-unit id="02297c05ffd69a001bc553284a8c48319db02e69" translate="yes" xml:space="preserve">
          <source>The filling value of the masked array is a scalar.</source>
          <target state="translated">掩码数组的填充值是一个标量。</target>
        </trans-unit>
        <trans-unit id="104abb4185415b9595a8eb2fd00671acf84e203a" translate="yes" xml:space="preserve">
          <source>The filling value of the masked array is a scalar. When setting, None will set to a default based on the data type.</source>
          <target state="translated">掩码数组的填充值是一个标量,设置时,None将根据数据类型设置为默认值。设置时,&quot;无 &quot;将根据数据类型设置为默认值。</target>
        </trans-unit>
        <trans-unit id="0bd5aa8a98810899514ee710bc2579712901ebe5" translate="yes" xml:space="preserve">
          <source>The final value of the sequence, unless &lt;code&gt;endpoint&lt;/code&gt; is False. In that case, &lt;code&gt;num + 1&lt;/code&gt; values are spaced over the interval in log-space, of which all but the last (a sequence of length &lt;code&gt;num&lt;/code&gt;) are returned.</source>
          <target state="translated">序列的最终值，除非 &lt;code&gt;endpoint&lt;/code&gt; 为False。在这种情况下， &lt;code&gt;num + 1&lt;/code&gt; 值在log-space的间隔中间隔开，返回除最后一个（长度为 &lt;code&gt;num&lt;/code&gt; 的序列）外的所有值。</target>
        </trans-unit>
        <trans-unit id="5b6f2d1ecce5ed0ec2d0e715086fccc9259a6627" translate="yes" xml:space="preserve">
          <source>The first 6 bytes are a magic string: exactly &lt;code&gt;\x93NUMPY&lt;/code&gt;.</source>
          <target state="translated">前6个字节是一个魔术字符串：恰好 &lt;code&gt;\x93NUMPY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df3f3dac6a267f56fafa2c760b8d38d59413267f" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;nargs&lt;/code&gt; elements of &lt;code&gt;steps&lt;/code&gt; remain the same as for scalar ufuncs. The following elements contain the strides of all core dimensions for all arguments in order.</source>
          <target state="translated">&lt;code&gt;steps&lt;/code&gt; 的前 &lt;code&gt;nargs&lt;/code&gt; 个元素与标量ufuncs相同。以下元素按顺序包含所有参数的所有核心维度的跨度。</target>
        </trans-unit>
        <trans-unit id="b9577dc8ae8dc3d75fe0e9351485a971c104657b" translate="yes" xml:space="preserve">
          <source>The first argument contains the Extension instance that can be useful to access its attributes like &lt;code&gt;depends&lt;/code&gt;, &lt;code&gt;sources&lt;/code&gt;, etc. lists and modify them during the building process. The second argument gives a path to a build directory that must be used when creating files to a disk.</source>
          <target state="translated">第一个参数包含Extension实例，可用于在构建过程中访问其属性，例如 &lt;code&gt;depends&lt;/code&gt; ， &lt;code&gt;sources&lt;/code&gt; 等列表，并对其进行修改。第二个参数提供了到磁盘创建文件时必须使用的构建目录的路径。</target>
        </trans-unit>
        <trans-unit id="98f417ae094b593aad4f373856f9d75fc3caadf1" translate="yes" xml:space="preserve">
          <source>The first argument is any object that can be converted into a fixed-size data-type object. The second argument is the desired shape of this type. If the shape parameter is 1, then the data-type object is equivalent to fixed dtype. If &lt;em&gt;shape&lt;/em&gt; is a tuple, then the new dtype defines a sub-array of the given shape.</source>
          <target state="translated">第一个参数是可以转换为固定大小的数据类型对象的任何对象。第二个参数是这种类型的所需形状。如果shape参数为1，则数据类型对象等效于固定dtype。如果&lt;em&gt;shape&lt;/em&gt;是一个元组，则新的dtype定义给定形状的子数组。</target>
        </trans-unit>
        <trans-unit id="8dca1bab679e35ad504daad1a00ee24ea2d780cc" translate="yes" xml:space="preserve">
          <source>The first argument is any object that can be converted into a fixed-size data-type object. The second argument is the desired shape of this type. If the shape parameter is 1, then the data-type object used to be equivalent to fixed dtype. This behaviour is deprecated since NumPy 1.17 and will raise an error in the future. If &lt;em&gt;shape&lt;/em&gt; is a tuple, then the new dtype defines a sub-array of the given shape.</source>
          <target state="translated">第一个参数是可以转换为固定大小的数据类型对象的任何对象。第二个参数是这种类型的所需形状。如果shape参数为1，则数据类型对象以前与固定dtype等效。从NumPy 1.17开始不推荐使用此行为，并且将来会引发错误。如果&lt;em&gt;shape&lt;/em&gt;是一个元组，则新的dtype定义给定形状的子数组。</target>
        </trans-unit>
        <trans-unit id="ddb3620809413337a1b624decfe7e8c4e4d1dcd2" translate="yes" xml:space="preserve">
          <source>The first argument is the newly created sub-type. The second argument (if not NULL) is the &amp;ldquo;parent&amp;rdquo; array (if the array was created using slicing or some other operation where a clearly-distinguishable parent is present). This routine can do anything it wants to. It should return a -1 on error and 0 otherwise.</source>
          <target state="translated">第一个参数是新创建的子类型。第二个参数（如果不是NULL）是&amp;ldquo;父&amp;rdquo;数组（如果该数组是使用切片或存在明显可区分父对象的其他操作创建的）。这个例程可以做任何想做的事情。错误应返回-1，否则返回0。</target>
        </trans-unit>
        <trans-unit id="2a0c10acae5d14d1b06af72f8c3df392eea96371" translate="yes" xml:space="preserve">
          <source>The first argument must be an object that is converted to a zero-sized flexible data-type object, the second argument is an integer providing the desired itemsize.</source>
          <target state="translated">第一个参数必须是一个被转换为零大小的灵活数据类型对象的对象,第二个参数是一个整数,提供所需的项目大小。</target>
        </trans-unit>
        <trans-unit id="4ab185078e9e031c6680e1f1eab45ad50f864a10" translate="yes" xml:space="preserve">
          <source>The first array shows the outcomes of throwing the dice 10 times, and the second shows the outcomes from throwing the dice 20 times.</source>
          <target state="translated">第一个阵列显示的是投掷骰子10次的结果,第二个阵列显示的是投掷骰子20次的结果。</target>
        </trans-unit>
        <trans-unit id="251cc7294c3d03a290266d04d53995289d0bed50" translate="yes" xml:space="preserve">
          <source>The first assert does not raise an exception:</source>
          <target state="translated">第一个断言没有引起例外。</target>
        </trans-unit>
        <trans-unit id="0135e65581d52468c8b55907d113ce790f408aef" translate="yes" xml:space="preserve">
          <source>The first business day on or after a date:</source>
          <target state="translated">日期当天或之后的第一个工作日。</target>
        </trans-unit>
        <trans-unit id="034408f6ac73256e0eb3a019833e3b1d26d2adb1" translate="yes" xml:space="preserve">
          <source>The first business day strictly after a date:</source>
          <target state="translated">严格在约会后的第一个工作日。</target>
        </trans-unit>
        <trans-unit id="d4d700653c3699a51205d4e8a1ce2d74d29df2ba" translate="yes" xml:space="preserve">
          <source>The first character specifies the kind of data and the remaining characters specify the number of bytes per item, except for Unicode, where it is interpreted as the number of characters. The item size must correspond to an existing type, or an error will be raised. The supported kinds are</source>
          <target state="translated">第一个字符指定数据的种类,其余字符指定每个项目的字节数,但Unicode除外,在Unicode中,它被解释为字符数。项的大小必须与现有的类型相对应,否则会出现错误。支持的类型有</target>
        </trans-unit>
        <trans-unit id="fce5520747cac508bb51c31e51bc43340f4f28dc" translate="yes" xml:space="preserve">
          <source>The first difference is given by &lt;code&gt;out[i] = a[i+1] - a[i]&lt;/code&gt; along the given axis, higher differences are calculated by using &lt;a href=&quot;#numpy.diff&quot;&gt;&lt;code&gt;diff&lt;/code&gt;&lt;/a&gt; recursively.</source>
          <target state="translated">沿给定轴的第一个差异为 &lt;code&gt;out[i] = a[i+1] - a[i]&lt;/code&gt; ，通过递归使用&lt;a href=&quot;#numpy.diff&quot;&gt; &lt;code&gt;diff&lt;/code&gt; &lt;/a&gt;计算更高的差异。</target>
        </trans-unit>
        <trans-unit id="1992d313d31d556125405ecacbe1299d290ec7b7" translate="yes" xml:space="preserve">
          <source>The first element of the &lt;code&gt;__array_interface__[&quot;data&quot;]&lt;/code&gt; tuple must be an integer</source>
          <target state="translated">&lt;code&gt;__array_interface__[&quot;data&quot;]&lt;/code&gt; 元组的第一个元素必须是整数</target>
        </trans-unit>
        <trans-unit id="a9df17052dacee8cafb40ea7e55b18075cf5de14" translate="yes" xml:space="preserve">
          <source>The first element, &lt;em&gt;field_name&lt;/em&gt;, is the field name (if this is &lt;code&gt;''&lt;/code&gt; then a standard field name, &lt;code&gt;'f#'&lt;/code&gt;, is assigned). The field name may also be a 2-tuple of strings where the first string is either a &amp;ldquo;title&amp;rdquo; (which may be any string or unicode string) or meta-data for the field which can be any object, and the second string is the &amp;ldquo;name&amp;rdquo; which must be a valid Python identifier.</source>
          <target state="translated">第一元件，&lt;em&gt;FIELD_NAME&lt;/em&gt;，是字段名称（如果这是 &lt;code&gt;''&lt;/code&gt; 则一个标准的字段名， &lt;code&gt;'f#'&lt;/code&gt; ，被分配）。字段名称也可以是2个字符串的字符串，其中第一个字符串可以是&amp;ldquo; title&amp;rdquo;（可以是任何字符串或unicode字符串），也可以是该字段的元数据，可以是任何对象，第二个字符串是&amp;ldquo;名称&amp;rdquo;，必须是有效的Python标识符。</target>
        </trans-unit>
        <trans-unit id="67d77719eacdaf274558e4a616994274e8d068b0" translate="yes" xml:space="preserve">
          <source>The first example integrates &lt;code&gt;p&lt;/code&gt; once, the second example integrates it twice. By default, the lower bound of the integration and the integration constant are 0, but both can be specified.:</source>
          <target state="translated">第一个示例 &lt;code&gt;p&lt;/code&gt; 一次积分，第二个示例对p进行两次积分。缺省情况下，积分的下界和积分常数为0，但都可以指定。</target>
        </trans-unit>
        <trans-unit id="311abfb54dbdf5d2ba16af23aef0589cc8d8cc86" translate="yes" xml:space="preserve">
          <source>The first form should be preferred.</source>
          <target state="translated">应首选第一种形式。</target>
        </trans-unit>
        <trans-unit id="efb03ce57a81f162cb7b4a2a4999809358d24fef" translate="yes" xml:space="preserve">
          <source>The first integer is the first byte of the array, the second integer is just past the last byte of the array. If &lt;code&gt;a&lt;/code&gt; is not contiguous it will not use every byte between the (&lt;code&gt;low&lt;/code&gt;, &lt;code&gt;high&lt;/code&gt;) values.</source>
          <target state="translated">第一个整数是数组的第一个字节，第二个整数刚好在数组的最后一个字节之后。如果 &lt;code&gt;a&lt;/code&gt; 不连续，则不会使用（ &lt;code&gt;low&lt;/code&gt; ， &lt;code&gt;high&lt;/code&gt; ）值之间的每个字节。</target>
        </trans-unit>
        <trans-unit id="19fd42d2f3f6ab1e3a2844cd4d5055ea1cbf31a0" translate="yes" xml:space="preserve">
          <source>The first is the use of the &lt;code&gt;ndarray.__new__&lt;/code&gt; method for the main work of object initialization, rather then the more usual &lt;code&gt;__init__&lt;/code&gt; method. The second is the use of the &lt;code&gt;__array_finalize__&lt;/code&gt; method to allow subclasses to clean up after the creation of views and new instances from templates.</source>
          <target state="translated">首先是使用 &lt;code&gt;ndarray.__new__&lt;/code&gt; 方法进行对象初始化的主要工作，而不是更常用的 &lt;code&gt;__init__&lt;/code&gt; 方法。第二个方法是使用 &lt;code&gt;__array_finalize__&lt;/code&gt; 方法，以允许子类在从模板创建视图和新实例之后进行清理。</target>
        </trans-unit>
        <trans-unit id="eb41b42b24f210f1f4be6981685ada6a1cb54412" translate="yes" xml:space="preserve">
          <source>The first law of Laplace, from 1774, states that the frequency of an error can be expressed as an exponential function of the absolute magnitude of the error, which leads to the Laplace distribution. For many problems in economics and health sciences, this distribution seems to model the data better than the standard Gaussian distribution.</source>
          <target state="translated">1774年的拉普拉斯第一定律指出,误差的频率可以表示为误差绝对值的指数函数,这就导致了拉普拉斯分布。对于经济学和健康科学中的许多问题,这种分布似乎比标准的高斯分布更能模拟数据。</target>
        </trans-unit>
        <trans-unit id="f7deea27a398e3cec5cdd6f79c6e53fb0be11445" translate="yes" xml:space="preserve">
          <source>The first output can be provided as either a positional or a keyword parameter. Keyword &amp;lsquo;out&amp;rsquo; arguments are incompatible with positional ones.</source>
          <target state="translated">第一输出可以作为位置参数或关键字参数提供。关键字&amp;ldquo; out&amp;rdquo;参数与位置参数不兼容。</target>
        </trans-unit>
        <trans-unit id="6c26c4fe0578c2071a8b45fe1c269e9b84d2d403" translate="yes" xml:space="preserve">
          <source>The first parameter, arr, must be an ndarray or subclass. The parameter, &lt;em&gt;flags&lt;/em&gt;, should be an integer consisting of bitwise combinations of the possible flags an array can have: &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">第一个参数arr必须是ndarray或子类。参数，&lt;em&gt;标志&lt;/em&gt;，应该是由可能的标志的阵列可具有的按位的组合的一个整数：&lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt; &lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ef7e5035a4cae33d8eaceb23fe8e3a39e676894" translate="yes" xml:space="preserve">
          <source>The first row is a header line that (mostly) describes the data in each column that follow in the rows below, and beginning in the fourth column, the header is the date of the observation.</source>
          <target state="translated">第一行是标题行,(主要是)描述下面几行中每一列的数据,从第四列开始,标题是观测的日期。</target>
        </trans-unit>
        <trans-unit id="a463555884e9f663755cbacb732bc60283f30e4e" translate="yes" xml:space="preserve">
          <source>The first rule of broadcasting is that if all input arrays do not have the same number of dimensions, a &amp;ldquo;1&amp;rdquo; will be repeatedly prepended to the shapes of the smaller arrays until all the arrays have the same number of dimensions.</source>
          <target state="translated">广播的第一个规则是，如果所有输入数组的维数不相同，则较小的数组形状将被重复添加&amp;ldquo; 1&amp;rdquo;，直到所有数组的维数相同。</target>
        </trans-unit>
        <trans-unit id="a8639bf3cb0cf6544a568d7a40bcc68d44fbb8c9" translate="yes" xml:space="preserve">
          <source>The first signature listed, &lt;code&gt;( DATA_TYPE IN_ARRAY[ANY] )&lt;/code&gt; is for one-dimensional arrays with hard-coded dimensions. Likewise, &lt;code&gt;( DATA_TYPE IN_ARRAY2[ANY][ANY] )&lt;/code&gt; is for two-dimensional arrays with hard-coded dimensions, and similarly for three-dimensional.</source>
          <target state="translated">列出的第一个签名 &lt;code&gt;( DATA_TYPE IN_ARRAY[ANY] )&lt;/code&gt; 用于具有硬编码维的一维数组。同样， &lt;code&gt;( DATA_TYPE IN_ARRAY2[ANY][ANY] )&lt;/code&gt; 用于具有硬编码维的二维数组，并且对于三维也是类似的。</target>
        </trans-unit>
        <trans-unit id="21bc00ee1c8a15912cb2e713abebe2d2f93cd1e7" translate="yes" xml:space="preserve">
          <source>The first thing done is to look-up in the thread-specific global dictionary the current values for the buffer-size, the error mask, and the associated error object. The state of the error mask controls what happens when an error condition is found. It should be noted that checking of the hardware error flags is only performed after each 1-D loop is executed. This means that if the input and output arrays are contiguous and of the correct type so that a single 1-D loop is performed, then the flags may not be checked until all elements of the array have been calculated. Looking up these values in a thread- specific dictionary takes time which is easily ignored for all but very small arrays.</source>
          <target state="translated">首先要做的是在线程特定的全局字典中查找缓冲区大小、错误掩码和相关错误对象的当前值。错误掩码的状态控制着发现错误条件时的情况。需要注意的是,对硬件错误标志的检查只在每个一维循环执行后进行。这意味着,如果输入和输出数组是连续的,并且类型正确,因此执行一个1-D循环,那么在数组的所有元素被计算出来之前,可能不会检查标志。在线程特定的字典中查找这些值需要花费时间,这对于除很小的数组外的所有数组来说很容易被忽略。</target>
        </trans-unit>
        <trans-unit id="eec0cb9e2856c8840ae3269c16ee7eee2770a458" translate="yes" xml:space="preserve">
          <source>The first thing to understand is that there are two conflicting conventions for indexing 2-dimensional arrays. Matrix notation uses the first index to indicate which row is being selected and the second index to indicate which column is selected. This is opposite the geometrically oriented-convention for images where people generally think the first index represents x position (i.e., column) and the second represents y position (i.e., row). This alone is the source of much confusion; matrix-oriented users and image-oriented users expect two different things with regard to indexing.</source>
          <target state="translated">首先要了解的是,二维数组的索引有两个相互冲突的约定。矩阵符号用第一个索引来表示选择哪一行,第二个索引来表示选择哪一列。这与图像的几何定向约定相反,人们一般认为第一个索引代表x位置(即列),第二个索引代表y位置(即行)。仅仅是这一点就造成了很多的混乱;面向矩阵的用户和面向图像的用户对索引有两种不同的期望。</target>
        </trans-unit>
        <trans-unit id="bf8fd843050316faeec1058499245d59f374d012" translate="yes" xml:space="preserve">
          <source>The first through third rows and fifth through ninth columns of a 2D array, &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">2D数组 &lt;code&gt;a&lt;/code&gt; 的第一至第三行和第五至第九列。</target>
        </trans-unit>
        <trans-unit id="3724db84918ba9464ddbe8344f5b3bc2ec94ad64" translate="yes" xml:space="preserve">
          <source>The first two of these are conveniences which resemble the names of the builtin types, in the same style as &lt;a href=&quot;#numpy.bool_&quot;&gt;&lt;code&gt;bool_&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.int_&quot;&gt;&lt;code&gt;int_&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.str_&quot;&gt;&lt;code&gt;str_&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.bytes_&quot;&gt;&lt;code&gt;bytes_&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#numpy.object_&quot;&gt;&lt;code&gt;object_&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">前两个是类似于内建类型名称的便捷方式，它们的风格与&lt;a href=&quot;#numpy.bool_&quot;&gt; &lt;code&gt;bool_&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#numpy.int_&quot;&gt; &lt;code&gt;int_&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#numpy.str_&quot;&gt; &lt;code&gt;str_&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#numpy.bytes_&quot;&gt; &lt;code&gt;bytes_&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#numpy.object_&quot;&gt; &lt;code&gt;object_&lt;/code&gt; 相同&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="43a31061c48404a506dd1e24e7517ade62790639" translate="yes" xml:space="preserve">
          <source>The fixed size of NumPy numeric types may cause overflow errors when a value requires more memory than available in the data type. For example, &lt;a href=&quot;../reference/generated/numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt; evaluates &lt;code&gt;100 * 10 ** 8&lt;/code&gt; correctly for 64-bit integers, but gives 1874919424 (incorrect) for a 32-bit integer.</source>
          <target state="translated">当一个值需要的数据存储量大于数据类型中可用的存储量时，NumPy数值类型的固定大小可能会导致溢出错误。例如，&lt;a href=&quot;../reference/generated/numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt;对于64位整数正确计算 &lt;code&gt;100 * 10 ** 8&lt;/code&gt; ，但对于32位整数给出1874919424（不正确）。</target>
        </trans-unit>
        <trans-unit id="00dceab341e446e82fd4facf33583ffedc7bd940" translate="yes" xml:space="preserve">
          <source>The flags member may consist of 5 bits showing how the data should be interpreted and one bit showing how the Interface should be interpreted. The data-bits are &lt;a href=&quot;c-api/array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (0x1), &lt;a href=&quot;c-api/array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (0x2), &lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; (0x100), &lt;a href=&quot;c-api/array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt;&lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt;&lt;/a&gt; (0x200), and &lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; (0x400). A final flag &lt;a href=&quot;#c.NPY_ARR_HAS_DESCR&quot;&gt;&lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt;&lt;/a&gt; (0x800) indicates whether or not this structure has the arrdescr field. The field should not be accessed unless this flag is present.</source>
          <target state="translated">标志成员可以由5位和1位组成，其中5位表示应该如何解释数据，而1位则应该如何解释接口。数据位是&lt;a href=&quot;c-api/array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;（0x1），&lt;a href=&quot;c-api/array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;（0x2），&lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;（0x100），&lt;a href=&quot;c-api/array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt; &lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt; &lt;/a&gt;（0x200）和&lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;（0x400）。最后一个标志&lt;a href=&quot;#c.NPY_ARR_HAS_DESCR&quot;&gt; &lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt; &lt;/a&gt;（0x800）指示此结构是否具有arrdescr字段。除非存在此标志，否则不应访问该字段。</target>
        </trans-unit>
        <trans-unit id="dae27e752e6250bcf53dd15428c26bfc6c4aff24" translate="yes" xml:space="preserve">
          <source>The flags member may consist of 5 bits showing how the data should be interpreted and one bit showing how the Interface should be interpreted. The data-bits are &lt;code&gt;CONTIGUOUS&lt;/code&gt; (0x1), &lt;code&gt;FORTRAN&lt;/code&gt; (0x2), &lt;code&gt;ALIGNED&lt;/code&gt; (0x100), &lt;code&gt;NOTSWAPPED&lt;/code&gt; (0x200), and &lt;code&gt;WRITEABLE&lt;/code&gt; (0x400). A final flag &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; (0x800) indicates whether or not this structure has the arrdescr field. The field should not be accessed unless this flag is present.</source>
          <target state="translated">标志成员可以由5位和1位组成，其中5位表示应如何解释数据，而1位则应如何解释接口。该数据比特是 &lt;code&gt;CONTIGUOUS&lt;/code&gt; （为0x1）， &lt;code&gt;FORTRAN&lt;/code&gt; （0X2）， &lt;code&gt;ALIGNED&lt;/code&gt; （0x100的）， &lt;code&gt;NOTSWAPPED&lt;/code&gt; （为0x200）和 &lt;code&gt;WRITEABLE&lt;/code&gt; （0x400的）。最后一个标志 &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; （0x800）指示此结构是否具有arrdescr字段。除非存在此标志，否则不应访问该字段。</target>
        </trans-unit>
        <trans-unit id="80d94b3bc99b1a4e8e2a1a02a0e27c0ae964964b" translate="yes" xml:space="preserve">
          <source>The flexible type array that is returned will have two fields:</source>
          <target state="translated">返回的灵活类型数组将有两个字段。</target>
        </trans-unit>
        <trans-unit id="bd686ab267e11ccd8dcbb950337101a32f2aa2c7" translate="yes" xml:space="preserve">
          <source>The float printing routines use an accurate but much more computationally demanding algorithm to compute the number of digits after the decimal point.</source>
          <target state="translated">浮点数打印例程使用精确但对计算要求更高的算法来计算小数点后的数字。</target>
        </trans-unit>
        <trans-unit id="9b521c71cd9d32371a352dcf94d2ff132ccb79f4" translate="yes" xml:space="preserve">
          <source>The floating-point exceptions are defined in the IEEE 754 standard &lt;a href=&quot;#r4cab4292821f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="translated">浮点异常在IEEE 754标准&lt;a href=&quot;#r4cab4292821f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;中定义：</target>
        </trans-unit>
        <trans-unit id="25cd839f1fa0397dfd8a073d288328126b03cd06" translate="yes" xml:space="preserve">
          <source>The floor division operator &lt;code&gt;//&lt;/code&gt; was added in Python 2.2 making &lt;code&gt;//&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; equivalent operators. The default floor division operation of &lt;code&gt;/&lt;/code&gt; can be replaced by true division with &lt;code&gt;from
__future__ import division&lt;/code&gt;.</source>
          <target state="translated">地板除法运算符 &lt;code&gt;//&lt;/code&gt; 是在Python 2.2中添加的 &lt;code&gt;//&lt;/code&gt; 和 &lt;code&gt;/&lt;/code&gt; 等效运算符。默认地板除法运算 &lt;code&gt;/&lt;/code&gt; 可真司被替换 &lt;code&gt;from __future__ import division&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e26997b358814cca7850a49e412f8a41b34dbe5" translate="yes" xml:space="preserve">
          <source>The floor of each element in &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 中每个元素的底限。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="eaacb373a79b18f285bd66c2cf0778d5b163c8e7" translate="yes" xml:space="preserve">
          <source>The floor of the scalar &lt;code&gt;x&lt;/code&gt; is the largest integer &lt;code&gt;i&lt;/code&gt;, such that &lt;code&gt;i &amp;lt;= x&lt;/code&gt;. It is often denoted as</source>
          <target state="translated">标量 &lt;code&gt;x&lt;/code&gt; 的底数是最大的整数 &lt;code&gt;i&lt;/code&gt; ，因此 &lt;code&gt;i &amp;lt;= x&lt;/code&gt; 。它通常表示为</target>
        </trans-unit>
        <trans-unit id="837a298621c37ae4f32158adfb48d3ae2b900f73" translate="yes" xml:space="preserve">
          <source>The fmax is equivalent to &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">当x1和x2都不是NaN时，fmax等于 &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; ，但是它更快并且可以正确广播。</target>
        </trans-unit>
        <trans-unit id="9192d9bcf4b5d5fc29087b97fc9fad549a45ccf6" translate="yes" xml:space="preserve">
          <source>The fmin is equivalent to &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">当x1和x2都不是NaN时，fmin等于 &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; ，但是它更快并且可以正确广播。</target>
        </trans-unit>
        <trans-unit id="359ddc84e42e1145c1875abe172377b5b248a4ef" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;git config --global&lt;/code&gt; commands:</source>
          <target state="translated">以下 &lt;code&gt;git config --global&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="518aa4775940c5975015df6bdff3bbfdd8f78874" translate="yes" xml:space="preserve">
          <source>The following aliases originate from Python 2, and it is recommended that they not be used in new code.</source>
          <target state="translated">下面的别名源自 Python 2,建议不要在新代码中使用它们。</target>
        </trans-unit>
        <trans-unit id="2933db06c5f57c543942f5ed02bb77ea787c4725" translate="yes" xml:space="preserve">
          <source>The following attributes are used by F2PY:</source>
          <target state="translated">F2PY使用的属性如下:</target>
        </trans-unit>
        <trans-unit id="26c655f10b13c11e712f57319bac1772cdc5526b" translate="yes" xml:space="preserve">
          <source>The following attributes contain information about the memory layout of the array:</source>
          <target state="translated">下面的属性包含了关于阵列的内存布局的信息。</target>
        </trans-unit>
        <trans-unit id="245831b050a7f252080c114fea4739c32457bc6e" translate="yes" xml:space="preserve">
          <source>The following code allows us to look at the call sequences and arguments:</source>
          <target state="translated">下面的代码允许我们查看调用序列和参数。</target>
        </trans-unit>
        <trans-unit id="b09df459a0ad4a5d7d6218f92cc55900d726085b" translate="yes" xml:space="preserve">
          <source>The following comparison does not raise an exception. There are NaNs in the inputs, but they are in the same positions.</source>
          <target state="translated">下面的比较没有引起异常。输入中有NaNs,但它们的位置相同。</target>
        </trans-unit>
        <trans-unit id="25c3aeb47ccb54f3895f28756398a03c01d886f7" translate="yes" xml:space="preserve">
          <source>The following corresponds to the usual functions except that nans are excluded from the results:</source>
          <target state="translated">下列函数与通常的函数相对应,但结果中不包括nans。</target>
        </trans-unit>
        <trans-unit id="367c359a19964728c01ac0e57fac7d66168d5b07" translate="yes" xml:space="preserve">
          <source>The following data types are &lt;strong&gt;flexible&lt;/strong&gt;: they have no predefined size and the data they describe can be of different length in different arrays. (In the character codes &lt;code&gt;#&lt;/code&gt; is an integer denoting how many elements the data type consists of.)</source>
          <target state="translated">以下数据类型是&lt;strong&gt;灵活的&lt;/strong&gt;：它们没有预定义的大小，并且它们描述的数据在不同的数组中可以具有不同的长度。（在字符代码中 &lt;code&gt;#&lt;/code&gt; 是一个整数，表示数据类型由多少个元素组成。）</target>
        </trans-unit>
        <trans-unit id="87cc18e3bbbb39d0641f0c5e5f7aaba73b3bfa17" translate="yes" xml:space="preserve">
          <source>The following example checks that &lt;code&gt;a * a+ * a == a&lt;/code&gt; and &lt;code&gt;a+ * a * a+ == a+&lt;/code&gt;:</source>
          <target state="translated">以下示例检查 &lt;code&gt;a * a+ * a == a&lt;/code&gt; 和 &lt;code&gt;a+ * a * a+ == a+&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="da726617ef56fc847d878f222531de4392ef5079" translate="yes" xml:space="preserve">
          <source>The following example demonstrates that operations on this particular dtype requires Python C-API.</source>
          <target state="translated">下面的例子演示了对这个特殊dtype的操作需要Python C-API。</target>
        </trans-unit>
        <trans-unit id="bff8fe87ad1b3faab42fa78be47af40e14a3cdee" translate="yes" xml:space="preserve">
          <source>The following example illustrates how to add user-defined variables to a F2PY generated extension module. Given the following signature file</source>
          <target state="translated">下面的例子说明了如何在F2PY生成的扩展模块中添加用户定义的变量。给定以下签名文件</target>
        </trans-unit>
        <trans-unit id="601636ce271dc6c59652a4b9ca1697d0ffc34977" translate="yes" xml:space="preserve">
          <source>The following example shows how you might write a wrapper that accepts two input arguments (that will be converted to an array) and an output argument (that must be an array). The function returns None and updates the output array. Note the updated use of WRITEBACKIFCOPY semantics for NumPy v1.14 and above</source>
          <target state="translated">下面的例子展示了如何编写一个包装器,接受两个输入参数(将转换为一个数组)和一个输出参数(必须是一个数组)。该函数返回None并更新输出数组。请注意,NumPy v1.14及以上版本更新了WRITEBACKIFCOPY语义的使用。</target>
        </trans-unit>
        <trans-unit id="cec08f779bf34d2ddbd6e93821079202c9a0f6c2" translate="yes" xml:space="preserve">
          <source>The following features aren&amp;rsquo;t supported by x86::Intel Compiler: &lt;strong&gt;XOP FMA4&lt;/strong&gt;</source>
          <target state="translated">x86 :: Intel编译器不支持以下功能：&lt;strong&gt;XOP FMA4&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6c191fcaf6a1f21a70ff57080f8689e6ba2fd60" translate="yes" xml:space="preserve">
          <source>The following features aren&amp;rsquo;t supported by x86::Microsoft Visual C/C++: &lt;strong&gt;AVX512_KNL AVX512_KNM&lt;/strong&gt;</source>
          <target state="translated">x86 :: Microsoft Visual C / C ++不支持以下功能：&lt;strong&gt;AVX512_KNL AVX512_KNM&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9274fe878c5628b41be8c56553474b2bf993bdb4" translate="yes" xml:space="preserve">
          <source>The following import conventions are used throughout the NumPy source and documentation:</source>
          <target state="translated">NumPy源码和文档中使用了以下导入约定。</target>
        </trans-unit>
        <trans-unit id="6a11277817c1922ff80f9328abde5fde7dba14c8" translate="yes" xml:space="preserve">
          <source>The following is equivalent to &lt;code&gt;x[:, np.newaxis]&lt;/code&gt;:</source>
          <target state="translated">以下等效于 &lt;code&gt;x[:, np.newaxis]&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c9a4cf52932022adac50e43fe76bc932e82c5751" translate="yes" xml:space="preserve">
          <source>The following is equivalent to &lt;code&gt;x[np.newaxis, :]&lt;/code&gt; or &lt;code&gt;x[np.newaxis]&lt;/code&gt;:</source>
          <target state="translated">以下等效于 &lt;code&gt;x[np.newaxis, :]&lt;/code&gt; 或 &lt;code&gt;x[np.newaxis]&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c7cc30376235469e66891b8aa9bb0978b2dc2799" translate="yes" xml:space="preserve">
          <source>The following is equivalent to &lt;code&gt;x[np.newaxis,:]&lt;/code&gt; or &lt;code&gt;x[np.newaxis]&lt;/code&gt;:</source>
          <target state="translated">以下等效于 &lt;code&gt;x[np.newaxis,:]&lt;/code&gt; 或 &lt;code&gt;x[np.newaxis]&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8b1e13d507d651c25d5c30d03b160ce21c4df709" translate="yes" xml:space="preserve">
          <source>The following is probably true, given that 0.6 is roughly twice the standard deviation:</source>
          <target state="translated">鉴于0.6大约是标准差的两倍,以下说法可能是正确的。</target>
        </trans-unit>
        <trans-unit id="abb45d568d4c1dc6b1960772da10fbcd2d6bd4ca" translate="yes" xml:space="preserve">
          <source>The following keys are allowed:</source>
          <target state="translated">允许使用下列钥匙:</target>
        </trans-unit>
        <trans-unit id="c7e7738746294a7939f873df246ce33769c08494" translate="yes" xml:space="preserve">
          <source>The following math constants are available in &lt;code&gt;npy_math.h&lt;/code&gt;. Single and extended precision are also available by adding the &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;l&lt;/code&gt; suffixes respectively.</source>
          <target state="translated">以下数学常量可在 &lt;code&gt;npy_math.h&lt;/code&gt; 中使用。也可以通过分别添加 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;l&lt;/code&gt; 后缀来获得单精度和扩展精度。</target>
        </trans-unit>
        <trans-unit id="18400fc6ad0ef15f4b4b9f40c34d77a0b29576fd" translate="yes" xml:space="preserve">
          <source>The following methods can be used to access information about the mask or to manipulate the mask.</source>
          <target state="translated">以下方法可用于访问有关掩码的信息或操作掩码。</target>
        </trans-unit>
        <trans-unit id="a7a27e2b2ff01b711d127c91926b8f2614c9b919" translate="yes" xml:space="preserve">
          <source>The following methods implement the pickle protocol:</source>
          <target state="translated">以下方法实现了pickle协议。</target>
        </trans-unit>
        <trans-unit id="ebfae704e1370f3e45632884fb2aa5f3e6615469" translate="yes" xml:space="preserve">
          <source>The following new &lt;code&gt;distutils&lt;/code&gt; commands are defined:</source>
          <target state="translated">定义了以下新的 &lt;code&gt;distutils&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="3e142b98cf4f076b7f9b0cce4a8911bba92433dc" translate="yes" xml:space="preserve">
          <source>The following norms can be calculated:</source>
          <target state="translated">可以计算出以下规范:</target>
        </trans-unit>
        <trans-unit id="7d6f7c16ce7db4761de0d3a2abd525b89c4146e9" translate="yes" xml:space="preserve">
          <source>The following predefined named repeat rules are available:</source>
          <target state="translated">以下是预定义的命名重复规则。</target>
        </trans-unit>
        <trans-unit id="de855448328b5e9f80cc8ce9168a701f985757d7" translate="yes" xml:space="preserve">
          <source>The following rules apply:</source>
          <target state="translated">适用以下规则:</target>
        </trans-unit>
        <trans-unit id="cb0a5d55704a6c767182c6ac613e21ec8fe0f334" translate="yes" xml:space="preserve">
          <source>The following sections list commonly reported issues depending on your setup. If you have an issue/solution that you think should appear please open a NumPy issue so that it will be added.</source>
          <target state="translated">下面的部分根据你的设置列出了常见的报告问题。如果你有一个你认为应该出现的问题/解决方案,请打开一个NumPy问题,这样它就会被添加进来。</target>
        </trans-unit>
        <trans-unit id="35ff8f470befc9ac72d0ecaaff54cadb612acf70" translate="yes" xml:space="preserve">
          <source>The following steps are repeated for the beta(s), release candidates(s) and the final release.</source>
          <target state="translated">以下步骤在测试版、候选版本和最终版本中重复进行。</target>
        </trans-unit>
        <trans-unit id="673282ba4caddc15d3834a42815a47f56a4e3e0c" translate="yes" xml:space="preserve">
          <source>The following subsections provide more details about the differences.</source>
          <target state="translated">以下各小节将详细介绍两者的区别。</target>
        </trans-unit>
        <trans-unit id="24372c47ac89c648eaea091804415a70512b9c0d" translate="yes" xml:space="preserve">
          <source>The following table summarizes the behaviors of the methods.</source>
          <target state="translated">下表总结了这些方法的行为。</target>
        </trans-unit>
        <trans-unit id="c06e0f256f2589491136501e9e87069b307e9c76" translate="yes" xml:space="preserve">
          <source>The following tables show the current supported optimizations sorted from the lowest to the highest interest.</source>
          <target state="translated">下表显示了当前支持的优化,从最低到最高兴趣排序。</target>
        </trans-unit>
        <trans-unit id="2238114e4622f64961aa457707939beca3d22430" translate="yes" xml:space="preserve">
          <source>The form of each element of the files sequence is very flexible allowing many combinations of where to get the files from the package and where they should ultimately be installed on the system. The most basic usage is for an element of the files argument sequence to be a simple filename. This will cause that file from the local path to be installed to the installation path of the self.name package (package path). The file argument can also be a relative path in which case the entire relative path will be installed into the package directory. Finally, the file can be an absolute path name in which case the file will be found at the absolute path name but installed to the package path.</source>
          <target state="translated">文件序列中每个元素的形式都非常灵活,允许从软件包中获取文件的位置以及它们最终应该安装在系统中的位置进行多种组合。最基本的用法是文件参数序列中的一个元素是一个简单的文件名,这将导致该文件从本地路径安装到系统中。这将导致该文件从本地路径安装到self.name包的安装路径(包路径)。文件参数也可以是一个相对路径,在这种情况下,整个相对路径将被安装到包的目录中。最后,文件可以是一个绝对路径名,在这种情况下,文件将在绝对路径名处被找到,但会被安装到包的路径上。</target>
        </trans-unit>
        <trans-unit id="7343176dc74f7dbd7af11c9825b614f0b44c3446" translate="yes" xml:space="preserve">
          <source>The formal syntax of signatures is as follows:</source>
          <target state="translated">签名的正式语法如下:</target>
        </trans-unit>
        <trans-unit id="9dfcbb2acec4cf5d146ee3b9671f0f8af54935b6" translate="yes" xml:space="preserve">
          <source>The format description, either specified as a string with comma-separated format descriptions in the form &lt;code&gt;'f8, i4, a5'&lt;/code&gt;, or a list of format description strings in the form &lt;code&gt;['f8', 'i4', 'a5']&lt;/code&gt;.</source>
          <target state="translated">格式描述，可以指定为字符串，并以逗号分隔的格式描述以 &lt;code&gt;'f8, i4, a5'&lt;/code&gt; ，或者以格式描述字符串列表的形式以 &lt;code&gt;['f8', 'i4', 'a5']&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d7571d646719e6a89afce2ffa8ca97d9a9e64da" translate="yes" xml:space="preserve">
          <source>The format is that required by the &amp;lsquo;descr&amp;rsquo; key in the &lt;code&gt;__array_interface__&lt;/code&gt; attribute.</source>
          <target state="translated">该格式是 &lt;code&gt;__array_interface__&lt;/code&gt; 属性中'descr'键所要求的格式。</target>
        </trans-unit>
        <trans-unit id="8a1e4bed9460777336f2b104636d1f996f032590" translate="yes" xml:space="preserve">
          <source>The format of these binary file types is documented in &lt;a href=&quot;generated/numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">这些二进制文件类型的格式记录在&lt;a href=&quot;generated/numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; 中&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab7733aff55a201beeb5e33bad2c1efefa91a712" translate="yes" xml:space="preserve">
          <source>The forward 2-dimensional FFT, of which &lt;a href=&quot;#numpy.fft.ifft2&quot;&gt;&lt;code&gt;ifft2&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">前向二维FFT，其中&lt;a href=&quot;#numpy.fft.ifft2&quot;&gt; &lt;code&gt;ifft2&lt;/code&gt; &lt;/a&gt;是逆数。</target>
        </trans-unit>
        <trans-unit id="0bd56e9c9eb1ee54cf6d17ca53e59f27e56218bd" translate="yes" xml:space="preserve">
          <source>The forward &lt;em&gt;n&lt;/em&gt;-dimensional FFT, of which &lt;a href=&quot;#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">正向&lt;em&gt;n&lt;/em&gt;维FFT，其中&lt;a href=&quot;#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt;是逆数。</target>
        </trans-unit>
        <trans-unit id="aeabce19c51398cd914249fe750519a8327c3674" translate="yes" xml:space="preserve">
          <source>The forward n-dimensional FFT of real input, of which &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">实数输入的正向n维FFT，其中&lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt;是逆数。</target>
        </trans-unit>
        <trans-unit id="09a0fbb085d0fd26ff5f14cab85195f81b750c9f" translate="yes" xml:space="preserve">
          <source>The forward two-dimensional FFT of real input, of which &lt;a href=&quot;#numpy.fft.irfft2&quot;&gt;&lt;code&gt;irfft2&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">实数输入的正向二维FFT，其中&lt;a href=&quot;#numpy.fft.irfft2&quot;&gt; &lt;code&gt;irfft2&lt;/code&gt; &lt;/a&gt;是逆数。</target>
        </trans-unit>
        <trans-unit id="86b261d0d21cfe3b6b89e72eae8348c6f9559d44" translate="yes" xml:space="preserve">
          <source>The foundations of Project governance are:</source>
          <target state="translated">项目治理的基础是:</target>
        </trans-unit>
        <trans-unit id="61a4038ee203c584eee7f06e34f73b9e221966a9" translate="yes" xml:space="preserve">
          <source>The four core distributions (&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;) all allow existing arrays to be filled using the &lt;code&gt;out&lt;/code&gt; keyword argument. Existing arrays need to be contiguous and well-behaved (writable and aligned). Under normal circumstances, arrays created using the common constructors such as &lt;a href=&quot;../generated/numpy.empty#numpy.empty&quot;&gt;&lt;code&gt;numpy.empty&lt;/code&gt;&lt;/a&gt; will satisfy these requirements.</source>
          <target state="translated">四个核心分布（&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; &lt;/a&gt;）都允许使用 &lt;code&gt;out&lt;/code&gt; 关键字参数填充现有数组。现有阵列需要是连续的且行为良好的（可写且对齐的）。在正常情况下，使用常见构造函数（例如&lt;a href=&quot;../generated/numpy.empty#numpy.empty&quot;&gt; &lt;code&gt;numpy.empty&lt;/code&gt; )&lt;/a&gt;创建的数组将满足这些要求。</target>
        </trans-unit>
        <trans-unit id="4e18095a7950042b568262a2f1c7ea1be5258e8f" translate="yes" xml:space="preserve">
          <source>The four values listed above correspond to the number of columns in your array. With a four-column array, you will get four values as your result.</source>
          <target state="translated">上面列出的四个值对应于数组中的列数。对于一个四列的数组,你将得到四个值作为你的结果。</target>
        </trans-unit>
        <trans-unit id="6b6b0ab0e6259043a789c7cdf6069c9981b5ed51" translate="yes" xml:space="preserve">
          <source>The fourth-order derivative of a 3rd-order polynomial is zero:</source>
          <target state="translated">三阶多项式的四阶导数为零。</target>
        </trans-unit>
        <trans-unit id="61efc608056775e101326edefdfb5b3e50b42207" translate="yes" xml:space="preserve">
          <source>The fractional and integral parts are negative if the given number is negative.</source>
          <target state="translated">如果给定的数是负数,则分数和积分都是负数。</target>
        </trans-unit>
        <trans-unit id="8a03fbb591756592459d393e8bbc5d2c3b77111d" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt;&lt;/a&gt; can always be used to reproduce the old behavior, as it will return a packed copy of the structured array. The code above, for example, can be replaced with:</source>
          <target state="translated">函数&lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt; &lt;/a&gt;始终可以用于重现旧的行为，因为它将返回结构化数组的压缩副本。例如，上面的代码可以替换为：</target>
        </trans-unit>
        <trans-unit id="a275d8e4e1eb223479714f496979856366e2451a" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#numpy.random.default_rng&quot;&gt;&lt;code&gt;numpy.random.default_rng&lt;/code&gt;&lt;/a&gt; will instantiate a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; with numpy&amp;rsquo;s default &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">函数&lt;a href=&quot;#numpy.random.default_rng&quot;&gt; &lt;code&gt;numpy.random.default_rng&lt;/code&gt; &lt;/a&gt;将使用numpy的默认&lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt;实例化&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3162acb71296218159c712934b3730fe102cab75" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#numpy.random.default_rng&quot;&gt;&lt;code&gt;numpy.random.default_rng&lt;/code&gt;&lt;/a&gt; will instantiate a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; with numpy&amp;rsquo;s default &lt;code&gt;BitGenerator&lt;/code&gt;.</source>
          <target state="translated">函数&lt;a href=&quot;#numpy.random.default_rng&quot;&gt; &lt;code&gt;numpy.random.default_rng&lt;/code&gt; &lt;/a&gt;将使用numpy的默认 &lt;code&gt;BitGenerator&lt;/code&gt; 实例化&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a8219757277659dda8af10246595348c539cf3e" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;../reference/c-api/array#c.PyArray_RemoveSmallest&quot;&gt;&lt;code&gt;PyArray_RemoveSmallest&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;multi&lt;/code&gt; ) can be used to take a multi-iterator object and adjust all the iterators so that iteration does not take place over the largest dimension (it makes that dimension of size 1). The code being looped over that makes use of the pointers will very-likely also need the strides data for each of the iterators. This information is stored in multi-&amp;gt;iters[i]-&amp;gt;strides.</source>
          <target state="translated">函数&lt;a href=&quot;../reference/c-api/array#c.PyArray_RemoveSmallest&quot;&gt; &lt;code&gt;PyArray_RemoveSmallest&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;multi&lt;/code&gt; ）可用于获取多迭代器对象并调整所有迭代器，以使迭代不会在最大维度上发生（它使该维度的大小为1）。使用指针的循环代码很可能还需要每个迭代器的步幅数据。此信息存储在multi-&amp;gt; iters [i]-&amp;gt;步幅中。</target>
        </trans-unit>
        <trans-unit id="9aca3baefb770d49123ec449717dbfcad5a619a9" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;../reference/generated/numpy.column_stack#numpy.column_stack&quot;&gt;&lt;code&gt;column_stack&lt;/code&gt;&lt;/a&gt; stacks 1D arrays as columns into a 2D array. It is equivalent to &lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt; only for 2D arrays:</source>
          <target state="translated">函数&lt;a href=&quot;../reference/generated/numpy.column_stack#numpy.column_stack&quot;&gt; &lt;code&gt;column_stack&lt;/code&gt; 将&lt;/a&gt;1D数组作为列堆叠到2D数组中。它仅对2D数组等效于&lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="ada915777af34962f5a155b7336d9374672697e6" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt;&lt;code&gt;busday_offset&lt;/code&gt;&lt;/a&gt; allows you to apply offsets specified in business days to datetimes with a unit of &amp;lsquo;D&amp;rsquo; (day).</source>
          <target state="translated">函数&lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt; &lt;code&gt;busday_offset&lt;/code&gt; &lt;/a&gt;允许您将工作日中指定的偏移量以'D'（天）为单位应用于日期时间。</target>
        </trans-unit>
        <trans-unit id="b326cd579834eae17571b08e2103d37d7f1ef376" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;gun&lt;/code&gt; may return any number of objects as a tuple. Then following rules are applied:</source>
          <target state="translated">功能 &lt;code&gt;gun&lt;/code&gt; 可以将任何数量的对象作为元组返回。然后应用以下规则：</target>
        </trans-unit>
        <trans-unit id="23e4e84916821d7380bf310d4fe3bd37497cc290" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;zeros&lt;/code&gt; creates an array full of zeros, the function &lt;code&gt;ones&lt;/code&gt; creates an array full of ones, and the function &lt;code&gt;empty&lt;/code&gt; creates an array whose initial content is random and depends on the state of the memory. By default, the dtype of the created array is &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;zeros&lt;/code&gt; 创建一个由零组成的数组，函数 &lt;code&gt;ones&lt;/code&gt; 创建由零组成的数组，函数 &lt;code&gt;empty&lt;/code&gt; 创建一个数组，其初始内容是随机的，并取决于内存的状态。默认情况下，创建的数组的 &lt;code&gt;float64&lt;/code&gt; 为float64。</target>
        </trans-unit>
        <trans-unit id="96d8a0725df6e95677a6e264d7cb37fa566a8b73" translate="yes" xml:space="preserve">
          <source>The function assumes that the number of dimensions of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are the same, if necessary prepending the smallest with ones. If &lt;code&gt;a.shape = (r0,r1,..,rN)&lt;/code&gt; and &lt;code&gt;b.shape = (s0,s1,&amp;hellip;,sN)&lt;/code&gt;, the Kronecker product has shape &lt;code&gt;(r0*s0, r1*s1, &amp;hellip;, rN*SN)&lt;/code&gt;. The elements are products of elements from &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, organized explicitly by:</source>
          <target state="translated">该函数假定 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的维数相同，必要时以最小的维为准。如果 &lt;code&gt;a.shape = (r0,r1,..,rN)&lt;/code&gt; 和 &lt;code&gt;b.shape = (s0,s1,&amp;hellip;,sN)&lt;/code&gt; ，则Kronecker积的形状为 &lt;code&gt;(r0*s0, r1*s1, &amp;hellip;, rN*SN)&lt;/code&gt; 。元素是 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 元素的乘积，其显式组织为：</target>
        </trans-unit>
        <trans-unit id="af59a6369749b3cb0f9764af498a65709d68b13e" translate="yes" xml:space="preserve">
          <source>The function has a mean of</source>
          <target state="translated">该函数的平均值为</target>
        </trans-unit>
        <trans-unit id="054f865aa3416e437e5f93f6d6b344a94ea0192f" translate="yes" xml:space="preserve">
          <source>The function has its peak (the mode) at</source>
          <target state="translated">该函数的峰值(模式)在</target>
        </trans-unit>
        <trans-unit id="6069aba02c2ff9e33d0e7ae153f4ba83da37a833" translate="yes" xml:space="preserve">
          <source>The function has its peak at the mean, and its &amp;ldquo;spread&amp;rdquo; increases with the standard deviation (the function reaches 0.607 times its maximum at</source>
          <target state="translated">该函数的平均值处于峰值，其&amp;ldquo;扩展&amp;rdquo;随标准偏差的增加而增加（该函数在0.6倍时达到最大值）</target>
        </trans-unit>
        <trans-unit id="3aafd01a0784838ff12d9b42abaea56f0c51d8d3" translate="yes" xml:space="preserve">
          <source>The function has zeroes where the angle is a multiple of</source>
          <target state="translated">该函数的零点是角度为</target>
        </trans-unit>
        <trans-unit id="8224b60c460c6d30ff461ee22df630041e59b82c" translate="yes" xml:space="preserve">
          <source>The function is accessed as an attribute of or an item from the loaded shared-library. Thus, if &lt;code&gt;./mylib.so&lt;/code&gt; has a function named &lt;code&gt;cool_function1&lt;/code&gt;, I could access this function either as:</source>
          <target state="translated">该功能可以作为已加载共享库的属性或项目来访问。因此，如果 &lt;code&gt;./mylib.so&lt;/code&gt; 有一个名为 &lt;code&gt;cool_function1&lt;/code&gt; 的函数，我可以通过以下方式访问此函数：</target>
        </trans-unit>
        <trans-unit id="fafbcce3a94cb5de2e94d10e8bc93622f1a9c81d" translate="yes" xml:space="preserve">
          <source>The function is also useful for computing some kinds of days like holidays. In Canada and the U.S., Mother&amp;rsquo;s day is on the second Sunday in May, which can be computed with a custom weekmask.</source>
          <target state="translated">该功能对于计算某些日期（例如假期）也很有用。在加拿大和美国，母亲节是五月的第二个星期日，可以使用自定义周掩码来计算。</target>
        </trans-unit>
        <trans-unit id="67cb306690132e9cba2500b1fa7de5410b4f5260" translate="yes" xml:space="preserve">
          <source>The function is applied to both the _data and the _mask, if any.</source>
          <target state="translated">该函数同时应用于_data和_mask(如果有)。</target>
        </trans-unit>
        <trans-unit id="da183d0fc1832c644fcb348cf07cf8e31326309a" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="translated">该函数使用N个参数调用，其中N是&lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;的等级。每个参数代表沿特定轴变化的数组坐标。例如，如果&lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;(2, 2)&lt;/code&gt; ，则参数将为 &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; 和 &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f3d30cf3098994de825e7f6bde3ab7173788815" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="translated">使用N个参数调用该函数，其中N是&lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;的等级。每个参数代表沿特定轴变化的数组坐标。例如，如果&lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;(2, 2)&lt;/code&gt; ，则参数将为 &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; 和 &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d612a9af75e269601691ae7eb90f682a5b996713" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;code&gt;shape&lt;/code&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;code&gt;shape&lt;/code&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="translated">该函数使用N个参数调用，其中N是 &lt;code&gt;shape&lt;/code&gt; 的等级。每个参数代表沿特定轴变化的数组坐标。例如，如果 &lt;code&gt;shape&lt;/code&gt; 为 &lt;code&gt;(2, 2)&lt;/code&gt; ，则参数将为 &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; 和 &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5020746e9a28c81bea9ebded1052af0dc8ae2dc6" translate="yes" xml:space="preserve">
          <source>The function is included as an argument to the python function call to the Fortran subroutine even though it was &lt;em&gt;not&lt;/em&gt; in the Fortran subroutine argument list. The &amp;ldquo;external&amp;rdquo; refers to the C function generated by f2py, not the python function itself. The python function must be supplied to the C function.</source>
          <target state="translated">该函数作为Fortran子例程的python函数调用的参数包含在内，即使它&lt;em&gt;不在&lt;/em&gt;Fortran子例程参数列表中也是如此。&amp;ldquo;外部&amp;rdquo;是指f2py生成的C函数，而不是python函数本身。python函数必须提供给C函数。</target>
        </trans-unit>
        <trans-unit id="8addd0f39cba25bd912a60b0fb5434bfd595dbe3" translate="yes" xml:space="preserve">
          <source>The function pointer type for NpyAuxData clone functions. These functions should never set the Python exception on error, because they may be called from a multi-threaded context.</source>
          <target state="translated">NpyAuxData克隆函数的函数指针类型。这些函数永远不应该在出错时设置Python异常,因为它们可能会在多线程上下文中被调用。</target>
        </trans-unit>
        <trans-unit id="167c7a543d8ccb24656ce9a1687449c4ecfb1950" translate="yes" xml:space="preserve">
          <source>The function pointer type for NpyAuxData free functions.</source>
          <target state="translated">NpyAuxData自由函数的函数指针类型。</target>
        </trans-unit>
        <trans-unit id="a328f1fcd0be371ed7460c86c4fd60c08690a1c3" translate="yes" xml:space="preserve">
          <source>The function returns the coefficients of the polynomial</source>
          <target state="translated">函数返回多项式的系数。</target>
        </trans-unit>
        <trans-unit id="56ed9dbe32b58078e6c4979647428ecdfd02c355" translate="yes" xml:space="preserve">
          <source>The function signature is normally found by introspection and displayed by the help function. For some functions (notably those written in C) the signature is not available, so we have to specify it as the first line of the docstring:</source>
          <target state="translated">函数签名通常是通过自省找到的,并由帮助函数显示。对于一些函数(尤其是那些用C语言编写的函数)来说,签名是不可用的,所以我们必须在docstring的第一行指定它。</target>
        </trans-unit>
        <trans-unit id="f0b123a5d43604d228ff7e22be71c876bc3f213f" translate="yes" xml:space="preserve">
          <source>The function that is called when x and y are omitted</source>
          <target state="translated">省略x和y时调用的函数。</target>
        </trans-unit>
        <trans-unit id="292f9d908dc66f70e34640d48dac32f92d8211ec" translate="yes" xml:space="preserve">
          <source>The function to be approximated. It must be a function of a single variable of the form &lt;code&gt;f(x, a, b, c...)&lt;/code&gt;, where &lt;code&gt;a, b, c...&lt;/code&gt; are extra arguments passed in the &lt;code&gt;args&lt;/code&gt; parameter.</source>
          <target state="translated">要近似的函数。它必须是形式为 &lt;code&gt;f(x, a, b, c...)&lt;/code&gt; 的单个变量的函数，其中 &lt;code&gt;a, b, c...&lt;/code&gt; 是在 &lt;code&gt;args&lt;/code&gt; 参数中传递的额外参数。</target>
        </trans-unit>
        <trans-unit id="e68506a39d4f1164408a473e0014c02732a65744" translate="yes" xml:space="preserve">
          <source>The function to be deprecated.</source>
          <target state="translated">拟废弃的功能。</target>
        </trans-unit>
        <trans-unit id="1ed24e8ca86c415e0834a63e6e6d562c0814371f" translate="yes" xml:space="preserve">
          <source>The function to be interpolated. It must be a function of a single variable of the form &lt;code&gt;f(x, a, b, c...)&lt;/code&gt;, where &lt;code&gt;a, b, c...&lt;/code&gt; are extra arguments passed in the &lt;code&gt;args&lt;/code&gt; parameter.</source>
          <target state="translated">要插值的函数。它必须是形式为 &lt;code&gt;f(x, a, b, c...)&lt;/code&gt; 的单个变量的函数，其中 &lt;code&gt;a, b, c...&lt;/code&gt; 是在 &lt;code&gt;args&lt;/code&gt; 参数中传递的额外参数。</target>
        </trans-unit>
        <trans-unit id="dd5723a1284c8aa8946aa81b4b7601e07d26020c" translate="yes" xml:space="preserve">
          <source>The functionality is based on &lt;a href=&quot;https://docs.python.org/dev/library/os.path.html#os.path.abspath&quot;&gt;&lt;code&gt;os.path.abspath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该功能基于&lt;a href=&quot;https://docs.python.org/dev/library/os.path.html#os.path.abspath&quot;&gt; &lt;code&gt;os.path.abspath&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6e850d04a35d82db7e5c340cdd654a0e7af1cfd" translate="yes" xml:space="preserve">
          <source>The functionality this provides is largely superceded by iterator &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt; introduced in 1.6, with flag &lt;a href=&quot;c-api.iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt; or with the same dtype parameter for all operands.</source>
          <target state="translated">它提供的功能在很大程度上被1.6中引入的&lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt; &lt;code&gt;NpyIter&lt;/code&gt; &lt;/a&gt;迭代器所取代，它带有标志&lt;a href=&quot;c-api.iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt; &lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt; &lt;/a&gt;或所有操作数具有相同的dtype参数。</target>
        </trans-unit>
        <trans-unit id="a07514d8b8d140f4e03babf46c4ca643c0f5e565" translate="yes" xml:space="preserve">
          <source>The functionality this provides is largely superseded by iterator &lt;a href=&quot;iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt; introduced in 1.6, with flag &lt;a href=&quot;iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt; or with the same dtype parameter for all operands.</source>
          <target state="translated">它提供的功能在很大程度上被1.6中引入的&lt;a href=&quot;iterator#c.NpyIter&quot;&gt; &lt;code&gt;NpyIter&lt;/code&gt; &lt;/a&gt;迭代器所取代，它带有标志&lt;a href=&quot;iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt; &lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt; &lt;/a&gt;或所有操作数具有相同的dtype参数。</target>
        </trans-unit>
        <trans-unit id="2962953aa600a37ce10b761bfc967d43ddef0e3d" translate="yes" xml:space="preserve">
          <source>The functions are named with the following conventions:</source>
          <target state="translated">这些函数的命名有以下惯例:</target>
        </trans-unit>
        <trans-unit id="9e207dc9abcf693e32399f76b884fbb8a9e3545f" translate="yes" xml:space="preserve">
          <source>The functions called to implement many arithmetic special methods for arrays can be modified using &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;修改为数组实现许多算术特殊方法的函数。</target>
        </trans-unit>
        <trans-unit id="9d8d64b72fb018cdee0e3f01b29eae167f558f81" translate="yes" xml:space="preserve">
          <source>The functions in the shared library are available as attributes of the ctypes library object (returned from &lt;code&gt;ctypeslib.load_library&lt;/code&gt;) or as items using &lt;code&gt;lib['func_name']&lt;/code&gt; syntax. The latter method for retrieving a function name is particularly useful if the function name contains characters that are not allowable in Python variable names.</source>
          <target state="translated">共享库中的函数可用作ctypes库对象的属性（从 &lt;code&gt;ctypeslib.load_library&lt;/code&gt; 返回），也可以用作使用 &lt;code&gt;lib['func_name']&lt;/code&gt; 语法的项。如果函数名称包含Python变量名称中不允许的字符，则后一种检索函数名称的方法特别有用。</target>
        </trans-unit>
        <trans-unit id="df46d6188871c9afe4dd8663a289bd38fe7112b3" translate="yes" xml:space="preserve">
          <source>The functions without &amp;ldquo;standard&amp;rdquo; in their name require additional parameters to describe the distributions.</source>
          <target state="translated">名称中不带&amp;ldquo;标准&amp;rdquo;的功能需要附加参数来描述分布。</target>
        </trans-unit>
        <trans-unit id="780f3f42d3ad6d900b31dca5cc39ba44b8433b34" translate="yes" xml:space="preserve">
          <source>The future value is computed by solving the equation:</source>
          <target state="translated">通过解方程计算出未来价值。</target>
        </trans-unit>
        <trans-unit id="35263bdc6b8f9ed76c3ffddda6ddc106a35e30ef" translate="yes" xml:space="preserve">
          <source>The gains are substantial and the scaling is reasonable even for arrays that are only moderately large. The gains are even larger when compared to a call that does not use an existing array due to array creation overhead.</source>
          <target state="translated">即使对于只有中等大小的数组来说,收益也是非常可观的,而且扩展也是合理的。与不使用现有数组的调用相比,由于数组创建的开销,收益甚至更大。</target>
        </trans-unit>
        <trans-unit id="f54d15f1fff04aaad23c1e30a6699255a7286273" translate="yes" xml:space="preserve">
          <source>The gains are substantial and the scaling is reasonable even for large that are only moderately large. The gains are even larger when compared to a call that does not use an existing array due to array creation overhead.</source>
          <target state="translated">收益是非常可观的,即使对于只有中等大小的大数组来说,扩展也是合理的。与不使用现有数组的调用相比,由于数组创建开销,收益更大。</target>
        </trans-unit>
        <trans-unit id="3a2348245b14000fc86ba9addf452f0058449713" translate="yes" xml:space="preserve">
          <source>The general concept of broadcasting is also available from Python using the &lt;a href=&quot;generated/numpy.broadcast#numpy.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt; iterator. This object takes</source>
          <target state="translated">也可以使用&lt;a href=&quot;generated/numpy.broadcast#numpy.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt;迭代器从Python获得广播的一般概念。该对象需要</target>
        </trans-unit>
        <trans-unit id="a9641437007836c208f74db848ac79bd7c6780e6" translate="yes" xml:space="preserve">
          <source>The generated file will have the following content:</source>
          <target state="translated">生成的文件将有以下内容。</target>
        </trans-unit>
        <trans-unit id="a2d632f87330613da9716d5bfa0297beb555f76a" translate="yes" xml:space="preserve">
          <source>The generated header &lt;code&gt;_cpu_dispatch.h&lt;/code&gt; contains all the definitions and headers of instruction-sets for the required optimizations that have been validated during the previous step.</source>
          <target state="translated">生成的标头 &lt;code&gt;_cpu_dispatch.h&lt;/code&gt; 包含上一步中已验证的所需优化的所有指令集定义和标头。</target>
        </trans-unit>
        <trans-unit id="49bcb642346cc566dc284f1407822db3afdb919f" translate="yes" xml:space="preserve">
          <source>The generated header takes the name of the dispatch-able source after excluding the extension and replace it with &amp;lsquo;&lt;strong&gt;.h&lt;/strong&gt;&amp;rsquo;, for example assume we have a dispatch-able source called &lt;strong&gt;hello.dispatch.c&lt;/strong&gt; and contains the following:</source>
          <target state="translated">生成的头文件在不包括扩展名的情况下使用了可调度源的名称，并将其替换为&amp;ldquo; &lt;strong&gt;.h&lt;/strong&gt; &amp;rdquo;，例如，假设我们有一个名为&lt;strong&gt;hello.dispatch.c&lt;/strong&gt;的可调度源，并且包含以下内容：</target>
        </trans-unit>
        <trans-unit id="1a1433c2f9219adfdc1717ee54946e456e115a63" translate="yes" xml:space="preserve">
          <source>The generated random samples</source>
          <target state="translated">产生的随机样本</target>
        </trans-unit>
        <trans-unit id="770d667a086582311721a20b1950124d0ed2b0b8" translate="yes" xml:space="preserve">
          <source>The generic hierarchical type objects convert to corresponding type objects according to the associations:</source>
          <target state="translated">通用分层类型对象根据关联转换为相应的类型对象。</target>
        </trans-unit>
        <trans-unit id="7b9da9a1e497b53c1498ef8728ff28c753a44590" translate="yes" xml:space="preserve">
          <source>The given decorator is applied to all public methods of &lt;code&gt;cls&lt;/code&gt; that are matched by the regular expression &lt;code&gt;testmatch&lt;/code&gt; (&lt;code&gt;testmatch.search(methodname)&lt;/code&gt;). Methods that are private, i.e. start with an underscore, are ignored.</source>
          <target state="translated">给定的装饰器适用于所有由正则表达式 &lt;code&gt;testmatch&lt;/code&gt; （ &lt;code&gt;testmatch.search(methodname)&lt;/code&gt; ）匹配的 &lt;code&gt;cls&lt;/code&gt; 的所有公共方法。私有的方法（即以下划线开头）将被忽略。</target>
        </trans-unit>
        <trans-unit id="d15ec8784a28b893c0b85001548e5baae80372c7" translate="yes" xml:space="preserve">
          <source>The gradient is computed using second order accurate central differences in the interior points and either first or second order accurate one-sides (forward or backwards) differences at the boundaries. The returned gradient hence has the same shape as the input array.</source>
          <target state="translated">梯度是利用内部点的二阶精确中心差和边界处的一阶或二阶精确单边(向前或向后)差计算出来的。因此,返回的梯度具有与输入数组相同的形状。</target>
        </trans-unit>
        <trans-unit id="a65f99b3266fd22231848816001d9a126ae0a24e" translate="yes" xml:space="preserve">
          <source>The graph has a strange shape from January 24th to February 1st. It would be interesing to know where this data comes from. If we look at the &lt;code&gt;locations&lt;/code&gt; array we extracted from the &lt;code&gt;.csv&lt;/code&gt; file, we can see that we have two columns, where the first would contain regions and the second would contain the name of the country. However, only the first few rows contain data for the the first column (province names in China). Following that, we only have country names. So it would make sense to group all the data from China into a single row. For this, we&amp;rsquo;ll select from the &lt;code&gt;nbcases&lt;/code&gt; array only the rows for which the second entry of the &lt;code&gt;locations&lt;/code&gt; array corresponds to China. Next, we&amp;rsquo;ll use the &lt;a href=&quot;../reference/generated/numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;numpy.sum&lt;/code&gt;&lt;/a&gt; function to sum all the selected rows (&lt;code&gt;axis=0&lt;/code&gt;):</source>
          <target state="translated">从1月24日到2月1日，图表的形状很奇怪。知道这些数据来自何处将会很有趣。如果查看从 &lt;code&gt;.csv&lt;/code&gt; 文件提取的 &lt;code&gt;locations&lt;/code&gt; 数组，可以看到我们有两列，其中第一列包含地区，第二列包含国家/地区名称。但是，只有前几行包含第一列的数据（中国的省名称）。之后，我们只有国家名称。因此，将来自中国的所有数据分组为一行是很有意义的。为此，我们将从中选择 &lt;code&gt;nbcases&lt;/code&gt; 阵列只行了其第二项 &lt;code&gt;locations&lt;/code&gt; 阵列对应于中国。接下来，我们将使用&lt;a href=&quot;../reference/generated/numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;numpy.sum&lt;/code&gt; &lt;/a&gt;用于汇总所有选定行（ &lt;code&gt;axis=0&lt;/code&gt; ）的函数：</target>
        </trans-unit>
        <trans-unit id="2b74e85f5516f60e3dbf421bf49f69c39506c265" translate="yes" xml:space="preserve">
          <source>The greatest common divisor</source>
          <target state="translated">最大公因子</target>
        </trans-unit>
        <trans-unit id="1335775c2defd62ddac3bf62f622a970f395fc71" translate="yes" xml:space="preserve">
          <source>The greatest common divisor of the absolute value of the inputs This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">输入的绝对值的最大公约数。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="1ffad58d21fbb0c889485660c6a73c057db064f2" translate="yes" xml:space="preserve">
          <source>The header file &amp;lt;numpy/halffloat.h&amp;gt; provides functions to work with IEEE 754-2008 16-bit floating point values. While this format is not typically used for numerical computations, it is useful for storing values which require floating point but do not need much precision. It can also be used as an educational tool to understand the nature of floating point round-off error.</source>
          <target state="translated">头文件&amp;lt;numpy / halffloat.h&amp;gt;提供了与IEEE 754-2008 16位浮点值一起使用的功能。尽管此格式通常不用于数值计算，但对于存储需要浮点但不需要太多精度的值很有用。它也可以用作了解浮点舍入误差性质的教育工具。</target>
        </trans-unit>
        <trans-unit id="d730bb14ffcab30f2844567d44182ca5b3af1815" translate="yes" xml:space="preserve">
          <source>The header of a typical SciPy &lt;code&gt;__init__.py&lt;/code&gt; is:</source>
          <target state="translated">典型的SciPy &lt;code&gt;__init__.py&lt;/code&gt; 的标头是：</target>
        </trans-unit>
        <trans-unit id="881c9d2e47b4057e556e6ff5df02bfb9e5dee04c" translate="yes" xml:space="preserve">
          <source>The highest precision data type of the same kind (&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt;&lt;code&gt;dtype.kind&lt;/code&gt;&lt;/a&gt;) as &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;t&lt;/code&gt; 相同类型（&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt; &lt;code&gt;dtype.kind&lt;/code&gt; &lt;/a&gt;）的最高精度数据类型。</target>
        </trans-unit>
        <trans-unit id="f28aa2c9365c3014c1b3133bf8c0527b1b6cd92f" translate="yes" xml:space="preserve">
          <source>The hyperbolic cosine describes the shape of a hanging cable:</source>
          <target state="translated">双曲余弦描述的是挂线的形状。</target>
        </trans-unit>
        <trans-unit id="5dfe11baf5c84767b263b0b9280dd1d13ec6b531" translate="yes" xml:space="preserve">
          <source>The hypotenuse of the triangle(s). This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">三角形的斜边。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="b1216f6dc1a8f133c88cabe04669f3d387166a72" translate="yes" xml:space="preserve">
          <source>The idea is to consider all but the first &lt;code&gt;k&lt;/code&gt; singular values in &lt;code&gt;Sigma&lt;/code&gt; (which are the same as in &lt;code&gt;s&lt;/code&gt;) as zeros, keeping &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;Vt&lt;/code&gt; intact, and computing the product of these matrices as the approximation.</source>
          <target state="translated">想法是将 &lt;code&gt;Sigma&lt;/code&gt; 中除前 &lt;code&gt;k&lt;/code&gt; 个奇异值（与 &lt;code&gt;s&lt;/code&gt; 中相同）之外的所有奇异值都视为零，保持 &lt;code&gt;U&lt;/code&gt; 和 &lt;code&gt;Vt&lt;/code&gt; 不变，并计算这些矩阵的乘积作为近似值。</target>
        </trans-unit>
        <trans-unit id="a77669c9a72d14b0f58a0186d231f3894219b608" translate="yes" xml:space="preserve">
          <source>The identity array is a square array with ones on the main diagonal.</source>
          <target state="translated">身份数组是一个主对角线上有1的方阵。</target>
        </trans-unit>
        <trans-unit id="2bf1c25d751d392b46c1da854b9e2214e84ecbda" translate="yes" xml:space="preserve">
          <source>The identity value.</source>
          <target state="translated">身份值;</target>
        </trans-unit>
        <trans-unit id="a3a4e04cbf529a826b2105546fd57be959a238a1" translate="yes" xml:space="preserve">
          <source>The imaginary component of the complex argument. If &lt;code&gt;val&lt;/code&gt; is real, the type of &lt;code&gt;val&lt;/code&gt; is used for the output. If &lt;code&gt;val&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">复杂参数的虚构部分。如果 &lt;code&gt;val&lt;/code&gt; 是真实的类型， &lt;code&gt;val&lt;/code&gt; 用于输出。如果 &lt;code&gt;val&lt;/code&gt; 具有复杂元素，则返回的类型为float。</target>
        </trans-unit>
        <trans-unit id="7286bf711b04d53845d16cb5a31eaaaaa02757bf" translate="yes" xml:space="preserve">
          <source>The imaginary part of the array.</source>
          <target state="translated">数组的虚数部分。</target>
        </trans-unit>
        <trans-unit id="9bc674154d61adacb44dda1d44c441449cdf2af6" translate="yes" xml:space="preserve">
          <source>The imaginary part of the masked array.</source>
          <target state="translated">掩码数组的虚数部分。</target>
        </trans-unit>
        <trans-unit id="bd9a2e20c2b901c483b54cb2f5a477f6cf2e7630" translate="yes" xml:space="preserve">
          <source>The imaginary part of the scalar.</source>
          <target state="translated">标量的虚部。</target>
        </trans-unit>
        <trans-unit id="fd6e842a69d72f29a0581eb97a936eaef8759475" translate="yes" xml:space="preserve">
          <source>The implementation of the tests that produce this information.</source>
          <target state="translated">实施产生这些信息的测试;</target>
        </trans-unit>
        <trans-unit id="aee088812e30b5da0a5df1b95d7c39c9c1258247" translate="yes" xml:space="preserve">
          <source>The implementations of multiplication, division, integration, and differentiation use the algebraic identities &lt;a href=&quot;#r3f3efff98d00-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="translated">乘法，除法，积分和微分的实现使用代数恒等式&lt;a href=&quot;#r3f3efff98d00-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="1e2ea421bf4e67c223dedefb366e2029ced79732" translate="yes" xml:space="preserve">
          <source>The importance that each element has in the computation of the average. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one. If &lt;code&gt;weights&lt;/code&gt; is complex, the imaginary parts are ignored.</source>
          <target state="translated">每个元素在平均值计算中的重要性。权重数组可以是1-D（在这种情况下，其长度必须是沿给定轴的 &lt;code&gt;a&lt;/code&gt; 的大小）或与 &lt;code&gt;a&lt;/code&gt; 相同的形状。如果 &lt;code&gt;weights=None&lt;/code&gt; ，则假定 &lt;code&gt;a&lt;/code&gt; 中的所有数据的权重等于1。如果 &lt;code&gt;weights&lt;/code&gt; 很复杂，则虚部将被忽略。</target>
        </trans-unit>
        <trans-unit id="8b1442547658f9bd4727b8dd9df733953ec22b3e" translate="yes" xml:space="preserve">
          <source>The importance that each element has in the computation of the average. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one. The 1-D calculation is:</source>
          <target state="translated">每个元素在平均值计算中的重要性。权重数组可以是1-D（在这种情况下，其长度必须是沿给定轴的 &lt;code&gt;a&lt;/code&gt; 的大小）或与 &lt;code&gt;a&lt;/code&gt; 相同的形状。如果 &lt;code&gt;weights=None&lt;/code&gt; ，则假定 &lt;code&gt;a&lt;/code&gt; 中的所有数据的权重等于1。一维计算为：</target>
        </trans-unit>
        <trans-unit id="f0f3bacce4854001ee5a2b2337e74219eceafb03" translate="yes" xml:space="preserve">
          <source>The include statement is inserted just before the wrapper functions. This feature enables using arbitrary C functions (defined in &lt;code&gt;&amp;lt;includefile&amp;gt;&lt;/code&gt;) in F2PY generated wrappers.</source>
          <target state="translated">include语句仅在包装函数之前插入。此功能允许在F2PY生成的包装器中使用任意C函数（在 &lt;code&gt;&amp;lt;includefile&amp;gt;&lt;/code&gt; 中定义）。</target>
        </trans-unit>
        <trans-unit id="3e99cfec9384fa0ceb0f339e2c89b3b94a829c5f" translate="yes" xml:space="preserve">
          <source>The included BitGenerators are:</source>
          <target state="translated">包含的位元发生器有:</target>
        </trans-unit>
        <trans-unit id="22391c7101fab8760afe729b1932a0c59fad5983" translate="yes" xml:space="preserve">
          <source>The included generators can be used in parallel, distributed applications in one of three ways:</source>
          <target state="translated">包含的生成器可以通过三种方式之一用于并行、分布式应用。</target>
        </trans-unit>
        <trans-unit id="0d9680eef1c6da704d4a94f1afb86f59c497487e" translate="yes" xml:space="preserve">
          <source>The index array consisting of the values 3, 3, 1 and 8 correspondingly create an array of length 4 (same as the index array) where each index is replaced by the value the index array has in the array being indexed.</source>
          <target state="translated">由值3、3、1和8组成的索引数组相应地建立一个长度为4的数组(与索引数组相同),其中每个索引被替换为索引数组在被索引数组中的值。</target>
        </trans-unit>
        <trans-unit id="c31840bf8111dd67b394647308aa4678f4427cf3" translate="yes" xml:space="preserve">
          <source>The index is tracked by the iterator object itself, and accessible through the &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;multi_index&lt;/code&gt; properties, depending on what was requested. The examples below show printouts demonstrating the progression of the index:</source>
          <target state="translated">索引由迭代器对象本身进行跟踪，并且可以根据所请求的内容通过 &lt;code&gt;index&lt;/code&gt; 或 &lt;code&gt;multi_index&lt;/code&gt; 属性进行访问。以下示例显示了显示索引进度的打印输出：</target>
        </trans-unit>
        <trans-unit id="b00c25ebce056fd05b5bde5e2e04470c497a8460" translate="yes" xml:space="preserve">
          <source>The index syntax is very powerful but limiting when dealing with a variable number of indices. For example, if you want to write a function that can handle arguments with various numbers of dimensions without having to write special case code for each number of possible dimensions, how can that be done? If one supplies to the index a tuple, the tuple will be interpreted as a list of indices. For example (using the previous definition for the array z):</source>
          <target state="translated">索引语法的功能非常强大,但在处理可变数量的索引时却有局限性。例如,如果你想写一个可以处理各种维数的参数的函数,而不必为每一个可能的维数写特殊情况代码,如何做到这一点呢?如果向索引提供一个元组,元组将被解释为一个索引列表。例如(使用前面对数组z的定义)。</target>
        </trans-unit>
        <trans-unit id="2c2a3bfa2d0e12fb3599b918fb58fa555ca8de7c" translate="yes" xml:space="preserve">
          <source>The indexed result.</source>
          <target state="translated">索引的结果。</target>
        </trans-unit>
        <trans-unit id="03743182a2227ccf2811c37150a243244da1cf36" translate="yes" xml:space="preserve">
          <source>The indexing works on the flattened target array. &lt;a href=&quot;#numpy.put&quot;&gt;&lt;code&gt;put&lt;/code&gt;&lt;/a&gt; is roughly equivalent to:</source>
          <target state="translated">索引在展平的目标数组上工作。&lt;a href=&quot;#numpy.put&quot;&gt; &lt;code&gt;put&lt;/code&gt; &lt;/a&gt;大致等于：</target>
        </trans-unit>
        <trans-unit id="59838ac2347062b68deb1ef0e067a09f0f1f12f7" translate="yes" xml:space="preserve">
          <source>The indices can be used as an index into an array.</source>
          <target state="translated">这些索引可以作为一个数组的索引。</target>
        </trans-unit>
        <trans-unit id="41bdc266e504f1b3636c2cdbc5a9368b53208f9c" translate="yes" xml:space="preserve">
          <source>The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array.</source>
          <target state="translated">三角形的索引。返回的元组包含两个数组,每个数组都有沿数组一维的索引。</target>
        </trans-unit>
        <trans-unit id="083f53a10046b877a4d17cdf8a047cadb142a0a5" translate="yes" xml:space="preserve">
          <source>The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array. Can be used to slice a ndarray of shape(&lt;code&gt;n&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;).</source>
          <target state="translated">三角形的索引。返回的元组包含两个数组，每个数组的索引沿数组的一维。可用于切片shape（ &lt;code&gt;n&lt;/code&gt; ， &lt;code&gt;n&lt;/code&gt; ）的ndarray 。</target>
        </trans-unit>
        <trans-unit id="313bb1645ee0bcc96011930b78001b8efa601b2f" translate="yes" xml:space="preserve">
          <source>The indices of first and last non-masked value in the array. Returns None if all values are masked.</source>
          <target state="translated">数组中第一个和最后一个非屏蔽值的索引。如果所有值都被屏蔽,则返回None。</target>
        </trans-unit>
        <trans-unit id="02de7d9422fcf4d3bd70015e02df12b6de819fce" translate="yes" xml:space="preserve">
          <source>The indices of the current iteration.</source>
          <target state="translated">当前迭代的指数。</target>
        </trans-unit>
        <trans-unit id="caeefd07d81c974d4f02d2a7cd29c00df5d3e970" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the common values in &lt;code&gt;ar1&lt;/code&gt;. Only provided if &lt;code&gt;return_indices&lt;/code&gt; is True.</source>
          <target state="translated">&lt;code&gt;ar1&lt;/code&gt; 中共同值的首次出现的索引。仅在 &lt;code&gt;return_indices&lt;/code&gt; 为True时提供。</target>
        </trans-unit>
        <trans-unit id="d03a2050722c8950165a7a42c8f8fbec16c8b478" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the common values in &lt;code&gt;ar2&lt;/code&gt;. Only provided if &lt;code&gt;return_indices&lt;/code&gt; is True.</source>
          <target state="translated">&lt;code&gt;ar2&lt;/code&gt; 中公共值首次出现的索引。仅在 &lt;code&gt;return_indices&lt;/code&gt; 为True时提供。</target>
        </trans-unit>
        <trans-unit id="dba5b2feac59133a263255144aa942786b75991f" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the unique values in the original array. Only provided if &lt;code&gt;return_index&lt;/code&gt; is True.</source>
          <target state="translated">原始数组中唯一值的首次出现的索引。仅在 &lt;code&gt;return_index&lt;/code&gt; 为True时提供。</target>
        </trans-unit>
        <trans-unit id="a4f376a3994ea66b3e8fe543f1059936c2c097d7" translate="yes" xml:space="preserve">
          <source>The indices of the matched values can be obtained with &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">可以使用&lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt;值获取匹配值的索引：</target>
        </trans-unit>
        <trans-unit id="43a87c99c2b28bd6cf46e8003a99b97203e9c8c1" translate="yes" xml:space="preserve">
          <source>The indices of the values to extract.</source>
          <target state="translated">要提取的值的指数。</target>
        </trans-unit>
        <trans-unit id="6ca413808a0cb47ebd7eb463c61ac12f6ed3fe9d" translate="yes" xml:space="preserve">
          <source>The indices to reconstruct the original array from the unique array. Only provided if &lt;code&gt;return_inverse&lt;/code&gt; is True.</source>
          <target state="translated">从唯一数组重建原始数组的索引。仅在 &lt;code&gt;return_inverse&lt;/code&gt; 为True时提供。</target>
        </trans-unit>
        <trans-unit id="76cdf05ced9d0285381afd071b2e4305a0c8b8a1" translate="yes" xml:space="preserve">
          <source>The indices will be valid for square arrays whose dimensions are the same as arr.</source>
          <target state="translated">指数将对尺寸与嵺峃相同的正方形数组有效。</target>
        </trans-unit>
        <trans-unit id="b73635c48b132fb2b59a6aa95f3cc03ac517b9fa" translate="yes" xml:space="preserve">
          <source>The indices will be valid for square arrays.</source>
          <target state="translated">指数将对方形数组有效。</target>
        </trans-unit>
        <trans-unit id="2408a7bae27e18b5f16ce6bfc6c2e9edbdf96e75" translate="yes" xml:space="preserve">
          <source>The info dict contains the necessary options to use the C library.</source>
          <target state="translated">info dict包含了使用C库的必要选项。</target>
        </trans-unit>
        <trans-unit id="1a162a1581bd9df0f0c132b54dd0bc2b023b7fbc" translate="yes" xml:space="preserve">
          <source>The initialized generator object.</source>
          <target state="translated">初始化的生成器对象。</target>
        </trans-unit>
        <trans-unit id="b17807d1d3d4b02432b9a563a71fb115959130d3" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;a&lt;/code&gt; as a float ndarray.</source>
          <target state="translated">输入 &lt;code&gt;a&lt;/code&gt; 为float ndarray。</target>
        </trans-unit>
        <trans-unit id="223b4394f2d166cb77455c12d7788790c3301749" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;a&lt;/code&gt; in Fortran, or column-major, order.</source>
          <target state="translated">以Fortran或列优先的顺序输入 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75fd22e41868bea41cd02857931f82382a569f45" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;seed&lt;/code&gt; is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to generate the key. The counter is set to 0.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;处理输入的 &lt;code&gt;seed&lt;/code&gt; 以生成密钥。计数器设置为0。</target>
        </trans-unit>
        <trans-unit id="528560fa701c687c766a152165432c7d1064754a" translate="yes" xml:space="preserve">
          <source>The input array</source>
          <target state="translated">输入阵列</target>
        </trans-unit>
        <trans-unit id="c14ffcb4fd955aec9b7bdb6f4e9b85112587e6c8" translate="yes" xml:space="preserve">
          <source>The input array needs to be of integer dtype, otherwise a TypeError is raised:</source>
          <target state="translated">输入数组必须是整数dtype,否则会引发TypeError。</target>
        </trans-unit>
        <trans-unit id="8ffb9fe9f3741ba95404f548e61803acdf79b642" translate="yes" xml:space="preserve">
          <source>The input array with invalid entries fixed.</source>
          <target state="translated">固定无效条目的输入数组。</target>
        </trans-unit>
        <trans-unit id="729e431a614c3f0d0d957b108e3ad1877caf7dd5" translate="yes" xml:space="preserve">
          <source>The input array&amp;rsquo;s mask is modified by this function.</source>
          <target state="translated">通过此功能可以修改输入数组的掩码。</target>
        </trans-unit>
        <trans-unit id="2bcc0bcc75499b8aa5923f648739bb1e1c9c5f2a" translate="yes" xml:space="preserve">
          <source>The input array, but with all or a subset of the dimensions of length 1 removed. This is always &lt;code&gt;a&lt;/code&gt; itself or a view into &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">输入数组，但删除了长度为1的全部或部分维度。这始终是 &lt;code&gt;a&lt;/code&gt; 本身或看到 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9c1757f1f00139c3d32d32875dc4cdee7e7573b" translate="yes" xml:space="preserve">
          <source>The input array, but with all or a subset of the dimensions of length 1 removed. This is always &lt;code&gt;a&lt;/code&gt; itself or a view into &lt;code&gt;a&lt;/code&gt;. Note that if all axes are squeezed, the result is a 0d array and not a scalar.</source>
          <target state="translated">输入数组，但删除了长度为1的全部或部分维度。这始终是 &lt;code&gt;a&lt;/code&gt; 本身或看到 &lt;code&gt;a&lt;/code&gt; 。请注意，如果所有轴都受到​​挤压，则结果为0d数组，而不是标量。</target>
        </trans-unit>
        <trans-unit id="3b9eebd6f3c2dccb825ca1eb5d3b6fff39eb990c" translate="yes" xml:space="preserve">
          <source>The input array.</source>
          <target state="translated">输入数组。</target>
        </trans-unit>
        <trans-unit id="a8dbbfb64079646cc26f949474f62f6d5a8bdb10" translate="yes" xml:space="preserve">
          <source>The input arrays are the coefficients (including any coefficients equal to zero) of the &amp;ldquo;numerator&amp;rdquo; (dividend) and &amp;ldquo;denominator&amp;rdquo; (divisor) polynomials, respectively.</source>
          <target state="translated">输入数组分别是&amp;ldquo;分子&amp;rdquo;（红利）和&amp;ldquo;分母&amp;rdquo;（除数）多项式的系数（包括等于零的任何系数）。</target>
        </trans-unit>
        <trans-unit id="a4fe0b89df27127c64e2d6a838fb7376eb328411" translate="yes" xml:space="preserve">
          <source>The input can be of any type and shape.</source>
          <target state="translated">输入的内容可以是任何类型和形状。</target>
        </trans-unit>
        <trans-unit id="0756c557e9cd622a4b4a6242d6e56ce5652e83a5" translate="yes" xml:space="preserve">
          <source>The input data type is preserved, list/tuple in means list/tuple out.</source>
          <target state="translated">保留输入数据类型,list/tuple in意味着list/tuple out。</target>
        </trans-unit>
        <trans-unit id="7e65fba32b4c379aee34d72564b929f364329962" translate="yes" xml:space="preserve">
          <source>The input data type. This can be a &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; object or an object that is convertible to a &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">输入数据类型。这可以是&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;对象，也可以是可转换为&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;的对象。</target>
        </trans-unit>
        <trans-unit id="8769eb794f5a03165931ba8181e41168fd7a696f" translate="yes" xml:space="preserve">
          <source>The input domain.</source>
          <target state="translated">输入域。</target>
        </trans-unit>
        <trans-unit id="8cece683eb84b1c6561cdb1ebf8cbf9f503e743a" translate="yes" xml:space="preserve">
          <source>The input is expected to be in the form returned by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, i.e. the real zero-frequency term followed by the complex positive frequency terms in order of increasing frequency. Since the discrete Fourier Transform of real input is Hermitian-symmetric, the negative frequency terms are taken to be the complex conjugates of the corresponding positive frequency terms.</source>
          <target state="translated">输入应采用&lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt;返回的形式，即按照频率递增的顺序，实零频率项，后跟复正频率项。由于实际输入的离散傅立叶变换是厄米对称的，因此负频率项被视为对应正频率项的复共轭。</target>
        </trans-unit>
        <trans-unit id="6f9750084d20ac908a43842756c2b861e3f42c50" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to fill the whole state. The first element is reset such that only its most significant bit is set.</source>
          <target state="translated">输入的种子由&lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;处理以填充整个状态。重置第一个元素，以便仅设置其最高有效位。</target>
        </trans-unit>
        <trans-unit id="a8974905180f39b4ffd2915ed945588ac5ab3b98" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to generate both values. The increment is not independently settable.</source>
          <target state="translated">输入的种子由&lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;处理以生成两个值。增量不能独立设置。</target>
        </trans-unit>
        <trans-unit id="9c7b1d5b6198e399c073a141f7cd1b6b8febb604" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to generate the first 3 values, then the &lt;code&gt;SFC64&lt;/code&gt; algorithm is iterated a small number of times to mix.</source>
          <target state="translated">输入的种子由&lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;处理以生成前三个值，然后将 &lt;code&gt;SFC64&lt;/code&gt; 算法迭代几次以进行混合。</target>
        </trans-unit>
        <trans-unit id="8d2a5838e3e88200b2eb57081e0d55983a6951c5" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to fill the whole state. The first element is reset such that only its most significant bit is set.</source>
          <target state="translated">输入的种子由 &lt;code&gt;SeedSequence&lt;/code&gt; 处理以填充整个状态。重置第一个元素，以便仅设置其最高有效位。</target>
        </trans-unit>
        <trans-unit id="b59429801bb072b95be274b2cab8c79cb4d9a0af" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate both values. The increment is not independently settable.</source>
          <target state="translated">输入的种子由 &lt;code&gt;SeedSequence&lt;/code&gt; 处理以生成两个值。增量不能独立设置。</target>
        </trans-unit>
        <trans-unit id="837326b6e18d83ecb217345cd40ecfada7f873f1" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate the first 3 values, then the &lt;code&gt;SFC64&lt;/code&gt; algorithm is iterated a small number of times to mix.</source>
          <target state="translated">输入的种子由 &lt;code&gt;SeedSequence&lt;/code&gt; 处理以生成前三个值，然后将 &lt;code&gt;SFC64&lt;/code&gt; 算法迭代几次以进行混合。</target>
        </trans-unit>
        <trans-unit id="df03e47997abce099faab26366e6f5795a2b583f" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate the key. The counter is set to 0.</source>
          <target state="translated">&lt;code&gt;SeedSequence&lt;/code&gt; 处理输入的种子以生成密钥。计数器设置为0。</target>
        </trans-unit>
        <trans-unit id="ee2b41f2ea30e39cb3d7552711a0b3d766641ddc" translate="yes" xml:space="preserve">
          <source>The input should be ordered in the same way as is returned by &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, i.e.,</source>
          <target state="translated">输入的顺序应与&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;返回的顺序相同，即，</target>
        </trans-unit>
        <trans-unit id="9065e71c46c758a421d1a5608c4e7515cdea0b0c" translate="yes" xml:space="preserve">
          <source>The input should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, i.e.,</source>
          <target state="translated">输入的顺序应与&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;返回的顺序相同，即，</target>
        </trans-unit>
        <trans-unit id="14cd4f07dbbafbca343da6b376f0bb96ca0ebb1e" translate="yes" xml:space="preserve">
          <source>The input should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;, i.e. as for &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; for the final transformation axis, and as for &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; along all the other axes.</source>
          <target state="translated">输入应以相同的方式如通过返回订购&lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt;，即作为用于&lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt;用于最终转化轴，和作为用于&lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt;沿所有其它轴。</target>
        </trans-unit>
        <trans-unit id="44801963410659f1459e257160aa0d4b1ef39ba2" translate="yes" xml:space="preserve">
          <source>The input value(s).</source>
          <target state="translated">输入值;</target>
        </trans-unit>
        <trans-unit id="519628f03d9ba5d6ae3260f3b709f32afd6fac80" translate="yes" xml:space="preserve">
          <source>The input, analogously to &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fft2#numpy.fft.fft2&quot;&gt;&lt;code&gt;fft2&lt;/code&gt;&lt;/a&gt;, i.e. it should have the term for zero frequency in the low-order corner of the two axes, the positive frequency terms in the first half of these axes, the term for the Nyquist frequency in the middle of the axes and the negative frequency terms in the second half of both axes, in order of decreasingly negative frequency.</source>
          <target state="translated">输入类似于&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt;，应按与&lt;a href=&quot;numpy.fft.fft2#numpy.fft.fft2&quot;&gt; &lt;code&gt;fft2&lt;/code&gt; &lt;/a&gt;返回相同的方式进行排序，即，在两个轴的低阶角应具有零频率项，而在前半个轴应具有正频率项轴的中间是奈奎斯特频率项，两个轴的后半部分是负频率项，以负频率递减的顺序排列。</target>
        </trans-unit>
        <trans-unit id="572b4f9e26edc1e967cf68e0ade8b40ff905e225" translate="yes" xml:space="preserve">
          <source>The input, analogously to &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;, i.e. it should have the term for zero frequency in all axes in the low-order corner, the positive frequency terms in the first half of all axes, the term for the Nyquist frequency in the middle of all axes and the negative frequency terms in the second half of all axes, in order of decreasingly negative frequency.</source>
          <target state="translated">输入类似于&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt;，应按与fftn返回相同的方式进行&lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt;，即输入应在低阶角的所有轴中都具有零频率项，在所有轴的前半部中均具有正频率项，所有轴中间的奈奎斯特频率项，所有轴后半部分的负频率项，以负频率递减的顺序排列。</target>
        </trans-unit>
        <trans-unit id="c971acf535ef1a0fc093a548ed92e5c2192bc129" translate="yes" xml:space="preserve">
          <source>The integer base(s) in which the log is taken.</source>
          <target state="translated">采集日志的整数基数。</target>
        </trans-unit>
        <trans-unit id="700a52e4f937c0dcc3e7f0a408095f8426dc542f" translate="yes" xml:space="preserve">
          <source>The integer value of flags.</source>
          <target state="translated">标志的整数值。</target>
        </trans-unit>
        <trans-unit id="0d58354ed5e0735b3768fbb2adf71637dbdf3f49" translate="yes" xml:space="preserve">
          <source>The integration constants default to zero, but can be specified:</source>
          <target state="translated">积分常数默认为零,但可以指定。</target>
        </trans-unit>
        <trans-unit id="b8cfb0f4ba349fe08f791a3f4e9c32e0be770fb0" translate="yes" xml:space="preserve">
          <source>The intent directive, intent(out) is used to tell f2py that &lt;code&gt;c&lt;/code&gt; is an output variable and should be created by the interface before being passed to the underlying code. The intent(hide) directive tells f2py to not allow the user to specify the variable, &lt;code&gt;n&lt;/code&gt;, but instead to get it from the size of &lt;code&gt;a&lt;/code&gt;. The depend( &lt;code&gt;a&lt;/code&gt; ) directive is necessary to tell f2py that the value of n depends on the input a (so that it won&amp;rsquo;t try to create the variable n until the variable a is created).</source>
          <target state="translated">Intent指令intent（out）用于告诉f2py &lt;code&gt;c&lt;/code&gt; 是输出变量，应该在传递给基础代码之前由接口创建。这样做的目的（隐藏）指令告诉f2py不允许用户指定变量， &lt;code&gt;n&lt;/code&gt; ，而是从规模得到它 &lt;code&gt;a&lt;/code&gt; 。将取决于（ &lt;code&gt;a&lt;/code&gt; ）指导是必要告诉f2py n的值取决于输入（所以它不会尝试创建变量n，直至创建一个变量）。</target>
        </trans-unit>
        <trans-unit id="fef0aef07474fa13f32cd7e44f96fd84d9e33ac9" translate="yes" xml:space="preserve">
          <source>The interface definition file (.pyf) is how you can fine-tune the interface between Python and Fortran. There is decent documentation for f2py found in the numpy/f2py/docs directory where-ever NumPy is installed on your system (usually under site-packages). There is also more information on using f2py (including how to use it to wrap C codes) at &lt;a href=&quot;https://scipy-cookbook.readthedocs.io&quot;&gt;https://scipy-cookbook.readthedocs.io&lt;/a&gt; under the &amp;ldquo;Interfacing With Other Languages&amp;rdquo; heading.</source>
          <target state="translated">接口定义文件（.pyf）是您如何微调Python和Fortran之间的接口。在numpy / f2py / docs目录中找到关于f2py的体面文档，无论您在系统上安装了NumPy的位置如何（通常在站点软件包下）。在&lt;a href=&quot;https://scipy-cookbook.readthedocs.io&quot;&gt;https://scipy-cookbook.readthedocs.io&lt;/a&gt;的&amp;ldquo;与其他语言交互&amp;rdquo;标题下，还提供了有关使用f2py的更多信息（包括如何使用它包装C代码）。</target>
        </trans-unit>
        <trans-unit id="a5987614ed3add49e80f0f100dd67a16f44fe90c" translate="yes" xml:space="preserve">
          <source>The interpolated values, same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">内插值，形状与 &lt;code&gt;x&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="c7907bef880fafa82932152f51dbb34029c0604c" translate="yes" xml:space="preserve">
          <source>The inverse &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt;&lt;code&gt;cos&lt;/code&gt;&lt;/a&gt; is also known as &lt;code&gt;acos&lt;/code&gt; or cos^-1.</source>
          <target state="translated">逆&lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt; &lt;code&gt;cos&lt;/code&gt; &lt;/a&gt;也称为 &lt;code&gt;acos&lt;/code&gt; 或cos ^ -1。</target>
        </trans-unit>
        <trans-unit id="ec2dceba2b532e6fed6c11da573a946f40425e79" translate="yes" xml:space="preserve">
          <source>The inverse DFT is defined as</source>
          <target state="translated">逆DFT定义为</target>
        </trans-unit>
        <trans-unit id="8495a1f69fb848ed573ead2789554fd370f64138" translate="yes" xml:space="preserve">
          <source>The inverse Gaussian distribution was first studied in relationship to Brownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian because there is an inverse relationship between the time to cover a unit distance and distance covered in unit time.</source>
          <target state="translated">逆高斯分布最早是在布朗运动的关系中被研究出来的。1956年,M.C.K.Tweedie使用了逆高斯这个名字,因为单位距离所需的时间和单位时间内所覆盖的距离之间存在着反向关系。</target>
        </trans-unit>
        <trans-unit id="fa59414aa20d4f47a4881cb0d68d8dadceab9bea" translate="yes" xml:space="preserve">
          <source>The inverse cosine(s) of the &lt;code&gt;x&lt;/code&gt; value(s). If &lt;code&gt;x&lt;/code&gt; was a scalar, so is &lt;code&gt;out&lt;/code&gt;, otherwise an array object is returned.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 值的反余弦值。如果 &lt;code&gt;x&lt;/code&gt; 是一个标量，则 &lt;code&gt;out&lt;/code&gt; 是，否则返回一个数组对象。</target>
        </trans-unit>
        <trans-unit id="68560eb00ac6299a73ce699655a0c6fd4e05a46a" translate="yes" xml:space="preserve">
          <source>The inverse function.</source>
          <target state="translated">反函数。</target>
        </trans-unit>
        <trans-unit id="fe2bbafffa2c0c536b90659aca2befdd2f2ba17e" translate="yes" xml:space="preserve">
          <source>The inverse hyperbolic sine is also known as &lt;code&gt;asinh&lt;/code&gt; or &lt;code&gt;sinh^-1&lt;/code&gt;.</source>
          <target state="translated">反双曲正弦也称为 &lt;code&gt;asinh&lt;/code&gt; 或 &lt;code&gt;sinh^-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a141e357fc6a95097873c345fcfc1ca43237a09" translate="yes" xml:space="preserve">
          <source>The inverse hyperbolic tangent is also known as &lt;code&gt;atanh&lt;/code&gt; or &lt;code&gt;tanh^-1&lt;/code&gt;.</source>
          <target state="translated">反双曲正切也称为 &lt;code&gt;atanh&lt;/code&gt; 或 &lt;code&gt;tanh^-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="553056619b9eeee97e1c078e300256a83649a37f" translate="yes" xml:space="preserve">
          <source>The inverse hyperbolic tangent(s) of the &lt;code&gt;x&lt;/code&gt; value(s). If &lt;code&gt;x&lt;/code&gt; was a scalar so is &lt;code&gt;out&lt;/code&gt;, otherwise an array is returned.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 值的反双曲正切值。如果 &lt;code&gt;x&lt;/code&gt; 是一个标量，则为 &lt;code&gt;out&lt;/code&gt; ，否则返回一个数组。</target>
        </trans-unit>
        <trans-unit id="aed0ee03d4e87b9fedd1788aca12c58fdfb391c4" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;的倒数。</target>
        </trans-unit>
        <trans-unit id="0b353ae768e12e71d0fa6bfe266dc15cf5490d90" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;, the inverse &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">的逆&lt;a href=&quot;#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt;，逆&lt;em&gt;&amp;ntilde;&lt;/em&gt;维FFT。</target>
        </trans-unit>
        <trans-unit id="c086c016e117d897d4f2eb057744861a76634688" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt;的反函数。</target>
        </trans-unit>
        <trans-unit id="9c2cb38b9631386379f4eeff7af3bee02f4b9bd5" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.hfft&quot;&gt;&lt;code&gt;hfft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.hfft&quot;&gt; &lt;code&gt;hfft&lt;/code&gt; &lt;/a&gt;的反函数。</target>
        </trans-unit>
        <trans-unit id="13314fd29e0fae4ac48c552fa0a549b05087d956" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt;的逆。</target>
        </trans-unit>
        <trans-unit id="ff66e88345498b6e91d7444ef284a6ddd3ab7bea" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;, i.e. the inverse of the n-dimensional FFT of real input.</source>
          <target state="translated">的逆&lt;a href=&quot;#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt;，即实际输入的n维FFT的倒数。</target>
        </trans-unit>
        <trans-unit id="4d74143e09328ea010bc57b6540cfb8051fcdf5e" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;的倒数。</target>
        </trans-unit>
        <trans-unit id="9e5b2a4471d9b30f761353eccfa786e46a0a43ee" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;generated/numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt;的反函数。</target>
        </trans-unit>
        <trans-unit id="f58d6b52f1a134a30d097dc36ab0b6c772a15466" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt;&lt;code&gt;cos&lt;/code&gt;&lt;/a&gt; so that, if &lt;code&gt;y = cos(x)&lt;/code&gt;, then &lt;code&gt;x = arccos(y)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt; &lt;code&gt;cos&lt;/code&gt; &lt;/a&gt;的倒数，因此，如果 &lt;code&gt;y = cos(x)&lt;/code&gt; ，则 &lt;code&gt;x = arccos(y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55a9d6743075a74b179dcc12407ef1436ea7bf25" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;. Although identical for even-length &lt;code&gt;x&lt;/code&gt;, the functions differ by one sample for odd-length &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt;的反函数。虽然对于相同偶数长度 &lt;code&gt;x&lt;/code&gt; 时，这些功能由为奇数长度一个样品不同 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b74e3f8abd785dde93a2e8dda9f5c04957251f7" translate="yes" xml:space="preserve">
          <source>The inverse of tan, so that if &lt;code&gt;y = tan(x)&lt;/code&gt; then &lt;code&gt;x = arctan(y)&lt;/code&gt;.</source>
          <target state="translated">tan的倒数，因此，如果 &lt;code&gt;y = tan(x)&lt;/code&gt; 则 &lt;code&gt;x = arctan(y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7167a352b20dee7e079ce80d9af1a1aba672dc81" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;em&gt;n&lt;/em&gt;-dimensional FFT of real input.</source>
          <target state="translated">实数输入的&lt;em&gt;n&lt;/em&gt;维FFT的逆函数。</target>
        </trans-unit>
        <trans-unit id="c880c78696b367269e70a1f53424d9f97028c767" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt;维FFT 的逆函数。</target>
        </trans-unit>
        <trans-unit id="f53fd91fa9c77430f006f0266202a3482a70bbcc" translate="yes" xml:space="preserve">
          <source>The inverse of the one-dimensional FFT of real input.</source>
          <target state="translated">实输入的一维FFT的反。</target>
        </trans-unit>
        <trans-unit id="3905252dc05b002d9515309faf3f78f1dbb4c5f8" translate="yes" xml:space="preserve">
          <source>The inverse of the two-dimensional FFT of real input.</source>
          <target state="translated">实输入的二维FFT的反。</target>
        </trans-unit>
        <trans-unit id="80593089870dd83ea035aa88fb44d2f41784516a" translate="yes" xml:space="preserve">
          <source>The inverse operation, adding entries of length one</source>
          <target state="translated">反向操作,将长度为1的条目相加。</target>
        </trans-unit>
        <trans-unit id="3423775348fb08030d24725c90e7b0f2bd7d7c47" translate="yes" xml:space="preserve">
          <source>The inverse operation, adding singleton dimensions</source>
          <target state="translated">反向操作,增加单子维度</target>
        </trans-unit>
        <trans-unit id="aa766ce77746577ed5c08c35ec888672cda564ff" translate="yes" xml:space="preserve">
          <source>The inverse operation, removing singleton dimensions</source>
          <target state="translated">反向操作,去除单子维度</target>
        </trans-unit>
        <trans-unit id="61a85cd6779e9d5a8b6211c3c235036b15ffb999" translate="yes" xml:space="preserve">
          <source>The inverse sine is also known as &lt;code&gt;asin&lt;/code&gt; or sin^{-1}.</source>
          <target state="translated">反正弦也称为 &lt;code&gt;asin&lt;/code&gt; 或sin ^ {-1}。</target>
        </trans-unit>
        <trans-unit id="bfedf779c5c4bd6b17ab80b12a0d79168ab5aaa7" translate="yes" xml:space="preserve">
          <source>The inverse sine of each element in &lt;code&gt;x&lt;/code&gt;, in radians and in the closed interval &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 中每个元素的反正弦，以弧度为单位，并且以闭合区间 &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt; 。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="07d977535bf5ffed042d449d14c2b30422676d24" translate="yes" xml:space="preserve">
          <source>The inverse sine(s) of the &lt;code&gt;x&lt;/code&gt; value(s). If &lt;code&gt;x&lt;/code&gt; was a scalar, so is &lt;code&gt;out&lt;/code&gt;, otherwise an array object is returned.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 值的反正弦值。如果 &lt;code&gt;x&lt;/code&gt; 是一个标量，则 &lt;code&gt;out&lt;/code&gt; 是，否则返回一个数组对象。</target>
        </trans-unit>
        <trans-unit id="9c1a84044c9dab08c09d55a04b2b48623b8d59b6" translate="yes" xml:space="preserve">
          <source>The inverse tangent is also known as &lt;code&gt;atan&lt;/code&gt; or tan^{-1}.</source>
          <target state="translated">逆切线也称为 &lt;code&gt;atan&lt;/code&gt; 或tan ^ {-1}。</target>
        </trans-unit>
        <trans-unit id="6981525643a6c5c7fc9e1e7dde681f16ce56e65e" translate="yes" xml:space="preserve">
          <source>The inverse two-dimensional FFT.</source>
          <target state="translated">反二维FFT。</target>
        </trans-unit>
        <trans-unit id="bdb5ead908952013fac6606928f3a4c8d7370b91" translate="yes" xml:space="preserve">
          <source>The irrational number &lt;code&gt;e&lt;/code&gt; is also known as Euler&amp;rsquo;s number. It is approximately 2.718281, and is the base of the natural logarithm, &lt;code&gt;ln&lt;/code&gt; (this means that, if</source>
          <target state="translated">无理数 &lt;code&gt;e&lt;/code&gt; 也称为欧拉数。它约为2.718281，并且是自然对数 &lt;code&gt;ln&lt;/code&gt; 的底数（这意味着，如果</target>
        </trans-unit>
        <trans-unit id="3dd3b5ec09656689d6b02dda587489104a598f1e" translate="yes" xml:space="preserve">
          <source>The iterator flag &amp;ldquo;delay_bufalloc&amp;rdquo; is there to allow iterator-allocated reduction operands to exist together with buffering. When this flag is set, the iterator will leave its buffers uninitialized until it receives a reset, after which it will be ready for regular iteration. Here&amp;rsquo;s how the previous example looks if we also enable buffering.</source>
          <target state="translated">迭代器标志&amp;ldquo; delay_bufalloc&amp;rdquo;用于允许分配迭代器的归约操作数与缓冲一起存在。设置此标志后，迭代器将使其缓冲区保持未初始化状态，直到接收到重置为止，此后它将准备进行常规迭代。如果我们还启用了缓冲，则这是前一个示例的外观。</target>
        </trans-unit>
        <trans-unit id="83edec37e4aaff5eef637f7c874f4dba22293c2c" translate="yes" xml:space="preserve">
          <source>The iterator holds a reference to iter</source>
          <target state="translated">迭代器持有一个对iter</target>
        </trans-unit>
        <trans-unit id="ffb4fa1555c6cc08c5edb304e11089604a5e4b03" translate="yes" xml:space="preserve">
          <source>The iterator layout is an internal detail, and user code only sees an incomplete struct.</source>
          <target state="translated">迭代器布局是一个内部细节,用户代码只能看到一个不完整的结构。</target>
        </trans-unit>
        <trans-unit id="5cd3a081c57ba646ed11444a9ba92c76e9cd9145" translate="yes" xml:space="preserve">
          <source>The iterator object &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;, introduced in NumPy 1.6, provides many flexible ways to visit all the elements of one or more arrays in a systematic fashion. This page introduces some basic ways to use the object for computations on arrays in Python, then concludes with how one can accelerate the inner loop in Cython. Since the Python exposure of &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; is a relatively straightforward mapping of the C array iterator API, these ideas will also provide help working with array iteration from C or C++.</source>
          <target state="translated">NumPy 1.6中引入的迭代器对象&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;提供了许多灵活的方式来系统地访问一个或多个数组的所有元素。本页介绍了一些基本的方法来使用该对象在Python中对数组进行计算，然后总结如何在Cython中加速内部循环。由于&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;的Python暴露是C数组迭代器API的相对简单的映射，因此这些想法​​也将为使用C或C ++进行数组迭代提供帮助。</target>
        </trans-unit>
        <trans-unit id="c7cde3e3f66c5a8b8cc8bfff4db276cc023c595e" translate="yes" xml:space="preserve">
          <source>The iterator uses NumPy&amp;rsquo;s casting rules to determine whether a specific conversion is permitted. By default, it enforces &amp;lsquo;safe&amp;rsquo; casting. This means, for example, that it will raise an exception if you try to treat a 64-bit float array as a 32-bit float array. In many cases, the rule &amp;lsquo;same_kind&amp;rsquo; is the most reasonable rule to use, since it will allow conversion from 64 to 32-bit float, but not from float to int or from complex to float.</source>
          <target state="translated">迭代器使用NumPy的转换规则来确定是否允许特定的转换。默认情况下，它强制执行&amp;ldquo;安全&amp;rdquo;强制转换。例如，这意味着，如果您尝试将64位浮点数组视为32位浮点数组，它将引发异常。在许多情况下，规则&amp;ldquo; same_kind&amp;rdquo;是最合理使用的规则，因为它将允许从64位浮点数转换为32位浮点数，但不允许从float转换为int或从复数转换为float。</target>
        </trans-unit>
        <trans-unit id="cacf8c06cd15c0c88c5430d945ba0f2cf7ba5182" translate="yes" xml:space="preserve">
          <source>The ix_() function</source>
          <target state="translated">ix_()函数</target>
        </trans-unit>
        <trans-unit id="bfb129467dcc5458e92314d1dc23bfece4b4c9b2" translate="yes" xml:space="preserve">
          <source>The jump size is</source>
          <target state="translated">跳跃的大小是</target>
        </trans-unit>
        <trans-unit id="ce335f317c6680914a491bd8a7fe70c41740c803" translate="yes" xml:space="preserve">
          <source>The jump step is computed using a modified version of Matsumoto&amp;rsquo;s implementation of Horner&amp;rsquo;s method. The step polynomial is precomputed to perform 2**128 steps. The jumped state has been verified to match the state produced using Matsumoto&amp;rsquo;s original code.</source>
          <target state="translated">跳转步骤是使用Matsumoto实现的Horner方法的修改版来计算的。步骤多项式被预先计算以执行2 ** 128个步骤。跳跃状态已​​被验证为与使用Matsumoto原始代码产生的状态相匹配。</target>
        </trans-unit>
        <trans-unit id="342e9169764fb77c1b214a706155105da1218b49" translate="yes" xml:space="preserve">
          <source>The key should be either a string or a sequence of string corresponding to the fields used to join the array. An exception is raised if the &lt;code&gt;key&lt;/code&gt; field cannot be found in the two input arrays. Neither &lt;code&gt;r1&lt;/code&gt; nor &lt;code&gt;r2&lt;/code&gt; should have any duplicates along &lt;code&gt;key&lt;/code&gt;: the presence of duplicates will make the output quite unreliable. Note that duplicates are not looked for by the algorithm.</source>
          <target state="translated">键应为字符串或与用于连接数组的字段相对应的字符串序列。如果在两个输入数组中找不到 &lt;code&gt;key&lt;/code&gt; 字段，则会引发异常。 &lt;code&gt;r1&lt;/code&gt; 和 &lt;code&gt;r2&lt;/code&gt; 都不应该在 &lt;code&gt;key&lt;/code&gt; 上有任何重复项：重复项的存在会使输出相当不可靠。请注意，算法不会查找重复项。</target>
        </trans-unit>
        <trans-unit id="1697c380f1179f3bbb3a86f4d75a8de0b46efbc6" translate="yes" xml:space="preserve">
          <source>The keys are:</source>
          <target state="translated">钥匙是:</target>
        </trans-unit>
        <trans-unit id="e784f79f4b595daae262ce721526297b147bf52d" translate="yes" xml:space="preserve">
          <source>The keywords mainly represent the additional optimizations configured through &lt;code&gt;--cpu-dispatch&lt;/code&gt;, but it can also represent other options such as:</source>
          <target state="translated">关键字主要表示通过 &lt;code&gt;--cpu-dispatch&lt;/code&gt; 配置的其他优化，但也可以表示其他选项，例如：</target>
        </trans-unit>
        <trans-unit id="b094a8a56c283a1dca9080c127defb8dc7eabacc" translate="yes" xml:space="preserve">
          <source>The kind of integer data type to get information about.</source>
          <target state="translated">要获取信息的整数数据类型的种类。</target>
        </trans-unit>
        <trans-unit id="41c3ca93d5f02dccd969da26a833b72af9110c68" translate="yes" xml:space="preserve">
          <source>The kwds argument holds a Python dictionary whose keys are the names of the keyword arguments and whose values are the corresponding keyword-argument values. This dictionary can be processed however you see fit. The easiest way to handle it, however, is to replace the &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; (args, format_string, addresses&amp;hellip;) function with a call to &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTupleAndKeywords&quot;&gt;&lt;code&gt;PyArg_ParseTupleAndKeywords&lt;/code&gt;&lt;/a&gt; (args, kwds, format_string, char *kwlist[], addresses&amp;hellip;). The kwlist parameter to this function is a &lt;code&gt;NULL&lt;/code&gt; -terminated array of strings providing the expected keyword arguments. There should be one string for each entry in the format_string. Using this function will raise a TypeError if invalid keyword arguments are passed in.</source>
          <target state="translated">kwds参数包含一个Python字典，该字典的键是关键字参数的名称，其值是相应的关键字参数值。可以对这本词典进行处理，但是您认为合适。但是，最简单的处理方法是用对&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTupleAndKeywords&quot;&gt; &lt;code&gt;PyArg_ParseTupleAndKeywords&lt;/code&gt; &lt;/a&gt;（args，kwds，format_string，char * kwlist []，地址&amp;hellip;）的调用来替换&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt;（args，format_string，addresss &amp;hellip;）函数。此函数的kwlist参数是一个以 &lt;code&gt;NULL&lt;/code&gt; 终止的字符串数组，提供了预期的关键字参数。 format_string中的每个条目应该有一个字符串。如果传入了无效的关键字参数，则使用此函数将引发TypeError。</target>
        </trans-unit>
        <trans-unit id="d80fbf99f1073ba593f4b530d71e8ae5f9ae88a1" translate="yes" xml:space="preserve">
          <source>The larger object to compare.</source>
          <target state="translated">较大的对象进行比较。</target>
        </trans-unit>
        <trans-unit id="3b1d6d882f09df5877abb8ef200d99a4552edbcc" translate="yes" xml:space="preserve">
          <source>The largest representable number.</source>
          <target state="translated">最大的可代表数。</target>
        </trans-unit>
        <trans-unit id="8c04ea0c745fb65e3a5c6b4d6a06693d11870a3e" translate="yes" xml:space="preserve">
          <source>The last dimension of the input array is converted into a structure, with number of field-elements equal to the size of the last dimension of the input array. By default all output fields have the input array&amp;rsquo;s dtype, but an output structured dtype with an equal number of fields-elements can be supplied instead.</source>
          <target state="translated">输入数组的最后一个维度将转换为结构，其中字段元素的数量等于输入数组的最后一个维度的大小。默认情况下，所有输出字段都具有输入数组的dtype，但是可以提供具有相等数量field-elements的输出结构化dtype。</target>
        </trans-unit>
        <trans-unit id="2abbd596290a88e6d12f22ea12675111b689f0a9" translate="yes" xml:space="preserve">
          <source>The last is an instance of freezing a core dimension and can be used to improve ufunc performance</source>
          <target state="translated">最后一个是冻结核心维度的例子,可以用来提高ufunc的性能。</target>
        </trans-unit>
        <trans-unit id="64a2253d0a7bf7afbe6eb3cddc1d5520d0b0c60a" translate="yes" xml:space="preserve">
          <source>The last one giving only the first elements because of the extra dimension. Compare &lt;code&gt;rowsum.nonzero()&lt;/code&gt; to understand this example.</source>
          <target state="translated">由于额外的维度，最后一个仅给出第一个元素。比较 &lt;code&gt;rowsum.nonzero()&lt;/code&gt; 以理解此示例。</target>
        </trans-unit>
        <trans-unit id="d08df5e86170609b57051ef10f9fb3e1c3868c9f" translate="yes" xml:space="preserve">
          <source>The last thing that must be done to finish the extension module is to actually write the code that performs the desired functions. There are two kinds of functions: those that don&amp;rsquo;t accept keyword arguments, and those that do.</source>
          <target state="translated">完成扩展模块必须做的最后一件事是实际编写执行所需功能的代码。有两种功能：不接受关键字参数的函数和可以接受关键字参数的函数。</target>
        </trans-unit>
        <trans-unit id="d5e8d86c6819b2227ff0ab7cafe1755645c6727d" translate="yes" xml:space="preserve">
          <source>The last two are characteristics of ndarrays - in order to support things like array slicing. The complications of subclassing ndarray are due to the mechanisms numpy has to support these latter two routes of instance creation.</source>
          <target state="translated">最后两个是ndarrays的特性--为了支持像数组切片这样的事情。子类化ndarray的复杂性是由于numpy有机制来支持后两种实例创建途径。</target>
        </trans-unit>
        <trans-unit id="2e8784c819189f431349d4282dd8265432f3285b" translate="yes" xml:space="preserve">
          <source>The latter group of &lt;code&gt;{NAME}s&lt;/code&gt; corresponds to letters used in the array interface typestring specification.</source>
          <target state="translated">后一组 &lt;code&gt;{NAME}s&lt;/code&gt; 与数组接口类型字符串规范中使用的字母相对应。</target>
        </trans-unit>
        <trans-unit id="376520c70f9d3809d519d1143cc58d7f446c8008" translate="yes" xml:space="preserve">
          <source>The leading organization of technical writers, &lt;a href=&quot;https://www.writethedocs.org/&quot;&gt;Write the Docs&lt;/a&gt;, holds conferences, hosts learning resources, and runs a Slack channel.</source>
          <target state="translated">技术作家的主要组织&lt;a href=&quot;https://www.writethedocs.org/&quot;&gt;Write Docs&lt;/a&gt;举行会议，主持学习资源并运行Slack频道。</target>
        </trans-unit>
        <trans-unit id="34445ad4113f33f26d89f86d8eb17d5993aa2b33" translate="yes" xml:space="preserve">
          <source>The leftmost and rightmost edges of the bins along each dimension (if not specified explicitly in the &lt;code&gt;bins&lt;/code&gt; parameters): &lt;code&gt;[[xmin, xmax], [ymin, ymax]]&lt;/code&gt;. All values outside of this range will be considered outliers and not tallied in the histogram.</source>
          <target state="translated">沿每个尺寸的仓的最左边缘和最右边缘（如果未在 &lt;code&gt;bins&lt;/code&gt; 参数中明确指定）： &lt;code&gt;[[xmin, xmax], [ymin, ymax]]&lt;/code&gt; 。所有超出此范围的值都将被视为离群值，并且不会在直方图中列出。</target>
        </trans-unit>
        <trans-unit id="7a57cb0c41d71bfde5dfe132d9a4c3e502a05b10" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;condlist&lt;/code&gt; must correspond to that of &lt;code&gt;funclist&lt;/code&gt;. If one extra function is given, i.e. if &lt;code&gt;len(funclist) == len(condlist) + 1&lt;/code&gt;, then that extra function is the default value, used wherever all conditions are false.</source>
          <target state="translated">的长度 &lt;code&gt;condlist&lt;/code&gt; 必须对应的 &lt;code&gt;funclist&lt;/code&gt; 。如果给出了一个附加函数，即 &lt;code&gt;len(funclist) == len(condlist) + 1&lt;/code&gt; ，则该附加函数是默认值，在所有条件均为false的情况下使用。</target>
        </trans-unit>
        <trans-unit id="fda9f4dafa3b1f4f0bc8667197c7c2f74ba12e70" translate="yes" xml:space="preserve">
          <source>The length of docstring lines should be kept to 75 characters to facilitate reading the docstrings in text terminals.</source>
          <target state="translated">docstring行的长度应控制在75个字符以内,以便于在文本终端阅读docstrings。</target>
        </trans-unit>
        <trans-unit id="081176014231d93ecc67e47d02d500051aeaedf5" translate="yes" xml:space="preserve">
          <source>The length of one element in bytes.</source>
          <target state="translated">一个元素的长度,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="74e1dfe5bb68b99490ab8db3a4549a897ab92285" translate="yes" xml:space="preserve">
          <source>The length of the list of integers. It is assumed safe to access &lt;em&gt;ptr&lt;/em&gt; [0] to &lt;em&gt;ptr&lt;/em&gt; [len-1].</source>
          <target state="translated">整数列表的长度。假定访问&lt;em&gt;ptr&lt;/em&gt; [0]至&lt;em&gt;ptr&lt;/em&gt; [len-1]是安全的。</target>
        </trans-unit>
        <trans-unit id="c7170d6904bad30d46bd752038c157844edf21e6" translate="yes" xml:space="preserve">
          <source>The length of the prefix and suffix strings are used to respectively align and wrap the output. An array is typically printed as:</source>
          <target state="translated">前缀和后缀字符串的长度分别用于对齐和包装输出。一个数组通常被打印成</target>
        </trans-unit>
        <trans-unit id="2a29e90467961f11261cb34c5ec7868485d4aa81" translate="yes" xml:space="preserve">
          <source>The length of the resulting strings</source>
          <target state="translated">所得字符串的长度</target>
        </trans-unit>
        <trans-unit id="bd80f84b161ca3d681912061b09ff3df6041ed39" translate="yes" xml:space="preserve">
          <source>The length of the returned string if &lt;code&gt;num&lt;/code&gt; is positive, or the length of the two&amp;rsquo;s complement if &lt;code&gt;num&lt;/code&gt; is negative, provided that &lt;code&gt;width&lt;/code&gt; is at least a sufficient number of bits for &lt;code&gt;num&lt;/code&gt; to be represented in the designated form.</source>
          <target state="translated">如果 &lt;code&gt;num&lt;/code&gt; 为正，则返回字符串的长度；如果 &lt;code&gt;num&lt;/code&gt; 为负，则返回二进制补码的长度，但前提是 &lt;code&gt;width&lt;/code&gt; 至少足以使 &lt;code&gt;num&lt;/code&gt; 以指定形式表示。</target>
        </trans-unit>
        <trans-unit id="f135e192b37267c7b20efc3238404265e3e1b9c0" translate="yes" xml:space="preserve">
          <source>The length of the scalar in bytes.</source>
          <target state="translated">标量的长度,单位为字节。</target>
        </trans-unit>
        <trans-unit id="63e0949a7b519952c49eb749b0448baf6c2dcdf9" translate="yes" xml:space="preserve">
          <source>The length of the segment in bytes.</source>
          <target state="translated">段的长度,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="b0af5a70b649c99b0be522e1c0ad6114744383d4" translate="yes" xml:space="preserve">
          <source>The length of the span is the range of a 64-bit integer times the length of the date or unit. For example, the time span for &amp;lsquo;W&amp;rsquo; (week) is exactly 7 times longer than the time span for &amp;lsquo;D&amp;rsquo; (day), and the time span for &amp;lsquo;D&amp;rsquo; (day) is exactly 24 times longer than the time span for &amp;lsquo;h&amp;rsquo; (hour).</source>
          <target state="translated">跨度的长度是64位整数乘以日期或单位长度的范围。例如，&amp;ldquo; W&amp;rdquo;（星期）的时间跨度比&amp;ldquo; D&amp;rdquo;（天）的时间跨度长7倍，而&amp;ldquo; D&amp;rdquo;（天）的时间跨度比时间跨度长24倍。为&amp;ldquo; h&amp;rdquo;（小时）。</target>
        </trans-unit>
        <trans-unit id="c92e142a9e3623399b64df009d94b4d034da17ea" translate="yes" xml:space="preserve">
          <source>The line above represents z**3 + 0*z**2 + 0*z + 0.</source>
          <target state="translated">上面的线代表z**3+0*z*2+0*z+0。</target>
        </trans-unit>
        <trans-unit id="b578e5e67f3e586204e4994bbe5c88c656a6cae7" translate="yes" xml:space="preserve">
          <source>The line above represents z**3 - z/4</source>
          <target state="translated">上面的线代表z**3-z/4。</target>
        </trans-unit>
        <trans-unit id="cb5275e91dcecc0c6dc816bc9710e92658bd3377" translate="yes" xml:space="preserve">
          <source>The linear map &lt;code&gt;offset + scale*x&lt;/code&gt; that maps the domain &lt;code&gt;old&lt;/code&gt; to the domain &lt;code&gt;new&lt;/code&gt; is applied to the points &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;old&lt;/code&gt; 域映射到 &lt;code&gt;new&lt;/code&gt; 域的线性映射 &lt;code&gt;offset + scale*x&lt;/code&gt; 应用于点 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2428c8d989723853883bd2c4d45c041f6e455adf" translate="yes" xml:space="preserve">
          <source>The list &lt;code&gt;x&lt;/code&gt; contains 4 items, each which can be accessed individually:</source>
          <target state="translated">列表 &lt;code&gt;x&lt;/code&gt; 包含4个项目，每个项目都可以单独访问：</target>
        </trans-unit>
        <trans-unit id="647499d1a98b89607edcd5f783a0adb1c730bbde" translate="yes" xml:space="preserve">
          <source>The list of arrays from which the output elements are taken. It has to be of the same length as &lt;code&gt;condlist&lt;/code&gt;.</source>
          <target state="translated">从中获取输出元素的数组列表。它的长度必须与 &lt;code&gt;condlist&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="529e159ac14f2e5a4bfd821c54e94a56730b5c46" translate="yes" xml:space="preserve">
          <source>The list of conditions which determine from which array in &lt;code&gt;choicelist&lt;/code&gt; the output elements are taken. When multiple conditions are satisfied, the first one encountered in &lt;code&gt;condlist&lt;/code&gt; is used.</source>
          <target state="translated">的其中确定从哪个数组中的条件列表 &lt;code&gt;choicelist&lt;/code&gt; 中所采取的输出元件。当满足多个条件时，将使用 &lt;code&gt;condlist&lt;/code&gt; 中遇到的第一个条件。</target>
        </trans-unit>
        <trans-unit id="a85b3c79db62cd35117edd96a90c46599648e8f3" translate="yes" xml:space="preserve">
          <source>The list of field names of a structured datatype can be found in the &lt;code&gt;names&lt;/code&gt; attribute of the dtype object:</source>
          <target state="translated">可以在dtype对象的 &lt;code&gt;names&lt;/code&gt; 属性中找到结构化数据类型的字段名称的列表：</target>
        </trans-unit>
        <trans-unit id="92c329f0ce8c711e6636f92601cc50d421b9b226" translate="yes" xml:space="preserve">
          <source>The list of slices, one for each continuous region of masked elements in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">切片的列表，一个用于在屏蔽元件中的每连续区域 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88a36ffbba49be32da3baf6bb43ea7e384cf3381" translate="yes" xml:space="preserve">
          <source>The list of slices, one for each continuous region of unmasked elements in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">切片的列表，一个用于在未掩蔽元件的每个连续区域 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7251af1a3271825930cf9fcd1d817e4c55bd823" translate="yes" xml:space="preserve">
          <source>The list of sources may contain functions (&amp;lsquo;source generators&amp;rsquo;) with a pattern &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return
&amp;lt;source(s) or None&amp;gt;&lt;/code&gt;. If &lt;code&gt;funcname&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, no sources are generated. And if the &lt;code&gt;Extension&lt;/code&gt; instance has no sources after processing all source generators, no extension module will be built. This is the recommended way to conditionally define extension modules. Source generator functions are called by the &lt;code&gt;build_src&lt;/code&gt; command of &lt;code&gt;numpy.distutils&lt;/code&gt;.</source>
          <target state="translated">源列表可能包含带有模式 &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return &amp;lt;source(s) or None&amp;gt;&lt;/code&gt; 函数（&amp;ldquo;源生成器&amp;rdquo; ）：return &amp;lt;source（s）或None&amp;gt;。如果 &lt;code&gt;funcname&lt;/code&gt; 返回 &lt;code&gt;None&lt;/code&gt; ，则不生成任何源。而且，如果 &lt;code&gt;Extension&lt;/code&gt; 实例在处理完所有源生成器之后没有源，则不会构建扩展模块。这是建议的有条件定义扩展模块的方法。源生成器函数由 &lt;code&gt;build_src&lt;/code&gt; 命令 &lt;code&gt;numpy.distutils&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70ba9a25afcb1723906c4b12dfd6f0a126515e6c" translate="yes" xml:space="preserve">
          <source>The list of sources may contain functions (&amp;lsquo;source generators&amp;rsquo;) with a pattern &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return
&amp;lt;source(s) or None&amp;gt;&lt;/code&gt;. If &lt;code&gt;funcname&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, no sources are generated. And if the &lt;code&gt;Extension&lt;/code&gt; instance has no sources after processing all source generators, no extension module will be built. This is the recommended way to conditionally define extension modules. Source generator functions are called by the &lt;code&gt;build_src&lt;/code&gt; sub-command of &lt;code&gt;numpy.distutils&lt;/code&gt;.</source>
          <target state="translated">源列表可能包含带有模式 &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return &amp;lt;source(s) or None&amp;gt;&lt;/code&gt; 函数（&amp;ldquo;源生成器&amp;rdquo; ）：return &amp;lt;source（s）或None&amp;gt;。如果 &lt;code&gt;funcname&lt;/code&gt; 返回 &lt;code&gt;None&lt;/code&gt; ，则不生成任何源。如果 &lt;code&gt;Extension&lt;/code&gt; 实例在处理完所有源生成器后没有源，则不会构建扩展模块。建议使用此方法有条件地定义扩展模块。源生成器函数由 &lt;code&gt;build_src&lt;/code&gt; 子命令 &lt;code&gt;numpy.distutils&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e86e6b1dfd4d026f3bb365ed0394b538f40e1c2c" translate="yes" xml:space="preserve">
          <source>The location of the mode of the distribution. Default is 0.</source>
          <target state="translated">分布模式的位置。默认为0。</target>
        </trans-unit>
        <trans-unit id="c828d9667ddc1c799350af57ae54e489e27f09a4" translate="yes" xml:space="preserve">
          <source>The log base 10 of the &lt;code&gt;x&lt;/code&gt; value(s). If &lt;code&gt;x&lt;/code&gt; was a scalar, so is &lt;code&gt;out&lt;/code&gt;, otherwise an array object is returned.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 值的对数以10为底。如果 &lt;code&gt;x&lt;/code&gt; 是一个标量，则 &lt;code&gt;out&lt;/code&gt; 是，否则返回一个数组对象。</target>
        </trans-unit>
        <trans-unit id="d10e6ebe0b7c221ce4f14d1d0c1caa877512f1e8" translate="yes" xml:space="preserve">
          <source>The log base 2 of the &lt;code&gt;x&lt;/code&gt; value(s). If &lt;code&gt;x&lt;/code&gt; was a scalar, so is &lt;code&gt;out&lt;/code&gt;, otherwise an array is returned.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 值的对数以2为底。如果 &lt;code&gt;x&lt;/code&gt; 是一个标量，则 &lt;code&gt;out&lt;/code&gt; 是，否则返回一个数组。</target>
        </trans-unit>
        <trans-unit id="87f861a99c70448b2c7eae628fc0d66e23cdacad" translate="yes" xml:space="preserve">
          <source>The log base &lt;code&gt;n&lt;/code&gt; of the &lt;code&gt;x&lt;/code&gt; value(s). If &lt;code&gt;x&lt;/code&gt; was a scalar, so is &lt;code&gt;out&lt;/code&gt;, otherwise an array is returned.</source>
          <target state="translated">日志基 &lt;code&gt;n&lt;/code&gt; 所述的 &lt;code&gt;x&lt;/code&gt; 值（S）。如果 &lt;code&gt;x&lt;/code&gt; 是一个标量，则 &lt;code&gt;out&lt;/code&gt; 是，否则返回一个数组。</target>
        </trans-unit>
        <trans-unit id="e0bd870e67f108672284e786e066e2248a62a253" translate="yes" xml:space="preserve">
          <source>The log of the &lt;code&gt;x&lt;/code&gt; value(s). If &lt;code&gt;x&lt;/code&gt; was a scalar, so is &lt;code&gt;out&lt;/code&gt;, otherwise an array is returned.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 值的对数。如果 &lt;code&gt;x&lt;/code&gt; 是一个标量，则 &lt;code&gt;out&lt;/code&gt; 是，否则返回一个数组。</target>
        </trans-unit>
        <trans-unit id="f922a603661ce7b289c8f2d5dd79d3f8d12f2d5b" translate="yes" xml:space="preserve">
          <source>The log series distribution is frequently used to represent species richness and occurrence, first proposed by Fisher, Corbet, and Williams in 1943 [2]. It may also be used to model the numbers of occupants seen in cars [3].</source>
          <target state="translated">对数序列分布常用来表示物种的丰富性和出现率,最早由Fisher、Corbet和Williams在1943年提出[2]。它也可用于模拟汽车中的乘员数量[3]。</target>
        </trans-unit>
        <trans-unit id="23451df0ca8ba5d5bfbdca9cf8c2255b108c68ac" translate="yes" xml:space="preserve">
          <source>The logarithm to the base 10 of &lt;code&gt;x&lt;/code&gt;, element-wise. NaNs are returned where x is negative. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">以元素为单位，以 &lt;code&gt;x&lt;/code&gt; 的 10为底的对数。如果x为负，则返回NaN。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="4d6739be6bf6c7545bc1a71d692001820b9d7cac" translate="yes" xml:space="preserve">
          <source>The logic behind those functions in more than two dimensions can be strange.</source>
          <target state="translated">这些功能背后的逻辑在超过二维的情况下会很奇怪。</target>
        </trans-unit>
        <trans-unit id="b8615daefc462d9e38519ed036e0e283940da95b" translate="yes" xml:space="preserve">
          <source>The lower and upper range of the bins. If not provided, range is simply &lt;code&gt;(a.min(), a.max())&lt;/code&gt;. Values outside the range are ignored. The first element of the range must be less than or equal to the second. &lt;code&gt;range&lt;/code&gt; affects the automatic bin computation as well. While bin width is computed to be optimal based on the actual data within &lt;code&gt;range&lt;/code&gt;, the bin count will fill the entire range including portions containing no data.</source>
          <target state="translated">垃圾箱的上下范围。如果未提供，则范围仅为 &lt;code&gt;(a.min(), a.max())&lt;/code&gt; 。超出范围的值将被忽略。范围的第一个元素必须小于或等于第二个。 &lt;code&gt;range&lt;/code&gt; 也会影响自动bin计算。虽然根据 &lt;code&gt;range&lt;/code&gt; 的实际数据计算出箱宽是最佳的，但箱数将填充整个范围，包括不包含数据的部分。</target>
        </trans-unit>
        <trans-unit id="6456e48a0250380ada9bfcdc5cd3014ca07e5eb0" translate="yes" xml:space="preserve">
          <source>The lower bound for the top 1% of the samples is :</source>
          <target state="translated">前1%的样本的下限是 。</target>
        </trans-unit>
        <trans-unit id="4e9276b72baca62196e481978e6fcfbd0f0274c3" translate="yes" xml:space="preserve">
          <source>The lower bound of the definite integral.</source>
          <target state="translated">定积分的下界。</target>
        </trans-unit>
        <trans-unit id="37caf12cbe44bfdef1d91bca2e93d01e775cf201" translate="yes" xml:space="preserve">
          <source>The lower bound of the integral. (Default: 0)</source>
          <target state="translated">积分的下界。(默认值:0)</target>
        </trans-unit>
        <trans-unit id="a76f1d77a96a5b462f5fae8acc24fa2aae62620a" translate="yes" xml:space="preserve">
          <source>The lowest common multiple</source>
          <target state="translated">最低公倍数</target>
        </trans-unit>
        <trans-unit id="87d6bfa25ac3b02d4e51aa1f4135cd735f016c13" translate="yes" xml:space="preserve">
          <source>The lowest common multiple of the absolute value of the inputs This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">输入绝对值的最小公倍数如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="5279b869b28ed9fc7a9edd7c369e695d6cb90bbb" translate="yes" xml:space="preserve">
          <source>The main difference between &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt;&lt;code&gt;Generator.shuffle&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt;&lt;code&gt;Generator.permutation&lt;/code&gt;&lt;/a&gt; is that &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt;&lt;code&gt;Generator.shuffle&lt;/code&gt;&lt;/a&gt; operates in-place, while &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt;&lt;code&gt;Generator.permutation&lt;/code&gt;&lt;/a&gt; returns a copy.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt; &lt;code&gt;Generator.shuffle&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt; &lt;code&gt;Generator.permutation&lt;/code&gt; &lt;/a&gt;之间的主要区别是&lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt; &lt;code&gt;Generator.shuffle&lt;/code&gt; &lt;/a&gt;就地操作，而&lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt; &lt;code&gt;Generator.permutation&lt;/code&gt; &lt;/a&gt;返回一个副本。</target>
        </trans-unit>
        <trans-unit id="6767713cd6108661a0803484e7289fe42459ebb5" translate="yes" xml:space="preserve">
          <source>The main feature of the &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module is the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; class, which is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;. The class, its attributes and methods are described in more details in the &lt;a href=&quot;maskedarray.baseclass#maskedarray-baseclass&quot;&gt;MaskedArray class&lt;/a&gt; section.</source>
          <target state="translated">&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt;模块的主要功能是&lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;类，它是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt;的子类。该类，其属性和方法在&lt;a href=&quot;maskedarray.baseclass#maskedarray-baseclass&quot;&gt;MaskedArray类&lt;/a&gt;部分中有更详细的描述。</target>
        </trans-unit>
        <trans-unit id="52a36a5301780b2d55c316deba861004a7e6a2e2" translate="yes" xml:space="preserve">
          <source>The main page for the &lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;NumPy Documentation&lt;/a&gt; lists several categories. The documents mentioned there live in different places.</source>
          <target state="translated">&lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;NumPy文档的&lt;/a&gt;主页列出了几个类别。那里提到的文件居住在不同的地方。</target>
        </trans-unit>
        <trans-unit id="48a467f7e54add76d93e3f038ba1d5a3c08c31d6" translate="yes" xml:space="preserve">
          <source>The main routine for obtaining an array from any Python object that can be converted to an array is &lt;a href=&quot;../reference/c-api/array#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt;. This function is very flexible with many input arguments. Several macros make it easier to use the basic function. &lt;a href=&quot;../reference/c-api/array#c.PyArray_FROM_OTF&quot;&gt;&lt;code&gt;PyArray_FROM_OTF&lt;/code&gt;&lt;/a&gt; is arguably the most useful of these macros for the most common uses. It allows you to convert an arbitrary Python object to an array of a specific builtin data-type ( &lt;em&gt;e.g.&lt;/em&gt; float), while specifying a particular set of requirements ( &lt;em&gt;e.g.&lt;/em&gt; contiguous, aligned, and writeable). The syntax is</source>
          <target state="translated">从任何可以转换为数组的Python对象获取数组的主要例程是&lt;a href=&quot;../reference/c-api/array#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;。此函数非常灵活，具有许多输入参数。几个宏使使用基本功能更加容易。&lt;a href=&quot;../reference/c-api/array#c.PyArray_FROM_OTF&quot;&gt; &lt;code&gt;PyArray_FROM_OTF&lt;/code&gt; &lt;/a&gt;可以说是最常用的这些宏中最有用的。它允许您在指定一组特定要求（&lt;em&gt;例如&lt;/em&gt;连续，对齐和可写）的同时，将任意Python对象转换为特定内置数据类型（&lt;em&gt;例如&lt;/em&gt;float）的数组。语法是&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9a6437cd8dced244085d75f5d4ec1f2af95ca5d9" translate="yes" xml:space="preserve">
          <source>The main way to control how the sequences of strings we have read from the file are converted to other types is to set the &lt;code&gt;dtype&lt;/code&gt; argument. Acceptable values for this argument are:</source>
          <target state="translated">控制从文件中读取的字符串序列如何转换为其他类型的主要方法是设置 &lt;code&gt;dtype&lt;/code&gt; 参数。此参数可接受的值为：</target>
        </trans-unit>
        <trans-unit id="b863f0a577a40cd3794882f4e85002ecea6308b0" translate="yes" xml:space="preserve">
          <source>The mantissas &lt;code&gt;x1&lt;/code&gt; and twos exponents &lt;code&gt;x2&lt;/code&gt; are used to construct floating point numbers &lt;code&gt;x1 * 2**x2&lt;/code&gt;.</source>
          <target state="translated">尾数 &lt;code&gt;x1&lt;/code&gt; 和二进制指数 &lt;code&gt;x2&lt;/code&gt; 用于构造浮点数 &lt;code&gt;x1 * 2**x2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1288609b08eeb3cc92c01ebf371043c8f0d81962" translate="yes" xml:space="preserve">
          <source>The map &lt;code&gt;L(x) = offset + scale*x&lt;/code&gt; maps the first domain to the second.</source>
          <target state="translated">映射 &lt;code&gt;L(x) = offset + scale*x&lt;/code&gt; 将第一个域映射到第二个域。</target>
        </trans-unit>
        <trans-unit id="fd5781bc4f89018e0fb9cd14ef3f3c125e3d74bb" translate="yes" xml:space="preserve">
          <source>The mapping function is defined by &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">映射功能由 &lt;code&gt;off + scl*x&lt;/code&gt; 定义。</target>
        </trans-unit>
        <trans-unit id="f0d7698b06a0aedcc32f911c787189d531c3eac9" translate="yes" xml:space="preserve">
          <source>The mask is lost if &lt;code&gt;out&lt;/code&gt; is not a valid &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; !</source>
          <target state="translated">如果 &lt;code&gt;out&lt;/code&gt; 不是有效的&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;，则掩码将丢失！</target>
        </trans-unit>
        <trans-unit id="813174aba4a83655c04e53a7f1ff5c50cdefaed0" translate="yes" xml:space="preserve">
          <source>The mask is lost if &lt;code&gt;out&lt;/code&gt; is not a valid &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;ma.MaskedArray&lt;/code&gt;&lt;/a&gt; !</source>
          <target state="translated">如果 &lt;code&gt;out&lt;/code&gt; 不是有效的&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;ma.MaskedArray&lt;/code&gt; &lt;/a&gt;，则掩码会丢失！</target>
        </trans-unit>
        <trans-unit id="649d4874d06fb274533beb59f5f2cd10f5dc2b95" translate="yes" xml:space="preserve">
          <source>The mask is lost if &lt;code&gt;out&lt;/code&gt; is not a valid MaskedArray !</source>
          <target state="translated">如果 &lt;code&gt;out&lt;/code&gt; 不是有效的MaskedArray ，则掩码将丢失！</target>
        </trans-unit>
        <trans-unit id="f9bf54dc7bd5e650858bf619f77da75fc06bf1f6" translate="yes" xml:space="preserve">
          <source>The mask of a masked array is accessible through its &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.mask&quot;&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/a&gt; attribute. We must keep in mind that a &lt;code&gt;True&lt;/code&gt; entry in the mask indicates an &lt;em&gt;invalid&lt;/em&gt; data.</source>
          <target state="translated">可通过其&lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.mask&quot;&gt; &lt;code&gt;mask&lt;/code&gt; &lt;/a&gt;属性访问被掩码数组的掩码。我们必须记住，掩码中的 &lt;code&gt;True&lt;/code&gt; 项表示&lt;em&gt;无效&lt;/em&gt;数据。</target>
        </trans-unit>
        <trans-unit id="5f7d748f7e23f2629a7257e1d7501357c2ce872d" translate="yes" xml:space="preserve">
          <source>The mask of a masked array view is also a view rather than a copy</source>
          <target state="translated">掩码数组视图的掩码也是一个视图,而不是一个副本。</target>
        </trans-unit>
        <trans-unit id="136b0641a8efd21e297d96cb868071b555117d7d" translate="yes" xml:space="preserve">
          <source>The masked arrays for which to compare fill values.</source>
          <target state="translated">屏蔽的数组,用于比较填充值。</target>
        </trans-unit>
        <trans-unit id="6a7c669e8d49f546a924fb9ea3a27606961c98f7" translate="yes" xml:space="preserve">
          <source>The matmul function implements the semantics of the &lt;code&gt;@&lt;/code&gt; operator introduced in Python 3.5 following PEP465.</source>
          <target state="translated">matmul函数实现PEP465之后在Python 3.5中引入的 &lt;code&gt;@&lt;/code&gt; 运算符的语义。</target>
        </trans-unit>
        <trans-unit id="b0018603311d83d5ccf5c07dff4523d1ca410b48" translate="yes" xml:space="preserve">
          <source>The matrix class is a Python subclass of the ndarray and can be used as a reference for how to construct your own subclass of the ndarray. Matrices can be created from other matrices, strings, and anything else that can be converted to an &lt;code&gt;ndarray&lt;/code&gt; . The name &amp;ldquo;mat &amp;ldquo;is an alias for &amp;ldquo;matrix &amp;ldquo;in NumPy.</source>
          <target state="translated">矩阵类是ndarray的Python子类，可以用作如何构造自己的ndarray子类的参考。可以从其他矩阵，字符串以及可以转换为 &lt;code&gt;ndarray&lt;/code&gt; 的任何其他对象创建矩阵。名称&amp;ldquo; mat&amp;rdquo;是NumPy中&amp;ldquo;矩阵&amp;rdquo;的别名。</target>
        </trans-unit>
        <trans-unit id="5f8d7cfa51bd7c57bbf7e03577a1825ff994845e" translate="yes" xml:space="preserve">
          <source>The matrix of random values with shape given by &lt;code&gt;*args&lt;/code&gt;.</source>
          <target state="translated">形状由 &lt;code&gt;*args&lt;/code&gt; 给定的随机值矩阵。</target>
        </trans-unit>
        <trans-unit id="608aa6eae8f7f68c13529cd8bd42452f015b4b90" translate="yes" xml:space="preserve">
          <source>The matrix product of the inputs. This is a scalar only when both x1, x2 are 1-d vectors.</source>
          <target state="translated">输入的矩阵积。只有当x1,x2都是1-d向量时,这是一个标量。</target>
        </trans-unit>
        <trans-unit id="c658bc86aaba588a6a002ba9982fdea6c89bc9cc" translate="yes" xml:space="preserve">
          <source>The matrix whose condition number is sought.</source>
          <target state="translated">寻找条件号的矩阵。</target>
        </trans-unit>
        <trans-unit id="c8c3ef8c7c85bd35de6e1deb7b50a36e856e51b4" translate="yes" xml:space="preserve">
          <source>The matrix, but as a (1, N) matrix if it had shape (N, 1).</source>
          <target state="translated">矩阵,但作为一个(1,N)矩阵,如果它的形状是(N,1)。</target>
        </trans-unit>
        <trans-unit id="d2f91514f11b147277135520b0867d5d6ef7f638" translate="yes" xml:space="preserve">
          <source>The maximum is equivalent to &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are nans, but it is faster and does proper broadcasting.</source>
          <target state="translated">当x1和x2都不是 &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; ，最大值等于np.where（x1&amp;gt; = x2，x1，x2），但它更快并且可以正确广播。</target>
        </trans-unit>
        <trans-unit id="b9ec29a01437d2db772a9e55518ff6e61467f369" translate="yes" xml:space="preserve">
          <source>The maximum number of array arguments that can be used in functions.</source>
          <target state="translated">函数中可使用的最大数组参数数量。</target>
        </trans-unit>
        <trans-unit id="d4b71803b063354491818e9ff7d7f91cb1c1ba7e" translate="yes" xml:space="preserve">
          <source>The maximum number of dimensions allowed in arrays.</source>
          <target state="translated">数组中允许的最大尺寸数。</target>
        </trans-unit>
        <trans-unit id="aff70196c900f17cb2833a4c90eb4869b491b830" translate="yes" xml:space="preserve">
          <source>The maximum number of rows to read. Must not be used with skip_footer at the same time. If given, the value must be at least 1. Default is to read the entire file.</source>
          <target state="translated">读取的最大行数。不能与 skip_footer 同时使用。如果给定,该值必须至少为1,默认为读取整个文件。</target>
        </trans-unit>
        <trans-unit id="bd4584d425d2919fbb0f9bcabce0ec35c9487dde" translate="yes" xml:space="preserve">
          <source>The maximum number of unit in the last place for tolerance (see Notes). Default is 1.</source>
          <target state="translated">允差最后一位的最大单位数(见注释)。默认为1。</target>
        </trans-unit>
        <trans-unit id="3cded325e7f85dbd01c8e732779ef69a0c4dfb37" translate="yes" xml:space="preserve">
          <source>The maximum number of units in the last place that elements of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; can differ. Default is 1.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的元素可以在最后位置不同的最大单位数。默认值为1。</target>
        </trans-unit>
        <trans-unit id="4d9efaa03fd6ffe081e389f0039d71a839a20c3f" translate="yes" xml:space="preserve">
          <source>The maximum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 的最大值（逐元素）。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="9686cc88755d232ce34c0c727b2433fe545075f6" translate="yes" xml:space="preserve">
          <source>The maximum representable value.</source>
          <target state="translated">最大可代表值。</target>
        </trans-unit>
        <trans-unit id="0b24f05221f4af03e40635809a9e83b6c24ab35f" translate="yes" xml:space="preserve">
          <source>The maximum value along a given axis.</source>
          <target state="translated">沿给定轴线的最大值。</target>
        </trans-unit>
        <trans-unit id="fda69f03e934be306357e5eceaea53c34ff9559a" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, ignores NaNs.</source>
          <target state="translated">沿给定轴线的数组最大值,忽略NaNs。</target>
        </trans-unit>
        <trans-unit id="7815283b9ba6a866678fcbb140334dc5a033015a" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, ignoring any NaNs.</source>
          <target state="translated">沿着给定轴线的阵列的最大值,忽略任何NaNs。</target>
        </trans-unit>
        <trans-unit id="d4de50ed13c4c863bfa3e8deacb7e5bde93f23df" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, propagates NaNs.</source>
          <target state="translated">沿给定轴线的数组最大值,传播NaNs。</target>
        </trans-unit>
        <trans-unit id="7ea2e2a635f47e2f3d7b25aa79029eb57056d0e6" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, propagating any NaNs.</source>
          <target state="translated">沿给定轴线的数组最大值,传播任何NaNs。</target>
        </trans-unit>
        <trans-unit id="1062669c35965744b7646a80587bb754273c0111" translate="yes" xml:space="preserve">
          <source>The maximum value of an output element. Must be present to allow computation on empty slice. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">输出元素的最大值。必须存在以允许在空片上进行计算。有关详细信息，请参见&lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4217fb4da5a1a61065cf374f0d2db5e29f625661" translate="yes" xml:space="preserve">
          <source>The mean is a coordinate in N-dimensional space, which represents the location where samples are most likely to be generated. This is analogous to the peak of the bell curve for the one-dimensional or univariate normal distribution.</source>
          <target state="translated">平均数是N维空间中的一个坐标,它代表了样本最有可能产生的位置。这类似于一维或单变量正态分布的钟形曲线的峰值。</target>
        </trans-unit>
        <trans-unit id="3afbef537c228c554c040f21270cfff32d76c2bc" translate="yes" xml:space="preserve">
          <source>The mean is normally calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of a hypothetical infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables.</source>
          <target state="translated">平均值通常按 &lt;code&gt;x.sum() / N&lt;/code&gt; 计算，其中 &lt;code&gt;N = len(x)&lt;/code&gt; 。然而，如果 &lt;code&gt;ddof&lt;/code&gt; 指定，除数 &lt;code&gt;N - ddof&lt;/code&gt; 代替。在标准的统计实践中， &lt;code&gt;ddof=1&lt;/code&gt; 提供了一个假设的无限总体方差的无偏估计量。 &lt;code&gt;ddof=0&lt;/code&gt; 为正态分布变量提供方差的最大似然估计。</target>
        </trans-unit>
        <trans-unit id="0055abb9b767358fbd1b30a2e475c3c5171aa230" translate="yes" xml:space="preserve">
          <source>The mean is typically calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of a hypothetical infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables.</source>
          <target state="translated">平均值通常计算为 &lt;code&gt;x.sum() / N&lt;/code&gt; ，其中 &lt;code&gt;N = len(x)&lt;/code&gt; 。然而，如果 &lt;code&gt;ddof&lt;/code&gt; 指定，除数 &lt;code&gt;N - ddof&lt;/code&gt; 代替。在标准的统计实践中， &lt;code&gt;ddof=1&lt;/code&gt; 提供了一个假设的无限总体方差的无偏估计量。 &lt;code&gt;ddof=0&lt;/code&gt; 为正态分布变量提供方差的最大似然估计。</target>
        </trans-unit>
        <trans-unit id="6de47f27b421a49095ff1b82a99c964834e4c682" translate="yes" xml:space="preserve">
          <source>The mechanism we use to accomplish this goal may be unfamiliar for those who are not experienced with the cultural norms around free/open-source software development. We provide a summary here, and highly recommend that all Contributors additionally read &lt;a href=&quot;http://producingoss.com/en/producingoss.html#social-infrastructure&quot;&gt;Chapter 4: Social and Political Infrastructure&lt;/a&gt; of Karl Fogel&amp;rsquo;s classic &lt;em&gt;Producing Open Source Software&lt;/em&gt;, and in particular the section on &lt;a href=&quot;http://producingoss.com/en/producingoss.html#consensus-democracy&quot;&gt;Consensus-based Democracy&lt;/a&gt;, for a more detailed discussion.</source>
          <target state="translated">对于那些不了解围绕自由/开源软件开发的文化规范的人来说，我们用于实现此目标的机制可能并不熟悉。我们在此处提供摘要，并强烈建议所有贡献者另外阅读Karl Fogel经典的&lt;em&gt;生产开源软件的&lt;/em&gt;&lt;a href=&quot;http://producingoss.com/en/producingoss.html#social-infrastructure&quot;&gt;第4章：社会和政治基础结构&lt;/a&gt;，尤其是关于&lt;a href=&quot;http://producingoss.com/en/producingoss.html#consensus-democracy&quot;&gt;基于共识的民主&lt;/a&gt;的部分，以进行更详细的讨论。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="530a7cbb36983f7e2dde0f52c1c905d90e12e910" translate="yes" xml:space="preserve">
          <source>The mediator will engage with all the parties and seek a resolution that is satisfactory to all. Upon completion, the mediator will provide a report (vetted by all parties to the process) to the Committee, with recommendations on further steps. The Committee will then evaluate these results (whether satisfactory resolution was achieved or not) and decide on any additional action deemed necessary.</source>
          <target state="translated">调解员将与所有各方接触,寻求各方都满意的解决办法。调解人在完成工作后,将向委员会提交一份报告(经该进程所有各方审查),并就进一步的步骤提出建议。然后,委员会将评价这些结果(无论是否达成满意的解决办法),并决定任何认为必要的额外行动。</target>
        </trans-unit>
        <trans-unit id="476855af021420263dd600a85590e6b055b087d3" translate="yes" xml:space="preserve">
          <source>The members are</source>
          <target state="translated">成员为</target>
        </trans-unit>
        <trans-unit id="f25c150719f0aed3ef8299c88981d255d24f240e" translate="yes" xml:space="preserve">
          <source>The members of this structure are</source>
          <target state="translated">这个结构的成员是</target>
        </trans-unit>
        <trans-unit id="a80fc0f190e501871954ac9917a55a8bb93998fb" translate="yes" xml:space="preserve">
          <source>The memmap object can be used anywhere an ndarray is accepted. Given a memmap &lt;code&gt;fp&lt;/code&gt;, &lt;code&gt;isinstance(fp, numpy.ndarray)&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">memmap对象可以在接受ndarray的任何地方使用。给定memmap &lt;code&gt;fp&lt;/code&gt; ， &lt;code&gt;isinstance(fp, numpy.ndarray)&lt;/code&gt; 返回 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="afefc9cb88d75583ea623e16ea1f8cf60770f93a" translate="yes" xml:space="preserve">
          <source>The memory layout of an advanced indexing result is optimized for each indexing operation and no particular memory order can be assumed.</source>
          <target state="translated">高级索引结果的内存布局是针对每个索引操作进行优化的,不能假设特定的内存顺序。</target>
        </trans-unit>
        <trans-unit id="76384eb2a7d5d22bbc5978606ad7f8f1173b53b8" translate="yes" xml:space="preserve">
          <source>The memory layout of structured datatypes allows fields at arbitrary byte offsets. This means the fields can be separated by padding bytes, their offsets can be non-monotonically increasing, and they can overlap.</source>
          <target state="translated">结构化数据类型的内存布局允许在任意字节偏移处设置字段,这意味着字段可以通过填充字节分开,它们的偏移量可以非单调增加,并且可以重叠。这意味着字段可以用填充字节分开,它们的偏移量可以非单调增加,并且可以重叠。</target>
        </trans-unit>
        <trans-unit id="5905e557d4f8798f2a63eb67ada3f5b47bd6cef3" translate="yes" xml:space="preserve">
          <source>The memory model for an ndarray admits arbitrary strides in each dimension to advance to the next element of the array. Often, however, you need to interface with code that expects a C-contiguous or a Fortran-contiguous memory layout. In addition, an ndarray can be misaligned (the address of an element is not at an integral multiple of the size of the element) which can cause your program to crash (or at least work more slowly) if you try and dereference a pointer into the array data. Both of these problems can be solved by converting the Python object into an array that is more &amp;ldquo;well-behaved&amp;rdquo; for your specific usage.</source>
          <target state="translated">ndarray的内存模型允许在每个维度上任意步长前进到数组的下一个元素。但是，通常，您需要与期望C连续或Fortran连续内存布局的代码进行交互。此外，ndarray可能未对齐（元素的地址不是该元素的大小的整数倍），如果您尝试取消对指针的引用，可能会导致程序崩溃（或至少运行得更慢）。数组数据。这两个问题都可以通过将Python对象转换为对您的特定用法更&amp;ldquo;规范&amp;rdquo;的数组来解决。</target>
        </trans-unit>
        <trans-unit id="92b75295665b751d736ee479f2ab0aea99cdf067" translate="yes" xml:space="preserve">
          <source>The memory-mapped array.</source>
          <target state="translated">内存映射阵列。</target>
        </trans-unit>
        <trans-unit id="aca17bd9cdf5246e194be60887f21d5d2d2f6e20" translate="yes" xml:space="preserve">
          <source>The merged result.</source>
          <target state="translated">合并的结果。</target>
        </trans-unit>
        <trans-unit id="26a8810bfd14aaec21beb6c6ecd19faf3719cc1e" translate="yes" xml:space="preserve">
          <source>The metadata field can be set using any dictionary at data-type creation. NumPy currently has no uniform approach to propagating metadata; although some array operations preserve it, there is no guarantee that others will.</source>
          <target state="translated">元数据字段可以在创建数据类型时使用任何字典进行设置。NumPy目前没有统一的元数据传播方法,虽然有些数组操作会保存元数据,但不能保证其他操作会保存元数据。</target>
        </trans-unit>
        <trans-unit id="b0b87bb043302905b55e9cdd6e1fad28731aa89a" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;generated/numpy.random.generator.permuted#numpy.random.Generator.permuted&quot;&gt;&lt;code&gt;Generator.permuted&lt;/code&gt;&lt;/a&gt; treats the &lt;code&gt;axis&lt;/code&gt; parameter similar to how &lt;a href=&quot;../generated/numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;numpy.sort&lt;/code&gt;&lt;/a&gt; treats it. Each slice along the given axis is shuffled independently of the others. Compare the following example of the use of &lt;a href=&quot;generated/numpy.random.generator.permuted#numpy.random.Generator.permuted&quot;&gt;&lt;code&gt;Generator.permuted&lt;/code&gt;&lt;/a&gt; to the above example of &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt;&lt;code&gt;Generator.permutation&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.random.generator.permuted#numpy.random.Generator.permuted&quot;&gt; &lt;code&gt;Generator.permuted&lt;/code&gt; &lt;/a&gt;方法对待 &lt;code&gt;axis&lt;/code&gt; 参数的方式类似于&lt;a href=&quot;../generated/numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;numpy.sort&lt;/code&gt; &lt;/a&gt;对待轴参数的方式。沿给定轴的每个切片将独立于其他切片进行随机播放。将下面的&lt;a href=&quot;generated/numpy.random.generator.permuted#numpy.random.Generator.permuted&quot;&gt; &lt;code&gt;Generator.permuted&lt;/code&gt; &lt;/a&gt;使用示例与上面的&lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt; &lt;code&gt;Generator.permutation&lt;/code&gt; &lt;/a&gt;示例进行比较：</target>
        </trans-unit>
        <trans-unit id="7df7fe557cb7d0b2f7c1ec9ba89a3700046e049a" translate="yes" xml:space="preserve">
          <source>The method should return either the result of the operation, or &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; if the operation requested is not implemented.</source>
          <target state="translated">该方法应该返回操作的结果，如果未实现所请求的操作，则返回&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4edd76a8cc0cb5a2a3b89a3543cae8f78bd75ba" translate="yes" xml:space="preserve">
          <source>The method uses the following property for computation: let</source>
          <target state="translated">该方法使用以下属性进行计算:让</target>
        </trans-unit>
        <trans-unit id="8c60b9f793967b9c55fe7d2d399c3c3c894ad07d" translate="yes" xml:space="preserve">
          <source>The methods for randomly permuting a sequence are</source>
          <target state="translated">随机换序的方法是</target>
        </trans-unit>
        <trans-unit id="ad0d254fa1824d11c17af544fbf486dd80c358ac" translate="yes" xml:space="preserve">
          <source>The methods to estimate the optimal number of bins are well founded in literature, and are inspired by the choices R provides for histogram visualisation. Note that having the number of bins proportional to</source>
          <target state="translated">估算最佳进制数的方法在文献中很有依据,并且受到R为直方图可视化提供的选择的启发。需要注意的是,让分仓的数量与以下几点成正比</target>
        </trans-unit>
        <trans-unit id="3d7963e1ce4d80720f0895da566be576ac9149e1" translate="yes" xml:space="preserve">
          <source>The minimal data type.</source>
          <target state="translated">最小数据类型。</target>
        </trans-unit>
        <trans-unit id="24db4b82ce9f82692c92a9ac46d90c6b64d6bb97" translate="yes" xml:space="preserve">
          <source>The minimum is equivalent to &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">当x1和x2都不是NaN时，最小值等于 &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; ，但是它更快并且可以正确广播。</target>
        </trans-unit>
        <trans-unit id="830a82f2ffde76e612c1dc506f1272bc14c9b4a2" translate="yes" xml:space="preserve">
          <source>The minimum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 的最小值（逐元素）。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="f7a8e12ffb3a7b028e99ec9cbaae32de38a438d0" translate="yes" xml:space="preserve">
          <source>The minimum representable value.</source>
          <target state="translated">最低可代表值。</target>
        </trans-unit>
        <trans-unit id="78d2dd7cf3cdcedef397cc8cfe35854b295317af" translate="yes" xml:space="preserve">
          <source>The minimum value along a given axis.</source>
          <target state="translated">沿给定轴线的最小值。</target>
        </trans-unit>
        <trans-unit id="7e0b0cb52a1bf19ef3e6bff0be136a12d77ae7e7" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, ignores NaNs.</source>
          <target state="translated">沿给定轴线的数组的最小值,忽略NaNs。</target>
        </trans-unit>
        <trans-unit id="d9e2b0a11e46ec4c3892cf8fdab488270aa4c95b" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, ignoring any NaNs.</source>
          <target state="translated">沿着给定轴线的阵列的最小值,忽略任何NaNs。</target>
        </trans-unit>
        <trans-unit id="77d53ae61484ff6af896adddf96d0d76b8331b4b" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, propagates NaNs.</source>
          <target state="translated">沿给定轴线的数组的最小值,传播NaNs。</target>
        </trans-unit>
        <trans-unit id="f3f970ad0b31d892cafa6b5a21e637a9f0353aee" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, propagating any NaNs.</source>
          <target state="translated">沿给定轴线的数组的最小值,传播任何NaNs。</target>
        </trans-unit>
        <trans-unit id="9ae224843f4578886c03cad9e1377c9c95d0f44e" translate="yes" xml:space="preserve">
          <source>The minimum value of an output element. Must be present to allow computation on empty slice. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">输出元素的最小值。必须存在以允许在空片上进行计算。有关详细信息，请参见&lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3270f0c455d0c0204b07f58b497a95a1d399a02b" translate="yes" xml:space="preserve">
          <source>The mode in which to open the file; the default is &amp;lsquo;r+&amp;rsquo;. In addition to the standard file modes, &amp;lsquo;c&amp;rsquo; is also accepted to mean &amp;ldquo;copy on write.&amp;rdquo; See &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt;&lt;code&gt;memmap&lt;/code&gt;&lt;/a&gt; for the available mode strings.</source>
          <target state="translated">打开文件的方式；默认值为&amp;ldquo; r +&amp;rdquo;。除标准文件模式外，&amp;ldquo; c&amp;rdquo;也被接受表示&amp;ldquo;写时复制&amp;rdquo;。有关可用的模式字符串，请参见&lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt; &lt;code&gt;memmap&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d437e19520a89179e90a54d1512529a938dad3c6" translate="yes" xml:space="preserve">
          <source>The mode should be one of:</source>
          <target state="translated">模式应该是其中之一。</target>
        </trans-unit>
        <trans-unit id="2ec84546189af066d8b391b45bfecb14d0737c14" translate="yes" xml:space="preserve">
          <source>The modified Bessel function evaluated at each of the elements of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">修改后的Bessel函数在 &lt;code&gt;x&lt;/code&gt; 的每个元素处求值。</target>
        </trans-unit>
        <trans-unit id="852847496df2ea03e82e7e539f1768f78993a6b8" translate="yes" xml:space="preserve">
          <source>The more common 2-parameter Weibull, including a scale parameter</source>
          <target state="translated">比较常见的2参数魏布尔,包括一个比例参数。</target>
        </trans-unit>
        <trans-unit id="ec8c35dc12f2bc0af45e628c14f8329c8c69aba9" translate="yes" xml:space="preserve">
          <source>The most basic task that can be done with the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; is to visit every element of an array. Each element is provided one by one using the standard Python iterator interface.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;可以完成的最基本任务是访问数组的每个元素。使用标准的Python迭代器接口逐一提供每个元素。</target>
        </trans-unit>
        <trans-unit id="d496ee7436ae1753a08460be49874cd0a97104de" translate="yes" xml:space="preserve">
          <source>The most basic way to create datetimes is from strings in ISO 8601 date or datetime format. The unit for internal storage is automatically selected from the form of the string, and can be either a &lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;date unit&lt;/a&gt; or a &lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;time unit&lt;/a&gt;. The date units are years (&amp;lsquo;Y&amp;rsquo;), months (&amp;lsquo;M&amp;rsquo;), weeks (&amp;lsquo;W&amp;rsquo;), and days (&amp;lsquo;D&amp;rsquo;), while the time units are hours (&amp;lsquo;h&amp;rsquo;), minutes (&amp;lsquo;m&amp;rsquo;), seconds (&amp;lsquo;s&amp;rsquo;), milliseconds (&amp;lsquo;ms&amp;rsquo;), and some additional SI-prefix seconds-based units.</source>
          <target state="translated">创建日期时间的最基本方法是使用ISO 8601日期或日期时间格式的字符串。内部存储单位是从字符串形式中自动选择的，可以是&lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;日期单位&lt;/a&gt;或&lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;时间单位&lt;/a&gt;。日期单位是年（'Y'），月（'M'），周（'W'）和天（'D'），而时间单位是小时（'h'），分钟（'m' ），秒（&amp;ldquo; s&amp;rdquo;），毫秒（&amp;ldquo; ms&amp;rdquo;）和一些其他基于SI前缀秒的单位。</target>
        </trans-unit>
        <trans-unit id="3f0f24060330e42125d74f607b6b6b61511b55b5" translate="yes" xml:space="preserve">
          <source>The most basic way to create datetimes is from strings in ISO 8601 date or datetime format. The unit for internal storage is automatically selected from the form of the string, and can be either a &lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;date unit&lt;/a&gt; or a &lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;time unit&lt;/a&gt;. The date units are years (&amp;lsquo;Y&amp;rsquo;), months (&amp;lsquo;M&amp;rsquo;), weeks (&amp;lsquo;W&amp;rsquo;), and days (&amp;lsquo;D&amp;rsquo;), while the time units are hours (&amp;lsquo;h&amp;rsquo;), minutes (&amp;lsquo;m&amp;rsquo;), seconds (&amp;lsquo;s&amp;rsquo;), milliseconds (&amp;lsquo;ms&amp;rsquo;), and some additional SI-prefix seconds-based units. The datetime64 data type also accepts the string &amp;ldquo;NAT&amp;rdquo;, in any combination of lowercase/uppercase letters, for a &amp;ldquo;Not A Time&amp;rdquo; value.</source>
          <target state="translated">创建日期时间的最基本方法是使用ISO 8601日期或日期时间格式的字符串。内部存储单位是从字符串形式中自动选择的，可以是&lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;日期单位&lt;/a&gt;或&lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;时间单位&lt;/a&gt;。日期单位是年（'Y'），月（'M'），周（'W'）和天（'D'），而时间单位是小时（'h'），分钟（'m' ），秒（&amp;ldquo; s&amp;rdquo;），毫秒（&amp;ldquo; ms&amp;rdquo;）和一些其他基于SI前缀秒的单位。datetime64数据类型还接受字符串&amp;ldquo; NAT&amp;rdquo;（大小写字母的任意组合）作为&amp;ldquo; Not A Time&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="66cbaf133a9d7fa2f2885d6f3bc9c4d230706591" translate="yes" xml:space="preserve">
          <source>The most common use of this function is to build a block matrix</source>
          <target state="translated">这个函数最常见的用途是建立一个块状矩阵。</target>
        </trans-unit>
        <trans-unit id="d15c9fb7581762b1e666994a9299d27d87d30396" translate="yes" xml:space="preserve">
          <source>The most natural way one can think of for boolean indexing is to use boolean arrays that have &lt;em&gt;the same shape&lt;/em&gt; as the original array:</source>
          <target state="translated">对于布尔索引，可以想到的最自然的方法是使用&lt;em&gt;形状&lt;/em&gt;与原始数组&lt;em&gt;相同的&lt;/em&gt;布尔数组：</target>
        </trans-unit>
        <trans-unit id="9781573736aca31c85fa33ce77a1caad972dd370" translate="yes" xml:space="preserve">
          <source>The most negative power of the base (2) consistent with there being no leading 0&amp;rsquo;s in the mantissa.</source>
          <target state="translated">基数（2）的最大负幂与尾数中没有前导0一致。</target>
        </trans-unit>
        <trans-unit id="fb15b7417ee56d15205cea48f990a823be057c87" translate="yes" xml:space="preserve">
          <source>The multidimensional histogram of sample x. See normed and weights for the different possible semantics.</source>
          <target state="translated">样本x的多维直方图,不同的可能语义见规范和权重。</target>
        </trans-unit>
        <trans-unit id="8be5b73af053c4fe54ab6b95a4f36c70767b3576" translate="yes" xml:space="preserve">
          <source>The multinomial distribution is a multivariate generalization of the binomial distribution. Take an experiment with one of &lt;code&gt;p&lt;/code&gt; possible outcomes. An example of such an experiment is throwing a dice, where the outcome can be 1 through 6. Each sample drawn from the distribution represents &lt;code&gt;n&lt;/code&gt; such experiments. Its values, &lt;code&gt;X_i = [X_0, X_1, ..., X_p]&lt;/code&gt;, represent the number of times the outcome was &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">多项式分布是二项式分布的多元概括。进行可能的 &lt;code&gt;p&lt;/code&gt; 个结果之一的实验。这样的实验的一个例子是掷骰子，结果可以是1到6。从分布中抽取的每个样本代表 &lt;code&gt;n&lt;/code&gt; 个这样的实验。其值 &lt;code&gt;X_i = [X_0, X_1, ..., X_p]&lt;/code&gt; 表示结果为 &lt;code&gt;i&lt;/code&gt; 的次数。</target>
        </trans-unit>
        <trans-unit id="6e35df9de409e360898297beb49d42cda54d84d4" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Hermite polynomials in the form</source>
          <target state="translated">乘法使用赫米特多项式的递推关系,形式为</target>
        </trans-unit>
        <trans-unit id="5d48b11de72371fe59540d3a1093cd7c7ef9026d" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Laguerre polynomials in the form</source>
          <target state="translated">乘法使用拉格尔多项式的递推关系,其形式为</target>
        </trans-unit>
        <trans-unit id="1da9d21187f4507f9a0b400fa81210b7d7adb8cd" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Legendre polynomials in the form</source>
          <target state="translated">乘法使用Legendre多项式的递推关系,形式为</target>
        </trans-unit>
        <trans-unit id="28fc83b7bf97d866e44dde49fafcb06224f49002" translate="yes" xml:space="preserve">
          <source>The multithreaded random number generator can be used to fill an array. The &lt;code&gt;values&lt;/code&gt; attributes shows the zero-value before the fill and the random value after.</source>
          <target state="translated">多线程随机数生成器可用于填充数组。的 &lt;code&gt;values&lt;/code&gt; 的属性示出的填充和之后的随机值之前在零值。</target>
        </trans-unit>
        <trans-unit id="b9bbb85b9ae78b76721288cfcfe9a4008f15e026" translate="yes" xml:space="preserve">
          <source>The multivariate hypergeometric distribution is a generalization of the hypergeometric distribution.</source>
          <target state="translated">多变量超几何分布是超几何分布的泛化。</target>
        </trans-unit>
        <trans-unit id="4747005456762b666a88180df9655da6422f2a03" translate="yes" xml:space="preserve">
          <source>The multivariate normal, multinormal or Gaussian distribution is a generalization of the one-dimensional normal distribution to higher dimensions. Such a distribution is specified by its mean and covariance matrix. These parameters are analogous to the mean (average or &amp;ldquo;center&amp;rdquo;) and variance (standard deviation, or &amp;ldquo;width,&amp;rdquo; squared) of the one-dimensional normal distribution.</source>
          <target state="translated">多元正态分布，多元正态分布或高斯分布是将一维正态分布推广到更高维度的方法。这种分布由其均值和协方差矩阵指定。这些参数类似于一维正态分布的均值（平均值或&amp;ldquo;中心&amp;rdquo;）和方差（标准偏差或&amp;ldquo;宽度&amp;rdquo;的平方）。</target>
        </trans-unit>
        <trans-unit id="a8b77cd2da64c5a2ad3fe22e334603fd46922d44" translate="yes" xml:space="preserve">
          <source>The mymethods must be an array (usually statically declared) of PyMethodDef structures which contain method names, actual C-functions, a variable indicating whether the method uses keyword arguments or not, and docstrings. These are explained in the next section. If you want to add constants to the module, then you store the returned value from Py_InitModule which is a module object. The most general way to add items to the module is to get the module dictionary using PyModule_GetDict(module). With the module dictionary, you can add whatever you like to the module manually. An easier way to add objects to the module is to use one of three additional Python C-API calls that do not require a separate extraction of the module dictionary. These are documented in the Python documentation, but repeated here for convenience:</source>
          <target state="translated">mymethods 必须是一个 PyMethodDef 结构的数组 (通常是静态声明的),其中包含方法名、实际的 C 函数、一个表示方法是否使用关键字参数的变量以及 docstrings。这些将在下一节解释。如果你想在模块中添加常量,那么你就存储Py_InitModule的返回值,它是一个模块对象。在模块中添加项目的最一般方法是使用 PyModule_GetDict(module)来获取模块字典。有了模块字典,你可以手动添加任何你喜欢的东西到模块中。向模块添加对象的更简单的方法是使用三个额外的 Python C-API 调用之一,它们不需要单独提取模块字典。这些调用在 Python 文档中都有记载,但为了方便起见,在这里重复一下。</target>
        </trans-unit>
        <trans-unit id="acd94e258d3a5164d9494ffb8bffe2f44669511c" translate="yes" xml:space="preserve">
          <source>The n-dimensional FFT.</source>
          <target state="translated">n维FFT。</target>
        </trans-unit>
        <trans-unit id="6c60f6d35e1563484077efd2da3ec7438c9b55d8" translate="yes" xml:space="preserve">
          <source>The n-dimensional array</source>
          <target state="translated">n维数组</target>
        </trans-unit>
        <trans-unit id="3b220f6b818351a33b819aef741ffc069011f1f9" translate="yes" xml:space="preserve">
          <source>The n-dimensional inverse FFT.</source>
          <target state="translated">n维逆向FFT。</target>
        </trans-unit>
        <trans-unit id="1aa43b3f9d99cab445704b967fccc316e94d1d57" translate="yes" xml:space="preserve">
          <source>The n-th differences. The shape of the output is the same as &lt;code&gt;a&lt;/code&gt; except along &lt;code&gt;axis&lt;/code&gt; where the dimension is smaller by &lt;code&gt;n&lt;/code&gt;. The type of the output is the same as the type of the difference between any two elements of &lt;code&gt;a&lt;/code&gt;. This is the same as the type of &lt;code&gt;a&lt;/code&gt; in most cases. A notable exception is &lt;a href=&quot;../arrays.scalars#numpy.datetime64&quot;&gt;&lt;code&gt;datetime64&lt;/code&gt;&lt;/a&gt;, which results in a &lt;a href=&quot;../arrays.scalars#numpy.timedelta64&quot;&gt;&lt;code&gt;timedelta64&lt;/code&gt;&lt;/a&gt; output array.</source>
          <target state="translated">第n个差异。输出的形状是相同的 &lt;code&gt;a&lt;/code&gt; 除了沿 &lt;code&gt;axis&lt;/code&gt; ，其中所述尺寸是由较小 &lt;code&gt;n&lt;/code&gt; 。类型的输出的相同的任意两个元素之间的差值的类型 &lt;code&gt;a&lt;/code&gt; 。在大多数情况下，这与 &lt;code&gt;a&lt;/code&gt; 的类型相同。一个明显的例外是&lt;a href=&quot;../arrays.scalars#numpy.datetime64&quot;&gt; &lt;code&gt;datetime64&lt;/code&gt; &lt;/a&gt;，它导致一个&lt;a href=&quot;../arrays.scalars#numpy.timedelta64&quot;&gt; &lt;code&gt;timedelta64&lt;/code&gt; &lt;/a&gt;输出数组。</target>
        </trans-unit>
        <trans-unit id="e1700cb4660502cb99b1ba6b83abc787863343a8" translate="yes" xml:space="preserve">
          <source>The n-th differences. The shape of the output is the same as &lt;code&gt;a&lt;/code&gt; except along &lt;code&gt;axis&lt;/code&gt; where the dimension is smaller by &lt;code&gt;n&lt;/code&gt;. The type of the output is the same as the type of the difference between any two elements of &lt;code&gt;a&lt;/code&gt;. This is the same as the type of &lt;code&gt;a&lt;/code&gt; in most cases. A notable exception is &lt;code&gt;datetime64&lt;/code&gt;, which results in a &lt;code&gt;timedelta64&lt;/code&gt; output array.</source>
          <target state="translated">第n个差异。输出的形状是相同的 &lt;code&gt;a&lt;/code&gt; 除了沿 &lt;code&gt;axis&lt;/code&gt; ，其中所述尺寸是由较小 &lt;code&gt;n&lt;/code&gt; 。类型的输出的相同的任意两个元素之间的差值的类型 &lt;code&gt;a&lt;/code&gt; 。在大多数情况下，这与 &lt;code&gt;a&lt;/code&gt; 的类型相同。一个明显的例外是 &lt;code&gt;datetime64&lt;/code&gt; ，它导致一个 &lt;code&gt;timedelta64&lt;/code&gt; 输出数组。</target>
        </trans-unit>
        <trans-unit id="bbebdf33e8d96895ad0ed5b9400d54086fef2b67" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;colors&lt;/code&gt; comes from a common description of the distribution: it is the probability distribution of the number of marbles of each color selected without replacement from an urn containing marbles of different colors; &lt;code&gt;colors[i]&lt;/code&gt; is the number of marbles in the urn with color &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;colors&lt;/code&gt; 这个名字来自对分布的一般描述：它是每种颜色的大理石数量的概率分布，这些颜色是从装有不同颜色大理石的中替换而未替换的； &lt;code&gt;colors[i]&lt;/code&gt; 是颜色为 &lt;code&gt;i&lt;/code&gt; 的骨灰盒中大理石的数量。</target>
        </trans-unit>
        <trans-unit id="0669ec99aeb2d5368091f67cb13b60ba81e67528" translate="yes" xml:space="preserve">
          <source>The name of an encoding</source>
          <target state="translated">编码的名称</target>
        </trans-unit>
        <trans-unit id="da19f645db8ba8aaf5c7216ec7214ec27975bb88" translate="yes" xml:space="preserve">
          <source>The name of each column, e.g. &lt;code&gt;('x', 'y', 'z')&lt;/code&gt;.</source>
          <target state="translated">每列的名称，例如 &lt;code&gt;('x', 'y', 'z')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2c5edd467b851569da4a2dda38a270ee36e54ad" translate="yes" xml:space="preserve">
          <source>The name of the compiled python module</source>
          <target state="translated">编译后的python模块名称</target>
        </trans-unit>
        <trans-unit id="cdc28be1ffb28a0940808960df363c803c7e10be" translate="yes" xml:space="preserve">
          <source>The name of the file on disk. This may &lt;em&gt;not&lt;/em&gt; be a file-like object.</source>
          <target state="translated">磁盘上文件的名称。这可能&lt;em&gt;不是&lt;/em&gt;类似文件的对象。</target>
        </trans-unit>
        <trans-unit id="a9271935a282dc40ee28d57c245df327643e67b9" translate="yes" xml:space="preserve">
          <source>The name of the function comes from the acronym for &amp;lsquo;peak to peak&amp;rsquo;.</source>
          <target state="translated">函数的名称来自&amp;ldquo; peak to peak&amp;rdquo;的缩写。</target>
        </trans-unit>
        <trans-unit id="d407bb92d1b152453450af784d89f7deb9d12336" translate="yes" xml:space="preserve">
          <source>The name of the function to be deprecated. Default is None, in which case the name of &lt;code&gt;func&lt;/code&gt; is used.</source>
          <target state="translated">要弃用的函数的名称。默认值为无，在这种情况下，将使用 &lt;code&gt;func&lt;/code&gt; 的名称。</target>
        </trans-unit>
        <trans-unit id="557578e757afec167650b8145d79c9de1775e751" translate="yes" xml:space="preserve">
          <source>The name of the module to test.</source>
          <target state="translated">要测试的模块名称。</target>
        </trans-unit>
        <trans-unit id="bb2cb1a8dd236bcfb532f7c48c470cce2101b1ff" translate="yes" xml:space="preserve">
          <source>The name of the polynomial variable</source>
          <target state="translated">多项式变量的名称</target>
        </trans-unit>
        <trans-unit id="48bd936a95b9da34fbbddac207b9c61cefe6e361" translate="yes" xml:space="preserve">
          <source>The name of the ufunc.</source>
          <target state="translated">ufunc的名字。</target>
        </trans-unit>
        <trans-unit id="8afcf394e9ae5bb9fa899425c9a8ba31df0dd746" translate="yes" xml:space="preserve">
          <source>The name sinc is short for &amp;ldquo;sine cardinal&amp;rdquo; or &amp;ldquo;sinus cardinalis&amp;rdquo;.</source>
          <target state="translated">sinc名称是&amp;ldquo;正弦基数&amp;rdquo;或&amp;ldquo;窦基数&amp;rdquo;的缩写。</target>
        </trans-unit>
        <trans-unit id="429822cfcff1010e8a45d7946ea2696aeb70a3d1" translate="yes" xml:space="preserve">
          <source>The names are ordered according to increasing byte offset. This can be used, for example, to walk through all of the named fields in offset order.</source>
          <target state="translated">名称按照递增的字节偏移量排序。例如,这可以用来按偏移量顺序浏览所有命名的字段。</target>
        </trans-unit>
        <trans-unit id="a9858df5c4f15a9862586b51516cf4a9f5358fd8" translate="yes" xml:space="preserve">
          <source>The names for the types in c code follows c naming conventions more closely. The Python names for these types follow Python conventions. Thus, &lt;a href=&quot;#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; picks up a 32-bit float in C, but &lt;a href=&quot;../arrays.scalars#numpy.float_&quot;&gt;&lt;code&gt;numpy.float_&lt;/code&gt;&lt;/a&gt; in Python corresponds to a 64-bit double. The bit-width names can be used in both Python and C for clarity.</source>
          <target state="translated">c代码中类型的名称更紧密地遵循c命名约定。这些类型的Python名称遵循Python约定。因此，&lt;a href=&quot;#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; &lt;/a&gt;在C语言中使用32位浮点数，但是Python中的&lt;a href=&quot;../arrays.scalars#numpy.float_&quot;&gt; &lt;code&gt;numpy.float_&lt;/code&gt; &lt;/a&gt;对应于64位double。为了清楚起见，可以在Python和C中使用位宽名称。</target>
        </trans-unit>
        <trans-unit id="d89404c184de8cb612b9ba60ba8159aea12d80ca" translate="yes" xml:space="preserve">
          <source>The names for the types in c code follows c naming conventions more closely. The Python names for these types follow Python conventions. Thus, &lt;a href=&quot;#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; picks up a 32-bit float in C, but &lt;code&gt;numpy.float_&lt;/code&gt; in Python corresponds to a 64-bit double. The bit-width names can be used in both Python and C for clarity.</source>
          <target state="translated">c代码中类型的名称更紧密地遵循c命名约定。这些类型的Python名称遵循Python约定。因此，&lt;a href=&quot;#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; &lt;/a&gt;在C语言中使用32位浮点数，但是Python中的 &lt;code&gt;numpy.float_&lt;/code&gt; 对应于64位double。为了清楚起见，可以在Python和C中使用位宽名称。</target>
        </trans-unit>
        <trans-unit id="7042a6f0e554df217f55061c01efbcd355c420f8" translate="yes" xml:space="preserve">
          <source>The names of the fields are given with the &lt;code&gt;names&lt;/code&gt; arguments, the corresponding values with the &lt;code&gt;data&lt;/code&gt; arguments. If a single field is appended, &lt;code&gt;names&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;dtypes&lt;/code&gt; do not have to be lists but just values.</source>
          <target state="translated">字段的 &lt;code&gt;names&lt;/code&gt; 与名称参数一起给出，相应的值与 &lt;code&gt;data&lt;/code&gt; 参数一起给出。如果附加了单个字段，则 &lt;code&gt;names&lt;/code&gt; ， &lt;code&gt;data&lt;/code&gt; 和 &lt;code&gt;dtypes&lt;/code&gt; 不必是列表，而只需是值。</target>
        </trans-unit>
        <trans-unit id="be2b0c55353c6ed87f255a0400693d129089b164" translate="yes" xml:space="preserve">
          <source>The native NumPy indexing type is &lt;code&gt;intp&lt;/code&gt; and may differ from the default integer array type. &lt;code&gt;intp&lt;/code&gt; is the smallest data type sufficient to safely index any array; for advanced indexing it may be faster than other types.</source>
          <target state="translated">本机NumPy索引类型为 &lt;code&gt;intp&lt;/code&gt; ，可能与默认的整数数组类型不同。 &lt;code&gt;intp&lt;/code&gt; 是足以安全地索引任何数组的最小数据类型；对于高级索引，它可能比其他类型更快。</target>
        </trans-unit>
        <trans-unit id="762cb1cca826c6e2247cb37d4810072af245272b" translate="yes" xml:space="preserve">
          <source>The natural log of the absolute value of the determinant.</source>
          <target state="translated">定数绝对值的自然对数。</target>
        </trans-unit>
        <trans-unit id="b3888cd1c7265c4b4a7bad4003632b69982812b1" translate="yes" xml:space="preserve">
          <source>The natural logarithm &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; is the inverse of the exponential function, so that &lt;code&gt;log(exp(x)) = x&lt;/code&gt;. The natural logarithm is logarithm in base &lt;a href=&quot;../constants#numpy.e&quot;&gt;&lt;code&gt;e&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">自然对数&lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt;是指数函数的倒数，因此 &lt;code&gt;log(exp(x)) = x&lt;/code&gt; 。自然对数是以&lt;a href=&quot;../constants#numpy.e&quot;&gt; &lt;code&gt;e&lt;/code&gt; &lt;/a&gt;为底的对数。</target>
        </trans-unit>
        <trans-unit id="133131ae7b63a1c0b2c215fb536c3aee797a1a49" translate="yes" xml:space="preserve">
          <source>The natural logarithm of &lt;code&gt;x&lt;/code&gt;, element-wise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的自然对数，以元素为单位。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="79018bd215ed2a4de07a7be8acb4bd00eb575cb1" translate="yes" xml:space="preserve">
          <source>The nditer can no longer be iterated once either &lt;code&gt;close&lt;/code&gt; is called or its context is exited.</source>
          <target state="translated">一旦调用 &lt;code&gt;close&lt;/code&gt; 或退出其上下文，就不再可以迭代nditer 。</target>
        </trans-unit>
        <trans-unit id="fba110cc07d7918f904cb2219cd75774f5e101fe" translate="yes" xml:space="preserve">
          <source>The nditer will then yield writeable buffer arrays which you may modify. However, because the nditer must copy this buffer data back to the original array once iteration is finished, you must signal when the iteration is ended, by one of two methods. You may either:</source>
          <target state="translated">迭代器将产生可写的缓冲区数组,你可以修改这些数组。然而,因为一旦迭代结束,nditer必须将这些缓冲区的数据复制回原来的数组,所以你必须在迭代结束的时候发出信号,用两种方法之一。你可以通过以下两种方法之一来结束迭代。</target>
        </trans-unit>
        <trans-unit id="36c9f1e0a0257851539d48df01a2ed2f053f22d7" translate="yes" xml:space="preserve">
          <source>The new array is formed from the data in the old array, repeated if necessary to fill out the required number of elements. The data are repeated in the order that they are stored in memory.</source>
          <target state="translated">新的数组是由旧数组中的数据组成的,如果有必要的话,会重复这些数据,以填满所需的元素数量。数据按其在内存中的存储顺序重复。</target>
        </trans-unit>
        <trans-unit id="a04e3c53d25194cf3b0ad0e57f30edc1bdcf03db" translate="yes" xml:space="preserve">
          <source>The new array will have a new last dimension equal in size to the number of field-elements of the input array. If not supplied, the output datatype is determined from the numpy type promotion rules applied to all the field datatypes.</source>
          <target state="translated">新的数组将有一个新的最后一个维度,其大小等于输入数组中字段元素的数量,如果没有提供,输出数据类型由应用于所有字段数据类型的numpy类型推广规则决定。如果没有提供,输出数据类型由应用于所有字段数据类型的numpy类型推广规则决定。</target>
        </trans-unit>
        <trans-unit id="f97568b5d149f57d8764f77c287f9f2fe46a132b" translate="yes" xml:space="preserve">
          <source>The new behavior as of Numpy 1.16 leads to extra &amp;ldquo;padding&amp;rdquo; bytes at the location of unindexed fields compared to 1.15. You will need to update any code which depends on the data having a &amp;ldquo;packed&amp;rdquo; layout. For instance code such as:</source>
          <target state="translated">与1.15相比，Numpy 1.16中的新行为导致在未索引字段的位置出现了额外的&amp;ldquo;填充&amp;rdquo;字节。您将需要更新任何代码，这些代码取决于具有&amp;ldquo;打包&amp;rdquo;布局的数据。例如如下代码：</target>
        </trans-unit>
        <trans-unit id="1e027640aca67041dbf9c118ab74b0f73d41441e" translate="yes" xml:space="preserve">
          <source>The new infrastructure takes a different approach to producing random numbers from the &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; object. Random number generation is separated into two components, a bit generator and a random generator.</source>
          <target state="translated">新的基础结构采用了不同的方法来从&lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;对象生成随机数。随机数生成分为两个部分，即位生成器和随机生成器。</target>
        </trans-unit>
        <trans-unit id="5d98e8d2c80f824b8ece662a9850103c0477cac7" translate="yes" xml:space="preserve">
          <source>The new infrastructure takes a different approach to producing random numbers from the &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; object. Random number generation is separated into two components, a bit generator and a random generator.</source>
          <target state="translated">新的基础结构采用了不同的方法来从&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;对象生成随机数。随机数生成分为两个部分，即位生成器和随机生成器。</target>
        </trans-unit>
        <trans-unit id="125105242ec81f06cd25f403baeb3cf1e8d9cd77" translate="yes" xml:space="preserve">
          <source>The new interface has docstring:</source>
          <target state="translated">新界面有docstring。</target>
        </trans-unit>
        <trans-unit id="86aae80fcd76b7ce0d8ebf83a57b3d06b3426d61" translate="yes" xml:space="preserve">
          <source>The new keyword argument interface and &lt;code&gt;excluded&lt;/code&gt; argument support further degrades performance.</source>
          <target state="translated">新的关键字参数接口和 &lt;code&gt;excluded&lt;/code&gt; 参数支持进一步降低了性能。</target>
        </trans-unit>
        <trans-unit id="d86ea97e67bbca694f01bcdba7b94c4f6336cda1" translate="yes" xml:space="preserve">
          <source>The new name for the function. Default is None, in which case the deprecation message is that &lt;code&gt;old_name&lt;/code&gt; is deprecated. If given, the deprecation message is that &lt;code&gt;old_name&lt;/code&gt; is deprecated and &lt;code&gt;new_name&lt;/code&gt; should be used instead.</source>
          <target state="translated">该函数的新名称。默认值为&amp;ldquo;无&amp;rdquo;，在这种情况下，不赞成使用的消息是不赞成使用 &lt;code&gt;old_name&lt;/code&gt; 。如果给出，则弃用消息是不赞成使用 &lt;code&gt;old_name&lt;/code&gt; ，而应改用 &lt;code&gt;new_name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55a87f3b341973ae0ced92b1f1a3e3e7074aa9e8" translate="yes" xml:space="preserve">
          <source>The new shape should be compatible with the original shape. If an integer is supplied, then the result will be a 1-D array of that length.</source>
          <target state="translated">新的形状应该与原来的形状兼容,如果提供一个整数,那么结果将是该长度的1-D数组。如果提供一个整数,那么结果将是该长度的1-D数组。</target>
        </trans-unit>
        <trans-unit id="691ae079d9ba62e9263b39950b26bbea5ce21d52" translate="yes" xml:space="preserve">
          <source>The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.</source>
          <target state="translated">新的形状应该与原始形状兼容。如果是整数,那么结果将是该长度的1-D数组。一个形状维度可以是-1,在这种情况下,从数组的长度和剩余的维度推断出数值。</target>
        </trans-unit>
        <trans-unit id="5388ec77c34409cb3cbd101b8eec670a3d1a1fdf" translate="yes" xml:space="preserve">
          <source>The next 1 byte is an unsigned byte: the major version number of the file format, e.g. &lt;code&gt;\x01&lt;/code&gt;.</source>
          <target state="translated">接下来的1个字节是无符号字节：文件格式的主要版本号，例如 &lt;code&gt;\x01&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="728636cfde682c4ca8ef5825e1a61b87b60f117f" translate="yes" xml:space="preserve">
          <source>The next 1 byte is an unsigned byte: the minor version number of the file format, e.g. &lt;code&gt;\x00&lt;/code&gt;. Note: the version of the file format is not tied to the version of the numpy package.</source>
          <target state="translated">接下来的1个字节是一个无符号字节：文件格式的次版本号，例如 &lt;code&gt;\x00&lt;/code&gt; 。注意：文件格式的版本与numpy软件包的版本无关。</target>
        </trans-unit>
        <trans-unit id="87a88c47d7bd9a05055f3613db15f890d4b10172" translate="yes" xml:space="preserve">
          <source>The next 2 bytes form a little-endian unsigned short int: the length of the header data HEADER_LEN.</source>
          <target state="translated">后面的2个字节形成一个小恩典无符号短int:头数据HEADER_LEN的长度。</target>
        </trans-unit>
        <trans-unit id="c0777c38aebc3061e6b58d63a6472bc19821f955" translate="yes" xml:space="preserve">
          <source>The next HEADER_LEN bytes form the header data describing the array&amp;rsquo;s format. It is an ASCII string which contains a Python literal expression of a dictionary. It is terminated by a newline (&lt;code&gt;\n&lt;/code&gt;) and padded with spaces (&lt;code&gt;\x20&lt;/code&gt;) to make the total of &lt;code&gt;len(magic string) + 2 + len(length) + HEADER_LEN&lt;/code&gt; be evenly divisible by 64 for alignment purposes.</source>
          <target state="translated">接下来的HEADER_LEN字节形成描述数组格式的头数据。它是一个ASCII字符串，其中包含字典的Python文字表达式。它以换行符（ &lt;code&gt;\n&lt;/code&gt; ）终止，并用空格（ &lt;code&gt;\x20&lt;/code&gt; ）填充，以使 &lt;code&gt;len(magic string) + 2 + len(length) + HEADER_LEN&lt;/code&gt; 可以被64整除，以进行对齐。</target>
        </trans-unit>
        <trans-unit id="af4ca037dcfe75d78dee9fbf52e144a1bd398782" translate="yes" xml:space="preserve">
          <source>The next floating point value after x1 towards x2</source>
          <target state="translated">x1之后的下一个浮点数向x2倾斜</target>
        </trans-unit>
        <trans-unit id="82fde05cc761629191474fcaee36452854b7c17c" translate="yes" xml:space="preserve">
          <source>The next representable values of &lt;code&gt;x1&lt;/code&gt; in the direction of &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 在 &lt;code&gt;x2&lt;/code&gt; 方向上的下一个可表示值。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="4935ecbe795efbe6b2d076bc80d266ef9b3d3b31" translate="yes" xml:space="preserve">
          <source>The next step depends on the type of index which was found. If all dimensions are indexed with an integer a scalar is returned or set. A single boolean indexing array will call specialized boolean functions. Indices containing an ellipsis or slice but no advanced indexing will always create a view into the old array by calculating the new strides and memory offset. This view can then either be returned or, for assignments, filled using &lt;code&gt;PyArray_CopyObject&lt;/code&gt;. Note that &lt;code&gt;PyArray_CopyObject&lt;/code&gt; may also be called on temporary arrays in other branches to support complicated assignments when the array is of object dtype.</source>
          <target state="translated">下一步取决于找到的索引类型。如果所有维都用整数索引，则返回或设置标量。单个布尔索引数组将调用专用的布尔函数。包含省略号或切片但没有高级索引的索引将始终通过计算新的步幅和内存偏移来创建旧数组的视图。然后可以返回该视图，或者可以使用 &lt;code&gt;PyArray_CopyObject&lt;/code&gt; 来填充该视图。请注意，当数组为 &lt;code&gt;PyArray_CopyObject&lt;/code&gt; 也可以在其他分支的临时数组上调用PyArray_CopyObject以支持复杂的分配。</target>
        </trans-unit>
        <trans-unit id="bdf75a3a6e21cea0d77ec634980ca032f5eeb858" translate="yes" xml:space="preserve">
          <source>The next table presents the performance in percentage relative to values generated by the legacy generator, &lt;code&gt;RandomState(MT19937())&lt;/code&gt;. The overall performance was computed using a geometric mean.</source>
          <target state="translated">下表显示了相对于传统生成器 &lt;code&gt;RandomState(MT19937())&lt;/code&gt; 生成的值的性能百分比。使用几何平均值计算总体性能。</target>
        </trans-unit>
        <trans-unit id="e979bd0b63198c55de3690f43140859bad90f54c" translate="yes" xml:space="preserve">
          <source>The nice interface can also be generated automatically by placing the variable directives as special comments in the original Fortran code. Thus, if I modify the source code to contain:</source>
          <target state="translated">通过将变量指令作为特殊注释放在原始Fortran代码中,也可以自动生成漂亮的界面。因此,如果我修改源码,包含。</target>
        </trans-unit>
        <trans-unit id="5462948418f50794d8b059e0adf72cefb6356af5" translate="yes" xml:space="preserve">
          <source>The nice interface can also be generated automatically by placing the variable directives as special comments in the original fortran code. Thus, if I modify the source code to contain:</source>
          <target state="translated">通过将变量指令作为特殊注释放在原始fortran代码中,也可以自动生成漂亮的界面。因此,如果我修改源码中包含。</target>
        </trans-unit>
        <trans-unit id="0153c9bc357a3afb289f46e1296cad96a6ebfe64" translate="yes" xml:space="preserve">
          <source>The noncentral</source>
          <target state="translated">非中枢</target>
        </trans-unit>
        <trans-unit id="007f1b9babda9d4c7b56259360ff2b4902c7689b" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">正态分布通常发生在自然界中。例如，它描述了受大量细微，随机扰动影响的样本的普遍分布，每种扰动都有自己独特的分布&lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2acd5981a8ea796b96e83bb6555be4413ecc4212" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#ra2e838c5ea87-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">正态分布通常发生在自然界中。例如，它描述了受大量细微，随机扰动影响的样本的普遍分布，每种扰动都有其自己独特的分布&lt;a href=&quot;#ra2e838c5ea87-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="edcb775700a94ba4ed282cab54aed1dcf6bc2923" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">正态分布通常发生在自然界中。例如，它描述了受大量细微，随机扰动影响的样本的普遍分布，每种扰动都有自己独特的分布&lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e795cd0114f2e83de16303b01c212b1bae08ff6" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#rf578abb8fba2-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">正态分布通常发生在自然界中。例如，它描述了受大量细微，随机扰动影响的样本的普遍分布，每种扰动都有其自己独特的分布&lt;a href=&quot;#rf578abb8fba2-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="966686da674deab5a174046b2e8990436c2787f9" translate="yes" xml:space="preserve">
          <source>The normal, exponential and gamma generators use 256-step Ziggurat methods which are 2-10 times faster than NumPy&amp;rsquo;s default implementation in &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">常规，指数和gamma生成器使用256步Ziggurat方法，比NumPy在&lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; 中&lt;/a&gt;的默认实现快2-10倍。</target>
        </trans-unit>
        <trans-unit id="725e48eaa30d1b2cbd58c002507d29063f93ce22" translate="yes" xml:space="preserve">
          <source>The normalized (unit &amp;ldquo;length&amp;rdquo;) eigenvectors, such that the column &lt;code&gt;v[:,i]&lt;/code&gt; is the eigenvector corresponding to the eigenvalue &lt;code&gt;w[i]&lt;/code&gt;.</source>
          <target state="translated">归一化（单位为&amp;ldquo;长度&amp;rdquo;）特征向量，使得列 &lt;code&gt;v[:,i]&lt;/code&gt; 是对应于特征值 &lt;code&gt;w[i]&lt;/code&gt; 的特征向量。</target>
        </trans-unit>
        <trans-unit id="3299e827c6aa0d2d0f05fb49e420b7948a6917ca" translate="yes" xml:space="preserve">
          <source>The normed arguments of &lt;code&gt;histogramdd&lt;/code&gt; and &lt;code&gt;histogram2d&lt;/code&gt; have been renamed</source>
          <target state="translated">&lt;code&gt;histogramdd&lt;/code&gt; 和 &lt;code&gt;histogram2d&lt;/code&gt; 的规范参数已重命名</target>
        </trans-unit>
        <trans-unit id="4a2bc0ba793eb9bb3e0347a0cebea0eac0618ee5" translate="yes" xml:space="preserve">
          <source>The nuclear norm is the sum of the singular values.</source>
          <target state="translated">核规范是奇异值之和。</target>
        </trans-unit>
        <trans-unit id="fb33d48b0d271638a6f54e06bd5c7431683a4b77" translate="yes" xml:space="preserve">
          <source>The number 13 has the binaray representation &lt;code&gt;00001101&lt;/code&gt;. Likewise, 16 is represented by &lt;code&gt;00010000&lt;/code&gt;. The bit-wise OR of 13 and 16 is then &lt;code&gt;000111011&lt;/code&gt;, or 29:</source>
          <target state="translated">数13具有binaray表示 &lt;code&gt;00001101&lt;/code&gt; 。同样，16用 &lt;code&gt;00010000&lt;/code&gt; 表示。13和16的按位或则为 &lt;code&gt;000111011&lt;/code&gt; 或29：</target>
        </trans-unit>
        <trans-unit id="9301b88af54fb2d08827d44439e6252ad34f0666" translate="yes" xml:space="preserve">
          <source>The number 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. Likewise, 17 is represented by &lt;code&gt;00010001&lt;/code&gt;. The bit-wise AND of 13 and 17 is therefore &lt;code&gt;000000001&lt;/code&gt;, or 1:</source>
          <target state="translated">数字13由 &lt;code&gt;00001101&lt;/code&gt; 表示。同样，17由 &lt;code&gt;00010001&lt;/code&gt; 表示。因此，13和17的按位与是 &lt;code&gt;000000001&lt;/code&gt; 或1：</target>
        </trans-unit>
        <trans-unit id="5dd5ca9f1bd4e589a273ee53560b9a52127f59e7" translate="yes" xml:space="preserve">
          <source>The number 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. Likewise, 17 is represented by &lt;code&gt;00010001&lt;/code&gt;. The bit-wise XOR of 13 and 17 is therefore &lt;code&gt;00011100&lt;/code&gt;, or 28:</source>
          <target state="translated">数字13由 &lt;code&gt;00001101&lt;/code&gt; 表示。同样，17由 &lt;code&gt;00010001&lt;/code&gt; 表示。因此，13和17的按位XOR为 &lt;code&gt;00011100&lt;/code&gt; 或28：</target>
        </trans-unit>
        <trans-unit id="d78115c4219b81e0960ff03256ee289bd93dfe48" translate="yes" xml:space="preserve">
          <source>The number &lt;code&gt;w&lt;/code&gt; is an eigenvalue of &lt;code&gt;a&lt;/code&gt; if there exists a vector &lt;code&gt;v&lt;/code&gt; such that &lt;code&gt;a @ v = w * v&lt;/code&gt;. Thus, the arrays &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;a @ v[:,i] = w[i] * v[:,i]&lt;/code&gt; for</source>
          <target state="translated">数 &lt;code&gt;w&lt;/code&gt; 是的特征值 &lt;code&gt;a&lt;/code&gt; ，如果存在一个矢量 &lt;code&gt;v&lt;/code&gt; ，使得 &lt;code&gt;a @ v = w * v&lt;/code&gt; 。因此，该阵列 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;w&lt;/code&gt; ，并且 &lt;code&gt;v&lt;/code&gt; 满足方程 &lt;code&gt;a @ v[:,i] = w[i] * v[:,i]&lt;/code&gt; 为</target>
        </trans-unit>
        <trans-unit id="dafcbdde76f7395561c97c3255cdf449984b5af3" translate="yes" xml:space="preserve">
          <source>The number &lt;code&gt;w&lt;/code&gt; is an eigenvalue of &lt;code&gt;a&lt;/code&gt; if there exists a vector &lt;code&gt;v&lt;/code&gt; such that &lt;code&gt;dot(a,v) = w * v&lt;/code&gt;. Thus, the arrays &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;dot(a[:,:], v[:,i]) = w[i] * v[:,i]&lt;/code&gt; for</source>
          <target state="translated">数 &lt;code&gt;w&lt;/code&gt; 是的特征值 &lt;code&gt;a&lt;/code&gt; ，如果存在一个矢量 &lt;code&gt;v&lt;/code&gt; ，使得 &lt;code&gt;dot(a,v) = w * v&lt;/code&gt; 。因此，该阵列 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;w&lt;/code&gt; ，并且 &lt;code&gt;v&lt;/code&gt; 满足方程 &lt;code&gt;dot(a[:,:], v[:,i]) = w[i] * v[:,i]&lt;/code&gt; 为</target>
        </trans-unit>
        <trans-unit id="1bb66b4a14636c387bd7dac27c6170702e129db5" translate="yes" xml:space="preserve">
          <source>The number of arguments.</source>
          <target state="translated">争论的数量。</target>
        </trans-unit>
        <trans-unit id="2746ed3dbbfae3f48c36fec89fbf1da59232f7b4" translate="yes" xml:space="preserve">
          <source>The number of array dimensions.</source>
          <target state="translated">阵列维数。</target>
        </trans-unit>
        <trans-unit id="50f26fa4113f32c300038f926f58c5de950b657e" translate="yes" xml:space="preserve">
          <source>The number of arrays that need to be broadcast to the same shape.</source>
          <target state="translated">需要广播到同一形状的数组的数量。</target>
        </trans-unit>
        <trans-unit id="cd1c13079fc7462745575ad6cadd5c1655d5fd8f" translate="yes" xml:space="preserve">
          <source>The number of base units in a step.</source>
          <target state="translated">一个步骤中的基本单位数。</target>
        </trans-unit>
        <trans-unit id="ddeea3732f7461b0e4b46d4155abe0931176b591" translate="yes" xml:space="preserve">
          <source>The number of bins (of size 1) is one larger than the largest value in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;minlength&lt;/code&gt; is specified, there will be at least this number of bins in the output array (though it will be longer if necessary, depending on the contents of &lt;code&gt;x&lt;/code&gt;). Each bin gives the number of occurrences of its index value in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;weights&lt;/code&gt; is specified the input array is weighted by it, i.e. if a value &lt;code&gt;n&lt;/code&gt; is found at position &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;out[n] += weight[i]&lt;/code&gt; instead of &lt;code&gt;out[n] += 1&lt;/code&gt;.</source>
          <target state="translated">箱数（大小为1）比 &lt;code&gt;x&lt;/code&gt; 中的最大值大1。如果指定了 &lt;code&gt;minlength&lt;/code&gt; ，则输出数组中至少会有这个bin数量（尽管如果需要，它会更长一些，具体取决于 &lt;code&gt;x&lt;/code&gt; 的内容）。每个bin以 &lt;code&gt;x&lt;/code&gt; 给出其索引值出现的次数。如果指定了 &lt;code&gt;weights&lt;/code&gt; 则对输入数组进行加权，即，如果在位置 &lt;code&gt;i&lt;/code&gt; 处找到值 &lt;code&gt;n&lt;/code&gt; ，则 &lt;code&gt;out[n] += weight[i]&lt;/code&gt; 而不是 &lt;code&gt;out[n] += 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="961981b3d06507afe179094c308682fa430fda0e" translate="yes" xml:space="preserve">
          <source>The number of bins for all dimensions (nx=ny=&amp;hellip;=bins).</source>
          <target state="translated">所有维度的箱数（nx = ny =&amp;hellip;=箱）。</target>
        </trans-unit>
        <trans-unit id="180a01cbfbe39044df94a38205c151e4055dfaef" translate="yes" xml:space="preserve">
          <source>The number of bins for each dimension (nx, ny, &amp;hellip; =bins)</source>
          <target state="translated">每个维度的垃圾箱数量（nx，ny，&amp;hellip;=垃圾箱）</target>
        </trans-unit>
        <trans-unit id="ef8032cee94538f0c3d6bbb995bbf06ce4b1a135" translate="yes" xml:space="preserve">
          <source>The number of bins is only proportional to cube root of &lt;code&gt;a.size&lt;/code&gt;. It tends to overestimate the number of bins and it does not take into account data variability.</source>
          <target state="translated">箱数仅与 &lt;code&gt;a.size&lt;/code&gt; 的立方根成正比。它往往高估了bin的数量，并且没有考虑数据的可变性。</target>
        </trans-unit>
        <trans-unit id="3c7ac04dd9e94e09e580f7718e7797190217f2db" translate="yes" xml:space="preserve">
          <source>The number of bins is the base 2 log of &lt;code&gt;a.size&lt;/code&gt;. This estimator assumes normality of data and is too conservative for larger, non-normal datasets. This is the default method in R&amp;rsquo;s &lt;code&gt;hist&lt;/code&gt; method.</source>
          <target state="translated">箱数是 &lt;code&gt;a.size&lt;/code&gt; 的以2为底的对数。此估算器假设数据是正态性的，对于较大的非正态数据集而言过于保守。这是R的 &lt;code&gt;hist&lt;/code&gt; 方法中的默认方法。</target>
        </trans-unit>
        <trans-unit id="ec49cbff29de9e7b90f0c2a06cd3039e0f213a48" translate="yes" xml:space="preserve">
          <source>The number of bits in the exponent including its sign and bias.</source>
          <target state="translated">指数中的位数,包括其符号和偏置。</target>
        </trans-unit>
        <trans-unit id="ffbebedcdf5bf4f1593520cffb80749e6f34262c" translate="yes" xml:space="preserve">
          <source>The number of bits in the exponent portion of the floating point representation.</source>
          <target state="translated">浮点数表示的指数部分的位数。</target>
        </trans-unit>
        <trans-unit id="96302b58629afe268f2042e560d43721a3fc2867" translate="yes" xml:space="preserve">
          <source>The number of bits in the mantissa.</source>
          <target state="translated">咒语中的位数。</target>
        </trans-unit>
        <trans-unit id="792cc1a58f0a3a46d19118877b6d13c493cb98ec" translate="yes" xml:space="preserve">
          <source>The number of bits occupied by the type.</source>
          <target state="translated">类型占用的位数。</target>
        </trans-unit>
        <trans-unit id="b307f502028d1a8e478a9e28dfcf2d36c5fe0bca" translate="yes" xml:space="preserve">
          <source>The number of bits required to generate a simulated value differs from the number of bits generated by the underlying RNG. For example, two 16-bit integer values can be simulated from a single draw of a 32-bit RNG.</source>
          <target state="translated">生成模拟值所需的位数与底层RNG生成的位数不同。例如,可以从32位RNG的一次抽签中模拟出两个16位整数值。</target>
        </trans-unit>
        <trans-unit id="5b028aff9079ccf79e60389c0ccd1c2bd52c5a13" translate="yes" xml:space="preserve">
          <source>The number of build jobs can also be specified via the environment variable &lt;code&gt;NPY_NUM_BUILD_JOBS&lt;/code&gt;.</source>
          <target state="translated">也可以通过环境变量 &lt;code&gt;NPY_NUM_BUILD_JOBS&lt;/code&gt; 来指定构建作业的数量。</target>
        </trans-unit>
        <trans-unit id="c523c9c933fe391fb48ef56ebd3c154a68738ed9" translate="yes" xml:space="preserve">
          <source>The number of bytes each item in the array requires.</source>
          <target state="translated">数组中每个项目所需的字节数。</target>
        </trans-unit>
        <trans-unit id="accc8d694cc26b9e63438cb6cbca5878ebb2f8ff" translate="yes" xml:space="preserve">
          <source>The number of bytes into the field at which to place &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 字段中的字节数。</target>
        </trans-unit>
        <trans-unit id="a1bc94a2ea241fcb184442f81754fe01e618cf6a" translate="yes" xml:space="preserve">
          <source>The number of characters per line for the purpose of inserting line breaks (default 75).</source>
          <target state="translated">每行的字符数,用于插入换行符(默认75)。</target>
        </trans-unit>
        <trans-unit id="e62a5487dfe8294b0662475991a8ef49d96aaa30" translate="yes" xml:space="preserve">
          <source>The number of children already spawned. Only pass this if reconstructing a &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; from a serialized form.</source>
          <target state="translated">已经产生的孩子数量。仅当从序列化形式重构&lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;时才通过此操作。</target>
        </trans-unit>
        <trans-unit id="51818f09691484990d73679da97e27bd0b748a81" translate="yes" xml:space="preserve">
          <source>The number of dimensions and the size of each dimension</source>
          <target state="translated">尺寸的数量和每个尺寸的大小。</target>
        </trans-unit>
        <trans-unit id="20f7440820740cd73bd8bc73940f9eb0da1ec572" translate="yes" xml:space="preserve">
          <source>The number of dimensions in the array.</source>
          <target state="translated">阵列的维数。</target>
        </trans-unit>
        <trans-unit id="d4b953d2df6296d252217619c918790078f1f070" translate="yes" xml:space="preserve">
          <source>The number of dimensions in the broadcasted result.</source>
          <target state="translated">广播结果的维度数。</target>
        </trans-unit>
        <trans-unit id="16045283fd37589fa60a5d2a0d49dd57ac83ac40" translate="yes" xml:space="preserve">
          <source>The number of dimensions.</source>
          <target state="translated">层面的数量。</target>
        </trans-unit>
        <trans-unit id="cf23530c90606a0534a47544a2bf03555320f356" translate="yes" xml:space="preserve">
          <source>The number of each type of item in the collection from which a sample is drawn. The values in &lt;code&gt;colors&lt;/code&gt; must be nonnegative. To avoid loss of precision in the algorithm, &lt;code&gt;sum(colors)&lt;/code&gt; must be less than &lt;code&gt;10**9&lt;/code&gt; when &lt;code&gt;method&lt;/code&gt; is &amp;ldquo;marginals&amp;rdquo;.</source>
          <target state="translated">从中抽取样本的集合中每种项目的编号。 &lt;code&gt;colors&lt;/code&gt; 的值必须为非负数。为避免算法精度下降，当 &lt;code&gt;method&lt;/code&gt; 为&amp;ldquo; marginals&amp;rdquo;时， &lt;code&gt;sum(colors)&lt;/code&gt; 必须小于 &lt;code&gt;10**9&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6aad0168a8285a1a3006caa27029c5241a1ba31b" translate="yes" xml:space="preserve">
          <source>The number of elements in the gentype.</source>
          <target state="translated">基因型中的元素数量;</target>
        </trans-unit>
        <trans-unit id="3a0a0191ab6889929bc691e4ea5f7b01d6f77c2e" translate="yes" xml:space="preserve">
          <source>The number of elements to unpack along &lt;code&gt;axis&lt;/code&gt;, provided as a way of undoing the effect of packing a size that is not a multiple of eight. A non-negative number means to only unpack &lt;code&gt;count&lt;/code&gt; bits. A negative number means to trim off that many bits from the end. &lt;code&gt;None&lt;/code&gt; means to unpack the entire array (the default). Counts larger than the available number of bits will add zero padding to the output. Negative counts must not exceed the available number of bits.</source>
          <target state="translated">沿 &lt;code&gt;axis&lt;/code&gt; 拆包的元素数，作为消除包装尺寸不是八的倍数的效果的一种方式。非负数表示仅解包 &lt;code&gt;count&lt;/code&gt; 位。负数表示从末尾开始修剪掉那么多位。 &lt;code&gt;None&lt;/code&gt; 表示将整个阵列拆包（默认）。大于可用位数的计数将为输出添加零填充。负计数不得超过可用位数。</target>
        </trans-unit>
        <trans-unit id="9762b9c4461b4320b651627cdc827d526c1d8a36" translate="yes" xml:space="preserve">
          <source>The number of floating-point types</source>
          <target state="translated">浮点类型的数量</target>
        </trans-unit>
        <trans-unit id="5f79b76db3c0063c4dbecc42a7851ca0e7d61297" translate="yes" xml:space="preserve">
          <source>The number of input arguments.</source>
          <target state="translated">输入参数的数量。</target>
        </trans-unit>
        <trans-unit id="5f16430ff4bbbb029090f84ca5392fa4a978dcbf" translate="yes" xml:space="preserve">
          <source>The number of inputs.</source>
          <target state="translated">投入的数量;</target>
        </trans-unit>
        <trans-unit id="ad3ac53999da2a535168ea7e917e83fb83c41419" translate="yes" xml:space="preserve">
          <source>The number of integrations to perform.</source>
          <target state="translated">要进行整合的次数。</target>
        </trans-unit>
        <trans-unit id="f51beaacf43aeefc0899893a53af8824382a26f0" translate="yes" xml:space="preserve">
          <source>The number of items selected. &lt;code&gt;nsample&lt;/code&gt; must not be greater than &lt;code&gt;sum(colors)&lt;/code&gt;.</source>
          <target state="translated">所选项目的数量。 &lt;code&gt;nsample&lt;/code&gt; 不得大于 &lt;code&gt;sum(colors)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb27416d0d8fd4a79bebfa578ec630568a0908f0" translate="yes" xml:space="preserve">
          <source>The number of items to read from &lt;em&gt;iterable&lt;/em&gt;. The default is -1, which means all data is read.</source>
          <target state="translated">从&lt;em&gt;iterable中&lt;/em&gt;读取的项目数。默认值为-1，表示读取所有数据。</target>
        </trans-unit>
        <trans-unit id="59d7f6376949b026c4f59178cb450cda4e03c50d" translate="yes" xml:space="preserve">
          <source>The number of iterator operands.</source>
          <target state="translated">迭代操作数的数量。</target>
        </trans-unit>
        <trans-unit id="906dbe82e1bcf21f6f38450b28f60987840c67b3" translate="yes" xml:space="preserve">
          <source>The number of lines to skip at the beginning of the file.</source>
          <target state="translated">文件开头要跳过的行数。</target>
        </trans-unit>
        <trans-unit id="1f9e5bb5bb6065f40b3b5f1acf92ad15826aa414" translate="yes" xml:space="preserve">
          <source>The number of lines to skip at the end of the file.</source>
          <target state="translated">文件末尾要跳过的行数。</target>
        </trans-unit>
        <trans-unit id="36ce98d71e68fb1757547c834a0c7900df88883d" translate="yes" xml:space="preserve">
          <source>The number of numerical NumPy types - of which there are 18 total - on which the ufunc can operate.</source>
          <target state="translated">Ufunc可以操作的NumPy数字类型的数量--总共有18种。</target>
        </trans-unit>
        <trans-unit id="9d9f649df57a2efc7c5d1837c8cce03f4ddffe4d" translate="yes" xml:space="preserve">
          <source>The number of objects returned by &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 返回的对象数。</target>
        </trans-unit>
        <trans-unit id="cd1491ebeebfc5761455718746328a874537820d" translate="yes" xml:space="preserve">
          <source>The number of output arguments.</source>
          <target state="translated">输出参数的数量。</target>
        </trans-unit>
        <trans-unit id="bb79176b795c17c39b28af054f09df09e008175b" translate="yes" xml:space="preserve">
          <source>The number of outputs.</source>
          <target state="translated">产出的数量;</target>
        </trans-unit>
        <trans-unit id="1f9d3b6c33190d8820407a65c8dfbe71f2fb41db" translate="yes" xml:space="preserve">
          <source>The number of periods &lt;code&gt;nper&lt;/code&gt; is computed by solving the equation:</source>
          <target state="translated">周期数 &lt;code&gt;nper&lt;/code&gt; 通过解方程计算：</target>
        </trans-unit>
        <trans-unit id="9f00991307aeed3ff212ec1f19aa64c4d4a70887" translate="yes" xml:space="preserve">
          <source>The number of places by which elements are shifted. If a tuple, then &lt;code&gt;axis&lt;/code&gt; must be a tuple of the same size, and each of the given axes is shifted by the corresponding number. If an int while &lt;code&gt;axis&lt;/code&gt; is a tuple of ints, then the same value is used for all given axes.</source>
          <target state="translated">元素移动的位数。如果是元组，则 &lt;code&gt;axis&lt;/code&gt; 必须是相同大小的元组，并且给定的每个轴都移动相应的数字。如果一个int while &lt;code&gt;axis&lt;/code&gt; 是一个int元组，则所有给定轴都使用相同的值。</target>
        </trans-unit>
        <trans-unit id="1c87f40038faffc87024cc0b95bb28f19f5ea872" translate="yes" xml:space="preserve">
          <source>The number of repetitions for each element. &lt;code&gt;repeats&lt;/code&gt; is broadcasted to fit the shape of the given axis.</source>
          <target state="translated">每个元素的重复次数。 &lt;code&gt;repeats&lt;/code&gt; 播放以适合给定轴的形状。</target>
        </trans-unit>
        <trans-unit id="4fedda7271f10f5b28b1a15e8ad961405e48dbc3" translate="yes" xml:space="preserve">
          <source>The number of repetitions of &lt;code&gt;A&lt;/code&gt; along each axis.</source>
          <target state="translated">沿每个轴的 &lt;code&gt;A&lt;/code&gt; 重复次数。</target>
        </trans-unit>
        <trans-unit id="1e0a0e5cb024809c54b4083f3e0a5bc9d1d9a145" translate="yes" xml:space="preserve">
          <source>The number of supported data types for the ufunc. This number specifies how many different 1-d loops (of the builtin data types) are available.</source>
          <target state="translated">ufunc支持的数据类型的数量。这个数字指定了多少个不同的1-d循环(内置数据类型)。</target>
        </trans-unit>
        <trans-unit id="d384dcdb010cb83d633476edabf26a7cd5dcb98d" translate="yes" xml:space="preserve">
          <source>The number of times &lt;code&gt;a&lt;/code&gt; is repeated along the first and second axes.</source>
          <target state="translated">沿第一和第二轴重复的次数 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84ea540c48d087fa8db5ec94e472c5f5f973f2f5" translate="yes" xml:space="preserve">
          <source>The number of times each of the unique values comes up in the original array. Only provided if &lt;code&gt;return_counts&lt;/code&gt; is True.</source>
          <target state="translated">每个唯一值出现在原始数组中的次数。仅在 &lt;code&gt;return_counts&lt;/code&gt; 为True时提供。</target>
        </trans-unit>
        <trans-unit id="27ba063589e5e81b80624f4103b1f5b28059f11a" translate="yes" xml:space="preserve">
          <source>The number of times values are differenced. If zero, the input is returned as-is.</source>
          <target state="translated">值的差分次数。如果为零,则输入值按原样返回。</target>
        </trans-unit>
        <trans-unit id="9f0b88f6fb636dd892bff0b33b009c20d79ffb03" translate="yes" xml:space="preserve">
          <source>The number of types.</source>
          <target state="translated">型的数量。</target>
        </trans-unit>
        <trans-unit id="fddf10cce5774b681c3f0ad6691bdd384810c58d" translate="yes" xml:space="preserve">
          <source>The number of variates to generate, either an integer or a tuple holding the shape of the array of variates. If the given size is, e.g., &lt;code&gt;(k, m)&lt;/code&gt;, then &lt;code&gt;k * m&lt;/code&gt; variates are drawn, where one variate is a vector of length &lt;code&gt;len(colors)&lt;/code&gt;, and the return value has shape &lt;code&gt;(k, m, len(colors))&lt;/code&gt;. If &lt;code&gt;size&lt;/code&gt; is an integer, the output has shape &lt;code&gt;(size, len(colors))&lt;/code&gt;. Default is None, in which case a single variate is returned as an array with shape &lt;code&gt;(len(colors),)&lt;/code&gt;.</source>
          <target state="translated">要生成的变量的数量，可以是保持变量数组形状的整数或元组。如果给定大小为 &lt;code&gt;(k, m)&lt;/code&gt; ，则绘制 &lt;code&gt;k * m&lt;/code&gt; 变量，其中一个变量是长度为 &lt;code&gt;len(colors)&lt;/code&gt; 的向量，返回值的形状为 &lt;code&gt;(k, m, len(colors))&lt;/code&gt; 。如果 &lt;code&gt;size&lt;/code&gt; 是整数，则输出的形状为 &lt;code&gt;(size, len(colors))&lt;/code&gt; 。默认值为None，在这种情况下，单个变量作为形状为 &lt;code&gt;(len(colors),)&lt;/code&gt; 的数组返回。</target>
        </trans-unit>
        <trans-unit id="87e16add792d15ef1991805fd1807bc3c93accb5" translate="yes" xml:space="preserve">
          <source>The numerical data we wish to work with begins at column 4, row 8, and extends from there to the rightmost column and the lowermost row.</source>
          <target state="translated">我们要处理的数字数据从第4列第8行开始,并从那里延伸到最右边的列和最下面的行。</target>
        </trans-unit>
        <trans-unit id="8a67e415f6489cfd59cc7656bd025411ca29912b" translate="yes" xml:space="preserve">
          <source>The numpy array shares the memory with the ctypes object.</source>
          <target state="translated">numpy数组与ctypes对象共享内存。</target>
        </trans-unit>
        <trans-unit id="d790ce3a56f19101368186a47de94f2e3aed2abb" translate="yes" xml:space="preserve">
          <source>The numpy core math library (&amp;lsquo;npymath&amp;rsquo;) is a first step in this direction. This library contains most math-related C99 functionality, which can be used on platforms where C99 is not well supported. The core math functions have the same API as the C99 ones, except for the npy_* prefix.</source>
          <target state="translated">numpy核心数学库（'npymath'）是朝着这个方向迈出的第一步。该库包含大多数与数学相关的C99功能，可以在不完全支持C99的平台上使用。核心数学函数具有与C99相同的API，除了npy_ *前缀。</target>
        </trans-unit>
        <trans-unit id="6064ebb13dec03f1de88e5067059d7a27df68911" translate="yes" xml:space="preserve">
          <source>The numpy documentation also depends on the &lt;a href=&quot;https://numpydoc.readthedocs.io/en/latest/&quot;&gt;numpydoc&lt;/a&gt; sphinx extension as well as an external sphinx theme. These extensions are included as git submodules and must be initialized before building the docs. From the &lt;code&gt;doc/&lt;/code&gt; directory:</source>
          <target state="translated">numpy文档还取决于&lt;a href=&quot;https://numpydoc.readthedocs.io/en/latest/&quot;&gt;numpydoc&lt;/a&gt; sphinx扩展以及外部sphinx主题。这些扩展包含在git子模块中，必须在构建文档之前进行初始化。在 &lt;code&gt;doc/&lt;/code&gt; 目录中：</target>
        </trans-unit>
        <trans-unit id="c633caa71d9888760198001cce3d8210c7c275af" translate="yes" xml:space="preserve">
          <source>The numpy.i file for swig is Python 3 only.</source>
          <target state="translated">swig的numpy.i文件只有Python 3。</target>
        </trans-unit>
        <trans-unit id="d91b51f2620c8e0f1fabe752803d49bce22176fb" translate="yes" xml:space="preserve">
          <source>The numpy.ma module</source>
          <target state="translated">numpy.ma模块</target>
        </trans-unit>
        <trans-unit id="2cbe93e7df3a43f9ae71da4b89814ed8fa49c0d4" translate="yes" xml:space="preserve">
          <source>The numpy/core/include/numpy/numpyconfig.h will need a new NPY_X_Y_API_VERSION macro, where X and Y are the major and minor version numbers of the release. The value given to that macro only needs to be increased from the previous version if some of the functions or macros in the include files were deprecated.</source>
          <target state="translated">numpy/core/include/numpy/numpyconfig.h中将需要一个新的NPY_X_Y_API_VERSION宏,其中X和Y是该版本的主要和次要版本号。只有当include文件中的某些函数或宏被废弃时,才需要在上一个版本的基础上增加给该宏的值。</target>
        </trans-unit>
        <trans-unit id="2fff5784e4a4fb8eb59dd23392ddf836510aaeb1" translate="yes" xml:space="preserve">
          <source>The numpydoc docstring guide</source>
          <target state="translated">numpydoc docstring指南</target>
        </trans-unit>
        <trans-unit id="dbd675a4d044f8874d7c67d632da0258490296eb" translate="yes" xml:space="preserve">
          <source>The object can be any Python object convertible to an ndarray. If the object is already (a subclass of) the ndarray that satisfies the requirements then a new reference is returned. Otherwise, a new array is constructed. The contents of &lt;em&gt;obj&lt;/em&gt; are copied to the new array unless the array interface is used so that data does not have to be copied. Objects that can be converted to an array include: 1) any nested sequence object, 2) any object exposing the array interface, 3) any object with an &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method (which should return an ndarray), and 4) any scalar object (becomes a zero-dimensional array). Sub-classes of the ndarray that otherwise fit the requirements will be passed through. If you want to ensure a base-class ndarray, then use &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_ENSUREARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt;&lt;/a&gt; in the requirements flag. A copy is made only if necessary. If you want to guarantee a copy, then pass in &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_ENSURECOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt;&lt;/a&gt; to the requirements flag.</source>
          <target state="translated">该对象可以是可转换为ndarray的任何Python对象。如果对象已经是满足要求的ndarray（的子类），则返回新的引用。否则，将构造一个新的数组。除非使用数组接口，否则&lt;em&gt;obj&lt;/em&gt;的内容将被复制到新数组中，从而不必复制数据。可以转换为一个数组对象包括：1）任何嵌套序列对象，2）的任何对象暴露阵列接口，3）用的任何对象&lt;a href=&quot;../reference/arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;方法（它应该返回一个ndarray），和4）任何标量对象（变零维数组）。否则将通过ndarray的子​​类满足要求。如果要确保基类ndarray，请使用&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_ENSUREARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt; &lt;/a&gt;在需求标记中。仅在必要时进行复制。如果要保证副本，则将&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_ENSURECOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt; &lt;/a&gt;传递到需求标记。</target>
        </trans-unit>
        <trans-unit id="a12e93df39508259f846e57ebebd07dec5405cd4" translate="yes" xml:space="preserve">
          <source>The object of which the type is returned.</source>
          <target state="translated">返回该类型的对象。</target>
        </trans-unit>
        <trans-unit id="892e730df208b39897e2c0d1b1cca7fbb8ae1420" translate="yes" xml:space="preserve">
          <source>The object to be converted to a type-and-requirement-satisfying array.</source>
          <target state="translated">要转换为满足类型和要求的数组的对象。</target>
        </trans-unit>
        <trans-unit id="bfbfb146acae6cf5d1e2df4b8b0cf4b046d06226" translate="yes" xml:space="preserve">
          <source>The object to check.</source>
          <target state="translated">要检查的对象。</target>
        </trans-unit>
        <trans-unit id="0f3ea496874fb4613c3a9be9c6a176f4f24c9e54" translate="yes" xml:space="preserve">
          <source>The object to iterate over.</source>
          <target state="translated">遍历的对象。</target>
        </trans-unit>
        <trans-unit id="52a504743f31bcad27f2c05d142802d7b1946829" translate="yes" xml:space="preserve">
          <source>The object type is also special because an array containing &lt;a href=&quot;#numpy.object_&quot;&gt;&lt;code&gt;object_&lt;/code&gt;&lt;/a&gt; items does not return an &lt;a href=&quot;#numpy.object_&quot;&gt;&lt;code&gt;object_&lt;/code&gt;&lt;/a&gt; object on item access, but instead returns the actual object that the array item refers to.</source>
          <target state="translated">对象类型也很特殊，因为包含&lt;a href=&quot;#numpy.object_&quot;&gt; &lt;code&gt;object_&lt;/code&gt; &lt;/a&gt; items的数组在访问项目时不会返回&lt;a href=&quot;#numpy.object_&quot;&gt; &lt;code&gt;object_&lt;/code&gt; &lt;/a&gt;对象，而是返回该数组项目所引用的实际对象。</target>
        </trans-unit>
        <trans-unit id="45971228cf20d163b0ca1b27e71b0f9a03bee868" translate="yes" xml:space="preserve">
          <source>The object type is also special because an array containing &lt;code&gt;object_&lt;/code&gt; items does not return an &lt;code&gt;object_&lt;/code&gt; object on item access, but instead returns the actual object that the array item refers to.</source>
          <target state="translated">对象类型也很特殊，因为包含 &lt;code&gt;object_&lt;/code&gt; items 的数组在访问项目时不会返回 &lt;code&gt;object_&lt;/code&gt; 对象，而是返回该数组项目所引用的实际对象。</target>
        </trans-unit>
        <trans-unit id="74fb22be6dfa85b139cc4a823d71b842fbca772d" translate="yes" xml:space="preserve">
          <source>The object which calculated these parameters and holds more detailed information.</source>
          <target state="translated">计算这些参数并保存更详细信息的对象。</target>
        </trans-unit>
        <trans-unit id="12dc58a76790d493cfd5ba208610a891b0f1c28f" translate="yes" xml:space="preserve">
          <source>The object will be converted to the desired type only if it can be done without losing precision. Otherwise &lt;code&gt;NULL&lt;/code&gt; will be returned and an error raised. Use &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt; in the requirements flag to override this behavior.</source>
          <target state="translated">仅在不损失精度的情况下，对象才会转换为所需的类型。否则将返回 &lt;code&gt;NULL&lt;/code&gt; 并引发错误。在需求标志中使用&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_FORCECAST&quot;&gt; &lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt; &lt;/a&gt;可以覆盖此行为。</target>
        </trans-unit>
        <trans-unit id="d7678b3e9676e0762f7a3c623921af222c12ff2c" translate="yes" xml:space="preserve">
          <source>The obvious fix for this situation is to change the dtype so it gives the correct endianness:</source>
          <target state="translated">这种情况的明显修复方法是改变dtype,使其给出正确的endianness。</target>
        </trans-unit>
        <trans-unit id="29b86a58a4365210dddb9297096eac1156c7d098" translate="yes" xml:space="preserve">
          <source>The offset (in bytes) from the file&amp;rsquo;s current position. Defaults to 0. Only permitted for binary files.</source>
          <target state="translated">与文件当前位置的偏移量（以字节为单位）。默认值为0。仅允许用于二进制文件。</target>
        </trans-unit>
        <trans-unit id="93c773e560e0498af231d1a157163977066e3d8a" translate="yes" xml:space="preserve">
          <source>The old error handler.</source>
          <target state="translated">旧的错误处理程序。</target>
        </trans-unit>
        <trans-unit id="1ec4554bb191ce258f048e411e4e87d29267fb91" translate="yes" xml:space="preserve">
          <source>The old iterator API includes functions like PyArrayIter_Check, PyArray_Iter* and PyArray_ITER_*. The multi-iterator array includes PyArray_MultiIter*, PyArray_Broadcast, and PyArray_RemoveSmallest. The new iterator design replaces all of this functionality with a single object and associated API. One goal of the new API is that all uses of the existing iterator should be replaceable with the new iterator without significant effort. In 1.6, the major exception to this is the neighborhood iterator, which does not have corresponding features in this iterator.</source>
          <target state="translated">旧的迭代器API包括PyArrayIter_Check、PyArray_Iter*和PyArray_ITER_*等函数。多迭代器数组包括PyArray_MultiIter*、PyArray_Broadcast和PyArray_RemoveSmallest。新的迭代器设计用一个对象和相关的API取代了所有这些功能。新API的一个目标是,现有迭代器的所有用途都应该可以用新迭代器替换,而不需要花费很大的精力。在1.6中,主要的例外是邻域迭代器,这个迭代器中没有相应的功能。</target>
        </trans-unit>
        <trans-unit id="5bba457e9d70db346759d26e013499c6bff97b55" translate="yes" xml:space="preserve">
          <source>The one-dimensional (forward) FFT, of which &lt;a href=&quot;#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt; is the inverse</source>
          <target state="translated">一维（前向）FFT，其中&lt;a href=&quot;#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt;是逆</target>
        </trans-unit>
        <trans-unit id="5483bbe6b4a2f84418c3aa21133c4c7676377fcb" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT for real input.</source>
          <target state="translated">实输入的一维FFT。</target>
        </trans-unit>
        <trans-unit id="b13835d03a9daf8c507b45bfab105cd08fae35d5" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of general (complex) input.</source>
          <target state="translated">一般(复杂)输入的一维FFT。</target>
        </trans-unit>
        <trans-unit id="0cd037d8b0e459e2ea7f7abda9a2074a96ea80a2" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of real input, of which &lt;a href=&quot;#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; is inverse.</source>
          <target state="translated">实数输入的一维FFT，其&lt;a href=&quot;#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt;是逆的。</target>
        </trans-unit>
        <trans-unit id="9fbd4ce083fd828af7518629c69fc1b51be085ea" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of real input.</source>
          <target state="translated">实输入的一维FFT。</target>
        </trans-unit>
        <trans-unit id="5c18581fbbf72b4741168098a1d9545410236f6d" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT, with definitions and conventions used.</source>
          <target state="translated">一维FFT,有定义和使用的惯例。</target>
        </trans-unit>
        <trans-unit id="cb7777bd048622e7012600d71666f63fa7ceb74f" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT.</source>
          <target state="translated">一维FFT。</target>
        </trans-unit>
        <trans-unit id="225306f7f184d0b92b85104fd4b6b278cc44c9a3" translate="yes" xml:space="preserve">
          <source>The one-dimensional inverse FFT.</source>
          <target state="translated">一维逆向FFT。</target>
        </trans-unit>
        <trans-unit id="ba7c728a6936b18871796d8f180aab8013101b39" translate="yes" xml:space="preserve">
          <source>The only constraint on &lt;code&gt;weights&lt;/code&gt; is that &lt;code&gt;sum(weights)&lt;/code&gt; must not be 0.</source>
          <target state="translated">&lt;code&gt;weights&lt;/code&gt; 的唯一限制是 &lt;code&gt;sum(weights)&lt;/code&gt; 不得为0。</target>
        </trans-unit>
        <trans-unit id="ff0f1129172422a9679a73fc5e8d6a883951639f" translate="yes" xml:space="preserve">
          <source>The only mandatory argument of &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; is the source of the data. It can be a string, a list of strings, a generator or an open file-like object with a &lt;code&gt;read&lt;/code&gt; method, for example, a file or &lt;a href=&quot;https://docs.python.org/dev/library/io.html#io.StringIO&quot;&gt;&lt;code&gt;io.StringIO&lt;/code&gt;&lt;/a&gt; object. If a single string is provided, it is assumed to be the name of a local or remote file. If a list of strings or a generator returning strings is provided, each string is treated as one line in a file. When the URL of a remote file is passed, the file is automatically downloaded to the current directory and opened.</source>
          <target state="translated">&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;的唯一必需参数是数据源。它可以是字符串，字符串列表，生成器或具有 &lt;code&gt;read&lt;/code&gt; 方法的打开的类似文件的对象，例如，文件或&lt;a href=&quot;https://docs.python.org/dev/library/io.html#io.StringIO&quot;&gt; &lt;code&gt;io.StringIO&lt;/code&gt; &lt;/a&gt;对象。如果提供单个字符串，则假定它是本地文件或远程文件的名称。如果提供了字符串列表或返回字符串的生成器，则将每个字符串视为文件中的一行。传递远程文件的URL后，该文件将自动下载到当前目录并打开。</target>
        </trans-unit>
        <trans-unit id="a3bf399916e3e501d883fea808c4310d7579f09c" translate="yes" xml:space="preserve">
          <source>The operand &lt;code&gt;+&lt;/code&gt; is only added for nominal reasons, For example: &lt;code&gt;--cpu-basline= &quot;min avx2&quot;&lt;/code&gt; is equivalent to &lt;code&gt;--cpu-basline=&quot;min + avx2&quot;&lt;/code&gt;. &lt;code&gt;--cpu-basline=&quot;min,avx2&quot;&lt;/code&gt; is equivalent to &lt;code&gt;--cpu-basline`=&quot;min,+avx2&quot;&lt;/code&gt;</source>
          <target state="translated">仅出于名义上的原因才添加操作数 &lt;code&gt;+&lt;/code&gt; ，例如：-- &lt;code&gt;--cpu-basline= &quot;min avx2&quot;&lt;/code&gt; 等效于 &lt;code&gt;--cpu-basline=&quot;min + avx2&quot;&lt;/code&gt; 。 &lt;code&gt;--cpu-basline=&quot;min,avx2&quot;&lt;/code&gt; 等效于 &lt;code&gt;--cpu-basline`=&quot;min,+avx2&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df0b92ea232e6d8dccfcd905588f89bc51445e3a" translate="yes" xml:space="preserve">
          <source>The operands of some operation whose result type is needed.</source>
          <target state="translated">某个操作数的操作数,其结果类型是需要的。</target>
        </trans-unit>
        <trans-unit id="10e5b80590b5efbd493758bd757a312d4d78c228" translate="yes" xml:space="preserve">
          <source>The operation in the inner loop is a straightforward multiplication. Everything to do with the outer product is handled by the iterator setup.</source>
          <target state="translated">内循环中的操作是一个简单的乘法。与外积有关的一切都由迭代器设置处理。</target>
        </trans-unit>
        <trans-unit id="471ee7828ebe7c0602cfc5e6e021f9c562ef10fd" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;dtype=None&lt;/code&gt; is provided for convenience. However, it is significantly slower than setting the dtype explicitly.</source>
          <target state="translated">为方便起见，提供了 &lt;code&gt;dtype=None&lt;/code&gt; 选项。但是，它比显式设置dtype慢得多。</target>
        </trans-unit>
        <trans-unit id="5d9c6a82b754562bff3c30cfb164e81b6c34b6c3" translate="yes" xml:space="preserve">
          <source>The optional &amp;lsquo;aligned&amp;rsquo; value can be set to &lt;code&gt;True&lt;/code&gt; to make the automatic offset computation use aligned offsets (see &lt;a href=&quot;#offsets-and-alignment&quot;&gt;Automatic Byte Offsets and Alignment&lt;/a&gt;), as if the &amp;lsquo;align&amp;rsquo; keyword argument of &lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt; had been set to True.</source>
          <target state="translated">可以将可选的'aligned'值设置为 &lt;code&gt;True&lt;/code&gt; ,以使自动偏移量计算使用对齐的偏移量（请参阅&lt;a href=&quot;#offsets-and-alignment&quot;&gt;自动字节偏移量和Alignment&lt;/a&gt;），就好像&lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;numpy.dtype&lt;/code&gt; &lt;/a&gt;的'align'关键字参数已设置为True一样。</target>
        </trans-unit>
        <trans-unit id="03a3e8c483cee1d9d2b1425187728e8a245d58ca" translate="yes" xml:space="preserve">
          <source>The optional &amp;lsquo;titles&amp;rsquo; value should be a list of titles of the same length as &amp;lsquo;names&amp;rsquo;, see &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt; below.</source>
          <target state="translated">可选的&amp;ldquo; titles&amp;rdquo;值应该是与&amp;ldquo; names&amp;rdquo;长度相同的标题列表，请参见下面的&amp;ldquo;&lt;a href=&quot;#titles&quot;&gt;字段标题&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0af8d6f274a699b745815e9b76bdbe8e97f9313c" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;code&gt;comments&lt;/code&gt; is used to define a character string that marks the beginning of a comment. By default, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; assumes &lt;code&gt;comments='#'&lt;/code&gt;. The comment marker may occur anywhere on the line. Any character present after the comment marker(s) is simply ignored:</source>
          <target state="translated">可选的参数 &lt;code&gt;comments&lt;/code&gt; 用于定义标记注释开始的字符串。默认情况下，&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;假定 &lt;code&gt;comments='#'&lt;/code&gt; 。注释标记可以出现在行中的任何位置。注释标记后面的任何字符都将被忽略：</target>
        </trans-unit>
        <trans-unit id="94b62b6ba781a5ddd569b811fe572b78fe805c1d" translate="yes" xml:space="preserve">
          <source>The optional output arguments can be used to help you save memory for large calculations. If your arrays are large, complicated expressions can take longer than absolutely necessary due to the creation and (later) destruction of temporary calculation spaces. For example, the expression &lt;code&gt;G = a * b + c&lt;/code&gt; is equivalent to &lt;code&gt;t1 = A * B; G = T1 + C; del t1&lt;/code&gt;. It will be more quickly executed as &lt;code&gt;G = A * B; add(G, C, G)&lt;/code&gt; which is the same as &lt;code&gt;G = A * B; G += C&lt;/code&gt;.</source>
          <target state="translated">可选的输出参数可用于帮助您节省用于大型计算的内存。如果数组很大，由于创建和（或以后）破坏临时计算空间，复杂的表达式所花费的时间可能比绝对所需的时间长。例如，表达式 &lt;code&gt;G = a * b + c&lt;/code&gt; 等效于 &lt;code&gt;t1 = A * B; G = T1 + C; del t1&lt;/code&gt; 。当 &lt;code&gt;G = A * B; add(G, C, G)&lt;/code&gt; ，它将更快地执行；add（G，C，G）与 &lt;code&gt;G = A * B; G += C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b2c78f4cc1b5de9c0c210654a3400e8183ebd83" translate="yes" xml:space="preserve">
          <source>The optional third element &lt;em&gt;field_shape&lt;/em&gt; contains the shape if this field represents an array of the data-type in the second element. Note that a 3-tuple with a third argument equal to 1 is equivalent to a 2-tuple.</source>
          <target state="translated">如果此字段表示第二个元素中的数据类型数组，则可选的第三个元素&lt;em&gt;field_shape&lt;/em&gt;包含形状。请注意，第三个参数等于1的3元组等效于2个元组。</target>
        </trans-unit>
        <trans-unit id="14b215bf63d4b571de67dcde3ac908fb35772330" translate="yes" xml:space="preserve">
          <source>The options &amp;lsquo;reduced&amp;rsquo;, &amp;lsquo;complete, and &amp;lsquo;raw&amp;rsquo; are new in numpy 1.8, see the notes for more information. The default is &amp;lsquo;reduced&amp;rsquo;, and to maintain backward compatibility with earlier versions of numpy both it and the old default &amp;lsquo;full&amp;rsquo; can be omitted. Note that array h returned in &amp;lsquo;raw&amp;rsquo; mode is transposed for calling Fortran. The &amp;lsquo;economic&amp;rsquo; mode is deprecated. The modes &amp;lsquo;full&amp;rsquo; and &amp;lsquo;economic&amp;rsquo; may be passed using only the first letter for backwards compatibility, but all others must be spelled out. See the Notes for more explanation.</source>
          <target state="translated">numpy 1.8中新增了&amp;ldquo; reduced&amp;rdquo;，&amp;ldquo; complete&amp;rdquo;和&amp;ldquo; raw&amp;rdquo;选项，有关更多信息，请参见注释。默认值是'reduced'，并且为了保持与numpy早期版本的向后兼容性，可以忽略它和旧的默认值'full'。请注意，以&amp;ldquo;原始&amp;rdquo;模式返回的数组h已转置以调用Fortran。不建议使用&amp;ldquo;经济&amp;rdquo;模式。为了向后兼容，可以仅使用第一个字母来传递&amp;ldquo;完全&amp;rdquo;和&amp;ldquo;经济&amp;rdquo;模式，但必须清楚说明所有其他模式。有关更多说明，请参见注释。</target>
        </trans-unit>
        <trans-unit id="6d9b2da0a0a7c1206d894d6f0fcce902e86c7458" translate="yes" xml:space="preserve">
          <source>The order in which the array data is stored in memory: &amp;lsquo;C&amp;rsquo; -&amp;gt; &amp;ldquo;row major&amp;rdquo; order (the default), &amp;lsquo;F&amp;rsquo; -&amp;gt; &amp;ldquo;column major&amp;rdquo; (Fortran) order.</source>
          <target state="translated">数组数据在内存中的存储顺序：&amp;ldquo; C&amp;rdquo;-&amp;gt;&amp;ldquo;行主要&amp;rdquo;顺序（默认），&amp;ldquo; F&amp;rdquo;-&amp;gt;&amp;ldquo;列主要&amp;rdquo;（Fortran）顺序。</target>
        </trans-unit>
        <trans-unit id="68929adbb771e5f9d5347a88dc7ca873ea9321af" translate="yes" xml:space="preserve">
          <source>The order in which they are preferred is determined by &lt;code&gt;NPY_BLAS_ILP64_ORDER&lt;/code&gt; and &lt;code&gt;NPY_LAPACK_ILP64_ORDER&lt;/code&gt; environment variables. The default value is &lt;code&gt;openblas64_,openblas_ilp64&lt;/code&gt;.</source>
          <target state="translated">首选它们的顺序由 &lt;code&gt;NPY_BLAS_ILP64_ORDER&lt;/code&gt; 和 &lt;code&gt;NPY_LAPACK_ILP64_ORDER&lt;/code&gt; 环境变量确定。默认值为 &lt;code&gt;openblas64_,openblas_ilp64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e18fbd568fd064406da176fc5bb0b9a80dc8baa0" translate="yes" xml:space="preserve">
          <source>The order of &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; doesn&amp;rsquo;t matter.</source>
          <target state="translated">&lt;code&gt;v1&lt;/code&gt; 和 &lt;code&gt;v2&lt;/code&gt; 的顺序无关紧要。</target>
        </trans-unit>
        <trans-unit id="64c7894d7cfcaaec3478ec1e4aaf0c4a01f8cc6f" translate="yes" xml:space="preserve">
          <source>The order of sub-arrays is changed but their contents remains the same.</source>
          <target state="translated">子数组的顺序被改变,但其内容保持不变。</target>
        </trans-unit>
        <trans-unit id="1d4e69a308201075218d8a094df1f5f1f4d37aad" translate="yes" xml:space="preserve">
          <source>The order of the elements in the array resulting from ravel() is normally &amp;ldquo;C-style&amp;rdquo;, that is, the rightmost index &amp;ldquo;changes the fastest&amp;rdquo;, so the element after a[0,0] is a[0,1]. If the array is reshaped to some other shape, again the array is treated as &amp;ldquo;C-style&amp;rdquo;. NumPy normally creates arrays stored in this order, so ravel() will usually not need to copy its argument, but if the array was made by taking slices of another array or created with unusual options, it may need to be copied. The functions ravel() and reshape() can also be instructed, using an optional argument, to use FORTRAN-style arrays, in which the leftmost index changes the fastest.</source>
          <target state="translated">由ravel（）得出的数组中元素的顺序通常为&amp;ldquo; C样式&amp;rdquo;，即最右边的索引&amp;ldquo;更改最快&amp;rdquo;，因此a [0,0]之后的元素为a [0,1] 。如果将数组重塑为其他形状，则再次将数组视为&amp;ldquo; C样式&amp;rdquo;。 NumPy通常按此顺序创建存储的数组，因此ravel（）通常不需要复制其参数，但是如果该数组是通过对另一个数组的切片进行分割或使用非常规选项创建的，则可能需要复制它。还可以使用可选参数指示函数ravel（）和reshape（）使用FORTRAN样式的数组，其中最左边的索引更改最快。</target>
        </trans-unit>
        <trans-unit id="1a665b347299d28c9a4225cbaa35961f7257fdf3" translate="yes" xml:space="preserve">
          <source>The order of the input bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011 =&amp;gt; ``, 'little' will
reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="translated">输入位的顺序。'big'将模拟bin（val）， &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011 =&amp;gt; ``, 'little' will reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt; 。默认为&amp;ldquo;大&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6a7badf2486ba3d65f6d452504aadca6f59aa17f" translate="yes" xml:space="preserve">
          <source>The order of the input bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011&lt;/code&gt;, &amp;lsquo;little&amp;rsquo; will reverse the order so &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="translated">输入位的顺序。'big'将模拟bin（val）， &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011&lt;/code&gt; ，'little'将颠倒顺序，因此 &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt; 1、1、0、0 ， 0，0，0，0] =&amp;gt; 3。默认为&amp;ldquo;大&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="284166d21f55654af6d0a1aecc95d3581a64b2f4" translate="yes" xml:space="preserve">
          <source>The order of the requsted optimizations doesn&amp;rsquo;t matter.</source>
          <target state="translated">所需优化的顺序无关紧要。</target>
        </trans-unit>
        <trans-unit id="c023a0582544690f15510a2492956e0e66cdc058" translate="yes" xml:space="preserve">
          <source>The order of the returned bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;3 = 0b00000011 =&amp;gt; [0, 0, 0, 0, 0, 0, 1, 1]&lt;/code&gt;, &amp;lsquo;little&amp;rsquo; will reverse the order to &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0]&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="translated">返回位的顺序。'big'将模拟bin（val）， &lt;code&gt;3 = 0b00000011 =&amp;gt; [0, 0, 0, 0, 0, 0, 1, 1]&lt;/code&gt; ，'little'将顺序反转为 &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0]&lt;/code&gt; 1，1，0，0 ， 0，0，0，0]。默认为&amp;ldquo;大&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d31a5b9999b59b34b6ad9fdaccda217e19238ad4" translate="yes" xml:space="preserve">
          <source>The order or degree of the polynomial</source>
          <target state="translated">多项式的阶数或度数。</target>
        </trans-unit>
        <trans-unit id="eea06a8f88d6f17386cd112eab18c7ac9fc8e799" translate="yes" xml:space="preserve">
          <source>The orientation of &lt;code&gt;c&lt;/code&gt; can be changed using the &lt;code&gt;axisc&lt;/code&gt; keyword.</source>
          <target state="translated">可以使用 &lt;code&gt;axisc&lt;/code&gt; 关键字更改 &lt;code&gt;c&lt;/code&gt; 的方向。</target>
        </trans-unit>
        <trans-unit id="f6895b0ec7c91fa01ba724c0454c0ecbf9046ad1" translate="yes" xml:space="preserve">
          <source>The original contents of the &lt;code&gt;intent(in)&lt;/code&gt; argument may be altered by the Fortran/C function. F2PY creates an optional argument &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; with the default value &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">可以通过Fortran / C函数更改 &lt;code&gt;intent(in)&lt;/code&gt; 参数的原始内容。F2PY创建一个可选参数 &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; ，其默认值为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b2e34a61895054c86583de1c9f28efb1bf046c4" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;coef&lt;/code&gt; attribute.</source>
          <target state="translated">另一个类必须具有 &lt;code&gt;coef&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="beffd1aec86565c0ed7e85fa9756b03e99dc1093" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;domain&lt;/code&gt; attribute.</source>
          <target state="translated">另一个类必须具有 &lt;code&gt;domain&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="c7b5b660115b8d1bff6ffdc35071c1bc977b44f5" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;window&lt;/code&gt; attribute.</source>
          <target state="translated">另一个类必须具有 &lt;code&gt;window&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="208270eb05b02b535197d000879d544f3abebcde" translate="yes" xml:space="preserve">
          <source>The out argument specifies where to place the result. If out is NULL, then the output array is created, otherwise the output is placed in out which must be the correct size and type. A new reference to the output array is always returned even when out is not NULL. The caller of the routine has the responsibility to &lt;code&gt;DECREF&lt;/code&gt; out if not NULL or a memory-leak will occur.</source>
          <target state="translated">out参数指定放置结果的位置。如果out为NULL，则创建输出数组，否则将输出放置在out中，该大小和类型必须正确。即使out不为NULL，也会始终返回对输出数组的新引用。如果不是NULL，否则例程的调用者有责任进行 &lt;code&gt;DECREF&lt;/code&gt; 输出，否则将发生内存泄漏。</target>
        </trans-unit>
        <trans-unit id="b1eb4436c2a0a0542bae9d8ee0693add2fca6bb8" translate="yes" xml:space="preserve">
          <source>The out argument specifies where to place the result. If out is NULL, then the output array is created, otherwise the output is placed in out which must be the correct size and type. A new reference to the output array is always returned even when out is not NULL. The caller of the routine has the responsibility to &lt;code&gt;Py_DECREF&lt;/code&gt; out if not NULL or a memory-leak will occur.</source>
          <target state="translated">out参数指定将结果放置在何处。如果out为NULL，则创建输出数组，否则将输出放置在out中，该输出必须是正确的大小和类型。即使out不为NULL，也会始终返回对输出数组的新引用。如果不为NULL，否则例程的调用者有责任将 &lt;code&gt;Py_DECREF&lt;/code&gt; 输出，否则将发生内存泄漏。</target>
        </trans-unit>
        <trans-unit id="d41934f2889307f51eefc25e7532b745714248c8" translate="yes" xml:space="preserve">
          <source>The outer product</source>
          <target state="translated">外围产品</target>
        </trans-unit>
        <trans-unit id="6a7d17b343c508aa5b0fa2c069711cc8be41d2b5" translate="yes" xml:space="preserve">
          <source>The output arguments (if any) are then processed and any missing return arrays are constructed. If any provided output array doesn&amp;rsquo;t have the correct type (or is mis-aligned) and is smaller than the buffer size, then a new output array is constructed with the special &lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set. At the end of the function, &lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called so that its contents will be copied back into the output array. Iterators for the output arguments are then processed.</source>
          <target state="translated">然后处理输出参数（如果有），并构造所有丢失的返回数组。如果提供的任何输出数组的类型不正确（或未对齐）并且小于缓冲区大小，则将使用特殊的&lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;标志设置构造一个新的输出数组。在该函数的末尾，将调用&lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;，以便将其内容复制回输出数组中。然后处理输出参数的迭代器。</target>
        </trans-unit>
        <trans-unit id="eaacd893fa91168722bb422e1bd4cfd1660e87de" translate="yes" xml:space="preserve">
          <source>The output arguments (if any) are then processed and any missing return arrays are constructed. If any provided output array doesn&amp;rsquo;t have the correct type (or is mis-aligned) and is smaller than the buffer size, then a new output array is constructed with the special &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag set. At the end of the function, &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called so that its contents will be copied back into the output array. Iterators for the output arguments are then processed.</source>
          <target state="translated">然后处理输出参数（如果有），并构造所有丢失的返回数组。如果提供的任何输出数组的类型不正确（或未对齐）且小于缓冲区大小，则将使用特殊的 &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; 标志设置新的输出数组。在函数的末尾，将调用&lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;，以便将其内容复制回输出数组。然后处理输出参数的迭代器。</target>
        </trans-unit>
        <trans-unit id="02fbb66d65f083fd2d9e7a738b5f72feedd2f131" translate="yes" xml:space="preserve">
          <source>The output arguments (if any) are then processed and any missing return arrays are constructed. If any provided output array doesn&amp;rsquo;t have the correct type (or is mis-aligned) and is smaller than the buffer size, then a new output array is constructed with the special &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag set. At the end of the function, &lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called so that its contents will be copied back into the output array. Iterators for the output arguments are then processed.</source>
          <target state="translated">然后处理输出参数（如果有），并构造所有丢失的返回数组。如果提供的任何输出数组的类型不正确（或未对齐）并且小于缓冲区大小，则将使用特殊的 &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; 标志设置一个新的输出数组。在该函数的末尾，将调用&lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;，以便将其内容复制回输出数组中。然后处理输出参数的迭代器。</target>
        </trans-unit>
        <trans-unit id="f268497aae1cce8ff8c25da79f231196a245eaac" translate="yes" xml:space="preserve">
          <source>The output array is masked where all the values along the given axis are masked: if the output would have been a scalar and that all the values are masked, then the output is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">输出数组被屏蔽，沿给定轴的所有值都被屏蔽：如果输出将是标量并且所有值都被屏蔽，则输出被&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb5ec377d841d6a8ac376aa017bca95b2c7ad6a2" translate="yes" xml:space="preserve">
          <source>The output array is masked where all the values along the given axis are masked: if the output would have been a scalar and that all the values are masked, then the output is &lt;code&gt;masked&lt;/code&gt;.</source>
          <target state="translated">输出数组被屏蔽，其中沿给定轴的所有值都被屏蔽：如果输出将是标量并且所有值都被屏蔽，则输出被 &lt;code&gt;masked&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cdd30a82881324958754cfed2ed5012e49b5922" translate="yes" xml:space="preserve">
          <source>The output array of type Boolean with the same shape as a and b.</source>
          <target state="translated">形状与a、b相同的布尔类型的输出数组。</target>
        </trans-unit>
        <trans-unit id="f55976ddc6094b99d81ee9f07a8be602a3926550" translate="yes" xml:space="preserve">
          <source>The output array, containing the part of the content of &lt;code&gt;file&lt;/code&gt; that was matched by &lt;code&gt;regexp&lt;/code&gt;. &lt;code&gt;output&lt;/code&gt; is always a structured array.</source>
          <target state="translated">输出数组，包含与 &lt;code&gt;regexp&lt;/code&gt; 匹配的 &lt;code&gt;file&lt;/code&gt; 内容的一部分。 &lt;code&gt;output&lt;/code&gt; 始终是结构化数组。</target>
        </trans-unit>
        <trans-unit id="5aa2c29b27cf9fdf4a29996c1b8c28730e8e0aea" translate="yes" xml:space="preserve">
          <source>The output array, element-wise Heaviside step function of &lt;code&gt;x1&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">输出数组 &lt;code&gt;x1&lt;/code&gt; 的逐个元素Heaviside步进函数。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="70719ba0effebe3bb3aa417f56a4a6c01822a6e7" translate="yes" xml:space="preserve">
          <source>The output array.</source>
          <target state="translated">输出阵列。</target>
        </trans-unit>
        <trans-unit id="09c7e58e3fd89577e8de606a001975293d749592" translate="yes" xml:space="preserve">
          <source>The output array. The number of dimensions is the same as &lt;code&gt;a&lt;/code&gt;, but the shape can be different. This depends on whether &lt;code&gt;func&lt;/code&gt; changes the shape of its output with respect to its input.</source>
          <target state="translated">输出数组。维数是相同的 &lt;code&gt;a&lt;/code&gt; ，但是其形状可以是不同的。这取决于 &lt;code&gt;func&lt;/code&gt; 是否相对于输入改变其输出的形状。</target>
        </trans-unit>
        <trans-unit id="d041e4d25d02f826463aa1a16a95e06fcf896235" translate="yes" xml:space="preserve">
          <source>The output array. The shape of &lt;code&gt;out&lt;/code&gt; is identical to the shape of &lt;code&gt;arr&lt;/code&gt;, except along the &lt;code&gt;axis&lt;/code&gt; dimension. This axis is removed, and replaced with new dimensions equal to the shape of the return value of &lt;code&gt;func1d&lt;/code&gt;. So if &lt;code&gt;func1d&lt;/code&gt; returns a scalar &lt;code&gt;out&lt;/code&gt; will have one fewer dimensions than &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">输出数组。的形状 &lt;code&gt;out&lt;/code&gt; 相同的形状 &lt;code&gt;arr&lt;/code&gt; ，除了沿所述 &lt;code&gt;axis&lt;/code&gt; 的维度。删除该轴，并用等于 &lt;code&gt;func1d&lt;/code&gt; 返回值形状的新尺寸替换。因此，如果 &lt;code&gt;func1d&lt;/code&gt; 返回标量 &lt;code&gt;out&lt;/code&gt; 则其尺寸比 &lt;code&gt;arr&lt;/code&gt; 少一。</target>
        </trans-unit>
        <trans-unit id="8620240fb2ec2168fe1488fc7c50d1b1766a372e" translate="yes" xml:space="preserve">
          <source>The output at position m is the m-th element of the array in &lt;code&gt;choicelist&lt;/code&gt; where the m-th element of the corresponding array in &lt;code&gt;condlist&lt;/code&gt; is True.</source>
          <target state="translated">在位置m的输出是第m个所述阵列的在元件 &lt;code&gt;choicelist&lt;/code&gt; ，其中在相应的阵列的第m个元素 &lt;code&gt;condlist&lt;/code&gt; 为True。</target>
        </trans-unit>
        <trans-unit id="0043f09ea13cb649da8f2d6d2895f2519551c732" translate="yes" xml:space="preserve">
          <source>The output data type. It must be specified as either a string of typecode characters or a list of data type specifiers. There should be one data type specifier for each output.</source>
          <target state="translated">输出数据类型。必须将其指定为一串类型代码字符或数据类型指定器列表。每个输出都应该有一个数据类型指定器。</target>
        </trans-unit>
        <trans-unit id="abacf3469f99309139bddd0efe494fc74e079f06" translate="yes" xml:space="preserve">
          <source>The output has the same shape as the input and each 1-D loop operates over</source>
          <target state="translated">输出的形状与输入的形状相同,每个1-D环路工作在</target>
        </trans-unit>
        <trans-unit id="63770907dcff4eb26363f61fd3098799f014e4b4" translate="yes" xml:space="preserve">
          <source>The output is a &lt;a href=&quot;https://docs.python.org/dev/tutorial/datastructures.html#tut-tuples&quot;&gt;tuple&lt;/a&gt; with three elements, which means that this is a three-dimensional array. In fact, since this is a color image, and we have used the &lt;code&gt;imread&lt;/code&gt; function to read it, the data is organized in three 2D arrays, representing color channels (in this case, red, green and blue - RGB). You can see this by looking at the shape above: it indicates that we have an array of 3 matrices, each having shape 768x1024.</source>
          <target state="translated">输出是具有三个元素的&lt;a href=&quot;https://docs.python.org/dev/tutorial/datastructures.html#tut-tuples&quot;&gt;元组&lt;/a&gt;，这意味着这是三维数组。实际上，由于这是彩色图像，并且我们使用了 &lt;code&gt;imread&lt;/code&gt; 函数来读取它，所以数据以三个2D数组进行组织，代表了彩色通道（在这种情况下，是红色，绿色和蓝色-RGB）。您可以通过查看上面的形状来看到这一点：它表示我们有3个矩阵的数组，每个矩阵的形状为768x1024。</target>
        </trans-unit>
        <trans-unit id="2e90afe5c10bc3b541c84caa9141acf978817abb" translate="yes" xml:space="preserve">
          <source>The output is left-padded by the length of the prefix string, and wrapping is forced at the column &lt;code&gt;max_line_width - len(suffix)&lt;/code&gt;. It should be noted that the content of prefix and suffix strings are not included in the output.</source>
          <target state="translated">输出用前缀字符串的长度左填充，并在 &lt;code&gt;max_line_width - len(suffix)&lt;/code&gt; 列处强制换行。应该注意的是，前缀和后缀字符串的内容不包含在输出中。</target>
        </trans-unit>
        <trans-unit id="e11dba8a2e35e34ff280ff12d3cc6c9a772a17ab" translate="yes" xml:space="preserve">
          <source>The output is sorted along the key.</source>
          <target state="translated">输出的结果是沿键排序的。</target>
        </trans-unit>
        <trans-unit id="8da09507a5558a4c68826bbfbad5a55048ee486a" translate="yes" xml:space="preserve">
          <source>The output is the same shape and type as x and is found by calling the functions in &lt;code&gt;funclist&lt;/code&gt; on the appropriate portions of &lt;code&gt;x&lt;/code&gt;, as defined by the boolean arrays in &lt;code&gt;condlist&lt;/code&gt;. Portions not covered by any condition have a default value of 0.</source>
          <target state="translated">输出是相同的形状和类型，x和通过调用在功能发现 &lt;code&gt;funclist&lt;/code&gt; 上的适当部分 &lt;code&gt;x&lt;/code&gt; ，由布尔数组定义 &lt;code&gt;condlist&lt;/code&gt; 。任何条件未涵盖的部分的默认值为0。</target>
        </trans-unit>
        <trans-unit id="f50dbb1c407bc1480ac12746928854d5651c29cc" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;argwhere&lt;/code&gt; is not suitable for indexing arrays. For this purpose use &lt;code&gt;nonzero(a)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;argwhere&lt;/code&gt; 的输出不适用于索引数组。为此，请改用 &lt;code&gt;nonzero(a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f4440d892c3898fd91df0e56df25108b1e0bf3c" translate="yes" xml:space="preserve">
          <source>The output of the ufunc (and its methods) is not necessarily an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if all input arguments are not &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. Indeed, if any input defines an &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, control will be passed completely to that function, i.e., the ufunc is &lt;a href=&quot;#ufuncs-overrides&quot;&gt;overridden&lt;/a&gt;.</source>
          <target state="translated">如果所有输入参数都不是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; s&lt;/a&gt;，则ufunc（及其方法）的输出不一定是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;。实际上，如果任何输入定义了&lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;方法，则控制将完全传递给该函数，即ufunc被&lt;a href=&quot;#ufuncs-overrides&quot;&gt;覆盖&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9cad5509a2704fc8189ddac84d202e22c4e895ee" translate="yes" xml:space="preserve">
          <source>The output of the ufunc (and its methods) is not necessarily an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if all input arguments are not &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. Indeed, if any input defines an &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, control will be passed completely to that function, i.e., the ufunc is &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/ufuncs.overrides&quot;&gt;overridden&lt;/a&gt;.</source>
          <target state="translated">如果所有输入参数都不是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; s&lt;/a&gt;，则ufunc（及其方法）的输出不一定是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;。实际上，如果任何输入定义了&lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;方法，则控制将完全传递给该函数，即ufunc被&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/ufuncs.overrides&quot;&gt;覆盖&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6599e81d2d214234687adf6fb69ac2c773f47b7b" translate="yes" xml:space="preserve">
          <source>The output of the ufunc (and its methods) is not necessarily an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if all input arguments are not &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. Indeed, if any input defines an &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, control will be passed completely to that function, i.e., the ufunc is &lt;a href=&quot;https://numpy.org/doc/1.19/reference/ufuncs.overrides&quot;&gt;overridden&lt;/a&gt;.</source>
          <target state="translated">如果所有输入参数都不是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; s&lt;/a&gt;，则ufunc（及其方法）的输出不一定是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;。实际上，如果任何输入定义了&lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;方法，则控制将完全传递给该函数，即ufunc被&lt;a href=&quot;https://numpy.org/doc/1.19/reference/ufuncs.overrides&quot;&gt;覆盖&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dffd3ba3dd5dfca8ee836a2b9bb97cc8318013a0" translate="yes" xml:space="preserve">
          <source>The output shape in the dense case is obtained by prepending the number of dimensions in front of the tuple of dimensions, i.e. if &lt;code&gt;dimensions&lt;/code&gt; is a tuple &lt;code&gt;(r0, ..., rN-1)&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the output shape is &lt;code&gt;(N, r0, ..., rN-1)&lt;/code&gt;.</source>
          <target state="translated">在密集情况下，输出形状是通过在维数元组前面添加维数而获得的，即，如果 &lt;code&gt;dimensions&lt;/code&gt; 是长度为 &lt;code&gt;N&lt;/code&gt; 的元组 &lt;code&gt;(r0, ..., rN-1)&lt;/code&gt; ，则输出形状为 &lt;code&gt;(N, r0, ..., rN-1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b58a2d32420f4e758be11c792f006660e86c89ee" translate="yes" xml:space="preserve">
          <source>The output type is determined by evaluating the first element of the input, unless it is specified:</source>
          <target state="translated">除非指定了输出类型,否则输出类型是通过评估输入的第一个元素来确定的。</target>
        </trans-unit>
        <trans-unit id="9fa5a7d08b947585ca82353fe9713958d5e25120" translate="yes" xml:space="preserve">
          <source>The output, analogously to &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, contains the term for zero frequency in the low-order corner of all axes, the positive frequency terms in the first half of all axes, the term for the Nyquist frequency in the middle of all axes and the negative frequency terms in the second half of all axes, in order of decreasingly negative frequency.</source>
          <target state="translated">与&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;类似，输出包含所有轴低阶角中的零频率项，所有轴前半部中的正频率项，所有轴中部的奈奎斯特频率项和负值。频率项在所有轴的后半部分中按负频率递减的顺序排列。</target>
        </trans-unit>
        <trans-unit id="810deb62d102585296e67e3c187bb792f35878ab" translate="yes" xml:space="preserve">
          <source>The output, analogously to &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, contains the term for zero frequency in the low-order corner of the transformed axes, the positive frequency terms in the first half of these axes, the term for the Nyquist frequency in the middle of the axes and the negative frequency terms in the second half of the axes, in order of decreasingly negative frequency.</source>
          <target state="translated">输出类似于&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;，在转换轴的低阶角包含零频率项，在这些轴的前半部分包含正频率项，在轴的中间包含奈奎斯特频率项，并且负频率项位于轴的后半部，按负频率递减的顺序排列。</target>
        </trans-unit>
        <trans-unit id="a8b2e53b333d791e589c426b13ebb877541abc09" translate="yes" xml:space="preserve">
          <source>The output, analogously to &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, contains the term for zero frequency in the low-order corner of all axes, the positive frequency terms in the first half of all axes, the term for the Nyquist frequency in the middle of all axes and the negative frequency terms in the second half of all axes, in order of decreasingly negative frequency.</source>
          <target state="translated">与&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;类似，输出包含所有轴低阶角中的零频率项，所有轴前半部中的正频率项，所有轴中部的奈奎斯特频率项和负值。频率项在所有轴的后一半中按负频率递减的顺序排列。</target>
        </trans-unit>
        <trans-unit id="2e04271603cd70e84ef996c185fb1fb3c75eb84c" translate="yes" xml:space="preserve">
          <source>The output, analogously to &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, contains the term for zero frequency in the low-order corner of the transformed axes, the positive frequency terms in the first half of these axes, the term for the Nyquist frequency in the middle of the axes and the negative frequency terms in the second half of the axes, in order of decreasingly negative frequency.</source>
          <target state="translated">输出类似于&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;，在转换轴的低阶角包含零频率项，在这些轴的前半部分包含正频率项，在轴的中间包含奈奎斯特频率项，并且负频率项位于轴的后半部，按负频率递减的顺序排列。</target>
        </trans-unit>
        <trans-unit id="ed35a4029927607a6ec8e44ffef5c4477bb8a981" translate="yes" xml:space="preserve">
          <source>The package ensures that masked entries are not used in computations.</source>
          <target state="translated">该包确保在计算中不使用掩码的条目。</target>
        </trans-unit>
        <trans-unit id="f6f78aee1988dc701d01aad263b1da5166d3a53f" translate="yes" xml:space="preserve">
          <source>The padding character to use (default is space).</source>
          <target state="translated">要使用的填充字符(默认为空格)。</target>
        </trans-unit>
        <trans-unit id="7e8fe55b063cd4163ba4aeac13d68612e9f5d53b" translate="yes" xml:space="preserve">
          <source>The padding function, if used, should modify a rank 1 array in-place. It has the following signature:</source>
          <target state="translated">如果使用padding函数,应该就地修改rank 1数组。它的签名如下:</target>
        </trans-unit>
        <trans-unit id="91842f7bb32c0502ac19c7e4e8ff23d234b3cdfd" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;oa_ndim&lt;/code&gt;, when not zero or -1, specifies the number of dimensions that will be iterated with customized broadcasting. If it is provided, &lt;code&gt;op_axes&lt;/code&gt; must and &lt;code&gt;itershape&lt;/code&gt; can also be provided. The &lt;code&gt;op_axes&lt;/code&gt; parameter let you control in detail how the axes of the operand arrays get matched together and iterated. In &lt;code&gt;op_axes&lt;/code&gt;, you must provide an array of &lt;code&gt;nop&lt;/code&gt; pointers to &lt;code&gt;oa_ndim&lt;/code&gt;-sized arrays of type &lt;code&gt;npy_intp&lt;/code&gt;. If an entry in &lt;code&gt;op_axes&lt;/code&gt; is NULL, normal broadcasting rules will apply. In &lt;code&gt;op_axes[j][i]&lt;/code&gt; is stored either a valid axis of &lt;code&gt;op[j]&lt;/code&gt;, or -1 which means &lt;code&gt;newaxis&lt;/code&gt;. Within each &lt;code&gt;op_axes[j]&lt;/code&gt; array, axes may not be repeated. The following example is how normal broadcasting applies to a 3-D array, a 2-D array, a 1-D array and a scalar.</source>
          <target state="translated">参数 &lt;code&gt;oa_ndim&lt;/code&gt; 不为零或-1时，将指定将使用自定义广播进行迭代的维数。如果提供， &lt;code&gt;op_axes&lt;/code&gt; 必须提供op_axes并且 &lt;code&gt;itershape&lt;/code&gt; 。该 &lt;code&gt;op_axes&lt;/code&gt; 参数让你在细节控制操作阵列的轴是如何被匹配在一起，并重复。在 &lt;code&gt;op_axes&lt;/code&gt; ，必须提供的阵列 &lt;code&gt;nop&lt;/code&gt; 指针 &lt;code&gt;oa_ndim&lt;/code&gt; 类型的尺度的阵列 &lt;code&gt;npy_intp&lt;/code&gt; 。如果 &lt;code&gt;op_axes&lt;/code&gt; 中的条目为NULL，则将应用常规广播规则。在 &lt;code&gt;op_axes[j][i]&lt;/code&gt; 中存储的是 &lt;code&gt;op[j]&lt;/code&gt; 的有效轴或-1，这意味着 &lt;code&gt;newaxis&lt;/code&gt; 。在每个 &lt;code&gt;op_axes[j]&lt;/code&gt; 数组内，不得重复轴。以下示例是普通广播如何应用于3-D阵列，2-D阵列，1-D阵列和标量的示例。</target>
        </trans-unit>
        <trans-unit id="6f24110e4501ed427c7d67150722a36e47c9eb87" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;x&lt;/code&gt; is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either &lt;code&gt;x&lt;/code&gt; or its elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">仅当 &lt;code&gt;x&lt;/code&gt; 是元组或列表时，参数x才会转换为数组，否则将被视为标量。无论哪种情况， &lt;code&gt;x&lt;/code&gt; 或其元素都必须支持自身和 &lt;code&gt;c&lt;/code&gt; 元素的乘法和加法。</target>
        </trans-unit>
        <trans-unit id="81b1fc95a0e75fbef51d185592084c9ff4aaba4c" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;x&lt;/code&gt; is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either &lt;code&gt;x&lt;/code&gt; or its elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">仅当参数 &lt;code&gt;x&lt;/code&gt; 是元组或列表时，参数x才会转换为数组，否则将其视为标量。无论哪种情况， &lt;code&gt;x&lt;/code&gt; 或其元素都必须支持自身和 &lt;code&gt;r&lt;/code&gt; 元素的乘法和加法。</target>
        </trans-unit>
        <trans-unit id="fed3e36a151b3d1051d8c0d0e63efcd30243f871" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;dtype&lt;/em&gt; specifies the data type over which a reduction operation (like summing) should take place. The default reduce data type is the same as the data type of &lt;em&gt;self&lt;/em&gt;. To avoid overflow, it can be useful to perform the reduction using a larger data type.</source>
          <target state="translated">参数&lt;em&gt;dtype&lt;/em&gt;指定应在其上进行归约运算（如求和）的数据类型。默认的reduce数据类型与&lt;em&gt;self&lt;/em&gt;的数据类型相同。为避免溢出，使用较大的数据类型执行还原操作可能很有用。</target>
        </trans-unit>
        <trans-unit id="5047704927c94b8b6586c636aa20a6789550df01" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars and they must have the same shape after conversion. In either case, either &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">仅当参数 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是元组或列表时，它们才会转换为数组，否则它们将被视为标量，并且转换后必须具有相同的形状。无论哪种情况， &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 或它们的元素都必须支持自身和 &lt;code&gt;c&lt;/code&gt; 元素的乘法和加法。</target>
        </trans-unit>
        <trans-unit id="ab30d7deae7ce08d9cafc57f0a0d9da22b443d75" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars. In either case, either &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">仅当参数 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是元组或列表时，它们才会转换为数组，否则将它们视为标量。无论哪种情况， &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 或它们的元素都必须支持自身和 &lt;code&gt;c&lt;/code&gt; 元素的乘法和加法。</target>
        </trans-unit>
        <trans-unit id="dea737cd6cbb9eb4fabc09fa179fafbb398a4ba4" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars and they must have the same shape after conversion. In either case, either &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 仅当它们是元组或列表时才转换为数组，否则将它们视为标量，并且转换后它们必须具有相同的形状。在任何一种情况下， &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 或其元素必须支持自身和 &lt;code&gt;c&lt;/code&gt; 元素的乘法和加法。</target>
        </trans-unit>
        <trans-unit id="942247face18dfe9d547bf9f163892321bfcd347" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars. In either case, either &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 仅在它们是元组或列表时才转换为数组，否则将它们视为标量。在任何一种情况下， &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 或其元素必须支持自身和 &lt;code&gt;c&lt;/code&gt; 元素的乘法和加法。</target>
        </trans-unit>
        <trans-unit id="2f059fed0e631d6e93c76ef517cee1b4493e82a4" translate="yes" xml:space="preserve">
          <source>The path of the template, relatively to the current package path.</source>
          <target state="translated">相对于当前包的路径,模板的路径。</target>
        </trans-unit>
        <trans-unit id="a3bed8bc2ca97f198b6eb9b3e908d4ed3c7c443d" translate="yes" xml:space="preserve">
          <source>The path to the file for which the doctests are run.</source>
          <target state="translated">运行doctests的文件路径。</target>
        </trans-unit>
        <trans-unit id="decb24fde62e2b923b5a976163e8c054497d68bf" translate="yes" xml:space="preserve">
          <source>The pattern for using nested iterators is as follows.</source>
          <target state="translated">使用嵌套迭代器的模式如下。</target>
        </trans-unit>
        <trans-unit id="9db61e58e4763f03cd16195e5ed8a40825c96961" translate="yes" xml:space="preserve">
          <source>The pattern is similar for other, more complex generators. The normal performance of the legacy &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; generator is much lower than the other since it uses the Box-Muller transformation rather than the Ziggurat generator. The performance gap for Exponentials is also large due to the cost of computing the log function to invert the CDF. The column labeled MT19973 is used the same 32-bit generator as &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; but produces random values using &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于其他更复杂的生成器，此模式相似。遗留的&lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;生成器的正常性能比其他生成器低得多，因为它使用Box-Muller变换而不是Ziggurat生成器。由于计算log函数以反转CDF的成本，因此指数的性能差距也很大。标记MT19973该柱所用的相同的32位发生器作为&lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;但产生使用随机值&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82eacc753e4241f8676568f6609cbd6d30cfc9ba" translate="yes" xml:space="preserve">
          <source>The pattern is similar for other, more complex generators. The normal performance of the legacy &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; generator is much lower than the other since it uses the Box-Muller transformation rather than the Ziggurat generator. The performance gap for Exponentials is also large due to the cost of computing the log function to invert the CDF. The column labeled MT19973 is used the same 32-bit generator as &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; but produces random values using &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于其他更复杂的生成器，此模式相似。传统的&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;生成器的正常性能比其他类型的低得多，因为它使用Box-Muller变换而不是Ziggurat生成器。由于计算log函数以反转CDF的成本，指数的性能差距也很大。标记MT19973该柱所用的相同的32位发生器作为&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;但产生使用随机值&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f948cd9daa190278b24b7616c4acaf6e82e63af" translate="yes" xml:space="preserve">
          <source>The payment is computed by solving the equation:</source>
          <target state="translated">通过解方程计算支付。</target>
        </trans-unit>
        <trans-unit id="7c38a52dfb1124cf95fad23836990fb2bf0bbca3" translate="yes" xml:space="preserve">
          <source>The percentage of waves larger than 3 meters is:</source>
          <target state="translated">波浪大于3米的比例是。</target>
        </trans-unit>
        <trans-unit id="bf26c5d0de790b76d482846fdfc7d5a573504f09" translate="yes" xml:space="preserve">
          <source>The performance of 64-bit generators on 32-bit Windows is much lower than on 64-bit operating systems due to register width. MT19937, the generator that has been in NumPy since 2005, operates on 32-bit integers.</source>
          <target state="translated">由于寄存器宽度的原因,64位生成器在32位Windows上的性能远低于64位操作系统。NumPy中自2005年开始的生成器MT19937,在32位整数上运行。</target>
        </trans-unit>
        <trans-unit id="02f4c7c728252209e49cade8944d95bdb15fb9ef" translate="yes" xml:space="preserve">
          <source>The place in the code corresponding to the actual computations for the ufunc are marked with /*BEGIN main ufunc computation*/ and /*END main ufunc computation*/. The code in between those lines is the primary thing that must be changed to create your own ufunc.</source>
          <target state="translated">代码中与ufunc实际计算相对应的地方用/*BEGIN main ufunc computation*/和/*END main ufunc computation*/来标记。这两行之间的代码是创建自己的ufunc所必须修改的主要内容。</target>
        </trans-unit>
        <trans-unit id="e0a72aed7747ec5b4e706a7296ecd1eb9faae060" translate="yes" xml:space="preserve">
          <source>The places in the code corresponding to the actual computations for the ufunc are marked with /*BEGIN main ufunc computation*/ and /*END main ufunc computation*/. The code in between those lines is the primary thing that must be changed to create your own ufunc.</source>
          <target state="translated">代码中与ufunc实际计算相对应的地方用**BEGIN main ufunc computation*/和**END main ufunc computation*/标记。这两行之间的代码是创建你自己的ufunc所必须修改的主要内容。</target>
        </trans-unit>
        <trans-unit id="4a5ee23f497e38c29e0616fdcc0bb0ea7d4426f2" translate="yes" xml:space="preserve">
          <source>The points about sequence size and speed are particularly important in scientific computing. As a simple example, consider the case of multiplying each element in a 1-D sequence with the corresponding element in another sequence of the same length. If the data are stored in two Python lists, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, we could iterate over each element:</source>
          <target state="translated">关于序列大小和速度的要点在科学计算中尤为重要。举一个简单的例子，考虑将一维序列中的每个元素与相同长度的另一序列中的对应元素相乘的情况。如果数据存储在两个Python列表 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 中，我们可以遍历每个元素：</target>
        </trans-unit>
        <trans-unit id="0779c65ec163a12759193f89f82723f01bb394dd" translate="yes" xml:space="preserve">
          <source>The polynomial coefficients</source>
          <target state="translated">多项式系数</target>
        </trans-unit>
        <trans-unit id="daaa36d42f5e3da309c9eab093a92efe7a0076ca" translate="yes" xml:space="preserve">
          <source>The polynomial convenience classes cannot be passed to ufuncs</source>
          <target state="translated">多项式方便类不能传递给ufuncs。</target>
        </trans-unit>
        <trans-unit id="b9ed1328025571c1195a04bff5fdf98ece032c1f" translate="yes" xml:space="preserve">
          <source>The polynomial resulting from the multiplication of the inputs. If either inputs is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</source>
          <target state="translated">输入与输出相乘后的多项式。如果任何一个输入是一个多项式对象,那么输出也是一个多项式对象。否则,它是一个从高到低的多项式系数的1D数组。</target>
        </trans-unit>
        <trans-unit id="515cfb6ef96288d03850b077c1e2ea4a5a576f0e" translate="yes" xml:space="preserve">
          <source>The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used.</source>
          <target state="translated">多项式数列类型的类,当前实例应该转换到哪个类。如果种类为None,则使用当前实例的类。</target>
        </trans-unit>
        <trans-unit id="75f7f784e98730c24c6aac1a9a0a155ec4addf47" translate="yes" xml:space="preserve">
          <source>The polynomial&amp;rsquo;s coefficients, in decreasing powers, or if the value of the second parameter is True, the polynomial&amp;rsquo;s roots (values where the polynomial evaluates to 0). For example, &lt;code&gt;poly1d([1, 2, 3])&lt;/code&gt; returns an object that represents</source>
          <target state="translated">多项式的系数，以递减的幂表示，或者第二个参数的值为True时，表示多项式的根（多项式的值为0的值）。例如， &lt;code&gt;poly1d([1, 2, 3])&lt;/code&gt; 返回一个对象，该对象表示</target>
        </trans-unit>
        <trans-unit id="80160250c999cde418e5655d194ff040c11e355e" translate="yes" xml:space="preserve">
          <source>The position,</source>
          <target state="translated">该职位:</target>
        </trans-unit>
        <trans-unit id="04babac298b058269a3dd833ef7829f7e3894479" translate="yes" xml:space="preserve">
          <source>The possibly nested list of array elements.</source>
          <target state="translated">可能嵌套的数组元素列表。</target>
        </trans-unit>
        <trans-unit id="5cb3bd54a03911e525c1ba1e36e3cfe8b319cbe5" translate="yes" xml:space="preserve">
          <source>The power function distribution is just the inverse of the Pareto distribution. It may also be seen as a special case of the Beta distribution.</source>
          <target state="translated">幂函数分布只是帕累托分布的倒数。它也可以被看作是Beta分布的一个特例。</target>
        </trans-unit>
        <trans-unit id="1c353d3430d1303bc49c56d7ffa562f5074d9b47" translate="yes" xml:space="preserve">
          <source>The power(s) to which &lt;code&gt;x&lt;/code&gt; is raised. If &lt;code&gt;x&lt;/code&gt; contains multiple values, &lt;code&gt;p&lt;/code&gt; has to either be a scalar, or contain the same number of values as &lt;code&gt;x&lt;/code&gt;. In the latter case, the result is &lt;code&gt;x[0]**p[0], x[1]**p[1], ...&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的幂次幂。如果 &lt;code&gt;x&lt;/code&gt; 包含多个值，则 &lt;code&gt;p&lt;/code&gt; 必须为标量，或包含与 &lt;code&gt;x&lt;/code&gt; 相同数量的值。在后一种情况下，结果是 &lt;code&gt;x[0]**p[0], x[1]**p[1], ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc85a1fd23e1e3db0366910d77d438dbfca5d6af" translate="yes" xml:space="preserve">
          <source>The precision of &lt;a href=&quot;arrays.scalars#numpy.number&quot;&gt;&lt;code&gt;numpy.number&lt;/code&gt;&lt;/a&gt; subclasses is treated as a covariant generic parameter (see &lt;a href=&quot;#numpy.typing.NBitBase&quot;&gt;&lt;code&gt;NBitBase&lt;/code&gt;&lt;/a&gt;), simplifying the annoting of proccesses involving precision-based casting.</source>
          <target state="translated">&lt;a href=&quot;arrays.scalars#numpy.number&quot;&gt; &lt;code&gt;numpy.number&lt;/code&gt; &lt;/a&gt;子类的精度被视为协变泛型参数（请参见&lt;a href=&quot;#numpy.typing.NBitBase&quot;&gt; &lt;code&gt;NBitBase&lt;/code&gt; &lt;/a&gt;），从而简化了涉及基于精度的转换的过程注释。</target>
        </trans-unit>
        <trans-unit id="e709f72b7679480004c48b6a53b93936d4d5cd1a" translate="yes" xml:space="preserve">
          <source>The preferred way to update the documentation is by submitting a pull request on GitHub (see the &lt;a href=&quot;docs/index&quot;&gt;Documentation index&lt;/a&gt;). Please help us to further improve the NumPy documentation!</source>
          <target state="translated">更新文档的首选方法是在GitHub上提交拉取请求（请参见&lt;a href=&quot;docs/index&quot;&gt;文档索引&lt;/a&gt;）。请帮助我们进一步完善NumPy文档！</target>
        </trans-unit>
        <trans-unit id="65b60415cb79d4266b3f17e50b1894cd53e37067" translate="yes" xml:space="preserve">
          <source>The preferred way to update the documentation is by submitting a pull request on Github (see the &lt;a href=&quot;docs/index&quot;&gt;Documentation Index&lt;/a&gt;). Please help us to further improve the NumPy documentation!</source>
          <target state="translated">更新文档的首选方法是在Github上提交拉取请求（请参阅&lt;a href=&quot;docs/index&quot;&gt;文档索引&lt;/a&gt;）。请帮助我们进一步完善NumPy文档！</target>
        </trans-unit>
        <trans-unit id="2f79358f94b924f7a1e059d54f311b3bb21fdafb" translate="yes" xml:space="preserve">
          <source>The preferred way to use a BitGenerator in parallel applications is to use the &lt;a href=&quot;generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;SeedSequence.spawn&lt;/code&gt;&lt;/a&gt; method to obtain entropy values, and to use these to generate new BitGenerators:</source>
          <target state="translated">在并行应用程序中使用BitG​​enerator的首选方法是使用&lt;a href=&quot;generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt; &lt;code&gt;SeedSequence.spawn&lt;/code&gt; &lt;/a&gt;方法获取熵值，并使用这些值生成新的BitGenerator：</target>
        </trans-unit>
        <trans-unit id="bce0b83b0022d3f62b001c90ef9147d9a4659969" translate="yes" xml:space="preserve">
          <source>The preferred way to use a BitGenerator in parallel applications is to use the &lt;code&gt;SeedSequence.spawn&lt;/code&gt; method to obtain entropy values, and to use these to generate new BitGenerators:</source>
          <target state="translated">在并行应用程序中使用BitG​​enerator的首选方法是使用 &lt;code&gt;SeedSequence.spawn&lt;/code&gt; 方法获取熵值，并使用这些值生成新的BitGenerator：</target>
        </trans-unit>
        <trans-unit id="7ca668d501fbd18bd9dc320e9a4abf1ee3d102d7" translate="yes" xml:space="preserve">
          <source>The preprocessing of generically typed C source files (whether in NumPy proper or in any third party package using NumPy Distutils) is performed by &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/distutils/conv_template.py&quot;&gt;conv_template.py&lt;/a&gt;. The type specific C files generated (extension: .c) by these modules during the build process are ready to be compiled. This form of generic typing is also supported for C header files (preprocessed to produce .h files).</source>
          <target state="translated">通用类型的C源文件的预处理（无论是使用NumPy还是使用NumPy Distutils的任何第三方软件包）由&lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/distutils/conv_template.py&quot;&gt;conv_template.py进行&lt;/a&gt;。这些模块在构建过程中生成的特定于类型的C文件（扩展名：.c）已准备好进行编译。C头文件（经过预处理可生成.h文件）也支持这种形式的通用类型。</target>
        </trans-unit>
        <trans-unit id="56cdda624db28589a66dbc09b61a222075e2ac43" translate="yes" xml:space="preserve">
          <source>The preprocessing of generically-typed C source files (whether in NumPy proper or in any third party package using NumPy Distutils) is performed by &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/distutils/conv_template.py&quot;&gt;conv_template.py&lt;/a&gt;. The type-specific C files generated (extension: &lt;code&gt;.c&lt;/code&gt;) by these modules during the build process are ready to be compiled. This form of generic typing is also supported for C header files (preprocessed to produce &lt;code&gt;.h&lt;/code&gt; files).</source>
          <target state="translated">通用类型的C源文件的预处理（无论是使用NumPy的NumPy软件包，还是使用NumPy Distutils的任何第三方软件包）都由&lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/distutils/conv_template.py&quot;&gt;conv_template.py&lt;/a&gt;进行预处理。这些模块在构建过程中生成的特定于类型的C文件（扩展名： &lt;code&gt;.c&lt;/code&gt; ）已准备好进行编译。 C头文件（经过预处理可生成 &lt;code&gt;.h&lt;/code&gt; 文件）也支持这种形式的通用类型。</target>
        </trans-unit>
        <trans-unit id="79ca2b18555d36b1c58583e3de2322375811401a" translate="yes" xml:space="preserve">
          <source>The presence of &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; also influences how &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; handles binary operations like &lt;code&gt;arr + obj&lt;/code&gt; and &lt;code&gt;arr
&amp;lt; obj&lt;/code&gt; when &lt;code&gt;arr&lt;/code&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;obj&lt;/code&gt; is an instance of a custom class. There are two possibilities. If &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; is present and not &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;code&gt;ndarray.__add__&lt;/code&gt; and friends will delegate to the ufunc machinery, meaning that &lt;code&gt;arr + obj&lt;/code&gt; becomes &lt;code&gt;np.add(arr, obj)&lt;/code&gt;, and then &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; invokes &lt;code&gt;obj.__array_ufunc__&lt;/code&gt;. This is useful if you want to define an object that acts like an array.</source>
          <target state="translated">的存在&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;也影响如何&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;手柄等二进制操作 &lt;code&gt;arr + obj&lt;/code&gt; 和 &lt;code&gt;arr &amp;lt; obj&lt;/code&gt; 时 &lt;code&gt;arr&lt;/code&gt; 是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;obj&lt;/code&gt; 是一个自定义的类的实例。有两种可能性。如果存在 &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; 而不是&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则 &lt;code&gt;ndarray.__add__&lt;/code&gt; 和朋友将委托给ufunc机制，这意味着 &lt;code&gt;arr + obj&lt;/code&gt; 变为 &lt;code&gt;np.add(arr, obj)&lt;/code&gt; ，然后&lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt; &lt;code&gt;add&lt;/code&gt; &lt;/a&gt;调用 &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; 。如果要定义一个行为类似于数组的对象，这将很有用。</target>
        </trans-unit>
        <trans-unit id="40d6e2ba786e2b9884243f86e826abd1b1d0b0e2" translate="yes" xml:space="preserve">
          <source>The presence of &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; also influences how &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; handles binary operations like &lt;code&gt;arr + obj&lt;/code&gt; and &lt;code&gt;arr
&amp;lt; obj&lt;/code&gt; when &lt;code&gt;arr&lt;/code&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;obj&lt;/code&gt; is an instance of a custom class. There are two possibilities. If &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; is present and not None, then &lt;code&gt;ndarray.__add__&lt;/code&gt; and friends will delegate to the ufunc machinery, meaning that &lt;code&gt;arr + obj&lt;/code&gt; becomes &lt;code&gt;np.add(arr, obj)&lt;/code&gt;, and then &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; invokes &lt;code&gt;obj.__array_ufunc__&lt;/code&gt;. This is useful if you want to define an object that acts like an array.</source>
          <target state="translated">的存在&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;也影响如何&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;手柄等二进制操作 &lt;code&gt;arr + obj&lt;/code&gt; 和 &lt;code&gt;arr &amp;lt; obj&lt;/code&gt; 时 &lt;code&gt;arr&lt;/code&gt; 是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;obj&lt;/code&gt; 是一个自定义的类的实例。有两种可能性。如果存在 &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; 而不是None，则 &lt;code&gt;ndarray.__add__&lt;/code&gt; 和朋友将委托给ufunc机制，这意味着 &lt;code&gt;arr + obj&lt;/code&gt; 变为 &lt;code&gt;np.add(arr, obj)&lt;/code&gt; ，然后&lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt; &lt;code&gt;add&lt;/code&gt; &lt;/a&gt;调用 &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; 。如果要定义一个像数组一样的对象，这很有用。</target>
        </trans-unit>
        <trans-unit id="6adb356cfd1303c61f397a436f3cf821b0707e98" translate="yes" xml:space="preserve">
          <source>The presence of a header in the file can hinder data processing. In that case, we need to use the &lt;code&gt;skip_header&lt;/code&gt; optional argument. The values of this argument must be an integer which corresponds to the number of lines to skip at the beginning of the file, before any other action is performed. Similarly, we can skip the last &lt;code&gt;n&lt;/code&gt; lines of the file by using the &lt;code&gt;skip_footer&lt;/code&gt; attribute and giving it a value of &lt;code&gt;n&lt;/code&gt;:</source>
          <target state="translated">文件中标头的存在会阻碍数据处理。在这种情况下，我们需要使用 &lt;code&gt;skip_header&lt;/code&gt; 可选参数。此参数的值必须是整数，该整数与执行任何其他操作之前在文件开头要跳过的行数相对应。同样，我们可以通过使用 &lt;code&gt;skip_footer&lt;/code&gt; 属性并将其值设置为 &lt;code&gt;n&lt;/code&gt; 来跳过文件的最后 &lt;code&gt;n&lt;/code&gt; 行：</target>
        </trans-unit>
        <trans-unit id="e5f36326e83630873ee2db09163f521fed09ccf8" translate="yes" xml:space="preserve">
          <source>The present value is computed by solving the equation:</source>
          <target state="translated">通过解方程计算出现值。</target>
        </trans-unit>
        <trans-unit id="601986bff68f0c999502156a5c8a6f32ded002a4" translate="yes" xml:space="preserve">
          <source>The primary advantage of using array scalars is that they preserve the array type (Python may not have a matching scalar type available, e.g. &lt;code&gt;int16&lt;/code&gt;). Therefore, the use of array scalars ensures identical behaviour between arrays and scalars, irrespective of whether the value is inside an array or not. NumPy scalars also have many of the same methods arrays do.</source>
          <target state="translated">使用数组标量的主要优点是它们保留了数组类型（Python可能没有可用的匹配标量类型，例如 &lt;code&gt;int16&lt;/code&gt; ）。因此，使用数组标量可以确保数组和标量之间的行为相同，而不管该值是否在数组内部。NumPy标量也具有许多与数组相同的方法。</target>
        </trans-unit>
        <trans-unit id="8c51c177d3ffae7eeb654a1cd5049b77b590c4db" translate="yes" xml:space="preserve">
          <source>The primitive types supported are tied closely to those in C:</source>
          <target state="translated">支持的基元类型与C语言中的基元类型紧密相连。</target>
        </trans-unit>
        <trans-unit id="8faab5fdb76f1a3f47be9fc86bef262e2ab4b27a" translate="yes" xml:space="preserve">
          <source>The probabilities associated with each entry in a. If not given the sample assumes a uniform distribution over all entries in a.</source>
          <target state="translated">与a中每个条目相关联的概率,如果没有给定,则样本假设a中所有条目的分布是均匀的。</target>
        </trans-unit>
        <trans-unit id="8e475ecd8059b20acc5cee6528910a74a85f3b11" translate="yes" xml:space="preserve">
          <source>The probability density for the Gamma distribution is</source>
          <target state="translated">Gamma分布的概率密度为</target>
        </trans-unit>
        <trans-unit id="de744fd74c21b122de22a0d8e948a2a51ccc2b96" translate="yes" xml:space="preserve">
          <source>The probability density for the Gaussian distribution is</source>
          <target state="translated">高斯分布的概率密度为</target>
        </trans-unit>
        <trans-unit id="5905e8ef12f7d0d9eb54f382d72998ae48c8ef44" translate="yes" xml:space="preserve">
          <source>The probability density for the Gumbel distribution is</source>
          <target state="translated">Gumbel分布的概率密度为</target>
        </trans-unit>
        <trans-unit id="bfb8724927e73ab8d936772b36c634818f86c5a4" translate="yes" xml:space="preserve">
          <source>The probability density for the Hypergeometric distribution is</source>
          <target state="translated">超几何分布的概率密度为</target>
        </trans-unit>
        <trans-unit id="f8985b96e26b0408a1f84b2787ee767e62c90303" translate="yes" xml:space="preserve">
          <source>The probability density for the Log Series distribution is</source>
          <target state="translated">对数系列分布的概率密度为</target>
        </trans-unit>
        <trans-unit id="99fc9473ccfc113313d9fd374b914f025b58f310" translate="yes" xml:space="preserve">
          <source>The probability density for the Logistic distribution is</source>
          <target state="translated">Logistic分布的概率密度为</target>
        </trans-unit>
        <trans-unit id="7985bdd977289b5652a3a0bba81a5da1bd3adf6d" translate="yes" xml:space="preserve">
          <source>The probability density for the Pareto distribution is</source>
          <target state="translated">帕累托分布的概率密度为</target>
        </trans-unit>
        <trans-unit id="238160654ada0174d17d83e1f0d7a26707c02c8d" translate="yes" xml:space="preserve">
          <source>The probability density for the Weibull distribution is</source>
          <target state="translated">Weibull分布的概率密度为</target>
        </trans-unit>
        <trans-unit id="fc3b79ebd29285bfc80812044ba5bd995aaaa06a" translate="yes" xml:space="preserve">
          <source>The probability density for the Zipf distribution is</source>
          <target state="translated">Zipf分布的概率密度为</target>
        </trans-unit>
        <trans-unit id="bb707b06597dece119e6e3ebea40c8f15c1cb44f" translate="yes" xml:space="preserve">
          <source>The probability density for the binomial distribution is</source>
          <target state="translated">二项分布的概率密度为</target>
        </trans-unit>
        <trans-unit id="6264a2e3e986c29af2fd700f69cafdda6f6c9d98" translate="yes" xml:space="preserve">
          <source>The probability density for the von Mises distribution is</source>
          <target state="translated">冯-米塞斯分布的概率密度为</target>
        </trans-unit>
        <trans-unit id="2e977910510c195394a91f298d7c9556abc16027" translate="yes" xml:space="preserve">
          <source>The probability density function</source>
          <target state="translated">概率密度函数</target>
        </trans-unit>
        <trans-unit id="a293dce90e3fe47dddc6a55e94ccb69a8fef9b0c" translate="yes" xml:space="preserve">
          <source>The probability density function for the Rayleigh distribution is</source>
          <target state="translated">雷利分布的概率密度函数为</target>
        </trans-unit>
        <trans-unit id="d3e0872e16a6ab7b6c0ee2a22d52dd0d2e1ca84e" translate="yes" xml:space="preserve">
          <source>The probability density function for the Wald distribution is</source>
          <target state="translated">Wald分布的概率密度函数为</target>
        </trans-unit>
        <trans-unit id="2f149a65fa2739e5de1eec985af9c1621ffacc73" translate="yes" xml:space="preserve">
          <source>The probability density function for the full Cauchy distribution is</source>
          <target state="translated">全Cauchy分布的概率密度函数为</target>
        </trans-unit>
        <trans-unit id="6b0dc98514227cdd44ff47b528c8a0bcaf89c265" translate="yes" xml:space="preserve">
          <source>The probability density function for the noncentral Chi-square distribution is</source>
          <target state="translated">非中心Chi-square分布的概率密度函数为</target>
        </trans-unit>
        <trans-unit id="c30948020144257a9fb38966abff7c99e81c50e9" translate="yes" xml:space="preserve">
          <source>The probability density function for the t distribution is</source>
          <target state="translated">t分布的概率密度函数为</target>
        </trans-unit>
        <trans-unit id="dcdbad2794701215e8c40510ff713b7913263c5a" translate="yes" xml:space="preserve">
          <source>The probability density function for the triangular distribution is</source>
          <target state="translated">三角分布的概率密度函数为</target>
        </trans-unit>
        <trans-unit id="6467351c7a0571530575123e2ae036078aaa2303" translate="yes" xml:space="preserve">
          <source>The probability density function is</source>
          <target state="translated">概率密度函数为</target>
        </trans-unit>
        <trans-unit id="ee41aab696af2a63a045005f9a20ab50a30087b5" translate="yes" xml:space="preserve">
          <source>The probability density function of the chi-squared distribution is</source>
          <target state="translated">齐次方分布的概率密度函数为</target>
        </trans-unit>
        <trans-unit id="c5e3eadc4ee0ddfc376707a7c47e36bdec30614e" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">正态分布的概率密度函数首先由De Moivre提出，然后在200年后由Gauss和Laplace分别独立地推导&lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;，由于其特征形状而通常被称为钟形曲线（请参见下面的示例）。</target>
        </trans-unit>
        <trans-unit id="2297eee1a9ef2ae469ffb4ffe7c7db8f4e4f83da" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#ra2e838c5ea87-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">正态分布的概率密度函数首先由De Moivre提出，然后在200年后由Gauss和Laplace分别推导&lt;a href=&quot;#ra2e838c5ea87-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;，由于其特征形状而通常被称为钟形曲线（请参见下面的示例）。</target>
        </trans-unit>
        <trans-unit id="d7e2875a44ce7ebdc83cb0f55dc114499ca0e8b1" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">正态分布的概率密度函数首先由De Moivre提出，然后在200年后由Gauss和Laplace分别独立地推导&lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;，由于其特征形状而通常被称为钟形曲线（请参见下面的示例）。</target>
        </trans-unit>
        <trans-unit id="31415e3883f5ad2cde00e0bf903f48cc5ab3d293" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#rf578abb8fba2-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">正态分布的概率密度函数首先由De Moivre提出，然后在200年后由Gauss和Laplace分别推导&lt;a href=&quot;#rf578abb8fba2-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;，由于其特征形状而通常被称为钟形曲线（请参见下面的示例）。</target>
        </trans-unit>
        <trans-unit id="2755556e2db9bd446cf581401e578c5337420320" translate="yes" xml:space="preserve">
          <source>The probability density function of the uniform distribution is</source>
          <target state="translated">统一分布的概率密度函数为</target>
        </trans-unit>
        <trans-unit id="415051b020f7949a62618fb53ef560dee4613543" translate="yes" xml:space="preserve">
          <source>The probability inputs should be normalized. As an implementation detail, the value of the last entry is ignored and assumed to take up any leftover probability mass, but this should not be relied on. A biased coin which has twice as much weight on one side as on the other should be sampled like so:</source>
          <target state="translated">概率输入应进行归一化处理。作为一个实施细节,最后一个输入的值被忽略,并被假定为占用任何剩余的概率质量,但这不应该被依赖。一个有偏向的硬币,其一边的权重是另一边的两倍,应该这样采样。</target>
        </trans-unit>
        <trans-unit id="8e4c202be333253a1251675439dcd7f21c1ef125" translate="yes" xml:space="preserve">
          <source>The probability mass function for the Log Series distribution is</source>
          <target state="translated">对数系列分布的概率质量函数为</target>
        </trans-unit>
        <trans-unit id="2d117aed0c4f59861c0b3330028791db8f91f6f5" translate="yes" xml:space="preserve">
          <source>The probability mass function of the geometric distribution is</source>
          <target state="translated">几何分布的概率质量函数为</target>
        </trans-unit>
        <trans-unit id="53c49feadffaed0acd89d507cebd4872b9032162" translate="yes" xml:space="preserve">
          <source>The probability mass function of the negative binomial distribution is</source>
          <target state="translated">负二项分布的概率质量函数为</target>
        </trans-unit>
        <trans-unit id="f1f5e6e451a12ecc1dfa7cb3123b997ae141c402" translate="yes" xml:space="preserve">
          <source>The probability of success of an individual trial.</source>
          <target state="translated">单项试验成功的概率;</target>
        </trans-unit>
        <trans-unit id="c0419d3f3c0dd14cc710a6332bd5b9e9f12f94e6" translate="yes" xml:space="preserve">
          <source>The problem here is that there is one dimension argument and two array arguments, and our typemaps are set up for dimensions that apply to a single array (in fact, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; does not provide a mechanism for associating &lt;code&gt;len&lt;/code&gt; with &lt;code&gt;vec2&lt;/code&gt; that takes two Python input arguments). The recommended solution is the following:</source>
          <target state="translated">这里的问题是，有一个维度参数和两个数组参数，并且我们的类型映射是为适用于单个数组的维度设置的（实际上，&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;不提供将 &lt;code&gt;len&lt;/code&gt; 与 &lt;code&gt;vec2&lt;/code&gt; 关联的机制，该机制需要两个Python输入参数）。推荐的解决方案如下：</target>
        </trans-unit>
        <trans-unit id="258606759bb8ded772cb41c8f492be953461a647" translate="yes" xml:space="preserve">
          <source>The problem is solved exactly. In this case, the function returns True only if there is an element shared between the arrays.</source>
          <target state="translated">这个问题正好解决了。在这种情况下,只有当数组之间有元素共享时,函数才返回True。</target>
        </trans-unit>
        <trans-unit id="4ad89e6d069e4dfa2e5a4dc8cd5ea0ef4b308ab4" translate="yes" xml:space="preserve">
          <source>The problem is solved exactly. In this case, the function returns True only if there is an element shared between the arrays. Finding the exact solution may take extremely long in some cases.</source>
          <target state="translated">这个问题正好解决了。在这种情况下,只有当数组之间有元素共享时,函数才会返回True。在某些情况下,找到精确的解可能需要极长的时间。</target>
        </trans-unit>
        <trans-unit id="12f7b79ffc79e216081a6d98b051a230198244d5" translate="yes" xml:space="preserve">
          <source>The product of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 的乘积，以元素为单位。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="3f6e1c408d5c694acb6e117eca1f17a66ff95359" translate="yes" xml:space="preserve">
          <source>The product of an empty array is the neutral element 1:</source>
          <target state="translated">空数组的乘积是中性元素1。</target>
        </trans-unit>
        <trans-unit id="75994948d8c7e15ea47031e7a198364fb67ad040" translate="yes" xml:space="preserve">
          <source>The project management structure can be found at our &lt;a href=&quot;dev/governance/index&quot;&gt;governance page&lt;/a&gt;</source>
          <target state="translated">可以在我们的&lt;a href=&quot;dev/governance/index&quot;&gt;管理页面上&lt;/a&gt;找到项目管理结构</target>
        </trans-unit>
        <trans-unit id="0cb319efd0acc22671f035a1669648180fbd73bb" translate="yes" xml:space="preserve">
          <source>The promoted data type.</source>
          <target state="translated">晋升的数据类型。</target>
        </trans-unit>
        <trans-unit id="6912cd62e766bc5197bb815c3a7a6d0beffe9f0f" translate="yes" xml:space="preserve">
          <source>The pseudo Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Chebyshev polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">伪范德蒙矩阵。返回矩阵的形状为 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; ，其中最后一个索引是相应的Chebyshev多项式的次数。dtype将与转换后的 &lt;code&gt;x&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="4ae75dbae228045f6a44f16a4959415e52a060af" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Hermite polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">伪范德蒙矩阵。返回矩阵的形状为 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; ，其中最后一个索引是对应的Hermite多项式的次数。dtype将与转换后的 &lt;code&gt;x&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="88145706d808f4e5b4b300c092c6d0b48707e827" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding HermiteE polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">伪范德蒙矩阵。返回矩阵的形状为 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; ，其中最后一个索引是对应的HermiteE多项式的次数。dtype将与转换后的 &lt;code&gt;x&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="461d6f363a2da4bb21861bdd9199b9a080f1058c" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Laguerre polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">伪范德蒙矩阵。返回矩阵的形状为 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; ，其中最后一个索引是相应的Laguerre多项式的次数。dtype将与转换后的 &lt;code&gt;x&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="a9fac4b82ab694bb7879684258269647508526ed" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Legendre polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">伪范德蒙矩阵。返回矩阵的形状为 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; ，其中最后一个索引是相应的Legendre多项式的次数。dtype将与转换后的 &lt;code&gt;x&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="1e87cfa1899783295ead645aa689484ac09d5ad0" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; instance, then so is &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">的伪逆 &lt;code&gt;a&lt;/code&gt; 。如果 &lt;code&gt;a&lt;/code&gt; 是&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;实例，则 &lt;code&gt;B&lt;/code&gt; 也是矩阵实例。</target>
        </trans-unit>
        <trans-unit id="14e8343a4bfc8bf0e783456b4d87d1a38896cde9" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;matrix&lt;/code&gt; instance, then so is &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">的伪逆 &lt;code&gt;a&lt;/code&gt; 。如果 &lt;code&gt;a&lt;/code&gt; 是 &lt;code&gt;matrix&lt;/code&gt; 实例，则 &lt;code&gt;B&lt;/code&gt; 也是。</target>
        </trans-unit>
        <trans-unit id="c9935b0bcef3c9f2790af77d395c4f7367a5b4f9" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of a matrix A, denoted</source>
          <target state="translated">矩阵A的伪逆,表示为</target>
        </trans-unit>
        <trans-unit id="43268b21480b8908d11ac78845b26e8a85b3d3ad" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;code&gt;F2PY&lt;/code&gt; &amp;ndash;&lt;em&gt;Fortran to Python interface generator&lt;/em&gt;&amp;ndash; is to provide a connection between Python and Fortran languages. F2PY is a part of &lt;a href=&quot;https://www.numpy.org/&quot;&gt;NumPy&lt;/a&gt; (&lt;code&gt;numpy.f2py&lt;/code&gt;) and also available as a standalone command line tool &lt;code&gt;f2py&lt;/code&gt; when &lt;code&gt;numpy&lt;/code&gt; is installed that facilitates creating/building Python C/API extension modules that make it possible</source>
          <target state="translated">&lt;code&gt;F2PY&lt;/code&gt; （&lt;em&gt;Fortran到Python的界面生成器）&lt;/em&gt;的目的是在Python和Fortran语言之间提供连接。F2PY是&lt;a href=&quot;https://www.numpy.org/&quot;&gt;NumPy&lt;/a&gt;（ &lt;code&gt;numpy.f2py&lt;/code&gt; ）的一部分，当安装 &lt;code&gt;numpy&lt;/code&gt; 时，它也可以作为独立的命令行工具 &lt;code&gt;f2py&lt;/code&gt; 使用，它有助于创建/构建Python C / API扩展模块，从而使其成为可能</target>
        </trans-unit>
        <trans-unit id="273d622b1bbcac1e58ca2d1b74d9ecdc471af9f8" translate="yes" xml:space="preserve">
          <source>The purpose of the reference count check is to make sure you do not use this array as a buffer for another Python object and then reallocate the memory. However, reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object, then you may safely set &lt;code&gt;refcheck&lt;/code&gt; to False.</source>
          <target state="translated">引用计数检查的目的是确保不要将此数组用作另一个Python对象的缓冲区，然后重新分配内存。但是，引用计数可以通过其他方式增加，因此，如果您确定尚未与另一个Python对象共享该数组的内存，则可以安全地将 &lt;code&gt;refcheck&lt;/code&gt; 设置为False。</target>
        </trans-unit>
        <trans-unit id="cd4694d2cc663a00201267e4370ce5da08336131" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to formalize the governance process used by the NumPy project in both ordinary and extraordinary situations, and to clarify how decisions are made and how the various elements of our community interact, including the relationship between open source collaborative development and work that may be funded by for-profit or non-profit entities.</source>
          <target state="translated">本文件的目的是将NumPy项目在普通和特殊情况下使用的治理流程正式化,并明确如何做出决策,以及我们社区的各个要素如何互动,包括开源合作开发与可能由盈利或非盈利实体资助的工作之间的关系。</target>
        </trans-unit>
        <trans-unit id="fd1af1501c6ee7b4f0b0aa9bb7ca5e17785491ff" translate="yes" xml:space="preserve">
          <source>The quadrant (i.e., branch) is chosen so that &lt;code&gt;arctan2(x1, x2)&lt;/code&gt; is the signed angle in radians between the ray ending at the origin and passing through the point (1,0), and the ray ending at the origin and passing through the point (&lt;code&gt;x2&lt;/code&gt;, &lt;code&gt;x1&lt;/code&gt;). (Note the role reversal: the &amp;ldquo;&lt;code&gt;y&lt;/code&gt;-coordinate&amp;rdquo; is the first function parameter, the &amp;ldquo;&lt;code&gt;x&lt;/code&gt;-coordinate&amp;rdquo; is the second.) By IEEE convention, this function is defined for &lt;code&gt;x2&lt;/code&gt; = +/-0 and for either or both of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; = +/-inf (see Notes for specific values).</source>
          <target state="translated">选择象限（即分支），以使 &lt;code&gt;arctan2(x1, x2)&lt;/code&gt; 是在以原点结束并通过点（1,0）的射线与以原点结束并通过的射线之间的弧度的符号角通过点（ &lt;code&gt;x2&lt;/code&gt; ， &lt;code&gt;x1&lt;/code&gt; ）。 （请注意角色反转：&amp;ldquo; &lt;code&gt;y&lt;/code&gt; -坐标&amp;rdquo;是第一个函数参数，&amp;ldquo; &lt;code&gt;x&lt;/code&gt; -坐标&amp;rdquo;是第二个函数参数。）按照IEEE惯例，此函数定义为 &lt;code&gt;x2&lt;/code&gt; = +/- 0以及两个或两个 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; = +/- inf（有关特定值，请参见注释）。</target>
        </trans-unit>
        <trans-unit id="a6498ac12126ab973a1934f179594a987afb7844" translate="yes" xml:space="preserve">
          <source>The quick and smart way</source>
          <target state="translated">快速而聪明的方法</target>
        </trans-unit>
        <trans-unit id="8b0770ff789fdc985036394e871929fde93eb9a9" translate="yes" xml:space="preserve">
          <source>The quick way</source>
          <target state="translated">快速方法</target>
        </trans-unit>
        <trans-unit id="d041efcac5d4fa984fd9e585c0e674ab20c24a98" translate="yes" xml:space="preserve">
          <source>The quickest way to wrap the Fortran subroutine &lt;code&gt;FIB&lt;/code&gt; to Python is to run</source>
          <target state="translated">将Fortran子例程 &lt;code&gt;FIB&lt;/code&gt; 包装到Python的最快方法是运行</target>
        </trans-unit>
        <trans-unit id="ef42c4d34d6fe180bfd554c782fbff1345844332" translate="yes" xml:space="preserve">
          <source>The random numbers generated are reproducible in the sense that the same seed will produce the same outputs, given that the number of threads does not change.</source>
          <target state="translated">生成的随机数是可重复的,即在线程数不变的情况下,相同的种子将产生相同的输出。</target>
        </trans-unit>
        <trans-unit id="d11423e3cc4bf0ed835c8b796b2965976e8e77d3" translate="yes" xml:space="preserve">
          <source>The random values are simulated using a rejection-based method and so, on average, more than one value from the underlying RNG is required to generate an single draw.</source>
          <target state="translated">随机值采用基于拒绝的方法进行模拟,因此,平均来说,产生一次抽奖需要底层RNG的一个以上的值。</target>
        </trans-unit>
        <trans-unit id="28da8ed4d2357ec2f5fb90d47c281e28c8eefc86" translate="yes" xml:space="preserve">
          <source>The random values produced by &lt;a href=&quot;../generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; orignate in a BitGenerator. The BitGenerators do not directly provide random numbers and only contains methods used for seeding, getting or setting the state, jumping or advancing the state, and for accessing low-level wrappers for consumption by code that can efficiently access the functions provided, e.g., &lt;a href=&quot;https://numba.pydata.org&quot;&gt;numba&lt;/a&gt;.</source>
          <target state="translated">由&lt;a href=&quot;../generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;产生的随机值在BitGenerator中指定。所述BitGenerators不直接提供随机数和只包含用于播种，获取或设置的状态下，跳跃或推进状态，并且对于由可以有效地访问的功能的提供的代码，例如，访问低电平包装消费方法&lt;a href=&quot;https://numba.pydata.org&quot;&gt;numba&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ad47a80d273e6280e7c076840353be5436abdd4" translate="yes" xml:space="preserve">
          <source>The random variate of the F distribution (also known as the Fisher distribution) is a continuous probability distribution that arises in ANOVA tests, and is the ratio of two chi-square variates.</source>
          <target state="translated">F分布的随机方差(又称Fisher分布)是方差分析检验中产生的连续概率分布,是两个齐次方差的比值。</target>
        </trans-unit>
        <trans-unit id="5e26087033b3fc33a117f2ffd1f65fecc7d3f31d" translate="yes" xml:space="preserve">
          <source>The random.Generator class has a new &lt;code&gt;permuted&lt;/code&gt; function.</source>
          <target state="translated">random.Generator类具有一个新的 &lt;code&gt;permuted&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="0add6113b9556467f5d4df18305b83fe87d90739" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;a href=&quot;numpy.full#numpy.full&quot;&gt;&lt;code&gt;full&lt;/code&gt;&lt;/a&gt; = False.</source>
          <target state="translated">最小二乘拟合中的系数矩阵的秩不足。仅当&lt;a href=&quot;numpy.full#numpy.full&quot;&gt; &lt;code&gt;full&lt;/code&gt; &lt;/a&gt; = False 时才发出警告。</target>
        </trans-unit>
        <trans-unit id="9713dea73f1e21f45e35ecea0c0c8c7ada18485a" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;a href=&quot;numpy.full#numpy.full&quot;&gt;&lt;code&gt;full&lt;/code&gt;&lt;/a&gt; = False. The warnings can be turned off by</source>
          <target state="translated">最小二乘拟合中的系数矩阵的秩不足。仅当&lt;a href=&quot;numpy.full#numpy.full&quot;&gt; &lt;code&gt;full&lt;/code&gt; &lt;/a&gt; = False时才发出警告。可以通过以下方式关闭警告</target>
        </trans-unit>
        <trans-unit id="b6ce678d6ccc2a705d695d4a88057837caab615e" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;code&gt;full&lt;/code&gt; = False.</source>
          <target state="translated">最小二乘拟合中的系数矩阵的秩不足。仅当 &lt;code&gt;full&lt;/code&gt; = False 时才发出警告。</target>
        </trans-unit>
        <trans-unit id="bd75ec6be6b0946c94eb5124dc2c270b7f45fc83" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;code&gt;full&lt;/code&gt; = False. The warnings can be turned off by</source>
          <target state="translated">最小二乘拟合中的系数矩阵的秩不足。仅当 &lt;code&gt;full&lt;/code&gt; = False 时才发出警告。可以通过以下方式关闭警告</target>
        </trans-unit>
        <trans-unit id="2c0ff958aa13b6c22519b1f58af607e808b9fc81" translate="yes" xml:space="preserve">
          <source>The rate of interest is computed by iteratively solving the (non-linear) equation:</source>
          <target state="translated">通过反复求解(非线性)方程来计算利率。</target>
        </trans-unit>
        <trans-unit id="b661d55a0a19500a077ffd4c961cfcdd8af11a0d" translate="yes" xml:space="preserve">
          <source>The real and imaginary parts of complex numbers are rounded separately. The result of rounding a float is a float.</source>
          <target state="translated">复数的实部和虚部要分别进行四舍五入。对浮点数进行四舍五入的结果就是浮点数。</target>
        </trans-unit>
        <trans-unit id="207d8f1e0e497b598f007938a1132510a97a9210" translate="yes" xml:space="preserve">
          <source>The real component of the complex argument. If &lt;code&gt;val&lt;/code&gt; is real, the type of &lt;code&gt;val&lt;/code&gt; is used for the output. If &lt;code&gt;val&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">复杂参数的实际组成部分。如果 &lt;code&gt;val&lt;/code&gt; 是真实的类型， &lt;code&gt;val&lt;/code&gt; 用于输出。如果 &lt;code&gt;val&lt;/code&gt; 具有复杂元素，则返回的类型为float。</target>
        </trans-unit>
        <trans-unit id="bcba5206897319bd4dfef5984f33a61e7bfd3a3e" translate="yes" xml:space="preserve">
          <source>The real part of the array.</source>
          <target state="translated">数组的真实部分。</target>
        </trans-unit>
        <trans-unit id="f76c20342380d19b36138a77680129546c04ac6d" translate="yes" xml:space="preserve">
          <source>The real part of the masked array.</source>
          <target state="translated">掩码数组的真实部分。</target>
        </trans-unit>
        <trans-unit id="3d31d01b7c11703d8075820106fa90d3e0159005" translate="yes" xml:space="preserve">
          <source>The real part of the scalar.</source>
          <target state="translated">标量的实部。</target>
        </trans-unit>
        <trans-unit id="f8c34f7042b404b994731920ea347bbd1e355fae" translate="yes" xml:space="preserve">
          <source>The recommended approach to multithreaded iteration is to first create an iterator with the flags &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt;&lt;code&gt;NPY_ITER_RANGED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt;&lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt;&lt;/a&gt;, and possibly &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt;. Create a copy of this iterator for each thread (minus one for the first iterator). Then, take the iteration index range &lt;code&gt;[0, NpyIter_GetIterSize(iter))&lt;/code&gt; and split it up into tasks, for example using a TBB parallel_for loop. When a thread gets a task to execute, it then uses its copy of the iterator by calling &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt;&lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt;&lt;/a&gt; and iterating over the full range.</source>
          <target state="translated">推荐的多线程迭代方法是首先创建一个带有标志&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt; &lt;code&gt;NPY_ITER_RANGED&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt; &lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt; &lt;/a&gt;以及可能的&lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt;的迭代器。为每个线程创建此迭代器的副本（第一个迭代器减去一个）。然后，采用迭代索引范围 &lt;code&gt;[0, NpyIter_GetIterSize(iter))&lt;/code&gt; 并将其拆分为多个任务，例如使用TBB parallel_for循环。当线程让任务执行时，它会通过调用&lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt; &lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt; &lt;/a&gt;并在整个范围内进行迭代来使用其迭代器的副本。</target>
        </trans-unit>
        <trans-unit id="8ebf9173277c6dd7ef8e96321015ddb67f853d5b" translate="yes" xml:space="preserve">
          <source>The recommended generator for general use is &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt;. It is statistically high quality, full-featured, and fast on most platforms, but somewhat slow when compiled for 32-bit processes.</source>
          <target state="translated">推荐的通用生成器是&lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;。从统计上讲，它是高质量的，功能齐全的，并且在大多数平台上都是快速的，但是为32位进程编译时，速度有些慢。</target>
        </trans-unit>
        <trans-unit id="5447919d67b87c18366730a8d862cd10ecf68752" translate="yes" xml:space="preserve">
          <source>The recommended generator for general use is &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt;. It is statistically high quality, full-featured, and fast on most platforms, but somewhat slow when compiled for 32-bit processes.</source>
          <target state="translated">推荐的通用生成器是&lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;。从统计上讲，它是高质量的，功能齐全的，并且在大多数平台上都是快速的，但是为32位进程编译时，速度有些慢。</target>
        </trans-unit>
        <trans-unit id="1ecded761aa3b896fb25df737596c852ad7e09c5" translate="yes" xml:space="preserve">
          <source>The recommended practice for initializing &lt;code&gt;mask&lt;/code&gt; with a scalar boolean value is to use &lt;code&gt;True&lt;/code&gt;/&lt;code&gt;False&lt;/code&gt; rather than &lt;code&gt;np.True_&lt;/code&gt;/&lt;code&gt;np.False_&lt;/code&gt;. The reason is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is represented internally as &lt;code&gt;np.False_&lt;/code&gt;.</source>
          <target state="translated">建议使用标量布尔值初始化 &lt;code&gt;mask&lt;/code&gt; 做法是使用 &lt;code&gt;True&lt;/code&gt; / &lt;code&gt;False&lt;/code&gt; 而不是 &lt;code&gt;np.True_&lt;/code&gt; / &lt;code&gt;np.False_&lt;/code&gt; 。原因是&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;在内部表示为 &lt;code&gt;np.False_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1f83ab16efb108e21fd8dc9140501bac936f974" translate="yes" xml:space="preserve">
          <source>The recommended way to mark one or several specific entries of a masked array as invalid is to assign the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; to them:</source>
          <target state="translated">将掩码数组的一个或几个特定条目标记为无效的建议方法是为它们分配&lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;的特殊值：</target>
        </trans-unit>
        <trans-unit id="8e71a8b22e3d3f7dda123223a571d40b785e19ae" translate="yes" xml:space="preserve">
          <source>The recommended way to store and load data:</source>
          <target state="translated">推荐的存储和加载数据的方式。</target>
        </trans-unit>
        <trans-unit id="8911e36d75ead22da4c98276ac7d48a14f617b1b" translate="yes" xml:space="preserve">
          <source>The reduceat function is a generalization of both the reduce and accumulate functions. It implements a reduce over ranges of the input array specified by indices. The extra indices argument is checked to be sure that every input is not too large for the input array along the selected dimension before the loop calculations take place. The loop implementation is handled using code that is very similar to the reduce code repeated as many times as there are elements in the indices input. In particular: the first input pointer passed to the underlying 1-D computational loop points to the input array at the correct location indicated by the index array. In addition, the output pointer and the second input pointer passed to the underlying 1-D loop point to the same position in memory. The size of the 1-D computational loop is fixed to be the difference between the current index and the next index (when the current index is the last index, then the next index is assumed to be the length of the array along the selected dimension). In this way, the 1-D loop will implement a reduce over the specified indices.</source>
          <target state="translated">reduceat 函数是 reduce 和 accumulate 函数的泛化。它实现了在由index指定的输入数组的范围内进行reduce。在循环计算发生之前,额外的index参数会被检查,以确保每个输入对输入数组来说,沿着选定的维度不会太大。循环的实现是使用与reduce代码非常相似的代码来处理的,只要indices输入中有元素,就会重复多次。特别是:传递给底层1-D计算循环的第一个输入指针指向索引数组所指示的正确位置的输入数组。此外,传递给底层1-D循环的输出指针和第二输入指针指向内存中的同一位置。1-D计算循环的大小固定为当前索引和下一个索引之间的差值(当当前索引为最后一个索引时,则假设下一个索引为沿选定维度的数组长度)。这样一来,一维循环将在指定的索引上实现缩减。</target>
        </trans-unit>
        <trans-unit id="7b43a1a08f82a3b68e452cbd124797f3f5925ce7" translate="yes" xml:space="preserve">
          <source>The reduced array. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to it.</source>
          <target state="translated">精简数组。如果提供 &lt;code&gt;out&lt;/code&gt; ，则 &lt;code&gt;r&lt;/code&gt; 是对其的引用。</target>
        </trans-unit>
        <trans-unit id="d46d2581ba496f8d142f6a4f33e8d4c920183656" translate="yes" xml:space="preserve">
          <source>The reduced values. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">降低的值。如果提供 &lt;code&gt;out&lt;/code&gt; ，则 &lt;code&gt;r&lt;/code&gt; 是对 &lt;code&gt;out&lt;/code&gt; 的引用。</target>
        </trans-unit>
        <trans-unit id="3281b17df16674bbe40c7e1efbe54eb9d464c9ee" translate="yes" xml:space="preserve">
          <source>The regular expression. Default value is None, in which case the nose default (&lt;code&gt;re.compile(r'(?:^|[\b_\.%s-])[Tt]est' % os.sep)&lt;/code&gt;) is used. If &lt;code&gt;testmatch&lt;/code&gt; is a string, it is compiled to a regular expression first.</source>
          <target state="translated">正则表达式。默认值为None，在这种情况下使用鼻子默认值（ &lt;code&gt;re.compile(r'(?:^|[\b_\.%s-])[Tt]est' % os.sep)&lt;/code&gt; ）。如果 &lt;code&gt;testmatch&lt;/code&gt; 是字符串，则首先将其编译为正则表达式。</target>
        </trans-unit>
        <trans-unit id="bd0a0dfb20db6ba5c33bc9ca8a9fe1a01f1841cf" translate="yes" xml:space="preserve">
          <source>The relative performance on 64-bit Linux and 64-bit Windows is broadly similar.</source>
          <target state="translated">在64位Linux和64位Windows上的相对性能大致相似。</target>
        </trans-unit>
        <trans-unit id="7989f6ae8fcd58319573d40c534aa46fe0a84b96" translate="yes" xml:space="preserve">
          <source>The relative tolerance parameter (see Notes).</source>
          <target state="translated">相对公差参数(见注释)。</target>
        </trans-unit>
        <trans-unit id="3e03b7da726f71e414e37015d45ecfcbfb010c83" translate="yes" xml:space="preserve">
          <source>The release should be announced on the mailing lists of NumPy and SciPy, to python-announce, and possibly also those of Matplotlib, IPython and/or Pygame.</source>
          <target state="translated">这个版本应该在NumPy和SciPy的邮件列表中公布,在python-announce中公布,也可能在Matplotlib、IPython和/或Pygame中公布。</target>
        </trans-unit>
        <trans-unit id="96164d49d0f26476a5104ba2b3a4aa7deeeccb58" translate="yes" xml:space="preserve">
          <source>The release should be announced on the numpy-discussion, scipy-devel, scipy-user, and python-announce-list mailing lists. Look at previous announcements for the basic template. The contributor and PR lists are the same as generated for the release notes above. If you crosspost, make sure that python-announce-list is BCC so that replies will not be sent to that list.</source>
          <target state="translated">这个版本应该在 numpy-discussion、scipy-devel、scipy-user 和 python-announce-list 邮件列表中公布。基本的模板可以参考之前的公告。贡献者和 PR 列表与上面的发布说明生成的列表是一样的。如果你跨贴,请确保 python-announce-list 是 BCC,这样回复就不会被发送到该列表。</target>
        </trans-unit>
        <trans-unit id="12f91fe84c2d74d72d982ce47fb9a64711667ccc" translate="yes" xml:space="preserve">
          <source>The release tag should have the release number in the annotation (tag message). Unfortunately, the name of a tag can be changed without breaking the signature, the contents of the message cannot.</source>
          <target state="translated">发布标签的注释(标签消息)中应该有发布号。遗憾的是,标签的名称可以更改而不破坏签名,消息的内容却不能更改。</target>
        </trans-unit>
        <trans-unit id="dafb58a5db48e1dfe53af56fea252537c1419b45" translate="yes" xml:space="preserve">
          <source>The remainder of the division of &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 除以 &lt;code&gt;x2&lt;/code&gt; 的余数。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="addbfd0df60663d128185f6696a4113588a064dc" translate="yes" xml:space="preserve">
          <source>The repos shown by &lt;code&gt;git remote -v show&lt;/code&gt; will include your fork on GitHub and the main repo:</source>
          <target state="translated">通过显示的回购 &lt;code&gt;git remote -v show&lt;/code&gt; 将包括您在GitHub和主要回购叉：</target>
        </trans-unit>
        <trans-unit id="45876a6251302c94b60ea59421b48e6f10e76b32" translate="yes" xml:space="preserve">
          <source>The required alignment (bytes) of this data-type according to the compiler.</source>
          <target state="translated">根据编译器,该数据类型所需的对齐方式(字节数)。</target>
        </trans-unit>
        <trans-unit id="13ef7d8fa51bbebbe1bd1d3ed4d25fe31e0c8b11" translate="yes" xml:space="preserve">
          <source>The required data type(s) of the operands. If copying or buffering is enabled, the data will be converted to/from their original types.</source>
          <target state="translated">操作数的必要数据类型。如果启用了复制或缓冲,数据将被转换为/从原始类型。</target>
        </trans-unit>
        <trans-unit id="0a7d78831f72627736ecbbe6affd07acc842cf9c" translate="yes" xml:space="preserve">
          <source>The required data-type. If None preserve the current dtype. If your application requires the data to be in native byteorder, include a byteorder specification as a part of the dtype specification.</source>
          <target state="translated">所需的数据类型。如果没有,则保留当前的dtype。如果您的应用程序要求数据是以本地字节顺序排列,请在dtype规范中包含字节顺序规范。</target>
        </trans-unit>
        <trans-unit id="65e5c657147f8f6206b51f162cff2b0b35eade26" translate="yes" xml:space="preserve">
          <source>The requirements flag allows specification of what kind of array is acceptable. If the object passed in does not satisfy this requirements then a copy is made so that thre returned object will satisfy the requirements. these ndarray can use a very generic pointer to memory. This flag allows specification of the desired properties of the returned array object. All of the flags are explained in the detailed API chapter. The flags most commonly needed are &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_IN_ARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_IN_ARRAY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../reference/c-api/array#c.NPY_OUT_ARRAY&quot;&gt;&lt;code&gt;NPY_OUT_ARRAY&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_INOUT_ARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_INOUT_ARRAY&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">需求标志允许指定可接受的数组类型。如果传入的对象不满足此要求，则进行复制，以使返回的对象满足要求。这些ndarray可以使用非常通用的内存指针。该标志允许指定返回数组对象的所需属性。在详细的API章节中说明了所有标志。最常用的标志是&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_IN_ARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_IN_ARRAY&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../reference/c-api/array#c.NPY_OUT_ARRAY&quot;&gt; &lt;code&gt;NPY_OUT_ARRAY&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_INOUT_ARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_INOUT_ARRAY&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="bb180b40fee6aef0d41f93f405142f00de46dd28" translate="yes" xml:space="preserve">
          <source>The requirements list can be any of the following</source>
          <target state="translated">要求清单可以是以下任何一种</target>
        </trans-unit>
        <trans-unit id="bf0f3cb688cf9b5f44c6080748b72439b46fb978" translate="yes" xml:space="preserve">
          <source>The reshaping operation cannot guarantee that a copy will not be made, to modify the shape in place, use &lt;code&gt;a.shape = s&lt;/code&gt;</source>
          <target state="translated">重塑操作不能保证不会复制，要修改形状，请使用 &lt;code&gt;a.shape = s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3c22a2794d4be1171f3bb3051bbeb72ad7588dd" translate="yes" xml:space="preserve">
          <source>The rest of the story</source>
          <target state="translated">剩下的故事</target>
        </trans-unit>
        <trans-unit id="2b262525b3075625bc8ca490c385d67e383e0b64" translate="yes" xml:space="preserve">
          <source>The rest of this document discusses working on the NumPy code base and documentation. We&amp;rsquo;re in the process of updating our descriptions of other activities and roles. If you are interested in these other activities, please contact us! You can do this via the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion mailing list&lt;/a&gt;, or on &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;GitHub&lt;/a&gt; (open an issue or comment on a relevant issue). These are our preferred communication channels (open source is open by nature!), however if you prefer to discuss in private first, please reach out to our community coordinators at &lt;code&gt;numpy-team@googlegroups.com&lt;/code&gt; or &lt;code&gt;numpy-team.slack.com&lt;/code&gt; (send an email to &lt;code&gt;numpy-team@googlegroups.com&lt;/code&gt; for an invite the first time).</source>
          <target state="translated">本文档的其余部分讨论了有关NumPy代码库和文档的工作。我们正在更新对其他活动和角色的描述。如果您对这些其他活动感兴趣，请与我们联系！您可以通过&lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion邮件列表&lt;/a&gt;或在&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;GitHub上执行此操作&lt;/a&gt;（打开问题或对相关问题发表评论）。这些是我们首选的沟通渠道（开放源代码是开放性的！），但是如果你愿意私下讨论首先，请与我们的社区协调员 &lt;code&gt;numpy-team@googlegroups.com&lt;/code&gt; 或 &lt;code&gt;numpy-team.slack.com&lt;/code&gt; （首次发送电子邮件至 &lt;code&gt;numpy-team@googlegroups.com&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="efae226cd4ce4ec97472c40d085c0b19d6b0deb7" translate="yes" xml:space="preserve">
          <source>The rest of this page will give you a basic idea of how to add unit tests to modules in SciPy. It is extremely important for us to have extensive unit testing since this code is going to be used by scientists and researchers and is being developed by a large number of people spread across the world. So, if you are writing a package that you&amp;rsquo;d like to become part of SciPy, please write the tests as you develop the package. Also since much of SciPy is legacy code that was originally written without unit tests, there are still several modules that don&amp;rsquo;t have tests yet. Please feel free to choose one of these modules and develop tests for it as you read through this introduction.</source>
          <target state="translated">本页面的其余部分将为您提供有关如何向SciPy中的模块添加单元测试的基本思想。对我们来说，进行大量的单元测试非常重要，因为该代码将由科学家和研究人员使用，并且由遍布世界各地的许多人开发。因此，如果您要编写一个要成为SciPy一部分的程序包，请在开发程序包时编写测试。同样，由于SciPy的大部分是遗留代码，最初是在没有单元测试的情况下编写的，因此仍有几个模块尚未进行测试。阅读本简介时，请随时选择其中一个模块并为其开发测试。</target>
        </trans-unit>
        <trans-unit id="90738a573063433b40a2bef8dfa08dda95ee95c6" translate="yes" xml:space="preserve">
          <source>The result can be used to construct a datetime that uses the same units as a timedelta</source>
          <target state="translated">结果可以用来构造一个使用与timedelta相同单位的日期时间。</target>
        </trans-unit>
        <trans-unit id="8baf21a4c319c73c6c3f91016a95ecc1ae5e1dca" translate="yes" xml:space="preserve">
          <source>The result depends on the bit-width:</source>
          <target state="translated">结果取决于位宽。</target>
        </trans-unit>
        <trans-unit id="7a004033c9a8a28e785dfe7afb00d43720c2d90c" translate="yes" xml:space="preserve">
          <source>The result is &lt;strong&gt;not&lt;/strong&gt; a MaskedArray!</source>
          <target state="translated">结果&lt;strong&gt;不是&lt;/strong&gt; MaskedArray！</target>
        </trans-unit>
        <trans-unit id="88b2f160b598518e6df066363213cebfd6339e40" translate="yes" xml:space="preserve">
          <source>The result is an inverse for &lt;code&gt;a&lt;/code&gt; relative to the tensordot operation &lt;code&gt;tensordot(a, b, ind)&lt;/code&gt;, i. e., up to floating-point accuracy, &lt;code&gt;tensordot(tensorinv(a), a, ind)&lt;/code&gt; is the &amp;ldquo;identity&amp;rdquo; tensor for the tensordot operation.</source>
          <target state="translated">其结果是逆 &lt;code&gt;a&lt;/code&gt; 相对于所述tensordot操作 &lt;code&gt;tensordot(a, b, ind)&lt;/code&gt; ，即最多浮点精度， &lt;code&gt;tensordot(tensorinv(a), a, ind)&lt;/code&gt; 是&amp;ldquo;同一性&amp;rdquo;张量为tensordot操作。</target>
        </trans-unit>
        <trans-unit id="1513bc4b365343f54e37e3a0463aec42e49631e5" translate="yes" xml:space="preserve">
          <source>The result is equivalent to the previous example where &lt;code&gt;b&lt;/code&gt; was an array. We can think of the scalar &lt;code&gt;b&lt;/code&gt; being &lt;em&gt;stretched&lt;/em&gt; during the arithmetic operation into an array with the same shape as &lt;code&gt;a&lt;/code&gt;. The new elements in &lt;code&gt;b&lt;/code&gt; are simply copies of the original scalar. The stretching analogy is only conceptual. NumPy is smart enough to use the original scalar value without actually making copies so that broadcasting operations are as memory and computationally efficient as possible.</source>
          <target state="translated">结果等同于前面的示例，其中 &lt;code&gt;b&lt;/code&gt; 是一个数组。我们可以想到标量 &lt;code&gt;b&lt;/code&gt; 在算术运算中被&lt;em&gt;拉伸&lt;/em&gt;成与 &lt;code&gt;a&lt;/code&gt; 形状相同的数组。 &lt;code&gt;b&lt;/code&gt; 中的新元素只是原始标量的副本。延伸类推只是概念上的。 NumPy足够聪明，可以使用原始标量值而无需实际制作副本，从而使广播操作尽可能地节省内存并提高计算效率。</target>
        </trans-unit>
        <trans-unit id="b234fdc2574c2d15c385cc66cebde459f6f8d571" translate="yes" xml:space="preserve">
          <source>The result is equivalent to the previous example where &lt;code&gt;b&lt;/code&gt; was an array. We can think of the scalar &lt;code&gt;b&lt;/code&gt; being stretched during the arithmetic operation into an array with the same shape as &lt;code&gt;a&lt;/code&gt;. The new elements in &lt;code&gt;b&lt;/code&gt;, as shown in &lt;a href=&quot;#figure-1&quot;&gt;Figure 1&lt;/a&gt;, are simply copies of the original scalar. The stretching analogy is only conceptual. numpy is smart enough to use the original scalar value without actually making copies so that broadcasting operations are as memory and computationally efficient as possible. Because &lt;a href=&quot;#example-2&quot;&gt;Example 2&lt;/a&gt; moves less memory, (&lt;code&gt;b&lt;/code&gt; is a scalar, not an array) around during the multiplication, it is about 10% faster than &lt;a href=&quot;#example-1&quot;&gt;Example 1&lt;/a&gt; using the standard numpy on Windows 2000 with one million element arrays.</source>
          <target state="translated">结果等同于前面的示例，其中 &lt;code&gt;b&lt;/code&gt; 是一个数组。我们可以想到标量 &lt;code&gt;b&lt;/code&gt; 在算术运算中被拉伸成与 &lt;code&gt;a&lt;/code&gt; 形状相同的数组。&lt;a href=&quot;#figure-1&quot;&gt;如图1&lt;/a&gt;所示， &lt;code&gt;b&lt;/code&gt; 中的新元素只是原始标量的副本。延伸类推只是概念上的。 numpy非常聪明，可以使用原始标量值而无需实际制作副本，从而使广播操作尽可能地节省内存并提高计算效率。由于&lt;a href=&quot;#example-2&quot;&gt;示例2&lt;/a&gt;在乘法过程中移动了较少的内存（ &lt;code&gt;b&lt;/code&gt; 是标量，而不是数组），因此它比&lt;a href=&quot;#example-1&quot;&gt;示例1&lt;/a&gt;快约10％。 在具有一百万个元素数组的Windows 2000上使用标准的numpy。</target>
        </trans-unit>
        <trans-unit id="d98fd654993b2c5bc8c34d84506f2eeb585bf55f" translate="yes" xml:space="preserve">
          <source>The result is padded to full bytes by inserting zero bits at the end.</source>
          <target state="translated">通过在末尾插入零位,将结果填充为完整的字节。</target>
        </trans-unit>
        <trans-unit id="a05d82855a760b96ff01a98014b6f39cd92699f0" translate="yes" xml:space="preserve">
          <source>The result is returned as a boolean array.</source>
          <target state="translated">结果以布尔数组的形式返回。</target>
        </trans-unit>
        <trans-unit id="f9d8170d98950c22e6026933d7548298a3e52f98" translate="yes" xml:space="preserve">
          <source>The result is:</source>
          <target state="translated">结果是:</target>
        </trans-unit>
        <trans-unit id="f485f36eec65ddcecdc4119f77e3da3d4540a73e" translate="yes" xml:space="preserve">
          <source>The result masks values that are masked in either &lt;code&gt;m1&lt;/code&gt; or &lt;code&gt;m2&lt;/code&gt;.</source>
          <target state="translated">结果将掩盖被 &lt;code&gt;m1&lt;/code&gt; 或 &lt;code&gt;m2&lt;/code&gt; 掩盖的值。</target>
        </trans-unit>
        <trans-unit id="93fabead91587e60c1a08bfee6b05728d77a4b94" translate="yes" xml:space="preserve">
          <source>The result may be a view on &lt;code&gt;m1&lt;/code&gt; or &lt;code&gt;m2&lt;/code&gt; if the other is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (i.e. False).</source>
          <target state="translated">如果另一个是&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;（即False），则结果可能是在 &lt;code&gt;m1&lt;/code&gt; 或 &lt;code&gt;m2&lt;/code&gt; 上的视图。</target>
        </trans-unit>
        <trans-unit id="12ea562d907c93ffb2a2a48a2ff38a17f82a53ed" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;cPickle.loads(strg)&lt;/code&gt; is returned.</source>
          <target state="translated">返回 &lt;code&gt;cPickle.loads(strg)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="b138f2dad8b26af563c2e4bf508dc59fdd1de271" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;x**p&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; are scalars, so is &lt;code&gt;out&lt;/code&gt;, otherwise an array is returned.</source>
          <target state="translated">&lt;code&gt;x**p&lt;/code&gt; 的结果。如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt; 是标量，则 &lt;code&gt;out&lt;/code&gt; 是，否则返回一个数组。</target>
        </trans-unit>
        <trans-unit id="437933320e33dbd911c7ecb653e24b023c9820e4" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;x1 * 2**x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">结果 &lt;code&gt;x1 * 2**x2&lt;/code&gt; 。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="d200549129cf50987e2e3db04a3ddae4d86fd86e" translate="yes" xml:space="preserve">
          <source>The result of binning the input array. The length of &lt;code&gt;out&lt;/code&gt; is equal to &lt;code&gt;np.amax(x)+1&lt;/code&gt;.</source>
          <target state="translated">合并输入数组的结果。 &lt;code&gt;out&lt;/code&gt; 的长度等于 &lt;code&gt;np.amax(x)+1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6126cff082b1038f45f0cf4b879a12e8909f651" translate="yes" xml:space="preserve">
          <source>The result of indexing with a multi-field index is a view into the original array, as follows:</source>
          <target state="translated">使用多字段索引的结果是进入原始数组的视图,如下所示。</target>
        </trans-unit>
        <trans-unit id="b74fd032efc344495e89da82ba5cefb838c783f0" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;a&lt;/code&gt; where &lt;code&gt;condition&lt;/code&gt; is True.</source>
          <target state="translated">掩蔽的结果 &lt;code&gt;a&lt;/code&gt; ，其中 &lt;code&gt;condition&lt;/code&gt; 是真。</target>
        </trans-unit>
        <trans-unit id="2f9d4558b4365ff73c9c67d9671ab31c28b67b0f" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;x&lt;/code&gt; where approximately equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">屏蔽 &lt;code&gt;x&lt;/code&gt; 的结果大约等于 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c8d1e813923a2b2b410b1cadd9d90a6a3b27803" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;x&lt;/code&gt; where equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">屏蔽 &lt;code&gt;x&lt;/code&gt; 等于 &lt;code&gt;value&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="20b27291ef8731ea508bbd0cd5e12a0ad3afd15b" translate="yes" xml:space="preserve">
          <source>The result of repeating &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">重复 &lt;code&gt;a&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="080be4f2b719d17ca857f6ff65fc2c9ddc4f8015" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; parameter.</source>
          <target state="translated">调用 &lt;code&gt;function&lt;/code&gt; 的结果直接传回。因此形状&lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt;完全被确定 &lt;code&gt;function&lt;/code&gt; 。如果 &lt;code&gt;function&lt;/code&gt; 返回标量值，则&lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt;的形状将与&lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;参数不匹配。</target>
        </trans-unit>
        <trans-unit id="5a3504d8e95aae2a9b20b749f6d2c5a3889c5102" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;code&gt;shape&lt;/code&gt; parameter.</source>
          <target state="translated">调用 &lt;code&gt;function&lt;/code&gt; 的结果直接传回。因此形状&lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt;完全被确定 &lt;code&gt;function&lt;/code&gt; 。如果 &lt;code&gt;function&lt;/code&gt; 返回标量值，则&lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt;的形状将与 &lt;code&gt;shape&lt;/code&gt; 参数不匹配。</target>
        </trans-unit>
        <trans-unit id="02a8e58b3d72e0b52f3592cd0fcb4ec46672a2f6" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; parameter.</source>
          <target state="translated">调用 &lt;code&gt;function&lt;/code&gt; 的结果直接传回。因此形状&lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt;完全被确定 &lt;code&gt;function&lt;/code&gt; 。如果 &lt;code&gt;function&lt;/code&gt; 返回标量值，则&lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt;的形状将与&lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;参数不匹配。</target>
        </trans-unit>
        <trans-unit id="7ebaed6e2d6aea7781825cdc661171775d93ce2b" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;numpy.fromfunction#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;numpy.fromfunction#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; parameter.</source>
          <target state="translated">调用 &lt;code&gt;function&lt;/code&gt; 的结果直接传回。因此形状&lt;a href=&quot;numpy.fromfunction#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt;完全被确定 &lt;code&gt;function&lt;/code&gt; 。如果 &lt;code&gt;function&lt;/code&gt; 返回标量值，则&lt;a href=&quot;numpy.fromfunction#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt;的形状将与&lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;参数不匹配。</target>
        </trans-unit>
        <trans-unit id="be63aee25a235ea7ecaebcc7084bf9b89e5f1ba3" translate="yes" xml:space="preserve">
          <source>The result of the inverse real 2-D FFT.</source>
          <target state="translated">逆实二维FFT的结果。</target>
        </trans-unit>
        <trans-unit id="0a8c1e8c657004ada13d1bd67fea4f58af8cdb70" translate="yes" xml:space="preserve">
          <source>The result of the modulo operation for negative dividend and divisors is bound by conventions. For &lt;a href=&quot;#numpy.fmod&quot;&gt;&lt;code&gt;fmod&lt;/code&gt;&lt;/a&gt;, the sign of result is the sign of the dividend, while for &lt;a href=&quot;numpy.remainder#numpy.remainder&quot;&gt;&lt;code&gt;remainder&lt;/code&gt;&lt;/a&gt; the sign of the result is the sign of the divisor. The &lt;a href=&quot;#numpy.fmod&quot;&gt;&lt;code&gt;fmod&lt;/code&gt;&lt;/a&gt; function is equivalent to the Matlab(TM) &lt;code&gt;rem&lt;/code&gt; function.</source>
          <target state="translated">负除数和除数的模运算结果受约定约束。对于&lt;a href=&quot;#numpy.fmod&quot;&gt; &lt;code&gt;fmod&lt;/code&gt; &lt;/a&gt;，结果的符号是除数的符号，而对于&lt;a href=&quot;numpy.remainder#numpy.remainder&quot;&gt; &lt;code&gt;remainder&lt;/code&gt; &lt;/a&gt;，结果的符号是除数的符号。的&lt;a href=&quot;#numpy.fmod&quot;&gt; &lt;code&gt;fmod&lt;/code&gt; &lt;/a&gt;函数等效于Matlab的（TM） &lt;code&gt;rem&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="432755e899e9d369003d6c1f79ef56f8c75f0660" translate="yes" xml:space="preserve">
          <source>The result of the real 2-D FFT.</source>
          <target state="translated">实二维FFT的结果。</target>
        </trans-unit>
        <trans-unit id="a62988dd4c556a700006b20bcac64bfa1f21b000" translate="yes" xml:space="preserve">
          <source>The result of this is always a 2d array, with a row for each non-zero element.</source>
          <target state="translated">其结果总是一个二维数组,每个非零元素有一行。</target>
        </trans-unit>
        <trans-unit id="552e732df1a7e97a3ac3793f40b01156b930c9d2" translate="yes" xml:space="preserve">
          <source>The result of trimming the input. The input data type is preserved.</source>
          <target state="translated">修剪输入的结果。保留输入数据类型。</target>
        </trans-unit>
        <trans-unit id="0ff6806d85e8fabd807a03dd151b7e1cdd284df8" translate="yes" xml:space="preserve">
          <source>The result type.</source>
          <target state="translated">结果类型:</target>
        </trans-unit>
        <trans-unit id="101ce3a3f58e25741f8924a6b8d0cfd25472eeff" translate="yes" xml:space="preserve">
          <source>The result will be multidimensional if y has more dimensions than b. For example:</source>
          <target state="translated">如果y的维度比b多,则结果将是多维的,例如。</target>
        </trans-unit>
        <trans-unit id="e2a369eb25dfa6d23e15865ad12a81c98b2538db" translate="yes" xml:space="preserve">
          <source>The result.</source>
          <target state="translated">结果是:</target>
        </trans-unit>
        <trans-unit id="d1fb43fabbedcad07c574b0e98cbace4463e697f" translate="yes" xml:space="preserve">
          <source>The resulting approximation of</source>
          <target state="translated">由此产生的近似值为</target>
        </trans-unit>
        <trans-unit id="8f5a6724cd845387db9fbc4a8e08fe47ae3e4ec1" translate="yes" xml:space="preserve">
          <source>The resulting array is a view into the original array. It shares the same memory locations and writing to the view will modify the original array.</source>
          <target state="translated">由此产生的数组是对原始数组的一个视图,它共享相同的内存位置,写入视图将修改原始数组。它共享相同的内存位置,对视图的写入将修改原始数组。</target>
        </trans-unit>
        <trans-unit id="a4450860735a4299b5638f4df95ccd877c9615a2" translate="yes" xml:space="preserve">
          <source>The resulting array therefore has a value &lt;code&gt;fn(x, y, z)&lt;/code&gt; at coordinate &lt;code&gt;(x, y, z)&lt;/code&gt;.</source>
          <target state="translated">因此，所得数组在坐标 &lt;code&gt;(x, y, z)&lt;/code&gt; 处具有值 &lt;code&gt;fn(x, y, z)&lt;/code&gt; （x，y，z）。</target>
        </trans-unit>
        <trans-unit id="8e45fa029de06ce207816940e254f28318e174ec" translate="yes" xml:space="preserve">
          <source>The resulting path indicates which terms of the input contraction should be contracted first, the result of this contraction is then appended to the end of the contraction list. This list can then be iterated over until all intermediate contractions are complete.</source>
          <target state="translated">所产生的路径指示了输入收缩中的哪些项应该首先被收缩,然后将收缩的结果追加到收缩列表的末尾。然后这个列表可以迭代,直到所有的中间收缩完成。</target>
        </trans-unit>
        <trans-unit id="b0397bb7d27e88275099d7a9e2663ecd158fec65" translate="yes" xml:space="preserve">
          <source>The resulting signature for the function add.zadd is exactly the same one that was created previously. If the original source code had contained &lt;code&gt;A(N)&lt;/code&gt; instead of &lt;code&gt;A(*)&lt;/code&gt; and so forth with &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;, then I could obtain (nearly) the same interface simply by placing the &lt;code&gt;INTENT(OUT) :: C&lt;/code&gt; comment line in the source code. The only difference is that &lt;code&gt;N&lt;/code&gt; would be an optional input that would default to the length of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">函数add.zadd的结果签名与之前创建的签名完全相同。如果原始源代码包含 &lt;code&gt;A(N)&lt;/code&gt; 而不是 &lt;code&gt;A(*)&lt;/code&gt; 以及 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 等，那么我只需将 &lt;code&gt;INTENT(OUT) :: C&lt;/code&gt; 注释行放在源代码。唯一的区别是 &lt;code&gt;N&lt;/code&gt; 是可选输入，默认为 &lt;code&gt;A&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="4e44a556cdbd9e08c1c73c688efe96d93b4a9c2d" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100 higher degrees may be problematic. The weights are determined by using the fact that</source>
          <target state="translated">结果只测试到了100度,更高的度数可能会有问题。权重是根据以下事实确定的:</target>
        </trans-unit>
        <trans-unit id="ef4a7d2bf5791e871493bd9bc1998dc73f56d092" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100, higher degrees may be problematic. For Gauss-Chebyshev there are closed form solutions for the sample points and weights. If n = &lt;code&gt;deg&lt;/code&gt;, then</source>
          <target state="translated">结果仅经过了100级的测试，较高的级别可能会有问题。对于高斯-切比雪夫（Gauss-Chebyshev），有用于采样点和权重的封闭式解决方案。如果n = &lt;code&gt;deg&lt;/code&gt; ，则</target>
        </trans-unit>
        <trans-unit id="7a2a5f718e6f28fd9a2d71c1fb3ee2ee9fe5b2fb" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100, higher degrees may be problematic. The weights are determined by using the fact that</source>
          <target state="translated">结果只测试到100度,更高的度数可能有问题。权重的确定是利用以下事实:</target>
        </trans-unit>
        <trans-unit id="af6fbd4d24683930cbf1a134289a3df4c1b144c3" translate="yes" xml:space="preserve">
          <source>The results will be placed in this array. It may be the input array for in-place clipping. &lt;code&gt;out&lt;/code&gt; must be of the right shape to hold the output. Its type is preserved.</source>
          <target state="translated">结果将放置在此数组中。它可能是就地剪切的输入数组。 &lt;code&gt;out&lt;/code&gt; 必须具有正确的形状以容纳输出。其类型被保留。</target>
        </trans-unit>
        <trans-unit id="c6b62851dacdc54d8864ac2edf1604fc62b66dd6" translate="yes" xml:space="preserve">
          <source>The return statement should &lt;em&gt;not&lt;/em&gt; get redundant parentheses:</source>
          <target state="translated">return语句应该&lt;em&gt;不会&lt;/em&gt;让多余的括号：</target>
        </trans-unit>
        <trans-unit id="9002868afc12284eedaa4f924eaaabb6a7944154" translate="yes" xml:space="preserve">
          <source>The return type will always be an inexact (i.e. floating point) scalar type, even if all the arrays are integer arrays. If one of the inputs is an integer array, the minimum precision type that is returned is a 64-bit floating point dtype.</source>
          <target state="translated">即使所有的数组都是整数组,返回的类型也总是不精确的(即浮点)标量类型。如果其中一个输入是整数组,返回的最小精度类型是64位浮点dtype。</target>
        </trans-unit>
        <trans-unit id="273dde020fc2e47183998cc14b3fb20e4a9436a7" translate="yes" xml:space="preserve">
          <source>The return value is 0 on success, -1 on failure.</source>
          <target state="translated">成功时返回值为0,失败时返回值为-1。</target>
        </trans-unit>
        <trans-unit id="95baf9f3feb186151992e17419a9d52bee50a218" translate="yes" xml:space="preserve">
          <source>The return value is the same shape and type as &lt;code&gt;M&lt;/code&gt;; if the exponent is positive or zero then the type of the elements is the same as those of &lt;code&gt;M&lt;/code&gt;. If the exponent is negative the elements are floating-point.</source>
          <target state="translated">返回值的形状和类型与 &lt;code&gt;M&lt;/code&gt; 相同；如果指数为正或零，则元素的类型与 &lt;code&gt;M&lt;/code&gt; 的类型相同。如果指数为负，则元素为浮点数。</target>
        </trans-unit>
        <trans-unit id="55801c938cbd16156c4c8c48d17f11e40e4107d9" translate="yes" xml:space="preserve">
          <source>The return value of failed converter functions which are called using the &amp;ldquo;O&amp;amp;&amp;rdquo; syntax in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;-like functions.</source>
          <target state="translated">失败的转换器函数的返回值，在&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt;的函数中使用&amp;ldquo; O＆&amp;rdquo;语法调用。</target>
        </trans-unit>
        <trans-unit id="41e4fb8b6c4e49bb724d556b26ed34481cfcd6dd" translate="yes" xml:space="preserve">
          <source>The return value of successful converter functions which are called using the &amp;ldquo;O&amp;amp;&amp;rdquo; syntax in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;-like functions.</source>
          <target state="translated">成功的转换器函数的返回值，在&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt;的函数中使用&amp;ldquo; O＆&amp;rdquo;语法调用。</target>
        </trans-unit>
        <trans-unit id="c05aab266b5f8aae47c5e7319a883da33ec4e284" translate="yes" xml:space="preserve">
          <source>The return value, False if &lt;code&gt;x&lt;/code&gt; is of a complex type.</source>
          <target state="translated">返回值，如果 &lt;code&gt;x&lt;/code&gt; 为复杂类型，则返回False 。</target>
        </trans-unit>
        <trans-unit id="c002d9b8869cd4388cf5943fa7426632d76c13b5" translate="yes" xml:space="preserve">
          <source>The return value, True if &lt;code&gt;x&lt;/code&gt; is of a complex type or has at least one complex element.</source>
          <target state="translated">返回值，如果 &lt;code&gt;x&lt;/code&gt; 为复杂类型或具有至少一个复杂元素，则返回True 。</target>
        </trans-unit>
        <trans-unit id="8cacfcdc238ffe8ba32e3f60b54d5d84f6258480" translate="yes" xml:space="preserve">
          <source>The returned array has the same type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">返回的数组具有相同的类型 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8984b85b3f1b178d24103374b554ddde5426110f" translate="yes" xml:space="preserve">
          <source>The returned array is always 1D.</source>
          <target state="translated">返回的数组总是1D。</target>
        </trans-unit>
        <trans-unit id="59afb62c6311159c3a4c4a5a09d0fcb3d683db81" translate="yes" xml:space="preserve">
          <source>The returned array is always a structured array, and is constructed from all matches of the regular expression in the file. Groups in the regular expression are converted to fields of the structured array.</source>
          <target state="translated">返回的数组始终是一个结构化数组,由文件中所有匹配的正则表达式构建而成。正则表达式中的组被转换为结构化数组的字段。</target>
        </trans-unit>
        <trans-unit id="235ae9f13128943772ff554e126bc69621884d0e" translate="yes" xml:space="preserve">
          <source>The returned array will be guaranteed to have the listed requirements by making a copy if needed.</source>
          <target state="translated">如果需要的话,返回的数组将通过复制来保证有列出的要求。</target>
        </trans-unit>
        <trans-unit id="4d7c736b03b1eeb7cc2b9172d888763588690bd3" translate="yes" xml:space="preserve">
          <source>The returned array will have at least &lt;code&gt;ndmin&lt;/code&gt; dimensions. Otherwise mono-dimensional axes will be squeezed. Legal values: 0 (default), 1 or 2.</source>
          <target state="translated">返回的数组将至少具有 &lt;code&gt;ndmin&lt;/code&gt; 维。否则，将挤压一维轴。合法值：0（默认），1或2。</target>
        </trans-unit>
        <trans-unit id="0991fc7713b9227f260fa7eb1775e9a559dcb08f" translate="yes" xml:space="preserve">
          <source>The returned class can be of different type than the current instance and/or have a different domain and/or different window.</source>
          <target state="translated">返回的类可以是与当前实例不同的类型和/或具有不同的域和/或不同的窗口。</target>
        </trans-unit>
        <trans-unit id="f40fdf0f51a86b8b90c8d1563cabe3126d1130f1" translate="yes" xml:space="preserve">
          <source>The returned float array &lt;code&gt;f&lt;/code&gt; contains the frequency bin centers in cycles per unit of the sample spacing (with zero at the start). For instance, if the sample spacing is in seconds, then the frequency unit is cycles/second.</source>
          <target state="translated">返回的浮点数组 &lt;code&gt;f&lt;/code&gt; 包含频率单元中心，该频率单元中心以每单位采样间隔的周期为周期（开始时为零）。例如，如果样本间隔为秒，则频率单位为循环/秒。</target>
        </trans-unit>
        <trans-unit id="235d36eec348db0a4ce24e42c9d6a7df17b250d1" translate="yes" xml:space="preserve">
          <source>The returned indices will be valid to access arrays of shape (n, n).</source>
          <target state="translated">返回的索引将有效地访问形状(n,n)的数组。</target>
        </trans-unit>
        <trans-unit id="ae4549a46a428a48cedb9424b21a41ed06873386" translate="yes" xml:space="preserve">
          <source>The returned list contains array(s) of dtype double, complex double, or object. A 1-d argument of shape &lt;code&gt;(N,)&lt;/code&gt; is parsed into &lt;code&gt;N&lt;/code&gt; arrays of size one; a 2-d argument of shape &lt;code&gt;(M,N)&lt;/code&gt; is parsed into &lt;code&gt;M&lt;/code&gt; arrays of size &lt;code&gt;N&lt;/code&gt; (i.e., is &amp;ldquo;parsed by row&amp;rdquo;); and a higher dimensional array raises a Value Error if it is not first reshaped into either a 1-d or 2-d array.</source>
          <target state="translated">返回的列表包含dtype double，complex double或object的数组。形状为 &lt;code&gt;(N,)&lt;/code&gt; 的1-d自变量被解析为大小为 &lt;code&gt;N&lt;/code&gt; 的个数组；将形状为 &lt;code&gt;(M,N)&lt;/code&gt; 的二维自变量解析为大小为 &lt;code&gt;N&lt;/code&gt; 的 &lt;code&gt;M&lt;/code&gt; 个数组（即&amp;ldquo;按行解析&amp;rdquo;）；如果未先将高维数组重新整形为1-d或2-d数组，则会引发&amp;ldquo;值错误&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="14f1e30e33046331e7dfbbcb8096ad0d5112d69f" translate="yes" xml:space="preserve">
          <source>The returned object is an object of Python-type &lt;em&gt;subtype&lt;/em&gt;, which must be a subtype of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. The array has &lt;em&gt;nd&lt;/em&gt; dimensions, described by &lt;em&gt;dims&lt;/em&gt;. The data-type descriptor of the new array is &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="translated">返回的对象是Python类型&lt;em&gt;子类型&lt;/em&gt;的对象，该&lt;em&gt;子类型&lt;/em&gt;必须是&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;的子类型。该数组具有&lt;em&gt;nd&lt;/em&gt;维，用&lt;em&gt;dims&lt;/em&gt;描述。新数组的数据类型描述符为&lt;em&gt;descr&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="32e057c6946960f31384643bb71f5913a86433e2" translate="yes" xml:space="preserve">
          <source>The returned object is an object of Python-type &lt;em&gt;subtype&lt;/em&gt;, which must be a subtype of &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. The array has &lt;em&gt;nd&lt;/em&gt; dimensions, described by &lt;em&gt;dims&lt;/em&gt;. The data-type descriptor of the new array is &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="translated">返回的对象是Python类型&lt;em&gt;子类型&lt;/em&gt;的对象，该&lt;em&gt;子类型&lt;/em&gt;必须是&lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;的子类型。该数组具有&lt;em&gt;nd&lt;/em&gt;维，用&lt;em&gt;dims&lt;/em&gt;描述。新数组的数据类型描述符为&lt;em&gt;descr&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="5d88cddc6712bcffcc47387ee400aa7949d299dc" translate="yes" xml:space="preserve">
          <source>The returned order &lt;code&gt;m&lt;/code&gt; antiderivative &lt;code&gt;P&lt;/code&gt; of polynomial &lt;code&gt;p&lt;/code&gt; satisfies</source>
          <target state="translated">返回的顺序 &lt;code&gt;m&lt;/code&gt; 原函数 &lt;code&gt;P&lt;/code&gt; 多项式的 &lt;code&gt;p&lt;/code&gt; 满足</target>
        </trans-unit>
        <trans-unit id="0b8999800a1f602548a03b4247be14d85063c532" translate="yes" xml:space="preserve">
          <source>The returned pointer will keep a reference to the array.</source>
          <target state="translated">返回的指针将保留对数组的引用。</target>
        </trans-unit>
        <trans-unit id="ff4b18e64fa81ec18b5e45dfe00e0436536dea93" translate="yes" xml:space="preserve">
          <source>The returned tuple can be passed as the second argument of &lt;a href=&quot;../arrays.scalars#numpy.datetime64&quot;&gt;&lt;code&gt;numpy.datetime64&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../arrays.scalars#numpy.timedelta64&quot;&gt;&lt;code&gt;numpy.timedelta64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回的元组可以作为&lt;a href=&quot;../arrays.scalars#numpy.datetime64&quot;&gt; &lt;code&gt;numpy.datetime64&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../arrays.scalars#numpy.timedelta64&quot;&gt; &lt;code&gt;numpy.timedelta64&lt;/code&gt; &lt;/a&gt;的第二个参数传递。</target>
        </trans-unit>
        <trans-unit id="592b730c2fcc65333034a0c7238210b05d5a5c20" translate="yes" xml:space="preserve">
          <source>The returned tuple can be passed as the second argument of &lt;code&gt;numpy.datetime64&lt;/code&gt; and &lt;code&gt;numpy.timedelta64&lt;/code&gt;.</source>
          <target state="translated">返回的元组可以作为 &lt;code&gt;numpy.datetime64&lt;/code&gt; 和 &lt;code&gt;numpy.timedelta64&lt;/code&gt; 的第二个参数传递。</target>
        </trans-unit>
        <trans-unit id="f91874be1de458c40a0f1f04bc921bf313bf20d4" translate="yes" xml:space="preserve">
          <source>The returned tuple has the following items:</source>
          <target state="translated">返回的元组有以下项目:</target>
        </trans-unit>
        <trans-unit id="cef76c21baa4e56901ef823fceedd7a7068daf4e" translate="yes" xml:space="preserve">
          <source>The returned type character must represent the smallest size dtype such that an array of the returned type can handle the data from an array of all types in &lt;code&gt;typechars&lt;/code&gt; (or if &lt;code&gt;typechars&lt;/code&gt; is an array, then its dtype.char).</source>
          <target state="translated">返回的类型字符必须表示最小大小的dtype，以便返回类型的数组可以处理 &lt;code&gt;typechars&lt;/code&gt; 中所有类型的数组中的数据（如果 &lt;code&gt;typechars&lt;/code&gt; 是数组，则返回其dtype.char）。</target>
        </trans-unit>
        <trans-unit id="4fcc4213866e3a2e0117cc077e63fcf825ea6d85" translate="yes" xml:space="preserve">
          <source>The returned ufunc always returns PyObject arrays.</source>
          <target state="translated">返回的ufunc总是返回PyObject数组。</target>
        </trans-unit>
        <trans-unit id="a3367f678ba189a0a7553569bd4ae4f1aabaa222" translate="yes" xml:space="preserve">
          <source>The returned ufunc object is a callable Python object. It should be placed in a (module) dictionary under the same name as was used in the name argument to the ufunc-creation routine. The following example is adapted from the umath module</source>
          <target state="translated">返回的 ufunc 对象是一个可调用的 Python 对象。它应该被放置在 (模块)字典中,名称与 ufunc-creation 例程的 name 参数中使用的名称相同。下面的例子是根据 umath 模块改编的。</target>
        </trans-unit>
        <trans-unit id="15355fac5e58f997eedbca2c4b98e86da4be8c2c" translate="yes" xml:space="preserve">
          <source>The returned values define a linear map &lt;code&gt;off + scl*x&lt;/code&gt; that is applied to the input arguments before the series is evaluated. The map depends on the &lt;code&gt;domain&lt;/code&gt; and &lt;code&gt;window&lt;/code&gt;; if the current &lt;code&gt;domain&lt;/code&gt; is equal to the &lt;code&gt;window&lt;/code&gt; the resulting map is the identity. If the coefficients of the series instance are to be used by themselves outside this class, then the linear function must be substituted for the &lt;code&gt;x&lt;/code&gt; in the standard representation of the base polynomials.</source>
          <target state="translated">返回的值定义了一个线性映射 &lt;code&gt;off + scl*x&lt;/code&gt; ，该线性映射将在评估系列之前应用于输入自变量。地图取决于 &lt;code&gt;domain&lt;/code&gt; 和 &lt;code&gt;window&lt;/code&gt; ;如果当前 &lt;code&gt;domain&lt;/code&gt; 等于 &lt;code&gt;window&lt;/code&gt; 则生成的映射为标识。如果要在此类之外自己使用系列实例的系数，则必须用线性函数代替基本多项式的标准表示形式中的 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b9b48003d17ce5e05cd985e616cb02707b4abeb" translate="yes" xml:space="preserve">
          <source>The role of &lt;code&gt;__array_finalize__&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__array_finalize__&lt;/code&gt; 的作用</target>
        </trans-unit>
        <trans-unit id="ee620d4452ada0e1d6c1803fadfa839462d12739" translate="yes" xml:space="preserve">
          <source>The root estimates are obtained as the eigenvalues of the companion matrix, Roots far from the origin of the complex plane may have large errors due to the numerical instability of the power series for such values. Roots with multiplicity greater than 1 will also show larger errors as the value of the series near such points is relatively insensitive to errors in the roots. Isolated roots near the origin can be improved by a few iterations of Newton&amp;rsquo;s method.</source>
          <target state="translated">根估计是伴随矩阵的特征值，由于这些值的幂级数在数值上不稳定，因此远离复平面原点的根可能会有较大的误差。多重性大于1的根也将显示较大的误差，因为靠近这些点的序列的值对根的误差相对不敏感。牛顿法的一些迭代可以改善原点附近的孤立根。</target>
        </trans-unit>
        <trans-unit id="f62c87e72745436aa10f6d1a92b0a21eb2cc7b33" translate="yes" xml:space="preserve">
          <source>The root estimates are obtained as the eigenvalues of the companion matrix, Roots far from the origin of the complex plane may have large errors due to the numerical instability of the series for such values. Roots with multiplicity greater than 1 will also show larger errors as the value of the series near such points is relatively insensitive to errors in the roots. Isolated roots near the origin can be improved by a few iterations of Newton&amp;rsquo;s method.</source>
          <target state="translated">根估计值是作为伴随矩阵的特征值而获得的，由于该值系列的数值不稳定性，远离复杂平面原点的根可能会有较大的误差。多重性大于1的根也将显示较大的误差，因为靠近这些点的序列的值对根的误差相对不敏感。牛顿法的一些迭代可以改善原点附近的孤立根。</target>
        </trans-unit>
        <trans-unit id="a8ae81d114b6feba67040d0b0dda1df226f1fa7e" translate="yes" xml:space="preserve">
          <source>The roots of the polynomial, where self(x) == 0</source>
          <target state="translated">多项式的根,其中self(x)==0。</target>
        </trans-unit>
        <trans-unit id="b31543f4d0be4f9892b87954c40031df062dff89" translate="yes" xml:space="preserve">
          <source>The row dimension of the arrays for which the returned indices will be valid.</source>
          <target state="translated">返回指数有效的数组的行尺寸。</target>
        </trans-unit>
        <trans-unit id="0cdec07351f87c4df86a480e3a89d1fead72ecd2" translate="yes" xml:space="preserve">
          <source>The rtype argument specifies the data-type the reduction should take place over. This is important if the data-type of the array is not &amp;ldquo;large&amp;rdquo; enough to handle the output. By default, all integer data-types are made at least as large as &lt;a href=&quot;c-api.dtype#c.NPY_LONG&quot;&gt;&lt;code&gt;NPY_LONG&lt;/code&gt;&lt;/a&gt; for the &amp;ldquo;add&amp;rdquo; and &amp;ldquo;multiply&amp;rdquo; ufuncs (which form the basis for mean, sum, cumsum, prod, and cumprod functions).</source>
          <target state="translated">rtype参数指定还原应采用的数据类型。如果数组的数据类型&amp;ldquo;不足&amp;rdquo;以处理输出，则这一点很重要。缺省情况下，所有的整数数据类型的至少制成一样大&lt;a href=&quot;c-api.dtype#c.NPY_LONG&quot;&gt; &lt;code&gt;NPY_LONG&lt;/code&gt; &lt;/a&gt;为&amp;ldquo;添加&amp;rdquo;和&amp;ldquo;乘法&amp;rdquo; ufuncs（其形成为平均值，和，cumsum，prod和cumprod功能的基础）。</target>
        </trans-unit>
        <trans-unit id="81acb42027d32e73c24e9573f794b96cf5d260da" translate="yes" xml:space="preserve">
          <source>The rtype argument specifies the data-type the reduction should take place over. This is important if the data-type of the array is not &amp;ldquo;large&amp;rdquo; enough to handle the output. By default, all integer data-types are made at least as large as &lt;a href=&quot;dtype#c.NPY_LONG&quot;&gt;&lt;code&gt;NPY_LONG&lt;/code&gt;&lt;/a&gt; for the &amp;ldquo;add&amp;rdquo; and &amp;ldquo;multiply&amp;rdquo; ufuncs (which form the basis for mean, sum, cumsum, prod, and cumprod functions).</source>
          <target state="translated">rtype参数指定还原应采用的数据类型。如果数组的数据类型&amp;ldquo;不足&amp;rdquo;以处理输出，则这一点很重要。默认情况下，对于&amp;ldquo;加&amp;rdquo;和&amp;ldquo;乘&amp;rdquo;函数（构成均值，总和，总和，prod和cumprod函数的基础），所有整数数据类型的大小都至少与&lt;a href=&quot;dtype#c.NPY_LONG&quot;&gt; &lt;code&gt;NPY_LONG&lt;/code&gt; &lt;/a&gt;一样大。</target>
        </trans-unit>
        <trans-unit id="bec28ce661286e5b1ead8f4ea14b439b8431742d" translate="yes" xml:space="preserve">
          <source>The rule governing whether two arrays have compatible shapes for broadcasting can be expressed in a single sentence.</source>
          <target state="translated">关于两个阵列是否具有兼容形状的广播的规则可以用一句话来表达。</target>
        </trans-unit>
        <trans-unit id="3014977f10c304b722035fb1a265596f0e833693" translate="yes" xml:space="preserve">
          <source>The rules for ABI and API compatibilities can be summarized as follows:</source>
          <target state="translated">ABI和API兼容性的规则可以总结如下。</target>
        </trans-unit>
        <trans-unit id="db5c92fbe4ce9110548aea4ebd5e7c863e8e7523" translate="yes" xml:space="preserve">
          <source>The same analysis could be done with several different interest rates and/or payments and/or total amounts to produce an entire table.</source>
          <target state="translated">同样的分析可以用几种不同的利率和(或)付款额和(或)总金额来制作整个表格。</target>
        </trans-unit>
        <trans-unit id="5194cb5cb7f5066d38ff362abcd5cc64d2bd2e08" translate="yes" xml:space="preserve">
          <source>The same axis can be used several times. In that case, every use reduces the corresponding original dimension:</source>
          <target state="translated">同一轴可以多次使用。在这种情况下,每次使用都会减少相应的原始尺寸。</target>
        </trans-unit>
        <trans-unit id="48a74e2709e394bc98ff4e370f8920b6550d09a0" translate="yes" xml:space="preserve">
          <source>The same function can operate on a 4-D array:</source>
          <target state="translated">同样的功能可以在4-D阵列上操作。</target>
        </trans-unit>
        <trans-unit id="54bfa0763e872f148814a7d73d89f2039603e607" translate="yes" xml:space="preserve">
          <source>The same gcc version is used as the one with which Python itself is built on each platform. At the moment this means:</source>
          <target state="translated">在每个平台上,Python本身的构建都使用相同的gcc版本。目前,这意味着:</target>
        </trans-unit>
        <trans-unit id="db94598647ae75e98a229d31f17501768537975a" translate="yes" xml:space="preserve">
          <source>The same results can be obtained by using the name of the second column (&lt;code&gt;&quot;p&quot;&lt;/code&gt;) as key instead of its index (1):</source>
          <target state="translated">通过将第二列的名称（ &lt;code&gt;&quot;p&quot;&lt;/code&gt; ）用作键而不是其索引（1），可以获得相同的结果：</target>
        </trans-unit>
        <trans-unit id="0259137762b94ac22ad991901b42b9be660a1c59" translate="yes" xml:space="preserve">
          <source>The same works for max and min, if you expand the dimensions:</source>
          <target state="translated">如果你扩大尺寸,对最大和最小也是一样的。</target>
        </trans-unit>
        <trans-unit id="2941e8dc3350840406ccff2f87675580f31546c3" translate="yes" xml:space="preserve">
          <source>The sample points corresponding to the &lt;code&gt;y&lt;/code&gt; values. If &lt;code&gt;x&lt;/code&gt; is None, the sample points are assumed to be evenly spaced &lt;code&gt;dx&lt;/code&gt; apart. The default is None.</source>
          <target state="translated">采样点对应于 &lt;code&gt;y&lt;/code&gt; 值。如果 &lt;code&gt;x&lt;/code&gt; 为None，则假定采样点的 &lt;code&gt;dx&lt;/code&gt; 间隔均匀。默认为无。</target>
        </trans-unit>
        <trans-unit id="52ca25ab3ba5f07f393e1c15a4222278fa9f69d6" translate="yes" xml:space="preserve">
          <source>The scale of the gamma distribution. Must be non-negative. Default is equal to 1.</source>
          <target state="translated">伽马分布的尺度。必须为非负值。默认值等于1。</target>
        </trans-unit>
        <trans-unit id="db0a2a364021746365e2e2dca54712719a934f9d" translate="yes" xml:space="preserve">
          <source>The scale parameter of the distribution. Default is 1. Must be non- negative.</source>
          <target state="translated">分布的比例参数,默认为1,必须为非负值。默认为1,必须是非负数。</target>
        </trans-unit>
        <trans-unit id="da19b6d80b0b211e043d20a99e868d2264fb18da" translate="yes" xml:space="preserve">
          <source>The scale parameter,</source>
          <target state="translated">规模参数。</target>
        </trans-unit>
        <trans-unit id="162cbdbbbf1e2c84bee29866f841c84cd6b13d80" translate="yes" xml:space="preserve">
          <source>The scaling of the covariance matrix in &lt;code&gt;np.polyfit&lt;/code&gt; is different</source>
          <target state="translated">&lt;code&gt;np.polyfit&lt;/code&gt; 中协方差矩阵的缩放比例不同</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
