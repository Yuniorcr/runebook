<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="3e3af0fcef04d64e093680f90bd154da4da6f7e6" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized beta distribution.</source>
          <target state="translated">从参数化的β分布中抽取样本。</target>
        </trans-unit>
        <trans-unit id="66aa1280d92bc58e93f2dd0657680e02202ddedc" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized binomial distribution, where each sample is equal to the number of successes over the n trials.</source>
          <target state="translated">从参数化二项分布中抽取样本,其中每个样本等于n次试验中的成功次数。</target>
        </trans-unit>
        <trans-unit id="803cd0d20a6c49e0eab984068f59353e0ec6f797" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized chi-square distribution.</source>
          <target state="translated">从参数化的齐次分布中抽取样本。</target>
        </trans-unit>
        <trans-unit id="0a07d0ff0927ba822ed7f54576b179ec4780bfd4" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized exponential distribution.</source>
          <target state="translated">从参数化指数分布中抽取样本。</target>
        </trans-unit>
        <trans-unit id="a2f28dab17c9ec69c1e4c0816e2b49d0d97cc8c9" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized gamma distribution.</source>
          <target state="translated">从参数化的伽马分布中抽取样本。</target>
        </trans-unit>
        <trans-unit id="645b194e18330c38a086d019ef409b1ad04a10ac" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized geometric distribution.</source>
          <target state="translated">从参数化的几何分布中抽取样本。</target>
        </trans-unit>
        <trans-unit id="675c1d8f69c01109a94a55f050b7feba6cfeb004" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized hypergeometric distribution. Each sample is the number of good items within a randomly selected subset of size &lt;code&gt;nsample&lt;/code&gt; taken from a set of &lt;code&gt;ngood&lt;/code&gt; good items and &lt;code&gt;nbad&lt;/code&gt; bad items.</source>
          <target state="translated">从参数化的超几何分布中抽取样本。每个样本都是从一组 &lt;code&gt;ngood&lt;/code&gt; 好项目和 &lt;code&gt;nbad&lt;/code&gt; 个坏项目中随机抽取的大小为 &lt;code&gt;nsample&lt;/code&gt; 的子集中的好项目的数量。</target>
        </trans-unit>
        <trans-unit id="0ec5fd25c15e2f401571dd2213b5e63981af1884" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized log-normal distribution.</source>
          <target state="translated">从参数化的对数正态分布中抽取样本。</target>
        </trans-unit>
        <trans-unit id="92c1e4b50e7e0ed6389caf6bd275c9d96e903819" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized logarithmic series distribution.</source>
          <target state="translated">从参数化的对数系列分布中抽取样本。</target>
        </trans-unit>
        <trans-unit id="0418a31cc205f33ce6262d40794bf3e47add1b19" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized logistic distribution.</source>
          <target state="translated">从参数化的逻辑分布中抽取样本。</target>
        </trans-unit>
        <trans-unit id="16ad062ab33ce9488dba4d726621ff0742f56c11" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized negative binomial distribution, where each sample is equal to N, the number of failures that occurred before a total of n successes was reached.</source>
          <target state="translated">从参数化的负二项分布中抽取样本,每个样本等于N,即在总共n次成功之前发生的失败次数。</target>
        </trans-unit>
        <trans-unit id="afe023dcddff604c4223693c51bcae1660f6eba8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized noncentral Fisher distribution.</source>
          <target state="translated">从参数化的非中心费舍尔分布中抽取样本。</target>
        </trans-unit>
        <trans-unit id="0dad06577da3cf941b7346f737f68fc3b67c036b" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized noncentral chi-square distribution.</source>
          <target state="translated">从参数化的非中心奇方分布中抽取样本。</target>
        </trans-unit>
        <trans-unit id="1b7aa6be999ea249ca4e25e9eb3c5a161f178b65" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized normal distribution.</source>
          <target state="translated">从参数化的正态分布中抽取样本。</target>
        </trans-unit>
        <trans-unit id="75a239b9fd8457ca43a81ea8883cb90f669b784d" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized power distribution.</source>
          <target state="translated">从参数化的功率分布中抽取样本。</target>
        </trans-unit>
        <trans-unit id="417f5f8f2a7e8f51ee4be6e5ef1c8c34cc318b2f" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized standard Student&amp;rsquo;s t distribution.</source>
          <target state="translated">从参数化标准学生t分布中抽取样本。</target>
        </trans-unit>
        <trans-unit id="9cfa7b49541ac131db1708e85662c20f82750d1b" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized standard gamma distribution.</source>
          <target state="translated">从参数化的标准伽马分布中抽取样本。</target>
        </trans-unit>
        <trans-unit id="24c6b8b6588f6544b47569ada0a5521ca47031b8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized triangular distribution.</source>
          <target state="translated">从参数化的三角分布中抽取样本。</target>
        </trans-unit>
        <trans-unit id="59ea0a59c91c46f3d89e817e79cad726c3dc2dab" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized uniform distribution.</source>
          <target state="translated">从参数化的均匀分布中抽取样本。</target>
        </trans-unit>
        <trans-unit id="f20dd8e0ca9375ee4c56dd90351efacbd5b573d8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized von Mises distribution.</source>
          <target state="translated">从参数化的冯-米塞斯分布中抽取样本。</target>
        </trans-unit>
        <trans-unit id="cb8b86177c95587cf24b6f015131fe691b9fc3ba" translate="yes" xml:space="preserve">
          <source>Drawn samples.</source>
          <target state="translated">抽到的样品。</target>
        </trans-unit>
        <trans-unit id="1d18cceebff607d37e9bf2c1387fbd956866a568" translate="yes" xml:space="preserve">
          <source>Draws samples in [0, 1] from a power distribution with positive exponent a - 1.</source>
          <target state="translated">从正指数a-1的幂分布中抽取[0,1]的样本。</target>
        </trans-unit>
        <trans-unit id="3494c64843d7663d424ff8535f672114cde4d98a" translate="yes" xml:space="preserve">
          <source>Dropped Support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d056b5f5f0adde2e16d37463c52db860d944e35" translate="yes" xml:space="preserve">
          <source>Dtype for the structured array.</source>
          <target state="translated">结构化数组的D类型。</target>
        </trans-unit>
        <trans-unit id="74a25c41a58aa29ed3adc5f8de64d6df2cab73e9" translate="yes" xml:space="preserve">
          <source>Dtype parameter added to &lt;code&gt;np.linspace&lt;/code&gt; and &lt;code&gt;np.logspace&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ed446a6c6e03872b9c3414013b747e673d0a8f" translate="yes" xml:space="preserve">
          <source>Dtypes for structured arrays can be specified in several forms, but all forms specify at least the data type and field name. For details see &lt;a href=&quot;../../user/basics.rec#module-numpy.doc.structured_arrays&quot;&gt;&lt;code&gt;doc.structured_arrays&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c6259462846b5f9baee7053eaac196aa6133053" translate="yes" xml:space="preserve">
          <source>Dtypes for structured arrays can be specified in several forms, but all forms specify at least the data type and field name. For details see &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#module-numpy.doc.structured_arrays&quot;&gt;&lt;code&gt;doc.structured_arrays&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以以几种形式指定结构化数组的Dtype，但是所有形式都至少指定数据类型和字段名称。有关详细信息，请参阅&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#module-numpy.doc.structured_arrays&quot;&gt; &lt;code&gt;doc.structured_arrays&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ffaaa2445408170b57b919ca6485e258a7c95d8b" translate="yes" xml:space="preserve">
          <source>Duda, R. O., Hart, P. E., and Stork, D. G., &amp;ldquo;Pattern Classification,&amp;rdquo; 2nd ed., New York: Wiley, 2001.</source>
          <target state="translated">Duda，RO，Hart，PE和Stork，DG，&amp;ldquo;模式分类&amp;rdquo;，第二版，纽约：Wiley，2001年。</target>
        </trans-unit>
        <trans-unit id="6baaefd65351906a350ba168fbf221f0d184adfa" translate="yes" xml:space="preserve">
          <source>Due to floating point rounding the resulting array may not be Hermitian, the diagonal elements may not be 1, and the elements may not satisfy the inequality abs(a) &amp;lt;= 1. The real and imaginary parts are clipped to the interval [-1, 1] in an attempt to improve on that situation but is not much help in the complex case.</source>
          <target state="translated">由于浮点舍入，结果数组可能不是Hermitian，对角元素可能不是1，并且这些元素可能不满足不等式abs（a）&amp;lt;=1。实部和虚部均裁剪为区间[-1 ，[1]试图改善这种情况，但在复杂情况下并没有太大帮助。</target>
        </trans-unit>
        <trans-unit id="d5668939217d0a50f3a990081bee30e034ec210d" translate="yes" xml:space="preserve">
          <source>Due to limitations in the interpretation of structured dtypes, dtypes with fields with empty names will have the names replaced by &amp;lsquo;f0&amp;rsquo;, &amp;lsquo;f1&amp;rsquo;, etc. Such arrays will not round-trip through the format entirely accurately. The data is intact; only the field names will differ. We are working on a fix for this. This fix will not require a change in the file format. The arrays with such structures can still be saved and restored, and the correct dtype may be restored by using the &lt;code&gt;loadedarray.view(correct_dtype)&lt;/code&gt; method.</source>
          <target state="translated">由于对结构化dtypes的解释的限制，具有空名称字段的dtypes的名称将替换为'f0'，'f1'等。此类数组将无法完全准确地遍历格式。数据完整无缺；只有字段名称会有所不同。我们正在为此修复。此修复程序不需要更改文件格式。具有此类结构的数组仍可以保存和还原，并且可以使用 &lt;code&gt;loadedarray.view(correct_dtype)&lt;/code&gt; 方法还原正确的dtype。</target>
        </trans-unit>
        <trans-unit id="be47cf08679632a886113408bbed677d155a3d74" translate="yes" xml:space="preserve">
          <source>Dump a pickle of the array to the specified file.</source>
          <target state="translated">将数组的pickle转到指定的文件中。</target>
        </trans-unit>
        <trans-unit id="c5317185019827371b1e31a396e0d441834d3252" translate="yes" xml:space="preserve">
          <source>Dump a pickle of the array to the specified file. The array can be read back with pickle.load or numpy.load.</source>
          <target state="translated">将数组的pickle转储到指定的文件中。数组可以用pickle.load或numpy.load来读取。</target>
        </trans-unit>
        <trans-unit id="7a2c1b02316fce9ee22b42f7f9087251340c710e" translate="yes" xml:space="preserve">
          <source>During iteration, you may want to use the index of the current element in a computation. For example, you may want to visit the elements of an array in memory order, but use a C-order, Fortran-order, or multidimensional index to look up values in a different array.</source>
          <target state="translated">在迭代过程中,你可能想在计算中使用当前元素的索引。例如,你可能想按内存顺序访问一个数组的元素,但使用C顺序、Fortran顺序或多维索引来查找不同数组中的值。</target>
        </trans-unit>
        <trans-unit id="3bf08c964c7c95130d665e4d98704726bfb41a50" translate="yes" xml:space="preserve">
          <source>During the beta/RC phase, an explicit request for testing the binaries with several other libraries (SciPy/Matplotlib/Pygame) should be posted on the mailing list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b260078602d9938ed8897f4dbe8eacdc7db28c29" translate="yes" xml:space="preserve">
          <source>During the everyday project activities, council members participate in all discussions, code review and other project activities as peers with all other Contributors and the Community. In these everyday activities, Council Members do not have any special power or privilege through their membership on the Council. However, it is expected that because of the quality and quantity of their contributions and their expert knowledge of the Project Software and Services that Council Members will provide useful guidance, both technical and in terms of project direction, to potentially less experienced contributors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a97e818f2855e4e5e1bc73604c63d51f0dc4bf1" translate="yes" xml:space="preserve">
          <source>Durran D. R. (1999) Numerical Methods for Wave Equations in Geophysical Fluid Dynamics. New York: Springer.</source>
          <target state="translated">Durran D.R.(1999),《地球物理流体动力学中波浪方程的数值方法》。纽约。Springer。</target>
        </trans-unit>
        <trans-unit id="e0184adedf913b076626646d3f52c3b49c39ad6d" translate="yes" xml:space="preserve">
          <source>E</source>
          <target state="translated">E</target>
        </trans-unit>
        <trans-unit id="26aa5b06114619ee705d4e196e09408f75d82651" translate="yes" xml:space="preserve">
          <source>E.R. Kanasewich, &amp;ldquo;Time Sequence Analysis in Geophysics&amp;rdquo;, The University of Alberta Press, 1975, pp. 106-108.</source>
          <target state="translated">ER Kanasewich，《地球物理学中的时序分析》，阿尔伯塔大学出版社，1975年，第106-108页。</target>
        </trans-unit>
        <trans-unit id="7020945b62676f3792048d52264e61eaf1f2f06e" translate="yes" xml:space="preserve">
          <source>E.R. Kanasewich, &amp;ldquo;Time Sequence Analysis in Geophysics&amp;rdquo;, The University of Alberta Press, 1975, pp. 109-110.</source>
          <target state="translated">ER Kanasewich，《地球物理学中的时序分析》，阿尔伯塔大学出版社，1975年，第109-110页。</target>
        </trans-unit>
        <trans-unit id="3bd1ccd7ec68cbb9d222ef47028613ad14f66cf8" translate="yes" xml:space="preserve">
          <source>E.R. Kanasewich, &amp;ldquo;Time Sequence Analysis in Geophysics&amp;rdquo;, The University of Alberta Press, 1975, pp. 177-178.</source>
          <target state="translated">ER Kanasewich，《地球物理学中的时序分析》，阿尔伯塔大学出版社，1975年，第177-178页。</target>
        </trans-unit>
        <trans-unit id="9282259a9bffd46a322a6acfc9997c91e019e7d4" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object in the selection tuple serves to expand the dimensions of the resulting selection by one unit-length dimension. The added dimension is the position of the &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object in the selection tuple.</source>
          <target state="translated">选择元组中的每个&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;对象用于将结果选择的尺寸扩展一个单位长度尺寸。添加的维是新&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;对象在选择元组中的位置。</target>
        </trans-unit>
        <trans-unit id="073efad576bf9e16c2944aef4f81bdac4eda711d" translate="yes" xml:space="preserve">
          <source>Each NumPy module exposes &lt;a href=&quot;#numpy.testing.Tester.bench&quot;&gt;&lt;code&gt;bench&lt;/code&gt;&lt;/a&gt; in its namespace to run all benchmarks for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2eda913d3072244fb087de35642a2b1eb54ff25" translate="yes" xml:space="preserve">
          <source>Each NumPy module exposes &lt;a href=&quot;#numpy.testing.Tester.test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; in its namespace to run all tests for it. For example, to run all tests for numpy.lib:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f76bc743577aee15d005972242975d93c3b7f843" translate="yes" xml:space="preserve">
          <source>Each array in the tuple has the same shape as the &lt;code&gt;indices&lt;/code&gt; array.</source>
          <target state="translated">元组中的每个数组都具有与 &lt;code&gt;indices&lt;/code&gt; 数组相同的形状。</target>
        </trans-unit>
        <trans-unit id="386efca9f91ba00773f6c9bc7ed1232d730522e6" translate="yes" xml:space="preserve">
          <source>Each array must have the same shape.</source>
          <target state="translated">每个数组必须具有相同的形状。</target>
        </trans-unit>
        <trans-unit id="286a71006dd39afde343b3c45a4fd98ff7cec30e" translate="yes" xml:space="preserve">
          <source>Each boolean array corresponds to a function in &lt;code&gt;funclist&lt;/code&gt;. Wherever &lt;code&gt;condlist[i]&lt;/code&gt; is True, &lt;code&gt;funclist[i](x)&lt;/code&gt; is used as the output value.</source>
          <target state="translated">每个布尔数组对应于 &lt;code&gt;funclist&lt;/code&gt; 中的一个函数。只要 &lt;code&gt;condlist[i]&lt;/code&gt; 为True， &lt;code&gt;funclist[i](x)&lt;/code&gt; 用作输出值。</target>
        </trans-unit>
        <trans-unit id="eef78733a1d1f7432ec1ab2af99217db7ce78c93" translate="yes" xml:space="preserve">
          <source>Each boolean array in &lt;code&gt;condlist&lt;/code&gt; selects a piece of &lt;code&gt;x&lt;/code&gt;, and should therefore be of the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;condlist&lt;/code&gt; 中的每个布尔数组都选择一个 &lt;code&gt;x&lt;/code&gt; ，因此应与 &lt;code&gt;x&lt;/code&gt; 具有相同的形状。</target>
        </trans-unit>
        <trans-unit id="8fe6ffb6ecffd6c39387e8f0ab0c3a109b7064bf" translate="yes" xml:space="preserve">
          <source>Each built-in data-type has a character code (the updated Numeric typecodes), that uniquely identifies it.</source>
          <target state="translated">每个内置的数据类型都有一个字符代码(更新后的Numeric类型代码),它是唯一的标识。</target>
        </trans-unit>
        <trans-unit id="a69a75e46ca3ac2d199e74b13f3b32f8dd1d6b80" translate="yes" xml:space="preserve">
          <source>Each differentiation is multiplied by &lt;code&gt;scl&lt;/code&gt;. The end result is multiplication by &lt;code&gt;scl**m&lt;/code&gt;. This is for use in a linear change of variable. (Default: 1)</source>
          <target state="translated">每个微分乘以 &lt;code&gt;scl&lt;/code&gt; 。最终结果是与 &lt;code&gt;scl**m&lt;/code&gt; 相乘。用于变量的线性变化。（默认值：1）</target>
        </trans-unit>
        <trans-unit id="80d6286823e7a8996b335e27ee039bd71682bf33" translate="yes" xml:space="preserve">
          <source>Each dimension in the signature is matched to a dimension of the corresponding passed-in array, starting from the end of the shape tuple.</source>
          <target state="translated">签名中的每个维度从形状元组的末尾开始,与相应的传入数组的维度相匹配。</target>
        </trans-unit>
        <trans-unit id="e3a7c87b9ea1dd98d592dea35e0511973a19c5ea" translate="yes" xml:space="preserve">
          <source>Each dimension in the signature is matched to a dimension of the corresponding passed-in array, starting from the end of the shape tuple. These are the core dimensions, and they must be present in the arrays, or an error will be raised.</source>
          <target state="translated">签名中的每一个维度都与相应的传入数组的维度相匹配,从形状元组的末端开始。这些是核心维度,它们必须存在于数组中,否则会出现错误。</target>
        </trans-unit>
        <trans-unit id="f8fa7f34f98b652b735f9d41844bf81c524a5373" translate="yes" xml:space="preserve">
          <source>Each element of &lt;code&gt;a&lt;/code&gt; represents a bit-field that should be unpacked into a binary-valued output array. The shape of the output array is either 1-D (if &lt;code&gt;axis&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;) or the same shape as the input array with unpacking done along the axis specified.</source>
          <target state="translated">的每个元件 &lt;code&gt;a&lt;/code&gt; 代表一个位字段应该被解压成二进制值输出阵列。输出数组的形状可以是1-D（如果 &lt;code&gt;axis&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ），也可以是与输入数组相同的形状，并且沿指定的轴进行拆包。</target>
        </trans-unit>
        <trans-unit id="50237f597aa5c58319566769ed4e784a20d0c8c4" translate="yes" xml:space="preserve">
          <source>Each element of the sum of the &amp;lsquo;ipmt&amp;rsquo; and &amp;lsquo;ppmt&amp;rsquo; arrays should equal &amp;lsquo;pmt&amp;rsquo;.</source>
          <target state="translated">&amp;ldquo; ipmt&amp;rdquo;和&amp;ldquo; ppmt&amp;rdquo;数组之和的每个元素应等于&amp;ldquo; pmt&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="20a2380f652b4d55cd4c96370ca8c7d2de50620c" translate="yes" xml:space="preserve">
          <source>Each entry in the mymethods array is a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyMethodDef&quot;&gt;&lt;code&gt;PyMethodDef&lt;/code&gt;&lt;/a&gt; structure containing 1) the Python name, 2) the C-function that implements the function, 3) flags indicating whether or not keywords are accepted for this function, and 4) The docstring for the function. Any number of functions may be defined for a single module by adding more entries to this table. The last entry must be all NULL as shown to act as a sentinel. Python looks for this entry to know that all of the functions for the module have been defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f33bf09c046e31c2241219b2051cb5ec2d5021c" translate="yes" xml:space="preserve">
          <source>Each entry will be the default for the corresponding column</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6596e910451a16280ea499b967185410396fa721" translate="yes" xml:space="preserve">
          <source>Each function is evaluated over &lt;code&gt;x&lt;/code&gt; wherever its corresponding condition is True. It should take a 1d array as input and give an 1d array or a scalar value as output. If, instead of a callable, a scalar is provided then a constant function (&lt;code&gt;lambda x: scalar&lt;/code&gt;) is assumed.</source>
          <target state="translated">每个功能之上评价 &lt;code&gt;x&lt;/code&gt; 无论其对应的条件为真。它应该以1d数组作为输入，并给出1d数组或标量值作为输出。如果提供了标量而不是可调用的标 &lt;code&gt;lambda x: scalar&lt;/code&gt; 则假定为常数函数（lambda x：scalar）。</target>
        </trans-unit>
        <trans-unit id="8d8deda694e466984ce525e906c00ea4f5dea09d" translate="yes" xml:space="preserve">
          <source>Each generalized ufunc has information associated with it that states what the &amp;ldquo;core&amp;rdquo; dimensionality of the inputs is, as well as the corresponding dimensionality of the outputs (the element-wise ufuncs have zero core dimensions). The list of the core dimensions for all arguments is called the &amp;ldquo;signature&amp;rdquo; of a ufunc. For example, the ufunc numpy.add has signature &lt;code&gt;(),()-&amp;gt;()&lt;/code&gt; defining two scalar inputs and one scalar output.</source>
          <target state="translated">每个广义ufunc都有与之相关的信息，该信息说明输入的&amp;ldquo;核心&amp;rdquo;维数是什么，以及输出的相应维数（逐个元素的ufunc具有零核心维）。所有参数的核心维度列表称为ufunc的&amp;ldquo;签名&amp;rdquo;。例如，ufunc numpy.add具有签名 &lt;code&gt;(),()-&amp;gt;()&lt;/code&gt; ,它们定义两个标量输入和一个标量输出。</target>
        </trans-unit>
        <trans-unit id="93ff2ff5db4665bc2536253e2cbc256cc6ee369b" translate="yes" xml:space="preserve">
          <source>Each item is used as an &amp;ldquo;op_axes&amp;rdquo; argument to an nditer</source>
          <target state="translated">每个项目都用作nditer的&amp;ldquo; op_axes&amp;rdquo;参数</target>
        </trans-unit>
        <trans-unit id="6515db7940afb238e42bf63e06ca75d53b616e9e" translate="yes" xml:space="preserve">
          <source>Each key can be a column index or a column name, and the corresponding value should be a single object. We can use the special key &lt;code&gt;None&lt;/code&gt; to define a default for all columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83888ab60bad511e4b53bdc1db03bb5f1c808f79" translate="yes" xml:space="preserve">
          <source>Each line past the first &lt;code&gt;skip_header&lt;/code&gt; lines is split at the &lt;code&gt;delimiter&lt;/code&gt; character, and characters following the &lt;code&gt;comments&lt;/code&gt; character are discarded.</source>
          <target state="translated">&lt;code&gt;skip_header&lt;/code&gt; 第一个skip_header行的每一行都在 &lt;code&gt;delimiter&lt;/code&gt; 处分割，并且 &lt;code&gt;comments&lt;/code&gt; 字符之后的字符将被丢弃。</target>
        </trans-unit>
        <trans-unit id="af447abfb761a63b2a173a6fe4db497d82a1d986" translate="yes" xml:space="preserve">
          <source>Each module should have a docstring with at least a summary line. Other sections are optional, and should be used in the same order as for documenting functions when they are appropriate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13efd9029e94adb763eb953172be3877d35b0214" translate="yes" xml:space="preserve">
          <source>Each of the arithmetic operations (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;//&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;divmod()&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; or &lt;code&gt;pow()&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;) and the comparisons (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;) is equivalent to the corresponding universal function (or &lt;a href=&quot;../glossary#term-ufunc&quot;&gt;ufunc&lt;/a&gt; for short) in NumPy. For more information, see the section on &lt;a href=&quot;ufuncs#ufuncs&quot;&gt;Universal Functions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3956c5acda082528edb0dd788f86e08b90ce29c7" translate="yes" xml:space="preserve">
          <source>Each of the arithmetic operations (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;//&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;divmod()&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; or &lt;code&gt;pow()&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;) and the comparisons (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;) is equivalent to the corresponding universal function (or &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; for short) in NumPy. For more information, see the section on &lt;a href=&quot;ufuncs#ufuncs&quot;&gt;Universal Functions&lt;/a&gt;.</source>
          <target state="translated">每个算术运算（ &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt; ， &lt;code&gt;//&lt;/code&gt; ， &lt;code&gt;%&lt;/code&gt; ， &lt;code&gt;divmod()&lt;/code&gt; ， &lt;code&gt;**&lt;/code&gt; 或 &lt;code&gt;pow()&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;^&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;~&lt;/code&gt; ）和比较（ &lt;code&gt;==&lt;/code&gt; ， &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; ， &lt;code&gt;!=&lt;/code&gt; ）等效于相应的通用功能（或&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt;在NumPy的简称）。有关更多信息，请参见&lt;a href=&quot;ufuncs#ufuncs&quot;&gt;通用函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce900752c03b63d004b95034fc7fe45e45781bb2" translate="yes" xml:space="preserve">
          <source>Each of these 12 classes is collected into a &lt;code&gt;unittest.TestSuite&lt;/code&gt;, which is then executed. Errors and failures are summed together and returned as the exit argument. Any non-zero result indicates that at least one test did not pass.</source>
          <target state="translated">这12个类中的每一个都被收集到 &lt;code&gt;unittest.TestSuite&lt;/code&gt; 中，然后执行它。错误和失败加在一起，并作为退出参数返回。任何非零结果表示至少一项测试未通过。</target>
        </trans-unit>
        <trans-unit id="534d5807de7d2badcef1e7e804770614e9153a49" translate="yes" xml:space="preserve">
          <source>Each of these sub-topics is covered in the following sub-sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67c4cfb6e2d44f4338462a5c73308f6ff60ab98" translate="yes" xml:space="preserve">
          <source>Each row in the text file must have the same number of values.</source>
          <target state="translated">文本文件中的每一行必须有相同数量的值。</target>
        </trans-unit>
        <trans-unit id="8b09b89b09738ea85b440f6b9b0782f598ebe968" translate="yes" xml:space="preserve">
          <source>Each sequence should be of integer or boolean type. Boolean sequences will be interpreted as boolean masks for the corresponding dimension (equivalent to passing in &lt;code&gt;np.nonzero(boolean_sequence)&lt;/code&gt;).</source>
          <target state="translated">每个序列应为整数或布尔类型。布尔序列将被解释为对应维的布尔掩码（等效于传递 &lt;code&gt;np.nonzero(boolean_sequence)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b117b16ba13396092e447a51f24074ff2e6bd854" translate="yes" xml:space="preserve">
          <source>Each test defined by the &lt;code&gt;VectorTestCase&lt;/code&gt; class extracts the python function it is trying to test by accessing the &lt;code&gt;Vector&lt;/code&gt; module&amp;rsquo;s dictionary:</source>
          <target state="translated">&lt;code&gt;VectorTestCase&lt;/code&gt; 类定义的每个测试都通过访问 &lt;code&gt;Vector&lt;/code&gt; 模块的字典来提取其正尝试测试的python函数：</target>
        </trans-unit>
        <trans-unit id="6083c3d38cbd0a21c59fda4f10850fe83ec68a22" translate="yes" xml:space="preserve">
          <source>Each tuple has the form &lt;code&gt;(fieldname, datatype, shape)&lt;/code&gt; where shape is optional. &lt;code&gt;fieldname&lt;/code&gt; is a string (or tuple if titles are used, see &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt; below), &lt;code&gt;datatype&lt;/code&gt; may be any object convertible to a datatype, and &lt;code&gt;shape&lt;/code&gt; is a tuple of integers specifying subarray shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7730362892427e71964e48c12006a9cf86055b3" translate="yes" xml:space="preserve">
          <source>Each ufunc consists of an elementary function that performs the most basic operation on the smallest portion of array arguments (e.g. adding two numbers is the most basic operation in adding two arrays). The ufunc applies the elementary function multiple times on different parts of the arrays. The input/output of elementary functions can be vectors; e.g., the elementary function of inner1d takes two vectors as input.</source>
          <target state="translated">每个ufunc由一个基本函数组成,该函数对数组参数的最小部分执行最基本的操作(例如,将两个数字相加是将两个数组相加中最基本的操作)。ufunc对数组的不同部分多次应用基本函数。基本函数的输入/输出可以是向量,例如,inner1d的基本函数以两个向量作为输入。</target>
        </trans-unit>
        <trans-unit id="cb1cf57d2ff93f75da1bd8ea2b2acd61c3fea8cd" translate="yes" xml:space="preserve">
          <source>Each universal function takes array inputs and produces array outputs by performing the core function element-wise on the inputs (where an element is generally a scalar, but can be a vector or higher-order sub-array for generalized ufuncs). Standard broadcasting rules are applied so that inputs not sharing exactly the same shapes can still be usefully operated on. Broadcasting can be understood by four rules:</source>
          <target state="translated">每个通用函数都接受数组输入,并通过在输入上按元素执行核心函数来产生数组输出(其中元素通常是一个标量,但对于通用的ufuncs来说,可以是一个向量或高阶子数组)。标准的广播规则被应用,因此,对于形状不完全相同的输入,仍然可以进行有效的操作。广播可以通过四个规则来理解。</target>
        </trans-unit>
        <trans-unit id="778a8f870adb20070c9bbd4345579e90072a320d" translate="yes" xml:space="preserve">
          <source>Easier setup and teardown functions / methods</source>
          <target state="translated">更简单的设置和拆卸功能/方法</target>
        </trans-unit>
        <trans-unit id="2797646a63f7af5bb42f88a4088468f8dc30c1ee" translate="yes" xml:space="preserve">
          <source>Edit pavement.py and setup.py as detailed in HOWTO_RELEASE:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2810e44da03a82e21b0a6385cc2c1eef5fd13ec6" translate="yes" xml:space="preserve">
          <source>Edit the &lt;code&gt;azure/posix.yml&lt;/code&gt; and &lt;code&gt;azure/windows.yml&lt;/code&gt; files to make sure they have the correct version, and put in the commit hash for the &lt;code&gt;REL&lt;/code&gt; commit created above for &lt;code&gt;BUILD_COMMIT&lt;/code&gt;, see an _example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e9fb2ea6c3b8c3ce97645eb902c348d859f36d" translate="yes" xml:space="preserve">
          <source>Editor</source>
          <target state="translated">Editor</target>
        </trans-unit>
        <trans-unit id="93d5c22f934ab8df1b20f8c3472b63bf839853fa" translate="yes" xml:space="preserve">
          <source>Effect of the &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">效果的&lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;说法。</target>
        </trans-unit>
        <trans-unit id="b16a3ec6ab9f466c4d89051f80bac7ab3d7a2dde" translate="yes" xml:space="preserve">
          <source>Effect of the &lt;code&gt;shrink&lt;/code&gt; parameter.</source>
          <target state="translated">效果的 &lt;code&gt;shrink&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="15b4ace616414347d2dd3d2801314c174bc7ba08" translate="yes" xml:space="preserve">
          <source>Effectively, this implements:</source>
          <target state="translated">实际上,这实现了。</target>
        </trans-unit>
        <trans-unit id="76eeaec1ccfef9304ec0a31b036423f1378c5288" translate="yes" xml:space="preserve">
          <source>Efficient</source>
          <target state="translated">Efficient</target>
        </trans-unit>
        <trans-unit id="2b4d17c36c1ff28a27a4b2931f3e20dd1dbef5a2" translate="yes" xml:space="preserve">
          <source>Efficient multi-dimensional iterator object to iterate over arrays.</source>
          <target state="translated">高效的多维迭代器对象,用于迭代数组。</target>
        </trans-unit>
        <trans-unit id="7e03cfade90e6c295c76156a8e2c563a63efa318" translate="yes" xml:space="preserve">
          <source>Efficient multi-dimensional iterator object to iterate over arrays. To get started using this object, see the &lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;introductory guide to array iteration&lt;/a&gt;.</source>
          <target state="translated">有效的多维迭代器对象，可以遍历数组。要开始使用此对象，请参阅&lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;数组迭代入门指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="036e376170c1d3906a5f0a04018619e235105dc6" translate="yes" xml:space="preserve">
          <source>Effort to spend on solving the overlap problem (maximum number of candidate solutions to consider). The following special values are recognized:</source>
          <target state="translated">在解决重叠问题上所花费的精力(要考虑的候选解决方案的最大数量)。下列特殊值得到承认:</target>
        </trans-unit>
        <trans-unit id="ab3820529f3b083c6a31ff8350ee28b11115b842" translate="yes" xml:space="preserve">
          <source>Effort to spend on solving the overlap problem. See &lt;a href=&quot;numpy.shares_memory#numpy.shares_memory&quot;&gt;&lt;code&gt;shares_memory&lt;/code&gt;&lt;/a&gt; for details. Default for &lt;code&gt;may_share_memory&lt;/code&gt; is to do a bounds check.</source>
          <target state="translated">花费精力解决重叠问题。有关详细信息，请参见&lt;a href=&quot;numpy.shares_memory#numpy.shares_memory&quot;&gt; &lt;code&gt;shares_memory&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;may_share_memory&lt;/code&gt; 的默认值是进行边界检查。</target>
        </trans-unit>
        <trans-unit id="444baf679021343f134e3ab4afdb77852c13f5b7" translate="yes" xml:space="preserve">
          <source>Einstein summation convention.</source>
          <target state="translated">爱因斯坦求和惯例。</target>
        </trans-unit>
        <trans-unit id="9e7269d88813a122dd6b4c8836b591f55f6ef940" translate="yes" xml:space="preserve">
          <source>Einsum</source>
          <target state="translated">Einsum</target>
        </trans-unit>
        <trans-unit id="b7f8aa394c8c17e22a13e4ec50ff49bf4fdd395d" translate="yes" xml:space="preserve">
          <source>Einsum optimization path updates and efficiency improvements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f574da7dabc16cec8dc28f2e16dcdf93d39e214" translate="yes" xml:space="preserve">
          <source>Either &amp;lsquo;inv&amp;rsquo; or &amp;lsquo;zig&amp;rsquo;. &amp;lsquo;inv&amp;rsquo; uses the default inverse CDF method. &amp;lsquo;zig&amp;rsquo; uses the much faster Ziggurat method of Marsaglia and Tsang.</source>
          <target state="translated">&amp;ldquo; inv&amp;rdquo;或&amp;ldquo; zig&amp;rdquo;。'inv'使用默认的逆CDF方法。&amp;ldquo; zig&amp;rdquo;使用Marsaglia和Tsang更快的Ziggurat方法。</target>
        </trans-unit>
        <trans-unit id="41ec8a6c5a0f22c1b241625049fb5165828e9c89" translate="yes" xml:space="preserve">
          <source>Either &lt;a href=&quot;ufunc#c.PyUFunc_One&quot;&gt;&lt;code&gt;PyUFunc_One&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ufunc#c.PyUFunc_Zero&quot;&gt;&lt;code&gt;PyUFunc_Zero&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ufunc#c.PyUFunc_None&quot;&gt;&lt;code&gt;PyUFunc_None&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;PyUFunc_AllOnes&lt;/code&gt; to indicate the identity for this operation. It is only used for a reduce-like call on an empty array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f248b6168fbf2f57439344bf599f0d52d7a807c7" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or a dictionary containing low-level casting functions for user- defined data-types. Each function is wrapped in a &lt;code&gt;PyCObject *&lt;/code&gt; and keyed by the data-type number.</source>
          <target state="translated">任一 &lt;code&gt;NULL&lt;/code&gt; 或含词典低电平铸造函数用户定义的数据类型。每个函数都包装在一个 &lt;code&gt;PyCObject *&lt;/code&gt; 中,并以数据类型编号为键。</target>
        </trans-unit>
        <trans-unit id="cd680ae51259fbdc5100a31577a59d7a7923df2f" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or an array of &lt;a href=&quot;array#c.NPY_NSCALARKINDS&quot;&gt;&lt;code&gt;NPY_NSCALARKINDS&lt;/code&gt;&lt;/a&gt; pointers. These pointers should each be either &lt;code&gt;NULL&lt;/code&gt; or a pointer to an array of integers (terminated by &lt;a href=&quot;dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt;) indicating data-types that a scalar of this data-type of the specified kind can be cast to safely (this usually means without losing precision).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff36def358c4174701abf75ea4d4e0cdcf5bd477" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or an array of &lt;a href=&quot;c-api.array#c.NPY_NSCALARKINDS&quot;&gt;&lt;code&gt;NPY_NSCALARKINDS&lt;/code&gt;&lt;/a&gt; pointers. These pointers should each be either &lt;code&gt;NULL&lt;/code&gt; or a pointer to an array of integers (terminated by &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt;) indicating data-types that a scalar of this data-type of the specified kind can be cast to safely (this usually means without losing precision).</source>
          <target state="translated">任一 &lt;code&gt;NULL&lt;/code&gt; 或阵列&lt;a href=&quot;c-api.array#c.NPY_NSCALARKINDS&quot;&gt; &lt;code&gt;NPY_NSCALARKINDS&lt;/code&gt; &lt;/a&gt;指针。这些指针应分别为 &lt;code&gt;NULL&lt;/code&gt; 或指向整数数组（以&lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; &lt;/a&gt;终止）的指针，这些整数指示可以安全地将指定类型的此数据类型的标量转换为数据类型的数据类型（这通常意味着在不损失精度的情况下）。</target>
        </trans-unit>
        <trans-unit id="9b68604ef80074abda088f5c021808f55b2ed04d" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or an array of integers (terminated by &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; ) indicated data-types that this data-type can be cast to safely (this usually means without losing precision).</source>
          <target state="translated">任一 &lt;code&gt;NULL&lt;/code&gt; 或整数的数组（通过终止&lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; &lt;/a&gt;）指示的数据类型，该数据类型可以转换为安全（这通常手段，而不会失去精度）。</target>
        </trans-unit>
        <trans-unit id="8a8e73551f33a77ec9147f05121309347af67814" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or an array of integers (terminated by &lt;a href=&quot;dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; ) indicated data-types that this data-type can be cast to safely (this usually means without losing precision).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="accffd1618e3de5c69c33d1510a23e42c114bdf3" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;None&lt;/code&gt; to indicate a C-style contiguous array or a Tuple of strides which provides the number of bytes needed to jump to the next array element in the corresponding dimension. Each entry must be an integer (a Python &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;). As with shape, the values may be larger than can be represented by a C &amp;ldquo;int&amp;rdquo; or &amp;ldquo;long&amp;rdquo;; the calling code should handle this appropriately, either by raising an error, or by using &lt;code&gt;Py_LONG_LONG&lt;/code&gt; in C. The default is &lt;code&gt;None&lt;/code&gt; which implies a C-style contiguous memory buffer. In this model, the last dimension of the array varies the fastest. For example, the default strides tuple for an object whose array entries are 8 bytes long and whose shape is (10,20,30) would be (4800, 240, 8)</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;None&lt;/code&gt; 表示C样式的连续数组，或者&amp;ldquo;跨步元组&amp;rdquo;提供跨越到相应维度中的下一个数组元素所需的字节数。每个条目必须是一个整数（Python &lt;code&gt;int&lt;/code&gt; 或 &lt;code&gt;long&lt;/code&gt; ）。与形状一样，值可能大于C的&amp;ldquo; int&amp;rdquo;或&amp;ldquo; long&amp;rdquo;表示的值；调用代码应该通过引发错误或通过在C中使用 &lt;code&gt;Py_LONG_LONG&lt;/code&gt; 来适当地处理此问题。默认值为 &lt;code&gt;None&lt;/code&gt; ，这意味着C风格的连续内存缓冲区。在此模型中，阵列的最后一个维度变化最快。例如，如果对象的数组数组长度为8个字节，形状为（10,20,30），则其默认跨度元组将为（4800，240，8）</target>
        </trans-unit>
        <trans-unit id="2e35b148ce133a87759db1169ada9bc7afe8b136" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;PyUFunc_One&lt;/code&gt;, &lt;code&gt;PyUFunc_Zero&lt;/code&gt;, &lt;code&gt;PyUFunc_None&lt;/code&gt; or &lt;code&gt;PyUFunc_AllOnes&lt;/code&gt; to indicate the identity for this operation. It is only used for a reduce-like call on an empty array.</source>
          <target state="translated">无论是 &lt;code&gt;PyUFunc_One&lt;/code&gt; ， &lt;code&gt;PyUFunc_Zero&lt;/code&gt; ， &lt;code&gt;PyUFunc_None&lt;/code&gt; 或 &lt;code&gt;PyUFunc_AllOnes&lt;/code&gt; 以表示此操作的身份。它仅用于对空数组进行类似reduce的调用。</target>
        </trans-unit>
        <trans-unit id="fb67ce0cbc08322db9293cceafb38eefe75acb01" translate="yes" xml:space="preserve">
          <source>Either None to indicate a C-style contiguous array or a Tuple of strides which provides the number of bytes needed to jump to the next array element in the corresponding dimension. Each entry must be an integer (a Python &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;). As with shape, the values may be larger than can be represented by a C &amp;ldquo;int&amp;rdquo; or &amp;ldquo;long&amp;rdquo;; the calling code should handle this appropriately, either by raising an error, or by using &lt;code&gt;Py_LONG_LONG&lt;/code&gt; in C. The default is None which implies a C-style contiguous memory buffer. In this model, the last dimension of the array varies the fastest. For example, the default strides tuple for an object whose array entries are 8 bytes long and whose shape is (10,20,30) would be (4800, 240, 8)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987f54d54272ffd5f21f8146bd411a9086f8f96d" translate="yes" xml:space="preserve">
          <source>Either a basic-type description string as in &lt;em&gt;typestr&lt;/em&gt; or another list (for nested structured types)</source>
          <target state="translated">如&lt;em&gt;typestr中&lt;/em&gt;的基本类型描述字符串或其他列表（对于嵌套结构化类型）</target>
        </trans-unit>
        <trans-unit id="e36f94dd4a5bc304e7b8e5a337101261c2694c11" translate="yes" xml:space="preserve">
          <source>Either a data-type, a tuple of data-types, or a special signature string indicating the input and output types of a ufunc. This argument allows you to provide a specific signature for the 1-d loop to use in the underlying calculation. If the loop specified does not exist for the ufunc, then a TypeError is raised. Normally, a suitable loop is found automatically by comparing the input types with what is available and searching for a loop with data-types to which all inputs can be cast safely. This keyword argument lets you bypass that search and choose a particular loop. A list of available signatures is provided by the &lt;strong&gt;types&lt;/strong&gt; attribute of the ufunc object. For backwards compatibility this argument can also be provided as &lt;em&gt;sig&lt;/em&gt;, although the long form is preferred. Note that this should not be confused with the generalized ufunc &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; that is stored in the &lt;strong&gt;signature&lt;/strong&gt; attribute of the of the ufunc object.</source>
          <target state="translated">数据类型，数据类型的元组或指示ufunc的输入和输出类型的特殊签名字符串。此参数允许您为1-d循环提供特定的签名，以在基础计算中使用。如果为ufunc指定的循环不存在，则引发TypeError。通常，通过将输入类型与可用输入类型进行比较，并搜索一个可以安全地将所有输入转换为数据类型的数据类型的循环，可以自动找到合适的循环。此关键字参数使您可以绕过该搜索并选择特定的循环。ufunc对象的&lt;strong&gt;types&lt;/strong&gt;属性提供了可用签名的列表。为了向后兼容，此参数也可以作为&lt;em&gt;sig&lt;/em&gt;提供&lt;em&gt;&lt;/em&gt;，尽管长格式是首选。请注意，这不应与存储在ufunc对象的&lt;strong&gt;signature&lt;/strong&gt;属性中的通用ufunc &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;签名&lt;/a&gt;相混淆。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7610b5a110dcd0d84cf907684a00201bedfda50b" translate="yes" xml:space="preserve">
          <source>Either a data-type, a tuple of data-types, or a special signature string indicating the input and output types of a ufunc. This argument allows you to provide a specific signature for the 1-d loop to use in the underlying calculation. If the loop specified does not exist for the ufunc, then a TypeError is raised. Normally, a suitable loop is found automatically by comparing the input types with what is available and searching for a loop with data-types to which all inputs can be cast safely. This keyword argument lets you bypass that search and choose a particular loop. A list of available signatures is provided by the &lt;strong&gt;types&lt;/strong&gt; attribute of the ufunc object. For backwards compatibility this argument can also be provided as &lt;em&gt;sig&lt;/em&gt;, although the long form is preferred. Note that this should not be confused with the generalized ufunc &lt;a href=&quot;c-api/generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; that is stored in the &lt;strong&gt;signature&lt;/strong&gt; attribute of the of the ufunc object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1209e0f0503ff7dc267174ecb081f65f265397" translate="yes" xml:space="preserve">
          <source>Either passing n arguments as in njoin(&amp;lsquo;a&amp;rsquo;,&amp;rsquo;b&amp;rsquo;), or a sequence of n names as in njoin([&amp;lsquo;a&amp;rsquo;,&amp;rsquo;b&amp;rsquo;]) is handled, or a mixture of such arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7015ddb90f8a42ecbacfed5d690fb153cc71ff7" translate="yes" xml:space="preserve">
          <source>Either the file name (string) or an open file (file-like object) where the data will be saved. If file is a string or a Path, the &lt;code&gt;.npz&lt;/code&gt; extension will be appended to the file name if it is not already there.</source>
          <target state="translated">文件名（字符串）或打开的文件（类似文件的对象）将在其中保存数据。如果文件是字符串或路径，则 &lt;code&gt;.npz&lt;/code&gt; 扩展名将附加到文件名（如果尚不存在）。</target>
        </trans-unit>
        <trans-unit id="0f9fa4310da3a7c0b9cf42ac99c7003bdc5b813b" translate="yes" xml:space="preserve">
          <source>Either the filename (string) or an open file (file-like object) where the data will be saved. If file is a string or a Path, the &lt;code&gt;.npz&lt;/code&gt; extension will be appended to the filename if it is not already there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2953df344283c54bedef1d8e252fb3c96e667a80" translate="yes" xml:space="preserve">
          <source>Element index to partition by. The k-th element will be in its final sorted position and all smaller elements will be moved before it and all larger elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of k-th it will partition all of them into their sorted position at once.</source>
          <target state="translated">要分割的元素索引。第k个元素将处于最终的排序位置,所有较小的元素将被移到它之前,所有较大的元素将被移到它之后。分区中所有元素的顺序是未定义的。如果提供了一个k-th的序列,它将一次把所有元素分到它们的排序位置。</target>
        </trans-unit>
        <trans-unit id="603f2f92b6e79eef48a044dac1baeab309560ae3" translate="yes" xml:space="preserve">
          <source>Element index to partition by. The k-th value of the element will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of k-th it will partition all elements indexed by k-th of them into their sorted position at once.</source>
          <target state="translated">元素的索引,以分割。元素的第k个值将处于最终的排序位置,所有较小的元素将被移到它的前面,所有相等或较大的元素将被移到它的后面。分区中所有元素的顺序是未定义的。如果提供一个k-th的序列,它将把所有以k-th为索引的元素一次性分区到它们的排序位置。</target>
        </trans-unit>
        <trans-unit id="dd1e5c082697760ec705616bbb818b3e3054f2a3" translate="yes" xml:space="preserve">
          <source>Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once.</source>
          <target state="translated">要分割的元素索引。第k个元素的值将处于最终的排序位置,所有较小的元素将被移到它的前面,所有相等或较大的元素将被移到它的后面。分区中所有元素的顺序是未定义的。如果提供一个kth的序列,它将把所有以kth为索引的元素一次性分区到它们的排序位置。</target>
        </trans-unit>
        <trans-unit id="67afd821e881e618d2d3c592047caa6ab2545d17" translate="yes" xml:space="preserve">
          <source>Element-wise 2 to the power &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">按元素2的幂 &lt;code&gt;x&lt;/code&gt; 。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="adaf9e130e6f948876c40cb7079ab5374d49e139" translate="yes" xml:space="preserve">
          <source>Element-wise &lt;code&gt;x*x&lt;/code&gt;, of the same shape and dtype as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">与 &lt;code&gt;x*x&lt;/code&gt; 相同的形状和dtype的逐元素x * &lt;code&gt;x&lt;/code&gt; 。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="808b6a2cc974757f97aaa854c54baffd849df5f9" translate="yes" xml:space="preserve">
          <source>Element-wise arc tangent of &lt;code&gt;x1/x2&lt;/code&gt; choosing the quadrant correctly.</source>
          <target state="translated">&lt;code&gt;x1/x2&lt;/code&gt; 的逐元素圆弧切线可正确选择象限。</target>
        </trans-unit>
        <trans-unit id="2ac96759d5e7cde7bc053be626eb0c73009447e8" translate="yes" xml:space="preserve">
          <source>Element-wise exponential minus one: &lt;code&gt;out = exp(x) - 1&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">逐元素指数减一： &lt;code&gt;out = exp(x) - 1&lt;/code&gt; 。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="2e24669e28a8f1555e04e187ba59f7b56eef5d74" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of array elements.</source>
          <target state="translated">阵列元素的元素最大值。</target>
        </trans-unit>
        <trans-unit id="de0f8227b430f00f150f25df31d4c6130cd8dee1" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, ignores NaNs.</source>
          <target state="translated">元素上最大的两个阵列,忽略NaNs。</target>
        </trans-unit>
        <trans-unit id="f0000ade51e0b31f8609d90f1fdd9bbd95746777" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, ignoring any NaNs.</source>
          <target state="translated">元素上最大的两个阵列,忽略任何NaNs。</target>
        </trans-unit>
        <trans-unit id="a0de4ef4fdf4c984be543486b8ef23d43631cea6" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, propagates NaNs.</source>
          <target state="translated">元素上最大的两个阵列,传播NaNs。</target>
        </trans-unit>
        <trans-unit id="bdcc1733a93ea05c9ded4af3bbc823384a01061c" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, propagating any NaNs.</source>
          <target state="translated">元素上最大的两个阵列,传播任何NaN。</target>
        </trans-unit>
        <trans-unit id="117fbbb294a3d3f4ec6bf9953291f0979ba3eb6d" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of array elements.</source>
          <target state="translated">阵列元素的最小值。</target>
        </trans-unit>
        <trans-unit id="f10c8e11f8111bdb87b272aa363c7d5a87d2958e" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, ignores NaNs.</source>
          <target state="translated">元素上最小的两个阵列,忽略NaNs。</target>
        </trans-unit>
        <trans-unit id="0c1d7d39298313f44ede26ddbe99082deaf8d999" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, ignoring any NaNs.</source>
          <target state="translated">元素上最小的两个阵列,忽略任何NaNs。</target>
        </trans-unit>
        <trans-unit id="129e7a520fce7febf9e89723a4b3e31c307bd988" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, propagates NaNs.</source>
          <target state="translated">元素上最小的两个阵列,传播NaNs。</target>
        </trans-unit>
        <trans-unit id="31ccb3abbc1e393d00365ccd1319992c54e9ed13" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, propagating any NaNs.</source>
          <target state="translated">元素上最小的两个阵列,传播任何NaNs。</target>
        </trans-unit>
        <trans-unit id="a664254a8e3d768c1b8ca8504a3064612680ed55" translate="yes" xml:space="preserve">
          <source>Element-wise quotient resulting from floor division. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">楼层划分得出的元素商。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="35a0aab7c92a2f3f84b40cb7246ed8c1bcebd9a8" translate="yes" xml:space="preserve">
          <source>Element-wise remainder from floor division. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">楼层划分的元素明智余数。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="41a18c5c80ce790e4ab72162c437f0a9d09ae712" translate="yes" xml:space="preserve">
          <source>Elementary Function</source>
          <target state="translated">基本功能</target>
        </trans-unit>
        <trans-unit id="04982a80ae05d1b0cdf8cb6f954f5d90370c1f1a" translate="yes" xml:space="preserve">
          <source>Elements shapes must match along the appropriate axes (without broadcasting), but leading 1s will be prepended to the shape as necessary to make the dimensions match.</source>
          <target state="translated">元素形状必须沿着适当的轴匹配(没有广播),但为了使尺寸匹配,在形状前会有必要的前导1。</target>
        </trans-unit>
        <trans-unit id="ec73af38a64af612d36b6b1e08ea284a14bd8798" translate="yes" xml:space="preserve">
          <source>Elements that roll beyond the last position are re-introduced at the first.</source>
          <target state="translated">滚动超过最后一个位置的元素在第一个位置重新引入。</target>
        </trans-unit>
        <trans-unit id="8ec956445b767a135cb8c6d627b5a2dfeb02537d" translate="yes" xml:space="preserve">
          <source>Elements to compare for the maximum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">要比较的最大元素。有关详细信息，请参见&lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4ba7c2272413ef1378137b3e69e8b4722f8659b1" translate="yes" xml:space="preserve">
          <source>Elements to compare for the minimum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">要比较的元素的最小值。有关详细信息，请参见&lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c0973f46abdf4cfdea56a1e0e2597c002a92fb2" translate="yes" xml:space="preserve">
          <source>Elements to include in the product. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">产品中要包含的元素。有关详细信息，请参见&lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="836bba81daa7bbfa24fcec9d876cd0ca01db1438" translate="yes" xml:space="preserve">
          <source>Elements to include in the sum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">总和中要包括的元素。有关详细信息，请参见&lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a68b36609400536b206e5ed8f4915662a0a2020b" translate="yes" xml:space="preserve">
          <source>Elements to sum.</source>
          <target state="translated">要素相加。</target>
        </trans-unit>
        <trans-unit id="680319fcdd621a03121d173370e025227fa7d8d6" translate="yes" xml:space="preserve">
          <source>Elementwise bit operations</source>
          <target state="translated">元素位操作</target>
        </trans-unit>
        <trans-unit id="59a9a9f6dbe39b1cf060328792d82b4916bb1fe4" translate="yes" xml:space="preserve">
          <source>Email the editor of LWN to let them know of the release. Directions at: &lt;a href=&quot;https://lwn.net/op/FAQ.lwn#contact&quot;&gt;https://lwn.net/op/FAQ.lwn#contact&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="599d2acd649f524c65c4bd78c5dfde8f2b7d2eea" translate="yes" xml:space="preserve">
          <source>Emeritus members</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975003171b5d10383f8baffd2a3aedbe6bfb0ccf" translate="yes" xml:space="preserve">
          <source>Emit py3kwarnings for division of integer arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b188c1a7743df45af55da550ee4905951a67f8f" translate="yes" xml:space="preserve">
          <source>Emphasize empathy for individuals rather than judging behavior, avoiding binary labels of &amp;ldquo;good&amp;rdquo; and &amp;ldquo;bad/evil&amp;rdquo;. Overt, clear-cut aggression and harassment exists and we will be address that firmly. But many scenarios that can prove challenging to resolve are those where normal disagreements devolve into unhelpful or harmful behavior from multiple parties. Understanding the full context and finding a path that re-engages all is hard, but ultimately the most productive for our community.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777a53a52816c5597e4f366c2ef31bc0f2a213da" translate="yes" xml:space="preserve">
          <source>Empty array of the given shape and type.</source>
          <target state="translated">指定形状和类型的空数组。</target>
        </trans-unit>
        <trans-unit id="30b8b3469c24b495eeedeb9693c9bf36670e4dcd" translate="yes" xml:space="preserve">
          <source>Empty masked array modelled on an existing array.</source>
          <target state="translated">在现有数组上建模的空掩模数组。</target>
        </trans-unit>
        <trans-unit id="6985c4b0d668125594b4f0ca6436e1c86a0154e8" translate="yes" xml:space="preserve">
          <source>Empty masked array with all elements masked.</source>
          <target state="translated">空的掩码数组,所有元素都被掩码。</target>
        </trans-unit>
        <trans-unit id="680b8e573f5c82aced131f36a223b41bb3352d25" translate="yes" xml:space="preserve">
          <source>Empty masked array with the properties of an existing array.</source>
          <target state="translated">用现有数组的属性清空掩码数组。</target>
        </trans-unit>
        <trans-unit id="45886aabb4d2355c3b829d3be8c1cca38e105c36" translate="yes" xml:space="preserve">
          <source>Enable AVX2/AVX512 at compile time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a122b7a065f1b0b6e65770d5576676e667e835a7" translate="yes" xml:space="preserve">
          <source>Enables support for iteration of sub-ranges of the full &lt;code&gt;iterindex&lt;/code&gt; range &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt;. Use the function &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt;&lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt;&lt;/a&gt; to specify a range for iteration.</source>
          <target state="translated">启用对整个 &lt;code&gt;iterindex&lt;/code&gt; 范围 &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt; 的子范围的迭代的支持。使用函数&lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt; &lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt; &lt;/a&gt;指定迭代范围。</target>
        </trans-unit>
        <trans-unit id="0bc79001ca7d4881c81aec2ea04317198e31e1bd" translate="yes" xml:space="preserve">
          <source>Enables the specified array flags. This function does no validation, and assumes that you know what you&amp;rsquo;re doing.</source>
          <target state="translated">启用指定的数组标志。该函数不进行验证，并假定您知道自己在做什么。</target>
        </trans-unit>
        <trans-unit id="2919970bd082897345d32d119a4800b54dae0c81" translate="yes" xml:space="preserve">
          <source>Encapsulate the functionality of functions and methods that take the axis= keyword and work properly with None as the axis argument. The input array is &lt;code&gt;obj&lt;/code&gt;, while &lt;code&gt;*axis&lt;/code&gt; is a converted integer (so that &amp;gt;=MAXDIMS is the None value), and &lt;code&gt;requirements&lt;/code&gt; gives the needed properties of &lt;code&gt;obj&lt;/code&gt;. The output is a converted version of the input so that requirements are met and if needed a flattening has occurred. On output negative values of &lt;code&gt;*axis&lt;/code&gt; are converted and the new value is checked to ensure consistency with the shape of &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">封装采用axis =关键字并正确使用None作为axis参数的函数和方法的功能。输入数组是 &lt;code&gt;obj&lt;/code&gt; ，而 &lt;code&gt;*axis&lt;/code&gt; 是转换后的整数（因此&amp;gt; = MAXDIMS是None值），并且 &lt;code&gt;requirements&lt;/code&gt; 给出了 &lt;code&gt;obj&lt;/code&gt; 所需的属性。输出是输入的转换版本，因此可以满足要求，并且在需要时进行展平。在输出时，将转换 &lt;code&gt;*axis&lt;/code&gt; 的负值，并检查新值以确保与 &lt;code&gt;obj&lt;/code&gt; 的形状一致。</target>
        </trans-unit>
        <trans-unit id="27ce22c6173324f95f01ae2e015c760af4bd2880" translate="yes" xml:space="preserve">
          <source>Enclose variables in single backticks. The colon must be preceded by a space, or omitted if the type is absent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="349d554a10586cdec500258debd97663d605504e" translate="yes" xml:space="preserve">
          <source>Encoding argument for text IO functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fcbf1219e531263b67edb6bcb90e0e603ad6031" translate="yes" xml:space="preserve">
          <source>Encoding used to decode the inputfile. Does not apply to input streams.</source>
          <target state="translated">用于解码输入文件的编码。不适用于输入流。</target>
        </trans-unit>
        <trans-unit id="b27e46c5a085977e5cb88681f8a881b52c0fec71" translate="yes" xml:space="preserve">
          <source>Encoding used to decode the inputfile. Does not apply to input streams. The special value &amp;lsquo;bytes&amp;rsquo; enables backward compatibility workarounds that ensures you receive byte arrays as results if possible and passes &amp;lsquo;latin1&amp;rsquo; encoded strings to converters. Override this value to receive unicode arrays and pass strings as input to converters. If set to None the system default is used. The default value is &amp;lsquo;bytes&amp;rsquo;.</source>
          <target state="translated">用于解码输入文件的编码。不适用于输入流。特殊值'bytes'支持向后兼容的解决方法，可确保您尽可能接收字节数组作为结果，并将'latin1'编码的字符串传递给转换器。覆盖此值以接收unicode数组，并将字符串作为输入传递给转换器。如果设置为&amp;ldquo;无&amp;rdquo;，则使用系统默认值。默认值为&amp;ldquo;字节&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6776a87f17cb7165db7de968828852a089f8cd2b" translate="yes" xml:space="preserve">
          <source>Encoding used to decode the inputfile. Does not apply when &lt;code&gt;fname&lt;/code&gt; is a file object. The special value &amp;lsquo;bytes&amp;rsquo; enables backward compatibility workarounds that ensure that you receive byte arrays when possible and passes latin1 encoded strings to converters. Override this value to receive unicode arrays and pass strings as input to converters. If set to None the system default is used. The default value is &amp;lsquo;bytes&amp;rsquo;.</source>
          <target state="translated">用于解码输入文件的编码。当 &lt;code&gt;fname&lt;/code&gt; 是文件对象时不适用。特殊值'bytes'支持向后兼容的变通方法，可确保您在可能的情况下接收字节数组，并将latin1编码的字符串传递给转换器。覆盖此值以接收unicode数组，并将字符串作为输入传递给转换器。如果设置为&amp;ldquo;无&amp;rdquo;，则使用系统默认值。默认值为&amp;ldquo;字节&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8e2939a9752e2c7114a267e7bcdaebdf8d9a69e0" translate="yes" xml:space="preserve">
          <source>Encoding used to encode the outputfile. Does not apply to output streams. If the encoding is something other than &amp;lsquo;bytes&amp;rsquo; or &amp;lsquo;latin1&amp;rsquo; you will not be able to load the file in NumPy versions &amp;lt; 1.14. Default is &amp;lsquo;latin1&amp;rsquo;.</source>
          <target state="translated">用于对输出文件进行编码的编码。不适用于输出流。如果编码不是'bytes'或'latin1'以外的其他格式，则将无法以&amp;lt;1.14的NumPy版本加载文件。默认值为&amp;ldquo; latin1&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="672959489089d143587fef9e4d4ad09fb66e2197" translate="yes" xml:space="preserve">
          <source>End of interval. The interval does not include this value, except in some cases where &lt;code&gt;step&lt;/code&gt; is not an integer and floating point round-off affects the length of &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">间隔结束。该间隔不包括该值，除非在某些情况下， &lt;code&gt;step&lt;/code&gt; 不是整数，并且浮点舍入会影响 &lt;code&gt;out&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="d9b220f5e9cefe4e27d14fddf001bfa3a63353e7" translate="yes" xml:space="preserve">
          <source>Endianness of this data:</source>
          <target state="translated">这个数据的终结性。</target>
        </trans-unit>
        <trans-unit id="90010140c11fc0bb2865fc9b51fcfa59f205ccef" translate="yes" xml:space="preserve">
          <source>Endnotes</source>
          <target state="translated">Endnotes</target>
        </trans-unit>
        <trans-unit id="05406404937f1ded938df8b2535e2c18c93233ac" translate="yes" xml:space="preserve">
          <source>Enforcing the Code of Conduct impacts our community today and for the future. It&amp;rsquo;s an action that we do not take lightly. When reviewing enforcement measures, the Code of Conduct Committee will keep the following values and guidelines in mind:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3bf2be725863fdffb3b97618f54e280ae615ed8" translate="yes" xml:space="preserve">
          <source>Enhancements</source>
          <target state="translated">Enhancements</target>
        </trans-unit>
        <trans-unit id="83a41a009718ba8b1b08f10745bce80452ba74f4" translate="yes" xml:space="preserve">
          <source>Enlarging an array: as above, but missing entries are filled with zeros:</source>
          <target state="translated">放大数组:同上,但缺失的条目用零填充。</target>
        </trans-unit>
        <trans-unit id="6c8cedd3caa9e42a775e9fa4b437c16d37b9b189" translate="yes" xml:space="preserve">
          <source>Ensure that the original contents of &lt;code&gt;intent(in)&lt;/code&gt; argument is preserved. Typically used in connection with &lt;code&gt;intent(in,out)&lt;/code&gt; attribute. F2PY creates an optional argument &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; with the default value &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b1cfaa83bf2eab645405941ddc61295f0ec9ed6" translate="yes" xml:space="preserve">
          <source>Ensure you are dealing with a well-behaved array (aligned, in machine byte-order and single-segment) of the correct type and number of dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a314f110f22f052f3fa828713d2b2afb82f2d3" translate="yes" xml:space="preserve">
          <source>Ensures that the input or output matches the iteration dimensions exactly.</source>
          <target state="translated">确保输入或输出与迭代尺寸完全匹配。</target>
        </trans-unit>
        <trans-unit id="2dfe05db0717fbae4e4c8fa997a9589c52cb7615" translate="yes" xml:space="preserve">
          <source>Enter your GitHub username and password (repeat contributors or advanced users can remove this step by connecting to GitHub with &lt;a href=&quot;gitwash/development_setup#set-up-and-configure-a-github-account&quot;&gt;SSH&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a6fa7af7b1354d47707152a8ad806c277ca980" translate="yes" xml:space="preserve">
          <source>Entropy bits in 32-bit unsigned integers. A scalar is returned if size is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">熵位（32位无符号整数）。如果size为 &lt;code&gt;None&lt;/code&gt; ,则返回一个标量。</target>
        </trans-unit>
        <trans-unit id="b0366a10ef9d6d3ef8c64dd51eeccb78bad1656a" translate="yes" xml:space="preserve">
          <source>Enumerated Types</source>
          <target state="translated">枚举类型</target>
        </trans-unit>
        <trans-unit id="e4ac742e5d17c07aad844f80aaa89a24ed90f881" translate="yes" xml:space="preserve">
          <source>Equal to &lt;code&gt;np.prod(a.shape)&lt;/code&gt;, i.e., the product of the array&amp;rsquo;s dimensions.</source>
          <target state="translated">等于 &lt;code&gt;np.prod(a.shape)&lt;/code&gt; ，即数组尺寸的乘积。</target>
        </trans-unit>
        <trans-unit id="2baf15a74d602a8791ff350bd57dfdac0a7e5d0e" translate="yes" xml:space="preserve">
          <source>Equations : as discussed in the &lt;strong&gt;Notes&lt;/strong&gt; section above, LaTeX formatting should be kept to a minimum. Often it&amp;rsquo;s possible to show equations as Python code or pseudo-code instead, which is much more readable in a terminal. For inline display use double backticks (like &lt;code&gt;y = np.sin(x)&lt;/code&gt;). For display with blank lines above and below, use a double colon and indent the code, like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf762494180c61769e42e78eeea4e46c35cf2ea1" translate="yes" xml:space="preserve">
          <source>Equations can also be typeset underneath the math directive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b75f0322b44b0e91520f5021f79c37a01c9e121d" translate="yes" xml:space="preserve">
          <source>Equivalent array function.</source>
          <target state="translated">等价数组函数。</target>
        </trans-unit>
        <trans-unit id="a87b0e23e278c7d5e4e266e84f6badc171df142a" translate="yes" xml:space="preserve">
          <source>Equivalent array method.</source>
          <target state="translated">等价数组法。</target>
        </trans-unit>
        <trans-unit id="1f85d863747d1d952d2380d6f9b0e6bc4a93c6e6" translate="yes" xml:space="preserve">
          <source>Equivalent function</source>
          <target state="translated">等效函数</target>
        </trans-unit>
        <trans-unit id="ec48c460ff53cdf24f427482ba077c38b868cbe6" translate="yes" xml:space="preserve">
          <source>Equivalent function for ndarrays.</source>
          <target state="translated">ndarrays的等价函数。</target>
        </trans-unit>
        <trans-unit id="47b16a4308d5d95c02caa6becddf32961f2329b1" translate="yes" xml:space="preserve">
          <source>Equivalent function in the NumPy module.</source>
          <target state="translated">NumPy模块中的等价函数。</target>
        </trans-unit>
        <trans-unit id="3fda7b941f8c3619f7cfea52fae50b8fafb8283f" translate="yes" xml:space="preserve">
          <source>Equivalent function in the masked array module.</source>
          <target state="translated">屏蔽数组模块中的等价函数。</target>
        </trans-unit>
        <trans-unit id="f3946f30225c2c4e0913895a299311328885ca06" translate="yes" xml:space="preserve">
          <source>Equivalent function in the top level NumPy module.</source>
          <target state="translated">顶层NumPy模块中的等价函数。</target>
        </trans-unit>
        <trans-unit id="e79348928e8ad109f51e4deea501091d1124a6a4" translate="yes" xml:space="preserve">
          <source>Equivalent function in the top-level NumPy module.</source>
          <target state="translated">顶层NumPy模块中的等价函数。</target>
        </trans-unit>
        <trans-unit id="f012d5b24482ab2f7fe8b36bc8562d2e06cf863d" translate="yes" xml:space="preserve">
          <source>Equivalent function in top-level NumPy module.</source>
          <target state="translated">顶层NumPy模块中的等价函数。</target>
        </trans-unit>
        <trans-unit id="bb89f40e9f2471ebbc500654e8790a75f09e8680" translate="yes" xml:space="preserve">
          <source>Equivalent function with additional &lt;code&gt;loc&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; arguments for setting the mean and standard deviation.</source>
          <target state="translated">带有附加 &lt;code&gt;loc&lt;/code&gt; 和 &lt;code&gt;scale&lt;/code&gt; 参数的等效函数，用于设置平均值和标准偏差。</target>
        </trans-unit>
        <trans-unit id="3fec03561045f830610698c03c4e7cda301e9182" translate="yes" xml:space="preserve">
          <source>Equivalent functionality of &lt;a href=&quot;numpy.add#numpy.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.add#numpy.add&quot;&gt; &lt;code&gt;add&lt;/code&gt; 的&lt;/a&gt;等效功能。</target>
        </trans-unit>
        <trans-unit id="73110076e1002b6b052fe8f385604bf0bd306ff9" translate="yes" xml:space="preserve">
          <source>Equivalent method in ndarray</source>
          <target state="translated">ndarray中的等价法</target>
        </trans-unit>
        <trans-unit id="8b818de9537a41af44762a6ff8c93846b78172ce" translate="yes" xml:space="preserve">
          <source>Equivalent method on ndarray object.</source>
          <target state="translated">等价于ndarray对象的方法。</target>
        </trans-unit>
        <trans-unit id="323a53e2d1eaaaf783c2a6e70d300696fee31861" translate="yes" xml:space="preserve">
          <source>Equivalent method when working on 1-D arrays</source>
          <target state="translated">在一维数组上工作时的等价法</target>
        </trans-unit>
        <trans-unit id="198298ece560304dd9cecebb0a6c0ea2bb7a8bae" translate="yes" xml:space="preserve">
          <source>Equivalent method.</source>
          <target state="translated">等价法。</target>
        </trans-unit>
        <trans-unit id="46b37d7b2f299efd2d123535be0f6369732ae724" translate="yes" xml:space="preserve">
          <source>Equivalent ndarray method.</source>
          <target state="translated">等效ndarray法。</target>
        </trans-unit>
        <trans-unit id="c920736bc05ff403de2ed423ca7f0b9c0f3adffb" translate="yes" xml:space="preserve">
          <source>Equivalent of Python &lt;code&gt;//&lt;/code&gt; operator.</source>
          <target state="translated">等效于Python &lt;code&gt;//&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="505d790701850092dede13a1225a7d0508099ca4" translate="yes" xml:space="preserve">
          <source>Equivalent of the MATLAB &lt;code&gt;rem&lt;/code&gt; function.</source>
          <target state="translated">等效于MATLAB &lt;code&gt;rem&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="4cdc670d68d8d05adfb0ac70f3d0ea4670424187" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#c.PyDataType_FLAGCHK&quot;&gt;&lt;code&gt;PyDataType_FLAGCHK&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;dtype&lt;/em&gt;, &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt;&lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">相当于&lt;a href=&quot;#c.PyDataType_FLAGCHK&quot;&gt; &lt;code&gt;PyDataType_FLAGCHK&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;D型&lt;/em&gt;，&lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt; &lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fee6dbfeac3ceda19730d1e4e0704640fe75ab77" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;ndarray.all&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array with True elements for every 1-d sub-array of &lt;code&gt;self&lt;/code&gt; defined by &lt;code&gt;axis&lt;/code&gt; in which all the elements are True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186b0b563cbae838de8810c69312c1eaa62ec654" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt;&lt;code&gt;ndarray.any&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array with True elements for every 1-d sub-array of &lt;em&gt;self&lt;/em&gt; defined by &lt;em&gt;axis&lt;/em&gt; in which any of the elements are True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f442103406eabff3384a2561e7e4f3b1cb166d5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the index of the largest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c75a0ddd8d31ee8d0abd1790434d076eb8e7770e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the index of the smallest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28fa5901ef493ca3cfeb35f1edc348f4ba70f84" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.argpartition#numpy.ndarray.argpartition&quot;&gt;&lt;code&gt;ndarray.argpartition&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;ktharray&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Return an array of indices such that selection of these indices along the given &lt;code&gt;axis&lt;/code&gt; would return a partitioned version of &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e47633b0ba2c1ea2ce577109feb2860147110ce7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.argsort#numpy.ndarray.argsort&quot;&gt;&lt;code&gt;ndarray.argsort&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array of indices such that selection of these indices along the given &lt;code&gt;axis&lt;/code&gt; would return a sorted version of &lt;em&gt;self&lt;/em&gt;. If &lt;em&gt;self&lt;/em&gt; -&amp;gt;descr is a data-type with fields defined, then self-&amp;gt;descr-&amp;gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab44c6dfb76d44a22896198277fc1dfa63e19a39" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.byteswap#numpy.ndarray.byteswap&quot;&gt;&lt;code&gt;ndarray.byteswap&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;inplace&lt;/em&gt;). Return an array whose data area is byteswapped. If &lt;em&gt;inplace&lt;/em&gt; is non-zero, then do the byteswap inplace and return a reference to self. Otherwise, create a byteswapped copy and leave self unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63580b7937fc29a8cc1a69e6dad1db1d8c003559" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.choose#numpy.ndarray.choose&quot;&gt;&lt;code&gt;ndarray.choose&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt;, &lt;em&gt;ret&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt;). Create a new array by selecting elements from the sequence of arrays in &lt;em&gt;op&lt;/em&gt; based on the integer values in &lt;em&gt;self&lt;/em&gt;. The arrays must all be broadcastable to the same shape and the entries in &lt;em&gt;self&lt;/em&gt; should be between 0 and len(&lt;em&gt;op&lt;/em&gt;). The output is placed in &lt;em&gt;ret&lt;/em&gt; unless it is &lt;code&gt;NULL&lt;/code&gt; in which case a new output is created. The &lt;em&gt;clipmode&lt;/em&gt; argument determines behavior for when entries in &lt;em&gt;self&lt;/em&gt; are not between 0 and len(&lt;em&gt;op&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3b2ea44431c439616093a9d5ebd74980360b6c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.clip#numpy.ndarray.clip&quot;&gt;&lt;code&gt;ndarray.clip&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;min&lt;/em&gt;, &lt;em&gt;max&lt;/em&gt;). Clip an array, &lt;em&gt;self&lt;/em&gt;, so that values larger than &lt;em&gt;max&lt;/em&gt; are fixed to &lt;em&gt;max&lt;/em&gt; and values less than &lt;em&gt;min&lt;/em&gt; are fixed to &lt;em&gt;min&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d43c27921059f0a7a10c6b7d33e4ffbe0ee4d6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.compress#numpy.ndarray.compress&quot;&gt;&lt;code&gt;ndarray.compress&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;condition&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt; ). Return the elements along &lt;em&gt;axis&lt;/em&gt; corresponding to elements of &lt;em&gt;condition&lt;/em&gt; that are true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9aa772deed9dfab23ce08d5aaf5096e5f550d9a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.conjugate#numpy.ndarray.conjugate&quot;&gt;&lt;code&gt;ndarray.conjugate&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return the complex conjugate of &lt;em&gt;self&lt;/em&gt;. If &lt;em&gt;self&lt;/em&gt; is not of complex data type, then return &lt;em&gt;self&lt;/em&gt; with a reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e0619959acd54807feb74d65e4fc49e0c39d7c4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt;&lt;code&gt;ndarray.copy&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;fortran&lt;/em&gt;). Make a copy of the &lt;em&gt;old&lt;/em&gt; array. The returned array is always aligned and writeable with data interpreted the same as the old array. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, then a C-style contiguous array is returned. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;, then a Fortran-style contiguous array is returned. If &lt;em&gt;order is&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, then the array returned is Fortran-style contiguous only if the old one is; otherwise, it is C-style contiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0c3cd7eb6fa6d356c2901bb9f6d3ba8cab9d89e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.cumprod#numpy.ndarray.cumprod&quot;&gt;&lt;code&gt;ndarray.cumprod&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d cumulative products of elements in &lt;code&gt;self&lt;/code&gt; along &lt;code&gt;axis&lt;/code&gt;. Perform the product after converting data to data type &lt;code&gt;rtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb82bf0e510f4d18fb05a89ac99cab0f063a9efd" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.cumsum#numpy.ndarray.cumsum&quot;&gt;&lt;code&gt;ndarray.cumsum&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return cumulative 1-d sums of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the sum after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147baa3bca301ee2641ca21a0eba77e7a019e912" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.diagonal#numpy.ndarray.diagonal&quot;&gt;&lt;code&gt;ndarray.diagonal&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;, &lt;em&gt;axis1&lt;/em&gt;, &lt;em&gt;axis2&lt;/em&gt; ). Return the &lt;em&gt;offset&lt;/em&gt; diagonals of the 2-d arrays defined by &lt;em&gt;axis1&lt;/em&gt; and &lt;em&gt;axis2&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a8dee6eb2f62046701960813747a2ce4d3c4eb9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt;&lt;code&gt;ndarray.flatten&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;). Return a 1-d copy of the array. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt; the elements are scanned out in Fortran order (first-dimension varies the fastest). If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, the elements of &lt;code&gt;self&lt;/code&gt; are scanned in C-order (last dimension varies the fastest). If &lt;em&gt;order&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, then the result of &lt;a href=&quot;#c.PyArray_ISFORTRAN&quot;&gt;&lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;) is used to determine which order to flatten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b8b003a6301beae59c2337672b7d873a7a30b4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.getfield#numpy.ndarray.getfield&quot;&gt;&lt;code&gt;ndarray.getfield&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;). This function &lt;a href=&quot;https://docs.python.org/3/c-api/intro.html?reference-count-details&quot;&gt;steals a reference&lt;/a&gt; to &lt;code&gt;PyArray_Descr&lt;/code&gt; and returns a new array of the given &lt;code&gt;dtype&lt;/code&gt; using the data in the current array at a specified &lt;code&gt;offset&lt;/code&gt; in bytes. The &lt;code&gt;offset&lt;/code&gt; plus the itemsize of the new array type must be less than &lt;code&gt;self
-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; or an error is raised. The same shape and strides as the original array are used. Therefore, this function has the effect of returning a field from a structured array. But, it can also be used to select specific bytes or groups of bytes from any array type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d22054d186b1f1ff23d804468173438990f202" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Returns the largest element of &lt;em&gt;self&lt;/em&gt; along the given &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d38f65f39197f34563c038f540e3b44a0d2f6ba" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.mean#numpy.ndarray.mean&quot;&gt;&lt;code&gt;ndarray.mean&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Returns the mean of the elements along the given &lt;em&gt;axis&lt;/em&gt;, using the enumerated type &lt;em&gt;rtype&lt;/em&gt; as the data type to sum in. Default sum behavior is obtained using &lt;a href=&quot;dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; for &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cb706fff5203c363163a51434cc7adef7ffc29f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the smallest element of &lt;em&gt;self&lt;/em&gt; along the given &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d5265b484ee101637dbdbbeb657d0f5063ebd7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;ndarray.nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Returns a tuple of index arrays that select elements of &lt;em&gt;self&lt;/em&gt; that are nonzero. If (nd= &lt;a href=&quot;#c.PyArray_NDIM&quot;&gt;&lt;code&gt;PyArray_NDIM&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;self&lt;/code&gt; ))==1, then a single index array is returned. The index arrays have data type &lt;a href=&quot;dtype#c.NPY_INTP&quot;&gt;&lt;code&gt;NPY_INTP&lt;/code&gt;&lt;/a&gt;. If a tuple is returned (nd</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="404bdbd3b8a1b96a6c46adc73debf37dfd647756" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.partition#numpy.ndarray.partition&quot;&gt;&lt;code&gt;ndarray.partition&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;ktharray&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Partitions the array so that the values of the element indexed by &lt;em&gt;ktharray&lt;/em&gt; are in the positions they would be if the array is fully sorted and places all elements smaller than the kth before and all elements equal or greater after the kth element. The ordering of all elements within the partitions is undefined. If &lt;em&gt;self&lt;/em&gt;-&amp;gt;descr is a data-type with fields defined, then self-&amp;gt;descr-&amp;gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type. Returns zero on success and -1 on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c549a447e1ab678178d605e0abed17f0cd61d094" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.prod#numpy.ndarray.prod&quot;&gt;&lt;code&gt;ndarray.prod&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d products of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the product after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e5592224385bd5a5a47c4e8db5171ddcc2ccb3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.ptp#numpy.ndarray.ptp&quot;&gt;&lt;code&gt;ndarray.ptp&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the difference between the largest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt; and the smallest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8518311e2b7b6ac094e9b94bd62860a33aa8bf47" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.repeat#numpy.ndarray.repeat&quot;&gt;&lt;code&gt;ndarray.repeat&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Copy the elements of &lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt; times along the given &lt;em&gt;axis&lt;/em&gt;. Either &lt;em&gt;op&lt;/em&gt; is a scalar integer or a sequence of length &lt;em&gt;self&lt;/em&gt; -&amp;gt;dimensions[ &lt;em&gt;axis&lt;/em&gt; ] indicating how many times to repeat each item along the axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8cf34534cc24beb73c77b84496c087a2293d28" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.reshape#numpy.ndarray.reshape&quot;&gt;&lt;code&gt;ndarray.reshape&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;shape&lt;/em&gt;) where &lt;em&gt;shape&lt;/em&gt; is a sequence. Converts &lt;em&gt;shape&lt;/em&gt; to a &lt;a href=&quot;types-and-structures#c.PyArray_Dims&quot;&gt;&lt;code&gt;PyArray_Dims&lt;/code&gt;&lt;/a&gt; structure and calls &lt;a href=&quot;#c.PyArray_Newshape&quot;&gt;&lt;code&gt;PyArray_Newshape&lt;/code&gt;&lt;/a&gt; internally. For back-ward compatibility &amp;ndash; Not recommended</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="638611d108c9a9ce025011cf0fefaaa249e16115" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt;&lt;code&gt;ndarray.resize&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;newshape&lt;/em&gt;, refcheck &lt;code&gt;=&lt;/code&gt;&lt;em&gt;refcheck&lt;/em&gt;, order= fortran ). This function only works on single-segment arrays. It changes the shape of &lt;em&gt;self&lt;/em&gt; inplace and will reallocate the memory for &lt;em&gt;self&lt;/em&gt; if &lt;em&gt;newshape&lt;/em&gt; has a different total number of elements then the old shape. If reallocation is necessary, then &lt;em&gt;self&lt;/em&gt; must own its data, have &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;base==NULL&lt;/code&gt;, have &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;weakrefs==NULL&lt;/code&gt;, and (unless refcheck is 0) not be referenced by any other array. The fortran argument can be &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;. It currently has no effect. Eventually it could be used to determine how the resize operation should view the data when constructing a differently-dimensioned array. Returns None on success and NULL on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54966ab6c4e29db133f8104359b27e76b17c469a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.round#numpy.ndarray.round&quot;&gt;&lt;code&gt;ndarray.round&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;decimals&lt;/em&gt;, &lt;em&gt;out&lt;/em&gt;). Returns the array with elements rounded to the nearest decimal place. The decimal place is defined as the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec01042d1895112ebd1035318c0017010dd4e832" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.searchsorted#numpy.ndarray.searchsorted&quot;&gt;&lt;code&gt;ndarray.searchsorted&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;values&lt;/em&gt;, &lt;em&gt;side&lt;/em&gt;, &lt;em&gt;perm&lt;/em&gt;). Assuming &lt;em&gt;self&lt;/em&gt; is a 1-d array in ascending order, then the output is an array of indices the same shape as &lt;em&gt;values&lt;/em&gt; such that, if the elements in &lt;em&gt;values&lt;/em&gt; were inserted before the indices, the order of &lt;em&gt;self&lt;/em&gt; would be preserved. No checking is done on whether or not self is in ascending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cef7e5af80a428c5254d2fef178ea505c8c19ead" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.setfield#numpy.ndarray.setfield&quot;&gt;&lt;code&gt;ndarray.setfield&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;val&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt; ). Set the field starting at &lt;em&gt;offset&lt;/em&gt; in bytes and of the given &lt;em&gt;dtype&lt;/em&gt; to &lt;em&gt;val&lt;/em&gt;. The &lt;em&gt;offset&lt;/em&gt; plus &lt;em&gt;dtype&lt;/em&gt; -&amp;gt;elsize must be less than &lt;em&gt;self&lt;/em&gt; -&amp;gt;descr-&amp;gt;elsize or an error is raised. Otherwise, the &lt;em&gt;val&lt;/em&gt; argument is converted to an array and copied into the field pointed to. If necessary, the elements of &lt;em&gt;val&lt;/em&gt; are repeated to fill the destination array, But, the number of elements in the destination must be an integer multiple of the number of elements in &lt;em&gt;val&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3c3255647be24898e308dd8ac21dadefba0c0a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.sort#numpy.ndarray.sort&quot;&gt;&lt;code&gt;ndarray.sort&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Return an array with the items of &lt;em&gt;self&lt;/em&gt; sorted along &lt;em&gt;axis&lt;/em&gt;. The array is sorted using the algorithm denoted by &lt;em&gt;kind&lt;/em&gt;, which is an integer/enum pointing to the type of sorting algorithms used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a6b11953d97b15697fad15568b370248cfeb20" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.squeeze#numpy.ndarray.squeeze&quot;&gt;&lt;code&gt;ndarray.squeeze&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return a new view of &lt;em&gt;self&lt;/em&gt; with all of the dimensions of length 1 removed from the shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="862af43d2c6b0a55c85e6d3a6b411873c5226258" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.std#numpy.ndarray.std&quot;&gt;&lt;code&gt;ndarray.std&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return the standard deviation using data along &lt;em&gt;axis&lt;/em&gt; converted to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e292f5ba0e99a5f16bcc2829ab5d9470ad0f4d13" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt;&lt;code&gt;ndarray.sum&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d vector sums of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the sum after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246fe22eecb98bac6eed58c36c5c002cc77b5ad9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.swapaxes#numpy.ndarray.swapaxes&quot;&gt;&lt;code&gt;ndarray.swapaxes&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;a1&lt;/em&gt;, &lt;em&gt;a2&lt;/em&gt;). The returned array is a new view of the data in &lt;em&gt;self&lt;/em&gt; with the given axes, &lt;em&gt;a1&lt;/em&gt; and &lt;em&gt;a2&lt;/em&gt;, swapped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a390cc4ddaa841114316d31bea2078c5a16e1cf6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;ndarray.take&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;indices&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;ret&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt;) except &lt;em&gt;axis&lt;/em&gt; =None in Python is obtained by setting &lt;em&gt;axis&lt;/em&gt; = &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; in C. Extract the items from self indicated by the integer-valued &lt;em&gt;indices&lt;/em&gt; along the given &lt;em&gt;axis.&lt;/em&gt; The clipmode argument can be &lt;a href=&quot;#c.NPY_RAISE&quot;&gt;&lt;code&gt;NPY_RAISE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_WRAP&quot;&gt;&lt;code&gt;NPY_WRAP&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.NPY_CLIP&quot;&gt;&lt;code&gt;NPY_CLIP&lt;/code&gt;&lt;/a&gt; to indicate what to do with out-of-bound indices. The &lt;em&gt;ret&lt;/em&gt; argument can specify an output array rather than having one created internally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7206ce6e4a585b31fefc3d225467d40239cdb106" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt;&lt;code&gt;ndarray.tobytes&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;). Return the bytes of this array in a Python string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="171c56ed06f2b8f601e0836c87ae1d6a49d81221" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.tolist#numpy.ndarray.tolist&quot;&gt;&lt;code&gt;ndarray.tolist&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return a nested Python list from &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77e40fb42cd93f8c483ffa7d7241b393d0e4ae3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.trace#numpy.ndarray.trace&quot;&gt;&lt;code&gt;ndarray.trace&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;, &lt;em&gt;axis1&lt;/em&gt;, &lt;em&gt;axis2&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return the sum (using &lt;em&gt;rtype&lt;/em&gt; as the data type of summation) over the &lt;em&gt;offset&lt;/em&gt; diagonal elements of the 2-d arrays defined by &lt;em&gt;axis1&lt;/em&gt; and &lt;em&gt;axis2&lt;/em&gt; variables. A positive offset chooses diagonals above the main diagonal. A negative offset selects diagonals below the main diagonal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd34a2c83d97a0f513db9230449465e813314c6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt;&lt;code&gt;ndarray.transpose&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;permute&lt;/em&gt;). Permute the axes of the ndarray object &lt;em&gt;self&lt;/em&gt; according to the data structure &lt;em&gt;permute&lt;/em&gt; and return the result. If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the resulting array has its axes reversed. For example if &lt;em&gt;self&lt;/em&gt; has shape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b13fb477c1c38e7bfcb6352e8ffc5f4bb87dd24f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;ndarray.view&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;). Return a new view of the array &lt;em&gt;self&lt;/em&gt; as possibly a different data-type, &lt;em&gt;dtype&lt;/em&gt;, and different array subclass &lt;em&gt;ptype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ecf3d3dd70eafb08906a1ad49ac399520f10f8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;ndarray.all&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array with True elements for every 1-d sub-array of &lt;code&gt;self&lt;/code&gt; defined by &lt;code&gt;axis&lt;/code&gt; in which all the elements are True.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;ndarray.all&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;）。对于 &lt;code&gt;axis&lt;/code&gt; 定义的 &lt;code&gt;self&lt;/code&gt; 定义的每个1-d子数组，返回一个包含True元素的数组，其中所有元素均为True。</target>
        </trans-unit>
        <trans-unit id="efd8289812e23cf1b7df07369198edcd67ccd665" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt;&lt;code&gt;ndarray.any&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array with True elements for every 1-d sub-array of &lt;em&gt;self&lt;/em&gt; defined by &lt;em&gt;axis&lt;/em&gt; in which any of the elements are True.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt; &lt;code&gt;ndarray.any&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;）。对于由其中任何元素为True的&lt;em&gt;axis&lt;/em&gt;定义的&lt;em&gt;self的&lt;/em&gt;每个1-d子数组，返回一个包含True元素的数组。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ea109271e7fe639649aeaaf2a0b5dd56ecc23fcf" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the index of the largest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;）。返回&lt;em&gt;self&lt;/em&gt;沿&lt;em&gt;axis&lt;/em&gt;的最大元素的索引。</target>
        </trans-unit>
        <trans-unit id="9e5a451b453bc4aefcc71e37cd8b0e84168886e8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the index of the smallest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;）。返回&lt;em&gt;自身&lt;/em&gt;最小元素沿&lt;em&gt;轴&lt;/em&gt;的索引。</target>
        </trans-unit>
        <trans-unit id="cf7a1a44ff60373e9f731b7ce7e339177577c561" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argpartition#numpy.ndarray.argpartition&quot;&gt;&lt;code&gt;ndarray.argpartition&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;ktharray&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Return an array of indices such that selection of these indices along the given &lt;code&gt;axis&lt;/code&gt; would return a partitioned version of &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.argpartition#numpy.ndarray.argpartition&quot;&gt; &lt;code&gt;ndarray.argpartition&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;ktharray&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;，&lt;em&gt;kind&lt;/em&gt;）。返回一个索引数组，这样沿给定 &lt;code&gt;axis&lt;/code&gt; 选择这些索引将返回&lt;em&gt;self&lt;/em&gt;的分区版本。</target>
        </trans-unit>
        <trans-unit id="d75ff39235401fe4390dbb04fd226bfccafd46e5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argsort#numpy.ndarray.argsort&quot;&gt;&lt;code&gt;ndarray.argsort&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array of indices such that selection of these indices along the given &lt;code&gt;axis&lt;/code&gt; would return a sorted version of &lt;em&gt;self&lt;/em&gt;. If &lt;em&gt;self&lt;/em&gt; -&amp;gt;descr is a data-type with fields defined, then self-&amp;gt;descr-&amp;gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.argsort#numpy.ndarray.argsort&quot;&gt; &lt;code&gt;ndarray.argsort&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;）。返回索引数组，以便沿给定 &lt;code&gt;axis&lt;/code&gt; 选择这些索引将返回&lt;em&gt;self&lt;/em&gt;的排序版本。如果&lt;em&gt;self-&lt;/em&gt; &amp;gt; descr是定义了字段的数据类型，则使用self-&amp;gt; descr-&amp;gt; names确定排序顺序。第一个字段相等的比较将使用第二个字段，依此类推。要更改结构化数组的排序顺序，请创建具有不同名称顺序的新数据类型，并使用该新数据类型构造数组的视图。</target>
        </trans-unit>
        <trans-unit id="6daadea926a9bfb0a800c60a35b85b50c40374a1" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.byteswap#numpy.ndarray.byteswap&quot;&gt;&lt;code&gt;ndarray.byteswap&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;inplace&lt;/em&gt;). Return an array whose data area is byteswapped. If &lt;em&gt;inplace&lt;/em&gt; is non-zero, then do the byteswap inplace and return a reference to self. Otherwise, create a byteswapped copy and leave self unchanged.</source>
          <target state="translated">相当于&lt;a href=&quot;generated/numpy.ndarray.byteswap#numpy.ndarray.byteswap&quot;&gt; &lt;code&gt;ndarray.byteswap&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;个体经营&lt;/em&gt;，&lt;em&gt;就地&lt;/em&gt;）。返回其数据区域为字节包装的数组。如果&lt;em&gt;就地&lt;/em&gt;不为零，然后执行字节交换就地并返回一个引用自我。否则，请创建一个字节包装的副本，并使自己保持不变。</target>
        </trans-unit>
        <trans-unit id="2ab0b0009765a5d262f32c0eec580607299fc96a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.choose#numpy.ndarray.choose&quot;&gt;&lt;code&gt;ndarray.choose&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt;, &lt;em&gt;ret&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt;). Create a new array by selecting elements from the sequence of arrays in &lt;em&gt;op&lt;/em&gt; based on the integer values in &lt;em&gt;self&lt;/em&gt;. The arrays must all be broadcastable to the same shape and the entries in &lt;em&gt;self&lt;/em&gt; should be between 0 and len(&lt;em&gt;op&lt;/em&gt;). The output is placed in &lt;em&gt;ret&lt;/em&gt; unless it is &lt;code&gt;NULL&lt;/code&gt; in which case a new output is created. The &lt;em&gt;clipmode&lt;/em&gt; argument determines behavior for when entries in &lt;em&gt;self&lt;/em&gt; are not between 0 and len(&lt;em&gt;op&lt;/em&gt;).</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.choose#numpy.ndarray.choose&quot;&gt; &lt;code&gt;ndarray.choose&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;op&lt;/em&gt;，&lt;em&gt;ret&lt;/em&gt;，&lt;em&gt;clipmode&lt;/em&gt;）。通过根据&lt;em&gt;self中&lt;/em&gt;的整数值从&lt;em&gt;op中&lt;/em&gt;的数组序列中选择元素来创建新数组。数组必须都可以广播为相同形状，并且&lt;em&gt;self中&lt;/em&gt;的条目应在0​​到len（&lt;em&gt;op&lt;/em&gt;）之间。除非它为 &lt;code&gt;NULL&lt;/code&gt; ，否则输出将放置在&lt;em&gt;ret中&lt;/em&gt;，在这种情况下，将创建新的输出。所述&lt;em&gt;clipmode&lt;/em&gt;参数确定用于当在条目行为&lt;em&gt;自&lt;/em&gt;不介于0和LEN（&lt;em&gt;OP&lt;/em&gt;）。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="07498cd87fe2ef12a2b26de127164c39b4bd9e44" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.clip#numpy.ndarray.clip&quot;&gt;&lt;code&gt;ndarray.clip&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;min&lt;/em&gt;, &lt;em&gt;max&lt;/em&gt;). Clip an array, &lt;em&gt;self&lt;/em&gt;, so that values larger than &lt;em&gt;max&lt;/em&gt; are fixed to &lt;em&gt;max&lt;/em&gt; and values less than &lt;em&gt;min&lt;/em&gt; are fixed to &lt;em&gt;min&lt;/em&gt;.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.clip#numpy.ndarray.clip&quot;&gt; &lt;code&gt;ndarray.clip&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;min&lt;/em&gt;，&lt;em&gt;max&lt;/em&gt;）。&lt;em&gt;自我&lt;/em&gt;裁剪数组，以便将大于&lt;em&gt;max的&lt;/em&gt;值固定为&lt;em&gt;max&lt;/em&gt;，将小于&lt;em&gt;min的&lt;/em&gt;值固定为&lt;em&gt;min&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="c163c568fd35392b35f7cb27b6a29f0e9cbd90da" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.compress#numpy.ndarray.compress&quot;&gt;&lt;code&gt;ndarray.compress&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;condition&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt; ). Return the elements along &lt;em&gt;axis&lt;/em&gt; corresponding to elements of &lt;em&gt;condition&lt;/em&gt; that are true.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.compress#numpy.ndarray.compress&quot;&gt; &lt;code&gt;ndarray.compress&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;condition&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;）。沿&lt;em&gt;轴&lt;/em&gt;返回与&lt;em&gt;条件&lt;/em&gt;为true 的元素相对应的元素。</target>
        </trans-unit>
        <trans-unit id="dd9acb1c9e137920376909d2dadce0362beab80c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.conjugate#numpy.ndarray.conjugate&quot;&gt;&lt;code&gt;ndarray.conjugate&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return the complex conjugate of &lt;em&gt;self&lt;/em&gt;. If &lt;em&gt;self&lt;/em&gt; is not of complex data type, then return &lt;em&gt;self&lt;/em&gt; with a reference.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.conjugate#numpy.ndarray.conjugate&quot;&gt; &lt;code&gt;ndarray.conjugate&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;）。返回&lt;em&gt;self&lt;/em&gt;的复共轭。如果&lt;em&gt;self&lt;/em&gt;不是复杂的数据类型，则返回带有引用的&lt;em&gt;self&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="cf40d04106c5d52e1884e99b3a37b71d8a81e331" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt;&lt;code&gt;ndarray.copy&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;fortran&lt;/em&gt;). Make a copy of the &lt;em&gt;old&lt;/em&gt; array. The returned array is always aligned and writeable with data interpreted the same as the old array. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, then a C-style contiguous array is returned. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;, then a Fortran-style contiguous array is returned. If &lt;em&gt;order is&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, then the array returned is Fortran-style contiguous only if the old one is; otherwise, it is C-style contiguous.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt; &lt;code&gt;ndarray.copy&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;fortran&lt;/em&gt;）。复制&lt;em&gt;旧&lt;/em&gt;数组。返回的数组始终与可解释的数组对齐和写入，与旧数组解释的数据相同。如果&lt;em&gt;order&lt;/em&gt;为&lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt;，则返回C样式的连续数组。如果&lt;em&gt;order&lt;/em&gt;为&lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt;，则返回一个Fortran样式的连续数组。如果&lt;em&gt;order为&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; &lt;/a&gt;，则仅当旧数组为数组时，返回的数组才为Fortran样式的连续数组。否则，它是C样式连续的。</target>
        </trans-unit>
        <trans-unit id="98feecd02ab5026f0970a3c09806ab4167d96259" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.cumprod#numpy.ndarray.cumprod&quot;&gt;&lt;code&gt;ndarray.cumprod&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d cumulative products of elements in &lt;code&gt;self&lt;/code&gt; along &lt;code&gt;axis&lt;/code&gt;. Perform the product after converting data to data type &lt;code&gt;rtype&lt;/code&gt;.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.cumprod#numpy.ndarray.cumprod&quot;&gt; &lt;code&gt;ndarray.cumprod&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;，&lt;em&gt;rtype&lt;/em&gt;）。沿 &lt;code&gt;axis&lt;/code&gt; 返回 &lt;code&gt;self&lt;/code&gt; 中元素的一维累积积。将数据转换为数据类型 &lt;code&gt;rtype&lt;/code&gt; 后执行产品。</target>
        </trans-unit>
        <trans-unit id="26f34a6ad4ecf38e07a2778b6f8366d8507a10ea" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.cumsum#numpy.ndarray.cumsum&quot;&gt;&lt;code&gt;ndarray.cumsum&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return cumulative 1-d sums of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the sum after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.cumsum#numpy.ndarray.cumsum&quot;&gt; &lt;code&gt;ndarray.cumsum&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;，&lt;em&gt;rtype&lt;/em&gt;）。沿&lt;em&gt;轴&lt;/em&gt;返回&lt;em&gt;自身&lt;/em&gt;中元素的累积一维和。将数据转换为数据类型&lt;em&gt;rtype&lt;/em&gt;后执行求和。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="44d031ba857ad4460b29f51ce74504941e945e52" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.diagonal#numpy.ndarray.diagonal&quot;&gt;&lt;code&gt;ndarray.diagonal&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;, &lt;em&gt;axis1&lt;/em&gt;, &lt;em&gt;axis2&lt;/em&gt; ). Return the &lt;em&gt;offset&lt;/em&gt; diagonals of the 2-d arrays defined by &lt;em&gt;axis1&lt;/em&gt; and &lt;em&gt;axis2&lt;/em&gt;.</source>
          <target state="translated">相当于&lt;a href=&quot;generated/numpy.ndarray.diagonal#numpy.ndarray.diagonal&quot;&gt; &lt;code&gt;ndarray.diagonal&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;自我&lt;/em&gt;，&lt;em&gt;偏移&lt;/em&gt;，&lt;em&gt;轴1&lt;/em&gt;，&lt;em&gt;Axis2的&lt;/em&gt;）。返回由&lt;em&gt;axis1&lt;/em&gt;和&lt;em&gt;axis2&lt;/em&gt;定义的&lt;em&gt;二维&lt;/em&gt;数组的&lt;em&gt;偏移&lt;/em&gt;对角线。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6400ea427e27ba969159bbf1cd1e50c3dd25455" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt;&lt;code&gt;ndarray.flatten&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;). Return a 1-d copy of the array. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt; the elements are scanned out in Fortran order (first-dimension varies the fastest). If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, the elements of &lt;code&gt;self&lt;/code&gt; are scanned in C-order (last dimension varies the fastest). If &lt;em&gt;order&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, then the result of &lt;a href=&quot;#c.PyArray_ISFORTRAN&quot;&gt;&lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;) is used to determine which order to flatten.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt; &lt;code&gt;ndarray.flatten&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;order&lt;/em&gt;）。返回数组的一维副本。如果&lt;em&gt;order&lt;/em&gt;为&lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; ,则按&lt;/a&gt; Fortran顺序扫描出元素（第一维变化最快）。如果&lt;em&gt;order&lt;/em&gt;为&lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt;，则按 C顺序扫描 &lt;code&gt;self&lt;/code&gt; 的元素（最后一个维度变化最快）。如果&lt;em&gt;订单为&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; &lt;/a&gt;，则使用&lt;a href=&quot;#c.PyArray_ISFORTRAN&quot;&gt; &lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;）的结果来确定要展平的订单。</target>
        </trans-unit>
        <trans-unit id="acb7bf8250a91a19555dbcdb02102524e6c94de7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.getfield#numpy.ndarray.getfield&quot;&gt;&lt;code&gt;ndarray.getfield&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;). This function &lt;a href=&quot;https://docs.python.org/3/c-api/intro.html?reference-count-details&quot;&gt;steals a reference&lt;/a&gt; to &lt;code&gt;PyArray_Descr&lt;/code&gt; and returns a new array of the given &lt;code&gt;dtype&lt;/code&gt; using the data in the current array at a specified &lt;code&gt;offset&lt;/code&gt; in bytes. The &lt;code&gt;offset&lt;/code&gt; plus the itemsize of the new array type must be less than &lt;code&gt;self
-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; or an error is raised. The same shape and strides as the original array are used. Therefore, this function has the effect of returning a field from a structured array. But, it can also be used to select specific bytes or groups of bytes from any array type.</source>
          <target state="translated">相当于&lt;a href=&quot;generated/numpy.ndarray.getfield#numpy.ndarray.getfield&quot;&gt; &lt;code&gt;ndarray.getfield&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;自我&lt;/em&gt;，&lt;em&gt;D型&lt;/em&gt;，&lt;em&gt;抵消&lt;/em&gt;）。此函数&lt;a href=&quot;https://docs.python.org/3/c-api/intro.html?reference-count-details&quot;&gt;窃取的引用&lt;/a&gt;到 &lt;code&gt;PyArray_Descr&lt;/code&gt; 并返回给定的一个新的数组 &lt;code&gt;dtype&lt;/code&gt; 使用所述数据的当前阵列中在指定的 &lt;code&gt;offset&lt;/code&gt; （字节）。的 &lt;code&gt;offset&lt;/code&gt; 的新的数组类型的加itemsize必须小于 &lt;code&gt;self -&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; 或引发错误。使用与原始数组相同的形状和步幅。因此，此函数具有从结构化数组返回字段的作用。但是，它也可以用于从任何数组类型中选择特定的字节或字节组。</target>
        </trans-unit>
        <trans-unit id="6e1e5da9cdc7a9b4c6725235e40182f3951d083a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Returns the largest element of &lt;em&gt;self&lt;/em&gt; along the given &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;）。返回沿给定&lt;em&gt;轴&lt;/em&gt;的最大&lt;em&gt;self&lt;/em&gt;元素。当结果是单个元素时，返回一个numpy标量而不是ndarray。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bdd01120eccb02f99889760c9ef36e279a9f9ea8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.mean#numpy.ndarray.mean&quot;&gt;&lt;code&gt;ndarray.mean&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Returns the mean of the elements along the given &lt;em&gt;axis&lt;/em&gt;, using the enumerated type &lt;em&gt;rtype&lt;/em&gt; as the data type to sum in. Default sum behavior is obtained using &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; for &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.mean#numpy.ndarray.mean&quot;&gt; &lt;code&gt;ndarray.mean&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;，&lt;em&gt;rtype&lt;/em&gt;）。使用枚举类型&lt;em&gt;rtype&lt;/em&gt;作为要求和的数据类型，返回沿给定&lt;em&gt;轴&lt;/em&gt;的元素的平均值。默认的求和行为是使用&lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; &lt;/a&gt;来获取&lt;em&gt;rtype的&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e276f562081b61880c79febde9752c6b4583d12" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the smallest element of &lt;em&gt;self&lt;/em&gt; along the given &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;）。沿给定&lt;em&gt;轴&lt;/em&gt;返回&lt;em&gt;self&lt;/em&gt;的最小元素。当结果是单个元素时，返回一个numpy标量而不是ndarray。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e792db3a62a29831ce03976f5ea2350fba5a323b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;ndarray.nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Returns a tuple of index arrays that select elements of &lt;em&gt;self&lt;/em&gt; that are nonzero. If (nd= &lt;a href=&quot;#c.PyArray_NDIM&quot;&gt;&lt;code&gt;PyArray_NDIM&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;self&lt;/code&gt; ))==1, then a single index array is returned. The index arrays have data type &lt;a href=&quot;c-api.dtype#c.NPY_INTP&quot;&gt;&lt;code&gt;NPY_INTP&lt;/code&gt;&lt;/a&gt;. If a tuple is returned (nd</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;ndarray.nonzero&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;）。返回索引数组的元组，该数组选择非零值的&lt;em&gt;self&lt;/em&gt;元素。如果（nd = &lt;a href=&quot;#c.PyArray_NDIM&quot;&gt; &lt;code&gt;PyArray_NDIM&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;self&lt;/code&gt; ））== 1，则返回单个索引数组。索引数组的数据类型为&lt;a href=&quot;c-api.dtype#c.NPY_INTP&quot;&gt; &lt;code&gt;NPY_INTP&lt;/code&gt; &lt;/a&gt;。如果返回一个元组（nd</target>
        </trans-unit>
        <trans-unit id="a70d121c7d953594f404dacb0d342fd3ab8b30ba" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.partition#numpy.ndarray.partition&quot;&gt;&lt;code&gt;ndarray.partition&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;ktharray&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Partitions the array so that the values of the element indexed by &lt;em&gt;ktharray&lt;/em&gt; are in the positions they would be if the array is fully sorted and places all elements smaller than the kth before and all elements equal or greater after the kth element. The ordering of all elements within the partitions is undefined. If &lt;em&gt;self&lt;/em&gt;-&amp;gt;descr is a data-type with fields defined, then self-&amp;gt;descr-&amp;gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type. Returns zero on success and -1 on failure.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.partition#numpy.ndarray.partition&quot;&gt; &lt;code&gt;ndarray.partition&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;ktharray&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;，&lt;em&gt;kind&lt;/em&gt;）。对数组进行分区，以使&lt;em&gt;ktharray&lt;/em&gt;索引的元素的值位于如果数组完全排序后的位置，并且将所有小于&lt;em&gt;kth&lt;/em&gt;的元素&lt;em&gt;放在kth&lt;/em&gt;元素之前，并将所有大于或等于&lt;em&gt;kth&lt;/em&gt;元素的元素&lt;em&gt;放在&lt;/em&gt;后面。分区中所有元素的顺序是不确定的。如果&lt;em&gt;自我&lt;/em&gt;-&amp;gt; descr是定义了字段的数据类型，然后使用self-&amp;gt; descr-&amp;gt; names确定排序顺序。第一个字段相等的比较将使用第二个字段，依此类推。要更改结构化数组的排序顺序，请创建具有不同名称顺序的新数据类型，并使用该新数据类型构造数组的视图。成功返回零，失败返回-1。</target>
        </trans-unit>
        <trans-unit id="1404ab20af4a0d50c24ff1ca93cc3a3448c7e38e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.prod#numpy.ndarray.prod&quot;&gt;&lt;code&gt;ndarray.prod&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d products of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the product after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.prod#numpy.ndarray.prod&quot;&gt; &lt;code&gt;ndarray.prod&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;，&lt;em&gt;rtype&lt;/em&gt;）。沿&lt;em&gt;轴&lt;/em&gt;返回&lt;em&gt;自身的&lt;/em&gt;一维元素乘积。将数据转换为数据类型&lt;em&gt;rtype&lt;/em&gt;后执行产品。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1100d008c0276fd76e61e9204938c06e2c190cea" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.ptp#numpy.ndarray.ptp&quot;&gt;&lt;code&gt;ndarray.ptp&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the difference between the largest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt; and the smallest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.ptp#numpy.ndarray.ptp&quot;&gt; &lt;code&gt;ndarray.ptp&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;）。返回的最大元素之间的差异&lt;em&gt;自我&lt;/em&gt;沿&lt;em&gt;轴&lt;/em&gt;和的最小元素&lt;em&gt;自我&lt;/em&gt;沿&lt;em&gt;轴线&lt;/em&gt;。如果结果是单个元素，则返回一个numpy标量而不是ndarray。</target>
        </trans-unit>
        <trans-unit id="2c16f538cf9a4222086ade1f8bc40148ea4157cd" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.repeat#numpy.ndarray.repeat&quot;&gt;&lt;code&gt;ndarray.repeat&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Copy the elements of &lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt; times along the given &lt;em&gt;axis&lt;/em&gt;. Either &lt;em&gt;op&lt;/em&gt; is a scalar integer or a sequence of length &lt;em&gt;self&lt;/em&gt; -&amp;gt;dimensions[ &lt;em&gt;axis&lt;/em&gt; ] indicating how many times to repeat each item along the axis.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.repeat#numpy.ndarray.repeat&quot;&gt; &lt;code&gt;ndarray.repeat&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;op&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;）。沿给定的&lt;em&gt;轴&lt;/em&gt;复制&lt;em&gt;self&lt;/em&gt;元素，&lt;em&gt;op&lt;/em&gt;时间。无论哪种&lt;em&gt;运算&lt;/em&gt;是一个标量整数或长度的序列&lt;em&gt;的自&lt;/em&gt; - &amp;gt;尺寸[ &lt;em&gt;轴&lt;/em&gt;指示多少次沿轴线重复的每个项目。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="89f8dce1a3fdb6440169e6117acb2747787948e3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.reshape#numpy.ndarray.reshape&quot;&gt;&lt;code&gt;ndarray.reshape&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;shape&lt;/em&gt;) where &lt;em&gt;shape&lt;/em&gt; is a sequence. Converts &lt;em&gt;shape&lt;/em&gt; to a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Dims&quot;&gt;&lt;code&gt;PyArray_Dims&lt;/code&gt;&lt;/a&gt; structure and calls &lt;a href=&quot;#c.PyArray_Newshape&quot;&gt;&lt;code&gt;PyArray_Newshape&lt;/code&gt;&lt;/a&gt; internally. For back-ward compatibility &amp;ndash; Not recommended</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.reshape#numpy.ndarray.reshape&quot;&gt; &lt;code&gt;ndarray.reshape&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;shape&lt;/em&gt;），其中&lt;em&gt;shape&lt;/em&gt;是一个序列。将&lt;em&gt;shape&lt;/em&gt;转换为&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Dims&quot;&gt; &lt;code&gt;PyArray_Dims&lt;/code&gt; &lt;/a&gt;结构，并&lt;a href=&quot;#c.PyArray_Newshape&quot;&gt; &lt;code&gt;PyArray_Newshape&lt;/code&gt; &lt;/a&gt;内部调用PyArray_Newshape。向后兼容&amp;ndash;不推荐</target>
        </trans-unit>
        <trans-unit id="c66cfa86b4fd8c96342e13259600ca57c73356a4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt;&lt;code&gt;ndarray.resize&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;newshape&lt;/em&gt;, refcheck &lt;code&gt;=&lt;/code&gt;&lt;em&gt;refcheck&lt;/em&gt;, order= fortran ). This function only works on single-segment arrays. It changes the shape of &lt;em&gt;self&lt;/em&gt; inplace and will reallocate the memory for &lt;em&gt;self&lt;/em&gt; if &lt;em&gt;newshape&lt;/em&gt; has a different total number of elements then the old shape. If reallocation is necessary, then &lt;em&gt;self&lt;/em&gt; must own its data, have &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;base==NULL&lt;/code&gt;, have &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;weakrefs==NULL&lt;/code&gt;, and (unless refcheck is 0) not be referenced by any other array. The fortran argument can be &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;. It currently has no effect. Eventually it could be used to determine how the resize operation should view the data when constructing a differently-dimensioned array. Returns None on success and NULL on error.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt; &lt;code&gt;ndarray.resize&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;newshape&lt;/em&gt;，refcheck &lt;code&gt;=&lt;/code&gt; &lt;em&gt;refcheck&lt;/em&gt;，order = fortran）。此功能仅适用于单段阵列。它改变的形状&lt;em&gt;自&lt;/em&gt;就位，并且将重新分配所述存储器中用于&lt;em&gt;自我&lt;/em&gt;如果&lt;em&gt;newshape&lt;/em&gt;具有元素的不同总数，则旧的形状。如果重新分配是必要的，那么&lt;em&gt;自&lt;/em&gt;必须拥有自己的数据，具有&lt;em&gt;自&lt;/em&gt; - &lt;code&gt;&amp;gt;base==NULL&lt;/code&gt; ，具有&lt;em&gt;自&lt;/em&gt; - &lt;code&gt;&amp;gt;weakrefs==NULL&lt;/code&gt; ，和（除非refcheck是0）不能被任何其他阵列中被引用。 fortran参数可以是&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt;。目前无效。最终，它可用于确定在构建不同维度的数组时调整大小操作应如何查看数据。成功返回None，错误返回NULL。</target>
        </trans-unit>
        <trans-unit id="c35d0fb0b3b672f40f8ed22b6a36b98bc32ccd79" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.round#numpy.ndarray.round&quot;&gt;&lt;code&gt;ndarray.round&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;decimals&lt;/em&gt;, &lt;em&gt;out&lt;/em&gt;). Returns the array with elements rounded to the nearest decimal place. The decimal place is defined as the</source>
          <target state="translated">相当于&lt;a href=&quot;generated/numpy.ndarray.round#numpy.ndarray.round&quot;&gt; &lt;code&gt;ndarray.round&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;自我&lt;/em&gt;，&lt;em&gt;小数&lt;/em&gt;，&lt;em&gt;出来&lt;/em&gt;）。返回元素四舍五入到最接近的小数位的数组。小数位定义为</target>
        </trans-unit>
        <trans-unit id="77c91912c2f0496c5da34bf18831db8c3ec272aa" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.searchsorted#numpy.ndarray.searchsorted&quot;&gt;&lt;code&gt;ndarray.searchsorted&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;values&lt;/em&gt;, &lt;em&gt;side&lt;/em&gt;, &lt;em&gt;perm&lt;/em&gt;). Assuming &lt;em&gt;self&lt;/em&gt; is a 1-d array in ascending order, then the output is an array of indices the same shape as &lt;em&gt;values&lt;/em&gt; such that, if the elements in &lt;em&gt;values&lt;/em&gt; were inserted before the indices, the order of &lt;em&gt;self&lt;/em&gt; would be preserved. No checking is done on whether or not self is in ascending order.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.searchsorted#numpy.ndarray.searchsorted&quot;&gt; &lt;code&gt;ndarray.searchsorted&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;values&lt;/em&gt;，&lt;em&gt;side&lt;/em&gt;，&lt;em&gt;perm&lt;/em&gt;）。假设&lt;em&gt;self&lt;/em&gt;是一个升序的1维数组，那么输出是一个索引数组，其形状与&lt;em&gt;值&lt;/em&gt;相同，因此，如果将&lt;em&gt;value&lt;/em&gt;中的元素插入到索引之前，则&lt;em&gt;self&lt;/em&gt;的顺序将得以保留。不检查自身是否升序。</target>
        </trans-unit>
        <trans-unit id="129c27494826551cd6d91c742839f2dd3b7a2b39" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.setfield#numpy.ndarray.setfield&quot;&gt;&lt;code&gt;ndarray.setfield&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;val&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt; ). Set the field starting at &lt;em&gt;offset&lt;/em&gt; in bytes and of the given &lt;em&gt;dtype&lt;/em&gt; to &lt;em&gt;val&lt;/em&gt;. The &lt;em&gt;offset&lt;/em&gt; plus &lt;em&gt;dtype&lt;/em&gt; -&amp;gt;elsize must be less than &lt;em&gt;self&lt;/em&gt; -&amp;gt;descr-&amp;gt;elsize or an error is raised. Otherwise, the &lt;em&gt;val&lt;/em&gt; argument is converted to an array and copied into the field pointed to. If necessary, the elements of &lt;em&gt;val&lt;/em&gt; are repeated to fill the destination array, But, the number of elements in the destination must be an integer multiple of the number of elements in &lt;em&gt;val&lt;/em&gt;.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.setfield#numpy.ndarray.setfield&quot;&gt; &lt;code&gt;ndarray.setfield&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;val&lt;/em&gt;，&lt;em&gt;dtype&lt;/em&gt;，&lt;em&gt;offset&lt;/em&gt;）。将以给定&lt;em&gt;dtype的&lt;/em&gt;字节&lt;em&gt;偏移量&lt;/em&gt;开始的字段设置为&lt;em&gt;val&lt;/em&gt;。的&lt;em&gt;偏移量&lt;/em&gt;加上&lt;em&gt;D型&lt;/em&gt; - &amp;gt; elsize必须小于&lt;em&gt;自&lt;/em&gt; - &amp;gt; descr-&amp;gt; elsize或引发错误。否则，&lt;em&gt;val&lt;/em&gt;参数将转换为数组，然后复制到指向的字段中。如有必要，重复&lt;em&gt;val&lt;/em&gt;的元素以填充目标数组，但是，目标中的元素数必须是in的元素数的整数倍。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;VAL&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="329e170888d304760a845c23e2123d83a997ded2" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.sort#numpy.ndarray.sort&quot;&gt;&lt;code&gt;ndarray.sort&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Return an array with the items of &lt;em&gt;self&lt;/em&gt; sorted along &lt;em&gt;axis&lt;/em&gt;. The array is sorted using the algorithm denoted by &lt;em&gt;kind&lt;/em&gt; , which is an integer/enum pointing to the type of sorting algorithms used.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.sort#numpy.ndarray.sort&quot;&gt; &lt;code&gt;ndarray.sort&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;，&lt;em&gt;kind&lt;/em&gt;）。返回一个数组，其中&lt;em&gt;self&lt;/em&gt;的项沿&lt;em&gt;axis&lt;/em&gt;排序。使用&lt;em&gt;kind&lt;/em&gt;表示的算法对数组进行排序，后者是一个整数/枚举，指向所使用的排序算法的类型。</target>
        </trans-unit>
        <trans-unit id="18f23f95a5677bb30c45f3519a8a38c4eb9ab14d" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.squeeze#numpy.ndarray.squeeze&quot;&gt;&lt;code&gt;ndarray.squeeze&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return a new view of &lt;em&gt;self&lt;/em&gt; with all of the dimensions of length 1 removed from the shape.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.squeeze#numpy.ndarray.squeeze&quot;&gt; &lt;code&gt;ndarray.squeeze&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;）。返回一个新的&lt;em&gt;self&lt;/em&gt;视图，将所有长度为1的尺寸从图形中删除。</target>
        </trans-unit>
        <trans-unit id="f3ea257f6db1c3b5b426fb4027029e9f1b7413a5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.std#numpy.ndarray.std&quot;&gt;&lt;code&gt;ndarray.std&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return the standard deviation using data along &lt;em&gt;axis&lt;/em&gt; converted to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.std#numpy.ndarray.std&quot;&gt; &lt;code&gt;ndarray.std&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;，&lt;em&gt;rtype&lt;/em&gt;）。使用沿&lt;em&gt;轴的&lt;/em&gt;数据返回转换为数据类型&lt;em&gt;rtype&lt;/em&gt;的标准差。</target>
        </trans-unit>
        <trans-unit id="4c7387b455871f5d5fed3305db644e74b9628876" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt;&lt;code&gt;ndarray.sum&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d vector sums of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the sum after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt; &lt;code&gt;ndarray.sum&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;，&lt;em&gt;rtype&lt;/em&gt;）。沿&lt;em&gt;axis&lt;/em&gt;返回&lt;em&gt;自身&lt;/em&gt;中元素的一维向量和。将数据转换为数据类型&lt;em&gt;rtype&lt;/em&gt;后执行求和。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b9ac6ba7775647d994932881b5b117c78bc1d61" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.swapaxes#numpy.ndarray.swapaxes&quot;&gt;&lt;code&gt;ndarray.swapaxes&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;a1&lt;/em&gt;, &lt;em&gt;a2&lt;/em&gt;). The returned array is a new view of the data in &lt;em&gt;self&lt;/em&gt; with the given axes, &lt;em&gt;a1&lt;/em&gt; and &lt;em&gt;a2&lt;/em&gt;, swapped.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.swapaxes#numpy.ndarray.swapaxes&quot;&gt; &lt;code&gt;ndarray.swapaxes&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;a1&lt;/em&gt;，&lt;em&gt;a2&lt;/em&gt;）。返回的数组是交换了给定轴&lt;em&gt;a1&lt;/em&gt;和&lt;em&gt;a2的&lt;/em&gt;&lt;em&gt;自身&lt;/em&gt;数据的新视图。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="526d5a8267bf48a76f6e4bef39106e81c90185a6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;ndarray.take&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;indices&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;ret&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt;) except &lt;em&gt;axis&lt;/em&gt; =None in Python is obtained by setting &lt;em&gt;axis&lt;/em&gt; = &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; in C. Extract the items from self indicated by the integer-valued &lt;em&gt;indices&lt;/em&gt; along the given &lt;em&gt;axis.&lt;/em&gt; The clipmode argument can be &lt;a href=&quot;#c.NPY_RAISE&quot;&gt;&lt;code&gt;NPY_RAISE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_WRAP&quot;&gt;&lt;code&gt;NPY_WRAP&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.NPY_CLIP&quot;&gt;&lt;code&gt;NPY_CLIP&lt;/code&gt;&lt;/a&gt; to indicate what to do with out-of-bound indices. The &lt;em&gt;ret&lt;/em&gt; argument can specify an output array rather than having one created internally.</source>
          <target state="translated">相当于&lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt; &lt;code&gt;ndarray.take&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;自&lt;/em&gt;，&lt;em&gt;指数&lt;/em&gt;，&lt;em&gt;轴&lt;/em&gt;，&lt;em&gt;RET&lt;/em&gt;，&lt;em&gt;clipmode&lt;/em&gt;）除&lt;em&gt;轴&lt;/em&gt; =无在Python通过设置获得&lt;em&gt;轴&lt;/em&gt; = &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; &lt;/a&gt;中C.提取项从自指示由整数值&lt;em&gt;索引&lt;/em&gt;沿给定&lt;em&gt;轴线。&lt;/em&gt; clipmode参数可以是&lt;a href=&quot;#c.NPY_RAISE&quot;&gt; &lt;code&gt;NPY_RAISE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_WRAP&quot;&gt; &lt;code&gt;NPY_WRAP&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#c.NPY_CLIP&quot;&gt; &lt;code&gt;NPY_CLIP&lt;/code&gt; &lt;/a&gt;来指示如何处理越界索引。的&lt;em&gt;RET&lt;/em&gt;参数可以指定，而不是在内部创建一个输出阵列。</target>
        </trans-unit>
        <trans-unit id="3fbb6db45f5065f7d5f46448fca11ee7f459d488" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt;&lt;code&gt;ndarray.tobytes&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;). Return the bytes of this array in a Python string.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt; &lt;code&gt;ndarray.tobytes&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;order&lt;/em&gt;）。以Python字符串返回此数组的字节。</target>
        </trans-unit>
        <trans-unit id="e1487cf1aae9421a58178865b5cc518907b872e6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.tolist#numpy.ndarray.tolist&quot;&gt;&lt;code&gt;ndarray.tolist&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return a nested Python list from &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">等效于&lt;a href=&quot;generated/numpy.ndarray.tolist#numpy.ndarray.tolist&quot;&gt; &lt;code&gt;ndarray.tolist&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;）。从&lt;em&gt;self&lt;/em&gt;返回一个嵌套的Python列表。</target>
        </trans-unit>
        <trans-unit id="92f6eaf18a532cc83a7879c0fc5e0cdb9219ac58" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.trace#numpy.ndarray.trace&quot;&gt;&lt;code&gt;ndarray.trace&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;, &lt;em&gt;axis1&lt;/em&gt;, &lt;em&gt;axis2&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return the sum (using &lt;em&gt;rtype&lt;/em&gt; as the data type of summation) over the &lt;em&gt;offset&lt;/em&gt; diagonal elements of the 2-d arrays defined by &lt;em&gt;axis1&lt;/em&gt; and &lt;em&gt;axis2&lt;/em&gt; variables. A positive offset chooses diagonals above the main diagonal. A negative offset selects diagonals below the main diagonal.</source>
          <target state="translated">相当于&lt;a href=&quot;generated/numpy.ndarray.trace#numpy.ndarray.trace&quot;&gt; &lt;code&gt;ndarray.trace&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;自我&lt;/em&gt;，&lt;em&gt;偏移&lt;/em&gt;，&lt;em&gt;轴1&lt;/em&gt;，&lt;em&gt;Axis2的&lt;/em&gt;，&lt;em&gt;舍入类型&lt;/em&gt;）。返回由&lt;em&gt;axis1&lt;/em&gt;和&lt;em&gt;axis2&lt;/em&gt;变量定义的&lt;em&gt;二维&lt;/em&gt;数组的&lt;em&gt;偏移&lt;/em&gt;对角线元素的和（使用&lt;em&gt;rtype&lt;/em&gt;作为求和的数据类型）。正偏移量选择主对角线上方的对角线。负偏移量选择主对角线以下的对角线。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="903dc5f64afb6611725d0b8ef7bd16c3db35ef02" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt;&lt;code&gt;ndarray.transpose&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;permute&lt;/em&gt;). Permute the axes of the ndarray object &lt;em&gt;self&lt;/em&gt; according to the data structure &lt;em&gt;permute&lt;/em&gt; and return the result. If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the resulting array has its axes reversed. For example if &lt;em&gt;self&lt;/em&gt; has shape</source>
          <target state="translated">相当于&lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt; &lt;code&gt;ndarray.transpose&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;自我&lt;/em&gt;，&lt;em&gt;置换&lt;/em&gt;）。根据数据结构&lt;em&gt;置换&lt;/em&gt; ndarray对象&lt;em&gt;自身&lt;/em&gt;的轴，并返回结果。如果&lt;em&gt;permute&lt;/em&gt;为 &lt;code&gt;NULL&lt;/code&gt; ，那么结果数组的轴将反转。例如，如果&lt;em&gt;自己&lt;/em&gt;有形状&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e84dfaf00361747bc32ce6d08fe80d8b155279f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;ndarray.view&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;). Return a new view of the array &lt;em&gt;self&lt;/em&gt; as possibly a different data-type, &lt;em&gt;dtype&lt;/em&gt;, and different array subclass &lt;em&gt;ptype&lt;/em&gt;.</source>
          <target state="translated">相当于&lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;ndarray.view&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;自我&lt;/em&gt;，&lt;em&gt;D型&lt;/em&gt;）。返回数组&lt;em&gt;self&lt;/em&gt;的新视图，可能是不同的数据类型&lt;em&gt;dtype&lt;/em&gt;和不同的数组子类&lt;em&gt;ptype&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="c80f2487a92354ad196d90ca737086d6a28cb501" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS&quot;&gt;&lt;code&gt;Py_BEGIN_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; except it uses &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; to determine if the macro if replaced with white-space or not.</source>
          <target state="translated">等效于&lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS&quot;&gt; &lt;code&gt;Py_BEGIN_ALLOW_THREADS&lt;/code&gt; ,&lt;/a&gt;但它使用 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 来确定是否将宏替换为空白。</target>
        </trans-unit>
        <trans-unit id="657a5eba5419e2937f0d7b0877025c3f2a8bf379" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_END_ALLOW_THREADS&quot;&gt;&lt;code&gt;Py_END_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; except it uses &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; to determine if the macro if replaced with white-space or not.</source>
          <target state="translated">等效于&lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_END_ALLOW_THREADS&quot;&gt; &lt;code&gt;Py_END_ALLOW_THREADS&lt;/code&gt; ,&lt;/a&gt;但它使用 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 来确定是否将宏替换为空白。</target>
        </trans-unit>
        <trans-unit id="821886e91092ad64682392ad985ffcb281eaf4b3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;1/2 * (np.exp(x) + np.exp(-x))&lt;/code&gt; and &lt;code&gt;np.cos(1j*x)&lt;/code&gt;.</source>
          <target state="translated">相当于 &lt;code&gt;1/2 * (np.exp(x) + np.exp(-x))&lt;/code&gt; 和 &lt;code&gt;np.cos(1j*x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cedbe2e2d0fc9bc98c2a4058eb21de10f0ba961" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;1/2 * (np.exp(x) - np.exp(-x))&lt;/code&gt; or &lt;code&gt;-1j * np.sin(1j*x)&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;1/2 * (np.exp(x) - np.exp(-x))&lt;/code&gt; 或 &lt;code&gt;-1j * np.sin(1j*x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65cabfa0a0b1ab314bf5ad313943ea0a61c9f913" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;a.copy(order='K')&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;a.copy(order='K')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a8b0df6f8f30decfdb8712f593677bd0361c0ef" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;divmod(x, 1)&lt;/code&gt; for positive &lt;code&gt;x&lt;/code&gt; with the return values switched.</source>
          <target state="translated">等效于 &lt;code&gt;divmod(x, 1)&lt;/code&gt; 对于正 &lt;code&gt;x&lt;/code&gt; ，返回值已切换。</target>
        </trans-unit>
        <trans-unit id="3f28125a3d825d23c8591cf7b44d136f5206aec6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;m[::-1,...]&lt;/code&gt;. Does not require the array to be two-dimensional.</source>
          <target state="translated">相当于 &lt;code&gt;m[::-1,...]&lt;/code&gt; 。不需要数组为二维。</target>
        </trans-unit>
        <trans-unit id="158b7bdd2f113f05d23975a3a9ae7c4cbbee72c4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.asarray(self)&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;np.asarray(self)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b757950b99b3fb5a49cac119260ff6b59afd089" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.asarray(x).ravel()&lt;/code&gt;</source>
          <target state="translated">等效于 &lt;code&gt;np.asarray(x).ravel()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01b942f822242874c950f31737a64908f9f10037" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.sin(x)/np.cos(x)&lt;/code&gt; element-wise.</source>
          <target state="translated">等效于 &lt;code&gt;np.sin(x)/np.cos(x)&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="e03e98ed258ef214f7093f680237951ada6cdb9f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.sinh(x)/np.cosh(x)&lt;/code&gt; or &lt;code&gt;-1j * np.tan(1j*x)&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;np.sinh(x)/np.cosh(x)&lt;/code&gt; 或 &lt;code&gt;-1j * np.tan(1j*x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6b5ff4ad03763736f9b2a4f6770ab65b1c73219" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.transpose(self)&lt;/code&gt; if &lt;code&gt;self&lt;/code&gt; is real-valued.</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 是实值，则等效于 &lt;code&gt;np.transpose(self)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75b818defe3ad1876ebfb087b965f01d49fa2ec9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;sqrt(x1**2 + x2**2)&lt;/code&gt;, element-wise. If &lt;code&gt;x1&lt;/code&gt; or &lt;code&gt;x2&lt;/code&gt; is scalar_like (i.e., unambiguously cast-able to a scalar type), it is broadcast for use with each element of the other argument. (See Examples)</source>
          <target state="translated">等效于 &lt;code&gt;sqrt(x1**2 + x2**2)&lt;/code&gt; （逐元素）。如果 &lt;code&gt;x1&lt;/code&gt; 或 &lt;code&gt;x2&lt;/code&gt; 是scalar_like（即明确地可转换为标量类型），则将其广播以与其他自变量的每个元素一起使用。（请参见示例）</target>
        </trans-unit>
        <trans-unit id="00df9c133fe8747499700e75effeb0cd5d136ccc" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x.copy()&lt;/code&gt;, but only defined for types that support arithmetic.</source>
          <target state="translated">等效于 &lt;code&gt;x.copy()&lt;/code&gt; ，但仅针对支持算术的类型定义。</target>
        </trans-unit>
        <trans-unit id="23adb20441299c90dbd1e383cfab76bf7d2274b8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x1 - x2&lt;/code&gt; in terms of array broadcasting.</source>
          <target state="translated">在阵列广播方面等效于 &lt;code&gt;x1 - x2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c304ff74936613f3d12e0fc5cde4c506dd3f3ab" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x1&lt;/code&gt; * &lt;code&gt;x2&lt;/code&gt; in terms of array broadcasting.</source>
          <target state="translated">在阵列广播方面相当于 &lt;code&gt;x1&lt;/code&gt; * &lt;code&gt;x2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98520850afe8056507d9d642ea9323b3ed72e130" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x1&lt;/code&gt; + &lt;code&gt;x2&lt;/code&gt; in terms of array broadcasting.</source>
          <target state="translated">在阵列广播方面相当于 &lt;code&gt;x1&lt;/code&gt; + &lt;code&gt;x2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="202bf1615636b8e0a84392691bc084a70b43390b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;em&gt;self&lt;/em&gt;.put(&lt;em&gt;values&lt;/em&gt;, &lt;em&gt;indices&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt; ). Put &lt;em&gt;values&lt;/em&gt; into &lt;em&gt;self&lt;/em&gt; at the corresponding (flattened) &lt;em&gt;indices&lt;/em&gt;. If &lt;em&gt;values&lt;/em&gt; is too small it will be repeated as necessary.</source>
          <target state="translated">等效于&lt;em&gt;self&lt;/em&gt; .put（&lt;em&gt;值&lt;/em&gt;，&lt;em&gt;索引&lt;/em&gt;，&lt;em&gt;clipmode&lt;/em&gt;）。把&lt;em&gt;值&lt;/em&gt;到&lt;em&gt;自&lt;/em&gt;于相应的（平坦化）&lt;em&gt;的索引&lt;/em&gt;。如果&lt;em&gt;值&lt;/em&gt;太小，将在必要时将其重复。</target>
        </trans-unit>
        <trans-unit id="65d607762120cf690bb00c590b16fa127fb75062" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;em&gt;self&lt;/em&gt;.ravel(&lt;em&gt;order&lt;/em&gt;). Same basic functionality as &lt;a href=&quot;#c.PyArray_Flatten&quot;&gt;&lt;code&gt;PyArray_Flatten&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;) except if &lt;em&gt;order&lt;/em&gt; is 0 and &lt;em&gt;self&lt;/em&gt; is C-style contiguous, the shape is altered but no copy is performed.</source>
          <target state="translated">等效于&lt;em&gt;self&lt;/em&gt; .ravel（&lt;em&gt;order&lt;/em&gt;）。基本功能与&lt;a href=&quot;#c.PyArray_Flatten&quot;&gt; &lt;code&gt;PyArray_Flatten&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;self&lt;/em&gt;，&lt;em&gt;order&lt;/em&gt;）相同，除了&lt;em&gt;order&lt;/em&gt;为0且&lt;em&gt;self&lt;/em&gt;为C样式的连续形式，形状会更改，但不会执行复制。</target>
        </trans-unit>
        <trans-unit id="9032a6cc40438a50e150a4a41ff47d4fe89a4820" translate="yes" xml:space="preserve">
          <source>Equivalent to PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING).</source>
          <target state="translated">相当于PyArray_CanCastTypeTo(fromtype,totype,NPY_SAFE_CASTING)。</target>
        </trans-unit>
        <trans-unit id="aa1dee2d3e2220598a3bbd05e1af8c95afb8286e" translate="yes" xml:space="preserve">
          <source>Equivalent to Python&amp;rsquo;s &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">等效于Python的 &lt;code&gt;%&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="c543b869fe6bab79a3a934117c7c6a1eff863d6f" translate="yes" xml:space="preserve">
          <source>Equivalent to Python&amp;rsquo;s &lt;code&gt;//&lt;/code&gt; operator.</source>
          <target state="translated">等效于Python的 &lt;code&gt;//&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="731025cc785b584c28e327dc6f1d60cad5cb1eb2" translate="yes" xml:space="preserve">
          <source>Equivalent to but faster than &lt;code&gt;np.maximum(a_min, np.minimum(a, a_max))&lt;/code&gt;. No check is performed to ensure &lt;code&gt;a_min &amp;lt; a_max&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;np.maximum(a_min, np.minimum(a, a_max))&lt;/code&gt; 等效但比其快。不执行检查以确保 &lt;code&gt;a_min &amp;lt; a_max&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b2f298705887fc3f13bb047301aaf8328f81dca" translate="yes" xml:space="preserve">
          <source>Equivalent to but faster than &lt;code&gt;np.minimum(a_max, np.maximum(a, a_min))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e127cc159cef630175cb2a2528435fea3e7fcdb3" translate="yes" xml:space="preserve">
          <source>Equivalent to calling &lt;code&gt;$ nosetests &amp;lt;argv&amp;gt; &amp;lt;file_to_run&amp;gt;&lt;/code&gt; from the command line</source>
          <target state="translated">等效于在命令行中调用 &lt;code&gt;$ nosetests &amp;lt;argv&amp;gt; &amp;lt;file_to_run&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed8f3be106058d41aa3036c07045c7a5df9a7239" translate="yes" xml:space="preserve">
          <source>Equivalent to creating a copy of the array and applying the MaskedArray &lt;code&gt;sort()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b847d0d31d2133c0201a061723b9aa92d8890f7" translate="yes" xml:space="preserve">
          <source>Equivalent to either NPY_INT or NPY_LONGLONG, depending on the platform.</source>
          <target state="translated">相当于NPY_INT或NPY_LONGLONG,取决于平台。</target>
        </trans-unit>
        <trans-unit id="85f38ed4c0f6096936fc4b84fb6a21d19adcc1cb" translate="yes" xml:space="preserve">
          <source>Equivalent to either NPY_UINT or NPY_ULONGLONG, depending on the platform.</source>
          <target state="translated">相当于NPY_UINT或NPY_ULONGLONG,取决于平台。</target>
        </trans-unit>
        <trans-unit id="d656dbe889cfc08e9f09fa23957b7de58cae8caa" translate="yes" xml:space="preserve">
          <source>Equivalent to m[:,::-1]. Requires the array to be at least 2-D.</source>
          <target state="translated">相当于m[:,::-1]。要求数组至少是二维的。</target>
        </trans-unit>
        <trans-unit id="1215aa39e41289b1c51c145e05d1743101aa9773" translate="yes" xml:space="preserve">
          <source>Equivalent to running:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a910d755d7e89acbf27b19fb05f069771ab0e7b" translate="yes" xml:space="preserve">
          <source>Equivalent to the Python &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">等效于Python &lt;code&gt;%&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="d371f28bfea1e852f448381bb4f0bdfccaa7149e" translate="yes" xml:space="preserve">
          <source>Equivalent to:</source>
          <target state="translated">相当于:</target>
        </trans-unit>
        <trans-unit id="f2c299359dd358c2f6f22a22ce8b45b901e994e8" translate="yes" xml:space="preserve">
          <source>Equivalently use the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;&lt;code&gt;mask&lt;/code&gt; attribute.</source>
          <target state="translated">等效地使用&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; &lt;code&gt;mask&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="6eed85d2c6463174f53200b994de55fedca2fe50" translate="yes" xml:space="preserve">
          <source>Equivalently use the &lt;code&gt;MaskedArray&lt;/code&gt;&lt;code&gt;data&lt;/code&gt; attribute.</source>
          <target state="translated">等效地使用 &lt;code&gt;MaskedArray&lt;/code&gt; &lt;code&gt;data&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="e59ba61683ec6d73dab0ba426c13a6a7d9ed31cf" translate="yes" xml:space="preserve">
          <source>Equivalently, eliminating the inner loop, the last two lines would be:</source>
          <target state="translated">同理,去掉内循环,最后两行就是。</target>
        </trans-unit>
        <trans-unit id="6b59734e1b8f67d36df303549c4673ff4f6c8d66" translate="yes" xml:space="preserve">
          <source>Equivalently, eliminating the inner loop, this can be expressed as:</source>
          <target state="translated">等价地,消除内循环,可以表示为:。</target>
        </trans-unit>
        <trans-unit id="28b75128748a47d2bb367541f76250db5dd9b6a0" translate="yes" xml:space="preserve">
          <source>Equivalently:</source>
          <target state="translated">Equivalently:</target>
        </trans-unit>
        <trans-unit id="149658b77c9d6e6cef1bb293ac32b781ccfe7dbd" translate="yes" xml:space="preserve">
          <source>Eric Wieser</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">错误处理</target>
        </trans-unit>
        <trans-unit id="5f577c8bef8739558c43df8e8796bc8e5a825a61" translate="yes" xml:space="preserve">
          <source>Error objects</source>
          <target state="translated">错误对象</target>
        </trans-unit>
        <trans-unit id="f13df400826d5582075c86f7280e918d94d2f9f5" translate="yes" xml:space="preserve">
          <source>Error type changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4884820cd63fe6870fd18f5bb40f96cacf7c1253" translate="yes" xml:space="preserve">
          <source>Errors result if the second argument is also supplied when x is a scalar input, if first and second arguments have different shapes, or if the first argument has complex values</source>
          <target state="translated">当x是标量输入时,如果第二个参数也被提供,如果第一个和第二个参数的形状不同,或者第一个参数的值很复杂,都会产生错误。</target>
        </trans-unit>
        <trans-unit id="68e944c31c80a964e18589df952c8e941c618fb2" translate="yes" xml:space="preserve">
          <source>Errors result if the second argument is also supplied when x is a scalar input, if first and second arguments have different shapes, or if the first argument has complex values.</source>
          <target state="translated">如果当x是标量输入时也提供了第二个参数,如果第一个和第二个参数的形状不同,或者第一个参数的值很复杂,就会产生错误。</target>
        </trans-unit>
        <trans-unit id="6896dc5d66baa055255d6a61e0f3010c1fcb944f" translate="yes" xml:space="preserve">
          <source>Errors result if the second argument is supplied when the first argument is a scalar, or if the first and second arguments have different shapes.</source>
          <target state="translated">如果第一个参数是标量,而第二个参数是标量,或者第一个和第二个参数的形状不同,就会产生错误。</target>
        </trans-unit>
        <trans-unit id="e6308f5d5324d30901fdba46e76a6baf1ab30827" translate="yes" xml:space="preserve">
          <source>Establish a timeline for mediation to complete, ideally within two weeks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5c90765bd01e407f47b56e1714c9f9bd1ace4b" translate="yes" xml:space="preserve">
          <source>Estimate a covariance matrix, given data and weights.</source>
          <target state="translated">给定数据和权重,估计一个协方差矩阵。</target>
        </trans-unit>
        <trans-unit id="3ff0c8c72ff670edbc5bdbae93aa2dbd2e54c4c0" translate="yes" xml:space="preserve">
          <source>Estimate the covariance matrix.</source>
          <target state="translated">估计协方差矩阵。</target>
        </trans-unit>
        <trans-unit id="2e86acb34f53f4c550f3dcf28b42823f0f59d900" translate="yes" xml:space="preserve">
          <source>Estimator based on leave-one-out cross-validation estimate of the integrated squared error. Can be regarded as a generalization of Scott&amp;rsquo;s rule.</source>
          <target state="translated">基于积分平方误差的留一法交叉验证估计的估计器。可以看作是斯科特规则的概括。</target>
        </trans-unit>
        <trans-unit id="35592e888d12a9934594d9f1f111830a7b9f7f37" translate="yes" xml:space="preserve">
          <source>Estimator does not take variability into account, only data size. Commonly overestimates number of bins required.</source>
          <target state="translated">估计器不考虑变异性,只考虑数据大小。通常高估了所需的料箱数量。</target>
        </trans-unit>
        <trans-unit id="da87f1093e8c246b1f6d85fea3650000b6da3790" translate="yes" xml:space="preserve">
          <source>Euler&amp;rsquo;s constant, base of natural logarithms, Napier&amp;rsquo;s constant.</source>
          <target state="translated">欧拉常数，自然对数的底数，纳皮尔常数。</target>
        </trans-unit>
        <trans-unit id="f91dd3dbbfae685abb68bc410da02d957a011629" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Chebyshev series at points (x, y).</source>
          <target state="translated">评估点(x,y)的二维切比雪夫数列。</target>
        </trans-unit>
        <trans-unit id="e05e0d192839700194b0291808ce8475fe0d0cc1" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.</source>
          <target state="translated">评估一个关于x和y的笛卡尔乘积的二维切比雪夫数列。</target>
        </trans-unit>
        <trans-unit id="7249c2fe23f2e17738db2110e9c2474dc3a27187" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Hermite series at points (x, y).</source>
          <target state="translated">评价在点(x,y)处的二维赫米特数列。</target>
        </trans-unit>
        <trans-unit id="12ed956c99b6390def2dd7ee918ef9474cc02f06" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Hermite series on the Cartesian product of x and y.</source>
          <target state="translated">评估一个关于x和y的笛卡尔积的二维赫米特数列。</target>
        </trans-unit>
        <trans-unit id="cedce799e74482d1942c64f4cd11a5b3fd98c128" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D HermiteE series at points (x, y).</source>
          <target state="translated">评价点(x,y)的二维HermiteE系列。</target>
        </trans-unit>
        <trans-unit id="48cc948294af1d7f259543794e3f125d854efce7" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D HermiteE series on the Cartesian product of x and y.</source>
          <target state="translated">评价x和y的笛卡尔积上的二维HermiteE数列。</target>
        </trans-unit>
        <trans-unit id="338d5b747397dce60dd29055f57344efa1d37666" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Laguerre series at points (x, y).</source>
          <target state="translated">评价在点(x,y)处的二维拉格列。</target>
        </trans-unit>
        <trans-unit id="4a829f126487a9ec9a923ab666b31db182581736" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Laguerre series on the Cartesian product of x and y.</source>
          <target state="translated">评估一个关于x和y的笛卡尔乘积的二维拉格尔数列。</target>
        </trans-unit>
        <trans-unit id="bb447e6da0b73bad544e19cbcbc6052261416eb9" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Legendre series at points (x, y).</source>
          <target state="translated">评估在点(x,y)处的二维Legendre序列。</target>
        </trans-unit>
        <trans-unit id="7373a9e22eb3236ef35b254cc0cb7ed7d29c6948" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Legendre series on the Cartesian product of x and y.</source>
          <target state="translated">评估关于x和y的笛卡尔积的二维Legendre数列。</target>
        </trans-unit>
        <trans-unit id="a527503bfcf8c4cb30f6f6943d6775ba7732cdef" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D polynomial at points (x, y).</source>
          <target state="translated">在点(x,y)处评价一个二维多项式。</target>
        </trans-unit>
        <trans-unit id="03726da2d6f02abab8a254ba40a2a300ecaef683" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D polynomial on the Cartesian product of x and y.</source>
          <target state="translated">评估一个关于x和y的笛卡尔乘积的二维多项式。</target>
        </trans-unit>
        <trans-unit id="9029d2c825f46990756a36847b1a1b6ef93e7f31" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Chebyshev series at points (x, y, z).</source>
          <target state="translated">评估在点(x,y,z)处的三维切比雪夫数列。</target>
        </trans-unit>
        <trans-unit id="6e0bda3c65d8c3458e685987ef115c2f03e1ce48" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.</source>
          <target state="translated">评估关于x、y和z的笛卡尔乘积的3-D切比雪夫数列。</target>
        </trans-unit>
        <trans-unit id="ae23b9ad402238d53a7767ef4d1d0feecad8d46a" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Hermite series at points (x, y, z).</source>
          <target state="translated">评估在点(x,y,z)处的三维赫米特数列。</target>
        </trans-unit>
        <trans-unit id="1fa86ea2fa2a78cb282ebd3e58571d4035e81572" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Hermite series on the Cartesian product of x, y, and z.</source>
          <target state="translated">评估一个关于x,y,z的笛卡尔乘积的3-D赫米特数列。</target>
        </trans-unit>
        <trans-unit id="e0e36a6aa699aa19c71e1fd7089481c08a161992" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.</source>
          <target state="translated">评价x,y,z的笛卡尔乘积上的3-D HermiteE数列。</target>
        </trans-unit>
        <trans-unit id="645e8b8ce98d2275a7fb6f40acce5d53b7f2ad81" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Hermite_e series at points (x, y, z).</source>
          <target state="translated">评价点(x,y,z)处的三维Hermite_e数列。</target>
        </trans-unit>
        <trans-unit id="ea580f96650cb24e9fc6eb589c30aba361084e3d" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Laguerre series at points (x, y, z).</source>
          <target state="translated">评估在点(x,y,z)处的3-D拉格尔系列。</target>
        </trans-unit>
        <trans-unit id="345ed8afbed95aea3201f6d8df2e9d955fe4ee9d" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.</source>
          <target state="translated">评估关于x、y、z的笛卡尔乘积的3-D拉格尔数列。</target>
        </trans-unit>
        <trans-unit id="fc1af478b3c58299201cb5fd893a359ec10739ca" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Legendre series at points (x, y, z).</source>
          <target state="translated">评估点(x,y,z)处的三维Legendre序列。</target>
        </trans-unit>
        <trans-unit id="888774bb82f3f8de5edab168d25dbd0a2eb3d033" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.</source>
          <target state="translated">评估一个关于x、y、z的笛卡尔乘积的3-D Legendre数列。</target>
        </trans-unit>
        <trans-unit id="e8846df08e194f124fe8cded1c782376715e8f39" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D polynomial at points (x, y, z).</source>
          <target state="translated">在点(x,y,z)处评价一个三维多项式。</target>
        </trans-unit>
        <trans-unit id="33f78fc3c5ae1454f9df0431d3f3fda38023ac26" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D polynomial on the Cartesian product of x, y and z.</source>
          <target state="translated">评估一个关于x,y和z的笛卡尔乘积的三维多项式。</target>
        </trans-unit>
        <trans-unit id="8b4e7acfc43ebffbd9c6285f10ac1b60b175795c" translate="yes" xml:space="preserve">
          <source>Evaluate a Chebyshev series at points x.</source>
          <target state="translated">评价x点处的切比雪夫数列。</target>
        </trans-unit>
        <trans-unit id="1f4ce01843c1515b967b600cb8fa4018d3436eaa" translate="yes" xml:space="preserve">
          <source>Evaluate a Laguerre series at points x.</source>
          <target state="translated">评价x点处的拉格尔系列。</target>
        </trans-unit>
        <trans-unit id="161f6a7aae0d5d7f196e5ee0e04ba73d7963b76b" translate="yes" xml:space="preserve">
          <source>Evaluate a Legendre series at points x.</source>
          <target state="translated">评价x点处的Legendre数列。</target>
        </trans-unit>
        <trans-unit id="1cc49d22e70eea61f6bdc96018100e105aba00e0" translate="yes" xml:space="preserve">
          <source>Evaluate a piecewise-defined function.</source>
          <target state="translated">评价一个片断定义的函数。</target>
        </trans-unit>
        <trans-unit id="79a283e785c7b9ab6cbfe6dbfe59b713502d0afb" translate="yes" xml:space="preserve">
          <source>Evaluate a polynomial at points x.</source>
          <target state="translated">在点x处评价一个多项式。</target>
        </trans-unit>
        <trans-unit id="ac86c84a106ffc30d8eceed0ff68761b61ebad9a" translate="yes" xml:space="preserve">
          <source>Evaluate a polynomial at specific values.</source>
          <target state="translated">在特定的数值下,评价一个多项式。</target>
        </trans-unit>
        <trans-unit id="283714fe4f49f84ab071c16c98a04aac5c0eb13d" translate="yes" xml:space="preserve">
          <source>Evaluate a polynomial specified by its roots at points x.</source>
          <target state="translated">评估由其根在点x处指定的多项式。</target>
        </trans-unit>
        <trans-unit id="5ae76cb25d3ddcb8fd7f5add4137cfe2c33287a6" translate="yes" xml:space="preserve">
          <source>Evaluate an Hermite series at points x.</source>
          <target state="translated">评价在点x处的赫米特数列。</target>
        </trans-unit>
        <trans-unit id="ce1ba49b7053d6908dd1d4b7a38524a5c4ffc2df" translate="yes" xml:space="preserve">
          <source>Evaluate an HermiteE series at points x.</source>
          <target state="translated">在点x处评价一个HermiteE系列。</target>
        </trans-unit>
        <trans-unit id="a389fe7d0ca7745a323c209ce5b023a9e30716fa" translate="yes" xml:space="preserve">
          <source>Evaluate the polynomial at</source>
          <target state="translated">评价多项式在</target>
        </trans-unit>
        <trans-unit id="201867eba810e127d20356b4920cc833601a5f27" translate="yes" xml:space="preserve">
          <source>Evaluates TRUE as long as the iterator has not looped through all of the elements, otherwise it evaluates FALSE.</source>
          <target state="translated">只要迭代器没有循环过所有的元素,就执行TRUE,否则执行FALSE。</target>
        </trans-unit>
        <trans-unit id="a61e7944eeb541b39ec48ef4572671aa9245dfe1" translate="yes" xml:space="preserve">
          <source>Evaluates TRUE as long as the multi-iterator has not looped through all of the elements (of the broadcasted result), otherwise it evaluates FALSE.</source>
          <target state="translated">只要多迭代器没有循环过所有的元素(广播结果),就执行TRUE,否则执行FALSE。</target>
        </trans-unit>
        <trans-unit id="22e5fc7652637561dc1ca3671ce7888c08020803" translate="yes" xml:space="preserve">
          <source>Evaluates a Chebyshev series.</source>
          <target state="translated">评价一个切比雪夫系列。</target>
        </trans-unit>
        <trans-unit id="8f5b426162065bbed8197ac088255c41cba4b070" translate="yes" xml:space="preserve">
          <source>Evaluates a Hermite series.</source>
          <target state="translated">评价一个赫米特系列。</target>
        </trans-unit>
        <trans-unit id="df7f15c01da2df8b851fc9f6e1e067fbbad7da62" translate="yes" xml:space="preserve">
          <source>Evaluates a Laguerre series.</source>
          <target state="translated">评估一个Laguerre系列。</target>
        </trans-unit>
        <trans-unit id="24200a16cfb4d36b211f0c64c8db3868f1aa7d7b" translate="yes" xml:space="preserve">
          <source>Evaluates a Legendre series.</source>
          <target state="translated">评价一个Legendre系列。</target>
        </trans-unit>
        <trans-unit id="85ee46dc575694a88add8fcac6da5ac9ea0ec2c1" translate="yes" xml:space="preserve">
          <source>Evaluates a polynomial.</source>
          <target state="translated">评价一个多项式。</target>
        </trans-unit>
        <trans-unit id="c6780dad55d1f852632365f7570aa643328d5b06" translate="yes" xml:space="preserve">
          <source>Evaluates as True if arrays &lt;em&gt;a1&lt;/em&gt; and &lt;em&gt;a2&lt;/em&gt; have the same shape.</source>
          <target state="translated">如果数组&lt;em&gt;a1&lt;/em&gt;和&lt;em&gt;a2&lt;/em&gt;具有相同的形状，则计算为True 。</target>
        </trans-unit>
        <trans-unit id="14b73bad8268092556c3d59c6262a1db866e29f2" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;code&gt;a&lt;/code&gt; is FORTRAN ordered.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是FORTRAN排序的，则评估为true 。</target>
        </trans-unit>
        <trans-unit id="74face1b8e76f520379a33453af827275b42370d" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;code&gt;a&lt;/code&gt; is a contiguous array. Equivalent to &lt;code&gt;(PyArray_ISCONTIGUOUS(a))&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是连续数组，则评估为true 。等效于 &lt;code&gt;(PyArray_ISCONTIGUOUS(a))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a92de714017736a8a012563cdae53ed5c18d733" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;code&gt;a&lt;/code&gt; is non-&lt;code&gt;NULL&lt;/code&gt; and can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 为非 &lt;code&gt;NULL&lt;/code&gt; 且可以转换为 &lt;code&gt;PyArrayObject*&lt;/code&gt; 则评估为true 。</target>
        </trans-unit>
        <trans-unit id="30b857f72fdd592a4e93e214be9f6a2a22f1daa5" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;em&gt;obj&lt;/em&gt; is a data-type object ( &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">如果&lt;em&gt;obj&lt;/em&gt;是数据类型的对象（&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr *&lt;/code&gt; &lt;/a&gt;），则评估为true 。</target>
        </trans-unit>
        <trans-unit id="1b0b459a4df746d063d9691e5dca8206407e50e5" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;em&gt;obj&lt;/em&gt; is a data-type object ( &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d60164442fc0f55a5557baa1dde2ec4ee3a192" translate="yes" xml:space="preserve">
          <source>Evaluates as true if the data buffer of &lt;code&gt;a&lt;/code&gt; uses native byte order. Equivalent to &lt;code&gt;(PyArray_ISNOTSWAPPED(a))&lt;/code&gt;.</source>
          <target state="translated">为真值，如果数据的缓冲区 &lt;code&gt;a&lt;/code&gt; 使用本地字节顺序。等效于 &lt;code&gt;(PyArray_ISNOTSWAPPED(a))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dcbfc3fc7cd5c92daad9c6700316991a65012cae" translate="yes" xml:space="preserve">
          <source>Evaluates pyfunc over input arrays using broadcasting rules of numpy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a80c85f7d09b073fbd515eb093798e576dcd94" translate="yes" xml:space="preserve">
          <source>Evaluates the Einstein summation convention on the operands.</source>
          <target state="translated">评估操作数的爱因斯坦求和约定。</target>
        </trans-unit>
        <trans-unit id="09f56994a692d463245ca900188d259358a1a1e3" translate="yes" xml:space="preserve">
          <source>Evaluates the lowest cost contraction order for an einsum expression by considering the creation of intermediate arrays.</source>
          <target state="translated">通过考虑中间数组的创建,评估einsum表达式的最低成本收缩顺序。</target>
        </trans-unit>
        <trans-unit id="a4fdb9cdb108616be69434eab1761cc78b88d33b" translate="yes" xml:space="preserve">
          <source>Evaluates to a pointer of type &lt;code&gt;void*&lt;/code&gt; that points to the data buffer of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">计算结果为类型的指针 &lt;code&gt;void*&lt;/code&gt; 该点到数据缓冲器的 &lt;code&gt;a&lt;/code&gt; ，假设 &lt;code&gt;a&lt;/code&gt; 可以转换为一个 &lt;code&gt;PyArrayObject*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b165cdcba7dabc88d6d0700bab2cea35959b8e6" translate="yes" xml:space="preserve">
          <source>Evaluates to an array of type &lt;code&gt;npy_intp&lt;/code&gt; and length &lt;code&gt;array_numdims(a)&lt;/code&gt;, giving the lengths of all of the dimensions of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">计算结果为类型的数组 &lt;code&gt;npy_intp&lt;/code&gt; 和长度 &lt;code&gt;array_numdims(a)&lt;/code&gt; 中，使所有的尺寸的长度 &lt;code&gt;a&lt;/code&gt; ，假设 &lt;code&gt;a&lt;/code&gt; 可以转换为一个 &lt;code&gt;PyArrayObject*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d18aba4418a76811df39bd817fcca0ecc3daf26" translate="yes" xml:space="preserve">
          <source>Evaluates to an array of type &lt;code&gt;npy_intp&lt;/code&gt; and length &lt;code&gt;array_numdims(a)&lt;/code&gt;, giving the stridess of all of the dimensions of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;. A stride is the distance in bytes between an element and its immediate neighbor along the same axis.</source>
          <target state="translated">计算结果为类型的数组 &lt;code&gt;npy_intp&lt;/code&gt; 和长度 &lt;code&gt;array_numdims(a)&lt;/code&gt; 中，使所有的尺寸的stridess &lt;code&gt;a&lt;/code&gt; ，假设 &lt;code&gt;a&lt;/code&gt; 可以转换为一个 &lt;code&gt;PyArrayObject*&lt;/code&gt; 。跨度是指元素与其相邻元素沿同一轴的距离（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="ee0a95426dfe5b7eb47ffd5ae2f4fb51edb35193" translate="yes" xml:space="preserve">
          <source>Evaluates to the &lt;code&gt;i&lt;/code&gt;-th dimension size of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">计算结果为 &lt;code&gt;i&lt;/code&gt; 的第尺寸大小 &lt;code&gt;a&lt;/code&gt; ，假定 &lt;code&gt;a&lt;/code&gt; 可以转换为一个 &lt;code&gt;PyArrayObject*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d4d289826f9e7f76dff23ce9b5a0d1ae92ad3cc" translate="yes" xml:space="preserve">
          <source>Evaluates to the &lt;code&gt;i&lt;/code&gt;-th stride of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">计算结果为 &lt;code&gt;i&lt;/code&gt; 的步幅第 &lt;code&gt;a&lt;/code&gt; ，假设 &lt;code&gt;a&lt;/code&gt; 可以转换为一个 &lt;code&gt;PyArrayObject*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32b35e339f75424281676b07ad9e28b079acb58f" translate="yes" xml:space="preserve">
          <source>Evaluates to the integer data type code of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">计算结果为的整数数据类型代码 &lt;code&gt;a&lt;/code&gt; ，假设 &lt;code&gt;a&lt;/code&gt; 可以转换为一个 &lt;code&gt;PyArrayObject*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60ab5981a7770a6202629fec1405f5cf8e6b68cf" translate="yes" xml:space="preserve">
          <source>Evaluates to the integer number of dimensions of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">计算结果为的维整数 &lt;code&gt;a&lt;/code&gt; ，假设 &lt;code&gt;a&lt;/code&gt; 可以转换为一个 &lt;code&gt;PyArrayObject*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0be0f4e7a59afdff5acbdbf74f20f94ceb3fdc16" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;arr&lt;/em&gt; is C-style contiguous.</source>
          <target state="translated">如果&lt;em&gt;arr&lt;/em&gt;是C样式连续的，则评估为true 。</target>
        </trans-unit>
        <trans-unit id="ccd3cb113f37e222d005c24c43bbeb4bb385e088" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous and &lt;em&gt;not&lt;/em&gt; C-style contiguous. &lt;a href=&quot;#c.PyArray_IS_F_CONTIGUOUS&quot;&gt;&lt;code&gt;PyArray_IS_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; is the correct way to test for Fortran-style contiguity.</source>
          <target state="translated">如果&lt;em&gt;arr&lt;/em&gt;是Fortran样式的连续而&lt;em&gt;不是&lt;/em&gt; C 样式的连续，则评估为true 。&lt;a href=&quot;#c.PyArray_IS_F_CONTIGUOUS&quot;&gt; &lt;code&gt;PyArray_IS_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;是测试Fortran样式连续性的正确方法。</target>
        </trans-unit>
        <trans-unit id="299ed12a95038cc7c47da499ceb2b1bb9bee7088" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous.</source>
          <target state="translated">如果&lt;em&gt;arr&lt;/em&gt;是Fortran样式的连续值，则评估为true 。</target>
        </trans-unit>
        <trans-unit id="0c6d7ddd3ec484ead393ec310ff7dd53898345cc" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python object whose type is a sub-type of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果&lt;em&gt;op&lt;/em&gt;是类型为&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;的子类型的Python对象，则计算true 。</target>
        </trans-unit>
        <trans-unit id="8d47b6abc57e8489e373d14442e0e135d79d490a" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python object whose type is a sub-type of &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda799e9981a95fbdf277bb7b4cac9dbe1897388" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python object with type &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果&lt;em&gt;op&lt;/em&gt;是类型为&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;的Python对象，则评估为true 。</target>
        </trans-unit>
        <trans-unit id="b99992949fa52eb31a616aa72ce3d2db9c377b8a" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python object with type &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eeb9c0e570ee6c3d7212996fe6c19be5c590a98" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python scalar object (see &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt;&lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt;&lt;/a&gt;), an array scalar (an instance of a sub-type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt;) or an instance of a sub-type of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; whose dimensionality is 0.</source>
          <target state="translated">如果&lt;em&gt;op&lt;/em&gt;是Python标量对象（请参阅&lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt; &lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt; &lt;/a&gt;），数组标量（ &lt;code&gt;PyGenericArr_Type&lt;/code&gt; 的子类型的实例）或维数为0 的&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;的子类型的实例，则计算true。</target>
        </trans-unit>
        <trans-unit id="77128428ecc736c262cee4d932684f9895a30acc" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python scalar object (see &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt;&lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt;&lt;/a&gt;), an array scalar (an instance of a sub-type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt;) or an instance of a sub-type of &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; whose dimensionality is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ae1d1c2d9114996b7543dee8f883c75689b0de" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a builtin Python scalar object (int, float, complex, bytes, str, long, bool).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="782aad878c58725282c24466a66a6d37025e0309" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a builtin Python scalar object (int, float, complex, str, unicode, long, bool).</source>
          <target state="translated">如果&lt;em&gt;op&lt;/em&gt;是内置的Python标量对象（int，float，complex，str，unicode，long，bool），则评估为true 。</target>
        </trans-unit>
        <trans-unit id="f7b432815e26220931657feceb0900b1d3b25457" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an array iterator (or instance of a subclass of the array iterator type).</source>
          <target state="translated">如果&lt;em&gt;op&lt;/em&gt;是数组迭代器（或数组迭代器类型的子类的实例），则为true 。</target>
        </trans-unit>
        <trans-unit id="72e9df6c71cba94b804e10a331ae768c03dc3136" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of (a subclass of) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and has 0 dimensions.</source>
          <target state="translated">如果&lt;em&gt;op&lt;/em&gt;是&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;（的子类）的实例并且具有0个维，则评估为true 。</target>
        </trans-unit>
        <trans-unit id="a92e36e0c44fee9b890a2256c6136f6838cd352e" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of (a subclass of) &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and has 0 dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5906e8dd00d0a1adb4ea6aa8b5091429c7f25bb2" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of &lt;code&gt;Py{cls}ArrType_Type&lt;/code&gt;.</source>
          <target state="translated">如果&lt;em&gt;op&lt;/em&gt;是 &lt;code&gt;Py{cls}ArrType_Type&lt;/code&gt; 的实例，则评估为true 。</target>
        </trans-unit>
        <trans-unit id="4fb6fa662c78b1650cad28ec8017fe594278de63" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of a builtin numeric type (int, float, complex, long, bool)</source>
          <target state="translated">如果&lt;em&gt;op&lt;/em&gt;是内置数字类型（int，float，complex，long，bool）的实例，则为true</target>
        </trans-unit>
        <trans-unit id="ab21393a2ba887799bdff9d28c50be01d0b70f5b" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is either a Python scalar object (see &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt;&lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt;&lt;/a&gt;) or an array scalar (an instance of a sub- type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ).</source>
          <target state="translated">如果&lt;em&gt;op&lt;/em&gt;是Python标量对象（请参见&lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt; &lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt; &lt;/a&gt;）或数组标量（ &lt;code&gt;PyGenericArr_Type&lt;/code&gt; 的子类型的实例），则为true。</target>
        </trans-unit>
        <trans-unit id="cf7b1413b57bbc99790ccf42c73ff86cedf1427a" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is either an array scalar (an instance of a sub-type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ), or an instance of (a sub-class of) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; whose dimensionality is 0.</source>
          <target state="translated">如果&lt;em&gt;op&lt;/em&gt;是数组标量（ &lt;code&gt;PyGenericArr_Type&lt;/code&gt; 的子类型的实例）或维数为0的&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;（的子类）的实例，则计算true 。</target>
        </trans-unit>
        <trans-unit id="5912b104b67fdb86cc53730cfe7f9447f1497a17" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is either an array scalar (an instance of a sub-type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ), or an instance of (a sub-class of) &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; whose dimensionality is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82908b45216f6f64aa572e8d9614febf36cdc646" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; can be written to</source>
          <target state="translated">如果可以将&lt;em&gt;arr&lt;/em&gt;的数据区域写入，则评估为true</target>
        </trans-unit>
        <trans-unit id="a6798bac58d14b80f66da409bb3101b7acf52c78" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; consists of a single (C-style or Fortran-style) contiguous segment.</source>
          <target state="translated">如果&lt;em&gt;arr&lt;/em&gt;的数据区域由单个（C样式或Fortran样式）连续段组成，则评估为true 。</target>
        </trans-unit>
        <trans-unit id="52d051a4856042792e3562a8cf85f0b04c4a4af1" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is C-style contiguous, aligned, and in machine byte-order.</source>
          <target state="translated">如果&lt;em&gt;arr&lt;/em&gt;的数据区域是C样式连续的，对齐的并且以机器字节顺序排列，则为true 。</target>
        </trans-unit>
        <trans-unit id="e202a99f33c9bfd2e1c5ac0fa0b8a81399b57105" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is C-style contiguous, and &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt;&lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;arr&lt;/em&gt;) is true.</source>
          <target state="translated">如果&lt;em&gt;arr&lt;/em&gt;的数据区域为C样式连续且&lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt; &lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;arr&lt;/em&gt;）为true ，则评估为true。</target>
        </trans-unit>
        <trans-unit id="effc549b6cbff87555006675e1c79c18e43a5365" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous and &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt;&lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;arr&lt;/em&gt;) is true.</source>
          <target state="translated">如果&lt;em&gt;arr&lt;/em&gt;的数据区域是Fortran风格的连续且&lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt; &lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;arr&lt;/em&gt;）为true ，则评估为true。</target>
        </trans-unit>
        <trans-unit id="8df904ca22ec2803d50d17cdbf121eedc6d72400" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous, aligned, and in machine byte-order &lt;strong&gt;.&lt;/strong&gt;</source>
          <target state="translated">如果&lt;em&gt;arr&lt;/em&gt;的数据区域为Fortran样式的连续，对齐并以机器字节顺序排列，则评估为true &lt;strong&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a1b64683aef87f7f1b4257764cf4227296d827e" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is aligned and in machine byte-order.</source>
          <target state="translated">如果&lt;em&gt;arr&lt;/em&gt;的数据区域已对齐并且以机器字节顺序排列，则为true 。</target>
        </trans-unit>
        <trans-unit id="f7f20e7e1e5772639b1f7c4eb4bff4d2800f8c2a" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is aligned and writeable and in machine byte-order according to its descriptor.</source>
          <target state="translated">如果&lt;em&gt;arr&lt;/em&gt;的数据区域是对齐且可写入的，并且根据其描述符以机器字节顺序进行计算，则为true 。</target>
        </trans-unit>
        <trans-unit id="e474d3b13b1be737b699dd99e94b826acd4340ff" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is properly aligned on the machine.</source>
          <target state="translated">如果&lt;em&gt;arr&lt;/em&gt;的数据区域在计算机上正确对齐，则评估为true 。</target>
        </trans-unit>
        <trans-unit id="2fa74bf1ebb6946b1363906270140aeda279cf9f" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of the ndarray &lt;em&gt;m&lt;/em&gt; is &lt;strong&gt;not&lt;/strong&gt; in machine byte-order according to the array&amp;rsquo;s data-type descriptor.</source>
          <target state="translated">如果的ndarray数据区域判断为真&lt;em&gt;米&lt;/em&gt;是&lt;strong&gt;不&lt;/strong&gt;根据阵列的数据类型的描述符在机器字节顺序。</target>
        </trans-unit>
        <trans-unit id="3267c071decd2c90623cf8528c8e4938c54505e6" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of the ndarray &lt;em&gt;m&lt;/em&gt; is in machine byte-order according to the array&amp;rsquo;s data-type descriptor.</source>
          <target state="translated">如果ndarray &lt;em&gt;m&lt;/em&gt;的数据区根据数组的数据类型描述符按机器字节顺序计算，则为true 。</target>
        </trans-unit>
        <trans-unit id="74157d4f0e365e7c26ee7ae56617ac39f0fc6cb5" translate="yes" xml:space="preserve">
          <source>Evaluation:</source>
          <target state="translated">Evaluation:</target>
        </trans-unit>
        <trans-unit id="bfed403a77ac8bf381d674a3abfc57ba60883a8b" translate="yes" xml:space="preserve">
          <source>Even for contiguous arrays a stride for a given dimension &lt;code&gt;arr.strides[dim]&lt;/code&gt; may be &lt;em&gt;arbitrary&lt;/em&gt; if &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; or the array has no elements. It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true.</source>
          <target state="translated">即使对于连续的数组，如果 &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; 或数组中没有元素，则给定维度 &lt;code&gt;arr.strides[dim]&lt;/code&gt; 的跨度也可以是&lt;em&gt;任意的&lt;/em&gt;。它并&lt;em&gt;没有&lt;/em&gt;普遍认为， &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; 为C语言风格的连续阵列或 &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; Fortran的风格的连续阵列是真实的。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1298a53951ccd9aa53bf4ad3ab74e5154ee53b89" translate="yes" xml:space="preserve">
          <source>Even for contiguous arrays a stride for a given dimension &lt;code&gt;arr.strides[dim]&lt;/code&gt; may be &lt;em&gt;arbitrary&lt;/em&gt; if &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; or the array has no elements. It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true. The correct way to access the &lt;code&gt;itemsize&lt;/code&gt; of an array from the C API is &lt;code&gt;PyArray_ITEMSIZE(arr)&lt;/code&gt;.</source>
          <target state="translated">即使对于连续的数组，如果 &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; 或数组中没有元素，则给定维度 &lt;code&gt;arr.strides[dim]&lt;/code&gt; 的跨度也可以是&lt;em&gt;任意的&lt;/em&gt;。它并&lt;em&gt;没有&lt;/em&gt;普遍认为， &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; 为C语言风格的连续阵列或 &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; Fortran的风格的连续阵列是真实的。从C API 访问数组的项目 &lt;code&gt;itemsize&lt;/code&gt; 的正确方法是 &lt;code&gt;PyArray_ITEMSIZE(arr)&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f9827d8888420fb8aa22f4344271feb523136ca5" translate="yes" xml:space="preserve">
          <source>Even though 0 occurs twice in the list of indices, the 0th element is only incremented once. This is because Python requires &amp;ldquo;a+=1&amp;rdquo; to be equivalent to &amp;ldquo;a = a + 1&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92024a025e8d5da08f38acb277e2e10c54a8e1a" translate="yes" xml:space="preserve">
          <source>Even though the image is not as sharp, using a small number of &lt;code&gt;k&lt;/code&gt; singular values (compared to the original set of 768 values), we can recover many of the distinguishing features from this image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17cc6a8778f1a9a25e4a2f86caa32ef74f1e599" translate="yes" xml:space="preserve">
          <source>Even when the input array is two-dimensional:</source>
          <target state="translated">即使输入数组是二维的。</target>
        </trans-unit>
        <trans-unit id="42a0931fb2d7f42f3ac87c5b18547abf5d77fe06" translate="yes" xml:space="preserve">
          <source>Evenly round to the given number of decimals.</source>
          <target state="translated">平均四舍五入到给定的小数。</target>
        </trans-unit>
        <trans-unit id="a19e0ffd5cc3d9a3df8ad933c77e6bea9dd169fb" translate="yes" xml:space="preserve">
          <source>Evenly spaced numbers with careful handling of endpoints.</source>
          <target state="translated">均匀的数字间距,小心翼翼的处理端点。</target>
        </trans-unit>
        <trans-unit id="1b950907a8c83b7ddb21092298e5404983c4a665" translate="yes" xml:space="preserve">
          <source>Eventually, expect to &lt;code&gt;__array_function__&lt;/code&gt; to always be enabled.</source>
          <target state="translated">最终，希望始终启用 &lt;code&gt;__array_function__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="581f2179fc03c06bcc3dcff4b3f8f2a107464b3a" translate="yes" xml:space="preserve">
          <source>Every Python module, extension module, or subpackage in the SciPy package directory should have a corresponding &lt;code&gt;test_&amp;lt;name&amp;gt;.py&lt;/code&gt; file. Pytest examines these files for test methods (named test*) and test classes (named Test*).</source>
          <target state="translated">SciPy软件包目录中的每个Python模块，扩展模块或子软件包均应具有相应的 &lt;code&gt;test_&amp;lt;name&amp;gt;.py&lt;/code&gt; 文件。Pytest检查这些文件中的测试方法（名为test *）和测试类（名为Test *）。</target>
        </trans-unit>
        <trans-unit id="8b7039d02f9e55e5e4b1540b84794daa8aa48877" translate="yes" xml:space="preserve">
          <source>Every module should have a docstring at the very top of the file. The module&amp;rsquo;s docstring may extend over multiple lines. If your docstring does extend over multiple lines, the closing three quotation marks must be on a line by itself, preferably preceded by a blank line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae734cbfb45b3c7fcea4a1b93bd51caeedc12aa" translate="yes" xml:space="preserve">
          <source>Every ufunc calculation involves some overhead related to setting up the calculation. The practical significance of this overhead is that even though the actual calculation of the ufunc is very fast, you will be able to write array and type-specific code that will work faster for small arrays than the ufunc. In particular, using ufuncs to perform many calculations on 0-D arrays will be slower than other Python-based solutions (the silently-imported scalarmath module exists precisely to give array scalars the look-and-feel of ufunc based calculations with significantly reduced overhead).</source>
          <target state="translated">每一个ufunc计算都涉及到一些与设置计算相关的开销。这个开销的实际意义在于,即使ufunc的实际计算速度非常快,你也能写出针对数组和类型的代码,这些代码对于小数组的工作速度会比ufunc快。特别是,使用ufuncs在0-D数组上进行许多计算,会比其他基于Python的解决方案慢(默默导入的scalarmath模块的存在,正是为了让数组标量具有基于ufunc计算的外观和感觉,同时大大降低开销)。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30643b2e1a03cdc521bd995bce3101935a638007" translate="yes" xml:space="preserve">
          <source>Example 1: Matrix creation from a string</source>
          <target state="translated">例子1:从一个字符串创建矩阵</target>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3d11c2b2ea882cbd46aab60dee035848945f1a" translate="yes" xml:space="preserve">
          <source>Example 2: Matrix creation from nested sequence</source>
          <target state="translated">例2:从嵌套序列创建矩阵</target>
        </trans-unit>
        <trans-unit id="fbf4dab701189a344fa5ab06d7b87c11a74e3da0" translate="yes" xml:space="preserve">
          <source>Example 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a618a4143ae0244c26c66d93ae5ab076865eca3" translate="yes" xml:space="preserve">
          <source>Example 3: Matrix creation from an array</source>
          <target state="translated">例3:从数组创建矩阵</target>
        </trans-unit>
        <trans-unit id="f4cd3ef194759e6a1bf205a2958b720d8edb10da" translate="yes" xml:space="preserve">
          <source>Example 4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc410822099cff77c866f8b10c2e48ca12a1afc" translate="yes" xml:space="preserve">
          <source>Example Non-ufunc extension</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f8c7c900cba2f392e5e38662fe498a8f56646a" translate="yes" xml:space="preserve">
          <source>Example NumPy ufunc for one dtype</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8809483f5fc6a5c010269d8adf002c5725f0e9b" translate="yes" xml:space="preserve">
          <source>Example NumPy ufunc with multiple arguments/return values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ef9bf28d21feb518a571e273d9e8fce03143d5" translate="yes" xml:space="preserve">
          <source>Example NumPy ufunc with multiple dtypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14395f9293b35a0e404c1a51a85116a67b48bdc5" translate="yes" xml:space="preserve">
          <source>Example NumPy ufunc with structured array dtype arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8172515c31d6aac1029b5cb8f7b23a7b399484c" translate="yes" xml:space="preserve">
          <source>Example Rendered</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b501c037bbc988735c2c33076d9ac8bcdd035dcd" translate="yes" xml:space="preserve">
          <source>Example Source</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0d4f43d7d9bdb2a4af703ab58a4be1e4d7fae7" translate="yes" xml:space="preserve">
          <source>Example illustrating a common use of &lt;a href=&quot;#numpy.linalg.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;: solving of least squares problems</source>
          <target state="translated">举例说明&lt;a href=&quot;#numpy.linalg.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt;的常用用法：求解最小二乘问题</target>
        </trans-unit>
        <trans-unit id="63135172667b6a87b3380fb1464ecfa4e93bae96" translate="yes" xml:space="preserve">
          <source>Example npymath.ini modified for cross-compilation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b9b4c475cb57be9cefc272ad9e58398f1d4a72d" translate="yes" xml:space="preserve">
          <source>Example of ellipsis use:</source>
          <target state="translated">省略号的使用实例。</target>
        </trans-unit>
        <trans-unit id="663d5de84d17f73904544fdaa7818c43c339aab6" translate="yes" xml:space="preserve">
          <source>Example of the &lt;em&gt;axis&lt;/em&gt; argument</source>
          <target state="translated">&lt;em&gt;轴&lt;/em&gt;参数的示例</target>
        </trans-unit>
        <trans-unit id="441193d28defb7b45677223f2e8385cc1771ef57" translate="yes" xml:space="preserve">
          <source>Example showing broadcast of scalar_like argument:</source>
          <target state="translated">例子显示scalar_like参数的广播。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="5ac5a296d96aa3e1af1d332eed81649776f6a783" translate="yes" xml:space="preserve">
          <source>Examples include ctypes, SWIG and Cython (which wraps C and C++) and f2py (which wraps Fortran).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fdbf34a4034d36b34a713099fb629e7144865e3" translate="yes" xml:space="preserve">
          <source>Examples of formats that cannot be read directly but for which it is not hard to convert are those formats supported by libraries like PIL (able to read and write many image formats such as jpg, png, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4f2c02f27681846f10b4ebe60fe1c291af3908e" translate="yes" xml:space="preserve">
          <source>Examples of using Numba, Cython, CFFI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="f7651c4bad19b71b6cb07d324b05afde4b46e15c" translate="yes" xml:space="preserve">
          <source>Exceeded max_work.</source>
          <target state="translated">超过了最大工作量。</target>
        </trans-unit>
        <trans-unit id="b4a918f3b3ebec530b94769e489c47c784e700d0" translate="yes" xml:space="preserve">
          <source>Except for splitting from the right, &lt;a href=&quot;#numpy.char.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; behaves like &lt;a href=&quot;numpy.char.split#numpy.char.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">除了从右侧拆分外，&lt;a href=&quot;#numpy.char.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; 的&lt;/a&gt;行为类似于&lt;a href=&quot;numpy.char.split#numpy.char.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50cf8f9b1990e86989de06e0c8538067135c84c5" translate="yes" xml:space="preserve">
          <source>Except for the handling of missing data this function does the same as &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt;&lt;code&gt;numpy.corrcoef&lt;/code&gt;&lt;/a&gt;. For more details and examples, see &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt;&lt;code&gt;numpy.corrcoef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">除了处理丢失的数据外，此功能与&lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt; &lt;code&gt;numpy.corrcoef&lt;/code&gt; &lt;/a&gt;相同。有关更多详细信息和示例，请参见&lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt; &lt;code&gt;numpy.corrcoef&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fcfc562b386cd345086d419126e4274f3e7274f0" translate="yes" xml:space="preserve">
          <source>Except for the handling of missing data this function does the same as &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt;&lt;code&gt;numpy.cov&lt;/code&gt;&lt;/a&gt;. For more details and examples, see &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt;&lt;code&gt;numpy.cov&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">除了处理丢失的数据外，此功能与&lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt; &lt;code&gt;numpy.cov&lt;/code&gt; &lt;/a&gt;相同。有关更多详细信息和示例，请参见&lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt; &lt;code&gt;numpy.cov&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="596913a65e41737843ee5c2dbdb338f87062d44f" translate="yes" xml:space="preserve">
          <source>Exception: if &lt;code&gt;&amp;lt;modulename&amp;gt;&lt;/code&gt; contains a substring &lt;code&gt;__user__&lt;/code&gt;, then the corresponding &lt;code&gt;python module&lt;/code&gt; block describes the signatures of so-called call-back functions (see &lt;a href=&quot;python-usage#call-back-arguments&quot;&gt;Call-back arguments&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="356b80b4376a84cb81f1eaec6f12177c31c9684b" translate="yes" xml:space="preserve">
          <source>Excessive profanity. Please avoid swearwords; people differ greatly in their sensitivity to swearing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b4ae599e40c23f9e1e3a0e96ba44f45767d0e8" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;f2py&lt;/code&gt; without any options to get an up-to-date list of available options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e6ce501ea40e3a3a4030f941745cb2ec376d8c" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;func1d(a, *args)&lt;/code&gt; where &lt;code&gt;func1d&lt;/code&gt; operates on 1-D arrays and &lt;code&gt;a&lt;/code&gt; is a 1-D slice of &lt;code&gt;arr&lt;/code&gt; along &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">执行 &lt;code&gt;func1d(a, *args)&lt;/code&gt; ，其中 &lt;code&gt;func1d&lt;/code&gt; 对一维数组进行操作，而 &lt;code&gt;a&lt;/code&gt; 是沿 &lt;code&gt;axis&lt;/code&gt; 的一维 &lt;code&gt;arr&lt;/code&gt; 切片。</target>
        </trans-unit>
        <trans-unit id="cf7ed2655aaf6ca10ebe34c9fc51e6d32e46bc68" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;func1d(a, *args, **kwargs)&lt;/code&gt; where &lt;code&gt;func1d&lt;/code&gt; operates on 1-D arrays and &lt;code&gt;a&lt;/code&gt; is a 1-D slice of &lt;code&gt;arr&lt;/code&gt; along &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2cece8ace64c3475d26ff85f2c7434847f99f4d" translate="yes" xml:space="preserve">
          <source>Execute a command in a sub-process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd62d234a86ea4d63bc3019c94a352e75700653" translate="yes" xml:space="preserve">
          <source>Existing array to use for output. If not given, returns a default copy of a.</source>
          <target state="translated">用于输出的现有数组。如果没有给定,则返回a的默认副本。</target>
        </trans-unit>
        <trans-unit id="49efde5e22ecb6838665120a39ab53a2bd9e68ce" translate="yes" xml:space="preserve">
          <source>Existing arrays are not copied:</source>
          <target state="translated">现有的数组不会被复制。</target>
        </trans-unit>
        <trans-unit id="49afcf31d80f21e8d0b1602a5dec36d208fe71f8" translate="yes" xml:space="preserve">
          <source>Expand the shape of an array.</source>
          <target state="translated">展开一个数组的形状。</target>
        </trans-unit>
        <trans-unit id="ffcf950230f953a0aa6e82e09f28f2ca5a3b9124" translate="yes" xml:space="preserve">
          <source>Expectation of interval, must be &amp;gt;= 0. A sequence of expectation intervals must be broadcastable over the requested size.</source>
          <target state="translated">期望间隔必须大于等于0。期望间隔序列必须可以在请求的大小上广播。</target>
        </trans-unit>
        <trans-unit id="b78dbac20462df52109f148c03ffe8d871381643" translate="yes" xml:space="preserve">
          <source>Expected type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf1e24ddaed54869cdb52d8afc4913163a237789" translate="yes" xml:space="preserve">
          <source>Expects a 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, returns None if all values are masked.</source>
          <target state="translated">需要一维&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;，如果所有值都被屏蔽，则返回None。</target>
        </trans-unit>
        <trans-unit id="436d6ba04e28ca54111c317cd8c5730750821416" translate="yes" xml:space="preserve">
          <source>Experimental Windows 64 bits support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb6e6265dd9bdb6a18fab53ed1eab48ecc15430" translate="yes" xml:space="preserve">
          <source>Expired deprecations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308f613122797fe7bbf7289f6c7ded6a9a215476" translate="yes" xml:space="preserve">
          <source>Explained without fancy indexing, this is equivalent to the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">在不使用华丽索引的情况下进行解释，这等效于&lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt;的以下用法，该用法将 &lt;code&gt;ii&lt;/code&gt; ， &lt;code&gt;jj&lt;/code&gt; 和 &lt;code&gt;kk&lt;/code&gt; 中的每一个设置为索引元组：</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="70888d5de72e21e66f15d3b4da0b71ef035227ca" translate="yes" xml:space="preserve">
          <source>Explanation of &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1cbb49be518437de30818cb1c73f87724317b3" translate="yes" xml:space="preserve">
          <source>Explanation of anonymous return value of type &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e720a46ab84c7db649aa1af73527c035249fc0" translate="yes" xml:space="preserve">
          <source>Explanation of parameters passed to a generator&amp;rsquo;s &lt;code&gt;.send()&lt;/code&gt; method, formatted as for Parameters, above. Since, like for Yields and Returns, a single object is always passed to the method, this may describe either the single parameter, or positional arguments passed as a tuple. If a docstring includes Receives it must also include Yields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed24536543d63881e8b2573801bfcc470ea854c5" translate="yes" xml:space="preserve">
          <source>Explanation of return value named &lt;code&gt;describe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084a31a8f3e785c2c2a6e821453dbd829b121e68" translate="yes" xml:space="preserve">
          <source>Explanation of the returned values and their types. Similar to the &lt;strong&gt;Parameters&lt;/strong&gt; section, except the name of each return value is optional. The type of each return value is always required:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d6a974dcdac50109739458b5d455115ab1bc92d" translate="yes" xml:space="preserve">
          <source>Explanation of the yielded values and their types. This is relevant to generators only. Similar to the &lt;strong&gt;Returns&lt;/strong&gt; section in that the name of each value is optional, but the type of each value is always required:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9375f321c90af9af48e6e3fb9835073a5901dfe" translate="yes" xml:space="preserve">
          <source>Explanations</source>
          <target state="translated">Explanations</target>
        </trans-unit>
        <trans-unit id="83ab7f45afecc2791323d368cde7b157fa580ff5" translate="yes" xml:space="preserve">
          <source>Explicit constructor call - as in &lt;code&gt;MySubClass(params)&lt;/code&gt;. This is the usual route to Python instance creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7239478231860a1fad923ee0b23fbd1cf944cc01" translate="yes" xml:space="preserve">
          <source>Exploring your repository</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2a8ab3710ac4db36fc8b2f6b13aa845d130b020" translate="yes" xml:space="preserve">
          <source>Exponent of the smallest (most negative) power of &lt;code&gt;ibeta&lt;/code&gt; that, added to 1.0, gives something different from 1.0</source>
          <target state="translated">&lt;code&gt;ibeta&lt;/code&gt; 的最小（最负数）次幂的幂加到1.0，则得出的结果不同于1.0</target>
        </trans-unit>
        <trans-unit id="b6c379526da851c2c188007fc0f60f969489df7a" translate="yes" xml:space="preserve">
          <source>Exponent of the smallest power of &lt;code&gt;ibeta&lt;/code&gt; that, subtracted from 1.0, gives something different from 1.0.</source>
          <target state="translated">从1.0中减去 &lt;code&gt;ibeta&lt;/code&gt; 的最小幂的指数得到的值与1.0有所不同。</target>
        </trans-unit>
        <trans-unit id="4b6764a081f01f39974a118ba6996f7bb9dae570" translate="yes" xml:space="preserve">
          <source>Exponentials</source>
          <target state="translated">Exponentials</target>
        </trans-unit>
        <trans-unit id="3ce964226c06687afb0e1cd2608b915c6e2ae80f" translate="yes" xml:space="preserve">
          <source>Exponents and logarithms</source>
          <target state="translated">指数和对数</target>
        </trans-unit>
        <trans-unit id="6816711cea53eaf2821d868455dd2b74af82fbfc" translate="yes" xml:space="preserve">
          <source>Extended Precision</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c674d20d95b51b6a4e4dd52d4e269a50723636" translate="yes" xml:space="preserve">
          <source>Extended array wrapping mechanism for ufuncs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be9a4abd6d7c8083fc1a7bf9004e653250a9ba5" translate="yes" xml:space="preserve">
          <source>Extending</source>
          <target state="translated">Extending</target>
        </trans-unit>
        <trans-unit id="11f9e57877f87be0cc6660ad6431454b1ce0dd15" translate="yes" xml:space="preserve">
          <source>Extending numpy.random via Cython</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853464b537e82bc933ba7340602eb65117de87c5" translate="yes" xml:space="preserve">
          <source>Extending via CFFI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d370bc918c56f5c33646a1857c72f909913490c1" translate="yes" xml:space="preserve">
          <source>Extending via Numba</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800827a3cd2ee901ad8ec499c46ac0ff69445548" translate="yes" xml:space="preserve">
          <source>Extending via Numba and CFFI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8df212e6d243492be0344c26fa93a5ac0e105d8" translate="yes" xml:space="preserve">
          <source>Extends &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt; with several advanced options providing more control over broadcasting and buffering.</source>
          <target state="translated">使用几个高级选项扩展了&lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt;，从而提供了对广播和缓冲的更多控制。</target>
        </trans-unit>
        <trans-unit id="1071c16401775941686162869b5dcd9b3809f3d7" translate="yes" xml:space="preserve">
          <source>Extension (class in numpy.distutils.core)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e3302475f159bce563240760503f1c4aa91903" translate="yes" xml:space="preserve">
          <source>Extension modules that need to compile against NumPy should use this function to locate the appropriate include directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48f1027b2aaccf449a26fbdeefabcf146890c52" translate="yes" xml:space="preserve">
          <source>Extension modules were discussed in &lt;a href=&quot;c-info.how-to-extend#writing-an-extension&quot;&gt;Writing an extension module&lt;/a&gt;. The most basic way to interface with compiled code is to write an extension module and construct a module method that calls the compiled code. For improved readability, your method should take advantage of the &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; call to convert between Python objects and C data-types. For standard C data-types there is probably already a built-in converter. For others you may need to write your own converter and use the &lt;code&gt;&quot;O&amp;amp;&quot;&lt;/code&gt; format string which allows you to specify a function that will be used to perform the conversion from the Python object to whatever C-structures are needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c018e97c181cd9c183fd3a91a81ef0772a1542dd" translate="yes" xml:space="preserve">
          <source>Extension name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="656bcfe284e2da39c77d4fdab55b16ad3c654719" translate="yes" xml:space="preserve">
          <source>Extensions</source>
          <target state="translated">Extensions</target>
        </trans-unit>
        <trans-unit id="27a37d04136a1c128f059ba2a96a979d4da85562" translate="yes" xml:space="preserve">
          <source>External &lt;code&gt;nose&lt;/code&gt; plugins are usable by &lt;code&gt;numpy.testing.Tester&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730550afb5b9c93a998c435ea0c0d79790c3f92e" translate="yes" xml:space="preserve">
          <source>External Links:</source>
          <target state="translated">外部链接:</target>
        </trans-unit>
        <trans-unit id="ae23cb438f3e53ca3afef0a03ebcc1785000e0ee" translate="yes" xml:space="preserve">
          <source>External member: Thomas Caswell</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5695baec527125ed849fab25176346709bcdc26" translate="yes" xml:space="preserve">
          <source>Extra arguments to be used in the function call. Default is no extra arguments.</source>
          <target state="translated">在函数调用中使用的额外参数。默认值是没有额外参数。</target>
        </trans-unit>
        <trans-unit id="7f681966048a97639927ca7899e8b79125b2db1c" translate="yes" xml:space="preserve">
          <source>Extra command line arguments to pass to the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca14953b246ceea670453a567006ae580503bb4e" translate="yes" xml:space="preserve">
          <source>Extra command line arguments to pass to the fortran77 compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6295d4fda810b14243403cdc434ad1cb27dc0759" translate="yes" xml:space="preserve">
          <source>Extra command line arguments to pass to the fortran90 compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7475cdd2c7bf2da401a59201928f6e438e74c2c4" translate="yes" xml:space="preserve">
          <source>Extra data to be passed to the 1-d vector loops or &lt;code&gt;NULL&lt;/code&gt; if no extra-data is needed. This C-array must be the same size ( &lt;em&gt;i.e.&lt;/em&gt; ntypes) as the functions array. &lt;code&gt;NULL&lt;/code&gt; is used if extra_data is not needed. Several C-API calls for UFuncs are just 1-d vector loops that make use of this extra data to receive a pointer to the actual function to call.</source>
          <target state="translated">要传递到1-d向量循环的多余数据；如果不需要多余数据，则为 &lt;code&gt;NULL&lt;/code&gt; 。此C数组必须与函数数组具有相同的大小（&lt;em&gt;即&lt;/em&gt; ntypes）。如果不需要extra_data，则使用 &lt;code&gt;NULL&lt;/code&gt; 。几个UFunc的C-API调用只是1-d向量循环，这些循环利用这些额外的数据来接收指向要调用的实际函数的指针。</target>
        </trans-unit>
        <trans-unit id="76b524fa169ed9d7419720ac2e63f1800fb02fd6" translate="yes" xml:space="preserve">
          <source>Extra features in NumPy Distutils</source>
          <target state="translated">NumPy Distutils的额外功能。</target>
        </trans-unit>
        <trans-unit id="0ba9e867255fe2b4e1a52a57cb3c07e37658da6a" translate="yes" xml:space="preserve">
          <source>Extra gotchas - custom &lt;code&gt;__del__&lt;/code&gt; methods and ndarray.base</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b908b04be2629c5ae91c968b91dbf4fa38bfee" translate="yes" xml:space="preserve">
          <source>Extract a diagonal or construct a diagonal array.</source>
          <target state="translated">提取一个对角线或构造一个对角线阵列。</target>
        </trans-unit>
        <trans-unit id="8f2f355e8dba1681289d909a9095fc402d801e4a" translate="yes" xml:space="preserve">
          <source>Extract the diagonal (requires explicit form):</source>
          <target state="translated">提取对角线(需要明文形式)。</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="00b194f535090973445600575106dc4bd4b91c15" translate="yes" xml:space="preserve">
          <source>F &amp;amp; C order preserved, otherwise most similar order</source>
          <target state="translated">保留F＆C订单，否则最相似的订单</target>
        </trans-unit>
        <trans-unit id="3a82a1967b0685fff927bd0da5e7638582e5ea69" translate="yes" xml:space="preserve">
          <source>F order</source>
          <target state="translated">F订单</target>
        </trans-unit>
        <trans-unit id="c79b9dbc4a93112f31ab2f13620d941f25753284" translate="yes" xml:space="preserve">
          <source>F order if input is F and not C, otherwise C order</source>
          <target state="translated">如果输入是F而不是C,则为F命令,否则为C命令。</target>
        </trans-unit>
        <trans-unit id="f2a180292b361263e635ced3b9691c0e12c80c50" translate="yes" xml:space="preserve">
          <source>F2PY Users Guide and Reference Manual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b399d8776a2242967c58643767ca90dfddcac38" translate="yes" xml:space="preserve">
          <source>F2PY can be used either as a command line tool &lt;code&gt;f2py&lt;/code&gt; or as a Python module &lt;code&gt;numpy.f2py&lt;/code&gt;. While we try to install the command line tool as part of the numpy setup, some platforms like Windows make it difficult to reliably put the executable on the &lt;code&gt;PATH&lt;/code&gt;. We will refer to &lt;code&gt;f2py&lt;/code&gt; in this document but you may have to run it as a module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="792c6defec01dbafd2bb97ac5636c97cd76fd00b" translate="yes" xml:space="preserve">
          <source>F2PY compiles all sources and builds an extension module containing the wrappers. In building extension modules, F2PY uses &lt;code&gt;numpy_distutils&lt;/code&gt; that supports a number of Fortran 77/90/95 compilers, including Gnu, Intel, Sun Fortre, SGI MIPSpro, Absoft, NAG, Compaq etc. compilers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e93ef7e35d0de4b606056f7c05a7e7f8e0fa7b" translate="yes" xml:space="preserve">
          <source>F2PY directive has the following form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c802734ec43042e46fc429c3bbb7f9b7a790ab48" translate="yes" xml:space="preserve">
          <source>F2PY directives</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9c3fd91761103aa57848e2e22375fdb641f2ae9" translate="yes" xml:space="preserve">
          <source>F2PY generated interface is very flexible with respect to call-back arguments. For each call-back argument an additional optional argument &lt;code&gt;&amp;lt;name&amp;gt;_extra_args&lt;/code&gt; is introduced by F2PY. This argument can be used to pass extra arguments to user provided call-back arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f6bbe236422250760ea03e1afee2f05419e0cf" translate="yes" xml:space="preserve">
          <source>F2PY generated wrapper functions accept (almost) any Python object as a string argument, &lt;code&gt;str&lt;/code&gt; is applied for non-string objects. Exceptions are NumPy arrays that must have type code &lt;code&gt;'c'&lt;/code&gt; or &lt;code&gt;'1'&lt;/code&gt; when used as string arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ac895bc25eb576f465fead8da56c16856e681e" translate="yes" xml:space="preserve">
          <source>F2PY generates wrappers to &lt;code&gt;common&lt;/code&gt; blocks defined in a routine signature block. Common blocks are visible by all Fortran codes linked with the current extension module, but not to other extension modules (this restriction is due to how Python imports shared libraries). In Python, the F2PY wrappers to &lt;code&gt;common&lt;/code&gt; blocks are &lt;code&gt;fortran&lt;/code&gt; type objects that have (dynamic) attributes related to data members of common blocks. When accessed, these attributes return as NumPy array objects (multidimensional arrays are Fortran-contiguous) that directly link to data members in common blocks. Data members can be changed by direct assignment or by in-place changes to the corresponding array objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818e71d7199268e4ad0bb28a90c9ec7b67e6a73f" translate="yes" xml:space="preserve">
          <source>F2PY generates wrappers to all entry names using the signature of the routine block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d8d5f0414d9a23442dad9a8767153d6dc63973" translate="yes" xml:space="preserve">
          <source>F2PY has basic support for Fortran 90 module allocatable arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70ca3b53756dbec8defd4dadba9010e32a75e058" translate="yes" xml:space="preserve">
          <source>F2PY implements basic compatibility checks between related arguments in order to avoid any unexpected crashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d254f0a276a232e34acfb47e3326523f334f058d" translate="yes" xml:space="preserve">
          <source>F2PY may lower cases also in C expressions when scanning Fortran codes (see &lt;code&gt;--[no]-lower&lt;/code&gt; option).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec756cae82276f06410c3a4d2b35a06f369bcafa" translate="yes" xml:space="preserve">
          <source>F2PY provides &lt;code&gt;intent(inplace)&lt;/code&gt; attribute that would modify the attributes of an input array so that any changes made by Fortran routine will be effective also in input argument. For example, if one specifies &lt;code&gt;intent(inplace) a&lt;/code&gt; (see below, how), then the example above would read:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca2006682a608b9e1b2b53bb3bb49e7143a70f2" translate="yes" xml:space="preserve">
          <source>F2PY reads a signature file and writes a Python C/API module containing Fortran/C/Python bindings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d34cb52e571436cd929620cb006187918c3090" translate="yes" xml:space="preserve">
          <source>F2PY supports calling Python functions from Fortran or C codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a50f97135d3a00f9c97ae354c1ab19960a6943cf" translate="yes" xml:space="preserve">
          <source>F2Py Guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db0e0f2556443edbd8b7072d8289833837b00763" translate="yes" xml:space="preserve">
          <source>F2py allows you to automatically construct an extension module that interfaces to routines in Fortran 77/90/95 code. It has the ability to parse Fortran 77/90/95 code and automatically generate Python signatures for the subroutines it encounters, or you can guide how the subroutine interfaces with Python by constructing an interface-definition-file (or modifying the f2py-produced one).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8300dc1be4d8761c3816eeb71051b6b621dd6e" translate="yes" xml:space="preserve">
          <source>FFT</source>
          <target state="translated">FFT</target>
        </trans-unit>
        <trans-unit id="ca600c25350318c92a93eef893cdd109ac18c10d" translate="yes" xml:space="preserve">
          <source>FFT (Fast Fourier Transform) refers to a way the discrete Fourier Transform (DFT) can be calculated efficiently, by using symmetries in the calculated terms. The symmetry is highest when &lt;code&gt;n&lt;/code&gt; is a power of 2, and the transform is therefore most efficient for these sizes.</source>
          <target state="translated">FFT（快速傅立叶变换）是指通过在计算项中使用对称性可以有效地计算离散傅立叶变换（DFT）的方法。当 &lt;code&gt;n&lt;/code&gt; 为2的幂时，对称性最高，因此，对于这些大小，变换效率最高。</target>
        </trans-unit>
        <trans-unit id="1e904f6af52956913c4ff703c15d71d4683c8dd0" translate="yes" xml:space="preserve">
          <source>F_CONTIGUOUS / F / FORTRAN</source>
          <target state="translated">F_CONTIGUOUS/F/FORTRAN.</target>
        </trans-unit>
        <trans-unit id="10ba031202732234b30a39bc920cbaa6d821ef6b" translate="yes" xml:space="preserve">
          <source>F_CONTIGUOUS and not C_CONTIGUOUS.</source>
          <target state="translated">F_CONTIGUOUS而不是C_CONTIGUOUS。</target>
        </trans-unit>
        <trans-unit id="542219cc1d690d05adfbb2e51a8b3ccb1985fddc" translate="yes" xml:space="preserve">
          <source>F_CONTIGUOUS or C_CONTIGUOUS (one-segment test).</source>
          <target state="translated">F_CONTIGUOUS或C_CONTIGUOUS(单段测试)。</target>
        </trans-unit>
        <trans-unit id="85c6c271be69ba94867c22f54f57654f454c41b4" translate="yes" xml:space="preserve">
          <source>Factor the matrix &lt;code&gt;a&lt;/code&gt; as &lt;em&gt;qr&lt;/em&gt;, where &lt;code&gt;q&lt;/code&gt; is orthonormal and &lt;code&gt;r&lt;/code&gt; is upper-triangular.</source>
          <target state="translated">将矩阵 &lt;code&gt;a&lt;/code&gt; 分解为&lt;em&gt;qr&lt;/em&gt;，其中 &lt;code&gt;q&lt;/code&gt; 是正交的， &lt;code&gt;r&lt;/code&gt; 是上三角的。</target>
        </trans-unit>
        <trans-unit id="fb318cde14ee94b6e5d32ac7d527c0788644b0e1" translate="yes" xml:space="preserve">
          <source>Fail unless an exception of class exception_class and with message that matches expected_regexp is thrown by callable when invoked with arguments args and keyword arguments kwargs.</source>
          <target state="translated">失败,除非当调用参数args和关键字参数kwargs时,callable会抛出一个类exception_class的异常,并带有与expected_regexp匹配的消息。</target>
        </trans-unit>
        <trans-unit id="021d84299e2248496708e7d1e546ad6c2c18b0ba" translate="yes" xml:space="preserve">
          <source>Fail unless an exception of class exception_class is thrown by callable when invoked with arguments args and keyword arguments kwargs.</source>
          <target state="translated">失败,除非用参数args和关键字参数kwargs调用时,callable会抛出一个类exception_class的异常。</target>
        </trans-unit>
        <trans-unit id="88591071684d50acd16039be01f0c08d81ea457a" translate="yes" xml:space="preserve">
          <source>Fail unless an exception of class exception_class is thrown by callable when invoked with arguments args and keyword arguments kwargs. If a different type of exception is thrown, it will not be caught, and the test case will be deemed to have suffered an error, exactly as for an unexpected exception.</source>
          <target state="translated">失败,除非当调用 arguments args 和关键字 arguments kwargs 时,callable 抛出类 exception_class 的异常。如果抛出了不同类型的异常,则不会被捕获,测试用例将被视为发生了错误,这与意外异常完全相同。</target>
        </trans-unit>
        <trans-unit id="719788786f4bf9fa2ee26b39d5371d0a438935c3" translate="yes" xml:space="preserve">
          <source>Fail unless the given callable throws the specified warning.</source>
          <target state="translated">失败,除非给定的callable抛出指定的警告。</target>
        </trans-unit>
        <trans-unit id="552c13b4b3257ae89f519cb962e935c59da9aa88" translate="yes" xml:space="preserve">
          <source>Fanaticism consists of redoubling your efforts when you have forgotten your aim. &amp;mdash; &lt;em&gt;George Santayana&lt;/em&gt;</source>
          <target state="translated">狂热主义包括忘记目标时加倍努力。&amp;mdash; &lt;em&gt;乔治&amp;middot;桑塔亚娜&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c67baf5f0ace8714e24d83b916518b08cd541740" translate="yes" xml:space="preserve">
          <source>Fast element-wise operations, called a &lt;a href=&quot;#term-ufunc&quot;&gt;ufunc&lt;/a&gt;, operate on arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35d6e8cdee3fab38ad9c3056a80a39fdb1d90ea" translate="yes" xml:space="preserve">
          <source>Faster version of &lt;a href=&quot;#numpy.base_repr&quot;&gt;&lt;code&gt;base_repr&lt;/code&gt;&lt;/a&gt; for base 2.</source>
          <target state="translated">base 2 的&lt;a href=&quot;#numpy.base_repr&quot;&gt; &lt;code&gt;base_repr&lt;/code&gt; &lt;/a&gt;更快版本。</target>
        </trans-unit>
        <trans-unit id="450b0ab74bf6b08b6fed235cfac5fd255dd761eb" translate="yes" xml:space="preserve">
          <source>Fasttake and fastputmask slots are deprecated and NULL&amp;rsquo;ed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="cba8e75130f021ad02ee54a4acd20b3b023d217d" translate="yes" xml:space="preserve">
          <source>Fernando Perez&amp;rsquo; git page - &lt;a href=&quot;http://www.fperez.org/py4science/git.html&quot;&gt;Fernando&amp;rsquo;s git page&lt;/a&gt; - many links and tips</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c6f34280b7f890c09c370b6ae106bab782a8ea7" translate="yes" xml:space="preserve">
          <source>Field Access</source>
          <target state="translated">外地访问</target>
        </trans-unit>
        <trans-unit id="783edc3ed85699bf943ebb957a288a27bf6fa548" translate="yes" xml:space="preserve">
          <source>Field Titles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f20e66b17a6eb7c2baf1ab68337d91eaf6f4f80" translate="yes" xml:space="preserve">
          <source>Figure</source>
          <target state="translated">Figure</target>
        </trans-unit>
        <trans-unit id="6810ab68c484c234e459c4fd42ee6ddebf48e9df" translate="yes" xml:space="preserve">
          <source>File bug reports or feature requests, and make contributions (e.g. code patches), by opening a &amp;ldquo;new issue&amp;rdquo; on GitHub:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373ecfdf236324d2c0d2c0966daa4376bd84ecc7" translate="yes" xml:space="preserve">
          <source>File extensions</source>
          <target state="translated">文件扩展名</target>
        </trans-unit>
        <trans-unit id="d09479e812c08194a796ba5cf0534018f31d75df" translate="yes" xml:space="preserve">
          <source>File like object that the output is written to, default is &lt;code&gt;stdout&lt;/code&gt;. The object has to be opened in &amp;lsquo;w&amp;rsquo; or &amp;lsquo;a&amp;rsquo; mode.</source>
          <target state="translated">写入输出的对象之类的文件，默认为 &lt;code&gt;stdout&lt;/code&gt; 。必须以&amp;ldquo; w&amp;rdquo;或&amp;ldquo; a&amp;rdquo;模式打开对象。</target>
        </trans-unit>
        <trans-unit id="87eae4c8fed58e613f33763392061f9f060bfb3a" translate="yes" xml:space="preserve">
          <source>File mode.</source>
          <target state="translated">文件模式:</target>
        </trans-unit>
        <trans-unit id="fd757708817417e6d160c4d854e159b642dde015" translate="yes" xml:space="preserve">
          <source>File name or file object to read.</source>
          <target state="translated">文件名或要读取的文件对象。</target>
        </trans-unit>
        <trans-unit id="a9cb7966c21c4ba3f863696ad8ce671f4f627493" translate="yes" xml:space="preserve">
          <source>File object.</source>
          <target state="translated">文件对象。</target>
        </trans-unit>
        <trans-unit id="4a94520c92dda87c31025fbdcee94cc740835e3c" translate="yes" xml:space="preserve">
          <source>File on disk is unchanged:</source>
          <target state="translated">磁盘上的文件没有变化。</target>
        </trans-unit>
        <trans-unit id="0031f1b0b3ec78263f049edb5bf2d9bd62cb7daa" translate="yes" xml:space="preserve">
          <source>File or filename to which the data is saved. If file is a file-object, then the filename is unchanged. If file is a string or Path, a &lt;code&gt;.npy&lt;/code&gt; extension will be appended to the file name if it does not already have one.</source>
          <target state="translated">将数据保存到的文件或文件名。如果file是文件对象，则文件名不变。如果文件是字符串或路径，则 &lt;code&gt;.npy&lt;/code&gt; 扩展名将附加到文件名（如果尚无扩展名）。</target>
        </trans-unit>
        <trans-unit id="1eb6e34596962a0a844dec399c9d41368523ad02" translate="yes" xml:space="preserve">
          <source>File or filename to which the data is saved. If file is a file-object, then the filename is unchanged. If file is a string or Path, a &lt;code&gt;.npy&lt;/code&gt; extension will be appended to the filename if it does not already have one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e820f26629f1b163437a25da45907f2a0bdeef89" translate="yes" xml:space="preserve">
          <source>File, filename, list, or generator to read. If the filename extension is &lt;code&gt;gz&lt;/code&gt; or &lt;a href=&quot;https://docs.python.org/dev/library/bz2.html#module-bz2&quot;&gt;&lt;code&gt;bz2&lt;/code&gt;&lt;/a&gt;, the file is first decompressed. Note that generators must return byte strings in Python 3k. The strings in a list or produced by a generator are treated as lines.</source>
          <target state="translated">要读取的文件，文件名，列表或生成器。如果文件扩展名是 &lt;code&gt;gz&lt;/code&gt; 或&lt;a href=&quot;https://docs.python.org/dev/library/bz2.html#module-bz2&quot;&gt; &lt;code&gt;bz2&lt;/code&gt; &lt;/a&gt;，则首先将文件解压缩。请注意，生成器必须在Python 3k中返回字节字符串。列表中或由生成器生成的字符串被视为行。</target>
        </trans-unit>
        <trans-unit id="fab43e32c1dfae0973539d24c1436cb574228947" translate="yes" xml:space="preserve">
          <source>File, filename, list, or generator to read. If the filename extension is &lt;code&gt;gz&lt;/code&gt; or &lt;a href=&quot;https://docs.python.org/dev/library/bz2.html#module-bz2&quot;&gt;&lt;code&gt;bz2&lt;/code&gt;&lt;/a&gt;, the file is first decompressed. Note that generators must return byte strings. The strings in a list or produced by a generator are treated as lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="822b222e1d15e367e3952f91b983db03e9a7813a" translate="yes" xml:space="preserve">
          <source>File, filename, or generator to read. If the filename extension is &lt;code&gt;.gz&lt;/code&gt; or &lt;code&gt;.bz2&lt;/code&gt;, the file is first decompressed. Note that generators should return byte strings for Python 3k.</source>
          <target state="translated">要读取的文件，文件名或生成器。如果文件扩展名是 &lt;code&gt;.gz&lt;/code&gt; 或 &lt;code&gt;.bz2&lt;/code&gt; ，则首先将文件解压缩。请注意，生成器应返回Python 3k的字节字符串。</target>
        </trans-unit>
        <trans-unit id="7c2d62ffff5fbd690a9400522b7a8e17b68bb40c" translate="yes" xml:space="preserve">
          <source>File, filename, or generator to read. If the filename extension is &lt;code&gt;.gz&lt;/code&gt; or &lt;code&gt;.bz2&lt;/code&gt;, the file is first decompressed. Note that generators should return byte strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c13aad6dcb77e8786c02dc6c8f0cc3a100a87f10" translate="yes" xml:space="preserve">
          <source>File-like object to write the output to. If omitted, use a pager.</source>
          <target state="translated">要将输出写到类似文件的对象。如果省略,则使用寻呼机。</target>
        </trans-unit>
        <trans-unit id="3b5057522ae1af734e89a0b5dfbff160729789a2" translate="yes" xml:space="preserve">
          <source>Filename extension if &lt;code&gt;source_fn&lt;/code&gt; is not provided. The extension tells which fortran standard is used. The default is &lt;code&gt;f&lt;/code&gt;, which implies F77 standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="529e452aa227b660fcf372199a15e8d7d5c2906a" translate="yes" xml:space="preserve">
          <source>Filename or file object to read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cafc76c090d17de83480422080a28bd0d7fd39f0" translate="yes" xml:space="preserve">
          <source>Fill a newly created array with a single value obj at all locations in the structure with object data-types. No checking is performed but &lt;em&gt;arr&lt;/em&gt; must be of data-type &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; and be single-segment and uninitialized (no previous objects in position). Use &lt;code&gt;PyArray_DECREF&lt;/code&gt; (&lt;em&gt;arr&lt;/em&gt;) if you need to decrement all the items in the object array prior to calling this function.</source>
          <target state="translated">使用对象数据类型在结构中的所有位置用单个值obj填充新创建的数组。不执行任何检查，但是&lt;em&gt;arr&lt;/em&gt;必须为数据类型&lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; &lt;/a&gt;且为单段且未初始化（位置中没有先前的对象）。如果需要在调用此函数之前减少对象数组中的所有项目，请使用 &lt;code&gt;PyArray_DECREF&lt;/code&gt; （&lt;em&gt;arr&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="bb9c4c9e7ee887e06f557b25790d19437a193098" translate="yes" xml:space="preserve">
          <source>Fill a newly created array with a single value obj at all locations in the structure with object data-types. No checking is performed but &lt;em&gt;arr&lt;/em&gt; must be of data-type &lt;a href=&quot;dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; and be single-segment and uninitialized (no previous objects in position). Use &lt;code&gt;PyArray_DECREF&lt;/code&gt; (&lt;em&gt;arr&lt;/em&gt;) if you need to decrement all the items in the object array prior to calling this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dddc689c840b0f704b5fbfeacd8ef3c5403555f" translate="yes" xml:space="preserve">
          <source>Fill in a new Python type-object structure with pointers to new functions that will over-ride the default behavior while leaving any function that should remain the same unfilled (or NULL). The tp_name element should be different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522f873213d8106cc0a4bcd37cf77275093b44ed" translate="yes" xml:space="preserve">
          <source>Fill in the tp_base member of the new type-object structure with a pointer to the (main) parent type object. For multiple-inheritance, also fill in the tp_bases member with a tuple containing all of the parent objects in the order they should be used to define inheritance. Remember, all parent-types must have the same C-structure for multiple inheritance to work properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a170286ef4b261aa8d713f55afdd2bfdd31a79" translate="yes" xml:space="preserve">
          <source>Fill out the release note &lt;code&gt;doc/release/1.14.5-notes.rst&lt;/code&gt; calling out significant changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260366fdf73d36b977576943b4aedf90420566c3" translate="yes" xml:space="preserve">
          <source>Fill the array pointed to by &lt;em&gt;obj&lt;/em&gt; &amp;mdash;which must be a (subclass of) ndarray&amp;mdash;with the contents of &lt;em&gt;val&lt;/em&gt; (evaluated as a byte). This macro calls memset, so obj must be contiguous.</source>
          <target state="translated">用&lt;em&gt;val&lt;/em&gt;的内容（以字节为单位）填充&lt;em&gt;obj所&lt;/em&gt;指向的数组（该数组必须是ndarray的子​​类）。此宏调用memset，因此obj必须是连续的。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1cc72d434ca66ec2855e95222b47cf34ee62d6a9" translate="yes" xml:space="preserve">
          <source>Fill the array with a scalar value.</source>
          <target state="translated">用一个标量值填充数组。</target>
        </trans-unit>
        <trans-unit id="a5d5966e608173a9667b1c1fac892e66538c72e9" translate="yes" xml:space="preserve">
          <source>Fill the array, &lt;em&gt;arr&lt;/em&gt;, with the given scalar object, &lt;em&gt;obj&lt;/em&gt;. The object is first converted to the data type of &lt;em&gt;arr&lt;/em&gt;, and then copied into every location. A -1 is returned if an error occurs, otherwise 0 is returned.</source>
          <target state="translated">用给定的标量对象&lt;em&gt;obj&lt;/em&gt;填充数组&lt;em&gt;arr&lt;/em&gt;。首先将对象转换为&lt;em&gt;arr&lt;/em&gt;的数据类型，然后将其复制到每个位置。如果发生错误，则返回-1，否则返回0。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7bee882405d3a5e1e28b315ab4a7baab2498c486" translate="yes" xml:space="preserve">
          <source>Fill the main diagonal of the given array of any dimensionality.</source>
          <target state="translated">填充任意维度的给定数组的主对角线。</target>
        </trans-unit>
        <trans-unit id="b0054199bd21115b17143e2277b55874769f1942" translate="yes" xml:space="preserve">
          <source>Fill value.</source>
          <target state="translated">填充值。</target>
        </trans-unit>
        <trans-unit id="b3edc087fa7c92433208963d028502658cb11c3c" translate="yes" xml:space="preserve">
          <source>Filling a masked array</source>
          <target state="translated">填充蒙版数组</target>
        </trans-unit>
        <trans-unit id="b16b1c014bc041df050e0baec2b30b9a58147141" translate="yes" xml:space="preserve">
          <source>Filling in the missing data</source>
          <target state="translated">填补缺失的数据</target>
        </trans-unit>
        <trans-unit id="f534a9943c59ee88bfbaa91a174f38f23a434db7" translate="yes" xml:space="preserve">
          <source>Filling value used to pad missing data on the shorter arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4473d8b6f530a08d5d328b58cdecfd819be6ec67" translate="yes" xml:space="preserve">
          <source>Filling value. A consistency test is performed to make sure the value is compatible with the dtype of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">填充值。进行一致性测试，以确保该值是用的D型兼容的 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13227282778cd8d20999d32a512e651e3ee07193" translate="yes" xml:space="preserve">
          <source>Filling value. Default is None.</source>
          <target state="translated">填充值。默认为无。</target>
        </trans-unit>
        <trans-unit id="6c1d42d50fc7e4074f490614ad1bcf00ba471b76" translate="yes" xml:space="preserve">
          <source>Fills &lt;code&gt;nop&lt;/code&gt; flags. Sets &lt;code&gt;outreadflags[i]&lt;/code&gt; to 1 if &lt;code&gt;op[i]&lt;/code&gt; can be read from, and to 0 if not.</source>
          <target state="translated">填充 &lt;code&gt;nop&lt;/code&gt; 标志。如果可以读取 &lt;code&gt;op[i]&lt;/code&gt; 则将 &lt;code&gt;outreadflags[i]&lt;/code&gt; 设置为1，否则将其设置为0。</target>
        </trans-unit>
        <trans-unit id="749d04ce696c047f8e1f31d9e0905d115c8ee6f7" translate="yes" xml:space="preserve">
          <source>Fills &lt;code&gt;nop&lt;/code&gt; flags. Sets &lt;code&gt;outwriteflags[i]&lt;/code&gt; to 1 if &lt;code&gt;op[i]&lt;/code&gt; can be written to, and to 0 if not.</source>
          <target state="translated">填充 &lt;code&gt;nop&lt;/code&gt; 标志。如果可以写入 &lt;code&gt;op[i]&lt;/code&gt; 则将 &lt;code&gt;outwriteflags[i]&lt;/code&gt; 设置为1，否则将其设置为0。</target>
        </trans-unit>
        <trans-unit id="488079b1696f7e1612a42c6bc0389bc81283467e" translate="yes" xml:space="preserve">
          <source>Fills fields from output with fields from input, with support for nested structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3ad1e9024ff38aba4d75bcdff8761b89757502" translate="yes" xml:space="preserve">
          <source>Filter deprecation warnings while running the test suite.</source>
          <target state="translated">在运行测试套件时过滤弃用警告。</target>
        </trans-unit>
        <trans-unit id="53d64090d55b3e9e6c51d2a5eb3eec10a8e6734d" translate="yes" xml:space="preserve">
          <source>Filters added inside the context manager will be discarded again when leaving it. Upon entering all filters defined outside a context will be applied automatically.</source>
          <target state="translated">在上下文管理器中添加的过滤器将在离开时再次被丢弃。进入后,所有在上下文之外定义的过滤器将被自动应用。</target>
        </trans-unit>
        <trans-unit id="1f7718a6ac69fd3c4dc296189cd48158349007af" translate="yes" xml:space="preserve">
          <source>Final output manipulation</source>
          <target state="translated">最后的输出操作</target>
        </trans-unit>
        <trans-unit id="f8cf825450130b603f61a294cd870952ff541ac0" translate="yes" xml:space="preserve">
          <source>Finally make a pull request using Github. Make sure it is against the maintenance branch and not master, Github will usually suggest you make the pull request against master.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba468d0ce6c90f05fb67a4c2a63c164ebea004bd" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;Configuration&lt;/code&gt; has &lt;code&gt;.todict()&lt;/code&gt; method that returns all the configuration data as a dictionary suitable for passing on to the &lt;code&gt;setup(..)&lt;/code&gt; function.</source>
          <target state="translated">最后， &lt;code&gt;Configuration&lt;/code&gt; 具有 &lt;code&gt;.todict()&lt;/code&gt; 方法，该方法返回所有配置数据作为适合传递给 &lt;code&gt;setup(..)&lt;/code&gt; 函数的字典。</target>
        </trans-unit>
        <trans-unit id="889c8c42cccc1d124561a48d8ca41abb6ac29d7b" translate="yes" xml:space="preserve">
          <source>Finally, a data type can describe items that are themselves arrays of items of another data type. These sub-arrays must, however, be of a fixed size.</source>
          <target state="translated">最后,一个数据类型可以描述本身就是另一个数据类型的项目数组的项目。但是,这些子数组必须是固定大小的。</target>
        </trans-unit>
        <trans-unit id="aa9d6cc4ce78cfcc5632e894bf62475be204d2f2" translate="yes" xml:space="preserve">
          <source>Finally, build an extension module using &lt;code&gt;f2py -c -m foo calculate.f&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4822ed4109421c2e3621bdd61e51416dfd1386" translate="yes" xml:space="preserve">
          <source>Finally, build the extension module using &lt;code&gt;f2py -c callback2.pyf callback.f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591676022a4d7afed7631e7209e11f88a0c70ca2" translate="yes" xml:space="preserve">
          <source>Finally, if you are only interested in testing a subset of SciPy, for example, the &lt;code&gt;integrate&lt;/code&gt; module, use the following:</source>
          <target state="translated">最后，如果您仅对测试SciPy的子集（例如， &lt;code&gt;integrate&lt;/code&gt; 模块）感兴趣，请使用以下命令：</target>
        </trans-unit>
        <trans-unit id="7ffdd7c64bfdacea7dacfdba32a5f08b8fc22860" translate="yes" xml:space="preserve">
          <source>Finally, if you detect a typo or an error in the documentation, or would like to suggest a different approach, you can also open an issue or submit a pull request with your suggestion. Keep in mind that changes fixing grammatical/spelling errors are welcome but not necessarily the highest priority. &amp;ldquo;Grammatical correctness&amp;rdquo; often gets confused with &amp;ldquo;style&amp;rdquo; which can result in unfruitful discussions that don&amp;rsquo;t necessarily improve anything. Changes that modify wording or rearrange phrasing without changing the technical content are discouraged. If you think that a different wording improves clarity, you should open an issue as noted above, but again, changes along these lines very often tend to be highly subjective and not necessarily do much to improve the quality of the documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd9ab198daaf3fb255075968e2a8d87bc37a3b9" translate="yes" xml:space="preserve">
          <source>Finally, it is emphasized that &lt;code&gt;v&lt;/code&gt; consists of the &lt;em&gt;right&lt;/em&gt; (as in right-hand side) eigenvectors of &lt;code&gt;a&lt;/code&gt;. A vector &lt;code&gt;y&lt;/code&gt; satisfying &lt;code&gt;dot(y.T, a) = z * y.T&lt;/code&gt; for some number &lt;code&gt;z&lt;/code&gt; is called a &lt;em&gt;left&lt;/em&gt; eigenvector of &lt;code&gt;a&lt;/code&gt;, and, in general, the left and right eigenvectors of a matrix are not necessarily the (perhaps conjugate) transposes of each other.</source>
          <target state="translated">最后，需要强调的是 &lt;code&gt;v&lt;/code&gt; 组成的&lt;em&gt;右侧&lt;/em&gt;（如右侧）的特征向量 &lt;code&gt;a&lt;/code&gt; 。载体 &lt;code&gt;y&lt;/code&gt; 满足 &lt;code&gt;dot(y.T, a) = z * y.T&lt;/code&gt; 一段数 &lt;code&gt;z&lt;/code&gt; 被称为&lt;em&gt;左侧&lt;/em&gt;的特征向量 &lt;code&gt;a&lt;/code&gt; 每个，并且，在一般情况下，矩阵的左和右本征向量不必是（可能共轭）转置其他。</target>
        </trans-unit>
        <trans-unit id="d65f378e68ed6a19a18dfdea402e5e3481327cbe" translate="yes" xml:space="preserve">
          <source>Finally, it is emphasized that &lt;code&gt;v&lt;/code&gt; consists of the &lt;em&gt;right&lt;/em&gt; (as in right-hand side) eigenvectors of &lt;code&gt;a&lt;/code&gt;. A vector &lt;code&gt;y&lt;/code&gt; satisfying &lt;code&gt;y.T @ a = z * y.T&lt;/code&gt; for some number &lt;code&gt;z&lt;/code&gt; is called a &lt;em&gt;left&lt;/em&gt; eigenvector of &lt;code&gt;a&lt;/code&gt;, and, in general, the left and right eigenvectors of a matrix are not necessarily the (perhaps conjugate) transposes of each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc16b6bd7f60859052f3d3e721d3a31f9f6a180" translate="yes" xml:space="preserve">
          <source>Finally, now you are confident this tag correctly defines the source code that you released you can push the tag and release commit up to github:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6153981fb1186c6a6c180fa5791ae775d104d070" translate="yes" xml:space="preserve">
          <source>Finally, remove the backup branch upon a successful rebase:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98d9a64e4784c058720be52ad39c03d39a9fcbd1" translate="yes" xml:space="preserve">
          <source>Finally, specific entries can be masked and/or unmasked by assigning to the mask a sequence of booleans:</source>
          <target state="translated">最后,可以通过给掩码分配一连串的booleans来掩码和/或取消掩码特定的条目。</target>
        </trans-unit>
        <trans-unit id="4d63661f6815f6c84ea80e3487b297638030ca91" translate="yes" xml:space="preserve">
          <source>Finally, the committee will make a report to the NumPy Steering Council (as well as the NumPy core team in the event of an ongoing resolution, such as a ban).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ee797bc2c97cc8f17d94ef802f458cb35c39bc" translate="yes" xml:space="preserve">
          <source>Finally, the decision is made about how to execute the looping mechanism to ensure that all elements of the input arrays are combined to produce the output arrays of the correct type. The options for loop execution are one-loop (for contiguous, aligned, and correct data type), strided-loop (for non-contiguous but still aligned and correct data type), and a buffered loop (for mis-aligned or incorrect data type situations). Depending on which execution method is called for, the loop is then setup and computed.</source>
          <target state="translated">最后,决定如何执行循环机制,以确保输入数组的所有元素都能组合成正确类型的输出数组。循环执行的选项有单循环(适用于连续、对齐和正确的数据类型)、strided-loop(适用于非连续但仍对齐和正确的数据类型)和缓冲循环(适用于错误对齐或不正确的数据类型情况)。根据调用哪种执行方法,再对循环进行设置和计算。</target>
        </trans-unit>
        <trans-unit id="75d671d62eb366ddccfcb1e2724191d1a472b131" translate="yes" xml:space="preserve">
          <source>Finally, the two functions to be exported by the interface can be written simply as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06dcc2f32047bb203bf95d18ff9fb7501e8c9e4" translate="yes" xml:space="preserve">
          <source>Finally, to obtain the full approximated image, we need to reassemble these matrices into the approximation. Now, note that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3616e9f1dcf861efd823c12b4478a31e6b82b402" translate="yes" xml:space="preserve">
          <source>Financial functions</source>
          <target state="translated">财务职能</target>
        </trans-unit>
        <trans-unit id="e6c50d99742741634b01369176b77e9bcc5af665" translate="yes" xml:space="preserve">
          <source>Financial interests, such as investments, employment or contracting work, outside of The Project that may influence their work on The Project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eddebdeca9f674c3a8bdff9147a750bce04b0b48" translate="yes" xml:space="preserve">
          <source>Find a candidate who can serve as a mediator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75334f040026f76d3eebb8839bcb303508014551" translate="yes" xml:space="preserve">
          <source>Find a domain suitable for a polynomial or Chebyshev series defined at the values supplied.</source>
          <target state="translated">找出一个适合于在所提供的值上定义的多项式或切比雪夫数列的域。</target>
        </trans-unit>
        <trans-unit id="c2a6e9c15d888c380a37d1831fa7891adeb9bb51" translate="yes" xml:space="preserve">
          <source>Find contiguous unmasked data in a masked array along the given axis.</source>
          <target state="translated">沿着给定的轴,在掩码阵列中找到连续的非掩码数据。</target>
        </trans-unit>
        <trans-unit id="a4ea5a445ce3dee9c559f1f1b3b7f52dca61477d" translate="yes" xml:space="preserve">
          <source>Find elements in a sorted array.</source>
          <target state="translated">在一个排序的数组中查找元素。</target>
        </trans-unit>
        <trans-unit id="48cd38efe59f33f3a5f798ed6a4cf4880d549aa4" translate="yes" xml:space="preserve">
          <source>Find elements in sorted array.</source>
          <target state="translated">在排序数组中查找元素。</target>
        </trans-unit>
        <trans-unit id="f6a5d00a32b708a9fb964c2d1da18b0ebb9fba20" translate="yes" xml:space="preserve">
          <source>Find indices where elements of v should be inserted in a to maintain order.</source>
          <target state="translated">找出v的元素应该插入a中的索引,以保持顺序。</target>
        </trans-unit>
        <trans-unit id="18d914d41d09d92c97e462c896bc6019f8705e89" translate="yes" xml:space="preserve">
          <source>Find indices where elements should be inserted to maintain order.</source>
          <target state="translated">找出应插入元素的索引,以保持顺序。</target>
        </trans-unit>
        <trans-unit id="9f16fd78492b0e655d9646c090e0277fb4bab8b3" translate="yes" xml:space="preserve">
          <source>Find more information about &lt;a href=&quot;../reference/arrays.indexing#arrays-indexing&quot;&gt;newaxis here&lt;/a&gt; and &lt;code&gt;expand_dims&lt;/code&gt; at &lt;a href=&quot;../reference/generated/numpy.expand_dims#numpy.expand_dims&quot;&gt;&lt;code&gt;expand_dims&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4372485b0452a2bbbc2898c490d8eaeffc724caf" translate="yes" xml:space="preserve">
          <source>Find the coefficients of a polynomial with a given sequence of roots.</source>
          <target state="translated">找出给定根序列的多项式的系数。</target>
        </trans-unit>
        <trans-unit id="faa2e8dff7b7635f67ecf147d005df15f99ba737" translate="yes" xml:space="preserve">
          <source>Find the coefficients of a polynomial with the given sequence of roots.</source>
          <target state="translated">找出给定根序列的多项式的系数。</target>
        </trans-unit>
        <trans-unit id="4eb3d9e0549601789e7c859dc2344bd2a9cd19fd" translate="yes" xml:space="preserve">
          <source>Find the derivative of order &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">找到阶 &lt;code&gt;m&lt;/code&gt; 的导数。</target>
        </trans-unit>
        <trans-unit id="d4ef9328264dc057bcc77daf8eddd203dc0e44a3" translate="yes" xml:space="preserve">
          <source>Find the duplicates in a structured array along a given key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b2e68d5137b01880925e686f099633be3e06dde" translate="yes" xml:space="preserve">
          <source>Find the indices into a sorted array &lt;code&gt;a&lt;/code&gt; such that, if the corresponding elements in &lt;code&gt;v&lt;/code&gt; were inserted before the indices, the order of &lt;code&gt;a&lt;/code&gt; would be preserved.</source>
          <target state="translated">将索引查找到排序数组 &lt;code&gt;a&lt;/code&gt; 中,这样，如果 &lt;code&gt;v&lt;/code&gt; 中的相应元素在索引之前插入，则将保留 &lt;code&gt;a&lt;/code&gt; 的顺序。</target>
        </trans-unit>
        <trans-unit id="7a9d95dd2166bd57167eb2521a394d4c2313d8ed" translate="yes" xml:space="preserve">
          <source>Find the indices of array elements that are non-zero, grouped by element.</source>
          <target state="translated">找出非零的数组元素的索引,按元素分组。</target>
        </trans-unit>
        <trans-unit id="2515b150e246a2efffb14706325a36534baa7e52" translate="yes" xml:space="preserve">
          <source>Find the indices of the first and last unmasked values along an axis.</source>
          <target state="translated">沿着一个轴找到第一个和最后一个未屏蔽的值的指数。</target>
        </trans-unit>
        <trans-unit id="696f121ac590832370778adcb2254fdcf409cf46" translate="yes" xml:space="preserve">
          <source>Find the indices of the first and last unmasked values.</source>
          <target state="translated">找到第一个和最后一个未屏蔽的值的指数。</target>
        </trans-unit>
        <trans-unit id="8c77cbf79b427711a4234d92c8cd55031f045a5a" translate="yes" xml:space="preserve">
          <source>Find the intersection of two arrays.</source>
          <target state="translated">找出两个数组的交点。</target>
        </trans-unit>
        <trans-unit id="1d747b61a4dca9ab1a6c9357e1706a93f4e98f6e" translate="yes" xml:space="preserve">
          <source>Find the product of two polynomials.</source>
          <target state="translated">求两个多项式的乘积。</target>
        </trans-unit>
        <trans-unit id="f141aa841d4a25a7614625f7b95555f03b44cb1f" translate="yes" xml:space="preserve">
          <source>Find the roots:</source>
          <target state="translated">找到根。</target>
        </trans-unit>
        <trans-unit id="e641c4ed98de6b655c0148c1b174236bccd25db9" translate="yes" xml:space="preserve">
          <source>Find the set difference of two arrays.</source>
          <target state="translated">求两个数组的集合差。</target>
        </trans-unit>
        <trans-unit id="1d47458289ee93eb8b76d9bd5fb051fb0ed38ef9" translate="yes" xml:space="preserve">
          <source>Find the set exclusive-or of two arrays.</source>
          <target state="translated">找出两个数组的集合独占或。</target>
        </trans-unit>
        <trans-unit id="40c6faf7e08f7eff45fa7f2fb510420c1dd0653b" translate="yes" xml:space="preserve">
          <source>Find the sum of two polynomials.</source>
          <target state="translated">求两个多项式的和。</target>
        </trans-unit>
        <trans-unit id="bc296de5854442d0290915421679a6d44da683c5" translate="yes" xml:space="preserve">
          <source>Find the union of two arrays.</source>
          <target state="translated">找出两个数组的联合。</target>
        </trans-unit>
        <trans-unit id="1c2a1d48695ed18506cd6bf1d2bc59c3cfb89875" translate="yes" xml:space="preserve">
          <source>Find the unique elements of an array.</source>
          <target state="translated">查找数组中的唯一元素。</target>
        </trans-unit>
        <trans-unit id="3c5a640c918941c9e6a6ecbfe984c3f4bfbed0d7" translate="yes" xml:space="preserve">
          <source>Finding help</source>
          <target state="translated">寻找帮助</target>
        </trans-unit>
        <trans-unit id="5b7033e44afb091d2adc537dc898dc007a565a8f" translate="yes" xml:space="preserve">
          <source>Finding masked data</source>
          <target state="translated">寻找被屏蔽的数据</target>
        </trans-unit>
        <trans-unit id="3f98684f09d3dc8ddcf467b643533c39f6675211" translate="yes" xml:space="preserve">
          <source>Finds the data type of smallest size and kind to which &lt;em&gt;type1&lt;/em&gt; and &lt;em&gt;type2&lt;/em&gt; may be safely converted. This function is symmetric and associative. A string or unicode result will be the proper size for storing the max value of the input types converted to a string or unicode.</source>
          <target state="translated">查找可以将&lt;em&gt;type1&lt;/em&gt;和&lt;em&gt;type2&lt;/em&gt;安全地转换为最小大小和种类的数据类型。此功能是对称且关联的。字符串或unicode结果将是适当的大小，用于存储转换为字符串或unicode的输入类型的最大值。</target>
        </trans-unit>
        <trans-unit id="ce819b28621d52328ceb9faf1bacb0b89098499a" translate="yes" xml:space="preserve">
          <source>Finds the polynomial resulting from the multiplication of the two input polynomials. Each input must be either a poly1d object or a 1D sequence of polynomial coefficients, from highest to lowest degree.</source>
          <target state="translated">找出两个输入多项式相乘后的多项式。每个输入必须是一个 poly1d 对象或多项式系数的 1D 序列,从高到低。</target>
        </trans-unit>
        <trans-unit id="1b46b96bf59323c910259f84d4d30f9baf994f09" translate="yes" xml:space="preserve">
          <source>Finish the Release Note</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f34df28a801d8ac2bf79f8d990420b3ba51454a" translate="yes" xml:space="preserve">
          <source>First adjusts the date to fall on a valid day according to the &lt;code&gt;roll&lt;/code&gt; rule, then applies offsets to the given dates counted in valid days.</source>
          <target state="translated">首先根据 &lt;code&gt;roll&lt;/code&gt; 规则将日期调整为属于有效日期，然后将偏移量应用于在有效日期中计算的给定日期。</target>
        </trans-unit>
        <trans-unit id="3d783583ca6eea2b3fefbcfe238ea095a9cef1e3" translate="yes" xml:space="preserve">
          <source>First argument.</source>
          <target state="translated">第一个论点:</target>
        </trans-unit>
        <trans-unit id="b0d88798d2f2c8c94dabdac74a6e61e0c6a796bf" translate="yes" xml:space="preserve">
          <source>First array</source>
          <target state="translated">第一个阵列</target>
        </trans-unit>
        <trans-unit id="6ac9adbced8bb3d28582fadcfc79411667f91541" translate="yes" xml:space="preserve">
          <source>First array elements raised to powers from second array, element-wise.</source>
          <target state="translated">第一个数组元素从第二个数组中提升到幂,逐个元素。</target>
        </trans-unit>
        <trans-unit id="2e663054d84a3a5ee1c34a1c08db3c0840bbd3a5" translate="yes" xml:space="preserve">
          <source>First axis.</source>
          <target state="translated">第一轴:</target>
        </trans-unit>
        <trans-unit id="683b791e072100a372b3bb52b18b0195b72f135d" translate="yes" xml:space="preserve">
          <source>First data type.</source>
          <target state="translated">第一个数据类型:</target>
        </trans-unit>
        <trans-unit id="380b7446c9b92904f875ef654f53dbe5211d262c" translate="yes" xml:space="preserve">
          <source>First fork NumPy into your account, as from &lt;a href=&quot;gitwash/development_setup#forking&quot;&gt;Making your own copy (fork) of NumPy&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c696689a14b681bedf220e6fcb537947492362e7" translate="yes" xml:space="preserve">
          <source>First input vector. Input is flattened if not already 1-dimensional.</source>
          <target state="translated">第一个输入向量。如果还不是一维的,则对输入进行扁平化处理。</target>
        </trans-unit>
        <trans-unit id="4da5db5b8e385a1ee882571360fd0091e5988af4" translate="yes" xml:space="preserve">
          <source>First mode, &lt;code&gt;buffer&lt;/code&gt; is None:</source>
          <target state="translated">第一种模式， &lt;code&gt;buffer&lt;/code&gt; 为None：</target>
        </trans-unit>
        <trans-unit id="79fb79c693534cb9180b2dc2b3dd92f6526ad678" translate="yes" xml:space="preserve">
          <source>First of all, if confused or uncertain, definitely look at the Examples - in its full generality, this function is less simple than it might seem from the following code description (below ndi = &lt;code&gt;numpy.lib.index_tricks&lt;/code&gt;):</source>
          <target state="translated">首先，如果感到困惑或不确定，一定要看一下示例-完全具有通用性，此函数不如下面的代码描述（在ndi = &lt;code&gt;numpy.lib.index_tricks&lt;/code&gt; 之下）看起来的那么简单：</target>
        </trans-unit>
        <trans-unit id="9507aadaef3c19b4ad781014173284bb4bf64a4d" translate="yes" xml:space="preserve">
          <source>First one-dimensional input array.</source>
          <target state="translated">第一个一维输入阵列。</target>
        </trans-unit>
        <trans-unit id="563237e589c4b3a10445b43e30dbcdf140e6cad9" translate="yes" xml:space="preserve">
          <source>First we need a polynomial class and a polynomial instance to play with. The classes can be imported directly from the polynomial package or from the module of the relevant type. Here we import from the package and use the conventional Polynomial class because of its familiarity:</source>
          <target state="translated">首先我们需要一个多项式类和一个多项式实例来玩。这些类可以直接从多项式包中导入,也可以从相关类型的模块中导入。这里我们从包中导入,因为熟悉,所以使用常规的多项式类。</target>
        </trans-unit>
        <trans-unit id="b0f42fa2b5b73e0d242583740b22144cb029b3bc" translate="yes" xml:space="preserve">
          <source>First you follow the instructions for &lt;a href=&quot;#forking&quot;&gt;Making your own copy (fork) of NumPy&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a78e460dd4b928f74942152fb57a017ad1190035" translate="yes" xml:space="preserve">
          <source>First, change/check the following variables in &lt;code&gt;pavement.py&lt;/code&gt; depending on the release version:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5de2ca0c3525a19f6ce453df437f39312ae63f64" translate="yes" xml:space="preserve">
          <source>First, fetch new commits from the &lt;code&gt;upstream&lt;/code&gt; repository:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7560a3397ca22e9994a5b8700ca3649fe54f4e" translate="yes" xml:space="preserve">
          <source>First, let&amp;rsquo;s check for the shape of the data in our array. Since this image is two-dimensional (the pixels in the image form a rectangle), we might expect a two-dimensional array to represent it (a matrix). However, using the &lt;code&gt;shape&lt;/code&gt; property of this NumPy array gives us a different result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e842f4efdaf87bde11917dd06d4d96aa743693a2" translate="yes" xml:space="preserve">
          <source>First, merge or rebase on the target branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d50e07ef0974f6c61f9887836f0cd195c4b8ffe" translate="yes" xml:space="preserve">
          <source>First, we create a signature file from &lt;code&gt;fib1.f&lt;/code&gt; by running</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5747b08f0749ca8d3f849c4ccb46feb2a535fd" translate="yes" xml:space="preserve">
          <source>First, we solve for</source>
          <target state="translated">首先,我们求解</target>
        </trans-unit>
        <trans-unit id="2db03d669f6d38f72ba0afd2d06c9fa6852bb990" translate="yes" xml:space="preserve">
          <source>First, you need to make the branch you will work on. This needs to be based on the older version of NumPy (not master):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b876747d103212266850792bf08c2d985fdb7ec" translate="yes" xml:space="preserve">
          <source>Fisher, R.A,, A.S. Corbet, and C.B. Williams. 1943. The relation between the number of species and the number of individuals in a random sample of an animal population. Journal of Animal Ecology, 12:42-58.</source>
          <target state="translated">Fisher,R.A,A.S.Corbet,和C.B.Williams。1943.动物种群随机抽样中物种数量和个体数量之间的关系。动物生态学杂志,12:42-58。</target>
        </trans-unit>
        <trans-unit id="1c009756385026adf817423fdf3347327b7bcadd" translate="yes" xml:space="preserve">
          <source>Fit a line, &lt;code&gt;y = mx + c&lt;/code&gt;, through some noisy data-points:</source>
          <target state="translated">通过一些嘈杂的数据点拟合一条线 &lt;code&gt;y = mx + c&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="04b6a58e5360946679575e2105b73e661e63702d" translate="yes" xml:space="preserve">
          <source>Fit a polynomial &lt;code&gt;p(x) = p[0] * x**deg + ... + p[deg]&lt;/code&gt; of degree &lt;code&gt;deg&lt;/code&gt; to points &lt;code&gt;(x, y)&lt;/code&gt;. Returns a vector of coefficients &lt;code&gt;p&lt;/code&gt; that minimises the squared error in the order &lt;code&gt;deg&lt;/code&gt;, &lt;code&gt;deg-1&lt;/code&gt;, &amp;hellip; &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">适合的多项式 &lt;code&gt;p(x) = p[0] * x**deg + ... + p[deg]&lt;/code&gt; 度的 &lt;code&gt;deg&lt;/code&gt; 来分 &lt;code&gt;(x, y)&lt;/code&gt; 。返回系数 &lt;code&gt;p&lt;/code&gt; 的向量，该向量使 &lt;code&gt;deg&lt;/code&gt; ， &lt;code&gt;deg-1&lt;/code&gt; ，&amp;hellip; &lt;code&gt;0&lt;/code&gt; 阶的平方误差最小。</target>
        </trans-unit>
        <trans-unit id="c63bb8e80d7458f568a44355aa0204375070cb16" translate="yes" xml:space="preserve">
          <source>Fits using Chebyshev series are usually better conditioned than fits using power series, but much can depend on the distribution of the sample points and the smoothness of the data. If the quality of the fit is inadequate splines may be a good alternative.</source>
          <target state="translated">使用切比雪夫序列的拟合通常比使用功率序列的拟合条件要好,但这很大程度上取决于样本点的分布和数据的平滑度。如果拟合的质量不够,花键可能是一个很好的选择。</target>
        </trans-unit>
        <trans-unit id="aed614e2e664ebb51dcf5d13afb77c7acb23c65a" translate="yes" xml:space="preserve">
          <source>Fits using Hermite series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the Hermite weight. In that case the weight &lt;code&gt;sqrt(w(x[i]))&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i]))&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.hermite.hermweight#numpy.polynomial.hermite.hermweight&quot;&gt;&lt;code&gt;hermweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac350719f356e32b4a5aa08bc22f253d0d0c702" translate="yes" xml:space="preserve">
          <source>Fits using Hermite series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the Hermite weight. In that case the weight &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.hermite.hermweight#numpy.polynomial.hermite.hermweight&quot;&gt;&lt;code&gt;hermweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当可以通过 &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt; 近似数据时，使用Hermite系列拟合可能最有用，其中 &lt;code&gt;w(x)&lt;/code&gt; 是Hermite权重。在这种情况下，应将权重 &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; 与数据值 &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt; 。权重函数可用作&lt;a href=&quot;numpy.polynomial.hermite.hermweight#numpy.polynomial.hermite.hermweight&quot;&gt; &lt;code&gt;hermweight&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a56ae26ef02f4f89e7f11d94ca2c9c2304108b1" translate="yes" xml:space="preserve">
          <source>Fits using HermiteE series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the HermiteE weight. In that case the weight &lt;code&gt;sqrt(w(x[i]))&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i]))&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.hermite_e.hermeweight#numpy.polynomial.hermite_e.hermeweight&quot;&gt;&lt;code&gt;hermeweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="676d43f6371871e1abab21b58a8b9ef9e5c444e9" translate="yes" xml:space="preserve">
          <source>Fits using HermiteE series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the HermiteE weight. In that case the weight &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.hermite_e.hermeweight#numpy.polynomial.hermite_e.hermeweight&quot;&gt;&lt;code&gt;hermeweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当可以通过 &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt; 近似数据时，使用HermiteE系列拟合可能是最有用的，其中 &lt;code&gt;w(x)&lt;/code&gt; 是HermiteE权重。在这种情况下，应将权重 &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; 与数据值 &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt; 。权重函数可用作&lt;a href=&quot;numpy.polynomial.hermite_e.hermeweight#numpy.polynomial.hermite_e.hermeweight&quot;&gt; &lt;code&gt;hermeweight&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce120ffeca412ba96243f730c358ebc5c1bfbf99" translate="yes" xml:space="preserve">
          <source>Fits using Laguerre series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the Laguerre weight. In that case the weight &lt;code&gt;sqrt(w(x[i]))&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i]))&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.laguerre.lagweight#numpy.polynomial.laguerre.lagweight&quot;&gt;&lt;code&gt;lagweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ad2d45b7ba84d02856af83a31db48500b6c521" translate="yes" xml:space="preserve">
          <source>Fits using Laguerre series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the Laguerre weight. In that case the weight &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.laguerre.lagweight#numpy.polynomial.laguerre.lagweight&quot;&gt;&lt;code&gt;lagweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当可以通过 &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt; 近似数据时，使用Laguerre级数拟合可能最有用，其中 &lt;code&gt;w(x)&lt;/code&gt; 是Laguerre权重。在这种情况下，应该将权重 &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; 与数据值 &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt; 。权重函数可以作为&lt;a href=&quot;numpy.polynomial.laguerre.lagweight#numpy.polynomial.laguerre.lagweight&quot;&gt; &lt;code&gt;lagweight&lt;/code&gt; 来使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a49cebd2c0a64b6ed696a25d8e9c66d10c8d54a0" translate="yes" xml:space="preserve">
          <source>Fits using Legendre series are usually better conditioned than fits using power series, but much can depend on the distribution of the sample points and the smoothness of the data. If the quality of the fit is inadequate splines may be a good alternative.</source>
          <target state="translated">使用Legendre数列的拟合通常比使用幂数列的拟合条件更好,但这很大程度上取决于样本点的分布和数据的平稳性。如果拟合的质量不够,花键可能是一个很好的选择。</target>
        </trans-unit>
        <trans-unit id="5165daf49b08b1322899a60f534d050a344807b1" translate="yes" xml:space="preserve">
          <source>Fitting</source>
          <target state="translated">Fitting</target>
        </trans-unit>
        <trans-unit id="5e51f96db68dc8fabd62d003884216322595fc6f" translate="yes" xml:space="preserve">
          <source>Fitting is the reason that the &lt;code&gt;domain&lt;/code&gt; and &lt;code&gt;window&lt;/code&gt; attributes are part of the convenience classes. To illustrate the problem, the values of the Chebyshev polynomials up to degree 5 are plotted below.</source>
          <target state="translated">拟合是 &lt;code&gt;domain&lt;/code&gt; 和 &lt;code&gt;window&lt;/code&gt; 属性属于便捷类的一部分的原因。为了说明此问题，下面绘制了直至5级的Chebyshev多项式的值。</target>
        </trans-unit>
        <trans-unit id="a882b40f9b004c60f42b6ed77cd0d0cb856640fe" translate="yes" xml:space="preserve">
          <source>Fix for PPC long double floating point information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919c4e1e9eb76e3cc1d2c2a8e361176acc1a9a4a" translate="yes" xml:space="preserve">
          <source>Fix regression in matmul (&lt;code&gt;@&lt;/code&gt; operator) for boolean types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f0d59fd522286a2d4031174470931df04c244c1" translate="yes" xml:space="preserve">
          <source>Fix swig bug in &lt;code&gt;numpy.i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95e31f1005ee116c93848080ddafc6a63474e8a" translate="yes" xml:space="preserve">
          <source>Fix to financial.npv</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4ad4288a37cfec787d6b9ab856b537a200ab81" translate="yes" xml:space="preserve">
          <source>Fixed &lt;code&gt;eigh&lt;/code&gt; and &lt;code&gt;cholesky&lt;/code&gt; methods in &lt;code&gt;numpy.random.multivariate_normal&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa2ab2730080c4d8658ad57247e52d05152019e" translate="yes" xml:space="preserve">
          <source>Fixed stride displacement from the beginning of an axis? Default is 0. Needs to be &amp;gt;=0.</source>
          <target state="translated">从轴的起点开始固定的步幅位移？默认值为0。需要&amp;gt; = 0。</target>
        </trans-unit>
        <trans-unit id="cb2453cbdd88f7c5dbf744844c92b0eb5d9399b7" translate="yes" xml:space="preserve">
          <source>Fixed the jumping implementation in &lt;code&gt;MT19937.jumped&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8028cdac733fedf53d18c62ba8dde19dd4874832" translate="yes" xml:space="preserve">
          <source>Fixes Merged</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="988fef1858095167d23aba7f3c43fc27915118e8" translate="yes" xml:space="preserve">
          <source>Fixing Warnings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35076585aaced59b92c591cb61ebdef18acdfe9a" translate="yes" xml:space="preserve">
          <source>Flag checking</source>
          <target state="translated">旗帜检查</target>
        </trans-unit>
        <trans-unit id="a59933a6089d6095752a4cce71d3ac903e7e62ac" translate="yes" xml:space="preserve">
          <source>Flag indicating the return a legacy tuple state when the BitGenerator is MT19937.</source>
          <target state="translated">标志表示当BitGenerator为MT19937时,返回一个遗留元组状态。</target>
        </trans-unit>
        <trans-unit id="ed451b4de2e9f4e89792baf70b0beefe2ddce512" translate="yes" xml:space="preserve">
          <source>Flag indicating to return a legacy tuple state when the BitGenerator is MT19937, instead of a dict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eae779d408b29132a4d17f05274c96311b19164" translate="yes" xml:space="preserve">
          <source>Flag indicating whether a tuple &lt;code&gt;(result, sum of weights)&lt;/code&gt; should be returned as output (True), or just the result (False). Default is False.</source>
          <target state="translated">指示应将元组 &lt;code&gt;(result, sum of weights)&lt;/code&gt; 作为输出（真）还是仅作为结果（假）返回的标志。默认值为False。</target>
        </trans-unit>
        <trans-unit id="cba3c052d7e9a9fd1a29828876ef83802ed53ad9" translate="yes" xml:space="preserve">
          <source>Flag to determine whether to mark test as deprecated or not. If the condition is a callable, it is used at runtime to dynamically make the decision. Default is True.</source>
          <target state="translated">用于决定是否将测试标记为废弃的标志。如果条件是可调用的,则在运行时使用它来动态地做出决定。默认为True。</target>
        </trans-unit>
        <trans-unit id="fc63716a41208b1dbc0ebbf61137c2d0ff0fbfd4" translate="yes" xml:space="preserve">
          <source>Flag to determine whether to mark the decorated test as a known failure (if True) or not (if False).</source>
          <target state="translated">标志,以确定是否将装饰测试标记为已知失败(如果为真)或不标记(如果为假)。</target>
        </trans-unit>
        <trans-unit id="3a36aef11ecfbbf2d82d57b5084b3ab96e773b04" translate="yes" xml:space="preserve">
          <source>Flag to determine whether to skip the decorated test.</source>
          <target state="translated">确定是否跳过装饰测试的标志。</target>
        </trans-unit>
        <trans-unit id="75e57359674e825c88bcaaa1bf354a5ba42abc10" translate="yes" xml:space="preserve">
          <source>Flag-like constants</source>
          <target state="translated">旗状常数</target>
        </trans-unit>
        <trans-unit id="684f757afc22b26a0ad180a11e58599da12d805b" translate="yes" xml:space="preserve">
          <source>Flags indicating how the memory pointed to by data is to be interpreted. Possible flags are &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指示如何解释数据指向的存储器的标志。可能的标志是&lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.array#c.NPY_ARRAY_OWNDATA&quot;&gt; &lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a25e18657a4cd94e4091eda9ea0dfb9fbc2878ec" translate="yes" xml:space="preserve">
          <source>Flags that may be passed in &lt;code&gt;flags&lt;/code&gt; are any combination of the global and per-operand flags documented in &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;, except for &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt;&lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以传递的 &lt;code&gt;flags&lt;/code&gt; 是&lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; 中&lt;/a&gt;记录的global和per-operand标志的任何组合，除了&lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt; &lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt; &lt;/a&gt;之外。</target>
        </trans-unit>
        <trans-unit id="edc811e4e9d890d1a74c59122b943f93451db31b" translate="yes" xml:space="preserve">
          <source>Flags that may be passed in &lt;code&gt;flags&lt;/code&gt;, applying to the whole iterator, are:</source>
          <target state="translated">可以在 &lt;code&gt;flags&lt;/code&gt; 中传递的标志（适用于整个迭代器）是：</target>
        </trans-unit>
        <trans-unit id="e576896ed3787e8ae91c02c3fee7275b55ae4f5d" translate="yes" xml:space="preserve">
          <source>Flags that may be passed in &lt;code&gt;op_flags[i]&lt;/code&gt;, where &lt;code&gt;0 &amp;lt;= i &amp;lt; nop&lt;/code&gt;:</source>
          <target state="translated">可以在 &lt;code&gt;op_flags[i]&lt;/code&gt; 传递的标志，其中 &lt;code&gt;0 &amp;lt;= i &amp;lt; nop&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0902dde9b75159ba7b0f6af69bd12aa3aed3ab46" translate="yes" xml:space="preserve">
          <source>Flags to control the behavior of the iterator.</source>
          <target state="translated">控制迭代器行为的标志。</target>
        </trans-unit>
        <trans-unit id="1bbaad527fcacc3d77ae0f546c2f20b2e4ef2d71" translate="yes" xml:space="preserve">
          <source>Flat Iterator indexing</source>
          <target state="translated">扁平迭代器索引</target>
        </trans-unit>
        <trans-unit id="ca0541280577eeacfb45501ad1950007e690905f" translate="yes" xml:space="preserve">
          <source>Flat array iterator.</source>
          <target state="translated">扁平数组迭代器。</target>
        </trans-unit>
        <trans-unit id="3f8292fdeb383ecef90303832ffb1117799af185" translate="yes" xml:space="preserve">
          <source>Flat iteration</source>
          <target state="translated">扁平化迭代</target>
        </trans-unit>
        <trans-unit id="666002e8705384831180e281fa74a843e3206b27" translate="yes" xml:space="preserve">
          <source>Flat iterator object to iterate over arrays.</source>
          <target state="translated">扁平迭代器对象,用于迭代数组。</target>
        </trans-unit>
        <trans-unit id="7d04e81220d975aa709532a3862f6c1a6f4a3f05" translate="yes" xml:space="preserve">
          <source>Flatten a structured data-type description.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec4ad130c0f4e03f5e84c5e86d9264a95dc6c3f6" translate="yes" xml:space="preserve">
          <source>Flattened version of this function.</source>
          <target state="translated">该函数的扁平化版本。</target>
        </trans-unit>
        <trans-unit id="21fe615f2b66ecf8096308ee67f646d6664a1077" translate="yes" xml:space="preserve">
          <source>Flip an array horizontally (axis=1).</source>
          <target state="translated">水平翻转一个数组(axis=1)。</target>
        </trans-unit>
        <trans-unit id="7849c3ad46cd56097aefd350ce5a24872c1a9619" translate="yes" xml:space="preserve">
          <source>Flip an array horizontally.</source>
          <target state="translated">水平翻转一个阵列。</target>
        </trans-unit>
        <trans-unit id="a25cec9261711d7c64f4f0328d27630ff4251008" translate="yes" xml:space="preserve">
          <source>Flip an array vertically (axis=0).</source>
          <target state="translated">垂直翻转一个数组(轴=0)。</target>
        </trans-unit>
        <trans-unit id="58f1196dc69384b1c0ff7122abf54115c6fe24e6" translate="yes" xml:space="preserve">
          <source>Flip an array vertically.</source>
          <target state="translated">垂直翻转一个阵列。</target>
        </trans-unit>
        <trans-unit id="054ba7b0cd3f0b3aa1e4b17f975a52c4e03f8b87" translate="yes" xml:space="preserve">
          <source>Flip array in the left/right direction.</source>
          <target state="translated">在左/右方向翻转阵列。</target>
        </trans-unit>
        <trans-unit id="a71aa214a7a981c7e5292f4c8603043e9a55d042" translate="yes" xml:space="preserve">
          <source>Flip array in the up/down direction.</source>
          <target state="translated">在上/下方向翻转阵列。</target>
        </trans-unit>
        <trans-unit id="d6b601389a5cfb7f115ef7332083ae3431e4e4e3" translate="yes" xml:space="preserve">
          <source>Flip the entries in each column in the up/down direction. Rows are preserved, but appear in a different order than before.</source>
          <target state="translated">按上/下方向翻转每列中的条目。行被保留,但显示顺序与之前不同。</target>
        </trans-unit>
        <trans-unit id="f14bb6de935d5a8cea7f1dc6e4323a38f4e11462" translate="yes" xml:space="preserve">
          <source>Flip the entries in each row in the left/right direction. Columns are preserved, but appear in a different order than before.</source>
          <target state="translated">将每行的条目向左/右方向翻转。列被保留,但出现的顺序与之前不同。</target>
        </trans-unit>
        <trans-unit id="a806413f7b898c72fd5e92970c2a0a0a31830c28" translate="yes" xml:space="preserve">
          <source>Float printing now uses &amp;ldquo;dragon4&amp;rdquo; algorithm for shortest decimal representation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7d4f9efa22847d513f86cb336f4d917bb3ff00" translate="yes" xml:space="preserve">
          <source>Float type code to coerce input array &lt;code&gt;a&lt;/code&gt;. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is one of the &amp;lsquo;int&amp;rsquo; dtypes, it is replaced with float64.</source>
          <target state="translated">浮点类型代码强制输入数组 &lt;code&gt;a&lt;/code&gt; 。如果&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;是&amp;ldquo;廉政&amp;rdquo; dtypes之一，它被替换为float64。</target>
        </trans-unit>
        <trans-unit id="01625a6e71519a2c19afcda12e2e9da94df799dc" translate="yes" xml:space="preserve">
          <source>Floating functions</source>
          <target state="translated">浮动功能</target>
        </trans-unit>
        <trans-unit id="0c47a1b436ef0cc135c28b0dd8fa381311e23c7a" translate="yes" xml:space="preserve">
          <source>Floating point</source>
          <target state="translated">浮点</target>
        </trans-unit>
        <trans-unit id="1229245ed91cf5c1f6662011b64e640e64679fd2" translate="yes" xml:space="preserve">
          <source>Floating point classification</source>
          <target state="translated">浮点分类</target>
        </trans-unit>
        <trans-unit id="82951541de1b33acb443a62a7f1b908de9e19ba0" translate="yes" xml:space="preserve">
          <source>Floating point error handling</source>
          <target state="translated">浮点错误处理</target>
        </trans-unit>
        <trans-unit id="dbe05d916add7aed11140c3ac753c505841f4681" translate="yes" xml:space="preserve">
          <source>Floating point number &lt;code&gt;beta**minexp&lt;/code&gt; (the smallest [in magnitude] usable floating value).</source>
          <target state="translated">浮点数 &lt;code&gt;beta**minexp&lt;/code&gt; （可用的最小浮点值）。</target>
        </trans-unit>
        <trans-unit id="1fd86bfd9f81a559ed8b4c9674c5d1f9e823b143" translate="yes" xml:space="preserve">
          <source>Floating point precision can be set:</source>
          <target state="translated">可设置浮点精度。</target>
        </trans-unit>
        <trans-unit id="481d82b2ccb68e7d8e1fe5eda973bb77f53833f0" translate="yes" xml:space="preserve">
          <source>Floating point precision. Defaults to &lt;code&gt;numpy.get_printoptions()['precision']&lt;/code&gt;.</source>
          <target state="translated">浮点精度。默认为 &lt;code&gt;numpy.get_printoptions()['precision']&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6770ad9e8703a79e53fa3beb7d8e8f53215f921c" translate="yes" xml:space="preserve">
          <source>Floating point routines</source>
          <target state="translated">浮点程序</target>
        </trans-unit>
        <trans-unit id="a8d35036268d7e5fa8b38b4abd4d049aeafa51d6" translate="yes" xml:space="preserve">
          <source>Floating point scalars implement &lt;code&gt;as_integer_ratio&lt;/code&gt; to match the builtin float</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb20a81d8b5780d9de2483bc5cafd120d0cd965" translate="yes" xml:space="preserve">
          <source>Floating point values are not demoted to integers, and complex values are not demoted to floats.</source>
          <target state="translated">浮点值不降级为整数,复数值不降级为浮点数。</target>
        </trans-unit>
        <trans-unit id="2a6aa48e3a6c80756547c7551fe79b07bb4f3a1c" translate="yes" xml:space="preserve">
          <source>Floating values between -1 and 1. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">浮点值介于-1和1之间。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="e6f0281f3f5728d7cb1a3465fbf569e0196bf3cd" translate="yes" xml:space="preserve">
          <source>Floating-point number &lt;code&gt;beta**machep&lt;/code&gt; (floating point precision)</source>
          <target state="translated">浮点数 &lt;code&gt;beta**machep&lt;/code&gt; （浮点精度）</target>
        </trans-unit>
        <trans-unit id="f8899b4f72c4b482d21d27616c70625d6596dd90" translate="yes" xml:space="preserve">
          <source>Floating-point number &lt;code&gt;beta**negep&lt;/code&gt;.</source>
          <target state="translated">浮点数 &lt;code&gt;beta**negep&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2eae9dc4dc291f4562016bea57ea67a7a3b1f88f" translate="yes" xml:space="preserve">
          <source>Floating-point numbers:</source>
          <target state="translated">浮点数。</target>
        </trans-unit>
        <trans-unit id="55734ad7ec5ec7776c0a844d3df4e815b482074b" translate="yes" xml:space="preserve">
          <source>Floats uniformly distributed over &lt;code&gt;[0, 1)&lt;/code&gt;.</source>
          <target state="translated">浮点在 &lt;code&gt;[0, 1)&lt;/code&gt; 均匀分布。</target>
        </trans-unit>
        <trans-unit id="9c505c67e9b4dbb54495e1dc42c80f1a7a1c454f" translate="yes" xml:space="preserve">
          <source>Floor divide self by other in-place.</source>
          <target state="translated">楼层将自己除以其他原地。</target>
        </trans-unit>
        <trans-unit id="1ddc7d58e45f89f16199c2075dcd43275a50c059" translate="yes" xml:space="preserve">
          <source>Floor division, &amp;lsquo;//&amp;rsquo;, is the division operator for the polynomial classes, polynomials are treated like integers in this regard. For Python versions &amp;lt; 3.x the &amp;lsquo;/&amp;rsquo; operator maps to &amp;lsquo;//&amp;rsquo;, as it does for Python, for later versions the &amp;lsquo;/&amp;rsquo; will only work for division by scalars. At some point it will be deprecated:</source>
          <target state="translated">地板除法&amp;ldquo; //&amp;rdquo;是多项式类别的除法运算符，在这方面，多项式被视为整数。对于版本低于3.x的Python，&amp;ldquo; /&amp;rdquo;运算符映射为&amp;ldquo; //&amp;rdquo;，对于Python而言，对于更高版本，&amp;ldquo; /&amp;rdquo;仅适用于标量除法。在某些时候，它会被弃用：</target>
        </trans-unit>
        <trans-unit id="977e7ae24b1ce53baf0769e85a5d553c0c1ba1a9" translate="yes" xml:space="preserve">
          <source>Following each integration the result is &lt;em&gt;multiplied&lt;/em&gt; by &lt;code&gt;scl&lt;/code&gt; before the integration constant is added. (Default: 1)</source>
          <target state="translated">继每个积分结果&lt;em&gt;乘以&lt;/em&gt;通过 &lt;code&gt;scl&lt;/code&gt; 加入积分常数之前。（默认值：1）</target>
        </trans-unit>
        <trans-unit id="0edda5efdca0ba777ab89777b73ae8abb0ac8170" translate="yes" xml:space="preserve">
          <source>Following the header comes the array data. If the dtype contains Python objects (i.e. &lt;code&gt;dtype.hasobject is True&lt;/code&gt;), then the data is a Python pickle of the array. Otherwise the data is the contiguous (either C- or Fortran-, depending on &lt;code&gt;fortran_order&lt;/code&gt;) bytes of the array. Consumers can figure out the number of bytes by multiplying the number of elements given by the shape (noting that &lt;code&gt;shape=()&lt;/code&gt; means there is 1 element) by &lt;code&gt;dtype.itemsize&lt;/code&gt;.</source>
          <target state="translated">头之后是数组数据。如果 &lt;code&gt;dtype.hasobject is True&lt;/code&gt; 包含Python对象（即dtype.hasobject为True），则数据为数组的Python泡菜。否则，数据是数组的连续字节（C或Fortran-，取决于 &lt;code&gt;fortran_order&lt;/code&gt; ）。消费者可以通过将形状给定的元素数量乘以 &lt;code&gt;dtype.itemsize&lt;/code&gt; 来计算字节数（注意 &lt;code&gt;shape=()&lt;/code&gt; 表示有1个元素）。</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="1e3737ce90be5e40d3542337b2a16d0ddfea15fe" translate="yes" xml:space="preserve">
          <source>For 18 of the 21 types this number is fixed by the data-type. For the flexible data-types, this number can be anything.</source>
          <target state="translated">对于21种类型中的18种,这个数字由数据类型固定。对于灵活的数据类型,这个数字可以是任何东西。</target>
        </trans-unit>
        <trans-unit id="6fe31cdcb6c6646809088d5903655d52a55d450e" translate="yes" xml:space="preserve">
          <source>For 2-D arrays it is the matrix product:</source>
          <target state="translated">对于二维数组来说,它是矩阵积。</target>
        </trans-unit>
        <trans-unit id="3f962aedbf83ef9d65d44b9e69490919cc79f9a0" translate="yes" xml:space="preserve">
          <source>For 2-D mixed with 1-D, the result is the usual.</source>
          <target state="translated">对于二维与一维的混合,结果是通常的。</target>
        </trans-unit>
        <trans-unit id="249d7389fa64403ab6c1fc03103e6db107907e49" translate="yes" xml:space="preserve">
          <source>For 8-bit strings, this method is locale-dependent.</source>
          <target state="translated">对于8位的字符串,这个方法是依赖于本地的。</target>
        </trans-unit>
        <trans-unit id="e34d3054bfe352b99ce08082d1411334b317ca53" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; one-dimensional, this is equivalent to:</source>
          <target state="translated">对于 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 一维，这等效于：</target>
        </trans-unit>
        <trans-unit id="a6fa074fdf944e6525f90fb53e3868628cc3a171" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;a.view(some_dtype)&lt;/code&gt;, if &lt;code&gt;some_dtype&lt;/code&gt; has a different number of bytes per entry than the previous dtype (for example, converting a regular array to a structured array), then the behavior of the view cannot be predicted just from the superficial appearance of &lt;code&gt;a&lt;/code&gt; (shown by &lt;code&gt;print(a)&lt;/code&gt;). It also depends on exactly how &lt;code&gt;a&lt;/code&gt; is stored in memory. Therefore if &lt;code&gt;a&lt;/code&gt; is C-ordered versus fortran-ordered, versus defined as a slice or transpose, etc., the view may give different results.</source>
          <target state="translated">对于 &lt;code&gt;a.view(some_dtype)&lt;/code&gt; ，如果 &lt;code&gt;some_dtype&lt;/code&gt; 每个条目的字节数与以前的dtype不同（例如，将常规数组转换为结构化数组），则无法仅从表面外观预测视图的行为的 &lt;code&gt;a&lt;/code&gt; （通过示出 &lt;code&gt;print(a)&lt;/code&gt; ）。这也完全取决于 &lt;code&gt;a&lt;/code&gt; 在内存中的存储方式。因此，如果 &lt;code&gt;a&lt;/code&gt; 是C顺序相对于fortran顺序，相对于定义为切片或转置等，则视图可能会给出不同的结果。</target>
        </trans-unit>
        <trans-unit id="e46f2d6f5fe5e7ec999c5f95aef2596fb69e222c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;array&lt;/code&gt;, &lt;strong&gt;``*`` means element-wise multiplication&lt;/strong&gt;, while &lt;strong&gt;``@`` means matrix multiplication&lt;/strong&gt;; they have associated functions &lt;code&gt;multiply()&lt;/code&gt; and &lt;code&gt;dot()&lt;/code&gt;. (Before python 3.5, &lt;code&gt;@&lt;/code&gt; did not exist and one had to use &lt;code&gt;dot()&lt;/code&gt; for matrix multiplication).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3105b82282a4b74064eec805ba7d2c290a53d304" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;array&lt;/code&gt;, the &lt;strong&gt;vector shapes 1xN, Nx1, and N are all different things&lt;/strong&gt;. Operations like &lt;code&gt;A[:,1]&lt;/code&gt; return a one-dimensional array of shape N, not a two-dimensional array of shape Nx1. Transpose on a one-dimensional &lt;code&gt;array&lt;/code&gt; does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272593adff1434bde1d4cd33b0346e0c6d20e042" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;e, E&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; specifiers, the number of digits to print after the decimal point.</source>
          <target state="translated">对于 &lt;code&gt;e, E&lt;/code&gt; 和 &lt;code&gt;f&lt;/code&gt; 指示符，小数点后要打印的位数。</target>
        </trans-unit>
        <trans-unit id="a8b87fa4bee96c31297a2faf4474562d50259437" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt;, the maximum number of significant digits.</source>
          <target state="translated">对于 &lt;code&gt;g&lt;/code&gt; 和 &lt;code&gt;G&lt;/code&gt; ，最大有效位数。</target>
        </trans-unit>
        <trans-unit id="d98628f7394ff0daa3811e58311c01f9a29ca826" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;matrix&lt;/code&gt;, &lt;strong&gt;``*`` means matrix multiplication&lt;/strong&gt;, and for element-wise multiplication one has to use the &lt;code&gt;multiply()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637ce924b991228068be8a9a9fc01722cca48f39" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;matrix&lt;/code&gt;, &lt;strong&gt;one-dimensional arrays are always upconverted to 1xN or Nx1 matrices&lt;/strong&gt; (row or column vectors). &lt;code&gt;A[:,1]&lt;/code&gt; returns a two-dimensional matrix of shape Nx1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f16f572df2de5dbe71ab6b482a26aade3788153" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;s&lt;/code&gt;, the maximum number of characters.</source>
          <target state="translated">对于 &lt;code&gt;s&lt;/code&gt; ，最大字符数。</target>
        </trans-unit>
        <trans-unit id="99d20f637f3a6e1d55b90d0390d938da13e44f35" translate="yes" xml:space="preserve">
          <source>For C code, see the &lt;a href=&quot;style_guide#style-guide&quot;&gt;numpy-c-style-guide&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96de2b474663e4b27c100d387c234e173e9360ba" translate="yes" xml:space="preserve">
          <source>For NumPy &amp;gt;= 1.10.0 a view of &lt;code&gt;a&lt;/code&gt; is always returned. For earlier NumPy versions a view of &lt;code&gt;a&lt;/code&gt; is returned only if the order of the axes is changed, otherwise the input array is returned.</source>
          <target state="translated">对于NumPy的&amp;gt; = 1.10.0一个的视图 &lt;code&gt;a&lt;/code&gt; 总是返回。对于较早版本NumPy的的视图 &lt;code&gt;a&lt;/code&gt; ，如果轴的顺序被改变仅返回，否则返回输入数组。</target>
        </trans-unit>
        <trans-unit id="187181bc029dad6f61070b7f6592eecd79b97aa5" translate="yes" xml:space="preserve">
          <source>For NumPy &amp;gt;= 1.10.0, if &lt;code&gt;a&lt;/code&gt; is an ndarray, then a view of &lt;code&gt;a&lt;/code&gt; is returned; otherwise a new array is created. For earlier NumPy versions a view of &lt;code&gt;a&lt;/code&gt; is returned only if the order of the axes is changed, otherwise the input array is returned.</source>
          <target state="translated">对于NumPy的&amp;gt; = 1.10.0，如果 &lt;code&gt;a&lt;/code&gt; 是ndarray，然后的视图 &lt;code&gt;a&lt;/code&gt; 被返回; 否则，将创建一个新数组。对于较早版本NumPy的的视图 &lt;code&gt;a&lt;/code&gt; ，如果轴的顺序被改变仅返回，否则返回输入数组。</target>
        </trans-unit>
        <trans-unit id="54f70af9beed617bc137c199798e6f21c9093a8c" translate="yes" xml:space="preserve">
          <source>For Python, the preferred way of handling contiguous (or technically, &lt;em&gt;strided&lt;/em&gt;) blocks of homogeneous data is with NumPy, which provides full object-oriented access to multidimensial arrays of data. Therefore, the most logical Python interface for the &lt;code&gt;rms&lt;/code&gt; function would be (including doc string):</source>
          <target state="translated">对于Python，处理连续（或技术上为&lt;em&gt;跨步&lt;/em&gt;）同类数据块的首选方法是使用NumPy，它提供对多维数据数组的完全面向对象的访问。因此，用于 &lt;code&gt;rms&lt;/code&gt; 函数的最合乎逻辑的Python接口是（包括doc字符串）：</target>
        </trans-unit>
        <trans-unit id="55f9e5f045d92376c7d38dda0f2622f9b6352be6" translate="yes" xml:space="preserve">
          <source>For a 1-D array this has no effect, as a transposed vector is simply the same vector. To convert a 1-D array into a 2D column vector, an additional dimension must be added. &lt;code&gt;np.atleast2d(a).T&lt;/code&gt; achieves this, as does &lt;code&gt;a[:, np.newaxis]&lt;/code&gt;. For a 2-D array, this is a standard matrix transpose. For an n-D array, if axes are given, their order indicates how the axes are permuted (see Examples). If axes are not provided and &lt;code&gt;a.shape = (i[0], i[1], ... i[n-2], i[n-1])&lt;/code&gt;, then &lt;code&gt;a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])&lt;/code&gt;.</source>
          <target state="translated">对于一维数组，这没有任何作用，因为转置向量只是同一向量。要将一维数组转换为二维列向量，必须添加一个附加维。 &lt;code&gt;np.atleast2d(a).T&lt;/code&gt; 实现了这一点， &lt;code&gt;a[:, np.newaxis]&lt;/code&gt; 。对于二维阵列，这是标准矩阵转置。对于nD数组，如果指定了轴，则其顺序指示如何排列轴（请参见示例）。如果未提供轴并且 &lt;code&gt;a.shape = (i[0], i[1], ... i[n-2], i[n-1])&lt;/code&gt; ，则 &lt;code&gt;a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c37103fe1630ecb51bfbc7a903129e1d60dd7ed" translate="yes" xml:space="preserve">
          <source>For a 1D array, &lt;code&gt;a.tolist()&lt;/code&gt; is almost the same as &lt;code&gt;list(a)&lt;/code&gt;, except that &lt;code&gt;tolist&lt;/code&gt; changes numpy scalars to Python scalars:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f2a60e0b01b84231d8024aebcc5e084e0ba27d" translate="yes" xml:space="preserve">
          <source>For a 1D array, &lt;code&gt;a.tolist()&lt;/code&gt; is almost the same as &lt;code&gt;list(a)&lt;/code&gt;:</source>
          <target state="translated">对于一维数组， &lt;code&gt;a.tolist()&lt;/code&gt; 与 &lt;code&gt;list(a)&lt;/code&gt; 几乎相同：</target>
        </trans-unit>
        <trans-unit id="cf0f7c81098fcc87863f3be5d59395a987825914" translate="yes" xml:space="preserve">
          <source>For a complete discussion of creation methods for masked arrays please see section &lt;a href=&quot;#maskedarray-generic-constructing&quot;&gt;Constructing masked arrays&lt;/a&gt;.</source>
          <target state="translated">有关掩码数组的创建方法的完整讨论，请参见&amp;ldquo; &lt;a href=&quot;#maskedarray-generic-constructing&quot;&gt;构造掩码数组&amp;rdquo;&lt;/a&gt;一节。</target>
        </trans-unit>
        <trans-unit id="0bdfc3356f177e5d7773cb796069c781e6c3ff20" translate="yes" xml:space="preserve">
          <source>For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关 &lt;code&gt;.npy&lt;/code&gt; 格式的说明，请参见&lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="197692467968599b779c0574e1302cadc5d30a4f" translate="yes" xml:space="preserve">
          <source>For a full description of these options, see &lt;a href=&quot;numpy.set_printoptions#numpy.set_printoptions&quot;&gt;&lt;code&gt;set_printoptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关这些选项的完整说明，请参见&lt;a href=&quot;numpy.set_printoptions#numpy.set_printoptions&quot;&gt; &lt;code&gt;set_printoptions&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b040ed436e354a6dfab8e28023d68c6eed7a06c2" translate="yes" xml:space="preserve">
          <source>For a function that returns a 1D array, the number of dimensions in &lt;code&gt;outarr&lt;/code&gt; is the same as &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">对于返回一维数组的函数， &lt;code&gt;outarr&lt;/code&gt; 中的维数与 &lt;code&gt;arr&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="9409ae5300d15907687b38139959611e06963f16" translate="yes" xml:space="preserve">
          <source>For a function that returns a higher dimensional array, those dimensions are inserted in place of the &lt;code&gt;axis&lt;/code&gt; dimension.</source>
          <target state="translated">对于返回高维数组的函数，将插入这些维来代替 &lt;code&gt;axis&lt;/code&gt; 维。</target>
        </trans-unit>
        <trans-unit id="17b694669442e700bd635063d9a03b4ef4365eec" translate="yes" xml:space="preserve">
          <source>For a more detailed discussion, read on and follow the links at the bottom of this page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7adc015d596be980abdfb7f52ddd54b20d9ed4e4" translate="yes" xml:space="preserve">
          <source>For a multi-dimensional array, accumulate is applied along only one axis (axis zero by default; see Examples below) so repeated use is necessary if one wants to accumulate over multiple axes.</source>
          <target state="translated">对于一个多维数组,累加只沿着一个轴(默认是零轴,见下面的例子),所以如果想在多个轴上累加,就必须重复使用。</target>
        </trans-unit>
        <trans-unit id="4a70a58adc76a39cce5a267ab70438cf75b9572e" translate="yes" xml:space="preserve">
          <source>For a non-trivial signature, &lt;code&gt;dimensions&lt;/code&gt; will also contain the sizes of the core dimensions as well, starting at the second entry. Only one size is provided for each unique dimension name and the sizes are given according to the first occurrence of a dimension name in the signature.</source>
          <target state="translated">对于非平凡的签名， &lt;code&gt;dimensions&lt;/code&gt; 也将从第二个条目开始也包含核心尺寸的尺寸。每个唯一的尺寸名称仅提供一个尺寸，并且尺寸是根据签名中尺寸名称的首次出现给出的。</target>
        </trans-unit>
        <trans-unit id="8218bd5d7a6649aa63226e5b622d4b8efad4dc34" translate="yes" xml:space="preserve">
          <source>For a one-dimensional array, accumulate produces results equivalent to:</source>
          <target state="translated">对于一维数组,累加产生的结果等同于。</target>
        </trans-unit>
        <trans-unit id="0424b9224931152a35a50c93d8cc0ece880de71a" translate="yes" xml:space="preserve">
          <source>For a one-sided t-test, how far out in the distribution does the t statistic appear?</source>
          <target state="translated">对于单边t检验,t统计量出现在分布的多远处?</target>
        </trans-unit>
        <trans-unit id="3911c3b2407712ae47f85ee3fb1ac557138ff00b" translate="yes" xml:space="preserve">
          <source>For a possible future loop selector with a different signature.</source>
          <target state="translated">对于未来可能出现的具有不同签名的循环选择器。</target>
        </trans-unit>
        <trans-unit id="c991a419f14da45f93fac679b2b79a552dc6a583" translate="yes" xml:space="preserve">
          <source>For a simple example, consider taking the sum of all elements in an array.</source>
          <target state="translated">举个简单的例子,考虑取一个数组中所有元素的和。</target>
        </trans-unit>
        <trans-unit id="65b58d63b284139c1918d1c4f188a0cdc07b3bf2" translate="yes" xml:space="preserve">
          <source>For advanced assignments, there is in general no guarantee for the iteration order. This means that if an element is set more than once, it is not possible to predict the final result.</source>
          <target state="translated">对于高级赋值,一般来说,迭代顺序是没有保证的。这意味着,如果一个元素被设置了不止一次,就不可能预测最终结果。</target>
        </trans-unit>
        <trans-unit id="d08105fb315fdfa97977e494fc0f07ee6275d676" translate="yes" xml:space="preserve">
          <source>For all of these macros &lt;em&gt;arr&lt;/em&gt; must be an instance of a (subclass of) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;, but no checking is done.</source>
          <target state="translated">对于所有这些宏，&lt;em&gt;arr&lt;/em&gt;必须是&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;（的子类）的实例，但不进行检查。</target>
        </trans-unit>
        <trans-unit id="e1f0a94de943c1efcc57e0ced39bb6353a416723" translate="yes" xml:space="preserve">
          <source>For all of these macros &lt;em&gt;arr&lt;/em&gt; must be an instance of a (subclass of) &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c98e7efdd0450f6d403ff7e88bf2f5b1a932b5" translate="yes" xml:space="preserve">
          <source>For all-NaN slices or slices with zero degrees of freedom, NaN is returned and a &lt;code&gt;RuntimeWarning&lt;/code&gt; is raised.</source>
          <target state="translated">对于全NaN切片或自由度为零的切片，将返回NaN并引发 &lt;code&gt;RuntimeWarning&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b523336c8d394d1599c127fd9600cfe28ac8e406" translate="yes" xml:space="preserve">
          <source>For all-NaN slices, NaN is returned and a &lt;code&gt;RuntimeWarning&lt;/code&gt; is raised.</source>
          <target state="translated">对于所有NaN片，将返回NaN并引发 &lt;code&gt;RuntimeWarning&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdcb9c3fa272c68c7dc5e676247f2291a44c1673" translate="yes" xml:space="preserve">
          <source>For an accompanying example, see &lt;a href=&quot;#example&quot;&gt;example.py&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f544bc19358af783f5828a5e5053cd2cf057f05c" translate="yes" xml:space="preserve">
          <source>For an array &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt;, the diagonal is the list of locations with indices &lt;code&gt;a[i, ..., i]&lt;/code&gt; all identical. This function modifies the input array in-place, it does not return a value.</source>
          <target state="translated">用于阵列 &lt;code&gt;a&lt;/code&gt; 与 &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; ，对角是与索引位置列表 &lt;code&gt;a[i, ..., i]&lt;/code&gt; 全部相同。此函数就地修改输入数组，但不返回值。</target>
        </trans-unit>
        <trans-unit id="3aca4d8fb9611bde95449f6380639b52b005e231" translate="yes" xml:space="preserve">
          <source>For an array a with two axes, transpose(a) gives the matrix transpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="836b756b5d814f029c077f0578ba6c0e58a3c672" translate="yes" xml:space="preserve">
          <source>For an array with rank greater than 1, some of the padding of later axes is calculated from padding of previous axes. This is easiest to think about with a rank 2 array where the corners of the padded array are calculated by using padded values from the first axis.</source>
          <target state="translated">对于一个等级大于1的数组,后面轴的一些填充是由前面轴的填充计算的。这对于一个等级为2的数组来说是最容易想到的,在这个数组中,填充数组的角是通过使用第一个轴的填充值来计算的。</target>
        </trans-unit>
        <trans-unit id="6e96c6b0d98bc68cbd820a41e54b4b8abe37a921" translate="yes" xml:space="preserve">
          <source>For an even number of input points, &lt;code&gt;A[n//2]&lt;/code&gt; represents the sum of the values at the positive and negative Nyquist frequencies, as the two are aliased together. See &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">对于偶数个输入点， &lt;code&gt;A[n//2]&lt;/code&gt; 代表正和负奈奎斯特频率下的值之和，因为两者是混叠的。有关详细信息，请参见&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="57743d92673c43f581b946774bebcebd154a8f73" translate="yes" xml:space="preserve">
          <source>For an example, see &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt;&lt;code&gt;Arrayterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关示例，请参见&lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt; &lt;code&gt;Arrayterator&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c782854d522cc47b6ef0aa24c79c91b4278be4a" translate="yes" xml:space="preserve">
          <source>For an optional array argument, all its dimensions must be bounded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe48c8702effa07c62fb464257e567d9ddc8002" translate="yes" xml:space="preserve">
          <source>For any index combination, including slicing and axis insertion, &lt;code&gt;a[indices]&lt;/code&gt; is the same as &lt;code&gt;a[np.index_exp[indices]]&lt;/code&gt; for any array &lt;code&gt;a&lt;/code&gt;. However, &lt;code&gt;np.index_exp[indices]&lt;/code&gt; can be used anywhere in Python code and returns a tuple of slice objects that can be used in the construction of complex index expressions.</source>
          <target state="translated">对于任何索引组合（包括切片和轴插入）， &lt;code&gt;a[indices]&lt;/code&gt; 与任何数组 &lt;code&gt;a&lt;/code&gt; 的 &lt;code&gt;a[np.index_exp[indices]]&lt;/code&gt; 相同。但是， &lt;code&gt;np.index_exp[indices]&lt;/code&gt; 可以在Python代码中的任何地方使用，并返回一个切片对象的元组，可用于构造复杂的索引表达式。</target>
        </trans-unit>
        <trans-unit id="befc2c9b3e9174a0e95946cae12589b779a18421" translate="yes" xml:space="preserve">
          <source>For array methods that take an &lt;code&gt;axis&lt;/code&gt; keyword, it defaults to None. If axis is None, then the array is treated as a 1-D array. Any other value for &lt;code&gt;axis&lt;/code&gt; represents the dimension along which the operation should proceed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec5bdb26c08f7af1b31abb9fd2aadbeeef092f4f" translate="yes" xml:space="preserve">
          <source>For array methods that take an &lt;em&gt;axis&lt;/em&gt; keyword, it defaults to &lt;code&gt;None&lt;/code&gt;. If axis is &lt;em&gt;None&lt;/em&gt;, then the array is treated as a 1-D array. Any other value for &lt;em&gt;axis&lt;/em&gt; represents the dimension along which the operation should proceed.</source>
          <target state="translated">对于采用&lt;em&gt;axis&lt;/em&gt;关键字的数组方法，默认为 &lt;code&gt;None&lt;/code&gt; 。如果axis为&lt;em&gt;None&lt;/em&gt;，则将该数组视为一维数组。&lt;em&gt;轴的&lt;/em&gt;任何其他值都表示应该进行操作的尺寸。</target>
        </trans-unit>
        <trans-unit id="d57067c37de796c57ab86aba446833670680acd2" translate="yes" xml:space="preserve">
          <source>For array methods that take an &lt;em&gt;axis&lt;/em&gt; keyword, it defaults to &lt;em&gt;None&lt;/em&gt;. If axis is &lt;em&gt;None&lt;/em&gt;, then the array is treated as a 1-D array. Any other value for &lt;em&gt;axis&lt;/em&gt; represents the dimension along which the operation should proceed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcba10981a70013794c3901be17ecdedebc27a1a" translate="yes" xml:space="preserve">
          <source>For backward compatibility and as a standard &amp;ldquo;container &amp;ldquo;class, the UserArray from Numeric has been brought over to NumPy and named &lt;a href=&quot;generated/numpy.lib.user_array.container#numpy.lib.user_array.container&quot;&gt;&lt;code&gt;numpy.lib.user_array.container&lt;/code&gt;&lt;/a&gt; The container class is a Python class whose self.array attribute is an ndarray. Multiple inheritance is probably easier with numpy.lib.user_array.container than with the ndarray itself and so it is included by default. It is not documented here beyond mentioning its existence because you are encouraged to use the ndarray class directly if you can.</source>
          <target state="translated">为了向后兼容并作为标准的&amp;ldquo;容器&amp;rdquo;类，已将Numeric的UserArray转移到NumPy，并将其命名为&lt;a href=&quot;generated/numpy.lib.user_array.container#numpy.lib.user_array.container&quot;&gt; &lt;code&gt;numpy.lib.user_array.container&lt;/code&gt; &lt;/a&gt;。容器类是Python类，其self.array属性是ndarray。使用numpy.lib.user_array.container可能比使用ndarray本身更容易进行多重继承，因此默认情况下将其包括在内。这里没有提及它的存在，因此没有记录在文档中，因为如果可以的话，建议您直接使用ndarray类。</target>
        </trans-unit>
        <trans-unit id="1756e23a025872fd532e8ba6c08bb9a4085acd5e" translate="yes" xml:space="preserve">
          <source>For backward compatibility with Python 2 the &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; typestrings remain zero-terminated bytes and &lt;code&gt;np.string_&lt;/code&gt; continues to map to &lt;code&gt;np.bytes_&lt;/code&gt;. To use actual strings in Python 3 use &lt;code&gt;U&lt;/code&gt; or &lt;code&gt;np.unicode_&lt;/code&gt;. For signed bytes that do not need zero-termination &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;i1&lt;/code&gt; can be used.</source>
          <target state="translated">对于与Python 2的向后兼容性 &lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;a&lt;/code&gt; typestrings保持零结尾字节和 &lt;code&gt;np.string_&lt;/code&gt; 继续映射到 &lt;code&gt;np.bytes_&lt;/code&gt; 。要在Python 3中使用实际的字符串，请使用 &lt;code&gt;U&lt;/code&gt; 或 &lt;code&gt;np.unicode_&lt;/code&gt; 。对于不需要零终止的带符号字节，可以使用 &lt;code&gt;b&lt;/code&gt; 或 &lt;code&gt;i1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f4c86851229c177d560fbdf1b8fb4dd2c3ff306" translate="yes" xml:space="preserve">
          <source>For backward compatible legacy reasons, we cannot change this. See &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77dfb74768b5914a720e322bd9c4f4d3188beb4" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, datetime64 still parses timezone offsets, which it handles by converting to UTC. However, the resulting datetime is timezone naive:</source>
          <target state="translated">为了向后兼容,datetime64仍然解析时区偏移,它通过转换为UTC来处理。然而,生成的日期时间是时区的。</target>
        </trans-unit>
        <trans-unit id="1c64f15e60882d9539499a036901b91bc24bc19f" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, the form (str, array of 624 uints, int) is also accepted although it is missing some information about the cached Gaussian value: &lt;code&gt;state = ('MT19937', keys, pos)&lt;/code&gt;.</source>
          <target state="translated">为了向后兼容，尽管缺少有关缓存的高斯值的某些信息： &lt;code&gt;state = ('MT19937', keys, pos)&lt;/code&gt; 也可以接受格式（str，624 uints，int数组）。</target>
        </trans-unit>
        <trans-unit id="4eb2208bc27c7545536cb93635c9264ced09a6ad" translate="yes" xml:space="preserve">
          <source>For bandlimited interpolation of discrete-time signals, the ideal interpolation kernel is proportional to the sinc function.</source>
          <target state="translated">对于离散时间信号的带限插值,理想的插值核与sinc函数成正比。</target>
        </trans-unit>
        <trans-unit id="0640d05a7ef317b56adcd70bde409c84daf4b12d" translate="yes" xml:space="preserve">
          <source>For buffered loops, care must be taken to copy and cast data before the loop function is called because the underlying loop expects aligned data of the correct data-type (including byte-order). The buffered loop must handle this copying and casting prior to calling the loop function on chunks no greater than the user-specified bufsize.</source>
          <target state="translated">对于缓冲循环,在调用循环函数之前,必须注意复制和转换数据,因为底层循环需要正确数据类型(包括字节顺序)的对齐数据。缓冲循环必须在调用循环函数之前处理好数据的复制和投射,其块数不能大于用户指定的bufsize。</target>
        </trans-unit>
        <trans-unit id="cb4713bd95be47f513cc79d1a6764009b9a70f10" translate="yes" xml:space="preserve">
          <source>For building NumPy, you&amp;rsquo;ll need a recent version of Cython.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ea569e34a0a0f36b8d0d5224e34f847b3cf085" translate="yes" xml:space="preserve">
          <source>For clarity it is useful to provide some examples of the type description and corresponding &lt;a href=&quot;#__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt; &amp;lsquo;descr&amp;rsquo; entries. Thanks to Scott Gilbert for these examples:</source>
          <target state="translated">为了清楚起见，提供一些类型描述示例和相应的&lt;a href=&quot;#__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; &lt;/a&gt; 'descr'条目非常有用。感谢Scott Gilbert提供了以下示例：</target>
        </trans-unit>
        <trans-unit id="cf57e9a465ef336bb9e191a7bcc71c622dd7e36c" translate="yes" xml:space="preserve">
          <source>For clearly intentional breaches, report those to the Code of Conduct committee (see below). For possibly unintentional breaches, you may reply to the person and point out this code of conduct (either in public or in private, whatever is most appropriate). If you would prefer not to do that, please feel free to report to the Code of Conduct Committee directly, or ask the Committee for advice, in confidence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79e4e860ac02f7665b97a2330e074b2889f9891" translate="yes" xml:space="preserve">
          <source>For comparison and general edification of the reader we provide a simple implementation of a C extension of logit that uses no numpy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d52548b7d82f8c08562b9cefe270c672ec6067" translate="yes" xml:space="preserve">
          <source>For comparison with the other methods to be discussed. Here is another example of a function that filters a two-dimensional array of double precision floating-point numbers using a fixed averaging filter. The advantage of using Fortran to index into multi-dimensional arrays should be clear from this example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aefcdcec95bb0a9f49c3ea43d81c147b480f4a1a" translate="yes" xml:space="preserve">
          <source>For complete documentation of the types of floating-point exceptions and treatment options, see &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关浮点异常类型和处理选项的完整文档，请参见&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6638e7aa649639c70b61a262d3fcb528e530dcc" translate="yes" xml:space="preserve">
          <source>For completeness, we&amp;rsquo;ll also add the &amp;lsquo;external_loop&amp;rsquo; and &amp;lsquo;buffered&amp;rsquo; flags, as these are what you will typically want for performance reasons.</source>
          <target state="translated">为了完整起见，我们还将添加&amp;ldquo; external_loop&amp;rdquo;和&amp;ldquo; buffered&amp;rdquo;标志，因为出于性能原因通常需要这些标志。</target>
        </trans-unit>
        <trans-unit id="823eefe35591ae1ef0928dcf4115410e8d28b81a" translate="yes" xml:space="preserve">
          <source>For complex arguments, &lt;code&gt;x = a + ib&lt;/code&gt;, we can write</source>
          <target state="translated">对于复杂的参数 &lt;code&gt;x = a + ib&lt;/code&gt; ，我们可以写</target>
        </trans-unit>
        <trans-unit id="00d19b01697a76f9042f9abe787cb066622b4409" translate="yes" xml:space="preserve">
          <source>For complex dtypes, the above is applied to each of the real and imaginary components of &lt;code&gt;x&lt;/code&gt; separately.</source>
          <target state="translated">对于复杂的dtype，以上内容分别应用于 &lt;code&gt;x&lt;/code&gt; 的每个实部和虚部。</target>
        </trans-unit>
        <trans-unit id="7aabc240767fa8c38770aded9994dbfb9309fc85" translate="yes" xml:space="preserve">
          <source>For complex inputs, the &lt;a href=&quot;#numpy.sign&quot;&gt;&lt;code&gt;sign&lt;/code&gt;&lt;/a&gt; function returns &lt;code&gt;sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j&lt;/code&gt;.</source>
          <target state="translated">对于复杂输入， &lt;code&gt;sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j&lt;/code&gt; ，则&lt;a href=&quot;#numpy.sign&quot;&gt; &lt;code&gt;sign&lt;/code&gt; &lt;/a&gt;函数返回sign（x.real）+ 0j，否则sign（x.imag）+ 0j。</target>
        </trans-unit>
        <trans-unit id="37a57514466afa09fc7538317ff0a405ada2d56e" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arccos&quot;&gt;&lt;code&gt;arccos&lt;/code&gt;&lt;/a&gt; is a complex analytic function that has branch cuts &lt;code&gt;[-inf, -1]&lt;/code&gt; and &lt;code&gt;[1, inf]&lt;/code&gt; and is continuous from above on the former and from below on the latter.</source>
          <target state="translated">对于复值输入，&lt;a href=&quot;#numpy.arccos&quot;&gt; &lt;code&gt;arccos&lt;/code&gt; &lt;/a&gt;是一个复杂的分析函数，具有分支切割 &lt;code&gt;[-inf, -1]&lt;/code&gt; 和 &lt;code&gt;[1, inf]&lt;/code&gt; 并且在前者上从上到下都是连续的。</target>
        </trans-unit>
        <trans-unit id="ff44215d073bf2342406439d430f9b3eb5cc308c" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arccosh&quot;&gt;&lt;code&gt;arccosh&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 1]&lt;/code&gt; and is continuous from above on it.</source>
          <target state="translated">对于复数值输入，&lt;a href=&quot;#numpy.arccosh&quot;&gt; &lt;code&gt;arccosh&lt;/code&gt; &lt;/a&gt;是一个复杂的分析函数，具有分支切割 &lt;code&gt;[-inf, 1]&lt;/code&gt; 并从上方连续。</target>
        </trans-unit>
        <trans-unit id="64f377fde8ecd4efebbb4d5831dcc8bc678877a9" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arcsin&quot;&gt;&lt;code&gt;arcsin&lt;/code&gt;&lt;/a&gt; is a complex analytic function that has, by convention, the branch cuts [-inf, -1] and [1, inf] and is continuous from above on the former and from below on the latter.</source>
          <target state="translated">对于复值输入，&lt;a href=&quot;#numpy.arcsin&quot;&gt; &lt;code&gt;arcsin&lt;/code&gt; &lt;/a&gt;是一个复杂的分析函数，按照惯例，该分支具有[-inf，-1]和[1，inf]分支，并且在前者上从上到下都是连续的。</target>
        </trans-unit>
        <trans-unit id="57038706eece9d133e1f92cf4c0e30653094f94f" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arctan&quot;&gt;&lt;code&gt;arctan&lt;/code&gt;&lt;/a&gt; is a complex analytic function that has [&lt;code&gt;1j, infj&lt;/code&gt;] and [&lt;code&gt;-1j, -infj&lt;/code&gt;] as branch cuts, and is continuous from the left on the former and from the right on the latter.</source>
          <target state="translated">对于复数值输入，&lt;a href=&quot;#numpy.arctan&quot;&gt; &lt;code&gt;arctan&lt;/code&gt; &lt;/a&gt;是一个复杂分析函数，具有[ &lt;code&gt;1j, infj&lt;/code&gt; ]和[ &lt;code&gt;-1j, -infj&lt;/code&gt; ]作为分支切口，并且从左开始在前者和从右开始在后者连续。</target>
        </trans-unit>
        <trans-unit id="4c701e0e2c7136fbf8b3d11659944481b8208402" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arctanh&quot;&gt;&lt;code&gt;arctanh&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has branch cuts &lt;code&gt;[-1, -inf]&lt;/code&gt; and &lt;code&gt;[1, inf]&lt;/code&gt; and is continuous from above on the former and from below on the latter.</source>
          <target state="translated">对于复数值输入，&lt;a href=&quot;#numpy.arctanh&quot;&gt; &lt;code&gt;arctanh&lt;/code&gt; &lt;/a&gt;是一个复杂的分析函数，具有分支切割 &lt;code&gt;[-1, -inf]&lt;/code&gt; 和 &lt;code&gt;[1, inf]&lt;/code&gt; 并且在前者上从上到下都是连续的。</target>
        </trans-unit>
        <trans-unit id="159e5638a9f1467d3dd2785cf39347fd2d548d9f" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 0]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">对于复数值输入，&lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt;是一个复杂的分析函数，具有分支剪切 &lt;code&gt;[-inf, 0]&lt;/code&gt; 并从上方连续。&lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt;将浮点负零作为无穷小负数处理，符合C99标准。</target>
        </trans-unit>
        <trans-unit id="5ba7031abf7f62c036d84ca3e657ff0bbe63c9b4" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 0]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">对于复数值输入，&lt;a href=&quot;#numpy.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt;是一个复杂的分析函数，具有分支剪切 &lt;code&gt;[-inf, 0]&lt;/code&gt; 并从上方连续。&lt;a href=&quot;#numpy.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt;将浮点负零作为无穷负数处理，符合C99标准。</target>
        </trans-unit>
        <trans-unit id="1d03218ffbd2a27086f21639f1e5d2c57e1fdb96" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, -1]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">对于复数值输入，&lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt;是一个复杂的分析函数，具有分支剪切 &lt;code&gt;[-inf, -1]&lt;/code&gt; 并从上方连续。&lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt;将浮点负零处理为无穷小负数，符合C99标准。</target>
        </trans-unit>
        <trans-unit id="714b21ba8fb7b3f93db097558f921f5a3cc7d7e7" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 0]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">对于复数值输入，&lt;a href=&quot;#numpy.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt;是一个复杂的分析函数，具有分支剪切 &lt;code&gt;[-inf, 0]&lt;/code&gt; 并从上方连续。&lt;a href=&quot;#numpy.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt;将浮点负零作为无穷小负数处理，符合C99标准。</target>
        </trans-unit>
        <trans-unit id="a557bc2da4dcaaf761d30f4619e8e0d4a2f4e8f4" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;numpy.arccos#numpy.arccos&quot;&gt;&lt;code&gt;arccos&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has branch cuts &lt;code&gt;[1j, infj]&lt;/code&gt; and &lt;code&gt;[-1j, -infj]&lt;/code&gt; and is continuous from the right on the former and from the left on the latter.</source>
          <target state="translated">对于复数值输入，&lt;a href=&quot;numpy.arccos#numpy.arccos&quot;&gt; &lt;code&gt;arccos&lt;/code&gt; &lt;/a&gt;是一个复杂的分析函数，具有分支切割 &lt;code&gt;[1j, infj]&lt;/code&gt; 和 &lt;code&gt;[-1j, -infj]&lt;/code&gt; 并且在右上连续，在左上连续。</target>
        </trans-unit>
        <trans-unit id="3c5f909f0d078490d8b615f107e16ec3bc3a188b" translate="yes" xml:space="preserve">
          <source>For computing the ULP difference, this API does not differentiate between various representations of NAN (ULP difference between 0x7fc00000 and 0xffc00000 is zero).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e81428e8e562739a6cb03d81d7a49ece97991e48" translate="yes" xml:space="preserve">
          <source>For consistency with histogram, an array of pre-computed bins is passed through unmodified:</source>
          <target state="translated">为了与直方图保持一致,一个预先计算的仓数组不加修改地通过。</target>
        </trans-unit>
        <trans-unit id="67034429080fa2a52e171f0ea36b0dba67f26dbe" translate="yes" xml:space="preserve">
          <source>For convenience and backward compatibility, a single &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s methods are imported into the numpy.random namespace, see &lt;a href=&quot;legacy#legacy&quot;&gt;Legacy Random Generation&lt;/a&gt; for the complete list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed4c585fafb6282979d170d7fc49312f2240470" translate="yes" xml:space="preserve">
          <source>For convenience and backward compatibility, a single &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s methods are imported into the numpy.random namespace, see &lt;a href=&quot;legacy#legacy&quot;&gt;Legacy Random Generation&lt;/a&gt; for the complete list.</source>
          <target state="translated">为了方便和向后兼容，将单个&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;实例的方法导入numpy.random命名空间，有关完整列表，请参见&lt;a href=&quot;legacy#legacy&quot;&gt;传统随机生成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d0d8cd3e47bac7d4c34c5ffeca248e53bd90070" translate="yes" xml:space="preserve">
          <source>For convenience, viewing an ndarray as type &lt;code&gt;np.recarray&lt;/code&gt; will automatically convert to &lt;code&gt;np.record&lt;/code&gt; datatype, so the dtype can be left out of the view:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d19661d614c330e3a9e7e16801d7b1d4abdea7" translate="yes" xml:space="preserve">
          <source>For data types that are always the same size (such as long), this holds the size of the data type. For flexible data types where different arrays can have a different elementsize, this should be 0.</source>
          <target state="translated">对于那些总是相同大小的数据类型(如long),这个值是数据类型的大小,对于灵活的数据类型,不同的数组可以有不同的元素大小,这个值应该是0。对于灵活的数据类型,不同的数组可以有不同的元素大小,这个值应该是0。</target>
        </trans-unit>
        <trans-unit id="88871b72e212455bd0a3305f24c658a9086cd65b" translate="yes" xml:space="preserve">
          <source>For data types that describe sub-arrays:</source>
          <target state="translated">对于描述子数组的数据类型。</target>
        </trans-unit>
        <trans-unit id="665e908efd043172f3a61d4025a859ec2c83aba8" translate="yes" xml:space="preserve">
          <source>For definition of the DFT and conventions used.</source>
          <target state="translated">对于DFT的定义和使用的惯例。</target>
        </trans-unit>
        <trans-unit id="ec4950c0b9d4572d83c373887e2dc02d9903faa1" translate="yes" xml:space="preserve">
          <source>For detailed info on testing, see &lt;a href=&quot;../dev/development_environment#testing-builds&quot;&gt;Testing builds&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb5f8bb3afe673736236ecca5864cdc9f7fc37e1" translate="yes" xml:space="preserve">
          <source>For developers of NumPy: do not instantiate this at the module level. The initial calculation of these parameters is expensive and negatively impacts import times. These objects are cached, so calling &lt;code&gt;finfo()&lt;/code&gt; repeatedly inside your functions is not a problem.</source>
          <target state="translated">对于NumPy的开发人员：不要在模块级别实例化此代码。这些参数的初始计算非常昂贵，并且会对导入时间产生负面影响。这些对象已缓存，因此在函数内重复调用 &lt;code&gt;finfo()&lt;/code&gt; 不会有问题。</target>
        </trans-unit>
        <trans-unit id="83549bc3ff37e9fd5f340310941a033ae7a10e48" translate="yes" xml:space="preserve">
          <source>For development, you can set up an in-place build so that changes made to &lt;code&gt;.py&lt;/code&gt; files have effect without rebuild. First, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c58f9c7b61fa3d8a2763dc4a797daee41cc03eb8" translate="yes" xml:space="preserve">
          <source>For each distinct core dimension, a set of &lt;code&gt;UFUNC_CORE_DIM*&lt;/code&gt; flags</source>
          <target state="translated">对于每个不同的核心维度，一组 &lt;code&gt;UFUNC_CORE_DIM*&lt;/code&gt; 标志</target>
        </trans-unit>
        <trans-unit id="396b05c439db2438a9382de672b6fa8e95c31893" translate="yes" xml:space="preserve">
          <source>For each distinct core dimension, the possible &lt;a href=&quot;c-api.generalized-ufuncs#frozen&quot;&gt;frozen&lt;/a&gt; size if &lt;code&gt;UFUNC_CORE_DIM_SIZE_INFERRED&lt;/code&gt; is 0</source>
          <target state="translated">对于每个不同的核心尺寸，如果 &lt;code&gt;UFUNC_CORE_DIM_SIZE_INFERRED&lt;/code&gt; 为0 ，则可能的&lt;a href=&quot;c-api.generalized-ufuncs#frozen&quot;&gt;冻结&lt;/a&gt;大小为0</target>
        </trans-unit>
        <trans-unit id="69d98b78325a9c10a5d66de529392752b9338931" translate="yes" xml:space="preserve">
          <source>For each distinct core dimension, the possible &lt;a href=&quot;generalized-ufuncs#frozen&quot;&gt;frozen&lt;/a&gt; size if &lt;code&gt;UFUNC_CORE_DIM_SIZE_INFERRED&lt;/code&gt; is 0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb98f2bacd6f2ddd2321b31d6e02518d57ef1a01" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy of the string where all characters occurring in the optional argument &lt;code&gt;deletechars&lt;/code&gt; are removed, and the remaining characters have been mapped through the given translation table.</source>
          <target state="translated">对于每一个元素 &lt;code&gt;a&lt;/code&gt; ，返回其中可选的参数中出现的所有字符的字符串拷贝 &lt;code&gt;deletechars&lt;/code&gt; 被删除，而剩余的字符已经通过给定的转换表映射。</target>
        </trans-unit>
        <trans-unit id="6fd82d55a1666ac371b70f835404bd2254f11112" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy of the string with all occurrences of substring &lt;code&gt;old&lt;/code&gt; replaced by &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">对于每一个元素 &lt;code&gt;a&lt;/code&gt; ，返回字符串的副本串中出现的所有 &lt;code&gt;old&lt;/code&gt; 换成 &lt;code&gt;new&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0072392849c4a29d135980cb1732127fb7c8293" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy with the leading and trailing characters removed.</source>
          <target state="translated">在每个元件 &lt;code&gt;a&lt;/code&gt; ，返回与该前缘和后字符的副本中删除。</target>
        </trans-unit>
        <trans-unit id="ce017fa2090bd21769500e23616f51df45b2cf16" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy with the leading characters removed.</source>
          <target state="translated">对于每一个元素 &lt;code&gt;a&lt;/code&gt; ，去除了主角返回副本。</target>
        </trans-unit>
        <trans-unit id="bcc8c5cf0a4ab8429da79ab635d524c5cd68a8b9" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy with the trailing characters removed.</source>
          <target state="translated">在每个元件 &lt;code&gt;a&lt;/code&gt; ，返回与除去尾部字符的副本。</target>
        </trans-unit>
        <trans-unit id="b48d2d67a82f24a073bc0fd48d1c7c812f1f1bea" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a list of the lines in the element, breaking at line boundaries.</source>
          <target state="translated">在每个元件 &lt;code&gt;a&lt;/code&gt; ，返回行的列表中的元素，在断裂线边界。</target>
        </trans-unit>
        <trans-unit id="d96129628d06f13e5afb8f18fe53cee0a045c865" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a list of the words in the string, using &lt;code&gt;sep&lt;/code&gt; as the delimiter string.</source>
          <target state="translated">在每个元件 &lt;code&gt;a&lt;/code&gt; ，返回的词的列表字符串中，使用 &lt;code&gt;sep&lt;/code&gt; 作为分隔符串。</target>
        </trans-unit>
        <trans-unit id="53321b75d28930691a06237aff36907b43cca790" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return the highest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found, such that &lt;code&gt;sub&lt;/code&gt; is contained within [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;].</source>
          <target state="translated">在每个元件 &lt;code&gt;a&lt;/code&gt; ，在字符串中返回指数最高，其中子串 &lt;code&gt;sub&lt;/code&gt; 被发现，使得 &lt;code&gt;sub&lt;/code&gt; 包含[内 &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e01fe9cacbc57867bf7b4b4ec2f69fefe5c4a037" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, split the element as the first occurrence of &lt;code&gt;sep&lt;/code&gt;, and return 3 strings containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return 3 strings containing the string itself, followed by two empty strings.</source>
          <target state="translated">在每个元件 &lt;code&gt;a&lt;/code&gt; ，分割元素作为第一次出现的 &lt;code&gt;sep&lt;/code&gt; ，和隔板，隔板本身，和隔板后的部分之前返回包含部分3个字符串。如果找不到分隔符，则返回3个包含字符串本身的字符串，然后返回两个空字符串。</target>
        </trans-unit>
        <trans-unit id="7288d8c0ac4641f453c7b03f986690cbb92d91ab" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, split the element as the last occurrence of &lt;code&gt;sep&lt;/code&gt;, and return 3 strings containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return 3 strings containing the string itself, followed by two empty strings.</source>
          <target state="translated">在每个元件 &lt;code&gt;a&lt;/code&gt; ，分割元素作为最后一次出现 &lt;code&gt;sep&lt;/code&gt; ，和隔板，隔板本身，和隔板后的部分之前返回包含部分3个字符串。如果找不到分隔符，则返回3个包含字符串本身的字符串，然后返回两个空字符串。</target>
        </trans-unit>
        <trans-unit id="b2be6980f0e55faed04690c7996e6d49756d7224" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return True if there are only decimal characters in the element.</source>
          <target state="translated">对于 &lt;code&gt;self&lt;/code&gt; 中的每个元素，如果元素中只有十进制字符，则返回True。</target>
        </trans-unit>
        <trans-unit id="b59ff6bcceb7225ac9cadb07484ec0465abb9c2a" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return True if there are only numeric characters in the element.</source>
          <target state="translated">对于 &lt;code&gt;self&lt;/code&gt; 中的每个元素，如果元素中仅包含数字字符，则返回True。</target>
        </trans-unit>
        <trans-unit id="9058afe727e5f02cb1c2a82daba2773477e47ab5" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy of the string where all characters occurring in the optional argument &lt;code&gt;deletechars&lt;/code&gt; are removed, and the remaining characters have been mapped through the given translation table.</source>
          <target state="translated">对于 &lt;code&gt;self&lt;/code&gt; 中的每个元素，返回字符串的副本，其中删除了在可选参数 &lt;code&gt;deletechars&lt;/code&gt; 中出现的所有字符，并且其余字符已通过给定的转换表进行映射。</target>
        </trans-unit>
        <trans-unit id="ef526a1c4bb908663ee9a7ed64b48415ce75d7c1" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy of the string with all occurrences of substring &lt;code&gt;old&lt;/code&gt; replaced by &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">对于每一个元素 &lt;code&gt;self&lt;/code&gt; ，返回字符串的副本串中出现的所有 &lt;code&gt;old&lt;/code&gt; 换成 &lt;code&gt;new&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e51c79c7e0159f28fc2312e8504acece61be2e0" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy of the string with uppercase characters converted to lowercase and vice versa.</source>
          <target state="translated">对于 &lt;code&gt;self&lt;/code&gt; 中的每个元素，返回字符串的副本，将大写字符转换为小写，反之亦然。</target>
        </trans-unit>
        <trans-unit id="563e89160eca98fee13c4e654d4638943cb7ede0" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy with the leading and trailing characters removed.</source>
          <target state="translated">对于 &lt;code&gt;self&lt;/code&gt; 中的每个元素，返回一个删除前导和尾随字符的副本。</target>
        </trans-unit>
        <trans-unit id="a46f8951acf83f33ee77a16371dbcf5fcea54c99" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy with the leading characters removed.</source>
          <target state="translated">对于 &lt;code&gt;self&lt;/code&gt; 中的每个元素，返回一个删除了前导字符的副本。</target>
        </trans-unit>
        <trans-unit id="c528552cf6666391ba164c6c98e3136c037ac0d0" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy with the trailing characters removed.</source>
          <target state="translated">对于 &lt;code&gt;self&lt;/code&gt; 中的每个元素，返回一个删除了结尾字符的副本。</target>
        </trans-unit>
        <trans-unit id="f3c87a7be827172789e8630db0faa9be334e4260" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a list of the lines in the element, breaking at line boundaries.</source>
          <target state="translated">对于 &lt;code&gt;self&lt;/code&gt; 中的每个元素，返回该元素中的行的列表，并在行边界处中断。</target>
        </trans-unit>
        <trans-unit id="3ca0a78fe28a9ed4242353e9fcde6e632b8bffa9" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a list of the words in the string, using &lt;code&gt;sep&lt;/code&gt; as the delimiter string.</source>
          <target state="translated">对于 &lt;code&gt;self&lt;/code&gt; 中的每个元素，使用 &lt;code&gt;sep&lt;/code&gt; 作为分隔符字符串，返回字符串中单词的列表。</target>
        </trans-unit>
        <trans-unit id="41b923cc154e9a0efebee6038be59b5d66a9e904" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a titlecased version of the string: words start with uppercase characters, all remaining cased characters are lowercase.</source>
          <target state="translated">对于 &lt;code&gt;self&lt;/code&gt; 中的每个元素，返回字符串的带标题大写的版本：单词以大写字母开头，所有其余的大写字母均为小写。</target>
        </trans-unit>
        <trans-unit id="a4fdbaa4039cefb583d1742ab7a44dc37da553da" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return the highest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found, such that &lt;code&gt;sub&lt;/code&gt; is contained within [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;].</source>
          <target state="translated">对于 &lt;code&gt;self&lt;/code&gt; 中的每个元素，返回在找到substring &lt;code&gt;sub&lt;/code&gt; 的字符串中的最高索引，这样 &lt;code&gt;sub&lt;/code&gt; 包含在[ &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt; ]中。</target>
        </trans-unit>
        <trans-unit id="66977f41b0aa64aabf235a79a75dcf6b6472f8b1" translate="yes" xml:space="preserve">
          <source>For each element, return True if there are only decimal characters in the element.</source>
          <target state="translated">对于每个元素,如果元素中只有十进制字符,则返回True。</target>
        </trans-unit>
        <trans-unit id="b1bf891f44f7ba1a69d9acfd1c67a586b04384f4" translate="yes" xml:space="preserve">
          <source>For each element, return True if there are only numeric characters in the element.</source>
          <target state="translated">对于每个元素,如果元素中只有数字字符,则返回True。</target>
        </trans-unit>
        <trans-unit id="de1f34aa0e69ee353932bddbc1b5178f2575078b" translate="yes" xml:space="preserve">
          <source>For each element, return the lowest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found, such that &lt;code&gt;sub&lt;/code&gt; is contained in the range [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;].</source>
          <target state="translated">对于每个元素，返回找到子字符串 &lt;code&gt;sub&lt;/code&gt; 的字符串中的最低索引，以使 &lt;code&gt;sub&lt;/code&gt; 包含在[ &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt; ] 范围内。</target>
        </trans-unit>
        <trans-unit id="2d0516f761ea835ae249621609400fab8f420640" translate="yes" xml:space="preserve">
          <source>For each element, return the lowest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found.</source>
          <target state="translated">对于每个元素，返回找到子字符串 &lt;code&gt;sub&lt;/code&gt; 的字符串中的最低索引。</target>
        </trans-unit>
        <trans-unit id="1a1da4bbdbc0f0985083d16493c494b0cdbca1db" translate="yes" xml:space="preserve">
          <source>For efficient memory alignment, &lt;code&gt;np.longdouble&lt;/code&gt; is usually stored padded with zero bits, either to 96 or 128 bits. Which is more efficient depends on hardware and development environment; typically on 32-bit systems they are padded to 96 bits, while on 64-bit systems they are typically padded to 128 bits. &lt;code&gt;np.longdouble&lt;/code&gt; is padded to the system default; &lt;code&gt;np.float96&lt;/code&gt; and &lt;code&gt;np.float128&lt;/code&gt; are provided for users who want specific padding. In spite of the names, &lt;code&gt;np.float96&lt;/code&gt; and &lt;code&gt;np.float128&lt;/code&gt; provide only as much precision as &lt;code&gt;np.longdouble&lt;/code&gt;, that is, 80 bits on most x86 machines and 64 bits in standard Windows builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42afabee0f54dc6a738be8285f1c8adb1a389c2c" translate="yes" xml:space="preserve">
          <source>For events with an expected separation</source>
          <target state="translated">对于预期离职的事件</target>
        </trans-unit>
        <trans-unit id="69f5ea3c2094e2e0d29f615dbd5f1be3db9e9635" translate="yes" xml:space="preserve">
          <source>For example &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;slicing&lt;/a&gt; can produce views of the array:</source>
          <target state="translated">例如，&lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;切片&lt;/a&gt;可以产生数组的视图：</target>
        </trans-unit>
        <trans-unit id="6ba61c52342c8ca357f9b025f520786b1e36f952" translate="yes" xml:space="preserve">
          <source>For example suppose the source directory contains fun/foo.dat and fun/bar/car.dat:</source>
          <target state="translated">例如,假设源目录中包含fun/foo.dat和fun/bar/car.dat。</target>
        </trans-unit>
        <trans-unit id="1b62eba4a89119c28458eb16bfa619aca8aa8969" translate="yes" xml:space="preserve">
          <source>For example you might make a startup script that looks like this (Note: this is just an example, not a statement of &amp;ldquo;best practices&amp;rdquo;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290de80d5fc36b01dd67ceeb09359da7bf8e0291" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; has a state consisting of 624 &lt;code&gt;uint32&lt;/code&gt; integers. A naive way to take a 32-bit integer seed would be to just set the last element of the state to the 32-bit seed and leave the rest 0s. This is a valid state for &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt;, but not a good one. The Mersenne Twister algorithm &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html&quot;&gt;suffers if there are too many 0s&lt;/a&gt;. Similarly, two adjacent 32-bit integer seeds (i.e. &lt;code&gt;12345&lt;/code&gt; and &lt;code&gt;12346&lt;/code&gt;) would produce very similar streams.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c528a73750dc2b0ea8c9a4908a64744d7d47416a" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; has a state consisting of 624 &lt;code&gt;uint32&lt;/code&gt; integers. A naive way to take a 32-bit integer seed would be to just set the last element of the state to the 32-bit seed and leave the rest 0s. This is a valid state for &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt;, but not a good one. The Mersenne Twister algorithm &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html&quot;&gt;suffers if there are too many 0s&lt;/a&gt;. Similarly, two adjacent 32-bit integer seeds (i.e. &lt;code&gt;12345&lt;/code&gt; and &lt;code&gt;12346&lt;/code&gt;) would produce very similar streams.</source>
          <target state="translated">例如，&lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt;的状态由624个 &lt;code&gt;uint32&lt;/code&gt; 整数组成。一种简单的获取32位整数种子的方法是将状态的最后一个元素设置为32位种子，其余的保留为0。这是&lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt;的有效状态，但不是好状态。&lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html&quot;&gt;如果0太多，则&lt;/a&gt; Mersenne Twister算法会受苦。类似地，两个相邻的32位整数种子（即 &lt;code&gt;12345&lt;/code&gt; 和 &lt;code&gt;12346&lt;/code&gt; ）将产生非常相似的流。</target>
        </trans-unit>
        <trans-unit id="c92ea12ee3f0aa3697d45f7df6d6af24fc7fd6b1" translate="yes" xml:space="preserve">
          <source>For example, F2PY generates from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f8823abb19bf71600d2b51cdc69b652a8cdb6f" translate="yes" xml:space="preserve">
          <source>For example, I might be working on a computer with a little-endian CPU - such as an Intel Pentium, but I have loaded some data from a file written by a computer that is big-endian. Let&amp;rsquo;s say I have loaded 4 bytes from a file written by a Sun (big-endian) computer. I know that these 4 bytes represent two 16-bit integers. On a big-endian machine, a two-byte integer is stored with the Most Significant Byte (MSB) first, and then the Least Significant Byte (LSB). Thus the bytes are, in memory order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214075869a9c515ee07024b57bc4ea923a1819de" translate="yes" xml:space="preserve">
          <source>For example, a 2x2 array &lt;code&gt;A&lt;/code&gt; is Fortran-contiguous if its elements are stored in memory in the following order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8f7cf41730b21d0b9a823684d400d6bc79bd0dc" translate="yes" xml:space="preserve">
          <source>For example, a function &lt;code&gt;myrange(n)&lt;/code&gt; generated from the following signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32bc5e66732d4344162eb54fb50c625865f9eafb" translate="yes" xml:space="preserve">
          <source>For example, add.accumulate() is equivalent to np.cumsum().</source>
          <target state="translated">例如,add.accumulate()相当于np.cumsum()。</target>
        </trans-unit>
        <trans-unit id="9a8d227d278d37b6250f8f06b0e4ddba59ee6707" translate="yes" xml:space="preserve">
          <source>For example, add.reduce() is equivalent to sum().</source>
          <target state="translated">例如,add.reduce()相当于sum()。</target>
        </trans-unit>
        <trans-unit id="10dea8dee68a389bd052fd52669dfbae04bf6a1e" translate="yes" xml:space="preserve">
          <source>For example, calculating 3*a, where a is an array of 32-bit floats, intuitively should result in a 32-bit float output. If the 3 is a 32-bit integer, the NumPy rules indicate it can&amp;rsquo;t convert losslessly into a 32-bit float, so a 64-bit float should be the result type. By examining the value of the constant, &amp;lsquo;3&amp;rsquo;, we see that it fits in an 8-bit integer, which can be cast losslessly into the 32-bit float.</source>
          <target state="translated">例如，计算3 * a，其中a是32位浮点数的数组，直观上应该会得出32位浮点数的输出。如果3是32位整数，则NumPy规则表明它不能无损地转换为32位浮点数，因此结果类型应为64位浮点数。通过检查常数&amp;ldquo; 3&amp;rdquo;的值，我们看到它适合一个8位整数，可以无损地转换为32位浮点型。</target>
        </trans-unit>
        <trans-unit id="e896d341feb39ad2e94789a2fa3a61f98c1ab6de" translate="yes" xml:space="preserve">
          <source>For example, consider a ufunc with signature &lt;code&gt;(i,j),(i)-&amp;gt;()&lt;/code&gt;. In this case, &lt;code&gt;args&lt;/code&gt; will contain three pointers to the data of the input/output arrays &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;. Furthermore, &lt;code&gt;dimensions&lt;/code&gt; will be &lt;code&gt;[N, I, J]&lt;/code&gt; to define the size of &lt;code&gt;N&lt;/code&gt; of the loop and the sizes &lt;code&gt;I&lt;/code&gt; and &lt;code&gt;J&lt;/code&gt; for the core dimensions &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;. Finally, &lt;code&gt;steps&lt;/code&gt; will be &lt;code&gt;[a_N, b_N, c_N, a_i, a_j, b_i]&lt;/code&gt;, containing all necessary strides.</source>
          <target state="translated">例如，考虑签名为 &lt;code&gt;(i,j),(i)-&amp;gt;()&lt;/code&gt; 的ufunc 。在这种情况下， &lt;code&gt;args&lt;/code&gt; 将包含三个指向输入/输出数组 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;c&lt;/code&gt; 的数据的指针。此外， &lt;code&gt;dimensions&lt;/code&gt; 将是 &lt;code&gt;[N, I, J]&lt;/code&gt; 来定义大小 &lt;code&gt;N&lt;/code&gt; 循环和尺寸 &lt;code&gt;I&lt;/code&gt; 和 &lt;code&gt;J&lt;/code&gt; 用于芯尺寸 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 。最后， &lt;code&gt;steps&lt;/code&gt; 将是 &lt;code&gt;[a_N, b_N, c_N, a_i, a_j, b_i]&lt;/code&gt; ，其中包含所有必要的步幅。</target>
        </trans-unit>
        <trans-unit id="dcfa362f844d8235742ab06beea7b0f26a111d9a" translate="yes" xml:space="preserve">
          <source>For example, consider the following Python code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c761c5136870def0974489fd65a1f38ad92d78" translate="yes" xml:space="preserve">
          <source>For example, for functions like &lt;code&gt;log&lt;/code&gt; with branch cuts, the versions in this module provide the mathematically valid answers in the complex plane:</source>
          <target state="translated">例如，对于带分支切割的 &lt;code&gt;log&lt;/code&gt; 功能，此模块中的版本在复杂平面中提供数学上有效的答案：</target>
        </trans-unit>
        <trans-unit id="1ae012c1a0fdd5d83c39490663637fce0836fd8c" translate="yes" xml:space="preserve">
          <source>For example, here is a typical source generator function:</source>
          <target state="translated">例如,这里是一个典型的源发生器函数。</target>
        </trans-unit>
        <trans-unit id="5f16b11fb1616884a1f7f0284cf2a3ad3bd24f37" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;a&lt;/code&gt; is a 3x3 array:</source>
          <target state="translated">例如，如果 &lt;code&gt;a&lt;/code&gt; 是3x3数组：</target>
        </trans-unit>
        <trans-unit id="7e1eba6b832e945c1e4ddb165d50f426b3bfee26" translate="yes" xml:space="preserve">
          <source>For example, if an iterator was created with a single array as its input, and it was possible to rearrange all its axes and then collapse it into a single strided iteration, this would return a view that is a one-dimensional array.</source>
          <target state="translated">例如,如果以单个数组作为输入创建一个迭代器,并且可以重新排列它的所有轴,然后将其折叠成一个单一的跨步迭代,这将返回一个是一维数组的视图。</target>
        </trans-unit>
        <trans-unit id="a7f0071af46179382458b34ec09b89b95e091389" translate="yes" xml:space="preserve">
          <source>For example, if we choose</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff87dba0f6e77925be276fcef4c7c831b8ea504" translate="yes" xml:space="preserve">
          <source>For example, if we want to import only the first and the last columns, we can use &lt;code&gt;usecols=(0, -1)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3d9bd14f229a7eb91aaf840c6ac1f84467537b" translate="yes" xml:space="preserve">
          <source>For example, if you create this array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f1b7e404a82b7d866b4be0ca94013f93955314" translate="yes" xml:space="preserve">
          <source>For example, if you create this function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4336a303ad0f6a2b1bcee09892c8545dcc3ff9f" translate="yes" xml:space="preserve">
          <source>For example, if you start with this array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302f8b44862add9c44dd094ba5ef88c857733962" translate="yes" xml:space="preserve">
          <source>For example, if you want your sub-class or duck-type to be compatible with numpy&amp;rsquo;s &lt;code&gt;sum&lt;/code&gt; function, the method signature for this object&amp;rsquo;s &lt;code&gt;sum&lt;/code&gt; method should be the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b454223ff8bed8a9b0c67509f246c5fba091e9" translate="yes" xml:space="preserve">
          <source>For example, on a (typical linux x64 gcc) system, the numpy &lt;code&gt;complex64&lt;/code&gt; datatype is implemented as &lt;code&gt;struct { float real, imag; }&lt;/code&gt;. This has &amp;ldquo;true&amp;rdquo; alignment of 4 and &amp;ldquo;uint&amp;rdquo; alignment of 8 (equal to the true alignment of &lt;code&gt;uint64&lt;/code&gt;).</source>
          <target state="translated">例如，在一个（典型的Linux x64 gcc）系统上，numpy &lt;code&gt;complex64&lt;/code&gt; 数据类型被实现为 &lt;code&gt;struct { float real, imag; }&lt;/code&gt; 。这具有4的&amp;ldquo; true&amp;rdquo;对齐和8的&amp;ldquo; uint&amp;rdquo;对齐（等于 &lt;code&gt;uint64&lt;/code&gt; 的真实对齐）。</target>
        </trans-unit>
        <trans-unit id="4ae14922ef64a97a2775a05d3077ba74da55d933" translate="yes" xml:space="preserve">
          <source>For example, the coordinates of a point in 3D space &lt;code&gt;[1,&amp;nbsp;2,&amp;nbsp;1]&lt;/code&gt; has one axis. That axis has 3 elements in it, so we say it has a length of 3. In the example pictured below, the array has 2 axes. The first axis has a length of 2, the second axis has a length of 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a172b13cb31313d38b209503a58e68588770858e" translate="yes" xml:space="preserve">
          <source>For example, this is the mean square error formula (a central formula used in supervised machine learning models that deal with regression):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0368fcdf7406da31a66eddfd11e72598360ada41" translate="yes" xml:space="preserve">
          <source>For example, using a 2-D boolean array of shape (2,3) with four True elements to select rows from a 3-D array of shape (2,3,5) results in a 2-D result of shape (4,5):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b9b1c9d703092f2621c55a5b2cd1e1eddf85b5" translate="yes" xml:space="preserve">
          <source>For example, you can create an array from a regular Python list or tuple using the &lt;code&gt;array&lt;/code&gt; function. The type of the resulting array is deduced from the type of the elements in the sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fad2cb39c870a9de4b9e44ed99144a88481e6ec" translate="yes" xml:space="preserve">
          <source>For example, you can plot a 1D array like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390c0f644804c3940d2b75b4dff6f12c284b252d" translate="yes" xml:space="preserve">
          <source>For example, you may have an array like this one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d24b595e5b1e7c226dfee05c7297047fa32fe9c1" translate="yes" xml:space="preserve">
          <source>For example, you might well want to be able to shorten &lt;code&gt;git checkout&lt;/code&gt; to &lt;code&gt;git co&lt;/code&gt;. Or you may want to alias &lt;code&gt;git diff --color-words&lt;/code&gt; (which gives a nicely formatted output of the diff) to &lt;code&gt;git wdiff&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b82f8996b94b3076d2602f80a0b8a902b3a3586" translate="yes" xml:space="preserve">
          <source>For examples, see the various functions.</source>
          <target state="translated">例如,请看各种功能。</target>
        </trans-unit>
        <trans-unit id="13b2e9c534395e7c5f78b138c5b0b5d135b327e2" translate="yes" xml:space="preserve">
          <source>For finite values, isclose uses the following equation to test whether two floating point values are equivalent.</source>
          <target state="translated">对于有限值,isclose使用以下公式来测试两个浮点值是否相等。</target>
        </trans-unit>
        <trans-unit id="e9eda33d9c06cab528c6194c742df4404b1ba711" translate="yes" xml:space="preserve">
          <source>For fixed format Fortran codes, &lt;code&gt;&amp;lt;comment char&amp;gt;&lt;/code&gt; must be at the first column of a file, of course. For free format Fortran codes, F2PY directives can appear anywhere in a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62c0e35a11ece55b5adf0e9c849759b322d0ed9" translate="yes" xml:space="preserve">
          <source>For floating point arguments, the length of the result is &lt;code&gt;ceil((stop - start)/step)&lt;/code&gt;. Because of floating point overflow, this rule may result in the last element of &lt;code&gt;out&lt;/code&gt; being greater than &lt;code&gt;stop&lt;/code&gt;.</source>
          <target state="translated">对于浮点参数，结果的长度为 &lt;code&gt;ceil((stop - start)/step)&lt;/code&gt; 。由于浮点溢出，此规则可能导致 &lt;code&gt;out&lt;/code&gt; 的最后一个元素大于 &lt;code&gt;stop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9208c67472507d398cb8a93a13859f9ce375088" translate="yes" xml:space="preserve">
          <source>For floating point numbers the numerical precision of sum (and &lt;code&gt;np.add.reduce&lt;/code&gt;) is in general limited by directly adding each number individually to the result causing rounding errors in every step. However, often numpy will use a numerically better approach (partial pairwise summation) leading to improved precision in many use-cases. This improved precision is always provided when no &lt;code&gt;axis&lt;/code&gt; is given. When &lt;code&gt;axis&lt;/code&gt; is given, it will depend on which axis is summed. Technically, to provide the best speed possible, the improved precision is only used when the summation is along the fast axis in memory. Note that the exact precision may vary depending on other parameters. In contrast to NumPy, Python&amp;rsquo;s &lt;code&gt;math.fsum&lt;/code&gt; function uses a slower but more precise approach to summation. Especially when summing a large number of lower precision floating point numbers, such as &lt;code&gt;float32&lt;/code&gt;, numerical errors can become significant. In such cases it can be advisable to use &lt;code&gt;dtype=&amp;rdquo;float64&amp;rdquo;&lt;/code&gt; to use a higher precision for the output.</source>
          <target state="translated">对于浮点数，总和（和 &lt;code&gt;np.add.reduce&lt;/code&gt; ）的数值精度通常受到限制，方法是将每个数字直接直接加到结果中，从而在每个步骤中产生舍入误差。但是，通常numpy将使用数值上更好的方法（部分对和），从而在许多用例中提高精度。当没有 &lt;code&gt;axis&lt;/code&gt; 时，总是提供提高的精度。当 &lt;code&gt;axis&lt;/code&gt; 被给出的，这将取决于其轴线被求和。从技术上讲，为了提供可能的最佳速度，仅当累加沿内存中的快轴时才使用提高的精度。请注意，确切的精度可能会因其他参数而异。与NumPy相反，Python的 &lt;code&gt;math.fsum&lt;/code&gt; 函数使用较慢但更精确的求和方法。尤其是在对大量较低精度的浮点数求和时，例如 &lt;code&gt;float32&lt;/code&gt; ，数值误差会变得很明显。在这种情况下，建议使用 &lt;code&gt;dtype=&amp;rdquo;float64&amp;rdquo;&lt;/code&gt; 对输出使用更高的精度。</target>
        </trans-unit>
        <trans-unit id="f41c623cdcb4a0e7f4eb2e6a140ca19a3b6cef7a" translate="yes" xml:space="preserve">
          <source>For floating-point input, the &lt;em&gt;std&lt;/em&gt; is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for float32 (see example below). Specifying a higher-accuracy accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="translated">对于浮点输入，将使用与输入相同的精度来计算&lt;em&gt;std&lt;/em&gt;。根据输入数据，这可能导致结果不准确，尤其是对于float32（请参见下面的示例）。使用&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;关键字指定精度更高的累加器可以缓解此问题。</target>
        </trans-unit>
        <trans-unit id="effdce45ed2fe7c4c7447e7c5d6ed579806ca2bd" translate="yes" xml:space="preserve">
          <source>For floating-point input, the variance is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;code&gt;float32&lt;/code&gt; (see example below). Specifying a higher-accuracy accumulator using the &lt;code&gt;dtype&lt;/code&gt; keyword can alleviate this issue.</source>
          <target state="translated">对于浮点输入，使用与输入相同的精度来计算方差。根据输入数据，这可能导致结果不准确，尤其是对于 &lt;code&gt;float32&lt;/code&gt; （请参见下面的示例）。使用 &lt;code&gt;dtype&lt;/code&gt; 关键字指定精度更高的累加器可以缓解此问题。</target>
        </trans-unit>
        <trans-unit id="d9b2341f620f885d0f8ab294ce3abbf3b1a90c60" translate="yes" xml:space="preserve">
          <source>For full documentation, see &lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt;&lt;code&gt;numpy.searchsorted&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">有关完整文档，请参见&lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt; &lt;code&gt;numpy.searchsorted&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8407df90b73fe86cd7253f98195431a6f813b267" translate="yes" xml:space="preserve">
          <source>For further details, consult the numpy reference documentation on array indexing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c711733607bfc1bae041078b86f27ea8766c29" translate="yes" xml:space="preserve">
          <source>For further information, see &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt;&lt;code&gt;memmap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt; &lt;code&gt;memmap&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e11475a277ae3113deb33326346ecfc8620fa4bf" translate="yes" xml:space="preserve">
          <source>For general resources for learning &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; see &lt;a href=&quot;git_resources#git-resources&quot;&gt;Additional Git Resources&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e32d40cffc64e1d0297c17e549d89391273d13d" translate="yes" xml:space="preserve">
          <source>For help in printing, the following strings are defined as the correct format specifier in printf and related commands.</source>
          <target state="translated">为了帮助打印,以下字符串被定义为printf和相关命令中的正确格式指定符。</target>
        </trans-unit>
        <trans-unit id="489d6f9ad36355f45e025471f49df88064ca87ee" translate="yes" xml:space="preserve">
          <source>For higher dimensional arrays summing a single axis can be done with ellipsis:</source>
          <target state="translated">对于高维数组,单轴求和可以用省略号来完成。</target>
        </trans-unit>
        <trans-unit id="6a424dcac51ca8b201228fd393c244dbeb8c5216" translate="yes" xml:space="preserve">
          <source>For i in &lt;code&gt;range(len(indices))&lt;/code&gt;, &lt;a href=&quot;#numpy.ufunc.reduceat&quot;&gt;&lt;code&gt;reduceat&lt;/code&gt;&lt;/a&gt; computes &lt;code&gt;ufunc.reduce(a[indices[i]:indices[i+1]])&lt;/code&gt;, which becomes the i-th generalized &amp;ldquo;row&amp;rdquo; parallel to &lt;code&gt;axis&lt;/code&gt; in the final result (i.e., in a 2-D array, for example, if &lt;code&gt;axis = 0&lt;/code&gt;, it becomes the i-th row, but if &lt;code&gt;axis = 1&lt;/code&gt;, it becomes the i-th column). There are three exceptions to this:</source>
          <target state="translated">对于 &lt;code&gt;range(len(indices))&lt;/code&gt; i ，&lt;a href=&quot;#numpy.ufunc.reduceat&quot;&gt; &lt;code&gt;reduceat&lt;/code&gt; &lt;/a&gt;计算 &lt;code&gt;ufunc.reduce(a[indices[i]:indices[i+1]])&lt;/code&gt; ，它成为最终结果中与 &lt;code&gt;axis&lt;/code&gt; 平行的第i个广义&amp;ldquo;行&amp;rdquo; （例如，在二维数组中，如果 &lt;code&gt;axis = 0&lt;/code&gt; ，它将成为第i行，但是如果 &lt;code&gt;axis = 1&lt;/code&gt; ，它将成为第i行）。对此有三个例外：</target>
        </trans-unit>
        <trans-unit id="3e2d688963af310435591977ab9e45596586b894" translate="yes" xml:space="preserve">
          <source>For initializing an array &lt;code&gt;&amp;lt;array name&amp;gt;&lt;/code&gt;, F2PY generates a loop over all indices and dimensions that executes the following pseudo-statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f651225304ab9158ee3f9e677f8c577d092edf" translate="yes" xml:space="preserve">
          <source>For input arrays that are smaller than the specified buffer size, copies are made of all non-contiguous, mis-aligned, or out-of- byteorder arrays to ensure that for small arrays, a single loop is used. Then, array iterators are created for all the input arrays and the resulting collection of iterators is broadcast to a single shape.</source>
          <target state="translated">对于小于指定缓冲区大小的输入数组,会对所有不连续、错位、或超出字节顺序的数组进行复制,以确保对于小数组,只使用一个循环。然后,为所有的输入数组创建数组迭代器,并将产生的迭代器集合广播到一个形状。</target>
        </trans-unit>
        <trans-unit id="0c7b69e69466d27c81eb277802b5fd2ba93ef1f2" translate="yes" xml:space="preserve">
          <source>For instructions on building for source package, see &lt;a href=&quot;building&quot;&gt;Building from source&lt;/a&gt;. This information is useful mainly for advanced users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37dbe6dc0691b61b379d0a2afb8134a45871395a" translate="yes" xml:space="preserve">
          <source>For integer arguments with absolute value larger than 1 the result is always zero because of the way Python handles integer division. For integer zero the result is an overflow.</source>
          <target state="translated">对于绝对值大于 1 的整数参数,由于 Python 处理整数除法的方式,结果总是零。对于整数零,结果是溢出。</target>
        </trans-unit>
        <trans-unit id="117e2f99abde5ef34211f008976cf994cee261a9" translate="yes" xml:space="preserve">
          <source>For integer input the return values are floats.</source>
          <target state="translated">对于整数输入,返回值为浮动值。</target>
        </trans-unit>
        <trans-unit id="51f2302ae3afa42e90f16f1c35bbd2af61213570" translate="yes" xml:space="preserve">
          <source>For integer specifiers (eg. &lt;code&gt;d,i,o,x&lt;/code&gt;), the minimum number of digits.</source>
          <target state="translated">对于整数说明符（例如 &lt;code&gt;d,i,o,x&lt;/code&gt; ），最小位数。</target>
        </trans-unit>
        <trans-unit id="7401aba5507b33d4914d20070660b9faa95209c3" translate="yes" xml:space="preserve">
          <source>For integer types, exact equality is used, in the same way as &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt;&lt;code&gt;masked_equal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于整数类型，使用完全相等的方式，与&lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt; &lt;code&gt;masked_equal&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="1e54c6af26706ff283ff28256c72b54eb26fbc6b" translate="yes" xml:space="preserve">
          <source>For integers, the fill value will be different in general to the result of &lt;code&gt;masked_equal&lt;/code&gt;.</source>
          <target state="translated">对于整数，填充值通常将与 &lt;code&gt;masked_equal&lt;/code&gt; 的结果不同。</target>
        </trans-unit>
        <trans-unit id="7d049cee37488c14a6b5c65b1da77ab9e42f2daa" translate="yes" xml:space="preserve">
          <source>For matrices that are not square or that (for negative powers) cannot be inverted numerically.</source>
          <target state="translated">对于非正方形或(负数幂)不能进行数值反演的矩阵。</target>
        </trans-unit>
        <trans-unit id="582e5fdc5986730f5cfb2129f1c085cdd20f4ef0" translate="yes" xml:space="preserve">
          <source>For monotonically _increasing_ &lt;code&gt;bins&lt;/code&gt;, the following are equivalent:</source>
          <target state="translated">对于单调_increasing_ &lt;code&gt;bins&lt;/code&gt; ，以下是等效的：</target>
        </trans-unit>
        <trans-unit id="83fdf15871a7264e4f60e9ab78a977dea92e1a03" translate="yes" xml:space="preserve">
          <source>For more detailed documentation.</source>
          <target state="translated">对于更详细的文件。</target>
        </trans-unit>
        <trans-unit id="37ae37abcab4e25dbfe5d8b108d91993462a8cf5" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;numpy.random.mtrand.randomstate.set_state#numpy.random.mtrand.RandomState.set_state&quot;&gt;&lt;code&gt;set_state&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;numpy.random.mtrand.randomstate.set_state#numpy.random.mtrand.RandomState.set_state&quot;&gt; &lt;code&gt;set_state&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51a8eedb7d395c27948e4922d0fabc18aafcf5ff" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;numpy.random.set_state#numpy.random.set_state&quot;&gt;&lt;code&gt;set_state&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f7f38b00189236c28757faab4aba491a5544afa" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;code&gt;linalg.lstsq&lt;/code&gt;.</source>
          <target state="translated">有关更多详细信息，请参见 &lt;code&gt;linalg.lstsq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8a8f4e50fa887cbbddc19a83dfdf91655b33341" translate="yes" xml:space="preserve">
          <source>For more extensive information, see &lt;a href=&quot;../reference/testing#testing-guidelines&quot;&gt;Testing Guidelines&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95cf6089ff82991425d6efdc0504169843591543" translate="yes" xml:space="preserve">
          <source>For more help on this function please see section 1.8 (Keyword Parameters for Extension Functions) of the Extending and Embedding tutorial in the Python documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61db67fed17b10d2110b06ec89aa13d261ade260" translate="yes" xml:space="preserve">
          <source>For more information on dictionaries, read the &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f4a148b39366545cf97da19167eb00139c5efc" translate="yes" xml:space="preserve">
          <source>For more information on the qr factorization, see for example: &lt;a href=&quot;https://en.wikipedia.org/wiki/QR_factorization&quot;&gt;https://en.wikipedia.org/wiki/QR_factorization&lt;/a&gt;</source>
          <target state="translated">有关qr因式分解的更多信息，请参见例如：&lt;a href=&quot;https://en.wikipedia.org/wiki/QR_factorization&quot;&gt;https&lt;/a&gt; : //en.wikipedia.org/wiki/QR_factorization</target>
        </trans-unit>
        <trans-unit id="17921f717812e3320e8a7f42f4f17f79981316f9" translate="yes" xml:space="preserve">
          <source>For more information see:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3985651be63157e0b3fd0f006d48347a4d4ad484" translate="yes" xml:space="preserve">
          <source>For more information, a way to suppress the warning, and an example of &lt;a href=&quot;#numpy.RankWarning&quot;&gt;&lt;code&gt;RankWarning&lt;/code&gt;&lt;/a&gt; being issued, see &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt;，它提供了抑制警告的方法以及发出&lt;a href=&quot;#numpy.RankWarning&quot;&gt; &lt;code&gt;RankWarning&lt;/code&gt; &lt;/a&gt;的示例。</target>
        </trans-unit>
        <trans-unit id="8581f2666047bb23a92c8e690d1acad362013f23" translate="yes" xml:space="preserve">
          <source>For more information, read the section on lists in the &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python tutorial&lt;/a&gt;. For a mapping type (key-value), see &lt;em&gt;dictionary&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4cae020b6b04928ab8186f1d73c1c26eba4002" translate="yes" xml:space="preserve">
          <source>For more information, refer to the &lt;a href=&quot;../index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; module and examine the methods and attributes of an array.</source>
          <target state="translated">有关更多信息，请参考&lt;a href=&quot;../index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt;模块并检查数组的方法和属性。</target>
        </trans-unit>
        <trans-unit id="d0fe83d89b7a0207c98cafeb4a0d87c2838e97b1" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://docs.python.org/3/extending/building.html&quot;&gt;Building C and C++ Extensions&lt;/a&gt; Python documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1433baa3f08eec4628310de483f3180d604e64" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-push.html&quot;&gt;git push&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b974edc2834bd1e574341abd9ce885d0e7a2979b" translate="yes" xml:space="preserve">
          <source>For more information, see F2Py source code &lt;code&gt;numpy/f2py/capi_maps.py&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32b573b8f00ce30b3419ec834d75448d214948d" translate="yes" xml:space="preserve">
          <source>For negative numbers, if width is not given, a minus sign is added to the front. If width is given, the two&amp;rsquo;s complement of the number is returned, with respect to that width.</source>
          <target state="translated">对于负数，如果未指定宽度，则会在前面添加减号。如果给定宽度，则返回该宽度的数字的二进制补码。</target>
        </trans-unit>
        <trans-unit id="5fc06ff1428a67551e7039c42cd5b569afbb759c" translate="yes" xml:space="preserve">
          <source>For non-Hermitian normal matrices the SciPy function &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.schur.html#scipy.linalg.schur&quot;&gt;&lt;code&gt;scipy.linalg.schur&lt;/code&gt;&lt;/a&gt; is preferred because the matrix &lt;code&gt;v&lt;/code&gt; is guaranteed to be unitary, which is not the case when using &lt;a href=&quot;#numpy.linalg.eig&quot;&gt;&lt;code&gt;eig&lt;/code&gt;&lt;/a&gt;. The Schur factorization produces an upper triangular matrix rather than a diagonal matrix, but for normal matrices only the diagonal of the upper triangular matrix is needed, the rest is roundoff error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e6d9fefb02ae78e90327bf08c7741fd4d7aad3c" translate="yes" xml:space="preserve">
          <source>For one-dimensional arrays these notions coincide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2721282deb17b4500d92138a510cdb4754bcd3" translate="yes" xml:space="preserve">
          <source>For operations which are either not commutative or not associative, doing a reduction over multiple axes is not well-defined. The ufuncs do not currently raise an exception in this case, but will likely do so in the future.</source>
          <target state="translated">对于那些不是换算型的操作,或者不是关联型的操作,在多轴上做还原并没有很好的定义。ufuncs目前没有在这种情况下提出异常,但将来可能会这样做。</target>
        </trans-unit>
        <trans-unit id="cce08ac0d595dc1fc36977f113db0494cd013706" translate="yes" xml:space="preserve">
          <source>For other keyword-only arguments, see the &lt;a href=&quot;../ufuncs#ufuncs-kwargs&quot;&gt;ufunc docs&lt;/a&gt;.</source>
          <target state="translated">有关其他仅关键字的参数，请参见&lt;a href=&quot;../ufuncs#ufuncs-kwargs&quot;&gt;ufunc docs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c08ef249ec6e440d6a8f4e999cc7fb84e271c54" translate="yes" xml:space="preserve">
          <source>For our example, we&amp;rsquo;ll create a sum of squares function. To start, let&amp;rsquo;s implement this function in straightforward Python. We want to support an &amp;lsquo;axis&amp;rsquo; parameter similar to the numpy &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; function, so we will need to construct a list for the &lt;code&gt;op_axes&lt;/code&gt; parameter. Here&amp;rsquo;s how this looks.</source>
          <target state="translated">对于我们的示例，我们将创建平方和函数。首先，让我们在简单的Python中实现此功能。我们要支持类似于numpy &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;函数的'axis'参数，因此我们需要为 &lt;code&gt;op_axes&lt;/code&gt; 参数构造一个列表。这是它的外观。</target>
        </trans-unit>
        <trans-unit id="1bfec23fd3b5a8e4feecb9f5b43f562b252ee813" translate="yes" xml:space="preserve">
          <source>For paragraphs, indentation is significant and indicates indentation in the output. New paragraphs are marked with a blank line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e34004cd49470f698985ea088603e79d6737af" translate="yes" xml:space="preserve">
          <source>For pickling.</source>
          <target state="translated">用于腌制。</target>
        </trans-unit>
        <trans-unit id="45d056f2d6dc25af69ffd36f748681cb1b37bcb7" translate="yes" xml:space="preserve">
          <source>For positive integers &lt;code&gt;n&lt;/code&gt;, the power is computed by repeated matrix squarings and matrix multiplications. If &lt;code&gt;n == 0&lt;/code&gt;, the identity matrix of the same shape as M is returned. If &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, the inverse is computed and then raised to the &lt;code&gt;abs(n)&lt;/code&gt;.</source>
          <target state="translated">对于正整数 &lt;code&gt;n&lt;/code&gt; ，乘方是通过重复的矩阵平方和矩阵乘法来计算的。如果 &lt;code&gt;n == 0&lt;/code&gt; ，则返回与M形状相同的单位矩阵。如果 &lt;code&gt;n &amp;lt; 0&lt;/code&gt; ，则计算逆，然后提高到 &lt;code&gt;abs(n)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2868f608509a0fb880318bfa1ea537e24b697cca" translate="yes" xml:space="preserve">
          <source>For private use, NumPy also constructs a &lt;code&gt;config.h&lt;/code&gt; in the NumPy include directory, which is not exported by NumPy (that is a python extension which use the numpy C API will not see those symbols), to avoid namespace pollution.</source>
          <target state="translated">为了供私人使用，NumPy还在NumPy包含目录中构造了一个 &lt;code&gt;config.h&lt;/code&gt; ，该目录不是由NumPy导出的（这是使用numpy C API的python扩展将看不到那些符号），以避免命名空间污染。</target>
        </trans-unit>
        <trans-unit id="3cba0cef0ecc3bf15466cf0b613737ac43d7cf46" translate="yes" xml:space="preserve">
          <source>For random samples from</source>
          <target state="translated">对于随机样本,从</target>
        </trans-unit>
        <trans-unit id="3b14ea0275a3817032fbdd7fbc1e7bdb06b2af67" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arccos&quot;&gt;&lt;code&gt;arccos&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">对于实值输入数据类型，&lt;a href=&quot;#numpy.arccos&quot;&gt; &lt;code&gt;arccos&lt;/code&gt; &lt;/a&gt;始终返回实输出。对于每个不能表示为实数或无穷大的值，它将产生 &lt;code&gt;nan&lt;/code&gt; 并设置 &lt;code&gt;invalid&lt;/code&gt; 浮点错误标志。</target>
        </trans-unit>
        <trans-unit id="f985096374044eb3c8f423921e1ca43a25a0a64a" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arccosh&quot;&gt;&lt;code&gt;arccosh&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">对于实值输入数据类型，&lt;a href=&quot;#numpy.arccosh&quot;&gt; &lt;code&gt;arccosh&lt;/code&gt; &lt;/a&gt;始终返回实输出。对于每个不能表示为实数或无穷大的值，它将产生 &lt;code&gt;nan&lt;/code&gt; 并设置 &lt;code&gt;invalid&lt;/code&gt; 浮点错误标志。</target>
        </trans-unit>
        <trans-unit id="1bd6dae91050b378f422d64d0fd3d06caee7dc76" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arcsinh&quot;&gt;&lt;code&gt;arcsinh&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it returns &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">对于实值输入数据类型，&lt;a href=&quot;#numpy.arcsinh&quot;&gt; &lt;code&gt;arcsinh&lt;/code&gt; &lt;/a&gt;始终返回实输出。对于每个不能表示为实数或无穷大的值，它将返回 &lt;code&gt;nan&lt;/code&gt; 并设置 &lt;code&gt;invalid&lt;/code&gt; 浮点错误标志。</target>
        </trans-unit>
        <trans-unit id="f1a3e2a79ac88302cd49ced01b5ae36cb593f786" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arctan&quot;&gt;&lt;code&gt;arctan&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">对于实值输入数据类型，&lt;a href=&quot;#numpy.arctan&quot;&gt; &lt;code&gt;arctan&lt;/code&gt; &lt;/a&gt;始终返回实输出。对于每个不能表示为实数或无穷大的值，它将产生 &lt;code&gt;nan&lt;/code&gt; 并设置 &lt;code&gt;invalid&lt;/code&gt; 浮点错误标志。</target>
        </trans-unit>
        <trans-unit id="4e59a4a7e10620a1dcf06247438f5e136a0933eb" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arctanh&quot;&gt;&lt;code&gt;arctanh&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">对于实值输入数据类型，&lt;a href=&quot;#numpy.arctanh&quot;&gt; &lt;code&gt;arctanh&lt;/code&gt; &lt;/a&gt;始终返回实输出。对于每个不能表示为实数或无穷大的值，它将产生 &lt;code&gt;nan&lt;/code&gt; 并设置 &lt;code&gt;invalid&lt;/code&gt; 浮点错误标志。</target>
        </trans-unit>
        <trans-unit id="00463e3d9bf72a8660310a707c972e6c6b2f2a87" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">对于实值输入数据类型，&lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt;始终返回实输出。对于每个不能表示为实数或无穷大的值，它将产生 &lt;code&gt;nan&lt;/code&gt; 并设置 &lt;code&gt;invalid&lt;/code&gt; 浮点错误标志。</target>
        </trans-unit>
        <trans-unit id="1dd401d005377ef79add082427bec36bd76d7d40" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">对于实值输入数据类型，&lt;a href=&quot;#numpy.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt;始终返回实输出。对于每个不能表示为实数或无穷大的值，它将产生 &lt;code&gt;nan&lt;/code&gt; 并设置 &lt;code&gt;invalid&lt;/code&gt; 浮点错误标志。</target>
        </trans-unit>
        <trans-unit id="18c562bcbaf668e2b82c801663121e7d15eaaa37" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">对于实值输入数据类型，&lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt;始终返回实输出。对于每个不能表示为实数或无穷大的值，它将产生 &lt;code&gt;nan&lt;/code&gt; 并设置 &lt;code&gt;invalid&lt;/code&gt; 浮点错误标志。</target>
        </trans-unit>
        <trans-unit id="cb65926ba3df7c570cfbf88879b3b9d563294100" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">对于实值输入数据类型，&lt;a href=&quot;#numpy.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt;始终返回实输出。对于每个不能表示为实数或无穷大的值，它将产生 &lt;code&gt;nan&lt;/code&gt; 并设置 &lt;code&gt;invalid&lt;/code&gt; 浮点错误标志。</target>
        </trans-unit>
        <trans-unit id="5a691d6f039d37de2f424c2292fd24a2e8849ab5" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;em&gt;arcsin&lt;/em&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">对于实值输入数据类型，&lt;em&gt;arcsin&lt;/em&gt;始终返回实输出。对于每个不能表示为实数或无穷大的值，它将产生 &lt;code&gt;nan&lt;/code&gt; 并设置 &lt;code&gt;invalid&lt;/code&gt; 浮点错误标志。</target>
        </trans-unit>
        <trans-unit id="ac8dda629e47802177efe000a2d093f5e016a0cb" translate="yes" xml:space="preserve">
          <source>For real-valued input, &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; is accurate also for &lt;code&gt;x&lt;/code&gt; so small that &lt;code&gt;1 + x == 1&lt;/code&gt; in floating-point accuracy.</source>
          <target state="translated">对于实值输入，&lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;x&lt;/code&gt; 精度也非常小，以至于浮点精度为 &lt;code&gt;1 + x == 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8718e777159adb99e6030aa86f73aaa6419d14ea" translate="yes" xml:space="preserve">
          <source>For repeatability and readability, the dictionary keys are sorted in alphabetic order. This is for convenience only. A writer SHOULD implement this if possible. A reader MUST NOT depend on this.</source>
          <target state="translated">为了重复性和可读性,字典键按字母顺序排列。这只是为了方便。如果可能的话,作者应该实现这一点。读者一定不要依赖这个。</target>
        </trans-unit>
        <trans-unit id="6bd239911d468099089301c7ec88d5d1667469b6" translate="yes" xml:space="preserve">
          <source>For reshape, resize, and transpose, the single tuple argument may be replaced with &lt;code&gt;n&lt;/code&gt; integers which will be interpreted as an n-tuple.</source>
          <target state="translated">对于整形，调整大小和转置，可以用 &lt;code&gt;n&lt;/code&gt; 个整数替换单个元组参数，这将被解释为n个元组。</target>
        </trans-unit>
        <trans-unit id="6fe957d6ccb5cf28dddb483265ed8d862961930a" translate="yes" xml:space="preserve">
          <source>For scalar &lt;code&gt;a&lt;/code&gt;, returns the data type with the smallest size and smallest scalar kind which can hold its value.</source>
          <target state="translated">对于标量 &lt;code&gt;a&lt;/code&gt; ，返回可以保留其值的最小大小和最小标量类型的数据类型。</target>
        </trans-unit>
        <trans-unit id="22863dbfbfce9a1b2c0c06d8e441eed6ee432e4b" translate="yes" xml:space="preserve">
          <source>For scalar &lt;code&gt;a&lt;/code&gt;, returns the data type with the smallest size and smallest scalar kind which can hold its value. For non-scalar array &lt;code&gt;a&lt;/code&gt;, returns the vector&amp;rsquo;s dtype unmodified.</source>
          <target state="translated">对于标量 &lt;code&gt;a&lt;/code&gt; ，返回可以保留其值的最小大小和最小标量类型的数据类型。对于非标量数组 &lt;code&gt;a&lt;/code&gt; ，返回未经修改的向量的dtype。</target>
        </trans-unit>
        <trans-unit id="5642e4133974cc82494c6e2e1a04d4f6b4435c53" translate="yes" xml:space="preserve">
          <source>For several methods, an optional &lt;em&gt;out&lt;/em&gt; argument can also be provided and the result will be placed into the output array given. The &lt;em&gt;out&lt;/em&gt; argument must be an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and have the same number of elements. It can have a different data type in which case casting will be performed.</source>
          <target state="translated">对于几种方法，还可以提供可选的&lt;em&gt;out&lt;/em&gt;参数，并将结果放入给定的输出数组中。该&lt;em&gt;出&lt;/em&gt;参数必须是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;且具有相同数目的元素。它可以具有不同的数据类型，在这种情况下将执行强制转换。</target>
        </trans-unit>
        <trans-unit id="b0753b0fcbeca94ce7630240e047138c854a65dd" translate="yes" xml:space="preserve">
          <source>For signed integer inputs, the two&amp;rsquo;s complement is returned. In a two&amp;rsquo;s-complement system negative numbers are represented by the two&amp;rsquo;s complement of the absolute value. This is the most common method of representing signed integers on computers &lt;a href=&quot;#rde927b304c4f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. A N-bit two&amp;rsquo;s-complement system can represent every integer in the range</source>
          <target state="translated">对于有符号整数输入，将返回二进制补码。在二进制补码系统中，负数由绝对值的二进制补码表示。这是在计算机上表示有符号整数的最常见方法&lt;a href=&quot;#rde927b304c4f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。N位二进制补码系统可以表示范围内的每个整数</target>
        </trans-unit>
        <trans-unit id="8a7f873acfba66a72d1ce69253d776c71ca10e17" translate="yes" xml:space="preserve">
          <source>For simplicity we give a ufunc for a single dtype, the &amp;lsquo;f8&amp;rsquo; double. As in the previous section, we first give the .c file and then the setup.py file used to create the module containing the ufunc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1790f111eccdfcb9badd8e72bbfbae78adf5ee18" translate="yes" xml:space="preserve">
          <source>For standard library functions:</source>
          <target state="translated">对于标准库函数。</target>
        </trans-unit>
        <trans-unit id="e58c1a1b97b83acb57ac2ac307ed0d7c16b3baf7" translate="yes" xml:space="preserve">
          <source>For structured arrays, all fields are combined, with masked values ignored. The result is masked if all fields were masked, with self and other considered equal only if both were fully masked.</source>
          <target state="translated">对于结构化数组,所有的字段都被合并,而屏蔽的值被忽略。如果所有字段都被掩码,则结果被掩码,只有当self和other都被完全掩码时,才会被认为是相等的。</target>
        </trans-unit>
        <trans-unit id="60753f45a63d90af610aa65f98fdd4ce690bf30a" translate="yes" xml:space="preserve">
          <source>For structured datatypes with no fields this function now returns False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b403ec15e745ce9b0d408a4253b0a3db036c37" translate="yes" xml:space="preserve">
          <source>For structured types, a structured scalar is returned, with each field the default fill value for its type.</source>
          <target state="translated">对于结构化类型,返回一个结构化标量,每个字段都是其类型的默认填充值。</target>
        </trans-unit>
        <trans-unit id="7c0b7d9c35a991bbf7b4be3304607a91761fd2e6" translate="yes" xml:space="preserve">
          <source>For subarray types, the fill value is an array of the same size containing the default scalar fill value.</source>
          <target state="translated">对于子数组类型,填充值是一个包含默认标量填充值的相同大小的数组。</target>
        </trans-unit>
        <trans-unit id="fa1668cc4f1ad2127afa574513a965e4f8de0bd1" translate="yes" xml:space="preserve">
          <source>For tall matrices in NumPy version up to 1.6.2, the diagonal &amp;ldquo;wrapped&amp;rdquo; after N columns. You can have this behavior with this option. This affects only tall matrices.</source>
          <target state="translated">对于NumPy版本高达1.6.2的高矩阵，对角线在N列后&amp;ldquo;包裹&amp;rdquo;。使用此选项，您可以具有这种行为。这仅影响高矩阵。</target>
        </trans-unit>
        <trans-unit id="15797574f39fa9a94e6a6ba0f1322211577809c1" translate="yes" xml:space="preserve">
          <source>For tests with a result that is random or platform-dependent, mark the output as such:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571561584fb9de04ee089fbe39a5ff6d6bc01c7a" translate="yes" xml:space="preserve">
          <source>For the explicit constructor call, our subclass will need to create a new ndarray instance of its own class. In practice this means that we, the authors of the code, will need to make a call to &lt;code&gt;ndarray.__new__(MySubClass,...)&lt;/code&gt;, a class-hierarchy prepared call to &lt;code&gt;super(MySubClass, cls).__new__(cls, ...)&lt;/code&gt;, or do view casting of an existing array (see below)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e3d7bba1f8f57e3e3d0698a1673d2f7dbd0218" translate="yes" xml:space="preserve">
          <source>For the first run, we threw 3 times 1, 4 times 2, etc. For the second, we threw 2 times 1, 4 times 2, etc.</source>
          <target state="translated">第一次,我们投了3次1,4次2等。第二次,我们投了2次1,4次2,等等。</target>
        </trans-unit>
        <trans-unit id="72f9e5e8e38fa061436e99d12c2a915135e47ac9" translate="yes" xml:space="preserve">
          <source>For the following methods there are also corresponding functions in &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt;: &lt;a href=&quot;generated/numpy.all#numpy.all&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.any#numpy.any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argmax#numpy.argmax&quot;&gt;&lt;code&gt;argmax&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argmin#numpy.argmin&quot;&gt;&lt;code&gt;argmin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argpartition#numpy.argpartition&quot;&gt;&lt;code&gt;argpartition&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.choose#numpy.choose&quot;&gt;&lt;code&gt;choose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.clip#numpy.clip&quot;&gt;&lt;code&gt;clip&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.compress#numpy.compress&quot;&gt;&lt;code&gt;compress&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.cumprod#numpy.cumprod&quot;&gt;&lt;code&gt;cumprod&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.cumsum#numpy.cumsum&quot;&gt;&lt;code&gt;cumsum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.diagonal#numpy.diagonal&quot;&gt;&lt;code&gt;diagonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.imag#numpy.imag&quot;&gt;&lt;code&gt;imag&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.amax#numpy.amax&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.amin#numpy.amin&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.partition#numpy.partition&quot;&gt;&lt;code&gt;partition&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.prod#numpy.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.ptp#numpy.ptp&quot;&gt;&lt;code&gt;ptp&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.put#numpy.put&quot;&gt;&lt;code&gt;put&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.ravel#numpy.ravel&quot;&gt;&lt;code&gt;ravel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.real#numpy.real&quot;&gt;&lt;code&gt;real&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.repeat#numpy.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;reshape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.around#numpy.around&quot;&gt;&lt;code&gt;round&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.searchsorted#numpy.searchsorted&quot;&gt;&lt;code&gt;searchsorted&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.squeeze#numpy.squeeze&quot;&gt;&lt;code&gt;squeeze&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.std#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.swapaxes#numpy.swapaxes&quot;&gt;&lt;code&gt;swapaxes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;trace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.var#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于下面的方法，也有相应的功能&lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; 的&lt;/a&gt;：&lt;a href=&quot;generated/numpy.all#numpy.all&quot;&gt; &lt;code&gt;all&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.any#numpy.any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.argmax#numpy.argmax&quot;&gt; &lt;code&gt;argmax&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.argmin#numpy.argmin&quot;&gt; &lt;code&gt;argmin&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.argpartition#numpy.argpartition&quot;&gt; &lt;code&gt;argpartition&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.choose#numpy.choose&quot;&gt; &lt;code&gt;choose&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.clip#numpy.clip&quot;&gt; &lt;code&gt;clip&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.compress#numpy.compress&quot;&gt; &lt;code&gt;compress&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.cumprod#numpy.cumprod&quot;&gt; &lt;code&gt;cumprod&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.cumsum#numpy.cumsum&quot;&gt; &lt;code&gt;cumsum&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.diagonal#numpy.diagonal&quot;&gt; &lt;code&gt;diagonal&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.imag#numpy.imag&quot;&gt; &lt;code&gt;imag&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.amax#numpy.amax&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.amin#numpy.amin&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.partition#numpy.partition&quot;&gt; &lt;code&gt;partition&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.prod#numpy.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.ptp#numpy.ptp&quot;&gt; &lt;code&gt;ptp&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.put#numpy.put&quot;&gt; &lt;code&gt;put&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.ravel#numpy.ravel&quot;&gt; &lt;code&gt;ravel&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.real#numpy.real&quot;&gt; &lt;code&gt;real&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.repeat#numpy.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;reshape&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.around#numpy.around&quot;&gt; &lt;code&gt;round&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.searchsorted#numpy.searchsorted&quot;&gt; &lt;code&gt;searchsorted&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.squeeze#numpy.squeeze&quot;&gt; &lt;code&gt;squeeze&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.std#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.swapaxes#numpy.swapaxes&quot;&gt; &lt;code&gt;swapaxes&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;trace&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;transpose&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.var#numpy.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f398fd04d9f322afdba477002ec5cde7b5d2d1b" translate="yes" xml:space="preserve">
          <source>For the general case, the iteration works by keeping track of a list of coordinate counters in the iterator object. At each iteration, the last coordinate counter is increased (starting from 0). If this counter is smaller than one less than the size of the array in that dimension (a pre-computed and stored value), then the counter is increased and the dataptr member is increased by the strides in that dimension and the macro ends. If the end of a dimension is reached, the counter for the last dimension is reset to zero and the dataptr is moved back to the beginning of that dimension by subtracting the strides value times one less than the number of elements in that dimension (this is also pre-computed and stored in the backstrides member of the iterator object). In this case, the macro does not end, but a local dimension counter is decremented so that the next-to-last dimension replaces the role that the last dimension played and the previously-described tests are executed again on the next-to-last dimension. In this way, the dataptr is adjusted appropriately for arbitrary striding.</source>
          <target state="translated">对于一般情况,迭代的工作方式是在迭代对象中跟踪坐标计数器的列表。在每次迭代时,最后一个坐标计数器都会增加(从0开始)。如果这个计数器小于一小于该维度中数组的大小(一个预先计算和存储的值),那么计数器就会增加,dataptr成员就会增加该维度中的步长,宏结束。如果到达一个维度的结束,最后一个维度的计数器被重置为零,并且dataptr通过减去strides值乘以该维度中元素数量的1来移动回该维度的开始(这也是预先计算并存储在迭代器对象的backstrides成员中)。在这种情况下,宏并没有结束,而是局部维度计数器被递减,这样下一个到最后一个维度就取代了上一个维度所起的作用,并且之前描述的测试会在下一个到最后一个维度上再次执行。这样一来,dataptr的任意跨度就会得到适当的调整。</target>
        </trans-unit>
        <trans-unit id="a106ff191577f5e49df4ba4a5b92a5dff872216c" translate="yes" xml:space="preserve">
          <source>For the most part, the rules for dispatch with &lt;code&gt;__array_function__&lt;/code&gt; match those for &lt;code&gt;__array_ufunc__&lt;/code&gt;. In particular:</source>
          <target state="translated">在大多数情况下，与调度规则 &lt;code&gt;__array_function__&lt;/code&gt; 匹配那些 &lt;code&gt;__array_ufunc__&lt;/code&gt; 。特别是：</target>
        </trans-unit>
        <trans-unit id="4180b0d2e31dfed11719fe695b4c67afcfef466f" translate="yes" xml:space="preserve">
          <source>For the parameter types, be as precise as possible. Below are a few examples of parameters and their types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aabe002787ac5ab3c2a4862f3aa6c788cd300e2" translate="yes" xml:space="preserve">
          <source>For the typenum macros, the argument is an integer representing an enumerated array data type. For the array type checking macros the argument must be a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that can be directly interpreted as a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于typenum宏，参数是代表枚举数组数据类型的整数。对于数组类型检查宏，参数必须是&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt;，可以直接解释为&lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="62fce29176d606bc6dce1d1603810532e05edeb2" translate="yes" xml:space="preserve">
          <source>For the typenum macros, the argument is an integer representing an enumerated array data type. For the array type checking macros the argument must be a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that can be directly interpreted as a &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3c40fa5c98be8aa15b70b390891bf28a170212" translate="yes" xml:space="preserve">
          <source>For these reasons it is advisable to avoid &lt;code&gt;as_strided&lt;/code&gt; when possible.</source>
          <target state="translated">由于这些原因，建议尽可能避免 &lt;code&gt;as_strided&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb33fc8c29e1bd562bffb815c2697c66a036bae2" translate="yes" xml:space="preserve">
          <source>For these reasons, NumPy provides an API to work with npy_half values accessible by including &amp;lt;numpy/halffloat.h&amp;gt; and linking to &amp;lsquo;npymath&amp;rsquo;. For functions that are not provided directly, such as the arithmetic operations, the preferred method is to convert to float or double and back again, as in the following example.</source>
          <target state="translated">由于这些原因，NumPy提供了一个API，用于通过包含&amp;lt;numpy / halffloat.h&amp;gt;并链接到'npymath'来访问npy_half值。对于不直接提供的功能（例如算术运算），首选方法是将其转换为float或double，然后再次返回，如以下示例所示。</target>
        </trans-unit>
        <trans-unit id="684c1e70d951c1d84a7330eb5d5d620e2e0f3ef5" translate="yes" xml:space="preserve">
          <source>For this example we will only handle the method &lt;code&gt;__call__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b0d8b34011752e4113aaa6a6fce2b3c78d19e5" translate="yes" xml:space="preserve">
          <source>For this function to work on sub-classes of ndarray, they must define &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; with the kwarg &lt;code&gt;keepdims&lt;/code&gt;</source>
          <target state="translated">为了使此函数能够对ndarray的子​​类起作用，它们必须使用kwarg &lt;code&gt;keepdims&lt;/code&gt; 定义&lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bffe6d0d22813c5a9e09a6444b12ab5f734f3a30" translate="yes" xml:space="preserve">
          <source>For this reason it is possible to use the output from the np.nonzero() function directly as an index since it always returns a tuple of index arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b38cff3c38a7296ea244a6f149ab3fa89299cb" translate="yes" xml:space="preserve">
          <source>For this reason, it is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.apply_along_axis#numpy.apply_along_axis&quot;&gt;&lt;code&gt;apply_along_axis&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">因此，它等同于（但比以下速度）&lt;a href=&quot;numpy.apply_along_axis#numpy.apply_along_axis&quot;&gt; &lt;code&gt;apply_along_axis&lt;/code&gt; &lt;/a&gt;的以下用法：</target>
        </trans-unit>
        <trans-unit id="77bbee921f7bbec73ea6da64c3957049942fe48c" translate="yes" xml:space="preserve">
          <source>For this sample array</source>
          <target state="translated">对于这个样本数组</target>
        </trans-unit>
        <trans-unit id="ef360ecaea0bceb4141bc860c62269adcea43126" translate="yes" xml:space="preserve">
          <source>For two dimensional arrays, the return will be two arrays ordered by axis. In this example the first array stands for the gradient in rows and the second one in columns direction:</source>
          <target state="translated">对于二维数组,返回的将是两个按轴排序的数组。在这个例子中,第一个数组代表行的梯度,第二个数组代表列的方向。</target>
        </trans-unit>
        <trans-unit id="5688be18895d1ed44e4e4ac9ea5a009f3d8f644d" translate="yes" xml:space="preserve">
          <source>For ufuncs dynamically created from python functions, this member holds a reference to the underlying Python function.</source>
          <target state="translated">对于从python函数动态创建的ufuncs,该成员持有对底层Python函数的引用。</target>
        </trans-unit>
        <trans-unit id="f51d3a13e3a61d2cfd5f82478bfc77249b90c3e8" translate="yes" xml:space="preserve">
          <source>For ufuncs, it is hoped to eventually deprecate this method in favour of &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于ufuncs，希望最终弃用赞成这种方法&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3fec4c12c09d2caf632487f32e741d15fde50a70" translate="yes" xml:space="preserve">
          <source>For unpickling.</source>
          <target state="translated">用于解腌。</target>
        </trans-unit>
        <trans-unit id="f5a617d92aada34c5b1b91d32c80426c8f059f29" translate="yes" xml:space="preserve">
          <source>For unsigned integer arrays, the results will also be unsigned. This should not be surprising, as the result is consistent with calculating the difference directly:</source>
          <target state="translated">对于无符号整数数组,结果也将是无符号的。这并不奇怪,因为结果与直接计算差值是一致的。</target>
        </trans-unit>
        <trans-unit id="6e4eba9645d784baff280ba41b2a35d0eb68b9c9" translate="yes" xml:space="preserve">
          <source>For us, what consensus means is that we entrust &lt;em&gt;everyone&lt;/em&gt; with the right to veto any change if they feel it necessary. While this may sound like a recipe for obstruction and pain, this is not what happens. Instead, we find that most people take this responsibility seriously, and only invoke their veto when they judge that a serious problem is being ignored, and that their veto is necessary to protect the project. And in practice, it turns out that such vetoes are almost never formally invoked, because their mere possibility ensures that Contributors are motivated from the start to find some solution that everyone can live with &amp;ndash; thus accomplishing our goal of ensuring that all interested perspectives are taken into account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b61801e49c04aeb574dfd6c0384db9e70e2d05c" translate="yes" xml:space="preserve">
          <source>For use if one has reason to manually (re-)set the internal state of the bit generator used by the RandomState instance. By default, RandomState uses the &amp;ldquo;Mersenne Twister&amp;rdquo;&lt;a href=&quot;#r0933ec43c7c9-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; pseudo-random number generating algorithm.</source>
          <target state="translated">如果有理由手动（重新）设置RandomState实例使用的位生成器的内部状态，则可以使用。默认情况下，RandomState使用&amp;ldquo; Mersenne Twister&amp;rdquo; &lt;a href=&quot;#r0933ec43c7c9-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;伪随机数生成算法。</target>
        </trans-unit>
        <trans-unit id="897febe53ee6bd5d25313858b98b8601f29d1bc3" translate="yes" xml:space="preserve">
          <source>For use if one has reason to manually (re-)set the internal state of the bit generator used by the RandomState instance. By default, RandomState uses the &amp;ldquo;Mersenne Twister&amp;rdquo;&lt;a href=&quot;#rd62dfb5ffa26-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; pseudo-random number generating algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea29248ff311f62cfdcca5534fc099ca5bcc6b8e" translate="yes" xml:space="preserve">
          <source>For use if one has reason to manually (re-)set the internal state of the bit generator used by the RandomState instance. By default, RandomState uses the &amp;ldquo;Mersenne Twister&amp;rdquo;&lt;a href=&quot;#rf0f3f75f485b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; pseudo-random number generating algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f7c1942ce335813533514ab6d97be522e99c17" translate="yes" xml:space="preserve">
          <source>For use with &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt;&lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt;&lt;/a&gt;, this flag disables allocating an array subtype for the output, forcing it to be a straight ndarray.</source>
          <target state="translated">与&lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt; &lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt; 一起&lt;/a&gt;使用时，此标志将禁用为输出分配数组子类型，从而将其强制为纯正ndarray。</target>
        </trans-unit>
        <trans-unit id="4f63cfae8856e0c1b4c745d806a5044a1d2050ad" translate="yes" xml:space="preserve">
          <source>For use with &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">与&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; 一起&lt;/a&gt;使用</target>
        </trans-unit>
        <trans-unit id="703ab6c203bc4f7c082f6639ec9949c363231487" translate="yes" xml:space="preserve">
          <source>For use with &lt;code&gt;PyArg_ParseTuple&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb254f53813d4f5ed5d47fcd78786e6b4efd30e" translate="yes" xml:space="preserve">
          <source>For values exactly halfway between rounded decimal values, NumPy rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0, -0.5 and 0.5 round to 0.0, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f0a5ecb33fee954cb51300dbd6244641e9062e" translate="yes" xml:space="preserve">
          <source>For values exactly halfway between rounded decimal values, NumPy rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0, -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due to the inexact representation of decimal fractions in the IEEE floating point standard &lt;a href=&quot;#r907366b089c1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; and errors introduced when scaling by powers of ten.</source>
          <target state="translated">对于恰好介于四舍五入的十进制值之间的值，NumPy会四舍五入为最接近的偶数。因此，将1.5和2.5舍入为2.0，将-0.5和0.5舍入为0.0，等等。由于IEEE浮点标准&lt;a href=&quot;#r907366b089c1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;中小数部分的不精确表示以及以10的幂进行缩放时引入的误差，结果也可能令人惊讶。</target>
        </trans-unit>
        <trans-unit id="a7513a1115d30c3b715a3ca9a5ba6b73db8ad275" translate="yes" xml:space="preserve">
          <source>For values of &lt;code&gt;ord &amp;lt; 1&lt;/code&gt;, the result is, strictly speaking, not a mathematical &amp;lsquo;norm&amp;rsquo;, but it may still be useful for various numerical purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8df8eb2541671de725aa87916abd483ac03487" translate="yes" xml:space="preserve">
          <source>For values of &lt;code&gt;ord &amp;lt;= 0&lt;/code&gt;, the result is, strictly speaking, not a mathematical &amp;lsquo;norm&amp;rsquo;, but it may still be useful for various numerical purposes.</source>
          <target state="translated">对于 &lt;code&gt;ord &amp;lt;= 0&lt;/code&gt; 的值，严格来说，结果不是数学上的&amp;ldquo;范数&amp;rdquo;，但是对于各种数值目的，它仍然可能有用。</target>
        </trans-unit>
        <trans-unit id="d6c5fe59c42bb96e8794f338a14a9afba25af3e6" translate="yes" xml:space="preserve">
          <source>For vectors (1-D arrays) it computes the ordinary inner-product:</source>
          <target state="translated">对于向量(一维数组),它计算普通的内积。</target>
        </trans-unit>
        <trans-unit id="f31afbaa8abd3ce58c5bf83aec637268a269a63d" translate="yes" xml:space="preserve">
          <source>For vectors &lt;code&gt;x1&lt;/code&gt;, &lt;code&gt;x2&lt;/code&gt;,&amp;hellip;, &amp;lsquo;xn&amp;rsquo; with lengths &lt;code&gt;Ni=len(xi)&lt;/code&gt; , return &lt;code&gt;(N1, N2, N3,...Nn)&lt;/code&gt; shaped arrays if indexing=&amp;rsquo;ij&amp;rsquo; or &lt;code&gt;(N2, N1, N3,...Nn)&lt;/code&gt; shaped arrays if indexing=&amp;rsquo;xy&amp;rsquo; with the elements of &lt;code&gt;xi&lt;/code&gt; repeated to fill the matrix along the first dimension for &lt;code&gt;x1&lt;/code&gt;, the second for &lt;code&gt;x2&lt;/code&gt; and so on.</source>
          <target state="translated">对于长度为 &lt;code&gt;Ni=len(xi)&lt;/code&gt; 的向量 &lt;code&gt;x1&lt;/code&gt; ， &lt;code&gt;x2&lt;/code&gt; ，...，'xn'，如果indexing ='ij'或 &lt;code&gt;(N2, N1, N3,...Nn)&lt;/code&gt; ），则返回 &lt;code&gt;(N1, N2, N3,...Nn)&lt;/code&gt; 形状的数组。 ..Nn）形状的数组，如果index ='xy'，且 &lt;code&gt;xi&lt;/code&gt; 的元素重复出现，则沿 &lt;code&gt;x1&lt;/code&gt; 的第一个维度填充矩阵，沿 &lt;code&gt;x2&lt;/code&gt; 的第二个维度填充矩阵，依此类推。</target>
        </trans-unit>
        <trans-unit id="51b960f61f40e8cc6aeabaf2a1735fbc2b9ac25d" translate="yes" xml:space="preserve">
          <source>For view casting and new-from-template, the equivalent of &lt;code&gt;ndarray.__new__(MySubClass,...&lt;/code&gt; is called, at the C level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6242c0a79a41aa81490f6fd1ec86280110a2af" translate="yes" xml:space="preserve">
          <source>Force a cast to the output type even if it cannot be done safely. Without this flag, a data cast will occur only if it can be done safely, otherwise an error is raised.</source>
          <target state="translated">即使不能安全地进行数据投射,也要强制投射到输出类型。如果没有这个标志,只有在可以安全地进行数据转换的情况下,才会发生数据转换,否则会引发错误。</target>
        </trans-unit>
        <trans-unit id="d3ec8aad2bec1b3220d7b727c3bf434f0d55bc18" translate="yes" xml:space="preserve">
          <source>Force the mask to hard.</source>
          <target state="translated">把面具逼得很紧。</target>
        </trans-unit>
        <trans-unit id="cd0355317a1ab931fccb7ea5788f7a01c8683490" translate="yes" xml:space="preserve">
          <source>Force the mask to soft.</source>
          <target state="translated">强行将面罩调至柔软。</target>
        </trans-unit>
        <trans-unit id="46e07bf1dcba4f22fb0998d98afd707eecb583d3" translate="yes" xml:space="preserve">
          <source>Format Version 1.0</source>
          <target state="translated">格式1.0版</target>
        </trans-unit>
        <trans-unit id="9c5ba690bca66f9b43bf7dce492a8ecc14116342" translate="yes" xml:space="preserve">
          <source>Format Version 2.0</source>
          <target state="translated">格式2.0版</target>
        </trans-unit>
        <trans-unit id="6d476621018ad05f5efc66b66f9628e71614d77b" translate="yes" xml:space="preserve">
          <source>Format Version 3.0</source>
          <target state="translated">格式3.0版</target>
        </trans-unit>
        <trans-unit id="082aa72e2e80659bc0dafa9d8a6a53207113bd45" translate="yes" xml:space="preserve">
          <source>Format a floating-point scalar as a decimal string in positional notation.</source>
          <target state="translated">将浮点标量以位置记数法格式化为十进制字符串。</target>
        </trans-unit>
        <trans-unit id="63ec1825c81674406abf9c065439398606f8e9c4" translate="yes" xml:space="preserve">
          <source>Format a floating-point scalar as a decimal string in scientific notation.</source>
          <target state="translated">将浮点标量用科学计数法格式化为十进制字符串。</target>
        </trans-unit>
        <trans-unit id="2ba865544cbf6ad122958e97b9cb7e6ee2fca0ce" translate="yes" xml:space="preserve">
          <source>Format string for text file output. Each entry in the array is formatted to text by first converting it to the closest Python type, and then using &amp;ldquo;format&amp;rdquo; % item.</source>
          <target state="translated">文本文件输出的格式字符串。首先将数组中的每个条目转换为最接近的Python类型，然后使用&amp;ldquo; format&amp;rdquo;％item将其格式化为文本。</target>
        </trans-unit>
        <trans-unit id="a3b7bf2b2380c4418912a52f4b2af945c3ac0459" translate="yes" xml:space="preserve">
          <source>Formatting issues</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5a92b78c74fdad3772b95c0bef006808c6f5062" translate="yes" xml:space="preserve">
          <source>Fornberg B. (1988) Generation of Finite Difference Formulas on Arbitrarily Spaced Grids, Mathematics of Computation 51, no. 184 : 699-706. &lt;a href=&quot;http://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&quot;&gt;PDF&lt;/a&gt;.</source>
          <target state="translated">Fornberg B.（1988）在任意间隔的网格上生成有限差分公式，计算数学51，第1期。184：699-706。&lt;a href=&quot;http://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&quot;&gt;PDF&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d1cc558102f286f771795f2da7cbcbf5ba1b6328" translate="yes" xml:space="preserve">
          <source>Fortran 90 module data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b62f0c388a951d6d6803e4d2dc48f368bb1a5685" translate="yes" xml:space="preserve">
          <source>Fortran assumed shape array and size function support in &lt;code&gt;numpy.f2py&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b756e1ed184faeae9981dd9378f750e8c6c0e04f" translate="yes" xml:space="preserve">
          <source>Fortran files</source>
          <target state="translated">Fortran文件</target>
        </trans-unit>
        <trans-unit id="443b7dd908046f637f8adbdcefe50ee302b6f087" translate="yes" xml:space="preserve">
          <source>Fortran order if all the inputs are Fortran, C otherwise.</source>
          <target state="translated">如果所有输入都是Fortran,则为Fortran顺序,否则为C。</target>
        </trans-unit>
        <trans-unit id="0dbb13a4208640c43e953aa1ecfe0492f9b453d1" translate="yes" xml:space="preserve">
          <source>Fortran order.</source>
          <target state="translated">Fortran命令。</target>
        </trans-unit>
        <trans-unit id="458144d44956123a91798b5242d7c298d549eb1b" translate="yes" xml:space="preserve">
          <source>Fortran source of module / subroutine to compile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b7af163ec1d9df45d457b3365dd7a8bb154117" translate="yes" xml:space="preserve">
          <source>Fortran to Python Interface Generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c97ded998a0ca595e9b4695a113a861855f88705" translate="yes" xml:space="preserve">
          <source>Fortran-contiguous arrays when data is stored column-wise, i.e. indexing of data as stored in memory starts from the lowest dimension;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c103a2ce4fa5c4bdfbfca73532b43fd7c1242b6" translate="yes" xml:space="preserve">
          <source>Fortran-order</source>
          <target state="translated">Fortran-order</target>
        </trans-unit>
        <trans-unit id="01f074f9b2b7da2704c7bf16c64348fbe5aff689" translate="yes" xml:space="preserve">
          <source>Fortran/C routine signatures</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa529d42774f0768730f12bc0880f9965a988000" translate="yes" xml:space="preserve">
          <source>Forward bytes from a subprocess call to the console, without attempting to decode them.</source>
          <target state="translated">将子进程调用的字节转发到控制台,而不试图对它们进行解码。</target>
        </trans-unit>
        <trans-unit id="ececb946a3ffd8fb7cf57101d577f7acf1341e58" translate="yes" xml:space="preserve">
          <source>Forward port changes in the release branch to release notes and release scripts, if any, to master branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2982346b57dba0536f8cd38d08e71e22e03b5068" translate="yes" xml:space="preserve">
          <source>Four values of the output are invalid: the first one comes from taking the square root of a negative number, the second from the division by zero, and the last two where the inputs were masked.</source>
          <target state="translated">有四个输出值是无效的:第一个来自于负数的平方根,第二个来自于零的除法,最后两个是输入被掩盖的地方。</target>
        </trans-unit>
        <trans-unit id="f163a620e6be53409bc7d6c8a56980a06cc8552e" translate="yes" xml:space="preserve">
          <source>Fourier analysis is fundamentally a method for expressing a function as a sum of periodic components, and for recovering the function from those components. When both the function and its Fourier transform are replaced with discretized counterparts, it is called the discrete Fourier transform (DFT). The DFT has become a mainstay of numerical computing in part because of a very fast algorithm for computing it, called the Fast Fourier Transform (FFT), which was known to Gauss (1805) and was brought to light in its current form by Cooley and Tukey &lt;a href=&quot;#rfb1dc64dd6a5-ct&quot; id=&quot;id1&quot;&gt;[CT]&lt;/a&gt;. Press et al. &lt;a href=&quot;#rfb1dc64dd6a5-nr&quot; id=&quot;id2&quot;&gt;[NR]&lt;/a&gt; provide an accessible introduction to Fourier analysis and its applications.</source>
          <target state="translated">傅里叶分析从根本上说是一种将函数表示为周期成分之和，并从这些成分中恢复功能的方法。当将函数及其傅立叶变换都替换为离散的对应项时，称为离散傅立叶变换（DFT）。DFT之所以成为数值计算的支柱，部分原因在于它是一种非常快速的计算算法，称为快速傅里叶变换（FFT），它是高斯（1805）所熟知，并由Cooley和图基&lt;a href=&quot;#rfb1dc64dd6a5-ct&quot; id=&quot;id1&quot;&gt;[CT]&lt;/a&gt;。出版社等。&lt;a href=&quot;#rfb1dc64dd6a5-nr&quot; id=&quot;id2&quot;&gt;[NR]&lt;/a&gt;提供了有关Fourier分析及其应用的易于理解的介绍。</target>
        </trans-unit>
        <trans-unit id="69fe683adb41f9ba1a3873187fd6c76482148e01" translate="yes" xml:space="preserve">
          <source>Fourier transform of &lt;code&gt;a&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
