<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="40188341aa1ae4126e28065ab4ae4528efd4ab80" translate="yes" xml:space="preserve">
          <source>An array containing the size of the array in each dimension.</source>
          <target state="translated">一个数组,包含数组每个维度的大小。</target>
        </trans-unit>
        <trans-unit id="c5525cd97ca2fd0380b69e5fa824c4cb8926190c" translate="yes" xml:space="preserve">
          <source>An array containing the x coordinates of the points to be histogrammed.</source>
          <target state="translated">一个包含要进行直方图测量的点的X坐标的数组。</target>
        </trans-unit>
        <trans-unit id="5e0350b6b12b116d1bc018ccc6e377cd22ea853f" translate="yes" xml:space="preserve">
          <source>An array containing the y coordinates of the points to be histogrammed.</source>
          <target state="translated">一个包含要进行直方图测量的点的Y坐标的数组。</target>
        </trans-unit>
        <trans-unit id="23292ed5ea6c87129ac7edf129a6b29a5c739151" translate="yes" xml:space="preserve">
          <source>An array created this way is a &lt;code&gt;view&lt;/code&gt;, and NumPy often exploits the performance gain of using a view versus making a new array.</source>
          <target state="translated">用这种方法创建的数组就是一个 &lt;code&gt;view&lt;/code&gt; ，而NumPy经常利用使用视图而不是制作一个新数组来提高性能。</target>
        </trans-unit>
        <trans-unit id="1cd97d56d812219b3b28e1a0c52b1ff6cc695c36" translate="yes" xml:space="preserve">
          <source>An array describing the shape and dtype of the required MaskedArray.</source>
          <target state="translated">描述所需MaskedArray形状和dtype的数组。</target>
        </trans-unit>
        <trans-unit id="04cda3e50b71bd943d98a23dec5faaaa9a7dbcdc" translate="yes" xml:space="preserve">
          <source>An array has a shape given by the number of elements along each axis:</source>
          <target state="translated">一个数组的形状由每个轴上的元素数决定。</target>
        </trans-unit>
        <trans-unit id="d793f2dc9aa6a2d7752deea585ed5cd173d35117" translate="yes" xml:space="preserve">
          <source>An array is a central data structure of the NumPy library. An array is a grid of values and it contains information about the raw data, how to locate an element, and how to interpret an element. It has a grid of elements that can be indexed in &lt;a href=&quot;quickstart#quickstart-indexing-slicing-and-iterating&quot;&gt;various ways&lt;/a&gt;. The elements are all of the same type, referred to as the array &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">数组是NumPy库的中央数据结构。数组是值的网格，它包含有关原始数据，如何定位元素以及如何解释元素的信息。它具有可以以&lt;a href=&quot;quickstart#quickstart-indexing-slicing-and-iterating&quot;&gt;各种方式建立&lt;/a&gt;索引的元素网格。元素都是相同的类型，称为数组 &lt;code&gt;dtype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf313c17a2dcae5eace0c3bac8edc28ea3d4e63f" translate="yes" xml:space="preserve">
          <source>An array is considered aligned if the memory offsets for all elements and the base offset itself is a multiple of &lt;code&gt;self.itemsize&lt;/code&gt;. Understanding &lt;code&gt;memory-alignment&lt;/code&gt; leads to better performance on most hardware.</source>
          <target state="translated">如果所有元素的内存偏移量和基本偏移量本身是 &lt;code&gt;self.itemsize&lt;/code&gt; 的倍数，则认为数组是对齐的。了解 &lt;code&gt;memory-alignment&lt;/code&gt; 可以在大多数硬件上提高性能。</target>
        </trans-unit>
        <trans-unit id="39caa1c045b8f25aa32aa854e91ee572acbabbf4" translate="yes" xml:space="preserve">
          <source>An array is contiguous if</source>
          <target state="translated">一个数组在以下情况下是连续的</target>
        </trans-unit>
        <trans-unit id="0d7bb147f3c8147036b25457f328e2835c359f8d" translate="yes" xml:space="preserve">
          <source>An array is usually a fixed-size container of items of the same type and size. The number of dimensions and items in an array is defined by its shape. The shape of an array is a tuple of non-negative integers that specify the sizes of each dimension.</source>
          <target state="translated">数组通常是一个固定大小的容器,包含相同类型和大小的项目。数组中的维数和项数由它的形状决定。数组的形状是一个非负整数的元组,它规定了每个维度的大小。</target>
        </trans-unit>
        <trans-unit id="8d722ed07993e54ee58671613ec6bb989469ec46" translate="yes" xml:space="preserve">
          <source>An array iterator is a simple way to access the elements of an N-dimensional array quickly and efficiently. Section &lt;a href=&quot;#sec-array-iterator&quot;&gt;2&lt;/a&gt; provides more description and examples of this useful approach to looping over an array.</source>
          <target state="translated">数组迭代器是一种快速有效地访问N维数组元素的简单方法。第&lt;a href=&quot;#sec-array-iterator&quot;&gt;2&lt;/a&gt;节提供了此有用的循环数组方法的更多说明和示例。</target>
        </trans-unit>
        <trans-unit id="4332fb61829c6f89ffe9272f70c9a5a0a04142f9" translate="yes" xml:space="preserve">
          <source>An array nested in a &lt;a href=&quot;#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, as &lt;code&gt;b&lt;/code&gt; is here:</source>
          <target state="translated">嵌套在&lt;a href=&quot;#term-structured-data-type&quot;&gt;结构化数据类型中&lt;/a&gt;的数组，如 &lt;code&gt;b&lt;/code&gt; 所示：</target>
        </trans-unit>
        <trans-unit id="8c8ecafe80193daba2a801115dc110f22a3a74c2" translate="yes" xml:space="preserve">
          <source>An array object represents a multidimensional, homogeneous array of fixed-size items.</source>
          <target state="translated">数组对象表示一个固定大小的多维同质数组。</target>
        </trans-unit>
        <trans-unit id="4cce5f6c6a06c1eb7b057cb09fd7ff7ffd616b00" translate="yes" xml:space="preserve">
          <source>An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.)</source>
          <target state="translated">一个数组对象表示一个多维的、由固定大小的项目组成的同质数组。一个关联的数据类型对象描述了数组中每个元素的格式(它的字节顺序,它在内存中占据了多少字节,它是一个整数,一个浮点数,还是其他的东西,等等)。</target>
        </trans-unit>
        <trans-unit id="8d1e82b5439e905b1ddafb253ce61f57276c43a9" translate="yes" xml:space="preserve">
          <source>An array object satisfying the specified requirements.</source>
          <target state="translated">一个满足指定要求的数组对象。</target>
        </trans-unit>
        <trans-unit id="b7bb351e2eb8c7a3b66881caf4f6450b8b6137b9" translate="yes" xml:space="preserve">
          <source>An array of</source>
          <target state="translated">一系列的</target>
        </trans-unit>
        <trans-unit id="5e4c885c1848f9a375fc02dab6bce7ae4010158c" translate="yes" xml:space="preserve">
          <source>An array of dates to consider as invalid dates, no matter which weekday they fall upon. Holiday dates may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days.</source>
          <target state="translated">被视为无效日期的日期数组,无论它们落在哪个工作日。节假日日期可以以任何顺序指定,NaT(非时间)日期将被忽略。这个列表以标准化的形式保存,适合快速计算有效日期。</target>
        </trans-unit>
        <trans-unit id="43a99ea190c51364ce40fbff67e226039938f643" translate="yes" xml:space="preserve">
          <source>An array of dates to consider as invalid dates. They may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days.</source>
          <target state="translated">被视为无效日期的日期数组。它们可以以任何顺序指定,NaT(非时间)日期将被忽略。这个列表以标准化的形式保存,适合快速计算有效日期。</target>
        </trans-unit>
        <trans-unit id="e52ec49035d815a8b775d98b8000ec27cfc67177" translate="yes" xml:space="preserve">
          <source>An array of floats to be rounded</source>
          <target state="translated">一个要四舍五入的浮动数组</target>
        </trans-unit>
        <trans-unit id="f3de1a372b66bb0f894c2b02cc87913d27ccf3e7" translate="yes" xml:space="preserve">
          <source>An array of function pointers &amp;mdash; one for each data type supported by the ufunc. This is the vector loop that is called to implement the underlying function &lt;em&gt;dims&lt;/em&gt; [0] times. The first argument, &lt;em&gt;args&lt;/em&gt;, is an array of &lt;em&gt;nargs&lt;/em&gt; pointers to behaved memory. Pointers to the data for the input arguments are first, followed by the pointers to the data for the output arguments. How many bytes must be skipped to get to the next element in the sequence is specified by the corresponding entry in the &lt;em&gt;steps&lt;/em&gt; array. The last argument allows the loop to receive extra information. This is commonly used so that a single, generic vector loop can be used for multiple functions. In this case, the actual scalar function to call is passed in as &lt;em&gt;extradata&lt;/em&gt;. The size of this function pointer array is ntypes.</source>
          <target state="translated">函数指针数组-对应ufunc支持的每种数据类型。这是调用向量循环以实现基础功能&lt;em&gt;dims&lt;/em&gt; [0]倍。第一个参数&lt;em&gt;args&lt;/em&gt;是指向行为内存的&lt;em&gt;nargs&lt;/em&gt;指针数组。首先指向输入自变量数据的指针，然后是指向输出自变量数据的指针。由&lt;em&gt;步骤&lt;/em&gt;数组中的相应条目指定要跳过多少字节才能到达序列中的下一个元素。最后一个参数允许循环接收额外的信息。这是常用的，因此单个通用向量循环可用于多种功能。在这种情况下，要调用的实际标量函数将作为&lt;em&gt;额外数据&lt;/em&gt;。该函数指针数组的大小为ntypes。</target>
        </trans-unit>
        <trans-unit id="e1457d1fa372ec75b9a3106caffe135f20a4e98d" translate="yes" xml:space="preserve">
          <source>An array of function pointers to a particular sorting algorithms. A particular sorting algorithm is obtained using a key (so far &lt;a href=&quot;array#c.NPY_QUICKSORT&quot;&gt;&lt;code&gt;NPY_QUICKSORT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_HEAPSORT&quot;&gt;&lt;code&gt;NPY_HEAPSORT&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;array#c.NPY_MERGESORT&quot;&gt;&lt;code&gt;NPY_MERGESORT&lt;/code&gt;&lt;/a&gt; are defined). These sorts are done in-place assuming contiguous and aligned data.</source>
          <target state="translated">指向特定排序算法的函数指针数组。使用键可以获取特定的排序算法（到目前为止，已定义&lt;a href=&quot;array#c.NPY_QUICKSORT&quot;&gt; &lt;code&gt;NPY_QUICKSORT&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;array#c.NPY_HEAPSORT&quot;&gt; &lt;code&gt;NPY_HEAPSORT&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;array#c.NPY_MERGESORT&quot;&gt; &lt;code&gt;NPY_MERGESORT&lt;/code&gt; &lt;/a&gt;）。这些排序是在假定连续且对齐的数据的情况下就地完成的。</target>
        </trans-unit>
        <trans-unit id="89ccf0c919c71e47e2ddd7bf201588725f440dd1" translate="yes" xml:space="preserve">
          <source>An array of function pointers to a particular sorting algorithms. A particular sorting algorithm is obtained using a key (so far &lt;code&gt;NPY_QUICKSORT&lt;/code&gt;, &lt;code&gt;NPY_HEAPSORT&lt;/code&gt;, and &lt;code&gt;NPY_MERGESORT&lt;/code&gt; are defined). These sorts are done in-place assuming contiguous and aligned data.</source>
          <target state="translated">指向特定排序算法的函数指针数组。使用键可以获取特定的排序算法（到目前为止，已定义 &lt;code&gt;NPY_QUICKSORT&lt;/code&gt; ， &lt;code&gt;NPY_HEAPSORT&lt;/code&gt; 和 &lt;code&gt;NPY_MERGESORT&lt;/code&gt; ）。这些排序是在假设连续且对齐的数据的情况下就地完成的。</target>
        </trans-unit>
        <trans-unit id="e16de626c174b91da42175d30f3d8341b71b66d8" translate="yes" xml:space="preserve">
          <source>An array of function pointers to cast from the current type to all of the other builtin types. Each function casts a contiguous, aligned, and notswapped buffer pointed at by &lt;em&gt;from&lt;/em&gt; to a contiguous, aligned, and notswapped buffer pointed at by &lt;em&gt;to&lt;/em&gt; The number of items to cast is given by &lt;em&gt;n&lt;/em&gt;, and the arguments &lt;em&gt;fromarr&lt;/em&gt; and &lt;em&gt;toarr&lt;/em&gt; are interpreted as PyArrayObjects for flexible arrays to get itemsize information.</source>
          <target state="translated">从当前类型转换为所有其他内置类型的函数指针数组。每个功能蒙上了连续的，对齐，和notswapped在由缓冲尖&lt;em&gt;从&lt;/em&gt;一个连续的，对齐，和notswapped缓冲区指向由&lt;em&gt;到&lt;/em&gt;项铸造的数量由下式给出&lt;em&gt;&amp;Ntilde;&lt;/em&gt;，和参数&lt;em&gt;fromarr&lt;/em&gt;和&lt;em&gt;toarr&lt;/em&gt;被解释为PyArrayObjects为灵活的数组以获取项目大小信息。</target>
        </trans-unit>
        <trans-unit id="e200feb9e53ed4ebf2adb54be5ba987c1cf7059b" translate="yes" xml:space="preserve">
          <source>An array of function pointers to sorting algorithms for this data type. The same sorting algorithms as for sort are available. The indices producing the sort are returned in &lt;code&gt;result&lt;/code&gt; (which must be initialized with indices 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive).</source>
          <target state="translated">指向此数据类型的排序算法的函数指针数组。可以使用与排序相同的排序算法。产生排序的索引将返回到 &lt;code&gt;result&lt;/code&gt; （必须使用索引0到 &lt;code&gt;length-1&lt;/code&gt; 包括长度在内）进行初始化）。</target>
        </trans-unit>
        <trans-unit id="4bf461a6da3a9c78b86edef9e37f8d374d2671a0" translate="yes" xml:space="preserve">
          <source>An array of indices into the flattened version of an array of dimensions &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="translated">索引数组，它是维数组的扁平化版本的 &lt;code&gt;dims&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43a2b96955709f32822d46286842703f4390b599" translate="yes" xml:space="preserve">
          <source>An array of indices or a single index value.</source>
          <target state="translated">一个索引数组或一个单一的索引值。</target>
        </trans-unit>
        <trans-unit id="c327e0cbb835c3f65406d2930b711dc0438fe097" translate="yes" xml:space="preserve">
          <source>An array of integers or booleans whose elements should be packed to bits.</source>
          <target state="translated">一个整数或布尔数组,其元素应该被包装成比特。</target>
        </trans-unit>
        <trans-unit id="760cd2caf69b9cf29b19f984123cfb0704600d65" translate="yes" xml:space="preserve">
          <source>An array of integers providing for each dimension the number of bytes that must be skipped to get to the next element in that dimension.</source>
          <target state="translated">一个整数数组,提供每个维度必须跳过的字节数,以到达该维度的下一个元素。</target>
        </trans-unit>
        <trans-unit id="71e7cb63a5da7e356218da95d576d7ce741d5a1c" translate="yes" xml:space="preserve">
          <source>An array of integers providing for each dimension the number of bytes that must be skipped to get to the next element in that dimension. Associated with macro &lt;a href=&quot;array#c.PyArray_STRIDES&quot;&gt;&lt;code&gt;PyArray_STRIDES&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">整数数组，为每个维度提供到达该维度中的下一个元素必须跳过的字节数。与宏&lt;a href=&quot;array#c.PyArray_STRIDES&quot;&gt; &lt;code&gt;PyArray_STRIDES&lt;/code&gt; 关联&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44196e580ff225be1ef1476b121c70c9f63af8cb" translate="yes" xml:space="preserve">
          <source>An array of integers providing the shape in each dimension as long as nd</source>
          <target state="translated">提供每个维度形状的整数数组,只要 nd</target>
        </trans-unit>
        <trans-unit id="62ed90156adc402e959f400c23d7929e6a74e615" translate="yes" xml:space="preserve">
          <source>An array of iterator objects that holds the iterators for the arrays to be broadcast together. On return, the iterators are adjusted for broadcasting.</source>
          <target state="translated">一个迭代器对象的数组,用来存放要一起广播的数组的迭代器。返回时,调整迭代器进行广播。</target>
        </trans-unit>
        <trans-unit id="e3e82fd2fdc82899ac97dd9d7069f0c853f214d0" translate="yes" xml:space="preserve">
          <source>An array of numeric data can also be passed.</source>
          <target state="translated">也可以传递一个数字数据数组。</target>
        </trans-unit>
        <trans-unit id="ece80d1b5df43cd5fed015f36204934c9ec31960" translate="yes" xml:space="preserve">
          <source>An array of pointers to the actual data for the input and output arrays. The input arguments are given first followed by the output arguments.</source>
          <target state="translated">一个指向输入和输出数组的实际数据的指针数组。先给出输入参数,然后是输出参数。</target>
        </trans-unit>
        <trans-unit id="d47c875bafe38f3ae53b22be1ca5e1e026b9c87a" translate="yes" xml:space="preserve">
          <source>An array of start and end indexes if there are any masked data in the array. If there are no masked data in the array, &lt;code&gt;edges&lt;/code&gt; is a list of the first and last index.</source>
          <target state="translated">起始和结束索引数组，如果该数组中有任何被屏蔽的数据。如果数组中没有屏蔽的数据，则 &lt;code&gt;edges&lt;/code&gt; 是第一个和最后一个索引的列表。</target>
        </trans-unit>
        <trans-unit id="c7dec96e92acd76ab0b9a5089a0591ab494441f3" translate="yes" xml:space="preserve">
          <source>An array of strings the same shape as &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;arr&lt;/code&gt; 形状相同的字符串数组。</target>
        </trans-unit>
        <trans-unit id="4864cc2ae1f8d0267df4cabfa6aa6a6b4bbde15b" translate="yes" xml:space="preserve">
          <source>An array of the same shape as &lt;code&gt;x&lt;/code&gt;, containing the cube cube-root of each element in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;out&lt;/code&gt; was provided, &lt;code&gt;y&lt;/code&gt; is a reference to it. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相同形状的阵列 &lt;code&gt;x&lt;/code&gt; ，包含在每个元件的立方体立方根 &lt;code&gt;x&lt;/code&gt; 。如果提供 &lt;code&gt;out&lt;/code&gt; ，则 &lt;code&gt;y&lt;/code&gt; 是对其的引用。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="2dca043d37393a6e2fc85fdd287fdcbcb4dfecc0" translate="yes" xml:space="preserve">
          <source>An array of the same shape as &lt;code&gt;x&lt;/code&gt;, containing the positive square-root of each element in &lt;code&gt;x&lt;/code&gt;. If any element in &lt;code&gt;x&lt;/code&gt; is complex, a complex array is returned (and the square-roots of negative reals are calculated). If all of the elements in &lt;code&gt;x&lt;/code&gt; are real, so is &lt;code&gt;y&lt;/code&gt;, with negative elements returning &lt;code&gt;nan&lt;/code&gt;. If &lt;code&gt;out&lt;/code&gt; was provided, &lt;code&gt;y&lt;/code&gt; is a reference to it. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相同形状的阵列 &lt;code&gt;x&lt;/code&gt; ，包含在各元件的正平方根 &lt;code&gt;x&lt;/code&gt; 。如果 &lt;code&gt;x&lt;/code&gt; 中的任何元素为复数，则返回一个复数数组（并计算负实数的平方根）。如果 &lt;code&gt;x&lt;/code&gt; 中的所有元素都是实数，则 &lt;code&gt;y&lt;/code&gt; 也是实数，负元素返回 &lt;code&gt;nan&lt;/code&gt; 。如果提供 &lt;code&gt;out&lt;/code&gt; ，则 &lt;code&gt;y&lt;/code&gt; 是对其的引用。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="b73f11faf81ffda921b160f49100211ca44e9e3b" translate="yes" xml:space="preserve">
          <source>An array of the same type as &lt;code&gt;a&lt;/code&gt;, containing the rounded values. Unless &lt;code&gt;out&lt;/code&gt; was specified, a new array is created. A reference to the result is returned.</source>
          <target state="translated">相同类型的阵列 &lt;code&gt;a&lt;/code&gt; ，包含舍入值。除非指定了 &lt;code&gt;out&lt;/code&gt; ，否则将创建一个新数组。返回对结果的引用。</target>
        </trans-unit>
        <trans-unit id="979601eabdfd48b8ade710f0f03e8b5a86f0bf28" translate="yes" xml:space="preserve">
          <source>An array of values &lt;code&gt;w_i&lt;/code&gt; weighing each sample &lt;code&gt;(x_i, y_i)&lt;/code&gt;. Weights are normalized to 1 if &lt;code&gt;normed&lt;/code&gt; is True. If &lt;code&gt;normed&lt;/code&gt; is False, the values of the returned histogram are equal to the sum of the weights belonging to the samples falling into each bin.</source>
          <target state="translated">权重每个样本 &lt;code&gt;(x_i, y_i)&lt;/code&gt; 的值 &lt;code&gt;w_i&lt;/code&gt; 的数组。如果 &lt;code&gt;normed&lt;/code&gt; 为True，则将权重标准化为1 。如果 &lt;code&gt;normed&lt;/code&gt; 为False，则返回的直方图的值等于属于每个bin的样本的权重之和。</target>
        </trans-unit>
        <trans-unit id="e086307191e3a610d256fdc031206d0be076bb2f" translate="yes" xml:space="preserve">
          <source>An array of values &lt;code&gt;w_i&lt;/code&gt; weighing each sample &lt;code&gt;(x_i, y_i, z_i, &amp;hellip;)&lt;/code&gt;. Weights are normalized to 1 if normed is True. If normed is False, the values of the returned histogram are equal to the sum of the weights belonging to the samples falling into each bin.</source>
          <target state="translated">权重每个样本 &lt;code&gt;(x_i, y_i, z_i, &amp;hellip;)&lt;/code&gt; 的值 &lt;code&gt;w_i&lt;/code&gt; 的数组。如果标准为True，则将权重标准化为1。如果normed为False，则返回的直方图的值等于属于每个bin的样本的权重之和。</target>
        </trans-unit>
        <trans-unit id="c0ce1ac9c3e01f3e63767874318d5ec35c6c8162" translate="yes" xml:space="preserve">
          <source>An array of weights associated with the values in &lt;code&gt;a&lt;/code&gt;. Each value in &lt;code&gt;a&lt;/code&gt; contributes to the average according to its associated weight. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one.</source>
          <target state="translated">与所述值相关联的权重的阵列 &lt;code&gt;a&lt;/code&gt; 。中的每个值 &lt;code&gt;a&lt;/code&gt; 根据其相关联的重量有助于平均。权重数组可以是1-D（在这种情况下，其长度必须是沿给定轴的 &lt;code&gt;a&lt;/code&gt; 的大小）或与 &lt;code&gt;a&lt;/code&gt; 相同的形状。如果 &lt;code&gt;weights=None&lt;/code&gt; ，则假定 &lt;code&gt;a&lt;/code&gt; 中的所有数据的权重等于1。</target>
        </trans-unit>
        <trans-unit id="cc2b51a306ef6edd1f96be1bb988f9b49d26d1ac" translate="yes" xml:space="preserve">
          <source>An array of weights associated with the values in &lt;code&gt;a&lt;/code&gt;. Each value in &lt;code&gt;a&lt;/code&gt; contributes to the average according to its associated weight. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one. The 1-D calculation is:</source>
          <target state="translated">与所述值相关联的权重的阵列 &lt;code&gt;a&lt;/code&gt; 。中的每个值 &lt;code&gt;a&lt;/code&gt; 根据其相关联的重量有助于平均。权重数组可以是1-D（在这种情况下，其长度必须是沿给定轴的 &lt;code&gt;a&lt;/code&gt; 的大小）或与 &lt;code&gt;a&lt;/code&gt; 相同的形状。如果 &lt;code&gt;weights=None&lt;/code&gt; ，则假定 &lt;code&gt;a&lt;/code&gt; 中的所有数据的权重等于1。一维计算为：</target>
        </trans-unit>
        <trans-unit id="91d3b67fb93cc4bc7812921dd986159ce97b0f1e" translate="yes" xml:space="preserve">
          <source>An array of weights, of the same shape as &lt;code&gt;a&lt;/code&gt;. Each value in &lt;code&gt;a&lt;/code&gt; only contributes its associated weight towards the bin count (instead of 1). If &lt;code&gt;density&lt;/code&gt; is True, the weights are normalized, so that the integral of the density over the range remains 1.</source>
          <target state="translated">权重的阵列相同的形状的， &lt;code&gt;a&lt;/code&gt; 。每个中 &lt;code&gt;a&lt;/code&gt; 每个值仅将其关联权重分配给仓位计数（而不是1）。如果 &lt;code&gt;density&lt;/code&gt; 为True，则将权重标准化，以使该范围内的密度积分保持为1。</target>
        </trans-unit>
        <trans-unit id="e08534b68e928582028171965f68debd33645b68" translate="yes" xml:space="preserve">
          <source>An array of weights, of the same shape as &lt;code&gt;a&lt;/code&gt;. Each value in &lt;code&gt;a&lt;/code&gt; only contributes its associated weight towards the bin count (instead of 1). This is currently not used by any of the bin estimators, but may be in the future.</source>
          <target state="translated">权重的阵列相同的形状的， &lt;code&gt;a&lt;/code&gt; 。每个中 &lt;code&gt;a&lt;/code&gt; 每个值仅将其关联权重分配给仓位计数（而不是1）。目前，任何bin估算器均未使用此功能，但将来可能会使用。</target>
        </trans-unit>
        <trans-unit id="9f66c5b78a1ee6031ffac8fb1c853e09ee03b883" translate="yes" xml:space="preserve">
          <source>An array shaped as &lt;code&gt;a&lt;/code&gt; but with the specified axis removed. Returns a reference to &lt;code&gt;out&lt;/code&gt; if specified.</source>
          <target state="translated">形状为 &lt;code&gt;a&lt;/code&gt; 但删除指定轴的数组。返回对 &lt;code&gt;out&lt;/code&gt; 的引用（如果已指定）。</target>
        </trans-unit>
        <trans-unit id="dd19a4a55dabbf2abd322a5d60254e3015e9603b" translate="yes" xml:space="preserve">
          <source>An array that does not own its data, but refers to another array&amp;rsquo;s data instead. For example, we may create a view that only shows every second element of another array:</source>
          <target state="translated">一个不拥有其数据，而是引用另一个数组的数据的数组。例如，我们可以创建一个仅显示另一个数组的第二个元素的视图：</target>
        </trans-unit>
        <trans-unit id="28da6e5d441ca894170555ee158c5c43a7ecacb4" translate="yes" xml:space="preserve">
          <source>An array where all elements are equal to zero, except for the &lt;code&gt;k&lt;/code&gt;-th diagonal, whose values are equal to one.</source>
          <target state="translated">一个数组，其中所有元素均等于零，第 &lt;code&gt;k&lt;/code&gt; 个对角线除外，其值等于1。</target>
        </trans-unit>
        <trans-unit id="9b75a9f2449bf7b8b39aa7a14602f9d2a9c799dd" translate="yes" xml:space="preserve">
          <source>An array whose dtype is &lt;code&gt;object&lt;/code&gt;; that is, it contains references to Python objects. Indexing the array dereferences the Python objects, so unlike other ndarrays, an object array has the ability to hold heterogeneous objects.</source>
          <target state="translated">dtype为 &lt;code&gt;object&lt;/code&gt; 的数组；也就是说，它包含对Python对象的引用。索引数组会取消对Python对象的引用，因此与其他ndarrays不同，对象数组具有保存异构对象的能力。</target>
        </trans-unit>
        <trans-unit id="1ea1e5537016317a890a5d4a449f9cc2d733ed07" translate="yes" xml:space="preserve">
          <source>An array whose nonzero or True entries indicate the elements of &lt;code&gt;arr&lt;/code&gt; to extract.</source>
          <target state="translated">一个非零或True条目指示要提取的 &lt;code&gt;arr&lt;/code&gt; 元素的数组。</target>
        </trans-unit>
        <trans-unit id="c9db9bfd04f4def5fd1afc2affd0945adf42512d" translate="yes" xml:space="preserve">
          <source>An array with (possibly) masked elements.</source>
          <target state="translated">一个包含(可能)屏蔽元素的数组。</target>
        </trans-unit>
        <trans-unit id="f661a37bc1f34ccd31f28fc314368c36fc3fd521" translate="yes" xml:space="preserve">
          <source>An array with a shape from broadcasting &lt;code&gt;begindates&lt;/code&gt; and &lt;code&gt;enddates&lt;/code&gt; together, containing the number of valid days between the begin and end dates.</source>
          <target state="translated">从广播具有的形状的阵列 &lt;code&gt;begindates&lt;/code&gt; 和 &lt;code&gt;enddates&lt;/code&gt; 一起，含有有效的天数之间的开始和结束日期。</target>
        </trans-unit>
        <trans-unit id="da4b7ef06bb85fc991c331148db99f16620489ed" translate="yes" xml:space="preserve">
          <source>An array with a shape from broadcasting &lt;code&gt;dates&lt;/code&gt; and &lt;code&gt;offsets&lt;/code&gt; together, containing the dates with offsets applied.</source>
          <target state="translated">具有同时广播 &lt;code&gt;dates&lt;/code&gt; 和 &lt;code&gt;offsets&lt;/code&gt; 的形状的数组，其中包含应用了偏移量的日期。</target>
        </trans-unit>
        <trans-unit id="cb96764e2b9c06bb0ff9fb7ca3e50e3f3bfa36d0" translate="yes" xml:space="preserve">
          <source>An array with elements from &lt;code&gt;x&lt;/code&gt; where &lt;code&gt;condition&lt;/code&gt; is True, and elements from &lt;code&gt;y&lt;/code&gt; elsewhere.</source>
          <target state="translated">一个数组，其中 &lt;code&gt;condition&lt;/code&gt; 为True的 &lt;code&gt;x&lt;/code&gt; 元素，其他地方的 &lt;code&gt;y&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="1229c9f2e1287182eb9a66528204171c6010bc1b" translate="yes" xml:space="preserve">
          <source>An array with ones at and below the given diagonal and zeros elsewhere.</source>
          <target state="translated">一个数组,在给定的对角线上和下有1,其他地方有0。</target>
        </trans-unit>
        <trans-unit id="13f9e7222fb1b0027174f3c545f28e69a270792e" translate="yes" xml:space="preserve">
          <source>An array with the elements of &lt;code&gt;a&lt;/code&gt;, but where values &amp;lt; &lt;code&gt;a_min&lt;/code&gt; are replaced with &lt;code&gt;a_min&lt;/code&gt;, and those &amp;gt; &lt;code&gt;a_max&lt;/code&gt; with &lt;code&gt;a_max&lt;/code&gt;.</source>
          <target state="translated">用的元素的数组 &lt;code&gt;a&lt;/code&gt; ，但是其中值&amp;lt; &lt;code&gt;a_min&lt;/code&gt; 与替换 &lt;code&gt;a_min&lt;/code&gt; ，以及那些&amp;gt; &lt;code&gt;a_max&lt;/code&gt; 与 &lt;code&gt;a_max&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0d81681b563f7cbf7ca14e4beb55c0e61ff30a7" translate="yes" xml:space="preserve">
          <source>An array with the same shape as &lt;code&gt;a&lt;/code&gt;, with the specified axis removed. If &lt;code&gt;a&lt;/code&gt; is a 0-d array, or if &lt;code&gt;axis&lt;/code&gt; is None, a scalar is returned. If an output array is specified, a reference to &lt;code&gt;out&lt;/code&gt; is returned.</source>
          <target state="translated">具有相同形状的阵列 &lt;code&gt;a&lt;/code&gt; ，与所述指定的轴移除。如果 &lt;code&gt;a&lt;/code&gt; 是0-d数组，或者如果 &lt;code&gt;axis&lt;/code&gt; 为None，则返回标量。如果指定了输出数组，则返回对 &lt;code&gt;out&lt;/code&gt; 的引用。</target>
        </trans-unit>
        <trans-unit id="9baa9b65de91284b3761237390d81577243ec095" translate="yes" xml:space="preserve">
          <source>An array with the same shape as &lt;code&gt;a&lt;/code&gt;, with the specified axis removed. If &lt;code&gt;a&lt;/code&gt; is a 0-d array, or if axis is None, an ndarray scalar is returned. The same dtype as &lt;code&gt;a&lt;/code&gt; is returned.</source>
          <target state="translated">具有相同形状的阵列 &lt;code&gt;a&lt;/code&gt; ，与所述指定的轴移除。如果 &lt;code&gt;a&lt;/code&gt; 是0-d数组，或者axis是None，则返回ndarray标量。返回与 &lt;code&gt;a&lt;/code&gt; 相同的dtype 。</target>
        </trans-unit>
        <trans-unit id="e70abaa821cac7240773cdf6e7844c07f6b75f59" translate="yes" xml:space="preserve">
          <source>An array with the same shape as &lt;code&gt;dates&lt;/code&gt;, containing True for each valid day, and False for each invalid day.</source>
          <target state="translated">与 &lt;code&gt;dates&lt;/code&gt; 具有相同形状的数组，每个有效日包含True，每个无效日包含False。</target>
        </trans-unit>
        <trans-unit id="3dd1a7da3ce189a324136cbefbaa56e7594e5b61" translate="yes" xml:space="preserve">
          <source>An array with the same shape as the input array, with the specified axis removed. If the array is a 0-d array, or if &lt;code&gt;axis&lt;/code&gt; is None, a scalar is returned.</source>
          <target state="translated">与输入数组具有相同形状的数组，但移除了指定的轴。如果数组是0维数组，或者 &lt;code&gt;axis&lt;/code&gt; 为None，则返回标量。</target>
        </trans-unit>
        <trans-unit id="02c2325cc9f9529260815a39ebd69bc396f69b18" translate="yes" xml:space="preserve">
          <source>An array, any object exposing the array interface, an object whose __array__ method returns an array, or any (nested) sequence.</source>
          <target state="translated">一个数组,任何暴露数组接口的对象,一个其__array__方法返回数组的对象,或者任何(嵌套的)序列。</target>
        </trans-unit>
        <trans-unit id="567f786634fc5daa235d994c1657787eea4b779a" translate="yes" xml:space="preserve">
          <source>An array, or list of arrays, each with &lt;code&gt;a.ndim &amp;gt;= 1&lt;/code&gt;. Copies are made only if necessary.</source>
          <target state="translated">一个数组或数组列表，每个数组的 &lt;code&gt;a.ndim &amp;gt;= 1&lt;/code&gt; 。仅在必要时进行复印。</target>
        </trans-unit>
        <trans-unit id="cba647ea9fdf896d7caaed5b946ba91dc1f4274e" translate="yes" xml:space="preserve">
          <source>An array, or list of arrays, each with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt;. Copies are avoided where possible, and views with two or more dimensions are returned.</source>
          <target state="translated">一个数组或数组列表，每个数组的 &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; 。尽可能避免复制，并返回二维或二维视图。</target>
        </trans-unit>
        <trans-unit id="20047f5be3a0546654cf45798129be0ced7cf529" translate="yes" xml:space="preserve">
          <source>An array, or list of arrays, each with &lt;code&gt;a.ndim &amp;gt;= 3&lt;/code&gt;. Copies are avoided where possible, and views with three or more dimensions are returned. For example, a 1-D array of shape &lt;code&gt;(N,)&lt;/code&gt; becomes a view of shape &lt;code&gt;(1, N, 1)&lt;/code&gt;, and a 2-D array of shape &lt;code&gt;(M, N)&lt;/code&gt; becomes a view of shape &lt;code&gt;(M, N, 1)&lt;/code&gt;.</source>
          <target state="translated">一个数组或数组列表，每个数组的 &lt;code&gt;a.ndim &amp;gt;= 3&lt;/code&gt; 。尽可能避免复制，并返回三个或更多尺寸的视图。例如，形状 &lt;code&gt;(N,)&lt;/code&gt; 的一维数组成为形状 &lt;code&gt;(1, N, 1)&lt;/code&gt; 的视图，形状 &lt;code&gt;(M, N, 1)&lt;/code&gt; &lt;code&gt;(M, N)&lt;/code&gt; 的二维数组成为形状（M，N，的视图）1）。</target>
        </trans-unit>
        <trans-unit id="f2d598faf58dcce518852d1c23ec2af6d3886d1a" translate="yes" xml:space="preserve">
          <source>An assertion is raised if the following condition is not met:</source>
          <target state="translated">如果不满足以下条件,就会提出断言。</target>
        </trans-unit>
        <trans-unit id="c3adef5312938abeed5e9919b7facafa03477317" translate="yes" xml:space="preserve">
          <source>An assignment example:</source>
          <target state="translated">一个任务实例。</target>
        </trans-unit>
        <trans-unit id="5b8cae1664bf34207082790eecd4cff8bc80d113" translate="yes" xml:space="preserve">
          <source>An authority is a person who can tell you more about something than you really care to know. &amp;mdash; &lt;em&gt;Unknown&lt;/em&gt;</source>
          <target state="translated">权威是一个可以告诉您更多事情的人，而您并不是真正想知道的事情。&amp;mdash; &lt;em&gt;未知&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8abc81a5a743ea9f021fdfc70f53e317bae852f" translate="yes" xml:space="preserve">
          <source>An easier way of casting the data to a specific dtype and byte ordering can be achieved with the ndarray astype method:</source>
          <target state="translated">使用ndarray astype方法可以更容易地将数据转换为特定的dtype和字节排序。</target>
        </trans-unit>
        <trans-unit id="a06ba8b5680e861b82812d380d7c8f04108d181f" translate="yes" xml:space="preserve">
          <source>An element of a structured datatype that behaves like an ndarray.</source>
          <target state="translated">一个结构化数据类型的元素,它的行为就像一个ndarray。</target>
        </trans-unit>
        <trans-unit id="88aa14c58828551e162cc4a4661a6843968586b6" translate="yes" xml:space="preserve">
          <source>An empty (tuple) index is a full scalar index into a zero dimensional array. &lt;code&gt;x[()]&lt;/code&gt; returns a &lt;em&gt;scalar&lt;/em&gt; if &lt;code&gt;x&lt;/code&gt; is zero dimensional and a view otherwise. On the other hand &lt;code&gt;x[...]&lt;/code&gt; always returns a view.</source>
          <target state="translated">空（元组）索引是零维数组中的完整标量索引。如果 &lt;code&gt;x&lt;/code&gt; 为零维，则 &lt;code&gt;x[()]&lt;/code&gt; 返回&lt;em&gt;标量，&lt;/em&gt;否则返回视图。另一方面， &lt;code&gt;x[...]&lt;/code&gt; 总是返回视图。</target>
        </trans-unit>
        <trans-unit id="9f8fe74c5bf94bc803b1bb945a029de2c98e9baa" translate="yes" xml:space="preserve">
          <source>An enumeration type indicating how permissive data conversions should be. This is used by the iterator added in NumPy 1.6, and is intended to be used more broadly in a future version.</source>
          <target state="translated">一个枚举类型,表示数据转换的允许性。这是NumPy 1.6中添加的迭代器所使用的,并打算在未来的版本中更广泛地使用。</target>
        </trans-unit>
        <trans-unit id="f076fadc0ee0a286669da0779a627fc24ddf6053" translate="yes" xml:space="preserve">
          <source>An enumeration type indicating the element order that an array should be interpreted in. When a brand new array is created, generally only &lt;strong&gt;NPY_CORDER&lt;/strong&gt; and &lt;strong&gt;NPY_FORTRANORDER&lt;/strong&gt; are used, whereas when one or more inputs are provided, the order can be based on them.</source>
          <target state="translated">枚举类型，指示应解释数组的元素顺序。创建全新数组时，通常仅使用&lt;strong&gt;NPY_CORDER&lt;/strong&gt;和&lt;strong&gt;NPY_FORTRANORDER&lt;/strong&gt;，而在提供一个或多个输入时，顺序可以基于它们。</target>
        </trans-unit>
        <trans-unit id="9ea26de5566952ec524cedbb60ee90bf6c1be0e2" translate="yes" xml:space="preserve">
          <source>An example</source>
          <target state="translated">一个例子</target>
        </trans-unit>
        <trans-unit id="6e2daf8ca86e15a2e24ed018141a980cd426e388" translate="yes" xml:space="preserve">
          <source>An example Python session would be identical to the previous example except that argument names would differ.</source>
          <target state="translated">除了参数名不同之外,Python 会话的例子和前面的例子是一样的。</target>
        </trans-unit>
        <trans-unit id="edf41c0b27774c1df8aed12edb2351eadd7f38b3" translate="yes" xml:space="preserve">
          <source>An example castfunc is:</source>
          <target state="translated">一个例子是Castfunc。</target>
        </trans-unit>
        <trans-unit id="64e8f4d7015b6070bf3f50c3e64f0fbef756b878" translate="yes" xml:space="preserve">
          <source>An example from Glantz[1], pp 47-40:</source>
          <target state="translated">格兰茨的例子[1],第47-40页。</target>
        </trans-unit>
        <trans-unit id="1ad321a0ede9c3a9da071e8e5fe72a77cf61d678" translate="yes" xml:space="preserve">
          <source>An example of a non-associative case:</source>
          <target state="translated">一个非关联案例的例子。</target>
        </trans-unit>
        <trans-unit id="21524e2813ff9dc11cf1667f630888b770b6f890" translate="yes" xml:space="preserve">
          <source>An example of broadcasting in practice:</source>
          <target state="translated">一个广播实践的例子。</target>
        </trans-unit>
        <trans-unit id="c9441160929c1f5a53f0eec18887501ddb4a68eb" translate="yes" xml:space="preserve">
          <source>An example of using the config header in light of the above:</source>
          <target state="translated">根据上述情况,举一个使用config头的例子。</target>
        </trans-unit>
        <trans-unit id="dd2a4a70d420aa2d3935775486296bc45b66a315" translate="yes" xml:space="preserve">
          <source>An example of where this may be useful is for a color lookup table where we want to map the values of an image into RGB triples for display. The lookup table could have a shape (nlookup, 3). Indexing such an array with an image with shape (ny, nx) with dtype=np.uint8 (or any integer type so long as values are with the bounds of the lookup table) will result in an array of shape (ny, nx, 3) where a triple of RGB values is associated with each pixel location.</source>
          <target state="translated">一个有用的例子是颜色查找表,我们想把图像的值映射成RGB三原色来显示。查找表可以有一个形状(nlookup,3)。用一个形状为(ny,nx),dtype=np.uint8(或任何整数类型,只要数值在查找表的范围内)的图像索引这样一个数组,将得到一个形状为(ny,nx,3)的数组,其中RGB值的三倍与每个像素位置相关联。</target>
        </trans-unit>
        <trans-unit id="92bcbe60f6b1cdb52a7d953fc81ff3369b0f2592" translate="yes" xml:space="preserve">
          <source>An example to show comments</source>
          <target state="translated">举例说明评论</target>
        </trans-unit>
        <trans-unit id="ab59fb864b641fc21102fa6867c9f294d4d4a6b9" translate="yes" xml:space="preserve">
          <source>An example using a &amp;ldquo;vector&amp;rdquo; of letters:</source>
          <target state="translated">一个使用字母&amp;ldquo;向量&amp;rdquo;的示例：</target>
        </trans-unit>
        <trans-unit id="ae67380a5d930011edb475d7e700cc0a79c17af2" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;b&lt;/code&gt; is a scalar:</source>
          <target state="translated">一个示例，其中 &lt;code&gt;b&lt;/code&gt; 是标量：</target>
        </trans-unit>
        <trans-unit id="94faf0f11390e7c87a6db1e320054aa5b39eed5b" translate="yes" xml:space="preserve">
          <source>An example with fixed-width columns</source>
          <target state="translated">固定宽度列的例子</target>
        </trans-unit>
        <trans-unit id="ee3a8754bce53d43d3e15790bf69e69f40787cb1" translate="yes" xml:space="preserve">
          <source>An extended example taking advantage of the overloading of + and *:</source>
          <target state="translated">一个利用+和*的重载的扩展例子。</target>
        </trans-unit>
        <trans-unit id="153bca2420915680d942ae459053fce685c8d220" translate="yes" xml:space="preserve">
          <source>An extensive list of tools for scientific work with Python can be found in the &lt;a href=&quot;https://scipy.org/topical-software.html&quot;&gt;topical software page&lt;/a&gt;.</source>
          <target state="translated">可以在&lt;a href=&quot;https://scipy.org/topical-software.html&quot;&gt;主题软件页面中&lt;/a&gt;找到使用Python进行科学工作的大量工具列表。</target>
        </trans-unit>
        <trans-unit id="3f1f5040c3fab0c8014dea349166afc8130d9681" translate="yes" xml:space="preserve">
          <source>An extensive list of tools for scientific work with python can be found in the &lt;a href=&quot;https://scipy.org/topical-software.html&quot;&gt;topical software page&lt;/a&gt;.</source>
          <target state="translated">可以在&lt;a href=&quot;https://scipy.org/topical-software.html&quot;&gt;主题软件页面中&lt;/a&gt;找到使用python进行科学工作的大量工具列表。</target>
        </trans-unit>
        <trans-unit id="41352b04320eefbd12c3e75a33715bda727551fe" translate="yes" xml:space="preserve">
          <source>An important distinction for these methods is how they handle the &lt;code&gt;axis&lt;/code&gt; parameter. Both &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt;&lt;code&gt;Generator.shuffle&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt;&lt;code&gt;Generator.permutation&lt;/code&gt;&lt;/a&gt; treat the input as a one-dimensional sequence, and the &lt;code&gt;axis&lt;/code&gt; parameter determines which dimension of the input array to use as the sequence. In the case of a two-dimensional array, &lt;code&gt;axis=0&lt;/code&gt; will, in effect, rearrange the rows of the array, and &lt;code&gt;axis=1&lt;/code&gt; will rearrange the columns. For example</source>
          <target state="translated">这些方法的重要区别是它们如何处理 &lt;code&gt;axis&lt;/code&gt; 参数。既&lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt; &lt;code&gt;Generator.shuffle&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt; &lt;code&gt;Generator.permutation&lt;/code&gt; &lt;/a&gt;处理输入作为一维序列，并且 &lt;code&gt;axis&lt;/code&gt; 参数确定其中输入阵列用作序列的尺寸。在二维数组的情况下， &lt;code&gt;axis=0&lt;/code&gt; 实际上将重新排列数组的行，而 &lt;code&gt;axis=1&lt;/code&gt; 将重新排列列。例如</target>
        </trans-unit>
        <trans-unit id="234994ab6fdb07f0421cdf6417fa8d08aaed3974" translate="yes" xml:space="preserve">
          <source>An important thing to be aware of for this iteration is that the order is chosen to match the memory layout of the array instead of using a standard C or Fortran ordering. This is done for access efficiency, reflecting the idea that by default one simply wants to visit each element without concern for a particular ordering. We can see this by iterating over the transpose of our previous array, compared to taking a copy of that transpose in C order.</source>
          <target state="translated">对于这个迭代,需要注意的一个重要问题是,顺序的选择是为了匹配数组的内存布局,而不是使用标准的C或Fortran排序。这样做是为了提高访问效率,反映了默认情况下人们只想访问每个元素而不关心特定的顺序。我们可以通过迭代前一个数组的转置来了解这一点,相比之下,我们可以按C顺序取一个该转置的副本。</target>
        </trans-unit>
        <trans-unit id="ce8e2f3f33d5cad8aca5e828b4984abc49c8c85d" translate="yes" xml:space="preserve">
          <source>An improved version of Sturges&amp;rsquo; estimator that works better with non-normal datasets.</source>
          <target state="translated">Sturges估计器的改进版本，可以更好地与非常规数据集一起使用。</target>
        </trans-unit>
        <trans-unit id="f04b75dbec8a648ba0471c30efe8cb82bf3011bd" translate="yes" xml:space="preserve">
          <source>An improved version of Sturges&amp;rsquo; formula that produces better estimates for non-normal datasets. This estimator attempts to account for the skew of the data.</source>
          <target state="translated">Sturges公式的改进版本，可以为非正态数据集提供更好的估计。此估算器尝试考虑数据的偏斜。</target>
        </trans-unit>
        <trans-unit id="6c0daf8923a8ff879a417d16aa3697c8609e06f7" translate="yes" xml:space="preserve">
          <source>An index which matches the order of iteration.</source>
          <target state="translated">一个符合迭代顺序的索引。</target>
        </trans-unit>
        <trans-unit id="fd3ef13b14659602803a66f38a194c91b0d16c51" translate="yes" xml:space="preserve">
          <source>An input can be used in the calculation if its size in a particular dimension either matches the output size in that dimension, or has value exactly 1.</source>
          <target state="translated">如果一个输入在特定维度上的尺寸与输出尺寸相匹配,或者其值正好是1,那么这个输入就可以被用于计算。</target>
        </trans-unit>
        <trans-unit id="24428e2d87c0033a748d11a9f2ce4caa1e91c810" translate="yes" xml:space="preserve">
          <source>An input object.</source>
          <target state="translated">一个输入对象。</target>
        </trans-unit>
        <trans-unit id="ccd98d417809c28451b9172282e9fd64d1c41e89" translate="yes" xml:space="preserve">
          <source>An instance of &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; can be thought as the combination of several elements:</source>
          <target state="translated">可以将&lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;的实例视为几个元素的组合：</target>
        </trans-unit>
        <trans-unit id="cc6e3d42720c490f4a7b292acd6a9d04e387f93f" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;numpy.lib.index_tricks.nd_grid&lt;/code&gt; which returns an dense (or fleshed out) mesh-grid when indexed, so that each returned argument has the same shape. The dimensions and number of the output arrays are equal to the number of indexing dimensions. If the step length is not a complex number, then the stop is not inclusive.</source>
          <target state="translated">&lt;code&gt;numpy.lib.index_tricks.nd_grid&lt;/code&gt; 的一个实例，该实例在建立索引时返回密集的（或充实的）网格网格，以便每个返回的参数具有相同的形状。输出数组的尺寸和数量等于索引尺寸的数量。如果步长不是复数，则停止不包括在内。</target>
        </trans-unit>
        <trans-unit id="634a502415ebc5263dc90361e50dd67e1f0e70b8" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;numpy.lib.index_tricks.nd_grid&lt;/code&gt; which returns an open (i.e. not fleshed out) mesh-grid when indexed, so that only one dimension of each returned array is greater than 1. The dimension and number of the output arrays are equal to the number of indexing dimensions. If the step length is not a complex number, then the stop is not inclusive.</source>
          <target state="translated">&lt;code&gt;numpy.lib.index_tricks.nd_grid&lt;/code&gt; 的一个实例，该实例在建立索引时返回一个开放的（即未充实的）网格网格，因此每个返回数组的一个维数都大于1。输出数组的维数和数量相等索引尺寸的数量。如果步长不是复数，则停止不包括在内。</target>
        </trans-unit>
        <trans-unit id="3ea316e4ad89d0b127e75fd6f9a3da36dffed3ba" translate="yes" xml:space="preserve">
          <source>An instance of class &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; consists of a contiguous one-dimensional segment of computer memory (owned by the array, or by some other object), combined with an indexing scheme that maps &lt;em&gt;N&lt;/em&gt; integers into the location of an item in the block. The ranges in which the indices can vary is specified by the &lt;a href=&quot;generated/numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; of the array. How many bytes each item takes and how the bytes are interpreted is defined by the &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;data-type object&lt;/a&gt; associated with the array.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;类的实例由计算机内存的连续一维段（由数组或某个其他对象拥有）组成，并与将&lt;em&gt;N个&lt;/em&gt;整数映射到块中某个项的位置的索引方案结合在一起。索引可以变化的范围由数组的&lt;a href=&quot;generated/numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;指定。每个项目占用多少字节以及如何解释字节由与数组关联的&lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;数据类型对象&lt;/a&gt;定义。</target>
        </trans-unit>
        <trans-unit id="6e1c5ac8d50b25041dc87f2c7519eb1a86058078" translate="yes" xml:space="preserve">
          <source>An integer array whose elements are indices into the flattened version of an array of dimensions &lt;code&gt;shape&lt;/code&gt;. Before version 1.6.0, this function accepted just one index value.</source>
          <target state="translated">一个整数数组，其元素是尺寸 &lt;code&gt;shape&lt;/code&gt; 数组的扁平化版本的索引。在1.6.0版之前，此函数仅接受一个索引值。</target>
        </trans-unit>
        <trans-unit id="4276a3e1422ad086a54d759953deada7066bbc35" translate="yes" xml:space="preserve">
          <source>An integer as a dimension name freezes that dimension to the value.</source>
          <target state="translated">一个整数作为维度名称冻结该维度的值。</target>
        </trans-unit>
        <trans-unit id="1fa126ddddd0a6a8da1f0e66c4d42624e8184e08" translate="yes" xml:space="preserve">
          <source>An integer offset into the array data region. This can only be used when data is &lt;code&gt;None&lt;/code&gt; or returns a &lt;code&gt;buffer&lt;/code&gt; object.</source>
          <target state="translated">数组数据区域的整数偏移量。仅当数据为 &lt;code&gt;None&lt;/code&gt; 或返回 &lt;code&gt;buffer&lt;/code&gt; 对象时，才可以使用此方法。</target>
        </trans-unit>
        <trans-unit id="208ac298af4fe8503099d4537d939f78fa068387" translate="yes" xml:space="preserve">
          <source>An integer offset into the array data region. This can only be used when data is None or returns a &lt;code&gt;buffer&lt;/code&gt; object.</source>
          <target state="translated">数组数据区域的整数偏移量。仅当数据为None或返回 &lt;code&gt;buffer&lt;/code&gt; 对象时，才可以使用此方法。</target>
        </trans-unit>
        <trans-unit id="7827031c1e4779ee518d6bbc19386c165a21aa2f" translate="yes" xml:space="preserve">
          <source>An integer providing the number of dimensions for this array. When nd is 0, the array is sometimes called a rank-0 array. Such arrays have undefined dimensions and strides and cannot be accessed. &lt;a href=&quot;c-api.array#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; is the largest number of dimensions for any array.</source>
          <target state="translated">一个整数，提供此数组的维数。当nd为0时，该数组有时称为Rank-0数组。这样的数组具有不确定的尺寸和跨度，无法访问。&lt;a href=&quot;c-api.array#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; &lt;/a&gt;是任何数组中最大数量的维。</target>
        </trans-unit>
        <trans-unit id="98a7f29877575db550ac35bbad96c05eb4cb8962" translate="yes" xml:space="preserve">
          <source>An integer providing the number of dimensions for this array. When nd is 0, the array is sometimes called a rank-0 array. Such arrays have undefined dimensions and strides and cannot be accessed. Macro &lt;a href=&quot;array#c.PyArray_NDIM&quot;&gt;&lt;code&gt;PyArray_NDIM&lt;/code&gt;&lt;/a&gt; defined in &lt;code&gt;ndarraytypes.h&lt;/code&gt; points to this data member. &lt;a href=&quot;array#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; is the largest number of dimensions for any array.</source>
          <target state="translated">一个整数，提供此数组的维数。当nd为0时，该数组有时称为Rank-0数组。这样的数组具有不确定的尺寸和步幅，无法访问。宏&lt;a href=&quot;array#c.PyArray_NDIM&quot;&gt; &lt;code&gt;PyArray_NDIM&lt;/code&gt; &lt;/a&gt;中定义 &lt;code&gt;ndarraytypes.h&lt;/code&gt; 指向该数据成员。&lt;a href=&quot;array#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; &lt;/a&gt;是任何数组中最大数量的维。</target>
        </trans-unit>
        <trans-unit id="740a8c0291954a1fc0b575bf55fa7f345ee70e49" translate="yes" xml:space="preserve">
          <source>An integer showing the version of the interface (i.e. 3 for this version). Be careful not to use this to invalidate objects exposing future versions of the interface.</source>
          <target state="translated">一个整数,显示接口的版本(例如3代表这个版本)。注意不要用它来使暴露接口未来版本的对象无效。</target>
        </trans-unit>
        <trans-unit id="d87fed7bbbc954e477fb70394a40418f3fdbf745" translate="yes" xml:space="preserve">
          <source>An integer, &lt;em&gt;i&lt;/em&gt;, returns the same values as &lt;code&gt;i:i+1&lt;/code&gt;&lt;strong&gt;except&lt;/strong&gt; the dimensionality of the returned object is reduced by 1. In particular, a selection tuple with the &lt;em&gt;p&lt;/em&gt;-th element an integer (and all other entries &lt;code&gt;:&lt;/code&gt;) returns the corresponding sub-array with dimension &lt;em&gt;N - 1&lt;/em&gt;. If &lt;em&gt;N = 1&lt;/em&gt; then the returned object is an array scalar. These objects are explained in &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;Scalars&lt;/a&gt;.</source>
          <target state="translated">的整数，&lt;em&gt;我&lt;/em&gt;，返回相同的值作为 &lt;code&gt;i:i+1&lt;/code&gt; &lt;strong&gt;不同之处&lt;/strong&gt;返回的对象的维数由1。特别地降低，选择元组与所述&lt;em&gt;p&lt;/em&gt;个元素的整数（以及所有其它条目 &lt;code&gt;:&lt;/code&gt; ）返回尺寸为&lt;em&gt;N-1的&lt;/em&gt;对应子数组。如果&lt;em&gt;N = 1，&lt;/em&gt;则返回的对象是数组标量。这些对象在&lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;Scalars中&lt;/a&gt;进行了说明。</target>
        </trans-unit>
        <trans-unit id="73fd3d8e22c91d0b01a5e0d96a1a194d3f402dd7" translate="yes" xml:space="preserve">
          <source>An introduction to the concepts discussed here</source>
          <target state="translated">对这里讨论的概念的介绍</target>
        </trans-unit>
        <trans-unit id="9337d47802d85cb5aefc4c6ec7749f6fe4d0f859" translate="yes" xml:space="preserve">
          <source>An introduction, with definitions and general explanations.</source>
          <target state="translated">介绍,包括定义和一般解释;</target>
        </trans-unit>
        <trans-unit id="0e55a620091e71a89cb39a3c09fd5cc874040b26" translate="yes" xml:space="preserve">
          <source>An item extracted from an array, &lt;em&gt;e.g.&lt;/em&gt;, by indexing, is represented by a Python object whose type is one of the &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar types&lt;/a&gt; built in NumPy. The array scalars allow easy manipulation of also more complicated arrangements of data.</source>
          <target state="translated">从数组中提取的项目（&lt;em&gt;例如&lt;/em&gt;通过索引）由Python对象表示，该对象的类型是NumPy中内置的&lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;数组标量类型&lt;/a&gt;之一。数组标量允许轻松处理更复杂的数据排列。</target>
        </trans-unit>
        <trans-unit id="de99db091c92a4334b9f2bbfb02c196f89f1e72f" translate="yes" xml:space="preserve">
          <source>An iterable object providing data for the array.</source>
          <target state="translated">一个为数组提供数据的可迭代对象。</target>
        </trans-unit>
        <trans-unit id="c2c683940adaf3e17b5b2d4dbfdc8fb1f9285bc0" translate="yes" xml:space="preserve">
          <source>An masked array with &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; elements where the condition is masked, elements from &lt;code&gt;x&lt;/code&gt; where &lt;code&gt;condition&lt;/code&gt; is True, and elements from &lt;code&gt;y&lt;/code&gt; elsewhere.</source>
          <target state="translated">一个掩蔽阵列&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;元素，其中的条件被屏蔽，从元件 &lt;code&gt;x&lt;/code&gt; ，其中 &lt;code&gt;condition&lt;/code&gt; 为True，和元件从 &lt;code&gt;y&lt;/code&gt; 别处。</target>
        </trans-unit>
        <trans-unit id="8ce742f07c8b93ebe9e87ec17c3c1ca6bc05421b" translate="yes" xml:space="preserve">
          <source>An ndarray can have a data segment that is not a simple contiguous chunk of well-behaved memory you can manipulate. It may not be aligned with word boundaries (very important on some platforms). It might have its data in a different byte-order than the machine recognizes. It might not be writeable. It might be in Fortan-contiguous order. The array flags are used to indicate what can be said about data associated with an array.</source>
          <target state="translated">一个ndarray可以有一个数据段,它不是一个简单的连续的大块乖巧的内存,你可以操作。它可能不与字的边界对齐(在某些平台上非常重要)。它的数据可能与机器识别的字节顺序不同。它可能是不可写的。它可能是以Fortan连续顺序排列的。数组标志用于指示与数组相关联的数据的内容。</target>
        </trans-unit>
        <trans-unit id="bb779643bca7bbe52a88ddd4236e7e3d90ebda9e" translate="yes" xml:space="preserve">
          <source>An ndarray can have a data segment that is not a simple contiguous chunk of well-behaved memory you can manipulate. It may not be aligned with word boundaries (very important on some platforms). It might have its data in a different byte-order than the machine recognizes. It might not be writeable. It might be in Fortran-contiguous order. The array flags are used to indicate what can be said about data associated with an array.</source>
          <target state="translated">一个ndarray可以有一个数据段,它不是一个简单的连续的大块乖巧的内存,你可以操作。它可能不与字的边界对齐(在某些平台上非常重要)。它的数据可能与机器识别的字节顺序不同。它可能是不可写的。它可能是Fortran连续顺序的。数组标志用于指示与数组相关联的数据的内容。</target>
        </trans-unit>
        <trans-unit id="84038cf3f95c6f7f876de572eb50dcdd65ebb4e5" translate="yes" xml:space="preserve">
          <source>An ndarray containing the absolute value of each element in &lt;code&gt;x&lt;/code&gt;. For complex input, &lt;code&gt;a + ib&lt;/code&gt;, the absolute value is</source>
          <target state="translated">包含 &lt;code&gt;x&lt;/code&gt; 中每个元素的绝对值的ndarray 。对于复数输入 &lt;code&gt;a + ib&lt;/code&gt; ，绝对值为</target>
        </trans-unit>
        <trans-unit id="937ff1e9853b1d8bb7896ced9c9a3c640f4a20fd" translate="yes" xml:space="preserve">
          <source>An ndarray of appropriate shape and dtype, filled with False.</source>
          <target state="translated">一个适当形状和dtype的ndarray,用False填充。</target>
        </trans-unit>
        <trans-unit id="a5ee74273207da7ae537266764fb0a696c970cac" translate="yes" xml:space="preserve">
          <source>An nditer for each item in &lt;code&gt;axes&lt;/code&gt;, outermost first</source>
          <target state="translated">在每个项目nditer &lt;code&gt;axes&lt;/code&gt; ，最外侧的第一</target>
        </trans-unit>
        <trans-unit id="d7605eba941666733600a4275983300b4a00400c" translate="yes" xml:space="preserve">
          <source>An ndpointer instance is used to describe an ndarray in restypes and argtypes specifications. This approach is more flexible than using, for example, &lt;code&gt;POINTER(c_double)&lt;/code&gt;, since several restrictions can be specified, which are verified upon calling the ctypes function. These include data type, number of dimensions, shape and flags. If a given array does not satisfy the specified restrictions, a &lt;code&gt;TypeError&lt;/code&gt; is raised.</source>
          <target state="translated">ndpointer实例用于描述restypes和argtypes规范中的ndarray。与可以使用例如 &lt;code&gt;POINTER(c_double)&lt;/code&gt; 相比，此方法更加灵活，因为可以指定几个限制，这些限制可以在调用ctypes函数时进行验证。这些包括数据类型，维数，形状和标志。如果给定数组不满足指定限制，则引发 &lt;code&gt;TypeError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7417872fe9adc5a45fba54aa51c9ae05347385d3" translate="yes" xml:space="preserve">
          <source>An object representing &lt;a href=&quot;arrays.scalars#numpy.number&quot;&gt;&lt;code&gt;numpy.number&lt;/code&gt;&lt;/a&gt; precision during static type checking.</source>
          <target state="translated">静态类型检查期间表示&lt;a href=&quot;arrays.scalars#numpy.number&quot;&gt; &lt;code&gt;numpy.number&lt;/code&gt; &lt;/a&gt;精度的对象。</target>
        </trans-unit>
        <trans-unit id="8249a78054c0cb82583f75cad623801b99c6e816" translate="yes" xml:space="preserve">
          <source>An object that can be passed as an argument to the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt; constructor to create the array&amp;rsquo;s dtype.</source>
          <target state="translated">可以作为参数传递给&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;numpy.dtype&lt;/code&gt; &lt;/a&gt;构造函数的对象，以创建数组的dtype。</target>
        </trans-unit>
        <trans-unit id="51b070f54d715dc3c886991b214975d29e065cb3" translate="yes" xml:space="preserve">
          <source>An object that can be queried for it&amp;rsquo;s numeric type.</source>
          <target state="translated">可以查询其数字类型的对象。</target>
        </trans-unit>
        <trans-unit id="cb7089d647c1b86db71967874a04b75f15c4139e" translate="yes" xml:space="preserve">
          <source>An object that cannot be modified after execution is called immutable. Two common examples are strings and tuples.</source>
          <target state="translated">执行后不能修改的对象称为不可变。两个常见的例子是字符串和元组。</target>
        </trans-unit>
        <trans-unit id="757fdfd1c89cb8f173de4247aa51861595590920" translate="yes" xml:space="preserve">
          <source>An object that exposes the buffer interface.</source>
          <target state="translated">一个暴露缓冲区接口的对象。</target>
        </trans-unit>
        <trans-unit id="9aa10d88b8c5173358367cce862fb4a6d6fc0051" translate="yes" xml:space="preserve">
          <source>An object that specifies a custom set of valid days.</source>
          <target state="translated">一个指定自定义有效天数集的对象。</target>
        </trans-unit>
        <trans-unit id="9697eabfa36a0c57b03730a9e63e9c0dd7cc2d09" translate="yes" xml:space="preserve">
          <source>An object to simplify the interaction of the array with the ctypes module.</source>
          <target state="translated">用于简化数组与ctypes模块的交互的对象。</target>
        </trans-unit>
        <trans-unit id="77d04ad5d02d58a854d2c57fda919f98926805a2" translate="yes" xml:space="preserve">
          <source>An offset can be passed also to the masking function. This gets us the indices starting on the first diagonal right of the main one:</source>
          <target state="translated">一个偏移量也可以传递给掩码函数。这样我们就可以得到从主索引右边第一条对角线开始的索引。</target>
        </trans-unit>
        <trans-unit id="e7bb40a65a5fed271af7ea895f0c3a327894df3e" translate="yes" xml:space="preserve">
          <source>An open file object, or a string containing a filename.</source>
          <target state="translated">一个打开的文件对象,或者一个包含文件名的字符串。</target>
        </trans-unit>
        <trans-unit id="d961e30e446f529b34e65541eef1f1abf1c657fc" translate="yes" xml:space="preserve">
          <source>An operation &lt;code&gt;along axis n&lt;/code&gt; of array &lt;code&gt;a&lt;/code&gt; behaves as if its argument were an array of slices of &lt;code&gt;a&lt;/code&gt; where each slice has a successive index of axis &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">操作 &lt;code&gt;along axis n&lt;/code&gt; 阵列的 &lt;code&gt;a&lt;/code&gt; 表现为好像其参数是的切片的阵列 &lt;code&gt;a&lt;/code&gt; ，其中每个切片具有轴线的连续索引 &lt;code&gt;n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe21301c43ae5617db256d71e7099b9d072912c3" translate="yes" xml:space="preserve">
          <source>An operator that transforms a function. For example, a &lt;code&gt;log&lt;/code&gt; decorator may be defined to print debugging information upon function execution:</source>
          <target state="translated">转换函数的运算符。例如，可以定义一个 &lt;code&gt;log&lt;/code&gt; 装饰器以在函数执行时打印调试信息：</target>
        </trans-unit>
        <trans-unit id="c61177b92fd6e93436d3f1589cdd0e84373a28c0" translate="yes" xml:space="preserve">
          <source>An optional argument which is passed through to &lt;code&gt;mask_func&lt;/code&gt;. Functions like &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt;&lt;code&gt;triu&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt;&lt;code&gt;tril&lt;/code&gt;&lt;/a&gt; take a second argument that is interpreted as an offset.</source>
          <target state="translated">传递给 &lt;code&gt;mask_func&lt;/code&gt; 的可选参数。诸如&lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt; &lt;code&gt;triu&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt; &lt;code&gt;tril&lt;/code&gt; 之&lt;/a&gt;类的函数采用第二个参数，该参数被解释为偏移量。</target>
        </trans-unit>
        <trans-unit id="6ed67195e81edd8b8281aeaf900064fe84cfec71" translate="yes" xml:space="preserve">
          <source>An optional section detailing which errors get raised and under what conditions:</source>
          <target state="translated">一个可选的部分,详细说明在什么情况下会出现哪些错误。</target>
        </trans-unit>
        <trans-unit id="1ae26e0d878e399f66a265f5cebede9ebffc3136" translate="yes" xml:space="preserve">
          <source>An optional section detailing which warnings get raised and under what conditions, formatted similarly to Raises.</source>
          <target state="translated">一个可选的部分,详细说明哪些警告会被提出,在什么情况下会被提出,格式与Raises类似。</target>
        </trans-unit>
        <trans-unit id="391f6511a38216160a18b8a442ab41f825e0e811" translate="yes" xml:space="preserve">
          <source>An optional section for examples, using the &lt;a href=&quot;http://docs.python.org/library/doctest.html&quot;&gt;doctest&lt;/a&gt; format. This section is meant to illustrate usage, not to provide a testing framework &amp;ndash; for that, use the &lt;code&gt;tests/&lt;/code&gt; directory. While optional, this section is very strongly encouraged.</source>
          <target state="translated">示例的可选部分，使用&lt;a href=&quot;http://docs.python.org/library/doctest.html&quot;&gt;doctest&lt;/a&gt;格式。本部分旨在说明用法，而不是提供测试框架，为此，请使用 &lt;code&gt;tests/&lt;/code&gt; 目录。虽然是可选的，但强烈建议此部分。</target>
        </trans-unit>
        <trans-unit id="366365808b8b78b0df47b3f2fa0f2ced248b85eb" translate="yes" xml:space="preserve">
          <source>An optional section that provides additional information about the code, possibly including a discussion of the algorithm. This section may include mathematical equations, written in &lt;a href=&quot;http://www.latex-project.org/&quot;&gt;LaTeX&lt;/a&gt; format:</source>
          <target state="translated">可选部分，提供有关代码的其他信息，可能包括对算法的讨论。本部分可能包含以&lt;a href=&quot;http://www.latex-project.org/&quot;&gt;LaTeX&lt;/a&gt;格式编写的数学方程式：</target>
        </trans-unit>
        <trans-unit id="9a2c98cd19c30e91e6748b44b5303643381a459b" translate="yes" xml:space="preserve">
          <source>An optional section used to describe infrequently used parameters. It should only be used if a function has a large number of keyword parameters, to prevent cluttering the &lt;strong&gt;Parameters&lt;/strong&gt; section.</source>
          <target state="translated">可选部分，用于描述不常用的参数。仅在函数具有大量关键字参数的情况下才应使用该参数，以免使&amp;ldquo;&lt;strong&gt;参数&amp;rdquo;&lt;/strong&gt;部分混乱。</target>
        </trans-unit>
        <trans-unit id="9abef9ce470f7fb03808979a319d66414811663e" translate="yes" xml:space="preserve">
          <source>An optional section used to refer to related code. This section can be very useful, but should be used judiciously. The goal is to direct users to other functions they may not be aware of, or have easy means of discovering (by looking at the module docstring, for example). Routines whose docstrings further explain parameters used by this function are good candidates.</source>
          <target state="translated">一个可选的部分,用于引用相关代码。这一部分可能非常有用,但应该谨慎使用。其目的是引导用户找到他们可能不知道的其他函数,或者是他们不容易发现的函数(例如,通过查看模块 docstring)。例程的 docstrings 进一步解释了这个函数使用的参数,是很好的选择。</target>
        </trans-unit>
        <trans-unit id="163026d9f814b206fafab6b479ab36888cccfde6" translate="yes" xml:space="preserve">
          <source>An optional section with cautions to the user in free text/reST.</source>
          <target state="translated">可选部分,以自由文本/reST的形式向用户提出警告。</target>
        </trans-unit>
        <trans-unit id="1965c219b7008fe9d099c530f609263a14ec3ab8" translate="yes" xml:space="preserve">
          <source>An optional shape tuple providing how many times this part of the structure should be repeated. No repeats are assumed if this is not given. Very complicated structures can be described using this generic interface. Notice, however, that each element of the array is still of the same data-type. Some examples of using this interface are given below.</source>
          <target state="translated">一个可选的形状元组,提供这部分结构应该重复多少次。如果没有给定,则不假设重复。非常复杂的结构可以用这个通用接口来描述。但是,请注意,数组中的每个元素仍然是相同的数据类型。下面给出了一些使用这个接口的例子。</target>
        </trans-unit>
        <trans-unit id="53899654d34ff89eb71076f6e6bc7701229a1b68" translate="yes" xml:space="preserve">
          <source>An order as close to the order of the inputs as possible, even if the input is in neither C nor Fortran order.</source>
          <target state="translated">一个尽可能接近输入顺序的顺序,即使输入既不是C也不是Fortran顺序。</target>
        </trans-unit>
        <trans-unit id="62dbe9a66cb25d1e5f12073cb6b65d7c95221376" translate="yes" xml:space="preserve">
          <source>An ordered tuple of field names. It is NULL if no field is defined.</source>
          <target state="translated">字段名的有序元组。如果没有定义字段,则为NULL。</target>
        </trans-unit>
        <trans-unit id="b28a1d46b1f9296ef3b935989580ffec6bc90e2b" translate="yes" xml:space="preserve">
          <source>And even an array that contains a range of evenly spaced intervals. To do this, you will specify the &lt;strong&gt;first number&lt;/strong&gt;, &lt;strong&gt;last number&lt;/strong&gt;, and the &lt;strong&gt;step size&lt;/strong&gt;.</source>
          <target state="translated">甚至是包含一定范围的均匀间隔的数组。为此，您将指定第&lt;strong&gt;一个数字&lt;/strong&gt;，&lt;strong&gt;最后一个数字&lt;/strong&gt;和&lt;strong&gt;步长&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="3fba956825020587f9a5a64e281c04047de223ea" translate="yes" xml:space="preserve">
          <source>And even use a Greek symbol like</source>
          <target state="translated">甚至用希腊语的符号,如</target>
        </trans-unit>
        <trans-unit id="d209b0782b74a22172d98886be624cfb54a8889a" translate="yes" xml:space="preserve">
          <source>And finally, we build the extension module by running</source>
          <target state="translated">最后,我们通过运行</target>
        </trans-unit>
        <trans-unit id="43728498911f9a35c7cfcd97027ee53c73e05582" translate="yes" xml:space="preserve">
          <source>And for assigning values:</source>
          <target state="translated">而对于分配值。</target>
        </trans-unit>
        <trans-unit id="4fb83d7408641f0a8ebf4e9525e3b469b9150326" translate="yes" xml:space="preserve">
          <source>And here are the time units:</source>
          <target state="translated">而这里是时间单位。</target>
        </trans-unit>
        <trans-unit id="1b699ec82ab8d002ac2193762454ef347af6a2da" translate="yes" xml:space="preserve">
          <source>And in more detail:</source>
          <target state="translated">而且更详细。</target>
        </trans-unit>
        <trans-unit id="de07ee02fee2070e061118495013c58fef8e83bb" translate="yes" xml:space="preserve">
          <source>And make sure the &lt;code&gt;VERSION&lt;/code&gt; variable is set properly.</source>
          <target state="translated">并确保正确设置了 &lt;code&gt;VERSION&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="4ee8deafdefbce6d1b2807fd39f58eb30f617552" translate="yes" xml:space="preserve">
          <source>And read your CSV with:</source>
          <target state="translated">并读取你的CSV与。</target>
        </trans-unit>
        <trans-unit id="750b2a038f3915c181ab3d5361e664ccd43727d0" translate="yes" xml:space="preserve">
          <source>And then in the debugger:</source>
          <target state="translated">然后在调试器中。</target>
        </trans-unit>
        <trans-unit id="021c9202efccb926bf8e315a46e72fcbd7af5307" translate="yes" xml:space="preserve">
          <source>And to find the shape of your array, run:</source>
          <target state="translated">要找到数组的形状,运行。</target>
        </trans-unit>
        <trans-unit id="d96cb503f931b03fd273a49b170890809399fc62" translate="yes" xml:space="preserve">
          <source>And use it to set the diagonal of an array of zeros to 1:</source>
          <target state="translated">并用它来设置零数组的对角线为1。</target>
        </trans-unit>
        <trans-unit id="240ae7e192fffb9c12f05d721f8aebdc4754f4de" translate="yes" xml:space="preserve">
          <source>Angle in radians.</source>
          <target state="translated">角度以弧度为单位。</target>
        </trans-unit>
        <trans-unit id="0184757264cf635f3a2e2e908775a586af284275" translate="yes" xml:space="preserve">
          <source>Angle, in radians (</source>
          <target state="translated">角度,以弧度为单位(</target>
        </trans-unit>
        <trans-unit id="531138e549dac342fe270e2699b3c5521bbf5ec8" translate="yes" xml:space="preserve">
          <source>Angles in degrees.</source>
          <target state="translated">角度为度。</target>
        </trans-unit>
        <trans-unit id="dfa37c7c185a546b145b8e12c452f16dbc48d7fc" translate="yes" xml:space="preserve">
          <source>Anirudh Subramanian</source>
          <target state="translated">Anirudh Subramanian</target>
        </trans-unit>
        <trans-unit id="1108804921f7fa74ee3f663d12f9acdb0f17609b" translate="yes" xml:space="preserve">
          <source>Announce the release on scipy.org</source>
          <target state="translated">在scipy.org上发布公告。</target>
        </trans-unit>
        <trans-unit id="9e0f71af0703a17a0fe77843a34b501f25db1f87" translate="yes" xml:space="preserve">
          <source>Announce to Linux Weekly News</source>
          <target state="translated">向Linux周刊新闻发布公告</target>
        </trans-unit>
        <trans-unit id="542e50fbd0847e1465192e2a2bd9c3cc0e292cfc" translate="yes" xml:space="preserve">
          <source>Announce to mailing lists</source>
          <target state="translated">向邮件列表公布</target>
        </trans-unit>
        <trans-unit id="ccc7a7a2cec9dbb01f44b9fb7e6acf4fd9b1506f" translate="yes" xml:space="preserve">
          <source>Announce to the lists</source>
          <target state="translated">向名单公布</target>
        </trans-unit>
        <trans-unit id="3b4dde3e14d997b719c29d0bbd6c5103efadda68" translate="yes" xml:space="preserve">
          <source>Another common separator is &lt;code&gt;&quot;\t&quot;&lt;/code&gt;, the tabulation character. However, we are not limited to a single character, any string will do. By default, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; assumes &lt;code&gt;delimiter=None&lt;/code&gt;, meaning that the line is split along white spaces (including tabs) and that consecutive white spaces are considered as a single white space.</source>
          <target state="translated">另一个常见的分隔符是制表符 &lt;code&gt;&quot;\t&quot;&lt;/code&gt; 。但是，我们不仅限于单个字符，任何字符串都可以。默认情况下，&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;假定 &lt;code&gt;delimiter=None&lt;/code&gt; ，这意味着该行沿空白（包括制表符）分隔，并且连续的空白被视为单个空白。</target>
        </trans-unit>
        <trans-unit id="dfdf42a70a6f5e3b9eb4a7a9d5fd5b3a5e3c028d" translate="yes" xml:space="preserve">
          <source>Another common use of indexing with arrays is the search of the maximum value of time-dependent series:</source>
          <target state="translated">使用数组进行索引的另一个常见用途是搜索时间相关序列的最大值。</target>
        </trans-unit>
        <trans-unit id="4043a7e9def49f8cd15e6e1c3c67b85fcd702c3b" translate="yes" xml:space="preserve">
          <source>Another difference with the standard ndarray of str data-type is that the chararray inherits the feature introduced by Numarray that white-space at the end of any element in the array will be ignored on item retrieval and comparison operations.</source>
          <target state="translated">与str数据类型的标准ndarray的另一个不同之处是,chararray继承了Numarray引入的特性,即在进行项目检索和比较操作时,数组中任何元素末尾的留白将被忽略。</target>
        </trans-unit>
        <trans-unit id="5dcd2747e1a6d1d5aac68e7e1ee2b04c96abcc9c" translate="yes" xml:space="preserve">
          <source>Another example is the function &lt;code&gt;inner1d(a, b)&lt;/code&gt; with a signature of &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt;. This applies the inner product along the last axis of each input, but keeps the remaining indices intact. For example, where &lt;code&gt;a&lt;/code&gt; is of shape &lt;code&gt;(3, 5, N)&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; is of shape &lt;code&gt;(5, N)&lt;/code&gt;, this will return an output of shape &lt;code&gt;(3,5)&lt;/code&gt;. The underlying elementary function is called &lt;code&gt;3 * 5&lt;/code&gt; times. In the signature, we specify one core dimension &lt;code&gt;(i)&lt;/code&gt; for each input and zero core dimensions &lt;code&gt;()&lt;/code&gt; for the output, since it takes two 1-d arrays and returns a scalar. By using the same name &lt;code&gt;i&lt;/code&gt;, we specify that the two corresponding dimensions should be of the same size.</source>
          <target state="translated">另一个示例是函数 &lt;code&gt;inner1d(a, b)&lt;/code&gt; ，其签名为 &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; 。这将沿每个输入的最后一个轴应用内积，但保持其余索引不变。例如，当 &lt;code&gt;a&lt;/code&gt; 的形状为 &lt;code&gt;(3, 5, N)&lt;/code&gt; 且 &lt;code&gt;b&lt;/code&gt; 的形状为 &lt;code&gt;(5, N)&lt;/code&gt; ，这将返回形状为 &lt;code&gt;(3,5)&lt;/code&gt; 的输出。基本的基本函数被调用 &lt;code&gt;3 * 5&lt;/code&gt; 次。在签名中，我们为每个输入指定一个核心尺寸 &lt;code&gt;(i)&lt;/code&gt; ,为输出指定零个核心尺寸 &lt;code&gt;()&lt;/code&gt; ，因为它需要两个1-d数组并返回一个标量。通过使用相同的名字 &lt;code&gt;i&lt;/code&gt; ，我们指定两个相应的尺寸应相同。</target>
        </trans-unit>
        <trans-unit id="90bf0b9c455b04ca91edfdb12178ac251d5b7ad5" translate="yes" xml:space="preserve">
          <source>Another frequently asked question is &amp;ldquo;How do I debug C code inside NumPy?&amp;rdquo;. First, ensure that you have gdb installed on your system with the Python extensions (often the default on Linux). You can see which version of Python is running inside gdb to verify your setup:</source>
          <target state="translated">另一个常见问题是&amp;ldquo;如何在NumPy中调试C代码？&amp;rdquo;。首先，确保您的系统上安装了带有Python扩展名的gdb（通常是Linux上的默认设置）。您可以查看gdb中正在运行哪个版本的Python来验证您的设置：</target>
        </trans-unit>
        <trans-unit id="f0c72feff7651c1b9feda841c49b58c2d454b80e" translate="yes" xml:space="preserve">
          <source>Another important role played by deprecation markings in the C API is to move towards hiding internal details of the NumPy implementation. For those needing direct, easy, access to the data of ndarrays, this will not remove this ability. Rather, there are many potential performance optimizations which require changing the implementation details, and NumPy developers have been unable to try them because of the high value of preserving ABI compatibility. By deprecating this direct access, we will in the future be able to improve NumPy&amp;rsquo;s performance in ways we cannot presently.</source>
          <target state="translated">C API中弃用标记所扮演的另一个重要角色是朝着隐藏NumPy实现的内部细节迈进。对于需要直接，轻松访问ndarray数据的用户，这不会消除此功能。相反，有许多潜在的性能优化需要更改实现细节，并且NumPy开发人员由于保留ABI兼容性的高价值而无法尝试它们。通过弃用这种直接访问，将来我们将能够以目前无法实现的方式改善NumPy的性能。</target>
        </trans-unit>
        <trans-unit id="a86afb1ef0a04254ac219408ffb94437b02ea319" translate="yes" xml:space="preserve">
          <source>Another method is to use &lt;a href=&quot;generated/numpy.random.mt19937.jumped#numpy.random.MT19937.jumped&quot;&gt;&lt;code&gt;MT19937.jumped&lt;/code&gt;&lt;/a&gt; which advances the state as-if</source>
          <target state="translated">另一种方法是使用&lt;a href=&quot;generated/numpy.random.mt19937.jumped#numpy.random.MT19937.jumped&quot;&gt; &lt;code&gt;MT19937.jumped&lt;/code&gt; &lt;/a&gt;将状态按原样提前</target>
        </trans-unit>
        <trans-unit id="91143b613b806bdad96301f98bc353e17238828f" translate="yes" xml:space="preserve">
          <source>Another method is to use &lt;a href=&quot;generated/numpy.random.mt19937.mt19937.jumped#numpy.random.mt19937.MT19937.jumped&quot;&gt;&lt;code&gt;MT19937.jumped&lt;/code&gt;&lt;/a&gt; which advances the state as-if</source>
          <target state="translated">另一种方法是使用&lt;a href=&quot;generated/numpy.random.mt19937.mt19937.jumped#numpy.random.mt19937.MT19937.jumped&quot;&gt; &lt;code&gt;MT19937.jumped&lt;/code&gt; &lt;/a&gt;将状态按原样提前</target>
        </trans-unit>
        <trans-unit id="0fd6c16778a959995e7dc3e9960a7fccd4bf7af0" translate="yes" xml:space="preserve">
          <source>Another possibility is to use the &lt;a href=&quot;generated/numpy.ma.getmask#numpy.ma.getmask&quot;&gt;&lt;code&gt;getmask&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.ma.getmaskarray#numpy.ma.getmaskarray&quot;&gt;&lt;code&gt;getmaskarray&lt;/code&gt;&lt;/a&gt; functions. &lt;code&gt;getmask(x)&lt;/code&gt; outputs the mask of &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is a masked array, and the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; otherwise. &lt;code&gt;getmaskarray(x)&lt;/code&gt; outputs the mask of &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is a masked array. If &lt;code&gt;x&lt;/code&gt; has no invalid entry or is not a masked array, the function outputs a boolean array of &lt;code&gt;False&lt;/code&gt; with as many elements as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">另一种可能性是使用&lt;a href=&quot;generated/numpy.ma.getmask#numpy.ma.getmask&quot;&gt; &lt;code&gt;getmask&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;generated/numpy.ma.getmaskarray#numpy.ma.getmaskarray&quot;&gt; &lt;code&gt;getmaskarray&lt;/code&gt; &lt;/a&gt;函数。 &lt;code&gt;getmask(x)&lt;/code&gt; 的输出的掩模 &lt;code&gt;x&lt;/code&gt; 如果 &lt;code&gt;x&lt;/code&gt; 是掩蔽的阵列，以及特殊值&lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;否则。 &lt;code&gt;getmaskarray(x)&lt;/code&gt; 的输出的掩模 &lt;code&gt;x&lt;/code&gt; 如果 &lt;code&gt;x&lt;/code&gt; 是掩蔽的阵列。如果 &lt;code&gt;x&lt;/code&gt; 没有无效条目或不是掩码数组，则该函数输出 &lt;code&gt;False&lt;/code&gt; 的布尔数组，其元素数量与 &lt;code&gt;x&lt;/code&gt; 一样多。</target>
        </trans-unit>
        <trans-unit id="f8f5707c41037b98d07b3655f44a00e7754af32b" translate="yes" xml:space="preserve">
          <source>Another simpler possibility is to use the &lt;code&gt;names&lt;/code&gt; keyword with a sequence of strings or a comma-separated string:</source>
          <target state="translated">另一个更简单的可能性是将 &lt;code&gt;names&lt;/code&gt; 关键字与字符串序列或逗号分隔的字符串一起使用：</target>
        </trans-unit>
        <trans-unit id="bb96c2d76983849aa396fb78c96e7b20143386c1" translate="yes" xml:space="preserve">
          <source>Another somewhat outdated MATLAB/NumPy cross-reference can be found at &lt;a href=&quot;http://mathesaurus.sf.net/&quot;&gt;http://mathesaurus.sf.net/&lt;/a&gt;</source>
          <target state="translated">可以在&lt;a href=&quot;http://mathesaurus.sf.net/&quot;&gt;http://mathesaurus.sf.net/&lt;/a&gt;找到另一个有点过时的MATLAB / NumPy交叉引用。</target>
        </trans-unit>
        <trans-unit id="5b047c7f58df9c5865a2b74a6710b7b1e5f19d15" translate="yes" xml:space="preserve">
          <source>Another term for &lt;a href=&quot;#term-advanced-indexing&quot;&gt;advanced indexing&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#term-advanced-indexing&quot;&gt;高级索引的&lt;/a&gt;另一个术语。</target>
        </trans-unit>
        <trans-unit id="28a695f570d8eedee37a6873f1169fc8ffe3e272" translate="yes" xml:space="preserve">
          <source>Another term for an array dimension. Axes are numbered left to right; axis 0 is the first element in the shape tuple.</source>
          <target state="translated">数组维度的另一个术语。轴从左到右编号,0轴是形状元组的第一个元素。</target>
        </trans-unit>
        <trans-unit id="05af7d96a4421569602af070d1f51ae85302570e" translate="yes" xml:space="preserve">
          <source>Another use of this flag is for setting up reduction operations. After the iterator is created, and a reduction output is allocated automatically by the iterator (be sure to use READWRITE access), its value may be initialized to the reduction unit. Use &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt; to get the object. Then, call &lt;a href=&quot;#c.NpyIter_Reset&quot;&gt;&lt;code&gt;NpyIter_Reset&lt;/code&gt;&lt;/a&gt; to allocate and fill the buffers with their initial values.</source>
          <target state="translated">此标志的另一种用法是设置缩减操作。创建迭代器并由迭代器自动分配归约输出后（请确保使用READWRITE访问权限），可以将其值初始化为归约单元。使用&lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt; &lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt; &lt;/a&gt;获取对象。然后，调用&lt;a href=&quot;#c.NpyIter_Reset&quot;&gt; &lt;code&gt;NpyIter_Reset&lt;/code&gt; &lt;/a&gt;分配并填充缓冲区的初始值。</target>
        </trans-unit>
        <trans-unit id="1273c53271563cf36a39aab59fe3df9f43442e63" translate="yes" xml:space="preserve">
          <source>Another way to represent the determinant, more suitable for large matrices where underflow/overflow may occur.</source>
          <target state="translated">另一种表示行列式的方法,更适合于可能发生下溢/溢出的大矩阵。</target>
        </trans-unit>
        <trans-unit id="4a9a549b7d1a971f20baf0bc7c2890ecc79e2921" translate="yes" xml:space="preserve">
          <source>Another way to retrieve the valid data is to use the &lt;a href=&quot;generated/numpy.ma.compressed#numpy.ma.compressed&quot;&gt;&lt;code&gt;compressed&lt;/code&gt;&lt;/a&gt; method, which returns a one-dimensional &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; (or one of its subclasses, depending on the value of the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.baseclass&quot;&gt;&lt;code&gt;baseclass&lt;/code&gt;&lt;/a&gt; attribute):</source>
          <target state="translated">以检索有效的数据的另一种方法是使用&lt;a href=&quot;generated/numpy.ma.compressed#numpy.ma.compressed&quot;&gt; &lt;code&gt;compressed&lt;/code&gt; &lt;/a&gt;方法，它返回一维&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;（或它的子类中的一个，这取决于的值&lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.baseclass&quot;&gt; &lt;code&gt;baseclass&lt;/code&gt; &lt;/a&gt;属性）：</target>
        </trans-unit>
        <trans-unit id="4c793b7f96dc3a05a24bc874af2795d6270941c5" translate="yes" xml:space="preserve">
          <source>Anti-derivative of a polynomial.</source>
          <target state="translated">多项式的反导数。</target>
        </trans-unit>
        <trans-unit id="253f5b3f24b2fd1c0fc450339280f5eb6eb4f07c" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;reference/arrays.scalars&quot;&gt;scalar&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-sequence&quot;&gt;sequence&lt;/a&gt; that can be interpreted as an ndarray. In addition to ndarrays and scalars this category includes lists (possibly nested and with different element types) and tuples. Any argument accepted by &lt;a href=&quot;reference/generated/numpy.array&quot;&gt;numpy.array&lt;/a&gt; is array_like.</source>
          <target state="translated">可以解释为ndarray的任何&lt;a href=&quot;reference/arrays.scalars&quot;&gt;标量&lt;/a&gt;或&lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-sequence&quot;&gt;序列&lt;/a&gt;。除了ndarray和标量，此类别还包括列表（可能是嵌套的并且具有不同的元素类型）和元组。&lt;a href=&quot;reference/generated/numpy.array&quot;&gt;numpy.array&lt;/a&gt;接受的任何参数都是array_like。</target>
        </trans-unit>
        <trans-unit id="6711bfd3b820f62c39c4d88fd0c62299f5e94371" translate="yes" xml:space="preserve">
          <source>Any Python object.</source>
          <target state="translated">任何Python对象。</target>
        </trans-unit>
        <trans-unit id="a193823ba578f9f1e7b81264ee2c1d9779647da7" translate="yes" xml:space="preserve">
          <source>Any Python object:</source>
          <target state="translated">任何Python对象。</target>
        </trans-unit>
        <trans-unit id="58e444efe77e462bb342fdd66c1b5f6f6487f4f4" translate="yes" xml:space="preserve">
          <source>Any binary operation can be extended to an array operation in an outer product fashion like in &lt;a href=&quot;generated/numpy.outer#numpy.outer&quot;&gt;&lt;code&gt;outer&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object provides a way to accomplish this by explicitly mapping the axes of the operands. It is also possible to do this with &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; indexing, but we will show you how to directly use the nditer &lt;code&gt;op_axes&lt;/code&gt; parameter to accomplish this with no intermediate views.</source>
          <target state="translated">任何二进制操作可以在一个外积的方式被扩展到一个数组运算像&lt;a href=&quot;generated/numpy.outer#numpy.outer&quot;&gt; &lt;code&gt;outer&lt;/code&gt; &lt;/a&gt;，和&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;对象提供了一种通过显式地映射所述操作数的轴来完成此。也可以使用&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;索引执行此操作，但是我们将向您展示如何直接使用nditer &lt;code&gt;op_axes&lt;/code&gt; 参数来完成此操作而没有中间视图。</target>
        </trans-unit>
        <trans-unit id="df3387b9c652aaab79f08e9bac190d701d99f2f6" translate="yes" xml:space="preserve">
          <source>Any class or type can define this method which should take an ndarray argument and return an instance of the type. It can be seen as the opposite of the &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method. This method is used by the ufuncs (and other NumPy functions) to allow other objects to pass through. For Python &amp;gt;2.4, it can also be used to write a decorator that converts a function that works only with ndarrays to one that works with any type with &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">任何类或类型都可以定义此方法，该方法应使用ndarray参数并返回该类型的实例。可以将其视为&lt;a href=&quot;../reference/arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;方法的反义词。ufunc（和其他NumPy函数）使用此方法来允许其他对象通过。对于Python&amp;gt; 2.4，它也可用于写一个装饰，其将只有具有ndarrays工作以一个与任何类型的工作的功能&lt;a href=&quot;../reference/arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="10078c28a66a73c575c275e6dbad2ad1c3448ead" translate="yes" xml:space="preserve">
          <source>Any class, ndarray subclass or not, can define this method or set it to &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; in order to override the behavior of NumPy&amp;rsquo;s ufuncs. This works quite similarly to Python&amp;rsquo;s &lt;code&gt;__mul__&lt;/code&gt; and other binary operation routines.</source>
          <target state="translated">任何类，无论是否为ndarray子类，都可以定义此方法或将其设置为&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，以覆盖NumPy的ufunc的行为。这与Python的 &lt;code&gt;__mul__&lt;/code&gt; 和其他二进制操作例程非常相似。</target>
        </trans-unit>
        <trans-unit id="615fb1d9086b422643eac8df92cc3c45b3d4452a" translate="yes" xml:space="preserve">
          <source>Any class, ndarray subclass or not, can define this method or set it to None in order to override the behavior of NumPy&amp;rsquo;s ufuncs. This works quite similarly to Python&amp;rsquo;s &lt;code&gt;__mul__&lt;/code&gt; and other binary operation routines.</source>
          <target state="translated">任何类，无论是否为ndarray子类，都可以定义此方法或将其设置为None，以覆盖NumPy的ufuncs的行为。这与Python的 &lt;code&gt;__mul__&lt;/code&gt; 和其他二进制操作例程非常相似。</target>
        </trans-unit>
        <trans-unit id="f4c392144526317c8f8ed6b5a13470ac5e7a3986" translate="yes" xml:space="preserve">
          <source>Any combination of N scalars/arrays with the meaning of 2. and 3.</source>
          <target state="translated">N个标量/数组的任意组合,具有2.和3.的含义。</target>
        </trans-unit>
        <trans-unit id="7e81367c0096f8373d0b6f4554ea3cc6aafb3c68" translate="yes" xml:space="preserve">
          <source>Any data flags (&lt;em&gt;e.g.&lt;/em&gt;&lt;a href=&quot;array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; ) that should be used to interpret the memory.</source>
          <target state="translated">应该用于解释内存的任何数据标志（&lt;em&gt;例如&lt;/em&gt;&lt;a href=&quot;array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="299b31e220e37372f3e91f15af6702628188b111" translate="yes" xml:space="preserve">
          <source>Any data flags (&lt;em&gt;e.g.&lt;/em&gt;&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; ) that should be used to interpret the memory.</source>
          <target state="translated">任何用于解释内存的数据标志（&lt;em&gt;例如&lt;/em&gt;&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d26a90b0973e9f5339ce6764ce63dbf7b59a3e02" translate="yes" xml:space="preserve">
          <source>Any data saved to the file is appended to the end of the file.</source>
          <target state="translated">保存到文件中的任何数据都会附加到文件的末尾。</target>
        </trans-unit>
        <trans-unit id="5d0107d5bdb46b9143c29ff9e836efde601fe340" translate="yes" xml:space="preserve">
          <source>Any dynamically allocated memory. Currently, this is used for dynamic ufuncs created from a python function to store room for the types, data, and name members.</source>
          <target state="translated">任何动态分配的内存。目前,这用于从python函数中创建的动态ufuncs,为类型、数据和名称成员存储空间。</target>
        </trans-unit>
        <trans-unit id="f1796623bc2027a8a0877fb0e869c4d3c3990d76" translate="yes" xml:space="preserve">
          <source>Any further arguments given to &lt;a href=&quot;#numpy.piecewise&quot;&gt;&lt;code&gt;piecewise&lt;/code&gt;&lt;/a&gt; are passed to the functions upon execution, i.e., if called &lt;code&gt;piecewise(..., ..., 1, 'a')&lt;/code&gt;, then each function is called as &lt;code&gt;f(x, 1, 'a')&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.piecewise&quot;&gt; &lt;code&gt;piecewise&lt;/code&gt; &lt;/a&gt;给出的任何其他参数在执行时都传递给函数，即，如果调用 &lt;code&gt;piecewise(..., ..., 1, 'a')&lt;/code&gt; ，则每个函数均称为 &lt;code&gt;f(x, 1, 'a')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fd7c425a186534062ca5afb654fb680173c25d5" translate="yes" xml:space="preserve">
          <source>Any keyword arguments the function requires.</source>
          <target state="translated">函数所需的任何关键字参数。</target>
        </trans-unit>
        <trans-unit id="487737106c5cb105d4cc96a9c1768d045f864529" translate="yes" xml:space="preserve">
          <source>Any masked values in x is propagated in y, and vice-versa.</source>
          <target state="translated">x中的任何屏蔽值都会在y中传播,反之亦然。</target>
        </trans-unit>
        <trans-unit id="5b3e589175f1027a44f22dd657bf35194fb4efe1" translate="yes" xml:space="preserve">
          <source>Any object that can be interpreted as a numpy data type.</source>
          <target state="translated">任何可以被解释为numpy数据类型的对象。</target>
        </trans-unit>
        <trans-unit id="5c7fd0d6a17d8a832706885c37ef7915bca46e30" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;array#c.NPY_CASTING&quot;&gt;&lt;code&gt;NPY_CASTING&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;casting&lt;/code&gt;. The values include &lt;a href=&quot;array#c.NPY_NO_CASTING&quot;&gt;&lt;code&gt;NPY_NO_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_EQUIV_CASTING&quot;&gt;&lt;code&gt;NPY_EQUIV_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_SAFE_CASTING&quot;&gt;&lt;code&gt;NPY_SAFE_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_SAME_KIND_CASTING&quot;&gt;&lt;code&gt;NPY_SAME_KIND_CASTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;array#c.NPY_UNSAFE_CASTING&quot;&gt;&lt;code&gt;NPY_UNSAFE_CASTING&lt;/code&gt;&lt;/a&gt;. To allow the casts to occur, copying or buffering must also be enabled.</source>
          <target state="translated">任何&lt;a href=&quot;array#c.NPY_CASTING&quot;&gt; &lt;code&gt;NPY_CASTING&lt;/code&gt; &lt;/a&gt;枚举值都可以传递给 &lt;code&gt;casting&lt;/code&gt; 。值包括&lt;a href=&quot;array#c.NPY_NO_CASTING&quot;&gt; &lt;code&gt;NPY_NO_CASTING&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;array#c.NPY_EQUIV_CASTING&quot;&gt; &lt;code&gt;NPY_EQUIV_CASTING&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;array#c.NPY_SAFE_CASTING&quot;&gt; &lt;code&gt;NPY_SAFE_CASTING&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;array#c.NPY_SAME_KIND_CASTING&quot;&gt; &lt;code&gt;NPY_SAME_KIND_CASTING&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;array#c.NPY_UNSAFE_CASTING&quot;&gt; &lt;code&gt;NPY_UNSAFE_CASTING&lt;/code&gt; &lt;/a&gt;。要允许进行强制转换，还必须启用复制或缓冲。</target>
        </trans-unit>
        <trans-unit id="a5faa1a4aa7fab555a1cad670ecbaad358f811e8" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;array#c.NPY_ORDER&quot;&gt;&lt;code&gt;NPY_ORDER&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;order&lt;/code&gt;. For efficient iteration, &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is the best option, and the other orders enforce the particular iteration pattern.</source>
          <target state="translated">任何&lt;a href=&quot;array#c.NPY_ORDER&quot;&gt; &lt;code&gt;NPY_ORDER&lt;/code&gt; &lt;/a&gt;枚举值都可以传递给 &lt;code&gt;order&lt;/code&gt; 。为了有效地进行迭代，&lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt;是最佳选择，而其他命令则强制执行特定的迭代模式。</target>
        </trans-unit>
        <trans-unit id="61c0049b3dfe5e641bc6afd3eb13a7ff82f212c5" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;array#c.NPY_ORDER&quot;&gt;&lt;code&gt;NPY_ORDER&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;order&lt;/code&gt;. For efficient iteration, &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is the best option, and the other orders enforce the particular iteration pattern. When using &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, if you also want to ensure that the iteration is not reversed along an axis, you should pass the flag &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt;&lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">任何&lt;a href=&quot;array#c.NPY_ORDER&quot;&gt; &lt;code&gt;NPY_ORDER&lt;/code&gt; &lt;/a&gt;枚举值都可以传递给 &lt;code&gt;order&lt;/code&gt; 。为了有效地进行迭代，&lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt;是最佳选择，而其他命令则强制执行特定的迭代模式。当使用&lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; 时&lt;/a&gt;，如果您还想确保迭代不沿轴反转，则应传递标记&lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt; &lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6945ac0af9b8b9ad29a3d13b28b137c3c2801d79" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;c-api.array#c.NPY_CASTING&quot;&gt;&lt;code&gt;NPY_CASTING&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;casting&lt;/code&gt;. The values include &lt;a href=&quot;c-api.array#c.NPY_NO_CASTING&quot;&gt;&lt;code&gt;NPY_NO_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_EQUIV_CASTING&quot;&gt;&lt;code&gt;NPY_EQUIV_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_SAFE_CASTING&quot;&gt;&lt;code&gt;NPY_SAFE_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_SAME_KIND_CASTING&quot;&gt;&lt;code&gt;NPY_SAME_KIND_CASTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.array#c.NPY_UNSAFE_CASTING&quot;&gt;&lt;code&gt;NPY_UNSAFE_CASTING&lt;/code&gt;&lt;/a&gt;. To allow the casts to occur, copying or buffering must also be enabled.</source>
          <target state="translated">任何&lt;a href=&quot;c-api.array#c.NPY_CASTING&quot;&gt; &lt;code&gt;NPY_CASTING&lt;/code&gt; &lt;/a&gt;枚举值都可以传递给 &lt;code&gt;casting&lt;/code&gt; 。值包括&lt;a href=&quot;c-api.array#c.NPY_NO_CASTING&quot;&gt; &lt;code&gt;NPY_NO_CASTING&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.array#c.NPY_EQUIV_CASTING&quot;&gt; &lt;code&gt;NPY_EQUIV_CASTING&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.array#c.NPY_SAFE_CASTING&quot;&gt; &lt;code&gt;NPY_SAFE_CASTING&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.array#c.NPY_SAME_KIND_CASTING&quot;&gt; &lt;code&gt;NPY_SAME_KIND_CASTING&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;c-api.array#c.NPY_UNSAFE_CASTING&quot;&gt; &lt;code&gt;NPY_UNSAFE_CASTING&lt;/code&gt; &lt;/a&gt;。要允许进行强制转换，还必须启用复制或缓冲。</target>
        </trans-unit>
        <trans-unit id="99411ff6757ed2755306b2b1a16852e86b5af656" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;c-api.array#c.NPY_ORDER&quot;&gt;&lt;code&gt;NPY_ORDER&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;order&lt;/code&gt;. For efficient iteration, &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is the best option, and the other orders enforce the particular iteration pattern.</source>
          <target state="translated">任何&lt;a href=&quot;c-api.array#c.NPY_ORDER&quot;&gt; &lt;code&gt;NPY_ORDER&lt;/code&gt; &lt;/a&gt;枚举值都可以传递给 &lt;code&gt;order&lt;/code&gt; 。为了进行有效的迭代，&lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt;是最佳选择，其他命令则强制执行特定的迭代模式。</target>
        </trans-unit>
        <trans-unit id="edb631f6c3d9ec9fd114b3a0b6be2d92e321c394" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;c-api.array#c.NPY_ORDER&quot;&gt;&lt;code&gt;NPY_ORDER&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;order&lt;/code&gt;. For efficient iteration, &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is the best option, and the other orders enforce the particular iteration pattern. When using &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, if you also want to ensure that the iteration is not reversed along an axis, you should pass the flag &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt;&lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">任何&lt;a href=&quot;c-api.array#c.NPY_ORDER&quot;&gt; &lt;code&gt;NPY_ORDER&lt;/code&gt; &lt;/a&gt;枚举值都可以传递给 &lt;code&gt;order&lt;/code&gt; 。为了进行有效的迭代，&lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt;是最佳选择，其他命令则强制执行特定的迭代模式。使用&lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; 时&lt;/a&gt;，如果您还想确保迭代不沿某个轴反转，则应传递标记&lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt; &lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3abc478c3f222918197160be100f748fcb675c9" translate="yes" xml:space="preserve">
          <source>Any of the above can be repeated with an arbitrary array-like instead of just integers. For instance:</source>
          <target state="translated">以上的任何一种都可以用任意的数组类代替单纯的整数来重复。例如:</target>
        </trans-unit>
        <trans-unit id="baa143a57607b2a750593f79fe56d85a053bca99" translate="yes" xml:space="preserve">
          <source>Any of the bits &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (1), &lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (2), &lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; (0x100), &lt;a href=&quot;array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt;&lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt;&lt;/a&gt; (0x200), or &lt;a href=&quot;array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; (0x400) to indicate something about the data. The &lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; flags can actually be determined from the other parameters. The flag &lt;a href=&quot;../arrays.interface#c.NPY_ARR_HAS_DESCR&quot;&gt;&lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt;&lt;/a&gt; (0x800) can also be set to indicate to objects consuming the version 3 array interface that the descr member of the structure is present (it will be ignored by objects consuming version 2 of the array interface).</source>
          <target state="translated">任何位&lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;（1），&lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;（2），&lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;（0x100的），&lt;a href=&quot;array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt; &lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt; &lt;/a&gt;（为0x200），或&lt;a href=&quot;array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;（0x400的），以指示一些有关的数据。的&lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;标志实际上可以从其它参数来确定。还可以设置标志&lt;a href=&quot;../arrays.interface#c.NPY_ARR_HAS_DESCR&quot;&gt; &lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt; &lt;/a&gt;（0x800），以指示使用版本3阵列接口的对象存在该结构的descr成员（使用阵列接口的版本2的对象将忽略该结构的descr成员）。</target>
        </trans-unit>
        <trans-unit id="50f8138ac25a7b846ede67771ef46a3519a7468a" translate="yes" xml:space="preserve">
          <source>Any of the bits &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (1), &lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (2), &lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; (0x100), &lt;a href=&quot;array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt;&lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt;&lt;/a&gt; (0x200), or &lt;a href=&quot;array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; (0x400) to indicate something about the data. The &lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; flags can actually be determined from the other parameters. The flag &lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt; (0x800) can also be set to indicate to objects consuming the version 3 array interface that the descr member of the structure is present (it will be ignored by objects consuming version 2 of the array interface).</source>
          <target state="translated">任何位&lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;（1），&lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;（2），&lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;（0x100的），&lt;a href=&quot;array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt; &lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt; &lt;/a&gt;（为0x200），或&lt;a href=&quot;array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;（0x400的），以指示一些有关的数据。的&lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;标志实际上可以从其它参数来确定。还可以设置标志 &lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt; （0x800），以指示使用版本3阵列接口的对象存在该结构的descr成员（使用阵列接口的版本2的对象将忽略该结构的descr成员）。</target>
        </trans-unit>
        <trans-unit id="be291c901c4e86c13d0921234777782594d69ca9" translate="yes" xml:space="preserve">
          <source>Any of the bits &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (1), &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (2), &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; (0x100), &lt;a href=&quot;c-api.array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt;&lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt;&lt;/a&gt; (0x200), or &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; (0x400) to indicate something about the data. The &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; flags can actually be determined from the other parameters. The flag &lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt; (0x800) can also be set to indicate to objects consuming the version 3 array interface that the descr member of the structure is present (it will be ignored by objects consuming version 2 of the array interface).</source>
          <target state="translated">任何位&lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;（1），&lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;（2），&lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;（0x100的），&lt;a href=&quot;c-api.array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt; &lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt; &lt;/a&gt;（为0x200），或&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;（0x400的），以指示一些有关的数据。的&lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;标志实际上可以从其它参数来确定。还可以设置标志 &lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt; （0x800），以指示使用版本3阵列接口的对象存在该结构的descr成员（使用阵列接口的版本2的对象将忽略该结构的descr成员）。</target>
        </trans-unit>
        <trans-unit id="451522a82b98d1ecbb1f701acd57fae92d96248e" translate="yes" xml:space="preserve">
          <source>Any scalar or sequence that can be interpreted as an ndarray.</source>
          <target state="translated">任何可以解释为ndarray的标量或序列。</target>
        </trans-unit>
        <trans-unit id="ade55446d2b73db16731c562424aceaad0914376" translate="yes" xml:space="preserve">
          <source>Any sequence that can be interpreted as an ndarray. This includes nested lists, tuples, scalars and existing arrays.</source>
          <target state="translated">任何可以解释为ndarray的序列。这包括嵌套的列表、元组、标量和现有的数组。</target>
        </trans-unit>
        <trans-unit id="f40cd9ea72e6075ff56d97f5c96e1adeaca3800f" translate="yes" xml:space="preserve">
          <source>Any specified CPU feature to &lt;code&gt;--cpu-dispatch&lt;/code&gt; will be skipped if it&amp;rsquo;s part of CPU baseline features</source>
          <target state="translated">如果指定给 &lt;code&gt;--cpu-dispatch&lt;/code&gt; 的任何CPU功能都是CPU基准功能的一部分，则将被跳过</target>
        </trans-unit>
        <trans-unit id="c0fc04558da8dd3c7bccbbace9c70f03ebdb6a80" translate="yes" xml:space="preserve">
          <source>Any string in &lt;code&gt;numpy.sctypeDict&lt;/code&gt;.keys():</source>
          <target state="translated">&lt;code&gt;numpy.sctypeDict&lt;/code&gt; .keys（）中的任何字符串：</target>
        </trans-unit>
        <trans-unit id="d713c0e047edfbd49f0b3846ac98a9a40d4a3161" translate="yes" xml:space="preserve">
          <source>Any third argument to &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#pow&quot;&gt;&lt;code&gt;pow&lt;/code&gt;&lt;/a&gt; is silently ignored, as the underlying &lt;a href=&quot;generated/numpy.power#numpy.power&quot;&gt;&lt;code&gt;ufunc&lt;/code&gt;&lt;/a&gt; takes only two arguments.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#pow&quot;&gt; &lt;code&gt;pow&lt;/code&gt; 的&lt;/a&gt;任何第三个参数都将被静默忽略，因为底层的&lt;a href=&quot;generated/numpy.power#numpy.power&quot;&gt; &lt;code&gt;ufunc&lt;/code&gt; &lt;/a&gt;仅接受两个参数。</target>
        </trans-unit>
        <trans-unit id="946a38c0dae9772a5b694f0cc7db9666bf07194e" translate="yes" xml:space="preserve">
          <source>Any time you want to use a package or library in your code, you first need to make it accessible.</source>
          <target state="translated">任何时候,你想在你的代码中使用一个包或库,你首先需要让它可以被访问。</target>
        </trans-unit>
        <trans-unit id="53be63b1330ee25c1f855c85df25ca52d3b0d9ac" translate="yes" xml:space="preserve">
          <source>Any type object with a &lt;code&gt;dtype&lt;/code&gt; attribute: The attribute will be accessed and used directly. The attribute must return something that is convertible into a dtype object.</source>
          <target state="translated">具有 &lt;code&gt;dtype&lt;/code&gt; 属性的任何类型对象：将直接访问和使用该属性。该属性必须返回可转换为dtype对象的内容。</target>
        </trans-unit>
        <trans-unit id="a26626a547f9526333d65f7f7ac98e634e8d404b" translate="yes" xml:space="preserve">
          <source>Append a new recording filter or apply it if the state is entered.</source>
          <target state="translated">如果进入状态,则添加一个新的记录过滤器或应用它。</target>
        </trans-unit>
        <trans-unit id="2911a13c39db194e9958de7d85a60b6ad7244721" translate="yes" xml:space="preserve">
          <source>Append directory &lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt; to the list of directories searched for include files.</source>
          <target state="translated">将目录 &lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt; 追加到搜索包含文件的目录列表中。</target>
        </trans-unit>
        <trans-unit id="01347379ae01a5a40d3d1ed49513be6a422e707d" translate="yes" xml:space="preserve">
          <source>Append elements at the end of an array.</source>
          <target state="translated">在数组的末尾添加元素。</target>
        </trans-unit>
        <trans-unit id="6e89159e1cc33f0d869902b46493c6f6e94db543" translate="yes" xml:space="preserve">
          <source>Append values to the end of an array.</source>
          <target state="translated">将数值追加到数组的末尾。</target>
        </trans-unit>
        <trans-unit id="481aab454c2962551cc9f57d11f57a67e0fca9e4" translate="yes" xml:space="preserve">
          <source>Appending to build flags</source>
          <target state="translated">附加到构建标志</target>
        </trans-unit>
        <trans-unit id="5d9cf77e8ba225a7ce0a29de1d2139c5781725d4" translate="yes" xml:space="preserve">
          <source>Appends a data function to the data_files list that will generate __svn_version__.py file to the current package directory.</source>
          <target state="translated">在data_files列表中添加一个数据函数,它将生成__svn_version__.py文件到当前的包目录下。</target>
        </trans-unit>
        <trans-unit id="33f5ee9b7c00e9ead408311c459141d052778da5" translate="yes" xml:space="preserve">
          <source>Applies an offset counted in valid days.</source>
          <target state="translated">应用以有效天数计算的偏移量。</target>
        </trans-unit>
        <trans-unit id="2bf57444d43c734213e1d3c851fdf1b3fb150bdf" translate="yes" xml:space="preserve">
          <source>Applies glob.glob(&amp;hellip;) to each path in the sequence (if needed) and pre-pends the local_path if needed. Because this is called on all source lists, this allows wildcard characters to be specified in lists of sources for extension modules and libraries and scripts and allows path-names be relative to the source directory.</source>
          <target state="translated">将glob.glob（...）应用于序列中的每个路径（如果需要），并在需要时预先添加local_path。因为这是在所有源列表上调用的，所以这允许在扩展模块，库和脚本的源列表中指定通配符，并允许路径名相对于源目录。</target>
        </trans-unit>
        <trans-unit id="78652f7b097973c5af68766b38955ba3ae45a013" translate="yes" xml:space="preserve">
          <source>Applies the Einstein summation convention to the array operands provided, returning a new array or placing the result in &lt;em&gt;out&lt;/em&gt;. The string in &lt;em&gt;subscripts&lt;/em&gt; is a comma separated list of index letters. The number of operands is in &lt;em&gt;nop&lt;/em&gt;, and &lt;em&gt;op_in&lt;/em&gt; is an array containing those operands. The data type of the output can be forced with &lt;em&gt;dtype&lt;/em&gt;, the output order can be forced with &lt;em&gt;order&lt;/em&gt; (&lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is recommended), and when &lt;em&gt;dtype&lt;/em&gt; is specified, &lt;em&gt;casting&lt;/em&gt; indicates how permissive the data conversion should be.</source>
          <target state="translated">将爱因斯坦求和约定应用于提供的数组操作数，返回新数组或将结果放入&lt;em&gt;out&lt;/em&gt;。&lt;em&gt;下标中&lt;/em&gt;的字符串是逗号分隔的索引字母列表。操作数的数量为&lt;em&gt;nop&lt;/em&gt;，&lt;em&gt;op_in&lt;/em&gt;是包含这些操作数的数组。的输出的数据类型可以被迫与&lt;em&gt;D型&lt;/em&gt;，输出顺序可以与被强制&lt;em&gt;顺序&lt;/em&gt;（&lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt;建议），并且当&lt;em&gt;D型细胞&lt;/em&gt;被指定时，&lt;em&gt;铸造&lt;/em&gt;指示如何允许性数据转换应。</target>
        </trans-unit>
        <trans-unit id="21feca4b141579d51c961cd00a897cb1717e4a03" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;index_array&lt;/code&gt; from argpartition to an array as if by calling partition.</source>
          <target state="translated">将 &lt;code&gt;index_array&lt;/code&gt; 的index_array应用于数组，就好像通过调用partition一样。</target>
        </trans-unit>
        <trans-unit id="4ca4fe7fefd7c25f71a50eeea097cc697cb368a1" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;index_array&lt;/code&gt; from argsort to an array as if by calling sort.</source>
          <target state="translated">将 &lt;code&gt;index_array&lt;/code&gt; 的index_array应用于数组，就好像调用sort一样。</target>
        </trans-unit>
        <trans-unit id="c436985ffd81a143fc825046932ac1ad32bff874" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;np.expand_dims(index_array, axis)&lt;/code&gt; from argmax to an array as if by calling max.</source>
          <target state="translated">将 &lt;code&gt;np.expand_dims(index_array, axis)&lt;/code&gt; 应用于数组，就像通过调用max一样。</target>
        </trans-unit>
        <trans-unit id="7cc1b6ea691ac922af6be7bae41f63f959261f5d" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;np.expand_dims(index_array, axis)&lt;/code&gt; from argmin to an array as if by calling min.</source>
          <target state="translated">将 &lt;code&gt;np.expand_dims(index_array, axis)&lt;/code&gt; 应用于数组，就像通过调用min一样。</target>
        </trans-unit>
        <trans-unit id="17c58f86e54424ee8c27debf26633ec82caf815e" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;op&lt;/code&gt; to the arguments &lt;code&gt;*x&lt;/code&gt; elementwise, broadcasting the arguments.</source>
          <target state="translated">将 &lt;code&gt;op&lt;/code&gt; 逐个应用于参数 &lt;code&gt;*x&lt;/code&gt; ，广播参数。</target>
        </trans-unit>
        <trans-unit id="a15deb464b32712e5faad1a95646f2d13bba4428" translate="yes" xml:space="preserve">
          <source>Apply a decorator to all methods in a class matching a regular expression.</source>
          <target state="translated">对类中所有与正则表达式匹配的方法应用一个装饰器。</target>
        </trans-unit>
        <trans-unit id="9aba00bb90c6eaaa703b9d293078221144653ecd" translate="yes" xml:space="preserve">
          <source>Apply a function repeatedly over multiple axes.</source>
          <target state="translated">在多个轴上重复应用一个函数。</target>
        </trans-unit>
        <trans-unit id="930471cd723d35b6c2b966e96ceecc291d0fdf6a" translate="yes" xml:space="preserve">
          <source>Apply a function to 1-D slices along the given axis.</source>
          <target state="translated">对沿给定轴线的一维切片应用一个函数。</target>
        </trans-unit>
        <trans-unit id="60e579e665f3197d6488027d302750921e380286" translate="yes" xml:space="preserve">
          <source>Apply a function to 1-D slices of an array along the given axis.</source>
          <target state="translated">沿着给定的轴对一个数组的1-D切片应用一个函数。</target>
        </trans-unit>
        <trans-unit id="8a69d5c1511c3d8cf1aef04b61ce82902f9e77f8" translate="yes" xml:space="preserve">
          <source>Apply function &amp;lsquo;func&amp;rsquo; as a reduction across fields of a structured array.</source>
          <target state="translated">应用功能'func'作为结构化数组中各个字段的简化。</target>
        </trans-unit>
        <trans-unit id="92f37352400ea0595778e975d3829366956d6422" translate="yes" xml:space="preserve">
          <source>Apply glob to paths and prepend local_path if needed.</source>
          <target state="translated">将 glob 应用到路径上,如果需要的话,可以在前面加上 local_path。</target>
        </trans-unit>
        <trans-unit id="6d57e8ee432c77c347bd91e42e1ec296a790a962" translate="yes" xml:space="preserve">
          <source>Apply linear map to input points.</source>
          <target state="translated">将线性图应用于输入点。</target>
        </trans-unit>
        <trans-unit id="b451c47d03d2342612630d90e5961330763668d9" translate="yes" xml:space="preserve">
          <source>Apply the same function to a scalar value.</source>
          <target state="translated">将同样的函数应用于一个标量值。</target>
        </trans-unit>
        <trans-unit id="c19a38c87eebd888f6ee1a1c74150ed1ef57dd31" translate="yes" xml:space="preserve">
          <source>Apply the ufunc &lt;code&gt;op&lt;/code&gt; to all pairs (a, b) with a in &lt;code&gt;A&lt;/code&gt; and b in &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">应用ufunc &lt;code&gt;op&lt;/code&gt; 在所有对（a，b）用 &lt;code&gt;A&lt;/code&gt; 和b在 &lt;code&gt;B&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b480bceb3391de1a231371b22b8f98d14965a74b" translate="yes" xml:space="preserve">
          <source>Applying to all colors</source>
          <target state="translated">适用于所有颜色</target>
        </trans-unit>
        <trans-unit id="f11fedb225efa784388e87f9d68e4b132e27f024" translate="yes" xml:space="preserve">
          <source>Approximation</source>
          <target state="translated">Approximation</target>
        </trans-unit>
        <trans-unit id="0a7e07004db73b8ccd197df301f0c0c88108495f" translate="yes" xml:space="preserve">
          <source>Arbitrary data (extra arguments, function names, &lt;em&gt;etc.&lt;/em&gt; ) that can be stored with the ufunc and will be passed in when it is called.</source>
          <target state="translated">可以与ufunc一起存储的任意数据（额外的参数，函数名称&lt;em&gt;等&lt;/em&gt;），将在调用时传入。</target>
        </trans-unit>
        <trans-unit id="d6c0ec3c601093336049eacec64ee0a29b472718" translate="yes" xml:space="preserve">
          <source>Arbitrary subclasses of numpy.ndarray are not completely preserved. Subclasses will be accepted for writing, but only the array data will be written out. A regular numpy.ndarray object will be created upon reading the file.</source>
          <target state="translated">numpy.ndarray的任意子类不会被完全保留。子类将被接受写入,但只有数组数据会被写出来。读取文件时将创建一个常规的numpy.ndarray对象。</target>
        </trans-unit>
        <trans-unit id="55d5f33d484d4926bb72a9fc085161f70575b63d" translate="yes" xml:space="preserve">
          <source>Arch option for windows binary</source>
          <target state="translated">拱形选项为Windows二进制</target>
        </trans-unit>
        <trans-unit id="d91c75193c3842b9d909ec7b8dd4d035b07a9f55" translate="yes" xml:space="preserve">
          <source>Are all arguments of a type that we know how to handle?</source>
          <target state="translated">所有的参数都是我们知道如何处理的类型吗?</target>
        </trans-unit>
        <trans-unit id="9bdf5e0978150bd50fab817fc37629d830ac57f1" translate="yes" xml:space="preserve">
          <source>Are axis or shape arguments tested to be &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;tuples&lt;/code&gt;?</source>
          <target state="translated">是否已将轴或形状自变量测试为 &lt;code&gt;int&lt;/code&gt; 或 &lt;code&gt;tuples&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="14bf0c3e3104c86791f4ce367eca2a5cc6cd438f" translate="yes" xml:space="preserve">
          <source>Are the array elements of type unicode (True) or string (False). Default is False.</source>
          <target state="translated">数组元素的类型是unicode(True)还是string(False)。默认为False。</target>
        </trans-unit>
        <trans-unit id="b5b7142c8499ab6cb5dbe41cc158e30ea956ddca" translate="yes" xml:space="preserve">
          <source>Are unusual &lt;code&gt;dtypes&lt;/code&gt; tested if a function supports those?</source>
          <target state="translated">如果函数支持非常 &lt;code&gt;dtypes&lt;/code&gt; 是否会对其进行测试？</target>
        </trans-unit>
        <trans-unit id="54fec1cc4e99f8522843b011fb68aafe3fb92c1c" translate="yes" xml:space="preserve">
          <source>Aren&amp;rsquo;t how-tos and tutorials the same thing?</source>
          <target state="translated">方法和教程不是同一回事吗？</target>
        </trans-unit>
        <trans-unit id="c651546e6d3a9b3b4ba1458219c7c80e713538c6" translate="yes" xml:space="preserve">
          <source>Argmin and argmax out argument</source>
          <target state="translated">Argmin和argmax出来的参数</target>
        </trans-unit>
        <trans-unit id="04b5fdf11f1c668ee1bccda74e473d486cb80034" translate="yes" xml:space="preserve">
          <source>Argout Arrays</source>
          <target state="translated">Argout Arrays</target>
        </trans-unit>
        <trans-unit id="1f693ea5d95326ee12ba9edafca87f6f5ac163dc" translate="yes" xml:space="preserve">
          <source>Argout View Arrays</source>
          <target state="translated">Argout视图数组</target>
        </trans-unit>
        <trans-unit id="9362235cd642830a37eb4b0e960e60e4a8a7f208" translate="yes" xml:space="preserve">
          <source>Argout arrays are arrays that appear in the input arguments in C, but are in fact output arrays. This pattern occurs often when there is more than one output variable and the single return argument is therefore not sufficient. In Python, the conventional way to return multiple arguments is to pack them into a sequence (tuple, list, etc.) and return the sequence. This is what the argout typemaps do. If a wrapped function that uses these argout typemaps has more than one return argument, they are packed into a tuple or list, depending on the version of Python. The Python user does not pass these arrays in, they simply get returned. For the case where a dimension is specified, the python user must provide that dimension as an argument. The argout signatures are</source>
          <target state="translated">Argout数组是C语言中输入参数中出现的数组,但实际上是输出数组。这种模式经常出现在有多个输出变量,因此单个返回参数不够用的情况下。在Python中,返回多个参数的传统方法是将它们打包成一个序列(元组、列表等),然后返回序列。这就是 argout 类型图的作用。如果一个使用这些 argout 类型图的封装函数有多个返回参数,则根据 Python 的版本,将它们打包成 tuple 或 list。Python 用户不会将这些数组传递进来,它们只是被返回。对于指定了一个维度的情况,Python 用户必须提供这个维度作为参数。argout的签名是</target>
        </trans-unit>
        <trans-unit id="f0d811a8c8b43b06e028e619f05e9d14eafcdca7" translate="yes" xml:space="preserve">
          <source>Argoutview arrays are for when your C code provides you with a view of its internal data and does not require any memory to be allocated by the user. This can be dangerous. There is almost no way to guarantee that the internal data from the C code will remain in existence for the entire lifetime of the NumPy array that encapsulates it. If the user destroys the object that provides the view of the data before destroying the NumPy array, then using that array may result in bad memory references or segmentation faults. Nevertheless, there are situations, working with large data sets, where you simply have no other choice.</source>
          <target state="translated">Argoutview数组适用于当你的C代码为你提供其内部数据的视图,并且不需要用户分配任何内存。这可能是危险的。几乎没有办法保证C代码的内部数据在封装它的NumPy数组的整个生命周期内都会保持存在。如果用户在销毁NumPy数组之前销毁了提供数据视图的对象,那么使用该数组可能会导致内存引用不良或分段故障。尽管如此,在处理大型数据集时,有些情况下,你根本没有其他选择。</target>
        </trans-unit>
        <trans-unit id="69013bc8794a33ce0d96e2362b8fd29875b1d20a" translate="yes" xml:space="preserve">
          <source>Argument can be either</source>
          <target state="translated">论据可以是</target>
        </trans-unit>
        <trans-unit id="80e8304a176934810abc17d2d26c3888e65cbaa7" translate="yes" xml:space="preserve">
          <source>Argument of complex values.</source>
          <target state="translated">复杂值的论证。</target>
        </trans-unit>
        <trans-unit id="103cd4d5d40741b2189f1a4cd45b1145dc7d5cc2" translate="yes" xml:space="preserve">
          <source>Argument of the Bessel function.</source>
          <target state="translated">Bessel函数的参数。</target>
        </trans-unit>
        <trans-unit id="da03da7501b0f4c3d0e71a81aacac0740f6ea6ce" translate="yes" xml:space="preserve">
          <source>Argument(s) can be either</source>
          <target state="translated">Argument(s)可以是</target>
        </trans-unit>
        <trans-unit id="3a267e3ae3a20fe67defefd5d3c99d6c87f6bed7" translate="yes" xml:space="preserve">
          <source>Argument(s) can be either:</source>
          <target state="translated">Argument(s)可以是:</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="5649abe78903b9f6461061e275735b25a7054ccd" translate="yes" xml:space="preserve">
          <source>Arguments for &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="1fece9ebb467e36ae935eb7f9713ac9a4f47e841" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">参数传递给 &lt;code&gt;func&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed091b4d91808383da4576963f0c43e1c919be23" translate="yes" xml:space="preserve">
          <source>Arguments to be passed to the nose test runner. &lt;code&gt;argv[0]&lt;/code&gt; is ignored. All command line arguments accepted by &lt;code&gt;nosetests&lt;/code&gt; will work. If it is the default value None, sys.argv is used.</source>
          <target state="translated">参数将传递给鼻子测试跑步者。 &lt;code&gt;argv[0]&lt;/code&gt; 被忽略。 &lt;code&gt;nosetests&lt;/code&gt; 接受的所有命令行参数都将起作用。如果它是默认值None，则使用sys.argv。</target>
        </trans-unit>
        <trans-unit id="a47a631225ff0c3415173266008602c859777e94" translate="yes" xml:space="preserve">
          <source>Arguments to pass on to the ufunc. Typically &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">传递给ufunc的参数。通常是&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;out&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="424915704fdafa9f1991a2f818f149305624ecb5" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operations</source>
          <target state="translated">算术和比较运算</target>
        </trans-unit>
        <trans-unit id="27c9afdfd25af93dd20b5c590862915ebec2aa5c" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operations are supported by masked arrays. As much as possible, invalid entries of a masked array are not processed, meaning that the corresponding &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; entries &lt;em&gt;should&lt;/em&gt; be the same before and after the operation.</source>
          <target state="translated">掩码数组支持算术和比较操作。尽可能不处理掩码数组的无效条目，这意味着相应的&lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt;条目在操作之前和之后&lt;em&gt;应该&lt;/em&gt;相同。</target>
        </trans-unit>
        <trans-unit id="c0e6f1226f47528d48f2f359b548a2a985744686" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operations are supported by masked arrays. As much as possible, invalid entries of a masked array are not processed, meaning that the corresponding &lt;code&gt;data&lt;/code&gt; entries &lt;em&gt;should&lt;/em&gt; be the same before and after the operation.</source>
          <target state="translated">掩码数组支持算术和比较操作。尽可能不处理掩码数组的无效条目，这意味着相应的 &lt;code&gt;data&lt;/code&gt; 条目在操作之前和之后&lt;em&gt;应该&lt;/em&gt;相同。</target>
        </trans-unit>
        <trans-unit id="574e424bf0f02d1b18e3ad5386f39a38953e230d" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operations on &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt; are defined as element-wise operations, and generally yield &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; objects as results.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;上的算术和比较运算被定义为逐元素运算，通常将&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;对象作为结果。</target>
        </trans-unit>
        <trans-unit id="6179dfdf1f721c4f139e7add385d54ea9025725c" translate="yes" xml:space="preserve">
          <source>Arithmetic is modular when using integer types, and no error is raised on overflow.</source>
          <target state="translated">当使用整数类型时,算术是模块化的,在溢出时不会出现错误。</target>
        </trans-unit>
        <trans-unit id="72188498e399312affe529bd4d440a03ee9c95e4" translate="yes" xml:space="preserve">
          <source>Arithmetic is modular when using integer types, and no error is raised on overflow. That means that, on a 32-bit platform:</source>
          <target state="translated">在使用整数类型时,算术是模块化的,在溢出时不会产生错误。这意味着,在32位平台上。</target>
        </trans-unit>
        <trans-unit id="339f6492877ce24a534c3f1e9110c317be457d3a" translate="yes" xml:space="preserve">
          <source>Arithmetic mean taken while not ignoring NaNs</source>
          <target state="translated">在不忽略NaNs的情况下采取的算术平均值。</target>
        </trans-unit>
        <trans-unit id="1fc0feb17ac2848b9f01591a445a367739c560da" translate="yes" xml:space="preserve">
          <source>Arithmetic operations</source>
          <target state="translated">算术运算</target>
        </trans-unit>
        <trans-unit id="7ee1fda772751523c2669ec2f48ddc06e8ec6d54" translate="yes" xml:space="preserve">
          <source>Arithmetic operators on arrays apply &lt;em&gt;elementwise&lt;/em&gt;. A new array is created and filled with the result.</source>
          <target state="translated">数组上的算术运算符适用于&lt;em&gt;elementwise&lt;/em&gt;。创建一个新数组，并用结果填充。</target>
        </trans-unit>
        <trans-unit id="16ba88bd7d8f2b893c09bcff737706246adcbc3b" translate="yes" xml:space="preserve">
          <source>Arithmetic, in-place:</source>
          <target state="translated">算术,就地取材。</target>
        </trans-unit>
        <trans-unit id="ac2131c4955b2cce396141546558f75712964834" translate="yes" xml:space="preserve">
          <source>Arithmetic, matrix multiplication, and comparison operations</source>
          <target state="translated">算术、矩阵乘法和比较运算。</target>
        </trans-unit>
        <trans-unit id="d534ca6745f09f171b20632796505d5bd60949d7" translate="yes" xml:space="preserve">
          <source>Arithmetic:</source>
          <target state="translated">Arithmetic:</target>
        </trans-unit>
        <trans-unit id="0771a753fa9fe721bf5720d2f9bacca79fff9e8e" translate="yes" xml:space="preserve">
          <source>Arithmetics</source>
          <target state="translated">Arithmetics</target>
        </trans-unit>
        <trans-unit id="dfc7a32fa9a79ec3a22472c368d871d5e78afd31" translate="yes" xml:space="preserve">
          <source>Array (possibly multi-dimensional) of values for which to to calculate &lt;code&gt;sinc(x)&lt;/code&gt;.</source>
          <target state="translated">要为其计算 &lt;code&gt;sinc(x)&lt;/code&gt; 的值的数组（可能是多维的）。</target>
        </trans-unit>
        <trans-unit id="0523df413b1fea0ba7975ab7c9175833f364830f" translate="yes" xml:space="preserve">
          <source>Array &lt;strong&gt;attributes&lt;/strong&gt; reflect information intrinsic to the array itself. If you need to get, or even set, properties of an array without creating a new array, you can often access an array through its attributes.</source>
          <target state="translated">数组&lt;strong&gt;属性&lt;/strong&gt;反映了数组本身固有的信息。如果您需要获取甚至设置数组的属性而不创建新数组，则通常可以通过其属性访问数组。</target>
        </trans-unit>
        <trans-unit id="6951f36c01ac0e1bf34c5ee5904784fafce57b89" translate="yes" xml:space="preserve">
          <source>Array API</source>
          <target state="translated">阵列API</target>
        </trans-unit>
        <trans-unit id="5555a6fcea0c1d138c4fd9c9348c13792e83ec8b" translate="yes" xml:space="preserve">
          <source>Array Attributes</source>
          <target state="translated">阵列属性</target>
        </trans-unit>
        <trans-unit id="3458034e7e106c04c09c4ec57632af02a473c676" translate="yes" xml:space="preserve">
          <source>Array Broadcasting in Numpy</source>
          <target state="translated">Numpy中的阵列广播</target>
        </trans-unit>
        <trans-unit id="0c1a37c234fe9514069c7363784bf98af15b8355" translate="yes" xml:space="preserve">
          <source>Array Creation</source>
          <target state="translated">阵列创建</target>
        </trans-unit>
        <trans-unit id="daa02d3f49bf321fb5979b03ac56b6cd9657dfad" translate="yes" xml:space="preserve">
          <source>Array Functions</source>
          <target state="translated">阵列函数</target>
        </trans-unit>
        <trans-unit id="12d693ff9b1c0d4047e2b7848ca27e4c2aad6719" translate="yes" xml:space="preserve">
          <source>Array Iterator</source>
          <target state="translated">阵列迭代器</target>
        </trans-unit>
        <trans-unit id="043a8c676a7d5d7051367cd8181a4b07707df511" translate="yes" xml:space="preserve">
          <source>Array Iterator API</source>
          <target state="translated">阵列迭代器API</target>
        </trans-unit>
        <trans-unit id="23211b01eb261a332c7929b935052183b79935ba" translate="yes" xml:space="preserve">
          <source>Array Iterators</source>
          <target state="translated">阵列迭代器</target>
        </trans-unit>
        <trans-unit id="17e44520a1762d19a9e642fb414c494c724cbf21" translate="yes" xml:space="preserve">
          <source>Array Scalars</source>
          <target state="translated">阵列标尺</target>
        </trans-unit>
        <trans-unit id="d8dbcc76e586f64f22d24c3030096b5747dde0a4" translate="yes" xml:space="preserve">
          <source>Array arguments</source>
          <target state="translated">阵列参数</target>
        </trans-unit>
        <trans-unit id="2ec85771e631fd3b121a1ff64071bd20ad9c65bf" translate="yes" xml:space="preserve">
          <source>Array attributes</source>
          <target state="translated">阵列属性</target>
        </trans-unit>
        <trans-unit id="447450427b5d5b0e87b960a4d40e39c7fb5454bf" translate="yes" xml:space="preserve">
          <source>Array attributes reflect information that is intrinsic to the array itself. Generally, accessing an array through its attributes allows you to get and sometimes set intrinsic properties of the array without creating a new array. The exposed attributes are the core parts of an array and only some of them can be reset meaningfully without creating a new array. Information on each attribute is given below.</source>
          <target state="translated">数组属性反映的是数组本身的内在信息。一般来说,通过数组的属性访问数组,可以在不创建新数组的情况下,获取和设置数组的固有属性。暴露的属性是一个数组的核心部分,只有部分属性可以在不创建新数组的情况下进行有意义的重置。下面给出了每个属性的信息。</target>
        </trans-unit>
        <trans-unit id="43e339bdd3d217a5df3e10b8dade9046731deb5f" translate="yes" xml:space="preserve">
          <source>Array axis summations, &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;numpy.sum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">数组轴求和&lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;numpy.sum&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2c33d8dc2ce945222653dfcc314e267ebd95901" translate="yes" xml:space="preserve">
          <source>Array coercion changes when Strings and other types are mixed</source>
          <target state="translated">当Strings和其他类型混合时,阵列胁迫会发生变化。</target>
        </trans-unit>
        <trans-unit id="c3499b80a79c532bb5bd65ecb4071851e51014ae" translate="yes" xml:space="preserve">
          <source>Array coercion restructure</source>
          <target state="translated">阵列胁迫重组</target>
        </trans-unit>
        <trans-unit id="57c60efa53930ae07f9d8ba23de0e194c69cf7fe" translate="yes" xml:space="preserve">
          <source>Array comparison assertions include maximum differences</source>
          <target state="translated">阵列比较断言包括最大差异</target>
        </trans-unit>
        <trans-unit id="347b135c7cac14f05d7b1660f5d4b4c54f55d66d" translate="yes" xml:space="preserve">
          <source>Array comparisons involving strings or structured dtypes</source>
          <target state="translated">涉及字符串或结构化dtypes的数组比较。</target>
        </trans-unit>
        <trans-unit id="d7a5d8de55dabc36dc25c0b90e8906cffcb6a61a" translate="yes" xml:space="preserve">
          <source>Array containing data to be averaged. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">包含要求平均值的数据的数组。如果 &lt;code&gt;a&lt;/code&gt; 不是数组，则尝试进行转换。</target>
        </trans-unit>
        <trans-unit id="54d016905c8d5e8ccde24c37f9843bcd318cb81c" translate="yes" xml:space="preserve">
          <source>Array containing elements to clip.</source>
          <target state="translated">包含要剪辑的元素的数组。</target>
        </trans-unit>
        <trans-unit id="3961c6f8eadfe688bca31469d6a9f6d86adf81c6" translate="yes" xml:space="preserve">
          <source>Array containing number of representable floating point numbers between items in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">数组，其中包含 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 中的项之间可表示的浮点数。</target>
        </trans-unit>
        <trans-unit id="3692161b3a773c7a966c7715be4b4e9968f11340" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose maximum is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">包含所需最大值的数字的数组。如果 &lt;code&gt;a&lt;/code&gt; 不是数组，则尝试进行转换。</target>
        </trans-unit>
        <trans-unit id="e6449394cdaf60dea5ac71fdd09a0ed9e9fcf7ee" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose mean is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">包含期望平均值的数字的数组。如果 &lt;code&gt;a&lt;/code&gt; 不是数组，则尝试进行转换。</target>
        </trans-unit>
        <trans-unit id="535ad2f426544f7de05e5d9017d86d66f0dc26b1" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose minimum is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">包含所需最小值的数字的数组。如果 &lt;code&gt;a&lt;/code&gt; 不是数组，则尝试进行转换。</target>
        </trans-unit>
        <trans-unit id="64bc244f5b24dc5faeb077670f074a7e20727322" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose product is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">包含需要其乘积的数字的数组。如果 &lt;code&gt;a&lt;/code&gt; 不是数组，则尝试进行转换。</target>
        </trans-unit>
        <trans-unit id="ee6ece6461a907cbfdfd61282756037912ce23f3" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose sum is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">包含所需总和的数字的数组。如果 &lt;code&gt;a&lt;/code&gt; 不是数组，则尝试进行转换。</target>
        </trans-unit>
        <trans-unit id="2effaddf77c674bd9a13dc031c59b1eb4d28fa23" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose variance is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">包含需要方差的数字的数组。如果 &lt;code&gt;a&lt;/code&gt; 不是数组，则尝试进行转换。</target>
        </trans-unit>
        <trans-unit id="f011f52156b6489c00057dbaf1f239251b746676" translate="yes" xml:space="preserve">
          <source>Array containing the roots of the series.</source>
          <target state="translated">包含系列根的阵列。</target>
        </trans-unit>
        <trans-unit id="d1fb2d0b90ad27fe772216fd0efb4378564945a2" translate="yes" xml:space="preserve">
          <source>Array contents</source>
          <target state="translated">阵列内容</target>
        </trans-unit>
        <trans-unit id="2ea33ca743035321174ecf9d435d32b0b6324742" translate="yes" xml:space="preserve">
          <source>Array conversion</source>
          <target state="translated">阵列转换</target>
        </trans-unit>
        <trans-unit id="fc6b3a513ef2597bc0f03a1e823241af5164729d" translate="yes" xml:space="preserve">
          <source>Array convolution. Same output as polymul, but has parameter for overlap mode.</source>
          <target state="translated">阵列卷积。与 polymul 的输出相同,但有重叠模式的参数。</target>
        </trans-unit>
        <trans-unit id="57c72a1a53b95fbe1af3976c75af0287d5c9a140" translate="yes" xml:space="preserve">
          <source>Array creation</source>
          <target state="translated">阵列创建</target>
        </trans-unit>
        <trans-unit id="b5a18bd4e3702b73f0e8bbba0d5f2e2fddff6728" translate="yes" xml:space="preserve">
          <source>Array creation routines</source>
          <target state="translated">阵列创建例程</target>
        </trans-unit>
        <trans-unit id="a51f0e8ac2e03ac06587c6b47fb57edec0450c93" translate="yes" xml:space="preserve">
          <source>Array data to be saved.</source>
          <target state="translated">要保存的阵列数据。</target>
        </trans-unit>
        <trans-unit id="4e68baef4a7d203aefd9d4a59b835fc6af2a5db3" translate="yes" xml:space="preserve">
          <source>Array data-type.</source>
          <target state="translated">阵列数据类型。</target>
        </trans-unit>
        <trans-unit id="52dbdba544f09b15fca774eb24a9caf2434bcfe6" translate="yes" xml:space="preserve">
          <source>Array desired.</source>
          <target state="translated">所需阵列。</target>
        </trans-unit>
        <trans-unit id="785376e3605a2b132b04a5af283162b0f7133160" translate="yes" xml:space="preserve">
          <source>Array flags</source>
          <target state="translated">阵列标志</target>
        </trans-unit>
        <trans-unit id="746aa39a47d26f55bf62b76f045191bc2131b857" translate="yes" xml:space="preserve">
          <source>Array flags provide information about how the memory area used for the array is to be interpreted. There are 7 Boolean flags in use, only four of which can be changed by the user: WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.</source>
          <target state="translated">阵列标志提供了关于如何解释用于阵列的内存区域的信息。有7个布尔标志在使用,其中只有4个可以由用户改变。WRITEBACKIFCOPY、UPDATEIFCOPY、WRITEABLE和ALIGNED。</target>
        </trans-unit>
        <trans-unit id="5f6e91f1df0558c7246187a2b89a1e305be167b2" translate="yes" xml:space="preserve">
          <source>Array flags; may be one or more of:</source>
          <target state="translated">阵列标志;可以是以下一项或多项:</target>
        </trans-unit>
        <trans-unit id="09f0fcdcc100e898aaa63b04e30eafb660bbc3ed" translate="yes" xml:space="preserve">
          <source>Array from which the diagonals are taken.</source>
          <target state="translated">取对角线的阵列。</target>
        </trans-unit>
        <trans-unit id="3966916957967be244949812c17944d586ffd56d" translate="yes" xml:space="preserve">
          <source>Array from which to extract a part.</source>
          <target state="translated">用于提取零件的阵列。</target>
        </trans-unit>
        <trans-unit id="e35c942121269158d9bce83e940f79fd38671bbd" translate="yes" xml:space="preserve">
          <source>Array indexing refers to any use of the square brackets ([]) to index array values. There are many options to indexing, which give numpy indexing great power, but with power comes some complexity and the potential for confusion. This section is just an overview of the various options and issues related to indexing. Aside from single element indexing, the details on most of these options are to be found in related sections.</source>
          <target state="translated">数组索引指的是任何使用方括号([])对数组值进行索引。索引有很多选项,这给numpy索引带来了巨大的威力,但威力的同时也带来了一定的复杂性和混淆的可能性。本节只是概述与索引有关的各种选项和问题。除了单元素索引外,关于这些选项的大部分细节都可以在相关章节中找到。</target>
        </trans-unit>
        <trans-unit id="4a877fe238b2290421c4de0ccb250aa8e3797a13" translate="yes" xml:space="preserve">
          <source>Array interface</source>
          <target state="translated">阵列接口</target>
        </trans-unit>
        <trans-unit id="533db24c36bf6bd74ce0240469f4033043848386" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">数组诠释 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1230519a64fd2e0f26f95201257e208e07092a99" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is an ndarray or a subclass of ndarray, it is returned as-is and no copy is performed.</source>
          <target state="translated">数组诠释 &lt;code&gt;a&lt;/code&gt; 。如果 &lt;code&gt;a&lt;/code&gt; 是ndarray或ndarray的子​​类，则按原样返回它，并且不执行任何复制。</target>
        </trans-unit>
        <trans-unit id="2a004555e4ca47c97c392427144fe0dcc6f68634" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;. No copy is performed if the input is already an ndarray with matching dtype and order. If &lt;code&gt;a&lt;/code&gt; is a subclass of ndarray, a base class ndarray is returned.</source>
          <target state="translated">数组诠释 &lt;code&gt;a&lt;/code&gt; 。如果输入已经是具有匹配dtype和order的ndarray，则不执行复制。如果 &lt;code&gt;a&lt;/code&gt; 是ndarray的子​​类，则返回基类ndarray。</target>
        </trans-unit>
        <trans-unit id="9a82a73ea4a83ace24f5a89b08b00620d66cb5bf" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;. No copy is performed if the input is already an ndarray. If &lt;code&gt;a&lt;/code&gt; is a subclass of ndarray, a base class ndarray is returned.</source>
          <target state="translated">数组诠释 &lt;code&gt;a&lt;/code&gt; 。如果输入已经是ndarray，则不执行复制。如果 &lt;code&gt;a&lt;/code&gt; 是ndarray的子​​类，则返回基类ndarray。</target>
        </trans-unit>
        <trans-unit id="1af36487281180923aa6bea35e0e5228dcc2e12d" translate="yes" xml:space="preserve">
          <source>Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output.</source>
          <target state="translated">放置输出的数组。它的类型被保留下来,并且必须是正确的形状,以容纳输出。</target>
        </trans-unit>
        <trans-unit id="02f71c6bb3adeae64ae8bccd5d811288aeb1d5e1" translate="yes" xml:space="preserve">
          <source>Array into which the result can be placed. Its type is preserved and it must be of the right shape to hold the output.</source>
          <target state="translated">可将结果放入的数组。它的类型被保留下来,并且必须是正确的形状,以容纳输出。</target>
        </trans-unit>
        <trans-unit id="1a57f1ce3b565cb3497401b660e08581c3aafec2" translate="yes" xml:space="preserve">
          <source>Array like index object or slice object for indexing into first operand. If first operand has multiple dimensions, indices can be a tuple of array like index objects or slice objects.</source>
          <target state="translated">像数组一样的索引对象或切片对象,用于对第一操作数进行索引。如果第一操作数有多个维度,索引可以是一个类似数组的索引对象或切片对象的元组。</target>
        </trans-unit>
        <trans-unit id="d40d802fdd7ba3f82f5c9dc44f415145a1e22c74" translate="yes" xml:space="preserve">
          <source>Array manipulation routines</source>
          <target state="translated">阵列操作例程</target>
        </trans-unit>
        <trans-unit id="069ff2b332e403300b9cde701bf5368c5831882c" translate="yes" xml:space="preserve">
          <source>Array method alternative API</source>
          <target state="translated">阵列方法替代API</target>
        </trans-unit>
        <trans-unit id="5a716333b00a93ed3236b0b9385a0a127035480c" translate="yes" xml:space="preserve">
          <source>Array methods</source>
          <target state="translated">阵列方法</target>
        </trans-unit>
        <trans-unit id="4e4004372e15259457b2d1e38548f61c9bc5e00d" translate="yes" xml:space="preserve">
          <source>Array mixins</source>
          <target state="translated">阵列混频器</target>
        </trans-unit>
        <trans-unit id="f161aeb75d90d23a000f60fbe55cf3eae07ee334" translate="yes" xml:space="preserve">
          <source>Array objects</source>
          <target state="translated">阵列对象</target>
        </trans-unit>
        <trans-unit id="cf093406a8132eb8bfd9cf1020e69e3fe6518645" translate="yes" xml:space="preserve">
          <source>Array obtained.</source>
          <target state="translated">获得的阵列。</target>
        </trans-unit>
        <trans-unit id="6b0a1f1e944aed373e67de14ba6a79b095a23306" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;fill_value&lt;/code&gt; with the given shape, dtype, and order.</source>
          <target state="translated">具有给定形状， &lt;code&gt;fill_value&lt;/code&gt; 和顺序的fill_value数组。</target>
        </trans-unit>
        <trans-unit id="141b0992112c657405943baa4a593bdfd3d362b8" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;fill_value&lt;/code&gt; with the same shape and type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">的阵列 &lt;code&gt;fill_value&lt;/code&gt; 具有相同的形状和类型为 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4591434d561c417ccddebc05c5c4eae4564de2b" translate="yes" xml:space="preserve">
          <source>Array of Chebyshev series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Chebyshev系列系数的阵列。如果c是多维的,不同的轴对应不同的变量,每个轴的度数由相应的指数给出。</target>
        </trans-unit>
        <trans-unit id="4f8604db9d0154dd7eb0dded915686a2e44b5243" translate="yes" xml:space="preserve">
          <source>Array of Hermite series coefficients. If &lt;code&gt;c&lt;/code&gt; is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Hermite级数系数的数组。如果 &lt;code&gt;c&lt;/code&gt; 是多维的，则不同的轴对应于不同的变量，每个轴的度数由相应的索引指定。</target>
        </trans-unit>
        <trans-unit id="817eb4e4585a916e35d1ff46432ac14702692600" translate="yes" xml:space="preserve">
          <source>Array of Hermite series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">赫米特系列系数的阵列。如果c是多维的,则不同的轴对应不同的变量,每个轴的度数由相应的指数给出。</target>
        </trans-unit>
        <trans-unit id="6bb7459da4388ebdd50a78addd0898c1f80aabbe" translate="yes" xml:space="preserve">
          <source>Array of Hermite_e series coefficients. If &lt;code&gt;c&lt;/code&gt; is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Hermite_e系列系数的数组。如果 &lt;code&gt;c&lt;/code&gt; 是多维的，则不同的轴对应于不同的变量，每个轴的度数由相应的索引指定。</target>
        </trans-unit>
        <trans-unit id="63e65a5158a929fafcbc4f8f156592488b9429ea" translate="yes" xml:space="preserve">
          <source>Array of Hermite_e series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Hermite_e系列系数的阵列。如果c是多维的,则不同的轴对应不同的变量,每个轴的度数由相应的索引给出。</target>
        </trans-unit>
        <trans-unit id="1ea8d2a10d04a6eb03ee934ed9f9008e87ff51dc" translate="yes" xml:space="preserve">
          <source>Array of Laguerre series coefficients. If &lt;code&gt;c&lt;/code&gt; is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Laguerre级数系数的数组。如果 &lt;code&gt;c&lt;/code&gt; 是多维的，则不同的轴对应于不同的变量，每个轴的度数由相应的索引指定。</target>
        </trans-unit>
        <trans-unit id="35c007605e6d77452f8dad5eb06d7938bab0902f" translate="yes" xml:space="preserve">
          <source>Array of Legendre series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Legendre系列系数的阵列。如果c是多维的,不同的轴对应不同的变量,每个轴的度数由相应的指数给出。</target>
        </trans-unit>
        <trans-unit id="4261b4b77833f5ffb9b4ec031af96d60404d62e0" translate="yes" xml:space="preserve">
          <source>Array of angles in radians, in the range &lt;code&gt;[-pi, pi]&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">以弧度表示的角度数组，范围为 &lt;code&gt;[-pi, pi]&lt;/code&gt; 。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="d00b51bfc114fceca7b5e804468ddaae71dd1f04" translate="yes" xml:space="preserve">
          <source>Array of bins. It has to be 1-dimensional and monotonic.</source>
          <target state="translated">仓的阵列。它必须是一维的和单调的。</target>
        </trans-unit>
        <trans-unit id="2431f4c023950cb461e657c537178d58e27e27dd" translate="yes" xml:space="preserve">
          <source>Array of booleans</source>
          <target state="translated">布尔汉数组</target>
        </trans-unit>
        <trans-unit id="536a897428fe0f47a3d34f49d6446e12ae81a0e0" translate="yes" xml:space="preserve">
          <source>Array of booleans identical in shape to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">到布尔形状相同的阵列 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a77bc6459d956649f3ae15d32c4f2c19eb8edf06" translate="yes" xml:space="preserve">
          <source>Array of booleans of same shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">相同的形状的布尔值作为阵列 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a658696b6a89082b912ff090b4b6b37dee9b715c" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in &lt;code&gt;c[i,j]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than 2 the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">排序的系数数组，以便将多度项i，j的系数包含在 &lt;code&gt;c[i,j]&lt;/code&gt; 。如果 &lt;code&gt;c&lt;/code&gt; 的维数大于2，则其余索引将枚举多组系数。</target>
        </trans-unit>
        <trans-unit id="56c372955c6e7c782716979251e8af46e2f83f0a" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in &lt;code&gt;c[i,j]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">排序的系数数组，以便将多度项i，j的系数包含在 &lt;code&gt;c[i,j]&lt;/code&gt; 。如果 &lt;code&gt;c&lt;/code&gt; 的维数大于2，则其余索引将枚举多组系数。</target>
        </trans-unit>
        <trans-unit id="fa76e8a2aedbceba248a9fc307fb834762ffa569" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in &lt;code&gt;c[i,j,k]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">排序的系数数组，以便将多度项i，j，k的系数包含在 &lt;code&gt;c[i,j,k]&lt;/code&gt; 。如果 &lt;code&gt;c&lt;/code&gt; 的维数大于3，则其余索引将枚举多组系数。</target>
        </trans-unit>
        <trans-unit id="2ca7ab8cb88305034f9c8ff4c4bec7fdbf7384a0" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in &lt;code&gt;c[i,j]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">有序系数数组，以使度数i，j的系数包含在 &lt;code&gt;c[i,j]&lt;/code&gt; 。如果 &lt;code&gt;c&lt;/code&gt; 的维数大于2，则其余索引将枚举多组系数。</target>
        </trans-unit>
        <trans-unit id="013054b355ed269971a257a22db8c61fecab58bc" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If &lt;code&gt;c&lt;/code&gt; is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">排序的系数数组，以便将度为n的系数包含在c [n]中。如果 &lt;code&gt;c&lt;/code&gt; 是多维的，则剩余索引将枚举多个多项式。在二维情况下，系数可以认为存储在 &lt;code&gt;c&lt;/code&gt; 列中。</target>
        </trans-unit>
        <trans-unit id="00bc78cb48de3651884eadaf718d38e560006d25" translate="yes" xml:space="preserve">
          <source>Array of evenly spaced values.</source>
          <target state="translated">均匀间隔的数值阵列。</target>
        </trans-unit>
        <trans-unit id="2d1560c385ed8ca347f0a453a1d3ede23238d315" translate="yes" xml:space="preserve">
          <source>Array of indices into the array. It has the same shape as &lt;code&gt;a.shape&lt;/code&gt; with the dimension along &lt;code&gt;axis&lt;/code&gt; removed.</source>
          <target state="translated">索引数组进入数组。它具有与 &lt;code&gt;a.shape&lt;/code&gt; 相同的形状，但沿 &lt;code&gt;axis&lt;/code&gt; 的尺寸已删除。</target>
        </trans-unit>
        <trans-unit id="a8ca40e5ac25fd9b6c7a437f8b20abf87b6dd448" translate="yes" xml:space="preserve">
          <source>Array of indices that partition &lt;code&gt;a&lt;/code&gt; along the specified axis. If &lt;code&gt;a&lt;/code&gt; is one-dimensional, &lt;code&gt;a[index_array]&lt;/code&gt; yields a partitioned &lt;code&gt;a&lt;/code&gt;. More generally, &lt;code&gt;np.take_along_axis(a, index_array, axis=a)&lt;/code&gt; always yields the partitioned &lt;code&gt;a&lt;/code&gt;, irrespective of dimensionality.</source>
          <target state="translated">沿指定轴划分 &lt;code&gt;a&lt;/code&gt; 的索引数组。如果 &lt;code&gt;a&lt;/code&gt; 是一维的，则 &lt;code&gt;a[index_array]&lt;/code&gt; 产生分区 &lt;code&gt;a&lt;/code&gt; 。更一般而言， &lt;code&gt;np.take_along_axis(a, index_array, axis=a)&lt;/code&gt; 总是产生分区 &lt;code&gt;a&lt;/code&gt; ，而与维数无关。</target>
        </trans-unit>
        <trans-unit id="8b6035bba7c71c43b0b9bba16cae62cbd47fc547" translate="yes" xml:space="preserve">
          <source>Array of indices that sort &lt;code&gt;a&lt;/code&gt; along the specified &lt;code&gt;axis&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is one-dimensional, &lt;code&gt;a[index_array]&lt;/code&gt; yields a sorted &lt;code&gt;a&lt;/code&gt;. More generally, &lt;code&gt;np.take_along_axis(a, index_array, axis=axis)&lt;/code&gt; always yields the sorted &lt;code&gt;a&lt;/code&gt;, irrespective of dimensionality.</source>
          <target state="translated">沿指定 &lt;code&gt;axis&lt;/code&gt; 对 &lt;code&gt;a&lt;/code&gt; 排序的索引数组。如果 &lt;code&gt;a&lt;/code&gt; 是一维的，则 &lt;code&gt;a[index_array]&lt;/code&gt; 产生排序的 &lt;code&gt;a&lt;/code&gt; 。更一般而言， &lt;code&gt;np.take_along_axis(a, index_array, axis=axis)&lt;/code&gt; 总是产生排序的 &lt;code&gt;a&lt;/code&gt; ，而与维数无关。</target>
        </trans-unit>
        <trans-unit id="a0dc6273aecd116e71b925f830b8b852ca18868e" translate="yes" xml:space="preserve">
          <source>Array of indices that sort &lt;code&gt;a&lt;/code&gt; along the specified axis. In other words, &lt;code&gt;a[index_array]&lt;/code&gt; yields a sorted &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">索引的阵列那种 &lt;code&gt;a&lt;/code&gt; 沿指定轴线。换句话说， &lt;code&gt;a[index_array]&lt;/code&gt; 产生一个排序的 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87cf8b4326e4bf74829f6ee998b605e627a3e05c" translate="yes" xml:space="preserve">
          <source>Array of indices that sort the keys along the specified axis.</source>
          <target state="translated">沿着指定的轴对键进行排序的索引数组。</target>
        </trans-unit>
        <trans-unit id="9ba877503fdc9b234f8b5bd4ff989ab5b66a993a" translate="yes" xml:space="preserve">
          <source>Array of insertion points with the same shape as &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;v&lt;/code&gt; 形状相同的插入点数组。</target>
        </trans-unit>
        <trans-unit id="eda2f2ab5893d6c8f805112f168403bde8914bdc" translate="yes" xml:space="preserve">
          <source>Array of length &lt;code&gt;n//2 + 1&lt;/code&gt; containing the sample frequencies.</source>
          <target state="translated">长度为 &lt;code&gt;n//2 + 1&lt;/code&gt; 数组，其中包含采样频率。</target>
        </trans-unit>
        <trans-unit id="16403e1679edece0422b414ba8df64826286ea95" translate="yes" xml:space="preserve">
          <source>Array of length &lt;code&gt;n&lt;/code&gt; containing the sample frequencies.</source>
          <target state="translated">长度为 &lt;code&gt;n&lt;/code&gt; 的数组，包含采样频率。</target>
        </trans-unit>
        <trans-unit id="3e56b710dd7f0b21c34a3b08ffd09a687bf4487b" translate="yes" xml:space="preserve">
          <source>Array of list objects</source>
          <target state="translated">列表对象阵列</target>
        </trans-unit>
        <trans-unit id="8a37d72f2b1b4102a1be6ef75c473c25a6af0723" translate="yes" xml:space="preserve">
          <source>Array of multipliers.</source>
          <target state="translated">乘法器阵列。</target>
        </trans-unit>
        <trans-unit id="206e9ffd7bd541d0301a39acc4ace879a4a8c4c0" translate="yes" xml:space="preserve">
          <source>Array of numbers to be decomposed.</source>
          <target state="translated">要分解的数组。</target>
        </trans-unit>
        <trans-unit id="b8d93545bf76db1e421350de1ab5b27bda265c94" translate="yes" xml:space="preserve">
          <source>Array of ones with the given shape, dtype, and order.</source>
          <target state="translated">具有给定形状、dtype和顺序的1的阵列。</target>
        </trans-unit>
        <trans-unit id="2a7562df8fd2349ba86c3e8c830bce9f44d2768c" translate="yes" xml:space="preserve">
          <source>Array of ones with the same shape and type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">那些具有相同形状和类型的阵列 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c57697e4962f7c2af124e859e719b69080933cff" translate="yes" xml:space="preserve">
          <source>Array of ones.</source>
          <target state="translated">一的阵列。</target>
        </trans-unit>
        <trans-unit id="baa4adf58634fb06ef6ad2372bc5421740221f26" translate="yes" xml:space="preserve">
          <source>Array of points of the same shape as &lt;code&gt;x&lt;/code&gt;, after application of the linear map between the two domains.</source>
          <target state="translated">在两个域之间应用线性映射后，与 &lt;code&gt;x&lt;/code&gt; 形状相同的点的数组。</target>
        </trans-unit>
        <trans-unit id="e10ad4b8d9ac04992efd38f05d15c560adaf42ef" translate="yes" xml:space="preserve">
          <source>Array of points. The dtype is converted to float64 or complex128 depending on whether any of the elements are complex. If &lt;code&gt;x&lt;/code&gt; is scalar it is converted to a 1-D array.</source>
          <target state="translated">点数组。dtype将根据任何元素是否为复数转换为float64或complex128。如果 &lt;code&gt;x&lt;/code&gt; 为标量，则将其转换为一维数组。</target>
        </trans-unit>
        <trans-unit id="2608e7cd905fe0c68e32ec9f1d08d5e186ac4133" translate="yes" xml:space="preserve">
          <source>Array of polynomial coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">多项式系数的阵列。如果c是多维的,则不同的轴对应不同的变量,每个轴的度数由相应的指数给出。</target>
        </trans-unit>
        <trans-unit id="df9f1c9c3e6efbfb4f90ed818292071092d8d4f0" translate="yes" xml:space="preserve">
          <source>Array of random floats of shape &lt;code&gt;size&lt;/code&gt; (unless &lt;code&gt;size=None&lt;/code&gt;, in which case a single float is returned).</source>
          <target state="translated">形状 &lt;code&gt;size&lt;/code&gt; 随机浮点数组（除非 &lt;code&gt;size=None&lt;/code&gt; ，否则返回单个浮点）。</target>
        </trans-unit>
        <trans-unit id="8c27164f605bc6a37751898bf3ccca7ad65d8b8c" translate="yes" xml:space="preserve">
          <source>Array of roots. If &lt;code&gt;r&lt;/code&gt; is multidimensional the first index is the root index, while the remaining indices enumerate multiple polynomials. For instance, in the two dimensional case the roots of each polynomial may be thought of as stored in the columns of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">根数组。如果 &lt;code&gt;r&lt;/code&gt; 为多维，则第一个索引为根索引，而其余索引枚举多个多项式。例如，在二维情况下，可以将每个多项式的根视为存储在 &lt;code&gt;r&lt;/code&gt; 的列中。</target>
        </trans-unit>
        <trans-unit id="f5e105f8faad33b4f50f2c4896fe5c70b476d2c2" translate="yes" xml:space="preserve">
          <source>Array of the roots of the polynomial. If all the roots are real, then &lt;code&gt;out&lt;/code&gt; is also real, otherwise it is complex.</source>
          <target state="translated">多项式的根的数组。如果所有的根都是真实的，那么 &lt;code&gt;out&lt;/code&gt; 也是真实的，否则它是复杂的。</target>
        </trans-unit>
        <trans-unit id="4d0d9a7ae0205565ce5ab6637ea0bc6fd758edf0" translate="yes" xml:space="preserve">
          <source>Array of the roots of the series. If all the roots are real, then &lt;code&gt;out&lt;/code&gt; is also real, otherwise it is complex.</source>
          <target state="translated">系列根的数组。如果所有的根都是真实的，那么 &lt;code&gt;out&lt;/code&gt; 也是真实的，否则它是复杂的。</target>
        </trans-unit>
        <trans-unit id="d523e60421af0d15597be465d458af223885d81e" translate="yes" xml:space="preserve">
          <source>Array of the same shape as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">与 &lt;code&gt;x&lt;/code&gt; 形状相同的数组。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="8fb65c76565be83184293a727b86b612f6baa966" translate="yes" xml:space="preserve">
          <source>Array of the same type and shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">相同的类型和形状的阵列 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cde597bca9a6bd0298c0f76843af628711adacdc" translate="yes" xml:space="preserve">
          <source>Array of two or more dimensions.</source>
          <target state="translated">两个或多个维度的阵列。</target>
        </trans-unit>
        <trans-unit id="9c36b99254e0fa9d0972f22709ef88f81c5217da" translate="yes" xml:space="preserve">
          <source>Array of twos exponents. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">二进制指数数组。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="ef176723af239a8b84441eb4e1012c9997a74190" translate="yes" xml:space="preserve">
          <source>Array of type uint8 whose elements represent bits corresponding to the logical (0 or nonzero) value of the input elements. The shape of &lt;code&gt;packed&lt;/code&gt; has the same number of dimensions as the input (unless &lt;code&gt;axis&lt;/code&gt; is None, in which case the output is 1-D).</source>
          <target state="translated">uint8类型的数组，其元素表示对应于输入元素的逻辑（0或非零）值的位。 &lt;code&gt;packed&lt;/code&gt; 的形状具有与输入相同的尺寸数（除非 &lt;code&gt;axis&lt;/code&gt; 为None，在这种情况下输出为1-D）。</target>
        </trans-unit>
        <trans-unit id="d136dd4eb12fa67aaa6854e035f05c7d1d6e0269" translate="yes" xml:space="preserve">
          <source>Array of uninitialized (arbitrary) data of the given shape, dtype, and order. Object arrays will be initialized to None.</source>
          <target state="translated">指定形状、dtype和顺序的未初始化(任意)数据数组。对象数组将被初始化为None。</target>
        </trans-unit>
        <trans-unit id="84a6a10448bc129791439e6ef9301081b2eae3db" translate="yes" xml:space="preserve">
          <source>Array of uninitialized (arbitrary) data with the same shape and type as &lt;code&gt;prototype&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;prototype&lt;/code&gt; 具有相同形状和类型的未初始化（任意）数据数组。</target>
        </trans-unit>
        <trans-unit id="1b00e6648235fca7be6befd806901affb44faa6e" translate="yes" xml:space="preserve">
          <source>Array of variates drawn from the multivariate hypergeometric distribution.</source>
          <target state="translated">从多变量超几何分布中提取的变量数组。</target>
        </trans-unit>
        <trans-unit id="e791423834bca116a632635c62e713e7f9a7037b" translate="yes" xml:space="preserve">
          <source>Array of zeros with the given shape, dtype, and order.</source>
          <target state="translated">具有给定形状、dtype和顺序的零数组。</target>
        </trans-unit>
        <trans-unit id="5118cee064bbe572e4b1416e1f0671b0db1bf70d" translate="yes" xml:space="preserve">
          <source>Array of zeros with the same shape and type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">具有相同形状和类型的零的阵列 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16e772e7005bc124d579516af58c7fbb273b27a8" translate="yes" xml:space="preserve">
          <source>Array or &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; object of the difference polynomial&amp;rsquo;s coefficients.</source>
          <target state="translated">差分多项式系数的数组或&lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="dbb2927a7be8102e0b46249ee761be13ecebeed6" translate="yes" xml:space="preserve">
          <source>Array or sequence of arrays storing the fields to add to the base.</source>
          <target state="translated">储存要添加到基数中的字段的数组或数组序列。</target>
        </trans-unit>
        <trans-unit id="95f2bfa93bf415207add71f7123707aa76abefda" translate="yes" xml:space="preserve">
          <source>Array output</source>
          <target state="translated">阵列输出</target>
        </trans-unit>
        <trans-unit id="de7dfcc33834d14fc2a907169048d0358bdabe51" translate="yes" xml:space="preserve">
          <source>Array output, specified fill-in value</source>
          <target state="translated">阵列输出,指定填充值</target>
        </trans-unit>
        <trans-unit id="367e141a4fff1b31230cbf6695c1abe0275a3a68" translate="yes" xml:space="preserve">
          <source>Array priority.</source>
          <target state="translated">阵列优先级。</target>
        </trans-unit>
        <trans-unit id="8afc8a14b9ea339f994a4b92b64eeee0fec93781" translate="yes" xml:space="preserve">
          <source>Array property returning the array transposed.</source>
          <target state="translated">数组属性,返回数组的转置。</target>
        </trans-unit>
        <trans-unit id="e80625fd7e8e2e9a68261ea8336b974ac71427ae" translate="yes" xml:space="preserve">
          <source>Array protocol: Python side</source>
          <target state="translated">阵列协议。Python方面</target>
        </trans-unit>
        <trans-unit id="4090e62e110e0132c9a83e32a1060b0b2b11ae1b" translate="yes" xml:space="preserve">
          <source>Array protocol: struct</source>
          <target state="translated">阵列协议:结构</target>
        </trans-unit>
        <trans-unit id="8bf3a8f5e4206285d07a06e43310e4a207d5bd53" translate="yes" xml:space="preserve">
          <source>Array representing the Chebyshev series of their sum.</source>
          <target state="translated">表示它们的和的切比雪夫数列的阵列。</target>
        </trans-unit>
        <trans-unit id="eb3f194c486d46ce1508a5889e8d0e228c628dfe" translate="yes" xml:space="preserve">
          <source>Array representing the Hermite series of their sum.</source>
          <target state="translated">代表它们的和的赫米特数列的阵列。</target>
        </trans-unit>
        <trans-unit id="18e93cb56abb59b15e14ea61f7ed36817dbde4e6" translate="yes" xml:space="preserve">
          <source>Array representing the Laguerre series of their sum.</source>
          <target state="translated">阵列表示它们的拉格尔数列之和。</target>
        </trans-unit>
        <trans-unit id="ec5ec69f7e2ff45ce04c960bdf2303ea70114cd3" translate="yes" xml:space="preserve">
          <source>Array representing the Legendre series of their sum.</source>
          <target state="translated">表示Legendre数列之和的阵列。</target>
        </trans-unit>
        <trans-unit id="edc338d6dbe8df5cb4ad885aef823a83fa3236d0" translate="yes" xml:space="preserve">
          <source>Array representing the result of the multiplication.</source>
          <target state="translated">代表乘法结果的阵列。</target>
        </trans-unit>
        <trans-unit id="016974069d41d6a6d61d2549905026f66c136979" translate="yes" xml:space="preserve">
          <source>Array scalar checks the value, array does not</source>
          <target state="translated">数组标量检查值,数组不检查。</target>
        </trans-unit>
        <trans-unit id="cc176eaf5a192bedc6a645855de021bd9ca0e1d1" translate="yes" xml:space="preserve">
          <source>Array scalar type</source>
          <target state="translated">阵列标量类型</target>
        </trans-unit>
        <trans-unit id="2ef4e544d40cf2979c0c92b90830370b3508c12a" translate="yes" xml:space="preserve">
          <source>Array scalars can be indexed like 0-dimensional arrays: if &lt;em&gt;x&lt;/em&gt; is an array scalar,</source>
          <target state="translated">数组标量可以像0维数组一样被索引：如果&lt;em&gt;x&lt;/em&gt;是数组标量，</target>
        </trans-unit>
        <trans-unit id="e33eacc8d6c4dbb6e2b8986e0cc11de2dc224ecc" translate="yes" xml:space="preserve">
          <source>Array scalars have exactly the same methods as arrays. The default behavior of these methods is to internally convert the scalar to an equivalent 0-dimensional array and to call the corresponding array method. In addition, math operations on array scalars are defined so that the same hardware flags are set and used to interpret the results as for &lt;a href=&quot;ufuncs#ufuncs&quot;&gt;ufunc&lt;/a&gt;, so that the error state used for ufuncs also carries over to the math on array scalars.</source>
          <target state="translated">数组标量具有与数组完全相同的方法。这些方法的默认行为是在内部将标量转换为等效的0维数组并调用相应的array方法。此外，阵列标量的数学运算被定义，使得在相同的硬件标志被设置，并用于解释结果作为&lt;a href=&quot;ufuncs#ufuncs&quot;&gt;ufunc&lt;/a&gt;，使得用于ufuncs错误状态也延续到上阵列标量的数学。</target>
        </trans-unit>
        <trans-unit id="037bfe1a4a99bed13c2116a48ffe9e15e096321a" translate="yes" xml:space="preserve">
          <source>Array scalars have the same attributes and methods as &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; This allows one to treat items of an array partly on the same footing as arrays, smoothing out rough edges that result when mixing scalar and array operations.</source>
          <target state="translated">数组标量与&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;具有相同的属性和方法。&lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;这样一来，就可以部分地将数组项与数组放在相同的基础上，从而平滑混合标量和数组操作时产生的粗糙边缘。</target>
        </trans-unit>
        <trans-unit id="9e3e59079f5e7b1524c0f3bc70e22cf06a0ad4de" translate="yes" xml:space="preserve">
          <source>Array scalars have the same attributes and methods as &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; This allows one to treat items of an array partly on the same footing as arrays, smoothing out rough edges that result when mixing scalar and array operations.</source>
          <target state="translated">数组标量与&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;具有相同的属性和方法。&lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;这样可以使一部分数组项与数组在相同的基础上处理，从而平滑混合标量和数组操作时产生的粗糙边缘。</target>
        </trans-unit>
        <trans-unit id="646d54d2caceda76929950b800cb978c81f4566e" translate="yes" xml:space="preserve">
          <source>Array scalars live in a hierarchy (see the Figure below) of data types. They can be detected using the hierarchy: For example, &lt;code&gt;isinstance(val, np.generic)&lt;/code&gt; will return &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;val&lt;/em&gt; is an array scalar object. Alternatively, what kind of array scalar is present can be determined using other members of the data type hierarchy. Thus, for example &lt;code&gt;isinstance(val, np.complexfloating)&lt;/code&gt; will return &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;val&lt;/em&gt; is a complex valued type, while &lt;code&gt;isinstance(val, np.flexible)&lt;/code&gt; will return true if &lt;em&gt;val&lt;/em&gt; is one of the flexible itemsize array types (&lt;a href=&quot;#numpy.str_&quot;&gt;&lt;code&gt;str_&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.bytes_&quot;&gt;&lt;code&gt;bytes_&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.void&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">数组标量位于数据类型的层次结构中（请参见下图）。可以使用层次结构检测到它们：例如，如果&lt;em&gt;val&lt;/em&gt;是一个数组标量对象，则 &lt;code&gt;isinstance(val, np.generic)&lt;/code&gt; 将返回&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt;。或者，可以使用数据类型层次结构的其他成员来确定存在哪种数组标量。因此，例如 &lt;code&gt;isinstance(val, np.complexfloating)&lt;/code&gt; 将返回&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt;如果&lt;em&gt;VAL&lt;/em&gt;是一个复值类型，而 &lt;code&gt;isinstance(val, np.flexible)&lt;/code&gt; 将返回真，如果&lt;em&gt;VAL&lt;/em&gt;是柔性itemsize数组类型（之一&lt;a href=&quot;#numpy.str_&quot;&gt; &lt;code&gt;str_&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#numpy.bytes_&quot;&gt; &lt;code&gt;bytes_&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#numpy.void&quot;&gt; &lt;code&gt;void&lt;/code&gt; &lt;/a&gt;）。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ed6ac908bf9aa1daed6dabda3ab37ae3cfe93cc" translate="yes" xml:space="preserve">
          <source>Array scalars live in a hierarchy (see the Figure below) of data types. They can be detected using the hierarchy: For example, &lt;code&gt;isinstance(val, np.generic)&lt;/code&gt; will return &lt;code&gt;True&lt;/code&gt; if &lt;em&gt;val&lt;/em&gt; is an array scalar object. Alternatively, what kind of array scalar is present can be determined using other members of the data type hierarchy. Thus, for example &lt;code&gt;isinstance(val, np.complexfloating)&lt;/code&gt; will return &lt;code&gt;True&lt;/code&gt; if &lt;em&gt;val&lt;/em&gt; is a complex valued type, while &lt;code&gt;isinstance(val, np.flexible)&lt;/code&gt; will return true if &lt;em&gt;val&lt;/em&gt; is one of the flexible itemsize array types (&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;unicode&lt;/code&gt;, &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">数组标量位于数据类型的层次结构中（请参见下图）。可以使用层次结构检测到它们：例如，如果&lt;em&gt;val&lt;/em&gt;是数组标量对象，则 &lt;code&gt;isinstance(val, np.generic)&lt;/code&gt; 将返回 &lt;code&gt;True&lt;/code&gt; 。或者，可以使用数据类型层次结构的其他成员来确定存在哪种数组标量。因此，例如 &lt;code&gt;isinstance(val, np.complexfloating)&lt;/code&gt; 将返回 &lt;code&gt;True&lt;/code&gt; 如果&lt;em&gt;VAL&lt;/em&gt;是一个复值类型，而 &lt;code&gt;isinstance(val, np.flexible)&lt;/code&gt; 如果将返回true &lt;em&gt;VAL&lt;/em&gt;是柔性itemsize数组类型（之一 &lt;code&gt;string&lt;/code&gt; ， &lt;code&gt;unicode&lt;/code&gt; 的， &lt;code&gt;void&lt;/code&gt; ）。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="656531cc575d33e2858cc0fa46ccccf4a68a1757" translate="yes" xml:space="preserve">
          <source>Array shape.</source>
          <target state="translated">阵列形状。</target>
        </trans-unit>
        <trans-unit id="ef64ccc224961e26021d9bca9dc014037c55120d" translate="yes" xml:space="preserve">
          <source>Array structure and data access</source>
          <target state="translated">阵列结构和数据访问</target>
        </trans-unit>
        <trans-unit id="342f29da2bf216f5bdf0ad7248aaa9e71a355727" translate="yes" xml:space="preserve">
          <source>Array that selects which entries to return. If len(condition) is less than the size of &lt;code&gt;a&lt;/code&gt; along the given axis, then output is truncated to the length of the condition array.</source>
          <target state="translated">选择要返回的条目的数组。如果len（condition）小于给定轴上 &lt;code&gt;a&lt;/code&gt; 的大小，则输出将被截断为condition数组的长度。</target>
        </trans-unit>
        <trans-unit id="592206156ca99ae21d8e7426eb607780c1bba521" translate="yes" xml:space="preserve">
          <source>Array that suppressed values indicated by a mask:</source>
          <target state="translated">阵列,抑制由掩码表示的值。</target>
        </trans-unit>
        <trans-unit id="87d2918cacf26a2502b4f9340bca07e66e5e74fe" translate="yes" xml:space="preserve">
          <source>Array to be divided into sub-arrays.</source>
          <target state="translated">要分割成子数组的数组。</target>
        </trans-unit>
        <trans-unit id="e4b60ba832fd5d14a8b64e94627ba0a71256396f" translate="yes" xml:space="preserve">
          <source>Array to be reshaped.</source>
          <target state="translated">要重塑的阵列。</target>
        </trans-unit>
        <trans-unit id="873958f5c5efd8efa35f71b483ecb2b2925a1b71" translate="yes" xml:space="preserve">
          <source>Array to be resized.</source>
          <target state="translated">要调整大小的阵列。</target>
        </trans-unit>
        <trans-unit id="a56492e54afe7d74e97671bd4eee3157258038ae" translate="yes" xml:space="preserve">
          <source>Array to be shuffled.</source>
          <target state="translated">要洗牌的阵列。</target>
        </trans-unit>
        <trans-unit id="b52f152b24d91c43ef9fb5209bce09865fb8369b" translate="yes" xml:space="preserve">
          <source>Array to be sorted.</source>
          <target state="translated">要排序的阵列。</target>
        </trans-unit>
        <trans-unit id="6b0f55aa6f40b643ba50d2b1a53516ef1346869f" translate="yes" xml:space="preserve">
          <source>Array to check for masked values.</source>
          <target state="translated">用于检查掩码值的阵列。</target>
        </trans-unit>
        <trans-unit id="20f86a6d67f17e927d1d04df5d4b886d82463103" translate="yes" xml:space="preserve">
          <source>Array to create a new.</source>
          <target state="translated">阵列来创建一个新的。</target>
        </trans-unit>
        <trans-unit id="38e408cec29face92846919cb92911927e113755" translate="yes" xml:space="preserve">
          <source>Array to create the sliding window view from.</source>
          <target state="translated">用于创建滑动窗口视图的阵列。</target>
        </trans-unit>
        <trans-unit id="a70bc91712a140c808e5cb79192527e68b6c9390" translate="yes" xml:space="preserve">
          <source>Array to mask</source>
          <target state="translated">屏蔽的阵列</target>
        </trans-unit>
        <trans-unit id="d43e409e24f30f0a6d90180b76c2efb4ab130452" translate="yes" xml:space="preserve">
          <source>Array to mask.</source>
          <target state="translated">要屏蔽的阵列。</target>
        </trans-unit>
        <trans-unit id="83c52b56e1210abcac3501b49e1d67729c904dfd" translate="yes" xml:space="preserve">
          <source>Array to put data into.</source>
          <target state="translated">要把数据放入的数组。</target>
        </trans-unit>
        <trans-unit id="fd5b40620a3c780ffc94d7f339fd1c7607c14c60" translate="yes" xml:space="preserve">
          <source>Array to sort.</source>
          <target state="translated">要排序的阵列。</target>
        </trans-unit>
        <trans-unit id="63fbdd1db19d27a9a5c7eab3d132c8bb3f503729" translate="yes" xml:space="preserve">
          <source>Array to test.</source>
          <target state="translated">要测试的阵列。</target>
        </trans-unit>
        <trans-unit id="55a565dc87ad0f5b9c2ac3f528dacc1158c373a0" translate="yes" xml:space="preserve">
          <source>Array type testing</source>
          <target state="translated">阵列类型测试</target>
        </trans-unit>
        <trans-unit id="585f95a404e839b1977230612e779c3487e0200e" translate="yes" xml:space="preserve">
          <source>Array types and conversions between types</source>
          <target state="translated">阵列类型和类型之间的转换</target>
        </trans-unit>
        <trans-unit id="023792f2b2e17a7b6e86f7c45b577b4c007acb28" translate="yes" xml:space="preserve">
          <source>Array types can also be referred to by character codes, mostly to retain backward compatibility with older packages such as Numeric. Some documentation may still refer to these, for example:</source>
          <target state="translated">阵列类型也可以用字符代码来表示,主要是为了保持与Numeric等旧软件包的向后兼容性。一些文档可能仍然会提及这些类型,例如:</target>
        </trans-unit>
        <trans-unit id="03d6303545819c17e2ef1222e68fb70dc26c55f8" translate="yes" xml:space="preserve">
          <source>Array whose &lt;a href=&quot;#term-dtype&quot;&gt;dtype&lt;/a&gt; is a &lt;a href=&quot;#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#term-dtype&quot;&gt;dtype&lt;/a&gt;为&lt;a href=&quot;#term-structured-data-type&quot;&gt;结构化数据类型的&lt;/a&gt;数组。</target>
        </trans-unit>
        <trans-unit id="e4bb8dd78a4c9a8f67c530c9ad1b7a619c52bea4" translate="yes" xml:space="preserve">
          <source>Array whose diagonal is to be filled, it gets modified in-place.</source>
          <target state="translated">对角线要被填充的数组,会被就地修改。</target>
        </trans-unit>
        <trans-unit id="82c627b6cd9b7d074082f31470ca27bba3557192" translate="yes" xml:space="preserve">
          <source>Array with its lower triangle filled with ones and zero elsewhere; in other words &lt;code&gt;T[i,j] == 1&lt;/code&gt; for &lt;code&gt;i &amp;lt;= j + k&lt;/code&gt;, 0 otherwise.</source>
          <target state="translated">下三角的数组由1填充，在其他地方为0；换句话说 &lt;code&gt;T[i,j] == 1&lt;/code&gt; 对于 &lt;code&gt;i &amp;lt;= j + k&lt;/code&gt; ，T [i，j] == 1，否则为0。</target>
        </trans-unit>
        <trans-unit id="b85c2934c5f2a59bc2e12dac7625860a488c925e" translate="yes" xml:space="preserve">
          <source>Array with its lower triangle filled with ones and zero elsewhere; in other words &lt;code&gt;T[i,j] == 1&lt;/code&gt; for &lt;code&gt;j &amp;lt;= i + k&lt;/code&gt;, 0 otherwise.</source>
          <target state="translated">下三角的数组由1填充，在其他地方为0；换句话说 &lt;code&gt;T[i,j] == 1&lt;/code&gt; 对于 &lt;code&gt;j &amp;lt;= i + k&lt;/code&gt; ，T [i，j] == 1，否则为0。</target>
        </trans-unit>
        <trans-unit id="41b54b4163faf0b1aa96452981f42d33d50824ef" translate="yes" xml:space="preserve">
          <source>Array with moved axes. This array is a view of the input array.</source>
          <target state="translated">带移动轴的数组。这个数组是输入数组的一个视图。</target>
        </trans-unit>
        <trans-unit id="84addce66651c27032bab9126d05042eeca1af0e" translate="yes" xml:space="preserve">
          <source>Array with specified requirements and type if given.</source>
          <target state="translated">如果给定,带有指定要求和类型的阵列。</target>
        </trans-unit>
        <trans-unit id="45f77fd17de7e78ac597a13bf5b178d24ee5d7aa" translate="yes" xml:space="preserve">
          <source>Array-checking restype/argtypes.</source>
          <target state="translated">阵列检查restype/argtypes。</target>
        </trans-unit>
        <trans-unit id="54d7e23aa660ea078adfa79ac4b2e54c5ef44772" translate="yes" xml:space="preserve">
          <source>Array-protocol type strings (see &lt;a href=&quot;arrays.interface#arrays-interface&quot;&gt;The Array Interface&lt;/a&gt;)</source>
          <target state="translated">数组协议类型的字符串（请参见&lt;a href=&quot;arrays.interface#arrays-interface&quot;&gt;Array接口&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="7bf6ce513964e0342411a0531bf1b89c426a52c9" translate="yes" xml:space="preserve">
          <source>Array-scalar types</source>
          <target state="translated">阵列标量类型</target>
        </trans-unit>
        <trans-unit id="8160528d25c4bf32940e604af5858cd6853079e6" translate="yes" xml:space="preserve">
          <source>ArrayLike</source>
          <target state="translated">ArrayLike</target>
        </trans-unit>
        <trans-unit id="91f0d52225d31ae76fcb11c767a8c5c08a4c298a" translate="yes" xml:space="preserve">
          <source>ArrayLike objects which do not define &lt;code&gt;__len__&lt;/code&gt; and &lt;code&gt;__getitem__&lt;/code&gt;</source>
          <target state="translated">未定义 &lt;code&gt;__len__&lt;/code&gt; 和 &lt;code&gt;__getitem__&lt;/code&gt; 的ArrayLike对象</target>
        </trans-unit>
        <trans-unit id="a50913b40e0e8d9dc26876d10bb49f2fa38c66fb" translate="yes" xml:space="preserve">
          <source>Array_like means all those objects &amp;ndash; lists, nested lists, etc. &amp;ndash; that can be converted to an array. We can also refer to variables like &lt;code&gt;var1&lt;/code&gt;.</source>
          <target state="translated">Array_like表示所有可以转换为数组的对象（列表，嵌套列表等）。我们还可以引用类似 &lt;code&gt;var1&lt;/code&gt; 的变量。</target>
        </trans-unit>
        <trans-unit id="31b1e39950526e77b6041b42fc1b62056a817d46" translate="yes" xml:space="preserve">
          <source>Arrays &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; must have the same shape.</source>
          <target state="translated">数组 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 必须具有相同的形状。</target>
        </trans-unit>
        <trans-unit id="f2499f813f17514e2097a1073a6cd307b768602d" translate="yes" xml:space="preserve">
          <source>Arrays based off readonly buffers cannot be set &lt;code&gt;writeable&lt;/code&gt;</source>
          <target state="translated">基于只读缓冲区的数组无法设置为 &lt;code&gt;writeable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1c67ac3218c1c87b31cea1d27a13f34756f157a" translate="yes" xml:space="preserve">
          <source>Arrays can be both C-style and Fortran-style contiguous simultaneously. This is clear for 1-dimensional arrays, but can also be true for higher dimensional arrays.</source>
          <target state="translated">数组既可以是C式的,也可以同时是Fortran式的连续数组。这一点对于一维数组来说是很清楚的,但对于高维数组来说也是如此。</target>
        </trans-unit>
        <trans-unit id="9cba266ac8d90f704b5607af4e06eea419c285f7" translate="yes" xml:space="preserve">
          <source>Arrays can be indexed using an extended Python slicing syntax, &lt;code&gt;array[selection]&lt;/code&gt;. Similar syntax is also used for accessing fields in a &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;.</source>
          <target state="translated">可以使用扩展的Python切片语法 &lt;code&gt;array[selection]&lt;/code&gt; 索引。类似的语法也用于访问&lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;结构化数据类型的&lt;/a&gt;字段。</target>
        </trans-unit>
        <trans-unit id="aac913dee168d782f611f9dc70790bf862c5b21d" translate="yes" xml:space="preserve">
          <source>Arrays can be indexed using an extended Python slicing syntax, &lt;code&gt;array[selection]&lt;/code&gt;. Similar syntax is also used for accessing fields in a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;.</source>
          <target state="translated">可以使用扩展的Python切片语法 &lt;code&gt;array[selection]&lt;/code&gt; 索引。类似的语法也用于访问&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;结构化数据类型的&lt;/a&gt;字段。</target>
        </trans-unit>
        <trans-unit id="7125fa97866bba33cfadfef25acde94b75f55b74" translate="yes" xml:space="preserve">
          <source>Arrays cannot be using subarray dtypes</source>
          <target state="translated">数组不能使用子数组dtypes。</target>
        </trans-unit>
        <trans-unit id="d674e5d59a78e41b46aaf270748b55f0fb8f59d0" translate="yes" xml:space="preserve">
          <source>Arrays do not need to have the same &lt;em&gt;number&lt;/em&gt; of dimensions. For example, if you have a &lt;code&gt;256x256x3&lt;/code&gt; array of RGB values, and you want to scale each color in the image by a different value, you can multiply the image by a one-dimensional array with 3 values. Lining up the sizes of the trailing axes of these arrays according to the broadcast rules, shows that they are compatible:</source>
          <target state="translated">阵列不需要有相同&lt;em&gt;数量的&lt;/em&gt;尺寸。例如，如果您具有 &lt;code&gt;256x256x3&lt;/code&gt; 的RGB值数组，并且想要按不同的值缩放图像中的每种颜色，则可以将图像乘以具有3个值的一维数组。根据广播规则来排列这些数组的尾轴的大小，表明它们是兼容的：</target>
        </trans-unit>
        <trans-unit id="5cf5c66690e5daa90427ed3c7163aa6397d5aeea" translate="yes" xml:space="preserve">
          <source>Arrays may be repeated along dimensions of length 1.</source>
          <target state="translated">数组可以沿长度为1的尺寸重复。</target>
        </trans-unit>
        <trans-unit id="00ec5e3a73cb29954290e60a6bc0ab13e3437ef3" translate="yes" xml:space="preserve">
          <source>Arrays may have a data-types containing fields, analogous to columns in a spread sheet. An example is &lt;code&gt;[(x, int), (y, float)]&lt;/code&gt;, where each entry in the array is a pair of &lt;code&gt;(int, float)&lt;/code&gt;. Normally, these attributes are accessed using dictionary lookups such as &lt;code&gt;arr['x']&lt;/code&gt; and &lt;code&gt;arr['y']&lt;/code&gt;. Record arrays allow the fields to be accessed as members of the array, using &lt;code&gt;arr.x&lt;/code&gt; and &lt;code&gt;arr.y&lt;/code&gt;.</source>
          <target state="translated">数组可能具有包含字段的数据类型，类似于电子表格中的列。一个示例是 &lt;code&gt;[(x, int), (y, float)]&lt;/code&gt; ，其中数组中的每个条目都是一对 &lt;code&gt;(int, float)&lt;/code&gt; 。通常，使用字典查找（例如 &lt;code&gt;arr['x']&lt;/code&gt; 和 &lt;code&gt;arr['y']&lt;/code&gt; 访问这些属性。记录数组允许使用 &lt;code&gt;arr.x&lt;/code&gt; 和 &lt;code&gt;arr.y&lt;/code&gt; 将字段作为数组的成员进行访问。</target>
        </trans-unit>
        <trans-unit id="b36ecf0a7f7bd039ed5c1c0704a51fefda73d80e" translate="yes" xml:space="preserve">
          <source>Arrays may have more than one dimension, each which can be sliced individually:</source>
          <target state="translated">数组可以有多个维度,每个维度都可以单独切片。</target>
        </trans-unit>
        <trans-unit id="ef7c0cea98d6d20ecb3d174c3213bef74e8bc018" translate="yes" xml:space="preserve">
          <source>Arrays of byte-strings are not swapped</source>
          <target state="translated">字节串的数组不能交换。</target>
        </trans-unit>
        <trans-unit id="d404bf1fb512f78d1d6fefbd98ddbbf1ae665dd2" translate="yes" xml:space="preserve">
          <source>Arrays of evenly spaced numbers in N-dimensions.</source>
          <target state="translated">在N维中均匀排列的数组。</target>
        </trans-unit>
        <trans-unit id="b8de1bbbfd3c637354288fac451e8a7c60ba28fc" translate="yes" xml:space="preserve">
          <source>Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays.</source>
          <target state="translated">形状相同的点坐标数组。dtypes将被转换为float64或complex128,取决于是否有任何元素是复杂的。标量会被转换为一维数组。</target>
        </trans-unit>
        <trans-unit id="52434d147f7a6b19ab25a12561971251796b7c3c" translate="yes" xml:space="preserve">
          <source>Arrays of strings are not swapped</source>
          <target state="translated">字符串数组不能交换。</target>
        </trans-unit>
        <trans-unit id="fc13f22057f28c646ca1b198ca565af87af49f1b" translate="yes" xml:space="preserve">
          <source>Arrays of values. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">值数组。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="e6f0032138e45d68f74e2c44f2f735c8b5313272" translate="yes" xml:space="preserve">
          <source>Arrays should be constructed using &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;zeros&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.empty#numpy.empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt; (refer to the See Also section below). The parameters given here refer to a low-level method (&lt;code&gt;ndarray(&amp;hellip;)&lt;/code&gt;) for instantiating an array.</source>
          <target state="translated">数组应使用&lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;zeros&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;numpy.empty#numpy.empty&quot;&gt; &lt;code&gt;empty&lt;/code&gt; &lt;/a&gt;构造（请参阅下面的另请参见部分）。此处给出的参数指的是用于实例化数组的低级方法（ &lt;code&gt;ndarray(&amp;hellip;)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="28d3efbe465ae0abcb5a0dfba10ae7944a7f48a2" translate="yes" xml:space="preserve">
          <source>Arrays support the iterator protocol and can be iterated over like Python lists. See the &lt;a href=&quot;../user/quickstart#quickstart-indexing-slicing-and-iterating&quot;&gt;Indexing, Slicing and Iterating&lt;/a&gt; section in the Quickstart guide for basic usage and examples. The remainder of this document presents the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object and covers more advanced usage.</source>
          <target state="translated">数组支持迭代器协议，并且可以像Python列表一样进行迭代。有关基本用法和示例&lt;a href=&quot;../user/quickstart#quickstart-indexing-slicing-and-iterating&quot;&gt;，&lt;/a&gt;请参见《快速入门》指南中的&amp;ldquo;索引，切片和迭代&amp;rdquo;部分。本文档的其余部分介绍了&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;对象，并介绍了更高级的用法。</target>
        </trans-unit>
        <trans-unit id="bcfb0f71df3562232665c06d9cf63f39acceecc4" translate="yes" xml:space="preserve">
          <source>Arrays to be compared.</source>
          <target state="translated">要比较的数组。</target>
        </trans-unit>
        <trans-unit id="c2fde1777833050ff202f7b922dc5d2847610f32" translate="yes" xml:space="preserve">
          <source>Arrays to save to the file. Arrays will be saved in the file with the keyword names.</source>
          <target state="translated">要保存到文件中的数组。数组将以关键字名称保存在文件中。</target>
        </trans-unit>
        <trans-unit id="4ba46cb118e6a4c1684691ff4c3a66ca5c9411f7" translate="yes" xml:space="preserve">
          <source>Arrays to save to the file. Since it is not possible for Python to know the names of the arrays outside &lt;a href=&quot;#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt;, the arrays will be saved with names &amp;ldquo;arr_0&amp;rdquo;, &amp;ldquo;arr_1&amp;rdquo;, and so on. These arguments can be any expression.</source>
          <target state="translated">保存到文件的数组。由于Python不可能知道&lt;a href=&quot;#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; &lt;/a&gt;之外的数组的名称，因此将使用名称&amp;ldquo; arr_0&amp;rdquo;，&amp;ldquo; arr_1&amp;rdquo;等来保存数组。这些参数可以是任何表达式。</target>
        </trans-unit>
        <trans-unit id="f51d18ef0f932163df8ae83aea003301ffa197e5" translate="yes" xml:space="preserve">
          <source>Arrays to save to the file. Since it is not possible for Python to know the names of the arrays outside &lt;a href=&quot;numpy.savez#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt;, the arrays will be saved with names &amp;ldquo;arr_0&amp;rdquo;, &amp;ldquo;arr_1&amp;rdquo;, and so on. These arguments can be any expression.</source>
          <target state="translated">保存到文件的数组。由于Python不可能知道&lt;a href=&quot;numpy.savez#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; &lt;/a&gt;之外的数组的名称，因此将使用名称&amp;ldquo; arr_0&amp;rdquo;，&amp;ldquo; arr_1&amp;rdquo;等来保存数组。这些参数可以是任何表达式。</target>
        </trans-unit>
        <trans-unit id="44d87a6dc57d91b7292b09dc95f59e76af66bd2d" translate="yes" xml:space="preserve">
          <source>Arrays to stack. All of them must have the same first dimension.</source>
          <target state="translated">要堆栈的数组。所有的数组必须有相同的第一维。</target>
        </trans-unit>
        <trans-unit id="b99248188fbd19d8c22a40832b75d837dc4de460" translate="yes" xml:space="preserve">
          <source>Arrays with complex dtypes don&amp;rsquo;t return True.</source>
          <target state="translated">具有复杂dtypes的数组不会返回True。</target>
        </trans-unit>
        <trans-unit id="a2bd40fc5b54aa90919de15beac751e23ad15489" translate="yes" xml:space="preserve">
          <source>Arrayterator (class in numpy.lib)</source>
          <target state="translated">迭代器(numpy.lib中的类)</target>
        </trans-unit>
        <trans-unit id="816e3f055425505d10d82fdb50f19dc782762aaa" translate="yes" xml:space="preserve">
          <source>Arrayterator.flat</source>
          <target state="translated">Arrayterator.flat</target>
        </trans-unit>
        <trans-unit id="e63ac43cdcb5a4238c7b9262748f81e7cf3457ea" translate="yes" xml:space="preserve">
          <source>Arrayterator.shape</source>
          <target state="translated">Arrayterator.shape</target>
        </trans-unit>
        <trans-unit id="62735fb443777d7de2d1c29ccbb762ccfb2be570" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, a masked array also inherits all the attributes and properties of a &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">由于&lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;是ndarray的子类，&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; masked数组也继承了&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;实例的所有属性和属性。</target>
        </trans-unit>
        <trans-unit id="bdc5d12d9a06d1a300c059aee30b6e3298b8cd56" translate="yes" xml:space="preserve">
          <source>As Numeric has matured and developed into NumPy, people have been able to write more code directly in NumPy. Often this code is fast-enough for production use, but there are still times that there is a need to access compiled code. Either to get that last bit of efficiency out of the algorithm or to make it easier to access widely-available codes written in C/C++ or Fortran.</source>
          <target state="translated">随着Numeric的成熟和NumPy的发展,人们已经可以直接在NumPy中编写更多的代码。通常这些代码的速度已经快到可以满足生产使用的程度,但有些时候还是需要访问编译后的代码。要么是为了从算法中获得最后一点效率,要么是为了更方便地访问用C/C++或Fortran编写的广泛可用的代码。</target>
        </trans-unit>
        <trans-unit id="266410aaeb848f2f7510db1bcf8e20c2778f75df" translate="yes" xml:space="preserve">
          <source>As a &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it inherits its mechanisms for indexing and slicing.</source>
          <target state="translated">作为&lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;是的子类&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt;，它继承其索引和切片机制。</target>
        </trans-unit>
        <trans-unit id="572a6b072b5d5bfb6b919bf3e8415158c50e5fd9" translate="yes" xml:space="preserve">
          <source>As a convenience for &lt;code&gt;__array_function__&lt;/code&gt; implementors, &lt;code&gt;types&lt;/code&gt; provides all argument types with an &lt;code&gt;'__array_function__'&lt;/code&gt; attribute. This allows implementors to quickly identify cases where they should defer to &lt;code&gt;__array_function__&lt;/code&gt; implementations on other arguments. Implementations should not rely on the iteration order of &lt;code&gt;types&lt;/code&gt;.</source>
          <target state="translated">为了方便 &lt;code&gt;__array_function__&lt;/code&gt; 实现者， &lt;code&gt;types&lt;/code&gt; 为所有参数类型提供了 &lt;code&gt;'__array_function__'&lt;/code&gt; 属性。这使实现者可以快速确定应 &lt;code&gt;__array_function__&lt;/code&gt; 其他参数的__array_function__实现的情况。实现不应依赖于 &lt;code&gt;types&lt;/code&gt; 的迭代顺序。</target>
        </trans-unit>
        <trans-unit id="943758d1e20ad4276263519968fa94f16b718bb2" translate="yes" xml:space="preserve">
          <source>As a corollary to this change, we no longer prohibit casting between datetimes with date units and datetimes with timeunits. With timezone naive datetimes, the rule for casting from dates to times is no longer ambiguous.</source>
          <target state="translated">作为这一变化的必然结果,我们不再禁止在带日期单位的日期时间和带时间单位的日期时间之间进行转换。对于时区天真的日期时间,从日期到时间的转换规则不再含糊不清。</target>
        </trans-unit>
        <trans-unit id="013d98a5ec5b7f58afd0279b5cb85ae341df8643" translate="yes" xml:space="preserve">
          <source>As a final note: if the &lt;code&gt;super&lt;/code&gt; route is suited to a given class, an advantage of using it is that it helps in constructing class hierarchies. E.g., suppose that our other class &lt;code&gt;B&lt;/code&gt; also used the &lt;code&gt;super&lt;/code&gt; in its &lt;code&gt;__array_ufunc__&lt;/code&gt; implementation, and we created a class &lt;code&gt;C&lt;/code&gt; that depended on both, i.e., &lt;code&gt;class C(A, B)&lt;/code&gt; (with, for simplicity, not another &lt;code&gt;__array_ufunc__&lt;/code&gt; override). Then any ufunc on an instance of &lt;code&gt;C&lt;/code&gt; would pass on to &lt;code&gt;A.__array_ufunc__&lt;/code&gt;, the &lt;code&gt;super&lt;/code&gt; call in &lt;code&gt;A&lt;/code&gt; would go to &lt;code&gt;B.__array_ufunc__&lt;/code&gt;, and the &lt;code&gt;super&lt;/code&gt; call in &lt;code&gt;B&lt;/code&gt; would go to &lt;code&gt;ndarray.__array_ufunc__&lt;/code&gt;, thus allowing &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; to collaborate.</source>
          <target state="translated">最后一点：如果 &lt;code&gt;super&lt;/code&gt; 路由适合于给定的类，则使用它的好处是它有助于构造类层次结构。例如，假设我们的其他类 &lt;code&gt;B&lt;/code&gt; 也采用了 &lt;code&gt;super&lt;/code&gt; 在其 &lt;code&gt;__array_ufunc__&lt;/code&gt; 落实，我们创建了一个类 &lt;code&gt;C&lt;/code&gt; 是依赖于两个，即 &lt;code&gt;class C(A, B)&lt;/code&gt; （用，为简便起见，不另 &lt;code&gt;__array_ufunc__&lt;/code&gt; 覆盖）。然后在实例任何ufunc &lt;code&gt;C&lt;/code&gt; 将传递给 &lt;code&gt;A.__array_ufunc__&lt;/code&gt; 的 &lt;code&gt;super&lt;/code&gt; 呼叫 &lt;code&gt;A&lt;/code&gt; 会去 &lt;code&gt;B.__array_ufunc__&lt;/code&gt; ，以及 &lt;code&gt;super&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; 中的调用将转到 &lt;code&gt;ndarray.__array_ufunc__&lt;/code&gt; ，从而允许 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 进行协作。</target>
        </trans-unit>
        <trans-unit id="839c21dc6f9c35797b35f17417f1d765334d2a61" translate="yes" xml:space="preserve">
          <source>As a rough estimate, a sliding window approach with an input size of &lt;code&gt;N&lt;/code&gt; and a window size of &lt;code&gt;W&lt;/code&gt; will scale as &lt;code&gt;O(N*W)&lt;/code&gt; where frequently a special algorithm can achieve &lt;code&gt;O(N)&lt;/code&gt;. That means that the sliding window variant for a window size of 100 can be a 100 times slower than a more specialized version.</source>
          <target state="translated">粗略估计，输入大小为 &lt;code&gt;N&lt;/code&gt; 且窗口大小为 &lt;code&gt;W&lt;/code&gt; 的滑动窗口方法将按 &lt;code&gt;O(N*W)&lt;/code&gt; 缩放，在这种情况下，通常有一种特殊算法可以实现 &lt;code&gt;O(N)&lt;/code&gt; 。这意味着，对于尺寸为100的窗口，滑动窗口的变体可能比更专业的版本慢100倍。</target>
        </trans-unit>
        <trans-unit id="20a42179492180fa8aaa4dc644b08e20ca1aef18" translate="yes" xml:space="preserve">
          <source>As an alternative to &lt;code&gt;pytest.mark.&amp;lt;label&amp;gt;&lt;/code&gt;, there are a number of labels you can use.</source>
          <target state="translated">作为 &lt;code&gt;pytest.mark.&amp;lt;label&amp;gt;&lt;/code&gt; 的替代方法，可以使用许多标签。</target>
        </trans-unit>
        <trans-unit id="3dab1c17c36782c312875481e08692d9b809435e" translate="yes" xml:space="preserve">
          <source>As an example, for &lt;code&gt;numpy.mean&lt;/code&gt; we would have:</source>
          <target state="translated">例如，对于 &lt;code&gt;numpy.mean&lt;/code&gt; ,我们将有：</target>
        </trans-unit>
        <trans-unit id="fecff8f943e371686abc1110d1711ebbbb86c5fa" translate="yes" xml:space="preserve">
          <source>As an example, see the 1.14.3 REL commit: &lt;a href=&quot;https://github.com/numpy/numpy/commit/73299826729be58cec179b52c656adfcaefada93&quot;&gt;https://github.com/numpy/numpy/commit/73299826729be58cec179b52c656adfcaefada93&lt;/a&gt;.</source>
          <target state="translated">例如，请参见1.14.3 REL提交：&lt;a href=&quot;https://github.com/numpy/numpy/commit/73299826729be58cec179b52c656adfcaefada93&quot;&gt;https&lt;/a&gt; : //github.com/numpy/numpy/commit/73299826729be58cec179b52c656adfcaefada93。</target>
        </trans-unit>
        <trans-unit id="f7ec8e32822a5e0a0d90b5363a2541452778cbc3" translate="yes" xml:space="preserve">
          <source>As an example, we print out the result of broadcasting a one and a two dimensional array together.</source>
          <target state="translated">举个例子,我们把一维和二维数组的广播结果一起打印出来。</target>
        </trans-unit>
        <trans-unit id="8f262d8c602a1c1784a0611d8d573ccc9d004b7a" translate="yes" xml:space="preserve">
          <source>As an illustration, let&amp;rsquo;s consider the following dataset:</source>
          <target state="translated">作为说明，让我们考虑以下数据集：</target>
        </trans-unit>
        <trans-unit id="3c1410845edf2c868fb5a0fe8e6419a05b6e17f2" translate="yes" xml:space="preserve">
          <source>As an optional convenience numpy provides an ndarray subclass, &lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;numpy.recarray&lt;/code&gt;&lt;/a&gt; that allows access to fields of structured arrays by attribute instead of only by index. Record arrays use a special datatype, &lt;a href=&quot;../reference/generated/numpy.record#numpy.record&quot;&gt;&lt;code&gt;numpy.record&lt;/code&gt;&lt;/a&gt;, that allows field access by attribute on the structured scalars obtained from the array. The &lt;code&gt;numpy.rec&lt;/code&gt; module provides functions for creating recarrays from various objects. Additional helper functions for creating and manipulating structured arrays can be found in &lt;a href=&quot;#module-numpy.lib.recfunctions&quot;&gt;&lt;code&gt;numpy.lib.recfunctions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">作为可选的便利，numpy提供了ndarray子类&lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt; &lt;code&gt;numpy.recarray&lt;/code&gt; &lt;/a&gt;，该子类允许按属性（而不是仅按索引）访问结构化数组的字段。记录数组使用特殊的数据类型&lt;a href=&quot;../reference/generated/numpy.record#numpy.record&quot;&gt; &lt;code&gt;numpy.record&lt;/code&gt; &lt;/a&gt;，该数据类型允许按属性访问从数组获得的结构化标量上的字段。所述 &lt;code&gt;numpy.rec&lt;/code&gt; 模块提供用于创建从各种对象recarrays。可以在&lt;a href=&quot;#module-numpy.lib.recfunctions&quot;&gt; &lt;code&gt;numpy.lib.recfunctions&lt;/code&gt; 中&lt;/a&gt;找到用于创建和操作结构化数组的其他辅助函数。</target>
        </trans-unit>
        <trans-unit id="06bd4fa6779fdd07b3d52175c70a52bf6deacdac" translate="yes" xml:space="preserve">
          <source>As an optional convenience numpy provides an ndarray subclass, &lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;numpy.recarray&lt;/code&gt;&lt;/a&gt;, and associated helper functions in the &lt;code&gt;numpy.rec&lt;/code&gt; submodule, that allows access to fields of structured arrays by attribute instead of only by index. Record arrays also use a special datatype, &lt;a href=&quot;../reference/generated/numpy.record#numpy.record&quot;&gt;&lt;code&gt;numpy.record&lt;/code&gt;&lt;/a&gt;, that allows field access by attribute on the structured scalars obtained from the array.</source>
          <target state="translated">作为可选的便利，numpy在 &lt;code&gt;numpy.rec&lt;/code&gt; 子模块中提供了ndarray子类&lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt; &lt;code&gt;numpy.recarray&lt;/code&gt; &lt;/a&gt;和关联的辅助函数，该子模块允许按属性而不是仅按索引访问结构化数组的字段。记录数组还使用特殊的数据类型&lt;a href=&quot;../reference/generated/numpy.record#numpy.record&quot;&gt; &lt;code&gt;numpy.record&lt;/code&gt; &lt;/a&gt;，该数据类型允许按属性访问从数组获得的结构化标量上的字段。</target>
        </trans-unit>
        <trans-unit id="ff6fd804dd39db5798ff08b4b25e0937a2c068e3" translate="yes" xml:space="preserve">
          <source>As an trivial example, consider this implementation of an &lt;code&gt;ArrayLike&lt;/code&gt; class that simply wraps a NumPy array and ensures that the result of any arithmetic operation is also an &lt;code&gt;ArrayLike&lt;/code&gt; object:</source>
          <target state="translated">作为一个简单的示例，请考虑 &lt;code&gt;ArrayLike&lt;/code&gt; 类的此实现，该实现仅包装NumPy数组并确保任何算术运算的结果也是 &lt;code&gt;ArrayLike&lt;/code&gt; 对象：</target>
        </trans-unit>
        <trans-unit id="cede8d515f0ee49ac10c9ddedbb9f437527bae9a" translate="yes" xml:space="preserve">
          <source>As can be seen, the &amp;ldquo;good&amp;rdquo; parts have shrunk to insignificance. In using Chebyshev polynomials for fitting we want to use the region where &lt;code&gt;x&lt;/code&gt; is between -1 and 1 and that is what the &lt;code&gt;window&lt;/code&gt; specifies. However, it is unlikely that the data to be fit has all its data points in that interval, so we use &lt;code&gt;domain&lt;/code&gt; to specify the interval where the data points lie. When the fit is done, the domain is first mapped to the window by a linear transformation and the usual least squares fit is done using the mapped data points. The window and domain of the fit are part of the returned series and are automatically used when computing values, derivatives, and such. If they aren&amp;rsquo;t specified in the call the fitting routine will use the default window and the smallest domain that holds all the data points. This is illustrated below for a fit to a noisy sine curve.</source>
          <target state="translated">可以看出，&amp;ldquo;好&amp;rdquo;部分已经缩小到无关紧要的程度。在使用Chebyshev多项式进行拟合时，我们要使用 &lt;code&gt;x&lt;/code&gt; 在-1和1之间的区域，这就是 &lt;code&gt;window&lt;/code&gt; 指定的区域。但是，要拟合的数据不可能在该时间间隔内拥有所有数据点，因此我们使用 &lt;code&gt;domain&lt;/code&gt; 指定数据点所在的间隔。拟合完成后，首先通过线性变换将域映射到窗口，然后使用映射的数据点完成通常的最小二乘拟合。拟合的窗口和范围是返回系列的一部分，在计算值，导数等时会自动使用。如果未在调用中指定它们，则拟合例程将使用默认窗口和包含所有数据点的最小域。如下所示，以拟合噪声正弦曲线。</target>
        </trans-unit>
        <trans-unit id="e0bc58a150fd519b1ef1b28d23e1c4528291bcac" translate="yes" xml:space="preserve">
          <source>As expected, this is a 768x1024 matrix:</source>
          <target state="translated">正如所料,这是一个768x1024的矩阵。</target>
        </trans-unit>
        <trans-unit id="c53fc1e45dbe406be17b6e30a5cfb9d43c0f2859" translate="yes" xml:space="preserve">
          <source>As explained previously, C-style contiguous arrays and Fortran-style contiguous arrays have particular striding patterns. Two array flags (&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;) indicate whether or not the striding pattern of a particular array matches the C-style contiguous or Fortran-style contiguous or neither. Whether or not the striding pattern matches a standard C or Fortran one can be tested Using &lt;a href=&quot;../reference/c-api/array#c.PyArray_IS_C_CONTIGUOUS&quot;&gt;&lt;code&gt;PyArray_IS_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (obj) and &lt;a href=&quot;../reference/c-api/array#c.PyArray_ISFORTRAN&quot;&gt;&lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt;&lt;/a&gt; (obj) respectively. Most third-party libraries expect contiguous arrays. But, often it is not difficult to support general-purpose striding. I encourage you to use the striding information in your own code whenever possible, and reserve single-segment requirements for wrapping third-party code. Using the striding information provided with the ndarray rather than requiring a contiguous striding reduces copying that otherwise must be made.</source>
          <target state="translated">如前所述，C风格的连续数组和Fortran风格的连续数组具有特定的跨步模式。两个数组标志（&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;）指示特定数组的跨步模式是否与C样式的连续样式或Fortran样式的连续样式匹配或两者都不匹配。可以使用&lt;a href=&quot;../reference/c-api/array#c.PyArray_IS_C_CONTIGUOUS&quot;&gt; &lt;code&gt;PyArray_IS_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;（obj）和&lt;a href=&quot;../reference/c-api/array#c.PyArray_ISFORTRAN&quot;&gt; &lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt; &lt;/a&gt;测试跨步模式是否与标准C或Fortran匹配。（obj）。大多数第三方库都希望使用连续数组。但是，通常不难支持通用跨步。我鼓励您在可能的情况下在自己的代码中使用跨步信息，并保留用于包装第三方代码的单段需求。使用与ndarray一起提供的跨步信息，而不是要求连续跨步，可以减少原本必须进行的复制。</target>
        </trans-unit>
        <trans-unit id="fdede3e80508e2816102dcd54a9d5c797c31ec48" translate="yes" xml:space="preserve">
          <source>As for &lt;a href=&quot;numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt;&lt;code&gt;ndarray.tobytes&lt;/code&gt;&lt;/a&gt;, information about the shape, dtype, etc., but also about &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;, will be lost.</source>
          <target state="translated">至于&lt;a href=&quot;numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt; &lt;code&gt;ndarray.tobytes&lt;/code&gt; &lt;/a&gt;，关于形状，D型等信息，而且关于&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;，将会丢失。</target>
        </trans-unit>
        <trans-unit id="6eb7f695a43a210c4ab19e5bc957617a28b1a107" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;ndarray.tobytes&lt;/code&gt;, information about the shape, dtype, etc., but also about &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;, will be lost.</source>
          <target state="translated">至于 &lt;code&gt;ndarray.tobytes&lt;/code&gt; ，关于形状，D型等信息，而且关于&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;，将会丢失。</target>
        </trans-unit>
        <trans-unit id="442dd71dc758bc00985af7b82e3b46e788353af0" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;ndarray.tobytes&lt;/code&gt;, information about the shape, dtype, etc., but also about &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;, will be lost.</source>
          <target state="translated">至于 &lt;code&gt;ndarray.tobytes&lt;/code&gt; ，关于形状，D型等信息，而且关于&lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;，将会丢失。</target>
        </trans-unit>
        <trans-unit id="b59d207ef2133a3867224936518ca5838dca25c9" translate="yes" xml:space="preserve">
          <source>As it turns out, numpy is smart enough when dealing with ufuncs to determine which index is the most rapidly varying one in memory and uses that for the innermost loop. Thus for ufuncs there is no large intrinsic advantage to either approach in most cases. On the other hand, use of .flat with an FORTRAN ordered array will lead to non-optimal memory access as adjacent elements in the flattened array (iterator, actually) are not contiguous in memory.</source>
          <target state="translated">事实证明,numpy在处理ufuncs的时候很聪明,可以判断出哪个索引是内存中变化最快的索引,并将其用于最里面的循环。因此对于ufuncs来说,在大多数情况下,这两种方法都没有太大的本质优势。另一方面,对FORTRAN有序数组使用.flat会导致非最佳的内存访问,因为扁平化数组(实际上是迭代器)中相邻的元素在内存中并不连续。</target>
        </trans-unit>
        <trans-unit id="bae171d630e66c8dccf252742ea919c5676002d9" translate="yes" xml:space="preserve">
          <source>As mentioned in the Notes section, &lt;a href=&quot;#numpy.testing.assert_array_equal&quot;&gt;&lt;code&gt;assert_array_equal&lt;/code&gt;&lt;/a&gt; has special handling for scalars. Here the test checks that each value in &lt;code&gt;x&lt;/code&gt; is 3:</source>
          <target state="translated">如注释部分所述，&lt;a href=&quot;#numpy.testing.assert_array_equal&quot;&gt; &lt;code&gt;assert_array_equal&lt;/code&gt; &lt;/a&gt;对标量具有特殊处理。在这里，测试检查 &lt;code&gt;x&lt;/code&gt; 中的每个值是否为3：</target>
        </trans-unit>
        <trans-unit id="13dc2b7c8c10ac2fc73aefee2fde7f627c9b6aa2" translate="yes" xml:space="preserve">
          <source>As mentioned previously, the flat attribute of ndarray objects returns an iterator that will cycle over the entire array in C-style contiguous order.</source>
          <target state="translated">如前所述,ndarray对象的flat属性会返回一个迭代器,这个迭代器会以C-style的连续顺序在整个数组上循环。</target>
        </trans-unit>
        <trans-unit id="1eeb436878ddf7f47ab4d8c1fb337ec14f285994" translate="yes" xml:space="preserve">
          <source>As mentioned, one can select a subset of an array to assign to using a single index, slices, and index and mask arrays. The value being assigned to the indexed array must be shape consistent (the same shape or broadcastable to the shape the index produces). For example, it is permitted to assign a constant to a slice:</source>
          <target state="translated">如前所述,人们可以选择一个数组的子集,使用单个索引、切片、索引和掩码数组来分配。被分配给索引数组的值必须是形状一致的(与索引产生的形状相同或可广播的形状)。例如,允许将一个常量赋给一个切片。</target>
        </trans-unit>
        <trans-unit id="6bb256df55b0c84359db8c790668112e195bd64a" translate="yes" xml:space="preserve">
          <source>As noted above the inverse Gaussian distribution first arise from attempts to model Brownian motion. It is also a competitor to the Weibull for use in reliability modeling and modeling stock returns and interest rate processes.</source>
          <target state="translated">如上所述,逆高斯分布最早产生于对布朗运动建模的尝试。它也是Weibull的竞争者,用于可靠性建模和股票回报和利率过程建模。</target>
        </trans-unit>
        <trans-unit id="ec730138fa95973e97f6613bc68aa1a1f0c5aafb" translate="yes" xml:space="preserve">
          <source>As of 1.6, this function simply calls &lt;a href=&quot;#c.PyArray_CopyInto&quot;&gt;&lt;code&gt;PyArray_CopyInto&lt;/code&gt;&lt;/a&gt;, which handles the casting.</source>
          <target state="translated">从1.6开始，此函数仅调用&lt;a href=&quot;#c.PyArray_CopyInto&quot;&gt; &lt;code&gt;PyArray_CopyInto&lt;/code&gt; &lt;/a&gt;，它处理转换。</target>
        </trans-unit>
        <trans-unit id="3f3530b3b21291b3dd3b74336008cc7a706ed945" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.10, the returned array will have the same type as the input array. (for example, a masked array will be returned for a masked array input)</source>
          <target state="translated">从NumPy 1.10开始,返回的数组将具有与输入数组相同的类型。(例如,一个掩码数组的输入将返回一个掩码数组)</target>
        </trans-unit>
        <trans-unit id="12042a22f9b6865da757e69e8d2ce21273a85e0c" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.4.0 &lt;a href=&quot;#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt; works with real/complex arrays containing nan values. The enhanced sort order is documented in &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从NumPy 1.4.0开始，&lt;a href=&quot;#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt;可以处理包含nan值的实数/复杂数组。增强的排序顺序在&lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; 中记录&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bba53cf9adf4ac58af71ddd4d6acfa9ee160b6ec" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.4.0 &lt;a href=&quot;#numpy.searchsorted&quot;&gt;&lt;code&gt;searchsorted&lt;/code&gt;&lt;/a&gt; works with real/complex arrays containing &lt;a href=&quot;../constants#numpy.nan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt; values. The enhanced sort order is documented in &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从NumPy 1.4.0开始，&lt;a href=&quot;#numpy.searchsorted&quot;&gt; &lt;code&gt;searchsorted&lt;/code&gt; &lt;/a&gt;可用于包含&lt;a href=&quot;../constants#numpy.nan&quot;&gt; &lt;code&gt;nan&lt;/code&gt; &lt;/a&gt;值的实数/复杂数组。增强的排序顺序在&lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; 中记录&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17597aa038b28f9f5c8df2774b1f9eab6ad3af4c" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.6.0, these array iterators are superceded by the new array iterator, &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从NumPy 1.6.0开始，这些数组迭代器将由新的数组迭代器&lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt; &lt;code&gt;NpyIter&lt;/code&gt; 取代&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8364d1abaebc5d8b1444ea31949f7accfaa13ead" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.6.0, these array iterators are superseded by the new array iterator, &lt;a href=&quot;iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从NumPy 1.6.0开始，这些数组迭代器由新的数组迭代器&lt;a href=&quot;iterator#c.NpyIter&quot;&gt; &lt;code&gt;NpyIter&lt;/code&gt; 取代&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f60464691ec1296f5eb92b23ac7c66b95bdc223" translate="yes" xml:space="preserve">
          <source>As previously discussed, you can also set the argtypes attribute of the function in order to have ctypes check the types of the input arguments when the function is called. Use the &lt;a href=&quot;#ndpointer&quot;&gt;&lt;code&gt;ndpointer&lt;/code&gt;&lt;/a&gt; factory function to generate a ready-made class for data-type, shape, and flags checking on your new function. The &lt;a href=&quot;#ndpointer&quot;&gt;&lt;code&gt;ndpointer&lt;/code&gt;&lt;/a&gt; function has the signature</source>
          <target state="translated">如前所述，您还可以设置函数的argtypes属性，以使ctypes在调用函数时检查输入参数的类型。使用&lt;a href=&quot;#ndpointer&quot;&gt; &lt;code&gt;ndpointer&lt;/code&gt; &lt;/a&gt;工厂函数来生成现成的类，以对新函数的数据类型，形状和标志进行检查。该&lt;a href=&quot;#ndpointer&quot;&gt; &lt;code&gt;ndpointer&lt;/code&gt; &lt;/a&gt;函数签名</target>
        </trans-unit>
        <trans-unit id="7e6c9caa222f474d8200d79ae5b20b408a1c8172" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;#figure-2&quot;&gt;Figure 2&lt;/a&gt;, &lt;code&gt;b&lt;/code&gt; is added to each row of &lt;code&gt;a&lt;/code&gt;. When &lt;code&gt;b&lt;/code&gt; is longer than the rows of &lt;code&gt;a&lt;/code&gt;, as in &lt;a href=&quot;#figure-3&quot;&gt;Figure 3&lt;/a&gt;, an exception is raised because of the incompatible shapes.</source>
          <target state="translated">如在所示&lt;a href=&quot;#figure-2&quot;&gt;图2&lt;/a&gt;， &lt;code&gt;b&lt;/code&gt; 加入到每行 &lt;code&gt;a&lt;/code&gt; 。当 &lt;code&gt;b&lt;/code&gt; 大于行更长的 &lt;code&gt;a&lt;/code&gt; ，如在&lt;a href=&quot;#figure-3&quot;&gt;图3中&lt;/a&gt;，一个异常，因为不相容的形状的凸起。</target>
        </trans-unit>
        <trans-unit id="0eb75b8579bfe992aa268341a4c85c6d503920b9" translate="yes" xml:space="preserve">
          <source>As the scale approaches infinity, the distribution becomes more like a Gaussian. Some references claim that the Wald is an inverse Gaussian with mean equal to 1, but this is by no means universal.</source>
          <target state="translated">当规模接近无穷大时,分布变得更像高斯。一些参考文献称,Wald是一个平均数等于1的逆高斯,但这绝不是普遍现象。</target>
        </trans-unit>
        <trans-unit id="2f0e40b24d4f520710fd1ed228a57a1690ea8227" translate="yes" xml:space="preserve">
          <source>As well as the scalar array special case signaling that an integer array was interpreted as an integer index, which is important because an integer array index forces a copy but is ignored if a scalar is returned (full integer index). The prepared index is guaranteed to be valid with the exception of out of bound values and broadcasting errors for advanced indexing. This includes that an ellipsis is added for incomplete indices for example when a two dimensional array is indexed with a single integer.</source>
          <target state="translated">以及标量数组的特殊情况,标志着一个整数数组被解释为一个整数索引,这很重要,因为整数数组索引会强制复制,但如果返回的是一个标量(全整数索引),则会被忽略。除了出界值和高级索引的广播错误外,准备好的索引保证有效。这包括对于不完整的索引会添加一个省略号,例如当一个二维数组用一个整数索引时。</target>
        </trans-unit>
        <trans-unit id="925814af80369e67056380832c2cbc226e28baa6" translate="yes" xml:space="preserve">
          <source>As with other container objects in Python, the contents of an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; can be accessed and modified by &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;indexing or slicing&lt;/a&gt; the array (using, for example, &lt;em&gt;N&lt;/em&gt; integers), and via the methods and attributes of the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如同在Python其他容器对象中，内容&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;可以访问和修改由&lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;索引或切片&lt;/a&gt;阵列（使用，例如，&lt;em&gt;&amp;Ntilde;&lt;/em&gt;整数），和通过所述方法和所述的属性&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52fd93066bad29b67273e079568eccef85b00fa0" translate="yes" xml:space="preserve">
          <source>As you can imagine from the introduction, there are two ways you can affect the relationship between the byte ordering of the array and the underlying memory it is looking at:</source>
          <target state="translated">从介绍中可以想象到,有两种方法可以影响数组的字节排序和它所看的底层内存之间的关系。</target>
        </trans-unit>
        <trans-unit id="d2891acf8ae5fe1d5007874779732cde26b391a3" translate="yes" xml:space="preserve">
          <source>As you can see, the object can be initialized in the &lt;code&gt;__new__&lt;/code&gt; method or the &lt;code&gt;__init__&lt;/code&gt; method, or both, and in fact ndarray does not have an &lt;code&gt;__init__&lt;/code&gt; method, because all the initialization is done in the &lt;code&gt;__new__&lt;/code&gt; method.</source>
          <target state="translated">如您所见，可以使用 &lt;code&gt;__new__&lt;/code&gt; 方法或 &lt;code&gt;__init__&lt;/code&gt; 方法，或同时使用这两种方法来初始化对象，实际上ndarray没有 &lt;code&gt;__init__&lt;/code&gt; 方法，因为所有初始化都是在 &lt;code&gt;__new__&lt;/code&gt; 方法中完成的。</target>
        </trans-unit>
        <trans-unit id="3b4f7dc7b3c4a70ce9ff533c44a9b7a4a1713152" translate="yes" xml:space="preserve">
          <source>Asking for your changes to be merged with the main repo</source>
          <target state="translated">要求将您的修改与主 repo 合并。</target>
        </trans-unit>
        <trans-unit id="b3cf9d2ab1eb546a2eba1efeb64eb1e97091b955" translate="yes" xml:space="preserve">
          <source>Assemble an nd-array from nested lists of blocks.</source>
          <target state="translated">从嵌套的区块列表中组合一个nd-array。</target>
        </trans-unit>
        <trans-unit id="74cbd6c218f89d00f752e7ba4b2b17d97a1a1ff7" translate="yes" xml:space="preserve">
          <source>Assemble arrays from blocks.</source>
          <target state="translated">从块中组装数组。</target>
        </trans-unit>
        <trans-unit id="de78d0a7b76ee6bba1ecaedfc383918b06ba62a9" translate="yes" xml:space="preserve">
          <source>Assert fails with numerical imprecision with floats:</source>
          <target state="translated">对浮点数的数值不精确时,断言失败。</target>
        </trans-unit>
        <trans-unit id="79536b913447cc8edd9ecd5192bb8530d9a9202a" translate="yes" xml:space="preserve">
          <source>Assert fails with numerical inprecision with floats:</source>
          <target state="translated">对浮点数的数值不精确时,断言失败。</target>
        </trans-unit>
        <trans-unit id="e3292c12a856a02722a46d87471ff4e6faefa104" translate="yes" xml:space="preserve">
          <source>AssertionError</source>
          <target state="translated">AssertionError</target>
        </trans-unit>
        <trans-unit id="561c16749736b8dbda1124817a2b4447de5e4505" translate="yes" xml:space="preserve">
          <source>Asserts</source>
          <target state="translated">Asserts</target>
        </trans-unit>
        <trans-unit id="289e36002d46d5808069779b9fe9f985a8b15407" translate="yes" xml:space="preserve">
          <source>Assigning data to a Structured Array</source>
          <target state="translated">将数据分配给结构化数组</target>
        </trans-unit>
        <trans-unit id="8a799af040a420920800093adb9e84b1752618c3" translate="yes" xml:space="preserve">
          <source>Assigning to slices/views of &lt;code&gt;MaskedArray&lt;/code&gt;</source>
          <target state="translated">分配给 &lt;code&gt;MaskedArray&lt;/code&gt; 的切片/视图</target>
        </trans-unit>
        <trans-unit id="a63aa663ce3fd806853c6e1d56f0f1c1896855bd" translate="yes" xml:space="preserve">
          <source>Assigning values to indexed arrays</source>
          <target state="translated">为索引数组赋值</target>
        </trans-unit>
        <trans-unit id="4d5174a57fec035b53144526667e457e11d00dd3" translate="yes" xml:space="preserve">
          <source>Assignment between two structured arrays occurs as if the source elements had been converted to tuples and then assigned to the destination elements. That is, the first field of the source array is assigned to the first field of the destination array, and the second field likewise, and so on, regardless of field names. Structured arrays with a different number of fields cannot be assigned to each other. Bytes of the destination structure which are not included in any of the fields are unaffected.</source>
          <target state="translated">两个结构化数组之间的赋值就像源元素被转换为元组,然后赋值给目的元素一样。也就是说,源数组的第一个字段被分配给目的数组的第一个字段,第二个字段也是如此,以此类推,而不考虑字段名。具有不同字段数的结构数组不能相互分配。目标结构的字节如果不包含在任何字段中,则不受影响。</target>
        </trans-unit>
        <trans-unit id="acccf5c6ee3457ada97687fe5c7f1318e0893486" translate="yes" xml:space="preserve">
          <source>Assignment from Python Native Types (Tuples)</source>
          <target state="translated">从Python原生类型(Tuples)中进行赋值</target>
        </trans-unit>
        <trans-unit id="9cc21533901f2115eb4a3c32d19650f93349565e" translate="yes" xml:space="preserve">
          <source>Assignment from Scalars</source>
          <target state="translated">来自Scalars的任务</target>
        </trans-unit>
        <trans-unit id="4c57993301d1b6548c0e4939d7c7c8d9a2d56b2c" translate="yes" xml:space="preserve">
          <source>Assignment from other Structured Arrays</source>
          <target state="translated">从其他结构化数组中分配</target>
        </trans-unit>
        <trans-unit id="fc5e2a82565507aaae14030e1c010088c6562688" translate="yes" xml:space="preserve">
          <source>Assignment involving subarrays</source>
          <target state="translated">涉及子阵列的任务</target>
        </trans-unit>
        <trans-unit id="dc3ede0861439daaed8c3de08958646d9211be1a" translate="yes" xml:space="preserve">
          <source>Assignment of ndarray object&amp;rsquo;s &lt;code&gt;data&lt;/code&gt; attribute</source>
          <target state="translated">分配ndarray对象的 &lt;code&gt;data&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="2edeef440cbb6c2ba230df4bbf3e9bef68f36e23" translate="yes" xml:space="preserve">
          <source>Assignment to an array with a multi-field index modifies the original array:</source>
          <target state="translated">对一个多字段索引的数组进行赋值,可以修改原数组。</target>
        </trans-unit>
        <trans-unit id="af53b1c5013c72eb7aa598ce977b69cfb859c315" translate="yes" xml:space="preserve">
          <source>Assignment to the view modifies the original array. The view&amp;rsquo;s fields will be in the order they were indexed. Note that unlike for single-field indexing, the dtype of the view has the same itemsize as the original array, and has fields at the same offsets as in the original array, and unindexed fields are merely missing.</source>
          <target state="translated">分配给视图会修改原始数组。视图的字段将按照它们被索引的顺序。请注意，与单字段索引不同，视图的dtype与原始数组具有相同的项目大小，并且其字段与原始数组具有相同的偏移量，而未索引的字段仅会丢失。</target>
        </trans-unit>
        <trans-unit id="ed91fb02ba267588e9268d85784e62da51f799fd" translate="yes" xml:space="preserve">
          <source>Assignment vs referencing</source>
          <target state="translated">分配与参考</target>
        </trans-unit>
        <trans-unit id="d8a1879dbe4b9ce9021e415e931186b4b4a19157" translate="yes" xml:space="preserve">
          <source>Assigns values from one structured array to another by field name.</source>
          <target state="translated">通过字段名将一个结构化数组的值分配到另一个结构化数组。</target>
        </trans-unit>
        <trans-unit id="ae9a24254ec6cd55a31a48c28461f44e73e53f66" translate="yes" xml:space="preserve">
          <source>Assume &lt;code&gt;mask_func&lt;/code&gt; is a function that, for a square array a of size &lt;code&gt;(n, n)&lt;/code&gt; with a possible offset argument &lt;code&gt;k&lt;/code&gt;, when called as &lt;code&gt;mask_func(a, k)&lt;/code&gt; returns a new array with zeros in certain locations (functions like &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt;&lt;code&gt;triu&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt;&lt;code&gt;tril&lt;/code&gt;&lt;/a&gt; do precisely this). Then this function returns the indices where the non-zero values would be located.</source>
          <target state="translated">假设 &lt;code&gt;mask_func&lt;/code&gt; 是一个函数，对于大小为 &lt;code&gt;(n, n)&lt;/code&gt; 且具有可能的偏移量参数 &lt;code&gt;k&lt;/code&gt; 的 &lt;code&gt;mask_func(a, k)&lt;/code&gt; 当被称为mask_func（a，k）时，它会返回一个在某些位置为零的新数组（函数如&lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt; &lt;code&gt;triu&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt; &lt;code&gt;tril&lt;/code&gt; &lt;/a&gt;恰好做到这一点）。然后，此函数返回将在其中定位非零值的索引。</target>
        </trans-unit>
        <trans-unit id="87a473db70c6a624c40e23afb12c39561d92a618" translate="yes" xml:space="preserve">
          <source>Assume &lt;em&gt;n&lt;/em&gt; is the number of elements in the dimension being sliced. Then, if &lt;em&gt;i&lt;/em&gt; is not given it defaults to 0 for &lt;em&gt;k &amp;gt; 0&lt;/em&gt; and &lt;em&gt;n - 1&lt;/em&gt; for &lt;em&gt;k &amp;lt; 0&lt;/em&gt; . If &lt;em&gt;j&lt;/em&gt; is not given it defaults to &lt;em&gt;n&lt;/em&gt; for &lt;em&gt;k &amp;gt; 0&lt;/em&gt; and &lt;em&gt;-n-1&lt;/em&gt; for &lt;em&gt;k &amp;lt; 0&lt;/em&gt; . If &lt;em&gt;k&lt;/em&gt; is not given it defaults to 1. Note that &lt;code&gt;::&lt;/code&gt; is the same as &lt;code&gt;:&lt;/code&gt; and means select all indices along this axis.</source>
          <target state="translated">假设&lt;em&gt;n&lt;/em&gt;是要切片的维度中的元素数。然后，如果&lt;em&gt;我&lt;/em&gt;没有给出其默认值为0 &lt;em&gt;K&amp;gt; 0&lt;/em&gt;和&lt;em&gt;N - 1&lt;/em&gt;为&lt;em&gt;ķ&amp;lt;0 。&lt;/em&gt;如果&lt;em&gt;Ĵ&lt;/em&gt;没有给出其默认值为&lt;em&gt;&amp;Ntilde;&lt;/em&gt;为&lt;em&gt;K&amp;gt; 0&lt;/em&gt;和&lt;em&gt;-n-1&lt;/em&gt;为&lt;em&gt;ķ&amp;lt;0 &lt;/em&gt;。如果未指定&lt;em&gt;k，&lt;/em&gt;则默认为1。注意 &lt;code&gt;::&lt;/code&gt; 与 &lt;code&gt;:&lt;/code&gt; 相同，表示选择该轴上的所有索引。</target>
        </trans-unit>
        <trans-unit id="b9dccb798e5c5e1b5508e3a8630765c07522b225" translate="yes" xml:space="preserve">
          <source>Assume that the observations are in the columns of the observation array &lt;code&gt;m&lt;/code&gt; and let &lt;code&gt;f = fweights&lt;/code&gt; and &lt;code&gt;a = aweights&lt;/code&gt; for brevity. The steps to compute the weighted covariance are as follows:</source>
          <target state="translated">假设观测值位于观测值数组 &lt;code&gt;m&lt;/code&gt; 的列中，为简洁起见，令 &lt;code&gt;f = fweights&lt;/code&gt; 和 &lt;code&gt;a = aweights&lt;/code&gt; 。计算加权协方差的步骤如下：</target>
        </trans-unit>
        <trans-unit id="97728787c4c0fd66ac4cc28f08c4ba4e206f76e5" translate="yes" xml:space="preserve">
          <source>Assume we have three matrices</source>
          <target state="translated">假设我们有三个矩阵</target>
        </trans-unit>
        <trans-unit id="68035e390827bfef5b6a722908902bf830e33068" translate="yes" xml:space="preserve">
          <source>Assuming that</source>
          <target state="translated">假设</target>
        </trans-unit>
        <trans-unit id="361dbf446d2fcbde7f8e5127964dd121d2c08adc" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;a&lt;/code&gt; is sorted:</source>
          <target state="translated">假设 &lt;code&gt;a&lt;/code&gt; 已排序：</target>
        </trans-unit>
        <trans-unit id="a66d954bab07db2d2ebde3811f3d1797fded0efb" translate="yes" xml:space="preserve">
          <source>Assuming the foo.ini.in file has the following content:</source>
          <target state="translated">假设foo.ini.in文件有如下内容。</target>
        </trans-unit>
        <trans-unit id="3d748459a93c925f679363da9105b14fbf94ff7f" translate="yes" xml:space="preserve">
          <source>Assuming you have followed the instructions in these pages, git will create a default link to your &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; repo called &lt;code&gt;origin&lt;/code&gt;. In git &amp;gt;= 1.7 you can ensure that the link to origin is permanently set by using the &lt;code&gt;--set-upstream&lt;/code&gt; option:</source>
          <target state="translated">假设您已按照这些页面中的说明进行操作，则git将为您的&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github存储库&lt;/a&gt;创建一个名为 &lt;code&gt;origin&lt;/code&gt; 的默认链接。在git&amp;gt; = 1.7中，您可以使用 &lt;code&gt;--set-upstream&lt;/code&gt; 选项确保永久设置到原点的链接：</target>
        </trans-unit>
        <trans-unit id="deb0f65a2eba6ba7c9892f097c02bd25a54d7da6" translate="yes" xml:space="preserve">
          <source>Assuming you have your &lt;a href=&quot;development_environment#development-environment&quot;&gt;development environment&lt;/a&gt; set up, you can now build the code and test it.</source>
          <target state="translated">假设您已经设置了&lt;a href=&quot;development_environment#development-environment&quot;&gt;开发环境&lt;/a&gt;，现在就可以构建代码并对其进行测试。</target>
        </trans-unit>
        <trans-unit id="0c95f65947e1bc255843aa11283635e0c0b35d4e" translate="yes" xml:space="preserve">
          <source>At &lt;em&gt;compile&lt;/em&gt; time, a distutils command is used to define the minimum and maximum features to support, based on user choice and compiler support. The appropriate macros are overlayed with the platform / architecture intrinsics, and the three loops are compiled.</source>
          <target state="translated">在&lt;em&gt;编译&lt;/em&gt;时，将根据用户的选择和编译器支持，使用distutils命令定义要支持的最小和最大功能。适当的宏被平台/体系结构内在函数所覆盖，并编译了三个循环。</target>
        </trans-unit>
        <trans-unit id="3efe13899297822b3fa2661ba300f5fe4b4634e5" translate="yes" xml:space="preserve">
          <source>At &lt;em&gt;runtime import&lt;/em&gt;, the CPU is probed for the set of supported intrinsic features. A mechanism is used to grab the pointer to the most appropriate function, and this will be the one called for the function.</source>
          <target state="translated">在&lt;em&gt;运行时导入时&lt;/em&gt;，将针对支持的一组固有功能对CPU进行探测。一种机制用于获取指向最合适函数的指针，这将是该函数所需要的一种。</target>
        </trans-unit>
        <trans-unit id="0527fe789f4627f3a63d0bb5ba48121982fec81a" translate="yes" xml:space="preserve">
          <source>At each iteration of the loop, the &lt;em&gt;nin&lt;/em&gt; input objects are extracted from their object arrays and placed into an argument tuple, the Python &lt;em&gt;callable&lt;/em&gt; is called with the input arguments, and the nout outputs are placed into their object arrays.</source>
          <target state="translated">在循环的每次迭代中，&lt;em&gt;nin的&lt;/em&gt;输入对象与它们的对象阵列提取并放入参数元组，Python的&lt;em&gt;可调用&lt;/em&gt;被调用的输入参数，并且输出NOUT被置于它们的对象阵列。</target>
        </trans-unit>
        <trans-unit id="ca83daf60668ea69e76df727d7b2b16f815d0807" translate="yes" xml:space="preserve">
          <source>At the beginning of every &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, this method is called on the input object with the highest array priority, or the output object if one was specified. The output array is passed in and whatever is returned is passed to the ufunc. Subclasses inherit a default implementation of this method which simply returns the output array unmodified. Subclasses may opt to use this method to transform the output array into an instance of the subclass and update metadata before returning the array to the ufunc for computation.</source>
          <target state="translated">在每个&lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;的开头，将对具有最高数组优先级的输入对象或如果指定了输出对象的输出对象调用此方法。输出数组将传入，返回的所有内容都会传递给ufunc。子类继承此方法的默认实现，该实现仅返回未修改的输出数组。子类可以选择使用此方法将输出数组转换为子类的实例，并在将数组返回给ufunc进行计算之前更新元数据。</target>
        </trans-unit>
        <trans-unit id="12bc262a1577057e701d7713e64c78fa019c087b" translate="yes" xml:space="preserve">
          <source>At the core of every ufunc is a collection of type-specific functions that defines the basic functionality for each of the supported types. These functions must evaluate the underlying function</source>
          <target state="translated">每个ufunc的核心是一个特定类型函数的集合,它定义了每个支持类型的基本功能。这些函数必须评估底层函数</target>
        </trans-unit>
        <trans-unit id="99499535512b6c181a0f3b43a50d805096cef5c2" translate="yes" xml:space="preserve">
          <source>At the core of every ufunc is a one-dimensional strided loop that implements the actual function for a specific type combination. When a ufunc is created, it is given a static list of inner loops and a corresponding list of type signatures over which the ufunc operates. The ufunc machinery uses this list to determine which inner loop to use for a particular case. You can inspect the &lt;a href=&quot;generated/numpy.ufunc.types#numpy.ufunc.types&quot;&gt;&lt;code&gt;.types&lt;/code&gt;&lt;/a&gt; attribute for a particular ufunc to see which type combinations have a defined inner loop and which output type they produce (&lt;a href=&quot;arrays.scalars#arrays-scalars-character-codes&quot;&gt;character codes&lt;/a&gt; are used in said output for brevity).</source>
          <target state="translated">每个ufunc的核心是一个一维的跨步循环，它为特定的类型组合实现实际功能。创建ufunc时，会为它提供一个内部循环的静态列表以及该ufunc在其上进行操作的类型签名的相应列表。 ufunc机制使用此列表来确定在特定情况下使用哪个内部循环。您可以检查特定&lt;a href=&quot;generated/numpy.ufunc.types#numpy.ufunc.types&quot;&gt; &lt;code&gt;.types&lt;/code&gt; &lt;/a&gt;属性，以查看哪些类型组合具有定义的内部循环以及它们产生的输出类型（为简便起见，在上述输出中使用了&lt;a href=&quot;arrays.scalars#arrays-scalars-character-codes&quot;&gt;字符代码&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a696ebe70ac5ecb64adf92ab51868a20788e2014" translate="yes" xml:space="preserve">
          <source>At the core of the NumPy package, is the &lt;code&gt;ndarray&lt;/code&gt; object. This encapsulates &lt;em&gt;n&lt;/em&gt;-dimensional arrays of homogeneous data types, with many operations being performed in compiled code for performance. There are several important differences between NumPy arrays and the standard Python sequences:</source>
          <target state="translated">NumPy包的核心是 &lt;code&gt;ndarray&lt;/code&gt; 对象。这封装了同类数据类型的&lt;em&gt;n&lt;/em&gt;维数组，其中许多操作都在编译后的代码中执行以提高性能。NumPy数组和标准Python序列之间有几个重要区别：</target>
        </trans-unit>
        <trans-unit id="d886c7715daa7e13f2899ef3973389ec60967548" translate="yes" xml:space="preserve">
          <source>At the end of every &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, this method is called on the input object with the highest array priority, or the output object if one was specified. The ufunc-computed array is passed in and whatever is returned is passed to the user. Subclasses inherit a default implementation of this method, which transforms the array into a new instance of the object&amp;rsquo;s class. Subclasses may opt to use this method to transform the output array into an instance of the subclass and update metadata before returning the array to the user.</source>
          <target state="translated">在每个&lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;的末尾，将对具有最高数组优先级的输入对象或如果指定了输出对象的输出对象调用此方法。ufunc计算的数组将传入，返回的任何内容都将传递给用户。子类继承此方法的默认实现，该实现将数组转换为对象类的新实例。子类可以选择使用此方法将输出数组转换为子类的实例，并在将数组返回给用户之前更新元数据。</target>
        </trans-unit>
        <trans-unit id="b5c2669a04a5d46f02634839c3dfc6c41bdd3f88" translate="yes" xml:space="preserve">
          <source>At the upper right of the page, click &lt;code&gt;Fork&lt;/code&gt;:</source>
          <target state="translated">在页面的右上角，点击 &lt;code&gt;Fork&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="54f27a6635e66c8275db039314e451b39ca65192" translate="yes" xml:space="preserve">
          <source>At this point &lt;code&gt;arr + 3&lt;/code&gt; does not work.</source>
          <target state="translated">此时， &lt;code&gt;arr + 3&lt;/code&gt; 不起作用。</target>
        </trans-unit>
        <trans-unit id="f7cf21779cc632f37ca6f9f1b905fd816410c5c5" translate="yes" xml:space="preserve">
          <source>Attribute statements:</source>
          <target state="translated">属性说明:</target>
        </trans-unit>
        <trans-unit id="e30390c6b25519953f15954ce4132cba67fdd587" translate="yes" xml:space="preserve">
          <source>AttributeError</source>
          <target state="translated">AttributeError</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="cfe76174da05e50b979cc6188b003f45d1df8482" translate="yes" xml:space="preserve">
          <source>Attributes and properties of masked arrays</source>
          <target state="translated">屏蔽数组的属性和特性</target>
        </trans-unit>
        <trans-unit id="75d3cd51a61f739cdedf79817eefc8974a835455" translate="yes" xml:space="preserve">
          <source>Attributes providing additional information:</source>
          <target state="translated">提供额外信息的属性:</target>
        </trans-unit>
        <trans-unit id="1003414a3eb685608efbc345c0f83084c22559bd" translate="yes" xml:space="preserve">
          <source>Attributes that are properties and have their own docstrings can be simply listed by name:</source>
          <target state="translated">作为属性的属性,有自己的docstrings,可以简单地按名称列出。</target>
        </trans-unit>
        <trans-unit id="b8087185e5ee37cef4c337de5697d35d75d909fd" translate="yes" xml:space="preserve">
          <source>Attributes:</source>
          <target state="translated">Attributes:</target>
        </trans-unit>
        <trans-unit id="6854c23ffe094a9dcc2c7d18b7054597700c09d7" translate="yes" xml:space="preserve">
          <source>Author: Pearu Peterson &amp;lt;&lt;a href=&quot;mailto:pearu%40cens.ioc.ee&quot;&gt;pearu@cens.ioc.ee&lt;/a&gt;&amp;gt; Created: 11 January 2003</source>
          <target state="translated">作者：Pearu Peterson &amp;lt; &lt;a href=&quot;mailto:pearu%40cens.ioc.ee&quot;&gt;pearu@cens.ioc.ee&lt;/a&gt; &amp;gt;创建：2003年1月11日</target>
        </trans-unit>
        <trans-unit id="d2a52548bd0852b99153ddd79a1f550f70674c7d" translate="yes" xml:space="preserve">
          <source>Authors</source>
          <target state="translated">Authors</target>
        </trans-unit>
        <trans-unit id="9a8e09e3b7e8024727baccc0a1e74a9673de3c0e" translate="yes" xml:space="preserve">
          <source>Automated Bin Selection Methods example, using 2 peak random data with 2000 points:</source>
          <target state="translated">自动选仓方法实例,采用2个峰值随机数据,2000点。</target>
        </trans-unit>
        <trans-unit id="bfb122c45c152fbdf176456bb1bd4e6bc24c337e" translate="yes" xml:space="preserve">
          <source>Automatic Byte Offsets and Alignment</source>
          <target state="translated">自动字节偏移和对齐</target>
        </trans-unit>
        <trans-unit id="522d7710743316a9bb70282225a360f203660682" translate="yes" xml:space="preserve">
          <source>Automatic detection of forward incompatibilities</source>
          <target state="translated">自动检测正向不相容性</target>
        </trans-unit>
        <trans-unit id="687034389bdc7cc4294c91418210f69e71c2ea75" translate="yes" xml:space="preserve">
          <source>Automatic extension module generation</source>
          <target state="translated">自动生成扩展模块</target>
        </trans-unit>
        <trans-unit id="b2ebac8c965ff2e52dca0ea08eceaccc8803b780" translate="yes" xml:space="preserve">
          <source>Automatically generated reference documentation</source>
          <target state="translated">自动生成参考文档</target>
        </trans-unit>
        <trans-unit id="65efb82d6e37e5b9994108df57fecde86e561550" translate="yes" xml:space="preserve">
          <source>Auxiliary Data With Object Semantics</source>
          <target state="translated">具有对象语义的辅助数据</target>
        </trans-unit>
        <trans-unit id="b5d54069c98dcc2bb7ef53455746da49544d4c61" translate="yes" xml:space="preserve">
          <source>Available Typemaps</source>
          <target state="translated">可用的类型图</target>
        </trans-unit>
        <trans-unit id="0eba0fa1e7377ce939b86cc49e664126d93a94fb" translate="yes" xml:space="preserve">
          <source>Available labels are:</source>
          <target state="translated">可用的标签有:</target>
        </trans-unit>
        <trans-unit id="b9ef456325fee29b959d2b71abeec2f41a07fee2" translate="yes" xml:space="preserve">
          <source>Available ufuncs</source>
          <target state="translated">可用的ufuncs</target>
        </trans-unit>
        <trans-unit id="15f86c051ecf0b64e5f8cdc8c689552f42595942" translate="yes" xml:space="preserve">
          <source>Average</source>
          <target state="translated">Average</target>
        </trans-unit>
        <trans-unit id="00230b1d5c35405f7ca65ccbf60097d1ff75f793" translate="yes" xml:space="preserve">
          <source>Averages and variances</source>
          <target state="translated">平均数和差异</target>
        </trans-unit>
        <trans-unit id="c283b762c8c40e64645901b30f41d8175d39891d" translate="yes" xml:space="preserve">
          <source>Avoid when possible; &lt;a href=&quot;https://docs.python.org/dev/library/pickle.html&quot;&gt;pickles&lt;/a&gt; are not secure against erroneous or maliciously constructed data.</source>
          <target state="translated">尽可能避免；&lt;a href=&quot;https://docs.python.org/dev/library/pickle.html&quot;&gt;泡菜&lt;/a&gt;对于错误或恶意构建的数据是不安全的。</target>
        </trans-unit>
        <trans-unit id="e7a6dacf63a1600c6901329b8727cfba6197e8fd" translate="yes" xml:space="preserve">
          <source>Axes are defined for arrays with more than one dimension. A 2-dimensional array has two corresponding axes: the first running vertically downwards across rows (axis 0), and the second running horizontally across columns (axis 1).</source>
          <target state="translated">轴是为多于一维的数组定义的。一个二维数组有两个相应的轴:第一个轴垂直向下穿过行(0轴),第二个轴水平穿过列(1轴)。</target>
        </trans-unit>
        <trans-unit id="260a17f609be1b620f1eb6b59b7945c255c81429" translate="yes" xml:space="preserve">
          <source>Axes in &lt;code&gt;a&lt;/code&gt; to reorder to the right, before inversion. If None (default), no reordering is done.</source>
          <target state="translated">反转前，将 &lt;code&gt;a&lt;/code&gt; 轴重新排序到右侧。如果为None（默认），则不进行任何重新排序。</target>
        </trans-unit>
        <trans-unit id="db233fcb37135c7f09c5ffb89b7ba1fec760ef66" translate="yes" xml:space="preserve">
          <source>Axes over which &lt;code&gt;func&lt;/code&gt; is applied; the elements must be integers.</source>
          <target state="translated">应用了 &lt;code&gt;func&lt;/code&gt; 的轴；元素必须是整数。</target>
        </trans-unit>
        <trans-unit id="3c7544c1215157a53157a59a39707d4b0bcf94df" translate="yes" xml:space="preserve">
          <source>Axes over which to calculate. Defaults to None, which shifts all axes.</source>
          <target state="translated">要计算的轴。默认为 &quot;无&quot;,会移动所有轴。</target>
        </trans-unit>
        <trans-unit id="01251d80564e6fc5615a7911ad0e73434e304c26" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT.</source>
          <target state="translated">用于计算FFT的轴。</target>
        </trans-unit>
        <trans-unit id="eae74832fcf1fa3443d947416920310bd08270f6" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified.</source>
          <target state="translated">计算FFT的轴。如果未指定，则使用最后一个 &lt;code&gt;len(s)&lt;/code&gt; 轴，如果未指定 &lt;code&gt;s&lt;/code&gt; ，则使用所有轴。</target>
        </trans-unit>
        <trans-unit id="087a54cd73e6a93e216a09c22b970ec84185e189" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified. Repeated indices in &lt;code&gt;axes&lt;/code&gt; means that the transform over that axis is performed multiple times.</source>
          <target state="translated">计算FFT的轴。如果未指定，则使用最后一个 &lt;code&gt;len(s)&lt;/code&gt; 轴，如果未指定 &lt;code&gt;s&lt;/code&gt; ，则使用所有轴。 &lt;code&gt;axes&lt;/code&gt; 重复的索引意味着该轴上的变换执行了多次。</target>
        </trans-unit>
        <trans-unit id="c012449cfef6487dddab190f30ddad2f2e0316c1" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT. If not given, the last two axes are used. A repeated index in &lt;code&gt;axes&lt;/code&gt; means the transform over that axis is performed multiple times. A one-element sequence means that a one-dimensional FFT is performed.</source>
          <target state="translated">计算FFT的轴。如果未给出，则使用最后两个轴。 &lt;code&gt;axes&lt;/code&gt; 重复的索引意味着多次执行该轴上的变换。一元素序列意味着执行一维FFT。</target>
        </trans-unit>
        <trans-unit id="c1bbe9559f43f27cc8c677ee579702aea02533b0" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the IFFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified. Repeated indices in &lt;code&gt;axes&lt;/code&gt; means that the inverse transform over that axis is performed multiple times.</source>
          <target state="translated">计算IFFT的轴。如果未指定，则使用最后一个 &lt;code&gt;len(s)&lt;/code&gt; 轴，如果未指定 &lt;code&gt;s&lt;/code&gt; ，则使用所有轴。 &lt;code&gt;axes&lt;/code&gt; 重复的索引意味着多次执行该轴上的逆变换。</target>
        </trans-unit>
        <trans-unit id="b354616c4fe4a354f85531d5428c20c0b32f3c2f" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the inverse FFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified. Repeated indices in &lt;code&gt;axes&lt;/code&gt; means that the inverse transform over that axis is performed multiple times.</source>
          <target state="translated">计算逆FFT的轴。如果未指定，则使用最后一个 &lt;code&gt;len(s)&lt;/code&gt; 轴，如果未指定 &lt;code&gt;s&lt;/code&gt; ，则使用所有轴。 &lt;code&gt;axes&lt;/code&gt; 重复的索引意味着多次执行该轴上的逆变换。</target>
        </trans-unit>
        <trans-unit id="8a99b64a4a7a7c7ead7b23b02c696f0da53ae319" translate="yes" xml:space="preserve">
          <source>Axes over which to shift. Default is None, which shifts all axes.</source>
          <target state="translated">要移动的轴。默认为 &quot;无&quot;,即移动所有轴。</target>
        </trans-unit>
        <trans-unit id="0a52967d9e9b8df8a4f8c170f8ca693ae8a86fe3" translate="yes" xml:space="preserve">
          <source>Axes to be used as the first and second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults are the first two axes of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">用作2-D子阵列的第一轴和第二轴的轴，应该从中获取对角线。缺省值是前两个轴线 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f303f8b434501d0a0e88a06f71ae6bf60e07440a" translate="yes" xml:space="preserve">
          <source>Axis along which &lt;code&gt;arr&lt;/code&gt; is sliced.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 轴。</target>
        </trans-unit>
        <trans-unit id="eb47b635b568e5dba0343ed2ed07af3eb1c5f691" translate="yes" xml:space="preserve">
          <source>Axis along which logical OR is performed</source>
          <target state="translated">执行逻辑OR的轴线</target>
        </trans-unit>
        <trans-unit id="09cfc91cd9019ea0548a0bc697b5fe1ac4febf1f" translate="yes" xml:space="preserve">
          <source>Axis along which the cumulative product is computed. By default the input is flattened.</source>
          <target state="translated">计算累积积的轴。默认情况下,输入是扁平化的。</target>
        </trans-unit>
        <trans-unit id="57187cefb1f2a69dac281d57460affb45a365e61" translate="yes" xml:space="preserve">
          <source>Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array.</source>
          <target state="translated">计算累计和的轴。默认值(None)是计算扁平化数组的累加和。</target>
        </trans-unit>
        <trans-unit id="f37486b57129451282a7b678277fa8169fe0110e" translate="yes" xml:space="preserve">
          <source>Axis along which the elements are counted. By default, give the total number of elements.</source>
          <target state="translated">沿着元素计数的轴。默认情况下,给出元素的总数。</target>
        </trans-unit>
        <trans-unit id="b08197a0ff41e61316a0f60a6919ee14fb5fe98b" translate="yes" xml:space="preserve">
          <source>Axis along which the medians are computed. The default (None) is to compute the median along a flattened version of the array.</source>
          <target state="translated">计算中位数的轴。默认值(None)是沿数组的扁平化版本计算中位数。</target>
        </trans-unit>
        <trans-unit id="bc92a5f411fa4b8657deb697c80aca8e1f76fb85" translate="yes" xml:space="preserve">
          <source>Axis along which the operation must be performed.</source>
          <target state="translated">必须沿此轴进行操作。</target>
        </trans-unit>
        <trans-unit id="f2cd71dae3fa50b163de963d5f5e4581028e17b5" translate="yes" xml:space="preserve">
          <source>Axis along which to average &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;None&lt;/code&gt;, averaging is done over the flattened array.</source>
          <target state="translated">平均 &lt;code&gt;a&lt;/code&gt; 轴。如果为 &lt;code&gt;None&lt;/code&gt; ，则对展平的数组进行平均。</target>
        </trans-unit>
        <trans-unit id="17667e8c77ab258d88774c70f62a92c1b9869875" translate="yes" xml:space="preserve">
          <source>Axis along which to average &lt;code&gt;a&lt;/code&gt;. If None, averaging is done over the flattened array.</source>
          <target state="translated">轴沿其平均 &lt;code&gt;a&lt;/code&gt; 。如果为None，则对展平的数组进行平均。</target>
        </trans-unit>
        <trans-unit id="6740a47c78c530ff5565f890ca7a6510d66b94b6" translate="yes" xml:space="preserve">
          <source>Axis along which to count. If None (default), a flattened version of the array is used.</source>
          <target state="translated">计数的轴。如果为 &quot;无&quot;(默认),则使用扁平化的数组。</target>
        </trans-unit>
        <trans-unit id="87e6cb227cab73030094d0bab3690d5e44d50da1" translate="yes" xml:space="preserve">
          <source>Axis along which to find the peaks. By default, flatten the array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">查找峰沿的轴。默认情况下，展平阵列。 &lt;code&gt;axis&lt;/code&gt; 可能为负，在这种情况下，它从最后一个轴开始计数。</target>
        </trans-unit>
        <trans-unit id="d012a76459484bfd8767b22b0537d0b22d4d11bb" translate="yes" xml:space="preserve">
          <source>Axis along which to find the peaks. If None (default) the flattened array is used.</source>
          <target state="translated">沿着轴找到峰值。如果为 &quot;无&quot;(默认值),则使用扁平化阵列。</target>
        </trans-unit>
        <trans-unit id="c855b308fb59a9f63969a5e9a73073df7701d3a8" translate="yes" xml:space="preserve">
          <source>Axis along which to insert &lt;code&gt;values&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is None then &lt;code&gt;arr&lt;/code&gt; is flattened first.</source>
          <target state="translated">沿其插入 &lt;code&gt;values&lt;/code&gt; 轴。如果 &lt;code&gt;axis&lt;/code&gt; 为None，则 &lt;code&gt;arr&lt;/code&gt; 首先被展平。</target>
        </trans-unit>
        <trans-unit id="caa670fb62ad34335b9428afd9953d664aefbfc6" translate="yes" xml:space="preserve">
          <source>Axis along which to operate. By default flattened input is used.</source>
          <target state="translated">操作的轴。默认情况下,使用扁平化的输入。</target>
        </trans-unit>
        <trans-unit id="1612a72f0d3b6ca5a9a80a269a8a766d4f4346ff" translate="yes" xml:space="preserve">
          <source>Axis along which to operate. By default, &lt;code&gt;axis&lt;/code&gt; is None and the flattened input is used.</source>
          <target state="translated">沿其运行的轴。默认情况下， &lt;code&gt;axis&lt;/code&gt; 为&amp;ldquo;无&amp;rdquo;，并且使用展平的输入。</target>
        </trans-unit>
        <trans-unit id="dfc23123538404f83aba951929e9f61fafacf779" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. Default is None.</source>
          <target state="translated">执行操作的轴。默认为 &quot;无&quot;。</target>
        </trans-unit>
        <trans-unit id="f599b7c76d66ef3380a35805a50ac6efed5828ce" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. If None (default), applies to a flattened version of the array, and this is the same as &lt;a href=&quot;numpy.ma.flatnotmasked_contiguous#numpy.ma.flatnotmasked_contiguous&quot;&gt;&lt;code&gt;flatnotmasked_contiguous&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">沿其执行操作的轴。如果为None（默认值），则适用于数组的展平版本，这与&lt;a href=&quot;numpy.ma.flatnotmasked_contiguous#numpy.ma.flatnotmasked_contiguous&quot;&gt; &lt;code&gt;flatnotmasked_contiguous&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="04c94dfe1278eba9030646d853545708152162d2" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. If None (default), applies to a flattened version of the array.</source>
          <target state="translated">执行操作的轴。如果为 &quot;无&quot;(默认),则适用于扁平化的数组。</target>
        </trans-unit>
        <trans-unit id="504f2a8eb88761fe60f8368b4521f8ae3d7cee4e" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. If None, applies to a flattened version of the array.</source>
          <target state="translated">执行操作的轴。如果无,适用于扁平化的数组。</target>
        </trans-unit>
        <trans-unit id="152709e5051b3ce45dda1f386ffce54b5252f137" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. Default is -1, which means sort along the last axis.</source>
          <target state="translated">排序的轴。默认值为-1,即沿着最后一个轴进行排序。</target>
        </trans-unit>
        <trans-unit id="2188a35fbb2aa8c603498f4b78d1698cebdd5a7d" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis.</source>
          <target state="translated">排序的轴。如果为 &quot;无&quot;,则在排序前对数组进行扁平化处理。默认值是-1,沿最后一个轴排序。</target>
        </trans-unit>
        <trans-unit id="740a6ece80316cdabae954a87f619b8a229d3521" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. If None, the default, the flattened array is used.</source>
          <target state="translated">要排序的轴。如果为 &quot;无&quot;,默认使用扁平化的数组。</target>
        </trans-unit>
        <trans-unit id="d4ba2932956beb23c342eb9374fa565cb3b55723" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. The default is -1 (the last axis). If None, the flattened array is used.</source>
          <target state="translated">要排序的轴。默认值是-1(最后一个轴)。如果无,则使用扁平化的数组。</target>
        </trans-unit>
        <trans-unit id="bf13afc2432793901330c8c7a32dd664b93fb6da" translate="yes" xml:space="preserve">
          <source>Axis along which to take slices. If None (default), work on the flattened array.</source>
          <target state="translated">切片的轴线。如果为None(默认),则在扁平化的数组上工作。</target>
        </trans-unit>
        <trans-unit id="862dd8c4bcf2d6630f10d14b83366d28de07835e" translate="yes" xml:space="preserve">
          <source>Axis along which unwrap will operate, default is the last axis.</source>
          <target state="translated">拆包操作的轴,默认为最后一个轴。</target>
        </trans-unit>
        <trans-unit id="2642370e7acd3a38fa3e5ae2e4852e710ae2493f" translate="yes" xml:space="preserve">
          <source>Axis of &lt;code&gt;a&lt;/code&gt; that defines the vector(s). By default, the last axis.</source>
          <target state="translated">定义向量的 &lt;code&gt;a&lt;/code&gt; 轴。默认情况下，最后一个轴。</target>
        </trans-unit>
        <trans-unit id="ac79a24e9b27340a01d757c607f815c179d09b07" translate="yes" xml:space="preserve">
          <source>Axis of &lt;code&gt;b&lt;/code&gt; that defines the vector(s). By default, the last axis.</source>
          <target state="translated">定义向量的 &lt;code&gt;b&lt;/code&gt; 轴。默认情况下，最后一个轴。</target>
        </trans-unit>
        <trans-unit id="f367b3271f5fcf8c75672a1e31a99c742130492f" translate="yes" xml:space="preserve">
          <source>Axis of &lt;code&gt;c&lt;/code&gt; containing the cross product vector(s). Ignored if both input vectors have dimension 2, as the return is scalar. By default, the last axis.</source>
          <target state="translated">包含叉积向量的 &lt;code&gt;c&lt;/code&gt; 轴。如果两个输入向量的维数均为2，则将其忽略，因为返回值为标量。默认情况下，最后一个轴。</target>
        </trans-unit>
        <trans-unit id="73455e870dee7c0562b8878e31766028fce2291e" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical AND reduction is performed. The default (&lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt;) is to perform a logical AND over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">执行逻辑与归约的一个或多个轴。默认值（ &lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt; ）是对输入数组的所有维执行逻辑与。 &lt;code&gt;axis&lt;/code&gt; 可能为负，在这种情况下，它从最后一个轴开始计数。</target>
        </trans-unit>
        <trans-unit id="10ee68577b50399a741722b3f075be540558e59c" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical AND reduction is performed. The default (&lt;code&gt;axis=None&lt;/code&gt;) is to perform a logical AND over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">执行逻辑与归约的一个或多个轴。默认值（ &lt;code&gt;axis=None&lt;/code&gt; ）是在输入数组的所有维度上执行逻辑与。 &lt;code&gt;axis&lt;/code&gt; 可能为负，在这种情况下，它从最后一个轴开始计数。</target>
        </trans-unit>
        <trans-unit id="f611b0275c8907be5ddfd942eef1d1cb490e3bfa" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical OR reduction is performed. The default (&lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt;) is to perform a logical OR over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">执行逻辑或归约的一个或多个轴。默认值（ &lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt; ）是对输入数组的所有维度执行逻辑或。 &lt;code&gt;axis&lt;/code&gt; 可能为负，在这种情况下，它从最后一个轴开始计数。</target>
        </trans-unit>
        <trans-unit id="4b3cd50c25bcf6114d5dbf62c339109576c970bf" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical OR reduction is performed. The default (&lt;code&gt;axis=None&lt;/code&gt;) is to perform a logical OR over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">执行逻辑或归约的一个或多个轴。默认值（ &lt;code&gt;axis=None&lt;/code&gt; ）是对输入数组的所有维度执行逻辑或。 &lt;code&gt;axis&lt;/code&gt; 可能为负，在这种情况下，它从最后一个轴开始计数。</target>
        </trans-unit>
        <trans-unit id="9fd47f9900eba5a8ae95abac9ad38d16026ca50d" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a product is performed. The default, axis=None, will calculate the product of all the elements in the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">执行乘积的一个或多个轴。默认情况下,axis=None,将计算输入数组中所有元素的乘积。如果axis为负数,则从最后一个轴到第一个轴进行计算。</target>
        </trans-unit>
        <trans-unit id="be576580b5bc0f979cac29a5b9d9045456b366f7" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a reduction is performed. The default (&lt;code&gt;axis&lt;/code&gt; = 0) is perform a reduction over the first dimension of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">进行缩小的一个或多个轴。默认值（ &lt;code&gt;axis&lt;/code&gt; = 0）是对输入数组的第一个维进行缩减。 &lt;code&gt;axis&lt;/code&gt; 可能为负，在这种情况下，它从最后一个轴开始计数。</target>
        </trans-unit>
        <trans-unit id="a9d8568517293b16cabcf73bd06fbc68a72003cd" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">进行求和的一个或多个轴。默认情况下,axis=None,将对输入数组的所有元素进行求和。如果axis为负数,则从最后一个轴到第一个轴进行计数。</target>
        </trans-unit>
        <trans-unit id="7cc8bc628160032ea1ebe6f16101b997f0306e3e" translate="yes" xml:space="preserve">
          <source>Axis or axes along which elements are shifted. By default, the array is flattened before shifting, after which the original shape is restored.</source>
          <target state="translated">移动元素的轴线。默认情况下,在移动之前,数组会被压平,之后会恢复原来的形状。</target>
        </trans-unit>
        <trans-unit id="0e425003e67ef9bdd8af0004538626cffe9c1582" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the count is performed. The default (&lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt;) performs the count over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">进行计数的一个或多个轴。默认值（ &lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt; ）对输入数组的所有维度进行计数。 &lt;code&gt;axis&lt;/code&gt; 可能为负，在这种情况下，它从最后一个轴开始计数。</target>
        </trans-unit>
        <trans-unit id="dbd8b445b81cd5436ce710f441b84e722e566a56" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the count is performed. The default, None, performs the count over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">进行计数的一个或多个轴。默认值为&amp;ldquo;无&amp;rdquo;，将对输入数组的所有维度进行计数。 &lt;code&gt;axis&lt;/code&gt; 可能为负，在这种情况下，它从最后一个轴开始计数。</target>
        </trans-unit>
        <trans-unit id="337ec9c050b4ae190316c405d645be292f57618f" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the maximum is computed. The default is to compute the maximum of the flattened array.</source>
          <target state="translated">计算最大值的一个或多个轴。默认情况下是计算扁平化数组的最大值。</target>
        </trans-unit>
        <trans-unit id="5bcbcdbcc90358e775edd4243e64cbf53abf5bcb" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the means are computed. The default is to compute the mean of the flattened array.</source>
          <target state="translated">计算平均值的轴。默认情况下是计算扁平化数组的平均值。</target>
        </trans-unit>
        <trans-unit id="81e7f835d919d359ddd019861026589dd953700f" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the medians are computed. The default is to compute the median along a flattened version of the array. A sequence of axes is supported since version 1.9.0.</source>
          <target state="translated">计算中位数的一个或多个轴。默认情况下是沿数组的扁平化版本计算中位数。从1.9.0版本开始支持轴的序列。</target>
        </trans-unit>
        <trans-unit id="86845400b54274fa2252847f24187b5fc174bc52" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the minimum is computed. The default is to compute the minimum of the flattened array.</source>
          <target state="translated">计算最小值的坐标轴。默认是计算扁平化数组的最小值。</target>
        </trans-unit>
        <trans-unit id="afcadb3cc3e2b57bd1839f95d5290aac2075b609" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the percentiles are computed. The default is to compute the percentile(s) along a flattened version of the array.</source>
          <target state="translated">计算百分位数的一个或多个轴。默认情况下是沿着一个扁平化的数组计算百分位数。</target>
        </trans-unit>
        <trans-unit id="1383f75934b288777f915d7bd0d8e7d4bc49532a" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the product is computed. The default is to compute the product of the flattened array.</source>
          <target state="translated">计算积的坐标轴。默认情况下是计算扁平化数组的乘积。</target>
        </trans-unit>
        <trans-unit id="dc86583a236f0e917d6fd47accfd6b2805fa40e8" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the quantiles are computed. The default is to compute the quantile(s) along a flattened version of the array.</source>
          <target state="translated">计算量子值的一个或多个轴。默认情况下是沿着一个扁平化的数组计算分位数。</target>
        </trans-unit>
        <trans-unit id="c32c668e0dd59a8b292f11f9182ecb083fc9a19d" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the sliding window is applied. By default, the sliding window is applied to all axes and &lt;code&gt;window_shape[i]&lt;/code&gt; will refer to axis &lt;code&gt;i&lt;/code&gt; of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is given as a &lt;code&gt;tuple of int&lt;/code&gt;, &lt;code&gt;window_shape[i]&lt;/code&gt; will refer to the axis &lt;code&gt;axis[i]&lt;/code&gt; of &lt;code&gt;x&lt;/code&gt;. Single integers &lt;code&gt;i&lt;/code&gt; are treated as if they were the tuple &lt;code&gt;(i,)&lt;/code&gt;.</source>
          <target state="translated">滑动窗口沿其应用的一个或多个轴。默认情况下，滑动窗口被施加到所有的轴和 &lt;code&gt;window_shape[i]&lt;/code&gt; 将参考轴线 &lt;code&gt;i&lt;/code&gt; 的 &lt;code&gt;x&lt;/code&gt; 。如果 &lt;code&gt;axis&lt;/code&gt; 被给出为一个 &lt;code&gt;tuple of int&lt;/code&gt; ， &lt;code&gt;window_shape[i]&lt;/code&gt; 将参考轴 &lt;code&gt;axis[i]&lt;/code&gt; 的 &lt;code&gt;x&lt;/code&gt; 。将单个整数 &lt;code&gt;i&lt;/code&gt; 视为它们是元组 &lt;code&gt;(i,)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff0198667d8f16fd97a42b385598004387813742" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the standard deviation is computed. The default is to compute the standard deviation of the flattened array.</source>
          <target state="translated">计算标准差的一个或多个轴。默认值是计算扁平化数组的标准差。</target>
        </trans-unit>
        <trans-unit id="561888a8d151a5f97b2ece2d51ce899a36bbfbdf" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the sum is computed. The default is to compute the sum of the flattened array.</source>
          <target state="translated">计算和的轴。默认情况下是计算扁平化数组的和。</target>
        </trans-unit>
        <trans-unit id="949a7d6d27806e44a3241bd974384af685d26396" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the variance is computed. The default is to compute the variance of the flattened array.</source>
          <target state="translated">计算方差的一个或多个轴。默认情况是计算扁平化数组的方差。</target>
        </trans-unit>
        <trans-unit id="daa1ea5e7ee9d15405e9d59d22ce1b86e2982a0b" translate="yes" xml:space="preserve">
          <source>Axis or axes along which to average &lt;code&gt;a&lt;/code&gt;. The default, axis=None, will average over all of the elements of the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">求平均值的 &lt;code&gt;a&lt;/code&gt; 或多个轴。默认值axis = None将对输入数组的所有元素求平均值。如果轴为负，则从最后一个轴开始计数。</target>
        </trans-unit>
        <trans-unit id="64370fd7391d23015a65d6e00207ab3ff57c0028" translate="yes" xml:space="preserve">
          <source>Axis or axes along which to flip over. The default, axis=None, will flip over all of the axes of the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">要翻转的一个或多个轴。默认情况下,axis=None,将在输入数组的所有轴上翻转。如果 axis 是负数,则从最后一个轴到第一个轴计数。</target>
        </trans-unit>
        <trans-unit id="f2bf5799ae5ef9d1cdddea7d865553db9614fd21" translate="yes" xml:space="preserve">
          <source>Axis or axes along which to operate. By default, flattened input is used.</source>
          <target state="translated">要操作的一个或多个轴。默认情况下,使用扁平化的输入。</target>
        </trans-unit>
        <trans-unit id="f257ca43f52b8d212133752a1e0cef3f157fcc12" translate="yes" xml:space="preserve">
          <source>Axis or tuple of axes along which to count non-zeros. Default is None, meaning that non-zeros will be counted along a flattened version of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">用于计算非零值的轴或轴元组。默认值是无，这意味着非零点将沿着一个扁平版本进行计数 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dfdd6be5ea8d2b943040ace17a9b289e52760e7" translate="yes" xml:space="preserve">
          <source>Axis over which the anomalies are taken. The default is to use the mean of the flattened array as reference.</source>
          <target state="translated">异常点所处的轴。默认情况下,使用扁平化数组的平均值作为参考。</target>
        </trans-unit>
        <trans-unit id="5a28ddd98da60a547b5ae35ef6abe54e89e91508" translate="yes" xml:space="preserve">
          <source>Axis over which the derivative is taken. (Default: 0).</source>
          <target state="translated">取导数的轴。(默认值:0)。</target>
        </trans-unit>
        <trans-unit id="ca8db3e3878b22dd385e21680a7f2404ba4af59f" translate="yes" xml:space="preserve">
          <source>Axis over which the integral is taken. (Default: 0).</source>
          <target state="translated">取积分的轴。(默认值:0)。</target>
        </trans-unit>
        <trans-unit id="7238aa3702fcf05542c14de94bdcecf60c8463af" translate="yes" xml:space="preserve">
          <source>Axis over which to compute the FFT. If not given, the last axis is used.</source>
          <target state="translated">计算FFT的轴。如果没有给出,则使用最后一个轴。</target>
        </trans-unit>
        <trans-unit id="78aed7a81e841b649e307d86af83f2a27f772253" translate="yes" xml:space="preserve">
          <source>Axis over which to compute the inverse DFT. If not given, the last axis is used.</source>
          <target state="translated">计算反DFT的轴。如果没有给出,则使用最后一个轴。</target>
        </trans-unit>
        <trans-unit id="1994028401ccc8c25a36ddcd64e63635d1053d3a" translate="yes" xml:space="preserve">
          <source>Axis over which to compute the inverse FFT. If not given, the last axis is used.</source>
          <target state="translated">计算反FFT的轴。如果没有给出,则使用最后一个轴。</target>
        </trans-unit>
        <trans-unit id="7fc8d289aafc37f1ce906424ecc35f2c72d9a34f" translate="yes" xml:space="preserve">
          <source>Axis to be indirectly sorted. By default, sort over the last axis.</source>
          <target state="translated">要间接排序的轴。默认情况下,在最后一个轴上排序。</target>
        </trans-unit>
        <trans-unit id="3e1ca61bed45345ef5098f13d05c389833be3df8" translate="yes" xml:space="preserve">
          <source>Axis to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to first axis (0).</source>
          <target state="translated">用来作为二维子阵列的第一轴的轴,对角线应该从这里开始。默认为第一轴(0)。</target>
        </trans-unit>
        <trans-unit id="45f7ee7208a9fb7d4e4732ffbd5f973fe0a479d3" translate="yes" xml:space="preserve">
          <source>Axis to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to second axis (1).</source>
          <target state="translated">用来作为二维子阵列的第二轴的轴,对角线应该从这里开始。默认为第二轴(1)。</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="c7781e5925cc1162bf57ca801ea173a8789aefd5" translate="yes" xml:space="preserve">
          <source>BEHAVED and C_CONTIGUOUS.</source>
          <target state="translated">BEHAVED和C_CONTIGUOUS。</target>
        </trans-unit>
        <trans-unit id="eca3180a6c33b0a38f6f76fa644f63211aa1f14e" translate="yes" xml:space="preserve">
          <source>BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.</source>
          <target state="translated">BEHAVED和F_CONTIGUOUS而不是C_CONTIGUOUS。</target>
        </trans-unit>
        <trans-unit id="c7243d04c977df0309eee7b50ccaddc2665154ee" translate="yes" xml:space="preserve">
          <source>BLAS</source>
          <target state="translated">BLAS</target>
        </trans-unit>
        <trans-unit id="bcd158bb5feaae9038808e3b55d2a031b8ba7709" translate="yes" xml:space="preserve">
          <source>BLAS (NetLIB)</source>
          <target state="translated">BLAS(NetLIB)</target>
        </trans-unit>
        <trans-unit id="dcf8c920edb3ad9eb9b92f8b67ba19eaaa1b8c86" translate="yes" xml:space="preserve">
          <source>BLIS</source>
          <target state="translated">BLIS</target>
        </trans-unit>
        <trans-unit id="cf867b1a06ac32f25a3a53b5cac69625adf84e3c" translate="yes" xml:space="preserve">
          <source>BLIS support in &lt;code&gt;numpy.distutils&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.distutils&lt;/code&gt; 中的BLIS支持</target>
        </trans-unit>
        <trans-unit id="214e501b88ef4fd6dfd2e0ceb3d07f872f3aa657" translate="yes" xml:space="preserve">
          <source>BSD / Solaris</source>
          <target state="translated">BSD/Solaris</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="bd452a7ea759269a521e984eabecb645ce4b2ea6" translate="yes" xml:space="preserve">
          <source>Background information</source>
          <target state="translated">背景资料</target>
        </trans-unit>
        <trans-unit id="090a12d667902964e48f38714b38e1c7c7410ac2" translate="yes" xml:space="preserve">
          <source>Backport Pull Requests</source>
          <target state="translated">后港拉练请求</target>
        </trans-unit>
        <trans-unit id="304c9bb8acb18cf698a66eac9714c36a88110784" translate="yes" xml:space="preserve">
          <source>Backporting</source>
          <target state="translated">Backporting</target>
        </trans-unit>
        <trans-unit id="850de91aa7213a4adf4d94aeab2caaf4d100f909" translate="yes" xml:space="preserve">
          <source>Backporting is the process of copying new feature/fixes committed in &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;numpy/master&lt;/a&gt; back to stable release branches. To do this you make a branch off the branch you are backporting to, cherry pick the commits you want from &lt;code&gt;numpy/master&lt;/code&gt;, and then submit a pull request for the branch containing the backport.</source>
          <target state="translated">反向移植是将&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;numpy / master中&lt;/a&gt;提交的新功能/修复复制回稳定版本分支的过程。为此，请在要反向移植到的分支上创建一个分支，从 &lt;code&gt;numpy/master&lt;/code&gt; 中选择所需的提交，然后为包含反向移植的分支提交拉取请求。</target>
        </trans-unit>
        <trans-unit id="7e9bfe183c1510e40aa465bc59796172c1a8f60e" translate="yes" xml:space="preserve">
          <source>Bad or missing data can be cleanly ignored by putting it in a masked array, which has an internal boolean array indicating invalid entries. Operations with masked arrays ignore these entries.</source>
          <target state="translated">坏的或缺失的数据可以通过把它放在一个掩码数组中被干净地忽略,掩码数组有一个内部的布尔数组表示无效的条目。对掩码数组的操作会忽略这些条目。</target>
        </trans-unit>
        <trans-unit id="172132c5b69b62eb861ca29a9ea486edc3f7219f" translate="yes" xml:space="preserve">
          <source>Bare metal, wrap your own C-code manually.</source>
          <target state="translated">赤裸裸的金属,手动包裹自己的C码。</target>
        </trans-unit>
        <trans-unit id="53740dccbfb785b89a2a2e2837295960b3f62362" translate="yes" xml:space="preserve">
          <source>Base Class for generic BitGenerators, which provide a stream of random bits based on different algorithms.</source>
          <target state="translated">通用BitGenerators的基类,它提供了基于不同算法的随机比特流。</target>
        </trans-unit>
        <trans-unit id="2f03f2251cbc22f3d11027c3e6199900a02163b7" translate="yes" xml:space="preserve">
          <source>Base Class for generic BitGenerators, which provide a stream of random bits based on different algorithms. Must be overridden.</source>
          <target state="translated">通用比特生成器的基类,提供基于不同算法的随机比特流。必须被重写。</target>
        </trans-unit>
        <trans-unit id="18c896688f02b72b07f8b6644f275710e91f33b7" translate="yes" xml:space="preserve">
          <source>Base class</source>
          <target state="translated">基础类</target>
        </trans-unit>
        <trans-unit id="c559e4e184dd4d014a0b5060ba07110daeea6a9f" translate="yes" xml:space="preserve">
          <source>Base class for all polynomial types.</source>
          <target state="translated">所有多项式类型的基类。</target>
        </trans-unit>
        <trans-unit id="6149d0f0d497f5c19a312e242e3099f49c4e1828" translate="yes" xml:space="preserve">
          <source>Base class for errors in this module.</source>
          <target state="translated">本模块中错误的基类。</target>
        </trans-unit>
        <trans-unit id="6c3e6ca54a7a88ced88fed404dda8485677d4e2e" translate="yes" xml:space="preserve">
          <source>Base class for numpy scalar types.</source>
          <target state="translated">numpy scalar类型的基类。</target>
        </trans-unit>
        <trans-unit id="860a1492914588f337f184bd4823757e7c5382ef" translate="yes" xml:space="preserve">
          <source>Base object if memory is from some other object.</source>
          <target state="translated">如果内存来自其他对象,则为基础对象。</target>
        </trans-unit>
        <trans-unit id="e272affdfa292522d2f5ac68c3e4ab276db10b62" translate="yes" xml:space="preserve">
          <source>Base of natural logarithm (</source>
          <target state="translated">自然对数的基数(</target>
        </trans-unit>
        <trans-unit id="65a08d51a2e698f7325209df48e279e52d580030" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;2**x1 + 2**x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">以2为基数的对数 &lt;code&gt;2**x1 + 2**x2&lt;/code&gt; 。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="dc8e13711f25f1ed77c835a90063cf7df6b684db" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的以2为底的对数。</target>
        </trans-unit>
        <trans-unit id="99798b5608dba0e80521a63a27ddafba29b89b07" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的以2为底的对数。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="38987414db4d1bf81908059ba9b136da28c33714" translate="yes" xml:space="preserve">
          <source>Base-n representations</source>
          <target state="translated">基数代表</target>
        </trans-unit>
        <trans-unit id="0bff1548231bd093df6d8bc4bf7a28a9733d2f0e" translate="yes" xml:space="preserve">
          <source>Based on the above characterization, &amp;ldquo;high-priority&amp;rdquo; changes (i.e. fixing technical inaccuracies, broken links, etc.) can be proposed via pull requests directly as they are straightforward to review. Other changes should be raised as issues first so that the discussion can happen before you make major modifications, which in principle saves you from wasting your time on undesired changes.</source>
          <target state="translated">基于上述特征，可以直接通过拉式请求提出&amp;ldquo;高优先级&amp;rdquo;更改（即，修复技术错误，链接断开等），因为它们很容易检查。首先应提出其他更改，以使讨论可以在您进行重大修改之前进行，从原则上讲，您可以避免浪费时间进行不必要的更改。</target>
        </trans-unit>
        <trans-unit id="da94602e9563f3ceebc2fc5b569a77851b4c7e35" translate="yes" xml:space="preserve">
          <source>Basic &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt;: ~1520ms (benchmarked on 3.1GHz Intel i5.)</source>
          <target state="translated">基本&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;：〜1520ms（在3.1GHz Intel i5上达到基准）。</target>
        </trans-unit>
        <trans-unit id="e6e180bdb3abc214441692c8749fa0f6558a1809" translate="yes" xml:space="preserve">
          <source>Basic Array Flags</source>
          <target state="translated">基本阵列标志</target>
        </trans-unit>
        <trans-unit id="e4e049299abaf782878f7f84544dfdb97d319e23" translate="yes" xml:space="preserve">
          <source>Basic Datetimes</source>
          <target state="translated">基本日期</target>
        </trans-unit>
        <trans-unit id="6081b68b227981c90bce83d2c2beb9f59d79503d" translate="yes" xml:space="preserve">
          <source>Basic Git setup</source>
          <target state="translated">基本的Git设置</target>
        </trans-unit>
        <trans-unit id="7a031fb4b54459f27072c9ee40c4b13ebd94a781" translate="yes" xml:space="preserve">
          <source>Basic Installation</source>
          <target state="translated">基本安装</target>
        </trans-unit>
        <trans-unit id="e5074656d77a5a1b87923975067a88a41f1ac1c1" translate="yes" xml:space="preserve">
          <source>Basic Iteration</source>
          <target state="translated">基本迭代</target>
        </trans-unit>
        <trans-unit id="57a6dc8bc52fe0e5017a1d4e4df961ab713b5b3a" translate="yes" xml:space="preserve">
          <source>Basic Linear Algebra</source>
          <target state="translated">基础线性代数</target>
        </trans-unit>
        <trans-unit id="c7231dfbf12224ef4a3543250815ccb954fcb938" translate="yes" xml:space="preserve">
          <source>Basic Linear Algebra Subprograms</source>
          <target state="translated">基本线性代数子程序</target>
        </trans-unit>
        <trans-unit id="9a85f6e8c6ded273cdb7e38718d85979a45dd77e" translate="yes" xml:space="preserve">
          <source>Basic Operations</source>
          <target state="translated">基本操作</target>
        </trans-unit>
        <trans-unit id="7169d2b21ccd399c4bc0e79bbfdd0bd5c61ee835" translate="yes" xml:space="preserve">
          <source>Basic Slicing and Indexing</source>
          <target state="translated">基本切片和索引</target>
        </trans-unit>
        <trans-unit id="60094894bbbb579bd2f4b96162f9928ec2ce169d" translate="yes" xml:space="preserve">
          <source>Basic Statistics</source>
          <target state="translated">基本统计</target>
        </trans-unit>
        <trans-unit id="b9b6d01ce3d08fc15e9971b8d7ad62d621a90733" translate="yes" xml:space="preserve">
          <source>Basic array operations</source>
          <target state="translated">基本数组操作</target>
        </trans-unit>
        <trans-unit id="bf23a24f7e23fb617c002847d87b0e8162ee99d1" translate="yes" xml:space="preserve">
          <source>Basic customization:</source>
          <target state="translated">基本定制。</target>
        </trans-unit>
        <trans-unit id="4c8d5fdc5db9950cf7bea592d196bad4f803b3fb" translate="yes" xml:space="preserve">
          <source>Basic examples</source>
          <target state="translated">基本例子</target>
        </trans-unit>
        <trans-unit id="beb8cd5e0f8e7a06f8d36dc83c4364f7f79078fa" translate="yes" xml:space="preserve">
          <source>Basic operations</source>
          <target state="translated">基本操作</target>
        </trans-unit>
        <trans-unit id="d6e8bb93c76a2ef8f7afd4a4fc3b007cbfd7ef2c" translate="yes" xml:space="preserve">
          <source>Basic operations are simple with NumPy. If you want to find the sum of the elements in an array, you&amp;rsquo;d use &lt;code&gt;sum()&lt;/code&gt;. This works for 1D arrays, 2D arrays, and arrays in higher dimensions.</source>
          <target state="translated">使用NumPy，基本操作很简单。如果要查找数组中元素的总和，请使用 &lt;code&gt;sum()&lt;/code&gt; 。这适用于1D阵列，2D阵列和较大尺寸的阵列。</target>
        </trans-unit>
        <trans-unit id="2f8920f677fe61e2e2076f058e28c7701ee809c1" translate="yes" xml:space="preserve">
          <source>Basic slicing extends Python&amp;rsquo;s basic concept of slicing to N dimensions. Basic slicing occurs when &lt;em&gt;obj&lt;/em&gt; is a &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt;&lt;code&gt;slice&lt;/code&gt;&lt;/a&gt; object (constructed by &lt;code&gt;start:stop:step&lt;/code&gt; notation inside of brackets), an integer, or a tuple of slice objects and integers. &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#Ellipsis&quot;&gt;&lt;code&gt;Ellipsis&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; objects can be interspersed with these as well.</source>
          <target state="translated">基本切片将Python的基本概念扩展为N个维度。当&lt;em&gt;obj&lt;/em&gt;是一个&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt; &lt;code&gt;slice&lt;/code&gt; &lt;/a&gt;对象（由方括号内的 &lt;code&gt;start:stop:step&lt;/code&gt; 表示法构造），整数或切片对象和整数的元组时，会发生基本切片。&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#Ellipsis&quot;&gt; &lt;code&gt;Ellipsis&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;对象也可以散布在这些对象上。</target>
        </trans-unit>
        <trans-unit id="b900db10ad3fb5583b98ef507ab36ddd8153f435" translate="yes" xml:space="preserve">
          <source>Basic slicing extends Python&amp;rsquo;s basic concept of slicing to N dimensions. Basic slicing occurs when &lt;em&gt;obj&lt;/em&gt; is a &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt;&lt;code&gt;slice&lt;/code&gt;&lt;/a&gt; object (constructed by &lt;code&gt;start:stop:step&lt;/code&gt; notation inside of brackets), an integer, or a tuple of slice objects and integers. &lt;code&gt;Ellipsis&lt;/code&gt; and &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; objects can be interspersed with these as well.</source>
          <target state="translated">基本切片将Python的基本概念扩展为N个维度。当&lt;em&gt;obj&lt;/em&gt;是一个&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt; &lt;code&gt;slice&lt;/code&gt; &lt;/a&gt;对象（由方括号内的 &lt;code&gt;start:stop:step&lt;/code&gt; 表示法构造），整数或切片对象和整数的元组时，会发生基本切片。 &lt;code&gt;Ellipsis&lt;/code&gt; 和&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;对象也可以散布在这些对象上。</target>
        </trans-unit>
        <trans-unit id="b34ccf1a566015b10946e74591046f4136452341" translate="yes" xml:space="preserve">
          <source>Basic slicing with more than one non-&lt;code&gt;:&lt;/code&gt; entry in the slicing tuple, acts like repeated application of slicing using a single non-&lt;code&gt;:&lt;/code&gt; entry, where the non-&lt;code&gt;:&lt;/code&gt; entries are successively taken (with all other non-&lt;code&gt;:&lt;/code&gt; entries replaced by &lt;code&gt;:&lt;/code&gt;). Thus, &lt;code&gt;x[ind1,...,ind2,:]&lt;/code&gt; acts like &lt;code&gt;x[ind1][...,ind2,:]&lt;/code&gt; under basic slicing.</source>
          <target state="translated">切片元组中具有多个non- &lt;code&gt;:&lt;/code&gt; 条目的基本切片，就像使用单个non- &lt;code&gt;:&lt;/code&gt; 条目重复应用切片一样，其中non- &lt;code&gt;:&lt;/code&gt; 条目是连续进行的（所有其他non- &lt;code&gt;:&lt;/code&gt; 条目都由 &lt;code&gt;:&lt;/code&gt; 代替） 。因此，在基本切片下， &lt;code&gt;x[ind1,...,ind2,:]&lt;/code&gt; 作用类似于 &lt;code&gt;x[ind1][...,ind2,:]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de17dd65e3190938ee92ddb98549d2245920a8ee" translate="yes" xml:space="preserve">
          <source>Basic usage is to call &lt;a href=&quot;../reference/c-api/array#c.PyArray_IterNew&quot;&gt;&lt;code&gt;PyArray_IterNew&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;array&lt;/code&gt; ) where array is an ndarray object (or one of its sub-classes). The returned object is an array-iterator object (the same object returned by the .flat attribute of the ndarray). This object is usually cast to PyArrayIterObject* so that its members can be accessed. The only members that are needed are &lt;code&gt;iter-&amp;gt;size&lt;/code&gt; which contains the total size of the array, &lt;code&gt;iter-&amp;gt;index&lt;/code&gt;, which contains the current 1-d index into the array, and &lt;code&gt;iter-&amp;gt;dataptr&lt;/code&gt; which is a pointer to the data for the current element of the array. Sometimes it is also useful to access &lt;code&gt;iter-&amp;gt;ao&lt;/code&gt; which is a pointer to the underlying ndarray object.</source>
          <target state="translated">基本用法是调用&lt;a href=&quot;../reference/c-api/array#c.PyArray_IterNew&quot;&gt; &lt;code&gt;PyArray_IterNew&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;array&lt;/code&gt; ），其中array是ndarray对象（或其子类之一）。返回的对象是一个数组迭代器对象（与ndarray的.flat属性返回的对象相同）。通常将此对象强制转换为PyArrayIterObject *，以便可以访问其成员。唯一需要的成员是 &lt;code&gt;iter-&amp;gt;size&lt;/code&gt; ，它包含数组的总大小； &lt;code&gt;iter-&amp;gt;index&lt;/code&gt; ，它包含数组的当前一 &lt;code&gt;iter-&amp;gt;dataptr&lt;/code&gt; ；以及iter-&amp;gt; dataptr，它是指向数据的指针。数组的当前元素。有时访问 &lt;code&gt;iter-&amp;gt;ao&lt;/code&gt; 也是有用的，它是指向底层ndarray对象的指针。</target>
        </trans-unit>
        <trans-unit id="af837eca09697118dc16afab4a2dc5bfeccd2a15" translate="yes" xml:space="preserve">
          <source>Basic usage. Note how y is the &amp;ldquo;flattened&amp;rdquo; version of [a[:, 0, :], a[:, 1, 0], a[:, 2, :]] since we specified the first iter&amp;rsquo;s axes as [1]</source>
          <target state="translated">基本用法。请注意y是[a [:, 0，：]，a [:, 1，0]，a [:, 2，：]]的&amp;ldquo;展平&amp;rdquo;版本，因为我们将第一个迭代器的轴指定为[1]</target>
        </trans-unit>
        <trans-unit id="189ceeabec801d69e58e27b3296832fd339cfd5c" translate="yes" xml:space="preserve">
          <source>Basic workflow</source>
          <target state="translated">基本工作流程</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="4ce3c1a6b26e31f8d07ec92f4cb05d49b3eec33d" translate="yes" xml:space="preserve">
          <source>Be aware that when NumPy prints N-dimensional arrays, the last axis is looped over the fastest while the first axis is the slowest. For instance:</source>
          <target state="translated">要注意的是,当NumPy打印N维数组时,最后一个轴的循环速度最快,而第一个轴的速度最慢。例如</target>
        </trans-unit>
        <trans-unit id="11716f1e3c0926fa9c04fbb3c924f0811bf4b112" translate="yes" xml:space="preserve">
          <source>Be careful about round-off error!</source>
          <target state="translated">小心四舍五入的错误!</target>
        </trans-unit>
        <trans-unit id="3008b1888d55827508c13f2c0985bc725a03a91e" translate="yes" xml:space="preserve">
          <source>Be careful in the words that we choose. We are careful and respectful in our communication and we take responsibility for our own speech. Be kind to others. Do not insult or put down other participants. We will not accept harassment or other exclusionary behaviour, such as:</source>
          <target state="translated">在我们选择的言语上要谨慎。我们在交流中小心谨慎,尊重他人,对自己的言论负责。要善待他人。不要侮辱或贬低其他参与者。我们不接受骚扰或其他排斥行为,如:。</target>
        </trans-unit>
        <trans-unit id="a95dfdc69ac7b8c496606d6afad271cdcc3a6cdb" translate="yes" xml:space="preserve">
          <source>Be collaborative. Our work will be used by other people, and in turn we will depend on the work of others. When we make something for the benefit of the project, we are willing to explain to others how it works, so that they can build on the work to make it even better. Any decision we make will affect users and colleagues, and we take those consequences seriously when making decisions.</source>
          <target state="translated">要有协作精神。我们的工作会被别人使用,反过来我们也会依赖别人的工作。当我们为了项目的利益而做出一些东西时,我们愿意向其他人解释它是如何工作的,这样他们就可以在工作的基础上把它做得更好。我们所做的任何决定都会影响到用户和同事,我们在做决定的时候会认真考虑这些后果。</target>
        </trans-unit>
        <trans-unit id="ff801bed133a99446534aede438fa2583bcd9e5a" translate="yes" xml:space="preserve">
          <source>Be empathetic, welcoming, friendly, and patient. We work together to resolve conflict, and assume good intentions. We may all experience some frustration from time to time, but we do not allow frustration to turn into a personal attack. A community where people feel uncomfortable or threatened is not a productive one.</source>
          <target state="translated">要有同理心、热情、友好、耐心。我们一起努力解决冲突,并假设好的意图。我们可能都会时常经历一些挫折,但我们不会让挫折变成人身攻击。一个让人感到不舒服或受到威胁的社区是不会有成效的。</target>
        </trans-unit>
        <trans-unit id="3eaab4694464d982dfc3e0a1afc07f0c4449c8cc" translate="yes" xml:space="preserve">
          <source>Be inquisitive. Nobody knows everything! Asking questions early avoids many problems later, so we encourage questions, although we may direct them to the appropriate forum. We will try hard to be responsive and helpful.</source>
          <target state="translated">要有好奇心。没有人什么都知道! 尽早提出问题可以避免以后的许多问题,所以我们鼓励大家提出问题,尽管我们可能会将问题引导到适当的论坛。我们会努力做到有求必应,有问必答。</target>
        </trans-unit>
        <trans-unit id="6a20b0ffbe846eba275eb3ea56da6251c7cd9752" translate="yes" xml:space="preserve">
          <source>Be mindful of the needs of new members: provide them with explicit support and consideration, with the aim of increasing participation from underrepresented groups in particular.</source>
          <target state="translated">铭记新成员的需要:向他们提供明确的支持和考虑,特别是要增加代表不足群体的参与。</target>
        </trans-unit>
        <trans-unit id="1f37a97353eabf9fd15a91dbc5d9f5eb04cea0bf" translate="yes" xml:space="preserve">
          <source>Be mindful that large arrays created with &lt;code&gt;np.empty&lt;/code&gt; or &lt;code&gt;np.zeros&lt;/code&gt; might not be allocated in physical memory until the memory is accessed. If this is desired behaviour, make sure to comment it in your setup function. If you are benchmarking an algorithm, it is unlikely that a user will be executing said algorithm on a newly created empty/zero array. One can force pagefaults to occur in the setup phase either by calling &lt;code&gt;np.ones&lt;/code&gt; or &lt;code&gt;arr.fill(value)&lt;/code&gt; after creating the array,</source>
          <target state="translated">请注意，使用 &lt;code&gt;np.empty&lt;/code&gt; 或 &lt;code&gt;np.zeros&lt;/code&gt; 创建的大型数组可能不会在物理内存中分配，直到访问该内存为止。如果需要这样做，请确保在设置功能中对其进行注释。如果您正在对算法进行基准测试，则用户不太可能在新创建的空/零数组上执行该算法。创建数组后，可以通过调用 &lt;code&gt;np.ones&lt;/code&gt; 或 &lt;code&gt;arr.fill(value)&lt;/code&gt; 来强制页面错误在设置阶段发生，</target>
        </trans-unit>
        <trans-unit id="3730bbeeef610bbf04c76abf5ec330327e101406" translate="yes" xml:space="preserve">
          <source>Be open. We invite anyone to participate in our community. We prefer to use public methods of communication for project-related messages, unless discussing something sensitive. This applies to messages for help or project-related support, too; not only is a public support request much more likely to result in an answer to a question, it also ensures that any inadvertent mistakes in answering are more easily detected and corrected.</source>
          <target state="translated">要开放。我们邀请任何人参与我们的社区。我们更倾向于使用公开的交流方式来处理与项目相关的消息,除非讨论一些敏感的问题。这也适用于寻求帮助或项目相关支持的消息;公开的支持请求不仅更有可能得到问题的回答,还能确保任何无意中的错误回答更容易被发现和纠正。</target>
        </trans-unit>
        <trans-unit id="ac10e1f58e2260e13e0683472d08e8f00358973a" translate="yes" xml:space="preserve">
          <source>Be sure to understand what steps you should take to manage the memory when using these conversion functions. These functions can require freeing memory, and/or altering the reference counts of specific objects based on your use.</source>
          <target state="translated">在使用这些转换函数时,一定要了解你应该采取什么步骤来管理内存。这些函数可能需要释放内存,和/或根据你的使用情况改变特定对象的引用计数。</target>
        </trans-unit>
        <trans-unit id="6e72bb7e156cb39574b057b9674c2412ed422481" translate="yes" xml:space="preserve">
          <source>Be warned that even if &lt;code&gt;np.longdouble&lt;/code&gt; offers more precision than python &lt;code&gt;float&lt;/code&gt;, it is easy to lose that extra precision, since python often forces values to pass through &lt;code&gt;float&lt;/code&gt;. For example, the &lt;code&gt;%&lt;/code&gt; formatting operator requires its arguments to be converted to standard python types, and it is therefore impossible to preserve extended precision even if many decimal places are requested. It can be useful to test your code with the value &lt;code&gt;1 + np.finfo(np.longdouble).eps&lt;/code&gt;.</source>
          <target state="translated">请注意，即使 &lt;code&gt;np.longdouble&lt;/code&gt; 比python &lt;code&gt;float&lt;/code&gt; 提供更高的精度，也容易失去这种额外的精度，因为python通常会迫使值通过 &lt;code&gt;float&lt;/code&gt; 传递。例如， &lt;code&gt;%&lt;/code&gt; 格式运算符要求将其参数转换为标准python类型，因此即使请求了许多小数位，也无法保持扩展的精度。使用值 &lt;code&gt;1 + np.finfo(np.longdouble).eps&lt;/code&gt; 来测试代码可能很有用。</target>
        </trans-unit>
        <trans-unit id="782223c5915f4980a539ed4710dad922b52bef1d" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; is a built-in type (written in C), the &lt;code&gt;__r{op}__&lt;/code&gt; special methods are not directly defined.</source>
          <target state="translated">由于&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;是内置类型（用C编写），因此 &lt;code&gt;__r{op}__&lt;/code&gt; 特殊方法未直接定义。</target>
        </trans-unit>
        <trans-unit id="d79cf7f45add11b370a63146a7703acf9ea33ca1" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;__array_finalize__&lt;/code&gt; is the only method that always sees new instances being created, it is the sensible place to fill in instance defaults for new object attributes, among other tasks.</source>
          <target state="translated">因为 &lt;code&gt;__array_finalize__&lt;/code&gt; 是始终看到新实例创建的唯一方法，所以在其他任务中，它是为新对象属性填写实例默认值的明智之地。</target>
        </trans-unit>
        <trans-unit id="cc46c55e2dfa187c2ac071bbb4bae1702d622519" translate="yes" xml:space="preserve">
          <source>Because Python strings are immutable, an &lt;code&gt;intent(inout)&lt;/code&gt; argument expects an array version of a string in order to have &lt;em&gt;in situ&lt;/em&gt; changes be effective.</source>
          <target state="translated">由于Python字符串是不可变的，因此 &lt;code&gt;intent(inout)&lt;/code&gt; 参数期望字符串的数组版本才能使&lt;em&gt;原位&lt;/em&gt;更改有效。</target>
        </trans-unit>
        <trans-unit id="b4ea4687fdb37cf012f30310b86e8fc32c6c91ad" translate="yes" xml:space="preserve">
          <source>Because access to additional information is so useful, IPython uses the &lt;code&gt;?&lt;/code&gt; character as a shorthand for accessing this documentation along with other relevant information. IPython is a command shell for interactive computing in multiple languages. &lt;a href=&quot;https://ipython.org/&quot;&gt;You can find more information about IPython here&lt;/a&gt;.</source>
          <target state="translated">因为访问附加信息非常有用，所以IPython使用 &lt;code&gt;?&lt;/code&gt; 。字符作为访问此文档以及其他相关信息的简写。IPython是用于多种语言的交互式计算的命令外壳。&lt;a href=&quot;https://ipython.org/&quot;&gt;您可以在此处找到有关IPython的更多信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67d90e5f1ae663c377ee558cca369308548469d2" translate="yes" xml:space="preserve">
          <source>Because exact overlap detection has exponential runtime in the number of dimensions, the decision is made based on heuristics, which has false positives (needless copies in unusual cases) but has no false negatives.</source>
          <target state="translated">因为精确的重叠检测在维度数上有指数级的运行时间,所以根据启发式方法来决定,它有假阳性(异常情况下的无必要拷贝),但没有假阴性。</target>
        </trans-unit>
        <trans-unit id="b6f4af8bef1f35015b148a058f523cde0f4ccc9d" translate="yes" xml:space="preserve">
          <source>Because of how &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; handles sets, the following does not work as expected:</source>
          <target state="translated">由于&lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt;处理集的方式不同，因此以下内容无法正常工作：</target>
        </trans-unit>
        <trans-unit id="4a390a00169642b8c370c2fa0fa4fb8d3ba973c7" translate="yes" xml:space="preserve">
          <source>Because of the difficulty in distributing an extension module made using ctypes, f2py and Cython are still the easiest ways to extend Python for package creation. However, ctypes is in some cases a useful alternative. This should bring more features to ctypes that should eliminate the difficulty in extending Python and distributing the extension using ctypes.</source>
          <target state="translated">由于使用 ctypes 制作的扩展模块很难发布,所以 f2py 和 Cython 仍然是扩展 Python 创建包的最简单的方法。然而,ctypes在某些情况下是一个有用的替代方案。这应该会给ctypes带来更多的功能,应该会消除扩展Python和使用ctypes发布扩展的困难。</target>
        </trans-unit>
        <trans-unit id="74a5855103a7e35a06feda100f69f0d3c37a35c5" translate="yes" xml:space="preserve">
          <source>Because python extensions are not used in the same way as usual libraries on most platforms, some errors cannot be automatically detected at build time or even runtime. For example, if you build an extension using a function available only for numpy &amp;gt;= 1.3.0, and you import the extension later with numpy 1.2, you will not get an import error (but almost certainly a segmentation fault when calling the function). That&amp;rsquo;s why several functions are provided to check for numpy versions. The macros &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt;&lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt;&lt;/a&gt; corresponds to the numpy version used to build the extension, whereas the versions returned by the functions &lt;a href=&quot;#c.PyArray_GetNDArrayCVersion&quot;&gt;&lt;code&gt;PyArray_GetNDArrayCVersion&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.PyArray_GetNDArrayCFeatureVersion&quot;&gt;&lt;code&gt;PyArray_GetNDArrayCFeatureVersion&lt;/code&gt;&lt;/a&gt; corresponds to the runtime numpy&amp;rsquo;s version.</source>
          <target state="translated">由于python扩展在大多数平台上的使用方式与通常的库不同，因此无法在构建时甚至运行时自动检测到某些错误。例如，如果使用仅适用于numpy&amp;gt; = 1.3.0的函数构建扩展，然后在以后使用numpy 1.2导入扩展，则不会出现导入错误（但几乎肯定是在调用该函数时出现分段错误） 。这就是为什么提供了几个函数来检查numpy版本的原因。宏&lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt; &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; &lt;/a&gt;对应于用于构建扩展的numpy版本，而函数&lt;a href=&quot;#c.PyArray_GetNDArrayCVersion&quot;&gt; &lt;code&gt;PyArray_GetNDArrayCVersion&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.PyArray_GetNDArrayCFeatureVersion&quot;&gt; &lt;code&gt;PyArray_GetNDArrayCFeatureVersion&lt;/code&gt; &lt;/a&gt;返回的版本 对应于运行时numpy的版本。</target>
        </trans-unit>
        <trans-unit id="c5a38fa639091b6298538af300d0ae57dcac2792" translate="yes" xml:space="preserve">
          <source>Because python extensions are not used in the same way as usual libraries on most platforms, some errors cannot be automatically detected at build time or even runtime. For example, if you build an extension using a function available only for numpy &amp;gt;= 1.3.0, and you import the extension later with numpy 1.2, you will not get an import error (but almost certainly a segmentation fault when calling the function). That&amp;rsquo;s why several functions are provided to check for numpy versions. The macros &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; corresponds to the numpy version used to build the extension, whereas the versions returned by the functions PyArray_GetNDArrayCVersion and PyArray_GetNDArrayCFeatureVersion corresponds to the runtime numpy&amp;rsquo;s version.</source>
          <target state="translated">由于python扩展在大多数平台上的使用方式与通常的库不同，因此无法在构建时甚至运行时自动检测到某些错误。例如，如果使用仅适用于numpy&amp;gt; = 1.3.0的函数构建扩展，然后在以后使用numpy 1.2导入扩展，则不会出现导入错误（但几乎可以肯定的是，调用该函数时出现分段错误） 。这就是为什么提供了几个函数来检查numpy版本的原因。宏&lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; 对应于用于构建扩展的numpy版本，而函数PyArray_GetNDArrayCVersion和PyArray_GetNDArrayCFeatureVersion返回的版本对应于运行时numpy的版本。</target>
        </trans-unit>
        <trans-unit id="00d51d08a981e99f75ad16b5ac99f6d7fcbcfe04" translate="yes" xml:space="preserve">
          <source>Because the ctypes approach exposes a raw interface to the compiled code it is not always tolerant of user mistakes. Robust use of the ctypes module typically involves an additional layer of Python code in order to check the data types and array bounds of objects passed to the underlying subroutine. This additional layer of checking (not to mention the conversion from ctypes objects to C-data-types that ctypes itself performs), will make the interface slower than a hand-written extension-module interface. However, this overhead should be negligible if the C-routine being called is doing any significant amount of work. If you are a great Python programmer with weak C skills, ctypes is an easy way to write a useful interface to a (shared) library of compiled code.</source>
          <target state="translated">因为 ctypes 方法向编译后的代码暴露了一个原始接口,所以它并不总是能够容忍用户的错误。ctypes 模块的稳健使用通常涉及到额外的 Python 代码层,以便检查传递给底层子程序的对象的数据类型和数组边界。这个额外的检查层 (更不用说 ctypes 本身所执行的从 ctypes 对象到 C-data-types 的转换了),会使这个接口比手工编写的扩展模块接口慢。然而,如果被调用的 C-程序正在做任何大量的工作,这个开销应该可以忽略不计。如果你是一个优秀的Python程序员,但C语言能力较弱,ctypes是一个简单的方法,可以为一个(共享)编译代码库写一个有用的接口。</target>
        </trans-unit>
        <trans-unit id="29dd075a4977fb05332410d8621bf30c67da289c" translate="yes" xml:space="preserve">
          <source>Because the discrete Fourier transform separates its input into components that contribute at discrete frequencies, it has a great number of applications in digital signal processing, e.g., for filtering, and in this context the discretized input to the transform is customarily referred to as a &lt;em&gt;signal&lt;/em&gt;, which exists in the &lt;em&gt;time domain&lt;/em&gt;. The output is called a &lt;em&gt;spectrum&lt;/em&gt; or &lt;em&gt;transform&lt;/em&gt; and exists in the &lt;em&gt;frequency domain&lt;/em&gt;.</source>
          <target state="translated">由于离散傅里叶变换将其输入分为对离散频率有贡献的分量，因此它在数字信号处理（例如用于滤波）中具有大量应用，在这种情况下，变换的离散输入通常称为&lt;em&gt;信号&lt;/em&gt;，它存在于&lt;em&gt;时域中&lt;/em&gt;。输出称为&lt;em&gt;频谱&lt;/em&gt;或&lt;em&gt;变换，&lt;/em&gt;并且存在于&lt;em&gt;频域中&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="9e9097d0b4adb9f9ce14f47bf1a8961a11b5917f" translate="yes" xml:space="preserve">
          <source>Because the output is limited to the range of the C int64 type, a ValueError is raised when &lt;code&gt;lam&lt;/code&gt; is within 10 sigma of the maximum representable value.</source>
          <target state="translated">因为输出限制为C int64类型的范围，所以当 &lt;code&gt;lam&lt;/code&gt; 位于最大可表示值的10 sigma以内时，将引发ValueError 。</target>
        </trans-unit>
        <trans-unit id="fac8d49cb6d5e3c4d76e0475c48ac86177c281c5" translate="yes" xml:space="preserve">
          <source>Because the special treatment of tuples, they are not automatically converted to an array as a list would be. As an example:</source>
          <target state="translated">由于对tuple的特殊处理,它们不会像列表那样自动转换为数组。举个例子。</target>
        </trans-unit>
        <trans-unit id="b9411fa9bcced44864e82d01d766c1a2786cafda" translate="yes" xml:space="preserve">
          <source>Because you shouldn&amp;rsquo;t have done that.</source>
          <target state="translated">因为你不应该那样做。</target>
        </trans-unit>
        <trans-unit id="e66686e9fe82b8c4d1e36e68b32d366de35a5f9f" translate="yes" xml:space="preserve">
          <source>Before beginning, ensure that &lt;em&gt;airspeed velocity&lt;/em&gt; is installed. By default, &lt;code&gt;asv&lt;/code&gt; ships with support for anaconda and virtualenv:</source>
          <target state="translated">开始之前，请确保已安装&lt;em&gt;空速&lt;/em&gt;。默认情况下， &lt;code&gt;asv&lt;/code&gt; 随附对anaconda和virtualenv的支持：</target>
        </trans-unit>
        <trans-unit id="a4352ccd0a83ad23754cd59af6872e1e5131c575" translate="yes" xml:space="preserve">
          <source>Before reading this tutorial you should know a bit of Python. If you would like to refresh your memory, take a look at the &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python tutorial&lt;/a&gt;.</source>
          <target state="translated">在阅读本教程之前，您应该了解一些Python。如果您想刷新内存，请查看&lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python教程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab8362b68d70c7caa9ac18442122ac15a5a21eab" translate="yes" xml:space="preserve">
          <source>Before reading this tutorial, you should know a bit of Python. If you would like to refresh your memory, take a look at the &lt;a href=&quot;https://docs.python.org/dev/tutorial/index.html&quot;&gt;Python tutorial&lt;/a&gt;.</source>
          <target state="translated">在阅读本教程之前，您应该了解一些Python。如果您想刷新内存，请查看&lt;a href=&quot;https://docs.python.org/dev/tutorial/index.html&quot;&gt;Python教程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6701eda483d7c3d519624fb81a0315cb15ec0008" translate="yes" xml:space="preserve">
          <source>Before reading this, it may help to familiarize yourself with the basics of C extensions for Python by reading/skimming the tutorials in Section 1 of &lt;a href=&quot;https://docs.python.org/extending/index.html&quot;&gt;Extending and Embedding the Python Interpreter&lt;/a&gt; and in &lt;a href=&quot;c-info.how-to-extend&quot;&gt;How to extend NumPy&lt;/a&gt;</source>
          <target state="translated">在阅读本文之前，通过阅读/略读&lt;a href=&quot;https://docs.python.org/extending/index.html&quot;&gt;扩展和嵌入Python解释器的&lt;/a&gt;第1节以及&lt;a href=&quot;c-info.how-to-extend&quot;&gt;如何扩展NumPy中&lt;/a&gt;的教程，可能有助于熟悉Python C扩展的基础知识。</target>
        </trans-unit>
        <trans-unit id="32836ad1d5d4d4bb58df8da3afbc677909c61049" translate="yes" xml:space="preserve">
          <source>Before the release branch is made, it should be checked that all deprecated code that should be removed is actually removed, and all new deprecations say in the docstring or deprecation warning at what version the code will be removed.</source>
          <target state="translated">在发布分支之前,应该检查所有应该被删除的废弃代码是否真的被删除了,所有新的废弃代码在docstring或deprecation警告中说,该代码将在什么版本被删除。</target>
        </trans-unit>
        <trans-unit id="6843f140ae464de1cf1062218ac15fdc241e46ba" translate="yes" xml:space="preserve">
          <source>Before you can register a 1-d loop for a ufunc, the ufunc must be previously created. Then you call &lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_RegisterLoopForType&quot;&gt;&lt;code&gt;PyUFunc_RegisterLoopForType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) with the information needed for the loop. The return value of this function is &lt;code&gt;0&lt;/code&gt; if the process was successful and &lt;code&gt;-1&lt;/code&gt; with an error condition set if it was not successful.</source>
          <target state="translated">在为ufunc注册1-d循环之前，必须先创建ufunc。然后，使用循环所需的信息调用&lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_RegisterLoopForType&quot;&gt; &lt;code&gt;PyUFunc_RegisterLoopForType&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）。如果过程成功，则此函数的返回值为 &lt;code&gt;0&lt;/code&gt; ;如果过程不成功，则返回 &lt;code&gt;-1&lt;/code&gt; （设置了错误条件）。</target>
        </trans-unit>
        <trans-unit id="be89e8229b2d83a60fa787b8ef67a25d3d7f1699" translate="yes" xml:space="preserve">
          <source>Begin if possible with the large issues, so the author knows they&amp;rsquo;ve been understood. Resist the temptation to immediately go line by line, or to open with small pervasive issues.</source>
          <target state="translated">如果可能的话，从大问题开始，所以作者知道它们已经被理解。抵制诱惑，以立即行事，或以普遍存在的小问题为开端。</target>
        </trans-unit>
        <trans-unit id="29cee176b513b19c85d7dfdf113b326997fd0f33" translate="yes" xml:space="preserve">
          <source>Behavior when the covariance matrix is not positive semidefinite.</source>
          <target state="translated">当协方差矩阵不是正半定型时的行为。</target>
        </trans-unit>
        <trans-unit id="16b46349029a1f8fc5f5c2e429e2632fc7c9ed5c" translate="yes" xml:space="preserve">
          <source>Behaviors and Errors</source>
          <target state="translated">行为和错误</target>
        </trans-unit>
        <trans-unit id="20b4ea80568cb9ce63d7c954c6894e4b50f0041f" translate="yes" xml:space="preserve">
          <source>Below I&amp;rsquo;ll describe three typical approaches of using F2PY. The following example Fortran 77 code will be used for illustration, save it as fib1.f:</source>
          <target state="translated">下面，我将描述三种使用F2PY的典型方法。以下示例Fortran 77代码将用于说明，将其另存为fib1.f：</target>
        </trans-unit>
        <trans-unit id="252e06d389a00c02f7e08aa374784958db4dd768" translate="yes" xml:space="preserve">
          <source>Below are the public attributes of this object which were documented in &amp;ldquo;Guide to NumPy&amp;rdquo; (we have omitted undocumented public attributes, as well as documented private attributes):</source>
          <target state="translated">以下是在&amp;ldquo; NumPy指南&amp;rdquo;中记录的该对象的公共属性（我们省略了未记录的公共属性以及已记录的私有属性）：</target>
        </trans-unit>
        <trans-unit id="4b6fe750132d00281d0a5b32dae239702c2e48c2" translate="yes" xml:space="preserve">
          <source>Below is a typical usage example: &lt;a href=&quot;#numpy.typing.NBitBase&quot;&gt;&lt;code&gt;NBitBase&lt;/code&gt;&lt;/a&gt; is herein used for annotating a function that takes a float and integer of arbitrary precision as arguments and returns a new float of whichever precision is largest (&lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;np.float16 + np.int64 -&amp;gt; np.float64&lt;/code&gt;).</source>
          <target state="translated">下面是一个典型的用法示例：&lt;a href=&quot;#numpy.typing.NBitBase&quot;&gt; &lt;code&gt;NBitBase&lt;/code&gt; &lt;/a&gt;在此处用于注释一个函数，该函数将浮点数和任意精度的整数作为参数，并返回精度最高的新浮点数（&lt;em&gt;例如&lt;/em&gt; &lt;code&gt;np.float16 + np.int64 -&amp;gt; np.float64&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="94890db1b347a181e379f1b5ca0fad5bcd6b3fc7" translate="yes" xml:space="preserve">
          <source>Below is an example of a minimal &lt;code&gt;setup.py&lt;/code&gt; file for a pure SciPy package:</source>
          <target state="translated">以下是纯SciPy软件包的最小 &lt;code&gt;setup.py&lt;/code&gt; 文件的示例：</target>
        </trans-unit>
        <trans-unit id="525759fddd68e1f874367bb6bfc9a8ba5f573531" translate="yes" xml:space="preserve">
          <source>Below, are several code examples and graphical representations that help make the broadcast rule visually obvious. &lt;a href=&quot;#example-3&quot;&gt;Example 3&lt;/a&gt; adds a one-dimensional array to a two-dimensional array:</source>
          <target state="translated">下面是几个代码示例和图形表示，它们有助于使广播规则在视觉上显而易见。&lt;a href=&quot;#example-3&quot;&gt;示例3&lt;/a&gt;将一维数组添加到二维数组中：</target>
        </trans-unit>
        <trans-unit id="6f3b2ca2746598a5c0c336c60d7f1e5542f3b64a" translate="yes" xml:space="preserve">
          <source>Benchmarking</source>
          <target state="translated">Benchmarking</target>
        </trans-unit>
        <trans-unit id="817dcc8fca981b9f81e80ededa53ee4f0c2fe004" translate="yes" xml:space="preserve">
          <source>Benchmarking NumPy with Airspeed Velocity.</source>
          <target state="translated">用空速速度基准NumPy。</target>
        </trans-unit>
        <trans-unit id="a532923696aa5c8f039ac98c01ebbdc352eb0162" translate="yes" xml:space="preserve">
          <source>Benchmarks are like tests, but have names starting with &amp;ldquo;bench&amp;rdquo; instead of &amp;ldquo;test&amp;rdquo;, and can be found under the &amp;ldquo;benchmarks&amp;rdquo; sub-directory of the module.</source>
          <target state="translated">基准测试类似于测试，但名称以&amp;ldquo;基准&amp;rdquo;而不是&amp;ldquo;测试&amp;rdquo;开头，可以在模块的&amp;ldquo;基准&amp;rdquo;子目录下找到。</target>
        </trans-unit>
        <trans-unit id="9e0aad69f001fa26b773185a06a8bef93c3f6567" translate="yes" xml:space="preserve">
          <source>Bernoulli trials are experiments with one of two outcomes: success or failure (an example of such an experiment is flipping a coin). The geometric distribution models the number of trials that must be run in order to achieve success. It is therefore supported on the positive integers, &lt;code&gt;k = 1, 2, ...&lt;/code&gt;.</source>
          <target state="translated">伯努利试验是具有以下两种结果之一的实验：成功或失败（这种实验的一个例子是掷硬币）。几何分布模型为获得成功而必须运行的试验次数。因此，在正整数 &lt;code&gt;k = 1, 2, ...&lt;/code&gt; 上受支持。</target>
        </trans-unit>
        <trans-unit id="9fb2a7b505b1b75b34095ee2ffe16a241dd5bdfa" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;sys.stdout&lt;/code&gt;, a file-like object can also be used as it has both required methods:</source>
          <target state="translated">除了 &lt;code&gt;sys.stdout&lt;/code&gt; 之外，还可以使用类似文件的对象，因为它具有两种必需的方法：</target>
        </trans-unit>
        <trans-unit id="4e5ba1e315701c442ad54ed60833fcd6227c3ccc" translate="yes" xml:space="preserve">
          <source>Besides creating an array from a sequence of elements, you can easily create an array filled with &lt;code&gt;0&lt;/code&gt;&amp;rsquo;s:</source>
          <target state="translated">除了根据一系列元素创建数组之外，您还可以轻松创建一个由 &lt;code&gt;0&lt;/code&gt; 组成的数组：</target>
        </trans-unit>
        <trans-unit id="feb46c86681950d0f6eb887f4a6fb11b462f9f2e" translate="yes" xml:space="preserve">
          <source>Besides its obvious scientific uses, &lt;em&gt;NumPy&lt;/em&gt; can also be used as an efficient multi-dimensional container of generic data. Arbitrary data types can be defined. This allows &lt;em&gt;NumPy&lt;/em&gt; to seamlessly and speedily integrate with a wide variety of databases.</source>
          <target state="translated">除了其明显的科学用途外，&lt;em&gt;NumPy&lt;/em&gt;还可以用作通用数据的高效多维容器。可以定义任意数据类型。这使&lt;em&gt;NumPy&lt;/em&gt;可以无缝，快速地与各种数据库集成。</target>
        </trans-unit>
        <trans-unit id="ab274f607cf51efd384bd87e6b3a93295c182bec" translate="yes" xml:space="preserve">
          <source>Besides the structural information contained in the strides and dimensions members of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;, the flags contain important information about how the data may be accessed. In particular, the &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set when the memory is on a suitable boundary according to the data-type array. Even if you have a contiguous chunk of memory, you cannot just assume it is safe to dereference a data- type-specific pointer to an element. Only if the &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set is this a safe operation (on some platforms it will work but on others, like Solaris, it will cause a bus error). The &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; should also be ensured if you plan on writing to the memory area of the array. It is also possible to obtain a pointer to an unwritable memory area. Sometimes, writing to the memory area when the &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag is not set will just be rude. Other times it can cause program crashes ( &lt;em&gt;e.g.&lt;/em&gt; a data-area that is a read-only memory-mapped file).</source>
          <target state="translated">除了包含在&lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; 的stride&lt;/a&gt;和Dimensions成员的结构信息之外，这些标志还包含有关如何访问数据的重要信息。尤其是，根据数据类型数组，当存储器位于适当的边界时，将设置&lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;标志。即使您有连续的内存块，也不能仅仅假设取消对元素的数据类型特定的指针的引用是安全的。只有设置了&lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;标志，此操作才是安全的操作（在某些平台上可以运行，但在其他平台上（例如Solaris），它将导致总线错误）。该&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;如果您打算写入阵列的存储区，则还应确保该值。也有可能获得指向不可写存储区的指针。有时，在未设置&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;标志的情况下写入存储区将很粗鲁。有时它可能导致程序崩溃（&lt;em&gt;例如&lt;/em&gt;，数据区域是只读的内存映射文件）。</target>
        </trans-unit>
        <trans-unit id="7552a827553f203cc1e2b5ca99b7201f49328d40" translate="yes" xml:space="preserve">
          <source>Besides the structural information contained in the strides and dimensions members of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;, the flags contain important information about how the data may be accessed. In particular, the &lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set when the memory is on a suitable boundary according to the data-type array. Even if you have a contiguous chunk of memory, you cannot just assume it is safe to dereference a data- type-specific pointer to an element. Only if the &lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set is this a safe operation (on some platforms it will work but on others, like Solaris, it will cause a bus error). The &lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; should also be ensured if you plan on writing to the memory area of the array. It is also possible to obtain a pointer to an unwritable memory area. Sometimes, writing to the memory area when the &lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag is not set will just be rude. Other times it can cause program crashes ( &lt;em&gt;e.g.&lt;/em&gt; a data-area that is a read-only memory-mapped file).</source>
          <target state="translated">除了包含在&lt;a href=&quot;c-api/types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; 的stride&lt;/a&gt;和Dimensions成员的结构信息之外，这些标志还包含有关如何访问数据的重要信息。特别是，根据数据类型数组，当存储器位于合适的边界上时，将设置&lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;标志。即使您有连续的内存块，也不能仅仅假设取消对元素的数据类型特定的指针的引用是安全的。只有设置了&lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;标志，此操作才是安全的操作（在某些平台上可以运行，但在其他平台（如Solaris）上，则会导致总线错误）。该&lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;如果您打算写入阵列的存储区，也应确保该值。也有可能获得指向不可写存储区的指针。有时，在未设置&lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;标志的情况下写入存储区将很不礼貌。有时它可能导致程序崩溃（&lt;em&gt;例如&lt;/em&gt;，数据区域是只读的内存映射文件）。</target>
        </trans-unit>
        <trans-unit id="e1ba37be85f86a4053d7f866745343aa6628b3b0" translate="yes" xml:space="preserve">
          <source>Besides using &lt;code&gt;runtests.py&lt;/code&gt;, there are various ways to run the tests. Inside the interpreter, tests can be run like this:</source>
          <target state="translated">除了使用 &lt;code&gt;runtests.py&lt;/code&gt; 之外，还有多种运行测试的方法。在解释器内部，可以像这样运行测试：</target>
        </trans-unit>
        <trans-unit id="2bf0953ee914f2edfe24d253c99b5774c0b042b9" translate="yes" xml:space="preserve">
          <source>Best choice for unitary and other non-Hermitian normal matrices.</source>
          <target state="translated">单元矩阵和其他非赫米特法线矩阵的最佳选择。</target>
        </trans-unit>
        <trans-unit id="22e034c69c8701c0ed22fdd3834451a1ee6eff5e" translate="yes" xml:space="preserve">
          <source>Best practice for achieving reproducible bit streams is to use the default &lt;code&gt;None&lt;/code&gt; for the initial entropy, and then use &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt;&lt;code&gt;SeedSequence.entropy&lt;/code&gt;&lt;/a&gt; to log/pickle the &lt;a href=&quot;../../entropy#module-numpy.random.entropy&quot;&gt;&lt;code&gt;entropy&lt;/code&gt;&lt;/a&gt; for reproducibility:</source>
          <target state="translated">实现可再现位流的最佳实践是对初始熵使用默认值 &lt;code&gt;None&lt;/code&gt; ，然后使用&lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt; &lt;code&gt;SeedSequence.entropy&lt;/code&gt; &lt;/a&gt;记录/ 刺入&lt;a href=&quot;../../entropy#module-numpy.random.entropy&quot;&gt; &lt;code&gt;entropy&lt;/code&gt; &lt;/a&gt;以实现可再现性：</target>
        </trans-unit>
        <trans-unit id="7670ec2417d2f252a955be33c6c1b4f20bd90718" translate="yes" xml:space="preserve">
          <source>Best practice for achieving reproducible bit streams is to use the default &lt;code&gt;None&lt;/code&gt; for the initial entropy, and then use &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt;&lt;code&gt;SeedSequence.entropy&lt;/code&gt;&lt;/a&gt; to log/pickle the &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt;&lt;code&gt;entropy&lt;/code&gt;&lt;/a&gt; for reproducibility:</source>
          <target state="translated">实现可再现比特流的最佳实践是对初始熵使用默认值 &lt;code&gt;None&lt;/code&gt; ，然后使用&lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt; &lt;code&gt;SeedSequence.entropy&lt;/code&gt; &lt;/a&gt;记录/刺入&lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt; &lt;code&gt;entropy&lt;/code&gt; &lt;/a&gt;以实现可再现性：</target>
        </trans-unit>
        <trans-unit id="ff113b93867eb5d4708dd06e48a11f6662278fd5" translate="yes" xml:space="preserve">
          <source>Beta, positive (&amp;gt;0).</source>
          <target state="translated">Beta，正数（&amp;gt; 0）。</target>
        </trans-unit>
        <trans-unit id="df6d93c232f8ef730e08cac2f842b70dab985fb0" translate="yes" xml:space="preserve">
          <source>Beta: &amp;lsquo;1.8.0b1&amp;rsquo;, &amp;lsquo;1.8.0b2&amp;rsquo;, etc.</source>
          <target state="translated">Beta：&amp;ldquo; 1.8.0b1&amp;rdquo;，&amp;ldquo; 1.8.0b2&amp;rdquo;等</target>
        </trans-unit>
        <trans-unit id="e5c69acc70fda034169d23116e19f5548d61c870" translate="yes" xml:space="preserve">
          <source>Better &lt;code&gt;repr&lt;/code&gt; of object arrays</source>
          <target state="translated">更好 &lt;code&gt;repr&lt;/code&gt; 对象阵列的</target>
        </trans-unit>
        <trans-unit id="71ff91962e9990f86b3c3c6f7d7e56caab72ace4" translate="yes" xml:space="preserve">
          <source>Better behaviour of ufunc identities during reductions</source>
          <target state="translated">在裁减过程中,UFUNC的特性表现更好。</target>
        </trans-unit>
        <trans-unit id="2e8b6f98e6b21c5c6afa9104a0769b9205288f70" translate="yes" xml:space="preserve">
          <source>Better default repr for &lt;code&gt;ndarray&lt;/code&gt; subclasses</source>
          <target state="translated">更好的 &lt;code&gt;ndarray&lt;/code&gt; 子类的默认repr</target>
        </trans-unit>
        <trans-unit id="9c34cb1b69a33b2d347cbab7a352fe546099b5b5" translate="yes" xml:space="preserve">
          <source>Better numerical stability for sum in some cases</source>
          <target state="translated">在某些情况下,和的数值稳定性更好</target>
        </trans-unit>
        <trans-unit id="c1c0df1717608a8779754648098f8f6a8b834b75" translate="yes" xml:space="preserve">
          <source>Better support for &lt;code&gt;const&lt;/code&gt; dimensions in API functions</source>
          <target state="translated">在API函数中更好地支持 &lt;code&gt;const&lt;/code&gt; 维度</target>
        </trans-unit>
        <trans-unit id="9bf8b70bc38b460cf450f48cba644f58d2901785" translate="yes" xml:space="preserve">
          <source>Better support for empty structured and string types</source>
          <target state="translated">更好地支持空结构类型和字符串类型</target>
        </trans-unit>
        <trans-unit id="741240e1ef7d29df48749ede4195530d21b5583c" translate="yes" xml:space="preserve">
          <source>Beyond changes to a functions docstring and possible description in the general documentation, if your change introduces any user-facing modifications they may need to be mentioned in the release notes. To add your change to the release notes, you need to create a short file with a summary and place it in &lt;code&gt;doc/release/upcoming_changes&lt;/code&gt;. The file &lt;code&gt;doc/release/upcoming_changes/README.rst&lt;/code&gt; details the format and filename conventions.</source>
          <target state="translated">除了对功能文档字符串的更改以及通用文档中可能的描述之外，如果您的更改引入了任何面向用户的修改，则可能需要在发行说明中提及它们。要将更改添加到发行说明中，您需要创建一个带有摘要的简短文件，并将其放置在 &lt;code&gt;doc/release/upcoming_changes&lt;/code&gt; 中。文件 &lt;code&gt;doc/release/upcoming_changes/README.rst&lt;/code&gt; 详细说明了格式和文件名约定。</target>
        </trans-unit>
        <trans-unit id="1d7c1c795d86187e8f7208b51b9e4bbd86fa144c" translate="yes" xml:space="preserve">
          <source>Beyond the Basics</source>
          <target state="translated">超越基础</target>
        </trans-unit>
        <trans-unit id="26ffbba2ad335a399beb79e57cd9f0fee4d0bfe1" translate="yes" xml:space="preserve">
          <source>Beyond the Provided Typemaps</source>
          <target state="translated">超越提供的类型图</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="2381a720988421ed44a915283532f745ec598844" translate="yes" xml:space="preserve">
          <source>Binary Format Description</source>
          <target state="translated">二进制格式描述</target>
        </trans-unit>
        <trans-unit id="b26f6c63a335a90adeeab8f4d5013e4f2efe2bec" translate="yes" xml:space="preserve">
          <source>Binary operations</source>
          <target state="translated">二进制操作</target>
        </trans-unit>
        <trans-unit id="e2606828726dd092395e99ae84af2fb16d4bba99" translate="yes" xml:space="preserve">
          <source>Binary operations with non-arrays as second argument</source>
          <target state="translated">以非数组作为第二个参数的二进制操作。</target>
        </trans-unit>
        <trans-unit id="1cc036b4a48151bfca642ff2ead78a54a934983c" translate="yes" xml:space="preserve">
          <source>Binary representation of &lt;code&gt;num&lt;/code&gt; or two&amp;rsquo;s complement of &lt;code&gt;num&lt;/code&gt;.</source>
          <target state="translated">的二进制表示 &lt;code&gt;num&lt;/code&gt; 或补 &lt;code&gt;num&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cc1259e21c7e613999e790394c5c675e22538ae" translate="yes" xml:space="preserve">
          <source>Binary search is used to find the required insertion points.</source>
          <target state="translated">二元搜索是用来寻找所需的插入点。</target>
        </trans-unit>
        <trans-unit id="d16d7bbb9c6ef7dc7a209b9f7f44b9f5da556503" translate="yes" xml:space="preserve">
          <source>Binary serialization</source>
          <target state="translated">二进制序列化</target>
        </trans-unit>
        <trans-unit id="c2fcfedbbaa7680e63fd8ec6b6d6fea722eb952d" translate="yes" xml:space="preserve">
          <source>Binomials</source>
          <target state="translated">Binomials</target>
        </trans-unit>
        <trans-unit id="d12186b0252e4232a8110ba893b738140b658fd0" translate="yes" xml:space="preserve">
          <source>Bit Generators</source>
          <target state="translated">位元发生器</target>
        </trans-unit>
        <trans-unit id="d9ea127fdd4796c75fc01357c967509bff02d70a" translate="yes" xml:space="preserve">
          <source>Bit field (following integer gives the number of bits in the bit field).</source>
          <target state="translated">位域(后面的整数表示位域中的位数)。</target>
        </trans-unit>
        <trans-unit id="4239f8b7894d76bb52c94538f111a8da8d4fb0a0" translate="yes" xml:space="preserve">
          <source>Bit packing</source>
          <target state="translated">比特包装</target>
        </trans-unit>
        <trans-unit id="b80dbb4a253c53f5aa98843beeecc669ef1da4eb" translate="yes" xml:space="preserve">
          <source>Bit-flags describing how this data type is to be interpreted.</source>
          <target state="translated">描述如何解释该数据类型的位标志。</target>
        </trans-unit>
        <trans-unit id="59a321c44dd261b336bb24b8f3a93b2ffcf9ad14" translate="yes" xml:space="preserve">
          <source>Bit-masks are in &lt;code&gt;numpy.core.multiarray&lt;/code&gt; as the constants &lt;code&gt;ITEM_HASOBJECT&lt;/code&gt;, &lt;code&gt;LIST_PICKLE&lt;/code&gt;, &lt;code&gt;ITEM_IS_POINTER&lt;/code&gt;, &lt;code&gt;NEEDS_INIT&lt;/code&gt;, &lt;code&gt;NEEDS_PYAPI&lt;/code&gt;, &lt;code&gt;USE_GETITEM&lt;/code&gt;, &lt;code&gt;USE_SETITEM&lt;/code&gt;. A full explanation of these flags is in C-API documentation; they are largely useful for user-defined data-types.</source>
          <target state="translated">位掩码在 &lt;code&gt;numpy.core.multiarray&lt;/code&gt; 中作为常量 &lt;code&gt;ITEM_HASOBJECT&lt;/code&gt; ， &lt;code&gt;LIST_PICKLE&lt;/code&gt; ， &lt;code&gt;ITEM_IS_POINTER&lt;/code&gt; ， &lt;code&gt;NEEDS_INIT&lt;/code&gt; ， &lt;code&gt;NEEDS_PYAPI&lt;/code&gt; ， &lt;code&gt;USE_GETITEM&lt;/code&gt; ， &lt;code&gt;USE_SETITEM&lt;/code&gt; 。有关这些标志的完整说明，请参见C-API文档。它们对于用户定义的数据类型非常有用。</target>
        </trans-unit>
        <trans-unit id="c6c2f273c5d1a8dcbceea602bbb87c029bbc0d32" translate="yes" xml:space="preserve">
          <source>Bit-twiddling functions</source>
          <target state="translated">捻位功能</target>
        </trans-unit>
        <trans-unit id="460d665e77f8686560c843f72478486336f12a1b" translate="yes" xml:space="preserve">
          <source>Bit-width names</source>
          <target state="translated">位宽名称</target>
        </trans-unit>
        <trans-unit id="7176dd338904b0fc1d2cdf1063572e4e5cbd193a" translate="yes" xml:space="preserve">
          <source>Bit-width references to enumerated typenums</source>
          <target state="translated">对枚举类型单元的位宽引用。</target>
        </trans-unit>
        <trans-unit id="143911730a6c4fbdf6bd766470cddffa24dd0b5c" translate="yes" xml:space="preserve">
          <source>BitGenerator</source>
          <target state="translated">BitGenerator</target>
        </trans-unit>
        <trans-unit id="e1d49785c1daa86c89ab6e63f74767502d9e2cd5" translate="yes" xml:space="preserve">
          <source>BitGenerator (class in numpy.random)</source>
          <target state="translated">比特生成器(numpy.random中的类)</target>
        </trans-unit>
        <trans-unit id="cc03ca2870189a580c7299116633756162b41a61" translate="yes" xml:space="preserve">
          <source>BitGenerator for Chris Doty-Humphrey&amp;rsquo;s Small Fast Chaotic PRNG.</source>
          <target state="translated">克里斯&amp;middot;多蒂-汉弗莱（Chris Doty-Humphrey）的小型快速混沌PRNG的BitGenerator。</target>
        </trans-unit>
        <trans-unit id="218df33e7359786597fc4c2a6c1726e5e91ef2e6" translate="yes" xml:space="preserve">
          <source>BitGenerator for the PCG-64 pseudo-random number generator.</source>
          <target state="translated">用于PCG-64伪随机数生成器的BitGenerator。</target>
        </trans-unit>
        <trans-unit id="9b6bde107d0c3c8164f2b3ab1e4164dad1766298" translate="yes" xml:space="preserve">
          <source>BitGenerator to use as the core generator.</source>
          <target state="translated">BitGenerator作为核心生成器使用。</target>
        </trans-unit>
        <trans-unit id="dbbe08f6d74daba648b1cd173a6a41449071b1bf" translate="yes" xml:space="preserve">
          <source>BitGenerator.random_raw()</source>
          <target state="translated">BitGenerator.random_raw()</target>
        </trans-unit>
        <trans-unit id="ade67fe752c31c985cb01482e4ad03f16cfe18bb" translate="yes" xml:space="preserve">
          <source>BitGenerators: Objects that generate random numbers. These are typically unsigned integer words filled with sequences of either 32 or 64 random bits.</source>
          <target state="translated">BitGenerators。产生随机数的对象。这些通常是无符号整数字,充满了32或64个随机位的序列。</target>
        </trans-unit>
        <trans-unit id="a36a25a1cccb68c7c87fcd879bbb216973e2de75" translate="yes" xml:space="preserve">
          <source>Bits</source>
          <target state="translated">Bits</target>
        </trans-unit>
        <trans-unit id="02f4859e8970806328996752f2ca5818252436db" translate="yes" xml:space="preserve">
          <source>Bits are shifted to the left by appending &lt;code&gt;x2&lt;/code&gt; 0s at the right of &lt;code&gt;x1&lt;/code&gt;. Since the internal representation of numbers is in binary format, this operation is equivalent to multiplying &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;2**x2&lt;/code&gt;.</source>
          <target state="translated">通过在 &lt;code&gt;x1&lt;/code&gt; 的右边附加 &lt;code&gt;x2&lt;/code&gt; 0，将位向左移动。因为数字的内部表示为二进制格式，这种操作相当于乘以 &lt;code&gt;x1&lt;/code&gt; 由 &lt;code&gt;2**x2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d9f79b7b35bc256a0d1b6d4ab01f312eace24eb" translate="yes" xml:space="preserve">
          <source>Bits are shifted to the right &lt;code&gt;x2&lt;/code&gt;. Because the internal representation of numbers is in binary format, this operation is equivalent to dividing &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;2**x2&lt;/code&gt;.</source>
          <target state="translated">位向右移 &lt;code&gt;x2&lt;/code&gt; 。因为数字的内部表示是二进制格式，所以此操作等效于将 &lt;code&gt;x1&lt;/code&gt; 除以 &lt;code&gt;2**x2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb86c6c99db380b9a785bd4e060a6f5dc41e87fd" translate="yes" xml:space="preserve">
          <source>Bits set for the object data-type: ( &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt;&lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_USE_GETITEM&quot;&gt;&lt;code&gt;NPY_USE_GETITEM&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_IS_POINTER&quot;&gt;&lt;code&gt;NPY_ITEM_IS_POINTER&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt;&lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt;&lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt;&lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">为对象数据类型设置的位：（&lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt; &lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_USE_GETITEM&quot;&gt; &lt;code&gt;NPY_USE_GETITEM&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_IS_POINTER&quot;&gt; &lt;code&gt;NPY_ITEM_IS_POINTER&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt; &lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt; &lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt; &lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="117a063b0a577c59c490f864292bca239247279f" translate="yes" xml:space="preserve">
          <source>Bits set for the object data-type: ( &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt;&lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_USE_GETITEM&quot;&gt;&lt;code&gt;NPY_USE_GETITEM&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_IS_POINTER&quot;&gt;&lt;code&gt;NPY_ITEM_IS_POINTER&lt;/code&gt;&lt;/a&gt; | &lt;code&gt;NPY_REFCOUNT&lt;/code&gt; | &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt;&lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt;&lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">为对象数据类型设置的位：（&lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt; &lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_USE_GETITEM&quot;&gt; &lt;code&gt;NPY_USE_GETITEM&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_IS_POINTER&quot;&gt; &lt;code&gt;NPY_ITEM_IS_POINTER&lt;/code&gt; &lt;/a&gt; | &lt;code&gt;NPY_REFCOUNT&lt;/code&gt; | &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt; &lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt; &lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="13031923c83ade827195c6241750d4615a698b51" translate="yes" xml:space="preserve">
          <source>Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra, Dover Publications, New York.</source>
          <target state="translated">Blackman,R.B.and Tukey,J.W.,(1958)The measurement of power spectra,Dover Publications,New York.</target>
        </trans-unit>
        <trans-unit id="348cdf7ff3c8eec7d1cd1aa8880558948fba2435" translate="yes" xml:space="preserve">
          <source>Blocks can be of any dimension, but will not be broadcasted using the normal rules. Instead, leading axes of size 1 are inserted, to make &lt;code&gt;block.ndim&lt;/code&gt; the same for all blocks. This is primarily useful for working with scalars, and means that code like &lt;code&gt;np.block([v, 1])&lt;/code&gt; is valid, where &lt;code&gt;v.ndim == 1&lt;/code&gt;.</source>
          <target state="translated">块可以是任何尺寸，但不会使用常规规则进行广播。而是插入大小为1的引导轴，以使 &lt;code&gt;block.ndim&lt;/code&gt; 对于所有块均相同。这对于处理标量主要有用，并且意味着像 &lt;code&gt;np.block([v, 1])&lt;/code&gt; 这样的代码是有效的，其中 &lt;code&gt;v.ndim == 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8994034796d9ec39a7933eb34371fad5f6ce9920" translate="yes" xml:space="preserve">
          <source>Blocks in the innermost lists are concatenated (see &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;) along the last dimension (-1), then these are concatenated along the second-last dimension (-2), and so on until the outermost list is reached.</source>
          <target state="translated">最里面的列表中的块沿最后一个维度（-1）串联（请参阅&lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt;），然后沿着倒数第二个维度（-2）进行串联，依此类推，直到到达最外面的列表。</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="317be1616a174c84304de299b4ead5ef76ce4a76" translate="yes" xml:space="preserve">
          <source>Boolean (True or False) stored as a byte</source>
          <target state="translated">以字节形式存储的布尔值(真或假)。</target>
        </trans-unit>
        <trans-unit id="71383121b53c1c9facdaaabc47b0de18549c5c80" translate="yes" xml:space="preserve">
          <source>Boolean (integer type where all values are only True or False)</source>
          <target state="translated">布尔型(整数型,所有值只有真或假)</target>
        </trans-unit>
        <trans-unit id="c7a0fd639a6581c56ba10f492adee6f212cd45b8" translate="yes" xml:space="preserve">
          <source>Boolean 1-d array selecting which entries to return. If len(condition) is less than the size of a along the axis, then output is truncated to length of condition array.</source>
          <target state="translated">布尔型1-d数组,选择要返回的条目。如果len(condition)沿轴线小于a的大小,那么输出将被截断到condition数组的长度。</target>
        </trans-unit>
        <trans-unit id="87962449a461c8ec49f5151d2bbb30e7a462a28e" translate="yes" xml:space="preserve">
          <source>Boolean array indexing</source>
          <target state="translated">布尔阵列索引</target>
        </trans-unit>
        <trans-unit id="60d82fac26a05eb411b70101c41bd3047454cb5f" translate="yes" xml:space="preserve">
          <source>Boolean array indices with mismatching shapes now properly give &lt;code&gt;IndexError&lt;/code&gt;</source>
          <target state="translated">形状不匹配的布尔数组索引现在可以正确地提供 &lt;code&gt;IndexError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c1aefe73a2b6727a0e572007771ddec686a6bb1f" translate="yes" xml:space="preserve">
          <source>Boolean array of same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;x&lt;/code&gt; 形状相同的布尔数组。</target>
        </trans-unit>
        <trans-unit id="233d1fbe1852dc657d35dfe3cd279e3947a9a911" translate="yes" xml:space="preserve">
          <source>Boolean arrays used as indices are treated in a different manner entirely than index arrays. Boolean arrays must be of the same shape as the initial dimensions of the array being indexed. In the most straightforward case, the boolean array has the same shape:</source>
          <target state="translated">用作索引的布尔数组与索引数组的处理方式完全不同。布尔数组的形状必须与被索引数组的初始维度相同。在最直接的情况下,布尔数组具有相同的形状。</target>
        </trans-unit>
        <trans-unit id="98073379b648edd4cbe725ce47f959a6d23058d4" translate="yes" xml:space="preserve">
          <source>Boolean indexing changes</source>
          <target state="translated">布尔索引变化</target>
        </trans-unit>
        <trans-unit id="639386fbce5315b91a1c655018a3b9643e9bcfef" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the byte order of this dtype is native to the platform.</source>
          <target state="translated">表示该dtype的字节顺序是否为平台本地的布尔值。</target>
        </trans-unit>
        <trans-unit id="0c76417c3c3c65ffeed61396388e3db4b8c19de6" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the dtype is a struct which maintains field alignment.</source>
          <target state="translated">表示dtype是否为保持字段对齐的结构的布尔值。</target>
        </trans-unit>
        <trans-unit id="dad1680b2705f6d7f6eeec97cbb513a4e1699f09" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the dtype is a struct which maintains field alignment. This flag is sticky, so when combining multiple structs together, it is preserved and produces new dtypes which are also aligned.</source>
          <target state="translated">表示dtype是否是一个保持字段对齐的结构的布尔值。这个标志是粘性的,所以当把多个结构组合在一起时,它将被保留,并产生同样对齐的新dtype。</target>
        </trans-unit>
        <trans-unit id="36f2224ace3c78a988e50bdc966ac649a4d3fc0b" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether this dtype contains any reference-counted objects in any fields or sub-dtypes.</source>
          <target state="translated">表示该dtype是否在任何字段或子类型中包含任何引用计数对象的布尔值。</target>
        </trans-unit>
        <trans-unit id="398d7e2271209225ea68a985a7b2fa72caeee3a6" translate="yes" xml:space="preserve">
          <source>Boolean mask array. It has to be the same shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">布尔掩码数组。它必须是相同的形状作为 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59815579c0e1a982c330b63fe4d4075e4fd81815" translate="yes" xml:space="preserve">
          <source>Boolean mask array. Must have the same size as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">布尔掩码数组。必须有大小相同的 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30d9ef559552bdd87313d89c8796d8136275e739" translate="yes" xml:space="preserve">
          <source>Boolean operations</source>
          <target state="translated">布尔运算</target>
        </trans-unit>
        <trans-unit id="0d747f327c87280779ba3eb08a42ad6dc25e090e" translate="yes" xml:space="preserve">
          <source>Boolean or &amp;ldquo;mask&amp;rdquo; index arrays</source>
          <target state="translated">布尔或&amp;ldquo;掩码&amp;rdquo;索引数组</target>
        </trans-unit>
        <trans-unit id="dd5ec2e25bdf5818c59dcd317ab96e5a1ea9111e" translate="yes" xml:space="preserve">
          <source>Boolean result of check whether &lt;code&gt;rep&lt;/code&gt; is a scalar dtype.</source>
          <target state="translated">检查 &lt;code&gt;rep&lt;/code&gt; 是否为标量dtype的布尔结果。</target>
        </trans-unit>
        <trans-unit id="e4ae3e1eb416ce7ddaa17364adbe02e871496027" translate="yes" xml:space="preserve">
          <source>Boolean result of the logical AND operation applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;; the shape is determined by broadcasting. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">应用于 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 元素的逻辑AND运算的布尔结果; 形状由广播决定。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="80129c87ec19d7266b12fa62c898f1de8e697318" translate="yes" xml:space="preserve">
          <source>Boolean result of the logical OR operation applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;; the shape is determined by broadcasting. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">应用于 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 元素的逻辑或运算的布尔结果; 形状由广播决定。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="efce76e1529f243bc75f6c85e1cb168b94a21ce6" translate="yes" xml:space="preserve">
          <source>Boolean result of the logical XOR operation applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;; the shape is determined by broadcasting. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">逻辑xor运算的布尔结果应用于 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 的元素; 形状由广播决定。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="e598e8b30eff8ac988c047694ee54841654f4531" translate="yes" xml:space="preserve">
          <source>Boolean result with the same shape as &lt;code&gt;x&lt;/code&gt; of the NOT operation on elements of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">与 &lt;code&gt;x&lt;/code&gt; 元素上的NOT运算的 &lt;code&gt;x&lt;/code&gt; 形状相同的布尔结果。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="b93268f3c2db16861f90ecc22ed53005b764061c" translate="yes" xml:space="preserve">
          <source>Boolean type (True or False), stored as a byte.</source>
          <target state="translated">布尔类型(真或假),以字节形式存储。</target>
        </trans-unit>
        <trans-unit id="4cfb7a503c91815ccbf2f35210fcd3eadc71e7eb" translate="yes" xml:space="preserve">
          <source>Booleans are accepted as well:</source>
          <target state="translated">布尔汉也是可以接受的。</target>
        </trans-unit>
        <trans-unit id="fff8683eb97daf0f7f34cfbaabaadf811d8b8133" translate="yes" xml:space="preserve">
          <source>Booleans:</source>
          <target state="translated">Booleans:</target>
        </trans-unit>
        <trans-unit id="37cb1b945ecb9b619ea4147615565076f43e7b81" translate="yes" xml:space="preserve">
          <source>Boost Python</source>
          <target state="translated">Boost Python</target>
        </trans-unit>
        <trans-unit id="80eb86696c9c70e3e908a024dfe4075dae3951c7" translate="yes" xml:space="preserve">
          <source>Boost is a repository of C++ libraries and Boost.Python is one of those libraries which provides a concise interface for binding C++ classes and functions to Python. The amazing part of the Boost.Python approach is that it works entirely in pure C++ without introducing a new syntax. Many users of C++ report that Boost.Python makes it possible to combine the best of both worlds in a seamless fashion. I have not used Boost.Python because I am not a big user of C++ and using Boost to wrap simple C-subroutines is usually over-kill. It&amp;rsquo;s primary purpose is to make C++ classes available in Python. So, if you have a set of C++ classes that need to be integrated cleanly into Python, consider learning about and using Boost.Python.</source>
          <target state="translated">Boost是C ++库的存储库，而Boost.Python是其中的一个库，它提供了简洁的接口来将C ++类和函数绑定到Python。 Boost.Python方法令人惊奇的部分是它完全在纯C ++中工作，而没有引入新的语法。 C ++的许多用户报告说，Boost.Python可以无缝地结合两个方面的优点。我没有使用Boost.Python，因为我不是C ++的大用户，而使用Boost来包装简单的C子例程通常是多余的。它的主要目的是使C ++类在Python中可用。因此，如果您有一组C ++类需要干净地集成到Python中，请考虑学习和使用Boost.Python。</target>
        </trans-unit>
        <trans-unit id="3d9f5c6c1605197a54538b1a42018d968a659108" translate="yes" xml:space="preserve">
          <source>Boost.Python</source>
          <target state="translated">Boost.Python</target>
        </trans-unit>
        <trans-unit id="35f319efb34e1e345510a06307dd059dbed15ac2" translate="yes" xml:space="preserve">
          <source>Boost.python</source>
          <target state="translated">Boost.python</target>
        </trans-unit>
        <trans-unit id="6a6c7de0b010d58cd0f9cb5716158db428b24bc0" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; must be 0-d or 1-d (ndim = 0 or 1), but &lt;code&gt;u.ndim&lt;/code&gt; need not equal &lt;code&gt;v.ndim&lt;/code&gt;. In other words, all four possible combinations - &lt;code&gt;u.ndim = v.ndim = 0&lt;/code&gt;, &lt;code&gt;u.ndim = v.ndim = 1&lt;/code&gt;, &lt;code&gt;u.ndim = 1, v.ndim = 0&lt;/code&gt;, and &lt;code&gt;u.ndim = 0, v.ndim = 1&lt;/code&gt; - work.</source>
          <target state="translated">既 &lt;code&gt;u&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 必须是0-d或1-d（NDIM = 0或1），但 &lt;code&gt;u.ndim&lt;/code&gt; 需要不等于 &lt;code&gt;v.ndim&lt;/code&gt; 。换句话说，所有四个可能的组合 &lt;code&gt;u.ndim = v.ndim = 0&lt;/code&gt; ， &lt;code&gt;u.ndim = v.ndim = 1&lt;/code&gt; ， &lt;code&gt;u.ndim = 1, v.ndim = 0&lt;/code&gt; 和 &lt;code&gt;u.ndim = 0, v.ndim = 1&lt;/code&gt; 工作。</target>
        </trans-unit>
        <trans-unit id="88f65d9e2d112f1a7a284a45eccfdccc621dc60d" translate="yes" xml:space="preserve">
          <source>Both C-ordering (&amp;ldquo;last dimension fastest&amp;rdquo;) or Fortran-ordering (&amp;ldquo;first dimension fastest&amp;rdquo;) support for 2D, 3D and 4D arrays.</source>
          <target state="translated">C排序（&amp;ldquo;最后一维最快&amp;rdquo;）或Fortran排序（&amp;ldquo;第一维最快&amp;rdquo;）都支持2D，3D和4D阵列。</target>
        </trans-unit>
        <trans-unit id="3720a76c9cc3b6258ee484172d090cd5b19b7e16" translate="yes" xml:space="preserve">
          <source>Both CTypes and CFFI allow the more complicated distributions to be used directly in Numba after compiling the file distributions.c into a &lt;code&gt;DLL&lt;/code&gt; or &lt;code&gt;so&lt;/code&gt;. An example showing the use of a more complicated distribution is in the &lt;code&gt;examples&lt;/code&gt; section below.</source>
          <target state="translated">两者的ctypes和CFFI允许更复杂的分布直接在Numba编译文件distributions.c成后使用 &lt;code&gt;DLL&lt;/code&gt; 或 &lt;code&gt;so&lt;/code&gt; 。下面的 &lt;code&gt;examples&lt;/code&gt; 部分中显示了一个使用更复杂发行版的示例。</target>
        </trans-unit>
        <trans-unit id="6876b038e6598420047feff6385d214f7a9456e4" translate="yes" xml:space="preserve">
          <source>Both CTypes and CFFI allow the more complicated distributions to be used directly in Numba after compiling the file distributions.c into a DLL or so. An example showing the use of a more complicated distribution is in the examples folder.</source>
          <target state="translated">CTypes和CFFI都允许在将distributions.c文件编译成DLL之类的文件后,直接在Numba中使用更复杂的分布式。在examples文件夹中,有一个例子展示了如何使用更复杂的分布式。</target>
        </trans-unit>
        <trans-unit id="9b2e6b498660f219d33da75fb672071ec22d0de1" translate="yes" xml:space="preserve">
          <source>Both arguments must be convertible to data-type objects with the same total size.</source>
          <target state="translated">两个参数都必须可以转换为总大小相同的数据类型对象。</target>
        </trans-unit>
        <trans-unit id="25024cfe43b48611add0d26f273e9fb8f30c82d0" translate="yes" xml:space="preserve">
          <source>Both for indexing:</source>
          <target state="translated">既为索引。</target>
        </trans-unit>
        <trans-unit id="9c58adbe49cf294225a6b4d010fdfff04815b05a" translate="yes" xml:space="preserve">
          <source>Both of these routines multiply an &lt;em&gt;n&lt;/em&gt; -length array, &lt;em&gt;seq&lt;/em&gt;, of integers and return the result. No overflow checking is performed.</source>
          <target state="translated">这两个例程都将一个&lt;em&gt;n&lt;/em&gt;长度的整数&lt;em&gt;seq&lt;/em&gt;乘以整数并返回结果。不执行溢出检查。</target>
        </trans-unit>
        <trans-unit id="e7d4dd33376799dad2f66b13833f7382c04f91d5" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;names&lt;/code&gt; and &lt;code&gt;fields&lt;/code&gt; attributes will equal &lt;code&gt;None&lt;/code&gt; for unstructured arrays. The recommended way to test if a dtype is structured is with &lt;code&gt;if dt.names is not None&lt;/code&gt; rather than &lt;code&gt;if dt.names&lt;/code&gt;, to account for dtypes with 0 fields.</source>
          <target state="translated">对于非结构化数组， &lt;code&gt;names&lt;/code&gt; 和 &lt;code&gt;fields&lt;/code&gt; 属性都将等于&amp;ldquo; &lt;code&gt;None&lt;/code&gt; &amp;rdquo;。推荐的测试 &lt;code&gt;if dt.names is not None&lt;/code&gt; 是否结构化的方法是使用dt.names不为None而不是 &lt;code&gt;if dt.names&lt;/code&gt; 来解决具有0字段的dtype。</target>
        </trans-unit>
        <trans-unit id="a5df7074d510c649a42e62d1e6b7c4d94875f1b9" translate="yes" xml:space="preserve">
          <source>Both the C and Fortran orders are &lt;a href=&quot;../glossary#term-contiguous&quot;&gt;contiguous&lt;/a&gt;, &lt;em&gt;i.e.,&lt;/em&gt; single-segment, memory layouts, in which every part of the memory block can be accessed by some combination of the indices.</source>
          <target state="translated">C和Fortran顺序都是&lt;a href=&quot;../glossary#term-contiguous&quot;&gt;连续的&lt;/a&gt;，&lt;em&gt;即&lt;/em&gt;单段内存布局，其中可以通过索引的某种组合来访问内存块的每个部分。</target>
        </trans-unit>
        <trans-unit id="6a9d7b7663daf24925c25758270cb4610491dfdf" translate="yes" xml:space="preserve">
          <source>Both the C and Fortran orders are &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-contiguous&quot;&gt;contiguous&lt;/a&gt;, &lt;em&gt;i.e.,&lt;/em&gt; single-segment, memory layouts, in which every part of the memory block can be accessed by some combination of the indices.</source>
          <target state="translated">C和Fortran顺序都是&lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-contiguous&quot;&gt;连续的&lt;/a&gt;，&lt;em&gt;即&lt;/em&gt;单段内存布局，其中可以通过索引的某种组合来访问内存块的每个部分。</target>
        </trans-unit>
        <trans-unit id="d093ba37f9ce9c9f30f8fca73c109507dfcb0225" translate="yes" xml:space="preserve">
          <source>Both the Frobenius and nuclear norm orders are only defined for matrices and raise a ValueError when &lt;code&gt;x.ndim != 2&lt;/code&gt;.</source>
          <target state="translated">Frobenius和核规范阶都只为矩阵定义，并且在 &lt;code&gt;x.ndim != 2&lt;/code&gt; 时引发ValueError 。</target>
        </trans-unit>
        <trans-unit id="ffea5bc12b4c544392f03bcbcae76a932ec7e9d3" translate="yes" xml:space="preserve">
          <source>Both vectors with dimension 2.</source>
          <target state="translated">都是维度为2的向量。</target>
        </trans-unit>
        <trans-unit id="ee63b82109d9ff030ecbe37ab04ceac7db2412e8" translate="yes" xml:space="preserve">
          <source>Breaking long lines: if you can, break after commas in the outermost argument list. Always indent continuation lines appropriately, e.g.,</source>
          <target state="translated">打破长行:如果可以,在最外层的参数列表中用逗号打破。始终适当地缩进续行,例如:。</target>
        </trans-unit>
        <trans-unit id="bd6b304289af9581af2ffeee2445279337f31f30" translate="yes" xml:space="preserve">
          <source>Brighton Webs Ltd., &amp;ldquo;Rayleigh Distribution,&amp;rdquo; &lt;a href=&quot;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&quot;&gt;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&lt;/a&gt;</source>
          <target state="translated">Brighton Webs Ltd。，&amp;ldquo; Rayleigh Distribution&amp;rdquo;，&lt;a href=&quot;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&quot;&gt;https：&lt;/a&gt; //web.archive.org/web/20090514091424/http：//brighton-webs.co.uk：80 / distributions / rayleigh.asp</target>
        </trans-unit>
        <trans-unit id="f95280aadb50a5d76ebefb36fbe813c4a9ec99eb" translate="yes" xml:space="preserve">
          <source>Brighton Webs Ltd., Wald Distribution, &lt;a href=&quot;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&quot;&gt;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&lt;/a&gt;</source>
          <target state="translated">Brighton Webs Ltd.，Wald Distribution，&lt;a href=&quot;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&quot;&gt;https:&lt;/a&gt; //web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp</target>
        </trans-unit>
        <trans-unit id="8d469ff5df319fd73b1f4431adc89a3cb7f9bc26" translate="yes" xml:space="preserve">
          <source>Broadcast an array to a new shape</source>
          <target state="translated">将一个数组广播成一个新的形状</target>
        </trans-unit>
        <trans-unit id="73facd5bb35116bed91fa4d11828ee34122a7818" translate="yes" xml:space="preserve">
          <source>Broadcast an array to a new shape.</source>
          <target state="translated">将一个数组广播成一个新的形状。</target>
        </trans-unit>
        <trans-unit id="335cb5d296e07dc61fd4677d50111abd1712ceae" translate="yes" xml:space="preserve">
          <source>Broadcast any number of arrays against each other.</source>
          <target state="translated">互相广播任意数量的数组。</target>
        </trans-unit>
        <trans-unit id="98d4c99349e07c3606d8247f67b6a69bf991b037" translate="yes" xml:space="preserve">
          <source>Broadcast the input parameters against one another, and return an object that encapsulates the result. Amongst others, it has &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;nd&lt;/code&gt; properties, and may be used as an iterator.</source>
          <target state="translated">相互广播输入参数，并返回一个封装结果的对象。其中，它具有 &lt;code&gt;shape&lt;/code&gt; 和 &lt;code&gt;nd&lt;/code&gt; 属性，可以用作迭代器。</target>
        </trans-unit>
        <trans-unit id="a82937f02ff3220ad370539cf8e7b1333cdbe7e9" translate="yes" xml:space="preserve">
          <source>Broadcast the input shapes into a single shape.</source>
          <target state="translated">将输入的形状广播成一个形状。</target>
        </trans-unit>
        <trans-unit id="6bb1c7bbc547d77034be314540af70ac8dab269b" translate="yes" xml:space="preserve">
          <source>Broadcasted shape.</source>
          <target state="translated">广播的形状。</target>
        </trans-unit>
        <trans-unit id="ba459229366746c447e3cdf752eb917433152cfe" translate="yes" xml:space="preserve">
          <source>Broadcasting</source>
          <target state="translated">Broadcasting</target>
        </trans-unit>
        <trans-unit id="2d4bd5e0675f1aedc285134fe7e6bea24d68a36e" translate="yes" xml:space="preserve">
          <source>Broadcasting (multi-iterators)</source>
          <target state="translated">广播(多中继器)</target>
        </trans-unit>
        <trans-unit id="5e308728b0383411510cb3c77af8cc43a178e5fc" translate="yes" xml:space="preserve">
          <source>Broadcasting Array Iteration</source>
          <target state="translated">广播阵列迭代</target>
        </trans-unit>
        <trans-unit id="ffca602e6975476928a035e0bd899a364b765bab" translate="yes" xml:space="preserve">
          <source>Broadcasting allows universal functions to deal in a meaningful way with inputs that do not have exactly the same shape.</source>
          <target state="translated">广播允许通用函数以有意义的方式处理形状不完全相同的输入。</target>
        </trans-unit>
        <trans-unit id="3f1a8f806c9ec4c20408d10522361491e36b1938" translate="yes" xml:space="preserve">
          <source>Broadcasting and scalar multiplication:</source>
          <target state="translated">广播和标量乘法。</target>
        </trans-unit>
        <trans-unit id="9c4c6b372f00f9bbc9735f2491e20986adab213c" translate="yes" xml:space="preserve">
          <source>Broadcasting comes up quite often in real world problems. A typical example occurs in the vector quantization (VQ) algorithm used in information theory, classification, and other related areas. The basic operation in VQ [#f0] finds the closest point in a set of points, called codes in VQ jargon, to a given point, called the observation. In the very simple, two-dimensional case shown in &lt;a href=&quot;#figure-5&quot;&gt;Figure 5&lt;/a&gt;, the values in observation describe the weight and height of an athlete to be classified. The codes represent different classes of athletes. &lt;a href=&quot;#f1&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; Finding the closest point requires calculating the distance between observation and each of the codes. The shortest distance provides the best match. In this example, &lt;code&gt;codes[0]&lt;/code&gt; is the closest class indicating that the athlete is likely a basketball player.</source>
          <target state="translated">在现实世界中，广播经常出现。一个典型的例子发生在信息理论，分类和其他相关领域中使用的矢量量化（VQ）算法中。 VQ [＃f0]中的基本操作是在一组点中找到最接近给定点（称为观测）的点（在VQ术语中称为代码）。在&lt;a href=&quot;#figure-5&quot;&gt;图5&lt;/a&gt;所示的非常简单的二维情况下，观察值描述了要分类的运动员的体重和身高。该代码代表不同类别的运动员。&lt;a href=&quot;#f1&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt;找到最接近的点需要计算观测值与每个代码之间的距离。最短的距离提供最佳的匹配。在此示例中， &lt;code&gt;codes[0]&lt;/code&gt; 是最接近的类别，表明运动员可能是篮球运动员。</target>
        </trans-unit>
        <trans-unit id="3086582d38372be76fcd6867986780678b3bdbd6" translate="yes" xml:space="preserve">
          <source>Broadcasting is conventional for stacks of arrays</source>
          <target state="translated">广播是传统的堆栈阵列。</target>
        </trans-unit>
        <trans-unit id="60a524b775e11155b5c4df4747f272a28d6e6176" translate="yes" xml:space="preserve">
          <source>Broadcasting is the term used to describe the implicit element-by-element behavior of operations; generally speaking, in NumPy all operations, not just arithmetic operations, but logical, bit-wise, functional, etc., behave in this implicit element-by-element fashion, i.e., they broadcast. Moreover, in the example above, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; could be multidimensional arrays of the same shape, or a scalar and an array, or even two arrays of with different shapes, provided that the smaller array is &amp;ldquo;expandable&amp;rdquo; to the shape of the larger in such a way that the resulting broadcast is unambiguous. For detailed &amp;ldquo;rules&amp;rdquo; of broadcasting see &lt;a href=&quot;basics.broadcasting#module-numpy.doc.broadcasting&quot;&gt;&lt;code&gt;numpy.doc.broadcasting&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">广播是用于描述操作的隐式逐元素行为的术语。一般而言，在NumPy中，所有运算，不仅是算术运算，而且是逻辑，按位，函数等，均以这种逐个元素的隐式方式运行，即它们广播。此外，在上面的示例中， &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 可以是相同形状的多维数组，也可以是标量和数组，甚至可以是形状不同的两个数组，条件是较小的数组可以&amp;ldquo;扩展&amp;rdquo;到较大的形状以这样的方式使得最终的广播是明确的。有关广播的详细&amp;ldquo;规则&amp;rdquo;，请参见&lt;a href=&quot;basics.broadcasting#module-numpy.doc.broadcasting&quot;&gt; &lt;code&gt;numpy.doc.broadcasting&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f8bfce10b38e0298dd7b485ac126daa93a79456" translate="yes" xml:space="preserve">
          <source>Broadcasting is the term used to describe the implicit element-by-element behavior of operations; generally speaking, in NumPy all operations, not just arithmetic operations, but logical, bit-wise, functional, etc., behave in this implicit element-by-element fashion, i.e., they broadcast. Moreover, in the example above, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; could be multidimensional arrays of the same shape, or a scalar and an array, or even two arrays of with different shapes, provided that the smaller array is &amp;ldquo;expandable&amp;rdquo; to the shape of the larger in such a way that the resulting broadcast is unambiguous. For detailed &amp;ldquo;rules&amp;rdquo; of broadcasting see &lt;code&gt;basics.broadcasting&lt;/code&gt;.</source>
          <target state="translated">广播是一个术语，用于描述操作的隐式逐元素行为；一般而言，在NumPy中，所有运算，不仅是算术运算，而且是逻辑，按位，函数等，均以这种逐个元素的隐式方式运行，即它们广播。此外，在上面的示例中， &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 可以是相同形状的多维数组，也可以是标量和数组，甚至可以是形状不同的两个数组，条件是较小的数组可以&amp;ldquo;扩展&amp;rdquo;到较大的形状以这样的方式使得最终的广播是明确的。有关广播的详细&amp;ldquo;规则&amp;rdquo;，请参阅 &lt;code&gt;basics.broadcasting&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8a22fa6f76158c02a615ce1e41377e5e327d96b" translate="yes" xml:space="preserve">
          <source>Broadcasting is used throughout NumPy to decide how to handle disparately shaped arrays; for example, all arithmetic operations (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &amp;hellip;) between &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt; broadcast the arrays before operation.</source>
          <target state="translated">在整个NumPy中都使用广播来决定如何处理形状各异的数组。例如，&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;之间的所有算术运算（ &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ，&amp;hellip;）都会在运算之前广播数组。</target>
        </trans-unit>
        <trans-unit id="c2ccb1ef65055f853bfad815cb4304fa00148706" translate="yes" xml:space="preserve">
          <source>Broadcasting over multiple arrays</source>
          <target state="translated">通过多个阵列进行广播</target>
        </trans-unit>
        <trans-unit id="8643e22fd07e0fa1b2c6f3538e1689c01bced1a3" translate="yes" xml:space="preserve">
          <source>Broadcasting provides a convenient way of taking the outer product (or any other outer operation) of two arrays. The following example shows an outer addition operation of two 1-d arrays that produces the same result as &lt;a href=&quot;#example-3&quot;&gt;Example 3&lt;/a&gt;</source>
          <target state="translated">广播提供了一种获取两个数组的外部乘积（或任何其他外部操作）的便捷方法。下面的示例显示两个1-d数组的外部加法运算，其结果与&lt;a href=&quot;#example-3&quot;&gt;示例3&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="f086db6f9cde283cd15667e2a34db081fa8323d1" translate="yes" xml:space="preserve">
          <source>Broadcasting provides a convenient way of taking the outer product (or any other outer operation) of two arrays. The following example shows an outer addition operation of two 1-d arrays:</source>
          <target state="translated">广播提供了一种方便的方法来获取两个数组的外积(或任何其他外运算)。下面的例子显示了两个一维数组的外加运算。</target>
        </trans-unit>
        <trans-unit id="916a860416eab96b40dda7fe2424a559b1d3ae5f" translate="yes" xml:space="preserve">
          <source>Broadcasting rules</source>
          <target state="translated">广播规则</target>
        </trans-unit>
        <trans-unit id="d8a2b5b45365993f46ca0dedffba4cb7be1f878c" translate="yes" xml:space="preserve">
          <source>Broadcasting rules apply, see the &lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt;&lt;code&gt;numpy.linalg&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">广播规则适用，有关详细信息，请参见&lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt; &lt;code&gt;numpy.linalg&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="d885a1b2d5577844b42f9c37b9817de5d134c079" translate="yes" xml:space="preserve">
          <source>Broadcasting was always implemented in Numeric using 0-valued strides for the extended dimensions. It is done in exactly the same way in NumPy. The big difference is that now the array of strides is kept track of in a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;, the iterators involved in a broadcast result are kept track of in a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt;, and the &lt;code&gt;PyArray_BroadCast&lt;/code&gt; call implements the broad-casting rules.</source>
          <target state="translated">广播始终以数字形式使用扩展值的0值跨度实现。它在NumPy中以完全相同的方式完成。最大的区别是，在现在进步的阵列保持跟踪&lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;，参与广播结果的迭代器保持轨道的一个&lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;PyArray_BroadCast&lt;/code&gt; 呼叫实现了广泛的铸造规则。</target>
        </trans-unit>
        <trans-unit id="34f655aae3670aa20a7e4bb7846e02a31bb3ce80" translate="yes" xml:space="preserve">
          <source>Broadcasting was always implemented in Numeric using 0-valued strides for the extended dimensions. It is done in exactly the same way in NumPy. The big difference is that now the array of strides is kept track of in a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;, the iterators involved in a broadcast result are kept track of in a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; call implements the broad-casting rules.</source>
          <target state="translated">广播始终以数字形式使用扩展值的0值跨度实现。它在NumPy中以完全相同的方式完成。最大的区别是，在现在进步的阵列保持跟踪&lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;，参与广播结果的迭代器保持轨道的一个&lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt;呼叫实现了广泛的铸造规则。</target>
        </trans-unit>
        <trans-unit id="2a0a6879b6872d1f7b106e1d3c8e15aa2bd9c9f9" translate="yes" xml:space="preserve">
          <source>Broadcasting was always implemented in Numeric using 0-valued strides for the extended dimensions. It is done in exactly the same way in NumPy. The big difference is that now the array of strides is kept track of in a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;, the iterators involved in a broadcast result are kept track of in a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt;, and the &lt;code&gt;PyArray_BroadCast&lt;/code&gt; call implements the broad-casting rules.</source>
          <target state="translated">广播始终以数字形式使用扩展值的0值跨度实现。它在NumPy中以完全相同的方式完成。最大的区别是，在现在进步的阵列保持跟踪&lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;，参与广播结果的迭代器保持轨道的一个&lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;PyArray_BroadCast&lt;/code&gt; 呼叫实现了广泛的铸造规则。</target>
        </trans-unit>
        <trans-unit id="6cc8d02b192349a4f1b4b7f860e5e3a1c421ecb8" translate="yes" xml:space="preserve">
          <source>Broadcasting, element-wise and scalar multiplication, &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;numpy.multiply&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">广播，逐元素和标量乘法，&lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;numpy.multiply&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90812c9e094ac5522eea3d57aa754d6964a1cdf2" translate="yes" xml:space="preserve">
          <source>Buffer (&lt;code&gt;buf&lt;/code&gt;) is interpreted according to these strides (strides define how many bytes each array element, row, column, etc. occupy in memory).</source>
          <target state="translated">缓冲区（ &lt;code&gt;buf&lt;/code&gt; ）根据这些步幅进行解释（步幅定义每个数组元素，行，列等在内存中占用多少字节）。</target>
        </trans-unit>
        <trans-unit id="3a3c6f456f2df72c3dcf8bdef2f2f225bc537cc1" translate="yes" xml:space="preserve">
          <source>Buffer of binary data</source>
          <target state="translated">二进制数据的缓冲区</target>
        </trans-unit>
        <trans-unit id="27cb2ff0185bcfdbaec6ac70d0f611c9c03b02a8" translate="yes" xml:space="preserve">
          <source>Buffered Loop</source>
          <target state="translated">缓冲环路</target>
        </trans-unit>
        <trans-unit id="3aa9875f6199e297bab60e3e7102191f0ce73af1" translate="yes" xml:space="preserve">
          <source>Buffered iterator for big arrays.</source>
          <target state="translated">大数组的缓冲迭代器。</target>
        </trans-unit>
        <trans-unit id="6d37057306b02ade5a2d41571a0c0e632337fc5c" translate="yes" xml:space="preserve">
          <source>Buffering mode mitigates the memory usage issue and is more cache-friendly than making temporary copies. Except for special cases, where the whole array is needed at once outside the iterator, buffering is recommended over temporary copying. Within NumPy, buffering is used by the ufuncs and other functions to support flexible inputs with minimal memory overhead.</source>
          <target state="translated">缓冲模式可以缓解内存使用问题,比做临时拷贝更有利于缓存。除了特殊情况下,在迭代器外需要一次性完成整个数组的时候,建议采用缓冲模式,而不是临时复制。在NumPy中,缓冲被ufuncs和其他函数使用,以最小的内存开销支持灵活的输入。</target>
        </trans-unit>
        <trans-unit id="aff21481cc1c0abc2cbd1fe3d4ce255d0403752e" translate="yes" xml:space="preserve">
          <source>Buffering the Array Elements</source>
          <target state="translated">阵列元素的缓冲</target>
        </trans-unit>
        <trans-unit id="e0ea19fac7306381f9369bebfc56bf181ad2f644" translate="yes" xml:space="preserve">
          <source>Bugs Fixed</source>
          <target state="translated">错误修正</target>
        </trans-unit>
        <trans-unit id="ac95995878b77d2a8ce4a1c4b232969f85fc5862" translate="yes" xml:space="preserve">
          <source>Build System Changes</source>
          <target state="translated">构建系统变更</target>
        </trans-unit>
        <trans-unit id="041e1aac6c7d1e7294bc5d8fa3967aabcde7a325" translate="yes" xml:space="preserve">
          <source>Build a matrix object from a string, nested sequence, or array.</source>
          <target state="translated">从字符串、嵌套序列或数组中建立一个矩阵对象。</target>
        </trans-unit>
        <trans-unit id="62d0591005ae8571425b97ff29068016515cd29b" translate="yes" xml:space="preserve">
          <source>Build and archive documentation</source>
          <target state="translated">建立和归档文件</target>
        </trans-unit>
        <trans-unit id="7fcd3a3a0bc7c1a4ce328d262f632a0650b70528" translate="yes" xml:space="preserve">
          <source>Build extension module from a Fortran 77 source string with f2py.</source>
          <target state="translated">用f2py从Fortran 77源码字符串中构建扩展模块。</target>
        </trans-unit>
        <trans-unit id="1d349060ba731253879161224c46e4521b75c084" translate="yes" xml:space="preserve">
          <source>Build options can be discovered by running any of:</source>
          <target state="translated">构建选项可以通过运行任何。</target>
        </trans-unit>
        <trans-unit id="368f9cf215b81c7db781f6218da65973b2216ee7" translate="yes" xml:space="preserve">
          <source>Build options for compilation</source>
          <target state="translated">构建编译选项</target>
        </trans-unit>
        <trans-unit id="7b1b626e82829b0dfeb4bfac3a16b7d5bcd6a8fc" translate="yes" xml:space="preserve">
          <source>Build source releases</source>
          <target state="translated">构建源码版本</target>
        </trans-unit>
        <trans-unit id="6e79e48e57f84dbe7fa157bde2a3fead704bb75d" translate="yes" xml:space="preserve">
          <source>Build system</source>
          <target state="translated">构建系统</target>
        </trans-unit>
        <trans-unit id="ea4c8827fa3eb397f1363449f23094e9e120bb77" translate="yes" xml:space="preserve">
          <source>Build the changelog and notes for upload with:</source>
          <target state="translated">建立变更日志和备注,以便上传与。</target>
        </trans-unit>
        <trans-unit id="133bc31192cbeea22da4122bb90ba0a93a894d67" translate="yes" xml:space="preserve">
          <source>Build wheels</source>
          <target state="translated">建造轮子</target>
        </trans-unit>
        <trans-unit id="d0fa723cff6db05fe0f943d3ba65530fea4a58d8" translate="yes" xml:space="preserve">
          <source>Building Installable C libraries</source>
          <target state="translated">构建可安装的C库</target>
        </trans-unit>
        <trans-unit id="fc68ddc861d1de39d367519f523580fe22e0de8b" translate="yes" xml:space="preserve">
          <source>Building NumPy requires the following software installed:</source>
          <target state="translated">构建NumPy需要安装以下软件。</target>
        </trans-unit>
        <trans-unit id="f7247d0ef96399c8a6f6f94bdfcbbd262feaf108" translate="yes" xml:space="preserve">
          <source>Building NumPy with a Python built with debug support (on Linux distributions typically packaged as &lt;code&gt;python-dbg&lt;/code&gt;) is highly recommended.</source>
          <target state="translated">强烈建议使用带有调试支持的Python构建NumPy（在通常打包为 &lt;code&gt;python-dbg&lt;/code&gt; 的Linux发行版上）。</target>
        </trans-unit>
        <trans-unit id="e3ab4efd8b4a10d38ed8959a1cb29fc9881db378" translate="yes" xml:space="preserve">
          <source>Building against OpenBLAS</source>
          <target state="translated">基于OpenBLAS的构建</target>
        </trans-unit>
        <trans-unit id="f1cd4f14fd9faeca78fccf35fd005e67e4d55852" translate="yes" xml:space="preserve">
          <source>Building and Extending the Documentation</source>
          <target state="translated">建立和扩展文件</target>
        </trans-unit>
        <trans-unit id="e724a6fd06203378a19b755ba05b8cd55da0f623" translate="yes" xml:space="preserve">
          <source>Building and extending the documentation</source>
          <target state="translated">建立和扩展文件</target>
        </trans-unit>
        <trans-unit id="ea6e2e9b251f8b11fe3d952437e66c0d7503db76" translate="yes" xml:space="preserve">
          <source>Building docs</source>
          <target state="translated">建立文档</target>
        </trans-unit>
        <trans-unit id="8cd56ee99256f6026c82a35e18d75551094d8936" translate="yes" xml:space="preserve">
          <source>Building from source</source>
          <target state="translated">从源头开始建设</target>
        </trans-unit>
        <trans-unit id="797c000e127fd646fe95625f81ea1c57543896ff" translate="yes" xml:space="preserve">
          <source>Building in-place</source>
          <target state="translated">原地建房</target>
        </trans-unit>
        <trans-unit id="e1f8c7d7fa78c6eb31ad5ca785a393676894e731" translate="yes" xml:space="preserve">
          <source>Building matrices</source>
          <target state="translated">建立矩阵</target>
        </trans-unit>
        <trans-unit id="d1d8b51984115777766e2f069b697c4bb754479c" translate="yes" xml:space="preserve">
          <source>Building source archives and wheels</source>
          <target state="translated">建立源档案和车轮</target>
        </trans-unit>
        <trans-unit id="1cc054390cfe90161261914ab7d65d3cfee4150a" translate="yes" xml:space="preserve">
          <source>Building the NumPy API and reference docs</source>
          <target state="translated">构建NumPy API和参考文档</target>
        </trans-unit>
        <trans-unit id="2b0584a2ddbe43766e4479e6f854126bbc0cb8a1" translate="yes" xml:space="preserve">
          <source>Building the documents requires a number of latex &lt;code&gt;.sty&lt;/code&gt; files. Install them all to avoid aggravation.</source>
          <target state="translated">构建文档需要大量的 &lt;code&gt;.sty&lt;/code&gt; 文件。将它们全部安装，以免加重压力。</target>
        </trans-unit>
        <trans-unit id="2afe730004d87377bea3908e9c6c7255bf4ce79e" translate="yes" xml:space="preserve">
          <source>Building the extension module can be now carried out in one command:</source>
          <target state="translated">现在只需一条命令就可以完成扩展模块的构建。</target>
        </trans-unit>
        <trans-unit id="fe2db8e7c7c6c32ba1fc4b4a6634f60ac081da44" translate="yes" xml:space="preserve">
          <source>Builds a set of strides which are the same as the strides of an output array created using the &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt;&lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt;&lt;/a&gt; flag, where NULL was passed for op_axes. This is for data packed contiguously, but not necessarily in C or Fortran order. This should be used together with &lt;a href=&quot;#c.NpyIter_GetShape&quot;&gt;&lt;code&gt;NpyIter_GetShape&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NpyIter_GetNDim&quot;&gt;&lt;code&gt;NpyIter_GetNDim&lt;/code&gt;&lt;/a&gt; with the flag &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt; passed into the constructor.</source>
          <target state="translated">构建一组&lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt; &lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt; &lt;/a&gt;，这些跨步与使用NPY_ITER_ALLOCATE标志创建的输出数组的跨步相同，其中为op_axes传递了NULL。这用于连续打包的数据，但不一定按C或Fortran顺序打包。这应该与&lt;a href=&quot;#c.NpyIter_GetShape&quot;&gt; &lt;code&gt;NpyIter_GetShape&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NpyIter_GetNDim&quot;&gt; &lt;code&gt;NpyIter_GetNDim&lt;/code&gt; &lt;/a&gt;一起使用，并将标志&lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt;传递到构造函数中。</target>
        </trans-unit>
        <trans-unit id="8b40e55c8fd12c110479c1a8e453add933b9c6e8" translate="yes" xml:space="preserve">
          <source>Built-in Python types</source>
          <target state="translated">内置Python类型</target>
        </trans-unit>
        <trans-unit id="b858e075ef402953578da270159a51f6ad1575b6" translate="yes" xml:space="preserve">
          <source>Built-in scalar types</source>
          <target state="translated">内置标量类型</target>
        </trans-unit>
        <trans-unit id="4a2892e18069d1f5869c7225c38ebadc7aa96d21" translate="yes" xml:space="preserve">
          <source>Bundled version of LAPACK is now 3.2.2</source>
          <target state="translated">捆绑版的LAPACK现在是3.2.2。</target>
        </trans-unit>
        <trans-unit id="f0300972b4a8f0b0074aec4f6903cf3e57d597c8" translate="yes" xml:space="preserve">
          <source>Business Day Functionality</source>
          <target state="translated">工作日功能</target>
        </trans-unit>
        <trans-unit id="3cbeeffaaa46e0b3d6b0ea56538a20f899791f42" translate="yes" xml:space="preserve">
          <source>Business Day Functions</source>
          <target state="translated">工作日功能</target>
        </trans-unit>
        <trans-unit id="a4da80602eb90228591a52fa43450b5af3478d27" translate="yes" xml:space="preserve">
          <source>But different types can be used for substitution. In fact, this is how conversion of Polynomial classes among themselves is done for type, domain, and window casting:</source>
          <target state="translated">但是不同的类型可以用来进行替换。事实上,多项式类之间的转换就是这样进行类型、域和窗口的铸造。</target>
        </trans-unit>
        <trans-unit id="bd8c2ef60d42745d2cdc473c152c1f9687c4dcc2" translate="yes" xml:space="preserve">
          <source>But if &lt;code&gt;rowsum&lt;/code&gt; would have two dimensions as well:</source>
          <target state="translated">但是，如果 &lt;code&gt;rowsum&lt;/code&gt; 也具有两个维度：</target>
        </trans-unit>
        <trans-unit id="a50860d81b9d10875263242c5534750b4457432a" translate="yes" xml:space="preserve">
          <source>But if the arrays have different dtype metadata, the metadata may be dropped:</source>
          <target state="translated">但如果数组的dtype元数据不同,元数据可能会被放弃。</target>
        </trans-unit>
        <trans-unit id="2cce3613bf130a21ef8719b403ca292f0f091a49" translate="yes" xml:space="preserve">
          <source>But in certain useful cases, NumPy can duplicate data along &amp;ldquo;missing&amp;rdquo; axes or &amp;ldquo;too-short&amp;rdquo; dimensions so shapes will match. The duplication costs no memory or time. For details, see &lt;a href=&quot;user/basics.broadcasting&quot;&gt;Broadcasting.&lt;/a&gt;</source>
          <target state="translated">但是在某些有用的情况下，NumPy可以沿&amp;ldquo;缺失&amp;rdquo;轴或&amp;ldquo;过短&amp;rdquo;尺寸复制数据，因此形状可以匹配。复制不会花费任何内存或时间。有关详细信息，请参见&lt;a href=&quot;user/basics.broadcasting&quot;&gt;广播。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4df18df25d280603f202e60c13a7a8f66254798" translate="yes" xml:space="preserve">
          <source>But is also allowed to produce, for some &lt;code&gt;a, b, c, d&lt;/code&gt;:</source>
          <target state="translated">但也可以产生一些 &lt;code&gt;a, b, c, d&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="95f2ff26f5da95b9bea4d70486f2a022cde496b8" translate="yes" xml:space="preserve">
          <source>But it automatically handles negative inputs:</source>
          <target state="translated">但它会自动处理负输入。</target>
        </trans-unit>
        <trans-unit id="6646b6ecbc06bc26898d3bc8dfd20372b9b785ad" translate="yes" xml:space="preserve">
          <source>But that&amp;rsquo;s not the only way to look at it. Suppose one has large two-dimensional arrays (images or matrices) stored in data files. Suppose the data are stored by rows rather than by columns. If we are to preserve our index convention (whether matrix or image) that means that depending on the language we use, we may be forced to reorder the data if it is read into memory to preserve our indexing convention. For example if we read row-ordered data into memory without reordering, it will match the matrix indexing convention for C, but not for Fortran. Conversely, it will match the image indexing convention for Fortran, but not for C. For C, if one is using data stored in row order, and one wants to preserve the image index convention, the data must be reordered when reading into memory.</source>
          <target state="translated">但这不是观察它的唯一方法。假设其中一个具有存储在数据文件中的大型二维数组（图像或矩阵）。假设数据是按行而不是按列存储的。如果我们要保留索引约定（无论是矩阵还是图像），这意味着根据我们使用的语言，如果将数据读入内存以保留索引约定，我们可能会被迫对数据进行重新排序。例如，如果我们将按行排序的数据读入内存而不进行重新排序，则它将匹配C的矩阵索引约定，但不匹配Fortran的矩阵索引约定。相反，它将与Fortran的图像索引约定匹配，但与C不匹配。对于C，如果使用的是按行顺序存储的数据，并且希望保留图像索引约定，则在读入内存时必须对数据重新排序。</target>
        </trans-unit>
        <trans-unit id="6e0bd4df436692919faeb191ed09cf810cb22035" translate="yes" xml:space="preserve">
          <source>But there are cross-platform considerations, such as library file extensions, plus the fact Windows will just load the first library it finds with that name. NumPy supplies the load_library function as a convenience.</source>
          <target state="translated">但是有跨平台的考虑,比如库文件的扩展名,再加上Windows只会加载它找到的第一个以该名称命名的库,所以NumPy提供了load_library函数作为方便。NumPy提供了load_library函数作为方便。</target>
        </trans-unit>
        <trans-unit id="ec781290ccbee49bdd7da500afd06d4ca2f948bf" translate="yes" xml:space="preserve">
          <source>But this omits some subtleties. Here is a fully general summary:</source>
          <target state="translated">但这省略了一些细微的地方。下面是一个完全概括性的总结。</target>
        </trans-unit>
        <trans-unit id="9d33835f4b0ffd7a417785ade1f5f4a66909b7f6" translate="yes" xml:space="preserve">
          <source>But we can also specify the axis over which to multiply:</source>
          <target state="translated">但我们也可以指定乘法的轴。</target>
        </trans-unit>
        <trans-unit id="9f79d5f66a9deb8e0798847bf7ab428de8db1e5a" translate="yes" xml:space="preserve">
          <source>But when you use &lt;code&gt;ravel&lt;/code&gt;, the changes you make to the new array will affect the parent array.</source>
          <target state="translated">但是，当您使用 &lt;code&gt;ravel&lt;/code&gt; 时，对新数组所做的更改将影响父数组。</target>
        </trans-unit>
        <trans-unit id="7460c60c1fec76b65a3c31a575c95674fb86e283" translate="yes" xml:space="preserve">
          <source>But, we could do anything we wanted:</source>
          <target state="translated">但是,我们可以做任何我们想做的事情。</target>
        </trans-unit>
        <trans-unit id="e13f0fd9c0e50a5064cf51cb50663812feb86a8e" translate="yes" xml:space="preserve">
          <source>Buzas, Martin A.; Culver, Stephen J., Understanding regional species diversity through the log series distribution of occurrences: BIODIVERSITY RESEARCH Diversity &amp;amp; Distributions, Volume 5, Number 5, September 1999 , pp. 187-195(9).</source>
          <target state="translated">布萨斯（Martin A.）；Culver，Stephen J.，通过事件的对数序列分布了解区域物种多样性：生物多样性研究多样性与分布，第5卷，第5期，1999年9月，第187-195（9）页。</target>
        </trans-unit>
        <trans-unit id="66360bf7fbf8657df2c1591ab899dd54476a182c" translate="yes" xml:space="preserve">
          <source>By choosing an offset of 8 bytes we can select the complex part of the array for our view:</source>
          <target state="translated">通过选择一个8字节的偏移量,我们可以选择数组中复杂的部分作为我们的视图。</target>
        </trans-unit>
        <trans-unit id="c96bbfd74d3086f0a931f577a61fdefbdd812bbe" translate="yes" xml:space="preserve">
          <source>By constructing a new ndarray of your desired shape and type using &lt;a href=&quot;../reference/c-api/array#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; or a simpler macro or function based on it.</source>
          <target state="translated">通过使用&lt;a href=&quot;../reference/c-api/array#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt;或基于它的更简单的宏或函数构造所需形状和类型的新ndarray 。</target>
        </trans-unit>
        <trans-unit id="6503cfb311994e99b18c321cb4370162b665063d" translate="yes" xml:space="preserve">
          <source>By convention, the negative sign represents cash flow out (i.e. money not available today). Thus, saving $100 a month at 5% annual interest leads to $15,692.93 available to spend in 10 years.</source>
          <target state="translated">按照惯例,负号代表现金流出(即今天不能用的钱)。因此,每月以5%的年息存100元,10年后就有15,692.93元可供使用。</target>
        </trans-unit>
        <trans-unit id="7f5fbe94c54051531f7d898251f9826df16e5720" translate="yes" xml:space="preserve">
          <source>By convention, the negative sign represents cash flow out (i.e., money not available today). Thus, to end up with $15,692.93 in 10 years saving $100 a month at 5% annual interest, one&amp;rsquo;s initial deposit should also be $100.</source>
          <target state="translated">按照惯例，负号表示现金流出（即，今天没有钱）。因此，要想在10年后得到$ 15,692.93，每月以$ 5％的年利率存入$ 100，一个人的初始存款也应该是$ 100。</target>
        </trans-unit>
        <trans-unit id="e8f9209679e0d480aec7fb981fefcc0f2b86d6ab" translate="yes" xml:space="preserve">
          <source>By converting it from some Python object using &lt;a href=&quot;../reference/c-api/array#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; or a macro built on it.</source>
          <target state="translated">通过使用&lt;a href=&quot;../reference/c-api/array#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;或基于其构建的宏将其从某些Python对象转换而来。</target>
        </trans-unit>
        <trans-unit id="2387467eae05dde35d2654a3dbfc0d30bc85b00f" translate="yes" xml:space="preserve">
          <source>By default (&lt;code&gt;align=False&lt;/code&gt;), numpy will pack the fields together such that each field starts at the byte offset the previous field ended, and the fields are contiguous in memory.</source>
          <target state="translated">默认情况下（ &lt;code&gt;align=False&lt;/code&gt; ），numpy会将字段打包在一起，以便每个字段都从上一个字段结束的字节偏移处开始，并且这些字段在内存中是连续的。</target>
        </trans-unit>
        <trans-unit id="52bf606add02bda44e68afd9558117218dd1b2cb" translate="yes" xml:space="preserve">
          <source>By default &lt;a href=&quot;#numpy.testing.rundocs&quot;&gt;&lt;code&gt;rundocs&lt;/code&gt;&lt;/a&gt; raises an AssertionError on failure.</source>
          <target state="translated">默认情况下，&lt;a href=&quot;#numpy.testing.rundocs&quot;&gt; &lt;code&gt;rundocs&lt;/code&gt; &lt;/a&gt;在失败时引发AssertionError。</target>
        </trans-unit>
        <trans-unit id="57786a266025c7ab2defbf0e660b34ff7cd9c745" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;../arrays.scalars#numpy.float16&quot;&gt;&lt;code&gt;float16&lt;/code&gt;&lt;/a&gt; results are computed using &lt;a href=&quot;../arrays.scalars#numpy.float32&quot;&gt;&lt;code&gt;float32&lt;/code&gt;&lt;/a&gt; intermediates for extra precision.</source>
          <target state="translated">默认情况下，使用&lt;a href=&quot;../arrays.scalars#numpy.float32&quot;&gt; &lt;code&gt;float32&lt;/code&gt; &lt;/a&gt;中间体计算&lt;a href=&quot;../arrays.scalars#numpy.float16&quot;&gt; &lt;code&gt;float16&lt;/code&gt; &lt;/a&gt;结果可获得更高的精度。</target>
        </trans-unit>
        <trans-unit id="bd3d90ca79bba610cc2cceb26a3b68c32b444a0a" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;generated/numpy.random.generator.permuted#numpy.random.Generator.permuted&quot;&gt;&lt;code&gt;Generator.permuted&lt;/code&gt;&lt;/a&gt; returns a copy. To operate in-place with &lt;a href=&quot;generated/numpy.random.generator.permuted#numpy.random.Generator.permuted&quot;&gt;&lt;code&gt;Generator.permuted&lt;/code&gt;&lt;/a&gt;, pass the same array as the first argument &lt;em&gt;and&lt;/em&gt; as the value of the &lt;code&gt;out&lt;/code&gt; parameter. For example,</source>
          <target state="translated">默认情况下，&lt;a href=&quot;generated/numpy.random.generator.permuted#numpy.random.Generator.permuted&quot;&gt; &lt;code&gt;Generator.permuted&lt;/code&gt; &lt;/a&gt;返回一个副本。要使用&lt;a href=&quot;generated/numpy.random.generator.permuted#numpy.random.Generator.permuted&quot;&gt; &lt;code&gt;Generator.permuted&lt;/code&gt; &lt;/a&gt;就地进行操作，请与第一个参数&lt;em&gt;和&lt;/em&gt; &lt;code&gt;out&lt;/code&gt; 参数的值传递相同的数组。例如，</target>
        </trans-unit>
        <trans-unit id="0791e549c9e1c0c68c18f4046427ddfd65fee6cf" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; uses bits provided by &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; which has better statistical properties than the legacy mt19937 random number generator in &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">默认情况下，&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;使用提供比特&lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;具有比传统mt19937随机数生成更好的统计特性&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2eb2435c3e98faf455297cd059d456431f056aed" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;float16&lt;/code&gt; results are computed using &lt;code&gt;float32&lt;/code&gt; intermediates for extra precision.</source>
          <target state="translated">默认情况下，使用 &lt;code&gt;float32&lt;/code&gt; 中间体计算 &lt;code&gt;float16&lt;/code&gt; 结果可获得更高的精度。</target>
        </trans-unit>
        <trans-unit id="f255d5e8f1a7ce5480c00642bd965d8cbd147605" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;skip_header=0&lt;/code&gt; and &lt;code&gt;skip_footer=0&lt;/code&gt;, meaning that no lines are skipped.</source>
          <target state="translated">默认情况下， &lt;code&gt;skip_header=0&lt;/code&gt; 和 &lt;code&gt;skip_footer=0&lt;/code&gt; ，这意味着不跳过任何行。</target>
        </trans-unit>
        <trans-unit id="509cc82d7b395ceb5fa528a542a3fa0619544044" translate="yes" xml:space="preserve">
          <source>By default, a new array is created of the given shape and data-type. If &lt;code&gt;buf&lt;/code&gt; is specified and is an object exposing the buffer interface, the array will use the memory from the existing buffer. In this case, the &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.recarray.strides#numpy.recarray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; keywords are available.</source>
          <target state="translated">默认情况下，将创建具有给定形状和数据类型的新数组。如果指定了 &lt;code&gt;buf&lt;/code&gt; 并且它是暴露缓冲区接口的对象，则阵列将使用现有缓冲区中的内存。在这种情况下，可以使用 &lt;code&gt;offset&lt;/code&gt; 和&lt;a href=&quot;numpy.recarray.strides#numpy.recarray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;关键字。</target>
        </trans-unit>
        <trans-unit id="823f8fa3f73a578c65a2065fa5f02e69dcee70ef" translate="yes" xml:space="preserve">
          <source>By default, all user-defined data-types are not presumed to be safely castable to any builtin data-types. In addition builtin data-types are not presumed to be safely castable to user-defined data-types. This situation limits the ability of user-defined data-types to participate in the coercion system used by ufuncs and other times when automatic coercion takes place in NumPy. This can be changed by registering data-types as safely castable from a particular data-type object. The function &lt;a href=&quot;../reference/c-api/array#c.PyArray_RegisterCanCast&quot;&gt;&lt;code&gt;PyArray_RegisterCanCast&lt;/code&gt;&lt;/a&gt; (from_descr, totype_number, scalarkind) should be used to specify that the data-type object from_descr can be cast to the data-type with type number totype_number. If you are not trying to alter scalar coercion rules, then use &lt;a href=&quot;../reference/c-api/array#c.NPY_NOSCALAR&quot;&gt;&lt;code&gt;NPY_NOSCALAR&lt;/code&gt;&lt;/a&gt; for the scalarkind argument.</source>
          <target state="translated">默认情况下，不假定所有用户定义的数据类型都可以安全地强制转换为任何内置数据类型。另外，不能将内置数据类型安全地转换为用户定义的数据类型。这种情况限制了用户定义的数据类型参与ufunc使用的强制系统以及在NumPy中进行自动强制的其他时间的能力。可以通过将数据类型注册为可从特定数据类型对象安全地强制转换来进行更改。函数&lt;a href=&quot;../reference/c-api/array#c.PyArray_RegisterCanCast&quot;&gt; &lt;code&gt;PyArray_RegisterCanCast&lt;/code&gt; &lt;/a&gt;（from_descr，totype_number，scalarkind）应用于指定数据类型对象from_descr可以强制转换为类型为totype_number的数据类型。如果您不尝试更改标量强制规则，则将&lt;a href=&quot;../reference/c-api/array#c.NPY_NOSCALAR&quot;&gt; &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; &lt;/a&gt;用作scalarkind参数。</target>
        </trans-unit>
        <trans-unit id="c3c9f5af6f6f20b9748f044265ea41cc53afdaad" translate="yes" xml:space="preserve">
          <source>By default, any empty string is marked as missing. We can also consider more complex strings, such as &lt;code&gt;&quot;N/A&quot;&lt;/code&gt; or &lt;code&gt;&quot;???&quot;&lt;/code&gt; to represent missing or invalid data. The &lt;code&gt;missing_values&lt;/code&gt; argument accepts three kind of values:</source>
          <target state="translated">默认情况下，任何空字符串都标记为丢失。我们还可以考虑更复杂的字符串，例如 &lt;code&gt;&quot;N/A&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;???&quot;&lt;/code&gt; 表示缺少或无效的数据。该 &lt;code&gt;missing_values&lt;/code&gt; 参数接受三个类型的值：</target>
        </trans-unit>
        <trans-unit id="5c0614e39713a118bc2e830f1f54b096ac814bb1" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">默认情况下，astype始终返回新分配的数组。如果设置为false，和&lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;order&lt;/code&gt; 和 &lt;code&gt;subok&lt;/code&gt; 的要求得到满足，输入数组返回而不是复制。</target>
        </trans-unit>
        <trans-unit id="65020739d65de234914c6eca7148d91943920302" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">默认情况下，astype始终返回新分配的数组。如果设置为false，和&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;order&lt;/code&gt; 和 &lt;code&gt;subok&lt;/code&gt; 的要求得到满足，输入数组返回而不是复制。</target>
        </trans-unit>
        <trans-unit id="67bd53a8510577a68e06f12cd6753f65341b7ba7" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">默认情况下，astype始终返回新分配的数组。如果设置为false，和&lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;order&lt;/code&gt; 和 &lt;code&gt;subok&lt;/code&gt; 的要求得到满足，输入数组返回而不是复制。</target>
        </trans-unit>
        <trans-unit id="33a91516197cac2d79884383700e7cb303d84acc" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">默认情况下，astype始终返回新分配的数组。如果设置为false，和&lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;order&lt;/code&gt; 和 &lt;code&gt;subok&lt;/code&gt; 的要求得到满足，输入数组返回而不是复制。</target>
        </trans-unit>
        <trans-unit id="18abc4afb5a03b89f3bcee3c191658826915b7e7" translate="yes" xml:space="preserve">
          <source>By default, calculate the product of all elements:</source>
          <target state="translated">默认情况下,计算所有元素的乘积。</target>
        </trans-unit>
        <trans-unit id="29592fecd779ff823d8494d78a32e4c6bef17a8b" translate="yes" xml:space="preserve">
          <source>By default, masked values are recognized as such. If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have the same shape, a common mask is allocated: if &lt;code&gt;x[i,j]&lt;/code&gt; is masked, then &lt;code&gt;y[i,j]&lt;/code&gt; will also be masked. Setting &lt;code&gt;allow_masked&lt;/code&gt; to False will raise an exception if values are missing in either of the input arrays.</source>
          <target state="translated">默认情况下，屏蔽值将被识别为原样。如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的形状相同，则分配一个公共掩码：如果 &lt;code&gt;x[i,j]&lt;/code&gt; 被掩码，则 &lt;code&gt;y[i,j]&lt;/code&gt; 也将被掩码。如果任一输入数组中缺少值，则将 &lt;code&gt;allow_masked&lt;/code&gt; 设置为False将引发异常。</target>
        </trans-unit>
        <trans-unit id="72d47f0b8465ed8e3b2a5736c0d1dfec28a91237" translate="yes" xml:space="preserve">
          <source>By default, mode is &amp;lsquo;full&amp;rsquo;. This returns the convolution at each point of overlap, with an output shape of (N+M-1,). At the end-points of the convolution, the signals do not overlap completely, and boundary effects may be seen.</source>
          <target state="translated">默认情况下，模式为&amp;ldquo;完整&amp;rdquo;。这将在每个重叠点返回卷积，输出形状为（N + M-1，）。在卷积的端点，信号没有完全重叠，并且可以看到边界效应。</target>
        </trans-unit>
        <trans-unit id="781e5458e78b28bbdf619e8539b2f911598af3c5" translate="yes" xml:space="preserve">
          <source>By default, returned multidimensional arrays are Fortran-contiguous. If &lt;code&gt;intent(c)&lt;/code&gt; is used, then returned multidimensional arrays are C-contiguous.</source>
          <target state="translated">默认情况下，返回的多维数组是Fortran连续的。如果使用 &lt;code&gt;intent(c)&lt;/code&gt; ，则返回的多维数组是C连续的。</target>
        </trans-unit>
        <trans-unit id="6971450c7aa549483b5389a69fedb16eaf066171" translate="yes" xml:space="preserve">
          <source>By default, reverse the dimensions, otherwise permute the axes according to the values given.</source>
          <target state="translated">默认情况下,将尺寸反转,否则根据给定的值对轴进行细分。</target>
        </trans-unit>
        <trans-unit id="f55a7b395485c3988f5bccbb6f9eaebb26dfc947" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; treats the input operand as a read-only object. To be able to modify the array elements, you must specify either read-write or write-only mode using the &lt;code&gt;&amp;lsquo;readwrite&amp;rsquo;&lt;/code&gt; or &lt;code&gt;&amp;lsquo;writeonly&amp;rsquo;&lt;/code&gt; per-operand flags.</source>
          <target state="translated">默认情况下，&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;将输入操作数视为只读对象。为了能够修改数组元素，必须使用每个操作数标志 &lt;code&gt;&amp;lsquo;readwrite&amp;rsquo;&lt;/code&gt; 或 &lt;code&gt;&amp;lsquo;writeonly&amp;rsquo;&lt;/code&gt; 指定读写模式或只写模式。</target>
        </trans-unit>
        <trans-unit id="174daf14dced474235661dc4a8a7f2c4b87b4b7c" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; uses the flags &amp;lsquo;allocate&amp;rsquo; and &amp;lsquo;writeonly&amp;rsquo; for operands that are passed in as None. This means we were able to provide just the two operands to the iterator, and it handled the rest.</source>
          <target state="translated">默认情况下，&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;将标志&amp;ldquo; allocate&amp;rdquo;和&amp;ldquo; writeonly&amp;rdquo;用于作为None传入的操作数。这意味着我们能够仅将两个操作数提供给迭代器，然后它处理其余的操作。</target>
        </trans-unit>
        <trans-unit id="17e308c1f2a6481942287f2519e364f482dd5128" translate="yes" xml:space="preserve">
          <source>By default, the data-type is inferred from the input data.</source>
          <target state="translated">默认情况下,数据类型是由输入数据推断出来的。</target>
        </trans-unit>
        <trans-unit id="d105f45ad87599a046dab97b11d0171a9dd2c47e" translate="yes" xml:space="preserve">
          <source>By default, the index is into the flattened array, otherwise along the specified axis.</source>
          <target state="translated">默认情况下,索引是进入扁平化的数组,否则沿着指定的轴。</target>
        </trans-unit>
        <trans-unit id="e68b2ebbdaa7d8bde52807398926b542381f9c7b" translate="yes" xml:space="preserve">
          <source>By default, the iterator produces pointers into the arrays provided, which may be aligned or unaligned, and with any byte order. If copying or buffering is not enabled and the operand data doesn&amp;rsquo;t satisfy the constraints, an error will be raised.</source>
          <target state="translated">默认情况下，迭代器将指针生成到所提供的数组中，这些数组可以是对齐的或不对齐的，并且具有任何字节顺序。如果未启用复制或缓冲并且操作数数据不满足约束条件，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="ab25c157edc4354c1f57c1df2646a0b82ab1dad1" translate="yes" xml:space="preserve">
          <source>By default, these operations apply to the array as though it were a list of numbers, regardless of its shape. However, by specifying the &lt;code&gt;axis&lt;/code&gt; parameter you can apply an operation along the specified axis of an array:</source>
          <target state="translated">默认情况下，这些操作适用于数组，就好像它是一个数字列表一样，而不管其形状如何。但是，通过指定 &lt;code&gt;axis&lt;/code&gt; 参数，可以沿数组的指定轴应用操作：</target>
        </trans-unit>
        <trans-unit id="8619d136820b4ea98c355d5e9bb29020512d7ef1" translate="yes" xml:space="preserve">
          <source>By default, when a line is decomposed into a series of strings, the individual entries are not stripped of leading nor trailing white spaces. This behavior can be overwritten by setting the optional argument &lt;code&gt;autostrip&lt;/code&gt; to a value of &lt;code&gt;True&lt;/code&gt;:</source>
          <target state="translated">默认情况下，当将一行分解为一系列字符串时，不会删除各个条目的前导或尾随空格。通过将可选参数 &lt;code&gt;autostrip&lt;/code&gt; 设置为 &lt;code&gt;True&lt;/code&gt; 可以覆盖此行为：</target>
        </trans-unit>
        <trans-unit id="a90e6d5076b3318d5438106f6aec8b51a30f2edc" translate="yes" xml:space="preserve">
          <source>By eliminating the inner loop in the description above, and using &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt; to build simple slice objects, &lt;a href=&quot;#numpy.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; can be expressed in terms of applying fancy indexing to each 1-d slice:</source>
          <target state="translated">通过消除上面描述中的内部循环，并使用&lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; &lt;/a&gt;来构建简单的切片对象，&lt;a href=&quot;#numpy.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;可以表示为对每个1-d切片应用花式索引：</target>
        </trans-unit>
        <trans-unit id="f5e127dadff417279256627201011a26eddd8177" translate="yes" xml:space="preserve">
          <source>By enabling buffering mode, the chunks provided by the iterator to the inner loop can be made larger, significantly reducing the overhead of the Python interpreter. In the example forcing Fortran iteration order, the inner loop gets to see all the elements in one go when buffering is enabled.</source>
          <target state="translated">通过启用缓冲模式,可以使迭代器提供给内循环的分块变大,大大降低Python解释器的开销。在强制Fortran迭代顺序的例子中,当启用缓冲时,内循环可以一次性看到所有元素。</target>
        </trans-unit>
        <trans-unit id="842fa81b602f5ee9d6e48f92f8610cb23e1b4b1b" translate="yes" xml:space="preserve">
          <source>By examining the coefficients, we see that the line should have a gradient of roughly 1 and cut the y-axis at, more or less, -1.</source>
          <target state="translated">通过研究系数,我们发现,这条线的梯度应该大致为1,并在-1处或多或少地切断y轴。</target>
        </trans-unit>
        <trans-unit id="4b0026b5caaf6e12c9b18e1ac7ccb5e7684a2b52" translate="yes" xml:space="preserve">
          <source>By far the most complex case is advanced indexing, which may or may not be combined with typical view based indexing. Here integer indices are interpreted as view based. Before trying to understand this, you may want to make yourself familiar with its subtleties. The advanced indexing code has three different branches and one special case:</source>
          <target state="translated">到目前为止,最复杂的情况是高级索引,它可能与典型的基于视图的索引相结合,也可能不相结合。在这里,整数索引被解释为基于视图的索引。在试图理解这一点之前,你可能需要熟悉它的微妙之处。高级索引代码有三个不同的分支和一个特殊情况。</target>
        </trans-unit>
        <trans-unit id="e675b296a66e810552905002296a09520d23ea5d" translate="yes" xml:space="preserve">
          <source>By organizing how-tos this way, you not only display the options for people who need to narrow their question, you also have provided answers for users who start with narrower questions (&amp;ldquo;I want to see historic buildings,&amp;rdquo; &amp;ldquo;Which way to city hall?&amp;rdquo;).</source>
          <target state="translated">通过这种方式组织操作方法，您不仅可以为需要缩小问题范围的人显示选项，还可以为从狭义问题开始的用户提供答案（&amp;ldquo;我想看历史建筑&amp;rdquo;，&amp;ldquo;通向城市的哪种方式大厅？&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="46784614463c18819405731702cb3c998ad15a83" translate="yes" xml:space="preserve">
          <source>By placing intent directives and checking code, the interface can be cleaned up quite a bit until the Python module method is both easier to use and more robust.</source>
          <target state="translated">通过放置意图指令和检查代码,接口可以清理不少,直到Python模块方法既容易使用又健壮。</target>
        </trans-unit>
        <trans-unit id="eb83a5c83addee3a887cb831a30aba85bb504443" translate="yes" xml:space="preserve">
          <source>By substituting</source>
          <target state="translated">代以</target>
        </trans-unit>
        <trans-unit id="a10b2dfc802325db14226bfb0f644772b0ee8dc9" translate="yes" xml:space="preserve">
          <source>By testing them against the compiler, and seeing what the compiler can support according to the requested optimizations.</source>
          <target state="translated">通过对编译器进行测试,根据要求的优化,看看编译器能支持什么。</target>
        </trans-unit>
        <trans-unit id="5cf0a6a61d5c04a9d920300ad8c8de64a060c650" translate="yes" xml:space="preserve">
          <source>By the above description, the casting rules are essentially implemented by the question of when a data type can be cast &amp;ldquo;safely&amp;rdquo; to another data type. The answer to this question can be determined in Python with a function call: &lt;a href=&quot;generated/numpy.can_cast#numpy.can_cast&quot;&gt;&lt;code&gt;can_cast(fromtype, totype)&lt;/code&gt;&lt;/a&gt;. The Figure below shows the results of this call for the 24 internally supported types on the author&amp;rsquo;s 64-bit system. You can generate this table for your system with the code given in the Figure.</source>
          <target state="translated">通过以上描述，强制转换规则实质上是通过何时可以将数据类型&amp;ldquo;安全&amp;rdquo;转换为另一种数据的问题来实现的。这个问题的答案可以在Python中通过以下函数调用确定：&lt;a href=&quot;generated/numpy.can_cast#numpy.can_cast&quot;&gt; &lt;code&gt;can_cast(fromtype, totype)&lt;/code&gt; &lt;/a&gt;。下图显示了对作者的64位系统上的24种内部支持的类型进行此调用的结果。您可以使用图中给出的代码为您的系统生成该表。</target>
        </trans-unit>
        <trans-unit id="0cffcf4de4e9b85ff13913ac390d2131986b166e" translate="yes" xml:space="preserve">
          <source>Byte (-128 to 127)</source>
          <target state="translated">字节(-128至127)</target>
        </trans-unit>
        <trans-unit id="c3b1bb21176956a777afbce91b2dc46b27bfdbd1" translate="yes" xml:space="preserve">
          <source>Byte order of the data (&lt;a href=&quot;../glossary#term-little-endian&quot;&gt;little-endian&lt;/a&gt; or &lt;a href=&quot;../glossary#term-big-endian&quot;&gt;big-endian&lt;/a&gt;)</source>
          <target state="translated">数据的字节顺序（&lt;a href=&quot;../glossary#term-little-endian&quot;&gt;little-endian&lt;/a&gt;或&lt;a href=&quot;../glossary#term-big-endian&quot;&gt;big-endian&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="c3ee543ea3c911ca70be24ca50be4966bfc9d11e" translate="yes" xml:space="preserve">
          <source>Byte order of the data (&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-little-endian&quot;&gt;little-endian&lt;/a&gt; or &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-big-endian&quot;&gt;big-endian&lt;/a&gt;)</source>
          <target state="translated">数据的字节顺序（&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-little-endian&quot;&gt;little-endian&lt;/a&gt;或&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-big-endian&quot;&gt;big-endian&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="33aea8e37e75e01b5515b25f2b9a264a2526b968" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications above. The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order.</source>
          <target state="translated">字节顺序强制；来自上述字节顺序规范的值。默认值（'S'）导致交换当前字节顺序。</target>
        </trans-unit>
        <trans-unit id="4fa7dfbdbb33fd63c061542164ead10c6ea66cdb" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications above. The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for the alternatives above. For example, any of &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;biggish&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">字节顺序强制；来自上述字节顺序规范的值。默认值（'S'）导致交换当前字节顺序。对于上述替代方案，代码对 &lt;code&gt;new_order&lt;/code&gt; 的第一个字母进行不区分大小写的检查。例如，&amp;ldquo; B&amp;rdquo;或&amp;ldquo; b&amp;rdquo;或&amp;ldquo; biggish&amp;rdquo;中的任何一个都可以有效地指定big-endian。</target>
        </trans-unit>
        <trans-unit id="d891a9572e92fd87112849b433aa9d82773e6323" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications below. &lt;code&gt;new_order&lt;/code&gt; codes can be any of:</source>
          <target state="translated">字节顺序强制；来自以下字节顺序规范的值。 &lt;code&gt;new_order&lt;/code&gt; 代码可以是以下任意一种：</target>
        </trans-unit>
        <trans-unit id="925da9e3660113afb959c492e32c0df4c8fba9ab" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications below. The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. &lt;code&gt;new_order&lt;/code&gt; codes can be any of:</source>
          <target state="translated">字节顺序强制；来自以下字节顺序规范的值。默认值（'S'）导致交换当前字节顺序。 &lt;code&gt;new_order&lt;/code&gt; 代码可以是以下任意一种：</target>
        </trans-unit>
        <trans-unit id="208a9d70c2ceb4cad845268b3793f06f24736861" translate="yes" xml:space="preserve">
          <source>Byte-order for all fields.</source>
          <target state="translated">所有字段的字节顺序。</target>
        </trans-unit>
        <trans-unit id="3d30b75f6bbab6dd2f33ea184465104adfe034dc" translate="yes" xml:space="preserve">
          <source>Byte-swapping</source>
          <target state="translated">Byte-swapping</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="c380132bd13732c2a4492b58e8089f6c672f3148" translate="yes" xml:space="preserve">
          <source>C API</source>
          <target state="translated">C API</target>
        </trans-unit>
        <trans-unit id="90c2059501661b20579455b452bcdf7917e96a74" translate="yes" xml:space="preserve">
          <source>C API Deprecations</source>
          <target state="translated">C API 废止</target>
        </trans-unit>
        <trans-unit id="5eefd673571a664f98901cbfc9269cc56d66bdd2" translate="yes" xml:space="preserve">
          <source>C API changes</source>
          <target state="translated">C API变化</target>
        </trans-unit>
        <trans-unit id="991eaf0718be5436cf82b4e88422dbaeb580655b" translate="yes" xml:space="preserve">
          <source>C API for random</source>
          <target state="translated">用于随机的C API</target>
        </trans-unit>
        <trans-unit id="a09f5c39498227c23bac03c4d85a857f0c660b68" translate="yes" xml:space="preserve">
          <source>C dialect</source>
          <target state="translated">丙方言</target>
        </trans-unit>
        <trans-unit id="baf0b9cf537d3452f0bedecd7885e6a6f5c95212" translate="yes" xml:space="preserve">
          <source>C expressions</source>
          <target state="translated">C表达式</target>
        </trans-unit>
        <trans-unit id="5053549bf41c7c644de43b7357e8b95981f3b14c" translate="yes" xml:space="preserve">
          <source>C expressions are used in the following parts of signature files:</source>
          <target state="translated">签字文件的以下部分使用了C表达式:</target>
        </trans-unit>
        <trans-unit id="62988a5cc34cb2d480ad455963d13a5b50fea224" translate="yes" xml:space="preserve">
          <source>C order</source>
          <target state="translated">C命令</target>
        </trans-unit>
        <trans-unit id="4d3779622c7ddb81083220abbfe17022ee213c7f" translate="yes" xml:space="preserve">
          <source>C order.</source>
          <target state="translated">C令。</target>
        </trans-unit>
        <trans-unit id="502ca6c945d9f8aee115c49e01f9edd12a50b0c8" translate="yes" xml:space="preserve">
          <source>C type</source>
          <target state="translated">C型</target>
        </trans-unit>
        <trans-unit id="1ef859ea3c4b4e94c8561ce88af6e45cd8c349e4" translate="yes" xml:space="preserve">
          <source>C++ support</source>
          <target state="translated">支持C++</target>
        </trans-unit>
        <trans-unit id="e04e63e5d64190b9021eeae0aa43f4dd8f802b80" translate="yes" xml:space="preserve">
          <source>C-API</source>
          <target state="translated">C-API</target>
        </trans-unit>
        <trans-unit id="b42fb0a4e21a6c7c2ad779467660c5d634cd1f27" translate="yes" xml:space="preserve">
          <source>C-API Array Additions</source>
          <target state="translated">C-API阵列添加</target>
        </trans-unit>
        <trans-unit id="20e7136fe60c57d32b3ba713a50d60dd983c3865" translate="yes" xml:space="preserve">
          <source>C-API Developer Improvements</source>
          <target state="translated">C-API开发者改进</target>
        </trans-unit>
        <trans-unit id="847c15716f4f18fd587862ab143e5d2f9581c235" translate="yes" xml:space="preserve">
          <source>C-API Ufunc Additions</source>
          <target state="translated">C-API Ufunc Additions</target>
        </trans-unit>
        <trans-unit id="c77824df8f5b9b7ad0f95af7e88364d494112e7e" translate="yes" xml:space="preserve">
          <source>C-API for implementing Elementary Functions</source>
          <target state="translated">用于实现基本函数的C-API</target>
        </trans-unit>
        <trans-unit id="6bc42241dfe0e66ad03fd900ab60e09366468123" translate="yes" xml:space="preserve">
          <source>C-Level string to datetime casts changed</source>
          <target state="translated">C级字符串到日期时间的投递发生了变化。</target>
        </trans-unit>
        <trans-unit id="39aa49db7f4958819165d85870c4e3056a314158" translate="yes" xml:space="preserve">
          <source>C-Types Foreign Function Interface (&lt;code&gt;numpy.ctypeslib&lt;/code&gt;)</source>
          <target state="translated">C类型外部函数接口（ &lt;code&gt;numpy.ctypeslib&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="1ee13877e6105fd56e4080481ca6046e3bea7c13" translate="yes" xml:space="preserve">
          <source>C-Types Foreign Function Interface (numpy.ctypeslib)</source>
          <target state="translated">C类型外函数接口(numpy.ctypeslib)</target>
        </trans-unit>
        <trans-unit id="72c1b618d901fa2527c184612af8e5f097445876" translate="yes" xml:space="preserve">
          <source>C-contiguous or simply contiguous arrays when data is stored row-wise, i.e. indexing of data as stored in memory starts from the highest dimension.</source>
          <target state="translated">当数据以行为单位存储时,C-连续或简称为连续数组,即存储在内存中的数据的索引从最高维度开始。</target>
        </trans-unit>
        <trans-unit id="bdb65d7a9aa6da6471ba4a02f9d435dd19d2ae5a" translate="yes" xml:space="preserve">
          <source>C-order</source>
          <target state="translated">C-order</target>
        </trans-unit>
        <trans-unit id="8bbf8c25cb421fee0bffcb1218c14c15435923a5" translate="yes" xml:space="preserve">
          <source>C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.</source>
          <target state="translated">C-ordered数组即使是FORTRAN-ordered数组也会显示为False。</target>
        </trans-unit>
        <trans-unit id="18f7fb2659bfefae5fe403809093ff794847eddb" translate="yes" xml:space="preserve">
          <source>C-series coefficients of the integral.</source>
          <target state="translated">积分的C系列系数。</target>
        </trans-unit>
        <trans-unit id="aa3b96b2dd6cb469f06816ec7d846596063a8314" translate="yes" xml:space="preserve">
          <source>C-side of the array interface</source>
          <target state="translated">阵列接口的C端</target>
        </trans-unit>
        <trans-unit id="6e0b67185c9289cda6113607f367a9d9edf7fee3" translate="yes" xml:space="preserve">
          <source>C-struct access</source>
          <target state="translated">C型结构访问</target>
        </trans-unit>
        <trans-unit id="bd0b363c8100c3e0002d75837308df33fee89719" translate="yes" xml:space="preserve">
          <source>C-type names</source>
          <target state="translated">C型名称</target>
        </trans-unit>
        <trans-unit id="af48e472b36161e129dd7edb2b2bd61998b64144" translate="yes" xml:space="preserve">
          <source>C. W. Clenshaw, &amp;ldquo;Chebyshev series for mathematical functions&amp;rdquo;, in &lt;em&gt;National Physical Laboratory Mathematical Tables&lt;/em&gt;, vol. 5, London: Her Majesty&amp;rsquo;s Stationery Office, 1962.</source>
          <target state="translated">CW Clenshaw，&amp;ldquo; Chebyshev数学函数系列&amp;rdquo;，在&lt;em&gt;国家物理实验室数学表中&lt;/em&gt;，第1卷。5，伦敦：英国女王Her下办公室，1962年。</target>
        </trans-unit>
        <trans-unit id="43beb2dca45ea5b86cf6e2c78e1df08bb1062e1a" translate="yes" xml:space="preserve">
          <source>C99-like complex functions have been added. Those can be used if you wish to implement portable C extensions. Since we still support platforms without C99 complex type, you need to restrict to C90-compatible syntax, e.g.:</source>
          <target state="translated">增加了类似于C99的复杂函数,如果你想实现可移植的C语言扩展,可以使用这些函数。如果你想实现可移植的C扩展,可以使用这些函数。由于我们仍然支持没有C99复合类型的平台,所以你需要限制在C90兼容的语法上,例如:。</target>
        </trans-unit>
        <trans-unit id="cf46ba2402ead2c46d226454dffcd7ce5ff43524" translate="yes" xml:space="preserve">
          <source>CFFI</source>
          <target state="translated">CFFI</target>
        </trans-unit>
        <trans-unit id="51aa24adb10c8f416d462fb3a5357dabf3e3fd38" translate="yes" xml:space="preserve">
          <source>CFFI + Numba</source>
          <target state="translated">CFFI+Numba</target>
        </trans-unit>
        <trans-unit id="b9f44f432adf98c7d09c95f8b09f92c94663702d" translate="yes" xml:space="preserve">
          <source>CFFI can be used to directly access the functions in &lt;code&gt;include/numpy/random/distributions.h&lt;/code&gt;. Some &amp;ldquo;massaging&amp;rdquo; of the header file is required:</source>
          <target state="translated">CFFI可用于直接访问 &lt;code&gt;include/numpy/random/distributions.h&lt;/code&gt; 中的功能。头文件的某些&amp;ldquo;按摩&amp;rdquo;是必需的：</target>
        </trans-unit>
        <trans-unit id="ebba6dc140f09bcbb9638f5bf4b3df884108c2f7" translate="yes" xml:space="preserve">
          <source>CFFI interface</source>
          <target state="translated">CFFI接口</target>
        </trans-unit>
        <trans-unit id="a36da1e151b2b0823e662d5b8eaaa38259edebce" translate="yes" xml:space="preserve">
          <source>CI extended with additional services</source>
          <target state="translated">传播和信息部扩大了服务范围,增加了服务内容</target>
        </trans-unit>
        <trans-unit id="6821c968895aca188636e67b589fcc004a8bbd12" translate="yes" xml:space="preserve">
          <source>CPU arch detection</source>
          <target state="translated">CPU拱门检测</target>
        </trans-unit>
        <trans-unit id="1ade62840c85639fb7384a1d18b950f273e9fb48" translate="yes" xml:space="preserve">
          <source>CPU architecture of the platform; only one of the above is defined.</source>
          <target state="translated">平台的CPU架构;以上只定义了一个。</target>
        </trans-unit>
        <trans-unit id="70b1c54ffd0a791d6e36e2ee0d98c9acf4b031e8" translate="yes" xml:space="preserve">
          <source>CPU features and other options are case-insensitive.</source>
          <target state="translated">CPU功能和其他选项不区分大小写。</target>
        </trans-unit>
        <trans-unit id="19b3426c923b3e7b1cdee4b651f488f72bf3c78b" translate="yes" xml:space="preserve">
          <source>CXX</source>
          <target state="translated">CXX</target>
        </trans-unit>
        <trans-unit id="c9cddb0fc26555bd7e44c82c30b8dd03f9efdf7e" translate="yes" xml:space="preserve">
          <source>C_CONTIGUOUS / C / CONTIGUOUS</source>
          <target state="translated">C_CONTIGUOUS/C/CONTIGUOUS</target>
        </trans-unit>
        <trans-unit id="0ce3a73aca867f2538f5c735d732291c3a6e377f" translate="yes" xml:space="preserve">
          <source>Caches in &lt;code&gt;np.fft&lt;/code&gt; are now bounded in total size and item count</source>
          <target state="translated">现在， &lt;code&gt;np.fft&lt;/code&gt; 中的缓存的总大小和项目数是有界的</target>
        </trans-unit>
        <trans-unit id="f3d5846dd99b124383ff0d457d07594b45e6712e" translate="yes" xml:space="preserve">
          <source>Calculate &lt;code&gt;2**p&lt;/code&gt; for all &lt;code&gt;p&lt;/code&gt; in the input array.</source>
          <target state="translated">为输入数组中的所有 &lt;code&gt;p&lt;/code&gt; 计算 &lt;code&gt;2**p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="250bbdf8f96508ded0e2419aede1c85ce8e60f69" translate="yes" xml:space="preserve">
          <source>Calculate &lt;code&gt;2**x&lt;/code&gt; for all elements in the array.</source>
          <target state="translated">为数组中的所有元素计算 &lt;code&gt;2**x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80c054468bb32b1733a38bd9e500e3c7e2410c60" translate="yes" xml:space="preserve">
          <source>Calculate &lt;code&gt;exp(x) - 1&lt;/code&gt; for all elements in the array.</source>
          <target state="translated">为数组中的所有元素计算 &lt;code&gt;exp(x) - 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="897a0bcc51e675340eb8de452d794c61bbe86ad4" translate="yes" xml:space="preserve">
          <source>Calculate the absolute value element-wise.</source>
          <target state="translated">按元素计算绝对值。</target>
        </trans-unit>
        <trans-unit id="52d855325ad8b8ba2e5f03ed06faa393dd2b3c5d" translate="yes" xml:space="preserve">
          <source>Calculate the exponential of all elements in the input array.</source>
          <target state="translated">计算输入数组中所有元素的指数。</target>
        </trans-unit>
        <trans-unit id="a3dc7bdd6edd5fbaf2d2ff0fab2c5a4b13186ce0" translate="yes" xml:space="preserve">
          <source>Calculate the generalized inverse of a matrix using its singular-value decomposition (SVD) and including all &lt;em&gt;large&lt;/em&gt; singular values.</source>
          <target state="translated">使用其奇异值分解（SVD）并包括所有&lt;em&gt;大&lt;/em&gt;奇异值来计算矩阵的广义逆。</target>
        </trans-unit>
        <trans-unit id="4b25208e5ebec1248ee411c25859b5c2fd7bb09b" translate="yes" xml:space="preserve">
          <source>Calculate the n-th discrete difference along given axis.</source>
          <target state="translated">计算沿给定轴的第n次离散差。</target>
        </trans-unit>
        <trans-unit id="42cb44e98b4304fa793f5c2a54298181fdecfa02" translate="yes" xml:space="preserve">
          <source>Calculate the n-th discrete difference along the given axis.</source>
          <target state="translated">计算沿给定轴的第n次离散差。</target>
        </trans-unit>
        <trans-unit id="1c03f8fb0f5af1d1f5a42484860a4bc9ada64002" translate="yes" xml:space="preserve">
          <source>Calculate the standard deviation of the non-NaN values.</source>
          <target state="translated">计算非纳米值的标准差。</target>
        </trans-unit>
        <trans-unit id="f8c757cfbde7655c0c48030d0cc0f2a47e05c8b1" translate="yes" xml:space="preserve">
          <source>Calculate the standard deviation of these values.</source>
          <target state="translated">计算这些数值的标准差。</target>
        </trans-unit>
        <trans-unit id="7c1b58f3d94fc67cd514e1570aa6b12719e32b56" translate="yes" xml:space="preserve">
          <source>Calculate the t statistic, setting the ddof parameter to the unbiased value so the divisor in the standard deviation will be degrees of freedom, N-1.</source>
          <target state="translated">计算t统计量,设置ddof参数为无偏值,所以标准差中的除数将是自由度,N-1。</target>
        </trans-unit>
        <trans-unit id="a8acd54a675004438176e793d314e80390eec770" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;1/x&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;1/x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5f90663e28e9982e7de271dda336040dea8f7aa" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;element in test_elements&lt;/code&gt;, broadcasting over &lt;code&gt;element&lt;/code&gt; only.</source>
          <target state="translated">计算 &lt;code&gt;element in test_elements&lt;/code&gt; &lt;code&gt;element&lt;/code&gt; 仅在元素上广播。</target>
        </trans-unit>
        <trans-unit id="c2efd3cd9b667cce814af0fcbaac60b64cdcdb35" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;element in test_elements&lt;/code&gt;, broadcasting over &lt;code&gt;element&lt;/code&gt; only. Returns a boolean array of the same shape as &lt;code&gt;element&lt;/code&gt; that is True where an element of &lt;code&gt;element&lt;/code&gt; is in &lt;code&gt;test_elements&lt;/code&gt; and False otherwise.</source>
          <target state="translated">计算 &lt;code&gt;element in test_elements&lt;/code&gt; &lt;code&gt;element&lt;/code&gt; 仅在元素上广播。返回与 &lt;code&gt;element&lt;/code&gt; 具有相同形状的布尔数组，如果元素的 &lt;code&gt;element&lt;/code&gt; 在 &lt;code&gt;test_elements&lt;/code&gt; 中，则返回True，否则返回 False。</target>
        </trans-unit>
        <trans-unit id="74b05ed646884364ea61a52a0d97dd5553fc5db3" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;log(1 + x)&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;log(1 + x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="793634569b16ddadf09c84f21826d340c4bb186b" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;log(exp(x1) + exp(x2))&lt;/code&gt;. This function is useful in statistics where the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers. In such cases the logarithm of the calculated probability is stored. This function allows adding probabilities stored in such a fashion.</source>
          <target state="translated">计算 &lt;code&gt;log(exp(x1) + exp(x2))&lt;/code&gt; 。此函数在统计中非常有用，在统计中，事件的计算概率可能很小，以至于超出了正常浮点数的范围。在这种情况下，将存储计算出的概率的对数。该功能允许以这种方式添加存储的概率。</target>
        </trans-unit>
        <trans-unit id="55306f441c10b288ef594152ca5bc10ba426774f" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;log2(2**x1 + 2**x2)&lt;/code&gt;. This function is useful in machine learning when the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers. In such cases the base-2 logarithm of the calculated probability can be used instead. This function allows adding probabilities stored in such a fashion.</source>
          <target state="translated">计算 &lt;code&gt;log2(2**x1 + 2**x2)&lt;/code&gt; 。当计算的事件概率可能很小以至于超过正常浮点数的范围时，此功能在机器学习中很有用。在这种情况下，可以代替使用计算出的概率的以2为底的对数。该功能允许以这种方式添加存储的概率。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
