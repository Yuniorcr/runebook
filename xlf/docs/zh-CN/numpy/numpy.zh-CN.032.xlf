<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="19399207372e8d7c054365b0a529ccf2981f3b82" translate="yes" xml:space="preserve">
          <source>vectorized string operations are provided as methods (e.g. &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.endswith.html#numpy.chararray.endswith&quot;&gt;&lt;code&gt;endswith&lt;/code&gt;&lt;/a&gt;) and infix operators (e.g. &lt;code&gt;&quot;+&quot;, &quot;*&quot;, &quot;%&quot;&lt;/code&gt;)</source>
          <target state="translated">提供向量化字符串操作作为方法（例如，&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.endswith.html#numpy.chararray.endswith&quot;&gt; &lt;code&gt;endswith&lt;/code&gt; &lt;/a&gt;）和中缀运算符（例如， &lt;code&gt;&quot;+&quot;, &quot;*&quot;, &quot;%&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6b72c98ed88bb4df85be360c468c57b064be204e" translate="yes" xml:space="preserve">
          <source>vectorized string operations are provided as methods (e.g. &lt;a href=&quot;numpy.char.chararray.endswith#numpy.char.chararray.endswith&quot;&gt;&lt;code&gt;endswith&lt;/code&gt;&lt;/a&gt;) and infix operators (e.g. &lt;code&gt;&quot;+&quot;, &quot;*&quot;, &quot;%&quot;&lt;/code&gt;)</source>
          <target state="translated">提供向量化字符串操作作为方法（例如，&lt;a href=&quot;numpy.char.chararray.endswith#numpy.char.chararray.endswith&quot;&gt; &lt;code&gt;endswith&lt;/code&gt; &lt;/a&gt;）和中缀运算符（例如， &lt;code&gt;&quot;+&quot;, &quot;*&quot;, &quot;%&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="db454313195f316238acd17aeb5d938f4db3f3f4" translate="yes" xml:space="preserve">
          <source>vectorized string operations are provided as methods (e.g. &lt;a href=&quot;numpy.chararray.endswith#numpy.chararray.endswith&quot;&gt;&lt;code&gt;endswith&lt;/code&gt;&lt;/a&gt;) and infix operators (e.g. &lt;code&gt;&quot;+&quot;, &quot;*&quot;, &quot;%&quot;&lt;/code&gt;)</source>
          <target state="translated">提供向量化的字符串操作作为方法（例如，&lt;a href=&quot;numpy.chararray.endswith#numpy.chararray.endswith&quot;&gt; &lt;code&gt;endswith&lt;/code&gt; &lt;/a&gt;）和中缀运算符（例如， &lt;code&gt;&quot;+&quot;, &quot;*&quot;, &quot;%&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="b595ca1ad64c45adbaa59fe3b6b7fb1e998d72d6" translate="yes" xml:space="preserve">
          <source>vectorized string operations are provided as methods (e.g. &lt;code&gt;str.endswith&lt;/code&gt;) and infix operators (e.g. &lt;code&gt;+, *, %&lt;/code&gt;)</source>
          <target state="translated">提供向量化的字符串操作作为方法（例如 &lt;code&gt;str.endswith&lt;/code&gt; ）和中缀运算符（例如 &lt;code&gt;+, *, %&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e122cd45e8e9df8c348e263b4143f2a68e76e98d" translate="yes" xml:space="preserve">
          <source>vectorized string operations are provided as methods (e.g. &lt;code&gt;str.endswith&lt;/code&gt;) and infix operators (e.g. &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;,``%``)</source>
          <target state="translated">提供向量化的字符串操作作为方法（例如 &lt;code&gt;str.endswith&lt;/code&gt; ）和中缀运算符（例如 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ，&amp;ldquo;％''）</target>
        </trans-unit>
        <trans-unit id="c692273deb2772da307ffe37041fef77bf4baa97" translate="yes" xml:space="preserve">
          <source>version</source>
          <target state="translated">version</target>
        </trans-unit>
        <trans-unit id="bfd190f5456486754027935ce9caa900beed7ccd" translate="yes" xml:space="preserve">
          <source>version:</source>
          <target state="translated">version:</target>
        </trans-unit>
        <trans-unit id="66e0e1037f3cc463bf7e6212024c466ab215fa03" translate="yes" xml:space="preserve">
          <source>very fast when it optimizes well</source>
          <target state="translated">优化得好的话,速度非常快</target>
        </trans-unit>
        <trans-unit id="8f3a07543988e4673dcae5e59c35323c5791f370" translate="yes" xml:space="preserve">
          <source>view</source>
          <target state="translated">view</target>
        </trans-unit>
        <trans-unit id="aaafdd472f0b52f4b28e53842ae8095cfe8dc805" translate="yes" xml:space="preserve">
          <source>view() (numpy.char.chararray method)</source>
          <target state="translated">view()(numpy.char.chararray方法)</target>
        </trans-unit>
        <trans-unit id="2ab098e314c8c4907b0cbf15c46523c5f4564351" translate="yes" xml:space="preserve">
          <source>views returned from np.einsum are writeable</source>
          <target state="translated">从np.einsum返回的视图是可写的。</target>
        </trans-unit>
        <trans-unit id="4fc1ae3e178d0efaeaff5106a735070367cc2e3b" translate="yes" xml:space="preserve">
          <source>virtualenv (pip)</source>
          <target state="translated">virtualenv (pip)</target>
        </trans-unit>
        <trans-unit id="e9cede9b80ea3abd89c755f1117337d429162c86" translate="yes" xml:space="preserve">
          <source>void</source>
          <target state="translated">void</target>
        </trans-unit>
        <trans-unit id="48b1339239922b5e07d5ce4184fcf5e87effde2b" translate="yes" xml:space="preserve">
          <source>von Mises, R., &amp;ldquo;Mathematical Theory of Probability and Statistics&amp;rdquo;, New York: Academic Press, 1964.</source>
          <target state="translated">冯&amp;middot;米塞斯（R. von Mises），&amp;ldquo;概率论和统计学的数学理论&amp;rdquo;，纽约：学术出版社，1964年。</target>
        </trans-unit>
        <trans-unit id="9ae5fe8b31c05755c850ae4d90a3fcb76c2a182a" translate="yes" xml:space="preserve">
          <source>vonmises() (in module numpy.random)</source>
          <target state="translated">vonmises()(在模块numpy.random中)</target>
        </trans-unit>
        <trans-unit id="d7e5b9982ea5d22fcf5a1d1ad3376fc5a48e7c9d" translate="yes" xml:space="preserve">
          <source>vsplit() (in module numpy)</source>
          <target state="translated">vsplit()(在模块numpy中)</target>
        </trans-unit>
        <trans-unit id="99c757c8afc5629a307995e13f88bb23fe068b80" translate="yes" xml:space="preserve">
          <source>vstack (in module numpy.ma)</source>
          <target state="translated">vstack(在numpy.ma模块中)</target>
        </trans-unit>
        <trans-unit id="15311d1f0df12d81853bd7c190c65a543b943872" translate="yes" xml:space="preserve">
          <source>vstack() (in module numpy)</source>
          <target state="translated">vstack()(在模块numpy中)</target>
        </trans-unit>
        <trans-unit id="6cd1107921db5bd5aa7000a30d16d502418e2ec3" translate="yes" xml:space="preserve">
          <source>wald() (in module numpy.random)</source>
          <target state="translated">wald()(在模块numpy.random中)</target>
        </trans-unit>
        <trans-unit id="3ddc3bec9c70c5c7e765cd8cf5fa5aa389917ef0" translate="yes" xml:space="preserve">
          <source>warn: Print a &lt;code&gt;RuntimeWarning&lt;/code&gt; (via the Python &lt;a href=&quot;https://docs.python.org/dev/library/warnings.html#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">警告：打印 &lt;code&gt;RuntimeWarning&lt;/code&gt; &lt;a href=&quot;https://docs.python.org/dev/library/warnings.html#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt;（通过Python 警告模块）。</target>
        </trans-unit>
        <trans-unit id="4884fd1a3cb1606444975d3740d56633fa35ad1b" translate="yes" xml:space="preserve">
          <source>we can build the approximation by doing</source>
          <target state="translated">我们可以通过以下方式建立近似值</target>
        </trans-unit>
        <trans-unit id="c0ee32d825d6ddb4025ab74af0609969ecc419c8" translate="yes" xml:space="preserve">
          <source>week</source>
          <target state="translated">week</target>
        </trans-unit>
        <trans-unit id="bc2615c16c37f07d240c50d07bfd867058aaeb3e" translate="yes" xml:space="preserve">
          <source>weekmask (numpy.busdaycalendar attribute)</source>
          <target state="translated">周密(numpy.busdaycalendar属性)</target>
        </trans-unit>
        <trans-unit id="c6f09c0d1d993f2a543feb0ac90ea8458105cb1e" translate="yes" xml:space="preserve">
          <source>weibull() (in module numpy.random)</source>
          <target state="translated">weibull()(在模块numpy.random中)</target>
        </trans-unit>
        <trans-unit id="a2a0b13381d4d5d8e14bc62eb1948f61052d27ce" translate="yes" xml:space="preserve">
          <source>what are the names of the &amp;ldquo;&lt;a href=&quot;../glossary#term-field&quot;&gt;fields&lt;/a&gt;&amp;rdquo; of the structure, by which they can be &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;accessed&lt;/a&gt;,</source>
          <target state="translated">该结构的&amp;ldquo;&lt;a href=&quot;../glossary#term-field&quot;&gt;字段&lt;/a&gt;&amp;rdquo;的名称是什么，通过它们可以&lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;访问&lt;/a&gt;它们，</target>
        </trans-unit>
        <trans-unit id="916d4dfd40fa788d4f97c5cbd19732b935ee5e9e" translate="yes" xml:space="preserve">
          <source>what are the names of the &amp;ldquo;&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;fields&lt;/a&gt;&amp;rdquo; of the structure, by which they can be &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;accessed&lt;/a&gt;,</source>
          <target state="translated">该结构的&amp;ldquo; &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;字段&lt;/a&gt; &amp;rdquo; 的名称是什么，通过它们可以&lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;访问&lt;/a&gt;它们，</target>
        </trans-unit>
        <trans-unit id="4bdf2c9a9320c2bb30296f2a5be0fd38903dcd4d" translate="yes" xml:space="preserve">
          <source>what exactly &lt;code&gt;seq&lt;/code&gt; is. Is it a single value to be altered in-place? Is it an array, and if so what is its length? Is it input-only? Output-only? Input-output? &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; cannot determine these details, and does not attempt to do so.</source>
          <target state="translated">&lt;code&gt;seq&lt;/code&gt; 到底是什么。就地更改是单个值吗？它是数组吗？如果是，它的长度是多少？它是仅输入的吗？仅输出？输入输出？&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;无法确定这些详细信息，也不会尝试这样做。</target>
        </trans-unit>
        <trans-unit id="0380a220e77d143346e4de9f7efc19cb89f002b0" translate="yes" xml:space="preserve">
          <source>what is the data-type of each &lt;a href=&quot;../glossary#term-field&quot;&gt;field&lt;/a&gt;, and</source>
          <target state="translated">每个&lt;a href=&quot;../glossary#term-field&quot;&gt;字段&lt;/a&gt;的数据类型是什么，以及</target>
        </trans-unit>
        <trans-unit id="52be18891fe12a3ccc69a948daf4a9df395f8160" translate="yes" xml:space="preserve">
          <source>what is the data-type of each &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;field&lt;/a&gt;, and</source>
          <target state="translated">每个&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;字段&lt;/a&gt;的数据类型是什么，以及</target>
        </trans-unit>
        <trans-unit id="d0192f6d7a8d53807254215b637508c53444c530" translate="yes" xml:space="preserve">
          <source>when &lt;code&gt;i = len(indices) - 1&lt;/code&gt; (so for the last index), &lt;code&gt;indices[i+1] = a.shape[axis]&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;i = len(indices) - 1&lt;/code&gt; （所以对于最后一个索引）时， &lt;code&gt;indices[i+1] = a.shape[axis]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec1e659fd8ee011943e5f3a9c49fd36000cceebd" translate="yes" xml:space="preserve">
          <source>when &lt;code&gt;i = len(indices) - 1&lt;/code&gt; (so for the last index), &lt;code&gt;indices[i+1] = array.shape[axis]&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;i = len(indices) - 1&lt;/code&gt; （所以对于最后一个索引）时， &lt;code&gt;indices[i+1] = array.shape[axis]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5297e650e9c08f060e1e619f5312964757572aef" translate="yes" xml:space="preserve">
          <source>when building Numpy. The following 64-bit BLAS/LAPACK libraries are supported:</source>
          <target state="translated">当构建Numpy时,支持以下64位BLAS/LAPACK库:支持以下64位BLAS/LAPACK库。</target>
        </trans-unit>
        <trans-unit id="5722cd99f39f9db8b61fbc3c1c82b426d3cd79fd" translate="yes" xml:space="preserve">
          <source>when investigating further and asking for support.</source>
          <target state="translated">在进一步调查和请求支持时。</target>
        </trans-unit>
        <trans-unit id="46148cc3b4d2b3ac8073f14b0cba7f25ffff54bd" translate="yes" xml:space="preserve">
          <source>where</source>
          <target state="translated">where</target>
        </trans-unit>
        <trans-unit id="cfaf285482cf6c4f89cd534ed09bc1fa065bdd59" translate="yes" xml:space="preserve">
          <source>where &amp;lt;package install directory&amp;gt; is the package (or sub-package) directory such as &amp;lsquo;/usr/lib/python2.4/site-packages/mypackage&amp;rsquo; (&amp;lsquo;C: Python2.4 Lib site-packages mypackage&amp;rsquo;) or &amp;lsquo;/usr/lib/python2.4/site- packages/mypackage/mysubpackage&amp;rsquo; (&amp;lsquo;C: Python2.4 Lib site-packages mypackage mysubpackage&amp;rsquo;).</source>
          <target state="translated">其中，&amp;lt;package install directory&amp;gt;是软件包（或子软件包）目录，例如&amp;ldquo; /usr/lib/python2.4/site-packages/mypackage&amp;rdquo;（&amp;ldquo;C：Python2.4 Lib site-packages mypackage&amp;rdquo;）或&amp;ldquo; /usr/lib/python2.4/site-packages/mypackage/mysubpackage'（'C：Python2.4 Lib site-packages mypackage mysubpackage'）。</target>
        </trans-unit>
        <trans-unit id="15b93f3fc1f372444d0c3a34d4013852d05253ac" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;&amp;lt;args&amp;gt;=string.join(&amp;lt;list&amp;gt;,' ')&lt;/code&gt;, but in Python. Unless &lt;code&gt;-h&lt;/code&gt; is used, this function returns a dictionary containing information on generated modules and their dependencies on source files. For example, the command &lt;code&gt;f2py -m scalar scalar.f&lt;/code&gt; can be executed from Python as follows</source>
          <target state="translated">其中 &lt;code&gt;&amp;lt;args&amp;gt;=string.join(&amp;lt;list&amp;gt;,' ')&lt;/code&gt; ，但在Python中。除非使用 &lt;code&gt;-h&lt;/code&gt; ，否则此函数将返回一个字典，其中包含有关生成的模块及其对源文件的依赖关系的信息。例如，命令 &lt;code&gt;f2py -m scalar scalar.f&lt;/code&gt; 可以从Python执行，如下所示</target>
        </trans-unit>
        <trans-unit id="82814f25ca2293053d415c5e9086a2d82cae615d" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;--bench&lt;/code&gt; activates the benchmark suite instead of the test suite. This builds NumPy and runs all available benchmarks defined in &lt;code&gt;benchmarks/&lt;/code&gt;. (Note: this could take a while. Each benchmark is run multiple times to measure the distribution in execution times.)</source>
          <target state="translated">其中 &lt;code&gt;--bench&lt;/code&gt; 激活基准套件，而不是测试套件。这将构建NumPy并运行在 &lt;code&gt;benchmarks/&lt;/code&gt; 定义的所有可用基准。 （注意：这可能需要一段时间。每个基准测试都会运行多次，以衡量执行时间的分布。）</target>
        </trans-unit>
        <trans-unit id="27722a8f94c49a1d17c79d2d98a28d7cd4fd50e2" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the elements of &lt;code&gt;x&lt;/code&gt; and the last index is the degree of the Chebyshev polynomial.</source>
          <target state="translated">其中 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 的前导索引将 &lt;code&gt;x&lt;/code&gt; 的元素索引，最后一个索引是Chebyshev多项式的次数。</target>
        </trans-unit>
        <trans-unit id="833860b51f45a74ee06a8481e7b59dec2776a9c5" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the elements of &lt;code&gt;x&lt;/code&gt; and the last index is the degree of the Hermite polynomial.</source>
          <target state="translated">其中 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 的前导索引将 &lt;code&gt;x&lt;/code&gt; 的元素索引，最后一个索引是Hermite多项式的次数。</target>
        </trans-unit>
        <trans-unit id="c69795dbab93fd4905d0bc022d8ac56b6e1e0f54" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the elements of &lt;code&gt;x&lt;/code&gt; and the last index is the degree of the HermiteE polynomial.</source>
          <target state="translated">其中 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 的前导索引将 &lt;code&gt;x&lt;/code&gt; 的元素索引，最后一个索引是HermiteE多项式的次数。</target>
        </trans-unit>
        <trans-unit id="bde30796ed968ed7657f0df45af477fbb40047da" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the elements of &lt;code&gt;x&lt;/code&gt; and the last index is the degree of the Laguerre polynomial.</source>
          <target state="translated">其中 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 的前导索引将 &lt;code&gt;x&lt;/code&gt; 的元素索引，最后一个索引是Laguerre多项式的次数。</target>
        </trans-unit>
        <trans-unit id="c6b4ff5c9a6986803c5708a92c411c4b253dec9c" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the elements of &lt;code&gt;x&lt;/code&gt; and the last index is the degree of the Legendre polynomial.</source>
          <target state="translated">其中 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 的前导索引将 &lt;code&gt;x&lt;/code&gt; 的元素索引，最后一个索引是Legendre多项式的次数。</target>
        </trans-unit>
        <trans-unit id="538f7fb88a53c793cea30da00779237a649749e0" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the elements of &lt;code&gt;x&lt;/code&gt; and the last index is the power of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">其中 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 的前导索引将 &lt;code&gt;x&lt;/code&gt; 的元素索引，最后一个索引是 &lt;code&gt;x&lt;/code&gt; 的幂。</target>
        </trans-unit>
        <trans-unit id="4de9c198e8ca08018e505031f38efeea306eb563" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y)&lt;/code&gt; and the last index encodes the degrees of the Chebyshev polynomials.</source>
          <target state="translated">其中 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; 和 &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 的前导索引对点 &lt;code&gt;(x, y)&lt;/code&gt; 进行索引，最后一个索引对Chebyshev多项式的次数进行编码。</target>
        </trans-unit>
        <trans-unit id="9c023f7138aa8d794b6a146fabd54c47a0508cbe" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y)&lt;/code&gt; and the last index encodes the degrees of the Hermite polynomials.</source>
          <target state="translated">其中 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; 和 &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 的前导索引对点 &lt;code&gt;(x, y)&lt;/code&gt; 进行索引，最后一个索引对Hermite多项式的次数进行编码。</target>
        </trans-unit>
        <trans-unit id="d3cf2ba80598064afebb705d3f96da951d339ad7" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y)&lt;/code&gt; and the last index encodes the degrees of the HermiteE polynomials.</source>
          <target state="translated">其中 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; 和 &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 的前导索引对点 &lt;code&gt;(x, y)&lt;/code&gt; 进行索引，最后一个索引对HermiteE多项式的次数进行编码。</target>
        </trans-unit>
        <trans-unit id="931ddf7a677dd0bb054e68bb0682795a7ecb2d44" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y)&lt;/code&gt; and the last index encodes the degrees of the Laguerre polynomials.</source>
          <target state="translated">其中 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; 和 &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 的前导索引对点 &lt;code&gt;(x, y)&lt;/code&gt; 进行索引，最后一个索引对Laguerre多项式的次数进行编码。</target>
        </trans-unit>
        <trans-unit id="5b4f668563e3498fcf093b6cc70e0bf28243dbb5" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y)&lt;/code&gt; and the last index encodes the degrees of the Legendre polynomials.</source>
          <target state="translated">其中 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; 和 &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 的前导索引对点 &lt;code&gt;(x, y)&lt;/code&gt; 进行索引，最后一个索引对Legendre多项式的次数进行编码。</target>
        </trans-unit>
        <trans-unit id="ae534bb750508bd12922fca33e07ed9e9147c7d1" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y)&lt;/code&gt; and the last index encodes the powers of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">其中 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; 和 &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 的前导索引对点 &lt;code&gt;(x, y)&lt;/code&gt; 进行索引，最后一个索引对 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的幂进行编码。</target>
        </trans-unit>
        <trans-unit id="968a8f99ae65dc781347987604737e4885f0347e" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt;, &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y, z)&lt;/code&gt; and the last index encodes the degrees of the Chebyshev polynomials.</source>
          <target state="translated">其中 &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt; ， &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt; 和 &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 的前导索引对点 &lt;code&gt;(x, y, z)&lt;/code&gt; 进行索引，最后一个索引对Chebyshev多项式的次数进行编码。</target>
        </trans-unit>
        <trans-unit id="290595042428a0adec26dcab062e9c72d203d119" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt;, &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y, z)&lt;/code&gt; and the last index encodes the degrees of the Hermite polynomials.</source>
          <target state="translated">其中 &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt; ， &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt; 和 &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 的前导索引对点 &lt;code&gt;(x, y, z)&lt;/code&gt; 进行索引，最后一个索引对Hermite多项式的次数进行编码。</target>
        </trans-unit>
        <trans-unit id="a3522d9ec4777ff57457a39fea3d27eb87e001f3" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt;, &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y, z)&lt;/code&gt; and the last index encodes the degrees of the HermiteE polynomials.</source>
          <target state="translated">其中 &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt; ， &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt; 和 &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 的前导索引对点 &lt;code&gt;(x, y, z)&lt;/code&gt; 进行索引，最后一个索引对HermiteE多项式的次数进行编码。</target>
        </trans-unit>
        <trans-unit id="e21aabee789ef859247cb7d579e69b9306ad94e9" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt;, &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y, z)&lt;/code&gt; and the last index encodes the degrees of the Laguerre polynomials.</source>
          <target state="translated">其中 &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt; ， &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt; 和 &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 的前导索引对点 &lt;code&gt;(x, y, z)&lt;/code&gt; 进行索引，最后一个索引对Laguerre多项式的次数进行编码。</target>
        </trans-unit>
        <trans-unit id="0fec4bcf4d4a798ecc63d7a8b21b974ec59ac767" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt;, &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y, z)&lt;/code&gt; and the last index encodes the degrees of the Legendre polynomials.</source>
          <target state="translated">其中 &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt; ， &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt; 和 &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 的前导索引对点 &lt;code&gt;(x, y, z)&lt;/code&gt; 进行索引，最后一个索引对Legendre多项式的次数进行编码。</target>
        </trans-unit>
        <trans-unit id="ef93d8eb54977daa7c98c55d5dde9a9422edf21b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt;, &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y, z)&lt;/code&gt; and the last index encodes the powers of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">其中 &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt; ， &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt; 和 &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt; 。 &lt;code&gt;V&lt;/code&gt; 的前导索引对点 &lt;code&gt;(x, y, z)&lt;/code&gt; 进行索引，最后一个索引对 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 的幂进行编码。</target>
        </trans-unit>
        <trans-unit id="907ece41fc35a24200255d27b81c13eb4a497bd2" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;GITHUB&lt;/code&gt; contains your github access token. This text may also be appended to &lt;code&gt;doc/release/1.14.5-notes.rst&lt;/code&gt; for release updates, though not for new releases like &lt;code&gt;1.14.0&lt;/code&gt;, as the changelogs for &lt;code&gt;*.0&lt;/code&gt; releases tend to be excessively long. The &lt;code&gt;doc/source/release.rst&lt;/code&gt; file should also be updated with a link to the new release notes. These changes should be committed to the maintenance branch, and later will be forward ported to master.</source>
          <target state="translated">其中 &lt;code&gt;GITHUB&lt;/code&gt; 包含您的GitHub的访问令牌。文本也可以附加到 &lt;code&gt;doc/release/1.14.5-notes.rst&lt;/code&gt; 中,以进行发行更新，但不用于 &lt;code&gt;1.14.0&lt;/code&gt; 之类的新发行，因为 &lt;code&gt;*.0&lt;/code&gt; 发行的变更日志往往太长。该 &lt;code&gt;doc/source/release.rst&lt;/code&gt; 文件应该也可以用链接到新的发行说明更新。这些更改应提交给维护分支，以后再转发给master。</target>
        </trans-unit>
        <trans-unit id="607e911964b92bbf30094d82119ac7da068f0db1" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;GITHUB&lt;/code&gt; contains your github access token. This text may also be appended to &lt;code&gt;doc/release/1.19.0-notes.rst&lt;/code&gt; for patch release, though not for new releases like &lt;code&gt;1.19.0&lt;/code&gt;, as the changelogs for &lt;code&gt;*.0&lt;/code&gt; releases tend to be excessively long. The &lt;code&gt;doc/source/release.rst&lt;/code&gt; file should also be updated with a link to the new release notes. These changes should be committed to the maintenance branch, and later will be forward ported to master. The changelog should be reviewed for name duplicates or short names and the &lt;code&gt;.mailmap&lt;/code&gt; file updated if needed.</source>
          <target state="translated">其中 &lt;code&gt;GITHUB&lt;/code&gt; 包含您的GitHub的访问令牌。该文本也可以附加到 &lt;code&gt;doc/release/1.19.0-notes.rst&lt;/code&gt; 中以进行补丁发布，但不适用于 &lt;code&gt;1.19.0&lt;/code&gt; 之类的新版本，因为 &lt;code&gt;*.0&lt;/code&gt; 版本的变更日志往往会过长。该 &lt;code&gt;doc/source/release.rst&lt;/code&gt; 文件应该也可以用链接到新的发行说明更新。这些更改应提交给维护分支，以后再转发给master。应该检查 &lt;code&gt;.mailmap&lt;/code&gt; 日志中是否存在名称重复或简称，并根据需要更新.mailmap文件。</target>
        </trans-unit>
        <trans-unit id="4b8c6ec18c2c43533633b2d6348c84d0e98e4282" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;V&lt;/code&gt; is the pseudo Vandermonde matrix of &lt;code&gt;x&lt;/code&gt;, the elements of &lt;code&gt;c&lt;/code&gt; are the coefficients to be solved for, and the elements of &lt;code&gt;y&lt;/code&gt; are the observed values. This equation is then solved using the singular value decomposition of &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">其中 &lt;code&gt;V&lt;/code&gt; 是 &lt;code&gt;x&lt;/code&gt; 的伪范德蒙德矩阵， &lt;code&gt;c&lt;/code&gt; 的元素是要求解的系数， &lt;code&gt;y&lt;/code&gt; 的元素是观测值。然后使用 &lt;code&gt;V&lt;/code&gt; 的奇异值分解求解该方程。</target>
        </trans-unit>
        <trans-unit id="bed15d23c255396f5ff96e362455881dfb6045bf" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;V&lt;/code&gt; is the weighted pseudo Vandermonde matrix of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; are the coefficients to be solved for, &lt;code&gt;w&lt;/code&gt; are the weights, &lt;code&gt;y&lt;/code&gt; are the observed values. This equation is then solved using the singular value decomposition of &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">其中 &lt;code&gt;V&lt;/code&gt; 是 &lt;code&gt;x&lt;/code&gt; 的加权伪Vandermonde矩阵， &lt;code&gt;c&lt;/code&gt; 是要求解的系数， &lt;code&gt;w&lt;/code&gt; 是权重， &lt;code&gt;y&lt;/code&gt; 是观测值。然后使用 &lt;code&gt;V&lt;/code&gt; 的奇异值分解求解该方程。</target>
        </trans-unit>
        <trans-unit id="d134ecc4ceb9149fc7a25fccd08e5a7a0a731874" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;V&lt;/code&gt; is the weighted pseudo Vandermonde matrix of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; are the coefficients to be solved for, &lt;code&gt;w&lt;/code&gt; are the weights, and &lt;code&gt;y&lt;/code&gt; are the observed values. This equation is then solved using the singular value decomposition of &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">其中 &lt;code&gt;V&lt;/code&gt; 是 &lt;code&gt;x&lt;/code&gt; 的加权伪Vandermonde矩阵， &lt;code&gt;c&lt;/code&gt; 是要求解的系数， &lt;code&gt;w&lt;/code&gt; 是权重， &lt;code&gt;y&lt;/code&gt; 是观测值。然后使用 &lt;code&gt;V&lt;/code&gt; 的奇异值分解求解该方程。</target>
        </trans-unit>
        <trans-unit id="6cd5aea9272d9238144e1f9f8fbb6ec55a2f9e37" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;_i[&amp;lt;i&amp;gt;]&lt;/code&gt; refers to the &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt;-th index value and that runs from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;shape(&amp;lt;array name&amp;gt;,&amp;lt;i&amp;gt;)-1&lt;/code&gt;.</source>
          <target state="translated">其中 &lt;code&gt;_i[&amp;lt;i&amp;gt;]&lt;/code&gt; 指第 &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; 个索引值，并且从 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;shape(&amp;lt;array name&amp;gt;,&amp;lt;i&amp;gt;)-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6ef8bc2bec31043ebddcd21aa113fe148170b4b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;n == len(roots) - 1&lt;/code&gt;; note that this implies that &lt;code&gt;1&lt;/code&gt; is always returned for</source>
          <target state="translated">其中 &lt;code&gt;n == len(roots) - 1&lt;/code&gt; ; 请注意，这意味着总是返回 &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4156f50382951be2ffb97afbef02067c099be6a8" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;deg&lt;/code&gt;.</source>
          <target state="translated">其中 &lt;code&gt;n&lt;/code&gt; 是 &lt;code&gt;deg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5da8ce8d8d1ee0181c57af0f31c56ab31f259987" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;n&lt;/code&gt; is the number of streams spawned. If a program uses an aggressive million streams, about</source>
          <target state="translated">其中 &lt;code&gt;n&lt;/code&gt; 是产生的流的数量。如果某个程序使用了激进的数百万个流，则大约</target>
        </trans-unit>
        <trans-unit id="227e7320c448b66cb7c7d238597d7f3a2804dfcf" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;p&lt;/code&gt; is the probability of success of an individual trial.</source>
          <target state="translated">其中 &lt;code&gt;p&lt;/code&gt; 是单个试验成功的概率。</target>
        </trans-unit>
        <trans-unit id="97e11a7633599dcc0b171bd3aeedc2980516829b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;seq&lt;/code&gt; would be a NumPy array of &lt;code&gt;double&lt;/code&gt; values, and its length &lt;code&gt;n&lt;/code&gt; would be extracted from &lt;code&gt;seq&lt;/code&gt; internally before being passed to the C routine. Even better, since NumPy supports construction of arrays from arbitrary Python sequences, &lt;code&gt;seq&lt;/code&gt; itself could be a nearly arbitrary sequence (so long as each element can be converted to a &lt;code&gt;double&lt;/code&gt;) and the wrapper code would internally convert it to a NumPy array before extracting its data and length.</source>
          <target state="translated">其中 &lt;code&gt;seq&lt;/code&gt; 是 &lt;code&gt;double&lt;/code&gt; 精度值的NumPy数组，其长度 &lt;code&gt;n&lt;/code&gt; 将在传递给C例程之前从 &lt;code&gt;seq&lt;/code&gt; 内部提取。更好的是，由于NumPy支持从任意Python序列构造数组，因此 &lt;code&gt;seq&lt;/code&gt; 本身可以是几乎任意的序列（只要每个元素都可以转换为 &lt;code&gt;double&lt;/code&gt; ），并且包装程序代码会在提取其内部内容之前将其内部转换为NumPy数组数据和长度。</target>
        </trans-unit>
        <trans-unit id="f02a66bece2f0610117ed2e55b338b497ee6a2f1" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;subdtype&lt;/code&gt; is the subclass. Thus the returned view is of the same class as the subclass, rather than being of class &lt;code&gt;ndarray&lt;/code&gt;.</source>
          <target state="translated">其中 &lt;code&gt;subdtype&lt;/code&gt; 是子类。因此，返回的视图与子类属于同一类，而不是 &lt;code&gt;ndarray&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="75e868ab11f1f9e4c58bc8e76e5d240947af7c46" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;upstream&lt;/code&gt; points to the main &lt;a href=&quot;https://github.com/numpy/numpy.git&quot;&gt;https://github.com/numpy/numpy.git&lt;/a&gt; repository.</source>
          <target state="translated">其中 &lt;code&gt;upstream&lt;/code&gt; 点到主&lt;a href=&quot;https://github.com/numpy/numpy.git&quot;&gt;https://github.com/numpy/numpy.git&lt;/a&gt;库。</target>
        </trans-unit>
        <trans-unit id="3fa7dcc068f2c1b22079c4e51b9b1d150978fe4d" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;x2&lt;/code&gt; is often taken to be 0.5, but 0 and 1 are also sometimes used.</source>
          <target state="translated">其中 &lt;code&gt;x2&lt;/code&gt; 通常取为0.5，但有时也使用0和1。</target>
        </trans-unit>
        <trans-unit id="6a9eda89bfd511983f4021317b7dd5833b1e827e" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;{bits}&lt;/code&gt; is the number of bits in the type and can be &lt;strong&gt;8&lt;/strong&gt;, &lt;strong&gt;16&lt;/strong&gt;, &lt;strong&gt;32&lt;/strong&gt;, &lt;strong&gt;64&lt;/strong&gt;, 128, and 256 for integer types; 16, &lt;strong&gt;32&lt;/strong&gt; , &lt;strong&gt;64&lt;/strong&gt;, 80, 96, 128, and 256 for floating-point types; and 32, &lt;strong&gt;64&lt;/strong&gt;, &lt;strong&gt;128&lt;/strong&gt;, 160, 192, and 512 for complex-valued types. Which bit-widths are available is platform dependent. The bolded bit-widths are usually available on all platforms.</source>
          <target state="translated">其中 &lt;code&gt;{bits}&lt;/code&gt; 在类型比特的数目，并且可以是&lt;strong&gt;8&lt;/strong&gt;，&lt;strong&gt;16&lt;/strong&gt;，&lt;strong&gt;32&lt;/strong&gt;，&lt;strong&gt;64&lt;/strong&gt;，128，和256为整数类型; 16，&lt;strong&gt;32&lt;/strong&gt;，&lt;strong&gt;64&lt;/strong&gt;，80，96，128，和256对浮点类型; 和32，&lt;strong&gt;64&lt;/strong&gt;，&lt;strong&gt;128&lt;/strong&gt;，160，192和512为复值的类型。哪些位宽可用取决于平台。加粗的位宽通常在所有平台上都可用。</target>
        </trans-unit>
        <trans-unit id="cdc8cdc0932dfe2cf825eb22285d6dc4584efd79" translate="yes" xml:space="preserve">
          <source>where &lt;strong&gt;I&lt;/strong&gt; is the &lt;code&gt;n&lt;/code&gt;-by-&lt;code&gt;n&lt;/code&gt; identity matrix. &lt;a href=&quot;#r6c2ffae921d1-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;</source>
          <target state="translated">其中&lt;strong&gt;I&lt;/strong&gt;是 &lt;code&gt;n&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 单位矩阵。&lt;a href=&quot;#r6c2ffae921d1-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9d65fe7270866ad53495d99232a820922277569" translate="yes" xml:space="preserve">
          <source>where R is a non-nan real value. Complex values with the same nan placements are sorted according to the non-nan part if it exists. Non-nan values are sorted as before.</source>
          <target state="translated">其中R为非nan实值。具有相同nan位置的复数值根据非nan部分(如果存在)进行排序。非nan值的排序与之前相同。</target>
        </trans-unit>
        <trans-unit id="c9686487c569c31836e68bc642e39a9e040607c0" translate="yes" xml:space="preserve">
          <source>where allowed comment characters for fixed and free format Fortran codes are &lt;code&gt;cC*!#&lt;/code&gt; and &lt;code&gt;!&lt;/code&gt;, respectively. Everything that follows &lt;code&gt;&amp;lt;comment char&amp;gt;f2py&lt;/code&gt; is ignored by a compiler but read by F2PY as a normal Fortran, non-comment line:</source>
          <target state="translated">固定和自由格式Fortran代码的允许注释字符为 &lt;code&gt;cC*!#&lt;/code&gt; 和 &lt;code&gt;!&lt;/code&gt; ， 分别。编译器将忽略 &lt;code&gt;&amp;lt;comment char&amp;gt;f2py&lt;/code&gt; 之后的所有内容，但由F2PY读取为常规的Fortran非注释行：</target>
        </trans-unit>
        <trans-unit id="9c3f870a9647b89f8d84edc93a3e3a7701994db4" translate="yes" xml:space="preserve">
          <source>where filename is a path relative to the reference guide source directory.</source>
          <target state="translated">其中文件名是相对于参考指南源目录的路径。</target>
        </trans-unit>
        <trans-unit id="5caa3907f70cffcfedf3fb4994a98de6a74be54f" translate="yes" xml:space="preserve">
          <source>where in this case the</source>
          <target state="translated">其中</target>
        </trans-unit>
        <trans-unit id="a0047659d01e6a2429cd941ed10ecc15806ec5e4" translate="yes" xml:space="preserve">
          <source>where p = probability.</source>
          <target state="translated">其中p=概率。</target>
        </trans-unit>
        <trans-unit id="ca92675847cdd29f796e592505c1d46281fcc976" translate="yes" xml:space="preserve">
          <source>where the</source>
          <target state="translated">其中</target>
        </trans-unit>
        <trans-unit id="53fc0cd37ec015722cb1c47e4ca053728ac6eba6" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;r_n&lt;/code&gt; are the roots specified in &lt;a href=&quot;numpy.roots#numpy.roots&quot;&gt;&lt;code&gt;roots&lt;/code&gt;&lt;/a&gt;. If a zero has multiplicity n, then it must appear in &lt;a href=&quot;numpy.roots#numpy.roots&quot;&gt;&lt;code&gt;roots&lt;/code&gt;&lt;/a&gt; n times. For instance, if 2 is a root of multiplicity three and 3 is a root of multiplicity 2, then &lt;a href=&quot;numpy.roots#numpy.roots&quot;&gt;&lt;code&gt;roots&lt;/code&gt;&lt;/a&gt; looks something like [2, 2, 2, 3, 3]. The roots can appear in any order.</source>
          <target state="translated">其中 &lt;code&gt;r_n&lt;/code&gt; 是roots中指定的&lt;a href=&quot;numpy.roots#numpy.roots&quot;&gt; &lt;code&gt;roots&lt;/code&gt; &lt;/a&gt;。如果零具有多重性n，那么它必须在&lt;a href=&quot;numpy.roots#numpy.roots&quot;&gt; &lt;code&gt;roots&lt;/code&gt; &lt;/a&gt;出现n次。例如，如果2是多重性3的根，而3是多重性2的根，则该&lt;a href=&quot;numpy.roots#numpy.roots&quot;&gt; &lt;code&gt;roots&lt;/code&gt; &lt;/a&gt;看起来像[2、2、2、3、3]。根可以以任何顺序出现。</target>
        </trans-unit>
        <trans-unit id="2c1ce56b739d1a90c6c7a8decdd89da276904513" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;r_n&lt;/code&gt; are the roots specified in &lt;code&gt;roots&lt;/code&gt;. If a zero has multiplicity n, then it must appear in &lt;code&gt;roots&lt;/code&gt; n times. For instance, if 2 is a root of multiplicity three and 3 is a root of multiplicity 2, then &lt;code&gt;roots&lt;/code&gt; looks something like [2, 2, 2, 3, 3]. The roots can appear in any order.</source>
          <target state="translated">其中 &lt;code&gt;r_n&lt;/code&gt; 是roots中指定的 &lt;code&gt;roots&lt;/code&gt; 。如果零具有多重性n，那么它必须在 &lt;code&gt;roots&lt;/code&gt; 出现n次。例如，如果2是多重性3的根，而3是多重性2的根，则该 &lt;code&gt;roots&lt;/code&gt; 看起来类似于[2，2，2，3，3]。根可以以任何顺序出现。</target>
        </trans-unit>
        <trans-unit id="de25e1e31fb8e144046ff201f8ad1ae5facb6b87" translate="yes" xml:space="preserve">
          <source>where the normalization, B, is the beta function,</source>
          <target state="translated">其中归一化,B为β函数。</target>
        </trans-unit>
        <trans-unit id="1279820475c803c32a1be658737be93ee2a97148" translate="yes" xml:space="preserve">
          <source>where the points &lt;code&gt;(a, b)&lt;/code&gt; consist of all pairs formed by taking &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from &lt;code&gt;y&lt;/code&gt;. The resulting points form a grid with &lt;code&gt;x&lt;/code&gt; in the first dimension and &lt;code&gt;y&lt;/code&gt; in the second.</source>
          <target state="translated">点 &lt;code&gt;(a, b)&lt;/code&gt; 包括通过从 &lt;code&gt;x&lt;/code&gt; 取 &lt;code&gt;a&lt;/code&gt; 和从 &lt;code&gt;y&lt;/code&gt; 取 &lt;code&gt;b&lt;/code&gt; 形成的所有对。所得的点形成一个网格，其中第一个维度为 &lt;code&gt;x&lt;/code&gt; ，第二个维度为 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6af8e5313e77ee7d6837ec79be794a7042e7075" translate="yes" xml:space="preserve">
          <source>where the points &lt;code&gt;(a, b, c)&lt;/code&gt; consist of all triples formed by taking &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; from &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; from &lt;code&gt;z&lt;/code&gt;. The resulting points form a grid with &lt;code&gt;x&lt;/code&gt; in the first dimension, &lt;code&gt;y&lt;/code&gt; in the second, and &lt;code&gt;z&lt;/code&gt; in the third.</source>
          <target state="translated">其中点 &lt;code&gt;(a, b, c)&lt;/code&gt; 包括通过取形成的所有的三元组的 &lt;code&gt;a&lt;/code&gt; 从 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 从 &lt;code&gt;y&lt;/code&gt; ，和 &lt;code&gt;c&lt;/code&gt; 从 &lt;code&gt;z&lt;/code&gt; 。结果点形成一个网格，其中第一个维度为 &lt;code&gt;x&lt;/code&gt; ，第二个维度为 &lt;code&gt;y&lt;/code&gt; ，第三个维度为 &lt;code&gt;z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83bfe9a2efafb46b83cd23b5c8266a3fd8781bb3" translate="yes" xml:space="preserve">
          <source>where() (in module numpy)</source>
          <target state="translated">where()(在numpy模块中)</target>
        </trans-unit>
        <trans-unit id="365862a50c0682caa8baa6f30edca76e3e5f81ed" translate="yes" xml:space="preserve">
          <source>where:</source>
          <target state="translated">where:</target>
        </trans-unit>
        <trans-unit id="bee8de4d18b018e76e45831ecaa774c3f734bfce" translate="yes" xml:space="preserve">
          <source>whether or not you have multiple versions of Python installed</source>
          <target state="translated">您是否安装了多个版本的 Python</target>
        </trans-unit>
        <trans-unit id="e37dbee4cae0df6201c1f4811e9b9537f69aabb6" translate="yes" xml:space="preserve">
          <source>which evaluates to:</source>
          <target state="translated">其评价为:</target>
        </trans-unit>
        <trans-unit id="a01e140cc92cbe722c0b95c684104ebb6b342985" translate="yes" xml:space="preserve">
          <source>which extends in the obvious way to higher dimensions, and the inverses in higher dimensions also extend in the same way.</source>
          <target state="translated">它以明显的方式延伸到更高的维度,在更高的维度上的反演也以同样的方式延伸。</target>
        </trans-unit>
        <trans-unit id="ced4c5cabdd3ef65db772d8c6ef758745f7d3e32" translate="yes" xml:space="preserve">
          <source>which is different from a common alternative,</source>
          <target state="translated">这与常见的替代方案不同。</target>
        </trans-unit>
        <trans-unit id="84e2d073d86e6b4b5f8c8391549685b60c7e4b55" translate="yes" xml:space="preserve">
          <source>which is not the right shape for showing the image. Finally, reordering the axes back to our original shape of &lt;code&gt;(768, 1024, 3)&lt;/code&gt;, we can see our approximation:</source>
          <target state="translated">这不是显示图像的正确形状。最后，将轴重新排序为我们的原始形状 &lt;code&gt;(768, 1024, 3)&lt;/code&gt; ，我们可以看到近似值：</target>
        </trans-unit>
        <trans-unit id="9ee66060f3ffdf52489d6d257097e268641308e4" translate="yes" xml:space="preserve">
          <source>which is related to &lt;code&gt;c_{av}[k]&lt;/code&gt; by &lt;code&gt;c'_{av}[k] = c_{av}[-k]&lt;/code&gt;.</source>
          <target state="translated">这是关系到 &lt;code&gt;c_{av}[k]&lt;/code&gt; 由 &lt;code&gt;c'_{av}[k] = c_{av}[-k]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="778d43b6da6e59d12f7b859a3d029062778f7c7d" translate="yes" xml:space="preserve">
          <source>which part of the memory block each field takes.</source>
          <target state="translated">每个字段占内存块的哪一部分。</target>
        </trans-unit>
        <trans-unit id="03234ac0a2f49221ceb858c5491d51de84061ef9" translate="yes" xml:space="preserve">
          <source>which provides 5 pointers. The first is an opaque pointer to the data structure used by the BitGenerators. The next three are function pointers which return the next 64- and 32-bit unsigned integers, the next random double and the next raw value. This final function is used for testing and so can be set to the next 64-bit unsigned integer function if not needed. Functions inside &lt;code&gt;Generator&lt;/code&gt; use this structure as in</source>
          <target state="translated">提供5个指针。第一个是BitGenerators使用的数据结构的不透明指针。接下来的三个是函数指针，它们返回下一个64位和32位无符号整数，下一个随机双精度数和下一个原始值。该最终函数用于测试，因此如果不需要，可以将其设置为下一个64位无符号整数函数。 &lt;code&gt;Generator&lt;/code&gt; 中的函数使用此结构，如下所示</target>
        </trans-unit>
        <trans-unit id="d47c4daeb44b47194663061e95cd8003350155df" translate="yes" xml:space="preserve">
          <source>which renders as &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;:</source>
          <target state="translated">呈现为&lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="670381f53d7dde4b658afc72fb1f03743b30325f" translate="yes" xml:space="preserve">
          <source>which should be used for new code.</source>
          <target state="translated">应该用于新代码。</target>
        </trans-unit>
        <trans-unit id="9c7c5f596971b2cd6617c86437a81292c06ddf91" translate="yes" xml:space="preserve">
          <source>which should be used in new code</source>
          <target state="translated">在新代码中应该使用</target>
        </trans-unit>
        <trans-unit id="376b56642da39094e74a99573c74c162327692be" translate="yes" xml:space="preserve">
          <source>which will rebuild NumPy, install it to a temporary location, and build the documentation in all formats. This will most likely again only work on Unix platforms.</source>
          <target state="translated">这将重建NumPy,将其安装到一个临时位置,并建立所有格式的文档。这很有可能再次只在Unix平台上工作。</target>
        </trans-unit>
        <trans-unit id="63577216ef75495c55551997ebb50867df34281b" translate="yes" xml:space="preserve">
          <source>which would have provided automatic type conversions for arrays of type &lt;code&gt;Py_complex&lt;/code&gt;, &lt;code&gt;npy_cfloat&lt;/code&gt; and &lt;code&gt;npy_cdouble&lt;/code&gt;. However, it seemed unlikely that there would be any independent (non-Python, non-NumPy) application code that people would be using &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; to generate a Python interface to, that also used these definitions for complex types. More likely, these application codes will define their own complex types, or in the case of C++, use &lt;code&gt;std::complex&lt;/code&gt;. Assuming these data structures are compatible with Python and NumPy complex types, &lt;code&gt;%numpy_typemap&lt;/code&gt; expansions as above (with the user&amp;rsquo;s complex type substituted for the first argument) should work.</source>
          <target state="translated">它将为 &lt;code&gt;Py_complex&lt;/code&gt; ， &lt;code&gt;npy_cfloat&lt;/code&gt; 和 &lt;code&gt;npy_cdouble&lt;/code&gt; 类型的数组提供自动类型转换。但是，似乎不太可能会有人们使用&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;生成Python接口的独立（非Python，非NumPy）应用程序代码，这些代码也将这些定义用于复杂类型。这些应用程序代码将更有可能定义自己的复杂类型，或者在C ++中，使用 &lt;code&gt;std::complex&lt;/code&gt; 。假设这些数据结构与Python和NumPy复杂类型兼容，则如上所述的 &lt;code&gt;%numpy_typemap&lt;/code&gt; 扩展（将用户的复杂类型替换为第一个参数）应该起作用。</target>
        </trans-unit>
        <trans-unit id="aad927bf697b386bb3e4f9b23016432e840fc725" translate="yes" xml:space="preserve">
          <source>who() (in module numpy)</source>
          <target state="translated">谁()</target>
        </trans-unit>
        <trans-unit id="2776b6c93cb7c4153849413953e56a2e5f33d80a" translate="yes" xml:space="preserve">
          <source>width:</source>
          <target state="translated">width:</target>
        </trans-unit>
        <trans-unit id="13bce647c8362fa91ee40694295febf34b1ec7fe" translate="yes" xml:space="preserve">
          <source>will allow using anything &lt;strong&gt;but&lt;/strong&gt; NetLIB BLAS and ATLAS libraries, the order of the above list is retained.</source>
          <target state="translated">将允许使用任何东西&lt;strong&gt;，但&lt;/strong&gt;NETLIB的BLAS和ATLAS库，上面列表的顺序被保留。</target>
        </trans-unit>
        <trans-unit id="27fa578bb2dbcc1e48218589e15dc33381c7adf2" translate="yes" xml:space="preserve">
          <source>will allow using anything &lt;strong&gt;but&lt;/strong&gt; the NetLIB LAPACK library, the order of the above list is retained.</source>
          <target state="translated">将允许使用任何东西&lt;strong&gt;，但&lt;/strong&gt;在NETLIB LAPACK库，上面列表的顺序被保留。</target>
        </trans-unit>
        <trans-unit id="9fabe3e5adc197f1aefb22a24a130eff8c2333b8" translate="yes" xml:space="preserve">
          <source>will build two extension modules &lt;code&gt;scalar&lt;/code&gt; and &lt;code&gt;fib2&lt;/code&gt; to the build directory.</source>
          <target state="translated">将在构建目录中构建两个扩展模块 &lt;code&gt;scalar&lt;/code&gt; 和 &lt;code&gt;fib2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2344e686feb0404839466210c31bd50c5f4d1ab2" translate="yes" xml:space="preserve">
          <source>will cause a program crash on most systems. Under the covers, the lists are being converted to proper arrays but then the underlying add loop is told to cycle way beyond the borders of the allocated memory.</source>
          <target state="translated">会导致大多数系统的程序崩溃。掩盖之下,列表被转换为适当的数组,但随后底层的加法循环被告知要循环到超出所分配内存的边界。</target>
        </trans-unit>
        <trans-unit id="5c7e83ac1040b10c50be2504c71c5845f663b6fd" translate="yes" xml:space="preserve">
          <source>will compile the &lt;code&gt;library&lt;/code&gt; sources without optimization flags.</source>
          <target state="translated">将编译没有优化标志的 &lt;code&gt;library&lt;/code&gt; 源代码。</target>
        </trans-unit>
        <trans-unit id="51356c12b39d1c2e5b60995f4d65e090afd1cd6f" translate="yes" xml:space="preserve">
          <source>will create an &lt;code&gt;alias&lt;/code&gt; section in your &lt;code&gt;.gitconfig&lt;/code&gt; file with contents like this:</source>
          <target state="translated">将在您的 &lt;code&gt;.gitconfig&lt;/code&gt; 文件中创建一个 &lt;code&gt;alias&lt;/code&gt; 部分，其内容如下：</target>
        </trans-unit>
        <trans-unit id="8d20a2ce8660814e46481f17cf57f185c268fa43" translate="yes" xml:space="preserve">
          <source>will install data files to the following locations</source>
          <target state="translated">将数据文件安装到以下位置</target>
        </trans-unit>
        <trans-unit id="9431832ed81f189de77da34df58a265d7a0dab02" translate="yes" xml:space="preserve">
          <source>will install these data files to:</source>
          <target state="translated">将这些数据文件安装到。</target>
        </trans-unit>
        <trans-unit id="65f2fae653365ee5c4440c9cc9c2d032f733a63a" translate="yes" xml:space="preserve">
          <source>will need to be changed. This code has raised a &lt;code&gt;FutureWarning&lt;/code&gt; since Numpy 1.12, and similar code has raised &lt;code&gt;FutureWarning&lt;/code&gt; since 1.7.</source>
          <target state="translated">将需要进行更改。此代码已经提出了 &lt;code&gt;FutureWarning&lt;/code&gt; 因为numpy的1.12，以及类似的代码已经提出 &lt;code&gt;FutureWarning&lt;/code&gt; 自1.7。</target>
        </trans-unit>
        <trans-unit id="c48dc5d80033d088b313d555b44339bd63ffba66" translate="yes" xml:space="preserve">
          <source>will output the difference from G to C (i.e. with effects of F and G), while:</source>
          <target state="translated">将输出G到C的差值(即有F和G的影响),而。</target>
        </trans-unit>
        <trans-unit id="98b3c1b6f0363b4b36389d5d1b18d315d36840fd" translate="yes" xml:space="preserve">
          <source>will prefer to use ATLAS, then BLIS, then OpenBLAS and as a last resort MKL. If neither of these exists the build will fail (names are compared lower case).</source>
          <target state="translated">会更倾向于使用ATLAS,然后是BLIS,然后是OpenBLAS,最后才是MKL。如果这两者都不存在,那么构建就会失败(名字会比较小写)。</target>
        </trans-unit>
        <trans-unit id="6b43fee04276950efbf0354e10bfe96ae5f91c4b" translate="yes" xml:space="preserve">
          <source>will prefer to use ATLAS, then OpenBLAS and as a last resort MKL. If neither of these exists the build will fail (names are compared lower case).</source>
          <target state="translated">会更倾向于使用ATLAS,然后是OpenBLAS,最后才是MKL。如果这两种方法都不存在,那么构建就会失败(名字会比较小写)。</target>
        </trans-unit>
        <trans-unit id="fcf97db7680020e322957977ba54cdaae4e7c664" translate="yes" xml:space="preserve">
          <source>will result in typemaps that will produce code that reference improper data lengths. You can implement the following macro expansion:</source>
          <target state="translated">会导致类型映射,产生引用不正确数据长度的代码。你可以实现下面的宏扩展。</target>
        </trans-unit>
        <trans-unit id="d09fffb5db2d7f631ba43ccc256617b444056d2e" translate="yes" xml:space="preserve">
          <source>win32</source>
          <target state="translated">win32</target>
        </trans-unit>
        <trans-unit id="273e334ec36853f9f9a05c2de34faba48191ff1f" translate="yes" xml:space="preserve">
          <source>window (numpy.polynomial.chebyshev.Chebyshev attribute)</source>
          <target state="translated">窗口(numpy.polynomial.chebyshev.Chebyshev属性)</target>
        </trans-unit>
        <trans-unit id="8fcd25a39d2037183044a8897e9a5333d727fded" translate="yes" xml:space="preserve">
          <source>with</source>
          <target state="translated">with</target>
        </trans-unit>
        <trans-unit id="85906e975567ef059f93ee1ec6cded27b66be258" translate="yes" xml:space="preserve">
          <source>with a and v sequences being zero-padded where necessary and conj being the conjugate.</source>
          <target state="translated">必要时,a和v序列为零垫,conj为共轭。</target>
        </trans-unit>
        <trans-unit id="fb4da7b2e3434f85dca212e250f77b33115633d3" translate="yes" xml:space="preserve">
          <source>with assert_warns(SomeWarning):</source>
          <target state="translated">与 assert_warns(SomeWarning)。</target>
        </trans-unit>
        <trans-unit id="198054914927940c04570defb3a1b48438d7e3f0" translate="yes" xml:space="preserve">
          <source>with similar code for &lt;code&gt;cadd&lt;/code&gt;, &lt;code&gt;dadd&lt;/code&gt;, and &lt;code&gt;sadd&lt;/code&gt; that handles complex float, double, and float data-types, respectively:</source>
          <target state="translated">使用 &lt;code&gt;cadd&lt;/code&gt; ， &lt;code&gt;dadd&lt;/code&gt; 和 &lt;code&gt;sadd&lt;/code&gt; 的相似代码分别处理复杂的float，double和float数据类型：</target>
        </trans-unit>
        <trans-unit id="0080f1a2ae1b166b68400bbd8e3bf2ad9b849c08" translate="yes" xml:space="preserve">
          <source>with the elements of &lt;code&gt;s&lt;/code&gt; in its diagonal and with the appropriate dimensions for multiplying: in our case,</source>
          <target state="translated">在对角线上带有 &lt;code&gt;s&lt;/code&gt; 的元素，并具有相乘的适当尺寸：在我们的情况下，</target>
        </trans-unit>
        <trans-unit id="475445d83d4b5fb4eb9cadb9634afa9926972eb2" translate="yes" xml:space="preserve">
          <source>with the weight function</source>
          <target state="translated">与权重函数</target>
        </trans-unit>
        <trans-unit id="e9106aaf08247a295732f94cac129b955c2a6cce" translate="yes" xml:space="preserve">
          <source>with their Taylor series expansion, this translates into solving the following the linear system:</source>
          <target state="translated">与它们的泰勒数列展开,这就转化为解决以下线性系统。</target>
        </trans-unit>
        <trans-unit id="e2ac21e5524a785601b5d72a44f59a41ff0de1fa" translate="yes" xml:space="preserve">
          <source>with which we now extract only three elements:</source>
          <target state="translated">现在我们只用它来提取三个元素。</target>
        </trans-unit>
        <trans-unit id="73978edcd3b1eeaba9e3510afd89a742dbbd379c" translate="yes" xml:space="preserve">
          <source>work space</source>
          <target state="translated">工作空间</target>
        </trans-unit>
        <trans-unit id="d664dcdca19ca8d9b446631ef2412473ee2226f1" translate="yes" xml:space="preserve">
          <source>worst case</source>
          <target state="translated">最坏情况</target>
        </trans-unit>
        <trans-unit id="3632e151c760c3c0cb60d7646cc6fdee30ebbafe" translate="yes" xml:space="preserve">
          <source>would output just differences in the topic branch (i.e. only A, B, and C).</source>
          <target state="translated">将只输出主题分支的差异(即只有A、B和C)。</target>
        </trans-unit>
        <trans-unit id="6f1f2b93f598ca8c33b6833c0a41bac0f1e8474a" translate="yes" xml:space="preserve">
          <source>wrap values &amp;lt; 0 by adding len(&lt;em&gt;op&lt;/em&gt;) and values &amp;gt;=len(&lt;em&gt;op&lt;/em&gt;) by subtracting len(&lt;em&gt;op&lt;/em&gt;) until they are in range;</source>
          <target state="translated">涡卷值&amp;lt;0通过加入LEN（&lt;em&gt;OP&lt;/em&gt;）和值&amp;gt; = LEN（&lt;em&gt;OP&lt;/em&gt;）通过减去LEN（&lt;em&gt;OP&lt;/em&gt;），直到它们处于范围;</target>
        </trans-unit>
        <trans-unit id="c4ce690c09e8b66a80dc42798b931fd3f8dfe52d" translate="yes" xml:space="preserve">
          <source>wraps the C library function &lt;code&gt;system()&lt;/code&gt;:</source>
          <target state="translated">包装C库函数 &lt;code&gt;system()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="11f6ad8ec52a2984abaafd7c3b516503785c2072" translate="yes" xml:space="preserve">
          <source>x</source>
          <target state="translated">x</target>
        </trans-unit>
        <trans-unit id="308f064ded46d05826bfd10e2ded24601eb24df9" translate="yes" xml:space="preserve">
          <source>x is equal to linspace(self.domain[0], self.domain[1], n) and y is the series evaluated at element of x.</source>
          <target state="translated">x等于linspace(self.domain[0],self.domain[1],n),y是在x元素处计算的数列。</target>
        </trans-unit>
        <trans-unit id="59dd422e447dd066581be0b92845e52e84b598c5" translate="yes" xml:space="preserve">
          <source>x-coordinates of the &lt;code&gt;M&lt;/code&gt; sample (data) points &lt;code&gt;(x[i], y[i])&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; 个样本（数据）点 &lt;code&gt;(x[i], y[i])&lt;/code&gt; x坐标。</target>
        </trans-unit>
        <trans-unit id="ba94ec9deda2ba79411318119236f9d9739ce86c" translate="yes" xml:space="preserve">
          <source>x-coordinates of the M sample points &lt;code&gt;(x[i], y[i])&lt;/code&gt;.</source>
          <target state="translated">M个采样点 &lt;code&gt;(x[i], y[i])&lt;/code&gt; x坐标。</target>
        </trans-unit>
        <trans-unit id="5cb437551401adf121138e8924c8f0383053f491" translate="yes" xml:space="preserve">
          <source>x.__getitem__(y) &amp;lt;==&amp;gt; x[y]</source>
          <target state="translated">x .__ getitem __（y）&amp;lt;==&amp;gt; x [y]</target>
        </trans-unit>
        <trans-unit id="fdc9be9752ea52874fd39a2bdad0f5823c5b6118" translate="yes" xml:space="preserve">
          <source>x.__setitem__(i, y) &amp;lt;==&amp;gt; x[i]=y</source>
          <target state="translated">x .__ setitem __（i，y）&amp;lt;==&amp;gt; x [i] = y</target>
        </trans-unit>
        <trans-unit id="344b1df0fe46a98fd4e221e42af496e380c32ddf" translate="yes" xml:space="preserve">
          <source>x86 - CPU feature names</source>
          <target state="translated">x86-CPU特征名称</target>
        </trans-unit>
        <trans-unit id="43b450669c7286193c5254c90bdb392eaf23f5db" translate="yes" xml:space="preserve">
          <source>x86 - Group names</source>
          <target state="translated">x86-组名</target>
        </trans-unit>
        <trans-unit id="08295c7bc6ebf5316eef21f8acebd8d7cd029921" translate="yes" xml:space="preserve">
          <source>x86::Intel Compiler - CPU feature names</source>
          <target state="translated">x86::Intel编译器-CPU功能名称</target>
        </trans-unit>
        <trans-unit id="c5d394b1f44c3682fa63a0111665b3afbefe4aea" translate="yes" xml:space="preserve">
          <source>x86::Microsoft Visual C/C++ - CPU feature names</source>
          <target state="translated">x86::Microsoft Visual C/C++-CPU特征名称</target>
        </trans-unit>
        <trans-unit id="da421920ce1bd5a03d063f77e2157e2573edaac2" translate="yes" xml:space="preserve">
          <source>xP_i(x) = (-(i + 1)*P_{i + 1}(x) + (2i + 1)P_{i}(x) - iP_{i - 1}(x))</source>
          <target state="translated">xP_i(x)=(-(i+1)*P_{i+1}(x)+(2i+1)P_{i}(x)-iP_{i-1}(x))</target>
        </trans-unit>
        <trans-unit id="1b073b5ec82f790856556cc378140ccaef2424ed" translate="yes" xml:space="preserve">
          <source>xP_i(x) = (P_{i + 1}(x) + iP_{i - 1}(x)))</source>
          <target state="translated">xP_i(x)=(P_{i+1}(x)+iP_{i-1}(x)))</target>
        </trans-unit>
        <trans-unit id="ef078637a19fed7e5c5fce6ae955f054edcce03b" translate="yes" xml:space="preserve">
          <source>xP_i(x) = (P_{i + 1}(x)/2 + i*P_{i - 1}(x))</source>
          <target state="translated">xP_i(x)=(P_{i+1}(x)/2+i*P_{i-1}(x))</target>
        </trans-unit>
        <trans-unit id="7e771f58043b3b39cee02a1814b5e97f817e4084" translate="yes" xml:space="preserve">
          <source>y : A floating point representation of Not a Number.</source>
          <target state="translated">y:Not a Number的浮点数表示。</target>
        </trans-unit>
        <trans-unit id="fe74eb20b81eed402c9b311b14c54faa75f17f0e" translate="yes" xml:space="preserve">
          <source>y = floor(&lt;code&gt;x1&lt;/code&gt;/&lt;code&gt;x2&lt;/code&gt;) This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">y = floor（ &lt;code&gt;x1&lt;/code&gt; / &lt;code&gt;x2&lt;/code&gt; ）如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="0153765279a24863ca46c77e0a9178c4b4e2152f" translate="yes" xml:space="preserve">
          <source>y is an array of the same subtype as &lt;code&gt;a&lt;/code&gt;, with shape &lt;code&gt;(a.size,)&lt;/code&gt;. Note that matrices are special cased for backward compatibility, if &lt;code&gt;a&lt;/code&gt; is a matrix, then y is a 1-D ndarray.</source>
          <target state="translated">y是与 &lt;code&gt;a&lt;/code&gt; 相同子类型的数组，其形状为 &lt;code&gt;(a.size,)&lt;/code&gt; 。请注意，矩阵是特殊情况下的向后兼容性，如果 &lt;code&gt;a&lt;/code&gt; 是矩阵，则y是一维ndarray。</target>
        </trans-unit>
        <trans-unit id="5d4da4e2a79f33194ecd725a3df53905dab08a90" translate="yes" xml:space="preserve">
          <source>y-coordinates of the M sample points &lt;code&gt;(x[i], y[i])&lt;/code&gt;.</source>
          <target state="translated">M个采样点 &lt;code&gt;(x[i], y[i])&lt;/code&gt; y坐标。</target>
        </trans-unit>
        <trans-unit id="71b29d0659535339d20f2f2d3906d3133889c3fc" translate="yes" xml:space="preserve">
          <source>y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column.</source>
          <target state="translated">样本点的y坐标。通过传入一个二维数组,每列包含一个数据集,可以同时拟合多个共享相同x坐标的样本点数据集。</target>
        </trans-unit>
        <trans-unit id="3c5bcca9b96afa5b616e3604f848cc87a49f687f" translate="yes" xml:space="preserve">
          <source>y-coordinates of the sample points. Several sets of sample points sharing the same x-coordinates can be (independently) fit with one call to &lt;a href=&quot;#numpy.polynomial.polynomial.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; by passing in for &lt;code&gt;y&lt;/code&gt; a 2-D array that contains one data set per column.</source>
          <target state="translated">采样点的y坐标。样本点共享相同的x坐标的几套可以（独立地）配合一个呼叫到&lt;a href=&quot;#numpy.polynomial.polynomial.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt;通过传递在 &lt;code&gt;y&lt;/code&gt; 包含每列一个数据集的2-d阵列。</target>
        </trans-unit>
        <trans-unit id="c246519118cdd1a1151602d948da3fb079223f11" translate="yes" xml:space="preserve">
          <source>y-coordinates of the sample points. Several sets of sample points sharing the same x-coordinates can be (independently) fit with one call to &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; by passing in for &lt;code&gt;y&lt;/code&gt; a 2-D array that contains one data set per column.</source>
          <target state="translated">采样点的y坐标。样本点共享相同的x坐标的几套可以（独立地）配合一个呼叫到&lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt;通过传递在 &lt;code&gt;y&lt;/code&gt; 包含每列一个数据集的2-d阵列。</target>
        </trans-unit>
        <trans-unit id="4ff0b1538469338a0073e2cdaab6a517801b6ab4" translate="yes" xml:space="preserve">
          <source>year</source>
          <target state="translated">year</target>
        </trans-unit>
        <trans-unit id="df1118dd020814fd66ffa05fad743411846bb68c" translate="yes" xml:space="preserve">
          <source>yellow_text() (in module numpy.distutils.misc_util)</source>
          <target state="translated">yellow_text()(在模块numpy.distutils.misc_util中)</target>
        </trans-unit>
        <trans-unit id="fb360f9c09ac8c5edb2f18be5de4e80ea4c430d0" translate="yes" xml:space="preserve">
          <source>yes</source>
          <target state="translated">yes</target>
        </trans-unit>
        <trans-unit id="88e1e34fad9aac1803c28d999922c02344bde475" translate="yes" xml:space="preserve">
          <source>you can use &lt;code&gt;np.unique&lt;/code&gt; to print the unique values in your array:</source>
          <target state="translated">您可以使用 &lt;code&gt;np.unique&lt;/code&gt; 在您的数组中打印唯一值：</target>
        </trans-unit>
        <trans-unit id="8ab429b829aab8de3c0b16635dc4fdd7df6b01db" translate="yes" xml:space="preserve">
          <source>your operating system</source>
          <target state="translated">您的操作系统</target>
        </trans-unit>
        <trans-unit id="321f014e68afc5d27fa673e253b66c1d1a885e28" translate="yes" xml:space="preserve">
          <source>zero-dimensional numpy arrays</source>
          <target state="translated">零维numpy数组</target>
        </trans-unit>
        <trans-unit id="851d6a9d4f40adec7bdb22e6aa7d78c29e7bad48" translate="yes" xml:space="preserve">
          <source>zero-terminated bytes (not recommended)</source>
          <target state="translated">零结束的字节(不推荐)</target>
        </trans-unit>
        <trans-unit id="3f703704e5615124533004024ac41835014b9923" translate="yes" xml:space="preserve">
          <source>zeros (in module numpy.ma)</source>
          <target state="translated">零点(在numpy.ma模块中</target>
        </trans-unit>
        <trans-unit id="03d38f0c14bca6590a27cad020688a8a53013cf8" translate="yes" xml:space="preserve">
          <source>zeros() (in module numpy)</source>
          <target state="translated">zeros()(在numpy模块中)</target>
        </trans-unit>
        <trans-unit id="f79617894be2a60271313f0d6918d0d57f8af46b" translate="yes" xml:space="preserve">
          <source>zeros(shape) will create an array filled with 0 values with the specified shape. The default dtype is float64.</source>
          <target state="translated">zeros(shape)将创建一个包含0个指定形状的值的数组,默认dtype为float64。默认的dtype是float64。</target>
        </trans-unit>
        <trans-unit id="bfb64fa17a2dd83829c97a1d19df887e579e00bf" translate="yes" xml:space="preserve">
          <source>zeros_like() (in module numpy)</source>
          <target state="translated">zeros_like()(在模块numpy中)</target>
        </trans-unit>
        <trans-unit id="1ecf8a17ab7800b6df8335d0e6bba16f16db3bac" translate="yes" xml:space="preserve">
          <source>zfill() (in module numpy.char)</source>
          <target state="translated">zfill()(在模块numpy.char中)</target>
        </trans-unit>
        <trans-unit id="3a4c1e0cb58cf02c936b120b0a676057daae3f59" translate="yes" xml:space="preserve">
          <source>zipf() (in module numpy.random)</source>
          <target state="translated">zipf()(在模块numpy.random中)</target>
        </trans-unit>
        <trans-unit id="7b16e4ea6cc467a3916252ca6ee5a838978ad9b6" translate="yes" xml:space="preserve">
          <source>{&amp;lsquo;&amp;gt;&amp;rsquo;, &amp;lsquo;B&amp;rsquo;} - big endian</source>
          <target state="translated">{'&amp;gt;'，'B'}-大端</target>
        </trans-unit>
        <trans-unit id="b1ed97369b58f912aec9b237bafe79be656e3b50" translate="yes" xml:space="preserve">
          <source>{&amp;lsquo;&amp;gt;&amp;rsquo;, &amp;lsquo;big&amp;rsquo;} - big endian</source>
          <target state="translated">{'&amp;gt;'，'big'}-大端</target>
        </trans-unit>
        <trans-unit id="69450a331083a0b68e4b8ea4f8d3ea5eed96797f" translate="yes" xml:space="preserve">
          <source>{&amp;lsquo;&amp;lt;&amp;rsquo;, &amp;lsquo;L&amp;rsquo;} - little endian</source>
          <target state="translated">{'&amp;lt;'，'L'}-小尾数</target>
        </trans-unit>
        <trans-unit id="837338df0bd2d77a5c9b0a5480413547dfdf02d8" translate="yes" xml:space="preserve">
          <source>{&amp;lsquo;&amp;lt;&amp;rsquo;, &amp;lsquo;little&amp;rsquo;} - little endian</source>
          <target state="translated">{'&amp;lt;'，'little'}-小尾数</target>
        </trans-unit>
        <trans-unit id="4a18b0c9674466129cdcccc0b853d0e7924dffb5" translate="yes" xml:space="preserve">
          <source>{&amp;lsquo;=&amp;rsquo;, &amp;lsquo;N&amp;rsquo;} - native order</source>
          <target state="translated">{'='，'N'}-本机顺序</target>
        </trans-unit>
        <trans-unit id="d8c7bacdfb9bb97d8000c8d86e26ecc69e84c128" translate="yes" xml:space="preserve">
          <source>{&amp;lsquo;|&amp;rsquo;, &amp;lsquo;I&amp;rsquo;} - ignore (no change to byte order)</source>
          <target state="translated">{'|'，'I'}-忽略（不更改字节顺序）</target>
        </trans-unit>
        <trans-unit id="129c2a92772859dd050db619eaedbf46e847091c" translate="yes" xml:space="preserve">
          <source>~n/2</source>
          <target state="translated">~n/2</target>
        </trans-unit>
        <trans-unit id="ff8c31042699d05d07f6e439438f8c8528e3badb" translate="yes" xml:space="preserve">
          <source>~self</source>
          <target state="translated">~self</target>
        </trans-unit>
        <trans-unit id="8105745e3f0510d3e2e069ea766a5a441edea419" translate="yes" xml:space="preserve">
          <source>“descr” : dtype.descr</source>
          <target state="translated">&amp;ldquo; descr&amp;rdquo;：dtype.descr</target>
        </trans-unit>
        <trans-unit id="b7ed67990b9e24b4aacf785a5ce0eac13652bccc" translate="yes" xml:space="preserve">
          <source>⋮</source>
          <target state="translated">⋮</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
