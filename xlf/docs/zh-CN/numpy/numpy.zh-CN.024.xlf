<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="97ab86f3d69d58ce3be53a871603ed078f8824cf" translate="yes" xml:space="preserve">
          <source>To describe the type of scalar data, there are several &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;built-in scalar types&lt;/a&gt; in NumPy for various precision of integers, floating-point numbers, &lt;em&gt;etc&lt;/em&gt;. An item extracted from an array, &lt;em&gt;e.g.&lt;/em&gt;, by indexing, will be a Python object whose type is the scalar type associated with the data type of the array.</source>
          <target state="translated">为了描述标量数据的&lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;类型&lt;/a&gt;，NumPy中有几种内置标量类型，用于整数，浮点数&lt;em&gt;等的&lt;/em&gt;各种精度。从数组（&lt;em&gt;例如&lt;/em&gt;通过索引）提取的项目将是Python对象，其类型是与数组的数据类型关联的标量类型。</target>
        </trans-unit>
        <trans-unit id="44e1fab9f28a4fa50d8975e0a1e46a2e64c1e9dc" translate="yes" xml:space="preserve">
          <source>To determine the type of an array, look at the dtype attribute:</source>
          <target state="translated">要确定一个数组的类型,请看dtype属性。</target>
        </trans-unit>
        <trans-unit id="9f971fbdece5884152a2421faf1e4b6e44db96d0" translate="yes" xml:space="preserve">
          <source>To disable this behaviour and force NumPy to print the entire array, you can change the printing options using &lt;code&gt;set_printoptions&lt;/code&gt;.</source>
          <target state="translated">要禁用此行为并强制NumPy打印整个数组，可以使用 &lt;code&gt;set_printoptions&lt;/code&gt; 更改打印选项。</target>
        </trans-unit>
        <trans-unit id="42815d30b39c91ade5f76679c62182278601bee8" translate="yes" xml:space="preserve">
          <source>To do buffered reduction requires yet another adjustment during the setup. Normally the iterator construction involves copying the first buffer of data from the readable arrays into the buffer. Any reduction operand is readable, so it may be read into a buffer. Unfortunately, initialization of the operand after this buffering operation is complete will not be reflected in the buffer that the iteration starts with, and garbage results will be produced.</source>
          <target state="translated">要进行缓冲区缩减,需要在设置过程中再进行一次调整。通常迭代器的构造包括将第一个缓冲区的数据从可读数组中复制到缓冲区中。任何还原操作数都是可读的,所以可以将其读入缓冲区。遗憾的是,在这个缓冲操作完成后,操作数的初始化将不会反映在迭代开始的缓冲区中,并且会产生垃圾结果。</target>
        </trans-unit>
        <trans-unit id="7bb73bf7d0560f6eb01b8f605dab2705b707dec2" translate="yes" xml:space="preserve">
          <source>To do this we need two files. The first is the C file which contains the actual code, and the second is the setup.py file used to create the module.</source>
          <target state="translated">要做到这一点,我们需要两个文件。第一个是包含实际代码的C文件,第二个是用于创建模块的setup.py文件。</target>
        </trans-unit>
        <trans-unit id="2a3fff7f3035206492b3a95d3cbf852432de0dee" translate="yes" xml:space="preserve">
          <source>To enable and control broadcasting, use an ellipsis. Default NumPy-style broadcasting is done by adding an ellipsis to the left of each term, like &lt;code&gt;np.einsum('...ii-&amp;gt;...i', a)&lt;/code&gt;. To take the trace along the first and last axes, you can do &lt;code&gt;np.einsum('i...i', a)&lt;/code&gt;, or to do a matrix-matrix product with the left-most indices instead of rightmost, one can do &lt;code&gt;np.einsum('ij...,jk...-&amp;gt;ik...', a, b)&lt;/code&gt;.</source>
          <target state="translated">要启用和控制广播，请使用省略号。默认的NumPy样式广播是通过在每个术语的左侧添加省略号来完成的，例如 &lt;code&gt;np.einsum('...ii-&amp;gt;...i', a)&lt;/code&gt; 。要沿第一个轴和最后一个轴进行跟踪，可以执行 &lt;code&gt;np.einsum('i...i', a)&lt;/code&gt; ，或者使用最左边的索引而不是最右边的索引做矩阵矩阵乘积， &lt;code&gt;np.einsum('ij...,jk...-&amp;gt;ik...', a, b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73e17138c97818c1d4c0e646e333300b5a17a016" translate="yes" xml:space="preserve">
          <source>To enforce summaries when doing merges (&lt;code&gt;~/.gitconfig&lt;/code&gt; file again):</source>
          <target state="translated">合并时要强制执行摘要（再次 &lt;code&gt;~/.gitconfig&lt;/code&gt; 文件）：</target>
        </trans-unit>
        <trans-unit id="03b64a95ca31ed1440ed9609a8efdae966875477" translate="yes" xml:space="preserve">
          <source>To ensure all elements within an &lt;code&gt;object&lt;/code&gt; array are copied, use &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要确保复制 &lt;code&gt;object&lt;/code&gt; 数组中的所有元素，请使用&lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.deepcopy&quot;&gt; &lt;code&gt;copy.deepcopy&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="e7550453146cba531db73646e9c8ba39942085d8" translate="yes" xml:space="preserve">
          <source>To ensure that your code does not have to be compiled for a specific NumPy version, you may add a constant, leaving room for changes in NumPy. A solution guaranteed to be compatible with any future NumPy version requires the use of a runtime calculate offset and allocation size.</source>
          <target state="translated">为了确保你的代码不必为特定的NumPy版本编译,你可以添加一个常量,为NumPy的变化留下空间。保证与任何未来的NumPy版本兼容的解决方案需要使用运行时计算偏移量和分配大小。</target>
        </trans-unit>
        <trans-unit id="56d44cf88fb39b36da11cf8bbe02f976134b23c7" translate="yes" xml:space="preserve">
          <source>To facilitate easy matching of array shapes with expressions and in assignments, the np.newaxis object can be used within array indices to add new dimensions with a size of 1. For example:</source>
          <target state="translated">为了便于将数组形状与表达式和赋值相匹配,np.newaxis对象可以在数组索引中使用,以增加新的尺寸为1的维度。 例如。</target>
        </trans-unit>
        <trans-unit id="09fc0ca575462761f878d637a2fecf46e1ccd71c" translate="yes" xml:space="preserve">
          <source>To facilitate this many similar unit tests, some high-level programming techniques are employed, including C and &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; macros, as well as Python inheritance. The purpose of this document is to describe the testing infrastructure employed to verify that the &lt;code&gt;numpy.i&lt;/code&gt; typemaps are working as expected.</source>
          <target state="translated">为了促进许多类似的单元测试，采用了一些高级编程技术，包括C和&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;宏以及Python继承。本文档的目的是描述用于验证 &lt;code&gt;numpy.i&lt;/code&gt; 类型图是否按预期工作的测试基础结构。</target>
        </trans-unit>
        <trans-unit id="df1248d3a4c3c276bf78a49ecea34ca2333414db" translate="yes" xml:space="preserve">
          <source>To find how many valid days there are in a specified range of datetime64 dates, use &lt;a href=&quot;generated/numpy.busday_count#numpy.busday_count&quot;&gt;&lt;code&gt;busday_count&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要查找在指定的datetime64日期范围内有多少有效天，请使用&lt;a href=&quot;generated/numpy.busday_count#numpy.busday_count&quot;&gt; &lt;code&gt;busday_count&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="319db282e290412afdbf4c23744ae53a90ac551e" translate="yes" xml:space="preserve">
          <source>To find the number of dimensions of the array, run:</source>
          <target state="translated">要查找数组的维数,运行。</target>
        </trans-unit>
        <trans-unit id="f3533d0798888b92292cdc274cd5cbd4e7bdef89" translate="yes" xml:space="preserve">
          <source>To find the total number of elements in the array, run:</source>
          <target state="translated">要查找数组中的元素总数,运行。</target>
        </trans-unit>
        <trans-unit id="381cf7b173efa6d304977d6f48b6eab1589b8ebf" translate="yes" xml:space="preserve">
          <source>To find the union of more than two arrays, use functools.reduce:</source>
          <target state="translated">要找到两个以上数组的联合,使用functools.reduce.commit。</target>
        </trans-unit>
        <trans-unit id="f20ef83823da30eba7178dbce314c99b1ef83b27" translate="yes" xml:space="preserve">
          <source>To get a feel for writing custom array containers, we&amp;rsquo;ll begin with a simple example that has rather narrow utility but illustrates the concepts involved.</source>
          <target state="translated">为了使您有编写自定义数组容器的感觉，我们将以一个简单的示例开始，该示例的实用程序非常狭窄，但说明了其中涉及的概念。</target>
        </trans-unit>
        <trans-unit id="e3a3751da83fe0d7f7a6c4230ed886f73729cca0" translate="yes" xml:space="preserve">
          <source>To get back to a plain ndarray both the dtype and type must be reset. The following view does so, taking into account the unusual case that the recordarr was not a structured type:</source>
          <target state="translated">为了回到普通的ndarray,必须重新设置dtype和type。考虑到 recordarr 不是结构化类型这一特殊情况,下面的视图就可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="4469a3b55f422122d26688e1424f485904a4794e" translate="yes" xml:space="preserve">
          <source>To get the indices of unique values in a NumPy array (an array of first index positions of unique values in the array), just pass the &lt;code&gt;return_index&lt;/code&gt; argument in &lt;code&gt;np.unique()&lt;/code&gt; as well as your array.</source>
          <target state="translated">要获取NumPy数组（数组中唯一值的第一个索引位置的数组）中唯一值的索引，只需在 &lt;code&gt;np.unique()&lt;/code&gt; 中以及数组中传递 &lt;code&gt;return_index&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="f05508b4b1612d928370bd8d22c78ce6740d7d75" translate="yes" xml:space="preserve">
          <source>To get the necessary information for the npymath library from NumPy:</source>
          <target state="translated">从NumPy中获取npymath库的必要信息。</target>
        </trans-unit>
        <trans-unit id="6b92fc58e63db5aa668493a43f6017a9433c467a" translate="yes" xml:space="preserve">
          <source>To get the unique rows, index position, and occurrence count, you can use:</source>
          <target state="translated">要获得唯一的行、索引位置和出现次数,你可以使用。</target>
        </trans-unit>
        <trans-unit id="8cb65420b2ca2983f196bbc9804b56531579abff" translate="yes" xml:space="preserve">
          <source>To group the indices by element, rather than dimension, use &lt;a href=&quot;numpy.argwhere#numpy.argwhere&quot;&gt;&lt;code&gt;argwhere&lt;/code&gt;&lt;/a&gt;, which returns a row for each non-zero element.</source>
          <target state="translated">要将索引按元素而不是维度进行&lt;a href=&quot;numpy.argwhere#numpy.argwhere&quot;&gt; &lt;code&gt;argwhere&lt;/code&gt; &lt;/a&gt;，请使用argwhere，它为每个非零元素返回一行。</target>
        </trans-unit>
        <trans-unit id="dd77da9e3cc0e1b206296360b148e66d7e5bf3e1" translate="yes" xml:space="preserve">
          <source>To group the indices by element, rather than dimension, use instead:</source>
          <target state="translated">要按元素而不是按维度对指数进行分组,请使用。</target>
        </trans-unit>
        <trans-unit id="ee4cd0adbfaa4d4a1d76673c36c93886ead4c8dd" translate="yes" xml:space="preserve">
          <source>To have a particular script file executed when the interactive Python interpreter is started, define the &lt;code&gt;PYTHONSTARTUP&lt;/code&gt; environment variable to contain the name of your startup script.</source>
          <target state="translated">要在启动交互式Python解释器时执行特定的脚本文件，请定义 &lt;code&gt;PYTHONSTARTUP&lt;/code&gt; 环境变量以包含启动脚本的名称。</target>
        </trans-unit>
        <trans-unit id="01fa3621bdaf741ed6a071c7af18f6f77c074d16" translate="yes" xml:space="preserve">
          <source>To implement the second method, NumPy provides the class-factory function &lt;a href=&quot;#ndpointer&quot;&gt;&lt;code&gt;ndpointer&lt;/code&gt;&lt;/a&gt; in the &lt;a href=&quot;../reference/routines.ctypeslib#module-numpy.ctypeslib&quot;&gt;&lt;code&gt;numpy.ctypeslib&lt;/code&gt;&lt;/a&gt; module. This class-factory function produces an appropriate class that can be placed in an argtypes attribute entry of a ctypes function. The class will contain a from_param method which ctypes will use to convert any ndarray passed in to the function to a ctypes-recognized object. In the process, the conversion will perform checking on any properties of the ndarray that were specified by the user in the call to &lt;a href=&quot;#ndpointer&quot;&gt;&lt;code&gt;ndpointer&lt;/code&gt;&lt;/a&gt;. Aspects of the ndarray that can be checked include the data-type, the number-of-dimensions, the shape, and/or the state of the flags on any array passed. The return value of the from_param method is the ctypes attribute of the array which (because it contains the &lt;code&gt;_as_parameter_&lt;/code&gt; attribute pointing to the array data area) can be used by ctypes directly.</source>
          <target state="translated">为了实现第二种方法，NumPy在&lt;a href=&quot;../reference/routines.ctypeslib#module-numpy.ctypeslib&quot;&gt; &lt;code&gt;numpy.ctypeslib&lt;/code&gt; &lt;/a&gt;模块中提供了类工厂函数&lt;a href=&quot;#ndpointer&quot;&gt; &lt;code&gt;ndpointer&lt;/code&gt; &lt;/a&gt;。这个classfactory函数产生一个合适的类，该类可以放在ctypes函数的argtypes属性条目中。该类将包含from_param方法，ctypes将使用该方法将传递给函数的任何ndarray转换为ctypes识别的对象。在此过程中，转换将检查用户在对&lt;a href=&quot;#ndpointer&quot;&gt; &lt;code&gt;ndpointer&lt;/code&gt; &lt;/a&gt;的调用中指定的ndarray的任何属性。可以检查的ndarray的方面包括任何传递的数组上的标志的数据类型，维数，形状和/或状态。from_param方法的返回值是数组的ctypes属性（由于它包含指向数组数据区域的 &lt;code&gt;_as_parameter_&lt;/code&gt; 属性），因此ctypes可以直接使用它。</target>
        </trans-unit>
        <trans-unit id="50d801e69012a04f7e0e0473d58cee9ab38e87fd" translate="yes" xml:space="preserve">
          <source>To install NumPy, run:</source>
          <target state="translated">要安装NumPy,运行。</target>
        </trans-unit>
        <trans-unit id="bd5ace9a611ff0639bf97923787f31ff3babad6c" translate="yes" xml:space="preserve">
          <source>To install NumPy, we strongly recommend using a scientific Python distribution. If you&amp;rsquo;re looking for the full instructions for installing NumPy on your operating system, you can &lt;a href=&quot;https://www.scipy.org/install.html&quot;&gt;find all of the details here&lt;/a&gt;.</source>
          <target state="translated">要安装NumPy，我们强烈建议您使用科学的Python发行版。如果您正在寻找有关在操作系统上安装NumPy的完整说明，则可以&lt;a href=&quot;https://www.scipy.org/install.html&quot;&gt;在此处找到所有详细信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ceadcdbd2ecba0b0b71d04b040d27f4a8978392" translate="yes" xml:space="preserve">
          <source>To intersect more than two arrays, use functools.reduce:</source>
          <target state="translated">要与两个以上的数组相交,请使用 functools.reduce.reduce。</target>
        </trans-unit>
        <trans-unit id="1eeff99dc3325ea11208d15f34bf3ae08056f134" translate="yes" xml:space="preserve">
          <source>To keep in sync with changes in NumPy, you want to set up your repository so it pulls from &lt;code&gt;upstream&lt;/code&gt; by default. This can be done with:</source>
          <target state="translated">为了与NumPy中的更改保持同步，您需要设置存储库，以使其默认情况下从 &lt;code&gt;upstream&lt;/code&gt; 拉出。这可以通过以下方式完成：</target>
        </trans-unit>
        <trans-unit id="422eea08f184929b902e9a6c5257e9028826306a" translate="yes" xml:space="preserve">
          <source>To learn more about finding the unique elements in an array, see &lt;a href=&quot;../reference/generated/numpy.unique#numpy.unique&quot;&gt;&lt;code&gt;unique&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要了解有关在数组中查找唯一元素的更多信息，请参见&lt;a href=&quot;../reference/generated/numpy.unique#numpy.unique&quot;&gt; &lt;code&gt;unique&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f5278c1b18ea2b8e10ed17f38664074c6889df4" translate="yes" xml:space="preserve">
          <source>To learn more about transposing and reshaping arrays, see &lt;a href=&quot;../reference/generated/numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;reshape&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要了解更多关于换位和整形数组，见&lt;a href=&quot;../reference/generated/numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;transpose&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../reference/generated/numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;reshape&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68755700558e4129caf4a1646cfbb8316cee0dd6" translate="yes" xml:space="preserve">
          <source>To make an iterator similar to the old iterator, this should work.</source>
          <target state="translated">要做一个类似于老迭代器的迭代器,这个应该可以。</target>
        </trans-unit>
        <trans-unit id="36529c6f3589cad07eabf913ffb155048ea1dac5" translate="yes" xml:space="preserve">
          <source>To make it concrete, we can pick the operation to be the array-reversal function &lt;a href=&quot;reference/generated/numpy.flip#numpy.flip&quot;&gt;&lt;code&gt;numpy.flip&lt;/code&gt;&lt;/a&gt;, which accepts an &lt;code&gt;axis&lt;/code&gt; argument. We construct a 3 x 4 array &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;reference/generated/numpy.flip#numpy.flip&quot;&gt; &lt;code&gt;numpy.flip&lt;/code&gt; &lt;/a&gt;，我们可以将操作选择为数组反转函数numpy.flip，该函数接受 &lt;code&gt;axis&lt;/code&gt; 参数。我们构造一个3 x 4的数组 &lt;code&gt;a&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6d696015c14a0cbcd57511007788b5810594a8d0" translate="yes" xml:space="preserve">
          <source>To make its properties more readily accessible during iteration, &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; has an alternative syntax for iterating, which works explicitly with the iterator object itself. With this looping construct, the current value is accessible by indexing into the iterator. Other properties, such as tracked indices remain as before. The examples below produce identical results to the ones in the previous section.</source>
          <target state="translated">为了使它的属性在迭代过程中更易于访问，&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;提供了另一种用于迭代的语法，该语法可与迭代器对象本身明确地协同工作。使用这种循环结构，可以通过索引迭代器来访问当前值。其他属性（如跟踪索引）保持不变。下面的示例产生与上一部分相同的结果。</target>
        </trans-unit>
        <trans-unit id="dcb62bb890eb45640b1d129077fff1a1982947c5" translate="yes" xml:space="preserve">
          <source>To make the necessary build options available to third parties, you could use the &lt;code&gt;npy-pkg-config&lt;/code&gt; mechanism implemented in &lt;a href=&quot;#module-numpy.distutils&quot;&gt;&lt;code&gt;numpy.distutils&lt;/code&gt;&lt;/a&gt;. This mechanism is based on a .ini file which contains all the options. A .ini file is very similar to .pc files as used by the pkg-config unix utility:</source>
          <target state="translated">为了进行必要的编译选项提供给第三方，您可以使用 &lt;code&gt;npy-pkg-config&lt;/code&gt; 中实现机制&lt;a href=&quot;#module-numpy.distutils&quot;&gt; &lt;code&gt;numpy.distutils&lt;/code&gt; &lt;/a&gt;。此机制基于包含所有选项的.ini文件。.ini文件与pkg-config unix实用程序使用的.pc文件非常相似：</target>
        </trans-unit>
        <trans-unit id="33556655b7ed4636c5875606d6d2c0f4cbb51bbb" translate="yes" xml:space="preserve">
          <source>To make your key more readily identifiable as you, consider sending your key to public keyservers, with a command such as:</source>
          <target state="translated">为了让你的密钥更容易被识别为你,可以考虑将你的密钥发送到公共密钥服务器上,使用命令,如:。</target>
        </trans-unit>
        <trans-unit id="18c1e38c6bb6394f66a0d335e612f3011262ff50" translate="yes" xml:space="preserve">
          <source>To measure the test coverage, install &lt;a href=&quot;https://pytest-cov.readthedocs.io/en/latest/&quot;&gt;pytest-cov&lt;/a&gt; and then run:</source>
          <target state="translated">要测量测试覆盖率，请安装&lt;a href=&quot;https://pytest-cov.readthedocs.io/en/latest/&quot;&gt;pytest-cov&lt;/a&gt;，然后运行：</target>
        </trans-unit>
        <trans-unit id="6239277562da98f7f93ad4e57c8a93f41fe39464" translate="yes" xml:space="preserve">
          <source>To modify your Python search path to include the locations of your own modules, define the &lt;code&gt;PYTHONPATH&lt;/code&gt; environment variable.</source>
          <target state="translated">要修改您的Python搜索路径以包括您自己的模块的位置，请定义 &lt;code&gt;PYTHONPATH&lt;/code&gt; 环境变量。</target>
        </trans-unit>
        <trans-unit id="8d1963ae310b977b5fdaf7c01ceaf03485096cb4" translate="yes" xml:space="preserve">
          <source>To override the automatic detection of available memory, set the environment variable &lt;code&gt;NPY_AVAILABLE_MEM&lt;/code&gt;, for example &lt;code&gt;NPY_AVAILABLE_MEM=32GB&lt;/code&gt;, or using pytest &lt;code&gt;--available-memory=32GB&lt;/code&gt; target option.</source>
          <target state="translated">要覆盖对可用内存的自动检测，请设置环境变量 &lt;code&gt;NPY_AVAILABLE_MEM&lt;/code&gt; ，例如 &lt;code&gt;NPY_AVAILABLE_MEM=32GB&lt;/code&gt; ，或使用pytest &lt;code&gt;--available-memory=32GB&lt;/code&gt; 目标选项。</target>
        </trans-unit>
        <trans-unit id="d1c61949e0ad3dc492f05ebb9e5438319174c320" translate="yes" xml:space="preserve">
          <source>To perform an in-place build that can be run from the source folder run:</source>
          <target state="translated">要执行可从源文件夹中运行的就地构建,请运行。</target>
        </trans-unit>
        <trans-unit id="c334cf8d4bed58e0564b6be3f28b72afdf600e2c" translate="yes" xml:space="preserve">
          <source>To proceed, import the linear algebra submodule from NumPy:</source>
          <target state="translated">继续,从NumPy导入线性代数子模块。</target>
        </trans-unit>
        <trans-unit id="02d722ee9de32d295a3f1aa488c332a62e29240a" translate="yes" xml:space="preserve">
          <source>To put back the default options, you can use:</source>
          <target state="translated">要放回默认选项,你可以使用。</target>
        </trans-unit>
        <trans-unit id="4f4e1d38162c68bbafa8964bc64bfa72b23866db" translate="yes" xml:space="preserve">
          <source>To read more about Matplotlib and what it can do, take a look at &lt;a href=&quot;https://matplotlib.org/&quot;&gt;the official documentation&lt;/a&gt;. For directions regarding installing Matplotlib, see the official &lt;a href=&quot;https://matplotlib.org/users/installing.html&quot;&gt;installation section&lt;/a&gt;.</source>
          <target state="translated">要了解有关Matplotlib及其功能的更多信息，请查看&lt;a href=&quot;https://matplotlib.org/&quot;&gt;官方文档&lt;/a&gt;。有关安装Matplotlib的说明，请参见官方&lt;a href=&quot;https://matplotlib.org/users/installing.html&quot;&gt;安装部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="98026c8318a10abcb126d49806744b4ae23d3123" translate="yes" xml:space="preserve">
          <source>To read more about concatenate, see: &lt;a href=&quot;../reference/generated/numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要了解有关串联的更多信息，请参阅：&lt;a href=&quot;../reference/generated/numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="425cb75a01c3201b08612ec800f1a7971e0378d1" translate="yes" xml:space="preserve">
          <source>To read more about sorting an array, see: &lt;a href=&quot;../reference/generated/numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要了解有关对数组进行排序的更多信息，请参见：&lt;a href=&quot;../reference/generated/numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33f422775354a46e3c9c41ff160bfb3c38d25920" translate="yes" xml:space="preserve">
          <source>To reduce the chance of misinterpretation, even though the following &amp;ldquo;abuse&amp;rdquo; is nominally supported, &lt;code&gt;choices&lt;/code&gt; should neither be, nor be thought of as, a single array, i.e., the outermost sequence-like container should be either a list or a tuple.</source>
          <target state="translated">为了减少错误解释的机会，即使名义上支持以下&amp;ldquo;滥用&amp;rdquo;， &lt;code&gt;choices&lt;/code&gt; 也不应该也不应被视为单个数组，即，最外面的类似于序列的容器应该是列表或元组。</target>
        </trans-unit>
        <trans-unit id="69f7fdf215ee6723757c121f1000e16153523a1d" translate="yes" xml:space="preserve">
          <source>To retrieve only the valid entries, we can use the inverse of the mask as an index. The inverse of the mask can be calculated with the &lt;a href=&quot;generated/numpy.logical_not#numpy.logical_not&quot;&gt;&lt;code&gt;numpy.logical_not&lt;/code&gt;&lt;/a&gt; function or simply with the &lt;code&gt;~&lt;/code&gt; operator:</source>
          <target state="translated">要仅检索有效条目，我们可以使用掩码的倒数作为索引。可以使用&lt;a href=&quot;generated/numpy.logical_not#numpy.logical_not&quot;&gt; &lt;code&gt;numpy.logical_not&lt;/code&gt; &lt;/a&gt;函数或仅使用 &lt;code&gt;~&lt;/code&gt; 运算符来计算掩码的逆：</target>
        </trans-unit>
        <trans-unit id="e546770d4089912cdd192abaecf0b1e29a9e2943" translate="yes" xml:space="preserve">
          <source>To return the indices of the values common to the input arrays along with the intersected values:</source>
          <target state="translated">返回与输入数组共同的值的索引以及相交的值。</target>
        </trans-unit>
        <trans-unit id="67e6eaca69e6f48eb1845e3b15fc19b5fce3851f" translate="yes" xml:space="preserve">
          <source>To run SciPy&amp;rsquo;s full test suite, use the following:</source>
          <target state="translated">要运行SciPy的完整测试套件，请使用以下命令：</target>
        </trans-unit>
        <trans-unit id="402853161da9a462a3784d2121c2566aac78b1d2" translate="yes" xml:space="preserve">
          <source>To run a benchmark defined in a class, such as &lt;code&gt;Mandelbrot&lt;/code&gt; from &lt;code&gt;bench_avx.py&lt;/code&gt;:</source>
          <target state="translated">要运行在一个类中，如定义的基准 &lt;code&gt;Mandelbrot&lt;/code&gt; 从 &lt;code&gt;bench_avx.py&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3862a782eb6529a8c99b98cef4c13299f47f23c0" translate="yes" xml:space="preserve">
          <source>To run all benchmarks, navigate to the root NumPy directory at the command line and execute:</source>
          <target state="translated">要运行所有基准,请在命令行导航到NumPy根目录并执行。</target>
        </trans-unit>
        <trans-unit id="12365d76682fb967acae76310ae656f9290fed8d" translate="yes" xml:space="preserve">
          <source>To run benchmarks from a particular benchmark module, such as &lt;code&gt;bench_core.py&lt;/code&gt;, simply append the filename without the extension:</source>
          <target state="translated">要从特定的基准测试模块（例如 &lt;code&gt;bench_core.py&lt;/code&gt; )运行基准测试，只需在文件名后加上扩展名即可：</target>
        </trans-unit>
        <trans-unit id="9661928d3b7e0b0f53e4248625106d96b260f714" translate="yes" xml:space="preserve">
          <source>To sample from N evenly spaced floating-point numbers between a and b, use:</source>
          <target state="translated">要从a和b之间的N个间隔均匀的浮点数字中取样,使用。</target>
        </trans-unit>
        <trans-unit id="cd520022e6b8a6d4a06e76bb94b1b7fee07bd6cf" translate="yes" xml:space="preserve">
          <source>To scan Fortran sources and generate a signature file, use</source>
          <target state="translated">要扫描Fortran源并生成签名文件,请使用</target>
        </trans-unit>
        <trans-unit id="67f8780eccc675b04bcebf369f6ed02655b97ea2" translate="yes" xml:space="preserve">
          <source>To see a graphical representation of the repository branches and commits:</source>
          <target state="translated">要查看仓库分支和提交的图形化表示。</target>
        </trans-unit>
        <trans-unit id="39780ed9cf55125c359d05489224449255a114a4" translate="yes" xml:space="preserve">
          <source>To see a linear list of commits for this branch:</source>
          <target state="translated">要查看该分支的线性提交列表。</target>
        </trans-unit>
        <trans-unit id="8b637e484b0579f8dde3e86fc54af28832dba4d1" translate="yes" xml:space="preserve">
          <source>To see how striding underlies the power of NumPy views, see &lt;a href=&quot;https://arxiv.org/pdf/1102.1523.pdf&quot;&gt;The NumPy array: a structure for efficient numerical computation. &lt;/a&gt;</source>
          <target state="translated">要了解跨步如何成为NumPy视图功能的基础，请参阅&lt;a href=&quot;https://arxiv.org/pdf/1102.1523.pdf&quot;&gt;NumPy数组：一种用于高效数值计算的结构。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79f07a6533e986fa44fe540266db879b8c346cb7" translate="yes" xml:space="preserve">
          <source>To see if an approximation is reasonable, we can check the values in &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">要查看近似值是否合理，我们可以检查 &lt;code&gt;s&lt;/code&gt; 中的值：</target>
        </trans-unit>
        <trans-unit id="bc4aaad8d81152b0e7e6f7703b5cec989fcf2cef" translate="yes" xml:space="preserve">
          <source>To see if this makes sense in our image, we should use a colormap from &lt;code&gt;matplotlib&lt;/code&gt; corresponding to the color we wish to see in out image (otherwise, &lt;code&gt;matplotlib&lt;/code&gt; will default to a colormap that does not correspond to the real data).</source>
          <target state="translated">要查看在我们的图像中是否有意义，我们应该使用来自 &lt;code&gt;matplotlib&lt;/code&gt; 的色图，该色图与我们希望从外面看的颜色相对应（否则， &lt;code&gt;matplotlib&lt;/code&gt; 将默认为不对应于实际数据的色图）。</target>
        </trans-unit>
        <trans-unit id="c11e108b211eeb3196e6c957c1a55cfbb8da63bc" translate="yes" xml:space="preserve">
          <source>To see the documentation for a specific ufunc, use &lt;a href=&quot;numpy.info#numpy.info&quot;&gt;&lt;code&gt;info&lt;/code&gt;&lt;/a&gt;. For example, &lt;code&gt;np.info(np.sin)&lt;/code&gt;. Because ufuncs are written in C (for speed) and linked into Python with NumPy&amp;rsquo;s ufunc facility, Python&amp;rsquo;s help() function finds this page whenever help() is called on a ufunc.</source>
          <target state="translated">要查看特定ufunc的文档，请使用&lt;a href=&quot;numpy.info#numpy.info&quot;&gt; &lt;code&gt;info&lt;/code&gt; &lt;/a&gt;。例如， &lt;code&gt;np.info(np.sin)&lt;/code&gt; 。因为ufuncs是用C语言编写的（为了提高速度），并通过NumPy的ufunc工具链接到Python，所以每当在ufunc上调用help（）时，Python的help（）函数都会找到此页面。</target>
        </trans-unit>
        <trans-unit id="74691658cd7769d44a45cda5e12dd3bc908a227e" translate="yes" xml:space="preserve">
          <source>To see whether F2PY generated interface performs copies of array arguments, use &lt;code&gt;-DF2PY_REPORT_ON_ARRAY_COPY=&amp;lt;int&amp;gt;&lt;/code&gt;. When the size of an array argument is larger than &lt;code&gt;&amp;lt;int&amp;gt;&lt;/code&gt;, a message about the coping is sent to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">要查看F2PY生成的接口是否执行数组参数的副本，请使用 &lt;code&gt;-DF2PY_REPORT_ON_ARRAY_COPY=&amp;lt;int&amp;gt;&lt;/code&gt; 。当数组参数的大小大于 &lt;code&gt;&amp;lt;int&amp;gt;&lt;/code&gt; 时，有关应对的消息将发送到 &lt;code&gt;stderr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ed1275cdacf759ff47d03a08e3787f0594bb1bb" translate="yes" xml:space="preserve">
          <source>To set up on another computer, you can copy your &lt;code&gt;~/.gitconfig&lt;/code&gt; file, or run the commands above.</source>
          <target state="translated">要在另一台计算机上进行设置，您可以复制 &lt;code&gt;~/.gitconfig&lt;/code&gt; 文件，或运行上面的命令。</target>
        </trans-unit>
        <trans-unit id="e4d00e748aea08f0006873ab29acb7a55ab4663b" translate="yes" xml:space="preserve">
          <source>To shuffle the rows of &lt;code&gt;x&lt;/code&gt; in-place, pass &lt;code&gt;x&lt;/code&gt; as the &lt;code&gt;out&lt;/code&gt; parameter:</source>
          <target state="translated">要随机替换 &lt;code&gt;x&lt;/code&gt; 的行，请将 &lt;code&gt;x&lt;/code&gt; 用作 &lt;code&gt;out&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="a4d884174d72a1ce55f9ee4b7d870c154a7a32b7" translate="yes" xml:space="preserve">
          <source>To skip a test, simply use &lt;code&gt;skipif&lt;/code&gt;:</source>
          <target state="translated">要跳过测试，只需使用 &lt;code&gt;skipif&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3dc6e4230f5944b1098c8c2df7bd61f24c145894" translate="yes" xml:space="preserve">
          <source>To submit your contribution:</source>
          <target state="translated">要提交您的贡献:</target>
        </trans-unit>
        <trans-unit id="ceffd750378d21341a7019937d0c789148b4f90a" translate="yes" xml:space="preserve">
          <source>To support it, we need to define the Python interfaces &lt;code&gt;__add__&lt;/code&gt;, &lt;code&gt;__lt__&lt;/code&gt;, and so on to dispatch to the corresponding ufunc. We can achieve this conveniently by inheriting from the mixin &lt;a href=&quot;../reference/generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt;&lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为了支持它，我们需要定义Python接口 &lt;code&gt;__add__&lt;/code&gt; ， &lt;code&gt;__lt__&lt;/code&gt; 等，以便分派到相应的ufunc。我们可以通过继承mixin &lt;a href=&quot;../reference/generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt; &lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt; &lt;/a&gt;方便地实现此目的。</target>
        </trans-unit>
        <trans-unit id="673335eebf9011c1628160cca5d99d26576f081d" translate="yes" xml:space="preserve">
          <source>To take the running sum of four successive values:</source>
          <target state="translated">要取四个连续值的运行之和。</target>
        </trans-unit>
        <trans-unit id="54587f602166cab38648eb3409cd921150aa4e7e" translate="yes" xml:space="preserve">
          <source>To test a datetime64 value to see if it is a valid day, use &lt;a href=&quot;generated/numpy.is_busday#numpy.is_busday&quot;&gt;&lt;code&gt;is_busday&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要测试datetime64值以查看其是否为有效日期，请使用&lt;a href=&quot;generated/numpy.is_busday#numpy.is_busday&quot;&gt; &lt;code&gt;is_busday&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="054b90fbdf163bc568eceff518fb7e05620b88d4" translate="yes" xml:space="preserve">
          <source>To test the performance of F2PY generated interfaces, use &lt;code&gt;-DF2PY_REPORT_ATEXIT&lt;/code&gt;. Then a report of various timings is printed out at the exit of Python. This feature may not work on all platforms, currently only Linux platform is supported.</source>
          <target state="translated">要测试F2PY生成的接口的性能，请使用 &lt;code&gt;-DF2PY_REPORT_ATEXIT&lt;/code&gt; 。然后在Python的出口处打印出各种时间的报告。此功能可能不适用于所有平台，当前仅支持Linux平台。</target>
        </trans-unit>
        <trans-unit id="01b5e9d9370a428c2b83ae13e33fb71722d9bb4f" translate="yes" xml:space="preserve">
          <source>To test whether an array is C-contiguous, use the &lt;code&gt;.flags.c_contiguous&lt;/code&gt; attribute of NumPy arrays. To test for Fortran contiguity, use the &lt;code&gt;.flags.f_contiguous&lt;/code&gt; attribute.</source>
          <target state="translated">若要测试数组是否为C连续的，请使用NumPy数组的 &lt;code&gt;.flags.c_contiguous&lt;/code&gt; 属性。要测试Fortran连续性，请使用 &lt;code&gt;.flags.f_contiguous&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="8ab2b1e95b971bb4c5c35b359a5634bf815d8fa6" translate="yes" xml:space="preserve">
          <source>To the extent possible under law, the authors have waived all copyright and related or neighboring rights to the NumPy project governance and decision-making document, as per the &lt;a href=&quot;https://creativecommons.org/publicdomain/zero/1.0/&quot;&gt;CC-0 public domain dedication / license&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;https://creativecommons.org/publicdomain/zero/1.0/&quot;&gt;CC-0公共领域的奉献精神/许可&lt;/a&gt;，在法律允许的范围内，作者放弃了NumPy项目治理和决策文件的所有版权及相关或邻近权利。</target>
        </trans-unit>
        <trans-unit id="4b06b82cac8a278e2d618ab82ddb18a2d508ecee" translate="yes" xml:space="preserve">
          <source>To the maximum extent possible, Council discussions and activities will be public and done in collaboration and discussion with the Project Contributors and Community. The Council will have a private mailing list that will be used sparingly and only when a specific matter requires privacy. When private communications and decisions are needed, the Council will do its best to summarize those to the Community after eliding personal/private/sensitive information that should not be posted to the public internet.</source>
          <target state="translated">在最大程度上,理事会的讨论和活动将是公开的,并与项目贡献者和社区合作和讨论。理事会将有一个私人邮件列表,将尽量少用,只有在具体事项需要保密时才使用。当需要进行私下交流和作出决定时,理事会将尽最大努力,在删去不应张贴在公共互联网上的个人/私人/敏感信息后,向社区总结这些信息。</target>
        </trans-unit>
        <trans-unit id="3cb8696297023077cd0b0457359ff13c01cdb0ce" translate="yes" xml:space="preserve">
          <source>To transform input arrays to column major storage order before passing them to Fortran routines, use the function &lt;code&gt;numpy.asfortranarray(&amp;lt;array&amp;gt;)&lt;/code&gt;.</source>
          <target state="translated">要将输入数组转换为列主要存储顺序，然后再将其传递给Fortran例程，请使用函数 &lt;code&gt;numpy.asfortranarray(&amp;lt;array&amp;gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ecbd73988a92874f75c5ca6f8256cc9806ceef6d" translate="yes" xml:space="preserve">
          <source>To unmask all masked entries of a masked array (provided the mask isn&amp;rsquo;t a hard mask), the simplest solution is to assign the constant &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; to the mask:</source>
          <target state="translated">要取消屏蔽已屏蔽数组的所有已屏蔽条目（假设该掩码不是硬掩码），最简单的解决方案是将常量&lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;分配给该掩码：</target>
        </trans-unit>
        <trans-unit id="573c20b6a49882f7eb74a61c9d6cc94e9816cad4" translate="yes" xml:space="preserve">
          <source>To unmask one or several specific entries, we can just assign one or several new valid values to them:</source>
          <target state="translated">要解除对一个或几个特定条目的屏蔽,我们只需给它们分配一个或几个新的有效值。</target>
        </trans-unit>
        <trans-unit id="9a8a0e07a3236c692c34f1277c4ab67311d7e811" translate="yes" xml:space="preserve">
          <source>To update your PR, make your changes on your local repository, commit, &lt;strong&gt;run tests, and only if they succeed&lt;/strong&gt; push to your fork. As soon as those changes are pushed up (to the same branch as before) the PR will update automatically. If you have no idea how to fix the test failures, you may push your changes anyway and ask for help in a PR comment.</source>
          <target state="translated">要更新您的PR，请在本地存储库上进行更改，提交，&lt;strong&gt;运行测试，并且仅在成功完成后才能进行&lt;/strong&gt;推送。这些更改一经推送（与以前相同的分支），PR就会自动更新。如果您不知道如何解决测试失败，则可以继续进行更改，并在PR注释中寻求帮助。</target>
        </trans-unit>
        <trans-unit id="334270275fd281b533f438d90c3f3ba9ca0332d2" translate="yes" xml:space="preserve">
          <source>To use ctypes you must</source>
          <target state="translated">要使用ctypes,你必须</target>
        </trans-unit>
        <trans-unit id="678a8d94c4368f39ac59f5979ae212033bfc0aa2" translate="yes" xml:space="preserve">
          <source>To use the NPY_NO_DEPRECATED_API mechanism, you need to #define it to the target API version of NumPy before #including any NumPy headers. If you want to confirm that your code is clean against 1.7, use:</source>
          <target state="translated">要使用NPY_NO_DEPRECATED_API机制,你需要在#包含任何NumPy头文件之前,将其定义为NumPy的目标API版本。如果你想确认你的代码在1.7的情况下是干净的,请使用:</target>
        </trans-unit>
        <trans-unit id="a6632c1bd45113f2d4d1587bfeed07e24b0355a1" translate="yes" xml:space="preserve">
          <source>To use the core math library in your own extension, you need to add the npymath compile and link options to your extension in your setup.py:</source>
          <target state="translated">要在你自己的扩展中使用核心数学库,你需要在setup.py中为你的扩展添加npymath编译和链接选项。</target>
        </trans-unit>
        <trans-unit id="b2026079012933359e4262f13af10283bf7286e8" translate="yes" xml:space="preserve">
          <source>To use the default &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; bit generator, one can instantiate it directly and pass it to &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要使用默认的&lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;位生成器，可以直接实例化并将其传递给&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="b22691af04491d10741332ecd435870cd225e63a" translate="yes" xml:space="preserve">
          <source>To use the deprecated &lt;code&gt;matrix&lt;/code&gt; and other &lt;code&gt;matlib&lt;/code&gt; functions:</source>
          <target state="translated">要使用已弃用的 &lt;code&gt;matrix&lt;/code&gt; 和其他 &lt;code&gt;matlib&lt;/code&gt; 函数，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="500206efd24c09b049a15922610b46ea489a6382" translate="yes" xml:space="preserve">
          <source>To use the setup.py file, place setup.py and spammodule.c in the same folder. Then python setup.py build will build the module to import, or setup.py install will install the module to your site-packages directory.</source>
          <target state="translated">要使用setup.py文件,将setup.py和spammodule.c放在同一个文件夹中。然后,python setup.py build将构建模块导入,或者setup.py install将安装模块到你的站点-packages目录。</target>
        </trans-unit>
        <trans-unit id="a62551f1b73595ab5f0441644c3e3f73182c8a6d" translate="yes" xml:space="preserve">
          <source>To work the examples, you&amp;rsquo;ll need &lt;code&gt;matplotlib&lt;/code&gt; installed in addition to NumPy.</source>
          <target state="translated">要运行示例，除了NumPy外，还需要安装 &lt;code&gt;matplotlib&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b09eedfc76bdeeb31bc979256f245ac870f03de" translate="yes" xml:space="preserve">
          <source>Toggle between low-endian and big-endian data representation by returning a byteswapped array, optionally swapped in-place.</source>
          <target state="translated">通过返回一个字节交换的数组,在低字节和大字节数据表示之间切换,可以选择就地交换。</target>
        </trans-unit>
        <trans-unit id="7ff4f3dd9acfe46112f7adc4d9246b8e34598f79" translate="yes" xml:space="preserve">
          <source>Toggle between low-endian and big-endian data representation by returning a byteswapped array, optionally swapped in-place. Arrays of byte-strings are not swapped. The real and imaginary parts of a complex number are swapped individually.</source>
          <target state="translated">通过返回一个字节交换的数组,在低字节和大字节数据表示之间切换,可以选择就地交换。字节串数组不被交换。复数的实部和虚部是单独交换的。</target>
        </trans-unit>
        <trans-unit id="7b37ca94c4e2eda42b84355ca6a25cdc55774133" translate="yes" xml:space="preserve">
          <source>Tolerance in machine epsilons for the complex part of the elements in the array.</source>
          <target state="translated">阵列中元素的复杂部分的机器epsilons公差。</target>
        </trans-unit>
        <trans-unit id="7a686b14e99b6f371ad9d543037e8be2650e9924" translate="yes" xml:space="preserve">
          <source>Tolerance parameters passed on to &lt;a href=&quot;numpy.isclose#numpy.isclose&quot;&gt;&lt;code&gt;isclose&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">公差参数传递给&lt;a href=&quot;numpy.isclose#numpy.isclose&quot;&gt; &lt;code&gt;isclose&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb34b2131d6523965cdff1a43f4d01b982373d17" translate="yes" xml:space="preserve">
          <source>Tolerance parameters passed on to &lt;code&gt;isclose&lt;/code&gt;</source>
          <target state="translated">公差参数传递给 &lt;code&gt;isclose&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6670aa4fd96fc23b9c267762a58d3e2634e5e33d" translate="yes" xml:space="preserve">
          <source>Tolerance when checking the singular values in covariance matrix. cov is cast to double before the check.</source>
          <target state="translated">检查协方差矩阵中的奇异值时的容忍度,cov在检查前被转为双倍。</target>
        </trans-unit>
        <trans-unit id="849d7597da246bfdf3ea363c9c3966af6e67a060" translate="yes" xml:space="preserve">
          <source>Tool chain</source>
          <target state="translated">工具链</target>
        </trans-unit>
        <trans-unit id="6e7bd14cfcb5cad5c21ec7a7360b81cb111dc93e" translate="yes" xml:space="preserve">
          <source>Top priority goes to &lt;strong&gt;technical inaccuracies&lt;/strong&gt; &amp;ndash; a docstring missing a parameter, a faulty description of a function/parameter/method, and so on. Other &amp;ldquo;structural&amp;rdquo; defects like broken links also get priority. All these fixes are easy to confirm and put in place. You can submit a &lt;a href=&quot;https://numpy.org/devdocs/dev/index.html#devindex&quot;&gt;pull request (PR)&lt;/a&gt; with the fix, if you know how to do that; otherwise please &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;open an issue&lt;/a&gt;.</source>
          <target state="translated">最重要的是&lt;strong&gt;技术上的不准确性&lt;/strong&gt;-缺少参数的文档字符串，错误的函数/参数/方法描述等。链接断开等其他&amp;ldquo;结构性&amp;rdquo;缺陷也将得到优先处理。所有这些修复很容易确认并就位。如果知道如何执行，则可以提交带有修复程序的&lt;a href=&quot;https://numpy.org/devdocs/dev/index.html#devindex&quot;&gt;拉取请求（PR）&lt;/a&gt;。否则请&lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;开一个问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7bae3881b1524f2891087bd43b6435b29e2fd654" translate="yes" xml:space="preserve">
          <source>Topics not covered in this tutorial can be found in the documentation:</source>
          <target state="translated">本教程中没有涉及的主题可以在文档中找到。</target>
        </trans-unit>
        <trans-unit id="62511550774b90e55fa9f4d081340a2b9a412907" translate="yes" xml:space="preserve">
          <source>Total bytes consumed by the elements of the array.</source>
          <target state="translated">数组元素消耗的总字节数。</target>
        </trans-unit>
        <trans-unit id="f98da7ab34ca5eed412ebdc84c5c6ee4a001f890" translate="yes" xml:space="preserve">
          <source>Total number of array elements which trigger summarization rather than full repr (default 1000).</source>
          <target state="translated">触发摘要而非完全重写的数组元素总数(默认1000)。</target>
        </trans-unit>
        <trans-unit id="af14b2afdcc9cc3c661815c98f45cde11a73254a" translate="yes" xml:space="preserve">
          <source>Total number of array elements which trigger summarization rather than full repr (default 1000). To always use the full repr without summarization, pass &lt;a href=&quot;https://docs.python.org/dev/library/sys.html#sys.maxsize&quot;&gt;&lt;code&gt;sys.maxsize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">触发汇总而不是完整repr的数组元素总数（默认为1000）。要始终使用完整的repr而不进行摘要，请传递&lt;a href=&quot;https://docs.python.org/dev/library/sys.html#sys.maxsize&quot;&gt; &lt;code&gt;sys.maxsize&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d7665d1d201c9ce2fd429127a2f276d913bba99d" translate="yes" xml:space="preserve">
          <source>Total number of array elements which trigger summarization rather than full repr. Defaults to &lt;code&gt;numpy.get_printoptions()['threshold']&lt;/code&gt;.</source>
          <target state="translated">触发汇总而不是完整表示的数组元素总数。默认为 &lt;code&gt;numpy.get_printoptions()['threshold']&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b009fd84652963a9ad5cd24ef82072817ddee41" translate="yes" xml:space="preserve">
          <source>Total size of broadcasted result.</source>
          <target state="translated">播出结果的总规模。</target>
        </trans-unit>
        <trans-unit id="77cca581150b844f956409245e7a5aa4e911b340" translate="yes" xml:space="preserve">
          <source>Trace of a matrix:</source>
          <target state="translated">矩阵的痕迹。</target>
        </trans-unit>
        <trans-unit id="b67024bc850bfd9a0093e89cd78bf7093386c17c" translate="yes" xml:space="preserve">
          <source>Trace of an array, &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;numpy.trace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">数组的跟踪&lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;numpy.trace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed0e339a8e0484e2fd0a0d26f8fea815f7ce8155" translate="yes" xml:space="preserve">
          <source>Tracking an Index or Multi-Index</source>
          <target state="translated">跟踪一个指数或多个指数</target>
        </trans-unit>
        <trans-unit id="4cf0fc0db43adb86a6609aeef379773c878c22d3" translate="yes" xml:space="preserve">
          <source>Tracking an index or multi-index is incompatible with using an external loop, because it requires a different index value per element. If you try to combine these flags, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object will raise an exception</source>
          <target state="translated">跟踪索引或多索引与使用外部循环不兼容，因为它要求每个元素具有不同的索引值。如果尝试组合这些标志，则&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;对象将引发异常</target>
        </trans-unit>
        <trans-unit id="d235c585e89d9d88a2fc997aec36a615cac97376" translate="yes" xml:space="preserve">
          <source>Tracking an index or multi-index is incompatible with using an external loop, because it requires a different index value per element. If you try to combine these flags, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object will raise an exception.</source>
          <target state="translated">跟踪索引或多索引与使用外部循环不兼容，因为它要求每个元素具有不同的索引值。如果尝试组合这些标志，则&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;对象将引发异常。</target>
        </trans-unit>
        <trans-unit id="0de8c9ca9943956fbbe74f36e563016e4ecbb6f6" translate="yes" xml:space="preserve">
          <source>Trailing (i.e., highest order) elements with absolute value less than or equal to &lt;code&gt;tol&lt;/code&gt; (default value is zero) are removed.</source>
          <target state="translated">绝对值小于或等于 &lt;code&gt;tol&lt;/code&gt; （默认值为零）的尾随（即最高阶）元素将被删除。</target>
        </trans-unit>
        <trans-unit id="60e5d748c9218c048de8740bcac1703e7a50da1a" translate="yes" xml:space="preserve">
          <source>Trailing comments should be used sparingly. Instead of</source>
          <target state="translated">应尽量少用尾部注释。不应使用</target>
        </trans-unit>
        <trans-unit id="b4e92ff02a7f9ca1e9c93153fdca1e9712b3f065" translate="yes" xml:space="preserve">
          <source>Trailing slices can be omitted:</source>
          <target state="translated">后面的片子可以省略。</target>
        </trans-unit>
        <trans-unit id="556492d634d78a1f54a40b4fbbb6e6c53716147d" translate="yes" xml:space="preserve">
          <source>Trailing zeros in the coefficients will be used in the evaluation, so they should be avoided if efficiency is a concern.</source>
          <target state="translated">系数中的尾数零将在评估中使用,所以如果担心效率,应该避免使用。</target>
        </trans-unit>
        <trans-unit id="745b5ecf9a2d85dc724cf9ddd7a6df396eb1df69" translate="yes" xml:space="preserve">
          <source>Transforms a masked array into a flexible-type array.</source>
          <target state="translated">将掩码数组转换为灵活型数组。</target>
        </trans-unit>
        <trans-unit id="5335ed0e86bcde3b96f32fd1545910f420f14d2e" translate="yes" xml:space="preserve">
          <source>Transition notice</source>
          <target state="translated">过渡通知</target>
        </trans-unit>
        <trans-unit id="d362208ff2e702ca3538568841ed00ca61c441f9" translate="yes" xml:space="preserve">
          <source>Translate slice objects to concatenation along the first axis.</source>
          <target state="translated">将切片对象转化为沿第一轴的连接。</target>
        </trans-unit>
        <trans-unit id="c42fc49440b8d06a906b44be13eb608ca2ffc1dd" translate="yes" xml:space="preserve">
          <source>Translates slice objects to concatenation along the first axis.</source>
          <target state="translated">将切片对象转化为沿第一轴的连接。</target>
        </trans-unit>
        <trans-unit id="ff7c65a71ec845e39d241d138fd72490df88fa74" translate="yes" xml:space="preserve">
          <source>Translates slice objects to concatenation along the second axis.</source>
          <target state="translated">将切片对象转化为沿第二轴的连接。</target>
        </trans-unit>
        <trans-unit id="59ccc78dea6365b58077aeb5bd29c68b822c1ef5" translate="yes" xml:space="preserve">
          <source>Translating content</source>
          <target state="translated">翻译内容</target>
        </trans-unit>
        <trans-unit id="8def3943422e0dc87b7f47772bd3dc4ad8ea550b" translate="yes" xml:space="preserve">
          <source>Transpose-like operations</source>
          <target state="translated">类似换位操作</target>
        </trans-unit>
        <trans-unit id="1dfdbda20e491607190c97bd4edf114a4a693811" translate="yes" xml:space="preserve">
          <source>Transposing a 1-D array returns an unchanged view of the original array.</source>
          <target state="translated">转置一个一维数组,返回的是原数组的不变视图。</target>
        </trans-unit>
        <trans-unit id="cfbc312acbc39b5f0298bdc7c7b5f4e1b759968b" translate="yes" xml:space="preserve">
          <source>Transposing and reshaping a matrix</source>
          <target state="translated">转置和重塑矩阵</target>
        </trans-unit>
        <trans-unit id="66408bfa15c9ed2902e447a43b1f7abcdee55a60" translate="yes" xml:space="preserve">
          <source>Transpositions and permutations, &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;numpy.transpose&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">换位和置换&lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;numpy.transpose&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65154a91dcd03eb78f603f149abeb7b4b5c5b547" translate="yes" xml:space="preserve">
          <source>Travis Oliphant &amp;ndash; project founder / emeritus leader (2005-2012)</source>
          <target state="translated">特拉维斯&amp;middot;奥利潘特（Travis Oliphant）&amp;ndash;项目创始人/名誉负责人（2005-2012）</target>
        </trans-unit>
        <trans-unit id="a7b41f9df87a78abbe8128d5a249676911368def" translate="yes" xml:space="preserve">
          <source>Travis Oliphant - Project Founder / Emeritus Leader (served: 2005-2012)</source>
          <target state="translated">Travis Oliphant-项目创始人/荣誉领导人(任职时间:2005-2012年)。</target>
        </trans-unit>
        <trans-unit id="8cd1d8f1121212090792af3b195766028fb3300b" translate="yes" xml:space="preserve">
          <source>Treatment for division by zero.</source>
          <target state="translated">除以零的处理方法。</target>
        </trans-unit>
        <trans-unit id="c576a1cfdbaf816c1398a32382e59edc28900bee" translate="yes" xml:space="preserve">
          <source>Treatment for floating-point overflow.</source>
          <target state="translated">浮点溢出的处理方法。</target>
        </trans-unit>
        <trans-unit id="17721dd3ac43e33f85ad621f2dc25c086c0470c0" translate="yes" xml:space="preserve">
          <source>Treatment for floating-point underflow.</source>
          <target state="translated">对浮点下溢的处理。</target>
        </trans-unit>
        <trans-unit id="a13040b51033dafdb26f7572598a0d12e22e4ffe" translate="yes" xml:space="preserve">
          <source>Treatment for invalid floating-point operation.</source>
          <target state="translated">浮点运算无效的处理方法。</target>
        </trans-unit>
        <trans-unit id="1150736fa84c0c4e53f25517e34313dcdeeed227" translate="yes" xml:space="preserve">
          <source>Tricks and Tips</source>
          <target state="translated">诀窍和技巧</target>
        </trans-unit>
        <trans-unit id="daa2b8a97e48dc7878c0a5d70afe5d62a641a9fe" translate="yes" xml:space="preserve">
          <source>Trigger a build by pushing a commit of your edits to the repository. Note that you can do this on a branch, but it must be pushed upstream to the &lt;code&gt;MacPython/numpy-wheels&lt;/code&gt; repository to trigger uploads since only that repo has the appropriate tokens to allow uploads.</source>
          <target state="translated">通过将所做的编辑推送到存储库来触发构建。请注意，您可以在分支上执行此操作，但是必须将其向上游推送到 &lt;code&gt;MacPython/numpy-wheels&lt;/code&gt; 存储库才能触发上传，因为只有该存储库具有允许上传的适当令牌。</target>
        </trans-unit>
        <trans-unit id="9ba6ba3648cadff3a99f26c6371ef76b8f5ec198" translate="yes" xml:space="preserve">
          <source>Trigger the wheel builds</source>
          <target state="translated">触发轮子的建立</target>
        </trans-unit>
        <trans-unit id="05468e0c8d821343ed9a233c1d01733b9266bd0b" translate="yes" xml:space="preserve">
          <source>Trigger the wheels build by pointing the numpy-wheels repository at this commit. This can take up to an hour. The numpy-wheels repository is cloned from &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt;. If this is the first release in a series, start with a pull as the repo may have been accessed and changed by someone else, then create a new branch for the series. If the branch already exists skip this:</source>
          <target state="translated">通过将numpy-wheels存储库指向此提交来触发Wheels构建。这可能需要一个小时。numpy-wheels存储库是从&lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt;克隆的。如果这是该系列的第一个发行版，请从下拉列表开始，因为其他人可能已经访问和更改了该存储库，然后为该系列创建一个新分支。如果分支已经存在，请跳过此步骤：</target>
        </trans-unit>
        <trans-unit id="4be7bc22dfdfa583bec627625a7e1101bc895967" translate="yes" xml:space="preserve">
          <source>Trigger the wheels build by pointing the numpy-wheels repository at this commit. This can take up to an hour. The numpy-wheels repository is cloned from &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt;. Start with a pull as the repo may have been accessed and changed by someone else and a push will fail:</source>
          <target state="translated">通过将numpy-wheels存储库指向此提交来触发Wheels构建。这可能需要一个小时。numpy-wheels存储库是从&lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt;克隆的。从拉动开始，因为其他人可能已经访问和更改了存储库，而推动将失败：</target>
        </trans-unit>
        <trans-unit id="3a49a3516e9535a98c78b0ab59efaa267faaaeac" translate="yes" xml:space="preserve">
          <source>Triggers &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt;&lt;code&gt;NPY_ITER_COPY&lt;/code&gt;&lt;/a&gt;, and when an array operand is flagged for writing and is copied, causes the data in a copy to be copied back to &lt;code&gt;op[i]&lt;/code&gt; when &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; is called.</source>
          <target state="translated">触发&lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt; &lt;code&gt;NPY_ITER_COPY&lt;/code&gt; &lt;/a&gt;，当将数组操作数标记为要写入并被复制时，将导致在调用 &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; 时将副本中的数据复制回 &lt;code&gt;op[i]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="translated">三角函数</target>
        </trans-unit>
        <trans-unit id="58cf0aee76fad599f97ff1db8c6a47d2270860db" translate="yes" xml:space="preserve">
          <source>Trigonometric inverse cosine, element-wise.</source>
          <target state="translated">三角形反余弦,元素式。</target>
        </trans-unit>
        <trans-unit id="b0b82a06c2ae28e8fcf146e965d0c41fd4531e3a" translate="yes" xml:space="preserve">
          <source>Trigonometric inverse tangent, element-wise.</source>
          <target state="translated">三角形反切线,元素式。</target>
        </trans-unit>
        <trans-unit id="ce4f3fa4852db4b9b207eedadc12e11135e46d85" translate="yes" xml:space="preserve">
          <source>Trigonometric sine, element-wise.</source>
          <target state="translated">三角形正弦,元素方面。</target>
        </trans-unit>
        <trans-unit id="10a283c17897bbd0b4cb4fd810a9eeb88aa8ef58" translate="yes" xml:space="preserve">
          <source>Trim the leading and/or trailing zeros from a 1-D array or sequence.</source>
          <target state="translated">从一维数组或序列中修剪前导零和/或后导零。</target>
        </trans-unit>
        <trans-unit id="e488bb5cb2e281f3b003ce95222b8e4917db65a6" translate="yes" xml:space="preserve">
          <source>Troubleshooting ImportError</source>
          <target state="translated">解决导入错误的问题</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="dec064efe14ed7a73f97fa4832f7dc39f8d37259" translate="yes" xml:space="preserve">
          <source>True divide self by other in-place.</source>
          <target state="translated">真正的将自己与其他原地划分。</target>
        </trans-unit>
        <trans-unit id="7c6199295c88c515de03909ca69e74e54d8c40d0" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;element&lt;/code&gt; is a scalar type, False if it is not.</source>
          <target state="translated">如果 &lt;code&gt;element&lt;/code&gt; 是标量类型，则为True；否则为False。</target>
        </trans-unit>
        <trans-unit id="39cf2a1ac05eb7ec1f611fa8df3b32f9cff1d558" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;m.dtype.type&lt;/code&gt; is MaskType, False otherwise.</source>
          <target state="translated">如果 &lt;code&gt;m.dtype.type&lt;/code&gt; 为MaskType，则为 True ，否则为False。</target>
        </trans-unit>
        <trans-unit id="c7e5263b6e49f0164ce122995ea161e565df58fa" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;num&lt;/code&gt; is a scalar type, False if it is not.</source>
          <target state="translated">如果 &lt;code&gt;num&lt;/code&gt; 是标量类型，则为True；否则为False。</target>
        </trans-unit>
        <trans-unit id="2655b1728487edfb72db0ecd08ff9ea666177ee0" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;path&lt;/code&gt; exists.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 存在，则为真。</target>
        </trans-unit>
        <trans-unit id="0acadbce2849d20449e701a26739adbff1b98e78" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;x&lt;/code&gt; is a MaskedArray with masked values, False otherwise.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是具有掩码值的MaskedArray，则为True ，否则为False。</target>
        </trans-unit>
        <trans-unit id="83f25ea97ce8639113893298b33aa2fdafa083b7" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;x&lt;/code&gt; is a MaskedArray.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是MaskedArray，则为true。</target>
        </trans-unit>
        <trans-unit id="05ff71445923acdd0c38d736b463809c9ccd39de" translate="yes" xml:space="preserve">
          <source>True if a Fortran 77 compiler is available (because a simple Fortran 77 code was able to be compiled successfully).</source>
          <target state="translated">如果有Fortran 77编译器,则为真(因为一个简单的Fortran 77代码能够被成功编译)。</target>
        </trans-unit>
        <trans-unit id="00cd0fd9fd4e9fcf05a5961ba064f7c5fc57b8ef" translate="yes" xml:space="preserve">
          <source>True if a Fortran 90 compiler is available (because a simple Fortran 90 code was able to be compiled successfully)</source>
          <target state="translated">如果有Fortran 90编译器,则为真(因为一个简单的Fortran 90代码能够被成功编译)。</target>
        </trans-unit>
        <trans-unit id="3616df3a5e4787a2b7d174f6c5a2763bf50c6e85" translate="yes" xml:space="preserve">
          <source>True if byteorder characters ( &lt;a href=&quot;#c.NPY_LITTLE&quot;&gt;&lt;code&gt;NPY_LITTLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_BIG&quot;&gt;&lt;code&gt;NPY_BIG&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_NATIVE&quot;&gt;&lt;code&gt;NPY_NATIVE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_IGNORE&quot;&gt;&lt;code&gt;NPY_IGNORE&lt;/code&gt;&lt;/a&gt; ) are either equal or equivalent as to their specification of a native byte order. Thus, on a little-endian machine &lt;a href=&quot;#c.NPY_LITTLE&quot;&gt;&lt;code&gt;NPY_LITTLE&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_NATIVE&quot;&gt;&lt;code&gt;NPY_NATIVE&lt;/code&gt;&lt;/a&gt; are equivalent where they are not equivalent on a big-endian machine.</source>
          <target state="translated">如果字节序字符（&lt;a href=&quot;#c.NPY_LITTLE&quot;&gt; &lt;code&gt;NPY_LITTLE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_BIG&quot;&gt; &lt;code&gt;NPY_BIG&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_NATIVE&quot;&gt; &lt;code&gt;NPY_NATIVE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_IGNORE&quot;&gt; &lt;code&gt;NPY_IGNORE&lt;/code&gt; &lt;/a&gt;）在本机字节序的规范上相等或相等，则为true。因此，在小端计算机上，&lt;a href=&quot;#c.NPY_LITTLE&quot;&gt; &lt;code&gt;NPY_LITTLE&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NPY_NATIVE&quot;&gt; &lt;code&gt;NPY_NATIVE&lt;/code&gt; &lt;/a&gt;是等效的，而在大端计算机上是不等效的。</target>
        </trans-unit>
        <trans-unit id="213506708b75038d86119f896c93fd459688fdaa" translate="yes" xml:space="preserve">
          <source>True if byteorder characters ( &lt;code&gt;NPY_LITTLE&lt;/code&gt;, &lt;code&gt;NPY_BIG&lt;/code&gt;, &lt;code&gt;NPY_NATIVE&lt;/code&gt;, &lt;code&gt;NPY_IGNORE&lt;/code&gt; ) are either equal or equivalent as to their specification of a native byte order. Thus, on a little-endian machine &lt;code&gt;NPY_LITTLE&lt;/code&gt; and &lt;code&gt;NPY_NATIVE&lt;/code&gt; are equivalent where they are not equivalent on a big-endian machine.</source>
          <target state="translated">如果字节序字符（ &lt;code&gt;NPY_LITTLE&lt;/code&gt; ， &lt;code&gt;NPY_BIG&lt;/code&gt; ， &lt;code&gt;NPY_NATIVE&lt;/code&gt; ， &lt;code&gt;NPY_IGNORE&lt;/code&gt; ）在本机字节序的规范上相等或相等，则为true。因此，在小端序计算机上， &lt;code&gt;NPY_LITTLE&lt;/code&gt; 和 &lt;code&gt;NPY_NATIVE&lt;/code&gt; 是等效的，而在大端序计算机上则不相等。</target>
        </trans-unit>
        <trans-unit id="ba3294550f0a20e5d9deb7f04a95fb8e4b4d1d46" translate="yes" xml:space="preserve">
          <source>True if cast can occur according to the casting rule.</source>
          <target state="translated">如果根据铸造规则可以发生铸造,则为真。</target>
        </trans-unit>
        <trans-unit id="1f63565b32d103f3a4de31640d426343af47dd7d" translate="yes" xml:space="preserve">
          <source>True if equivalent, False otherwise.</source>
          <target state="translated">如果等价,则为真,否则为假。</target>
        </trans-unit>
        <trans-unit id="1e741019d05ad4b1c0222d2d53486f99a6732190" translate="yes" xml:space="preserve">
          <source>True if other is same class as self</source>
          <target state="translated">如果other与self同级,则为true</target>
        </trans-unit>
        <trans-unit id="70fbd415e3863800b42dd70f2afc2d0435498df0" translate="yes" xml:space="preserve">
          <source>True if the coefficients are the same, False otherwise.</source>
          <target state="translated">如果系数相同则为真,否则为假。</target>
        </trans-unit>
        <trans-unit id="a6afbacb41b3137cec218f989dffb959ca4f44cd" translate="yes" xml:space="preserve">
          <source>True if the domains are the same, False otherwise.</source>
          <target state="translated">如果域名相同则为真,否则为假。</target>
        </trans-unit>
        <trans-unit id="4bc2a6d6f70eb24c8def5df03724644edb474780" translate="yes" xml:space="preserve">
          <source>True if the windows are the same, False otherwise.</source>
          <target state="translated">如果窗口相同则为true,否则为False。</target>
        </trans-unit>
        <trans-unit id="24f9df4fb7133abd7e86f4b5f0391c10a93621e7" translate="yes" xml:space="preserve">
          <source>True if two arrays have the same shape and elements, False otherwise.</source>
          <target state="translated">如果两个数组的形状和元素相同,则为真,否则为假。</target>
        </trans-unit>
        <trans-unit id="755e15abf3303ababe3ade30f10af71c607d4530" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is NaN, false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为NaN，则为true，否则为false。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="dc0b3f0e3c0fa8c731e1bcdadee661ee71b2ddb8" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is NaT, false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是NaT，则为true，否则为false。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="cd270c6be47d5f9045a9640d5cc8ead8711407bc" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is not positive infinity, negative infinity, or NaN; false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">当 &lt;code&gt;x&lt;/code&gt; 不是正无穷大，负无穷大或NaN时为真；否则为假。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="3170e8eb3762dd10d0e3ab109761eb5c944e9ac1" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is positive or negative infinity, false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">当 &lt;code&gt;x&lt;/code&gt; 为正或负无穷大时为true，否则为false。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="425b939d0909e079d100ad47521c0febc0bd307a" translate="yes" xml:space="preserve">
          <source>Truncate s values at 50 so plot is interesting:</source>
          <target state="translated">将s值截断在50处,这样绘图才有趣。</target>
        </trans-unit>
        <trans-unit id="8726579bd5d3f34275a243eb604a9ceb6cbd38eb" translate="yes" xml:space="preserve">
          <source>Truncate series to length &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">将系列截短为长度 &lt;code&gt;size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adcf68c15599690309b811decf083d5555853eeb" translate="yes" xml:space="preserve">
          <source>Truncate series to the given degree.</source>
          <target state="translated">将系列截断到给定的程度。</target>
        </trans-unit>
        <trans-unit id="d2338e206b938414aa6688a0afb4b20ac9ad0ec9" translate="yes" xml:space="preserve">
          <source>Truth value of an array (&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt;&lt;code&gt;bool()&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">数组的真值（&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt; &lt;code&gt;bool()&lt;/code&gt; &lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="d78b8c914ad90242aebfa1ad45be017c8a4ed426" translate="yes" xml:space="preserve">
          <source>Truth value of an array (&lt;code&gt;bool&lt;/code&gt;):</source>
          <target state="translated">数组的真值（ &lt;code&gt;bool&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="d14d79df6800bf8b855c978794baaad558b55ab7" translate="yes" xml:space="preserve">
          <source>Truth value testing</source>
          <target state="translated">真值测试</target>
        </trans-unit>
        <trans-unit id="a34d6317df428f3a0882e4fcc17ec8a423d926fc" translate="yes" xml:space="preserve">
          <source>Truth-value testing of an array invokes &lt;a href=&quot;generated/numpy.ndarray.__bool__#numpy.ndarray.__bool__&quot;&gt;&lt;code&gt;ndarray.__bool__&lt;/code&gt;&lt;/a&gt;, which raises an error if the number of elements in the array is larger than 1, because the truth value of such arrays is ambiguous. Use &lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt;&lt;code&gt;.any()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;.all()&lt;/code&gt;&lt;/a&gt; instead to be clear about what is meant in such cases. (If the number of elements is 0, the array evaluates to &lt;code&gt;False&lt;/code&gt;.)</source>
          <target state="translated">数组的真值测试会调用&lt;a href=&quot;generated/numpy.ndarray.__bool__#numpy.ndarray.__bool__&quot;&gt; &lt;code&gt;ndarray.__bool__&lt;/code&gt; &lt;/a&gt;，如果数组中的元素数大于1，则会引发错误，因为此类数组的真值不明确。使用&lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt; &lt;code&gt;.any()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;.all()&lt;/code&gt; &lt;/a&gt;，而不是要清楚什么是在这种情况下的意思。（如果元素数为0，则数组的值为 &lt;code&gt;False&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="2ecf59a43e289ad2b017cf95dec49da40904a53e" translate="yes" xml:space="preserve">
          <source>Try to get version string of a package.</source>
          <target state="translated">尝试获取一个软件包的版本字符串。</target>
        </trans-unit>
        <trans-unit id="d41c38be32c336059996707815d0e3ddc6359848" translate="yes" xml:space="preserve">
          <source>Try to keep the runtime of the benchmark reasonable.</source>
          <target state="translated">尽量保持基准的运行时间合理。</target>
        </trans-unit>
        <trans-unit id="78b28b6348f61eb4f458af0454cbb48914113f96" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;(item_dtype, shape)&lt;/code&gt; if this &lt;a href=&quot;#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; describes a sub-array, and None otherwise.</source>
          <target state="translated">如果此&lt;a href=&quot;#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;描述子数组， &lt;code&gt;(item_dtype, shape)&lt;/code&gt; 元组（item_dtype，shape），否则为None。</target>
        </trans-unit>
        <trans-unit id="3e6ddb0c1b967dfa42de0aef208f74bd1f3fd6c6" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;(item_dtype, shape)&lt;/code&gt; if this &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; describes a sub-array, and None otherwise.</source>
          <target state="translated">如果此&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;描述子数组， &lt;code&gt;(item_dtype, shape)&lt;/code&gt; 元组（item_dtype，shape），否则为None。</target>
        </trans-unit>
        <trans-unit id="f3757a0166a586f2a2125cefab21784843d386d2" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;(item_dtype, shape)&lt;/code&gt; if this &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; describes a sub-array, and None otherwise.</source>
          <target state="translated">如果此&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;描述子数组， &lt;code&gt;(item_dtype, shape)&lt;/code&gt; 元组（item_dtype，shape），否则为None。</target>
        </trans-unit>
        <trans-unit id="84be13d7b7fcc75e7ec8441a86e66cf302003bb9" translate="yes" xml:space="preserve">
          <source>Tuple axis arguments to ufuncs are equivalent:</source>
          <target state="translated">ufuncs的元组轴参数是等价的。</target>
        </trans-unit>
        <trans-unit id="92e7c78c7d4063f090081adef280802cf975a20b" translate="yes" xml:space="preserve">
          <source>Tuple object dtypes</source>
          <target state="translated">元组对象dtypes</target>
        </trans-unit>
        <trans-unit id="288ea08ff10a961743d4d8b925f5d1931f661310" translate="yes" xml:space="preserve">
          <source>Tuple of array dimensions.</source>
          <target state="translated">阵列维数的元组。</target>
        </trans-unit>
        <trans-unit id="f5d08265a0d5770b0b5299133319ac3ca12e44d4" translate="yes" xml:space="preserve">
          <source>Tuple of bytes steps in each dimension.</source>
          <target state="translated">每个维度的字节步数的元组。</target>
        </trans-unit>
        <trans-unit id="119e92503836c54689c5f8c6dff4e15a28816a46" translate="yes" xml:space="preserve">
          <source>Tuple of bytes to step in each dimension when traversing an array.</source>
          <target state="translated">当遍历一个数组时,在每个维度上要步进的字节元组。</target>
        </trans-unit>
        <trans-unit id="08a4b4faf13c4a1ee940941cfebf009124c6372f" translate="yes" xml:space="preserve">
          <source>Tuple whose elements are the array size in each dimension. Each entry is an integer (a Python &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;). Note that these integers could be larger than the platform &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; could hold (a Python &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; is a C &lt;code&gt;long&lt;/code&gt;). It is up to the code using this attribute to handle this appropriately; either by raising an error when overflow is possible, or by using &lt;code&gt;long long&lt;/code&gt; as the C type for the shapes.</source>
          <target state="translated">元组的元素是每个维度中的数组大小。每个条目都是一个整数（Python &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;）。请注意，这些整数可以大于平台 &lt;code&gt;int&lt;/code&gt; 或 &lt;code&gt;long&lt;/code&gt; 可以容纳的&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;（Python int是C &lt;code&gt;long&lt;/code&gt; ）。取决于使用此属性的代码来适当地处理它；这取决于代码。或者在可能发生溢出时通过引发错误，或者通过将 &lt;code&gt;long long&lt;/code&gt; 用作形状的C类型来使用。</target>
        </trans-unit>
        <trans-unit id="a39e9bc9ce6796bfca6ebd0c63299d64e075f553" translate="yes" xml:space="preserve">
          <source>Tuple whose elements are the array size in each dimension. Each entry is an integer (a Python int or long). Note that these integers could be larger than the platform &amp;ldquo;int&amp;rdquo; or &amp;ldquo;long&amp;rdquo; could hold (a Python int is a C long). It is up to the code using this attribute to handle this appropriately; either by raising an error when overflow is possible, or by using &lt;code&gt;Py_LONG_LONG&lt;/code&gt; as the C type for the shapes.</source>
          <target state="translated">元组的元素是每个维中的数组大小。每个条目都是一个整数（Python int或long）。请注意，这些整数可能大于平台&amp;ldquo; int&amp;rdquo;或&amp;ldquo; long&amp;rdquo;可容纳的整数（Python int为C long）。取决于使用此属性的代码来适当地处理此问题。在可能发生溢出时引发错误，或者使用 &lt;code&gt;Py_LONG_LONG&lt;/code&gt; 作为形状的C类型。</target>
        </trans-unit>
        <trans-unit id="20d441ae2c7520e9597892d62d069dab012afe76" translate="yes" xml:space="preserve">
          <source>Turns pure python into efficient machine code through jit-like optimizations</source>
          <target state="translated">通过类似jit的优化,将纯Python变成高效的机器代码。</target>
        </trans-unit>
        <trans-unit id="d9bd3e52f2caf4d6594b811b3960a4952fbdcd14" translate="yes" xml:space="preserve">
          <source>Tutorial: Linear algebra on n-dimensional arrays</source>
          <target state="translated">教程。n维数组的线性代数</target>
        </trans-unit>
        <trans-unit id="6cedb23d3e7c47dc54b88999730d0194898d3934" translate="yes" xml:space="preserve">
          <source>Tutorial: Masked Arrays</source>
          <target state="translated">教程。屏蔽数组</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="a3aad8fcfc1fb793d988e46dd13b4c587f04cc94" translate="yes" xml:space="preserve">
          <source>Tutorials and summaries</source>
          <target state="translated">教程和摘要</target>
        </trans-unit>
        <trans-unit id="0e8bc0a325097293ba3968264a6e780fc207371f" translate="yes" xml:space="preserve">
          <source>Tweaking the conversion</source>
          <target state="translated">调整转换</target>
        </trans-unit>
        <trans-unit id="a84f46a1bd48b0888bd11bac416f31bd455192d4" translate="yes" xml:space="preserve">
          <source>Two and three dots in difference specs</source>
          <target state="translated">两点和三点的不同规格</target>
        </trans-unit>
        <trans-unit id="eff015ed2b91595519ef0f82b5da310790ed8380" translate="yes" xml:space="preserve">
          <source>Two groups, children of diabetics (25 people) and children from people without diabetes (25 controls). Fasting blood glucose was measured, case group had a mean value of 86.1, controls had a mean value of 82.2. Standard deviations were 2.09 and 2.49 respectively. Are these data consistent with the null hypothesis that the parents diabetic status does not affect their children&amp;rsquo;s blood glucose levels? Calculating the F statistic from the data gives a value of 36.01.</source>
          <target state="translated">两组分别为糖尿病儿童（25人）和非糖尿病儿童（25人）。测量空腹血糖，病例组的平均值为86.1，对照组的平均值为82.2。标准偏差分别为2.09和2.49。这些数据是否与父母的糖尿病状况不影响孩子的血糖水平的零假设相符？从数据计算F统计量得出的值为36.01。</target>
        </trans-unit>
        <trans-unit id="9a29304c220b1dd3134936cc76050af186cb5278" translate="yes" xml:space="preserve">
          <source>Two times the reciprocal of pi (</source>
          <target state="translated">pi的倒数的2倍 (</target>
        </trans-unit>
        <trans-unit id="c6b3128dd2f1c22ff8a2b286be1379fe8a8fe179" translate="yes" xml:space="preserve">
          <source>Two-by-four array of samples from</source>
          <target state="translated">二乘四的样品阵列</target>
        </trans-unit>
        <trans-unit id="b1f6d6c8746a437f90f0dee674c0b93df2f99381" translate="yes" xml:space="preserve">
          <source>Two-by-four array of samples from N(3, 6.25):</source>
          <target state="translated">N(3,6.25)的二乘四样品阵列。</target>
        </trans-unit>
        <trans-unit id="3db221513448342ff7f1391357dc023cdf6dc3dc" translate="yes" xml:space="preserve">
          <source>Two-by-four matrix of samples from</source>
          <target state="translated">二乘四样本矩阵</target>
        </trans-unit>
        <trans-unit id="862d5ad68d4b198349fd0cc9c98a5797e23f13c7" translate="yes" xml:space="preserve">
          <source>Two-dimensional array:</source>
          <target state="translated">二维阵列。</target>
        </trans-unit>
        <trans-unit id="4ca814bb64ef6897ea819d313fffbc4815334f0e" translate="yes" xml:space="preserve">
          <source>Two-dimensional arrays are tested in exactly the same manner. The above description applies, but with &lt;code&gt;Matrix&lt;/code&gt; substituted for &lt;code&gt;Vector&lt;/code&gt;. For three-dimensional tests, substitute &lt;code&gt;Tensor&lt;/code&gt; for &lt;code&gt;Vector&lt;/code&gt;. For four-dimensional tests, substitute &lt;code&gt;SuperTensor&lt;/code&gt; for &lt;code&gt;Vector&lt;/code&gt;. For flat in-place array tests, substitute &lt;code&gt;Flat&lt;/code&gt; for &lt;code&gt;Vector&lt;/code&gt;. For the descriptions that follow, we will reference the &lt;code&gt;Vector&lt;/code&gt; tests, but the same information applies to &lt;code&gt;Matrix&lt;/code&gt;, &lt;code&gt;Tensor&lt;/code&gt; and &lt;code&gt;SuperTensor&lt;/code&gt; tests.</source>
          <target state="translated">以完全相同的方式测试二维数组。上面的描述适用，但是用 &lt;code&gt;Matrix&lt;/code&gt; 代替了 &lt;code&gt;Vector&lt;/code&gt; 。对于三维测试，用 &lt;code&gt;Tensor&lt;/code&gt; 代替 &lt;code&gt;Vector&lt;/code&gt; 。对于四维测试，用 &lt;code&gt;SuperTensor&lt;/code&gt; 代替 &lt;code&gt;Vector&lt;/code&gt; 。对于平面就地数组测试，用 &lt;code&gt;Flat&lt;/code&gt; 代替 &lt;code&gt;Vector&lt;/code&gt; 。对于以下描述，我们将引用 &lt;code&gt;Vector&lt;/code&gt; 测试，但是相同的信息适用于 &lt;code&gt;Matrix&lt;/code&gt; ， &lt;code&gt;Tensor&lt;/code&gt; 和 &lt;code&gt;SuperTensor&lt;/code&gt; 测试。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="4f87d1dd8d472cbdfec76a8cf89933a4a1cf8dbd" translate="yes" xml:space="preserve">
          <source>Type Promotion</source>
          <target state="translated">促销类型</target>
        </trans-unit>
        <trans-unit id="315f6367d2e7e25cde681d099ca28e1c2c774de1" translate="yes" xml:space="preserve">
          <source>Type declarations</source>
          <target state="translated">类型声明</target>
        </trans-unit>
        <trans-unit id="546ef13b4643b6acadc0951eac37d6f468caac3d" translate="yes" xml:space="preserve">
          <source>Type description examples</source>
          <target state="translated">类型描述示例</target>
        </trans-unit>
        <trans-unit id="966782d7443e2170cf499e59f9a8368a7b7380cd" translate="yes" xml:space="preserve">
          <source>Type has fields associated with it.</source>
          <target state="translated">类型有与之相关的字段。</target>
        </trans-unit>
        <trans-unit id="ad1651cc08eba91d6dce8f9e7cbe0420ed624c49" translate="yes" xml:space="preserve">
          <source>Type has no size information attached, and can be resized. Should only be called on flexible dtypes. Types that are attached to an array will always be sized, hence the array form of this macro not existing.</source>
          <target state="translated">类型没有附加的尺寸信息,并且可以调整大小。应该只对灵活的dtypes调用。附加在数组上的类型总是有大小的,因此这个宏的数组形式不存在。</target>
        </trans-unit>
        <trans-unit id="00fea5456fe9ccd4a61fecaaa45953e334c1c594" translate="yes" xml:space="preserve">
          <source>Type is either flexible or user-defined.</source>
          <target state="translated">类型可以是灵活的,也可以是用户定义的。</target>
        </trans-unit>
        <trans-unit id="fd89c694ef19c6e785630016c5d715bce35c6076" translate="yes" xml:space="preserve">
          <source>Type is preserved for boolean arrays, so the result will contain &lt;code&gt;False&lt;/code&gt; when consecutive elements are the same and &lt;code&gt;True&lt;/code&gt; when they differ.</source>
          <target state="translated">类型是为布尔数组保留的，因此当连续元素相同时，结果将包含 &lt;code&gt;False&lt;/code&gt; ,而在连续元素不同时将包含 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f129dda4a5f86710986e28a3910cacd0ab66b0a" translate="yes" xml:space="preserve">
          <source>Type of comparison.</source>
          <target state="translated">比较类型:</target>
        </trans-unit>
        <trans-unit id="c36d17e1133f5c5a545edd7db2e2ccd0a71a9cf5" translate="yes" xml:space="preserve">
          <source>Type of the data (integer, float, Python object, etc.)</source>
          <target state="translated">数据类型(整数、浮点数、Python对象等)</target>
        </trans-unit>
        <trans-unit id="dd429360d0a73315317719cd2b034bd7849c79e3" translate="yes" xml:space="preserve">
          <source>Type of the returned array and of the accumulator in which the elements are summed. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not specified, it defaults to the dtype of &lt;code&gt;a&lt;/code&gt;, unless &lt;code&gt;a&lt;/code&gt; has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.</source>
          <target state="translated">返回的数组和累加器的类型，元素在其中累加。如果&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;未指定，则默认为的D型 &lt;code&gt;a&lt;/code&gt; ，除非 &lt;code&gt;a&lt;/code&gt; 具有精度小于默认平台整数的整数D型。在这种情况下，将使用默认平台整数。</target>
        </trans-unit>
        <trans-unit id="07bc03c5a2d510ae05b611f9e4728e3dfbb4d656" translate="yes" xml:space="preserve">
          <source>Type of the returned array, as well as of the accumulator in which the elements are multiplied. If &lt;em&gt;dtype&lt;/em&gt; is not specified, it defaults to the dtype of &lt;code&gt;a&lt;/code&gt;, unless &lt;code&gt;a&lt;/code&gt; has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used instead.</source>
          <target state="translated">返回数组的类型，以及与元素相乘的累加器的类型。如果&lt;em&gt;D型&lt;/em&gt;未指定，则默认为的D型 &lt;code&gt;a&lt;/code&gt; ，除非 &lt;code&gt;a&lt;/code&gt; 具有精度小于默认平台整数的整数D型。在这种情况下，将使用默认平台整数。</target>
        </trans-unit>
        <trans-unit id="2fbcc881be006ea806d10d1a75e79dec487e047f" translate="yes" xml:space="preserve">
          <source>Type of the returned view, e.g., ndarray or matrix. Again, omission of the parameter results in type preservation.</source>
          <target state="translated">返回的视图类型,例如,ndarray或矩阵。同样,省略该参数会导致类型保留。</target>
        </trans-unit>
        <trans-unit id="36795fd8406bf11fda0ac3128a88df4463dd2892" translate="yes" xml:space="preserve">
          <source>Type of the returned view, e.g., ndarray or matrix. Again, the default None results in type preservation.</source>
          <target state="translated">返回视图的类型,例如,ndarray或矩阵。同样,默认的None会导致类型保留。</target>
        </trans-unit>
        <trans-unit id="e3dd48b9d6f09dc7416ab4d63d6ccc2dc14a5715" translate="yes" xml:space="preserve">
          <source>Type of the returned view, either ndarray or a subclass. The default None results in type preservation.</source>
          <target state="translated">返回的视图的类型,可以是ndarray或子类。默认的None会导致类型保留。</target>
        </trans-unit>
        <trans-unit id="9d0b3189219da3d7ba109eef463be8e2071fbe7e" translate="yes" xml:space="preserve">
          <source>Type promotion in NumPy works similarly to the rules in languages like C++, with some slight differences. When both scalars and arrays are used, the array&amp;rsquo;s type takes precedence and the actual value of the scalar is taken into account.</source>
          <target state="translated">NumPy中的类型提升与C ++等语言中的规则类似，但略有不同。当同时使用标量和数组时，数组的类型优先，并且标量的实际值也要考虑在内。</target>
        </trans-unit>
        <trans-unit id="66585ef6b68c044b299bc7220f22788121e21167" translate="yes" xml:space="preserve">
          <source>Type provided:</source>
          <target state="translated">提供的类型:</target>
        </trans-unit>
        <trans-unit id="bc25fc1327a92506da2b55272b3113fcffa65d61" translate="yes" xml:space="preserve">
          <source>Type represents Boolean data type.</source>
          <target state="translated">类型代表布尔数据类型。</target>
        </trans-unit>
        <trans-unit id="60db025c166ec63b9a181b61c24b20c5d24b0648" translate="yes" xml:space="preserve">
          <source>Type represents a signed integer.</source>
          <target state="translated">类型代表一个有符号的整数。</target>
        </trans-unit>
        <trans-unit id="acb6256437982d272438054c848d82884163b4d8" translate="yes" xml:space="preserve">
          <source>Type represents a string data type.</source>
          <target state="translated">类型代表一个字符串数据类型。</target>
        </trans-unit>
        <trans-unit id="08f325041fae51a65ee6e08f868548827f3e2b61" translate="yes" xml:space="preserve">
          <source>Type represents a user-defined type.</source>
          <target state="translated">类型代表用户定义的类型。</target>
        </trans-unit>
        <trans-unit id="f5f87b05bbeb10ab3c2ec34871c51fb7f3e190f2" translate="yes" xml:space="preserve">
          <source>Type represents an enumerated type corresponding to one of the standard Python scalar (bool, int, float, or complex).</source>
          <target state="translated">Type 表示对应于标准 Python 标量之一的枚举类型 (bool、int、float 或 complex)。</target>
        </trans-unit>
        <trans-unit id="6fc847c0dbefe834d836a7b9b36c518b8a349fc4" translate="yes" xml:space="preserve">
          <source>Type represents an unsigned integer.</source>
          <target state="translated">类型代表一个无符号整数。</target>
        </trans-unit>
        <trans-unit id="f8e7a296ef6aceb534615bd823bf7fad61a5043e" translate="yes" xml:space="preserve">
          <source>Type represents any complex floating point number.</source>
          <target state="translated">类型代表任何复杂的浮点数。</target>
        </trans-unit>
        <trans-unit id="28cd3b87be44c11187d7cc10075315e307082083" translate="yes" xml:space="preserve">
          <source>Type represents any floating point number.</source>
          <target state="translated">类型代表任何浮点数。</target>
        </trans-unit>
        <trans-unit id="579601ba7e8ea9eb8623a33cadfe20f9eaea6f83" translate="yes" xml:space="preserve">
          <source>Type represents any integer, floating point, or complex floating point number.</source>
          <target state="translated">类型代表任何整数、浮点或复杂的浮点数。</target>
        </trans-unit>
        <trans-unit id="051ab06f1a62606ef03aadb95e9e56f705f31488" translate="yes" xml:space="preserve">
          <source>Type represents any integer.</source>
          <target state="translated">类型代表任何整数。</target>
        </trans-unit>
        <trans-unit id="a2ba1da5781162c52e0abb1d3993de06d380b834" translate="yes" xml:space="preserve">
          <source>Type represents object data type.</source>
          <target state="translated">类型代表对象数据类型。</target>
        </trans-unit>
        <trans-unit id="20eece7c06865b2554e5d1db1375400953d56528" translate="yes" xml:space="preserve">
          <source>Type represents one of the flexible array types ( &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">Type表示灵活数组类型之一（&lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt; &lt;code&gt;NPY_STRING&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt; &lt;code&gt;NPY_UNICODE&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt; &lt;code&gt;NPY_VOID&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8e6c44e27b4edb7108b331e3527612380352acbf" translate="yes" xml:space="preserve">
          <source>Type represents one of the flexible array types ( &lt;a href=&quot;dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">Type表示灵活数组类型之一（&lt;a href=&quot;dtype#c.NPY_STRING&quot;&gt; &lt;code&gt;NPY_STRING&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;dtype#c.NPY_UNICODE&quot;&gt; &lt;code&gt;NPY_UNICODE&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;dtype#c.NPY_VOID&quot;&gt; &lt;code&gt;NPY_VOID&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cab551b16a69b24d82e03c4a0d668cc3040d4465" translate="yes" xml:space="preserve">
          <source>Type specific, core 1-d functions for ufuncs where each calculation is obtained by calling a function taking one input argument and returning one output. This function is passed in &lt;code&gt;func&lt;/code&gt;. The letters correspond to dtypechar&amp;rsquo;s of the supported data types ( &lt;code&gt;e&lt;/code&gt; - half, &lt;code&gt;f&lt;/code&gt; - float, &lt;code&gt;d&lt;/code&gt; - double, &lt;code&gt;g&lt;/code&gt; - long double, &lt;code&gt;F&lt;/code&gt; - cfloat, &lt;code&gt;D&lt;/code&gt; - cdouble, &lt;code&gt;G&lt;/code&gt; - clongdouble). The argument &lt;em&gt;func&lt;/em&gt; must support the same signature. The _As_X_X variants assume ndarray&amp;rsquo;s of one data type but cast the values to use an underlying function that takes a different data type. Thus, &lt;a href=&quot;#c.PyUFunc_f_f_As_d_d&quot;&gt;&lt;code&gt;PyUFunc_f_f_As_d_d&lt;/code&gt;&lt;/a&gt; uses ndarrays of data type &lt;a href=&quot;c-api.dtype#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; but calls out to a C-function that takes double and returns double.</source>
          <target state="translated">类型特定的ufunc核心1-d函数，其中的每个计算都是通过调用一个具有一个输入参数并返回一个输出的函数来获得的。该函数在 &lt;code&gt;func&lt;/code&gt; 中传递。字母对应于受支持的数据类型的dtypechar（ &lt;code&gt;e&lt;/code&gt; -一半， &lt;code&gt;f&lt;/code&gt; -浮点数， &lt;code&gt;d&lt;/code&gt; -两倍， &lt;code&gt;g&lt;/code&gt; -长双倍， &lt;code&gt;F&lt;/code&gt; -cfloat， &lt;code&gt;D&lt;/code&gt; -cdouble， &lt;code&gt;G&lt;/code&gt; -clongdouble）。参数&lt;em&gt;func&lt;/em&gt;必须支持相同的签名。 _As_X_X变体假定一种数据类型的ndarray，但将其值强制转换为使用具有不同数据类型的基础函数。因此，&lt;a href=&quot;#c.PyUFunc_f_f_As_d_d&quot;&gt; &lt;code&gt;PyUFunc_f_f_As_d_d&lt;/code&gt; &lt;/a&gt;使用数据类型为&lt;a href=&quot;c-api.dtype#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; 的ndarrays,&lt;/a&gt;但调用C函数，该函数需要double并返回double。</target>
        </trans-unit>
        <trans-unit id="e494b69883a66d9ceddef7c995f1d4e3172789f0" translate="yes" xml:space="preserve">
          <source>Type specific, core 1-d functions for ufuncs where each calculation is obtained by calling a function taking one input argument and returning one output. This function is passed in &lt;code&gt;func&lt;/code&gt;. The letters correspond to dtypechar&amp;rsquo;s of the supported data types ( &lt;code&gt;e&lt;/code&gt; - half, &lt;code&gt;f&lt;/code&gt; - float, &lt;code&gt;d&lt;/code&gt; - double, &lt;code&gt;g&lt;/code&gt; - long double, &lt;code&gt;F&lt;/code&gt; - cfloat, &lt;code&gt;D&lt;/code&gt; - cdouble, &lt;code&gt;G&lt;/code&gt; - clongdouble). The argument &lt;em&gt;func&lt;/em&gt; must support the same signature. The _As_X_X variants assume ndarray&amp;rsquo;s of one data type but cast the values to use an underlying function that takes a different data type. Thus, &lt;a href=&quot;#c.PyUFunc_f_f_As_d_d&quot;&gt;&lt;code&gt;PyUFunc_f_f_As_d_d&lt;/code&gt;&lt;/a&gt; uses ndarrays of data type &lt;a href=&quot;dtype#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; but calls out to a C-function that takes double and returns double.</source>
          <target state="translated">类型特定的ufunc核心1-d函数，其中的每个计算都是通过调用接受一个输入参数并返回一个输出的函数来获得的。此函数在 &lt;code&gt;func&lt;/code&gt; 中传递。字母对应于受支持的数据类型的dtypechar（ &lt;code&gt;e&lt;/code&gt; -一半， &lt;code&gt;f&lt;/code&gt; -浮点数， &lt;code&gt;d&lt;/code&gt; -两倍， &lt;code&gt;g&lt;/code&gt; -长双倍， &lt;code&gt;F&lt;/code&gt; -cfloat， &lt;code&gt;D&lt;/code&gt; -cdouble， &lt;code&gt;G&lt;/code&gt; -clongdouble）。参数&lt;em&gt;func&lt;/em&gt;必须支持相同的签名。 _As_X_X变体假定一种数据类型的ndarray，但将其值强制转换为使用采用另一种数据类型的基础函数。因此，&lt;a href=&quot;#c.PyUFunc_f_f_As_d_d&quot;&gt; &lt;code&gt;PyUFunc_f_f_As_d_d&lt;/code&gt; &lt;/a&gt;使用数据类型为&lt;a href=&quot;dtype#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; 的ndarrays,&lt;/a&gt;但是调用C函数，该函数需要double并返回double。</target>
        </trans-unit>
        <trans-unit id="2718d921f0c8c7bb73eed2147fee6ea79b6b6859" translate="yes" xml:space="preserve">
          <source>Type specific, core 1-d functions for ufuncs where each calculation is obtained by calling a function taking two input arguments and returning one output. The underlying function to call is passed in as &lt;em&gt;func&lt;/em&gt;. The letters correspond to dtypechar&amp;rsquo;s of the specific data type supported by the general-purpose function. The argument &lt;code&gt;func&lt;/code&gt; must support the corresponding signature. The &lt;code&gt;_As_XX_X&lt;/code&gt; variants assume ndarrays of one data type but cast the values at each iteration of the loop to use the underlying function that takes a different data type.</source>
          <target state="translated">类型特定的ufunc核心1-d函数，其中的每个计算都是通过调用带有两个输入参数并返回一个输出的函数来获得的。调用的基础函数作为&lt;em&gt;func&lt;/em&gt;传递。字母对应于通用功能支持的特定数据类型的dtypechar。参数 &lt;code&gt;func&lt;/code&gt; 必须支持相应的签名。所述 &lt;code&gt;_As_XX_X&lt;/code&gt; 变体假定一个数据类型的ndarrays但在循环中使用的底层函数采用不同的数据类型的每个迭代投的值。</target>
        </trans-unit>
        <trans-unit id="ef2ee12d948765f441a77e0dc116238b4eb26327" translate="yes" xml:space="preserve">
          <source>Type specifier strings are convertible to dtypes and can therefore be used instead of dtypes:</source>
          <target state="translated">类型指定符字符串可以转换为dtypes,因此可以代替dtypes使用。</target>
        </trans-unit>
        <trans-unit id="f7df157385540da09117c232afd23b684eee205b" translate="yes" xml:space="preserve">
          <source>Type strings</source>
          <target state="translated">字符串类型</target>
        </trans-unit>
        <trans-unit id="49d07ace07256156d179be0651876cfb45bce120" translate="yes" xml:space="preserve">
          <source>Type to use in computing the mean. For integer inputs, the default is &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;float64&lt;/code&gt;&lt;/a&gt;; for floating point inputs, it is the same as the input dtype.</source>
          <target state="translated">用于计算平均值的类型。对于整数输入，默认值为&lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt; &lt;code&gt;float64&lt;/code&gt; &lt;/a&gt;；对于浮点输入，它与输入dtype相同。</target>
        </trans-unit>
        <trans-unit id="3e254f683fcb738da4c686306a38d5b35595c5b4" translate="yes" xml:space="preserve">
          <source>Type to use in computing the mean. For integer inputs, the default is &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;float64&lt;/code&gt;&lt;/a&gt;; for inexact inputs, it is the same as the input dtype.</source>
          <target state="translated">用于计算平均值的类型。对于整数输入，默认值为&lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt; &lt;code&gt;float64&lt;/code&gt; &lt;/a&gt;；对于不精确的输入，它与输入dtype相同。</target>
        </trans-unit>
        <trans-unit id="b6e792a3d08a7bd144dac10e42edb461fd3dd2e3" translate="yes" xml:space="preserve">
          <source>Type to use in computing the mean. For integer inputs, the default is &lt;code&gt;float64&lt;/code&gt;; for floating point inputs, it is the same as the input dtype.</source>
          <target state="translated">用于计算平均值的类型。对于整数输入，默认值为 &lt;code&gt;float64&lt;/code&gt; ；对于浮点输入，它与输入dtype相同。</target>
        </trans-unit>
        <trans-unit id="9f9df4fba8dcd1fb7d56164c04214c5a4ba9ba6b" translate="yes" xml:space="preserve">
          <source>Type to use in computing the mean. For integer inputs, the default is &lt;code&gt;float64&lt;/code&gt;; for inexact inputs, it is the same as the input dtype.</source>
          <target state="translated">用于计算平均值的类型。对于整数输入，默认值为 &lt;code&gt;float64&lt;/code&gt; ；对于不精确的输入，它与输入dtype相同。</target>
        </trans-unit>
        <trans-unit id="3131a42adb40886f91b9db8d1e4f4fee7e5c8913" translate="yes" xml:space="preserve">
          <source>Type to use in computing the standard deviation. For arrays of integer type the default is float64, for arrays of float types it is the same as the array type.</source>
          <target state="translated">计算标准差时使用的类型。对于整数类型的数组,默认为float64,对于浮动类型的数组,它与数组类型相同。</target>
        </trans-unit>
        <trans-unit id="80e97dffa22c435830b854e8d6fb1c6cb57a1b46" translate="yes" xml:space="preserve">
          <source>Type to use in computing the variance. For arrays of integer type</source>
          <target state="translated">计算方差时使用的类型。对于整数类型的数组</target>
        </trans-unit>
        <trans-unit id="af41caa041c2dd1ec692f185fc4f70fc76fd368b" translate="yes" xml:space="preserve">
          <source>Type to use in computing the variance. For arrays of integer type the default is &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;float64&lt;/code&gt;&lt;/a&gt;; for arrays of float types it is the same as the array type.</source>
          <target state="translated">用于计算方差的类型。对于整数类型的数组，默认值为&lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt; &lt;code&gt;float64&lt;/code&gt; &lt;/a&gt;；对于float类型的数组，它与数组类型相同。</target>
        </trans-unit>
        <trans-unit id="c52f694878c4817d9cf0e30a93a5ac5c826ca338" translate="yes" xml:space="preserve">
          <source>Type to use in computing the variance. For arrays of integer type the default is &lt;code&gt;float32&lt;/code&gt;; for arrays of float types it is the same as the array type.</source>
          <target state="translated">用于计算方差的类型。对于整数类型的数组，默认值为 &lt;code&gt;float32&lt;/code&gt; ；对于float类型的数组，它与数组类型相同。</target>
        </trans-unit>
        <trans-unit id="251490cecef7141a0dccef6fed5a02c3f5f10907" translate="yes" xml:space="preserve">
          <source>Type to use in computing the variance. For arrays of integer type the default is &lt;code&gt;float64&lt;/code&gt;; for arrays of float types it is the same as the array type.</source>
          <target state="translated">用于计算方差的类型。对于整数类型的数组，默认值为 &lt;code&gt;float64&lt;/code&gt; ；对于float类型的数组，它与数组类型相同。</target>
        </trans-unit>
        <trans-unit id="9af8f14bd15271db0f113f7c146e7fa9294b1caa" translate="yes" xml:space="preserve">
          <source>TypeError</source>
          <target state="translated">TypeError</target>
        </trans-unit>
        <trans-unit id="d160c5845a8a77a5befb4851a7053d8bdf35eb94" translate="yes" xml:space="preserve">
          <source>Typecode or data-type to which the array is cast.</source>
          <target state="translated">数组被投向的类型代码或数据类型。</target>
        </trans-unit>
        <trans-unit id="41a5cdb8ef55e142306841748946bd3431f088b4" translate="yes" xml:space="preserve">
          <source>Typed versions of many of the &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; methods as well as the classes themselves can be accessed directly from Cython via</source>
          <target state="translated">可以通过以下方式直接从Cython中访问许多&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt;方法的类型化版本以及类本身。</target>
        </trans-unit>
        <trans-unit id="23cf72e69c01c79ece86b50f4bc0e1b659346558" translate="yes" xml:space="preserve">
          <source>Typemap conversions for complex floating-point types is also not supported automatically. This is because Python and NumPy are written in C, which does not have native complex types. Both Python and NumPy implement their own (essentially equivalent) &lt;code&gt;struct&lt;/code&gt; definitions for complex variables:</source>
          <target state="translated">还不自动支持复杂浮点类型的Typemap转换。这是因为Python和NumPy是用C编写的，它没有本机复杂类型。Python和NumPy都为复杂变量实现了它们自己的（基本上等效的） &lt;code&gt;struct&lt;/code&gt; 定义：</target>
        </trans-unit>
        <trans-unit id="f2014cb40164abd5b9ac9cf3258c64ef343de062" translate="yes" xml:space="preserve">
          <source>Typemaps are keyed off a list of one or more function arguments, either by type or by type and name. We will refer to such lists as &lt;em&gt;signatures&lt;/em&gt;. One of the many typemaps defined by &lt;code&gt;numpy.i&lt;/code&gt; is used above and has the signature &lt;code&gt;(double* IN_ARRAY1, int DIM1)&lt;/code&gt;. The argument names are intended to suggest that the &lt;code&gt;double*&lt;/code&gt; argument is an input array of one dimension and that the &lt;code&gt;int&lt;/code&gt; represents the size of that dimension. This is precisely the pattern in the &lt;code&gt;rms&lt;/code&gt; prototype.</source>
          <target state="translated">类型映射从一个或多个函数参数的列表中键入（按类型或类型和名称）。我们将这些列表称为&lt;em&gt;签名&lt;/em&gt;。上面使用了numpy.i定义的许多类型映射 &lt;code&gt;numpy.i&lt;/code&gt; ，并且具有签名 &lt;code&gt;(double* IN_ARRAY1, int DIM1)&lt;/code&gt; 。参数名称旨在建议 &lt;code&gt;double*&lt;/code&gt; 参数是一维的输入数组，而 &lt;code&gt;int&lt;/code&gt; 表示该维的大小。这正是 &lt;code&gt;rms&lt;/code&gt; 原型中的模式。</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="908f34305dca26ca1d02c401b17bcc9125b1ab5c" translate="yes" xml:space="preserve">
          <source>Types with &lt;code&gt;.dtype&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.dtype&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="translated">典型用途:</target>
        </trans-unit>
        <trans-unit id="e390f0c6d81411459ef6be418905b3473133c360" translate="yes" xml:space="preserve">
          <source>Typically a &amp;lsquo;greedy&amp;rsquo; algorithm is applied which empirical tests have shown returns the optimal path in the majority of cases. In some cases &amp;lsquo;optimal&amp;rsquo; will return the superlative path through a more expensive, exhaustive search. For iterative calculations it may be advisable to calculate the optimal path once and reuse that path by supplying it as an argument. An example is given below.</source>
          <target state="translated">通常，采用&amp;ldquo;贪心&amp;rdquo;算法，根据经验测试，该算法在大多数情况下会返回最佳路径。在某些情况下，&amp;ldquo;最优&amp;rdquo;将通过更昂贵，更详尽的搜索返回最高级路径。对于迭代计算，建议一次计算最佳路径并通过将其作为参数提供来重用该路径。下面给出一个例子。</target>
        </trans-unit>
        <trans-unit id="291bb923a1cf51e55db8c8127cc92200f5117732" translate="yes" xml:space="preserve">
          <source>Typically these new versions of the array metadata but the same data buffer are new &amp;lsquo;views&amp;rsquo; into the data buffer. There is a different ndarray object, but it uses the same data buffer. This is why it is necessary to force copies through use of the .copy() method if one really wants to make a new and independent copy of the data buffer.</source>
          <target state="translated">通常，这些新版本的数组元数据和相同的数据缓冲区是数据缓冲区的新&amp;ldquo;视图&amp;rdquo;。有一个不同的ndarray对象，但是它使用相同的数据缓冲区。这就是为什么如果真的想制作一个新的独立的数据缓冲区副本，则必须通过使用.copy（）方法来强制进行复制的原因。</target>
        </trans-unit>
        <trans-unit id="54a23bec4dd6b17bf03f7139f1786ecb950b41b8" translate="yes" xml:space="preserve">
          <source>Typically this value will be one more than what you might expect because all ufuncs take the optional &amp;ldquo;out&amp;rdquo; argument.</source>
          <target state="translated">通常，此值将比您期望的值大一个，因为所有ufunc都采用可选的&amp;ldquo; out&amp;rdquo;参数。</target>
        </trans-unit>
        <trans-unit id="2db839a7e94204fc83aa9e6a4d27e6c5c452f385" translate="yes" xml:space="preserve">
          <source>Typically though, &lt;code&gt;self.min(axis=axis)&lt;/code&gt; is sufficient.</source>
          <target state="translated">不过通常情况下， &lt;code&gt;self.min(axis=axis)&lt;/code&gt; 就足够了。</target>
        </trans-unit>
        <trans-unit id="32606a7a80aee72f839ad47d7de51922ee1b0957" translate="yes" xml:space="preserve">
          <source>Typically you get a new reference to a variable when it is created or is the return value of some function (there are some prominent exceptions, however &amp;mdash; such as getting an item out of a tuple or a dictionary). When you own the reference, you are responsible to make sure that &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; (var) is called when the variable is no longer necessary (and no other function has &amp;ldquo;stolen&amp;rdquo; its reference). Also, if you are passing a Python object to a function that will &amp;ldquo;steal&amp;rdquo; the reference, then you need to make sure you own it (or use &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; to get your own reference). You will also encounter the notion of borrowing a reference. A function that borrows a reference does not alter the reference count of the object and does not expect to &amp;ldquo;hold on &amp;ldquo;to the reference. It&amp;rsquo;s just going to use the object temporarily. When you use &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_UnpackTuple&quot;&gt;&lt;code&gt;PyArg_UnpackTuple&lt;/code&gt;&lt;/a&gt; you receive a borrowed reference to the objects in the tuple and should not alter their reference count inside your function. With practice, you can learn to get reference counting right, but it can be frustrating at first.</source>
          <target state="translated">通常，在创建变量时它会获得新的引用，或者它是某个函数的返回值（但是，有一些突出的例外情况，例如从元组或字典中取出项目）。当您拥有引用时，您有责任确保在不再需要该变量（并且没有其他函数&amp;ldquo;窃取&amp;rdquo;其引用）时调用&lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt; &lt;code&gt;Py_DECREF&lt;/code&gt; &lt;/a&gt;（var）。另外，如果要将Python对象传递给将&amp;ldquo;窃取&amp;rdquo;引用的函数，则需要确保自己拥有该引用（或使用&lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt;以获得您自己的参考）。您还将遇到借用参考的概念。借用引用的函数不会更改对象的引用计数，并且不会期望&amp;ldquo;保留&amp;rdquo;该引用。只是临时使用该对象。当您使用&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_UnpackTuple&quot;&gt; &lt;code&gt;PyArg_UnpackTuple&lt;/code&gt; 时,&lt;/a&gt;您会收到对元组中对象的借用引用，并且不应在函数中更改它们的引用计数。通过实践，您可以学习正确地进行引用计数，但是起初可能会感到沮丧。</target>
        </trans-unit>
        <trans-unit id="3fadc3f723273062c4d9c5a6483a39eed14f9c66" translate="yes" xml:space="preserve">
          <source>Typically, the size of all core dimensions in an output will be determined by the size of a core dimension with the same label in an input array. This is not a requirement, and it is possible to define a signature where a label comes up for the first time in an output, although some precautions must be taken when calling such a function. An example would be the function &lt;code&gt;euclidean_pdist(a)&lt;/code&gt;, with signature &lt;code&gt;(n,d)-&amp;gt;(p)&lt;/code&gt;, that given an array of &lt;code&gt;n&lt;/code&gt;&lt;code&gt;d&lt;/code&gt;-dimensional vectors, computes all unique pairwise Euclidean distances among them. The output dimension &lt;code&gt;p&lt;/code&gt; must therefore be equal to &lt;code&gt;n * (n - 1) / 2&lt;/code&gt;, but it is the caller&amp;rsquo;s responsibility to pass in an output array of the right size. If the size of a core dimension of an output cannot be determined from a passed in input or output array, an error will be raised.</source>
          <target state="translated">通常，输出中所有核心尺寸的大小将由输入数组中具有相同标签的核心尺寸的大小确定。这不是必需的，并且可以定义一个签名，在该签名中输出中第一次出现标签，尽管在调用此类函数时必须采取一些预防措施。一个示例是具有签名 &lt;code&gt;(n,d)-&amp;gt;(p)&lt;/code&gt; 的函数 &lt;code&gt;euclidean_pdist(a)&lt;/code&gt; ，该函数给定 &lt;code&gt;n&lt;/code&gt; &lt;code&gt;d&lt;/code&gt; 维矢量的数组，计算其中所有唯一的成对欧几里德距离。因此，输出尺寸 &lt;code&gt;p&lt;/code&gt; 必须等于 &lt;code&gt;n * (n - 1) / 2&lt;/code&gt; ，但是传递正确大小的输出数组是调用者的责任。如果无法根据传入的输入或输出数组确定输出核心尺寸的大小，则会产生错误。</target>
        </trans-unit>
        <trans-unit id="81f4149c1a20e72abefc686a48b22d01b3176b3b" translate="yes" xml:space="preserve">
          <source>Typing (&lt;code&gt;numpy.typing&lt;/code&gt;)</source>
          <target state="translated">键入（ &lt;code&gt;numpy.typing&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="59adc3948a7b50794673f56a730ed1dc08703d52" translate="yes" xml:space="preserve">
          <source>Typing (numpy.typing)</source>
          <target state="translated">Typing (numpy.typing)</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="c093fd2ae7a1b6c1d5d85e7bc3cb2abb1cfc0cb0" translate="yes" xml:space="preserve">
          <source>UC Berkeley (St&amp;eacute;fan van der Walt, Sebastian Berg, Warren Weckesser, Ross Barnowski)</source>
          <target state="translated">加州大学伯克利分校（St&amp;eacute;fanvan der Walt，塞巴斯蒂安&amp;middot;伯格，沃伦&amp;middot;韦克瑟尔，罗斯&amp;middot;巴诺夫斯基）</target>
        </trans-unit>
        <trans-unit id="f1bad5a5addf87c78243a0908ff2f26f2b5c976f" translate="yes" xml:space="preserve">
          <source>UC Berkeley (Stefan van der Walt, Sebastian Berg, Warren Weckesser, Ross Barnowski)</source>
          <target state="translated">加州大学伯克利分校(Stefan van der Walt、Sebastian Berg、Warren Weckesser、Ross Barnowski)</target>
        </trans-unit>
        <trans-unit id="054ec2a1c571b996a33a40629d7bbd3a2c7c7a03" translate="yes" xml:space="preserve">
          <source>UFUNC_CHECK_ERROR()</source>
          <target state="translated">UFUNC_CHECK_ERROR()</target>
        </trans-unit>
        <trans-unit id="d2291265ceb8694acf9ebd2a0083ea66791f6665" translate="yes" xml:space="preserve">
          <source>UFUNC_CHECK_STATUS()</source>
          <target state="translated">UFUNC_CHECK_STATUS()</target>
        </trans-unit>
        <trans-unit id="7c45c7778c0f3c31bbfb06962ea0f2b3d024a473" translate="yes" xml:space="preserve">
          <source>UFUNC_ERR_{HANDLER}</source>
          <target state="translated">UFUNC_ERR_{HANDLER}</target>
        </trans-unit>
        <trans-unit id="46518eb931ec8d24ef410f576a7160b8b457bb69" translate="yes" xml:space="preserve">
          <source>UFunc API</source>
          <target state="translated">UFunc API</target>
        </trans-unit>
        <trans-unit id="779cd7c4bcd3367298526e617162cab51fe8f735" translate="yes" xml:space="preserve">
          <source>UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;</source>
          <target state="translated">UPDATEIFCOPY (U)(已废弃),被WRITEBACKIFCOPY取代。</target>
        </trans-unit>
        <trans-unit id="4eab2a5ea17917129ec8fa19b15a7cfda3fe1d46" translate="yes" xml:space="preserve">
          <source>UPDATEIFCOPY / U</source>
          <target state="translated">UPDATEIFCOPY/U</target>
        </trans-unit>
        <trans-unit id="8c955f87125d1d07da79b0f8b10f03f3519e41af" translate="yes" xml:space="preserve">
          <source>UPDATEIFCOPY can only be set &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">UPDATEIFCOPY只能设置为 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7033cb6e00b408f93174a1cb4dc874e5ec8f4436" translate="yes" xml:space="preserve">
          <source>URLs require a scheme string (&lt;code&gt;http://&lt;/code&gt;) to be used, without it they will fail:</source>
          <target state="translated">URL需要使用方案字符串（ &lt;code&gt;http://&lt;/code&gt; ），否则将失败：</target>
        </trans-unit>
        <trans-unit id="76298f39f520148528f0c1a12443b1e9a612a67d" translate="yes" xml:space="preserve">
          <source>Ufunc API</source>
          <target state="translated">Ufunc API</target>
        </trans-unit>
        <trans-unit id="07fbda00eaafb6ceaaf8098d7abd7adf2f3fa665" translate="yes" xml:space="preserve">
          <source>Ufunc behavior for overlapping inputs</source>
          <target state="translated">重叠输入的Ufunc行为</target>
        </trans-unit>
        <trans-unit id="01787e5708f1880517c980a345514f0ac0d4f3a1" translate="yes" xml:space="preserve">
          <source>Ufuncs allow other array-like classes to be passed seamlessly through the interface in that inputs of a particular class will induce the outputs to be of that same class. The mechanism by which this works is the following. If any of the inputs are not ndarrays and define the &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method, then the class with the largest &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; attribute determines the type of all the outputs (with the exception of any output arrays passed in). The &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method of the input array will be called with the ndarray being returned from the ufunc as it&amp;rsquo;s input. There are two calling styles of the &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; function supported. The first takes the ndarray as the first argument and a tuple of &amp;ldquo;context&amp;rdquo; as the second argument. The context is (ufunc, arguments, output argument number). This is the first call tried. If a TypeError occurs, then the function is called with just the ndarray as the first argument.</source>
          <target state="translated">Ufunc允许其他类似数组的类通过接口无缝传递，因为特定类的输入将导致输出属于同一类。其工作机制如下。如果有任何的输入不是ndarrays并定义&lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;方法，则具有最大的类&lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;属性确定所有输出的类型（与传递的任何输出阵列的除外）。所述&lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;输入数组的方法将用来自ufunc因为它的输入返回的感ndarray被调用。&lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;有两种调用样式功能支持。第一个将ndarray作为第一个参数，将&amp;ldquo; context&amp;rdquo;的元组作为第二个参数。上下文是（ufunc，自变量，输出自变量编号）。这是第一次尝试通话。如果发生TypeError，则仅使用ndarray作为第一个参数来调用该函数。</target>
        </trans-unit>
        <trans-unit id="bb1e7beaee60184f94b2766ad490881fcda15d1a" translate="yes" xml:space="preserve">
          <source>Ufuncs also have a fifth method that allows in place operations to be performed using fancy indexing. No buffering is used on the dimensions where fancy indexing is used, so the fancy index can list an item more than once and the operation will be performed on the result of the previous operation for that item.</source>
          <target state="translated">Ufuncs还有第五种方法,可以使用花式索引进行到位操作。在使用花式索引的维度上不使用缓冲,所以花式索引可以不止一次地列出一个项目,并且会对该项目的前一次操作结果进行操作。</target>
        </trans-unit>
        <trans-unit id="ebe1370731077d311895107006a4816f68d36e75" translate="yes" xml:space="preserve">
          <source>Ufuncs: If the &lt;code&gt;ALIGNED&lt;/code&gt; flag of an array is False, ufuncs will buffer/cast the array before evaluation. This is needed since ufunc inner loops access raw elements directly, which might fail on some archs if the elements are not true-aligned.</source>
          <target state="translated">Ufuncs：如果数组的 &lt;code&gt;ALIGNED&lt;/code&gt; 标志为False，则Ufuncs将在评估之前缓冲/广播该数组。这是必需的，因为ufunc内部循环直接访问原始元素，如果元素未真正对齐，则在某些拱形上可能会失败。</target>
        </trans-unit>
        <trans-unit id="781ffa6fd9f0234942bb6847c5bb2f8924769498" translate="yes" xml:space="preserve">
          <source>Umath and multiarray c-extension modules merged into a single module</source>
          <target state="translated">Umath和多数组c扩展模块合并为一个模块。</target>
        </trans-unit>
        <trans-unit id="52313eed90dffcad6d336fc2df812a51c07afa3f" translate="yes" xml:space="preserve">
          <source>Un-sized flexible data-type objects do not have this attribute.</source>
          <target state="translated">非大小灵活的数据类型对象没有这个属性。</target>
        </trans-unit>
        <trans-unit id="b7fcaea31c03023df34e5b7b17cd0d3a054b94c0" translate="yes" xml:space="preserve">
          <source>Unary operations:</source>
          <target state="translated">单元操作。</target>
        </trans-unit>
        <trans-unit id="eb11f871299eef811cd072499c803b05b282a2bf" translate="yes" xml:space="preserve">
          <source>Under certain conditions, &lt;code&gt;nditer&lt;/code&gt; must be used in a context manager</source>
          <target state="translated">在某些情况下，必须在上下文管理器中使用 &lt;code&gt;nditer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a813a893f115799fcd0b6f6dee8828d16c00cb4d" translate="yes" xml:space="preserve">
          <source>Under-the-hood Documentation for developers</source>
          <target state="translated">开发者的机身下文档</target>
        </trans-unit>
        <trans-unit id="ee256bb7a636957391cc28f26fc314ab3aeba52b" translate="yes" xml:space="preserve">
          <source>Under-the-hood docs</source>
          <target state="translated">罩内文件</target>
        </trans-unit>
        <trans-unit id="56332d95dfcc595c6bea8676636a72713f221f0a" translate="yes" xml:space="preserve">
          <source>Underflow: result so close to zero that some precision was lost.</source>
          <target state="translated">下溢:结果如此接近于零,以至于损失了一些精度。</target>
        </trans-unit>
        <trans-unit id="59c608e219e1ef1b3832d726571dbc3af32612af" translate="yes" xml:space="preserve">
          <source>Understand axis and shape properties for n-dimensional arrays.</source>
          <target state="translated">了解n维数组的轴和形状属性。</target>
        </trans-unit>
        <trans-unit id="cd6d50dccc320b7b45e093ddb7f7dd61e7e784a1" translate="yes" xml:space="preserve">
          <source>Understand how to access and modify data for masked arrays</source>
          <target state="translated">了解如何访问和修改掩码数组的数据。</target>
        </trans-unit>
        <trans-unit id="7a82cdb76fef36e8a84963b1363d0b9e06ddc672" translate="yes" xml:space="preserve">
          <source>Understand how to apply some linear algebra operations to n-dimensional arrays without using for-loops;</source>
          <target state="translated">了解如何在不使用for-loop的情况下对n维数组应用一些线性代数运算。</target>
        </trans-unit>
        <trans-unit id="c54944247198ee020e57c96492a8adaa8f1c26ce" translate="yes" xml:space="preserve">
          <source>Understand the difference between one-, two- and n-dimensional arrays in NumPy;</source>
          <target state="translated">了解NumPy中一维、二维和n维数组的区别。</target>
        </trans-unit>
        <trans-unit id="0ac405cd12d1e61ef3ec9ed67b16e321b2ef49d7" translate="yes" xml:space="preserve">
          <source>Understand what are masked arrays and how they can be created</source>
          <target state="translated">理解什么是掩码数组,以及如何创建它们。</target>
        </trans-unit>
        <trans-unit id="64abb06a1b37c1ebb0933941a714064fe78f5ee7" translate="yes" xml:space="preserve">
          <source>Understanding CPU Dispatching, How the NumPy dispatcher works?</source>
          <target state="translated">了解CPU调度,NumPy调度器如何工作?</target>
        </trans-unit>
        <trans-unit id="233fa68a512b31fd9c7e11c16b1a271f55f3bf8e" translate="yes" xml:space="preserve">
          <source>Understanding the code &amp;amp; getting started</source>
          <target state="translated">了解代码并开始使用</target>
        </trans-unit>
        <trans-unit id="de8fa4e24f45bc650b9e48b7af77833b4a2c462a" translate="yes" xml:space="preserve">
          <source>Undoes &lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;, shifts zero-frequency terms to beginning of array.</source>
          <target state="translated">撤消&lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt;，将零频率项移到数组的开头。</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="4fee0b7959c07c12abdb6224e31004ed0e03fe8f" translate="yes" xml:space="preserve">
          <source>Unicode (fixed-length sequence of &lt;a href=&quot;https://docs.python.org/dev/c-api/unicode.html#c.Py_UNICODE&quot;&gt;&lt;code&gt;Py_UNICODE&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">Unicode（&lt;a href=&quot;https://docs.python.org/dev/c-api/unicode.html#c.Py_UNICODE&quot;&gt; &lt;code&gt;Py_UNICODE&lt;/code&gt; 的&lt;/a&gt;固定长度序列）</target>
        </trans-unit>
        <trans-unit id="1b41da839119c4860ed2bab536f19149822ad0f7" translate="yes" xml:space="preserve">
          <source>Unicode string</source>
          <target state="translated">统一码字符串</target>
        </trans-unit>
        <trans-unit id="b817c790c0e1eb2da135f6728ba7e7a734d36d2a" translate="yes" xml:space="preserve">
          <source>Uniforms</source>
          <target state="translated">Uniforms</target>
        </trans-unit>
        <trans-unit id="bd181d4ea0c5f747e6be59067008be3f6a568280" translate="yes" xml:space="preserve">
          <source>Uniforms (&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.random.generator.integers#numpy.random.Generator.integers&quot;&gt;&lt;code&gt;integers&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">制服（&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;generated/numpy.random.generator.integers#numpy.random.Generator.integers&quot;&gt; &lt;code&gt;integers&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="e9cccdf4596cb9bd6da09d86e9aec754328ad900" translate="yes" xml:space="preserve">
          <source>Uniforms (&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">制服（&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="2697f04d1c34bc0fd003a5d4f2f248be3c9842cb" translate="yes" xml:space="preserve">
          <source>Union types</source>
          <target state="translated">联盟类型</target>
        </trans-unit>
        <trans-unit id="7d19a005048195442e1a0367112ec40ef36c8dd2" translate="yes" xml:space="preserve">
          <source>Unique, sorted union of the input arrays.</source>
          <target state="translated">输入数组的唯一、排序联合。</target>
        </trans-unit>
        <trans-unit id="76a96316e226896e4f1438a10bfe2c7d74733b0a" translate="yes" xml:space="preserve">
          <source>Unit Conversion</source>
          <target state="translated">单位换算</target>
        </trans-unit>
        <trans-unit id="2b379c9399e276f2dc8f9383decfb02923fa06dd" translate="yes" xml:space="preserve">
          <source>Unitary array(s). The first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions have the same size as those of the input &lt;code&gt;a&lt;/code&gt;. The size of the last two dimensions depends on the value of &lt;code&gt;full_matrices&lt;/code&gt;. Only returned when &lt;code&gt;compute_uv&lt;/code&gt; is True.</source>
          <target state="translated">单一数组。前 &lt;code&gt;a.ndim - 2&lt;/code&gt; 维的大小与输入 &lt;code&gt;a&lt;/code&gt; 的大小相同。最后两个维度的大小取决于 &lt;code&gt;full_matrices&lt;/code&gt; 的值。仅在 &lt;code&gt;compute_uv&lt;/code&gt; 为True 时返回。</target>
        </trans-unit>
        <trans-unit id="89952e170b7f249d54c02c56dc948ea92d581887" translate="yes" xml:space="preserve">
          <source>Universal Functions</source>
          <target state="translated">通用功能</target>
        </trans-unit>
        <trans-unit id="7d5959424165b0a7771ddfd877626852ebcf0b02" translate="yes" xml:space="preserve">
          <source>Universal function. A fast element-wise, &lt;a href=&quot;#term-vectorization&quot;&gt;vectorized&lt;/a&gt; array operation. Examples include &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt; and &lt;code&gt;logical_or&lt;/code&gt;.</source>
          <target state="translated">通用功能。快速的逐元素&lt;a href=&quot;#term-vectorization&quot;&gt;矢量&lt;/a&gt;数组操作。示例包括 &lt;code&gt;add&lt;/code&gt; ， &lt;code&gt;sin&lt;/code&gt; 和 &lt;code&gt;logical_or&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4ed03ac8db5e6ac9dfa92939a06553bcbad44ab" translate="yes" xml:space="preserve">
          <source>Universal functions</source>
          <target state="translated">通用功能</target>
        </trans-unit>
        <trans-unit id="e3950ded82824788c1d59c1dc67f67776133fd02" translate="yes" xml:space="preserve">
          <source>Universal functions (&lt;code&gt;ufunc&lt;/code&gt;)</source>
          <target state="translated">通用功能（ &lt;code&gt;ufunc&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="825ac503579fb05389d22b5b4afa49b44dc3e914" translate="yes" xml:space="preserve">
          <source>Universal functions (ufunc)</source>
          <target state="translated">通用功能(ufunc)</target>
        </trans-unit>
        <trans-unit id="1c8ff35a75bf6e5497766666bbe2a77eb53892e4" translate="yes" xml:space="preserve">
          <source>Universal functions are callable objects that take</source>
          <target state="translated">通用函数是可调用的对象,它们以</target>
        </trans-unit>
        <trans-unit id="14ef4c614fdbba7fe91a08e7e1d79eb5845cd489" translate="yes" xml:space="preserve">
          <source>Universal functions can trip special floating-point status registers in your hardware (such as divide-by-zero). If available on your platform, these registers will be regularly checked during calculation. Error handling is controlled on a per-thread basis, and can be configured using the functions</source>
          <target state="translated">通用函数可以跳转你的硬件中的特殊浮点状态寄存器(如除以零)。如果你的平台上有这些寄存器,那么在计算过程中会定期检查。错误处理是在每个线程的基础上进行控制的,可以使用函数</target>
        </trans-unit>
        <trans-unit id="f2a6f922fe59febd69c7ec0550beca70f253abf6" translate="yes" xml:space="preserve">
          <source>Universal functions in NumPy are flexible enough to have mixed type signatures. Thus, for example, a universal function could be defined that works with floating-point and integer values. See &lt;a href=&quot;generated/numpy.ldexp#numpy.ldexp&quot;&gt;&lt;code&gt;ldexp&lt;/code&gt;&lt;/a&gt; for an example.</source>
          <target state="translated">NumPy中的通用函数足够灵活，可以具有混合类型签名。因此，例如，可以定义一个通用函数，该函数可用于浮点数和整数值。有关&lt;a href=&quot;generated/numpy.ldexp#numpy.ldexp&quot;&gt; &lt;code&gt;ldexp&lt;/code&gt; &lt;/a&gt;，请参见ldexp。</target>
        </trans-unit>
        <trans-unit id="3933468b1ecf18729ecddd910fc6819434f5cf58" translate="yes" xml:space="preserve">
          <source>Unlabeled tests like the ones above are run in the default &lt;code&gt;numpy.test()&lt;/code&gt; run. If you want to label your test as slow - and therefore reserved for a full &lt;code&gt;numpy.test(label='full')&lt;/code&gt; run, you can label it with &lt;code&gt;pytest.mark.slow&lt;/code&gt;:</source>
          <target state="translated">像上面的那些未标记的测试在默认的 &lt;code&gt;numpy.test()&lt;/code&gt; 运行中运行。如果您想将测试标记为慢速-因此保留用于完整的 &lt;code&gt;numpy.test(label='full')&lt;/code&gt; 运行，则可以使用 &lt;code&gt;pytest.mark.slow&lt;/code&gt; 将其标记为：</target>
        </trans-unit>
        <trans-unit id="dc2928ef9066faa49b65eacee08cc9ff5b8df03a" translate="yes" xml:space="preserve">
          <source>Unlabeled tests like the ones above are run in the default &lt;code&gt;scipy.test()&lt;/code&gt; run. If you want to label your test as slow - and therefore reserved for a full &lt;code&gt;scipy.test(label='full')&lt;/code&gt; run, you can label it with a decorator:</source>
          <target state="translated">如上的未标记测试在默认的 &lt;code&gt;scipy.test()&lt;/code&gt; 运行中运行。如果您想将测试标记为缓慢-因此保留用于完整的 &lt;code&gt;scipy.test(label='full')&lt;/code&gt; 运行，则可以使用装饰器将其标记为：</target>
        </trans-unit>
        <trans-unit id="f80a919f246626907387dd0726bbe89b8b51b4df" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">除非&lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;为False且满足返回输入数组的其他条件（请参见&lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;输入参数的描述）， &lt;code&gt;arr_t&lt;/code&gt; 是形状与输入数组相同的新数组，其类型为dtype，顺序为&lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef7dd27d4664eeedf99baaa7e0c49db6deaa478b" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">除非&lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;为False且满足返回输入数组的其他条件（请参见&lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;输入参数的描述）， &lt;code&gt;arr_t&lt;/code&gt; 是形状与输入数组相同的新数组，其类型为dtype，顺序为&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5fb1f8307f01c7e357482bf17ec2115ae4f2033" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">除非&lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;为False且返回输入数组的其他条件得到满足（请参阅&lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;输入参数的描述）， &lt;code&gt;arr_t&lt;/code&gt; 是形状与输入数组相同的新数组，其类型为dtype，顺序为&lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd72f00597798516e6971a2dbcb92a29bbbdaed9" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">除非&lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;为False且满足返回输入数组的其他条件（请参见&lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;输入参数的描述）， &lt;code&gt;arr_t&lt;/code&gt; 是形状与输入数组相同的新数组，其类型为dtype，顺序为&lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e2517e50c2cd18f9fa374a65d4b11b6882475bf" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;refcheck&lt;/code&gt; is False:</source>
          <target state="translated">除非 &lt;code&gt;refcheck&lt;/code&gt; 为False：</target>
        </trans-unit>
        <trans-unit id="5c06c023a0677199fe16b8704d88475521f3247a" translate="yes" xml:space="preserve">
          <source>Unless NumPy is made aware of an issue with this, this function is scheduled for rapid removal without replacement.</source>
          <target state="translated">除非NumPy意识到这一问题,否则该功能将被安排快速移除而不被替换。</target>
        </trans-unit>
        <trans-unit id="b12a052540dd37bc0bf5e60cc41fc32cdcbd4cfa" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt;&lt;code&gt;numpy.equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">与&lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt; &lt;code&gt;numpy.equal&lt;/code&gt; &lt;/a&gt;不同，此比较是通过首先从字符串末尾去除空格字符来执行的。提供此行为是为了与numarray向后兼容。</target>
        </trans-unit>
        <trans-unit id="6b2b2c64bbd5177dd4a58ffb6ba3be3f39244e9c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.fft.fftfreq#numpy.fft.fftfreq&quot;&gt;&lt;code&gt;fftfreq&lt;/code&gt;&lt;/a&gt; (but like &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.rfftfreq.html#scipy.fftpack.rfftfreq&quot;&gt;&lt;code&gt;scipy.fftpack.rfftfreq&lt;/code&gt;&lt;/a&gt;) the Nyquist frequency component is considered to be positive.</source>
          <target state="translated">与&lt;a href=&quot;numpy.fft.fftfreq#numpy.fft.fftfreq&quot;&gt; &lt;code&gt;fftfreq&lt;/code&gt; &lt;/a&gt;（但类似于&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.rfftfreq.html#scipy.fftpack.rfftfreq&quot;&gt; &lt;code&gt;scipy.fftpack.rfftfreq&lt;/code&gt; &lt;/a&gt;）不同，奈奎斯特频率分量被认为是正数。</target>
        </trans-unit>
        <trans-unit id="5f3a2cd1365b2531abc2f011c55c5607d024f719" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.greater#numpy.greater&quot;&gt;&lt;code&gt;numpy.greater&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">与&lt;a href=&quot;numpy.greater#numpy.greater&quot;&gt; &lt;code&gt;numpy.greater&lt;/code&gt; &lt;/a&gt;不同，此比较是通过首先从字符串末尾去除空格字符来执行的。提供此行为是为了与numarray向后兼容。</target>
        </trans-unit>
        <trans-unit id="8db96ae1e185ea43483bbcf2e2a064fdf5d5ac53" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.greater_equal#numpy.greater_equal&quot;&gt;&lt;code&gt;numpy.greater_equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">与&lt;a href=&quot;numpy.greater_equal#numpy.greater_equal&quot;&gt; &lt;code&gt;numpy.greater_equal&lt;/code&gt; &lt;/a&gt;不同，此比较是通过首先从字符串末尾去除空格字符来执行的。提供此行为是为了与numarray向后兼容。</target>
        </trans-unit>
        <trans-unit id="cc98934fa39c9d5a378edf27cd9d3fdf09aca64f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.less_equal#numpy.less_equal&quot;&gt;&lt;code&gt;numpy.less_equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">与&lt;a href=&quot;numpy.less_equal#numpy.less_equal&quot;&gt; &lt;code&gt;numpy.less_equal&lt;/code&gt; &lt;/a&gt;不同，此比较是通过首先从字符串末尾去除空格字符来执行的。提供此行为是为了与numarray向后兼容。</target>
        </trans-unit>
        <trans-unit id="13463cefef0c63fb378a22fb3869ee59d3559110" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.asmatrix&quot;&gt;&lt;code&gt;asmatrix&lt;/code&gt;&lt;/a&gt; does not make a copy if the input is already a matrix or an ndarray. Equivalent to &lt;code&gt;matrix(data, copy=False)&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;不同，如果输入已经是矩阵或ndarray ，则&lt;a href=&quot;#numpy.asmatrix&quot;&gt; &lt;code&gt;asmatrix&lt;/code&gt; &lt;/a&gt;不会复制。等效于 &lt;code&gt;matrix(data, copy=False)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0d5bc239c5d20908848ae252443d0a4e4413dd3" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.asmatrix#numpy.asmatrix&quot;&gt;&lt;code&gt;asmatrix&lt;/code&gt;&lt;/a&gt; does not make a copy if the input is already a matrix or an ndarray. Equivalent to &lt;code&gt;matrix(data, copy=False)&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;不同，如果输入已经是矩阵或ndarray ，则&lt;a href=&quot;numpy.asmatrix#numpy.asmatrix&quot;&gt; &lt;code&gt;asmatrix&lt;/code&gt; &lt;/a&gt;不会复制。等效于 &lt;code&gt;matrix(data, copy=False)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5b1299452ddecaa69fc7626dc84ab62f7aec6df" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.not_equal#numpy.not_equal&quot;&gt;&lt;code&gt;numpy.not_equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">与&lt;a href=&quot;numpy.not_equal#numpy.not_equal&quot;&gt; &lt;code&gt;numpy.not_equal&lt;/code&gt; &lt;/a&gt;不同，此比较是通过首先从字符串末尾去除空格字符来执行的。提供此行为是为了与numarray向后兼容。</target>
        </trans-unit>
        <trans-unit id="67d52aad6ea0dc9937241f5063f5755aaf1c098a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt;, each slice along the given axis is shuffled independently of the others.</source>
          <target state="translated">与&lt;a href=&quot;numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt; &lt;code&gt;shuffle&lt;/code&gt; &lt;/a&gt;不同，沿给定轴的每个切片都彼此独立地随机播放。</target>
        </trans-unit>
        <trans-unit id="1df4f0edb26736c54c37d1f3f53f3c4e05be97d2" translate="yes" xml:space="preserve">
          <source>Unlike MATLAB&amp;reg;, where anything on your path can be called immediately, with Python you need to first do an &amp;lsquo;import&amp;rsquo; statement to make functions in a particular file accessible.</source>
          <target state="translated">与MATLAB&amp;reg;不同，后者可以立即调用路径上的任何内容，而对于Python，则需要首先执行&amp;ldquo; import&amp;rdquo;语句，以使特定文件中的函数可访问。</target>
        </trans-unit>
        <trans-unit id="5e87736758d47e2ea2a3e97a051391d1169b07f7" translate="yes" xml:space="preserve">
          <source>Unlike MATLAB, where anything on your path can be called immediately, with Python you need to first do an &amp;lsquo;import&amp;rsquo; statement to make functions in a particular file accessible.</source>
          <target state="translated">与MATLAB不同，在MATLAB中，路径上的任何内容都可以立即调用，而使用Python，则需要首先执行&amp;ldquo; import&amp;rdquo;语句，以使特定文件中的函数可访问。</target>
        </trans-unit>
        <trans-unit id="dd2a67552682e7936714b3e48fc7203a2e15901a" translate="yes" xml:space="preserve">
          <source>Unlike in many matrix languages, the product operator &lt;code&gt;*&lt;/code&gt; operates elementwise in NumPy arrays. The matrix product can be performed using the &lt;code&gt;@&lt;/code&gt; operator (in python &amp;gt;=3.5) or the &lt;code&gt;dot&lt;/code&gt; function or method:</source>
          <target state="translated">与许多矩阵语言不同，乘积运算符 &lt;code&gt;*&lt;/code&gt; 在NumPy数组中按元素进行运算。可以使用 &lt;code&gt;@&lt;/code&gt; 运算符（在python&amp;gt; = 3.5中）或 &lt;code&gt;dot&lt;/code&gt; 函数或方法执行矩阵乘积：</target>
        </trans-unit>
        <trans-unit id="991d558a10f3fed386601ea572b9a25a236458aa" translate="yes" xml:space="preserve">
          <source>Unlike in the case of integer index arrays, in the boolean case, the result is a 1-D array containing all the elements in the indexed array corresponding to all the true elements in the boolean array. The elements in the indexed array are always iterated and returned in &lt;a href=&quot;../glossary#term-row-major&quot;&gt;row-major&lt;/a&gt; (C-style) order. The result is also identical to &lt;code&gt;y[np.nonzero(b)]&lt;/code&gt;. As with index arrays, what is returned is a copy of the data, not a view as one gets with slices.</source>
          <target state="translated">与整数索引数组的情况不同，在布尔值情况下，结果是一维数组，其中包含索引数组中的所有元素，它们对应于布尔数组中的所有真实元素。索引数组中的元素始终以&lt;a href=&quot;../glossary#term-row-major&quot;&gt;行&lt;/a&gt;优先（C样式）的顺序进行迭代和返回。结果也与 &lt;code&gt;y[np.nonzero(b)]&lt;/code&gt; 。与索引数组一样，返回的是数据的副本，而不是与切片一起获取的视图。</target>
        </trans-unit>
        <trans-unit id="9b9e6d341e111d5abaa8c91d594d12353e24be13" translate="yes" xml:space="preserve">
          <source>Unlike lists and tuples, numpy arrays support multidimensional indexing for multidimensional arrays. That means that it is not necessary to separate each dimension&amp;rsquo;s index into its own set of square brackets.</source>
          <target state="translated">与列表和元组不同，numpy数组支持多维数组的多维索引。这意味着不必将每个维度的索引都分成自己的一组方括号。</target>
        </trans-unit>
        <trans-unit id="70d4d959a48f1152d15702553262318c5fb98806" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Chebyshev series is a Chebyshev series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个Chebyshev级数的差是一个Chebyshev级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此减法就像&amp;ldquo;标准&amp;rdquo;多项式一样，只是&amp;ldquo;按分量&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="e46cc304c2f214fabbfe81dd6c99872edb6df227" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Hermite series is a Hermite series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个Hermite级数的差是一个Hermite级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此减法就像&amp;ldquo;标准&amp;rdquo;多项式的减法一样，只是&amp;ldquo;按分量进行&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0beee9ca9d008b84130a4966827a4791db0f0fc1" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Laguerre series is a Laguerre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个Laguerre级数的差是Laguerre级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此减法就像&amp;ldquo;标准&amp;rdquo;多项式一样，只是&amp;ldquo;按分量进行&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="853913b39ae1eac706caf9dd0fbf8022480e5898" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Legendre series is a Legendre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个勒让德级数的差是勒让德级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此减法就像&amp;ldquo;标准&amp;rdquo;多项式一样，只是&amp;ldquo;按分量&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="817c653b37e40c515ff2966447fe5fceb6d50c2b" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Chebyshev series is a Chebyshev series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个Chebyshev级数的和是一个Chebyshev级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此加法就像&amp;ldquo;标准&amp;rdquo;多项式的加法一样，只是&amp;ldquo;逐分量&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="96e94bebc99e72aa93e0ba2b3e9d976f9a242788" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Hermite series is a Hermite series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个Hermite系列的总和是一个Hermite系列（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此加法就像&amp;ldquo;标准&amp;rdquo;多项式的加法一样，只是&amp;ldquo;按分量进行&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="a1bfae60ca127fe23c05d0fcb5e3af8c025e808e" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Laguerre series is a Laguerre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个Laguerre级数的和是Laguerre级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此加法就像&amp;ldquo;标准&amp;rdquo;多项式的加法一样，只是&amp;ldquo;逐分量&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="479fccdc37cae736330d681081d02fd22d2b4c05" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Legendre series is a Legendre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个勒让德级数的总和是勒让德级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此加法就像&amp;ldquo;标准&amp;rdquo;多项式的加法一样，只是&amp;ldquo;按分量进行&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="c37836d2f2fa6578d699e351ca0672a2d96cc650" translate="yes" xml:space="preserve">
          <source>Unlike other numpy scalars, structured scalars are mutable and act like views into the original array, such that modifying the scalar will modify the original array. Structured scalars also support access and assignment by field name:</source>
          <target state="translated">与其他numpy标量不同,结构化标量是可以突变的,就像进入原始数组的视图一样,这样修改标量就会修改原始数组。结构化标量还支持按字段名访问和赋值。</target>
        </trans-unit>
        <trans-unit id="191384b28da289c339b69142c174b4bdb8ca4902" translate="yes" xml:space="preserve">
          <source>Unlike some of the references (such as array and mask indices) assignments are always made to the original data in the array (indeed, nothing else would make sense!). Note though, that some actions may not work as one may naively expect. This particular example is often surprising to people:</source>
          <target state="translated">与一些引用(如数组和掩码索引)不同,赋值总是对数组中的原始数据进行赋值(事实上,没有别的意义!)。但请注意,有些操作可能并不像人们天真地期望的那样。这个特殊的例子常常让人感到惊讶。</target>
        </trans-unit>
        <trans-unit id="6138c52b3d14f1f06df9ad9cd32f8b7c13aad36f" translate="yes" xml:space="preserve">
          <source>Unlike the built-in &lt;a href=&quot;https://docs.python.org/dev/library/math.html#math.isclose&quot;&gt;&lt;code&gt;math.isclose&lt;/code&gt;&lt;/a&gt;, the above equation is not symmetric in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; &amp;ndash; it assumes &lt;code&gt;b&lt;/code&gt; is the reference value &amp;ndash; so that &lt;code&gt;isclose(a, b)&lt;/code&gt; might be different from &lt;code&gt;isclose(b, a)&lt;/code&gt;. Furthermore, the default value of atol is not zero, and is used to determine what small values should be considered close to zero. The default value is appropriate for expected values of order unity: if the expected values are significantly smaller than one, it can result in false positives. &lt;code&gt;atol&lt;/code&gt; should be carefully selected for the use case at hand. A zero value for &lt;code&gt;atol&lt;/code&gt; will result in &lt;code&gt;False&lt;/code&gt; if either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is zero.</source>
          <target state="translated">与内置&lt;a href=&quot;https://docs.python.org/dev/library/math.html#math.isclose&quot;&gt; &lt;code&gt;math.isclose&lt;/code&gt; 不同&lt;/a&gt;，上述方程式在 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 中不对称-假定 &lt;code&gt;b&lt;/code&gt; 是参考值-因此 &lt;code&gt;isclose(a, b)&lt;/code&gt; 可能与 &lt;code&gt;isclose(b, a)&lt;/code&gt; 。此外，atol的默认值不为零，用于确定应将哪些较小的值视为接近零。默认值适用于阶数为1的期望值：如果期望值明显小于1，则可能导致误报。应该仔细选择 &lt;code&gt;atol&lt;/code&gt; 作为手边的用例。零值 &lt;code&gt;atol&lt;/code&gt; 会导致 &lt;code&gt;False&lt;/code&gt; 如果任 &lt;code&gt;a&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt; 为零。</target>
        </trans-unit>
        <trans-unit id="f562bb48bffcb6e3afb75a4ff67fcee5424e89c9" translate="yes" xml:space="preserve">
          <source>Unlike the builtin &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, this supports the &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#bufferobjects&quot;&gt;Buffer Protocol&lt;/a&gt;, exposing its contents as UCS4:</source>
          <target state="translated">与内置的&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;不同，它支持&lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#bufferobjects&quot;&gt;Buffer Protocol&lt;/a&gt;，将其内容公开为UCS4：</target>
        </trans-unit>
        <trans-unit id="b9b43bc2298a20c8156a6023d94ab148e7869ea1" translate="yes" xml:space="preserve">
          <source>Unlike the free function &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, this method on &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; allows the elements of the shape parameter to be passed in as separate arguments. For example, &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; is equivalent to &lt;code&gt;a.reshape((10, 11))&lt;/code&gt;.</source>
          <target state="translated">不同于免费功能&lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt;，在此方法&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;允许形状参数中的元素，以作为单独的参数传递。例如， &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; 等效于 &lt;code&gt;a.reshape((10, 11))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c055ec1da31f5b3a36529d3d52329cd0cef8c5de" translate="yes" xml:space="preserve">
          <source>Unlike the free function &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, this method on &lt;code&gt;ndarray&lt;/code&gt; allows the elements of the shape parameter to be passed in as separate arguments. For example, &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; is equivalent to &lt;code&gt;a.reshape((10, 11))&lt;/code&gt;.</source>
          <target state="translated">不同于免费功能&lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt;，在此方法 &lt;code&gt;ndarray&lt;/code&gt; 允许形状参数中的元素，以作为单独的参数传递。例如， &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; 等效于 &lt;code&gt;a.reshape((10, 11))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6f1b0bab79178181c6f1258ede14dd475f1a6b3" translate="yes" xml:space="preserve">
          <source>Unlike the previous &lt;code&gt;nose&lt;/code&gt;-based implementation, this class is not publicly exposed as it performs some &lt;code&gt;numpy&lt;/code&gt;-specific warning suppression.</source>
          <target state="translated">与以前的基于 &lt;code&gt;nose&lt;/code&gt; 的实现不同，此类不公开公开，因为它执行一些特定于 &lt;code&gt;numpy&lt;/code&gt; 的警告抑制。</target>
        </trans-unit>
        <trans-unit id="0206a9a6a08e980ce9de3768f0db78bc718405ea" translate="yes" xml:space="preserve">
          <source>Unlike the standard numpy comparison operators, the ones in the &lt;code&gt;char&lt;/code&gt; module strip trailing whitespace characters before performing the comparison.</source>
          <target state="translated">与标准numpy比较运算符不同， &lt;code&gt;char&lt;/code&gt; 模块中的运算符在执行比较之前会删除尾随空白字符。</target>
        </trans-unit>
        <trans-unit id="7fbacb4b6a81b741ccf818cdd058fa9d9f52d43b" translate="yes" xml:space="preserve">
          <source>Unmasking an entry</source>
          <target state="translated">解除屏蔽条目</target>
        </trans-unit>
        <trans-unit id="de9f965938adc0324fd8157cc466e2436f4a68e4" translate="yes" xml:space="preserve">
          <source>Unmasking an entry by direct assignment will silently fail if the masked array has a &lt;em&gt;hard&lt;/em&gt; mask, as shown by the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt;&lt;code&gt;hardmask&lt;/code&gt;&lt;/a&gt; attribute. This feature was introduced to prevent overwriting the mask. To force the unmasking of an entry where the array has a hard mask, the mask must first to be softened using the &lt;a href=&quot;generated/numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt;&lt;code&gt;soften_mask&lt;/code&gt;&lt;/a&gt; method before the allocation. It can be re-hardened with &lt;a href=&quot;generated/numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt;&lt;code&gt;harden_mask&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果被掩码的数组具有&lt;em&gt;硬&lt;/em&gt;掩码，则通过直接分配取消掩码条目将无提示地失败，如&lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt; &lt;code&gt;hardmask&lt;/code&gt; &lt;/a&gt;属性所示。引入此功能是为了防止覆盖掩码。要在阵列具有硬掩码的情况下强制取消条目的掩码，必须先在分配之前使用&lt;a href=&quot;generated/numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt; &lt;code&gt;soften_mask&lt;/code&gt; &lt;/a&gt;方法将掩码软化。可以使用&lt;a href=&quot;generated/numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt; &lt;code&gt;harden_mask&lt;/code&gt; &lt;/a&gt;重新加固它：</target>
        </trans-unit>
        <trans-unit id="c37a5ee094534c733a693e498e6b83c12096d6e0" translate="yes" xml:space="preserve">
          <source>Unmasking an entry by direct assignment will silently fail if the masked array has a &lt;em&gt;hard&lt;/em&gt; mask, as shown by the &lt;code&gt;hardmask&lt;/code&gt; attribute. This feature was introduced to prevent overwriting the mask. To force the unmasking of an entry where the array has a hard mask, the mask must first to be softened using the &lt;a href=&quot;generated/numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt;&lt;code&gt;soften_mask&lt;/code&gt;&lt;/a&gt; method before the allocation. It can be re-hardened with &lt;a href=&quot;generated/numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt;&lt;code&gt;harden_mask&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果被掩码的数组具有&lt;em&gt;硬&lt;/em&gt;掩码，则通过直接分配取消对条目的掩码将自动失败，如 &lt;code&gt;hardmask&lt;/code&gt; 属性所示。引入此功能是为了防止覆盖掩码。要在阵列具有硬掩码的情况下强制取消条目的掩码，必须先在分配之前使用&lt;a href=&quot;generated/numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt; &lt;code&gt;soften_mask&lt;/code&gt; &lt;/a&gt;方法将掩码软化。可以使用&lt;a href=&quot;generated/numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt; &lt;code&gt;harden_mask&lt;/code&gt; &lt;/a&gt;重新加固它：</target>
        </trans-unit>
        <trans-unit id="5724dd60c593622fc16f28573a8be39237c1817b" translate="yes" xml:space="preserve">
          <source>Unmodified core dimensions that share the same name must have the same size. Each dimension name typically corresponds to one level of looping in the elementary function&amp;rsquo;s implementation.</source>
          <target state="translated">具有相同名称的未修改核心尺寸必须具有相同的大小。每个维名称通常对应于基本函数实现中的一个循环级别。</target>
        </trans-unit>
        <trans-unit id="0c8c8df9f7c1cb71b2c99863e55f28b2342c49c8" translate="yes" xml:space="preserve">
          <source>Unpacks elements of a uint8 array into a binary-valued output array.</source>
          <target state="translated">将一个uint8数组中的元素解包成一个二进制值的输出数组。</target>
        </trans-unit>
        <trans-unit id="cfb0e26f84a72aa991cbd86d2a8e70f9268c36da" translate="yes" xml:space="preserve">
          <source>Unpickling while loading requires explicit opt-in</source>
          <target state="translated">加载过程中取消挑拣需要明确的选择。</target>
        </trans-unit>
        <trans-unit id="c2316b90ad07a17bab89992c697827520a7c1a76" translate="yes" xml:space="preserve">
          <source>Unsafe int casting of the num attribute in &lt;code&gt;linspace&lt;/code&gt;</source>
          <target state="translated">在NUM属性的不安全INT铸造 &lt;code&gt;linspace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b27e09825b38c1619e31484868bfeb48e96d8d2" translate="yes" xml:space="preserve">
          <source>Unsigned integer</source>
          <target state="translated">无符号整数</target>
        </trans-unit>
        <trans-unit id="19201d9c175004fe2d2c285a14b33dc2f3c58964" translate="yes" xml:space="preserve">
          <source>Unsigned integer (0 to 18446744073709551615)</source>
          <target state="translated">无符号整数(0至18446744073709551615)</target>
        </trans-unit>
        <trans-unit id="d614ab4b08ea51c529ca2afd42bd5cb8f14039b7" translate="yes" xml:space="preserve">
          <source>Unsigned integer (0 to 255)</source>
          <target state="translated">无符号整数(0至255)</target>
        </trans-unit>
        <trans-unit id="ece1b13212dbdde6f6979b0eb6cfffcea163e303" translate="yes" xml:space="preserve">
          <source>Unsigned integer (0 to 4294967295)</source>
          <target state="translated">无符号整数(0至4294967295)</target>
        </trans-unit>
        <trans-unit id="5280260c5f39b844aa889ca5265bd63ac321070f" translate="yes" xml:space="preserve">
          <source>Unsigned integer (0 to 65535)</source>
          <target state="translated">无符号整数(0至65535)</target>
        </trans-unit>
        <trans-unit id="b2aab86479226bc8229a66fd8baa56a5fe8412a4" translate="yes" xml:space="preserve">
          <source>Unsigned integer type, compatible with C &lt;code&gt;unsigned char&lt;/code&gt;.</source>
          <target state="translated">无符号整数类型，与C &lt;code&gt;unsigned char&lt;/code&gt; 兼容。</target>
        </trans-unit>
        <trans-unit id="595c836cdf50bf3f4050476b93f63ab67a1da92f" translate="yes" xml:space="preserve">
          <source>Unsigned integer type, compatible with C &lt;code&gt;unsigned int&lt;/code&gt;.</source>
          <target state="translated">无符号整数类型，与C &lt;code&gt;unsigned int&lt;/code&gt; 兼容。</target>
        </trans-unit>
        <trans-unit id="2e05de9d1a63c40d810e731eb7ec8ec87ae658b9" translate="yes" xml:space="preserve">
          <source>Unsigned integer type, compatible with C &lt;code&gt;unsigned long&lt;/code&gt;.</source>
          <target state="translated">无符号整数类型，与C &lt;code&gt;unsigned long&lt;/code&gt; 兼容。</target>
        </trans-unit>
        <trans-unit id="c931b6dcc5518010a4218c052e902b5fef939e8d" translate="yes" xml:space="preserve">
          <source>Unsigned integer type, compatible with C &lt;code&gt;unsigned short&lt;/code&gt;.</source>
          <target state="translated">无符号整数类型，与C &lt;code&gt;unsigned short&lt;/code&gt; 兼容。</target>
        </trans-unit>
        <trans-unit id="fd0a7731fa8a0a0f488308cec0945059f2de6581" translate="yes" xml:space="preserve">
          <source>Unsigned integer types</source>
          <target state="translated">无符号整数类型</target>
        </trans-unit>
        <trans-unit id="432373371510943ee2651ebf21148b86384d0a29" translate="yes" xml:space="preserve">
          <source>Unsigned integers:</source>
          <target state="translated">无符号整数。</target>
        </trans-unit>
        <trans-unit id="c824dd22d12bde4feee6277b067eb0b05fa4fdf1" translate="yes" xml:space="preserve">
          <source>Unsigned versions of the integers can be defined by pre-pending a &amp;lsquo;u&amp;rsquo; to the front of the integer name.</source>
          <target state="translated">整数的无符号版本可以通过在整数名称的前面添加&amp;ldquo; u&amp;rdquo;来定义。</target>
        </trans-unit>
        <trans-unit id="3b4a1ed161e3d5d468bc7819a4a4469e69fb390c" translate="yes" xml:space="preserve">
          <source>Unstructured array or dtype to convert.</source>
          <target state="translated">要转换的非结构化数组或dtype。</target>
        </trans-unit>
        <trans-unit id="8443c9cc12807ec6c811788bbce2592aaf619083" translate="yes" xml:space="preserve">
          <source>Unstructured array with one more dimension.</source>
          <target state="translated">多一个维度的非结构化数组。</target>
        </trans-unit>
        <trans-unit id="239cbdafe6ac9fc4ef398b9a7b1e9b6cb6e3e71d" translate="yes" xml:space="preserve">
          <source>Until August 2020, this said:</source>
          <target state="translated">直到2020年8月,这说。</target>
        </trans-unit>
        <trans-unit id="cd4f4dc80803ac1f52848ab12f25d8e2d5b8e16f" translate="yes" xml:space="preserve">
          <source>Until Python 3.5 the only disadvantage of using the array type was that you had to use &lt;code&gt;dot&lt;/code&gt; instead of &lt;code&gt;*&lt;/code&gt; to multiply (reduce) two tensors (scalar product, matrix vector multiplication etc.). Since Python 3.5 you can use the matrix multiplication &lt;code&gt;@&lt;/code&gt; operator.</source>
          <target state="translated">在Python 3.5之前，使用数组类型的唯一缺点是必须使用 &lt;code&gt;dot&lt;/code&gt; 而不是 &lt;code&gt;*&lt;/code&gt; 来乘（减少）两个张量（标量积，矩阵向量乘法等）。从Python 3.5开始，您可以使用矩阵乘法 &lt;code&gt;@&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="91aa49f62879d325c6707e96a59652eaa942e8ca" translate="yes" xml:space="preserve">
          <source>Until the 1.15 release, NumPy used the &lt;a href=&quot;https://nose.readthedocs.io/en/latest/&quot;&gt;nose&lt;/a&gt; testing framework, it now uses the &lt;a href=&quot;https://pytest.readthedocs.io&quot;&gt;pytest&lt;/a&gt; framework. The older framework is still maintained in order to support downstream projects that use the old numpy framework, but all tests for NumPy should use pytest.</source>
          <target state="translated">在1.15版之前，NumPy使用&lt;a href=&quot;https://nose.readthedocs.io/en/latest/&quot;&gt;鼻子&lt;/a&gt;测试框架，现在使用&lt;a href=&quot;https://pytest.readthedocs.io&quot;&gt;pytest&lt;/a&gt;框架。为了支持使用旧numpy框架的下游项目，仍旧维护旧框架，但是所有针对NumPy的测试都应使用pytest。</target>
        </trans-unit>
        <trans-unit id="f13be7738e1389f72c0f88aa84d17719f746bf4a" translate="yes" xml:space="preserve">
          <source>Unused.</source>
          <target state="translated">Unused.</target>
        </trans-unit>
        <trans-unit id="52bd5ee224646394816a409132afdc6f181c7d8b" translate="yes" xml:space="preserve">
          <source>Unwelcome sexual attention.</source>
          <target state="translated">不受欢迎的性关注。</target>
        </trans-unit>
        <trans-unit id="91235b6cec5e2bdecb806fae5c6f1c673c46dd54" translate="yes" xml:space="preserve">
          <source>Unwrap by changing deltas between values to 2*pi complement.</source>
          <target state="translated">将数值之间的三角区改为2*pi补全,就可以解开。</target>
        </trans-unit>
        <trans-unit id="cba2ade8e0d37d0f36a249f716f7633b555a4616" translate="yes" xml:space="preserve">
          <source>Unwrap radian phase &lt;code&gt;p&lt;/code&gt; by changing absolute jumps greater than &lt;code&gt;discont&lt;/code&gt; to their 2*pi complement along the given axis.</source>
          <target state="translated">通过改变大于给定轴上2 * pi补码的绝对跳 &lt;code&gt;discont&lt;/code&gt; 来解开弧度相位 &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31f87bfbdb61e41f06f9d6ba5c2c33b85dec73cd" translate="yes" xml:space="preserve">
          <source>Upcasting:</source>
          <target state="translated">Upcasting:</target>
        </trans-unit>
        <trans-unit id="579edc70cbe349fcc3048fa42d7c965a563d10ae" translate="yes" xml:space="preserve">
          <source>Update PyPI</source>
          <target state="translated">更新PyPI</target>
        </trans-unit>
        <trans-unit id="a305b240bddfefe147af5326421c8f0107898199" translate="yes" xml:space="preserve">
          <source>Update Release documentation</source>
          <target state="translated">更新发行文件</target>
        </trans-unit>
        <trans-unit id="a858dc159ecba3062c1406c8e0fb587c83eace91" translate="yes" xml:space="preserve">
          <source>Update policy documents such as this one.</source>
          <target state="translated">更新政策文件,如这一文件。</target>
        </trans-unit>
        <trans-unit id="676d87bea990c4c73ff4081f6b93aae5ebcc7dac" translate="yes" xml:space="preserve">
          <source>Update scipy.org</source>
          <target state="translated">更新scipy.org</target>
        </trans-unit>
        <trans-unit id="64e81e08ab40d294f4651a8208d4e909d5156cbf" translate="yes" xml:space="preserve">
          <source>Update the Milestones in Trac.</source>
          <target state="translated">更新Trac中的里程碑。</target>
        </trans-unit>
        <trans-unit id="8117487cd3d843fb21b5965b5f6cf86d9fd9d8a6" translate="yes" xml:space="preserve">
          <source>Update the release notes with a Highlights section. Mention some of the following:</source>
          <target state="translated">在发布说明中更新亮点部分。提到以下一些内容:</target>
        </trans-unit>
        <trans-unit id="cd25c09dc3e898187644d607cbbc12c4edc2554e" translate="yes" xml:space="preserve">
          <source>Update the release status and create a release &amp;ldquo;tag&amp;rdquo;</source>
          <target state="translated">更新发布状态并创建发布&amp;ldquo;标签&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="1db22e1acc193e90fbde99ab0d68584a24cec01a" translate="yes" xml:space="preserve">
          <source>Update the version of the master branch</source>
          <target state="translated">更新主分支的版本</target>
        </trans-unit>
        <trans-unit id="777088119e41bc0469a64ccb283496abe08bc95e" translate="yes" xml:space="preserve">
          <source>Updated version of PyArray_Correlate, which uses the usual definition of correlation for 1d arrays. The correlation is computed at each output point by multiplying &lt;em&gt;op1&lt;/em&gt; by a shifted version of &lt;em&gt;op2&lt;/em&gt; and summing the result. As a result of the shift, needed values outside of the defined range of &lt;em&gt;op1&lt;/em&gt; and &lt;em&gt;op2&lt;/em&gt; are interpreted as zero. The mode determines how many shifts to return: 0 - return only shifts that did not need to assume zero- values; 1 - return an object that is the same size as &lt;em&gt;op1&lt;/em&gt;, 2 - return all possible shifts (any overlap at all is accepted).</source>
          <target state="translated">PyArray_Correlate的更新版本，它使用一维数组的常规相关定义。通过将&lt;em&gt;op1&lt;/em&gt;乘以&lt;em&gt;op2&lt;/em&gt;的移位版本并求和，可以在每个输出点计算相关性。移位的结果是，超出&lt;em&gt;op1&lt;/em&gt;和&lt;em&gt;op2&lt;/em&gt;定义范围的所需值被解释为零。该模式确定要返回的班次：0-仅返回不需要采用零值的班次；否则，返回0。1-返回与&lt;em&gt;op1&lt;/em&gt;大小相同的对象，2-返回所有可能的移位（任何重叠都被接受）。</target>
        </trans-unit>
        <trans-unit id="a7409084cf2605b5cad89ac1878143241b496ed1" translate="yes" xml:space="preserve">
          <source>Updating the code</source>
          <target state="translated">更新代码</target>
        </trans-unit>
        <trans-unit id="2ab89ee68187f5c809160685dea5430718e73ea0" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;doc/changelog/1.14.5-changelog.rst&lt;/code&gt; as a binary file.</source>
          <target state="translated">将 &lt;code&gt;doc/changelog/1.14.5-changelog.rst&lt;/code&gt; 上传为二进制文件。</target>
        </trans-unit>
        <trans-unit id="d1cf0b974aedc608d19f10cd46abf353ccf013a1" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;doc/changelog/1.19.0-changelog.rst&lt;/code&gt; as a binary file.</source>
          <target state="translated">将 &lt;code&gt;doc/changelog/1.19.0-changelog.rst&lt;/code&gt; 作为二进制文件上传。</target>
        </trans-unit>
        <trans-unit id="e8242899ac44525eea3639fc9196319bcd5798e1" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;release/README.rst&lt;/code&gt; as a binary file.</source>
          <target state="translated">将 &lt;code&gt;release/README.rst&lt;/code&gt; 作为二进制文件上传。</target>
        </trans-unit>
        <trans-unit id="4be4f20f37deddb1b1a33a72c43f77bfa0490a76" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;release/installers/numpy-1.14.5.tar.gz&lt;/code&gt; as a binary file.</source>
          <target state="translated">上传 &lt;code&gt;release/installers/numpy-1.14.5.tar.gz&lt;/code&gt; 作为二进制文件。</target>
        </trans-unit>
        <trans-unit id="c5f92deadaf10f46166261ad542bc8986cab5d64" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;release/installers/numpy-1.14.5.zip&lt;/code&gt; as a binary file.</source>
          <target state="translated">将二进制 &lt;code&gt;release/installers/numpy-1.14.5.zip&lt;/code&gt; 载。</target>
        </trans-unit>
        <trans-unit id="33203022b8466a3576e1acf3d1dc460eb5c8960e" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;release/installers/numpy-1.19.0.tar.gz&lt;/code&gt; as a binary file.</source>
          <target state="translated">上传 &lt;code&gt;release/installers/numpy-1.19.0.tar.gz&lt;/code&gt; 作为二进制文件。</target>
        </trans-unit>
        <trans-unit id="0420f995c997e7a2ced387d97a072ef37e7e87ef" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;release/installers/numpy-1.19.0.zip&lt;/code&gt; as a binary file.</source>
          <target state="translated">上载 &lt;code&gt;release/installers/numpy-1.19.0.zip&lt;/code&gt; 作为二进制文件。</target>
        </trans-unit>
        <trans-unit id="feca53bac4346b96bf1a7a8af5a58f9b95162f3b" translate="yes" xml:space="preserve">
          <source>Upload documents to numpy.org</source>
          <target state="translated">上传文件到numpy.org</target>
        </trans-unit>
        <trans-unit id="8bc2fac0bfff4c1c9d6c6f5a22fc6d38d8b5119c" translate="yes" xml:space="preserve">
          <source>Upload files to github</source>
          <target state="translated">上传文件到github</target>
        </trans-unit>
        <trans-unit id="37ea156fa200c4b1e62bfc88ad83c78600949638" translate="yes" xml:space="preserve">
          <source>Upload to PyPI</source>
          <target state="translated">上传到PyPI</target>
        </trans-unit>
        <trans-unit id="c16ab259dc55f6326fdf3044018a5aed36c63fd1" translate="yes" xml:space="preserve">
          <source>Upload to PyPI using &lt;code&gt;twine&lt;/code&gt;. A recent version of &lt;code&gt;twine&lt;/code&gt; of is needed after recent PyPI changes, version &lt;code&gt;1.11.0&lt;/code&gt; was used here.</source>
          <target state="translated">使用 &lt;code&gt;twine&lt;/code&gt; 上传到PyPI 。在最近的PyPI更改之后，需要使用 &lt;code&gt;twine&lt;/code&gt; 的最新版本，此处使用的是 &lt;code&gt;1.11.0&lt;/code&gt; 版本。</target>
        </trans-unit>
        <trans-unit id="440f57ef8033b34c5e177db217a4c616fe0710cc" translate="yes" xml:space="preserve">
          <source>Upload to PyPI using &lt;code&gt;twine&lt;/code&gt;. A recent version of &lt;code&gt;twine&lt;/code&gt; of is needed after recent PyPI changes, version &lt;code&gt;3.1.1&lt;/code&gt; was used here:</source>
          <target state="translated">使用 &lt;code&gt;twine&lt;/code&gt; 上传到PyPI 。在最近的PyPI更改后，需要使用的最新版本的 &lt;code&gt;twine&lt;/code&gt; ，此处使用的版本为 &lt;code&gt;3.1.1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6565e74e2ff5bcf02b09c60c49c14fcfab1feb84" translate="yes" xml:space="preserve">
          <source>Uploading to PyPI</source>
          <target state="translated">上传到PyPI</target>
        </trans-unit>
        <trans-unit id="9b72e324adb06ca1d01de4a8922403d911a439a0" translate="yes" xml:space="preserve">
          <source>Upper bound to relative error due to rounding in 64-bit floating point arithmetic.</source>
          <target state="translated">64位浮点算术中四舍五入导致的相对误差的上界。</target>
        </trans-unit>
        <trans-unit id="80d1841e63317d86d0b2bbae07f2e08dc59ff7f9" translate="yes" xml:space="preserve">
          <source>Upper boundary of the output interval. All values generated will be less than high. The default value is 1.0.</source>
          <target state="translated">输出区间的上界。所有生成的值都将小于高值。默认值为1.0。</target>
        </trans-unit>
        <trans-unit id="94608c7ff5f4700d78cab2cf3285f4a9e6dc1615" translate="yes" xml:space="preserve">
          <source>Upper boundary of the output interval. All values generated will be less than or equal to high. The default value is 1.0.</source>
          <target state="translated">输出区间的上界。所有生成的值将小于或等于高。默认值为1.0。</target>
        </trans-unit>
        <trans-unit id="52be5864b9af229753de85f916fa14a1fa97d3a1" translate="yes" xml:space="preserve">
          <source>Upper limit, must be larger than &lt;code&gt;left&lt;/code&gt;.</source>
          <target state="translated">上限，必须大于 &lt;code&gt;left&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="528933f6438e2665073f1a6a0a370889bd9e0bae" translate="yes" xml:space="preserve">
          <source>Upper or lower-triangular Cholesky factor of &lt;code&gt;a&lt;/code&gt;. Returns a matrix object if &lt;code&gt;a&lt;/code&gt; is a matrix object.</source>
          <target state="translated">上或下三角的Cholesky因数 &lt;code&gt;a&lt;/code&gt; 。如果 &lt;code&gt;a&lt;/code&gt; 是矩阵对象，则返回矩阵对象。</target>
        </trans-unit>
        <trans-unit id="57bb98258946012ee6623d2627640ef4f5f0bbc8" translate="yes" xml:space="preserve">
          <source>Upper triangle of an array.</source>
          <target state="translated">阵列的上三角。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="0385484fbb876c4198e9c03bf37e041d3810df5e" translate="yes" xml:space="preserve">
          <source>Usage and Examples</source>
          <target state="translated">使用方法和例子</target>
        </trans-unit>
        <trans-unit id="a6ddf950ead3f5a277ec641c8bb4408b4523e874" translate="yes" xml:space="preserve">
          <source>Usage of ATLAS and other accelerated libraries in NumPy can be disabled via:</source>
          <target state="translated">在NumPy中使用ATLAS和其他加速库可以通过以下方式禁用。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="f8422a8af0050351fb69661fa171b15f26430c90" translate="yes" xml:space="preserve">
          <source>Use 4-space indents and no tabs at all.</source>
          <target state="translated">使用4空格缩进,完全不使用制表符。</target>
        </trans-unit>
        <trans-unit id="a4f4f55257b83792366b61f4d5627bfeafb83aa3" translate="yes" xml:space="preserve">
          <source>Use 64-bit integer size on 64-bit platforms in fallback lapack_lite</source>
          <target state="translated">在回退lapack_lite中,在64位平台上使用64位整数大小。</target>
        </trans-unit>
        <trans-unit id="a15df8cc43a52230464924d2366701940520ece7" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt; because &lt;a href=&quot;#numpy.Inf&quot;&gt;&lt;code&gt;Inf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.Infinity&quot;&gt;&lt;code&gt;Infinity&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.PINF&quot;&gt;&lt;code&gt;PINF&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#numpy.infty&quot;&gt;&lt;code&gt;infty&lt;/code&gt;&lt;/a&gt; are aliases for &lt;a href=&quot;#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt;. For more details, see &lt;a href=&quot;#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; &lt;/a&gt;是因为&lt;a href=&quot;#numpy.Inf&quot;&gt; &lt;code&gt;Inf&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#numpy.Infinity&quot;&gt; &lt;code&gt;Infinity&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#numpy.PINF&quot;&gt; &lt;code&gt;PINF&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#numpy.infty&quot;&gt; &lt;code&gt;infty&lt;/code&gt; &lt;/a&gt;是&lt;a href=&quot;#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; 的&lt;/a&gt;别名。有关更多详细信息，请参见&lt;a href=&quot;#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="351414f7c521f4b341a7a407035466c24988a100" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;numpy.genfromtxt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;numpy.genfromtxt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1081c5bfa15ce1f1d2793775db1564a0d257f094" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../reference/generated/numpy.load#numpy.load&quot;&gt;&lt;code&gt;numpy.load&lt;/code&gt;&lt;/a&gt;. It can read files generated by any of &lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt;&lt;code&gt;numpy.save&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../reference/generated/numpy.savez#numpy.savez&quot;&gt;&lt;code&gt;numpy.savez&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../reference/generated/numpy.savez_compressed#numpy.savez_compressed&quot;&gt;&lt;code&gt;numpy.savez_compressed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;../reference/generated/numpy.load#numpy.load&quot;&gt; &lt;code&gt;numpy.load&lt;/code&gt; &lt;/a&gt;。它可以读取&lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt; &lt;code&gt;numpy.save&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../reference/generated/numpy.savez#numpy.savez&quot;&gt; &lt;code&gt;numpy.savez&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../reference/generated/numpy.savez_compressed#numpy.savez_compressed&quot;&gt; &lt;code&gt;numpy.savez_compressed&lt;/code&gt; 中的&lt;/a&gt;任何一个生成的文件。</target>
        </trans-unit>
        <trans-unit id="c2da46a0755bb961c8bf3e39960e920a669632f9" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../reference/generated/numpy.loadtxt#numpy.loadtxt&quot;&gt;&lt;code&gt;numpy.loadtxt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;../reference/generated/numpy.loadtxt#numpy.loadtxt&quot;&gt; &lt;code&gt;numpy.loadtxt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4f8ac8fa6bbe32be50850bd12eaa662fa8d4dcb" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt;&lt;code&gt;numpy.save&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.load#numpy.load&quot;&gt;&lt;code&gt;numpy.load&lt;/code&gt;&lt;/a&gt;. Set &lt;code&gt;allow_pickle=False&lt;/code&gt;, unless the array dtype includes Python objects, in which case pickling is required.</source>
          <target state="translated">使用&lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt; &lt;code&gt;numpy.save&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../reference/generated/numpy.load#numpy.load&quot;&gt; &lt;code&gt;numpy.load&lt;/code&gt; &lt;/a&gt;。设置 &lt;code&gt;allow_pickle=False&lt;/code&gt; ，除非数组dtype包含Python对象，在这种情况下需要酸洗。</target>
        </trans-unit>
        <trans-unit id="02b4c353908e359bf6eb7d8604286846ac3d1bd8" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt;&lt;code&gt;numpy.save&lt;/code&gt;&lt;/a&gt;, or to store multiple arrays &lt;a href=&quot;../reference/generated/numpy.savez#numpy.savez&quot;&gt;&lt;code&gt;numpy.savez&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/generated/numpy.savez_compressed#numpy.savez_compressed&quot;&gt;&lt;code&gt;numpy.savez_compressed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt; &lt;code&gt;numpy.save&lt;/code&gt; &lt;/a&gt;，或存储多个数组&lt;a href=&quot;../reference/generated/numpy.savez#numpy.savez&quot;&gt; &lt;code&gt;numpy.savez&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../reference/generated/numpy.savez_compressed#numpy.savez_compressed&quot;&gt; &lt;code&gt;numpy.savez_compressed&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6250a8c021e0b5f57d8def96501e9671eb570fb3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;SeedSequence.spawn&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt; &lt;code&gt;SeedSequence.spawn&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="315e845b90149a11b36b35f1bf0bf7c4eadadf53" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6cd23ceb7d31c81e1ae51bfa02cfeb8d16da6862" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/hawkowl/towncrier&quot;&gt;towncrier&lt;/a&gt; to build the release note and commit the changes. This will remove all the fragments from &lt;code&gt;doc/release/upcoming_changes&lt;/code&gt; and add &lt;code&gt;doc/release/&amp;lt;version&amp;gt;-note.rst&lt;/code&gt;. Note that currently towncrier must be installed from its master branch as the last release (19.2.0) is outdated.</source>
          <target state="translated">使用&lt;a href=&quot;https://github.com/hawkowl/towncrier&quot;&gt;towncrier&lt;/a&gt;构建发行说明并提交更改。这将从 &lt;code&gt;doc/release/upcoming_changes&lt;/code&gt; 中删除所有片段，并添加 &lt;code&gt;doc/release/&amp;lt;version&amp;gt;-note.rst&lt;/code&gt; 。请注意，由于最后一个版本（19.2.0）已过时，当前必须从其master分支安装Towncrier。</target>
        </trans-unit>
        <trans-unit id="239d871fd4cf571322892166220cc9bdd722de95" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;numpy.printoptions#numpy.printoptions&quot;&gt;&lt;code&gt;printoptions&lt;/code&gt;&lt;/a&gt; as a context manager to set the values temporarily.</source>
          <target state="translated">使用&lt;a href=&quot;numpy.printoptions#numpy.printoptions&quot;&gt; &lt;code&gt;printoptions&lt;/code&gt; &lt;/a&gt;作为上下文管理器可以临时设置值。</target>
        </trans-unit>
        <trans-unit id="f81e110951d1c31f755b7eda89bda400f45185fe" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt;&lt;code&gt;assert_allclose&lt;/code&gt;&lt;/a&gt; or one of the nulp (number of floating point values) functions for these cases instead:</source>
          <target state="translated">在这些情况下，请使用&lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt; &lt;code&gt;assert_allclose&lt;/code&gt; &lt;/a&gt;或nulp（浮点值的数量）函数之一：</target>
        </trans-unit>
        <trans-unit id="c2c3133adfff844d3d7390f3b12e049c01cfbf85" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;*italics*&lt;/code&gt;, &lt;code&gt;**bold**&lt;/code&gt; and &lt;code&gt;``monospace``&lt;/code&gt; if needed in any explanations (but not for variable names and doctest code or multi-line code). Variable, module, function, and class names should be written between single back-ticks (&lt;code&gt;`numpy`&lt;/code&gt;).</source>
          <target state="translated">如有任何说明，请使用 &lt;code&gt;*italics*&lt;/code&gt; ， &lt;code&gt;**bold**&lt;/code&gt; 和 &lt;code&gt;``monospace``&lt;/code&gt; （但不用于变量名称和doctest代码或多行代码）。变量，模块，函数和类的名称应写在单 &lt;code&gt;`numpy`&lt;/code&gt; （'numpy`）之间。</target>
        </trans-unit>
        <trans-unit id="f96b961e5f74e075163f17783fa068cb28fd7dac" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Py_BEGIN_ALLOW_THREADS .. Py_END_ALLOW_THREADS&lt;/code&gt; block around the call to Fortran/C function.</source>
          <target state="translated">在对Fortran / C函数的调用周围使用 &lt;code&gt;Py_BEGIN_ALLOW_THREADS .. Py_END_ALLOW_THREADS&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="279c8e9cb261d8451ee87221b2c4c3c0acff77e2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;atleast1d&lt;/code&gt; explicitly if this behavior is deliberate.</source>
          <target state="translated">如果此行为是故意的， &lt;code&gt;atleast1d&lt;/code&gt; 显式使用atleast1d。</target>
        </trans-unit>
        <trans-unit id="1f3c1a16eb9a2500b8452a8a5360fe793c9d0e80" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;integers(0, np.iinfo(np.int_).max,&lt;/code&gt;&lt;code&gt;endpoint=False)&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;integers(0, np.iinfo(np.int_).max,&lt;/code&gt; &lt;code&gt;endpoint=False)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9990e788a91877bc1314e512b42f5fa96b72afa8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;intent(callback)&lt;/code&gt; in situations where a Fortran/C code assumes that a user implements a function with given prototype and links it to an executable. Don&amp;rsquo;t use &lt;code&gt;intent(callback)&lt;/code&gt; if function appears in the argument list of a Fortran routine.</source>
          <target state="translated">在Fortran / C代码假设用户使用给定的原型实现功能并将其链接到可执行文件的情况下，请使用 &lt;code&gt;intent(callback)&lt;/code&gt; 。如果函数出现在Fortran例程的参数列表中，请不要使用 &lt;code&gt;intent(callback)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8f354d8129891e4371211f7e2b02c3e86182e68" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;np.rec.fromrecords&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;np.rec.fromrecords&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b891c3328df6ed66c13f42757acead75f849207" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;transpose(a, argsort(axes))&lt;/code&gt; to invert the transposition of tensors when using the &lt;code&gt;axes&lt;/code&gt; keyword argument.</source>
          <target state="translated">使用 &lt;code&gt;axes&lt;/code&gt; 关键字参数时 &lt;code&gt;transpose(a, argsort(axes))&lt;/code&gt; 使用transpose（a，argsort（axes））反转张量的转置。</target>
        </trans-unit>
        <trans-unit id="464b9132a697ad83a17ca6141a5f052f243225bc" translate="yes" xml:space="preserve">
          <source>Use AVX512 intrinsic to implement &lt;code&gt;np.exp&lt;/code&gt; when input is &lt;code&gt;np.float64&lt;/code&gt;</source>
          <target state="translated">使用AVX512内在实现 &lt;code&gt;np.exp&lt;/code&gt; 当输入为 &lt;code&gt;np.float64&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54252b83acef1c2d4145831c1849100189007324" translate="yes" xml:space="preserve">
          <source>Use C99 (that is, the standard defined by ISO/IEC 9899:1999).</source>
          <target state="translated">使用C99(即ISO/IEC 9899:1999定义的标准)。</target>
        </trans-unit>
        <trans-unit id="711cfaf9a47519e9f223142a373928a92e01f581" translate="yes" xml:space="preserve">
          <source>Use C99 complex functions when available</source>
          <target state="translated">有条件时使用C99复合函数</target>
        </trans-unit>
        <trans-unit id="86275be9977f886d82e016929a242789bd409942" translate="yes" xml:space="preserve">
          <source>Use a &lt;a href=&quot;basics.rec&quot;&gt;structured array&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;basics.rec&quot;&gt;结构化数组&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="98bf81203a370aca52162542f86441968d5a857b" translate="yes" xml:space="preserve">
          <source>Use a code checker:</source>
          <target state="translated">使用代码检查器。</target>
        </trans-unit>
        <trans-unit id="e79cdecbdf930a5fc02d963ddb3cee0b341e1836" translate="yes" xml:space="preserve">
          <source>Use an index array to construct a new array from a set of choices.</source>
          <target state="translated">使用一个索引数组从一组选择中构造一个新的数组。</target>
        </trans-unit>
        <trans-unit id="b449716c39e8e2ad1701598e0a781904fd930dad" translate="yes" xml:space="preserve">
          <source>Use boolean indexing to select all rows adding up to an even number. At the same time columns 0 and 2 should be selected with an advanced integer index. Using the &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; function this can be done with:</source>
          <target state="translated">使用布尔索引来选择所有相加为偶数的行。同时，应使用高级整数索引选择第0列和第2列。使用&lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt;函数可以通过以下方式完成：</target>
        </trans-unit>
        <trans-unit id="8b644965af35188379a837d813ccb011d1f78f91" translate="yes" xml:space="preserve">
          <source>Use f90 compiler specified by the command line args</source>
          <target state="translated">使用命令行args指定的f90编译器。</target>
        </trans-unit>
        <trans-unit id="8f82174ebfd083d8637822ce00a0c4c91588113b" translate="yes" xml:space="preserve">
          <source>Use frompyfunc to add broadcasting to the Python function &lt;code&gt;oct&lt;/code&gt;:</source>
          <target state="translated">使用frompyfunc将广播添加到Python函数 &lt;code&gt;oct&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1985c7d495449d5cb406d70622b9f8f51933acf4" translate="yes" xml:space="preserve">
          <source>Use integers()</source>
          <target state="translated">使用integers()</target>
        </trans-unit>
        <trans-unit id="dc8e632ae2c46f77a697535ec370bf0774d7d3a3" translate="yes" xml:space="preserve">
          <source>Use it inside source generating function to ensure that setup distribution instance has been initialized.</source>
          <target state="translated">在源生成函数中使用它来确保设置分发实例已经初始化。</target>
        </trans-unit>
        <trans-unit id="19f951b7351050e3c262a94c6097609e26d32919" translate="yes" xml:space="preserve">
          <source>Use memory mapping. See &lt;a href=&quot;../reference/generated/numpy.lib.format.open_memmap#numpy.lib.format.open_memmap&quot;&gt;&lt;code&gt;numpy.lib.format.open_memmap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用内存映射。请参阅&lt;a href=&quot;../reference/generated/numpy.lib.format.open_memmap#numpy.lib.format.open_memmap&quot;&gt; &lt;code&gt;numpy.lib.format.open_memmap&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ee4c011b47d55b7bfff5ce2a411098048a912df" translate="yes" xml:space="preserve">
          <source>Use numpy data types instead of strings (&lt;code&gt;np.uint8&lt;/code&gt; instead of &lt;code&gt;&quot;uint8&quot;&lt;/code&gt;).</source>
          <target state="translated">使用numpy数据类型而不是字符串（ &lt;code&gt;np.uint8&lt;/code&gt; 而不是 &lt;code&gt;&quot;uint8&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2623e95742f95738b81e96ff23790e2857ea53b8" translate="yes" xml:space="preserve">
          <source>Use of Special Libraries</source>
          <target state="translated">特别图书馆的使用</target>
        </trans-unit>
        <trans-unit id="71894ec37f432f11f7de9a5b9b593a7cdf8ac0f3" translate="yes" xml:space="preserve">
          <source>Use of internal buffers</source>
          <target state="translated">内部缓冲器的使用</target>
        </trans-unit>
        <trans-unit id="19e9181ca40527ae40c5f3d764f8d2f436e1e1db" translate="yes" xml:space="preserve">
          <source>Use of special library functions (e.g., random)</source>
          <target state="translated">使用特殊的库函数(如随机)</target>
        </trans-unit>
        <trans-unit id="375ee90511f8800725237c9c32010dd6bfc434d9" translate="yes" xml:space="preserve">
          <source>Use one of the two predefined instances &lt;code&gt;index_exp&lt;/code&gt; or &lt;a href=&quot;#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt; rather than directly using &lt;code&gt;IndexExpression&lt;/code&gt;.</source>
          <target state="translated">使用两个预定义实例 &lt;code&gt;index_exp&lt;/code&gt; 或&lt;a href=&quot;#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; 之一,&lt;/a&gt;而不是直接使用 &lt;code&gt;IndexExpression&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4baff69e242f9bdf1683765ea1f2508b120d6009" translate="yes" xml:space="preserve">
          <source>Use statements:</source>
          <target state="translated">使用报表。</target>
        </trans-unit>
        <trans-unit id="f399bcf7c74a9a9e383f645bfc3f3a24ebea505e" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--f2cmap&lt;/code&gt; command-line option to pass the file name to F2PY. By default, F2PY assumes file name is &lt;code&gt;.f2py_f2cmap&lt;/code&gt; in the current working directory.</source>
          <target state="translated">使用 &lt;code&gt;--f2cmap&lt;/code&gt; 命令行选项将文件名传递给F2PY。默认情况下，F2PY假定当前工作目录中的文件名为 &lt;code&gt;.f2py_f2cmap&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="563d6ccf41351782f370e56a915df0b3956e26f4" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;buf&lt;/code&gt; keyword.</source>
          <target state="translated">使用 &lt;code&gt;buf&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="6e0dab0efbd30d7f80d43f09e327292cfe0afdb8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;endpoint&lt;/code&gt; kwarg to adjust the inclusion or exclution of the &lt;code&gt;high&lt;/code&gt; interval endpoint</source>
          <target state="translated">使用 &lt;code&gt;endpoint&lt;/code&gt; kwarg调整 &lt;code&gt;high&lt;/code&gt; 间隔端点的包含或排除</target>
        </trans-unit>
        <trans-unit id="1a4a01452f45e746c6cb102d0e1fd6cdbe229239" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;order&lt;/code&gt; keyword to specify a field to use when sorting a structured array:</source>
          <target state="translated">使用 &lt;code&gt;order&lt;/code&gt; 关键字指定对结构化数组进行排序时要使用的字段：</target>
        </trans-unit>
        <trans-unit id="bd1412430a20e73aea7c2107ffe5351cd94a8833" translate="yes" xml:space="preserve">
          <source>Use the following import conventions:</source>
          <target state="translated">使用以下导入惯例:</target>
        </trans-unit>
        <trans-unit id="25cbadfbabe4aec8c49a2fe4ad5d41f89ab2957d" translate="yes" xml:space="preserve">
          <source>Use the indices of the non-zero elements as an index array to extract these elements:</source>
          <target state="translated">使用非零元素的指数作为索引数组来提取这些元素。</target>
        </trans-unit>
        <trans-unit id="053906d6c11e234d0523bc070994cf48c59e8878" translate="yes" xml:space="preserve">
          <source>Use the library &lt;code&gt;&amp;lt;libname&amp;gt;&lt;/code&gt; when linking.</source>
          <target state="translated">链接时使用库 &lt;code&gt;&amp;lt;libname&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52a989636199f4d3c95f768797df44dd326f52d3" translate="yes" xml:space="preserve">
          <source>Use the same sections as outlined above (all except &lt;code&gt;Returns&lt;/code&gt; are applicable). The constructor (&lt;code&gt;__init__&lt;/code&gt;) should also be documented here, the &lt;strong&gt;Parameters&lt;/strong&gt; section of the docstring details the constructors parameters.</source>
          <target state="translated">请使用与上述相同的部分（适用所有除&amp;ldquo; &lt;code&gt;Returns&lt;/code&gt; 外的内容）。构造函数（ &lt;code&gt;__init__&lt;/code&gt; ）也应记录在这里，文档字符串的&lt;strong&gt;Parameters&lt;/strong&gt;部分详细说明了构造函数的参数。</target>
        </trans-unit>
        <trans-unit id="bcbe93ff8f6462c82dd7a279518d76404badb4f2" translate="yes" xml:space="preserve">
          <source>Use the same sections as outlined for functions where applicable:</source>
          <target state="translated">在适用的情况下,使用与概述的功能相同的章节。</target>
        </trans-unit>
        <trans-unit id="91b5ae96e69a49c5a6862c6b40c4da95f9ee09c6" translate="yes" xml:space="preserve">
          <source>Use these sparingly, as they do not look very good in text terminals and are not often necessary. One situation in which a warning can be useful is for marking a known bug that is not yet fixed.</source>
          <target state="translated">尽量少用,因为它们在文本终端中看起来不是很好,而且通常也没有必要。有一种情况下,警告是有用的,那就是标记一个已知的、尚未修复的错误。</target>
        </trans-unit>
        <trans-unit id="fce2d931323b452a238b3e2d786e8a8211d7c7e3" translate="yes" xml:space="preserve">
          <source>Used as an alias of &lt;a href=&quot;#c.NPY_MERGESORT&quot;&gt;&lt;code&gt;NPY_MERGESORT&lt;/code&gt;&lt;/a&gt; and vica versa.</source>
          <target state="translated">用作&lt;a href=&quot;#c.NPY_MERGESORT&quot;&gt; &lt;code&gt;NPY_MERGESORT&lt;/code&gt; &lt;/a&gt;的别名，反之亦然。</target>
        </trans-unit>
        <trans-unit id="fd6f1513bb6f3e4a98050539792c7f3cbaf760a6" translate="yes" xml:space="preserve">
          <source>Used as-is.</source>
          <target state="translated">按原样使用。</target>
        </trans-unit>
        <trans-unit id="07b7a5c37f889b88311324311f27b8d80e97eae1" translate="yes" xml:space="preserve">
          <source>Used exclusively for the purpose static type checking, &lt;a href=&quot;#numpy.typing.NBitBase&quot;&gt;&lt;code&gt;NBitBase&lt;/code&gt;&lt;/a&gt; represents the base of a hierachieral set of subclasses. Each subsequent subclass is herein used for representing a lower level of precision, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;64Bit &amp;gt; 32Bit &amp;gt; 16Bit&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.typing.NBitBase&quot;&gt; &lt;code&gt;NBitBase&lt;/code&gt; &lt;/a&gt;专门用于目的静态类型检查，它表示层次结构子类集的基础。每个随后的子类在此用于表示较低的精度级别，&lt;em&gt;例如&lt;/em&gt; &lt;code&gt;64Bit &amp;gt; 32Bit &amp;gt; 16Bit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86d25879dd6e8e65f51cfd2c9e310da0aa3fb93c" translate="yes" xml:space="preserve">
          <source>Used for an array, &lt;em&gt;op&lt;/em&gt;, that contains any Python objects. It decrements the reference count of every object in the array according to the data-type of &lt;em&gt;op&lt;/em&gt;. Normal return value is 0. A -1 is returned if an error occurs.</source>
          <target state="translated">用于包含任何Python对象的数组&lt;em&gt;op&lt;/em&gt;。它根据&lt;em&gt;op&lt;/em&gt;的数据类型递减数组中每个对象的引用计数。正常返回值为0。如果发生错误，则返回-1。</target>
        </trans-unit>
        <trans-unit id="12676328e0f8258da10db691bf737e9cd286a726" translate="yes" xml:space="preserve">
          <source>Used for an array, &lt;em&gt;op&lt;/em&gt;, that contains any Python objects. It increments the reference count of every object in the array according to the data-type of &lt;em&gt;op&lt;/em&gt;. A -1 is returned if an error occurs, otherwise 0 is returned.</source>
          <target state="translated">用于包含任何Python对象的数组&lt;em&gt;op&lt;/em&gt;。它根据&lt;em&gt;op&lt;/em&gt;的数据类型增加数组中每个对象的引用计数。如果发生错误，则返回-1，否则返回0。</target>
        </trans-unit>
        <trans-unit id="2a13b41ea5661dcbc4d05b7183bc9d474dd67bb8" translate="yes" xml:space="preserve">
          <source>Used if &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy&lt;/code&gt;&lt;/a&gt; is called on an array.</source>
          <target state="translated">如果使用&lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy&lt;/code&gt; &lt;/a&gt;被称为阵列上。</target>
        </trans-unit>
        <trans-unit id="b1500692edf9e6d67bd590cb2e6428fecab9820c" translate="yes" xml:space="preserve">
          <source>Used if &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy&lt;/code&gt;&lt;/a&gt; is called on an array. Returns a copy of the array.</source>
          <target state="translated">如果使用&lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy&lt;/code&gt; &lt;/a&gt;被称为阵列上。返回数组的副本。</target>
        </trans-unit>
        <trans-unit id="054ce70cbf81d2356ba6ae20aa8fb864ef13bf9e" translate="yes" xml:space="preserve">
          <source>Used if &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy&lt;/code&gt;&lt;/a&gt; is called on an array.</source>
          <target state="translated">如果使用&lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.deepcopy&quot;&gt; &lt;code&gt;copy.deepcopy&lt;/code&gt; &lt;/a&gt;被称为阵列上。</target>
        </trans-unit>
        <trans-unit id="df1278433c263cdbbd69170e679d3f52bb78e816" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;constant&amp;rsquo;. The values to set the padded values for each axis.</source>
          <target state="translated">在&amp;ldquo;常量&amp;rdquo;中使用。用于设置每个轴的填充值的值。</target>
        </trans-unit>
        <trans-unit id="465b8fcd19cd5e2ed77adff74f2ff5a3fc18db79" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;linear_ramp&amp;rsquo;. The values used for the ending value of the linear_ramp and that will form the edge of the padded array.</source>
          <target state="translated">在'linear_ramp'中使用。用于linear_ramp结束值的值，它将形成填充数组的边缘。</target>
        </trans-unit>
        <trans-unit id="d71d6f65b16e9b35cb9fcf9b7569838936b2caa2" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;maximum&amp;rsquo;, &amp;lsquo;mean&amp;rsquo;, &amp;lsquo;median&amp;rsquo;, and &amp;lsquo;minimum&amp;rsquo;. Number of values at edge of each axis used to calculate the statistic value.</source>
          <target state="translated">用于&amp;ldquo;最大&amp;rdquo;，&amp;ldquo;平均&amp;rdquo;，&amp;ldquo;中位数&amp;rdquo;和&amp;ldquo;最小&amp;rdquo;。每个轴边缘上用于计算统计值的值的数量。</target>
        </trans-unit>
        <trans-unit id="4325f42e7e418215aac0a73c897c39904b4d0a1e" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;reflect&amp;rsquo;, and &amp;lsquo;symmetric&amp;rsquo;. The &amp;lsquo;even&amp;rsquo; style is the default with an unaltered reflection around the edge value. For the &amp;lsquo;odd&amp;rsquo; style, the extended part of the array is created by subtracting the reflected values from two times the edge value.</source>
          <target state="translated">用于&amp;ldquo;反射&amp;rdquo;和&amp;ldquo;对称&amp;rdquo;。默认设置为&amp;ldquo;偶数&amp;rdquo;样式，边缘值周围的反射不变。对于&amp;ldquo;奇数&amp;rdquo;样式，通过从两倍的边缘值中减去反射值来创建数组的扩展部分。</target>
        </trans-unit>
        <trans-unit id="6a848d84f0829fb89fe0a4c3ff31da438ec74574" translate="yes" xml:space="preserve">
          <source>Used in universal function code to only release the Python GIL if loop-&amp;gt;obj is not true (&lt;em&gt;i.e.&lt;/em&gt; this is not an OBJECT array loop). Requires use of &lt;a href=&quot;array#c.NPY_BEGIN_THREADS_DEF&quot;&gt;&lt;code&gt;NPY_BEGIN_THREADS_DEF&lt;/code&gt;&lt;/a&gt; in variable declaration area.</source>
          <target state="translated">在通用功能代码中使用，仅当loop-&amp;gt; obj不为真（&lt;em&gt;即，&lt;/em&gt;这不是OBJECT数组循环）时才释放Python GIL 。需要在变量声明区域中使用&lt;a href=&quot;array#c.NPY_BEGIN_THREADS_DEF&quot;&gt; &lt;code&gt;NPY_BEGIN_THREADS_DEF&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1b7f1793a4a4b44dd1933f922f757d629d3be5a3" translate="yes" xml:space="preserve">
          <source>Used in universal function code to only release the Python GIL if loop-&amp;gt;obj is not true (&lt;em&gt;i.e.&lt;/em&gt; this is not an OBJECT array loop). Requires use of &lt;a href=&quot;c-api.array#c.NPY_BEGIN_THREADS_DEF&quot;&gt;&lt;code&gt;NPY_BEGIN_THREADS_DEF&lt;/code&gt;&lt;/a&gt; in variable declaration area.</source>
          <target state="translated">在通用功能代码中使用，仅当loop-&amp;gt; obj不为真（&lt;em&gt;即，&lt;/em&gt;这不是OBJECT数组循环）时才释放Python GIL 。需要在变量声明区域中使用&lt;a href=&quot;c-api.array#c.NPY_BEGIN_THREADS_DEF&quot;&gt; &lt;code&gt;NPY_BEGIN_THREADS_DEF&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="10031fc1a49c2cbba6bbb424956b8667cda6fefa" translate="yes" xml:space="preserve">
          <source>Used in universal function code to re-acquire the Python GIL if it was released (because loop-&amp;gt;obj was not true).</source>
          <target state="translated">在通用功能代码中用于重新获取Python GIL（如果它已发行）（因为loop-&amp;gt; obj不是true）。</target>
        </trans-unit>
        <trans-unit id="5e817653770e3b6919ac9612c69ec10ee688db47" translate="yes" xml:space="preserve">
          <source>Used synonymously in the NumPy docs with &lt;a href=&quot;#term-ndarray&quot;&gt;ndarray&lt;/a&gt;.</source>
          <target state="translated">在NumPy文档中与&lt;a href=&quot;#term-ndarray&quot;&gt;ndarray&lt;/a&gt;同义使用。</target>
        </trans-unit>
        <trans-unit id="c23b41a6c14497a2fa2fb894918e5ebdff35b118" translate="yes" xml:space="preserve">
          <source>Used to construct the convolution operator.</source>
          <target state="translated">用于构造卷积算子。</target>
        </trans-unit>
        <trans-unit id="c5c64c33615821368bc9743122d8a6c96ff848fe" translate="yes" xml:space="preserve">
          <source>Used to fill the array with data.</source>
          <target state="translated">用于在数组中填充数据。</target>
        </trans-unit>
        <trans-unit id="9ead00318903d57eb423777b76455ee4a052f86f" translate="yes" xml:space="preserve">
          <source>Used to select only certain elements from a sequence:</source>
          <target state="translated">用于从一个序列中只选择某些元素。</target>
        </trans-unit>
        <trans-unit id="4b06029f962bdaa60d205631cac84f36f3e29d6f" translate="yes" xml:space="preserve">
          <source>Useful functions in &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; 中的有用函数</target>
        </trans-unit>
        <trans-unit id="7dc863346a17f843606dc78b7fd5eaa70c18759a" translate="yes" xml:space="preserve">
          <source>Useful math constants</source>
          <target state="translated">有用的数学常数</target>
        </trans-unit>
        <trans-unit id="d7e7cae700d3c37685c439282d2378cb79df959c" translate="yes" xml:space="preserve">
          <source>Useful to regain the GIL in situations where it was released using the BEGIN form of this macro.</source>
          <target state="translated">在使用此宏的BEGIN形式释放GIL的情况下,恢复GIL是有用的。</target>
        </trans-unit>
        <trans-unit id="8cef70f655bb7cdb9d1c581e3560341cb090e5c3" translate="yes" xml:space="preserve">
          <source>Useful to release the GIL only if &lt;em&gt;dtype&lt;/em&gt; does not contain arbitrary Python objects which may need the Python interpreter during execution of the loop.</source>
          <target state="translated">仅当&lt;em&gt;dtype&lt;/em&gt;不包含任意Python对象（在循环执行期间可能需要Python解释器）时才有用释放GIL 。</target>
        </trans-unit>
        <trans-unit id="d580b2c9b4825f08cb2691c40cd94404df444f3e" translate="yes" xml:space="preserve">
          <source>Useful to release the GIL only if &lt;em&gt;dtype&lt;/em&gt; does not contain arbitrary Python objects which may need the Python interpreter during execution of the loop. Equivalent to</source>
          <target state="translated">仅当&lt;em&gt;dtype&lt;/em&gt;不包含任意Python对象（在循环执行期间可能需要Python解释器）时才释放GIL有用。相当于</target>
        </trans-unit>
        <trans-unit id="2978535fda1f10395442e618746112da0bb87d3a" translate="yes" xml:space="preserve">
          <source>Useful to release the GIL only if &lt;em&gt;loop_size&lt;/em&gt; exceeds a minimum threshold, currently set to 500. Should be matched with a &lt;a href=&quot;#c.NPY_END_THREADS&quot;&gt;&lt;code&gt;NPY_END_THREADS&lt;/code&gt;&lt;/a&gt; to regain the GIL.</source>
          <target state="translated">仅当&lt;em&gt;loop_size&lt;/em&gt;超过当前设置为最小阈值的最小阈值时才有用，以释放GIL。应与&lt;a href=&quot;#c.NPY_END_THREADS&quot;&gt; &lt;code&gt;NPY_END_THREADS&lt;/code&gt; &lt;/a&gt;匹配以重新获得GIL。</target>
        </trans-unit>
        <trans-unit id="67dcf8adc685ecdcc2081b1b467df13f891ef2cf" translate="yes" xml:space="preserve">
          <source>User documentation</source>
          <target state="translated">用户文件</target>
        </trans-unit>
        <trans-unit id="377ee38d9430016857a7ac84277e93d26f665af8" translate="yes" xml:space="preserve">
          <source>User-defined BLAS detection order</source>
          <target state="translated">用户自定义BLAS检测顺序</target>
        </trans-unit>
        <trans-unit id="01d8c2fd752b3823aa5ae01359574a0ac7005a6d" translate="yes" xml:space="preserve">
          <source>User-defined LAPACK detection order</source>
          <target state="translated">用户自定义LAPACK检测顺序</target>
        </trans-unit>
        <trans-unit id="feb130415c58c07804dd84fa00fab56690d584a4" translate="yes" xml:space="preserve">
          <source>User-defined data-types</source>
          <target state="translated">用户定义的数据类型</target>
        </trans-unit>
        <trans-unit id="77352cf9f5e0b55e17c69c67b2dd7ed545a9424a" translate="yes" xml:space="preserve">
          <source>User-defined types now need to implement &lt;code&gt;__str__&lt;/code&gt; and &lt;code&gt;__repr__&lt;/code&gt;</source>
          <target state="translated">用户定义的类型现在需要实现 &lt;code&gt;__str__&lt;/code&gt; 和 &lt;code&gt;__repr__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2314f2b86670571851375cde1d05391e4ea574a3" translate="yes" xml:space="preserve">
          <source>Users can create arbitrarily complex &lt;a href=&quot;#term-dtype&quot;&gt;dtypes&lt;/a&gt; that can include other arrays and dtypes. These composite dtypes are called &lt;a href=&quot;user/basics.rec&quot;&gt;structured data types.&lt;/a&gt;</source>
          <target state="translated">用户可以创建任意复杂的&lt;a href=&quot;#term-dtype&quot;&gt;dtype&lt;/a&gt;，其中可以包括其他数组和dtype。这些复合dtype称为&lt;a href=&quot;user/basics.rec&quot;&gt;结构化数据类型。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd331bef50cb48757824818608d12be462d6034d" translate="yes" xml:space="preserve">
          <source>Users looking to manipulate tabular data, such as stored in csv files, may find other pydata projects more suitable, such as xarray, pandas, or DataArray. These provide a high-level interface for tabular data analysis and are better optimized for that use. For instance, the C-struct-like memory layout of structured arrays in numpy can lead to poor cache behavior in comparison.</source>
          <target state="translated">希望操作表格数据(如存储在csv文件中的数据)的用户可能会发现其他pydata项目更适合,如xarray、pandas或DataArray。这些项目为表格式数据分析提供了一个高级接口,并针对这一用途进行了更好的优化。例如,numpy中结构化数组类似C结构的内存布局,相比之下会导致缓存行为不佳。</target>
        </trans-unit>
        <trans-unit id="2637443926c71ce03a091c2e95bf9b5610348992" translate="yes" xml:space="preserve">
          <source>Using &amp;lsquo;r&amp;rsquo; or &amp;lsquo;c&amp;rsquo; as a first string argument creates a matrix.</source>
          <target state="translated">将&amp;ldquo; r&amp;rdquo;或&amp;ldquo; c&amp;rdquo;用作第一个字符串参数将创建一个矩阵。</target>
        </trans-unit>
        <trans-unit id="65fcf8542af4dfa98c8e336c7ebb663b2e96f530" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; one can quickly construct index arrays that will index the cross product. &lt;code&gt;a[np.ix_([1,3],[2,5])]&lt;/code&gt; returns the array &lt;code&gt;[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]&lt;/code&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; ,&lt;/a&gt;可以快速构造索引数组，该索引数组将对叉积进行索引。 &lt;code&gt;a[np.ix_([1,3],[2,5])]&lt;/code&gt; 返回数组 &lt;code&gt;[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32ece8fbb6c1ed850bf1c3c8fb0f4d5a7300c2c0" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt; with **kwds, the arrays are saved with the keyword names.</source>
          <target state="translated">将&lt;a href=&quot;#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; &lt;/a&gt;与** kwds一起使用时，将使用关键字名称保存数组。</target>
        </trans-unit>
        <trans-unit id="8c36d4099fe15bc91bbfe91acb74cd64e75d6b3f" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt; with *args, the arrays are saved with default names.</source>
          <target state="translated">将&lt;a href=&quot;#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; &lt;/a&gt;与* args结合使用时，将使用默认名称保存阵列。</target>
        </trans-unit>
        <trans-unit id="a65056bb65a5824d8a28541dbacefafbcbe064d0" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;../reference/generated/numpy.hsplit#numpy.hsplit&quot;&gt;&lt;code&gt;hsplit&lt;/code&gt;&lt;/a&gt;, you can split an array along its horizontal axis, either by specifying the number of equally shaped arrays to return, or by specifying the columns after which the division should occur:</source>
          <target state="translated">使用&lt;a href=&quot;../reference/generated/numpy.hsplit#numpy.hsplit&quot;&gt; &lt;code&gt;hsplit&lt;/code&gt; &lt;/a&gt;，您可以沿数组的水平轴拆分数组，方法是指定要返回的均等形状数组的数量，或者指定应在其后进行除法的列：</target>
        </trans-unit>
        <trans-unit id="abcbf246bed1356ef5a4f7a84e0efa6276b04144" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;arr.reshape()&lt;/code&gt; will give a new shape to an array without changing the data. Just remember that when you use the reshape method, the array you want to produce needs to have the same number of elements as the original array. If you start with an array with 12 elements, you&amp;rsquo;ll need to make sure that your new array also has a total of 12 elements.</source>
          <target state="translated">使用 &lt;code&gt;arr.reshape()&lt;/code&gt; 将在不更改数据的情况下为数组赋予新的形状。只需记住，当您使用reshape方法时，要生成的数组需要具有与原始数组相同数量的元素。如果从包含12个元素的数组开始，则需要确保新数组也总共包含12个元素。</target>
        </trans-unit>
        <trans-unit id="c05ea485672c370249efc13cf02206fa0079194e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;intent(inout)&lt;/code&gt; is generally not recommended, use &lt;code&gt;intent(in,out)&lt;/code&gt; instead. See also &lt;code&gt;intent(inplace)&lt;/code&gt; attribute.</source>
          <target state="translated">通常不建议使用 &lt;code&gt;intent(inout)&lt;/code&gt; ，而应使用 &lt;code&gt;intent(in,out)&lt;/code&gt; 。另请参见 &lt;code&gt;intent(inplace)&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="d44e140015f4a842157d0c38e650d4d90f0d7d32" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;intent(inplace)&lt;/code&gt; is generally not recommended either. For example, when slices have been taken from an &lt;code&gt;intent(inplace)&lt;/code&gt; argument then after in-place changes, slices data pointers may point to unallocated memory area.</source>
          <target state="translated">通常也不建议使用 &lt;code&gt;intent(inplace)&lt;/code&gt; 。例如，当已经从 &lt;code&gt;intent(inplace)&lt;/code&gt; 参数中获取了切片之后，在就地更改之后，切片数据指针可能指向未分配的存储区域。</target>
        </trans-unit>
        <trans-unit id="9b0a1a12d91b1a55351df033aec60b12c39daa72" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;np.newaxis&lt;/code&gt; will increase the dimensions of your array by one dimension when used once. This means that a &lt;strong&gt;1D&lt;/strong&gt; array will become a &lt;strong&gt;2D&lt;/strong&gt; array, a &lt;strong&gt;2D&lt;/strong&gt; array will become a &lt;strong&gt;3D&lt;/strong&gt; array, and so on.</source>
          <target state="translated">使用 &lt;code&gt;np.newaxis&lt;/code&gt; 一次使用将使数组的尺寸增加一维。这意味着&lt;strong&gt;1D&lt;/strong&gt;阵列将变成&lt;strong&gt;2D&lt;/strong&gt;阵列，&lt;strong&gt;2D&lt;/strong&gt;阵列将变成&lt;strong&gt;3D&lt;/strong&gt;阵列，依此类推。</target>
        </trans-unit>
        <trans-unit id="191982a04357e09366b8b88accf4a58472233372" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;runtests.py&lt;/code&gt; is the recommended approach to running tests. There are also a number of alternatives to it, for example in-place build or installing to a virtualenv. See the FAQ below for details.</source>
          <target state="translated">建议使用 &lt;code&gt;runtests.py&lt;/code&gt; 来运行测试。它也有许多替代方案，例如就地构建或安装到virtualenv。有关详情，请参见下面的常见问题解答。</target>
        </trans-unit>
        <trans-unit id="f797cc0ae3c70b42806d8484c2173341138aa334" translate="yes" xml:space="preserve">
          <source>Using Eclipse/PyDev with Anaconda/conda Python (or environments)</source>
          <target state="translated">使用Eclipse/PyDev与Anaconda/conda Python (或环境)</target>
        </trans-unit>
        <trans-unit id="0f4523c954e2a9e31bfb34aa3f197069ed09884a" translate="yes" xml:space="preserve">
          <source>Using F2PY</source>
          <target state="translated">使用F2PY</target>
        </trans-unit>
        <trans-unit id="b5ca717d067542a1c5fc904dd82ea349b1543085" translate="yes" xml:space="preserve">
          <source>Using F2PY bindings in Python</source>
          <target state="translated">在Python中使用F2PY绑定</target>
        </trans-unit>
        <trans-unit id="805e17bb02b4c971b82b3da2b45fde14cdb9678e" translate="yes" xml:space="preserve">
          <source>Using NumPy C-API</source>
          <target state="translated">使用NumPy C-API</target>
        </trans-unit>
        <trans-unit id="9c7bc452a9834b5876e355900cc35464401d0f74" translate="yes" xml:space="preserve">
          <source>Using PyCharm with Anaconda/conda Python</source>
          <target state="translated">在Anaconda/conda Python中使用PyCharm。</target>
        </trans-unit>
        <trans-unit id="b9863374b5764d5e46c1682602eaea50268a1efa" translate="yes" xml:space="preserve">
          <source>Using Python as glue</source>
          <target state="translated">使用Python作为胶水</target>
        </trans-unit>
        <trans-unit id="6f2e5d63438a571f3123ef33ae03e1d5f2864e48" translate="yes" xml:space="preserve">
          <source>Using Python from &lt;code&gt;conda&lt;/code&gt; (Anaconda)</source>
          <target state="translated">从 &lt;code&gt;conda&lt;/code&gt; （Anaconda）使用Python</target>
        </trans-unit>
        <trans-unit id="e43089c0ec4ca3358f03ef23a9043bc3004dbaed" translate="yes" xml:space="preserve">
          <source>Using VSCode with Anaconda/conda Python (or environments)</source>
          <target state="translated">在Anaconda/conda Python (或环境)中使用VSCode。</target>
        </trans-unit>
        <trans-unit id="e7d91cc202089a17bf1dca7f6ffac1974935ce7f" translate="yes" xml:space="preserve">
          <source>Using a flexible &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用灵活的&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4ecb91f09183edc4f23a5cc314556ac8c1af3c8" translate="yes" xml:space="preserve">
          <source>Using a flexible &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">使用灵活的 &lt;code&gt;dtype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cfac66afdbdc20a411f9f9f200f87cdcbe870cdd" translate="yes" xml:space="preserve">
          <source>Using a view to convert an array to a recarray:</source>
          <target state="translated">使用视图将一个数组转换为一个recarray。</target>
        </trans-unit>
        <trans-unit id="a4fb72e0c5f0602466b0b452237f4e23496663cc" translate="yes" xml:space="preserve">
          <source>Using an External Loop</source>
          <target state="translated">使用外部环路</target>
        </trans-unit>
        <trans-unit id="f210f428b873c49c7b2b57aa15cfa3164fde53af" translate="yes" xml:space="preserve">
          <source>Using an instance of &lt;a href=&quot;#numpy.errstate&quot;&gt;&lt;code&gt;errstate&lt;/code&gt;&lt;/a&gt; as a context manager allows statements in that context to execute with a known error handling behavior. Upon entering the context the error handling is set with &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;, and upon exiting it is reset to what it was before.</source>
          <target state="translated">将&lt;a href=&quot;#numpy.errstate&quot;&gt; &lt;code&gt;errstate&lt;/code&gt; &lt;/a&gt;实例用作上下文管理器可以使该上下文中的语句以已知的错误处理行为执行。输入上下文后，将使用&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt;设置错误处理，退出后将其重置为之前的状态。</target>
        </trans-unit>
        <trans-unit id="d1fe8e1d4770589cbebb7564eb13c83317ecba70" translate="yes" xml:space="preserve">
          <source>Using an ndpointer class in the argtypes method can make it significantly safer to call a C function using ctypes and the data- area of an ndarray. You may still want to wrap the function in an additional Python wrapper to make it user-friendly (hiding some obvious arguments and making some arguments output arguments). In this process, the &lt;code&gt;requires&lt;/code&gt; function in NumPy may be useful to return the right kind of array from a given input.</source>
          <target state="translated">在argtypes方法中使用ndpointer类可以使使用ctypes和ndarray的数据区域调用C函数的安全性大大提高。您可能仍然希望将函数包装在其他Python包装器中，以使其易于使用（隐藏一些明显的参数并使某些参数输出参数）。在此过程中， &lt;code&gt;requires&lt;/code&gt; 在与NumPy功能可以是从给定输入返回正确的阵列的有用的。</target>
        </trans-unit>
        <trans-unit id="7af0c7a348040b3b4ff1744a0608d17163c9138e" translate="yes" xml:space="preserve">
          <source>Using array-protocol type strings:</source>
          <target state="translated">使用数组协议类型的字符串。</target>
        </trans-unit>
        <trans-unit id="fd7054fa064ad2611d4b7d00df8240d7735e3c37" translate="yes" xml:space="preserve">
          <source>Using array-scalar type:</source>
          <target state="translated">使用数组标量类型。</target>
        </trans-unit>
        <trans-unit id="03a2b430abf28e746816ea1cff1b193db00a94c9" translate="yes" xml:space="preserve">
          <source>Using comma-separated field formats. The shape is (2,3):</source>
          <target state="translated">使用逗号分隔的字段格式。形状为(2,3)。</target>
        </trans-unit>
        <trans-unit id="e282c417933d97d3a53a56d481d1f405a74c7c0d" translate="yes" xml:space="preserve">
          <source>Using complex sequences:</source>
          <target state="translated">使用复杂的序列。</target>
        </trans-unit>
        <trans-unit id="eb191c9fcdc8ee9e52364b3acea1bba66afa1818" translate="yes" xml:space="preserve">
          <source>Using ctypes is a powerful way to connect Python with arbitrary C-code. Its advantages for extending Python include</source>
          <target state="translated">使用ctypes是连接Python和任意C代码的强大方法。它扩展Python的优势包括</target>
        </trans-unit>
        <trans-unit id="26e522c98bd807e94f2ab9fc3a1975ce203f287e" translate="yes" xml:space="preserve">
          <source>Using dictionaries. Two fields named &amp;lsquo;gender&amp;rsquo; and &amp;lsquo;age&amp;rsquo;:</source>
          <target state="translated">使用字典。两个字段分别称为&amp;ldquo;性别&amp;rdquo;和&amp;ldquo;年龄&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="af330b02f13d207e5fac3c22b8c9bdbaab36afee" translate="yes" xml:space="preserve">
          <source>Using dtype = None</source>
          <target state="translated">使用dtype=None</target>
        </trans-unit>
        <trans-unit id="78961faefc955a768bc7940893e23db94f94772b" translate="yes" xml:space="preserve">
          <source>Using masked arrays to see COVID-19 data</source>
          <target state="translated">使用屏蔽数组查看COVID-19数据</target>
        </trans-unit>
        <trans-unit id="00ac7fffb347ca02e4efcd6c4f0a66db988cde12" translate="yes" xml:space="preserve">
          <source>Using missing and filling values</source>
          <target state="translated">使用缺失值和填充值</target>
        </trans-unit>
        <trans-unit id="8d2131672fafcfdf449f29b29350743e40c17d69" translate="yes" xml:space="preserve">
          <source>Using months for the unit:</source>
          <target state="translated">以月为单位。</target>
        </trans-unit>
        <trans-unit id="68007c19f643deebacff69bbb71fb357fa3f341a" translate="yes" xml:space="preserve">
          <source>Using non-symbol-suffixed 64-bit BLAS/LAPACK in a program that also uses 32-bit BLAS/LAPACK can cause crashes under certain conditions (e.g. with embedded Python interpreters on Linux).</source>
          <target state="translated">在同样使用32位BLAS/LAPACK的程序中使用非符号后缀的64位BLAS/LAPACK,在某些情况下会导致崩溃(例如在Linux上使用嵌入式Python解释器)。</target>
        </trans-unit>
        <trans-unit id="2f696379652fe6905a66fc5fd2b9273fa2471296" translate="yes" xml:space="preserve">
          <source>Using numpy.i</source>
          <target state="translated">使用numpy.i</target>
        </trans-unit>
        <trans-unit id="e8111da9fdc8286f7fa1decedd3c62fdfaa40d28" translate="yes" xml:space="preserve">
          <source>Using numpy.ma</source>
          <target state="translated">使用numpy.ma</target>
        </trans-unit>
        <trans-unit id="fca1ba2673c50c8d4a43a28f5b4401d362ff3c79" translate="yes" xml:space="preserve">
          <source>Using numpy.random.binomial may change the RNG state vs. numpy &amp;lt; 1.9</source>
          <target state="translated">与numpy &amp;lt;1.9相比，使用numpy.random.binomial可能会更改RNG状态</target>
        </trans-unit>
        <trans-unit id="03252764a2ca129ee8f53a1ebcd3c94ffd3382b7" translate="yes" xml:space="preserve">
          <source>Using poly1d objects:</source>
          <target state="translated">使用poly1d对象。</target>
        </trans-unit>
        <trans-unit id="79eb3bbcb08c7d6704be86d77b0727b917270b3d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;axis&lt;/code&gt; argument to compute matrix norms:</source>
          <target state="translated">使用 &lt;code&gt;axis&lt;/code&gt; 参数计算矩阵范数：</target>
        </trans-unit>
        <trans-unit id="9e684f49459c0d5aba4c5f2579aeb17add74610d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;axis&lt;/code&gt; argument to compute vector norms:</source>
          <target state="translated">使用 &lt;code&gt;axis&lt;/code&gt; 参数计算向量范数：</target>
        </trans-unit>
        <trans-unit id="0049dd8bb80b8109d30cf294edeebc9226866484" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;copy&lt;/code&gt; method will make a complete copy of the array and its data (a &lt;em&gt;deep copy&lt;/em&gt;). To use this on your array, you could run:</source>
          <target state="translated">使用 &lt;code&gt;copy&lt;/code&gt; 方法将对数组及其数据进行完整复制（&lt;em&gt;深层复制&lt;/em&gt;）。要在您的阵列上使用它，可以运行：</target>
        </trans-unit>
        <trans-unit id="b9ba36c2f053a06ac3abc3a930f4a1d05aada052" translate="yes" xml:space="preserve">
          <source>Using the Convenience Classes</source>
          <target state="translated">使用方便类</target>
        </trans-unit>
        <trans-unit id="1bd2966f639ab87086919a9a710a3ff850eadf79" translate="yes" xml:space="preserve">
          <source>Using the Einstein summation convention, many common multi-dimensional, linear algebraic array operations can be represented in a simple fashion. In &lt;em&gt;implicit&lt;/em&gt; mode &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; computes these values.</source>
          <target state="translated">使用爱因斯坦求和约定，可以以简单的方式表示许多常见的多维线性代数数组运算。在&lt;em&gt;隐式&lt;/em&gt;模式下，&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;计算这些值。</target>
        </trans-unit>
        <trans-unit id="44ec7387e738c4a2877c9993514a14374905ca3a" translate="yes" xml:space="preserve">
          <source>Using the aliases of builtin types like &lt;code&gt;np.int&lt;/code&gt; is deprecated</source>
          <target state="translated">使用内置类型的别名一样 &lt;code&gt;np.int&lt;/code&gt; 已被弃用</target>
        </trans-unit>
        <trans-unit id="75da2a462c666654f41a122b8cf7201ccca6f453" translate="yes" xml:space="preserve">
          <source>Using the casting rules</source>
          <target state="translated">使用铸造规则</target>
        </trans-unit>
        <trans-unit id="eed50259686b11043b2277964d70797ed9e23c6d" translate="yes" xml:space="preserve">
          <source>Using the new casting implementation</source>
          <target state="translated">使用新的铸造实施</target>
        </trans-unit>
        <trans-unit id="a7a6cb5aa0103dc18935f9ad693972e0008b2a2f" translate="yes" xml:space="preserve">
          <source>Using the object looks like this:</source>
          <target state="translated">使用对象的样子是这样的。</target>
        </trans-unit>
        <trans-unit id="0e2a18ad6df592872579dd4bbee44818b7034db3" translate="yes" xml:space="preserve">
          <source>Using these #defines you can use the C-API in multiple files for a single extension module. In each file you must define &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to some name that will hold the C-API (&lt;em&gt;e.g.&lt;/em&gt; myextension_ARRAY_API). This must be done &lt;strong&gt;before&lt;/strong&gt; including the numpy/arrayobject.h file. In the module initialization routine you call &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt;. In addition, in the files that do not have the module initialization sub_routine define &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; prior to including numpy/arrayobject.h.</source>
          <target state="translated">使用这些#defines，您可以在单个扩展模块的多个文件中使用C-API。在每个文件中，必须将&lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt;定义为将包含C-API的名称（&lt;em&gt;例如&lt;/em&gt; myextension_ARRAY_API）。必须&lt;strong&gt;在&lt;/strong&gt;包含numpy / arrayobject.h文件&lt;strong&gt;之前&lt;/strong&gt;完成此操作。在模块初始化例程中，调用&lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; &lt;/a&gt;。此外，在没有初始化模块sub_routine的文件定义&lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; &lt;/a&gt;之前，包括numpy的/ arrayobject.h。</target>
        </trans-unit>
        <trans-unit id="315900bdae1d95768693f5caf49a459c0e9247e8" translate="yes" xml:space="preserve">
          <source>Using this result to index &lt;code&gt;a&lt;/code&gt; is equivalent to using the mask directly:</source>
          <target state="translated">使用此结果索引 &lt;code&gt;a&lt;/code&gt; 等同于直接使用掩码：</target>
        </trans-unit>
        <trans-unit id="2b3c55a8f302db1fd2b8e30d4741e13199d60cd0" translate="yes" xml:space="preserve">
          <source>Using this scheme, an upper bound on the probability of a collision can be estimated if one knows the number of streams that you derive. &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; hashes its inputs, both the seed and the spawn-tree-path, down to a 128-bit pool by default. The probability that there is a collision in that pool, pessimistically-estimated (&lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;), will be about</source>
          <target state="translated">使用这种方案，如果人们知道您导出的流的数量，就可以估算出发生冲突的可能性的上限。&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;其输入（包括种子和生成树路径）散列到一个128位的池中。悲观地估计（&lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;）的那个池中发生碰撞的概率大约为</target>
        </trans-unit>
        <trans-unit id="f1e207983fdf75c13618b12af3dac2cc9b09a86a" translate="yes" xml:space="preserve">
          <source>Using this scheme, an upper bound on the probability of a collision can be estimated if one knows the number of streams that you derive. &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; hashes its inputs, both the seed and the spawn-tree-path, down to a 128-bit pool by default. The probability that there is a collision in that pool, pessimistically-estimated (&lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;), will be about</source>
          <target state="translated">使用这种方案，如果知道您派生的流的数量，就可以估算出发生冲突的可能性的上限。&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;其输入（包括种子和生成树路径）散列到128位池中。悲观估计（&lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;），该池中发生冲突的概率约为</target>
        </trans-unit>
        <trans-unit id="81f2b8dfbfc71c96c12b186f5770d7cbd6cb20f2" translate="yes" xml:space="preserve">
          <source>Using tuples. &lt;code&gt;int&lt;/code&gt; is a fixed type, 3 the field&amp;rsquo;s shape. &lt;code&gt;void&lt;/code&gt; is a flexible type, here of size 10:</source>
          <target state="translated">使用元组。 &lt;code&gt;int&lt;/code&gt; 是固定类型的3字段的形状。 &lt;code&gt;void&lt;/code&gt; 是一种灵活的类型，大小为10：</target>
        </trans-unit>
        <trans-unit id="824f10f86cbfa339b11bf5f57f7a0ce042086b4a" translate="yes" xml:space="preserve">
          <source>Using via &lt;code&gt;numpy.distutils&lt;/code&gt;</source>
          <target state="translated">通过 &lt;code&gt;numpy.distutils&lt;/code&gt; 使用</target>
        </trans-unit>
        <trans-unit id="6043061ff0da53be43d1b2e098be1b0520525dba" translate="yes" xml:space="preserve">
          <source>Using via numpy.distutils</source>
          <target state="translated">通过numpy.distutils使用</target>
        </trans-unit>
        <trans-unit id="73888fb9a3aa49066395d1b7748b2f3a75b9907a" translate="yes" xml:space="preserve">
          <source>Using virtualenvs</source>
          <target state="translated">使用 virtualenvs</target>
        </trans-unit>
        <trans-unit id="ef8b4345a7cc12338d15d1fb67d9e4a4feb23426" translate="yes" xml:space="preserve">
          <source>Usually denoted</source>
          <target state="translated">通常表示为</target>
        </trans-unit>
        <trans-unit id="9efea8253bd046afd804470a677e434b3a6392ca" translate="yes" xml:space="preserve">
          <source>Usually there is no need to worry about how the arrays are stored in memory and whether the wrapped functions, being either Fortran or C functions, assume one or another storage order. F2PY automatically ensures that wrapped functions get arguments with proper storage order; the corresponding algorithm is designed to make copies of arrays only when absolutely necessary. However, when dealing with very large multidimensional input arrays with sizes close to the size of the physical memory in your computer, then a care must be taken to use always proper-contiguous and proper type arguments.</source>
          <target state="translated">通常不需要担心数组如何存储在内存中,也不需要担心被封装的函数,无论是Fortran函数还是C函数,是否承担了这样或那样的存储顺序。F2PY会自动保证被封装的函数得到的参数具有正确的存储顺序;相应的算法设计为只有在绝对必要的时候才会对数组进行拷贝。但是,当处理非常大的多维输入数组时,其大小接近计算机物理内存的大小,那么必须注意始终使用适当的连续和适当的类型参数。</target>
        </trans-unit>
        <trans-unit id="409d8adcbc7ff9f8ede9fa136b31fc43f33b4ab8" translate="yes" xml:space="preserve">
          <source>Usually, defining a dtype is sufficient to define how the sequence of strings must be converted. However, some additional control may sometimes be required. For example, we may want to make sure that a date in a format &lt;code&gt;YYYY/MM/DD&lt;/code&gt; is converted to a &lt;a href=&quot;https://docs.python.org/dev/library/datetime.html#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object, or that a string like &lt;code&gt;xx%&lt;/code&gt; is properly converted to a float between 0 and 1. In such cases, we should define conversion functions with the &lt;code&gt;converters&lt;/code&gt; arguments.</source>
          <target state="translated">通常，定义dtype足以定义必须如何转换字符串序列。但是，有时可能需要一些其他控制。例如，我们可能要确保将格式 &lt;code&gt;YYYY/MM/DD&lt;/code&gt; 的&lt;a href=&quot;https://docs.python.org/dev/library/datetime.html#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt;转换为datetime对象，或者将诸如 &lt;code&gt;xx%&lt;/code&gt; 之类的字符串正确转换为介于0和1之间的浮点数。应该使用 &lt;code&gt;converters&lt;/code&gt; 参数定义转换函数。</target>
        </trans-unit>
        <trans-unit id="04880c31a806536e09375a28b6393c4ae89b3000" translate="yes" xml:space="preserve">
          <source>Usually, defining a dtype is sufficient to define how the sequence of strings must be converted. However, some additional control may sometimes be required. For example, we may want to make sure that a date in a format &lt;code&gt;YYYY/MM/DD&lt;/code&gt; is converted to a &lt;code&gt;datetime&lt;/code&gt; object, or that a string like &lt;code&gt;xx%&lt;/code&gt; is properly converted to a float between 0 and 1. In such cases, we should define conversion functions with the &lt;code&gt;converters&lt;/code&gt; arguments.</source>
          <target state="translated">通常，定义dtype足以定义必须如何转换字符串序列。但是，有时可能需要一些其他控制。例如，我们可能要确保将格式 &lt;code&gt;YYYY/MM/DD&lt;/code&gt; 的 &lt;code&gt;datetime&lt;/code&gt; 转换为datetime对象，或者将诸如 &lt;code&gt;xx%&lt;/code&gt; 之类的字符串正确转换为介于0和1之间的浮点数。应该使用 &lt;code&gt;converters&lt;/code&gt; 参数定义转换函数。</target>
        </trans-unit>
        <trans-unit id="a5abc30aa6f2b926c1472fe22071db5adb16a0bc" translate="yes" xml:space="preserve">
          <source>Usually, however, adding the &lt;code&gt;tests/&lt;/code&gt; directory to the python path isn&amp;rsquo;t desirable. Instead it would better to invoke the test straight from the module &lt;code&gt;xxx&lt;/code&gt;. To this end, simply place the following lines at the end of your package&amp;rsquo;s &lt;code&gt;__init__.py&lt;/code&gt; file:</source>
          <target state="translated">但是，通常不希望将 &lt;code&gt;tests/&lt;/code&gt; 目录添加到python路径。相反，最好直接从模块 &lt;code&gt;xxx&lt;/code&gt; 调用测试。为此，只需将以 &lt;code&gt;__init__.py&lt;/code&gt; 放在包的__init__.py文件的末尾：</target>
        </trans-unit>
        <trans-unit id="89189507b2a074e98b2e877227343a6e1f27b3ab" translate="yes" xml:space="preserve">
          <source>Utility</source>
          <target state="translated">Utility</target>
        </trans-unit>
        <trans-unit id="6be23322b56766a1db9b8621387497e594f16d2d" translate="yes" xml:space="preserve">
          <source>Utility classes and functions for the polynomial modules.</source>
          <target state="translated">多项式模块的实用类和函数。</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="d00ce61cfc8e3df435adebc36c2fa866be4f94a4" translate="yes" xml:space="preserve">
          <source>Valid dtype for all arrays</source>
          <target state="translated">所有数组的有效dtype</target>
        </trans-unit>
        <trans-unit id="1221b238d98a98303bde26ccb737f70710cfeaec" translate="yes" xml:space="preserve">
          <source>Valid dtype for array.</source>
          <target state="translated">数组的有效dtype。</target>
        </trans-unit>
        <trans-unit id="7c5b11cbfd943ab04293f9f062d297257b4ba0e8" translate="yes" xml:space="preserve">
          <source>Validating names</source>
          <target state="translated">验证名称</target>
        </trans-unit>
        <trans-unit id="3522db33c6e586ed6f52f3af3bea08c2509cdaed" translate="yes" xml:space="preserve">
          <source>Value indicating that a masked array has no invalid entry. &lt;a href=&quot;#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is used internally to speed up computations when the mask is not needed.</source>
          <target state="translated">指示掩码数组没有无效条目的值。当不需要遮罩时，内部使用&lt;a href=&quot;#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;来加快计算速度。</target>
        </trans-unit>
        <trans-unit id="a1c7830f6acd0062d2809fbc11f2bfb2e8aedd16" translate="yes" xml:space="preserve">
          <source>Value indicating that a masked array has no invalid entry. &lt;a href=&quot;#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is used internally to speed up computations when the mask is not needed. It is represented internally as &lt;code&gt;np.False_&lt;/code&gt;.</source>
          <target state="translated">指示被屏蔽的数组没有无效条目的值。当不需要遮罩时，内部使用&lt;a href=&quot;#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;来加快计算速度。它在内部表示为 &lt;code&gt;np.False_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b9ec234c1eee91fedfeaba35509216217fe21cd" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;operands&lt;/code&gt; at current iteration. Normally, this is a tuple of array scalars, but if the flag &lt;code&gt;external_loop&lt;/code&gt; is used, it is a tuple of one dimensional arrays.</source>
          <target state="translated">当前迭代中 &lt;code&gt;operands&lt;/code&gt; 值。通常，这是数组标量的元组，但是如果使用标志 &lt;code&gt;external_loop&lt;/code&gt; ，则它是一维数组的元组。</target>
        </trans-unit>
        <trans-unit id="d866e0938fcfdf12b88042317593d4295facb33c" translate="yes" xml:space="preserve">
          <source>Value to be placed in field.</source>
          <target state="translated">要放在字段中的值。</target>
        </trans-unit>
        <trans-unit id="4ba37300f6a7d1d653bfd085d1c3e62828c53205" translate="yes" xml:space="preserve">
          <source>Value to be used to fill NaN values. If no value is passed then NaN values will be replaced with 0.0.</source>
          <target state="translated">用来填充NaN值的值。如果没有传递值,那么NaN值将被替换为0.0。</target>
        </trans-unit>
        <trans-unit id="73822c64a61d90da64aca29978cabf65524aa150" translate="yes" xml:space="preserve">
          <source>Value to be used to fill negative infinity values. If no value is passed then negative infinity values will be replaced with a very small (or negative) number.</source>
          <target state="translated">用来填充负无穷值的值。如果没有传递任何值,那么负的无限值将被一个非常小的(或负的)数字代替。</target>
        </trans-unit>
        <trans-unit id="f4796b06e4cb3d07bcdfe89591ec37b878b0609f" translate="yes" xml:space="preserve">
          <source>Value to be used to fill positive infinity values. If no value is passed then positive infinity values will be replaced with a very large number.</source>
          <target state="translated">用来填充正无穷值的值。如果没有传递值,那么正无穷值将被一个非常大的数字代替。</target>
        </trans-unit>
        <trans-unit id="f7cccdf775f458dbd65351fa14dd9eb110134681" translate="yes" xml:space="preserve">
          <source>Value to be written on the diagonal, its type must be compatible with that of the array a.</source>
          <target state="translated">要写在对角线上的值,其类型必须与数组a的类型一致。</target>
        </trans-unit>
        <trans-unit id="715dcdd8f6ff522d4658e491027e9aae31a8b5e6" translate="yes" xml:space="preserve">
          <source>Value to format.</source>
          <target state="translated">要格式化的值。</target>
        </trans-unit>
        <trans-unit id="3d3e32ccc4b0ab4e1f0dc806d286fb59b6c443d6" translate="yes" xml:space="preserve">
          <source>Value to return for &lt;code&gt;x &amp;gt; xp[-1]&lt;/code&gt;, default is &lt;code&gt;fp[-1]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x &amp;gt; xp[-1]&lt;/code&gt; 返回值，默认值为 &lt;code&gt;fp[-1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26d4865cbe90216e1386cb06fe27a2a8a2fdea6f" translate="yes" xml:space="preserve">
          <source>Value to return for &lt;code&gt;x &amp;lt; xp[0]&lt;/code&gt;, default is &lt;code&gt;fp[0]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x &amp;lt; xp[0]&lt;/code&gt; 返回值，默认值为 &lt;code&gt;fp[0]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7a5e0e3824dade99c632ba9171e408c2ecc5e00" translate="yes" xml:space="preserve">
          <source>Value used for fixing invalid data. Default is None, in which case the &lt;code&gt;a.fill_value&lt;/code&gt; is used.</source>
          <target state="translated">用于修复无效数据的值。默认值为无，在这种情况下，将使用 &lt;code&gt;a.fill_value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69ddc9b73f581b3343b0affbf7e4377d672439b1" translate="yes" xml:space="preserve">
          <source>Value used internally for the masked values. If &lt;code&gt;fill_value&lt;/code&gt; is not None, it supersedes &lt;code&gt;endwith&lt;/code&gt;.</source>
          <target state="translated">内部用于掩码值的值。如果 &lt;code&gt;fill_value&lt;/code&gt; 不为None，它将取代 &lt;code&gt;endwith&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="328663db0b3aba67f0d82903937cd9193c3e207c" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values when necessary. If None, a default based on the data-type is used.</source>
          <target state="translated">用于在必要时填充掩码值的值。如果无,则使用基于数据类型的默认值。</target>
        </trans-unit>
        <trans-unit id="ac07a9705ce80720af8585478b1d81e8b7b8b456" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values.</source>
          <target state="translated">用于填充掩码值的值。</target>
        </trans-unit>
        <trans-unit id="86e71cf73f1d7bc170999262699205370f1f93e4" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. Default is None, in which case &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;MaskedArray.fill_value&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">用于填充掩码值的值。默认值为无，在这种情况下，将使用&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;MaskedArray.fill_value&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d8761f6b2df3e19fd6227b05e79d17f94c040e4" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. Default is None, in which case &lt;code&gt;MaskedArray.fill_value&lt;/code&gt; is used.</source>
          <target state="translated">用于填充掩码值的值。默认值为无，在这种情况下，将使用 &lt;code&gt;MaskedArray.fill_value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19866b65a013a0eb3c733fc479da8433fc02a5f3" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, the output of maximum_fill_value(self._data) is used instead.</source>
          <target state="translated">用于填充掩码值的值。如果为None,则使用maximum_fill_value(self._data)的输出。</target>
        </trans-unit>
        <trans-unit id="5c0a58c6eeb18776376a78bc0a9866ce44b1ad27" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, the output of minimum_fill_value(self._data) is used instead.</source>
          <target state="translated">用于填充掩码值的值。如果为None,则使用最小填充值(self._data)的输出。</target>
        </trans-unit>
        <trans-unit id="07a803442a8c55907703d44ba611d57fdb6545b5" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, use the output of &lt;a href=&quot;numpy.ma.minimum_fill_value#numpy.ma.minimum_fill_value&quot;&gt;&lt;code&gt;minimum_fill_value&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于填充掩码值的值。如果为None，则使用&lt;a href=&quot;numpy.ma.minimum_fill_value#numpy.ma.minimum_fill_value&quot;&gt; &lt;code&gt;minimum_fill_value&lt;/code&gt; &lt;/a&gt;的输出。</target>
        </trans-unit>
        <trans-unit id="752e711d9ae184609f9efa220ffeb98e2623ff23" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, use the output of &lt;code&gt;minimum_fill_value&lt;/code&gt;.</source>
          <target state="translated">用于填充掩码值的值。如果为None，则使用 &lt;code&gt;minimum_fill_value&lt;/code&gt; 的输出。</target>
        </trans-unit>
        <trans-unit id="94b3fde97e6b1196d461cd6d1087f12e6dea54b2" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, use the output of maximum_fill_value().</source>
          <target state="translated">用于填充掩码值的值。如果为None,则使用maximum_fill_value()的输出。</target>
        </trans-unit>
        <trans-unit id="017e62bc34ab2d5b5f6988aa11de1c343e6dfb88" translate="yes" xml:space="preserve">
          <source>Value(s) to write on the diagonal. If &lt;code&gt;val&lt;/code&gt; is scalar, the value is written along the diagonal. If array-like, the flattened &lt;code&gt;val&lt;/code&gt; is written along the diagonal, repeating if necessary to fill all diagonal entries.</source>
          <target state="translated">在对角线上要写入的值。如果 &lt;code&gt;val&lt;/code&gt; 是标量，则该值沿对角线写入。如果是数组式的，则平整的 &lt;code&gt;val&lt;/code&gt; 沿对角线写入，如有必要，重复此操作以填充所有对角线条目。</target>
        </trans-unit>
        <trans-unit id="ca5e1888f7ff9f4679a3377b455596a48d014681" translate="yes" xml:space="preserve">
          <source>ValueError</source>
          <target state="translated">ValueError</target>
        </trans-unit>
        <trans-unit id="cff85a0729a85ef9e54dee30d0bb637ac055b748" translate="yes" xml:space="preserve">
          <source>ValueError: shape mismatch</source>
          <target state="translated">值错误:形状不匹配</target>
        </trans-unit>
        <trans-unit id="eddd55b4550fcb347a1d6bf73a696e1497719104" translate="yes" xml:space="preserve">
          <source>Values are appended to a copy of this array.</source>
          <target state="translated">值被附加到这个数组的副本中。</target>
        </trans-unit>
        <trans-unit id="24421420351a973d79bcca3d2ef0e453017e616f" translate="yes" xml:space="preserve">
          <source>Values are generated within the half-open interval &lt;code&gt;[start, stop)&lt;/code&gt; (in other words, the interval including &lt;code&gt;start&lt;/code&gt; but excluding &lt;code&gt;stop&lt;/code&gt;). For integer arguments the function is equivalent to the Python built-in &lt;code&gt;range&lt;/code&gt; function, but returns an ndarray rather than a list.</source>
          <target state="translated">在半开间隔 &lt;code&gt;[start, stop)&lt;/code&gt; （换句话说，包括 &lt;code&gt;start&lt;/code&gt; 但不包括 &lt;code&gt;stop&lt;/code&gt; 的间隔）内生成值。对于整数参数，该函数等效于Python内置的 &lt;code&gt;range&lt;/code&gt; 函数，但返回ndarray而不是列表。</target>
        </trans-unit>
        <trans-unit id="38b38aff8e14ce007107a5b62d7837a43399e916" translate="yes" xml:space="preserve">
          <source>Values at which the weight function will be computed.</source>
          <target state="translated">计算权重函数的数值。</target>
        </trans-unit>
        <trans-unit id="8afc1edfb8d26a9a4bac7610a9a2ed43bc17c240" translate="yes" xml:space="preserve">
          <source>Values from which to choose. &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;condition&lt;/code&gt; need to be broadcastable to some shape.</source>
          <target state="translated">从中选择的值。 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;condition&lt;/code&gt; 需要广播为某种形状。</target>
        </trans-unit>
        <trans-unit id="55fd9fa348e62e91b8d05086f74314a1ab640581" translate="yes" xml:space="preserve">
          <source>Values in &lt;code&gt;i&lt;/code&gt; of less than 0 are treated as 0 (which yields an empty string).</source>
          <target state="translated">在值 &lt;code&gt;i&lt;/code&gt; 的小于0被视为0（它产生一个空字符串）。</target>
        </trans-unit>
        <trans-unit id="c01309d65a99b72623b37f6cd9a8f8ab7021db81" translate="yes" xml:space="preserve">
          <source>Values of the dictionary are strings or sequence of strings. The corresponding keys can be column indices (integers) or column names (strings). In addition, the special key &lt;code&gt;None&lt;/code&gt; can be used to define a default applicable to all columns.</source>
          <target state="translated">字典的值是字符串或字符串序列。相应的键可以是列索引（整数）或列名称（字符串）。此外，特殊键 &lt;code&gt;None&lt;/code&gt; 可以用来定义适用于所有列的默认值。</target>
        </trans-unit>
        <trans-unit id="c0da0f066601a2a9367e697b89519e6b0c50e33e" translate="yes" xml:space="preserve">
          <source>Values to change the sign of.</source>
          <target state="translated">要改变符号的数值。</target>
        </trans-unit>
        <trans-unit id="4158750ed1844d81234e02100fb4f6a0ce246137" translate="yes" xml:space="preserve">
          <source>Values to find the next representable value of.</source>
          <target state="translated">找到下一个可表示的值。</target>
        </trans-unit>
        <trans-unit id="beb9a9be5bcba10dec2aa7359c7898f16a9d7ca8" translate="yes" xml:space="preserve">
          <source>Values to find the spacing of.</source>
          <target state="translated">找出间距的数值。</target>
        </trans-unit>
        <trans-unit id="3b61fff151ba4cdc5d10abd1dbdd04d94f432686" translate="yes" xml:space="preserve">
          <source>Values to insert into &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">值插入到 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19b54e21994fdcbd2ab01d7104b74c970245cfe1" translate="yes" xml:space="preserve">
          <source>Values to insert into &lt;code&gt;arr&lt;/code&gt;. If the type of &lt;code&gt;values&lt;/code&gt; is different from that of &lt;code&gt;arr&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt; is converted to the type of &lt;code&gt;arr&lt;/code&gt;. &lt;code&gt;values&lt;/code&gt; should be shaped so that &lt;code&gt;arr[...,obj,...] = values&lt;/code&gt; is legal.</source>
          <target state="translated">要插入到 &lt;code&gt;arr&lt;/code&gt; 中的值。如果类型 &lt;code&gt;values&lt;/code&gt; 不同于不同 &lt;code&gt;arr&lt;/code&gt; ， &lt;code&gt;values&lt;/code&gt; 被转换为的类型 &lt;code&gt;arr&lt;/code&gt; 。 &lt;code&gt;values&lt;/code&gt; 形状应使 &lt;code&gt;arr[...,obj,...] = values&lt;/code&gt; 合法。</target>
        </trans-unit>
        <trans-unit id="817bf23706b268004f4bf56ee98317c1ad7d150d" translate="yes" xml:space="preserve">
          <source>Values to place in &lt;code&gt;a&lt;/code&gt; at target indices. If &lt;code&gt;v&lt;/code&gt; is shorter than &lt;code&gt;ind&lt;/code&gt; it will be repeated as necessary.</source>
          <target state="translated">价值观在放置 &lt;code&gt;a&lt;/code&gt; 在目标指数。如果 &lt;code&gt;v&lt;/code&gt; 小于 &lt;code&gt;ind&lt;/code&gt; ，则将在必要时将其重复。</target>
        </trans-unit>
        <trans-unit id="a9be9f0fa346eb48800661efe4c9cdccf0a4d68a" translate="yes" xml:space="preserve">
          <source>Values to place in self._data copy at target indices.</source>
          <target state="translated">要放在目标索引的self._data副本中的值。</target>
        </trans-unit>
        <trans-unit id="81f73f98efd45554f2765f8a372cd020b7023051" translate="yes" xml:space="preserve">
          <source>Values to prepend or append to &amp;ldquo;a&amp;rdquo; along axis prior to performing the difference. Scalar values are expanded to arrays with length 1 in the direction of axis and the shape of the input array in along all other axes. Otherwise the dimension and shape must match &amp;ldquo;a&amp;rdquo; except along axis.</source>
          <target state="translated">在执行差分之前，要沿轴在&amp;ldquo; a&amp;rdquo;之前或之后附加的值。标量值将扩展为在轴方向上长度为1的数组，并在所有其他轴上扩展为输入数组的形状。否则，尺寸和形状必须沿轴匹配&amp;ldquo; a&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3e169e71a4b3659a2db1d8c19b6c033e97b1e36f" translate="yes" xml:space="preserve">
          <source>Values to prepend or append to &lt;code&gt;a&lt;/code&gt; along axis prior to performing the difference. Scalar values are expanded to arrays with length 1 in the direction of axis and the shape of the input array in along all other axes. Otherwise the dimension and shape must match &lt;code&gt;a&lt;/code&gt; except along axis.</source>
          <target state="translated">值，以前置或后置到 &lt;code&gt;a&lt;/code&gt; 沿轴线之前执行的差异。标量值将扩展为在轴方向上长度为1的数组，并在所有其他轴上扩展为输入数组的形状。否则，尺寸和形状必须与沿轴 &lt;code&gt;a&lt;/code&gt; 除外相匹配。</target>
        </trans-unit>
        <trans-unit id="462c5daaa1bebf27712ab1f9e6dff7991b7d4f2b" translate="yes" xml:space="preserve">
          <source>Values to put into &lt;code&gt;a&lt;/code&gt; where &lt;code&gt;mask&lt;/code&gt; is True. If &lt;code&gt;values&lt;/code&gt; is smaller than &lt;code&gt;a&lt;/code&gt; it will be repeated.</source>
          <target state="translated">值投入 &lt;code&gt;a&lt;/code&gt; 地方 &lt;code&gt;mask&lt;/code&gt; 是真。如果 &lt;code&gt;values&lt;/code&gt; 小于 &lt;code&gt;a&lt;/code&gt; ，将重复执行。</target>
        </trans-unit>
        <trans-unit id="25e7a819f368d39546137552cf420f108ade4ace" translate="yes" xml:space="preserve">
          <source>Values to put into &lt;code&gt;a&lt;/code&gt;. Only the first N elements are used, where N is the number of True values in &lt;code&gt;mask&lt;/code&gt;. If &lt;code&gt;vals&lt;/code&gt; is smaller than N, it will be repeated, and if elements of &lt;code&gt;a&lt;/code&gt; are to be masked, this sequence must be non-empty.</source>
          <target state="translated">值投入 &lt;code&gt;a&lt;/code&gt; 。仅使用前N个元素，其中N是 &lt;code&gt;mask&lt;/code&gt; 中的True值的数量。如果 &lt;code&gt;vals&lt;/code&gt; 小于N，它将被重复，并且如果元素 &lt;code&gt;a&lt;/code&gt; 都被掩蔽，该序列必须是非空的。</target>
        </trans-unit>
        <trans-unit id="60bd6b681e5d46e176fd602e7f740408a4b90a97" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix for powers.</source>
          <target state="translated">幂的范德蒙德矩阵。</target>
        </trans-unit>
        <trans-unit id="6401e380553d40526975bfbedfb18608ca5c00ad" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of Chebyshev series.</source>
          <target state="translated">Chebyshev系列的Vandermonde矩阵。</target>
        </trans-unit>
        <trans-unit id="ae6e82d94a52ea695163be06dc24993156d990a5" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of Hermite series.</source>
          <target state="translated">Hermite系列的Vandermonde矩阵。</target>
        </trans-unit>
        <trans-unit id="a2d6130252c264087c83a0456898053f5cce8c9b" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of Legendre series.</source>
          <target state="translated">Vandermonde矩阵或Legendre系列。</target>
        </trans-unit>
        <trans-unit id="5d2bf93649140d94c435a78c84579d541c1303f5" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of given degree.</source>
          <target state="translated">给定度的Vandermonde矩阵。</target>
        </trans-unit>
        <trans-unit id="315c420145ba2a2de3ef508e657b666b667d7db9" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix. If &lt;code&gt;increasing&lt;/code&gt; is False, the first column is &lt;code&gt;x^(N-1)&lt;/code&gt;, the second &lt;code&gt;x^(N-2)&lt;/code&gt; and so forth. If &lt;code&gt;increasing&lt;/code&gt; is True, the columns are &lt;code&gt;x^0, x^1, ..., x^(N-1)&lt;/code&gt;.</source>
          <target state="translated">范德蒙矩阵。如果 &lt;code&gt;increasing&lt;/code&gt; 为False，则第一列为 &lt;code&gt;x^(N-1)&lt;/code&gt; ，第二 &lt;code&gt;x^(N-2)&lt;/code&gt; ，依此类推。如果 &lt;code&gt;increasing&lt;/code&gt; 为True，则列为 &lt;code&gt;x^0, x^1, ..., x^(N-1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2fb0e847303b2656c561914c6c1fadfb2178ba16" translate="yes" xml:space="preserve">
          <source>Variable names are displayed in typewriter font, obtained by using &lt;code&gt;\mathtt{var}&lt;/code&gt;:</source>
          <target state="translated">变量名称以打字机字体显示，该字体通过使用 &lt;code&gt;\mathtt{var}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ef7476851367ab64af3bc4c81c52e5e1e6857c25" translate="yes" xml:space="preserve">
          <source>Variables in Numpy which control and describe alignment</source>
          <target state="translated">Numpy中控制和描述对齐的变量。</target>
        </trans-unit>
        <trans-unit id="2a1f6fba473be39ef3c80a51eed0db143c77f764" translate="yes" xml:space="preserve">
          <source>Variance while not ignoring NaNs</source>
          <target state="translated">不忽略NaNs时的差异</target>
        </trans-unit>
        <trans-unit id="8676fa65ac8cfd04cdda1d2741f1f3486c926b70" translate="yes" xml:space="preserve">
          <source>Various continuous integration (CI) services are triggered after each PR update to build the code, run unit tests, measure code coverage and check coding style of your branch. The CI tests must pass before your PR can be merged. If CI fails, you can find out why by clicking on the &amp;ldquo;failed&amp;rdquo; icon (red cross) and inspecting the build and test log. To avoid overuse and waste of this resource, &lt;a href=&quot;development_environment#recommended-development-setup&quot;&gt;test your work&lt;/a&gt; locally before committing.</source>
          <target state="translated">每次PR更新后都会触发各种持续集成（CI）服务，以构建代码，运行单元测试，测量代码覆盖率并检查分支的编码样式。必须先通过CI测试，然后才能合并您的PR。如果CI失败，则可以通过单击&amp;ldquo;失败&amp;rdquo;图标（红叉）并检查构建和测试日志来找出原因。为避免过度使用和浪费此资源，&lt;a href=&quot;development_environment#recommended-development-setup&quot;&gt;请&lt;/a&gt;在提交之前在本地测试您的工作。</target>
        </trans-unit>
        <trans-unit id="47604fcededf37e9515dbd4dd1f0e8ae5e2d23c4" translate="yes" xml:space="preserve">
          <source>Various fields have standard formats for array data. The following lists the ones with known python libraries to read them and return numpy arrays (there may be others for which it is possible to read and convert to numpy arrays so check the last section as well)</source>
          <target state="translated">各个字段都有数组数据的标准格式,下面列出了已知python库可以读取它们并返回numpy数组的字段。下面列出了已知的python库可以读取它们并返回numpy数组的数组(可能还有其他数组可以读取并转换为numpy数组,所以也请查看最后一节)</target>
        </trans-unit>
        <trans-unit id="407b9055a29b3862ad6596884f933fb2e3b90801" translate="yes" xml:space="preserve">
          <source>Various windows</source>
          <target state="translated">各种窗口</target>
        </trans-unit>
        <trans-unit id="a77d3d622bb695acc100256fe700b0a21c995057" translate="yes" xml:space="preserve">
          <source>Vector Quantization J. Makhoul, S. Roucos, and H. Gish, &amp;ldquo;Vector Quantization in Speech Coding,&amp;rdquo; Proc. IEEE, vol. 73, pp. 1551-1587, Nov. 1985.</source>
          <target state="translated">矢量量化J. Makhoul，S。Roucos和H. Gish，&amp;ldquo;语音编码中的矢量量化&amp;rdquo;，Proc.Natl.Acad.Sci.USA，87，3593-2。IEEE，第一卷 1985年11月，第73页，第1551-1587页。</target>
        </trans-unit>
        <trans-unit id="f5d5df32cb3f2a3be9fd3df5321700c5dfe41670" translate="yes" xml:space="preserve">
          <source>Vector Stacking</source>
          <target state="translated">矢量堆叠</target>
        </trans-unit>
        <trans-unit id="690a0d6330a132cb4527e3e44d7a2347c9a06b3a" translate="yes" xml:space="preserve">
          <source>Vector cross product(s).</source>
          <target state="translated">矢量交叉积。</target>
        </trans-unit>
        <trans-unit id="28cb052426ac62f08e613cbe9ac7789542c3593f" translate="yes" xml:space="preserve">
          <source>Vector cross-product.</source>
          <target state="translated">矢量交叉产品。</target>
        </trans-unit>
        <trans-unit id="0fe94b620577959abe98d342c3396c44b95bc9ac" translate="yes" xml:space="preserve">
          <source>Vector inner and outer products, &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt;&lt;code&gt;numpy.inner&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;numpy.outer#numpy.outer&quot;&gt;&lt;code&gt;numpy.outer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">向量内部和外部乘积&lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt; &lt;code&gt;numpy.inner&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;numpy.outer#numpy.outer&quot;&gt; &lt;code&gt;numpy.outer&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc155524d5d2ad1522cc08f2291c52dc38dcecf1" translate="yes" xml:space="preserve">
          <source>Vector inner products:</source>
          <target state="translated">矢量内制品。</target>
        </trans-unit>
        <trans-unit id="7b8a7176d65340f9da0fa7937d046de8633e6685" translate="yes" xml:space="preserve">
          <source>Vector outer product:</source>
          <target state="translated">矢量外积。</target>
        </trans-unit>
        <trans-unit id="acae4c791d04e4455a560ff6e41306cbb57dcf51" translate="yes" xml:space="preserve">
          <source>Vector(s) with the singular values, within each vector sorted in descending order. The first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions have the same size as those of the input &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">每个向量中具有奇异值的向量，它们按降序排列。前 &lt;code&gt;a.ndim - 2&lt;/code&gt; 维的大小与输入 &lt;code&gt;a&lt;/code&gt; 的大小相同。</target>
        </trans-unit>
        <trans-unit id="2a5acfbe842fd0541792480526462188b04dde53" translate="yes" xml:space="preserve">
          <source>Vector, vector returns the scalar inner product, but neither argument is complex-conjugated:</source>
          <target state="translated">向量,向量返回标量内积,但这两个参数都不是复数共轭的。</target>
        </trans-unit>
        <trans-unit id="d24d62baa6df1c0e53e6c0f85d62c2190886f5dd" translate="yes" xml:space="preserve">
          <source>Vectorization describes the absence of any explicit looping, indexing, etc., in the code - these things are taking place, of course, just &amp;ldquo;behind the scenes&amp;rdquo; in optimized, pre-compiled C code. Vectorized code has many advantages, among which are:</source>
          <target state="translated">向量化描述了代码中没有任何显式的循环，索引等操作-当然，这些事情发生在优化的预编译C代码的&amp;ldquo;幕后&amp;rdquo;。向量化代码具有许多优点，其中包括：</target>
        </trans-unit>
        <trans-unit id="c6ec9d2e3c00c48eca40b4ca66a3c4d474b90630" translate="yes" xml:space="preserve">
          <source>Vectorized function.</source>
          <target state="translated">矢量化函数。</target>
        </trans-unit>
        <trans-unit id="72db9853411ecb8ab44d24a7ecaed3ef15eeb780" translate="yes" xml:space="preserve">
          <source>Verbosity value for benchmark outputs, in the range 1-10. Default is 1.</source>
          <target state="translated">基准输出的Verbosity值,范围为1-10。默认为1。</target>
        </trans-unit>
        <trans-unit id="56a92946aff3755099c7d26b356bbca785b0c03f" translate="yes" xml:space="preserve">
          <source>Verbosity value for test outputs, in the range 1-10. Default is 1.</source>
          <target state="translated">测试输出的Verbosity值,范围为1-10。默认为1。</target>
        </trans-unit>
        <trans-unit id="7bfe5238ce1d36e9bfcb089f4f57728d117a113e" translate="yes" xml:space="preserve">
          <source>Verify the mean and the variance:</source>
          <target state="translated">验证平均值和方差。</target>
        </trans-unit>
        <trans-unit id="01e4cae31c98991a3d53edad9d5a04ca08ed4f3b" translate="yes" xml:space="preserve">
          <source>Version numbering</source>
          <target state="translated">版本编号</target>
        </trans-unit>
        <trans-unit id="51eea7cbb443c92981917f3f8bfdb384f15a6153" translate="yes" xml:space="preserve">
          <source>Version of this function that preserves the shape of ar1.</source>
          <target state="translated">这个函数的版本,保留了ar1的形状。</target>
        </trans-unit>
        <trans-unit id="224aeb6086ba7022d83156756ac873c6ff737642" translate="yes" xml:space="preserve">
          <source>Versus a regular NumPy array of type &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;unicode&lt;/code&gt;, this class adds the following functionality:</source>
          <target state="translated">与类型为&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;unicode&lt;/code&gt; 的常规NumPy数组相比，此类增加了以下功能：</target>
        </trans-unit>
        <trans-unit id="a21f850c092874207e85425f1992b2d1d4a0daef" translate="yes" xml:space="preserve">
          <source>Versus a regular NumPy array of type &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;unicode&lt;/code&gt;, this class adds the following functionality:</source>
          <target state="translated">与类型为 &lt;code&gt;str&lt;/code&gt; 或 &lt;code&gt;unicode&lt;/code&gt; 的常规NumPy数组相比，此类增加了以下功能：</target>
        </trans-unit>
        <trans-unit id="8dff4805e231cae5fc82f2b66c5c75ea9b76e2a9" translate="yes" xml:space="preserve">
          <source>Very little support for C++ code and its different library-calling conventions. You will probably need a C wrapper around C++ code to use with ctypes (or just use Boost.Python instead).</source>
          <target state="translated">对 C++代码及其不同的库调用约定的支持非常少。你可能需要一个围绕C++代码的C包装器来与ctypes一起使用 (或者直接使用Boost.Python)。</target>
        </trans-unit>
        <trans-unit id="c127fa63d626c5390ae1bdab993f5e47e3ded50c" translate="yes" xml:space="preserve">
          <source>Very often, it is desirable to iterate over several arrays at the same time. The universal functions are an example of this kind of behavior. If all you want to do is iterate over arrays with the same shape, then simply creating several iterator objects is the standard procedure. For example, the following code iterates over two arrays assumed to be the same shape and size (actually obj1 just has to have at least as many total elements as does obj2):</source>
          <target state="translated">很多时候,人们希望同时对多个数组进行迭代。通用函数就是这种行为的一个例子。如果你想做的只是迭代具有相同形状的数组,那么简单地创建几个迭代器对象就是标准的程序。例如,下面的代码在两个假定形状和大小相同的数组上进行迭代(实际上obj1的总元素数至少要和obj2一样多)。</target>
        </trans-unit>
        <trans-unit id="ba00ebd75f3175e23b4f09615b45ef3560ac5818" translate="yes" xml:space="preserve">
          <source>View based and advanced indexing is mixed. In this case the view based indexing defines a collection of subarrays that are combined by the advanced indexing. For example, &lt;code&gt;arr[[1, 2, 3], :]&lt;/code&gt; is created by vertically stacking the subarrays &lt;code&gt;arr[1, :]&lt;/code&gt;, &lt;code&gt;arr[2,:]&lt;/code&gt;, and &lt;code&gt;arr[3, :]&lt;/code&gt;.</source>
          <target state="translated">基于视图的索引和高级索引混合在一起。在这种情况下，基于视图的索引定义了由高级索引组合的子数组的集合。例如， &lt;code&gt;arr[[1, 2, 3], :]&lt;/code&gt; 是通过垂直堆叠的子阵列创建 &lt;code&gt;arr[1, :]&lt;/code&gt; ， &lt;code&gt;arr[2,:]&lt;/code&gt; ，和 &lt;code&gt;arr[3, :]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9c88862eb9a71fc0e8a80b619b8e3f7d2d2d42e" translate="yes" xml:space="preserve">
          <source>View casting</source>
          <target state="translated">查看铸造</target>
        </trans-unit>
        <trans-unit id="56880c7be840a348e75d7f5abcf907eb8bf9c7d5" translate="yes" xml:space="preserve">
          <source>View casting - casting an existing ndarray as a given subclass</source>
          <target state="translated">视图转换--将现有的ndarray转换为给定的子类。</target>
        </trans-unit>
        <trans-unit id="b2ca30abe686b95f053f55957fa5266ab07dca0a" translate="yes" xml:space="preserve">
          <source>View inputs as arrays with at least three dimensions.</source>
          <target state="translated">将输入视为至少有三个维度的数组。</target>
        </trans-unit>
        <trans-unit id="45fb889525ea027b940786067638d779d675de17" translate="yes" xml:space="preserve">
          <source>View inputs as arrays with at least two dimensions.</source>
          <target state="translated">将输入视为至少有两个维度的数组。</target>
        </trans-unit>
        <trans-unit id="6e4fbf98b4a2f11308bf6ec449635485ea8cdb89" translate="yes" xml:space="preserve">
          <source>View of &lt;code&gt;a&lt;/code&gt; with the number of dimensions increased by one.</source>
          <target state="translated">观 &lt;code&gt;a&lt;/code&gt; ，尺寸的数量增加了一个。</target>
        </trans-unit>
        <trans-unit id="1435a6e88e9cfdd34dddec8e0ea3d664de355e82" translate="yes" xml:space="preserve">
          <source>View of &lt;code&gt;a&lt;/code&gt; with the number of dimensions increased.</source>
          <target state="translated">视图 &lt;code&gt;a&lt;/code&gt; 随维数增加。</target>
        </trans-unit>
        <trans-unit id="cbf2e6fd5608dfcde8e1d428501030442d53386c" translate="yes" xml:space="preserve">
          <source>View of &lt;code&gt;a&lt;/code&gt;, with axes suitably permuted.</source>
          <target state="translated">查看的 &lt;code&gt;a&lt;/code&gt; ，与轴适当地置换。</target>
        </trans-unit>
        <trans-unit id="64d2e5a4061b7a0c16fd366760c98d172091bc5e" translate="yes" xml:space="preserve">
          <source>View or Shallow Copy</source>
          <target state="translated">查看或浅度复制</target>
        </trans-unit>
        <trans-unit id="690413363bd8aafde5497bc7e1d13a4d8e5f2372" translate="yes" xml:space="preserve">
          <source>View the array as a record array:</source>
          <target state="translated">以记录数组的形式查看数组。</target>
        </trans-unit>
        <trans-unit id="aea7dff1c7bb5f575c10f755c8f2b7c22ca00476" translate="yes" xml:space="preserve">
          <source>Viewing Structured Arrays Containing Objects</source>
          <target state="translated">查看包含对象的结构化数组</target>
        </trans-unit>
        <trans-unit id="81d42abd80c44b454ac926e28ee7856a84a169a3" translate="yes" xml:space="preserve">
          <source>Viewing array data using a different type and dtype:</source>
          <target state="translated">使用不同类型和dtype查看数组数据。</target>
        </trans-unit>
        <trans-unit id="e4585378f90f92f4cace47440b8fa755fd8680a6" translate="yes" xml:space="preserve">
          <source>Views are an important NumPy concept! NumPy functions, as well as operations like indexing and slicing, will return views whenever possible. This saves memory and is faster (no copy of the data has to be made). However it&amp;rsquo;s important to be aware of this - modifying data in a view also modifies the original array!</source>
          <target state="translated">视图是NumPy的重要概念！NumPy函数以及诸如索引和切片之类的操作将在可能的情况下返回视图。这样可以节省内存并且速度更快（无需复制数据）。但是，请务必注意这一点-修改视图中的数据也会修改原始数组！</target>
        </trans-unit>
        <trans-unit id="30c8756fc6d8ab2295389484bbe9c6879a472d3c" translate="yes" xml:space="preserve">
          <source>Views of arrays in Fortran order</source>
          <target state="translated">Fortran中数组的视图顺序</target>
        </trans-unit>
        <trans-unit id="59879f373c87da4a2c95c0412230c3555cfc240e" translate="yes" xml:space="preserve">
          <source>Views returned from einsum are now writeable whenever the input array is writeable. For example, &lt;code&gt;np.einsum('ijk...-&amp;gt;kji...', a)&lt;/code&gt; will now have the same effect as &lt;a href=&quot;numpy.swapaxes#numpy.swapaxes&quot;&gt;&lt;code&gt;np.swapaxes(a, 0, 2)&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; will return a writeable view of the diagonal of a 2D array.</source>
          <target state="translated">现在，只要输入数组可写，从einsum返回的视图就可以写。例如， &lt;code&gt;np.einsum('ijk...-&amp;gt;kji...', a)&lt;/code&gt; 现在将与&lt;a href=&quot;numpy.swapaxes#numpy.swapaxes&quot;&gt; &lt;code&gt;np.swapaxes(a, 0, 2)&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; 将返回2D数组对角线的可写视图。</target>
        </trans-unit>
        <trans-unit id="212733d972db48c77aaab9351402436eae4fd2ff" translate="yes" xml:space="preserve">
          <source>Views share data:</source>
          <target state="translated">观点共享数据。</target>
        </trans-unit>
        <trans-unit id="c9d8f3fc365bae8c1e0312cb68b7341a485aec6e" translate="yes" xml:space="preserve">
          <source>Views that change the dtype size (bytes per entry) should normally be avoided on arrays defined by slices, transposes, fortran-ordering, etc.:</source>
          <target state="translated">通常应该避免在由slices、transposes、fortran-ordering等定义的数组上使用改变dtype大小(每个条目的字节数)的视图。</target>
        </trans-unit>
        <trans-unit id="56b0a8ac25b1950e1419116b1fa18ea25ea62bb3" translate="yes" xml:space="preserve">
          <source>Violent threats or language directed against another person.</source>
          <target state="translated">针对他人的暴力威胁或语言;</target>
        </trans-unit>
        <trans-unit id="43e46231e2e4425940323040c2be47d46f02e331" translate="yes" xml:space="preserve">
          <source>Virtualenv</source>
          <target state="translated">Virtualenv</target>
        </trans-unit>
        <trans-unit id="2e7e7becfbd2f76f4c7a1cf2e451eb461ef24b08" translate="yes" xml:space="preserve">
          <source>Virtualenv is a very useful tool to keep several versions of packages around. It is also used in the Paver script to build the docs.</source>
          <target state="translated">Virtualenv是一个非常有用的工具,它可以让多个版本的包在身边。它也被用于Paver脚本来构建文档。</target>
        </trans-unit>
        <trans-unit id="319d8490779b3eba0e5e3b87402a7431309ef352" translate="yes" xml:space="preserve">
          <source>Void dtype discovery in &lt;code&gt;np.array&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;np.array&lt;/code&gt; 空Dtype发现</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="3cd2f9e2b1f25c2f5e7b93f7ce911077d7d964a4" translate="yes" xml:space="preserve">
          <source>W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery, &amp;ldquo;Numerical Recipes (3rd edition)&amp;rdquo;, Cambridge University Press, 2007, page 795.</source>
          <target state="translated">WH Press，SA Teukolsky，WT Vetterling和BP Flannery，&amp;ldquo;数字食谱（第3版）&amp;rdquo;，剑桥大学出版社，2007年，第795页。</target>
        </trans-unit>
        <trans-unit id="e9c669c28770b602c0d3307e40af975f3d6ab286" translate="yes" xml:space="preserve">
          <source>W.H. Press, B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling, &amp;ldquo;Numerical Recipes&amp;rdquo;, Cambridge University Press, 1986, page 425.</source>
          <target state="translated">WH出版社，BP Flannery，SA Teukolsky和WT Vetterling，&amp;ldquo;数字食谱&amp;rdquo;，剑桥大学出版社，1986年，第425页。</target>
        </trans-unit>
        <trans-unit id="dbd0b2fdf754a4d650097a931842e3ce01d68c23" translate="yes" xml:space="preserve">
          <source>W.H. Press, B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling, &amp;ldquo;Numerical Recipes&amp;rdquo;, Cambridge University Press, 1986, page 429.</source>
          <target state="translated">WH出版社，BP Flannery，SA Teukolsky和WT Vetterling，&amp;ldquo;数字食谱&amp;rdquo;，剑桥大学出版社，1986年，第429页。</target>
        </trans-unit>
        <trans-unit id="4d8b44b86ac9762795ccf1eb37bf4871143a380a" translate="yes" xml:space="preserve">
          <source>WRITEABLE (W) the data area can be written to;</source>
          <target state="translated">WRITEABLE (W)可写入数据区域。</target>
        </trans-unit>
        <trans-unit id="a6dcab075be566e2b98d550a936f8cae5ce9422f" translate="yes" xml:space="preserve">
          <source>WRITEABLE / W</source>
          <target state="translated">可写/W</target>
        </trans-unit>
        <trans-unit id="73fb58e7589a9ff67f327a9e1cfb0abcae369bb5" translate="yes" xml:space="preserve">
          <source>WRITEABLE can only be set &lt;code&gt;True&lt;/code&gt; if the array owns its own memory or the ultimate owner of the memory exposes a writeable buffer interface or is a string.</source>
          <target state="translated">仅当阵列拥有自己的内存或内存的最终所有者公开了可写缓冲区接口或为字符串时，才可以将WRITEABLE设置为 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ca2fe3e818dba5a5804a5bb3a831dd89c500d7a" translate="yes" xml:space="preserve">
          <source>WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced by .base). When the C-API function PyArray_ResolveWritebackIfCopy is called, the base array will be updated with the contents of this array.</source>
          <target state="translated">WRITEBACKIFCOPY (X)这个数组是其他数组的副本(由.base引用),当调用C-API函数PyArray_ResolveWritebackIfCopy时,这个数组的内容将被更新。当C-API函数PyArray_ResolveWritebackIfCopy被调用时,base数组将被更新为这个数组的内容。</target>
        </trans-unit>
        <trans-unit id="3b243b9b37eb143e3a1ec8091e9c80e424b7cb17" translate="yes" xml:space="preserve">
          <source>WRITEBACKIFCOPY / X</source>
          <target state="translated">WRITEBACKIFCOPY/X</target>
        </trans-unit>
        <trans-unit id="09fcb82609179c1f7885c137f520c527fdcb1905" translate="yes" xml:space="preserve">
          <source>WRITEBACKIFCOPY can only be set &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">只能将WRITEBACKIFCOPY设置为 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fd7081253d772e7a32e41421d2cdf6a9cabced2" translate="yes" xml:space="preserve">
          <source>Waloddi Weibull, &amp;ldquo;A Statistical Distribution Function of Wide Applicability&amp;rdquo;, Journal Of Applied Mechanics ASME Paper 1951.</source>
          <target state="translated">Waloddi Weibull，&amp;ldquo;广泛适用性的统计分布函数&amp;rdquo;，《应用力学杂志》 ASME，1951年发表。</target>
        </trans-unit>
        <trans-unit id="db8ff1d3b42b8d1fe40e88e8148de81cccee175c" translate="yes" xml:space="preserve">
          <source>Waloddi Weibull, Royal Technical University, Stockholm, 1939 &amp;ldquo;A Statistical Theory Of The Strength Of Materials&amp;rdquo;, Ingeniorsvetenskapsakademiens Handlingar Nr 151, 1939, Generalstabens Litografiska Anstalts Forlag, Stockholm.</source>
          <target state="translated">Waloddi Weibull，皇家技术大学，斯德哥尔摩，1939年，&amp;ldquo;材料强度的统计理论&amp;rdquo;，Ingeniorsvetenskapsakademiens Handlingar Nr 151，1939年，斯德哥尔摩，Generalstabens Litografiska Anstalt公司。</target>
        </trans-unit>
        <trans-unit id="f1346bf7169c446f1eec32708e49a903284d1169" translate="yes" xml:space="preserve">
          <source>Warn when saving a dtype with metadata</source>
          <target state="translated">保存带有元数据的dtype时发出警告。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="4754f4fe525f9c37d19fda1322550a0b26e13158" translate="yes" xml:space="preserve">
          <source>Warning class to filter</source>
          <target state="translated">警告类过滤</target>
        </trans-unit>
        <trans-unit id="f88a191846138392ad4758d4ff77a36f017f6d00" translate="yes" xml:space="preserve">
          <source>Warning objects</source>
          <target state="translated">警告对象</target>
        </trans-unit>
        <trans-unit id="bb630d84baa9f5fb3c8c438ee6064e7457d1688d" translate="yes" xml:space="preserve">
          <source>Warning on casting complex to real</source>
          <target state="translated">关于将综合体投向真实的警告</target>
        </trans-unit>
        <trans-unit id="37361059464af82221d16eb1a2018e9694f9cd57" translate="yes" xml:space="preserve">
          <source>Warning: This attribute exists specifically for &lt;code&gt;__array_interface__&lt;/code&gt;, and is not a datatype description compatible with &lt;code&gt;np.dtype&lt;/code&gt;.</source>
          <target state="translated">警告：此属性专门用于 &lt;code&gt;__array_interface__&lt;/code&gt; ，并且不是与 &lt;code&gt;np.dtype&lt;/code&gt; 兼容的数据类型描述。</target>
        </trans-unit>
        <trans-unit id="53dd2d8a36d40ea4bb66f08310fbbcb2e7533b5f" translate="yes" xml:space="preserve">
          <source>Warning: This attribute exists specifically for &lt;code&gt;__array_interface__&lt;/code&gt;, and passing it directly to &lt;code&gt;np.dtype&lt;/code&gt; will not accurately reconstruct some dtypes (e.g., scalar and subarray dtypes).</source>
          <target state="translated">警告：此属性专门用于 &lt;code&gt;__array_interface__&lt;/code&gt; ，并且将其直接传递给 &lt;code&gt;np.dtype&lt;/code&gt; 将无法准确地重构某些dtype（例如，标量和子数组dtype）。</target>
        </trans-unit>
        <trans-unit id="67f63aaa6eb093a2b8631aeb7aa1f1f56dd3fc86" translate="yes" xml:space="preserve">
          <source>Warning: This functionality does &lt;strong&gt;not&lt;/strong&gt; consider axes separately, i.e. it does not apply interpolation/extrapolation. It fills the return array with the required number of elements, taken from &lt;code&gt;a&lt;/code&gt; as they are laid out in memory, disregarding strides and axes. (This is in case the new shape is smaller. For larger, see above.) This functionality is therefore not suitable to resize images, or data where each axis represents a separate and distinct entity.</source>
          <target state="translated">警告：此功能并&lt;strong&gt;不会&lt;/strong&gt;单独考虑轴，即它并不适用插/外推。它填补与所需数量的元素，取自返回阵列 &lt;code&gt;a&lt;/code&gt; ，因为它们是在存储器布局，忽略进展和轴。 （这是在新形状较小的情况下。对于较大的形状，请参见上文。）因此，此功能不适用于调整图像或数据的大小，其中每个轴代表一个单独且不同的实体。</target>
        </trans-unit>
        <trans-unit id="1430f976c596795274458abcfbc4f280cbfcebac" translate="yes" xml:space="preserve">
          <source>Warnings</source>
          <target state="translated">Warnings</target>
        </trans-unit>
        <trans-unit id="60f5d88ea293a20258ae77bd080550b12d5b3d82" translate="yes" xml:space="preserve">
          <source>Warns</source>
          <target state="translated">Warns</target>
        </trans-unit>
        <trans-unit id="6fcbb55cbf3a317fd9e559a46404d4ffc0901e5d" translate="yes" xml:space="preserve">
          <source>Warns:</source>
          <target state="translated">Warns:</target>
        </trans-unit>
        <trans-unit id="2877e71e929aa29b0e79a512d385261189d70371" translate="yes" xml:space="preserve">
          <source>Wave heights tend to follow a Rayleigh distribution. If the mean wave height is 1 meter, what fraction of waves are likely to be larger than 3 meters?</source>
          <target state="translated">波高往往遵循雷利分布。如果平均波高为1米,那么大于3米的波高可能占多大比例?</target>
        </trans-unit>
        <trans-unit id="58cd26b5bf632fda361651c5bed4615a24ac5c34" translate="yes" xml:space="preserve">
          <source>We are thankful to the groups behind the following documents, from which we drew content and inspiration:</source>
          <target state="translated">我们感谢以下文件背后的团体,我们从这些文件中获得了内容和灵感。</target>
        </trans-unit>
        <trans-unit id="87d1583437d12a714a66434e88f0db3dd9eec3f0" translate="yes" xml:space="preserve">
          <source>We build 32- and 64-bit wheels on Windows. Windows 7, 8 and 10 are supported. We build NumPy using the &lt;a href=&quot;https://mingwpy.github.io&quot;&gt;mingw-w64 toolchain&lt;/a&gt; on Appveyor.</source>
          <target state="translated">我们在Windows上构建32位和64位轮子。支持Windows 7、8和10。我们使用Appveyor上的&lt;a href=&quot;https://mingwpy.github.io&quot;&gt;mingw-w64工具链&lt;/a&gt;构建NumPy 。</target>
        </trans-unit>
        <trans-unit id="52a53769f72b3e9d74a22d9793d68e7e1c952be3" translate="yes" xml:space="preserve">
          <source>We build all our wheels on cloud infrastructure - so this list of compilers is for information and debugging builds locally. See the &lt;code&gt;.travis.yml&lt;/code&gt; and &lt;code&gt;appveyor.yml&lt;/code&gt; scripts in the &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;numpy wheels&lt;/a&gt; repo for the definitive source of the build recipes. Packages that are available using pip are noted.</source>
          <target state="translated">我们将所有精力都放在云基础架构上-因此，此编译器列表用于提供信息并在本地调试构建。有关构建配方的确切来源，请参见&lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;numpy&lt;/a&gt; &lt;code&gt;appveyor.yml&lt;/code&gt; 的 &lt;code&gt;.travis.yml&lt;/code&gt; 和appveyor.yml脚本。注意使用pip可用的软件包。</target>
        </trans-unit>
        <trans-unit id="5ffd71ee5e18a21e4fac71c59e3fce6abfaf692e" translate="yes" xml:space="preserve">
          <source>We build and ship &lt;a href=&quot;https://www.python.org/dev/peps/pep-0513&quot;&gt;manylinux1&lt;/a&gt; wheels for NumPy. Many Linux distributions include their own binary builds of NumPy.</source>
          <target state="translated">我们为NumPy建造并运送了&lt;a href=&quot;https://www.python.org/dev/peps/pep-0513&quot;&gt;许多Linux1&lt;/a&gt;车轮。许多Linux发行版都包含自己的NumPy二进制版本。</target>
        </trans-unit>
        <trans-unit id="c2a47a01a930577b3f6fd6bc57c66f9caa61248a" translate="yes" xml:space="preserve">
          <source>We build source releases in both .zip and .tar.gz formats.</source>
          <target state="translated">我们以.zip和.tar.gz两种格式构建源代码。</target>
        </trans-unit>
        <trans-unit id="90fdab75def7d856cf227160207c1857877a95de" translate="yes" xml:space="preserve">
          <source>We can access the elements in the array using square brackets. When you&amp;rsquo;re accessing elements, remember that indexing in NumPy starts at 0. That means that if you want to access the first element in your array, you&amp;rsquo;ll be accessing element &amp;ldquo;0&amp;rdquo;.</source>
          <target state="translated">我们可以使用方括号访问数组中的元素。在访问元素时，请记住NumPy中的索引从0开始。这意味着，如果要访问数组中的第一个元素，则将访问元素&amp;ldquo; 0&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="27c3166519c3983dd1bdd287de2f7543430ee161" translate="yes" xml:space="preserve">
          <source>We can also access the valid entries by using the logical negation for this mask:</source>
          <target state="translated">我们也可以通过使用这个掩码的逻辑否定来访问有效条目。</target>
        </trans-unit>
        <trans-unit id="72895573c71234a77f8f78e60c8d2a3fa9071512" translate="yes" xml:space="preserve">
          <source>We can also give indexes for more than one dimension. The arrays of indices for each dimension must have the same shape.</source>
          <target state="translated">我们也可以给出多个维度的索引。每个维度的索引数组必须具有相同的形状。</target>
        </trans-unit>
        <trans-unit id="d199611fe572f9a604421aeb87fed868192644af" translate="yes" xml:space="preserve">
          <source>We can begin with a chain dot example. In this case, it is optimal to contract the &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; tensors first as represented by the first element of the path &lt;code&gt;(1, 2)&lt;/code&gt;. The resulting tensor is added to the end of the contraction and the remaining contraction &lt;code&gt;(0, 1)&lt;/code&gt; is then completed.</source>
          <target state="translated">我们可以从一个链点示例开始。在这种情况下，最好先收缩 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 张量，如路径 &lt;code&gt;(1, 2)&lt;/code&gt; 的第一个元素所示。将所得张量添加到收缩的末尾，然后完成剩余的收缩 &lt;code&gt;(0, 1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c24b2dc7e2cf1c2ee15a3b856c501da4eb664f2c" translate="yes" xml:space="preserve">
          <source>We can convert to a numpy array using &lt;a href=&quot;../reference/generated/numpy.array#numpy.array&quot;&gt;&lt;code&gt;numpy.array&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/generated/numpy.asarray#numpy.asarray&quot;&gt;&lt;code&gt;numpy.asarray&lt;/code&gt;&lt;/a&gt;, which will call its &lt;code&gt;__array__&lt;/code&gt; method to obtain a standard &lt;code&gt;numpy.ndarray&lt;/code&gt;.</source>
          <target state="translated">我们可以转换到使用numpy的阵列&lt;a href=&quot;../reference/generated/numpy.array#numpy.array&quot;&gt; &lt;code&gt;numpy.array&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../reference/generated/numpy.asarray#numpy.asarray&quot;&gt; &lt;code&gt;numpy.asarray&lt;/code&gt; &lt;/a&gt;，这将调用其 &lt;code&gt;__array__&lt;/code&gt; 方法来获得标准 &lt;code&gt;numpy.ndarray&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="679a2f0f20fc2e3fa05b5f20a0ca536c32a5eeaa" translate="yes" xml:space="preserve">
          <source>We can get a finer control on the conversion of missing values with the &lt;code&gt;filling_values&lt;/code&gt; optional argument. Like &lt;code&gt;missing_values&lt;/code&gt;, this argument accepts different kind of values:</source>
          <target state="translated">使用 &lt;code&gt;filling_values&lt;/code&gt; 可选参数，我们可以更好地控制缺失值的转换。像 &lt;code&gt;missing_values&lt;/code&gt; 一样，此参数接受不同类型的值：</target>
        </trans-unit>
        <trans-unit id="66a6a3c1aa8ab5615ae93578f83c6c2bc137c427" translate="yes" xml:space="preserve">
          <source>We can now compute the mean of the dataset, without taking the invalid data into account:</source>
          <target state="translated">现在我们可以计算数据集的平均值,而不考虑无效数据。</target>
        </trans-unit>
        <trans-unit id="52c82ab011abc5da0365af1d671286d5b3b09bbe" translate="yes" xml:space="preserve">
          <source>We can overwrite this default with the &lt;code&gt;defaultfmt&lt;/code&gt; argument, that takes any format string:</source>
          <target state="translated">我们可以使用 &lt;code&gt;defaultfmt&lt;/code&gt; 参数覆盖此默认值，该参数可以使用任何格式的字符串：</target>
        </trans-unit>
        <trans-unit id="55ec8b33a4acc5b04909546d200237b6de3e0139" translate="yes" xml:space="preserve">
          <source>We can replace the data with this information and plot a new graph, focusing on Mainland China:</source>
          <target state="translated">我们可以用这些信息替换数据,绘制一个新的图形,关注中国大陆。</target>
        </trans-unit>
        <trans-unit id="07dfd0de116a4118d2e8d7ab1e0ba4c4055ce110" translate="yes" xml:space="preserve">
          <source>We can replace the maximum values with:</source>
          <target state="translated">我们可以将最大值替换为:</target>
        </trans-unit>
        <trans-unit id="e6a512625d0cb7e17ddcfbaaf190c6f0c94959ed" translate="yes" xml:space="preserve">
          <source>We can reset the function to the default:</source>
          <target state="translated">我们可以将该函数重置为默认值。</target>
        </trans-unit>
        <trans-unit id="b52b8758d686451191a4e1193e567d392d717d53" translate="yes" xml:space="preserve">
          <source>We can rewrite the line equation as &lt;code&gt;y = Ap&lt;/code&gt;, where &lt;code&gt;A = [[x 1]]&lt;/code&gt; and &lt;code&gt;p = [[m], [c]]&lt;/code&gt;. Now use &lt;a href=&quot;#numpy.linalg.lstsq&quot;&gt;&lt;code&gt;lstsq&lt;/code&gt;&lt;/a&gt; to solve for &lt;code&gt;p&lt;/code&gt;:</source>
          <target state="translated">我们可以将线方程改写为 &lt;code&gt;y = Ap&lt;/code&gt; ，其中 &lt;code&gt;A = [[x 1]]&lt;/code&gt; 和 &lt;code&gt;p = [[m], [c]]&lt;/code&gt; 。现在使用&lt;a href=&quot;#numpy.linalg.lstsq&quot;&gt; &lt;code&gt;lstsq&lt;/code&gt; &lt;/a&gt;求解 &lt;code&gt;p&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dd1121cb835ca07af6856a6e1f4f9f9a02284739" translate="yes" xml:space="preserve">
          <source>We can see that this is a different kind of array. As mentioned in the introduction, it has three attributes (&lt;code&gt;data&lt;/code&gt;, &lt;code&gt;mask&lt;/code&gt; and &lt;code&gt;fill_value&lt;/code&gt;). Keep in mind that the &lt;code&gt;mask&lt;/code&gt; attribute has a &lt;code&gt;True&lt;/code&gt; value for elements corresponding to &lt;strong&gt;invalid&lt;/strong&gt; data (represented by two dashes in the &lt;code&gt;data&lt;/code&gt; attribute).</source>
          <target state="translated">我们可以看到这是另一种数组。如简介中所述，它具有三个属性（ &lt;code&gt;data&lt;/code&gt; ， &lt;code&gt;mask&lt;/code&gt; 和 &lt;code&gt;fill_value&lt;/code&gt; ）。请记住，对于与&lt;strong&gt;无效&lt;/strong&gt;数据相对应的元素， &lt;code&gt;mask&lt;/code&gt; 属性具有 &lt;code&gt;True&lt;/code&gt; 值（由 &lt;code&gt;data&lt;/code&gt; 属性中的两个破折号表示）。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9280da38538a3f969f230f09cea0b4dbc319a8ef" translate="yes" xml:space="preserve">
          <source>We can see the image using the &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.imshow.html#matplotlib.pyplot.imshow&quot;&gt;&lt;code&gt;matplotlib.pyplot.imshow&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">我们可以使用&lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.imshow.html#matplotlib.pyplot.imshow&quot;&gt; &lt;code&gt;matplotlib.pyplot.imshow&lt;/code&gt; &lt;/a&gt;函数查看图像：</target>
        </trans-unit>
        <trans-unit id="bcf794d24d8964269b87153ebb1affba96ff631d" translate="yes" xml:space="preserve">
          <source>We can sort either by using sort directly, or argsort and this function</source>
          <target state="translated">我们既可以直接使用排序,也可以使用argsort和这个函数进行排序。</target>
        </trans-unit>
        <trans-unit id="1a14ecae9fbda2061a0c2690a51d04695403160b" translate="yes" xml:space="preserve">
          <source>We can think of a &lt;a href=&quot;../reference/maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; as a combination of:</source>
          <target state="translated">我们可以将&lt;a href=&quot;../reference/maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;视为以下各项的组合：</target>
        </trans-unit>
        <trans-unit id="c8b935f50d33884f474e4109b428a56eb6fe6366" translate="yes" xml:space="preserve">
          <source>We can use a different method other than the default to factorize cov: &amp;gt;&amp;gt;&amp;gt; y = rng.multivariate_normal(mean, cov, (3, 3), method=&amp;rsquo;cholesky&amp;rsquo;) &amp;gt;&amp;gt;&amp;gt; y.shape (3, 3, 2)</source>
          <target state="translated">我们可以使用默认方法以外的其他方法来分解cov：&amp;gt;&amp;gt;&amp;gt; y = rng.multivariate_normal（mean，cov，（3，3），method ='cholesky'）&amp;gt;&amp;gt;&amp;gt; y.shape（3，3， 2）</target>
        </trans-unit>
        <trans-unit id="23502bd41157dbb482cc4d93fe154b6f35759b68" translate="yes" xml:space="preserve">
          <source>We can verify this, approximating the derivative with &lt;code&gt;(f(x + h) - f(x))/h&lt;/code&gt;:</source>
          <target state="translated">我们可以用 &lt;code&gt;(f(x + h) - f(x))/h&lt;/code&gt; 近似导数来验证这一点：</target>
        </trans-unit>
        <trans-unit id="1edbc1babc558648a370766b66d6bf09ff4d2327" translate="yes" xml:space="preserve">
          <source>We chose our default threshold because it is in wide use. Other thresholds are possible. For example, elsewhere in the 2007 edition of &lt;em&gt;Numerical recipes&lt;/em&gt; there is an alternative threshold of &lt;code&gt;S.max() *
np.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.)&lt;/code&gt;. The authors describe this threshold as being based on &amp;ldquo;expected roundoff error&amp;rdquo; (p 71).</source>
          <target state="translated">我们选择了默认阈值，因为它已被广泛使用。其他阈值也是可能的。例如，在2007年版《&lt;em&gt;数字食谱》的&lt;/em&gt;其他地方，还有一个替代阈值 &lt;code&gt;S.max() * np.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.)&lt;/code&gt; 。作者将这个阈值描述为基于&amp;ldquo;预期的舍入误差&amp;rdquo;（第71页）。</target>
        </trans-unit>
        <trans-unit id="81b92d4d0e0bfcb2ba46a1a8b9dd4a22e1691631" translate="yes" xml:space="preserve">
          <source>We could also have used the &lt;a href=&quot;../reference/generated/numpy.allclose#numpy.allclose&quot;&gt;&lt;code&gt;numpy.allclose&lt;/code&gt;&lt;/a&gt; function to make sure the reconstructed product is, in fact, &lt;em&gt;close&lt;/em&gt; to our original matrix (the difference between the two arrays is small):</source>
          <target state="translated">我们还可以使用&lt;a href=&quot;../reference/generated/numpy.allclose#numpy.allclose&quot;&gt; &lt;code&gt;numpy.allclose&lt;/code&gt; &lt;/a&gt;函数来确保重构后的乘积实际上&lt;em&gt;接近于&lt;/em&gt;原始矩阵（两个数组之间的差很小）：</target>
        </trans-unit>
        <trans-unit id="d8ba993fff071da05f22748cefa6f6b8ad24e53b" translate="yes" xml:space="preserve">
          <source>We could have implemented:</source>
          <target state="translated">我们本可以实施。</target>
        </trans-unit>
        <trans-unit id="37a18e023d482a1a5f3f0844c696551b9f7ca294" translate="yes" xml:space="preserve">
          <source>We currently support Python 3.6-3.8 on Windows, OSX, and Linux</source>
          <target state="translated">我们目前在Windows、OSX和Linux上支持Python 3.6-3.8。</target>
        </trans-unit>
        <trans-unit id="07a1c0a83c857f695d91b773fe8da038b7dff7fd" translate="yes" xml:space="preserve">
          <source>We currently use &lt;a href=&quot;http://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; for generating the API and reference documentation for NumPy. You will need Sphinx &amp;gt;= 2.2.0.</source>
          <target state="translated">当前，我们使用&lt;a href=&quot;http://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt;生成NumPy的API和参考文档。您将需要Sphinx&amp;gt; = 2.2.0。</target>
        </trans-unit>
        <trans-unit id="3e8150976e1be876e23fe9902955320291d1f04b" translate="yes" xml:space="preserve">
          <source>We currently use &lt;a href=&quot;https://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; for generating the API and reference documentation for NumPy. You will need Sphinx &amp;gt;= 2.2.0.</source>
          <target state="translated">当前，我们使用&lt;a href=&quot;https://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt;生成NumPy的API和参考文档。您将需要Sphinx&amp;gt; = 2.2.0。</target>
        </trans-unit>
        <trans-unit id="59bec2d1c76c534a2fc4afd9318e87ce91e937b9" translate="yes" xml:space="preserve">
          <source>We default to using a 128-bit integer using entropy gathered from the OS. This is a good amount of entropy to initialize all of the generators that we have in numpy. We do not recommend using small seeds below 32 bits for general use. Using just a small set of seeds to instantiate larger state spaces means that there are some initial states that are impossible to reach. This creates some biases if everyone uses such values.</source>
          <target state="translated">我们默认使用从操作系统中收集的熵来使用128位的整数。这对于初始化我们在numpy中的所有生成器来说是一个很好的熵量。我们不推荐使用低于32位的小种子,用于一般用途。只使用小的种子集来实例化更大的状态空间,意味着有一些初始状态是不可能达到的。如果大家都使用这样的值,就会产生一些偏差。</target>
        </trans-unit>
        <trans-unit id="5796ea3e43e927c951158cf75a113735a9be5c88" translate="yes" xml:space="preserve">
          <source>We distinguish both tutorials and how-tos from &lt;code&gt;Explanations&lt;/code&gt;, which are deep dives intended to give understanding rather than immediate assistance, and &lt;code&gt;References&lt;/code&gt;, which give complete, autoritative data on some concrete part of NumPy (like its API) but aren&amp;rsquo;t obligated to paint a broader picture.</source>
          <target state="translated">我们将&amp;ldquo;教程&amp;rdquo;和&amp;ldquo;操作方法&amp;rdquo;与&amp;ldquo; &lt;code&gt;Explanations&lt;/code&gt; （旨在深入理解而不是立即提供帮助）和&amp;ldquo; &lt;code&gt;References&lt;/code&gt; （用于提供有关NumPy某些具体部分（例如其API）的完整，自定义数据的深入理解&amp;rdquo;区分开来，但没有义务描绘出更广阔的前景。</target>
        </trans-unit>
        <trans-unit id="dc787d0b25c896acc068b7c607665544c0350ae5" translate="yes" xml:space="preserve">
          <source>We do as follows:</source>
          <target state="translated">我们的做法如下:</target>
        </trans-unit>
        <trans-unit id="6c39690106b67e736bf72e53ea7082db75a8ca14" translate="yes" xml:space="preserve">
          <source>We expect the arccos of 1 to be 0, and of -1 to be pi:</source>
          <target state="translated">我们期望1的arccos是0,而-1的arccos是pi。</target>
        </trans-unit>
        <trans-unit id="44f2a9cfd92075d83d3f564752917c6115d7836b" translate="yes" xml:space="preserve">
          <source>We expect the arctan of 0 to be 0, and of 1 to be pi/4:</source>
          <target state="translated">我们期望0的arctan是0,1的arctan是pi/4。</target>
        </trans-unit>
        <trans-unit id="b30e48f7bd5611b7e5063995e5e3d8d0377a6a59" translate="yes" xml:space="preserve">
          <source>We finally give an example of a full ufunc, with inner loops for half-floats, floats, doubles, and long doubles. As in the previous sections we first give the .c file and then the corresponding setup.py file.</source>
          <target state="translated">最后我们给出一个完整的ufunc的例子,其中包含了半浮点、浮点、双倍和长双倍的内循环。和前面几节一样,我们先给出.c文件,然后再给出相应的setup.py文件。</target>
        </trans-unit>
        <trans-unit id="60136b35f0997a97a43dcb76040b0f18f3536c81" translate="yes" xml:space="preserve">
          <source>We have 10 degrees of freedom, so is the sample mean within 95% of the recommended value?</source>
          <target state="translated">我们有10个自由度,那么样本均值是否在推荐值的95%以内?</target>
        </trans-unit>
        <trans-unit id="84db14adfcdaf5f72b2db96fd86ac625f5af0ee6" translate="yes" xml:space="preserve">
          <source>We have authoritative answers.</source>
          <target state="translated">我们有权威的答案。</target>
        </trans-unit>
        <trans-unit id="e5235dd026426cf863204463534241d25f8524b9" translate="yes" xml:space="preserve">
          <source>We intend to re-implement numpy functions as (generalized) Ufunc, in which case it will become possible for them to be overridden by the &lt;code&gt;__array_ufunc__&lt;/code&gt; method. A prime candidate is &lt;a href=&quot;generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;matmul&lt;/code&gt;&lt;/a&gt;, which currently is not a Ufunc, but could be relatively easily be rewritten as a (set of) generalized Ufuncs. The same may happen with functions such as &lt;a href=&quot;generated/numpy.median#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.amin#numpy.amin&quot;&gt;&lt;code&gt;amin&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">我们打算将numpy函数重新实现为（通用的）Ufunc，在这种情况下，有可能被 &lt;code&gt;__array_ufunc__&lt;/code&gt; 方法覆盖。最主要的候选者是&lt;a href=&quot;generated/numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;matmul&lt;/code&gt; &lt;/a&gt;，它目前不是Ufunc，但是可以相对容易地重写为（一组）广义Ufuncs。同样可以用功能，如发生&lt;a href=&quot;generated/numpy.median#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.amin#numpy.amin&quot;&gt; &lt;code&gt;amin&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e23f0ad561893af23edd41efd72f4bd368c5b95" translate="yes" xml:space="preserve">
          <source>We intend to re-implement numpy functions as (generalized) Ufunc, in which case it will become possible for them to be overridden by the &lt;code&gt;__array_ufunc__&lt;/code&gt; method. A prime candidate is &lt;a href=&quot;generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;matmul&lt;/code&gt;&lt;/a&gt;, which currently is not a Ufunc, but could be relatively easily be rewritten as a (set of) generalized Ufuncs. The same may happen with functions such as &lt;a href=&quot;generated/numpy.median#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;min&lt;/code&gt;, and &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">我们打算将numpy函数重新实现为（通用的）Ufunc，在这种情况下，有可能被 &lt;code&gt;__array_ufunc__&lt;/code&gt; 方法覆盖。最主要的候选者是&lt;a href=&quot;generated/numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;matmul&lt;/code&gt; &lt;/a&gt;，它目前不是Ufunc，但是可以相对容易地重写为（一组）广义Ufuncs。函数可能发生同样的情况，例如中&lt;a href=&quot;generated/numpy.median#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;min&lt;/code&gt; 和&lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1293e5317149027712d90c363de09ae292d438a7" translate="yes" xml:space="preserve">
          <source>We know how to recognize missing data, but we still need to provide a value for these missing entries. By default, this value is determined from the expected dtype according to this table:</source>
          <target state="translated">我们知道如何识别缺失的数据,但我们仍然需要为这些缺失的条目提供一个值。默认情况下,这个值是根据这个表的预期dtype确定的。</target>
        </trans-unit>
        <trans-unit id="6f8e06849ef9bab23d7db3a10be02e06887dd75e" translate="yes" xml:space="preserve">
          <source>We know that it is painfully common for internet communication to start at or devolve into obvious and flagrant abuse. We also recognize that sometimes people may have a bad day, or be unaware of some of the guidelines in this Code of Conduct. Please keep this in mind when deciding on how to respond to a breach of this Code.</source>
          <target state="translated">我们知道,互联网通信开始或发展到明显和公然的滥用是很痛苦的。我们也认识到,有时人们可能会有糟糕的一天,或者不知道本行为准则中的一些准则。在决定如何应对违反本守则的行为时,请牢记这一点。</target>
        </trans-unit>
        <trans-unit id="c3d95188759c6e8c19362be20ce93f51fbaea853" translate="yes" xml:space="preserve">
          <source>We know that it is painfully common for internet communication to start at or devolve into obvious and flagrant abuse. We will deal quickly with clear and severe breaches like personal threats, violent, sexist or racist language.</source>
          <target state="translated">我们知道,互联网通信开始或发展到明显和公然的滥用是非常痛苦的。我们将迅速处理明显而严重的违规行为,如人身威胁、暴力、性别歧视或种族主义语言。</target>
        </trans-unit>
        <trans-unit id="f7544e988af826e0fbccd6c4b63e19df859cd38a" translate="yes" xml:space="preserve">
          <source>We make something where they don&amp;rsquo;t match:</source>
          <target state="translated">我们做一些他们不匹配的东西：</target>
        </trans-unit>
        <trans-unit id="781a6efc97caaf1a36d25f937ebe769fa9a9b591" translate="yes" xml:space="preserve">
          <source>We may also want to keep track of the occurrence of missing data by constructing a boolean mask, with &lt;code&gt;True&lt;/code&gt; entries where data was missing and &lt;code&gt;False&lt;/code&gt; otherwise. To do that, we just have to set the optional argument &lt;code&gt;usemask&lt;/code&gt; to &lt;code&gt;True&lt;/code&gt; (the default is &lt;code&gt;False&lt;/code&gt;). The output array will then be a &lt;a href=&quot;../reference/maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">我们可能还想通过构造一个布尔掩码来跟踪丢失数据的发生，在数据丢失的情况下使用 &lt;code&gt;True&lt;/code&gt; 条目，在其他情况下使用 &lt;code&gt;False&lt;/code&gt; 。为此，我们只需要将可选参数 &lt;code&gt;usemask&lt;/code&gt; 设置为 &lt;code&gt;True&lt;/code&gt; （默认值为 &lt;code&gt;False&lt;/code&gt; ）。然后，输出数组将为&lt;a href=&quot;../reference/maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d343b0827c2326d2e2dfa15e06ce5fa3d4c2f432" translate="yes" xml:space="preserve">
          <source>We may sometimes need to define the column names from the data itself. In that case, we must use the &lt;code&gt;names&lt;/code&gt; keyword with a value of &lt;code&gt;True&lt;/code&gt;. The names will then be read from the first line (after the &lt;code&gt;skip_header&lt;/code&gt; ones), even if the line is commented out:</source>
          <target state="translated">有时我们可能需要根据数据本身定义列名称。在这种情况下，我们必须使用具有 &lt;code&gt;True&lt;/code&gt; 值的 &lt;code&gt;names&lt;/code&gt; 关键字。即使从第一行中将其 &lt;code&gt;skip_header&lt;/code&gt; ，也将从第一行（在skip_header之后）读取名称：</target>
        </trans-unit>
        <trans-unit id="a4d639f7ac01ada7c421e46e5c0c6852fa788e6e" translate="yes" xml:space="preserve">
          <source>We might want to use an &lt;code&gt;ndarray&lt;/code&gt; to access these integers. In that case, we can create an array around this memory, and tell numpy that there are two integers, and that they are 16 bit and big-endian:</source>
          <target state="translated">我们可能要使用 &lt;code&gt;ndarray&lt;/code&gt; 来访问这些整数。在这种情况下，我们可以在此内存周围创建一个数组，并告诉numpy有两个整数，它们是16位的big-endian：</target>
        </trans-unit>
        <trans-unit id="072334154bb34d89af6df6dd9ad4c673bc66d42c" translate="yes" xml:space="preserve">
          <source>We mostly follow the standard Python style conventions as described here:</source>
          <target state="translated">我们主要遵循标准的Python风格约定,如这里所述。</target>
        </trans-unit>
        <trans-unit id="b81decf25be5fe15c427b84c45168043bb0f3933" translate="yes" xml:space="preserve">
          <source>We need to keep in mind that &lt;code&gt;defaultfmt&lt;/code&gt; is used only if some names are expected but not defined.</source>
          <target state="translated">我们需要记住，仅当需要某些名称但未定义某些名称时， &lt;code&gt;defaultfmt&lt;/code&gt; 使用defaultfmt。</target>
        </trans-unit>
        <trans-unit id="380361f0524609518a908c9433a3d7c3dd0b0e84" translate="yes" xml:space="preserve">
          <source>We need to keep in mind that by default, &lt;code&gt;dtype=float&lt;/code&gt;. A float is therefore expected for the second column. However, the strings &lt;code&gt;' 2.3%'&lt;/code&gt; and &lt;code&gt;' 78.9%'&lt;/code&gt; cannot be converted to float and we end up having &lt;code&gt;np.nan&lt;/code&gt; instead. Let&amp;rsquo;s now use a converter:</source>
          <target state="translated">我们需要记住，默认情况下， &lt;code&gt;dtype=float&lt;/code&gt; 。因此，第二列应该有一个浮点数。但是，字符串 &lt;code&gt;' 2.3%'&lt;/code&gt; 和 &lt;code&gt;np.nan&lt;/code&gt; &lt;code&gt;' 78.9%'&lt;/code&gt; 不能转换为float，而最终得到的是np.nan。现在让我们使用一个转换器：</target>
        </trans-unit>
        <trans-unit id="b3cf3455d01dd7db3c5c070359dd30cf5e39de43" translate="yes" xml:space="preserve">
          <source>We need to stress that this behavior may not be systematic, that masked data may be affected by the operation in some cases and therefore users should not rely on this data remaining unchanged.</source>
          <target state="translated">我们需要强调的是,这种行为可能并不是系统性的,被屏蔽的数据在某些情况下可能会受到操作的影响,因此用户不应该依赖这些数据保持不变。</target>
        </trans-unit>
        <trans-unit id="70c4b47019e4c41b3daf6bed7ca28bdcaf2fd573" translate="yes" xml:space="preserve">
          <source>We only give the C code as the setup.py file is exactly the same as the setup.py file in &lt;a href=&quot;#example-numpy-ufunc-for-one-dtype&quot;&gt;Example NumPy ufunc for one dtype&lt;/a&gt;, except that the line</source>
          <target state="translated">我们只给出C代码，因为&lt;a href=&quot;#example-numpy-ufunc-for-one-dtype&quot;&gt;对于一个dtype&lt;/a&gt;，setup.py文件与示例NumPy ufunc中的setup.py文件完全相同，除了该行</target>
        </trans-unit>
        <trans-unit id="58ff07099c06b392c411860c04ae360c63b97582" translate="yes" xml:space="preserve">
          <source>We only show a few blocks for clarity:</source>
          <target state="translated">为了清楚起见,我们只展示几个区块。</target>
        </trans-unit>
        <trans-unit id="3d2e197c5a535b7925bbc101233e0083e1245480" translate="yes" xml:space="preserve">
          <source>We pluralize &lt;em&gt;index&lt;/em&gt; as &lt;em&gt;indices&lt;/em&gt; rather than &lt;a href=&quot;https://developers.google.com/style/word-list#letter-i&quot;&gt;indexes&lt;/a&gt;, following the precedent of &lt;a href=&quot;../reference/generated/numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;numpy.indices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">我们以复数&lt;em&gt;指数&lt;/em&gt;作为&lt;em&gt;指标&lt;/em&gt;，而不是&lt;a href=&quot;https://developers.google.com/style/word-list#letter-i&quot;&gt;指数&lt;/a&gt;，的先例以下&lt;a href=&quot;../reference/generated/numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;numpy.indices&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="304f3c954bda4d21c5240e032a79df191a1f957e" translate="yes" xml:space="preserve">
          <source>We prefer not to use the Google style</source>
          <target state="translated">我们不喜欢使用谷歌风格</target>
        </trans-unit>
        <trans-unit id="673c3f49f8ee0b4069fb17ea81837a33f48d70f3" translate="yes" xml:space="preserve">
          <source>We recommend using &lt;a href=&quot;numpy.isin#numpy.isin&quot;&gt;&lt;code&gt;isin&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#numpy.in1d&quot;&gt;&lt;code&gt;in1d&lt;/code&gt;&lt;/a&gt; for new code.</source>
          <target state="translated">我们建议使用&lt;a href=&quot;numpy.isin#numpy.isin&quot;&gt; &lt;code&gt;isin&lt;/code&gt; &lt;/a&gt;代替&lt;a href=&quot;#numpy.in1d&quot;&gt; &lt;code&gt;in1d&lt;/code&gt; &lt;/a&gt;对新代码。</target>
        </trans-unit>
        <trans-unit id="cf93137d5dc17f96b6bf02cdfd69394699568873" translate="yes" xml:space="preserve">
          <source>We recommend using dtype objects instead.</source>
          <target state="translated">我们建议使用dtype对象代替。</target>
        </trans-unit>
        <trans-unit id="7ca33c6b93a76db017c3cdc61675ace9bc2b416c" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;code&gt;.npy&lt;/code&gt; and &lt;code&gt;.npz&lt;/code&gt; extensions for files saved in this format. This is by no means a requirement; applications may wish to use these file formats but use an extension specific to the application. In the absence of an obvious alternative, however, we suggest using &lt;code&gt;.npy&lt;/code&gt; and &lt;code&gt;.npz&lt;/code&gt;.</source>
          <target state="translated">对于以这种格式保存的文件，我们建议使用 &lt;code&gt;.npy&lt;/code&gt; 和 &lt;code&gt;.npz&lt;/code&gt; 扩展名。这绝不是必须的；应用程序可能希望使用这些文件格式，但使用特定于该应用程序的扩展名。但是，在没有明显替代方案的情况下，我们建议使用 &lt;code&gt;.npy&lt;/code&gt; 和 &lt;code&gt;.npz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e258b740225a3be0218640f279a2c21d7ffb3dc3" translate="yes" xml:space="preserve">
          <source>We review pull requests as soon as we can, typically within a week. If you get no review comments within two weeks, feel free to ask for feedback by adding a comment on your PR (this will notify maintainers).</source>
          <target state="translated">我们会尽快审核拉取请求,通常在一周内。如果您在两周内没有收到审查意见,请在您的PR上添加评论,以寻求反馈(这将通知维护者)。</target>
        </trans-unit>
        <trans-unit id="2d2b661adfc63aa8859c127667d479a970f43ef4" translate="yes" xml:space="preserve">
          <source>We run a ufunc on an instance of our new array:</source>
          <target state="translated">我们在新数组的一个实例上运行ufunc。</target>
        </trans-unit>
        <trans-unit id="cba0887597362639bee54fad4d580fb5a05cde4d" translate="yes" xml:space="preserve">
          <source>We set the printing precision so the example can be auto-tested:</source>
          <target state="translated">我们设置了印刷精度,所以例子可以自动测试。</target>
        </trans-unit>
        <trans-unit id="44aaad76397b012d2d13a57d62118fcba214a475" translate="yes" xml:space="preserve">
          <source>We strive to:</source>
          <target state="translated">我们努力做到:</target>
        </trans-unit>
        <trans-unit id="33c0514953dd33becf83ed3bc37cb8f06826d505" translate="yes" xml:space="preserve">
          <source>We then define a new test case class for each supported data type with a short definition such as:</source>
          <target state="translated">然后我们为每个支持的数据类型定义一个新的测试用例类,并给出一个简短的定义,如:。</target>
        </trans-unit>
        <trans-unit id="0935f73910a1bfd402810a3c2528dcf47c85a9da" translate="yes" xml:space="preserve">
          <source>We understand that email is a difficult medium and can be isolating. Receiving criticism over email, without personal contact, can be particularly painful. This makes it especially important to keep an atmosphere of open-minded respect of the views of others. It also means that we must be transparent in our actions, and that we will do everything in our power to make sure that all our members are treated fairly and with sympathy.</source>
          <target state="translated">我们理解电子邮件是一种困难的媒介,可能会让人感到孤独。在没有个人联系的情况下,通过电子邮件接受批评可能会特别痛苦。因此,保持一种开放的氛围,尊重他人的意见就显得尤为重要。这也意味着,我们的行动必须透明,我们将尽一切力量确保我们的所有成员得到公平和同情的对待。</target>
        </trans-unit>
        <trans-unit id="ad180c1380373588b422b6f9367e1dfa995335a7" translate="yes" xml:space="preserve">
          <source>We use the algorithm published by Clenshaw &lt;a href=&quot;#rfd38a370b188-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; and referenced by Abramowitz and Stegun &lt;a href=&quot;#rfd38a370b188-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;, for which the function domain is partitioned into the two intervals [0,8] and (8,inf), and Chebyshev polynomial expansions are employed in each interval. Relative error on the domain [0,30] using IEEE arithmetic is documented &lt;a href=&quot;#rfd38a370b188-3&quot; id=&quot;id3&quot;&gt;[3]&lt;/a&gt; as having a peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).</source>
          <target state="translated">我们使用由Clenshaw &lt;a href=&quot;#rfd38a370b188-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;发布并由Abramowitz和Stegun &lt;a href=&quot;#rfd38a370b188-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;引用的算法，针对该算法，功能域被划分为两个区间[0,8]和（8，inf），而Chebyshev多项式展开式则用于每个间隔。使用IEEE算术在域[0,30]上的相对误差记录为&lt;a href=&quot;#rfd38a370b188-3&quot; id=&quot;id3&quot;&gt;[3]&lt;/a&gt;，具有5.8e-16的峰值和均方根值为1.4e-16（n = 30000）。</target>
        </trans-unit>
        <trans-unit id="9d53c78c1f4b5630c6b07b51b68a31292300c983" translate="yes" xml:space="preserve">
          <source>We use the same Fortran 77 code as in previous example but now we&amp;rsquo;ll pretend that F2PY was not able to guess the signatures of call-back arguments correctly. First, we create an initial signature file &lt;code&gt;callback2.pyf&lt;/code&gt; using F2PY:</source>
          <target state="translated">我们使用与先前示例相同的Fortran 77代码，但现在我们假装F2PY无法正确猜测回调参数的签名。首先，我们使用F2PY创建一个初始签名文件 &lt;code&gt;callback2.pyf&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a0523fb6c3b4aea424494446d21b54e60300c1ae" translate="yes" xml:space="preserve">
          <source>We wait until this point to push the tag because it is public and should not be changed after it has been pushed.</source>
          <target state="translated">我们等到这个时候才推送标签,因为标签是公开的,推送后不应该更改。</target>
        </trans-unit>
        <trans-unit id="97648b7bd3927ac1d2723b1e8ddc4d732f8e55fd" translate="yes" xml:space="preserve">
          <source>We welcome being &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;alerted&lt;/a&gt; to cases we should add to the NumPy style rules.</source>
          <target state="translated">我们欢迎&lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;收到有关&lt;/a&gt;应添加到NumPy样式规则的案例的警报。</target>
        </trans-unit>
        <trans-unit id="c9afbb264decb0b7e5bd769fa476b27d49621056" translate="yes" xml:space="preserve">
          <source>We will deal with the domain and window when we get to fitting, for the moment we ignore them and run through the basic algebraic and arithmetic operations.</source>
          <target state="translated">我们在进行拟合的时候会处理域和窗口的问题,目前我们先忽略它们,运行基本的代数和算术运算。</target>
        </trans-unit>
        <trans-unit id="4c1bac40e83eb84eced242b32b6de4090c9d63d5" translate="yes" xml:space="preserve">
          <source>We will investigate and respond to all complaints. The NumPy Code of Conduct Committee and the NumPy Steering Committee (if involved) will protect the identity of the reporter, and treat the content of complaints as confidential (unless the reporter agrees otherwise).</source>
          <target state="translated">我们将对所有投诉进行调查和回应。NumPy行为准则委员会和NumPy指导委员会(如果涉及)将保护举报人的身份,并将投诉内容作为机密处理(除非举报人另行同意)。</target>
        </trans-unit>
        <trans-unit id="a83f39578a9a665e3a205bff08ec0d259c697975" translate="yes" xml:space="preserve">
          <source>We will use NumPy&amp;rsquo;s linear algebra module, &lt;a href=&quot;../reference/routines.linalg#module-numpy.linalg&quot;&gt;&lt;code&gt;numpy.linalg&lt;/code&gt;&lt;/a&gt;, to perform the operations in this tutorial. Most of the linear algebra functions in this module can also be found in &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt;&lt;code&gt;scipy.linalg&lt;/code&gt;&lt;/a&gt;, and users are encouraged to use the &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/index.html#module-scipy&quot;&gt;&lt;code&gt;scipy&lt;/code&gt;&lt;/a&gt; module for real-world applications. However, it is currently not possible to apply linear algebra operations to n-dimensional arrays using the &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt;&lt;code&gt;scipy.linalg&lt;/code&gt;&lt;/a&gt; module. For more information on this, check the &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/tutorial/linalg.html&quot;&gt;scipy.linalg Reference&lt;/a&gt;.</source>
          <target state="translated">我们将使用NumPy的线性代数模块&lt;a href=&quot;../reference/routines.linalg#module-numpy.linalg&quot;&gt; &lt;code&gt;numpy.linalg&lt;/code&gt; &lt;/a&gt;来执行本教程中的操作。该模块中的大多数线性代数函数也可以在&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt; &lt;code&gt;scipy.linalg&lt;/code&gt; 中&lt;/a&gt;找到，建议用户将&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/index.html#module-scipy&quot;&gt; &lt;code&gt;scipy&lt;/code&gt; &lt;/a&gt;模块用于实际应用。但是，当前无法使用&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt; &lt;code&gt;scipy.linalg&lt;/code&gt; &lt;/a&gt;模块将线性代数运算应用于n维数组。有关此的更多信息，请查看&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/tutorial/linalg.html&quot;&gt;scipy.linalg参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82a72786c4fe5d6bfb5f753a25b0cbc3ef629d6d" translate="yes" xml:space="preserve">
          <source>We wish to mark the fourth entry as invalid. The easiest is to create a masked array:</source>
          <target state="translated">我们希望将第四个条目标记为无效。最简单的方法是创建一个掩码数组。</target>
        </trans-unit>
        <trans-unit id="2678a6cb2f01328bc5e5792424e05e77b5265e7c" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll do a simple outer product, placing the dimensions of the first operand before the dimensions of the second operand. The &lt;code&gt;op_axes&lt;/code&gt; parameter needs one list of axes for each operand, and provides a mapping from the iterator&amp;rsquo;s axes to the axes of the operand.</source>
          <target state="translated">我们将做一个简单的外部乘积，将第一个操作数的尺寸放在第二个操作数的尺寸之前。所述 &lt;code&gt;op_axes&lt;/code&gt; 参数需要轴中的一个列表中的每个操作数，并从迭代器的轴来的操作数的轴提供了一个映射。</target>
        </trans-unit>
        <trans-unit id="ced2186a63444cfbd458cebaed4de6214b500394" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll show how this works by creating a function &lt;a href=&quot;generated/numpy.square#numpy.square&quot;&gt;&lt;code&gt;square&lt;/code&gt;&lt;/a&gt; which squares its input. Let&amp;rsquo;s start with a minimal function definition excluding &amp;lsquo;out&amp;rsquo; parameter support.</source>
          <target state="translated">我们将通过创建一个平方其输入的函数&lt;a href=&quot;generated/numpy.square#numpy.square&quot;&gt; &lt;code&gt;square&lt;/code&gt; &lt;/a&gt;来说明其工作原理。让我们从不包含&amp;ldquo; out&amp;rdquo;参数支持的最小功能定义开始。</target>
        </trans-unit>
        <trans-unit id="844ec2b5d0ad65b6ef4bf0acb9f400aab9e00804" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re eager to hear about and fix doc defects. But to attack the biggest problems we end up having to defer or overlook some bug reports. Here are the best defects to go after.</source>
          <target state="translated">我们渴望了解并修复文档缺陷。但是要解决最大的问题，我们最终不得不推迟或忽略一些错误报告。这是最好的缺陷。</target>
        </trans-unit>
        <trans-unit id="0d014927573cadb3b0b374c9809c25adaa8d709f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve seen that 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. The invert or bit-wise NOT of 13 is then:</source>
          <target state="translated">我们已经看到13由 &lt;code&gt;00001101&lt;/code&gt; 表示。那么13的取反或按位非为：</target>
        </trans-unit>
        <trans-unit id="08e02d58d5e7e09402e352c84d20a516011f20f4" translate="yes" xml:space="preserve">
          <source>Website design and development</source>
          <target state="translated">网站设计和开发</target>
        </trans-unit>
        <trans-unit id="9f5117721c82b02552e432ea3720cde40d7059ad" translate="yes" xml:space="preserve">
          <source>Weight function of the Hermite polynomials.</source>
          <target state="translated">赫米特多项式的权重函数。</target>
        </trans-unit>
        <trans-unit id="95800a204e1bbd4903f4870d8343853257206077" translate="yes" xml:space="preserve">
          <source>Weight function of the Hermite_e polynomials.</source>
          <target state="translated">Hermite_e多项式的权重函数。</target>
        </trans-unit>
        <trans-unit id="5f860b19432a865263496fdce430b1e33571bfe5" translate="yes" xml:space="preserve">
          <source>Weight function of the Laguerre polynomials.</source>
          <target state="translated">拉格尔多项式的权重函数。</target>
        </trans-unit>
        <trans-unit id="79be08f88c623301ce3bc873b7c9affda9625a90" translate="yes" xml:space="preserve">
          <source>Weight function of the Legendre polynomials.</source>
          <target state="translated">Legendre多项式的权重函数。</target>
        </trans-unit>
        <trans-unit id="c74e4e7c5caf95682fb65872b5814741f06c7fac" translate="yes" xml:space="preserve">
          <source>Weighted average</source>
          <target state="translated">加权平均数</target>
        </trans-unit>
        <trans-unit id="d8f6b85e664320ad22c47352d13059c9a94e57ff" translate="yes" xml:space="preserve">
          <source>Weighted average.</source>
          <target state="translated">加权平均数:</target>
        </trans-unit>
        <trans-unit id="50616113e0953b16858a840423f52798108ba636" translate="yes" xml:space="preserve">
          <source>Weights to apply to the y-coordinates of the sample points. For gaussian uncertainties, use 1/sigma (not 1/sigma**2).</source>
          <target state="translated">对样本点的y坐标进行加权。对于高斯不确定度,使用1/sigma(不是1/sigma**2)。</target>
        </trans-unit>
        <trans-unit id="5a7070233023bbad210855f921220f6a37969ec7" translate="yes" xml:space="preserve">
          <source>Weights, array of the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">权重，与 &lt;code&gt;x&lt;/code&gt; 形状相同的数组。</target>
        </trans-unit>
        <trans-unit id="946476c654c11a5e92f8b55850bb98a1263ad96b" translate="yes" xml:space="preserve">
          <source>Weights. If not None the contribution of each point &lt;code&gt;(x[i],y[i])&lt;/code&gt; to the fit is weighted by &lt;code&gt;w[i]&lt;/code&gt;. Ideally the weights are chosen so that the errors of the products &lt;code&gt;w[i]*y[i]&lt;/code&gt; all have the same variance. The default value is None.</source>
          <target state="translated">重量。如果不是 &lt;code&gt;(x[i],y[i])&lt;/code&gt; 则用 &lt;code&gt;w[i]&lt;/code&gt; 加权每个点（x [i]，y [i]）对拟合的贡献。理想地，选择权重以使得乘积 &lt;code&gt;w[i]*y[i]&lt;/code&gt; 的误差均具有相同的方差。默认值为&amp;ldquo;无&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="1c25ee55e973a0ac3876804d2f28cc0929f53254" translate="yes" xml:space="preserve">
          <source>Weights. If not None, the contribution of each point &lt;code&gt;(x[i],y[i])&lt;/code&gt; to the fit is weighted by &lt;code&gt;w[i]&lt;/code&gt;. Ideally the weights are chosen so that the errors of the products &lt;code&gt;w[i]*y[i]&lt;/code&gt; all have the same variance. The default value is None.</source>
          <target state="translated">重量。如果不为None，则每个点 &lt;code&gt;(x[i],y[i])&lt;/code&gt; 对拟合的贡献均由 &lt;code&gt;w[i]&lt;/code&gt; 加权。理想地，选择权重以使得乘积 &lt;code&gt;w[i]*y[i]&lt;/code&gt; 的误差均具有相同的方差。默认值为&amp;ldquo;无&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="890907bf4b6e9a3c2721945116f4521c292ba997" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Binomial Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/BinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/BinomialDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein，EricW。&amp;ldquo;二项式分布&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/BinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/BinomialDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="44532eacfd8a477fb8d811692e1a730faf373cda" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Cauchy Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/CauchyDistribution.html&quot;&gt;http://mathworld.wolfram.com/CauchyDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein，EricW。&amp;ldquo;漂亮的分布&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/CauchyDistribution.html&quot;&gt;http://mathworld.wolfram.com/CauchyDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ce6b4d0490f5c6c29f7bd660e93014a010601e88" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Gamma Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/GammaDistribution.html&quot;&gt;http://mathworld.wolfram.com/GammaDistribution.html&lt;/a&gt;</source>
          <target state="translated">韦斯斯坦，埃里克&amp;middot;W。&amp;ldquo;伽玛分布&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/GammaDistribution.html&quot;&gt;http://mathworld.wolfram.com/GammaDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="250b4512032938435df06c099254026086b0b46d" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Hypergeometric Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/HypergeometricDistribution.html&quot;&gt;http://mathworld.wolfram.com/HypergeometricDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein，EricW。&amp;ldquo;超几何分布&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/HypergeometricDistribution.html&quot;&gt;http://mathworld.wolfram.com/HypergeometricDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="403ee22c6c9f5dfb6128b5015952af83dc7fe1f5" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Laplace Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/LaplaceDistribution.html&quot;&gt;http://mathworld.wolfram.com/LaplaceDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein，EricW。&amp;ldquo;拉普拉斯分布&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/LaplaceDistribution.html&quot;&gt;http://mathworld.wolfram.com/LaplaceDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c85ee5175b40c6661962e1c4dcdc7232b8e5568a" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Logistic Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/LogisticDistribution.html&quot;&gt;http://mathworld.wolfram.com/LogisticDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein，EricW。&amp;ldquo;物流配送&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/LogisticDistribution.html&quot;&gt;http://mathworld.wolfram.com/LogisticDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1938577c4f79d7fadb65a22f0b9b9cba0e6904e" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Negative Binomial Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein，EricW。&amp;ldquo;负二项分布&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed9cdcffdd5a34db501b8269560f163da34bcfda" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Noncentral F-Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/NoncentralF-Distribution.html&quot;&gt;http://mathworld.wolfram.com/NoncentralF-Distribution.html&lt;/a&gt;</source>
          <target state="translated">魏斯汀，埃里克&amp;middot;W。&amp;ldquo;非中心F分布&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/NoncentralF-Distribution.html&quot;&gt;http://mathworld.wolfram.com/NoncentralF-Distribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6786c23a16b57cae22a2a2fe8c5eef583bfac0cc" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Poisson Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/PoissonDistribution.html&quot;&gt;http://mathworld.wolfram.com/PoissonDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein，Eric W.&amp;ldquo;泊松分布&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/PoissonDistribution.html&quot;&gt;http://mathworld.wolfram.com/PoissonDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="87ff1415ce102e6420c0e0f61ef322d348a5f507" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Sinc Function.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/SincFunction.html&quot;&gt;http://mathworld.wolfram.com/SincFunction.html&lt;/a&gt;</source>
          <target state="translated">Weisstein，Eric W.&amp;ldquo; Sinc函数&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/SincFunction.html&quot;&gt;http://mathworld.wolfram.com/SincFunction.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d56f530182243e33b481a1e9052be8e6b37f719d" translate="yes" xml:space="preserve">
          <source>Welcome to NumPy!</source>
          <target state="translated">欢迎来到NumPy!</target>
        </trans-unit>
        <trans-unit id="abaf546091bcd48cd855fade4a2162266fa33ab0" translate="yes" xml:space="preserve">
          <source>Welcome to the absolute beginner&amp;rsquo;s guide to NumPy! If you have comments or suggestions, please don&amp;rsquo;t hesitate to reach out!</source>
          <target state="translated">欢迎来到NumPy的绝对入门指南！如果您有任何意见或建议，请随时与我们联系！</target>
        </trans-unit>
        <trans-unit id="97cc607ac7fcfde11c85a5379ce211093f48fda9" translate="yes" xml:space="preserve">
          <source>Welcome! This is the documentation for NumPy 1.19.0, last updated Jun 29, 2020.</source>
          <target state="translated">欢迎!这是NumPy 1.19.0的文档。这是NumPy 1.19.0的文档,最后一次更新是2020年6月29日。</target>
        </trans-unit>
        <trans-unit id="e52f86b6168d7288c28967f3ee6d60f730fcffb9" translate="yes" xml:space="preserve">
          <source>Welcome! This is the documentation for NumPy 1.20.0 , last updated Jan 31, 2021.</source>
          <target state="translated">欢迎!这是NumPy 1.20.0的文档。这是NumPy 1.20.0的文档,最后更新时间为2021年1月31日。</target>
        </trans-unit>
        <trans-unit id="e4a9602b9f7c3767b63b80691e19a57b6adce08c" translate="yes" xml:space="preserve">
          <source>What are masked arrays?</source>
          <target state="translated">什么是屏蔽数组?</target>
        </trans-unit>
        <trans-unit id="3fef717821661f9806ec19067704e1d37a6e1a47" translate="yes" xml:space="preserve">
          <source>What are the least-squares-best &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;y0&lt;/code&gt; in &lt;code&gt;y = y0 + mx&lt;/code&gt; for the following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points and you&amp;rsquo;ll see that it should be y0 = 0, m = 1.) The answer is provided by solving the over-determined matrix equation &lt;code&gt;Ax = b&lt;/code&gt;, where:</source>
          <target state="translated">对于以下数据，{=（0,1），（1,0），（1,2），（2,1）} 在 &lt;code&gt;y = y0 + mx&lt;/code&gt; ，最小二乘最佳 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;y0&lt;/code&gt; 是多少。（绘制点，您将看到它应该为y0 = 0，m =1。）答案是通过求解超定矩阵方程 &lt;code&gt;Ax = b&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="3e9b892da0c44e54a5a3d94ba212b74404ec1950" translate="yes" xml:space="preserve">
          <source>What can be converted to a data-type object is described below:</source>
          <target state="translated">下面介绍可以转换为数据类型对象的内容。</target>
        </trans-unit>
        <trans-unit id="7f1eadc1a60d1383bbd27a5874b7f7b346ec84b4" translate="yes" xml:space="preserve">
          <source>What encoding to use when reading Python 2 strings. Only useful when loading Python 2 generated pickled files in Python 3, which includes npy/npz files containing object arrays. Values other than &amp;lsquo;latin1&amp;rsquo;, &amp;lsquo;ASCII&amp;rsquo;, and &amp;lsquo;bytes&amp;rsquo; are not allowed, as they can corrupt numerical data. Default: &amp;lsquo;ASCII&amp;rsquo;</source>
          <target state="translated">读取Python 2字符串时使用哪种编码。仅当在Python 3中加载Python 2生成的腌制文件时有用，该文件包括包含对象数组的npy / npz文件。不允许使用&amp;ldquo; latin1&amp;rdquo;，&amp;ldquo; ASCII&amp;rdquo;和&amp;ldquo; bytes&amp;rdquo;以外的其他值，因为它们会破坏数字数据。默认值：&amp;ldquo; ASCII&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="a414efd43aeae99e0f66cba2afec4195fe86ff0f" translate="yes" xml:space="preserve">
          <source>What happened.</source>
          <target state="translated">发生了什么事?</target>
        </trans-unit>
        <trans-unit id="cc1dbc2aba98097ae72989d44015108a57b61d35" translate="yes" xml:space="preserve">
          <source>What happens with unexpected inputs like empty arrays or nan/inf values?</source>
          <target state="translated">如果出现意外的输入,如空数组或nan/inf值,会怎样?</target>
        </trans-unit>
        <trans-unit id="b53d35ef01217a62dff0ba25d166a1b1caaa9dc7" translate="yes" xml:space="preserve">
          <source>What if the user specifies certain &lt;strong&gt;baseline features&lt;/strong&gt; during the build but at runtime the machine doesn&amp;rsquo;t support even these features? Will the compiled code be called via one of these definitions, or maybe the compiler itself auto-generated/vectorized certain piece of code based on the provided command line compiler flags?</source>
          <target state="translated">如果用户在构建期间指定了某些&lt;strong&gt;基准功能&lt;/strong&gt;，但是在运行时机器甚至不支持这些功能，该怎么办？是通过这些定义之一调用已编译的代码，还是编译器本身根据提供的命令行编译器标志自动生成/矢量化了某些代码？</target>
        </trans-unit>
        <trans-unit id="d026aa92cb632a0008d65ec665e66cb82db19d44" translate="yes" xml:space="preserve">
          <source>What is NumPy?</source>
          <target state="translated">什么是NumPy?</target>
        </trans-unit>
        <trans-unit id="1e1fa581e9e916507b4446a529a092d8e86437db" translate="yes" xml:space="preserve">
          <source>What is a masked array?</source>
          <target state="translated">什么是掩码数组?</target>
        </trans-unit>
        <trans-unit id="9751e6648cb276739f841dae292a17853fcae611" translate="yes" xml:space="preserve">
          <source>What is an array?</source>
          <target state="translated">什么是数组?</target>
        </trans-unit>
        <trans-unit id="437c59796bebb67cae1bb453196d12e5dabd418f" translate="yes" xml:space="preserve">
          <source>What is compared are values, not types. So an int (1) and an array of length one can evaluate as True:</source>
          <target state="translated">比较的是值,而不是类型。所以一个int(1)和一个长度为1的数组可以评价为True。</target>
        </trans-unit>
        <trans-unit id="0ad7f91a8e7927b564b105b1d3081b63dcc31aef" translate="yes" xml:space="preserve">
          <source>What is described below is a recommended workflow with Git.</source>
          <target state="translated">下面介绍的是Git的推荐工作流程。</target>
        </trans-unit>
        <trans-unit id="b5bea1d13da31e58211ad4c35c1a02b82b3ae53f" translate="yes" xml:space="preserve">
          <source>What is released</source>
          <target state="translated">释放什么</target>
        </trans-unit>
        <trans-unit id="ed5c56f4637ad63b06ae7f91c4fda9c76b610d6b" translate="yes" xml:space="preserve">
          <source>What is tested is whether the input has a non-zero imaginary part, not if the input type is complex.</source>
          <target state="translated">测试的是输入的虚部是否为非零,而不是输入类型是否为复数。</target>
        </trans-unit>
        <trans-unit id="010a5d0834f679e03164332d6d50425424fc97f8" translate="yes" xml:space="preserve">
          <source>What is the amortization schedule for a 1 year loan of $2500 at 8.24% interest per year compounded monthly?</source>
          <target state="translated">贷款1年2500元,年息8.24%,月复利,其摊还期是多少?</target>
        </trans-unit>
        <trans-unit id="59aacf2a72313a7cde0de3da40cb764e30627fa7" translate="yes" xml:space="preserve">
          <source>What is the future value after 10 years of saving $100 now, with an additional monthly savings of $100. Assume the interest rate is 5% (annually) compounded monthly?</source>
          <target state="translated">现在存100元,每月多存100元,10年后的未来价值是多少。假设利率为5%(年),每月复利?</target>
        </trans-unit>
        <trans-unit id="68f86a620521000717f405763a7c2c87aeacd919" translate="yes" xml:space="preserve">
          <source>What is the monthly payment needed to pay off a $200,000 loan in 15 years at an annual interest rate of 7.5%?</source>
          <target state="translated">按年利率7.5%计算,15年内还清20万元贷款需要多少月供?</target>
        </trans-unit>
        <trans-unit id="bd55b3638089456ad2fcd33f8ddb002a9ff2afef" translate="yes" xml:space="preserve">
          <source>What is the present value (e.g., the initial investment) of an investment that needs to total $15692.93 after 10 years of saving $100 every month? Assume the interest rate is 5% (annually) compounded monthly.</source>
          <target state="translated">某项投资10年后,每月存100元,共需15692.93元,现值(如初始投资)是多少?假设利率为5%(年),每月复利。</target>
        </trans-unit>
        <trans-unit id="80bbcabaec75450b003887ef27bbf523c85b5a9f" translate="yes" xml:space="preserve">
          <source>What is the right way to index multi-dimensional arrays? Before you jump to conclusions about the one and true way to index multi-dimensional arrays, it pays to understand why this is a confusing issue. This section will try to explain in detail how numpy indexing works and why we adopt the convention we do for images, and when it may be appropriate to adopt other conventions.</source>
          <target state="translated">多维数组的正确索引方式是什么?在你对多维数组索引的正确方法下结论之前,最好先了解一下为什么这是一个令人困惑的问题。本节将尝试详细解释numpy索引是如何工作的,以及为什么我们对图像采用这种约定,什么时候采用其他约定是合适的。</target>
        </trans-unit>
        <trans-unit id="c8f9b6ad9828683b0bae9bbc812741ce15ef2e1e" translate="yes" xml:space="preserve">
          <source>What makes this work so well is that &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; can contain one or a thousand values. They only need to be the same size.</source>
          <target state="translated">使这项工作如此出色的原因是 &lt;code&gt;predictions&lt;/code&gt; 和 &lt;code&gt;labels&lt;/code&gt; 可以包含一个或一千个值。它们只需要大小相同即可。</target>
        </trans-unit>
        <trans-unit id="e27b294bbb4cb3c1e3ee88822cc65d21f2416881" translate="yes" xml:space="preserve">
          <source>What results is the construction of a new array where each value of the index array selects one row from the array being indexed and the resultant array has the resulting shape (number of index elements, size of row).</source>
          <target state="translated">结果是构造一个新的数组,索引数组的每一个值都从被索引的数组中选择一行,结果数组具有结果的形状(索引元素的数量,行的大小)。</target>
        </trans-unit>
        <trans-unit id="5cc81ce77bcae494adbf2656415c9e36736b6793" translate="yes" xml:space="preserve">
          <source>What we lack are docs with broader scope &amp;ndash; tutorials, how-tos, and explanations. Reporting defects is another way to contribute. We discuss both.</source>
          <target state="translated">我们缺少的是范围更广的文档-教程，操作方法和说明。报告缺陷是另一种贡献方式。我们都讨论。</target>
        </trans-unit>
        <trans-unit id="0bd771107f7afe976fc592b463f0e0c3505ed432" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s New or Different</source>
          <target state="translated">有什么新变化</target>
        </trans-unit>
        <trans-unit id="6137204c31653b349cf3c8ead844b7d64e89eb84" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s needed</source>
          <target state="translated">需要什么</target>
        </trans-unit>
        <trans-unit id="2feeca88895960783f7c2e153b1e528ad57119f7" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s the difference between a Python list and a NumPy array?</source>
          <target state="translated">Python列表和NumPy数组有什么区别？</target>
        </trans-unit>
        <trans-unit id="9f2949fbd884fd2e87977bc6442d7541c249e9bc" translate="yes" xml:space="preserve">
          <source>What’s New or Different</source>
          <target state="translated">什么是新的或不同的</target>
        </trans-unit>
        <trans-unit id="7c1df74199c25c42832661082d6ca6ac9e56b175" translate="yes" xml:space="preserve">
          <source>Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May). Open Document Format for Office Applications (OpenDocument)v1.2, Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version, Pre-Draft 12. Organization for the Advancement of Structured Information Standards (OASIS). Billerica, MA, USA. [ODT Document]. Available: &lt;a href=&quot;http://www.oasis-open.org/committees/documents.php&quot;&gt;http://www.oasis-open.org/committees/documents.php&lt;/a&gt; ?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt</source>
          <target state="translated">惠勒（Wheeler，DA），拉瑟克（E.Rathke）和威尔（R.Weir）（编辑）（2009年5月）。 Office应用程序的开放文档格式（OpenDocument）v1.2，第2部分：重新计算的公式（OpenFormula）格式-带注释的版本，预草案12。结构化信息标准促进组织（OASIS）。美国马萨诸塞州比勒里卡。 [ODT文件]。可用：&lt;a href=&quot;http://www.oasis-open.org/committees/documents.php&quot;&gt;http&lt;/a&gt; : //www.oasis-open.org/committees/documents.php？wg_abbrev = office-formulaOpenDocument-formula-20090508.odt</target>
        </trans-unit>
        <trans-unit id="030c83d2119f52206dbf3733046b420a1749a0e1" translate="yes" xml:space="preserve">
          <source>Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May). Open Document Format for Office Applications (OpenDocument)v1.2, Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version, Pre-Draft 12. Organization for the Advancement of Structured Information Standards (OASIS). Billerica, MA, USA. [ODT Document]. Available: &lt;a href=&quot;http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula&quot;&gt;http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula&lt;/a&gt; OpenDocument-formula-20090508.odt</source>
          <target state="translated">惠勒（Wheeler，DA），拉瑟克（E.Rathke）和威尔（R.Weir）（编辑）（2009年5月）。Office应用程序的开放文档格式（OpenDocument）v1.2，第2部分：重新计算的公式（OpenFormula）格式-带注释的版本，预草案12。结构化信息标准促进组织（OASIS）。美国马萨诸塞州比勒里卡。[ODT文件]。可用：&lt;a href=&quot;http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula&quot;&gt;http&lt;/a&gt; : //www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula OpenDocument-formula-20090508.odt</target>
        </trans-unit>
        <trans-unit id="45e561a630c53e04980638c8d4e86ae0087886be" translate="yes" xml:space="preserve">
          <source>Wheels</source>
          <target state="translated">Wheels</target>
        </trans-unit>
        <trans-unit id="28b30ef805c7fb044e119b47e7ac08078b5b70cf" translate="yes" xml:space="preserve">
          <source>When &amp;lsquo;decimals&amp;rsquo; is negative, it specifies the number of positions to the left of the decimal point. The real and imaginary parts of complex numbers are rounded separately. Nothing is done if the array is not of float type and &amp;lsquo;decimals&amp;rsquo; is greater than or equal to 0.</source>
          <target state="translated">当&amp;ldquo;小数&amp;rdquo;为负数时，它指定小数点左侧的位置数。复数的实部和虚部分别取整。如果数组不是浮点型并且'decimals'大于或等于0，则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="f209cff1399437b00b7cd0ee8730d177efc65293" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; is specified, the typical inner loop construct is as follows.</source>
          <target state="translated">当指定&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; 时&lt;/a&gt;，典型的内部循环结构如下。</target>
        </trans-unit>
        <trans-unit id="e3bd2b595c2ff9c9cbf3b48defe560bc708bb864" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#numpy.ma.MaskedArray.tofile&quot;&gt;&lt;code&gt;tofile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">何时&lt;a href=&quot;#numpy.ma.MaskedArray.tofile&quot;&gt; &lt;code&gt;tofile&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="62e74c933581584a63ff5ff51eb96f98ecf99dc0" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#numpy.ma.masked_array.tofile&quot;&gt;&lt;code&gt;tofile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">何时&lt;a href=&quot;#numpy.ma.masked_array.tofile&quot;&gt; &lt;code&gt;tofile&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d17005044d622bf07127624dd5d1775dbe22cd5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not a valid dtype for a structured array.</source>
          <target state="translated">当&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;不是结构化数组的有效dtype时。</target>
        </trans-unit>
        <trans-unit id="105e60976ea8fbfb90203db8ab4a0a320369170d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;A = rfft(a)&lt;/code&gt; and fs is the sampling frequency, &lt;code&gt;A[0]&lt;/code&gt; contains the zero-frequency term 0*fs, which is real due to Hermitian symmetry.</source>
          <target state="translated">当 &lt;code&gt;A = rfft(a)&lt;/code&gt; 且fs为采样频率时， &lt;code&gt;A[0]&lt;/code&gt; 包含零频率项0 * fs，由于厄米对称性，该频率为实数。</target>
        </trans-unit>
        <trans-unit id="fb065328be54e2c3569cb5f58bbc8287bcb1fb7d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; is called, the array pointed to by base will be updated with the contents of this array.</source>
          <target state="translated">当 &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; 被调用时，该阵列所指向的基将与此数组的内容进行更新。</target>
        </trans-unit>
        <trans-unit id="6087c2287fac970fe48c994c66e9668908c28aae" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a = 1&lt;/code&gt;, the Weibull distribution reduces to the exponential distribution.</source>
          <target state="translated">当 &lt;code&gt;a = 1&lt;/code&gt; ，威布尔分布减小为指数分布。</target>
        </trans-unit>
        <trans-unit id="3234eec63d682a68b39f821bda537d5249018389" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is a 2D array, it is factorized as &lt;code&gt;u @ np.diag(s) @ vh
= (u * s) @ vh&lt;/code&gt;, where &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;vh&lt;/code&gt; are 2D unitary arrays and &lt;code&gt;s&lt;/code&gt; is a 1D array of &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s singular values. When &lt;code&gt;a&lt;/code&gt; is higher-dimensional, SVD is applied in stacked mode as explained below.</source>
          <target state="translated">当 &lt;code&gt;a&lt;/code&gt; 被2D阵列，它被分解为 &lt;code&gt;u @ np.diag(s) @ vh = (u * s) @ vh&lt;/code&gt; ，其中 &lt;code&gt;u&lt;/code&gt; 和 &lt;code&gt;vh&lt;/code&gt; 是2D阵列酉和 &lt;code&gt;s&lt;/code&gt; 是一维数组 &lt;code&gt;a&lt;/code&gt; 的奇异值。当 &lt;code&gt;a&lt;/code&gt; 高维时，如下所述，SVD以堆叠模式应用。</target>
        </trans-unit>
        <trans-unit id="40bcbe29998f385e3a1059191be0f61338a8c763" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is a structured array, this argument specifies which fields to compare first, second, and so on. This list does not need to include all of the fields.</source>
          <target state="translated">当 &lt;code&gt;a&lt;/code&gt; 是结构化数组时，此参数指定要比较的字段第一，第二，依此类推。该列表不需要包括所有字段。</target>
        </trans-unit>
        <trans-unit id="c171b92b4bddf9c8ebd2e75ee317f0b5fe3e94eb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</source>
          <target state="translated">当 &lt;code&gt;a&lt;/code&gt; 是定义了字段的数组时，此参数指定要比较的字段的第一个，第二个等。单个字段可以指定为字符串，并且不需要指定所有字段，但是仍将使用未指定的字段。他们以dtype出现的顺序来打破关系。</target>
        </trans-unit>
        <trans-unit id="78f75090c501ced3a2b9ede8c30345a037a7c202" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need to be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</source>
          <target state="translated">当 &lt;code&gt;a&lt;/code&gt; 是定义了字段的数组时，此参数指定要比较的字段的第一个，第二个等。单个字段可以指定为字符串，并且不需要指定所有字段，但仍将使用未指定的字段他们在dtype中出现的顺序，以打破平局。</target>
        </trans-unit>
        <trans-unit id="2cd3e98c67109375f859806b9beef061a4ef694a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string. Not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</source>
          <target state="translated">当 &lt;code&gt;a&lt;/code&gt; 是定义了字段的数组时，此参数指定要比较第一，第二等的字段。可以将单个字段指定为字符串。并非所有字段都需要指定，但是未指定的字段仍会按照在dtype中出现的顺序使用，以打破联系。</target>
        </trans-unit>
        <trans-unit id="b2ce72a40e12e2d7dda3e8c60930788493a39d27" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. Not all fields need be specified.</source>
          <target state="translated">当 &lt;code&gt;a&lt;/code&gt; 是定义了字段的数组时，此参数指定要比较的字段的第一个，第二个等。并非所有字段都需要指定。</target>
        </trans-unit>
        <trans-unit id="ffd5f3ded394e20ded56e4169ae0a349c97ccd8c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;arange&lt;/code&gt; is used with floating point arguments, it is generally not possible to predict the number of elements obtained, due to the finite floating point precision. For this reason, it is usually better to use the function &lt;code&gt;linspace&lt;/code&gt; that receives as an argument the number of elements that we want, instead of the step:</source>
          <target state="translated">当 &lt;code&gt;arange&lt;/code&gt; 与浮点参数一起使用时，由于有限的浮点精度，通常无法预测获得的元素数量。出于这个原因，通常最好使用函数 &lt;code&gt;linspace&lt;/code&gt; 来接收所需数量的元素作为参数，而不是使用步骤：</target>
        </trans-unit>
        <trans-unit id="d9212747ec3985b5dbc30be906a85b9cd4a58814" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;axes&lt;/code&gt; is integer_like, the sequence for evaluation will be: first the -Nth axis in &lt;code&gt;a&lt;/code&gt; and 0th axis in &lt;code&gt;b&lt;/code&gt;, and the -1th axis in &lt;code&gt;a&lt;/code&gt; and Nth axis in &lt;code&gt;b&lt;/code&gt; last.</source>
          <target state="translated">当 &lt;code&gt;axes&lt;/code&gt; 为integer_like时，求值顺序为：首先是a中的-N轴和 &lt;code&gt;b&lt;/code&gt; 中 &lt;code&gt;a&lt;/code&gt; 第0轴，最后是 &lt;code&gt;b&lt;/code&gt; 中 &lt;code&gt;a&lt;/code&gt; 和N轴中的第-1轴。</target>
        </trans-unit>
        <trans-unit id="a0e5c01c245527cc066079729775f892bf5a93e0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;axis&lt;/code&gt; is specified, &lt;code&gt;values&lt;/code&gt; must have the correct shape.</source>
          <target state="translated">当 &lt;code&gt;axis&lt;/code&gt; 被指定， &lt;code&gt;values&lt;/code&gt; 必须具有正确的形状。</target>
        </trans-unit>
        <trans-unit id="91b3e386bc1245c3b6fdcb369364554e159e0d4a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;callstatement&lt;/code&gt; statement is used then F2PY may not generate proper prototypes for Fortran/C functions (because &lt;code&gt;&amp;lt;C-expr&amp;gt;&lt;/code&gt; may contain any function calls and F2PY has no way to determine what should be the proper prototype). With this statement you can explicitly specify the arguments of the corresponding prototype:</source>
          <target state="translated">当使用 &lt;code&gt;callstatement&lt;/code&gt; 语句时，F2PY可能无法为Fortran / C函数生成正确的原型（因为 &lt;code&gt;&amp;lt;C-expr&amp;gt;&lt;/code&gt; 可能包含任何函数调用，并且F2PY无法确定什么是正确的原型）。使用此语句，您可以显式指定相应原型的参数：</target>
        </trans-unit>
        <trans-unit id="3a3f207a74aef7083c1eb02bef5c64216a30b6fc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;condition&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt; contain masked values.</source>
          <target state="translated">当 &lt;code&gt;condition&lt;/code&gt; 或 &lt;code&gt;a&lt;/code&gt; 包含掩蔽值。</target>
        </trans-unit>
        <trans-unit id="f3581744e88f263225956bbed713e5c867c6bf74" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;copy=False&lt;/code&gt; and a copy is made for other reasons, the result is the same as if &lt;code&gt;copy=True&lt;/code&gt;, with some exceptions for &lt;code&gt;A&lt;/code&gt;, see the Notes section. The default order is &amp;lsquo;K&amp;rsquo;.</source>
          <target state="translated">如果 &lt;code&gt;copy=False&lt;/code&gt; 且由于其他原因进行了复制，则结果与 &lt;code&gt;copy=True&lt;/code&gt; 相同，但 &lt;code&gt;A&lt;/code&gt; 例外，请参见&amp;ldquo;注释&amp;rdquo;部分。默认顺序为&amp;ldquo; K&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2e1ae66e35c85b2fe34abaa8efd6e58beb3b3355" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;df&lt;/code&gt; &amp;lt;= 0 or when an inappropriate &lt;code&gt;size&lt;/code&gt; (e.g. &lt;code&gt;size=-1&lt;/code&gt;) is given.</source>
          <target state="translated">当 &lt;code&gt;df&lt;/code&gt; &amp;lt;= 0或给出不合适的 &lt;code&gt;size&lt;/code&gt; （例如 &lt;code&gt;size=-1&lt;/code&gt; ）时。</target>
        </trans-unit>
        <trans-unit id="6647686e555ae4abe6c033723e872acfb1bd3153" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;df&lt;/code&gt; independent random variables, each with standard normal distributions (mean 0, variance 1), are squared and summed, the resulting distribution is chi-square (see Notes). This distribution is often used in hypothesis testing.</source>
          <target state="translated">对每个具有标准正态分布（均值0，方差1）的 &lt;code&gt;df&lt;/code&gt; 独立随机变量进行平方和求和时，所得分布为卡方（见注）。此分布通常用于假设检验中。</target>
        </trans-unit>
        <trans-unit id="ef591edbbf8bac21872c8b29394eee7a7391694c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;dtype=None&lt;/code&gt;, the type of each column is determined iteratively from its data. We start by checking whether a string can be converted to a boolean (that is, if the string matches &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; in lower cases); then whether it can be converted to an integer, then to a float, then to a complex and eventually to a string. This behavior may be changed by modifying the default mapper of the &lt;code&gt;StringConverter&lt;/code&gt; class.</source>
          <target state="translated">当 &lt;code&gt;dtype=None&lt;/code&gt; 时，将根据其数据迭代确定每个列的类型。我们首先检查字符串是否可以转换为布尔值（即，如果字符串匹配小写的 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ）；然后是否可以将其转换为整数，然后转换为浮点数，然后转换为复数，最后转换为字符串。通过修改 &lt;code&gt;StringConverter&lt;/code&gt; 类的默认映射器，可以更改此行为。</target>
        </trans-unit>
        <trans-unit id="fd7138161ba09f963f4c9ef09529d5db9dce6e9c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;equal_nan&lt;/code&gt; is True, complex values with nan components are considered equal if either the real &lt;em&gt;or&lt;/em&gt; the imaginary components are nan.</source>
          <target state="translated">当 &lt;code&gt;equal_nan&lt;/code&gt; 为True时，如果实数分量&lt;em&gt;或&lt;/em&gt;虚数分量均为nan，则具有nan分量的复数值被视为相等。</target>
        </trans-unit>
        <trans-unit id="ffb0cfba1c0d31cbfd6e3e6d57d32a4b67d07be0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;high&lt;/code&gt; == &lt;code&gt;low&lt;/code&gt;, values of &lt;code&gt;low&lt;/code&gt; will be returned. If &lt;code&gt;high&lt;/code&gt; &amp;lt; &lt;code&gt;low&lt;/code&gt;, the results are officially undefined and may eventually raise an error, i.e. do not rely on this function to behave when passed arguments satisfying that inequality condition.</source>
          <target state="translated">当 &lt;code&gt;high&lt;/code&gt; == &lt;code&gt;low&lt;/code&gt; ，值 &lt;code&gt;low&lt;/code&gt; 将被退回。如果 &lt;code&gt;high&lt;/code&gt; &amp;lt; &lt;code&gt;low&lt;/code&gt; ，则结果在官方上是不确定的，并且最终可能会引发错误，即，在传递满足该不等式条件的参数时，不要依赖此函数的行为。</target>
        </trans-unit>
        <trans-unit id="3c038afaac1cec1ca1939f072442e623790bdaa5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;high&lt;/code&gt; == &lt;code&gt;low&lt;/code&gt;, values of &lt;code&gt;low&lt;/code&gt; will be returned. If &lt;code&gt;high&lt;/code&gt; &amp;lt; &lt;code&gt;low&lt;/code&gt;, the results are officially undefined and may eventually raise an error, i.e. do not rely on this function to behave when passed arguments satisfying that inequality condition. The &lt;code&gt;high&lt;/code&gt; limit may be included in the returned array of floats due to floating-point rounding in the equation &lt;code&gt;low + (high-low) * random_sample()&lt;/code&gt;. For example:</source>
          <target state="translated">当 &lt;code&gt;high&lt;/code&gt; == &lt;code&gt;low&lt;/code&gt; ，值 &lt;code&gt;low&lt;/code&gt; 将被退回。如果 &lt;code&gt;high&lt;/code&gt; &amp;lt; &lt;code&gt;low&lt;/code&gt; ，结果在官方上是不确定的，并且最终可能会引发错误，即，在传递满足该不等式条件的参数时，不要依赖此函数的行为。该 &lt;code&gt;high&lt;/code&gt; 限值可以包括由于浮点漂浮在方程四舍五入的返回的数组中 &lt;code&gt;low + (high-low) * random_sample()&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="f9aa8b45107567c376fa7741eff97cb12f0255ea" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;normed&lt;/code&gt; is True, then the returned histogram is the sample density, defined such that the sum over bins of the product &lt;code&gt;bin_value * bin_area&lt;/code&gt; is 1.</source>
          <target state="translated">当 &lt;code&gt;normed&lt;/code&gt; 为True时，返回的直方图就是样本密度，定义为使得乘积 &lt;code&gt;bin_value * bin_area&lt;/code&gt; bin上的总和为1。</target>
        </trans-unit>
        <trans-unit id="d3c1a253c347320a48abee4b8144700cbe11dedb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;op[i]&lt;/code&gt; is NULL, the requested data type &lt;code&gt;op_dtypes[i]&lt;/code&gt; may be NULL as well, in which case it is automatically generated from the dtypes of the arrays which are flagged as readable. The rules for generating the dtype are the same is for UFuncs. Of special note is handling of byte order in the selected dtype. If there is exactly one input, the input&amp;rsquo;s dtype is used as is. Otherwise, if more than one input dtypes are combined together, the output will be in native byte order.</source>
          <target state="translated">当 &lt;code&gt;op[i]&lt;/code&gt; 为NULL时，请求的数据类型 &lt;code&gt;op_dtypes[i]&lt;/code&gt; 也可以为NULL，在这种情况下，它是根据标记为可读的数组的dtypes自动生成的。生成dtype的规则与UFunc相同。特别要注意的是在选定的dtype中处理字节顺序。如果只有一个输入，则按原样使用输入的dtype。否则，如果将多个输入dtypes组合在一起，则输出将以本机字节顺序。</target>
        </trans-unit>
        <trans-unit id="8b2b29bdbe08a7c3e8ddf1683de5150728b2dbef" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;order&lt;/code&gt; is &amp;lsquo;A&amp;rsquo;, it will preserve the array&amp;rsquo;s &amp;lsquo;C&amp;rsquo; or &amp;lsquo;F&amp;rsquo; ordering:</source>
          <target state="translated">当 &lt;code&gt;order&lt;/code&gt; 为'A'时，它将保留数组的'C'或'F'顺序：</target>
        </trans-unit>
        <trans-unit id="6b8f346f1161f4e387f8b7fce9c3c4eab735e268" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;order&lt;/code&gt; is &amp;lsquo;K&amp;rsquo;, it will preserve orderings that are neither &amp;lsquo;C&amp;rsquo; nor &amp;lsquo;F&amp;rsquo;, but won&amp;rsquo;t reverse axes:</source>
          <target state="translated">当 &lt;code&gt;order&lt;/code&gt; 为'K'时，它将保留既不是'C'也不是'F'的顺序，但不会反转轴：</target>
        </trans-unit>
        <trans-unit id="08a648e9a0d7c320ff7a951bdd5b53abf89293b1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;p&lt;/code&gt; cannot be converted to a rank-1 array.</source>
          <target state="translated">当 &lt;code&gt;p&lt;/code&gt; 无法转换为等级1数组时。</target>
        </trans-unit>
        <trans-unit id="e45ca1a69513367d482121e776e438a0bc2c1c76" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;path&lt;/code&gt; is an URL, &lt;a href=&quot;#numpy.DataSource.exists&quot;&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/a&gt; will return True if it&amp;rsquo;s either stored locally in the &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; directory, or is a valid remote URL. &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; does not discriminate between the two, the file is accessible if it exists in either location.</source>
          <target state="translated">当 &lt;code&gt;path&lt;/code&gt; 是URL时，如果它是本地存储在&lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt;目录中或是有效的远程URL ，则&lt;a href=&quot;#numpy.DataSource.exists&quot;&gt; &lt;code&gt;exists&lt;/code&gt; &lt;/a&gt;将返回True 。&lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt;不会区分这两者，如果文件在任一位置都可以访问。</target>
        </trans-unit>
        <trans-unit id="25d6d2d2a499c808880c721a0e1b19db64d43932" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;seed&lt;/code&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, a new &lt;code&gt;BitGenerator&lt;/code&gt; and &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; will be instantiated each time. This function does not manage a default global instance.</source>
          <target state="translated">如果省略 &lt;code&gt;seed&lt;/code&gt; 或 &lt;code&gt;None&lt;/code&gt; ，则每次都会实例化一个新的 &lt;code&gt;BitGenerator&lt;/code&gt; 和&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;。此功能不管理默认的全局实例。</target>
        </trans-unit>
        <trans-unit id="11aa8349ecf313cc611177c175cba7ab95aa1209" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;start &amp;lt;= axis&lt;/code&gt;, the axis is rolled back until it lies in this position. When &lt;code&gt;start &amp;gt; axis&lt;/code&gt;, the axis is rolled until it lies before this position. The default, 0, results in a &amp;ldquo;complete&amp;rdquo; roll. The following table describes how negative values of &lt;code&gt;start&lt;/code&gt; are interpreted:</source>
          <target state="translated">当 &lt;code&gt;start &amp;lt;= axis&lt;/code&gt; ，轴将回滚直到它位于此位置。当 &lt;code&gt;start &amp;gt; axis&lt;/code&gt; ，轴将滚动直到其位于该位置之前。默认值为0，将导致&amp;ldquo;完成&amp;rdquo;滚动。下表描述了如何解释 &lt;code&gt;start&lt;/code&gt; 的负值：</target>
        </trans-unit>
        <trans-unit id="548ec80d9148e8694deef2af35ec844cd9f8fe80" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;writemasked&lt;/code&gt; flag is used, and this operand is buffered, this changes how data is copied from the buffer into the array. A masked copying routine is used, which only copies the elements in the buffer for which &lt;code&gt;writemasked&lt;/code&gt; returns true from the corresponding element in the ARRAYMASK operand.</source>
          <target state="translated">当使用 &lt;code&gt;writemasked&lt;/code&gt; 标志并且对该操作数进行缓冲时，这将更改如何将数据从缓冲区复制到数组中。使用屏蔽的复制例程，该例程仅从ARRAYMASK操作数中的对应元素复制缓冲区中的那些元素，对于这些元素， &lt;code&gt;writemasked&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="e06542a52ac6a1f85d560afb9efd573db44bd48f" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, the result order is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;prototype&lt;/em&gt; is a fortran array, &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt; otherwise. When &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, the result order matches that of &lt;em&gt;prototype&lt;/em&gt;, even when the axes of &lt;em&gt;prototype&lt;/em&gt; aren&amp;rsquo;t in C or Fortran order.</source>
          <target state="translated">当&lt;em&gt;order&lt;/em&gt;为&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; 时&lt;/a&gt;，如果&lt;em&gt;原型&lt;/em&gt;为fortran数组，则结果顺序为&lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt;，否则为&lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt;。当&lt;em&gt;顺序&lt;/em&gt;是&lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt;，结果顺序匹配的那个&lt;em&gt;原型&lt;/em&gt;，即使当轴&lt;em&gt;原型&lt;/em&gt;不是C或Fortran的顺序。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e7033d51e081041b1a2d922760ea9482eb361bec" translate="yes" xml:space="preserve">
          <source>When F2PY finds a line with F2PY directive, the directive is first replaced by 5 spaces and then the line is reread.</source>
          <target state="translated">当F2PY发现一行有F2PY指令时,先用5个空格代替指令,然后再重读该行。</target>
        </trans-unit>
        <trans-unit id="ad9397f3e6e3e4c72dcb47695405ed9d0b6444eb" translate="yes" xml:space="preserve">
          <source>When NumPy is built, information about system configuration is recorded, and is made available for extension modules using NumPy&amp;rsquo;s C API. These are mostly defined in &lt;code&gt;numpyconfig.h&lt;/code&gt; (included in &lt;code&gt;ndarrayobject.h&lt;/code&gt;). The public symbols are prefixed by &lt;code&gt;NPY_*&lt;/code&gt;. NumPy also offers some functions for querying information about the platform in use.</source>
          <target state="translated">构建NumPy时，将记录有关系统配置的信息，并使用NumPy的C API将其提供给扩展模块。这些大多在 &lt;code&gt;numpyconfig.h&lt;/code&gt; 中定义（包含在 &lt;code&gt;ndarrayobject.h&lt;/code&gt; 中）。公用符号以 &lt;code&gt;NPY_*&lt;/code&gt; 为前缀。 NumPy还提供了一些用于查询有关所使用平台的信息的功能。</target>
        </trans-unit>
        <trans-unit id="f9eebd0d248f1a6803fb5b3cabe894035e7a712b" translate="yes" xml:space="preserve">
          <source>When True, trailing zeros are removed from the inputs. When False, the inputs are passed through intact.</source>
          <target state="translated">当为 &quot;真 &quot;时,输入的尾部零会被删除。当为 &quot;False &quot;时,输入将完整地通过。</target>
        </trans-unit>
        <trans-unit id="97a14729b31bf94d828802c225db2f870571e19a" translate="yes" xml:space="preserve">
          <source>When a &lt;em&gt;casting&lt;/em&gt; error occurs during assignment (for example updating a numerical array using a sequence of strings), the array being assigned to may end up in an unpredictable partially updated state. However, if any other error (such as an out of bounds index) occurs, the array will remain unchanged.</source>
          <target state="translated">如果在分配过程中发生&lt;em&gt;转换&lt;/em&gt;错误（例如，使用字符串序列更新数字数组），则分配给该数组的结果可能会以不可预测的部分更新状态结束。但是，如果发生任何其他错误（例如越界索引），则数组将保持不变。</target>
        </trans-unit>
        <trans-unit id="e61114b95ee070856965d70e916fd6711963caa8" translate="yes" xml:space="preserve">
          <source>When a NumPy array, that is Fortran contiguous and has a dtype corresponding to presumed Fortran type, is used as an input array argument, then its C pointer is directly passed to Fortran.</source>
          <target state="translated">当一个NumPy数组,是Fortran连续的,并且其dtype对应于假定的Fortran类型,作为输入数组参数时,那么它的C指针就会直接传递给Fortran。</target>
        </trans-unit>
        <trans-unit id="0d0060f5095733a108d2028d216426111947fd92" translate="yes" xml:space="preserve">
          <source>When a broadcasting error occurs, the iterator raises an exception which includes the input shapes to help diagnose the problem.</source>
          <target state="translated">当发生广播错误时,迭代器会引发一个异常,其中包括输入形状以帮助诊断问题。</target>
        </trans-unit>
        <trans-unit id="811ec8a0586d1ac674df53f06017026b62d3d8b5" translate="yes" xml:space="preserve">
          <source>When a member of the Code of Conduct committee becomes aware of a clear and severe breach, they will do the following:</source>
          <target state="translated">当行为守则委员会成员意识到有明显和严重的违反行为时,他们将采取以下行动:</target>
        </trans-unit>
        <trans-unit id="bb6f21e3a640b767ac7aa4f3739c198a4f93da24" translate="yes" xml:space="preserve">
          <source>When a memmap causes a file to be created or extended beyond its current size in the filesystem, the contents of the new part are unspecified. On systems with POSIX filesystem semantics, the extended part will be filled with zero bytes.</source>
          <target state="translated">当memmap导致文件被创建或扩展到文件系统中超过其当前大小时,新部分的内容是未指定的。在具有POSIX文件系统语义的系统中,扩展部分将被零字节填充。</target>
        </trans-unit>
        <trans-unit id="7aea5877fc6d970c99b779ec7ae2a444e7ff36a4" translate="yes" xml:space="preserve">
          <source>When a parameter can only assume one of a fixed set of values, those values can be listed in braces, with the default appearing first:</source>
          <target state="translated">当一个参数只能承担一组固定值中的一个时,这些值可以用括号列出,默认值出现在前面。</target>
        </trans-unit>
        <trans-unit id="9b87e186d194de6f9d4cd9e098a815eab1dbc5b7" translate="yes" xml:space="preserve">
          <source>When a recording filter is added, matching warnings are stored in the &lt;code&gt;log&lt;/code&gt; attribute as well as in the list returned by &lt;code&gt;record&lt;/code&gt;.</source>
          <target state="translated">添加记录过滤器后，匹配的警告将存储在 &lt;code&gt;log&lt;/code&gt; 属性以及 &lt;code&gt;record&lt;/code&gt; 返回的列表中。</target>
        </trans-unit>
        <trans-unit id="d3862b7e9fa0724ebb3b8d0fa3f7b6e962081ab4" translate="yes" xml:space="preserve">
          <source>When a report is sent to the committee they will immediately reply to the reporter to confirm receipt. This reply must be sent within 72 hours, and the group should strive to respond much quicker than that.</source>
          <target state="translated">当报告被送到委员会时,他们将立即回复记者以确认收到。答复必须在72小时内发出,小组应争取在72小时内作出更快的答复。</target>
        </trans-unit>
        <trans-unit id="ba1de10f5ac1f9d67feabe34568ca76340334549" translate="yes" xml:space="preserve">
          <source>When a ufunc is called, many things must be done. The information collected from these setup operations is stored in a loop-object. This loop object is a C-structure (that could become a Python object but is not initialized as such because it is only used internally). This loop object has the layout needed to be used with PyArray_Broadcast so that the broadcasting can be handled in the same way as it is handled in other sections of code.</source>
          <target state="translated">当一个ufunc被调用时,必须做很多事情。从这些设置操作中收集到的信息被存储在一个 loop-对象中。这个循环对象是一个 C-结构 (它可以成为一个 Python 对象,但没有被初始化,因为它只在内部使用)。这个循环对象具有与PyArray_Broadcast一起使用所需的布局,因此可以用处理其他代码部分的方式来处理广播。</target>
        </trans-unit>
        <trans-unit id="bed1032321553c178be0f4aa76322e048587c74c" translate="yes" xml:space="preserve">
          <source>When a view is desired in as many cases as possible, &lt;code&gt;arr.reshape(-1)&lt;/code&gt; may be preferable.</source>
          <target state="translated">在尽可能多的情况下需要查看时， &lt;code&gt;arr.reshape(-1)&lt;/code&gt; 可能是首选。</target>
        </trans-unit>
        <trans-unit id="3d973a2064387ee8231885f5fb66b3c4832468fa" translate="yes" xml:space="preserve">
          <source>When accessing a single entry of a masked array with no named fields, the output is either a scalar (if the corresponding entry of the mask is &lt;code&gt;False&lt;/code&gt;) or the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; (if the corresponding entry of the mask is &lt;code&gt;True&lt;/code&gt;):</source>
          <target state="translated">当访问没有命名字段的被掩码数组的单个条目时，输出要么是标量（如果掩码的相应条目为 &lt;code&gt;False&lt;/code&gt; ），要么是&lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;的特殊值（如果掩码的相应条目为 &lt;code&gt;True&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="06a15d5053f26aa57bf4b46b8d10d7192f9bc439" translate="yes" xml:space="preserve">
          <source>When accessing a slice, the output is a masked array whose &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; attribute is a view of the original data, and whose mask is either &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (if there was no invalid entries in the original array) or a view of the corresponding slice of the original mask. The view is required to ensure propagation of any modification of the mask to the original.</source>
          <target state="translated">访问切片时，输出是被掩码的数组，其&lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt;属性是原始数据的视图，并且其掩码是&lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;（如果原始数组中没有无效的条目）或原始的相应切片的视图面具。需要该视图以确保将蒙版的任何修改传播到原始蒙版。</target>
        </trans-unit>
        <trans-unit id="4d92b7829e88a948fb9eb65ffcf73c11643904a9" translate="yes" xml:space="preserve">
          <source>When added within a context, filters are only added inside the context and will be forgotten when the context is exited.</source>
          <target state="translated">当在上下文中添加时,过滤器只在上下文中添加,退出上下文时将被遗忘。</target>
        </trans-unit>
        <trans-unit id="9541e02340938d50efa6e54249172d0ce37841bb" translate="yes" xml:space="preserve">
          <source>When adding the &amp;lsquo;out&amp;rsquo; parameter, we have to explicitly provide those flags, because if someone passes in an array as &amp;lsquo;out&amp;rsquo;, the iterator will default to &amp;lsquo;readonly&amp;rsquo;, and our inner loop would fail. The reason &amp;lsquo;readonly&amp;rsquo; is the default for input arrays is to prevent confusion about unintentionally triggering a reduction operation. If the default were &amp;lsquo;readwrite&amp;rsquo;, any broadcasting operation would also trigger a reduction, a topic which is covered later in this document.</source>
          <target state="translated">添加'out'参数时，我们必须显式提供这些标志，因为如果有人将数组作为'out'传递，则迭代器将默认为'readonly'，并且我们的内部循环将失败。输入数组的默认值&amp;ldquo;只读&amp;rdquo;的原因是为了避免因意外触发归约操作而引起的混乱。如果默认值为&amp;ldquo; readwrite&amp;rdquo;，则任何广播操作都将触发减少操作，该主题将在本文档后面介绍。</target>
        </trans-unit>
        <trans-unit id="4db060a24fc0c2ce0739cc8fe613a0f3bd607af5" translate="yes" xml:space="preserve">
          <source>When advanced indices are next to each other transposing may be necessary. All necessary transposing is handled by &lt;code&gt;PyArray_MapIterSwapAxes&lt;/code&gt; and has to be handled by the caller unless &lt;code&gt;PyArray_MapIterNew&lt;/code&gt; is asked to allocate the result.</source>
          <target state="translated">当高级索引彼此相邻时，可能需要转置。除非要求 &lt;code&gt;PyArray_MapIterNew&lt;/code&gt; 分配结果，否则所有必需的转置都由 &lt;code&gt;PyArray_MapIterSwapAxes&lt;/code&gt; 处理，并且必须由调用方处理。</target>
        </trans-unit>
        <trans-unit id="d51d0efd85b1005294bf85e6a8973d000ac30965" translate="yes" xml:space="preserve">
          <source>When all weights along axis are zero. See &lt;a href=&quot;numpy.ma.average#numpy.ma.average&quot;&gt;&lt;code&gt;numpy.ma.average&lt;/code&gt;&lt;/a&gt; for a version robust to this type of error.</source>
          <target state="translated">沿轴的所有权重均为零时。请参阅&lt;a href=&quot;numpy.ma.average#numpy.ma.average&quot;&gt; &lt;code&gt;numpy.ma.average&lt;/code&gt; &lt;/a&gt;以获取对此类错误更可靠的版本。</target>
        </trans-unit>
        <trans-unit id="b89455b8b1550525cbe82d65bea2d7c4ae5a2baa" translate="yes" xml:space="preserve">
          <source>When an array, each row is a coordinate in a D-dimensional space - such as &lt;code&gt;histogramdd(np.array([p1, p2, p3]))&lt;/code&gt;.</source>
          <target state="translated">当是数组时，每一行都是D维空间中的坐标-例如 &lt;code&gt;histogramdd(np.array([p1, p2, p3]))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8f93d8039436724f69d84838e7be89d226d23fc" translate="yes" xml:space="preserve">
          <source>When an array, each row is a coordinate in a D-dimensional space - such as &lt;code&gt;histogramgramdd(np.array([p1, p2, p3]))&lt;/code&gt;.</source>
          <target state="translated">当是数组时，每一行都是D维空间中的坐标-例如 &lt;code&gt;histogramgramdd(np.array([p1, p2, p3]))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74f6a2bdb1716e78ebe330a0020c810a9f33a7a2" translate="yes" xml:space="preserve">
          <source>When an array_like, each element is the list of values for single coordinate - such as &lt;code&gt;histogramdd((X, Y, Z))&lt;/code&gt;.</source>
          <target state="translated">当为array_like时，每个元素都是单个坐标的值的列表-例如 &lt;code&gt;histogramdd((X, Y, Z))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82d8732b0393645ea59279b9ddb8a309ed548c77" translate="yes" xml:space="preserve">
          <source>When an array_like, each element is the list of values for single coordinate - such as &lt;code&gt;histogramgramdd((X, Y, Z))&lt;/code&gt;.</source>
          <target state="translated">当为array_like时，每个元素都是单个坐标的值的列表-例如 &lt;code&gt;histogramgramdd((X, Y, Z))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c37c33974afb82f0204264e74c8f9fe0fca4a425" translate="yes" xml:space="preserve">
          <source>When an axis is specified the subarrays indexed by the axis are sorted. This is done by making the specified axis the first dimension of the array (move the axis to the first dimension to keep the order of the other axes) and then flattening the subarrays in C order. The flattened subarrays are then viewed as a structured type with each element given a label, with the effect that we end up with a 1-D array of structured types that can be treated in the same way as any other 1-D array. The result is that the flattened subarrays are sorted in lexicographic order starting with the first element.</source>
          <target state="translated">当指定一个轴时,由该轴索引的子数组将被排序。这是通过将指定的轴作为数组的第一维来完成的(将轴移动到第一维,以保持其他轴的顺序),然后将子数组按C顺序扁平化。然后将扁平化后的子数组看作是一个结构化类型,每个元素都被赋予一个标签,其效果是我们最终得到的是一个结构化类型的一维数组,它可以和其他任何一维数组一样被处理。结果是,扁平化子数组从第一个元素开始按词法顺序排序。</target>
        </trans-unit>
        <trans-unit id="355be91097240a30b4454a31696bf68a0b258227" translate="yes" xml:space="preserve">
          <source>When an axis is specified the subarrays indexed by the axis are sorted. This is done by making the specified axis the first dimension of the array and then flattening the subarrays in C order. The flattened subarrays are then viewed as a structured type with each element given a label, with the effect that we end up with a 1-D array of structured types that can be treated in the same way as any other 1-D array. The result is that the flattened subarrays are sorted in lexicographic order starting with the first element.</source>
          <target state="translated">当指定一个轴时,由轴索引的子数组将被排序。这是通过将指定的轴作为数组的第一维,然后按C顺序对子数组进行扁平化处理来实现的。扁平化后的子数组被看作是一个结构化类型,每个元素都被赋予一个标签,其效果是我们最终得到一个结构化类型的1-D数组,可以用与其他1-D数组相同的方式处理。结果是,扁平化子数组从第一个元素开始按词法顺序排序。</target>
        </trans-unit>
        <trans-unit id="6b69f1e4103645c38ed661fd82fe69ef3f4b8546" translate="yes" xml:space="preserve">
          <source>When an ellipsis (&lt;code&gt;...&lt;/code&gt;) is present but has no size (i.e. replaces zero &lt;code&gt;:&lt;/code&gt;) the result will still always be an array. A view if no advanced index is present, otherwise a copy.</source>
          <target state="translated">当一个省略号（ &lt;code&gt;...&lt;/code&gt; ）存在，但没有大小（即取代零 &lt;code&gt;:&lt;/code&gt; ）的结果仍然将永远是一个数组。如果没有高级索引，则为视图，否则为副本。</target>
        </trans-unit>
        <trans-unit id="a6d6a3b6d360dde7b2d4e12e9485e974a0d7c19d" translate="yes" xml:space="preserve">
          <source>When an extension module is written, compiled, and installed to somewhere in the Python path (sys.path), the code can then be imported into Python as if it were a standard python file. It will contain objects and methods that have been defined and compiled in C code. The basic steps for doing this in Python are well-documented and you can find more information in the documentation for Python itself available online at &lt;a href=&quot;https://www.python.org&quot;&gt;www.python.org&lt;/a&gt; .</source>
          <target state="translated">将扩展模块编写，编译并安装到Python路径（sys.path）中的某个位置后，可以将该代码导入到Python中，就好像它是标准python文件一样。它将包含用C代码定义和编译的对象和方法。在Python中执行此操作的基本步骤已被详细记录，您可以在&lt;a href=&quot;https://www.python.org&quot;&gt;www.python.org上&lt;/a&gt;在线获取有关Python本身的文档中找到更多信息。</target>
        </trans-unit>
        <trans-unit id="3d4c4fe16d2ce5d90f03758ae48eb086b0f73e4f" translate="yes" xml:space="preserve">
          <source>When an input date falls on the weekend or a holiday, &lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt;&lt;code&gt;busday_offset&lt;/code&gt;&lt;/a&gt; first applies a rule to roll the date to a valid business day, then applies the offset. The default rule is &amp;lsquo;raise&amp;rsquo;, which simply raises an exception. The rules most typically used are &amp;lsquo;forward&amp;rsquo; and &amp;lsquo;backward&amp;rsquo;.</source>
          <target state="translated">当输入日期是在周末或假日时，&lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt; &lt;code&gt;busday_offset&lt;/code&gt; &lt;/a&gt;首先应用规则将日期滚动到有效的工作日，然后应用偏移量。默认规则是&amp;ldquo; raise&amp;rdquo;，它只会引发一个异常。最常用的规则是&amp;ldquo;前进&amp;rdquo;和&amp;ldquo;后退&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="64e5ff0649d57b71884c5f5309f3367e78576ca8" translate="yes" xml:space="preserve">
          <source>When applied to masked arrays, this function drops the mask information if the &lt;code&gt;to_begin&lt;/code&gt; and/or &lt;code&gt;to_end&lt;/code&gt; parameters are used.</source>
          <target state="translated">当应用到屏蔽数组时，如果使用 &lt;code&gt;to_begin&lt;/code&gt; 和/或 &lt;code&gt;to_end&lt;/code&gt; 参数，此函数将删除屏蔽信息。</target>
        </trans-unit>
        <trans-unit id="15d1d9494e1bc6589dcc00277cd9b509332d208c" translate="yes" xml:space="preserve">
          <source>When applying the rule would make the code less readable, even for someone who is used to reading code that follows the rules.</source>
          <target state="translated">当应用该规则时,会使代码的可读性降低,即使对于习惯于阅读遵循规则的代码的人来说也是如此。</target>
        </trans-unit>
        <trans-unit id="e3d9940340bbe50ab427886c71fa9ffd19149804" translate="yes" xml:space="preserve">
          <source>When assigning to fields which are subarrays, the assigned value will first be broadcast to the shape of the subarray.</source>
          <target state="translated">当分配给是子数组的字段时,分配的值将首先被广播到子数组的形状。</target>
        </trans-unit>
        <trans-unit id="f9f55c2f275cd5eebce400c5d632f8721b4b827a" translate="yes" xml:space="preserve">
          <source>When axis is not None, this function does the same thing as &amp;ldquo;fancy&amp;rdquo; indexing (indexing arrays using arrays); however, it can be easier to use if you need elements along a given axis. A call such as &lt;code&gt;np.take(arr, indices, axis=3)&lt;/code&gt; is equivalent to &lt;code&gt;arr[:,:,:,indices,...]&lt;/code&gt;.</source>
          <target state="translated">当axis不为None时，此功能与&amp;ldquo;奇特&amp;rdquo;索引（使用数组索引数组）具有相同的作用；但是，如果您需要沿给定轴的元素，则使用起来会更容易。诸如 &lt;code&gt;np.take(arr, indices, axis=3)&lt;/code&gt; 类的调用等效于 &lt;code&gt;arr[:,:,:,indices,...]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98c8d4285d8be1f6c2247d830229aff2863b6c70" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, controls the size of the temporary buffers. Set to 0 for the default value.</source>
          <target state="translated">启用缓冲时,控制临时缓冲区的大小。默认值设置为0。</target>
        </trans-unit>
        <trans-unit id="16e4f331a390aab5d5358796f242e2ca6c555d93" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, this allows the size of the inner loop to grow when buffering isn&amp;rsquo;t necessary. This option is best used if you&amp;rsquo;re doing a straight pass through all the data, rather than anything with small cache-friendly arrays of temporary values for each inner loop.</source>
          <target state="translated">启用缓冲后，如果不需要缓冲，则允许内部循环的大小增加。如果您要直接通过所有数据，而不是每个内部循环都使用小型缓存友好型临时值数组的任何内容，则最好使用此选项。</target>
        </trans-unit>
        <trans-unit id="b51f6738b373830fc8b3cc055c675ac17c018d38" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, this also switches to a special buffering mode which reduces the loop length as necessary to not trample on values being reduced.</source>
          <target state="translated">当启用缓冲时,这也会切换到一个特殊的缓冲模式,根据需要减少循环长度,以免践踏被减少的值。</target>
        </trans-unit>
        <trans-unit id="41819020a24f8ece45999c2f5c36e5cb1be0993f" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, this delays allocation of the buffers until &lt;a href=&quot;#c.NpyIter_Reset&quot;&gt;&lt;code&gt;NpyIter_Reset&lt;/code&gt;&lt;/a&gt; or another reset function is called. This flag exists to avoid wasteful copying of buffer data when making multiple copies of a buffered iterator for multi-threaded iteration.</source>
          <target state="translated">启用缓冲后，这会延迟缓冲区的分配，直到&lt;a href=&quot;#c.NpyIter_Reset&quot;&gt; &lt;code&gt;NpyIter_Reset&lt;/code&gt; &lt;/a&gt;或另一个复位函数为止。存在此标志以避免在为多线程迭代创建缓冲迭代器的多个副本时避免浪费地复制缓冲区数据。</target>
        </trans-unit>
        <trans-unit id="4659cc673583a700172b8a1a2788271c0236c929" translate="yes" xml:space="preserve">
          <source>When building Python packages containing Fortran sources, then one can choose different Fortran compilers by using &lt;code&gt;build_ext&lt;/code&gt; command option &lt;code&gt;--fcompiler=&amp;lt;Vendor&amp;gt;&lt;/code&gt;. Here &lt;code&gt;&amp;lt;Vendor&amp;gt;&lt;/code&gt; can be one of the following names:</source>
          <target state="translated">构建包含Fortran源代码的Python软件包时，可以使用 &lt;code&gt;build_ext&lt;/code&gt; 命令选项 &lt;code&gt;--fcompiler=&amp;lt;Vendor&amp;gt;&lt;/code&gt; 选择不同的Fortran编译器。在这里 &lt;code&gt;&amp;lt;Vendor&amp;gt;&lt;/code&gt; 可以是以下名称之一：</target>
        </trans-unit>
        <trans-unit id="f21f4d61950661d3a1581fb7fc069996b1dddfdd" translate="yes" xml:space="preserve">
          <source>When building an extension module, a combination of the following macros may be required for non-gcc Fortran compilers:</source>
          <target state="translated">在构建扩展模块时,对于非gcc的Fortran编译器,可能需要以下宏的组合。</target>
        </trans-unit>
        <trans-unit id="230c13e7258bcd1f717539097a4dd43ccf64c97d" translate="yes" xml:space="preserve">
          <source>When calculating the power of an experiment (power = probability of rejecting the null hypothesis when a specific alternative is true) the non-central F statistic becomes important. When the null hypothesis is true, the F statistic follows a central F distribution. When the null hypothesis is not true, then it follows a non-central F statistic.</source>
          <target state="translated">在计算实验的功率时(功率=当一个特定的备选方案为真时拒绝零假设的概率),非中心F统计量变得很重要。当零假设为真时,F统计量遵循中心F分布。当零假设不为真时,则遵循非中心F统计量。</target>
        </trans-unit>
        <trans-unit id="5a88371e6c71e0713242640efaf4aa0aa5e85f64" translate="yes" xml:space="preserve">
          <source>When called from the explicit constructor, &lt;code&gt;obj&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;</source>
          <target state="translated">从显式构造函数调用时， &lt;code&gt;obj&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4c4c9c09668cb4fc50a86156b0582de19cfc0aea" translate="yes" xml:space="preserve">
          <source>When called from view casting, &lt;code&gt;obj&lt;/code&gt; can be an instance of any subclass of ndarray, including our own.</source>
          <target state="translated">从视图转换调用 &lt;code&gt;obj&lt;/code&gt; 时,它可以是ndarray的任何子类的实例，包括我们自己的。</target>
        </trans-unit>
        <trans-unit id="bdfd9e1642e1e1ff8048cf3528d0f05bb78c463a" translate="yes" xml:space="preserve">
          <source>When called in new-from-template, &lt;code&gt;obj&lt;/code&gt; is another instance of our own subclass, that we might use to update the new &lt;code&gt;self&lt;/code&gt; instance.</source>
          <target state="translated">当在new-from-template中调用时， &lt;code&gt;obj&lt;/code&gt; 是我们自己的子类的另一个实例，我们可以使用它来更新新的 &lt;code&gt;self&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="67a93e8e91305afaf6fc0532016e5191c667e052" translate="yes" xml:space="preserve">
          <source>When called on a zero-d array or scalar, &lt;code&gt;nonzero(a)&lt;/code&gt; is treated as &lt;code&gt;nonzero(atleast1d(a))&lt;/code&gt;.</source>
          <target state="translated">当一个零d阵列或标量，在称为 &lt;code&gt;nonzero(a)&lt;/code&gt; 被视为 &lt;code&gt;nonzero(atleast1d(a))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="983eb3e7c851b006b5ca4f0291c430972bc7e1fb" translate="yes" xml:space="preserve">
          <source>When called on a zero-d array or scalar, &lt;code&gt;nonzero(a)&lt;/code&gt; is treated as &lt;code&gt;nonzero(atleast_1d(a))&lt;/code&gt;.</source>
          <target state="translated">当一个零d阵列或标量，在称为 &lt;code&gt;nonzero(a)&lt;/code&gt; 被视为 &lt;code&gt;nonzero(atleast_1d(a))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05271cb09f7d75c6bfb61cf24594f89c89131399" translate="yes" xml:space="preserve">
          <source>When called with only scalars, &lt;code&gt;np.block&lt;/code&gt; is equivalent to an ndarray call. So &lt;code&gt;np.block([[1, 2], [3, 4]])&lt;/code&gt; is equivalent to &lt;code&gt;np.array([[1, 2], [3, 4]])&lt;/code&gt;.</source>
          <target state="translated">仅使用标量调用时， &lt;code&gt;np.block&lt;/code&gt; 等效于ndarray调用。因此 &lt;code&gt;np.block([[1, 2], [3, 4]])&lt;/code&gt; 等效于 &lt;code&gt;np.array([[1, 2], [3, 4]])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="067efac39e6f277a074b649718c28575841dd307" translate="yes" xml:space="preserve">
          <source>When can they be useful?</source>
          <target state="translated">什么时候能有用?</target>
        </trans-unit>
        <trans-unit id="eb3fc5492e5904c93f3605a33709fbb0c2bb0c5b" translate="yes" xml:space="preserve">
          <source>When casting from complex to float or int. To avoid this, one should use &lt;code&gt;a.real.astype(t)&lt;/code&gt;.</source>
          <target state="translated">从复数转换为浮点数或整数时。为了避免这种情况，应该使用 &lt;code&gt;a.real.astype(t)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d77d44055e40bb5dab3ddffb7c979aaad7a40365" translate="yes" xml:space="preserve">
          <source>When coding custom algorithms, and sometimes when wrapping existing C libraries, some familiarity with C is required. In particular, when using C memory management (&lt;code&gt;malloc&lt;/code&gt; and friends), it&amp;rsquo;s easy to introduce memory leaks. However, just compiling a Python module renamed to &lt;code&gt;.pyx&lt;/code&gt; can already speed it up, and adding a few type declarations can give dramatic speedups in some code.</source>
          <target state="translated">在编写自定义算法时，有时在包装现有C库时，需要对C有一定的了解。特别是，在使用C内存管理（ &lt;code&gt;malloc&lt;/code&gt; 和friends）时，很容易引入内存泄漏。但是，只需编译一个重命名为 &lt;code&gt;.pyx&lt;/code&gt; 的Python模块就可以加快速度，而添加一些类型声明可以在某些代码中显着提高速度。</target>
        </trans-unit>
        <trans-unit id="7b0aeecc6c945df228976af6d76ace4f58298a37" translate="yes" xml:space="preserve">
          <source>When considering potential Members, the Council will look at candidates with a comprehensive view of their contributions. This will include but is not limited to code, code review, infrastructure work, mailing list and chat participation, community help/building, education and outreach, design work, etc. We are deliberately not setting arbitrary quantitative metrics (like &amp;ldquo;100 commits in this repo&amp;rdquo;) to avoid encouraging behavior that plays to the metrics rather than the project&amp;rsquo;s overall well-being. We want to encourage a diverse array of backgrounds, viewpoints and talents in our team, which is why we explicitly do not define code as the sole metric on which council membership will be evaluated.</source>
          <target state="translated">在考虑潜在会员时，理事会将对候选人进行全面评估。这将包括但不限于代码，代码审查，基础结构工作，邮件列表和聊天参与，社区帮助/建设，教育和推广，设计工作等。我们故意不设置任意的量化指标（例如&amp;ldquo; 100次提交此回购&amp;rdquo;），以避免鼓舞符合指标而不是项目整体福祉的行为。我们希望在团队中鼓励各种各样的背景，观点和才华，这就是为什么我们明确不将代码定义为评估理事会成员资格的唯一指标的原因。</target>
        </trans-unit>
        <trans-unit id="3afb0a37a10edd1baec0a1dc8d2095269323f16d" translate="yes" xml:space="preserve">
          <source>When creating a 0-d array from an array scalar use &lt;code&gt;f-&amp;gt;setitem&lt;/code&gt; instead of the standard copy from an array scalar. Must use if you don&amp;rsquo;t define an array scalar to go along with the data-type.</source>
          <target state="translated">从数组标量创建0维数组时，请使用 &lt;code&gt;f-&amp;gt;setitem&lt;/code&gt; 而不是从数组标量中复制标准副本。如果您没有定义数组标量与数据类型一起使用，则必须使用。</target>
        </trans-unit>
        <trans-unit id="8887c1561ce70af56f037b9ba953356547c232a4" translate="yes" xml:space="preserve">
          <source>When creating a new masked array with a simple, non-structured datatype, the mask is initially set to the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;, that corresponds roughly to the boolean &lt;code&gt;False&lt;/code&gt;. Trying to set an element of &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; will fail with a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception, as a boolean does not support item assignment.</source>
          <target state="translated">当使用简单的&lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;数据类型创建新的掩码数组时，掩码最初设置为特殊值nomask，该值大致对应于布尔 &lt;code&gt;False&lt;/code&gt; 。尝试设置&lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;的元素将失败，并出现&lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;异常，因为布尔值不支持项目分配。</target>
        </trans-unit>
        <trans-unit id="4e6d2af630e30f862a489ba6df45674126eb3cd4" translate="yes" xml:space="preserve">
          <source>When creating an array of datetimes from a string, it is still possible to automatically select the unit from the inputs, by using the datetime type with generic units.</source>
          <target state="translated">当从一个字符串创建一个日期时间数组时,仍然可以通过使用通用单位的日期时间类型,从输入中自动选择单位。</target>
        </trans-unit>
        <trans-unit id="ac49ba1355f1db42e6af84f03eb57484c54f1f5d" translate="yes" xml:space="preserve">
          <source>When cross-compiling with numpy distutils, it might be necessary to use modified npy-pkg-config files. Using the default/generated files will link with the host libraries (i.e. libnpymath.a). For cross-compilation you of-course need to link with target libraries, while using the host Python installation.</source>
          <target state="translated">当与 numpy distutils 交叉编译时,可能需要使用修改后的 npy-pkg-config 文件。使用默认/生成的文件将与宿主库 (例如 libnpymath.a)链接。对于交叉编译,您当然需要与目标库链接,同时使用主机的 Python 安装。</target>
        </trans-unit>
        <trans-unit id="8f67c8b0b4f5cc7d1d888ed98b880f842ee42d75" translate="yes" xml:space="preserve">
          <source>When either of the dimensions compared is one, the other is used. In other words, dimensions with size 1 are stretched or &amp;ldquo;copied&amp;rdquo; to match the other.</source>
          <target state="translated">当比较的任何一个尺寸为一个尺寸时，将使用另一个尺寸。换句话说，尺寸为1的尺寸将被拉伸或&amp;ldquo;复制&amp;rdquo;以彼此匹配。</target>
        </trans-unit>
        <trans-unit id="36a5c7d333e9c484967d9590699c121ae8287b5d" translate="yes" xml:space="preserve">
          <source>When either of the elements is masked, the result is masked as well, but the underlying boolean data are still set, with self and other considered equal if both are masked, and unequal otherwise.</source>
          <target state="translated">当其中任何一个元素被遮蔽时,结果也被遮蔽,但底层的布尔数据仍然被设置,如果两个元素都被遮蔽,则self和other视为相等,否则不相等。</target>
        </trans-unit>
        <trans-unit id="2c15c829ea1146c460c63d87fff55a43784eaa99" translate="yes" xml:space="preserve">
          <source>When estimating the standard error of a proportion in a population by using a random sample, the normal distribution works well unless the product p*n &amp;lt;=5, where p = population proportion estimate, and n = number of samples, in which case the binomial distribution is used instead. For example, a sample of 15 people shows 4 who are left handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4, so the binomial distribution should be used in this case.</source>
          <target state="translated">当使用随机样本估算总体中某个比例的标准误时，正态分布很好，除非乘积p * n &amp;lt;= 5，其中p =总体比例估算，n =样本数量，在这种情况下而是使用二项式分布。例如，一个15个人的样本显示了4个左撇子和11个右撇子。那么p = 4/15 = 27％。0.27 * 15 = 4，因此在这种情况下应使用二项式分布。</target>
        </trans-unit>
        <trans-unit id="09930c9cc0372480cd647d7e9b5ec7bd58cefab8" translate="yes" xml:space="preserve">
          <source>When fewer indices are provided than the number of axes, the missing indices are considered complete slices&lt;code&gt;:&lt;/code&gt;</source>
          <target state="translated">如果提供的索引数少于轴数，则缺失的索引被视为完整切片 &lt;code&gt;:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b79bfc37b770b9a9d472063cecf571e647616c67" translate="yes" xml:space="preserve">
          <source>When fid is a file object, array contents are directly written to the file, bypassing the file object&amp;rsquo;s &lt;code&gt;write&lt;/code&gt; method. As a result, tofile cannot be used with files objects supporting compression (e.g., GzipFile) or file-like objects that do not support &lt;code&gt;fileno()&lt;/code&gt; (e.g., BytesIO).</source>
          <target state="translated">当fid是文件对象时，将数组内容直接写入文件，而绕过文件对象的 &lt;code&gt;write&lt;/code&gt; 方法。结果，tofile不能与支持压缩的文件对象（例如GzipFile）或不支持 &lt;code&gt;fileno()&lt;/code&gt; 的类似文件的对象（例如BytesIO）一起使用。</target>
        </trans-unit>
        <trans-unit id="aefa8c4cd90708b249d563eead9370ff301bdaf2" translate="yes" xml:space="preserve">
          <source>When finished:</source>
          <target state="translated">当完成。</target>
        </trans-unit>
        <trans-unit id="b8650f4614cacd7afc4a45f34e856756be0c8acc" translate="yes" xml:space="preserve">
          <source>When forcing an iteration order, we observed that the external loop option may provide the elements in smaller chunks because the elements can&amp;rsquo;t be visited in the appropriate order with a constant stride. When writing C code, this is generally fine, however in pure Python code this can cause a significant reduction in performance.</source>
          <target state="translated">在强制执行迭代顺序时，我们观察到外部循环选项可能会以较小的块提供元素，因为无法以恒定的步幅按适当的顺序访问元素。在编写C代码时，这通常很好，但是在纯Python代码中，这可能会导致性能显着降低。</target>
        </trans-unit>
        <trans-unit id="70fcc2c9e602ae36838f0ffe9f9889f2373533f4" translate="yes" xml:space="preserve">
          <source>When giving examples, we will use the following conventions:</source>
          <target state="translated">在举例时,我们将使用以下惯例。</target>
        </trans-unit>
        <trans-unit id="f35ea57e8d85acee84ee1ddb5c53faafa07f0d16" translate="yes" xml:space="preserve">
          <source>When it comes to the data science ecosystem, Python and NumPy are built with the user in mind. One of the best examples of this is the built-in access to documentation. Every object contains the reference to a string, which is known as the &lt;strong&gt;docstring&lt;/strong&gt;. In most cases, this docstring contains a quick and concise summary of the object and how to use it. Python has a built-in &lt;code&gt;help()&lt;/code&gt; function that can help you access this information. This means that nearly any time you need more information, you can use &lt;code&gt;help()&lt;/code&gt; to quickly find the information that you need.</source>
          <target state="translated">当涉及到数据科学生态系统时，Python和NumPy是在考虑用户的基础上构建的。最好的例子之一是对文档的内置访问。每个对象都包含对字符串的引用，该引用称为&lt;strong&gt;docstring&lt;/strong&gt;。在大多数情况下，此文档字符串包含该对象及其使用方式的简要概述。Python具有内置的 &lt;code&gt;help()&lt;/code&gt; 函数，可以帮助您访问此信息。这意味着几乎在任何时候您需要更多信息，都可以使用 &lt;code&gt;help()&lt;/code&gt; 快速找到所需的信息。</target>
        </trans-unit>
        <trans-unit id="b9b252a9e3ddb6a4daaa0819da4dce1d5c66c848" translate="yes" xml:space="preserve">
          <source>When matplotlib is imported in the example, the Example code will be wrapped in &lt;code&gt;matplotlib&amp;rsquo;s Sphinx `plot&lt;/code&gt; directive &amp;lt;&lt;a href=&quot;http://matplotlib.org/sampledoc/extensions.html&quot;&gt;http://matplotlib.org/sampledoc/extensions.html&lt;/a&gt;&amp;gt;`_. When matplotlib is not explicitly imported, &lt;code&gt; plot::&lt;/code&gt; can be used directly if &lt;a href=&quot;https://matplotlib.org/api/sphinxext_plot_directive_api.html#module-matplotlib.sphinxext.plot_directive&quot;&gt;&lt;code&gt;matplotlib.sphinxext.plot_directive&lt;/code&gt;&lt;/a&gt; is loaded as a Sphinx extension in &lt;code&gt;conf.py&lt;/code&gt;.</source>
          <target state="translated">在示例中导入matplotlib时，示例代码将包装在 &lt;code&gt;matplotlib&amp;rsquo;s Sphinx `plot&lt;/code&gt; 指令&amp;lt; &lt;a href=&quot;http://matplotlib.org/sampledoc/extensions.html&quot;&gt;http://matplotlib.org/sampledoc/extensions.html&lt;/a&gt; &amp;gt;`_中。当未明确导入matplotlib时，如果将&lt;a href=&quot;https://matplotlib.org/api/sphinxext_plot_directive_api.html#module-matplotlib.sphinxext.plot_directive&quot;&gt; &lt;code&gt;matplotlib.sphinxext.plot_directive&lt;/code&gt; &lt;/a&gt;作为Sphinx扩展名加载到 &lt;code&gt;conf.py&lt;/code&gt; 中，则可以直接使用 &lt;code&gt; plot::&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c71cf348548e71c4885bb0a433c67bf4fdec31b8" translate="yes" xml:space="preserve">
          <source>When merging contributions, a committer is responsible for ensuring that those meet the requirements outlined in the &lt;a href=&quot;index#guidelines&quot;&gt;Development process guidelines&lt;/a&gt; for NumPy. Also, check that new features and backwards compatibility breaks were discussed on the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion mailing list&lt;/a&gt;.</source>
          <target state="translated">合并贡献时，提交者负责确保这些贡献符合NumPy&lt;a href=&quot;index#guidelines&quot;&gt;开发过程指南中&lt;/a&gt;概述的要求。另外，请检查&lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion邮件列表&lt;/a&gt;上是否讨论了新功能和向后兼容性中断。</target>
        </trans-unit>
        <trans-unit id="d35b37d44b28508587e123d157336a91b6e8c01f" translate="yes" xml:space="preserve">
          <source>When multiple arrays are involved in an operation, you may want to use the same broadcasting rules that the math operations (&lt;em&gt;i.e.&lt;/em&gt; the ufuncs) use. This can be done easily using the &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt;. This is the object returned from the Python command numpy.broadcast and it is almost as easy to use from C. The function &lt;a href=&quot;../reference/c-api/array#c.PyArray_MultiIterNew&quot;&gt;&lt;code&gt;PyArray_MultiIterNew&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;...&lt;/code&gt; ) is used (with &lt;code&gt;n&lt;/code&gt; input objects in place of &lt;code&gt;...&lt;/code&gt; ). The input objects can be arrays or anything that can be converted into an array. A pointer to a PyArrayMultiIterObject is returned. Broadcasting has already been accomplished which adjusts the iterators so that all that needs to be done to advance to the next element in each array is for PyArray_ITER_NEXT to be called for each of the inputs. This incrementing is automatically performed by &lt;a href=&quot;../reference/c-api/array#c.PyArray_MultiIter_NEXT&quot;&gt;&lt;code&gt;PyArray_MultiIter_NEXT&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;obj&lt;/code&gt; ) macro (which can handle a multiterator &lt;code&gt;obj&lt;/code&gt; as either a &lt;code&gt;PyArrayMultiObject *&lt;/code&gt; or a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt;). The data from input number &lt;code&gt;i&lt;/code&gt; is available using &lt;a href=&quot;../reference/c-api/array#c.PyArray_MultiIter_DATA&quot;&gt;&lt;code&gt;PyArray_MultiIter_DATA&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;obj&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt; ) and the total (broadcasted) size as &lt;code&gt;PyArray_MultiIter_SIZE&lt;/code&gt; ( &lt;code&gt;obj&lt;/code&gt;). An example of using this feature follows.</source>
          <target state="translated">当一个运算涉及多个数组时，您可能希望使用与数学运算（&lt;em&gt;即&lt;/em&gt;ufuncs）相同的广播规则。使用&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;可以轻松完成此操作。这是从Python命令numpy.broadcast返回的对象，几乎可以从C使用。使用函数&lt;a href=&quot;../reference/c-api/array#c.PyArray_MultiIterNew&quot;&gt; &lt;code&gt;PyArray_MultiIterNew&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;n&lt;/code&gt; ， &lt;code&gt;...&lt;/code&gt; ）（使用 &lt;code&gt;n&lt;/code&gt; 个输入对象代替 &lt;code&gt;...&lt;/code&gt; ）。输入对象可以是数组或可以转换为数组的任何对象。返回指向PyArrayMultiIterObject的指针。广播已经完成，它可以调整迭代器，以便前进到每个数组中的下一个元素所需要做的就是为每个输入调用PyArray_ITER_NEXT。这种增加是由&lt;a href=&quot;../reference/c-api/array#c.PyArray_MultiIter_NEXT&quot;&gt; &lt;code&gt;PyArray_MultiIter_NEXT&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;obj&lt;/code&gt; ）宏自动执行的（它可以将 &lt;code&gt;PyArrayMultiObject *&lt;/code&gt; &lt;code&gt;obj&lt;/code&gt; 作为PyArrayMultiObject *或&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; 来处理&lt;/a&gt;）。输入编号 &lt;code&gt;i&lt;/code&gt; 中的数据可使用&lt;a href=&quot;../reference/c-api/array#c.PyArray_MultiIter_DATA&quot;&gt; &lt;code&gt;PyArray_MultiIter_DATA&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;obj&lt;/code&gt; ， &lt;code&gt;i&lt;/code&gt; ），总（广播的）大小为 &lt;code&gt;PyArray_MultiIter_SIZE&lt;/code&gt; （ &lt;code&gt;obj&lt;/code&gt; ）。以下是使用此功能的示例。</target>
        </trans-unit>
        <trans-unit id="36f72cd33b97d536492271e1edd9154022c923bc" translate="yes" xml:space="preserve">
          <source>When multiple examples are provided, they should be separated by blank lines. Comments explaining the examples should have blank lines both above and below them:</source>
          <target state="translated">当提供多个例子时,应以空行分隔。解释例子的评论应在例子的上方和下方都有空行。</target>
        </trans-unit>
        <trans-unit id="7c4c339ad493bfce465346e967265bb9c039f51a" translate="yes" xml:space="preserve">
          <source>When one of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; is a scalar and the other is array_like, the function checks that each element of the array_like object is equal to the scalar.</source>
          <target state="translated">当 &lt;code&gt;actual&lt;/code&gt; 和 &lt;code&gt;desired&lt;/code&gt; 的一个是标量而另一个是array_like时，该函数将检查array_like对象的每个元素是否等于标量。</target>
        </trans-unit>
        <trans-unit id="2eb53e9a562d149565801498a40e0d889c5c04ae" translate="yes" xml:space="preserve">
          <source>When one of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is a scalar and the other is array_like, the function checks that each element of the array_like object is equal to the scalar.</source>
          <target state="translated">当 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 中的一个是标量，另一个是array_like时，该函数将检查array_like对象的每个元素是否等于标量。</target>
        </trans-unit>
        <trans-unit id="63eda21eb7811aeacc325fcf56f657d21ccc05f4" translate="yes" xml:space="preserve">
          <source>When one or more of the arrays to be concatenated is a MaskedArray, this function will return a MaskedArray object instead of an ndarray, but the input masks are &lt;em&gt;not&lt;/em&gt; preserved. In cases where a MaskedArray is expected as input, use the ma.concatenate function from the masked array module instead.</source>
          <target state="translated">当要串联的一个或多个数组为MaskedArray时，此函数将返回MaskedArray对象而不是ndarray，但&lt;em&gt;不会&lt;/em&gt;保留输入掩码。如果需要使用MaskedArray作为输入，请改用MaskedArray模块中的ma.concatenate函数。</target>
        </trans-unit>
        <trans-unit id="eccfc4e1a7be21e04b2017257495e340f746e64f" translate="yes" xml:space="preserve">
          <source>When only &lt;code&gt;condition&lt;/code&gt; is provided, this function is a shorthand for &lt;code&gt;np.asarray(condition).nonzero()&lt;/code&gt;. Using &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt; directly should be preferred, as it behaves correctly for subclasses. The rest of this documentation covers only the case where all three arguments are provided.</source>
          <target state="translated">仅提供 &lt;code&gt;condition&lt;/code&gt; ，此函数是 &lt;code&gt;np.asarray(condition).nonzero()&lt;/code&gt; 的简写。最好直接使用&lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt;，因为它对于子类的行为正确。本文档的其余部分仅涉及提供所有三个参数的情况。</target>
        </trans-unit>
        <trans-unit id="b8419db09cea322048fba5bff5f136770a8b6713" translate="yes" xml:space="preserve">
          <source>When only &lt;code&gt;condition&lt;/code&gt; is provided, this function is identical to &lt;a href=&quot;numpy.ma.nonzero#numpy.ma.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;. The rest of this documentation covers only the case where all three arguments are provided.</source>
          <target state="translated">仅提供 &lt;code&gt;condition&lt;/code&gt; ，此函数&lt;a href=&quot;numpy.ma.nonzero#numpy.ma.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt;。本文档的其余部分仅涉及提供所有三个参数的情况。</target>
        </trans-unit>
        <trans-unit id="f0ab5d9437775df5178e579cfc66f050d2a606a1" translate="yes" xml:space="preserve">
          <source>When only &lt;code&gt;condition&lt;/code&gt; is provided, this function is identical to &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;. The rest of this documentation covers only the case where all three arguments are provided.</source>
          <target state="translated">仅提供 &lt;code&gt;condition&lt;/code&gt; ，此函数与&lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt;相同。本文档的其余部分仅涉及提供所有三个参数的情况。</target>
        </trans-unit>
        <trans-unit id="a83dea336fc44b86e10fe7d04631005f6869d53b" translate="yes" xml:space="preserve">
          <source>When opening the saved &lt;code&gt;.npz&lt;/code&gt; file with &lt;a href=&quot;numpy.load#numpy.load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; a &lt;code&gt;NpzFile&lt;/code&gt; object is returned. This is a dictionary-like object which can be queried for its list of arrays (with the &lt;code&gt;.files&lt;/code&gt; attribute), and for the arrays themselves.</source>
          <target state="translated">当打开保存 &lt;code&gt;.npz&lt;/code&gt; 与文件&lt;a href=&quot;numpy.load#numpy.load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt;一个 &lt;code&gt;NpzFile&lt;/code&gt; 被返回的对象。这是一个类似于字典的对象，可以查询其数组列表（带有 &lt;code&gt;.files&lt;/code&gt; 属性）以及数组本身。</target>
        </trans-unit>
        <trans-unit id="db678ddd8c249ca5b7124cc39a503e60a8883bd8" translate="yes" xml:space="preserve">
          <source>When operating and manipulating arrays, their data is sometimes copied into a new array and sometimes not. This is often a source of confusion for beginners. There are three cases:</source>
          <target state="translated">在操作和处理数组时,其数据有时会被复制到一个新的数组中,有时不会。这常常是初学者感到困惑的根源。有三种情况。</target>
        </trans-unit>
        <trans-unit id="7826c9c3ec00652f97696ab5820b06d6f4736590" translate="yes" xml:space="preserve">
          <source>When operating on two arrays, NumPy compares their shapes element-wise. It starts with the trailing (i.e. rightmost) dimensions and works its way left. Two dimensions are compatible when</source>
          <target state="translated">当对两个数组进行操作时,NumPy会按元素比较它们的形状。它从尾部(即最右边)的维度开始,然后向左移动。两个维度是兼容的,当</target>
        </trans-unit>
        <trans-unit id="db500670e369fb09767346f1ee93c96337acfc4a" translate="yes" xml:space="preserve">
          <source>When operating on two arrays, NumPy compares their shapes element-wise. It starts with the trailing dimensions and works its way forward. Two dimensions are compatible when</source>
          <target state="translated">当对两个数组进行操作时,NumPy会按元素比较它们的形状。它从尾部的维度开始,然后往前走。两个维度是兼容的,当</target>
        </trans-unit>
        <trans-unit id="991db5cc5ea188509eab7bddbbcf6ec194a1d9e5" translate="yes" xml:space="preserve">
          <source>When operating with arrays of different types, the type of the resulting array corresponds to the more general or precise one (a behavior known as upcasting).</source>
          <target state="translated">当对不同类型的数组进行操作时,产生的数组的类型对应于更通用或更精确的数组(这种行为被称为upcasting)。</target>
        </trans-unit>
        <trans-unit id="26e6b9fa52377f35e02d57b8c33d212f74b50ae3" translate="yes" xml:space="preserve">
          <source>When order is &amp;lsquo;A&amp;rsquo; and &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; is an array in neither &amp;lsquo;C&amp;rsquo; nor &amp;lsquo;F&amp;rsquo; order, and a copy is forced by a change in dtype, then the order of the result is not necessarily &amp;lsquo;C&amp;rsquo; as expected. This is likely a bug.</source>
          <target state="translated">当order为'A'并且&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt;是既不是'C'也不是'F'的数组，并且由于dtype的改变而强制执行复制时，结果的顺序不一定是预期的'C'。这可能是一个错误。</target>
        </trans-unit>
        <trans-unit id="5be535caa0bb6516144fc1de604b8372d3c9991d" translate="yes" xml:space="preserve">
          <source>When payments are due (&amp;lsquo;begin&amp;rsquo; (1) or &amp;lsquo;end&amp;rsquo; (0))</source>
          <target state="translated">付款到期时（&amp;ldquo;开始&amp;rdquo;（1）或&amp;ldquo;结束&amp;rdquo;（0））</target>
        </trans-unit>
        <trans-unit id="9149bcf3649f5259f262c786b3a7a6478a7a8e0f" translate="yes" xml:space="preserve">
          <source>When payments are due (&amp;lsquo;begin&amp;rsquo; (1) or &amp;lsquo;end&amp;rsquo; (0)). Defaults to {&amp;lsquo;end&amp;rsquo;, 0}.</source>
          <target state="translated">付款到期时（&amp;ldquo;开始&amp;rdquo;（1）或&amp;ldquo;结束&amp;rdquo;（0））。默认为{'end'，0}。</target>
        </trans-unit>
        <trans-unit id="6642df63420a359718ac20ea567420cbe3b18377" translate="yes" xml:space="preserve">
          <source>When performance is important for manipulating many business dates with one particular choice of weekmask and holidays, there is an object &lt;a href=&quot;generated/numpy.busdaycalendar#numpy.busdaycalendar&quot;&gt;&lt;code&gt;busdaycalendar&lt;/code&gt;&lt;/a&gt; which stores the data necessary in an optimized form.</source>
          <target state="translated">当性能对于使用多个特殊的选择的工作日和假期来处理许多业务日期很重要时，有一个对象&lt;a href=&quot;generated/numpy.busdaycalendar#numpy.busdaycalendar&quot;&gt; &lt;code&gt;busdaycalendar&lt;/code&gt; &lt;/a&gt;以优化的形式存储必要的数据。</target>
        </trans-unit>
        <trans-unit id="fd00b76d3636aeca15fb36d92b84ae47d7409ff3" translate="yes" xml:space="preserve">
          <source>When positive infinity and negative infinity are present:</source>
          <target state="translated">当正无穷和负无穷出现时。</target>
        </trans-unit>
        <trans-unit id="bfd35400824f4bd78ecd5a9fec6a8610574752f0" translate="yes" xml:space="preserve">
          <source>When referring to an entirely different module:</source>
          <target state="translated">当指的是一个完全不同的模块时。</target>
        </trans-unit>
        <trans-unit id="b81236c338b918002d5b76ae218758bcc0c4f094" translate="yes" xml:space="preserve">
          <source>When referring to functions in the same sub-module, no prefix is needed, and the tree is searched upwards for a match.</source>
          <target state="translated">当引用同一子模块中的函数时,不需要前缀,树会向上搜索匹配。</target>
        </trans-unit>
        <trans-unit id="6cda328920c935f49e7ba607f4bde2c82e352842" translate="yes" xml:space="preserve">
          <source>When reviewing pull requests, please use workflow tracking features on GitHub as appropriate:</source>
          <target state="translated">在审核拉取请求时,请酌情使用GitHub上的工作流跟踪功能。</target>
        </trans-unit>
        <trans-unit id="de7c6f732a621082b328f0e10ba6ebce8f1a6e6b" translate="yes" xml:space="preserve">
          <source>When saving dictionaries, the dictionary keys become filenames inside the ZIP archive. Therefore, keys should be valid filenames. E.g., avoid keys that begin with &lt;code&gt;/&lt;/code&gt; or contain &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">保存字典时，字典键将成为ZIP存档中的文件名。因此，密钥应为有效的文件名。例如，避免以 &lt;code&gt;/&lt;/code&gt; 开头的键或包含 &lt;code&gt;.&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a563656ae79c2922818f2a82bafe22a75de09b5e" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;madvise&lt;/code&gt; NumPy will typically use hugepages for a performance boost. This behaviour can be modified by setting the environment variable:</source>
          <target state="translated">当设置为 &lt;code&gt;madvise&lt;/code&gt; 时, NumPy通常会使用大量页面来提高性能。可以通过设置环境变量来修改此行为：</target>
        </trans-unit>
        <trans-unit id="57212127eb9536990cda5db105b01bdf8367e735" translate="yes" xml:space="preserve">
          <source>When spaces are used as delimiters, or when no delimiter has been given as input, there should not be any missing data between two fields.</source>
          <target state="translated">当使用空格作为定界符时,或者当输入时没有给出定界符时,两个字段之间不应该有任何缺失的数据。</target>
        </trans-unit>
        <trans-unit id="4370d934ab543968b812927b0ca16a2cbda45f5d" translate="yes" xml:space="preserve">
          <source>When specifying a target using &lt;code&gt;-s&lt;/code&gt;, &lt;code&gt;-t&lt;/code&gt;, or &lt;code&gt;--python&lt;/code&gt;, additional arguments may be forwarded to the target embedded by &lt;code&gt;runtests.py&lt;/code&gt; by passing the extra arguments after a bare &lt;code&gt;--&lt;/code&gt;. For example, to run a test method with the &lt;code&gt;--pdb&lt;/code&gt; flag forwarded to the target, run the following:</source>
          <target state="translated">当使用 &lt;code&gt;-s&lt;/code&gt; ， &lt;code&gt;-t&lt;/code&gt; 或 &lt;code&gt;--python&lt;/code&gt; 指定目标时，通过在多余的 &lt;code&gt;--&lt;/code&gt; 后面传递额外的参数，可以将其他参数转发给 &lt;code&gt;runtests.py&lt;/code&gt; 嵌入的目标。例如，要运行将 &lt;code&gt;--pdb&lt;/code&gt; 标志转发到目标的测试方法，请运行以下命令：</target>
        </trans-unit>
        <trans-unit id="de5db3a5e4bce528f298ed2c8c86e1143611c165" translate="yes" xml:space="preserve">
          <source>When storing a multi-byte value in memory as a sequence of bytes, the sequence addresses/sends/stores the least significant byte first (lowest address) and the most significant byte last (highest address). Common in x86 processors.</source>
          <target state="translated">当把一个多字节的值以字节序列的形式存储在内存中时,序列先寻址/发送/存储最不重要的字节(地址最低),最后寻址/发送/存储最重要的字节(地址最高)。在x86处理器中常见。</target>
        </trans-unit>
        <trans-unit id="ea57d2031842d794e355da55aa4d649b5ca424d5" translate="yes" xml:space="preserve">
          <source>When storing a multi-byte value in memory as a sequence of bytes, the sequence addresses/sends/stores the most significant byte first (lowest address) and the least significant byte last (highest address). Common in micro-processors and used for transmission of data over network protocols.</source>
          <target state="translated">当把一个多字节值以字节序列的形式存储在存储器中时,序列先寻址/发送/存储最重要的字节(地址最低),最后寻址/发送/存储最不重要的字节(地址最高)。在微处理器中常见,用于通过网络协议传输数据。</target>
        </trans-unit>
        <trans-unit id="2c6d6090a315dc06167791d55632ca0e61a0eb7f" translate="yes" xml:space="preserve">
          <source>When studying hypothesis tests that assume normality, seeing how the tests perform on data from a Cauchy distribution is a good indicator of their sensitivity to a heavy-tailed distribution, since the Cauchy looks very much like a Gaussian distribution, but with heavier tails.</source>
          <target state="translated">在研究假设正态性的假设检验时,看检验在Cauchy分布的数据上的表现是一个很好的指标,说明它们对重尾分布的敏感性,因为Cauchy看起来很像高斯分布,但尾部更重。</target>
        </trans-unit>
        <trans-unit id="4d6b9c752dcf618e14ab373ad09afb2c5aaf1513" translate="yes" xml:space="preserve">
          <source>When sub-classing &lt;code&gt;ndarray&lt;/code&gt; or creating duck-types that mimic the &lt;code&gt;ndarray&lt;/code&gt; interface, it is your responsibility to decide how aligned your APIs will be with those of numpy. For convenience, many numpy functions that have a corresponding &lt;code&gt;ndarray&lt;/code&gt; method (e.g., &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;mean&lt;/code&gt;, &lt;code&gt;take&lt;/code&gt;, &lt;code&gt;reshape&lt;/code&gt;) work by checking if the first argument to a function has a method of the same name. If it exists, the method is called instead of coercing the arguments to a numpy array.</source>
          <target state="translated">当子类化 &lt;code&gt;ndarray&lt;/code&gt; 或创建模仿 &lt;code&gt;ndarray&lt;/code&gt; 接口的鸭子类型时，您有责任决定API与numpy的对齐方式。为了方便起见，具有相应 &lt;code&gt;ndarray&lt;/code&gt; 方法（例如 &lt;code&gt;sum&lt;/code&gt; ， &lt;code&gt;mean&lt;/code&gt; ， &lt;code&gt;take&lt;/code&gt; ， &lt;code&gt;reshape&lt;/code&gt; ）的许多numpy函数通过检查函数的第一个参数是否具有相同名称的方法来工作。如果存在，则调用该方法，而不是将参数强制为numpy数组。</target>
        </trans-unit>
        <trans-unit id="83471109ed39b7eca8654b0b5b56f710df2f0ed6" translate="yes" xml:space="preserve">
          <source>When success (0 return value) is returned, either out_arr is filled with a non-NULL PyArrayObject and the rest of the parameters are untouched, or out_arr is filled with NULL, and the rest of the parameters are filled.</source>
          <target state="translated">当返回成功(返回值为0)时,要么用一个非NULL的PyArrayObject填充out_arr,其余参数不被触动,要么用NULL填充out_arr,其余参数被填充。</target>
        </trans-unit>
        <trans-unit id="c5848cbfcc751d6fb624a1cce409c076b5cc5302" translate="yes" xml:space="preserve">
          <source>When the &amp;ldquo;external_loop&amp;rdquo; was not used during construction, but is desired, this modifies the iterator to behave as if the flag was specified.</source>
          <target state="translated">如果在构造过程中未使用&amp;ldquo; external_loop&amp;rdquo;，但希望使用&amp;ldquo; external_loop&amp;rdquo;，则它将修改迭代器，使其表现得就像指定了标志。</target>
        </trans-unit>
        <trans-unit id="a1da80e9817b29febb418ac2727dd8feb1e9ca57" translate="yes" xml:space="preserve">
          <source>When the &amp;ldquo;multi_index&amp;rdquo; flag was specified, this removes it, allowing the internal iteration structure to be optimized further.</source>
          <target state="translated">指定&amp;ldquo; multi_index&amp;rdquo;标志后，将其删除，从而可以进一步优化内部迭代结构。</target>
        </trans-unit>
        <trans-unit id="ea45d329df78eba717c22414db760106850fd424" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;axis&lt;/code&gt; keyword is specified an array of appropriate size is returned.</source>
          <target state="translated">当 &lt;code&gt;axis&lt;/code&gt; 指定的关键字被返回适当大小的阵列。</target>
        </trans-unit>
        <trans-unit id="3fdd0f5189c6dc8a23dfca9586f442b975510baf" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;axis&lt;/code&gt; keyword is used an array is returned.</source>
          <target state="translated">使用 &lt;code&gt;axis&lt;/code&gt; 关键字时，将返回一个数组。</target>
        </trans-unit>
        <trans-unit id="53c50ce51f38684cf2835cdea8b4002b8bbf92a8" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;c_index&lt;/code&gt; or &lt;code&gt;f_index&lt;/code&gt; flag was used, this property provides access to the index. Raises a ValueError if accessed and &lt;code&gt;has_index&lt;/code&gt; is False.</source>
          <target state="translated">当使用 &lt;code&gt;c_index&lt;/code&gt; 或 &lt;code&gt;f_index&lt;/code&gt; 标志时，此属性提供对索引的访问。如果已访问且 &lt;code&gt;has_index&lt;/code&gt; 为False，则引发ValueError 。</target>
        </trans-unit>
        <trans-unit id="76706b5098ca6b382b941c090b506c3f0587d432" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;multi_index&lt;/code&gt; flag was used, this property provides access to the index. Raises a ValueError if accessed accessed and &lt;code&gt;has_multi_index&lt;/code&gt; is False.</source>
          <target state="translated">使用 &lt;code&gt;multi_index&lt;/code&gt; 标志时，此属性提供对索引的访问。如果访问已访问且 &lt;code&gt;has_multi_index&lt;/code&gt; 为False，则引发ValueError 。</target>
        </trans-unit>
        <trans-unit id="ac5d59cc3a2303eaecb29429bf707b0c3c3bedde" translate="yes" xml:space="preserve">
          <source>When the DFT is computed for purely real input, the output is Hermitian-symmetric, i.e. the negative frequency terms are just the complex conjugates of the corresponding positive-frequency terms, and the negative-frequency terms are therefore redundant. This function does not compute the negative frequency terms, and the length of the transformed axis of the output is therefore &lt;code&gt;n//2 + 1&lt;/code&gt;.</source>
          <target state="translated">当为纯实数输入计算DFT时，输出是Hermitian对称的，即负频率项只是相应正频率项的复共轭，因此负频率项是多余的。此函数不计算负频率项，因此输出的变换轴的长度为 &lt;code&gt;n//2 + 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b75d1885e8ca13361f9bec6a445a1ba51b9a5271" translate="yes" xml:space="preserve">
          <source>When the committee (or a committee member) receives a report, they will first determine whether the report is about a clear and severe breach (as defined below). If so, immediate action needs to be taken in addition to the regular report handling process.</source>
          <target state="translated">当委员会(或委员会成员)收到报告时,他们将首先确定报告是否涉及明显和严重的违规行为(定义如下)。如果是,除了常规的报告处理程序外,还需要立即采取行动。</target>
        </trans-unit>
        <trans-unit id="d3d4a45bb9288ccb26e83539df4a7489dddcf142" translate="yes" xml:space="preserve">
          <source>When the data type of &lt;code&gt;a&lt;/code&gt; is longdouble or clongdouble, item() returns a scalar array object because there is no available Python scalar that would not lose information. Void arrays return a buffer object for item(), unless fields are defined, in which case a tuple is returned.</source>
          <target state="translated">当的数据类型 &lt;code&gt;a&lt;/code&gt; 是longdouble或clongdouble，项（）返回一个标阵列对象，因为不存在可用的Python标量不会丢失信息。除非定义了字段，否则无效数组将为item（）返回一个缓冲区对象，在这种情况下，将返回一个元组。</target>
        </trans-unit>
        <trans-unit id="6d7c5ae7d2e5fed7aeaee002bc1ee17b1c24ba0a" translate="yes" xml:space="preserve">
          <source>When the dimension of the vector(s) in &lt;code&gt;a&lt;/code&gt; and/or &lt;code&gt;b&lt;/code&gt; does not equal 2 or 3.</source>
          <target state="translated">当 &lt;code&gt;a&lt;/code&gt; 和/或 &lt;code&gt;b&lt;/code&gt; 中的向量的维数不等于2或3。</target>
        </trans-unit>
        <trans-unit id="dd1fba0c6bb426cf1f952081182426781d82c79b" translate="yes" xml:space="preserve">
          <source>When the error handling for a floating-point error (one of &amp;ldquo;divide&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, or &amp;ldquo;invalid&amp;rdquo;) is set to &amp;lsquo;call&amp;rsquo; or &amp;lsquo;log&amp;rsquo;, the function that is called or the log instance that is written to is returned by &lt;a href=&quot;#numpy.geterrcall&quot;&gt;&lt;code&gt;geterrcall&lt;/code&gt;&lt;/a&gt;. This function or log instance has been set with &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当对浮点错误的错误处理（&amp;ldquo;除&amp;rdquo;，&amp;ldquo;上&amp;rdquo;，&amp;ldquo;下&amp;rdquo;或&amp;ldquo;无效&amp;rdquo;之一）设置为&amp;ldquo;调用&amp;rdquo;或&amp;ldquo;日志&amp;rdquo;时，被调用的函数或日志实例写入的内容由&lt;a href=&quot;#numpy.geterrcall&quot;&gt; &lt;code&gt;geterrcall&lt;/code&gt; &lt;/a&gt;返回。此功能或日志实例已使用&lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt;设置。</target>
        </trans-unit>
        <trans-unit id="3a105e739e37e79639871fe00f74a7608f41e18f" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; is used, the code needs to know the parameters for doing the inner loop. These functions provide that information.</source>
          <target state="translated">当使用标志&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; 时&lt;/a&gt;，代码需要知道进行内部循环的参数。这些功能提供了该信息。</target>
        </trans-unit>
        <trans-unit id="a3b33dbd60831369f7fef62a2b038dc2ad278fa8" translate="yes" xml:space="preserve">
          <source>When the flags attribute is retrieved from Python, a special builtin object of this type is constructed. This special type makes it easier to work with the different flags by accessing them as attributes or by accessing them as if the object were a dictionary with the flag names as entries.</source>
          <target state="translated">当从 Python 中获取 flags 属性时,会构造一个特殊的内置对象。这个特殊的类型使我们可以更容易地使用不同的标志,把它们作为属性来访问,或者像访问一个以标志名作为条目的字典一样访问它们。</target>
        </trans-unit>
        <trans-unit id="6997b127e257f2d9de0f0028a03e8903521c7172" translate="yes" xml:space="preserve">
          <source>When the index consists of as many integer arrays as the array being indexed has dimensions, the indexing is straight forward, but different from slicing.</source>
          <target state="translated">当索引由与被索引数组的维数一样多的整数数组组成时,索引是直接的,但与分片不同。</target>
        </trans-unit>
        <trans-unit id="74a8e0eaba5b1fd886e8897754dffe2e69872867" translate="yes" xml:space="preserve">
          <source>When the indexed array &lt;code&gt;a&lt;/code&gt; is multidimensional, a single array of indices refers to the first dimension of &lt;code&gt;a&lt;/code&gt;. The following example shows this behavior by converting an image of labels into a color image using a palette.</source>
          <target state="translated">当索引数组 &lt;code&gt;a&lt;/code&gt; 是多维的，指数的单个阵列指的第一维度 &lt;code&gt;a&lt;/code&gt; 。下面的示例通过使用调色板将标签图像转换为彩色图像来显示此行为。</target>
        </trans-unit>
        <trans-unit id="e3539c51a85d030896869c59fab4a3546a18e92e" translate="yes" xml:space="preserve">
          <source>When the input &lt;code&gt;a&lt;/code&gt; is a time-domain signal and &lt;code&gt;A = fft(a)&lt;/code&gt;, &lt;code&gt;np.abs(A)&lt;/code&gt; is its amplitude spectrum and &lt;code&gt;np.abs(A)**2&lt;/code&gt; is its power spectrum. The phase spectrum is obtained by &lt;code&gt;np.angle(A)&lt;/code&gt;.</source>
          <target state="translated">当输入 &lt;code&gt;a&lt;/code&gt; 是时域信号且 &lt;code&gt;A = fft(a)&lt;/code&gt; ， &lt;code&gt;np.abs(A)&lt;/code&gt; 是其幅度谱， &lt;code&gt;np.abs(A)**2&lt;/code&gt; 是其功率谱。通过 &lt;code&gt;np.angle(A)&lt;/code&gt; 获得相位谱。</target>
        </trans-unit>
        <trans-unit id="1367f160bbb5fedd65e0cbb76f7f60e11a8156e2" translate="yes" xml:space="preserve">
          <source>When the input and output arrays are aligned and of the correct type, but the striding is not uniform (non-contiguous and 2-D or larger), then a second looping structure is employed for the calculation. This approach converts all of the iterators for the input and output arguments to iterate over all but the largest dimension. The inner loop is then handled by the underlying 1-D computational loop. The outer loop is a standard iterator loop on the converted iterators. The hardware error flags are checked after each 1-D loop is completed.</source>
          <target state="translated">当输入和输出数组是对齐的,并且类型正确,但跨度不一致(非连续和2-D或更大)时,则采用第二个循环结构进行计算。这种方法将输入和输出参数的所有迭代器转换为除最大维度外的所有迭代器。内循环则由底层的1-D计算循环来处理。外循环是对转换后的迭代器进行标准迭代循环。在每个1-D循环完成后,都会检查硬件错误标志。</target>
        </trans-unit>
        <trans-unit id="34e3c1c18b6a533eb7d5554f7595a67b84951780" translate="yes" xml:space="preserve">
          <source>When the input is purely real, its transform is Hermitian, i.e., the component at frequency</source>
          <target state="translated">当输入为纯实数时,它的变换是赫米特式的,即频率上的分量为</target>
        </trans-unit>
        <trans-unit id="52b34b95d5e176ad47f62260446b195804a6cada" translate="yes" xml:space="preserve">
          <source>When the length of 1D &lt;code&gt;weights&lt;/code&gt; is not the same as the shape of &lt;code&gt;a&lt;/code&gt; along axis.</source>
          <target state="translated">当1D的长度 &lt;code&gt;weights&lt;/code&gt; 是不一样的形状 &lt;code&gt;a&lt;/code&gt; 沿轴线。</target>
        </trans-unit>
        <trans-unit id="af1eaf8889fe184a62b6fd5a964889299281ae31" translate="yes" xml:space="preserve">
          <source>When the nested list is two levels deep, this allows block matrices to be constructed from their components.</source>
          <target state="translated">当嵌套列表的深度为两层时,可以从它们的组件中构造块矩阵。</target>
        </trans-unit>
        <trans-unit id="e5f5bbbcfb6705ce5d9a02195d69308545da2c5f" translate="yes" xml:space="preserve">
          <source>When the optional keys &lt;em&gt;offsets&lt;/em&gt; and &lt;em&gt;titles&lt;/em&gt; are provided, their values must each be lists of the same length as the &lt;em&gt;names&lt;/em&gt; and &lt;em&gt;formats&lt;/em&gt; lists. The &lt;em&gt;offsets&lt;/em&gt; value is a list of byte offsets (limited to &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt;&lt;code&gt;ctypes.c_int&lt;/code&gt;&lt;/a&gt;) for each field, while the &lt;em&gt;titles&lt;/em&gt; value is a list of titles for each field (&lt;code&gt;None&lt;/code&gt; can be used if no title is desired for that field). The &lt;em&gt;titles&lt;/em&gt; can be any &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;unicode&lt;/code&gt; object and will add another entry to the fields dictionary keyed by the title and referencing the same field tuple which will contain the title as an additional tuple member.</source>
          <target state="translated">提供可选键&lt;em&gt;偏移量&lt;/em&gt;和&lt;em&gt;标题时&lt;/em&gt;，它们的值都必须是与&lt;em&gt;名称&lt;/em&gt;和&lt;em&gt;格式&lt;/em&gt;列表长度相同的列表。该&lt;em&gt;偏移&lt;/em&gt;值是字节偏移（限于列表&lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt; &lt;code&gt;ctypes.c_int&lt;/code&gt; &lt;/a&gt;）对于每个字段，而&lt;em&gt;标题&lt;/em&gt;值是标题的每个字段的列表（ &lt;code&gt;None&lt;/code&gt; 可以如果没有标题期望该字段中使用）。的&lt;em&gt;标题&lt;/em&gt;可以是任何 &lt;code&gt;string&lt;/code&gt; 或 &lt;code&gt;unicode&lt;/code&gt; 的对象，并且将添加另一条目的字段字典由标题键和引用相同的字段的元组，其将包含标题作为附加元组构件。</target>
        </trans-unit>
        <trans-unit id="e15e18cad68d6d45da7080a3afbf8bf6942044ae" translate="yes" xml:space="preserve">
          <source>When the optional keys &lt;em&gt;offsets&lt;/em&gt; and &lt;em&gt;titles&lt;/em&gt; are provided, their values must each be lists of the same length as the &lt;em&gt;names&lt;/em&gt; and &lt;em&gt;formats&lt;/em&gt; lists. The &lt;em&gt;offsets&lt;/em&gt; value is a list of byte offsets (limited to &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt;&lt;code&gt;ctypes.c_int&lt;/code&gt;&lt;/a&gt;) for each field, while the &lt;em&gt;titles&lt;/em&gt; value is a list of titles for each field (&lt;code&gt;None&lt;/code&gt; can be used if no title is desired for that field). The &lt;em&gt;titles&lt;/em&gt; can be any object, but when a &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; object will add another entry to the fields dictionary keyed by the title and referencing the same field tuple which will contain the title as an additional tuple member.</source>
          <target state="translated">提供可选键&lt;em&gt;偏移量&lt;/em&gt;和&lt;em&gt;标题时&lt;/em&gt;，它们的值都必须是与&lt;em&gt;名称&lt;/em&gt;和&lt;em&gt;格式&lt;/em&gt;列表长度相同的列表。该&lt;em&gt;偏移&lt;/em&gt;值是字节偏移（限于列表&lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt; &lt;code&gt;ctypes.c_int&lt;/code&gt; &lt;/a&gt;）对于每个字段，而&lt;em&gt;标题&lt;/em&gt;值是标题的每个字段的列表（ &lt;code&gt;None&lt;/code&gt; 可以如果没有标题期望该字段中使用）。的&lt;em&gt;标题&lt;/em&gt;可以是任何对象，但是当一个&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;对象将添加另一条目的字段字典由标题键和引用相同的字段的元组，其将包含标题作为附加元组构件。</target>
        </trans-unit>
        <trans-unit id="fe8737aa96b92cabf0904a91af144d1939eed308" translate="yes" xml:space="preserve">
          <source>When the optional keys &lt;em&gt;offsets&lt;/em&gt; and &lt;em&gt;titles&lt;/em&gt; are provided, their values must each be lists of the same length as the &lt;em&gt;names&lt;/em&gt; and &lt;em&gt;formats&lt;/em&gt; lists. The &lt;em&gt;offsets&lt;/em&gt; value is a list of byte offsets (limited to &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt;&lt;code&gt;ctypes.c_int&lt;/code&gt;&lt;/a&gt;) for each field, while the &lt;em&gt;titles&lt;/em&gt; value is a list of titles for each field (None can be used if no title is desired for that field). The &lt;em&gt;titles&lt;/em&gt; can be any &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;unicode&lt;/code&gt; object and will add another entry to the fields dictionary keyed by the title and referencing the same field tuple which will contain the title as an additional tuple member.</source>
          <target state="translated">提供可选键&lt;em&gt;偏移量&lt;/em&gt;和&lt;em&gt;标题时&lt;/em&gt;，它们的值都必须是与&lt;em&gt;名称&lt;/em&gt;和&lt;em&gt;格式&lt;/em&gt;列表长度相同的列表。该&lt;em&gt;偏移&lt;/em&gt;值是字节偏移（限于列表&lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt; &lt;code&gt;ctypes.c_int&lt;/code&gt; &lt;/a&gt;）对于每个字段，而&lt;em&gt;标题&lt;/em&gt;值是标题的每个字段的列表（如果没有标题期望该字段被用于无）。的&lt;em&gt;标题&lt;/em&gt;可以是任何 &lt;code&gt;string&lt;/code&gt; 或 &lt;code&gt;unicode&lt;/code&gt; 的对象，并且将添加另一条目的字段字典由标题键和引用相同的字段的元组，其将包含标题作为附加元组构件。</target>
        </trans-unit>
        <trans-unit id="0c89441828aa0daf46fb0989feeaa96e8f46c4c3" translate="yes" xml:space="preserve">
          <source>When the result of an advanced indexing operation has no elements but an individual index is out of bounds, whether or not an &lt;code&gt;IndexError&lt;/code&gt; is raised is undefined (e.g. &lt;code&gt;x[[], [123]]&lt;/code&gt; with &lt;code&gt;123&lt;/code&gt; being out of bounds).</source>
          <target state="translated">如果高级索引操作的结果没有元素，但单个索引超出范围，则不确定是否引发 &lt;code&gt;IndexError&lt;/code&gt; （例如 &lt;code&gt;x[[], [123]]&lt;/code&gt; 其中 &lt;code&gt;123&lt;/code&gt; 超出范围）。</target>
        </trans-unit>
        <trans-unit id="1684797a859b01eb303a68402fabf36c34b7e573" translate="yes" xml:space="preserve">
          <source>When the total size of the array does not change &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;reshape&lt;/code&gt;&lt;/a&gt; should be used. In most other cases either indexing (to reduce the size) or padding (to increase the size) may be a more appropriate solution.</source>
          <target state="translated">当阵列的总大小不变时，应使用&lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;reshape&lt;/code&gt; &lt;/a&gt;。在大多数其他情况下，索引（减小尺寸）或填充（增大尺寸）可能是更合适的解决方案。</target>
        </trans-unit>
        <trans-unit id="a8285d0cb4c35abac624d1adebd2fa89972bd5bd" translate="yes" xml:space="preserve">
          <source>When the variables are named (either by a flexible dtype or with &lt;code&gt;names&lt;/code&gt;), there must not be any header in the file (else a ValueError exception is raised).</source>
          <target state="translated">命名变量时（通过灵活的dtype或使用 &lt;code&gt;names&lt;/code&gt; ），文件中不得包含任何标头（否则将引发ValueError异常）。</target>
        </trans-unit>
        <trans-unit id="cb9d5c54f477f497096e6733fd299984beb835c4" translate="yes" xml:space="preserve">
          <source>When the variables are named (either by a flexible dtype or with &lt;code&gt;names&lt;/code&gt;, there must not be any header in the file (else a ValueError exception is raised).</source>
          <target state="translated">命名变量时（通过灵活的dtype或使用 &lt;code&gt;names&lt;/code&gt; 命名)，文件中不得包含任何标头（否则将引发ValueError异常）。</target>
        </trans-unit>
        <trans-unit id="6e373c4bcfc128e5c3fce3b4068067e3ffa9e6bc" translate="yes" xml:space="preserve">
          <source>When the wheels have all been successfully built and staged, download them from the Anaconda staging directory using the &lt;code&gt;tools/download-wheels.py&lt;/code&gt; script:</source>
          <target state="translated">成功完成所有轮子的组装和登台后，请使用 &lt;code&gt;tools/download-wheels.py&lt;/code&gt; 脚本从Anaconda登台目录下载轮子：</target>
        </trans-unit>
        <trans-unit id="545b6ed903baa5a5144eaa7b81c5d5357b7f3721" translate="yes" xml:space="preserve">
          <source>When the wheels have all been successfully built, download them using the &lt;code&gt;wheel-uploader&lt;/code&gt; in the &lt;code&gt;terryfy&lt;/code&gt; repository. The terryfy repository may be cloned from &lt;a href=&quot;https://github.com/MacPython/terryfy&quot;&gt;https://github.com/MacPython/terryfy&lt;/a&gt; if you don&amp;rsquo;t already have it. The wheels can also be uploaded using the &lt;code&gt;wheel-uploader&lt;/code&gt;, but we prefer to download all the wheels to the &lt;code&gt;../numpy/release/installers&lt;/code&gt; directory and upload later using &lt;code&gt;twine&lt;/code&gt;:</source>
          <target state="translated">当车轮已全部成功构建，使用下载这些 &lt;code&gt;wheel-uploader&lt;/code&gt; 在 &lt;code&gt;terryfy&lt;/code&gt; 库。如果您还没有的话，可以从&lt;a href=&quot;https://github.com/MacPython/terryfy&quot;&gt;https://github.com/MacPython/terryfy&lt;/a&gt;克隆terryfy存储库。也可以使用 &lt;code&gt;wheel-uploader&lt;/code&gt; 上传车轮，但是我们更愿意将所有车轮下载到 &lt;code&gt;../numpy/release/installers&lt;/code&gt; 目录中，并稍后使用 &lt;code&gt;twine&lt;/code&gt; 上传：</target>
        </trans-unit>
        <trans-unit id="1ce6824829e37ca585156c8e8abdeb7e7047b4a6" translate="yes" xml:space="preserve">
          <source>When there is at least one slice (&lt;code&gt;:&lt;/code&gt;), ellipsis (&lt;code&gt;...&lt;/code&gt;) or &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; in the index (or the array has more dimensions than there are advanced indexes), then the behaviour can be more complicated. It is like concatenating the indexing result for each advanced index element</source>
          <target state="translated">当存在至少一个片（ &lt;code&gt;:&lt;/code&gt; ），省略号（ &lt;code&gt;...&lt;/code&gt; ）或&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;在索引（或阵列具有多个尺寸比有先进的索引），则行为可以更复杂。就像将每个高级索引元素的索引结果连接起来一样</target>
        </trans-unit>
        <trans-unit id="7fc05435c156ef19015ca040276948a66576f250" translate="yes" xml:space="preserve">
          <source>When there is more than one axis to sum over - and they are not the last (first) axes of &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) - the argument &lt;code&gt;axes&lt;/code&gt; should consist of two sequences of the same length, with the first axis to sum over given first in both sequences, the second axis second, and so forth.</source>
          <target state="translated">如果有多个轴求和-并且它们不是 &lt;code&gt;a&lt;/code&gt; （ &lt;code&gt;b&lt;/code&gt; ）的最后（第一个）轴，则参数 &lt;code&gt;axes&lt;/code&gt; 应由两个长度相同的序列组成，第一个轴求和于给定的第一个轴两个序列，第二个轴第二个，依此类推。</target>
        </trans-unit>
        <trans-unit id="aca72761c1059e14a576d5243f55b005214eb5e7" translate="yes" xml:space="preserve">
          <source>When there is only one operand, no axes are summed, and no output parameter is provided, a view into the operand is returned instead of a new array. Thus, taking the diagonal as &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; produces a view (changed in version 1.10.0).</source>
          <target state="translated">当只有一个操作数时，没有轴求和，也没有提供输出参数，则返回对该操作数的视图，而不是新的数组。因此，将对角线作为 &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; 会生成一个视图（在版本1.10.0中进行了更改）。</target>
        </trans-unit>
        <trans-unit id="6c0c17ce5d478e05a8554320c78aec93528cb754" translate="yes" xml:space="preserve">
          <source>When true, allow writing to the returned view. The default is false, as this should be used with caution: the returned view contains the same memory location multiple times, so writing to one location will cause others to change.</source>
          <target state="translated">当为真时,允许对返回的视图进行写入。默认值为false,因为应谨慎使用:返回的视图多次包含相同的内存位置,因此对一个位置的写入会导致其他位置发生变化。</target>
        </trans-unit>
        <trans-unit id="d6560fa9a8a1164ba82db1ff6a46fb84089bde5d" translate="yes" xml:space="preserve">
          <source>When true, the resulting &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; can contain Unicode characters, when false only 8-bit characters. If unicode is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;obj&lt;/code&gt; is one of the following:</source>
          <target state="translated">如果为true，则结果字符&lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;可以包含Unicode字符；如果为false，则仅8位字符。如果unicode为 &lt;code&gt;None&lt;/code&gt; 且 &lt;code&gt;obj&lt;/code&gt; 为以下之一：</target>
        </trans-unit>
        <trans-unit id="65b8be94d25ee5071fb62b957f74c26a7a160de6" translate="yes" xml:space="preserve">
          <source>When true, the resulting &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; can contain Unicode characters, when false only 8-bit characters. If unicode is None and &lt;code&gt;obj&lt;/code&gt; is one of the following:</source>
          <target state="translated">如果为true，则结果字符&lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;可以包含Unicode字符；如果为false，则仅包含8位字符。如果unicode为None且 &lt;code&gt;obj&lt;/code&gt; 为以下之一：</target>
        </trans-unit>
        <trans-unit id="eef56b2a721b3cb91ab7c41be9f28e5cebabf16b" translate="yes" xml:space="preserve">
          <source>When true, the resulting &lt;a href=&quot;numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; can contain Unicode characters, when false only 8-bit characters. If unicode is None and &lt;code&gt;obj&lt;/code&gt; is one of the following:</source>
          <target state="translated">如果为true，则结果字符&lt;a href=&quot;numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;可以包含Unicode字符；如果为false，则仅包含8位字符。如果unicode为None且 &lt;code&gt;obj&lt;/code&gt; 为以下之一：</target>
        </trans-unit>
        <trans-unit id="a283e044d3ebfd4430bd993011e5610365921585" translate="yes" xml:space="preserve">
          <source>When true, the resulting &lt;code&gt;chararray&lt;/code&gt; can contain Unicode characters, when false only 8-bit characters. If unicode is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;obj&lt;/code&gt; is one of the following:</source>
          <target state="translated">如果为true，则结果字符 &lt;code&gt;chararray&lt;/code&gt; 可以包含Unicode字符；如果为false，则仅8位字符。如果unicode为 &lt;code&gt;None&lt;/code&gt; 且 &lt;code&gt;obj&lt;/code&gt; 为以下之一：</target>
        </trans-unit>
        <trans-unit id="f2245dda0193d47132d217a15baacd8d95efb40d" translate="yes" xml:space="preserve">
          <source>When true, the resulting &lt;code&gt;chararray&lt;/code&gt; can contain Unicode characters, when false only 8-bit characters. If unicode is None and &lt;code&gt;obj&lt;/code&gt; is one of the following:</source>
          <target state="translated">如果为true，则结果字符 &lt;code&gt;chararray&lt;/code&gt; 可以包含Unicode字符；如果为false，则仅包含8位字符。如果unicode为None且 &lt;code&gt;obj&lt;/code&gt; 为以下之一：</target>
        </trans-unit>
        <trans-unit id="d546b1cbadc8d553f3a2c608a6a9f37844d1cc07" translate="yes" xml:space="preserve">
          <source>When two or more input parameters have exactly the same type, shape and description, they can be combined:</source>
          <target state="translated">当两个或多个输入参数的类型、形状和描述完全相同时,可以将它们组合起来。</target>
        </trans-unit>
        <trans-unit id="ec3e52986ad6366d7a0f302f7264cd3302d4a4d7" translate="yes" xml:space="preserve">
          <source>When used as a command line tool, &lt;code&gt;f2py&lt;/code&gt; has three major modes, distinguished by the usage of &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-h&lt;/code&gt; switches:</source>
          <target state="translated">当用作命令行工具时， &lt;code&gt;f2py&lt;/code&gt; 具有三种主要模式，以 &lt;code&gt;-c&lt;/code&gt; 和 &lt;code&gt;-h&lt;/code&gt; 开关的使用来区分：</target>
        </trans-unit>
        <trans-unit id="78f0324161c5da45717d8c4c5bc86e44423bdd63" translate="yes" xml:space="preserve">
          <source>When used in arrays, this type strips trailing null bytes.</source>
          <target state="translated">当使用在数组中时,这种类型会剥离尾部的空字节。</target>
        </trans-unit>
        <trans-unit id="40f0d662c07cdabfedd3b1f6952fe6f31dfba509" translate="yes" xml:space="preserve">
          <source>When used in arrays, this type strips trailing null codepoints.</source>
          <target state="translated">当使用在数组中时,这个类型会剥离尾部的空代码点。</target>
        </trans-unit>
        <trans-unit id="a2f6bc6ae79777087ef9f135d7de551097f22c0d" translate="yes" xml:space="preserve">
          <source>When used inside &lt;code&gt;&amp;lt;routine signature&amp;gt;&lt;/code&gt;, then given C code will be inserted to the corresponding wrapper function just after declaring variables but before any C statements. So, &lt;code&gt;usercode&lt;/code&gt; follow-up can contain both declarations and C statements.</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;routine signature&amp;gt;&lt;/code&gt; 中使用时，给定的C代码将在声明变量之后但在任何C语句之前插入到相应的包装器函数中。因此， &lt;code&gt;usercode&lt;/code&gt; 后续可以包含声明和C语句。</target>
        </trans-unit>
        <trans-unit id="596f3568b1167a9a713a0235333d3a0c34a92814" translate="yes" xml:space="preserve">
          <source>When used inside &lt;code&gt;python module&lt;/code&gt; block, then given C code will be inserted to generated C/API source just before wrapper function definitions. Here you can define arbitrary C functions to be used in initialization of optional arguments, for example. If &lt;code&gt;usercode&lt;/code&gt; is used twice inside &lt;code&gt;python
module&lt;/code&gt; block then the second multiline block is inserted after the definition of external routines.</source>
          <target state="translated">在 &lt;code&gt;python module&lt;/code&gt; 块中使用时，将在包装函数定义之前将给定的C代码插入到生成的C / API源中。例如，您可以在此处定义用于可选参数初始化的任意C函数。如果在 &lt;code&gt;python module&lt;/code&gt; 块中两次使用了 &lt;code&gt;usercode&lt;/code&gt; ,则在定义外部例程之后插入第二个多行块。</target>
        </trans-unit>
        <trans-unit id="80e1b4b5cbc8b59436318942fdcb6ca6f33e723e" translate="yes" xml:space="preserve">
          <source>When used inside the first &lt;code&gt;interface&lt;/code&gt; block, then given C code will be inserted at the end of the initialization function of the extension module. Here you can modify extension modules dictionary. For example, for defining additional variables etc.</source>
          <target state="translated">在第一个 &lt;code&gt;interface&lt;/code&gt; 块内使用时，将在扩展模块的初始化功能的末尾插入给定的C代码。在这里您可以修改扩展模块字典。例如，用于定义其他变量等。</target>
        </trans-unit>
        <trans-unit id="436bc3d73aa6565d86aefabb54c9292e559b97a5" translate="yes" xml:space="preserve">
          <source>When used interactively with an object, &lt;code&gt;np.info(obj)&lt;/code&gt; is equivalent to &lt;code&gt;help(obj)&lt;/code&gt; on the Python prompt or &lt;code&gt;obj?&lt;/code&gt; on the IPython prompt.</source>
          <target state="translated">与对象交互使用时， &lt;code&gt;np.info(obj)&lt;/code&gt; 等同于Python提示符或 &lt;code&gt;obj?&lt;/code&gt; 上的 &lt;code&gt;help(obj)&lt;/code&gt; 。在IPython提示符下。</target>
        </trans-unit>
        <trans-unit id="59366ede5c94f784128a0963e5498e4128255217" translate="yes" xml:space="preserve">
          <source>When used with arrays as arguments, &lt;a href=&quot;../reference/generated/numpy.r_#numpy.r_&quot;&gt;&lt;code&gt;r_&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.c_#numpy.c_&quot;&gt;&lt;code&gt;c_&lt;/code&gt;&lt;/a&gt; are similar to &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt; in their default behavior, but allow for an optional argument giving the number of the axis along which to concatenate.</source>
          <target state="translated">当与数组一起用作参数时，&lt;a href=&quot;../reference/generated/numpy.r_#numpy.r_&quot;&gt; &lt;code&gt;r_&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../reference/generated/numpy.c_#numpy.c_&quot;&gt; &lt;code&gt;c_&lt;/code&gt; &lt;/a&gt;在默认行为上类似于&lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt; &lt;code&gt;vstack&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt;，但是允许使用可选参数来给出要连接的轴数。</target>
        </trans-unit>
        <trans-unit id="29f0905c43c5dc57dbedbc6c77600c829150dde0" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;http://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; in combination with the numpy conventions, you should use the &lt;code&gt;numpydoc&lt;/code&gt; extension so that your docstrings will be handled correctly. For example, Sphinx will extract the &lt;code&gt;Parameters&lt;/code&gt; section from your docstring and convert it into a field list. Using &lt;code&gt;numpydoc&lt;/code&gt; will also avoid the reStructuredText errors produced by plain Sphinx when it encounters numpy docstring conventions like section headers (e.g. &lt;code&gt;-------------&lt;/code&gt;) that sphinx does not expect to find in docstrings.</source>
          <target state="translated">当将&lt;a href=&quot;http://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt;与numpy约定结合使用时，应使用 &lt;code&gt;numpydoc&lt;/code&gt; 扩展名，以便可以正确处理您的文档字符串。例如，Sphinx将从您的文档字符串中提取&amp;ldquo; &lt;code&gt;Parameters&lt;/code&gt; 部分，并将其转换为字段列表。使用 &lt;code&gt;numpydoc&lt;/code&gt; 还将避免纯Sphinx遇到numpy docstring约定（例如，节头（例如 &lt;code&gt;-------------&lt;/code&gt; ））而遇到的sphinx期望不会在docstring中发现的reStruxdText错误。</target>
        </trans-unit>
        <trans-unit id="4ead31700ab371101b93de0e7731e3c33827c622" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;https://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; in combination with the numpy conventions, you should use the &lt;code&gt;numpydoc&lt;/code&gt; extension so that your docstrings will be handled correctly. For example, Sphinx will extract the &lt;code&gt;Parameters&lt;/code&gt; section from your docstring and convert it into a field list. Using &lt;code&gt;numpydoc&lt;/code&gt; will also avoid the reStructuredText errors produced by plain Sphinx when it encounters numpy docstring conventions like section headers (e.g. &lt;code&gt;-------------&lt;/code&gt;) that sphinx does not expect to find in docstrings.</source>
          <target state="translated">当将&lt;a href=&quot;https://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt;与numpy约定结合使用时，应使用 &lt;code&gt;numpydoc&lt;/code&gt; 扩展名，以便可以正确处理您的文档字符串。例如，Sphinx将从您的文档字符串中提取&amp;ldquo; &lt;code&gt;Parameters&lt;/code&gt; 部分，并将其转换为字段列表。使用 &lt;code&gt;numpydoc&lt;/code&gt; 还将避免纯Sphinx遇到numpy docstring约定（例如，节头（例如 &lt;code&gt;-------------&lt;/code&gt; ））而遇到的sphinx期望不会在docstring中发现的reStruxdText错误。</target>
        </trans-unit>
        <trans-unit id="12d8af6e4436a72ae5774609dfe31b0219205b6b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;distutils&lt;/code&gt;, for example in &lt;code&gt;setup.py&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;distutils&lt;/code&gt; 时，例如在 &lt;code&gt;setup.py&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="a8bcdc54785df618c23c01dc97dc1468fe9c49c4" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;jumped&lt;/code&gt;, one does have to take care not to jump to a stream that was already used. In the above example, one could not later use &lt;code&gt;blocked_rng[0].jumped()&lt;/code&gt; as it would overlap with &lt;code&gt;blocked_rng[1]&lt;/code&gt;. Like with the independent streams, if the main process here wants to split off 10 more streams by jumping, then it needs to start with &lt;code&gt;range(10, 20)&lt;/code&gt;, otherwise it would recreate the same streams. On the other hand, if you carefully construct the streams, then you are guaranteed to have streams that do not overlap.</source>
          <target state="translated">使用 &lt;code&gt;jumped&lt;/code&gt; 时，必须注意不要跳转到已使用的流。在上面的示例中，以后将无法使用 &lt;code&gt;blocked_rng[0].jumped()&lt;/code&gt; 因为它将与 &lt;code&gt;blocked_rng[1]&lt;/code&gt; 重叠。像独立流一样，如果此处的主进程希望通过跳转将更多的流分成10个，则它需要从 &lt;code&gt;range(10, 20)&lt;/code&gt; ，否则它将重新创建相同的流。另一方面，如果您精心构造流，那么可以保证流不会重叠。</target>
        </trans-unit>
        <trans-unit id="724bc629cdbfec6a4e5af9a220d38930424c297d" translate="yes" xml:space="preserve">
          <source>When using a non-integer step, such as 0.1, the results will often not be consistent. It is better to use &lt;a href=&quot;numpy.linspace#numpy.linspace&quot;&gt;&lt;code&gt;numpy.linspace&lt;/code&gt;&lt;/a&gt; for these cases.</source>
          <target state="translated">当使用非整数步骤（例如0.1）时，结果通常将不一致。对于这些情况，最好使用&lt;a href=&quot;numpy.linspace#numpy.linspace&quot;&gt; &lt;code&gt;numpy.linspace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27718ed960a95a721b47ff1931021ed4073bbe48" translate="yes" xml:space="preserve">
          <source>When using a string for &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; it is possible to get multiple results.</source>
          <target state="translated">当使用字符串作为&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt;时，可以获得多个结果。</target>
        </trans-unit>
        <trans-unit id="4483d4c2e345ca8073aa1a9817270cc3cdb40e82" translate="yes" xml:space="preserve">
          <source>When using a subclass (especially one which manipulates its shape), the default &lt;code&gt;ndarray.__setitem__&lt;/code&gt; behaviour will call &lt;code&gt;__getitem__&lt;/code&gt; for &lt;em&gt;basic&lt;/em&gt; indexing but not for &lt;em&gt;advanced&lt;/em&gt; indexing. For such a subclass it may be preferable to call &lt;code&gt;ndarray.__setitem__&lt;/code&gt; with a &lt;em&gt;base class&lt;/em&gt; ndarray view on the data. This &lt;em&gt;must&lt;/em&gt; be done if the subclasses &lt;code&gt;__getitem__&lt;/code&gt; does not return views.</source>
          <target state="translated">当使用一个子类（尤其是其操纵它的形状），默认 &lt;code&gt;ndarray.__setitem__&lt;/code&gt; 行为将调用 &lt;code&gt;__getitem__&lt;/code&gt; 为&lt;em&gt;基础&lt;/em&gt;的索引，但不是&lt;em&gt;先进的&lt;/em&gt;索引。对于此类子类，可能最好在数据上使用&lt;em&gt;基类&lt;/em&gt; ndarray视图调用 &lt;code&gt;ndarray.__setitem__&lt;/code&gt; 。这&lt;em&gt;必须&lt;/em&gt;如果子类来实现 &lt;code&gt;__getitem__&lt;/code&gt; 不返回意见。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc311b69f41b3e0c41508f3b081d2280ad7970ec" translate="yes" xml:space="preserve">
          <source>When using broadcasting with uint64 dtypes, the maximum value (2**64) cannot be represented as a standard integer type. The high array (or low if high is None) must have object dtype, e.g., array([2**64]).</source>
          <target state="translated">当使用带有uint64 dtypes的广播时,最大值(2**64)不能用标准整数类型表示。高数组(如果高数组为None,则低数组)必须有对象dtype,如array([2**64])。</target>
        </trans-unit>
        <trans-unit id="23e3eec66bc7d3437b52c086371fd6ea153ed9c6" translate="yes" xml:space="preserve">
          <source>When using pytest as a target (the default), you can &lt;a href=&quot;https://docs.pytest.org/en/latest/usage.html#specifying-tests-selecting-tests&quot;&gt;match test names using python operators&lt;/a&gt; by passing the &lt;code&gt;-k&lt;/code&gt; argument to pytest:</source>
          <target state="translated">将pytest用作目标时（默认），可以通过将 &lt;code&gt;-k&lt;/code&gt; 参数传递给pytest&lt;a href=&quot;https://docs.pytest.org/en/latest/usage.html#specifying-tests-selecting-tests&quot;&gt;来使用python运算符匹配测试名称&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="c04978427f46ec116ad24550bbf1c67bfbb16f61" translate="yes" xml:space="preserve">
          <source>When using signed integer types the result is the two&amp;rsquo;s complement of the result for the unsigned type:</source>
          <target state="translated">当使用有符号整数类型时，结果是无符号类型结果的二进制补码：</target>
        </trans-unit>
        <trans-unit id="453da0e9bd45f20742c660821d0bef0203dd876c" translate="yes" xml:space="preserve">
          <source>When using the first form of dictionary-based specification, the titles may be supplied as an extra &lt;code&gt;'titles'&lt;/code&gt; key as described above. When using the second (discouraged) dictionary-based specification, the title can be supplied by providing a 3-element tuple &lt;code&gt;(datatype, offset, title)&lt;/code&gt; instead of the usual 2-element tuple:</source>
          <target state="translated">当使用基于字典的规范的第一形式时，标题可以作为额外的 &lt;code&gt;'titles'&lt;/code&gt; 键提供，如上所述。当使用第二个（折损的）基于字典的规范时，可以通过提供3元素元组 &lt;code&gt;(datatype, offset, title)&lt;/code&gt; 代替通常的2元素元组来提供标题：</target>
        </trans-unit>
        <trans-unit id="fefd781e401a9acf4994aa658770a54631a31aac" translate="yes" xml:space="preserve">
          <source>When using the iterator in multi-threaded code or in code not holding the Python GIL, care must be taken to only call functions which are safe in that context. &lt;a href=&quot;#c.NpyIter_Copy&quot;&gt;&lt;code&gt;NpyIter_Copy&lt;/code&gt;&lt;/a&gt; cannot be safely called without the Python GIL, because it increments Python references. The &lt;code&gt;Reset*&lt;/code&gt; and some other functions may be safely called by passing in the &lt;code&gt;errmsg&lt;/code&gt; parameter as non-NULL, so that the functions will pass back errors through it instead of setting a Python exception.</source>
          <target state="translated">在多线程代码或不包含Python GIL的代码中使用迭代器时，必须注意仅调用在该上下文中安全的函数。没有Python GIL不能安全地调用&lt;a href=&quot;#c.NpyIter_Copy&quot;&gt; &lt;code&gt;NpyIter_Copy&lt;/code&gt; &lt;/a&gt;，因为它会增加Python引用。该 &lt;code&gt;Reset*&lt;/code&gt; 和其他一些功能可以通过传递安全地调用 &lt;code&gt;errmsg&lt;/code&gt; 参数非NULL，这样的功能将通过它传回错误，而不是设置一个Python异常。</target>
        </trans-unit>
        <trans-unit id="88e2c9415b727957007e5109caacd82ffe84043d" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;C('hello')&lt;/code&gt;, the &lt;code&gt;__new__&lt;/code&gt; method gets its own class as first argument, and the passed argument, which is the string &lt;code&gt;'hello'&lt;/code&gt;. After python calls &lt;code&gt;__new__&lt;/code&gt;, it usually (see below) calls our &lt;code&gt;__init__&lt;/code&gt; method, with the output of &lt;code&gt;__new__&lt;/code&gt; as the first argument (now a class instance), and the passed arguments following.</source>
          <target state="translated">当我们调用 &lt;code&gt;C('hello')&lt;/code&gt; 时， &lt;code&gt;__new__&lt;/code&gt; 方法将其自身的类作为第一个参数，并将传递的参数作为字符串 &lt;code&gt;'hello'&lt;/code&gt; 。在python调用 &lt;code&gt;__new__&lt;/code&gt; 之后，它通常（如下所示）调用 &lt;code&gt;__init__&lt;/code&gt; 方法，并将 &lt;code&gt;__new__&lt;/code&gt; 的输出作为第一个参数（现在是类实例），并在其后传递参数。</target>
        </trans-unit>
        <trans-unit id="80e0c3e3144afbdbfb1503b2b31fd233cbb9bcb1" translate="yes" xml:space="preserve">
          <source>When we index arrays with arrays of (integer) indices we are providing the list of indices to pick. With boolean indices the approach is different; we explicitly choose which items in the array we want and which ones we don&amp;rsquo;t.</source>
          <target state="translated">当我们使用（整数）索引数组对数组进行索引时，我们将提供要选择的索引列表。使用布尔索引时，方法是不同的。我们显式选择数组中需要哪些项，不需要哪些项。</target>
        </trans-unit>
        <trans-unit id="e0e93c50be29a8db34812f3b063181378aab17d0" translate="yes" xml:space="preserve">
          <source>When working along a given axis, a slice along that axis is returned in &lt;code&gt;output&lt;/code&gt; for each index where &lt;code&gt;condition&lt;/code&gt; evaluates to True. When working on a 1-D array, &lt;a href=&quot;#numpy.compress&quot;&gt;&lt;code&gt;compress&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;a href=&quot;numpy.extract#numpy.extract&quot;&gt;&lt;code&gt;extract&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">沿给定轴工作时，沿着该轴的切片返回在 &lt;code&gt;output&lt;/code&gt; 为每个索引，其中 &lt;code&gt;condition&lt;/code&gt; 评估为真。处理一维数组时，&lt;a href=&quot;#numpy.compress&quot;&gt; &lt;code&gt;compress&lt;/code&gt; &lt;/a&gt;等效于&lt;a href=&quot;numpy.extract#numpy.extract&quot;&gt; &lt;code&gt;extract&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d7c565731670a0f048fc0a67ffb9fb36e062b00" translate="yes" xml:space="preserve">
          <source>When working with more complex dtypes which are composed of other dtypes, such as the struct dtype, creating inner loops that manipulate the dtypes requires carrying along additional data. NumPy supports this idea through a struct &lt;a href=&quot;#c.NpyAuxData&quot;&gt;&lt;code&gt;NpyAuxData&lt;/code&gt;&lt;/a&gt;, mandating a few conventions so that it is possible to do this.</source>
          <target state="translated">当使用由其他dtype（例如struct dtype）组成的更复杂的dtype时，创建操纵dtype的内部循环需要携带附加数据。 NumPy通过结构&lt;a href=&quot;#c.NpyAuxData&quot;&gt; &lt;code&gt;NpyAuxData&lt;/code&gt; &lt;/a&gt;支持该想法，规定了一些约定，以便可以执行此操作。</target>
        </trans-unit>
        <trans-unit id="dccc69e8b88626650c84c98fbaee8d5823372b3a" translate="yes" xml:space="preserve">
          <source>When working with very large arrays on modern Linux kernels, you can experience a significant speedup when &lt;a href=&quot;https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html&quot;&gt;transparent hugepage&lt;/a&gt; is used. The current system policy for transparent hugepages can be seen by:</source>
          <target state="translated">在现代Linux内核上使用非常大的阵列时，使用&lt;a href=&quot;https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html&quot;&gt;透明大页面&lt;/a&gt;时，您可以显着提高速度。当前透明大页面的系统策略可以通过以下方式查看：</target>
        </trans-unit>
        <trans-unit id="37deec6852814cd475cf2ac8609e4771e7e23ff2" translate="yes" xml:space="preserve">
          <source>When you break a long expression at a binary operator, the operator goes at the end of the previous line, e.g.,</source>
          <target state="translated">当你在二进制操作符处断开一个长的表达式时,操作符会在前一行的末尾,例如:。</target>
        </trans-unit>
        <trans-unit id="e44c90082df7337355379f5ec7bbacbbcd47fdf0" translate="yes" xml:space="preserve">
          <source>When you edit dependence relations that were initially generated by F2PY, be careful not to break the dependence relations of other relevant variables. Another thing to watch out is cyclic dependencies. F2PY is able to detect cyclic dependencies when constructing wrappers and it complains if any are found.</source>
          <target state="translated">当你编辑最初由F2PY生成的依赖关系时,要注意不要破坏其他相关变量的依赖关系。另外需要注意的是循环依赖关系。F2PY在构造包装器时能够检测到循环依赖关系,如果发现有循环依赖关系,它就会抱怨。</target>
        </trans-unit>
        <trans-unit id="656c7a0b5e4bb86f29ff26d5f3ecacd14ae91bd4" translate="yes" xml:space="preserve">
          <source>When you feel your work is finished, you can create a pull request (PR). Github has a nice help page that outlines the process for &lt;a href=&quot;https://help.github.com/articles/using-pull-requests/#initiating-the-pull-request&quot;&gt;filing pull requests&lt;/a&gt;.</source>
          <target state="translated">当您感觉工作已完成时，可以创建拉取请求（PR）。Github有一个很好的帮助页面，概述了&lt;a href=&quot;https://help.github.com/articles/using-pull-requests/#initiating-the-pull-request&quot;&gt;提交拉取请求&lt;/a&gt;的过程。</target>
        </trans-unit>
        <trans-unit id="57465a3d673d3ee14218ee57f56504a3d7049d2f" translate="yes" xml:space="preserve">
          <source>When you have a set of &amp;ldquo;ready&amp;rdquo; changes in a feature branch ready for NumPy&amp;rsquo;s &lt;code&gt;master&lt;/code&gt; or &lt;code&gt;maintenance&lt;/code&gt; branches, you can push them to &lt;code&gt;upstream&lt;/code&gt; as follows:</source>
          <target state="translated">当功能分支中有一组&amp;ldquo;就绪&amp;rdquo;更改准备好供NumPy的 &lt;code&gt;master&lt;/code&gt; 分支或 &lt;code&gt;maintenance&lt;/code&gt; 分支使用时，可以按以下步骤将其推入 &lt;code&gt;upstream&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a89cc2a2b8c2002bf1ad2532a745d3004a2fb796" translate="yes" xml:space="preserve">
          <source>When you have different flags for missing or invalid values, and wish to preserve these flags without replacing them in the original dataset, but exclude them from computations;</source>
          <target state="translated">当你对缺失或无效的值有不同的标志,并希望保留这些标志而不在原始数据集中替换它们,但在计算中排除它们。</target>
        </trans-unit>
        <trans-unit id="1aac8f9491bd528a6d7337e1a909f8444ac4779a" translate="yes" xml:space="preserve">
          <source>When you have to handle many arrays, each with their own mask. If the mask is part of the array, you avoid bugs and the code is possibly more compact;</source>
          <target state="translated">当你必须处理许多数组,每个数组都有自己的掩码。如果掩码是数组的一部分,你就可以避免错误,代码也可能更紧凑。</target>
        </trans-unit>
        <trans-unit id="df9284875f70d664e11ddef3155365522e76bf5c" translate="yes" xml:space="preserve">
          <source>When you print an array, NumPy displays it in a similar way to nested lists, but with the following layout:</source>
          <target state="translated">当你打印一个数组时,NumPy会以类似于嵌套列表的方式显示它,但布局如下。</target>
        </trans-unit>
        <trans-unit id="ff118b2f38b6fa40b704c3319ca967dd7a981fb4" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;flatten&lt;/code&gt;, changes to your new array won&amp;rsquo;t change the parent array.</source>
          <target state="translated">当您使用 &lt;code&gt;flatten&lt;/code&gt; 时，对新数组的更改不会更改父数组。</target>
        </trans-unit>
        <trans-unit id="aaa9ed3a1aa18ac3b534d99cdc2037422344dc84" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;%apply&lt;/code&gt; directive, as is usually necessary to use &lt;code&gt;numpy.i&lt;/code&gt;, it will remain in effect until you tell &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; that it shouldn&amp;rsquo;t be. If the arguments to the functions or methods that you are wrapping have common names, such as &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;vector&lt;/code&gt;, these typemaps may get applied in situations you do not expect or want. Therefore, it is always a good idea to add a &lt;code&gt;%clear&lt;/code&gt; directive after you are done with a specific typemap:</source>
          <target state="translated">当您使用 &lt;code&gt;%apply&lt;/code&gt; 指令（通常使用 &lt;code&gt;numpy.i&lt;/code&gt; 必需)时，该指令将一直有效，直到您告诉&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;不应这样做为止。如果要包装的函数或方法的参数具有通用名称，例如 &lt;code&gt;length&lt;/code&gt; 或 &lt;code&gt;vector&lt;/code&gt; ，则这些类型映射可能会在您不希望或不希望使用的情况下应用。因此，在完成特定的类型映射后，最好添加 &lt;code&gt;%clear&lt;/code&gt; 指令：</target>
        </trans-unit>
        <trans-unit id="c9161d14b7fe0e0123346d805be6e656205c9a99" translate="yes" xml:space="preserve">
          <source>When you want to discard all changes and go back to the last commit in the repo, use one of:</source>
          <target state="translated">当你想放弃所有的修改,回到repo中的最后一次提交时,可以使用以下其中之一。</target>
        </trans-unit>
        <trans-unit id="ab916b3f54cece1e88c682ef0d387765f5a2bcfb" translate="yes" xml:space="preserve">
          <source>When you want to preserve the values you masked for later processing, without copying the array;</source>
          <target state="translated">当你想在不复制数组的情况下,为以后的处理保留你屏蔽的值。</target>
        </trans-unit>
        <trans-unit id="6d2417174abf12a643d6fa2e2e75101924104702" translate="yes" xml:space="preserve">
          <source>When you want to reject a PR: if it&amp;rsquo;s very obvious, you can just close it and explain why. If it&amp;rsquo;s not, then it&amp;rsquo;s a good idea to first explain why you think the PR is not suitable for inclusion in NumPy and then let a second committer comment or close.</source>
          <target state="translated">当您想拒绝PR时：如果它很明显，您可以将其关闭并说明原因。如果不是，那么首先要解释为什么您认为PR不适合包含在NumPy中，然后让第二个提交者评论或关闭是一个好主意。</target>
        </trans-unit>
        <trans-unit id="ccb838c9de18863cdb39cb5422eeea3c8d7e130e" translate="yes" xml:space="preserve">
          <source>Whenever &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; != &lt;code&gt;PyArray_GetNDArrayCVersion()&lt;/code&gt;, the extension has to be recompiled (ABI incompatibility).</source>
          <target state="translated">每当&lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt;！= &lt;code&gt;PyArray_GetNDArrayCVersion()&lt;/code&gt; 时，都必须重新编译扩展名（ABI不兼容）。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
