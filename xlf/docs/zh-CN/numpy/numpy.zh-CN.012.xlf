<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">另见</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">另见</target>
        </trans-unit>
        <trans-unit id="1234129c54dee52191f9a009e54d14ba3cd7901d" translate="yes" xml:space="preserve">
          <source>See also the corresponding attribute of the derived class of interest.</source>
          <target state="translated">也可参见派生类的相应属性。</target>
        </trans-unit>
        <trans-unit id="83750efeee588beded293ee3f9269da81e7c7a09" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;generated/numpy.einsum#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; function for more details.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;generated/numpy.einsum#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="b4f3fbbc86b01e081d4bf3029eeb047323af050f" translate="yes" xml:space="preserve">
          <source>See the class docstring for the number of bits returned.</source>
          <target state="translated">返回的位数见类docstring。</target>
        </trans-unit>
        <trans-unit id="c83ee6459f11d959cce47b344352f4193d454359" translate="yes" xml:space="preserve">
          <source>See the function &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt; for an alternative mechanism introduced in NumPy 1.6.0.</source>
          <target state="translated">有关NumPy 1.6.0中引入的替代机制，请参见函数&lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b5e9065c0e163926104e92911bff64adedee471" translate="yes" xml:space="preserve">
          <source>See the function &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt; for details of NumPy type promotion, updated in NumPy 1.6.0.</source>
          <target state="translated">有关NumPy类型提升的详细信息，请参见函数&lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; &lt;/a&gt;，该功能已在NumPy 1.6.0中更新。</target>
        </trans-unit>
        <trans-unit id="27b980b7065c19a238ed0ab9383f5a540a5d637c" translate="yes" xml:space="preserve">
          <source>See the more detailed documentation for &lt;code&gt;numpy.diagonal&lt;/code&gt; if you use this function to extract a diagonal and wish to write to the resulting array; whether it returns a copy or a view depends on what version of numpy you are using.</source>
          <target state="translated">如果使用此函数提取对角线并希望写入结果数组，请参见 &lt;code&gt;numpy.diagonal&lt;/code&gt; 的详细文档。是否返回副本或视图取决于您使用的numpy版本。</target>
        </trans-unit>
        <trans-unit id="a367dbe20937470e410dfbea9585fd8048f1569d" translate="yes" xml:space="preserve">
          <source>See the notes and examples for clarification.</source>
          <target state="translated">详见注释和实例说明。</target>
        </trans-unit>
        <trans-unit id="ed05825174e3134f290feabd650cdebd78790e5d" translate="yes" xml:space="preserve">
          <source>See the notes for an outline of the algorithm.</source>
          <target state="translated">算法概要见注释。</target>
        </trans-unit>
        <trans-unit id="2de41805fe60d43135ccbebaad2f5782594f2632" translate="yes" xml:space="preserve">
          <source>SeedSequence mixes sources of entropy in a reproducible way to set the initial state for independent and very probably non-overlapping BitGenerators.</source>
          <target state="translated">SeedSequence以一种可重复的方式混合熵源,为独立的、很可能不重叠的BitGenerators设置初始状态。</target>
        </trans-unit>
        <trans-unit id="c837283b736981a9d882e30832f45d2c3a206514" translate="yes" xml:space="preserve">
          <source>SeedSequence spawning</source>
          <target state="translated">种子序列产卵</target>
        </trans-unit>
        <trans-unit id="28355ed4d1be051fdd750124cc876d1fa222f5c2" translate="yes" xml:space="preserve">
          <source>SeedSequence.entropy</source>
          <target state="translated">SeedSequence.entropy</target>
        </trans-unit>
        <trans-unit id="03d7f2826ccb833676fbe70c0022e77d2e2c9c55" translate="yes" xml:space="preserve">
          <source>SeedSequence.generate_state()</source>
          <target state="translated">SeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="c4d5a701757a2a9341845319c69171cb1c646cf5" translate="yes" xml:space="preserve">
          <source>SeedSequence.spawn()</source>
          <target state="translated">SeedSequence.spawn()</target>
        </trans-unit>
        <trans-unit id="9ba62987b34fe8fc63485d9dd7e815f3286c5601" translate="yes" xml:space="preserve">
          <source>SeedSequence.spawn_key</source>
          <target state="translated">SeedSequence.spawn_key</target>
        </trans-unit>
        <trans-unit id="8803a737a63e4b3f599d7264c369bdc58f640281" translate="yes" xml:space="preserve">
          <source>Seeding and Entropy</source>
          <target state="translated">种子和熵</target>
        </trans-unit>
        <trans-unit id="e478fbf4bf9d911f2c366f8992866e1d7b083794" translate="yes" xml:space="preserve">
          <source>Seeding and State</source>
          <target state="translated">播种和国家</target>
        </trans-unit>
        <trans-unit id="37cd3865c006d959fb649d73b618699ccd761419" translate="yes" xml:space="preserve">
          <source>Seeds can be passed to any of the BitGenerators. The provided value is mixed via &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to spread a possible sequence of seeds across a wider range of initialization states for the BitGenerator. Here &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; is used and is wrapped with a &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">种子可以传递给任何BitGenerator。提供的值通过&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;进行混合，以将可能的种子序列分布在BitGenerator的更广泛的初始化状态中。这里使用&lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;并用&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;包裹。</target>
        </trans-unit>
        <trans-unit id="befc8fb6b3706476b647851ec8b54ce3f110f269" translate="yes" xml:space="preserve">
          <source>Selection algorithm. Default is &amp;lsquo;introselect&amp;rsquo;</source>
          <target state="translated">选择算法。默认为'introselect'</target>
        </trans-unit>
        <trans-unit id="ad6f6961c3fd31b6fdfea3ebca7b48b26cade497" translate="yes" xml:space="preserve">
          <source>Selection algorithm. Default is &amp;lsquo;introselect&amp;rsquo;.</source>
          <target state="translated">选择算法。默认值为&amp;ldquo; introselect&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d113b695dceac1abca63d8057088ab91eda91dcc" translate="yes" xml:space="preserve">
          <source>Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</source>
          <target state="translated">选择形状中单维条目的子集。如果选择的轴的形状条目大于1,会出现错误。</target>
        </trans-unit>
        <trans-unit id="ce43c468d1865e00edb6873541f360679646ae28" translate="yes" xml:space="preserve">
          <source>Separator between array items for text output. If &amp;ldquo;&amp;rdquo; (empty), a binary file is written, equivalent to &lt;code&gt;file.write(a.tobytes())&lt;/code&gt;.</source>
          <target state="translated">用于文本输出的数组项目之间的分隔符。如果为&amp;ldquo;&amp;rdquo;（空）， &lt;code&gt;file.write(a.tobytes())&lt;/code&gt; 写入一个二进制文件，等效于file.write（a.tobytes（））。</target>
        </trans-unit>
        <trans-unit id="69c3854cf2f97e2b89f4f88e15dea295b287e18d" translate="yes" xml:space="preserve">
          <source>Separator between items if file is a text file. Empty (&amp;ldquo;&amp;rdquo;) separator means the file should be treated as binary. Spaces (&amp;rdquo; &amp;ldquo;) in the separator match zero or more whitespace characters. A separator consisting only of spaces must match at least one whitespace.</source>
          <target state="translated">如果文件是文本文件，则项目之间的分隔符。空（&amp;ldquo;&amp;rdquo;）分隔符表示该文件应被视为二进制文件。分隔符中的空格（&amp;ldquo;&amp;rdquo;）匹配零个或多个空格字符。仅由空格组成的分隔符必须至少匹配一个空格。</target>
        </trans-unit>
        <trans-unit id="58b5ef82070109089258d37935f6f8dd60465e83" translate="yes" xml:space="preserve">
          <source>Separator to split each string element in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">分离器，以在每个字符串元件分割 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fda4d938e57bdf80fd45be4a4b9ed3293812c803" translate="yes" xml:space="preserve">
          <source>Sequence containing the roots.</source>
          <target state="translated">包含根部的序列。</target>
        </trans-unit>
        <trans-unit id="577113b6ca2471336f20adea7da8449aa1b619c6" translate="yes" xml:space="preserve">
          <source>Sequence of Poly series coefficients. This routine fails for empty sequences.</source>
          <target state="translated">保利系列系数的序列。对于空序列,此例程失败。</target>
        </trans-unit>
        <trans-unit id="0cd7f24fb8c01924663f200685435e6585e0483c" translate="yes" xml:space="preserve">
          <source>Sequence of title strings. An empty list can be used to leave titles out.</source>
          <target state="translated">标题字符串的序列。可以使用空列表来删除标题。</target>
        </trans-unit>
        <trans-unit id="e892733a57cfb8724fa5f063a8369bfa0e2ca384" translate="yes" xml:space="preserve">
          <source>Series basis polynomial of degree &lt;code&gt;deg&lt;/code&gt;.</source>
          <target state="translated">度 &lt;code&gt;deg&lt;/code&gt; 的级数基础多项式。</target>
        </trans-unit>
        <trans-unit id="1337e50ba66491fb95c336fa496a5915ac327127" translate="yes" xml:space="preserve">
          <source>Series of representing the identity.</source>
          <target state="translated">系列的代表身份。</target>
        </trans-unit>
        <trans-unit id="b63dd64982c7da79c8185bb27db51618398f47db" translate="yes" xml:space="preserve">
          <source>Series with the specified roots.</source>
          <target state="translated">系列与指定的根。</target>
        </trans-unit>
        <trans-unit id="c58eeea00ccb981db5bb1976aef71852fd00d936" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;a.flat[n] = values[n]&lt;/code&gt; for all &lt;code&gt;n&lt;/code&gt; in indices.</source>
          <target state="translated">为索引中的所有 &lt;code&gt;n&lt;/code&gt; 设置 &lt;code&gt;a.flat[n] = values[n]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77a70ae836628667e278cbc0920a320844fc2438" translate="yes" xml:space="preserve">
          <source>Set a Python function to be used when pretty printing arrays.</source>
          <target state="translated">设置一个Python函数,用于漂亮地打印数组。</target>
        </trans-unit>
        <trans-unit id="2c5db0d0b74f7205ac29d00dc0f28315d34810c2" translate="yes" xml:space="preserve">
          <source>Set a callback function for the &amp;lsquo;call&amp;rsquo; mode.</source>
          <target state="translated">为&amp;ldquo;通话&amp;rdquo;模式设置一个回调函数。</target>
        </trans-unit>
        <trans-unit id="b4dd0addc44a7c0a5f052f38a920a2396cfdd632" translate="yes" xml:space="preserve">
          <source>Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively.</source>
          <target state="translated">分别设置数组标志WRITEABLE、ALIGNED、(WRITEBACKIFCOPY和UPDATEIFCOPY)。</target>
        </trans-unit>
        <trans-unit id="fe4f54f983d0fc0329e51cb812fc504ecf7d9aeb" translate="yes" xml:space="preserve">
          <source>Set how floating-point errors are handled.</source>
          <target state="translated">设置如何处理浮点错误。</target>
        </trans-unit>
        <trans-unit id="39887c043db9f2506d3506245ce2f8a4950e71c8" translate="yes" xml:space="preserve">
          <source>Set item described by index. If value is masked, masks those locations.</source>
          <target state="translated">设置由索引描述的项目。如果值被掩盖,则掩盖这些位置。</target>
        </trans-unit>
        <trans-unit id="d43a840d83fb8f7ade894cbf5726d0d362e9206c" translate="yes" xml:space="preserve">
          <source>Set items 0 and 1 to their negative values:</source>
          <target state="translated">将项目0和1设为负值。</target>
        </trans-unit>
        <trans-unit id="7e3313ed91d9ab09cbf1b02b801051fadfe61771" translate="yes" xml:space="preserve">
          <source>Set of strings or integers representing the positional or keyword arguments for which the function will not be vectorized. These will be passed directly to &lt;code&gt;pyfunc&lt;/code&gt; unmodified.</source>
          <target state="translated">一组字符串或整数，表示位置或关键字参数，对其不会对其进行向量化。这些将直接传递给未经修改的 &lt;code&gt;pyfunc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd426fb4dd6e4754c713da93e729d89067e4bb9f" translate="yes" xml:space="preserve">
          <source>Set print options for the scope of the &lt;code&gt;with&lt;/code&gt; block, and restore the old options at the end. See &lt;a href=&quot;numpy.set_printoptions#numpy.set_printoptions&quot;&gt;&lt;code&gt;set_printoptions&lt;/code&gt;&lt;/a&gt; for the full description of available options.</source>
          <target state="translated">为 &lt;code&gt;with&lt;/code&gt; 块的范围设置打印选项，最后恢复旧选项。有关可用选项的完整说明，请参见&lt;a href=&quot;numpy.set_printoptions#numpy.set_printoptions&quot;&gt; &lt;code&gt;set_printoptions&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="865d37322e223fb10d7a9b7ba6a65aa905f9c08b" translate="yes" xml:space="preserve">
          <source>Set printing options.</source>
          <target state="translated">设置打印选项。</target>
        </trans-unit>
        <trans-unit id="12d96b7d9d8a25110f724914dda75cc579f9b15b" translate="yes" xml:space="preserve">
          <source>Set routines</source>
          <target state="translated">设置例行程序</target>
        </trans-unit>
        <trans-unit id="90e5a4de82b432cd6a08040a41846a8b484aa8bd" translate="yes" xml:space="preserve">
          <source>Set self[key] to value.</source>
          <target state="translated">将self[key]设置为value。</target>
        </trans-unit>
        <trans-unit id="03a01981fda3953041f5032c2c1e545ec21542ec" translate="yes" xml:space="preserve">
          <source>Set storage-indexed locations to corresponding values.</source>
          <target state="translated">将存储索引的位置设置为相应的值。</target>
        </trans-unit>
        <trans-unit id="b78901915d1c3e355e6e7781fdabdcf49646d0cb" translate="yes" xml:space="preserve">
          <source>Set the &lt;em&gt;iterator&lt;/em&gt; index and dataptr to the location in the array indicated by the integer &lt;em&gt;index&lt;/em&gt; which points to an element in the C-styled flattened array.</source>
          <target state="translated">将&lt;em&gt;迭代器&lt;/em&gt;索引和dataptr 设置为整数&lt;em&gt;索引&lt;/em&gt;指示的数组中的位置，该整数&lt;em&gt;索引&lt;/em&gt;指向C样式的扁平化数组中的元素。</target>
        </trans-unit>
        <trans-unit id="4a1438d389936667e0dd90e958cbfcfc479a293a" translate="yes" xml:space="preserve">
          <source>Set the &lt;em&gt;iterator&lt;/em&gt; index, dataptr, and coordinates members to the location in the array indicated by the N-dimensional c-array, &lt;em&gt;destination&lt;/em&gt;, which must have size at least &lt;em&gt;iterator&lt;/em&gt; -&amp;gt;nd_m1+1.</source>
          <target state="translated">将&lt;em&gt;迭代器&lt;/em&gt;索引，dataptr和坐标成员设置为N维c数组&lt;em&gt;destination&lt;/em&gt;指示的数组中的位置，该数组的大小必须至少为&lt;em&gt;iterator-&lt;/em&gt; &amp;gt; nd_m1 + 1。</target>
        </trans-unit>
        <trans-unit id="9fda88468648975d476004e19b12d7764d8871eb" translate="yes" xml:space="preserve">
          <source>Set the divide by zero floating point exception</source>
          <target state="translated">设置浮点除以零的异常。</target>
        </trans-unit>
        <trans-unit id="052e8b4098d433df163dbe5f239a55cbd55acd03" translate="yes" xml:space="preserve">
          <source>Set the filling value of a masked array.</source>
          <target state="translated">设置掩码数组的填充值。</target>
        </trans-unit>
        <trans-unit id="9db96c8032d2ad506db915a48cc3b65dec28661e" translate="yes" xml:space="preserve">
          <source>Set the filling value of a, if a is a masked array.</source>
          <target state="translated">如果a是掩码数组,则设置a的填充值。</target>
        </trans-unit>
        <trans-unit id="8edcc5a32149cac92ce5f5d9a420660866edfc9a" translate="yes" xml:space="preserve">
          <source>Set the floating-point error callback function or log object.</source>
          <target state="translated">设置浮点错误回调函数或日志对象。</target>
        </trans-unit>
        <trans-unit id="f50931261f78ae53e6d835ee44ec72ac16267946" translate="yes" xml:space="preserve">
          <source>Set the internal state of the generator from a tuple.</source>
          <target state="translated">从元组中设置信号发生器的内部状态。</target>
        </trans-unit>
        <trans-unit id="b7c017b4e42e5916929d8c2729e2850e7861e4ad" translate="yes" xml:space="preserve">
          <source>Set the invalid floating point exception</source>
          <target state="translated">设置无效的浮点异常</target>
        </trans-unit>
        <trans-unit id="5fc1b5b3104040e069bf3d79bfbecde1de4a9774" translate="yes" xml:space="preserve">
          <source>Set the mask.</source>
          <target state="translated">设置面具。</target>
        </trans-unit>
        <trans-unit id="ddcd09abf8029d03a1fc8a1db4814b795eb053c2" translate="yes" xml:space="preserve">
          <source>Set the object that defines floating-point error handling.</source>
          <target state="translated">设置定义浮点错误处理的对象。</target>
        </trans-unit>
        <trans-unit id="e125e8e413edbc9d7b60464db9303d04e73186dc" translate="yes" xml:space="preserve">
          <source>Set the overflow floating point exception</source>
          <target state="translated">设置溢出浮点异常</target>
        </trans-unit>
        <trans-unit id="32771428ee3d4ac8ada5bdd6145886e45b552f86" translate="yes" xml:space="preserve">
          <source>Set the size of the buffer used in ufuncs.</source>
          <target state="translated">设置ufuncs中使用的缓冲区大小。</target>
        </trans-unit>
        <trans-unit id="0594a866f8a04edf46179a77822269ada171c654" translate="yes" xml:space="preserve">
          <source>Set the underflow floating point exception</source>
          <target state="translated">设置下溢浮点异常</target>
        </trans-unit>
        <trans-unit id="74d19ff83e70ffb68238d34c2f7bcf87b543941d" translate="yes" xml:space="preserve">
          <source>Set treatment for all types of floating-point errors at once:</source>
          <target state="translated">设置一次性处理所有类型的浮点错误。</target>
        </trans-unit>
        <trans-unit id="3643bcad64c7deb0821dc34ea3dcd8232b0cde58" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;a.flat[n] = values[n]&lt;/code&gt; for each n where &lt;code&gt;mask.flat[n]==True&lt;/code&gt;.</source>
          <target state="translated">为每个n 设置 &lt;code&gt;a.flat[n] = values[n]&lt;/code&gt; ，其中 &lt;code&gt;mask.flat[n]==True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b6bbd22699cc5a44aa30f4688fb3d6f05291031" translate="yes" xml:space="preserve">
          <source>Sets self._data.flat[n] = values[n] for each n in indices. If &lt;code&gt;values&lt;/code&gt; is shorter than &lt;a href=&quot;numpy.ma.indices#numpy.ma.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; then it will repeat. If &lt;code&gt;values&lt;/code&gt; has some masked values, the initial mask is updated in consequence, else the corresponding values are unmasked.</source>
          <target state="translated">为索引中的每个n设置self._data.flat [n] = values [n]。如果 &lt;code&gt;values&lt;/code&gt; 短于&lt;a href=&quot;numpy.ma.indices#numpy.ma.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt;则它将重复。如果 &lt;code&gt;values&lt;/code&gt; 具有某些掩码的值，则将初始掩码进行更新，否则将取消相应的值。</target>
        </trans-unit>
        <trans-unit id="6e37f27c4b449514c6ac39ca56b186f5e999b75a" translate="yes" xml:space="preserve">
          <source>Sets the flag represented by &lt;code&gt;f&lt;/code&gt; of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">设置标志表示通过 &lt;code&gt;f&lt;/code&gt; 的 &lt;code&gt;a&lt;/code&gt; ，假设 &lt;code&gt;a&lt;/code&gt; 可以转换为一个 &lt;code&gt;PyArrayObject*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adf72c83614ca687d6f697b1bf172e89b7086997" translate="yes" xml:space="preserve">
          <source>Setting and getting error handling</source>
          <target state="translated">设置和获取错误处理</target>
        </trans-unit>
        <trans-unit id="a384be3e2e0c4f12be39cdfe96a41f79740f7b44" translate="yes" xml:space="preserve">
          <source>Setting the timezone to UTC shows the same information, but with a Z suffix</source>
          <target state="translated">将时区设置为UTC,会显示相同的信息,但后缀为Z。</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="c91695f6ab0af4734ea0166f05bdecf2943954de" translate="yes" xml:space="preserve">
          <source>Setup and teardown functions to functions and methods are known as &amp;ldquo;fixtures&amp;rdquo;, and their use is not encouraged.</source>
          <target state="translated">功能和方法的设置和拆卸功能称为&amp;ldquo;固定装置&amp;rdquo;，不鼓励使用它们。</target>
        </trans-unit>
        <trans-unit id="badd1cce039672931750b6c398bce1ef82aaa01b" translate="yes" xml:space="preserve">
          <source>Several algorithms in NumPy work on arbitrarily strided arrays. However, some algorithms require single-segment arrays. When an irregularly strided array is passed in to such algorithms, a copy is automatically made.</source>
          <target state="translated">NumPy中的一些算法都是在任意跨度的数组上工作的。但是,有些算法需要使用单段数组。当一个不规则步长的数组被传入这类算法时,会自动进行复制。</target>
        </trans-unit>
        <trans-unit id="feb6d874b888999df457d285f3a6f7b3c564b09d" translate="yes" xml:space="preserve">
          <source>Several kinds of strings can be converted. Recognized strings can be prepended with &lt;code&gt;'&amp;gt;'&lt;/code&gt; (&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-big-endian&quot;&gt;big-endian&lt;/a&gt;), &lt;code&gt;'&amp;lt;'&lt;/code&gt; (&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-little-endian&quot;&gt;little-endian&lt;/a&gt;), or &lt;code&gt;'='&lt;/code&gt; (hardware-native, the default), to specify the byte order.</source>
          <target state="translated">可以转换几种字符串。公认的字符串可以以 &lt;code&gt;'&amp;gt;'&lt;/code&gt; （&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-big-endian&quot;&gt;big-endian&lt;/a&gt;）， &lt;code&gt;'&amp;lt;'&lt;/code&gt; （&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-little-endian&quot;&gt;little-endian&lt;/a&gt;）或 &lt;code&gt;'='&lt;/code&gt; （hardware-native，默认值）开头，以指定字节顺序。</target>
        </trans-unit>
        <trans-unit id="ea3e5d75b76acbd893a6d1a1cc411aeb6e8d344d" translate="yes" xml:space="preserve">
          <source>Several new types are defined in the C-code. Most of these are accessible from Python, but a few are not exposed due to their limited use. Every new Python type has an associated &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; with an internal structure that includes a pointer to a &amp;ldquo;method table&amp;rdquo; that defines how the new object behaves in Python. When you receive a Python object into C code, you always get a pointer to a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject&lt;/code&gt;&lt;/a&gt; structure. Because a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject&lt;/code&gt;&lt;/a&gt; structure is very generic and defines only &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt;&lt;code&gt;PyObject_HEAD&lt;/code&gt;&lt;/a&gt;, by itself it is not very interesting. However, different objects contain more details after the &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt;&lt;code&gt;PyObject_HEAD&lt;/code&gt;&lt;/a&gt; (but you have to cast to the correct type to access them &amp;mdash; or use accessor functions or macros).</source>
          <target state="translated">C代码中定义了几种新类型。这些中的大多数都可以从Python访问，但由于使用受限，因此其中一些不公开。每个新的Python类型都有一个关联的&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt;，其内部结构包含指向&amp;ldquo;方法表&amp;rdquo;的指针，该方法定义了新对象在Python中的行为。当您将Python对象接收到C代码中时，总会得到一个指向&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject&lt;/code&gt; &lt;/a&gt;结构的指针。因为&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject&lt;/code&gt; &lt;/a&gt;结构非常通用并且仅定义&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt; &lt;code&gt;PyObject_HEAD&lt;/code&gt; &lt;/a&gt;，所以它不是很有趣。但是，不同的对象在&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt; &lt;code&gt;PyObject_HEAD&lt;/code&gt; &lt;/a&gt;之后包含更多详细信息（但必须强制转换为正确的类型才能访问它们-或使用访问器函数或宏）。</target>
        </trans-unit>
        <trans-unit id="8baf8c262d837f958d6464df64e5309968744eec" translate="yes" xml:space="preserve">
          <source>Several of the linear algebra routines listed above are able to compute results for several matrices at once, if they are stacked into the same array.</source>
          <target state="translated">上面列出的几个线性代数例程,如果将几个矩阵堆叠到同一个数组中,就能同时计算出几个矩阵的结果。</target>
        </trans-unit>
        <trans-unit id="72b4a9a262fa7d17e9ac09d705cde6aa24c8773a" translate="yes" xml:space="preserve">
          <source>Several python types are equivalent to a corresponding array scalar when used to generate a &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; object:</source>
          <target state="translated">当用于生成&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;对象时，几种python类型等效于对应的数组标量：</target>
        </trans-unit>
        <trans-unit id="6c3e28ff5f28439895ee75d4f683fd40b7b5c1c1" translate="yes" xml:space="preserve">
          <source>Shape (length along each transformed axis) to use from the input. (&lt;code&gt;s[0]&lt;/code&gt; refers to axis 0, &lt;code&gt;s[1]&lt;/code&gt; to axis 1, etc.). The final element of &lt;code&gt;s&lt;/code&gt; corresponds to &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;rfft(x, n)&lt;/code&gt;, while for the remaining axes, it corresponds to &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;fft(x, n)&lt;/code&gt;. Along any axis, if the given shape is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. if &lt;code&gt;s&lt;/code&gt; is not given, the shape of the input along the axes specified by &lt;code&gt;axes&lt;/code&gt; is used.</source>
          <target state="translated">输入要使用的形状（沿每个变换轴的长度）。（ &lt;code&gt;s[0]&lt;/code&gt; 表示轴0， &lt;code&gt;s[1]&lt;/code&gt; 表示轴1，依此类推）。的最终元件 &lt;code&gt;s&lt;/code&gt; 相当于 &lt;code&gt;n&lt;/code&gt; 为 &lt;code&gt;rfft(x, n)&lt;/code&gt; 而其余的轴，它对应于 &lt;code&gt;n&lt;/code&gt; 为 &lt;code&gt;fft(x, n)&lt;/code&gt; 。沿任意轴，如果给定的形状小于输入的形状，则将裁剪输入。如果较大，则输入将填充零。如果未指定 &lt;code&gt;s&lt;/code&gt; ，则使用沿轴指定的 &lt;code&gt;axes&lt;/code&gt; 的输入形状。</target>
        </trans-unit>
        <trans-unit id="25e97af4557ebd95034e25fa1946abe7364f73b7" translate="yes" xml:space="preserve">
          <source>Shape (length of each axis) of the output (&lt;code&gt;s[0]&lt;/code&gt; refers to axis 0, &lt;code&gt;s[1]&lt;/code&gt; to axis 1, etc.). This corresponds to &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;ifft(x, n)&lt;/code&gt;. Along each axis, if the given shape is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. if &lt;code&gt;s&lt;/code&gt; is not given, the shape of the input along the axes specified by &lt;code&gt;axes&lt;/code&gt; is used. See notes for issue on &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt; zero padding.</source>
          <target state="translated">输出的形状（每个轴的长度）（ &lt;code&gt;s[0]&lt;/code&gt; 指向轴0， &lt;code&gt;s[1]&lt;/code&gt; 指向轴1，依此类推）。这对应于 &lt;code&gt;n&lt;/code&gt; 为 &lt;code&gt;ifft(x, n)&lt;/code&gt; 。沿每个轴，如果给定的形状小于输入的形状，则将裁剪输入。如果较大，则输入将填充零。如果未指定 &lt;code&gt;s&lt;/code&gt; ，则使用沿轴指定的 &lt;code&gt;axes&lt;/code&gt; 的输入形状。请参阅有关&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt;零填充问题的注释。</target>
        </trans-unit>
        <trans-unit id="4f0274375e7f902c51299d209c86d1f430d2633d" translate="yes" xml:space="preserve">
          <source>Shape (length of each transformed axis) of the output (&lt;code&gt;s[0]&lt;/code&gt; refers to axis 0, &lt;code&gt;s[1]&lt;/code&gt; to axis 1, etc.). &lt;code&gt;s&lt;/code&gt; is also the number of input points used along this axis, except for the last axis, where &lt;code&gt;s[-1]//2+1&lt;/code&gt; points of the input are used. Along any axis, if the shape indicated by &lt;code&gt;s&lt;/code&gt; is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;s&lt;/code&gt; is not given, the shape of the input along the axes specified by &lt;code&gt;axes&lt;/code&gt; is used.</source>
          <target state="translated">输出的形状（每个转换轴的长度）（ &lt;code&gt;s[0]&lt;/code&gt; 指向轴0， &lt;code&gt;s[1]&lt;/code&gt; 指向轴1，等等）。 &lt;code&gt;s&lt;/code&gt; 也是沿着该轴使用的输入点数，除了最后一个轴（其中使用了输入的 &lt;code&gt;s[-1]//2+1&lt;/code&gt; 点）。沿任何轴，如果 &lt;code&gt;s&lt;/code&gt; 表示的形状小于输入的形状，则将裁剪输入。如果较大，则输入将填充零。如果未指定 &lt;code&gt;s&lt;/code&gt; ，则使用沿轴指定的 &lt;code&gt;axes&lt;/code&gt; 的输入形状。</target>
        </trans-unit>
        <trans-unit id="715197f23d8523982bbe5b136ca8694c043fdfe2" translate="yes" xml:space="preserve">
          <source>Shape (length of each transformed axis) of the output (&lt;code&gt;s[0]&lt;/code&gt; refers to axis 0, &lt;code&gt;s[1]&lt;/code&gt; to axis 1, etc.). This corresponds to &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;fft(x, n)&lt;/code&gt;. Along any axis, if the given shape is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. if &lt;code&gt;s&lt;/code&gt; is not given, the shape of the input along the axes specified by &lt;code&gt;axes&lt;/code&gt; is used.</source>
          <target state="translated">输出的形状（每个变换轴的长度）（ &lt;code&gt;s[0]&lt;/code&gt; 指向轴0， &lt;code&gt;s[1]&lt;/code&gt; 指向轴1，等等）。这对应于 &lt;code&gt;n&lt;/code&gt; 为 &lt;code&gt;fft(x, n)&lt;/code&gt; 。沿任意轴，如果给定的形状小于输入的形状，则将裁剪输入。如果较大，则输入将填充零。如果未指定 &lt;code&gt;s&lt;/code&gt; ，则使用沿轴指定的 &lt;code&gt;axes&lt;/code&gt; 的输入形状。</target>
        </trans-unit>
        <trans-unit id="911dd842dd5fbba1fec3b25f55cac11209b63564" translate="yes" xml:space="preserve">
          <source>Shape (length of each transformed axis) of the output (&lt;code&gt;s[0]&lt;/code&gt; refers to axis 0, &lt;code&gt;s[1]&lt;/code&gt; to axis 1, etc.). This corresponds to &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;fft(x, n)&lt;/code&gt;. Along each axis, if the given shape is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. if &lt;code&gt;s&lt;/code&gt; is not given, the shape of the input along the axes specified by &lt;code&gt;axes&lt;/code&gt; is used.</source>
          <target state="translated">输出的形状（每个变换轴的长度）（ &lt;code&gt;s[0]&lt;/code&gt; 指向轴0， &lt;code&gt;s[1]&lt;/code&gt; 指向轴1，等等）。这对应于 &lt;code&gt;n&lt;/code&gt; 为 &lt;code&gt;fft(x, n)&lt;/code&gt; 。沿每个轴，如果给定的形状小于输入的形状，则将裁剪输入。如果较大，则输入将填充零。如果未指定 &lt;code&gt;s&lt;/code&gt; ，则使用沿轴指定的 &lt;code&gt;axes&lt;/code&gt; 的输入形状。</target>
        </trans-unit>
        <trans-unit id="b17262b4844364ff0a648b69b2dd5889d0fd6ded" translate="yes" xml:space="preserve">
          <source>Shape (length of each transformed axis) of the output (&lt;code&gt;s[0]&lt;/code&gt; refers to axis 0, &lt;code&gt;s[1]&lt;/code&gt; to axis 1, etc.). This corresponds to &lt;code&gt;n&lt;/code&gt; for &lt;code&gt;ifft(x, n)&lt;/code&gt;. Along any axis, if the given shape is smaller than that of the input, the input is cropped. If it is larger, the input is padded with zeros. if &lt;code&gt;s&lt;/code&gt; is not given, the shape of the input along the axes specified by &lt;code&gt;axes&lt;/code&gt; is used. See notes for issue on &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt; zero padding.</source>
          <target state="translated">输出的形状（每个变换轴的长度）（ &lt;code&gt;s[0]&lt;/code&gt; 指向轴0， &lt;code&gt;s[1]&lt;/code&gt; 指向轴1，等等）。这对应于 &lt;code&gt;n&lt;/code&gt; 为 &lt;code&gt;ifft(x, n)&lt;/code&gt; 。沿任意轴，如果给定的形状小于输入的形状，则将裁剪输入。如果较大，则输入将填充零。如果未指定 &lt;code&gt;s&lt;/code&gt; ，则使用沿轴指定的 &lt;code&gt;axes&lt;/code&gt; 的输入形状。请参阅有关&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt;零填充问题的注释。</target>
        </trans-unit>
        <trans-unit id="4ebeb877c0987d74b5cc7ea4944124e8bf55dfce" translate="yes" xml:space="preserve">
          <source>Shape Manipulation</source>
          <target state="translated">形状操作</target>
        </trans-unit>
        <trans-unit id="c9f4b98b8edf5592548ab5955c6e16a228f358cb" translate="yes" xml:space="preserve">
          <source>Shape consistent means they are either the same shape, or one input array can be broadcasted to create the same shape as the other one.</source>
          <target state="translated">形状一致的意思是它们要么是相同的形状,要么是一个输入阵列可以广播创建与另一个相同的形状。</target>
        </trans-unit>
        <trans-unit id="5f1d9e046d241980c89d8b9124d4eafb15b1ca52" translate="yes" xml:space="preserve">
          <source>Shape manipulation</source>
          <target state="translated">形状操作</target>
        </trans-unit>
        <trans-unit id="3b6ca0ce8b60b462e3cf99cb12bf59179d6a929d" translate="yes" xml:space="preserve">
          <source>Shape of broadcasted result.</source>
          <target state="translated">播出结果的形状。</target>
        </trans-unit>
        <trans-unit id="bddad57d8d1388e963005420a02793b2da427fb5" translate="yes" xml:space="preserve">
          <source>Shape of created array.</source>
          <target state="translated">创建阵列的形状。</target>
        </trans-unit>
        <trans-unit id="6cd9e448195effa4bae30eb0f347906fc449b5d5" translate="yes" xml:space="preserve">
          <source>Shape of output array.</source>
          <target state="translated">输出阵列的形状。</target>
        </trans-unit>
        <trans-unit id="46e7814f1b68d56a7fb197281826d8c0d7e2f4af" translate="yes" xml:space="preserve">
          <source>Shape of resized array.</source>
          <target state="translated">调整数组的形状。</target>
        </trans-unit>
        <trans-unit id="ee903849125469d0cd897ee6f3eb2ebe3bb658c4" translate="yes" xml:space="preserve">
          <source>Shape of the FFT.</source>
          <target state="translated">FFT的形状。</target>
        </trans-unit>
        <trans-unit id="93a4d2c249aa77d74ddbee4b73894079d88c4f5d" translate="yes" xml:space="preserve">
          <source>Shape of the array.</source>
          <target state="translated">阵列的形状。</target>
        </trans-unit>
        <trans-unit id="02877fc62d2c6f24e10d1abc3b67c8004f59d738" translate="yes" xml:space="preserve">
          <source>Shape of the distribution. Must be positive.</source>
          <target state="translated">形状的分布。必须是正数。</target>
        </trans-unit>
        <trans-unit id="f2d500bd962f41d17541e213ff6895cd13e0803e" translate="yes" xml:space="preserve">
          <source>Shape of the empty array, e.g., &lt;code&gt;(2, 3)&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">空数组的形状，例如 &lt;code&gt;(2, 3)&lt;/code&gt; 或 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24ef6c437154658151fd05bcb5ba7d5668bdcc5d" translate="yes" xml:space="preserve">
          <source>Shape of the empty matrix.</source>
          <target state="translated">空矩阵的形状。</target>
        </trans-unit>
        <trans-unit id="655648f0fa12f5cdf873e10745fb89b0bd95696d" translate="yes" xml:space="preserve">
          <source>Shape of the inverse FFT.</source>
          <target state="translated">反FFT的形状。</target>
        </trans-unit>
        <trans-unit id="3199c5dcca84fd372c42321d02949f1a124a4434" translate="yes" xml:space="preserve">
          <source>Shape of the matrix</source>
          <target state="translated">矩阵的形状</target>
        </trans-unit>
        <trans-unit id="c98d12cd91ff402d167f61e45930510176bc8db1" translate="yes" xml:space="preserve">
          <source>Shape of the new array, e.g., &lt;code&gt;(2, 3)&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">新数组的形状，例如 &lt;code&gt;(2, 3)&lt;/code&gt; 或 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="011eae76336380495ec0325c87bbf97467274627" translate="yes" xml:space="preserve">
          <source>Shape of the output array, which also determines the shape of the coordinate arrays passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">输出数组的形状，它也确定传递给 &lt;code&gt;function&lt;/code&gt; 的坐标数组的形状。</target>
        </trans-unit>
        <trans-unit id="c07147cdf3a1896289324d57eac09581fa428dd6" translate="yes" xml:space="preserve">
          <source>Shape of the output. If given as N integers, each integer specifies the size of one dimension. If given as a tuple, this tuple gives the complete shape.</source>
          <target state="translated">输出的形状。如果以N个整数给出,每个整数指定一个维度的大小。如果以元组形式给定,这个元组给出完整的形状。</target>
        </trans-unit>
        <trans-unit id="af9d8afd8fa749d8e52d9830aee69713b28d831e" translate="yes" xml:space="preserve">
          <source>Shape of the required MaskedArray.</source>
          <target state="translated">所需MaskedArray的形状。</target>
        </trans-unit>
        <trans-unit id="e290412db84643bfd2e4e9eaed5764c99448847e" translate="yes" xml:space="preserve">
          <source>Shape parameter for the distribution. Must be in the range (0, 1).</source>
          <target state="translated">分布的形状参数,必须在(0,1)范围内。必须在(0,1)范围内。</target>
        </trans-unit>
        <trans-unit id="83905d9bb159cfd69b777f36625de825a5e41d49" translate="yes" xml:space="preserve">
          <source>Shape parameter for window.</source>
          <target state="translated">窗口的形状参数。</target>
        </trans-unit>
        <trans-unit id="9b7a43cf04b72cc2f8a23566b289e4d0bd8ec177" translate="yes" xml:space="preserve">
          <source>Shape parameter of the distribution. Must be nonnegative.</source>
          <target state="translated">分布的形状参数。必须为非负值。</target>
        </trans-unit>
        <trans-unit id="8e3c6edf56bb87890fd0d1cdb08c97f69b223d25" translate="yes" xml:space="preserve">
          <source>Shape tuple of the sub-array if this data type describes a sub-array, and &lt;code&gt;()&lt;/code&gt; otherwise.</source>
          <target state="translated">如果此数据类型描述了子数组，则子数组的形状元组，否则为 &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="446e2a7d2369f9d1a3b2488394691efa0754afe6" translate="yes" xml:space="preserve">
          <source>Shape tuple, the shape of the iterator.</source>
          <target state="translated">Shape tuple,迭代器的形状。</target>
        </trans-unit>
        <trans-unit id="553abfec4e1a448d4b14d3d81794f14b5ad2fe5b" translate="yes" xml:space="preserve">
          <source>Share status of the mask (read-only).</source>
          <target state="translated">分享面具的状态(只读)。</target>
        </trans-unit>
        <trans-unit id="7c87de531eb450c69f475f1cc68cfb4c95a8aa3e" translate="yes" xml:space="preserve">
          <source>Shift the bits of an integer to the left.</source>
          <target state="translated">将一个整数的位数向左移动。</target>
        </trans-unit>
        <trans-unit id="2f8deb45beae3abccb987abecafce17d01cca0db" translate="yes" xml:space="preserve">
          <source>Shift the bits of an integer to the right.</source>
          <target state="translated">将整数的位数向右移动。</target>
        </trans-unit>
        <trans-unit id="4b62e14d6acb41a9881dd5c7d1b632d11117bf42" translate="yes" xml:space="preserve">
          <source>Shift the zero-frequency component only along the second axis:</source>
          <target state="translated">仅沿第二轴移动零频分量。</target>
        </trans-unit>
        <trans-unit id="dd4356118ce17af4ac61d8e18b734f9c851e6a93" translate="yes" xml:space="preserve">
          <source>Shift the zero-frequency component to the center of the spectrum.</source>
          <target state="translated">将零频分量移到光谱中心。</target>
        </trans-unit>
        <trans-unit id="5055dc1fca0e758173b975d01eb66d87f3cbb17c" translate="yes" xml:space="preserve">
          <source>Shift zero-frequency component to the center of the spectrum.</source>
          <target state="translated">将零频分量移到频谱中心。</target>
        </trans-unit>
        <trans-unit id="b180ab3848496fb12e866c104e23d82cd3b364fd" translate="yes" xml:space="preserve">
          <source>Shifts zero-frequency terms to centre of array</source>
          <target state="translated">将零频项移至阵列中心。</target>
        </trans-unit>
        <trans-unit id="277215a3b406656029fa8041449bf3521c519abc" translate="yes" xml:space="preserve">
          <source>Shifts zero-frequency terms to the center of the array. For two-dimensional input, swaps first and third quadrants, and second and fourth quadrants.</source>
          <target state="translated">将零频项移到阵列的中心。对于二维输入,交换第一和第三象限,第二和第四象限。</target>
        </trans-unit>
        <trans-unit id="b762aac578ae466a940477f419de45f5524873a7" translate="yes" xml:space="preserve">
          <source>Short repeat rule</source>
          <target state="translated">简短重复规则</target>
        </trans-unit>
        <trans-unit id="82df73654f5b2a3f44b1124d8173803e26dbe857" translate="yes" xml:space="preserve">
          <source>Shortcut to &lt;code&gt;masked_where&lt;/code&gt;, where &lt;code&gt;condition&lt;/code&gt; is True for &lt;code&gt;x&lt;/code&gt; inside the interval [v1,v2] (v1 &amp;lt;= x &amp;lt;= v2). The boundaries &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; can be given in either order.</source>
          <target state="translated">到 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式，其中 &lt;code&gt;condition&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 在间隔[v1，v2]（v1 &amp;lt;= x &amp;lt;= v2）之内为True 。边界 &lt;code&gt;v1&lt;/code&gt; 和 &lt;code&gt;v2&lt;/code&gt; 可以任意顺序给出。</target>
        </trans-unit>
        <trans-unit id="2b41646ab781bb52f3ec916c5f5214e0562ccf8b" translate="yes" xml:space="preserve">
          <source>Shortcut to &lt;code&gt;masked_where&lt;/code&gt;, where &lt;code&gt;condition&lt;/code&gt; is True for &lt;code&gt;x&lt;/code&gt; outside the interval [v1,v2] (x &amp;lt; v1)|(x &amp;gt; v2). The boundaries &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; can be given in either order.</source>
          <target state="translated">到 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式，其中对于间隔[v1，v2]（x &amp;lt;v1）|（x&amp;gt; v2）之外的 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;condition&lt;/code&gt; 为True 。边界 &lt;code&gt;v1&lt;/code&gt; 和 &lt;code&gt;v2&lt;/code&gt; 可以任意顺序给出。</target>
        </trans-unit>
        <trans-unit id="90a7ea5e6af4c7b7105e0bea7e0631a8b326d3c4" translate="yes" xml:space="preserve">
          <source>Show how an extreme value distribution can arise from a Gaussian process and compare to a Gaussian:</source>
          <target state="translated">说明极值分布如何从高斯过程中产生,并与高斯进行比较。</target>
        </trans-unit>
        <trans-unit id="19b965e86e175fb4e059f2686baef10d13deee7c" translate="yes" xml:space="preserve">
          <source>Show the coefficient of the k-th power in the polynomial (which is equivalent to &lt;code&gt;p.c[-(i+1)]&lt;/code&gt;):</source>
          <target state="translated">显示多项式中的第k次幂的系数（等效于 &lt;code&gt;p.c[-(i+1)]&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="2dc1d2c7e18782c1b84edd4a515e52ecaf16ffe6" translate="yes" xml:space="preserve">
          <source>Show the coefficients:</source>
          <target state="translated">出示系数。</target>
        </trans-unit>
        <trans-unit id="196a4e0eff8a41440049d47c5b180f7f45132ca2" translate="yes" xml:space="preserve">
          <source>Show which elements are NaN.</source>
          <target state="translated">说明哪些元素是NaN。</target>
        </trans-unit>
        <trans-unit id="c42d9c8bf1bc36b5a64f8cd7d6ec47959c633d86" translate="yes" xml:space="preserve">
          <source>Show which elements are not NaN or +/-inf.</source>
          <target state="translated">说明哪些元素不是NaN或+/-inf。</target>
        </trans-unit>
        <trans-unit id="1722f8e8697cd3b5c7fd5053f2fe5fc8ffff0c94" translate="yes" xml:space="preserve">
          <source>Showing the shape equivalence:</source>
          <target state="translated">显示出形状的等价性。</target>
        </trans-unit>
        <trans-unit id="f7b90b8e09428e6e1e81258972869d09b4e3cfb5" translate="yes" xml:space="preserve">
          <source>Shows which elements are Not a Number (NaN).</source>
          <target state="translated">显示哪些元素是非数字(NaN)。</target>
        </trans-unit>
        <trans-unit id="fe897f37d53e4d88b6771d092e29d0cbef83871f" translate="yes" xml:space="preserve">
          <source>Shows which elements are finite (not NaN, not infinity)</source>
          <target state="translated">显示哪些元素是有限的(不是NaN,不是无穷大)。</target>
        </trans-unit>
        <trans-unit id="7baa9edf65ea714b6abdb42e0d551c9f633b7a31" translate="yes" xml:space="preserve">
          <source>Shows which elements are negative infinity.</source>
          <target state="translated">显示哪些元素是负无穷大。</target>
        </trans-unit>
        <trans-unit id="8a9af7136c0a378e79ffd9025ff0d52b52f3f5b3" translate="yes" xml:space="preserve">
          <source>Shows which elements are neither NaN nor infinity.</source>
          <target state="translated">显示哪些元素既不是NaN也不是无穷大。</target>
        </trans-unit>
        <trans-unit id="b641e3652a21af65f93f39772715d39737df1101" translate="yes" xml:space="preserve">
          <source>Shows which elements are positive infinity.</source>
          <target state="translated">显示哪些元素是正无穷大。</target>
        </trans-unit>
        <trans-unit id="cae71eb0e9768c0464ac97199ab347f3e2d0b2fa" translate="yes" xml:space="preserve">
          <source>Shows which elements are positive or negative infinity.</source>
          <target state="translated">显示哪些元素是正的或负的无穷大。</target>
        </trans-unit>
        <trans-unit id="fb36ed0dc4329ccc9a4d63a4ab49050cba7729e3" translate="yes" xml:space="preserve">
          <source>Shrinking an array: array is flattened (in the order that the data are stored in memory), resized, and reshaped:</source>
          <target state="translated">缩小数组:数组被扁平化(按照数据在内存中的存储顺序)、调整大小和重塑形状。</target>
        </trans-unit>
        <trans-unit id="57d924a0266c81fc54add4584a1ccacbe3e83546" translate="yes" xml:space="preserve">
          <source>Signals to nose that this function is or is not a test.</source>
          <target state="translated">向鼻子发出信号,说明这个功能是或不是测试。</target>
        </trans-unit>
        <trans-unit id="2f32be1dc74166373c988ec03b0bd86f0a576919" translate="yes" xml:space="preserve">
          <source>Signature</source>
          <target state="translated">Signature</target>
        </trans-unit>
        <trans-unit id="7931cda1fe427976dc0d85722ec095e3dd727c1d" translate="yes" xml:space="preserve">
          <source>Similar function which always returns ndarrays.</source>
          <target state="translated">类似的函数,总是返回ndarrays。</target>
        </trans-unit>
        <trans-unit id="3274df1aa677da58a67e936b08b6d01b18ae9bbb" translate="yes" xml:space="preserve">
          <source>Similar function which checks input for NaNs and Infs.</source>
          <target state="translated">类似的功能,检查输入的NaNs和Infs。</target>
        </trans-unit>
        <trans-unit id="5bfc139e101673a0040c4eaa29d6026a0cc4d777" translate="yes" xml:space="preserve">
          <source>Similar function which passes through subclasses.</source>
          <target state="translated">类似的功能,通过子类。</target>
        </trans-unit>
        <trans-unit id="385cb8c7bac921aa96fc7c5b5e20aadf977c2b11" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#c.PyArray_FROM_O&quot;&gt;&lt;code&gt;PyArray_FROM_O&lt;/code&gt;&lt;/a&gt; except it can take an argument of &lt;em&gt;requirements&lt;/em&gt; indicating properties the resulting array must have. Available requirements that can be enforced are &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_NOTSWAPPED&quot;&gt;&lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ENSURECOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt;&lt;/a&gt;. Standard combinations of flags can also be used:</source>
          <target state="translated">与&lt;a href=&quot;#c.PyArray_FROM_O&quot;&gt; &lt;code&gt;PyArray_FROM_O&lt;/code&gt; &lt;/a&gt;类似，不同之处在于它可以接受&lt;em&gt;要求&lt;/em&gt;的参数，以指示结果数组必须具有的属性。可以强制执行可要求&lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_NOTSWAPPED&quot;&gt; &lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_ENSURECOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt; &lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt; &lt;/a&gt;。也可以使用标志的标准组合：</target>
        </trans-unit>
        <trans-unit id="34e63b3cec603aed4fdc223ab142b8582483ea26" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#c.PyArray_FROM_O&quot;&gt;&lt;code&gt;PyArray_FROM_O&lt;/code&gt;&lt;/a&gt; except it can take an argument of &lt;em&gt;typenum&lt;/em&gt; specifying the type-number the returned array.</source>
          <target state="translated">与&lt;a href=&quot;#c.PyArray_FROM_O&quot;&gt; &lt;code&gt;PyArray_FROM_O&lt;/code&gt; &lt;/a&gt;类似，除了它可以接受&lt;em&gt;typenum&lt;/em&gt;参数指定返回数组的类型编号。</target>
        </trans-unit>
        <trans-unit id="9ab72ded5542baece20f259b6e4f2d1ffd7e40a6" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; except the data-type is specified using a typenumber. &lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;typenum&lt;/em&gt;) is passed directly to &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt;. This macro also adds &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; to requirements if &lt;a href=&quot;#c.NPY_ARRAY_ENSURECOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt;&lt;/a&gt; is passed in as requirements.</source>
          <target state="translated">类似于&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; ,&lt;/a&gt;不同的是使用typenumber指定数据类型。&lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;typenum&lt;/em&gt;）直接传递给&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;。如果将&lt;a href=&quot;#c.NPY_ARRAY_ENSURECOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt; &lt;/a&gt;作为要求传递，则此宏还将&lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; &lt;/a&gt;添加到要求中。</target>
        </trans-unit>
        <trans-unit id="b7795b78351922539b7bd3388bd15513fe09ab10" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#numpy.linspace&quot;&gt;&lt;code&gt;linspace&lt;/code&gt;&lt;/a&gt;, but uses a step size (instead of the number of samples).</source>
          <target state="translated">与&lt;a href=&quot;#numpy.linspace&quot;&gt; &lt;code&gt;linspace&lt;/code&gt; &lt;/a&gt;相似，但是使用步长大小（而不是样本数）。</target>
        </trans-unit>
        <trans-unit id="61b73acdf7b4aeb554b76ddf529120fdd3244e4c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#numpy.linspace&quot;&gt;&lt;code&gt;linspace&lt;/code&gt;&lt;/a&gt;, but with numbers spaced evenly on a log scale (a geometric progression).</source>
          <target state="translated">与&lt;a href=&quot;#numpy.linspace&quot;&gt; &lt;code&gt;linspace&lt;/code&gt; &lt;/a&gt;相似，但数字在对数刻度上均匀分布（几何级数）。</target>
        </trans-unit>
        <trans-unit id="b7334b28a788c204f9b851a15f23e3dc83fbe028" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#numpy.ma.asanyarray&quot;&gt;&lt;code&gt;asanyarray&lt;/code&gt;&lt;/a&gt;, but does not conserve subclass.</source>
          <target state="translated">与&lt;a href=&quot;#numpy.ma.asanyarray&quot;&gt; &lt;code&gt;asanyarray&lt;/code&gt; &lt;/a&gt;相似，但不保留子类。</target>
        </trans-unit>
        <trans-unit id="e0639724205f7208e357391aa44785bd18f6e10a" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#numpy.ma.asarray&quot;&gt;&lt;code&gt;asarray&lt;/code&gt;&lt;/a&gt;, but conserves subclasses.</source>
          <target state="translated">与&lt;a href=&quot;#numpy.ma.asarray&quot;&gt; &lt;code&gt;asarray&lt;/code&gt; &lt;/a&gt;相似，但保留子类。</target>
        </trans-unit>
        <trans-unit id="087902d07ba8ed25e8e25e39b41104a23371fa18" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#numpy.random.mtrand.RandomState.random_integers&quot;&gt;&lt;code&gt;random_integers&lt;/code&gt;&lt;/a&gt;, only for the half-open interval [&lt;code&gt;low&lt;/code&gt;, &lt;code&gt;high&lt;/code&gt;), and 0 is the lowest value if &lt;code&gt;high&lt;/code&gt; is omitted.</source>
          <target state="translated">与&lt;a href=&quot;#numpy.random.mtrand.RandomState.random_integers&quot;&gt; &lt;code&gt;random_integers&lt;/code&gt; &lt;/a&gt;相似，仅在半开间隔[ &lt;code&gt;low&lt;/code&gt; ， &lt;code&gt;high&lt;/code&gt; ）中，如果省略 &lt;code&gt;high&lt;/code&gt; ,则0为最小值。</target>
        </trans-unit>
        <trans-unit id="4f32836393c39ad349545e85caa88d4f0b0d4f21" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;numpy.geomspace#numpy.geomspace&quot;&gt;&lt;code&gt;geomspace&lt;/code&gt;&lt;/a&gt;, but with the end points specified as logarithms.</source>
          <target state="translated">与&lt;a href=&quot;numpy.geomspace#numpy.geomspace&quot;&gt; &lt;code&gt;geomspace&lt;/code&gt; &lt;/a&gt;相似，但将端点指定为对数。</target>
        </trans-unit>
        <trans-unit id="9f556182c8173073bc9575354a35bd7cdcf632ab" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;np.copyto(arr, vals, where=mask)&lt;/code&gt;, the difference is that &lt;a href=&quot;#numpy.place&quot;&gt;&lt;code&gt;place&lt;/code&gt;&lt;/a&gt; uses the first N elements of &lt;code&gt;vals&lt;/code&gt;, where N is the number of True values in &lt;code&gt;mask&lt;/code&gt;, while &lt;a href=&quot;numpy.copyto#numpy.copyto&quot;&gt;&lt;code&gt;copyto&lt;/code&gt;&lt;/a&gt; uses the elements where &lt;code&gt;mask&lt;/code&gt; is True.</source>
          <target state="translated">与 &lt;code&gt;np.copyto(arr, vals, where=mask)&lt;/code&gt; 相似，区别在于该&lt;a href=&quot;#numpy.place&quot;&gt; &lt;code&gt;place&lt;/code&gt; &lt;/a&gt;使用 &lt;code&gt;vals&lt;/code&gt; 的前N个元素，其中N是 &lt;code&gt;mask&lt;/code&gt; 中True值的数量，而&lt;a href=&quot;numpy.copyto#numpy.copyto&quot;&gt; &lt;code&gt;copyto&lt;/code&gt; &lt;/a&gt;使用 &lt;code&gt;mask&lt;/code&gt; 为True 的元素。</target>
        </trans-unit>
        <trans-unit id="85182c2cf4636594ba4bb81df790d59ce12b4844" translate="yes" xml:space="preserve">
          <source>Similar to a Blackman</source>
          <target state="translated">类似于布莱克曼</target>
        </trans-unit>
        <trans-unit id="fda0ddbefcd9b950d1be64cfa40b8b4d44338564" translate="yes" xml:space="preserve">
          <source>Similar to a Hamming</source>
          <target state="translated">类似于Hamming</target>
        </trans-unit>
        <trans-unit id="e44711f2465ecfd9681ac18329e5511ea31ae57b" translate="yes" xml:space="preserve">
          <source>Similar to a Hanning</source>
          <target state="translated">类似于汉宁</target>
        </trans-unit>
        <trans-unit id="234d445a03f1aebf3ed4d77e0d02e9c11e9233b2" translate="yes" xml:space="preserve">
          <source>Similar to add_library, but the specified library is installed.</source>
          <target state="translated">类似于add_library,但指定的库已经安装。</target>
        </trans-unit>
        <trans-unit id="3dfdcd8111d1084fb95920b6488396d3e8d8a393" translate="yes" xml:space="preserve">
          <source>Similar to geomspace, but with arithmetic instead of geometric progression.</source>
          <target state="translated">类似于地理空间,但用算术代替几何级数。</target>
        </trans-unit>
        <trans-unit id="33e0805e34847491157755893623c681d0de564b" translate="yes" xml:space="preserve">
          <source>Similar to geomspace, but with endpoints specified using log and base.</source>
          <target state="translated">类似于geomspace,但使用log和base指定端点。</target>
        </trans-unit>
        <trans-unit id="2e5b100f812a24f804b90138859e80b7ccf1d358" translate="yes" xml:space="preserve">
          <source>Similar to linspace, with the step size specified instead of the number of samples.</source>
          <target state="translated">类似于linspace,指定步长而不是样本数。</target>
        </trans-unit>
        <trans-unit id="17805c407a9f09edaa3bff91c61279fe000f669b" translate="yes" xml:space="preserve">
          <source>Similar to linspace, with the step size specified instead of the number of samples. Note that, when used with a float endpoint, the endpoint may or may not be included.</source>
          <target state="translated">类似于linspace,指定步长而不是样本数。请注意,当与浮点端点一起使用时,端点可能被包含,也可能不被包含。</target>
        </trans-unit>
        <trans-unit id="376b7895ca7454ae515537b5c988798aa23f4981" translate="yes" xml:space="preserve">
          <source>Similar to logspace, but with endpoints specified directly.</source>
          <target state="translated">类似于日志空间,但直接指定端点。</target>
        </trans-unit>
        <trans-unit id="fb5e56ddf3f3d8bcd94b1df305f6991c2bdc0db5" translate="yes" xml:space="preserve">
          <source>Similar to logspace, but with the samples uniformly distributed in linear space, instead of log space.</source>
          <target state="translated">类似于logspace,但样本均匀分布在线性空间,而不是对数空间。</target>
        </trans-unit>
        <trans-unit id="972ade8b6d212f3e2ece52621379958937336838" translate="yes" xml:space="preserve">
          <source>Similar, but takes a tuple as its argument.</source>
          <target state="translated">类似,但取一个元组作为参数。</target>
        </trans-unit>
        <trans-unit id="d90324501e9d6e49bd014963ecc43250f1eed84e" translate="yes" xml:space="preserve">
          <source>Similarly for methods:</source>
          <target state="translated">方法也是如此。</target>
        </trans-unit>
        <trans-unit id="8e9eeb8d7a147426a8015c3531ee3a6251c0e6fe" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;sqrt&lt;/code&gt;, other base logarithms, &lt;code&gt;power&lt;/code&gt; and trig functions are correctly handled. See their respective docstrings for specific examples.</source>
          <target state="translated">同样， &lt;code&gt;sqrt&lt;/code&gt; ，其他基本对数， &lt;code&gt;power&lt;/code&gt; 和触发函数也可以正确处理。有关特定示例，请参见其各自的文档字符串。</target>
        </trans-unit>
        <trans-unit id="acf3895a0f3e8fb2433f49e7c933653b2955fa80" translate="yes" xml:space="preserve">
          <source>Simple Iteration Example</source>
          <target state="translated">简单迭代实例</target>
        </trans-unit>
        <trans-unit id="4512383893712587e1eb27a74805a2a877a79b85" translate="yes" xml:space="preserve">
          <source>Simple Multi-Iteration Example</source>
          <target state="translated">简单的多迭代实例</target>
        </trans-unit>
        <trans-unit id="50416fe10bcfba1d097d2f78636e350c2106eb91" translate="yes" xml:space="preserve">
          <source>Simple example showing support of broadcasting</source>
          <target state="translated">显示支持广播的简单例子</target>
        </trans-unit>
        <trans-unit id="ae19d7f5a896d028209ec76ca00e6ca839a5fe6f" translate="yes" xml:space="preserve">
          <source>Simple financial functions</source>
          <target state="translated">简单的财务职能</target>
        </trans-unit>
        <trans-unit id="d369dea603addc198cac2b7cf54d9f2f5da3fe8f" translate="yes" xml:space="preserve">
          <source>Simple random data</source>
          <target state="translated">简单的随机数据</target>
        </trans-unit>
        <trans-unit id="1c8cdc6800aadf2bece7e4049099bee1ec8e07ce" translate="yes" xml:space="preserve">
          <source>Simulate from the complex normal distribution (&lt;code&gt;complex_normal&lt;/code&gt;)</source>
          <target state="translated">从复杂的正态分布（ &lt;code&gt;complex_normal&lt;/code&gt; ）模拟</target>
        </trans-unit>
        <trans-unit id="6c7cbba342c72a06adf163e32df8899d2552eb30" translate="yes" xml:space="preserve">
          <source>Simultaneous floor division and remainder.</source>
          <target state="translated">同时进行楼层划分和剩余。</target>
        </trans-unit>
        <trans-unit id="5bfc61180c73bf11bcf8e9a59d533a6dcbb10666" translate="yes" xml:space="preserve">
          <source>Since Numpy version 1.17.0 the Generator can be initialized with a number of different BitGenerators. It exposes many different probability distributions. See &lt;a href=&quot;https://www.numpy.org/neps/nep-0019-rng-policy.html&quot;&gt;NEP 19&lt;/a&gt; for context on the updated random Numpy number routines. The legacy &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; random number routines are still available, but limited to a single BitGenerator.</source>
          <target state="translated">从Numpy版本1.17.0开始，可以使用许多不同的BitGenerators初始化Generator。它揭示了许多不同的概率分布。有关更新的随机Numpy数例程的上下文，请参见&lt;a href=&quot;https://www.numpy.org/neps/nep-0019-rng-policy.html&quot;&gt;NEP 19&lt;/a&gt;。传统的&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;随机数例程仍然可用，但仅限于单个BitGenerator。</target>
        </trans-unit>
        <trans-unit id="0e5a09c913abb2d820fe3ca564fc0e41384dbaaf" translate="yes" xml:space="preserve">
          <source>Since all ufuncs can take output arguments, this will always be (at least) 1.</source>
          <target state="translated">因为所有的ufuncs都可以接受输出参数,所以这将永远是(至少)1。</target>
        </trans-unit>
        <trans-unit id="2ed82f769a88b72358683adc7002539ca034c05e" translate="yes" xml:space="preserve">
          <source>Since concatenation happens along the last axis first, &lt;a href=&quot;#numpy.block&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; is _not_ capable of producing the following directly:</source>
          <target state="translated">由于级联沿最后轴第一情况，&lt;a href=&quot;#numpy.block&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt;是_not_能够直接生产如下：</target>
        </trans-unit>
        <trans-unit id="dbccad20cacee376129c1a8bbd5585811048a318" translate="yes" xml:space="preserve">
          <source>Single Array Iteration</source>
          <target state="translated">单阵迭代</target>
        </trans-unit>
        <trans-unit id="1923a37e061c3d312b736626f7d4070c8dcabda6" translate="yes" xml:space="preserve">
          <source>Singular Value Decomposition.</source>
          <target state="translated">奇异值分解。</target>
        </trans-unit>
        <trans-unit id="be2751c62dbed56ddb419e417fca2d9511c5f595" translate="yes" xml:space="preserve">
          <source>Singular values of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">奇异值的 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f7ca2b11c805ad773c63eebb03a2a048382c59e" translate="yes" xml:space="preserve">
          <source>Size of a pointer on this platform (sizeof(void *)) (A macro defines NPY_SIZEOF_INTP as well.)</source>
          <target state="translated">这个平台上指针的大小(sizeof(void *))。(一个宏也定义了NPY_SIZEOF_INTP。)</target>
        </trans-unit>
        <trans-unit id="f19f296d7676df236287d76dbc5f75e14729bdc6" translate="yes" xml:space="preserve">
          <source>Size of buffer.</source>
          <target state="translated">缓冲区的大小。</target>
        </trans-unit>
        <trans-unit id="94f57e9139c081fd224904e8757bd108f6615f74" translate="yes" xml:space="preserve">
          <source>Size of spacing between samples.</source>
          <target state="translated">样本之间的间距大小。</target>
        </trans-unit>
        <trans-unit id="3de9e845a3b95a48f909e7b501dd8bf3a25f0227" translate="yes" xml:space="preserve">
          <source>Size of the data (how many bytes is in &lt;em&gt;e.g.&lt;/em&gt; the integer)</source>
          <target state="translated">数据大小（&lt;em&gt;例如&lt;/em&gt;整数中有多少个字节）</target>
        </trans-unit>
        <trans-unit id="69356099c1bda1de5732916fcc4b059a9e5e1e9d" translate="yes" xml:space="preserve">
          <source>Size of the data is in turn described by:</source>
          <target state="translated">数据的大小又用以下方法来描述:</target>
        </trans-unit>
        <trans-unit id="b7b677e8d293fb1fdabc56b0ddc443af48c5aeca" translate="yes" xml:space="preserve">
          <source>Size of the iterator.</source>
          <target state="translated">迭代器的大小。</target>
        </trans-unit>
        <trans-unit id="9f5f50339fb8609920b44a4a178129be24577d29" translate="yes" xml:space="preserve">
          <source>Size of the pooled entropy to store. Default is 4 to give a 128-bit entropy pool. 8 (for 256 bits) is another reasonable choice if working with larger PRNGs, but there is very little to be gained by selecting another value.</source>
          <target state="translated">要存储的熵池大小。默认值是4,给出一个128位的熵池。如果使用较大的PRNG,8(对于256位)是另一个合理的选择,但选择其他值的好处不大。</target>
        </trans-unit>
        <trans-unit id="425427638096d8909ac722e80f2f8c0179bde19c" translate="yes" xml:space="preserve">
          <source>Size of the returned identity matrix.</source>
          <target state="translated">返回身份矩阵的大小。</target>
        </trans-unit>
        <trans-unit id="c4824192ad4385f49198eaabf9b1f747f0e02ed6" translate="yes" xml:space="preserve">
          <source>Size of ufunc buffer in bytes.</source>
          <target state="translated">ufunc缓冲区的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="ad4bbd7cecbd939b77596b18a5178a89c143d6ba" translate="yes" xml:space="preserve">
          <source>Skip the first &lt;code&gt;skiprows&lt;/code&gt; lines, including comments; default: 0.</source>
          <target state="translated">跳过第一 &lt;code&gt;skiprows&lt;/code&gt; 线，包括意见; 默认值：0</target>
        </trans-unit>
        <trans-unit id="ceefed34cafaf5b19edca282e41b54d0f46c4e35" translate="yes" xml:space="preserve">
          <source>Slicing creates a view, whose memory is shared with x:</source>
          <target state="translated">切片创建一个视图,其内存与x共享。</target>
        </trans-unit>
        <trans-unit id="68f51b4a2c9bfa7e4967d12fe3615173471a2867" translate="yes" xml:space="preserve">
          <source>Small results can be suppressed:</source>
          <target state="translated">小的结果可以被压制。</target>
        </trans-unit>
        <trans-unit id="55c8d4062bb648b3be6e31f36bb0441eeb936269" translate="yes" xml:space="preserve">
          <source>Smallest (most negative) power of &lt;code&gt;ibeta&lt;/code&gt; consistent with there being no leading zeros in the mantissa.</source>
          <target state="translated">&lt;code&gt;ibeta&lt;/code&gt; 的最小（最负数）次幂，与尾数中没有前导零一致。</target>
        </trans-unit>
        <trans-unit id="5723001a57f6b6652b2b21977d2b2710160cd8a8" translate="yes" xml:space="preserve">
          <source>Smallest (positive) power of &lt;code&gt;ibeta&lt;/code&gt; that causes overflow.</source>
          <target state="translated">&lt;code&gt;ibeta&lt;/code&gt; 的最小（正）幂会导致溢出。</target>
        </trans-unit>
        <trans-unit id="77213ab3e24eed5431e4dc1329418d12eafeda49" translate="yes" xml:space="preserve">
          <source>Smallest size of user-settable internal buffers.</source>
          <target state="translated">用户可设置的最小尺寸的内部缓冲区。</target>
        </trans-unit>
        <trans-unit id="5987afde50b9e89e0e7eef5d3f74c5e410d18d69" translate="yes" xml:space="preserve">
          <source>So if this is true, why not choose the index order that matches what you most expect? In particular, why not define row-ordered images to use the image convention? (This is sometimes referred to as the Fortran convention vs the C convention, thus the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;FORTRAN&amp;rsquo; order options for array ordering in numpy.) The drawback of doing this is potential performance penalties. It&amp;rsquo;s common to access the data sequentially, either implicitly in array operations or explicitly by looping over rows of an image. When that is done, then the data will be accessed in non-optimal order. As the first index is incremented, what is actually happening is that elements spaced far apart in memory are being sequentially accessed, with usually poor memory access speeds. For example, for a two dimensional image &amp;lsquo;im&amp;rsquo; defined so that im[0, 10] represents the value at x=0, y=10. To be consistent with usual Python behavior then im[0] would represent a column at x=0. Yet that data would be spread over the whole array since the data are stored in row order. Despite the flexibility of numpy&amp;rsquo;s indexing, it can&amp;rsquo;t really paper over the fact basic operations are rendered inefficient because of data order or that getting contiguous subarrays is still awkward (e.g., im[:,0] for the first row, vs im[0]), thus one can&amp;rsquo;t use an idiom such as for row in im; for col in im does work, but doesn&amp;rsquo;t yield contiguous column data.</source>
          <target state="translated">因此，如果这是真的，为什么不选择与您最期望的匹配的索引顺序呢？特别是为什么不定义按行排序的图像以使用图像约定？ （这有时被称为Fortran约定与C约定，因此以numpy进行数组排序的'C'和'FORTRAN'排序选项。）这样做的缺点是潜在的性能损失。顺序访问数据是很常见的，既可以隐式地在数组操作中访问，也可以通过循环遍历图像的行来显式访问。完成此操作后，将以非最佳顺序访问数据。随着第一个索引的增加，实际上发生的事情是顺序访问内存中间隔很远的元素，通常访问内存的速度较差。例如，对于定义为使im [0，10]表示x = 0处的值的二维图像&amp;ldquo; im&amp;rdquo;，y = 10。为了与通常的Python行为保持一致，则im [0]将表示x = 0处的列。但是，由于数据按行顺序存储，因此该数据将散布在整个阵列上。尽管numpy的索引具有灵活性，但它无法真正说明由于数据顺序使基本操作效率低下或获取连续子数组仍然很尴尬的事实（例如，第一行的im [：，0]与im [ 0]），因此不能使用诸如im中的row这样的惯用语； for im in col可以工作，但不会产生连续的列数据。它不能真正地说明由于数据顺序使基本操作效率低下或获得连续子数组仍然很尴尬的事实（例如，第一行的im [：，0]与im [0]相对），因此可以不要在im中使用诸如for的成语； for im in col可以工作，但不会产生连续的列数据。它不能真正地说明由于数据顺序使基本操作效率低下或获得连续子数组仍然很尴尬的事实（例如，第一行的im [：，0]与im [0]相对），因此可以不要在im中使用诸如for的成语； for im in col可以工作，但不会产生连续的列数据。</target>
        </trans-unit>
        <trans-unit id="75338853856b7644da267b729869a79f35465ac8" translate="yes" xml:space="preserve">
          <source>So the p-value is about 0.009, which says the null hypothesis has a probability of about 99% of being true.</source>
          <target state="translated">所以p值约为0.009,说明零假设有约99%的概率为真。</target>
        </trans-unit>
        <trans-unit id="b22b13d407a40d9045527bdf90132a3a9fa96895" translate="yes" xml:space="preserve">
          <source>So there is about a 1% chance that the F statistic will exceed 7.62, the measured value is 36, so the null hypothesis is rejected at the 1% level.</source>
          <target state="translated">所以大约有1%的机会,F统计量会超过7.62,测得的数值是36,所以在1%的水平上拒绝零假设。</target>
        </trans-unit>
        <trans-unit id="a6530c806dc81f899a20b29f20f0a01aeaaaf38e" translate="yes" xml:space="preserve">
          <source>So, over 64 months would be required to pay off the loan.</source>
          <target state="translated">所以,需要64个月以上才能还清贷款。</target>
        </trans-unit>
        <trans-unit id="a5004dc1aab93010354b018bb188be79f920df9c" translate="yes" xml:space="preserve">
          <source>So, to end up with the same $15692.93 under the same $100 per month &amp;ldquo;savings plan,&amp;rdquo; for annual interest rates of 4% and 3%, one would need initial investments of $649.27 and $1273.79, respectively.</source>
          <target state="translated">因此，要想在相同的每月100美元的&amp;ldquo;储蓄计划&amp;rdquo;下获得相同的15692.93美元，对于4％和3％的年利率，则分别需要分别为649.27美元和1273.79美元的初始投资。</target>
        </trans-unit>
        <trans-unit id="6ebdb3e9e8d6757481f655d319b1afadf8dc01e9" translate="yes" xml:space="preserve">
          <source>Solution to the system a x = b. Returned shape is identical to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">解决方案ax = b。返回的形状与 &lt;code&gt;b&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="47cd45ea813008c51999b21afe4021732229d27d" translate="yes" xml:space="preserve">
          <source>Solve a linear matrix equation, or system of linear scalar equations.</source>
          <target state="translated">解线性矩阵方程,或线性标量方程组。</target>
        </trans-unit>
        <trans-unit id="f401130634f936a923b84a9e812b9c0958189ce8" translate="yes" xml:space="preserve">
          <source>Solve the system of equations &lt;code&gt;3 * x0 + x1 = 9&lt;/code&gt; and &lt;code&gt;x0 + 2 * x1 = 8&lt;/code&gt;:</source>
          <target state="translated">解方程组 &lt;code&gt;3 * x0 + x1 = 9&lt;/code&gt; 和 &lt;code&gt;x0 + 2 * x1 = 8&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4fa6a62025edb0c24849f443aeee1762c51d4292" translate="yes" xml:space="preserve">
          <source>Solve the tensor equation &lt;code&gt;a x = b&lt;/code&gt; for x.</source>
          <target state="translated">对x 求解张量方程 &lt;code&gt;a x = b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2662dd226f62ccee1e8db7abb4ac87cf33caa66b" translate="yes" xml:space="preserve">
          <source>Solves the equation</source>
          <target state="translated">解方程</target>
        </trans-unit>
        <trans-unit id="c7e1b491799507ad39ca1efa34833c4a45590d4c" translate="yes" xml:space="preserve">
          <source>Solving equations and inverting matrices</source>
          <target state="translated">解方程和倒矩阵</target>
        </trans-unit>
        <trans-unit id="43b0492eef0c0518822e4513393b1d39235d0d0e" translate="yes" xml:space="preserve">
          <source>Some cases where uint and true alignment are different ()</source>
          <target state="translated">一些uint和true对齐方式不同的情况()。</target>
        </trans-unit>
        <trans-unit id="d1019de292a3b48b30fff1374e4676305929bebd" translate="yes" xml:space="preserve">
          <source>Some cases where uint and true alignment are different (default gcc linux):</source>
          <target state="translated">某些情况下,uint和true对齐方式是不同的(默认gcc linux)。</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">一些例子:</target>
        </trans-unit>
        <trans-unit id="8c00107ac79c20e1a081f03fb6cbaba3191f960b" translate="yes" xml:space="preserve">
          <source>Some of the scalar types are essentially equivalent to fundamental Python types and therefore inherit from them as well as from the generic array scalar type:</source>
          <target state="translated">一些标量类型本质上等同于Python的基本类型,因此它们和通用数组标量类型一样,都是继承自它们。</target>
        </trans-unit>
        <trans-unit id="c85e63aec45df025bea301bcb4bf6b89b178cf85" translate="yes" xml:space="preserve">
          <source>Some old Fortran codes need special compiler options in order to work correctly. In order to specify compiler options per source file, &lt;code&gt;numpy.distutils&lt;/code&gt; Fortran compiler looks for the following pattern:</source>
          <target state="translated">一些旧的Fortran代码需要特殊的编译器选项才能正常工作。为了指定每个源文件的编译器选项， &lt;code&gt;numpy.distutils&lt;/code&gt; Fortran编译器将寻找以下模式：</target>
        </trans-unit>
        <trans-unit id="b279d322696735803b77494e0d85658168ba5e97" translate="yes" xml:space="preserve">
          <source>Some spreadsheet programs calculate the &amp;ldquo;floor-towards-zero&amp;rdquo;, in other words &lt;code&gt;floor(-2.5) == -2&lt;/code&gt;. NumPy instead uses the definition of &lt;a href=&quot;#numpy.floor&quot;&gt;&lt;code&gt;floor&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;floor(-2.5) == -3&lt;/code&gt;.</source>
          <target state="translated">一些电子表格程序会计算&amp;ldquo;地板朝零&amp;rdquo;，即 &lt;code&gt;floor(-2.5) == -2&lt;/code&gt; 。NumPy改为使用&lt;a href=&quot;#numpy.floor&quot;&gt; &lt;code&gt;floor&lt;/code&gt; &lt;/a&gt;的定义，其中 &lt;code&gt;floor(-2.5) == -3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e076ea295087ca8af80708dc44915c8314e4840f" translate="yes" xml:space="preserve">
          <source>Some useful aliases of the above types are</source>
          <target state="translated">上述类型的一些有用的别名是</target>
        </trans-unit>
        <trans-unit id="1671b95e5ffbf1238a81b8297939415d3fd1114c" translate="yes" xml:space="preserve">
          <source>Something like the following code can be used to support both &lt;code&gt;RandomState&lt;/code&gt; and &lt;code&gt;Generator&lt;/code&gt;, with the understanding that the interfaces are slightly different</source>
          <target state="translated">在理解接口略有不同的 &lt;code&gt;RandomState&lt;/code&gt; ，可以使用以下代码来支持RandomState和 &lt;code&gt;Generator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9467a0f0b915a6467304173ebaf28fafa38f3924" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to access a multidimensional array as a C-style multi-dimensional array so that algorithms can be implemented using C&amp;rsquo;s a[i][j][k] syntax. This routine returns a pointer, &lt;em&gt;ptr&lt;/em&gt;, that simulates this kind of C-style array, for 1-, 2-, and 3-d ndarrays.</source>
          <target state="translated">有时，将多维数组作为C样式的多维数组进行访问很有用，以便可以使用C的a [i] [j] [k]语法实现算法。此例程返回一个指针&lt;em&gt;ptr&lt;/em&gt;，该指针针对1-d，2-d和3-d ndarray模拟这种C样式的数组。</target>
        </trans-unit>
        <trans-unit id="ec72337ff3c83f7940812234b3ba998c6f082e9e" translate="yes" xml:space="preserve">
          <source>Sometimes it may be useful to get the N-dimensional index while iterating. The ndenumerate iterator can achieve this.</source>
          <target state="translated">有时候,在迭代的同时,可能需要得到N维的索引。ndenumerate迭代器可以实现这一点。</target>
        </trans-unit>
        <trans-unit id="0744d9126505450547757e296c542c0b00376d4c" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to skip a test or mark it as a known failure, such as when the test suite is being written before the code it&amp;rsquo;s meant to test, or if a test only fails on a particular architecture.</source>
          <target state="translated">有时，您可能想跳过测试或将其标记为已知的失败，例如在将测试套件编写在要测试的代码之前编写测试套件时，或者测试仅在特定体系结构上失败时。</target>
        </trans-unit>
        <trans-unit id="c295e72861adbd23ef6b2dcbfed6577dacefe499" translate="yes" xml:space="preserve">
          <source>Sometimes, the best approach is to use the &lt;code&gt;%extend&lt;/code&gt; directive to define new methods for your classes (or overload existing ones) that take a &lt;code&gt;PyObject*&lt;/code&gt; (that either is or can be converted to a &lt;code&gt;PyArrayObject*&lt;/code&gt;) instead of a pointer to a buffer. In this case, the helper routines in &lt;code&gt;numpy.i&lt;/code&gt; can be very useful.</source>
          <target state="translated">有时，最好的方法是使用 &lt;code&gt;%extend&lt;/code&gt; 指令为采用 &lt;code&gt;PyObject*&lt;/code&gt; （即可以转换为 &lt;code&gt;PyArrayObject*&lt;/code&gt; ）而不是指向缓冲区的指针的类（或重载现有方法）定义新方法。。在这种情况下， &lt;code&gt;numpy.i&lt;/code&gt; 中的帮助程序例程可能非常有用。</target>
        </trans-unit>
        <trans-unit id="013e7e93c49d182f82742c8920c97f56d061e7e4" translate="yes" xml:space="preserve">
          <source>Somewhat more sophisticated example</source>
          <target state="translated">稍微复杂一点的例子</target>
        </trans-unit>
        <trans-unit id="328b7438e36cdae2c28d64a3dd3bc7ddc0df1e77" translate="yes" xml:space="preserve">
          <source>Sort a complex array using the real part first, then the imaginary part.</source>
          <target state="translated">先用实部,再用虚部对复数组进行排序。</target>
        </trans-unit>
        <trans-unit id="7703cef2dff0050a3552375a078ec7f70589b4bd" translate="yes" xml:space="preserve">
          <source>Sort an array in-place.</source>
          <target state="translated">对一个数组进行就地排序。</target>
        </trans-unit>
        <trans-unit id="758912cadfdc3e6db6c081dc567a966e86a886f3" translate="yes" xml:space="preserve">
          <source>Sort an array in-place. Refer to &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;numpy.sort&lt;/code&gt;&lt;/a&gt; for full documentation.</source>
          <target state="translated">就地排序数组。有关完整文档，请参考&lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;numpy.sort&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e971cf5812926cfacabdee56dc64c56ffada0b99" translate="yes" xml:space="preserve">
          <source>Sort by age, then height if ages are equal:</source>
          <target state="translated">按年龄排序,如果年龄相同,则按身高排序。</target>
        </trans-unit>
        <trans-unit id="edf066d3ae816f3adbcc852b784794ee538b1cc5" translate="yes" xml:space="preserve">
          <source>Sort names: first by surname, then by name.</source>
          <target state="translated">姓名排序:先按姓氏排序,再按姓名排序。</target>
        </trans-unit>
        <trans-unit id="c29b838e8a5ddeb05ab8f84b06787846a1a439df" translate="yes" xml:space="preserve">
          <source>Sort the array, in-place</source>
          <target state="translated">对数组进行排序,就地取材</target>
        </trans-unit>
        <trans-unit id="b84eb35a33eb1b763dfde94c1db6ce2176107aa8" translate="yes" xml:space="preserve">
          <source>Sort two columns of numbers:</source>
          <target state="translated">对两列数字进行排序。</target>
        </trans-unit>
        <trans-unit id="880e5dacaffdb29c387c406a9aa16d00ec9b6165" translate="yes" xml:space="preserve">
          <source>Sorted 1D array of common and unique elements.</source>
          <target state="translated">普通元素和独特元素的排序1D数组。</target>
        </trans-unit>
        <trans-unit id="2b58c607b5c87ff5c9488ade6840a7c97cabbe74" translate="yes" xml:space="preserve">
          <source>Sorted 1D array of unique values that are in only one of the input arrays.</source>
          <target state="translated">排序后的1D数组中只有一个输入数组的唯一值。</target>
        </trans-unit>
        <trans-unit id="378e9e163b7eecefadb4415cae533096e336c4ab" translate="yes" xml:space="preserve">
          <source>Sorting</source>
          <target state="translated">Sorting</target>
        </trans-unit>
        <trans-unit id="ba112ceba77d3fead905df9fb056b8ffb7481e25" translate="yes" xml:space="preserve">
          <source>Sorting algorithm. The default is &amp;lsquo;quicksort&amp;rsquo;. Note that both &amp;lsquo;stable&amp;rsquo; and &amp;lsquo;mergesort&amp;rsquo; use timsort or radix sort under the covers and, in general, the actual implementation will vary with data type. The &amp;lsquo;mergesort&amp;rsquo; option is retained for backwards compatibility.</source>
          <target state="translated">排序算法。默认值为&amp;ldquo;快速排序&amp;rdquo;。请注意，&amp;ldquo;稳定&amp;rdquo;和&amp;ldquo;合并排序&amp;rdquo;在后台都使用timsort或基数排序，并且通常，实际实现会随数据类型而变化。保留'mergesort'选项是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="0575bbf541bc6691bd2f441dd799bc35084ddbf2" translate="yes" xml:space="preserve">
          <source>Sorting algorithm. The default is &amp;lsquo;quicksort&amp;rsquo;. Note that both &amp;lsquo;stable&amp;rsquo; and &amp;lsquo;mergesort&amp;rsquo; use timsort under the covers and, in general, the actual implementation will vary with data type. The &amp;lsquo;mergesort&amp;rsquo; option is retained for backwards compatibility.</source>
          <target state="translated">排序算法。默认值为&amp;ldquo;快速排序&amp;rdquo;。请注意，&amp;ldquo;稳定&amp;rdquo;和&amp;ldquo;合并排序&amp;rdquo;在后台都使用timsort，并且通常，实际实现会随数据类型而变化。保留'mergesort'选项是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="2cdbbd83ff8697bca9c84ed001e2e5d899425b4f" translate="yes" xml:space="preserve">
          <source>Sorting algorithm. The default is &amp;lsquo;quicksort&amp;rsquo;. Note that both &amp;lsquo;stable&amp;rsquo; and &amp;lsquo;mergesort&amp;rsquo; use timsort under the covers and, in general, the actual implementation will vary with datatype. The &amp;lsquo;mergesort&amp;rsquo; option is retained for backwards compatibility.</source>
          <target state="translated">排序算法。默认值为&amp;ldquo;快速排序&amp;rdquo;。请注意，&amp;ldquo;稳定&amp;rdquo;和&amp;ldquo;合并排序&amp;rdquo;在后台都使用timsort，并且通常情况下，实际实现会随数据类型而变化。保留'mergesort'选项是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="bdc99b8f2211c27e95a7ae2ea3c4e510c89721f9" translate="yes" xml:space="preserve">
          <source>Sorting with keys:</source>
          <target state="translated">用钥匙排序。</target>
        </trans-unit>
        <trans-unit id="26d009fe61cd6c804332028c785b29bfb52d084f" translate="yes" xml:space="preserve">
          <source>Sorting, searching, and counting</source>
          <target state="translated">排序、搜索和计数</target>
        </trans-unit>
        <trans-unit id="6767832dfbb08054083a5a2806dbcbcc61e43981" translate="yes" xml:space="preserve">
          <source>Source array</source>
          <target state="translated">源数组</target>
        </trans-unit>
        <trans-unit id="f129cc36c0cc30f28b30e1834c4eba00a6a6b06e" translate="yes" xml:space="preserve">
          <source>Source of entropy. &amp;lsquo;system&amp;rsquo; uses system cryptographic pool. &amp;lsquo;fallback&amp;rsquo; uses a hash of the time and process id.</source>
          <target state="translated">熵的来源。&amp;ldquo;系统&amp;rdquo;使用系统密码池。&amp;ldquo;后备&amp;rdquo;使用时间和进程ID的哈希值。</target>
        </trans-unit>
        <trans-unit id="dc1737b3b1fae12e4ca81687b7ce0c8d06e3bfa1" translate="yes" xml:space="preserve">
          <source>Spacing between f values. Default unitary spacing for all dimensions. Spacing can be specified using:</source>
          <target state="translated">f值之间的间距。所有尺寸的默认单位间距。间距可以用:</target>
        </trans-unit>
        <trans-unit id="534a506bdd04ed14f369aaa8c5d2a5a1b475cf75" translate="yes" xml:space="preserve">
          <source>Spacing between values. For any output &lt;code&gt;out&lt;/code&gt;, this is the distance between two adjacent values, &lt;code&gt;out[i+1] - out[i]&lt;/code&gt;. The default step size is 1. If &lt;code&gt;step&lt;/code&gt; is specified as a position argument, &lt;code&gt;start&lt;/code&gt; must also be given.</source>
          <target state="translated">值之间的间距。对于任何输出 &lt;code&gt;out&lt;/code&gt; ，这是两个相邻值 &lt;code&gt;out[i+1] - out[i]&lt;/code&gt; 之间的距离。默认步长为1。如果将 &lt;code&gt;step&lt;/code&gt; 指定为位置参数，则还必须指定 &lt;code&gt;start&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b1c83ae389903de1c17429b8031bd633cfea38a" translate="yes" xml:space="preserve">
          <source>Spacing can be also specified with an array that represents the coordinates of the values F along the dimensions. For instance a uniform spacing:</source>
          <target state="translated">间距也可以用一个数组来指定,这个数组表示F值沿维度的坐标。例如统一的间距。</target>
        </trans-unit>
        <trans-unit id="3c1452a3b0205f538f941fa6e2df87a5606ff452" translate="yes" xml:space="preserve">
          <source>Spacing of +- inf and NaN is NaN.</source>
          <target state="translated">+-inf和NaN的间距为NaN。</target>
        </trans-unit>
        <trans-unit id="23afed8ee1674d2a0d0a6b27d54e26458214a09b" translate="yes" xml:space="preserve">
          <source>Spawn a number of child &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; s by extending the &lt;a href=&quot;numpy.random.seedsequence.spawn_key#numpy.random.SeedSequence.spawn_key&quot;&gt;&lt;code&gt;spawn_key&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">酿出了许多孩子&lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;通过扩展的S &lt;a href=&quot;numpy.random.seedsequence.spawn_key#numpy.random.SeedSequence.spawn_key&quot;&gt; &lt;code&gt;spawn_key&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="91b21b0aabd8c374de6706b913967d168827f182" translate="yes" xml:space="preserve">
          <source>Spawn a number of child &lt;a href=&quot;numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; s by extending the &lt;a href=&quot;numpy.random.seedsequence.spawn_key#numpy.random.SeedSequence.spawn_key&quot;&gt;&lt;code&gt;spawn_key&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">酿出了许多孩子&lt;a href=&quot;numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;通过扩展的S &lt;a href=&quot;numpy.random.seedsequence.spawn_key#numpy.random.SeedSequence.spawn_key&quot;&gt; &lt;code&gt;spawn_key&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3011c57bc17adfb34d1d5b7d2a537f2f42b61ecd" translate="yes" xml:space="preserve">
          <source>Spawn a number of child &lt;code&gt;SeedSequence&lt;/code&gt; s by extending the &lt;code&gt;spawn_key&lt;/code&gt;.</source>
          <target state="translated">酿出了许多孩子 &lt;code&gt;SeedSequence&lt;/code&gt; 通过扩展的S &lt;code&gt;spawn_key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5bdcbf562b3722f869ecc22fc6f007711257a292" translate="yes" xml:space="preserve">
          <source>Special attributes and methods</source>
          <target state="translated">特殊属性和方法</target>
        </trans-unit>
        <trans-unit id="aed4a5ac93d537d2fee54607e067f0fcd734c2a7" translate="yes" xml:space="preserve">
          <source>Special case of &lt;a href=&quot;#c.PyArray_EquivTypes&quot;&gt;&lt;code&gt;PyArray_EquivTypes&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) that does not accept flexible data types but may be easier to call.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArray_EquivTypes&quot;&gt; &lt;code&gt;PyArray_EquivTypes&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）的特殊情况，它不接受灵活的数据类型，但可能更容易调用。</target>
        </trans-unit>
        <trans-unit id="1fe419ca9a2135cb73cdfe673bb644f8c5d089ef" translate="yes" xml:space="preserve">
          <source>Special case of &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; for when &lt;em&gt;op&lt;/em&gt; is already an array but it needs to be of a specific &lt;em&gt;newtype&lt;/em&gt; (including byte-order) or has certain &lt;em&gt;requirements&lt;/em&gt;.</source>
          <target state="translated">的特殊情况&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;用于当&lt;em&gt;运&lt;/em&gt;已经是一个阵列，但它需要一个特定的&lt;em&gt;NEWTYPE&lt;/em&gt;（包括字节顺序）或有一定的&lt;em&gt;要求&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="60bf3781f7b69622f4280d80dab8f4e70529bfe8" translate="yes" xml:space="preserve">
          <source>Special functions for NPY_OBJECT</source>
          <target state="translated">NPY_OBJECT的特殊功能</target>
        </trans-unit>
        <trans-unit id="b3dfcf123c0344e2a770caf2c6d80f585312a2df" translate="yes" xml:space="preserve">
          <source>Special hook for ufuncs.</source>
          <target state="translated">Ufuncs的专用挂钩。</target>
        </trans-unit>
        <trans-unit id="93a7e480fca31e54d3a1bf415987f972c987379d" translate="yes" xml:space="preserve">
          <source>Special methods</source>
          <target state="translated">特殊方法</target>
        </trans-unit>
        <trans-unit id="3002d8550adc7583b9e34c0e71be4f097501b6cb" translate="yes" xml:space="preserve">
          <source>Specific methods</source>
          <target state="translated">具体方法</target>
        </trans-unit>
        <trans-unit id="cf2f0aad66d259134ba110faea6639bae5dba0cf" translate="yes" xml:space="preserve">
          <source>Specifies how indices outside &lt;code&gt;[0, n-1]&lt;/code&gt; will be treated:</source>
          <target state="translated">指定如何处理 &lt;code&gt;[0, n-1]&lt;/code&gt; 以外的索引：</target>
        </trans-unit>
        <trans-unit id="a7fddec5bc5d09611a6a6411474f1557bfcece40" translate="yes" xml:space="preserve">
          <source>Specifies how out-of-bounds indices are handled. Can specify either one mode or a tuple of modes, one mode per index.</source>
          <target state="translated">指定如何处理越界索引。可以指定一个模式或一个模式元组,每个索引一个模式。</target>
        </trans-unit>
        <trans-unit id="bd5a8d9eaa67a4089d4d8ea6c9d2499b271531d4" translate="yes" xml:space="preserve">
          <source>Specifies how out-of-bounds indices will behave.</source>
          <target state="translated">指定越界指数的表现。</target>
        </trans-unit>
        <trans-unit id="0c82c7d4c03f4e3d40af4885f34fa55cd32452a2" translate="yes" xml:space="preserve">
          <source>Specifies how out-of-bounds indices will behave. &amp;lsquo;raise&amp;rsquo; : raise an error. &amp;lsquo;wrap&amp;rsquo; : wrap around. &amp;lsquo;clip&amp;rsquo; : clip to the range.</source>
          <target state="translated">指定越界索引的行为。'raise'：引发一个错误。'环绕'：环绕。'clip'：裁剪到范围。</target>
        </trans-unit>
        <trans-unit id="613844173fd200c8dfdc2aaedd515354fe3b2a25" translate="yes" xml:space="preserve">
          <source>Specifies how to handle encoding errors</source>
          <target state="translated">指定如何处理编码错误</target>
        </trans-unit>
        <trans-unit id="9b982562ff1b137afe496fb00468655c2065dda1" translate="yes" xml:space="preserve">
          <source>Specifies the calculation iteration order/memory layout of the output array. Defaults to &amp;lsquo;K&amp;rsquo;. &amp;lsquo;C&amp;rsquo; means the output should be C-contiguous, &amp;lsquo;F&amp;rsquo; means F-contiguous, &amp;lsquo;A&amp;rsquo; means F-contiguous if the inputs are F-contiguous and not also not C-contiguous, C-contiguous otherwise, and &amp;lsquo;K&amp;rsquo; means to match the element ordering of the inputs as closely as possible.</source>
          <target state="translated">指定输出数组的计算迭代顺序/内存布局。默认为&amp;ldquo; K&amp;rdquo;。'C'表示输出应该是C连续的，'F'表示F是连续的，如果输入是F连续的并且不是C连续的，'A'是F连续的，否则输入是C连续的，'K '表示要尽可能匹配输入的元素顺序。</target>
        </trans-unit>
        <trans-unit id="050a737d589d7084aca709c1606453929922c13e" translate="yes" xml:space="preserve">
          <source>Specifies the minimum number of dimensions that the resulting array should have. Ones will be pre-pended to the shape as needed to meet this requirement.</source>
          <target state="translated">指定生成的数组的最小维数。根据需要,将在形状上预先添加一,以满足这一要求。</target>
        </trans-unit>
        <trans-unit id="1931e4d3fdc0bcca4a66f0fb2135dc85de6a0cb0" translate="yes" xml:space="preserve">
          <source>Specifies the subscripts for summation as comma separated list of subscript labels. An implicit (classical Einstein summation) calculation is performed unless the explicit indicator &amp;lsquo;-&amp;gt;&amp;rsquo; is included as well as subscript labels of the precise output form.</source>
          <target state="translated">将要求和的下标指定为下标标签的逗号分隔列表。除非包含显式指示符&amp;ldquo;-&amp;gt;&amp;rdquo;以及精确输出形式的下标标签，否则将执行隐式（经典的爱因斯坦求和）计算。</target>
        </trans-unit>
        <trans-unit id="7ecc55fddab59538bed27df3a80b7134cf4b1452" translate="yes" xml:space="preserve">
          <source>Specifies the subscripts for summation.</source>
          <target state="translated">指定求和的下标。</target>
        </trans-unit>
        <trans-unit id="dc782b605bddd3902febdfde45c4deaed380a257" translate="yes" xml:space="preserve">
          <source>Specifies whether the calculation is done with the lower triangular part of &lt;code&gt;a&lt;/code&gt; (&amp;lsquo;L&amp;rsquo;, default) or the upper triangular part (&amp;lsquo;U&amp;rsquo;). Irrespective of this value only the real parts of the diagonal will be considered in the computation to preserve the notion of a Hermitian matrix. It therefore follows that the imaginary part of the diagonal will always be treated as zero.</source>
          <target state="translated">指定的计算是否与的下三角部分进行 &lt;code&gt;a&lt;/code&gt; （&amp;ldquo;L&amp;rdquo;，缺省值）或上三角部分（&amp;ldquo;U&amp;rdquo;）。不管该值如何，在计算中仅考虑对角线的实部以保留厄米矩阵的概念。因此得出结论，对角线的虚部将始终被视为零。</target>
        </trans-unit>
        <trans-unit id="84b53fe298f53e60bfe5c134c03be76d2e5954a6" translate="yes" xml:space="preserve">
          <source>Specify &lt;code&gt;count&lt;/code&gt; to improve performance. It allows &lt;code&gt;fromiter&lt;/code&gt; to pre-allocate the output array, instead of resizing it on demand.</source>
          <target state="translated">指定 &lt;code&gt;count&lt;/code&gt; 以提高性能。它允许 &lt;code&gt;fromiter&lt;/code&gt; 预先分配输出数组，而不是按需调整大小。</target>
        </trans-unit>
        <trans-unit id="a2559f8e80c3826a37d110b99c7697f1e76b2b76" translate="yes" xml:space="preserve">
          <source>Specify the memory layout of the array. If object is not an array, the newly created array will be in C order (row major) unless &amp;lsquo;F&amp;rsquo; is specified, in which case it will be in Fortran order (column major). If object is an array the following holds.</source>
          <target state="translated">指定阵列的内存布局。如果object不是数组，则除非指定'F'，否则新创建的数组将以C顺序（行主），在这种情况下，它将以Fortran顺序（行主）。如果object是一个数组，则以下成立。</target>
        </trans-unit>
        <trans-unit id="c44bd2c1faa32dfad2b525474c59d5dbcd2e61f5" translate="yes" xml:space="preserve">
          <source>Specify the order of the array. If order is &amp;lsquo;C&amp;rsquo; (default), then the array will be in C-contiguous order (last-index varies the fastest). If order is &amp;lsquo;F&amp;rsquo;, then the returned array will be in Fortran-contiguous order (first-index varies the fastest).</source>
          <target state="translated">指定数组的顺序。如果order为'C'（默认值），则数组将为C连续顺序（last-index变化最快）。如果order为'F'，则返回的数组将为Fortran连续的顺序（first-index变化最快）。</target>
        </trans-unit>
        <trans-unit id="8f0736b76ded7485aa40ce78476b297a664e4a9e" translate="yes" xml:space="preserve">
          <source>Specify the order of the array. If order is &amp;lsquo;C&amp;rsquo; (default), then the array will be in C-contiguous order (last-index varies the fastest). If order is &amp;lsquo;F&amp;rsquo;, then the returned array will be in Fortran-contiguous order (first-index varies the fastest). If order is &amp;lsquo;A&amp;rsquo;, then the returned array may be in any order (either C-, Fortran-contiguous, or even discontiguous).</source>
          <target state="translated">指定数组的顺序。如果order为'C'（默认值），则数组将为C连续顺序（last-index变化最快）。如果order为'F'，则返回的数组将为Fortran连续顺序（first-index变化最快）。如果order为'A'，则返回的数组可以为任何顺序（C-，Fortran连续或什至不连续）。</target>
        </trans-unit>
        <trans-unit id="21cff05ed82b999db4c7f573fea17c64f4478c68" translate="yes" xml:space="preserve">
          <source>Specify the order of the array. If order is &amp;lsquo;C&amp;rsquo;, then the array will be in C-contiguous order (last-index varies the fastest). If order is &amp;lsquo;F&amp;rsquo;, then the returned array will be in Fortran-contiguous order (first-index varies the fastest). If order is &amp;lsquo;A&amp;rsquo; (default), then the returned array may be in any order (either C-, Fortran-contiguous, or even discontiguous), unless a copy is required, in which case it will be C-contiguous.</source>
          <target state="translated">指定数组的顺序。如果order为'C'，则数组将为C连续顺序（last-index变化最快）。如果order为'F'，则返回的数组将为Fortran连续顺序（first-index变化最快）。如果order为'A'（默认值），则返回的数组可以为任何顺序（C-，Fortran连续或什至不连续），除非需要复制，在这种情况下它将是C连续的。</target>
        </trans-unit>
        <trans-unit id="b4bff2e865a836b411173470fe4113bf016b57f0" translate="yes" xml:space="preserve">
          <source>Specify the order of the ndarray memory layout: &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style or &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-column-major&quot;&gt;column-major&lt;/a&gt;, Fortran-style. This only has an effect if the shape is greater than 1-D. The default order is &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">指定ndarray内存布局的顺序：&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt;，C样式或&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-column-major&quot;&gt;column-major&lt;/a&gt;，Fortran样式。仅当形状大于一维时才有效。默认顺序为&amp;ldquo; C&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="83ad629c93587e0e12f83328a8f66ad92721efa4" translate="yes" xml:space="preserve">
          <source>Specifying and constructing data types</source>
          <target state="translated">指定和构建数据类型</target>
        </trans-unit>
        <trans-unit id="00b91ffde426d9b0a3c3899a390a47a2d221ddad" translate="yes" xml:space="preserve">
          <source>Specifying config_fc options for libraries in setup.py script</source>
          <target state="translated">在setup.py脚本中为库指定config_fc选项。</target>
        </trans-unit>
        <trans-unit id="497ce53e1d016b8475e5f51d0ed03829af1fe8b7" translate="yes" xml:space="preserve">
          <source>Specifying dtype and names</source>
          <target state="translated">指定dtype和名称</target>
        </trans-unit>
        <trans-unit id="99c8805177de6129ae475f67ee264572110d40f8" translate="yes" xml:space="preserve">
          <source>Specifying just the month, but forcing a &amp;lsquo;days&amp;rsquo; unit:</source>
          <target state="translated">仅指定月份，但强制使用&amp;ldquo;天&amp;rdquo;单位：</target>
        </trans-unit>
        <trans-unit id="b3dbb36c7df88f2134e58d3a13401955888547e5" translate="yes" xml:space="preserve">
          <source>Specifying the roots of a polynomial still leaves one degree of freedom, typically represented by an undetermined leading coefficient. &lt;a href=&quot;#r6c2ffae921d1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; In the case of this function, that coefficient - the first one in the returned array - is always taken as one. (If for some reason you have one other point, the only automatic way presently to leverage that information is to use &lt;code&gt;polyfit&lt;/code&gt;.)</source>
          <target state="translated">指定多项式的根仍然保留一个自由度，通常由不确定的前导系数表示。&lt;a href=&quot;#r6c2ffae921d1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;对于此函数，该系数-返回数组中的第一个系数-始终取为1。（如果出于某种原因，您还有其他观点，则目前唯一利用该信息的自动方法是使用 &lt;code&gt;polyfit&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="0b1f4aea2b38e05ca6cff4352833d4c2eead6bd1" translate="yes" xml:space="preserve">
          <source>Speeding up copy operations by using uint assignment in instead of memcpy</source>
          <target state="translated">通过使用uint赋值代替memcpy来加快复制操作。</target>
        </trans-unit>
        <trans-unit id="76bb3aba19733547ddb8d57ed987b6a041161ff6" translate="yes" xml:space="preserve">
          <source>Spherical covariance (&lt;code&gt;cov&lt;/code&gt; is a multiple of the identity matrix)</source>
          <target state="translated">球面协方差（ &lt;code&gt;cov&lt;/code&gt; 是单位矩阵的倍数）</target>
        </trans-unit>
        <trans-unit id="088d71f3f52d7346fd614d711bd267b4c39c4007" translate="yes" xml:space="preserve">
          <source>Split an array into multiple sub-arrays horizontally (column-wise).</source>
          <target state="translated">将一个数组水平分割成多个子数组(以列为单位)。</target>
        </trans-unit>
        <trans-unit id="b5754126c144e79af24aefbc17318a87cc5f7fd2" translate="yes" xml:space="preserve">
          <source>Split an array into multiple sub-arrays of equal or near-equal size.</source>
          <target state="translated">将一个数组分割成多个大小相等或接近相等的子数组。</target>
        </trans-unit>
        <trans-unit id="0cf080dcab286083ff1cc66a435eccc8025f3bbc" translate="yes" xml:space="preserve">
          <source>Split an array into multiple sub-arrays of equal or near-equal size. Does not raise an exception if an equal division cannot be made.</source>
          <target state="translated">将一个数组分割成多个大小相等或接近相等的子数组。如果不能进行等分,不会引发异常。</target>
        </trans-unit>
        <trans-unit id="c6395892c45b206d6b99821cc909fe1d65570f05" translate="yes" xml:space="preserve">
          <source>Split an array into multiple sub-arrays of equal size.</source>
          <target state="translated">将一个数组分割成多个大小相等的子数组。</target>
        </trans-unit>
        <trans-unit id="505aae82481059a2edd349c99b982eb22991f3d7" translate="yes" xml:space="preserve">
          <source>Split an array into multiple sub-arrays vertically (row-wise).</source>
          <target state="translated">将一个数组垂直分割成多个子数组(以行为单位)。</target>
        </trans-unit>
        <trans-unit id="0976bf6e914482518c948616b2a64bfe1f530549" translate="yes" xml:space="preserve">
          <source>Split an array into multiple sub-arrays.</source>
          <target state="translated">将一个数组分割成多个子数组。</target>
        </trans-unit>
        <trans-unit id="ffd00244dfa808ccdb1e357f445723b1de446321" translate="yes" xml:space="preserve">
          <source>Split array along second axis.</source>
          <target state="translated">沿第二轴分割阵列。</target>
        </trans-unit>
        <trans-unit id="19f8340eb834a92f93fbe1b260b02dab12c9b437" translate="yes" xml:space="preserve">
          <source>Split array along third axis.</source>
          <target state="translated">沿第三轴分割阵列。</target>
        </trans-unit>
        <trans-unit id="abb8acff6e092f71fe2d7d85b72048053b4e0289" translate="yes" xml:space="preserve">
          <source>Split array into a list of multiple sub-arrays of equal size.</source>
          <target state="translated">将数组分割成多个大小相同的子数组列表。</target>
        </trans-unit>
        <trans-unit id="eeb46fbf791ef3d6b7513aae13670bfd1d286c5f" translate="yes" xml:space="preserve">
          <source>Split array into a list of multiple sub-arrays vertically.</source>
          <target state="translated">将数组垂直分割成多个子数组的列表。</target>
        </trans-unit>
        <trans-unit id="08031d3c1e963e5e593f6077f8007bde4094d65a" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays along the 3rd axis (depth).</source>
          <target state="translated">沿第3轴(深度)将阵列分割成多个子阵列。</target>
        </trans-unit>
        <trans-unit id="95260188435af534996db3e9c839aec2ec1973f1" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays horizontally (column wise)</source>
          <target state="translated">将数组水平分割成多个子数组(列式)。</target>
        </trans-unit>
        <trans-unit id="4a58d1a7c17bf5b26ef79c3a68ad7dfd39dc14fd" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays horizontally (column-wise).</source>
          <target state="translated">将数组水平分割成多个子数组(以列为单位)。</target>
        </trans-unit>
        <trans-unit id="aaa399416b95737d5812be5e3aafc40e1bde329d" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays of equal size.</source>
          <target state="translated">将数组分割成多个大小相等的子数组。</target>
        </trans-unit>
        <trans-unit id="32200fb547976d9cdce1bf0123e79ad3d01d45c6" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays vertically (row wise)</source>
          <target state="translated">将数组垂直分割成多个子数组(以行为单位)。</target>
        </trans-unit>
        <trans-unit id="5e2072ff967b60fe048397bbdc922e037ef75e9d" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays vertically (row wise).</source>
          <target state="translated">将数组垂直分割成多个子数组(以行为单位)。</target>
        </trans-unit>
        <trans-unit id="d638a6c0e1614240bc1fdb2bb9a33a3845eee28f" translate="yes" xml:space="preserve">
          <source>Splitting arrays</source>
          <target state="translated">拆分数组</target>
        </trans-unit>
        <trans-unit id="4d58ebaf799f88b14e5a55e0738d2ff6431f8e7d" translate="yes" xml:space="preserve">
          <source>Square identity matrix.</source>
          <target state="translated">平方身份矩阵。</target>
        </trans-unit>
        <trans-unit id="3613d80d3881f6e72e0182c8791baa68e9f04486" translate="yes" xml:space="preserve">
          <source>Square root (of data size) estimator, used by Excel and other programs for its speed and simplicity.</source>
          <target state="translated">平方根(数据大小)估计器,Excel和其他程序使用的速度和简单性。</target>
        </trans-unit>
        <trans-unit id="a20f5de17a778177c1d20a924357600fac4e355d" translate="yes" xml:space="preserve">
          <source>Stack 1-D arrays as columns into a 2-D array.</source>
          <target state="translated">将一维数组作为列堆叠成二维数组。</target>
        </trans-unit>
        <trans-unit id="22aff824a88fb9e372dada7709040605bdecb795" translate="yes" xml:space="preserve">
          <source>Stack a sequence of arrays along a new axis.</source>
          <target state="translated">沿着新的轴堆叠一个数组序列。</target>
        </trans-unit>
        <trans-unit id="b708f3f441cf8b7881ef5ae7003def9a89be1321" translate="yes" xml:space="preserve">
          <source>Stack along first axis.</source>
          <target state="translated">沿着第一轴线叠加。</target>
        </trans-unit>
        <trans-unit id="4e6821d485f2c248408d2340ce48afc4638994d9" translate="yes" xml:space="preserve">
          <source>Stack along second axis.</source>
          <target state="translated">沿着第二轴线堆积。</target>
        </trans-unit>
        <trans-unit id="654d38ec444eb1ee8c9c4cb4064b5c34d10ed04b" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence along a new dimension.</source>
          <target state="translated">沿着一个新的维度依次堆叠数组。</target>
        </trans-unit>
        <trans-unit id="8075374116f55fd4a715fc7ce7ce68e6a94d1c6b" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence depth wise (along third axis).</source>
          <target state="translated">按顺序深度堆叠数组(沿第三轴)。</target>
        </trans-unit>
        <trans-unit id="49771b17dcab7c55c17889eac7ab065c2d3411f8" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence depth wise (along third dimension)</source>
          <target state="translated">按深度顺序堆栈数组(沿第三维)。</target>
        </trans-unit>
        <trans-unit id="d03609f09d0072b17b53d7c9e81abc547dbe26af" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence depth wise (along third dimension).</source>
          <target state="translated">按顺序深度堆叠数组(沿第三维)。</target>
        </trans-unit>
        <trans-unit id="9d4bdc812ef44d6a84449088558f278a7a04fd89" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence horizontally (column wise)</source>
          <target state="translated">依次水平堆叠数组(列式)。</target>
        </trans-unit>
        <trans-unit id="ab9d3847a31919c576029d377c5a503add8ffa12" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence horizontally (column wise).</source>
          <target state="translated">依次水平堆叠数组(以列为单位)。</target>
        </trans-unit>
        <trans-unit id="6895241ba9b7ce75e412efb0b37cc740ec4c6f5a" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence vertically (row wise)</source>
          <target state="translated">依次垂直堆叠数组(以行为单位)。</target>
        </trans-unit>
        <trans-unit id="d3ccf82c78c83570433d65f4d8ae10b7fd8977b2" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence vertically (row wise).</source>
          <target state="translated">按顺序垂直堆叠数组(以行为单位)。</target>
        </trans-unit>
        <trans-unit id="8085e023a3bd83539ee52ab6920d2f5d11c78066" translate="yes" xml:space="preserve">
          <source>Stacks of matrices are broadcast together as if the matrices were elements, respecting the signature &lt;code&gt;(n,k),(k,m)-&amp;gt;(n,m)&lt;/code&gt;:</source>
          <target state="translated">将矩阵堆栈一起广播，就好像矩阵是元素一样，同时尊重签名 &lt;code&gt;(n,k),(k,m)-&amp;gt;(n,m)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d04797e8ae7899c2001f6f6340094625d64a3d75" translate="yes" xml:space="preserve">
          <source>Stacks of object matrices are not currently supported.</source>
          <target state="translated">目前不支持对象矩阵的堆栈。</target>
        </trans-unit>
        <trans-unit id="67bfee426b8f29b7c1b147b264c4ea92422abbce" translate="yes" xml:space="preserve">
          <source>Stadlober, Ernst, &amp;ldquo;The ratio of uniforms approach for generating discrete random variates&amp;rdquo;, Journal of Computational and Applied Mathematics, 31, pp. 181-189 (1990).</source>
          <target state="translated">Stadlober，Ernst，&amp;ldquo;用于生成离散随机变量的均匀法方法&amp;rdquo;，《计算与应用数学学报》，第31卷，第181-189页（1990）。</target>
        </trans-unit>
        <trans-unit id="6555192e9f6da8cd095b33f3c4f7b71a9783ffae" translate="yes" xml:space="preserve">
          <source>Standard Exponentials (&lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">标准指数（&lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="a76b8a339223d559651cacde3723ee6065b8680a" translate="yes" xml:space="preserve">
          <source>Standard FFTs</source>
          <target state="translated">标准FFTs</target>
        </trans-unit>
        <trans-unit id="8a50b57204e2e599132c00b62a1be1df8baa7ef4" translate="yes" xml:space="preserve">
          <source>Standard Gammas (&lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">标准伽玛（&lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="6acbc6354e507f6042f5f9e2e8ed73fc0f0df274" translate="yes" xml:space="preserve">
          <source>Standard array subclasses</source>
          <target state="translated">标准数组子类</target>
        </trans-unit>
        <trans-unit id="cc94a4125e37461a7eb45a58071de9b78020fdd7" translate="yes" xml:space="preserve">
          <source>Standard container class</source>
          <target state="translated">标准容器类</target>
        </trans-unit>
        <trans-unit id="d97a83beb388d3e9a736d669dd24314ad1c4c05d" translate="yes" xml:space="preserve">
          <source>Standard container-class for easy multiple-inheritance.</source>
          <target state="translated">标准容器类,便于多继承。</target>
        </trans-unit>
        <trans-unit id="fd746f492ad659d3f7460598edb734faace83b3c" translate="yes" xml:space="preserve">
          <source>Standard deviation</source>
          <target state="translated">标准偏差</target>
        </trans-unit>
        <trans-unit id="abfc13a248e3a8f054556e98e30f2c835c7640af" translate="yes" xml:space="preserve">
          <source>Standard deviation (spread or &amp;ldquo;width&amp;rdquo;) of the distribution. Must be non-negative.</source>
          <target state="translated">分布的标准偏差（展开或&amp;ldquo;宽度&amp;rdquo;）。必须为非负数。</target>
        </trans-unit>
        <trans-unit id="353ecc8b9a821fe897c9828f33c52edee66e1903" translate="yes" xml:space="preserve">
          <source>Standard deviation of the underlying normal distribution. Must be non-negative. Default is 1.</source>
          <target state="translated">基本正态分布的标准差。必须为非负值。默认值为1。</target>
        </trans-unit>
        <trans-unit id="23af397f01a5349c3364864801bdaded9c9fd69b" translate="yes" xml:space="preserve">
          <source>Standard division.</source>
          <target state="translated">标准划分:</target>
        </trans-unit>
        <trans-unit id="41e65f8d183f4a9b208031a1e27c9fa561f1fc26" translate="yes" xml:space="preserve">
          <source>Standard iterator method, returns the index tuple and array value.</source>
          <target state="translated">标准迭代器方法,返回索引元组和数组值。</target>
        </trans-unit>
        <trans-unit id="5dc1c8c87cf79f5d6e41fc7b3d5b58a53840de0c" translate="yes" xml:space="preserve">
          <source>Standard iterator method, updates the index and returns the index tuple.</source>
          <target state="translated">标准迭代器方法,更新索引并返回索引元组。</target>
        </trans-unit>
        <trans-unit id="df808e9a53d2f9ad1713cebd06d023de29058b1f" translate="yes" xml:space="preserve">
          <source>Start of interval. The interval includes this value. The default start value is 0.</source>
          <target state="translated">区间的开始。间隔包括这个值。默认的起始值为0。</target>
        </trans-unit>
        <trans-unit id="e3d56ccfa43387f906331b5afa2c49c8c391ba34" translate="yes" xml:space="preserve">
          <source>Start reading buffer (&lt;code&gt;buf&lt;/code&gt;) from this offset onwards.</source>
          <target state="translated">从此偏移量开始读取缓冲区（ &lt;code&gt;buf&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8a8f60afc4e5d9508e376d3a267b217a51489d68" translate="yes" xml:space="preserve">
          <source>Start reading the buffer from this offset (in bytes); default: 0.</source>
          <target state="translated">从这个偏移量开始读取缓冲区(单位:字节);默认:0。</target>
        </trans-unit>
        <trans-unit id="ddcac8bcdcee9d908ef620776b7aaacfebecb3f8" translate="yes" xml:space="preserve">
          <source>Start search at this level.</source>
          <target state="translated">从这个层面开始搜索。</target>
        </trans-unit>
        <trans-unit id="1b68451d2955d61b15e001c6fdcdc0d7038975d3" translate="yes" xml:space="preserve">
          <source>Starting from numpy 1.3.0, we are working on separating the pure C, &amp;ldquo;computational&amp;rdquo; code from the python dependent code. The goal is twofolds: making the code cleaner, and enabling code reuse by other extensions outside numpy (scipy, etc&amp;hellip;).</source>
          <target state="translated">从numpy 1.3.0开始，我们正在将纯C&amp;ldquo;计算&amp;rdquo;代码与python依赖代码分开。目标是双重的：使代码更整洁，并使numpy之外的其他扩展（scipy等）实现代码重用。</target>
        </trans-unit>
        <trans-unit id="190bfe8a8e41d4d3adc0d8967b2fb6cda62c785e" translate="yes" xml:space="preserve">
          <source>Starting guess for solving the rate of interest, default 0.1</source>
          <target state="translated">解利率的起始猜测,默认0.1。</target>
        </trans-unit>
        <trans-unit id="1998183b3f42c5d604f45eee6e025b0b95e779c9" translate="yes" xml:space="preserve">
          <source>Starting in NumPy 1.7, there are core array data types which natively support datetime functionality. The data type is called &amp;ldquo;datetime64&amp;rdquo;, so named because &amp;ldquo;datetime&amp;rdquo; is already taken by the datetime library included in Python.</source>
          <target state="translated">从NumPy 1.7开始，有些核心数组数据类型本身支持日期时间功能。数据类型称为&amp;ldquo; datetime64&amp;rdquo;，之所以这样命名是因为Python中包含的datetime库已经采用了&amp;ldquo; datetime&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e4430717cba93d1575e5d9028fa5b9735d7a5640" translate="yes" xml:space="preserve">
          <source>Starting in NumPy 1.9 it returns a read-only view on the original array. Attempting to write to the resulting array will produce an error.</source>
          <target state="translated">从NumPy 1.9开始,它返回一个只读的原始数组视图。试图对结果数组进行写入将产生一个错误。</target>
        </trans-unit>
        <trans-unit id="03579e07c4a86e15aa2daa8e0ee5d8b2de28c77b" translate="yes" xml:space="preserve">
          <source>Starting in NumPy 1.9, promote_types function now returns a valid string length when given an integer or float dtype as one argument and a string dtype as another argument. Previously it always returned the input string dtype, even if it wasn&amp;rsquo;t long enough to store the max integer/float value converted to a string.</source>
          <target state="translated">从NumPy 1.9开始，promote_types函数现在会在给定整数或浮点dtype作为一个参数而给定字符串dtype作为另一个参数时返回有效的字符串长度。以前，它总是返回输入字符串dtype，即使它的时间不足以存储转换为字符串的最大整数/浮点值。</target>
        </trans-unit>
        <trans-unit id="48acaf98f98fb538de8401c0548aec9b9591fd70" translate="yes" xml:space="preserve">
          <source>Starting value for the sum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">总和的起始值。有关详细信息，请参见&lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="2086b21f8f49274138c38d476bee317a84a8aecc" translate="yes" xml:space="preserve">
          <source>Statistics</source>
          <target state="translated">Statistics</target>
        </trans-unit>
        <trans-unit id="55fdc4e46b10f8815926e76cd96fd99504aad94e" translate="yes" xml:space="preserve">
          <source>Store compressed data to disk, and load it again:</source>
          <target state="translated">将压缩后的数据存储到磁盘上,然后再加载。</target>
        </trans-unit>
        <trans-unit id="c40b4ecf74fcdef0fac2e2b3e7ed1b00b25b3fa6" translate="yes" xml:space="preserve">
          <source>Store data to disk, and load it again:</source>
          <target state="translated">将数据存储到磁盘上,然后再加载。</target>
        </trans-unit>
        <trans-unit id="e1c52dc3262f206eabc8e2236b28e7c92720ec86" translate="yes" xml:space="preserve">
          <source>Stores all of the necessary information to reconstruct the array including shape and dtype on a machine of a different architecture. Both little-endian and big-endian arrays are supported, and a file with little-endian numbers will yield a little-endian array on any machine reading the file. The types are described in terms of their actual sizes. For example, if a machine with a 64-bit C &amp;ldquo;long int&amp;rdquo; writes out an array with &amp;ldquo;long ints&amp;rdquo;, a reading machine with 32-bit C &amp;ldquo;long ints&amp;rdquo; will yield an array with 64-bit integers.</source>
          <target state="translated">存储所有必要的信息以在不同体系结构的计算机上重建包括shape和dtype的数组。little-endian和big-endian数组均受支持，并且具有little-endian编号的文件将在读取该文件的任何计算机上生成一个little-endian数组。这些类型根据其实际大小进行描述。例如，如果一台具有64位C&amp;ldquo; long int&amp;rdquo;的机器写出一个具有&amp;ldquo; long ints&amp;rdquo;的数组，那么一台具有32位C&amp;ldquo; long int&amp;rdquo;的读取机将产生一个具有64位整数的数组。</target>
        </trans-unit>
        <trans-unit id="4be1432cfaeaa9150a93183cf4c2899fcef7c724" translate="yes" xml:space="preserve">
          <source>Stores object arrays, i.e. arrays containing elements that are arbitrary Python objects. Files with object arrays are not to be mmapable, but can be read and written to disk.</source>
          <target state="translated">存储对象数组,即包含任意 Python 对象元素的数组。带有对象数组的文件是不可mmap的,但可以读和写到磁盘。</target>
        </trans-unit>
        <trans-unit id="f27167d2cff299e4b6bdced9e8ba574539ece3ec" translate="yes" xml:space="preserve">
          <source>Strided Loop</source>
          <target state="translated">步行圈</target>
        </trans-unit>
        <trans-unit id="0229721b8100825a2747d58dc18cba748992b615" translate="yes" xml:space="preserve">
          <source>Strided copy code: Here, &amp;ldquo;uint alignment&amp;rdquo; is used instead. If the itemsize of an array is equal to 1, 2, 4, 8 or 16 bytes and the array is uint aligned then instead numpy will do &lt;code&gt;*(uintN*)dst) = *(uintN*)src)&lt;/code&gt; for appropriate N. Otherwise numpy copies by doing &lt;code&gt;memcpy(dst, src, N)&lt;/code&gt;.</source>
          <target state="translated">交错的复制代码：在这里，使用&amp;ldquo;统一对齐&amp;rdquo;。如果数组的项目大小等于1、2、4、8或16个字节，并且数组是uint对齐的，那么numpy会对适当的N 做 &lt;code&gt;*(uintN*)dst) = *(uintN*)src)&lt;/code&gt; 。通过执行 &lt;code&gt;memcpy(dst, src, N)&lt;/code&gt; 进行numpy复制。</target>
        </trans-unit>
        <trans-unit id="416989873d1bb367de9329586677a513ca98acbb" translate="yes" xml:space="preserve">
          <source>Strides for the array (see &lt;a href=&quot;numpy.ndarray.strides#numpy.ndarray.strides&quot;&gt;&lt;code&gt;ndarray.strides&lt;/code&gt;&lt;/a&gt; for full description). Default is None.</source>
          <target state="translated">数组的&lt;a href=&quot;numpy.ndarray.strides#numpy.ndarray.strides&quot;&gt; &lt;code&gt;ndarray.strides&lt;/code&gt; &lt;/a&gt;有关完整说明，请参见ndarray.strides）。默认为无。</target>
        </trans-unit>
        <trans-unit id="abe83ed756895533bb0aacd0ff6c133f19d2f819" translate="yes" xml:space="preserve">
          <source>Strides for the array (see &lt;code&gt;ndarray.strides&lt;/code&gt; for full description). Default is None.</source>
          <target state="translated">数组的 &lt;code&gt;ndarray.strides&lt;/code&gt; 有关完整说明，请参见ndarray.strides）。默认为无。</target>
        </trans-unit>
        <trans-unit id="715d0f58588cad2551c57b871fab2907378f7743" translate="yes" xml:space="preserve">
          <source>Strides of data in memory.</source>
          <target state="translated">内存中的数据步数。</target>
        </trans-unit>
        <trans-unit id="4afc193de85ea729f32e1a7419493e9d11ac22a1" translate="yes" xml:space="preserve">
          <source>String (fixed-length sequence of char)</source>
          <target state="translated">字符串</target>
        </trans-unit>
        <trans-unit id="f12af9aa3dd629be8a9ae33b8570944039c84f2e" translate="yes" xml:space="preserve">
          <source>String Parsing</source>
          <target state="translated">字符串解析</target>
        </trans-unit>
        <trans-unit id="34123bf351844b619c4dbfc6727ace35b50b4db7" translate="yes" xml:space="preserve">
          <source>String containing words to look for.</source>
          <target state="translated">包含要找的词的字符串。</target>
        </trans-unit>
        <trans-unit id="4df4e94946ef158e4c1e5b716aaee91f272b4a7e" translate="yes" xml:space="preserve">
          <source>String formatting</source>
          <target state="translated">字符串格式化</target>
        </trans-unit>
        <trans-unit id="92531b336e4e7bb6a1d7d30a01f8111947fec115" translate="yes" xml:space="preserve">
          <source>String information</source>
          <target state="translated">字符串信息</target>
        </trans-unit>
        <trans-unit id="c2b35fa4d37ee8a6b4bd38cea3798cc9fbf4cba7" translate="yes" xml:space="preserve">
          <source>String integers specify the axis to concatenate along or the minimum number of dimensions to force entries into.</source>
          <target state="translated">字符串整数指定了要连接的轴或强制输入的最小尺寸数。</target>
        </trans-unit>
        <trans-unit id="f501c85c352da3ec100086db122d9f22d122b32e" translate="yes" xml:space="preserve">
          <source>String of length &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">长度为 &lt;code&gt;length&lt;/code&gt; 的字符串。</target>
        </trans-unit>
        <trans-unit id="766f45c1227c8c7d13e31b3c8218c7c441dc99b1" translate="yes" xml:space="preserve">
          <source>String operations</source>
          <target state="translated">字符串操作</target>
        </trans-unit>
        <trans-unit id="b92216b3243250ff57b76e23d2f013b608ec0972" translate="yes" xml:space="preserve">
          <source>String or character separating columns.</source>
          <target state="translated">分列的字符串或字符。</target>
        </trans-unit>
        <trans-unit id="791d1bdb2ea8c1e1e2ac650ffdc82b6e091407c9" translate="yes" xml:space="preserve">
          <source>String or character separating lines.</source>
          <target state="translated">分隔线的字符串或字符。</target>
        </trans-unit>
        <trans-unit id="070445e0a7bd458bdad35ce8dcb2d1d0173ff69e" translate="yes" xml:space="preserve">
          <source>String representation of &lt;code&gt;number&lt;/code&gt; in &lt;code&gt;base&lt;/code&gt; system.</source>
          <target state="translated">的字符串表示 &lt;code&gt;number&lt;/code&gt; 在 &lt;code&gt;base&lt;/code&gt; 系统。</target>
        </trans-unit>
        <trans-unit id="2e31e8b091806f3d1f281cc4ba782be9fda82868" translate="yes" xml:space="preserve">
          <source>String representation of floating point infinity (default inf).</source>
          <target state="translated">浮点无穷大的字符串表示(默认为inf)。</target>
        </trans-unit>
        <trans-unit id="01373c57fb8fe982545c8617e4790c9bba32d3bd" translate="yes" xml:space="preserve">
          <source>String representation of floating point not-a-number (default nan).</source>
          <target state="translated">浮点数not-a-number的字符串表示(默认为nan)。</target>
        </trans-unit>
        <trans-unit id="9f3842d201b21eb0e7888c9c3d9a2c881516b8c4" translate="yes" xml:space="preserve">
          <source>String representation of the array.</source>
          <target state="translated">数组的字符串表示。</target>
        </trans-unit>
        <trans-unit id="4db97d521f52ac6d93080543eb6b74577ba23cc3" translate="yes" xml:space="preserve">
          <source>String representations:</source>
          <target state="translated">字符串表示。</target>
        </trans-unit>
        <trans-unit id="e0d061a82ce8af858bef95987cfb2e899639d475" translate="yes" xml:space="preserve">
          <source>String that will be prepended to the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;footer&lt;/code&gt; strings, to mark them as comments. Default: &amp;lsquo;# &amp;lsquo;, as expected by e.g. &lt;code&gt;numpy.loadtxt&lt;/code&gt;.</source>
          <target state="translated">将在 &lt;code&gt;header&lt;/code&gt; 和 &lt;code&gt;footer&lt;/code&gt; 字符串之前添加的字符串，以将其标记为注释。默认值：&amp;ldquo;＃&amp;rdquo;，例如 &lt;code&gt;numpy.loadtxt&lt;/code&gt; 所期望的。</target>
        </trans-unit>
        <trans-unit id="29161ee7a7a15a1abaf0f1612beb0eae4baa01d7" translate="yes" xml:space="preserve">
          <source>String that will be written at the beginning of the file.</source>
          <target state="translated">写在文件开头的字符串。</target>
        </trans-unit>
        <trans-unit id="5c5d64e1c727d0403596e9c5ea3308951b6f9d69" translate="yes" xml:space="preserve">
          <source>String that will be written at the end of the file.</source>
          <target state="translated">将写在文件末尾的字符串。</target>
        </trans-unit>
        <trans-unit id="65875ffed7d9c75f6fe284ddd93f194bd7eecd53" translate="yes" xml:space="preserve">
          <source>String used in lieu of missing data when a masked array is printed. By default, this string is &lt;code&gt;'--'&lt;/code&gt;.</source>
          <target state="translated">打印掩码数组时使用的字符串代替丢失的数据。默认情况下，此字符串为 &lt;code&gt;'--'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e619565781aeac87df5988755d8308bf2c9d2598" translate="yes" xml:space="preserve">
          <source>String with comma-separated fields</source>
          <target state="translated">逗号分隔的字符串</target>
        </trans-unit>
        <trans-unit id="70f2192ce102bd881643cbec0959f90e05d94515" translate="yes" xml:space="preserve">
          <source>Strings are also a scalar type:</source>
          <target state="translated">字符串也是一种标量类型。</target>
        </trans-unit>
        <trans-unit id="abee4933ed6df48a826b4ec24a053bf896cc2409" translate="yes" xml:space="preserve">
          <source>Structured arrays are sorted lexically by &lt;code&gt;argsort&lt;/code&gt;:</source>
          <target state="translated">结构化数组由 &lt;code&gt;argsort&lt;/code&gt; 按词法排序：</target>
        </trans-unit>
        <trans-unit id="f15140621e0cd4e0f0fe72960c228d9f03950ae6" translate="yes" xml:space="preserve">
          <source>Structured data types are formed by creating a data type whose &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;field&lt;/a&gt; contain other data types. Each field has a name by which it can be &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;accessed&lt;/a&gt;. The parent data type should be of sufficient size to contain all its fields; the parent is nearly always based on the &lt;code&gt;void&lt;/code&gt; type which allows an arbitrary item size. Structured data types may also contain nested structured sub-array data types in their fields.</source>
          <target state="translated">通过创建其&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;字段&lt;/a&gt;包含其他数据类型的数据类型来形成结构化数据类型。每个字段都有一个可以&lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;访问&lt;/a&gt;的名称。父数据类型的大小应足以容纳其所有字段；父级几乎总是基于允许任意项目大小的 &lt;code&gt;void&lt;/code&gt; 类型。结构化数据类型还可以在其字段中包含嵌套的结构化子数组数据类型。</target>
        </trans-unit>
        <trans-unit id="6624b07c38a844e59271b0a0c26ed454ac19dbe9" translate="yes" xml:space="preserve">
          <source>Structured type, one field name &amp;lsquo;f1&amp;rsquo;, containing int16:</source>
          <target state="translated">结构化类型，一个字段名称'f1'，包含int16：</target>
        </trans-unit>
        <trans-unit id="d2e117ca328d87720528f1cfaf8d8960167ffb11" translate="yes" xml:space="preserve">
          <source>Structured type, one field named &amp;lsquo;f1&amp;rsquo;, in itself containing a structured type with one field:</source>
          <target state="translated">结构化类型，一个名为&amp;ldquo; f1&amp;rdquo;的字段，其本身包含具有一个字段的结构化类型：</target>
        </trans-unit>
        <trans-unit id="58f4a5191b04c275b13b1266e03ae0e69f92c2c1" translate="yes" xml:space="preserve">
          <source>Structured type, two fields: the first field contains an unsigned int, the second an int32:</source>
          <target state="translated">结构化类型,两个字段:第一个字段包含一个无符号int,第二个字段包含一个int32。</target>
        </trans-unit>
        <trans-unit id="ca4456203ca66897ff0941bbafc31276906d7671" translate="yes" xml:space="preserve">
          <source>Structured view(s) of &lt;a href=&quot;numpy.nditer.operands#numpy.nditer.operands&quot;&gt;&lt;code&gt;operands&lt;/code&gt;&lt;/a&gt; in memory, matching the reordered and optimized iterator access pattern. Valid only before the iterator is closed.</source>
          <target state="translated">内存中&lt;a href=&quot;numpy.nditer.operands#numpy.nditer.operands&quot;&gt; &lt;code&gt;operands&lt;/code&gt; &lt;/a&gt;结构化视图，与重新排序和优化的迭代器访问模式匹配。仅在关闭迭代器之前有效。</target>
        </trans-unit>
        <trans-unit id="803fd087e54001bfefdde2c389864825258535d4" translate="yes" xml:space="preserve">
          <source>Sub-arrays always have a C-contiguous memory layout.</source>
          <target state="translated">子数组的内存布局总是C型连续的。</target>
        </trans-unit>
        <trans-unit id="b5f988ec613aba03f62b8fb5c8cfc27a7a1a6d0f" translate="yes" xml:space="preserve">
          <source>Sub-optimal &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (due to repeated path calculation time): ~330ms</source>
          <target state="translated">次优&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;（由于重复的路径计算时间）：〜330ms</target>
        </trans-unit>
        <trans-unit id="fa0a23c0a00071a5375730590cb136590b810c95" translate="yes" xml:space="preserve">
          <source>Subclasses of &lt;code&gt;ndarray&lt;/code&gt; are preserved except for the &amp;lsquo;raw&amp;rsquo; mode. So if &lt;code&gt;a&lt;/code&gt; is of type &lt;code&gt;matrix&lt;/code&gt;, all the return values will be matrices too.</source>
          <target state="translated">除&amp;ldquo;原始&amp;rdquo;模式外，保留 &lt;code&gt;ndarray&lt;/code&gt; 的子类。因此，如果 &lt;code&gt;a&lt;/code&gt; 为 &lt;code&gt;matrix&lt;/code&gt; 类型，则所有返回值也将为矩阵。</target>
        </trans-unit>
        <trans-unit id="9d147ab8047bc6066411af552791a9504b59a189" translate="yes" xml:space="preserve">
          <source>Subclassing a &lt;code&gt;numpy.ndarray&lt;/code&gt; is possible but if your goal is to create an array with &lt;em&gt;modified&lt;/em&gt; behavior, as do dask arrays for distributed computation and cupy arrays for GPU-based computation, subclassing is discouraged. Instead, using numpy&amp;rsquo;s &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.dispatch.html#basics-dispatch&quot;&gt;dispatch mechanism&lt;/a&gt; is recommended.</source>
          <target state="translated">可以对 &lt;code&gt;numpy.ndarray&lt;/code&gt; 进行子类化，但是如果您的目标是创建具有&lt;em&gt;经过修改的&lt;/em&gt;行为的数组（例如，用于分布式计算的dask数组和用于基于GPU的计算的cupy数组），则不建议使用子类化。相反，建议使用numpy的&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.dispatch.html#basics-dispatch&quot;&gt;调度机制&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33bc88cf96b41fa0646c461894f505af99f67ac1" translate="yes" xml:space="preserve">
          <source>Subclassing is preserved. This means that if, e.g., the data part of the masked array is a recarray, &lt;a href=&quot;numpy.ma.filled#numpy.ma.filled&quot;&gt;&lt;code&gt;filled&lt;/code&gt;&lt;/a&gt; returns a recarray:</source>
          <target state="translated">子类保留。这意味着，如果，例如，掩蔽阵列的数据部分是一个recarray，&lt;a href=&quot;numpy.ma.filled#numpy.ma.filled&quot;&gt; &lt;code&gt;filled&lt;/code&gt; &lt;/a&gt;返回一个recarray：</target>
        </trans-unit>
        <trans-unit id="dcd026d87f16ab5d865099378d38748e1049d4d8" translate="yes" xml:space="preserve">
          <source>Subclassing ndarray</source>
          <target state="translated">ndarray的子类</target>
        </trans-unit>
        <trans-unit id="d9952117e8cb53d0fd7ca6ba7d99ad537965d8c9" translate="yes" xml:space="preserve">
          <source>Subdivide &lt;code&gt;int16&lt;/code&gt; into 2 &lt;code&gt;int8&lt;/code&gt;&amp;rsquo;s, called x and y. 0 and 1 are the offsets in bytes:</source>
          <target state="translated">将 &lt;code&gt;int16&lt;/code&gt; 细分为2个 &lt;code&gt;int8&lt;/code&gt; ，分别称为x和y。0和1是字节偏移量：</target>
        </trans-unit>
        <trans-unit id="7cd760711c541e202c788fb098af0b33b391721e" translate="yes" xml:space="preserve">
          <source>Subsequence with trailing zeros removed. If the resulting sequence would be empty, return the first element. The returned sequence may or may not be a view.</source>
          <target state="translated">去掉尾部零的子序列。如果生成的序列为空,返回第一个元素。返回的序列可能是也可能不是视图。</target>
        </trans-unit>
        <trans-unit id="259ff26648e77d2b9a5ec16a4f186ec8e1c65753" translate="yes" xml:space="preserve">
          <source>Substitute a polynomial for x and expand the result. Here we substitute p in itself leading to a new polynomial of degree 4 after expansion. If the polynomials are regarded as functions this is composition of functions:</source>
          <target state="translated">将一个多项式代入x,然后展开结果。这里我们将p代入本身,展开后得到一个新的4度多项式。如果将多项式视为函数,这就是函数的组成。</target>
        </trans-unit>
        <trans-unit id="8d18e7a773fc8ec030ec151dbf7cd596c836697a" translate="yes" xml:space="preserve">
          <source>Substitution:</source>
          <target state="translated">Substitution:</target>
        </trans-unit>
        <trans-unit id="976370d3324e5eaaec19ed99a261ec090486b0fa" translate="yes" xml:space="preserve">
          <source>Subtract arguments, element-wise.</source>
          <target state="translated">减去参数,元素方面。</target>
        </trans-unit>
        <trans-unit id="8567fbb4d729f4cd5b7fbe5674c01c465635fa47" translate="yes" xml:space="preserve">
          <source>Subtract one Chebyshev series from another.</source>
          <target state="translated">从另一个切比雪夫数列中减去一个。</target>
        </trans-unit>
        <trans-unit id="a494f472ea255a2aaa4f1c8f52b90c62196690f5" translate="yes" xml:space="preserve">
          <source>Subtract one Hermite series from another.</source>
          <target state="translated">从另一个Hermite系列中减去一个。</target>
        </trans-unit>
        <trans-unit id="60b31c93b32c6d82ec367e99b58e2a7fd1690435" translate="yes" xml:space="preserve">
          <source>Subtract one Laguerre series from another.</source>
          <target state="translated">从另一个Laguerre系列中减去一个。</target>
        </trans-unit>
        <trans-unit id="09477810015d786e3a1ce0d9827bfd9d00039de6" translate="yes" xml:space="preserve">
          <source>Subtract one Legendre series from another.</source>
          <target state="translated">从另一个Legendre系列中减去一个。</target>
        </trans-unit>
        <trans-unit id="a2407a57a6647eba13b915586134c7e1d7534217" translate="yes" xml:space="preserve">
          <source>Subtract one polynomial from another.</source>
          <target state="translated">用一个多项式减去另一个多项式。</target>
        </trans-unit>
        <trans-unit id="5de67be97d964e12a293477e154e8fa146741938" translate="yes" xml:space="preserve">
          <source>Subtract other from self in-place.</source>
          <target state="translated">从自己身上原地减去其他。</target>
        </trans-unit>
        <trans-unit id="b3957443ea74659d4523c7bc9e466d304ba155cf" translate="yes" xml:space="preserve">
          <source>Subtract other from self, and return a new masked array.</source>
          <target state="translated">从self中减去other,并返回一个新的掩码数组。</target>
        </trans-unit>
        <trans-unit id="6cf676697a4c117ec3074a618da8a2b0fca9cd14" translate="yes" xml:space="preserve">
          <source>Subtract self from other, and return a new masked array.</source>
          <target state="translated">从other中减去self,并返回一个新的掩码数组。</target>
        </trans-unit>
        <trans-unit id="d0b818b7784e48b243d98be89f763b62cb9fc7bd" translate="yes" xml:space="preserve">
          <source>Successfully tested on:</source>
          <target state="translated">成功测试上。</target>
        </trans-unit>
        <trans-unit id="7f477dc5121884706ef8fed21e4d11c24e6db091" translate="yes" xml:space="preserve">
          <source>Sum across array propagating NaNs.</source>
          <target state="translated">整个阵列传播NaNs的总和。</target>
        </trans-unit>
        <trans-unit id="b2cc82eaee79a7562889de3502bb827b013693aa" translate="yes" xml:space="preserve">
          <source>Sum along diagonals.</source>
          <target state="translated">沿对角线求和。</target>
        </trans-unit>
        <trans-unit id="b221abad8e52361732192c7acb9613f67b076ac3" translate="yes" xml:space="preserve">
          <source>Sum array elements.</source>
          <target state="translated">数组元素之和。</target>
        </trans-unit>
        <trans-unit id="96c00e26cd369dd11b081a1035d4633225e7965d" translate="yes" xml:space="preserve">
          <source>Sum of array elements over a given axis.</source>
          <target state="translated">给定轴上的数组元素之和。</target>
        </trans-unit>
        <trans-unit id="6302a8aa98d30db8a3e7186cb73eb9e4337d618b" translate="yes" xml:space="preserve">
          <source>Sum over an axis (requires explicit form):</source>
          <target state="translated">在一个轴上求和(需要明确的形式)。</target>
        </trans-unit>
        <trans-unit id="1c979daf2b6e4cef98bd537ad236de258dbc0d5a" translate="yes" xml:space="preserve">
          <source>Sum over axes 0 and 2. The result has same number of dimensions as the original array:</source>
          <target state="translated">在0轴和2轴上求和。结果与原数组的维数相同。</target>
        </trans-unit>
        <trans-unit id="1103f1f7acbd2c5b9349bcbddbb45121fae537eb" translate="yes" xml:space="preserve">
          <source>Sum products over arbitrary axes.</source>
          <target state="translated">在任意轴上求积。</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="bf661fd6213ae079ce34c2c9dd00db526c359e2b" translate="yes" xml:space="preserve">
          <source>Sums of residuals; squared Euclidean 2-norm for each column in &lt;code&gt;b - a*x&lt;/code&gt;. If the rank of &lt;code&gt;a&lt;/code&gt; is &amp;lt; N or M &amp;lt;= N, this is an empty array. If &lt;code&gt;b&lt;/code&gt; is 1-dimensional, this is a (1,) shape array. Otherwise the shape is (K,).</source>
          <target state="translated">残差之和； &lt;code&gt;b - a*x&lt;/code&gt; 每一列的平方欧几里德2-范数。如果秩 &lt;code&gt;a&lt;/code&gt; 是&amp;lt;N或M &amp;lt;= N，这是一个空数组。如果 &lt;code&gt;b&lt;/code&gt; 为一维，则为（1，）形状数组。否则，形状为（K，）。</target>
        </trans-unit>
        <trans-unit id="b6c71b95244ccde5ac8df906b9633b9278b04563" translate="yes" xml:space="preserve">
          <source>Sums, products, differences</source>
          <target state="translated">总和、产品、差异</target>
        </trans-unit>
        <trans-unit id="56cedb0b6384ebe895f048d3113a97e19adce9ed" translate="yes" xml:space="preserve">
          <source>SunOS 5.9, Python 2.2, 2.3.2</source>
          <target state="translated">SunOS 5.9,Python 2.2,2.3.2.</target>
        </trans-unit>
        <trans-unit id="5732c875d678ed7bc376f8bdb01c865cd0e57b5f" translate="yes" xml:space="preserve">
          <source>Support for multiple insertions when &lt;code&gt;obj&lt;/code&gt; is a single scalar or a sequence with one element (similar to calling insert multiple times).</source>
          <target state="translated">当 &lt;code&gt;obj&lt;/code&gt; 是单个标量或具有一个元素的序列时，支持多次插入（类似于多次调用insert）。</target>
        </trans-unit>
        <trans-unit id="6d95257e0d6b5ee52701ed6e60955d7b5cf2355f" translate="yes" xml:space="preserve">
          <source>Supported BitGenerators</source>
          <target state="translated">支持的位元发生器</target>
        </trans-unit>
        <trans-unit id="090678b79c24d0799aa7434df5ba4e013c0ea2ff" translate="yes" xml:space="preserve">
          <source>Supports Fortran-contiguous arrays directly.</source>
          <target state="translated">直接支持Fortran连续数组。</target>
        </trans-unit>
        <trans-unit id="62c4a407a3644c899b58964ef70d8d5ea099dfdd" translate="yes" xml:space="preserve">
          <source>Supports full broadcasting of the inputs.</source>
          <target state="translated">支持输入的全部广播。</target>
        </trans-unit>
        <trans-unit id="12f46de9102cae348756a951378fba972f726b07" translate="yes" xml:space="preserve">
          <source>Supports rolling over multiple dimensions simultaneously.</source>
          <target state="translated">支持同时在多个尺寸上滚动。</target>
        </trans-unit>
        <trans-unit id="d97b0cce7cf0a1a8ea78834b26b7eaa1e93207d9" translate="yes" xml:space="preserve">
          <source>Supports the method &lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt; to advance the RNG an arbitrary number of steps. The state of the PCG-64 RNG is represented by 2 128-bit unsigned integers.</source>
          <target state="translated">支持方法&lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt; &lt;code&gt;advance&lt;/code&gt; &lt;/a&gt;将RNG前进任意步数。PCG-64 RNG的状态由2个128位无符号整数表示。</target>
        </trans-unit>
        <trans-unit id="34c5f00d14223115d609ab63804b8bf6dbd38059" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;x.shape&lt;/code&gt; is (10,20,30) and &lt;code&gt;ind&lt;/code&gt; is a (2,3,4)-shaped indexing &lt;code&gt;intp&lt;/code&gt; array, then &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; has shape (10,2,3,4,30) because the (20,)-shaped subspace has been replaced with a (2,3,4)-shaped broadcasted indexing subspace. If we let &lt;em&gt;i, j, k&lt;/em&gt; loop over the (2,3,4)-shaped subspace then &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt;. This example produces the same result as &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">假设 &lt;code&gt;x.shape&lt;/code&gt; 为（10,20,30）并且 &lt;code&gt;ind&lt;/code&gt; 为（2,3,4）形索引 &lt;code&gt;intp&lt;/code&gt; 数组，则 &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; 形状为（10,2,3 ，4,30），因为（20，）形状的子空间已被（2,3,4）形状的广播索引子空间替换。如果我们让&lt;em&gt;i，j，k&lt;/em&gt;在（2,3,4）形子空间上循环，则 &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt; 。本示例产生的结果与&lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt; &lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab6e03b971eeb9906907892d695f98f70c00c465" translate="yes" xml:space="preserve">
          <source>Suppose I have two files coolmodule.c and coolhelper.c which need to be compiled and linked into a single extension module. Suppose coolmodule.c contains the required initcool module initialization function (with the import_array() function called). Then, coolmodule.c would have at the top:</source>
          <target state="translated">假设我有两个文件coolmodule.c和coolhelper.c,它们需要被编译并链接到一个扩展模块中。假设coolmodule.c包含所需的initcool模块初始化函数(调用import_array()函数)。那么,coolmodule.c的顶部就会有以下内容。</target>
        </trans-unit>
        <trans-unit id="1a06be2cc716b778d6a1c32b124922e42d2cce52" translate="yes" xml:space="preserve">
          <source>Suppose now that we wish to print that same data, but with the missing values replaced by the average value.</source>
          <target state="translated">假设现在我们想打印同样的数据,但用平均值代替缺失值。</target>
        </trans-unit>
        <trans-unit id="5dca6dc181cc53601add013bc2ada72709458943" translate="yes" xml:space="preserve">
          <source>Suppose the first operand is one dimensional and the second operand is two dimensional. The iterator will have three dimensions, so &lt;code&gt;op_axes&lt;/code&gt; will have two 3-element lists. The first list picks out the one axis of the first operand, and is -1 for the rest of the iterator axes, with a final result of [0, -1, -1]. The second list picks out the two axes of the second operand, but shouldn&amp;rsquo;t overlap with the axes picked out in the first operand. Its list is [-1, 0, 1]. The output operand maps onto the iterator axes in the standard manner, so we can provide None instead of constructing another list.</source>
          <target state="translated">假设第一个操作数是一维的，第二个操作数是二维的。迭代器将具有三个维度，因此 &lt;code&gt;op_axes&lt;/code&gt; 将具有两个3元素列表。第一个列表挑选出第一个操作数的一个轴，其余迭代器轴为-1，最终结果为[0，-1，-1]。第二个列表选择第二个操作数的两个轴，但不应与第一个操作数中选择的轴重叠。它的列表是[-1，0，1]。输出操作数以标准方式映射到迭代器轴，因此我们可以提供None而不是构造另一个列表。</target>
        </trans-unit>
        <trans-unit id="ffbff519fe81519b5859278de1db83d3776384bb" translate="yes" xml:space="preserve">
          <source>Suppose you have a SciPy module &lt;code&gt;scipy/xxx/yyy.py&lt;/code&gt; containing a function &lt;code&gt;zzz()&lt;/code&gt;. To test this function you would create a test module called &lt;code&gt;test_yyy.py&lt;/code&gt;. If you only need to test one aspect of &lt;code&gt;zzz&lt;/code&gt;, you can simply add a test function:</source>
          <target state="translated">假设你有一个SciPy的模块 &lt;code&gt;scipy/xxx/yyy.py&lt;/code&gt; 包含函数 &lt;code&gt;zzz()&lt;/code&gt; 。要测试此功能，您将创建一个名为 &lt;code&gt;test_yyy.py&lt;/code&gt; 的测试模块。如果只需要测试 &lt;code&gt;zzz&lt;/code&gt; 的一个方面，则只需添加一个测试功能即可：</target>
        </trans-unit>
        <trans-unit id="561e62ec5d03ac50c21e0a257548d3eb990ac028" translate="yes" xml:space="preserve">
          <source>Suppose you have an urn with 15 white and 15 black marbles. If you pull 15 marbles at random, how likely is it that 12 or more of them are one color?</source>
          <target state="translated">假设你有一个瓮,里面有15个白色和15个黑色的弹珠。如果你随机抽取15个弹珠,那么其中12个或更多的弹珠是一种颜色的可能性有多大?</target>
        </trans-unit>
        <trans-unit id="7c7cd36a0c21d430e2827a371600cad0b35b80b7" translate="yes" xml:space="preserve">
          <source>Suppress the rows and/or columns of a 2-D array that contain masked values.</source>
          <target state="translated">抑制包含屏蔽值的二维数组的行和/或列。</target>
        </trans-unit>
        <trans-unit id="00f54cf02ad98c4bd3014ede43830053636d4545" translate="yes" xml:space="preserve">
          <source>Suppress whole columns of a 2-D array that contain masked values.</source>
          <target state="translated">抑制包含屏蔽值的二维数组的整列。</target>
        </trans-unit>
        <trans-unit id="685b0c43425911b6f904fe6d170e96c0345d4cbf" translate="yes" xml:space="preserve">
          <source>Suppress whole rows of a 2-D array that contain masked values.</source>
          <target state="translated">抑制包含屏蔽值的二维数组的整行。</target>
        </trans-unit>
        <trans-unit id="b11d9a95741366c39b17b9d4fd94445d808b15b4" translate="yes" xml:space="preserve">
          <source>Swap the bytes of the array elements</source>
          <target state="translated">交换数组元素的字节</target>
        </trans-unit>
        <trans-unit id="bbdcf90ffec6f9d47a9ac51cf19b00a93a140fa9" translate="yes" xml:space="preserve">
          <source>Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned.</source>
          <target state="translated">决定返回值性质的开关。当为False(默认)时,只返回系数,当为True时,也会返回奇异值分解的诊断信息。</target>
        </trans-unit>
        <trans-unit id="6b3384dea957229bd45073ab4c8cae823f791969" translate="yes" xml:space="preserve">
          <source>Switch determining the nature of the return value. When &lt;code&gt;False&lt;/code&gt; (the default) just the coefficients are returned; when &lt;code&gt;True&lt;/code&gt;, diagnostic information from the singular value decomposition (used to solve the fit&amp;rsquo;s matrix equation) is also returned.</source>
          <target state="translated">开关确定返回值的性质。如果为 &lt;code&gt;False&lt;/code&gt; （默认值），则仅返回系数。如果为 &lt;code&gt;True&lt;/code&gt; ，则还返回来自奇异值分解（用于求解拟合矩阵方程）的诊断信息。</target>
        </trans-unit>
        <trans-unit id="7af38070c59fd5383f5319f90871324cb011240a" translate="yes" xml:space="preserve">
          <source>System Entropy</source>
          <target state="translated">熵系统</target>
        </trans-unit>
        <trans-unit id="1b1430441b7b7dd5a90d83f42f914deacc5fd0e5" translate="yes" xml:space="preserve">
          <source>System configuration</source>
          <target state="translated">系统配置</target>
        </trans-unit>
        <trans-unit id="8e0d354392fe3fc9d2a5d83e7fd5a6f24a2b815a" translate="yes" xml:space="preserve">
          <source>TODO: Maybe it would be better to introduce a function &lt;code&gt;NpyIter_GetWrappedOutput&lt;/code&gt; and remove this flag?</source>
          <target state="translated">TODO：也许最好引入一个函数 &lt;code&gt;NpyIter_GetWrappedOutput&lt;/code&gt; 并删除该标志？</target>
        </trans-unit>
        <trans-unit id="c398f641b79127cbb5368a052c9c18ee4b191edd" translate="yes" xml:space="preserve">
          <source>TODO: This feature can be easily extended for Fortran 90 codes as well. Let us know if you would need such a feature.</source>
          <target state="translated">TODO:这个功能也可以很容易地扩展到Fortran 90代码。如果您需要这一功能,请告诉我们。</target>
        </trans-unit>
        <trans-unit id="d2bf59208074c19e062d597b69c91e24c1b3f65d" translate="yes" xml:space="preserve">
          <source>Take a sequence of 1-D arrays and stack them as columns to make a single 2-D array. 2-D arrays are stacked as-is, just like with &lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;. 1-D arrays are turned into 2-D columns first.</source>
          <target state="translated">采取一系列一维数组并将其堆叠为列以构成单个二维数组。二维数组按原样堆叠，就像使用&lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; 一样&lt;/a&gt;。首先将一维数组转换为二维列。</target>
        </trans-unit>
        <trans-unit id="a7063ff9c282b69776d4b6c1965ce5cc8d3d21f1" translate="yes" xml:space="preserve">
          <source>Take a sequence of 1-D arrays and stack them as columns to make a single 2-D array. 2-D arrays are stacked as-is, just like with &lt;a href=&quot;numpy.ma.hstack#numpy.ma.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;. 1-D arrays are turned into 2-D columns first.</source>
          <target state="translated">采取一系列一维数组并将其堆叠为列以构成单个二维数组。二维数组按原样堆叠，就像使用&lt;a href=&quot;numpy.ma.hstack#numpy.ma.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; 一样&lt;/a&gt;。首先将一维数组转换为二维列。</target>
        </trans-unit>
        <trans-unit id="948650b27c1b2b9784a79436cafe48d7d653c938" translate="yes" xml:space="preserve">
          <source>Take along an axis, using the same indices for every 1d slice</source>
          <target state="translated">沿着轴线,对每一个1d的片子使用相同的指数。</target>
        </trans-unit>
        <trans-unit id="750d821c9fa304621f4be0f3b88564bf9278e152" translate="yes" xml:space="preserve">
          <source>Take elements by matching the array and the index arrays</source>
          <target state="translated">通过匹配数组和索引数组来获取元素。</target>
        </trans-unit>
        <trans-unit id="e11fd16230a195030272e04871b014d038eef9ab" translate="yes" xml:space="preserve">
          <source>Take elements from an array along an axis.</source>
          <target state="translated">从一个数组中沿轴取元素。</target>
        </trans-unit>
        <trans-unit id="2bd0abec8d18fb4f628e5467a962eaf329bb6905" translate="yes" xml:space="preserve">
          <source>Take elements using a boolean mask</source>
          <target state="translated">使用布尔掩码获取元素</target>
        </trans-unit>
        <trans-unit id="b8cd92f0049ea13b3db726f84fc3411287caeddf" translate="yes" xml:space="preserve">
          <source>Take the fields dictionary, &lt;em&gt;dict&lt;/em&gt;, such as the one attached to a data-type object and construct an ordered-list of field names such as is stored in the names field of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">拿字段字典&lt;em&gt;dict&lt;/em&gt;（例如附加到数据类型对象的字典），构造字段名称的有序列表，例如存储在&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;对象的names字段中。</target>
        </trans-unit>
        <trans-unit id="673397230d0da22f7147b4eeece871fd1294c5ff" translate="yes" xml:space="preserve">
          <source>Take values from the input array by matching 1d index and data slices</source>
          <target state="translated">通过匹配1d索引和数据片,从输入数组中取值。</target>
        </trans-unit>
        <trans-unit id="7f4b8f1ca46302f3d1aba5fbdc3749dad60f0480" translate="yes" xml:space="preserve">
          <source>Take values from the input array by matching 1d index and data slices.</source>
          <target state="translated">通过匹配1d索引和数据片从输入数组中取值。</target>
        </trans-unit>
        <trans-unit id="567aaaa85050a78f736c937e4e349477825e7c6c" translate="yes" xml:space="preserve">
          <source>Takes an arbitrary Python function and returns a NumPy ufunc.</source>
          <target state="translated">读取一个任意的Python函数并返回一个NumPy ufunc。</target>
        </trans-unit>
        <trans-unit id="ad884a5ab2796ce61beab25497caa48a0c350a18" translate="yes" xml:space="preserve">
          <source>Takes an arbitrary Python function and returns a ufunc</source>
          <target state="translated">读取一个任意的Python函数并返回一个ufunc。</target>
        </trans-unit>
        <trans-unit id="4fe8421f7b4bac2910c2919a03e01d32f910e006" translate="yes" xml:space="preserve">
          <source>Taking an example cited in Wikipedia, this distribution can be used if one wanted to cut strings (each of initial length 1.0) into K pieces with different lengths, where each piece had, on average, a designated average length, but allowing some variation in the relative sizes of the pieces.</source>
          <target state="translated">以维基百科中引用的一个例子为例,如果想把字符串(每个初始长度为1.0)切割成K个不同长度的片段,其中每个片段平均有一个指定的平均长度,但允许片段的相对大小有一些变化,就可以使用这种分布。</target>
        </trans-unit>
        <trans-unit id="af1237aaefe517f485a7a53e6bb8a3bb8a86a6a4" translate="yes" xml:space="preserve">
          <source>Target array.</source>
          <target state="translated">目标阵列:</target>
        </trans-unit>
        <trans-unit id="51038a1a794fec6114fafbb47a8bce902f23294f" translate="yes" xml:space="preserve">
          <source>Target indices, interpreted as integers.</source>
          <target state="translated">目标指数,解释为整数。</target>
        </trans-unit>
        <trans-unit id="695f8bb0287f4fc300e17fa93e5262f0b53e9bb1" translate="yes" xml:space="preserve">
          <source>Temporary directories are deleted when the DataSource is deleted.</source>
          <target state="translated">当DataSource被删除时,临时目录会被删除。</target>
        </trans-unit>
        <trans-unit id="6701dda5ea2a62c52d8395d7a5c8f390a0ab64df" translate="yes" xml:space="preserve">
          <source>Tensor contraction:</source>
          <target state="translated">张量收缩。</target>
        </trans-unit>
        <trans-unit id="7e786b6ecaa33c3bfa2a663250579b348bbb6678" translate="yes" xml:space="preserve">
          <source>Tensor contractions, &lt;a href=&quot;numpy.tensordot#numpy.tensordot&quot;&gt;&lt;code&gt;numpy.tensordot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">张量收缩&lt;a href=&quot;numpy.tensordot#numpy.tensordot&quot;&gt; &lt;code&gt;numpy.tensordot&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8aa53899fcc2f4722e3aaa13b02a9f0c21a58b0c" translate="yes" xml:space="preserve">
          <source>Tensor to &amp;lsquo;invert&amp;rsquo;. Its shape must be &amp;lsquo;square&amp;rsquo;, i. e., &lt;code&gt;prod(a.shape[:ind]) == prod(a.shape[ind:])&lt;/code&gt;.</source>
          <target state="translated">张量&amp;ldquo;反转&amp;rdquo;。它的形状必须为&amp;ldquo;正方形&amp;rdquo;，即 &lt;code&gt;prod(a.shape[:ind]) == prod(a.shape[ind:])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a7912060e7ae8d981d410c16692b658bc5a8653" translate="yes" xml:space="preserve">
          <source>Tensors to &amp;ldquo;dot&amp;rdquo;.</source>
          <target state="translated">张量为&amp;ldquo;点&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="71218d40834bc4913fe2fbb95e52de19a584b43a" translate="yes" xml:space="preserve">
          <source>Test Running</source>
          <target state="translated">测试运行</target>
        </trans-unit>
        <trans-unit id="2ec99dbb44d0090912e3c4ddf71222f3cee61914" translate="yes" xml:space="preserve">
          <source>Test Support (&lt;code&gt;numpy.testing&lt;/code&gt;)</source>
          <target state="translated">测试支持（ &lt;code&gt;numpy.testing&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c35554b04739c6c6869f7c83d9841e0dda4c5073" translate="yes" xml:space="preserve">
          <source>Test Support (numpy.testing)</source>
          <target state="translated">测试支持 (numpy.testing)</target>
        </trans-unit>
        <trans-unit id="59afddee1692b59da457c30d92a5b65f5e31115a" translate="yes" xml:space="preserve">
          <source>Test element-wise for NaN and return result as a boolean array.</source>
          <target state="translated">对NaN进行逐元素测试,并以布尔数组形式返回结果。</target>
        </trans-unit>
        <trans-unit id="ed391a308f11ca7f40c17a765e9b20cc4e1035a2" translate="yes" xml:space="preserve">
          <source>Test element-wise for NaT (not a time) and return result as a boolean array.</source>
          <target state="translated">对NaT(不是时间)进行元素测试,并以布尔数组的形式返回结果。</target>
        </trans-unit>
        <trans-unit id="9f34997c659f4457d18a667e13e9b54ff7ea7b5d" translate="yes" xml:space="preserve">
          <source>Test element-wise for finiteness (not infinity or not Not a Number).</source>
          <target state="translated">从元素上测试有限性(不是无穷大,也不是Not a Number)。</target>
        </trans-unit>
        <trans-unit id="b73482f0dd7c13ea3e95362c875b37244def5b6c" translate="yes" xml:space="preserve">
          <source>Test element-wise for negative infinity, return result as bool array.</source>
          <target state="translated">逐元素测试负无穷大,返回结果为bool数组。</target>
        </trans-unit>
        <trans-unit id="f441420173d81baeaa59a4fb443d5293972df75a" translate="yes" xml:space="preserve">
          <source>Test element-wise for positive infinity, return result as bool array.</source>
          <target state="translated">逐元素测试是否为正无穷大,返回结果为bool数组。</target>
        </trans-unit>
        <trans-unit id="f76286ad13fcd1d6939365b38ad9443c5711054b" translate="yes" xml:space="preserve">
          <source>Test element-wise for positive or negative infinity.</source>
          <target state="translated">从元素上检验正负无穷大。</target>
        </trans-unit>
        <trans-unit id="a54ae1b5fd87138bbeb065cc5056362be6e773bd" translate="yes" xml:space="preserve">
          <source>Test if &lt;code&gt;path&lt;/code&gt; exists as (and in this order):</source>
          <target state="translated">测试 &lt;code&gt;path&lt;/code&gt; 存在（以该顺序）：</target>
        </trans-unit>
        <trans-unit id="6db21c53daecd81068cb27c5716c17cf9ec8f853" translate="yes" xml:space="preserve">
          <source>Test if path exists.</source>
          <target state="translated">测试路径是否存在。</target>
        </trans-unit>
        <trans-unit id="ab9c97d91f47360ac72bf2e9386f7b26c75db7d2" translate="yes" xml:space="preserve">
          <source>Test if two strings are equal.</source>
          <target state="translated">测试两个字符串是否相等。</target>
        </trans-unit>
        <trans-unit id="90c99592ef3a4e369f5b8438543a142bc4a6d8c8" translate="yes" xml:space="preserve">
          <source>Test support</source>
          <target state="translated">测试支持</target>
        </trans-unit>
        <trans-unit id="fe6e53750db930a15ff2a9eb0786f6b4b0dd49e8" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;ary&lt;/code&gt; is contiguous. If so, return 1. Otherwise, set a Python error and return 0.</source>
          <target state="translated">测试 &lt;code&gt;ary&lt;/code&gt; 是否连续。如果是，则返回1。否则，设置Python错误并返回0。</target>
        </trans-unit>
        <trans-unit id="e52099e2b541a96f27cc77aa438f266ac05e538f" translate="yes" xml:space="preserve">
          <source>Test whether all array elements along a given axis evaluate to True.</source>
          <target state="translated">测试是否所有沿给定轴的数组元素都为True。</target>
        </trans-unit>
        <trans-unit id="7d4c1c04414d7af36c37c81837979d62019dac75" translate="yes" xml:space="preserve">
          <source>Test whether all elements along a given axis evaluate to True.</source>
          <target state="translated">测试是否所有沿给定轴的元素都为True。</target>
        </trans-unit>
        <trans-unit id="8dcb7ed405671230192b179ae33bab118c7f5996" translate="yes" xml:space="preserve">
          <source>Test whether all matrix elements along a given axis evaluate to True.</source>
          <target state="translated">测试是否所有的矩阵元素沿着给定的轴计算为True。</target>
        </trans-unit>
        <trans-unit id="a8cd365e47952360dc676cadf55d3bc2ecae44b5" translate="yes" xml:space="preserve">
          <source>Test whether any array element along a given axis evaluates to True.</source>
          <target state="translated">测试沿给定轴的任何数组元素是否为True。</target>
        </trans-unit>
        <trans-unit id="e54011a9e26f7c9e97e1ca23a771785990f7e7d4" translate="yes" xml:space="preserve">
          <source>Test whether any element along a given axis evaluates to True.</source>
          <target state="translated">测试沿给定轴的任何元素是否为True。</target>
        </trans-unit>
        <trans-unit id="3c5d24b0586eac0954dbcb6d49897a1641c89d36" translate="yes" xml:space="preserve">
          <source>Test whether each element of a 1-D array is also present in a second array.</source>
          <target state="translated">测试一个一维数组的每个元素是否也存在于第二个数组中。</target>
        </trans-unit>
        <trans-unit id="025a700084bfede250ccd79227b915c047f7f35d" translate="yes" xml:space="preserve">
          <source>Test whether input is an instance of MaskedArray.</source>
          <target state="translated">测试输入是否是MaskedArray的实例。</target>
        </trans-unit>
        <trans-unit id="43d2fa7f4fbc625f4df01f08ea6653e49f950cbd" translate="yes" xml:space="preserve">
          <source>Testing Guidelines</source>
          <target state="translated">测试指南</target>
        </trans-unit>
        <trans-unit id="ef9606fae34bdb52d82ad257949ec42aea0b9b12" translate="yes" xml:space="preserve">
          <source>Testing Header Files</source>
          <target state="translated">测试头文件</target>
        </trans-unit>
        <trans-unit id="d322a0e8fe52f19dbe7d5bd52156ee63071b90d8" translate="yes" xml:space="preserve">
          <source>Testing Organization</source>
          <target state="translated">测试机构</target>
        </trans-unit>
        <trans-unit id="e3148b0ff766bdb8347a198898838253aab4da96" translate="yes" xml:space="preserve">
          <source>Testing Python Scripts</source>
          <target state="translated">测试Python脚本</target>
        </trans-unit>
        <trans-unit id="8c3a61a48bb499744371cb7fc30761102d86f229" translate="yes" xml:space="preserve">
          <source>Testing SWIG Interface Files</source>
          <target state="translated">测试SWIG接口文件</target>
        </trans-unit>
        <trans-unit id="34d08d85bddb11f11da76ad84dab43a94d74c7ed" translate="yes" xml:space="preserve">
          <source>Testing Source Files</source>
          <target state="translated">测试源文件</target>
        </trans-unit>
        <trans-unit id="7704b172077f920ddd46d5adbcffe86730e58a19" translate="yes" xml:space="preserve">
          <source>Testing looks for module-level or class-level setup and teardown functions by name; thus:</source>
          <target state="translated">测试按名称查找模块级或类级的设置和拆卸函数;因此。</target>
        </trans-unit>
        <trans-unit id="45ece46e91d1fe305feeee99aed2fad182be7b30" translate="yes" xml:space="preserve">
          <source>Testing the numpy.i Typemaps</source>
          <target state="translated">测试 numpy.i Typemaps</target>
        </trans-unit>
        <trans-unit id="417d130b240483956f423e540d6cb689832b6f9e" translate="yes" xml:space="preserve">
          <source>Tests on random data</source>
          <target state="translated">随机数据的测试</target>
        </trans-unit>
        <trans-unit id="f3d72180c504c070f745ad049bd21c11042867d1" translate="yes" xml:space="preserve">
          <source>Tests on random data are good, but since test failures are meant to expose new bugs or regressions, a test that passes most of the time but fails occasionally with no code changes is not helpful. Make the random data deterministic by setting the random number seed before generating it. Use either Python&amp;rsquo;s &lt;code&gt;random.seed(some_number)&lt;/code&gt; or NumPy&amp;rsquo;s &lt;code&gt;numpy.random.seed(some_number)&lt;/code&gt;, depending on the source of random numbers.</source>
          <target state="translated">对随机数据进行测试是好的，但是由于测试失败是为了暴露新的错误或回归，因此在大多数情况下通过但偶尔失败且没有代码更改的测试无济于事。通过在生成随机数种子之前对其进行设置，使随机数据具有确定性。使用Python的 &lt;code&gt;random.seed(some_number)&lt;/code&gt; 或NumPy的 &lt;code&gt;numpy.random.seed(some_number)&lt;/code&gt; ，具体取决于随机数的来源。</target>
        </trans-unit>
        <trans-unit id="927f696caa5bf0529c4f0991bbe8b99afb2fa55b" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float has a value equal to zero. This may be slightly faster than calling npy_half_eq(h, NPY_ZERO).</source>
          <target state="translated">测试半精度的浮点数是否等于零,这比调用npy_half_eq(h,NPY_ZERO)稍快。这可能比调用npy_half_eq(h,NPY_ZERO)稍快。</target>
        </trans-unit>
        <trans-unit id="b3be553d33f0513a6775eaa86f3391147a1aac09" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is a NaN.</source>
          <target state="translated">测试半精度浮点数是否为NaN。</target>
        </trans-unit>
        <trans-unit id="6424a62751d70065c8ad2d16d22d5e29e4d2e45c" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is finite (not NaN or Inf).</source>
          <target state="translated">测试半精度浮点数是否有限(不是NaN或Inf)。</target>
        </trans-unit>
        <trans-unit id="b796fd95ec3aee28c84902e310b3fcc5e87bd087" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is plus or minus Inf.</source>
          <target state="translated">测试半精度浮点数是正还是负Inf。</target>
        </trans-unit>
        <trans-unit id="9cad929af9630184e2ec9f960cd674271afcf718" translate="yes" xml:space="preserve">
          <source>Tests, that send messages to stderr, fail when executed from MSYS prompt because the messages are lost at some point.</source>
          <target state="translated">向stderr发送消息的测试,在MSYS提示下执行时失败,因为消息在某些时候丢失了。</target>
        </trans-unit>
        <trans-unit id="0a988a505d4f9bd1f41a57f4c2458a2423baedc7" translate="yes" xml:space="preserve">
          <source>Text files</source>
          <target state="translated">文本文件</target>
        </trans-unit>
        <trans-unit id="4ba343aecd438b7c22876dbbd27f537f09be5607" translate="yes" xml:space="preserve">
          <source>Text formatting options</source>
          <target state="translated">文本格式选项</target>
        </trans-unit>
        <trans-unit id="90e8faeace432448f3522160a796443560f628f2" translate="yes" xml:space="preserve">
          <source>That can be one of 12 different scalar types: &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;unsigned long long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">那可以是12种不同的标量类型之一：有 &lt;code&gt;signed char&lt;/code&gt; ， &lt;code&gt;unsigned char&lt;/code&gt; ， &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;unsigned short&lt;/code&gt; ， &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;unsigned int&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; ， &lt;code&gt;unsigned long&lt;/code&gt; ， &lt;code&gt;long long&lt;/code&gt; ， &lt;code&gt;unsigned long long&lt;/code&gt; ， &lt;code&gt;float&lt;/code&gt; 和 &lt;code&gt;double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be4b72468f984c83d93633e8f8bf75388e94a047" translate="yes" xml:space="preserve">
          <source>That is a looser test than originally documented, but agrees with what the actual implementation did up to rounding vagaries. An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">这是一个比最初记录的更宽松的测试,但与实际执行的情况一致,直到四舍五入的变化。在形状不匹配或值冲突时,会引发一个异常。与 numpy 中的标准用法不同,NaNs 是像数字一样进行比较的,如果两个对象的 NaNs 在相同的位置,则不会引发断言。</target>
        </trans-unit>
        <trans-unit id="31ca174a88927a9e0e7f8f15283f8ce9b3459f51" translate="yes" xml:space="preserve">
          <source>That is a looser test than originally documented, but agrees with what the actual implementation in &lt;a href=&quot;numpy.testing.assert_array_almost_equal#numpy.testing.assert_array_almost_equal&quot;&gt;&lt;code&gt;assert_array_almost_equal&lt;/code&gt;&lt;/a&gt; did up to rounding vagaries. An exception is raised at conflicting values. For ndarrays this delegates to assert_array_almost_equal</source>
          <target state="translated">这是一个比最初记录的测试宽松的测试，但与&lt;a href=&quot;numpy.testing.assert_array_almost_equal#numpy.testing.assert_array_almost_equal&quot;&gt; &lt;code&gt;assert_array_almost_equal&lt;/code&gt; 中&lt;/a&gt;的实际实现对舍入变幻莫测的结果是一致的。值冲突时会引发异常。对于ndarray，这委托给assert_array_almost_equal</target>
        </trans-unit>
        <trans-unit id="b5240cf478eeccab2d778da09495ef32dd780cc8" translate="yes" xml:space="preserve">
          <source>That support 74 different argument signatures for each data type, including:</source>
          <target state="translated">这支持每个数据类型的74种不同的论点签名,包括:</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="5c4c1c79691cc97764af36fe5679519dac98f423" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;busday&amp;rdquo; functions can additionally check a list of &amp;ldquo;holiday&amp;rdquo; dates, specific dates that are not valid days.</source>
          <target state="translated">&amp;ldquo; busday&amp;rdquo;功能还可以检查&amp;ldquo;假期&amp;rdquo;列表，这些日期不是有效日期。</target>
        </trans-unit>
        <trans-unit id="701df984a45b35c07efc7a2ab11dc3b2d9004e29" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;four quadrant&amp;rdquo; arctan of the angle formed by (&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;) and the positive &lt;code&gt;x&lt;/code&gt;-axis.</source>
          <target state="translated">由（ &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; ）和正 &lt;code&gt;x&lt;/code&gt; 轴形成的角度的&amp;ldquo;四象限&amp;rdquo;反正切。</target>
        </trans-unit>
        <trans-unit id="2adc5d4e116d43dd248737cacbfac03ed3ef63f9" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;y-intercept&amp;rdquo; and &amp;ldquo;slope&amp;rdquo; of the line, respectively.</source>
          <target state="translated">线的&amp;ldquo; y截距&amp;rdquo;和&amp;ldquo;斜率&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e4a0235cef14b392c275cecc105837cde82d5723" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;a&amp;rsquo; variable is unstripped from c[1] because whitespace leading.</source>
          <target state="translated">因为空格领先，所以'a'变量未从c [1]中剥离。</target>
        </trans-unit>
        <trans-unit id="bda37a7da4e6885245e567c4fedb24dc646e8a1c" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;out&amp;rsquo; keyword argument is expected to be a tuple with one entry per output (which can be &lt;code&gt;None&lt;/code&gt; for arrays to be allocated by the ufunc). For ufuncs with a single output, passing a single array (instead of a tuple holding a single array) is also valid.</source>
          <target state="translated">关键字'out'参数应为每个输出只有一个条目的元组（对于由ufunc分配的数组，可以为 &lt;code&gt;None&lt;/code&gt; ）。对于具有单个输出的ufunc，传递单个数组（而不是包含单个数组的元组）也是有效的。</target>
        </trans-unit>
        <trans-unit id="34701f78458bf915d5b828bf9386058d6824fbe4" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;per&amp;rsquo; variable represents the periods of the loan. Remember that financial equations start the period count at 1!</source>
          <target state="translated">&amp;ldquo;每&amp;rdquo;变量代表贷款的期限。请记住，财务方程式从1开始计算期间！</target>
        </trans-unit>
        <trans-unit id="cb090179fdd970838b19c1b214a4530cfcd16ee3" translate="yes" xml:space="preserve">
          <source>The (non-conjugated) transpose of the matrix.</source>
          <target state="translated">矩阵的(非共轭)转置。</target>
        </trans-unit>
        <trans-unit id="2c0a3ac18c0e35ff547f3a4005419b0e018f9e8e" translate="yes" xml:space="preserve">
          <source>The 1.6 implementation of datetime does not convert between units correctly.:</source>
          <target state="translated">1.6实现的datetime不能正确转换单位。</target>
        </trans-unit>
        <trans-unit id="f72725eb7318a896f41cd0cf447d8c91f324fb0d" translate="yes" xml:space="preserve">
          <source>The 1.6 implementation of datetime only works correctly for a small subset of arithmetic operations. Here we show some simple cases.:</source>
          <target state="translated">1.6版本的datetime只在一小部分算术运算中正确运行。这里我们展示了一些简单的案例。</target>
        </trans-unit>
        <trans-unit id="887cfe3b8a793575511e5fe48982dbd8c7813d6e" translate="yes" xml:space="preserve">
          <source>The 2-D output array.</source>
          <target state="translated">二维输出阵列。</target>
        </trans-unit>
        <trans-unit id="8d40d72287619706da0622aa60cf9b527faa81be" translate="yes" xml:space="preserve">
          <source>The 24 built-in &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;array scalar type objects&lt;/a&gt; all convert to an associated data-type object. This is true for their sub-classes as well.</source>
          <target state="translated">24个内置&lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;数组标量类型对象&lt;/a&gt;都转换为关联的数据类型对象。他们的子类别也是如此。</target>
        </trans-unit>
        <trans-unit id="44abfc0b778e06539587a775fdc8b33ee9085231" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; array flags can be &amp;ldquo;calculated&amp;rdquo; from the array object itself. This routine updates one or more of these flags of &lt;em&gt;arr&lt;/em&gt; as specified in &lt;em&gt;flagmask&lt;/em&gt; by performing the required calculation.</source>
          <target state="translated">的&lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;从阵列对象本身阵列标志可&amp;ldquo;计算&amp;rdquo;。此例程通过执行所需的计算来更新标志&lt;em&gt;掩码中&lt;/em&gt;指定的&lt;em&gt;arr&lt;/em&gt;标志中的一个或多个。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="83e501c171dddeb86862ef16beddd704b5bc114a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the built-in type of the data-type-descriptor objects used to describe how the bytes comprising the array are to be interpreted. There are 21 statically-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects for the built-in data-types. While these participate in reference counting, their reference count should never reach zero. There is also a dynamic table of user-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects that is also maintained. Once a data-type-descriptor object is &amp;ldquo;registered&amp;rdquo; it should never be deallocated either. The function &lt;a href=&quot;c-api.array#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to retrieve a &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object from an enumerated type-number (either built-in or user- defined).</source>
          <target state="translated">该&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt;是内置型的数据类型描述符的对象用于描述包含在阵列中的字节是如何被解释。内置数据类型有21个静态定义的&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;对象。尽管这些都参与了参考计数，但它们的参考计数绝不能达到零。还存在一个用户定义的&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;对象的动态表。一旦数据类型描述符对象被&amp;ldquo;注册&amp;rdquo;，它也绝不能被释放。函数&lt;a href=&quot;c-api.array#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）可用于从枚举的类型号（内置的或用户定义的）中检索&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="3bd6fb4bf6c794847df919e4e53f9f40e8a12e37" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure is defined so that NumPy and other extension modules can use the rapid array interface protocol. The &lt;code&gt;__array_struct__&lt;/code&gt; method of an object that supports the rapid array interface protocol should return a &lt;code&gt;PyCObject&lt;/code&gt; that contains a pointer to a &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure with the relevant details of the array. After the new array is created, the attribute should be &lt;code&gt;DECREF&lt;/code&gt;&amp;rsquo;d which will free the &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure. Remember to &lt;code&gt;INCREF&lt;/code&gt; the object (whose &lt;code&gt;__array_struct__&lt;/code&gt; attribute was retrieved) and point the base member of the new &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; to this same object. In this way the memory for the array will be managed correctly.</source>
          <target state="translated">该&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;结构被限定为使得NumPy的和其它的扩展模块可以使用快速阵列接口协议。所述 &lt;code&gt;__array_struct__&lt;/code&gt; 的对象的方法，该方法支持快速阵列接口协议应返回 &lt;code&gt;PyCObject&lt;/code&gt; 包含一个指向&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;与阵列的相关细节结构。创建新数组后，该属性应为 &lt;code&gt;DECREF&lt;/code&gt; ，这将释放&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;结构。记得 &lt;code&gt;INCREF&lt;/code&gt; 对象（其 &lt;code&gt;__array_struct__&lt;/code&gt; 属性被检索）和指向新的基体构件&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;到同一对象。这样，将正确管理阵列的内存。</target>
        </trans-unit>
        <trans-unit id="cd84e3bef1191839ce6ab3739e785dd2e1559188" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; C-structure contains all of the required information for an array. All instances of an ndarray (and its subclasses) will have this structure. For future compatibility, these structure members should normally be accessed using the provided macros. If you need a shorter name, then you can make use of &lt;code&gt;NPY_AO&lt;/code&gt; (deprecated) which is defined to be equivalent to &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; C-结构包含所有用于阵列所需的信息。ndarray（及其子类）的所有实例都将具有此结构。为了将来的兼容性，通常应使用提供的宏来访问这些结构成员。如果您需要一个较短的名称，则可以使用 &lt;code&gt;NPY_AO&lt;/code&gt; （已弃用），其定义与&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;等效。</target>
        </trans-unit>
        <trans-unit id="9d2c044849f6b8be8bb6f06a8ac4ced885f369cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure lies at the heart of the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt;. While it is described here for completeness, it should be considered internal to NumPy and manipulated via &lt;code&gt;PyArrayDescr_*&lt;/code&gt; or &lt;code&gt;PyDataType*&lt;/code&gt; functions and macros. The size of this structure is subject to change across versions of NumPy. To ensure compatibility:</source>
          <target state="translated">该&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;结构熟记于的心脏&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt;。尽管此处出于完整性的目的对其进行了说明，但应将其视为NumPy的内部内容，并通过 &lt;code&gt;PyArrayDescr_*&lt;/code&gt; 或 &lt;code&gt;PyDataType*&lt;/code&gt; 函数和宏进行操作。此结构的大小可能会在NumPy的各个版本中发生变化。为确保兼容性：</target>
        </trans-unit>
        <trans-unit id="2e3e60e01ee7ee0a4514d09bc8a1e601d0467625" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; typeobject implements many of the features of &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyTypeObject&quot;&gt;&lt;code&gt;Python objects&lt;/code&gt;&lt;/a&gt; including the &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_number&quot;&gt;&lt;code&gt;tp_as_number&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence&quot;&gt;&lt;code&gt;tp_as_sequence&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping&quot;&gt;&lt;code&gt;tp_as_mapping&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer&quot;&gt;&lt;code&gt;tp_as_buffer&lt;/code&gt;&lt;/a&gt; interfaces. The &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.richcmpfunc&quot;&gt;&lt;code&gt;rich comparison&lt;/code&gt;&lt;/a&gt;) is also used along with new-style attribute lookup for member (&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_members&quot;&gt;&lt;code&gt;tp_members&lt;/code&gt;&lt;/a&gt;) and properties (&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_getset&quot;&gt;&lt;code&gt;tp_getset&lt;/code&gt;&lt;/a&gt;). The &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; can also be sub-typed.</source>
          <target state="translated">该&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; typeobject实现了许多的功能&lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyTypeObject&quot;&gt; &lt;code&gt;Python objects&lt;/code&gt; &lt;/a&gt;包括&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_number&quot;&gt; &lt;code&gt;tp_as_number&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence&quot;&gt; &lt;code&gt;tp_as_sequence&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping&quot;&gt; &lt;code&gt;tp_as_mapping&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer&quot;&gt; &lt;code&gt;tp_as_buffer&lt;/code&gt; &lt;/a&gt;接口。在&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.richcmpfunc&quot;&gt; &lt;code&gt;rich comparison&lt;/code&gt; &lt;/a&gt;）也与新样式属性查找会员（用于沿&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_members&quot;&gt; &lt;code&gt;tp_members&lt;/code&gt; &lt;/a&gt;）和属性（&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_getset&quot;&gt; &lt;code&gt;tp_getset&lt;/code&gt; &lt;/a&gt;）。该&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;也可以是子类型。</target>
        </trans-unit>
        <trans-unit id="f2f36b5d156bf75520af226984583d62ec445b7c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module provides a set of vectorized string operations for arrays of type &lt;code&gt;numpy.string_&lt;/code&gt; or &lt;code&gt;numpy.unicode_&lt;/code&gt;. All of them are based on the string methods in the Python standard library.</source>
          <target state="translated">所述&lt;a href=&quot;#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;模块提供类型的数组的一组矢量的字符串操作的 &lt;code&gt;numpy.string_&lt;/code&gt; 或 &lt;code&gt;numpy.unicode_&lt;/code&gt; 。它们全部基于Python标准库中的字符串方法。</target>
        </trans-unit>
        <trans-unit id="2314014335c763a38d9f2613dc7158883ea47e7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module can be used as an addition to &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">所述&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt;模块可以被用作除了&lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; 的&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="bc31921d14e06fe1077c1cf00e508c39081a2db7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module comes with a specific implementation of most ufuncs. Unary and binary functions that have a validity domain (such as &lt;a href=&quot;generated/numpy.log#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.divide#numpy.divide&quot;&gt;&lt;code&gt;divide&lt;/code&gt;&lt;/a&gt;) return the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; constant whenever the input is masked or falls outside the validity domain:</source>
          <target state="translated">该&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt;模块配备了一个具体实施最ufuncs的。具有有效域（例如&lt;a href=&quot;generated/numpy.log#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;generated/numpy.divide#numpy.divide&quot;&gt; &lt;code&gt;divide&lt;/code&gt; &lt;/a&gt;）的一元和二进制函数在输入被屏蔽或超出有效域范围时返回&lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;常量：</target>
        </trans-unit>
        <trans-unit id="b2581729cb5a508c4225155bce5e9d0c211d34fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;存在与Numarray向后兼容类，所以不推荐在新的发展。从numpy的1.4开始，如果字符串中的一个需要数组，建议使用数组&lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; ， &lt;code&gt;string_&lt;/code&gt; 或 &lt;code&gt;unicode_&lt;/code&gt; ，以及在使用免费的功能&lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;快速矢量字符串操作模块。</target>
        </trans-unit>
        <trans-unit id="bfd56b98bdff55bc0967f4255e8d608e0cada88c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.char.chararray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.char.chararray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;物可类似于字典的（如在被访问 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ），或通过使用小写属性名称（如在 &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短标志名仅在字典访问中受支持。</target>
        </trans-unit>
        <trans-unit id="5b3e9186bfdffbf3c12bbb5a751b0411b0862a0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;存在与Numarray向后兼容类，所以不推荐在新的发展。从numpy的1.4开始，如果字符串中的一个需要数组，建议使用数组&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; ， &lt;code&gt;string_&lt;/code&gt; 或 &lt;code&gt;unicode_&lt;/code&gt; ，以及在使用免费的功能&lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;快速矢量字符串操作模块。</target>
        </trans-unit>
        <trans-unit id="3c48c115471617c80e93a7432dc970b4f61e8b90" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.MaskedArray.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt;, as a regular &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt; of any shape or datatype (the data).</source>
          <target state="translated">的&lt;a href=&quot;#numpy.ma.MaskedArray.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt;，作为常规&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt;任何形状或数据类型（数据）的。</target>
        </trans-unit>
        <trans-unit id="a0df6452154474f3f899180d65ac301d22c1fea9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.MaskedArray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.ma.MaskedArray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;物可类似于字典的（如在被访问 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ），或通过使用小写属性名称（如在 &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短标志名仅在字典访问中受支持。</target>
        </trans-unit>
        <trans-unit id="768878a0d288c4cac805d022d60e3e5c74cdd571" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; constant is a special case of &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, with a float datatype and a null shape. It is used to test whether a specific entry of a masked array is masked, or to mask one or several entries of a masked array:</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;常数的特殊情况&lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;，具有float数据类型和一个空的形状。它用于测试是否屏蔽了掩码数组的特定条目，或掩码了掩码数组的一个或多个条目：</target>
        </trans-unit>
        <trans-unit id="146a5b50c3ebb2fb745630d24192949df345a171" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.matrix.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.matrix.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;物可类似于字典的（如在被访问 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ），或通过使用小写属性名称（如在 &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短标志名仅在字典访问中受支持。</target>
        </trans-unit>
        <trans-unit id="59336961ce31b9039ac38b42d5319606fa0f917b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ndarray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.ndarray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;物可类似于字典的（如在被访问 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ），或通过使用小写属性名称（如在 &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短标志名仅在字典访问中受支持。</target>
        </trans-unit>
        <trans-unit id="550894140eb6b413b0c8bb49cded0a5d50198b4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; provides access to a wide range of distributions, and served as a replacement for &lt;code&gt;RandomState&lt;/code&gt;. The main difference between the two is that &lt;code&gt;Generator&lt;/code&gt; relies on an additional BitGenerator to manage state and generate the random bits, which are then transformed into random values from useful distributions. The default BitGenerator used by &lt;code&gt;Generator&lt;/code&gt; is &lt;code&gt;PCG64&lt;/code&gt;. The BitGenerator can be changed by passing an instantized BitGenerator to &lt;code&gt;Generator&lt;/code&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;可以访问广泛分布的，并作为一个替换 &lt;code&gt;RandomState&lt;/code&gt; 。两者之间的主要区别在于 &lt;code&gt;Generator&lt;/code&gt; 依赖于附加的BitGenerator来管理状态并生成随机位，然后将这些随机位从有用的分布转换为随机值。 &lt;code&gt;Generator&lt;/code&gt; 使用的默认BitGenerator 为 &lt;code&gt;PCG64&lt;/code&gt; 。可以通过将实例化的BitGenerator传递给 &lt;code&gt;Generator&lt;/code&gt; 来更改BitGenerator 。</target>
        </trans-unit>
        <trans-unit id="c4a823e24105a263472e6db5aa11ef1abc5d69b0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; provides access to legacy generators. This generator is considered frozen and will have no further improvements. It is guaranteed to produce the same values as the final point release of NumPy v1.16. These all depend on Box-Muller normals or inverse CDF exponentials or gammas. This class should only be used if it is essential to have randoms that are identical to what would have been produced by previous versions of NumPy.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;提供访问旧式发电机。该生成器被认为是冻结的，将没有进一步的改进。保证产生与NumPy v1.16的最终版本相同的值。这些都取决于Box-Muller法线或反CDF指数或伽马。仅当必须具有与以前版本的NumPy产生的随机数相同的随机数时，才应使用此类。</target>
        </trans-unit>
        <trans-unit id="81979ac862ad90b476e52b55f8477208f98b95b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.recarray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.recarray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;物可类似于字典的（如在被访问 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ），或通过使用小写属性名称（如在 &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短标志名仅在字典访问中受支持。</target>
        </trans-unit>
        <trans-unit id="84da36ced33272fa147152f5a355ea7313e10b52" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.sign&quot;&gt;&lt;code&gt;sign&lt;/code&gt;&lt;/a&gt; function returns &lt;code&gt;-1 if x &amp;lt; 0, 0 if x==0, 1 if x &amp;gt; 0&lt;/code&gt;. nan is returned for nan inputs.</source>
          <target state="translated">的&lt;a href=&quot;#numpy.sign&quot;&gt; &lt;code&gt;sign&lt;/code&gt; &lt;/a&gt;函数返回 &lt;code&gt;-1 if x &amp;lt; 0, 0 if x==0, 1 if x &amp;gt; 0&lt;/code&gt; 。返回nan作为nan输入。</target>
        </trans-unit>
        <trans-unit id="c8f5bdf7e480a14edfbd94978da2fd35d2b6fd26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.testing.decorators.deprecated&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt; decorator itself.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.testing.decorators.deprecated&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;装饰本身。</target>
        </trans-unit>
        <trans-unit id="f00c158e6b19c749648df9ba6c6e65d03c7d496b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.vectorize&quot;&gt;&lt;code&gt;vectorize&lt;/code&gt;&lt;/a&gt; function is provided primarily for convenience, not for performance. The implementation is essentially a for loop.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.vectorize&quot;&gt; &lt;code&gt;vectorize&lt;/code&gt; &lt;/a&gt;功能主要是为了方便而提供，而不是性能。该实现实质上是一个for循环。</target>
        </trans-unit>
        <trans-unit id="5870961c86339efdff46c3532a51705af2f592f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;datetime unit&lt;/a&gt; on which this dtype is based.</source>
          <target state="translated">此dtype所基于的&lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;datetime单位&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a98bd2e9d383259ba90aad2f3b46a4c0ddbbec99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../routines.testing#module-numpy.testing&quot;&gt;&lt;code&gt;numpy.testing&lt;/code&gt;&lt;/a&gt; module includes &lt;code&gt;import decorators as dec&lt;/code&gt;. A test can be decorated as slow like this:</source>
          <target state="translated">该&lt;a href=&quot;../routines.testing#module-numpy.testing&quot;&gt; &lt;code&gt;numpy.testing&lt;/code&gt; &lt;/a&gt;模块包括 &lt;code&gt;import decorators as dec&lt;/code&gt; 。可以像这样缓慢地装饰测试：</target>
        </trans-unit>
        <trans-unit id="c4d94d478ef39d11efc586cafc38818b04af19cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; function takes the iterators that have already been defined and uses them to determine the broadcast shape in each dimension (to create the iterators at the same time that broadcasting occurs then use the &lt;code&gt;PyMultiIter_New&lt;/code&gt; function). Then, the iterators are adjusted so that each iterator thinks it is iterating over an array with the broadcast size. This is done by adjusting the iterators number of dimensions, and the shape in each dimension. This works because the iterator strides are also adjusted. Broadcasting only adjusts (or adds) length-1 dimensions. For these dimensions, the strides variable is simply set to 0 so that the data-pointer for the iterator over that array doesn&amp;rsquo;t move as the broadcasting operation operates over the extended dimension.</source>
          <target state="translated">所述&lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt;函数采用已定义的迭代器和使用它们来确定在每个维度广播形状（在同一时间创建迭代器广播发生然后使用 &lt;code&gt;PyMultiIter_New&lt;/code&gt; 功能）。然后，调整迭代器，以便每个迭代器都认为它正在广播大小的数组上进行迭代。这可以通过调整迭代器的维数以及每个维中的形状来完成。这是可行的，因为还调整了迭代器的步幅。广播仅调整（或添加）长度为1的尺寸。对于这些维度，将strides变量简单地设置为0，以便当广播操作在扩展维度上进行操作时，该数组上迭代器的数据指针不会移动。</target>
        </trans-unit>
        <trans-unit id="d36f842f2997c8193b726b30df3debd673ecb729" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object can be used in all slicing operations to create an axis of length one. &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; is an alias for &amp;lsquo;None&amp;rsquo;, and &amp;lsquo;None&amp;rsquo; can be used in place of this with the same result.</source>
          <target state="translated">所述&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;对象可以在所有的限幅操作被用来创建一个长度的轴线。&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;是'None'的别名，可以使用'None'代替它并得到相同的结果。</target>
        </trans-unit>
        <trans-unit id="149f4058a1754093961b02f9ea6b9d5dd9c10925" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">该&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;存在与Numarray向后兼容类，所以不推荐在新的发展。从numpy的1.4开始，如果字符串中的一个需要数组，建议使用数组&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; ， &lt;code&gt;string_&lt;/code&gt; 或 &lt;code&gt;unicode_&lt;/code&gt; ，以及在使用免费的功能&lt;a href=&quot;routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;快速矢量字符串操作模块。</target>
        </trans-unit>
        <trans-unit id="f9537bf435fae2ec4edc2520b8aeb23abd0ca21e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; can be inherited from (in Python or in C) if desired. Therefore, it can form a foundation for many useful classes. Often whether to sub-class the array object or to simply use the core array component as an internal part of a new class is a difficult decision, and can be simply a matter of choice. NumPy has several tools for simplifying how your new object interacts with other array objects, and so the choice may not be significant in the end. One way to simplify the question is by asking yourself if the object you are interested in can be replaced as a single array or does it really require two or more arrays at its core.</source>
          <target state="translated">如果&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;可以从（在Python或C语言中）继承ndarray。因此，它可以为许多有用的类奠定基础。通常是对数组对象进行子类化还是将核心数组组件简单地用作新类的内部部分是一个困难的决定，并且可能只是选择问题。 NumPy有几个工具可以简化新对象与其他数组对象的交互方式，因此最终选择可能并不重要。简化问题的一种方法是问自己是否可以将感兴趣的对象替换为单个数组，或者它的核心确实需要两个或多个数组。</target>
        </trans-unit>
        <trans-unit id="c0cd171dc2a149543f352698d4bc596e7f8afac8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; will try to provide chunks that are as large as possible to the inner loop. By forcing &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; order, we get different external loop sizes. This mode is enabled by specifying an iterator flag.</source>
          <target state="translated">该&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;将尝试提供尽可能大的内循环块。通过强制执行&amp;ldquo; C&amp;rdquo;和&amp;ldquo; F&amp;rdquo;顺序，我们获得了不同的外部循环大小。通过指定迭代器标志启用此模式。</target>
        </trans-unit>
        <trans-unit id="f0287b2a9be936e86bf33e5d1e69557ad4042b14" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; is the user-facing object that is nearly identical to &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. The canonical method to initialize a generator passes a &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; bit generator as the sole argument.</source>
          <target state="translated">该&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;是面向用户的对象，它是几乎相同的&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;。初始化生成器的规范方法将&lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;位生成器作为唯一参数。</target>
        </trans-unit>
        <trans-unit id="a44536d85a990a438123d796af5725162190334f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;random generator&lt;/code&gt;&lt;/a&gt; takes the bit generator-provided stream and transforms them into more useful distributions, e.g., simulated normal random values. This structure allows alternative bit generators to be used with little code duplication.</source>
          <target state="translated">所述&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;random generator&lt;/code&gt; &lt;/a&gt;取位发生器提供的流，并将它们转换成更加有用的分布，例如，模拟正常的随机值。这种结构允许使用很少的代码重复就可以使用替代位生成器。</target>
        </trans-unit>
        <trans-unit id="f7f755efceb36d8200d20dc31c04e76cd3c9faf2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; type checking and conversion system is a complicated combination of C macros, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; macros, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemaps and &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; fragments. Fragments are a way to conditionally insert code into your wrapper file if it is needed, and not insert it if not needed. If multiple typemaps require the same fragment, the fragment only gets inserted into your wrapper code once.</source>
          <target state="translated">所述&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;类型检查和转换系统是C宏的复杂组合&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;宏&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemaps和&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;片段。片段是一种在需要时有条件地将代码插入包装文件的方法，而在不需要时则不插入代码。如果多个类型映射需要相同的片段，则该片段仅被插入到您的包装器代码中一次。</target>
        </trans-unit>
        <trans-unit id="1a20426fc7bb4d929b1ae303283b379020fbc254" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;numpy.polynomial.polynomial.polynomial.fit#numpy.polynomial.polynomial.Polynomial.fit&quot;&gt;&lt;code&gt;Polynomial.fit&lt;/code&gt;&lt;/a&gt; class method is recommended for new code as it is more stable numerically. See the documentation of the method for more information.</source>
          <target state="translated">对于新代码，建议使用&lt;a href=&quot;numpy.polynomial.polynomial.polynomial.fit#numpy.polynomial.polynomial.Polynomial.fit&quot;&gt; &lt;code&gt;Polynomial.fit&lt;/code&gt; &lt;/a&gt;类方法，因为它在数值上更稳定。有关更多信息，请参见该方法的文档。</target>
        </trans-unit>
        <trans-unit id="1ea1937064d555fd6f04fc2b57ae9e905ce9bf17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npy&lt;/code&gt; format is the standard binary file format in NumPy for persisting a &lt;em&gt;single&lt;/em&gt; arbitrary NumPy array on disk. The format stores all of the shape and dtype information necessary to reconstruct the array correctly even on another machine with a different architecture. The format is designed to be as simple as possible while achieving its limited goals.</source>
          <target state="translated">所述 &lt;code&gt;.npy&lt;/code&gt; 格式是在NumPy的用于持久化一个标准二进制文件格式&lt;em&gt;单&lt;/em&gt;上磁盘任意NumPy的阵列。该格式存储正确地重建阵列所需的所有形状和dtype信息，即使在具有不同体系结构的另一台机器上也是如此。该格式旨在在达到其有限目标的同时尽可能地简单。</target>
        </trans-unit>
        <trans-unit id="d25fde9120bc920bdf839700f32d6b700adf8720" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npy&lt;/code&gt; format, including motivation for creating it and a comparison of alternatives, is described in the &lt;a href=&quot;https://www.numpy.org/neps/nep-0001-npy-format.html&quot;&gt;&amp;ldquo;npy-format&amp;rdquo; NEP&lt;/a&gt;, however details have evolved with time and this document is more current.</source>
          <target state="translated">该 &lt;code&gt;.npy&lt;/code&gt; 格式，包括动机，创造它和替代的比较，在描述&lt;a href=&quot;https://www.numpy.org/neps/nep-0001-npy-format.html&quot;&gt;&amp;ldquo;NPY格式&amp;rdquo; NEP&lt;/a&gt;，但细节已经演变随着时间的推移而这个文件是更大的电流。</target>
        </trans-unit>
        <trans-unit id="22e53f126c53ee44cfae93fe323456796e3a7525" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; file format is a zipped archive of files named after the variables they contain. The archive is compressed with &lt;code&gt;zipfile.ZIP_DEFLATED&lt;/code&gt; and each file in the archive contains one variable in &lt;code&gt;.npy&lt;/code&gt; format. For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;.npz&lt;/code&gt; 文件格式是它们所包含的变量命名的文件的压缩文档。压缩文件使用 &lt;code&gt;zipfile.ZIP_DEFLATED&lt;/code&gt; 压缩，并且压缩文件中的每个文件都包含一个 &lt;code&gt;.npy&lt;/code&gt; 格式的变量。有关 &lt;code&gt;.npy&lt;/code&gt; 格式的说明，请参见&lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b51e4d01309ff5a759f392af08bb39d1e99043e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; file format is a zipped archive of files named after the variables they contain. The archive is not compressed and each file in the archive contains one variable in &lt;code&gt;.npy&lt;/code&gt; format. For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;.npz&lt;/code&gt; 文件格式是它们所包含的变量命名的文件的压缩文档。档案未压缩，档案中的每个文件都包含一个 &lt;code&gt;.npy&lt;/code&gt; 格式的变量。有关 &lt;code&gt;.npy&lt;/code&gt; 格式的说明，请参见&lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5c00dd2aa73f26e18024a200e3875179deacef9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; format is the standard format for persisting &lt;em&gt;multiple&lt;/em&gt; NumPy arrays on disk. A &lt;code&gt;.npz&lt;/code&gt; file is a zip file containing multiple &lt;code&gt;.npy&lt;/code&gt; files, one for each array.</source>
          <target state="translated">所述 &lt;code&gt;.npz&lt;/code&gt; 格式是用于持久化的标准格式&lt;em&gt;的多个&lt;/em&gt;磁盘上NumPy的阵列。甲 &lt;code&gt;.npz&lt;/code&gt; 文件是包含多个压缩文件 &lt;code&gt;.npy&lt;/code&gt; 文件，一个用于每个阵列。</target>
        </trans-unit>
        <trans-unit id="19658579206ac4f8753c064c0302ad76f2f72a46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ALIGNED&lt;/code&gt; flag of an ndarray, computed in &lt;code&gt;IsAligned&lt;/code&gt; and checked by &lt;code&gt;PyArray_ISALIGNED&lt;/code&gt;. This is computed from &lt;code&gt;dtype.alignment&lt;/code&gt;. It is set to &lt;code&gt;True&lt;/code&gt; if every item in the array is at a memory location consistent with &lt;code&gt;dtype.alignment&lt;/code&gt;, which is the case if the data ptr and all strides of the array are multiples of that alignment.</source>
          <target state="translated">所述 &lt;code&gt;ALIGNED&lt;/code&gt; 一个ndarray的标志，计算在 &lt;code&gt;IsAligned&lt;/code&gt; 和通过检查 &lt;code&gt;PyArray_ISALIGNED&lt;/code&gt; 。这是从 &lt;code&gt;dtype.alignment&lt;/code&gt; 计算的。如果数组中的每个项目都位于与 &lt;code&gt;dtype.alignment&lt;/code&gt; 一致的内存位置，则将其设置为 &lt;code&gt;True&lt;/code&gt; ,如果数据ptr和数组的所有跨度是该对齐的倍数，则为true。</target>
        </trans-unit>
        <trans-unit id="85388f353d8827d53025cb4498ec7c4f7175db9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BitGenerator&lt;/code&gt; has a limited set of responsibilities. It manages state and provides functions to produce random doubles and random unsigned 32- and 64-bit values.</source>
          <target state="translated">该 &lt;code&gt;BitGenerator&lt;/code&gt; 有一组有限的责任。它管理状态并提供产生随机双精度数和随机无符号32位和64位值的功能。</target>
        </trans-unit>
        <trans-unit id="29642d4a46e1b1f330f5d899a27d8931b3675855" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Configuration&lt;/code&gt; constructor has a fourth optional argument, &lt;code&gt;package_path&lt;/code&gt;, that can be used when package files are located in a different location than the directory of the &lt;code&gt;setup.py&lt;/code&gt; file.</source>
          <target state="translated">该 &lt;code&gt;Configuration&lt;/code&gt; 构造有第四个可选参数， &lt;code&gt;package_path&lt;/code&gt; ，当包文件位于不同的位置比所在的目录可以使用 &lt;code&gt;setup.py&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="d942d62411c592ee85272583cee21a0d612eb9cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MT19937&lt;/code&gt; state vector consists of a 624-element array of 32-bit unsigned integers plus a single integer value between 0 and 624 that indexes the current position within the main array.</source>
          <target state="translated">所述 &lt;code&gt;MT19937&lt;/code&gt; 状态向量由32位无符号整数一个624个元素的数组加一个整数值的0和624的索引主阵列内的当前位置。</target>
        </trans-unit>
        <trans-unit id="a95fd45cabac9b94aa97772f024779835dc306b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Makefile&lt;/code&gt; calls &lt;code&gt;swig&lt;/code&gt; to generate &lt;code&gt;Vector.py&lt;/code&gt; and &lt;code&gt;Vector_wrap.cxx&lt;/code&gt;, and also executes the &lt;code&gt;setup.py&lt;/code&gt; script that compiles &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; and links together the extension module &lt;code&gt;_Vector.so&lt;/code&gt; or &lt;code&gt;_Vector.dylib&lt;/code&gt;, depending on the platform. This extension module and the proxy file &lt;code&gt;Vector.py&lt;/code&gt; are both placed in a subdirectory under the &lt;code&gt;build&lt;/code&gt; directory.</source>
          <target state="translated">在 &lt;code&gt;Makefile&lt;/code&gt; 文件调用 &lt;code&gt;swig&lt;/code&gt; 生成 &lt;code&gt;Vector.py&lt;/code&gt; 和 &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; ，并执行 &lt;code&gt;setup.py&lt;/code&gt; ，编译脚本 &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; 和链接在一起的扩展模块 &lt;code&gt;_Vector.so&lt;/code&gt; 或 &lt;code&gt;_Vector.dylib&lt;/code&gt; ，根据不同的平台上。该扩展模块和代理文件 &lt;code&gt;Vector.py&lt;/code&gt; 都位于 &lt;code&gt;build&lt;/code&gt; 目录下的子目录中。</target>
        </trans-unit>
        <trans-unit id="a509290375510505b589158f3b8f2b07b506f6b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MaskedArray&lt;/code&gt; class</source>
          <target state="translated">该 &lt;code&gt;MaskedArray&lt;/code&gt; 类</target>
        </trans-unit>
        <trans-unit id="b55e755e6d26d2135c464a8b79f8ff9c154dcada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; constants are defined so that sizeof information is available to the pre-processor.</source>
          <target state="translated">所述 &lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; 常数定义为使得的sizeof信息是提供给预处理器。</target>
        </trans-unit>
        <trans-unit id="d918fc830e6f124f45ecb19bab96030d1a7583a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PCG64&lt;/code&gt; state vector consists of 2 unsigned 128-bit values, which are represented externally as Python ints. One is the state of the PRNG, which is advanced by a linear congruential generator (LCG). The second is a fixed odd increment used in the LCG.</source>
          <target state="translated">所述 &lt;code&gt;PCG64&lt;/code&gt; 状态矢量由2无符号的128位值，其在外部表示为整数的Python的。一种是PRNG的状态，它由线性同余生成器（LCG）进行高级处理。第二个是LCG中使用的固定奇数增量。</target>
        </trans-unit>
        <trans-unit id="c1a90ac63bb863a062bb153b73df1e64c4857aff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Philox&lt;/code&gt; state vector consists of a 256-bit value encoded as a 4-element uint64 array and a 128-bit value encoded as a 2-element uint64 array. The former is a counter which is incremented by 1 for every 4 64-bit randoms produced. The second is a key which determined the sequence produced. Using different keys produces independent sequences.</source>
          <target state="translated">所述 &lt;code&gt;Philox&lt;/code&gt; 状态向量由编码为4元件阵列UINT64一个256位的值的和一个128位的值编码为2元件UINT64阵列。前者是一个计数器，每产生4个64位随机数，计数器就会增加1。第二个是确定生成顺序的键。使用不同的键会产生独立的序列。</target>
        </trans-unit>
        <trans-unit id="4d1f94165781d8145f1fd80c467f6bd0f760f0b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SFC64&lt;/code&gt; state vector consists of 4 unsigned 64-bit values. The last is a 64-bit counter that increments by 1 each iteration.</source>
          <target state="translated">所述 &lt;code&gt;SFC64&lt;/code&gt; 状态向量由4无符号的64位值。最后一个是64位计数器，每次迭代递增1。</target>
        </trans-unit>
        <trans-unit id="395b8858a352467f67b6a09c4a5fc424e26cfad2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__init__.py&lt;/code&gt; file</source>
          <target state="translated">该 &lt;code&gt;__init__.py&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="55e0b71eae2cfd6e566258a88d10c513a1a5a113" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; keyword of the dtype constructor, which only affects structured arrays. If the structure&amp;rsquo;s field offsets are not manually provided numpy determines offsets automatically. In that case, &lt;code&gt;align=True&lt;/code&gt; pads the structure so that each field is &amp;ldquo;true&amp;rdquo; aligned in memory and sets &lt;code&gt;dtype.alignment&lt;/code&gt; to be the largest of the field &amp;ldquo;true&amp;rdquo; alignments. This is like what C-structs usually do. Otherwise if offsets or itemsize were manually provided &lt;code&gt;align=True&lt;/code&gt; simply checks that all the fields are &amp;ldquo;true&amp;rdquo; aligned and that the total itemsize is a multiple of the largest field alignment. In either case &lt;code&gt;dtype.isalignedstruct&lt;/code&gt; is also set to True.</source>
          <target state="translated">dtype构造函数的 &lt;code&gt;align&lt;/code&gt; 关键字，仅影响结构化数组。如果未手动提供结构的字段偏移量，则numpy会自动确定偏移量。在这种情况下， &lt;code&gt;align=True&lt;/code&gt; &lt;code&gt;dtype.alignment&lt;/code&gt; 结构，以便每个字段在内存中都是&amp;ldquo; true&amp;rdquo;对齐的，并将dtype.alignment设置为字段&amp;ldquo; true&amp;rdquo;对齐中的最大对齐。这就像C结构通常所做的那样。否则，如果手动提供了偏移量或项目大小，则 &lt;code&gt;align=True&lt;/code&gt; 仅检查所有字段是否为&amp;ldquo; true&amp;rdquo;对齐，并且总项目大小为最大字段对齐的倍数。无论哪种情况， &lt;code&gt;dtype.isalignedstruct&lt;/code&gt; 也都设置为True。</target>
        </trans-unit>
        <trans-unit id="dd27c9fa716237737a1b850fd84a88e9e84db97b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt;-clause of the &lt;code&gt;with&lt;/code&gt;-statement gives the current print options:</source>
          <target state="translated">该 &lt;code&gt;as&lt;/code&gt; 的-clause &lt;code&gt;with&lt;/code&gt; 语句来给出当前打印选项：</target>
        </trans-unit>
        <trans-unit id="caa858c948295450c18bcef4c572e68d7eda67a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; keyword can be used to specify a subset of axes of which the gradient is calculated</source>
          <target state="translated">所述 &lt;code&gt;axis&lt;/code&gt; 关键字可以被用来指定一个被计算的梯度轴的一个子集</target>
        </trans-unit>
        <trans-unit id="c68a2d64e2aeed4fdf4077c45259bb4b7c07822e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; parameter specifies the index of the new axis in the dimensions of the result. For example, if &lt;code&gt;axis=0&lt;/code&gt; it will be the first dimension and if &lt;code&gt;axis=-1&lt;/code&gt; it will be the last dimension.</source>
          <target state="translated">所述 &lt;code&gt;axis&lt;/code&gt; 参数指定新轴的在结果的尺寸的索引。例如，如果 &lt;code&gt;axis=0&lt;/code&gt; ，它将是第一个尺寸；如果 &lt;code&gt;axis=-1&lt;/code&gt; ，它将是最后的尺寸。</target>
        </trans-unit>
        <trans-unit id="7d4cb66724d02c13ff5f50a065c67d6d75a20a6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool_&lt;/code&gt; data type is very similar to the Python &lt;code&gt;BooleanType&lt;/code&gt; but does not inherit from it because Python&amp;rsquo;s &lt;code&gt;BooleanType&lt;/code&gt; does not allow itself to be inherited from, and on the C-level the size of the actual bool data is not the same as a Python Boolean scalar.</source>
          <target state="translated">该 &lt;code&gt;bool_&lt;/code&gt; 数据类型是非常相似的Python &lt;code&gt;BooleanType&lt;/code&gt; 但不继承它，因为Python的 &lt;code&gt;BooleanType&lt;/code&gt; 不允许自己被继承，并在C级的实际布尔数据的大小是不一样的一个Python布尔标量。</target>
        </trans-unit>
        <trans-unit id="1a9ec4df6ec3fb7357baf90864b29d969f59440a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool_&lt;/code&gt; type is not a subclass of the &lt;code&gt;int_&lt;/code&gt; type (the &lt;code&gt;bool_&lt;/code&gt; is not even a number type). This is different than Python&amp;rsquo;s default implementation of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; as a sub-class of int.</source>
          <target state="translated">所述 &lt;code&gt;bool_&lt;/code&gt; 类型不是的一个子类 &lt;code&gt;int_&lt;/code&gt; 类型（ &lt;code&gt;bool_&lt;/code&gt; 甚至不是一个数类型）。这与Python 作为int的子类的&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;的默认实现不同。</target>
        </trans-unit>
        <trans-unit id="3f5c3b6d52d4becfb53cc5a7dd0ae6b04cdb9085" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a prefix or suffix; rather, all combinations of its values are stripped.</source>
          <target state="translated">的 &lt;code&gt;chars&lt;/code&gt; 参数是要除去的字符串指定的字符集。如果省略或为None，则 &lt;code&gt;chars&lt;/code&gt; 参数默认为删除空格。该 &lt;code&gt;chars&lt;/code&gt; 参数不是前缀或后缀; 而是删除其值的所有组合。</target>
        </trans-unit>
        <trans-unit id="44ca716c299a61027880c154634feb6b89178fc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a prefix; rather, all combinations of its values are stripped.</source>
          <target state="translated">的 &lt;code&gt;chars&lt;/code&gt; 参数是要除去的字符串指定的字符集。如果省略或为None，则 &lt;code&gt;chars&lt;/code&gt; 参数默认为删除空格。该 &lt;code&gt;chars&lt;/code&gt; 参数不是前缀; 而是删除其值的所有组合。</target>
        </trans-unit>
        <trans-unit id="3ab81d1fe754db2126af526470043294b9859fdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a suffix; rather, all combinations of its values are stripped.</source>
          <target state="translated">的 &lt;code&gt;chars&lt;/code&gt; 参数是要除去的字符串指定的字符集。如果省略或为None，则 &lt;code&gt;chars&lt;/code&gt; 参数默认为删除空格。该 &lt;code&gt;chars&lt;/code&gt; 参数不是后缀; 而是删除其值的所有组合。</target>
        </trans-unit>
        <trans-unit id="c5f33c0fec12debe8698b9f3d00999bb3fb759ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype.alignment&lt;/code&gt; attribute (&lt;code&gt;descr-&amp;gt;alignment&lt;/code&gt; in C). This is meant to reflect the &amp;ldquo;true alignment&amp;rdquo; of the type. It has arch-dependent default values for all datatypes, with the exception of structured types created with &lt;code&gt;align=True&lt;/code&gt; as described below.</source>
          <target state="translated">所述 &lt;code&gt;dtype.alignment&lt;/code&gt; 属性（ &lt;code&gt;descr-&amp;gt;alignment&lt;/code&gt; 在C）。这是为了反映类型的&amp;ldquo;真实对齐&amp;rdquo;。对于所有数据类型，它都有与拱有关的默认值，但使用 &lt;code&gt;align=True&lt;/code&gt; 创建的结构化类型除外，如下所述。</target>
        </trans-unit>
        <trans-unit id="4e0428300bbf21ef1b533ffa3e86adb5ceddd8dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype&lt;/code&gt; parameter defines the underlying data type.</source>
          <target state="translated">的 &lt;code&gt;dtype&lt;/code&gt; 参数定义的底层数据的类型。</target>
        </trans-unit>
        <trans-unit id="93f7d511e2846b265125fabe4d5030e15709832e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;excluded&lt;/code&gt; argument can be used to prevent vectorizing over certain arguments. This can be useful for array-like arguments of a fixed length such as the coefficients for a polynomial as in &lt;a href=&quot;numpy.polyval#numpy.polyval&quot;&gt;&lt;code&gt;polyval&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在 &lt;code&gt;excluded&lt;/code&gt; 参数可以用来防止向量化对某些参数。这对于固定长度的类似数组的参数很有用，例如在&lt;a href=&quot;numpy.polyval#numpy.polyval&quot;&gt; &lt;code&gt;polyval&lt;/code&gt; 中&lt;/a&gt;的多项式系数：</target>
        </trans-unit>
        <trans-unit id="2beff53e54fda1bd096a7e81c4708f352287d275" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; attribute of the &lt;code&gt;PyArrayObject&lt;/code&gt; structure contains important information about the memory used by the array (pointed to by the data member) This flag information must be kept accurate or strange results and even segfaults may result.</source>
          <target state="translated">&lt;code&gt;PyArrayObject&lt;/code&gt; 结构的 &lt;code&gt;flags&lt;/code&gt; 属性包含有关数组使用的内存的重要信息（由数据成员指向）。必须保留此标志信息的准确性或奇怪的结果，甚至可能导致段错误。</target>
        </trans-unit>
        <trans-unit id="8b08d522b6b1cfd800cd6bda4d86b04d644f1baf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int_&lt;/code&gt; type does &lt;strong&gt;not&lt;/strong&gt; inherit from the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; built-in under Python 3, because type &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; is no longer a fixed-width integer type.</source>
          <target state="translated">所述 &lt;code&gt;int_&lt;/code&gt; 类型并&lt;strong&gt;没有&lt;/strong&gt;从继承&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;内置Python 3下，因为型&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;不再是固定宽度的整数类型。</target>
        </trans-unit>
        <trans-unit id="5032550323e57bc7dec27d8af2d8f9df18642750" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;itershape&lt;/code&gt; parameter allows you to force the iterator to have a specific iteration shape. It is an array of length &lt;code&gt;oa_ndim&lt;/code&gt;. When an entry is negative, its value is determined from the operands. This parameter allows automatically allocated outputs to get additional dimensions which don&amp;rsquo;t match up with any dimension of an input.</source>
          <target state="translated">使用 &lt;code&gt;itershape&lt;/code&gt; 参数可以强制迭代器具有特定的迭代形状。它是一个长度为 &lt;code&gt;oa_ndim&lt;/code&gt; 的数组。当条目为负数时，其值由操作数确定。此参数允许自动分配的输出获得与输入的任何尺寸都不匹配的其他尺寸。</target>
        </trans-unit>
        <trans-unit id="d1b139e99319cf8723f8471165f727072e0de12d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;k&lt;/code&gt; different &amp;ldquo;columns&amp;rdquo; to be sorted. The last column (or row if &lt;code&gt;keys&lt;/code&gt; is a 2D array) is the primary sort key.</source>
          <target state="translated">要排序的 &lt;code&gt;k&lt;/code&gt; 个不同的&amp;ldquo;列&amp;rdquo;。最后一列（如果 &lt;code&gt;keys&lt;/code&gt; 是2D数组，则为行）是主排序键。</target>
        </trans-unit>
        <trans-unit id="ab61433b884d13cbf28918d009f77e172c843e81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt; arrays of indices corresponding to the locations where &lt;code&gt;mask_func(np.ones((n, n)), k)&lt;/code&gt; is True.</source>
          <target state="translated">对应于 &lt;code&gt;mask_func(np.ones((n, n)), k)&lt;/code&gt; 为True 的位置的索引的 &lt;code&gt;n&lt;/code&gt; 个数组。</target>
        </trans-unit>
        <trans-unit id="68dcfe0b1fdf3a267f300958e2039277e48ae02c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new_order&lt;/code&gt; code can be any from the following:</source>
          <target state="translated">该 &lt;code&gt;new_order&lt;/code&gt; 代码可以是任何从以下方面：</target>
        </trans-unit>
        <trans-unit id="8693a0f592844bcf9978c5fbaa78f4621036206e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nonzero&lt;/code&gt; method of the condition array can also be called.</source>
          <target state="translated">也可以调用条件数组的 &lt;code&gt;nonzero&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="d18c665ad6cff39ded6fc90bc8648963ab9ee138" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; file contains several macros and routines that it uses internally to build its typemaps. However, these functions may be useful elsewhere in your interface file. These macros and routines are implemented as fragments, which are described briefly in the previous section. If you try to use one or more of the following macros or functions, but your compiler complains that it does not recognize the symbol, then you need to force these fragments to appear in your code using:</source>
          <target state="translated">该 &lt;code&gt;numpy.i&lt;/code&gt; 文件包含几个宏和例程，它在内部使用，以建立自己的typemaps。但是，这些功能在界面文件中的其他位置可能很有用。这些宏和例程作为片段实现，在上一节中进行了简要描述。如果尝试使用以下一个或多个宏或函数，但是编译器抱怨它无法识别该符号，则需要使用以下命令强制这些片段出现在代码中：</target>
        </trans-unit>
        <trans-unit id="9f4cb37fdc51e8b1f5c2b248e5fd15fdd94aa9b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; file is currently located in the &lt;code&gt;tools/swig&lt;/code&gt; sub-directory under the &lt;code&gt;numpy&lt;/code&gt; installation directory. Typically, you will want to copy it to the directory where you are developing your wrappers.</source>
          <target state="translated">该 &lt;code&gt;numpy.i&lt;/code&gt; 当前文件位于 &lt;code&gt;tools/swig&lt;/code&gt; 下子目录 &lt;code&gt;numpy&lt;/code&gt; 的安装目录。通常，您需要将其复制到开发包装程序的目录中。</target>
        </trans-unit>
        <trans-unit id="96831ff16133b13c87cfe870992604959917c570" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file also provides additional tools for wrapper developers, including:</source>
          <target state="translated">该 &lt;code&gt;numpy.i&lt;/code&gt; 接口文件还提供了额外的工具，用于包装的开发，其中包括：</target>
        </trans-unit>
        <trans-unit id="d04832f55eba99f2bc4cc0dceb3d718f68b6cac8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file does not support typemaps for output arrays, for several reasons. First, C/C++ return arguments are limited to a single value. This prevents obtaining dimension information in a general way. Second, arrays with hard-coded lengths are not permitted as return arguments. In other words:</source>
          <target state="translated">该 &lt;code&gt;numpy.i&lt;/code&gt; 接口文件不支持typemaps输出数组，有几个原因。首先，C / C ++返回参数限制为单个值。这阻止了以一般方式获得尺寸信息。其次，不允许将具有硬编码长度的数组作为返回参数。换一种说法：</target>
        </trans-unit>
        <trans-unit id="65e8b572ae6dc55c16aea9abc0f0766e897fe055" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file uses the &lt;code&gt;%numpy_typemaps&lt;/code&gt; macro to implement typemaps for the following C data types and &lt;code&gt;int&lt;/code&gt; dimension types:</source>
          <target state="translated">所述 &lt;code&gt;numpy.i&lt;/code&gt; 接口文件使用 &lt;code&gt;%numpy_typemaps&lt;/code&gt; 宏实施typemaps为下面的C数据类型和 &lt;code&gt;int&lt;/code&gt; 尺寸类型：</target>
        </trans-unit>
        <trans-unit id="d99e0e96fa984690444350c5bb3087380beb5586" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.ma&lt;/code&gt; module</source>
          <target state="translated">该 &lt;code&gt;numpy.ma&lt;/code&gt; 模块</target>
        </trans-unit>
        <trans-unit id="4c8ade543f0e1c46d97cf061c562c3116b9639d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;order&lt;/code&gt; keyword gives the index ordering both for &lt;em&gt;fetching&lt;/em&gt; the values from &lt;code&gt;a&lt;/code&gt;, and then &lt;em&gt;placing&lt;/em&gt; the values into the output array. For example, let&amp;rsquo;s say you have an array:</source>
          <target state="translated">的 &lt;code&gt;order&lt;/code&gt; 关键字给出的索引用于订购两者&lt;em&gt;取&lt;/em&gt;从值 &lt;code&gt;a&lt;/code&gt; ，然后&lt;em&gt;把&lt;/em&gt;该值代入输出阵列。例如，假设您有一个数组：</target>
        </trans-unit>
        <trans-unit id="022ed8cd0b6cf9d8c83ca5b8b482f20886ea6324" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;series&lt;/code&gt; is expected to be an instance of some polynomial series of one of the types supported by by the numpy.polynomial module, but could be some other class that supports the convert method.</source>
          <target state="translated">该 &lt;code&gt;series&lt;/code&gt; 应为numpy.polynomial模块支持的一种类型的多项式系列的实例，但也可以是其他支持convert方法的类。</target>
        </trans-unit>
        <trans-unit id="f4910f2b9024b32efada1e65d4c1134f65374f1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setup.py&lt;/code&gt; file</source>
          <target state="translated">该 &lt;code&gt;setup.py&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="0948550106d7d72b97910c4e4918bcddbe3d6d6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;signature&lt;/code&gt; argument allows for vectorizing functions that act on non-scalar arrays of fixed length. For example, you can use it for a vectorized calculation of Pearson correlation coefficient and its p-value:</source>
          <target state="translated">的 &lt;code&gt;signature&lt;/code&gt; 参数允许向量化上的固定长度的非标量阵列作用的功能。例如，可以将其用于皮尔逊相关系数及其p值的矢量化计算：</target>
        </trans-unit>
        <trans-unit id="19cc10b9b9bd6104c6aeb8b9be441a8dc8445028" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; argument must be a sequence that contains the following elements:</source>
          <target state="translated">的 &lt;code&gt;state&lt;/code&gt; 参数必须是包含下列元素的序列：</target>
        </trans-unit>
        <trans-unit id="28db18b99085783cc1cb19c430887ae4c1bd2dc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; tuple has the following items:</source>
          <target state="translated">该 &lt;code&gt;state&lt;/code&gt; 元组有以下三个项目：</target>
        </trans-unit>
        <trans-unit id="0e4c35736a2eec986972a33d172a5be16d326f7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tp_as_number&lt;/code&gt; methods use a generic approach to call whatever function has been registered for handling the operation. When the &lt;code&gt;_multiarray_umath module&lt;/code&gt; is imported, it sets the numeric operations for all arrays to the corresponding ufuncs. This choice can be changed with &lt;a href=&quot;c-api.ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt;&lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt;&lt;/a&gt; The &lt;code&gt;tp_str&lt;/code&gt; and &lt;code&gt;tp_repr&lt;/code&gt; methods can also be altered using &lt;a href=&quot;c-api.array#c.PyArray_SetStringFunction&quot;&gt;&lt;code&gt;PyArray_SetStringFunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;tp_as_number&lt;/code&gt; 方法使用一个通用的方法来调用函数的任何已登记处理操作。当 &lt;code&gt;_multiarray_umath module&lt;/code&gt; 被导入，它为所有阵列到相应ufuncs数字操作。这种选择可以改变&lt;a href=&quot;c-api.ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt; &lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;tp_str&lt;/code&gt; 和 &lt;code&gt;tp_repr&lt;/code&gt; 方法也可以使用改变&lt;a href=&quot;c-api.array#c.PyArray_SetStringFunction&quot;&gt; &lt;code&gt;PyArray_SetStringFunction&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88a54cde186ec5ee99014b55275737fd8ded4abc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;bounds&lt;/em&gt; argument is expected to be a (2 * iter-&amp;gt;ao-&amp;gt;nd) arrays, such as the range bound[2*i]-&amp;gt;bounds[2*i+1] defines the range where to walk for dimension i (both bounds are included in the walked coordinates). The bounds should be ordered for each dimension (bounds[2*i] &amp;lt;= bounds[2*i+1]).</source>
          <target state="translated">的&lt;em&gt;边界&lt;/em&gt;参数预期为一个（2 * iter-&amp;gt; AO-&amp;gt; ND）阵列，诸如结合的范围[2 * I] - &amp;gt;界[2 * I + 1]定义的范围内，其中以步行尺寸我（两个边界都包含在行走坐标中）。每个维度的边界应排序（bounds [2 * i] &amp;lt;= bounds [2 * i + 1]）。</target>
        </trans-unit>
        <trans-unit id="ea1fe523a0552e237800f38d8997bfcb72c8d0f5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;func&lt;/em&gt;, &lt;em&gt;data&lt;/em&gt;, &lt;em&gt;types&lt;/em&gt;, &lt;em&gt;name&lt;/em&gt;, and &lt;em&gt;doc&lt;/em&gt; arguments are not copied by &lt;a href=&quot;#c.PyUFunc_FromFuncAndData&quot;&gt;&lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt;&lt;/a&gt;. The caller must ensure that the memory used by these arrays is not freed as long as the ufunc object is alive.</source>
          <target state="translated">该&lt;em&gt;FUNC&lt;/em&gt;，&lt;em&gt;数据&lt;/em&gt;，&lt;em&gt;类型&lt;/em&gt;，&lt;em&gt;名称&lt;/em&gt;，和&lt;em&gt;文档&lt;/em&gt;参数不被复制&lt;a href=&quot;#c.PyUFunc_FromFuncAndData&quot;&gt; &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; &lt;/a&gt;。只要ufunc对象处于活动状态，调用者必须确保不释放这些数组使用的内存。</target>
        </trans-unit>
        <trans-unit id="20c9d63d4d93167ef641a021fb26c115a182b092" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;itemsize&lt;/em&gt; key allows the total size of the dtype to be set, and must be an integer large enough so all the fields are within the dtype. If the dtype being constructed is aligned, the &lt;em&gt;itemsize&lt;/em&gt; must also be divisible by the struct alignment. Total dtype &lt;em&gt;itemsize&lt;/em&gt; is limited to &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt;&lt;code&gt;ctypes.c_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">项目&lt;em&gt;大小&lt;/em&gt;键允许设置&lt;em&gt;dtype&lt;/em&gt;的总大小，并且必须是足够大的整数，以便所有字段都在dtype内。如果正在构造的&lt;em&gt;dtype&lt;/em&gt;是对齐的，则&lt;em&gt;itemsize&lt;/em&gt;也必须可以被struct对齐整除。&lt;em&gt;dtype项的&lt;/em&gt;总&lt;em&gt;大小&lt;/em&gt;限制为&lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt; &lt;code&gt;ctypes.c_int&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ed9f0881461d81b2f7af8ce5229589ca6d28abd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-dimensional FFT of real input.</source>
          <target state="translated">实数输入的&lt;em&gt;n&lt;/em&gt;维FFT。</target>
        </trans-unit>
        <trans-unit id="35066a9f7cb50260dfe6cd2d771163f62f1011ce" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">在&lt;em&gt;&amp;ntilde;&lt;/em&gt;维FFT。</target>
        </trans-unit>
        <trans-unit id="1f82e353fb8bee88c46f056efaf0e1b9b205e05a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;out&lt;/em&gt; argument to &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt; is not supported, &lt;code&gt;third&lt;/code&gt; has to be None.</source>
          <target state="translated">不支持&lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt;的&lt;em&gt;out&lt;/em&gt;参数， &lt;code&gt;third&lt;/code&gt; 必须为None。</target>
        </trans-unit>
        <trans-unit id="17d0c90784f11b0394d45b1939c2a01c10fdf407" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;shape&lt;/em&gt; is the fixed shape of the sub-array described by this data type, and &lt;em&gt;item_dtype&lt;/em&gt; the data type of the array.</source>
          <target state="translated">该&lt;em&gt;形状&lt;/em&gt;是由该数据类型所描述的子阵列的固定形状，并且&lt;em&gt;item_dtype&lt;/em&gt;阵列的数据类型。</target>
        </trans-unit>
        <trans-unit id="e35e90d2e4f0ba849a49c1795babe3ab2a9f08fe" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;side&lt;/em&gt; argument indicates whether the index returned should be that of the first suitable location (if &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt;) or of the last (if &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt;).</source>
          <target state="translated">所述&lt;em&gt;侧&lt;/em&gt;参数指示返回的索引是否应该是第一合适的位置的（如果 &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt; ）或最后的（如果 &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="099bc64f90d3db4f6c006d553b07493bf40349bd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sorter&lt;/em&gt; argument, if not &lt;code&gt;NULL&lt;/code&gt;, must be a 1D array of integer indices the same length as &lt;em&gt;self&lt;/em&gt;, that sorts it into ascending order. This is typically the result of a call to &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt;&lt;code&gt;PyArray_ArgSort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) Binary search is used to find the required insertion points.</source>
          <target state="translated">在&lt;em&gt;分选器&lt;/em&gt;的参数，如果不是 &lt;code&gt;NULL&lt;/code&gt; ，必须是整数索引的一维数组的长度相同&lt;em&gt;自我&lt;/em&gt;，即排序成升序排列。这通常是调用&lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt; &lt;code&gt;PyArray_ArgSort&lt;/code&gt; &lt;/a&gt;（...）的结果。二进制搜索用于查找所需的插入点。</target>
        </trans-unit>
        <trans-unit id="7fad9b84d117a49a76f66aa7359451abb9299209" translate="yes" xml:space="preserve">
          <source>The API exposed by NumPy for third-party extensions has grown over years of releases, and has allowed programmers to directly access NumPy functionality from C. This API can be best described as &amp;ldquo;organic&amp;rdquo;. It has emerged from multiple competing desires and from multiple points of view over the years, strongly influenced by the desire to make it easy for users to move to NumPy from Numeric and Numarray. The core API originated with Numeric in 1995 and there are patterns such as the heavy use of macros written to mimic Python&amp;rsquo;s C-API as well as account for compiler technology of the late 90&amp;rsquo;s. There is also only a small group of volunteers who have had very little time to spend on improving this API.</source>
          <target state="translated">NumPy公开的用于第三方扩展的API已经增长了许多年，并且允许程序员直接从C访问NumPy功能。此API最好描述为&amp;ldquo;有机&amp;rdquo;。多年来，它已经从多种竞争需求和多种观点中脱颖而出，强烈地受到了使用户易于从Numeric和Numarray迁移到NumPy的渴望的影响。核心API起源于Numeric于1995年，其模式有很多，例如大量使用模仿Python的C-API编写的宏以及90年代后期的编译器技术。也只有一小部分志愿者花很少的时间来改善此API。</target>
        </trans-unit>
        <trans-unit id="00284168716cc312202174053f58f3f176efd9f0" translate="yes" xml:space="preserve">
          <source>The Array Interface</source>
          <target state="translated">阵列接口</target>
        </trans-unit>
        <trans-unit id="0126a67e2a45442b450ea70b10470e175bf968af" translate="yes" xml:space="preserve">
          <source>The Bartlett window is defined as</source>
          <target state="translated">Bartlett窗口定义为</target>
        </trans-unit>
        <trans-unit id="937ca2e1b9d54c371bf73ce20e57493839ccf829" translate="yes" xml:space="preserve">
          <source>The Bartlett window is very similar to a triangular window, except that the end points are at zero. It is often used in signal processing for tapering a signal, without generating too much ripple in the frequency domain.</source>
          <target state="translated">巴特利特窗与三角窗非常相似,只是端点在零点。在信号处理中,它经常被用来对信号进行渐变,而不会在频域内产生过多的波纹。</target>
        </trans-unit>
        <trans-unit id="9c87b609239622a7f33fd7054a79bbe3b69d99bf" translate="yes" xml:space="preserve">
          <source>The Beta distribution is a special case of the Dirichlet distribution, and is related to the Gamma distribution. It has the probability distribution function</source>
          <target state="translated">Beta分布是Dirichlet分布的一种特例,与Gamma分布有关。它的概率分布函数为</target>
        </trans-unit>
        <trans-unit id="b111fe41355b271c80f9d028d2e71b1df692e910" translate="yes" xml:space="preserve">
          <source>The BitGenerator can also be directly accessed using the members of the basic RNG structure.</source>
          <target state="translated">也可以使用基本RNG结构的成员直接访问BitGenerator。</target>
        </trans-unit>
        <trans-unit id="fe9a0ff0e1aba5f3307dd340548f412e309bd12d" translate="yes" xml:space="preserve">
          <source>The BitGenerators have been designed to be extendable using standard tools for high-performance Python &amp;ndash; numba and Cython. The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; object can also be used with user-provided BitGenerators as long as these export a small set of required functions.</source>
          <target state="translated">BitGenerators设计为可使用用于高性能Python的标准工具numba和Cython进行扩展。该&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;目的也可以使用用户提供的BitGenerators使用，只要这些出口一小部分的所需功能。</target>
        </trans-unit>
        <trans-unit id="d038e7d7a9d5b6013d6bf710bb0f42c26b9ffb86" translate="yes" xml:space="preserve">
          <source>The Blackman window is a taper formed by using the first three terms of a summation of cosines. It was designed to have close to the minimal leakage possible. It is close to optimal, only slightly worse than a Kaiser window.</source>
          <target state="translated">布莱克曼窗是利用余弦相加的前三个项形成的锥度。它被设计为具有接近于最小的泄漏可能。它接近于最佳状态,只比凯撒窗稍差。</target>
        </trans-unit>
        <trans-unit id="df8aff554aa2b04bd579ded0666721d3f45ae21e" translate="yes" xml:space="preserve">
          <source>The Blackman window is defined as</source>
          <target state="translated">布莱克曼窗口定义为</target>
        </trans-unit>
        <trans-unit id="201133c822c73c7e6eedbd7735bf455db76c868e" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using &lt;code&gt;Generator&lt;/code&gt; for the normal distribution or any other distribution that relies on the normal such as the &lt;code&gt;gamma&lt;/code&gt; or &lt;code&gt;standard_t&lt;/code&gt;. If you require bitwise backward compatible streams, use &lt;code&gt;RandomState&lt;/code&gt;.</source>
          <target state="translated">用于生成NumPy法线的Box-Muller方法在&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 中&lt;/a&gt;不再可用。使用 &lt;code&gt;Generator&lt;/code&gt; 不能针对正态分布或依赖于法线的任何其他分布（例如 &lt;code&gt;gamma&lt;/code&gt; 或 &lt;code&gt;standard_t&lt;/code&gt; )使用精确的随机值进行再现。如果需要按位向后兼容的流，请使用 &lt;code&gt;RandomState&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="530afb1a91925fe435a9294f8360e96b319ffb64" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using Generator for the normal distribution or any other distribution that relies on the normal such as the &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.gamma#numpy.random.mtrand.RandomState.gamma&quot;&gt;&lt;code&gt;RandomState.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.standard_t#numpy.random.mtrand.RandomState.standard_t&quot;&gt;&lt;code&gt;RandomState.standard_t&lt;/code&gt;&lt;/a&gt;. If you require bitwise backward compatible streams, use &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于生成NumPy法线的Box-Muller方法在&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 中&lt;/a&gt;不再可用。使用Generator不能为正态分布或任何其他依赖于正态的分布（例如&lt;a href=&quot;generated/numpy.random.mtrand.randomstate.gamma#numpy.random.mtrand.RandomState.gamma&quot;&gt; &lt;code&gt;RandomState.gamma&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;generated/numpy.random.mtrand.randomstate.standard_t#numpy.random.mtrand.RandomState.standard_t&quot;&gt; &lt;code&gt;RandomState.standard_t&lt;/code&gt; )&lt;/a&gt;再现精确的随机值。如果需要按位向后兼容的流，请使用&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="08ca8f1d4aa8ba16007dde802489e6ef41f52bf0" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available.</source>
          <target state="translated">用于生成NumPy法线的Box-Muller方法不再可用。</target>
        </trans-unit>
        <trans-unit id="12c85becd504bcc9e1840ed9b25393915f66f319" translate="yes" xml:space="preserve">
          <source>The C code to be wrapped for argoutview arrays are characterized by pointers: pointers to the dimensions and double pointers to the data, so that these values can be passed back to the user. The argoutview typemap signatures are therefore</source>
          <target state="translated">argoutview数组要封装的C代码的特点是指针:指向维度的指针和指向数据的双指针,因此这些值可以传回给用户。因此,argoutview的类型映射签名为</target>
        </trans-unit>
        <trans-unit id="3b86dcfa016c911d4342c93c728710eb6da34647" translate="yes" xml:space="preserve">
          <source>The C-API is actually an array of function pointers. This array is created (and pointed to by a global variable) by import_ufunc. The global variable is either statically defined or allowed to be seen by other files depending on the state of &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt;&lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C-API实际上是一个函数指针数组。此数组由import_ufunc创建（并由全局变量指向）。根据&lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt; &lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt; &lt;/a&gt;的状态，全局变量是静态定义的，还是允许其他文件查看。</target>
        </trans-unit>
        <trans-unit id="27ac48dd933ed72b23987767613d8001cf662454" translate="yes" xml:space="preserve">
          <source>The C-structure corresponding to an object of &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; is used to keep track of a pointer into an N-dimensional array. It contains associated information used to quickly march through the array. The pointer can be adjusted in three basic ways: 1) advance to the &amp;ldquo;next&amp;rdquo; position in the array in a C-style contiguous fashion, 2) advance to an arbitrary N-dimensional coordinate in the array, and 3) advance to an arbitrary one-dimensional index into the array. The members of the &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure are used in these calculations. Iterator objects keep their own dimension and strides information about an array. This can be adjusted as needed for &amp;ldquo;broadcasting,&amp;rdquo; or to loop over only specific dimensions.</source>
          <target state="translated">对应于&lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; &lt;/a&gt;对象的C结构是&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;。所述&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;被用于跟踪的指针的成N维阵列。它包含用于快速遍历阵列的关联信息。可以通过三种基本方式来调整指针：1）以C样式的连续方式前进到数组中的&amp;ldquo;下一个&amp;rdquo;位置； 2）前进到数组中任意N维坐标，以及3）前进到数组中的任意N维坐标。数组中的任意一维索引。&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;的成员这些计算中使用结构。迭代器对象保留其自己的尺寸，并遍历有关数组的信息。可以根据需要进行&amp;ldquo;广播&amp;rdquo;调整，也可以仅在特定尺寸上循环播放。</target>
        </trans-unit>
        <trans-unit id="5b65035b5e2ef1f9ddd680e8269d8b6e8cd78edf" translate="yes" xml:space="preserve">
          <source>The C-structure corresponding to an object of &lt;a href=&quot;#c.PyArrayNeighborhoodIter_Type&quot;&gt;&lt;code&gt;PyArrayNeighborhoodIter_Type&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;#c.PyArrayNeighborhoodIterObject&quot;&gt;&lt;code&gt;PyArrayNeighborhoodIterObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对应于&lt;a href=&quot;#c.PyArrayNeighborhoodIter_Type&quot;&gt; &lt;code&gt;PyArrayNeighborhoodIter_Type&lt;/code&gt; &lt;/a&gt;对象的C结构是&lt;a href=&quot;#c.PyArrayNeighborhoodIterObject&quot;&gt; &lt;code&gt;PyArrayNeighborhoodIterObject&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b70a592ea3e52c944c4250fca143b3a7150ee3c2" translate="yes" xml:space="preserve">
          <source>The Cauchy distribution arises in the solution to the driven harmonic oscillator problem, and also describes spectral line broadening. It also describes the distribution of values at which a line tilted at a random angle will cut the x axis.</source>
          <target state="translated">Cauchy分布是在解决驱动谐波振荡器问题时产生的,也描述了谱线拓宽。它还描述了以随机角度倾斜的线将切断x轴的值的分布。</target>
        </trans-unit>
        <trans-unit id="7e16b7bac76fd95a18826e75104c29f03fcae229" translate="yes" xml:space="preserve">
          <source>The Chebyshev class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the methods listed below.</source>
          <target state="translated">Chebyshev类提供标准的Python数值方法'+'，'-'，'*'，'//'，'％'，'divmod'，'**'和'（）'以及列出的方法下面。</target>
        </trans-unit>
        <trans-unit id="993466511b9f370f4f72797c543b0fe46fcac4af" translate="yes" xml:space="preserve">
          <source>The Chebyshev series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Chebyshev系列基础多项式不是 &lt;code&gt;x&lt;/code&gt; 的幂，因此此函数的结果似乎不直观。</target>
        </trans-unit>
        <trans-unit id="46d5d357969a2c2d8e943734dcd70f209f532e7d" translate="yes" xml:space="preserve">
          <source>The Cholesky decomposition is often used as a fast way of solving</source>
          <target state="translated">Cholesky分解法经常被用来作为快速解决</target>
        </trans-unit>
        <trans-unit id="7319ec02e3cbbaab7add308cd0a417516f369a3b" translate="yes" xml:space="preserve">
          <source>The DFT is defined, with the conventions used in this implementation, in the documentation for the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">使用此实现中使用的约定在&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt;模块的文档中定义了DFT。</target>
        </trans-unit>
        <trans-unit id="c850428d828f95dc2c92af14d3b7a369fbb6f873" translate="yes" xml:space="preserve">
          <source>The DFT is in general defined for complex inputs and outputs, and a single-frequency component at linear frequency</source>
          <target state="translated">一般来说,DFT是针对复杂的输入和输出而定义的,在线性频率下的单频分量。</target>
        </trans-unit>
        <trans-unit id="e1f0dbe8081449397bad0aa2cc6ad0fe41215d23" translate="yes" xml:space="preserve">
          <source>The Datetime and Timedelta data types support a large number of time units, as well as generic units which can be coerced into any of the other units based on input data.</source>
          <target state="translated">Datetime和Timedelta数据类型支持大量的时间单位,以及通用单位,这些单位可以根据输入数据被强制成任何其他单位。</target>
        </trans-unit>
        <trans-unit id="fcc8fbde1f068047c588e86f64b1d9bca100dc12" translate="yes" xml:space="preserve">
          <source>The Dirichlet distribution is a distribution over vectors</source>
          <target state="translated">Dirichlet分布是一个在向量上的分布。</target>
        </trans-unit>
        <trans-unit id="a4edf1637ded5c0257b8e49c407baa1302046498" translate="yes" xml:space="preserve">
          <source>The Einstein summation convention can be used to compute many multi-dimensional, linear algebraic array operations. &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; provides a succinct way of representing these.</source>
          <target state="translated">爱因斯坦求和约定可用于计算许多多维的线性代数数组运算。&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;提供了一种简洁的表示方式。</target>
        </trans-unit>
        <trans-unit id="28b073ac0a61d366802edc13aac74cfca673e0d2" translate="yes" xml:space="preserve">
          <source>The Euler constant</source>
          <target state="translated">欧拉常数</target>
        </trans-unit>
        <trans-unit id="e516b8e0c93fdf83378c5af74b4c3f11ab8b2eec" translate="yes" xml:space="preserve">
          <source>The F statistic is used to compare in-group variances to between-group variances. Calculating the distribution depends on the sampling, and so it is a function of the respective degrees of freedom in the problem. The variable &lt;code&gt;dfnum&lt;/code&gt; is the number of samples minus one, the between-groups degrees of freedom, while &lt;code&gt;dfden&lt;/code&gt; is the within-groups degrees of freedom, the sum of the number of samples in each group minus the number of groups.</source>
          <target state="translated">F统计量用于比较组内方差与组间方差。计算分布取决于采样，因此它是问题中各个自由度的函数。变量 &lt;code&gt;dfnum&lt;/code&gt; 是样本数减去一，即组间自由度，而 &lt;code&gt;dfden&lt;/code&gt; 是组内自由度，即每组样本数的总和减去组数。</target>
        </trans-unit>
        <trans-unit id="255611abe871551a6f0d10449c721d9ac320d3a5" translate="yes" xml:space="preserve">
          <source>The Frobenius norm is given by &lt;a href=&quot;#rac1c834adb66-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="translated">Frobenius范数由&lt;a href=&quot;#rac1c834adb66-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;给出：</target>
        </trans-unit>
        <trans-unit id="7783b7563d5c19477bd0cec8f560b128f37ead00" translate="yes" xml:space="preserve">
          <source>The Gamma distribution is often used to model the times to failure of electronic components, and arises naturally in processes for which the waiting times between Poisson distributed events are relevant.</source>
          <target state="translated">Gamma分布经常被用来模拟电子元件的失效时间,并且自然而然地出现在与泊松分布事件之间的等待时间相关的过程中。</target>
        </trans-unit>
        <trans-unit id="9c990e445bfb7966adc1e3b9adac640f1e0e9113" translate="yes" xml:space="preserve">
          <source>The Generator&amp;rsquo;s normal, exponential and gamma functions use 256-step Ziggurat methods which are 2-10 times faster than NumPy&amp;rsquo;s Box-Muller or inverse CDF implementations.</source>
          <target state="translated">Generator的常规，指数和伽马函数使用256步Ziggurat方法，比NumPy的Box-Muller或CDF逆实现快2-10倍。</target>
        </trans-unit>
        <trans-unit id="5fd129bc188ef44c6bd32a38b068d9f3ddc783f7" translate="yes" xml:space="preserve">
          <source>The Gumbel (named for German mathematician Emil Julius Gumbel) was used very early in the hydrology literature, for modeling the occurrence of flood events. It is also used for modeling maximum wind speed and rainfall rates. It is a &amp;ldquo;fat-tailed&amp;rdquo; distribution - the probability of an event in the tail of the distribution is larger than if one used a Gaussian, hence the surprisingly frequent occurrence of 100-year floods. Floods were initially modeled as a Gaussian process, which underestimated the frequency of extreme events.</source>
          <target state="translated">Gumbel（以德国数学家Emil Julius Gumbel的名字命名）在水文学中很早就被用来模拟洪水事件的发生。它也用于建模最大风速和降雨量。这是一种&amp;ldquo;肥尾&amp;rdquo;分布-分布尾部发生事件的可能性大于使用高斯分布的情况，因此令人惊讶地频繁发生了100年的洪水。洪水最初被建模为高斯过程，这高估了极端事件的发生频率。</target>
        </trans-unit>
        <trans-unit id="aa1cbdb34f4d0d2f5ba482222c9284e53a83897b" translate="yes" xml:space="preserve">
          <source>The Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme Value Type I) distribution is one of a class of Generalized Extreme Value (GEV) distributions used in modeling extreme value problems. The Gumbel is a special case of the Extreme Value Type I distribution for maximums from distributions with &amp;ldquo;exponential-like&amp;rdquo; tails.</source>
          <target state="translated">Gumbel（或最小极值（SEV）或I最小极值类型）分布是用于建模极值问题的一类广义极值（GEV）分布之一。Gumbel是I极值类型分布的一种特例，用于从带有&amp;ldquo;指数状&amp;rdquo;尾部的分布中获得最大值。</target>
        </trans-unit>
        <trans-unit id="d38e3c533241c1cffef7a77e2fb316d839d0e953" translate="yes" xml:space="preserve">
          <source>The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and is described in Blackman and Tukey. It was recommended for smoothing the truncated autocovariance function in the time domain. Most references to the Hamming window come from the signal processing literature, where it is used as one of many windowing functions for smoothing values. It is also known as an apodization (which means &amp;ldquo;removing the foot&amp;rdquo;, i.e. smoothing discontinuities at the beginning and end of the sampled signal) or tapering function.</source>
          <target state="translated">Hamming以JW Tukey的合伙人RW Hamming的名字命名，并在Blackman和Tukey中进行了描述。建议在时域中平滑截断的自协方差函数。对汉明窗的大多数参考来自信号处理文献，在该文献中，汉明窗用作平滑值的许多窗函数之一。这也被称为切趾（apodization）（意思是&amp;ldquo;移开脚&amp;rdquo;，即在采样信号的开始和结束处平滑不连续点）或渐缩功能。</target>
        </trans-unit>
        <trans-unit id="f6f99a10c7b1d0ed496e360cabc47ad0e8b4f95f" translate="yes" xml:space="preserve">
          <source>The Hamming window is a taper formed by using a weighted cosine.</source>
          <target state="translated">汉明窗是利用加权余弦形成的锥度。</target>
        </trans-unit>
        <trans-unit id="c543c8775de7884a498fb8d25199a6da7865f313" translate="yes" xml:space="preserve">
          <source>The Hamming window is defined as</source>
          <target state="translated">汉明窗口定义为</target>
        </trans-unit>
        <trans-unit id="c53c036c06b914f30dfda36ac484fab584082b10" translate="yes" xml:space="preserve">
          <source>The Hanning was named for Julius von Hann, an Austrian meteorologist. It is also known as the Cosine Bell. Some authors prefer that it be called a Hann window, to help avoid confusion with the very similar Hamming window.</source>
          <target state="translated">汉宁号是以奥地利气象学家Julius von Hann的名字命名的。它也被称为余弦钟。有些作者喜欢把它称为汉恩窗,以避免与非常相似的汉明窗相混淆。</target>
        </trans-unit>
        <trans-unit id="ff9ff54dbcac5fb28018a438cebbfd23097afaae" translate="yes" xml:space="preserve">
          <source>The Hanning window is a taper formed by using a weighted cosine.</source>
          <target state="translated">汉宁窗是利用加权余弦形成的锥度。</target>
        </trans-unit>
        <trans-unit id="7063e81cb7e74fa0cdbf05d1c6333c059e7c5e09" translate="yes" xml:space="preserve">
          <source>The Hanning window is defined as</source>
          <target state="translated">汉宁窗口定义为</target>
        </trans-unit>
        <trans-unit id="48a86546760e1edd4295f33a270bba0337fe9c75" translate="yes" xml:space="preserve">
          <source>The Heaviside step function is defined as:</source>
          <target state="translated">Heaviside阶梯函数定义为:</target>
        </trans-unit>
        <trans-unit id="a4ab8a335073ed439b508ce34550cc0419ac6836" translate="yes" xml:space="preserve">
          <source>The Hermite class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Hermite类提供标准的Python数值方法'+'，'-'，'*'，'//'，'％'，'divmod'，'**'和'（）'以及属性和 &lt;code&gt;ABCPolyBase&lt;/code&gt; 文档中列出的方法。</target>
        </trans-unit>
        <trans-unit id="18c51c2fe8d0823ca52707c91973d012f1770684" translate="yes" xml:space="preserve">
          <source>The Hermite series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Hermite系列基础多项式不是 &lt;code&gt;x&lt;/code&gt; 的幂，因此此函数的结果似乎不直观。</target>
        </trans-unit>
        <trans-unit id="29f886dede3063b00d8467b1f756a147bc393097" translate="yes" xml:space="preserve">
          <source>The HermiteE class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">HermiteE类提供标准的Python数值方法'+'，'-'，'*'，'//'，'％'，'divmod'，'**'和'（）'以及属性和 &lt;code&gt;ABCPolyBase&lt;/code&gt; 文档中列出的方法。</target>
        </trans-unit>
        <trans-unit id="8cc8b1724a44c8d63d2cfd0d81bc585f17fc260c" translate="yes" xml:space="preserve">
          <source>The HermiteE series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">HermiteE系列基础多项式不是 &lt;code&gt;x&lt;/code&gt; 的幂，因此此函数的结果似乎不直观。</target>
        </trans-unit>
        <trans-unit id="d4c697a75ca6fe93876f5946baa1a9463872c64a" translate="yes" xml:space="preserve">
          <source>The IRR is perhaps best understood through an example (illustrated using np.irr in the Examples section below). Suppose one invests 100 units and then makes the following withdrawals at regular (fixed) intervals: 39, 59, 55, 20. Assuming the ending value is 0, one&amp;rsquo;s 100 unit investment yields 173 units; however, due to the combination of compounding and the periodic withdrawals, the &amp;ldquo;average&amp;rdquo; rate of return is neither simply 0.73/4 nor (1.73)^0.25-1. Rather, it is the solution (for</source>
          <target state="translated">可以通过一个示例（在下面的&amp;ldquo;示例&amp;rdquo;部分中使用np.irr进行说明）来最好地理解IRR。假设某人投资100个单位，然后以固定的（固定的）时间间隔进行以下提取：39、59、55、20。假设最终值为0，则某人的100个单位投资产生173个单位；然而，由于复利和定期提款的结合，&amp;ldquo;平均&amp;rdquo;回报率既不是简单的0.73 / 4也不是（1.73）^ 0.25-1。而是解决方案</target>
        </trans-unit>
        <trans-unit id="ddbfb62d79e442dbada344aa5b0b7d3f75bd62fd" translate="yes" xml:space="preserve">
          <source>The Kaiser can approximate many other windows by varying the beta parameter.</source>
          <target state="translated">凯撒可以通过改变β参数来近似其他许多窗口。</target>
        </trans-unit>
        <trans-unit id="61a6a7b7c0a7a3c07a636b9187a5aa5c8ed22e80" translate="yes" xml:space="preserve">
          <source>The Kaiser was named for Jim Kaiser, who discovered a simple approximation to the DPSS window based on Bessel functions. The Kaiser window is a very good approximation to the Digital Prolate Spheroidal Sequence, or Slepian window, which is the transform which maximizes the energy in the main lobe of the window relative to total energy.</source>
          <target state="translated">Kaiser是以Jim Kaiser命名的,他发现了一个基于Bessel函数的DPSS窗口的简单近似。Kaiser窗是数字普罗尔球体序列的一个非常好的近似,或者说是Slepian窗,它是相对于总能量而言,使窗口主叶的能量最大化的变换。</target>
        </trans-unit>
        <trans-unit id="3c47d6f84b8a7a5230ef01c3b24f485faf045505" translate="yes" xml:space="preserve">
          <source>The Kaiser window is a taper formed by using a Bessel function.</source>
          <target state="translated">凯撒窗是利用贝塞尔函数形成的锥度。</target>
        </trans-unit>
        <trans-unit id="d40317952ac62ac63be6a7eb42d8bb031447a844" translate="yes" xml:space="preserve">
          <source>The Kaiser window is defined as</source>
          <target state="translated">凯撒窗的定义为</target>
        </trans-unit>
        <trans-unit id="de389ba4bc7accb91ca973f3199d4d09bb36d074" translate="yes" xml:space="preserve">
          <source>The Laguerre class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Laguerre类提供标准的Python数值方法'+'，'-'，'*'，'//'，'％'，'divmod'，'**'和'（）'以及属性和 &lt;code&gt;ABCPolyBase&lt;/code&gt; 文档中列出的方法。</target>
        </trans-unit>
        <trans-unit id="673da347447c32096475798f43cd3eae37f1e962" translate="yes" xml:space="preserve">
          <source>The Laguerre series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Laguerre系列基础多项式不是 &lt;code&gt;x&lt;/code&gt; 的幂，因此此函数的结果似乎不直观。</target>
        </trans-unit>
        <trans-unit id="beacaa427ac9dd11f90d057bc9c94b6f47608f00" translate="yes" xml:space="preserve">
          <source>The Laplace distribution is similar to the Gaussian/normal distribution, but is sharper at the peak and has fatter tails. It represents the difference between two independent, identically distributed exponential random variables.</source>
          <target state="translated">拉普拉斯分布类似于高斯/正态分布,但其峰值更尖锐,尾部更粗。它表示两个独立的、相同分布的指数随机变量之间的差异。</target>
        </trans-unit>
        <trans-unit id="9f6965544802824fa340cc542a5a8e5ec41b1a8a" translate="yes" xml:space="preserve">
          <source>The Legendre class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Legendre类提供标准的Python数值方法'+'，'-'，'*'，'//'，'％'，'divmod'，'**'和'（）'以及属性和 &lt;code&gt;ABCPolyBase&lt;/code&gt; 文档中列出的方法。</target>
        </trans-unit>
        <trans-unit id="083c119f1df4d844bfc4b2160deea854a1daea76" translate="yes" xml:space="preserve">
          <source>The Legendre series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">勒让德级数基础多项式不是 &lt;code&gt;x&lt;/code&gt; 的幂，因此此函数的结果似乎不直观。</target>
        </trans-unit>
        <trans-unit id="191a6c01d66efbf4468b0c4b76d708edbb3efb30" translate="yes" xml:space="preserve">
          <source>The Logistic distribution is used in Extreme Value problems where it can act as a mixture of Gumbel distributions, in Epidemiology, and by the World Chess Federation (FIDE) where it is used in the Elo ranking system, assuming the performance of each player is a logistically distributed random variable.</source>
          <target state="translated">Logistic分布被用于极值问题中,它可以作为Gumbel分布的混合物,在流行病学中,世界棋联(FIDE)在Elo排名系统中使用它,假设每个棋手的表现是一个逻辑分布的随机变量。</target>
        </trans-unit>
        <trans-unit id="7e46f1b490ad93ea0aa4b70cea1c8217c1eeec4d" translate="yes" xml:space="preserve">
          <source>The Lomax or Pareto II distribution is a shifted Pareto distribution. The classical Pareto distribution can be obtained from the Lomax distribution by adding 1 and multiplying by the scale parameter &lt;code&gt;m&lt;/code&gt; (see Notes). The smallest value of the Lomax distribution is zero while for the classical Pareto distribution it is &lt;code&gt;mu&lt;/code&gt;, where the standard Pareto distribution has location &lt;code&gt;mu = 1&lt;/code&gt;. Lomax can also be considered as a simplified version of the Generalized Pareto distribution (available in SciPy), with the scale set to one and the location set to zero.</source>
          <target state="translated">Lomax或Pareto II分布是移位的Pareto分布。可以通过将Lomax分布加1并乘以比例参数 &lt;code&gt;m&lt;/code&gt; 来获得经典的Pareto分布（请参见注释）。Lomax分布的最小值为零，而经典Pareto分布的最小值为 &lt;code&gt;mu&lt;/code&gt; ，而标准Pareto分布的位置为 &lt;code&gt;mu = 1&lt;/code&gt; 。Lomax也可以被视为Generalized Pareto分布的简化版本（在SciPy中可用），比例设置为1，位置设置为零。</target>
        </trans-unit>
        <trans-unit id="913eec14ed443e489cdc77c2f2c24950a32724fd" translate="yes" xml:space="preserve">
          <source>The MATLAB &lt;code&gt;rem&lt;/code&gt; function and or the C &lt;code&gt;%&lt;/code&gt; operator which is the complement to &lt;code&gt;int(x1 / x2)&lt;/code&gt;.</source>
          <target state="translated">MATLAB &lt;code&gt;rem&lt;/code&gt; 函数和/或C &lt;code&gt;%&lt;/code&gt; 运算符，它是 &lt;code&gt;int(x1 / x2)&lt;/code&gt; 的补充。</target>
        </trans-unit>
        <trans-unit id="accc4f84d711af6e82c6efbbd034211d91d17fc7" translate="yes" xml:space="preserve">
          <source>The MaskedArray class</source>
          <target state="translated">MaskedArray类</target>
        </trans-unit>
        <trans-unit id="5110aa799914ad12dc0bd211beae0c5585bdbc96" translate="yes" xml:space="preserve">
          <source>The Matrix class</source>
          <target state="translated">矩阵类</target>
        </trans-unit>
        <trans-unit id="aae8587a9f8f2d6d760d4e3f9211a40fc1df3fef" translate="yes" xml:space="preserve">
          <source>The N-dimensional array (&lt;code&gt;ndarray&lt;/code&gt;)</source>
          <target state="translated">N维数组（ &lt;code&gt;ndarray&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ebbab7ca4ee7572bcfa080543866bf18ac7ca419" translate="yes" xml:space="preserve">
          <source>The N-dimensional array (ndarray)</source>
          <target state="translated">N维数组(ndarray)</target>
        </trans-unit>
        <trans-unit id="9062ffe94800b2d5eac1ade12a3d3195e3fb90d9" translate="yes" xml:space="preserve">
          <source>The NPV of the input cash flow series &lt;code&gt;values&lt;/code&gt; at the discount &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">输入现金流系列的NPV &lt;code&gt;values&lt;/code&gt; 的折现&lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06341e3da348b45983c3d2e0a0cf15e91944f0fa" translate="yes" xml:space="preserve">
          <source>The NumPy 1.6 release includes a more primitive datetime data type than 1.7. This section documents many of the changes that have taken place.</source>
          <target state="translated">NumPy 1.6版本包含了比1.7更原始的数据时间类型。本节记录了许多已经发生的变化。</target>
        </trans-unit>
        <trans-unit id="22808a8257a77bd3771514110cd88913c8cbfe31" translate="yes" xml:space="preserve">
          <source>The NumPy linear algebra functions rely on BLAS and LAPACK to provide efficient low level implementations of standard linear algebra algorithms. Those libraries may be provided by NumPy itself using C versions of a subset of their reference implementations but, when possible, highly optimized libraries that take advantage of specialized processor functionality are preferred. Examples of such libraries are &lt;a href=&quot;https://www.openblas.net/&quot;&gt;OpenBLAS&lt;/a&gt;, MKL (TM), and ATLAS. Because those libraries are multithreaded and processor dependent, environmental variables and external packages such as &lt;a href=&quot;https://github.com/joblib/threadpoolctl&quot;&gt;threadpoolctl&lt;/a&gt; may be needed to control the number of threads or specify the processor architecture.</source>
          <target state="translated">NumPy线性代数函数依靠BLAS和LAPACK提供标准线性代数算法的有效低层实现。这些库可以由NumPy本身使用其参考实现的子集的C版本提供，但在可能的情况下，最好使用充分利用专用处理器功能的高度优化的库。此类库的示例是&lt;a href=&quot;https://www.openblas.net/&quot;&gt;OpenBLAS&lt;/a&gt;，MKL（TM）和ATLAS。由于这些库是多线程的，并且取决于处理器，因此可能需要环境变量和外部程序包（例如&lt;a href=&quot;https://github.com/joblib/threadpoolctl&quot;&gt;threadpoolctl）&lt;/a&gt;来控制线程数或指定处理器体系结构。</target>
        </trans-unit>
        <trans-unit id="5abe575872513074969d9820a4d531c3d12a22f7" translate="yes" xml:space="preserve">
          <source>The Pareto distribution must be greater than zero, and is unbounded above. It is also known as the &amp;ldquo;80-20 rule&amp;rdquo;. In this distribution, 80 percent of the weights are in the lowest 20 percent of the range, while the other 20 percent fill the remaining 80 percent of the range.</source>
          <target state="translated">帕累托分布必须大于零，并且在上方无界。它也被称为&amp;ldquo; 80-20规则&amp;rdquo;。在此分布中，80％的权重在范围的最低20％中，而其他20％占其余的80％。</target>
        </trans-unit>
        <trans-unit id="ed5b998678bc3c838f5d54a5f0beb5816b99470d" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#r8689274e67cd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">以意大利经济学家维尔弗雷多&amp;middot;帕累托（Vilfredo Pareto）的名字命名的帕累托分布是一种幂律概率分布，可用于许多现实世界中的问题。在经济学领域之外，通常将其称为Bradford分布。帕累托（Pareto）建立了分布来描述经济中财富的分布。还发现它可用于保险，网页访问统计，油田规模以及许多其他问题，包括Sourceforge &lt;a href=&quot;#r8689274e67cd-1&quot; id=&quot;id1&quot;&gt;[1]中&lt;/a&gt;项目的下载频率。它是所谓的&amp;ldquo;胖尾&amp;rdquo;分布之一。</target>
        </trans-unit>
        <trans-unit id="2867a07ee69e6406fe64c658305fdda7fb7b8075" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#rc338d9f74bfc-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">以意大利经济学家维尔弗雷多&amp;middot;帕累托（Vilfredo Pareto）的名字命名的帕累托分布是一种幂律概率分布，可用于许多现实世界中的问题。在经济学领域之外，通常将其称为Bradford分布。帕累托（Pareto）建立了分布来描述经济中财富的分布。还发现它可用于保险，网页访问统计，油田规模以及许多其他问题，包括Sourceforge &lt;a href=&quot;#rc338d9f74bfc-1&quot; id=&quot;id1&quot;&gt;[1]中&lt;/a&gt;项目的下载频率。它是所谓的&amp;ldquo;胖尾&amp;rdquo;分布之一。</target>
        </trans-unit>
        <trans-unit id="8aa87161535a17c7b4517b9679a26277a14402b5" translate="yes" xml:space="preserve">
          <source>The Poisson distribution</source>
          <target state="translated">泊松分布</target>
        </trans-unit>
        <trans-unit id="0ebdde94b2528198e1aa6a1394f362ff4a94706c" translate="yes" xml:space="preserve">
          <source>The Poisson distribution is the limit of the binomial distribution for large N.</source>
          <target state="translated">泊松分布是大N时二项分布的极限。</target>
        </trans-unit>
        <trans-unit id="9280ad29766a65718d4060a0ccabd4c148a5c905" translate="yes" xml:space="preserve">
          <source>The Polynomial class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Polynomial类提供标准的Python数值方法'+'，'-'，'*'，'//'，'％'，'divmod'，'**'和'（）'以及属性和 &lt;code&gt;ABCPolyBase&lt;/code&gt; 文档中列出的方法。</target>
        </trans-unit>
        <trans-unit id="827ba55564ba45b324c36aacf3e17c27674e9dcd" translate="yes" xml:space="preserve">
          <source>The PyArrayInterface structure had no descr member at the end (and therefore no flag ARR_HAS_DESCR)</source>
          <target state="translated">PyArrayInterface结构的最后没有descr成员(因此没有标志ARR_HAS_DESCR)</target>
        </trans-unit>
        <trans-unit id="41d158f9c0cb59631db3742cfa40b5047248d25c" translate="yes" xml:space="preserve">
          <source>The PyArrayInterface structure is defined in &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; as:</source>
          <target state="translated">PyArrayInterface结构在 &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; 中定义为：</target>
        </trans-unit>
        <trans-unit id="5f9e4e5af356a67d9cce5fec6bebfc002a3fe5b0" translate="yes" xml:space="preserve">
          <source>The Python exposure supplies two iteration interfaces, one which follows the Python iterator protocol, and another which mirrors the C-style do-while pattern. The native Python approach is better in most cases, but if you need the coordinates or index of an iterator, use the C-style pattern.</source>
          <target state="translated">Python暴露提供了两个迭代接口,一个是遵循Python迭代器协议,另一个是镜像C风格的do-while模式。在大多数情况下,原生的Python方法更好,但如果你需要迭代器的坐标或索引,请使用C风格模式。</target>
        </trans-unit>
        <trans-unit id="52c071d4e6dd56561ca8fc870ab3c5e829454e91" translate="yes" xml:space="preserve">
          <source>The Python function &lt;code&gt;max()&lt;/code&gt; will find the maximum over a one-dimensional array, but it will do so using a slower sequence interface. The reduce method of the maximum ufunc is much faster. Also, the &lt;code&gt;max()&lt;/code&gt; method will not give answers you might expect for arrays with greater than one dimension. The reduce method of minimum also allows you to compute a total minimum over an array.</source>
          <target state="translated">Python函数 &lt;code&gt;max()&lt;/code&gt; 将在一维数组中找到最大值，但是它将使用较慢的序列接口来找到最大值。最大ufunc的reduce方法要快得多。另外， &lt;code&gt;max()&lt;/code&gt; 方法不会提供您对大于一维的数组可能期望的答案。最小值的reduce方法还允许您计算数组的总最小值。</target>
        </trans-unit>
        <trans-unit id="faf8bfa039d6b92e8c05db35a7f948162088fe3f" translate="yes" xml:space="preserve">
          <source>The Python interactive interpreter unfortunately prints out the values of expressions inside the while loop during each iteration of the loop. We have modified the output in the examples using this looping construct in order to be more readable.</source>
          <target state="translated">遗憾的是,Python交互式解释器在每次循环迭代的过程中,都会打印出while循环里面的表达式的值。我们使用这种循环结构修改了示例中的输出,以便使其更易读。</target>
        </trans-unit>
        <trans-unit id="4b9b366242a59401489f5a3a46b627dbab76f505" translate="yes" xml:space="preserve">
          <source>The Python interface that we want is:</source>
          <target state="translated">我们想要的Python接口是。</target>
        </trans-unit>
        <trans-unit id="a4e789fdc99a292c8a541209ecbc17b1d6c5f8c7" translate="yes" xml:space="preserve">
          <source>The Python iterator protocol doesn&amp;rsquo;t have a natural way to query these additional values from the iterator, so we introduce an alternate syntax for iterating with an &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;. This syntax explicitly works with the iterator object itself, so its properties are readily accessible during iteration. With this looping construct, the current value is accessible by indexing into the iterator, and the index being tracked is the property &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;multi_index&lt;/code&gt; depending on what was requested.</source>
          <target state="translated">Python迭代器协议没有从迭代器中查询这些&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;的自然方法，因此我们引入了另一种语法，用于使用nditer进行迭代。该语法显式地与迭代器对象本身一起使用，因此在迭代过程中可以轻松访问其属性。使用这种循环结构，可以通过索引到迭代器中来访问当前值，并且所跟踪的索引是属性 &lt;code&gt;index&lt;/code&gt; 或 &lt;code&gt;multi_index&lt;/code&gt; ,具体取决于所请求的内容。</target>
        </trans-unit>
        <trans-unit id="6867d7144d35416337495ca1b602061770d80f10" translate="yes" xml:space="preserve">
          <source>The Python list representation of the masked array.</source>
          <target state="translated">掩码数组的Python列表表示。</target>
        </trans-unit>
        <trans-unit id="10730a9ceb03252e7c33bf729de07821aa7c70e5" translate="yes" xml:space="preserve">
          <source>The Python object this chunk of memory comes from. Needed so that memory can be accounted for properly.</source>
          <target state="translated">这块内存来自的 Python 对象。需要,这样才能正确计算内存。</target>
        </trans-unit>
        <trans-unit id="8a0585dac865895f74c0e37d281119c6e2073a73" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator with a number of methods that are similar to the ones available in &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Python stdlib模块&amp;ldquo;随机&amp;rdquo;还包含Mersenne Twister伪随机数生成器，该生成器具有许多与&lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; 中&lt;/a&gt;可用的方法相似的方法。除了具有NumPy感知能力外，&lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;还具有以下优点：它提供了更多的概率分布供您选择。</target>
        </trans-unit>
        <trans-unit id="e2bba830daa553cb7faa782d38dcb55b1552bd1f" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator.</source>
          <target state="translated">Python stdlib模块&amp;ldquo;随机&amp;rdquo;还包含Mersenne Twister伪随机数生成器。</target>
        </trans-unit>
        <trans-unit id="d16bb9351563ad26c9ac5328e3a25381d78f799b" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; contains pseudo-random number generator with a number of methods that are similar to the ones available in &lt;code&gt;Generator&lt;/code&gt;. It uses Mersenne Twister, and this bit generator can be accessed using &lt;code&gt;MT19937&lt;/code&gt;. &lt;code&gt;Generator&lt;/code&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Python stdlib模块&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt;包含伪随机数生成器，其中的许多方法类似于 &lt;code&gt;Generator&lt;/code&gt; 中可用的方法。它使用Mersenne Twister，并且可以使用 &lt;code&gt;MT19937&lt;/code&gt; 访问此位生成器。 &lt;code&gt;Generator&lt;/code&gt; 除了具有NumPy感知能力外，还具有提供大量概率分布可供选择的优势。</target>
        </trans-unit>
        <trans-unit id="bbfe8c34ab4f057b17acc33f18a11bfdb2e17b46" translate="yes" xml:space="preserve">
          <source>The Python type of the ndarray is &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. In C, every ndarray is a pointer to a &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure. The ob_type member of this structure contains a pointer to the &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; typeobject.</source>
          <target state="translated">ndarray的Python类型是&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;。在C语言中，每个ndarray都是指向&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;结构的指针。此结构的ob_type成员包含一个指向&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; 类型&lt;/a&gt;对象的指针。</target>
        </trans-unit>
        <trans-unit id="92e614f1f8b5e40429cf0717c65db8d5a132db4d" translate="yes" xml:space="preserve">
          <source>The Rayleigh distribution would arise, for example, if the East and North components of the wind velocity had identical zero-mean Gaussian distributions. Then the wind speed would have a Rayleigh distribution.</source>
          <target state="translated">例如,如果风速的东、北两部分具有相同的零均值高斯分布,就会出现雷利分布。那么风速就会有雷利分布。</target>
        </trans-unit>
        <trans-unit id="0175f443d47358199cf2723ff7e49526482ab828" translate="yes" xml:space="preserve">
          <source>The Simple Wrapper and Interface Generator (or &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;) is a powerful tool for generating wrapper code for interfacing to a wide variety of scripting languages. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; can parse header files, and using only the code prototypes, create an interface to the target language. But &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; is not omnipotent. For example, it cannot know from the prototype:</source>
          <target state="translated">Simple Wrapper和Interface Generator（或&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;）是一个强大的工具，用于生成用于与各种脚本语言接口的包装器代码。&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;可以解析头文件，并且仅使用代码原型创建目标语言的接口。但是&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;并不是万能的。例如，它不能从原型中知道：</target>
        </trans-unit>
        <trans-unit id="3486112e5f71acaa9b7cc7fff52d1dbfa7f50dd3" translate="yes" xml:space="preserve">
          <source>The Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where the last index is the power of &lt;code&gt;x&lt;/code&gt;. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">范德蒙矩阵。返回矩阵的形状为 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; ，其中最后一个索引是 &lt;code&gt;x&lt;/code&gt; 的幂。dtype将与转换后的 &lt;code&gt;x&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="39a7c567f58b9f21ca516451a55bb90e053dd395" translate="yes" xml:space="preserve">
          <source>The Weibull (or Type III asymptotic extreme value distribution for smallest values, SEV Type III, or Rosin-Rammler distribution) is one of a class of Generalized Extreme Value (GEV) distributions used in modeling extreme value problems. This class includes the Gumbel and Frechet distributions.</source>
          <target state="translated">Weibull(或最小值的III型渐进极值分布,SEV III型,或Rosin-Rammler分布)是一类用于极值问题建模的广义极值(GEV)分布之一。这类分布包括Gumbel分布和Frechet分布。</target>
        </trans-unit>
        <trans-unit id="201b34b560ffa9f638b13b95cb2b860322d162bb" translate="yes" xml:space="preserve">
          <source>The Zipf distribution (also known as the zeta distribution) is a continuous probability distribution that satisfies Zipf&amp;rsquo;s law: the frequency of an item is inversely proportional to its rank in a frequency table.</source>
          <target state="translated">Zipf分布（也称为zeta分布）是满足Zipf定律的连续概率分布：某项的频率与它在频率表中的排名成反比。</target>
        </trans-unit>
        <trans-unit id="cb048510e93bd94f0172757e215cb9cb29cef573" translate="yes" xml:space="preserve">
          <source>The ability to be used as a context manager is new in NumPy v1.11.0.</source>
          <target state="translated">NumPy v1.11.0中新增了作为上下文管理器使用的功能。</target>
        </trans-unit>
        <trans-unit id="10ff963859461b5262a67238fd0cc7b697172b26" translate="yes" xml:space="preserve">
          <source>The above does not hold for in-place operators, for which &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; never returns &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt;. Hence, &lt;code&gt;arr += obj&lt;/code&gt; would always lead to a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. This is because for arrays in-place operations cannot generically be replaced by a simple reverse operation. (For instance, by default, &lt;code&gt;arr += obj&lt;/code&gt; would be translated to &lt;code&gt;arr =
arr + obj&lt;/code&gt;, i.e., &lt;code&gt;arr&lt;/code&gt; would be replaced, contrary to what is expected for in-place array operations.)</source>
          <target state="translated">上面的内容不适用于就地运算符，对于这些运算符，&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;永远不会返回&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt;。因此， &lt;code&gt;arr += obj&lt;/code&gt; 总是会导致&lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;。这是因为对于数组，就地操作通常不能用简单的反向操作代替。（例如，默认情况下， &lt;code&gt;arr += obj&lt;/code&gt; 将被转换为 &lt;code&gt;arr = arr + obj&lt;/code&gt; ，即，将 &lt;code&gt;arr&lt;/code&gt; 替换，这与就地数组操作所期望的相反。）</target>
        </trans-unit>
        <trans-unit id="68e86910bcee8988f5fee730ecb24162fd22e6a7" translate="yes" xml:space="preserve">
          <source>The above equation is not symmetric in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, so that &lt;code&gt;allclose(a, b)&lt;/code&gt; might be different from &lt;code&gt;allclose(b, a)&lt;/code&gt; in some rare cases.</source>
          <target state="translated">上面的方程在 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 中不是对称的，因此 &lt;code&gt;allclose(a, b)&lt;/code&gt; &lt;code&gt;allclose(b, a)&lt;/code&gt; 在某些罕见情况下可能与allclose（b，a）不同。</target>
        </trans-unit>
        <trans-unit id="6185045f653324c861d3553f34d55db24911888b" translate="yes" xml:space="preserve">
          <source>The above is &lt;strong&gt;not&lt;/strong&gt; true for advanced indexing.</source>
          <target state="translated">对于高级索引，以上内容&lt;strong&gt;不&lt;/strong&gt;适用。</target>
        </trans-unit>
        <trans-unit id="21db79b1f2f5936ea0ef3cfbbfc9697c308c56be" translate="yes" xml:space="preserve">
          <source>The above rules may be clearer in the following template source example:</source>
          <target state="translated">在下面的模板源例中,上述规则可能更加清晰。</target>
        </trans-unit>
        <trans-unit id="bbd30ffed27aefb02b7cc5cbecba164ede0884a8" translate="yes" xml:space="preserve">
          <source>The absolute tolerance parameter (see Notes).</source>
          <target state="translated">绝对公差参数(见注释)。</target>
        </trans-unit>
        <trans-unit id="b410151dc56a82d87375b78c87d1aad1438a967a" translate="yes" xml:space="preserve">
          <source>The absolute values of &lt;code&gt;x&lt;/code&gt;, the returned values are always floats. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的绝对值，返回值始终是浮点型的。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="a714cd42c4750db7daf108e375247bf95502ae46" translate="yes" xml:space="preserve">
          <source>The accumulate function is very similar to the reduce function in that the output and the second input both point to the output. The difference is that the second input points to memory one stride behind the current output pointer. Thus, the operation performed is</source>
          <target state="translated">累积函数与reduce函数非常相似,输出和第二个输入都指向输出。不同的是,第二个输入指向的内存比当前输出指针晚一个步长。因此,执行的操作是</target>
        </trans-unit>
        <trans-unit id="09fde86411dc88385ee0c9001b20e47aa778341c" translate="yes" xml:space="preserve">
          <source>The accumulated values. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">累计值。如果提供 &lt;code&gt;out&lt;/code&gt; ，则 &lt;code&gt;r&lt;/code&gt; 是对 &lt;code&gt;out&lt;/code&gt; 的引用。</target>
        </trans-unit>
        <trans-unit id="ea47ba00873e187022bea737541efbc8a18ba099" translate="yes" xml:space="preserve">
          <source>The actual object to check.</source>
          <target state="translated">要检查的实际对象。</target>
        </trans-unit>
        <trans-unit id="2c2156efeae8cdcc13e079cd68ed8ee62442ae55" translate="yes" xml:space="preserve">
          <source>The actual testing takes place with a Python script named:</source>
          <target state="translated">实际测试是通过一个名为Python的脚本进行的。</target>
        </trans-unit>
        <trans-unit id="e611ef52ce3f87e2cae1cb595f38cf187d2711d5" translate="yes" xml:space="preserve">
          <source>The advanced indexes are all next to each other. For example &lt;code&gt;x[..., arr1, arr2, :]&lt;/code&gt; but &lt;em&gt;not&lt;/em&gt;&lt;code&gt;x[arr1, :, 1]&lt;/code&gt; since &lt;code&gt;1&lt;/code&gt; is an advanced index in this regard.</source>
          <target state="translated">高级索引彼此相邻。例如 &lt;code&gt;x[..., arr1, arr2, :]&lt;/code&gt; 但&lt;em&gt;不是&lt;/em&gt; &lt;code&gt;x[arr1, :, 1]&lt;/code&gt; 因为 &lt;code&gt;1&lt;/code&gt; 在这方面是高级索引。</target>
        </trans-unit>
        <trans-unit id="31c1e1991e0db334efbc077fcf4425ba78851bf7" translate="yes" xml:space="preserve">
          <source>The advanced indexes are separated by a slice, &lt;code&gt;Ellipsis&lt;/code&gt; or &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;. For example &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt;.</source>
          <target state="translated">先进的指标是通过切片，分离 &lt;code&gt;Ellipsis&lt;/code&gt; 或&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;。例如 &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e14666a8704d081387416d669f25517240f5f545" translate="yes" xml:space="preserve">
          <source>The aim of this document is to describe how to add new tools to SciPy.</source>
          <target state="translated">本文档的目的是描述如何向SciPy添加新工具。</target>
        </trans-unit>
        <trans-unit id="ddbe83e4c507cabc5c6e4f89a6b5af846c612df5" translate="yes" xml:space="preserve">
          <source>The algorithm is carefully designed to eliminate a number of possible ways to collide. For example, if one only does one level of spawning, it is guaranteed that all states will be unique. But it&amp;rsquo;s easier to estimate the naive upper bound on a napkin and take comfort knowing that the probability is actually lower.</source>
          <target state="translated">该算法经过精心设计，消除了多种可能的碰撞方式。例如，如果仅执行一个级别的生成，则可以保证所有状态都是唯一的。但是，更容易估计餐巾纸上的天真上限，并知道该概率实际上较低，这会让您感到宽慰。</target>
        </trans-unit>
        <trans-unit id="31b40688fb93dbcbc32e9b43e4ccf1abfa448a2d" translate="yes" xml:space="preserve">
          <source>The algorithm relies on computing the eigenvalues of the companion matrix &lt;a href=&quot;#r01a8f58ef25b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">该算法依赖于计算伴随矩阵的特征值&lt;a href=&quot;#r01a8f58ef25b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ddd22305ce6ff69cc69c0e35a34dfdaaddbe6b6d" translate="yes" xml:space="preserve">
          <source>The algorithm works by first finding a &amp;ldquo;running dimension&amp;rdquo;, along which the blocks will be extracted. Given an array of dimensions &lt;code&gt;(d1, d2, ..., dn)&lt;/code&gt;, e.g. if &lt;code&gt;buf_size&lt;/code&gt; is smaller than &lt;code&gt;d1&lt;/code&gt;, the first dimension will be used. If, on the other hand, &lt;code&gt;d1 &amp;lt; buf_size &amp;lt; d1*d2&lt;/code&gt; the second dimension will be used, and so on. Blocks are extracted along this dimension, and when the last block is returned the process continues from the next dimension, until all elements have been read.</source>
          <target state="translated">该算法通过首先找到一个&amp;ldquo;运行维&amp;rdquo;来工作，沿着该维将提取块。给定维度数组 &lt;code&gt;(d1, d2, ..., dn)&lt;/code&gt; ，例如，如果 &lt;code&gt;buf_size&lt;/code&gt; 小于 &lt;code&gt;d1&lt;/code&gt; ，则将使用第一个维度。另一方面，如果 &lt;code&gt;d1 &amp;lt; buf_size &amp;lt; d1*d2&lt;/code&gt; ，则将使用第二维，依此类推。沿该维度提取块，并在返回最后一个块时，过程将从下一个维度继续进行，直到已读取所有元素。</target>
        </trans-unit>
        <trans-unit id="bddd09a9de7b4e7a6ce50c8c2ab936314f5f7ae0" translate="yes" xml:space="preserve">
          <source>The angle of the ray intersecting the unit circle at the given &lt;code&gt;x&lt;/code&gt;-coordinate in radians [0, pi]. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">在给定的 &lt;code&gt;x&lt;/code&gt; 坐标（弧度[0，pi]）下，射线与单位圆相交的角度。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="a13da23a8343744c8c54019aa364c899333968f0" translate="yes" xml:space="preserve">
          <source>The anti-diagonal can be filled by reversing the order of elements using either &lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt;&lt;code&gt;numpy.flipud&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt;&lt;code&gt;numpy.fliplr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt; &lt;code&gt;numpy.flipud&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt; &lt;code&gt;numpy.fliplr&lt;/code&gt; &lt;/a&gt;反转元素的顺序来填充反对角线。</target>
        </trans-unit>
        <trans-unit id="900a13fc7d937db8f345df515885761fbb0acd80" translate="yes" xml:space="preserve">
          <source>The anti-diagonal can be obtained by reversing the order of elements using either &lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt;&lt;code&gt;numpy.flipud&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt;&lt;code&gt;numpy.fliplr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以通过使用&lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt; &lt;code&gt;numpy.flipud&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt; &lt;code&gt;numpy.fliplr&lt;/code&gt; &lt;/a&gt;反转元素的顺序来获得反对角线。</target>
        </trans-unit>
        <trans-unit id="bdd6673496c6fd17d43bfb63694d67b1a23e7074" translate="yes" xml:space="preserve">
          <source>The approximate decimal resolution of this type, i.e., &lt;code&gt;10**-precision&lt;/code&gt;.</source>
          <target state="translated">此类型的近似十进制分辨率，即 &lt;code&gt;10**-precision&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6b2d49779da2fb225e5136c9ad3c68e119d3fee" translate="yes" xml:space="preserve">
          <source>The approximate number of decimal digits to which this kind of float is precise.</source>
          <target state="translated">这类浮点数精确到小数点后的约数。</target>
        </trans-unit>
        <trans-unit id="0fe8c5bbb5b2bd70ddad0ccf0217bddc268f6835" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;ngood&lt;/code&gt; and &lt;code&gt;nbad&lt;/code&gt; each must be less than &lt;code&gt;10**9&lt;/code&gt;. For extremely large arguments, the algorithm that is used to compute the samples &lt;a href=&quot;#r688e4aa3bfc3-4&quot; id=&quot;id1&quot;&gt;[4]&lt;/a&gt; breaks down because of loss of precision in floating point calculations. For such large values, if &lt;code&gt;nsample&lt;/code&gt; is not also large, the distribution can be approximated with the binomial distribution, &lt;code&gt;binomial(n=nsample, p=ngood/(ngood + nbad))&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;ngood&lt;/code&gt; 和 &lt;code&gt;nbad&lt;/code&gt; 都必须小于 &lt;code&gt;10**9&lt;/code&gt; 。对于极大的论点，由于浮点计算的精度损失，用于计算样本&lt;a href=&quot;#r688e4aa3bfc3-4&quot; id=&quot;id1&quot;&gt;[4]&lt;/a&gt;的算法崩溃了。对于这样的大值，如果 &lt;code&gt;nsample&lt;/code&gt; 也不太大，则可以使用二项式分布 &lt;code&gt;binomial(n=nsample, p=ngood/(ngood + nbad))&lt;/code&gt; 近似该分布。</target>
        </trans-unit>
        <trans-unit id="2d355dbffda7b60d25c8fd14c77261de1c537b59" translate="yes" xml:space="preserve">
          <source>The arguments of the &lt;code&gt;configuration&lt;/code&gt; function specify the name of parent SciPy package (&lt;code&gt;parent_package&lt;/code&gt;) and the directory location of the main &lt;code&gt;setup.py&lt;/code&gt; script (&lt;code&gt;top_path&lt;/code&gt;). These arguments, along with the name of the current package, should be passed to the &lt;code&gt;Configuration&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;configuration&lt;/code&gt; 函数的参数指定父SciPy包的名称（ &lt;code&gt;parent_package&lt;/code&gt; ）和主 &lt;code&gt;setup.py&lt;/code&gt; 脚本的目录位置（ &lt;code&gt;top_path&lt;/code&gt; ）。这些参数以及当前包的名称应传递给 &lt;code&gt;Configuration&lt;/code&gt; 构造函数。</target>
        </trans-unit>
        <trans-unit id="9b1212b40ba5f9b8205d7b64e2e9c20d35b415b3" translate="yes" xml:space="preserve">
          <source>The arithmetic mean is the sum of the elements along the axis divided by the number of elements.</source>
          <target state="translated">算术平均值是沿轴线的元素之和除以元素数。</target>
        </trans-unit>
        <trans-unit id="149dc5ada110e245afebc011f82badc7bfaf2c21" translate="yes" xml:space="preserve">
          <source>The arithmetic mean is the sum of the non-NaN elements along the axis divided by the number of non-NaN elements.</source>
          <target state="translated">算术平均数是沿轴线的非纳米元素之和除以非纳米元素的数量。</target>
        </trans-unit>
        <trans-unit id="a686d6fd794f1b48b235aeae1a3e22a10c775aa4" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;v&lt;/code&gt; of eigenvectors may not be of maximum rank, that is, some of the columns may be linearly dependent, although round-off error may obscure that fact. If the eigenvalues are all different, then theoretically the eigenvectors are linearly independent. Likewise, the (complex-valued) matrix of eigenvectors &lt;code&gt;v&lt;/code&gt; is unitary if the matrix &lt;code&gt;a&lt;/code&gt; is normal, i.e., if &lt;code&gt;dot(a, a.H) = dot(a.H, a)&lt;/code&gt;, where &lt;code&gt;a.H&lt;/code&gt; denotes the conjugate transpose of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">特征向量的数组 &lt;code&gt;v&lt;/code&gt; 可能没有最大秩，也就是说，某些列可能是线性相关的，尽管舍入误差可能会掩盖这一事实。如果特征值都不同，则理论上特征向量是线性独立的。同样，特征向量的（复值）矩阵 &lt;code&gt;v&lt;/code&gt; 是酉如果基质 &lt;code&gt;a&lt;/code&gt; 是正常的，即，如果 &lt;code&gt;dot(a, a.H) = dot(a.H, a)&lt;/code&gt; ，其中 &lt;code&gt;a.H&lt;/code&gt; 表示的共轭转置 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="539630988d5b7ef9eff53456e4a77b468fdbbd35" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;x&lt;/code&gt; is prefilled with its filling value.</source>
          <target state="translated">数组 &lt;code&gt;x&lt;/code&gt; 会预先填充其填充值。</target>
        </trans-unit>
        <trans-unit id="048ae46227673b90cff5c0388062d4ed48f2b030" translate="yes" xml:space="preserve">
          <source>The array assembled from the given blocks.</source>
          <target state="translated">由给定的块组合而成的数组。</target>
        </trans-unit>
        <trans-unit id="f6532b7ade94739e158787e37c1d9655afff859b" translate="yes" xml:space="preserve">
          <source>The array can be indexed using Python container-like syntax:</source>
          <target state="translated">数组可以使用类似Python容器的语法进行索引。</target>
        </trans-unit>
        <trans-unit id="a7b308d78b11f2c07c75c1db0756393dc3ae53a1" translate="yes" xml:space="preserve">
          <source>The array data-type or scalar for which the default fill value is returned.</source>
          <target state="translated">返回默认填充值的数组数据类型或标量。</target>
        </trans-unit>
        <trans-unit id="3821c84ea0df179e936beb82ec9c4a845023032b" translate="yes" xml:space="preserve">
          <source>The array element of the current iteration.</source>
          <target state="translated">当前迭代的数组元素。</target>
        </trans-unit>
        <trans-unit id="930ed301b34bfc297be655fe9a537d3e2971d137" translate="yes" xml:space="preserve">
          <source>The array flags cannot be set arbitrarily:</source>
          <target state="translated">阵列标志不能任意设置。</target>
        </trans-unit>
        <trans-unit id="67bdbd5d8bcbe5caab95cc4d4f8dabba43280775" translate="yes" xml:space="preserve">
          <source>The array for which the string representation of the pickle is returned.</source>
          <target state="translated">返回pickle的字符串表示的数组。</target>
        </trans-unit>
        <trans-unit id="2a33c6111cdd8f36d42a5e94437f624d1b58746f" translate="yes" xml:space="preserve">
          <source>The array for which to count non-zeros.</source>
          <target state="translated">要计算非零的数组。</target>
        </trans-unit>
        <trans-unit id="ceccbd318dae2746e4f8b98dac923588a6a52441" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays, will be at least 2-D.</source>
          <target state="translated">将给定的数组堆叠形成的数组,将至少是二维的。</target>
        </trans-unit>
        <trans-unit id="2568bf2e437e715b60f945dc9695881ce8ef667f" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays, will be at least 3-D.</source>
          <target state="translated">将给定的数组堆叠形成的数组,将至少是三维的。</target>
        </trans-unit>
        <trans-unit id="b2c061ec289a87d3c0d4e9e7c64e5126014d42ed" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays.</source>
          <target state="translated">由给定数组堆叠而成的数组。</target>
        </trans-unit>
        <trans-unit id="8e505b1ebbfcf9d9aa6a8f699f88f4ba40304f40" translate="yes" xml:space="preserve">
          <source>The array from which values are copied.</source>
          <target state="translated">复制值的数组。</target>
        </trans-unit>
        <trans-unit id="7c8fb39bbbe950fa5ba32f6dec4764ff1752adf1" translate="yes" xml:space="preserve">
          <source>The array h contains the Householder reflectors that generate q along with r. The tau array contains scaling factors for the reflectors. In the deprecated &amp;lsquo;economic&amp;rsquo; mode only h is returned.</source>
          <target state="translated">数组h包含与q一起生成q的Householder反射器。 tau数组包含反射器的比例因子。在已弃用的&amp;ldquo;经济&amp;rdquo;模式下，仅返回h。</target>
        </trans-unit>
        <trans-unit id="d2932d4203636051c0cde3cab914ac5caf308f90" translate="yes" xml:space="preserve">
          <source>The array interface (sometimes called array protocol) was created in 2005 as a means for array-like Python objects to re-use each other&amp;rsquo;s data buffers intelligently whenever possible. The homogeneous N-dimensional array interface is a default mechanism for objects to share N-dimensional array memory and information. The interface consists of a Python-side and a C-side using two attributes. Objects wishing to be considered an N-dimensional array in application code should support at least one of these attributes. Objects wishing to support an N-dimensional array in application code should look for at least one of these attributes and use the information provided appropriately.</source>
          <target state="translated">数组接口（有时称为数组协议）创建于2005年，目的是使类似数组的Python对象在可能的情况下智能地重用彼此的数据缓冲区。同构N维数组接口是对象共享N维数组内存和信息的默认机制。该接口由使用两个属性的Python端和C端组成。希望在应用程序代码中被视为N维数组的对象应支持这些属性中的至少一个。希望在应用程序代码中支持N维数组的对象应查找这些属性中的至少一个，并使用适当提供的信息。</target>
        </trans-unit>
        <trans-unit id="3b7adbdac3eaf5c6305f1f61b91018f4287bec67" translate="yes" xml:space="preserve">
          <source>The array into which values are copied.</source>
          <target state="translated">复制值的数组。</target>
        </trans-unit>
        <trans-unit id="8a281d694c98742955f6444ee26a08d74603ea7a" translate="yes" xml:space="preserve">
          <source>The array is filled with a fill value before the string conversion.</source>
          <target state="translated">在字符串转换之前,数组中会填充一个填充值。</target>
        </trans-unit>
        <trans-unit id="fba8708c42061e69f757d72f0e5d1d004653f4bc" translate="yes" xml:space="preserve">
          <source>The array is rotated in the plane defined by the axes. Axes must be different.</source>
          <target state="translated">阵列在轴所定义的平面上旋转。轴必须是不同的。</target>
        </trans-unit>
        <trans-unit id="9a1223a8243cbae9aaa7753c7ea500a550cf52c0" translate="yes" xml:space="preserve">
          <source>The array iterator encapsulates many of the key features in ufuncs, allowing user code to support features like output parameters, preservation of memory layouts, and buffering of data with the wrong alignment or type, without requiring difficult coding.</source>
          <target state="translated">数组迭代器封装了ufuncs中的许多关键特性,允许用户代码支持输出参数、保存内存布局、缓冲错误对齐或类型的数据等特性,而不需要困难的编码。</target>
        </trans-unit>
        <trans-unit id="c6e1241b8c7d132ea91621f870c2bd3aaf572b4c" translate="yes" xml:space="preserve">
          <source>The array may be recreated via &lt;code&gt;a = np.array(a.tolist())&lt;/code&gt;, although this may sometimes lose precision.</source>
          <target state="translated">可以通过 &lt;code&gt;a = np.array(a.tolist())&lt;/code&gt; 重新创建数组，尽管有时可能会失去精度。</target>
        </trans-unit>
        <trans-unit id="1eee9d9d69514705c81523ac5b902691363a28a0" translate="yes" xml:space="preserve">
          <source>The array of UTC timestamps to format.</source>
          <target state="translated">要格式化的UTC时间戳数组。</target>
        </trans-unit>
        <trans-unit id="c75d57d539a00e02934380f0ab251d1c277b5e1c" translate="yes" xml:space="preserve">
          <source>The array of dates to process.</source>
          <target state="translated">要处理的日期数组。</target>
        </trans-unit>
        <trans-unit id="cc2f192e213603a4bcf402844b3339c10f79380e" translate="yes" xml:space="preserve">
          <source>The array of numbers for which the absolute values are required. If &lt;code&gt;x&lt;/code&gt; is a scalar, the result &lt;code&gt;y&lt;/code&gt; will also be a scalar.</source>
          <target state="translated">需要绝对值的数字数组。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则结果 &lt;code&gt;y&lt;/code&gt; 也将是标量。</target>
        </trans-unit>
        <trans-unit id="f9c4960d6bbbc8f2591cc039cfe68db4d8e24d90" translate="yes" xml:space="preserve">
          <source>The array of offsets, which is broadcast with &lt;code&gt;dates&lt;/code&gt;.</source>
          <target state="translated">偏移量数组，以 &lt;code&gt;dates&lt;/code&gt; 广播。</target>
        </trans-unit>
        <trans-unit id="2d674fe1383c12f697c52fd3b5198eb57b81bcb7" translate="yes" xml:space="preserve">
          <source>The array of rounded numbers</source>
          <target state="translated">四舍五入的数字阵列</target>
        </trans-unit>
        <trans-unit id="202adb7679573040b63e561db69df0e93b9eb75e" translate="yes" xml:space="preserve">
          <source>The array of the end dates for counting, which are excluded from the count themselves.</source>
          <target state="translated">计数的结束日期数组,该数组不包括计数本身。</target>
        </trans-unit>
        <trans-unit id="f508cbbca81c78d6c3819b4c01ca29622bef56f6" translate="yes" xml:space="preserve">
          <source>The array of the first dates for counting.</source>
          <target state="translated">用于计数的第一个日期的数组。</target>
        </trans-unit>
        <trans-unit id="a4e03a6eeebaef72c6a7e32f280b123bbf142ff2" translate="yes" xml:space="preserve">
          <source>The array or list to be shuffled.</source>
          <target state="translated">要洗牌的数组或列表。</target>
        </trans-unit>
        <trans-unit id="1f6abc9406bedaa275a3843a6290b585462b97a3" translate="yes" xml:space="preserve">
          <source>The array or matrix to be repeated.</source>
          <target state="translated">要重复的数组或矩阵。</target>
        </trans-unit>
        <trans-unit id="53aead7fb32cb3de7311369b48d13d4953d0adc5" translate="yes" xml:space="preserve">
          <source>The array owns the memory it uses or borrows it from another object.</source>
          <target state="translated">数组拥有它所使用的内存,或者从另一个对象那里借来。</target>
        </trans-unit>
        <trans-unit id="8abf01fdd64396d234195c26c60e850e4a12a8d7" translate="yes" xml:space="preserve">
          <source>The array scalar objects have an &lt;code&gt;array priority&lt;/code&gt; of &lt;a href=&quot;c-api.array#c.NPY_SCALAR_PRIORITY&quot;&gt;&lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt;&lt;/a&gt; (-1,000,000.0). They also do not (yet) have a &lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; attribute. Otherwise, they share the same attributes as arrays:</source>
          <target state="translated">数组标量对象的 &lt;code&gt;array priority&lt;/code&gt; 为&lt;a href=&quot;c-api.array#c.NPY_SCALAR_PRIORITY&quot;&gt; &lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt; &lt;/a&gt;（-1,000,000.0）。它们也还没有&lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt;属性。否则，它们与数组共享相同的属性：</target>
        </trans-unit>
        <trans-unit id="8c0162c81e2783b3bcbb0dd799de5c3ba91aba6a" translate="yes" xml:space="preserve">
          <source>The array scalars also offer the same methods and attributes as arrays with the intent that the same code can be used to support arbitrary dimensions (including 0-dimensions). The array scalars are read-only (immutable) with the exception of the void scalar which can also be written to so that structured array field setting works more naturally (a[0][&amp;lsquo;f1&amp;rsquo;] = &lt;code&gt;value&lt;/code&gt; ).</source>
          <target state="translated">数组标量还提供与数组相同的方法和属性，目的是可以使用相同的代码来支持任意维（包括0维）。数组标量是只读的（不可变的），除了void标量也可以写入，使得结构化数组字段设置更自然地工作（a [0] ['f1'] = &lt;code&gt;value&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d0afa5fdfdf427a8322c75c5712091eca91eabac" translate="yes" xml:space="preserve">
          <source>The array scalars offer a hierarchy of Python types that allow a one- to-one correspondence between the data-type stored in an array and the Python-type that is returned when an element is extracted from the array. An exception to this rule was made with object arrays. Object arrays are heterogeneous collections of arbitrary Python objects. When you select an item from an object array, you get back the original Python object (and not an object array scalar which does exist but is rarely used for practical purposes).</source>
          <target state="translated">数组标量提供了一个Python类型的层次结构,它允许存储在数组中的数据类型和从数组中提取元素时返回的Python类型之间有一对一的对应关系。这个规则的例外是对象数组。对象数组是任意 Python 对象的异构集合。当你从一个对象数组中选择一个项目时,你会得到原始的 Python 对象 (而不是对象数组标量,后者确实存在,但很少用于实际目的)。</target>
        </trans-unit>
        <trans-unit id="4e947f26c0ecf6d9ff639e9f27b5b5f852135d7e" translate="yes" xml:space="preserve">
          <source>The array to act on.</source>
          <target state="translated">要执行的数组。</target>
        </trans-unit>
        <trans-unit id="7000ca786d20479930ea43aa17e050c42578abc2" translate="yes" xml:space="preserve">
          <source>The array to be pickled.</source>
          <target state="translated">要腌制的数组。</target>
        </trans-unit>
        <trans-unit id="25694c63a056a35911c5654e87ce1708648d0cd3" translate="yes" xml:space="preserve">
          <source>The array to broadcast.</source>
          <target state="translated">要广播的数组。</target>
        </trans-unit>
        <trans-unit id="61fa35e69f8b8bb03ffef7462ad7cef9c9cdddeb" translate="yes" xml:space="preserve">
          <source>The array to mask. If not a MaskedArray instance (or if no array elements are masked). The result is a MaskedArray with &lt;code&gt;mask&lt;/code&gt; set to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (False). Must be a 2D array.</source>
          <target state="translated">要屏蔽的数组。如果不是MaskedArray实例（或者没有掩码的数组元素）。结果是MaskedArray，其 &lt;code&gt;mask&lt;/code&gt; 设置为&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;（False）。必须是2D数组。</target>
        </trans-unit>
        <trans-unit id="9a0afda668850edc1a593d4069db9a58418e2d74" translate="yes" xml:space="preserve">
          <source>The array to operate on. If not a MaskedArray instance (or if no array elements are masked), &lt;code&gt;x&lt;/code&gt; is interpreted as a MaskedArray with &lt;code&gt;mask&lt;/code&gt; set to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;. Must be a 2D array.</source>
          <target state="translated">要操作的阵列。如果不是一个MaskedArray实例（或如果没有数组元素被掩蔽）， &lt;code&gt;x&lt;/code&gt; 被解释为与MaskedArray &lt;code&gt;mask&lt;/code&gt; 设置为&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;。必须是2D数组。</target>
        </trans-unit>
        <trans-unit id="da7df7a6420823a6b7e45bca218ba68631febc25" translate="yes" xml:space="preserve">
          <source>The array to pad.</source>
          <target state="translated">要垫的数组。</target>
        </trans-unit>
        <trans-unit id="8966af5b1934b124717f0c80ec9988807e784cf9" translate="yes" xml:space="preserve">
          <source>The array to perform in place operation on.</source>
          <target state="translated">要执行就地操作的数组。</target>
        </trans-unit>
        <trans-unit id="1a2586a66b67a305c2797e7e06685302608f4ea4" translate="yes" xml:space="preserve">
          <source>The array whose axes should be reordered.</source>
          <target state="translated">数组的轴应该重新排序。</target>
        </trans-unit>
        <trans-unit id="81f5ca8ebafc1afb8a9d51589c5e138b4b807e19" translate="yes" xml:space="preserve">
          <source>The array(s) to be iterated over. Valid only before the iterator is closed.</source>
          <target state="translated">迭代的数组。仅在迭代器关闭前有效。</target>
        </trans-unit>
        <trans-unit id="8c52ea12181e4277b350926a7c51f79608004cd5" translate="yes" xml:space="preserve">
          <source>The array(s) to iterate over.</source>
          <target state="translated">迭代的数组。</target>
        </trans-unit>
        <trans-unit id="ae34a0f5008cfcf7a204a6ae1b41350a0a8ffea9" translate="yes" xml:space="preserve">
          <source>The array-protocol typestring of this data-type object.</source>
          <target state="translated">该数据类型对象的数组-协议类型字符串。</target>
        </trans-unit>
        <trans-unit id="342be16484b97c95949f88958c455899735a9596" translate="yes" xml:space="preserve">
          <source>The arrays all have exactly the same shape.</source>
          <target state="translated">阵列都有完全相同的形状。</target>
        </trans-unit>
        <trans-unit id="d48d7d91bb3512b8a648b512669295a09d607ddf" translate="yes" xml:space="preserve">
          <source>The arrays all have the same number of dimensions and the length of each dimensions is either a common length or 1.</source>
          <target state="translated">数组的维数都是一样的,而且每个维数的长度都是共同长度或1。</target>
        </trans-unit>
        <trans-unit id="3b32b95e95ce590daa0a88406a7282f0b6f9ae1f" translate="yes" xml:space="preserve">
          <source>The arrays holding the elements to be compared. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">包含要比较的元素的数组。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="b72974524c2659f265dc742386bd383e243bc4a6" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the first axis. 1-D arrays must have the same length.</source>
          <target state="translated">除第一轴外,所有阵列必须具有相同的形状。一维阵列必须具有相同的长度。</target>
        </trans-unit>
        <trans-unit id="9548b85aa3e636c88bbbc65cfcdf4e6b5fff4585" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the second axis, except 1-D arrays which can be any length.</source>
          <target state="translated">除第二轴外,阵列必须沿所有轴线具有相同的形状,但一维阵列可以是任何长度。</target>
        </trans-unit>
        <trans-unit id="34736140b85990281116cda8321b303d602cfb2e" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the third axis. 1-D or 2-D arrays must have the same shape.</source>
          <target state="translated">除第三轴外,所有阵列必须具有相同的形状。一维或二维阵列必须具有相同的形状。</target>
        </trans-unit>
        <trans-unit id="250d7318b7910004f5ade9c6bf7fa2a62b2d0aa6" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape, except in the dimension corresponding to &lt;code&gt;axis&lt;/code&gt; (the first, by default).</source>
          <target state="translated">数组必须具有相同的形状，除了对应于 &lt;code&gt;axis&lt;/code&gt; 的尺寸（默认为第一个）。</target>
        </trans-unit>
        <trans-unit id="3650412314ab8d0d6cc595877979b22653a06cac" translate="yes" xml:space="preserve">
          <source>The arrays that have too few dimensions can have their shapes prepended with a dimension of length 1 to satisfy property 2.</source>
          <target state="translated">维度太少的数组,其形状可以用长度为1的维度前置,以满足属性2。</target>
        </trans-unit>
        <trans-unit id="3c7fb6624c1c578e967064538473cd4324bc56b1" translate="yes" xml:space="preserve">
          <source>The arrays to be added. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">要添加的数组。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="61831d63f8eb03ec54ea81f37b4edf92245e6861" translate="yes" xml:space="preserve">
          <source>The arrays to be subtracted from each other. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">彼此相减的数组。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="b989bf28be4c34813d52a00110756329cfab3199" translate="yes" xml:space="preserve">
          <source>The arrays to broadcast.</source>
          <target state="translated">要广播的数组。</target>
        </trans-unit>
        <trans-unit id="4bc127992ac15b346e5ebc50b22b2084cc253474" translate="yes" xml:space="preserve">
          <source>The available functions are defined in &amp;lt;numpy/npy_math.h&amp;gt; - please refer to this header when in doubt.</source>
          <target state="translated">可用的函数在&amp;lt;numpy / npy_math.h&amp;gt;中定义-如有疑问，请参考此头文件。</target>
        </trans-unit>
        <trans-unit id="4c1200844d5256d1bf5c45cf0a767eb7723d9e5e" translate="yes" xml:space="preserve">
          <source>The average along the specified axis. When returned is &lt;code&gt;True&lt;/code&gt;, return a tuple with the average as the first element and the sum of the weights as the second element. The return type is &lt;code&gt;np.float64&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is of integer type and floats smaller than &lt;code&gt;float64&lt;/code&gt;, or the input data-type, otherwise. If returned, &lt;code&gt;sum_of_weights&lt;/code&gt; is always &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">沿指定轴的平均值。当返回 &lt;code&gt;True&lt;/code&gt; 时，返回一个以平均值为第一个元素，权重之和为第二个元素的元组。如果 &lt;code&gt;a&lt;/code&gt; 为整数类型，并且浮点数小于 &lt;code&gt;float64&lt;/code&gt; 或输入数据类型，则返回类型为 &lt;code&gt;np.float64&lt;/code&gt; 。如果返回， &lt;code&gt;sum_of_weights&lt;/code&gt; 始终为 &lt;code&gt;float64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="542875b084a7c351a7a1f8a6d2d600675ca4d2a7" translate="yes" xml:space="preserve">
          <source>The average squared deviation is normally calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of the infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables. The standard deviation computed in this function is the square root of the estimated variance, so even with &lt;code&gt;ddof=1&lt;/code&gt;, it will not be an unbiased estimate of the standard deviation per se.</source>
          <target state="translated">均方差通常计算为 &lt;code&gt;x.sum() / N&lt;/code&gt; ，其中 &lt;code&gt;N = len(x)&lt;/code&gt; 。然而，如果 &lt;code&gt;ddof&lt;/code&gt; 指定，除数 &lt;code&gt;N - ddof&lt;/code&gt; 代替。在标准的统计实践中， &lt;code&gt;ddof=1&lt;/code&gt; 提供了无穷总体方差的无偏估计量。 &lt;code&gt;ddof=0&lt;/code&gt; 为正态分布变量提供方差的最大似然估计。在此函数中计算的标准偏差是估计方差的平方根，因此即使 &lt;code&gt;ddof=1&lt;/code&gt; ，也不会是标准偏差本身的无偏估计。</target>
        </trans-unit>
        <trans-unit id="21ebdcee890d352b954472165e15ea262b078aa8" translate="yes" xml:space="preserve">
          <source>The axes over which to compute the inverse fft. Default is the last two axes.</source>
          <target state="translated">计算反FFT的轴。默认为最后两个轴。</target>
        </trans-unit>
        <trans-unit id="3f6da36d69c95a72b5592c0677dd407fdc9cfa2c" translate="yes" xml:space="preserve">
          <source>The axis along which &lt;code&gt;v&lt;/code&gt; are appended. If &lt;code&gt;axis&lt;/code&gt; is not given, both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are flattened before use.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 所沿的轴。如果未指定 &lt;code&gt;axis&lt;/code&gt; ，则在使用前将 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 展平。</target>
        </trans-unit>
        <trans-unit id="071585631d8d75cc42162ae0da0a1b91474572d1" translate="yes" xml:space="preserve">
          <source>The axis along which &lt;code&gt;values&lt;/code&gt; are appended. If &lt;code&gt;axis&lt;/code&gt; is not given, both &lt;code&gt;arr&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; are flattened before use.</source>
          <target state="translated">沿其 &lt;code&gt;values&lt;/code&gt; 的轴。如果未指定 &lt;code&gt;axis&lt;/code&gt; ，则在使用前将 &lt;code&gt;arr&lt;/code&gt; 和 &lt;code&gt;values&lt;/code&gt; 都展平。</target>
        </trans-unit>
        <trans-unit id="d25eb0541fd006d52dcbebc548c80309c583cc52" translate="yes" xml:space="preserve">
          <source>The axis along which the arrays will be joined. Default is 0.</source>
          <target state="translated">连接数组的轴线。默认为0。</target>
        </trans-unit>
        <trans-unit id="ab324f8b42b072f0ce80303066858390de817e59" translate="yes" xml:space="preserve">
          <source>The axis along which the arrays will be joined. If axis is None, arrays are flattened before use. Default is 0.</source>
          <target state="translated">连接数组的轴线。如果坐标轴为None,则在使用前对数组进行扁平化处理。默认值为0。</target>
        </trans-unit>
        <trans-unit id="b85856e591095eebb92c2f542dccaa68776b00c8" translate="yes" xml:space="preserve">
          <source>The axis along which the difference is taken, default is the last axis.</source>
          <target state="translated">取差的轴线,默认为最后一个轴线。</target>
        </trans-unit>
        <trans-unit id="848f8430ea7a17384babb0b6d388a2e2e8bda711" translate="yes" xml:space="preserve">
          <source>The axis along which the selection is performed. The default, 0, selects by row.</source>
          <target state="translated">执行选择的轴。默认值0,按行选择。</target>
        </trans-unit>
        <trans-unit id="db9105950615faa8709d8dba888767b4f466811c" translate="yes" xml:space="preserve">
          <source>The axis along which to apply the accumulation; default is zero.</source>
          <target state="translated">应用累积的轴,默认为零。</target>
        </trans-unit>
        <trans-unit id="b45496da67ff059714d0b1ae6911029e831dd2fd" translate="yes" xml:space="preserve">
          <source>The axis along which to apply the reduceat.</source>
          <target state="translated">缩小的轴线。</target>
        </trans-unit>
        <trans-unit id="ef9dbd3a8e7509325fd10ad7183022f46facda83" translate="yes" xml:space="preserve">
          <source>The axis along which to delete the subarray defined by &lt;code&gt;obj&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;obj&lt;/code&gt; is applied to the flattened array.</source>
          <target state="translated">删除 &lt;code&gt;obj&lt;/code&gt; 定义的子数组所沿的轴。如果 &lt;code&gt;axis&lt;/code&gt; 为None，则 &lt;code&gt;obj&lt;/code&gt; 将应用于扁平化数组。</target>
        </trans-unit>
        <trans-unit id="5932d4cf836b6b58485bd9f15e2f20474363c36f" translate="yes" xml:space="preserve">
          <source>The axis along which to integrate.</source>
          <target state="translated">沿着这个轴线进行整合。</target>
        </trans-unit>
        <trans-unit id="0011917dec1b66b996673fed4476058c1c23ee6e" translate="yes" xml:space="preserve">
          <source>The axis along which to repeat values. By default, use the flattened input array, and return a flat output array.</source>
          <target state="translated">重复值的轴。默认情况下,使用扁平化的输入数组,并返回一个扁平的输出数组。</target>
        </trans-unit>
        <trans-unit id="407371d3199afc3105f3e75619a63b4981063028" translate="yes" xml:space="preserve">
          <source>The axis along which to split, default is 0.</source>
          <target state="translated">分割的轴线,默认为0。</target>
        </trans-unit>
        <trans-unit id="40f4cb16df8166b16f689cc3f6a27ceb034ca2a8" translate="yes" xml:space="preserve">
          <source>The axis currently being calculated.</source>
          <target state="translated">当前正在计算的轴。</target>
        </trans-unit>
        <trans-unit id="779396c94c96c008627d39cce908fca96b699246" translate="yes" xml:space="preserve">
          <source>The axis in the result array along which the input arrays are stacked.</source>
          <target state="translated">结果数组中的轴,输入数组沿此轴堆叠。</target>
        </trans-unit>
        <trans-unit id="f53c3f1c70993fc128dae4ee501fb80cbace06f6" translate="yes" xml:space="preserve">
          <source>The axis in the result to store the samples. Relevant only if start or stop are array-like. By default (0), the samples will be along a new axis inserted at the beginning. Use -1 to get an axis at the end.</source>
          <target state="translated">结果中存储样本的轴。只有当start或stop是类似数组的时候才有意义。默认情况下(0),样本将沿着在开始时插入的新轴。使用-1可以在最后得到一个轴。</target>
        </trans-unit>
        <trans-unit id="5d9b30084a3b37c792a839c94c54a5cdb7a8cfce" translate="yes" xml:space="preserve">
          <source>The axis is rolled until it lies before this position. The default, 0, results in a &amp;ldquo;complete&amp;rdquo; roll.</source>
          <target state="translated">轴将滚动直到其位于该位置之前。默认值为0，将导致&amp;ldquo;完成&amp;rdquo;滚动。</target>
        </trans-unit>
        <trans-unit id="bb67daef266f9ea49c20107e1bf4911d74a22608" translate="yes" xml:space="preserve">
          <source>The axis over which to select values. By default, the flattened input array is used.</source>
          <target state="translated">选择值的轴。默认情况下,使用扁平化的输入数组。</target>
        </trans-unit>
        <trans-unit id="d0edfc48d57e03c356c790b28b9213c10fc98a8b" translate="yes" xml:space="preserve">
          <source>The axis to operate on. If None, &lt;code&gt;ar&lt;/code&gt; will be flattened. If an integer, the subarrays indexed by the given axis will be flattened and treated as the elements of a 1-D array with the dimension of the given axis, see the notes for more details. Object arrays or structured arrays that contain objects are not supported if the &lt;code&gt;axis&lt;/code&gt; kwarg is used. The default is None.</source>
          <target state="translated">要运行的轴。如果为None，则 &lt;code&gt;ar&lt;/code&gt; 将被展平。如果为整数，则由给定轴索引的子数组将被展平并视为具有给定轴尺寸的一维数组的元素，有关更多详细信息，请参见注释。如果使用 &lt;code&gt;axis&lt;/code&gt; kwarg，则不支持对象数组或包含对象的结构化数组。默认为无。</target>
        </trans-unit>
        <trans-unit id="b9493a9f29cafe569828c852de6864aa7f5d0ff6" translate="yes" xml:space="preserve">
          <source>The axis to roll backwards. The positions of the other axes do not change relative to one another.</source>
          <target state="translated">向后滚动的轴。其他轴的位置不会相对改变。</target>
        </trans-unit>
        <trans-unit id="340d3fc196833339a77972eea60efcdfd52ba73c" translate="yes" xml:space="preserve">
          <source>The axis to take 1d slices along. If axis is None, the destination array is treated as if a flattened 1d view had been created of it.</source>
          <target state="translated">沿着1d切片的轴。如果轴为None,目标数组将被视为已创建的扁平化1d视图。</target>
        </trans-unit>
        <trans-unit id="a049beb1044c250e5951941014a3acba639cb49d" translate="yes" xml:space="preserve">
          <source>The axis to take 1d slices along. If axis is None, the input array is treated as if it had first been flattened to 1d, for consistency with &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">沿其取一维切片的轴。如果axis为None，则将输入数组视为首先被展平为1d，以与&lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt;保持一致。</target>
        </trans-unit>
        <trans-unit id="98787e1071b5327d0b2e07537c81bb27588db08e" translate="yes" xml:space="preserve">
          <source>The base case for this recursion is a 0D array:</source>
          <target state="translated">这个递归的基本情况是一个0D数组。</target>
        </trans-unit>
        <trans-unit id="88d21dfd4e25736b7184078ba7f33b64bea753e0" translate="yes" xml:space="preserve">
          <source>The base of an array that owns its memory is None:</source>
          <target state="translated">拥有其内存的数组的基数是None。</target>
        </trans-unit>
        <trans-unit id="074b16b582d8ec2099beaee8dcbc987839646a35" translate="yes" xml:space="preserve">
          <source>The base of the log space. The step size between the elements in &lt;code&gt;ln(samples) / ln(base)&lt;/code&gt; (or &lt;code&gt;log_base(samples)&lt;/code&gt;) is uniform. Default is 10.0.</source>
          <target state="translated">日志空间的基础。 &lt;code&gt;ln(samples) / ln(base)&lt;/code&gt; （或 &lt;code&gt;log_base(samples)&lt;/code&gt; ）中元素之间的步长是均匀的。默认值为10.0。</target>
        </trans-unit>
        <trans-unit id="535897fba7f592c8b7dd04c68596d9a31edf2e11" translate="yes" xml:space="preserve">
          <source>The bases in &lt;code&gt;x1&lt;/code&gt; raised to the exponents in &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 中的基数上升到 &lt;code&gt;x2&lt;/code&gt; 中的指数。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="707f28b031c35e2bf30d29bbd42946a1e8c7dc8c" translate="yes" xml:space="preserve">
          <source>The bases.</source>
          <target state="translated">基地。</target>
        </trans-unit>
        <trans-unit id="5bc92f7e413935d311df16000ae397f9e815d85b" translate="yes" xml:space="preserve">
          <source>The basic data element&amp;rsquo;s size in bytes</source>
          <target state="translated">基本数据元素的大小（以字节为单位）</target>
        </trans-unit>
        <trans-unit id="68fe9eda4da762f1f4d04299c59c07412dcd5a69" translate="yes" xml:space="preserve">
          <source>The basic slice syntax is &lt;code&gt;i:j:k&lt;/code&gt; where &lt;em&gt;i&lt;/em&gt; is the starting index, &lt;em&gt;j&lt;/em&gt; is the stopping index, and &lt;em&gt;k&lt;/em&gt; is the step (</source>
          <target state="translated">基本切片语法为 &lt;code&gt;i:j:k&lt;/code&gt; ，其中&lt;em&gt;i&lt;/em&gt;是起始索引，&lt;em&gt;j&lt;/em&gt;是终止索引，&lt;em&gt;k&lt;/em&gt;是步骤（</target>
        </trans-unit>
        <trans-unit id="aeeddb45e8f2002e147b881df220bd44abec802b" translate="yes" xml:space="preserve">
          <source>The basic type character codes are:</source>
          <target state="translated">基本类型字符代码为:</target>
        </trans-unit>
        <trans-unit id="94f38793f86bdba698e5ca03402c847550f50738" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is a Chebyshev basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">缩放基本多项式，以便当 &lt;code&gt;c&lt;/code&gt; 是Chebyshev基本多项式时，伴随矩阵对称。与未缩放的情况相比，这提供了更好的特征值估计，对于基本多项式，如果使用&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;来获得特征值，则可以保证它们是实数。</target>
        </trans-unit>
        <trans-unit id="fd443fcafad8cfc7235ab73b5edb8fa2361feb5f" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an Hermite basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">缩放基础多项式，以便当 &lt;code&gt;c&lt;/code&gt; 是Hermite基础多项式时，伴随矩阵对称。与未缩放的情况相比，这提供了更好的特征值估计，对于基本多项式，如果使用&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;来获得特征值，则可以保证它们是实数。</target>
        </trans-unit>
        <trans-unit id="e1520a86bfcd397936d59363e21a13733e7a71b7" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an HermiteE basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">缩放基本多项式，以便当 &lt;code&gt;c&lt;/code&gt; 是HermiteE基本多项式时，伴随矩阵对称。与未缩放的情况相比，这提供了更好的特征值估计，对于基本多项式，如果使用&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;来获得特征值，则可以保证它们是实数。</target>
        </trans-unit>
        <trans-unit id="31e8496a7482cd5cd28cb680bd285957a80df61e" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an Legendre basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">缩放基本多项式，以便当 &lt;code&gt;c&lt;/code&gt; 是Legendre基本多项式时，伴随矩阵对称。与未缩放的情况相比，这提供了更好的特征值估计，对于基本多项式，如果使用&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;来获得特征值，则可以保证它们是实数。</target>
        </trans-unit>
        <trans-unit id="f437318ff72364f761b90a9b7cf38009e657db81" translate="yes" xml:space="preserve">
          <source>The behavior depends on the arguments in the following way.</source>
          <target state="translated">其行为取决于以下方式的参数。</target>
        </trans-unit>
        <trans-unit id="e2bdcfca6c07efc9e236b5653fc2391d3452350a" translate="yes" xml:space="preserve">
          <source>The best practice is to &lt;strong&gt;not&lt;/strong&gt; reseed a BitGenerator, rather to recreate a new one. This method is here for legacy reasons. This example demonstrates best practice.</source>
          <target state="translated">最佳实践是&lt;strong&gt;不要&lt;/strong&gt;播种BitGenerator，而要重新创建一个新的BitGenerator。由于遗留原因，此处使用此方法。此示例演示了最佳实践。</target>
        </trans-unit>
        <trans-unit id="b917d701e1031f727f4614d1e3412a655c750b99" translate="yes" xml:space="preserve">
          <source>The best way to become familiar with the iterator is to look at its usage within the NumPy codebase itself. For example, here is a slightly tweaked version of the code for &lt;a href=&quot;c-api.array#c.PyArray_CountNonzero&quot;&gt;&lt;code&gt;PyArray_CountNonzero&lt;/code&gt;&lt;/a&gt;, which counts the number of non-zero elements in an array.</source>
          <target state="translated">熟悉迭代器的最佳方法是在NumPy代码库本身中查看其用法。例如，这是&lt;a href=&quot;c-api.array#c.PyArray_CountNonzero&quot;&gt; &lt;code&gt;PyArray_CountNonzero&lt;/code&gt; &lt;/a&gt;的代码的略微调整版本，该版本对数组中非零元素的数量进行计数。</target>
        </trans-unit>
        <trans-unit id="de71d7b03048d0ddf7e9d872a2d91138dd227be5" translate="yes" xml:space="preserve">
          <source>The best way to encode the options required to link against the specified C libraries is to use a &amp;ldquo;libname.ini&amp;rdquo; file, and use &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt; to retrieve the required options (see &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt;&lt;code&gt;add_npy_pkg_config&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="translated">编码链接到指定C库所需的选项的最佳方法是使用&amp;ldquo; libname.ini&amp;rdquo;文件，并使用&lt;a href=&quot;#numpy.distutils.misc_util.Configuration.get_info&quot;&gt; &lt;code&gt;get_info&lt;/code&gt; &lt;/a&gt;检索所需的选项（有关更多信息，请参见&lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt; &lt;code&gt;add_npy_pkg_config&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1969d49698b808b6d276d97e5d8d4c69483e3b58" translate="yes" xml:space="preserve">
          <source>The bi-dimensional histogram of samples &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Values in &lt;code&gt;x&lt;/code&gt; are histogrammed along the first dimension and values in &lt;code&gt;y&lt;/code&gt; are histogrammed along the second dimension.</source>
          <target state="translated">样本 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的二维直方图。 &lt;code&gt;x&lt;/code&gt; 中的值沿第一维直方图， &lt;code&gt;y&lt;/code&gt; 中的值沿第二维直方图。</target>
        </trans-unit>
        <trans-unit id="14050b2975e92118c403ebf94bd3985c0b813e9c" translate="yes" xml:space="preserve">
          <source>The bin edges along the first dimension.</source>
          <target state="translated">仓边沿第一维。</target>
        </trans-unit>
        <trans-unit id="4350d5e237c7d985f1cac8ee28f6158f7c836a6a" translate="yes" xml:space="preserve">
          <source>The bin edges along the second dimension.</source>
          <target state="translated">仓边沿二维。</target>
        </trans-unit>
        <trans-unit id="a2867162a2727e5c2d9c039d549ef3ce42449ec8" translate="yes" xml:space="preserve">
          <source>The bin specification:</source>
          <target state="translated">仓规格。</target>
        </trans-unit>
        <trans-unit id="60d93abeda71712ad2c6a79ef8adc26f40d2aa9b" translate="yes" xml:space="preserve">
          <source>The binwidth is proportional to the interquartile range (IQR) and inversely proportional to cube root of a.size. Can be too conservative for small datasets, but is quite good for large datasets. The IQR is very robust to outliers.</source>
          <target state="translated">二进制宽度与四分位数范围(IQR)成正比,与a.size的立方根成反比。对于小数据集来说可能过于保守,但对于大数据集来说是相当不错的。IQR对离群值的影响非常大。</target>
        </trans-unit>
        <trans-unit id="fcdd8e437719df337fcbc4c74083d021a1773472" translate="yes" xml:space="preserve">
          <source>The binwidth is proportional to the standard deviation of the data and inversely proportional to cube root of &lt;code&gt;x.size&lt;/code&gt;. Can be too conservative for small datasets, but is quite good for large datasets. The standard deviation is not very robust to outliers. Values are very similar to the Freedman-Diaconis estimator in the absence of outliers.</source>
          <target state="translated">binwidth与数据的标准偏差成正比，与 &lt;code&gt;x.size&lt;/code&gt; 的立方根成反比。对于小型数据集可能过于保守，但对于大型数据集则相当不错。标准偏差对异常值不是很稳健。在没有异常值的情况下，值与Freedman-Diaconis估计量非常相似。</target>
        </trans-unit>
        <trans-unit id="4bfe7be4cfb5e7ee31495fab431c2ade90ea37b4" translate="yes" xml:space="preserve">
          <source>The bit generator instance used by the generator</source>
          <target state="translated">生成器使用的位生成器实例</target>
        </trans-unit>
        <trans-unit id="c5d3462c76522066d7ff9beefce9a7effa7d1a7a" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via &lt;a href=&quot;extending#randomgen-cython&quot;&gt;Cython&lt;/a&gt;.</source>
          <target state="translated">可以通过&lt;a href=&quot;extending#randomgen-cython&quot;&gt;Cython&lt;/a&gt;在下游项目中使用位生成器。</target>
        </trans-unit>
        <trans-unit id="bb60b63a1d593f422d320c08f605d5c913dee609" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via Cython.</source>
          <target state="translated">位生成器可以通过Cython在下游项目中使用。</target>
        </trans-unit>
        <trans-unit id="6e4e6fbd0cb3401b8c573dd3679e44e3f4f81dbf" translate="yes" xml:space="preserve">
          <source>The bit-width names can also be used (e.g. &lt;a href=&quot;c-api.dtype#c.NPY_INT32&quot;&gt;&lt;code&gt;NPY_INT32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_COMPLEX128&quot;&gt;&lt;code&gt;NPY_COMPLEX128&lt;/code&gt;&lt;/a&gt; ) if desired.</source>
          <target state="translated">如果需要，也可以使用位宽名称（例如&lt;a href=&quot;c-api.dtype#c.NPY_INT32&quot;&gt; &lt;code&gt;NPY_INT32&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.dtype#c.NPY_COMPLEX128&quot;&gt; &lt;code&gt;NPY_COMPLEX128&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="81d10a070991358c5aabcf2c4a0f8549725777dd" translate="yes" xml:space="preserve">
          <source>The bit-wise operators &amp;amp; and | are the proper way to perform element-by-element array comparisons. Be sure you understand the operator precedence: &lt;code&gt;(a &amp;gt; 2) &amp;amp; (a &amp;lt; 5)&lt;/code&gt; is the proper syntax because &lt;code&gt;a &amp;gt; 2 &amp;amp; a &amp;lt; 5&lt;/code&gt; will result in an error due to the fact that &lt;code&gt;2 &amp;amp; a&lt;/code&gt; is evaluated first.</source>
          <target state="translated">按位运算符＆和| 是执行逐元素数组比较的正确方法。请确保您了解运算符的优先级： &lt;code&gt;(a &amp;gt; 2) &amp;amp; (a &amp;lt; 5)&lt;/code&gt; 是正确的语法，因为 &lt;code&gt;a &amp;gt; 2 &amp;amp; a &amp;lt; 5&lt;/code&gt; 会由于首先计算 &lt;code&gt;2 &amp;amp; a&lt;/code&gt; 而导致错误。</target>
        </trans-unit>
        <trans-unit id="023be86065ffa72daa5873059c9ec3d6c37210a4" translate="yes" xml:space="preserve">
          <source>The bits that are inherited for the parent data-type if these bits are set in any field of the data-type. Currently ( &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt;&lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt;&lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt;&lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt;&lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">如果在数据类型的任何字段中设置了这些位，则为父数据类型继承的位。当前（&lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt; &lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt; &lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt; &lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt; &lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4cdfeeb979f5beeacca8e8ed28ded2c7c6f59236" translate="yes" xml:space="preserve">
          <source>The buffer size. If &lt;code&gt;buf_size&lt;/code&gt; is supplied, the maximum amount of data that will be read into memory is &lt;code&gt;buf_size&lt;/code&gt; elements. Default is None, which will read as many element as possible into memory.</source>
          <target state="translated">缓冲区大小。如果提供 &lt;code&gt;buf_size&lt;/code&gt; ，则将读入内存的最大数据量为 &lt;code&gt;buf_size&lt;/code&gt; 元素。默认值为&amp;ldquo;无&amp;rdquo;，它将把尽可能多的元素读入内存。</target>
        </trans-unit>
        <trans-unit id="2e41256de81634e573afba6a93755e0b3e1dcc73" translate="yes" xml:space="preserve">
          <source>The built-in scalar types are shown below. Along with their (mostly) C-derived names, the integer, float, and complex data-types are also available using a bit-width convention so that an array of the right size can always be ensured (e.g. &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;). Two aliases (&lt;code&gt;intp&lt;/code&gt; and &lt;code&gt;uintp&lt;/code&gt;) pointing to the integer type that is sufficiently large to hold a C pointer are also provided. The C-like names are associated with character codes, which are shown in the table. Use of the character codes, however, is discouraged.</source>
          <target state="translated">内置标量类型如下所示。除了它们（主要是C派生的名称）之外，还可以使用位宽约定来使用整数，浮点数和复杂数据类型，以便始终确保大小正确的数组（例如 &lt;code&gt;int8&lt;/code&gt; ， &lt;code&gt;float64&lt;/code&gt; ， &lt;code&gt;complex128&lt;/code&gt; ） 。还提供了两个别名（ &lt;code&gt;intp&lt;/code&gt; 和 &lt;code&gt;uintp&lt;/code&gt; ），它们分别指向足够容纳C指针的整数类型。类似于C的名称与字符代码相关联，如表所示。但是，不建议使用字符代码。</target>
        </trans-unit>
        <trans-unit id="c0f5f929adb8df8a6adc766b8c78557ffdeb6dfb" translate="yes" xml:space="preserve">
          <source>The byte offset of element &lt;code&gt;(i[0], i[1], ..., i[n])&lt;/code&gt; in an array &lt;code&gt;a&lt;/code&gt; is:</source>
          <target state="translated">数组 &lt;code&gt;a&lt;/code&gt; 中元素 &lt;code&gt;(i[0], i[1], ..., i[n])&lt;/code&gt; 的字节偏移为：</target>
        </trans-unit>
        <trans-unit id="a157c5730d5626d8d468cb6666e1e8a306635908" translate="yes" xml:space="preserve">
          <source>The byte order of the data (which may not be the native byte order)</source>
          <target state="translated">数据的字节顺序(可能不是本地字节顺序)。</target>
        </trans-unit>
        <trans-unit id="54750603ecbabb9e0fbfb396fe440127b1696b3c" translate="yes" xml:space="preserve">
          <source>The byteswapped array. If &lt;code&gt;inplace&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this is a view to self.</source>
          <target state="translated">字节数组。如果 &lt;code&gt;inplace&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则这是对自身的看法。</target>
        </trans-unit>
        <trans-unit id="50ca95011c00b72a055aafd7f7fd748d3ee5666f" translate="yes" xml:space="preserve">
          <source>The calculation based on the Einstein summation convention.</source>
          <target state="translated">基于爱因斯坦求和惯例的计算。</target>
        </trans-unit>
        <trans-unit id="f28022cc3c759ea7fff9649dace591b586e47f2a" translate="yes" xml:space="preserve">
          <source>The call function takes two arguments. The first is a string describing the type of error (such as &amp;ldquo;divide by zero&amp;rdquo;, &amp;ldquo;overflow&amp;rdquo;, &amp;ldquo;underflow&amp;rdquo;, or &amp;ldquo;invalid value&amp;rdquo;), and the second is the status flag. The flag is a byte, whose four least-significant bits indicate the type of error, one of &amp;ldquo;divide&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, &amp;ldquo;invalid&amp;rdquo;:</source>
          <target state="translated">调用函数有两个参数。第一个是描述错误类型的字符串（例如&amp;ldquo;除以零&amp;rdquo;，&amp;ldquo;上溢&amp;rdquo;，&amp;ldquo;下溢&amp;rdquo;或&amp;ldquo;无效值&amp;rdquo;），第二个是状态标志。该标志是一个字节，其四个最低有效位指示错误的类型，即&amp;ldquo;除&amp;rdquo;，&amp;ldquo;上&amp;rdquo;，&amp;ldquo;下&amp;rdquo;，&amp;ldquo;无效&amp;rdquo;之一：</target>
        </trans-unit>
        <trans-unit id="65bfb33c8f536eca2e334a181b45563504281f94" translate="yes" xml:space="preserve">
          <source>The callable to test.</source>
          <target state="translated">要测试的callable。</target>
        </trans-unit>
        <trans-unit id="431e9b7795bdf48241d6bec5990fb4a0130d071a" translate="yes" xml:space="preserve">
          <source>The ceil of the scalar &lt;code&gt;x&lt;/code&gt; is the smallest integer &lt;code&gt;i&lt;/code&gt;, such that &lt;code&gt;i &amp;gt;= x&lt;/code&gt;. It is often denoted as</source>
          <target state="translated">标量 &lt;code&gt;x&lt;/code&gt; 的ceil 是最小的整数 &lt;code&gt;i&lt;/code&gt; ，使得 &lt;code&gt;i &amp;gt;= x&lt;/code&gt; 。它通常表示为</target>
        </trans-unit>
        <trans-unit id="e9d3cf326f9a7a53ec955615e43eb638c61eb8ef" translate="yes" xml:space="preserve">
          <source>The ceiling of each element in &lt;code&gt;x&lt;/code&gt;, with &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; dtype. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 中每个元素的上限，带有&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; dtype。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="39a8dcb488a9fc6fc34cf5a558688abf07d39d3f" translate="yes" xml:space="preserve">
          <source>The character representing the minimum-size type that was found.</source>
          <target state="translated">代表找到的最小尺寸类型的字符。</target>
        </trans-unit>
        <trans-unit id="97cbe8e263bc4b6b77075dcb6bab028e565a01e7" translate="yes" xml:space="preserve">
          <source>The character to use for padding</source>
          <target state="translated">用于填充的字符</target>
        </trans-unit>
        <trans-unit id="6c4bf24ea0f35b24c677f85fded0fd7b09f23149" translate="yes" xml:space="preserve">
          <source>The character used to indicate the start of a comment. All the characters occurring on a line after a comment are discarded</source>
          <target state="translated">用来表示注释的开始的字符。注释之后的行上出现的所有字符都将被丢弃。</target>
        </trans-unit>
        <trans-unit id="d85f382686a835461ae276491d1cc1f7d794fafc" translate="yes" xml:space="preserve">
          <source>The characteristic polynomial,</source>
          <target state="translated">特征多项式。</target>
        </trans-unit>
        <trans-unit id="95fe0ca98cff261937758debf60dec87c78a570a" translate="yes" xml:space="preserve">
          <source>The characters or list of characters used to indicate the start of a comment. None implies no comments. For backwards compatibility, byte strings will be decoded as &amp;lsquo;latin1&amp;rsquo;. The default is &amp;lsquo;#&amp;rsquo;.</source>
          <target state="translated">用于指示注释开始的字符或字符列表。无表示无评论。为了向后兼容，字节字符串将被解码为&amp;ldquo; latin1&amp;rdquo;。默认值为&amp;ldquo;＃&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5b3f50108009441cc91c801c6a0d50e7f118400f" translate="yes" xml:space="preserve">
          <source>The class defining the warning that &lt;code&gt;func&lt;/code&gt; is expected to throw.</source>
          <target state="translated">定义警告预期 &lt;code&gt;func&lt;/code&gt; 引发的类。</target>
        </trans-unit>
        <trans-unit id="3182c5f9b369539a27f1bc7716b92f10416add66" translate="yes" xml:space="preserve">
          <source>The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for these alternatives. For example, any of &amp;lsquo;&amp;gt;&amp;rsquo; or &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;brian&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">对于这些替代方案， &lt;code&gt;new_order&lt;/code&gt; 对new_order的第一个字母进行不区分大小写的检查。例如，&amp;ldquo;&amp;gt;&amp;rdquo;或&amp;ldquo; B&amp;rdquo;或&amp;ldquo; b&amp;rdquo;或&amp;ldquo; brian&amp;rdquo;中的任何一个都可以有效地指定big-endian。</target>
        </trans-unit>
        <trans-unit id="3d7fde77cc6d2864c99d7d852dc9654a8a2c232a" translate="yes" xml:space="preserve">
          <source>The coefficient array representing their sum.</source>
          <target state="translated">代表其总和的系数数组。</target>
        </trans-unit>
        <trans-unit id="8877be945db0e0267ce25ed710aea10434e74470" translate="yes" xml:space="preserve">
          <source>The coefficient matrix of the coefficients &lt;code&gt;p&lt;/code&gt; is a Vandermonde matrix.</source>
          <target state="translated">系数 &lt;code&gt;p&lt;/code&gt; 的系数矩阵是范德蒙德矩阵。</target>
        </trans-unit>
        <trans-unit id="1749ca10e1fd82b0f81734b8e3040c222ba10138" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is 1 for monic polynomials in this form.</source>
          <target state="translated">对于这种形式的一元多项式,最后一项的系数为1。</target>
        </trans-unit>
        <trans-unit id="7f518b8b3d036f3e65aa1004d0ce4c9fe4f469f2" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Chebyshev form.</source>
          <target state="translated">对于切比雪夫形式的一元多项式,最后一项的系数一般不为1。</target>
        </trans-unit>
        <trans-unit id="c6e27aff7bd03298a7abe7cdd24c2851e78ffc19" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Hermite form.</source>
          <target state="translated">对于赫尔米特形式的一元多项式,最后一项的系数一般不为1。</target>
        </trans-unit>
        <trans-unit id="d8180193920e1d179284839e524518471959f55d" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in HermiteE form.</source>
          <target state="translated">对于HermiteE形式的一元多项式,最后一项的系数一般不为1。</target>
        </trans-unit>
        <trans-unit id="870417532aa77b335abb3ff61d44b3280649b54a" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Laguerre form.</source>
          <target state="translated">对于Laguerre形式的一元多项式,最后一项的系数一般不为1。</target>
        </trans-unit>
        <trans-unit id="d2eb9fcb4c7fc816e015e2f1263164865a84ea2c" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Legendre form.</source>
          <target state="translated">对于Legendre形式的一元多项式,最后一项的系数一般不为1。</target>
        </trans-unit>
        <trans-unit id="c0eab4462e93f35863c8383ff656ddde3733b00b" translate="yes" xml:space="preserve">
          <source>The coefficients are determined by multiplying together linear factors of the form &lt;code&gt;(x - r_i)&lt;/code&gt;, i.e.</source>
          <target state="translated">系数是通过将 &lt;code&gt;(x - r_i)&lt;/code&gt; 形式的线性因子相乘来确定的，即</target>
        </trans-unit>
        <trans-unit id="96b42532f49d3b3a4358a0737c1292c860f167f7" translate="yes" xml:space="preserve">
          <source>The column &lt;code&gt;v[:, i]&lt;/code&gt; is the normalized eigenvector corresponding to the eigenvalue &lt;code&gt;w[i]&lt;/code&gt;. Will return a matrix object if &lt;code&gt;a&lt;/code&gt; is a matrix object.</source>
          <target state="translated">列 &lt;code&gt;v[:, i]&lt;/code&gt; 是对应于特征值 &lt;code&gt;w[i]&lt;/code&gt; 的归一化特征向量。如果 &lt;code&gt;a&lt;/code&gt; 是矩阵对象，将返回一个矩阵对象。</target>
        </trans-unit>
        <trans-unit id="05afae6f6316038b8a077ed2d79753233c9700ab" translate="yes" xml:space="preserve">
          <source>The column dimension of the arrays for which the returned arrays will be valid. By default &lt;code&gt;m&lt;/code&gt; is taken equal to &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">返回数组将对其有效的数组的列维。默认情况下， &lt;code&gt;m&lt;/code&gt; 等于 &lt;code&gt;n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="049227627bd4dfed2d2a3d0a02023afddf2ece4d" translate="yes" xml:space="preserve">
          <source>The columns of the output matrix are powers of the input vector. The order of the powers is determined by the &lt;code&gt;increasing&lt;/code&gt; boolean argument. Specifically, when &lt;code&gt;increasing&lt;/code&gt; is False, the &lt;code&gt;i&lt;/code&gt;-th output column is the input vector raised element-wise to the power of &lt;code&gt;N - i - 1&lt;/code&gt;. Such a matrix with a geometric progression in each row is named for Alexandre- Theophile Vandermonde.</source>
          <target state="translated">输出矩阵的列是输入向量的幂。幂的顺序由 &lt;code&gt;increasing&lt;/code&gt; 布尔参数确定。具体来说，当 &lt;code&gt;increasing&lt;/code&gt; 为False时，第 &lt;code&gt;i&lt;/code&gt; 个输出列是逐元素提高到 &lt;code&gt;N - i - 1&lt;/code&gt; 的幂的输入向量。每行中具有几何级数的矩阵以Alexandre-Theophile Vandermonde的名字命名。</target>
        </trans-unit>
        <trans-unit id="fd5ff7ed1e1b0436ec4f4722206a381ca973b853" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;make test&lt;/code&gt; will ensure that all of the test software is built and then run all three test scripts.</source>
          <target state="translated">命令 &lt;code&gt;make test&lt;/code&gt; 将确保已构建所有测试软件，然后运行所有三个测试脚本。</target>
        </trans-unit>
        <trans-unit id="24aa155f0fb452987333532fc0871b6b96e25258" translate="yes" xml:space="preserve">
          <source>The common data type, which is the maximum of &lt;code&gt;array_types&lt;/code&gt; ignoring &lt;code&gt;scalar_types&lt;/code&gt;, unless the maximum of &lt;code&gt;scalar_types&lt;/code&gt; is of a different kind (&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt;&lt;code&gt;dtype.kind&lt;/code&gt;&lt;/a&gt;). If the kind is not understood, then None is returned.</source>
          <target state="translated">所述公共数据类型，这是最大的 &lt;code&gt;array_types&lt;/code&gt; 忽略 &lt;code&gt;scalar_types&lt;/code&gt; ，除非最大的 &lt;code&gt;scalar_types&lt;/code&gt; 是不同种类的（的&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt; &lt;code&gt;dtype.kind&lt;/code&gt; &lt;/a&gt;）。如果不了解种类，则返回None。</target>
        </trans-unit>
        <trans-unit id="6557c9bc2aa7a334ee156279cd2e6ed26882b290" translate="yes" xml:space="preserve">
          <source>The common fill value, or None.</source>
          <target state="translated">常用的填充值,或无。</target>
        </trans-unit>
        <trans-unit id="c7c4929011c41aa057f46d2bc4e51aaccf9a85a1" translate="yes" xml:space="preserve">
          <source>The companion matrix for power series cannot be made symmetric by scaling the basis, so this function differs from those for the orthogonal polynomials.</source>
          <target state="translated">幂级数的伴生矩阵不能通过缩放基数使其对称,所以这个函数与正交多项式的函数不同。</target>
        </trans-unit>
        <trans-unit id="50728cc7411772baf0d23ae9dab7a04fd085919c" translate="yes" xml:space="preserve">
          <source>The comparison of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; uses standard broadcasting, which means that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; need not have the same shape in order for &lt;code&gt;allclose(a, b)&lt;/code&gt; to evaluate to True. The same is true for &lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/a&gt; but not &lt;a href=&quot;numpy.array_equal#numpy.array_equal&quot;&gt;&lt;code&gt;array_equal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的比较使用标准广播，这意味着 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 不必具有相同的形状即可使 &lt;code&gt;allclose(a, b)&lt;/code&gt; 评估为True。对于&lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt; &lt;code&gt;equal&lt;/code&gt; ,&lt;/a&gt;但不是&lt;a href=&quot;numpy.array_equal#numpy.array_equal&quot;&gt; &lt;code&gt;array_equal&lt;/code&gt; ,&lt;/a&gt;这同样适用。</target>
        </trans-unit>
        <trans-unit id="ed9a376f5659e4753c56a46ffbea586e1c5b762b" translate="yes" xml:space="preserve">
          <source>The complex conjugate of &lt;code&gt;x&lt;/code&gt;, with same dtype as &lt;code&gt;y&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的复共轭，与 &lt;code&gt;y&lt;/code&gt; 的 dtype相同。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="d1ca0ff74dd3394813701dd385de23f306fa9c69" translate="yes" xml:space="preserve">
          <source>The complex conjugate of a complex number is obtained by changing the sign of its imaginary part.</source>
          <target state="translated">一个复数的复共轭是通过改变其虚部的符号得到的。</target>
        </trans-unit>
        <trans-unit id="41eb6fa093181f73897902c7f0874292edf29e51" translate="yes" xml:space="preserve">
          <source>The compressed array.</source>
          <target state="translated">压缩阵列。</target>
        </trans-unit>
        <trans-unit id="5eb5823a400c379807aed8ab125dee97f320721d" translate="yes" xml:space="preserve">
          <source>The concatenated array with any masked entries preserved.</source>
          <target state="translated">保留了任何掩码条目的连接数组。</target>
        </trans-unit>
        <trans-unit id="a37868502a5a0d6add95945d1a64803e757adeaa" translate="yes" xml:space="preserve">
          <source>The concatenated array.</source>
          <target state="translated">串联的数组。</target>
        </trans-unit>
        <trans-unit id="3af59c1bb124d9d3dff66fb6d58de527a5027e82" translate="yes" xml:space="preserve">
          <source>The concept of a behaved segment is used in the description of the function pointers. A behaved segment is one that is aligned and in native machine byte-order for the data-type. The &lt;code&gt;nonzero&lt;/code&gt;, &lt;code&gt;copyswap&lt;/code&gt;, &lt;code&gt;copyswapn&lt;/code&gt;, &lt;code&gt;getitem&lt;/code&gt;, and &lt;code&gt;setitem&lt;/code&gt; functions can (and must) deal with mis-behaved arrays. The other functions require behaved memory segments.</source>
          <target state="translated">行为段的概念在函数指针的描述中使用。正常运行的段是对齐的段，并按本机字节顺序排列为数据类型。的 &lt;code&gt;nonzero&lt;/code&gt; ， &lt;code&gt;copyswap&lt;/code&gt; ， &lt;code&gt;copyswapn&lt;/code&gt; ， &lt;code&gt;getitem&lt;/code&gt; 和 &lt;code&gt;setitem&lt;/code&gt; 功能可以（而且必须）处理误表现阵列。其他功能需要正常运行的内存段。</target>
        </trans-unit>
        <trans-unit id="46e686c81ff0f33a7ee42cbdb148b2206e722231" translate="yes" xml:space="preserve">
          <source>The condition number of &lt;code&gt;x&lt;/code&gt; is defined as the norm of &lt;code&gt;x&lt;/code&gt; times the norm of the inverse of &lt;code&gt;x&lt;/code&gt;&lt;a href=&quot;#r611900c44d60-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;; the norm can be the usual L2-norm (root-of-sum-of-squares) or one of a number of other matrix norms.</source>
          <target state="translated">的条件数 &lt;code&gt;x&lt;/code&gt; 被定义为的范数 &lt;code&gt;x&lt;/code&gt; 次的逆的范数 &lt;code&gt;x&lt;/code&gt; &lt;a href=&quot;#r611900c44d60-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; ; 范数可以是通常的L2范数（平方和），也可以是许多其他矩阵范数之一。</target>
        </trans-unit>
        <trans-unit id="7ed508e4defcab357510ceacda28d2924496cd06" translate="yes" xml:space="preserve">
          <source>The condition number of the matrix. May be infinite.</source>
          <target state="translated">矩阵的条件数。可能是无限的。</target>
        </trans-unit>
        <trans-unit id="c901451fe41cf6f1482465c84b6a4c739cbccbff" translate="yes" xml:space="preserve">
          <source>The config file generated from &lt;code&gt;template&lt;/code&gt; is installed in the given install directory, using &lt;code&gt;subst_dict&lt;/code&gt; for variable substitution.</source>
          <target state="translated">从 &lt;code&gt;template&lt;/code&gt; 生成的配置文件安装在给定的安装目录中，使用 &lt;code&gt;subst_dict&lt;/code&gt; 进行变量替换。</target>
        </trans-unit>
        <trans-unit id="2fe0070d6ccb31708b92b4e4ed2caabdfe3d249d" translate="yes" xml:space="preserve">
          <source>The constants &lt;strong&gt;NPY_INTP&lt;/strong&gt; and &lt;strong&gt;NPY_UINTP&lt;/strong&gt; refer to an enumerated integer type that is large enough to hold a pointer on the platform. Index arrays should always be converted to &lt;strong&gt;NPY_INTP&lt;/strong&gt; , because the dimension of the array is of type npy_intp.</source>
          <target state="translated">常量&lt;strong&gt;NPY_INTP&lt;/strong&gt;和&lt;strong&gt;NPY_UINTP&lt;/strong&gt;引用枚举的整数类型，该类型足够大以将指针保持在平台上。索引数组应始终转换为&lt;strong&gt;NPY_INTP&lt;/strong&gt;，因为数组的维类型为npy_intp。</target>
        </trans-unit>
        <trans-unit id="fd8a200b77c06e1513f552e8d61858be6438182d" translate="yes" xml:space="preserve">
          <source>The constructed array.</source>
          <target state="translated">构建的数组。</target>
        </trans-unit>
        <trans-unit id="6f12164e316c899cbeec8a520db14b994fa35a8e" translate="yes" xml:space="preserve">
          <source>The contiguous constraint applies only to the inner loop, successive inner loops may have arbitrary pointer changes.</source>
          <target state="translated">连续约束只适用于内循环,连续的内循环可能有任意的指针变化。</target>
        </trans-unit>
        <trans-unit id="a28f32d0e2528be0855bfa01e7539cc0e939d215" translate="yes" xml:space="preserve">
          <source>The convenience classes provided by the polynomial package are:</source>
          <target state="translated">多项式包提供的方便类有:。</target>
        </trans-unit>
        <trans-unit id="5a4e9570e8f8bcacc96f206106a01eefad39bd6f" translate="yes" xml:space="preserve">
          <source>The convert method can also convert domain and window:</source>
          <target state="translated">转换方法还可以转换域和窗口。</target>
        </trans-unit>
        <trans-unit id="60131768e228b843852dbff6de95273c5e8b7bcb" translate="yes" xml:space="preserve">
          <source>The converted data-type.</source>
          <target state="translated">转换后的数据类型。</target>
        </trans-unit>
        <trans-unit id="1fc6b89fce1f12a34477c12a69d7cd751ad23c91" translate="yes" xml:space="preserve">
          <source>The convolution operator is often seen in signal processing, where it models the effect of a linear time-invariant system on a signal &lt;a href=&quot;#r95849f33d2b1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. In probability theory, the sum of two independent random variables is distributed according to the convolution of their individual distributions.</source>
          <target state="translated">卷积算子在信号处理中经常见到，它在信号上模拟了线性时不变系统的效果&lt;a href=&quot;#r95849f33d2b1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。在概率论中，两个独立随机变量之和是根据它们各自分布的卷积分布的。</target>
        </trans-unit>
        <trans-unit id="1b7a113f553d13745aed52a84f8c20493ad427e3" translate="yes" xml:space="preserve">
          <source>The coordinates member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure maintains the current N-d counter unless the underlying array is C-contiguous in which case the coordinate counting is by-passed. The index member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the current flat index of the iterator. It is updated by the &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">除非基础数组是C连续的，否则&lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;结构的坐标成员将维护当前的Nd计数器，在这种情况下，绕过坐标计数。&lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;的索引成员跟踪迭代器的当前平面索引。它由&lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt;宏更新。</target>
        </trans-unit>
        <trans-unit id="893c6dfe4a5a151e44d6687fac35fbd3b646a45a" translate="yes" xml:space="preserve">
          <source>The core dimensions are removed from all inputs and the remaining dimensions are broadcast together, defining the loop dimensions.</source>
          <target state="translated">核心维度从所有输入中移除,其余维度一起广播,定义循环维度。</target>
        </trans-unit>
        <trans-unit id="72b350bebf37a78a10162e24af07cb3168e9e839" translate="yes" xml:space="preserve">
          <source>The core of the ufunc is the &lt;a href=&quot;#c.PyUFuncObject&quot;&gt;&lt;code&gt;PyUFuncObject&lt;/code&gt;&lt;/a&gt; which contains all the information needed to call the underlying C-code loops that perform the actual work. While it is described here for completeness, it should be considered internal to NumPy and manipulated via &lt;code&gt;PyUFunc_*&lt;/code&gt; functions. The size of this structure is subject to change across versions of NumPy. To ensure compatibility:</source>
          <target state="translated">&lt;a href=&quot;#c.PyUFuncObject&quot;&gt; &lt;code&gt;PyUFuncObject&lt;/code&gt; &lt;/a&gt;的核心是PyUFuncObject，它包含调用执行实际工作的基础C代码循环所需的所有信息。虽然此处出于完整性考虑对其进行了描述，但应将其视为NumPy的内部内容，并通过 &lt;code&gt;PyUFunc_*&lt;/code&gt; 函数进行操作。此结构的大小可能会在NumPy的各个版本中发生变化。为确保兼容性：</target>
        </trans-unit>
        <trans-unit id="76b4be14cc8fe5491309195ba608e3525321fc00" translate="yes" xml:space="preserve">
          <source>The correlation coefficient matrix of the variables.</source>
          <target state="translated">变量的相关系数矩阵。</target>
        </trans-unit>
        <trans-unit id="f4e710373f0588180cd5157b94f36ff64a509ad5" translate="yes" xml:space="preserve">
          <source>The corresponding angle in degrees. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的角度（以度为单位）。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="a2c63fcb50ab2a66bb9a9ad01ce9f4ff69c1d271" translate="yes" xml:space="preserve">
          <source>The corresponding angle in radians. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的角度（以弧度为单位）。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="c2babda63010514076aef395fac45645683b9564" translate="yes" xml:space="preserve">
          <source>The corresponding array scalar type is &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="translated">对应的数组标量类型为 &lt;code&gt;int32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd11fa4205dd5b33a3e2b183413534954599bad7" translate="yes" xml:space="preserve">
          <source>The corresponding cosine values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">对应的余弦值。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="6d98f6605847a59a64fcad02a0b3d4fdfd44ca3d" translate="yes" xml:space="preserve">
          <source>The corresponding degree values; if &lt;code&gt;out&lt;/code&gt; was supplied this is a reference to it. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的度值；如果 &lt;code&gt;out&lt;/code&gt; 供给，这是它的一个引用。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="2584010810109879710934f24451582df80fa088" translate="yes" xml:space="preserve">
          <source>The corresponding hyperbolic sine values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的双曲正弦值。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="2f46b05f80b785698faf42d321e3104fa7625e8a" translate="yes" xml:space="preserve">
          <source>The corresponding hyperbolic tangent values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的双曲正切值。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="d9ca95035c9f509708b9e99487c1ebe9e3ab11bd" translate="yes" xml:space="preserve">
          <source>The corresponding radian values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的弧度值。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="c1e4a7360c69977ad10edc5bee560d5ac06dcf90" translate="yes" xml:space="preserve">
          <source>The corresponding tangent values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的切线值。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="f1763b6e0e62ea8d29f68696fab1bd4ea96474d4" translate="yes" xml:space="preserve">
          <source>The cost for a matrix multiplication can be calculated with the following function:</source>
          <target state="translated">矩阵乘法的成本可以用以下函数计算:</target>
        </trans-unit>
        <trans-unit id="6933bada15117031adec212786a3dbdf77a91aff" translate="yes" xml:space="preserve">
          <source>The costs for the two different parenthesizations are as follows:</source>
          <target state="translated">两种不同括号的费用如下:</target>
        </trans-unit>
        <trans-unit id="71417050531966fa2bba7739241abcc4b67310e0" translate="yes" xml:space="preserve">
          <source>The counterclockwise angle from the positive real axis on the complex plane in the range &lt;code&gt;(-pi, pi]&lt;/code&gt;, with dtype as numpy.float64.</source>
          <target state="translated">与复平面上的正实轴的逆时针角度在 &lt;code&gt;(-pi, pi]&lt;/code&gt; 范围内， dtype为numpy.float64。</target>
        </trans-unit>
        <trans-unit id="703b92f1857fec3346f55e95a27ed079fdf918ac" translate="yes" xml:space="preserve">
          <source>The covariance matrix of the variables.</source>
          <target state="translated">变量的协方差矩阵。</target>
        </trans-unit>
        <trans-unit id="f56bfc3801b5981a49e90ddd94a5011933b03e11" translate="yes" xml:space="preserve">
          <source>The cross product of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in</source>
          <target state="translated">的叉积 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 中</target>
        </trans-unit>
        <trans-unit id="d70737d8a9b599cea578eef90e469f4ec5cade8d" translate="yes" xml:space="preserve">
          <source>The cumulative product for each column (i.e., over the rows) of &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">对于每列（即，在所述行）所述累积产 &lt;code&gt;a&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4974aaba8d216c55c50471b0bc56ddd6323d0ebc" translate="yes" xml:space="preserve">
          <source>The cumulative product for each row (i.e. over the columns) of &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">对于每一行（即在列）累计产品 &lt;code&gt;a&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="50631d91282d5f6763c8dcfd14a90d74339342d9" translate="yes" xml:space="preserve">
          <source>The current (1-d) index into the broadcasted result.</source>
          <target state="translated">当前(1-d)索引进入广播结果。</target>
        </trans-unit>
        <trans-unit id="8c233acaa927b0b3ae6437f9077a3fae3621ed5f" translate="yes" xml:space="preserve">
          <source>The current 1-d index into the array.</source>
          <target state="translated">数组中当前的1-d索引。</target>
        </trans-unit>
        <trans-unit id="cbb3baf8a681bbb5337a5050d23b30de4d838c39" translate="yes" xml:space="preserve">
          <source>The current error handler. If no handler was set through &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">当前的错误处理程序。如果没有通过&lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt;设置处理程序，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcd1e82b97c62204928be3c1426e12c2f8f2093c" translate="yes" xml:space="preserve">
          <source>The current interface remains unchanged, and &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; can still be used to implement (specialized) ufuncs, consisting of scalar elementary functions.</source>
          <target state="translated">当前接口保持不变，并且 &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; 仍可用于实现（特殊的）ufunc，它由标量基本函数组成。</target>
        </trans-unit>
        <trans-unit id="4809e84f7d3a9eb68e3d6e9384c7ac43b19e108c" translate="yes" xml:space="preserve">
          <source>The current version of the ndarray object (check to see if this variable is defined to guarantee the numpy/arrayobject.h header is being used).</source>
          <target state="translated">ndarray对象的当前版本(检查是否定义了这个变量以保证numpy/arrayobject.h头被使用)。</target>
        </trans-unit>
        <trans-unit id="d02692cc2b9183733a0e1ac33e907e722f2cb651" translate="yes" xml:space="preserve">
          <source>The data actually stored in object arrays (&lt;em&gt;i.e.&lt;/em&gt;, arrays having dtype &lt;code&gt;object_&lt;/code&gt;) are references to Python objects, not the objects themselves. Hence, object arrays behave more like usual Python &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt;&lt;code&gt;lists&lt;/code&gt;&lt;/a&gt;, in the sense that their contents need not be of the same Python type.</source>
          <target state="translated">实际上存储在对象数组（&lt;em&gt;即&lt;/em&gt;，具有 &lt;code&gt;object_&lt;/code&gt; 数组）中的数据是对Python对象的引用，而不是对象本身。因此，对象数组的行为更像是普通的Python &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt; &lt;code&gt;lists&lt;/code&gt; &lt;/a&gt;，从某种意义上说，它们的内容不必是相同的Python类型。</target>
        </trans-unit>
        <trans-unit id="2b8f4fa1516918fd8297afcfb360ffa13708823d" translate="yes" xml:space="preserve">
          <source>The data and all elements are aligned appropriately for the hardware.</source>
          <target state="translated">数据和所有的元素都是针对硬件进行适当的排列。</target>
        </trans-unit>
        <trans-unit id="3286aa81b485c3d7add58cb76776a5c44fcb4bf2" translate="yes" xml:space="preserve">
          <source>The data area and all array elements are aligned appropriately.</source>
          <target state="translated">数据区和所有的数组元素都适当地对齐。</target>
        </trans-unit>
        <trans-unit id="c1365a86184a90bddcccd2199d804c180d307014" translate="yes" xml:space="preserve">
          <source>The data area can be written to.</source>
          <target state="translated">可以写入数据区。</target>
        </trans-unit>
        <trans-unit id="539587e7a7889df8e80a73151cc3ac06f87c111c" translate="yes" xml:space="preserve">
          <source>The data area can be written to. Setting this to False locks the data, making it read-only. A view (slice, etc.) inherits WRITEABLE from its base array at creation time, but a view of a writeable array may be subsequently locked while the base array remains writeable. (The opposite is not true, in that a view of a locked array may not be made writeable. However, currently, locking a base object does not lock any views that already reference it, so under that circumstance it is possible to alter the contents of a locked array via a previously created writeable view onto it.) Attempting to change a non-writeable array raises a RuntimeError exception.</source>
          <target state="translated">数据区域可以被写入。将此设置为False会锁定数据,使其成为只读数据。视图(片等)在创建时从它的基数组继承WRITEABLE,但一个可写数组的视图可能随后被锁定,而基数组仍可写。(反之则不然,一个被锁定的数组的视图可能不会被变成可写的)。然而,目前,锁定一个基础对象并不会锁定任何已经引用它的视图,所以在这种情况下,可以通过先前创建的可写视图来改变一个锁定数组的内容。)试图改变一个非可写数组会引发一个RuntimeError异常。</target>
        </trans-unit>
        <trans-unit id="dfe7ced9a654feaf927f01f408558bf43f63134c" translate="yes" xml:space="preserve">
          <source>The data area is in C-style contiguous order (last index varies the fastest).</source>
          <target state="translated">数据区采用C式连续顺序(最后一个索引变化最快)。</target>
        </trans-unit>
        <trans-unit id="28271e4f2d83215b5c3293be14583eebd0638934" translate="yes" xml:space="preserve">
          <source>The data area is in Fortran-style contiguous order (first index varies the fastest).</source>
          <target state="translated">数据区按Fortran式的连续顺序(第一索引变化最快)。</target>
        </trans-unit>
        <trans-unit id="a2e621a0b9254b737a1faf535f1456a6f33c01ae" translate="yes" xml:space="preserve">
          <source>The data area is owned by this array.</source>
          <target state="translated">数据区由这个数组拥有。</target>
        </trans-unit>
        <trans-unit id="ca9e054ad351441ecdb18cea4952500858e11b12" translate="yes" xml:space="preserve">
          <source>The data area represents a (well-behaved) copy whose information should be transferred back to the original when &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">数据区域表示一个（行为良好的）副本，当&lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;时，其信息应传输回原始文件。</target>
        </trans-unit>
        <trans-unit id="15eb3cf2a1c1abdf07a79e9fe9ea7b5a63c62afd" translate="yes" xml:space="preserve">
          <source>The data in the array is returned as a single string. This function is similar to &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt;, the difference being that &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt; also returns information on the kind of array and its data type.</source>
          <target state="translated">数组中的数据作为单个字符串返回。此函数类似于&lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt;，不同之处在于&lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt;还返回有关数组类型及其数据类型的信息。</target>
        </trans-unit>
        <trans-unit id="4cbbe8ca710f692f60ad1bfe0fc2af00b27f6fa9" translate="yes" xml:space="preserve">
          <source>The data in the same field can be heterogeneous, they will be promoted to the highest data type. This method is intended for creating smaller record arrays. If used to create large array without formats defined</source>
          <target state="translated">同一字段中的数据可以是异构的,它们将被提升到最高的数据类型。此方法用于创建较小的记录数组。如果用于创建没有定义格式的大数组</target>
        </trans-unit>
        <trans-unit id="f030fb38724d73d189a884d6cd4eaca4e1c69e90" translate="yes" xml:space="preserve">
          <source>The data is in a single, C-style contiguous segment.</source>
          <target state="translated">数据是在一个单一的C型连续段中。</target>
        </trans-unit>
        <trans-unit id="5f1d8da4b437441472e9916d9ae01c496d02e5d4" translate="yes" xml:space="preserve">
          <source>The data is in a single, Fortran-style contiguous segment.</source>
          <target state="translated">数据是在一个单一的、Fortran式的连续段中。</target>
        </trans-unit>
        <trans-unit id="56a1a480524e7bf67ab594cb10c3c6101b00713c" translate="yes" xml:space="preserve">
          <source>The data of the resulting array will not be byteswapped, but will be interpreted correctly.</source>
          <target state="translated">结果数组的数据不会被字节交换,但会被正确解释。</target>
        </trans-unit>
        <trans-unit id="b88d2dbaff9987ad87362817ef4a120d93a6244e" translate="yes" xml:space="preserve">
          <source>The data to be histogrammed.</source>
          <target state="translated">要进行直方图测量的数据。</target>
        </trans-unit>
        <trans-unit id="5386b778229b14d65914edc6d972b4efb28b5001" translate="yes" xml:space="preserve">
          <source>The data type object associated with the array can be found in the &lt;a href=&quot;generated/numpy.ndarray.dtype#numpy.ndarray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; attribute:</source>
          <target state="translated">与数组关联的数据类型对象可以在&lt;a href=&quot;generated/numpy.ndarray.dtype#numpy.ndarray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;属性中找到：</target>
        </trans-unit>
        <trans-unit id="1c7886ffa6332318e280aa7625497d4df1ee7f24" translate="yes" xml:space="preserve">
          <source>The data type of &lt;code&gt;rep&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rep&lt;/code&gt; 的数据类型。</target>
        </trans-unit>
        <trans-unit id="4b822d3fbc39f811ebad48ba4194f76d214d3123" translate="yes" xml:space="preserve">
          <source>The data type of an operand with this flag should be either &lt;a href=&quot;c-api.dtype#c.NPY_BOOL&quot;&gt;&lt;code&gt;NPY_BOOL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_MASK&quot;&gt;&lt;code&gt;NPY_MASK&lt;/code&gt;&lt;/a&gt;, or a struct dtype whose fields are all valid mask dtypes. In the latter case, it must match up with a struct operand being WRITEMASKED, as it is specifying a mask for each field of that array.</source>
          <target state="translated">具有此标志的操作数的数据类型应为&lt;a href=&quot;c-api.dtype#c.NPY_BOOL&quot;&gt; &lt;code&gt;NPY_BOOL&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.dtype#c.NPY_MASK&quot;&gt; &lt;code&gt;NPY_MASK&lt;/code&gt; &lt;/a&gt;或结构dtype，其字段均为有效的掩码dtype。在后一种情况下，它必须与结构操作数WRITEMASKED相匹配，因为它正在为该数组的每个字段指定一个掩码。</target>
        </trans-unit>
        <trans-unit id="11db59fda83e28216c250b45f855268127882d3e" translate="yes" xml:space="preserve">
          <source>The data type of the array; default: float. For binary input data, the data must be in exactly this format.</source>
          <target state="translated">数组的数据类型,默认:float。对于二进制输入数据,数据必须是这种格式。</target>
        </trans-unit>
        <trans-unit id="6121c8d9cd39c4f61e9ffef0d098e3b7d36639d6" translate="yes" xml:space="preserve">
          <source>The data type of the output of &lt;code&gt;vectorized&lt;/code&gt; is determined by calling the function with the first element of the input. This can be avoided by specifying the &lt;code&gt;otypes&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;vectorized&lt;/code&gt; 输出的数据类型是通过使用输入的第一个元素调用函数来确定的。通过指定 &lt;code&gt;otypes&lt;/code&gt; 参数可以避免这种情况。</target>
        </trans-unit>
        <trans-unit id="bc2814a7f847db35d30b7458174ec64d03a7e7a5" translate="yes" xml:space="preserve">
          <source>The data type of the view. The dtype size of the view can not be larger than that of the array itself.</source>
          <target state="translated">视图的数据类型。视图的dtype大小不能大于数组本身。</target>
        </trans-unit>
        <trans-unit id="99643c3f7e25f9a00992f90ee5d0bdd7cb79f63e" translate="yes" xml:space="preserve">
          <source>The data types of the values provided in &lt;a href=&quot;numpy.nditer.value#numpy.nditer.value&quot;&gt;&lt;code&gt;value&lt;/code&gt;&lt;/a&gt;. This may be different from the operand data types if buffering is enabled. Valid only before the iterator is closed.</source>
          <target state="translated">value中提供的&lt;a href=&quot;numpy.nditer.value#numpy.nditer.value&quot;&gt; &lt;code&gt;value&lt;/code&gt; &lt;/a&gt;的数据类型。如果启用了缓冲，这可能与操作数数据类型不同。仅在关闭迭代器之前有效。</target>
        </trans-unit>
        <trans-unit id="9d016fef105a6db00651ac782a1c7e9c999e6600" translate="yes" xml:space="preserve">
          <source>The data-type is an important abstraction of the ndarray. Operations will look to the data-type to provide the key functionality that is needed to operate on the array. This functionality is provided in the list of function pointers pointed to by the &amp;lsquo;f&amp;rsquo; member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure. In this way, the number of data-types can be extended simply by providing a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure with suitable function pointers in the &amp;lsquo;f&amp;rsquo; member. For built-in types there are some optimizations that by-pass this mechanism, but the point of the data- type abstraction is to allow new data-types to be added.</source>
          <target state="translated">数据类型是ndarray的重要抽象。操作将寻找数据类型，以提供对阵列进行操作所需的关键功能。在&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;结构的'f'成员指向的函数指针列表中提供了此功能。这样，只需在&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;结构中为'f'成员提供适当的函数指针，即可扩展数据类型的数量。对于内置类型，有一些绕过此机制的优化，但是数据类型抽象的要点是允许添加新的数据类型。</target>
        </trans-unit>
        <trans-unit id="b58fbdafeaa8107e58c408c096a3cb8ca5d659d7" translate="yes" xml:space="preserve">
          <source>The data-type of the returned array.</source>
          <target state="translated">返回数组的数据类型。</target>
        </trans-unit>
        <trans-unit id="5c8d679fa5d2836b35d4e189ea3c3c42c4a9bfcc" translate="yes" xml:space="preserve">
          <source>The data-type used to interpret the file contents. Default is &lt;code&gt;uint8&lt;/code&gt;.</source>
          <target state="translated">用于解释文件内容的数据类型。默认值为 &lt;code&gt;uint8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1e17b816f5aa8d3b539033dd4f8579bd040ce7c" translate="yes" xml:space="preserve">
          <source>The data-type used to represent the intermediate results. Defaults to the data-type of the output array if such is provided, or the the data-type of the input array if no output array is provided.</source>
          <target state="translated">用于表示中间结果的数据类型。如果有输出数组,默认为输出数组的数据类型,如果没有输出数组,默认为输入数组的数据类型。</target>
        </trans-unit>
        <trans-unit id="932e882a29033e270334b0a0ca27c7a0b749d38c" translate="yes" xml:space="preserve">
          <source>The data-type-descriptor object of the base-type.</source>
          <target state="translated">基类型的数据类型描述符对象。</target>
        </trans-unit>
        <trans-unit id="d6987a7425e0ff97a8320c32ec6abc8ee62f4f4d" translate="yes" xml:space="preserve">
          <source>The datatype determines which of &amp;lsquo;mergesort&amp;rsquo; or &amp;lsquo;timsort&amp;rsquo; is actually used, even if &amp;lsquo;mergesort&amp;rsquo; is specified. User selection at a finer scale is not currently available.</source>
          <target state="translated">即使指定了&amp;ldquo; mergesort&amp;rdquo;，数据类型也会确定实际使用的是&amp;ldquo; mergesort&amp;rdquo;还是&amp;ldquo; timsort&amp;rdquo;。目前尚无法进行更精细的用户选择。</target>
        </trans-unit>
        <trans-unit id="f8494cadb009486b1d5ee5b6a13352cbf85e331c" translate="yes" xml:space="preserve">
          <source>The datetime API is &lt;em&gt;experimental&lt;/em&gt; in 1.7.0, and may undergo changes in future versions of NumPy.</source>
          <target state="translated">datetime API 在1.7.0中处于&lt;em&gt;试验阶段&lt;/em&gt;，在以后的NumPy版本中可能会发生更改。</target>
        </trans-unit>
        <trans-unit id="5a29e38fde2fbef6d304ea68f9f28e90e826577d" translate="yes" xml:space="preserve">
          <source>The datetime object represents a single moment in time. If two datetimes have different units, they may still be representing the same moment of time, and converting from a bigger unit like months to a smaller unit like days is considered a &amp;lsquo;safe&amp;rsquo; cast because the moment of time is still being represented exactly.</source>
          <target state="translated">datetime对象表示单个时刻。如果两个日期时间具有不同的单位，则它们可能仍代表相同的时间，从较大的单位（如月份）转换为较小的单位（如日期）被认为是&amp;ldquo;安全&amp;rdquo;转换，因为时间段仍可以精确表示。</target>
        </trans-unit>
        <trans-unit id="96194d206533dca35ec887829a70fc8982e7d450" translate="yes" xml:space="preserve">
          <source>The datetime string parser in NumPy 1.6 is very liberal in what it accepts, and silently allows invalid input without raising errors. The parser in NumPy 1.7 is quite strict about only accepting ISO 8601 dates, with a few convenience extensions. 1.6 always creates microsecond (us) units by default, whereas 1.7 detects a unit based on the format of the string. Here is a comparison.:</source>
          <target state="translated">NumPy 1.6中的日期时间字符串解析器在接受的内容上非常自由,它允许无效的输入而不引起错误。NumPy 1.7中的解析器非常严格,只接受ISO 8601日期,并做了一些方便的扩展。1.6总是默认创建微秒(us)单位,而1.7则根据字符串的格式检测单位。下面是一个比较..:</target>
        </trans-unit>
        <trans-unit id="1369383d5a514fcfed8df04d6ed924de54d6f3b1" translate="yes" xml:space="preserve">
          <source>The datetime type works with many common NumPy functions, for example &lt;a href=&quot;generated/numpy.arange#numpy.arange&quot;&gt;&lt;code&gt;arange&lt;/code&gt;&lt;/a&gt; can be used to generate ranges of dates.</source>
          <target state="translated">datetime类型可与许多常见的NumPy函数一起使用，例如&lt;a href=&quot;generated/numpy.arange#numpy.arange&quot;&gt; &lt;code&gt;arange&lt;/code&gt; &lt;/a&gt;可用于生成日期范围。</target>
        </trans-unit>
        <trans-unit id="60d7f83834880a987611358eebe758ac593dc7d2" translate="yes" xml:space="preserve">
          <source>The decomposition is performed using LAPACK routine &lt;code&gt;_gesdd&lt;/code&gt;.</source>
          <target state="translated">使用LAPACK例程 &lt;code&gt;_gesdd&lt;/code&gt; 执行分解。</target>
        </trans-unit>
        <trans-unit id="e1516fc7b62e4a0344208958aa595053689db869" translate="yes" xml:space="preserve">
          <source>The decorated test &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">装饰性测试 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9657b7f30a96eb6a9709525e36cff8e84658cbb" translate="yes" xml:space="preserve">
          <source>The decorator itself is decorated with the &lt;code&gt;nose.tools.make_decorator&lt;/code&gt; function in order to transmit function name, and various other metadata.</source>
          <target state="translated">装饰器本身使用 &lt;code&gt;nose.tools.make_decorator&lt;/code&gt; 函数进行装饰，以传输函数名称以及其他各种元数据。</target>
        </trans-unit>
        <trans-unit id="4a37da8a9aa52a4088272dd54ccf6dae2a209ad8" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;atol&lt;/code&gt; is not appropriate for comparing numbers that are much smaller than one (see Notes).</source>
          <target state="translated">默认的 &lt;code&gt;atol&lt;/code&gt; 不适用于比较比1小得多的数字（请参见注释）。</target>
        </trans-unit>
        <trans-unit id="cb5293865f62263e0a19bbfa34c77f6486814f1d" translate="yes" xml:space="preserve">
          <source>The default __array_priority__ of matrix objects is 10.0, and therefore mixed operations with ndarrays always produce matrices.</source>
          <target state="translated">矩阵对象的默认__array_priority__是10.0,因此与ndarrays的混合操作总是产生矩阵。</target>
        </trans-unit>
        <trans-unit id="cd69cae26ca025156d4d72a557a24e650bb3e040" translate="yes" xml:space="preserve">
          <source>The default character, this is returned if none of the characters in &lt;code&gt;typechars&lt;/code&gt; matches a character in &lt;code&gt;typeset&lt;/code&gt;.</source>
          <target state="translated">默认的字符，如果没有在此字符返回 &lt;code&gt;typechars&lt;/code&gt; 在字符匹配 &lt;code&gt;typeset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9f67bac25f1e9fa1addb151018aeaf9def3b945" translate="yes" xml:space="preserve">
          <source>The default data type in NumPy is &lt;code&gt;float_&lt;/code&gt;.</source>
          <target state="translated">NumPy中的默认数据类型为 &lt;code&gt;float_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cb916c2a199dec22e3c7d35ff5ca943ade2af02" translate="yes" xml:space="preserve">
          <source>The default data type: &lt;code&gt;float_&lt;/code&gt;.</source>
          <target state="translated">默认数据类型： &lt;code&gt;float_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="585140e706eb572d257d276596c7c62733d99ac8" translate="yes" xml:space="preserve">
          <source>The default fill value.</source>
          <target state="translated">默认的填充值。</target>
        </trans-unit>
        <trans-unit id="a6dbb84bde95674721b5026ade7be2a1d41460db" translate="yes" xml:space="preserve">
          <source>The default filling value depends on the datatype of the input array or the type of the input scalar:</source>
          <target state="translated">默认的填充值取决于输入数组的数据类型或输入标量的类型。</target>
        </trans-unit>
        <trans-unit id="d172f7f7da97c607ca46d821dc996e8763c04a60" translate="yes" xml:space="preserve">
          <source>The default for busday functions is that the only valid days are Monday through Friday (the usual business days). The implementation is based on a &amp;ldquo;weekmask&amp;rdquo; containing 7 Boolean flags to indicate valid days; custom weekmasks are possible that specify other sets of valid days.</source>
          <target state="translated">busday功能的默认设置是唯一有效的日期是星期一至星期五（通常的工作日）。该实现基于包含7个布尔值标志的&amp;ldquo;周掩码&amp;rdquo;，以指示有效日期；可以使用自定义周掩码来指定其他有效日期集。</target>
        </trans-unit>
        <trans-unit id="b9e6f3b39a9841c2072fe28c903a4873d59b58cf" translate="yes" xml:space="preserve">
          <source>The default for most operations, raises an exception if an index is out of bounds.</source>
          <target state="translated">大多数操作的默认值,如果索引出界会引发异常。</target>
        </trans-unit>
        <trans-unit id="0b3aadfe669f7dc7282a8bf3bc7021b967d5f363" translate="yes" xml:space="preserve">
          <source>The default is not to change the current behavior.</source>
          <target state="translated">默认情况是不改变当前行为。</target>
        </trans-unit>
        <trans-unit id="13f5430198109332da2b945e817fa963554a0039" translate="yes" xml:space="preserve">
          <source>The default iterator of an ndarray object is the default Python iterator of a sequence type. Thus, when the array object itself is used as an iterator. The default behavior is equivalent to:</source>
          <target state="translated">ndarray对象的默认迭代器是一个序列类型的默认Python迭代器。因此,当数组对象本身被用作迭代器时。默认行为等同于。</target>
        </trans-unit>
        <trans-unit id="d0a1e3c85492f9a28cfa2d6a52018d6303212281" translate="yes" xml:space="preserve">
          <source>The default normalization has the direct transforms unscaled and the inverse transforms are scaled by</source>
          <target state="translated">默认的归一化使直接变换不按比例放大,反变换按以下比例放大</target>
        </trans-unit>
        <trans-unit id="d79f5666dde2a74098ca71f007435f35059e5b3e" translate="yes" xml:space="preserve">
          <source>The default threshold to detect rank deficiency is a test on the magnitude of the singular values of &lt;code&gt;M&lt;/code&gt;. By default, we identify singular values less than &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; as indicating rank deficiency (with the symbols defined above). This is the algorithm MATLAB uses [1]. It also appears in &lt;em&gt;Numerical recipes&lt;/em&gt; in the discussion of SVD solutions for linear least squares [2].</source>
          <target state="translated">检测秩不足的默认阈值是对 &lt;code&gt;M&lt;/code&gt; 的奇异值的大小的测试。默认情况下，我们将小于 &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; 奇异值标识为秩不足（使用上面定义的符号）。这是MATLAB使用的算法[1]。在有关线性最小二乘的SVD解决方案的讨论中，它也出现在&lt;em&gt;数值配方&lt;/em&gt;中[2]。</target>
        </trans-unit>
        <trans-unit id="fabcee56c3086c9123fae22826809a0d986ec9e3" translate="yes" xml:space="preserve">
          <source>The default type to use when no dtype is explicitly specified, for example when calling np.zero(shape). This is equivalent to &lt;a href=&quot;#c.NPY_DOUBLE&quot;&gt;&lt;code&gt;NPY_DOUBLE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当未显式指定dtype时（例如，在调用np.zero（shape）时）使用的默认类型。这等效于&lt;a href=&quot;#c.NPY_DOUBLE&quot;&gt; &lt;code&gt;NPY_DOUBLE&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a62d7fdf404d547735e1b655e9c601557613abc2" translate="yes" xml:space="preserve">
          <source>The default valid days are Monday through Friday (&amp;ldquo;business days&amp;rdquo;). A busdaycalendar object can be specified with any set of weekly valid days, plus an optional &amp;ldquo;holiday&amp;rdquo; dates that always will be invalid.</source>
          <target state="translated">默认的有效日期为星期一至星期五（&amp;ldquo;工作日&amp;rdquo;）。可以使用任何一组每周有效日期以及一个可选的&amp;ldquo;假日&amp;rdquo;日期来指定一个busdaycalendar对象，该日期总是无效的。</target>
        </trans-unit>
        <trans-unit id="203757e2bdf5bbe5e651d506c476783cf6e50edd" translate="yes" xml:space="preserve">
          <source>The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for the alternatives above. For example, any of &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;biggish&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">默认值（'S'）导致交换当前字节顺序。对于上述替代方案，代码对 &lt;code&gt;new_order&lt;/code&gt; 的第一个字母进行不区分大小写的检查。例如，&amp;ldquo; B&amp;rdquo;或&amp;ldquo; b&amp;rdquo;或&amp;ldquo; biggish&amp;rdquo;中的任何一个都可以有效地指定big-endian。</target>
        </trans-unit>
        <trans-unit id="19a5ab6c7c39a905e845eb64d8df075515c15636" translate="yes" xml:space="preserve">
          <source>The defining property of the antiderivative:</source>
          <target state="translated">反衍生物的定义属性。</target>
        </trans-unit>
        <trans-unit id="a1b5640a64fc73d8755c0223b335feaa121479d8" translate="yes" xml:space="preserve">
          <source>The definition of advanced indexing means that &lt;code&gt;x[(1,2,3),]&lt;/code&gt; is fundamentally different than &lt;code&gt;x[(1,2,3)]&lt;/code&gt;. The latter is equivalent to &lt;code&gt;x[1,2,3]&lt;/code&gt; which will trigger basic selection while the former will trigger advanced indexing. Be sure to understand why this occurs.</source>
          <target state="translated">高级索引的定义意味着 &lt;code&gt;x[(1,2,3),]&lt;/code&gt; 与 &lt;code&gt;x[(1,2,3)]&lt;/code&gt; 根本不同。后者等效于 &lt;code&gt;x[1,2,3]&lt;/code&gt; ，它将触发基本选择，而前者将触发高级索引。确保了解为什么会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="61496dee2f3816bd693a7ce0398282c8ea47a960" translate="yes" xml:space="preserve">
          <source>The definition of correlation above is not unique and sometimes correlation may be defined differently. Another common definition is:</source>
          <target state="translated">以上关于相关性的定义并不是唯一的,有时候相关性的定义可能会有所不同。另一种常见的定义是:</target>
        </trans-unit>
        <trans-unit id="e5f33fe407bab51cea8bacccfd88b8a5036810dc" translate="yes" xml:space="preserve">
          <source>The degree of the series.</source>
          <target state="translated">系列的程度。</target>
        </trans-unit>
        <trans-unit id="155faa0de8c44a325761ca30fe7a5e7dbf74e6e4" translate="yes" xml:space="preserve">
          <source>The depends list contains paths to files or directories that the sources of the extension module depend on. If any path in the depends list is newer than the extension module, then the module will be rebuilt.</source>
          <target state="translated">依赖列表中包含了扩展模块的源代码所依赖的文件或目录的路径。如果依赖列表中的任何路径比扩展模块更新,那么该模块将被重建。</target>
        </trans-unit>
        <trans-unit id="63644093036e4f3b360649808afd2f026edeffe7" translate="yes" xml:space="preserve">
          <source>The derivation of the t-distribution was first published in 1908 by William Gosset while working for the Guinness Brewery in Dublin. Due to proprietary issues, he had to publish under a pseudonym, and so he used the name Student.</source>
          <target state="translated">1908年,威廉-戈塞特在都柏林的吉尼斯啤酒厂工作时,首次发表了t分布的推导。由于专利问题,他不得不用假名发表,所以他使用了学生这个名字。</target>
        </trans-unit>
        <trans-unit id="7db2e5319fb072c88d575bc92b04bca324abdb47" translate="yes" xml:space="preserve">
          <source>The derivative of the polynomial</source>
          <target state="translated">多项式的导数</target>
        </trans-unit>
        <trans-unit id="e38da7322eec5dfeb19db7a40e7e799054f3e9fa" translate="yes" xml:space="preserve">
          <source>The desc member of the PyCObject returned from __array_struct__ was not specified. Usually, it was the object exposing the array (so that a reference to it could be kept and destroyed when the C-object was destroyed). Now it must be a tuple whose first element is a string with &amp;ldquo;PyArrayInterface Version #&amp;rdquo; and whose second element is the object exposing the array.</source>
          <target state="translated">未指定从__array_struct__返回的PyCObject的desc成员。通常，它是暴露数组的对象（以便在销毁C对象时可以保留和销毁对它的引用）。现在，它必须是一个元组，其第一个元素是带有&amp;ldquo; PyArrayInterface Version＃&amp;rdquo;的字符串，第二个元素是暴露数组的对象。</target>
        </trans-unit>
        <trans-unit id="d7dbcb2541cf001d7b26e25e4170575fd900c8ee" translate="yes" xml:space="preserve">
          <source>The description of the fourth element of the header therefore has become: &amp;ldquo;The next 4 bytes form a little-endian unsigned int: the length of the header data HEADER_LEN.&amp;rdquo;</source>
          <target state="translated">标头的第四个元素的描述因此变为：&amp;ldquo;接下来的4个字节形成一个低位无符号int：标头数据HEADER_LEN的长度。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="f4a52cabb32fca3b74ad0388e9c1cbe1cf8d25b1" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array, e.g., &lt;code&gt;numpy.int8&lt;/code&gt;. Default is &lt;code&gt;numpy.float64&lt;/code&gt;.</source>
          <target state="translated">数组的所需数据类型，例如 &lt;code&gt;numpy.int8&lt;/code&gt; 。默认值为 &lt;code&gt;numpy.float64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7534f7cefc524ae1e988328a3c98ad10f344592" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array. If not given, then the type will be determined as the minimum type required to hold the objects in the sequence. This argument can only be used to &amp;lsquo;upcast&amp;rsquo; the array. For downcasting, use the .astype(t) method.</source>
          <target state="translated">数组所需的数据类型。如果未给出，则将类型确定为在序列中保存对象所需的最小类型。此参数只能用于&amp;ldquo;上载&amp;rdquo;阵列。对于向下转换，请使用.astype（t）方法。</target>
        </trans-unit>
        <trans-unit id="50dd3f94578e7376ef4b1fc5b09b342ebb1fed2e" translate="yes" xml:space="preserve">
          <source>The desired data-type for the matrix, default is float.</source>
          <target state="translated">矩阵的数据类型,默认为float。</target>
        </trans-unit>
        <trans-unit id="07d678da86d17478a0143d6947f08f3fa51a5f65" translate="yes" xml:space="preserve">
          <source>The desired data-type for the matrix, default is np.float64.</source>
          <target state="translated">矩阵的数据类型,默认为np.float64。</target>
        </trans-unit>
        <trans-unit id="d07509f4b4964e751a91c8805000083d2ee4926c" translate="yes" xml:space="preserve">
          <source>The desired data-type. By default, the data-type is determined from &lt;code&gt;formats&lt;/code&gt;, &lt;code&gt;names&lt;/code&gt;, &lt;code&gt;titles&lt;/code&gt;, &lt;code&gt;aligned&lt;/code&gt; and &lt;code&gt;byteorder&lt;/code&gt;.</source>
          <target state="translated">所需的数据类型。默认情况下，数据类型由 &lt;code&gt;formats&lt;/code&gt; ， &lt;code&gt;names&lt;/code&gt; ， &lt;code&gt;titles&lt;/code&gt; ， &lt;code&gt;aligned&lt;/code&gt; 和 &lt;code&gt;byteorder&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c998f357ef80cf65beb1c4220aff1c69081dd53" translate="yes" xml:space="preserve">
          <source>The desired shape of the array. If &lt;code&gt;mode == 'r'&lt;/code&gt; and the number of remaining bytes after &lt;code&gt;offset&lt;/code&gt; is not a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, you must specify &lt;a href=&quot;numpy.memmap.shape#numpy.memmap.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. By default, the returned array will be 1-D with the number of elements determined by file size and data-type.</source>
          <target state="translated">所需的阵列形状。如果 &lt;code&gt;mode == 'r'&lt;/code&gt; 和剩余字节后面的数字 &lt;code&gt;offset&lt;/code&gt; 不是字节大小的倍数&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;，你必须指定&lt;a href=&quot;numpy.memmap.shape#numpy.memmap.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;。默认情况下，返回的数组将为一维，其元素数由文件大小和数据类型确定。</target>
        </trans-unit>
        <trans-unit id="cdd86af715375b55e1d483d875bf1753af5d922f" translate="yes" xml:space="preserve">
          <source>The desired shape of the iterator. This allows &lt;code&gt;allocate&lt;/code&gt; operands with a dimension mapped by op_axes not corresponding to a dimension of a different operand to get a value not equal to 1 for that dimension.</source>
          <target state="translated">所需的迭代器形状。这允许 &lt;code&gt;allocate&lt;/code&gt; 操作数具有与op_axes映射的维度不对应于另一个操作数的维度的操作数，以获取该维度的不等于1的值。</target>
        </trans-unit>
        <trans-unit id="84971317bba10bc74f9aaf650dccf1acca028d13" translate="yes" xml:space="preserve">
          <source>The desired, expected object.</source>
          <target state="translated">所需的、预期的对象。</target>
        </trans-unit>
        <trans-unit id="40c65673e654df212bffc77b7c4cf508b802ea94" translate="yes" xml:space="preserve">
          <source>The determinant is computed via LU factorization using the LAPACK routine &lt;code&gt;z/dgetrf&lt;/code&gt;.</source>
          <target state="translated">行列式使用LAPACK例程 &lt;code&gt;z/dgetrf&lt;/code&gt; 通过LU分解进行计算。</target>
        </trans-unit>
        <trans-unit id="94f9591a378d3f5d467509648f89e89bcee5af83" translate="yes" xml:space="preserve">
          <source>The determinant of a 2-D array &lt;code&gt;[[a, b], [c, d]]&lt;/code&gt; is &lt;code&gt;ad - bc&lt;/code&gt;:</source>
          <target state="translated">二维数组 &lt;code&gt;[[a, b], [c, d]]&lt;/code&gt; 的行列式为 &lt;code&gt;ad - bc&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="67af8ebad34e1dbafff04ba3dd64dccd7934523b" translate="yes" xml:space="preserve">
          <source>The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:</source>
          <target state="translated">二维数组[[a,b],[c,d]]的行列式为ad-bc。</target>
        </trans-unit>
        <trans-unit id="e56bde2e38a2da31d0e2d0f24b802753579a52ca" translate="yes" xml:space="preserve">
          <source>The determinant of a square Vandermonde matrix is the product of the differences between the values of the input vector:</source>
          <target state="translated">方范德蒙德矩阵的行列式是输入向量值之间的差值的乘积。</target>
        </trans-unit>
        <trans-unit id="34c13c034ad3086185d61530fb01b7940b4e4527" translate="yes" xml:space="preserve">
          <source>The dictionary contains three keys:</source>
          <target state="translated">该字典包含三个键。</target>
        </trans-unit>
        <trans-unit id="bd944e951e9799c3343f288ae6c347a06ac11e23" translate="yes" xml:space="preserve">
          <source>The dictionary is indexed by keys that are the names of the fields. Each entry in the dictionary is a tuple fully describing the field:</source>
          <target state="translated">该字典以字段名称的键为索引。字典中的每个条目都是一个元组,全面描述了该字段。</target>
        </trans-unit>
        <trans-unit id="162f606f6e0310c46fbb8198beb3cd00b92c6224" translate="yes" xml:space="preserve">
          <source>The difference of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 之差，按元素进行。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="07942ea7f660d79ad7e6e73de1169306977fb28a" translate="yes" xml:space="preserve">
          <source>The differences between consecutive elements of an array.</source>
          <target state="translated">数组中连续元素之间的差异。</target>
        </trans-unit>
        <trans-unit id="f62761da3d9dc37e999ceb43677343bc26056903" translate="yes" xml:space="preserve">
          <source>The differences. Loosely, this is &lt;code&gt;ary.flat[1:] - ary.flat[:-1]&lt;/code&gt;.</source>
          <target state="translated">差异。 &lt;code&gt;ary.flat[1:] - ary.flat[:-1]&lt;/code&gt; 地，这是ary.flat [1：]-ary.flat [：-1]。</target>
        </trans-unit>
        <trans-unit id="e2f3cc77955898f687e1a89336e253a34038e978" translate="yes" xml:space="preserve">
          <source>The different types of interpolation can be visualized graphically:</source>
          <target state="translated">不同类型的插值可以用图形可视化。</target>
        </trans-unit>
        <trans-unit id="0f5b79f9447070c03232c2c0b7664e2645b9b9cd" translate="yes" xml:space="preserve">
          <source>The dimension over which bit-packing is done. &lt;code&gt;None&lt;/code&gt; implies packing the flattened array.</source>
          <target state="translated">完成位打包的尺寸。 &lt;code&gt;None&lt;/code&gt; 表示打包扁平化数组。</target>
        </trans-unit>
        <trans-unit id="dfa565d5af13bd83cac275f338d5f2b3b4b7544c" translate="yes" xml:space="preserve">
          <source>The dimension over which bit-unpacking is done. &lt;code&gt;None&lt;/code&gt; implies unpacking the flattened array.</source>
          <target state="translated">展开位的尺寸。 &lt;code&gt;None&lt;/code&gt; 表示解压缩展平的数组。</target>
        </trans-unit>
        <trans-unit id="db3013243a57c5e7a96cffb61f2f631ca09ac6ac" translate="yes" xml:space="preserve">
          <source>The dimensionality of each input/output of an elementary function is defined by its core dimensions (zero core dimensions correspond to a scalar input/output). The core dimensions are mapped to the last dimensions of the input/output arrays.</source>
          <target state="translated">一个基本函数的每个输入/输出的维度由它的核心维度定义(核心维度为零对应一个标量输入/输出)。核心维度被映射到输入/输出数组的最后维度。</target>
        </trans-unit>
        <trans-unit id="bbd2ce0767215831bee7913f7b1f8113fac9632a" translate="yes" xml:space="preserve">
          <source>The dimensionality of the output is equal to the greatest of: * the dimensionality of all the inputs * the depth to which the input list is nested</source>
          <target state="translated">输出的维度等于以下两项中的最大一项。*所有输入的维度*输入列表的嵌套深度。</target>
        </trans-unit>
        <trans-unit id="169b189aee12891e66fa6116bc6ee28490426b80" translate="yes" xml:space="preserve">
          <source>The dimensions beyond the core dimensions are called &amp;ldquo;loop&amp;rdquo; dimensions. In the above example, this corresponds to &lt;code&gt;(3, 5)&lt;/code&gt;.</source>
          <target state="translated">超出核心尺寸的尺寸称为&amp;ldquo;环形&amp;rdquo;尺寸。在上面的示例中，这对应于 &lt;code&gt;(3, 5)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f513b3b85fff0b6f84da786029bafd05ba0e618b" translate="yes" xml:space="preserve">
          <source>The dimensions of the iterator.</source>
          <target state="translated">迭代器的尺寸。</target>
        </trans-unit>
        <trans-unit id="5ecf20054a40c0975aa34c7a074c143c2ad5eb76" translate="yes" xml:space="preserve">
          <source>The dimensions of the returned array, must be non-negative. If no argument is given a single Python float is returned.</source>
          <target state="translated">返回数组的维数,必须是非负数。如果没有给出参数,则返回一个Python float。</target>
        </trans-unit>
        <trans-unit id="1962b62fe3553b6c10eaad6d82d38bd0027b1eca" translate="yes" xml:space="preserve">
          <source>The direction where to look for the next representable value of &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">查找 &lt;code&gt;x1&lt;/code&gt; 的下一个可表示值的方向。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="712dcab95da2336dfeef7d45bac02b258dccf977" translate="yes" xml:space="preserve">
          <source>The discount rate.</source>
          <target state="translated">贴现率;</target>
        </trans-unit>
        <trans-unit id="0706686baa5fd5b913d978e6a5e5bd325098b037" translate="yes" xml:space="preserve">
          <source>The discrete convolution operation is defined as</source>
          <target state="translated">离散卷积运算定义为</target>
        </trans-unit>
        <trans-unit id="12a1ae320e29367bfe14ad50414fe949007c38e7" translate="yes" xml:space="preserve">
          <source>The docstring for the function. If &lt;code&gt;None&lt;/code&gt;, the docstring will be the &lt;code&gt;pyfunc.__doc__&lt;/code&gt;.</source>
          <target state="translated">该函数的文档字符串。如果为 &lt;code&gt;None&lt;/code&gt; ，则文档字符串将为 &lt;code&gt;pyfunc.__doc__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72a23a7f9d3c84d9ccb7d9d4e76905cf07195965" translate="yes" xml:space="preserve">
          <source>The docstring is taken from the input function to &lt;a href=&quot;#numpy.vectorize&quot;&gt;&lt;code&gt;vectorize&lt;/code&gt;&lt;/a&gt; unless it is specified:</source>
          <target state="translated">除非已指定，否则从输入函数获取文档字符串以进行&lt;a href=&quot;#numpy.vectorize&quot;&gt; &lt;code&gt;vectorize&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="82bd10e4e262158659ec5e27575297c3e33fb51b" translate="yes" xml:space="preserve">
          <source>The doctests are run as if they are in a fresh Python instance which has executed &lt;code&gt;import numpy as np&lt;/code&gt;. Tests that are part of a SciPy subpackage will have that subpackage already imported. E.g. for a test in &lt;code&gt;scipy/linalg/tests/&lt;/code&gt;, the namespace will be created such that &lt;code&gt;from scipy import linalg&lt;/code&gt; has already executed.</source>
          <target state="translated">像运行doctest一样，就像在新的Python实例中一样，该实例已执行 &lt;code&gt;import numpy as np&lt;/code&gt; 。作为SciPy子程序包一部分的测试将具有已导入的子程序包。例如，对于 &lt;code&gt;scipy/linalg/tests/&lt;/code&gt; 中的测试，将创建名称空间， &lt;code&gt;from scipy import linalg&lt;/code&gt; 已经从scipy导入linalg。</target>
        </trans-unit>
        <trans-unit id="4e34de0083248d68455464ce3b6cb6cff4a615e4" translate="yes" xml:space="preserve">
          <source>The doctests can be run by adding the &lt;code&gt;doctests&lt;/code&gt; argument to the &lt;code&gt;test()&lt;/code&gt; call; for example, to run all tests (including doctests) for numpy.lib:</source>
          <target state="translated">可以通过将 &lt;code&gt;doctests&lt;/code&gt; 参数添加到 &lt;code&gt;test()&lt;/code&gt; 调用来运行doctest。例如，运行numpy.lib的所有测试（包括doctests）：</target>
        </trans-unit>
        <trans-unit id="914dd900bd888e0ac2a856c709956c6c77b685df" translate="yes" xml:space="preserve">
          <source>The doctests can be run by the user/developer by adding the &lt;code&gt;doctests&lt;/code&gt; argument to the &lt;code&gt;test()&lt;/code&gt; call. For example, to run all tests (including doctests) for &lt;code&gt;numpy.lib&lt;/code&gt;:</source>
          <target state="translated">通过将 &lt;code&gt;doctests&lt;/code&gt; 参数添加到 &lt;code&gt;test()&lt;/code&gt; 调用，用户/开发人员可以运行doctest。例如，运行所有测试（包括文档测试）为 &lt;code&gt;numpy.lib&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b01857d163ce7be746891e6a1ddb4df8d280228b" translate="yes" xml:space="preserve">
          <source>The domain of the converted series. If the value is None, the default domain of &lt;code&gt;kind&lt;/code&gt; is used.</source>
          <target state="translated">转换后的系列的域。如果值为&amp;ldquo;无&amp;rdquo;，则使用默认的 &lt;code&gt;kind&lt;/code&gt; 域。</target>
        </trans-unit>
        <trans-unit id="3910d27792e65700eaf0cb459a12293f622c5605" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape (size, alpha.ndim).</source>
          <target state="translated">绘制的样本,形状(大小,alpha.ndim)。</target>
        </trans-unit>
        <trans-unit id="caba47af25cacb65ea654dc8b3910b7df6c6afc4" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape &lt;em&gt;size&lt;/em&gt;, if that was provided. If not, the shape is &lt;code&gt;(N,)&lt;/code&gt;.</source>
          <target state="translated">如果提供的话，抽取的样品的形状为&lt;em&gt;大小&lt;/em&gt;。如果不是，则形状为 &lt;code&gt;(N,)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40b0e929b6fe8b38b46b38ce838182fe7c7332dc" translate="yes" xml:space="preserve">
          <source>The drawn samples.</source>
          <target state="translated">抽到的样品。</target>
        </trans-unit>
        <trans-unit id="aa44e17b8461776ae7df4f43d6abddd8f6a24f76" translate="yes" xml:space="preserve">
          <source>The dtype object, which must be a &lt;code&gt;datetime64&lt;/code&gt; or &lt;code&gt;timedelta64&lt;/code&gt; type.</source>
          <target state="translated">dtype对象，必须是 &lt;code&gt;datetime64&lt;/code&gt; 或 &lt;code&gt;timedelta64&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="8fb6faafe66ffccb238a2fd43e44c5a7f5fbd5ca" translate="yes" xml:space="preserve">
          <source>The dtype of the masked array matches the dtype of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">掩码数组的dtype与 &lt;code&gt;arr&lt;/code&gt; 的dtype相匹配。</target>
        </trans-unit>
        <trans-unit id="a55d71e165e1e48cb124a8472e43c4880e17aca7" translate="yes" xml:space="preserve">
          <source>The dtype to convert</source>
          <target state="translated">要转换的dtype</target>
        </trans-unit>
        <trans-unit id="5ecd0c1cb739e638a2efc7fc65026ccc752fcf9a" translate="yes" xml:space="preserve">
          <source>The dtype to convert.</source>
          <target state="translated">要转换的dtype。</target>
        </trans-unit>
        <trans-unit id="0624587fa2f7d6454c0f9d5829dab19d01e4bd1b" translate="yes" xml:space="preserve">
          <source>The easiest way to understand the situation may be to think in terms of the result shape. There are two parts to the indexing operation, the subspace defined by the basic indexing (excluding integers) and the subspace from the advanced indexing part. Two cases of index combination need to be distinguished:</source>
          <target state="translated">最简单的理解方式可能是从结果形状来考虑。索引操作有两个部分,一个是基本索引定义的子空间(不包括整数),一个是来自高级索引部分的子空间。需要区分索引组合的两种情况。</target>
        </trans-unit>
        <trans-unit id="f92b730683a3cb47168faa379ee22ac3235eed0f" translate="yes" xml:space="preserve">
          <source>The easy way to do conversions between polynomial basis sets is to use the convert method of a class instance.</source>
          <target state="translated">在多项式基集之间进行转换的简单方法是使用类实例的转换方法。</target>
        </trans-unit>
        <trans-unit id="2fc5d8b78173f52a2c49af3f59f052a25e59fb4f" translate="yes" xml:space="preserve">
          <source>The edges to pass into &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt;的边缘</target>
        </trans-unit>
        <trans-unit id="b6f1be0a37063a8a4026cc94c7cf86f62cf5bdd8" translate="yes" xml:space="preserve">
          <source>The effect of broadcasting.</source>
          <target state="translated">广播的效果。</target>
        </trans-unit>
        <trans-unit id="a34abd23a6e4bdf2596a3b4673affad53721777d" translate="yes" xml:space="preserve">
          <source>The eigenvalues are computed using LAPACK routines &lt;code&gt;_syevd&lt;/code&gt;, &lt;code&gt;_heevd&lt;/code&gt;.</source>
          <target state="translated">使用LAPACK例程 &lt;code&gt;_syevd&lt;/code&gt; ， &lt;code&gt;_heevd&lt;/code&gt; 计算特征值。</target>
        </trans-unit>
        <trans-unit id="7701e5ef9799c4995d19bac48ad9fa82db4dc5c5" translate="yes" xml:space="preserve">
          <source>The eigenvalues in ascending order, each repeated according to its multiplicity.</source>
          <target state="translated">按升序排列的特征值,每个特征值按其倍数重复。</target>
        </trans-unit>
        <trans-unit id="af42e28434cbe95fe6890df4d996c2c99e9b2481" translate="yes" xml:space="preserve">
          <source>The eigenvalues of real symmetric or complex Hermitian matrices are always real. &lt;a href=&quot;#rc702e98a756a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; The array &lt;code&gt;v&lt;/code&gt; of (column) eigenvectors is unitary and &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;dot(a, v[:, i]) = w[i] * v[:, i]&lt;/code&gt;.</source>
          <target state="translated">实对称或复Hermitian矩阵的特征值始终为实。&lt;a href=&quot;#rc702e98a756a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;（列）特征向量的数组 &lt;code&gt;v&lt;/code&gt; 是单一的，并且 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;w&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 满足等式 &lt;code&gt;dot(a, v[:, i]) = w[i] * v[:, i]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ff4d23698273b360b1d6366e444e95ea540f28f" translate="yes" xml:space="preserve">
          <source>The eigenvalues, each repeated according to its multiplicity. The eigenvalues are not necessarily ordered. The resulting array will be of complex type, unless the imaginary part is zero in which case it will be cast to a real type. When &lt;code&gt;a&lt;/code&gt; is real the resulting eigenvalues will be real (0 imaginary part) or occur in conjugate pairs</source>
          <target state="translated">特征值，每个特征值根据其多重性重复。特征值不一定是有序的。除非虚部为零，否则所得数组将为复杂类型，在这种情况下，它将被强制转换为实型。当 &lt;code&gt;a&lt;/code&gt; 为实数时，所得特征值将为实数（虚部为0）或出现在共轭对中</target>
        </trans-unit>
        <trans-unit id="9cfc7ae7c9df4df4270a01f781a7985d0061b823" translate="yes" xml:space="preserve">
          <source>The eigenvalues, each repeated according to its multiplicity. They are not necessarily ordered, nor are they necessarily real for real matrices.</source>
          <target state="translated">的特征值,每个特征值按其倍数重复。它们不一定是有序的,也不一定是实数矩阵的实数。</target>
        </trans-unit>
        <trans-unit id="fedbdf07c41c58b01420971d15b808683a8a1612" translate="yes" xml:space="preserve">
          <source>The eigenvalues/eigenvectors are computed using LAPACK routines &lt;code&gt;_syevd&lt;/code&gt;, &lt;code&gt;_heevd&lt;/code&gt;.</source>
          <target state="translated">使用LAPACK例程 &lt;code&gt;_syevd&lt;/code&gt; ， &lt;code&gt;_heevd&lt;/code&gt; 计算特征值/特征向量。</target>
        </trans-unit>
        <trans-unit id="672eac8f0267740479f9ff389b02d40f57b3ff35" translate="yes" xml:space="preserve">
          <source>The element inserted in &lt;code&gt;output&lt;/code&gt; when all conditions evaluate to False.</source>
          <target state="translated">当所有条件评估为False时，元素将插入 &lt;code&gt;output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c154db2e01512028a28319b3317262699278c799" translate="yes" xml:space="preserve">
          <source>The element size of this data-type object.</source>
          <target state="translated">该数据类型对象的元素大小。</target>
        </trans-unit>
        <trans-unit id="100849a009dc981ce005b4c12bbdd30342f43ac6" translate="yes" xml:space="preserve">
          <source>The element-wise remainder of the quotient &lt;code&gt;floor_divide(x1, x2)&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">商 &lt;code&gt;floor_divide(x1, x2)&lt;/code&gt; 的按元素的余数。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="55f57b3f397334c809b04b980612f0a5ab349a62" translate="yes" xml:space="preserve">
          <source>The elements are binary-valued (0 or 1).</source>
          <target state="translated">元素为二进制值(0或1)。</target>
        </trans-unit>
        <trans-unit id="18d658a71c2e23e5ce04fb215c6cdc657f3c41d2" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;a&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;m&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">使用此索引顺序读取 &lt;code&gt;a&lt;/code&gt; 的元素。 &amp;ldquo; C&amp;rdquo;表示以类似C的顺序索引元素，最后一个轴索引更改最快，而返回到第一个轴索引更改最慢。 &amp;ldquo; F&amp;rdquo;表示以类似Fortran的索引顺序索引元素，第一个索引更改最快，最后一个索引更改最慢。请注意，&amp;ldquo; C&amp;rdquo;和&amp;ldquo; F&amp;rdquo;选项不考虑基础数组的内存布局，仅参考轴索引的顺序。如果 &lt;code&gt;m&lt;/code&gt; 在内存中是&lt;em&gt;连续的&lt;/em&gt; Fortran，则&amp;ldquo; A&amp;rdquo;表示以类似于Fortran的索引顺序读取元素，否则为类似于C的顺序。 &amp;ldquo; K&amp;rdquo;表示按顺序在内存中读取元素，但当步幅为负时反转数据除外。默认情况下，使用&amp;ldquo; C&amp;rdquo;索引顺序。</target>
        </trans-unit>
        <trans-unit id="27ccf6e9acce055e532ad81d9bdd8638f9a4a262" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;a&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in row-major, C-style order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in column-major, Fortran-style order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;a&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">使用此索引顺序读取 &lt;code&gt;a&lt;/code&gt; 的元素。&amp;ldquo; C&amp;rdquo;表示以行优先，C样式的顺序索引元素，最后一个轴索引更改最快，回到第一个轴索引更改最慢。&amp;ldquo; F&amp;rdquo;表示以Fortran样式的列主顺序索引元素，第一个索引变化最快，最后一个索引变化最慢。请注意，&amp;ldquo; C&amp;rdquo;和&amp;ldquo; F&amp;rdquo;选项不考虑基础数组的内存布局，仅参考轴索引的顺序。如果 &lt;code&gt;a&lt;/code&gt; 是&lt;em&gt;连续的&lt;/em&gt; Fortran，则&amp;ldquo; A&amp;rdquo;表示以类似于Fortran的索引顺序读取元素&lt;em&gt;&lt;/em&gt;在内存中，否则类似C的顺序。&amp;ldquo; K&amp;rdquo;表示按步在内存中的顺序读取元素，但步幅为负时反转数据除外。默认情况下，使用&amp;ldquo; C&amp;rdquo;索引顺序。</target>
        </trans-unit>
        <trans-unit id="8bfe90d8bb9b3a44603b03bac0e42210874e7808" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;m&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;m&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">使用此索引顺序读取 &lt;code&gt;m&lt;/code&gt; 的元素。 &amp;ldquo; C&amp;rdquo;表示以类似C的顺序索引元素，最后一个轴索引更改最快，而返回到第一个轴索引更改最慢。 &amp;ldquo; F&amp;rdquo;表示以类似Fortran的索引顺序索引元素，第一个索引更改最快，最后一个索引更改最慢。请注意，&amp;ldquo; C&amp;rdquo;和&amp;ldquo; F&amp;rdquo;选项不考虑基础数组的内存布局，仅参考轴索引的顺序。如果 &lt;code&gt;m&lt;/code&gt; 在内存中是&lt;em&gt;连续的&lt;/em&gt; Fortran，则&amp;ldquo; A&amp;rdquo;表示以类似于Fortran的索引顺序读取元素，否则为类似于C的顺序。 &amp;ldquo; K&amp;rdquo;表示按顺序在内存中读取元素，但当步幅为负时反转数据除外。默认情况下，使用&amp;ldquo; C&amp;rdquo;索引顺序。</target>
        </trans-unit>
        <trans-unit id="d8d7a05ea4e76ed025da3efb7e37c3722ae9fddb" translate="yes" xml:space="preserve">
          <source>The elements of both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;a.T&lt;/code&gt; get traversed in the same order, namely the order they are stored in memory, whereas the elements of &lt;code&gt;a.T.copy(order=&amp;rsquo;C&amp;rsquo;)&lt;/code&gt; get visited in a different order because they have been put into a different memory layout.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;a.T&lt;/code&gt; 的元素以相同的顺序遍历，即它们存储在内存中的顺序，而 &lt;code&gt;a.T.copy(order=&amp;rsquo;C&amp;rsquo;)&lt;/code&gt; 的元素以不同的顺序访问，因为它们已放入不同的内存中布局。</target>
        </trans-unit>
        <trans-unit id="7c09282fb5ba8925fe26507ed54970dbeacf3bc3" translate="yes" xml:space="preserve">
          <source>The elements of the shape tuple give the lengths of the corresponding array dimensions.</source>
          <target state="translated">形状元组的元素给出了相应阵列尺寸的长度。</target>
        </trans-unit>
        <trans-unit id="d08dc6baf6d1de4ff7af87aa1f35d18925c1f47b" translate="yes" xml:space="preserve">
          <source>The elements of this structure are:</source>
          <target state="translated">这一结构的要素是:</target>
        </trans-unit>
        <trans-unit id="d0777cee700edf703f03cd8f123c44ac46b607f9" translate="yes" xml:space="preserve">
          <source>The end value of the sequence, unless &lt;code&gt;endpoint&lt;/code&gt; is set to False. In that case, the sequence consists of all but the last of &lt;code&gt;num + 1&lt;/code&gt; evenly spaced samples, so that &lt;code&gt;stop&lt;/code&gt; is excluded. Note that the step size changes when &lt;code&gt;endpoint&lt;/code&gt; is False.</source>
          <target state="translated">序列的最终值，除非将 &lt;code&gt;endpoint&lt;/code&gt; 设置为False。在这种情况下，该序列由除 &lt;code&gt;num + 1&lt;/code&gt; 均匀间隔的采样之外的所有采样组成，因此排除了 &lt;code&gt;stop&lt;/code&gt; 。请注意，当 &lt;code&gt;endpoint&lt;/code&gt; 为False 时，步长会更改。</target>
        </trans-unit>
        <trans-unit id="61c8a67ac747d5eb7d80852565d6317e805901a1" translate="yes" xml:space="preserve">
          <source>The endpoint of the interval can optionally be excluded.</source>
          <target state="translated">区间的端点可以选择排除。</target>
        </trans-unit>
        <trans-unit id="7c70e4957abd94f2cb0f87772d68554c90cbe5b2" translate="yes" xml:space="preserve">
          <source>The entropy for creating a &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">创建&lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;的熵。</target>
        </trans-unit>
        <trans-unit id="0807164c2e58b526f47d2a17d970242e2786a8ed" translate="yes" xml:space="preserve">
          <source>The enumeration value for ASCII strings of a selectable size. The strings have a fixed maximum size within a given array.</source>
          <target state="translated">可选择大小的ASCII字符串的枚举值。在一个给定的数组中,字符串有一个固定的最大尺寸。</target>
        </trans-unit>
        <trans-unit id="4486c486e9b2ccc0519632048cae0af33e6f2bea" translate="yes" xml:space="preserve">
          <source>The enumeration value for UCS4 strings of a selectable size. The strings have a fixed maximum size within a given array.</source>
          <target state="translated">可选择大小的UCS4字符串的枚举值。在给定的数组中,字符串有一个固定的最大尺寸。</target>
        </trans-unit>
        <trans-unit id="ceb80d4c945347bb465d428088d951fae89cf7e9" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 128-bit/16-byte complex type made up of two NPY_DOUBLE values.</source>
          <target state="translated">由两个NPY_DOUBLE值组成的128位/16字节复杂类型的枚举值。</target>
        </trans-unit>
        <trans-unit id="022dd3242a4f7ab9f354ab53434df9783dde262d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte IEEE 754-2008 compatible floating point type.</source>
          <target state="translated">16位/2字节IEEE 754-2008兼容浮点类型的枚举值。</target>
        </trans-unit>
        <trans-unit id="54200391c747968ffe444d868d0f00fe22c905a7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte signed integer.</source>
          <target state="translated">16位/2字节有符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="24e698054b91536d27ff27c354d21704b0ff5fa7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte unsigned integer.</source>
          <target state="translated">16位/2字节无符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="48c93b25a09888099a2fa0e8cc423bbdd97aec51" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte IEEE 754 compatible floating point type.</source>
          <target state="translated">32位/4字节IEEE 754兼容浮点类型的枚举值。</target>
        </trans-unit>
        <trans-unit id="0767688f1013b974d66b67bec323cce162186c28" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte signed integer.</source>
          <target state="translated">32位/4字节有符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="61e002f4aaa6d35ff73356572d5e52edd07749bc" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte unsigned integer.</source>
          <target state="translated">32位/4字节无符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="13bb2de2cc37c2d6613c3c408dc1f6c1a04bcaf7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte IEEE 754 compatible floating point type.</source>
          <target state="translated">64位/8字节IEEE 754兼容浮点类型的枚举值。</target>
        </trans-unit>
        <trans-unit id="712e85738302795b01166defaa51ce15d788398b" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte complex type made up of two NPY_FLOAT values.</source>
          <target state="translated">由两个NPY_FLOAT值组成的64位/8字节复杂类型的枚举值。</target>
        </trans-unit>
        <trans-unit id="6fcce91d25d23bb25fdb72e7335d026c8e38fbfa" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte signed integer.</source>
          <target state="translated">64位/8字节有符号整数的枚举值。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
