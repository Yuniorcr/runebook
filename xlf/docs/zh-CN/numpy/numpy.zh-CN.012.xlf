<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="5f26098ec8a9cbafe4e4d839766540a822d41056" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; is not the same size as the second-to-last dimension of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 的最后一个尺寸与 &lt;code&gt;b&lt;/code&gt; 的倒数第二个尺寸不同。</target>
        </trans-unit>
        <trans-unit id="2fd0d252831ab8d15d091d4ef1abf6e28cded875" translate="yes" xml:space="preserve">
          <source>If the masked array has named fields, accessing a single entry returns a &lt;code&gt;numpy.void&lt;/code&gt; object if none of the fields are masked, or a 0d masked array with the same dtype as the initial array if at least one of the fields is masked.</source>
          <target state="translated">如果被屏蔽的数组具有命名字段，则如果没有一个字段被屏蔽，则访问单个条目将返回 &lt;code&gt;numpy.void&lt;/code&gt; 对象；如果至少一个字段被屏蔽，则访问具有与初始数组相同的dtype的0d被屏蔽的数组。</target>
        </trans-unit>
        <trans-unit id="8ec6f09c123aa3a76dc4dc9103d999ab337134eb" translate="yes" xml:space="preserve">
          <source>If the mode is constant filling (&lt;code&gt;NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING&lt;/code&gt;), fill_value should point to an array object which holds the filling value (the first item will be the filling value if the array contains more than one item). For other cases, fill_value may be NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510c4eb8a3d20ab4214058c75f9744c994e75f43" translate="yes" xml:space="preserve">
          <source>If the mode is constant filling (NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING), fill_value should point to an array object which holds the filling value (the first item will be the filling value if the array contains more than one item). For other cases, fill_value may be NULL.</source>
          <target state="translated">如果模式是恒定填充(NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING),fill_value应该指向一个持有填充值的数组对象(如果数组中包含多个项目,则第一个项目将是填充值)。对于其他情况,fill_value可以是NULL。</target>
        </trans-unit>
        <trans-unit id="be7395567c47ed030147671e19ef0b8f24978bfe" translate="yes" xml:space="preserve">
          <source>If the name is suffixed with the &amp;ldquo;?&amp;rdquo; modifier, the dimension is a core dimension only if it exists on all inputs and outputs that share it; otherwise it is ignored (and replaced by a dimension of size 1 for the elementary function).</source>
          <target state="translated">如果名称后缀&amp;ldquo;？&amp;rdquo; 修改器，只有在共享该维度的所有输入和输出中都存在该维度时，该维度才是核心维度；否则，它将被忽略（并为基本函数替换为尺寸为1的尺寸）。</target>
        </trans-unit>
        <trans-unit id="c3d1c518bb585ba44b9ba4aaf335820db98fa4f5" translate="yes" xml:space="preserve">
          <source>If the new array is larger than the original array, then the new array is filled with repeated copies of &lt;code&gt;a&lt;/code&gt;. Note that this behavior is different from a.resize(new_shape) which fills with zeros instead of repeated copies of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">如果新数组大于原始数组，则新数组将填充 &lt;code&gt;a&lt;/code&gt; 的重复副本。请注意，这种行为是从a.resize（new_shape）不同，其用零代替重复副本填充 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5041b424abd93910d43bf1d34adce8cb0f61f85" translate="yes" xml:space="preserve">
          <source>If the number of objects in the selection tuple is less than &lt;em&gt;N&lt;/em&gt; , then &lt;code&gt;:&lt;/code&gt; is assumed for any subsequent dimensions.</source>
          <target state="translated">如果选择元组中的对象数小于&lt;em&gt;N&lt;/em&gt;，则对于任何后续维，均假定 &lt;code&gt;:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f2a8e76e80cc97243c0461015d68ab374ad3374" translate="yes" xml:space="preserve">
          <source>If the number of objects in the selection tuple is less than &lt;em&gt;N&lt;/em&gt;, then &lt;code&gt;:&lt;/code&gt; is assumed for any subsequent dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2928aac7d9000dc7b0628e4b095667d7efc04498" translate="yes" xml:space="preserve">
          <source>If the object in question is compiled in a language other than Python, using &lt;code&gt;??&lt;/code&gt; will return the same information as &lt;code&gt;?&lt;/code&gt;. You&amp;rsquo;ll find this with a lot of built-in objects and types, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a6c4456ec6f4292b9cf18dc4d579bb22a84db3" translate="yes" xml:space="preserve">
          <source>If the object provided is an array, this function traverses the chain of &lt;code&gt;base&lt;/code&gt; pointers so that each array points to the owner of the memory directly. Once the base is set, it may not be changed to another value.</source>
          <target state="translated">如果提供的对象是数组，则此函数将遍历 &lt;code&gt;base&lt;/code&gt; 指针链，以便每个数组直接指向内存的所有者。一旦设置了基准，就不能将其更改为另一个值。</target>
        </trans-unit>
        <trans-unit id="89a89c71a1b9f2da8de85eabab619e5820532ff8" translate="yes" xml:space="preserve">
          <source>If the offsets of the fields and itemsize of a structured array satisfy the alignment conditions, the array will have the &lt;code&gt;ALIGNED&lt;/code&gt;&lt;a href=&quot;../reference/generated/numpy.ndarray.flags#numpy.ndarray.flags&quot;&gt;&lt;code&gt;flag&lt;/code&gt;&lt;/a&gt; set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657e1806ea99b60e1959c9ce313bdaa2fd70aa64" translate="yes" xml:space="preserve">
          <source>If the operand is flagged as write-only and a copy is needed, an uninitialized temporary array will be created and then copied to back to &lt;code&gt;op[i]&lt;/code&gt; on calling &lt;code&gt;NpyIter_Deallocate&lt;/code&gt;, instead of doing the unnecessary copy operation.</source>
          <target state="translated">如果操作数被标记为只写且需要复制，则将创建未初始化的临时数组，然后在调用 &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; 时将其复制回 &lt;code&gt;op[i]&lt;/code&gt; ，而不执行不必要的复制操作。</target>
        </trans-unit>
        <trans-unit id="17f4400245338f1e4a33ed23afc91ef7ab8c40c6" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; is given, only the first &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; occurrences are replaced.</source>
          <target state="translated">如果给出了可选的参数&lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;，则仅替换第一个出现的&lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="650baf4400147a0e58c70982764ea43290cfecc2" translate="yes" xml:space="preserve">
          <source>If the package is not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad175da47137fbc79b21402b2a0b69af4d4bc0f" translate="yes" xml:space="preserve">
          <source>If the position of iter is changed, any subsequent call to PyArrayNeighborhoodIter_Next is undefined behavior, and PyArrayNeighborhoodIter_Reset must be called.</source>
          <target state="translated">如果改变了iter的位置,后续对PyArrayNeighborhoodIter_Next的任何调用都是未定义的行为,必须调用PyArrayNeighborhoodIter_Reset。</target>
        </trans-unit>
        <trans-unit id="16e630a04286a25caaca20cb641690b37ba91ed8" translate="yes" xml:space="preserve">
          <source>If the release series is a new one, you will need to add a new section to the &lt;code&gt;doc/build/merge/index.html&lt;/code&gt; front page just after the &amp;ldquo;insert here&amp;rdquo; comment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c927b8ff30da3cc5f4b149881b61cbe3118f463" translate="yes" xml:space="preserve">
          <source>If the requested data type is in non-native byte order, the NBO flag overrides it and the requested data type is converted to be in native byte order.</source>
          <target state="translated">如果所请求的数据类型为非本地字节顺序,NBO标志将覆盖它,所请求的数据类型将被转换为本地字节顺序。</target>
        </trans-unit>
        <trans-unit id="8a5c6764b6f67871837f5bb9b64736c18fe7a7ad" translate="yes" xml:space="preserve">
          <source>If the returned coefficients are &lt;code&gt;c&lt;/code&gt;, then</source>
          <target state="translated">如果返回的系数为 &lt;code&gt;c&lt;/code&gt; ，则</target>
        </trans-unit>
        <trans-unit id="054023bbbbd71a4d456dd16da82bfb709a02f2cc" translate="yes" xml:space="preserve">
          <source>If the second argument is 1-D, it is promoted to a matrix by appending a 1 to its dimensions. After matrix multiplication the appended 1 is removed.</source>
          <target state="translated">如果第二个参数是1-D,则通过在其维度上追加1,将其提升为矩阵。矩阵乘法后,去掉附加的1。</target>
        </trans-unit>
        <trans-unit id="b4b38312a537fa220f815af5dcf5f4139bad3681" translate="yes" xml:space="preserve">
          <source>If the selection tuple has all entries &lt;code&gt;:&lt;/code&gt; except the &lt;em&gt;p&lt;/em&gt;-th entry which is a slice object &lt;code&gt;i:j:k&lt;/code&gt;, then the returned array has dimension &lt;em&gt;N&lt;/em&gt; formed by concatenating the sub-arrays returned by integer indexing of elements &lt;em&gt;i&lt;/em&gt;, &lt;em&gt;i+k&lt;/em&gt;, &amp;hellip;, &lt;em&gt;i + (m - 1) k &amp;lt; j&lt;/em&gt;,</source>
          <target state="translated">如果选择元组具有所有条目 &lt;code&gt;:&lt;/code&gt; 除第&lt;em&gt;p&lt;/em&gt;个条目（它是切片对象 &lt;code&gt;i:j:k&lt;/code&gt; )之外，则返回数组的维数&lt;em&gt;N&lt;/em&gt;是通过串联元素&lt;em&gt;i&lt;/em&gt;，&lt;em&gt;i + k的&lt;/em&gt;整数索引返回的子数组而形成的，&amp;hellip;，&lt;em&gt;i +（m-1）k &amp;lt;j&lt;/em&gt;，</target>
        </trans-unit>
        <trans-unit id="9a652cfa7a533eb64735eb374de6f3a4977f5b9c" translate="yes" xml:space="preserve">
          <source>If the spacing between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; for one or more elements is larger than &lt;code&gt;nulp&lt;/code&gt;.</source>
          <target state="translated">如果一个或多个元素的 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 之间的间距大于 &lt;code&gt;nulp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3600ee510b36714644dcc89a19bb177b5b6c4ba7" translate="yes" xml:space="preserve">
          <source>If the string is not the correct size to satisfy the requested &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">如果字符串的大小不正确，不能满足要求的&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8431a3b44693b10770bc98218be6d44b926dbd16" translate="yes" xml:space="preserve">
          <source>If the transition to C++ goes through it is possible that this form will be relaxed so that short class methods meant to be inlined can have the return type on the same line as the function name. However, that is yet to be determined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc3886c14d49cd40506d4084002663f28dbcdd3" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;x&lt;/code&gt; is unsigned, then the output type is the unsigned platform integer:</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 的类型是无符号的，则输出类型是无符号的平台整数：</target>
        </trans-unit>
        <trans-unit id="183bc4d9ba8fd4894a95c0f09db6946e16642c92" translate="yes" xml:space="preserve">
          <source>If the type of the input is complex.</source>
          <target state="translated">如果输入的类型是复杂的。</target>
        </trans-unit>
        <trans-unit id="95366e62fbbbe64ba41cdcaa0c22be8d3f384cd4" translate="yes" xml:space="preserve">
          <source>If the type of the input is float or complex.</source>
          <target state="translated">如果输入的类型是浮点数或复数。</target>
        </trans-unit>
        <trans-unit id="25291949b6396c31462d4c34b8e8b5c2797cb90a" translate="yes" xml:space="preserve">
          <source>If the ufunc has 2 inputs and 1 output and the second input is an Object array then a special-case check is performed so that NotImplemented is returned if the second input is not an ndarray, has the __array_priority__ attribute, and has an __r{op}__ special method. In this way, Python is signaled to give the other object a chance to complete the operation instead of using generic object-array calculations. This allows (for example) sparse matrices to override the multiplication operator 1-D loop.</source>
          <target state="translated">如果ufunc有2个输入和1个输出,并且第二个输入是一个对象数组,那么就会进行特殊情况下的检查,所以如果第二个输入不是ndarray,有__array_priority__属性,并且有__r{op}__特殊方法,就会返回NotImplemented。通过这种方式,Python 会发出信号,让另一个对象有机会完成操作,而不是使用通用的对象-数组计算。这允许(例如)稀疏矩阵覆盖乘法运算符 1-D 循环。</target>
        </trans-unit>
        <trans-unit id="a4dffd94a98e9a9ee0037afd472e661e6232061e" translate="yes" xml:space="preserve">
          <source>If the underlying data is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it is returned as such.</source>
          <target state="translated">如果基础数据是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt;的子类，则将其返回。</target>
        </trans-unit>
        <trans-unit id="c8138c9410f7b3ce9c5c6bb9d0523e6e1ea7bd8e" translate="yes" xml:space="preserve">
          <source>If the underlying data is a subclass of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it is returned as such.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f03c3143f8af1fee84b593563d21e127566799" translate="yes" xml:space="preserve">
          <source>If the user tries to use any numpy functions not included in &lt;code&gt;HANDLED_FUNCTIONS&lt;/code&gt;, a &lt;code&gt;TypeError&lt;/code&gt; will be raised by numpy, indicating that this operation is not supported. For example, concatenating two &lt;code&gt;DiagonalArrays&lt;/code&gt; does not produce another diagonal array, so it is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23122d3c8d35684d3c1d392886f730d15f172384" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果值不是默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 将传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;子类的&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt;方法。如果子类方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="2abfa832de7674bd2d08ad1f7e2b845f18a0059c" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果该值不是默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 将传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;子类的&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt;方法。如果子类方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="fb8acc52d13221f0fba6edb05a42e80cbebd0a2e" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; methods of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果值不是默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 将传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;子类的&lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;方法。如果子类方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="33c6901ff2ee0db95c77f2b313983f44526bb314" translate="yes" xml:space="preserve">
          <source>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt;&lt;code&gt;PyArray_PromoteTypes&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">如果仅存在标量或标量的最大类别高于数组的最大类别，则将数据类型与&lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt; &lt;code&gt;PyArray_PromoteTypes&lt;/code&gt; &lt;/a&gt;组合以生成返回值。</target>
        </trans-unit>
        <trans-unit id="33fe4c771f7142c020971d30614039b35a541395" translate="yes" xml:space="preserve">
          <source>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">如果仅存在标量，或者标量的最大类别高于数组的最大类别，则将数据类型与&lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt;组合以产生返回值。</target>
        </trans-unit>
        <trans-unit id="713f3b36701faad5c729c8225f4c0508fcfe41f1" translate="yes" xml:space="preserve">
          <source>If there is no dictionary passed in or &lt;code&gt;vardict&lt;/code&gt; is None then returns NumPy arrays in the globals() dictionary (all NumPy arrays in the namespace).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c11d30de5e96bdaa85cb78bb53dddd3ba03ebc" translate="yes" xml:space="preserve">
          <source>If there is no library with the expected extension, or the library is defective and cannot be loaded.</source>
          <target state="translated">如果没有预期的扩展库,或者库有缺陷,无法加载。</target>
        </trans-unit>
        <trans-unit id="ef27bb26cd9e20ec5eb81bab137d2b6e00a224b0" translate="yes" xml:space="preserve">
          <source>If there is only one Boolean array and no integer indexing array present, this is straight forward. Care must only be taken to make sure that the boolean index has &lt;em&gt;exactly&lt;/em&gt; as many dimensions as it is supposed to work with.</source>
          <target state="translated">如果仅存在一个布尔数组，而没有整数索引数组，则这很简单。必须注意只能采取以确保布尔指数具有&lt;em&gt;完全相同&lt;/em&gt;的许多方面，它应该是与工作。</target>
        </trans-unit>
        <trans-unit id="6e268d3c7b0192c893825d9fa07e4e49b28360ad" translate="yes" xml:space="preserve">
          <source>If these arrays are all collected in a structured array, then &lt;a href=&quot;#c.PyArray_Sort&quot;&gt;&lt;code&gt;PyArray_Sort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can also be used to sort the array directly.</source>
          <target state="translated">如果所有这些数组都收集在一个结构化数组中，则&lt;a href=&quot;#c.PyArray_Sort&quot;&gt; &lt;code&gt;PyArray_Sort&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）也可用于直接对该数组排序。</target>
        </trans-unit>
        <trans-unit id="54dc9b5be81c958064f5d558fe01980eec4eadde" translate="yes" xml:space="preserve">
          <source>If these conditions are not met, a &lt;code&gt;ValueError: operands could not be broadcast together&lt;/code&gt; exception is thrown, indicating that the arrays have incompatible shapes. The size of the resulting array is the size that is not 1 along each axis of the inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5797d27d90ecc738ae241c7f2d88131ab4d780" translate="yes" xml:space="preserve">
          <source>If these conditions hold, &lt;code&gt;__array_function__&lt;/code&gt; should return the result from calling its implementation for &lt;code&gt;func(*args, **kwargs)&lt;/code&gt;. Otherwise, it should return the sentinel value &lt;code&gt;NotImplemented&lt;/code&gt;, indicating that the function is not implemented by these types.</source>
          <target state="translated">如果这些条件成立，则 &lt;code&gt;__array_function__&lt;/code&gt; 应该从调用 &lt;code&gt;func(*args, **kwargs)&lt;/code&gt; 实现中返回结果。否则，它应该返回前哨值 &lt;code&gt;NotImplemented&lt;/code&gt; ，指示该功能不是由这些类型实现的。</target>
        </trans-unit>
        <trans-unit id="c80ca8262eeedd9bef78dbd28fb2dc07a4582c48" translate="yes" xml:space="preserve">
          <source>If this array does not own its own memory, then base points to the Python object that owns it (perhaps another array object)</source>
          <target state="translated">如果这个数组没有自己的内存,那么base指向拥有它的Python对象(可能是另一个数组对象)</target>
        </trans-unit>
        <trans-unit id="f79009d9f8b9e9859082a3efe68d074e3e908ff8" translate="yes" xml:space="preserve">
          <source>If this array has the (deprecated) &lt;a href=&quot;array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set, then this array is a working copy of a &amp;ldquo;misbehaved&amp;rdquo; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f63b91f81d86b6356e230f230ee7da044adca895" translate="yes" xml:space="preserve">
          <source>If this array has the (deprecated) &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set, then this array is a working copy of a &amp;ldquo;misbehaved&amp;rdquo; array.</source>
          <target state="translated">如果此阵列设置了（不建议使用的）&lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;标志，则此阵列是&amp;ldquo;行为不当&amp;rdquo;阵列的工作副本。</target>
        </trans-unit>
        <trans-unit id="2e1498e4add4060095cafec2d44c32b17e6ac395" translate="yes" xml:space="preserve">
          <source>If this condition is not met, a &lt;code&gt;ValueError('frames are not aligned')&lt;/code&gt; exception is thrown indicating that the arrays have incompatible shapes. The size of the result array created by broadcast operations is the maximum size along each dimension from the input arrays. Note that the rule does not say anything about the two arrays needing to have the same number of dimensions. So, for example, if you have a 256 x 256 x 3 array of RGB values, and you want to scale each color in the image by a different value, you can multiply the image by a one-dimensional array with 3 values. Lining up the sizes of the trailing axes of these arrays according to the broadcast rule shows that they are compatible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54640e63d198f32f1e8358a28ce29bc6179e6f7" translate="yes" xml:space="preserve">
          <source>If this function returns true, the caller should also check the inner loop stride of the operand, because if that stride is 0, then only the first element of the innermost external loop is being visited for the first time.</source>
          <target state="translated">如果这个函数返回true,调用者还应该检查操作数的内循环跨度,因为如果该跨度为0,那么第一次只访问了最里面的外部循环的第一个元素。</target>
        </trans-unit>
        <trans-unit id="24a22c06faef1b4b61f295517b88ec97d1fc0a84" translate="yes" xml:space="preserve">
          <source>If this is &lt;code&gt;None&lt;/code&gt;, a reduction is performed over all the axes. If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">如果为 &lt;code&gt;None&lt;/code&gt; ，则对所有轴进行归约。如果这是一个整数元组，则在多个轴上执行归约，而不是像以前那样在单个轴或所有轴上执行归约。</target>
        </trans-unit>
        <trans-unit id="33f579e70b917db4493a3111bc7067b3dc4d2ff2" translate="yes" xml:space="preserve">
          <source>If this is None, a reduction is performed over all the axes. If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4599c6e53b844db2376ed9e56ed7b49e63c6ec3" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a mean is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">如果这是一个ints的元组,则在多个轴上执行平均数,而不是像以前那样在一个轴或所有轴上执行。</target>
        </trans-unit>
        <trans-unit id="04767d2c5f5bbd4aab7323a751a31f226739a396" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">如果这是一个ints的元组,则会在多个轴上进行还原,而不是像之前那样在单个轴或所有轴上进行还原。</target>
        </trans-unit>
        <trans-unit id="e11ec2c8b461dd6b1390de16d518719c4d72ce55" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a standard deviation is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">如果这是一个ints的元组,则在多个轴上执行标准偏差,而不是像以前那样在一个轴或所有轴上执行标准偏差。</target>
        </trans-unit>
        <trans-unit id="cdec667610de13f7517139e9ece6f88d2d290194" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a variance is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">如果这是一个ints的元组,则会在多个轴上进行方差,而不是像之前那样在单个轴或所有轴上进行方差。</target>
        </trans-unit>
        <trans-unit id="d50012ee6c384ff0215bab7085fcf98c562bc452" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the count is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">如果这是一个ints的元组,则在多个轴上进行计数,而不是像以前那样在单个轴或所有轴上进行计数。</target>
        </trans-unit>
        <trans-unit id="c674e367c6b1c23d3abf3ddc4c5a7a14ff593b5a" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the maximum is selected over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">如果这是一个ints的元组,则在多个轴上选择最大值,而不是像以前那样选择单个轴或所有轴。</target>
        </trans-unit>
        <trans-unit id="a0756a48081a9a9cb1bfbc79e9843f0007e55c1d" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the minimum is selected over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">如果这是一个ints的元组,则在多个轴上选择最小值,而不是像以前那样选择单个轴或所有轴。</target>
        </trans-unit>
        <trans-unit id="7573da3ff564f7261e16d53ba17d4d7c25b6abc9" translate="yes" xml:space="preserve">
          <source>If this is anything but the default value it will be passed through (in the special case of an empty array) to the &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; function of the underlying array. If the array is a sub-class and &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; does not have the kwarg &lt;code&gt;keepdims&lt;/code&gt; this will raise a RuntimeError.</source>
          <target state="translated">如果这不是默认值，它将通过（在特殊情况下为空数组）传递给基础数组的&lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;函数。如果数组是子类，并且&lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;没有kwarg &lt;code&gt;keepdims&lt;/code&gt; ,则将引发RuntimeError。</target>
        </trans-unit>
        <trans-unit id="9eef22bd67c15e89cde5d92734a40aa76d92e691" translate="yes" xml:space="preserve">
          <source>If this is non- &lt;code&gt;NULL&lt;/code&gt;, then this data-type descriptor is a C-style contiguous array of another data-type descriptor. In other-words, each element that this descriptor describes is actually an array of some other base descriptor. This is most useful as the data-type descriptor for a field in another data-type descriptor. The fields member should be &lt;code&gt;NULL&lt;/code&gt; if this is non- &lt;code&gt;NULL&lt;/code&gt; (the fields member of the base descriptor can be non- &lt;code&gt;NULL&lt;/code&gt; however). The &lt;code&gt;PyArray_ArrayDescr&lt;/code&gt; structure is defined using</source>
          <target state="translated">如果这是非 &lt;code&gt;NULL&lt;/code&gt; ，则此数据类型描述符是另一个数据类型描述符的C样式连续数组。换句话说，此描述符描述的每个元素实际上是一些其他基本描述符的数组。作为另一个数据类型描述符中字段的数据类型描述符，这是最有用的。字段构件应该是 &lt;code&gt;NULL&lt;/code&gt; ，如果这是不 &lt;code&gt;NULL&lt;/code&gt; （基描述符的字段构件可以是非 &lt;code&gt;NULL&lt;/code&gt; 不过）。该 &lt;code&gt;PyArray_ArrayDescr&lt;/code&gt; 结构使用定义</target>
        </trans-unit>
        <trans-unit id="2824d770011e81edcc48aaca00be40fe5064246e" translate="yes" xml:space="preserve">
          <source>If this is non-NULL, then this data-type-descriptor has fields described by a Python dictionary whose keys are names (and also titles if given) and whose values are tuples that describe the fields. Recall that a data-type-descriptor always describes a fixed-length set of bytes. A field is a named sub-region of that total, fixed-length collection. A field is described by a tuple composed of another data- type-descriptor and a byte offset. Optionally, the tuple may contain a title which is normally a Python string. These tuples are placed in this dictionary keyed by name (and also title if given).</source>
          <target state="translated">如果这个是非NULL,那么这个数据类型描述符的字段由Python字典描述,它的键是名称(如果给定,也包括标题),它的值是描述字段的元组。回想一下,一个数据类型描述符总是描述一个固定长度的字节集。字段是这个总的、固定长度的集合的一个命名的子区域。字段由另一个数据类型描述符和一个字节偏移量组成的元组来描述。可选地,元组可以包含一个标题,它通常是一个 Python 字符串。这些元组被放置在这个按名称(如果给定的话,还包括标题)键的字典中。</target>
        </trans-unit>
        <trans-unit id="0d86cba4ba7294ed9f7338e68f7b4f37b35c1557" translate="yes" xml:space="preserve">
          <source>If this is not desirable, then the array should be cast to a larger integer type first:</source>
          <target state="translated">如果不希望这样做,那么应该先将数组转为一个较大的整数类型。</target>
        </trans-unit>
        <trans-unit id="1ae38fd1d446748062bddf73d4866a0b315e1322" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;True&lt;/code&gt;, axes which are reduced over will be left in the result as a dimension with size one, so that the result will broadcast correctly against the inputs. This option can only be used for generalized ufuncs that operate on inputs that all have the same number of core dimensions and with outputs that have no core dimensions , i.e., with signatures like &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; or &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt;. If used, the location of the dimensions in the output can be controlled with &lt;code&gt;axes&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">如果将其设置为 &lt;code&gt;True&lt;/code&gt; ，则缩小的轴将作为尺寸为1的尺寸保留在结果中，以便可以正确地对输入广播结果。此选项仅可用于对所有具有相同核心尺寸的输入和没有核心尺寸的输出进行操作的通用ufunc，即具有 &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; 或 &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt; 。如果使用的话，在输出尺寸的位置就可以与被控制 &lt;code&gt;axes&lt;/code&gt; 和 &lt;code&gt;axis&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a675290349084bcd281fdfbd331891015b07aca9" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;True&lt;/code&gt;, axes which are reduced over will be left in the result as a dimension with size one, so that the result will broadcast correctly against the inputs. This option can only be used for generalized ufuncs that operate on inputs that all have the same number of core dimensions and with outputs that have no core dimensions, i.e., with signatures like &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; or &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt;. If used, the location of the dimensions in the output can be controlled with &lt;code&gt;axes&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e30e948710dc5b2db29b7dc82437914fd08740" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes that are counted are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74585a8bd339c6874f448a64d5fe0ba3642c10c6" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are normed over are left in the result as dimensions with size one. With this option the result will broadcast correctly against the original &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">如果将其设置为True，则归一化后的轴将保留为尺寸为1的尺寸。使用此选项，结果将针对原始 &lt;code&gt;x&lt;/code&gt; 正确广播。</target>
        </trans-unit>
        <trans-unit id="526b620d34688cc0c68a7ee67814781d453388f5" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the array.</source>
          <target state="translated">如果这个选项被设置为True,被缩减的轴将作为尺寸为1的尺寸留在结果中。使用这个选项,结果将正确地在数组中广播。</target>
        </trans-unit>
        <trans-unit id="015e500928e7c3f86f2c9b5121c746246fcd7a9f" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</source>
          <target state="translated">如果设置为True,被缩小的轴将作为尺寸为1的尺寸留在结果中。使用这个选项,结果将正确地在输入数组中广播。</target>
        </trans-unit>
        <trans-unit id="caf30df07a09579107c0faa5c9aaad9ad8721644" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">如果将其设置为True，则缩小的轴将保留为尺寸1的尺寸。使用此选项，结果将相对于原始 &lt;code&gt;a&lt;/code&gt; 正确广播。</target>
        </trans-unit>
        <trans-unit id="668624d9e02d10dc8924733d51742fcc1923286c" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">如果将其设置为True，则缩小的轴将保留为尺寸1的尺寸。使用此选项，结果将针对原始 &lt;code&gt;arr&lt;/code&gt; 正确广播。</target>
        </trans-unit>
        <trans-unit id="813c59426f99f6e2035686f0669f18c79ec2fc97" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">如果将其设置为True，则缩小的轴将保留为尺寸1的尺寸。使用此选项，结果将针对原始数组 &lt;code&gt;a&lt;/code&gt; 正确广播。</target>
        </trans-unit>
        <trans-unit id="28e1fe971ad9fdc32699e38250e14da5caf0bb91" translate="yes" xml:space="preserve">
          <source>If this value is anything but the default it is passed through as-is to the relevant functions of the sub-classes. If these functions do not have a &lt;code&gt;keepdims&lt;/code&gt; kwarg, a RuntimeError will be raised.</source>
          <target state="translated">如果该值不是默认值，它将按原样传递给子类的相关函数。如果这些函数没有 &lt;code&gt;keepdims&lt;/code&gt; kwarg，则会引发RuntimeError。</target>
        </trans-unit>
        <trans-unit id="dd4ec2a983c899a1017fcabb86ae5785ce4793ab" translate="yes" xml:space="preserve">
          <source>If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, etc.).</source>
          <target state="translated">如果为true（默认值），则复制对象。否则，仅当__array__返回副本，obj是嵌套序列或满足其他任何要求（&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;order&lt;/code&gt; 等）需要副本时，才进行副本。</target>
        </trans-unit>
        <trans-unit id="a6f5f638d5dadad294989835332dc69ea08c7e48" translate="yes" xml:space="preserve">
          <source>If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (&lt;code&gt;itemsize&lt;/code&gt;, unicode, &lt;code&gt;order&lt;/code&gt;, etc.).</source>
          <target state="translated">如果为true（默认值），则复制对象。否则，仅当__array__返回副本，obj为嵌套序列或满足其他任何要求（ &lt;code&gt;itemsize&lt;/code&gt; ，unicode， &lt;code&gt;order&lt;/code&gt; 等）需要副本时，才创建副本。</target>
        </trans-unit>
        <trans-unit id="7cfded7f1f4f8985525752f730c915f025bbc3bd" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">如果为true，则 &lt;code&gt;stop&lt;/code&gt; 是最后一个样本。否则，不包括在内。默认值为True。</target>
        </trans-unit>
        <trans-unit id="89363179f510b5ee9e2706f4cf949aff38e269d9" translate="yes" xml:space="preserve">
          <source>If true, sample from the interval [low, high] instead of the default [low, high) Defaults to False</source>
          <target state="translated">如果为真,从区间[低,高]取样,而不是默认的[低,高]默认为假。</target>
        </trans-unit>
        <trans-unit id="ade7c82d0d30db8fc4ef391480e9db75f4fe6678" translate="yes" xml:space="preserve">
          <source>If true, use an &amp;ldquo;aligned&amp;rdquo; memory layout, otherwise use a &amp;ldquo;packed&amp;rdquo; layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef0d38b764385bc39d70e5ad26d095da7b5d3f0" translate="yes" xml:space="preserve">
          <source>If used with &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;, the inner loop for the caller may get larger chunks than would be possible without buffering, because of how the strides are laid out.</source>
          <target state="translated">如果与&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;一起使用，则调用程序的内部循环可能会获得比没有缓冲的情况更大的块，这是因为步幅的布局方式。</target>
        </trans-unit>
        <trans-unit id="e6e87a78ddc8c45866e59f696a01a91d82f291c2" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;x&lt;/code&gt; are beyond the bounds of &lt;code&gt;bins&lt;/code&gt;, 0 or &lt;code&gt;len(bins)&lt;/code&gt; is returned as appropriate.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 中的值超出 &lt;code&gt;bins&lt;/code&gt; 的范围，则将适当地返回0或 &lt;code&gt;len(bins)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adc126c0d80d4b8b968260ca8a9cd270dc0bc84e" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;x&lt;/code&gt; are such that they fall outside the bin range, attempting to index &lt;code&gt;bins&lt;/code&gt; with the indices that &lt;a href=&quot;#numpy.digitize&quot;&gt;&lt;code&gt;digitize&lt;/code&gt;&lt;/a&gt; returns will result in an IndexError.</source>
          <target state="translated">如果值 &lt;code&gt;x&lt;/code&gt; 是这样的，它们落在垃圾桶范围之外，试图指数 &lt;code&gt;bins&lt;/code&gt; 与指数是&lt;a href=&quot;#numpy.digitize&quot;&gt; &lt;code&gt;digitize&lt;/code&gt; &lt;/a&gt;回报率将导致IndexError。</target>
        </trans-unit>
        <trans-unit id="b223152b4e60f22e3efa048a66b57e829307cf69" translate="yes" xml:space="preserve">
          <source>If we designed &lt;code&gt;rms&lt;/code&gt;, we probably made it a routine that takes an input-only array of length &lt;code&gt;n&lt;/code&gt; of &lt;code&gt;double&lt;/code&gt; values called &lt;code&gt;seq&lt;/code&gt; and returns the root mean square. The default behavior of &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;, however, will be to create a wrapper function that compiles, but is nearly impossible to use from the scripting language in the way the C routine was intended.</source>
          <target state="translated">如果我们设计 &lt;code&gt;rms&lt;/code&gt; ，则可能使它成为一个例程，该例程接受长度为 &lt;code&gt;n&lt;/code&gt; 的 &lt;code&gt;double&lt;/code&gt; 值（称为 &lt;code&gt;seq&lt;/code&gt; )的仅输入数组，并返回均方根。但是，&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;的默认行为是创建一个包装函数，该函数可以进行编译，但几乎不可能以脚本语言的预期方式使用C例程。</target>
        </trans-unit>
        <trans-unit id="995e94e98f9bf00d5fa392b05fcaad89987b6cf9" translate="yes" xml:space="preserve">
          <source>If we operate on &lt;code&gt;arr&lt;/code&gt; with a numpy function, numpy will again use the &lt;code&gt;__array__&lt;/code&gt; interface to convert it to an array and then apply the function in the usual way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f97977f7edcb7ebd515a426a761fd048280b35b8" translate="yes" xml:space="preserve">
          <source>If we subclass ndarray, we need to deal not only with explicit construction of our array type, but also &lt;a href=&quot;#view-casting&quot;&gt;View casting&lt;/a&gt; or &lt;a href=&quot;#new-from-template&quot;&gt;Creating new from template&lt;/a&gt;. NumPy has the machinery to do this, and this machinery that makes subclassing slightly non-standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3492efc8039f75947121fd3b30a1fa61841ee0" translate="yes" xml:space="preserve">
          <source>If we want to get the max and min at the same time, we can stack the indices first</source>
          <target state="translated">如果我们想同时得到最大和最小值,我们可以先把指数堆叠起来。</target>
        </trans-unit>
        <trans-unit id="0b08db0a15b738091c43209c89bb138ad98fa1a5" translate="yes" xml:space="preserve">
          <source>If writing to the value in &amp;lsquo;op&amp;rsquo; is desired, set the boolean &amp;lsquo;writeable&amp;rsquo; to 1. This raises an error when &amp;lsquo;op&amp;rsquo; is a scalar, list of lists, or other non-writeable &amp;lsquo;op&amp;rsquo;. This differs from passing &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; to PyArray_FromAny, where the writeable array may be a copy of the input.</source>
          <target state="translated">如果需要写入&amp;ldquo; op&amp;rdquo;中的值，请将布尔值&amp;ldquo; writeable&amp;rdquo;设置为1。如果&amp;ldquo; op&amp;rdquo;是标量，列表列表或其他不可写的&amp;ldquo; op&amp;rdquo;，则会引发错误。这与将&lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;传递给PyArray_FromAny 有所不同，在PyArray_FromAny中，可写数组可能是输入的副本。</target>
        </trans-unit>
        <trans-unit id="d75e358b391e7be55d7e5cd127dec8c0712acdf8" translate="yes" xml:space="preserve">
          <source>If you already have Matplotlib installed, you can import it with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cdef2e4118adffef01cdccc2d7928ddab94e772" translate="yes" xml:space="preserve">
          <source>If you already have Python, you can install NumPy with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541c45cda5d06a312d0d288fb58df06c65cc4253" translate="yes" xml:space="preserve">
          <source>If you are a first-time contributor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df553e5d4398ed0e4dcd8bdb41c75c9a32748a9c" translate="yes" xml:space="preserve">
          <source>If you are constructing an array using the C API, and specifying your own memory, you should use the function &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt; to set the base to an object which owns the memory.</source>
          <target state="translated">如果要使用C API构造数组并指定自己的内存，则应使用函数&lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; &lt;/a&gt;将基设置为拥有内存的对象。</target>
        </trans-unit>
        <trans-unit id="348c2da24ae5fb5879e487ab21af4e5f5e066f22" translate="yes" xml:space="preserve">
          <source>If you are executing the commands above in the IPython shell, it might be necessary to use the command &lt;code&gt;plt.show()&lt;/code&gt; to show the image window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a6add3139de0ce389e24494d0e34b85d48e6cd" translate="yes" xml:space="preserve">
          <source>If you are not a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend your class define special methods like &lt;code&gt;__add__&lt;/code&gt; and &lt;code&gt;__lt__&lt;/code&gt; that delegate to ufuncs just like ndarray does. An easy way to do this is to subclass from &lt;a href=&quot;generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt;&lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您不是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;的子类，我们建议您的类定义 &lt;code&gt;__add__&lt;/code&gt; 和 &lt;code&gt;__lt__&lt;/code&gt; 之类的特殊方法，就像ndarray 一样，它们委托给ufuncs。一种简单的方法是从&lt;a href=&quot;generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt; &lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt; 继承&lt;/a&gt;子类。</target>
        </trans-unit>
        <trans-unit id="7c035b2fcdae27121ab8105788f03a3cf705ba84" translate="yes" xml:space="preserve">
          <source>If you are unfamiliar with git/GitHub or the process of submitting a pull request (PR), check our &lt;a href=&quot;index#devindex&quot;&gt;Contributor Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4921cf970b61f597c75ff9a8df48494b979251" translate="yes" xml:space="preserve">
          <source>If you are unsure whether your tutorial is useful to the community, consider submitting an issue on GitHub suggesting it, or asking on the mailing list or Stack Overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e97815d05cf1a3f4e8ef4ccabd6db0958203378" translate="yes" xml:space="preserve">
          <source>If you are using a development setup, make sure to run &lt;code&gt;git clean -xdf&lt;/code&gt; to delete all files not under version control (be careful not to lose any modifications you made, e.g. &lt;code&gt;site.cfg&lt;/code&gt;). In many cases files from old builds may lead to incorrect builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1cb5159432a421c78854c686fcae1e006f9ca62" translate="yes" xml:space="preserve">
          <source>If you are using your own image, this command might take a while to run, depending on the size of your image and your hardware. Don&amp;rsquo;t worry, this is normal! The SVD can be a pretty intensive computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773329737315bec4048498e2cb47eae44fac50c7" translate="yes" xml:space="preserve">
          <source>If you are writing a tutorial or how-to, we encourage you to use real images and data (provided they are appropriately licensed and available). This makes the material more engaging for readers, and choosing the right data can add pedagogical value to your content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4136f331004a4bb7cc67364f6afc023fd507b25" translate="yes" xml:space="preserve">
          <source>If you are writing an extension module that will include quite a bit of your own algorithmic code as well, then Cython is a good match. Among its features is the ability to easily and quickly work with multidimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97bfbc5e92312fd81c84cc357b8b556f1c360029" translate="yes" xml:space="preserve">
          <source>If you are writing code that needs to support older versions of numpy, note that prior to 1.15, &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; was not a context manager and did not have a &lt;code&gt;close&lt;/code&gt; method. Instead it relied on the destructor to initiate the writeback of the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ae6f737ad58a255ae0b7d304bf552b5362f8bf" translate="yes" xml:space="preserve">
          <source>If you are writing the algorithm, then I recommend that you use the stride information contained in the array to access the elements of the array (the &lt;a href=&quot;../reference/c-api/array#c.PyArray_GetPtr&quot;&gt;&lt;code&gt;PyArray_GetPtr&lt;/code&gt;&lt;/a&gt; macros make this painless). Then, you can relax your requirements so as not to force a single-segment array and the data-copying that might result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55dd90ddf002e60cb33ced8fd77f1baf2f3e711" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t already comfortable with reading tutorials that contain a lot of code, you might not know how to interpret a code block that looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aadabdedda0a7396088f7e7156f2221bf29f201" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t familiar with this style, it&amp;rsquo;s very easy to understand. If you see &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, you&amp;rsquo;re looking at &lt;strong&gt;input&lt;/strong&gt;, or the code that you would enter. Everything that doesn&amp;rsquo;t have &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; in front of it is &lt;strong&gt;output&lt;/strong&gt;, or the results of running your code. This is the style you see when you run &lt;code&gt;python&lt;/code&gt; on the command line, but if you&amp;rsquo;re using IPython, you might see a different style.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb14ac1edba829d3112a46c925f71b9aef58fe4d" translate="yes" xml:space="preserve">
          <source>If you begin with a 1D array like this one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d785ffa376c738acba9fd3062d7ce8c3507854" translate="yes" xml:space="preserve">
          <source>If you construct an array by passing in your own memory buffer as a parameter, you need to set the array&amp;rsquo;s &lt;code&gt;base&lt;/code&gt; property to ensure the lifetime of the memory buffer is appropriate.</source>
          <target state="translated">如果通过传入自己的内存缓冲区作为参数来构造数组，则需要设置数组的 &lt;code&gt;base&lt;/code&gt; 属性以确保内存缓冲区的生存期合适。</target>
        </trans-unit>
        <trans-unit id="5a09672523495c2e56a3b155436551396bec1686" translate="yes" xml:space="preserve">
          <source>If you created this array &amp;ldquo;a&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ea524f17d30ae2b5b06f8b246da402ecc0aab1" translate="yes" xml:space="preserve">
          <source>If you define &lt;code&gt;__array_ufunc__&lt;/code&gt;:</source>
          <target state="translated">如果定义 &lt;code&gt;__array_ufunc__&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ad02ce8758b2b7ef1353b5d6ceccf301d0d32341" translate="yes" xml:space="preserve">
          <source>If you depend on the current behavior, then we suggest copying the returned array explicitly, i.e., use &lt;code&gt;np.diagonal(a).copy()&lt;/code&gt; instead of just &lt;code&gt;np.diagonal(a)&lt;/code&gt;. This will work with both past and future versions of NumPy.</source>
          <target state="translated">如果依赖当前行为，则建议显式复制返回的数组，即，使用 &lt;code&gt;np.diagonal(a).copy()&lt;/code&gt; 而不是仅使用 &lt;code&gt;np.diagonal(a)&lt;/code&gt; 。这将适用于过去和将来的NumPy版本。</target>
        </trans-unit>
        <trans-unit id="e04ecd6da4be5a785c0ba7636ed164c9197444de" translate="yes" xml:space="preserve">
          <source>If you didn&amp;rsquo;t actually mess up but there are merge conflicts, you need to resolve those. This can be one of the trickier things to get right. For a good description of how to do this, see &lt;a href=&quot;https://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging#Basic-Merge-Conflicts&quot;&gt;this article on merging conflicts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e434a6791515ca1be095b9c944cc43b7244bf754" translate="yes" xml:space="preserve">
          <source>If you do this often, consider making CDN_URL and NPY_WHLS part of your default environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d4a9d3c1a910573f5c99d8162fc661353211a4" translate="yes" xml:space="preserve">
          <source>If you do want to use Fortran ordering realize that there are two approaches to consider: 1) accept that the first index is just not the most rapidly changing in memory and have all your I/O routines reorder your data when going from memory to disk or visa versa, or use numpy&amp;rsquo;s mechanism for mapping the first index to the most rapidly varying data. We recommend the former if possible. The disadvantage of the latter is that many of numpy&amp;rsquo;s functions will yield arrays without Fortran ordering unless you are careful to use the &amp;lsquo;order&amp;rsquo; keyword. Doing this would be highly inconvenient.</source>
          <target state="translated">如果您确实想使用Fortran排序，请意识到有两种方法可供考虑：1）接受第一个索引并不是内存中变化最快的方法，并让所有I / O例程在从内存到磁盘的过程中对数据进行重新排序反之亦然，或者使用numpy的机制将第一个索引映射到变化最快的数据。如果可能，我们建议使用前者。后者的缺点是，除非小心使用'order'关键字，否则许多numpy函数都会产生没有Fortran排序的数组。这样做非常不方便。</target>
        </trans-unit>
        <trans-unit id="e095aad5306acb61c4cd71ef6f17e3d170477a48" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have Python yet, you might want to consider using &lt;a href=&quot;https://www.anaconda.com/&quot;&gt;Anaconda&lt;/a&gt;. It&amp;rsquo;s the easiest way to get started. The good thing about getting this distribution is the fact that you don&amp;rsquo;t need to worry too much about separately installing NumPy or any of the major packages that you&amp;rsquo;ll be using for your data analyses, like pandas, Scikit-Learn, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a32666f1e22aaef44f676905cda497776944f399" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; account, go to the &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; page, and make one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00332ddab35edaceba6aacb138a662dde934bdb6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t write to the array returned by this function, then you can just ignore all of the above.</source>
          <target state="translated">如果您不写此函数返回的数组，则可以忽略以上所有内容。</target>
        </trans-unit>
        <trans-unit id="ddf01261f92656913e0a2ec2a624205e1c2e4b27" translate="yes" xml:space="preserve">
          <source>If you forgot to make a backup branch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe80a2730dc1732963891b3491f20ea69996dc7b" translate="yes" xml:space="preserve">
          <source>If you get a Python error that looks like the following:</source>
          <target state="translated">如果你得到一个类似下面的Python错误。</target>
        </trans-unit>
        <trans-unit id="a53df4d5bfbd08adf0a5725999a9e0795dcb81f8" translate="yes" xml:space="preserve">
          <source>If you have a collection of tests that must be run multiple times with minor variations, it can be helpful to create a base class containing all the common tests, and then create a subclass for each variation. Several examples of this technique exist in NumPy; below are excerpts from one in &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py&quot;&gt;numpy/linalg/tests/test_linalg.py&lt;/a&gt;:</source>
          <target state="translated">如果您有一组测试，这些测试必须在有较小的变体的情况下运行多次，那么创建包含所有通用测试的基类，然后为每个变体创建一个子类将很有帮助。NumPy中存在该技术的几个示例。以下是&lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py&quot;&gt;numpy / linalg / tests / test_linalg.py中的摘录&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="b76d68a8292694b360bf5a2e8b28bbbb6775f004" translate="yes" xml:space="preserve">
          <source>If you have already decided which type of document you want to write, you can check out the following specific guides:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edd73a9e41446ceec5844edddba90601c9a86d6a" translate="yes" xml:space="preserve">
          <source>If you have an array of datetime64 day values, and you want a count of how many of them are valid dates, you can do this:</source>
          <target state="translated">如果你有一个datetime64日值的数组,并且你想统计其中有多少是有效日期,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="afdea327e298d690859d2830125b0506072aa9c8" translate="yes" xml:space="preserve">
          <source>If you have made changes to files that have changed also upstream, this may generate merge conflicts that you need to resolve. See &lt;a href=&quot;#recovering-from-mess-up&quot;&gt;below&lt;/a&gt; for help in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3940d12fada6e74d3a4f390741c7084734cc9f7c" translate="yes" xml:space="preserve">
          <source>If you have worked before with only one- or two-dimensional arrays in NumPy, you might use &lt;a href=&quot;../reference/generated/numpy.dot#numpy.dot&quot;&gt;&lt;code&gt;numpy.dot&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;numpy.matmul&lt;/code&gt;&lt;/a&gt; (or the &lt;code&gt;@&lt;/code&gt; operator) interchangeably. However, for n-dimensional arrays, they work in very different ways. For more details, check the documentation &lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;numpy.matmul&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61245264d3565a00eccec23e4c121348aa40e38c" translate="yes" xml:space="preserve">
          <source>If you index &lt;code&gt;x&lt;/code&gt; at position 1 you get a structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e171dd0ccd0c17916e231c961dda814be7cba5" translate="yes" xml:space="preserve">
          <source>If you just use Cython to compile a standard Python module, then you will get a C extension module that typically runs a bit faster than the equivalent Python module. Further speed increases can be gained by using the &lt;code&gt;cdef&lt;/code&gt; keyword to statically define C variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c28db0c64cef3fce82c680e83d5a3bf5a7d6611" translate="yes" xml:space="preserve">
          <source>If you know you have boolean arguments, you can get away with using NumPy&amp;rsquo;s bitwise operators, but be careful with parentheses, like this: z = (x &amp;gt; 1) &amp;amp; (x &amp;lt; 2). The absence of NumPy operator forms of logical_and and logical_or is an unfortunate consequence of Python&amp;rsquo;s design.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50bdabfd893e921c2545949ea3927871fd9123c" translate="yes" xml:space="preserve">
          <source>If you mess up during a rebase:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5b391b72fd29e26b5330f8bc73fd6e0406a58fe" translate="yes" xml:space="preserve">
          <source>If you need a stricter way to identify a &lt;em&gt;numerical&lt;/em&gt; scalar, use &lt;code&gt;isinstance(x, numbers.Number)&lt;/code&gt;, as that returns &lt;code&gt;False&lt;/code&gt; for most non-numerical elements such as strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b620559920ae0493b1df8c4590d21b79ff5570f" translate="yes" xml:space="preserve">
          <source>If you need to generate a good seed &amp;ldquo;offline&amp;rdquo;, then &lt;code&gt;SeedSequence().entropy&lt;/code&gt; or using &lt;code&gt;secrets.randbits(128)&lt;/code&gt; from the standard library are both convenient ways.</source>
          <target state="translated">如果需要生成良好的&amp;ldquo;离线&amp;rdquo;种子，则使用 &lt;code&gt;SeedSequence().entropy&lt;/code&gt; 或使用标准库中的secrets.randbits &lt;code&gt;secrets.randbits(128)&lt;/code&gt; 都是方便的方法。</target>
        </trans-unit>
        <trans-unit id="9dadc35707bb7693c411ca705b6a79a8fd4bc6a1" translate="yes" xml:space="preserve">
          <source>If you need to generate a plot for your values, it&amp;rsquo;s very simple with &lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd4f29a22f2d83f814cd7d3d9fed381be8da6e41" translate="yes" xml:space="preserve">
          <source>If you notice you messed up after the rebase:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee201455e7a9931a5a44547dd0593d53785f3676" translate="yes" xml:space="preserve">
          <source>If you obtained NumPy via git, get also the git submodules that contain additional parts required for building the documentation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fafc92af92f970e1f9bc871b99562e2a4dcbfd58" translate="yes" xml:space="preserve">
          <source>If you only had $150/month to pay towards the loan, how long would it take to pay-off a loan of $8,000 at 7% annual interest?</source>
          <target state="translated">如果你只有150元/月的贷款,按年息7%计算,需要多长时间才能还清8000元的贷款?</target>
        </trans-unit>
        <trans-unit id="f1851d09e17596b6fef1418fbf6cd4eb3f3c1218" translate="yes" xml:space="preserve">
          <source>If you only want to get the documentation, note that pre-built versions can be found at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba77d4ac4c0346cf08567fdade124408903e3ad" translate="yes" xml:space="preserve">
          <source>If you prefer, you can use your own image as you work through this tutorial. In order to transform your image into a NumPy array that can be manipulated, you can use the &lt;code&gt;imread&lt;/code&gt; function from the &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.html#module-matplotlib.pyplot&quot;&gt;&lt;code&gt;matplotlib.pyplot&lt;/code&gt;&lt;/a&gt; submodule. Alternatively, you can use the &lt;a href=&quot;https://imageio.readthedocs.io/en/stable/userapi.html#imageio.imread&quot;&gt;&lt;code&gt;imageio.imread&lt;/code&gt;&lt;/a&gt; function from the &lt;code&gt;imageio&lt;/code&gt; library. Be aware that if you use your own image, you&amp;rsquo;ll likely need to adapt the steps below. For more information on how images are treated when converted to NumPy arrays, see &lt;a href=&quot;https://scikit-image.org/docs/stable/user_guide/numpy_images.html&quot;&gt;A crash course on NumPy for images&lt;/a&gt; from the &lt;code&gt;scikit-image&lt;/code&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="163df9c9003b7c4450bb235f2c67b2a07c0207a6" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;f2py&lt;/code&gt; with no arguments, and the line &lt;code&gt;numpy Version&lt;/code&gt; at the end matches the NumPy version printed from &lt;code&gt;python -m numpy.f2py&lt;/code&gt;, then you can use the shorter version. If not, or if you cannot run &lt;code&gt;f2py&lt;/code&gt;, you should replace all calls to &lt;code&gt;f2py&lt;/code&gt; here with the longer version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f8a5ed085feb6d7cb818c6bb6a9239c65b61dd" translate="yes" xml:space="preserve">
          <source>If you run into a situation where a function or method is returning a pointer to an array, your best bet is to write your own version of the function to be wrapped, either with &lt;code&gt;%extend&lt;/code&gt; for the case of class methods or &lt;code&gt;%ignore&lt;/code&gt; and &lt;code&gt;%rename&lt;/code&gt; for the case of functions.</source>
          <target state="translated">如果遇到函数或方法返回指向数组的指针的情况，则最好的选择是编写自己要包装的函数版本，对于类方法，使用 &lt;code&gt;%extend&lt;/code&gt; 或 &lt;code&gt;%ignore&lt;/code&gt; 和 &lt;code&gt;%rename&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="2a7a60ee3a192da84e7197524a79fee3ab370312" translate="yes" xml:space="preserve">
          <source>If you see a good tutorial, how-to or explanation that is not included in the official documentation, you can suggest it to be added by &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;opening an issue on GitHub&lt;/a&gt;. Similarly, opening issues to suggest a tutorial, how-to or explanation that you can&amp;rsquo;t find anywhere is a great way to help the documentation team direct efforts towards what users are looking for. &lt;a href=&quot;https://github.com/numpy/numpy/issues/15760&quot;&gt;See this issue&lt;/a&gt; for an example of how to do this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c084a3f2a6106a54039205662cc0565194fa0738" translate="yes" xml:space="preserve">
          <source>If you specify an &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;a&lt;/code&gt; must be zero-padded or truncated, the extra/removed values will be added/removed at high frequencies. One can thus resample a series to &lt;code&gt;m&lt;/code&gt; points via Fourier interpolation by: &lt;code&gt;a_resamp = irfft(rfft(a), m)&lt;/code&gt;.</source>
          <target state="translated">如果您指定一个 &lt;code&gt;n&lt;/code&gt; 使得必须对 &lt;code&gt;a&lt;/code&gt; 进行零填充或截断，那么多余的/已删除的值将在高频下被添加/删除。因此，可以通过以下方式通过傅里叶插值将序列重新采样为 &lt;code&gt;m&lt;/code&gt; 个点： &lt;code&gt;a_resamp = irfft(rfft(a), m)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd256004a74583cc184f8439d5d048c30d412fb7" translate="yes" xml:space="preserve">
          <source>If you start with these arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2448ad4b64da661ec458b63dd3b9923ea02aca5" translate="yes" xml:space="preserve">
          <source>If you start with this array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777d1be2db0dc4450d7b4eef96ddf2f8d5888d83" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend that you put all your override logic in &lt;code&gt;__array_ufunc__&lt;/code&gt; and not also override special methods. This ensures the class hierarchy is determined in only one place rather than separately by the ufunc machinery and by the binary operation rules (which gives preference to special methods of subclasses; the alternative way to enforce a one-place only hierarchy, of setting &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, would seem very unexpected and thus confusing, as then the subclass would not work at all with ufuncs).</source>
          <target state="translated">如果你的子类&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，我们建议您把所有的重写逻辑 &lt;code&gt;__array_ufunc__&lt;/code&gt; ，而不是还覆盖的特殊方法。这确保了类层次结构仅在一个地方确定，而不是由ufunc机制和二进制操作规则（它优先于子类的特殊方法；这是强制实施仅一个地方的层次结构的另一种方法，将&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;设置为&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，这似乎是非常出乎意料的，因此会造成混乱，因为那时子类对ufuncs完全无效。</target>
        </trans-unit>
        <trans-unit id="2b988c177dc2b27c86ba6dc5904e8834a5cbf804" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend that you put all your override logic in &lt;code&gt;__array_ufunc__&lt;/code&gt; and not also override special methods. This ensures the class hierarchy is determined in only one place rather than separately by the ufunc machinery and by the binary operation rules (which gives preference to special methods of subclasses; the alternative way to enforce a one-place only hierarchy, of setting &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; to None, would seem very unexpected and thus confusing, as then the subclass would not work at all with ufuncs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68630e24ebcf26648c6330182b68ffff11c7fe21" translate="yes" xml:space="preserve">
          <source>If you want to allow your new data-type to also be able to share in the scalar coercion rules, then you need to specify the scalarkind function in the data-type object&amp;rsquo;s &amp;ldquo;.f&amp;rdquo; member to return the kind of scalar the new data-type should be seen as (the value of the scalar is available to that function). Then, you can register data-types that can be cast to separately for each scalar kind that may be returned from your user-defined data-type. If you don&amp;rsquo;t register scalar coercion handling, then all of your user-defined data-types will be seen as &lt;a href=&quot;../reference/c-api/array#c.NPY_NOSCALAR&quot;&gt;&lt;code&gt;NPY_NOSCALAR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b381b011cdbc746e6a1a9147256650f6139d3056" translate="yes" xml:space="preserve">
          <source>If you want to be able to run the examples in this tutorial, you should also have &lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt; and &lt;a href=&quot;https://scipy.org&quot;&gt;SciPy&lt;/a&gt; installed on your computer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd528b5e948a367e7029016eb9b4a7e59a0c3cc" translate="yes" xml:space="preserve">
          <source>If you want to check your array, you can run::</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239d78c449f1143da9fe3cab0308bfd5b8c57120" translate="yes" xml:space="preserve">
          <source>If you want to distribute your f2py extension module, then you only need to include the .pyf file and the Fortran code. The distutils extensions in NumPy allow you to define an extension module entirely in terms of this interface file. A valid &lt;code&gt;setup.py&lt;/code&gt; file allowing distribution of the &lt;code&gt;add.f&lt;/code&gt; module (as part of the package &lt;code&gt;f2py_examples&lt;/code&gt; so that it would be loaded as &lt;code&gt;f2py_examples.add&lt;/code&gt;) is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205839ed0e5eb197529b1363e1bb132c099c8dee" translate="yes" xml:space="preserve">
          <source>If you want to edit an array with aligned &lt;code&gt;double&lt;/code&gt; code, but the order doesn&amp;rsquo;t matter, you would use this.</source>
          <target state="translated">如果要使用对齐的 &lt;code&gt;double&lt;/code&gt; 代码编辑数组，但顺序无关紧要，则可以使用它。</target>
        </trans-unit>
        <trans-unit id="354259176d8d4848edf2f2ea177ee9321090388c" translate="yes" xml:space="preserve">
          <source>If you want to generate a list of coordinates where the elements exist, you can zip the arrays, iterate over the list of coordinates, and print them. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09988ae17a5580ba08c41432cf193fcdceccc334" translate="yes" xml:space="preserve">
          <source>If you want to get the unique rows or columns, make sure to pass the &lt;code&gt;axis&lt;/code&gt; argument. To find the unique rows, specify &lt;code&gt;axis=0&lt;/code&gt; and for columns, specify &lt;code&gt;axis=1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a706c6c7d842fe3c84f0f98172224bf53de48486" translate="yes" xml:space="preserve">
          <source>If you want to learn more about C and Fortran order, you can &lt;a href=&quot;../reference/internals#numpy-internals&quot;&gt;read more about the internal organization of NumPy arrays here&lt;/a&gt;. Essentially, C and Fortran orders have to do with how indices correspond to the order the array is stored in memory. In Fortran, when moving through the elements of a two-dimensional array as it is stored in memory, the &lt;strong&gt;first&lt;/strong&gt; index is the most rapidly varying index. As the first index moves to the next row as it changes, the matrix is stored one column at a time. This is why Fortran is thought of as a &lt;strong&gt;Column-major language&lt;/strong&gt;. In C on the other hand, the &lt;strong&gt;last&lt;/strong&gt; index changes the most rapidly. The matrix is stored by rows, making it a &lt;strong&gt;Row-major language&lt;/strong&gt;. What you do for C or Fortran depends on whether it&amp;rsquo;s more important to preserve the indexing convention or not reorder the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90eb7317f80793824fd5ca68d969b076155c2b6b" translate="yes" xml:space="preserve">
          <source>If you want to make use of these extensions in third-party projects, they are available on &lt;a href=&quot;https://pypi.org/&quot;&gt;PyPi&lt;/a&gt; as the &lt;a href=&quot;https://python.org/pypi/numpydoc&quot;&gt;numpydoc&lt;/a&gt; package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce326a8e1b86089803e6e52c507c14343be2d322" translate="yes" xml:space="preserve">
          <source>If you want to print your reversed array, you can run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1156594a53dfa7f56ad636c35e9f1ff1d1bf58" translate="yes" xml:space="preserve">
          <source>If you want to reset both the &lt;code&gt;iterindex&lt;/code&gt; range and the base pointers at the same time, you can do the following to avoid extra buffer copying (be sure to add the return code error checks when you copy this code).</source>
          <target state="translated">如果要同时重置 &lt;code&gt;iterindex&lt;/code&gt; 范围和基指针，则可以执行以下操作以避免额外的缓冲区复制（确保在复制此代码时添加返回代码错误检查）。</target>
        </trans-unit>
        <trans-unit id="64b7d79c9f444db203d014596ebfe464ce993392" translate="yes" xml:space="preserve">
          <source>If you want to select values from your array that fulfill certain conditions, it&amp;rsquo;s straightforward with NumPy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37f52b8408b71a5a1ecc2762c718ea9d22604602" translate="yes" xml:space="preserve">
          <source>If you want to store a single ndarray object, store it as a .npy file using &lt;code&gt;np.save&lt;/code&gt;. If you want to store more than one ndarray object in a single file, save it as a .npz file using &lt;code&gt;np.savez&lt;/code&gt;. You can also save several arrays into a single file in compressed npz format with &lt;a href=&quot;../reference/generated/numpy.savez_compressed#numpy.savez_compressed&quot;&gt;&lt;code&gt;savez_compressed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88094cb7e9cc7094508fd58f64e280384e2b183f" translate="yes" xml:space="preserve">
          <source>If you want to work on some stuff with other people, where you are all committing into the same repository, or even the same branch, then just share it via &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8a79d78dafc5ad7f75ccfea604d3c282656ec2" translate="yes" xml:space="preserve">
          <source>If you wanted to split this array into three equally shaped arrays, you would run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe157cf65afca39aaf28e7392b7bcce12c2fa490" translate="yes" xml:space="preserve">
          <source>If you wanted to split your array after the third and fourth column, you&amp;rsquo;d run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f154266a0558b92de5f9f6ffafaf54fec025441e" translate="yes" xml:space="preserve">
          <source>If you wish to build against OpenBLAS but you also have BLIS available one may predefine the order of searching via the environment variable &lt;code&gt;NPY_BLAS_ORDER&lt;/code&gt; which is a comma-separated list of the above names which is used to determine what to search for, for instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591a2b4b56f13d91fd0f488df05b473dc7163812" translate="yes" xml:space="preserve">
          <source>If you wish to build against OpenBLAS but you also have MKL available one may predefine the order of searching via the environment variable &lt;code&gt;NPY_LAPACK_ORDER&lt;/code&gt; which is a comma-separated list of the above names, for instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05bc8da7a227df06fa8b2e6100a971876a03d9e2" translate="yes" xml:space="preserve">
          <source>If you wish to maintain compatibility with numpy and its subsequent versions (which might add new keyword arguments) but do not want to surface all of numpy&amp;rsquo;s arguments, your function&amp;rsquo;s signature should accept &lt;code&gt;**kwargs&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b99e9167303c0b41027781a2b137980415f644" translate="yes" xml:space="preserve">
          <source>If you wish to work the examples in this tutorial, you must also have some software installed on your computer. Please see &lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https://scipy.org/install.html&lt;/a&gt; for instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7557e5e98e1d6b39d314fab8f9700d862099c3ca" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in learning more about Pandas, take a look at the &lt;a href=&quot;https://pandas.pydata.org/index.html&quot;&gt;official Pandas documentation&lt;/a&gt;. Learn how to install Pandas with the &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/install.html&quot;&gt;official Pandas installation information&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed6aac4fbb9a95f912d9c4a1bba39294044ad2e" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re reading this page, you probably want to help. This guide is meant to help you decide which kind of content you&amp;rsquo;ll write, as well as give you some tips and instructions for submitting it to the official NumPy documentation (that is, the documentation that ships with NumPy and lives on the &lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;official project pages&lt;/a&gt;). Keep in mind that if you don&amp;rsquo;t want to do this, writing a tutorial on your own blog, creating a YouTube video or answering questions on social media or Stack Overflow are also great contributions!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7594579a51a68345b4192c0906de63f2aaa750" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using the command line, you can read your saved CSV any time with a command such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb1dc4c88210c13fc91fb612afbe4d0471d01d47" translate="yes" xml:space="preserve">
          <source>If your change introduces a deprecation, make sure to discuss this first on GitHub or the mailing list first. If agreement on the deprecation is reached, follow &lt;a href=&quot;http://www.numpy.org/neps/nep-0023-backwards-compatibility.html&quot;&gt;NEP 23 deprecation policy&lt;/a&gt; to add the deprecation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383746919525c98ba38f05552e38f10fc7e17a76" translate="yes" xml:space="preserve">
          <source>If your changes involve modifications to the API or addition/modification of a function, you should</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57214d0288965780d58c7b4b54223afc06a658d" translate="yes" xml:space="preserve">
          <source>If your commit introduces a new feature or changes functionality, post on the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-devel&quot;&gt;mailing list&lt;/a&gt; to explain your changes. For bug fixes, documentation updates, etc., this is generally not necessary, though if you do not get any reaction, do feel free to ask for review.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceebca4c980fce897cd94c7ea4093efdb4e34dd2" translate="yes" xml:space="preserve">
          <source>If your goal is to print such values with a fixed number of decimals, it is preferable to use numpy&amp;rsquo;s float printing routines to limit the number of printed decimals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8a3ab9024a9447fbb66b46a34249a781d9bca6" translate="yes" xml:space="preserve">
          <source>If your report involves any members of the committee, or if they feel they have a conflict of interest in handling it, then they will recuse themselves from considering your report. Alternatively, if for any reason you feel uncomfortable making a report to the committee, then you can also contact:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1e83353521c6fb2d9909d1a47041f20fbc218d" translate="yes" xml:space="preserve">
          <source>If, however, you decide to deviate from this signature and do something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c323f3cd6a35ba341fff7e94a4d83cd135d073a2" translate="yes" xml:space="preserve">
          <source>Ignoring extreme values</source>
          <target state="translated">忽略极端值</target>
        </trans-unit>
        <trans-unit id="d887ce439b6be40447269f7cc275bae88c7965c1" translate="yes" xml:space="preserve">
          <source>Illustration image: &lt;a href=&quot;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&quot;&gt;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&lt;/a&gt;</source>
          <target state="translated">插图图片：&lt;a href=&quot;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&quot;&gt;https&lt;/a&gt; : //en.wikipedia.org/wiki/File : Composite_trapezoidal_rule_illustration.png</target>
        </trans-unit>
        <trans-unit id="8dc5a9232d67823e896b05855151653c2378fa30" translate="yes" xml:space="preserve">
          <source>Illustration, using the fact that the eigenvalues of a diagonal matrix are its diagonal elements, that multiplying a matrix on the left by an orthogonal matrix, &lt;code&gt;Q&lt;/code&gt;, and on the right by &lt;code&gt;Q.T&lt;/code&gt; (the transpose of &lt;code&gt;Q&lt;/code&gt;), preserves the eigenvalues of the &amp;ldquo;middle&amp;rdquo; matrix. In other words, if &lt;code&gt;Q&lt;/code&gt; is orthogonal, then &lt;code&gt;Q * A * Q.T&lt;/code&gt; has the same eigenvalues as &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">举例说明，利用对角矩阵的特征值是其对角元素这一事实，将左边的矩阵乘以正交矩阵 &lt;code&gt;Q&lt;/code&gt; ，将右边的矩阵乘以 &lt;code&gt;Q.T&lt;/code&gt; （ &lt;code&gt;Q&lt;/code&gt; 的转置），可以保留&amp;ldquo;中间&amp;rdquo;矩阵。换句话说，如果 &lt;code&gt;Q&lt;/code&gt; 是正交的，则 &lt;code&gt;Q * A * Q.T&lt;/code&gt; 具有与 &lt;code&gt;A&lt;/code&gt; 相同的特征值：</target>
        </trans-unit>
        <trans-unit id="aa91fcf02d0f861f5dcc65de755f413adabac4c5" translate="yes" xml:space="preserve">
          <source>Illustration:</source>
          <target state="translated">Illustration:</target>
        </trans-unit>
        <trans-unit id="50e19fda0d5b4b74a4a1a1d584e56578693a4ea4" translate="yes" xml:space="preserve">
          <source>Image</source>
          <target state="translated">Image</target>
        </trans-unit>
        <trans-unit id="536fc5481730660eaf684050e171a85c03ce521a" translate="yes" xml:space="preserve">
          <source>Image &lt;a href=&quot;#r7aa6c77779c0-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; illustrates trapezoidal rule &amp;ndash; y-axis locations of points will be taken from &lt;code&gt;y&lt;/code&gt; array, by default x-axis distances between points will be 1.0, alternatively they can be provided with &lt;code&gt;x&lt;/code&gt; array or with &lt;code&gt;dx&lt;/code&gt; scalar. Return value will be equal to combined area under the red lines.</source>
          <target state="translated">图像&lt;a href=&quot;#r7aa6c77779c0-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;说明了梯形法则&amp;ndash;点的y轴位置将从 &lt;code&gt;y&lt;/code&gt; 数组中获取，默认情况下，点之间的x轴距离为1.0，或者可以为它们提供 &lt;code&gt;x&lt;/code&gt; 数组或 &lt;code&gt;dx&lt;/code&gt; 标量。返回值将等于红线下方的总面积。</target>
        </trans-unit>
        <trans-unit id="a9fdbeb05caca869c7ab036893a4d3951315842f" translate="yes" xml:space="preserve">
          <source>Image filter in Cython</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e3e609852befab966299ce3a62b4f677877a107" translate="yes" xml:space="preserve">
          <source>Images are allowed, but should not be central to the explanation; users viewing the docstring as text must be able to comprehend its meaning without resorting to an image viewer. These additional illustrations are included using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4796b475dca83b62f81a07c968464a3ec0ce36b3" translate="yes" xml:space="preserve">
          <source>Imagine a series of commits A, B, C, D&amp;hellip; Imagine that there are two branches, &lt;em&gt;topic&lt;/em&gt; and &lt;em&gt;master&lt;/em&gt;. You branched &lt;em&gt;topic&lt;/em&gt; off &lt;em&gt;master&lt;/em&gt; when &lt;em&gt;master&lt;/em&gt; was at commit &amp;lsquo;E&amp;rsquo;. The graph of the commits looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1a70afdce8219e6a6ff23faf95244260258e23" translate="yes" xml:space="preserve">
          <source>Imagine an array of 32-bit integers (each 4 bytes):</source>
          <target state="translated">想象一个32位整数的数组(每个4个字节)。</target>
        </trans-unit>
        <trans-unit id="56024d919b5d6ee0185b1f966812231e966a9f22" translate="yes" xml:space="preserve">
          <source>Immediately disconnect the originator from all NumPy communication channels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">实施细节</target>
        </trans-unit>
        <trans-unit id="c12c46e2305d0716b258ac51f2e79f55da8c1069" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;__array_function__&lt;/code&gt; indicate that they can handle the operation by returning any value other than &lt;code&gt;NotImplemented&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__array_function__&lt;/code&gt; 的实现指示它们可以通过返回 &lt;code&gt;NotImplemented&lt;/code&gt; 以外的任何值来处理该操作。</target>
        </trans-unit>
        <trans-unit id="45682c285dcaa4b3e31e357f40fa088a415ce505" translate="yes" xml:space="preserve">
          <source>Implementing this formula is simple and straightforward in NumPy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e028e89dfea3c1cba7d9fc7a23453fc7abac732" translate="yes" xml:space="preserve">
          <source>Implements exec_command function that is (almost) equivalent to commands.getstatusoutput function but on NT, DOS systems the returned status is actually correct (though, the returned status values may be different by a factor). In addition, exec_command takes keyword arguments for (re-)defining environment variables.</source>
          <target state="translated">实现exec_command函数,(几乎)等同于command.getstatusoutput函数,但在NT、DOS系统上,返回的状态实际上是正确的(虽然,返回的状态值可能会有一定的差异)。此外,exec_command还接受关键字参数,用于(重新)定义环境变量。</target>
        </trans-unit>
        <trans-unit id="b794a9ed38f8d441574ce1ea158c0a341f3db730" translate="yes" xml:space="preserve">
          <source>Implements the complex comparisons between two complex numbers (structures with a real and imag member) using NumPy&amp;rsquo;s definition of the ordering which is lexicographic: comparing the real parts first and then the complex parts if the real parts are equal.</source>
          <target state="translated">使用字典顺序的NumPy定义在两个复数（带有实成员和imag成员的结构）之间进行复杂比较：如果实部分相等，则先比较实部分，然后比较复杂部分。</target>
        </trans-unit>
        <trans-unit id="8c1ede9f9fcf093439f0e008232b895dda53883b" translate="yes" xml:space="preserve">
          <source>Implements the rules for scalar coercion. Scalars are only silently coerced from thistype to neededtype if this function returns nonzero. If scalar is &lt;a href=&quot;#c.NPY_NOSCALAR&quot;&gt;&lt;code&gt;NPY_NOSCALAR&lt;/code&gt;&lt;/a&gt;, then this function is equivalent to &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt;&lt;code&gt;PyArray_CanCastSafely&lt;/code&gt;&lt;/a&gt;. The rule is that scalars of the same KIND can be coerced into arrays of the same KIND. This rule means that high-precision scalars will never cause low-precision arrays of the same KIND to be upcast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22af89867a4595ad888fcb4ec7aff9a5775524c5" translate="yes" xml:space="preserve">
          <source>Implements the rules for scalar coercion. Scalars are only silently coerced from thistype to neededtype if this function returns nonzero. If scalar is &lt;code&gt;NPY_NOSCALAR&lt;/code&gt;, then this function is equivalent to &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt;&lt;code&gt;PyArray_CanCastSafely&lt;/code&gt;&lt;/a&gt;. The rule is that scalars of the same KIND can be coerced into arrays of the same KIND. This rule means that high-precision scalars will never cause low-precision arrays of the same KIND to be upcast.</source>
          <target state="translated">实施标量强制的规则。如果此函数返回非零值，则仅将标量从此类型静默转换为需要的类型。如果标量为 &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; ，则此函数等效于&lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt; &lt;code&gt;PyArray_CanCastSafely&lt;/code&gt; &lt;/a&gt;。规则是可以将相同KIND的标量强制转换为相同KIND的数组。该规则意味着高精度标量将永远不会导致相同KIND的低精度数组被泛滥。</target>
        </trans-unit>
        <trans-unit id="cc6b2c01f5b15596a7e379b52c69cde1905611b5" translate="yes" xml:space="preserve">
          <source>Implications for subclassing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1ecf27a94cea1bc5736c0891a645368078e452" translate="yes" xml:space="preserve">
          <source>Implicit rules are used to determine the type specification of a variable (from the first-letter of its name) if the variable is not defined using &lt;code&gt;&amp;lt;variable type declaration&amp;gt;&lt;/code&gt;. Default implicit rule is given by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0951af8ad6c339672abaff4e57cd5d78b54b3d59" translate="yes" xml:space="preserve">
          <source>Import conventions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361838ee748707501d1086cda1d546a0bca541ea" translate="yes" xml:space="preserve">
          <source>ImportError</source>
          <target state="translated">ImportError</target>
        </trans-unit>
        <trans-unit id="2fdd9172a8740a8589e6db75bd8b770e98070548" translate="yes" xml:space="preserve">
          <source>Importing and exporting a CSV</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b02515f5c051785b53791b2ce9293238d373b1" translate="yes" xml:space="preserve">
          <source>Importing data with &lt;code&gt;genfromtxt&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce37d23b2e6f8bbdca3d0d3d416305b155ec2af" translate="yes" xml:space="preserve">
          <source>Importing data with genfromtxt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c27d990de6ba5889ef7140c6c7a668ba89dfd7cb" translate="yes" xml:space="preserve">
          <source>Importing the API</source>
          <target state="translated">导入API</target>
        </trans-unit>
        <trans-unit id="dd37ac12c1ad8599b8ebf308693dc3e055ea4be3" translate="yes" xml:space="preserve">
          <source>Improve detection of CPU features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf92b1447d3f56d21aa04032c4a2bb6319ee3e3" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;numpy.pad&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1f2a7f430fee41352adede4b4563f47e652af5" translate="yes" xml:space="preserve">
          <source>Improved automated bin estimators for &lt;code&gt;histogram&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1f0700651c0f4723ea34b9b380874940d8f5904" translate="yes" xml:space="preserve">
          <source>Improved conversion from ctypes objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="518dff1009456384a218feffc1efa6923feaa474" translate="yes" xml:space="preserve">
          <source>Improved handling of zero-width string/unicode dtypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ab9853fb47f5464aeb249a62f870635c06737e" translate="yes" xml:space="preserve">
          <source>Improved precision of &lt;code&gt;ndarray.mean&lt;/code&gt; for float16 arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38934ca4956698ef07754fc3267371731cc1f9a9" translate="yes" xml:space="preserve">
          <source>Improved set operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df66ef4f9fec541e48971fe99984a92ee3d241bf" translate="yes" xml:space="preserve">
          <source>Improvements</source>
          <target state="translated">Improvements</target>
        </trans-unit>
        <trans-unit id="75cb8c222cfbf4c46e4378aa465749528ac0f696" translate="yes" xml:space="preserve">
          <source>Improvements to build warnings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21535b2ca395b919fe7ab1e068c3e3d0e600eb23" translate="yes" xml:space="preserve">
          <source>Improving the basic interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="651ad1981d9513aaa48106696e9dc28fdbdbb95a" translate="yes" xml:space="preserve">
          <source>In &amp;lsquo;clip&amp;rsquo; mode, a negative index which would normally wrap will clip to 0 instead.</source>
          <target state="translated">在&amp;ldquo;剪辑&amp;rdquo;模式下，通常会自动换行的负索引将改为剪辑为0。</target>
        </trans-unit>
        <trans-unit id="0a5b493d076f809b633ada78947b9be3536bf476" translate="yes" xml:space="preserve">
          <source>In 1.16 a number of functions have been introduced in the &lt;a href=&quot;#module-numpy.lib.recfunctions&quot;&gt;&lt;code&gt;numpy.lib.recfunctions&lt;/code&gt;&lt;/a&gt; module to help users account for this change. These are &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.lib.recfunctions.structured_to_unstructured&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.structured_to_unstructured&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.lib.recfunctions.unstructured_to_structured&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.unstructured_to_structured&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.lib.recfunctions.apply_along_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.apply_along_fields&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.lib.recfunctions.assign_fields_by_name&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.assign_fields_by_name&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#numpy.lib.recfunctions.require_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.require_fields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa6844c3d81a6fe2067c8e0e928cef4f2f272dc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;range(6)&lt;/code&gt;, information on what kind of rounding is done in addition, and on how underflow is handled.</source>
          <target state="translated">在 &lt;code&gt;range(6)&lt;/code&gt; 中，此外还提供有关如何进行四舍五入以及如何处理下溢的信息。</target>
        </trans-unit>
        <trans-unit id="50fbd12243b4769e24084faa8adf2287f6b3d6cd" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;explicit mode&lt;/em&gt; the output can be directly controlled by specifying output subscript labels. This requires the identifier &amp;lsquo;-&amp;gt;&amp;rsquo; as well as the list of output subscript labels. This feature increases the flexibility of the function since summing can be disabled or forced when required. The call &lt;code&gt;np.einsum('i-&amp;gt;', a)&lt;/code&gt; is like &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;np.sum(a, axis=-1)&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; is like &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;np.diag(a)&lt;/code&gt;&lt;/a&gt;. The difference is that &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; does not allow broadcasting by default. Additionally &lt;code&gt;np.einsum('ij,jh-&amp;gt;ih', a, b)&lt;/code&gt; directly specifies the order of the output subscript labels and therefore returns matrix multiplication, unlike the example above in implicit mode.</source>
          <target state="translated">在&lt;em&gt;显式模式下&lt;/em&gt;，可以通过指定输出下标标签直接控制输出。这需要标识符&amp;ldquo;-&amp;gt;&amp;rdquo;以及输出下标标签的列表。此功能增加了功能的灵活性，因为可以在需要时禁用或强制求和。调用 &lt;code&gt;np.einsum('i-&amp;gt;', a)&lt;/code&gt; 就像&lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;np.sum(a, axis=-1)&lt;/code&gt; &lt;/a&gt;，而 &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; 就像&lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;np.diag(a)&lt;/code&gt; &lt;/a&gt;。区别在于&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;默认情况下不允许广播。另外，与上面的隐式模式示例不同 &lt;code&gt;np.einsum('ij,jh-&amp;gt;ih', a, b)&lt;/code&gt; 直接指定输出下标标签的顺序，因此返回矩阵乘法。</target>
        </trans-unit>
        <trans-unit id="c0145016518b0031bebdd7367da2ce7b6495c4d5" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;explicit&lt;/em&gt; mode, &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; provides further flexibility to compute other array operations that might not be considered classical Einstein summation operations, by disabling, or forcing summation over specified subscript labels.</source>
          <target state="translated">在&lt;em&gt;显式&lt;/em&gt;模式下，&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;通过禁用或强制对指定下标标签进行求和，从而提供了更大的灵活性来计算其他数组操作（可能不被视为经典的爱因斯坦求和操作）。</target>
        </trans-unit>
        <trans-unit id="4c8b68052719d1c1d5215bfd711f82950ca7a1df" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;implicit mode&lt;/em&gt;, the chosen subscripts are important since the axes of the output are reordered alphabetically. This means that &lt;code&gt;np.einsum('ij', a)&lt;/code&gt; doesn&amp;rsquo;t affect a 2D array, while &lt;code&gt;np.einsum('ji', a)&lt;/code&gt; takes its transpose. Additionally, &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; returns a matrix multiplication, while, &lt;code&gt;np.einsum('ij,jh', a, b)&lt;/code&gt; returns the transpose of the multiplication since subscript &amp;lsquo;h&amp;rsquo; precedes subscript &amp;lsquo;i&amp;rsquo;.</source>
          <target state="translated">在&lt;em&gt;隐式模式下&lt;/em&gt;，选择的下标很重要，因为输出的轴按字母顺序重新排序。这意味着 &lt;code&gt;np.einsum('ij', a)&lt;/code&gt; 不影响2D数组，而 &lt;code&gt;np.einsum('ji', a)&lt;/code&gt; 进行转置。此外， &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; 返回矩阵乘法，而 &lt;code&gt;np.einsum('ij,jh', a, b)&lt;/code&gt; 返回乘法转置，因为下标'h'在下标之前'一世'。</target>
        </trans-unit>
        <trans-unit id="065543ba7b7c467e5ff1cf1108109daa4f6f9b2e" translate="yes" xml:space="preserve">
          <source>In C, there is no equivalent to the deprecation warnings that Python supports. One way to do deprecations is to flag them in the documentation and release notes, then remove or change the deprecated features in a future major version (NumPy 2.0 and beyond). Minor versions of NumPy should not have major C-API changes, however, that prevent code that worked on a previous minor release. For example, we will do our best to ensure that code that compiled and worked on NumPy 1.4 should continue to work on NumPy 1.7 (but perhaps with compiler warnings).</source>
          <target state="translated">在C语言中,没有与Python支持的recrecation警告相对应的功能。一种方法是在文档和发布说明中标记它们,然后在未来的主要版本中(NumPy 2.0及以后的版本)删除或更改被废弃的特性。然而,NumPy的小版本不应该有重大的C-API变化,这些变化阻止了在以前的小版本上工作的代码。例如,我们会尽最大努力确保在NumPy 1.4上编译和工作的代码在NumPy 1.7上继续工作(但可能会有编译器警告)。</target>
        </trans-unit>
        <trans-unit id="a9ca8be4f66144d7c2dcc488bdd409f6a21dcaf9" translate="yes" xml:space="preserve">
          <source>In IPython it is also possible to run individual examples simply by copy-pasting them in doctest mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="494eed34e26fa744c79b6950c743fa3931771a94" translate="yes" xml:space="preserve">
          <source>In MATLAB&amp;reg; the main tool available to you for customizing the environment is to modify the search path with the locations of your favorite functions. You can put such customizations into a startup script that MATLAB will run on startup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b064c6c8d4ad79dd43510f89eb8bbc99cffd4b" translate="yes" xml:space="preserve">
          <source>In MATLAB&amp;reg;, arrays have pass-by-value semantics, with a lazy copy-on-write scheme to prevent actually creating copies until they are actually needed. Slice operations copy parts of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c279433c70eb2d4b30f568fbc349c5cc15292b" translate="yes" xml:space="preserve">
          <source>In MATLAB&amp;reg;, the basic data type is a multidimensional array of double precision floating point numbers. Most expressions take such arrays and return such arrays. Operations on the 2-D instances of these arrays are designed to act more or less like matrix operations in linear algebra.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7fc4e4e9aaf59319f61cb1b2c8333ad9f8d065b" translate="yes" xml:space="preserve">
          <source>In NumPy 1.16, you need to set the environment variable &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1&lt;/code&gt; before importing NumPy to use NumPy function overrides.</source>
          <target state="translated">在NumPy 1.16中，您需要在导入NumPy以使用NumPy函数替代之前设置环境变量 &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d05b90f328ed41700350ed32107071a1f6f3fbc" translate="yes" xml:space="preserve">
          <source>In NumPy 1.17, the protocol is enabled by default, but can be disabled with &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0&lt;/code&gt;.</source>
          <target state="translated">在NumPy 1.17中，默认情况下启用该协议，但可以使用 &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0&lt;/code&gt; 禁用该协议。</target>
        </trans-unit>
        <trans-unit id="1b4938fa72e1c7213ec03de65817f46747825eb5" translate="yes" xml:space="preserve">
          <source>In NumPy 1.6.0, a type promotion API was created to encapsulate the mechanism for determining output types. See the functions &lt;a href=&quot;generated/numpy.result_type#numpy.result_type&quot;&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">在NumPy 1.6.0中，创建了类型升级API以封装用于确定输出类型的机制。有关更多详细信息，请参见函数&lt;a href=&quot;generated/numpy.result_type#numpy.result_type&quot;&gt; &lt;code&gt;result_type&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;generated/numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6817ac22605fc4c2d0f573a2b14f3a89cb1e8f22" translate="yes" xml:space="preserve">
          <source>In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal, but depending on this fact is deprecated. Writing to the resulting array continues to work as it used to, but a FutureWarning is issued.</source>
          <target state="translated">在NumPy 1.7和1.8中,它继续返回对角线的副本,但根据这一事实,它已被废弃。写入结果的数组继续像以前一样工作,但会发出未来警告。</target>
        </trans-unit>
        <trans-unit id="117fbe2ef07a30dba33092bb43c1ec1f63fe2b7a" translate="yes" xml:space="preserve">
          <source>In NumPy 1.7 and later, this form allows &lt;code&gt;base_dtype&lt;/code&gt; to be interpreted as a structured dtype. Arrays created with this dtype will have underlying dtype &lt;code&gt;base_dtype&lt;/code&gt; but will have fields and flags taken from &lt;code&gt;new_dtype&lt;/code&gt;. This is useful for creating custom structured dtypes, as done in &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record arrays&lt;/a&gt;.</source>
          <target state="translated">在NumPy 1.7和更高版本中，此格式允许将 &lt;code&gt;base_dtype&lt;/code&gt; 解释为结构化dtype。使用此 &lt;code&gt;base_dtype&lt;/code&gt; 创建的数组将具有基础dtype base_dtype，但具有从 &lt;code&gt;new_dtype&lt;/code&gt; 获取的字段和标志。这对于创建自定义结构化dtype很有用，就像在&lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record array中一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11387d0f86941bf54bf7c514e7a5b1f0fd171696" translate="yes" xml:space="preserve">
          <source>In NumPy arrays have pass-by-reference semantics. Slice operations are views into an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0193a49a749beca871335b39ba584f160aa0e7bd" translate="yes" xml:space="preserve">
          <source>In NumPy the basic type is a multidimensional &lt;code&gt;array&lt;/code&gt;. Operations on these arrays in all dimensionalities including 2D are element-wise operations. One needs to use specific functions for linear algebra (though for matrix multiplication, one can use the &lt;code&gt;@&lt;/code&gt; operator in python 3.5 and above).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b53f7eb15b7831e508349b1a60777dcdbd79a0e" translate="yes" xml:space="preserve">
          <source>In NumPy versions &amp;lt;= 1.9.0 Nan is returned for slices that are all-NaN or empty. In later versions zero is returned.</source>
          <target state="translated">在NumPy版本&amp;lt;= 1.9.0中，对于全NaN或空的片返回Nan。在更高版本中，返回零。</target>
        </trans-unit>
        <trans-unit id="36d3e5a6749595663c6dacbe6e7c386adcf1a912" translate="yes" xml:space="preserve">
          <source>In NumPy, dimensions are called &lt;strong&gt;axes&lt;/strong&gt;. This means that if you have a 2D array that looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed78411a5f19815c75577c53c9647b97f455af34" translate="yes" xml:space="preserve">
          <source>In NumPy, there are 24 new fundamental Python types to describe different types of scalars. These type descriptors are mostly based on the types available in the C language that CPython is written in, with several additional types compatible with Python&amp;rsquo;s types.</source>
          <target state="translated">在NumPy中，有24种新的基本Python类型来描述不同类型的标量。这些类型描述符主要基于编写CPython的C语言中可用的类型，以及与Python类型兼容的其他几种类型。</target>
        </trans-unit>
        <trans-unit id="0c775f1e9d60e517f99b3f4fb5fbef2cd48f1233" translate="yes" xml:space="preserve">
          <source>In NumPy, universal functions are instances of the &lt;code&gt;numpy.ufunc&lt;/code&gt; class. Many of the built-in functions are implemented in compiled C code. The basic ufuncs operate on scalars, but there is also a generalized kind for which the basic elements are sub-arrays (vectors, matrices, etc.), and broadcasting is done over other dimensions. One can also produce custom &lt;code&gt;ufunc&lt;/code&gt; instances using the &lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt;&lt;code&gt;frompyfunc&lt;/code&gt;&lt;/a&gt; factory function.</source>
          <target state="translated">在NumPy中，通用函数是 &lt;code&gt;numpy.ufunc&lt;/code&gt; 类的实例。许多内置函数是在已编译的C代码中实现的。基本ufunc在标量上运行，但是也存在一种通用类型，其基本元素是子数组（向量，矩阵等），并且在其他维度上进行广播。你也可以定制生产 &lt;code&gt;ufunc&lt;/code&gt; 使用情况&lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt; &lt;code&gt;frompyfunc&lt;/code&gt; &lt;/a&gt;工厂函数。</target>
        </trans-unit>
        <trans-unit id="774635ebbde845fd67b0f22449de4d887322609c" translate="yes" xml:space="preserve">
          <source>In Numeric, the ancestor of Numpy, broadcasting was implemented in several lines of code buried deep in ufuncobject.c. In NumPy, the notion of broadcasting has been abstracted so that it can be performed in multiple places. Broadcasting is handled by the function &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt;. This function requires a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; (or something that is a binary equivalent) to be passed in. The &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the broadcast number of dimensions and size in each dimension along with the total size of the broadcast result. It also keeps track of the number of arrays being broadcast and a pointer to an iterator for each of the arrays being broadcast.</source>
          <target state="translated">在Numpy的祖先Numeric中，广播是通过深埋在ufuncobject.c中的几行代码实现的。在NumPy中，广播的概念已被抽象化，因此可以在多个地方进行广播。广播由函数&lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt;处理。此函数需要&lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;一个PyArrayMultiIterObject（或等效的二进制文件）&lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;跟踪广播的维数和​​每个维的大小以及广播结果的总大小。它还跟踪正在广播的阵列的数量，以及每个正在广播的阵列的指向迭代器的指针。</target>
        </trans-unit>
        <trans-unit id="8922bb1c700cbaf5cb6e489ccc3a2d78c8e39611" translate="yes" xml:space="preserve">
          <source>In Numeric, the ancestor of Numpy, broadcasting was implemented in several lines of code buried deep in ufuncobject.c. In NumPy, the notion of broadcasting has been abstracted so that it can be performed in multiple places. Broadcasting is handled by the function &lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt;. This function requires a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; (or something that is a binary equivalent) to be passed in. The &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the broadcast number of dimensions and size in each dimension along with the total size of the broadcast result. It also keeps track of the number of arrays being broadcast and a pointer to an iterator for each of the arrays being broadcast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22b48541001b861013a36c818439e26a1074dfe7" translate="yes" xml:space="preserve">
          <source>In Numpy 1.15, indexing an array with a multi-field index returned a copy of the result above, but with fields packed together in memory as if passed through &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b22fd0d42a99bd19673ecd40259cf68612486f3" translate="yes" xml:space="preserve">
          <source>In Python 3.0, &lt;code&gt;//&lt;/code&gt; is the floor division operator and &lt;code&gt;/&lt;/code&gt; the true division operator. The &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; function is equivalent to true division in Python.</source>
          <target state="translated">在Python 3.0中， &lt;code&gt;//&lt;/code&gt; 是下位除法运算符和 &lt;code&gt;/&lt;/code&gt; 是真正的除法运算符。所述 &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; 函数等同于在Python真实划分。</target>
        </trans-unit>
        <trans-unit id="62fa547333a8d1dc9c0d4f4c02b89f627c6e6bc6" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;//&lt;/code&gt; is the floor division operator and &lt;code&gt;/&lt;/code&gt; the true division operator. The &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; function is equivalent to true division in Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ae9f01dfbac70b64c2f45fa3c211ed297fec42" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;arr[i, j]&lt;/code&gt; is exactly the same as &lt;code&gt;arr[(i, j)]&lt;/code&gt;&amp;mdash;so we can put &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; in a &lt;code&gt;tuple&lt;/code&gt; and then do the indexing with that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060ed7eb6876dfc9a447b37757dfa0a45bd6069c" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;x[(exp1, exp2, ..., expN)]&lt;/code&gt; is equivalent to &lt;code&gt;x[exp1, exp2, ..., expN]&lt;/code&gt;; the latter is just syntactic sugar for the former.</source>
          <target state="translated">在Python中， &lt;code&gt;x[(exp1, exp2, ..., expN)]&lt;/code&gt; 等效于 &lt;code&gt;x[exp1, exp2, ..., expN]&lt;/code&gt; ; 后者只是前者的语法糖。</target>
        </trans-unit>
        <trans-unit id="667b044648896477b62af8727dbe5136eaaff74b" translate="yes" xml:space="preserve">
          <source>In Python:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269b609eb84c47b360c36d70b62b2cd1bb86a5a5" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, each sub-type is called a &lt;code&gt;field&lt;/code&gt;. The &lt;code&gt;field&lt;/code&gt; has a name (a string), a type (any valid dtype), and an optional &lt;code&gt;title&lt;/code&gt;. See &lt;a href=&quot;reference/arrays.dtypes#arrays-dtypes&quot;&gt;Data type objects (dtype)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2721403cc827c0b84ea65a28ef2dffa50ceb53e2" translate="yes" xml:space="preserve">
          <source>In a nutshell, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; runs two main loops. The first loop converts each line of the file in a sequence of strings. The second loop converts each string to the appropriate data type. This mechanism is slower than a single loop, but gives more flexibility. In particular, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; is able to take missing data into account, when other faster and simpler functions like &lt;a href=&quot;../reference/generated/numpy.loadtxt#numpy.loadtxt&quot;&gt;&lt;code&gt;loadtxt&lt;/code&gt;&lt;/a&gt; cannot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0643c04fa6f173d8a3f9cc4f3ce84f7f07625090" translate="yes" xml:space="preserve">
          <source>In a study, testing for a specific alternative to the null hypothesis requires use of the Noncentral F distribution. We need to calculate the area in the tail of the distribution that exceeds the value of the F distribution for the null hypothesis. We&amp;rsquo;ll plot the two probability distributions for comparison.</source>
          <target state="translated">在一项研究中，测试零假设的特定替代方法需要使用非中心F分布。我们需要为零假设计算分布尾部中超过F分布值的面积。我们将绘制两个概率分布以进行比较。</target>
        </trans-unit>
        <trans-unit id="4a555d5f0fdb6581c9697563824e3d61c23e3de4" translate="yes" xml:space="preserve">
          <source>In a two&amp;rsquo;s-complement system negative numbers are represented by the two&amp;rsquo;s complement of the absolute value. This is the most common method of representing signed integers on computers &lt;a href=&quot;#r962252997619-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. A N-bit two&amp;rsquo;s-complement system can represent every integer in the range</source>
          <target state="translated">在二进制补码系统中，负数由绝对值的二进制补码表示。这是在计算机上表示带符号整数的最常见方法&lt;a href=&quot;#r962252997619-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。N位二进制补码系统可以表示范围内的每个整数</target>
        </trans-unit>
        <trans-unit id="6ec708a7d401df6aafb3a323298b5e8a10e70e10" translate="yes" xml:space="preserve">
          <source>In addition &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; may be scalars, in which case:</source>
          <target state="translated">另外， &lt;code&gt;a&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt; 可以是标量，在这种情况下：</target>
        </trans-unit>
        <trans-unit id="85652b9aa303fc72ea7ade73af4f0dda2d5084d0" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;numpy.lib.io&lt;/code&gt; module provides several convenience functions derived from &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;. These functions work the same way as the original, but they have different default values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b2e8925339289db83edc8e4d5703c4e6627acaa" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;__array_wrap__&lt;/code&gt;, which is called on the way out of the ufunc, there is also an &lt;code&gt;__array_prepare__&lt;/code&gt; method which is called on the way into the ufunc, after the output arrays are created but before any computation has been performed. The default implementation does nothing but pass through the array. &lt;code&gt;__array_prepare__&lt;/code&gt; should not attempt to access the array data or resize the array, it is intended for setting the output array type, updating attributes and metadata, and performing any checks based on the input that may be desired before computation begins. Like &lt;code&gt;__array_wrap__&lt;/code&gt;, &lt;code&gt;__array_prepare__&lt;/code&gt; must return an ndarray or subclass thereof or raise an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0202a847e7f1c55dfe19c04653df757ab3188d4f" translate="yes" xml:space="preserve">
          <source>In addition to attributes that can be specified via keyword arguments to &lt;code&gt;Configuration&lt;/code&gt; constructor, &lt;code&gt;Configuration&lt;/code&gt; instance (let us denote as &lt;code&gt;config&lt;/code&gt;) has the following attributes that can be useful in writing setup scripts:</source>
          <target state="translated">除了可以通过 &lt;code&gt;Configuration&lt;/code&gt; 构造函数的关键字参数指定的属性外， &lt;code&gt;Configuration&lt;/code&gt; 实例（让我们表示为 &lt;code&gt;config&lt;/code&gt; ）具有以下属性，这些属性在编写安装脚本时可能会有用：</target>
        </trans-unit>
        <trans-unit id="9205eb129a4d89ef4a9eb5c8d77614ae87b40a33" translate="yes" xml:space="preserve">
          <source>In addition to field names, fields may also have an associated &lt;a href=&quot;../glossary#term-title&quot;&gt;title&lt;/a&gt;, an alternate name, which is sometimes used as an additional description or alias for the field. The title may be used to index an array, just like a field name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee5bd9d7a0e50bb5b466ac30e311415eba3cdbd" translate="yes" xml:space="preserve">
          <source>In addition to field names, structured array fields may have an associated &lt;a href=&quot;user/basics.rec#titles&quot;&gt;title&lt;/a&gt; which is an alias to the name and is commonly used for plotting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8a9cc27249ffd4d0b1366a65411d876d2aa7c5" translate="yes" xml:space="preserve">
          <source>In addition to sort, which returns a sorted copy of an array, you can use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ec49c4a4c9a814e9bec074f3eabcbf7dea786f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; class, the &lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module defines several constants.</source>
          <target state="translated">除了&lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;类之外，&lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt;模块还定义了几个常量。</target>
        </trans-unit>
        <trans-unit id="7b236bba71a2e6d9bbb7e9f54e04010c73fd209b" translate="yes" xml:space="preserve">
          <source>In addition to the Python C-API, there is a full and rich C-API for NumPy allowing sophisticated manipulations on a C-level. However, for most applications, only a few API calls will typically be used. For example, if you need to just extract a pointer to memory along with some shape information to pass to another calculation routine, then you will use very different calls than if you are trying to create a new array-like type or add a new data type for ndarrays. This chapter documents the API calls and macros that are most commonly used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c1e50029232768a84bc4dc52748436e5f14647c" translate="yes" xml:space="preserve">
          <source>In addition, F2PY introduces the following statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f7370be70d6fe0e899df628f5a07f23f4c4044" translate="yes" xml:space="preserve">
          <source>In addition, building the documentation requires the Sphinx extension &lt;code&gt;plot_directive&lt;/code&gt;, which is shipped with &lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;. This Sphinx extension can be installed by installing Matplotlib. You will also need Python&amp;gt;=3.6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ae7a3680f09394c2ee157c2db0452e71e75c1c" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;em&gt;data&lt;/em&gt; is non-NULL, then &lt;em&gt;strides&lt;/em&gt; can also be provided. If &lt;em&gt;strides&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the array strides are computed as C-style contiguous (default) or Fortran-style contiguous (&lt;em&gt;flags&lt;/em&gt; is nonzero for &lt;em&gt;data&lt;/em&gt; = &lt;code&gt;NULL&lt;/code&gt; or &lt;em&gt;flags&lt;/em&gt; &amp;amp; &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; is nonzero non-NULL &lt;em&gt;data&lt;/em&gt;). Any provided &lt;em&gt;dims&lt;/em&gt; and &lt;em&gt;strides&lt;/em&gt; are copied into newly allocated dimension and strides arrays for the new array object.</source>
          <target state="translated">此外，如果&lt;em&gt;数据&lt;/em&gt;为非NULL，则还可以提供&lt;em&gt;跨度&lt;/em&gt;。如果&lt;em&gt;strides&lt;/em&gt;为 &lt;code&gt;NULL&lt;/code&gt; ，则将数组的步长计算为C风格的连续（默认）或Fortran风格的连续（&lt;em&gt;数据的&lt;/em&gt;&lt;em&gt;标志&lt;/em&gt;为非零= &lt;code&gt;NULL&lt;/code&gt; 或&lt;em&gt;标志&lt;/em&gt;＆&lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;为非零的非NULL &lt;em&gt;数据&lt;/em&gt;）。提供的所有&lt;em&gt;暗淡&lt;/em&gt;和&lt;em&gt;步幅&lt;/em&gt;都将复制到新分配的维度和步幅数组中，以用于新的数组对象。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="176596f4a4076180f296c1297a5a4088a9dfbec9" translate="yes" xml:space="preserve">
          <source>In all the cases but the first one, the output will be a 1D array with a structured dtype. This dtype has as many fields as items in the sequence. The field names are defined with the &lt;code&gt;names&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d28ba92ccb218b4c16f2db7077723c632363102" translate="yes" xml:space="preserve">
          <source>In all the examples so far, the elements of &lt;code&gt;a&lt;/code&gt; are provided by the iterator one at a time, because all the looping logic is internal to the iterator. While this is simple and convenient, it is not very efficient. A better approach is to move the one-dimensional innermost loop into your code, external to the iterator. This way, NumPy&amp;rsquo;s vectorized operations can be used on larger chunks of the elements being visited.</source>
          <target state="translated">到目前为止的所有示例中，a的元素 &lt;code&gt;a&lt;/code&gt; 都由迭代器提供，因为所有循环逻辑都在迭代器内部。尽管这既简单又方便，但是效率不是很高。更好的方法是将一维最内层循环移到代码中，位于迭代器外部。这样，NumPy的矢量化操作可用于要访问的元素的较大块。</target>
        </trans-unit>
        <trans-unit id="8389ffaf8c2e94e518381d310c79dd3ec1608070" translate="yes" xml:space="preserve">
          <source>In almost all cases &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; should be used instead of this function, as that will also return true for 0d arrays. This is how numpy overloads functions in the style of the &lt;code&gt;dx&lt;/code&gt; arguments to &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt;&lt;code&gt;gradient&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;bins&lt;/code&gt; argument to &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;. Some key differences:</source>
          <target state="translated">在几乎所有情况下，应使用 &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; 代替此函数，因为对于0d数组，该函数也将返回true。这就是numpy重载如何以 &lt;code&gt;dx&lt;/code&gt; 参数的形式&lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt; &lt;code&gt;gradient&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;bins&lt;/code&gt; 参数的&lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt;。一些主要区别：</target>
        </trans-unit>
        <trans-unit id="09406f1061497030999a27047c2ac1dba1e1fddd" translate="yes" xml:space="preserve">
          <source>In both cases, set the &lt;code&gt;BUILD_COMMIT&lt;/code&gt; variable to the current release tag - e.g. &lt;code&gt;v1.19.0&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e277da1826bb81328288e7b48e1bc36cb3d9f8b" translate="yes" xml:space="preserve">
          <source>In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence are returned.</source>
          <target state="translated">如果最大值多次出现,则返回第一次出现的指数。</target>
        </trans-unit>
        <trans-unit id="27e7146cba1027fb05de967eb96a8d0d4f3188c0" translate="yes" xml:space="preserve">
          <source>In case of multiple occurrences of the minimum values, the indices corresponding to the first occurrence are returned.</source>
          <target state="translated">如果最小值出现多次,则返回第一次出现的指数。</target>
        </trans-unit>
        <trans-unit id="e0a4f4799ebef164e20467e93383e4d4633f2709" translate="yes" xml:space="preserve">
          <source>In case of severe and obvious breaches, e.g. personal threat or violent, sexist or racist language, we will immediately disconnect the originator from NumPy communication channels; please see the manual for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3b7f089e082a13dedd4fd05f16654244713a03" translate="yes" xml:space="preserve">
          <source>In cases not involving clear severe and obvious breaches of this code of conduct, the process for acting on any received code of conduct violation report will be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7695ef954df8bd205d22a810fa2781d2a8a8dfc" translate="yes" xml:space="preserve">
          <source>In certain cases a failed installation or setup issue can cause you to see the following error message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77e954d7daee979232398ad08ec5cc70a6a273a6" translate="yes" xml:space="preserve">
          <source>In code, arrays are often conveniently expressed as nested lists:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38db33a30014f091c11009d703bc2b8cd0eeadd" translate="yes" xml:space="preserve">
          <source>In complex cases, &lt;a href=&quot;../reference/generated/numpy.r_#numpy.r_&quot;&gt;&lt;code&gt;r_&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.c_#numpy.c_&quot;&gt;&lt;code&gt;c_&lt;/code&gt;&lt;/a&gt; are useful for creating arrays by stacking numbers along one axis. They allow the use of range literals (&amp;ldquo;:&amp;rdquo;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15906ca68f2a7d7e2f6c027ec51f5d69dd3bed29" translate="yes" xml:space="preserve">
          <source>In copying mode, &amp;lsquo;copy&amp;rsquo; is specified as a per-operand flag. This is done to provide control in a per-operand fashion. Buffering mode is specified as an iterator flag.</source>
          <target state="translated">在复制模式下，&amp;ldquo; copy&amp;rdquo;被​​指定为每个操作数标志。这样做是为了以每个操作数的方式提供控制。缓冲模式被指定为迭代器标志。</target>
        </trans-unit>
        <trans-unit id="d217a2b2edd5733cc1a08fd36e52adeffd147a5f" translate="yes" xml:space="preserve">
          <source>In ctypes, the return-value of a function is set to be &amp;lsquo;int&amp;rsquo; by default. This behavior can be changed by setting the restype attribute of the function. Use None for the restype if the function has no return value (&amp;lsquo;void&amp;rsquo;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20601c7341dfe87ba7a45fcff8c92729cd267fbb" translate="yes" xml:space="preserve">
          <source>In depth explanation of concepts, best practices and techniques</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2913833b48b2894352d88e1660f11e59aa09d3c6" translate="yes" xml:space="preserve">
          <source>In detail</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18557e967a450637ab72e77508fbfb08c6b092fc" translate="yes" xml:space="preserve">
          <source>In effect, the slice and index array operation are independent. The slice operation extracts columns with index 1 and 2, (i.e. the 2nd and 3rd columns), followed by the index array operation which extracts rows with index 0, 2 and 4 (i.e the first, third and fifth rows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0401f70e9e9ccb692db031dd68efec8a8e548588" translate="yes" xml:space="preserve">
          <source>In every case, the &amp;lsquo;descr&amp;rsquo; key is optional, but of course provides more information which may be important for various applications:</source>
          <target state="translated">在每种情况下，&amp;ldquo; descr&amp;rdquo;键都是可选的，但是当然会提供更多信息，这些信息对于各种应用程序可能很重要：</target>
        </trans-unit>
        <trans-unit id="ed0824a3a5c26008c8df28fe72abd00f4b7f2a94" translate="yes" xml:space="preserve">
          <source>In every case, the moderator should make a reasonable effort to contact the originator, and tell them specifically how their language or actions qualify as a &amp;ldquo;clear and severe breach&amp;rdquo;. The moderator should also say that, if the originator believes this is unfair or they want to be reconnected to NumPy, they have the right to ask for a review, as below, by the Code of Conduct Committee. The moderator should copy this explanation to the Code of Conduct Committee.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eac15d5d1d96d05ac021a41eb29548e9ee61a69" translate="yes" xml:space="preserve">
          <source>In fact, why don&amp;rsquo;t we try that?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a50f2ab9bd768752351c518eb56b5f190e77022a" translate="yes" xml:space="preserve">
          <source>In general how to set and check your environment variables depends on your system. If you can open a correct python shell, you can also run the following in python:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51a2782158f2135b3873b2bc91584160c3224ec1" translate="yes" xml:space="preserve">
          <source>In general if an index includes a Boolean array, the result will be identical to inserting &lt;code&gt;obj.nonzero()&lt;/code&gt; into the same position and using the integer array indexing mechanism described above. &lt;code&gt;x[ind_1, boolean_array, ind_2]&lt;/code&gt; is equivalent to &lt;code&gt;x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]&lt;/code&gt;.</source>
          <target state="translated">通常，如果索引包含布尔数组，则结果将与将 &lt;code&gt;obj.nonzero()&lt;/code&gt; 插入相同位置并使用上述整数数组索引机制相同。 &lt;code&gt;x[ind_1, boolean_array, ind_2]&lt;/code&gt; 等效于 &lt;code&gt;x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0426d4d5e9174343610861881dfacd8c07a4e5a" translate="yes" xml:space="preserve">
          <source>In general, a scalar argument of a F2PY generated wrapper function can be an ordinary Python scalar (integer, float, complex number) as well as an arbitrary sequence object (list, tuple, array, string) of scalars. In the latter case, the first element of the sequence object is passed to Fortran routine as a scalar argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b09ab4340a010ae2242f6c23854be608350193" translate="yes" xml:space="preserve">
          <source>In general, array arguments of F2PY generated wrapper functions accept arbitrary sequences that can be transformed to NumPy array objects. An exception is &lt;code&gt;intent(inout)&lt;/code&gt; array arguments that always must be proper-contiguous and have proper type, otherwise an exception is raised. Another exception is &lt;code&gt;intent(inplace)&lt;/code&gt; array arguments that attributes will be changed &lt;em&gt;in situ&lt;/em&gt; if the argument has different type than expected (see &lt;code&gt;intent(inplace)&lt;/code&gt; attribute for more information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9f087f4c4d9805ec9d46a8db9fd36d60eeb431" translate="yes" xml:space="preserve">
          <source>In general, for &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">一般而言，对于 &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4732749a65786e199f581dd65439c32d67356e7" translate="yes" xml:space="preserve">
          <source>In general, for arrays with more than two dimensions, &lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt; stacks along their second axes, &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt; stacks along their first axes, and &lt;a href=&quot;../reference/generated/numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt; allows for an optional arguments giving the number of the axis along which the concatenation should happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31150963fe6ef250ba4e833d06b222cca1c2cb70" translate="yes" xml:space="preserve">
          <source>In general, if a NumPy array is proper-contiguous and has a proper type then it is directly passed to wrapped Fortran/C function. Otherwise, an element-wise copy of an input array is made and the copy, being proper-contiguous and with proper type, is used as an array argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ea723c2a24ed6ef1771c5f258ea31816238b49" translate="yes" xml:space="preserve">
          <source>In general, if the array owns its own memory, as for &lt;code&gt;arr&lt;/code&gt; in this case, then &lt;code&gt;arr.base&lt;/code&gt; will be None - there are some exceptions to this - see the numpy book for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abc873332e6b6be31064612f2de6812b8a80d3b" translate="yes" xml:space="preserve">
          <source>In general, it is not necessary to list class methods. Those that are not part of the public API have names that start with an underscore. In some cases, however, a class may have a great many methods, of which only a few are relevant (e.g., subclasses of ndarray). Then, it becomes useful to have an additional &lt;strong&gt;Methods&lt;/strong&gt; section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcbe439e71ce76a6bc1cdecd65ffad854f695844" translate="yes" xml:space="preserve">
          <source>In general, numerical data arranged in an array-like structure in Python can be converted to arrays through the use of the array() function. The most obvious examples are lists and tuples. See the documentation for array() for details for its use. Some objects may support the array-protocol and allow conversion to arrays this way. A simple way to find out if the object can be converted to a numpy array using array() is simply to try it interactively and see if it works! (The Python Way).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2636b2d2555459756347b2bec78d067967d80c45" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one C-series by another results in quotient and remainder terms that are not in the Chebyshev polynomial basis set. Thus, to express these results as C-series, it is typically necessary to &amp;ldquo;reproject&amp;rdquo; the results onto said basis set, which typically produces &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">通常，一个C系列除以（多项式）所得的商和余项不在Chebyshev多项式基集中。因此，为了将这些结果表示为C系列，通常需要将结果&amp;ldquo;重新投影&amp;rdquo;到所述基集上，该基集通常会产生&amp;ldquo;不直观&amp;rdquo;（但正确）的结果。请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="e3455fcce926f7a356d4db4cbb1cca4337cab9da" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Hermite series by another results in quotient and remainder terms that are not in the Hermite polynomial basis set. Thus, to express these results as a Hermite series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Hermite basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">通常，一个Hermite级数的（多项式）除法会导致商和余数项不在Hermite多项式基集中。因此，要将这些结果表示为Hermite系列，有必要将结果&amp;ldquo;重新投影&amp;rdquo;到Hermite基础集上，这可能会产生&amp;ldquo;不直观&amp;rdquo;（但正确）的结果；请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="efbd236c04665a122a8e3491beed41d349724880" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Laguerre series by another results in quotient and remainder terms that are not in the Laguerre polynomial basis set. Thus, to express these results as a Laguerre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Laguerre basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">通常，一个Laguerre级数的（多项式）除法会导致商和余项项不在Laguerre多项式基集中。因此，要将这些结果表示为Laguerre级数，必须将结果&amp;ldquo;重新投影&amp;rdquo;到Laguerre基集上，这可能会产生&amp;ldquo;不直观&amp;rdquo;（但正确）的结果；请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="3e8f9ae8eb5287a2e2ca75de1027864d1ea7dce3" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Legendre series by another results in quotient and remainder terms that are not in the Legendre polynomial basis set. Thus, to express these results as a Legendre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Legendre basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">通常，一个勒让德系列的（多项式）除法会导致商和余项不在勒让德多项式基集中。因此，要将这些结果表示为Legendre系列，有必要将结果&amp;ldquo;重新投影&amp;rdquo;到Legendre基集上，这可能会产生&amp;ldquo;不直观&amp;rdquo;（但正确）的结果。请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="747e8b05b6e447bd7c26bc6951f1c707ad59f09d" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Chebyshev polynomial basis set. Thus, to express the product as a C-series, it is typically necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which typically produces &amp;ldquo;unintuitive live&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">通常，两个C系列的（多项式）乘积的结果不在Chebyshev多项式基集中。因此，为了将产品表示为C系列，通常需要将产品&amp;ldquo;重新投影&amp;rdquo;到所述基集上，这通常会产生&amp;ldquo;不直观的实时&amp;rdquo;（但正确的）结果；请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="140624c01263c11121eb8733a7573189c8b35148" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Hermite polynomial basis set. Thus, to express the product as a Hermite series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">通常，两个C系列的（多项式）乘积的结果不在Hermite多项式基集中。因此，要将产品表示为Hermite系列，有必要将产品&amp;ldquo;重新投影&amp;rdquo;到所述基集上，这可能会产生&amp;ldquo;不直观&amp;rdquo;（但正确）的结果；请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="4be0c1b381e26e882c60023195f1e89d336414ac" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Laguerre polynomial basis set. Thus, to express the product as a Laguerre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">通常，两个C系列的（多项式）乘积的结果不在Laguerre多项式基集中。因此，要将产品表示为Laguerre系列，有必要将产品&amp;ldquo;重新投影&amp;rdquo;到所述基集上，这可能会产生&amp;ldquo;不直观&amp;rdquo;（但正确）的结果。请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="54659a570a760a1d9fe356eba1a0141427eabe1f" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Legendre polynomial basis set. Thus, to express the product as a Legendre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">通常，两个C系列的（多项式）乘积的结果不在勒让德多项式基集中。因此，要将产品表示为Legendre系列，有必要将产品&amp;ldquo;重新投影&amp;rdquo;到所述基础集上，这可能会产生&amp;ldquo;不直观&amp;rdquo;（但正确）的结果；请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="afe18211391947a00635543978b5840ef054bbac" translate="yes" xml:space="preserve">
          <source>In general, the contents of signature files is case-sensitive. When scanning Fortran codes and writing a signature file, F2PY lowers all cases automatically except in multiline blocks or when &lt;code&gt;--no-lower&lt;/code&gt; option is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de938489906c2e0d2c954a8201ef415c1aa719ca" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a C-series needs to be &amp;ldquo;reprojected&amp;rdquo; onto the C-series basis set. Thus, typically, the result of this function is &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">通常，区分C系列的结果需要&amp;ldquo;重新投影&amp;rdquo;到C系列基础集上。因此，通常，此功能的结果是&amp;ldquo;不直观的&amp;rdquo;，尽管是正确的。请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="dc47191395ffa64cfa2441fe3b165eeaca46d090" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Hermite series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">通常，区分Hermite级数的结果与幂级数的运算不同。因此，此功能的结果可能是&amp;ldquo;不直观的&amp;rdquo;，尽管是正确的。请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="c6b49ce2210116245bad6e5bb6d187bba65b38de" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Laguerre series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">通常，对Laguerre序列求微的结果与幂级数的运算不同。因此，此功能的结果可能是&amp;ldquo;不直观的&amp;rdquo;，尽管是正确的。请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="68d490300c846fea9862fc337043383e53cf549a" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Legendre series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">通常，区分Legendre系列的结果与幂级数的运算不同。因此，此功能的结果可能是&amp;ldquo;不直观的&amp;rdquo;，尽管是正确的。请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="ebd1b8db4b2a00ae669c478fea3d4050ecbe0184" translate="yes" xml:space="preserve">
          <source>In general, the shape of the resultant array will be the concatenation of the shape of the index array (or the shape that all the index arrays were broadcast to) with the shape of any unused dimensions (those not indexed) in the array being indexed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5de4ef25adb6cfc3610a2fc23a9d5023b6dda95" translate="yes" xml:space="preserve">
          <source>In general, when the boolean array has fewer dimensions than the array being indexed, this is equivalent to y[b, &amp;hellip;], which means y is indexed by b followed by as many : as are needed to fill out the rank of y. Thus the shape of the result is one dimension containing the number of True elements of the boolean array, followed by the remaining dimensions of the array being indexed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a094c205647147c910d02f3a8f4ccd59ee07b5bd" translate="yes" xml:space="preserve">
          <source>In general, you should target these typemap signatures specifically where you want them, and then clear them after you are done.</source>
          <target state="translated">一般来说,你应该专门针对这些类型地图签名的位置,然后在你完成后清除它们。</target>
        </trans-unit>
        <trans-unit id="dd3e08bc1a57887f18c581f1dbde91b2bd716911" translate="yes" xml:space="preserve">
          <source>In higher dimensions, FFTs are used, e.g., for image analysis and filtering. The computational efficiency of the FFT means that it can also be a faster way to compute large convolutions, using the property that a convolution in the time domain is equivalent to a point-by-point multiplication in the frequency domain.</source>
          <target state="translated">在更高的维度上,FFT被用于,例如,图像分析和滤波。FFT的计算效率意味着它也可以是一种更快的计算大卷积的方法,利用时域的卷积相当于频域的逐点乘法的特性。</target>
        </trans-unit>
        <trans-unit id="b07ddb1ceb7095c96bdb1f519b0d36703eda5462" translate="yes" xml:space="preserve">
          <source>In interactions between &lt;code&gt;ArrayLike&lt;/code&gt; objects and numbers or numpy arrays, the result is always another &lt;code&gt;ArrayLike&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;ArrayLike&lt;/code&gt; 对象与数字或numpy数组之间的交互中，结果始终是另一个 &lt;code&gt;ArrayLike&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="859968bca8846c38eabf846201d96ee61f1cb6f0" translate="yes" xml:space="preserve">
          <source>In linear space, the sequence starts at &lt;code&gt;base ** start&lt;/code&gt; (&lt;code&gt;base&lt;/code&gt; to the power of &lt;code&gt;start&lt;/code&gt;) and ends with &lt;code&gt;base ** stop&lt;/code&gt; (see &lt;code&gt;endpoint&lt;/code&gt; below).</source>
          <target state="translated">线性空间，在序列开始 &lt;code&gt;base ** start&lt;/code&gt; （ &lt;code&gt;base&lt;/code&gt; 到的功率 &lt;code&gt;start&lt;/code&gt; ），并用端部 &lt;code&gt;base ** stop&lt;/code&gt; （参见 &lt;code&gt;endpoint&lt;/code&gt; 下文）。</target>
        </trans-unit>
        <trans-unit id="e8987c188d2dc12518e96e9c96bc6fb94bc0c364" translate="yes" xml:space="preserve">
          <source>In many circumstances, datasets can be incomplete or tainted by the presence of invalid data. For example, a sensor may have failed to record a data, or recorded an invalid value. The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module provides a convenient way to address this issue, by introducing masked arrays.</source>
          <target state="translated">在许多情况下，数据集可能不完整或被无效数据污染。例如，传感器可能无法记录数据或记录了无效值。所述&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt;模块提供一种方便的方式通过引入掩蔽阵列来解决这个问题，。</target>
        </trans-unit>
        <trans-unit id="af19adb5953933b119cf6e38053a7bd63ddf0076" translate="yes" xml:space="preserve">
          <source>In memory overlap checks, assume that operands with &lt;code&gt;NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE&lt;/code&gt; enabled are accessed only in the iterator order.</source>
          <target state="translated">在内存重叠检查中，假定仅以迭代器顺序访问启用了 &lt;code&gt;NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE&lt;/code&gt; 的操作数。</target>
        </trans-unit>
        <trans-unit id="bd53b438575f194778c1656e57b318d6b487ca6a" translate="yes" xml:space="preserve">
          <source>In more detail</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e0501d6a0c7c31ee0e8c5ea3ca4747d4c70398" translate="yes" xml:space="preserve">
          <source>In most cases &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; should be used instead of this function, as that will also return true for 0d arrays. This is how numpy overloads functions in the style of the &lt;code&gt;dx&lt;/code&gt; arguments to &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt;&lt;code&gt;gradient&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;bins&lt;/code&gt; argument to &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;. Some key differences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c743fe265d56156ca24d5e10903518aede0334" translate="yes" xml:space="preserve">
          <source>In most use cases the best way to install NumPy on your system is by using a pre-built package for your operating system. Please see &lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https://scipy.org/install.html&lt;/a&gt; for links to available options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="763b6e76c1532989efe227d788422ad02bd06f94" translate="yes" xml:space="preserve">
          <source>In normal buffering, the size of each inner loop is equal to the buffer size, or possibly larger if &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; is specified. If &lt;a href=&quot;#c.NPY_ITER_REDUCE_OK&quot;&gt;&lt;code&gt;NPY_ITER_REDUCE_OK&lt;/code&gt;&lt;/a&gt; is enabled and a reduction occurs, the inner loops may become smaller depending on the structure of the reduction.</source>
          <target state="translated">在普通缓冲中，每个内部循环的大小等于缓冲区大小，如果指定了&lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; ,&lt;/a&gt;则可能更大。如果启用&lt;a href=&quot;#c.NPY_ITER_REDUCE_OK&quot;&gt; &lt;code&gt;NPY_ITER_REDUCE_OK&lt;/code&gt; &lt;/a&gt;并发生缩减，则根据缩减的结构，内部循环可能会变小。</target>
        </trans-unit>
        <trans-unit id="2c60bcd4aa111fe243ec4d9e38a39cdb9410fc32" translate="yes" xml:space="preserve">
          <source>In numpy versions &amp;gt;= 1.7.0 the &lt;code&gt;basis&lt;/code&gt; and &lt;code&gt;cast&lt;/code&gt; class methods are also available. The cast method works like the convert method while the basis method returns the basis polynomial of given degree:</source>
          <target state="translated">在numpy的版本&amp;gt; = 1.7.0的 &lt;code&gt;basis&lt;/code&gt; 和 &lt;code&gt;cast&lt;/code&gt; 类的方法也是可用的。强制转换方法的工作方式类似于转换方法，而基本方法则返回给定度数的基本多项式：</target>
        </trans-unit>
        <trans-unit id="9a36a11020261b9ce301df38d29f32b272d351ef" translate="yes" xml:space="preserve">
          <source>In order to add a Python package to SciPy, its build script (&lt;code&gt;setup.py&lt;/code&gt;) must meet certain requirements. The most important requirement is that the package define a &lt;code&gt;configuration(parent_package='',top_path=None)&lt;/code&gt; function which returns a dictionary suitable for passing to &lt;code&gt;numpy.distutils.core.setup(..)&lt;/code&gt;. To simplify the construction of this dictionary, &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; provides the &lt;code&gt;Configuration&lt;/code&gt; class, described below.</source>
          <target state="translated">为了将Python软件包添加到SciPy，其构建脚本（ &lt;code&gt;setup.py&lt;/code&gt; ）必须满足某些要求。最重要的要求是，程序包定义一个 &lt;code&gt;configuration(parent_package='',top_path=None)&lt;/code&gt; 函数，该函数返回适合传递给 &lt;code&gt;numpy.distutils.core.setup(..)&lt;/code&gt; 的字典。为了简化此字典的构造， &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; 提供了 &lt;code&gt;Configuration&lt;/code&gt; 类，如下所述。</target>
        </trans-unit>
        <trans-unit id="9195216b823d914ae553da6509b9641a3f8c45ff" translate="yes" xml:space="preserve">
          <source>In order to extract information from a given matrix, we can use the SVD to obtain 3 arrays which can be multiplied to obtain the original matrix. From the theory of linear algebra, given a matrix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60fc69a196f8bf024afb0ed60ca3a78c46194201" translate="yes" xml:space="preserve">
          <source>In order to improve the interface, directives should be provided. This is accomplished by constructing an interface definition file. It is usually best to start from the interface file that f2py can produce (where it gets its default behavior from). To get f2py to generate the interface file use the -h option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5eaeb15f58484d8774fc878d68cb55c966f0844" translate="yes" xml:space="preserve">
          <source>In order to make use of the C-API from another extension module, the &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt; function must be called. If the extension module is self-contained in a single .c file, then that is all that needs to be done. If, however, the extension module involves multiple files where the C-API is needed then some additional steps must be taken.</source>
          <target state="translated">为了使用另一个扩展模块中的C-API，必须调用&lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; &lt;/a&gt;函数。如果扩展模块是独立包含在单个.c文件中的，那么这就是所有要做的事情。但是，如果扩展模块涉及需要C-API的多个文件，则必须采取一些其他步骤。</target>
        </trans-unit>
        <trans-unit id="c34adc34291107e6d105c5cd2a716fc5c0f9914c" translate="yes" xml:space="preserve">
          <source>In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained today, a monthly payment of $1,854.02 would be required. Note that this example illustrates usage of &lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt;&lt;code&gt;fv&lt;/code&gt;&lt;/a&gt; having a default value of 0.</source>
          <target state="translated">为了还清（即，终值为0）今天获得的$ 200,000，每月需要支付$ 1,854.02。请注意，此示例说明了默认值为0 的&lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt; &lt;code&gt;fv&lt;/code&gt; 的&lt;/a&gt;用法。</target>
        </trans-unit>
        <trans-unit id="5f37a6feac047af18be703227c7a9f994a3a9fcc" translate="yes" xml:space="preserve">
          <source>In order to prevent clobbering object pointers in fields of &lt;code&gt;numpy.object&lt;/code&gt; type, numpy currently does not allow views of structured arrays containing objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b7199a5c1d305f9cc30b6b7f154cecb0f39e6d3" translate="yes" xml:space="preserve">
          <source>In order to remove elements from an array, it&amp;rsquo;s simple to use indexing to select the elements that you want to keep.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b465797b5de029b2baabd94edf6595fe5ee0db1d" translate="yes" xml:space="preserve">
          <source>In order to start using NumPy and all of the functions available in NumPy, you&amp;rsquo;ll need to import it. This can be easily done with this import statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdf699c411308f89c9b3b067e51b1e307dfb7a9f" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;flags = divide + 2*over + 4*under + 8*invalid&lt;/code&gt;.</source>
          <target state="translated">换句话说， &lt;code&gt;flags = divide + 2*over + 4*under + 8*invalid&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f91eee16dbc3f050fa038e2c5209d53822e69e47" translate="yes" xml:space="preserve">
          <source>In other words, each entry &lt;code&gt;out[i,j,...,:]&lt;/code&gt; is an N-dimensional value drawn from the distribution.</source>
          <target state="translated">换句话说，每个入口 &lt;code&gt;out[i,j,...,:]&lt;/code&gt; 是从分布中得出的N维值。</target>
        </trans-unit>
        <trans-unit id="b7dcdc5e279e7f5cb5fcdbe1eac1b3a0742ee26b" translate="yes" xml:space="preserve">
          <source>In other words, the usage of info is exactly the same as when using blas_info and co.</source>
          <target state="translated">换句话说,info的用法与使用blas_info和co时完全一样。</target>
        </trans-unit>
        <trans-unit id="84851d19bec7dda86a1de5ddcd1548f32366d2fa" translate="yes" xml:space="preserve">
          <source>In our case,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08ff7590113d034602ad8a932c13f96f4f84856" translate="yes" xml:space="preserve">
          <source>In our case, we are approximating the grayscale portion of the image, so we will use the colormap &lt;code&gt;gray&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f0de1dccddf6867cedf88d3dd90186911881e1" translate="yes" xml:space="preserve">
          <source>In our examples, we will treat the input array with a complex data type, so that we can take square roots of negative numbers. Without enabling copies or buffering mode, the iterator will raise an exception if the data type doesn&amp;rsquo;t match precisely.</source>
          <target state="translated">在我们的示例中，我们将使用复杂的数据类型来处理输入数组，以便我们可以取负数的平方根。如果不启用复制或缓冲模式，则如果数据类型不完全匹配，则迭代器将引发异常。</target>
        </trans-unit>
        <trans-unit id="f3aea51c3c320aa437734a573490879eb2569913" translate="yes" xml:space="preserve">
          <source>In place fancy indexing for ufuncs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f02a14688f33a1cd645cff2ad5ad3ea73913fd03" translate="yes" xml:space="preserve">
          <source>In place operations will perform the calculation using the precision decided by the data type of the two operands, but will silently downcast the result (if necessary) so it can fit back into the array. Therefore, for mixed precision calculations, &lt;code&gt;A {op}=
B&lt;/code&gt; can be different than &lt;code&gt;A = A {op} B&lt;/code&gt;. For example, suppose &lt;code&gt;a = ones((3,3))&lt;/code&gt;. Then, &lt;code&gt;a += 3j&lt;/code&gt; is different than &lt;code&gt;a = a +
3j&lt;/code&gt;: while they both perform the same computation, &lt;code&gt;a += 3&lt;/code&gt; casts the result to fit back in &lt;code&gt;a&lt;/code&gt;, whereas &lt;code&gt;a = a + 3j&lt;/code&gt; re-binds the name &lt;code&gt;a&lt;/code&gt; to the result.</source>
          <target state="translated">就地操作将使用由两个操作数的数据类型决定的精度执行计算，但是会静默向下转换结果（如果需要），以便可以放回到数组中。因此，对于混合精度计算， &lt;code&gt;A {op}= B&lt;/code&gt; 可不同于 &lt;code&gt;A = A {op} B&lt;/code&gt; 。例如，假设 &lt;code&gt;a = ones((3,3))&lt;/code&gt; 。然后， &lt;code&gt;a += 3j&lt;/code&gt; 与 &lt;code&gt;a = a + 3j&lt;/code&gt; ：虽然它们都执行相同的计算， &lt;code&gt;a += 3&lt;/code&gt; 会将结果强制转换为适合 &lt;code&gt;a&lt;/code&gt; ，而 &lt;code&gt;a = a + 3j&lt;/code&gt; 将名称 &lt;code&gt;a&lt;/code&gt; 重新绑定到结果。</target>
        </trans-unit>
        <trans-unit id="3ffbc219d4925b162d68445ad04161e81b80a2ae" translate="yes" xml:space="preserve">
          <source>In practice, we anticipate that for most Steering Council decisions (e.g., voting in new members) a more informal process will suffice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="211d3795b0d3cedf14ae00bfdd7e3e38d86df021" translate="yes" xml:space="preserve">
          <source>In prior versions of NumPy, the datetime64 type always stored times in UTC. By default, creating a datetime64 object from a string or printing it would convert from or to local time:</source>
          <target state="translated">在NumPy之前的版本中,datetime64类型总是以UTC存储时间。默认情况下,从一个字符串创建一个datetime64对象或打印它将从当地时间转换为当地时间。</target>
        </trans-unit>
        <trans-unit id="bb94af890255a1752661e16a2eacce9c1ad12713" translate="yes" xml:space="preserve">
          <source>In row-major, C-style order, in two dimensions, the row index varies the slowest, and the column index the quickest. This can be generalized to multiple dimensions, where row-major order implies that the index along the first axis varies slowest, and the index along the last quickest. The opposite holds for column-major, Fortran-style index ordering.</source>
          <target state="translated">在行-大,C式顺序中,在两个维度中,行指数变化最慢,列指数变化最快。这可以推广到多个维度,其中行-主序意味着沿第一个轴的索引变化最慢,而沿最后一个轴的索引变化最快。而列大数、Fortran式的索引排序则相反。</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="507aaff0e5cc21d7011bc819d2bd20f0b309484f" translate="yes" xml:space="preserve">
          <source>In single precision, &lt;a href=&quot;#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; can be inaccurate:</source>
          <target state="translated">以单精度表示，&lt;a href=&quot;#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;可能不准确：</target>
        </trans-unit>
        <trans-unit id="9b1dbcac5dd55e1c7b0ed7b38aff1c0737c2f620" translate="yes" xml:space="preserve">
          <source>In single precision, std() can be inaccurate:</source>
          <target state="translated">在单一精度下,std()可能不准确。</target>
        </trans-unit>
        <trans-unit id="ca04a495cdff9e1119115547af374f5b2a4d64ac" translate="yes" xml:space="preserve">
          <source>In single precision, var() can be inaccurate:</source>
          <target state="translated">在单一精度下,var()可能不准确。</target>
        </trans-unit>
        <trans-unit id="568553829625c2078673593fe2ee401327874ad7" translate="yes" xml:space="preserve">
          <source>In some cases, an appropriate use of the roll and the offset is necessary to get a desired answer.</source>
          <target state="translated">在某些情况下,为了得到理想的答案,适当地使用卷筒和偏移是必要的。</target>
        </trans-unit>
        <trans-unit id="bac6ec658cf559e360b3f959f986ce1e7d727c27" translate="yes" xml:space="preserve">
          <source>In some cases, broadcasting stretches both arrays to form an output array larger than either of the initial arrays.*</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0960cf0185d8fe7d74b182c3299905c5bc5818" translate="yes" xml:space="preserve">
          <source>In some cases, such as structured arrays and the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; interface, a data type needs to be used to make sense of the object. When this is needed, provide a Descr for &amp;lsquo;requested_dtype&amp;rsquo;, otherwise provide NULL. This reference is not stolen. Also, if the requested dtype doesn&amp;rsquo;t modify the interpretation of the input, out_dtype will still get the &amp;ldquo;innate&amp;rdquo; dtype of the object, not the dtype passed in &amp;lsquo;requested_dtype&amp;rsquo;.</source>
          <target state="translated">在某些情况下，例如结构化数组和&lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;接口，需要使用数据类型来理解对象。需要时，为&amp;ldquo; requested_dtype&amp;rdquo;提供一个Descr，否则提供NULL。此引用未被盗。另外，如果请求的dtype不修改输入的解释，则out_dtype仍将获得对象的&amp;ldquo;先天&amp;rdquo; dtype，而不是在&amp;ldquo; requested_dtype&amp;rdquo;中传递的dtype。</target>
        </trans-unit>
        <trans-unit id="facb6bd6062bf723ed24036374202b109145e308" translate="yes" xml:space="preserve">
          <source>In some cases, we are not interested in all the columns of the data but only a few of them. We can select which columns to import with the &lt;code&gt;usecols&lt;/code&gt; argument. This argument accepts a single integer or a sequence of integers corresponding to the indices of the columns to import. Remember that by convention, the first column has an index of 0. Negative integers behave the same as regular Python negative indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef2ea8dc139c52f2365b3742b195c7e8c88faf3c" translate="yes" xml:space="preserve">
          <source>In some cases, you will see this form of the commit command: &lt;code&gt;git commit
-a&lt;/code&gt;. The extra &lt;code&gt;-a&lt;/code&gt; flag automatically commits all modified files and removes all deleted files. This can save you some typing of numerous &lt;code&gt;git
add&lt;/code&gt; commands; however, it can add unwanted changes to a commit if you&amp;rsquo;re not careful. For more information, see &lt;a href=&quot;http://www.gitready.com/beginner/2009/01/18/the-staging-area.html&quot;&gt;why the -a flag?&lt;/a&gt; - and the helpful use-case description in the &lt;a href=&quot;https://tomayko.com/writings/the-thing-about-git&quot;&gt;tangled working copy problem&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="341cdd9b0329316960c0e4cc444da230117b1062" translate="yes" xml:space="preserve">
          <source>In some future release, it will return a read/write view and writing to the returned array will alter your original array. The returned array will have the same type as the input array.</source>
          <target state="translated">在未来的一些版本中,它将返回一个读/写视图,对返回的数组进行写入将改变你原来的数组。返回的数组将具有与输入数组相同的类型。</target>
        </trans-unit>
        <trans-unit id="f5ee90b2a39e9fa80b16d394e14dd0a33a028120" translate="yes" xml:space="preserve">
          <source>In some situations, it is possible that you could use the &lt;code&gt;%numpy_typemaps&lt;/code&gt; macro to implement typemaps for your own types. See the &lt;a href=&quot;#other-common-types-bool&quot;&gt;Other Common Types: bool&lt;/a&gt; or &lt;a href=&quot;#other-common-types-complex&quot;&gt;Other Common Types: complex&lt;/a&gt; sections for examples. Another situation is if your dimensions are of a type other than &lt;code&gt;int&lt;/code&gt; (say &lt;code&gt;long&lt;/code&gt; for example):</source>
          <target state="translated">在某些情况下，可能可以使用 &lt;code&gt;%numpy_typemaps&lt;/code&gt; 宏为您自己的类型实现类型映射。有关示例，请参见&lt;a href=&quot;#other-common-types-bool&quot;&gt;其他常见类型：布尔值&lt;/a&gt;或&lt;a href=&quot;#other-common-types-complex&quot;&gt;其他常见类型：复杂&lt;/a&gt;部分。另一种情况是，如果您的尺寸不是 &lt;code&gt;int&lt;/code&gt; 类型（例如， &lt;code&gt;long&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="ef54aceba82e6cd0b5d227cf1545504de22cdfa8" translate="yes" xml:space="preserve">
          <source>In that case, each item is associated to a column, in order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4128e61e6436506814002ae295957c7fd56f0e0e" translate="yes" xml:space="preserve">
          <source>In that repository edit the files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d0c88a0902d8f4e29b2260087b409a1f0c6bbf0" translate="yes" xml:space="preserve">
          <source>In the 1-D and 0-D case, the indexing and sparse keywords have no effect.</source>
          <target state="translated">在1-D和0-D的情况下,索引和稀疏的关键词没有影响。</target>
        </trans-unit>
        <trans-unit id="82b4d34298ee4da5c6486a950c439f010b328116" translate="yes" xml:space="preserve">
          <source>In the above example F2PY was able to guess accurately the signature of a call-back function. However, sometimes F2PY cannot establish the signature as one would wish and then the signature of a call-back function must be modified in the signature file manually. Namely, signature files may contain special modules (the names of such modules contain a substring &lt;code&gt;__user__&lt;/code&gt;) that collect various signatures of call-back functions. Callback arguments in routine signatures have attribute &lt;code&gt;external&lt;/code&gt; (see also &lt;code&gt;intent(callback)&lt;/code&gt; attribute). To relate a callback argument and its signature in &lt;code&gt;__user__&lt;/code&gt; module block, use &lt;code&gt;use&lt;/code&gt; statement as illustrated below. The same signature of a callback argument can be referred in different routine signatures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e263de7df2b576cf438fac441850586c983ab809" translate="yes" xml:space="preserve">
          <source>In the case of double precision tests, this will return the python function &lt;code&gt;Vector.doubleLength&lt;/code&gt;.</source>
          <target state="translated">在双精度测试的情况下，这将返回python函数 &lt;code&gt;Vector.doubleLength&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0240da2483005a9c53b4aad1de6618f577c43aa" translate="yes" xml:space="preserve">
          <source>In the common 2-D case (N=1), the block structure can be visualized:</source>
          <target state="translated">在常见的二维情况下(N=1),块状结构可以可视化。</target>
        </trans-unit>
        <trans-unit id="e138055380190b3c93b794e532e7d0c34dce613a" translate="yes" xml:space="preserve">
          <source>In the end, which you do for Fortran or C depends on which is more important, not reordering data or preserving the indexing convention. For large images, reordering data is potentially expensive, and often the indexing convention is inverted to avoid that.</source>
          <target state="translated">最后,对于Fortran和C来说,你做哪个取决于哪个更重要,不重新排序数据和保留索引惯例。对于大图像来说,重新排序数据有可能是昂贵的,通常为了避免这种情况,会将索引惯例倒置。</target>
        </trans-unit>
        <trans-unit id="8930375040ab76aae34fb47c1b34d1c268b41dae" translate="yes" xml:space="preserve">
          <source>In the event of any conflict of interest, a committee member must immediately notify the other members, and recuse themselves if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d5a2c6f7d9d2516af28db041f10097409dc991" translate="yes" xml:space="preserve">
          <source>In the example above, we used the fact that by default, &lt;code&gt;dtype=float&lt;/code&gt;. By giving a sequence of names, we are forcing the output to a structured dtype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb66ccf87f3461ec66b2cc1735ef182a062917a" translate="yes" xml:space="preserve">
          <source>In the file, array data starts at this offset. Since &lt;code&gt;offset&lt;/code&gt; is measured in bytes, it should normally be a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;. When &lt;code&gt;mode != 'r'&lt;/code&gt;, even positive offsets beyond end of file are valid; The file will be extended to accommodate the additional data. By default, &lt;code&gt;memmap&lt;/code&gt; will start at the beginning of the file, even if &lt;code&gt;filename&lt;/code&gt; is a file pointer &lt;code&gt;fp&lt;/code&gt; and &lt;code&gt;fp.tell() != 0&lt;/code&gt;.</source>
          <target state="translated">在文件中，数组数据从此偏移量开始。由于 &lt;code&gt;offset&lt;/code&gt; 以字节为单位，因此通常应为&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;的字节大小的倍数。当 &lt;code&gt;mode != 'r'&lt;/code&gt; ，甚至超出文件末尾的正偏移量也有效；该文件将被扩展以容纳其他数据。默认情况下，即使 &lt;code&gt;filename&lt;/code&gt; 是文件指针 &lt;code&gt;fp&lt;/code&gt; 和 &lt;code&gt;fp.tell() != 0&lt;/code&gt; ， &lt;code&gt;memmap&lt;/code&gt; 也将从文件的开头开始。</target>
        </trans-unit>
        <trans-unit id="6d51d7e744b66162bcb271fa8e86dbafebc0e214" translate="yes" xml:space="preserve">
          <source>In the first case the lower bound of the integration is set to -1 and the integration constant is 0. In the second the constant of integration is set to 1 as well. Differentiation is simpler since the only option is the number of times the polynomial is differentiated:</source>
          <target state="translated">在第一种情况下,积分的下界设为-1,积分常数为0,在第二种情况下,积分常数也设为1。微分比较简单,因为唯一的选项是多项式的微分次数。</target>
        </trans-unit>
        <trans-unit id="39042dbdcabf0496e03a08644bb7e129fe61d278" translate="yes" xml:space="preserve">
          <source>In the first case, the dimensions resulting from the advanced indexing operation come first in the result array, and the subspace dimensions after that. In the second case, the dimensions from the advanced indexing operations are inserted into the result array at the same spot as they were in the initial array (the latter logic is what makes simple advanced indexing behave just like slicing).</source>
          <target state="translated">在第一种情况下,高级索引操作产生的维度首先出现在结果数组中,子空间的维度在其后。在第二种情况下,高级索引操作产生的维度被插入到结果数组中与初始数组中的位置相同(后一种逻辑是使简单的高级索引表现得像切片一样的原因)。</target>
        </trans-unit>
        <trans-unit id="fee9951c9cac899e8dc4b73ca21eaf580eee1e11" translate="yes" xml:space="preserve">
          <source>In the following descriptions, we reference a generic &lt;code&gt;DATA_TYPE&lt;/code&gt;, which could be any of the C data types listed above, and &lt;code&gt;DIM_TYPE&lt;/code&gt; which should be one of the many types of integers.</source>
          <target state="translated">在以下描述中，我们引用通用 &lt;code&gt;DATA_TYPE&lt;/code&gt; ，它可以是上面列出的任何C数据类型，而 &lt;code&gt;DIM_TYPE&lt;/code&gt; 则应该是许多整数类型之一。</target>
        </trans-unit>
        <trans-unit id="0a77a218f61bf2d19822ca93ebcee58f5aa1e669" translate="yes" xml:space="preserve">
          <source>In the following example, both the &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; arrays have axes with length one that are expanded to a larger size during the broadcast operation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c7aa7e2fe12577360a1a373c78ed632827aefd" translate="yes" xml:space="preserve">
          <source>In the following example, both the &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; arrays have axes with length one that are expanded to a larger size in a broadcast operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0aabec281905f99f49d1bbd6f2c64a2c3c69d5" translate="yes" xml:space="preserve">
          <source>In the following example, the second column is converted from as string representing a percentage to a float between 0 and 1:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b029336d8b412b884840fa6a1fbeb3e45d0f30b" translate="yes" xml:space="preserve">
          <source>In the following example, we suppose that the missing values are flagged with &lt;code&gt;&quot;N/A&quot;&lt;/code&gt; in the first column and by &lt;code&gt;&quot;???&quot;&lt;/code&gt; in the third column. We wish to transform these missing values to 0 if they occur in the first and second column, and to -999 if they occur in the last column:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fceed6223bcf512a691c7903c36d65343ab22b97" translate="yes" xml:space="preserve">
          <source>In the graph, we can see that although we have 768 singular values in &lt;code&gt;s&lt;/code&gt;, most of those (after the 150th entry or so) are pretty small. So it might make sense to use only the information related to the first (say, 50) &lt;em&gt;singular values&lt;/em&gt; to build a more economical approximation to our image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66d2fff5a851e4221aa19362249b2b84c5964134" translate="yes" xml:space="preserve">
          <source>In the next several sections we give example code that can be easily modified to create your own ufuncs. The examples are successively more complete or complicated versions of the logit function, a common function in statistical modeling. Logit is also interesting because, due to the magic of IEEE standards (specifically IEEE 754), all of the logit functions created below automatically have the following behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dc319444395eeb97927a05649519246dd32d72d" translate="yes" xml:space="preserve">
          <source>In the past most implementations used the &amp;ldquo;desc&amp;rdquo; member of the &lt;code&gt;PyCObject&lt;/code&gt; itself (do not confuse this with the &amp;ldquo;descr&amp;rdquo; member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure above &amp;mdash; they are two separate things) to hold the pointer to the object exposing the interface. This is now an explicit part of the interface. Be sure to own a reference to the object when the &lt;code&gt;PyCObject&lt;/code&gt; is created using &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt;.</source>
          <target state="translated">在过去，大多数实现都使用 &lt;code&gt;PyCObject&lt;/code&gt; 本身的&amp;ldquo; desc&amp;rdquo;成员（不要将其与上面的&lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;结构的&amp;ldquo; descr&amp;rdquo;成员混淆-它们是两个不同的东西）来保存指向暴露接口的对象的指针。现在，这是界面的显式部分。一定要自己去当对象的引用 &lt;code&gt;PyCObject&lt;/code&gt; 使用创建 &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cb71d475f8be6120fc976bd353b076b792b7f77" translate="yes" xml:space="preserve">
          <source>In the past most implementations used the &amp;ldquo;desc&amp;rdquo; member of the &lt;code&gt;PyCObject&lt;/code&gt; itself (do not confuse this with the &amp;ldquo;descr&amp;rdquo; member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure above &amp;mdash; they are two separate things) to hold the pointer to the object exposing the interface. This is now an explicit part of the interface. Be sure to own a reference to the object when the &lt;code&gt;PyCObject&lt;/code&gt; is created using &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfcf82ced52f76044f84d6258de886b7808506ff" translate="yes" xml:space="preserve">
          <source>In the range -1 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 1 they are nice, equiripple functions lying between +/- 1. The same plots over the range -2 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 2 look very different:</source>
          <target state="translated">在-1 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 1 范围内，它们是不错的，等波动函数介于+/- 1之间。在-2 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 2 范围内的相同图看起来非常不同：</target>
        </trans-unit>
        <trans-unit id="8d2fb588d0d5207847c4495ec3e5ed9b60e1f12d" translate="yes" xml:space="preserve">
          <source>In the same way, if we don&amp;rsquo;t give enough names to match the length of the dtype, the missing names will be defined with this default template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9664dec4c702af778eb236a77580a7bb3b836b54" translate="yes" xml:space="preserve">
          <source>In the simplest case, there is only a &lt;em&gt;single&lt;/em&gt; advanced index. A single advanced index can for example replace a slice and the result array will be the same, however, it is a copy and may have a different memory layout. A slice is preferable when it is possible.</source>
          <target state="translated">在最简单的情况下，只有一个&lt;em&gt;单一的&lt;/em&gt;指标先进。单个高级索引可以例如替换切片，并且结果数组将相同，但是，它是一个副本，并且可能具有不同的内存布局。如果可能的话，切片是优选的。</target>
        </trans-unit>
        <trans-unit id="eaceaaeb778efa3a74e32f0e07667ae3c3a1ce24" translate="yes" xml:space="preserve">
          <source>In the source code, be sure to preface any issue or PR reference with &lt;code&gt;gh-xxxx&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c94924098b3009fa708b6c1aec49764e87be7477" translate="yes" xml:space="preserve">
          <source>In the table below, it is assumed that you have executed the following commands in Python:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8a45b3135fa0c84b41da4d210f43fe96826517e" translate="yes" xml:space="preserve">
          <source>In the tables below, &lt;code&gt;platform?&lt;/code&gt; means that the type may not be available on all platforms. Compatibility with different C or Python types is indicated: two types are compatible if their data is of the same size and interpreted in the same way.</source>
          <target state="translated">在下表中， &lt;code&gt;platform?&lt;/code&gt; 表示该类型可能并非在所有平台上都可用。指出了与不同C或Python类型的兼容性：如果两种类型的数据大小相同且以相同的方式解释，则这两种类型是兼容的。</target>
        </trans-unit>
        <trans-unit id="97b2743d166cdad8253bc15ad591949789d4af86" translate="yes" xml:space="preserve">
          <source>In the worst case, if a Contributor is genuinely misusing their veto in an obstructive fashion to the detriment of the project, then they can be ejected from the project by consensus of the Steering Council &amp;ndash; see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7fe7582d8015e2df7c05da1f3a915ff663edd3" translate="yes" xml:space="preserve">
          <source>In this calculation, we can ignore the amount of numbers drawn from each stream. Each of the PRNGs we provide has some extra protection built in that avoids overlaps if the &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; pools differ in the slightest bit. &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; has</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a0a52b3e0dac0b940f22ccbd59e595b0b91828" translate="yes" xml:space="preserve">
          <source>In this calculation, we can ignore the amount of numbers drawn from each stream. Each of the PRNGs we provide has some extra protection built in that avoids overlaps if the &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; pools differ in the slightest bit. &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; has</source>
          <target state="translated">在此计算中，我们可以忽略从每个流中提取的数字量。我们提供的每个PRNG都有一些内置的额外保护措施，如果&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;池的差异最小，则可以避免重叠。&lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;有</target>
        </trans-unit>
        <trans-unit id="fcdf80c260003d781b3489e23716b20d73cd0927" translate="yes" xml:space="preserve">
          <source>In this case, if the index arrays have a matching shape, and there is an index array for each dimension of the array being indexed, the resultant array has the same shape as the index arrays, and the values correspond to the index set for each position in the index arrays. In this example, the first index value is 0 for both index arrays, and thus the first value of the resultant array is y[0,0]. The next value is y[2,1], and the last is y[4,2].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c8dba17ad2bf90a54597788476417de6721a53" translate="yes" xml:space="preserve">
          <source>In this case, we wanted to test solving a linear algebra problem using matrices of several data types, using &lt;code&gt;linalg.solve&lt;/code&gt; and &lt;code&gt;linalg.inv&lt;/code&gt;. The common test cases (for single-precision, double-precision, etc. matrices) are collected in &lt;code&gt;LinalgTestCase&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，我们想使用 &lt;code&gt;linalg.solve&lt;/code&gt; 和 &lt;code&gt;linalg.inv&lt;/code&gt; 使用几种数据类型的矩阵来测试解决线性代数问题。在 &lt;code&gt;LinalgTestCase&lt;/code&gt; 中收集了常见的测试用例（用于单精度，双精度等矩阵）。</target>
        </trans-unit>
        <trans-unit id="a876e5a0c738a8e265b4a962587a67aa3cabc3ca" translate="yes" xml:space="preserve">
          <source>In this chapter routine docstrings are presented, grouped by functionality. Many docstrings contain example code, which demonstrates basic usage of the routine. The examples assume that NumPy is imported with:</source>
          <target state="translated">在这一章中,例行程序docstrings按功能分组。许多 docstrings 包含示例代码,演示了例程的基本用法。这些例子假定NumPy是通过以下方式导入的。</target>
        </trans-unit>
        <trans-unit id="4030b7d01040d7db2670bc21cd8e6f75987d1ae6" translate="yes" xml:space="preserve">
          <source>In this context, consensus does &lt;em&gt;not&lt;/em&gt; require:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb82fb6aef1a39fd7c11a037068f12eca825f3ae" translate="yes" xml:space="preserve">
          <source>In this example if &lt;code&gt;a&lt;/code&gt; is an ndarray, &amp;ldquo;fancy&amp;rdquo; indexing can be used.</source>
          <target state="translated">在此示例中，如果 &lt;code&gt;a&lt;/code&gt; 是ndarray，则可以使用&amp;ldquo;花式&amp;rdquo;索引。</target>
        </trans-unit>
        <trans-unit id="8f824e9ad2dd27432acf7adb45ed2442b89417d6" translate="yes" xml:space="preserve">
          <source>In this example the spacing is also specified: uniform for axis=0 and non uniform for axis=1</source>
          <target state="translated">在这个例子中,还指定了间距:轴线=0时为统一,轴线=1时为非统一。</target>
        </trans-unit>
        <trans-unit id="328c265783b83eb29747b7db6d81add31503c3ba" translate="yes" xml:space="preserve">
          <source>In this example, I will show how the addition function and the filter function implemented previously using the other approaches can be implemented using ctypes. First, the C code which implements the algorithms contains the functions &lt;code&gt;zadd&lt;/code&gt;, &lt;code&gt;dadd&lt;/code&gt;, &lt;code&gt;sadd&lt;/code&gt;, &lt;code&gt;cadd&lt;/code&gt;, and &lt;code&gt;dfilter2d&lt;/code&gt;. The &lt;code&gt;zadd&lt;/code&gt; function is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c094638bd844d3fa04f0e228195eec44c93a4f" translate="yes" xml:space="preserve">
          <source>In this example, a tuple of arrays was returned: one for each dimension. The first array represents the row indices where these values are found, and the second array represents the column indices where the values are found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2729241cb81ad5eb6d0653ad987658266f4094e0" translate="yes" xml:space="preserve">
          <source>In this example, both the predictions and labels vectors contain three values, meaning &lt;code&gt;n&lt;/code&gt; has a value of three. After we carry out subtractions the values in the vector are squared. Then NumPy sums the values, and your result is the error value for that prediction and a score for the quality of the model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e415859b6bc51789a95cf9e8d4d1433827763e1d" translate="yes" xml:space="preserve">
          <source>In this example, real input has an FFT which is Hermitian, i.e., symmetric in the real part and anti-symmetric in the imaginary part, as described in the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; documentation:</source>
          <target state="translated">在此示例中，实际输入具有FFT，即FFT，即厄米（Hermitian），即在实部是对称的，而在虚部是反对称的，如&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt;文档中所述：</target>
        </trans-unit>
        <trans-unit id="ceae5efa8d3a6692e49c8c2886b52adb07addf1c" translate="yes" xml:space="preserve">
          <source>In this example, weight has more impact on the distance calculation than height because of the larger values. In practice, it is important to normalize the height and weight, often by their standard deviation across the data set, so that both have equal influence on the distance calculation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3e40fb7708f540adaa0b760c857b87aaa0e15a" translate="yes" xml:space="preserve">
          <source>In this shorthand notation any of the &lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes-constructing&quot;&gt;string dtype specifications&lt;/a&gt; may be used in a string and separated by commas. The itemsize and byte offsets of the fields are determined automatically, and the field names are given the default names &lt;code&gt;f0&lt;/code&gt;, &lt;code&gt;f1&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03bc9d15047b673ea201dcf5663747af818d9b11" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will use a &lt;a href=&quot;https://en.wikipedia.org/wiki/Matrix_decomposition&quot;&gt;matrix decomposition&lt;/a&gt; from linear algebra, the Singular Value Decomposition, to generate a compressed approximation of an image. We&amp;rsquo;ll use the &lt;code&gt;face&lt;/code&gt; image from the &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/misc.html#module-scipy.misc&quot;&gt;&lt;code&gt;scipy.misc&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b71631798c22c7379ee16411ed600d40ef635fc" translate="yes" xml:space="preserve">
          <source>In two dimensions, the DFT is defined as</source>
          <target state="translated">在二维中,DFT定义为</target>
        </trans-unit>
        <trans-unit id="e78643ae03c902815fce8ed7873dad947453bab7" translate="yes" xml:space="preserve">
          <source>In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_ macro namespace in them. That form of the constant names is deprecated in 1.7.</source>
          <target state="translated">在NumPy的1.6及更早的版本中,以下标志中没有_ARRAY_宏命名空间。这种形式的常量名称在1.7中已经被废弃。</target>
        </trans-unit>
        <trans-unit id="2eb3748bd4c40ee385c34a340546b34ff09c6d0f" translate="yes" xml:space="preserve">
          <source>In versions of NumPy prior to 1.7, this function always returned a new, independent array containing a copy of the values in the diagonal.</source>
          <target state="translated">在1.7之前的NumPy版本中,这个函数总是返回一个新的、独立的数组,其中包含对角线中数值的副本。</target>
        </trans-unit>
        <trans-unit id="0dd37ad2fb32e65c87fa0dbb4334407e5e86a994" translate="yes" xml:space="preserve">
          <source>In what NumPy version the object was deprecated, and when it will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e3012fb521e71655f173862b6d8385b1b505394" translate="yes" xml:space="preserve">
          <source>In-Place Arrays</source>
          <target state="translated">原位阵列</target>
        </trans-unit>
        <trans-unit id="4515cac8ae9188e7e6a2adf0d7162014d11595d3" translate="yes" xml:space="preserve">
          <source>In-place arrays are defined as arrays that are modified in-place. The input values may or may not be used, but the values at the time the function returns are significant. The provided Python argument must therefore be a NumPy array of the required type. The in-place signatures are</source>
          <target state="translated">就地数组定义为就地修改的数组。输入的值可能被使用,也可能不被使用,但函数返回时的值是重要的。因此,所提供的 Python 参数必须是所需类型的 NumPy 数组。就地修改的签名是</target>
        </trans-unit>
        <trans-unit id="e156e5cac1a2d58a18cbdda52494e20ca1917186" translate="yes" xml:space="preserve">
          <source>In-place sort.</source>
          <target state="translated">就地排序。</target>
        </trans-unit>
        <trans-unit id="79b98df32c7e9b7cb0e464788719f6ba70f3ff64" translate="yes" xml:space="preserve">
          <source>Incident reporting resolution &amp;amp; Code of Conduct enforcement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1195d8c8b6b9e2d6ec4d935a14c881a29bcc75" translate="yes" xml:space="preserve">
          <source>Incorrect &lt;code&gt;threshold&lt;/code&gt; in &lt;code&gt;np.set_printoptions&lt;/code&gt; raises &lt;code&gt;TypeError&lt;/code&gt; or &lt;code&gt;ValueError&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2070997d3a1215cd23a07fdeb2caa1389920935f" translate="yes" xml:space="preserve">
          <source>Increased performance in &lt;code&gt;random.permutation&lt;/code&gt; for multidimensional arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7086e912a42ead51516c8a8180bf48b02a02ed8" translate="yes" xml:space="preserve">
          <source>Incremement the index and the dataptr members of the &lt;em&gt;iterator&lt;/em&gt; to point to the next element of the array. If the array is not (C-style) contiguous, also increment the N-dimensional coordinates array.</source>
          <target state="translated">增加&lt;em&gt;迭代器&lt;/em&gt;的索引和dataptr成员以指向数组的下一个元素。如果数组不是（C样式）连续的，则还要增加N维坐标数组。</target>
        </trans-unit>
        <trans-unit id="7a7d2f744a7296cdaea426008f157d69008c6d52" translate="yes" xml:space="preserve">
          <source>Increment items 0 and 1, and increment item 2 twice:</source>
          <target state="translated">将项目0和1递增,项目2递增两次。</target>
        </trans-unit>
        <trans-unit id="aa0f6e205ff77646c8e4c26a5cd802d06b0ed1ab" translate="yes" xml:space="preserve">
          <source>Increment the multi-dimensional index by one.</source>
          <target state="translated">将多维指数递增1。</target>
        </trans-unit>
        <trans-unit id="1431536c5cec1e86a2b496f9aea15a2431b6da9a" translate="yes" xml:space="preserve">
          <source>Increment the release number in setup.py. Release candidates should have &amp;ldquo;rc1&amp;rdquo; (or &amp;ldquo;rc2&amp;rdquo;, &amp;ldquo;rcN&amp;rdquo;) appended to the X.Y.Z format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47bbbc7bbd392dc811939b0ca8df290ae66b6625" translate="yes" xml:space="preserve">
          <source>Indeed, the fact is that Python indexing on lists and other sequences naturally leads to an outside-to inside ordering (the first index gets the largest grouping, the next the next largest, and the last gets the smallest element). Since image data are normally stored by rows, this corresponds to position within rows being the last item indexed.</source>
          <target state="translated">事实上,Python 在列表和其他序列上的索引自然会导致从外到内的排序(第一个索引得到最大的分组,下一个索引得到下一个最大的分组,最后一个索引得到最小的元素)。由于图像数据通常是按行来存储的,这就相当于行内的位置是最后一个索引的项目。</target>
        </trans-unit>
        <trans-unit id="a955748860a9401904eff7aeb318142866860450" translate="yes" xml:space="preserve">
          <source>Independent Streams</source>
          <target state="translated">独立流</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="9362b6e75e3f28d4a83666c8ba00890a4d410bc7" translate="yes" xml:space="preserve">
          <source>Index arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7ef6cce7547dfa6d1e0bda509869536452ee0c" translate="yes" xml:space="preserve">
          <source>Index arrays may be combined with slices. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c44a201623d0e3d087173369dce55b524d144281" translate="yes" xml:space="preserve">
          <source>Index arrays must be of integer type. Each value in the array indicates which value in the array to use in place of the index. To illustrate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a35691c6c1bb32304626e5515963a9a6c7ec2da" translate="yes" xml:space="preserve">
          <source>Index of the diagonal: 0 (the default) refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal.</source>
          <target state="translated">对角线的索引:0(默认)表示主对角线,正值表示上对角线,负值表示下对角线。</target>
        </trans-unit>
        <trans-unit id="119920061dcb691e0fcbed0a1783c9e871f11ec5" translate="yes" xml:space="preserve">
          <source>Index of the diagonal: 0 refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal.</source>
          <target state="translated">对角线的指数:0表示主对角线,正值表示上对角线,负值表示下对角线。</target>
        </trans-unit>
        <trans-unit id="57f71bf775773f532dceb2dabadcde07069670df" translate="yes" xml:space="preserve">
          <source>Indexes of the maximal elements of a N-dimensional array:</source>
          <target state="translated">N维数组中最大元素的索引。</target>
        </trans-unit>
        <trans-unit id="c30b085b29907fc8dd1fcc4ba9d8f5fab779ff0b" translate="yes" xml:space="preserve">
          <source>Indexes of the maximum values along an axis.</source>
          <target state="translated">沿轴的最大值的索引。</target>
        </trans-unit>
        <trans-unit id="f9b599db4bf0df8d9bbcf7c5db6a037f6e6e69aa" translate="yes" xml:space="preserve">
          <source>Indexes of the minimum values along an axis.</source>
          <target state="translated">沿轴的最小值的索引。</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="ca22a585bfdf222b22aaead59f3666212fc40ce0" translate="yes" xml:space="preserve">
          <source>Indexing &lt;code&gt;x['field-name']&lt;/code&gt; returns a new &lt;a href=&quot;../glossary#term-view&quot;&gt;view&lt;/a&gt; to the array, which is of the same shape as &lt;em&gt;x&lt;/em&gt; (except when the field is a sub-array) but of data type &lt;code&gt;x.dtype['field-name']&lt;/code&gt; and contains only the part of the data in the specified field. Also &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record array&lt;/a&gt; scalars can be &amp;ldquo;indexed&amp;rdquo; this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b59c12801d6fa741bd0be2abcd90167bf71d161c" translate="yes" xml:space="preserve">
          <source>Indexing &lt;code&gt;x['field-name']&lt;/code&gt; returns a new &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;view&lt;/a&gt; to the array, which is of the same shape as &lt;em&gt;x&lt;/em&gt; (except when the field is a sub-array) but of data type &lt;code&gt;x.dtype['field-name']&lt;/code&gt; and contains only the part of the data in the specified field. Also &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record array&lt;/a&gt; scalars can be &amp;ldquo;indexed&amp;rdquo; this way.</source>
          <target state="translated">索引 &lt;code&gt;x['field-name']&lt;/code&gt; 返回数组的新&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;视图&lt;/a&gt;，该视图与&lt;em&gt;x&lt;/em&gt;具有相同的形状（当字段是子数组时除外），但数据类型为 &lt;code&gt;x.dtype['field-name']&lt;/code&gt; 并且仅包含指定字段中的部分数据。还&lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;记录阵列&lt;/a&gt;标量可以被&amp;ldquo;索引&amp;rdquo;这种方式。</target>
        </trans-unit>
        <trans-unit id="9542b665971d159d6c17d4f34752698e601626e8" translate="yes" xml:space="preserve">
          <source>Indexing MaskedArrays/Constants with &lt;code&gt;...&lt;/code&gt; (ellipsis) now returns MaskedArray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a956de2c65434dac2e3f2395af98a63c09e0e921" translate="yes" xml:space="preserve">
          <source>Indexing Multi-dimensional arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29f8c2cdcd3c7159d7617a4b4b26d63a3389924" translate="yes" xml:space="preserve">
          <source>Indexing Structured Arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370bbc588e0d38b8f416d5dcc2dcf3fc93d26630" translate="yes" xml:space="preserve">
          <source>Indexing a single element of a structured array (with an integer index) returns a structured scalar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1544ebdc7ceef1dd43c207ab5e502bb881e63b2a" translate="yes" xml:space="preserve">
          <source>Indexing and Assignment to Structured arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b75e279fb5c7684c193076341ad2da99a787445" translate="yes" xml:space="preserve">
          <source>Indexing and slicing</source>
          <target state="translated">索引和切片</target>
        </trans-unit>
        <trans-unit id="c620de8536d4e92665cc1da6338b0e3c9ccd772a" translate="yes" xml:space="preserve">
          <source>Indexing and slicing operations are useful when you&amp;rsquo;re manipulating matrices:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f16e8a5deb5dca320283bcd174b16dd9a73b2c2" translate="yes" xml:space="preserve">
          <source>Indexing arrays</source>
          <target state="translated">索引数组</target>
        </trans-unit>
        <trans-unit id="32cfd79e57bf8a3877f833f091f428533e7b10d7" translate="yes" xml:space="preserve">
          <source>Indexing basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43bc37d1483f275b849fa10b51ee75dd7340e249" translate="yes" xml:space="preserve">
          <source>Indexing into a structured array can also be done with a list of field names, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt;. As of NumPy 1.16 this returns a view containing only those fields. In older versions of numpy it returned a copy. See the user guide section on &lt;a href=&quot;../user/basics.rec#structured-arrays&quot;&gt;Structured arrays&lt;/a&gt; for more information on multifield indexing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287cc46fe81b17127e826e2dc4d460f956256411" translate="yes" xml:space="preserve">
          <source>Indexing into a structured array can also be done with a list of field names, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt;. As of NumPy 1.16 this returns a view containing only those fields. In older versions of numpy it returned a copy. See the user guide section on &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#structured-arrays&quot;&gt;Structured arrays&lt;/a&gt; for more information on multifield indexing.</source>
          <target state="translated">也可以使用字段名称列表（&lt;em&gt;例如&lt;/em&gt; &lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt; 索引到结构化数组中。从NumPy 1.16开始，它将返回仅包含这些字段的视图。在旧版本的numpy中，它返回了一个副本。有关多字段索引的更多信息，请参见&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#structured-arrays&quot;&gt;结构化数组&lt;/a&gt;的用户指南部分。</target>
        </trans-unit>
        <trans-unit id="f9931083a6e7f53e9bc486a3df5e5e7c8488e9d6" translate="yes" xml:space="preserve">
          <source>Indexing routines</source>
          <target state="translated">索引程序</target>
        </trans-unit>
        <trans-unit id="6e79a0e3c54ea0ceb91b9669283adab9f2147f0b" translate="yes" xml:space="preserve">
          <source>Indexing with Arrays of Indices</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5b7926d0e1062fbea55528bbcec6310b0c56043" translate="yes" xml:space="preserve">
          <source>Indexing with Boolean Arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3484dfe82dee2e7bac292b6534b5cbe2647cd408" translate="yes" xml:space="preserve">
          <source>Indexing with an Integer to get a Structured Scalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090d4c4fc948bc8eed34fc6e8ddf8e7bd5be023c" translate="yes" xml:space="preserve">
          <source>Indexing with strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2794b9b37dd0d88704ab33758cd5ea559027c74f" translate="yes" xml:space="preserve">
          <source>Indexing, Slicing and Iterating</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b6ddf08f9938b1aef1c27a89f039c34d4ed175" translate="yes" xml:space="preserve">
          <source>Indexing-like operations</source>
          <target state="translated">类似索引的操作</target>
        </trans-unit>
        <trans-unit id="0454b105259e523f13a84d0a1ff2499fbf44bf18" translate="yes" xml:space="preserve">
          <source>Indicate how the user of the iterator will read or write to &lt;code&gt;op[i]&lt;/code&gt;. Exactly one of these flags must be specified per operand. Using &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; or &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; for a user-provided operand may trigger &lt;code&gt;WRITEBACKIFCOPY`&lt;/code&gt; semantics. The data will be written back to the original array when &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; is called.</source>
          <target state="translated">指示迭代器的用户如何读取或写入 &lt;code&gt;op[i]&lt;/code&gt; 。必须为每个操作数指定这些标志之一。对用户提供的操作数使用 &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; 或 &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; 可能会触发 &lt;code&gt;WRITEBACKIFCOPY`&lt;/code&gt; 语义。调用 &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; 时，数据将写回到原始数组。</target>
        </trans-unit>
        <trans-unit id="ba89764e8d83fcb18f052ec54405d196f55000ee" translate="yes" xml:space="preserve">
          <source>Indicate indices of sub-arrays to remove along the specified axis.</source>
          <target state="translated">指明要沿着指定的轴删除的子数组的指数。</target>
        </trans-unit>
        <trans-unit id="ff289ba1c19ab34e00eb1d52160a46b6efb2713b" translate="yes" xml:space="preserve">
          <source>Indicates arrays of this data-type must be converted to a list before pickling.</source>
          <target state="translated">表示该数据类型的数组在拣选前必须转换为列表。</target>
        </trans-unit>
        <trans-unit id="327748da6a9d945d96e091b8e7383b60afba1da7" translate="yes" xml:space="preserve">
          <source>Indicates memory for this data-type must be initialized (set to 0) on creation.</source>
          <target state="translated">表示该数据类型的内存必须在创建时被初始化(设置为0)。</target>
        </trans-unit>
        <trans-unit id="4bc4530525549adc3e6afe819ca6b79c82a0ab71" translate="yes" xml:space="preserve">
          <source>Indicates that arrays with a size of zero should be permitted. Since the typical iteration loop does not naturally work with zero-sized arrays, you must check that the IterSize is larger than zero before entering the iteration loop. Currently only the operands are checked, not a forced shape.</source>
          <target state="translated">表示应该允许使用大小为零的数组。由于典型的迭代循环并不能自然地使用零大小的数组,所以在进入迭代循环之前必须检查IterSize是否大于零。目前只检查操作数,不检查强制形状。</target>
        </trans-unit>
        <trans-unit id="3f20ca03a166ca2b12eed667d0c9d43d498dcabe" translate="yes" xml:space="preserve">
          <source>Indicates that arrays with reference types (object arrays or structured arrays containing an object type) may be accepted and used in the iterator. If this flag is enabled, the caller must be sure to check whether &lt;code&gt;NpyIter_IterationNeedsAPI(iter)&lt;/code&gt; is true, in which case it may not release the GIL during iteration.</source>
          <target state="translated">指示在迭代器中可以接受和使用具有引用类型的数组（对象数组或包含对象类型的结构化数组）。如果启用此标志，则调用者必须确保检查 &lt;code&gt;NpyIter_IterationNeedsAPI(iter)&lt;/code&gt; 是否为true，在这种情况下，它可能不会在迭代过程中释放GIL。</target>
        </trans-unit>
        <trans-unit id="e809396a40c3ec96fdae3328ed0a31c66576c7c0" translate="yes" xml:space="preserve">
          <source>Indicates that items of this data-type must be reference counted (using &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">指示此数据类型的项目必须是参照（使用计数&lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt; &lt;code&gt;Py_DECREF&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="03ad2756a493f01508378680f8d907e50dad0e86" translate="yes" xml:space="preserve">
          <source>Indicates that this operand is the mask to use for selecting elements when writing to operands which have the &lt;a href=&quot;#c.NPY_ITER_WRITEMASKED&quot;&gt;&lt;code&gt;NPY_ITER_WRITEMASKED&lt;/code&gt;&lt;/a&gt; flag applied to them. Only one operand may have &lt;a href=&quot;#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; flag applied to it.</source>
          <target state="translated">指示此操作数是在写入应用了&lt;a href=&quot;#c.NPY_ITER_WRITEMASKED&quot;&gt; &lt;code&gt;NPY_ITER_WRITEMASKED&lt;/code&gt; &lt;/a&gt;标志的操作数时用于选择元素的掩码。只有一个操作数可以应用&lt;a href=&quot;#c.NPY_ITER_ARRAYMASK&quot;&gt; &lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt; &lt;/a&gt;标志。</target>
        </trans-unit>
        <trans-unit id="613ac9b34fa48eda3d48ba0a932ba15f0204a86f" translate="yes" xml:space="preserve">
          <source>Indicates the item is a pointer to some other data-type</source>
          <target state="translated">表示该项目是指向其他数据类型的指针。</target>
        </trans-unit>
        <trans-unit id="6f07bb702873a42eecec00d6bf9d09bfd0c31b06" translate="yes" xml:space="preserve">
          <source>Indicates this data-type requires the Python C-API during access (so don&amp;rsquo;t give up the GIL if array access is going to be needed).</source>
          <target state="translated">指示此数据类型在访问期间需要Python C-API（因此，如果需要数组访问，请不要放弃GIL）。</target>
        </trans-unit>
        <trans-unit id="d5ca13d01e4aee97ba5ebf7dbc18794ab7e82eae" translate="yes" xml:space="preserve">
          <source>Indicating whether the intervals include the right or the left bin edge. Default behavior is (right==False) indicating that the interval does not include the right edge. The left bin end is open in this case, i.e., bins[i-1] &amp;lt;= x &amp;lt; bins[i] is the default behavior for monotonically increasing bins.</source>
          <target state="translated">指示间隔是包括右边还是左边的边沿。默认行为是（right == False），指示间隔不包括右边缘。在这种情况下，左侧料斗末端是敞开的，即bins [i-1] &amp;lt;= x &amp;lt;bins [i]是单调递增料斗的默认行为。</target>
        </trans-unit>
        <trans-unit id="ca9cfe4e704c12c6c1fa5c4b576973839a44850c" translate="yes" xml:space="preserve">
          <source>Indices can also be grouped by element.</source>
          <target state="translated">指数也可以按元素分组。</target>
        </trans-unit>
        <trans-unit id="14ad131012032e9e04ca04f6d1ddd8fbcaa3e2c0" translate="yes" xml:space="preserve">
          <source>Indices for the upper-triangle of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 的上三角符号。</target>
        </trans-unit>
        <trans-unit id="05056f495c02c0b518e0436ff12d0703c782c034" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero.</source>
          <target state="translated">非零元素的指数。</target>
        </trans-unit>
        <trans-unit id="91841f1f82f1c15d4b5be121831bfdfa7d539a5a" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero. Indices are grouped by element.</source>
          <target state="translated">非零元素的指数。指数按元素分组。</target>
        </trans-unit>
        <trans-unit id="7756fd7ee8f7161ab914664d39dc9bedefea080d" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero. Indices are grouped by element. This array will have shape &lt;code&gt;(N, a.ndim)&lt;/code&gt; where &lt;code&gt;N&lt;/code&gt; is the number of non-zero items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94c56d6a6bfbdfee7bbd9db799f4cac5be86fa1" translate="yes" xml:space="preserve">
          <source>Indices of the minimum elements of a N-dimensional array:</source>
          <target state="translated">N维数组中最小元素的指数。</target>
        </trans-unit>
        <trans-unit id="764406c1c2d21f5c9a93e6d3d66afbc9de92b722" translate="yes" xml:space="preserve">
          <source>Indices of the sorted elements of a N-dimensional array:</source>
          <target state="translated">N维数组的排序元素的指数。</target>
        </trans-unit>
        <trans-unit id="d010fa85fcc511735fc1ba118d8c9fa77c46fb33" translate="yes" xml:space="preserve">
          <source>Indices to change along each 1d slice of &lt;code&gt;arr&lt;/code&gt;. This must match the dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast against &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">沿 &lt;code&gt;arr&lt;/code&gt; 的每个1d切片变化的指标。这必须匹配arr的尺寸，但是要针对 &lt;code&gt;arr&lt;/code&gt; 广播，Ni和Nj中的尺寸可能为1 。</target>
        </trans-unit>
        <trans-unit id="bd4ed66b25e3e81f7c09020b3e15317e8ebab751" translate="yes" xml:space="preserve">
          <source>Indices to take along each 1d slice of &lt;code&gt;arr&lt;/code&gt;. This must match the dimension of arr, but dimensions Ni and Nj only need to broadcast against &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">沿 &lt;code&gt;arr&lt;/code&gt; 的每一1d切片取的指数。这必须匹配arr的尺寸，但是尺寸Ni和Nj仅需要针对 &lt;code&gt;arr&lt;/code&gt; 广播。</target>
        </trans-unit>
        <trans-unit id="7dfac1d76acfef8a43ec3bb5c63e278bd2c2aa5a" translate="yes" xml:space="preserve">
          <source>Indirect partial sort.</source>
          <target state="translated">间接部分排序。</target>
        </trans-unit>
        <trans-unit id="67b91131b038b258475621be16da6d4bad633d9d" translate="yes" xml:space="preserve">
          <source>Indirect partition.</source>
          <target state="translated">间接分区。</target>
        </trans-unit>
        <trans-unit id="ceed8c74919b3d66cbcd799fe2d4bb252d0af6a7" translate="yes" xml:space="preserve">
          <source>Indirect sort.</source>
          <target state="translated">间接排序。</target>
        </trans-unit>
        <trans-unit id="7a7f09efc9fe3734b3bf1afc86adc2e542a21680" translate="yes" xml:space="preserve">
          <source>Indirect stable sort on multiple keys.</source>
          <target state="translated">多键间接稳定排序。</target>
        </trans-unit>
        <trans-unit id="80cc0e6eec2203fc2c38742d008a3fb864036a7b" translate="yes" xml:space="preserve">
          <source>Indirect stable sort with multiple keys.</source>
          <target state="translated">多键间接稳定排序。</target>
        </trans-unit>
        <trans-unit id="f2d326af87bc022a272e7d1fdc4716803c23e396" translate="yes" xml:space="preserve">
          <source>Individual fields of a structured array may be accessed and modified by indexing the array with the field name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e9e048443c76eaece9af376ed6551264b94a4e9" translate="yes" xml:space="preserve">
          <source>Individual values are not stripped of spaces by default. When using a custom converter, make sure the function does remove spaces.</source>
          <target state="translated">默认情况下,单个值不会去掉空格。当使用自定义转换器时,请确保该函数能去除空格。</target>
        </trans-unit>
        <trans-unit id="5888912f1820a7f863f2cf1064c7ab5b1a9a9baa" translate="yes" xml:space="preserve">
          <source>Individuals come from different cultural backgrounds and native languages. Try to identify any honest misunderstandings caused by a non-native speaker and help them understand the issue and what they can change to avoid causing offence. Complex discussion in a foreign language can be very intimidating, and we want to grow our diversity also across nationalities and cultures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28ed132c608e3b4681e944b25690757eebfc33f" translate="yes" xml:space="preserve">
          <source>Inf (in module numpy)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b675f1c2537bc4e7587a11173af58141e3f3972" translate="yes" xml:space="preserve">
          <source>Infinity (in module numpy)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbf064be21246c8a34df5396396140e055f24f53" translate="yes" xml:space="preserve">
          <source>Info are easily retrieved from the &lt;a href=&quot;distutils/misc_util#numpy.distutils.misc_util.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt; function in &lt;a href=&quot;distutils/misc_util#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecae1f8d30472c9a7f54d4130dc7c3b85605f125" translate="yes" xml:space="preserve">
          <source>Info are easily retrieved from the &lt;code&gt;get_info&lt;/code&gt; function in &lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">可以从&lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt; &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; 中&lt;/a&gt;的 &lt;code&gt;get_info&lt;/code&gt; 函数轻松检索信息：</target>
        </trans-unit>
        <trans-unit id="ce47f6aad749dde8c374d70dfb4bb3378d690b1b" translate="yes" xml:space="preserve">
          <source>Information (via the dtype object) about the interpretation of the basic data element. The basic data element may be as simple as a int or a float, or it may be a compound object (e.g., struct-like), a fixed character field, or Python object pointers.</source>
          <target state="translated">关于基本数据元素的解释的信息 (通过 dtype 对象)。基本数据元素可以是简单的int或float,也可以是一个复合对象(例如,类似结构体)、一个固定的字符域或Python对象指针。</target>
        </trans-unit>
        <trans-unit id="bfbba3e12af5ea2c7741d834d66f7c560456f725" translate="yes" xml:space="preserve">
          <source>Information about sub-data-types in a &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87749b5a0427424240dbd899baaf24bccac8d963" translate="yes" xml:space="preserve">
          <source>Information about sub-data-types in a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;:</source>
          <target state="translated">有关&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;结构化数据&lt;/a&gt;类型中的子数据类型的信息：</target>
        </trans-unit>
        <trans-unit id="feb91fe9e3a82284bbc774141950eade27079231" translate="yes" xml:space="preserve">
          <source>Information about the memory layout of the array.</source>
          <target state="translated">阵列的内存布局信息。</target>
        </trans-unit>
        <trans-unit id="6c6da40785b1a9277377a0ac6b35aa661e1efec5" translate="yes" xml:space="preserve">
          <source>Information may include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b590718892221849c4b4d49b1a5feaa2b8ce90e3" translate="yes" xml:space="preserve">
          <source>Initialize all function pointers and members to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">将所有函数指针和成员初始化为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32bc5b2fd4039aefa8f94877a70e63431f9d15f4" translate="yes" xml:space="preserve">
          <source>Inner product</source>
          <target state="translated">内部产品</target>
        </trans-unit>
        <trans-unit id="1dba54e0b565dd813bcf7f4dd26137c8252036b6" translate="yes" xml:space="preserve">
          <source>Inner product of two arrays.</source>
          <target state="translated">两个数组的内积。</target>
        </trans-unit>
        <trans-unit id="064057f93ed4cdc0c2704e960d9c6d25cbbcac22" translate="yes" xml:space="preserve">
          <source>Inplace partition.</source>
          <target state="translated">Inplace partition.</target>
        </trans-unit>
        <trans-unit id="5afc0baf08aba247f1b2f3cdc0980c0ea2b6e83d" translate="yes" xml:space="preserve">
          <source>Inplace sort.</source>
          <target state="translated">Inplace out.</target>
        </trans-unit>
        <trans-unit id="d72a097ccb9c0003ebff6189ebb422b954b438f2" translate="yes" xml:space="preserve">
          <source>Input 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">输入一维&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80930bf11175241ae29fe59d0d272e2dd3fda246" translate="yes" xml:space="preserve">
          <source>Input &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; for which the mask is required.</source>
          <target state="translated">输入需要掩码的&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abfa0de453f55ea46910c5cb072561c46c566eda" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;MaskedArray&lt;/code&gt;, alternatively a ndarray or a subclass thereof.</source>
          <target state="translated">输入 &lt;code&gt;MaskedArray&lt;/code&gt; ，或者ndarray或其子类。</target>
        </trans-unit>
        <trans-unit id="ef6caaf1ffac65c55e3879237f23b9e4cd5b35fe" translate="yes" xml:space="preserve">
          <source>Input Arrays</source>
          <target state="translated">输入数组</target>
        </trans-unit>
        <trans-unit id="c77783bb0c7d4d2f9b2b8bd6478b069981c0866f" translate="yes" xml:space="preserve">
          <source>Input and output</source>
          <target state="translated">输入和输出</target>
        </trans-unit>
        <trans-unit id="43fab0b785a955e5195e8f3f11f33f3ad7b432bc" translate="yes" xml:space="preserve">
          <source>Input argument, can be of any type and shape.</source>
          <target state="translated">输入参数,可以是任何类型和形状。</target>
        </trans-unit>
        <trans-unit id="df78d5709935001a8bf74fe47ed30fca9beafae5" translate="yes" xml:space="preserve">
          <source>Input array</source>
          <target state="translated">输入阵列</target>
        </trans-unit>
        <trans-unit id="d573fb86d82f5065edfc4ca49f5112f03928d672" translate="yes" xml:space="preserve">
          <source>Input array in degrees.</source>
          <target state="translated">输入阵列的度数。</target>
        </trans-unit>
        <trans-unit id="c7b020a842b9509ee12f3acbb189d43b5a5c8e2b" translate="yes" xml:space="preserve">
          <source>Input array in radians.</source>
          <target state="translated">以弧度为单位的输入阵列。</target>
        </trans-unit>
        <trans-unit id="f139b5d61b47039d6645fe901089b8d7348e059e" translate="yes" xml:space="preserve">
          <source>Input array of size 1.</source>
          <target state="translated">输入数组大小为1。</target>
        </trans-unit>
        <trans-unit id="4fabb62ebf0299b3a11dc8870c6ebb3a76ef6ff9" translate="yes" xml:space="preserve">
          <source>Input array of strings to capitalize.</source>
          <target state="translated">输入要大写的字符串数组。</target>
        </trans-unit>
        <trans-unit id="8088eb90e795502e434844cfa6cdf9e95d4c9437" translate="yes" xml:space="preserve">
          <source>Input array of the same size as &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">输入数组的大小与 &lt;code&gt;condition&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="f46407fd3e6fc3c69904fb1af7940d31883ac983" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array, containing nan values to be ignored</source>
          <target state="translated">输入数组或可转换为数组的对象,包含要忽略的nan值。</target>
        </trans-unit>
        <trans-unit id="49d0fb63038b2721f65a3fb79be1b2a9aa62e9d2" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array, containing nan values to be ignored.</source>
          <target state="translated">输入数组或可转换为数组的对象,包含要忽略的nan值。</target>
        </trans-unit>
        <trans-unit id="1e12f84194e4961e84959b469b0f8a65e2620351" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array.</source>
          <target state="translated">输入数组或可转换为数组的对象。</target>
        </trans-unit>
        <trans-unit id="a14df91a899a43d15ec0d5b0ebc8a2a56f832cef" translate="yes" xml:space="preserve">
          <source>Input array to be binned. Prior to NumPy 1.10.0, this array had to be 1-dimensional, but can now have any shape.</source>
          <target state="translated">要进行分层的输入数组,在NumPy 1.10.0之前,这个数组必须是一维的,但现在可以是任何形状。在NumPy 1.10.0之前,这个数组必须是一维的,但现在可以有任何形状。</target>
        </trans-unit>
        <trans-unit id="bf15a8f66c7dacebdd89b7241fd4d11919829ad3" translate="yes" xml:space="preserve">
          <source>Input array to compute determinants for.</source>
          <target state="translated">用于计算行列式的输入数组。</target>
        </trans-unit>
        <trans-unit id="9eff9d201dcac2141e1679ca23a312d5c7800681" translate="yes" xml:space="preserve">
          <source>Input array to extend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e287445198fc945368949e1412f5d8cb686139f" translate="yes" xml:space="preserve">
          <source>Input array to integrate.</source>
          <target state="translated">要整合的输入数组。</target>
        </trans-unit>
        <trans-unit id="85b9cb3f5f032dd1e9e0718bbfaa4576f72e78eb" translate="yes" xml:space="preserve">
          <source>Input array whose fields must be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42226304be73817a4e285cb433d2b7bb659c59a4" translate="yes" xml:space="preserve">
          <source>Input array with datetime or timedelta data type.</source>
          <target state="translated">输入数据类型为datetime或timedelta的数组。</target>
        </trans-unit>
        <trans-unit id="7c1847566b14607f43160463914cca58e1d1e0d6" translate="yes" xml:space="preserve">
          <source>Input array, a (subclass of) ndarray.</source>
          <target state="translated">输入数组,一个(ndarray的子类)。</target>
        </trans-unit>
        <trans-unit id="a4f57e9a75e6d26f7e8f35eb55623a7c6ae8a1b9" translate="yes" xml:space="preserve">
          <source>Input array, can be complex</source>
          <target state="translated">输入阵列,可以是复杂的</target>
        </trans-unit>
        <trans-unit id="1b7a137c8182cfa54895f3372cda87fe7e3932e7" translate="yes" xml:space="preserve">
          <source>Input array, can be complex.</source>
          <target state="translated">输入数组,可以很复杂。</target>
        </trans-unit>
        <trans-unit id="6d76cf24117a4b5288f54769d468e637657f37e2" translate="yes" xml:space="preserve">
          <source>Input array, from which the diagonals are taken.</source>
          <target state="translated">输入数组,从中提取对角线。</target>
        </trans-unit>
        <trans-unit id="2204886fc1fe79484a18e95229b508e3a16d8a88" translate="yes" xml:space="preserve">
          <source>Input array, has to be a square 2-D array.</source>
          <target state="translated">输入数组,必须是一个正方形的二维数组。</target>
        </trans-unit>
        <trans-unit id="4e7ee35a9b27cc189fd5faf36b937d455a1aa919" translate="yes" xml:space="preserve">
          <source>Input array, must be at least 2-D.</source>
          <target state="translated">输入阵列,必须至少是二维的。</target>
        </trans-unit>
        <trans-unit id="b7ba46399772c3a420055c71f8f5dda1e65da7f0" translate="yes" xml:space="preserve">
          <source>Input array, taken to be real.</source>
          <target state="translated">输入数组,取为实数。</target>
        </trans-unit>
        <trans-unit id="16ca749420dd58126c1f3f4ccf95ce2fc49387c9" translate="yes" xml:space="preserve">
          <source>Input array.</source>
          <target state="translated">输入阵列。</target>
        </trans-unit>
        <trans-unit id="05370e4965d51e56f1347351509792a8c2d8443c" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;x&lt;/code&gt; must be 1-D or 2-D, unless &lt;code&gt;ord&lt;/code&gt; is None. If both &lt;code&gt;axis&lt;/code&gt; and &lt;code&gt;ord&lt;/code&gt; are None, the 2-norm of &lt;code&gt;x.ravel&lt;/code&gt; will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e22a13f0e68b42a409027fe2f016234b4ec5feb3" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;x&lt;/code&gt; must be 1-D or 2-D.</source>
          <target state="translated">输入数组。如果 &lt;code&gt;axis&lt;/code&gt; 为&amp;ldquo;无&amp;rdquo;，则 &lt;code&gt;x&lt;/code&gt; 必须为一维或二维。</target>
        </trans-unit>
        <trans-unit id="a823c846105b9c9719fbae89a64d485cac5a4b66" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;sorter&lt;/code&gt; is None, then it must be sorted in ascending order, otherwise &lt;code&gt;sorter&lt;/code&gt; must be an array of indices that sort it.</source>
          <target state="translated">输入数组。如果 &lt;code&gt;sorter&lt;/code&gt; 为None，则必须按升序排序，否则 &lt;code&gt;sorter&lt;/code&gt; 必须是对其进行排序的索引数组。</target>
        </trans-unit>
        <trans-unit id="9358104d5c139fb6025e6e3c499456297f4494b9" translate="yes" xml:space="preserve">
          <source>Input array. It must conform to the Python-side of the array interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eef0d989b2fd6fdf464d508f694dc4a0a6a6caa" translate="yes" xml:space="preserve">
          <source>Input array. The elements in &lt;code&gt;a&lt;/code&gt; are read in the order specified by &lt;code&gt;order&lt;/code&gt;, and packed as a 1-D array.</source>
          <target state="translated">输入数组。中的元素 &lt;code&gt;a&lt;/code&gt; 被读入由指定的顺序 &lt;code&gt;order&lt;/code&gt; ，并包装为1-d阵列。</target>
        </trans-unit>
        <trans-unit id="88c5aa449f45fc85917596c4004dffe23e0b86ac" translate="yes" xml:space="preserve">
          <source>Input array. Unless &lt;code&gt;axis&lt;/code&gt; is specified, this will be flattened if it is not already 1-D.</source>
          <target state="translated">输入数组。除非指定了 &lt;code&gt;axis&lt;/code&gt; ，否则如果它不是一维的，它将被展平。</target>
        </trans-unit>
        <trans-unit id="c937c57a4f225878ef9dec01334ff4466710291e" translate="yes" xml:space="preserve">
          <source>Input arrays</source>
          <target state="translated">输入数组</target>
        </trans-unit>
        <trans-unit id="d4ab162cfec9e7e5f511b1323f2a38dced9855a6" translate="yes" xml:space="preserve">
          <source>Input arrays are defined as arrays of data that are passed into a routine but are not altered in-place or returned to the user. The Python input array is therefore allowed to be almost any Python sequence (such as a list) that can be converted to the requested type of array. The input array signatures are</source>
          <target state="translated">输入数组被定义为数据的数组,这些数据被传递到一个例程中,但不会被就地改变或返回给用户。因此,Python输入数组几乎可以是任何Python序列(如一个列表),可以转换为所请求的数组类型。输入数组的签名是</target>
        </trans-unit>
        <trans-unit id="098168471a46df6606b6ff9c9cd3ead3422de613" translate="yes" xml:space="preserve">
          <source>Input arrays of the same shape.</source>
          <target state="translated">输入相同形状的数组。</target>
        </trans-unit>
        <trans-unit id="27f64d53a246ed11a85c01a61d0a931b1d50a817" translate="yes" xml:space="preserve">
          <source>Input arrays to be compared.</source>
          <target state="translated">要比较的输入数组。</target>
        </trans-unit>
        <trans-unit id="6fed91f1bcdfc2569325e9089bbd325328b5c5e9" translate="yes" xml:space="preserve">
          <source>Input arrays to be multiplied. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">要相乘的输入数组。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="4a8e2cbe86fa87773992dad5fc91ec0f376d5ef6" translate="yes" xml:space="preserve">
          <source>Input arrays to compare.</source>
          <target state="translated">输入数组进行比较。</target>
        </trans-unit>
        <trans-unit id="66d649cf79701276da2a390f23e474c6ab2aff7f" translate="yes" xml:space="preserve">
          <source>Input arrays, scalars not allowed.</source>
          <target state="translated">输入数组,不允许输入标量。</target>
        </trans-unit>
        <trans-unit id="556a7ea15ff0974e693ba20b38993284bf2034ec" translate="yes" xml:space="preserve">
          <source>Input arrays.</source>
          <target state="translated">输入数组。</target>
        </trans-unit>
        <trans-unit id="ad9b94d855384626461316d89dd8037bff8db7bd" translate="yes" xml:space="preserve">
          <source>Input arrays. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">输入数组。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="d784452f6247a01f2c79aa8a172590665da159e0" translate="yes" xml:space="preserve">
          <source>Input arrays. They are flattened if they are not already 1D.</source>
          <target state="translated">输入数组。如果它们还不是1D,就会被扁平化。</target>
        </trans-unit>
        <trans-unit id="e48eae13547040a1f74bd1dc543d4762a4b7970d" translate="yes" xml:space="preserve">
          <source>Input arrays. Will be flattened if not already 1D.</source>
          <target state="translated">输入数组。如果还不是1D,将被扁平化。</target>
        </trans-unit>
        <trans-unit id="670ce16c58ae415abf92889322038709e2fa68ca" translate="yes" xml:space="preserve">
          <source>Input cash flows per time period. By convention, net &amp;ldquo;deposits&amp;rdquo; are negative and net &amp;ldquo;withdrawals&amp;rdquo; are positive. Thus, for example, at least the first element of &lt;code&gt;values&lt;/code&gt;, which represents the initial investment, will typically be negative.</source>
          <target state="translated">每个时间段的输入现金流量。按照惯例，净&amp;ldquo;存款&amp;rdquo;为负，净&amp;ldquo;取款&amp;rdquo;为正。因此，例如，至少代表初始投资的 &lt;code&gt;values&lt;/code&gt; 的第一要素通常为负。</target>
        </trans-unit>
        <trans-unit id="00f0d4d4fb6b101c2c16fbc5749470d99cd4de8c" translate="yes" xml:space="preserve">
          <source>Input class. If a tuple of classes, True is returned if &lt;code&gt;arg1&lt;/code&gt; is a subclass of any of the tuple elements.</source>
          <target state="translated">输入类别。如果是类的元组，则当 &lt;code&gt;arg1&lt;/code&gt; 是任何元组元素的子类时，则返回True 。</target>
        </trans-unit>
        <trans-unit id="2bad44bea0aeffb47c89150e3263bb8f1abd9181" translate="yes" xml:space="preserve">
          <source>Input class. True is returned if &lt;code&gt;arg1&lt;/code&gt; is a subclass of &lt;code&gt;arg2&lt;/code&gt;.</source>
          <target state="translated">输入类别。如果 &lt;code&gt;arg1&lt;/code&gt; 是 &lt;code&gt;arg2&lt;/code&gt; 的子类，则返回True。</target>
        </trans-unit>
        <trans-unit id="56f0cc662add4c7f0901841588673883d4d29d17" translate="yes" xml:space="preserve">
          <source>Input comparison array.</source>
          <target state="translated">输入比较数组。</target>
        </trans-unit>
        <trans-unit id="64be30841013bc47e9c3850c4b6a7fded4a86ac4" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to a masked array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists, ndarrays and masked arrays.</source>
          <target state="translated">输入数据,以任何形式可以转换为掩码数组。这包括列表、元组列表、元组、元组的元组、列表的元组、ndarrays和掩码数组。</target>
        </trans-unit>
        <trans-unit id="81eacae9b22a55fbd594cc3dd8bc53a24b4e16f7" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array.</source>
          <target state="translated">输入数据,任何形式的数据都可以转换为一个数组。</target>
        </trans-unit>
        <trans-unit id="2ed4e1316aa603c005ccf7b9b354de1cad7aa423" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays.</source>
          <target state="translated">输入数据,以任何可以转换为数组的形式。这包括列表、元组列表、元组、元组的元组、列表的元组和ndarrays。</target>
        </trans-unit>
        <trans-unit id="c935f3a4d2949a1b2d5a11eb7de8a0fed4bd8dc0" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays. Success requires no NaNs or Infs.</source>
          <target state="translated">输入数据,以任何可以转换为数组的形式。这包括列表、元组列表、元组、元组的元组、列表的元组和ndarrays。成功要求不需要NaNs或Infs。</target>
        </trans-unit>
        <trans-unit id="ebe3314c250fe9acc710492a54a53defc42ce5bf" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes scalars, lists, lists of tuples, tuples, tuples of tuples, tuples of lists, and ndarrays.</source>
          <target state="translated">输入数据,以任何可以转换为数组的形式。这包括标量、列表、元组列表、元组、元组的元组、列表的元组和ndarrays。</target>
        </trans-unit>
        <trans-unit id="d430a3ba769bee8e9797da35defb2f32aa2749a3" translate="yes" xml:space="preserve">
          <source>Input data, which is flattened and set as the &lt;code&gt;k&lt;/code&gt;-th diagonal of the output.</source>
          <target state="translated">输入数据被展平并设置为输出的第 &lt;code&gt;k&lt;/code&gt; 个对角线。</target>
        </trans-unit>
        <trans-unit id="260753716624ad2077f13f38ada17a33c0f48cba" translate="yes" xml:space="preserve">
          <source>Input data.</source>
          <target state="translated">输入数据:</target>
        </trans-unit>
        <trans-unit id="110e3a721161e503e06852d0b67d62808bcf14b0" translate="yes" xml:space="preserve">
          <source>Input data. If a string, variables in the current scope may be referenced by name.</source>
          <target state="translated">输入数据。如果是字符串,当前作用域中的变量可以通过名称引用。</target>
        </trans-unit>
        <trans-unit id="50ef3fe01b042bdbfb18f290684475887aff6e69" translate="yes" xml:space="preserve">
          <source>Input data. The histogram is computed over the flattened array.</source>
          <target state="translated">输入数据。直方图是在扁平化的数组上计算出来的。</target>
        </trans-unit>
        <trans-unit id="479157011c9bc4b0c174d6c627dd634e47f423a6" translate="yes" xml:space="preserve">
          <source>Input datatype</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3661c49bb4714e36d1ea68c6778013ac4b2c966" translate="yes" xml:space="preserve">
          <source>Input masks.</source>
          <target state="translated">输入掩码。</target>
        </trans-unit>
        <trans-unit id="49c6112477838697a8b42892713d1ff818dab05e" translate="yes" xml:space="preserve">
          <source>Input must be an ndarray (or have similar attributes) for it to be considered a valid mask.</source>
          <target state="translated">输入必须是一个ndarray(或具有类似的属性),才能被认为是一个有效的掩码。</target>
        </trans-unit>
        <trans-unit id="cdda590be17222720d3dca31ac32ec20a4bd2027" translate="yes" xml:space="preserve">
          <source>Input object or name to get information about. If &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; is a numpy object, its docstring is given. If it is a string, available modules are searched for matching objects. If None, information about &lt;a href=&quot;#numpy.info&quot;&gt;&lt;code&gt;info&lt;/code&gt;&lt;/a&gt; itself is returned.</source>
          <target state="translated">输入对象或名称以获取有关的信息。如果&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt;是一个numpy对象，则给出其文档字符串。如果是字符串，则在可用模块中搜索匹配的对象。如果为None，则返回有关&lt;a href=&quot;#numpy.info&quot;&gt; &lt;code&gt;info&lt;/code&gt; &lt;/a&gt;本身的信息。</target>
        </trans-unit>
        <trans-unit id="884c8a0c5d0944c72ee0463c3eae0abb376b5e70" translate="yes" xml:space="preserve">
          <source>Input object. This can be any object (function, class, module, &amp;hellip;).</source>
          <target state="translated">输入对象。这可以是任何对象（函数，类，模块等）。</target>
        </trans-unit>
        <trans-unit id="5bf2f1c9ba1965ca26f274218714e854f9f8439e" translate="yes" xml:space="preserve">
          <source>Input parameters.</source>
          <target state="translated">输入参数:</target>
        </trans-unit>
        <trans-unit id="f281e3f644ef1c6e22e0e862f4156eee5c382d75" translate="yes" xml:space="preserve">
          <source>Input polynomials.</source>
          <target state="translated">输入多项式。</target>
        </trans-unit>
        <trans-unit id="d68cab221829e2198b605b4996fba557e5ff14b8" translate="yes" xml:space="preserve">
          <source>Input sequences.</source>
          <target state="translated">输入序列:</target>
        </trans-unit>
        <trans-unit id="103b73f8b8612de7f92ed544d130aab2ccb3dead" translate="yes" xml:space="preserve">
          <source>Input value.</source>
          <target state="translated">输入值:</target>
        </trans-unit>
        <trans-unit id="cf14e71217c8a7f10324a53bd5825d3d1b8701ee" translate="yes" xml:space="preserve">
          <source>Input values</source>
          <target state="translated">输入值</target>
        </trans-unit>
        <trans-unit id="4191049318f63b6c3a85211b91a5c1cecb649bdb" translate="yes" xml:space="preserve">
          <source>Input values.</source>
          <target state="translated">输入值:</target>
        </trans-unit>
        <trans-unit id="07feb5a3916677b58c8f1860e3f940ccc64ab2f3" translate="yes" xml:space="preserve">
          <source>Input values. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">输入值。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="75826edc2e28e338fe2b7ee2851bc98b65454f08" translate="yes" xml:space="preserve">
          <source>Input vector or stack of matrices.</source>
          <target state="translated">输入矢量或矩阵堆栈。</target>
        </trans-unit>
        <trans-unit id="31df6d6470f1b56cda7e136be4be3e1c6dd63188" translate="yes" xml:space="preserve">
          <source>Input-only, in-place, argout, argoutview, and memory managed argoutview behavior.</source>
          <target state="translated">只输入、就地、argout、argoutview和内存管理的argoutview行为。</target>
        </trans-unit>
        <trans-unit id="f0c077a272f1db74eb4547826e2fa78b80131915" translate="yes" xml:space="preserve">
          <source>Inputs array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35b236db313f77f4ec031a91db5c8c986efb6cc5" translate="yes" xml:space="preserve">
          <source>Inputs arrays.</source>
          <target state="translated">输入数组。</target>
        </trans-unit>
        <trans-unit id="b698f1874b3f648c9ca7483478e5a5187dbc4214" translate="yes" xml:space="preserve">
          <source>Insert a new axis that will appear at the &lt;code&gt;axis&lt;/code&gt; position in the expanded array shape.</source>
          <target state="translated">插入一个新轴，该 &lt;code&gt;axis&lt;/code&gt; 将出现在扩展数组形状的轴位置上。</target>
        </trans-unit>
        <trans-unit id="af781fb10a00be46a34d9311756bc61e0afddfa8" translate="yes" xml:space="preserve">
          <source>Insert elements into an array.</source>
          <target state="translated">在一个数组中插入元素。</target>
        </trans-unit>
        <trans-unit id="62cc157d912a7ebc384c4d505230255340ab3ae0" translate="yes" xml:space="preserve">
          <source>Insert scalar into an array (scalar is cast to array&amp;rsquo;s dtype, if possible)</source>
          <target state="translated">将标量插入数组（如果可能，将标量强制转换为数组的dtype）</target>
        </trans-unit>
        <trans-unit id="6f263a0b1fde8fabbe156179a3331b4bc254ecbf" translate="yes" xml:space="preserve">
          <source>Insert values along the given axis before the given indices.</source>
          <target state="translated">沿着给定的轴在给定的指数前插入数值。</target>
        </trans-unit>
        <trans-unit id="6c05692f04b1e8c9bcb190b107c8a7b51796744b" translate="yes" xml:space="preserve">
          <source>Insert, remove, and combine dimensions, and resize existing ones</source>
          <target state="translated">插入、移除、合并尺寸,以及调整现有尺寸的大小。</target>
        </trans-unit>
        <trans-unit id="5ca6174fce3b04b3d69345d6264017af5ed2d820" translate="yes" xml:space="preserve">
          <source>Inserted between elements.</source>
          <target state="translated">插入元素之间。</target>
        </trans-unit>
        <trans-unit id="e6afa88e6a63d5a7ba7fb743473b463e1d9a17d0" translate="yes" xml:space="preserve">
          <source>Inserting data into arrays</source>
          <target state="translated">在数组中插入数据</target>
        </trans-unit>
        <trans-unit id="0f2b8c85b4203c61d3146e95e582c267d771f003" translate="yes" xml:space="preserve">
          <source>Inserting directives in Fortran source</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d078b8bceaffb54addedcd30ef388e1bc3bf477b" translate="yes" xml:space="preserve">
          <source>Inserts newlines if text is longer than &lt;code&gt;max_line_width&lt;/code&gt;. Defaults to &lt;code&gt;numpy.get_printoptions()['linewidth']&lt;/code&gt;.</source>
          <target state="translated">如果文本长于 &lt;code&gt;max_line_width&lt;/code&gt; ,则插入换行符。默认为 &lt;code&gt;numpy.get_printoptions()['linewidth']&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e503f860ac4f65121fead950747f4fcea390ed6" translate="yes" xml:space="preserve">
          <source>Inspecting the array</source>
          <target state="translated">检查阵列</target>
        </trans-unit>
        <trans-unit id="60da80156a5d0a6bae59ac9116ec4cab69c6184c" translate="yes" xml:space="preserve">
          <source>Install git</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e853cc56e81f34b9860e59d86983f00754c7d4" translate="yes" xml:space="preserve">
          <source>Installation of the new package is easy using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b894e265fdd7f5a67dff5c1fc33dcfbd31481f9" translate="yes" xml:space="preserve">
          <source>Installing NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aee4fe0a13da73153ed829e66d85c46397091399" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; subclasses are passed through as-is:</source>
          <target state="translated">&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;子类的实例按原样传递：</target>
        </trans-unit>
        <trans-unit id="449be076c28f2ad0824dc5cabdcb20c6b823dcf2" translate="yes" xml:space="preserve">
          <source>Instances of classes that are part of the NumPy API (for example &lt;code&gt;np.r_&lt;/code&gt;&lt;code&gt;np,c_&lt;/code&gt;, &lt;code&gt;np.index_exp&lt;/code&gt;, etc.) may require some care. To give these instances a useful docstring, we do the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39a6352ce81aec018b2a3acbf6b2a0e689c1611" translate="yes" xml:space="preserve">
          <source>Instead of plain &lt;code&gt;gdb&lt;/code&gt; you can of course use your favourite alternative debugger; run it on the python binary with arguments &lt;code&gt;runtests.py -g --python mytest.py&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb90e39d52c4ed3cde5408270177895a426f7a11" translate="yes" xml:space="preserve">
          <source>Instead of special method names which define behavior for Python classes, there are &amp;ldquo;function tables&amp;rdquo; which point to functions that implement the desired results. Since Python 2.2, the PyTypeObject itself has become dynamic which allows C types that can be &amp;ldquo;sub-typed &amp;ldquo;from other C-types in C, and sub-classed in Python. The children types inherit the attributes and methods from their parent(s).</source>
          <target state="translated">代替定义Python类行为的特殊方法名称，有&amp;ldquo;函数表&amp;rdquo;指向实现所需结果的函数。从Python 2.2开始，PyTypeObject本身就变得动态起来，它允许C类型可以从C中的其他C类型&amp;ldquo;子类型化&amp;rdquo;，并在Python中进行子分类。子类型从其父类继承属性和方法。</target>
        </trans-unit>
        <trans-unit id="1a76aa17748f84d4f0a3ce05629dc02de8fc5860" translate="yes" xml:space="preserve">
          <source>Instead of specifying the full covariance matrix, popular approximations include:</source>
          <target state="translated">常用的近似方法包括,不指定完整的协方差矩阵,而是:</target>
        </trans-unit>
        <trans-unit id="569af2f9677e0019350ea2c63399c035e782231b" translate="yes" xml:space="preserve">
          <source>Instead of the Python traditional &amp;lsquo;floor division&amp;rsquo;, this returns a true division. True division adjusts the output type to present the best answer, regardless of input types.</source>
          <target state="translated">而不是Python传统的&amp;ldquo;地板分割&amp;rdquo;，它返回一个真正的分割。真除法调整输出类型以提供最佳答案，而与输入类型无关。</target>
        </trans-unit>
        <trans-unit id="2a07db57033cceb88c4be20433a8c922b8ebe578" translate="yes" xml:space="preserve">
          <source>Instead of the above, you can also do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50b73dbdc0cbb3f8f1706a51e59d5b72389beaee" translate="yes" xml:space="preserve">
          <source>Instead of this function &lt;code&gt;PyObject_Call(ufunc, args, kwds)&lt;/code&gt; should be used. The above function differs from this because it ignores support for non-array, or array subclasses as inputs. To ensure identical behaviour, it may be necessary to convert all inputs using &lt;code&gt;PyArray_FromAny(obj, NULL, 0, 0, NPY_ARRAY_ENSUREARRAY, NULL)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93d352d3764b7602f9edf496f491993157b0351d" translate="yes" xml:space="preserve">
          <source>Institutional Neutrality</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8f68e1ce3b53a860ea6246ace5d16aba4fb2d5" translate="yes" xml:space="preserve">
          <source>Institutional Partner benefits are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36318fd5786e4e1f35ed034e1d3f5b6a4d87922c" translate="yes" xml:space="preserve">
          <source>Institutional Partners</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228367a5efa47fc0ca88237f73f231005624c438" translate="yes" xml:space="preserve">
          <source>Institutional Partners and Funding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="415e24116e418ab9260b5d4870a4577bbf2a9dc5" translate="yes" xml:space="preserve">
          <source>Institutions become eligible to become an Institutional Partner by employing individuals who actively contribute to The Project as part of their official duties. To state this another way, the only way for a Partner to influence the project is by actively contributing to the open development of the project, in equal terms to any other member of the community of Contributors and Council Members. Merely using Project Software in institutional context does not allow an entity to become an Institutional Partner. Financial gifts do not enable an entity to become an Institutional Partner. Once an institution becomes eligible for Institutional Partnership, the Steering Council must nominate and approve the Partnership.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed58f29743f8e14b9c8e13d41e070a1cc1d1c9f5" translate="yes" xml:space="preserve">
          <source>Instructions</source>
          <target state="translated">Instructions</target>
        </trans-unit>
        <trans-unit id="987d64b35cc2b94395724f62d16f3a187b63fb14" translate="yes" xml:space="preserve">
          <source>Insufficient bit width parameter to &lt;code&gt;binary_repr&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="5796f99d3f819f045b29a1c73196d8c40b12d9d3" translate="yes" xml:space="preserve">
          <source>Integer (-2147483648 to 2147483647)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4710e6c81ea3d854c2dc7806935816c50a107107" translate="yes" xml:space="preserve">
          <source>Integer (-32768 to 32767)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d944b6a3d689ab2dee3e16b0c8d8d941fd887e9b" translate="yes" xml:space="preserve">
          <source>Integer (-9223372036854775808 to 9223372036854775807)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8fe5938766ae937144b5f55575793bff2ec8f88" translate="yes" xml:space="preserve">
          <source>Integer and Void scalars are now unaffected by &lt;code&gt;np.set_string_function&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61c09200238e7c60e4949f4f742cd3529f52bfd" translate="yes" xml:space="preserve">
          <source>Integer array indexing</source>
          <target state="translated">整数数组索引</target>
        </trans-unit>
        <trans-unit id="a764d9440def338d1a721af2c9bc3cf9203fd57a" translate="yes" xml:space="preserve">
          <source>Integer array indexing allows selection of arbitrary items in the array based on their &lt;em&gt;N&lt;/em&gt;-dimensional index. Each integer array represents a number of indexes into that dimension.</source>
          <target state="translated">整数数组索引允许基于数组的&lt;em&gt;N&lt;/em&gt;维索引选择数组中的任意项。每个整数数组代表该维度的多个索引。</target>
        </trans-unit>
        <trans-unit id="a46c6037b6ed3e2034603c23c6f4211c22a945c1" translate="yes" xml:space="preserve">
          <source>Integer exponents of 2. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">2的整数指数。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="a3173b86433d0db1fb5b647328822672be728221" translate="yes" xml:space="preserve">
          <source>Integer indicating how this dtype relates to the built-in dtypes.</source>
          <target state="translated">表示该dtype与内置dtype关系的整数。</target>
        </trans-unit>
        <trans-unit id="201042a920a1327277fe1dda0e55cd37046acf9f" translate="yes" xml:space="preserve">
          <source>Integer large enough to hold a pointer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ad68cb65f108515f3a5b364ab814f280978530" translate="yes" xml:space="preserve">
          <source>Integer performance has a similar ordering.</source>
          <target state="translated">整数性能有类似的排序。</target>
        </trans-unit>
        <trans-unit id="006c632da5c7b1582b36540c57330b631facab3d" translate="yes" xml:space="preserve">
          <source>Integer that can hold a pointer</source>
          <target state="translated">可容纳指针的整数</target>
        </trans-unit>
        <trans-unit id="b13be07f7abad8e811e3c73cea1a525a627e0bc2" translate="yes" xml:space="preserve">
          <source>Integer ufuncs vectorized with AVX2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a334f0e07c1be58e6996ea133d59f4da9faac7a9" translate="yes" xml:space="preserve">
          <source>Integer used for indexing, typically the same as &lt;code&gt;ssize_t&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654f37af768fdf3bb70ca69e758a2fe80f1abf09" translate="yes" xml:space="preserve">
          <source>Integers:</source>
          <target state="translated">Integers:</target>
        </trans-unit>
        <trans-unit id="84cede945b07b48bcb97421b3eb8bd4f5bd269e0" translate="yes" xml:space="preserve">
          <source>Integral part of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的整数部分。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="1ea3c0d26d1c5d1b53eb099b2c1cf7972b99ebe8" translate="yes" xml:space="preserve">
          <source>Integrate &lt;code&gt;y&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) along given axis.</source>
          <target state="translated">沿给定轴积分 &lt;code&gt;y&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cc54f713576053888447a5aa6f2b6660db759e79" translate="yes" xml:space="preserve">
          <source>Integrate a Chebyshev series.</source>
          <target state="translated">整合一个切比雪夫系列。</target>
        </trans-unit>
        <trans-unit id="f7e0820ca3cf5b80cf75499d63a15279548b4395" translate="yes" xml:space="preserve">
          <source>Integrate a Hermite series.</source>
          <target state="translated">整合一个赫米特系列。</target>
        </trans-unit>
        <trans-unit id="09cdc33ab9232f32b3ffa23eec0555fd0aad884d" translate="yes" xml:space="preserve">
          <source>Integrate a Hermite_e series.</source>
          <target state="translated">整合一个Hermite_e系列。</target>
        </trans-unit>
        <trans-unit id="28e01e90e39bcd5c5a200d36b330a9fb8a0cc2c8" translate="yes" xml:space="preserve">
          <source>Integrate a Laguerre series.</source>
          <target state="translated">并入拉盖尔系列。</target>
        </trans-unit>
        <trans-unit id="e45d1046a79d8f27551599eaeb79cbfa5c322286" translate="yes" xml:space="preserve">
          <source>Integrate a Legendre series.</source>
          <target state="translated">集成到传奇系列。</target>
        </trans-unit>
        <trans-unit id="51617b9fadb594aa47fc197fa4afb1a0d12a97e3" translate="yes" xml:space="preserve">
          <source>Integrate a polynomial.</source>
          <target state="translated">对一个多项式进行积分。</target>
        </trans-unit>
        <trans-unit id="1b28e42d25bb1781655bdbd732badc274759c37c" translate="yes" xml:space="preserve">
          <source>Integrate along the given axis using the composite trapezoidal rule.</source>
          <target state="translated">利用复合梯形法则沿给定轴线进行积分。</target>
        </trans-unit>
        <trans-unit id="f6bc7be2c5b5072601573fb92ccbc047dff88160" translate="yes" xml:space="preserve">
          <source>Integrate.</source>
          <target state="translated">Integrate.</target>
        </trans-unit>
        <trans-unit id="a77970f26b3a19856dc6d676e2149a78243716b5" translate="yes" xml:space="preserve">
          <source>Integrated squared error (ISE) estimator added to &lt;code&gt;histogram&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24640b86177ce52879242a4e3855fb7330a6f367" translate="yes" xml:space="preserve">
          <source>Integration constant(s). The value of the first integral at &lt;code&gt;lbnd&lt;/code&gt; is the first value in the list, the value of the second integral at &lt;code&gt;lbnd&lt;/code&gt; is the second value, etc. If &lt;code&gt;k == []&lt;/code&gt; (the default), all constants are set to zero. If &lt;code&gt;m == 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">积分常数。 &lt;code&gt;lbnd&lt;/code&gt; 处的第一个整数的值是列表中的第一个值， &lt;code&gt;lbnd&lt;/code&gt; 处的第二个整数的值是第二个值，依此类推。如果 &lt;code&gt;k == []&lt;/code&gt; （默认值），则所有常数都设置为零。如果 &lt;code&gt;m == 1&lt;/code&gt; ，则可以给出单个标量而不是列表。</target>
        </trans-unit>
        <trans-unit id="faa7aa2d13f47c8dc8e8d870349e9f9bbf12fee6" translate="yes" xml:space="preserve">
          <source>Integration constant(s). The value of the first integral at zero is the first value in the list, the value of the second integral at zero is the second value, etc. If &lt;code&gt;k == []&lt;/code&gt; (the default), all constants are set to zero. If &lt;code&gt;m == 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">积分常数。第一个整数为零的值是列表中的第一个值，第二个整数为零的值是第二个值， &lt;code&gt;k == []&lt;/code&gt; 。如果k == []（默认值），则所有常数都设置为零。如果 &lt;code&gt;m == 1&lt;/code&gt; ，则可以给出单个标量而不是列表。</target>
        </trans-unit>
        <trans-unit id="79199da79d91b1fb5aeec3ae95134c32578dd203" translate="yes" xml:space="preserve">
          <source>Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to &lt;code&gt;m&lt;/code&gt; in length and any missing values are set to zero.</source>
          <target state="translated">积分常数。第一个常量应用于第一个积分，第二个常量应用于第二个，依此类推。值列表的长度必须小于或等于 &lt;code&gt;m&lt;/code&gt; ，并且所有缺少的值都将设置为零。</target>
        </trans-unit>
        <trans-unit id="99a973b23f26b788591e237471230a61bc42bfca" translate="yes" xml:space="preserve">
          <source>Integration constants. They are given in the order of integration: those corresponding to highest-order terms come first.</source>
          <target state="translated">整合常数。它们按积分顺序给出:与最高阶项相对应的常数在前。</target>
        </trans-unit>
        <trans-unit id="f1b63b1b837d115daafc12c34b184fde445bf116" translate="yes" xml:space="preserve">
          <source>Integration of array values using the composite trapezoidal rule.</source>
          <target state="translated">利用复合梯形规则对数组值进行积分。</target>
        </trans-unit>
        <trans-unit id="272bd8e11d9a2557b005814cbc8295b6bce05913" translate="yes" xml:space="preserve">
          <source>Interaction with &lt;code&gt;scipy.sparse&lt;/code&gt; is a bit cleaner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5308846512dd05b3fe349862b884d3dad34184" translate="yes" xml:space="preserve">
          <source>Interchange two axes of an array.</source>
          <target state="translated">互换一个数组的两个轴。</target>
        </trans-unit>
        <trans-unit id="487fafdb343a2fa07aa1e904de9985413e377451" translate="yes" xml:space="preserve">
          <source>Interest paid against the loan changes during the life or the loan. The &lt;code&gt;per&lt;/code&gt; is the payment period to calculate the interest amount.</source>
          <target state="translated">借贷所支付的利息在存续期间或贷款中发生变化。在 &lt;code&gt;per&lt;/code&gt; 是支付周期来计算的利息金额。</target>
        </trans-unit>
        <trans-unit id="94a1603aa26be2dbffaf8cf5c3954f0266df1988" translate="yes" xml:space="preserve">
          <source>Interest portion of payment. If all input is scalar, returns a scalar float. If any input is array_like, returns interest payment for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="translated">支付的利息部分。如果所有输入都是标量,返回一个标量浮点数。如果任何输入是array_like,返回每个输入元素的利息支付。如果多个输入是array_like,它们必须具有相同的形状。</target>
        </trans-unit>
        <trans-unit id="fae2c1a639317094eef5fc0747acae252e47559d" translate="yes" xml:space="preserve">
          <source>Interest rate paid on the cash flows</source>
          <target state="translated">现金流支付的利率</target>
        </trans-unit>
        <trans-unit id="bac9f8f12cdd23938b9506adf721b640d1387b0f" translate="yes" xml:space="preserve">
          <source>Interest rate received on the cash flows upon reinvestment</source>
          <target state="translated">再投资时收到的现金流量利息率</target>
        </trans-unit>
        <trans-unit id="acbc7801b292b22fd84bb969c2c0f9ee879becf9" translate="yes" xml:space="preserve">
          <source>Interfacing to C</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5669f1ef998cb57e98a6c7c64ced935f3a20e1ba" translate="yes" xml:space="preserve">
          <source>Interfacing to C++:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef0659c2c669af8efd19f667b98f55614307e8e" translate="yes" xml:space="preserve">
          <source>Interfacing to Fortran:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1eb29a8757da9ba26cf2dfef44ad676331c673" translate="yes" xml:space="preserve">
          <source>Internal Flexibility</source>
          <target state="translated">内部灵活性</target>
        </trans-unit>
        <trans-unit id="ac2251ff80e959c9a76b1d8e25426050ad978681" translate="yes" xml:space="preserve">
          <source>Internal Rate of Return for periodic input values.</source>
          <target state="translated">定期输入值的内部收益率。</target>
        </trans-unit>
        <trans-unit id="70e52d12f616579455cc3db6303a1fc61cf8ea38" translate="yes" xml:space="preserve">
          <source>Internal changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="811920182b71e4d6c39f62829f0533afa24b5bfb" translate="yes" xml:space="preserve">
          <source>Internal functions</source>
          <target state="translated">内部职能</target>
        </trans-unit>
        <trans-unit id="ecdbace78f65adf7ab79aea820093f0235b38c83" translate="yes" xml:space="preserve">
          <source>Internal memory layout of an ndarray</source>
          <target state="translated">ndarray的内部内存布局</target>
        </trans-unit>
        <trans-unit id="4c771d77fd8a74b74dbd14733dbe89a221191139" translate="yes" xml:space="preserve">
          <source>Internal organization of numpy arrays</source>
          <target state="translated">numpy数组的内部组织</target>
        </trans-unit>
        <trans-unit id="8693ac81d62075b90be2f5012ceac7d5e0960c71" translate="yes" xml:space="preserve">
          <source>Internally used structures</source>
          <target state="translated">内部使用的结构</target>
        </trans-unit>
        <trans-unit id="353f9272117a257bd48156e257afe86724ce335c" translate="yes" xml:space="preserve">
          <source>Internally, buffers are used for misaligned data, swapped data, and data that has to be converted from one data type to another. The size of internal buffers is settable on a per-thread basis. There can be up to</source>
          <target state="translated">在内部,缓冲区用于错位数据、交换数据和必须从一种数据类型转换到另一种数据类型的数据。内部缓冲区的大小是可以按线程设置的。内部缓冲区的大小可以按线程设置,最多可以有</target>
        </trans-unit>
        <trans-unit id="0b9562a5febab6388bcaad8af8913734a30e5c69" translate="yes" xml:space="preserve">
          <source>Internally, the code uses some additional Python objects primarily for memory management. These types are not accessible directly from Python, and are not exposed to the C-API. They are included here only for completeness and assistance in understanding the code.</source>
          <target state="translated">在内部,代码使用了一些额外的 Python 对象,主要用于内存管理。这些类型不能直接从Python中访问,也没有暴露在C-API中。这里包含它们只是为了完整和帮助理解代码。</target>
        </trans-unit>
        <trans-unit id="88c585f236f03e4d85467407665675347bdfa2c1" translate="yes" xml:space="preserve">
          <source>Internally, these #defines work as follows:</source>
          <target state="translated">在内部,这些#定义的工作原理如下。</target>
        </trans-unit>
        <trans-unit id="2e02d69fdcfa7dd47d4e20a9c3718e372f145dcc" translate="yes" xml:space="preserve">
          <source>Interoperability-Related Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b400cd2b32800b89445114d966c1ee1e1e2f5b22" translate="yes" xml:space="preserve">
          <source>Interpolate a function at the Chebyshev points of the first kind.</source>
          <target state="translated">在第一种切比雪夫点上插值一个函数。</target>
        </trans-unit>
        <trans-unit id="b0124a6fa4961521e8ff39aa6c372018194a4ebf" translate="yes" xml:space="preserve">
          <source>Interpolating Chebyshev instance.</source>
          <target state="translated">穿插切比雪夫实例。</target>
        </trans-unit>
        <trans-unit id="1427e61ed742cbf9aa91a5c0cf7909917aab75eb" translate="yes" xml:space="preserve">
          <source>Interpolation with periodic x-coordinates:</source>
          <target state="translated">用周期性X坐标进行插值。</target>
        </trans-unit>
        <trans-unit id="437831e765e33b0f2fa769dfde52d2c581b5cfbf" translate="yes" xml:space="preserve">
          <source>Interpret a buffer as a 1-dimensional array.</source>
          <target state="translated">将缓冲区解释为一维数组。</target>
        </trans-unit>
        <trans-unit id="9feed02e3d661ed814b67ed529ab9195e31b0cb4" translate="yes" xml:space="preserve">
          <source>Interpret the input as a matrix.</source>
          <target state="translated">将输入的内容解释为矩阵。</target>
        </trans-unit>
        <trans-unit id="a0422cc647bba954b177a29fbf1305b2895860e3" translate="yes" xml:space="preserve">
          <source>Interrupt Handling</source>
          <target state="translated">中断处理</target>
        </trans-unit>
        <trans-unit id="e5f5d0f73f8dc2d6363a75fe32ba76d7d8dff9cc" translate="yes" xml:space="preserve">
          <source>Intrinsic NumPy Array Creation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e2ea7ccd882296e2e16cdecb01f04008d30cfc7" translate="yes" xml:space="preserve">
          <source>Intrinsic numpy array creation objects (e.g., arange, ones, zeros, etc.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd3fd94e72c882e4eaa006cb5da780542c07011" translate="yes" xml:space="preserve">
          <source>Introduce yourself to Git:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="b6ab6d57043280ab296716031275867d148d3ca7" translate="yes" xml:space="preserve">
          <source>Introduction to byte ordering and ndarrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24583ffa86b443c7a55325e4b25e34083f63ac92" translate="yes" xml:space="preserve">
          <source>Invalid arguments for array ordering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46dbc8721ef190eab06879ef282ac69a2d11056b" translate="yes" xml:space="preserve">
          <source>Invalid data means values of &lt;code&gt;nan&lt;/code&gt;, &lt;code&gt;inf&lt;/code&gt;, etc.</source>
          <target state="translated">无效数据表示 &lt;code&gt;nan&lt;/code&gt; ， &lt;code&gt;inf&lt;/code&gt; 等值。</target>
        </trans-unit>
        <trans-unit id="b66a9668314f5851a31b3926b89142340d67c1e0" translate="yes" xml:space="preserve">
          <source>Invalid fill value exceptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd811ad3cf2203333b0468d5361ce3f92b716aa" translate="yes" xml:space="preserve">
          <source>Invalid operation: result is not an expressible number, typically indicates that a NaN was produced.</source>
          <target state="translated">无效操作:结果不是一个可表示的数字,通常表示产生了一个NaN。</target>
        </trans-unit>
        <trans-unit id="dfed6b5bd73798f6efbc4f77cde7ac568bd5cdfb" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine, element-wise.</source>
          <target state="translated">逆双曲余弦,元素方面。</target>
        </trans-unit>
        <trans-unit id="21de990f2f734fbb43aa31870f6cebb10139a34e" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine element-wise.</source>
          <target state="translated">逆双曲正弦元的方式。</target>
        </trans-unit>
        <trans-unit id="ae6bb16d1805cc3ebef5cfaf633f1f868061a8dc" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent element-wise.</source>
          <target state="translated">逆双曲正切元素方面。</target>
        </trans-unit>
        <trans-unit id="2c6d3ed37e9c36a516eafee4d6cf6bce8fa583e5" translate="yes" xml:space="preserve">
          <source>Inverse sine, element-wise.</source>
          <target state="translated">反正弦,元素方面。</target>
        </trans-unit>
        <trans-unit id="9b049bc33b3f3b47e868bbdc217dc4db5fb5be2d" translate="yes" xml:space="preserve">
          <source>Inverses of several matrices can be computed at once:</source>
          <target state="translated">可以同时计算多个矩阵的反值。</target>
        </trans-unit>
        <trans-unit id="bafff722f42fe9db3b595ab6ea0bb84953a6e8ad" translate="yes" xml:space="preserve">
          <source>Investigate. Change directory to your new repo: &lt;code&gt;cd numpy&lt;/code&gt;. Then &lt;code&gt;git branch -a&lt;/code&gt; to show you all branches. You&amp;rsquo;ll get something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="525b73c1bc26402f8fe2106a7fc0623195c4b729" translate="yes" xml:space="preserve">
          <source>Is equivalent to &lt;code&gt;np.delete(arr, [0,2,4], axis=0)&lt;/code&gt;, but allows further use of &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;np.delete(arr, [0,2,4], axis=0)&lt;/code&gt; ，但允许进一步使用 &lt;code&gt;mask&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24c5caf7c1723177101292b0ec91f3f69f7573df" translate="yes" xml:space="preserve">
          <source>Is straightforward to reverse engineer. Datasets often live longer than the programs that created them. A competent developer should be able to create a solution in their preferred programming language to read most &lt;code&gt;.npy&lt;/code&gt; files that he has been given without much documentation.</source>
          <target state="translated">对逆向工程师很简单。数据集的寿命通常比创建它们的程序更长。一个有能力的开发人员应该能够使用他们喜欢的编程语言创建一个解决方案，以读取他在没有太多文档的情况下获得的大多数 &lt;code&gt;.npy&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="1a81d4101d801108adb8aad8206475022e2e35b0" translate="yes" xml:space="preserve">
          <source>Is the given function something that we know how to overload?</source>
          <target state="translated">给定的函数是我们知道如何重载的吗?</target>
        </trans-unit>
        <trans-unit id="b10180fbee8cac98fb1ea7940ed518f48a70dee3" translate="yes" xml:space="preserve">
          <source>Issued by &lt;a href=&quot;generated/numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; when the Vandermonde matrix is rank deficient.</source>
          <target state="translated">当Vandermonde矩阵秩不足时，由&lt;a href=&quot;generated/numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt;发出。</target>
        </trans-unit>
        <trans-unit id="2c7da8ef717a7e944f5132cdc9e7ea084630c1b8" translate="yes" xml:space="preserve">
          <source>Issued by &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; when the Vandermonde matrix is rank deficient.</source>
          <target state="translated">当Vandermonde矩阵秩不足时，由&lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt;发出。</target>
        </trans-unit>
        <trans-unit id="62ecce1ee2f04057e107579d5bef99ec7e6758b0" translate="yes" xml:space="preserve">
          <source>Issued by chebfit when the design matrix is rank deficient.</source>
          <target state="translated">当设计矩阵存在等级缺失时,由chebfit发出。</target>
        </trans-unit>
        <trans-unit id="ed3a53b09f923a24c6dd04195732883fc05144f5" translate="yes" xml:space="preserve">
          <source>Issued by the generic Poly class when two domains don&amp;rsquo;t match.</source>
          <target state="translated">当两个域不匹配时，由通用Poly类发出。</target>
        </trans-unit>
        <trans-unit id="f00ecef77fb41ae5e26098e89f064e811f1d6ae9" translate="yes" xml:space="preserve">
          <source>Issues Fixed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b19e94cfda274542200371fca470c64546558300" translate="yes" xml:space="preserve">
          <source>Issues a DeprecationWarning, adds warning to &lt;code&gt;old_name&lt;/code&gt;&amp;rsquo;s docstring, rebinds &lt;code&gt;old_name.__name__&lt;/code&gt; and returns the new function object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ddf288870dda342df98b4b9313d3dcfea4defcb" translate="yes" xml:space="preserve">
          <source>Issues fixed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee1de34f5e6dfdd4c0e68ce69b1f31528f724f6" translate="yes" xml:space="preserve">
          <source>It can also be used in places of &lt;a href=&quot;numpy.atleast_1d#numpy.atleast_1d&quot;&gt;&lt;code&gt;atleast_1d&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.atleast_2d#numpy.atleast_2d&quot;&gt;&lt;code&gt;atleast_2d&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">也可以在&lt;a href=&quot;numpy.atleast_1d#numpy.atleast_1d&quot;&gt; &lt;code&gt;atleast_1d&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.atleast_2d#numpy.atleast_2d&quot;&gt; &lt;code&gt;atleast_2d&lt;/code&gt; 的&lt;/a&gt;地方使用</target>
        </trans-unit>
        <trans-unit id="378d5136b02c66ae2366b0871c9dc87a59e458eb" translate="yes" xml:space="preserve">
          <source>It can be considered as a generalization of EPS: &lt;code&gt;spacing(np.float64(1)) == np.finfo(np.float64).eps&lt;/code&gt;, and there should not be any representable number between &lt;code&gt;x + spacing(x)&lt;/code&gt; and x for any finite x.</source>
          <target state="translated">可以将其视为EPS的一般化： &lt;code&gt;spacing(np.float64(1)) == np.finfo(np.float64).eps&lt;/code&gt; ，并且 &lt;code&gt;x + spacing(x)&lt;/code&gt; interval （x）和x 之间不应有任何可表示的数字任何有限的x。</target>
        </trans-unit>
        <trans-unit id="1ef0650f598bd8c46d6488dc9e1ecf7f36a57c12" translate="yes" xml:space="preserve">
          <source>It can be shown that a convolution</source>
          <target state="translated">可以证明,卷积</target>
        </trans-unit>
        <trans-unit id="3a39f7205319edd1c303f4671f99c8c35d8b49e6" translate="yes" xml:space="preserve">
          <source>It can be shown that if</source>
          <target state="translated">可以看出,如果</target>
        </trans-unit>
        <trans-unit id="6680413ecf8178af7a6bc1c7bc275bc8809885e1" translate="yes" xml:space="preserve">
          <source>It differs from the forward transform by the sign of the exponential argument and the default normalization by</source>
          <target state="translated">它与正向变换的不同之处在于指数参数的符号和默认的归一化。</target>
        </trans-unit>
        <trans-unit id="d2a43fea3528f404f8930330d870fe7079aa62c4" translate="yes" xml:space="preserve">
          <source>It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true.</source>
          <target state="translated">它并&lt;em&gt;没有&lt;/em&gt;普遍认为， &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; 为C语言风格的连续阵列或 &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; Fortran的风格的连续阵列是真实的。</target>
        </trans-unit>
        <trans-unit id="47be37fff5f8f22af765f82be2c6bfbaf9c3032a" translate="yes" xml:space="preserve">
          <source>It has the following structure:</source>
          <target state="translated">它的结构如下:</target>
        </trans-unit>
        <trans-unit id="9d66b7021aa904bae4cfae41aeb4ea6450db47e9" translate="yes" xml:space="preserve">
          <source>It has the probability density function</source>
          <target state="translated">它的概率密度函数为</target>
        </trans-unit>
        <trans-unit id="8df067c80d1dbac7caebbaa192d51d71072198f4" translate="yes" xml:space="preserve">
          <source>It helps to understand a bit about how numpy arrays are handled under the covers to help understand numpy better. This section will not go into great detail. Those wishing to understand the full details are referred to Travis Oliphant&amp;rsquo;s book &amp;ldquo;Guide to NumPy&amp;rdquo;.</source>
          <target state="translated">它有助于您了解一些有关如何处理numpy数组的知识，以帮助您更好地理解numpy。本节将不会详细介绍。那些希望了解所有详细信息的人，请参考Travis Oliphant的书&amp;ldquo; NumPy指南&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2fbb89405ce29cc8160fa307e221950fa152cd3e" translate="yes" xml:space="preserve">
          <source>It is also possible to select more than one item at a time, using &lt;em&gt;slicing&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6785902c796379d2b6f1ca680d1350c037d297a" translate="yes" xml:space="preserve">
          <source>It is an error to have index values out of bounds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd3e350ace36c053f4770c254bc8bbc0ed59492" translate="yes" xml:space="preserve">
          <source>It is assumed that all indices of &lt;code&gt;x&lt;/code&gt; are summed over in the product, together with the rightmost indices of &lt;code&gt;a&lt;/code&gt;, as is done in, for example, &lt;code&gt;tensordot(a, x, axes=b.ndim)&lt;/code&gt;.</source>
          <target state="translated">假定所有索引 &lt;code&gt;x&lt;/code&gt; 被求和在产物中，用的最右索引一起 &lt;code&gt;a&lt;/code&gt; ，如在完成，例如， &lt;code&gt;tensordot(a, x, axes=b.ndim)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58008c74c97fe4d3ae3f9ae78ab47043dddec099" translate="yes" xml:space="preserve">
          <source>It is available from:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca7dcbab26b74b24d5b23e3d1dfbaa7bb550a61f" translate="yes" xml:space="preserve">
          <source>It is convenient to use &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; objects for dealing with polynomials:</source>
          <target state="translated">使用&lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt;对象处理多项式很方便：</target>
        </trans-unit>
        <trans-unit id="ee3d89b7c311757a10611a623afead7359a99d73" translate="yes" xml:space="preserve">
          <source>It is convenient to use &lt;code&gt;poly1d&lt;/code&gt; objects for dealing with polynomials:</source>
          <target state="translated">使用 &lt;code&gt;poly1d&lt;/code&gt; 对象处理多项式很方便：</target>
        </trans-unit>
        <trans-unit id="f0b5d505c1b6aa0449adcda591bae28c54d28b79" translate="yes" xml:space="preserve">
          <source>It is difficult to distribute an extension module made using ctypes because of a lack of support for building shared libraries in distutils (but I suspect this will change in time).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6233db9ea353c629e411da73701b45f43b34d4b" translate="yes" xml:space="preserve">
          <source>It is easy to lose a clean separation between Python and C which makes re-using your C-code for other non-Python-related projects more difficult.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09772c45572066c0ab1839c5da61b341c459c08d" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;reshape(-1, order=order)&lt;/code&gt;.</source>
          <target state="translated">它等效于 &lt;code&gt;reshape(-1, order=order)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8649182deb90f9e5b82c97ccd124c9f5e91bbefa" translate="yes" xml:space="preserve">
          <source>It is expected that function &lt;code&gt;func&lt;/code&gt; has been defined externally. In order to use a Python function as &lt;code&gt;func&lt;/code&gt;, it must have an attribute &lt;code&gt;intent(callback)&lt;/code&gt; (it must be specified before the &lt;code&gt;external&lt;/code&gt; statement).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41074d06eaa1aca6cfcc81add0a6d4a0de1496e0" translate="yes" xml:space="preserve">
          <source>It is expected that the Council Members will be employed at a wide range of companies, universities and non-profit organizations. Because of this, it is possible that Members will have conflict of interests. Such conflict of interests include, but are not limited to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e897ba8d8d1e35fdbcdafccfd6dd8ffccaf71314" translate="yes" xml:space="preserve">
          <source>It is good practice to tell &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; who you are, for labeling any changes you make to the code. The simplest way to do this is from the command line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c72b281ec77874c2a8219572de87ebec10916f2" translate="yes" xml:space="preserve">
          <source>It is important to keep in mind that you get a &lt;em&gt;borrowed&lt;/em&gt; reference to the object when using the &amp;ldquo;O&amp;rdquo; format string. However, the converter functions usually require some form of memory handling. In this example, if the conversion is successful, &lt;em&gt;dtype&lt;/em&gt; will hold a new reference to a &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; object, while &lt;em&gt;input&lt;/em&gt; will hold a borrowed reference. Therefore, if this conversion were mixed with another conversion (say to an integer) and the data-type conversion was successful but the integer conversion failed, then you would need to release the reference count to the data-type object before returning. A typical way to do this is to set &lt;em&gt;dtype&lt;/em&gt; to &lt;code&gt;NULL&lt;/code&gt; before calling &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; and then use &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_XDECREF&quot;&gt;&lt;code&gt;Py_XDECREF&lt;/code&gt;&lt;/a&gt; on &lt;em&gt;dtype&lt;/em&gt; before returning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e5e295697e350544ce52515eda2757f41a1612" translate="yes" xml:space="preserve">
          <source>It is important to keep the flags updated (using &lt;a href=&quot;#c.PyArray_UpdateFlags&quot;&gt;&lt;code&gt;PyArray_UpdateFlags&lt;/code&gt;&lt;/a&gt; can help) whenever a manipulation with an array is performed that might cause them to change. Later calculations in NumPy that rely on the state of these flags do not repeat the calculation to update them.</source>
          <target state="translated">每当对数组执行可能会导致其更改的标志时，保持标志更新（使用&lt;a href=&quot;#c.PyArray_UpdateFlags&quot;&gt; &lt;code&gt;PyArray_UpdateFlags&lt;/code&gt; &lt;/a&gt;会有所帮助）很重要。以后依赖于这些标志状态的NumPy中的计算不会重复计算以更新它们。</target>
        </trans-unit>
        <trans-unit id="6dd28e38486b7b23cc628bcffec168f7a3e2908d" translate="yes" xml:space="preserve">
          <source>It is important to note that once the iterator is exited, dangling references (like &lt;code&gt;x&lt;/code&gt; in the example) may or may not share data with the original data &lt;code&gt;a&lt;/code&gt;. If writeback semantics were active, i.e. if &lt;code&gt;x.base.flags.writebackifcopy&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then exiting the iterator will sever the connection between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, writing to &lt;code&gt;x&lt;/code&gt; will no longer write to &lt;code&gt;a&lt;/code&gt;. If writeback semantics are not active, then &lt;code&gt;x.data&lt;/code&gt; will still point at some part of &lt;code&gt;a.data&lt;/code&gt;, and writing to one will affect the other.</source>
          <target state="translated">重要的是要注意，一旦退出迭代器，悬空引用（例如示例中的 &lt;code&gt;x&lt;/code&gt; ）可能会或可能不会与原始数据 &lt;code&gt;a&lt;/code&gt; 共享数据。如果写回语义处于活动状态，即 &lt;code&gt;x.base.flags.writebackifcopy&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则退出迭代器将切断 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;a&lt;/code&gt; 之间的连接，写给 &lt;code&gt;x&lt;/code&gt; 将不再写给 &lt;code&gt;a&lt;/code&gt; 。如果写回语义不处于活动状态，则 &lt;code&gt;x.data&lt;/code&gt; 仍将指向 &lt;code&gt;a.data&lt;/code&gt; 的某些部分，而写一个将影响另一个。</target>
        </trans-unit>
        <trans-unit id="63bda28ddda57fde741844f509673a49e4004752" translate="yes" xml:space="preserve">
          <source>It is important to retain an archive of all activities of this committee to ensure consistency in behavior and provide institutional memory for the project. To assist in this, the default channel of discussion for this committee will be a private mailing list accessible to current and future members of the committee as well as members of the Steering Council upon justified request. If the Committee finds the need to use off-list communications (e.g. phone calls for early/rapid response), it should in all cases summarize these back to the list so there&amp;rsquo;s a good record of the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a263f6ef91dbde8a42fa624ef445c812e662a622" translate="yes" xml:space="preserve">
          <source>It is intended that all polynomial instances are immutable, therefore augmented operations (&lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, etc.) and any other functionality that would violate the immutablity of a polynomial instance are intentionally unimplemented.</source>
          <target state="translated">意图是所有多项式实例都是不可变的，因此有意地未实现增强操作（ &lt;code&gt;+=&lt;/code&gt; ， &lt;code&gt;-=&lt;/code&gt; 等）以及任何违反多项式实例的不变性的功能。</target>
        </trans-unit>
        <trans-unit id="8b8f2e17893170efcb86b57f32479a3f40a7b944" translate="yes" xml:space="preserve">
          <source>It is named for the American linguist George Kingsley Zipf, who noted that the frequency of any word in a sample of a language is inversely proportional to its rank in the frequency table.</source>
          <target state="translated">它是以美国语言学家乔治-金斯利-齐普夫的名字命名的,他指出,在一种语言的样本中,任何一个词的频率与它在频率表中的等级成反比。</target>
        </trans-unit>
        <trans-unit id="21e4b23be2d40c69036b3d2e468ea13e53868304" translate="yes" xml:space="preserve">
          <source>It is no longer recommended to use this class, even for linear</source>
          <target state="translated">我们不再推荐使用这个类,即使是线性的。</target>
        </trans-unit>
        <trans-unit id="c8350ce47be17c20baa97fc4d0754bec81b2f208" translate="yes" xml:space="preserve">
          <source>It is no longer recommended to use this class, even for linear algebra. Instead use regular arrays. The class may be removed in the future.</source>
          <target state="translated">即使是线性代数,也不建议再使用这个类。取而代之的是使用常规数组。该类将来可能会被删除。</target>
        </trans-unit>
        <trans-unit id="8c5239a5bff654c37cc55078706d5d6b20118c0c" translate="yes" xml:space="preserve">
          <source>It is not always possible to change the shape of an array without copying the data. If you want an error to be raised when the data is copied, you should assign the new shape to the shape attribute of the array:</source>
          <target state="translated">并非总是可以在不复制数据的情况下改变数组的形状。如果你希望在复制数据时出现错误,你应该将新的形状分配给数组的形状属性。</target>
        </trans-unit>
        <trans-unit id="656bf2f4ae8187e5defb4f5552faf2fbd1f5fad1" translate="yes" xml:space="preserve">
          <source>It is not difficult to create your own ufunc. All that is required is a 1-d loop for each data-type you want to support. Each 1-d loop must have a specific signature, and only ufuncs for fixed-size data-types can be used. The function call used to create a new ufunc to work on built-in data-types is given below. A different mechanism is used to register ufuncs for user-defined data-types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8b548648b06bad09d9ab843a8e5797d1798c5b5" translate="yes" xml:space="preserve">
          <source>It is not necessary to use the doctest markup &lt;code&gt;&amp;lt;BLANKLINE&amp;gt;&lt;/code&gt; to indicate empty lines in the output. Note that the option to run the examples through &lt;code&gt;numpy.test&lt;/code&gt; is provided for checking if the examples work, not for making the examples part of the testing framework.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37f77a2246e7fcb1e0b4774efe6b903d4205875" translate="yes" xml:space="preserve">
          <source>It is often seen in Bayesian inference and order statistics.</source>
          <target state="translated">它经常出现在贝叶斯推理和顺序统计中。</target>
        </trans-unit>
        <trans-unit id="7bef780e922069dd57c2e5a08856175d82409e4f" translate="yes" xml:space="preserve">
          <source>It is one of a class of extreme value distributions, the Generalized Extreme Value (GEV) distributions, which also includes the Weibull and Frechet.</source>
          <target state="translated">它是一类极值分布,即广义极值(GEV)分布中的一种,它还包括Weibull和Frechet。</target>
        </trans-unit>
        <trans-unit id="5071b59a11ab8c54d2368dbe31b14e825424a9ec" translate="yes" xml:space="preserve">
          <source>It is possible to index arrays with other arrays for the purposes of selecting lists of values out of arrays into new arrays. There are two different ways of accomplishing this. One uses one or more arrays of index values. The other involves giving a boolean array of the proper shape to indicate the values to be selected. Index arrays are a very powerful tool that allow one to avoid looping over individual elements in arrays and thus greatly improve performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36000cdc40cdbba3e0e5f28ba7dcb30e267b4506" translate="yes" xml:space="preserve">
          <source>It is possible to load a library using &amp;gt;&amp;gt;&amp;gt; lib = ctypes.cdll[&amp;lt;full_path_name&amp;gt;] # doctest: +SKIP</source>
          <target state="translated">可以使用&amp;gt;&amp;gt;&amp;gt; lib = ctypes.cdll [&amp;lt;full_path_name&amp;gt;]＃doctest：+ SKIP加载库</target>
        </trans-unit>
        <trans-unit id="38fbbd2c67dc08fbfcb5c5de50ecf788043a91ae" translate="yes" xml:space="preserve">
          <source>It is possible to slice and stride arrays to extract arrays of the same number of dimensions, but of different sizes than the original. The slicing and striding works exactly the same way it does for lists and tuples except that they can be applied to multiple dimensions as well. A few examples illustrates best:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a211923eef6c9018ec875b45f1ee8aa7feb24f0" translate="yes" xml:space="preserve">
          <source>It is possible to specify config_fc options in setup.py scripts. For example, using</source>
          <target state="translated">可以在setup.py脚本中指定config_fc选项。例如,使用</target>
        </trans-unit>
        <trans-unit id="3af7692eade07c544a49c1e0a3fa2b4f67d86e02" translate="yes" xml:space="preserve">
          <source>It is possible to specify how boundaries are treated using &lt;code&gt;edge_order&lt;/code&gt;</source>
          <target state="translated">可以指定使用 &lt;code&gt;edge_order&lt;/code&gt; 处理边界的方式</target>
        </trans-unit>
        <trans-unit id="425695dd90c5cd68dc182714b9d0871e6107582e" translate="yes" xml:space="preserve">
          <source>It is possible to use methods from linear algebra to approximate an existing set of data. Here, we will use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Singular_value_decomposition&quot;&gt;SVD (Singular Value Decomposition)&lt;/a&gt; to try to rebuild an image that uses less singular value information than the original one, while still retaining some of its features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9279d7909405dcb9e4e547b0701fbd4a212eac71" translate="yes" xml:space="preserve">
          <source>It is possible to use special features to effectively increase the number of dimensions in an array through indexing so the resulting array acquires the shape needed for use in an expression or with a specific function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="006848dc30e65d20b3919e74b2fa41c8170663f6" translate="yes" xml:space="preserve">
          <source>It is recommended to use one of &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt;&lt;code&gt;assert_allclose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.testing.assert_array_almost_equal_nulp#numpy.testing.assert_array_almost_equal_nulp&quot;&gt;&lt;code&gt;assert_array_almost_equal_nulp&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.testing.assert_array_max_ulp#numpy.testing.assert_array_max_ulp&quot;&gt;&lt;code&gt;assert_array_max_ulp&lt;/code&gt;&lt;/a&gt; instead of this function for more consistent floating point comparisons.</source>
          <target state="translated">为了更一致的浮点比较，建议使用&lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt; &lt;code&gt;assert_allclose&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.testing.assert_array_almost_equal_nulp#numpy.testing.assert_array_almost_equal_nulp&quot;&gt; &lt;code&gt;assert_array_almost_equal_nulp&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;numpy.testing.assert_array_max_ulp#numpy.testing.assert_array_max_ulp&quot;&gt; &lt;code&gt;assert_array_max_ulp&lt;/code&gt; 之一&lt;/a&gt;代替此函数。</target>
        </trans-unit>
        <trans-unit id="e411ddee11ac634d5c4281835040dc7466b061ac" translate="yes" xml:space="preserve">
          <source>It is strongly advised &lt;em&gt;not&lt;/em&gt; to use the matrix subclass. As described below, it makes writing functions that deal consistently with matrices and regular arrays very difficult. Currently, they are mainly used for interacting with &lt;code&gt;scipy.sparse&lt;/code&gt;. We hope to provide an alternative for this use, however, and eventually remove the &lt;code&gt;matrix&lt;/code&gt; subclass.</source>
          <target state="translated">强烈建议&lt;em&gt;不要&lt;/em&gt;使用矩阵子类。如下所述，这使得编写处理矩阵和规则数组的函数非常困难。当前，它们主要用于与 &lt;code&gt;scipy.sparse&lt;/code&gt; 进行交互。但是，我们希望为此提供一种替代方法，并最终删除 &lt;code&gt;matrix&lt;/code&gt; 子类。</target>
        </trans-unit>
        <trans-unit id="7669de0e65d605729606ade6c00d09dc551353c4" translate="yes" xml:space="preserve">
          <source>It is used, for example, in modeling the over-reporting of insurance claims.</source>
          <target state="translated">例如,它被用于模拟保险索赔的过度报告。</target>
        </trans-unit>
        <trans-unit id="ca0ecc89a435e5703a52f043959e28e66dbb2433" translate="yes" xml:space="preserve">
          <source>It is useful for writing classes that do not inherit from &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, but that should support arithmetic and numpy universal functions like arrays as described in &lt;a href=&quot;../../neps/nep-0013-ufunc-overrides&quot;&gt;A Mechanism for Overriding Ufuncs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e32c0ef1527073446df56f2f6fdb74c9774fe25a" translate="yes" xml:space="preserve">
          <source>It is useful for writing classes that do not inherit from &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, but that should support arithmetic and numpy universal functions like arrays as described in &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/neps/nep-0013-ufunc-overrides.html&quot;&gt;A Mechanism for Overriding Ufuncs&lt;/a&gt;.</source>
          <target state="translated">这对于编写不继承自&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; 的&lt;/a&gt;类很有用，但该类应支持算术和numpy通用函数，例如数组，如&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/neps/nep-0013-ufunc-overrides.html&quot;&gt;覆盖Ufuncs的机制中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3b8ad76686cc18b830ba552fba24082c4f933e5" translate="yes" xml:space="preserve">
          <source>It is worth noting that if</source>
          <target state="translated">值得注意的是,如果</target>
        </trans-unit>
        <trans-unit id="29b82dd1d6f270f96b8bc45104bc41a8e589f966" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t always convenient to explicitly use Polynomial instances, so tuples, lists, arrays, and scalars are automatically cast in the arithmetic operations:</source>
          <target state="translated">显式使用多项式实例并不总是很方便，因此元组，列表，数组和标量会在算术运算中自动进行转换：</target>
        </trans-unit>
        <trans-unit id="cf495221779c2163a5e7a39d1bf1b540324c978b" translate="yes" xml:space="preserve">
          <source>It landed 4 times on 1, once on 2, etc.</source>
          <target state="translated">1上落地4次,2上落地1次等。</target>
        </trans-unit>
        <trans-unit id="d1653963d10a9096aa75746f96dbe0fd1387381e" translate="yes" xml:space="preserve">
          <source>It may also be convenient to define a custom decorators (&lt;code&gt;implements&lt;/code&gt; below) for registering &lt;code&gt;__array_function__&lt;/code&gt; implementations.</source>
          <target state="translated">定义用于注册 &lt;code&gt;__array_function__&lt;/code&gt; 实现的自定义装饰器（下面的 &lt;code&gt;implements&lt;/code&gt; ）也可能很方便。</target>
        </trans-unit>
        <trans-unit id="3598c5e5543d6be85e81adfe21a8be7084de89d0" translate="yes" xml:space="preserve">
          <source>It may be preferable to split the projected cashflow into an initial investment and expected future cashflows. In this case, the value of the initial cashflow is zero and the initial investment is later added to the future cashflows net present value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c144448b26d1bb5e1e573955f886137b35b8bc6" translate="yes" xml:space="preserve">
          <source>It may be the case that while you were working on your edits, new commits have been added to &lt;code&gt;upstream&lt;/code&gt; that affect your work. In this case, follow the &lt;a href=&quot;#rebasing-on-master&quot;&gt;Rebasing on master&lt;/a&gt; section of this document to apply those changes to your branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a2cf7173d1c99310b82e23b09fc16ccfa711fb" translate="yes" xml:space="preserve">
          <source>It often happens that the memory that you want to view with an array is not of the same byte ordering as the computer on which you are running Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaadd007be7687e8c25f3eb461c4399e71de7888" translate="yes" xml:space="preserve">
          <source>It should be clear that any structured type could be described using this interface.</source>
          <target state="translated">应该清楚的是,任何结构化类型都可以用这个接口来描述。</target>
        </trans-unit>
        <trans-unit id="40b700e9c3136bc2579dd22e6d2f087fce1952e9" translate="yes" xml:space="preserve">
          <source>It should be emphasized at this point that you may not need the array iterator if your array is already contiguous (using an array iterator will work but will be slower than the fastest code you could write). The major purpose of array iterators is to encapsulate iteration over N-dimensional arrays with arbitrary strides. They are used in many, many places in the NumPy source code itself. If you already know your array is contiguous (Fortran or C), then simply adding the element- size to a running pointer variable will step you through the array very efficiently. In other words, code like this will probably be faster for you in the contiguous case (assuming doubles).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026d73ab6dffc63b48ab1902fa6d889c8def5bcb" translate="yes" xml:space="preserve">
          <source>It uses a &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; rather than the more modern &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18504c66aebcc566a9cf5db146c843b0920c0fed" translate="yes" xml:space="preserve">
          <source>It uses global state, which means results will change as the code changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f377563feb8e5b75d15a1cc4f00304a3153cefc3" translate="yes" xml:space="preserve">
          <source>It works in 2-D as well:</source>
          <target state="translated">它在2-D中也可以使用。</target>
        </trans-unit>
        <trans-unit id="e168152d8a6d565c340c6f98aabefe43987e5068" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to need to transpose your matrices. NumPy arrays have the property &lt;code&gt;T&lt;/code&gt; that allows you to transpose a matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a604443bcd6724527af1c5d434ed815a21fd057" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to save and load and array with &lt;code&gt;np.save()&lt;/code&gt;. Just make sure to specify the array you want to save and a file name. For example, if you create this array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5dacd50e546c91bb0023917cb217930a8f4581" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to assign to copy-on-write array, but values are only written into the memory copy of the array, and not written to disk:</source>
          <target state="translated">可以分配给写时复制数组，但是值仅写入数组的内存副本，而不写入磁盘：</target>
        </trans-unit>
        <trans-unit id="2a0ce98ff31bde352ed1c0c91f62805b6675f308" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to do a parallel build with &lt;code&gt;numpy.distutils&lt;/code&gt; with the &lt;code&gt;-j&lt;/code&gt; option; see &lt;a href=&quot;../user/building#parallel-builds&quot;&gt;Parallel builds&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4121d3718e690b8fea8d720656c256ae8ee8cf80" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to do a parallel build with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a92fc5de8c1d7511c762594edc421f16b236424" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s recommended to specify only those config_fc options in such a way that are compiler independent.</source>
          <target state="translated">建议仅以与编译器无关的方式指定那些config_fc选项。</target>
        </trans-unit>
        <trans-unit id="0753c18f0b1243f25af624a4511a2035947276c3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s simple to read in a CSV that contains existing information. The best and easiest way to do this is to use &lt;a href=&quot;https://pandas.pydata.org/getpandas.html&quot;&gt;Pandas&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14495a2289a19a1e28ed57bed5a4a3a49edf0b4e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s simple to use Pandas in order to export your array as well. If you are new to NumPy, you may want to create a Pandas dataframe from the values in your array and then write the data frame to a CSV file with Pandas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060cec9479c0c03cb8146120d17fc1e1fd50e074" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s usually a good idea to use the &lt;code&gt;-n&lt;/code&gt; flag to &lt;code&gt;git push&lt;/code&gt; to check first that you&amp;rsquo;re about to push the changes you want to the place you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85be1e8acbcf441a36b9c0c869cff5476c693c32" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s very common to want to aggregate along a row or column. By default, every NumPy aggregation function will return the aggregate of the entire array. To find the sum or the minimum of the elements in your array, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a9e71b0cabb8c3a03cd16e13045b08078788b6" translate="yes" xml:space="preserve">
          <source>Item selection and manipulation</source>
          <target state="translated">项目选择和操作</target>
        </trans-unit>
        <trans-unit id="867490709f6ff3383fa1fcfac4368fffd68d75ba" translate="yes" xml:space="preserve">
          <source>Items of an array of this data type are wrapped in an &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar&lt;/a&gt; type that also has two fields:</source>
          <target state="translated">此数据类型的数组的项目包装在也有两个字段的&lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;数组标量&lt;/a&gt;类型中：</target>
        </trans-unit>
        <trans-unit id="7b5cbf04c6d27c2ce2fa2026bd76b8e62a482e6d" translate="yes" xml:space="preserve">
          <source>Iterating Over Arrays</source>
          <target state="translated">在数组上迭代</target>
        </trans-unit>
        <trans-unit id="61c7e36ee871033d37342fea4c9a477a22a3ad15" translate="yes" xml:space="preserve">
          <source>Iterating as a Specific Data Type</source>
          <target state="translated">迭代作为一个特定的数据类型</target>
        </trans-unit>
        <trans-unit id="d0332abd31d07a7d02dd3e33350dc402dcd2926d" translate="yes" xml:space="preserve">
          <source>Iterating over all but one axis</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1844648c4af60a1a170cdaf38688443ce7ba666d" translate="yes" xml:space="preserve">
          <source>Iterating over arrays</source>
          <target state="translated">迭代数组</target>
        </trans-unit>
        <trans-unit id="b05284699d8fb62b19954c2a16145ceb83ef59a3" translate="yes" xml:space="preserve">
          <source>Iterating over elements in the array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8467929e39862040c3a1bba747525fbb89952c" translate="yes" xml:space="preserve">
          <source>Iterating over multiple arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c8101d6360b4040707379e2577c7a16fa0bf84e" translate="yes" xml:space="preserve">
          <source>Iteration is done in row-major, C-style order (the last index varying the fastest). The iterator can also be indexed using basic slicing or advanced indexing.</source>
          <target state="translated">迭代是按照行主、C式的顺序进行的(最后一个索引变化最快)。迭代器也可以使用基本分片或高级索引进行索引。</target>
        </trans-unit>
        <trans-unit id="acbcdc45d250ba7dd26edab06186cf3962745972" translate="yes" xml:space="preserve">
          <source>Iterator Data Types</source>
          <target state="translated">迭代器数据类型</target>
        </trans-unit>
        <trans-unit id="21aa412ed70b91ee6a2ff89a4abea36c2af42360" translate="yes" xml:space="preserve">
          <source>Iterator flag &lt;a href=&quot;#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">迭代器标志&lt;a href=&quot;#c.NPY_ITER_COMMON_DTYPE&quot;&gt; &lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1116d7dda5125208b276ad5471ddd5d08e64ba8" translate="yes" xml:space="preserve">
          <source>Iterator flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">迭代器标志&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b6f69b38ac0228e9245d67b9b1d09ee42bc5dcb" translate="yes" xml:space="preserve">
          <source>Iterator for broadcasting</source>
          <target state="translated">广播用迭代器</target>
        </trans-unit>
        <trans-unit id="6425854ab104811d699d59fa557478463a96d42e" translate="yes" xml:space="preserve">
          <source>Iterator-Allocated Output Arrays</source>
          <target state="translated">迭代器分配的输出数组</target>
        </trans-unit>
        <trans-unit id="3ea20b9878659e33fbac6ee844497cef84a926f4" translate="yes" xml:space="preserve">
          <source>Iterators are a powerful concept for array processing. Essentially, iterators implement a generalized for-loop. If &lt;em&gt;myiter&lt;/em&gt; is an iterator object, then the Python code:</source>
          <target state="translated">迭代器是数组处理的强大概念。本质上，迭代器实现了通用的for循环。如果&lt;em&gt;myiter&lt;/em&gt;是迭代器对象，则Python代码：</target>
        </trans-unit>
        <trans-unit id="796f6321f3f35af9085ef4cf35c1d4e6f0e4b4dc" translate="yes" xml:space="preserve">
          <source>Its disadvantages include</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d54f82f4390510a92d95c53ba668fb5b8d3f93" translate="yes" xml:space="preserve">
          <source>Its probability density function is</source>
          <target state="translated">其概率密度函数为</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="a2cbec366193e4ee99c0016c5fe79f216b41e583" translate="yes" xml:space="preserve">
          <source>J. F. Kaiser, &amp;ldquo;Digital Filters&amp;rdquo; - Ch 7 in &amp;ldquo;Systems analysis by digital computer&amp;rdquo;, Editors: F.F. Kuo and J.F. Kaiser, p 218-285. John Wiley and Sons, New York, (1966).</source>
          <target state="translated">JF Kaiser，&amp;ldquo;数字滤波器&amp;rdquo;-&amp;ldquo;数字计算机的系统分析&amp;rdquo;中的第7章，编辑：FF Kuo和JF Kaiser，第218-285页。约翰&amp;middot;威利父子出版社，纽约，（1966年）。</target>
        </trans-unit>
        <trans-unit id="f458212a67f9dc847550889da59b7be8169fde2a" translate="yes" xml:space="preserve">
          <source>Jaime Fern&amp;aacute;ndez del R&amp;iacute;o</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85b6dd0eee475b31af984e7ef5b76c826173395" translate="yes" xml:space="preserve">
          <source>John K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw, &amp;ldquo;Parallel Random Numbers: As Easy as 1, 2, 3,&amp;rdquo; Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (SC11), New York, NY: ACM, 2011.</source>
          <target state="translated">John K. Salmon，Mark A. Moraes，Ron O. Dror和David E. Shaw，&amp;ldquo;并行随机数：1、2、3一样容易&amp;rdquo;，高性能计算，网络，存储和存储国际会议论文集分析（SC11），纽约，纽约：ACM，2011年。</target>
        </trans-unit>
        <trans-unit id="5955c7d39672a39a399f419793e9d4b2998a0ae1" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays along a new axis.</source>
          <target state="translated">沿着一个新的轴连接一个数组序列。</target>
        </trans-unit>
        <trans-unit id="4ea1c9ee9a15b3dcbf6e5bf8c6f47b37d396752b" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays along an existing axis.</source>
          <target state="translated">沿着一个现有的轴连接一个数组序列。</target>
        </trans-unit>
        <trans-unit id="c169b65bb5e75fcaa26f3cb74e710ac8d05e200a" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays together.</source>
          <target state="translated">将一个数组序列连接在一起。</target>
        </trans-unit>
        <trans-unit id="a0cbf31ae389d3a2da5d14e49f527c1cd6c82518" translate="yes" xml:space="preserve">
          <source>Join arrays &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; on key &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23191121c5e72da7ca4394cebd036d5824a4bf84" translate="yes" xml:space="preserve">
          <source>Join arrays &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; on keys. Alternative to join_by, that always returns a np.recarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace77e0ad40f2680b6aa7f69f4dfbec0108a72b3" translate="yes" xml:space="preserve">
          <source>Join the sequence of objects in &lt;em&gt;obj&lt;/em&gt; together along &lt;em&gt;axis&lt;/em&gt; into a single array. If the dimensions or types are not compatible an error is raised.</source>
          <target state="translated">将&lt;em&gt;obj中&lt;/em&gt;的对象序列沿&lt;em&gt;轴连接&lt;/em&gt;到一个数组中。如果尺寸或类型不兼容，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="0b145a058f4f708ddeea141e56d4c1c7cea2454f" translate="yes" xml:space="preserve">
          <source>Join two or more pathname components + - convert a /-separated pathname to one using the OS&amp;rsquo;s path separator. - resolve  and  from path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="930021877100c692fce1a3c6407a5fca82ef8115" translate="yes" xml:space="preserve">
          <source>Joining arrays</source>
          <target state="translated">连接数组</target>
        </trans-unit>
        <trans-unit id="853683e5afe4c33d14d4fe25be2e7a31fcdb24ae" translate="yes" xml:space="preserve">
          <source>Julian Taylor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ad4711cdf3c76bf58efbbfffae229363be1de78" translate="yes" xml:space="preserve">
          <source>July 26, 2019</source>
          <target state="translated">2019年7月26日</target>
        </trans-unit>
        <trans-unit id="0ea4fce60f72408c555e74c1176fd49b9f6f546a" translate="yes" xml:space="preserve">
          <source>Jump Size</source>
          <target state="translated">跳跃尺寸</target>
        </trans-unit>
        <trans-unit id="2f4eece64596ae5728be928b098daa67afdcbd49" translate="yes" xml:space="preserve">
          <source>Jumping the BitGenerator state</source>
          <target state="translated">跳转到BitGenerator状态</target>
        </trans-unit>
        <trans-unit id="edaececa3ce78905da5d0c8d3e5c155d40b3049c" translate="yes" xml:space="preserve">
          <source>Jumping to the next level of complexity, it is possible to only partially index an array with index arrays. It takes a bit of thought to understand what happens in such cases. For example if we just use one index array with y:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3780087bf4b8552cfaeefd4ae432b76ab3d8ec4" translate="yes" xml:space="preserve">
          <source>Jumps the state as-if jumps * 210306068529402873165736369884012333109 random numbers have been generated.</source>
          <target state="translated">跳转状态为如果跳转*210306068529402873165736369884012333109 随机数已经生成。</target>
        </trans-unit>
        <trans-unit id="e66b5685b9897c71dad3170faecd2518dfadece3" translate="yes" xml:space="preserve">
          <source>June 29, 2020</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d305a937478453054f4a6c27158c776273985e" translate="yes" xml:space="preserve">
          <source>Just for your own satisfaction, show yourself that you now have a new &amp;lsquo;remote&amp;rsquo;, with &lt;code&gt;git remote -v show&lt;/code&gt;, giving you something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8882074cfd8e824bd17a6e53a5a926e124e1b9b" translate="yes" xml:space="preserve">
          <source>Just like in other Python container objects, the contents of an array can be accessed and modified by indexing or slicing the array. Unlike the typical container objects, different arrays can share the same data, so changes made on one array might be visible in another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a2ccc2c43427a5df3aae2525cebca91213ce58" translate="yes" xml:space="preserve">
          <source>Just like the case for builtin special methods like &lt;code&gt;__add__&lt;/code&gt;, properly written &lt;code&gt;__array_function__&lt;/code&gt; methods should always return &lt;code&gt;NotImplemented&lt;/code&gt; when an unknown type is encountered. Otherwise, it will be impossible to correctly override NumPy functions from another object if the operation also includes one of your objects.</source>
          <target state="translated">就像案例内建的特殊方法，如 &lt;code&gt;__add__&lt;/code&gt; ，正确编写 &lt;code&gt;__array_function__&lt;/code&gt; 方法应该总是返回 &lt;code&gt;NotImplemented&lt;/code&gt; 遇到一个未知类型时。否则，如果操作还包含一个对象，则将无法从另一个对象正确覆盖NumPy函数。</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="fea9c97b23d277bbc25a4ecec464e976ad73c9d8" translate="yes" xml:space="preserve">
          <source>Key to use in the Philox state. Unlike &lt;code&gt;seed&lt;/code&gt;, the value in key is directly set. Can be either a Python int in [0, 2**128) or a 2-element uint64 array. &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;seed&lt;/code&gt; cannot both be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e171a322d7a93c71ab2aebd91bfaf316577346" translate="yes" xml:space="preserve">
          <source>Key to use in the Philox state. Unlike seed, the value in key is directly set. Can be either a Python int in [0, 2**128) or a 2-element uint64 array. &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;seed&lt;/code&gt; cannot both be used.</source>
          <target state="translated">在Philox状态下使用的密钥。与种子不同，键中的值是直接设置的。可以是[0，2 ** 128）中的Python int或2元素的uint64数组。 &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;seed&lt;/code&gt; 不能同时使用。</target>
        </trans-unit>
        <trans-unit id="a4f25f4e01bab825ac7968a35cf2573aecf46441" translate="yes" xml:space="preserve">
          <source>Keyword arguments passed to &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">关键字参数传递给 &lt;code&gt;func&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="936d17141932bddd8cdbe3cf3d8e6417d18816b5" translate="yes" xml:space="preserve">
          <source>Keyword arguments used in calling &lt;a href=&quot;#numpy.piecewise&quot;&gt;&lt;code&gt;piecewise&lt;/code&gt;&lt;/a&gt; are passed to the functions upon execution, i.e., if called &lt;code&gt;piecewise(..., ..., alpha=1)&lt;/code&gt;, then each function is called as &lt;code&gt;f(x, alpha=1)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.piecewise&quot;&gt; &lt;code&gt;piecewise&lt;/code&gt; &lt;/a&gt;调用中使用的关键字参数在执行时传递给函数，即，如果调用了 &lt;code&gt;piecewise(..., ..., alpha=1)&lt;/code&gt; ，则每个函数都称为 &lt;code&gt;f(x, alpha=1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94796302f2d6010802da8fc83c102abd3d91e59b" translate="yes" xml:space="preserve">
          <source>Keyword arguments with the value &lt;code&gt;None&lt;/code&gt; are not checked. Specifying a keyword enforces checking of that aspect of the ndarray on conversion to a ctypes-compatible object. The dtype keyword can be any object understood as a data-type object. The ndim keyword should be an integer, and the shape keyword should be an integer or a sequence of integers. The flags keyword specifies the minimal flags that are required on any array passed in. This can be specified as a string of comma separated requirements, an integer indicating the requirement bits OR&amp;rsquo;d together, or a flags object returned from the flags attribute of an array with the necessary requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b38351b3da46b01757fe5df0b763a6ba88d3175" translate="yes" xml:space="preserve">
          <source>Keyword arguments. The valid keywords are the possible floating-point exceptions. Each keyword should have a string value that defines the treatment for the particular error. Possible values are {&amp;lsquo;ignore&amp;rsquo;, &amp;lsquo;warn&amp;rsquo;, &amp;lsquo;raise&amp;rsquo;, &amp;lsquo;call&amp;rsquo;, &amp;lsquo;print&amp;rsquo;, &amp;lsquo;log&amp;rsquo;}.</source>
          <target state="translated">关键字参数。有效的关键字是可能的浮点异常。每个关键字应具有一个字符串值，该字符串值定义对特定错误的处理方式。可能的值为{'ignore'，'warn'，'raise'，'call'，'print'，'log'}。</target>
        </trans-unit>
        <trans-unit id="cca3dd937ca64fcc731c3b76e10a3a59e197b380" translate="yes" xml:space="preserve">
          <source>Keywords other than &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;以外的关键字传递给 &lt;code&gt;function&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd51c0cf5320b73d3ff55b2176ad245d2d7397b1" translate="yes" xml:space="preserve">
          <source>Keywords other than &lt;code&gt;dtype&lt;/code&gt; are passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; 以外的关键字传递给 &lt;code&gt;function&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c23ce94abbcda9863c972bac23c6a2a76bdd7d1" translate="yes" xml:space="preserve">
          <source>Kind of floating point data-type about which to get information.</source>
          <target state="translated">一种浮点数据类型,要获取相关信息。</target>
        </trans-unit>
        <trans-unit id="31be8fd23c00b4b851fa5f224f6fd4dac29e08c9" translate="yes" xml:space="preserve">
          <source>Known bugs:</source>
          <target state="translated">已知的错误。</target>
        </trans-unit>
        <trans-unit id="26db35f7eb95d8b793f4df612e64a0ce6b5afd47" translate="yes" xml:space="preserve">
          <source>Known failures &amp;amp; skipping tests</source>
          <target state="translated">已知故障和跳过测试</target>
        </trans-unit>
        <trans-unit id="d54ed0ae4c90f25216ec62895c50ba0c59603696" translate="yes" xml:space="preserve">
          <source>Kotz, Samuel, et. al. &amp;ldquo;The Laplace Distribution and Generalizations, &amp;rdquo; Birkhauser, 2001.</source>
          <target state="translated">Kotz，Samuel等。等 &amp;ldquo;拉普拉斯分布与归纳&amp;rdquo;，Birkhauser，2001年。</target>
        </trans-unit>
        <trans-unit id="9b54aa8ed101113f4ff654653787cb490d5956f9" translate="yes" xml:space="preserve">
          <source>Kronecker product of two arrays.</source>
          <target state="translated">两个数组的克朗克积。</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="0c5ca7c9489e795d6e344494ca6012e6c5e6c94a" translate="yes" xml:space="preserve">
          <source>L. J. Gitman, &amp;ldquo;Principles of Managerial Finance, Brief,&amp;rdquo; 3rd ed., Addison-Wesley, 2003, pg. 346.</source>
          <target state="translated">LJ Gitman，&amp;ldquo;管理财务原理，简介&amp;rdquo;，第3版，Addison-Wesley，2003年，第13页。346。</target>
        </trans-unit>
        <trans-unit id="dad744be14f4bac6567fee2e00e8179f1cafc777" translate="yes" xml:space="preserve">
          <source>L. J. Gitman, &amp;ldquo;Principles of Managerial Finance, Brief,&amp;rdquo; 3rd ed., Addison-Wesley, 2003, pg. 348.</source>
          <target state="translated">LJ Gitman，&amp;ldquo;管理财务原理，简介&amp;rdquo;，第3版，Addison-Wesley，2003年，第13页。348。</target>
        </trans-unit>
        <trans-unit id="c9abe91342431b93d138f7615d16985673f94ddb" translate="yes" xml:space="preserve">
          <source>L2 norm of vector &lt;code&gt;v&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9e7dcbce935737e3132c8567095e62b32e357d" translate="yes" xml:space="preserve">
          <source>LAPACK</source>
          <target state="translated">LAPACK</target>
        </trans-unit>
        <trans-unit id="a3fb459b8d25a6646ccd3006470636c4394d2fa7" translate="yes" xml:space="preserve">
          <source>LAPACK (NetLIB)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d5b247623a47d3ffff1da535ef4461b811d560" translate="yes" xml:space="preserve">
          <source>LSB integer 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17bcd0c5595da0e7eb910f67673f577b1f83f0f7" translate="yes" xml:space="preserve">
          <source>LSB integer 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eec57c77bc60eb78065b6605060bb41430b8e7ce" translate="yes" xml:space="preserve">
          <source>LU decomposition (note: P(Matlab) == transpose(P(numpy)) )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f50beb264ce7d144bf1ce0f2f4d3f272a300b7de" translate="yes" xml:space="preserve">
          <source>Label a test as &amp;lsquo;slow&amp;rsquo;.</source>
          <target state="translated">将测试标记为&amp;ldquo;慢&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="369c34c1729b62dec5c01c92266ffbd20a59873d" translate="yes" xml:space="preserve">
          <source>Labeling tests</source>
          <target state="translated">标签测试</target>
        </trans-unit>
        <trans-unit id="4bebfc5e6e36da81205979cf627ca2083b60eab7" translate="yes" xml:space="preserve">
          <source>Laguerre</source>
          <target state="translated">Laguerre</target>
        </trans-unit>
        <trans-unit id="e97fc7286288e61e2979e3135f28bb8c533a9b55" translate="yes" xml:space="preserve">
          <source>Laguerre (class in numpy.polynomial.laguerre)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e57606aead53cf91effb25cd081645a48be4c71" translate="yes" xml:space="preserve">
          <source>Laguerre Class</source>
          <target state="translated">Laguerre级</target>
        </trans-unit>
        <trans-unit id="ba379f482d893a166d54a2acffc47cc917ce664e" translate="yes" xml:space="preserve">
          <source>Laguerre Module (&lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt;)</source>
          <target state="translated">Laguerre模块（ &lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="1fa1d2e4107d4f18290f33c4164e9ffd20858112" translate="yes" xml:space="preserve">
          <source>Laguerre Module (numpy.polynomial.laguerre)</source>
          <target state="translated">拉盖尔模块 (numpy.polynomial.laguerre)</target>
        </trans-unit>
        <trans-unit id="2a936707907aefc2336791e67e0a362c7a6f2893" translate="yes" xml:space="preserve">
          <source>Laguerre Series (&lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df257db6a3d424bc3a9e921bbaaa3ba0ba50dac3" translate="yes" xml:space="preserve">
          <source>Laguerre Series (numpy.polynomial.laguerre)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99466c13dff878e880a6ce449247757d575c46d1" translate="yes" xml:space="preserve">
          <source>Laguerre coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*L_0(x) + 2*L_1(X) + 3*L_2(x)&lt;/code&gt;.</source>
          <target state="translated">Laguerre系数按递增的顺序排列，即 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 给出 &lt;code&gt;1*L_0(x) + 2*L_1(X) + 3*L_2(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96781eb22440929e4bf56e8413b2c4b2ee004cfa" translate="yes" xml:space="preserve">
          <source>Laguerre coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">拉盖尔系数从低到高排序。如果 &lt;code&gt;y&lt;/code&gt; 为2-d，在的k列中的数据的系数 &lt;code&gt;y&lt;/code&gt; 在柱 &lt;code&gt;k&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="203d5e91f105ffb95930f626e1d302a193aeaa68" translate="yes" xml:space="preserve">
          <source>Laguerre series</source>
          <target state="translated">拉盖尔系列</target>
        </trans-unit>
        <trans-unit id="a347ea54d317cc577991ec7bf8e660f33b29ea5f" translate="yes" xml:space="preserve">
          <source>Laguerre series coefficients of the integral.</source>
          <target state="translated">拉格尔系列系数的积分。</target>
        </trans-unit>
        <trans-unit id="d470a6ac507868056b6fb97be3c38f8e66fd3f73" translate="yes" xml:space="preserve">
          <source>Laguerre series of power.</source>
          <target state="translated">拉盖尔系列电。</target>
        </trans-unit>
        <trans-unit id="077697f66c66782d4ef98066ee75e7065a9fd35e" translate="yes" xml:space="preserve">
          <source>Laguerre series of the derivative.</source>
          <target state="translated">导数的拉格列。</target>
        </trans-unit>
        <trans-unit id="9a5deb2e7228ec3244f92981a2f639bd0074c61e" translate="yes" xml:space="preserve">
          <source>Laguerre series whose graph is a straight line.</source>
          <target state="translated">拉盖尔数列的图形是一条直线。</target>
        </trans-unit>
        <trans-unit id="40be499dbcfef954b53f79728a280796ea6c4f1b" translate="yes" xml:space="preserve">
          <source>Laguerre weight function.</source>
          <target state="translated">拉格尔权重函数。</target>
        </trans-unit>
        <trans-unit id="19b66881a109c4450aeadcaedc080b0375d2ecf9" translate="yes" xml:space="preserve">
          <source>Laguerre.__call__()</source>
          <target state="translated">Laguerre.__call__()</target>
        </trans-unit>
        <trans-unit id="b79eed7b566471b5b98d5403131d5fcccb9ccdd6" translate="yes" xml:space="preserve">
          <source>Laguerre.basis()</source>
          <target state="translated">Laguerre.basis()</target>
        </trans-unit>
        <trans-unit id="8450b9cd56cfc84841f9b6a7b3ce8b6553391224" translate="yes" xml:space="preserve">
          <source>Laguerre.cast()</source>
          <target state="translated">Laguerre.cast()</target>
        </trans-unit>
        <trans-unit id="27a50de57a0c19215d0a40ab26d7fc3244818104" translate="yes" xml:space="preserve">
          <source>Laguerre.convert()</source>
          <target state="translated">Laguerre.convert()</target>
        </trans-unit>
        <trans-unit id="ba2566270efed850de8b718e7293f07a260b676d" translate="yes" xml:space="preserve">
          <source>Laguerre.copy()</source>
          <target state="translated">Laguerre.copy()</target>
        </trans-unit>
        <trans-unit id="3b52ca7dceafcdacc78576d128623ad1866249fc" translate="yes" xml:space="preserve">
          <source>Laguerre.cutdeg()</source>
          <target state="translated">Laguerre.cutdeg()</target>
        </trans-unit>
        <trans-unit id="d2b6b76b4b9ee361106b2c94187d00faaf8bec52" translate="yes" xml:space="preserve">
          <source>Laguerre.degree()</source>
          <target state="translated">Laguerre.degree()</target>
        </trans-unit>
        <trans-unit id="00ba5991cdfe21416f272ddb4e2fd2ee48ba1e73" translate="yes" xml:space="preserve">
          <source>Laguerre.deriv()</source>
          <target state="translated">Laguerre.deriv()</target>
        </trans-unit>
        <trans-unit id="3774c67b9a36d28184dc80e1b4d2486ea1e1f36a" translate="yes" xml:space="preserve">
          <source>Laguerre.domain</source>
          <target state="translated">Laguerre.domain</target>
        </trans-unit>
        <trans-unit id="b85b503244ce55e050a887342980da72b2e9ad78" translate="yes" xml:space="preserve">
          <source>Laguerre.fit()</source>
          <target state="translated">Laguerre.fit()</target>
        </trans-unit>
        <trans-unit id="23af0332e2c429442e5afb68340fa4aeef4545dc" translate="yes" xml:space="preserve">
          <source>Laguerre.fromroots()</source>
          <target state="translated">Laguerre.fromroots()</target>
        </trans-unit>
        <trans-unit id="a2a6581abb5a91aaeac7e93a2a256734282432d3" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samecoef()</source>
          <target state="translated">Laguerre.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="7dd4d8134966100274e963f0060bfab576b5fddf" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samedomain()</source>
          <target state="translated">Laguerre.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="e5e59e81443c19ac8f19e8c2fdccb120a1c9224f" translate="yes" xml:space="preserve">
          <source>Laguerre.has_sametype()</source>
          <target state="translated">Laguerre.has_sametype()</target>
        </trans-unit>
        <trans-unit id="3d138070a5021011806b89098bbe766378b10e7e" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samewindow()</source>
          <target state="translated">Laguerre.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="6f69d4698823efec4ccf07af22829cc894b0b98c" translate="yes" xml:space="preserve">
          <source>Laguerre.identity()</source>
          <target state="translated">Laguerre.identity()</target>
        </trans-unit>
        <trans-unit id="f1f6d872a178e7692b45f4ccbfd34fbbf6ed5f91" translate="yes" xml:space="preserve">
          <source>Laguerre.integ()</source>
          <target state="translated">Laguerre.integ()</target>
        </trans-unit>
        <trans-unit id="068cb46402017cfb3dd18164c9b41f89c700f799" translate="yes" xml:space="preserve">
          <source>Laguerre.linspace()</source>
          <target state="translated">Laguerre.linspace()</target>
        </trans-unit>
        <trans-unit id="100d51943018ffa8eadce404d26cfaa31b915872" translate="yes" xml:space="preserve">
          <source>Laguerre.mapparms()</source>
          <target state="translated">Laguerre.mapparms()</target>
        </trans-unit>
        <trans-unit id="de9dd46ebdab9f670b65d8cedb81c132ac30c276" translate="yes" xml:space="preserve">
          <source>Laguerre.roots()</source>
          <target state="translated">Laguerre.roots()</target>
        </trans-unit>
        <trans-unit id="9779fb4f29c73da5d6cee5ec234239b97271c1ae" translate="yes" xml:space="preserve">
          <source>Laguerre.trim()</source>
          <target state="translated">Laguerre.trim()</target>
        </trans-unit>
        <trans-unit id="76a59bb3d54a6db3b464f00c41f8b5a8b4767c11" translate="yes" xml:space="preserve">
          <source>Laguerre.truncate()</source>
          <target state="translated">Laguerre.truncate()</target>
        </trans-unit>
        <trans-unit id="36198a8897031e87556aee045b29805731052142" translate="yes" xml:space="preserve">
          <source>Laplaces</source>
          <target state="translated">Laplaces</target>
        </trans-unit>
        <trans-unit id="82f5e1511892c7fb01c75144ac000d62f83d5a77" translate="yes" xml:space="preserve">
          <source>Large allocations marked as suitable for transparent hugepages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da46491a1118285dbcf5975a2a3f36f864e4e6eb" translate="yes" xml:space="preserve">
          <source>Large parts of this manual originate from Travis E. Oliphant&amp;rsquo;s book &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;Guide to NumPy&lt;/a&gt; (which generously entered Public Domain in August 2008). The reference documentation for many of the functions are written by numerous contributors and developers of NumPy.</source>
          <target state="translated">本手册的大部分内容来自Travis E. Oliphant的&lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;《 NumPy指南》&lt;/a&gt;（该指南于2008年8月慷慨地进入了Public Domain）。许多功能的参考文档由NumPy的许多贡献者和开发人员编写。</target>
        </trans-unit>
        <trans-unit id="eab5c44c0f0e22a5c5510649d34e17cb192d1603" translate="yes" xml:space="preserve">
          <source>Large parts of this manual originate from Travis E. Oliphant's book &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;&quot;Guide to NumPy&quot;&lt;/a&gt; (which generously entered Public Domain in August 2008). The reference documentation for many of the functions are written by numerous contributors and developers of NumPy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fdae5c61df170eabed81dff27bfb3678199f99b" translate="yes" xml:space="preserve">
          <source>Largest size allowed for the user-settable buffers.</source>
          <target state="translated">允许用户设置缓冲区的最大尺寸。</target>
        </trans-unit>
        <trans-unit id="8da87d373f111f7e103693ae24e8a07ffa7a91e2" translate="yes" xml:space="preserve">
          <source>Last processed field name (used internally during recursion).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="688c183c0553e7f8897c3da631ac608e3281e20b" translate="yes" xml:space="preserve">
          <source>Learn about concepts and submodules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1c2c8a281b93c2a756aa5c5b0dde7c93d58559" translate="yes" xml:space="preserve">
          <source>Learn about what NumPy is and how to install it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1893b40e2e74ded8d87e7668bb8ea0e85b265882" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;../reference/routines.io#routines-io&quot;&gt;input and output routines here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42d6db2ec75c1bd30bb52b2e73819209cb308cc1" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;quickstart#quickstart-indexing-slicing-and-iterating&quot;&gt;indexing and slicing here&lt;/a&gt; and &lt;a href=&quot;basics.indexing#basics-indexing&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a595050bddab4e4c46cb1e0dc7dff5874ac8e5f" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;whatisnumpy#whatisnumpy&quot;&gt;NumPy here&lt;/a&gt;!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eccf892e3b309e4f27b805fda73ba6310c691f1f" translate="yes" xml:space="preserve">
          <source>Learn more about creating arrays here</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f285095a214517cc70148a152aa9ce3bfb1555" translate="yes" xml:space="preserve">
          <source>Least squares fit of Chebyshev series to data.</source>
          <target state="translated">Chebyshev序列与数据的最小二乘拟合。</target>
        </trans-unit>
        <trans-unit id="5eede6c92597c6ad1ec14f2a50e868bfa8dbcef5" translate="yes" xml:space="preserve">
          <source>Least squares fit of Hermite series to data.</source>
          <target state="translated">Hermite系列与数据的最小二乘拟合。</target>
        </trans-unit>
        <trans-unit id="f9834397596bb1c91a60ebd7bed6c56b93f210b5" translate="yes" xml:space="preserve">
          <source>Least squares fit of Laguerre series to data.</source>
          <target state="translated">Laguerre序列与数据的最小二乘拟合。</target>
        </trans-unit>
        <trans-unit id="60abe6780ea6293285c10210c3c968485e58937b" translate="yes" xml:space="preserve">
          <source>Least squares fit of Legendre series to data.</source>
          <target state="translated">Legendre序列与数据的最小二乘拟合。</target>
        </trans-unit>
        <trans-unit id="f70b890f268681837dd642a40e85f47d99c8ef5c" translate="yes" xml:space="preserve">
          <source>Least squares fit to data.</source>
          <target state="translated">对数据进行最小二乘拟合。</target>
        </trans-unit>
        <trans-unit id="82d4ad107d684ab9ad44770f05b7a2542d27bae6" translate="yes" xml:space="preserve">
          <source>Least squares polynomial fit.</source>
          <target state="translated">最小二乘多项式拟合。</target>
        </trans-unit>
        <trans-unit id="66b99a01120f0770d01e2e70f30aa7b3e6d8760b" translate="yes" xml:space="preserve">
          <source>Least-squares fit of a polynomial to data.</source>
          <target state="translated">多项式与数据的最小二乘拟合。</target>
        </trans-unit>
        <trans-unit id="004f7153cd5215d911c25b804b9cb64fc053135e" translate="yes" xml:space="preserve">
          <source>Least-squares solution. If &lt;code&gt;b&lt;/code&gt; is two-dimensional, the solutions are in the &lt;code&gt;K&lt;/code&gt; columns of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">最小二乘解。如果 &lt;code&gt;b&lt;/code&gt; 是二维的，则解在 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;K&lt;/code&gt; 列中。</target>
        </trans-unit>
        <trans-unit id="8e3bf79d3ac96cdf89ed0ca352f8850960c3aecf" translate="yes" xml:space="preserve">
          <source>Leg of the triangle(s). If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">三角形的边。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="a3da3f26242bb8617087ec4d4fb9fafcb77635dc" translate="yes" xml:space="preserve">
          <source>Legacy Generator (RandomState)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a03f0fe89c9579b9b2b236650c98185edc2fe62" translate="yes" xml:space="preserve">
          <source>Legacy Random Generation</source>
          <target state="translated">遗产随机生成</target>
        </trans-unit>
        <trans-unit id="47a5d89b5a8a2f363ca5b4a1476eb173fc07ab11" translate="yes" xml:space="preserve">
          <source>Legendre</source>
          <target state="translated">Legendre</target>
        </trans-unit>
        <trans-unit id="358ed7a487a2a55bfa9556bbf8f4fe1f6f4c1094" translate="yes" xml:space="preserve">
          <source>Legendre (class in numpy.polynomial.legendre)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4120cea9b471c879abda7b1336aba3d61c52e3bc" translate="yes" xml:space="preserve">
          <source>Legendre Class</source>
          <target state="translated">Legendre级</target>
        </trans-unit>
        <trans-unit id="b4a47072941f51eec5be92fa7536302b1cd27189" translate="yes" xml:space="preserve">
          <source>Legendre Module (&lt;code&gt;numpy.polynomial.legendre&lt;/code&gt;)</source>
          <target state="translated">Legendre模块（ &lt;code&gt;numpy.polynomial.legendre&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="a6b7c39b7f03fb5bf1916b89cb05334bb7660fc8" translate="yes" xml:space="preserve">
          <source>Legendre Module (numpy.polynomial.legendre)</source>
          <target state="translated">Legendre模块 (numpy.polynomial.legadre)</target>
        </trans-unit>
        <trans-unit id="5cf0b728017026cd3633f8023ba22356ac49e8e9" translate="yes" xml:space="preserve">
          <source>Legendre Series (&lt;code&gt;numpy.polynomial.legendre&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc1f7294028d411cdbd64652dfec514ea719176" translate="yes" xml:space="preserve">
          <source>Legendre Series (numpy.polynomial.legendre)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a4b81826e99e6fe744c1d98416a1d24f591803" translate="yes" xml:space="preserve">
          <source>Legendre coefficients in order of increasing degree, i.e., &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*P_0(x) + 2*P_1(x) + 3*P_2(x)&lt;/code&gt;.</source>
          <target state="translated">勒让德系数按递增的顺序排列，即 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 给出 &lt;code&gt;1*P_0(x) + 2*P_1(x) + 3*P_2(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd1aecb7d54479faf64417ed750dd54dbc48134e" translate="yes" xml:space="preserve">
          <source>Legendre coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;. If &lt;code&gt;deg&lt;/code&gt; is specified as a list, coefficients for terms not included in the fit are set equal to zero in the returned &lt;code&gt;coef&lt;/code&gt;.</source>
          <target state="translated">勒让德系数从低到高排序。如果 &lt;code&gt;y&lt;/code&gt; 为2-d，在的k列中的数据的系数 &lt;code&gt;y&lt;/code&gt; 在柱 &lt;code&gt;k&lt;/code&gt; 。如果将 &lt;code&gt;deg&lt;/code&gt; 指定为列表，则不包含在拟合中的项的 &lt;code&gt;coef&lt;/code&gt; 在返回的coef中设置为零。</target>
        </trans-unit>
        <trans-unit id="36661c8b6df50f0810e8abcd38c911e37700210a" translate="yes" xml:space="preserve">
          <source>Legendre series</source>
          <target state="translated">Legendre系列</target>
        </trans-unit>
        <trans-unit id="cff0f8c14f012c4d84feceb1b721e76e38f2b7e7" translate="yes" xml:space="preserve">
          <source>Legendre series coefficient array of the integral.</source>
          <target state="translated">Legendre系列系数阵的积分。</target>
        </trans-unit>
        <trans-unit id="e423b1233d9fcd2c8894e66b68b4670d1797fcf6" translate="yes" xml:space="preserve">
          <source>Legendre series of power.</source>
          <target state="translated">传奇系列的力量。</target>
        </trans-unit>
        <trans-unit id="cbfaa0f2130ef078276a68c292602bd146355698" translate="yes" xml:space="preserve">
          <source>Legendre series of the derivative.</source>
          <target state="translated">Legendre系列的衍生物。</target>
        </trans-unit>
        <trans-unit id="0c94fd4bbecdfa33cfa2085e96aaf27eb258cb91" translate="yes" xml:space="preserve">
          <source>Legendre series whose graph is a straight line.</source>
          <target state="translated">Legendre系列的图形是一条直线。</target>
        </trans-unit>
        <trans-unit id="9c6dd8780cca130b14ebf98dc6a58e0b8fde7f4f" translate="yes" xml:space="preserve">
          <source>Legendre weight function (= 1).</source>
          <target state="translated">Legendre权重函数(=1)。</target>
        </trans-unit>
        <trans-unit id="11838d713a7ca74c36db28fb9741ab01b38fc2f4" translate="yes" xml:space="preserve">
          <source>Legendre, Laguerre, Hermite, HermiteE polynomials in &lt;code&gt;numpy.polynomial&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4086e8682b0af8e09d2dfa82cd2fdc76b5bc8f8d" translate="yes" xml:space="preserve">
          <source>Legendre.__call__()</source>
          <target state="translated">Legendre.__call__()</target>
        </trans-unit>
        <trans-unit id="38dffd4eba846de64c001288fae359b48ca7be06" translate="yes" xml:space="preserve">
          <source>Legendre.basis()</source>
          <target state="translated">Legendre.basis()</target>
        </trans-unit>
        <trans-unit id="03d79bdd0c244e4a8685e0cc2ed8f9bba14f2e75" translate="yes" xml:space="preserve">
          <source>Legendre.cast()</source>
          <target state="translated">Legendre.cast()</target>
        </trans-unit>
        <trans-unit id="c3757be303c19145dd4cdc1f1fdbe7778af7a9b8" translate="yes" xml:space="preserve">
          <source>Legendre.convert()</source>
          <target state="translated">Legendre.convert()</target>
        </trans-unit>
        <trans-unit id="30694a9a60e1750eef89dd48cd213d03dc835778" translate="yes" xml:space="preserve">
          <source>Legendre.copy()</source>
          <target state="translated">Legendre.copy()</target>
        </trans-unit>
        <trans-unit id="67fd9bca2a23484298ecfc5a44e6dbe767f8deee" translate="yes" xml:space="preserve">
          <source>Legendre.cutdeg()</source>
          <target state="translated">Legendre.cutdeg()</target>
        </trans-unit>
        <trans-unit id="de6280bafa05de1ba0dc2f4ee315b2f1c3f376c2" translate="yes" xml:space="preserve">
          <source>Legendre.degree()</source>
          <target state="translated">Legendre.degree()</target>
        </trans-unit>
        <trans-unit id="065d87c76a899767772e29e52989a91f8e7a3c94" translate="yes" xml:space="preserve">
          <source>Legendre.deriv()</source>
          <target state="translated">Legendre.deriv()</target>
        </trans-unit>
        <trans-unit id="dc4f96a4666e84f37c719b2fad25d196a612cc45" translate="yes" xml:space="preserve">
          <source>Legendre.domain</source>
          <target state="translated">Legendre.domain</target>
        </trans-unit>
        <trans-unit id="11c2423446ff507ce6eb98675dde94c735489c69" translate="yes" xml:space="preserve">
          <source>Legendre.fit()</source>
          <target state="translated">Legendre.fit()</target>
        </trans-unit>
        <trans-unit id="e21bd7963e9b515a9f4b47a6bcd09e263e8089ee" translate="yes" xml:space="preserve">
          <source>Legendre.fromroots()</source>
          <target state="translated">Legendre.fromroots()</target>
        </trans-unit>
        <trans-unit id="d5d912a486cc7b8f50ccecabe4f025c8e6390336" translate="yes" xml:space="preserve">
          <source>Legendre.has_samecoef()</source>
          <target state="translated">Legendre.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="6666d87ba29b4b8ae40e97a1bf2868d699324607" translate="yes" xml:space="preserve">
          <source>Legendre.has_samedomain()</source>
          <target state="translated">Legendre.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="3760f41cb73e83c63c3b041fb1850faaf75fa051" translate="yes" xml:space="preserve">
          <source>Legendre.has_sametype()</source>
          <target state="translated">Legendre.has_sametype()</target>
        </trans-unit>
        <trans-unit id="776a3387bba3bfaabfedc34f80f56441350be257" translate="yes" xml:space="preserve">
          <source>Legendre.has_samewindow()</source>
          <target state="translated">Legendre.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="d270c39a15f9cf84d450407eca8d04e34120a21a" translate="yes" xml:space="preserve">
          <source>Legendre.identity()</source>
          <target state="translated">Legendre.identity()</target>
        </trans-unit>
        <trans-unit id="a025b9af1289248a2a7d813cd3249b6c59a1b90e" translate="yes" xml:space="preserve">
          <source>Legendre.integ()</source>
          <target state="translated">Legendre.integ()</target>
        </trans-unit>
        <trans-unit id="b1309f9dd6fba8397cba7645c87fd874d753067f" translate="yes" xml:space="preserve">
          <source>Legendre.linspace()</source>
          <target state="translated">Legendre.linspace()</target>
        </trans-unit>
        <trans-unit id="3b41ed00816bbf0ea94cb8ce7b846f9374dce867" translate="yes" xml:space="preserve">
          <source>Legendre.mapparms()</source>
          <target state="translated">Legendre.mapparms()</target>
        </trans-unit>
        <trans-unit id="498206cc30a61e0936daddec7420065e1fb22906" translate="yes" xml:space="preserve">
          <source>Legendre.roots()</source>
          <target state="translated">Legendre.roots()</target>
        </trans-unit>
        <trans-unit id="c917ded9bfb105e1d1214678489c4d2d643e0789" translate="yes" xml:space="preserve">
          <source>Legendre.trim()</source>
          <target state="translated">Legendre.trim()</target>
        </trans-unit>
        <trans-unit id="4b818047b63ac1fb3abbf9ee09b84ccf39af0370" translate="yes" xml:space="preserve">
          <source>Legendre.truncate()</source>
          <target state="translated">Legendre.truncate()</target>
        </trans-unit>
        <trans-unit id="d96ebfedf4c36cbda183cd7a457b02a6edaca923" translate="yes" xml:space="preserve">
          <source>Length &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; array of &lt;code&gt;char&lt;/code&gt; encoding the &lt;a href=&quot;../generated/numpy.dtype.num#numpy.dtype.num&quot;&gt;&lt;code&gt;numpy.dtype.num&lt;/code&gt;&lt;/a&gt; (built-in only) that the corresponding function in the &lt;code&gt;func&lt;/code&gt; array accepts. For instance, for a comparison ufunc with three &lt;code&gt;ntypes&lt;/code&gt;, two &lt;code&gt;nin&lt;/code&gt; and one &lt;code&gt;nout&lt;/code&gt;, where the first function accepts &lt;code&gt;numpy.int32&lt;/code&gt; and the the second &lt;code&gt;numpy.int64&lt;/code&gt;, with both returning &lt;code&gt;numpy.bool_&lt;/code&gt;, &lt;code&gt;types&lt;/code&gt; would be &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; since &lt;code&gt;NPY_INT32&lt;/code&gt; is 5, &lt;code&gt;NPY_INT64&lt;/code&gt; is 7, and &lt;code&gt;NPY_BOOL&lt;/code&gt; is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ba05a259a8b34022dc6e1b217b0390cf104e0b" translate="yes" xml:space="preserve">
          <source>Length &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; array of &lt;code&gt;char&lt;/code&gt; encoding the &lt;a href=&quot;generated/numpy.dtype.num#numpy.dtype.num&quot;&gt;&lt;code&gt;numpy.dtype.num&lt;/code&gt;&lt;/a&gt; (built-in only) that the corresponding function in the &lt;code&gt;func&lt;/code&gt; array accepts. For instance, for a comparison ufunc with three &lt;code&gt;ntypes&lt;/code&gt;, two &lt;code&gt;nin&lt;/code&gt; and one &lt;code&gt;nout&lt;/code&gt;, where the first function accepts &lt;code&gt;numpy.int32&lt;/code&gt; and the the second &lt;code&gt;numpy.int64&lt;/code&gt;, with both returning &lt;code&gt;numpy.bool_&lt;/code&gt;, &lt;code&gt;types&lt;/code&gt; would be &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; since &lt;code&gt;NPY_INT32&lt;/code&gt; is 5, &lt;code&gt;NPY_INT64&lt;/code&gt; is 7, and &lt;code&gt;NPY_BOOL&lt;/code&gt; is 0.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 长度 &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; 数组，对 &lt;code&gt;func&lt;/code&gt; 数组中的相应函数接受的&lt;a href=&quot;generated/numpy.dtype.num#numpy.dtype.num&quot;&gt; &lt;code&gt;numpy.dtype.num&lt;/code&gt; &lt;/a&gt;（仅内置）进行编码。例如，对于具有三个 &lt;code&gt;ntypes&lt;/code&gt; ，两个 &lt;code&gt;nin&lt;/code&gt; 和一个 &lt;code&gt;nout&lt;/code&gt; 的比较ufunc，其中第一个函数接受 &lt;code&gt;numpy.int32&lt;/code&gt; ，第二个 &lt;code&gt;numpy.int64&lt;/code&gt; 都返回 &lt;code&gt;numpy.bool_&lt;/code&gt; ， &lt;code&gt;types&lt;/code&gt; 将是 &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; &lt;code&gt;NPY_INT32&lt;/code&gt; }，因为NPY_INT32为5， &lt;code&gt;NPY_INT64&lt;/code&gt; 为7，而 &lt;code&gt;NPY_BOOL&lt;/code&gt; 为0。</target>
        </trans-unit>
        <trans-unit id="e599dfd0500969f55b8c9d010461f8e1fcc41925" translate="yes" xml:space="preserve">
          <source>Length of each array element, in number of characters. Default is 1.</source>
          <target state="translated">每个数组元素的长度,以字符数为单位。默认为1。</target>
        </trans-unit>
        <trans-unit id="6dbef5ea0e7b53958b8a2d75b0863dd2996ea77a" translate="yes" xml:space="preserve">
          <source>Length of one array element in bytes.</source>
          <target state="translated">一个数组元素的长度,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="ebd0316d087a92fa193507d4dfe490f6483edcaf" translate="yes" xml:space="preserve">
          <source>Length of the inverse FFT, the number of points along transformation axis in the input to use. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used.</source>
          <target state="translated">逆FFT的长度，输入中沿变换轴使用的点数。如果 &lt;code&gt;n&lt;/code&gt; 小于输入的长度，则裁剪输入。如果较大，则输入将填充零。如果未指定 &lt;code&gt;n&lt;/code&gt; ，则使用输入沿由axis指定的 &lt;code&gt;axis&lt;/code&gt; 长度。</target>
        </trans-unit>
        <trans-unit id="c0386e146b5b66f11c90240baf5f54bbd4a84b7b" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2 + 1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is determined from the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">输出的转换轴的长度。对于 &lt;code&gt;n&lt;/code&gt; 个输出点，需要 &lt;code&gt;n//2 + 1&lt;/code&gt; 输入点。如果输入长于此长度，则将对其进行裁剪。如果比这短，则用零填充。如果未给出 &lt;code&gt;n&lt;/code&gt; ，则由输入沿沿着axis指定的 &lt;code&gt;axis&lt;/code&gt; 的长度确定。</target>
        </trans-unit>
        <trans-unit id="4f13f9612cce3a275a1186d10417cbf86f8f9b46" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2 + 1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is taken to be &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef669ab3a842002f9a1fb7bac5550ccceaa27247" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2+1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is determined from the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">输出的转换轴的长度。对于 &lt;code&gt;n&lt;/code&gt; 个输出点，需要 &lt;code&gt;n//2+1&lt;/code&gt; 输入点。如果输入长于此长度，则将对其进行裁剪。如果比这短，则用零填充。如果未给出 &lt;code&gt;n&lt;/code&gt; ，则由输入沿沿着axis指定的 &lt;code&gt;axis&lt;/code&gt; 的长度确定。</target>
        </trans-unit>
        <trans-unit id="1393d388a3302d35f0092d404b2ba089179672a7" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2+1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is taken to be &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9649fc48731a6d9a87c71452f8efbcb7f76b78d4" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used.</source>
          <target state="translated">输出的转换轴的长度。如果 &lt;code&gt;n&lt;/code&gt; 小于输入的长度，则裁剪输入。如果较大，则输入将填充零。如果未指定 &lt;code&gt;n&lt;/code&gt; ，则使用输入沿由axis指定的 &lt;code&gt;axis&lt;/code&gt; 长度。</target>
        </trans-unit>
        <trans-unit id="838e5e82eb9b3c833687dc387dbd43309bd32602" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used. See notes about padding issues.</source>
          <target state="translated">输出的转换轴的长度。如果 &lt;code&gt;n&lt;/code&gt; 小于输入的长度，则裁剪输入。如果较大，则输入将填充零。如果未指定 &lt;code&gt;n&lt;/code&gt; ，则使用输入沿由axis指定的 &lt;code&gt;axis&lt;/code&gt; 长度。请参阅有关填充问题的注释。</target>
        </trans-unit>
        <trans-unit id="20b7b6096b899f364abc1b0ab113ac1d88c95817" translate="yes" xml:space="preserve">
          <source>Lentner, Marvin, &amp;ldquo;Elementary Applied Statistics&amp;rdquo;, Bogden and Quigley, 1972.</source>
          <target state="translated">马文&amp;middot;伦特纳（Lentner，Marvin），&amp;ldquo;基本应用统计学&amp;rdquo;，博格登和奎格利，1972年。</target>
        </trans-unit>
        <trans-unit id="ad48dd4be642df433d10c28592cb939dc42a109f" translate="yes" xml:space="preserve">
          <source>Less Basic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99e5b627f7ed42d45bd8cf2acdec386f4c6174c" translate="yes" xml:space="preserve">
          <source>Less robust estimator that that takes into account data variability and data size.</source>
          <target state="translated">考虑到数据变异性和数据大小的稳健性较低的估计器。</target>
        </trans-unit>
        <trans-unit id="ef5fe1edf37940bd463fee8eda068dc8d66b0f8a" translate="yes" xml:space="preserve">
          <source>Let</source>
          <target state="translated">Let</target>
        </trans-unit>
        <trans-unit id="a718bc5ba689b0611826e8a00c42db91a4cc33c1" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;M = A.ndim&lt;/code&gt;, &lt;code&gt;N = B.ndim&lt;/code&gt;. Then the result, &lt;code&gt;C&lt;/code&gt;, of &lt;code&gt;op.outer(A, B)&lt;/code&gt; is an array of dimension M + N such that:</source>
          <target state="translated">令 &lt;code&gt;M = A.ndim&lt;/code&gt; ， &lt;code&gt;N = B.ndim&lt;/code&gt; 。那么结果， &lt;code&gt;C&lt;/code&gt; ，的 &lt;code&gt;op.outer(A, B)&lt;/code&gt; 是尺寸M + N，使得阵列：</target>
        </trans-unit>
        <trans-unit id="c21492f5c1039f68826ed62d8fddcbe2ecf43d60" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;x.shape&lt;/code&gt; be (10,20,30,40,50) and suppose &lt;code&gt;ind_1&lt;/code&gt; and &lt;code&gt;ind_2&lt;/code&gt; can be broadcast to the shape (2,3,4). Then &lt;code&gt;x[:,ind_1,ind_2]&lt;/code&gt; has shape (10,2,3,4,40,50) because the (20,30)-shaped subspace from X has been replaced with the (2,3,4) subspace from the indices. However, &lt;code&gt;x[:,ind_1,:,ind_2]&lt;/code&gt; has shape (2,3,4,10,30,50) because there is no unambiguous place to drop in the indexing subspace, thus it is tacked-on to the beginning. It is always possible to use &lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt;&lt;code&gt;.transpose()&lt;/code&gt;&lt;/a&gt; to move the subspace anywhere desired. Note that this example cannot be replicated using &lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">令 &lt;code&gt;x.shape&lt;/code&gt; 为（10,20,30,40,50）并假定 &lt;code&gt;ind_1&lt;/code&gt; 和 &lt;code&gt;ind_2&lt;/code&gt; 可以广播为形状（2,3,4）。然后 &lt;code&gt;x[:,ind_1,ind_2]&lt;/code&gt; 形状为（10,2,3,4,40,50），因为X的（20,30）形状的子空间已被X的（2,3,4）子空间替换索引。但是， &lt;code&gt;x[:,ind_1,:,ind_2]&lt;/code&gt; 形状为（2,3,4,10,30,50），因为在索引子空间中没有明确的放置位置，因此将其固定在开始位置。始终可以使用&lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt; &lt;code&gt;.transpose()&lt;/code&gt; &lt;/a&gt;将子空间移动到所需的任何位置。请注意，无法使用&lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;复制此示例。</target>
        </trans-unit>
        <trans-unit id="c5de9d97cc2b507966a716e78a84203d66bead94" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s apply the steps of wrapping Fortran functions to Python one by one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91c6bd95be9fba42070138c60bc544f63be79cf2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s check that this is what we expected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d53ca7c39e959075c64a326e51c71e27bb307d6d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider a list of elements, &lt;code&gt;x&lt;/code&gt;, where values of -9999. represent missing data. We wish to compute the average value of the data and the vector of anomalies (deviations from the average):</source>
          <target state="translated">让我们考虑元素列表 &lt;code&gt;x&lt;/code&gt; ，其中-9999的值。代表缺少的数据。我们希望计算数据的平均值和异常向量（与平均值的偏差）：</target>
        </trans-unit>
        <trans-unit id="2913bcf139d6f47d02c0ac2f1be4a80f4a447c13" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider an array &lt;code&gt;d&lt;/code&gt; of floats between 0 and 1. We wish to compute the average of the values of &lt;code&gt;d&lt;/code&gt; while ignoring any data outside the range &lt;code&gt;[0.2, 0.9]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab1ea5de1d1447221ec240c0905b303173635736" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider an array &lt;code&gt;d&lt;/code&gt; of random floats between 0 and 1. We wish to compute the average of the values of &lt;code&gt;d&lt;/code&gt; while ignoring any data outside the range &lt;code&gt;[0.1, 0.9]&lt;/code&gt;:</source>
          <target state="translated">让我们考虑一个介于0和1之间的随机浮点数 &lt;code&gt;d&lt;/code&gt; 。我们希望计算 &lt;code&gt;d&lt;/code&gt; 值的平均值，而忽略范围 &lt;code&gt;[0.1, 0.9]&lt;/code&gt; 之外的任何数据：</target>
        </trans-unit>
        <trans-unit id="39281dff86138ded282e6212c34eb9cda8834f15" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do 20,000 trials of the model, and count the number that generate zero positive results.</source>
          <target state="translated">让我们对模型进行20,000次试验，并计算产生零阳性结果的数目。</target>
        </trans-unit>
        <trans-unit id="1b9b5278ac2afa5e3136c310885e0f8fd06a8be2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s explore a more advanced concept in numpy called broadcasting. The term broadcasting describes how numpy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is &amp;ldquo;broadcast&amp;rdquo; across the larger array so that they have compatible shapes. Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. It does this without making needless copies of data and usually leads to efficient algorithm implementations. There are also cases where broadcasting is a bad idea because it leads to inefficient use of memory that slows computation. This article provides a gentle introduction to broadcasting with numerous examples ranging from simple to involved. It also provides hints on when and when not to use broadcasting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b59fac8428f8c1733e5af773d6cbf876149f27" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at two examples we&amp;rsquo;ve seen before to see how they might be implemented using Cython. These examples were compiled into extension modules using Cython 0.21.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddfef2ee46e1e4256e10013c995a2b4530178cef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say the two integers were in fact 1 and 770. Because 770 = 256 * 3 + 2, the 4 bytes in memory would contain respectively: 0, 1, 3, 2. The bytes I have loaded from the file would have these contents:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95938c655542a69cb7228f0ca9c4b635920085cc" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you create this array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b85caabf5e3eeb59af1ba993281156e38d2a215" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have this array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d641e5a95c4dff41b3615beef8a44670fd8d8071" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this goes for our array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663e98c256d28e922f69b08f25c6c3b896decad0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this works in practice with just one matrix first. Note that according to &lt;a href=&quot;https://en.wikipedia.org/wiki/Grayscale#Colorimetric_(perceptual_luminance-preserving)_conversion_to_grayscale&quot;&gt;colorimetry&lt;/a&gt;, it is possible to obtain a fairly reasonable grayscale version of our color image if we apply the formula</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba48f83aec5246b87728fc21ac0f71842c7f7846" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with this array, called &amp;ldquo;a&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="8be2fdf380d9d18148fd2ad94dc354c20768a219" translate="yes" xml:space="preserve">
          <source>License of NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538c09161b8497f998404cafc34964ed3a445575" translate="yes" xml:space="preserve">
          <source>Licensed under the 3-clause BSD License.</source>
          <target state="translated">采用3-clause BSD授权。</target>
        </trans-unit>
        <trans-unit id="b0484b837c9aac64b9b4f0cbb8a409c60f826cd6" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#c.PyArray_DescrConverter&quot;&gt;&lt;code&gt;PyArray_DescrConverter&lt;/code&gt;&lt;/a&gt; except it aligns C-struct-like objects on word-boundaries as the compiler would.</source>
          <target state="translated">像&lt;a href=&quot;#c.PyArray_DescrConverter&quot;&gt; &lt;code&gt;PyArray_DescrConverter&lt;/code&gt; &lt;/a&gt;一样，除了它像编译器一样在字边界上对齐类似于C结构的对象。</target>
        </trans-unit>
        <trans-unit id="2bf9a983b58a3025088acd0d34cc34c35bed8eba" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#c.PyArray_DescrConverter2&quot;&gt;&lt;code&gt;PyArray_DescrConverter2&lt;/code&gt;&lt;/a&gt; except it aligns C-struct-like objects on word-boundaries as the compiler would.</source>
          <target state="translated">像&lt;a href=&quot;#c.PyArray_DescrConverter2&quot;&gt; &lt;code&gt;PyArray_DescrConverter2&lt;/code&gt; &lt;/a&gt;一样，除了它像编译器一样在字边界上对齐C结构对象。</target>
        </trans-unit>
        <trans-unit id="98e8d5db12d0ec6df75e2b77dc6308321b737245" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;generated/numpy.char.find#numpy.char.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">类似于&lt;a href=&quot;generated/numpy.char.find#numpy.char.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt;，但是在未找到子字符串时引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cac4055aba9315ef35a508ccbff6fd2fccbce50" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;generated/numpy.char.rfind#numpy.char.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">类似于&lt;a href=&quot;generated/numpy.char.rfind#numpy.char.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt;，但是在未找到子字符串 &lt;code&gt;sub&lt;/code&gt; 时引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bfb637364ad5b206ba50bed21f3142c132fe9341" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.find.html#numpy.chararray.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.find.html#numpy.chararray.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt;，但是在未找到子字符串时引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f8c624e10b2f68f4700be90af9ceef9f419abcf" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.rfind.html#numpy.chararray.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.rfind.html#numpy.chararray.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt;，但是在未找到子字符串 &lt;code&gt;sub&lt;/code&gt; 时引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74d7df04563822c7d8ad24dbe267870b77fbb351" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.char.find#numpy.char.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">类似于&lt;a href=&quot;numpy.char.find#numpy.char.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt;，但是在未找到子字符串时引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b35ea9f95fe9a083c883dcd6041e1ed2b46d8192" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.char.rfind#numpy.char.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">类似于&lt;a href=&quot;numpy.char.rfind#numpy.char.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt;，但是在未找到子字符串 &lt;code&gt;sub&lt;/code&gt; 时引发 &lt;code&gt;ValueError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1381300ae7e04647799c4d29476d81d2674e1d00" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.chararray.find#numpy.chararray.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6baf9238888e49aa859d8fb862f39242936cfbf" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.chararray.rfind#numpy.chararray.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f6786bbc0e6826ccf967ce3d26832cec08da525" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;catch_warnings&lt;/code&gt; this context manager is not threadsafe.</source>
          <target state="translated">像 &lt;code&gt;catch_warnings&lt;/code&gt; 一样，此上下文管理器也不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="4988e06267fc3ad462b8b1372828e98aa6abe4ae" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;recfromtxt&lt;/code&gt;, but with a default &lt;code&gt;delimiter=&quot;,&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0fa83334e9080fab8905202d2a0b49831c3f225" translate="yes" xml:space="preserve">
          <source>Like for other types, NumPy includes a typedef npy_half for the 16 bit float. Unlike for most of the other types, you cannot use this as a normal type in C, since it is a typedef for npy_uint16. For example, 1.0 looks like 0x3c00 to C, and if you do an equality comparison between the different signed zeros, you will get -0.0 != 0.0 (0x8000 != 0x0000), which is incorrect.</source>
          <target state="translated">和其他类型一样,NumPy包含了一个类型定义npy_half,用于16位浮点。与大多数其他类型不同的是,在C语言中你不能将其作为普通类型使用,因为它是npy_uint16的类型定义。例如,1.0在C语言中看起来像0x3c00,如果你在不同的有符号的0之间做一个等价比较,你将得到-0.0 !=0.0 (0x8000 !=0x0000),这是不正确的。</target>
        </trans-unit>
        <trans-unit id="e112999c2cd378720fa09f5bf6d3cb8761f7e014" translate="yes" xml:space="preserve">
          <source>Like with some other special methods in python, such as &lt;code&gt;__hash__&lt;/code&gt; and &lt;code&gt;__iter__&lt;/code&gt;, it is possible to indicate that your class does &lt;em&gt;not&lt;/em&gt; support ufuncs by setting &lt;code&gt;__array_ufunc__ = None&lt;/code&gt;. Ufuncs always raise &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; when called on an object that sets &lt;code&gt;__array_ufunc__ = None&lt;/code&gt;.</source>
          <target state="translated">像Python中其他一些特殊的方法，如 &lt;code&gt;__hash__&lt;/code&gt; 和 &lt;code&gt;__iter__&lt;/code&gt; ，有可能表明你的类并&lt;em&gt;没有&lt;/em&gt;通过设置支持ufuncs &lt;code&gt;__array_ufunc__ = None&lt;/code&gt; 。当对设置 &lt;code&gt;__array_ufunc__ = None&lt;/code&gt; 的对象进行调用时，Ufunc始终会引发&lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4aa7900482808a9df749231293505b57d3e3de9c" translate="yes" xml:space="preserve">
          <source>Likewise, ellipsis can be specified by code by using the Ellipsis object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3297842e50729fb77f4f0545de2f9ff7aa3909b6" translate="yes" xml:space="preserve">
          <source>Likewise, slicing can be combined with broadcasted boolean indices:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="aed0f783a12a4ca0992442cfbd711f6845a91b7b" translate="yes" xml:space="preserve">
          <source>Limpert, E., Stahel, W. A., and Abbt, M., &amp;ldquo;Log-normal Distributions across the Sciences: Keys and Clues,&amp;rdquo; BioScience, Vol. 51, No. 5, May, 2001. &lt;a href=&quot;https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf&quot;&gt;https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf&lt;/a&gt;</source>
          <target state="translated">Limpert，E.，Stahel，WA和Abbt，M。，&amp;ldquo;整个科学的对数正态分布：键和线索&amp;rdquo;，《生物科学》，第1卷。51，第5号，2001年5月&lt;a href=&quot;https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf&quot;&gt;.https：//stat.ethz.ch/~stahel/lognormal/bioscience.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2c6327e28944d450d23eb12c3f0eb10b95ac744a" translate="yes" xml:space="preserve">
          <source>LinAlgError</source>
          <target state="translated">LinAlgError</target>
        </trans-unit>
        <trans-unit id="fbfdf4025591ea0589baa96d7f54fd5d7f0a5dbd" translate="yes" xml:space="preserve">
          <source>Line breaks are not included in the resulting list unless keepends is given and true.</source>
          <target state="translated">除非给定了keepends且为真,否则换行符不会包含在结果列表中。</target>
        </trans-unit>
        <trans-unit id="fd8f1853d29d8157d704e36102bd70d85ec315bd" translate="yes" xml:space="preserve">
          <source>Line spacing and indentation are significant and should be carefully followed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb739908d0a50031f680d3b4fffc6749c4002d3" translate="yes" xml:space="preserve">
          <source>Linear Algebra</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2d7925777b262f78b0ed1ceeb1f07eef61acc7" translate="yes" xml:space="preserve">
          <source>Linear Algebra Equivalents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77bb2c05a2dcf0461045da9b6109d509594fc9a" translate="yes" xml:space="preserve">
          <source>Linear Algebra libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d74260ba46e8ed76ff22dda956f18a7b66203c" translate="yes" xml:space="preserve">
          <source>Linear algebra</source>
          <target state="translated">线性代数</target>
        </trans-unit>
        <trans-unit id="ef4be3efd16d5b211ab89b5efbf030ca1bafba61" translate="yes" xml:space="preserve">
          <source>Linear algebra (&lt;code&gt;numpy.linalg&lt;/code&gt;)</source>
          <target state="translated">线性代数（ &lt;code&gt;numpy.linalg&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e2be6b18cf91c04a7b6c400bd00876f94a2389cb" translate="yes" xml:space="preserve">
          <source>Linear algebra (numpy.linalg)</source>
          <target state="translated">线性代数 (numpy.linalg)</target>
        </trans-unit>
        <trans-unit id="b624aab78757a9b353883b1449d6df824049976b" translate="yes" xml:space="preserve">
          <source>Linear algebra on several matrices at once</source>
          <target state="translated">在多个矩阵上同时进行线性代数运算。</target>
        </trans-unit>
        <trans-unit id="991cbbcb4b1ecb2172a95ff800353dc3c4b54edd" translate="yes" xml:space="preserve">
          <source>Linear map parameters between domains.</source>
          <target state="translated">域间线性映射参数。</target>
        </trans-unit>
        <trans-unit id="eb36eb210c8667bae908d8f0d19ef3098c4c1701" translate="yes" xml:space="preserve">
          <source>Link extension module with &amp;lt;resource&amp;gt; as defined by &lt;code&gt;numpy_distutils/system_info.py&lt;/code&gt;. E.g. to link with optimized LAPACK libraries (vecLib on MacOSX, ATLAS elsewhere), use &lt;code&gt;--link-lapack_opt&lt;/code&gt;. See also &lt;code&gt;--help-link&lt;/code&gt; switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26958b7c786c621d84d02830a0b14f77df5b2d9e" translate="yes" xml:space="preserve">
          <source>Linking against the core math library in an extension</source>
          <target state="translated">在扩展中针对核心数学库进行链接。</target>
        </trans-unit>
        <trans-unit id="f9ddb8c3deec44cd98e047bb68bdaf188f3b72f8" translate="yes" xml:space="preserve">
          <source>Linking your repository to the upstream repo</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="2d54756ca8573af092113bb3435c0903eeb35dd6" translate="yes" xml:space="preserve">
          <source>Links : If you need to include hyperlinks in your docstring, note that some docstring sections are not parsed as standard reST, and in these sections, numpydoc may become confused by hyperlink targets such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="518ed7ba947b32b000717c46a46d61dd856bd112" translate="yes" xml:space="preserve">
          <source>Linus Torvalds on &lt;a href=&quot;http://kerneltrap.org/Linux/Git_Management&quot;&gt;git management&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965d93d3a9947030cc756b2db0fcacc76437a993" translate="yes" xml:space="preserve">
          <source>Linus Torvalds on &lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;linux git workflow&lt;/a&gt; . Summary; use the git tools to make the history of your edits as clean as possible; merge from upstream edits as little as possible in branches where you are doing active development.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="d1400c37d080d60eab76dbcb84834f7292aae696" translate="yes" xml:space="preserve">
          <source>Linux timings used Ubuntu 18.04 and GCC 7.4. Windows timings were made on Windows 10 using Microsoft C/C++ Optimizing Compiler Version 19 (Visual Studio 2015). All timings were produced on a i5-3570 processor.</source>
          <target state="translated">Linux定时使用Ubuntu 18.04和GCC 7.4。Windows定时是在Windows 10上使用Microsoft C/C++优化编译器19版(Visual Studio 2015)制作的。所有计时都是在i5-3570处理器上制作的。</target>
        </trans-unit>
        <trans-unit id="56d0cc5c207ff297b983e9b52ef59aa241b28b67" translate="yes" xml:space="preserve">
          <source>Linux timings used Ubuntu 18.04 and GCC 7.4. Windows timings were made on Windows 10 using Microsoft C/C++ Optimizing Compiler Version 19 (Visual Studio 2015). All timings were produced on an i5-3570 processor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87860891be4cddda593f0fa03126f25fb568db9f" translate="yes" xml:space="preserve">
          <source>Linux: 32-bit and 64-bit Manylinux1 wheels built using travis-ci.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97d9791ab8737c4211f3e78630cca56638f02eb1" translate="yes" xml:space="preserve">
          <source>List available Fortran compilers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb5d7118db68e7b8996c3d0844e8e2d779102b13" translate="yes" xml:space="preserve">
          <source>List of array-like objects (such as lists, tuples, and ndarrays).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="decb4e37dac06b0a04b2b5a1ce16d06dbaf9430d" translate="yes" xml:space="preserve">
          <source>List of maximum degrees of the form [x_deg, y_deg, z_deg].</source>
          <target state="translated">表格[x_deg,y_deg,z_deg]的最大度数列表。</target>
        </trans-unit>
        <trans-unit id="16b40ddc35115642a1ebd2b343c063499d9e736a" translate="yes" xml:space="preserve">
          <source>List of maximum degrees of the form [x_deg, y_deg].</source>
          <target state="translated">表格[x_deg,y_deg]的最大度数列表。</target>
        </trans-unit>
        <trans-unit id="3946ce7ee00307be1e56a351d33b3682868445a4" translate="yes" xml:space="preserve">
          <source>List of roots.</source>
          <target state="translated">根的清单。</target>
        </trans-unit>
        <trans-unit id="4e5a894ae66af5e5eb828b13d596e0e9298ff835" translate="yes" xml:space="preserve">
          <source>List of source file locations relative to the top directory of the package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7afb1b33d8f0bf102c5fdc5f3bfa27a81be1cb" translate="yes" xml:space="preserve">
          <source>List of the library&amp;rsquo;s source files. See &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_library&quot;&gt;&lt;code&gt;add_library&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">库的源文件列表。有关详细信息，请参见&lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_library&quot;&gt; &lt;code&gt;add_library&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5754e63d6ae44ac265c0defe49c460674a2539b7" translate="yes" xml:space="preserve">
          <source>List of the most important terms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6519aa721c25f67c763afcfac03293aba9cab8a8" translate="yes" xml:space="preserve">
          <source>List of the sources. The list of sources may contain functions (called source generators) which must take an extension instance and a build directory as inputs and return a source file or list of source files or None. If None is returned then no sources are generated. If the Extension instance has no sources after processing all source generators, then no extension module is built.</source>
          <target state="translated">源文件列表。源文件列表可以包含函数(称为源文件生成器),这些函数必须以扩展实例和构建目录作为输入,并返回一个源文件或源文件列表或None。如果返回None,则不生成源文件。如果Extension实例在处理完所有源文件生成器后没有源文件,那么就不会构建扩展模块。</target>
        </trans-unit>
        <trans-unit id="2485a7cc99c4617bf66ce59e5b75a2d0c1ccfb4b" translate="yes" xml:space="preserve">
          <source>List system resources found by &lt;code&gt;numpy_distutils/system_info.py&lt;/code&gt;. For example, try &lt;code&gt;f2py --help-link lapack_opt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50800b4f18e2a927baac61501f7e23170e957be0" translate="yes" xml:space="preserve">
          <source>List with any extra arguments to pass to nosetests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70836ea6cfbd010e5c69675c6ed9768657e90763" translate="yes" xml:space="preserve">
          <source>Literal string representation.</source>
          <target state="translated">字符串表示。</target>
        </trans-unit>
        <trans-unit id="d75a54184aa53b5be4e832c635455d88f3cdc5e6" translate="yes" xml:space="preserve">
          <source>Load a pickle from the current string.</source>
          <target state="translated">从当前字符串中加载一个泡菜。</target>
        </trans-unit>
        <trans-unit id="3a504cdc1122f04029c4d408c355532536995f45" translate="yes" xml:space="preserve">
          <source>Load arrays or pickled objects from &lt;code&gt;.npy&lt;/code&gt;, &lt;code&gt;.npz&lt;/code&gt; or pickled files.</source>
          <target state="translated">从 &lt;code&gt;.npy&lt;/code&gt; ， &lt;code&gt;.npz&lt;/code&gt; 或腌制的文件中加载数组或腌制的对象。</target>
        </trans-unit>
        <trans-unit id="9d2a30e3c587d0309a2b15e920e2381e52d3b73a" translate="yes" xml:space="preserve">
          <source>Load data from a text file, with missing values handled as specified.</source>
          <target state="translated">从文本文件加载数据,缺失值按指定处理。</target>
        </trans-unit>
        <trans-unit id="671e399a95a295b1b112f2ec88bde3aa682ce01d" translate="yes" xml:space="preserve">
          <source>Load data from a text file.</source>
          <target state="translated">从文本文件加载数据。</target>
        </trans-unit>
        <trans-unit id="ede7696890a000813048b7b45d0ec4e8eaa41ac3" translate="yes" xml:space="preserve">
          <source>Load data with missing values handled as specified.</source>
          <target state="translated">加载数据的缺失值按指定处理。</target>
        </trans-unit>
        <trans-unit id="0fb4575d68b4fb0f498f6ef6cd58ad29dfef99ec" translate="yes" xml:space="preserve">
          <source>Load the files created by savez_compressed.</source>
          <target state="translated">装入由savez_compressed创建的文件。</target>
        </trans-unit>
        <trans-unit id="00e2276e50083512489893c74a3667bfb2f8d261" translate="yes" xml:space="preserve">
          <source>Load the memmap and verify data was stored:</source>
          <target state="translated">加载memmap并验证数据是否被存储。</target>
        </trans-unit>
        <trans-unit id="f5bde0422e688546d3fcbda903a1675bdef859be" translate="yes" xml:space="preserve">
          <source>Load the shared library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1b35f9beeb82ff23b55bdd7e4bccbaa09655da" translate="yes" xml:space="preserve">
          <source>Loading files that contain object arrays uses the &lt;code&gt;pickle&lt;/code&gt; module, which is not secure against erroneous or maliciously constructed data. Consider passing &lt;code&gt;allow_pickle=False&lt;/code&gt; to load data that is known not to contain object arrays for the safer handling of untrusted sources.</source>
          <target state="translated">加载包含对象数组的文件时，会使用 &lt;code&gt;pickle&lt;/code&gt; 模块，该模块对于错误或恶意构建的数据并不安全。考虑传递 &lt;code&gt;allow_pickle=False&lt;/code&gt; 来加载已知不包含对象数组的数据，以便更安全地处理不受信任的源。</target>
        </trans-unit>
        <trans-unit id="dc43ff557f7299b63c00a5f98241bc55534a0318" translate="yes" xml:space="preserve">
          <source>Loading the shared library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd21227c7ed1f7628c4569c3c3b1f97f5e4a3e0" translate="yes" xml:space="preserve">
          <source>Local file path or URL to open.</source>
          <target state="translated">本地文件路径或打开的URL。</target>
        </trans-unit>
        <trans-unit id="399e1ff0ce348a172dad0b088afb4891c55b0357" translate="yes" xml:space="preserve">
          <source>Lock instance that is shared so that the same BitGenerator can be used in multiple Generators without corrupting the state. Code that generates values from a bit generator should hold the bit generator&amp;rsquo;s lock.</source>
          <target state="translated">共享的锁实例，以便同一BitGenerator可以在多个Generator中使用，而不会破坏状态。从位生成器生成值的代码应持有位生成器的锁。</target>
        </trans-unit>
        <trans-unit id="2d415fb960b72005c6491287e9aedba95abd331c" translate="yes" xml:space="preserve">
          <source>Lock instance that is shared so that the same bit git generator can be used in multiple Generators without corrupting the state. Code that generates values from a bit generator should hold the bit generator&amp;rsquo;s lock.</source>
          <target state="translated">共享的锁实例，以便同一位git generator可以在多个Generator中使用，而不会破坏状态。从位生成器生成值的代码应持有位生成器的锁。</target>
        </trans-unit>
        <trans-unit id="107cbe58cd70b9b9564b7a980ec9a134ba83ff37" translate="yes" xml:space="preserve">
          <source>Log error message:</source>
          <target state="translated">记录错误信息。</target>
        </trans-unit>
        <trans-unit id="4eb269913863abecf02addc638fee893d2c7588f" translate="yes" xml:space="preserve">
          <source>Log into your &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b18e27bd081f5e88f5467d9d05245be1522ecbd" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;10**z = x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">对数是一个多值函数：每个 &lt;code&gt;x&lt;/code&gt; 都有无限个 &lt;code&gt;z&lt;/code&gt; ，使得 &lt;code&gt;10**z = x&lt;/code&gt; 。惯例是返回虚部在 &lt;code&gt;[-pi, pi]&lt;/code&gt; 的 &lt;code&gt;z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a52fe88f1d34f63b32537a63132c16ed59948f4" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;2**z = x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">对数是一个多值函数：每个 &lt;code&gt;x&lt;/code&gt; 都有无限个 &lt;code&gt;z&lt;/code&gt; ，使得 &lt;code&gt;2**z = x&lt;/code&gt; 。惯例是返回虚部在 &lt;code&gt;[-pi, pi]&lt;/code&gt; 的 &lt;code&gt;z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04517496328a3b4c1d39612790fc59d3b950de57" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;exp(z) = 1 + x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">对数是一个多值函数：每个 &lt;code&gt;x&lt;/code&gt; 都有无限多个 &lt;code&gt;z&lt;/code&gt; ，使得 &lt;code&gt;exp(z) = 1 + x&lt;/code&gt; 。惯例是返回虚部在 &lt;code&gt;[-pi, pi]&lt;/code&gt; 的 &lt;code&gt;z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f044358a356b12f8f04d65ec46fba2c711db9ca" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;exp(z) = x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">对数是一个多值函数：每个 &lt;code&gt;x&lt;/code&gt; 都有无限个 &lt;code&gt;z&lt;/code&gt; ，使得 &lt;code&gt;exp(z) = x&lt;/code&gt; 。惯例是返回虚部在 &lt;code&gt;[-pi, pi]&lt;/code&gt; 的 &lt;code&gt;z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="166930005429709b3b373125970bc9f001b57f22" translate="yes" xml:space="preserve">
          <source>Logarithm of &lt;code&gt;exp(x1) + exp(x2)&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;exp(x1) + exp(x2)&lt;/code&gt; 对数。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="0df50307c119146d5dc714638f54a5eccd592099" translate="yes" xml:space="preserve">
          <source>Logarithm of the sum of exponentiations of inputs in base 2.</source>
          <target state="translated">基数2的投入指数之和的对数。</target>
        </trans-unit>
        <trans-unit id="3a29b9b1054fef950824734dd96565e57e322c96" translate="yes" xml:space="preserve">
          <source>Logarithm of the sum of exponentiations of the inputs in base-2.</source>
          <target state="translated">基数2中的投入指数之和的对数。</target>
        </trans-unit>
        <trans-unit id="273c857a62012f5708232560c688d9c8f7c28ba5" translate="yes" xml:space="preserve">
          <source>Logarithm of the sum of exponentiations of the inputs.</source>
          <target state="translated">输入的指数之和的对数。</target>
        </trans-unit>
        <trans-unit id="e7b8fad3893b278189df782f86ba4d32084ced17" translate="yes" xml:space="preserve">
          <source>Logarithm to base 10 of the Euler constant (</source>
          <target state="translated">欧拉常数的10基对数(</target>
        </trans-unit>
        <trans-unit id="80963c1ddcee26932e512e1ef164c3f919eb6773" translate="yes" xml:space="preserve">
          <source>Logarithm to base 2 of the Euler constant (</source>
          <target state="translated">欧拉常数的基数2的对数(</target>
        </trans-unit>
        <trans-unit id="dca3308567585813d8c4516ae0b5df7d6382aa24" translate="yes" xml:space="preserve">
          <source>Logic functions</source>
          <target state="translated">逻辑功能</target>
        </trans-unit>
        <trans-unit id="acdcdb17721480a7efeeb33b0138faad218dbf31" translate="yes" xml:space="preserve">
          <source>Logical NOT is applied to the elements of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">逻辑非应用于 &lt;code&gt;x&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="98ddc2178009c7731c8ae53ab405983c8f38c802" translate="yes" xml:space="preserve">
          <source>Logical OR is applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">逻辑或应用于 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 的元素。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="f5bd72920a8d92e6480e74978ed9235cd1d3ad95" translate="yes" xml:space="preserve">
          <source>Logical XOR is applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">逻辑XOR应用于 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 的元素。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="ab411408fbd29ad68b53700b2e7826c03e6703f0" translate="yes" xml:space="preserve">
          <source>Logical operations</source>
          <target state="translated">逻辑运算</target>
        </trans-unit>
        <trans-unit id="f9360627c5984485d4c34bec86c9dfebc0835bd0" translate="yes" xml:space="preserve">
          <source>Logspace is equivalent to the code</source>
          <target state="translated">日志空间相当于以下代码</target>
        </trans-unit>
        <trans-unit id="05614c0010510d48dea6823d792acc33ba6daeb2" translate="yes" xml:space="preserve">
          <source>Long answer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfff3eff895eee45ffb53c164dd9129e264c6241" translate="yes" xml:space="preserve">
          <source>Long arrays can be summarised:</source>
          <target state="translated">可以对长数组进行总结。</target>
        </trans-unit>
        <trans-unit id="8677f57b867596167599f15cd53463b229e648c6" translate="yes" xml:space="preserve">
          <source>Lots of learning overhead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcabfd17cd19c7e1ebdad9125ee467aec3f27671" translate="yes" xml:space="preserve">
          <source>Low-level floating point manipulation</source>
          <target state="translated">低级浮点操作</target>
        </trans-unit>
        <trans-unit id="20bd4a379661919ac01507844a8735e9e7029b21" translate="yes" xml:space="preserve">
          <source>Low-level function which converts a 16-bit half-precision float into a 32-bit single-precision float, stored as a uint32.</source>
          <target state="translated">低级函数,将16位半精度浮点数转换为32位单精度浮点数,存储为uint32。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
