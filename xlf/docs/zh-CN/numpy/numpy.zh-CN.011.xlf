<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="55427a60a4bc7584f941291fc8f1c78e3b48892c" translate="yes" xml:space="preserve">
          <source>Fourteen C macros and fifteen C functions that can be used to write specialized typemaps, extensions, or inlined functions that handle cases not covered by the provided typemaps. Note that the macros and functions are coded specifically to work with the NumPy C/API regardless of NumPy version number, both before and after the deprecation of some aspects of the API after version 1.6.</source>
          <target state="translated">14个C语言宏和15个C语言函数,可用于编写专门的类型图、扩展或内联函数,以处理所提供的类型图未覆盖的情况。请注意,这些宏和函数是专门为NumPy C/API编写的,无论NumPy的版本号是什么,无论是在1.6版本之前还是之后API的某些方面被废弃之后。</target>
        </trans-unit>
        <trans-unit id="a55119325a9e50ab95a500e00074b97b1b9e36d5" translate="yes" xml:space="preserve">
          <source>Fractional part of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的小数部分。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="3ef0af518168c89e00d0d671000eff79ef6d0866" translate="yes" xml:space="preserve">
          <source>Francis Hunt and Paul Johnson, On the Pareto Distribution of Sourceforge projects.</source>
          <target state="translated">Francis Hunt和Paul Johnson,On the Pareto Distribution of Sourceforge projects.</target>
        </trans-unit>
        <trans-unit id="1702d7b8bdd07fbea0c5cab99e1759e69160609f" translate="yes" xml:space="preserve">
          <source>Frequency bins for given FFT parameters.</source>
          <target state="translated">给定FFT参数的频带。</target>
        </trans-unit>
        <trans-unit id="8c7beab7a6d84d3a1004bcc75ccd72648a4866a0" translate="yes" xml:space="preserve">
          <source>Frobenius norm</source>
          <target state="translated">夫罗奔尼乌斯规范</target>
        </trans-unit>
        <trans-unit id="b496ebf456418bea6f72b4dd532369d14b955f9b" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#r755c9bae090e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeadfde385f544a91cc8eaeeffa0c5ba93e6dc7d" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#r89f5270d198b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb8d23120bc74b1cfb060aa5332c0996e661cf6" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#r9f872b3c913b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="translated">在Dalgaard第83页&lt;a href=&quot;#r9f872b3c913b-1&quot; id=&quot;id3&quot;&gt;[1]中&lt;/a&gt;，假设11位女性的每日能量摄入量以千焦耳（kJ）为单位：</target>
        </trans-unit>
        <trans-unit id="449b24b6007276ad9bb465db2968bb8f2f82cb23" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#rb7c952f3992e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="translated">在Dalgaard第83页&lt;a href=&quot;#rb7c952f3992e-1&quot; id=&quot;id3&quot;&gt;[1]中&lt;/a&gt;，假设11位女性的每日能量摄入量以千焦耳（kJ）为单位：</target>
        </trans-unit>
        <trans-unit id="e91799328361ed7f1f3c997458139cffb3209540" translate="yes" xml:space="preserve">
          <source>From a 4x3 array the corner elements should be selected using advanced indexing. Thus all elements for which the column is one of &lt;code&gt;[0, 2]&lt;/code&gt; and the row is one of &lt;code&gt;[0, 3]&lt;/code&gt; need to be selected. To use advanced indexing one needs to select all elements &lt;em&gt;explicitly&lt;/em&gt;. Using the method explained previously one could write:</source>
          <target state="translated">从4x3数组中，应使用高级索引选择拐角元素。因此 &lt;code&gt;[0, 3]&lt;/code&gt; 需要选择列为[0，2]之一而行为[0，3 &lt;code&gt;[0, 2]&lt;/code&gt; 之一的所有元素。要使用高级索引，需要&lt;em&gt;明确&lt;/em&gt;选择所有元素。使用前面解释的方法，可以编写：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a91be0fd97aa12da8097d28986c00ba2a4f3a53c" translate="yes" xml:space="preserve">
          <source>From a Fortran routine signature F2PY generates a Python/C extension function that has the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f43663857b3b074086e6a5458d7eeb8cc710716c" translate="yes" xml:space="preserve">
          <source>From a date and time:</source>
          <target state="translated">从一个日期和时间。</target>
        </trans-unit>
        <trans-unit id="b27ac815b804369e0e908095a8f60fb839b9ffbc" translate="yes" xml:space="preserve">
          <source>From an array, select all rows which sum up to less or equal two:</source>
          <target state="translated">从一个数组中,选择所有加起来小于或等于2的行。</target>
        </trans-unit>
        <trans-unit id="0b1e37af40ab4883a1e4a8a3dc83bcc94bb649dc" translate="yes" xml:space="preserve">
          <source>From each row, a specific element should be selected. The row index is just &lt;code&gt;[0, 1, 2]&lt;/code&gt; and the column index specifies the element to choose for the corresponding row, here &lt;code&gt;[0, 1, 0]&lt;/code&gt;. Using both together the task can be solved using advanced indexing:</source>
          <target state="translated">从每一行中，应选择一个特定元素。行索引仅为 &lt;code&gt;[0, 1, 2]&lt;/code&gt; ，列索引指定要为相应行选择的元素，此处为 &lt;code&gt;[0, 1, 0]&lt;/code&gt; 。两者结合使用可以使用高级索引解决任务：</target>
        </trans-unit>
        <trans-unit id="2bdc929241ee7611d7ce8654d5c0e7a97c5922e2" translate="yes" xml:space="preserve">
          <source>From existing data</source>
          <target state="translated">根据现有数据</target>
        </trans-unit>
        <trans-unit id="1978da17047230ecfb709900d093fe2bc00bb2a8" translate="yes" xml:space="preserve">
          <source>From now on &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; will know that &lt;code&gt;my-new-feature&lt;/code&gt; is related to the &lt;code&gt;my-new-feature&lt;/code&gt; branch in your own &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; repo. Subsequent push calls are then simplified to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7dc9b3626b3cb541c458a7c7758c637090adb4" translate="yes" xml:space="preserve">
          <source>From other objects</source>
          <target state="translated">来自其他物体</target>
        </trans-unit>
        <trans-unit id="5dce71950093c2ccd6198a0075dc3e5ee84cb7ec" translate="yes" xml:space="preserve">
          <source>From scratch</source>
          <target state="translated">从零开始</target>
        </trans-unit>
        <trans-unit id="374969a1bf6cf09ab316c531b85ee98729ec817d" translate="yes" xml:space="preserve">
          <source>From the command line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8689c1f53f242e3e2ed351ba13d4443b972a335" translate="yes" xml:space="preserve">
          <source>From the output above, we can see that every value in &lt;code&gt;img[:,:,0]&lt;/code&gt; is an integer value between 0 and 255, representing the level of red in each corresponding image pixel (keep in mind that this might be different if you use your own image instead of &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.face.html#scipy.misc.face&quot;&gt;&lt;code&gt;scipy.misc.face&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="487083148a4854e5ec264b4e7603e6d383b8513e" translate="yes" xml:space="preserve">
          <source>From time to time you may want to pull down the latest code. Do this with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541d68d9d4a26a74b3b1aec38602641c99c42b4f" translate="yes" xml:space="preserve">
          <source>Full broadcasting support for &lt;code&gt;np.cross&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6cd09bf0f40761ab28ccaa4cab2a4c6c336752" translate="yes" xml:space="preserve">
          <source>Full indirect sort</source>
          <target state="translated">完全间接排序</target>
        </trans-unit>
        <trans-unit id="b5dd204ac7b63984bfca215999235cdddc1cbe34" translate="yes" xml:space="preserve">
          <source>Full indirect sort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d106cfe968d6ee1cdc60bee01550735688b85f7" translate="yes" xml:space="preserve">
          <source>Full sort.</source>
          <target state="translated">完整的排序。</target>
        </trans-unit>
        <trans-unit id="733bce60654becd4d4e1700d743ab7573d5f2742" translate="yes" xml:space="preserve">
          <source>Full sorting</source>
          <target state="translated">全面分类</target>
        </trans-unit>
        <trans-unit id="b375e36a5e2c847719599e1c9bc607f532495b26" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;median&lt;/code&gt; used with &lt;code&gt;overwrite_input&lt;/code&gt; only partially sorts array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b35686e8529228454146ad9f9eb6c40fa0abbf7c" translate="yes" xml:space="preserve">
          <source>Function and macro call style: &lt;code&gt;foo(a, b, c)&lt;/code&gt;, no space before the open paren, no spaces inside the parens, no spaces before commas, one space after each comma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="translated">函数调用</target>
        </trans-unit>
        <trans-unit id="5fafc2ca93d61a962accac1563a05d9b48e0a23a" translate="yes" xml:space="preserve">
          <source>Function decorator to apply certain suppressions to a whole function.</source>
          <target state="translated">函数装饰器,对整个函数进行一定的抑制。</target>
        </trans-unit>
        <trans-unit id="1ace8a404ff1b1cae179e78198d969ee763553f5" translate="yes" xml:space="preserve">
          <source>Function definition style: function name in column 1, outermost curly braces in column 1, blank line after local variable declarations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf873f24ebe960e5f8ab96d1bf1dafec8236126" translate="yes" xml:space="preserve">
          <source>Function documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6611eada8817f5f656a38dbcf1f891cb71be30b3" translate="yes" xml:space="preserve">
          <source>Function operating on ndarrays.</source>
          <target state="translated">对ndarrays进行操作的功能。</target>
        </trans-unit>
        <trans-unit id="7fb4f2de4dfb1639014358c3b7015d9c6a5f5d6b" translate="yes" xml:space="preserve">
          <source>Function pointer from &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt;&lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">来自&lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt; &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt; 的&lt;/a&gt;函数指针</target>
        </trans-unit>
        <trans-unit id="636b3b392dcabee45d972282bc714f124a2984ee" translate="yes" xml:space="preserve">
          <source>Function that converts a float array to float. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;. Note that this does not seem to do anything useful in the current implementation.</source>
          <target state="translated">将float数组转换为float的函数。默认为&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt;。注意，这在当前实现中似乎没有任何用处。</target>
        </trans-unit>
        <trans-unit id="25f491198ced438a979dee0c06f7b99f4c27522c" translate="yes" xml:space="preserve">
          <source>Function that converts a float or float array to an integer or integer array. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将float或float数组转换为整数或整数数组的函数。默认为&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1c65cb38bc5533518bfad836c738613691b12bd" translate="yes" xml:space="preserve">
          <source>Function that converts a single float to a string. Default is &lt;code&gt;lambda v:'%24.16e' %v&lt;/code&gt;.</source>
          <target state="translated">将单个float转换为字符串的函数。默认值为 &lt;code&gt;lambda v:'%24.16e' %v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49e035248ad61f94c49b3411ced40a15d03e994b" translate="yes" xml:space="preserve">
          <source>Function that converts an integer or integer array to a float or float array. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将整数或整数数组转换为float或float数组的函数。默认为&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81aebc7824dc558f5740b2294a8d328bfb265c12" translate="yes" xml:space="preserve">
          <source>Function to apply on the &amp;ldquo;field&amp;rdquo; dimension. This function must support an &lt;code&gt;axis&lt;/code&gt; argument, like np.mean, np.sum, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cdbff65d2dcd6dbb1f176839d343d5cd6740b77" translate="yes" xml:space="preserve">
          <source>Function to be used to pretty print arrays. The function should expect a single array argument and return a string of the representation of the array. If None, the function is reset to the default NumPy function to print arrays.</source>
          <target state="translated">用于打印数组的函数。该函数应该期望一个数组参数,并返回一个数组的表示形式的字符串,如果None,则该函数被重置为默认的NumPy函数来打印数组。如果为None,则函数被重置为默认的NumPy函数来打印数组。</target>
        </trans-unit>
        <trans-unit id="2e5428e59d421faf071ea47a590fb561ece5a39d" translate="yes" xml:space="preserve">
          <source>Function to calculate only the edges of the bins used by the &lt;a href=&quot;generated/numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">仅计算&lt;a href=&quot;generated/numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt;功能使用的仓的边缘的功能。</target>
        </trans-unit>
        <trans-unit id="ecfa9e590ef0d3ed65da85a7cdda1af66b824ea3" translate="yes" xml:space="preserve">
          <source>Function to calculate only the edges of the bins used by the &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">仅计算&lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt;功能使用的仓的边缘的功能。</target>
        </trans-unit>
        <trans-unit id="3daae79264ded053c68caf5a77aad1db49558306" translate="yes" xml:space="preserve">
          <source>Function to call upon floating-point errors (&amp;lsquo;call&amp;rsquo;-mode) or object whose &amp;lsquo;write&amp;rsquo; method is used to log such message (&amp;lsquo;log&amp;rsquo;-mode).</source>
          <target state="translated">调用浮点错误的函数（&amp;ldquo;调用&amp;rdquo;模式）或使用&amp;ldquo;写&amp;rdquo;方法记录此类消息的对象（&amp;ldquo;日志&amp;rdquo;模式）。</target>
        </trans-unit>
        <trans-unit id="936e3c682ce34cc0f0f7b3b6776919fc933d5fe1" translate="yes" xml:space="preserve">
          <source>Function which returns a masked inner loop for the ufunc</source>
          <target state="translated">函数,返回ufunc的屏蔽内循环。</target>
        </trans-unit>
        <trans-unit id="deb4e042b9d6249db97e6680ab8276b237985bd9" translate="yes" xml:space="preserve">
          <source>Functional programming</source>
          <target state="translated">功能性方案编制</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="5a31942f8f4b1c24c2cf2f6e11f8f96977c918a6" translate="yes" xml:space="preserve">
          <source>Functions For Iteration</source>
          <target state="translated">迭代函数</target>
        </trans-unit>
        <trans-unit id="c9d64db1884b2fd4f353a105874e4c3957322b65" translate="yes" xml:space="preserve">
          <source>Functions and Methods Overview</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6da2fb68f3db64f0a7a53228a8721f52f6134f" translate="yes" xml:space="preserve">
          <source>Functions available from numpy.ma.testutils have changed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7916ccc48b7ce0f25ff69e01c25e39ce11de03b" translate="yes" xml:space="preserve">
          <source>Functions implementing internal features. Not all of these function pointers must be defined for a given type. The required members are &lt;code&gt;nonzero&lt;/code&gt;, &lt;code&gt;copyswap&lt;/code&gt;, &lt;code&gt;copyswapn&lt;/code&gt;, &lt;code&gt;setitem&lt;/code&gt;, &lt;code&gt;getitem&lt;/code&gt;, and &lt;code&gt;cast&lt;/code&gt;. These are assumed to be non- &lt;code&gt;NULL&lt;/code&gt; and &lt;code&gt;NULL&lt;/code&gt; entries will cause a program crash. The other functions may be &lt;code&gt;NULL&lt;/code&gt; which will just mean reduced functionality for that data-type. (Also, the nonzero function will be filled in with a default function if it is &lt;code&gt;NULL&lt;/code&gt; when you register a user-defined data-type).</source>
          <target state="translated">实现内部功能的功能。并非必须为给定类型定义所有这些函数指针。必需的成员为 &lt;code&gt;nonzero&lt;/code&gt; ， &lt;code&gt;copyswap&lt;/code&gt; ， &lt;code&gt;copyswapn&lt;/code&gt; ， &lt;code&gt;setitem&lt;/code&gt; ， &lt;code&gt;getitem&lt;/code&gt; 和 &lt;code&gt;cast&lt;/code&gt; 。假定它们为非 &lt;code&gt;NULL&lt;/code&gt; ,并且 &lt;code&gt;NULL&lt;/code&gt; 条目将导致程序崩溃。其他功能可能为 &lt;code&gt;NULL&lt;/code&gt; ，这仅意味着该数据类型的功能减少。 （此外，当注册用户定义的数据类型时，如果非零函数为 &lt;code&gt;NULL&lt;/code&gt; ，则将使用默认函数填充该函数）。</target>
        </trans-unit>
        <trans-unit id="f48c175b4673c0bc456bc9f1ba654da2d9542a5c" translate="yes" xml:space="preserve">
          <source>Functions in &lt;code&gt;numpy.random&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516c584b732d36ebda7d25fae38b326dc6d202ae" translate="yes" xml:space="preserve">
          <source>Functions in numpy.random</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c724fd9678ed45fd313d6c7db38a089943643ca5" translate="yes" xml:space="preserve">
          <source>Functions may be listed without descriptions, and this is preferable if the functionality is clear from the function name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="786d8b1defa125829799bc249caf1adda1184b6a" translate="yes" xml:space="preserve">
          <source>Functions returning an index along an axis, like &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.argpartition#numpy.argpartition&quot;&gt;&lt;code&gt;argpartition&lt;/code&gt;&lt;/a&gt;, produce suitable indices for this function.</source>
          <target state="translated">沿轴返回索引的函数（例如&lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.argpartition#numpy.argpartition&quot;&gt; &lt;code&gt;argpartition&lt;/code&gt; &lt;/a&gt;）会为此函数生成合适的索引。</target>
        </trans-unit>
        <trans-unit id="7961218e053edec8b5fc62ef3005af10a3415803" translate="yes" xml:space="preserve">
          <source>Functions that are also in the numpy namespace and return matrices</source>
          <target state="translated">同样在numpy命名空间中并返回矩阵的函数。</target>
        </trans-unit>
        <trans-unit id="95335a3a51e2f80868a95521fb5668b275263818" translate="yes" xml:space="preserve">
          <source>Functions that don&amp;rsquo;t accept keyword arguments should be written as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7888c5dcdff069b34a3486459892edd2f262c97" translate="yes" xml:space="preserve">
          <source>Functions with keyword arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6020fb8e5272b3356bebe72ae19a144383754b4e" translate="yes" xml:space="preserve">
          <source>Functions without keyword arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dad1764839322eb03eab6b07936a589482f90c1" translate="yes" xml:space="preserve">
          <source>Fundraising</source>
          <target state="translated">Fundraising</target>
        </trans-unit>
        <trans-unit id="6da76886d65d87e4650f5c14ec791f8c2f676112" translate="yes" xml:space="preserve">
          <source>Further explanation of the &lt;code&gt;fmt&lt;/code&gt; parameter (&lt;code&gt;%[flag]width[.precision]specifier&lt;/code&gt;):</source>
          <target state="translated">关于 &lt;code&gt;fmt&lt;/code&gt; 参数（ &lt;code&gt;%[flag]width[.precision]specifier&lt;/code&gt; ）的进一步说明：</target>
        </trans-unit>
        <trans-unit id="3abcbfb793b7e40f09b0f5479b45936952f0ec59" translate="yes" xml:space="preserve">
          <source>Further improvements to &lt;code&gt;ctypes&lt;/code&gt; support in &lt;code&gt;np.ctypeslib&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7e1185b0b79852815db7f42a86a47fec5e9990" translate="yes" xml:space="preserve">
          <source>Further improvements to &lt;code&gt;ctypes&lt;/code&gt; support in &lt;code&gt;numpy.ctypeslib&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e44c8b638baa470dbb5f127964c092cc77ea465" translate="yes" xml:space="preserve">
          <source>Further reading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad9659f7e2980db9b405ad20b3c5294ccc96416" translate="yes" xml:space="preserve">
          <source>Further, note how &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are combined:</source>
          <target state="translated">此外，请注意 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的组合方式：</target>
        </trans-unit>
        <trans-unit id="9af0aaaf4de03972531671e0eb9bb87000ba4e1d" translate="yes" xml:space="preserve">
          <source>Furthermore, arrays created with this function often contain self overlapping memory, so that two elements are identical. Vectorized write operations on such arrays will typically be unpredictable. They may even give different results for small, large, or transposed arrays. Since writing to these arrays has to be tested and done with great care, you may want to use &lt;code&gt;writeable=False&lt;/code&gt; to avoid accidental write operations.</source>
          <target state="translated">此外，使用此函数创建的数组通常包含自重叠内存，因此两个元素相同。这种阵列上的向量化写操作通常是不可预测的。对于小型，大型或转置阵列，它们甚至可能给出不同的结果。由于必须非常仔细地测试和完成对这些数组的写入操作，因此您可能希望使用 &lt;code&gt;writeable=False&lt;/code&gt; 以避免意外的写入操作。</target>
        </trans-unit>
        <trans-unit id="12143faa25aabfe7fe468016abec86297c6fcf15" translate="yes" xml:space="preserve">
          <source>Furthermore, numpy now provides a new function &lt;a href=&quot;#numpy.lib.recfunctions.structured_to_unstructured&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.structured_to_unstructured&lt;/code&gt;&lt;/a&gt; which is a safer and more efficient alternative for users who wish to convert structured arrays to unstructured arrays, as the view above is often indeded to do. This function allows safe conversion to an unstructured type taking into account padding, often avoids a copy, and also casts the datatypes as needed, unlike the view. Code such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f84a7ca85b2fada9bdf949e608abf006366bb0e" translate="yes" xml:space="preserve">
          <source>Furthermore, the callback function is of the same type as before, &lt;code&gt;void (*foo)(char **args, intp *dimensions, intp *steps, void *func)&lt;/code&gt;. When invoked, &lt;code&gt;args&lt;/code&gt; is a list of length &lt;code&gt;nargs&lt;/code&gt; containing the data of all input/output arguments. For a scalar elementary function, &lt;code&gt;steps&lt;/code&gt; is also of length &lt;code&gt;nargs&lt;/code&gt;, denoting the strides used for the arguments. &lt;code&gt;dimensions&lt;/code&gt; is a pointer to a single integer defining the size of the axis to be looped over.</source>
          <target state="translated">此外，回调函数与以前的类型相同，即 &lt;code&gt;void (*foo)(char **args, intp *dimensions, intp *steps, void *func)&lt;/code&gt; 。调用时， &lt;code&gt;args&lt;/code&gt; 是长度为 &lt;code&gt;nargs&lt;/code&gt; 的列表，其中包含所有输入/输出参数的数据。对于标量基本函数， &lt;code&gt;steps&lt;/code&gt; 的长度也为 &lt;code&gt;nargs&lt;/code&gt; ，表示用于自变量的步幅。 &lt;code&gt;dimensions&lt;/code&gt; 是指向单个整数的指针，该整数定义了要循环的轴的大小。</target>
        </trans-unit>
        <trans-unit id="c462e5cfdac7c4df78636f70346d506c3e424749" translate="yes" xml:space="preserve">
          <source>Furthermore, using the &lt;code&gt;ndim&lt;/code&gt; property of this array, we can see that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22552b8bf29fce0c52d5fcd39548010b9e76338c" translate="yes" xml:space="preserve">
          <source>Future Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb0dc3b9f8b3f5bdca8fc1d87183e1bba912790" translate="yes" xml:space="preserve">
          <source>Future changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7285e0cef5e4daf805eb913ea140d9a03dc8d07" translate="yes" xml:space="preserve">
          <source>Future value</source>
          <target state="translated">未来价值</target>
        </trans-unit>
        <trans-unit id="0d44fa727f9b3f4d912a98a3e170b462f52557e6" translate="yes" xml:space="preserve">
          <source>Future value (default = 0)</source>
          <target state="translated">未来值(默认值=0</target>
        </trans-unit>
        <trans-unit id="ba4092807d491bea64803fff0c7e477eac372847" translate="yes" xml:space="preserve">
          <source>Future values. If all input is scalar, returns a scalar float. If any input is array_like, returns future values for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="translated">未来值。如果所有输入都是标量,返回一个标量浮点数。如果任何输入是array_like,返回每个输入元素的未来值。如果多个输入是array_like,它们必须具有相同的形状。</target>
        </trans-unit>
        <trans-unit id="722af3dc654f5b03462276f1ddc84a2ecf2baa12" translate="yes" xml:space="preserve">
          <source>Future very uncertain: it&amp;rsquo;s the only part of Scipy not ported to Python 3 and is effectively deprecated in favor of Cython.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d739c24bbd3b77640efa7aa653675284eae750ca" translate="yes" xml:space="preserve">
          <source>FutureWarning to changed behavior</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6cee77152a751b028de81f7755bdc87bacc5925" translate="yes" xml:space="preserve">
          <source>FutureWarnings</source>
          <target state="translated">FutureWarnings</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="2f44d78e0bf8d58385fdcde50f5d5e7baff3d944" translate="yes" xml:space="preserve">
          <source>G. H. Golub and C. F. Van Loan, &lt;em&gt;Matrix Computations&lt;/em&gt;, Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</source>
          <target state="translated">GH Golub和CF Van Loan，《&lt;em&gt;矩阵计算》&lt;/em&gt;，马里兰州巴尔的摩，约翰&amp;middot;霍普金斯大学出版社，1985年，第13页。15</target>
        </trans-unit>
        <trans-unit id="cbd53064adb7ff38d27c336291f9eaba7270aacd" translate="yes" xml:space="preserve">
          <source>G. Strang, &amp;ldquo;Linear Algebra and Its Applications, 2nd Edition,&amp;rdquo; Academic Press, pg. 182, 1980.</source>
          <target state="translated">G. Strang，&amp;ldquo;线性代数及其应用，第二版&amp;rdquo;，学术出版社，第3页。182，1980。</target>
        </trans-unit>
        <trans-unit id="0fee945837fcad5efdf449e24366c4e1f7b65d37" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, Various pp.</source>
          <target state="translated">G.Strang，《&lt;em&gt;线性代数及其应用》&lt;/em&gt;，第二版，佛罗里达州奥兰多，Academic Press，Inc.，1980年，第pp。</target>
        </trans-unit>
        <trans-unit id="4d62050a6efa830b0646c86cf65d2a276c097206" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 22.</source>
          <target state="translated">G.Strang，&amp;ldquo; &lt;em&gt;线性代数及其应用&amp;rdquo;&lt;/em&gt;，第二版，佛罗里达州奥兰多，Academic Press，Inc.，1980年，第5页。22</target>
        </trans-unit>
        <trans-unit id="8a5685424a4a906ee371dfacdea6a5b47dc7b3ff" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 222.</source>
          <target state="translated">G.Strang，&amp;ldquo; &lt;em&gt;线性代数及其应用&amp;rdquo;&lt;/em&gt;，第二版，佛罗里达州奥兰多，Academic Press，Inc.，1980年，第5页。222。</target>
        </trans-unit>
        <trans-unit id="db937a0ed23b9cf712fadda8ce2d53e90fb3fb34" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pp. 139-142.</source>
          <target state="translated">G.Strang，《&lt;em&gt;线性代数及其应用》&lt;/em&gt;，第二版，佛罗里达州奥兰多，Academic Press，Inc.，1980，第139-142页。</target>
        </trans-unit>
        <trans-unit id="d923f5047de7db54bb0494345e02c3e60011f631" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, Orlando, FL, Academic Press, Inc., 1980, pg. 285.</source>
          <target state="translated">G. Strang，《&lt;em&gt;线性代数及其应用》&lt;/em&gt;，佛罗里达州奥兰多市，Academic Press，Inc.，1980年，第1页。285。</target>
        </trans-unit>
        <trans-unit id="2fe46435d8800606efbbb4738ea49577e004f01c" translate="yes" xml:space="preserve">
          <source>GUfuncs on empty arrays and NpyIter axis removal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a5e73fba8665db50a8e3577ecf8eb28b80e421" translate="yes" xml:space="preserve">
          <source>Gammas</source>
          <target state="translated">Gammas</target>
        </trans-unit>
        <trans-unit id="027498996e260dbd9c33778f3168019dfde3d4cc" translate="yes" xml:space="preserve">
          <source>Gauss-Chebyshev quadrature.</source>
          <target state="translated">高斯-切比雪夫方块。</target>
        </trans-unit>
        <trans-unit id="372d4c8be97b59c2965354454eaf80e844e74e50" translate="yes" xml:space="preserve">
          <source>Gauss-Hermite quadrature.</source>
          <target state="translated">高斯-赫米特方块。</target>
        </trans-unit>
        <trans-unit id="90aa100cf157ec594ce20f650ca9a1d9019f03be" translate="yes" xml:space="preserve">
          <source>Gauss-HermiteE quadrature.</source>
          <target state="translated">高斯-赫米特E方块。</target>
        </trans-unit>
        <trans-unit id="9d10f081127b50e1f17e0a5c3971976017840cbe" translate="yes" xml:space="preserve">
          <source>Gauss-Laguerre quadrature.</source>
          <target state="translated">高斯-拉盖尔正交。</target>
        </trans-unit>
        <trans-unit id="88f1f37c698b12eaffdc9bbccbc77d8b6246ccd8" translate="yes" xml:space="preserve">
          <source>Gauss-Legendre quadrature.</source>
          <target state="translated">高斯-列根德雷正交。</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="0cffb2d4275e42dba57746961ea67052aaeef334" translate="yes" xml:space="preserve">
          <source>General Broadcasting Rules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ff3c8e4686a4c021328dd784ede1cb72d7755f" translate="yes" xml:space="preserve">
          <source>General Purpose Equivalents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d731fc16d10c539de3eb06ab7ca854e8f4dd60e" translate="yes" xml:space="preserve">
          <source>General check of Python Type</source>
          <target state="translated">Python类型的一般检查</target>
        </trans-unit>
        <trans-unit id="1b31f308f2ce85a33700b95c3da21fcb018ed716" translate="yes" xml:space="preserve">
          <source>General purpose exception class, derived from Python&amp;rsquo;s exception.Exception class, programmatically raised in linalg functions when a Linear Algebra-related condition would prevent further correct execution of the function.</source>
          <target state="translated">从Python的exception.Exception类派生的通用异常类，在与线性代数相关的条件会阻止函数进一步正确执行时，在linalg函数中以编程方式引发。</target>
        </trans-unit>
        <trans-unit id="6a5d5977ff7dabeb26104f13133251775857ac24" translate="yes" xml:space="preserve">
          <source>Generalised matrix product, using second last dimension of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">广义矩阵乘积，使用 &lt;code&gt;b&lt;/code&gt; 的倒数第二个维。</target>
        </trans-unit>
        <trans-unit id="172636dd07a5cf344fc718f14e5f8bac9163a8d1" translate="yes" xml:space="preserve">
          <source>Generalized &lt;code&gt;flip&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d7eab60b5c5966c3521dbaae99dc8efbf97f6cb" translate="yes" xml:space="preserve">
          <source>Generalized Ufuncs will now unlock the GIL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9332c2d546d63dda92dba61cafe3df82f0dd8b19" translate="yes" xml:space="preserve">
          <source>Generalized Universal Function API</source>
          <target state="translated">通用函数API</target>
        </trans-unit>
        <trans-unit id="e299d19ac7292c1bf7156bae2d6dd21bd9fba291" translate="yes" xml:space="preserve">
          <source>Generalized axis support for median and percentile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b50941190dd87fa655dc29ac5df20dd7d7c66f" translate="yes" xml:space="preserve">
          <source>Generalized function class.</source>
          <target state="translated">通用函数类。</target>
        </trans-unit>
        <trans-unit id="1a1bc0e8d9d246a721e301167a79c68d6cdef5b2" translate="yes" xml:space="preserve">
          <source>Generalized ufunc signatures now allow fixed-size dimensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d28b03b171fb860aee83a82f532e58c4e9fba3" translate="yes" xml:space="preserve">
          <source>Generalized ufunc signatures now allow flexible dimensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0046ab62e86cdc207bdc51ed66f39ae439778565" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a042cdeb42f3ae672017ab4c672646772ccf00" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs are used internally in many linalg functions, and in the testing suite; the examples below are taken from these. For ufuncs that operate on scalars, the signature is &lt;code&gt;None&lt;/code&gt;, which is equivalent to &amp;lsquo;()&amp;rsquo; for every argument.</source>
          <target state="translated">通用ufunc在内部的许多Linalg函数和测试套件中使用。以下示例摘自这些。对于按标量操作的ufunc，其签名为 &lt;code&gt;None&lt;/code&gt; ，每个参数等效于'（）'。</target>
        </trans-unit>
        <trans-unit id="b0078c3e5a20e2fad81f2acb827abe758030ac9d" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs are used internally in many linalg functions, and in the testing suite; the examples below are taken from these. For ufuncs that operate on scalars, the signature is None, which is equivalent to &amp;lsquo;()&amp;rsquo; for every argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9c0fe98002f4322da923b10684f6d5d099ff33" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs now accept &lt;code&gt;axes&lt;/code&gt;, &lt;code&gt;axis&lt;/code&gt; and &lt;code&gt;keepdims&lt;/code&gt; arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96ae300222cf76379f354819a4df06d3fbfa490" translate="yes" xml:space="preserve">
          <source>Generalized universal function signature, e.g., &lt;code&gt;(m,n),(n)-&amp;gt;(m)&lt;/code&gt; for vectorized matrix-vector multiplication. If provided, &lt;code&gt;pyfunc&lt;/code&gt; will be called with (and expected to return) arrays with shapes given by the size of corresponding core dimensions. By default, &lt;code&gt;pyfunc&lt;/code&gt; is assumed to take scalars as input and output.</source>
          <target state="translated">通用通用函数签名，例如 &lt;code&gt;(m,n),(n)-&amp;gt;(m)&lt;/code&gt; ,用于向量化矩阵-矢量乘法。如果提供 &lt;code&gt;pyfunc&lt;/code&gt; ,将使用具有（由预期的返回）形状由相应核心尺寸的大小给定的数组调用。默认情况下，假定 &lt;code&gt;pyfunc&lt;/code&gt; 将标量用作输入和输出。</target>
        </trans-unit>
        <trans-unit id="4bdfd56723e2a4630d0aa40f0eab7e7e821379e3" translate="yes" xml:space="preserve">
          <source>Generally speaking, what is returned when index arrays are used is an array with the same shape as the index array, but with the type and values of the array being indexed. As an example, we can use a multidimensional index array instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2257faa28ea2af0838b36329ac81b4299b5a11a1" translate="yes" xml:space="preserve">
          <source>Generally, the file needs to be generated during the build, since it needs some information known at build time only (e.g. prefix). This is mostly automatic if one uses the &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; method &lt;code&gt;add_npy_pkg_config&lt;/code&gt;. Assuming we have a template file foo.ini.in as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b3bfe4a96aaf1f0210aadbf43dc393e3a362c6" translate="yes" xml:space="preserve">
          <source>Generally, the file needs to be generated during the build, since it needs some information known at build time only (e.g. prefix). This is mostly automatic if one uses the &lt;code&gt;Configuration&lt;/code&gt; method &lt;code&gt;add_npy_pkg_config&lt;/code&gt;. Assuming we have a template file foo.ini.in as follows:</source>
          <target state="translated">通常，文件需要在构建期间生成，因为它只需要一些在构建时就已知的信息（例如前缀）。如果使用 &lt;code&gt;Configuration&lt;/code&gt; 方法 &lt;code&gt;add_npy_pkg_config&lt;/code&gt; ,这通常是自动的。假设我们有一个模板文件foo.ini.in，如下所示：</target>
        </trans-unit>
        <trans-unit id="ba56532a4a3fb8146e876e1d3659dfdac724a189" translate="yes" xml:space="preserve">
          <source>Generate a 1 by 3 array with 3 different lower bounds</source>
          <target state="translated">生成一个具有3个不同下限的1乘3数组。</target>
        </trans-unit>
        <trans-unit id="3724c74e69c85b7924eab36b9e17078ea85e817c" translate="yes" xml:space="preserve">
          <source>Generate a 1 x 3 array with 3 different upper bounds</source>
          <target state="translated">生成一个具有3个不同上界的1×3数组。</target>
        </trans-unit>
        <trans-unit id="c78b4920f6305013e33283131f3991e4d5dda157" translate="yes" xml:space="preserve">
          <source>Generate a 2 by 4 array using broadcasting with dtype of uint8</source>
          <target state="translated">用dtype为uint8的广播生成一个2乘4的数组。</target>
        </trans-unit>
        <trans-unit id="52ec8bca285ae5da030ea4680d276692f61c3804" translate="yes" xml:space="preserve">
          <source>Generate a 2 x 4 array of ints between 0 and 4, inclusive:</source>
          <target state="translated">生成一个介于0和4之间的2×4的ints数组。</target>
        </trans-unit>
        <trans-unit id="9e541c44f7aa5d7ed7acb09f3c0fe019e268af5e" translate="yes" xml:space="preserve">
          <source>Generate a Chebyshev series with given roots.</source>
          <target state="translated">用给定的根生成一个切比雪夫数列。</target>
        </trans-unit>
        <trans-unit id="0c791c1439e16e2fd0efb50c6644249b5b3eebb5" translate="yes" xml:space="preserve">
          <source>Generate a Hermite series with given roots.</source>
          <target state="translated">用给定的根生成一个赫米特数列。</target>
        </trans-unit>
        <trans-unit id="8bd121a27d585c3734742539ee143a52ac9b73de" translate="yes" xml:space="preserve">
          <source>Generate a HermiteE series with given roots.</source>
          <target state="translated">用给定的根生成一个HermiteE系列。</target>
        </trans-unit>
        <trans-unit id="a9d697582320e7c884bbfd6a03995e4b278f2c74" translate="yes" xml:space="preserve">
          <source>Generate a Laguerre series with given roots.</source>
          <target state="translated">用给定的根生成一个Laguerre数列。</target>
        </trans-unit>
        <trans-unit id="9fd152ea5ebdb08e6cd481a5737f68bdf9d18ad6" translate="yes" xml:space="preserve">
          <source>Generate a Legendre series with given roots.</source>
          <target state="translated">用给定的根生成一个Legendre系列。</target>
        </trans-unit>
        <trans-unit id="67cead80b0965ee4736c5f23fba251df4f3ebe37" translate="yes" xml:space="preserve">
          <source>Generate a Vandermonde matrix.</source>
          <target state="translated">在Vandermonde矩阵生成。</target>
        </trans-unit>
        <trans-unit id="f4b901c2336926f254f07d1ab7b60e0386e5b58c" translate="yes" xml:space="preserve">
          <source>Generate a monic polynomial with given roots.</source>
          <target state="translated">用给定的根生成一个一元多项式。</target>
        </trans-unit>
        <trans-unit id="2e173a5f3c2204af8ef7b9a77d34afee8c360a27" translate="yes" xml:space="preserve">
          <source>Generate a non-uniform random sample from np.arange(5) of size 3 without replacement:</source>
          <target state="translated">从np.arrange(5)中生成一个大小为3的非均匀随机样本,不需要替换。</target>
        </trans-unit>
        <trans-unit id="3b032abdb8bc3ee596986f951aad13aeb29eff03" translate="yes" xml:space="preserve">
          <source>Generate a non-uniform random sample from np.arange(5) of size 3:</source>
          <target state="translated">从np.arrange(5)中生成一个大小为3的非均匀随机样本。</target>
        </trans-unit>
        <trans-unit id="15beef8541c11b005861875826a071b16faf6c61" translate="yes" xml:space="preserve">
          <source>Generate a single integer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ecb4243c3f96a98ea55b6a9b74781792dce996" translate="yes" xml:space="preserve">
          <source>Generate a uniform random sample from np.arange(5) of size 3 without replacement:</source>
          <target state="translated">从np.arrange(5)中生成一个大小为3的均匀随机样本,不需要替换。</target>
        </trans-unit>
        <trans-unit id="7e7e8cdcfbc5d1d81d3a8108edeaf14a80335951" translate="yes" xml:space="preserve">
          <source>Generate a uniform random sample from np.arange(5) of size 3:</source>
          <target state="translated">从np.arrange(5)中生成一个大小为3的均匀随机样本。</target>
        </trans-unit>
        <trans-unit id="382b425e693319395299c741c143ce2398939efe" translate="yes" xml:space="preserve">
          <source>Generate and install a npy-pkg config file from a template.</source>
          <target state="translated">从模板中生成并安装一个 npy-pkg 配置文件。</target>
        </trans-unit>
        <trans-unit id="19a90f1dba170779ac0befe5afd3d6d9c884c6d1" translate="yes" xml:space="preserve">
          <source>Generate config.py file containing system_info information used during building the package.</source>
          <target state="translated">生成config.py文件,其中包含了构建包时使用的system_info信息。</target>
        </trans-unit>
        <trans-unit id="34c49c62f8886e09ca6e64b9c96074bf60926d62" translate="yes" xml:space="preserve">
          <source>Generate package __config__.py file containing system_info information used during building the package.</source>
          <target state="translated">生成软件包 __config__.py 文件,其中包含构建软件包时使用的系统信息。</target>
        </trans-unit>
        <trans-unit id="14952923eed9a754d36fbf7d9df88e59880c6dad" translate="yes" xml:space="preserve">
          <source>Generate package __svn_version__.py file from SVN revision number, it will be removed after python exits but will be available when sdist, etc commands are executed.</source>
          <target state="translated">根据SVN版本号生成包__svn_version__.py文件,它将在python退出后被删除,但在执行sdist等命令时可以使用。</target>
        </trans-unit>
        <trans-unit id="60ff5f05cec532a7f8f7d819baeeb92b41c5296d" translate="yes" xml:space="preserve">
          <source>Generate random uint64 numbers in closed interval [off, off + rng].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8045f4bbe378a7866506cc0ecb5d877bf5eaf96" translate="yes" xml:space="preserve">
          <source>Generate the README files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7412730131bc368e3c0dcb289c20fbf2554245c4" translate="yes" xml:space="preserve">
          <source>Generate variates from a multivariate hypergeometric distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd9212c9f1d53d55d853a3b264e1b6b858f35fd" translate="yes" xml:space="preserve">
          <source>Generates a random sample from a given 1-D array</source>
          <target state="translated">从给定的一维数组中产生一个随机样本。</target>
        </trans-unit>
        <trans-unit id="d332ac6845c5273c1195174ec786fa2289b9b752" translate="yes" xml:space="preserve">
          <source>Generating author/pr lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="150ce9aa76a74d0a43ead917a8c785193ed877b1" translate="yes" xml:space="preserve">
          <source>Generating index arrays</source>
          <target state="translated">生成索引数组</target>
        </trans-unit>
        <trans-unit id="4bc72cf76a431fc1b67a969426c355ba5d2b3044" translate="yes" xml:space="preserve">
          <source>Generating random numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0d1bad0186174ecfcdc9782f2116277b7b05e0" translate="yes" xml:space="preserve">
          <source>Generator (class in numpy.random)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb174c2f425e0d1a36b6da19833f5708052f5b2" translate="yes" xml:space="preserve">
          <source>Generator.beta()</source>
          <target state="translated">Generator.beta()</target>
        </trans-unit>
        <trans-unit id="5c54211367d38fc1c657f1a2b11682aa7073f8a0" translate="yes" xml:space="preserve">
          <source>Generator.binomial()</source>
          <target state="translated">Generator.binomial()</target>
        </trans-unit>
        <trans-unit id="d222082a3e85bc085f3813830709c1091b870201" translate="yes" xml:space="preserve">
          <source>Generator.bit_generator</source>
          <target state="translated">Generator.bit_generator</target>
        </trans-unit>
        <trans-unit id="ccf1aa45703830ef34744bdb91c5ee84eb339af2" translate="yes" xml:space="preserve">
          <source>Generator.bytes()</source>
          <target state="translated">Generator.bytes()</target>
        </trans-unit>
        <trans-unit id="a1e223f39e59656efb6dcd2b450fd1f3d11e0f5b" translate="yes" xml:space="preserve">
          <source>Generator.chisquare()</source>
          <target state="translated">Generator.chisquare()</target>
        </trans-unit>
        <trans-unit id="a2cf011c29fcb364a340b0b0739ed3940f0415ce" translate="yes" xml:space="preserve">
          <source>Generator.choice()</source>
          <target state="translated">Generator.choice()</target>
        </trans-unit>
        <trans-unit id="acb19d66e8b5e00bd8ab9eaa938d00f3718515fe" translate="yes" xml:space="preserve">
          <source>Generator.dirichlet()</source>
          <target state="translated">Generator.dirichlet()</target>
        </trans-unit>
        <trans-unit id="81c841ae15f138b1059c14b8ebc34f2ceb6506da" translate="yes" xml:space="preserve">
          <source>Generator.exponential()</source>
          <target state="translated">Generator.exponential()</target>
        </trans-unit>
        <trans-unit id="ceb6ee1b51ecd1875248d0ca388e0fb1daabb181" translate="yes" xml:space="preserve">
          <source>Generator.f()</source>
          <target state="translated">Generator.f()</target>
        </trans-unit>
        <trans-unit id="9a5544f1f1d846a0215be8277752788b52f5d5ae" translate="yes" xml:space="preserve">
          <source>Generator.gamma()</source>
          <target state="translated">Generator.gamma()</target>
        </trans-unit>
        <trans-unit id="cb698152656074b26c2b514594b6841ba98646e0" translate="yes" xml:space="preserve">
          <source>Generator.geometric()</source>
          <target state="translated">Generator.geometric()</target>
        </trans-unit>
        <trans-unit id="fbe271ee0cdf14a0b127e97b8a754332b21122bf" translate="yes" xml:space="preserve">
          <source>Generator.gumbel()</source>
          <target state="translated">Generator.gumbel()</target>
        </trans-unit>
        <trans-unit id="1bb4c4773f6c2e362f6bdc12b4738edbd30f23d2" translate="yes" xml:space="preserve">
          <source>Generator.hypergeometric()</source>
          <target state="translated">Generator.hypergeometric()</target>
        </trans-unit>
        <trans-unit id="c50dbdf77399f33f0754452bd827d7d9972e1f6e" translate="yes" xml:space="preserve">
          <source>Generator.integers()</source>
          <target state="translated">Generator.integers()</target>
        </trans-unit>
        <trans-unit id="2ac6ee43d1992ed473a404e92103ad981ee56dd8" translate="yes" xml:space="preserve">
          <source>Generator.laplace()</source>
          <target state="translated">Generator.laplace()</target>
        </trans-unit>
        <trans-unit id="9a01e0244542efabb99865e59014bd47d50fe182" translate="yes" xml:space="preserve">
          <source>Generator.logistic()</source>
          <target state="translated">Generator.logistic()</target>
        </trans-unit>
        <trans-unit id="c320801600fb9c31cc3d790a76584f303a266f0d" translate="yes" xml:space="preserve">
          <source>Generator.lognormal()</source>
          <target state="translated">Generator.lognormal()</target>
        </trans-unit>
        <trans-unit id="2133a52d0f531222ffd5b10595265bd407d65eae" translate="yes" xml:space="preserve">
          <source>Generator.logseries()</source>
          <target state="translated">Generator.logseries()</target>
        </trans-unit>
        <trans-unit id="3fb5b968b7c3c6e4334e366ce81b7d1c72dd0587" translate="yes" xml:space="preserve">
          <source>Generator.multinomial()</source>
          <target state="translated">Generator.multinomial()</target>
        </trans-unit>
        <trans-unit id="ee77530caf29c96157f8b247c28bc2729509bc1f" translate="yes" xml:space="preserve">
          <source>Generator.multivariate_normal()</source>
          <target state="translated">Generator.multivariate_normal()</target>
        </trans-unit>
        <trans-unit id="e4accfbbf5411ba4e6ed6190c6c4a4f347889476" translate="yes" xml:space="preserve">
          <source>Generator.negative_binomial()</source>
          <target state="translated">Generator.negative_binomial()</target>
        </trans-unit>
        <trans-unit id="f5c86d9e1ec54b1f6ceef69c6b35acbc51980bb9" translate="yes" xml:space="preserve">
          <source>Generator.noncentral_chisquare()</source>
          <target state="translated">Generator.noncentral_chisquare()</target>
        </trans-unit>
        <trans-unit id="4ffb9eb22957bfe4ccb8d5eb67072da9ed2c8fe8" translate="yes" xml:space="preserve">
          <source>Generator.noncentral_f()</source>
          <target state="translated">Generator.noncentral_f()</target>
        </trans-unit>
        <trans-unit id="155766b36ed963438beae39d25dc848285e67bec" translate="yes" xml:space="preserve">
          <source>Generator.normal()</source>
          <target state="translated">Generator.normal()</target>
        </trans-unit>
        <trans-unit id="b6ff7a92707e2ef9f9f69eb28c0f2a89afd2fb30" translate="yes" xml:space="preserve">
          <source>Generator.pareto()</source>
          <target state="translated">Generator.pareto()</target>
        </trans-unit>
        <trans-unit id="76efb5ddfe9997620fd07ade2a0e0cee44bb8c62" translate="yes" xml:space="preserve">
          <source>Generator.permutation()</source>
          <target state="translated">Generator.permutation()</target>
        </trans-unit>
        <trans-unit id="7a00012743deaf56311a785e2b3c42ad040930cb" translate="yes" xml:space="preserve">
          <source>Generator.poisson()</source>
          <target state="translated">Generator.poisson()</target>
        </trans-unit>
        <trans-unit id="9ebe8ebc29357762dc172bd7a50a6d2bbec0bbc0" translate="yes" xml:space="preserve">
          <source>Generator.power()</source>
          <target state="translated">Generator.power()</target>
        </trans-unit>
        <trans-unit id="760d539be436a9fd5786ef5406b94bdadd320519" translate="yes" xml:space="preserve">
          <source>Generator.random()</source>
          <target state="translated">Generator.random()</target>
        </trans-unit>
        <trans-unit id="4fe55f2eb5b58a57536abac4e6392ebd311bfe6e" translate="yes" xml:space="preserve">
          <source>Generator.rayleigh()</source>
          <target state="translated">Generator.rayleigh()</target>
        </trans-unit>
        <trans-unit id="3fff1d63fa4122d609dcfb229ec0499ef08a14a7" translate="yes" xml:space="preserve">
          <source>Generator.shuffle()</source>
          <target state="translated">Generator.shuffle()</target>
        </trans-unit>
        <trans-unit id="9b1634a618bfbc7c72035711945372ce07c3fe19" translate="yes" xml:space="preserve">
          <source>Generator.standard_cauchy()</source>
          <target state="translated">Generator.standard_cauchy()</target>
        </trans-unit>
        <trans-unit id="34db4ce80b61d7d21ff61b89aa2d2d63aa910f5c" translate="yes" xml:space="preserve">
          <source>Generator.standard_exponential()</source>
          <target state="translated">Generator.standard_exponential()</target>
        </trans-unit>
        <trans-unit id="34031ad3432250f012a4d89407bba35b84a16c3c" translate="yes" xml:space="preserve">
          <source>Generator.standard_gamma()</source>
          <target state="translated">Generator.standard_gamma()</target>
        </trans-unit>
        <trans-unit id="87dab3cf1af1d204bcf4e1ac664f4ea0ea2557c9" translate="yes" xml:space="preserve">
          <source>Generator.standard_normal()</source>
          <target state="translated">Generator.standard_normal()</target>
        </trans-unit>
        <trans-unit id="f906f6a0afddbf8cdbe07f5b8f0720c2656e3a0d" translate="yes" xml:space="preserve">
          <source>Generator.standard_t()</source>
          <target state="translated">Generator.standard_t()</target>
        </trans-unit>
        <trans-unit id="b0b2b3ce2c0360b1a89e482830d2d3c0cbab9581" translate="yes" xml:space="preserve">
          <source>Generator.triangular()</source>
          <target state="translated">Generator.triangular()</target>
        </trans-unit>
        <trans-unit id="ab3025f762e986dfbed9abf7722d638afcbcac65" translate="yes" xml:space="preserve">
          <source>Generator.uniform()</source>
          <target state="translated">Generator.uniform()</target>
        </trans-unit>
        <trans-unit id="41234839ae9e6c31f86b35be70f95dd2edfdb45f" translate="yes" xml:space="preserve">
          <source>Generator.vonmises()</source>
          <target state="translated">Generator.vonmises()</target>
        </trans-unit>
        <trans-unit id="524f7ff03bcd2538def6c2fcd08d18e053cd0a0d" translate="yes" xml:space="preserve">
          <source>Generator.wald()</source>
          <target state="translated">Generator.wald()</target>
        </trans-unit>
        <trans-unit id="e7d43ca17b95d21950576674e14eac05300d6600" translate="yes" xml:space="preserve">
          <source>Generator.weibull()</source>
          <target state="translated">Generator.weibull()</target>
        </trans-unit>
        <trans-unit id="425fdb323ea262485eeead85528e77951596ac23" translate="yes" xml:space="preserve">
          <source>Generator.zipf()</source>
          <target state="translated">Generator.zipf()</target>
        </trans-unit>
        <trans-unit id="b9790b2a609e0a0a9945eb7f9ff37cc7c5acb58d" translate="yes" xml:space="preserve">
          <source>Generators should be documented just as functions are documented. The only difference is that one should use the &lt;strong&gt;Yields&lt;/strong&gt; section instead of the &lt;strong&gt;Returns&lt;/strong&gt; section. Support for the &lt;strong&gt;Yields&lt;/strong&gt; section was added in &lt;a href=&quot;https://github.com/numpy/numpydoc&quot;&gt;numpydoc&lt;/a&gt; version 0.6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5e162e441d1aa68e920c4da50498c7a00cc1ca" translate="yes" xml:space="preserve">
          <source>Generators: Objects that transform sequences of random bits from a BitGenerator into sequences of numbers that follow a specific probability distribution (such as uniform, Normal or Binomial) within a specified interval.</source>
          <target state="translated">生成器。将来自比特生成器的随机比特序列转化为在特定区间内遵循特定概率分布(如均匀、正态或二项式)的数字序列的对象。</target>
        </trans-unit>
        <trans-unit id="fcca6d928c0647f440353ba62ca89c9a77b6389a" translate="yes" xml:space="preserve">
          <source>Generic Python-exception-derived object raised by linalg functions.</source>
          <target state="translated">由linalg函数引发的通用Python-exception派生对象。</target>
        </trans-unit>
        <trans-unit id="37f5365cdbef14515226dcd384583192170cc525" translate="yes" xml:space="preserve">
          <source>Generic functions</source>
          <target state="translated">通用功能</target>
        </trans-unit>
        <trans-unit id="36687e3d4c6e89be61413141c9001bd1269ea61f" translate="yes" xml:space="preserve">
          <source>Generic types</source>
          <target state="translated">通用类型</target>
        </trans-unit>
        <trans-unit id="4725fc543850e19ff2039cda197dd7e9e18cc3b7" translate="yes" xml:space="preserve">
          <source>Get a Python object of a builtin type from the ndarray, &lt;em&gt;arr&lt;/em&gt;, at the location pointed to by itemptr. Return &lt;code&gt;NULL&lt;/code&gt; on failure.</source>
          <target state="translated">从ndarray &lt;em&gt;arr中&lt;/em&gt;获取一个内置类型的Python对象，该对象由itemptr指向。失败时返回 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89bba80c206cb8084a11e65d5dc5c897b6a8a686" translate="yes" xml:space="preserve">
          <source>Get a copy of the iterator as a 1-D array.</source>
          <target state="translated">获取一个一维数组的迭代器副本。</target>
        </trans-unit>
        <trans-unit id="f7e3ab2dfabd54e64b9ac5580bc305e9c24165dc" translate="yes" xml:space="preserve">
          <source>Get a copy of the iterator in its current state.</source>
          <target state="translated">获取迭代器当前状态的副本。</target>
        </trans-unit>
        <trans-unit id="87b8e4a6c47eabed3fcd4c264f91d248484dbd8e" translate="yes" xml:space="preserve">
          <source>Get floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reodering this function call relative to the code setting the status, which could lead to incorrect results.</source>
          <target state="translated">获取浮点状态。传递一个指向本地变量的指针,以防止编译器的激进优化,防止该函数调用相对于设置状态的代码重新编码,从而导致错误的结果。</target>
        </trans-unit>
        <trans-unit id="c919c3aaf29bde2f7fadef95afc3436e547fc4bb" translate="yes" xml:space="preserve">
          <source>Get floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reordering this function call relative to the code setting the status, which could lead to incorrect results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27b9509ff4121a0e1b9f0986d9920de57d819f0" translate="yes" xml:space="preserve">
          <source>Get floating point status. Returns a bitmask with following possible flags:</source>
          <target state="translated">获取浮点状态。返回一个带有以下标志的位掩码。</target>
        </trans-unit>
        <trans-unit id="ddfceaf39034459b039832aa5e0f88a5294c648e" translate="yes" xml:space="preserve">
          <source>Get help information for a function, class, or module.</source>
          <target state="translated">获取函数、类或模块的帮助信息。</target>
        </trans-unit>
        <trans-unit id="ec25cf47cdd55b9b521bbdadbef69d3ea1d8e5a4" translate="yes" xml:space="preserve">
          <source>Get information about the step size of a date or time type.</source>
          <target state="translated">获取日期或时间类型的步长信息。</target>
        </trans-unit>
        <trans-unit id="d0d9c57e1b16aa99fa5d9ab014f87b4ec73ded17" translate="yes" xml:space="preserve">
          <source>Get number of parallel build jobs set by the &amp;ndash;parallel command line argument of setup.py If the command did not receive a setting the environment variable NPY_NUM_BUILD_JOBS is checked. If that is unset, return the number of processors on the system, with a maximum of 8 (to prevent overloading the system if there a lot of CPUs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693a41351204b667429ed1f8f87172706e8b4a91" translate="yes" xml:space="preserve">
          <source>Get or set the PRNG state</source>
          <target state="translated">获取或设置PRNG状态</target>
        </trans-unit>
        <trans-unit id="09c0240016b842d9be6c9625e5a572e040565a6a" translate="yes" xml:space="preserve">
          <source>Get or set the mask of the array if it has no named fields.</source>
          <target state="translated">如果数组没有命名字段,则获取或设置数组的掩码。</target>
        </trans-unit>
        <trans-unit id="0a74bcddcc3142595e265c6f91c54ba0941f6e3f" translate="yes" xml:space="preserve">
          <source>Get or set the mask of the array if it has no named fields. For structured arrays, returns a ndarray of booleans where entries are &lt;code&gt;True&lt;/code&gt; if &lt;strong&gt;all&lt;/strong&gt; the fields are masked, &lt;code&gt;False&lt;/code&gt; otherwise:</source>
          <target state="translated">如果没有命名字段，则获取或设置数组的掩码。对于结构化数组，返回布尔值的ndarray，如果&lt;strong&gt;所有&lt;/strong&gt;字段都被屏蔽，则条目为 &lt;code&gt;True&lt;/code&gt; ，否则为 &lt;code&gt;False&lt;/code&gt; ：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0ab6b2bea51cfebc1977ab8830dcd90e5d8f56d" translate="yes" xml:space="preserve">
          <source>Get resources information.</source>
          <target state="translated">获取资源信息。</target>
        </trans-unit>
        <trans-unit id="7d41ad59188f890aeb1ed8209e30d553a33f1536" translate="yes" xml:space="preserve">
          <source>Get the Python values used for ufunc processing from the thread-local storage area unless the defaults have been set in which case the name lookup is bypassed. The name is placed as a string in the first element of &lt;em&gt;*errobj&lt;/em&gt;. The second element is the looked-up function to call on error callback. The value of the looked-up buffer-size to use is passed into &lt;em&gt;bufsize&lt;/em&gt;, and the value of the error mask is placed into &lt;em&gt;errmask&lt;/em&gt;.</source>
          <target state="translated">从线程本地存储区获取用于ufunc处理的Python值，除非已设置默认值，在这种情况下将绕过名称查找。该名称作为字符串放置在&lt;em&gt;* errobj&lt;/em&gt;的第一个元素中。第二个元素是在错误回调上调用的查找函数。要使用的查找缓冲区大小的值传递到&lt;em&gt;bufsize中&lt;/em&gt;，错误掩码的值放入&lt;em&gt;errmask中&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b42cef4d77cbf66bab7c534b082e6107163dee92" translate="yes" xml:space="preserve">
          <source>Get the current way of handling floating-point errors.</source>
          <target state="translated">获取当前浮点错误的处理方式。</target>
        </trans-unit>
        <trans-unit id="1ad2852f86c694e329d03e73d07b76a105a8cebc" translate="yes" xml:space="preserve">
          <source>Get the local copy of the code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="695f3e243afdf261b45538304791ad040f8d34f0" translate="yes" xml:space="preserve">
          <source>Get the number of dimensions of an array</source>
          <target state="translated">获取一个数组的维数。</target>
        </trans-unit>
        <trans-unit id="38abfcd88f93b84356fd5ce9430a9a3bce6aa97e" translate="yes" xml:space="preserve">
          <source>Get the shape of the array and a pointer to its actual data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b4332f0fd288d9a8660cb9b90eb2d70399cb30" translate="yes" xml:space="preserve">
          <source>Getitem/setitem/copyswap function: Similar to ufuncs, these functions generally have two code paths. If &lt;code&gt;ALIGNED&lt;/code&gt; is False they will use a code path that buffers the arguments so they are true-aligned.</source>
          <target state="translated">Getitem / setitem / copyswap函数：与ufuncs相似，这些函数通常具有两个代码路径。如果 &lt;code&gt;ALIGNED&lt;/code&gt; 为False，则它们将使用一个缓冲参数的代码路径，使它们为真对齐。</target>
        </trans-unit>
        <trans-unit id="be9042cc4b8d1c2a38a88090c5bbf827e249e726" translate="yes" xml:space="preserve">
          <source>Gets an array of strides which are fixed, or will not change during the entire iteration. For strides that may change, the value NPY_MAX_INTP is placed in the stride.</source>
          <target state="translated">获取一个固定的或在整个迭代过程中不会改变的步长数组,对于可能会改变的步长,NPY_MAX_INTP会放在步长中。对于可能改变的步长,NPY_MAX_INTP会被放置在步长中。</target>
        </trans-unit>
        <trans-unit id="30fc1fed71b9648bc39ebe85c632c9c96d68765c" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;iterindex&lt;/code&gt; of the iterator, which is an index matching the iteration order of the iterator.</source>
          <target state="translated">获取迭代器的 &lt;code&gt;iterindex&lt;/code&gt; ，它是与迭代器的迭代顺序匹配的索引。</target>
        </trans-unit>
        <trans-unit id="c9217aeddd13f7d6ea905e46252fcb27732c6211" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;iterindex&lt;/code&gt; sub-range that is being iterated. If &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt;&lt;code&gt;NPY_ITER_RANGED&lt;/code&gt;&lt;/a&gt; was not specified, this always returns the range &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt;.</source>
          <target state="translated">获取要迭代的 &lt;code&gt;iterindex&lt;/code&gt; 子范围。如果未指定&lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt; &lt;code&gt;NPY_ITER_RANGED&lt;/code&gt; &lt;/a&gt;，则始终返回范围 &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b29099a868ef51a061ab01f34d141a4b26e68b87" translate="yes" xml:space="preserve">
          <source>Gets the array of data pointers directly into the arrays (never into the buffers), corresponding to iteration index 0.</source>
          <target state="translated">直接获取数组中的数据指针(绝不是进入缓冲区),对应迭代索引0。</target>
        </trans-unit>
        <trans-unit id="ad1880ff271cb91c83bb908e9bec8d5e682e13f9" translate="yes" xml:space="preserve">
          <source>Gets the array of strides for the specified axis. Requires that the iterator be tracking a multi-index, and that buffering not be enabled.</source>
          <target state="translated">获取指定轴的步长数组。要求迭代器跟踪一个多索引,并且不启用缓冲。</target>
        </trans-unit>
        <trans-unit id="cbcc80db035da4f014fe2b35abfcfb7fdf954c8c" translate="yes" xml:space="preserve">
          <source>Gets the bit generator instance used by the generator</source>
          <target state="translated">获取生成器使用的位生成器实例。</target>
        </trans-unit>
        <trans-unit id="d159fd31101fbca3940d95031521a0aa1cca2dba" translate="yes" xml:space="preserve">
          <source>Getting at ndarray memory and accessing elements of the ndarray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a46b1f79c63a304cb32357fb767b2f9f13f63b7" translate="yes" xml:space="preserve">
          <source>Getting extra Fortran 77 compiler options from source</source>
          <target state="translated">从源代码中获取额外的Fortran 77编译器选项</target>
        </trans-unit>
        <trans-unit id="40231bcdbc4a93a29a6d8b82096fcd17f9064444" translate="yes" xml:space="preserve">
          <source>Getting started with Git development</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e47f4c54647389b910573011e6826ea1e0a912" translate="yes" xml:space="preserve">
          <source>Git Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfff37d55b9830b2f87d05fbf99d4f09fbfa666c" translate="yes" xml:space="preserve">
          <source>Git configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5717316487921ed9c21d808282281daa39b5a4" translate="yes" xml:space="preserve">
          <source>Git for development</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62cbb73206931d6c5b9ae31c184bc49486ee1eb6" translate="yes" xml:space="preserve">
          <source>Git will then immediately bring up an editor for editing the commit message. After revising it, we get the output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed2b47c2eb6fcb9566d8e5b338ef20c663258ac" translate="yes" xml:space="preserve">
          <source>Give a new shape to an array without changing its data.</source>
          <target state="translated">给一个数组赋予新的形状而不改变其数据。</target>
        </trans-unit>
        <trans-unit id="a577ea656c2f3aa2b8af6ec81a5f57008704a3bb" translate="yes" xml:space="preserve">
          <source>Give a new shape to the array without changing its data.</source>
          <target state="translated">给数组一个新的形状,而不改变其数据。</target>
        </trans-unit>
        <trans-unit id="5633a94c306e1317df951f106e430c35db17233f" translate="yes" xml:space="preserve">
          <source>Given a sequence of a polynomial&amp;rsquo;s zeros:</source>
          <target state="translated">给定一个多项式零的序列：</target>
        </trans-unit>
        <trans-unit id="4cc543f62ec648afbd60f8c46e36515054ff8b40" translate="yes" xml:space="preserve">
          <source>Given a sequence of arrays (&lt;em&gt;sort_keys&lt;/em&gt;) of the same shape, return an array of indices (similar to &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt;&lt;code&gt;PyArray_ArgSort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;)) that would sort the arrays lexicographically. A lexicographic sort specifies that when two keys are found to be equal, the order is based on comparison of subsequent keys. A merge sort (which leaves equal entries unmoved) is required to be defined for the types. The sort is accomplished by sorting the indices first using the first &lt;em&gt;sort_key&lt;/em&gt; and then using the second &lt;em&gt;sort_key&lt;/em&gt; and so forth. This is equivalent to the lexsort(&lt;em&gt;sort_keys&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;) Python command. Because of the way the merge-sort works, be sure to understand the order the &lt;em&gt;sort_keys&lt;/em&gt; must be in (reversed from the order you would use when comparing two elements).</source>
          <target state="translated">给定一系列形状相同的数组（&lt;em&gt;sort_keys&lt;/em&gt;），返回一个索引数组（类似于&lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt; &lt;code&gt;PyArray_ArgSort&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）），该索引将按字典顺序对数组进行排序。词典排序指定当发现两个键相等时，顺序基于后续键的比较。需要为这些类型定义合并排序（保留相等的条目不变）。通过首先使用第一个&lt;em&gt;sort_key&lt;/em&gt;对索引进行排序，然后使用第二个&lt;em&gt;sort_key&lt;/em&gt;等对索引进行排序，即可完成排序。这等效于lexsort（&lt;em&gt;sort_keys&lt;/em&gt;，&lt;em&gt;axis&lt;/em&gt;）Python命令。由于合并排序的工作方式，请务必了解&lt;em&gt;sort_keys&lt;/em&gt;的顺序&lt;em&gt;&lt;/em&gt; 必须存在（与比较两个元素时使用的顺序相反）。</target>
        </trans-unit>
        <trans-unit id="675ac4930884c9f7a3554ad9fd66c39834a06013" translate="yes" xml:space="preserve">
          <source>Given a set of conditions and corresponding functions, evaluate each function on the input data wherever its condition is true.</source>
          <target state="translated">给定一组条件和相应的函数,在输入数据上对每个函数进行评估,只要其条件为真。</target>
        </trans-unit>
        <trans-unit id="9104557d433ccbecbd40d5b471167b269afd4924" translate="yes" xml:space="preserve">
          <source>Given a shape of, for example, &lt;code&gt;(m,n,k)&lt;/code&gt;, &lt;code&gt;m*n*k&lt;/code&gt; samples are generated, and packed in an &lt;code&gt;m&lt;/code&gt;-by-&lt;code&gt;n&lt;/code&gt;-by-&lt;code&gt;k&lt;/code&gt; arrangement. Because each sample is &lt;code&gt;N&lt;/code&gt;-dimensional, the output shape is &lt;code&gt;(m,n,k,N)&lt;/code&gt;. If no shape is specified, a single (&lt;code&gt;N&lt;/code&gt;-D) sample is returned.</source>
          <target state="translated">给定的形状，例如， &lt;code&gt;(m,n,k)&lt;/code&gt; ， &lt;code&gt;m*n*k&lt;/code&gt; 中产生的样品，并包装在一 &lt;code&gt;m&lt;/code&gt; -by- &lt;code&gt;n&lt;/code&gt; -by- &lt;code&gt;k&lt;/code&gt; 布置。因为每个样本都是 &lt;code&gt;N&lt;/code&gt; 维的，所以输出形状为 &lt;code&gt;(m,n,k,N)&lt;/code&gt; 。如果未指定形状，则返回单个（ &lt;code&gt;N&lt;/code&gt; -D）样本。</target>
        </trans-unit>
        <trans-unit id="cd43bd0b568c4a20eb55e09b56aec26e4bcf57e8" translate="yes" xml:space="preserve">
          <source>Given a square array object:</source>
          <target state="translated">给定一个正方形数组对象。</target>
        </trans-unit>
        <trans-unit id="c727e55b5284efd4b0f949a20f79f07a731a7def" translate="yes" xml:space="preserve">
          <source>Given a square matrix &lt;code&gt;a&lt;/code&gt;, return the matrix &lt;code&gt;ainv&lt;/code&gt; satisfying &lt;code&gt;dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])&lt;/code&gt;.</source>
          <target state="translated">给定一个正方形矩阵 &lt;code&gt;a&lt;/code&gt; ，返回满足 &lt;code&gt;dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])&lt;/code&gt; 的矩阵 &lt;code&gt;ainv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc3ba91f03af5d3e0b135a4d459d0b8c153beab2" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the &lt;code&gt;q&lt;/code&gt;-th percentile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q/100&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the percentile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=50&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=100&lt;/code&gt;.</source>
          <target state="translated">给定的矢量 &lt;code&gt;V&lt;/code&gt; 的长度 &lt;code&gt;N&lt;/code&gt; ，所述 &lt;code&gt;q&lt;/code&gt; 个的百分 &lt;code&gt;V&lt;/code&gt; 是值 &lt;code&gt;q/100&lt;/code&gt; 的从最小到最大的的排序拷贝的方式 &lt;code&gt;V&lt;/code&gt; 。如果归一化排名与 &lt;code&gt;q&lt;/code&gt; 的位置不完全匹配，则两个最近邻居的值和距离以及 &lt;code&gt;interpolation&lt;/code&gt; 参数将确定百分位数。如果 &lt;code&gt;q=50&lt;/code&gt; ，此函数与中位数相同；如果 &lt;code&gt;q=0&lt;/code&gt; ，则与最小值相同；如果 &lt;code&gt;q=100&lt;/code&gt; ，则与最大值相同。</target>
        </trans-unit>
        <trans-unit id="1966cedf9ce61fd3a211e32f4abbb9573112f3e8" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;V_sorted&lt;/code&gt; - i e., &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd, and the average of the two middle values of &lt;code&gt;V_sorted&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">给定的矢量 &lt;code&gt;V&lt;/code&gt; 的长度 &lt;code&gt;N&lt;/code&gt; ，中位 &lt;code&gt;V&lt;/code&gt; 是的排序副本的中间值 &lt;code&gt;V&lt;/code&gt; ， &lt;code&gt;V_sorted&lt;/code&gt; -即， &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt; ，当 &lt;code&gt;N&lt;/code&gt; 是奇数，并且平均的当 &lt;code&gt;N&lt;/code&gt; 为偶数时， &lt;code&gt;V_sorted&lt;/code&gt; 的两个中间值。</target>
        </trans-unit>
        <trans-unit id="a11a60c1be0b2a1a4251da19f3ebb410f0917d80" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;V_sorted&lt;/code&gt; - i.e., &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd and the average of the two middle values of &lt;code&gt;V_sorted&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">给定的矢量 &lt;code&gt;V&lt;/code&gt; 的长度 &lt;code&gt;N&lt;/code&gt; ，中位 &lt;code&gt;V&lt;/code&gt; 是的排序副本的中间值 &lt;code&gt;V&lt;/code&gt; ， &lt;code&gt;V_sorted&lt;/code&gt; -即 &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt; ，当 &lt;code&gt;N&lt;/code&gt; 是奇数，并且平均两个中间值的 &lt;code&gt;N&lt;/code&gt; 为偶数时， &lt;code&gt;V_sorted&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="d76c2715df60bdab25092c54104462a6d39f23bb" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the q-th percentile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q/100&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the percentile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=50&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=100&lt;/code&gt;.</source>
          <target state="translated">给定的矢量 &lt;code&gt;V&lt;/code&gt; 的长度 &lt;code&gt;N&lt;/code&gt; ，的第q个百分位 &lt;code&gt;V&lt;/code&gt; 是值 &lt;code&gt;q/100&lt;/code&gt; 的从最小到最大的的排序拷贝的方式 &lt;code&gt;V&lt;/code&gt; 。如果归一化排名与 &lt;code&gt;q&lt;/code&gt; 的位置不完全匹配，则两个最近邻居的值和距离以及 &lt;code&gt;interpolation&lt;/code&gt; 参数将确定百分位数。如果 &lt;code&gt;q=50&lt;/code&gt; ，此函数与中位数相同；如果 &lt;code&gt;q=0&lt;/code&gt; ，则与最小值相同；如果 &lt;code&gt;q=100&lt;/code&gt; ，则与最大值相同。</target>
        </trans-unit>
        <trans-unit id="dfd59ffc41fbed91404c5101ddfa184c5392006b" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the q-th quantile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the quantile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=0.5&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0.0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=1.0&lt;/code&gt;.</source>
          <target state="translated">给定的矢量 &lt;code&gt;V&lt;/code&gt; 的长度 &lt;code&gt;N&lt;/code&gt; ，的第q个位数 &lt;code&gt;V&lt;/code&gt; 是值 &lt;code&gt;q&lt;/code&gt; 的从最小值到最大值在的排序拷贝的方式 &lt;code&gt;V&lt;/code&gt; 。如果归一化排名与 &lt;code&gt;q&lt;/code&gt; 的位置不完全匹配，则两个最近邻居的值和距离以及 &lt;code&gt;interpolation&lt;/code&gt; 参数将确定分位数。如果 &lt;code&gt;q=0.5&lt;/code&gt; ，此函数与中位数相同；如果 &lt;code&gt;q=0.0&lt;/code&gt; ，则与最小值相同；如果 &lt;code&gt;q=1.0&lt;/code&gt; ，则与最大值相同。</target>
        </trans-unit>
        <trans-unit id="97afe1ab394be8a96329790e96c805504acf970b" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; with &lt;code&gt;N&lt;/code&gt; non masked values, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt; (&lt;code&gt;Vs&lt;/code&gt;) - i.e. &lt;code&gt;Vs[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd, or &lt;code&gt;{Vs[N/2 - 1] + Vs[N/2]}/2&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">给定具有 &lt;code&gt;N&lt;/code&gt; 个非掩码值的向量 &lt;code&gt;V&lt;/code&gt; ， &lt;code&gt;V&lt;/code&gt; 的中位数是 &lt;code&gt;V&lt;/code&gt; （ &lt;code&gt;Vs&lt;/code&gt; ）的排序副本的中间值-即 &lt;code&gt;Vs[(N-1)/2]&lt;/code&gt; ，当 &lt;code&gt;N&lt;/code&gt; 为奇数时，即 &lt;code&gt;{Vs[N/2 - 1] + Vs[N/2]}/2&lt;/code&gt; 当 &lt;code&gt;N&lt;/code&gt; 为偶数时）。</target>
        </trans-unit>
        <trans-unit id="2f958084a15b1cea997fb4f3882497b30e2d92da" translate="yes" xml:space="preserve">
          <source>Given a window length &lt;code&gt;n&lt;/code&gt; and a sample spacing &lt;code&gt;d&lt;/code&gt;:</source>
          <target state="translated">给定窗口长度 &lt;code&gt;n&lt;/code&gt; 和样本间距 &lt;code&gt;d&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3cf50be3014d334ce381b3182c6e22be99505ba7" translate="yes" xml:space="preserve">
          <source>Given an &amp;ldquo;index&amp;rdquo; array (&lt;code&gt;a&lt;/code&gt;) of integers and a sequence of &lt;code&gt;n&lt;/code&gt; arrays (&lt;code&gt;choices&lt;/code&gt;), &lt;code&gt;a&lt;/code&gt; and each choice array are first broadcast, as necessary, to arrays of a common shape; calling these &lt;em&gt;Ba&lt;/em&gt; and &lt;em&gt;Bchoices[i], i = 0,&amp;hellip;,n-1&lt;/em&gt; we have that, necessarily, &lt;code&gt;Ba.shape == Bchoices[i].shape&lt;/code&gt; for each &lt;code&gt;i&lt;/code&gt;. Then, a new array with shape &lt;code&gt;Ba.shape&lt;/code&gt; is created as follows:</source>
          <target state="translated">给定一个由整数组成的&amp;ldquo;索引&amp;rdquo;数组（ &lt;code&gt;a&lt;/code&gt; ）和一个 &lt;code&gt;n&lt;/code&gt; 个数组（ &lt;code&gt;choices&lt;/code&gt; ）的序列，根据需要，首先将 &lt;code&gt;a&lt;/code&gt; 和每个choice数组广播到具有相同形状的数组；称这些&lt;em&gt;Ba&lt;/em&gt;和&lt;em&gt;Bchoices [i]，i = 0，&amp;hellip;，n-1，&lt;/em&gt;我们必然有 &lt;code&gt;Ba.shape == Bchoices[i].shape&lt;/code&gt; 每个 &lt;code&gt;i&lt;/code&gt; 的Bchoices [i] .shape。然后，创建一个形状为 &lt;code&gt;Ba.shape&lt;/code&gt; 的新数组，如下所示：</target>
        </trans-unit>
        <trans-unit id="182d11d96136738a2da66eeca81246c173e18b8d" translate="yes" xml:space="preserve">
          <source>Given an array of integers and a set of n choice arrays, this method will create a new array that merges each of the choice arrays. Where a value in &lt;code&gt;a&lt;/code&gt; is i, the new array will have the value that choices[i] contains in the same place.</source>
          <target state="translated">给定一个整数数组和一组n个选择数组，此方法将创建一个合并每个选择数组的新数组。如果a中 &lt;code&gt;a&lt;/code&gt; 值为i，则新数组将具有options [i]包含在同一位置的值。</target>
        </trans-unit>
        <trans-unit id="e37e450d620d60b14cee7269755ab57ba8f06da4" translate="yes" xml:space="preserve">
          <source>Given an interval, values outside the interval are clipped to the interval edges. For example, if an interval of &lt;code&gt;[0, 1]&lt;/code&gt; is specified, values smaller than 0 become 0, and values larger than 1 become 1.</source>
          <target state="translated">给定一个间隔，该间隔之外的值将被裁剪到间隔边缘。例如，如果指定间隔 &lt;code&gt;[0, 1]&lt;/code&gt; 则小于0的值将变为0，而大于1的值将变为1。</target>
        </trans-unit>
        <trans-unit id="38e44e10395d6cbc3f11e11b2660a79eed5fd62a" translate="yes" xml:space="preserve">
          <source>Given multiple sorting keys, which can be interpreted as columns in a spreadsheet, lexsort returns an array of integer indices that describes the sort order by multiple columns. The last key in the sequence is used for the primary sort order, the second-to-last key for the secondary sort order, and so on. The keys argument must be a sequence of objects that can be converted to arrays of the same shape. If a 2D array is provided for the keys argument, it&amp;rsquo;s rows are interpreted as the sorting keys and sorting is according to the last row, second last row etc.</source>
          <target state="translated">给定多个排序键（可以将其解释为电子表格中的列），lexsort返回一个整数索引数组，该数组描述了按多列排序的顺序。序列中的最后一个键用于主排序顺序，倒数第二个键用于辅助排序顺序，依此类推。keys参数必须是可以转换为相同形状的数组的对象序列。如果为keys参数提供了2D数组，则将其行解释为排序键，并根据最后一行，倒数第二行等进行排序。</target>
        </trans-unit>
        <trans-unit id="67d67e5173e989786e884148ab1ee5c292352200" translate="yes" xml:space="preserve">
          <source>Given the &amp;ldquo;legs&amp;rdquo; of a right triangle, return its hypotenuse.</source>
          <target state="translated">给定直角三角形的&amp;ldquo;腿&amp;rdquo;，返回其斜边。</target>
        </trans-unit>
        <trans-unit id="65f0e0f7ab08e6e7d473538fe0c4ef0f86fa2404" translate="yes" xml:space="preserve">
          <source>Given the above, we intend to deprecate &lt;code&gt;matrix&lt;/code&gt; eventually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd7a5a167593ffa963306f804bdee09ec39e8fd9" translate="yes" xml:space="preserve">
          <source>Given the shape of an array, an &lt;a href=&quot;#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; instance iterates over the N-dimensional index of the array. At each iteration a tuple of indices is returned, the last dimension is iterated over first.</source>
          <target state="translated">给定数组的形状，&lt;a href=&quot;#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt;实例将在数组的N维索引上进行迭代。在每次迭代中，将返回一个索引元组，最后一个维将首先迭代。</target>
        </trans-unit>
        <trans-unit id="6d84cece4ac6198159f79505d6fa6346cdc3c584" translate="yes" xml:space="preserve">
          <source>Given two &lt;em&gt;n&lt;/em&gt; -length arrays of integers, &lt;em&gt;l1&lt;/em&gt;, and &lt;em&gt;l2&lt;/em&gt;, return 1 if the lists are identical; otherwise, return 0.</source>
          <target state="translated">给定两个&lt;em&gt;n&lt;/em&gt;长度的整数数组&lt;em&gt;l1&lt;/em&gt;和&lt;em&gt;l2&lt;/em&gt;，如果列表相同，则返回1；否则，返回1。否则，返回0。</target>
        </trans-unit>
        <trans-unit id="b4d93ad7919330e367279622118fac9cd99eb66a" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of the first object are strictly smaller than those of the second object. An exception is raised at shape mismatch or incorrectly ordered values. Shape mismatch does not raise if an object has zero dimension. In contrast to the standard usage in numpy, NaNs are compared, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">给定两个array_like对象,检查形状是否相等,第一个对象的所有元素是否严格小于第二个对象的元素。形状不匹配或排序不正确会引发异常。如果一个对象的维度为零,形状不匹配不会引发异常。与numpy中的标准用法不同,NaNs是比较的,如果两个对象的NaNs位置相同,则不会引发断言。</target>
        </trans-unit>
        <trans-unit id="33ed5b3e4d203313d72bfb61344b0ef20252735e" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of these objects are equal (but see the Notes for the special handling of a scalar). An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fdf131a8e234662a4baf7342d5cbfdd8815673" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of these objects are equal. An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">给定两个array_like对象,检查形状是否相等,这些对象的所有元素是否相等。当形状不匹配或值冲突时,会引发一个异常。与numpy中的标准用法不同,NaNs是像数字一样进行比较的,如果两个对象的NaNs在相同的位置,则不会引发断言。</target>
        </trans-unit>
        <trans-unit id="03c045ae56fa8df86b5ce72f657667f3cc594e54" translate="yes" xml:space="preserve">
          <source>Given two numbers, check that they are approximately equal. Approximately equal is defined as the number of significant digits that agree.</source>
          <target state="translated">给定两个数字,检查它们是否近似相等。大致相等的定义是相同的有意义的数字的个数。</target>
        </trans-unit>
        <trans-unit id="d9d002c83204235df23caf3ec14f4354842036c7" translate="yes" xml:space="preserve">
          <source>Given two objects (scalars, lists, tuples, dictionaries or numpy arrays), check that all elements of these objects are equal. An exception is raised at the first conflicting values.</source>
          <target state="translated">给定两个对象(标量、列表、元组、字典或numpy数组),检查这些对象的所有元素是否相等。在第一个冲突的值时,就会引发一个异常。</target>
        </trans-unit>
        <trans-unit id="9d61f0f6669477d0eddf6043188e0f420dad8728" translate="yes" xml:space="preserve">
          <source>Given two polynomials &lt;code&gt;a1&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt;, returns &lt;code&gt;a1 - a2&lt;/code&gt;. &lt;code&gt;a1&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt; can be either array_like sequences of the polynomials&amp;rsquo; coefficients (including coefficients equal to zero), or &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">给定两个多项式 &lt;code&gt;a1&lt;/code&gt; 和 &lt;code&gt;a2&lt;/code&gt; ，返回 &lt;code&gt;a1 - a2&lt;/code&gt; 。 &lt;code&gt;a1&lt;/code&gt; 和 &lt;code&gt;a2&lt;/code&gt; 可以是多项式系数（包括等于零的系数）的类数组序列，也可以是&lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="8737cb46ba6778426f460962013153a76a798f04" translate="yes" xml:space="preserve">
          <source>Given two tensors, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and an array_like object containing two array_like objects, &lt;code&gt;(a_axes, b_axes)&lt;/code&gt;, sum the products of &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s and &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s elements (components) over the axes specified by &lt;code&gt;a_axes&lt;/code&gt; and &lt;code&gt;b_axes&lt;/code&gt;. The third argument can be a single non-negative integer_like scalar, &lt;code&gt;N&lt;/code&gt;; if it is such, then the last &lt;code&gt;N&lt;/code&gt; dimensions of &lt;code&gt;a&lt;/code&gt; and the first &lt;code&gt;N&lt;/code&gt; dimensions of &lt;code&gt;b&lt;/code&gt; are summed over.</source>
          <target state="translated">给定两个张量 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; ，以及一个包含两个array_like对象的array_like对象 &lt;code&gt;(a_axes, b_axes)&lt;/code&gt; ，将 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的元素（分量）的 &lt;code&gt;a_axes&lt;/code&gt; 和 &lt;code&gt;b_axes&lt;/code&gt; 指定的轴上求和。第三个参数可以是单个非负整数类标量 &lt;code&gt;N&lt;/code&gt; ；如果是这样，则最后 &lt;code&gt;N&lt;/code&gt; 的尺寸 &lt;code&gt;a&lt;/code&gt; 和第一 &lt;code&gt;N&lt;/code&gt; 的尺寸 &lt;code&gt;b&lt;/code&gt; 相加结束。</target>
        </trans-unit>
        <trans-unit id="1bcbaa6d418fa3c95df027de6ff9d3bb5387a091" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#r14e6c54b746b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">给定两个向量， &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; 和 &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; ，外积&lt;a href=&quot;#r14e6c54b746b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;为：</target>
        </trans-unit>
        <trans-unit id="3854728349ae7af32452ae7e4400a155448f9794" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#r863504129d6e-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">给定两个向量， &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; 和 &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; ，外积&lt;a href=&quot;#r863504129d6e-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;为：</target>
        </trans-unit>
        <trans-unit id="80ea28027215a4aa397564db3b7818bf4ec592b8" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#rf0d57dd5badd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">给定两个向量， &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; 和 &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; ，外积&lt;a href=&quot;#rf0d57dd5badd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;为：</target>
        </trans-unit>
        <trans-unit id="4975cd64a92e88880758085eef7772db2bdb4f4d" translate="yes" xml:space="preserve">
          <source>Given:</source>
          <target state="translated">Given:</target>
        </trans-unit>
        <trans-unit id="882e099811dae6ac151e6bf8446fa672be3c6225" translate="yes" xml:space="preserve">
          <source>Gives a list of the names to exclude, such as &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, &lt;code&gt;print&lt;/code&gt;&amp;hellip; If one of the input name is part of this list, an underscore character (&lt;code&gt;'_'&lt;/code&gt;) will be appended to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8020f30b057521f3745170a52c99adab4537c734" translate="yes" xml:space="preserve">
          <source>Gives a new shape to an array without changing its data.</source>
          <target state="translated">给予一个数组新的形状而不改变其数据。</target>
        </trans-unit>
        <trans-unit id="1175f81a358d9e3f38210901aaa9e95baea2d5bc" translate="yes" xml:space="preserve">
          <source>Gives a string combining all the characters that must be deleted from the name. By default, invalid characters are &lt;code&gt;~!@#$%^&amp;amp;*()-=+~\|]}[{';:
/?.&amp;gt;,&amp;lt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6df81d1943f224253f7e8824d4f6d90b5a6fd6" translate="yes" xml:space="preserve">
          <source>Glantz, Stanton A. &amp;ldquo;Primer of Biostatistics.&amp;rdquo;, McGraw-Hill, Fifth Edition, 2002.</source>
          <target state="translated">Stanton A. Glantz，&amp;ldquo;生物统计学的基础知识&amp;rdquo;，McGraw-Hill，第五版，2002年。</target>
        </trans-unit>
        <trans-unit id="98ce8e321806dbb3b91df4ce336400b327d82b05" translate="yes" xml:space="preserve">
          <source>Global State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="b5455baaf8bb77490bac48f282fc705e080b078c" translate="yes" xml:space="preserve">
          <source>Go to &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;https://github.com/numpy/numpy&lt;/a&gt; and click the &amp;ldquo;fork&amp;rdquo; button to create your own copy of the project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e307ec71f941bf50bb0ca58211aaf38b07c21cec" translate="yes" xml:space="preserve">
          <source>Go to &lt;a href=&quot;https://github.com/numpy/numpy/releases&quot;&gt;https://github.com/numpy/numpy/releases&lt;/a&gt;, there should be a &lt;code&gt;v1.14.5
tag&lt;/code&gt;, click on it and hit the edit button for that tag. There are two ways to add files, using an editable text window and as binary uploads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a55f17953adb4e53b1ccccc7c663a01a1165b91" translate="yes" xml:space="preserve">
          <source>Go to GitHub. The new branch will show up with a green Pull Request button. Make sure the title and message are clear, concise, and self- explanatory. Then click the button to submit it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69980c4426505922b99957185231ede61f777564" translate="yes" xml:space="preserve">
          <source>Go to github and make a PR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46869e8de50d59c9c1645cda5ce89ba58d2c65a" translate="yes" xml:space="preserve">
          <source>Go to the &lt;a href=&quot;https://www.numpy.org&quot;&gt;NumPy&lt;/a&gt; github home at &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy github&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3f0c82f9a531318bc29fd46c7f891f5c55b9a1" translate="yes" xml:space="preserve">
          <source>Good for wrapping large (many functions) existing C libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bb06bd200ddbdceda42084b415b9a92259f61a" translate="yes" xml:space="preserve">
          <source>Google offers two free &lt;a href=&quot;https://developers.google.com/tech-writing&quot;&gt;Technical Writing Courses&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823619e079c311b099f1d0e427a584eafcd6ed06" translate="yes" xml:space="preserve">
          <source>Governance</source>
          <target state="translated">Governance</target>
        </trans-unit>
        <trans-unit id="99a7f06ad80d74e23ee701e64001d24ce844ca07" translate="yes" xml:space="preserve">
          <source>Gradient is calculated only along the given axis or axes The default (axis = None) is to calculate the gradient for all the axes of the input array. axis may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">梯度只沿着给定的一个或多个轴计算。默认(轴=无)是计算输入数组所有轴的梯度。</target>
        </trans-unit>
        <trans-unit id="61aa58c2b09a3034acae73f52494d42574c0ca1c" translate="yes" xml:space="preserve">
          <source>Gradient is calculated using N-th order accurate differences at the boundaries. Default: 1.</source>
          <target state="translated">梯度是用N-阶精确的边界差计算的。默认值:1。</target>
        </trans-unit>
        <trans-unit id="ea0fcf87d2287941521d49f814fee6c705ce244c" translate="yes" xml:space="preserve">
          <source>Graphical illustration of &lt;code&gt;endpoint&lt;/code&gt; parameter:</source>
          <target state="translated">&lt;code&gt;endpoint&lt;/code&gt; 参数的图形化图示：</target>
        </trans-unit>
        <trans-unit id="bb4d80637c2066c9e7bffa72841d8f27a47b292b" translate="yes" xml:space="preserve">
          <source>Graphical illustration:</source>
          <target state="translated">图解。</target>
        </trans-unit>
        <trans-unit id="4a52fe6ab66ec52ee6bfd51d48518f7de2e194f9" translate="yes" xml:space="preserve">
          <source>Greater consistency in &lt;code&gt;assert_almost_equal&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d14a2a20cf23aef24c6cf5ba97cf49567e1739" translate="yes" xml:space="preserve">
          <source>Greedy &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (faster optimal path approximation): ~160ms</source>
          <target state="translated">贪婪的&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;（更快的最佳路径近似值）：〜160ms</target>
        </trans-unit>
        <trans-unit id="f6534be852374768c36e7beef74b1f4199fef68a" translate="yes" xml:space="preserve">
          <source>Grid-shaped arrays of evenly spaced numbers in N-dimensions.</source>
          <target state="translated">N个维度的均匀间隔数字的网格状阵列。</target>
        </trans-unit>
        <trans-unit id="d291656cb315e59b3437432c3e771768a130826d" translate="yes" xml:space="preserve">
          <source>Group 1</source>
          <target state="translated">第1组</target>
        </trans-unit>
        <trans-unit id="374327355d21f90b289f6f435aa2da5d797f0ae6" translate="yes" xml:space="preserve">
          <source>Group 2</source>
          <target state="translated">第二组</target>
        </trans-unit>
        <trans-unit id="f5ac35811e25f377d3ea665e7f41177582e5b116" translate="yes" xml:space="preserve">
          <source>Guaranteeing safe aligned access for ufuncs/setitem/casting code</source>
          <target state="translated">保证ufuncs/setitem/casting代码的安全对齐访问。</target>
        </trans-unit>
        <trans-unit id="f454c80c182290ac641c3ab02a9edcdbe149e617" translate="yes" xml:space="preserve">
          <source>Guide to writing Tutorials (TODO)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d49ac2fe6a93b218baff7cae5e0e60393e7661a" translate="yes" xml:space="preserve">
          <source>Guide to writing reference (API) documentation: the numpydoc docstring guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="141d1d74d8a6b3e7a7f1418ef539a53ce746ef34" translate="yes" xml:space="preserve">
          <source>Guidelines</source>
          <target state="translated">Guidelines</target>
        </trans-unit>
        <trans-unit id="fefaa04c360e4a9e3930a2840029cc9f56039f5f" translate="yes" xml:space="preserve">
          <source>Gumbel, E. J., &amp;ldquo;Statistics of Extremes,&amp;rdquo; New York: Columbia University Press, 1958.</source>
          <target state="translated">EJ Gumbel，&amp;ldquo;极端情况的统计&amp;rdquo;，纽约：哥伦比亚大学出版社，1958年。</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="a23a715b33c5262fe3d1b937504a94f4b675a4b6" translate="yes" xml:space="preserve">
          <source>H() (numpy.matrix property)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40b37f0341f572e1998e910b25532a92af5b558" translate="yes" xml:space="preserve">
          <source>Hack away! See &lt;a href=&quot;#editing-workflow&quot;&gt;below&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ecd57d6fb3350fcd694b91496d526594622dbb6" translate="yes" xml:space="preserve">
          <source>Half precision float: sign bit, 5 bits exponent, 10 bits mantissa</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c895f403bde1ed69e17f92c19862768cc5f5de8d" translate="yes" xml:space="preserve">
          <source>Half-precision functions</source>
          <target state="translated">半精度功能</target>
        </trans-unit>
        <trans-unit id="188b61888bd344a019188c5ddd9af8e491599b6a" translate="yes" xml:space="preserve">
          <source>Hand-generated wrappers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636dbc8830ea645ecf6015e1f4a6dd1accda26f4" translate="yes" xml:space="preserve">
          <source>Handled by &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">由&lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt;处理</target>
        </trans-unit>
        <trans-unit id="7178628eaa2183565412d3981a3508d31193d4b5" translate="yes" xml:space="preserve">
          <source>Handling complex numbers</source>
          <target state="translated">处理复杂的数字</target>
        </trans-unit>
        <trans-unit id="0294f5e8c997832af6154aa5a34d3bc487dacc89" translate="yes" xml:space="preserve">
          <source>Handling of higher-dimensional arrays (ndim &amp;gt; 2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29536b0ea00b813744dd07cc20d7e2d652df9775" translate="yes" xml:space="preserve">
          <source>Handling of vectors (one-dimensional arrays)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210d84fcc7fb5c4b75800916312424c57f881c7b" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;fill_value&lt;/code&gt;</source>
          <target state="translated">处理 &lt;code&gt;fill_value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e59976d95e4c0283fbcfa38c1a2f893c3bfd15d" translate="yes" xml:space="preserve">
          <source>Handling the mask</source>
          <target state="translated">处理面具</target>
        </trans-unit>
        <trans-unit id="78dcc8157bbf5d134fc488651952052da7016437" translate="yes" xml:space="preserve">
          <source>Hard-coded dimensions, data-buffer-then-dimensions specification, and dimensions-then-data-buffer specification.</source>
          <target state="translated">硬编码尺寸、数据缓冲区再尺寸规范、尺寸再数据缓冲区规范。</target>
        </trans-unit>
        <trans-unit id="edfcf418a2bb124e6b8ce652d8bb7600c0be7269" translate="yes" xml:space="preserve">
          <source>Hardness of the mask</source>
          <target state="translated">面罩的硬度</target>
        </trans-unit>
        <trans-unit id="a06e8ccba0be0394ad2df2eedd04a51d1a1039c5" translate="yes" xml:space="preserve">
          <source>Has no effect, do not use.</source>
          <target state="translated">没有效果,请勿使用。</target>
        </trans-unit>
        <trans-unit id="4669500ffada7a9acbed3d1bf7fceec5a930f074" translate="yes" xml:space="preserve">
          <source>Has the same shape as &lt;code&gt;element&lt;/code&gt;. The values &lt;code&gt;element[isin]&lt;/code&gt; are in &lt;code&gt;test_elements&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;element&lt;/code&gt; 具有相同的形状。值 &lt;code&gt;element[isin]&lt;/code&gt; &lt;code&gt;test_elements&lt;/code&gt; ]在test_elements中。</target>
        </trans-unit>
        <trans-unit id="2d794659e95706af6481a92a9285f876ae1c7d63" translate="yes" xml:space="preserve">
          <source>Have a look at the &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; install help pages available from &lt;a href=&quot;https://help.github.com&quot;&gt;github help&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab4d88ad951423d45baeab75192e5801e748751" translate="yes" xml:space="preserve">
          <source>Have a shared library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d944005e31393bd466d7655b38df2b420878ca75" translate="yes" xml:space="preserve">
          <source>Having a shared library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f62bdff9b904bdda1a1ed9ed602657769f3345fd" translate="yes" xml:space="preserve">
          <source>Having compiled code also means that importing NumPy from the development sources needs some additional steps, which are explained below. For the rest of this chapter we assume that you have set up your git repo as described in &lt;a href=&quot;gitwash/index#using-git&quot;&gt;Git for development&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce7b6e9a18227e2359efe8c98f693affe997e690" translate="yes" xml:space="preserve">
          <source>Heckert, N. A. and Filliben, James J. &amp;ldquo;NIST Handbook 148: Dataplot Reference Manual, Volume 2: Let Subcommands and Library Functions&amp;rdquo;, National Institute of Standards and Technology Handbook Series, June 2003. &lt;a href=&quot;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&quot;&gt;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&lt;/a&gt;</source>
          <target state="translated">Neck的Heckert和James J的Filliben。&amp;ldquo; NIST手册148：Dataplot参考手册，第2卷：让子命令和库功能&amp;rdquo;，美国国家标准技术研究所手册系列，2003年6月&lt;a href=&quot;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&quot;&gt;。https：//www.itl.nist。 gov / div898 / software / dataplot / refman2 / auxillar / powpdf.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f25b2d1977ec1a7cc15a3fe3ee364cef6feeebb6" translate="yes" xml:space="preserve">
          <source>Help increase engagement in good discussion practice: try to identify where discussion may have broken down and provide actionable information, pointers and resources that can lead to positive change on these points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334c16fc9ac63595f080f7bbcdf324a43ffd5267" translate="yes" xml:space="preserve">
          <source>Helper Functions</source>
          <target state="translated">辅助功能</target>
        </trans-unit>
        <trans-unit id="3cffecba0fc696fb0b452757e50e8d2d6aa15660" translate="yes" xml:space="preserve">
          <source>Helper for pickle.</source>
          <target state="translated">泡菜的帮手。</target>
        </trans-unit>
        <trans-unit id="8e0ce1fc0fa49364a15481aa8d6e74b5ad646a8c" translate="yes" xml:space="preserve">
          <source>Helper routines</source>
          <target state="translated">辅助程序</target>
        </trans-unit>
        <trans-unit id="591b0ee67a75bdd05c2441f5d821e72ac5abd9ff" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; may also contain signature files. Among other options (see below), the following options can be used in this mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad119f3969c50ae36c69dfd7a8f2258a296a9e4" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;x&lt;/code&gt; is a one-dimensional array of length two whose datatype is a structure with three fields: 1. A string of length 10 or less named &amp;lsquo;name&amp;rsquo;, 2. a 32-bit integer named &amp;lsquo;age&amp;rsquo;, and 3. a 32-bit float named &amp;lsquo;weight&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05d939cfc36f7e101c6969543d3aa4fc112af1c5" translate="yes" xml:space="preserve">
          <source>Here appropriately means at least two tabs. It isn&amp;rsquo;t necessary to line everything up with the opening parenthesis of the function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41762c3a1457e94bd62a7f7522c1df055434f548" translate="yes" xml:space="preserve">
          <source>Here are examples of shapes that do not broadcast:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f2d508ec85c3c97b5a1229502e255e40023669a" translate="yes" xml:space="preserve">
          <source>Here are several examples of custom weekmask values. These examples specify the &amp;ldquo;busday&amp;rdquo; default of Monday through Friday being valid days.</source>
          <target state="translated">这是自定义周掩码值的几个示例。这些示例将星期一至星期五的&amp;ldquo; busday&amp;rdquo;默认值指定为有效日期。</target>
        </trans-unit>
        <trans-unit id="4cc8d83645ead10353d3c11cd3d81d28f5fe4bc7" translate="yes" xml:space="preserve">
          <source>Here are some examples of signatures:</source>
          <target state="translated">下面是一些签名的例子。</target>
        </trans-unit>
        <trans-unit id="c7c80754b6ccbe7d6353c18ee79360b34170e3a5" translate="yes" xml:space="preserve">
          <source>Here are some more examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edcf4d32cc0d6364c8d8b907e9c3e1d6fd286f96" translate="yes" xml:space="preserve">
          <source>Here are the date units:</source>
          <target state="translated">这里是日期单位。</target>
        </trans-unit>
        <trans-unit id="fcedd65241f400ab6b9cead2ae708d4ee0595afe" translate="yes" xml:space="preserve">
          <source>Here brackets &lt;code&gt;[]&lt;/code&gt; indicate an optional part, dots &lt;code&gt;...&lt;/code&gt; indicate one or more of a previous part. So, &lt;code&gt;[]...&lt;/code&gt; reads zero or more of a previous part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a598f6524593a5ce80868abd4ad9058d26e6370" translate="yes" xml:space="preserve">
          <source>Here is a class that takes a standard ndarray that already exists, casts as our type, and adds an extra attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e64dc50ed3c98bebd079533bedfe8d3d04f0a87" translate="yes" xml:space="preserve">
          <source>Here is a conversion table for which functions to use with the new iterator:</source>
          <target state="translated">下面是新迭代器使用哪些函数的转换表。</target>
        </trans-unit>
        <trans-unit id="ae703a87217d209b99ae68f8790ce06f1f882b70" translate="yes" xml:space="preserve">
          <source>Here is a list of some useful NumPy functions and methods names ordered in categories. See &lt;a href=&quot;../reference/routines#routines&quot;&gt;Routines&lt;/a&gt; for the full list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2fbbb0f1468c183a40201806e4aca9dcb3c7060" translate="yes" xml:space="preserve">
          <source>Here is a simple copy function using the iterator. The &lt;code&gt;order&lt;/code&gt; parameter is used to control the memory layout of the allocated result, typically &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f499cb9c92d0a44a206fb77f5f29cb1c19da659" translate="yes" xml:space="preserve">
          <source>Here is a simple copy function using the iterator. The &lt;code&gt;order&lt;/code&gt; parameter is used to control the memory layout of the allocated result, typically &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is desired.</source>
          <target state="translated">这是使用迭代器的简单复制功能。的 &lt;code&gt;order&lt;/code&gt; 参数被用于控制所分配的结果的存储器布局，通常&lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt;是期望的。</target>
        </trans-unit>
        <trans-unit id="955a08b4bff95343601789d2bf6e0369ccf3f1b3" translate="yes" xml:space="preserve">
          <source>Here is a useful idiom for getting contiguous copies instead of non-contiguous views.</source>
          <target state="translated">这里有一个很有用的成语,用来获取毗连的副本而不是不毗连的视图。</target>
        </trans-unit>
        <trans-unit id="9908262441b7f09837e1f501a21d5cc69908d615" translate="yes" xml:space="preserve">
          <source>Here is an example function which operates like a &amp;ldquo;lambda&amp;rdquo; ufunc:</source>
          <target state="translated">这是一个示例函数，其功能类似于&amp;ldquo; lambda&amp;rdquo; ufunc：</target>
        </trans-unit>
        <trans-unit id="1e3d31fc803b806643f783a13be59435e8ec2879" translate="yes" xml:space="preserve">
          <source>Here is an example outer product function:</source>
          <target state="translated">下面是一个外积函数的例子。</target>
        </trans-unit>
        <trans-unit id="3e01528c46f09f5f5d5be27407d90af619b21250" translate="yes" xml:space="preserve">
          <source>Here is how the variables above are used:</source>
          <target state="translated">下面是上述变量的使用方法。</target>
        </trans-unit>
        <trans-unit id="1637a3171b3e141604dedb2e68519a7e5432d5d7" translate="yes" xml:space="preserve">
          <source>Here is how they can be used with a sample array:</source>
          <target state="translated">下面是如何使用它们的样本数组。</target>
        </trans-unit>
        <trans-unit id="b9c4a8ea1157853e06ffc2f25fe3f9b079de55b6" translate="yes" xml:space="preserve">
          <source>Here is how we might write an &lt;code&gt;iter_add&lt;/code&gt; function, using the Python iterator protocol:</source>
          <target state="translated">这是我们使用Python迭代器协议编写 &lt;code&gt;iter_add&lt;/code&gt; 函数的方式：</target>
        </trans-unit>
        <trans-unit id="82ebceae19f8e179d652196db8007bed9b016e84" translate="yes" xml:space="preserve">
          <source>Here is part of a Cython module named &lt;code&gt;add.pyx&lt;/code&gt; which implements the complex addition functions we previously implemented using f2py:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27fb417254a59c4a73469e0d501f40b87bdc16a" translate="yes" xml:space="preserve">
          <source>Here is shown a modified version of the previous Fortran code, save it as &lt;code&gt;fib3.f&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ce084ba97f0fb601f4ee822ae6a8abc564ba7d" translate="yes" xml:space="preserve">
          <source>Here is the same function, but following the C-style pattern:</source>
          <target state="translated">这里是同样的函数,但遵循C式模式。</target>
        </trans-unit>
        <trans-unit id="d4daff3ad7f47434c82a5051360f6f8f9147bcdd" translate="yes" xml:space="preserve">
          <source>Here the 4th and 5th rows are selected from the indexed array and combined to make a 2-D array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="879104127602f2f170c22fa52acd13e1c1a2bd91" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;newaxis&lt;/code&gt; index operator inserts a new axis into &lt;code&gt;a&lt;/code&gt;, making it a two-dimensional &lt;code&gt;4x1&lt;/code&gt; array. Combining the &lt;code&gt;4x1&lt;/code&gt; array with &lt;code&gt;b&lt;/code&gt;, which has shape &lt;code&gt;(3,)&lt;/code&gt;, yields a &lt;code&gt;4x3&lt;/code&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="386e95414daee162c67ba2f23612c05957e9c9fa" translate="yes" xml:space="preserve">
          <source>Here the newaxis index operator inserts a new axis into &lt;code&gt;a&lt;/code&gt;, making it a two-dimensional 4x1 array. &lt;a href=&quot;#figure-4&quot;&gt;Figure 4&lt;/a&gt; illustrates the stretching of both arrays to produce the desired 4x3 output array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="948564e37f936b7d719e03a725d3b08432712a65" translate="yes" xml:space="preserve">
          <source>Here we give a list of short and useful tips.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43ab7c4c94ff9df3968be0c3da83726730e60b3" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the listing of sum_squares.pyx:</source>
          <target state="translated">这是sum_squares.pyx的清单：</target>
        </trans-unit>
        <trans-unit id="4f05498cc571c5e0811d261874316f4fcd69c560" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the short summary, complete TOC links are below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30babd25e27e87a901a32627496afe119a238cc9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;x&lt;/code&gt; is a dictionary mapping keys to values, in this case the integer 1 to the string &amp;ldquo;one&amp;rdquo;, and the string &amp;ldquo;two&amp;rdquo; to the list &lt;code&gt;[1, 2]&lt;/code&gt;. The values may be accessed using their corresponding keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb0a1675e1ab72957846b002b2ccbd5daaee32d" translate="yes" xml:space="preserve">
          <source>Here, I&amp;rsquo;ve used the built-in enumerate iterator to return the iterator index as well as the value.</source>
          <target state="translated">在这里，我使用了内置的枚举迭代器来返回迭代器索引和值。</target>
        </trans-unit>
        <trans-unit id="423ebc2c2e7601fe55f4484a7fb3dc69ce69a81b" translate="yes" xml:space="preserve">
          <source>Here, U is drawn from the uniform distribution over (0,1].</source>
          <target state="translated">这里,U来自于(0,1]上的均匀分布。</target>
        </trans-unit>
        <trans-unit id="b81e3c833ac1c20cf33999c717a7683fc509fd53" translate="yes" xml:space="preserve">
          <source>Here, you grabbed a section of your array from index position 3 through index position 8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9958f2320c4c020dbe0ba918682ede328e6342d6" translate="yes" xml:space="preserve">
          <source>Hermite</source>
          <target state="translated">Hermite</target>
        </trans-unit>
        <trans-unit id="3e97b960fb6669c7ce3d868bc1ee39fbd840fc5f" translate="yes" xml:space="preserve">
          <source>Hermite (class in numpy.polynomial.hermite)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666fe7ebc09d7395dcf2297ae16799bfb275707b" translate="yes" xml:space="preserve">
          <source>Hermite Class</source>
          <target state="translated">赫米特级</target>
        </trans-unit>
        <trans-unit id="78bcd4fcaaa0c27a38e217337ec719b8d794b08b" translate="yes" xml:space="preserve">
          <source>Hermite Module, &amp;ldquo;Physicists&amp;rsquo;&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite&lt;/code&gt;)</source>
          <target state="translated">Hermite模块，&amp;ldquo;物理学家&amp;rdquo;（ &lt;code&gt;numpy.polynomial.hermite&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="20e36a23caee8661ea5087eb6b2833159c8b55f9" translate="yes" xml:space="preserve">
          <source>Hermite Module, &amp;ldquo;Physicists&amp;rsquo;&amp;rdquo; (numpy.polynomial.hermite)</source>
          <target state="translated">Hermite模块，&amp;ldquo;物理学家&amp;rdquo;（numpy.polynomial.hermite）</target>
        </trans-unit>
        <trans-unit id="4e51cfc7050a81e8b6b2247a7d2dcbdd5d5665a8" translate="yes" xml:space="preserve">
          <source>Hermite Module, “Physicists’” (numpy.polynomial.hermite)</source>
          <target state="translated">Hermite模块,&quot;物理学家&quot;(numpy.polynomial.hermite)</target>
        </trans-unit>
        <trans-unit id="7e732e7a329c7f9da3eef2d091dd68d62fa1ae1a" translate="yes" xml:space="preserve">
          <source>Hermite Series, &amp;ldquo;Physicists&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d4eab91a42ee672e761807e2ccfac51f95da47" translate="yes" xml:space="preserve">
          <source>Hermite Series, &amp;ldquo;Physicists&amp;rdquo; (numpy.polynomial.hermite)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="321f1ab84f3ad6f4602b6463648250d7c017db66" translate="yes" xml:space="preserve">
          <source>Hermite coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*H_0(x) + 2*H_1(X) + 3*H_2(x)&lt;/code&gt;.</source>
          <target state="translated">厄米系数按递增的顺序排列，即 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 给出 &lt;code&gt;1*H_0(x) + 2*H_1(X) + 3*H_2(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="030c6d9cd5a3996624a5dedd47cce0a8b255a2e1" translate="yes" xml:space="preserve">
          <source>Hermite coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">厄米系数从低到高排序。如果 &lt;code&gt;y&lt;/code&gt; 为2-d，在的k列中的数据的系数 &lt;code&gt;y&lt;/code&gt; 在柱 &lt;code&gt;k&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdaeee3c1bfcab3d833e2cd601bbef119c7ca375" translate="yes" xml:space="preserve">
          <source>Hermite series</source>
          <target state="translated">Hermite系列</target>
        </trans-unit>
        <trans-unit id="5d7c6da49173b96e3654eaebdb82df4267a07cd8" translate="yes" xml:space="preserve">
          <source>Hermite series coefficients of the integral.</source>
          <target state="translated">赫米特系列系数的积分。</target>
        </trans-unit>
        <trans-unit id="f178c08ed0e44e86c3dcdcdd94165f4d2159704d" translate="yes" xml:space="preserve">
          <source>Hermite series of power.</source>
          <target state="translated">赫米特系列的动力。</target>
        </trans-unit>
        <trans-unit id="4b1ee605707018d73fef71e944f33b064cb30198" translate="yes" xml:space="preserve">
          <source>Hermite series of the derivative.</source>
          <target state="translated">赫米特系列的衍生物。</target>
        </trans-unit>
        <trans-unit id="f3b525d4a933addff05d89e23fb102c4771100af" translate="yes" xml:space="preserve">
          <source>Hermite series whose graph is a straight line.</source>
          <target state="translated">赫米特数列的图形是一条直线。</target>
        </trans-unit>
        <trans-unit id="f15ba129dfce798b05af2ecf87c4c56e141a51c6" translate="yes" xml:space="preserve">
          <source>Hermite weight function</source>
          <target state="translated">赫米特重量函数</target>
        </trans-unit>
        <trans-unit id="e91ac76ec50377772a4d0a0fad317ac36bda67d9" translate="yes" xml:space="preserve">
          <source>Hermite.__call__()</source>
          <target state="translated">Hermite.__call__()</target>
        </trans-unit>
        <trans-unit id="e00caea2e8b760013383648bd7a0c8356ad2d21a" translate="yes" xml:space="preserve">
          <source>Hermite.basis()</source>
          <target state="translated">Hermite.basis()</target>
        </trans-unit>
        <trans-unit id="510f491be62b2a7e3419873aabcc929cba4aad0a" translate="yes" xml:space="preserve">
          <source>Hermite.cast()</source>
          <target state="translated">Hermite.cast()</target>
        </trans-unit>
        <trans-unit id="0bbb26adb9485391c59073a0150f1aeb28250175" translate="yes" xml:space="preserve">
          <source>Hermite.convert()</source>
          <target state="translated">Hermite.convert()</target>
        </trans-unit>
        <trans-unit id="46e59fa3efb39aa8de99b77595a66c5aca6f95af" translate="yes" xml:space="preserve">
          <source>Hermite.copy()</source>
          <target state="translated">Hermite.copy()</target>
        </trans-unit>
        <trans-unit id="150883af29979fdad32a1485afaa265ae485116d" translate="yes" xml:space="preserve">
          <source>Hermite.cutdeg()</source>
          <target state="translated">Hermite.cutdeg()</target>
        </trans-unit>
        <trans-unit id="6e3addaaf8a990d63bd9644e879a45bfaaa3d048" translate="yes" xml:space="preserve">
          <source>Hermite.degree()</source>
          <target state="translated">Hermite.degree()</target>
        </trans-unit>
        <trans-unit id="1898e27484be79666c2d0d0671ff99bb73c61fb0" translate="yes" xml:space="preserve">
          <source>Hermite.deriv()</source>
          <target state="translated">Hermite.deriv()</target>
        </trans-unit>
        <trans-unit id="74d98daf1082d857dc8043ef7d611943987bcbf6" translate="yes" xml:space="preserve">
          <source>Hermite.domain</source>
          <target state="translated">Hermite.domain</target>
        </trans-unit>
        <trans-unit id="69a9477b050cf5e84517bc3ba4b2540b289809dd" translate="yes" xml:space="preserve">
          <source>Hermite.fit()</source>
          <target state="translated">Hermite.fit()</target>
        </trans-unit>
        <trans-unit id="ee377bb8277d3cc87539518382039049d3434ab2" translate="yes" xml:space="preserve">
          <source>Hermite.fromroots()</source>
          <target state="translated">Hermite.fromroots()</target>
        </trans-unit>
        <trans-unit id="f3d364e431135afb3032332cc59ddec1d0087c65" translate="yes" xml:space="preserve">
          <source>Hermite.has_samecoef()</source>
          <target state="translated">Hermite.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="4f5a15af827e1a34e56c335924bc117f06d9550b" translate="yes" xml:space="preserve">
          <source>Hermite.has_samedomain()</source>
          <target state="translated">Hermite.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="5c6b35ea3f6249366ad14a64bf61b1e2f4ef3fa2" translate="yes" xml:space="preserve">
          <source>Hermite.has_sametype()</source>
          <target state="translated">Hermite.has_sametype()</target>
        </trans-unit>
        <trans-unit id="51595f8a76f511b51c25db7ca6799c30af573ff1" translate="yes" xml:space="preserve">
          <source>Hermite.has_samewindow()</source>
          <target state="translated">Hermite.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="fae0683eb07169c7856c805873bd384998f4ce23" translate="yes" xml:space="preserve">
          <source>Hermite.identity()</source>
          <target state="translated">Hermite.identity()</target>
        </trans-unit>
        <trans-unit id="6d7f1a135c9fd7bdb20e45551f21a01a1b98749d" translate="yes" xml:space="preserve">
          <source>Hermite.integ()</source>
          <target state="translated">Hermite.integ()</target>
        </trans-unit>
        <trans-unit id="87c4ac5818fcc034b0a86594470677888839404b" translate="yes" xml:space="preserve">
          <source>Hermite.linspace()</source>
          <target state="translated">Hermite.linspace()</target>
        </trans-unit>
        <trans-unit id="e4e8e042f2bff68022c1506a796ae1f2b1a45e62" translate="yes" xml:space="preserve">
          <source>Hermite.mapparms()</source>
          <target state="translated">Hermite.mapparms()</target>
        </trans-unit>
        <trans-unit id="dd2d324dc15bd07b8d8eba7c1b9a303c6e61cbe9" translate="yes" xml:space="preserve">
          <source>Hermite.roots()</source>
          <target state="translated">Hermite.roots()</target>
        </trans-unit>
        <trans-unit id="357de88ac6a59383fa4db68dc02a30a97aa55b31" translate="yes" xml:space="preserve">
          <source>Hermite.trim()</source>
          <target state="translated">Hermite.trim()</target>
        </trans-unit>
        <trans-unit id="ded6de456aef1c9f3f0dbb030eecbec360a2a3d9" translate="yes" xml:space="preserve">
          <source>Hermite.truncate()</source>
          <target state="translated">Hermite.truncate()</target>
        </trans-unit>
        <trans-unit id="bfa82105a95ddf719538cbbbc2136f5bdc652b85" translate="yes" xml:space="preserve">
          <source>HermiteE</source>
          <target state="translated">HermiteE</target>
        </trans-unit>
        <trans-unit id="213b3add1699deb17fd0362b28ee9eaa1e08297e" translate="yes" xml:space="preserve">
          <source>HermiteE (class in numpy.polynomial.hermite_e)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6628b3304670336395ae6732f06085678ac90c72" translate="yes" xml:space="preserve">
          <source>HermiteE Class</source>
          <target state="translated">HermiteE级</target>
        </trans-unit>
        <trans-unit id="da640bfdcf0affcdb1cb3e699294b822aff50f4d" translate="yes" xml:space="preserve">
          <source>HermiteE Module, &amp;ldquo;Probabilists&amp;rsquo;&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt;)</source>
          <target state="translated">HermiteE模块，&amp;ldquo;概率专家&amp;rdquo;（ &lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="93c34719e313928a50611a43ea25a148a84b264b" translate="yes" xml:space="preserve">
          <source>HermiteE Module, &amp;ldquo;Probabilists&amp;rsquo;&amp;rdquo; (numpy.polynomial.hermite_e)</source>
          <target state="translated">HermiteE模块，&amp;ldquo;概率主义者&amp;rdquo;（numpy.polynomial.hermite_e）</target>
        </trans-unit>
        <trans-unit id="56f6680ec7b317dd6ae3f4dbb7e9720ab2e6af02" translate="yes" xml:space="preserve">
          <source>HermiteE Module, “Probabilists’” (numpy.polynomial.hermite_e)</source>
          <target state="translated">HermiteE模块,&quot;概率论者&quot;(numpy.polynomial.hermite_e)</target>
        </trans-unit>
        <trans-unit id="a7da5893b105551d489e12a654065cc1aa5b0de0" translate="yes" xml:space="preserve">
          <source>HermiteE Series, &amp;ldquo;Probabilists&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01652b3974c2bf789bf8511d4ddd036a45eab615" translate="yes" xml:space="preserve">
          <source>HermiteE Series, &amp;ldquo;Probabilists&amp;rdquo; (numpy.polynomial.hermite_e)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7090e745bd4427b0619b5249b32836cf9e710c91" translate="yes" xml:space="preserve">
          <source>HermiteE coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*He_0(x) + 2*He_1(X) + 3*He_2(x)&lt;/code&gt;.</source>
          <target state="translated">HermiteE系数按递增顺序递增，即 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 给出 &lt;code&gt;1*He_0(x) + 2*He_1(X) + 3*He_2(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fdce93a022f8c8da6190fdc0f7e0fa2783e7c6d" translate="yes" xml:space="preserve">
          <source>HermiteE series</source>
          <target state="translated">HermiteE系列</target>
        </trans-unit>
        <trans-unit id="f8a256fa19026169a866b5809900fc5fb915e807" translate="yes" xml:space="preserve">
          <source>HermiteE weight function.</source>
          <target state="translated">HermiteE重量函数。</target>
        </trans-unit>
        <trans-unit id="f2a1b68f303ab3a67abc7b2e4c4c8451183b7095" translate="yes" xml:space="preserve">
          <source>HermiteE.__call__()</source>
          <target state="translated">HermiteE.__call__()</target>
        </trans-unit>
        <trans-unit id="45c27d16e911c80a7d363f3c39ba54997fd020cd" translate="yes" xml:space="preserve">
          <source>HermiteE.basis()</source>
          <target state="translated">HermiteE.basis()</target>
        </trans-unit>
        <trans-unit id="b45b6525bda44ccf736a4ef59137ed1b81c51100" translate="yes" xml:space="preserve">
          <source>HermiteE.cast()</source>
          <target state="translated">HermiteE.cast()</target>
        </trans-unit>
        <trans-unit id="4ddefc1ce033e171e5d4661134688bd82e8bc5af" translate="yes" xml:space="preserve">
          <source>HermiteE.convert()</source>
          <target state="translated">HermiteE.convert()</target>
        </trans-unit>
        <trans-unit id="002903a3a64a57beced04a1c5706dd609af411f5" translate="yes" xml:space="preserve">
          <source>HermiteE.copy()</source>
          <target state="translated">HermiteE.copy()</target>
        </trans-unit>
        <trans-unit id="b24cf643ce7571c11b38beb07f1dba60d0898965" translate="yes" xml:space="preserve">
          <source>HermiteE.cutdeg()</source>
          <target state="translated">HermiteE.cutdeg()</target>
        </trans-unit>
        <trans-unit id="564634c0d69d527c3b8fbcf352579c91cc6babc0" translate="yes" xml:space="preserve">
          <source>HermiteE.degree()</source>
          <target state="translated">HermiteE.degree()</target>
        </trans-unit>
        <trans-unit id="b0998c48dfd3e6da9f8d9a094fe9026de37d9068" translate="yes" xml:space="preserve">
          <source>HermiteE.deriv()</source>
          <target state="translated">HermiteE.deriv()</target>
        </trans-unit>
        <trans-unit id="e3b7e4ce40140bfad9d15417ff37a5918c3d9ee7" translate="yes" xml:space="preserve">
          <source>HermiteE.domain</source>
          <target state="translated">HermiteE.domain</target>
        </trans-unit>
        <trans-unit id="b9a9cf1e6530dd58c8fe754b4c5e909f051929ea" translate="yes" xml:space="preserve">
          <source>HermiteE.fit()</source>
          <target state="translated">HermiteE.fit()</target>
        </trans-unit>
        <trans-unit id="4a10eb67a6e8118b67d08f9c1672e5c1ef31f7e7" translate="yes" xml:space="preserve">
          <source>HermiteE.fromroots()</source>
          <target state="translated">HermiteE.fromroots()</target>
        </trans-unit>
        <trans-unit id="f215586092039a3f249d19a38ef5f2e5c8b9fe46" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samecoef()</source>
          <target state="translated">HermiteE.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="e303961ece2b00de2ea59d3add859f3b9afba3be" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samedomain()</source>
          <target state="translated">HermiteE.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="56c531828abb17c1fa8561b9e8274772104c7875" translate="yes" xml:space="preserve">
          <source>HermiteE.has_sametype()</source>
          <target state="translated">HermiteE.has_sametype()</target>
        </trans-unit>
        <trans-unit id="f597206a0348307571c5766a04f0329e0e5977a6" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samewindow()</source>
          <target state="translated">HermiteE.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="edecbdf0322d9c36d15b82f596749f9baa998818" translate="yes" xml:space="preserve">
          <source>HermiteE.identity()</source>
          <target state="translated">HermiteE.identity()</target>
        </trans-unit>
        <trans-unit id="50879495edc6ec638987e4aab2fb5c3ff2693ffc" translate="yes" xml:space="preserve">
          <source>HermiteE.integ()</source>
          <target state="translated">HermiteE.integ()</target>
        </trans-unit>
        <trans-unit id="7644c7d4879b67345881eccc21f74f5ac1d76221" translate="yes" xml:space="preserve">
          <source>HermiteE.linspace()</source>
          <target state="translated">HermiteE.linspace()</target>
        </trans-unit>
        <trans-unit id="71240e92395878a17c98ad6cabf8e728e1e375a7" translate="yes" xml:space="preserve">
          <source>HermiteE.mapparms()</source>
          <target state="translated">HermiteE.mapparms()</target>
        </trans-unit>
        <trans-unit id="918dc10943107e5fa1f93651ccb4cc1d4ca399a0" translate="yes" xml:space="preserve">
          <source>HermiteE.roots()</source>
          <target state="translated">HermiteE.roots()</target>
        </trans-unit>
        <trans-unit id="6c5620ec0bf2dc54449e61b049184a2294791751" translate="yes" xml:space="preserve">
          <source>HermiteE.trim()</source>
          <target state="translated">HermiteE.trim()</target>
        </trans-unit>
        <trans-unit id="8b9f703c9558cb71c68ad02c3049b60b8b59198b" translate="yes" xml:space="preserve">
          <source>HermiteE.truncate()</source>
          <target state="translated">HermiteE.truncate()</target>
        </trans-unit>
        <trans-unit id="a2691f3b6c74bc9be228ebe1bfd4aaa8b167edac" translate="yes" xml:space="preserve">
          <source>Hermite_e series coefficients of the integral.</source>
          <target state="translated">Hermite_e系列系数的积分。</target>
        </trans-unit>
        <trans-unit id="cb6305ebb37efa97b74f55f04adb878c2cfd6823" translate="yes" xml:space="preserve">
          <source>Hermitian (symmetric if all elements are real), positive-definite input matrix.</source>
          <target state="translated">隐函数(如果所有元素都是实数,则是对称的),正定义输入矩阵。</target>
        </trans-unit>
        <trans-unit id="559550c9b0251579dbef6add2f3cc35db020af9a" translate="yes" xml:space="preserve">
          <source>Hermitian FFTs</source>
          <target state="translated">隐性FFTs</target>
        </trans-unit>
        <trans-unit id="d6600c2342a8053253425f9846737e2bf29ea82c" translate="yes" xml:space="preserve">
          <source>Hermitian or real symmetric matrices whose eigenvalues and eigenvectors are to be computed.</source>
          <target state="translated">隐性或实对称矩阵,其特征值和特征向量要计算。</target>
        </trans-unit>
        <trans-unit id="2e330e11eac48710d52dc39e422ecae197585b4d" translate="yes" xml:space="preserve">
          <source>High-order polynomials may oscillate wildly:</source>
          <target state="translated">高阶多项式可能会疯狂振荡。</target>
        </trans-unit>
        <trans-unit id="4be99f1c1557117aa5c64902eb10d5b0886a0d69" translate="yes" xml:space="preserve">
          <source>Higher dimensions</source>
          <target state="translated">更高的层面</target>
        </trans-unit>
        <trans-unit id="1f9c9c4e9b69dcd6586dbf80815cf3c44f18d220" translate="yes" xml:space="preserve">
          <source>Highlights</source>
          <target state="translated">Highlights</target>
        </trans-unit>
        <trans-unit id="00b07925679220cb801f1a4855d71039bbcccecc" translate="yes" xml:space="preserve">
          <source>Hiroshi Haramoto, Makoto Matsumoto, Takuji Nishimura, Fran&amp;ccedil;ois Panneton, Pierre L&amp;rsquo;Ecuyer, &amp;ldquo;Efficient Jump Ahead for F2-Linear Random Number Generators&amp;rdquo;, INFORMS JOURNAL ON COMPUTING, Vol. 20, No. 3, Summer 2008, pp. 385-390.</source>
          <target state="translated">原本博史，松本诚，西村拓uji，弗朗索瓦&amp;middot;潘尼顿，皮埃尔&amp;middot;拉库尔（Pierre L'Ecuyer），&amp;ldquo; F2线性随机数发生器的高效前行&amp;rdquo;，《计算机信息学杂志》，第1卷。20，第3号，2008年夏季，第385-390页。</target>
        </trans-unit>
        <trans-unit id="5fb511a742639c34c53d07c644e43f8a516d0a8b" translate="yes" xml:space="preserve">
          <source>Hiroshi Haramoto, Makoto Matsumoto, and Pierre L&amp;rsquo;Ecuyer, &amp;ldquo;A Fast Jump Ahead Algorithm for Linear Recurrences in a Polynomial Space&amp;rdquo;, Sequences and Their Applications - SETA, 290&amp;ndash;298, 2008.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f16459104f92ab6b38aa265adb4ecbfc3768e303" translate="yes" xml:space="preserve">
          <source>Histogram</source>
          <target state="translated">Histogram</target>
        </trans-unit>
        <trans-unit id="9f573dd516c5fae818d100652937d22c8be8a33c" translate="yes" xml:space="preserve">
          <source>Histograms</source>
          <target state="translated">Histograms</target>
        </trans-unit>
        <trans-unit id="4ae9938f95b0f1ddca2c84e6c590258bb6c7a2fc" translate="yes" xml:space="preserve">
          <source>Historically, NumPy has provided a special matrix type, &lt;code&gt;np.matrix&lt;/code&gt;, which is a subclass of ndarray which makes binary operations linear algebra operations. You may see it used in some existing code instead of &lt;code&gt;np.array&lt;/code&gt;. So, which one to use?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c95aa82b69eff297d0839c133733de00ba649c" translate="yes" xml:space="preserve">
          <source>Hit the &lt;code&gt;{Publish,Update} release&lt;/code&gt; button at the bottom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34329cbed12573fba3127f8cc749498a60eadbb9" translate="yes" xml:space="preserve">
          <source>Hook in &lt;code&gt;numpy/__init__.py&lt;/code&gt; to run distribution-specific checks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f07bc7a75153468adfa0658b0fd2c34d3ff7ae" translate="yes" xml:space="preserve">
          <source>Horner&amp;rsquo;s scheme &lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is used to evaluate the polynomial. Even so, for polynomials of high degree the values may be inaccurate due to rounding errors. Use carefully.</source>
          <target state="translated">Horner的方案&lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;用于评估多项式。即使这样，对于高次多项式，由于舍入误差，值可能仍然不准确。小心使用。</target>
        </trans-unit>
        <trans-unit id="a0bb6d60bdafa1c8cd27af7d704ca6a159830aba" translate="yes" xml:space="preserve">
          <source>How Tos</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37544ef44c5ec43acf39ee75fa75aed3630c67b7" translate="yes" xml:space="preserve">
          <source>How can we pass our custom array type through this function? Numpy allows a class to indicate that it would like to handle computations in a custom-defined way through the interfaces &lt;code&gt;__array_ufunc__&lt;/code&gt; and &lt;code&gt;__array_function__&lt;/code&gt;. Let&amp;rsquo;s take one at a time, starting with &lt;code&gt;_array_ufunc__&lt;/code&gt;. This method covers &lt;a href=&quot;../reference/ufuncs#ufuncs&quot;&gt;Universal functions (ufunc)&lt;/a&gt;, a class of functions that includes, for example, &lt;a href=&quot;../reference/generated/numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;numpy.multiply&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.sin#numpy.sin&quot;&gt;&lt;code&gt;numpy.sin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb47cd6d16a30a926efe82eaad98fb5865139f5" translate="yes" xml:space="preserve">
          <source>How do we construct a 2D array from a list of equally-sized row vectors? In MATLAB this is quite easy: if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are two vectors of the same length you only need do &lt;code&gt;m=[x;y]&lt;/code&gt;. In NumPy this works via the functions &lt;code&gt;column_stack&lt;/code&gt;, &lt;code&gt;dstack&lt;/code&gt;, &lt;code&gt;hstack&lt;/code&gt; and &lt;code&gt;vstack&lt;/code&gt;, depending on the dimension in which the stacking is to be done. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6749c478409711ffa23534cffe66364ec264e6" translate="yes" xml:space="preserve">
          <source>How do we know when consensus has been achieved? In principle, this is rather difficult, since consensus is defined by the absence of vetos, which requires us to somehow prove a negative. In practice, we use a combination of our best judgement (e.g., a simple and uncontroversial bug fix posted on GitHub and reviewed by a core developer is probably fine) and best efforts (e.g., all substantive API changes must be posted to the mailing list in order to give the broader community a chance to catch any problems and suggest improvements; we assume that anyone who cares enough about NumPy to invoke their veto right should be on the mailing list). If no-one bothers to comment on the mailing list after a few days, then it&amp;rsquo;s probably fine. And worst case, if a change is more controversial than expected, or a crucial critique is delayed because someone was on vacation, then it&amp;rsquo;s no big deal: we apologize for misjudging the situation, &lt;a href=&quot;http://producingoss.com/en/producingoss.html#version-control-relaxation&quot;&gt;back up, and sort things out&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fbb3731558c54237c322aa799a621ca3c7d2a1" translate="yes" xml:space="preserve">
          <source>How do you know the shape and size of an array?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e254592757b5e545a9eb104e6529f78a4c37d7" translate="yes" xml:space="preserve">
          <source>How many bytes needed to jump from the end of a dimension back to its beginning. Note that &lt;code&gt;backstrides[k] == strides[k] *
dims_m1[k]&lt;/code&gt;, but it is stored here as an optimization.</source>
          <target state="translated">从维的末尾跳回其开始需要多少字节。注意 &lt;code&gt;backstrides[k] == strides[k] * dims_m1[k]&lt;/code&gt; ，但它是作为优化存储在这里的。</target>
        </trans-unit>
        <trans-unit id="50be7c0770c6ecdb4f48559d001a760ebacd49cf" translate="yes" xml:space="preserve">
          <source>How many trials succeeded after a single run?</source>
          <target state="translated">一次运行后,有多少次试验成功?</target>
        </trans-unit>
        <trans-unit id="b58aa8864964e56b91e5cf3a16abe6db4861d007" translate="yes" xml:space="preserve">
          <source>How numpy handles numerical exceptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769ef91e51259c0af4889f9e0ba44a7641bc888d" translate="yes" xml:space="preserve">
          <source>How the committee will respond to reports</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9fac3d5f2ed22d26d8e65434409a64b568a19a" translate="yes" xml:space="preserve">
          <source>How to Prepare a Release</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2421f501c3d9da50b64e18ac9aabab538f44d78" translate="yes" xml:space="preserve">
          <source>How to access the docstring for more information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acdb5801edd59835ce1589b37b87df7e5921dc32" translate="yes" xml:space="preserve">
          <source>How to check the ABI of BLAS/LAPACK libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aec4c512fe995b8565d4654ce7ac7f7406a4e3f" translate="yes" xml:space="preserve">
          <source>How to contribute to the NumPy documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9221bbb4c993e17b159a09a015a8cfb26163b6a" translate="yes" xml:space="preserve">
          <source>How to contribute to this documentation (user and API)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16ba9588c01309cec829be39d4d7fa37da2d3d4" translate="yes" xml:space="preserve">
          <source>How to convert a 1D array into a 2D array (how to add a new axis to an array)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767132203b56ed5a732938158524dc8930f4e863" translate="yes" xml:space="preserve">
          <source>How to create a basic array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484181d716d9291c06f7d7ef08909d7d6fab3e0a" translate="yes" xml:space="preserve">
          <source>How to create an array from existing data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc4cf70f5442751464e426079ad36aeb36f19be" translate="yes" xml:space="preserve">
          <source>How to do common tasks with NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf433e8cb198db7bf7c955d6715ae5e9750b810" translate="yes" xml:space="preserve">
          <source>How to extend NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666793dffdb7a87d947a14c2cbc94401669fb6a1" translate="yes" xml:space="preserve">
          <source>How to get unique items and counts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f78c1b7c6c2daa9f22d71b7624a2bf3c525a6f" translate="yes" xml:space="preserve">
          <source>How to import NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f492f4c3e2bb0aa4c599fef867f4b321aedf559" translate="yes" xml:space="preserve">
          <source>How to read and write data using NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e26bd806025536efd64003099ee09d64aa0000" translate="yes" xml:space="preserve">
          <source>How to reverse an array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a0ae6b713025a426e1208163ee26bcb0e742b0a" translate="yes" xml:space="preserve">
          <source>How to save and load NumPy objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41cd522ba4633ce6d4277a1ec4fd27e9f6066b5f" translate="yes" xml:space="preserve">
          <source>How to treat dates that do not fall on a valid day. The default is &amp;lsquo;raise&amp;rsquo;.</source>
          <target state="translated">如何处理非有效日期的日期。默认值为&amp;ldquo; raise&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="32eab6d31082447f7e78feb7ff06453c5204497b" translate="yes" xml:space="preserve">
          <source>How to use an array iterator on a C-level is explained more fully in later sections. Typically, you do not need to concern yourself with the internal structure of the iterator object, and merely interact with it through the use of the macros &lt;a href=&quot;array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it), &lt;a href=&quot;array#c.PyArray_ITER_GOTO&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt;&lt;/a&gt; (it, dest), or &lt;a href=&quot;array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; (it, index). All of these macros require the argument &lt;em&gt;it&lt;/em&gt; to be a &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031b673efec683dbe6f1648f1b6820d5445558f5" translate="yes" xml:space="preserve">
          <source>How to use an array iterator on a C-level is explained more fully in later sections. Typically, you do not need to concern yourself with the internal structure of the iterator object, and merely interact with it through the use of the macros &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it), &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt;&lt;/a&gt; (it, dest), or &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; (it, index). All of these macros require the argument &lt;em&gt;it&lt;/em&gt; to be a &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在后面的部分中将更全面地说明如何在C级上使用数组迭代器。通常，您不需要关心迭代器对象的内部结构，而只需通过使用宏&lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt;（it），&lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt; &lt;/a&gt;（it，dest）或&lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt; &lt;/a&gt;（it，index）与它进行交互。所有这些宏需要论证&lt;em&gt;它&lt;/em&gt;是一个&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject *&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9bcd1bde0a6ac509c8c0a0f1ece3cf8687c68de6" translate="yes" xml:space="preserve">
          <source>How to write docstrings in the numpydoc format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e4974ddfecbf0d517a464e620b926746339cbe" translate="yes" xml:space="preserve">
          <source>However, F2PY provides a hook to overcome this difficulty, namely, users can define their own &amp;lt;Fortran type&amp;gt; to &amp;lt;C type&amp;gt; maps. For example, if Fortran 90 code contains:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fba89386b8ecb89961d14d41f66fbec5ccd1d21" translate="yes" xml:space="preserve">
          <source>However, array scalars are immutable, so none of the array scalar attributes are settable.</source>
          <target state="translated">但是,数组标量是不可变的,所以数组标量的属性都是不可设置的。</target>
        </trans-unit>
        <trans-unit id="1e80ea7cc9443be2dc987f1f00e1482c24f952ab" translate="yes" xml:space="preserve">
          <source>However, for a 2D array, &lt;code&gt;tolist&lt;/code&gt; applies recursively:</source>
          <target state="translated">但是，对于2D数组， &lt;code&gt;tolist&lt;/code&gt; 递归适用：</target>
        </trans-unit>
        <trans-unit id="015eddccae9844f7be37e7464bfea1ad89cd5089" translate="yes" xml:space="preserve">
          <source>However, if editing Fortran codes is acceptable, then the generation of an intermediate signature file can be skipped in most cases. Namely, F2PY specific attributes can be inserted directly to Fortran source codes using the so-called F2PY directive. A F2PY directive defines special comment lines (starting with &lt;code&gt;Cf2py&lt;/code&gt;, for example) which are ignored by Fortran compilers but F2PY interprets them as normal lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b575af53d48fbf01519f17fa75457eb6160cea6e" translate="yes" xml:space="preserve">
          <source>However, if one wants to perform an operation on each element in the array, one can use the &lt;code&gt;flat&lt;/code&gt; attribute which is an &lt;a href=&quot;https://docs.python.org/tutorial/classes.html#iterators&quot;&gt;iterator&lt;/a&gt; over all the elements of the array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538a59374ec076485a1ecbe77f4b8f8bcaeb6930" translate="yes" xml:space="preserve">
          <source>However, if the step length is a &lt;strong&gt;complex number&lt;/strong&gt; (e.g. 5j), then the integer part of its magnitude is interpreted as specifying the number of points to create between the start and stop values, where the stop value &lt;strong&gt;is inclusive&lt;/strong&gt;.</source>
          <target state="translated">但是，如果步长是一个&lt;strong&gt;复数&lt;/strong&gt;（例如5j），则将其幅度的整数部分解释为指定要在起始值和终止值之间创建的点数，其中终止值&lt;strong&gt;是包含端点的&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c7b350918e2c3c187f55b17296e6170af94589d5" translate="yes" xml:space="preserve">
          <source>However, it also provides a filter mechanism to work around &lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180&lt;/a&gt;.</source>
          <target state="translated">但是，它也提供了一种过滤器机制来解决&lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180的问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a0d3e8aabdd09f6d1c5b5cc067196fd48077165" translate="yes" xml:space="preserve">
          <source>However, on Windows accessing an attribute of the &lt;code&gt;cdll&lt;/code&gt; method will load the first DLL by that name found in the current directory or on the PATH. Loading the absolute path name requires a little finesse for cross-platform work since the extension of shared libraries varies. There is a &lt;code&gt;ctypes.util.find_library&lt;/code&gt; utility available that can simplify the process of finding the library to load but it is not foolproof. Complicating matters, different platforms have different default extensions used by shared libraries (e.g. .dll &amp;ndash; Windows, .so &amp;ndash; Linux, .dylib &amp;ndash; Mac OS X). This must also be taken into account if you are using ctypes to wrap code that needs to work on several platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72730352a2b8f129f65e5ce4d2975cad73414281" translate="yes" xml:space="preserve">
          <source>However, since the indexing arrays above just repeat themselves, broadcasting can be used (compare operations such as &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt;) to simplify this:</source>
          <target state="translated">但是，由于上面的索引数组只会重复自身，因此可以使用广播（比较操作，例如 &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt; ）来简化此操作：</target>
        </trans-unit>
        <trans-unit id="5598df37564d4f9b7b446978966b782318a91f69" translate="yes" xml:space="preserve">
          <source>However, the Council&amp;rsquo;s primary responsibility is to facilitate the ordinary community-based decision making procedure described above. If we ever have to step in and formally override the community for the health of the Project, then we will do so, but we will consider reaching this point to indicate a failure in our leadership.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148e0e3942c54a4e1382c28056e669f5ec70ca70" translate="yes" xml:space="preserve">
          <source>However, the recommended way to get changes made by Fortran subroutine back to Python is to use &lt;code&gt;intent(out)&lt;/code&gt; attribute. It is more efficient and a cleaner solution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076196cf7f29cbacc06332dc3a19baa5b6deb43a" translate="yes" xml:space="preserve">
          <source>However, there are ways (see below) how to &amp;ldquo;teach&amp;rdquo; F2PY about the true intentions (among other things) of function arguments; and then F2PY is able to generate more Pythonic (more explicit, easier to use, and less error prone) wrappers to Fortran functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517b2fc5c448904cbaf5099f9fa2e17572271c41" translate="yes" xml:space="preserve">
          <source>However, this class is not run directly. Rather, it serves as a base class to several other python classes, each one specific to a particular data type. The &lt;code&gt;VectorTestCase&lt;/code&gt; class stores two strings for typing information:</source>
          <target state="translated">但是，此类不能直接运行。相反，它是其他几个python类的基类，每个python类都特定于一种特定的数据类型。该 &lt;code&gt;VectorTestCase&lt;/code&gt; 类存储两个字符串的打字信息：</target>
        </trans-unit>
        <trans-unit id="2a6f4657816e90073e4efa70d32c1dabe823c21d" translate="yes" xml:space="preserve">
          <source>However, we can not do this by putting &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; into an array, because this array will be interpreted as indexing the first dimension of a.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b3b9f48e63d95c45789879b62e0b7dfb5a4009" translate="yes" xml:space="preserve">
          <source>However, when the list of indices contains repetitions, the assignment is done several times, leaving behind the last value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf7f433a664b8146a9906ca7ff1abe3cab252ff" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine, element-wise.</source>
          <target state="translated">双曲余弦,元素方面。</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">双曲函数</target>
        </trans-unit>
        <trans-unit id="b87cce3c91c3e9d2649c00af3ce0c941c00a9a8f" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine, element-wise.</source>
          <target state="translated">双曲正弦,元素方面。</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="32232530b1100268522739a98df9e054ce98ef4f" translate="yes" xml:space="preserve">
          <source>I() (numpy.matrix property)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c586011e018241bf43412c51ec75d78e1897bbe7" translate="yes" xml:space="preserve">
          <source>I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng. trans. Ed.), &lt;em&gt;Handbook of Mathematics&lt;/em&gt;, New York, Van Nostrand Reinhold Co., 1985, pg. 720.</source>
          <target state="translated">在Bronshtein，KA Semendyayev和KA Hirsch（英语译）中，&lt;em&gt;《数学手册》&lt;/em&gt;，纽约，范&amp;middot;诺斯特兰德&amp;middot;莱因霍尔德（Van Nostrand Reinhold Co.），第1985页。720。</target>
        </trans-unit>
        <trans-unit id="447fb9923a27f15d934b8afdf5c0a4f010eb6dd4" translate="yes" xml:space="preserve">
          <source>I/O with NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc08020472b5f8bfb4430d0521200fb31b0b681" translate="yes" xml:space="preserve">
          <source>IEEE 754 Floating Point Special Values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee225f319b80c76b05dae881594a3894bf4661e" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of (positive) infinity.</source>
          <target state="translated">IEEE 754浮点表示(正)无穷大。</target>
        </trans-unit>
        <trans-unit id="ff3e6480ff45af971d6b3762d77291c710637eb0" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of Not a Number (NaN).</source>
          <target state="translated">IEEE 754浮点表示的不是一个数字(NaN)。</target>
        </trans-unit>
        <trans-unit id="824566ddb199752efcc7660bd7d421e1b2678da4" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative infinity.</source>
          <target state="translated">IEEE 754浮点表示负无穷大。</target>
        </trans-unit>
        <trans-unit id="2e340e10314a130edadd8cad9f96f416538b858d" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative zero.</source>
          <target state="translated">IEEE 754 负零的浮点表示。</target>
        </trans-unit>
        <trans-unit id="b287f77a659c8b69b20168ee840f1a54628cc862" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of positive zero.</source>
          <target state="translated">IEEE 754浮点表示正零。</target>
        </trans-unit>
        <trans-unit id="72cabc0c250f4a292eec84ba99be92816a937afe" translate="yes" xml:space="preserve">
          <source>INSTALL.rst.txt</source>
          <target state="translated">INSTALL.rst.txt</target>
        </trans-unit>
        <trans-unit id="ab585ec9c005c8ff11ee6135d8e5382d325fbd66" translate="yes" xml:space="preserve">
          <source>IO compatibility with large files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e274113d3320e2ddaa1955ecaa00f8ecd732ab0e" translate="yes" xml:space="preserve">
          <source>IO performance improvements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401e5d8be22ba7ec21a65d4ac42f63626cf30eac" translate="yes" xml:space="preserve">
          <source>ISO/IEC standard 9899:1999, &amp;ldquo;Programming language C.&amp;rdquo;</source>
          <target state="translated">ISO / IEC标准9899：1999，&amp;ldquo;编程语言C&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a192903ac36265b2268a1b63fb4343f1bc34ccf1" translate="yes" xml:space="preserve">
          <source>ISeedSequence.generate_state()</source>
          <target state="translated">ISeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="7817ae1e33233084a2765c4156676391d76c8dd8" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.generate_state()</source>
          <target state="translated">ISpawnableSeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="266493f5f6f829a5601662541a1f5723f1a321cc" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.spawn()</source>
          <target state="translated">ISpawnableSeedSequence.spawn()</target>
        </trans-unit>
        <trans-unit id="08673d1ddebe80d6502dff08e88d404531dbe20b" translate="yes" xml:space="preserve">
          <source>Identifies the benchmarks to run. This can be a string to pass to the nosetests executable with the &amp;lsquo;-A&amp;rsquo; option, or one of several special values. Special values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2938dea7757a31542d1346c3f1074719ce51ad4d" translate="yes" xml:space="preserve">
          <source>Identifies the tests to run. This can be a string to pass to the nosetests executable with the &amp;lsquo;-A&amp;rsquo; option, or one of several special values. Special values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84791116b8cc2df6bbeaf0d85f3bf0937f9761c0" translate="yes" xml:space="preserve">
          <source>Identify the commit hash of the release, e.g. 1b2e1d63ff.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111e795804fa7bde03948ba63ec2cb3f6f402b39" translate="yes" xml:space="preserve">
          <source>Identity function.</source>
          <target state="translated">身份功能。</target>
        </trans-unit>
        <trans-unit id="ef2cb61738111c3044b6a344dba03012a1f3066b" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;inner&amp;rsquo;, returns the elements common to both r1 and r2. If &amp;lsquo;outer&amp;rsquo;, returns the common elements as well as the elements of r1 not in r2 and the elements of not in r2. If &amp;lsquo;leftouter&amp;rsquo;, returns the common elements and the elements of r1 not in r2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a8c69d524e3737d8a52d7c063a710ab1820ab4" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;left&amp;rsquo;, the index of the first suitable location found is given. If &amp;lsquo;right&amp;rsquo;, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">如果为&amp;ldquo; left&amp;rdquo;，则给出找到的第一个合适位置的索引。如果为&amp;ldquo;正确&amp;rdquo;，则返回最后一个这样的索引。如果没有合适的索引，返回0或N（其中N是的长度 &lt;code&gt;a&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0b2ac55fdba7a6077870f65fb651eb209decd3f7" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;out&amp;rsquo; is None (the default), a uninitialized return array is created. The output array is then filled with the results of the ufunc in the places that the broadcast &amp;lsquo;where&amp;rsquo; is True. If &amp;lsquo;where&amp;rsquo; is the scalar True (the default), then this corresponds to the entire output being filled. Note that outputs not explicitly filled are left with their uninitialized values.</source>
          <target state="translated">如果'out'为None（默认值），则会创建一个未初始化的返回数组。然后，在广播&amp;ldquo; where&amp;rdquo;为True的地方，用ufunc的结果填充输出数组。如果&amp;ldquo; where&amp;rdquo;是标量True（默认值），则它对应于要填充的整个输出。请注意，未明确填充的输出将保留其未初始化的值。</target>
        </trans-unit>
        <trans-unit id="b221bc8f0d9f3564598fa735c4c298856c0dd2e9" translate="yes" xml:space="preserve">
          <source>If -1/NULL values are passed to &lt;code&gt;oa_ndim&lt;/code&gt;, &lt;code&gt;op_axes&lt;/code&gt;, &lt;code&gt;itershape&lt;/code&gt;, and &lt;code&gt;buffersize&lt;/code&gt;, it is equivalent to &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果将-1 / NULL值传递给 &lt;code&gt;oa_ndim&lt;/code&gt; ， &lt;code&gt;op_axes&lt;/code&gt; ， &lt;code&gt;itershape&lt;/code&gt; 和 &lt;code&gt;buffersize&lt;/code&gt; ，则等效于&lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="07ab4829841dadccaa2d85de36af5f3925367c25" translate="yes" xml:space="preserve">
          <source>If 64-bit integers are still too small the result may be cast to a floating point number. Floating point numbers offer a larger, but inexact, range of possible values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d46b4b066a6ba67bd08b99b0faa98132c0c54b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is #defined, regardless of whether &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is, the C-API is declared to be &lt;code&gt;extern void**&lt;/code&gt;, so it is expected to be defined in another compilation unit.</source>
          <target state="translated">如果&lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; &lt;/a&gt;是#defined定义的，则不管&lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt;是否为C，都将C-API声明为 &lt;code&gt;extern void**&lt;/code&gt; ，因此应在另一个编译单元中对其进行定义。</target>
        </trans-unit>
        <trans-unit id="f636b5861ee4fae57e7d457d50fef770ecd7b810" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; was called, you may want to enable the flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;. This flag is not permitted together with &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt;, so this function is provided to enable the feature after &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; is called. This function also resets the iterator to its initial state.</source>
          <target state="translated">如果&lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; &lt;/a&gt;，则可能要启用标记&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;。不允许将此标志与&lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt;一起使用，因此提供此函数以在&lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; &lt;/a&gt;之后启用该功能。此功能还可以将迭代器重置为其初始状态。</target>
        </trans-unit>
        <trans-unit id="1cac2a31adf2200c294f5c075bb6c153e55fa5a2" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is #defined, but &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is not, the C-API is declared to be &lt;code&gt;void**&lt;/code&gt;, so that it will also be visible to other compilation units.</source>
          <target state="translated">如果&lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt;定义了PY_ARRAY_UNIQUE_SYMBOL，但没有定义&lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; &lt;/a&gt;，则C-API被声明为 &lt;code&gt;void**&lt;/code&gt; ，因此其他编译单元也可以看到它。</target>
        </trans-unit>
        <trans-unit id="f0fe9dfd78027e91a1bff4d801d8eb87a4610a71" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is not specified, but &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is specified (and is not an ndarray sub-class), the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; of the MaskedArray will be reset. If neither &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are specified (or if &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is an ndarray sub-class), then the fill value is preserved. Finally, if &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is specified, but &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not, the fill value is set to the specified value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6b83b00b9ce96c4a5e91132daa4d55535f9e96d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is set, array is copied only if dtype does not match:</source>
          <target state="translated">如果设置了&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;，则仅当dtype不匹配时才复制数组：</target>
        </trans-unit>
        <trans-unit id="4fc8bcfc9864193d76a4195dd238fe6624ed9a71" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is not one dimensional, the output also has these dimensions.</source>
          <target state="translated">如果&lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt;不是一维，则输出也具有这些维。</target>
        </trans-unit>
        <trans-unit id="6ede9f1a1e5701156394dbca76c84f8a340a9cea" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is not specified, but &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is specified (and is not an ndarray sub-class), the &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; of the MaskedArray will be reset. If neither &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are specified (or if &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is an ndarray sub-class), then the fill value is preserved. Finally, if &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is specified, but &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not, the fill value is set to the specified value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5ce8d43810f8659a3ffbe656fd3c96f0228399" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is a string, it is interpreted as a matrix with commas or spaces separating columns, and semicolons separating rows.</source>
          <target state="translated">如果&lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt;是字符串，则将其解释为矩阵，其中用逗号或空格分隔列，用分号分隔行。</target>
        </trans-unit>
        <trans-unit id="006799ea3355b83be37fd21ad89f661aac343125" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, then this flag determines whether the data is copied (the default), or whether a view is constructed.</source>
          <target state="translated">如果&lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt;已经是&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，则此标志确定是否复制数据（默认值）或是否构造视图。</target>
        </trans-unit>
        <trans-unit id="f12c5c9464a76ef6881e238c0f45cc6cb56cab96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;filename.pyf&amp;gt;&lt;/code&gt; is specified as &lt;code&gt;stdout&lt;/code&gt; then signatures are send to standard output instead of a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e7424cfa201c4ec783e98a6da198e97606627a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; contains a signature file, then a source for an extension module is constructed, all Fortran and C sources are compiled, and finally all object and library files are linked to the extension module &lt;code&gt;&amp;lt;modulename&amp;gt;.so&lt;/code&gt; which is saved into the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207fbf09fcd7223478aec74725e5d0380117e758" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; does not contain a signature file, then an extension module is constructed by scanning all Fortran source codes for routine signatures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b197e7232928483bec23ab77c22b02eb5eeb910" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt;, &lt;code&gt;reps&lt;/code&gt; is promoted to &lt;code&gt;A&lt;/code&gt;.ndim by pre-pending 1&amp;rsquo;s to it. Thus for an &lt;code&gt;A&lt;/code&gt; of shape (2, 3, 4, 5), a &lt;code&gt;reps&lt;/code&gt; of (2, 2) is treated as (1, 1, 2, 2).</source>
          <target state="translated">如果 &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt; ，则通过 &lt;code&gt;A&lt;/code&gt; 前面加上1 来将 &lt;code&gt;reps&lt;/code&gt; 提升为A.ndim。因此，对于 &lt;code&gt;A&lt;/code&gt; 形状（2，3，4，5）的，一个 &lt;code&gt;reps&lt;/code&gt; 的（2,2）被视为（1,1，2,2）。</target>
        </trans-unit>
        <trans-unit id="dbe88f61ce8f631b9b28c692a7753b41fb5fe9e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is promoted to be d-dimensional by prepending new axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication, or shape (1, 1, 3) for 3-D replication. If this is not the desired behavior, promote &lt;code&gt;A&lt;/code&gt; to d-dimensions manually before calling this function.</source>
          <target state="translated">如果 &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt; ，则通过添加新轴将 &lt;code&gt;A&lt;/code&gt; 提升为d维。因此，将形状（3，）阵列提升为（1，3）以进行2D复制，或将形状（1、1、3）提升为3D复制。如果这不是所需的行为，请在调用此函数之前手动 &lt;code&gt;A&lt;/code&gt; 提升为d维。</target>
        </trans-unit>
        <trans-unit id="7f85c71b217560bd561bde5602b4923ab34868ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, the result will contain the number of samples in each bin. If &lt;code&gt;True&lt;/code&gt;, the result is the value of the probability &lt;em&gt;density&lt;/em&gt; function at the bin, normalized such that the &lt;em&gt;integral&lt;/em&gt; over the range is 1. Note that the sum of the histogram values will not be equal to 1 unless bins of unity width are chosen; it is not a probability &lt;em&gt;mass&lt;/em&gt; function.</source>
          <target state="translated">如果为 &lt;code&gt;False&lt;/code&gt; ，则结果将包含每个bin中的样本数。如果为 &lt;code&gt;True&lt;/code&gt; ，则结果是bin处的概率&lt;em&gt;密度&lt;/em&gt;函数的值，将其标准化以使该范围内的&lt;em&gt;积分&lt;/em&gt;为1。注意，除非选择了单位宽度的bin，否则直方图值的总和将不等于1；它不是概率&lt;em&gt;质量&lt;/em&gt;函数。</target>
        </trans-unit>
        <trans-unit id="ca7cba1e4456723daee790d09bd9b4e007a0b7f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;None&lt;/code&gt; (default), all constants are assumed to be zero. If &lt;code&gt;m = 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">如果为 &lt;code&gt;None&lt;/code&gt; （默认），则所有常量均假定为零。如果 &lt;code&gt;m = 1&lt;/code&gt; ，则可以给出单个标量而不是列表。</target>
        </trans-unit>
        <trans-unit id="aec21489ec4d901f1aa321dc3743c87fb290d768" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, swap bytes in-place, default is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">如果为 &lt;code&gt;True&lt;/code&gt; ，则就地交换字节，默认值为 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2e3fbb074311bdb46e2b67afbf7fb14e162de56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, the cutoff of &lt;code&gt;precision&lt;/code&gt; digits refers to the total number of digits after the decimal point, including leading zeros. If &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;precision&lt;/code&gt; refers to the total number of significant digits, before or after the decimal point, ignoring leading zeros.</source>
          <target state="translated">如果为 &lt;code&gt;True&lt;/code&gt; ，则 &lt;code&gt;precision&lt;/code&gt; 数字的截止点是指小数点后的位数总数，包括前导零。如果为 &lt;code&gt;False&lt;/code&gt; ，则 &lt;code&gt;precision&lt;/code&gt; 是指小数点前后的有效位数总数，忽略了前导零。</target>
        </trans-unit>
        <trans-unit id="a29f76a184d9fb35f364bb63d222c84be040ac5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, then cache the first function call that determines the number of outputs if &lt;code&gt;otypes&lt;/code&gt; is not provided.</source>
          <target state="translated">如果为 &lt;code&gt;True&lt;/code&gt; ，则在未提供 &lt;code&gt;otypes&lt;/code&gt; 的情况下，缓存确定输出数量的第一个函数调用。</target>
        </trans-unit>
        <trans-unit id="7faac3985b746b05ac26d42bd00cce4fcc2669d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">如果为 &lt;code&gt;True&lt;/code&gt; ，则使用数字生成策略，该策略给出最短的表示形式，通过明​​智的舍入，可以从相同类型的其他值中唯一标识浮点数。如果省略了 &lt;code&gt;precision&lt;/code&gt; ，则打印所有必需的数字，否则在 &lt;code&gt;precision&lt;/code&gt; 数字后将切断数字生成，并将剩余值四舍五入。如果为 &lt;code&gt;False&lt;/code&gt; ，则生成数字，就好像打印一个无限精度的值并在 &lt;code&gt;precision&lt;/code&gt; 数字之后停止一样，将剩余值四舍五入。</target>
        </trans-unit>
        <trans-unit id="d46a903cfc558730b35e63368d27aca2360607f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print out all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">如果为 &lt;code&gt;True&lt;/code&gt; ，则使用数字生成策略，该策略给出最短的表示形式，通过明​​智的舍入，可以从相同类型的其他值中唯一标识浮点数。如果省略了 &lt;code&gt;precision&lt;/code&gt; ，则输出所有必需的数字，否则在 &lt;code&gt;precision&lt;/code&gt; 数字后将中断数字生成，并将剩余值四舍五入。如果为 &lt;code&gt;False&lt;/code&gt; ，则生成数字，就好像打印一个无限精度的值并在 &lt;code&gt;precision&lt;/code&gt; 数字之后停止一样，将剩余值四舍五入。</target>
        </trans-unit>
        <trans-unit id="e630a68b772e53281799a75b2daa484538be6573" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; ，则 &lt;code&gt;V&lt;/code&gt; 的列按顺序对应于形状为（xdeg + 1，ydeg + 1）的二维系数数组 &lt;code&gt;c&lt;/code&gt; 的元素</target>
        </trans-unit>
        <trans-unit id="8cbfd70f5cc4a9c80c1b3f4ac628ba80decf75d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; ，然后的列 &lt;code&gt;V&lt;/code&gt; 对应于3-d系数数组的元素 &lt;code&gt;c&lt;/code&gt; 形状（xdeg + 1的ydeg + 1，...，ZDEG + 1）按顺序</target>
        </trans-unit>
        <trans-unit id="00bfc10fc177e8c4f7b6b34693c411592fe272c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt; ，则 &lt;code&gt;V&lt;/code&gt; 的列按顺序对应于形状为（xdeg + 1，ydeg + 1）的二维系数数组 &lt;code&gt;c&lt;/code&gt; 的元素</target>
        </trans-unit>
        <trans-unit id="a7c811e070f694575d65f49ba72909eaec417a6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; ，然后的列 &lt;code&gt;V&lt;/code&gt; 对应于3-d系数数组的元素 &lt;code&gt;c&lt;/code&gt; 形状（xdeg + 1的ydeg + 1，...，ZDEG + 1）按顺序</target>
        </trans-unit>
        <trans-unit id="262fc8f05dc54d641c4705041f46d8b6c771c1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; ，则 &lt;code&gt;V&lt;/code&gt; 的列按顺序对应于形状为（xdeg + 1，ydeg + 1）的二维系数数组 &lt;code&gt;c&lt;/code&gt; 的元素</target>
        </trans-unit>
        <trans-unit id="066ad3b1f4c835bc91d8b4d1ca954772c0457a46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; ，然后的列 &lt;code&gt;V&lt;/code&gt; 对应于3-d系数数组的元素 &lt;code&gt;c&lt;/code&gt; 形状（xdeg + 1的ydeg + 1，...，ZDEG + 1）按顺序</target>
        </trans-unit>
        <trans-unit id="6596fc02b05eb1b57c388bcee28f45c0fa647e79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; ，则 &lt;code&gt;V&lt;/code&gt; 的列按顺序对应于形状为（xdeg + 1，ydeg + 1）的二维系数数组 &lt;code&gt;c&lt;/code&gt; 的元素</target>
        </trans-unit>
        <trans-unit id="658f3ceb580a0341f1c8e14be933e5829c9b95b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; ，然后的列 &lt;code&gt;V&lt;/code&gt; 对应于3-d系数阵列的元件 &lt;code&gt;c&lt;/code&gt; 形状的（xdeg + 1，ydeg + 1，ZDEG + 1）按顺序</target>
        </trans-unit>
        <trans-unit id="102bddd53317314797d80d0b03e0de44ee8eec62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; ，则 &lt;code&gt;V&lt;/code&gt; 的列按顺序对应于形状为（xdeg + 1，ydeg + 1）的二维系数数组 &lt;code&gt;c&lt;/code&gt; 的元素</target>
        </trans-unit>
        <trans-unit id="f9e4383801f2b61b08f9300b1b7fdf17e1c3f488" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; ，然后的列 &lt;code&gt;V&lt;/code&gt; 对应于3-d系数阵列的元件 &lt;code&gt;c&lt;/code&gt; 形状的（xdeg + 1，ydeg + 1，ZDEG + 1）按顺序</target>
        </trans-unit>
        <trans-unit id="c691cf5dd3bcc26326919122a716b1456743d83e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; ，则 &lt;code&gt;V&lt;/code&gt; 的列按顺序对应于形状为（xdeg + 1，ydeg + 1）的二维系数数组 &lt;code&gt;c&lt;/code&gt; 的元素</target>
        </trans-unit>
        <trans-unit id="3795a0fc387856e1a4fb9463ff23e8e2dc033c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; ，然后的列 &lt;code&gt;V&lt;/code&gt; 对应于3-d系数数组的元素 &lt;code&gt;c&lt;/code&gt; 形状（xdeg + 1的ydeg + 1，...，ZDEG + 1）按顺序</target>
        </trans-unit>
        <trans-unit id="f8959bef2f1f180cd1904ca3003b3eeaecf0bbcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt;, return the fill value, otherwise return None.</source>
          <target state="translated">如果 &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt; ，则返回填充值，否则返回None。</target>
        </trans-unit>
        <trans-unit id="8f6e1a60280ed3603677c79dbcdebfa7ff398c42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt;, then the dimensions specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are removed, and a new axis inserted at the end corresponding to the diagonal.</source>
          <target state="translated">如果 &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; ，则将删除由 &lt;code&gt;axis1&lt;/code&gt; 和 &lt;code&gt;axis2&lt;/code&gt; 指定的尺寸，并在与对角线相对应的一端插入新的轴。</target>
        </trans-unit>
        <trans-unit id="64c4131bb0fe8a413fc2bc1ebe219f3e36ea1e9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim&lt;/code&gt; is 0, then since the depth of the nested list is 0, it will not be a list at all, but a simple Python scalar.</source>
          <target state="translated">如果 &lt;code&gt;a.ndim&lt;/code&gt; 为0，则由于嵌套列表的深度为0，因此它根本不是列表，而是简单的Python标量。</target>
        </trans-unit>
        <trans-unit id="355d7bac3059f5072f60fecea5ae0b7d9ef0b74d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.shape&lt;/code&gt; is (5,1), &lt;code&gt;b.shape&lt;/code&gt; is (1,6), &lt;code&gt;c.shape&lt;/code&gt; is (6,) and &lt;code&gt;d.shape&lt;/code&gt; is () so that &lt;em&gt;d&lt;/em&gt; is a scalar, then &lt;em&gt;a&lt;/em&gt;, &lt;em&gt;b&lt;/em&gt;, &lt;em&gt;c&lt;/em&gt;, and &lt;em&gt;d&lt;/em&gt; are all broadcastable to dimension (5,6); and</source>
          <target state="translated">如果 &lt;code&gt;a.shape&lt;/code&gt; 为（5,1）， &lt;code&gt;b.shape&lt;/code&gt; 为（1,6）， &lt;code&gt;c.shape&lt;/code&gt; 为（6，）和 &lt;code&gt;d.shape&lt;/code&gt; 为（）使得&lt;em&gt;d&lt;/em&gt;为标量，则&lt;em&gt;a&lt;/em&gt;，&lt;em&gt;b&lt;/em&gt;，&lt;em&gt;c&lt;/em&gt;，和&lt;em&gt;d&lt;/em&gt;都可广播至维度（5,6）；和</target>
        </trans-unit>
        <trans-unit id="61914428b3107b079ee31cfc27e080d8a722c6a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are nonscalar, their last dimensions must match.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 是非标量的，则它们的最后尺寸必须匹配。</target>
        </trans-unit>
        <trans-unit id="b4f4e526a35a19438379df1f3dbff9a3882d194d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and each choice array are not all broadcastable to the same shape.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 和每一个选择阵列是不是所有broadcastable到相同的形状。</target>
        </trans-unit>
        <trans-unit id="6714bc3434562dda36e8035d926f1d408c7a5936" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; does not own its own data or references or views to it exist, and the data memory must be changed. PyPy only: will always raise if the data memory must be changed, since there is no reliable way to determine if references or views to it exist.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 不拥有自己的数据或存在对其的引用或视图，则必须更改数据存储器。仅限于PyPy：如果必须更改数据存储器，将始终升高，因为没有可靠的方法来确定是否存在对其的引用或视图。</target>
        </trans-unit>
        <trans-unit id="d46ad13c1a8181bf81ec49d29f19d0a4e8222929" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then broadcasting rules apply, as explained in &lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;Linear algebra on several matrices at once&lt;/a&gt;. This means that SVD is working in &amp;ldquo;stacked&amp;rdquo; mode: it iterates over all indices of the first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions and for each combination SVD is applied to the last two indices. The matrix &lt;code&gt;a&lt;/code&gt; can be reconstructed from the decomposition with either &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; or &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt;. (The &lt;code&gt;@&lt;/code&gt; operator can be replaced by the function &lt;code&gt;np.matmul&lt;/code&gt; for python versions below 3.5.)</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 具有两个以上的维，则适用广播规则，如&lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;一次线性代数在多个矩阵上所述&lt;/a&gt;。这意味着SVD在&amp;ldquo;堆叠&amp;rdquo;模式下工作：迭代第一个 &lt;code&gt;a.ndim - 2&lt;/code&gt; 维的所有索引，并且对于每种组合，SVD应用于最后两个索引。可以使用 &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; 或 &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt; 从分解中重建矩阵 &lt;code&gt;a&lt;/code&gt; 。 （对于3.5以下的python版本， &lt;code&gt;@&lt;/code&gt; 运算符可以由 &lt;code&gt;np.matmul&lt;/code&gt; 函数代替。）</target>
        </trans-unit>
        <trans-unit id="0f5e97c2878caebdac54716045091816869ce6d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by axis1 and axis2 are used to determine the 2-D sub-arrays whose traces are returned. The shape of the resulting array is the same as that of &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; removed.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 具有两个以上的维，则使用axis1和axis2指定的轴来确定要返回其迹线的2-D子数组。所得数组的形状与除去了 &lt;code&gt;axis1&lt;/code&gt; 和 &lt;code&gt;axis2&lt;/code&gt; 的 &lt;code&gt;a&lt;/code&gt; 的形状相同。</target>
        </trans-unit>
        <trans-unit id="1b46ead587370435670ac4bc03b81d9c95e42b33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 1-D, the function &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; is the same as &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; where &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;range(len(array) - 1)&lt;/code&gt; with a zero placed in every other element: &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt;, &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是1-d，函数 &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; 是相同的 &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; ，其中&lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt;是 &lt;code&gt;range(len(array) - 1)&lt;/code&gt; 具有零放置在每其他元素： &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt; ， &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b8db921b8261a5150c028a4a52e2a78422e254b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, returns the diagonal of &lt;code&gt;a&lt;/code&gt; with the given offset, i.e., the collection of elements of the form &lt;code&gt;a[i, i+offset]&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are used to determine the 2-D sub-array whose diagonal is returned. The shape of the resulting array can be determined by removing &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; and appending an index to the right equal to the size of the resulting diagonals.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是2-D，则返回给定偏移量 &lt;code&gt;a&lt;/code&gt; 的对角线，即，形式为 &lt;code&gt;a[i, i+offset]&lt;/code&gt; 的元素的集合。如果 &lt;code&gt;a&lt;/code&gt; 具有两个以上的维，则使用 &lt;code&gt;axis1&lt;/code&gt; 和 &lt;code&gt;axis2&lt;/code&gt; 指定的轴来确定返回对角线的2-D子数组。可以通过删除 &lt;code&gt;axis1&lt;/code&gt; 和 &lt;code&gt;axis2&lt;/code&gt; 并在右边添加一个等于所得对角线大小的索引来确定所得数组的形状。</target>
        </trans-unit>
        <trans-unit id="016f6a15e05ea7909f939f7c56abdd96bd940bcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along its diagonal with the given offset is returned, i.e., the sum of elements &lt;code&gt;a[i,i+offset]&lt;/code&gt; for all i.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 为2-D，则返回沿其对角线具有给定偏移的和，即，所有i 的元素 &lt;code&gt;a[i,i+offset]&lt;/code&gt; 和。</target>
        </trans-unit>
        <trans-unit id="821330dbafd930ef241f18ef291a677b001e3d1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along the diagonal is returned. If &lt;code&gt;a&lt;/code&gt; has larger dimensions, then an array of sums along diagonals is returned.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 为二维，则返回沿对角线的总和。如果 &lt;code&gt;a&lt;/code&gt; 的尺寸较大，则返回沿对角线的总和数组。</target>
        </trans-unit>
        <trans-unit id="20e0991e165d15052f7414c1d9067709a6741ba8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, then a 1-D array containing the diagonal and of the same type as &lt;code&gt;a&lt;/code&gt; is returned unless &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, in which case a 1-D array rather than a (2-D) &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; is returned in order to maintain backward compatibility.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是2- d，然后将含有对角线和一个1-d阵列作为相同类型的 &lt;code&gt;a&lt;/code&gt; 被返回，除非 &lt;code&gt;a&lt;/code&gt; 是一个&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;在这种情况下，1-d阵列而不是一个（2-d），&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;被返回为了保持向后兼容。</target>
        </trans-unit>
        <trans-unit id="65772464bb82fc9b6e011b51f1c71a9673e3a5fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;matrix&lt;/code&gt; object (as opposed to an &lt;code&gt;ndarray&lt;/code&gt;), then so are all the return values.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是一个 &lt;code&gt;matrix&lt;/code&gt; 对象（与 &lt;code&gt;ndarray&lt;/code&gt; 相对），那么所有返回值也是如此。</target>
        </trans-unit>
        <trans-unit id="cea4b92a7534a3149383f752281c310050f705b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a reference to &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;(a is b) == True&lt;/code&gt;. Therefore, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are different names for the same Python object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edeed84f3c81e9ebf31ecd438474825302f801e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a subclass of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, its class is conserved. No copy is performed if the input is already an &lt;code&gt;ndarray&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;的子类，则其类是保守的。如果输入已经是 &lt;code&gt;ndarray&lt;/code&gt; ,则不执行复制。</target>
        </trans-unit>
        <trans-unit id="79b3d97ca6a58beeb5178bade7556181ec643eb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is a 1-D array, it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是ND数组， &lt;code&gt;b&lt;/code&gt; 是1-D数组，则它是 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的最后一个轴的总和。</target>
        </trans-unit>
        <trans-unit id="41bd115d2530c0df6f893d58055a4e7bbeb51a86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is an M-D array (where &lt;code&gt;M&amp;gt;=2&lt;/code&gt;), it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and the second-to-last axis of &lt;code&gt;b&lt;/code&gt;:</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是一个ND阵列和 &lt;code&gt;b&lt;/code&gt; 是MD阵列（其中， &lt;code&gt;M&amp;gt;=2&lt;/code&gt; ），这是在最后一个轴和积 &lt;code&gt;a&lt;/code&gt; 和第二到最后一个的轴 &lt;code&gt;b&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e2d3d6c358f256f08097a63c0a16dbce473bc638" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is complex the complex conjugate is taken before calculation of the dot product.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是复数，则在计算点积之前采用复共轭。</target>
        </trans-unit>
        <trans-unit id="eccde6fba477d4d0328834eeb9139f4c209a7f8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;a&lt;/code&gt; itself is returned. If &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fill_value&lt;/code&gt; is None, &lt;code&gt;fill_value&lt;/code&gt; is set to &lt;code&gt;a.fill_value&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 不是&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;，则返回 &lt;code&gt;a&lt;/code&gt; 本身。如果 &lt;code&gt;a&lt;/code&gt; 为&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;并且 &lt;code&gt;fill_value&lt;/code&gt; 为None，则 &lt;code&gt;fill_value&lt;/code&gt; 设置为 &lt;code&gt;a.fill_value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ac306a4eb2b5b20798f61a7b119dddd329017ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not square or inversion fails.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 不是正方形或反转失败。</target>
        </trans-unit>
        <trans-unit id="dc36615c1be692990452f6adc2c02bec7979d9d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is real, the type of &lt;code&gt;a&lt;/code&gt; is used for the output. If &lt;code&gt;a&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是真实的类型， &lt;code&gt;a&lt;/code&gt; 用于输出。如果 &lt;code&gt;a&lt;/code&gt; 具有复杂元素，则返回的类型为float。</target>
        </trans-unit>
        <trans-unit id="49742c1cee8e9efafb1c7fbbe431a8e95469bbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not &amp;lsquo;square&amp;rsquo; (in the above sense).</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是单数或不是&amp;ldquo;方形&amp;rdquo;（在上述的意义上）。</target>
        </trans-unit>
        <trans-unit id="2e9b74892f6f35d0326c1dc235300557d874f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not square.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 为奇数或非正方形。</target>
        </trans-unit>
        <trans-unit id="ceece9b2545779310cb6355ec10529e551268898" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=False&lt;/code&gt;, this method produces a &amp;ldquo;packed&amp;rdquo; memory layout in which each field starts at the byte the previous field ended, and any padding bytes are removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="460932656f30d1ee879c1ced09e2eca3e1ff623d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=True&lt;/code&gt; is set, numpy will pad the structure in the same way many C compilers would pad a C-struct. Aligned structures can give a performance improvement in some cases, at the cost of increased datatype size. Padding bytes are inserted between fields such that each field&amp;rsquo;s byte offset will be a multiple of that field&amp;rsquo;s alignment, which is usually equal to the field&amp;rsquo;s size in bytes for simple datatypes, see &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr.alignment&quot;&gt;&lt;code&gt;PyArray_Descr.alignment&lt;/code&gt;&lt;/a&gt;. The structure will also have trailing padding added so that its itemsize is a multiple of the largest field&amp;rsquo;s alignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b8c190caa583967ef3d50f42e6abb370b98e8c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=True&lt;/code&gt;, this methods produces an &amp;ldquo;aligned&amp;rdquo; memory layout in which each field&amp;rsquo;s offset is a multiple of its alignment, and the total itemsize is a multiple of the largest alignment, by adding padding bytes as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f554f1ca3b0160e94e964322795aa916ef0365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr&lt;/code&gt; doesn&amp;rsquo;t have a shape attribute (i.e. not an ndarray)</source>
          <target state="translated">如果 &lt;code&gt;arr&lt;/code&gt; 没有shape属性（即不是ndarray）</target>
        </trans-unit>
        <trans-unit id="6f94c014869b41cb6e3e090bab6cec3fc3652e46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axes&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;axes&lt;/code&gt; 大于 &lt;code&gt;a&lt;/code&gt; 的最后一个轴。</target>
        </trans-unit>
        <trans-unit id="fb5967cac1f9c838f629289b9701f4f5d967c63e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 0, only rows are masked.</source>
          <target state="translated">如果 &lt;code&gt;axis&lt;/code&gt; 为0，则仅屏蔽行。</target>
        </trans-unit>
        <trans-unit id="e77d1c339b65acf6a89a949d1d50328c8561be33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 1 or -1, only columns are masked.</source>
          <target state="translated">如果 &lt;code&gt;axis&lt;/code&gt; 为1或-1，则仅掩盖列。</target>
        </trans-unit>
        <trans-unit id="527dba2aee917b7e820a9015382f439872829fc2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, rows &lt;em&gt;and&lt;/em&gt; columns are masked.</source>
          <target state="translated">如果 &lt;code&gt;axis&lt;/code&gt; 为None，则将屏蔽行&lt;em&gt;和&lt;/em&gt;列。</target>
        </trans-unit>
        <trans-unit id="1c5e761c4a44d3d8422fc68aeed03dd9853a0a7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, the result is a scalar. Otherwise, if &lt;code&gt;axis&lt;/code&gt; is given and the array is at least 2-D, the result is a masked array with dimension one smaller than the array on which &lt;a href=&quot;#numpy.ma.masked_array.mini&quot;&gt;&lt;code&gt;mini&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042bc001a4914cd7d0d232c6f0fb346989909740" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is an integer, it specifies the axis of &lt;code&gt;x&lt;/code&gt; along which to compute the vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If &lt;code&gt;axis&lt;/code&gt; is None then either a vector norm (when &lt;code&gt;x&lt;/code&gt; is 1-D) or a matrix norm (when &lt;code&gt;x&lt;/code&gt; is 2-D) is returned.</source>
          <target state="translated">如果 &lt;code&gt;axis&lt;/code&gt; 是整数，则它指定 &lt;code&gt;x&lt;/code&gt; 的轴，沿着该轴计算矢量范数。如果 &lt;code&gt;axis&lt;/code&gt; 是2元组，则它指定保存2D矩阵的轴，并计算这些矩阵的矩阵范数。如果 &lt;code&gt;axis&lt;/code&gt; 为None，则返回向量范数（当 &lt;code&gt;x&lt;/code&gt; 为1-D时）或矩阵范数（当 &lt;code&gt;x&lt;/code&gt; 为2-D时）。</target>
        </trans-unit>
        <trans-unit id="bfadfc7eb4a4188168e39022bbb71c1c25d02efa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is an integer, it specifies the axis of &lt;code&gt;x&lt;/code&gt; along which to compute the vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If &lt;code&gt;axis&lt;/code&gt; is None then either a vector norm (when &lt;code&gt;x&lt;/code&gt; is 1-D) or a matrix norm (when &lt;code&gt;x&lt;/code&gt; is 2-D) is returned. The default is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523d86ecb59b40a9d925f2a1e78fa6cb76926a2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is given, the number of varargs must equal the number of axes. Default: 1.</source>
          <target state="translated">如果给定 &lt;code&gt;axis&lt;/code&gt; ，则可变参数的数量必须等于轴的数量。默认值：1。</target>
        </trans-unit>
        <trans-unit id="86e33ec8c24f94e2430b0659a5ab81a91a91d564" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;axis&lt;/code&gt; 大于 &lt;code&gt;a&lt;/code&gt; 的最后一个轴。</target>
        </trans-unit>
        <trans-unit id="b10999639108c4b4999de59d1e8da7d5676f431c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, and an axis being squeezed is not of length 1</source>
          <target state="translated">如果 &lt;code&gt;axis&lt;/code&gt; 不为 &lt;code&gt;None&lt;/code&gt; ，并且被压缩的轴的长度不为1</target>
        </trans-unit>
        <trans-unit id="048ac1275e643db0f79c87e34405c76349afe0b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not None, and an axis being squeezed is not of length 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e5f5a4f466db64bba565371ecaf3c0accbb2cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b = a[:100]&lt;/code&gt; is used instead, &lt;code&gt;a&lt;/code&gt; is referenced by &lt;code&gt;b&lt;/code&gt; and will persist in memory even if &lt;code&gt;del a&lt;/code&gt; is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ba1d797cf86b71e14a5b8da31b21199908a909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is a matrix, then all array results are returned as matrices.</source>
          <target state="translated">如果 &lt;code&gt;b&lt;/code&gt; 是矩阵，则所有数组结果都作为矩阵返回。</target>
        </trans-unit>
        <trans-unit id="ca0b482dcb07a6085a21a5bc1b0dde224b2f172c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string from the list below, &lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt; will use the method chosen to calculate the optimal bin width and consequently the number of bins (see &lt;code&gt;Notes&lt;/code&gt; for more detail on the estimators) from the data that falls within the requested range. While the bin width will be optimal for the actual data in the range, the number of bins will be computed to fill the entire range, including the empty portions. For visualisation, using the &amp;lsquo;auto&amp;rsquo; option is suggested. Weighted data is not supported for automated bin size selection.</source>
          <target state="translated">如果 &lt;code&gt;bins&lt;/code&gt; 是下面列表中的字符串，则&lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; &lt;/a&gt;将使用选择的方法来计算最佳bin宽度，从而从落入请求范围内的数据计算出bin的数量（有关估计量的更多信息，请参见&amp;ldquo; &lt;code&gt;Notes&lt;/code&gt; &amp;rdquo;）。虽然仓宽对于该范围内的实际数据而言是最佳的，但是仓数将被计算为填充整个范围，包括空白部分。为了可视化，建议使用&amp;ldquo;自动&amp;rdquo;选项。自动箱大小选择不支持加权数据。</target>
        </trans-unit>
        <trans-unit id="b70a91ff0eb4c89d18a81d985f393eb13ac7933f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string, it defines the method used to calculate the optimal bin width, as defined by &lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;bins&lt;/code&gt; 是字符串，则它定义用于计算最佳bin宽度的方法，如&lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; &lt;/a&gt;所定义。</target>
        </trans-unit>
        <trans-unit id="cbffbf31546ec9af5b6fd778dfc3e0a7e49fc75c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">如果 &lt;code&gt;bins&lt;/code&gt; 是一个int，则它定义给定范围内的等宽垃圾箱数（默认为10个）。如果 &lt;code&gt;bins&lt;/code&gt; 是序列，则它将定义bin边缘（包括最右边）的单调递增数组，从而允许非均匀的bin宽度。</target>
        </trans-unit>
        <trans-unit id="b4024bb04b779936a7803a2173c03bd8c96f6ec1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines the bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">如果 &lt;code&gt;bins&lt;/code&gt; 是一个int，则它定义给定范围内的等宽垃圾箱数（默认为10个）。如果 &lt;code&gt;bins&lt;/code&gt; 是序列，则它将定义bin边缘（包括最右边），从而允许非均匀的bin宽度。</target>
        </trans-unit>
        <trans-unit id="f3d0d1457dc2c27ebf07eb8b8d37fdfe4b5b5f86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is not monotonic.</source>
          <target state="translated">如果 &lt;code&gt;bins&lt;/code&gt; 不是单调的。</target>
        </trans-unit>
        <trans-unit id="f1d57ef4cb7d5156a4314b6ea06d7045fe52a5fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is None, then only &lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;order&lt;/code&gt; are used.</source>
          <target state="translated">如果 &lt;code&gt;buffer&lt;/code&gt; 为None，则仅使用&lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb00c687c7393dfd8dae48855df788062a7f7eb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is None, then only &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;order&lt;/code&gt; are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f34c748ade1a438e4af494b9939bb52d6b65ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is an object exposing the buffer interface, then all keywords are interpreted.</source>
          <target state="translated">如果 &lt;code&gt;buffer&lt;/code&gt; 是暴露buffer接口的对象，则将解释所有关键字。</target>
        </trans-unit>
        <trans-unit id="f67df360e18cb83b99203eea7e5b2b66896eaba4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffersize&lt;/code&gt; is zero, a default buffer size is used, otherwise it specifies how big of a buffer to use. Buffers which are powers of 2 such as 4096 or 8192 are recommended.</source>
          <target state="translated">如果 &lt;code&gt;buffersize&lt;/code&gt; 为零，则使用默认的缓冲区大小，否则它指定要使用的缓冲区大小。建议使用2的幂的缓冲区，例如4096或8192。</target>
        </trans-unit>
        <trans-unit id="beb58b828353ed80b8e0bbe892a75cbfcebae43d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than 3 dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 的尺寸少于3个，则将其隐式附加到其形状以使其成为3D。结果的形状将为c.shape [3：] + x.shape。</target>
        </trans-unit>
        <trans-unit id="f7c13f789159cee3609188e9f6918f23db3edd6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than three dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape + y.shape + z.shape.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 的尺寸少于三个，则将其隐式附加到其形状以使其成为3-D。结果的形状将为c.shape [3：] + x.shape + y.shape + z.shape。</target>
        </trans-unit>
        <trans-unit id="210c7187323274ff624491c071d18c59ba05eaa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape + y.shape.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 的尺寸少于二维，则将其隐式附加到其形状以使其成为二维。结果的形状将为c.shape [2：] + x.shape + y.shape。</target>
        </trans-unit>
        <trans-unit id="4b9c82b7f7444c244d3d87499e2e6abb52d1e818" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 的尺寸少于二维，则将其隐式附加到其形状以使其成为二维。结果的形状将为c.shape [2：] + x.shape。</target>
        </trans-unit>
        <trans-unit id="b813783672e3b8b110dcc3caed6943e29c499cf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array a one is implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是一维数组，则将其隐式附加到其形状以使其成为二维数组。结果的形状将为c.shape [2：] + x.shape。</target>
        </trans-unit>
        <trans-unit id="9b697950a550c5d2ac6bfd1a90d0ee0cf3873621" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermevander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermeval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of HermiteE series of the same degree and sample points.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是系数为 &lt;code&gt;n + 1&lt;/code&gt; 的一维数组，而 &lt;code&gt;V&lt;/code&gt; 是数组 &lt;code&gt;V = hermevander(x, n)&lt;/code&gt; ，则 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 和 &lt;code&gt;hermeval(x, c)&lt;/code&gt; 相同，直到四舍五入。这种等效性对于最小二乘拟合和评估相同程度和采样点的大量HermiteE系列都是有用的。</target>
        </trans-unit>
        <trans-unit id="8795163ae21f93104b677b1ca18c8738fd9a209a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Hermite series of the same degree and sample points.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是系数为 &lt;code&gt;n + 1&lt;/code&gt; 的一维数组，而 &lt;code&gt;V&lt;/code&gt; 是数组 &lt;code&gt;V = hermvander(x, n)&lt;/code&gt; ，则 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 和 &lt;code&gt;hermval(x, c)&lt;/code&gt; 相同，直到四舍五入。这种等效性对于最小二乘拟合和评估相同程度和采样点的大量Hermite级数都是有用的。</target>
        </trans-unit>
        <trans-unit id="41e4b417db13b3be059bf5b8693dedddbf2d39c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = lagvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;lagval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Laguerre series of the same degree and sample points.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是系数为 &lt;code&gt;n + 1&lt;/code&gt; 的一维数组，而 &lt;code&gt;V&lt;/code&gt; 是数组 &lt;code&gt;V = lagvander(x, n)&lt;/code&gt; ，则 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 和 &lt;code&gt;lagval(x, c)&lt;/code&gt; 相同，直到四舍五入。这种等效性对于最小二乘拟合以及对相同度数和采样点的大量Laguerre级数的评估都是有用的。</target>
        </trans-unit>
        <trans-unit id="a1b597f29a3697113f705d9c197e77e09839d912" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = legvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;legval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Legendre series of the same degree and sample points.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是系数为 &lt;code&gt;n + 1&lt;/code&gt; 的一维数组，而 &lt;code&gt;V&lt;/code&gt; 是数组 &lt;code&gt;V = legvander(x, n)&lt;/code&gt; ，则 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 和 &lt;code&gt;legval(x, c)&lt;/code&gt; 相同，直到四舍五入。这种等效性对于最小二乘拟合以及对相同程度和采样点的大量Legendre级数的评估都是有用的。</target>
        </trans-unit>
        <trans-unit id="b7f0c7e082f8807f04eefbe2acbae592bdec65ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = chebvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;chebval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Chebyshev series of the same degree and sample points.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是系数为 &lt;code&gt;n + 1&lt;/code&gt; 的一维数组，并且 &lt;code&gt;V&lt;/code&gt; 是矩阵 &lt;code&gt;V = chebvander(x, n)&lt;/code&gt; ，则 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 和 &lt;code&gt;chebval(x, c)&lt;/code&gt; 相同，直到四舍五入。这种等效性对于最小二乘拟合以及对相同程度和采样点的大量Chebyshev级数的评估都是有用的。</target>
        </trans-unit>
        <trans-unit id="4e382928aa8d32a6b35f8adca3a6cffe61170326" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = polyvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;polyval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of polynomials of the same degree and sample points.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是系数为 &lt;code&gt;n + 1&lt;/code&gt; 的一维数组，并且 &lt;code&gt;V&lt;/code&gt; 是矩阵 &lt;code&gt;V = polyvander(x, n)&lt;/code&gt; ，则 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 和 &lt;code&gt;polyval(x, c)&lt;/code&gt; 相同，直到四舍五入。这种等效性对于最小二乘拟合以及对相同度数和采样点的大量多项式的评估都是有用的。</target>
        </trans-unit>
        <trans-unit id="8e80660168c2556d80131aae5098ce463a202c8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is true the shape will be c.shape[1:] + x.shape. If &lt;code&gt;tensor&lt;/code&gt; is false the shape will be c.shape[1:]. Note that scalars have shape (,).</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是一维数组，则 &lt;code&gt;p(x)&lt;/code&gt; 将具有与 &lt;code&gt;x&lt;/code&gt; 相同的形状。如果 &lt;code&gt;c&lt;/code&gt; 是多维的，则结果的形状取决于 &lt;code&gt;tensor&lt;/code&gt; 的值。如果 &lt;code&gt;tensor&lt;/code&gt; 为真，则形状将为c.shape [1：] + x.shape。如果 &lt;code&gt;tensor&lt;/code&gt; 为假，则形状将为c.shape [1：]。请注意，标量具有形状（，）。</target>
        </trans-unit>
        <trans-unit id="0a3728daa3b2e189e758d347ca0d72357650db3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 的长度为 &lt;code&gt;n + 1&lt;/code&gt; ，则此函数返回值</target>
        </trans-unit>
        <trans-unit id="e3ad7dc6a355dfc8a1c8aa46843f5488897fd4ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value:</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 的长度为 &lt;code&gt;n + 1&lt;/code&gt; ，则此函数返回值：</target>
        </trans-unit>
        <trans-unit id="6a970efb45caa036763049ac1a92ee21b5440b3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;check(..)&lt;/code&gt; is not used then F2PY generates few standard checks (e.g. in a case of an array argument, check for the proper shape and size) automatically. Use &lt;code&gt;check()&lt;/code&gt; to disable checks generated by F2PY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce30f3388eee45516fb0d109b2a57581be93d2fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cmp_op&lt;/code&gt; is not valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3791f18c578dee37c08b1f05312986ce4a1234a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;condition&lt;/code&gt; is boolean:</source>
          <target state="translated">如果 &lt;code&gt;condition&lt;/code&gt; 为布尔值：</target>
        </trans-unit>
        <trans-unit id="945ce76f24a4c673d6aa37d9ae7569a5f68abd37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is provided, it must stay alive for the life of the array. One way to manage this is through &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">如果提供了 &lt;code&gt;data&lt;/code&gt; ，则该数据必须在阵列的生命周期内保持有效。一种管理方法是通过&lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58463c629975ec8a9511dbc013fc3e05064ff197" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;device&lt;/code&gt; does not have a &lt;code&gt;write()&lt;/code&gt; or &lt;code&gt;flush()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799e69512e3ae47752ad1a4389491bce54790cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb15e22b2a7d43231c255a7fc2569fdb2ab36892" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68051abdc74ce34a8cd57f65aadeda23f8c9fb89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, then it requires that data type. If copying is allowed, it will make a temporary copy if the data is castable. If &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; is enabled, it will also copy the data back with another cast upon iterator destruction.</source>
          <target state="translated">如果 &lt;code&gt;dtype&lt;/code&gt; 不为 &lt;code&gt;NULL&lt;/code&gt; ，则它需要该数据类型。如果允许复制，则在数据可转换时将进行临时复制。如果启用了&lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;，它还将在销毁迭代器时将数据复制回另一个强制类型。</target>
        </trans-unit>
        <trans-unit id="760548f2e1b1246d013e160a44370e64f44dc286" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enddates&lt;/code&gt; specifies a date value that is earlier than the corresponding &lt;code&gt;begindates&lt;/code&gt; date value, the count will be negative.</source>
          <target state="translated">如果 &lt;code&gt;enddates&lt;/code&gt; 指定的日期值早于相应的 &lt;code&gt;begindates&lt;/code&gt; 日期值，则该计数为负数。</target>
        </trans-unit>
        <trans-unit id="417859000cee8d29cc7044346e37933b08a0f1c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fieldname&lt;/code&gt; is the empty string &lt;code&gt;''&lt;/code&gt;, the field will be given a default name of the form &lt;code&gt;f#&lt;/code&gt;, where &lt;code&gt;#&lt;/code&gt; is the integer index of the field, counting from 0 from the left:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2d55579b57bf31daf1f1c848f07e4ba4a33873" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fortranname&lt;/code&gt; statement is used without &lt;code&gt;&amp;lt;actual Fortran/C routine name&amp;gt;&lt;/code&gt; then a dummy wrapper is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4a6b4dd2e4a7b67147341a42f6c8197722c973" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is a 1-D array of sorted integers, the entries indicate where along &lt;code&gt;axis&lt;/code&gt; the array is split. For example, &lt;code&gt;[2, 3]&lt;/code&gt; would, for &lt;code&gt;axis=0&lt;/code&gt;, result in</source>
          <target state="translated">如果 &lt;code&gt;indices_or_sections&lt;/code&gt; 是一维排序的整数数组，则条目指示沿 &lt;code&gt;axis&lt;/code&gt; 在哪里拆分该数组。例如，对于 &lt;code&gt;axis=0&lt;/code&gt; ， &lt;code&gt;[2, 3]&lt;/code&gt; 将导致</target>
        </trans-unit>
        <trans-unit id="750e535a910db315f0680626cd7e38f07dd476ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is an integer, N, the array will be divided into N equal arrays along &lt;code&gt;axis&lt;/code&gt;. If such a split is not possible, an error is raised.</source>
          <target state="translated">如果 &lt;code&gt;indices_or_sections&lt;/code&gt; 是整数N，则该数组将沿 &lt;code&gt;axis&lt;/code&gt; 分为N个相等的数组。如果无法进行此类拆分，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="c2fbdd32f871ea7c6656b8280d919dff6251170e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is given as an integer, but a split does not result in equal division.</source>
          <target state="translated">如果 &lt;code&gt;indices_or_sections&lt;/code&gt; 是整数，但是分割不会导致相等的除法。</target>
        </trans-unit>
        <trans-unit id="64c4e0e507acd8c3f4b71cfa7cf2cf1d38b76639" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;intent(c)&lt;/code&gt; is used as a statement but without an entity declaration list, then F2PY adds the &lt;code&gt;intent(c)&lt;/code&gt; attribute to all arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="820239142587f3701cc156b154b6624dd5007ecf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;intent(copy)&lt;/code&gt; or &lt;code&gt;intent(overwrite)&lt;/code&gt; is used, then an additional optional argument is introduced with a name &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; and a default value 0 or 1, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c296e3258dbc49519e8602388ede880a24772142" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k &amp;gt; l&lt;/code&gt;, then only &lt;code&gt;x_1, ..., x_l&lt;/code&gt; are set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="271207c6144fe7ced9054709b41446a9de60c700" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k &amp;lt; l&lt;/code&gt;, then &lt;code&gt;y_{k + 1}, ..., y_l&lt;/code&gt; are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99e0454406f9add7ef291687419a1330612a513" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;legacy&lt;/code&gt; is False, or the BitGenerator is not MT19937, then state is returned as a dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce1a7ad82e3cfecd360d23c388ed9b15e3542af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;legacy&lt;/code&gt; is False, or the BitGenerator is not NT19937, then state is returned as a dictionary.</source>
          <target state="translated">如果 &lt;code&gt;legacy&lt;/code&gt; 为False，或者BitGenerator不是NT19937，则状态作为字典返回。</target>
        </trans-unit>
        <trans-unit id="146abcde4c240659f226130b295dbaf50c55deac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 0&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;m &amp;lt; 0&lt;/code&gt; ， &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; ， &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; 或 &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c2df004cd887df3e646568cfffdf17b3ac0ffbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 1&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;m &amp;lt; 1&lt;/code&gt; ， &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; ， &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; 或 &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e220ffcadc52e486b28727579ddc1e86ad96fbcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; have different flexible dtypes.</source>
          <target state="translated">如果 &lt;code&gt;m1&lt;/code&gt; 和 &lt;code&gt;m2&lt;/code&gt; 具有不同的灵活dtype。</target>
        </trans-unit>
        <trans-unit id="0cda2eb48aaf0ad93b34e30066de3169d0688cac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m&lt;/code&gt; has a single column then that column is returned as the single row of a matrix. Otherwise &lt;code&gt;m&lt;/code&gt; is returned. The returned matrix is always either &lt;code&gt;m&lt;/code&gt; itself or a view into &lt;code&gt;m&lt;/code&gt;. Supplying an axis keyword argument will not affect the returned matrix but it may cause an error to be raised.</source>
          <target state="translated">如果 &lt;code&gt;m&lt;/code&gt; 具有单个列，则该列将作为矩阵的单个行返回。否则，返回 &lt;code&gt;m&lt;/code&gt; 。返回的矩阵始终为 &lt;code&gt;m&lt;/code&gt; 本身或看到 &lt;code&gt;m&lt;/code&gt; 。提供axis关键字参数不会影响返回的矩阵，但可能会引起错误。</target>
        </trans-unit>
        <trans-unit id="d089e6b20e99bc8aa35211116381511548d1fc6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done, the rightmost ones.</source>
          <target state="translated">如果给出了 &lt;code&gt;maxsplit&lt;/code&gt; ,则最多完成 &lt;code&gt;maxsplit&lt;/code&gt; 拆分，最右边的拆分完成。</target>
        </trans-unit>
        <trans-unit id="f3a2beabba4d5e799494083ff0f67c424eaf8432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done.</source>
          <target state="translated">如果给出 &lt;code&gt;maxsplit&lt;/code&gt; ,则最多完成 &lt;code&gt;maxsplit&lt;/code&gt; 分割。</target>
        </trans-unit>
        <trans-unit id="6e310688fa6d65057ce51d85bd5439d15eeafd62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n + p &amp;lt;= m&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_n, e_1, ..., e_p)&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d4baac79ac0ec79605a8d87c557699bd33432f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n + p&lt;/code&gt; is less than the number of required arguments to &lt;code&gt;gun&lt;/code&gt; then an exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6773ebb7a73c0cf9641c3fc6c53898d5654dcdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is even, &lt;code&gt;A[-1]&lt;/code&gt; contains the term representing both positive and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely real. If &lt;code&gt;n&lt;/code&gt; is odd, there is no term at fs/2; &lt;code&gt;A[-1]&lt;/code&gt; contains the largest positive frequency (fs/2*(n-1)/n), and is complex in the general case.</source>
          <target state="translated">如果 &lt;code&gt;n&lt;/code&gt; 为偶数，则 &lt;code&gt;A[-1]&lt;/code&gt; 包含代表正和负奈奎斯特频率（+ fs / 2和-fs / 2）的项，并且也必须是纯实数。如果 &lt;code&gt;n&lt;/code&gt; 为奇数，则fs / 2处无项； &lt;code&gt;A[-1]&lt;/code&gt; 包含最大正频率（fs / 2 *（n-1）/ n），在一般情况下很复杂。</target>
        </trans-unit>
        <trans-unit id="d002795222f44b6308a6ac63aedd1a3723557506" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;names&lt;/code&gt; is True, the field names are read from the first line after the first &lt;code&gt;skip_header&lt;/code&gt; lines. This line can optionally be proceeded by a comment delimiter. If &lt;code&gt;names&lt;/code&gt; is a sequence or a single-string of comma-separated names, the names will be used to define the field names in a structured dtype. If &lt;code&gt;names&lt;/code&gt; is None, the names of the dtype fields will be used, if any.</source>
          <target state="translated">如果 &lt;code&gt;names&lt;/code&gt; 为True，则从第一行 &lt;code&gt;skip_header&lt;/code&gt; 行之后的第一行读取字段名称。此行可以选择用注释定界符继续。如果 &lt;code&gt;names&lt;/code&gt; 是序列或逗号分隔名称的单字符串，则这些名称将用于以结构化dtype定义字段名称。如果 &lt;code&gt;names&lt;/code&gt; 为None，则将使用dtype字段的名称（如果有）。</target>
        </trans-unit>
        <trans-unit id="07b76e3a08f68e2d41d08bcc90944dfb38bf1854" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;names=None&lt;/code&gt; but a structured dtype is expected, names are defined with the standard NumPy default of &lt;code&gt;&quot;f%i&quot;&lt;/code&gt;, yielding names like &lt;code&gt;f0&lt;/code&gt;, &lt;code&gt;f1&lt;/code&gt; and so forth:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8d4bbddf580197e193ef2ab5f3260ca263687d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. In contrast to &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt; it makes no attempt to copy the data from &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; This undoes &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called after an error when you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input.</source>
          <target state="translated">如果 &lt;code&gt;obj.flags&lt;/code&gt; 具有&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;或（不建议使用）&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;，则此函数将清除标志 &lt;code&gt;DECREF&lt;/code&gt; 的 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 并使其可写，并将 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 设置为NULL。与&lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt;相比，它不尝试从 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 复制数据。这撤消了&lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; &lt;/a&gt;。通常，在完成 &lt;code&gt;obj&lt;/code&gt; 后在错误之后， &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; 之前调用此方法。可以多次调用它，或者使用 &lt;code&gt;NULL&lt;/code&gt; 输入。</target>
        </trans-unit>
        <trans-unit id="8f43e6f1e973bd0d462747acc6303f4251ae23b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. It then copies &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; to &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt;, and returns the error state of the copy operation. This is the opposite of &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called once you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input. See also &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;obj.flags&lt;/code&gt; 具有&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;或（不建议使用）&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;，则此函数将清除标志 &lt;code&gt;DECREF&lt;/code&gt; 的 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 并使其可写，并将 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 设置为NULL。然后，它将 &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; 复制到 &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt; ，并返回复制操作的错误状态。这与&lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; &lt;/a&gt;相反。通常，在完成 &lt;code&gt;obj&lt;/code&gt; 之后，即在 &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; 之前调用此方法。它可以被多次调用，或 &lt;code&gt;NULL&lt;/code&gt; 输入。另见&lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="19e346c07517b41525b586a4ff8685ed9ba6dbe8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;code&gt;True&lt;/code&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;../glossary#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;code&gt;True&lt;/code&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9effe7f71bd1a595880c87c20422da0870723e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;code&gt;True&lt;/code&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;code&gt;True&lt;/code&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt; ，则 &lt;code&gt;x[obj]&lt;/code&gt; 返回一维数组，其中填充了与&lt;em&gt;obj&lt;/em&gt;的 &lt;code&gt;True&lt;/code&gt; 值相对应的&lt;em&gt;x&lt;/em&gt;元素。搜索顺序将是C风格的&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;行&lt;/a&gt;优先。如果&lt;em&gt;obj&lt;/em&gt;在&lt;em&gt;x&lt;/em&gt;的边界之外的条目上具有 &lt;code&gt;True&lt;/code&gt; 值，则将引发索引错误。如果&lt;em&gt;obj&lt;/em&gt;小于&lt;em&gt;x&lt;/em&gt;，则等同于用 &lt;code&gt;False&lt;/code&gt; 填充它。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0cb8b5f8682e528917b9dad63d5ce0f0a15864d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; isn&amp;rsquo;t a suitable numeric type.</source>
          <target state="translated">如果 &lt;code&gt;obj&lt;/code&gt; 不是合适的数字类型。</target>
        </trans-unit>
        <trans-unit id="bd67812cd1998c40abb29425bc518b926e6b0841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to &lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt;&lt;code&gt;Py_NotImplemented&lt;/code&gt;&lt;/a&gt; and no error condition is set.</source>
          <target state="translated">如果 &lt;code&gt;op&lt;/code&gt; 实现了数组接口的任何部分，则 &lt;code&gt;out&lt;/code&gt; 将包含使用该接口对新创建的ndarray的新引用，或者 &lt;code&gt;out&lt;/code&gt; 将包含 &lt;code&gt;NULL&lt;/code&gt; (如果在转换期间发生错误）。否则，out将包含对&lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt; &lt;code&gt;Py_NotImplemented&lt;/code&gt; &lt;/a&gt;的借用引用，并且未设置任何错误条件。</target>
        </trans-unit>
        <trans-unit id="12f75ca0900af5198142d436cbdd5e1ee389cfd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to Py_NotImplemented and no error condition is set. This version allows setting of the dtype in the part of the array interface that looks for the &lt;a href=&quot;../arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; attribute. &lt;code&gt;context&lt;/code&gt; is unused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98dbfb53c5754a6749d968f5df5fe9eebecd4ff8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to Py_NotImplemented and no error condition is set. This version allows setting of the type and context in the part of the array interface that looks for the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">如果 &lt;code&gt;op&lt;/code&gt; 实现了数组接口的任何部分，则 &lt;code&gt;out&lt;/code&gt; 将包含使用该接口对新创建的ndarray的新引用，或者 &lt;code&gt;out&lt;/code&gt; 将包含 &lt;code&gt;NULL&lt;/code&gt; (如果在转换期间发生错误）。否则，out将包含对Py_NotImplemented的借用引用，并且未设置任何错误条件。此版本允许在数组接口中寻找&lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;属性的部分中设置类型和上下文。</target>
        </trans-unit>
        <trans-unit id="ed83570f54caf00535275cbf2433364d3dc43b7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; is already (C-style) contiguous and well-behaved then just return a reference, otherwise return a (contiguous and well-behaved) copy of the array. The parameter op must be a (sub-class of an) ndarray and no checking for that is done.</source>
          <target state="translated">如果 &lt;code&gt;op&lt;/code&gt; 已经（C风格）连续且行为良好，则仅返回引用，否则返回数组的（连续且行为良好）副本。参数op必须是ndarray（的子类），并且不对此进行检查。</target>
        </trans-unit>
        <trans-unit id="3efc82f6eb8962f2bbdd61dd48e5d36f40ab01fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_dtypes&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, it specifies a data type or &lt;code&gt;NULL&lt;/code&gt; for each &lt;code&gt;op[i]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;op_dtypes&lt;/code&gt; 不为 &lt;code&gt;NULL&lt;/code&gt; ，则为每个 &lt;code&gt;op[i]&lt;/code&gt; 指定一种数据类型或 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49913a9d3761c3c5184d0fb1b55beebafb026c1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;otypes&lt;/code&gt; is not specified, then a call to the function with the first argument will be used to determine the number of outputs. The results of this call will be cached if &lt;code&gt;cache&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; to prevent calling the function twice. However, to implement the cache, the original function must be wrapped which will slow down subsequent calls, so only do this if your function is expensive.</source>
          <target state="translated">如果未指定 &lt;code&gt;otypes&lt;/code&gt; ，则将使用对带有第一个参数的函数的调用来确定输出数量。如果 &lt;code&gt;cache&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则将缓存此调用的结果，以防止两次调用该函数。但是，要实现缓存，必须包装原始函数，这会减慢后续调用的速度，因此仅在函数昂贵时才这样做。</target>
        </trans-unit>
        <trans-unit id="6567b2686e797d9822a7bbf895363486cc94afc9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array.</source>
          <target state="translated">如果 &lt;code&gt;out&lt;/code&gt; 为None，则返回包含标准偏差的新数组，否则返回对输出数组的引用。</target>
        </trans-unit>
        <trans-unit id="089152cfcf81b924028fc82e4f2ab4321cd32c01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">如果 &lt;code&gt;out&lt;/code&gt; 为None，则返回包含标准偏差的新数组，否则返回对输出数组的引用。如果ddof&amp;gt; ==切片中非NaN元素的数量，或者该切片仅包含NaN，则该切片的结果为NaN。</target>
        </trans-unit>
        <trans-unit id="a3cf56d56f9711ddb9fe165ac4a15d1c897a7d62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the variance, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">如果 &lt;code&gt;out&lt;/code&gt; 为None，则返回包含差异的新数组，否则返回对输出数组的引用。如果ddof&amp;gt; ==切片中非NaN元素的数量，或者该切片仅包含NaN，则该切片的结果为NaN。</target>
        </trans-unit>
        <trans-unit id="bd3ed46fb1ad18e3f54a87922d109c78bc224796" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is provided, the function writes the result into it, and returns a reference to &lt;code&gt;out&lt;/code&gt;. (See Examples)</source>
          <target state="translated">如果提供 &lt;code&gt;out&lt;/code&gt; ，则函数将结果写入其中，并返回对 &lt;code&gt;out&lt;/code&gt; 的引用。（请参见示例）</target>
        </trans-unit>
        <trans-unit id="d0b860961bc5b4a4c45189c0fd4de5c2d61f1ab4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned.</source>
          <target state="translated">如果 &lt;code&gt;out=None&lt;/code&gt; ，则返回一个包含平均值的新数组，否则返回对输出数组的引用。</target>
        </trans-unit>
        <trans-unit id="d2bfee9ac0986058c6155b92fa93c7a62c8953a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned. Nan is returned for slices that contain only NaNs.</source>
          <target state="translated">如果 &lt;code&gt;out=None&lt;/code&gt; ，则返回一个包含平均值的新数组，否则返回对输出数组的引用。对于仅包含NaN的切片，将返回Nan。</target>
        </trans-unit>
        <trans-unit id="64277711f0130f08ef89a03256433633c6256165" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the variance; otherwise, a reference to the output array is returned.</source>
          <target state="translated">如果 &lt;code&gt;out=None&lt;/code&gt; ，则返回包含方差的新数组；否则，返回新数组。否则，返回对输出数组的引用。</target>
        </trans-unit>
        <trans-unit id="9b1c9c61ff9f1ab4238c3c9129f3c3d7264b97ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;output&lt;/code&gt; not supplied then source code is printed to screen (sys.stdout). File object must be created with either write &amp;lsquo;w&amp;rsquo; or append &amp;lsquo;a&amp;rsquo; modes.</source>
          <target state="translated">如果未提供 &lt;code&gt;output&lt;/code&gt; 则将源代码打印到屏幕（sys.stdout）。必须使用写'w'或附加'a'模式创建文件对象。</target>
        </trans-unit>
        <trans-unit id="710d73ebab70d58eff0ea577b59d52767457dc24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p &amp;gt; m&lt;/code&gt; then &lt;code&gt;gun(e_1, ..., e_m)&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffd83286f9552326735c9e9997d8b928bd7d08a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p &amp;lt;= m &amp;lt; n + p&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_q, e_1, ..., e_p)&lt;/code&gt; is called, here &lt;code&gt;q=m-p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e928ca77781f5fb31deca2051e51b1031bced3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p == 0&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_q)&lt;/code&gt; is called, here &lt;code&gt;q = min(m, n)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c444cb5aa197d63b68cfea78d90d29188a9456" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is of length N, this function returns the value:</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 的长度为N，则此函数返回值：</target>
        </trans-unit>
        <trans-unit id="fe3f05df5768add8f656a94f10e13fc6943b0c1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is the returned series, then &lt;code&gt;p(x) == x&lt;/code&gt; for all values of x.</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 是返回的序列，则对于 &lt;code&gt;p(x) == x&lt;/code&gt; 的所有值，p（x）== x。</target>
        </trans-unit>
        <trans-unit id="f5468a2ba10e85782ab3beca18220db469f1d944" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, it will be downloaded, stored in the &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; directory and opened from there.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 是URL，它将被下载，存储在&lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt;目录中并从那里打开。</target>
        </trans-unit>
        <trans-unit id="24260df7d2aad1e014a4c9af35e7ef7678f51548" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, then &lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt;&lt;code&gt;abspath&lt;/code&gt;&lt;/a&gt; will return either the location the file exists locally or the location it would exist when opened using the &lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 是URL，则&lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt; &lt;code&gt;abspath&lt;/code&gt; &lt;/a&gt;将返回文件在本地存在的位置或使用&lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;方法打开时将存在的位置。</target>
        </trans-unit>
        <trans-unit id="9e52fcae8c89336b9d76db6bc95e2d2ecd5abb9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple percentiles are given, first axis of the result corresponds to the percentiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">如果 &lt;code&gt;q&lt;/code&gt; 是单个百分位数，而 &lt;code&gt;axis=None&lt;/code&gt; ，则结果是标量。如果给出了多个百分位数，则结果的第一个轴对应于百分位数。其他轴是 &lt;code&gt;a&lt;/code&gt; 减小后剩余的轴。如果输入包含小于 &lt;code&gt;float64&lt;/code&gt; 的整数或浮点数，则输出数据类型为 &lt;code&gt;float64&lt;/code&gt; 。否则，输出数据类型与输入的数据类型相同。如果指定 &lt;code&gt;out&lt;/code&gt; ，则返回该数组。</target>
        </trans-unit>
        <trans-unit id="4219d6c9d1025bc747faeaba10649824d1b4aa46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">如果 &lt;code&gt;q&lt;/code&gt; 是单个百分位数，而 &lt;code&gt;axis=None&lt;/code&gt; ，则结果是标量。如果给出了多个分位数，则结果的第一轴对应于分位数。其他轴是 &lt;code&gt;a&lt;/code&gt; 减小后剩余的轴。如果输入包含小于 &lt;code&gt;float64&lt;/code&gt; 的整数或浮点数，则输出数据类型为 &lt;code&gt;float64&lt;/code&gt; 。否则，输出数据类型与输入的数据类型相同。如果指定 &lt;code&gt;out&lt;/code&gt; ，则返回该数组。</target>
        </trans-unit>
        <trans-unit id="adb7c2f1dd4ba6f271e782ab821bd6ce35c48378" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single quantile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">如果 &lt;code&gt;q&lt;/code&gt; 是单个分位数并且 &lt;code&gt;axis=None&lt;/code&gt; ，则结果是标量。如果给出了多个分位数，则结果的第一轴对应于分位数。其他轴是 &lt;code&gt;a&lt;/code&gt; 减小后剩余的轴。如果输入包含小于 &lt;code&gt;float64&lt;/code&gt; 的整数或浮点数，则输出数据类型为 &lt;code&gt;float64&lt;/code&gt; 。否则，输出数据类型与输入的数据类型相同。如果指定 &lt;code&gt;out&lt;/code&gt; ，则返回该数组。</target>
        </trans-unit>
        <trans-unit id="9da6831f27b77e8b6677e8aad5c341d985befa99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;r&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor is ``True`&lt;/code&gt; the shape will be r.shape[1:] + x.shape; that is, each polynomial is evaluated at every value of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the shape will be r.shape[1:]; that is, each polynomial is evaluated only for the corresponding broadcast value of &lt;code&gt;x&lt;/code&gt;. Note that scalars have shape (,).</source>
          <target state="translated">如果 &lt;code&gt;r&lt;/code&gt; 是一维数组，则 &lt;code&gt;p(x)&lt;/code&gt; 将具有与 &lt;code&gt;x&lt;/code&gt; 相同的形状。如果 &lt;code&gt;r&lt;/code&gt; 是多维的，则结果的形状取决于 &lt;code&gt;tensor&lt;/code&gt; 的值。如果 &lt;code&gt;tensor is ``True`&lt;/code&gt; 则形状将为r.shape [1：] + x.shape; 也就是说，每个多项式都是在 &lt;code&gt;x&lt;/code&gt; 的每个值处求值的。如果 &lt;code&gt;tensor&lt;/code&gt; 为 &lt;code&gt;False&lt;/code&gt; ，则形状将为r.shape [1：];。也就是说，仅针对 &lt;code&gt;x&lt;/code&gt; 的相应广播值评估每个多项式。请注意，标量具有形状（，）。</target>
        </trans-unit>
        <trans-unit id="16d6bbf3ace149a532102c10ab8ede2738b896bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is of length &lt;code&gt;N&lt;/code&gt;, this function returns the value</source>
          <target state="translated">如果 &lt;code&gt;r&lt;/code&gt; 的长度为 &lt;code&gt;N&lt;/code&gt; ，则此函数返回值</target>
        </trans-unit>
        <trans-unit id="6bc06c8f2ea0c3500f46f216948ca646bd403c39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep&lt;/code&gt; is an instance of a scalar dtype, True is returned. If not, False is returned.</source>
          <target state="translated">如果 &lt;code&gt;rep&lt;/code&gt; 是标量dtype的实例，则返回True。如果不是，则返回False。</target>
        </trans-unit>
        <trans-unit id="caf6ef0eb6bbcb3c4e7a4a5b04998bc1341e6eb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reps&lt;/code&gt; has length &lt;code&gt;d&lt;/code&gt;, the result will have dimension of &lt;code&gt;max(d, A.ndim)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;reps&lt;/code&gt; 的长度为 &lt;code&gt;d&lt;/code&gt; ，则结果的尺寸将为 &lt;code&gt;max(d, A.ndim)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15d930e73a09a54bb69273b247bbe9349e70a0c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rowvar&lt;/code&gt; is True (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations.</source>
          <target state="translated">如果 &lt;code&gt;rowvar&lt;/code&gt; 为True（默认值），则每一行代表一个变量，各列中带有观察值。否则，该关系将转置：每一列代表一个变量，而行包含观察值。</target>
        </trans-unit>
        <trans-unit id="0e485a675b3c010a2a7eedd59e29811b56d30eeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length, or &lt;code&gt;axes&lt;/code&gt; not given and &lt;code&gt;len(s) != 2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;axes&lt;/code&gt; 长度不同，或者未指定 &lt;code&gt;axes&lt;/code&gt; 且 &lt;code&gt;len(s) != 2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1a95f9d4c94712a6711035b0d38ca6007922134" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;axes&lt;/code&gt; 长度不同。</target>
        </trans-unit>
        <trans-unit id="7c3cc7c092c11cc91fc3de1425949e6b1c9585a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sctype&lt;/code&gt; is an object for which the type can not be inferred.</source>
          <target state="translated">如果 &lt;code&gt;sctype&lt;/code&gt; 是无法推断类型的对象。</target>
        </trans-unit>
        <trans-unit id="9a8f382549c758d89f2c430b015281fc763e47f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;seed&lt;/code&gt; is not a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;, a new &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; is instantiated. This function does not manage a default global instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aeaeba3f41f378516fdce780d9277e8a4ccfffb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.shape[k] == 1&lt;/code&gt; then for any legal index &lt;code&gt;index[k] == 0&lt;/code&gt;. This means that in the formula for the offset</source>
          <target state="translated">如果 &lt;code&gt;self.shape[k] == 1&lt;/code&gt; 那么对于任何合法索引 &lt;code&gt;index[k] == 0&lt;/code&gt; 。这意味着在公式中的偏移量</target>
        </trans-unit>
        <trans-unit id="5df5fe3df9ec97e65980a43dfd1884e4e357c660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is non-singular, &lt;code&gt;ret&lt;/code&gt; is such that &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size))&lt;/code&gt; all return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5eb20061bb0d5a1e031a6a1b5daa75d4a16cad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is non-singular, &lt;code&gt;ret&lt;/code&gt; is such that &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; all return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 是非奇异的，则 &lt;code&gt;ret&lt;/code&gt; 使得 &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; 都返回 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b27bb431dc045601d86e73a474de86c64d035384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is singular.</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 是奇异的。</target>
        </trans-unit>
        <trans-unit id="a097af1908df1ac936bba64c59e9507a0eb901d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified or &lt;code&gt;None&lt;/code&gt;, any whitespace string is a separator.</source>
          <target state="translated">如果未指定 &lt;code&gt;sep&lt;/code&gt; 或 &lt;code&gt;None&lt;/code&gt; ，则任何空格字符串都是分隔符。</target>
        </trans-unit>
        <trans-unit id="6b286f3e58c7b02612a4551d6a9dcb5406b09f75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified or None, any whitespace string is a separator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768a6e9085deaf336653d5c9857ddf9b254027d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; has length one i.e. &lt;code&gt;(N,)&lt;/code&gt;, or is a scalar &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;out&lt;/code&gt; becomes a single row matrix of shape &lt;code&gt;(1,N)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;shape&lt;/code&gt; 长度为一个，即 &lt;code&gt;(N,)&lt;/code&gt; 或为标量 &lt;code&gt;N&lt;/code&gt; ，则 &lt;code&gt;out&lt;/code&gt; 变为形状 &lt;code&gt;(1,N)&lt;/code&gt; 的单行矩阵。</target>
        </trans-unit>
        <trans-unit id="afe85dc9a909b4503b3e7da810ec90771fac4a7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sources&lt;/code&gt; does not contain a signature files, then F2PY is used to scan Fortran source files for routine signatures to construct the wrappers to Fortran codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3a0815985e487dc8833e6a9544cd8f4d19132e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tol&lt;/code&gt; &amp;lt; 0</source>
          <target state="translated">如果 &lt;code&gt;tol&lt;/code&gt; &amp;lt;0</target>
        </trans-unit>
        <trans-unit id="6cf15e83c2fdf72b1f29bfc75044966bd6bc1399" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is a 2-D array, return a copy of its &lt;code&gt;k&lt;/code&gt;-th diagonal. If &lt;code&gt;v&lt;/code&gt; is a 1-D array, return a 2-D array with &lt;code&gt;v&lt;/code&gt; on the &lt;code&gt;k&lt;/code&gt;-th diagonal.</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 是二维数组，则返回其第 &lt;code&gt;k&lt;/code&gt; 个对角线的副本。如果 &lt;code&gt;v&lt;/code&gt; 是一维数组，则返回一个二维数组，其中 &lt;code&gt;v&lt;/code&gt; 在第 &lt;code&gt;k&lt;/code&gt; 个对角线上。</target>
        </trans-unit>
        <trans-unit id="8349a8e04c4275fccf8d4c40bdfe6166a838f29e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is longer than &lt;code&gt;a&lt;/code&gt;, the arrays are swapped before computation.</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 大于 &lt;code&gt;a&lt;/code&gt; ，则在计算之前交换数组。</target>
        </trans-unit>
        <trans-unit id="bfdbe84100978bde6f35b9bd48d4f5ad4bf72c8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is not the same size as &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;mask&lt;/code&gt; then it will repeat. This gives behavior different from &lt;code&gt;a[mask] = values&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;values&lt;/code&gt; 的大小与 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;mask&lt;/code&gt; 的大小不同，则它将重复。这给出的行为不同于 &lt;code&gt;a[mask] = values&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54792a3abbf75ac3395cbad014c19ac2ff1595e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is smaller than &lt;code&gt;a&lt;/code&gt; it is repeated:</source>
          <target state="translated">如果 &lt;code&gt;values&lt;/code&gt; 小于 &lt;code&gt;a&lt;/code&gt; ，则重复：</target>
        </trans-unit>
        <trans-unit id="d3b50be1f74d03f550d5fd9dbbf8a888d565797b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x2&lt;/code&gt; is a scalar, its sign will be copied to all elements of &lt;code&gt;x1&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x2&lt;/code&gt; 是标量，则其符号将被复制到 &lt;code&gt;x1&lt;/code&gt; 的所有元素。</target>
        </trans-unit>
        <trans-unit id="b5f780e2f5cb497ee27a4b50260d939ccb5e1976" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是列表或元组，则将其转换为ndarray，否则将保持不变并被视为标量。在任何一种情况下， &lt;code&gt;x&lt;/code&gt; 或其元素必须支持与自身以及 &lt;code&gt;c&lt;/code&gt; 元素的加法和乘法。</target>
        </trans-unit>
        <trans-unit id="e9289f94a42ce2a055130aa0322c6aa21e4c7a12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是列表或元组，则将其转换为ndarray，否则将保持不变并被视为标量。在任何一种情况下， &lt;code&gt;x&lt;/code&gt; 或其元素必须支持与自身以及 &lt;code&gt;r&lt;/code&gt; 元素的加法和乘法。</target>
        </trans-unit>
        <trans-unit id="0f3c93ccc6b110d8957f1eff605f32da46911a50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a multi-dimensional array, it is only shuffled along its first index.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是多维数组，则仅沿其第一个索引随机排列。</target>
        </trans-unit>
        <trans-unit id="10902731cd32fb924a9fa6246d242dab230b11a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a poly1d instance, the result is the composition of the two polynomials, i.e., &lt;code&gt;x&lt;/code&gt; is &amp;ldquo;substituted&amp;rdquo; in &lt;code&gt;p&lt;/code&gt; and the simplified result is returned. In addition, the type of &lt;code&gt;x&lt;/code&gt; - array_like or poly1d - governs the type of the output: &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like, &lt;code&gt;x&lt;/code&gt; a poly1d object =&amp;gt; &lt;code&gt;values&lt;/code&gt; is also.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是一个poly1d实例，则结果是两个多项式的组合，即 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;p&lt;/code&gt; 中被&amp;ldquo;取代&amp;rdquo;，并返回简化的结果。另外， &lt;code&gt;x&lt;/code&gt; 的类型-array_like或poly1d-决定输出的类型： &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like， &lt;code&gt;x&lt;/code&gt; a poly1d object =&amp;gt; &lt;code&gt;values&lt;/code&gt; 也是如此。</target>
        </trans-unit>
        <trans-unit id="d6a5280b73875b8ad0b036e2ed1535be94a86966" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a sequence, then &lt;code&gt;p(x)&lt;/code&gt; is returned for each element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is another polynomial then the composite polynomial &lt;code&gt;p(x(t))&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是一个序列，则 &lt;code&gt;p(x)&lt;/code&gt; 的每个元素被返回 &lt;code&gt;x&lt;/code&gt; 。如果 &lt;code&gt;x&lt;/code&gt; 是另一个多项式，则返回复合多项式 &lt;code&gt;p(x(t))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e418b1b9672c946b1ca5e8afc3125fd05c313b38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a subtype of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; the return value will be of the same type.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;的子类型，则返回值将是同一类型。</target>
        </trans-unit>
        <trans-unit id="2f55968163fb644f21e767c8ca56c7265582f682" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an integer, randomly permute &lt;code&gt;np.arange(x)&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is an array, make a copy and shuffle the elements randomly.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是整数，则随机置换 &lt;code&gt;np.arange(x)&lt;/code&gt; 。如果 &lt;code&gt;x&lt;/code&gt; 是一个数组，请进行复制并随机随机排列这些元素。</target>
        </trans-unit>
        <trans-unit id="8675c9efb1c5ad5afa002d06cb6dcceef7c6f2a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is inexact, NaN is replaced by zero or by the user defined value in &lt;a href=&quot;../constants#numpy.nan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt; keyword, infinity is replaced by the largest finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;posinf&lt;/code&gt; keyword and -infinity is replaced by the most negative finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;neginf&lt;/code&gt; keyword.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 不精确，将NaN替换为零或&lt;a href=&quot;../constants#numpy.nan&quot;&gt; &lt;code&gt;nan&lt;/code&gt; &lt;/a&gt;关键字中的用户定义值，将infinity替换为 &lt;code&gt;x.dtype&lt;/code&gt; 可表示的最大有限浮点值，或替换为 &lt;code&gt;posinf&lt;/code&gt; 关键字中的用户定义值，并将-infinity替换为由 &lt;code&gt;x.dtype&lt;/code&gt; 或 &lt;code&gt;neginf&lt;/code&gt; 关键字中用户定义的值表示的最负的有限浮点值。</target>
        </trans-unit>
        <trans-unit id="a12bcfaac2b6a0d5eb775110eb5d113a7ffcf89b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not inexact, then no replacements are made.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 不精确，则不进行替换。</target>
        </trans-unit>
        <trans-unit id="dab92b609c96bcdc43f19efa69fe1680ecbcb0cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is of a signed integer type, then the output type is the default platform integer:</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为带符号整数类型，则输出类型为默认平台整数：</target>
        </trans-unit>
        <trans-unit id="9b8211170506c6269c7986617b768331c6cb9374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;xp&lt;/code&gt; and &lt;code&gt;fp&lt;/code&gt; have different length If &lt;code&gt;xp&lt;/code&gt; or &lt;code&gt;fp&lt;/code&gt; are not 1-D sequences If &lt;code&gt;period == 0&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;xp&lt;/code&gt; 和 &lt;code&gt;fp&lt;/code&gt; 的长度不同如果 &lt;code&gt;xp&lt;/code&gt; 或 &lt;code&gt;fp&lt;/code&gt; 不是一维序列如果 &lt;code&gt;period == 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c2455250a9da7702638a12b7e54e59f4d21fc53" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;arr&lt;/em&gt; is an array, returns its data type descriptor, but if &lt;em&gt;arr&lt;/em&gt; is an array scalar (has 0 dimensions), it finds the data type of smallest size to which the value may be converted without overflow or truncation to an integer.</source>
          <target state="translated">如果&lt;em&gt;arr&lt;/em&gt;是一个数组，则返回其数据类型描述符，但是如果&lt;em&gt;arr&lt;/em&gt;是一个数组标量（维数为0），它将找到最小大小的数据类型，该值可以转换为该大小而不会发生溢出或截断，得到整数。</target>
        </trans-unit>
        <trans-unit id="a70ed9437e4a5163189d25b472581eabce8d5ceb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is &lt;em&gt;None&lt;/em&gt; (the default), the array is treated as a 1-D array and the operation is performed over the entire array. This behavior is also the default if self is a 0-dimensional array or array scalar. (An array scalar is an instance of the types/classes float32, float64, etc., whereas a 0-dimensional array is an ndarray instance containing precisely one array scalar.)</source>
          <target state="translated">如果&lt;em&gt;axis&lt;/em&gt;为&lt;em&gt;None&lt;/em&gt;（默认值），则将该数组视为一维数组，并在整个数组上执行该操作。如果self是0维数组或数组标量，则此行为也是默认行为。（数组标量是float32，float64等类型/类的实例，而0维数组是仅包含一个数组标量的ndarray实例。）</target>
        </trans-unit>
        <trans-unit id="9235232429102d093beb5f545c26b8fef229f79b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is an integer, then the operation is done over the given axis (for each 1-D subarray that can be created along the given axis).</source>
          <target state="translated">如果&lt;em&gt;axis&lt;/em&gt;是整数，则将在给定的轴上进行操作（对于可沿给定轴创建的每个1-D子数组）。</target>
        </trans-unit>
        <trans-unit id="1b1a4ec186584bdfde20daf47a6283f1daa2a542" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then new unitinialized memory will be allocated and &lt;em&gt;flags&lt;/em&gt; can be non-zero to indicate a Fortran-style contiguous array. Use &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt;&lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt;&lt;/a&gt; to initialize the memory.</source>
          <target state="translated">如果&lt;em&gt;data&lt;/em&gt;为 &lt;code&gt;NULL&lt;/code&gt; ，则将分配新的单位化内存，并且&lt;em&gt;标志&lt;/em&gt;可以为非零，以指示Fortran样式的连续数组。使用&lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt; &lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt; &lt;/a&gt;初始化内存。</target>
        </trans-unit>
        <trans-unit id="b7bd71ee3411fe6c23b731a500527ae1ac46e705" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, then it is assumed to point to the memory to be used for the array and the &lt;em&gt;flags&lt;/em&gt; argument is used as the new flags for the array (except the state of &lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags of the new array will be reset).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3854bd1e23682951d79d6393e1c1b2b19835be" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, then it is assumed to point to the memory to be used for the array and the &lt;em&gt;flags&lt;/em&gt; argument is used as the new flags for the array (except the state of &lt;code&gt;NPY_OWNDATA&lt;/code&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags of the new array will be reset).</source>
          <target state="translated">如果&lt;em&gt;data&lt;/em&gt;不为 &lt;code&gt;NULL&lt;/code&gt; ，则假定它指向要用于数组的内存，并且&lt;em&gt;flags&lt;/em&gt;参数用作数组的新标志（新数组的 &lt;code&gt;NPY_OWNDATA&lt;/code&gt; ，&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;标志的状态除外）重置）。</target>
        </trans-unit>
        <trans-unit id="9cebbbbcc1739892f8b12e053651c131570cd283" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;descr&lt;/em&gt; is NULL, the data type of &lt;em&gt;prototype&lt;/em&gt; is used.</source>
          <target state="translated">如果&lt;em&gt;descr&lt;/em&gt;为NULL，则使用&lt;em&gt;原型&lt;/em&gt;的数据类型。</target>
        </trans-unit>
        <trans-unit id="aec9506a456027cf0203832745240a439d9ff187" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dtype&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the returned array will have the same data type as &lt;em&gt;self&lt;/em&gt;. The new data-type must be consistent with the size of &lt;em&gt;self&lt;/em&gt;. Either the itemsizes must be identical, or &lt;em&gt;self&lt;/em&gt; must be single-segment and the total number of bytes must be the same. In the latter case the dimensions of the returned array will be altered in the last (or first for Fortran-style contiguous arrays) dimension. The data area of the returned array and self is exactly the same.</source>
          <target state="translated">如果&lt;em&gt;dtype&lt;/em&gt;为 &lt;code&gt;NULL&lt;/code&gt; ，则返回的数组将具有与&lt;em&gt;self&lt;/em&gt;相同的数据类型。新的数据类型必须与&lt;em&gt;self&lt;/em&gt;的大小一致。项目大小必须相同，或者&lt;em&gt;self&lt;/em&gt;必须为单段，并且字节总数必须相同。在后一种情况下，将在最后一个（对于Fortran样式的连续数组来说，第一个）维中更改返回数组的维。返回的数组和self的数据区域完全相同。</target>
        </trans-unit>
        <trans-unit id="b00215400909f507a463937ff52555cace4d8945" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;op&lt;/em&gt; is already an array, but does not satisfy the requirements, then a copy is made (which will satisfy the requirements). If this flag is present and a copy (of an object that is already an array) must be made, then the corresponding &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag is set in the returned copy and &lt;em&gt;op&lt;/em&gt; is made to be read-only. You must be sure to call &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; to copy the contents back into &lt;em&gt;op&lt;/em&gt; and the &lt;em&gt;op&lt;/em&gt; array will be made writeable again. If &lt;em&gt;op&lt;/em&gt; is not writeable to begin with, or if it is not already an array, then an error is raised.</source>
          <target state="translated">如果&lt;em&gt;op&lt;/em&gt;已经是一个数组，但不满足要求，那么将进行复制（将满足要求）。如果存在此标志，并且必须创建（已经是数组的对象的）副本，则在返回的副本中设置相应的&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;标志，并将&lt;em&gt;op&lt;/em&gt;设为只读。您必须确保调用&lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;将内容复制回&lt;em&gt;op中&lt;/em&gt;，并且&lt;em&gt;op&lt;/em&gt;数组将再次变为可写状态。如果&lt;em&gt;op&lt;/em&gt;从一开始就不可写，或者它还不是数组，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="2b3d523872c6239b2b47533fe932fb9b935c7ec9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, the shape of the result is</source>
          <target state="translated">如果&lt;em&gt;permute&lt;/em&gt;为 &lt;code&gt;NULL&lt;/code&gt; ，则结果的形状为</target>
        </trans-unit>
        <trans-unit id="864a2871c8455778be67517dc3e9f63ae59a60fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subok&lt;/em&gt; is 1, the newly created array will use the sub-type of &lt;em&gt;prototype&lt;/em&gt; to create the new array, otherwise it will create a base-class array.</source>
          <target state="translated">如果&lt;em&gt;subok&lt;/em&gt;为1，则新创建的数组将使用&lt;em&gt;原型&lt;/em&gt;的子类型创建新数组，否则将创建基类数组。</target>
        </trans-unit>
        <trans-unit id="d7c8774de40710ea170a99b3d842fc0b2a6f66b4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subtype&lt;/em&gt; is of an array subclass instead of the base &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;obj&lt;/em&gt; is the object to pass to the &lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; method of the subclass.</source>
          <target state="translated">如果&lt;em&gt;子类型&lt;/em&gt;属于数组子类，而不是基础&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt; &lt;/a&gt;，则&lt;em&gt;obj&lt;/em&gt;是要传递给子类的&lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; &lt;/a&gt;方法的对象。</target>
        </trans-unit>
        <trans-unit id="3703a88bcd847e1448a723a502192b0e8fa8fa65" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subtype&lt;/em&gt; is of an array subclass instead of the base &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;obj&lt;/em&gt; is the object to pass to the &lt;a href=&quot;../arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; method of the subclass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c808aeb714f46484081440736a2f659eda1cb00f" translate="yes" xml:space="preserve">
          <source>If A = qr such that q is orthonormal (which is always possible via Gram-Schmidt), then &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt;. (In numpy practice, however, we simply use &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt;&lt;code&gt;lstsq&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">如果A = qr使得q是正交的（通过Gram-Schmidt总是可以的），则 &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt; 。（但是，在numpy练习中，我们仅使用&lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt; &lt;code&gt;lstsq&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="a5523a2784c429b6ba47e45d47c8a0bb942c669e" translate="yes" xml:space="preserve">
          <source>If False, a view into the original arrays are returned in order to conserve memory. Default is True. Please note that &lt;code&gt;sparse=False, copy=False&lt;/code&gt; will likely return non-contiguous arrays. Furthermore, more than one element of a broadcast array may refer to a single memory location. If you need to write to the arrays, make copies first.</source>
          <target state="translated">如果为False，则返回原始数组的视图以节省内存。默认值为True。请注意， &lt;code&gt;sparse=False, copy=False&lt;/code&gt; 可能会返回非连续数组。此外，广播阵列的一个以上的元素可以引用单个存储位置。如果需要写入阵列，请先进行复制。</target>
        </trans-unit>
        <trans-unit id="343caea52a4d2f3f220c6f641bc3ef525fc8ff10" translate="yes" xml:space="preserve">
          <source>If False, reference count will not be checked. Default is True.</source>
          <target state="translated">如果为False,将不检查参考次数。默认为True。</target>
        </trans-unit>
        <trans-unit id="cc82a0ba7e27b536a6fe2ae6adeaa5a186566e3c" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt;.</source>
          <target state="translated">如果默认值为False，则返回每个bin中的样本数。如果为True，则在bin &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt; 处返回概率&lt;em&gt;密度&lt;/em&gt;函数。</target>
        </trans-unit>
        <trans-unit id="023ffe5319599a1faa2198b591752fc4467344db" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt;.</source>
          <target state="translated">如果默认值为False，则返回每个bin中的样本数。如果为True，则在bin处返回概率&lt;em&gt;密度&lt;/em&gt;函数 &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fff9762cd2d96487b93950bfb4f1067d252f526d" translate="yes" xml:space="preserve">
          <source>If GitHub indicates that the branch of your Pull Request can no longer be merged automatically, you have to incorporate changes that have been made since you started into your branch. Our recommended way to do this is to &lt;a href=&quot;development_workflow#rebasing-on-master&quot;&gt;rebase on master&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65d3c4015ca8415c134fa3b89bccc8e92003c36" translate="yes" xml:space="preserve">
          <source>If K = min(M, N), then</source>
          <target state="translated">如果K=min(M,N),则</target>
        </trans-unit>
        <trans-unit id="c8fe35dc8be08c32dcc7a321c29a26e840a0b0cb" translate="yes" xml:space="preserve">
          <source>If None, the index is into the flattened array, otherwise along the specified axis</source>
          <target state="translated">如果为None,则索引进入扁平化数组,否则沿着指定的坐标轴</target>
        </trans-unit>
        <trans-unit id="b2ed776381411dcc06237a74c5e85611ae70c52e" translate="yes" xml:space="preserve">
          <source>If None, then the path is assumed to be the local path plus the subpackage_name. If a setup.py file is not found in the subpackage_path, then a default configuration is used.</source>
          <target state="translated">如果为None,则假设路径为本地路径加上subpackage_name。如果在subpackage_path中没有找到setup.py文件,则使用默认配置。</target>
        </trans-unit>
        <trans-unit id="7f68badbcb18a0e633a2cc1aee70bc74cc566792" translate="yes" xml:space="preserve">
          <source>If None, use a MaskType instance. Otherwise, use a new datatype with the same fields as &lt;code&gt;dtype&lt;/code&gt;, converted to boolean types.</source>
          <target state="translated">如果为None，则使用MaskType实例。否则，请使用与 &lt;code&gt;dtype&lt;/code&gt; 相同字段的新数据类型，并将其转换为布尔类型。</target>
        </trans-unit>
        <trans-unit id="858f084d421de6a09702f1940e95232bb37adf96" translate="yes" xml:space="preserve">
          <source>If Python &lt;code&gt;None&lt;/code&gt; object is used as a required argument, the argument is treated as optional. That is, in the case of array argument, the memory is allocated. And if &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; is given, the corresponding initialization is carried out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b88b29f182ab4a1e89998e5d778c700419477eb5" translate="yes" xml:space="preserve">
          <source>If SVD computation does not converge.</source>
          <target state="translated">如果SVD计算不收敛。</target>
        </trans-unit>
        <trans-unit id="1c8e91eba4c31b07d056c5e107cd3dbd66e73c1f" translate="yes" xml:space="preserve">
          <source>If True (default) make a copy of &lt;code&gt;a&lt;/code&gt; in the result. If False modify &lt;code&gt;a&lt;/code&gt; in place and return a view.</source>
          <target state="translated">如果为True（默认），则在结果中复制 &lt;code&gt;a&lt;/code&gt; 。如果假修改 &lt;code&gt;a&lt;/code&gt; 到位，并返回一个视图。</target>
        </trans-unit>
        <trans-unit id="5f05298246a514cfbe30605192f5c3eec0c39e89" translate="yes" xml:space="preserve">
          <source>If True (default), &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;vh&lt;/code&gt; have the shapes &lt;code&gt;(..., M, M)&lt;/code&gt; and &lt;code&gt;(..., N, N)&lt;/code&gt;, respectively. Otherwise, the shapes are &lt;code&gt;(..., M, K)&lt;/code&gt; and &lt;code&gt;(..., K, N)&lt;/code&gt;, respectively, where &lt;code&gt;K = min(M, N)&lt;/code&gt;.</source>
          <target state="translated">如果为True（默认），则 &lt;code&gt;u&lt;/code&gt; 和 &lt;code&gt;vh&lt;/code&gt; 分别具有 &lt;code&gt;(..., M, M)&lt;/code&gt; 和 &lt;code&gt;(..., N, N)&lt;/code&gt; 的形状。否则，形状分别为 &lt;code&gt;(..., M, K)&lt;/code&gt; 和 &lt;code&gt;(..., K, N)&lt;/code&gt; ，其中 &lt;code&gt;K = min(M, N)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7193bd03fb8a4044e82de41b9072ea59ef18024" translate="yes" xml:space="preserve">
          <source>If True (default), the function for pretty printing (&lt;code&gt;__repr__&lt;/code&gt;) is set, if False the function that returns the default string representation (&lt;code&gt;__str__&lt;/code&gt;) is set.</source>
          <target state="translated">如果为True（默认值），则设置漂亮打印功能（ &lt;code&gt;__repr__&lt;/code&gt; ），如果为False，则设置返回默认字符串表示形式的函数（ &lt;code&gt;__str__&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="303e2928545dd79ae7d3ee948a353e0207edca4f" translate="yes" xml:space="preserve">
          <source>If True a sparse grid is returned in order to conserve memory. Default is False.</source>
          <target state="translated">如果为True,则返回一个稀疏网格,以节省内存。默认为False。</target>
        </trans-unit>
        <trans-unit id="963fdb4eb1744c24416dda1302569ec977b1039b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;M&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">如果为True，则将 &lt;code&gt;M&lt;/code&gt; 假定为Hermitian（如果为实数，则为对称），从而可以更有效地找到奇异值。默认为False。</target>
        </trans-unit>
        <trans-unit id="7ff6382ed5c39a63563e9ed1fd085cab5037a2b5" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;a&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">如果为True，则将 &lt;code&gt;a&lt;/code&gt; 假定为Hermitian（如果为实值，则为对称），从而可以更有效地找到奇异值。默认为False。</target>
        </trans-unit>
        <trans-unit id="e36b410b04f66dbee1ad8585d5ab761e08ac7f58" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;c_or_r&lt;/code&gt; specifies the polynomial&amp;rsquo;s roots; the default is False.</source>
          <target state="translated">如果为True，则 &lt;code&gt;c_or_r&lt;/code&gt; 指定多项式的根。默认值为False。</target>
        </trans-unit>
        <trans-unit id="d928194afbe2c2b929bfedb481313d712d7c8b8b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">如果为True，则 &lt;code&gt;stop&lt;/code&gt; 是最后一个样本。否则，不包括在内。默认值为True。</target>
        </trans-unit>
        <trans-unit id="7b47be5e3a5ad40d6f18921eb27fcceb85292f89" translate="yes" xml:space="preserve">
          <source>If True, NaNs will compare equal.</source>
          <target state="translated">如果True,NaNs将比较平等。</target>
        </trans-unit>
        <trans-unit id="cf238e83938a09d87961a742f48c2f2620eb27d1" translate="yes" xml:space="preserve">
          <source>If True, align the fields by padding as the C-compiler would. Default is False.</source>
          <target state="translated">如果为True,就像C编译器一样用padding对齐字段。默认为False。</target>
        </trans-unit>
        <trans-unit id="9aac1833ab9bd35419c20a57ebf8fcbcb3fe9e5b" translate="yes" xml:space="preserve">
          <source>If True, also repack nested structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac02997269b77136285be7a5e579ac29dadfffd" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of &lt;code&gt;ar&lt;/code&gt; (along the specified axis, if provided, or in the flattened array) that result in the unique array.</source>
          <target state="translated">如果为True，则还返回 &lt;code&gt;ar&lt;/code&gt; 的索引（沿着指定的轴，如果提供的话，或者在展平的数组中），这将导致唯一的数组。</target>
        </trans-unit>
        <trans-unit id="5ba4a4047dcee50611d5129a3a15323121b0e960" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of the unique array (for the specified axis, if provided) that can be used to reconstruct &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">如果为True，则还返回可用于重建 &lt;code&gt;ar&lt;/code&gt; 的唯一数组的索引（对于指定的轴（如果提供））。</target>
        </trans-unit>
        <trans-unit id="399ee9e74026589c23b2445da8094594d73ae5dd" translate="yes" xml:space="preserve">
          <source>If True, also return the number of times each unique item appears in &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">如果为True，则还返回每个唯一项出现在 &lt;code&gt;ar&lt;/code&gt; 中的次数。</target>
        </trans-unit>
        <trans-unit id="66852352128b1c7e34ad7789302cdfe6ede485bb" translate="yes" xml:space="preserve">
          <source>If True, always print floating point numbers using fixed point notation, in which case numbers equal to zero in the current precision will print as zero. If False, then scientific notation is used when absolute value of the smallest number is &amp;lt; 1e-4 or the ratio of the maximum absolute value to the minimum is &amp;gt; 1e3. The default is False.</source>
          <target state="translated">如果为True，则始终使用定点表示法打印浮点数，在这种情况下，当前精度中等于零的数字将打印为零。如果为False，则当最小数的绝对值&amp;lt;1e-4或最大绝对值与最小值之比&amp;gt; 1e3时使用科学计数法。默认值为False。</target>
        </trans-unit>
        <trans-unit id="cbca430a42a0182aa9ea6441a3957e8ab3c8a25b" translate="yes" xml:space="preserve">
          <source>If True, always returns a tuple.</source>
          <target state="translated">如果为真,总是返回一个元组。</target>
        </trans-unit>
        <trans-unit id="7f126462d85653c6dda1dce20f661e9fd87395a7" translate="yes" xml:space="preserve">
          <source>If True, an exception is raised if an inconsistency is detected in the number of columns. If False, a warning is emitted and the offending lines are skipped.</source>
          <target state="translated">如果为真,如果检测到列数不一致,就会引发异常。如果为False,则会发出警告,并跳过违规的行。</target>
        </trans-unit>
        <trans-unit id="00dd94f809ecdc81e9a20bf00165ace3a76e2409" translate="yes" xml:space="preserve">
          <source>If True, do not raise errors for invalid values.</source>
          <target state="translated">如果为True,则不会为无效值出错。</target>
        </trans-unit>
        <trans-unit id="75ba0a561e02b7ed5e7fa180639d41ec79419f2b" translate="yes" xml:space="preserve">
          <source>If True, field names are case sensitive. If False or &amp;lsquo;upper&amp;rsquo;, field names are converted to upper case. If &amp;lsquo;lower&amp;rsquo;, field names are converted to lower case.</source>
          <target state="translated">如果为True，则字段名称区分大小写。如果为False或&amp;ldquo; upper&amp;rdquo;，则字段名称将转换为大写。如果为&amp;ldquo; lower&amp;rdquo;，则字段名称将转换为小写。</target>
        </trans-unit>
        <trans-unit id="d130bfc0ef6421a7c1dc4437f4b7a0f3775ccf94" translate="yes" xml:space="preserve">
          <source>If True, fields in the dst for which there was no matching field in the src are filled with the value 0 (zero). This was the behavior of numpy &amp;lt;= 1.13. If False, those fields are not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d57971ed0ca8f21d400e58c76703f43cbfc417c" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises a &lt;code&gt;ValueError&lt;/code&gt; exception when some values are missing.</source>
          <target state="translated">如果为True，则屏蔽的值将成对传播：如果某个值在 &lt;code&gt;x&lt;/code&gt; 中被屏蔽，则相应的值在 &lt;code&gt;y&lt;/code&gt; 中被屏蔽。如果为False，则在缺少某些值时会引发 &lt;code&gt;ValueError&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="73add7a762002fef273e9b4ffea7ca56d1fceed2" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises an exception. Because &lt;code&gt;bias&lt;/code&gt; is deprecated, this argument needs to be treated as keyword only to avoid a warning.</source>
          <target state="translated">如果为True，则屏蔽的值将成对传播：如果某个值在 &lt;code&gt;x&lt;/code&gt; 中被屏蔽，则相应的值在 &lt;code&gt;y&lt;/code&gt; 中被屏蔽。如果为False，则引发异常。由于不建议使用 &lt;code&gt;bias&lt;/code&gt; ，因此仅在避免警告时才需要将此参数视为关键字。</target>
        </trans-unit>
        <trans-unit id="3151423c1b8495757a74a9c40933465afccfc94a" translate="yes" xml:space="preserve">
          <source>If True, report coverage of NumPy code. Default is False. (This requires the &lt;a href=&quot;https://nedbatchelder.com/code/modules/coveragehtml&quot;&gt;coverage module&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2788b0d6fce7deb3124b031af49411eebfd85f" translate="yes" xml:space="preserve">
          <source>If True, return (&lt;code&gt;samples&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;), where &lt;code&gt;step&lt;/code&gt; is the spacing between samples.</source>
          <target state="translated">如果为True，则返回（ &lt;code&gt;samples&lt;/code&gt; ， &lt;code&gt;step&lt;/code&gt; ），其中 &lt;code&gt;step&lt;/code&gt; 是样本之间的间隔。</target>
        </trans-unit>
        <trans-unit id="1ec0fbd07daef19f7914b14e4eca0f4fd562cd19" translate="yes" xml:space="preserve">
          <source>If True, return a masked array. If False, return a regular array.</source>
          <target state="translated">如果为真,返回一个掩码数组。如果为False,返回一个常规数组。</target>
        </trans-unit>
        <trans-unit id="6adea9a68fb349bf8bb3df130607e9340ead5b74" translate="yes" xml:space="preserve">
          <source>If True, run doctests in module. Default is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ec8ba9608d7abff50b6dc8fd3f7629dafcce5d" translate="yes" xml:space="preserve">
          <source>If True, specifies that the decorated callable is a test. If False, specifies that the decorated callable is not a test. Default is True.</source>
          <target state="translated">如果为True,指定被装饰的callable是一个测试。如果为False,则指定被装饰的callable不是测试。默认为True。</target>
        </trans-unit>
        <trans-unit id="392d55a0a9d04db7b0ca9f8c7072e4cdcc499491" translate="yes" xml:space="preserve">
          <source>If True, subclasses are preserved.</source>
          <target state="translated">如果为True,则保留子类。</target>
        </trans-unit>
        <trans-unit id="8d750c3ba08e3d89b81f148fbacf7cfd56b0a5f8" translate="yes" xml:space="preserve">
          <source>If True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">如果为True，则缩小的轴将保留为尺寸1的尺寸。使用此选项，结果将针对原始 &lt;code&gt;arr&lt;/code&gt; 正确广播。</target>
        </trans-unit>
        <trans-unit id="b2006dd9c76a3ff3a106ec273dd3c8e1e765c752" translate="yes" xml:space="preserve">
          <source>If True, the conflicting values are appended to the error message.</source>
          <target state="translated">如果为True,则将冲突的值附加到错误信息中。</target>
        </trans-unit>
        <trans-unit id="d8ba5d3712bb2ee2efcfc81e8a867c710618acda" translate="yes" xml:space="preserve">
          <source>If True, the indices which correspond to the intersection of the two arrays are returned. The first instance of a value is used if there are multiple. Default is False.</source>
          <target state="translated">如果为True,返回两个数组的交点对应的索引。如果有多个数组,则使用第一个值的实例。默认值为False。</target>
        </trans-unit>
        <trans-unit id="796c55d79196f76e9a5e82ed451d32129c18b457" translate="yes" xml:space="preserve">
          <source>If True, the input arrays are both assumed to be unique, which can speed up the calculation. Default is False.</source>
          <target state="translated">如果为True,则假设输入数组都是唯一的,这样可以加快计算速度。默认为False。</target>
        </trans-unit>
        <trans-unit id="4faadc5e6554004b31ce5928d5d80bd241c02388" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with either the &lt;code&gt;c_index&lt;/code&gt; or the &lt;code&gt;f_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">如果为True，则使用 &lt;code&gt;c_index&lt;/code&gt; 或 &lt;code&gt;f_index&lt;/code&gt; 标志创建迭代器，并且可以使用属性&lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt;来检索它。</target>
        </trans-unit>
        <trans-unit id="78e99fe24c914b8497fc3d013aec906afbe03579" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;delay_bufalloc&lt;/code&gt; flag, and no reset() function was called on it yet.</source>
          <target state="translated">如果为True，则使用 &lt;code&gt;delay_bufalloc&lt;/code&gt; 标志创建迭代器，并且尚未对其调用reset（）函数。</target>
        </trans-unit>
        <trans-unit id="78a4539bda923dafd78fad0e5fb97c6b43556f2b" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;multi_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt;&lt;code&gt;multi_index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">如果为True，则使用 &lt;code&gt;multi_index&lt;/code&gt; 标志创建迭代器，并且可以使用属性&lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt; &lt;code&gt;multi_index&lt;/code&gt; &lt;/a&gt;来检索它。</target>
        </trans-unit>
        <trans-unit id="f4229174699f5726402f68c65f4921612f023a93" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;</source>
          <target state="translated">如果为True，则对返回的数组进行转置，以便可以使用 &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt; 解压缩参数。</target>
        </trans-unit>
        <trans-unit id="b9bf7edcd483311b9596b9cc1a4efa43974ee453" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;. When used with a structured data-type, arrays are returned for each field. Default is False.</source>
          <target state="translated">如果为True，则对返回的数组进行转置，以便可以使用 &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt; 解压缩参数。与结构化数据类型一起使用时，将为每个字段返回数组。默认值为False。</target>
        </trans-unit>
        <trans-unit id="d43fcdb1c52440e31bff4cb2f390cb23f384392a" translate="yes" xml:space="preserve">
          <source>If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;c&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;c&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;c&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">如果为True，则系数数组的形状在右侧扩展为1， &lt;code&gt;x&lt;/code&gt; 的每个维度都为1。标量对此操作的尺寸为0。结果是，对 &lt;code&gt;x&lt;/code&gt; 的每个元素都评估 &lt;code&gt;c&lt;/code&gt; 中的每一列系数。如果为False，则 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;c&lt;/code&gt; 的列上广播以进行评估。当 &lt;code&gt;c&lt;/code&gt; 为多维时，此关键字很有用。默认值是true。</target>
        </trans-unit>
        <trans-unit id="959391ebb6591b28733d37c72b179dc2ae1393e8" translate="yes" xml:space="preserve">
          <source>If True, the shape of the roots array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;r&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;r&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;r&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">如果为True，则将根数组的形状在右侧扩展为1，每个 &lt;code&gt;x&lt;/code&gt; 维度均扩展为1。标量对此操作的尺寸为0。结果是，对 &lt;code&gt;x&lt;/code&gt; 的每个元素都评估 &lt;code&gt;r&lt;/code&gt; 中的每一列系数。如果为False，则 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;r&lt;/code&gt; 的列上广播以进行评估。当 &lt;code&gt;r&lt;/code&gt; 为多维时，此关键字很有用。默认值是true。</target>
        </trans-unit>
        <trans-unit id="6f56bb6f69c7a79b2fcb0eba261866b1784e5a91" translate="yes" xml:space="preserve">
          <source>If True, the spaces at the end of Strings are removed before the comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201e227337fd7a8180e5a7ed35ba4fd5fc02b88e" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted (that is, False where an element of &lt;code&gt;ar1&lt;/code&gt; is in &lt;code&gt;ar2&lt;/code&gt; and True otherwise). Default is False. &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; is equivalent to (but is faster than) &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt;.</source>
          <target state="translated">如果为True，则返回的数组中的值将被反转（即，在 &lt;code&gt;ar1&lt;/code&gt; 中的一个元素位于 &lt;code&gt;ar2&lt;/code&gt; 中时为False，否则为True）。默认值为False。 &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; 等效于（但比 &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt; 更快）。</target>
        </trans-unit>
        <trans-unit id="259b3152dca6c438bfe50af972160ce0a4a1de26" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted, as if calculating &lt;code&gt;element not in test_elements&lt;/code&gt;. Default is False. &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; is equivalent to (but faster than) &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt;.</source>
          <target state="translated">如果为True，则返回数组中的值将被反转，就像计算 &lt;code&gt;element not in test_elements&lt;/code&gt; 。默认值为False。 &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; 等效于（但比 &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt; 更快）。</target>
        </trans-unit>
        <trans-unit id="945e8f6a0cee215b87f641fdb7d3287ee26a3bd1" translate="yes" xml:space="preserve">
          <source>If True, then allow the input array &lt;code&gt;a&lt;/code&gt; to be modified by intermediate calculations, to save memory. In this case, the contents of the input &lt;code&gt;a&lt;/code&gt; after this function completes is undefined.</source>
          <target state="translated">如果为True，则允许通过中间计算来修改输入数组 &lt;code&gt;a&lt;/code&gt; ，以节省内存。在这种情况下，此功能完成后输入 &lt;code&gt;a&lt;/code&gt; 的内容是不确定的。</target>
        </trans-unit>
        <trans-unit id="efffbf4abfcfd3dab70b2b5adf8fd6ea45c7060a" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array (a) for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. Note that, if &lt;code&gt;overwrite_input&lt;/code&gt; is True, and the input is not already an &lt;code&gt;ndarray&lt;/code&gt;, an error will be raised.</source>
          <target state="translated">如果为True，则允许使用输入数组（a）的内存进行计算。输入数组将通过调用中位数进行修改。当您不需要保留输入数组的内容时，这将节省内存。将输入视为未定义，但可能会完全或部分排序。默认值为False。请注意，如果 &lt;code&gt;overwrite_input&lt;/code&gt; 为True，并且输入还不是 &lt;code&gt;ndarray&lt;/code&gt; ，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="453475060bdf9f6ca07ca2a9d367c0c72b7c7341" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">如果为True，则允许使用输入数组 &lt;code&gt;a&lt;/code&gt; 的内存进行计算。输入数组将通过调用&lt;a href=&quot;#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt;来修改。当您不需要保留输入数组的内容时，这将节省内存。将输入视为未定义，但可能会完全或部分排序。默认值为False。如果 &lt;code&gt;overwrite_input&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; 并且 &lt;code&gt;a&lt;/code&gt; 还不是&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，将引发错误。</target>
        </trans-unit>
        <trans-unit id="bf48ed6030d0efc488f7b3086097c6ad325b803d" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;numpy.median#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">如果为True，则允许使用输入数组 &lt;code&gt;a&lt;/code&gt; 的内存进行计算。输入数组将通过调用&lt;a href=&quot;numpy.median#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt;来修改。当您不需要保留输入数组的内容时，这将节省内存。将输入视为未定义，但可能会完全或部分排序。默认值为False。如果 &lt;code&gt;overwrite_input&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; 并且 &lt;code&gt;a&lt;/code&gt; 还不是&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，将引发错误。</target>
        </trans-unit>
        <trans-unit id="727bb21e15aa63ae35b6dc8fc80a632c45207cf3" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array.</source>
          <target state="translated">如果为True,那么子类将被传递(默认),否则返回的数组将被强制为基类数组。</target>
        </trans-unit>
        <trans-unit id="4ceb06545ceed82d0fd2c4e74fddc1a8387d729b" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).</source>
          <target state="translated">如果为True,那么子类将被传递,否则返回的数组将被强制为基类数组(默认)。</target>
        </trans-unit>
        <trans-unit id="7931866e33bf18d405c7c9da5047f41db3dc88c3" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (defaults to False).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9752fe228ae3462d649576fdb0cd4757647ae348" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned arrays will be forced to be a base-class array (default).</source>
          <target state="translated">如果为True,那么子类将被传递,否则返回的数组将被强制为基类数组(默认)。</target>
        </trans-unit>
        <trans-unit id="066838f1ffe5aa12c7d71f9b1de32afdb88ee10e" translate="yes" xml:space="preserve">
          <source>If True, then the newly created array will use the sub-class type of &amp;lsquo;a&amp;rsquo;, otherwise it will be a base-class array. Defaults to True.</source>
          <target state="translated">如果为True，则新创建的数组将使用'a'的子类类型，否则它将是基类数组。默认为True。</target>
        </trans-unit>
        <trans-unit id="9ba9655ceab858d8e0fbfbe35222ace33db08fb2" translate="yes" xml:space="preserve">
          <source>If [array, array], the bin edges in each dimension (x_edges, y_edges = bins).</source>
          <target state="translated">如果[数组,数组],则每个维度的bin边(x_edges,y_edges=bins)。</target>
        </trans-unit>
        <trans-unit id="74d7f2b29106e8ca088ed3ddc192d60c869742ea" translate="yes" xml:space="preserve">
          <source>If [int, int], the number of bins in each dimension (nx, ny = bins).</source>
          <target state="translated">如果[int,int],则每个维度中的宾格数(nx,ny=宾格)。</target>
        </trans-unit>
        <trans-unit id="63952cde8568ab7ec41b2ac80ecf7fdc353a6855" translate="yes" xml:space="preserve">
          <source>If __svn_version__.py existed before, nothing is done.</source>
          <target state="translated">如果之前存在__svn_version__.py,则什么都不做。</target>
        </trans-unit>
        <trans-unit id="2973727add43998ece2695a952786574b37deff8" translate="yes" xml:space="preserve">
          <source>If a &amp;lt; 1.</source>
          <target state="translated">如果&amp;lt;1。</target>
        </trans-unit>
        <trans-unit id="d6288450796b9bb41fb24a4a3b5f478c44715bdc" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;python module&lt;/code&gt; block contains two or more &lt;code&gt;common&lt;/code&gt; blocks with the same name, the variables from the additional declarations are appended. The types of variables in &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt; are defined using &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt;. Note that the corresponding &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt; may contain array specifications; then you don&amp;rsquo;t need to specify these in &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="949f92ee120b49054523e5f48bcc0be73d87cf4a" translate="yes" xml:space="preserve">
          <source>If a Council member becomes inactive in the project for a period of one year, they will be considered for removal from the Council. Before removal, inactive Member will be approached to see if they plan on returning to active participation. If not they will be removed immediately upon a Council vote. If they plan on returning to active participation soon, they will be given a grace period of one year. If they don&amp;rsquo;t return to active participation within that time period they will be removed by vote of the Council without further grace period. All former Council members can be considered for membership again at any time in the future, like any other Project Contributor. Retired Council members will be listed on the project website, acknowledging the period during which they were active in the Council.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f5ac51d599581ab3e8a496c55fdc29ce07640e8" translate="yes" xml:space="preserve">
          <source>If a F2PY generated wrapper function expects the following call-back argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5279f6f16ca5cb6814a2ac00854340dc9cd2fbb" translate="yes" xml:space="preserve">
          <source>If a class (ndarray subclass or not) having the &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method is used as the output object of an &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, results will be written to the object returned by &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt;. Similar conversion is done on input arrays.</source>
          <target state="translated">如果具有一个类（子类ndarray与否）&lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;方法被用作一个的输出对象&lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;，结果将被写入到由返回的对象&lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;。在输入数组上完成类似的转换。</target>
        </trans-unit>
        <trans-unit id="874568bcf37ebe0e2a8a8d54069b92c02f85f23a" translate="yes" xml:space="preserve">
          <source>If a class defines the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, this disables the &lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; mechanism described below for ufuncs (which may eventually be deprecated).</source>
          <target state="translated">如果一个类定义了&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;方法，这将禁用&lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;机制下面描述用于ufuncs（其可以最终被弃用）。</target>
        </trans-unit>
        <trans-unit id="0577aaede06ac434e631d772788e0f369a956f02" translate="yes" xml:space="preserve">
          <source>If a compile-time fixed buffer is being used (both flags &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;), the inner size may be used as a signal as well. The size is guaranteed to become zero when &lt;code&gt;iternext()&lt;/code&gt; returns false, enabling the following loop construct. Note that if you use this construct, you should not pass &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; as a flag, because it will cause larger sizes under some circumstances.</source>
          <target state="translated">如果正在使用编译时固定缓冲区（标志&lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;），则内部大小也可用作信号。当 &lt;code&gt;iternext()&lt;/code&gt; 返回false时，保证大小变为零，从而启用以下循环构造。请注意，如果使用此构造，则不&lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt;作为标志传递，因为在某些情况下它将导致更大的尺寸。</target>
        </trans-unit>
        <trans-unit id="9d666b71ab2db0f6cb052dc4a309c02e840cf132" translate="yes" xml:space="preserve">
          <source>If a dimension is given as -1 in a reshaping operation, the other dimensions are automatically calculated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769025cc778c9102b36d6a70ef7aed0a8fe51c05" translate="yes" xml:space="preserve">
          <source>If a field name in the required_dtype does not exist in the input array, that field is created and set to 0 in the output array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3ce99d9611a27292277b44f279f72466bca938" translate="yes" xml:space="preserve">
          <source>If a field whose dtype object has this attribute is retrieved, then the extra dimensions implied by &lt;em&gt;shape&lt;/em&gt; are tacked on to the end of the retrieved array.</source>
          <target state="translated">如果检索到其dtype对象具有此属性的字段，则&lt;em&gt;形状&lt;/em&gt;隐含的额外维将附加到检索到的数组的末尾。</target>
        </trans-unit>
        <trans-unit id="aa639d13854427042e288c4d7a227d11cd8e9453" translate="yes" xml:space="preserve">
          <source>If a file &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; does not exist, the &lt;code&gt;include&lt;/code&gt; statement is ignored. Otherwise, the file &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; is included to a signature file. &lt;code&gt;include&lt;/code&gt; statements can be used in any part of a signature file, also outside the Fortran/C routine signature blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24439780a6864c35956999c18798d43f08d60388" translate="yes" xml:space="preserve">
          <source>If a formatter is specified for a certain type, the &lt;code&gt;precision&lt;/code&gt; keyword is ignored for that type.</source>
          <target state="translated">如果为特定类型指定了格式化程序，则将忽略该类型的 &lt;code&gt;precision&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="687f359e5176c0f016578fb6a4154929ee305cd5" translate="yes" xml:space="preserve">
          <source>If a given array does not satisfy the specified restrictions.</source>
          <target state="translated">如果一个给定的数组不满足指定的限制。</target>
        </trans-unit>
        <trans-unit id="0f9748bf845ac9d150692dd01c4e3cac7093889e" translate="yes" xml:space="preserve">
          <source>If a is a matrix object, then the return value is a matrix as well:</source>
          <target state="translated">如果a是一个矩阵对象,那么返回值也是一个矩阵。</target>
        </trans-unit>
        <trans-unit id="8ca1d1baf4aebfbd38dd688686cce7228cb6bc88" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if a or p are not 1-dimensional, if a is an array-like of size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size</source>
          <target state="translated">如果a是一个int且小于0,如果a或p不是一维的,如果a是一个大小为0的类数组,如果p不是一个概率向量,如果a和p有不同的长度,或者如果replace=False,且样本量大于人口数量。</target>
        </trans-unit>
        <trans-unit id="45d749c722fde2f54ef7349c75a2d911b0caf469" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if p is not 1-dimensional, if a is array-like with a size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size.</source>
          <target state="translated">如果a是一个int且小于0,如果p不是一维的,如果a是大小为0的类数组,如果p不是概率的向量,如果a和p的长度不同,或者如果replace=False且样本数大于人口数。</target>
        </trans-unit>
        <trans-unit id="6a821a28e324f16f0f4bf4708058f9a3d079d082" translate="yes" xml:space="preserve">
          <source>If a list of strings, each string should represent a dtype. If array_like, the character representation of the array dtype is used.</source>
          <target state="translated">如果是字符串列表,每个字符串应该代表一个dtype。如果是array_like,则使用数组dtype的字符表示。</target>
        </trans-unit>
        <trans-unit id="f0978a6e619ec2d43693907e27d2eb435814d97e" translate="yes" xml:space="preserve">
          <source>If a report doesn&amp;rsquo;t contain enough information, the committee will obtain all relevant data before acting. The committee is empowered to act on the Steering Council&amp;rsquo;s behalf in contacting any individuals involved to get a more complete account of events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63795a6ab48fcba94623b51f8a7753fc963d4b8e" translate="yes" xml:space="preserve">
          <source>If a scalar dtype, the corresponding string character is returned. If an object, &lt;a href=&quot;#numpy.sctype2char&quot;&gt;&lt;code&gt;sctype2char&lt;/code&gt;&lt;/a&gt; tries to infer its scalar type and then return the corresponding string character.</source>
          <target state="translated">如果是标量dtype，则返回相应的字符串字符。如果是对象，则&lt;a href=&quot;#numpy.sctype2char&quot;&gt; &lt;code&gt;sctype2char&lt;/code&gt; &lt;/a&gt;尝试推断其标量类型，然后返回相应的字符串字符。</target>
        </trans-unit>
        <trans-unit id="98a2233adc7ab93848107f159b490659bfa27e57" translate="yes" xml:space="preserve">
          <source>If a scalar value is passed in.</source>
          <target state="translated">如果传入一个标量值。</target>
        </trans-unit>
        <trans-unit id="15bc103dab402117d3913395fb8b40bbeeb0b897" translate="yes" xml:space="preserve">
          <source>If a second argument is supplied the result is stored there. If the type of that array is a numeric type the result is represented as zeros and ones, if the type is boolean then as False and True. The return value &lt;code&gt;out&lt;/code&gt; is then a reference to that array.</source>
          <target state="translated">如果提供了第二个参数，则结果存储在那里。如果该数组的类型是数字类型，则结果表示为零和一，如果类型为布尔值，则表示为False和True。然后，返回值 &lt;code&gt;out&lt;/code&gt; 是对该数组的引用。</target>
        </trans-unit>
        <trans-unit id="342304e655e812ee2a83e5789793e22172924b42" translate="yes" xml:space="preserve">
          <source>If a second argument is supplied the result is stored there. The return value &lt;code&gt;out&lt;/code&gt; is then a reference to that array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb1ddfcab0f3cbec5d42431c301b1cc28fccf65" translate="yes" xml:space="preserve">
          <source>If a zero dimensional array is present in the index &lt;em&gt;and&lt;/em&gt; it is a full integer index the result will be a &lt;em&gt;scalar&lt;/em&gt; and not a zero dimensional array. (Advanced indexing is not triggered.)</source>
          <target state="translated">如果索引中存在零维数组，&lt;em&gt;并且&lt;/em&gt;它是全整数索引，则结果将是&lt;em&gt;标量，&lt;/em&gt;而不是零维数组。（不会触发高级索引。）</target>
        </trans-unit>
        <trans-unit id="64c5c963ea9794eafa3b89f1dd216c6a8ebfd684" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal up to specified precision.</source>
          <target state="translated">如果实际值和期望值不相等,达到指定精度。</target>
        </trans-unit>
        <trans-unit id="39bbb6143ab84f37b65c3d7880c2778b652d186d" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal.</source>
          <target state="translated">如果实际和期望不相等。</target>
        </trans-unit>
        <trans-unit id="fcebdf6acdb7662938a429c761fa5ad9e5471b67" translate="yes" xml:space="preserve">
          <source>If actual and desired objects are not equal.</source>
          <target state="translated">如果实际对象和期望对象不相等。</target>
        </trans-unit>
        <trans-unit id="8aa394119b239dde7365c85e156833625438bfa9" translate="yes" xml:space="preserve">
          <source>If all &lt;code&gt;__array_function__&lt;/code&gt; methods return &lt;code&gt;NotImplemented&lt;/code&gt;, NumPy will raise &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">如果所有 &lt;code&gt;__array_function__&lt;/code&gt; 方法都返回 &lt;code&gt;NotImplemented&lt;/code&gt; ，则NumPy将引发 &lt;code&gt;TypeError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="454ac4064cbf860208005757a60b81b3482b89cb" translate="yes" xml:space="preserve">
          <source>If all of the commits are related, create a merge commit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85985aaa1b2d2d353f8a23ec019a6f4085543d14" translate="yes" xml:space="preserve">
          <source>If all proposals for resolving some issue are vetoed, then the status quo wins by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab8ea3dfbb5bbbb71e7908ef2deef22ffee42c7" translate="yes" xml:space="preserve">
          <source>If all the arrays are 1-D, &lt;a href=&quot;#numpy.where&quot;&gt;&lt;code&gt;where&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="translated">如果所有的阵列是1-d，&lt;a href=&quot;#numpy.where&quot;&gt; &lt;code&gt;where&lt;/code&gt; &lt;/a&gt;等效于：</target>
        </trans-unit>
        <trans-unit id="4680fc5e031229cdb3ef2e322dccd91736ba09de" translate="yes" xml:space="preserve">
          <source>If all values are masked, return None. Otherwise, return a list of two tuples, corresponding to the indices of the first and last unmasked values respectively.</source>
          <target state="translated">如果所有的值都被屏蔽了,返回None。否则,返回两个元组的列表,分别对应第一个和最后一个未屏蔽值的索引。</target>
        </trans-unit>
        <trans-unit id="517ad1e00b3a93fbecfebfae5c6590d4c6fe64a9" translate="yes" xml:space="preserve">
          <source>If an argument has no &lt;code&gt;&amp;lt;argument type declaration&amp;gt;&lt;/code&gt;, its type is determined by applying &lt;code&gt;implicit&lt;/code&gt; rules to its name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0b2100814d2bab89059c0f2bc3adff904ee9a6" translate="yes" xml:space="preserve">
          <source>If an array has a very small or very large determinant, then a call to &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt; may overflow or underflow. This routine is more robust against such issues, because it computes the logarithm of the determinant rather than the determinant itself.</source>
          <target state="translated">如果数组的行列式很小或很大，则对&lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;的调用可能会溢出或下溢。此例程针对此类问题更健壮，因为它计算行列式的对数，而不是行列式本身。</target>
        </trans-unit>
        <trans-unit id="089dc283ee6bf525b9e1357cb2890636154add48" translate="yes" xml:space="preserve">
          <source>If an array has no elements (&lt;code&gt;self.size == 0&lt;/code&gt;) there is no legal index and the strides are never used. Any array with no elements may be considered C-style and Fortran-style contiguous.</source>
          <target state="translated">如果数组没有元素（ &lt;code&gt;self.size == 0&lt;/code&gt; ），则没有合法索引，并且不会使用步幅。没有元素的任何数组都可以视为C样式和Fortran样式的连续数组。</target>
        </trans-unit>
        <trans-unit id="c5c598efb3988281532c1be87569879df34d1935" translate="yes" xml:space="preserve">
          <source>If an array is created using a data-type describing a sub-array, the dimensions of the sub-array are appended to the shape of the array when the array is created. Sub-arrays in a field of a structured type behave differently, see &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;Field Access&lt;/a&gt;.</source>
          <target state="translated">如果使用描述子数组的数据类型创建数组，则在创建数组时会将子数组的尺寸附加到数组的形状上。结构化类型的字段中的子数组的行为不同，请参见&lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;Field Access&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bf36df6b09764d99c53b04e05c8fe53411949d03" translate="yes" xml:space="preserve">
          <source>If an array is created with this method, simply adding &amp;lsquo;itemsize&amp;rsquo; for each iteration will traverse the new array matching the iterator.</source>
          <target state="translated">如果使用此方法创建数组，则只需为每次迭代添加&amp;ldquo; itemsize&amp;rdquo;，将遍历与迭代器匹配的新数组。</target>
        </trans-unit>
        <trans-unit id="1497d51c68c81f921994ed240661dbb7879d05a8" translate="yes" xml:space="preserve">
          <source>If an array is too large to be printed, NumPy automatically skips the central part of the array and only prints the corners:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8325ebccad64f5436323a863f272d5f091c76c" translate="yes" xml:space="preserve">
          <source>If an element of &lt;code&gt;axes&lt;/code&gt; is larger than than the number of axes of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;axes&lt;/code&gt; 的元素大于 &lt;code&gt;a&lt;/code&gt; 的轴数。</target>
        </trans-unit>
        <trans-unit id="bc51d7d23e7dc12f32f8e1785a950a943342d4c8" translate="yes" xml:space="preserve">
          <source>If an index exceeds the dimension of the array along &lt;code&gt;axis&lt;/code&gt;, an empty sub-array is returned correspondingly.</source>
          <target state="translated">如果索引沿 &lt;code&gt;axis&lt;/code&gt; 超出数组的维数，则将相应返回一个空的子数组。</target>
        </trans-unit>
        <trans-unit id="d50315439445c5e53d7c5cb2eca5a37deb22722b" translate="yes" xml:space="preserve">
          <source>If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the &lt;a href=&quot;../glossary#term-ufunc&quot;&gt;ufunc&lt;/a&gt; will simply not step along that dimension (the &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;stride&lt;/a&gt; will be 0 for that dimension).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fec5dbaf9a5723fb1db21784554641e2d086b8" translate="yes" xml:space="preserve">
          <source>If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; will simply not step along that dimension (the &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;stride&lt;/a&gt; will be 0 for that dimension).</source>
          <target state="translated">如果输入形状的尺寸大小为1，则该尺寸中的第一个数据条目将用于沿该尺寸的所有计算。换句话说，&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt;的步进机械将根本不会沿该尺寸步进（该尺寸的&lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;跨度&lt;/a&gt;将为0）。</target>
        </trans-unit>
        <trans-unit id="981216fcb80286728db3aa0467d4b1e8a655fef5" translate="yes" xml:space="preserve">
          <source>If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if a were np.arange(a)</source>
          <target state="translated">如果是ndarray,则从它的元素中产生一个随机样本。如果是一个int,随机样本的产生就像np.arrange(a)一样。</target>
        </trans-unit>
        <trans-unit id="6bcff738f855376346fed2a54471feef4ca0479d" translate="yes" xml:space="preserve">
          <source>If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated from np.arange(a).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b055403a11a75cdadf358d2e4b16e4aaac100a0a" translate="yes" xml:space="preserve">
          <source>If an object is provided, its write method should take one argument, a string.</source>
          <target state="translated">如果提供了一个对象,它的写方法应该接受一个参数,一个字符串。</target>
        </trans-unit>
        <trans-unit id="c6eb2fb826e8cbc6182574444dd579783c5b9225" translate="yes" xml:space="preserve">
          <source>If any input is array_like, &lt;code&gt;pv&lt;/code&gt; returns an array of equal shape. Let&amp;rsquo;s compare different interest rates in the example above:</source>
          <target state="translated">如果有任何输入类似于array_like，则 &lt;code&gt;pv&lt;/code&gt; 返回形状相同的数组。让我们在上面的示例中比较不同的利率：</target>
        </trans-unit>
        <trans-unit id="ffa8ae9c8e4ca204b853aaf38ee0943c2276d1c9" translate="yes" xml:space="preserve">
          <source>If any input is array_like, returns an array of equal shape. Let&amp;rsquo;s compare different interest rates from the example above.</source>
          <target state="translated">如果有任何输入为array_like，则返回形状相同的数组。让我们比较上面示例中的不同利率。</target>
        </trans-unit>
        <trans-unit id="dce7db3f12e1e92b36fcbe9af677f929557b423e" translate="yes" xml:space="preserve">
          <source>If any read/write overlap exists, this flag ensures the result of the operation is the same as if all operands were copied. In cases where copies would need to be made, &lt;strong&gt;the result of the computation may be undefined without this flag!&lt;/strong&gt;</source>
          <target state="translated">如果存在任何读/写重叠，则此标志确保操作结果与复制所有操作数相同。在需要复制的情况下，如果&lt;strong&gt;没有该标志，则计算结果可能不确定！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e0c40f81e19502941982ef1a412a173673233b4" translate="yes" xml:space="preserve">
          <source>If any value in &lt;code&gt;alpha&lt;/code&gt; is less than or equal to zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8f0d595ba6a3701f0ba4d0bf45fa3cd44ca9ce" translate="yes" xml:space="preserve">
          <source>If any value in alpha is less than or equal to zero</source>
          <target state="translated">如果alpha中的任何数值小于或等于零</target>
        </trans-unit>
        <trans-unit id="bc219d3a8300527c6efa92537ff8d0dcdb1108df" translate="yes" xml:space="preserve">
          <source>If any write operand has overlap with any read operand, eliminate all overlap by making temporary copies (enabling UPDATEIFCOPY for write operands, if necessary). A pair of operands has overlap if there is a memory address that contains data common to both arrays.</source>
          <target state="translated">如果任何写操作数与任何读操作数有重叠,则通过制作临时副本来消除所有重叠(必要时为写操作数启用UPDATEIFCOPY)。如果有一个内存地址包含两个数组共同的数据,则一对操作数有重叠。</target>
        </trans-unit>
        <trans-unit id="2a45557faccf378e4b524258e3744f14e01d0549" translate="yes" xml:space="preserve">
          <source>If argument consists exclusively of int dtypes.</source>
          <target state="translated">如果参数完全由int dtypes组成。</target>
        </trans-unit>
        <trans-unit id="c785d849c18fc327cf9bee37bc11741d006f8fa7" translate="yes" xml:space="preserve">
          <source>If arguments are passed in with no keywords, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file, are &amp;lsquo;arr_0&amp;rsquo;, &amp;lsquo;arr_1&amp;rsquo;, etc. If keyword arguments are given, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file will match the keyword names.</source>
          <target state="translated">如果传入的参数没有关键字，则 &lt;code&gt;.npz&lt;/code&gt; 文件中的相应变量名称为'arr_0'，'arr_1'等。如果给出了关键字参数，则 &lt;code&gt;.npz&lt;/code&gt; 文件中的相应变量名称将与关键字名称。</target>
        </trans-unit>
        <trans-unit id="3d1c7a0f1e977aad5bcdfcdc2989a2f748b0274f" translate="yes" xml:space="preserve">
          <source>If array_like, the bin edges for the two dimensions (x_edges=y_edges=bins).</source>
          <target state="translated">如果是array_like,则是两个维度的bin边(x_edges=y_edges=bins)。</target>
        </trans-unit>
        <trans-unit id="8ad413f7fc8dfff3a6c2ee36c2613993e6279848" translate="yes" xml:space="preserve">
          <source>If at least one of &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is a non-string array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c56f840baa3a689fec388e92d6ba86ff952aa7" translate="yes" xml:space="preserve">
          <source>If at some point an existing Institutional Partner stops having any contributing employees, then a one year grace period commences. If at the end of this one year period they continue not to have any contributing employees, then their Institutional Partnership will lapse, and resuming it will require going through the normal process for new Partnerships.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a90d0b3d22bdc0f93b285a7398aa4703fe73214" translate="yes" xml:space="preserve">
          <source>If axis is 0, only rows are suppressed.</source>
          <target state="translated">如果轴为0,则只压制行。</target>
        </trans-unit>
        <trans-unit id="0782bc28993b5f00e72a0af1dcec69356d31839c" translate="yes" xml:space="preserve">
          <source>If axis is 1 or -1, only columns are suppressed.</source>
          <target state="translated">如果轴为1或-1,则只压制列。</target>
        </trans-unit>
        <trans-unit id="9506a7c18a807c059cd952ed93d5c51207a2a07d" translate="yes" xml:space="preserve">
          <source>If axis is None, both rows and columns are suppressed.</source>
          <target state="translated">如果轴为None,则行和列都被压制。</target>
        </trans-unit>
        <trans-unit id="c5149a1f08013bd4c50d9514785f4f44208d1f0b" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a product is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">如果 axis 是一个 ints 的元组,则在元组中指定的所有轴上执行乘积,而不是像之前那样在单个轴或所有轴上执行乘积。</target>
        </trans-unit>
        <trans-unit id="8de953aea1cde5c7cd7a932c7c1cd638dd5b48f8" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">如果 axis 是一个 ints 的元组,则在元组中指定的所有轴上进行求和,而不是像之前那样对单个轴或所有轴进行求和。</target>
        </trans-unit>
        <trans-unit id="b7d9ad0b67d074ec073be5ef4e15eeecb68acdae" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, averaging is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">如果 axis 是 ints 的元组,则对元组中指定的所有轴进行平均,而不是像之前那样对单个轴或所有轴进行平均。</target>
        </trans-unit>
        <trans-unit id="288d1e6c0a612db41ca8d2410d35c52a79ba7795" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, flipping is performed on all of the axes specified in the tuple.</source>
          <target state="translated">如果 axis 是 ints 的元组,则在元组中指定的所有轴上进行翻转。</target>
        </trans-unit>
        <trans-unit id="4a67a427d1a7cbcfc229fb55b05bdd5b239d1bd3" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 1-D arrays, it is inner product of vectors (without complex conjugation).</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 都是一维数组，则它是向量的内积（无复共轭）。</target>
        </trans-unit>
        <trans-unit id="c28be53ff292bd7a51506b92f27ed7a94fd2ec15" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2-D arrays, it is matrix multiplication, but using &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;matmul&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;a @ b&lt;/code&gt; is preferred.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 均为二维数组，则为矩阵乘法，但最好使用&lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;matmul&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;a @ b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="194f3cee9e7df2b602bf5ba80d6118fb502e2eaf" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;formats&lt;/code&gt; and &lt;code&gt;dtype&lt;/code&gt; are None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368fd1e825cc7f1439018ab086e3ca74379697e1" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;code&gt;NULL&lt;/code&gt;, then return &lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt;&lt;code&gt;PyArray_Nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;condition&lt;/em&gt;). Otherwise, both &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; must be given and the object returned is shaped like &lt;em&gt;condition&lt;/em&gt; and has elements of &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; where &lt;em&gt;condition&lt;/em&gt; is respectively True or False.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 均为 &lt;code&gt;NULL&lt;/code&gt; ，则返回&lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt; &lt;code&gt;PyArray_Nonzero&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;condition&lt;/em&gt;）。否则，必须同时给出&lt;em&gt;x&lt;/em&gt;和&lt;em&gt;y，&lt;/em&gt;并且返回的对象的形状类似于&lt;em&gt;condition&lt;/em&gt;并具有&lt;em&gt;x&lt;/em&gt;和&lt;em&gt;y的&lt;/em&gt;元素，其中&lt;em&gt;condition&lt;/em&gt;分别为True或False。</target>
        </trans-unit>
        <trans-unit id="7d34c61041bcc07e55093729fc859031c36d6999" translate="yes" xml:space="preserve">
          <source>If both arguments are 2-D they are multiplied like conventional matrices.</source>
          <target state="translated">如果两个参数都是二维的,它们就会像传统的矩阵一样相乘。</target>
        </trans-unit>
        <trans-unit id="bf26496158ed7aff00fe3f64e66aa6a508289463" translate="yes" xml:space="preserve">
          <source>If both positive and negative infinity are present, the sum will be Not A Number (NaN).</source>
          <target state="translated">如果同时存在正数和负数的无穷大,那么总和将是Not A数(NaN)。</target>
        </trans-unit>
        <trans-unit id="c6be65ffe7d2b7c519b021c7a585a65d749c5cc8" translate="yes" xml:space="preserve">
          <source>If both the name and type are specified, the &lt;strong&gt;Returns&lt;/strong&gt; section takes the same form as the &lt;strong&gt;Parameters&lt;/strong&gt; section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10140359cb73a0890a92d9b94e958a4d9feb7bea" translate="yes" xml:space="preserve">
          <source>If both the name and type are specified, the &lt;strong&gt;Yields&lt;/strong&gt; section takes the same form as the &lt;strong&gt;Returns&lt;/strong&gt; section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d89fb74ad22e53fe87d261e5d40a2d4a0331e92" translate="yes" xml:space="preserve">
          <source>If called with all arguments other than the warning class omitted, may be used as a context manager:</source>
          <target state="translated">如果调用时省略了除警告类以外的所有参数,可以作为上下文管理器使用。</target>
        </trans-unit>
        <trans-unit id="e1f9fb2b578de1420ef1d4182da3c75ca58e3552" translate="yes" xml:space="preserve">
          <source>If complex input returns a real array if complex parts are close to zero.</source>
          <target state="translated">如果复杂的输入部分接近于零,则返回一个实数组。</target>
        </trans-unit>
        <trans-unit id="4ec7acf826794e4e37207136e102eb50e7632b5f" translate="yes" xml:space="preserve">
          <source>If computation does not converge.</source>
          <target state="translated">如果计算不收敛。</target>
        </trans-unit>
        <trans-unit id="66501fc9abcadb23835ebb60ef928268453bb410" translate="yes" xml:space="preserve">
          <source>If condition is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, missing values are considered as &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">如果condition为&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;，则将缺少的值视为 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bd71f3d3293e73ba78bbdd8102f9b41323ceaaa" translate="yes" xml:space="preserve">
          <source>If copy is False and one of the inputs is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;, return a view of the other input mask. Defaults to False.</source>
          <target state="translated">如果copy为False并且输入之一为&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;，则返回另一个输入掩码的视图。默认为False。</target>
        </trans-unit>
        <trans-unit id="6d1cb15d43c2ba3971e5b54fc0a9bc261de3fb39" translate="yes" xml:space="preserve">
          <source>If data is passed to &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.PyArray_New&quot;&gt;&lt;code&gt;PyArray_New&lt;/code&gt;&lt;/a&gt;, this memory must not be deallocated until the new array is deleted. If this data came from another Python object, this can be accomplished using &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; on that object and setting the base member of the new array to point to that object. If strides are passed in they must be consistent with the dimensions, the itemsize, and the data of the array.</source>
          <target state="translated">如果将数据传递给&lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#c.PyArray_New&quot;&gt; &lt;code&gt;PyArray_New&lt;/code&gt; &lt;/a&gt;，则在删除新数组之前，不得释放该内存。如果此数据来自另一个Python对象，则可以使用该对象上的&lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt;并将新数组的基本成员设置为指向该对象来实现。如果传递了步幅，则步幅必须与维度，项目大小和数组数据一致。</target>
        </trans-unit>
        <trans-unit id="8cd71bec9bf23486f57ed709deb2da7e823cdd37" translate="yes" xml:space="preserve">
          <source>If defined, the axis of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; that defines the vector(s) and cross product(s). Overrides &lt;code&gt;axisa&lt;/code&gt;, &lt;code&gt;axisb&lt;/code&gt; and &lt;code&gt;axisc&lt;/code&gt;.</source>
          <target state="translated">如果定义，则定义矢量和叉积的 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 轴。覆盖 &lt;code&gt;axisa&lt;/code&gt; ， &lt;code&gt;axisb&lt;/code&gt; 和 &lt;code&gt;axisc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13711ea532b05dfaebf7f20551317865f1c997fe" translate="yes" xml:space="preserve">
          <source>If dtype is not supplied, this specifies the field names for the output dtype, in order. The field dtypes will be the same as the input array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0ca2bca36fd3ca611fb59e9f429be6ca1dfcef" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is 0-D (scalar), it is equivalent to &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;multiply&lt;/code&gt;&lt;/a&gt; and using &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; or &lt;code&gt;a * b&lt;/code&gt; is preferred.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt; 为0-D（标量），则等效于&lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;multiply&lt;/code&gt; &lt;/a&gt;并且最好使用 &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; 或 &lt;code&gt;a * b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="849e7230439a12b395b3d9d948e074f889418b25" translate="yes" xml:space="preserve">
          <source>If either argument is N-D, N &amp;gt; 2, it is treated as a stack of matrices residing in the last two indexes and broadcast accordingly.</source>
          <target state="translated">如果任何一个参数为ND，N&amp;gt; 2，则将其视为驻留在最后两个索引中的一组矩阵，并进行相应广播。</target>
        </trans-unit>
        <trans-unit id="cc8e18e241d0267fb4cce88d0332bc823b722b5a" translate="yes" xml:space="preserve">
          <source>If either array contains one or more NaNs, False is returned. Infs are treated as equal if they are in the same place and of the same sign in both arrays.</source>
          <target state="translated">如果任何一个数组包含一个或多个NaNs,则返回False。如果两个数组中的Infs在同一位置且符号相同,则被视为相等。</target>
        </trans-unit>
        <trans-unit id="281de8e5c6dae1e0aea9ae6d89d002bae88a2963" translate="yes" xml:space="preserve">
          <source>If element has complex type with zero complex part, the return value for that element is True.</source>
          <target state="translated">如果元素的复杂类型为零,则该元素的返回值为True。</target>
        </trans-unit>
        <trans-unit id="5d17dff94d5eaef97820ea5c6ea029508947d3b9" translate="yes" xml:space="preserve">
          <source>If factoring fails.</source>
          <target state="translated">如果保理失败。</target>
        </trans-unit>
        <trans-unit id="d31081e35606566d9542bf752ae043c7bb856921" translate="yes" xml:space="preserve">
          <source>If file is a string or a path-like object then that file is opened, else it is assumed to be a file object. The file object must support random access (i.e. it must have tell and seek methods).</source>
          <target state="translated">如果文件是一个字符串或类似路径的对象,那么该文件就会被打开,否则就会被认为是一个文件对象。文件对象必须支持随机访问(即它必须有告诉和寻找方法)。</target>
        </trans-unit>
        <trans-unit id="c92c0b980c98427841fd06fc2e90c17e3f8c8cf4" translate="yes" xml:space="preserve">
          <source>If filters are added and the &lt;code&gt;module&lt;/code&gt; keyword is given, the warning registry of this module will additionally be cleared when applying it, entering the context, or exiting it. This could cause warnings to appear a second time after leaving the context if they were configured to be printed once (default) and were already printed before the context was entered.</source>
          <target state="translated">如果添加了过滤器并指定了 &lt;code&gt;module&lt;/code&gt; 关键字，则在应用，进入上下文或退出该模块时，还将清除该模块的警告注册表。如果警告被配置为打印一次（默认）并且在进入上下文之前已经被打印，则警告可能会在离开上下文后第二次出现。</target>
        </trans-unit>
        <trans-unit id="aa86a09a4bd6f04a9393e4d4dd4d45d0b7a047d8" translate="yes" xml:space="preserve">
          <source>If formats is None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="translated">如果 formats 为 None,则会自动检测格式。使用tuples列表而不是list列表来加快处理速度。</target>
        </trans-unit>
        <trans-unit id="9c65522b5d0c56fc6284329915c9ff282e0a064e" translate="yes" xml:space="preserve">
          <source>If given and not &lt;code&gt;False&lt;/code&gt;, return not just the estimate but also its covariance matrix. By default, the covariance are scaled by chi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable except in a relative sense and everything is scaled such that the reduced chi2 is unity. This scaling is omitted if &lt;code&gt;cov='unscaled'&lt;/code&gt;, as is relevant for the case that the weights are 1/sigma**2, with sigma known to be a reliable estimate of the uncertainty.</source>
          <target state="translated">如果给出且不为 &lt;code&gt;False&lt;/code&gt; ，则不仅返回估计值，还返回其协方差矩阵。默认情况下，协方差按chi2 / sqrt（N-dof）进行缩放，即，权重假定为相对可靠（除非相对），并且所有内容均按比例缩放，以使减少的chi2统一。如果 &lt;code&gt;cov='unscaled'&lt;/code&gt; ，则忽略此缩放，这与权重为1 / sigma ** 2的情况有关，已知sigma是不确定性的可靠估计。</target>
        </trans-unit>
        <trans-unit id="4a01bcc692f66d3a6d58bd9dd10d9c51e6240bfa" translate="yes" xml:space="preserve">
          <source>If given, any string of the form &lt;code&gt;@key@&lt;/code&gt; will be replaced by &lt;code&gt;subst_dict[key]&lt;/code&gt; in the template file when installed. The install prefix is always available through the variable &lt;code&gt;@prefix@&lt;/code&gt;, since the install prefix is not easy to get reliably from setup.py.</source>
          <target state="translated">如果已提供，则在安装时，模板文件中所有格式为 &lt;code&gt;@key@&lt;/code&gt; 字符串都将替换为 &lt;code&gt;subst_dict[key]&lt;/code&gt; 。安装前缀始终可以通过变量 &lt;code&gt;@prefix@&lt;/code&gt; 来获得，因为从setup.py中很难轻易获得安装前缀。</target>
        </trans-unit>
        <trans-unit id="f229986316849fc58c19699184e093af0322102f" translate="yes" xml:space="preserve">
          <source>If given, should be a sequence of additional directories where to look for npy-pkg-config files. Those directories are searched prior to the NumPy directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282b0a219b18c48a317e72503d2100cde36f84f8" translate="yes" xml:space="preserve">
          <source>If given, the array must be of the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the domain. If None is given then the class domain is used. The default is None.</source>
          <target state="translated">如果给定，则数组的格式必须为 &lt;code&gt;[beg, end]&lt;/code&gt; ，其中 &lt;code&gt;beg&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 是域的端点。如果没有给出，则使用类域。默认为无。</target>
        </trans-unit>
        <trans-unit id="0dd507ea0f76e3b5e94e32d9b92c028c04854d11" translate="yes" xml:space="preserve">
          <source>If given, the resulting array must be if the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the window. If None is given then the class window is used. The default is None.</source>
          <target state="translated">如果给定，则结果数组必须为 &lt;code&gt;[beg, end]&lt;/code&gt; 形式，其中 &lt;code&gt;beg&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 是窗口的端点。如果没有给出，则使用类窗口。默认为无。</target>
        </trans-unit>
        <trans-unit id="d16d5189bfa0fff58db67c1477d4b5ae0a2a03f6" translate="yes" xml:space="preserve">
          <source>If given, this is returned for objects whose types can not be determined. If not given, None is returned for those objects.</source>
          <target state="translated">如果给定,对于那些类型无法确定的对象,将返回None。如果不给定,则对这些对象返回None。</target>
        </trans-unit>
        <trans-unit id="4c9471fb7a9f3abaf682e7276b2ee9a3f16f1ed9" translate="yes" xml:space="preserve">
          <source>If input array &lt;code&gt;a&lt;/code&gt; is not 2D.</source>
          <target state="translated">如果输入数组 &lt;code&gt;a&lt;/code&gt; 不是2D。</target>
        </trans-unit>
        <trans-unit id="03697161ee2c8ff90aa05356bdc85cfdd7ffe30e" translate="yes" xml:space="preserve">
          <source>If input is complex with all imaginary parts close to zero, return real parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f96f22e66784df0c0e7c7e7a77f909c0ac407de2" translate="yes" xml:space="preserve">
          <source>If input is the wrong shape (the input must be a 1-D or square 2-D array).</source>
          <target state="translated">如果输入是错误的形状(输入必须是一维或二维正方形阵列)。</target>
        </trans-unit>
        <trans-unit id="c9a78f52b99ab1c1f8aad79c5f4b73ab06b85a94" translate="yes" xml:space="preserve">
          <source>If instead, we replace our &lt;code&gt;super&lt;/code&gt; call with &lt;code&gt;getattr(ufunc, method)&lt;/code&gt;, we effectively do &lt;code&gt;np.add(a.view(np.ndarray), b)&lt;/code&gt;. Again, &lt;code&gt;B.__array_ufunc__&lt;/code&gt; will be called, but now it sees an &lt;code&gt;ndarray&lt;/code&gt; as the other argument. Likely, it will know how to handle this, and return a new instance of the &lt;code&gt;B&lt;/code&gt; class to us. Our example class is not set up to handle this, but it might well be the best approach if, e.g., one were to re-implement &lt;code&gt;MaskedArray&lt;/code&gt; using &lt;code&gt;__array_ufunc__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570a12b7ce63be7a2ce71fba3d8c9da77deb9d9d" translate="yes" xml:space="preserve">
          <source>If int, the number of bins for the two dimensions (nx=ny=bins).</source>
          <target state="translated">如果是int,则为两个维度的仓数(nx=ny=仓)。</target>
        </trans-unit>
        <trans-unit id="f4fb4d5bcb48df147e2cef0a0ea5928ac8067b9e" translate="yes" xml:space="preserve">
          <source>If it becomes necessary for the Steering Council to produce a formal decision, then they will use a form of the &lt;a href=&quot;https://www.apache.org/foundation/voting.html&quot;&gt;Apache Foundation voting process&lt;/a&gt;. This is a formalized version of consensus, in which +1 votes indicate agreement, -1 votes are vetoes (and must be accompanied with a rationale, as above), and one can also vote fractionally (e.g. -0.5, +0.5) if one wishes to express an opinion without registering a full veto. These numeric votes are also often used informally as a way of getting a general sense of people&amp;rsquo;s feelings on some issue, and should not normally be taken as formal votes. A formal vote only occurs if explicitly declared, and if this does occur then the vote should be held open for long enough to give all interested Council Members a chance to respond &amp;ndash; at least one week.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b4bbe660909db346ad59c7951f05bdd8332431" translate="yes" xml:space="preserve">
          <source>If it is necessary to explain a private method (use with care!), it can be referred to in the &lt;strong&gt;Extended Summary&lt;/strong&gt; or the &lt;strong&gt;Notes&lt;/strong&gt; section. Do not list private methods in the &lt;strong&gt;methods&lt;/strong&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2941a8c3ef7e42aa1704dd826466efd7a289a13" translate="yes" xml:space="preserve">
          <source>If it is not necessary to specify a keyword argument, use &lt;code&gt;optional&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14206cf495608dab3bc0c9563f466018da9e1b11" translate="yes" xml:space="preserve">
          <source>If it went wrong, recovery is again possible as explained &lt;a href=&quot;#recovering-from-mess-up&quot;&gt;above&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1bd74933e0b346982972b3334dd2af53c8b3cb" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, then filenames are taken from the keywords. If arguments are passed in with no keywords, then stored file names are arr_0, arr_1, etc.</source>
          <target state="translated">如果给了关键字参数,那么文件名就取自关键字。如果传入的参数没有关键字,那么存储的文件名就是arr_0、arr_1等。</target>
        </trans-unit>
        <trans-unit id="a05e5457e182b0de28998599a17f81c2384bc52a" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, then filenames are taken from the keywords. If arguments are passed in with no keywords, then stored filenames are arr_0, arr_1, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f5690b1b20b80392957d2cc602580121727a3e" translate="yes" xml:space="preserve">
          <source>If list depths are mismatched - for instance, &lt;code&gt;[[a, b], c]&lt;/code&gt; is illegal, and should be spelt &lt;code&gt;[[a, b], [c]]&lt;/code&gt;</source>
          <target state="translated">如果列表深度不匹配-例如 &lt;code&gt;[[a, b], c]&lt;/code&gt; 是非法的，应将其拼写为 &lt;code&gt;[[a, b], [c]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f609da24233a507af66f8b7969941dc9c31d8838" translate="yes" xml:space="preserve">
          <source>If lists are empty - for instance, &lt;code&gt;[[a, b], []]&lt;/code&gt;</source>
          <target state="translated">如果列表为空-例如 &lt;code&gt;[[a, b], []]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0fa6317253cb5f3105874e72d36c2e7ed1eb2af" translate="yes" xml:space="preserve">
          <source>If multi-dimension input, returns a new ndarray of indices to the minimum values along the given axis. Otherwise, returns a scalar of index to the minimum values along the given axis.</source>
          <target state="translated">如果是多维度的输入,返回一个新的ndarray的指数,沿给定轴的最小值。否则,返回沿给定轴的最小值的索引标量。</target>
        </trans-unit>
        <trans-unit id="3be2da634ae4e1a50b6a61b6e2a72b4b4858161d" translate="yes" xml:space="preserve">
          <source>If necessary, will be flattened before the differences are taken.</source>
          <target state="translated">如有必要,将在取差前进行平整。</target>
        </trans-unit>
        <trans-unit id="301925ec926932bb64f4f4002e984f88f86a2131" translate="yes" xml:space="preserve">
          <source>If needed create a new C-structure to handle each instance of your type. A typical C-structure would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a3c8652ca0e3dccf381651d80f187b5ac1a5a74" translate="yes" xml:space="preserve">
          <source>If neither is defined, the C-API is declared to be &lt;code&gt;static void**&lt;/code&gt;, so it is only visible within the compilation unit that #includes numpy/arrayobject.h.</source>
          <target state="translated">如果两个都没有定义，则C-API被声明为 &lt;code&gt;static void**&lt;/code&gt; ，因此它仅在#includes numpy / arrayobject.h的编译单元中可见。</target>
        </trans-unit>
        <trans-unit id="853b03d065feffbc6ac6731a7bbb396016c51c2b" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;__array_function__&lt;/code&gt; methods exists, NumPy will default to calling its own implementation, intended for use on NumPy arrays. This case arises, for example, when all array-like arguments are Python numbers or lists. (NumPy arrays do have a &lt;code&gt;__array_function__&lt;/code&gt; method, given below, but it always returns &lt;code&gt;NotImplemented&lt;/code&gt; if any argument other than a NumPy array subclass implements &lt;code&gt;__array_function__&lt;/code&gt;.)</source>
          <target state="translated">如果不存在 &lt;code&gt;__array_function__&lt;/code&gt; 方法，则NumPy将默认调用其自己的实现，该实现用于NumPy数组。例如，当所有类似数组的参数都是Python数字或列表时，就会出现这种情况。（NumPy数组确实具有 &lt;code&gt;__array_function__&lt;/code&gt; 方法，如下所示，但是如果NumPy数组子类以外的任何参数实现 &lt;code&gt;__array_function__&lt;/code&gt; ，则它始终返回 &lt;code&gt;NotImplemented&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="9e9935f1dd70f7a86b993ae6eeed6ce9464e1229" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;intent(in | inout | out | hide)&lt;/code&gt; is specified, &lt;code&gt;intent(in)&lt;/code&gt; is assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505142361ce7d844b31c251e5147e86fce3849fd" translate="yes" xml:space="preserve">
          <source>If none of the inputs overrides the ufunc, then all output arrays will be passed to the &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; methods of the input (besides &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;, and scalars) that defines it &lt;strong&gt;and&lt;/strong&gt; has the highest &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of any other input to the universal function. The default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of the ndarray is 0.0, and the default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of a subtype is 0.0. Matrices have &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; equal to 10.0.</source>
          <target state="translated">如果没有输入覆盖ufunc，那么所有的输出阵列将被传递到&lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;输入的方法（除了&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;，和标量）定义它&lt;strong&gt;和&lt;/strong&gt;具有最高&lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;任何其他输入到通用的功能。默认&lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;的ndarray的是0.0，而默认&lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;亚型的是0.0。矩阵的&lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;等于10.0。</target>
        </trans-unit>
        <trans-unit id="96625db984c22cd52ed20b5b293895185469b2c4" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; normalization is by &lt;code&gt;(N - ddof)&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of observations; this overrides the value implied by &lt;code&gt;bias&lt;/code&gt;. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果不是 &lt;code&gt;None&lt;/code&gt; 正常化是通过 &lt;code&gt;(N - ddof)&lt;/code&gt; ，其中 &lt;code&gt;N&lt;/code&gt; 是观测数目; 这将覆盖由 &lt;code&gt;bias&lt;/code&gt; 隐含的值。默认值为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e98fcdb4d2a9bfdfbe2eeae9c39d82ef88da39fa" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; the default value implied by &lt;code&gt;bias&lt;/code&gt; is overridden. Note that &lt;code&gt;ddof=1&lt;/code&gt; will return the unbiased estimate, even if both &lt;code&gt;fweights&lt;/code&gt; and &lt;code&gt;aweights&lt;/code&gt; are specified, and &lt;code&gt;ddof=0&lt;/code&gt; will return the simple average. See the notes for the details. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果不是&amp;ldquo; &lt;code&gt;None&lt;/code&gt; 则将覆盖由 &lt;code&gt;bias&lt;/code&gt; 隐含的默认值。请注意，即使同时指定了 &lt;code&gt;fweights&lt;/code&gt; 和 &lt;code&gt;aweights&lt;/code&gt; ， &lt;code&gt;ddof=1&lt;/code&gt; 也将返回无偏估计，而 &lt;code&gt;ddof=0&lt;/code&gt; 将返回简单平均值。有关详细信息，请参见注释。默认值为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcf87e157fa41fe29ae78434e407f9e7ee68fcea" translate="yes" xml:space="preserve">
          <source>If not None, the keys should indicate the type(s) that the respective formatting function applies to. Callables should return a string. Types that are not specified (by their corresponding keys) are handled by the default formatters. Individual types for which a formatter can be set are:</source>
          <target state="translated">如果不是None,则键应表示各自的格式化函数所适用的类型。可调用函数应该返回一个字符串。未指定的类型(由其对应的键)由默认格式化器处理。可以设置格式化器的单个类型有:。</target>
        </trans-unit>
        <trans-unit id="bb477c8d5a32ba9dc9b4018fd2f3af6fa9009c49" translate="yes" xml:space="preserve">
          <source>If not None, the specified domain is used instead of that of the calling instance. It should be of the form &lt;code&gt;[beg,end]&lt;/code&gt;. The default is None which case the class domain is used.</source>
          <target state="translated">如果不是None，则使用指定的域而不是调用实例的域。它的形式应为 &lt;code&gt;[beg,end]&lt;/code&gt; 。默认值为无，在这种情况下将使用类域。</target>
        </trans-unit>
        <trans-unit id="9fd5a8f72ea35597060cfb26a58e00837b4119cd" translate="yes" xml:space="preserve">
          <source>If not None, then memory-map the file, using the given mode (see &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt;&lt;code&gt;numpy.memmap&lt;/code&gt;&lt;/a&gt; for a detailed description of the modes). A memory-mapped array is kept on disk. However, it can be accessed and sliced like any ndarray. Memory mapping is especially useful for accessing small fragments of large files without reading the entire file into memory.</source>
          <target state="translated">如果不是None，则使用给定的模式对文件进行内存映射（有关模式的详细说明，请参见&lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt; &lt;code&gt;numpy.memmap&lt;/code&gt; &lt;/a&gt;）。内存映射的阵列保留在磁盘上。但是，可以像访问任何ndarray一样对其进行访问和切片。内存映射对于访问大文件的小片段而不将整个文件读入内存特别有用。</target>
        </trans-unit>
        <trans-unit id="1dde66b48fa13cf03c30ed219d07e5b09a8bd837" translate="yes" xml:space="preserve">
          <source>If obj is an ndarray (&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt;), then the data-area of the ndarray is pointed to by the void* pointer &lt;a href=&quot;../reference/c-api/array#c.PyArray_DATA&quot;&gt;&lt;code&gt;PyArray_DATA&lt;/code&gt;&lt;/a&gt; (obj) or the char* pointer &lt;a href=&quot;../reference/c-api/array#c.PyArray_BYTES&quot;&gt;&lt;code&gt;PyArray_BYTES&lt;/code&gt;&lt;/a&gt; (obj). Remember that (in general) this data-area may not be aligned according to the data-type, it may represent byte-swapped data, and/or it may not be writeable. If the data area is aligned and in native byte-order, then how to get at a specific element of the array is determined only by the array of npy_intp variables, &lt;a href=&quot;../reference/c-api/array#c.PyArray_STRIDES&quot;&gt;&lt;code&gt;PyArray_STRIDES&lt;/code&gt;&lt;/a&gt; (obj). In particular, this c-array of integers shows how many &lt;strong&gt;bytes&lt;/strong&gt; must be added to the current element pointer to get to the next element in each dimension. For arrays less than 4-dimensions there are &lt;code&gt;PyArray_GETPTR{k}&lt;/code&gt; (obj, &amp;hellip;) macros where {k} is the integer 1, 2, 3, or 4 that make using the array strides easier. The arguments &amp;hellip;. represent {k} non- negative integer indices into the array. For example, suppose &lt;code&gt;E&lt;/code&gt; is a 3-dimensional ndarray. A (void*) pointer to the element &lt;code&gt;E[i,j,k]&lt;/code&gt; is obtained as &lt;a href=&quot;../reference/c-api/array#c.PyArray_GETPTR3&quot;&gt;&lt;code&gt;PyArray_GETPTR3&lt;/code&gt;&lt;/a&gt; (E, i, j, k).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9280c1d0944bd8756c1f5111dc408efcc4ac592a" translate="yes" xml:space="preserve">
          <source>If offsets were specified using the optional &lt;code&gt;offsets&lt;/code&gt; key in the dictionary-based dtype specification, setting &lt;code&gt;align=True&lt;/code&gt; will check that each field&amp;rsquo;s offset is a multiple of its size and that the itemsize is a multiple of the largest field size, and raise an exception if not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8ee117c63f729e22bf227e3e07bb22de12fa90" translate="yes" xml:space="preserve">
          <source>If one argument: a scalar, only used in case &lt;code&gt;a&lt;/code&gt; is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</source>
          <target state="translated">如果一个参数：一标量，只有在情况下使用 &lt;code&gt;a&lt;/code&gt; 是大小为1，如果两个参数：最后一个参数是要设置的值，并且必须是一个标量，该第一参数指定的单个阵列元素位置。它是一个int或一个元组。</target>
        </trans-unit>
        <trans-unit id="57c6aeb84d68fcc852763a7a13de57615e4d20cf" translate="yes" xml:space="preserve">
          <source>If one does need to invoke a formal veto, then it should consist of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="071afc2f1bb001ecc847b5f0833d4155cd8fca5d" translate="yes" xml:space="preserve">
          <source>If one of the commands breaks in the middle, which is not uncommon, you may need to selectively upload the remaining files because PyPI does not allow the same file to be uploaded twice. The source file should be uploaded last to avoid synchronization problems if pip users access the files while this is in process. Note that PyPI only allows a single source distribution, here we have chosen the zip archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6981fed895201194d2f8c788e92aaa4d462ed21a" translate="yes" xml:space="preserve">
          <source>If one of the input or output arguments has a &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, it is executed &lt;em&gt;instead&lt;/em&gt; of the ufunc. If more than one of the arguments implements &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;, they are tried in the order: subclasses before superclasses, inputs before outputs, otherwise left to right. The first routine returning something other than &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; determines the result. If all of the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; operations return &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">如果输入或输出参数之一具有&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;方法，则将执行该方法&lt;em&gt;而不是&lt;/em&gt; ufunc。如果多个参数实现&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;，则按以下顺序尝试：子类在超类之前，输入在输出之前，否则从左到右。返回非&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt;以外的东西的第一个例程确定结果。如果所有&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;操作都返回&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt;，则引发&lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="078513303dc00f49a54bb48b4a05d01efff2507a" translate="yes" xml:space="preserve">
          <source>If one or more elements differ by more than &lt;code&gt;maxulp&lt;/code&gt;.</source>
          <target state="translated">如果一个或多个元素的差异大于 &lt;code&gt;maxulp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00b891e47fe38237c020d297bb43b5693729c6dd" translate="yes" xml:space="preserve">
          <source>If one throws a die repeatedly until the third time a &amp;ldquo;1&amp;rdquo; appears, then the probability distribution of the number of non-&amp;ldquo;1&amp;rdquo;s that appear before the third &amp;ldquo;1&amp;rdquo; is a negative binomial distribution.</source>
          <target state="translated">如果一个人反复掷骰子直到第三次出现&amp;ldquo; 1&amp;rdquo;，那么出现在第三次&amp;ldquo; 1&amp;rdquo;之前的非&amp;ldquo; 1&amp;rdquo;数目的概率分布为负二项式分布。</target>
        </trans-unit>
        <trans-unit id="f25e55ccd77b879343ce3ca049a9d0e4b78987e8" translate="yes" xml:space="preserve">
          <source>If one uses the same dimension name in multiple locations, this enforces the same size of the corresponding dimensions.</source>
          <target state="translated">如果在多个位置使用相同的维度名称,这将强制执行相应维度的相同大小。</target>
        </trans-unit>
        <trans-unit id="341d0c5af878a988a0ac05e9410e510da00aae4c" translate="yes" xml:space="preserve">
          <source>If operand flags &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; are used the operands may be views into the original data with the &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag. In this case &lt;a href=&quot;#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; must be used as a context manager or the &lt;a href=&quot;numpy.nditer.close#numpy.nditer.close&quot;&gt;&lt;code&gt;nditer.close&lt;/code&gt;&lt;/a&gt; method must be called before using the result. The temporary data will be written back to the original data when the &lt;code&gt;__exit__&lt;/code&gt; function is called but not before:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d0e3c2e03d57620541ba508399723e46a30af16" translate="yes" xml:space="preserve">
          <source>If operand flags &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; are used the operands may be views into the original data with the &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag. In this case nditer must be used as a context manager or the nditer.close method must be called before using the result. The temporary data will be written back to the original data when the &lt;code&gt;__exit__&lt;/code&gt; function is called but not before:</source>
          <target state="translated">如果使用操作数标志 &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; 或 &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; ，则操作数可能是带有 &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; 标志的原始数据视图。在这种情况下，必须将nditer用作上下文管理器，或者必须在使用结果之前调用nditer.close方法。当调用 &lt;code&gt;__exit__&lt;/code&gt; 函数时，临时数据将被写回到原始数据，但不会在此之前：</target>
        </trans-unit>
        <trans-unit id="6bcdbb4b2db72f15cd471674f6106b51d73bea1c" translate="yes" xml:space="preserve">
          <source>If our array has more than two dimensions, then the SVD can be applied to all axes at once. However, the linear algebra functions in NumPy expect to see an array of the form &lt;code&gt;(N, M, M)&lt;/code&gt;, where the first axis represents the number of matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7979a86d632f406a43fda9a7bbc242f0b6aa48c1" translate="yes" xml:space="preserve">
          <source>If out is given and does not have a mask attribute, the mask of a is lost!</source>
          <target state="translated">如果给了out,并且没有 mask属性,那么a的 mask就会丢失!</target>
        </trans-unit>
        <trans-unit id="540ba134ebef3a60b12504ba1dddaea7cf0cec06" translate="yes" xml:space="preserve">
          <source>If passed a single ndarray or scalar (a nested list of depth 0), this is returned unmodified (and not copied).</source>
          <target state="translated">如果传递的是单个ndarray或标量(深度为0的嵌套列表),则会不加修改地返回(而不是复制)。</target>
        </trans-unit>
        <trans-unit id="96808216b5aaeeafcea0d1c6dd5a1e0894eaaeca" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">如果提供正int_like参数，&lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt;产生形状的阵列 &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; ，填充有从单变量采样随机浮点数均值为0，方差为1的单个浮子的&amp;ldquo;正常&amp;rdquo;（高斯）分布如果未提供任何参数，则从分布中随机抽样。</target>
        </trans-unit>
        <trans-unit id="6cd43f42d93868c2f881ad2d0e04b27cc3b3d230" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfcb0d73efeb90f5b4e3ce5ebdfcfa5192159dee" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;numpy.random.randn#numpy.random.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55be54163f14c3cf436fe9e5956719fe1ba33eba" translate="yes" xml:space="preserve">
          <source>If provided, forces the calculation to use the data type specified. Note that you may have to also give a more liberal &lt;code&gt;casting&lt;/code&gt; parameter to allow the conversions. Default is None.</source>
          <target state="translated">如果提供，则强制计算使用指定的数据类型。请注意，您可能还必须提供一个更宽松的 &lt;code&gt;casting&lt;/code&gt; 参数以允许进行转换。默认为无。</target>
        </trans-unit>
        <trans-unit id="e083348afe334fd6151280febab9e53c63ddbb1c" translate="yes" xml:space="preserve">
          <source>If provided, is a list of ints or None for each operands. The list of axes for an operand is a mapping from the dimensions of the iterator to the dimensions of the operand. A value of -1 can be placed for entries, causing that dimension to be treated as &lt;a href=&quot;../constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果提供，则为每个操作数的整数或无列表。操作数的轴列表是从迭代器的尺寸到操作数的尺寸的映射。可以为输入放置值-1，从而将该尺寸视为&lt;a href=&quot;../constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5d381c2d7955b7fd1c70c985e306d9e2f555e38" translate="yes" xml:space="preserve">
          <source>If provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;). If array-like, must contain integer values</source>
          <target state="translated">如果提供，则从分布中得出的最大（有符号）整数上方一个整数（如果 &lt;code&gt;high=None&lt;/code&gt; ,请参见上面的行为）。如果为数组，则必须包含整数值</target>
        </trans-unit>
        <trans-unit id="95838d6d878826fc55d5a3e35ced6032cc48a529" translate="yes" xml:space="preserve">
          <source>If provided, the calculation is done into this array.</source>
          <target state="translated">如果提供,则计算到这个数组中。</target>
        </trans-unit>
        <trans-unit id="af1a016b36ff8a1ba521445122b451501db1dbf6" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what concatenate would have returned if no out argument were specified.</source>
          <target state="translated">如果提供,则是放置结果的目的地。形状必须正确,与没有指定out参数的情况下concat返回的形状一致。</target>
        </trans-unit>
        <trans-unit id="c1c663fe8abb225f988d791716021ba47f8cdb72" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what stack would have returned if no out argument were specified.</source>
          <target state="translated">如果提供,则是放置结果的目的地。形状必须正确,与没有指定out参数时堆栈返回的形状一致。</target>
        </trans-unit>
        <trans-unit id="f5316b9b72a00d5e03e3e99cc76713f526033f92" translate="yes" xml:space="preserve">
          <source>If provided, the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;).</source>
          <target state="translated">如果提供，则从分布中得出最大（有符号）整数（如果 &lt;code&gt;high=None&lt;/code&gt; ,请参见上面的行为）。</target>
        </trans-unit>
        <trans-unit id="95c405f27ca318550aa8a5e9d68fd036459e5597" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">如果提供，结果将被插入此数组。它应该具有适当的形状和 &lt;code&gt;dtype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5aa5842b82d356df663381019439d99b6de6d45f" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype.</source>
          <target state="translated">如果提供,结果将被插入到这个数组中。它应该是适当的形状和dtype。</target>
        </trans-unit>
        <trans-unit id="cb7c8c85e64a3a49b66549989ff45cf1e28fbfc9" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">如果提供，结果将被插入此数组。它应该具有适当的形状和dtype。注意，如果 &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; ，则 &lt;code&gt;out&lt;/code&gt; 总是被缓冲；使用其他模式以获得更好的性能。</target>
        </trans-unit>
        <trans-unit id="81a5da5dc747b4213d85b5feaae67db0441d8c96" translate="yes" xml:space="preserve">
          <source>If provided, the result will be placed in this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">如果提供，结果将放置在此数组中。它应该具有适当的形状和dtype。注意，如果 &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; ，则 &lt;code&gt;out&lt;/code&gt; 总是被缓冲；使用其他模式以获得更好的性能。</target>
        </trans-unit>
        <trans-unit id="930ff5cfb0e50021c5f5a8e94b02d45dd7e7a78b" translate="yes" xml:space="preserve">
          <source>If provided, this array is filled with the result.</source>
          <target state="translated">如果提供了,这个数组将被填入结果。</target>
        </trans-unit>
        <trans-unit id="11fa623532ff8e1a6968612e0395b44c20331e38" translate="yes" xml:space="preserve">
          <source>If set to False, the returned array will always be readonly. Otherwise it will be writable if the original array was. It is advisable to set this to False if possible (see Notes).</source>
          <target state="translated">如果设置为False,返回的数组将始终是只读的。否则,如果原始数组是可写的,那么它将是可写的。如果可能的话,建议将其设置为False(见注释)。</target>
        </trans-unit>
        <trans-unit id="2bff5e445257625fab4df9171fbb5cbef9e23081" translate="yes" xml:space="preserve">
          <source>If set to the string &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; enables 1.13 legacy printing mode. This approximates numpy 1.13 print output by including a space in the sign position of floats and different behavior for 0d arrays. If set to &lt;code&gt;False&lt;/code&gt;, disables legacy mode. Unrecognized strings will be ignored with a warning for forward compatibility.</source>
          <target state="translated">如果设置为字符串 &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; 启用1.13旧版打印模式。通过在浮点数的符号位置包含一个空格以及0d数组的不同行为，这近似于numpy 1.13打印输出。如果设置为 &lt;code&gt;False&lt;/code&gt; ，则禁用旧模式。无法识别的字符串将被警告，并带有向前兼容性的警告。</target>
        </trans-unit>
        <trans-unit id="fe72d8f764239876f5476ff64d033c4aa157117d" translate="yes" xml:space="preserve">
          <source>If slice notation is used, the syntax &lt;code&gt;start:stop:step&lt;/code&gt; is equivalent to &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; inside of the brackets. However, if &lt;code&gt;step&lt;/code&gt; is an imaginary number (i.e. 100j) then its integer portion is interpreted as a number-of-points desired and the start and stop are inclusive. In other words &lt;code&gt;start:stop:stepj&lt;/code&gt; is interpreted as &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; inside of the brackets. After expansion of slice notation, all comma separated sequences are concatenated together.</source>
          <target state="translated">如果使用切片符号，则语法 &lt;code&gt;start:stop:step&lt;/code&gt; 等效于方括号内的 &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; 。但是，如果 &lt;code&gt;step&lt;/code&gt; 是一个虚数（即100j），则将其整数部分解释为所需的点数，并且开始和结束都包括在内。换句话说， &lt;code&gt;start:stop:stepj&lt;/code&gt; 被解释为方括号内的 &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; 。切片符号扩展后，所有逗号分隔的序列将连接在一起。</target>
        </trans-unit>
        <trans-unit id="81a87ade0c2eb6eb2f3e1b57567f9837157177e2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected (and &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt;), a &lt;code&gt;RankWarning&lt;/code&gt; will be raised. This means that the coefficient values may be poorly determined. Fitting to a lower order polynomial will usually get rid of the warning (but may not be what you want, of course; if you have independent reason(s) for choosing the degree which isn&amp;rsquo;t working, you may have to: a) reconsider those reasons, and/or b) reconsider the quality of your data). The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">如果 &lt;code&gt;V&lt;/code&gt; 的某些奇异值太小以至于它们被忽略（并且 &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt; ），则将引发 &lt;code&gt;RankWarning&lt;/code&gt; 。这意味着系数值可能难以确定。拟合低阶多项式通常会摆脱警告（但不一定是您想要的警告；当然，如果您有选择不起作用的次数的独立原因，则可能必须：a）重新考虑这些原因，和/或b）重新考虑数据的质量）。也可以将 &lt;code&gt;rcond&lt;/code&gt; 参数设置为小于其默认值的值，但是最终的拟合可能是虚假的，并且由于舍入误差而产生很大的影响。</target>
        </trans-unit>
        <trans-unit id="279580d9404d9230f24c863b3bff92a3996533c2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected, then a &lt;code&gt;RankWarning&lt;/code&gt; will be issued. This means that the coefficient values may be poorly determined. Using a lower order fit will usually get rid of the warning. The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">如果 &lt;code&gt;V&lt;/code&gt; 的某些奇异值太小以至于它们被忽略，则将发出 &lt;code&gt;RankWarning&lt;/code&gt; 。这意味着系数值可能难以确定。使用低阶拟合通常会摆脱警告。也可以将 &lt;code&gt;rcond&lt;/code&gt; 参数设置为小于其默认值的值，但是结果拟合可能是虚假的，并且由于舍入误差而产生很大的影响。</target>
        </trans-unit>
        <trans-unit id="965baa6e6f17f07c36f67c069da20d4c8b056bfe" translate="yes" xml:space="preserve">
          <source>If sparse is False:</source>
          <target state="translated">如果稀疏为False。</target>
        </trans-unit>
        <trans-unit id="d3cfaef438df28358b3d4e747b777d350c839464" translate="yes" xml:space="preserve">
          <source>If sparse is True:</source>
          <target state="translated">如果稀疏为真。</target>
        </trans-unit>
        <trans-unit id="da499c4730990d0eca07f07d81ecedd5eee01e35" translate="yes" xml:space="preserve">
          <source>If sparse is set to true, the grid will be returned in a sparse representation.</source>
          <target state="translated">如果sparse被设置为true,网格将以稀疏的方式返回。</target>
        </trans-unit>
        <trans-unit id="a0b2e0085e9bacd8c444b0a0e2e8508a5f8b81ab" translate="yes" xml:space="preserve">
          <source>If specified, all the fields will be changed to the provided byte-order. Otherwise, the default byte-order is used. For all available string specifiers, see &lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt;&lt;code&gt;dtype.newbyteorder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果指定，所有字段将更改为提供的字节顺序。否则，将使用默认字节顺序。有关所有可用的字符串说明符，请参见&lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt; &lt;code&gt;dtype.newbyteorder&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="524227865d52e8b4442de30061c3ce0262f46831" translate="yes" xml:space="preserve">
          <source>If specified, it must be a tuple or list which contains a permutation of [0,1,..,N-1] where N is the number of axes of a. The i&amp;rsquo;th axis of the returned array will correspond to the axis numbered &lt;code&gt;axes[i]&lt;/code&gt; of the input. If not specified, defaults to &lt;code&gt;range(a.ndim)[::-1]&lt;/code&gt;, which reverses the order of the axes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f824fc5934f1c56555b7168823af2d5da98b5dab" translate="yes" xml:space="preserve">
          <source>If state is a dictionary, it is directly set using the BitGenerators &lt;code&gt;state&lt;/code&gt; property.</source>
          <target state="translated">如果state是字典，则可以使用BitG​​enerators &lt;code&gt;state&lt;/code&gt; 属性直接设置它。</target>
        </trans-unit>
        <trans-unit id="8bed509b136f4d80f9b83488488a97c842996d12" translate="yes" xml:space="preserve">
          <source>If steps 1 and 2 are done correctly, compiling the release should not give a warning &amp;ldquo;API mismatch detect at the beginning of the build&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc779ce22e3bc8704e258c3f6aa49989598231f" translate="yes" xml:space="preserve">
          <source>If the (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flags are set, it has a different meaning, namely base is the array into which the current array will be copied upon copy resolution. This overloading of the base property for two functions is likely to change in a future version of NumPy.</source>
          <target state="translated">如果设置了（不建议使用的）&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;标志，则它具有不同的含义，即base是在复制分辨率下将当前数组复制到的数组。两个函数的基本属性的重载可能会在NumPy的未来版本中改变。</target>
        </trans-unit>
        <trans-unit id="cfe3d233f0d1b6d420d00f98b03a5ffbba4bbec2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; attribute is a CObject, then the pointer must be a pointer to a function with the signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7883df78258ee376bc6906db165b3539bd009bc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; attribute is not None nor a CObject, then it must be a Python method that takes the parent array as an argument (which could be None if there is no parent), and returns nothing. Errors in this method will be caught and handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35bc1249e520730be2802640a0588a9755304660" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object is a structured array the &lt;a href=&quot;../glossary#term-field&quot;&gt;fields&lt;/a&gt; of the array can be accessed by indexing the array with strings, dictionary-like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f501c2023177671c00839603f74082e5dd3d055" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object is a structured array the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;fields&lt;/a&gt; of the array can be accessed by indexing the array with strings, dictionary-like.</source>
          <target state="translated">如果&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;对象是结构化数组，则可以通过使用类似于字典的字符串对数组进行索引来访问数组的&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;字段&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0646be9a4620b324160297ec7386ae7d381a6d92" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;order&lt;/code&gt; keyword argument is specified. This behaviour is a bug in NumPy.</source>
          <target state="translated">如果指定了 &lt;code&gt;order&lt;/code&gt; 关键字参数。此行为是NumPy中的错误。</target>
        </trans-unit>
        <trans-unit id="95474ba24abf246463d023b7d37164eff549d001" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;width&lt;/code&gt; value is insufficient, it will be ignored, and &lt;code&gt;num&lt;/code&gt; will be returned in binary (&lt;code&gt;num&lt;/code&gt; &amp;gt; 0) or two&amp;rsquo;s complement (&lt;code&gt;num&lt;/code&gt; &amp;lt; 0) form with its width equal to the minimum number of bits needed to represent the number in the designated form. This behavior is deprecated and will later raise an error.</source>
          <target state="translated">如果 &lt;code&gt;width&lt;/code&gt; 值不足，它将被忽略，并且 &lt;code&gt;num&lt;/code&gt; 将以二进制（ &lt;code&gt;num&lt;/code&gt; &amp;gt; 0）或二进制补码（ &lt;code&gt;num&lt;/code&gt; &amp;lt;0）的形式返回，其宽度等于表示数字中所需的最小位数。指定表格。不建议使用此行为，以后将引发错误。</target>
        </trans-unit>
        <trans-unit id="e55f68c7edc654033798e55316d9b9691f5ca17e" translate="yes" xml:space="preserve">
          <source>If the API has changed, increment the C_API_VERSION in setup_common.py. The API is unchanged only if any code compiled against the current API will be backward compatible with the last released NumPy version. Any changes to C structures or additions to the public interface will make the new API not backward compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="846345b681ee07e5dd05c26de91938c5750e96ed" translate="yes" xml:space="preserve">
          <source>If the C_API_VERSION in the first step has changed, or if the hash of the API has changed, the cversions.txt file needs to be updated. To check the hash, run the script numpy/core/cversions.py and note the API hash that is printed. If that hash does not match the last hash in numpy/core/code_generators/cversions.txt the hash has changed. Using both the appropriate C_API_VERSION and hash, add a new entry to cversions.txt. If the API version was not changed, but the hash differs, you will need to comment out the previous entry for that API version. For instance, in NumPy 1.9 annotations were added, which changed the hash, but the API was the same as in 1.8. The hash serves as a check for API changes, but it is not definitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307258bcc851f5976aadd2f56343dad80fcf2a38" translate="yes" xml:space="preserve">
          <source>If the PR relates to any issues, you can add the text &lt;code&gt;xref gh-xxxx&lt;/code&gt; where &lt;code&gt;xxxx&lt;/code&gt; is the number of the issue to github comments. Likewise, if the PR solves an issue, replace the &lt;code&gt;xref&lt;/code&gt; with &lt;code&gt;closes&lt;/code&gt;, &lt;code&gt;fixes&lt;/code&gt; or any of the other flavors &lt;a href=&quot;https://help.github.com/en/articles/closing-issues-using-keywords&quot;&gt;github accepts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049594537957d0705cc457b562940a40a3ed3347" translate="yes" xml:space="preserve">
          <source>If the SVD computation does not converge.</source>
          <target state="translated">如果SVD计算不收敛。</target>
        </trans-unit>
        <trans-unit id="532b7abf588e485b512986621b48cdfb34aabd33" translate="yes" xml:space="preserve">
          <source>If the Sphinx build issues a warning of the form &lt;code&gt;WARNING: Unknown target name: &quot;example&quot;&lt;/code&gt;, then that is what is happening. To avoid this problem, use the inline hyperlink form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f36babe99dcf796b7778a9ef584cf09c04cb03" translate="yes" xml:space="preserve">
          <source>If the accessed field is a sub-array, the dimensions of the sub-array are appended to the shape of the result.</source>
          <target state="translated">如果访问的字段是一个子数组,子数组的尺寸会附加到结果的形状上。</target>
        </trans-unit>
        <trans-unit id="7e63ccdf53ce8ac8b2fb2a0fbc4aad1e23cbc4dc" translate="yes" xml:space="preserve">
          <source>If the accessed field is a subarray, the dimensions of the subarray are appended to the shape of the result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba28bd784223a2a08bea18d126c6d98be59cd057" translate="yes" xml:space="preserve">
          <source>If the accumulator is too small, overflow occurs:</source>
          <target state="translated">如果蓄能器太小,就会发生溢流。</target>
        </trans-unit>
        <trans-unit id="f2dce957332c62c691a49ddcc68e31de7ff97f8b" translate="yes" xml:space="preserve">
          <source>If the array has no mask, the address of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is returned. This address is typically not close to the data in memory:</source>
          <target state="translated">如果数组没有掩码，则返回&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;的地址。此地址通常不接近内存中的数据：</target>
        </trans-unit>
        <trans-unit id="0e4bd5d4fdacecd1895716db48cb1cac490ae19c" translate="yes" xml:space="preserve">
          <source>If the array is not compatible with the new shape according to NumPy&amp;rsquo;s broadcasting rules.</source>
          <target state="translated">根据NumPy的广播规则，该数组是否与新形状不兼容。</target>
        </trans-unit>
        <trans-unit id="1b3a1026c96ba9547fc879c6163e5467ed414876" translate="yes" xml:space="preserve">
          <source>If the axis argument isn&amp;rsquo;t passed, your 2D array will be flattened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9556db7609e9b52c8da71258e9ebc1e23d97b8b8" translate="yes" xml:space="preserve">
          <source>If the buffer has data that is not in machine byte-order, this should be specified as part of the data-type, e.g.:</source>
          <target state="translated">如果缓冲区中的数据不是按机器字节顺序排列的,则应将其作为数据类型的一部分来指定,例如:。</target>
        </trans-unit>
        <trans-unit id="707be1af574eabd0a2204881f5336941a1d0fb1f" translate="yes" xml:space="preserve">
          <source>If the columns have names, we can also select which columns to import by giving their name to the &lt;code&gt;usecols&lt;/code&gt; argument, either as a sequence of strings or a comma-separated string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9172eee727e3bc5966a060de8a7a54e3be2870d" translate="yes" xml:space="preserve">
          <source>If the common data type is known ahead of time, don&amp;rsquo;t use this flag. Instead, set the requested dtype for all the operands.</source>
          <target state="translated">如果公共数据类型提前知道，请不要使用此标志。而是为所有操作数设置请求的dtype。</target>
        </trans-unit>
        <trans-unit id="c0b42d9b2195e628dbcfcb8e55fe0f75a169d8db" translate="yes" xml:space="preserve">
          <source>If the condition is a callable, it is used at runtime to dynamically make the decision. This is useful for tests that may require costly imports, to delay the cost until the test suite is actually executed.</source>
          <target state="translated">如果条件是可调用的,那么它就会在运行时被用来动态地做出决定。这对于那些可能需要昂贵的导入的测试来说是很有用的,可以将成本延迟到测试套件实际执行的时候。</target>
        </trans-unit>
        <trans-unit id="da8929bf843323251f47496e7bd27572472297dd" translate="yes" xml:space="preserve">
          <source>If the conversion is not possible</source>
          <target state="translated">如果不可能进行转换</target>
        </trans-unit>
        <trans-unit id="bf41eeaf999250f9cdaa16bd479da6c16a96c8f5" translate="yes" xml:space="preserve">
          <source>If the ctypes module is not available, then the ctypes attribute of array objects still returns something useful, but ctypes objects are not returned and errors may be raised instead. In particular, the object will still have the &lt;code&gt;as_parameter&lt;/code&gt; attribute which will return an integer equal to the data attribute.</source>
          <target state="translated">如果ctypes模块不可用，则数组对象的ctypes属性仍然返回有用的内容，但不会返回ctypes对象，而可能会引发错误。特别是，对象仍将具有 &lt;code&gt;as_parameter&lt;/code&gt; 属性，该属性将返回等于data属性的整数。</target>
        </trans-unit>
        <trans-unit id="882469c86c3e266d61a4e68ca724a4e1e6d70bb9" translate="yes" xml:space="preserve">
          <source>If the current domain is the interval &lt;code&gt;[l1, r1]&lt;/code&gt; and the window is &lt;code&gt;[l2, r2]&lt;/code&gt;, then the linear mapping function &lt;code&gt;L&lt;/code&gt; is defined by the equations:</source>
          <target state="translated">如果当前域是区间 &lt;code&gt;[l1, r1]&lt;/code&gt; ，窗口是 &lt;code&gt;[l2, r2]&lt;/code&gt; ，则线性映射函数 &lt;code&gt;L&lt;/code&gt; 由以下等式定义：</target>
        </trans-unit>
        <trans-unit id="74cde2bcb160b06069d73cce52e519943212158c" translate="yes" xml:space="preserve">
          <source>If the data type is &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, an aggregate of other data types, (&lt;em&gt;e.g.&lt;/em&gt;, describing an array item consisting of an integer and a float),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e4177a6acaf9fb51b7f55a4c29b9a1f7f66006" translate="yes" xml:space="preserve">
          <source>If the data type is &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, an aggregate of other data types, (&lt;em&gt;e.g.&lt;/em&gt;, describing an array item consisting of an integer and a float),</source>
          <target state="translated">如果数据类型是&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;结构化数据类型&lt;/a&gt;，则为其他数据类型的集合（&lt;em&gt;例如&lt;/em&gt;，描述由整数和浮点数组成的数组项），</target>
        </trans-unit>
        <trans-unit id="0cecddf950b77d1003b9474189d29ff0bfdb6282" translate="yes" xml:space="preserve">
          <source>If the data type is a sub-array, what is its shape and data type.</source>
          <target state="translated">如果数据类型是子数组,其形状和数据类型是什么。</target>
        </trans-unit>
        <trans-unit id="5b7ff57105753a62bcfc1055c91f35344e435758" translate="yes" xml:space="preserve">
          <source>If the decomposition fails, for example, if &lt;code&gt;a&lt;/code&gt; is not positive-definite.</source>
          <target state="translated">如果分解失败，例如，如果 &lt;code&gt;a&lt;/code&gt; 不是正定的。</target>
        </trans-unit>
        <trans-unit id="ee52413e2abf8d484ea3208ee7d3358a43d8e634" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.all&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;子类的&lt;a href=&quot;#numpy.all&quot;&gt; &lt;code&gt;all&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="206ca5be0da6c825b1f0142de708ea22958f4d55" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amax&quot;&gt;&lt;code&gt;amax&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;子类的&lt;a href=&quot;#numpy.amax&quot;&gt; &lt;code&gt;amax&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="f05780b3efb83cb7999e12324775e7fa0e8c55fe" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amin&quot;&gt;&lt;code&gt;amin&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果默认值被传递，然后 &lt;code&gt;keepdims&lt;/code&gt; 不会被通过所传递&lt;a href=&quot;#numpy.amin&quot;&gt; &lt;code&gt;amin&lt;/code&gt; &lt;/a&gt;的亚类的方法&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，然而任何非默认值将是。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="4bb758877f868372bd36b970799d233d6c9b6b2e" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果默认值被传递，然后 &lt;code&gt;keepdims&lt;/code&gt; 不会被通过所传递&lt;a href=&quot;#numpy.any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt;的亚类的方法&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，然而任何非默认值将是。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="4f36bf742dff79ee7a2535335e60a655538367af" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给 &lt;code&gt;ndarray&lt;/code&gt; 子类的&lt;a href=&quot;#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="e936312beb89ed94ea31f46b832a3128132ea8c3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;的子类的&lt;a href=&quot;#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="cccfcc112e296f9db67affb5426a407a1e1b1ab3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;的子类的&lt;a href=&quot;#numpy.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都会传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="f6aec8996590d19051796274c83c4f7439695ce8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ptp&quot;&gt;&lt;code&gt;ptp&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;的子类的&lt;a href=&quot;#numpy.ptp&quot;&gt; &lt;code&gt;ptp&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="04b4fba4bb9497e64959763e9e88bb419b385930" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;的子类的&lt;a href=&quot;#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="3ec6e98470abd2d3a8abe5e8029889dd09ba623f" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;的子类的&lt;a href=&quot;#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="2d09798a597d9e0c839ab8917b5d5016554acbc8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;子类的&lt;a href=&quot;#numpy.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="83795d27b8fbf6727fc73ba1d3ba1433b7f48097" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给 &lt;code&gt;ndarray&lt;/code&gt; 子类的&lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="f36f9bb6a297ac4fc949ef700d42398954026ba5" translate="yes" xml:space="preserve">
          <source>If the dimension of &lt;code&gt;a&lt;/code&gt; is less than 2.</source>
          <target state="translated">如果的尺寸 &lt;code&gt;a&lt;/code&gt; 小于2。</target>
        </trans-unit>
        <trans-unit id="a923921d01ae62bb1aaf773e7e11bc37201f68aa" translate="yes" xml:space="preserve">
          <source>If the discontinuity in &lt;code&gt;p&lt;/code&gt; is smaller than &lt;code&gt;pi&lt;/code&gt;, but larger than &lt;code&gt;discont&lt;/code&gt;, no unwrapping is done because taking the 2*pi complement would only make the discontinuity larger.</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 中的不连续性小于 &lt;code&gt;pi&lt;/code&gt; ，但大于 &lt;code&gt;discont&lt;/code&gt; ，则不进行解包，因为采用2 * pi补码只会使不连续性变大。</target>
        </trans-unit>
        <trans-unit id="dd1746ba40294ba18df6698853992dfa2b70977c" translate="yes" xml:space="preserve">
          <source>If the dtypes of two void structured arrays are equal, testing the equality of the arrays will result in a boolean array with the dimensions of the original arrays, with elements set to &lt;code&gt;True&lt;/code&gt; where all fields of the corresponding structures are equal. Structured dtypes are equal if the field names, dtypes and titles are the same, ignoring endianness, and the fields are in the same order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769e103ab2e97d0544e3e9203d0c4335be336adf" translate="yes" xml:space="preserve">
          <source>If the eigenvalue computation does not converge.</source>
          <target state="translated">如果特征值计算不收敛。</target>
        </trans-unit>
        <trans-unit id="18adc01c0eaa64bd3fe6f5b836944558dd579c54" translate="yes" xml:space="preserve">
          <source>If the element you&amp;rsquo;re looking for doesn&amp;rsquo;t exist in the array, then the returned array of indices will be empty. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5f5ebbdda43d87574658252f8456304a3e6d83" translate="yes" xml:space="preserve">
          <source>If the file contains pickle data, then whatever object is stored in the pickle is returned.</source>
          <target state="translated">如果文件中包含pickle数据,那么将返回pickle中存储的任何对象。</target>
        </trans-unit>
        <trans-unit id="52f9285704aeec7c0050eb73ae0eedae9e536c15" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npy&lt;/code&gt; file, then a single array is returned.</source>
          <target state="translated">如果文件是 &lt;code&gt;.npy&lt;/code&gt; 文件，则返回单个数组。</target>
        </trans-unit>
        <trans-unit id="c850dbbea34f89942e452ade066952afb4aff87b" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, the returned value supports the context manager protocol in a similar fashion to the open function:</source>
          <target state="translated">如果文件是 &lt;code&gt;.npz&lt;/code&gt; 文件，则返回的值以类似于open函数的方式支持上下文管理器协议：</target>
        </trans-unit>
        <trans-unit id="6dd34773e8e6fce245333f3661e9174ce50590a5" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, then a dictionary-like object is returned, containing &lt;code&gt;{filename: array}&lt;/code&gt; key-value pairs, one for each file in the archive.</source>
          <target state="translated">如果文件是 &lt;code&gt;.npz&lt;/code&gt; 文件，则将返回一个类似于字典的对象，其中包含 &lt;code&gt;{filename: array}&lt;/code&gt; 键值对，对于归档中的每个文件一个。</target>
        </trans-unit>
        <trans-unit id="3eb136618e35fc45bcfb6109a519b0397c62a7f3" translate="yes" xml:space="preserve">
          <source>If the filename ends in &lt;code&gt;.gz&lt;/code&gt;, the file is automatically saved in compressed gzip format. &lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt;&lt;code&gt;loadtxt&lt;/code&gt;&lt;/a&gt; understands gzipped files transparently.</source>
          <target state="translated">如果文件名以 &lt;code&gt;.gz&lt;/code&gt; 结尾，则文件将以压缩的gzip格式自动保存。&lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt; &lt;code&gt;loadtxt&lt;/code&gt; &lt;/a&gt;可以透明地理解gzip压缩文件。</target>
        </trans-unit>
        <trans-unit id="3cd5e67735dce4fe85460703c53dc9836515a450" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as a row vector. If the last argument is 1-D it is treated as a column vector. The other arguments must be 2-D.</source>
          <target state="translated">如果第一个参数是1-D,则作为行向量处理。如果最后一个参数是1-D,则作为列向量处理。其他参数必须是2-D的。</target>
        </trans-unit>
        <trans-unit id="02ed5193bd3dcf84d786340881fcb3d577ef57f7" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as row vector. If the last argument is 1-D it is treated as column vector. The other arguments must be 2-D.</source>
          <target state="translated">如果第一个参数是1-D,则作为行向量处理。如果最后一个参数是1-D,则作为列向量处理。其他参数必须是2-D。</target>
        </trans-unit>
        <trans-unit id="0a74c0a74431c3bd3b43bf07934fe3d61fd80338" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D, it is promoted to a matrix by prepending a 1 to its dimensions. After matrix multiplication the prepended 1 is removed.</source>
          <target state="translated">如果第一个参数是1-D,则通过在其维度上预置1,将其提升为一个矩阵。矩阵乘法后,去掉预置的1。</target>
        </trans-unit>
        <trans-unit id="89db4e5dab2cb1ce35a7fb31edd3413095e85f3c" translate="yes" xml:space="preserve">
          <source>If the first argument is a tuple, other arguments are ignored:</source>
          <target state="translated">如果第一个参数是元组,其他参数将被忽略。</target>
        </trans-unit>
        <trans-unit id="727e22f05290aaa6c2959157d7df0bc582e3c538" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then &lt;a href=&quot;#numpy.ma.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; returns True:</source>
          <target state="translated">如果以下方程式为元素式True，则&lt;a href=&quot;#numpy.ma.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; &lt;/a&gt;返回True：</target>
        </trans-unit>
        <trans-unit id="94cbab458f248cbb972811c2359461201e9861d5" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then allclose returns True.</source>
          <target state="translated">如果下面的等式元素为True,那么allclose返回True。</target>
        </trans-unit>
        <trans-unit id="1386561a26e41c95c312db50b7ef52259e4517da" translate="yes" xml:space="preserve">
          <source>If the given strings are equal, &lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt;&lt;code&gt;assert_string_equal&lt;/code&gt;&lt;/a&gt; does nothing. If they are not equal, an AssertionError is raised, and the diff between the strings is shown.</source>
          <target state="translated">如果给定的字符串相等，则&lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt; &lt;code&gt;assert_string_equal&lt;/code&gt; &lt;/a&gt;不执行任何操作。如果它们不相等，则会引发AssertionError，并显示字符串之间的差异。</target>
        </trans-unit>
        <trans-unit id="f5f5e437a85f1a89c55d54e0a09b57161df68a13" translate="yes" xml:space="preserve">
          <source>If the header file that contains the prototype for &lt;code&gt;double dot()&lt;/code&gt; also contains other prototypes that you want to wrap, so that you need to &lt;code&gt;%include&lt;/code&gt; this header file, then you will also need a &lt;code&gt;%ignore
dot;&lt;/code&gt; directive, placed after the &lt;code&gt;%rename&lt;/code&gt; and before the &lt;code&gt;%include&lt;/code&gt; directives. Or, if the function in question is a class method, you will want to use &lt;code&gt;%extend&lt;/code&gt; rather than &lt;code&gt;%inline&lt;/code&gt; in addition to &lt;code&gt;%ignore&lt;/code&gt;.</source>
          <target state="translated">如果包含 &lt;code&gt;double dot()&lt;/code&gt; 原型的头文件还包含您要包装的其他原型，那么您需要 &lt;code&gt;%include&lt;/code&gt; 这个头文件，那么您还将需要 &lt;code&gt;%ignore dot;&lt;/code&gt; 指令，位于 &lt;code&gt;%rename&lt;/code&gt; 之后和 &lt;code&gt;%include&lt;/code&gt; 指令之前。或者，如果所讨论的函数是类方法，则除了 &lt;code&gt;%ignore&lt;/code&gt; 之外，还希望使用 &lt;code&gt;%extend&lt;/code&gt; 而不是 &lt;code&gt;%inline&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e4a3d5e2d4e2e2a3ebb889979e38306c67da7f4" translate="yes" xml:space="preserve">
          <source>If the index arrays do not have the same shape, there is an attempt to broadcast them to the same shape. If they cannot be broadcast to the same shape, an exception is raised:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f745354786d48a61873aeb74a86c334de5c7a7b4" translate="yes" xml:space="preserve">
          <source>If the index expression contains comma separated arrays, then stack them along their first axis.</source>
          <target state="translated">如果索引表达式包含逗号分隔的数组,那么就沿着它们的第一个轴堆叠它们。</target>
        </trans-unit>
        <trans-unit id="34ad012e6ac2224c1d99e1fa90fb54c844437b0d" translate="yes" xml:space="preserve">
          <source>If the index expression contains slice notation or scalars then create a 1-D array with a range indicated by the slice notation.</source>
          <target state="translated">如果索引表达式包含分片符号或标量,那么就创建一个一维数组,其范围由分片符号表示。</target>
        </trans-unit>
        <trans-unit id="70dea339f55810f6be3e1b0c9e7aefd88107ebbf" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;a&lt;/code&gt; contains an imaginary part, it is silently discarded.</source>
          <target state="translated">如果输入 &lt;code&gt;a&lt;/code&gt; 包含虚部，则将其静默丢弃。</target>
        </trans-unit>
        <trans-unit id="4637e99d70ef2c1cb40679370ac10807b840a3f4" translate="yes" xml:space="preserve">
          <source>If the input file does not exist or cannot be read.</source>
          <target state="translated">如果输入文件不存在或无法读取。</target>
        </trans-unit>
        <trans-unit id="bbf06b38d2758769a67207876edd570ca41378d4" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.max.</source>
          <target state="translated">如果输入为整数类型,则函数等同于np.max。</target>
        </trans-unit>
        <trans-unit id="7895a434c9eeafd563766c2013458a9eca1c5fea" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.min.</source>
          <target state="translated">如果输入为整数类型,则函数等同于np.min。</target>
        </trans-unit>
        <trans-unit id="b307c09a45c4aabb639976a619f0171d6a01d0dd" translate="yes" xml:space="preserve">
          <source>If the input is 2d and axis is specified, the result is a list of lists.</source>
          <target state="translated">如果输入的是2D,并且指定了轴,结果是一个列表。</target>
        </trans-unit>
        <trans-unit id="7ed38fa8c8d2f0a335bd5a040aeda16b9d1b796e" translate="yes" xml:space="preserve">
          <source>If the input is not 1-dimensional, or contains elements with negative values, or if &lt;code&gt;minlength&lt;/code&gt; is negative.</source>
          <target state="translated">如果输入不是一维的，或者包含具有负值的元素，或者 &lt;code&gt;minlength&lt;/code&gt; 为负。</target>
        </trans-unit>
        <trans-unit id="10296cda117e24158759559beefea304129412f0" translate="yes" xml:space="preserve">
          <source>If the input parameter &lt;code&gt;n&lt;/code&gt; is larger than the size of the input, the input is padded by appending zeros at the end. Even though this is the common approach, it might lead to surprising results. If a different padding is desired, it must be performed before calling &lt;a href=&quot;#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果输入参数 &lt;code&gt;n&lt;/code&gt; 大于输入的大小，则通过在末尾附加零来填充输入。即使这是常用方法，也可能导致令人惊讶的结果。如果需要不同的填充，则必须在调用&lt;a href=&quot;#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt;之前执行。</target>
        </trans-unit>
        <trans-unit id="3fc060b3dda78a5634929550749227bb1804a61d" translate="yes" xml:space="preserve">
          <source>If the inputs are ndarrays, then np.greater is equivalent to &amp;lsquo;&amp;gt;&amp;rsquo;.</source>
          <target state="translated">如果输入是ndarrays，则np.greater等效于'&amp;gt;'。</target>
        </trans-unit>
        <trans-unit id="36e6b94197e7b6e49557830166101a92fecb27ad" translate="yes" xml:space="preserve">
          <source>If the inputs or dtype are complex, the output will follow a logarithmic spiral in the complex plane. (There are an infinite number of spirals passing through two points; the output will follow the shortest such path.)</source>
          <target state="translated">如果输入或dtype是复数,输出将遵循复数平面上的对数螺旋。(通过两点的螺旋线的数量是无限的,输出将遵循最短的路径)。</target>
        </trans-unit>
        <trans-unit id="ce8f1e8f63cbe617564d9cd3d7c5c8bc3e2530ae" translate="yes" xml:space="preserve">
          <source>If the iterator is buffered, returns the size of the buffer being used, otherwise returns 0.</source>
          <target state="translated">如果迭代器是缓冲区,返回正在使用的缓冲区大小,否则返回0。</target>
        </trans-unit>
        <trans-unit id="f3c918834625c8823bdade73b25f11346749b818" translate="yes" xml:space="preserve">
          <source>If the iterator is tracking a multi-index, this strips support for them, and does further iterator optimizations that are possible if multi-indices are not needed. This function also resets the iterator to its initial state.</source>
          <target state="translated">如果迭代器正在跟踪多索引,这将剥离对它们的支持,并做进一步的迭代器优化,如果不需要多索引,则有可能。这个函数也会将迭代器重置为初始状态。</target>
        </trans-unit>
        <trans-unit id="7df15990c36906ed5503360d9305db9b7bfe762b" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; has different size.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的最后一个尺寸具有不同的大小。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
