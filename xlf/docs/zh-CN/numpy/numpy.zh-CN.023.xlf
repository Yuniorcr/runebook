<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="7f0e6c0ce58755cae988a618ed26819ae121acf3" translate="yes" xml:space="preserve">
          <source>The scipy implementation is recommended over this function: it is a proper ufunc written in C, and more than an order of magnitude faster.</source>
          <target state="translated">比起这个函数,推荐使用 scipy 实现:它是一个用 C 语言编写的合适的 ufunc,而且速度快了不止一个数量级。</target>
        </trans-unit>
        <trans-unit id="678645818896e353218894b08bcbb6e53102fa78" translate="yes" xml:space="preserve">
          <source>The scipy.org should be a PR at &lt;a href=&quot;https://github.com/scipy/scipy.org&quot;&gt;https://github.com/scipy/scipy.org&lt;/a&gt;. The file that needs modification is &lt;code&gt;www/index.rst&lt;/code&gt;. Search for &lt;code&gt;News&lt;/code&gt;.</source>
          <target state="translated">scipy.org应该是&lt;a href=&quot;https://github.com/scipy/scipy.org&quot;&gt;https://github.com/scipy/scipy.org&lt;/a&gt;上的PR 。需要修改的文件是 &lt;code&gt;www/index.rst&lt;/code&gt; 。搜索 &lt;code&gt;News&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="076d96a74fdcb13373554cd33f5faa0a5c841024" translate="yes" xml:space="preserve">
          <source>The second argument passed in to the Py_InitModule function is a structure that makes it easy to to define functions in the module. In the example given above, the mymethods structure would have been defined earlier in the file (usually right before the init{name} subroutine) to:</source>
          <target state="translated">传入 Py_InitModule 函数的第二个参数是一个结构,它可以方便地定义模块中的函数。在上面给出的例子中,mymethods 结构应该在文件的前面(通常是在 init{name}子程序之前)被定义为。</target>
        </trans-unit>
        <trans-unit id="f1d1e93a16e6953d6dc31578f1bc0e4185a42885" translate="yes" xml:space="preserve">
          <source>The second element, &lt;em&gt;field_dtype&lt;/em&gt;, can be anything that can be interpreted as a data-type.</source>
          <target state="translated">第二个元素&lt;em&gt;field_dtype&lt;/em&gt;可以是任何可以解释为数据类型的元素。</target>
        </trans-unit>
        <trans-unit id="4ebced32cc87e2c3435e9151b36d6b3c2cfaf845" translate="yes" xml:space="preserve">
          <source>The second is to set the error-handler to &amp;lsquo;log&amp;rsquo;, using &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;. Floating-point errors then trigger a call to the &amp;lsquo;write&amp;rsquo; method of the provided object.</source>
          <target state="translated">第二种是使用&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;将错误处理程序设置为'log' 。然后，浮点错误会触发对提供的对象的&amp;ldquo;写入&amp;rdquo;方法的调用。</target>
        </trans-unit>
        <trans-unit id="6f31ccc451074791f12a3d0394615bd3d0e3cdd2" translate="yes" xml:space="preserve">
          <source>The second issue to understand is how indices correspond to the order the array is stored in memory. In Fortran the first index is the most rapidly varying index when moving through the elements of a two dimensional array as it is stored in memory. If you adopt the matrix convention for indexing, then this means the matrix is stored one column at a time (since the first index moves to the next row as it changes). Thus Fortran is considered a Column-major language. C has just the opposite convention. In C, the last index changes most rapidly as one moves through the array as stored in memory. Thus C is a Row-major language. The matrix is stored by rows. Note that in both cases it presumes that the matrix convention for indexing is being used, i.e., for both Fortran and C, the first index is the row. Note this convention implies that the indexing convention is invariant and that the data order changes to keep that so.</source>
          <target state="translated">第二个要理解的问题是,指数如何对应数组在内存中的存储顺序。在Fortran中,当二维数组的元素在内存中存储时,第一个索引是变化最快的索引。如果采用矩阵约定的索引方式,那么就意味着矩阵一次只存储一列(因为第一个索引在变化时要移动到下一行)。因此,Fortran被认为是一种Column-major语言。C语言的约定刚好相反。在C中,当人们在内存中存储的数组中移动时,最后一个索引的变化速度最快。因此C语言是一种行主语言。矩阵是以行为单位存储的。请注意,在这两种情况下,都假定使用了索引的矩阵约定,也就是说,对于Fortran和C,第一个索引是行。注意这个约定意味着索引约定是不变的,数据顺序的改变也是为了保持这一点。</target>
        </trans-unit>
        <trans-unit id="453559558db2eb56414a46dbdb5de2376ea80083" translate="yes" xml:space="preserve">
          <source>The second rule of broadcasting ensures that arrays with a size of 1 along a particular dimension act as if they had the size of the array with the largest shape along that dimension. The value of the array element is assumed to be the same along that dimension for the &amp;ldquo;broadcast&amp;rdquo; array.</source>
          <target state="translated">广播的第二条规则可确保在特定维度上大小为1的数组的行为就像在该维度上具有最大形状的数组的大小一样。假设数组元素的值沿&amp;ldquo;广播&amp;rdquo;数组的维度是相同的。</target>
        </trans-unit>
        <trans-unit id="df98d64a8c2e83a203df1c7d9ac9de7f5c519eeb" translate="yes" xml:space="preserve">
          <source>The second through seventh row contain summary data that is of a different type than that which we are going to examine, so we will need to exclude that from the data with which we will work.</source>
          <target state="translated">第二行至第七行包含的汇总数据与我们要检查的数据类型不同,因此我们需要将其从我们要处理的数据中排除。</target>
        </trans-unit>
        <trans-unit id="fe0109b90f8697e3f57d897bca8c421d8285d2b1" translate="yes" xml:space="preserve">
          <source>The second way is to upload the PKG_INFO file inside the sdist dir in the web interface of PyPI. The source tarball can also be uploaded through this interface.</source>
          <target state="translated">第二种方法是在PyPI的web界面的sdist目录下上传PKG_INFO文件。源码包也可以通过这个界面上传。</target>
        </trans-unit>
        <trans-unit id="7aabd3a3162d932dde5dce5c1f8c9f863c647d1b" translate="yes" xml:space="preserve">
          <source>The second way of indexing with booleans is more similar to integer indexing; for each dimension of the array we give a 1D boolean array selecting the slices we want:</source>
          <target state="translated">第二种用布林索引的方式更类似于整数索引,对于数组的每个维度,我们给出一个1D布林数组选择我们想要的切片。</target>
        </trans-unit>
        <trans-unit id="66a3455570bd434e86d6f052ed9b9a1d4a2c4251" translate="yes" xml:space="preserve">
          <source>The sections of a function&amp;rsquo;s docstring are:</source>
          <target state="translated">函数的文档字符串的各节为：</target>
        </trans-unit>
        <trans-unit id="8eb125eefbda7190ce972cb7d8270d5ae89dc7b7" translate="yes" xml:space="preserve">
          <source>The self.paths(&amp;hellip;) method is applied to all lists that may contain paths.</source>
          <target state="translated">self.paths（&amp;hellip;）方法适用于可能包含路径的所有列表。</target>
        </trans-unit>
        <trans-unit id="8c7148486ba5b770e99fd7463ec63c216dee7366" translate="yes" xml:space="preserve">
          <source>The separation between elements for each dimension (the &amp;lsquo;stride&amp;rsquo;). This does not have to be a multiple of the element size</source>
          <target state="translated">每个维度的元素之间的分隔（&amp;ldquo;跨度&amp;rdquo;）。这不必是元素大小的倍数</target>
        </trans-unit>
        <trans-unit id="9cd2ff64b895aeb8d0b16f3694ac2aea08560437" translate="yes" xml:space="preserve">
          <source>The series in this context are finite sums of the corresponding polynomial basis functions multiplied by coefficients. For instance, a power series looks like</source>
          <target state="translated">这里的数列是相应多项式基函数乘以系数的有限和。例如,一个幂级数看起来像</target>
        </trans-unit>
        <trans-unit id="9285a776c2a659ee75e7938ac17b155070381205" translate="yes" xml:space="preserve">
          <source>The series instance to be converted.</source>
          <target state="translated">要转换的系列实例。</target>
        </trans-unit>
        <trans-unit id="89a518ad1f6d727d2464d8f222f198c518f126e6" translate="yes" xml:space="preserve">
          <source>The series is reduced to degree &lt;code&gt;deg&lt;/code&gt; by discarding the high order terms. The value of &lt;code&gt;deg&lt;/code&gt; must be a non-negative integer.</source>
          <target state="translated">通过丢弃高阶项，将序列减小到度 &lt;code&gt;deg&lt;/code&gt; 。 &lt;code&gt;deg&lt;/code&gt; 的值必须是非负整数。</target>
        </trans-unit>
        <trans-unit id="adbbacc122f5859d958a7eb7009d4955c1c2c537" translate="yes" xml:space="preserve">
          <source>The series is reduced to length &lt;code&gt;size&lt;/code&gt; by discarding the high degree terms. The value of &lt;code&gt;size&lt;/code&gt; must be a positive integer.</source>
          <target state="translated">通过丢弃高级项，将序列减小为长度 &lt;code&gt;size&lt;/code&gt; 。 &lt;code&gt;size&lt;/code&gt; 的值必须为正整数。</target>
        </trans-unit>
        <trans-unit id="38262a9c7d66cebff5a42640a9df021a775761be" translate="yes" xml:space="preserve">
          <source>The set of available codecs comes from the Python standard library, and may be extended at runtime. For more information, see the &lt;a href=&quot;https://docs.python.org/dev/library/codecs.html#module-codecs&quot;&gt;&lt;code&gt;codecs&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">可用的编解码器集来自Python标准库，并且可以在运行时进行扩展。有关更多信息，请参见&lt;a href=&quot;https://docs.python.org/dev/library/codecs.html#module-codecs&quot;&gt; &lt;code&gt;codecs&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="a717e3302b8636b7790364bffe6b5a183f3f6e7f" translate="yes" xml:space="preserve">
          <source>The set of available codecs comes from the Python standard library, and may be extended at runtime. For more information, see the codecs module.</source>
          <target state="translated">可用的编解码器集来自 Python 标准库,并可在运行时进行扩展。更多信息,请参见 codecs 模块。</target>
        </trans-unit>
        <trans-unit id="f3119f479b7378be171f9e5461ebc7ae89470f50" translate="yes" xml:space="preserve">
          <source>The set of characters that the returned character is chosen from. The default set is &amp;lsquo;GDFgdf&amp;rsquo;.</source>
          <target state="translated">从中选择返回字符的字符集。默认设置为&amp;ldquo; GDFgdf&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a3a4541aef2e0618e33ebd5e18d9c022d28bcaa8" translate="yes" xml:space="preserve">
          <source>The set of functions that convert the data of a column to a value. The converters can also be used to provide a default value for missing data: &lt;code&gt;converters = {3: lambda s: float(s or 0)}&lt;/code&gt;.</source>
          <target state="translated">将列的数据转换为值的一组函数。转换器还可以用于为丢失的数据提供默认值： &lt;code&gt;converters = {3: lambda s: float(s or 0)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e26f5391f4384da7c676eb1e9d468550abb0eb1" translate="yes" xml:space="preserve">
          <source>The set of int values is not a subset of the uint values for types with the same number of bits, something not reflected in &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt;, but handled as a special case in PyArray_ResultType.</source>
          <target state="translated">int值的集合不是具有相同位数的类型的uint值的子集，这没有反映在&lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; 中&lt;/a&gt;，而是在PyArray_ResultType中作为特殊情况处理。</target>
        </trans-unit>
        <trans-unit id="e76841686484db8628455fd162b8197749bc84c1" translate="yes" xml:space="preserve">
          <source>The set of int values is not a subset of the uint values for types with the same number of bits, something not reflected in &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt;, but handled as a special case in &lt;a href=&quot;#numpy.result_type&quot;&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">int值的集合不是具有相同位数的类型的uint值的子集，这没有反映在&lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; 中&lt;/a&gt;，而是在&lt;a href=&quot;#numpy.result_type&quot;&gt; &lt;code&gt;result_type&lt;/code&gt; 中&lt;/a&gt;作为特殊情况处理。</target>
        </trans-unit>
        <trans-unit id="561107923e2d5ef74733b059316312382b1f95e9" translate="yes" xml:space="preserve">
          <source>The set of strings corresponding to missing data.</source>
          <target state="translated">对应缺失数据的字符串集。</target>
        </trans-unit>
        <trans-unit id="3c3fdff23bd130c5708b43d7769884cc7638d9dc" translate="yes" xml:space="preserve">
          <source>The set of values to be used as default when the data are missing.</source>
          <target state="translated">当数据缺失时作为默认值使用的一组值。</target>
        </trans-unit>
        <trans-unit id="40c5a46b247f5eb179525001f8ba092f80c0ed2a" translate="yes" xml:space="preserve">
          <source>The setup function for all three methods is &lt;code&gt;construct_reduce&lt;/code&gt;. This function creates a reducing loop object and fills it with parameters needed to complete the loop. All of the methods only work on ufuncs that take 2-inputs and return 1 output. Therefore, the underlying 1-D loop is selected assuming a signature of [ &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt; ] where &lt;code&gt;otype&lt;/code&gt; is the requested reduction data-type. The buffer size and error handling is then retrieved from (per-thread) global storage. For small arrays that are mis-aligned or have incorrect data-type, a copy is made so that the un-buffered section of code is used. Then, the looping strategy is selected. If there is 1 element or 0 elements in the array, then a simple looping method is selected. If the array is not mis-aligned and has the correct data-type, then strided looping is selected. Otherwise, buffered looping must be performed. Looping parameters are then established, and the return array is constructed. The output array is of a different shape depending on whether the method is reduce, accumulate, or reduceat. If an output array is already provided, then it&amp;rsquo;s shape is checked. If the output array is not C-contiguous, aligned, and of the correct data type, then a temporary copy is made with the WRITEBACKIFCOPY flag set. In this way, the methods will be able to work with a well-behaved output array but the result will be copied back into the true output array when &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called at function completion. Finally, iterators are set up to loop over the correct axis (depending on the value of axis provided to the method) and the setup routine returns to the actual computation routine.</source>
          <target state="translated">所有这三种方法的设置函数是 &lt;code&gt;construct_reduce&lt;/code&gt; 。此函数创建一个减少循环的对象，并用完成循环所需的参数填充它。所有这些方法仅适用于具有2个输入并返回1个输出的ufunc。因此，在选择[ &lt;code&gt;otype&lt;/code&gt; ， &lt;code&gt;otype&lt;/code&gt; ， &lt;code&gt;otype&lt;/code&gt; ] 签名的情况下选择基础的一维循环，其中 &lt;code&gt;otype&lt;/code&gt; 是请求的减少量数据类型。然后从（每个线程）全局存储中检索缓冲区大小和错误处理。对于未对齐或数据类型不正确的小型阵列，将进行复制，以便使用未缓冲的代码段。然后，选择循环策略。如果数组中有1个元素或0个元素，则选择一种简单的循环方法。如果数组未未对齐且具有正确的数据类型，则选择跨步循环。否则，必须执行缓冲循环。然后建立循环参数，并构造返回数组。输出数组的形状不同，具体取决于方法是缩小，累加还是缩小。如果已经提供了输出数组，则检查其形状。如果输出数组不是C连续的，则对齐，并且具有正确的数据类型，然后使用WRITEBACKIFCOPY标志设置临时副本。这样，这些方法将能够与行为良好的输出数组一起使用，但结果将在以下情况下复制回真实的输出数组中：&lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;在函数完成时被调用。最后，将迭代器设置为在正确的轴上循环（取决于提供给该方法的轴的值），并且设置例程将返回到实际的计算例程。</target>
        </trans-unit>
        <trans-unit id="26040668927e88fa78277a9dd0406a200dc72c4f" translate="yes" xml:space="preserve">
          <source>The setup function for all three methods is &lt;code&gt;construct_reduce&lt;/code&gt;. This function creates a reducing loop object and fills it with parameters needed to complete the loop. All of the methods only work on ufuncs that take 2-inputs and return 1 output. Therefore, the underlying 1-D loop is selected assuming a signature of [ &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt; ] where &lt;code&gt;otype&lt;/code&gt; is the requested reduction data-type. The buffer size and error handling is then retrieved from (per-thread) global storage. For small arrays that are mis-aligned or have incorrect data-type, a copy is made so that the un-buffered section of code is used. Then, the looping strategy is selected. If there is 1 element or 0 elements in the array, then a simple looping method is selected. If the array is not mis-aligned and has the correct data-type, then strided looping is selected. Otherwise, buffered looping must be performed. Looping parameters are then established, and the return array is constructed. The output array is of a different shape depending on whether the method is reduce, accumulate, or reduceat. If an output array is already provided, then it&amp;rsquo;s shape is checked. If the output array is not C-contiguous, aligned, and of the correct data type, then a temporary copy is made with the WRITEBACKIFCOPY flag set. In this way, the methods will be able to work with a well-behaved output array but the result will be copied back into the true output array when &lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called at function completion. Finally, iterators are set up to loop over the correct axis (depending on the value of axis provided to the method) and the setup routine returns to the actual computation routine.</source>
          <target state="translated">所有这三种方法的设置函数都是 &lt;code&gt;construct_reduce&lt;/code&gt; 。此函数创建一个减少循环的对象，并用完成循环所需的参数填充它。所有这些方法仅适用于具有2个输入并返回1个输出的ufunc。因此，假设[ &lt;code&gt;otype&lt;/code&gt; ， &lt;code&gt;otype&lt;/code&gt; ， &lt;code&gt;otype&lt;/code&gt; ]的签名为基础，则选择基础的一维循环，其中 &lt;code&gt;otype&lt;/code&gt; 是请求的减少量数据类型。然后从（每个线程）全局存储中检索缓冲区大小和错误处理。对于未对齐或数据类型不正确的小型阵列，将进行复制，以便使用未缓冲的代码段。然后，选择循环策略。如果数组中有1个元素或0个元素，则选择一种简单的循环方法。如果数组未未对齐且具有正确的数据类型，则选择跨步循环。否则，必须执行缓冲循环。然后建立循环参数，并构造返回数组。输出数组的形状不同，具体取决于方法是缩小，累加还是缩小。如果已经提供输出数组，则检查其形状。如果输出数组不是C连续的，则对齐，且具有正确的数据类型，则在设置了WRITEBACKIFCOPY标志的情况下进行临时复制。这样，这些方法将能够与行为良好的输出数组一起使用，但结果将在以下情况下复制回真实的输出数组中：&lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;在函数完成时被调用。最后，将迭代器设置为在正确的轴上循环（取决于提供给该方法的轴的值），并且设置例程将返回到实际的计算例程。</target>
        </trans-unit>
        <trans-unit id="780e857a060059f3e4636a17060f123b8f85b3b2" translate="yes" xml:space="preserve">
          <source>The shape (always C-style contiguous) of the sub-array as a Python tuple.</source>
          <target state="translated">作为Python元组的子数组的形状(总是C式连续)。</target>
        </trans-unit>
        <trans-unit id="9bd591fada3b4117c12a2a1f4d689c069ec359b8" translate="yes" xml:space="preserve">
          <source>The shape and data-type of &lt;code&gt;a&lt;/code&gt; define these same attributes of the returned array.</source>
          <target state="translated">的形状和数据类型 &lt;code&gt;a&lt;/code&gt; 限定返回的数组的这些相同的属性。</target>
        </trans-unit>
        <trans-unit id="ea4fdc5d91eb3f313e977fbfd63ada0a25a66896" translate="yes" xml:space="preserve">
          <source>The shape and data-type of &lt;code&gt;prototype&lt;/code&gt; define these same attributes of the returned array.</source>
          <target state="translated">&lt;code&gt;prototype&lt;/code&gt; 的形状和数据类型定义了返回数组的这些相同属性。</target>
        </trans-unit>
        <trans-unit id="de0758f703e3713cedaff1b24e8618c254649ffe" translate="yes" xml:space="preserve">
          <source>The shape of an array can be changed with various commands. Note that the following three commands all return a modified array, but do not change the original array:</source>
          <target state="translated">数组的形状可以通过各种命令来改变。请注意,以下三个命令都会返回一个修改后的数组,但不会改变原始数组的形状。</target>
        </trans-unit>
        <trans-unit id="55cbdf85b9592ec5dbddfd31ccd2c86de9452ccc" translate="yes" xml:space="preserve">
          <source>The shape of array into which the indices from &lt;code&gt;multi_index&lt;/code&gt; apply.</source>
          <target state="translated">&lt;code&gt;multi_index&lt;/code&gt; 的索引将应用到的数组的形状。</target>
        </trans-unit>
        <trans-unit id="86ea4631bc5657813d3aa6a6102c3531d8908358" translate="yes" xml:space="preserve">
          <source>The shape of each output is determined from the loop dimensions plus the output&amp;rsquo;s core dimensions</source>
          <target state="translated">每个输出的形状由回路尺寸加上输出的核心尺寸确定</target>
        </trans-unit>
        <trans-unit id="345c4787e4fcac13ce0e228d7aa0f85b31312232" translate="yes" xml:space="preserve">
          <source>The shape of the array if we are creating a new file in &amp;ldquo;write&amp;rdquo; mode, in which case this parameter is required. Otherwise, this parameter is ignored and is thus optional.</source>
          <target state="translated">如果要在&amp;ldquo;写入&amp;rdquo;模式下创建新文件，则数组的形状，在这种情况下，此参数是必需的。否则，此参数将被忽略，因此是可选的。</target>
        </trans-unit>
        <trans-unit id="432cd297e760e974a03d449cad5f33c7ccb0d645" translate="yes" xml:space="preserve">
          <source>The shape of the array is preserved, but the elements are reordered.</source>
          <target state="translated">数组的形状被保留,但元素被重新排序。</target>
        </trans-unit>
        <trans-unit id="fb341212b6f41ae91b019292b043b6094616b784" translate="yes" xml:space="preserve">
          <source>The shape of the array to be iterated over.</source>
          <target state="translated">迭代的数组的形状。</target>
        </trans-unit>
        <trans-unit id="a015ba13ffb4171bac494c802f272bfb87417c5d" translate="yes" xml:space="preserve">
          <source>The shape of the array to use for unraveling &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">用于解开 &lt;code&gt;indices&lt;/code&gt; 的数组的形状。</target>
        </trans-unit>
        <trans-unit id="9865a6cbf282f8b0812325650b93441342efdd22" translate="yes" xml:space="preserve">
          <source>The shape of the array.</source>
          <target state="translated">阵列的形状。</target>
        </trans-unit>
        <trans-unit id="634c22963834ab0f96135fc087ba541ef29a9351" translate="yes" xml:space="preserve">
          <source>The shape of the broadcasted result (only &lt;code&gt;nd&lt;/code&gt; slots are used).</source>
          <target state="translated">广播结果的形状（仅使用 &lt;code&gt;nd&lt;/code&gt; 时隙）。</target>
        </trans-unit>
        <trans-unit id="b35ba9f7409c5e79b96888dfb9fe12c59d8276ca" translate="yes" xml:space="preserve">
          <source>The shape of the desired array.</source>
          <target state="translated">所需阵列的形状。</target>
        </trans-unit>
        <trans-unit id="f8fd7f6a4e1f2e482a2f6d64364dd79594585ba9" translate="yes" xml:space="preserve">
          <source>The shape of the gamma distribution. Must be non-negative.</source>
          <target state="translated">伽马分布的形状。必须是非负数。</target>
        </trans-unit>
        <trans-unit id="40d55544c4b29b3e5cccb47aa9255a7413094e32" translate="yes" xml:space="preserve">
          <source>The shape of the grid.</source>
          <target state="translated">网格的形状。</target>
        </trans-unit>
        <trans-unit id="666be679bea4cf4401944751286d85ef9bcbd1ab" translate="yes" xml:space="preserve">
          <source>The shape of the new array. Defaults to &lt;code&gt;x.shape&lt;/code&gt;.</source>
          <target state="translated">新数组的形状。默认为 &lt;code&gt;x.shape&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91c1116d9a62d56b653126b73ba2224a6c45b6f9" translate="yes" xml:space="preserve">
          <source>The shape of the output depends on the size of &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt;, and may be larger than &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; (this happens if &lt;code&gt;len(indices) &amp;gt; array.shape[axis]&lt;/code&gt;).</source>
          <target state="translated">输出的形状取决于&lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt;的大小，并且可能大于&lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt;（如果 &lt;code&gt;len(indices) &amp;gt; array.shape[axis]&lt;/code&gt; 会发生这种情况）。</target>
        </trans-unit>
        <trans-unit id="be82fcdcf7279745a92907a11f17b40fb49cfa8e" translate="yes" xml:space="preserve">
          <source>The shape of the output depends on the size of &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt;, and may be larger than &lt;code&gt;a&lt;/code&gt; (this happens if &lt;code&gt;len(indices) &amp;gt; a.shape[axis]&lt;/code&gt;).</source>
          <target state="translated">输出的形状取决于&lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt;的大小，并且可能大于 &lt;code&gt;a&lt;/code&gt; （如果 &lt;code&gt;len(indices) &amp;gt; a.shape[axis]&lt;/code&gt; 会发生这种情况）。</target>
        </trans-unit>
        <trans-unit id="fed05fc9900417f6dd9d3b1246dc76a2025a600b" translate="yes" xml:space="preserve">
          <source>The shape of the result consists of the non-contracted axes of the first tensor, followed by the non-contracted axes of the second.</source>
          <target state="translated">结果的形状包括第一个张量的非收缩轴,然后是第二个张量的非收缩轴。</target>
        </trans-unit>
        <trans-unit id="dac69f494ba7fae89ed73806775a3c39622a5622" translate="yes" xml:space="preserve">
          <source>The shape of the return value is described above.</source>
          <target state="translated">返回值的形状如上所述。</target>
        </trans-unit>
        <trans-unit id="e988320cd7cc6c4a6c3dd57d84589dcf99664d33" translate="yes" xml:space="preserve">
          <source>The shape of the returned array is described above.</source>
          <target state="translated">返回数组的形状如上所述。</target>
        </trans-unit>
        <trans-unit id="3b10de911cd8ce2a5b2b31e29ac9a30a0aac3857" translate="yes" xml:space="preserve">
          <source>The shape of the returned matrix is &lt;code&gt;x.shape + (order,)&lt;/code&gt;, where</source>
          <target state="translated">返回矩阵的形状为 &lt;code&gt;x.shape + (order,)&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="80077b48358a43ab7ec659d3d5fde9d46b95fb86" translate="yes" xml:space="preserve">
          <source>The shape parameter must be given if converting from a ctypes POINTER. The shape parameter is ignored if converting from a ctypes array</source>
          <target state="translated">如果从ctypes POINTER转换,必须给出shape参数。如果从ctypes数组转换,形状参数将被忽略。</target>
        </trans-unit>
        <trans-unit id="fd56dfcd2507095f44b621f1654fe8bcd97f2720" translate="yes" xml:space="preserve">
          <source>The shape property is usually used to get the current shape of an array, but may also be used to reshape the array in-place by assigning a tuple of array dimensions to it. As with &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, one of the new shape dimensions can be -1, in which case its value is inferred from the size of the array and the remaining dimensions. Reshaping an array in-place will fail if a copy is required.</source>
          <target state="translated">shape属性通常用于获取数组的当前形状，但也可以通过向其分配数组尺寸的元组来就地对数组进行整形。与&lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; 一样&lt;/a&gt;，新形状尺寸之一可以为-1，在这种情况下，其值是从数组的大小和其余尺寸推断出来的。如果需要复制，就地重塑阵列将失败。</target>
        </trans-unit>
        <trans-unit id="80c5a27079e0e5c1026de7841cb52daa2c677404" translate="yes" xml:space="preserve">
          <source>The shapes of x, y, and the condition are broadcast together:</source>
          <target state="translated">x、y的形状和条件一起播报。</target>
        </trans-unit>
        <trans-unit id="052d67151c1ebcb6fedc9c36859ec35b9f5a3388" translate="yes" xml:space="preserve">
          <source>The shapes to be broadcast against each other.</source>
          <target state="translated">形状要对着广播。</target>
        </trans-unit>
        <trans-unit id="18b788b2f85a3ae45e9f183bcbf59e96d87edbee" translate="yes" xml:space="preserve">
          <source>The shifted array.</source>
          <target state="translated">移位阵列。</target>
        </trans-unit>
        <trans-unit id="a03c5ad272b253bf040f55b1c50d0da307be8ac5" translate="yes" xml:space="preserve">
          <source>The sign of &lt;code&gt;x2&lt;/code&gt; is copied to &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">&lt;code&gt;x2&lt;/code&gt; 的符号被复制到 &lt;code&gt;x1&lt;/code&gt; 。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="9a96a866f0e16363f3d77343ed89edc57a089b06" translate="yes" xml:space="preserve">
          <source>The sign of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的符号。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="39e50e1c53e79cf4e2679a1929a8b236a790ceb1" translate="yes" xml:space="preserve">
          <source>The signature defines &amp;ldquo;core&amp;rdquo; dimensionality of input and output variables, and thereby also defines the contraction of the dimensions. The signature is represented by a string of the following format:</source>
          <target state="translated">签名定义输入和输出变量的&amp;ldquo;核心&amp;rdquo;维，从而也定义维的收缩。签名由以下格式的字符串表示：</target>
        </trans-unit>
        <trans-unit id="077a1bbb529dbf66c684eb23b600d5d4d40598cf" translate="yes" xml:space="preserve">
          <source>The signature determines how the dimensions of each input/output array are split into core and loop dimensions:</source>
          <target state="translated">签名决定了每个输入/输出数组的尺寸如何被分割成核心和循环尺寸。</target>
        </trans-unit>
        <trans-unit id="b9b7ac7b939268ddc59ac1f05c9ebd5e07bf4b21" translate="yes" xml:space="preserve">
          <source>The signature file is saved to &lt;code&gt;fib1.pyf&lt;/code&gt; (see &lt;code&gt;-h&lt;/code&gt; flag) and its contents is shown below.</source>
          <target state="translated">签名文件保存到 &lt;code&gt;fib1.pyf&lt;/code&gt; （请参见 &lt;code&gt;-h&lt;/code&gt; 标志），其内容如下所示。</target>
        </trans-unit>
        <trans-unit id="f03fcdecb4ad7904d6d08273575b7efc1ecd0bcc" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;__array_finalize__&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;__array_finalize__&lt;/code&gt; 的签名为：</target>
        </trans-unit>
        <trans-unit id="51657129c6ecba9775cfcd86518eea063cc02856" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;__array_ufunc__&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;__array_ufunc__&lt;/code&gt; 的签名为：</target>
        </trans-unit>
        <trans-unit id="7eceedf301ec9322c1f2e0e1b62bac4ce44cf0b3" translate="yes" xml:space="preserve">
          <source>The signature of a Fortran block data has the following structure:</source>
          <target state="translated">Fortran块数据的签名具有以下结构。</target>
        </trans-unit>
        <trans-unit id="07cca1f52e338494fc6137e9ab73032ffedaab99" translate="yes" xml:space="preserve">
          <source>The signature of a Fortran routine has the following structure:</source>
          <target state="translated">Fortran例程的签名具有以下结构。</target>
        </trans-unit>
        <trans-unit id="29c6d5e035a62abf39bca07984559eb4c2eed470" translate="yes" xml:space="preserve">
          <source>The simplest and fastest estimator. Only takes into account the data size.</source>
          <target state="translated">最简单、最快的估算器。只考虑数据大小。</target>
        </trans-unit>
        <trans-unit id="f68339a598fdad0949b432ba0f071db76d4162b2" translate="yes" xml:space="preserve">
          <source>The simplest case of indexing with &lt;em&gt;N&lt;/em&gt; integers returns an &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar&lt;/a&gt; representing the corresponding item. As in Python, all indices are zero-based: for the &lt;em&gt;i&lt;/em&gt;-th index</source>
          <target state="translated">使用&lt;em&gt;N个&lt;/em&gt;整数进行索引的最简单情况是返回表示对应项的&lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;数组标量&lt;/a&gt;。与Python中一样，所有索引都从零开始：对于第&lt;em&gt;i&lt;/em&gt;个索引</target>
        </trans-unit>
        <trans-unit id="7ff2686b623caae27117f3c5885c7d6ae7623a3a" translate="yes" xml:space="preserve">
          <source>The simplest way to assign values to a structured array is using python tuples. Each assigned value should be a tuple of length equal to the number of fields in the array, and not a list or array as these will trigger numpy&amp;rsquo;s broadcasting rules. The tuple&amp;rsquo;s elements are assigned to the successive fields of the array, from left to right:</source>
          <target state="translated">将值分配给结构化数组的最简单方法是使用python元组。每个分配的值都应是一个长度等于数组中字段数的元组，而不是列表或数组，因为它们将触发numpy的广播规则。元组的元素从左到右分配给数组的连续字段：</target>
        </trans-unit>
        <trans-unit id="082b93c290be349a4bf83756ecca01f8d723b944" translate="yes" xml:space="preserve">
          <source>The simplest way to create a record array is with &lt;code&gt;numpy.rec.array&lt;/code&gt;:</source>
          <target state="translated">创建记录数组的最简单方法是使用 &lt;code&gt;numpy.rec.array&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="47091f34475faaaa1ba4de46a8ad6549a8d5a1f2" translate="yes" xml:space="preserve">
          <source>The simulation of a C-style array is not complete for 2-d and 3-d arrays. For example, the simulated arrays of pointers cannot be passed to subroutines expecting specific, statically-defined 2-d and 3-d arrays. To pass to functions requiring those kind of inputs, you must statically define the required array and copy data.</source>
          <target state="translated">对于2-d和3-d数组来说,C式数组的模拟是不完整的。例如,模拟的指针数组不能传递给期望特定的、静态定义的2-d和3-d数组的子程序。要传递给需要这类输入的函数,必须静态定义所需的数组并复制数据。</target>
        </trans-unit>
        <trans-unit id="51abf12252a4d92a90b52830906a8c2bd4002537" translate="yes" xml:space="preserve">
          <source>The sinc function is</source>
          <target state="translated">sinc函数是</target>
        </trans-unit>
        <trans-unit id="ca8287ab64739fe1883b42785585fd67081d297d" translate="yes" xml:space="preserve">
          <source>The sinc function is used in various signal processing applications, including in anti-aliasing, in the construction of a Lanczos resampling filter, and in interpolation.</source>
          <target state="translated">sinc函数在各种信号处理中都有应用,包括抗锯齿、Lanczos重采样滤波器的构造和插值。</target>
        </trans-unit>
        <trans-unit id="237e09976f401d9a2f1baabe777a697734eddddd" translate="yes" xml:space="preserve">
          <source>The sine is one of the fundamental functions of trigonometry (the mathematical study of triangles). Consider a circle of radius 1 centered on the origin. A ray comes in from the</source>
          <target state="translated">正弦是三角学(三角形的数学研究)的基本函数之一。考虑以原点为中心的半径为1的圆。一条射线从</target>
        </trans-unit>
        <trans-unit id="eeee63a3a1e6205f2e90fb5ed65d351e3798fee5" translate="yes" xml:space="preserve">
          <source>The sine of each element of x. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">x的每个元素的正弦。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="b9c09c4d5914f0dda5c0b150c5f3b90e766bd841" translate="yes" xml:space="preserve">
          <source>The single threaded call directly uses the BitGenerator.</source>
          <target state="translated">单线程调用直接使用BitGenerator。</target>
        </trans-unit>
        <trans-unit id="4e52363a0d1aff84bc0a45f224b49ba218e2396a" translate="yes" xml:space="preserve">
          <source>The situation with numpy makes this issue yet more complicated. The internal machinery of numpy arrays is flexible enough to accept any ordering of indices. One can simply reorder indices by manipulating the internal stride information for arrays without reordering the data at all. NumPy will know how to map the new index order to the data without moving the data.</source>
          <target state="translated">numpy的情况使得这个问题更加复杂。numpy数组的内部机制非常灵活,可以接受任何索引的排序。我们可以简单地通过操作数组的内部跨步信息来重新排列索引,而完全不需要重新排列数据。NumPy将知道如何在不移动数据的情况下将新的索引顺序映射到数据上。</target>
        </trans-unit>
        <trans-unit id="6d5ab6e4dc0fec0528be17bc5d4e3ad5f3c1a900" translate="yes" xml:space="preserve">
          <source>The size in each dimension of the output shape is the maximum of all the input sizes in that dimension.</source>
          <target state="translated">输出形状的每个维度的尺寸是该维度中所有输入尺寸的最大值。</target>
        </trans-unit>
        <trans-unit id="9a3ff85912460f4dce83d9377238c987b64400fb" translate="yes" xml:space="preserve">
          <source>The size of each dimension of the array can be passed as individual parameters or as the elements of a tuple.</source>
          <target state="translated">数组中每个维度的大小可以作为单个参数或元组的元素传递。</target>
        </trans-unit>
        <trans-unit id="0f600bd12887e2a8896ddc5bed9d6833c21b9000" translate="yes" xml:space="preserve">
          <source>The size of each dimension of the array.</source>
          <target state="translated">数组中每个维度的大小。</target>
        </trans-unit>
        <trans-unit id="53e85438a85fb68e962963fce436f922d4bad0ac" translate="yes" xml:space="preserve">
          <source>The size of each word. This should only be either &lt;a href=&quot;../../../arrays.scalars#numpy.uint32&quot;&gt;&lt;code&gt;uint32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../arrays.scalars#numpy.uint64&quot;&gt;&lt;code&gt;uint64&lt;/code&gt;&lt;/a&gt;. Strings (&lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt;, &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt;) are fine. Note that requesting &lt;a href=&quot;../../../arrays.scalars#numpy.uint64&quot;&gt;&lt;code&gt;uint64&lt;/code&gt;&lt;/a&gt; will draw twice as many bits as &lt;a href=&quot;../../../arrays.scalars#numpy.uint32&quot;&gt;&lt;code&gt;uint32&lt;/code&gt;&lt;/a&gt; for the same &lt;code&gt;n_words&lt;/code&gt;. This is a convenience for &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; arrays.</source>
          <target state="translated">每个单词的大小。这只能是&lt;a href=&quot;../../../arrays.scalars#numpy.uint32&quot;&gt; &lt;code&gt;uint32&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../../arrays.scalars#numpy.uint64&quot;&gt; &lt;code&gt;uint64&lt;/code&gt; &lt;/a&gt;。字符串（ &lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt; ， &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt; ）很好。请注意，对于相同的 &lt;code&gt;n_words&lt;/code&gt; ，请求&lt;a href=&quot;../../../arrays.scalars#numpy.uint64&quot;&gt; &lt;code&gt;uint64&lt;/code&gt; &lt;/a&gt;将绘制的位是&lt;a href=&quot;../../../arrays.scalars#numpy.uint32&quot;&gt; &lt;code&gt;uint32&lt;/code&gt; &lt;/a&gt;的两倍。这对于 &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; 数组很方便。</target>
        </trans-unit>
        <trans-unit id="bcfaa2928c38d19614d82820fec94f09b6747c0f" translate="yes" xml:space="preserve">
          <source>The size of each word. This should only be either &lt;code&gt;uint32&lt;/code&gt; or &lt;code&gt;uint64&lt;/code&gt;. Strings (&lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt;, &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt;) are fine. Note that requesting &lt;code&gt;uint64&lt;/code&gt; will draw twice as many bits as &lt;code&gt;uint32&lt;/code&gt; for the same &lt;code&gt;n_words&lt;/code&gt;. This is a convenience for &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; arrays.</source>
          <target state="translated">每个单词的大小。这只能是 &lt;code&gt;uint32&lt;/code&gt; 或 &lt;code&gt;uint64&lt;/code&gt; 。字符串（ &lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt; ， &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt; ）很好。请注意，对于相同的 &lt;code&gt;n_words&lt;/code&gt; ，请求 &lt;code&gt;uint64&lt;/code&gt; 将绘制的位是 &lt;code&gt;uint32&lt;/code&gt; 的两倍。这对于 &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; 数组很方便。</target>
        </trans-unit>
        <trans-unit id="28a984c9bdd908f87770bb977436d6a66f4306a1" translate="yes" xml:space="preserve">
          <source>The size of the array minus 1 in each dimension.</source>
          <target state="translated">数组的大小,每维减1。</target>
        </trans-unit>
        <trans-unit id="c41c1278613c7ed690de9865ed90f9449e9899a0" translate="yes" xml:space="preserve">
          <source>The size of the arrays for which the returned indices will be valid.</source>
          <target state="translated">返回索引有效的数组的大小。</target>
        </trans-unit>
        <trans-unit id="d186d8343ee709824ee3589500ce1f21e3851f01" translate="yes" xml:space="preserve">
          <source>The size of the dtype element in bytes.</source>
          <target state="translated">dtype元素的大小,单位为字节。</target>
        </trans-unit>
        <trans-unit id="b0386b240ebd0571b8a05df9bc4fa0aef34289c1" translate="yes" xml:space="preserve">
          <source>The size, along each dimension, of the arrays for which the returned indices can be used.</source>
          <target state="translated">沿着每个维度,可以使用返回索引的数组的大小。</target>
        </trans-unit>
        <trans-unit id="14747cd54a2f3abe194636cc52acff3e4c5bb985" translate="yes" xml:space="preserve">
          <source>The slice is a &lt;em&gt;view&lt;/em&gt; onto the original &lt;code&gt;c_arr&lt;/code&gt; data. So, when we take a view from the ndarray, we return a new ndarray, of the same class, that points to the data in the original.</source>
          <target state="translated">切片是原始 &lt;code&gt;c_arr&lt;/code&gt; 数据的&lt;em&gt;视图&lt;/em&gt;。因此，当我们从ndarray进行查看时，我们将返回一个相同类的新ndarray，它指向原始数据。</target>
        </trans-unit>
        <trans-unit id="eb79b94dc729ec0da33bab5d4cd377a2401e89f0" translate="yes" xml:space="preserve">
          <source>The smaller object to check.</source>
          <target state="translated">要检查的小对象。</target>
        </trans-unit>
        <trans-unit id="ebb19de9c6970f0b74d4dc788893b77a8ab0bd68" translate="yes" xml:space="preserve">
          <source>The smallest positive floating point number with full precision (see Notes).</source>
          <target state="translated">全精度的最小正浮点数(见注释)。</target>
        </trans-unit>
        <trans-unit id="c2b26e02affe13f7769ad145c9ef05f90265c054" translate="yes" xml:space="preserve">
          <source>The smallest positive power of the base (2) that causes overflow.</source>
          <target state="translated">引起溢出的基数(2)的最小正功率。</target>
        </trans-unit>
        <trans-unit id="52e11ee8daa6593b3d750ee5dc32dda2fcbf193b" translate="yes" xml:space="preserve">
          <source>The smallest positive usable number. Type of &lt;code&gt;tiny&lt;/code&gt; is an appropriate floating point type.</source>
          <target state="translated">最小正可用数。 &lt;code&gt;tiny&lt;/code&gt; 类型是适当的浮点类型。</target>
        </trans-unit>
        <trans-unit id="af2a8dd9510ac11ca6b963d4ee773dcefbea79aa" translate="yes" xml:space="preserve">
          <source>The smallest representable number, typically &lt;code&gt;-max&lt;/code&gt;.</source>
          <target state="translated">最小的可表示数字，通常为 &lt;code&gt;-max&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a159db5ccf6a60aac5543438bfb54acff104da1e" translate="yes" xml:space="preserve">
          <source>The smallest representable positive number such that &lt;code&gt;1.0 + eps != 1.0&lt;/code&gt;. Type of &lt;code&gt;eps&lt;/code&gt; is an appropriate floating point type.</source>
          <target state="translated">最小的可表示正数，使得 &lt;code&gt;1.0 + eps != 1.0&lt;/code&gt; 。 &lt;code&gt;eps&lt;/code&gt; 的类型是适当的浮点类型。</target>
        </trans-unit>
        <trans-unit id="d9321ebdb39683114ce6992ea6b9cc620e5ef480" translate="yes" xml:space="preserve">
          <source>The smallest representable positive number such that &lt;code&gt;1.0 - epsneg != 1.0&lt;/code&gt;.</source>
          <target state="translated">最小的可表示正数，使得 &lt;code&gt;1.0 - epsneg != 1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="528bc510a2ddc52e9f705a28a08910ff17c4b364" translate="yes" xml:space="preserve">
          <source>The smart way</source>
          <target state="translated">聪明的方法</target>
        </trans-unit>
        <trans-unit id="fdf4e6a27441f2bc059f1e2263f51d77fbf6e55a" translate="yes" xml:space="preserve">
          <source>The so-called F2PY directives allow using F2PY signature file constructs also in Fortran 77/90 source codes. With this feature you can skip (almost) completely intermediate signature file generations and apply F2PY directly to Fortran source codes.</source>
          <target state="translated">所谓的F2PY指令允许在Fortran 77/90源代码中也使用F2PY签名文件结构。有了这个功能,您可以跳过(几乎)完全中间的签名文件生成,直接将F2PY应用到Fortran源代码中。</target>
        </trans-unit>
        <trans-unit id="fff36344b5ce01b9f9447846bf8f8d0ca8bf20cf" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Chebyshev series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解决方案是切比雪夫系列 &lt;code&gt;p&lt;/code&gt; 的系数，该系数使加权平方误差的总和最小化</target>
        </trans-unit>
        <trans-unit id="d7b342b5e308288dae8bce1f9ff3a83bc7ae73a3" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Hermite series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解决方案是使最小化加权平方误差之和的Hermite级数 &lt;code&gt;p&lt;/code&gt; 的系数</target>
        </trans-unit>
        <trans-unit id="e858f502931c190b84210ff73e4892a2231f8dea" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the HermiteE series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解决方案是HermiteE系列 &lt;code&gt;p&lt;/code&gt; 的系数，该系数使加权平方误差的总和最小化</target>
        </trans-unit>
        <trans-unit id="cac2b42634eddb5565b046dffc57149ff94fb5e5" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Laguerre series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解决方案是拉盖尔级数 &lt;code&gt;p&lt;/code&gt; 的系数，该系数使加权平方误差的总和最小化</target>
        </trans-unit>
        <trans-unit id="acc0f8a9120be725868622995211f9656fc88e64" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Legendre series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解决方案是使勒让德级数 &lt;code&gt;p&lt;/code&gt; 的系数最小化加权平方误差之和</target>
        </trans-unit>
        <trans-unit id="132408df155a153e982d44f873f2076aed312f9a" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the polynomial &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">解是多项式 &lt;code&gt;p&lt;/code&gt; 的系数，该系数使加权平方误差的总和最小化</target>
        </trans-unit>
        <trans-unit id="727489824facdfd8e793d7820b6d48d439e20ed1" translate="yes" xml:space="preserve">
          <source>The solution minimizes the squared error</source>
          <target state="translated">解决方案的平方误差最小化</target>
        </trans-unit>
        <trans-unit id="905babbec7af7dc86acc47da182cc43822ce2de5" translate="yes" xml:space="preserve">
          <source>The solution will be to either:</source>
          <target state="translated">解决办法将是要么。</target>
        </trans-unit>
        <trans-unit id="ea7110277074b52a752297c7e2a8351687eb1a36" translate="yes" xml:space="preserve">
          <source>The solutions are computed using LAPACK routine &lt;code&gt;_gesv&lt;/code&gt;.</source>
          <target state="translated">使用LAPACK例程 &lt;code&gt;_gesv&lt;/code&gt; 计算解。</target>
        </trans-unit>
        <trans-unit id="2324f65c28650d2bb749a64e0d6878a8a423096e" translate="yes" xml:space="preserve">
          <source>The sort order for complex numbers is lexicographic. If both the real and imaginary parts are non-nan then the order is determined by the real parts except when they are equal, in which case the order is determined by the imaginary parts.</source>
          <target state="translated">复数的排序顺序是词典式的。如果实部和虚部都是非纳米的,那么顺序由实部决定,除非它们相等,在这种情况下,顺序由虚部决定。</target>
        </trans-unit>
        <trans-unit id="94fa27637cf0004fe36c14f580e547f6911b6110" translate="yes" xml:space="preserve">
          <source>The sorted unique values.</source>
          <target state="translated">排序后的唯一值。</target>
        </trans-unit>
        <trans-unit id="c380c0b74f7e3ca7cbe5b2bb1b45003f6fb70837" translate="yes" xml:space="preserve">
          <source>The sorting algorithm used.</source>
          <target state="translated">使用的排序算法。</target>
        </trans-unit>
        <trans-unit id="e03d33ebb9f3232a066dd4b0991b32cb56211358" translate="yes" xml:space="preserve">
          <source>The source and destination arrays during assignment.</source>
          <target state="translated">赋值时的源数组和目的数组。</target>
        </trans-unit>
        <trans-unit id="2132b1a1146e5e5ced071e842080bf9a009b6944" translate="yes" xml:space="preserve">
          <source>The source array.</source>
          <target state="translated">源数组。</target>
        </trans-unit>
        <trans-unit id="f3a4e63ab5a7b2b3732df5942d36a724d124f0ea" translate="yes" xml:space="preserve">
          <source>The source code is only returned for objects written in Python.</source>
          <target state="translated">只有用Python编写的对象才会返回源代码。</target>
        </trans-unit>
        <trans-unit id="cf16b74745b78ed96effaeceb909805fb279ce98" translate="yes" xml:space="preserve">
          <source>The source code is only returned for objects written in Python. Many functions and classes are defined in C and will therefore not return useful information.</source>
          <target state="translated">源代码只返回用Python编写的对象。许多函数和类是用C语言定义的,因此不会返回有用的信息。</target>
        </trans-unit>
        <trans-unit id="809a1cfd22069f38c46105c92eebf5c576bb4207" translate="yes" xml:space="preserve">
          <source>The source string can be any valid Fortran code. If you want to save the extension-module source code then a suitable file-name can be provided by the &lt;code&gt;source_fn&lt;/code&gt; keyword to the compile function.</source>
          <target state="translated">源字符串可以是任何有效的Fortran代码。如果要保存扩展模块源代码，则可以通过 &lt;code&gt;source_fn&lt;/code&gt; 关键字为编译函数提供合适的文件名。</target>
        </trans-unit>
        <trans-unit id="cd5904ef77ea8bffca88dd379e736043b3ab2537" translate="yes" xml:space="preserve">
          <source>The spacing between sample points when &lt;code&gt;x&lt;/code&gt; is None. The default is 1.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 为&amp;ldquo;无&amp;rdquo; 时，采样点之间的间隔。预设值为1。</target>
        </trans-unit>
        <trans-unit id="f3c0291e43c18442ce997268f6d827c51450c140" translate="yes" xml:space="preserve">
          <source>The spacing of values of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 值的间距。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="90f7163cd42de5312873857f6e49d754d0181393" translate="yes" xml:space="preserve">
          <source>The specific algorithm used is as follows.</source>
          <target state="translated">具体采用的算法如下:</target>
        </trans-unit>
        <trans-unit id="87dcde88b185fa2a9572c4ddf0c6760b6d6e72a4" translate="yes" xml:space="preserve">
          <source>The specified line is given by &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">指定的行由 &lt;code&gt;off + scl*x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80beaa85dfa05c582a58cbd93778b4e21b5c2873" translate="yes" xml:space="preserve">
          <source>The square root of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; was a scalar, so is &lt;code&gt;out&lt;/code&gt;, otherwise an array is returned.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的平方根。如果 &lt;code&gt;x&lt;/code&gt; 是一个标量，则 &lt;code&gt;out&lt;/code&gt; 是，否则返回一个数组。</target>
        </trans-unit>
        <trans-unit id="6ffe340425612aa0e424be1bcdd9b7a397555dd0" translate="yes" xml:space="preserve">
          <source>The stacked array has one more dimension than the input arrays.</source>
          <target state="translated">叠加数组比输入数组多一个维度。</target>
        </trans-unit>
        <trans-unit id="b5df163136221ee565809e31a5ec5ce477690b37" translate="yes" xml:space="preserve">
          <source>The standard array can have 24 different data types (and has some support for adding your own types). These data types all have an enumerated type, an enumerated type-character, and a corresponding array scalar Python type object (placed in a hierarchy). There are also standard C typedefs to make it easier to manipulate elements of the given data type. For the numeric types, there are also bit-width equivalent C typedefs and named typenumbers that make it easier to select the precision desired.</source>
          <target state="translated">标准数组可以有24种不同的数据类型(并且对添加自己的类型有一定的支持)。这些数据类型都有一个枚举的类型,一个枚举的类型字符,以及一个相应的数组标量Python类型对象(放在一个层次结构中)。此外,还有标准的C类型定义,以便于操作给定数据类型的元素。对于数值类型,也有位宽等价的 C 类型定义和命名的 typenumbers,使其更容易选择所需的精度。</target>
        </trans-unit>
        <trans-unit id="45b18b5cfbbed3fbae9c681cc6f3c1fa70483591" translate="yes" xml:space="preserve">
          <source>The standard casting rules ensure that a scalar cannot up-cast an array unless the scalar is of a fundamentally different kind of data (i.e. under a different hierarchy in the data type hierarchy) then the array:</source>
          <target state="translated">标准铸造规则确保标量不能上铸数组,除非标量的数据种类与数组根本不同(即在数据类型层次结构中的不同层次下)。</target>
        </trans-unit>
        <trans-unit id="3b087bfb5ae783fa5041fbcb80716e85b4cfcd9d" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean, i.e., &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt;.</source>
          <target state="translated">标准偏差是与均值平方差的平均值的平方根，即 &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57c54b3c6804893f71da6c87373c7bbb983d07a9" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean, i.e., &lt;code&gt;std = sqrt(mean(x))&lt;/code&gt;, where &lt;code&gt;x = abs(a - a.mean())**2&lt;/code&gt;.</source>
          <target state="translated">标准偏差是与平均值平方差的平均值的平方根，即 &lt;code&gt;std = sqrt(mean(x))&lt;/code&gt; ，其中 &lt;code&gt;x = abs(a - a.mean())**2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f057ac9f65af78fe632de7c8031e6f6e2ae80dc" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean: &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt;.</source>
          <target state="translated">标准偏差是与均值平方差的平均值的平方根： &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9194bef8dfee2642aab9789d8b2c457a98f783af" translate="yes" xml:space="preserve">
          <source>The standard rules of sequence slicing apply to basic slicing on a per-dimension basis (including using a step index). Some useful concepts to remember include:</source>
          <target state="translated">序列分片的标准规则适用于按维度进行的基本分片(包括使用步长索引)。需要记住的一些有用的概念包括:</target>
        </trans-unit>
        <trans-unit id="903735d28aa358318c996f0fbe6f9bd887af58b8" translate="yes" xml:space="preserve">
          <source>The start of the data within the data buffer (an offset relative to the beginning of the data buffer).</source>
          <target state="translated">数据缓冲区内数据的开始(相对于数据缓冲区开始的偏移)。</target>
        </trans-unit>
        <trans-unit id="df2af17caf9f66a81db3bc6a51eb1b52d78258be" translate="yes" xml:space="preserve">
          <source>The start of type numbers used for Custom Data types.</source>
          <target state="translated">自定义数据类型使用的类型号的开头。</target>
        </trans-unit>
        <trans-unit id="e63c738294e147bc42d8454a2cacbd481d845725" translate="yes" xml:space="preserve">
          <source>The starting value for this product. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">此产品的起始值。有关详细信息，请参见&lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b49e967087e1769cf1a280ea97d2d8fd93d40ef9" translate="yes" xml:space="preserve">
          <source>The starting value of the sequence.</source>
          <target state="translated">序列的起始值。</target>
        </trans-unit>
        <trans-unit id="be3a2f4f7af9d19db4503332628441741d474403" translate="yes" xml:space="preserve">
          <source>The state of the returned big generator is jumped as-if 2**(128 * jumps) random numbers have been generated.</source>
          <target state="translated">返回的大生成器的状态是跳转的,因为如果2**(128 *跳转)随机数已经生成。</target>
        </trans-unit>
        <trans-unit id="9f0543dedf6d1409b4f87e0823027e644cab05a9" translate="yes" xml:space="preserve">
          <source>The step size is phi-1 when multiplied by 2**128 where phi is the golden ratio.</source>
          <target state="translated">步长大小乘以2**128时为phi-1,其中phi为黄金比例。</target>
        </trans-unit>
        <trans-unit id="ed6404a00884e4a1c814b4fe32b4f8e4142164f0" translate="yes" xml:space="preserve">
          <source>The steps are:</source>
          <target state="translated">这些步骤是:</target>
        </trans-unit>
        <trans-unit id="da99252ecc9a954c9ea523c42dd589060111b276" translate="yes" xml:space="preserve">
          <source>The strides of the array. How many bytes needed to jump to the next element in each dimension.</source>
          <target state="translated">数组的步长。在每个维度中跳转到下一个元素所需的字节数。</target>
        </trans-unit>
        <trans-unit id="6bea4f23f51bf1c5c1b134b3c31652eb62271512" translate="yes" xml:space="preserve">
          <source>The strides of the new array. Defaults to &lt;code&gt;x.strides&lt;/code&gt;.</source>
          <target state="translated">新数组的大步前进。默认为 &lt;code&gt;x.strides&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e7d4c32101a82d4a575c51fa47c579d84a90ccb" translate="yes" xml:space="preserve">
          <source>The string character corresponding to the scalar type.</source>
          <target state="translated">对应标量类型的字符串字符。</target>
        </trans-unit>
        <trans-unit id="280cdfd9e5006321af13d97ed1dea840dc6157dc" translate="yes" xml:space="preserve">
          <source>The string representation of a structured datatype is shown in the &amp;ldquo;list of tuples&amp;rdquo; form if possible, otherwise numpy falls back to using the more general dictionary form.</source>
          <target state="translated">如果可能的话，以&amp;ldquo;元组列表&amp;rdquo;形式显示结构化数据类型的字符串表示形式，否则numpy退回到使用更通用的字典形式。</target>
        </trans-unit>
        <trans-unit id="56e3689374848f3f51b64947b16bec4c3ea61c9e" translate="yes" xml:space="preserve">
          <source>The string representation of an array.</source>
          <target state="translated">数组的字符串表示。</target>
        </trans-unit>
        <trans-unit id="3e6678ed1379ae4a29d74cf130ddd533a3d54faa" translate="yes" xml:space="preserve">
          <source>The string representation of the floating point value</source>
          <target state="translated">浮点值的字符串表示</target>
        </trans-unit>
        <trans-unit id="a73fe28c8757ab0f0da0e2f4243de7dc56a5b482" translate="yes" xml:space="preserve">
          <source>The string separating numbers in the data; extra whitespace between elements is also ignored.</source>
          <target state="translated">数据中分隔数字的字符串;元素之间的额外空格也被忽略。</target>
        </trans-unit>
        <trans-unit id="3dd7799be74e76e0df59b70e60e88893f1e79944" translate="yes" xml:space="preserve">
          <source>The string to load.</source>
          <target state="translated">要加载的字符串。</target>
        </trans-unit>
        <trans-unit id="fe1a3737165141949913fff90aaf8e13cf8c53af" translate="yes" xml:space="preserve">
          <source>The string to test for equality against the expected string.</source>
          <target state="translated">要测试的字符串与预期的字符串是否相同。</target>
        </trans-unit>
        <trans-unit id="abd4042bc9b171ded494b956ae5b9d9577f995c1" translate="yes" xml:space="preserve">
          <source>The string used to separate values. By default, any consecutive whitespaces act as delimiter. An integer or sequence of integers can also be provided as width(s) of each field.</source>
          <target state="translated">用于分隔值的字符串。默认情况下,任何连续的空格都会作为分隔符。也可以提供一个整数或整数序列作为每个字段的宽度。</target>
        </trans-unit>
        <trans-unit id="af52fb130d33fe69945cefb6f52e5cf4ca3f8766" translate="yes" xml:space="preserve">
          <source>The string used to separate values. For backwards compatibility, byte strings will be decoded as &amp;lsquo;latin1&amp;rsquo;. The default is whitespace.</source>
          <target state="translated">用于分隔值的字符串。为了向后兼容，字节字符串将被解码为&amp;ldquo; latin1&amp;rdquo;。默认为空格。</target>
        </trans-unit>
        <trans-unit id="9d54c543599ad13e3bb6b6bb26859ee068b06992" translate="yes" xml:space="preserve">
          <source>The strings produced by the Python float.hex method can be used as input for floats.</source>
          <target state="translated">Python float.hex方法产生的字符串可以作为float的输入。</target>
        </trans-unit>
        <trans-unit id="4e980753b02b50913c2b5e0d5a5fa0dd49eac85d" translate="yes" xml:space="preserve">
          <source>The structured dtype of the output array</source>
          <target state="translated">输出数组的结构d类型</target>
        </trans-unit>
        <trans-unit id="05daa592464e6166b985d1ccf981f505cab14119" translate="yes" xml:space="preserve">
          <source>The sub-arrays whose main diagonals we just obtained; note that each corresponds to fixing the right-most (column) axis, and that the diagonals are &amp;ldquo;packed&amp;rdquo; in rows.</source>
          <target state="translated">我们刚刚获得的主要对角线的子数组；请注意，每个对应于固定最右边（列）的轴，并且对角线成行&amp;ldquo;打包&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="032fe52a10dbbb96d8d2155ebf017c5a37d540fb" translate="yes" xml:space="preserve">
          <source>The sub-diagonal at and below which the array is filled. &lt;code&gt;k&lt;/code&gt; = 0 is the main diagonal, while &lt;code&gt;k&lt;/code&gt; &amp;lt; 0 is below it, and &lt;code&gt;k&lt;/code&gt; &amp;gt; 0 is above. The default is 0.</source>
          <target state="translated">填充数组并在其下方的对角线。 &lt;code&gt;k&lt;/code&gt; = 0是主对角线，而 &lt;code&gt;k&lt;/code&gt; &amp;lt;0在其下方，而 &lt;code&gt;k&lt;/code&gt; &amp;gt; 0在其上方。默认值为0。</target>
        </trans-unit>
        <trans-unit id="8e6c361139d8c7c0ac565e0bf2e23b72d7fed91d" translate="yes" xml:space="preserve">
          <source>The subarrays &lt;code&gt;grid[k]&lt;/code&gt; contains the N-D array of indices along the &lt;code&gt;k-th&lt;/code&gt; axis. Explicitly:</source>
          <target state="translated">子数组 &lt;code&gt;grid[k]&lt;/code&gt; 包含沿第 &lt;code&gt;k-th&lt;/code&gt; 轴的索引的ND数组。明确地：</target>
        </trans-unit>
        <trans-unit id="c73621fe8c8d7b0663f28b8d7e7772440297f53c" translate="yes" xml:space="preserve">
          <source>The subscripts string is a comma-separated list of subscript labels, where each label refers to a dimension of the corresponding operand. Whenever a label is repeated it is summed, so &lt;code&gt;np.einsum('i,i', a, b)&lt;/code&gt; is equivalent to &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt;&lt;code&gt;np.inner(a,b)&lt;/code&gt;&lt;/a&gt;. If a label appears only once, it is not summed, so &lt;code&gt;np.einsum('i', a)&lt;/code&gt; produces a view of &lt;code&gt;a&lt;/code&gt; with no changes. A further example &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; describes traditional matrix multiplication and is equivalent to &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;np.matmul(a,b)&lt;/code&gt;&lt;/a&gt;. Repeated subscript labels in one operand take the diagonal. For example, &lt;code&gt;np.einsum('ii', a)&lt;/code&gt; is equivalent to &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;np.trace(a)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">下标字符串是用逗号分隔的下标标签列表，其中每个标签均指相应操作数的维。每当重复标签时，都会对其进行求和，因此 &lt;code&gt;np.einsum('i,i', a, b)&lt;/code&gt; 等同于&lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt; &lt;code&gt;np.inner(a,b)&lt;/code&gt; &lt;/a&gt;。如果标签仅出现一次，则不会对其进行求和，因此 &lt;code&gt;np.einsum('i', a)&lt;/code&gt; 生成的视图 &lt;code&gt;a&lt;/code&gt; 不变。另一个示例 &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; 描述了传统的矩阵乘法，并且等效于&lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;np.matmul(a,b)&lt;/code&gt; &lt;/a&gt;。一个操作数中重复的下标标签取对角线。例如， &lt;code&gt;np.einsum('ii', a)&lt;/code&gt; 等效于&lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;np.trace(a)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67e5fbff128f593f5baf173c69fe839b3262add2" translate="yes" xml:space="preserve">
          <source>The substring to search for.</source>
          <target state="translated">要搜索的子串。</target>
        </trans-unit>
        <trans-unit id="965c999c4a333ea7538f32117fa173b48c1340d4" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 之和，以元素为单位。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="6ad40e475222ea9afc0452e8c7fd45129517c8c0" translate="yes" xml:space="preserve">
          <source>The sum of an empty array is the neutral element 0:</source>
          <target state="translated">空数组的和是中性元素0。</target>
        </trans-unit>
        <trans-unit id="d51acbb68e0ec9e47200775b381bf1325a23c32a" translate="yes" xml:space="preserve">
          <source>The sum of the inputs. If either input is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</source>
          <target state="translated">输入的总和。如果任何一个输入是一个poly1d对象,那么输出也是一个poly1d对象。否则,它是由多项式系数从高到低的1D数组。</target>
        </trans-unit>
        <trans-unit id="a83a6a324c47c50fcc7b05d36f9de3513626990f" translate="yes" xml:space="preserve">
          <source>The suppression behavior is selected with the &lt;code&gt;axis&lt;/code&gt; parameter.</source>
          <target state="translated">通过 &lt;code&gt;axis&lt;/code&gt; 参数选择抑制行为。</target>
        </trans-unit>
        <trans-unit id="ac5e9039faffaa312745861609180dbee345923d" translate="yes" xml:space="preserve">
          <source>The symbol suffix avoids the symbol name clashes between 32-bit and 64-bit BLAS/LAPACK libraries.</source>
          <target state="translated">符号后缀避免了32位和64位BLAS/LAPACK库之间的符号名冲突。</target>
        </trans-unit>
        <trans-unit id="d22d2ca3e9d62707042d4e5eab8a754482cb7bf9" translate="yes" xml:space="preserve">
          <source>The syntax of signature files is presented below.</source>
          <target state="translated">签字文件的语法如下。</target>
        </trans-unit>
        <trans-unit id="dc008fb51ab0096c0ab2810136d6a94b39d8b6ae" translate="yes" xml:space="preserve">
          <source>The syntax specification for signature files (.pyf files) is borrowed from the Fortran 90/95 language specification. Almost all Fortran 90/95 standard constructs are understood, both in free and fixed format (recall that Fortran 77 is a subset of Fortran 90/95). F2PY introduces also some extensions to Fortran 90/95 language specification that help designing Fortran to Python interface, make it more &amp;ldquo;Pythonic&amp;rdquo;.</source>
          <target state="translated">签名文件（.pyf文件）的语法规范是从Fortran 90/95语言规范中借用的。自由和固定格式都可以理解几乎所有的Fortran 90/95标准构造（请记住，Fortran 77是Fortran 90/95的子集）。F2PY还引入了对Fortran 90/95语言规范的一些扩展，这些扩展有助于设计从Fortran到Python的接口，使其更加&amp;ldquo; Pythonic&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4cac57b443c7e139444cef039c708d06cc974fbe" translate="yes" xml:space="preserve">
          <source>The t test is based on an assumption that the data come from a Normal distribution. The t test provides a way to test whether the sample mean (that is the mean calculated from the data) is a good estimate of the true mean.</source>
          <target state="translated">t检验的基础是假设数据来自于正态分布。t检验提供了一种方法来检验样本平均数(即从数据中计算出的平均数)是否是真实平均数的良好估计。</target>
        </trans-unit>
        <trans-unit id="09daeca7b9767c35345c4b41aa696722f6d0ab8e" translate="yes" xml:space="preserve">
          <source>The table below gives rough equivalents for some common MATLAB expressions. These are similar expressions, not equivalents. For details, see the &lt;a href=&quot;../reference/index#reference&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">下表列出了一些常见的MATLAB表达式的大致等效项。这些是类似的表达，而不是等同的表达。有关详细信息，请参见&lt;a href=&quot;../reference/index#reference&quot;&gt;文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a7fcb5dad38e6ecd0517ba513e487ccaccafb31" translate="yes" xml:space="preserve">
          <source>The table below gives rough equivalents for some common MATLAB&amp;reg; expressions. &lt;strong&gt;These are not exact equivalents&lt;/strong&gt;, but rather should be taken as hints to get you going in the right direction. For more detail read the built-in documentation on the NumPy functions.</source>
          <target state="translated">下表列出了一些常见的MATLAB&amp;reg;表达式的大致等效项。&lt;strong&gt;这些不是精确的等价物&lt;/strong&gt;，而应作为提示使您朝正确的方向前进。有关更多详细信息，请阅读有关NumPy函数的内置文档。</target>
        </trans-unit>
        <trans-unit id="1feedf873323b1df0d515f29065f1cceac91a5f6" translate="yes" xml:space="preserve">
          <source>The template language blocks are delimited by &lt;code&gt;/**begin repeat&lt;/code&gt; and &lt;code&gt;/**end repeat**/&lt;/code&gt; lines, which may also be nested using consecutively numbered delimiting lines such as &lt;code&gt;/**begin repeat1&lt;/code&gt; and &lt;code&gt;/**end repeat1**/&lt;/code&gt;:</source>
          <target state="translated">模板语言块由分隔 &lt;code&gt;/**begin repeat&lt;/code&gt; 和 &lt;code&gt;/**end repeat**/&lt;/code&gt; 线，其也可以使用连续编号的限定线，如嵌套 &lt;code&gt;/**begin repeat1&lt;/code&gt; 和 &lt;code&gt;/**end repeat1**/&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2a419cbcd05b123b547d845ae2a3bfd3fd96fc50" translate="yes" xml:space="preserve">
          <source>The tensor dot product of the input.</source>
          <target state="translated">输入的张量点积。</target>
        </trans-unit>
        <trans-unit id="babafa633a1d5ffe1e85308352efa2b576e666e1" translate="yes" xml:space="preserve">
          <source>The term broadcasting describes how numpy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is &amp;ldquo;broadcast&amp;rdquo; across the larger array so that they have compatible shapes. Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. It does this without making needless copies of data and usually leads to efficient algorithm implementations. There are, however, cases where broadcasting is a bad idea because it leads to inefficient use of memory that slows computation.</source>
          <target state="translated">术语广播描述了numpy在算术运算期间如何处理具有不同形状的数组。受到某些约束，较小的阵列将在较大的阵列上&amp;ldquo;广播&amp;rdquo;，以使它们具有兼容的形状。广播提供了一种对数组操作进行矢量化的方法，从而使循环在C而不是Python中发生。它无需复制不必要的数据即可完成此操作，并且通常可以实现高效的算法实现。但是，在某些情况下，广播不是一个好主意，因为广播会导致内存使用效率低下，从而减慢计算速度。</target>
        </trans-unit>
        <trans-unit id="0567674780e936db24c51c4154cb1e7bb19a5fb1" translate="yes" xml:space="preserve">
          <source>The test can also be inverted:</source>
          <target state="translated">检验也可以倒置。</target>
        </trans-unit>
        <trans-unit id="a043640318788c216d9c35c72474b86e64a58875" translate="yes" xml:space="preserve">
          <source>The test is equivalent to &lt;code&gt;allclose(actual, desired, rtol, atol)&lt;/code&gt; (note that &lt;code&gt;allclose&lt;/code&gt; has different default values). It compares the difference between &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; to &lt;code&gt;atol + rtol * abs(desired)&lt;/code&gt;.</source>
          <target state="translated">该测试等效于 &lt;code&gt;allclose(actual, desired, rtol, atol)&lt;/code&gt; （请注意， &lt;code&gt;allclose&lt;/code&gt; 具有不同的默认值）。它的差进行比较之间 &lt;code&gt;actual&lt;/code&gt; 和 &lt;code&gt;desired&lt;/code&gt; 到 &lt;code&gt;atol + rtol * abs(desired)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d949a99e166ed49b879032942f22bd239ac73b6e" translate="yes" xml:space="preserve">
          <source>The test is marked as skipped if &lt;code&gt;SkipMyTest&lt;/code&gt; evaluates to nonzero, and the message in verbose test output is the second argument given to &lt;code&gt;skipif&lt;/code&gt;. Similarly, a test can be marked as a known failure by using &lt;code&gt;xfail&lt;/code&gt;:</source>
          <target state="translated">如果 &lt;code&gt;SkipMyTest&lt;/code&gt; 的评估结果为非零，则该测试被标记为已跳过，并且详细测试输出中的消息是给 &lt;code&gt;skipif&lt;/code&gt; 的第二个参数。同样，可以使用 &lt;code&gt;xfail&lt;/code&gt; 将测试标记为已知失败：</target>
        </trans-unit>
        <trans-unit id="7223f3e04a5764585f35605ea5b6d016c41f2fa7" translate="yes" xml:space="preserve">
          <source>The test method may take two or more arguments; the first &lt;code&gt;label&lt;/code&gt; is a string specifying what should be tested and the second &lt;code&gt;verbose&lt;/code&gt; is an integer giving the level of output verbosity. See the docstring &lt;a href=&quot;#numpy.test&quot;&gt;&lt;code&gt;numpy.test&lt;/code&gt;&lt;/a&gt; for details. The default value for &lt;code&gt;label&lt;/code&gt; is &amp;lsquo;fast&amp;rsquo; - which will run the standard tests. The string &amp;lsquo;full&amp;rsquo; will run the full battery of tests, including those identified as being slow to run. If &lt;code&gt;verbose&lt;/code&gt; is 1 or less, the tests will just show information messages about the tests that are run; but if it is greater than 1, then the tests will also provide warnings on missing tests. So if you want to run every test and get messages about which modules don&amp;rsquo;t have tests:</source>
          <target state="translated">测试方法可以使用两个或多个参数。第一个 &lt;code&gt;label&lt;/code&gt; 是一个字符串，指定要测试的内容，第二个 &lt;code&gt;verbose&lt;/code&gt; 是给出输出详细程度的整数。有关详细信息，请参见docstring &lt;a href=&quot;#numpy.test&quot;&gt; &lt;code&gt;numpy.test&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;label&lt;/code&gt; 的默认值为&amp;ldquo;快速&amp;rdquo;-将运行标准测试。字符串&amp;ldquo; full&amp;rdquo;将运行全部测试，包括那些确定为运行缓慢的测试。如果 &lt;code&gt;verbose&lt;/code&gt; 为1或更小，则测试将仅显示有关正在运行的测试的信息消息；否则，将显示错误消息。但是如果大于1，则测试还将针对缺少的测试提供警告。因此，如果您想运行每个测试并获取有关哪些模块没有测试的消息：</target>
        </trans-unit>
        <trans-unit id="85bd6917449fe181340a2938e0dac494fbfea5fe" translate="yes" xml:space="preserve">
          <source>The test method may take two or more arguments; the first, &lt;code&gt;label&lt;/code&gt; is a string specifying what should be tested and the second, &lt;code&gt;verbose&lt;/code&gt; is an integer giving the level of output verbosity. See the docstring for numpy.test for details. The default value for &lt;code&gt;label&lt;/code&gt; is &amp;lsquo;fast&amp;rsquo; - which will run the standard tests. The string &amp;lsquo;full&amp;rsquo; will run the full battery of tests, including those identified as being slow to run. If &lt;code&gt;verbose&lt;/code&gt; is 1 or less, the tests will just show information messages about the tests that are run; but if it is greater than 1, then the tests will also provide warnings on missing tests. So if you want to run every test and get messages about which modules don&amp;rsquo;t have tests:</source>
          <target state="translated">测试方法可以使用两个或多个参数。第一个， &lt;code&gt;label&lt;/code&gt; 是一个字符串，指定应该测试的内容，第二个， &lt;code&gt;verbose&lt;/code&gt; 是给出输出详细程度的整数。有关详细信息，请参见numpy.test的文档字符串。 &lt;code&gt;label&lt;/code&gt; 的默认值为&amp;ldquo;快速&amp;rdquo;-将运行标准测试。字符串&amp;ldquo; full&amp;rdquo;将运行全部测试，包括那些确定为运行缓慢的测试。如果 &lt;code&gt;verbose&lt;/code&gt; 为1或更小，则测试将仅显示有关正在运行的测试的信息消息；否则，将显示错误消息。但是如果大于1，则测试还将针对缺少的测试提供警告。因此，如果您想运行每个测试并获取有关哪些模块没有测试的消息：</target>
        </trans-unit>
        <trans-unit id="03733f354e779af14d028cdbdf0476c16657d14e" translate="yes" xml:space="preserve">
          <source>The test to label as slow.</source>
          <target state="translated">检验,以标为慢。</target>
        </trans-unit>
        <trans-unit id="28bda9f13cb5fd35de4d1871d5d1a6b158a05b66" translate="yes" xml:space="preserve">
          <source>The test verifies identical shapes and that the elements of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; satisfy.</source>
          <target state="translated">该测试验证相同的形状，并且满足 &lt;code&gt;actual&lt;/code&gt; 和 &lt;code&gt;desired&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="a7fabe2aaa71feebc60270bd4d75ad9164f05bed" translate="yes" xml:space="preserve">
          <source>The test verifies that the elements of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; satisfy.</source>
          <target state="translated">该测试验证 &lt;code&gt;actual&lt;/code&gt; 和 &lt;code&gt;desired&lt;/code&gt; 的元素是否满足。</target>
        </trans-unit>
        <trans-unit id="bf9247f40709953bae5128ab011a3c6a23e1bb6b" translate="yes" xml:space="preserve">
          <source>The three dimensional series is evaluated at the points &lt;code&gt;(x, y, z)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; must have the same shape. If any of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, or &lt;code&gt;z&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn&amp;rsquo;t an ndarray it is treated as a scalar.</source>
          <target state="translated">在点 &lt;code&gt;(x, y, z)&lt;/code&gt; 处评估三维序列，其中 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 必须具有相同的形状。如果 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 或 &lt;code&gt;z&lt;/code&gt; 中的任何一个是列表或元组，则首先将其转换为ndarray，否则将保持不变，并且如果它不是ndarray，则将其视为标量。</target>
        </trans-unit>
        <trans-unit id="ababec7c614f8cc809a5f4b9df993b70ee13a8f8" translate="yes" xml:space="preserve">
          <source>The three dimensional series is evaluated at the points in the Cartesian product of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt;,`y`, or &lt;code&gt;z&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">在 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 的笛卡尔积中的点处评估三维序列。如果 &lt;code&gt;x&lt;/code&gt; ，y或 &lt;code&gt;z&lt;/code&gt; 是列表或元组，则首先将其转换为ndarray，否则将保持不变，并且如果不是ndarray，则将其视为标量。</target>
        </trans-unit>
        <trans-unit id="3f792b485609224acbb4d7367551edb56b3d1d82" translate="yes" xml:space="preserve">
          <source>The three division operators are all defined; &lt;code&gt;div&lt;/code&gt; is active by default, &lt;code&gt;truediv&lt;/code&gt; is active when &lt;a href=&quot;https://docs.python.org/dev/library/__future__.html#module-__future__&quot;&gt;&lt;code&gt;__future__&lt;/code&gt;&lt;/a&gt; division is in effect.</source>
          <target state="translated">定义了三个除法运算符； &lt;code&gt;div&lt;/code&gt; 默认情况下处于活动状态，当&lt;a href=&quot;https://docs.python.org/dev/library/__future__.html#module-__future__&quot;&gt; &lt;code&gt;__future__&lt;/code&gt; &lt;/a&gt;除法生效时， &lt;code&gt;truediv&lt;/code&gt; 处于活动状态。</target>
        </trans-unit>
        <trans-unit id="6953aff01d51815d13e09f72484f920fa7369db2" translate="yes" xml:space="preserve">
          <source>The thresholds above deal with floating point roundoff error in the calculation of the SVD. However, you may have more information about the sources of error in &lt;code&gt;M&lt;/code&gt; that would make you consider other tolerance values to detect &lt;em&gt;effective&lt;/em&gt; rank deficiency. The most useful measure of the tolerance depends on the operations you intend to use on your matrix. For example, if your data come from uncertain measurements with uncertainties greater than floating point epsilon, choosing a tolerance near that uncertainty may be preferable. The tolerance may be absolute if the uncertainties are absolute rather than relative.</source>
          <target state="translated">上面的阈值处理SVD计算中的浮点舍入误差。但是，您可能具有有关 &lt;code&gt;M&lt;/code&gt; 中错误源的更多信息，这将使您考虑其他公差值来检测&lt;em&gt;有效&lt;/em&gt;等级不足。公差最有用的度量取决于要在矩阵上使用的运算。例如，如果您的数据来自不确定性测量，且不确定性大于浮点&amp;epsilon;，那么选择接近该不确定性的容差可能会更好。如果不确定性是绝对的而不是相对的，则公差可能是绝对的。</target>
        </trans-unit>
        <trans-unit id="64c20447e1e6f9694ec0f7bb75ec43f4f4cb6058" translate="yes" xml:space="preserve">
          <source>The tiled output array.</source>
          <target state="translated">平铺输出阵列。</target>
        </trans-unit>
        <trans-unit id="8bc4b16e1cf995efdf33020e8a2b8f7760d88f9e" translate="yes" xml:space="preserve">
          <source>The time required to produce using multiple threads can be compared to the time required to generate using a single thread.</source>
          <target state="translated">使用多线程生成所需的时间可以与使用单线程生成所需的时间进行比较。</target>
        </trans-unit>
        <trans-unit id="bcdefbec5fdfd59d604b41a08eaf1010ff1f9f3b" translate="yes" xml:space="preserve">
          <source>The timings below are the time in ns to produce 1 random value from a specific distribution. The original &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; generator is much slower since it requires 2 32-bit values to equal the output of the faster generators.</source>
          <target state="translated">以下时序是从特定分布中产生1个随机值的时间（以ns为单位）。原始的&lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt;生成器要慢得多，因为它需要2个32位值才能等于较快生成器的输出。</target>
        </trans-unit>
        <trans-unit id="343a5bcbcad72b541893cb8c8e45cc7f466bba8b" translate="yes" xml:space="preserve">
          <source>The timings below are the time in ns to produce 1 random value from a specific distribution. The original &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; generator is much slower since it requires 2 32-bit values to equal the output of the faster generators.</source>
          <target state="translated">以下时序是从特定分布中产生1个随机值的时间（以ns为单位）。原始的&lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt;生成器要慢得多，因为它需要2个32位值才能等于较快生成器的输出。</target>
        </trans-unit>
        <trans-unit id="1d2c30ac9be07be723e9ef95eaf137f9bc73af0a" translate="yes" xml:space="preserve">
          <source>The tolerance values are positive, typically very small numbers. The relative difference (&lt;code&gt;rtol&lt;/code&gt; * abs(&lt;code&gt;b&lt;/code&gt;)) and the absolute difference &lt;code&gt;atol&lt;/code&gt; are added together to compare against the absolute difference between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">公差值是正的，通常很小。将相对差（ &lt;code&gt;rtol&lt;/code&gt; * abs（ &lt;code&gt;b&lt;/code&gt; ））和绝对差 &lt;code&gt;atol&lt;/code&gt; 相加，以与 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 之间的绝对差进行比较。</target>
        </trans-unit>
        <trans-unit id="52a51aeadfd53cc309968068f2e1965d359a3909" translate="yes" xml:space="preserve">
          <source>The total broadcasted size.</source>
          <target state="translated">广播的总规模。</target>
        </trans-unit>
        <trans-unit id="df3d0e81279bb92508eaea005084a0b02573f0f5" translate="yes" xml:space="preserve">
          <source>The total number of arguments (&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;). This must be less than &lt;a href=&quot;array#c.NPY_MAXARGS&quot;&gt;&lt;code&gt;NPY_MAXARGS&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">参数总数（&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;）。该值必须小于&lt;a href=&quot;array#c.NPY_MAXARGS&quot;&gt; &lt;code&gt;NPY_MAXARGS&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1470f5efa816c498ec2cdd99dd6bc7fe2a058b68" translate="yes" xml:space="preserve">
          <source>The total number of arguments (&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;). This must be less than &lt;code&gt;NPY_MAXARGS&lt;/code&gt;.</source>
          <target state="translated">参数总数（&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;）。该值必须小于 &lt;code&gt;NPY_MAXARGS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af0d1953b87871e5f5c2cfb05eba9aaf99050200" translate="yes" xml:space="preserve">
          <source>The total number of built-in NumPy types. The enumeration covers the range from 0 to NPY_NTYPES-1.</source>
          <target state="translated">NumPy内置类型的总数。枚举范围从0到NPY_NTYPES-1。</target>
        </trans-unit>
        <trans-unit id="abe92a5e4aa66a77153ec46749bbd30d898eb468" translate="yes" xml:space="preserve">
          <source>The total number of masked elements (axis=None) or the number of masked elements along each slice of the given axis.</source>
          <target state="translated">掩码元素的总数(轴=None)或沿给定轴的每个切片的掩码元素的数量。</target>
        </trans-unit>
        <trans-unit id="7423c677797c62eaba11c700e763c8330a87769e" translate="yes" xml:space="preserve">
          <source>The total payment is made up of payment against principal plus interest.</source>
          <target state="translated">总的付款方式是由支付本金加利息组成。</target>
        </trans-unit>
        <trans-unit id="b7226d44903c768f342634b37f3cd2cbe870d83c" translate="yes" xml:space="preserve">
          <source>The total size of the underlying array.</source>
          <target state="translated">底层数组的总大小。</target>
        </trans-unit>
        <trans-unit id="b17ef49a2b827517f40e328c2cdae6675b6f65d6" translate="yes" xml:space="preserve">
          <source>The transform for real input is performed over the last transformation axis, as by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, then the transform over the remaining axes is performed as by &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;. The order of the output is as for &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt; for the final transformation axis, and as for &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt; for the remaining transformation axes.</source>
          <target state="translated">通过&lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt;在最后一个变换轴上执行实际输入的变换，然后通过fftn在其余轴上进行&lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt;。的输出的顺序是作为&lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt;用于最终转化轴，和作为用于&lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt;对于剩余的转换的轴。</target>
        </trans-unit>
        <trans-unit id="85975e151b66ed8086ffe0edc17f692849490b8d" translate="yes" xml:space="preserve">
          <source>The transpose of a C-ordered array is a FORTRAN-ordered array.</source>
          <target state="translated">C序数组的转置是FORTRAN序数组。</target>
        </trans-unit>
        <trans-unit id="be8d0d980a1c43a49c10382a49da454ce905c4ef" translate="yes" xml:space="preserve">
          <source>The transposed array.</source>
          <target state="translated">转置数组。</target>
        </trans-unit>
        <trans-unit id="ded8f77d9cba6691688303bd624c72d17c97324f" translate="yes" xml:space="preserve">
          <source>The tree in &lt;code&gt;numpy&lt;/code&gt; will now have the latest changes from the initial repository.</source>
          <target state="translated">&lt;code&gt;numpy&lt;/code&gt; 中的树现在将具有初始存储库中的最新更改。</target>
        </trans-unit>
        <trans-unit id="362e7b5f1deb8afe588bc61b11c57a486aa6b58d" translate="yes" xml:space="preserve">
          <source>The triangular distribution is a continuous probability distribution with lower limit left, peak at mode, and upper limit right. Unlike the other distributions, these parameters directly define the shape of the pdf.</source>
          <target state="translated">三角分布是一个连续的概率分布,其下限为左,峰值为模,上限为右。与其他分布不同,这些参数直接定义了pdf的形状。</target>
        </trans-unit>
        <trans-unit id="1d2039a815b5ec90474a824463e862d2894a1c82" translate="yes" xml:space="preserve">
          <source>The triangular distribution is often used in ill-defined problems where the underlying distribution is not known, but some knowledge of the limits and mode exists. Often it is used in simulations.</source>
          <target state="translated">三角分布经常用于定义不清的问题,其中基本分布不知道,但存在一些极限和模式的知识。三角分布经常用于模拟。</target>
        </trans-unit>
        <trans-unit id="6a93dc1adb33729debf6e5480c2814c2157666fd" translate="yes" xml:space="preserve">
          <source>The triangular window, with the maximum value normalized to one (the value one appears only if the number of samples is odd), with the first and last samples equal to zero.</source>
          <target state="translated">三角形窗口,最大值归一(只有当样本数为奇数时才会出现值一),首尾样本等于零。</target>
        </trans-unit>
        <trans-unit id="24e66129ed79808afe1e2c37f4c9f61c91ca2839" translate="yes" xml:space="preserve">
          <source>The true value of &lt;code&gt;exp(1e-10) - 1&lt;/code&gt; is &lt;code&gt;1.00000000005e-10&lt;/code&gt; to about 32 significant digits. This example shows the superiority of expm1 in this case.</source>
          <target state="translated">&lt;code&gt;exp(1e-10) - 1&lt;/code&gt; 的真实值是 &lt;code&gt;1.00000000005e-10&lt;/code&gt; 至约32个有效数字。此示例显示了这种情况下expm1的优越性。</target>
        </trans-unit>
        <trans-unit id="973da8e077b17711228349d2b08c7d0d4f2d3661" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above.</source>
          <target state="translated">截断的或填充零的输入，沿轴指示的 &lt;code&gt;axes&lt;/code&gt; 或 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;a&lt;/code&gt; 的组合转换，如上面的参数部分所述。</target>
        </trans-unit>
        <trans-unit id="0cef9d8907fc4d88debbd9a6424b4425ec58e68f" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above. The length of the last axis transformed will be &lt;code&gt;s[-1]//2+1&lt;/code&gt;, while the remaining transformed axes will have lengths according to &lt;code&gt;s&lt;/code&gt;, or unchanged from the input.</source>
          <target state="translated">截断的或填充零的输入，沿轴指示的 &lt;code&gt;axes&lt;/code&gt; 或 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;a&lt;/code&gt; 的组合转换，如上面的参数部分所述。最后变换的轴的长度将为 &lt;code&gt;s[-1]//2+1&lt;/code&gt; ，而其余​​变换后的轴将具有根据 &lt;code&gt;s&lt;/code&gt; 的长度，或与输入保持不变。</target>
        </trans-unit>
        <trans-unit id="9c91d131105a38ed60b366938edb9bb82399cba7" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above.</source>
          <target state="translated">截断的或填充零的输入，沿轴指示的 &lt;code&gt;axes&lt;/code&gt; 或 &lt;code&gt;s&lt;/code&gt; 或 &lt;code&gt;a&lt;/code&gt; 的组合转换，如上面参数部分所述。</target>
        </trans-unit>
        <trans-unit id="879b9a05c20a089a225b78254a5b2e292b149d60" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above. The length of each transformed axis is as given by the corresponding element of &lt;code&gt;s&lt;/code&gt;, or the length of the input in every axis except for the last one if &lt;code&gt;s&lt;/code&gt; is not given. In the final transformed axis the length of the output when &lt;code&gt;s&lt;/code&gt; is not given is &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the final transformed axis of the input. To get an odd number of output points in the final axis, &lt;code&gt;s&lt;/code&gt; must be specified.</source>
          <target state="translated">截断的或填充零的输入，沿着轴指示的 &lt;code&gt;axes&lt;/code&gt; 或 &lt;code&gt;s&lt;/code&gt; 或 &lt;code&gt;a&lt;/code&gt; 的组合转换，如上面的参数部分所述。每个转换轴的长度由 &lt;code&gt;s&lt;/code&gt; 的相应元素给定，或者，如果未给出 &lt;code&gt;s&lt;/code&gt; ,则除最后一个轴以外的每个轴的输入长度。在最终的变换轴上，未给出 &lt;code&gt;s&lt;/code&gt; 时输出的长度为 &lt;code&gt;2*(m-1)&lt;/code&gt; ，其中 &lt;code&gt;m&lt;/code&gt; 是输入的最终变换轴的长度。为了在最终轴上获得奇数个输出点，必须指定 &lt;code&gt;s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="933c6e0a0fb2fd7449c8d46cb7e6572b1c3279dd" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or the last two axes if &lt;code&gt;axes&lt;/code&gt; is not given.</source>
          <target state="translated">截短的或零填充的输入，沿着轴线变换指示由 &lt;code&gt;axes&lt;/code&gt; ，或最后两个轴如果 &lt;code&gt;axes&lt;/code&gt; 没有给出。</target>
        </trans-unit>
        <trans-unit id="bdca2715ebaff6edc1c47e7d7cb69eb535ec549b" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified.</source>
          <target state="translated">截短的或零填充的输入，沿着轴线变换指示由 &lt;code&gt;axis&lt;/code&gt; ，或最后一个，如果 &lt;code&gt;axis&lt;/code&gt; 没有被指定。</target>
        </trans-unit>
        <trans-unit id="f4095a8db5d8ecd4ba9c0d3227d91d6c6751102f" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. If &lt;code&gt;n&lt;/code&gt; is even, the length of the transformed axis is &lt;code&gt;(n/2)+1&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is odd, the length is &lt;code&gt;(n+1)/2&lt;/code&gt;.</source>
          <target state="translated">截短的或零填充的输入，沿着轴线变换指示由 &lt;code&gt;axis&lt;/code&gt; ，或最后一个，如果 &lt;code&gt;axis&lt;/code&gt; 没有被指定。如果 &lt;code&gt;n&lt;/code&gt; 为偶数，则变换后的轴的长度为 &lt;code&gt;(n/2)+1&lt;/code&gt; 。如果 &lt;code&gt;n&lt;/code&gt; 为奇数，则长度为 &lt;code&gt;(n+1)/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="210fa87b6170797ddb3ab263d911a488e3f1f97e" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n//2 + 1&lt;/code&gt;.</source>
          <target state="translated">截短的或零填充的输入，沿着轴线变换指示由 &lt;code&gt;axis&lt;/code&gt; ，或最后一个，如果 &lt;code&gt;axis&lt;/code&gt; 没有被指定。变换后的轴的长度为 &lt;code&gt;n//2 + 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1026feb255ba9e4ae695f12a04d60bbc57c49ac5" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n&lt;/code&gt;, or, if &lt;code&gt;n&lt;/code&gt; is not given, &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the transformed axis of the input. To get an odd number of output points, &lt;code&gt;n&lt;/code&gt; must be specified.</source>
          <target state="translated">截短的或零填充的输入，沿着轴线变换指示由 &lt;code&gt;axis&lt;/code&gt; ，或最后一个，如果 &lt;code&gt;axis&lt;/code&gt; 没有被指定。变换轴的长度为 &lt;code&gt;n&lt;/code&gt; ，或者，如果未指定 &lt;code&gt;n&lt;/code&gt; ,则为 &lt;code&gt;2*(m-1)&lt;/code&gt; ，其中 &lt;code&gt;m&lt;/code&gt; 是输入的变换轴的长度。要获得奇数个输出点，必须指定 &lt;code&gt;n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="785f913e97e6f2c077e366a11b3d02d03922b2c4" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n&lt;/code&gt;, or, if &lt;code&gt;n&lt;/code&gt; is not given, &lt;code&gt;2*m - 2&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the transformed axis of the input. To get an odd number of output points, &lt;code&gt;n&lt;/code&gt; must be specified, for instance as &lt;code&gt;2*m - 1&lt;/code&gt; in the typical case,</source>
          <target state="translated">截短的或零填充的输入，沿着轴线变换指示由 &lt;code&gt;axis&lt;/code&gt; ，或最后一个，如果 &lt;code&gt;axis&lt;/code&gt; 没有被指定。变换轴的长度为 &lt;code&gt;n&lt;/code&gt; ，或者，如果未指定 &lt;code&gt;n&lt;/code&gt; ,则为 &lt;code&gt;2*m - 2&lt;/code&gt; ，其中 &lt;code&gt;m&lt;/code&gt; 是输入的变换轴的长度。要获得奇数个输出点，必须指定 &lt;code&gt;n&lt;/code&gt; ，例如在典型情况下为 &lt;code&gt;2*m - 1&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="890cb80542174800559555fcc8928d47ac767144" translate="yes" xml:space="preserve">
          <source>The truncated value of each element in &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 中每个元素的截断值。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="d225104697ad1c2e4adc5e266a19505669d514fa" translate="yes" xml:space="preserve">
          <source>The truncated value of the scalar &lt;code&gt;x&lt;/code&gt; is the nearest integer &lt;code&gt;i&lt;/code&gt; which is closer to zero than &lt;code&gt;x&lt;/code&gt; is. In short, the fractional part of the signed number &lt;code&gt;x&lt;/code&gt; is discarded.</source>
          <target state="translated">标量 &lt;code&gt;x&lt;/code&gt; 的截断值是最接近的整数 &lt;code&gt;i&lt;/code&gt; ，它比 &lt;code&gt;x&lt;/code&gt; 更接近零。简而言之，有符号数 &lt;code&gt;x&lt;/code&gt; 的小数部分将被丢弃。</target>
        </trans-unit>
        <trans-unit id="7473e98cdd8b9577d457a4ec3ae00062b1e0d1c1" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;args&lt;/code&gt; and dict &lt;code&gt;kwargs&lt;/code&gt; are directly passed on from the original call.</source>
          <target state="translated">元组 &lt;code&gt;args&lt;/code&gt; 和dict &lt;code&gt;kwargs&lt;/code&gt; 直接从原始调用传递。</target>
        </trans-unit>
        <trans-unit id="8a95ef02498e39d8be9ecf72e13e2817e4a11b13" translate="yes" xml:space="preserve">
          <source>The tuple returned from &lt;code&gt;__array_interface__['data']&lt;/code&gt; used to be a hex-string (now it is an integer or a long integer).</source>
          <target state="translated">从 &lt;code&gt;__array_interface__['data']&lt;/code&gt; 返回的元组曾经是一个十六进制字符串（现在是整数或长整数）。</target>
        </trans-unit>
        <trans-unit id="462bd3332737c1c0e3c136e2df99165ffa307b94" translate="yes" xml:space="preserve">
          <source>The tuple returned from __array_interface__[&amp;lsquo;data&amp;rsquo;] used to be a hex-string (now it is an integer or a long integer).</source>
          <target state="translated">从__array_interface __ ['data']返回的元组曾经是一个十六进制字符串（现在是整数或长整数）。</target>
        </trans-unit>
        <trans-unit id="ac07e35413d52171420d0546afbc516e4675dfc6" translate="yes" xml:space="preserve">
          <source>The two arrays are of the same length, so there is only one position where they completely overlap:</source>
          <target state="translated">两个数组的长度相同,所以只有一个位置是完全重叠的。</target>
        </trans-unit>
        <trans-unit id="a1576896c14768083aa4b0494018f6de168f9aa6" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points &lt;code&gt;(x, y)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn&amp;rsquo;t an ndarray it is treated as a scalar.</source>
          <target state="translated">在点 &lt;code&gt;(x, y)&lt;/code&gt; 处评估二维序列，其中 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 必须具有相同的形状。如果 &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;y&lt;/code&gt; 是列表或元组，则首先将其转换为ndarray，否则将保持不变，并且如果它不是ndarray，则将其视为标量。</target>
        </trans-unit>
        <trans-unit id="2eba9ab6dc5fc4a672b7a559261dcf61c08663b7" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points &lt;code&gt;(x, y)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">在点 &lt;code&gt;(x, y)&lt;/code&gt; 处评估二维序列，其中 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 必须具有相同的形状。如果 &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;y&lt;/code&gt; 是一个列表或元组，则首先将其转换为ndarray，否则将保持不变，并且如果它不是ndarray，则将其视为标量。</target>
        </trans-unit>
        <trans-unit id="0688b7907322e12f298dd8f02d187105297d15b2" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">在 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的笛卡尔积中的点处评估二维序列。如果 &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;y&lt;/code&gt; 是一个列表或元组，则首先将其转换为ndarray，否则将保持不变，并且如果它不是ndarray，则将其视为标量。</target>
        </trans-unit>
        <trans-unit id="d4aa44f129ba54b421bffe3762821ce4945dce60" translate="yes" xml:space="preserve">
          <source>The two domains that determine the map. Each must (successfully) convert to 1-d arrays containing precisely two values.</source>
          <target state="translated">决定地图的两个域。每个域都必须(成功地)转换为精确包含两个值的一维数组。</target>
        </trans-unit>
        <trans-unit id="0027adc4d9c51b047c70705863099ef3efdd05ff" translate="yes" xml:space="preserve">
          <source>The two methods do not return the same sequence of variates.</source>
          <target state="translated">这两种方法返回的变量序列不一样。</target>
        </trans-unit>
        <trans-unit id="810d0511d5cc6182785b949cef8752429de415c1" translate="yes" xml:space="preserve">
          <source>The two&amp;rsquo;s complement is returned when the input number is negative and width is specified:</source>
          <target state="translated">当输入数字为负并且指定了宽度时，将返回二进制补码：</target>
        </trans-unit>
        <trans-unit id="584450aea06b04e9037daf43c6af1e81a83e775a" translate="yes" xml:space="preserve">
          <source>The two-dimensional FFT of real input.</source>
          <target state="translated">实输入的二维FFT。</target>
        </trans-unit>
        <trans-unit id="9b11970984391ed9339a62d69846a84202600584" translate="yes" xml:space="preserve">
          <source>The two-dimensional FFT.</source>
          <target state="translated">二维的FFT。</target>
        </trans-unit>
        <trans-unit id="93378f6188f826db256b9d6c37c0794ddd0149ba" translate="yes" xml:space="preserve">
          <source>The two-dimensional example we created using Fortran is just as easy to write in Cython:</source>
          <target state="translated">我们用Fortran创建的二维示例在Cython中写起来也同样简单。</target>
        </trans-unit>
        <trans-unit id="cc89089001cef3c7a737f8de3b95a6b67d11a175" translate="yes" xml:space="preserve">
          <source>The two-dimensional inverse FFT.</source>
          <target state="translated">二维逆向FFT。</target>
        </trans-unit>
        <trans-unit id="9f5faf584fb30081780464310b34017103e73128" translate="yes" xml:space="preserve">
          <source>The type above can either refer to an actual Python type (e.g. &lt;code&gt;int&lt;/code&gt;), or describe the type of the variable in more detail, e.g. &lt;code&gt;(N,) ndarray&lt;/code&gt; or &lt;code&gt;array_like&lt;/code&gt;.</source>
          <target state="translated">上面的类型可以引用实际的Python类型（例如 &lt;code&gt;int&lt;/code&gt; ），也可以更详细地描述变量的类型，例如 &lt;code&gt;(N,) ndarray&lt;/code&gt; 或 &lt;code&gt;array_like&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66cebb62b229032f20fef01d3cd3e2d8c08b92d1" translate="yes" xml:space="preserve">
          <source>The type object used to instantiate a scalar of this data-type.</source>
          <target state="translated">用于实例化该数据类型的标量的类型对象。</target>
        </trans-unit>
        <trans-unit id="6e4f0a20a4e71ba4f55f61f65f81013f324f6ce9" translate="yes" xml:space="preserve">
          <source>The type of the array can also be explicitly specified at creation time:</source>
          <target state="translated">数组的类型也可以在创建时明确指定。</target>
        </trans-unit>
        <trans-unit id="fa0bd68b05131d508a3464e6044d68f87729d81c" translate="yes" xml:space="preserve">
          <source>The type of the data can be accessed through the &lt;a href=&quot;#numpy.ma.MaskedArray.baseclass&quot;&gt;&lt;code&gt;baseclass&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">可以通过&lt;a href=&quot;#numpy.ma.MaskedArray.baseclass&quot;&gt; &lt;code&gt;baseclass&lt;/code&gt; &lt;/a&gt;属性访问数据的类型。</target>
        </trans-unit>
        <trans-unit id="4e723834a8970a250a2a2d214449437cb2b1463f" translate="yes" xml:space="preserve">
          <source>The type of the data can be accessed through the &lt;a href=&quot;numpy.ma.masked_array.baseclass#numpy.ma.masked_array.baseclass&quot;&gt;&lt;code&gt;baseclass&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">可以通过&lt;a href=&quot;numpy.ma.masked_array.baseclass#numpy.ma.masked_array.baseclass&quot;&gt; &lt;code&gt;baseclass&lt;/code&gt; &lt;/a&gt;属性访问数据的类型。</target>
        </trans-unit>
        <trans-unit id="55666432b4662cbbcca855eedc915c8dbb074f43" translate="yes" xml:space="preserve">
          <source>The type of the data is described by the following &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; attributes:</source>
          <target state="translated">数据的类型由以下&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;属性描述：</target>
        </trans-unit>
        <trans-unit id="7c7e8530225fc135f4d9b6eea552288840993321" translate="yes" xml:space="preserve">
          <source>The type of the input is checked, not the value. Even if the input has an imaginary part equal to zero, &lt;a href=&quot;#numpy.iscomplexobj&quot;&gt;&lt;code&gt;iscomplexobj&lt;/code&gt;&lt;/a&gt; evaluates to True.</source>
          <target state="translated">将检查输入的类型，而不是值。即使输入的虚部等于零，&lt;a href=&quot;#numpy.iscomplexobj&quot;&gt; &lt;code&gt;iscomplexobj&lt;/code&gt; 也会&lt;/a&gt;计算为True。</target>
        </trans-unit>
        <trans-unit id="1a2c8e641184f0940417186c9bd1b40520bec6a6" translate="yes" xml:space="preserve">
          <source>The type of the input is checked, not the value. So even if the input has an imaginary part equal to zero, &lt;a href=&quot;#numpy.isrealobj&quot;&gt;&lt;code&gt;isrealobj&lt;/code&gt;&lt;/a&gt; evaluates to False if the data type is complex.</source>
          <target state="translated">将检查输入的类型，而不是值。因此，即使输入的虚部等于零，&lt;a href=&quot;#numpy.isrealobj&quot;&gt; &lt;code&gt;isrealobj&lt;/code&gt; &lt;/a&gt;如果数据类型复杂，isrealobj的求值为False。</target>
        </trans-unit>
        <trans-unit id="ea61e4d42852a1b3d6a2054bbf717a4dcd45c615" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not given, infer the data type from the other input arguments.</source>
          <target state="translated">输出数组的类型。如果未给出&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;，则从其他输入参数推断数据类型。</target>
        </trans-unit>
        <trans-unit id="32f8e95967dee5b6024af49a6833df8b96400b41" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not given, the data type is inferred from &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. The inferred dtype will never be an integer; &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; is chosen even if the arguments would produce an array of integers.</source>
          <target state="translated">输出数组的类型。如果未给出&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;，则从 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;stop&lt;/code&gt; 推断出数据类型。推断的dtype永远不会是整数；即使参数将产生整数数组，也会选择&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4f2b2af4ea00b9069f29f29630cfed5b29605d4" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not given, the data type is inferred from &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. The inferred type will never be an integer; &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; is chosen even if the arguments would produce an array of integers.</source>
          <target state="translated">输出数组的类型。如果未给出&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;，则从 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;stop&lt;/code&gt; 推断出数据类型。推断的类型永远不会是整数；即使参数将产生整数数组，也会选择&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2c73d98907158f7fb67c4efa759cdbb5f806f2d4" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;code&gt;dtype&lt;/code&gt; is not given, infer the data type from the other input arguments.</source>
          <target state="translated">输出数组的类型。如果未给出 &lt;code&gt;dtype&lt;/code&gt; ，则从其他输入参数推断数据类型。</target>
        </trans-unit>
        <trans-unit id="a61a6b8f22a17e9cfb7771cdc6f2f0f745c54b06" translate="yes" xml:space="preserve">
          <source>The type of the result will depend on the encoding specified.</source>
          <target state="translated">结果的类型将取决于指定的编码。</target>
        </trans-unit>
        <trans-unit id="9f964988f963b226cae3c6098e96762218b96f31" translate="yes" xml:space="preserve">
          <source>The type of the returned array and of the accumulator in which the elements are summed. By default, the dtype of &lt;code&gt;a&lt;/code&gt; is used. An exception is when &lt;code&gt;a&lt;/code&gt; has an integer type with less precision than the platform (u)intp. In that case, the default will be either (u)int32 or (u)int64 depending on whether the platform is 32 or 64 bits. For inexact inputs, dtype must be inexact.</source>
          <target state="translated">返回的数组和累加器的类型，元素在其中累加。默认情况下，使用 &lt;code&gt;a&lt;/code&gt; 的dtype 。一个例外是当 &lt;code&gt;a&lt;/code&gt; 具有比平台（u）intp精度低的整数类型时。在这种情况下，默认值是（u）int32或（u）int64，具体取决于平台是32位还是64位。对于不精确的输入，dtype必须不精确。</target>
        </trans-unit>
        <trans-unit id="fae2388276bf4adee2baf6958155240f0239ec9b" translate="yes" xml:space="preserve">
          <source>The type of the returned array and of the accumulator in which the elements are summed. The dtype of &lt;code&gt;a&lt;/code&gt; is used by default unless &lt;code&gt;a&lt;/code&gt; has an integer dtype of less precision than the default platform integer. In that case, if &lt;code&gt;a&lt;/code&gt; is signed then the platform integer is used while if &lt;code&gt;a&lt;/code&gt; is unsigned then an unsigned integer of the same precision as the platform integer is used.</source>
          <target state="translated">返回的数组和累加器的类型，元素在其中累加。的D型细胞 &lt;code&gt;a&lt;/code&gt; 默认使用，除非 &lt;code&gt;a&lt;/code&gt; 具有比缺省平台整数精度以下的整数D型。在这种情况下，如果 &lt;code&gt;a&lt;/code&gt; 是带符号的，则使用平台整数，而如果 &lt;code&gt;a&lt;/code&gt; 是无符号的，则使用与平台整数具有相同精度的无符号整数。</target>
        </trans-unit>
        <trans-unit id="bd79c4b3d3f0f1be1ec3ce5a1aa5d47271e61a5b" translate="yes" xml:space="preserve">
          <source>The type of the returned array, as well as of the accumulator in which the elements are multiplied. The dtype of &lt;code&gt;a&lt;/code&gt; is used by default unless &lt;code&gt;a&lt;/code&gt; has an integer dtype of less precision than the default platform integer. In that case, if &lt;code&gt;a&lt;/code&gt; is signed then the platform integer is used while if &lt;code&gt;a&lt;/code&gt; is unsigned then an unsigned integer of the same precision as the platform integer is used.</source>
          <target state="translated">返回数组的类型，以及与元素相乘的累加器的类型。的D型细胞 &lt;code&gt;a&lt;/code&gt; 默认使用，除非 &lt;code&gt;a&lt;/code&gt; 具有比缺省平台整数精度以下的整数D型。在这种情况下，如果 &lt;code&gt;a&lt;/code&gt; 是带符号的，则使用平台整数，而如果 &lt;code&gt;a&lt;/code&gt; 是无符号的，则使用与平台整数具有相同精度的无符号整数。</target>
        </trans-unit>
        <trans-unit id="e3a7bb2863553d52f83413fb23d739a7fea567ae" translate="yes" xml:space="preserve">
          <source>The type used to represent the intermediate results. Defaults to the data type of the output array if this is provided, or the data type of the input array if no output array is provided.</source>
          <target state="translated">用来表示中间结果的类型,如果提供了中间结果,默认为输出数组的数据类型,如果没有提供输出数组,则默认为输入数组的数据类型。如果提供了输出数组,默认为输出数组的数据类型,如果没有提供输出数组,默认为输入数组的数据类型。</target>
        </trans-unit>
        <trans-unit id="f46b668fbc5ae74dc471bbfdc9b1c8b2040c3ed5" translate="yes" xml:space="preserve">
          <source>The type used to represent the intermediate results. Defaults to the data-type of the output array if this is provided, or the data-type of the input array if no output array is provided.</source>
          <target state="translated">用来表示中间结果的类型,如果提供了中间结果,默认为输出数组的数据类型,如果没有提供输出数组,则默认为输入数组的数据类型。如果提供了输出数组,默认为输出数组的数据类型,如果没有提供输出数组,默认为输入数组的数据类型。</target>
        </trans-unit>
        <trans-unit id="3d1a1953424d5a7364adfc318f2ceeb8ef42f6ff" translate="yes" xml:space="preserve">
          <source>The typemap directives provided by &lt;code&gt;numpy.i&lt;/code&gt; for arrays of different data types, say &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt;, and dimensions of different types, say &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;, are identical to one another except for the C and NumPy type specifications. The typemaps are therefore implemented (typically behind the scenes) via a macro:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; 为不同数据类型的数组（例如 &lt;code&gt;double&lt;/code&gt; 和 &lt;code&gt;int&lt;/code&gt; ）以及不同类型的维度（例如 &lt;code&gt;int&lt;/code&gt; 或 &lt;code&gt;long&lt;/code&gt; )提供的typemap指令彼此相同，除了C和NumPy类型规范。因此，类型映射是通过宏（通常在幕后）实现的：</target>
        </trans-unit>
        <trans-unit id="dff7b3c37fb51796f178f8cb67e96939e35d8847" translate="yes" xml:space="preserve">
          <source>The typemap signatures are largely differentiated on the name given to the buffer pointer. Names with &lt;code&gt;FARRAY&lt;/code&gt; are for Fortran-ordered arrays, and names with &lt;code&gt;ARRAY&lt;/code&gt; are for C-ordered (or 1D arrays).</source>
          <target state="translated">类型映射签名在给缓冲区指针的名称上有很大的区别。带 &lt;code&gt;FARRAY&lt;/code&gt; 的名称适用于Fortran排序的数组，带 &lt;code&gt;ARRAY&lt;/code&gt; 的名称适用于C顺序（或1D数组）。</target>
        </trans-unit>
        <trans-unit id="d316f93b51d10bd2681fb7336deed9067a473d1a" translate="yes" xml:space="preserve">
          <source>The typemaps from &lt;code&gt;numpy.i&lt;/code&gt; are responsible for the following lines of code: 12&amp;ndash;20, 25 and 30. Line 10 parses the input to the &lt;code&gt;rms&lt;/code&gt; function. From the format string &lt;code&gt;&quot;O:rms&quot;&lt;/code&gt;, we can see that the argument list is expected to be a single Python object (specified by the &lt;code&gt;O&lt;/code&gt; before the colon) and whose pointer is stored in &lt;code&gt;obj0&lt;/code&gt;. A number of functions, supplied by &lt;code&gt;numpy.i&lt;/code&gt;, are called to make and check the (possible) conversion from a generic Python object to a NumPy array. These functions are explained in the section &lt;a href=&quot;#helper-functions&quot;&gt;Helper Functions&lt;/a&gt;, but hopefully their names are self-explanatory. At line 12 we use &lt;code&gt;obj0&lt;/code&gt; to construct a NumPy array. At line 17, we check the validity of the result: that it is non-null and that it has a single dimension of arbitrary length. Once these states are verified, we extract the data buffer and length in lines 19 and 20 so that we can call the underlying C function at line 22. Line 25 performs memory management for the case where we have created a new array that is no longer needed.</source>
          <target state="translated">numpy.i的类型 &lt;code&gt;numpy.i&lt;/code&gt; 负责以下代码行：12&amp;ndash;20、25和30。第10行分析 &lt;code&gt;rms&lt;/code&gt; 函数的输入。从格式字符串 &lt;code&gt;&quot;O:rms&quot;&lt;/code&gt; ，我们可以看到参数列表应该是单个Python对象（由冒号前的 &lt;code&gt;O&lt;/code&gt; 指定），其指针存储在 &lt;code&gt;obj0&lt;/code&gt; 中。调用 &lt;code&gt;numpy.i&lt;/code&gt; 提供的许多函数来进行和检查从通用Python对象到NumPy数组的（可能的）转换。这些功能在&amp;ldquo; &lt;a href=&quot;#helper-functions&quot;&gt;帮助器功能&lt;/a&gt; &amp;rdquo;部分中进行了说明，但希望它们的名称不言自明。在第12行，我们使用 &lt;code&gt;obj0&lt;/code&gt; 构造一个NumPy数组。在第17行，我们检查结果的有效性：它为非null且具有任意长度的单个维。一旦验证了这些状态，我们将在第19行和第20行提取数据缓冲区和长度，以便可以在第22行调用基础C函数。对于创建了不再需要的新数组的情况，第25行执行内存管理。需要。</target>
        </trans-unit>
        <trans-unit id="94a9db34d902a4524ad7871b0441ea5be9c4a8b8" translate="yes" xml:space="preserve">
          <source>The typical looping construct is as follows.</source>
          <target state="translated">典型的循环结构如下。</target>
        </trans-unit>
        <trans-unit id="93f339cfb377248f9f368c97945ac549c08d48eb" translate="yes" xml:space="preserve">
          <source>The ufunc object is implemented by creation of the &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt;&lt;code&gt;PyUFunc_Type&lt;/code&gt;&lt;/a&gt;. It is a very simple type that implements only basic getattribute behavior, printing behavior, and has call behavior which allows these objects to act like functions. The basic idea behind the ufunc is to hold a reference to fast 1-dimensional (vector) loops for each data type that supports the operation. These one-dimensional loops all have the same signature and are the key to creating a new ufunc. They are called by the generic looping code as appropriate to implement the N-dimensional function. There are also some generic 1-d loops defined for floating and complexfloating arrays that allow you to define a ufunc using a single scalar function (&lt;em&gt;e.g.&lt;/em&gt; atanh).</source>
          <target state="translated">&lt;a href=&quot;#c.PyUFunc_Type&quot;&gt; &lt;code&gt;PyUFunc_Type&lt;/code&gt; &lt;/a&gt;对象是通过创建PyUFunc_Type实现的。这是一种非常简单的类型，仅实现基本的getattribute行为，打印行为，并具有允许这些对象充当函数的调用行为。ufunc的基本思想是为支持该操作的每种数据类型保留对快速一维（矢量）循环的引用。这些一维循环都具有相同的签名，并且是创建新的ufunc的关键。它们由通用循环代码适当地调用以实现N维功能。还为浮点和复数浮点数组定义了一些通用的1-d循环，使您可以使用单个标量函数（&lt;em&gt;例如&lt;/em&gt; atanh）定义ufunc 。</target>
        </trans-unit>
        <trans-unit id="cf8db1044487cf17b16ec5dfd6f051754480a0fd" translate="yes" xml:space="preserve">
          <source>The ufunc still returns its output(s) even if you use the optional output argument(s).</source>
          <target state="translated">即使你使用了可选的输出参数,ufunc仍然会返回它的输出。</target>
        </trans-unit>
        <trans-unit id="a13b64ddac2c6f9c4757f678876470a35b9dd260" translate="yes" xml:space="preserve">
          <source>The umath module is a computer-generated C-module that creates many ufuncs. It provides a great many examples of how to create a universal function. Creating your own ufunc that will make use of the ufunc machinery is not difficult either. Suppose you have a function that you want to operate element-by-element over its inputs. By creating a new ufunc you will obtain a function that handles</source>
          <target state="translated">umath模块是一个计算机生成的C模块,它可以创建许多ufuncs。它提供了大量的例子来说明如何创建一个通用函数。创建自己的ufunc,利用ufunc机制也不难。假设你有一个函数,你想对它的输入逐个元素进行操作。通过创建一个新的ufunc,你将得到一个处理以下内容的函数。</target>
        </trans-unit>
        <trans-unit id="a59f16e305808090335d01a0996ae1722a21eee6" translate="yes" xml:space="preserve">
          <source>The unary &lt;code&gt;+&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.positive&lt;/code&gt; on ndarrays.</source>
          <target state="translated">一元 &lt;code&gt;+&lt;/code&gt; 运算符可用作 &lt;code&gt;np.positive&lt;/code&gt; 上np.positive的简写。</target>
        </trans-unit>
        <trans-unit id="3520cc99bc38dec23789298886ad1bf0cd8d3a9e" translate="yes" xml:space="preserve">
          <source>The unary &lt;code&gt;-&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.negative&lt;/code&gt; on ndarrays.</source>
          <target state="translated">一元 &lt;code&gt;-&lt;/code&gt; 运算符可以用作速记 &lt;code&gt;np.negative&lt;/code&gt; 上ndarrays。</target>
        </trans-unit>
        <trans-unit id="6d199d62fee4302579457e386e4a80ba73f82400" translate="yes" xml:space="preserve">
          <source>The underlying data of a masked array can be accessed in several ways:</source>
          <target state="translated">掩码数组的底层数据可以通过多种方式进行访问。</target>
        </trans-unit>
        <trans-unit id="11e8796701c0b67707f7be52c1081d9ae533b8cd" translate="yes" xml:space="preserve">
          <source>The underlying file descriptor is closed when exiting the &amp;lsquo;with&amp;rsquo; block.</source>
          <target state="translated">退出&amp;ldquo; with&amp;rdquo;块时，基础文件描述符关闭。</target>
        </trans-unit>
        <trans-unit id="8a7d26eedaa6e3c6ca58f22a4d3a1445aae9ed58" translate="yes" xml:space="preserve">
          <source>The upper-triangular matrix.</source>
          <target state="translated">上三角矩阵。</target>
        </trans-unit>
        <trans-unit id="4d3a2d4644c583ea8315d7ff8cedb605a3b103a4" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;fib1.fib&lt;/code&gt; in Python is very similar to using &lt;code&gt;FIB&lt;/code&gt; in Fortran. However, using &lt;em&gt;in situ&lt;/em&gt; output arguments in Python indicates a poor style as there is no safety mechanism in Python with respect to wrong argument types. When using Fortran or C, compilers naturally discover any type mismatches during compile time but in Python the types must be checked in runtime. So, using &lt;em&gt;in situ&lt;/em&gt; output arguments in Python may cause difficult to find bugs, not to mention that the codes will be less readable when all required type checks are implemented.</source>
          <target state="translated">在Python中使用 &lt;code&gt;fib1.fib&lt;/code&gt; 与在Fortran中使用 &lt;code&gt;FIB&lt;/code&gt; 非常相似。但是，在Python中使用&lt;em&gt;原位&lt;/em&gt;输出参数表示样式较差，因为Python中没有针对错误参数类型的安全机制。使用Fortran或C时，编译器自然会在编译期间发现任何类型不匹配的情况，但是在Python中，必须在运行时检查类型。因此，在Python中使用&lt;em&gt;原位&lt;/em&gt;输出参数可能会导致难以发现错误，更不用说在实现所有必需的类型检查后，代码的可读性也会降低。</target>
        </trans-unit>
        <trans-unit id="e4cb9fef2603ca49b4b7d883decd87bdc8eb544d" translate="yes" xml:space="preserve">
          <source>The use of random number generation is an important part of the configuration and evaluation of many numerical and machine learning algorithms. Whether you need to randomly initialize weights in an artificial neural network, split data into random sets, or randomly shuffle your dataset, being able to generate random numbers (actually, repeatable pseudo-random numbers) is essential.</source>
          <target state="translated">使用随机数生成是许多数值和机器学习算法的配置和评估的重要部分。无论你是否需要在人工神经网络中随机初始化权重,将数据分割成随机集,还是随机洗牌你的数据集,能够生成随机数(实际上是可重复的伪随机数)都是必不可少的。</target>
        </trans-unit>
        <trans-unit id="638520b9fcb56661a86b8addd734b2116df46c53" translate="yes" xml:space="preserve">
          <source>The use of this form of specification is discouraged, but documented here because older numpy code may use it. The keys of the dictionary are the field names and the values are tuples specifying type and offset:</source>
          <target state="translated">我们不鼓励使用这种形式的规范,但在这里记录下来,因为旧的numpy代码可能会使用它。字典的键是字段名,值是指定类型和偏移量的元组。</target>
        </trans-unit>
        <trans-unit id="4fb07adf94a9c0d15c6277e214f78bd8de82a95e" translate="yes" xml:space="preserve">
          <source>The user always has the option of converting to a normal &lt;code&gt;numpy.ndarray&lt;/code&gt; with &lt;a href=&quot;../reference/generated/numpy.asarray#numpy.asarray&quot;&gt;&lt;code&gt;numpy.asarray&lt;/code&gt;&lt;/a&gt; and using standard numpy from there.</source>
          <target state="translated">用户总是具有转换为正常的选项 &lt;code&gt;numpy.ndarray&lt;/code&gt; 与&lt;a href=&quot;../reference/generated/numpy.asarray#numpy.asarray&quot;&gt; &lt;code&gt;numpy.asarray&lt;/code&gt; &lt;/a&gt;并使用标准numpy的从那里。</target>
        </trans-unit>
        <trans-unit id="c853de173592dd7ca97d9f29062998fe65a116cb" translate="yes" xml:space="preserve">
          <source>The user should always check the final report through the build log to verify the enabled features.</source>
          <target state="translated">用户应随时通过构建日志检查最终报告,以验证启用的功能。</target>
        </trans-unit>
        <trans-unit id="8fcd141d1c403551e053ceda2314596f85b55796" translate="yes" xml:space="preserve">
          <source>The usual caution for verifying equality with floating point numbers is advised.</source>
          <target state="translated">建议用浮点数验证平等性时,通常要谨慎。</target>
        </trans-unit>
        <trans-unit id="6f6231b1c986a1cae99123ebb4b0aec8cf8b789f" translate="yes" xml:space="preserve">
          <source>The usual companion matrix of the Laguerre polynomials is already symmetric when &lt;code&gt;c&lt;/code&gt; is a basis Laguerre polynomial, so no scaling is applied.</source>
          <target state="translated">当 &lt;code&gt;c&lt;/code&gt; 是基本Laguerre多项式时，Laguerre多项式的通常伴随矩阵已经是对称的，因此不应用缩放。</target>
        </trans-unit>
        <trans-unit id="ab74e1cb912398a285a4b8e03a0b11ad44100129" translate="yes" xml:space="preserve">
          <source>The validation process for the requsted optimizations when it comes to &lt;code&gt;--cpu-baseline&lt;/code&gt; isn&amp;rsquo;t strict. For example, if the user requested &lt;code&gt;AVX2&lt;/code&gt; but the compiler doesn&amp;rsquo;t support it then we just skip it and return the maximum optimization that the compiler can handle depending on the implied features of &lt;code&gt;AVX2&lt;/code&gt;, let us assume &lt;code&gt;AVX&lt;/code&gt;.</source>
          <target state="translated">当涉及 &lt;code&gt;--cpu-baseline&lt;/code&gt; 时，要求优化的验证过程并不严格。例如，如果用户请求了 &lt;code&gt;AVX2&lt;/code&gt; ,但是编译器不支持它，那么我们就跳过它，并根据 &lt;code&gt;AVX2&lt;/code&gt; 的隐含功能返回编译器可以处理的最大优化，让我们假设 &lt;code&gt;AVX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1624b44eda9b54e7f0bf73b95d72ca30534e15ac" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;--cpu-baseline&lt;/code&gt; will be treated as &amp;ldquo;native&amp;rdquo; if compiler native flag &lt;code&gt;-march=native&lt;/code&gt; or &lt;code&gt;-xHost&lt;/code&gt; or &lt;code&gt;QxHost&lt;/code&gt; is enabled through environment variable &lt;code&gt;CFLAGS&lt;/code&gt;</source>
          <target state="translated">如果通过环境变量 &lt;code&gt;CFLAGS&lt;/code&gt; 启用了编译器本机标志 &lt;code&gt;-march=native&lt;/code&gt; 或 &lt;code&gt;-xHost&lt;/code&gt; 或 &lt;code&gt;QxHost&lt;/code&gt; ,则 &lt;code&gt;--cpu-baseline&lt;/code&gt; 的值将被视为&amp;ldquo;本机&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f5374a35aef1f1111ab75965c88b8c317b197461" translate="yes" xml:space="preserve">
          <source>The value of &lt;em&gt;newendian&lt;/em&gt; is one of these macros:</source>
          <target state="translated">&lt;em&gt;newendian&lt;/em&gt;的值是以下宏之一：</target>
        </trans-unit>
        <trans-unit id="f77acab0966818b5a377ef30b38be521ef7f7b59" translate="yes" xml:space="preserve">
          <source>The value of the function when x1 is 0. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">x1为0时的函数值。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="03d358ce11030b4d51f9879722053df717a3fe53" translate="yes" xml:space="preserve">
          <source>The value of this argument is typically a dictionary with column indices or column names as keys and a conversion functions as values. These conversion functions can either be actual functions or lambda functions. In any case, they should accept only a string as input and output only a single element of the wanted type.</source>
          <target state="translated">这个参数的值通常是一个以列索引或列名为键的字典和以转换函数为值的字典。这些转换函数可以是实际函数,也可以是lambda函数。在任何情况下,它们应该只接受一个字符串作为输入,并且只输出一个所需类型的单一元素。</target>
        </trans-unit>
        <trans-unit id="c3e9e5da5ef1ee5aadaa824ae3c6fd2914c94c23" translate="yes" xml:space="preserve">
          <source>The value of this attribute is used to determine what type of object to return in situations where there is more than one possibility for the Python type of the returned object. Subclasses inherit a default value of 0.0 for this attribute.</source>
          <target state="translated">这个属性的值用来决定在返回对象的Python类型有多种可能性的情况下,返回什么类型的对象。子类继承这个属性的默认值为0.0。</target>
        </trans-unit>
        <trans-unit id="8bcc816a3b6323731b656c466ec0a5744f30e87e" translate="yes" xml:space="preserve">
          <source>The value to convert. Positive and negative values are handled.</source>
          <target state="translated">要转换的值。正值和负值均可处理。</target>
        </trans-unit>
        <trans-unit id="32b4c5a64bc9a7f3fa379e6006c427acc72a2601" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="translated">用于无效条目的值（默认为无）。如果为None，则使用数组的&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="de21d1a60175f56eb618a4e1b78157f5a0b80498" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, then this argument is inferred from the passed &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, or in its absence the original array, as discussed in the notes below.</source>
          <target state="translated">用于无效条目的值（默认为无）。如果为None，则从传递的&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;推断此参数，或者在不存在的情况下从原始数组中推断出该参数，如以下注释中所述。</target>
        </trans-unit>
        <trans-unit id="46bea3445bf9a264b60905faf1d0effc77e2e249" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, then this argument is inferred from the passed &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, or in its absence the original array, as discussed in the notes below.</source>
          <target state="translated">用于无效条目的值（默认为无）。如果为None，则从传递的&lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;推断此参数，或者在不存在的情况下从原始数组中推断出该参数，如以下注释中所述。</target>
        </trans-unit>
        <trans-unit id="a8455fb8033504388eae171a33ad0ef930322f1e" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, then this argument is inferred from the passed &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, or in its absence the original array, as discussed in the notes below.</source>
          <target state="translated">用于无效条目的值（默认为无）。如果为None，则从传递的&lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;推断此参数，或者在不存在的情况下从原始数组中推断出该参数，如以下注释中所述。</target>
        </trans-unit>
        <trans-unit id="2e873302c473555951f6bce102181f00086c301d" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Can be scalar or non-scalar. If non-scalar, the resulting ndarray must be broadcastable over input array. Default is None, in which case, the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="translated">用于无效条目的值。可以是标量或非标量。如果为非标量，则生成的ndarray必须可在输入数组上广播。默认值为&amp;ldquo;无&amp;rdquo;，在这种情况下，将使用数组的&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="1880e242040c0aab4362eb1a0863297a32bd5f4b" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Can be scalar or non-scalar. If non-scalar, the resulting ndarray must be broadcastable over input array. Default is None, in which case, the &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="translated">用于无效条目的值。可以是标量或非标量。如果为非标量，则生成的ndarray必须可在输入数组上广播。默认值为&amp;ldquo;无&amp;rdquo;，在这种情况下，将使用数组的&lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="11b1837d34a4ca9f6b2279399c10c60d4b55936a" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Default is None.</source>
          <target state="translated">无效条目要使用的值。默认值为 &quot;无&quot;。</target>
        </trans-unit>
        <trans-unit id="54be798891264cab731a931b04ea9772cdab541c" translate="yes" xml:space="preserve">
          <source>The value to use for the &lt;a href=&quot;numpy.ufunc.identity#numpy.ufunc.identity&quot;&gt;&lt;code&gt;identity&lt;/code&gt;&lt;/a&gt; attribute of the resulting object. If specified, this is equivalent to setting the underlying C &lt;code&gt;identity&lt;/code&gt; field to &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;. If omitted, the identity is set to &lt;code&gt;PyUFunc_None&lt;/code&gt;. Note that this is _not_ equivalent to setting the identity to &lt;code&gt;None&lt;/code&gt;, which implies the operation is reorderable.</source>
          <target state="translated">用于结果对象的&lt;a href=&quot;numpy.ufunc.identity#numpy.ufunc.identity&quot;&gt; &lt;code&gt;identity&lt;/code&gt; &lt;/a&gt;属性的值。如果指定，则等效于将基础C &lt;code&gt;identity&lt;/code&gt; 字段设置为 &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; 。如果省略，则标识设置为 &lt;code&gt;PyUFunc_None&lt;/code&gt; 。请注意，这等效于将标识设置为 &lt;code&gt;None&lt;/code&gt; ，这意味着该操作是可重新排序的。</target>
        </trans-unit>
        <trans-unit id="adfb1baad553fefd1bd16dad3fa307f22463d54c" translate="yes" xml:space="preserve">
          <source>The value where the peak of the distribution occurs. The value must fulfill the condition &lt;code&gt;left &amp;lt;= mode &amp;lt;= right&lt;/code&gt;.</source>
          <target state="translated">分布峰值出现的值。该值必须满足条件 &lt;code&gt;left &amp;lt;= mode &amp;lt;= right&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="686c0ef41d4f40d919659043042cba31d0a83ddd" translate="yes" xml:space="preserve">
          <source>The value whose minimal data type is to be found.</source>
          <target state="translated">要找到最小数据类型的值。</target>
        </trans-unit>
        <trans-unit id="ec08073e01c06623c4f6388732ecfb40030e861d" translate="yes" xml:space="preserve">
          <source>The value with which to start the reduction. If the ufunc has no identity or the dtype is object, this defaults to None - otherwise it defaults to ufunc.identity. If &lt;code&gt;None&lt;/code&gt; is given, the first element of the reduction is used, and an error is thrown if the reduction is empty.</source>
          <target state="translated">开始减少的值。如果ufunc没有标识，或者dtype是object，则默认为None-否则默认为ufunc.identity。如果 &lt;code&gt;None&lt;/code&gt; 给出，则使用约简的第一个元素，如果约简为空，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="c02e60b2cf88beea9b6213b9d1e3b2c17ab885eb" translate="yes" xml:space="preserve">
          <source>The value(s) whose arccos is (are) required.</source>
          <target state="translated">需要其arccos的值。</target>
        </trans-unit>
        <trans-unit id="183fa270f0d1fa6f702a51a2364673ed5612bfd2" translate="yes" xml:space="preserve">
          <source>The value(s) whose arcsin is (are) required.</source>
          <target state="translated">需要的值的arcsin。</target>
        </trans-unit>
        <trans-unit id="1d4cd85936bff2c0840b52fb0d1f9b2b867275e7" translate="yes" xml:space="preserve">
          <source>The value(s) whose arctanh is (are) required.</source>
          <target state="translated">需要其arctanh值。</target>
        </trans-unit>
        <trans-unit id="d21864f90829a08fd0ce039dcaefd6c6c1041816" translate="yes" xml:space="preserve">
          <source>The value(s) whose log base 10 is (are) required.</source>
          <target state="translated">需要对数基数为10的数值。</target>
        </trans-unit>
        <trans-unit id="3a56b30d194880ee472ad588027f66ef7c7510ff" translate="yes" xml:space="preserve">
          <source>The value(s) whose log base 2 is (are) required.</source>
          <target state="translated">需要对数基数为2的数值。</target>
        </trans-unit>
        <trans-unit id="bfb30aa30026604ddea308e1175db0c56c2dbb97" translate="yes" xml:space="preserve">
          <source>The value(s) whose log base &lt;code&gt;n&lt;/code&gt; is (are) required.</source>
          <target state="translated">需要其日志基数为 &lt;code&gt;n&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="b2591ea528e39e4354f5f1d5877efb3bad7380af" translate="yes" xml:space="preserve">
          <source>The value(s) whose log is (are) required.</source>
          <target state="translated">需要对数的值。</target>
        </trans-unit>
        <trans-unit id="930e3ad8c3851bb30a80a559ca4a2af60560b1ff" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;ar1[in1d]&lt;/code&gt; are in &lt;code&gt;ar2&lt;/code&gt;.</source>
          <target state="translated">值 &lt;code&gt;ar1[in1d]&lt;/code&gt; 在 &lt;code&gt;ar2&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="a4cb91abe1a0f589bcf1ee9ebaba06339dc294dc" translate="yes" xml:space="preserve">
          <source>The values against which to test each value of &lt;code&gt;ar1&lt;/code&gt;.</source>
          <target state="translated">用于测试 &lt;code&gt;ar1&lt;/code&gt; 的每个值的值。</target>
        </trans-unit>
        <trans-unit id="55096101173292ac6a418aa55429cc3cfcc3d718" translate="yes" xml:space="preserve">
          <source>The values against which to test each value of &lt;code&gt;element&lt;/code&gt;. This argument is flattened if it is an array or array_like. See notes for behavior with non-array-like parameters.</source>
          <target state="translated">用于测试 &lt;code&gt;element&lt;/code&gt; 的每个值的值。如果它是array或array_like，则将其展平。有关非类数组参数的行为，请参见注释。</target>
        </trans-unit>
        <trans-unit id="10fa1bca5c63978c522a37d289203eb7633c9fb5" translate="yes" xml:space="preserve">
          <source>The values in the rank-1 array &lt;code&gt;p&lt;/code&gt; are coefficients of a polynomial. If the length of &lt;code&gt;p&lt;/code&gt; is n+1 then the polynomial is described by:</source>
          <target state="translated">等级1阵列 &lt;code&gt;p&lt;/code&gt; 中的值是多项式的系数。如果 &lt;code&gt;p&lt;/code&gt; 的长度为n + 1，则多项式由下式描述：</target>
        </trans-unit>
        <trans-unit id="427b2ca25633b731d69a885f7ebcb443f1d11f04" translate="yes" xml:space="preserve">
          <source>The values in the result follow so-called &amp;ldquo;standard&amp;rdquo; order: If &lt;code&gt;A =
fft(a, n)&lt;/code&gt;, then &lt;code&gt;A[0]&lt;/code&gt; contains the zero-frequency term (the sum of the signal), which is always purely real for real inputs. Then &lt;code&gt;A[1:n/2]&lt;/code&gt; contains the positive-frequency terms, and &lt;code&gt;A[n/2+1:]&lt;/code&gt; contains the negative-frequency terms, in order of decreasingly negative frequency. For an even number of input points, &lt;code&gt;A[n/2]&lt;/code&gt; represents both positive and negative Nyquist frequency, and is also purely real for real input. For an odd number of input points, &lt;code&gt;A[(n-1)/2]&lt;/code&gt; contains the largest positive frequency, while &lt;code&gt;A[(n+1)/2]&lt;/code&gt; contains the largest negative frequency. The routine &lt;code&gt;np.fft.fftfreq(n)&lt;/code&gt; returns an array giving the frequencies of corresponding elements in the output. The routine &lt;code&gt;np.fft.fftshift(A)&lt;/code&gt; shifts transforms and their frequencies to put the zero-frequency components in the middle, and &lt;code&gt;np.fft.ifftshift(A)&lt;/code&gt; undoes that shift.</source>
          <target state="translated">结果中的值遵循所谓的&amp;ldquo;标准&amp;rdquo;顺序：如果 &lt;code&gt;A = fft(a, n)&lt;/code&gt; ，则 &lt;code&gt;A[0]&lt;/code&gt; 包含零频项（信号的总和），对于实数，它始终是纯实数输入。然后， &lt;code&gt;A[1:n/2]&lt;/code&gt; 包含正频率项，而 &lt;code&gt;A[n/2+1:]&lt;/code&gt; 包含负频率项，按负频率递减的顺序排列。对于偶数个输入点， &lt;code&gt;A[n/2]&lt;/code&gt; 代表正奈奎斯特频率和负奈奎斯特频率，并且对于实数输入也是纯实数。对于奇数个输入点， &lt;code&gt;A[(n-1)/2]&lt;/code&gt; 包含最大的正频率，而 &lt;code&gt;A[(n+1)/2]&lt;/code&gt; 包含最大的负频率。例行 &lt;code&gt;np.fft.fftfreq(n)&lt;/code&gt; 返回一个数组，给出输出中相应元素的频率。例程 &lt;code&gt;np.fft.fftshift(A)&lt;/code&gt; 将变换及其频率进行移位，以将零频率分量置于中间，而 &lt;code&gt;np.fft.ifftshift(A)&lt;/code&gt; 将撤消该移位。</target>
        </trans-unit>
        <trans-unit id="049629d5662346c69d1da68173623b07fbd3ce2f" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;R&lt;/code&gt; are between -1 and 1, inclusive.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; 的值介于-1和1之间（含）。</target>
        </trans-unit>
        <trans-unit id="9be1b3aaf13595cf59a1cfa63bbe9d63fd300725" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;x1&lt;/code&gt; with the sign of &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 的值带有 &lt;code&gt;x2&lt;/code&gt; 的符号。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="0b6f0a3f189dc33bd74c3b4b3649d7d6ee49f75c" translate="yes" xml:space="preserve">
          <source>The values of the histogram. See &lt;code&gt;density&lt;/code&gt; and &lt;code&gt;weights&lt;/code&gt; for a description of the possible semantics.</source>
          <target state="translated">直方图的值。有关可能的语义的描述，请参见 &lt;code&gt;density&lt;/code&gt; 和 &lt;code&gt;weights&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94c9275f5f339f7a7296146a88f4dacc4958d420" translate="yes" xml:space="preserve">
          <source>The values of the multidimension polynomial on points formed with triples of corresponding values from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 对应值的三元组形成的点上的多维多项式的值。</target>
        </trans-unit>
        <trans-unit id="000e1e6aea9b8f07ac10536f42598c0ea9bb0313" translate="yes" xml:space="preserve">
          <source>The values of the multidimensional polynomial on points formed with triples of corresponding values from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">多维多项式在由 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 对应值的三倍形成的点上的值。</target>
        </trans-unit>
        <trans-unit id="04875120c52fa413c52d82fe0fc8626bcc9f10c7" translate="yes" xml:space="preserve">
          <source>The values of the time series of cash flows. The (fixed) time interval between cash flow &amp;ldquo;events&amp;rdquo; must be the same as that for which &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; is given (i.e., if &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; is per year, then precisely a year is understood to elapse between each cash flow event). By convention, investments or &amp;ldquo;deposits&amp;rdquo; are negative, income or &amp;ldquo;withdrawals&amp;rdquo; are positive; &lt;code&gt;values&lt;/code&gt; must begin with the initial investment, thus &lt;code&gt;values[0]&lt;/code&gt; will typically be negative.</source>
          <target state="translated">现金流量时间序列的值。现金流量&amp;ldquo;事件&amp;rdquo;之间的（固定）时间间隔必须与为其指定&lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt;时间间隔相同（即，如果&lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt;是每年，则每个现金流量事件之间精确地经过了一年）。按照惯例，投资或&amp;ldquo;存款&amp;rdquo;为负，收入或&amp;ldquo;取款&amp;rdquo;为正； &lt;code&gt;values&lt;/code&gt; 必须以初始投资开始，因此 &lt;code&gt;values[0]&lt;/code&gt; 通常为负。</target>
        </trans-unit>
        <trans-unit id="1a3aeed326405c6ff97973ff76e3c1ac5b78c950" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Chebyshev series at points formed from pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">二维切比雪夫级数的值是由 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的对应值对组成的。</target>
        </trans-unit>
        <trans-unit id="d500e0f26328b27b56cc6ea280ce335971a39a93" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Chebyshev series at points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">二维Chebyshev级数在 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的笛卡尔积上的值。</target>
        </trans-unit>
        <trans-unit id="118ceee048eeb019cc7036790e58ad86a6694410" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Legendre series at points formed from pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的对应值对构成的点处的二维Legendre级数的值。</target>
        </trans-unit>
        <trans-unit id="75bce5c26e8d20f2a28b76fe4bee99ba20e34131" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional polynomial at points formed with pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">二维多项式的值由 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的对应值对组成。</target>
        </trans-unit>
        <trans-unit id="fb47214ec0ab61ed4f83b6664e41c0aa8a83d3ed" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional polynomial at points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的笛卡尔积中的点处的二维多项式的值。</target>
        </trans-unit>
        <trans-unit id="7d3e958b62535b85e2d7d32e34bc42123eb7d409" translate="yes" xml:space="preserve">
          <source>The values reported are normalized relative to the speed of MT19937 in each table. A value of 100 indicates that the performance matches the MT19937. Higher values indicate improved performance. These values cannot be compared across tables.</source>
          <target state="translated">在每个表格中,所报告的数值相对于MT19937的速度进行了标准化处理。值为100表示性能与MT19937相匹配。值越高表示性能越好。这些值不能跨表比较。</target>
        </trans-unit>
        <trans-unit id="d8a3da63b70322018b836bf5f65f57d16d3ac651" translate="yes" xml:space="preserve">
          <source>The values whose cube-roots are required.</source>
          <target state="translated">需要其立方根的数值。</target>
        </trans-unit>
        <trans-unit id="b42bae2bd42a8c9e82a7332d1979f8a09c759feb" translate="yes" xml:space="preserve">
          <source>The values whose square-roots are required.</source>
          <target state="translated">要求其平方根的数值。</target>
        </trans-unit>
        <trans-unit id="187833930bd2cba800be6e8dd52776f374cc2f1c" translate="yes" xml:space="preserve">
          <source>The variable obtained by summing the squares of &lt;code&gt;df&lt;/code&gt; independent, standard normally distributed random variables:</source>
          <target state="translated">通过将独立于 &lt;code&gt;df&lt;/code&gt; 的平方，标准正态分布随机变量的平方相加而获得的变量：</target>
        </trans-unit>
        <trans-unit id="fddb7e65a48e5500c69e424836450e7732656827" translate="yes" xml:space="preserve">
          <source>The variable used in the string representation of &lt;code&gt;p&lt;/code&gt; can be modified, using the &lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt;&lt;code&gt;variable&lt;/code&gt;&lt;/a&gt; parameter:</source>
          <target state="translated">可以使用&lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt; &lt;code&gt;variable&lt;/code&gt; &lt;/a&gt;参数来修改 &lt;code&gt;p&lt;/code&gt; 的字符串表示中使用的变量：</target>
        </trans-unit>
        <trans-unit id="032af5a223b6a82b2905b5c850f693e8fec137cd" translate="yes" xml:space="preserve">
          <source>The variance is the average of the squared deviations from the mean, i.e., &lt;code&gt;var = mean(abs(x - x.mean())**2)&lt;/code&gt;.</source>
          <target state="translated">方差是与平均值的平方偏差的平均值，即 &lt;code&gt;var = mean(abs(x - x.mean())**2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bc052e3f44988f0e29422c1a7d1c9ad7fd6f4a4" translate="yes" xml:space="preserve">
          <source>The variance is the average of the squared deviations from the mean, i.e., &lt;code&gt;var = mean(x)&lt;/code&gt;, where &lt;code&gt;x = abs(a - a.mean())**2&lt;/code&gt;.</source>
          <target state="translated">方差是与平均值的平方偏差的平均值，即 &lt;code&gt;var = mean(x)&lt;/code&gt; ，其中 &lt;code&gt;x = abs(a - a.mean())**2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="598bba43a5fa13ecb982a04e1ac2dcfa3fb5a79a" translate="yes" xml:space="preserve">
          <source>The various character codes indicating certain types are also part of an enumerated list. References to type characters (should they be needed at all) should always use these enumerations. The form of them is &lt;code&gt;NPY_{NAME}LTR&lt;/code&gt; where &lt;code&gt;{NAME}&lt;/code&gt; can be</source>
          <target state="translated">指示某些类型的各种字符代码也是枚举列表的一部分。对类型字符的引用（应该完全需要）应始终使用这些枚举。它们的形式是 &lt;code&gt;NPY_{NAME}LTR&lt;/code&gt; ，其中 &lt;code&gt;{NAME}&lt;/code&gt; 可以是</target>
        </trans-unit>
        <trans-unit id="d2bf21ee585f4c470168bc467b8b8760de8826fd" translate="yes" xml:space="preserve">
          <source>The various routines in the Polynomial package all deal with series whose coefficients go from degree zero upward, which is the &lt;em&gt;reverse order&lt;/em&gt; of the Poly1d convention. The easy way to remember this is that indexes correspond to degree, i.e., coef[i] is the coefficient of the term of degree i.</source>
          <target state="translated">多项式程序包中的各种例程均处理其系数从零度开始向上的级数，这与Poly1d约定的&lt;em&gt;顺序相反&lt;/em&gt;。记住这一点的简单方法是索引对应于度，即coef [i]是度项i的系数。</target>
        </trans-unit>
        <trans-unit id="40dcb2f33f2d122b10f89906b0fa578dee7f50c3" translate="yes" xml:space="preserve">
          <source>The various selection algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The available algorithms have the following properties:</source>
          <target state="translated">各种选择算法的特点是:平均速度、最差情况下的性能、工作空间大小以及是否稳定。稳定的排序可以使具有相同键的项目保持相同的相对顺序。现有的算法具有以下特性。</target>
        </trans-unit>
        <trans-unit id="cc8322a9b3a11e0738c1dc848dd44452ebdc9f34" translate="yes" xml:space="preserve">
          <source>The various sorting algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The four algorithms implemented in NumPy have the following properties:</source>
          <target state="translated">各种排序算法的特点是:平均速度、最差情况下的性能、工作空间大小以及是否稳定。稳定的排序可以使具有相同键的项目保持相同的相对顺序。NumPy中实现的四种算法具有以下特性。</target>
        </trans-unit>
        <trans-unit id="909b1eaadbbd85f2064b83f98f4324e7aba0802c" translate="yes" xml:space="preserve">
          <source>The vdot(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;) function handles complex numbers differently than dot(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;). If the first argument is complex the complex conjugate of the first argument is used for the calculation of the dot product.</source>
          <target state="translated">vdot（ &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; ）函数对复数的处理方式与点（ &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; ）不同。如果第一个参数是复数，则将第一个参数的复共轭用于点积的计算。</target>
        </trans-unit>
        <trans-unit id="f8aeebbf639e209f314766460959c079ab13f5dd" translate="yes" xml:space="preserve">
          <source>The version 1.0 format only allowed the array header to have a total size of 65535 bytes. This can be exceeded by structured arrays with a large number of columns. The version 2.0 format extends the header size to 4 GiB. &lt;a href=&quot;numpy.save#numpy.save&quot;&gt;&lt;code&gt;numpy.save&lt;/code&gt;&lt;/a&gt; will automatically save in 2.0 format if the data requires it, else it will always use the more compatible 1.0 format.</source>
          <target state="translated">1.0版格式仅允许数组头的总大小为65535字节。具有大量列的结构化数组可能会超出此范围。2.0版格式将标头大小扩展到4 GiB。如果数据需要，&lt;a href=&quot;numpy.save#numpy.save&quot;&gt; &lt;code&gt;numpy.save&lt;/code&gt; &lt;/a&gt;将自动以2.0格式保存，否则它将始终使用更兼容的1.0格式。</target>
        </trans-unit>
        <trans-unit id="7a92769f6aa86193f32ae6d12aa9581114703198" translate="yes" xml:space="preserve">
          <source>The version 2 interface was very similar. The differences were largely aesthetic. In particular:</source>
          <target state="translated">第2版的界面非常相似。不同之处主要是美学上的。特别是:</target>
        </trans-unit>
        <trans-unit id="73bb55ce329b913976b213535f9642d82795177e" translate="yes" xml:space="preserve">
          <source>The version numbering of these formats is independent of NumPy version numbering. If the format is upgraded, the code in &lt;code&gt;numpy.io&lt;/code&gt; will still be able to read and write Version 1.0 files.</source>
          <target state="translated">这些格式的版本编号与NumPy版本编号无关。如果格式已升级，则 &lt;code&gt;numpy.io&lt;/code&gt; 中的代码仍将能够读取和写入1.0版文件。</target>
        </trans-unit>
        <trans-unit id="d465b2400649c410304e54f051f7d49aa970de97" translate="yes" xml:space="preserve">
          <source>The von Mises distribution (also known as the circular normal distribution) is a continuous probability distribution on the unit circle. It may be thought of as the circular analogue of the normal distribution.</source>
          <target state="translated">冯-米塞斯分布(也称为环形正态分布)是一个单位圆上的连续概率分布。它可以被认为是正态分布的圆形模拟。</target>
        </trans-unit>
        <trans-unit id="08a316a93b85a841b11a6055717875d0502f2c60" translate="yes" xml:space="preserve">
          <source>The von Mises is named for Richard Edler von Mises, who was born in Austria-Hungary, in what is now the Ukraine. He fled to the United States in 1939 and became a professor at Harvard. He worked in probability theory, aerodynamics, fluid mechanics, and philosophy of science.</source>
          <target state="translated">冯-米塞斯是以理查德-埃德勒-冯-米塞斯的名字命名的,他出生于奥匈帝国,也就是现在的乌克兰。他于1939年逃到美国,成为哈佛大学教授。他从事概率论、空气动力学、流体力学和科学哲学的研究。</target>
        </trans-unit>
        <trans-unit id="c66491ff606b4dc91911613d519dc8370dc0d225" translate="yes" xml:space="preserve">
          <source>The warnings can be turned off by</source>
          <target state="translated">可以通过以下方式关闭警告</target>
        </trans-unit>
        <trans-unit id="a3b6182c6d54b721f88f41929f57467a3fff8892" translate="yes" xml:space="preserve">
          <source>The weight function at &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 处的权重函数。</target>
        </trans-unit>
        <trans-unit id="88ba21dce5f8f071e2673c0f1f06439caa2807d7" translate="yes" xml:space="preserve">
          <source>The weight function is</source>
          <target state="translated">权重函数为</target>
        </trans-unit>
        <trans-unit id="308836c1d8a38528ab14ca4524532677c1153f22" translate="yes" xml:space="preserve">
          <source>The weight function of the Chebyshev polynomials.</source>
          <target state="translated">切比雪夫多项式的权重函数。</target>
        </trans-unit>
        <trans-unit id="adb5d593e92bd3e7a619595dc278c8d8865de5f1" translate="yes" xml:space="preserve">
          <source>The wheels and source should be uploaded to PyPI.</source>
          <target state="translated">车轮和源码应上传到PyPI。</target>
        </trans-unit>
        <trans-unit id="8a75026ea8d79cfa948ad8144c46e90db33a682b" translate="yes" xml:space="preserve">
          <source>The wheels, once built, appear at &lt;a href=&quot;https://anaconda.org/multibuild-wheels-staging/numpy&quot;&gt;https://anaconda.org/multibuild-wheels-staging/numpy&lt;/a&gt;</source>
          <target state="translated">车轮一旦制成，就会出现在&lt;a href=&quot;https://anaconda.org/multibuild-wheels-staging/numpy&quot;&gt;https://anaconda.org/multibuild-wheels-staging/numpy&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9b231b3ccfadec2079a40387b8d56e7ec8b9bb3d" translate="yes" xml:space="preserve">
          <source>The window of the converted series. If the value is None, the default window of &lt;code&gt;kind&lt;/code&gt; is used.</source>
          <target state="translated">转换后的系列的窗口。如果值为&amp;ldquo;无&amp;rdquo;，则使用默认的 &lt;code&gt;kind&lt;/code&gt; 窗口。</target>
        </trans-unit>
        <trans-unit id="1da2fe6ad3abf125b431351fbdd12b7a74edc3f3" translate="yes" xml:space="preserve">
          <source>The window, with the maximum value normalized to one (the value one appears only if &lt;code&gt;M&lt;/code&gt; is odd).</source>
          <target state="translated">最大值标准化为1的窗口（仅当 &lt;code&gt;M&lt;/code&gt; 为奇数时才显示1 ）。</target>
        </trans-unit>
        <trans-unit id="48ac736d93f8e7e8643c8e0f7b0c321855533edd" translate="yes" xml:space="preserve">
          <source>The window, with the maximum value normalized to one (the value one appears only if the number of samples is odd).</source>
          <target state="translated">窗口,最大值归一化(只有当样本数为奇数时,才会出现值一)。</target>
        </trans-unit>
        <trans-unit id="523eb308fcdc8d9a4d1dacdeabc03bc7b0a18f42" translate="yes" xml:space="preserve">
          <source>The word &amp;ldquo;non-zero&amp;rdquo; is in reference to the Python 2.x built-in method &lt;code&gt;__nonzero__()&lt;/code&gt; (renamed &lt;code&gt;__bool__()&lt;/code&gt; in Python 3.x) of Python objects that tests an object&amp;rsquo;s &amp;ldquo;truthfulness&amp;rdquo;. For example, any number is considered truthful if it is nonzero, whereas any string is considered truthful if it is not the empty string. Thus, this function (recursively) counts how many elements in &lt;code&gt;a&lt;/code&gt; (and in sub-arrays thereof) have their &lt;code&gt;__nonzero__()&lt;/code&gt; or &lt;code&gt;__bool__()&lt;/code&gt; method evaluated to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo;非零&amp;rdquo;一词是指测试对象&amp;ldquo;真实性&amp;rdquo;的Python对象的Python 2.x内置方法 &lt;code&gt;__nonzero__()&lt;/code&gt; （在Python 3.x中更名为 &lt;code&gt;__bool__()&lt;/code&gt; ）。例如，如果任何数字非零，则将其视为真实，而如果其不是空字符串，则将其视为真实。因此，该功能（递归的）计数如何在许多元素 &lt;code&gt;a&lt;/code&gt; （并且在子阵列体）具有其 &lt;code&gt;__nonzero__()&lt;/code&gt; 或 &lt;code&gt;__bool__()&lt;/code&gt; 评价方法 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3f383c240aa5414ebaced6e3034416ca7d1b6af" translate="yes" xml:space="preserve">
          <source>The wrap option affects only tall matrices:</source>
          <target state="translated">缠绕选项只影响高大的矩阵。</target>
        </trans-unit>
        <trans-unit id="fc81c936c38ae025ba8146e1222f7da14b956b1d" translate="yes" xml:space="preserve">
          <source>The x-coordinate sequence is expected to be increasing, but this is not explicitly enforced. However, if the sequence &lt;code&gt;xp&lt;/code&gt; is non-increasing, interpolation results are meaningless.</source>
          <target state="translated">x坐标序列预计会增加，但是没有明确执行。但是，如果序列 &lt;code&gt;xp&lt;/code&gt; 不增加，则插值结果将毫无意义。</target>
        </trans-unit>
        <trans-unit id="f30f1b95441858e7d3037adb27c5185133726d2e" translate="yes" xml:space="preserve">
          <source>The x-coordinates at which to evaluate the interpolated values.</source>
          <target state="translated">评估内插值的X坐标。</target>
        </trans-unit>
        <trans-unit id="98e412a8d1f1dc441497184c5505f308bf594274" translate="yes" xml:space="preserve">
          <source>The x-coordinates of the data points, must be increasing if argument &lt;code&gt;period&lt;/code&gt; is not specified. Otherwise, &lt;code&gt;xp&lt;/code&gt; is internally sorted after normalizing the periodic boundaries with &lt;code&gt;xp = xp % period&lt;/code&gt;.</source>
          <target state="translated">如果未指定参数 &lt;code&gt;period&lt;/code&gt; ，则数据点的x坐标必须增加。否则，在用 &lt;code&gt;xp = xp % period&lt;/code&gt; 归一化周期性边界之后，内部对 &lt;code&gt;xp&lt;/code&gt; 进行排序。</target>
        </trans-unit>
        <trans-unit id="5fb42b6312c1e1cea4c01b6bb567b8d84d30c4b2" translate="yes" xml:space="preserve">
          <source>The y-coordinates of the data points, same length as &lt;code&gt;xp&lt;/code&gt;.</source>
          <target state="translated">数据点的y坐标，与 &lt;code&gt;xp&lt;/code&gt; 的长度相同。</target>
        </trans-unit>
        <trans-unit id="0716cf4800278ada150f876e9ddcae3c99250b13" translate="yes" xml:space="preserve">
          <source>Their are two basic approaches to calling compiled code: writing an extension module that is then imported to Python using the import command, or calling a shared-library subroutine directly from Python using the &lt;a href=&quot;https://docs.python.org/3/library/ctypes.html&quot;&gt;ctypes&lt;/a&gt; module. Writing an extension module is the most common method.</source>
          <target state="translated">它们是调用已编译代码的两种基本方法：编写扩展模块，然后使用import命令将其导入到Python，或使用&lt;a href=&quot;https://docs.python.org/3/library/ctypes.html&quot;&gt;ctypes&lt;/a&gt;模块直接从Python调用共享库子例程。编写扩展模块是最常见的方法。</target>
        </trans-unit>
        <trans-unit id="13617ef6d1ed670620e3eee1fe6521faed558f33" translate="yes" xml:space="preserve">
          <source>Their contents are described below.</source>
          <target state="translated">其内容介绍如下。</target>
        </trans-unit>
        <trans-unit id="d67a14bba38674d133aa6326e1d56a5430227ffd" translate="yes" xml:space="preserve">
          <source>Then modify it as follows</source>
          <target state="translated">然后修改如下</target>
        </trans-unit>
        <trans-unit id="629d9c8c7e969c90c99e3fcb123c3c923c445b2e" translate="yes" xml:space="preserve">
          <source>Then set your name and email:</source>
          <target state="translated">然后设置你的名字和电子邮件。</target>
        </trans-unit>
        <trans-unit id="18de376fec5af9b24c105e03578c15d330983aed" translate="yes" xml:space="preserve">
          <source>Then you can obtain a lot of useful information (first details about &lt;code&gt;a&lt;/code&gt; itself, followed by the docstring of &lt;code&gt;ndarray&lt;/code&gt; of which &lt;code&gt;a&lt;/code&gt; is an instance):</source>
          <target state="translated">然后，您可以获得很多有用的信息（有关 &lt;code&gt;a&lt;/code&gt; 自身的第一个详细信息，其次是 &lt;code&gt;ndarray&lt;/code&gt; 的文档字符串，其中 &lt;code&gt;a&lt;/code&gt; 是实例）：</target>
        </trans-unit>
        <trans-unit id="beca14a81e09ec62e1fbfc41746f56a23c04a2b2" translate="yes" xml:space="preserve">
          <source>Then, I can compile the extension module using:</source>
          <target state="translated">然后,我可以使用扩展模块编译。</target>
        </trans-unit>
        <trans-unit id="daa5af99f0618068c146112b2487469ac95f27c4" translate="yes" xml:space="preserve">
          <source>Then, all the HTML files will be generated in &lt;code&gt;doc/build/html/&lt;/code&gt;. Since the documentation is based on docstrings, the appropriate version of numpy must be installed in the host python used to run sphinx.</source>
          <target state="translated">然后，所有HTML文件都将在 &lt;code&gt;doc/build/html/&lt;/code&gt; 。由于文档基于文档字符串，因此必须在用于运行sphinx的主机python中安装适当版本的numpy。</target>
        </trans-unit>
        <trans-unit id="7bbaffa25ddeac5ba58545ce47397f8a88d6c19f" translate="yes" xml:space="preserve">
          <source>Then, create a new branch based on the master branch of the upstream repository:</source>
          <target state="translated">然后,基于上游仓库的主分支创建一个新分支。</target>
        </trans-unit>
        <trans-unit id="a64f3ff6d48531fcbe93b1b844e9cc7950b3eeb4" translate="yes" xml:space="preserve">
          <source>Then, go to your forked repository github page, say &lt;code&gt;https://github.com/your-user-name/numpy&lt;/code&gt;</source>
          <target state="translated">然后，转到分叉的存储库github页面，说 &lt;code&gt;https://github.com/your-user-name/numpy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="2a2d6eb0d79238cba7c8636b58f3ce6ad4b5b344" translate="yes" xml:space="preserve">
          <source>There are 4 relevant uses of the word &lt;code&gt;align&lt;/code&gt; used in numpy:</source>
          <target state="translated">numpy中使用 &lt;code&gt;align&lt;/code&gt; 一词有4种相关用法：</target>
        </trans-unit>
        <trans-unit id="d627a19c8c5bea4de4ec9dd15face492281b6f90" translate="yes" xml:space="preserve">
          <source>There are 5 basic numerical types representing booleans (bool), integers (int), unsigned integers (uint) floating point (float) and complex. Those with numbers in their name indicate the bitsize of the type (i.e. how many bits are needed to represent a single value in memory). Some types, such as &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;intp&lt;/code&gt;, have differing bitsizes, dependent on the platforms (e.g. 32-bit vs. 64-bit machines). This should be taken into account when interfacing with low-level code (such as C or Fortran) where the raw memory is addressed.</source>
          <target state="translated">有5种基本的数值类型，分别代表布尔（布尔），整数（int），无符号整数（uint）浮点（float）和复数。名称中带有数字的数字表示该类型的位大小（即，需要多少位来表示内存中的单个值）。某些类型（例如 &lt;code&gt;int&lt;/code&gt; 和 &lt;code&gt;intp&lt;/code&gt; ）具有不同的位大小，具体取决于平台（例如32位和64位计算机）。当与寻址原始内存的低级代码（例如C或Fortran）接口时，应考虑到这一点。</target>
        </trans-unit>
        <trans-unit id="17bb2653ac2aa7153e927fc1353ff32c9d0fadd9" translate="yes" xml:space="preserve">
          <source>There are 5 general mechanisms for creating arrays:</source>
          <target state="translated">创建数组的一般机制有5种。</target>
        </trans-unit>
        <trans-unit id="4a7e737fa7ec2df18d82d046fe4547a421ecb3b7" translate="yes" xml:space="preserve">
          <source>There are 6 (binary) flags that describe the memory area used by the data buffer. These constants are defined in &lt;code&gt;arrayobject.h&lt;/code&gt; and determine the bit-position of the flag. Python exposes a nice attribute- based interface as well as a dictionary-like interface for getting (and, if appropriate, setting) these flags.</source>
          <target state="translated">有6个（二进制）标志描述了数据缓冲区使用的存储区域。这些常量在 &lt;code&gt;arrayobject.h&lt;/code&gt; 中定义，并确定标志的位位置。Python公开了一个不错的基于属性的接口以及一个类似于字典的接口，用于获取（以及在适当情况下设置）这些标志。</target>
        </trans-unit>
        <trans-unit id="92880b58f6bd9442d0573770c5bcc16b810e1cdc" translate="yes" xml:space="preserve">
          <source>There are &lt;code&gt;num&lt;/code&gt; equally spaced samples in the closed interval &lt;code&gt;[start, stop]&lt;/code&gt; or the half-open interval &lt;code&gt;[start, stop)&lt;/code&gt; (depending on whether &lt;code&gt;endpoint&lt;/code&gt; is True or False).</source>
          <target state="translated">在关闭间隔 &lt;code&gt;[start, stop]&lt;/code&gt; 或半开间隔 &lt;code&gt;[start, stop)&lt;/code&gt; ]中有 &lt;code&gt;num&lt;/code&gt; 个等间距的样本（取决于 &lt;code&gt;endpoint&lt;/code&gt; 是True还是False）。</target>
        </trans-unit>
        <trans-unit id="8269e59da4433043c91490542198a44ae2a7bd22" translate="yes" xml:space="preserve">
          <source>There are a few commonly reported issues depending on your system/setup. If none of the following tips help you, please be sure to note the following:</source>
          <target state="translated">根据您的系统/设置,有一些常见的报告问题。如果以下提示都不能帮助你,请务必注意以下几点。</target>
        </trans-unit>
        <trans-unit id="c1df47117b7e4e6ae3cadbfbaa9a3f7c95c99296" translate="yes" xml:space="preserve">
          <source>There are a few situations where masked arrays can be more useful than just eliminating the invalid entries of an array:</source>
          <target state="translated">在一些情况下,掩码数组比仅仅消除数组的无效条目更有用。</target>
        </trans-unit>
        <trans-unit id="6f20349ffc92d6259aa973ed6765d972938b14bd" translate="yes" xml:space="preserve">
          <source>There are a number of ways to assign values to a structured array: Using python tuples, using scalar values, or using other structured arrays.</source>
          <target state="translated">有很多方法可以给结构化数组赋值。使用python元组,使用标量值,或者使用其他结构化数组。</target>
        </trans-unit>
        <trans-unit id="aabadb6a5aa99979671de060b5cf5eb2bfdc73b8" translate="yes" xml:space="preserve">
          <source>There are a variety of approaches one can use. If the file has a relatively simple format then one can write a simple I/O library and use the numpy fromfile() function and .tofile() method to read and write numpy arrays directly (mind your byteorder though!) If a good C or C++ library exists that read the data, one can wrap that library with a variety of techniques though that certainly is much more work and requires significantly more advanced knowledge to interface with C or C++.</source>
          <target state="translated">可以使用多种方法。如果文件的格式比较简单,那么可以写一个简单的I/O库,然后使用numpy fromfile()函数和.tofile()方法直接读写numpy数组(不过要注意你的字节顺序!)如果有一个很好的C或C++库可以读取数据,那么可以用各种技术来包装这个库,不过那肯定要费力得多,而且需要更高级的知识来与C或C++接口。</target>
        </trans-unit>
        <trans-unit id="6009b813cfbdbc400ba73901cd26bc8dc165215e" translate="yes" xml:space="preserve">
          <source>There are also typedefs for signed integers, unsigned integers, floating point, and complex floating point types of specific bit- widths. The available type names are</source>
          <target state="translated">还有有符号整数、无符号整数、浮点数和特定位宽的复杂浮点数类型的类型定义。可用的类型名称有</target>
        </trans-unit>
        <trans-unit id="2cd3e7355c4c3985bff39b5837a16202e8c1540c" translate="yes" xml:space="preserve">
          <source>There are currently more than 60 universal functions defined in &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; on one or more types, covering a wide variety of operations. Some of these ufuncs are called automatically on arrays when the relevant infix notation is used (&lt;em&gt;e.g.&lt;/em&gt;, &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add(a, b)&lt;/code&gt;&lt;/a&gt; is called internally when &lt;code&gt;a + b&lt;/code&gt; is written and &lt;em&gt;a&lt;/em&gt; or &lt;em&gt;b&lt;/em&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;). Nevertheless, you may still want to use the ufunc call in order to use the optional output argument(s) to place the output(s) in an object (or objects) of your choice.</source>
          <target state="translated">目前，在&lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; 中&lt;/a&gt;针对一种或多种类型定义了60多种通用函数，涵盖了多种操作。当使用相关的后缀表示法时，其中的一些ufunc会在数组上自动调用（&lt;em&gt;例如&lt;/em&gt;，当写入 &lt;code&gt;a + b&lt;/code&gt; 且&lt;em&gt;a&lt;/em&gt;或&lt;em&gt;b&lt;/em&gt;是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;时&lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt; &lt;code&gt;add(a, b)&lt;/code&gt; &lt;/a&gt;内部会调用add（a，b））。但是，您可能仍想使用ufunc调用，以便使用可选的输出参数将输出放置在您选择的一个或多个对象中。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="775b5ff21441ff77356a90016945326f51981b32" translate="yes" xml:space="preserve">
          <source>There are fairly common issues when using PyCharm together with Anaconda, please see the &lt;a href=&quot;https://www.jetbrains.com/help/pycharm/conda-support-creating-conda-virtual-environment.html&quot;&gt;PyCharm support&lt;/a&gt;</source>
          <target state="translated">将PyCharm与Anaconda一起使用时，存在相当普遍的问题，请参阅&lt;a href=&quot;https://www.jetbrains.com/help/pycharm/conda-support-creating-conda-virtual-environment.html&quot;&gt;PyCharm支持&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63abd249d8d4c496fdec07d0a25a5469a4e4f4df" translate="yes" xml:space="preserve">
          <source>There are formulas for writing useful documents, and four formulas cover nearly everything. There are four formulas because there are four categories of document &amp;ndash; &lt;code&gt;tutorial&lt;/code&gt;, &lt;code&gt;how-to guide&lt;/code&gt;, &lt;code&gt;explanation&lt;/code&gt;, and &lt;code&gt;reference&lt;/code&gt;. The insight that docs divide up this way belongs to Daniele Procida, who goes on &lt;a href=&quot;https://documentation.divio.com/&quot;&gt;in this short article&lt;/a&gt; to explain the differences and reveal the formulas. When you begin a document or propose one, have in mind which of these types it will be.</source>
          <target state="translated">有编写有用文档的公式，几乎涵盖了所有内容的四个公式。因为有四个类别的文档，所以有四个公式- &lt;code&gt;tutorial&lt;/code&gt; ，操作 &lt;code&gt;how-to guide&lt;/code&gt; ， &lt;code&gt;explanation&lt;/code&gt; 和 &lt;code&gt;reference&lt;/code&gt; 。文档以这种方式划分的见解属于Daniele Procida，他&lt;a href=&quot;https://documentation.divio.com/&quot;&gt;在这篇简短的文章中&lt;/a&gt;继续解释了差异并揭示了公式。当您开始一个文档或提出一个文档时，请记住它将是哪种类型。</target>
        </trans-unit>
        <trans-unit id="3438358c09e82d3e17ac10e9485821f710c7159e" translate="yes" xml:space="preserve">
          <source>There are libraries that can be used to generate arrays for special purposes and it isn&amp;rsquo;t possible to enumerate all of them. The most common uses are use of the many array generation functions in random that can generate arrays of random values, and some utility functions to generate special matrices (e.g. diagonal).</source>
          <target state="translated">有一些库可用于生成特殊用途的数组，并且无法枚举所有库。最常见的用途是随机使用可以生成随机值数组的许多数组生成函数，以及一些用于生成特殊矩阵（例如对角线）的实用函数。</target>
        </trans-unit>
        <trans-unit id="c69a32040141b3969da2a2cbb310c56f38084713" translate="yes" xml:space="preserve">
          <source>There are lots of examples of how to use &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; throughout the NumPy source code. The standard usage is like this:</source>
          <target state="translated">关于整个NumPy源代码，如何使用&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt;的例子很多。标准用法是这样的：</target>
        </trans-unit>
        <trans-unit id="68b9dbbab83df5d12e3f17adf9850959d4114286" translate="yes" xml:space="preserve">
          <source>There are many C or C++ array/NumPy array situations not covered by a simple &lt;code&gt;%include &quot;numpy.i&quot;&lt;/code&gt; and subsequent &lt;code&gt;%apply&lt;/code&gt; directives.</source>
          <target state="translated">简单的 &lt;code&gt;%include &quot;numpy.i&quot;&lt;/code&gt; 和后续的 &lt;code&gt;%apply&lt;/code&gt; 指令未涵盖许多C或C ++数组/ NumPy数组的情况。</target>
        </trans-unit>
        <trans-unit id="db56cb5ed387c40b2bc60fa8c76803719afb40fe" translate="yes" xml:space="preserve">
          <source>There are many online tutorials to help you &lt;a href=&quot;https://try.github.io/&quot;&gt;learn git&lt;/a&gt;. For discussions of specific git workflows, see these discussions on &lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;linux git workflow&lt;/a&gt;, and &lt;a href=&quot;https://mail.python.org/pipermail/ipython-dev/2010-October/005632.html&quot;&gt;ipython git workflow&lt;/a&gt;.</source>
          <target state="translated">有许多在线教程可以帮助您&lt;a href=&quot;https://try.github.io/&quot;&gt;学习git&lt;/a&gt;。有关特定git工作流程的讨论，请参阅有关&lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;linux git工作流程&lt;/a&gt;和&lt;a href=&quot;https://mail.python.org/pipermail/ipython-dev/2010-October/005632.html&quot;&gt;ipython git工作流程的&lt;/a&gt;这些讨论。</target>
        </trans-unit>
        <trans-unit id="a3c7bbd8e8aff936bd091f138c70193c9efdefe3" translate="yes" xml:space="preserve">
          <source>There are many online tutorials to help you &lt;a href=&quot;https://www.atlassian.com/git/tutorials/&quot;&gt;learn git&lt;/a&gt;. For discussions of specific git workflows, see these discussions on &lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;linux git workflow&lt;/a&gt;, and &lt;a href=&quot;http://mail.python.org/pipermail/ipython-dev/2010-October/006746.html&quot;&gt;ipython git workflow&lt;/a&gt;.</source>
          <target state="translated">有许多在线教程可以帮助您&lt;a href=&quot;https://www.atlassian.com/git/tutorials/&quot;&gt;学习git&lt;/a&gt;。有关特定git工作流程的讨论，请参阅有关&lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;linux git工作流程&lt;/a&gt;和&lt;a href=&quot;http://mail.python.org/pipermail/ipython-dev/2010-October/006746.html&quot;&gt;ipython git工作流程的&lt;/a&gt;这些讨论。</target>
        </trans-unit>
        <trans-unit id="4e7a362f552d6539941413dc2279097986613078" translate="yes" xml:space="preserve">
          <source>There are many ways of working with &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;; here are some posts on the rules of thumb that other projects have come up with:</source>
          <target state="translated">有很多使用&lt;a href=&quot;https://git-scm.com/&quot;&gt;git的方法&lt;/a&gt;；这是其他项目提出的一些经验法则的帖子：</target>
        </trans-unit>
        <trans-unit id="850bf20dccfb45fbea5bb3bf4cc123a24de9ce74" translate="yes" xml:space="preserve">
          <source>There are many ways to define the DFT, varying in the sign of the exponent, normalization, etc. In this implementation, the DFT is defined as</source>
          <target state="translated">定义DFT的方法有很多,在指数的符号、归一化等方面有所不同。在本实施例中,DFT被定义为</target>
        </trans-unit>
        <trans-unit id="76da8844fec054fd5276e6ad85d740b68fcb82e8" translate="yes" xml:space="preserve">
          <source>There are no general requirements on the return value from &lt;code&gt;__array_function__&lt;/code&gt;, although most sensible implementations should probably return array(s) with the same type as one of the function&amp;rsquo;s arguments.</source>
          <target state="translated">&lt;code&gt;__array_function__&lt;/code&gt; 的返回值没有一般要求，尽管大多数明智的实现可能应该返回与该函数的参数之一具有相同类型的数组。</target>
        </trans-unit>
        <trans-unit id="06faa5c6fcba06f9dd8ca92063029df6a41e4c58" translate="yes" xml:space="preserve">
          <source>There are often instances where we want NumPy to initialize the values of an array. NumPy offers functions like &lt;code&gt;ones()&lt;/code&gt; and &lt;code&gt;zeros()&lt;/code&gt;, and the &lt;code&gt;random.Generator&lt;/code&gt; class for random number generation for that. All you need to do is pass in the number of elements you want it to generate:</source>
          <target state="translated">在很多情况下，我们希望NumPy初始化数组的值。NumPy提供了 &lt;code&gt;ones()&lt;/code&gt; 和 &lt;code&gt;zeros()&lt;/code&gt; 之类的函数，以及 &lt;code&gt;random.Generator&lt;/code&gt; 类，用于生成随机数。您需要做的就是传递要生成的元素数量：</target>
        </trans-unit>
        <trans-unit id="95381d820ed4d179172c69e3a1efc8e39007df94" translate="yes" xml:space="preserve">
          <source>There are only integer array indices so that no subarray exists.</source>
          <target state="translated">只有整数组索引,所以不存在子数组。</target>
        </trans-unit>
        <trans-unit id="115526010a225042aa40f787fc2f47f797982daf" translate="yes" xml:space="preserve">
          <source>There are other points in the use of ndarrays where we need such views, such as copying arrays (&lt;code&gt;c_arr.copy()&lt;/code&gt;), creating ufunc output arrays (see also &lt;a href=&quot;#array-wrap&quot;&gt;__array_wrap__ for ufuncs and other functions&lt;/a&gt;), and reducing methods (like &lt;code&gt;c_arr.mean()&lt;/code&gt;).</source>
          <target state="translated">在使用ndarray时，还有其他需要我们提供此类视图的要点，例如复制数组（ &lt;code&gt;c_arr.copy()&lt;/code&gt; ），创建ufunc输出数组（&lt;a href=&quot;#array-wrap&quot;&gt;有关ufuncs和其他函数&lt;/a&gt;，请参见__array_wrap__）以及简化方法（如 &lt;code&gt;c_arr.mean()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="72e1214b4766467e55cb3f8f030a4456afbf45a2" translate="yes" xml:space="preserve">
          <source>There are other wrapping situations in which &lt;code&gt;numpy.i&lt;/code&gt; may be helpful when you encounter them.</source>
          <target state="translated">在其他包装情况下，遇到 &lt;code&gt;numpy.i&lt;/code&gt; 可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="318856ec210de70f7b88df3c75c2a12aaa8c93b2" translate="yes" xml:space="preserve">
          <source>There are pros and cons to using both:</source>
          <target state="translated">使用这两种方法有利有弊。</target>
        </trans-unit>
        <trans-unit id="f83bfa0078610ce5c1a2e851fa86300b3de47263" translate="yes" xml:space="preserve">
          <source>There are several disadvantages of using Cython:</source>
          <target state="translated">使用Cython有几个缺点。</target>
        </trans-unit>
        <trans-unit id="1c928426bd7e5582ef0057cd443cd0554ec0f93c" translate="yes" xml:space="preserve">
          <source>There are several examples of using the multi-iterator in the NumPy source code as it makes N-dimensional broadcasting-code very simple to write. Browse the source for more examples.</source>
          <target state="translated">在NumPy源码中,有几个使用多算子的例子,因为它使N维广播代码的编写非常简单。浏览源码以获得更多的例子。</target>
        </trans-unit>
        <trans-unit id="27bf18c3e68f395d5dcf853e32e810c666f7a43d" translate="yes" xml:space="preserve">
          <source>There are several requirements for a shared library that can be used with ctypes that are platform specific. This guide assumes you have some familiarity with making a shared library on your system (or simply have a shared library available to you). Items to remember are:</source>
          <target state="translated">共享库有几个要求,可以与平台特定的ctypes一起使用。本指南假设你对在系统上建立共享库有一定的熟悉程度(或者只是有一个共享库可供你使用)。需要记住的项目是:</target>
        </trans-unit>
        <trans-unit id="b82ec3b39568bfec9a11840bdb7b6ec4c84323cc" translate="yes" xml:space="preserve">
          <source>There are several ways to construct a masked array.</source>
          <target state="translated">有几种方法可以构建一个掩码数组。</target>
        </trans-unit>
        <trans-unit id="c4a7e4b025b48bc40d3703a29b57ae48e3043f29" translate="yes" xml:space="preserve">
          <source>There are several ways to create arrays.</source>
          <target state="translated">有几种方法可以创建数组。</target>
        </trans-unit>
        <trans-unit id="ffbc541dfd45825fd321c5ec3bdf633ecc4c702b" translate="yes" xml:space="preserve">
          <source>There are some informational attributes that universal functions possess. None of the attributes can be set.</source>
          <target state="translated">通用函数具有一些信息属性。这些属性都是不能设置的。</target>
        </trans-unit>
        <trans-unit id="25b081aeb44044a8abafdf90f986afb1775ac9ea" translate="yes" xml:space="preserve">
          <source>There are sometimes issues reported on Raspberry Pi setups when installing using &lt;code&gt;pip3 install&lt;/code&gt; (or &lt;code&gt;pip&lt;/code&gt; install). These will typically mention:</source>
          <target state="translated">使用 &lt;code&gt;pip3 install&lt;/code&gt; （或 &lt;code&gt;pip&lt;/code&gt; install）进行安装时，有时会在Raspberry Pi设置上报告一些问题。这些通常会提到：</target>
        </trans-unit>
        <trans-unit id="014e04d63bbb11cf7242b7931500c73711d0520d" translate="yes" xml:space="preserve">
          <source>There are standard variable types for each of the numeric data types and the bool data type. Some of these are already available in the C-specification. You can create variables in extension code with these types.</source>
          <target state="translated">数字数据类型和布尔数据类型都有标准的变量类型。其中一些变量类型已经在C规范中提供。你可以用这些类型在扩展代码中创建变量。</target>
        </trans-unit>
        <trans-unit id="d266f8d3fc00db82d70a1cf8a8ecaaaa80431033" translate="yes" xml:space="preserve">
          <source>There are three independent testing frameworks supported, for one-, two-, and three-dimensional arrays respectively. For one-dimensional arrays, there are two C++ files, a header and a source, named:</source>
          <target state="translated">支持的独立测试框架有三个,分别针对一维、二维和三维数组。对于一维数组,有两个C++文件,一个是头文件,一个是源文件,分别命名为。</target>
        </trans-unit>
        <trans-unit id="a98d06ff6365cb9b94028f7c87529f8503c9281a" translate="yes" xml:space="preserve">
          <source>There are three methods of ufuncs that require calculation similar to the general-purpose ufuncs. These are reduce, accumulate, and reduceat. Each of these methods requires a setup command followed by a loop. There are four loop styles possible for the methods corresponding to no-elements, one-element, strided-loop, and buffered- loop. These are the same basic loop styles as implemented for the general purpose function call except for the no-element and one- element cases which are special-cases occurring when the input array objects have 0 and 1 elements respectively.</source>
          <target state="translated">ufuncs有三种方法需要计算,类似于通用的ufuncs。这三种方法是reduce、accumulate和reduceat。每一种方法都需要一个设置命令,然后是一个循环。有四种可能的循环方式,分别对应于no-elements、one-element、strided-loop和buffered-loop。除了无元素和一元素的情况外,这些基本的循环方式和通用函数调用的基本循环方式是一样的,而无元素和一元素的情况是特殊情况,分别发生在输入数组对象有0和1个元素的时候。</target>
        </trans-unit>
        <trans-unit id="79149af5bd80302b7d9a0d00bba8113083202d98" translate="yes" xml:space="preserve">
          <source>There are three steps to the process.</source>
          <target state="translated">这个过程有三个步骤。</target>
        </trans-unit>
        <trans-unit id="30d692f23dd01af5033268a8ed1b02fd45c32c1c" translate="yes" xml:space="preserve">
          <source>There are three strategies implemented that can be used to produce repeatable pseudo-random numbers across multiple processes (local or distributed).</source>
          <target state="translated">有三种策略实施,可以用来在多个进程(本地或分布式)中产生可重复的伪随机数。</target>
        </trans-unit>
        <trans-unit id="9dfb3a62923157363de4f21bfcb4cc89da91a3e2" translate="yes" xml:space="preserve">
          <source>There are three use-cases related to memory alignment in numpy (as of 1.14):</source>
          <target state="translated">在numpy中,有三个与内存对齐有关的用例(从1.14开始)。</target>
        </trans-unit>
        <trans-unit id="1878e6ac9e299677e2b59b09c76f88c728c9412d" translate="yes" xml:space="preserve">
          <source>There are times when it is important to visit the elements of an array in a specific order, irrespective of the layout of the elements in memory. The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object provides an &lt;code&gt;order&lt;/code&gt; parameter to control this aspect of iteration. The default, having the behavior described above, is order=&amp;rsquo;K&amp;rsquo; to keep the existing order. This can be overridden with order=&amp;rsquo;C&amp;rsquo; for C order and order=&amp;rsquo;F&amp;rsquo; for Fortran order.</source>
          <target state="translated">在某些时候，重要的是要以特定顺序访问数组的元素，而不管元素在内存中的布局如何。所述&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;对象提供一个 &lt;code&gt;order&lt;/code&gt; 参数来控制迭代的这一方面。具有上述行为的默认值是order ='K'，以保留现有订单。对于C订单，可以使用order ='C'覆盖；对于Fortran订单，可以使用order ='F'覆盖。</target>
        </trans-unit>
        <trans-unit id="8bcb408782f4cab8808f9329f353388438a050d8" translate="yes" xml:space="preserve">
          <source>There are times when it is necessary to treat an array as a different data type than it is stored as. For instance, one may want to do all computations on 64-bit floats, even if the arrays being manipulated are 32-bit floats. Except when writing low-level C code, it&amp;rsquo;s generally better to let the iterator handle the copying or buffering instead of casting the data type yourself in the inner loop.</source>
          <target state="translated">有时，有必要将数组视为不同于存储类型的数据类型。例如，即使要处理的数组是32位浮点数，也可能要对64位浮点数进行所有计算。除了编写低级C代码时，通常最好让迭代器处理复制或缓冲，而不要自己在内部循环中强制转换数据类型。</target>
        </trans-unit>
        <trans-unit id="49296589bf54025f71f98956452ad22438eb00b7" translate="yes" xml:space="preserve">
          <source>There are times when you might want to carry out an operation between an array and a single number (also called &lt;em&gt;an operation between a vector and a scalar&lt;/em&gt;) or between arrays of two different sizes. For example, your array (we&amp;rsquo;ll call it &amp;ldquo;data&amp;rdquo;) might contain information about distance in miles but you want to convert the information to kilometers. You can perform this operation with:</source>
          <target state="translated">有时您可能想在数组和单个数字&lt;em&gt;之间进行运算&lt;/em&gt;（也称为&lt;em&gt;向量和标量之间的运算&lt;/em&gt;），或者在两个大小不同的数组&lt;em&gt;之间进行运算&lt;/em&gt;。例如，您的数组（我们称其为&amp;ldquo;数据&amp;rdquo;）可能包含有关距离的信息（以英里为单位），但您希望将其转换为公里。您可以通过以下方式执行此操作：</target>
        </trans-unit>
        <trans-unit id="52cac18f5846d7a58eabeae3e5d687453dc981d9" translate="yes" xml:space="preserve">
          <source>There are two Timedelta units (&amp;lsquo;Y&amp;rsquo;, years and &amp;lsquo;M&amp;rsquo;, months) which are treated specially, because how much time they represent changes depending on when they are used. While a timedelta day unit is equivalent to 24 hours, there is no way to convert a month unit into days, because different months have different numbers of days.</source>
          <target state="translated">有两个Timedelta单位（&amp;ldquo; Y&amp;rdquo;，年和&amp;ldquo; M&amp;rdquo;，月）被特别处理，因为它们表示多少时间取决于使用时间。尽管timedelta天单位等于24小时，但无法将一个月单位转换为天，因为不同的月份有不同的天数。</target>
        </trans-unit>
        <trans-unit id="47ec50226de8d5ba6a84cfb19309924a297ce7ae" translate="yes" xml:space="preserve">
          <source>There are two aspects to the machinery that ndarray uses to support views and new-from-template in subclasses.</source>
          <target state="translated">ndarray用来支持子类中的视图和new-from-template的机制有两个方面。</target>
        </trans-unit>
        <trans-unit id="ced97d88ae2c849acfa28a2cee713cefa36672d2" translate="yes" xml:space="preserve">
          <source>There are two major new types: the ndarray ( &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; ) and the ufunc ( &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt;&lt;code&gt;PyUFunc_Type&lt;/code&gt;&lt;/a&gt; ). Additional types play a supportive role: the &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt;&lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; . The &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt; is the type for a flat iterator for an ndarray (the object that is returned when getting the flat attribute). The &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt;&lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt;&lt;/a&gt; is the type of the object returned when calling &lt;code&gt;broadcast&lt;/code&gt; (). It handles iteration and broadcasting over a collection of nested sequences. Also, the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the data-type-descriptor type whose instances describe the data. Finally, there are 21 new scalar-array types which are new Python scalars corresponding to each of the fundamental data types available for arrays. An additional 10 other types are place holders that allow the array scalars to fit into a hierarchy of actual Python types.</source>
          <target state="translated">有两种主要的新类型：ndarray（&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;）和&lt;a href=&quot;#c.PyUFunc_Type&quot;&gt; &lt;code&gt;PyUFunc_Type&lt;/code&gt; &lt;/a&gt;（PyUFunc_Type）。其他类型起支持作用：&lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt; &lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt;。该&lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; &lt;/a&gt;是用于为ndarray（获取属性平坦时返回的对象）的平坦迭代器类型。所述&lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt; &lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt; &lt;/a&gt;是调用当对象的类型返回 &lt;code&gt;broadcast&lt;/code&gt; （）。它处理嵌套序列的集合上的迭代和广播。另外，&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt;是其实例描述数据的数据类型描述符类型。最后，有21种新的标量数组类型，它们是与数组可用的每种基本数据类型相对应的Python新标量。其他10种类型是占位符，它们允许数组标量适合实际的Python类型的层次结构。</target>
        </trans-unit>
        <trans-unit id="c37fba99ab33d4532607fe9319066dc8a4405878" translate="yes" xml:space="preserve">
          <source>There are two mechanisms which allow this to be done, temporary copies and buffering mode. With temporary copies, a copy of the entire array is made with the new data type, then iteration is done in the copy. Write access is permitted through a mode which updates the original array after all the iteration is complete. The major drawback of temporary copies is that the temporary copy may consume a large amount of memory, particularly if the iteration data type has a larger itemsize than the original one.</source>
          <target state="translated">有两种机制可以做到这一点,临时拷贝和缓冲模式。对于临时拷贝,用新的数据类型对整个数组进行拷贝,然后在拷贝中进行迭代。通过模式允许写访问,在所有迭代完成后更新原始数组。临时拷贝的主要缺点是,临时拷贝可能会消耗大量的内存,特别是当迭代数据类型的项目size比原来的大时。</target>
        </trans-unit>
        <trans-unit id="bbd0e93d84494368770e6b417effb4b358f4babd" translate="yes" xml:space="preserve">
          <source>There are two modes of creating an array using &lt;code&gt;__new__&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;__new__&lt;/code&gt; 创建数组的方式有两种：</target>
        </trans-unit>
        <trans-unit id="e95a2d13ee09be4667ba99a7e23d783a62c61eb8" translate="yes" xml:space="preserve">
          <source>There are two popular ways to flatten an array: &lt;code&gt;.flatten()&lt;/code&gt; and &lt;code&gt;.ravel()&lt;/code&gt;. The primary difference between the two is that the new array created using &lt;code&gt;ravel()&lt;/code&gt; is actually a reference to the parent array (i.e., a &amp;ldquo;view&amp;rdquo;). This means that any changes to the new array will affect the parent array as well. Since &lt;code&gt;ravel&lt;/code&gt; does not create a copy, it&amp;rsquo;s memory efficient.</source>
          <target state="translated">扁平化数组有两种流行的方法： &lt;code&gt;.flatten()&lt;/code&gt; 和 &lt;code&gt;.ravel()&lt;/code&gt; 。两者之间的主要区别在于，使用 &lt;code&gt;ravel()&lt;/code&gt; 创建的新数组实际上是对父数组的引用（即&amp;ldquo;视图&amp;rdquo;）。这意味着对新数组的任何更改也会影响父数组。由于 &lt;code&gt;ravel&lt;/code&gt; 不会创建副本，因此可以提高内存效率。</target>
        </trans-unit>
        <trans-unit id="97769fec67515ece6f805db56bd64883845242d0" translate="yes" xml:space="preserve">
          <source>There are two types of proper-contiguous NumPy arrays:</source>
          <target state="translated">有两种类型的适当连续的NumPy数组。</target>
        </trans-unit>
        <trans-unit id="0373fb682b5018f30be6571b2e08840bdbbdebff" translate="yes" xml:space="preserve">
          <source>There are two ways to capture floating-point error messages. The first is to set the error-handler to &amp;lsquo;call&amp;rsquo;, using &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;. Then, set the function to call using this function.</source>
          <target state="translated">有两种捕获浮点错误消息的方法。首先是使用&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;将错误处理程序设置为&amp;ldquo; call&amp;rdquo; 。然后，将该函数设置为使用此函数进行调用。</target>
        </trans-unit>
        <trans-unit id="7822fba8682a2c5b4fec5101c082332701ec52bb" translate="yes" xml:space="preserve">
          <source>There are two ways to effectively define a new array scalar type (apart from composing structured types &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtypes&lt;/a&gt; from the built-in scalar types): One way is to simply subclass the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and overwrite the methods of interest. This will work to a degree, but internally certain behaviors are fixed by the data type of the array. To fully customize the data type of an array you need to define a new data-type, and register it with NumPy. Such new types can only be defined in C, using the &lt;a href=&quot;c-api#c-api&quot;&gt;NumPy C-API&lt;/a&gt;.</source>
          <target state="translated">有效定义新数组标量类型的方法有两种（除了从内置标量类型构成结构化类型&lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtype&lt;/a&gt;之外）：一种方法是简单地对&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;进行子类化并覆盖感兴趣的方法。这将在一定程度上起作用，但是在内部，某些行为由数组的数据类型固定。要完全自定义数组的数据类型，您需要定义一个新的数据类型，并将其注册到NumPy。此类新类型只能使用&lt;a href=&quot;c-api#c-api&quot;&gt;NumPy C-API&lt;/a&gt;在C中定义。</target>
        </trans-unit>
        <trans-unit id="5c78474a57486cf4a85d9232cd27ee1937bd696d" translate="yes" xml:space="preserve">
          <source>There are two ways to effectively define a new array scalar type (apart from composing structured types &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtypes&lt;/a&gt; from the built-in scalar types): One way is to simply subclass the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and overwrite the methods of interest. This will work to a degree, but internally certain behaviors are fixed by the data type of the array. To fully customize the data type of an array you need to define a new data-type, and register it with NumPy. Such new types can only be defined in C, using the &lt;a href=&quot;c-api/index#c-api&quot;&gt;NumPy C-API&lt;/a&gt;.</source>
          <target state="translated">有效定义新数组标量类型的方法有两种（除了从内置标量类型组成结构化类型&lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtype&lt;/a&gt;的方法之外）：一种方法是简单地对&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;进行子类化并覆盖感兴趣的方法。这将在一定程度上起作用，但是在内部，某些行为由数组的数据类型固定。要完全自定义数组的数据类型，您需要定义一个新的数据类型，并将其注册到NumPy。此类新类型只能使用&lt;a href=&quot;c-api/index#c-api&quot;&gt;NumPy C-API&lt;/a&gt;在C中定义。</target>
        </trans-unit>
        <trans-unit id="cedb91ab21e9adb6003c75e29f535939f4382660" translate="yes" xml:space="preserve">
          <source>There are two ways to update the source release on PyPI, the first one is:</source>
          <target state="translated">在PyPI上更新源码版本有两种方法,第一种是。</target>
        </trans-unit>
        <trans-unit id="07256ff1dd075c50fc2daea66eb388157aacb269" translate="yes" xml:space="preserve">
          <source>There are two ways to use the interface: A Python side and a C-side. Both are separate attributes.</source>
          <target state="translated">界面的使用有两种方式。一个是Python端,一个是C端。两者都是独立的属性。</target>
        </trans-unit>
        <trans-unit id="b03a9c50082003b4ef01f90e63c960011178dda8" translate="yes" xml:space="preserve">
          <source>There has been no consistent prefix for NumPy public functions, but they all begin with a prefix of some sort, followed by an underscore, and are in camel case: &lt;code&gt;PyArray_DescrAlignConverter&lt;/code&gt;, &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;. In the future the names should be of the form &lt;code&gt;Npy*_PublicFunction&lt;/code&gt;, where the star is something appropriate.</source>
          <target state="translated">NumPy公共函数没有一致的前缀，但是它们都以某种前缀开头，后跟一个下划线，并且在驼峰情况下： &lt;code&gt;PyArray_DescrAlignConverter&lt;/code&gt; ， &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt; 。将来，名称应采用 &lt;code&gt;Npy*_PublicFunction&lt;/code&gt; 的形式，其中合适的名称应为星号。</target>
        </trans-unit>
        <trans-unit id="dde43af7d13c44f94f0d79c46e9390e7c8216335" translate="yes" xml:space="preserve">
          <source>There is a Python type for each of the different built-in data types that can be present in the array Most of these are simple wrappers around the corresponding data type in C. The C-names for these types are &lt;code&gt;Py{TYPE}ArrType_Type&lt;/code&gt; where &lt;code&gt;{TYPE}&lt;/code&gt; can be</source>
          <target state="translated">数组中可以存在每种不同的内置数据类型的Python类型，其中大多数都是C中对应数据类型的简单包装。这些类型的C名称为 &lt;code&gt;Py{TYPE}ArrType_Type&lt;/code&gt; 其中 &lt;code&gt;{TYPE}&lt;/code&gt; 可以是</target>
        </trans-unit>
        <trans-unit id="07c5411b83a37216eb927b90741cd5630b9b2108" translate="yes" xml:space="preserve">
          <source>There is a clear distinction between element-wise operations and linear algebra operations.</source>
          <target state="translated">元的运算和线性代数运算有明显的区别。</target>
        </trans-unit>
        <trans-unit id="c0d05d2bbb1d4347eb1dace6314a1a3b989e2daa" translate="yes" xml:space="preserve">
          <source>There is a fragment for converting a Python integer to a C &lt;code&gt;long&lt;/code&gt;. There is a different fragment that converts a Python integer to a C &lt;code&gt;int&lt;/code&gt;, that calls the routine defined in the &lt;code&gt;long&lt;/code&gt; fragment. We can make the changes we want here by changing the definition for the &lt;code&gt;long&lt;/code&gt; fragment. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; determines the active definition for a fragment using a &amp;ldquo;first come, first served&amp;rdquo; system. That is, we need to define the fragment for &lt;code&gt;long&lt;/code&gt; conversions prior to &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; doing it internally. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; allows us to do this by putting our fragment definitions in the file &lt;code&gt;pyfragments.swg&lt;/code&gt;. If we were to put the new fragment definitions in &lt;code&gt;numpy.i&lt;/code&gt;, they would be ignored.</source>
          <target state="translated">有一个将Python整数转换为C &lt;code&gt;long&lt;/code&gt; 的片段。有一个不同的片段将Python整数转换为C &lt;code&gt;int&lt;/code&gt; ，它调用了 &lt;code&gt;long&lt;/code&gt; 片段中定义的例程。我们可以通过更改 &lt;code&gt;long&lt;/code&gt; 片段的定义来进行所需的更改。&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;使用&amp;ldquo;先到先得&amp;rdquo;系统确定片段的有效定义。也就是说，我们需要先定义片段以进行 &lt;code&gt;long&lt;/code&gt; 转换，然后再在&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;内部进行操作。&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;允许我们通过将片段定义放在 &lt;code&gt;pyfragments.swg&lt;/code&gt; 文件中来执行此操作。如果我们将新的片段定义放在 &lt;code&gt;numpy.i&lt;/code&gt; ，它们将被忽略。</target>
        </trans-unit>
        <trans-unit id="d31593a379a881f2302877c7bf40c8ae65305ffb" translate="yes" xml:space="preserve">
          <source>There is a general need for looping over not only functions on scalars but also over functions on vectors (or arrays). This concept is realized in NumPy by generalizing the universal functions (ufuncs). In regular ufuncs, the elementary function is limited to element-by-element operations, whereas the generalized version (gufuncs) supports &amp;ldquo;sub-array&amp;rdquo; by &amp;ldquo;sub-array&amp;rdquo; operations. The Perl vector library PDL provides a similar functionality and its terms are re-used in the following.</source>
          <target state="translated">通常，不仅需要遍历标量上的函数，还需要遍历矢量（或数组）上的函数。NumPy通过泛化通用函数（ufuncs）来实现此概念。在常规ufunc中，基本功能仅限于逐个元素的操作，而通用版本（gufuncs）通过&amp;ldquo;子数组&amp;rdquo;操作支持&amp;ldquo;子数组&amp;rdquo;。Perl矢量库PDL提供了类似的功能，其术语在下面重新使用。</target>
        </trans-unit>
        <trans-unit id="16ce9fcfde9d0ef11eba9dffd6932b4fb7fe6e10" translate="yes" xml:space="preserve">
          <source>There is a list of enumerated types defined providing the basic 24 data types plus some useful generic names. Whenever the code requires a type number, one of these enumerated types is requested. The types are all called &lt;code&gt;NPY_{NAME}&lt;/code&gt;:</source>
          <target state="translated">定义了一系列枚举类型，提供了24种基本数据类型以及一些有用的通用名称。每当代码需要类型编号时，就会要求使用这些枚举类型之一。这些类型都称为 &lt;code&gt;NPY_{NAME}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fd095b1a939a3168566a681ecc0b30a59e81e682" translate="yes" xml:space="preserve">
          <source>There is a small difference between &lt;a href=&quot;#numpy.ma.masked_array.mini&quot;&gt;&lt;code&gt;mini&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.ma.min#numpy.ma.min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.masked_array.mini&quot;&gt; &lt;code&gt;mini&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.ma.min#numpy.ma.min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt;之间有一个小的差异：</target>
        </trans-unit>
        <trans-unit id="426d6a71d6ada6c4fe36711b0bf2acc4eb8a1d92" translate="yes" xml:space="preserve">
          <source>There is a subarray but it has exactly one element. This case can be handled as if there is no subarray, but needs some care during setup.</source>
          <target state="translated">有一个子数组,但它只有一个元素。这种情况可以像没有子数组一样处理,但在设置时需要注意。</target>
        </trans-unit>
        <trans-unit id="a1e2cb9284c447866f4fcfbd5e36a19034ca7940" translate="yes" xml:space="preserve">
          <source>There is also a &amp;ldquo;flat&amp;rdquo; in-place array for situations in which you would like to modify or process each element, regardless of the number of dimensions. One example is a &amp;ldquo;quantization&amp;rdquo; function that quantizes each element of an array in-place, be it 1D, 2D or whatever. This form checks for continuity but allows either C or Fortran ordering.</source>
          <target state="translated">还有一个&amp;ldquo;平面&amp;rdquo;原位数组，用于您要修改或处理每个元素的情况，而与维数无关。一个示例是&amp;ldquo;量化&amp;rdquo;功能，该功能可以就地量化数组的每个元素，无论是1D，2D或其他任何元素。此表单检查连续性，但允许使用C或Fortran排序。</target>
        </trans-unit>
        <trans-unit id="42d7ce17e767848814f251a3d945724bdcad4394" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;introductory guide to array iteration&lt;/a&gt; which may be of interest for those using this C API. In many instances, testing out ideas by creating the iterator in Python is a good idea before writing the C iteration code.</source>
          <target state="translated">有一个&lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;数组迭代&lt;/a&gt;的入门指南，对于使用此C API的用户可能会感兴趣。在许多情况下，在编写C迭代代码之前，通过在Python中创建迭代器来测试想法是一个好主意。</target>
        </trans-unit>
        <trans-unit id="89b73fe8185f285d3a10cd617f08eb8cadb40473" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;arrays.nditer#arrays-nditer&quot;&gt;introductory guide to array iteration&lt;/a&gt; which may be of interest for those using this C API. In many instances, testing out ideas by creating the iterator in Python is a good idea before writing the C iteration code.</source>
          <target state="translated">有一个&lt;a href=&quot;arrays.nditer#arrays-nditer&quot;&gt;数组迭代&lt;/a&gt;的入门指南，对于使用此C API的用户可能会感兴趣。在许多情况下，在编写C迭代代码之前，通过在Python中创建迭代器来测试想法是一个好主意。</target>
        </trans-unit>
        <trans-unit id="606a479ef2292dc711e91c789c67dff3002d3e8e" translate="yes" xml:space="preserve">
          <source>There is an ongoing effort to improve the API. It is important in this effort to ensure that code that compiles for NumPy 1.X continues to compile for NumPy 1.X. At the same time, certain API&amp;rsquo;s will be marked as deprecated so that future-looking code can avoid these API&amp;rsquo;s and follow better practices.</source>
          <target state="translated">正在进行改进API的工作。在此过程中，重要的是要确保为NumPy 1.X编译的代码继续为NumPy 1.X编译。同时，某些API将被标记为已弃用，以便将来使用的代码可以避免使用这些API并遵循更好的做法。</target>
        </trans-unit>
        <trans-unit id="2d9dbfa834497f6482a194ae6bc42d9b31e1c027" translate="yes" xml:space="preserve">
          <source>There is exactly one function that must be defined in your C-code in order for Python to use it as an extension module. The function must be called init{name} where {name} is the name of the module from Python. This function must be declared so that it is visible to code outside of the routine. Besides adding the methods and constants you desire, this subroutine must also contain calls like &lt;code&gt;import_array()&lt;/code&gt; and/or &lt;code&gt;import_ufunc()&lt;/code&gt; depending on which C-API is needed. Forgetting to place these commands will show itself as an ugly segmentation fault (crash) as soon as any C-API subroutine is actually called. It is actually possible to have multiple init{name} functions in a single file in which case multiple modules will be defined by that file. However, there are some tricks to get that to work correctly and it is not covered here.</source>
          <target state="translated">必须在C代码中定义一个函数，Python才能将其用作扩展模块。该函数必须称为init {name}，其中{name}是Python中模块的名称。必须声明此函数，以便在例程外的代码中可见。除了添加所需的方法和常量外，此子例程还必须包含 &lt;code&gt;import_array()&lt;/code&gt; 和/或 &lt;code&gt;import_ufunc()&lt;/code&gt; 之类的调用取决于所需的C-API。一旦实际调用任何C-API子例程，忘记放置这些命令将显示为丑陋的分段错误（崩溃）。实际上，在一个文件中可能有多个init {name}函数，在这种情况下，该文件将定义多个模块。但是，有一些技巧可以使它正常工作，这里不介绍。</target>
        </trans-unit>
        <trans-unit id="c951415e0655e2f1d542beb400e29df172840589" translate="yes" xml:space="preserve">
          <source>There is more than one definition of sign in common use for complex numbers. The definition used here is equivalent to</source>
          <target state="translated">对于复数,常用的符号定义不止一个。这里使用的定义相当于</target>
        </trans-unit>
        <trans-unit id="81f07ae1e9b8a43b5991326dbec6dd373febf78b" translate="yes" xml:space="preserve">
          <source>There is no need to use &lt;code&gt;intent(c)&lt;/code&gt; for one-dimensional arrays, no matter if the wrapped function is either a Fortran or a C function. This is because the concepts of Fortran- and C contiguity overlap in one-dimensional cases.</source>
          <target state="translated">无论包装函数是Fortran还是C函数，都无需对一维数组使用 &lt;code&gt;intent(c)&lt;/code&gt; 。这是因为Fortran和C连续性的概念在一维情况下重叠。</target>
        </trans-unit>
        <trans-unit id="b1c5400df70c93e783da6a5dac7fee87f2f1e727" translate="yes" xml:space="preserve">
          <source>There is no standard way in Python distutils to create a standard shared library (an extension module is a &amp;ldquo;special&amp;rdquo; shared library Python understands) in a cross-platform manner. Thus, a big disadvantage of ctypes at the time of writing this book is that it is difficult to distribute in a cross-platform manner a Python extension that uses ctypes and includes your own code which should be compiled as a shared library on the users system.</source>
          <target state="translated">Python distutils中没有标准方法以跨平台方式创建标准共享库（扩展模块是Python理解的&amp;ldquo;特殊&amp;rdquo;共享库）。因此，在撰写本书时，ctypes的一个很大的缺点是，很难以跨平台的方式分发使用ctypes并包含您自己的代码的Python扩展，该扩展应编译为用户系统上的共享库。 。</target>
        </trans-unit>
        <trans-unit id="54b0268bf735345a9f64350e8e77b1a81c8688d9" translate="yes" xml:space="preserve">
          <source>There is one indexing array and it, as well as the assignment array, can be iterated trivially. For example they may be contiguous. Also the indexing array must be of &lt;a href=&quot;arrays.scalars#numpy.intp&quot;&gt;&lt;code&gt;intp&lt;/code&gt;&lt;/a&gt; type and the value array in assignments should be of the correct type. This is purely a fast path.</source>
          <target state="translated">有一个索引数组，它以及赋值数组都可以被简单地迭代。例如，它们可以是连续的。另外，索引数组必须为&lt;a href=&quot;arrays.scalars#numpy.intp&quot;&gt; &lt;code&gt;intp&lt;/code&gt; &lt;/a&gt;类型，赋值中的值数组应为正确的类型。这纯粹是一条捷径。</target>
        </trans-unit>
        <trans-unit id="23297908101e96f4ab7052c44ca172ce18526477" translate="yes" xml:space="preserve">
          <source>There is one indexing array and it, as well as the assignment array, can be iterated trivially. For example they may be contiguous. Also the indexing array must be of &lt;code&gt;intp&lt;/code&gt; type and the value array in assignments should be of the correct type. This is purely a fast path.</source>
          <target state="translated">有一个索引数组，它以及赋值数组都可以被简单地迭代。例如，它们可以是连续的。另外，索引数组必须为 &lt;code&gt;intp&lt;/code&gt; 类型，赋值中的值数组应为正确的类型。这纯粹是一条捷径。</target>
        </trans-unit>
        <trans-unit id="d8fac7ab155f3d88da854276783ffad458c19c82" translate="yes" xml:space="preserve">
          <source>There is one notable exception to this behavior: if the optional argument &lt;code&gt;names=True&lt;/code&gt;, the first commented line will be examined for names.</source>
          <target state="translated">此行为有一个明显的例外：如果可选参数 &lt;code&gt;names=True&lt;/code&gt; ，则将检查第一条注释行的名称。</target>
        </trans-unit>
        <trans-unit id="df9a641fbd94988d395fb4542afcc38f2bd13355" translate="yes" xml:space="preserve">
          <source>There must be at least 1 argument, and define the last argument as &lt;em&gt;item&lt;/em&gt;. Then, &lt;code&gt;a.itemset(*args)&lt;/code&gt; is equivalent to but faster than &lt;code&gt;a[args] = item&lt;/code&gt;. The item should be a scalar value and &lt;code&gt;args&lt;/code&gt; must select a single item in the array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">必须至少有一个参数，并将最后一个参数定义为&lt;em&gt;item&lt;/em&gt;。然后， &lt;code&gt;a.itemset(*args)&lt;/code&gt; 等同于但比 &lt;code&gt;a[args] = item&lt;/code&gt; 更快。该项目应为标量值，并且 &lt;code&gt;args&lt;/code&gt; 必须在数组 &lt;code&gt;a&lt;/code&gt; 中选择一个项目。</target>
        </trans-unit>
        <trans-unit id="d9bdbeac0f4a4a2c09a4382d5b665ee480b88e7d" translate="yes" xml:space="preserve">
          <source>There was no &lt;code&gt;__array_interface__&lt;/code&gt; attribute instead all of the keys (except for version) in the &lt;code&gt;__array_interface__&lt;/code&gt; dictionary were their own attribute: Thus to obtain the Python-side information you had to access separately the attributes:</source>
          <target state="translated">没有 &lt;code&gt;__array_interface__&lt;/code&gt; 属性，而是 &lt;code&gt;__array_interface__&lt;/code&gt; 词典中的所有键（版本除外）都是它们自己的属性：因此，要获取Python端信息，您必须分别访问以下属性：</target>
        </trans-unit>
        <trans-unit id="bc33808ec0ca031cf8b9c1fdd7c9278c78f0db38" translate="yes" xml:space="preserve">
          <source>There was no __array_interface__ attribute instead all of the keys (except for version) in the __array_interface__ dictionary were their own attribute: Thus to obtain the Python-side information you had to access separately the attributes:</source>
          <target state="translated">没有__array_interface__属性,相反,__array_interface__字典中的所有键(除了版本)都是它们自己的属性。因此,为了获得Python方面的信息,你必须分别访问这些属性。</target>
        </trans-unit>
        <trans-unit id="1d3ca63c0d0c4fb92d45d132b89354f4e2a0e2fc" translate="yes" xml:space="preserve">
          <source>There will not be anything &lt;em&gt;wrong&lt;/em&gt; with the results, per se; even a seed of 0 is perfectly fine thanks to the processing that &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; does. If you just need &lt;em&gt;some&lt;/em&gt; fixed value for unit tests or debugging, feel free to use whatever seed you like. But if you want to make inferences from the results or publish them, drawing from a larger set of seeds is good practice.</source>
          <target state="translated">结果本身不会有任何&lt;em&gt;问题&lt;/em&gt;。由于&lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;的处理，即使是0的种子也非常好。如果您只需要&lt;em&gt;一些&lt;/em&gt;固定值用于单元测试或调试，请随时使用所需的任何种子。但是，如果您想根据结果进行推断或将其发布，则从大量种子中提取是一种很好的做法。</target>
        </trans-unit>
        <trans-unit id="1a33a5d0a80b8b553aad5ef6b8b9d3cf3a744293" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s an embarrassing typo in a commit you made? Or perhaps the you made several false starts you would like the posterity not to see.</source>
          <target state="translated">您所做的提交中有一个令人尴尬的错字？或者，也许您犯了几次错误的开始，您希望后代看不到。</target>
        </trans-unit>
        <trans-unit id="7586899d52e7cb2e4afcaa41a1d9614a067b4661" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s an embarrassing typo in a commit you made? Or perhaps you made several false starts you would like the posterity not to see.</source>
          <target state="translated">您所做的提交中有一个令人尴尬的错字？或者，也许您犯了几次错误的开始，您希望后代不见。</target>
        </trans-unit>
        <trans-unit id="de5a5e9111615649ff06d77b214a9aa4744c2e9e" translate="yes" xml:space="preserve">
          <source>These Boolean-valued flags affect how numpy interprets the memory area used by &lt;code&gt;a&lt;/code&gt; (see Notes below). The ALIGNED flag can only be set to True if the data is actually aligned according to the type. The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set to True. The flag WRITEABLE can only be set to True if the array owns its own memory, or the ultimate owner of the memory exposes a writeable buffer interface, or is a string. (The exception for string is made so that unpickling can be done without copying memory.)</source>
          <target state="translated">这些布尔值标志影响numpy解释 &lt;code&gt;a&lt;/code&gt; 使用的内存区域的方式（请参见下面的注释）。如果数据实际上根据类型对齐，则ALIGNED标志只能设置为True。 WRITEBACKIFCOPY和（不建议使用）UPDATEIFCOPY标志永远不能设置为True。如果数组拥有自己的内存，或者内存的最终所有者公开了可写的缓冲区接口，或者为字符串，则只能将标志WRITEABLE设置为True。 （对string进行了例外处理，因此可以在不复制内存的情况下进行解腌。）</target>
        </trans-unit>
        <trans-unit id="a6788920c31464c6803c23f30203598688f71c50" translate="yes" xml:space="preserve">
          <source>These additional dependencies for building the documentation are listed in &lt;code&gt;doc_requirements.txt&lt;/code&gt; and can be conveniently installed with:</source>
          <target state="translated">&lt;code&gt;doc_requirements.txt&lt;/code&gt; 中列出了用于构建文档的这些其他依赖项，可以通过以下方式方便地安装：</target>
        </trans-unit>
        <trans-unit id="7faf38a4c03dd7b8b5f6a940a17e52f4253526ca" translate="yes" xml:space="preserve">
          <source>These all achieve the same result:</source>
          <target state="translated">这些都能达到同样的效果。</target>
        </trans-unit>
        <trans-unit id="ca33633bc8f8738d475e05fabdb7eda73e305c81" translate="yes" xml:space="preserve">
          <source>These are defined for &lt;code&gt;{bits}&lt;/code&gt; = 8, 16, 32, 64, 128, and 256 and provide the maximum (minimum) value of the corresponding (unsigned) integer type. Note: the actual integer type may not be available on all platforms (i.e. 128-bit and 256-bit integers are rare).</source>
          <target state="translated">它们是针对 &lt;code&gt;{bits}&lt;/code&gt; = 8、16、32、64、128和256定义的，并提供了相应（无符号）整数类型的最大值（最小值）。注意：实际的整数类型可能并非在所有平台上都可用（即，很少使用128位和256位整数）。</target>
        </trans-unit>
        <trans-unit id="e68165dfdce046a2deae960fcc7bcd8c7c8919ea" translate="yes" xml:space="preserve">
          <source>These are enhanced arrays of either &lt;a href=&quot;arrays.scalars#numpy.str_&quot;&gt;&lt;code&gt;str_&lt;/code&gt;&lt;/a&gt; type or &lt;a href=&quot;arrays.scalars#numpy.bytes_&quot;&gt;&lt;code&gt;bytes_&lt;/code&gt;&lt;/a&gt; type. These arrays inherit from the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, but specially-define the operations &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt; on a (broadcasting) element-by-element basis. These operations are not available on the standard &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; of character type. In addition, the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; has all of the standard &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;) methods, executing them on an element-by-element basis. Perhaps the easiest way to create a chararray is to use &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;self.view(chararray)&lt;/code&gt;&lt;/a&gt; where &lt;em&gt;self&lt;/em&gt; is an ndarray of str or unicode data-type. However, a chararray can also be created using the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;numpy.chararray&lt;/code&gt;&lt;/a&gt; constructor, or via the &lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt;&lt;code&gt;numpy.char.array&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">这些是&lt;a href=&quot;arrays.scalars#numpy.str_&quot;&gt; &lt;code&gt;str_&lt;/code&gt; &lt;/a&gt;类型或&lt;a href=&quot;arrays.scalars#numpy.bytes_&quot;&gt; &lt;code&gt;bytes_&lt;/code&gt; &lt;/a&gt;类型的增强型数组。这些数组继承自&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，但在逐个元素的基础上特别定义了 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt; 操作。这些操作在字符类型的标准&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;上不可用。另外，&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;具有所有标准的&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;（和&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;）方法，它们在逐个元素的基础上执行。创建chararray的最简单方法可能是使用&lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;self.view(chararray)&lt;/code&gt; &lt;/a&gt;，其中&lt;em&gt;self&lt;/em&gt;是str或unicode数据类型的ndarray。但是，也可以使用&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;numpy.chararray&lt;/code&gt; &lt;/a&gt;构造函数或通过&lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt; &lt;code&gt;numpy.char.array&lt;/code&gt; &lt;/a&gt;函数来创建chararray：</target>
        </trans-unit>
        <trans-unit id="8ddb00a13475a7300c7d1510545ce91de444184f" translate="yes" xml:space="preserve">
          <source>These are enhanced arrays of either &lt;code&gt;string_&lt;/code&gt; type or &lt;code&gt;unicode_&lt;/code&gt; type. These arrays inherit from the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, but specially-define the operations &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt; on a (broadcasting) element-by-element basis. These operations are not available on the standard &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; of character type. In addition, the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; has all of the standard &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; (and &lt;code&gt;unicode&lt;/code&gt;) methods, executing them on an element-by-element basis. Perhaps the easiest way to create a chararray is to use &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;self.view(chararray)&lt;/code&gt;&lt;/a&gt; where &lt;em&gt;self&lt;/em&gt; is an ndarray of str or unicode data-type. However, a chararray can also be created using the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;numpy.chararray&lt;/code&gt;&lt;/a&gt; constructor, or via the &lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt;&lt;code&gt;numpy.char.array&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">这些是 &lt;code&gt;string_&lt;/code&gt; 类型或 &lt;code&gt;unicode_&lt;/code&gt; 类型的增强数组。这些数组继承自&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，但是在逐个元素的基础上特别定义了 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt; 操作。这些操作在字符类型的标准&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;上不可用。另外，&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;具有所有标准&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt;（和 &lt;code&gt;unicode&lt;/code&gt; ）方法，它们在逐个元素的基础上执行。创建chararray的最简单方法可能是使用&lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;self.view(chararray)&lt;/code&gt; &lt;/a&gt;，其中&lt;em&gt;self&lt;/em&gt;是str或unicode数据类型的ndarray。但是，也可以使用&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;numpy.chararray&lt;/code&gt; &lt;/a&gt;构造函数或通过&lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt; &lt;code&gt;numpy.char.array&lt;/code&gt; &lt;/a&gt;函数创建chararray：</target>
        </trans-unit>
        <trans-unit id="5c5d09f4ce60946e76740852fd56ca7c8c49e5bd" translate="yes" xml:space="preserve">
          <source>These are roughly ordered from least-to-most precision.</source>
          <target state="translated">这些大致是由最少到最精确的顺序。</target>
        </trans-unit>
        <trans-unit id="2ce5765c6141294e2d5121321badaf2a8b57c10d" translate="yes" xml:space="preserve">
          <source>These are some detailed notes, which are not of importance for day to day indexing (in no particular order):</source>
          <target state="translated">这些都是一些详细的注意事项,对于日常的索引并不重要(排名不分先后)。</target>
        </trans-unit>
        <trans-unit id="3f20305498e715f2e7a95c2c0aa48306a2b1d79a" translate="yes" xml:space="preserve">
          <source>These are the arrays for the operation.</source>
          <target state="translated">这些是操作的数组。</target>
        </trans-unit>
        <trans-unit id="7a1ac004102d237171aefc6abd621531cd490cc4" translate="yes" xml:space="preserve">
          <source>These are the constants and functions for accessing the ufunc C-API from extension modules in precisely the same way as the array C-API can be accessed. The &lt;code&gt;import_ufunc&lt;/code&gt; () function must always be called (in the initialization subroutine of the extension module). If your extension module is in one file then that is all that is required. The other two constants are useful if your extension module makes use of multiple files. In that case, define &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to something unique to your code and then in source files that do not contain the module initialization function but still need access to the UFUNC API, define &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to the same name used previously and also define &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt;&lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这些是用于以与访问数组C-API完全相同的方式从扩展模块访问ufunc C-API的常量和函数。该 &lt;code&gt;import_ufunc&lt;/code&gt; （）函数必须始终（在扩展模块的初始化子程序）被调用。如果您的扩展模块在一个文件中，则仅需这些。如果扩展模块使用多个文件，则其他两个常量很有用。在这种情况下，定义&lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt;以独特的代码，然后在不包含模块初始化函数，但到UFUNC API仍需要访问，定义源文件的东西&lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt;同名以前用过，也定义&lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt; &lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0aaea1e5f2c4b6d0e0dc28a8aa40e102fa58beb" translate="yes" xml:space="preserve">
          <source>These are the indices that would allow you to access the upper triangular part of any 3x3 array:</source>
          <target state="translated">这些是允许你访问任何3x3数组的上三角部分的索引。</target>
        </trans-unit>
        <trans-unit id="38bc2b8e25d17f4fb4231aea381549f2e431c561" translate="yes" xml:space="preserve">
          <source>These are the instructions if you just want to follow the latest &lt;em&gt;NumPy&lt;/em&gt; source, but you don&amp;rsquo;t need to do any development for now. If you do want to contribute a patch (excellent!) or do more extensive NumPy development, see &lt;a href=&quot;../development_workflow#development-workflow&quot;&gt;Development workflow&lt;/a&gt;.</source>
          <target state="translated">如果您只是想遵循最新的&lt;em&gt;NumPy&lt;/em&gt;来源，那么这些就是说明，但是您现在不需要进行任何开发。如果您确实想贡献一个补丁（出色！）或进行更广泛的NumPy开发，请参阅&lt;a href=&quot;../development_workflow#development-workflow&quot;&gt;开发工作流程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="43efdc6f451764645e6025c80a5a83f304f68569" translate="yes" xml:space="preserve">
          <source>These are typically used in situations where in C/C++, you would allocate a(n) array(s) on the heap, and call the function to fill the array(s) values. In Python, the arrays are allocated for you and returned as new array objects.</source>
          <target state="translated">这些函数通常用于在 C/C++中,在堆上分配一个(n)数组,然后调用函数来填充数组的值。在 Python 中,数组是为你分配的,并作为新的数组对象返回。</target>
        </trans-unit>
        <trans-unit id="f04a7bcc6ce293328ac2b1079d0f95ad7b19da67" translate="yes" xml:space="preserve">
          <source>These are written in doctest format, and should illustrate how to use the function.</source>
          <target state="translated">这些都是以doctest格式写的,应该说明如何使用函数。</target>
        </trans-unit>
        <trans-unit id="a93c5dc49de55891886f179425b788a1c6ad1b35" translate="yes" xml:space="preserve">
          <source>These arrays are views on the original arrays. They are typically not contiguous. Furthermore, more than one element of a broadcasted array may refer to a single memory location. If you need to write to the arrays, make copies first. While you can set the &lt;code&gt;writable&lt;/code&gt; flag True, writing to a single output value may end up changing more than one location in the output array.</source>
          <target state="translated">这些阵列是原始阵列的视图。它们通常不连续。此外，广播阵列中的一个以上元素可以引用单个存储位置。如果需要写入阵列，请先进行复制。虽然可以将 &lt;code&gt;writable&lt;/code&gt; 标志设置为True，但是写入单个输出值可能最终会更改输出数组中的多个位置。</target>
        </trans-unit>
        <trans-unit id="95e5069d3636251c2ff01dcc947b04bbf8ba1923" translate="yes" xml:space="preserve">
          <source>These behaviors can be set for all kinds of errors or specific ones:</source>
          <target state="translated">这些行为可以针对所有类型的错误或特定的错误进行设置。</target>
        </trans-unit>
        <trans-unit id="7f0acac4ec85b4b4bd7ae1e0ff5a3f9603fcfbc3" translate="yes" xml:space="preserve">
          <source>These constants are used in &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; (and its macro forms) to specify desired properties of the new array.</source>
          <target state="translated">这些常量在&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;（及其宏格式）中用于指定新数组的所需属性。</target>
        </trans-unit>
        <trans-unit id="3d245bb5214c903868626d468b5ef8607e3f9a4a" translate="yes" xml:space="preserve">
          <source>These cover almost the whole array (two diagonals right of the main one):</source>
          <target state="translated">这些几乎覆盖了整个阵列(主阵列右边的两个对角线)。</target>
        </trans-unit>
        <trans-unit id="f7e900132de2199b00f5d74615e0a1848ce14490" translate="yes" xml:space="preserve">
          <source>These cover only a small part of the whole array (two diagonals right of the main one):</source>
          <target state="translated">这些只覆盖整个阵列的一小部分(主阵列右边的两个对角线)。</target>
        </trans-unit>
        <trans-unit id="1adc6f5a53325e3aa2e7cccdff9469027b73b4ce" translate="yes" xml:space="preserve">
          <source>These documents are intended as an introductory overview of NumPy and its features. For detailed reference documentation of the functions and classes contained in the package, see the &lt;a href=&quot;../reference/index#reference&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">这些文档旨在作为NumPy及其功能的介绍性概述。有关包中包含的功能和类的详细参考文档，请参阅&lt;a href=&quot;../reference/index#reference&quot;&gt;API参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca02dca00e56b01dd5323ec3c2c51c9bba04e9a2" translate="yes" xml:space="preserve">
          <source>These documents are intended as recipes to common tasks using NumPy. For detailed reference documentation of the functions and classes contained in the package, see the &lt;a href=&quot;../reference/index#reference&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">这些文档旨在用作使用NumPy的常见任务的配方。有关包中包含的功能和类的详细参考文档，请参阅&lt;a href=&quot;../reference/index#reference&quot;&gt;API参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad1b854bfa000aee75512c8df139be2e2841e0fd" translate="yes" xml:space="preserve">
          <source>These documents are intended to explain in detail the concepts and techniques used in NumPy. For the reference documentation of the functions and classes contained in the package, see the &lt;a href=&quot;../reference/index#reference&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">这些文档旨在详细解释NumPy中使用的概念和技术。有关包中包含的功能和类的参考文档，请参阅&lt;a href=&quot;../reference/index#reference&quot;&gt;API参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63868acfbf699fe963e728a55308e7d3a9b22eb9" translate="yes" xml:space="preserve">
          <source>These examples illustrate the low-level &lt;a href=&quot;#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; constructor. Refer to the &lt;code&gt;See Also&lt;/code&gt; section above for easier ways of constructing an ndarray.</source>
          <target state="translated">这些示例说明了低级&lt;a href=&quot;#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;构造函数。 &lt;code&gt;See Also&lt;/code&gt; 构造ndarray的更简便方法，请参阅上面的&amp;ldquo; 另请参见&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="8a348b17d2fb1b33a90b7baa8a557d9af808a018" translate="yes" xml:space="preserve">
          <source>These function all require integer arguments and they manipulate the bit-pattern of those arguments.</source>
          <target state="translated">这些函数都需要整数参数,并对这些参数的位型进行操作。</target>
        </trans-unit>
        <trans-unit id="d7e647d09c10f9f4521e851e5661f2624622c65e" translate="yes" xml:space="preserve">
          <source>These functions along with a minimal setup file are included in the examples folder.</source>
          <target state="translated">这些功能和一个最小的设置文件都包含在例子文件夹中。</target>
        </trans-unit>
        <trans-unit id="47c8ad5dd0ea816b255a3666826ae66a37ff3a15" translate="yes" xml:space="preserve">
          <source>These functions and macros provide easy access to elements of the ndarray from C. These work for all arrays. You may need to take care when accessing the data in the array, however, if it is not in machine byte-order, misaligned, or not writeable. In other words, be sure to respect the state of the flags unless you know what you are doing, or have previously guaranteed an array that is writeable, aligned, and in machine byte-order using &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt;. If you wish to handle all types of arrays, the copyswap function for each type is useful for handling misbehaved arrays. Some platforms (e.g. Solaris) do not like misaligned data and will crash if you de-reference a misaligned pointer. Other platforms (e.g. x86 Linux) will just work more slowly with misaligned data.</source>
          <target state="translated">这些函数和宏使您可以轻松地从C访问ndarray的元素。它们适用于所有数组。但是，如果访问数组中的数据不是机器字节顺序，未对齐或不可写，则可能需要小心。换句话说，除非您知道自己在做什么，否则请确保尊重标记的状态，或者使用&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;先前已保证可写，对齐且以机器字节顺序排列的数组。如果要处理所有类型的数组，则每种类型的copyswap函数对于处理行为异常的数组很有用。某些平台（例如Solaris）不喜欢未对齐的数据，如果取消引用未对齐的指针，则会崩溃。其他平台（例如x86 Linux）对未对齐的数据的处理只会更慢。</target>
        </trans-unit>
        <trans-unit id="a0b164307df93568d43c0a9ad269b4dbe393e0e6" translate="yes" xml:space="preserve">
          <source>These functions are included here because they are used at least once in the array object&amp;rsquo;s methods. The function returns -1 (without setting a Python Error) if one of the objects being assigned is not callable.</source>
          <target state="translated">之所以包含这些函数，是因为它们在数组对象的方法中至少使用了一次。如果分配的对象之一不可调用，则该函数返回-1（未设置Python错误）。</target>
        </trans-unit>
        <trans-unit id="8de7e7b6b1e1ede303832d725868059c022d2d0a" translate="yes" xml:space="preserve">
          <source>These functions are very similar to functions without keyword arguments. The only difference is that the function signature is:</source>
          <target state="translated">这些函数与没有关键字参数的函数非常相似。唯一不同的是,函数的签名是:</target>
        </trans-unit>
        <trans-unit id="474e0e7c22745c37837977d2aed3d481ae32dc24" translate="yes" xml:space="preserve">
          <source>These identities allow a Chebyshev series to be expressed as a finite, symmetric Laurent series. In this module, this sort of Laurent series is referred to as a &amp;ldquo;z-series.&amp;rdquo;</source>
          <target state="translated">这些身份允许将切比雪夫级数表示为有限的对称洛朗级数。在此模块中，此类Laurent系列称为&amp;ldquo; z系列&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="21ed26c6390b302396f6eeab85800f1a745f670f" translate="yes" xml:space="preserve">
          <source>These macros access the &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure members and are defined in &lt;code&gt;ndarraytypes.h&lt;/code&gt;. The input argument, &lt;em&gt;arr&lt;/em&gt;, can be any &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that is directly interpretable as a &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; (any instance of the &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and its sub-types).</source>
          <target state="translated">这些宏访问&lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;结构成员，并在 &lt;code&gt;ndarraytypes.h&lt;/code&gt; 中定义。输入参数，&lt;em&gt;ARR&lt;/em&gt;，可以是任何&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt;是作为一个直接可解释&lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt;（的任何实例&lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;及其子类型）。</target>
        </trans-unit>
        <trans-unit id="a58240a1702d16b3630637ee0890f803946e53fd" translate="yes" xml:space="preserve">
          <source>These macros access the &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure members and are defined in &lt;code&gt;ndarraytypes.h&lt;/code&gt;. The input argument, &lt;em&gt;arr&lt;/em&gt;, can be any &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that is directly interpretable as a &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; (any instance of the &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and itssub-types).</source>
          <target state="translated">这些宏访问&lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;结构成员，并在 &lt;code&gt;ndarraytypes.h&lt;/code&gt; 中定义。输入参数&lt;em&gt;arr&lt;/em&gt;可以是可直接解释为&lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; 的&lt;/a&gt;任何&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt;*（&lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;及其子类型的任何实例）。</target>
        </trans-unit>
        <trans-unit id="13b269cced89ab6392bc06c8030f96e4b737c057" translate="yes" xml:space="preserve">
          <source>These macros all access the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure members. The input argument, arr, can be any &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that is directly interpretable as a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; (any instance of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and its sub-types).</source>
          <target state="translated">这些宏都访问&lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;结构成员。输入参数，ARR，可以是任何&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt;是作为一个直接可解释&lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt;（的任何实例&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;及其子类型）。</target>
        </trans-unit>
        <trans-unit id="11ea008c03805b7a8b457a794a3fc2be74133b50" translate="yes" xml:space="preserve">
          <source>These macros are only meaningful if &lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt;&lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; evaluates True during compilation of the extension module. Otherwise, these macros are equivalent to whitespace. Python uses a single Global Interpreter Lock (GIL) for each Python process so that only a single thread may execute at a time (even on multi-cpu machines). When calling out to a compiled function that may take time to compute (and does not have side-effects for other threads like updated global variables), the GIL should be released so that other Python threads can run while the time-consuming calculations are performed. This can be accomplished using two groups of macros. Typically, if one macro in a group is used in a code block, all of them must be used in the same code block. Currently, &lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt;&lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; is defined to the python-defined &lt;a href=&quot;#c.WITH_THREADS&quot;&gt;&lt;code&gt;WITH_THREADS&lt;/code&gt;&lt;/a&gt; constant unless the environment variable &lt;code&gt;NPY_NOSMP&lt;/code&gt; is set in which case &lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt;&lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; is defined to be 0.</source>
          <target state="translated">仅当&lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt; &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt;在扩展模块的编译期间评估为True时，这些宏才有意义。否则，这些宏等效于空白。 Python为每个Python进程使用一个全局解释器锁（GIL），以便一次只能执行一个线程（即使在多cpu机器上）。当调用可能花费时间进行计算的已编译函数（并且不会对其他线程（如更新的全局变量）产生副作用）时，应释放GIL，以便其他Python线程可以在执行耗时的计算时运行。这可以使用两组宏来完成。通常，如果在代码块中使用了组中的一个宏，则所有宏都必须在同一代码块中使用。目前，&lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt; &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt;除非已设置环境变量 &lt;code&gt;NPY_NOSMP&lt;/code&gt; ，在这种情况下&lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt; &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt;定义为0，否则将定义为python定义的&lt;a href=&quot;#c.WITH_THREADS&quot;&gt; &lt;code&gt;WITH_THREADS&lt;/code&gt; &lt;/a&gt;常量。</target>
        </trans-unit>
        <trans-unit id="0b21dcbffd2b61b3d3ee30959d3bc33fc08a9c74" translate="yes" xml:space="preserve">
          <source>These macros are only meaningful if &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; evaluates True during compilation of the extension module. Otherwise, these macros are equivalent to whitespace. Python uses a single Global Interpreter Lock (GIL) for each Python process so that only a single thread may execute at a time (even on multi-cpu machines). When calling out to a compiled function that may take time to compute (and does not have side-effects for other threads like updated global variables), the GIL should be released so that other Python threads can run while the time-consuming calculations are performed. This can be accomplished using two groups of macros. Typically, if one macro in a group is used in a code block, all of them must be used in the same code block. Currently, &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined to the python-defined &lt;code&gt;WITH_THREADS&lt;/code&gt; constant unless the environment variable &lt;code&gt;NPY_NOSMP&lt;/code&gt; is set in which case &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined to be 0.</source>
          <target state="translated">仅当 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 在扩展模块的编译期间评估为True时，这些宏才有意义。否则，这些宏等效于空白。 Python为每个Python进程使用一个全局解释器锁（GIL），以便一次只能执行一个线程（即使在多cpu机器上）。当调用可能花费时间进行计算的已编译函数（并且对其他线程（如更新的全局变量）没有副作用）时，应释放GIL，以便其他Python线程可以在执行耗时的计算时运行。这可以使用两组宏来完成。通常，如果在代码块中使用了组中的一个宏，则所有宏都必须在同一代码块中使用。目前， &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 除非已设置环境变量 &lt;code&gt;NPY_NOSMP&lt;/code&gt; ，在这种情况下 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 定义为0，否则将定义为python定义的 &lt;code&gt;WITH_THREADS&lt;/code&gt; 常量。</target>
        </trans-unit>
        <trans-unit id="729c9787f60d8418994cdb90a7bff93ed76bf569" translate="yes" xml:space="preserve">
          <source>These macros use different memory allocators, depending on the constant &lt;a href=&quot;#c.NPY_USE_PYMEM&quot;&gt;&lt;code&gt;NPY_USE_PYMEM&lt;/code&gt;&lt;/a&gt;. The system malloc is used when &lt;a href=&quot;#c.NPY_USE_PYMEM&quot;&gt;&lt;code&gt;NPY_USE_PYMEM&lt;/code&gt;&lt;/a&gt; is 0, if &lt;a href=&quot;#c.NPY_USE_PYMEM&quot;&gt;&lt;code&gt;NPY_USE_PYMEM&lt;/code&gt;&lt;/a&gt; is 1, then the Python memory allocator is used.</source>
          <target state="translated">这些宏使用不同的内存分配器，具体取决于常量&lt;a href=&quot;#c.NPY_USE_PYMEM&quot;&gt; &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; &lt;/a&gt;。当&lt;a href=&quot;#c.NPY_USE_PYMEM&quot;&gt; &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; &lt;/a&gt;为0时使用系统malloc ，如果&lt;a href=&quot;#c.NPY_USE_PYMEM&quot;&gt; &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; &lt;/a&gt;为1，则使用Python内存分配器。</target>
        </trans-unit>
        <trans-unit id="da2fff533a172874c502697494e5cdbf3a7c39b3" translate="yes" xml:space="preserve">
          <source>These macros use different memory allocators, depending on the constant &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt;. The system malloc is used when &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; is 0, if &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; is 1, then the Python memory allocator is used.</source>
          <target state="translated">这些宏使用不同的内存分配器，具体取决于常量 &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; 。当 &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; 为0 时使用系统malloc ，如果 &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; 为1，则使用Python内存分配器。</target>
        </trans-unit>
        <trans-unit id="512de4565bde2a4a800d6eb7f4ecd21ece637307" translate="yes" xml:space="preserve">
          <source>These members are both pointers to functions to copy data from &lt;em&gt;src&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;swap&lt;/em&gt; if indicated. The value of arr is only used for flexible ( &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ) arrays (and is obtained from &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; ). The second function copies a single value, while the first loops over n values with the provided strides. These functions can deal with misbehaved &lt;em&gt;src&lt;/em&gt; data. If &lt;em&gt;src&lt;/em&gt; is NULL then no copy is performed. If &lt;em&gt;swap&lt;/em&gt; is 0, then no byteswapping occurs. It is assumed that &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;src&lt;/em&gt; do not overlap. If they overlap, then use &lt;code&gt;memmove&lt;/code&gt; (&amp;hellip;) first followed by &lt;code&gt;copyswap(n)&lt;/code&gt; with NULL valued &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">这些成员都是指向将数据从&lt;em&gt;src&lt;/em&gt;复制到&lt;em&gt;dest&lt;/em&gt;并在需要时&lt;em&gt;交换的&lt;/em&gt;函数的指针。 arr的值仅用于灵活的（&lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt; &lt;code&gt;NPY_STRING&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt; &lt;code&gt;NPY_UNICODE&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt; &lt;code&gt;NPY_VOID&lt;/code&gt; &lt;/a&gt;）数组（从 &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; 获得）。第二个函数复制单个值，而第一个函数以提供的步幅循环n个值。这些功能可以处理行为异常的&lt;em&gt;src&lt;/em&gt;数据。如果&lt;em&gt;src&lt;/em&gt;为NULL，则不执行任何复制。如果&lt;em&gt;swap&lt;/em&gt;为0，则不会发生字节&lt;em&gt;交换&lt;/em&gt;。假设&lt;em&gt;dest&lt;/em&gt;和&lt;em&gt;src&lt;/em&gt;不要重叠。如果它们重叠，则首先使用 &lt;code&gt;memmove&lt;/code&gt; （...），然后使用NULL值为 &lt;code&gt;src&lt;/code&gt; 的 &lt;code&gt;copyswap(n)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a72dfa72e903b9f6c19523d338aa7b21c3b5f83" translate="yes" xml:space="preserve">
          <source>These members are both pointers to functions to copy data from &lt;em&gt;src&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;swap&lt;/em&gt; if indicated. The value of arr is only used for flexible ( &lt;a href=&quot;dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ) arrays (and is obtained from &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; ). The second function copies a single value, while the first loops over n values with the provided strides. These functions can deal with misbehaved &lt;em&gt;src&lt;/em&gt; data. If &lt;em&gt;src&lt;/em&gt; is NULL then no copy is performed. If &lt;em&gt;swap&lt;/em&gt; is 0, then no byteswapping occurs. It is assumed that &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;src&lt;/em&gt; do not overlap. If they overlap, then use &lt;code&gt;memmove&lt;/code&gt; (&amp;hellip;) first followed by &lt;code&gt;copyswap(n)&lt;/code&gt; with NULL valued &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">这些成员都是指向将数据从&lt;em&gt;src&lt;/em&gt;复制到&lt;em&gt;dest&lt;/em&gt;并在需要时&lt;em&gt;交换的&lt;/em&gt;函数的指针。 arr的值仅用于灵活的（&lt;a href=&quot;dtype#c.NPY_STRING&quot;&gt; &lt;code&gt;NPY_STRING&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;dtype#c.NPY_UNICODE&quot;&gt; &lt;code&gt;NPY_UNICODE&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;dtype#c.NPY_VOID&quot;&gt; &lt;code&gt;NPY_VOID&lt;/code&gt; &lt;/a&gt;）数组（从 &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; 获得）。第二个函数复制单个值，而第一个函数以提供的跨度循环遍历n个值。这些功能可以处理行为异常的&lt;em&gt;src&lt;/em&gt;数据。如果&lt;em&gt;src&lt;/em&gt;为NULL，则不执行任何复制。如果&lt;em&gt;swap&lt;/em&gt;为0，则不会发生字节&lt;em&gt;交换&lt;/em&gt;。假设&lt;em&gt;dest&lt;/em&gt;和&lt;em&gt;src&lt;/em&gt;不要重叠。如果它们重叠，则首先使用 &lt;code&gt;memmove&lt;/code&gt; （...），然后使用NULL值为 &lt;code&gt;src&lt;/code&gt; 的 &lt;code&gt;copyswap(n)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6721252244f80ca68ee960086197a2ea6f31616" translate="yes" xml:space="preserve">
          <source>These numbers in the previous line represent (0, 0) to machine precision</source>
          <target state="translated">前面一行的数字代表(0,0)到机器的精度。</target>
        </trans-unit>
        <trans-unit id="dc06d74801540c694b86fd1603123c1d29a31d44" translate="yes" xml:space="preserve">
          <source>These options determine the way floating point numbers, arrays and other NumPy objects are displayed.</source>
          <target state="translated">这些选项决定了浮点数字、数组和其他NumPy对象的显示方式。</target>
        </trans-unit>
        <trans-unit id="c7caafe15667a4da0d6093971259ebc7a46a9f78" translate="yes" xml:space="preserve">
          <source>These pages describe a general &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; and &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; workflow.</source>
          <target state="translated">这些页面描述了一般的&lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;和&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;工作流程。</target>
        </trans-unit>
        <trans-unit id="df150acba8d3f0417e81ddcccc29e42e2e807db8" translate="yes" xml:space="preserve">
          <source>These paths both use the same machinery. We make the distinction here, because they result in different input to your methods. Specifically, &lt;a href=&quot;#view-casting&quot;&gt;View casting&lt;/a&gt; means you have created a new instance of your array type from any potential subclass of ndarray. &lt;a href=&quot;#new-from-template&quot;&gt;Creating new from template&lt;/a&gt; means you have created a new instance of your class from a pre-existing instance, allowing you - for example - to copy across attributes that are particular to your subclass.</source>
          <target state="translated">这些路径都使用相同的机器。我们在这里有所不同，因为它们导致您的方法输入不同。具体来说，&lt;a href=&quot;#view-casting&quot;&gt;视图转换&lt;/a&gt;意味着您已经从ndarray的任何潜在子类中创建了数组类型的新实例。&lt;a href=&quot;#new-from-template&quot;&gt;从模板创建新对象&lt;/a&gt;意味着您已经从现有实例创建了类的新实例，例如，允许您跨子类特有的属性进行复制。</target>
        </trans-unit>
        <trans-unit id="dcba0fcabfaea90dcbb4dedc9f83dbe704fc9440" translate="yes" xml:space="preserve">
          <source>These pointers are different from the pointers accepted by &lt;code&gt;NpyIter_ResetBasePointers&lt;/code&gt;, because the direction along some axes may have been reversed.</source>
          <target state="translated">这些指针与 &lt;code&gt;NpyIter_ResetBasePointers&lt;/code&gt; 接受的指针不同，因为沿某些轴的方向可能已反转。</target>
        </trans-unit>
        <trans-unit id="2936192ef68f1082cb1baded7a4cc1332510cdca" translate="yes" xml:space="preserve">
          <source>These properties together mean that we can safely mix together the usual user-provided seed with simple incrementing counters to get &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; states that are (to very high probability) independent of each other. We can wrap this together into an API that is easy to use and difficult to misuse.</source>
          <target state="translated">这些属性共同意味着我们可以安全地将用户提供的常规种子与简单的增量计数器安全地混合在一起，以获得（非常有可能）彼此独立的&lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt;状态。我们可以将它们包装到一个易于使用且难以滥用的API中。</target>
        </trans-unit>
        <trans-unit id="43a8a14f212cc60aa00fe9447268d1975d32ef40" translate="yes" xml:space="preserve">
          <source>These properties together mean that we can safely mix together the usual user-provided seed with simple incrementing counters to get &lt;code&gt;BitGenerator&lt;/code&gt; states that are (to very high probability) independent of each other. We can wrap this together into an API that is easy to use and difficult to misuse.</source>
          <target state="translated">这些属性共同意味着我们可以安全地将用户提供的常规种子与简单的递增计数器安全地混合在一起，以获得（非常有可能）彼此独立的 &lt;code&gt;BitGenerator&lt;/code&gt; 状态。我们可以将它们包装到一个易于使用且难以滥用的API中。</target>
        </trans-unit>
        <trans-unit id="a6a12c973c6b3912e3652bb2e3ed402ca4234700" translate="yes" xml:space="preserve">
          <source>These tools have been found useful by others using Python and so are included here. They are discussed separately because they are either older ways to do things now handled by f2py, Cython, or ctypes (SWIG, PyFort) or because I don&amp;rsquo;t know much about them (SIP, Boost). I have not added links to these methods because my experience is that you can find the most relevant link faster using Google or some other search engine, and any links provided here would be quickly dated. Do not assume that just because it is included in this list, I don&amp;rsquo;t think the package deserves your attention. I&amp;rsquo;m including information about these packages because many people have found them useful and I&amp;rsquo;d like to give you as many options as possible for tackling the problem of easily integrating your code.</source>
          <target state="translated">这些工具已被其他使用Python的人发现有用，因此包含在此处。分别讨论它们是因为它们是执行f2py，Cython或ctypes（SWIG，PyFort）现在处理的旧方法，或者因为我对其了解不多（SIP，Boost）。我没有为这些方法添加链接，因为我的经验是，您可以使用Google或其他搜索引擎更快地找到最相关的链接，并且此处提供的任何链接都会过时。不要以为仅仅因为它包含在此列表中，所以我认为该软件包不值得您关注。我之所以提供这些软件包的信息，是因为许多人发现它们很有用，并且我想为您提供尽可能多的选择，以解决轻松集成代码的问题。</target>
        </trans-unit>
        <trans-unit id="f0fbc806872e828602fd0c760ad7240ac769262d" translate="yes" xml:space="preserve">
          <source>These two macros are similar and obtain the pointer to the data-buffer for the array. The first macro can (and should be) assigned to a particular pointer where the second is for generic processing. If you have not guaranteed a contiguous and/or aligned array then be sure you understand how to access the data in the array to avoid memory and/or alignment problems.</source>
          <target state="translated">这两个宏类似于获取数组数据缓冲区的指针。第一个宏可以(也应该)分配给一个特定的指针,第二个宏用于通用处理。如果你没有保证一个连续的和/或对齐的数组,那么请确保你了解如何访问数组中的数据以避免内存和/或对齐问题。</target>
        </trans-unit>
        <trans-unit id="e28f8dd7e1d385fa1bfc87cb75abfbb7c4a8ade7" translate="yes" xml:space="preserve">
          <source>These type names are part of the C-API and can therefore be created in extension C-code. There is also a &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; and a &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; that are simple substitutes for one of the integer types that can hold a pointer on the platform. The structure of these scalar objects is not exposed to C-code. The function &lt;a href=&quot;array#c.PyArray_ScalarAsCtype&quot;&gt;&lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt;&lt;/a&gt; (..) can be used to extract the C-type value from the array scalar and the function &lt;a href=&quot;array#c.PyArray_Scalar&quot;&gt;&lt;code&gt;PyArray_Scalar&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to construct an array scalar from a C-value.</source>
          <target state="translated">这些类型名称是C-API的一部分，因此可以在扩展C代码中创建。还有一个 &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; 和 &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; ，它们可以简单地替代可以在平台上保存指针的整数类型之一。这些标量对象的结构不暴露于C代码。函数&lt;a href=&quot;array#c.PyArray_ScalarAsCtype&quot;&gt; &lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt; &lt;/a&gt;（..）可用于从数组标量提取C类型值，函数&lt;a href=&quot;array#c.PyArray_Scalar&quot;&gt; &lt;code&gt;PyArray_Scalar&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）可用于从C值构造数组标量。</target>
        </trans-unit>
        <trans-unit id="be4a900566749a67d476933d0258a41ade60543e" translate="yes" xml:space="preserve">
          <source>These type names are part of the C-API and can therefore be created in extension C-code. There is also a &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; and a &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; that are simple substitutes for one of the integer types that can hold a pointer on the platform. The structure of these scalar objects is not exposed to C-code. The function &lt;a href=&quot;c-api.array#c.PyArray_ScalarAsCtype&quot;&gt;&lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt;&lt;/a&gt; (..) can be used to extract the C-type value from the array scalar and the function &lt;a href=&quot;c-api.array#c.PyArray_Scalar&quot;&gt;&lt;code&gt;PyArray_Scalar&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to construct an array scalar from a C-value.</source>
          <target state="translated">这些类型名称是C-API的一部分，因此可以在扩展C代码中创建。还有一个 &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; 和 &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; ，它们可以简单地替代可以在平台上保存指针的整数类型之一。这些标量对象的结构不暴露于C代码。函数&lt;a href=&quot;c-api.array#c.PyArray_ScalarAsCtype&quot;&gt; &lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt; &lt;/a&gt;（..）可用于从数组标量中提取C类型的值，函数&lt;a href=&quot;c-api.array#c.PyArray_Scalar&quot;&gt; &lt;code&gt;PyArray_Scalar&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）可用于从C值构造数组中的标量。</target>
        </trans-unit>
        <trans-unit id="39c33e43ad465d1114668c2913272d120aead183" translate="yes" xml:space="preserve">
          <source>These typemaps now check to make sure that the &lt;code&gt;INPLACE_ARRAY&lt;/code&gt; arguments use native byte ordering. If not, an exception is raised.</source>
          <target state="translated">现在，这些类型映射检查以确保 &lt;code&gt;INPLACE_ARRAY&lt;/code&gt; 参数使用本机字节顺序。如果不是，则引发异常。</target>
        </trans-unit>
        <trans-unit id="afffd3e5751f118e6c4a8e5fa416a0de7397d2ff" translate="yes" xml:space="preserve">
          <source>These values are appended to a copy of &lt;code&gt;a&lt;/code&gt;. It must be of the correct shape (the same shape as &lt;code&gt;a&lt;/code&gt;, excluding &lt;code&gt;axis&lt;/code&gt;). If &lt;code&gt;axis&lt;/code&gt; is not specified, &lt;code&gt;b&lt;/code&gt; can be any shape and will be flattened before use.</source>
          <target state="translated">这些值附加的副本 &lt;code&gt;a&lt;/code&gt; 。它必须是正确的形状（相同的形状的 &lt;code&gt;a&lt;/code&gt; ，不包括 &lt;code&gt;axis&lt;/code&gt; ）。如果未指定 &lt;code&gt;axis&lt;/code&gt; ，则 &lt;code&gt;b&lt;/code&gt; 可以是任何形状，并且在使用前将被展平。</target>
        </trans-unit>
        <trans-unit id="612fafedc61071a5e61db03c65c0f553ab91df63" translate="yes" xml:space="preserve">
          <source>These values are appended to a copy of &lt;code&gt;arr&lt;/code&gt;. It must be of the correct shape (the same shape as &lt;code&gt;arr&lt;/code&gt;, excluding &lt;code&gt;axis&lt;/code&gt;). If &lt;code&gt;axis&lt;/code&gt; is not specified, &lt;code&gt;values&lt;/code&gt; can be any shape and will be flattened before use.</source>
          <target state="translated">这些值将附加到 &lt;code&gt;arr&lt;/code&gt; 的副本中。它必须具有正确的形状（与 &lt;code&gt;arr&lt;/code&gt; 相同的形状，但 &lt;code&gt;axis&lt;/code&gt; 除外）。如果未指定 &lt;code&gt;axis&lt;/code&gt; ，则 &lt;code&gt;values&lt;/code&gt; 可以是任何形状，并且在使用前将被展平。</target>
        </trans-unit>
        <trans-unit id="d11f3f9e08bc59771682cf52bbe126f37d2ff215" translate="yes" xml:space="preserve">
          <source>These values are only returned if &lt;a href=&quot;numpy.full#numpy.full&quot;&gt;&lt;code&gt;full&lt;/code&gt;&lt;/a&gt; = True</source>
          <target state="translated">仅当&lt;a href=&quot;numpy.full#numpy.full&quot;&gt; &lt;code&gt;full&lt;/code&gt; &lt;/a&gt; = True时才返回这些值</target>
        </trans-unit>
        <trans-unit id="c265d10397c2203b05e143772f5cfb33ffa2cf8c" translate="yes" xml:space="preserve">
          <source>These values are only returned if &lt;code&gt;full&lt;/code&gt; = True</source>
          <target state="translated">仅当 &lt;code&gt;full&lt;/code&gt; = True 时才返回这些值</target>
        </trans-unit>
        <trans-unit id="94c85fa0224cf9a04b1b6ccf08fcebfe46c06507" translate="yes" xml:space="preserve">
          <source>These values will be element-wise interpolated into the string.</source>
          <target state="translated">这些值将被逐个元素插值到字符串中。</target>
        </trans-unit>
        <trans-unit id="dd5e6abec4e1ccbc6948e611e796f2af804c4524" translate="yes" xml:space="preserve">
          <source>They are the standard vector/matrix/tensor type of NumPy. Many NumPy functions return arrays, not matrices.</source>
          <target state="translated">它们是NumPy的标准向量/矩阵/张量类型。许多NumPy函数都返回数组,而不是矩阵。</target>
        </trans-unit>
        <trans-unit id="8f43e0b4384b8a2ab0accbd750c1e3d8364a7037" translate="yes" xml:space="preserve">
          <source>They are the standard vector/matrix/tensor type of numpy. Many numpy functions return arrays, not matrices.</source>
          <target state="translated">它们是numpy的标准向量/矩阵/张量类型。许多numpy函数都返回数组,而不是矩阵。</target>
        </trans-unit>
        <trans-unit id="509dc829f5043c117345f356b056cfc2f0e4fe76" translate="yes" xml:space="preserve">
          <source>They support multidimensional array algebra that is supported in MATLAB</source>
          <target state="translated">它们支持MATLAB中支持的多维数组代数。</target>
        </trans-unit>
        <trans-unit id="d528fd04772fea95a1dd88b443f26490baf33962" translate="yes" xml:space="preserve">
          <source>Things are a little bit more tricky when combining reduction and allocated operands. Before iteration is started, any reduction operand must be initialized to its starting values. Here&amp;rsquo;s how we can do this, taking sums along the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">当组合归约操作数和分配的操作数时，事情要复杂一些。在开始迭代之前，必须将任何归约操作数初始化为其初始值。沿a的最后一个轴求和 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d8c3ebfdc398f463f36600d7ef80c9d888a357d" translate="yes" xml:space="preserve">
          <source>Things become more complex when multidimensional arrays are indexed, particularly with multidimensional index arrays. These tend to be more unusual uses, but they are permitted, and they are useful for some problems. We&amp;rsquo;ll start with the simplest multidimensional case (using the array y from the previous examples):</source>
          <target state="translated">当对多维数组进行索引时，事情变得更加复杂，尤其是对于多维索引数组。这些往往是更不寻常的用途，但被允许使用，它们对于某些问题很有用。我们将从最简单的多维情况开始（使用前面示例中的数组y）：</target>
        </trans-unit>
        <trans-unit id="998943208ea6deef89245cfe0875a67c35f9b773" translate="yes" xml:space="preserve">
          <source>Think of &lt;a href=&quot;#numpy.linalg.multi_dot&quot;&gt;&lt;code&gt;multi_dot&lt;/code&gt;&lt;/a&gt; as:</source>
          <target state="translated">将&lt;a href=&quot;#numpy.linalg.multi_dot&quot;&gt; &lt;code&gt;multi_dot&lt;/code&gt; &lt;/a&gt;视为：</target>
        </trans-unit>
        <trans-unit id="80d13b605601d6c6ca920c19b73c5be17b635404" translate="yes" xml:space="preserve">
          <source>This 2-d averaging filter runs quickly because the loop is in C and the pointer computations are done only as needed. If the code above is compiled as a module &lt;code&gt;image&lt;/code&gt;, then a 2-d image, &lt;code&gt;img&lt;/code&gt;, can be filtered using this code very quickly using:</source>
          <target state="translated">该二维平均滤波器运行很快，因为循环位于C中，并且指针计算仅在需要时执行。如果以上代码被编译为模块 &lt;code&gt;image&lt;/code&gt; ，则可以使用以下代码非常快速地过滤出 &lt;code&gt;img&lt;/code&gt; 图像img：</target>
        </trans-unit>
        <trans-unit id="1e4e675f0444c2be3f07e89468e7d677b6986ce7" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;.wav&lt;/code&gt; example is for illustration; to read a &lt;code&gt;.wav&lt;/code&gt; file in real life, use Python&amp;rsquo;s built-in module &lt;a href=&quot;https://docs.python.org/dev/library/wave.html#module-wave&quot;&gt;&lt;code&gt;wave&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;.wav&lt;/code&gt; 示例仅用于说明；要在现实生活中读取 &lt;code&gt;.wav&lt;/code&gt; 文件，请使用Python的内置模块&lt;a href=&quot;https://docs.python.org/dev/library/wave.html#module-wave&quot;&gt; &lt;code&gt;wave&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="269959a51cb8489ddd62f29ffab3f7d5a6b40d53" translate="yes" xml:space="preserve">
          <source>This Chapter attempts to explain the logic behind some of the new pieces of code. The purpose behind these explanations is to enable somebody to be able to understand the ideas behind the implementation somewhat more easily than just staring at the code. Perhaps in this way, the algorithms can be improved on, borrowed from, and/or optimized by more people.</source>
          <target state="translated">本章试图解释一些新代码背后的逻辑。这些解释背后的目的是为了让人能够更容易理解实现背后的思想,而不是仅仅盯着代码看。也许通过这种方式,算法可以被更多人改进、借鉴和/或优化。</target>
        </trans-unit>
        <trans-unit id="d6d4a7a2f523794d0b16e4b9b049698c812e64fd" translate="yes" xml:space="preserve">
          <source>This Subcommittee shall NOT make decisions about the direction, scope or technical direction of the Project.</source>
          <target state="translated">小組委員會不得就該計劃的方向、範圍或技術方向作出決定。</target>
        </trans-unit>
        <trans-unit id="e344df267f24877e3c878787dee0c7157b282950" translate="yes" xml:space="preserve">
          <source>This Subcommittee will have 5 members, 4 of whom will be current Council Members and 1 of whom will be external to the Steering Council. No more than 2 Subcommittee Members can report to one person through employment or contracting work (including the reportee, i.e. the reportee + 1 is the max). This avoids effective majorities resting on one person.</source>
          <target state="translated">小組委員會將有5名成員,其中4名為現任理事會成員,1名為督導委員會以外的成員。小組委員會委員透過受僱或合約工作向一人匯報的人數不得多於2人(包括匯報人,即匯報人+1人為上限)。此舉可避免因一人佔大多數而出現問題。</target>
        </trans-unit>
        <trans-unit id="d8eb7804ceb212518c04178ca9353c5652cddc34" translate="yes" xml:space="preserve">
          <source>This address may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it. The value itself may change during iteration, in particular if buffering is enabled. This function may be safely called without holding the Python GIL.</source>
          <target state="translated">该地址可能在迭代循环之前被缓存，调用 &lt;code&gt;iternext&lt;/code&gt; 不会更改它。该值本身在迭代过程中可能会更改，特别是如果启用了缓冲。无需持有Python GIL即可安全地调用此函数。</target>
        </trans-unit>
        <trans-unit id="6a02ab6384a4ff5cc117cc0360cf322a65257b07" translate="yes" xml:space="preserve">
          <source>This advanced indexing occurs when obj is an array object of Boolean type, such as may be returned from comparison operators. A single boolean index array is practically identical to &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; where, as described above, &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;obj.nonzero()&lt;/code&gt;&lt;/a&gt; returns a tuple (of length &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt;&lt;code&gt;obj.ndim&lt;/code&gt;&lt;/a&gt;) of integer index arrays showing the &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; elements of &lt;em&gt;obj&lt;/em&gt;. However, it is faster when &lt;code&gt;obj.shape == x.shape&lt;/code&gt;.</source>
          <target state="translated">当obj是布尔类型的数组对象（例如，可以从比较运算符返回）时，就会发生这种高级索引。单个布尔索引数组实际上与 &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; 相同，如上所述，&lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;obj.nonzero()&lt;/code&gt; &lt;/a&gt;返回整数索引数组的元组（长度为&lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt; &lt;code&gt;obj.ndim&lt;/code&gt; &lt;/a&gt;），该数组显示&lt;em&gt;obj&lt;/em&gt;的&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt;元素。但是，当 &lt;code&gt;obj.shape == x.shape&lt;/code&gt; 时，速度更快。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dacb6ef0aabe4e0449ac2f7d6e826edb424af8c" translate="yes" xml:space="preserve">
          <source>This advanced indexing occurs when obj is an array object of Boolean type, such as may be returned from comparison operators. A single boolean index array is practically identical to &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; where, as described above, &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;obj.nonzero()&lt;/code&gt;&lt;/a&gt; returns a tuple (of length &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt;&lt;code&gt;obj.ndim&lt;/code&gt;&lt;/a&gt;) of integer index arrays showing the &lt;code&gt;True&lt;/code&gt; elements of &lt;em&gt;obj&lt;/em&gt;. However, it is faster when &lt;code&gt;obj.shape == x.shape&lt;/code&gt;.</source>
          <target state="translated">当obj是布尔类型的数组对象（例如，可以从比较运算符返回）时，就会发生这种高级索引。单个布尔索引数组实际上与 &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; 相同，如上所述，&lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;obj.nonzero()&lt;/code&gt; &lt;/a&gt;返回整数索引数组的元组（长度为&lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt; &lt;code&gt;obj.ndim&lt;/code&gt; &lt;/a&gt;），该数组显示&lt;em&gt;obj&lt;/em&gt;的 &lt;code&gt;True&lt;/code&gt; 元素。但是，当 &lt;code&gt;obj.shape == x.shape&lt;/code&gt; 时，速度更快。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="710121ccc37af7c57d603d19a46f2cadc801d4ee" translate="yes" xml:space="preserve">
          <source>This allows multithreading to fill large arrays in chunks using suitable BitGenerators in parallel.</source>
          <target state="translated">这就允许多线程使用合适的BitGenerators并行填充大型数组。</target>
        </trans-unit>
        <trans-unit id="af03503ddeac7c1214ea6c40abe67021cd6a3a66" translate="yes" xml:space="preserve">
          <source>This allows you to import the in-place built NumPy &lt;em&gt;from the repo base directory only&lt;/em&gt;. If you want the in-place build to be visible outside that base dir, you need to point your &lt;code&gt;PYTHONPATH&lt;/code&gt; environment variable to this directory. Some IDEs (&lt;a href=&quot;https://www.spyder-ide.org/&quot;&gt;Spyder&lt;/a&gt; for example) have utilities to manage &lt;code&gt;PYTHONPATH&lt;/code&gt;. On Linux and OSX, you can run the command:</source>
          <target state="translated">这允许您&lt;em&gt;仅从repo基本目录&lt;/em&gt;导入就地构建的NumPy 。如果希望就地构建在该基本目录之外可见，则需要将 &lt;code&gt;PYTHONPATH&lt;/code&gt; 环境变量指向此目录。某些IDE（例如&lt;a href=&quot;https://www.spyder-ide.org/&quot;&gt;Spyder&lt;/a&gt;）具有实用程序来管理 &lt;code&gt;PYTHONPATH&lt;/code&gt; 。在Linux和OSX上，可以运行以下命令：</target>
        </trans-unit>
        <trans-unit id="8a10be423c319c36683d60f03c4235ea58ef43ca" translate="yes" xml:space="preserve">
          <source>This also works for functions and other objects that &lt;strong&gt;you&lt;/strong&gt; create. Just remember to include a docstring with your function using a string literal (&lt;code&gt;&quot;&quot;&quot; &quot;&quot;&quot;&lt;/code&gt; or &lt;code&gt;''' '''&lt;/code&gt; around your documentation).</source>
          <target state="translated">这也适用于&lt;strong&gt;您&lt;/strong&gt;创建的函数和其他对象。只要记住要在函数中使用字符串文字（在文档中使用 &lt;code&gt;&quot;&quot;&quot; &quot;&quot;&quot;&lt;/code&gt; 或 &lt;code&gt;''' '''&lt;/code&gt; ）来包含文档字符串。</target>
        </trans-unit>
        <trans-unit id="43700c3e2d90a58545492f544e16be4440930810" translate="yes" xml:space="preserve">
          <source>This also works in more dimensions, e.g.</source>
          <target state="translated">这在更多的维度上也是可行的,比如。</target>
        </trans-unit>
        <trans-unit id="d1c39c0afd071dc6e571fc8d1273c278aad6faa3" translate="yes" xml:space="preserve">
          <source>This also works with 2D arrays! If you start with this array:</source>
          <target state="translated">这也适用于2D数组! 如果你从这个数组开始。</target>
        </trans-unit>
        <trans-unit id="d160c6be16a498bbc805a56a17ad9724ae3c358b" translate="yes" xml:space="preserve">
          <source>This applies type promotion to all the inputs, using the NumPy rules for combining scalars and arrays, to determine the output type of a set of operands. This is the same result type that ufuncs produce. The specific algorithm used is as follows.</source>
          <target state="translated">它对所有的输入进行类型升级,使用NumPy的标量和数组组合规则来确定操作数集的输出类型。这和ufuncs产生的结果类型是一样的。具体使用的算法如下。</target>
        </trans-unit>
        <trans-unit id="2e8bc0cbcc5f069a41dc6497b9c0a909fd514a44" translate="yes" xml:space="preserve">
          <source>This approach to the array interface allows for faster access to an array using only one attribute lookup and a well-defined C-structure.</source>
          <target state="translated">这种数组接口的方法,只需使用一个属性查找和一个定义良好的C结构,就可以更快地访问数组。</target>
        </trans-unit>
        <trans-unit id="b2cfa3868ca6d5d3eec71f613d2a281e952e696d" translate="yes" xml:space="preserve">
          <source>This approach to the interface consists of the object having an &lt;a href=&quot;#__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">这种接口方法由具有&lt;a href=&quot;#__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; &lt;/a&gt;属性的对象组成。</target>
        </trans-unit>
        <trans-unit id="3505c6babbf93b992cced9994459f797fa18ee9a" translate="yes" xml:space="preserve">
          <source>This approach to the interface consists of the object having an &lt;a href=&quot;#object.__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">这种接口方法由具有&lt;a href=&quot;#object.__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; &lt;/a&gt;属性的对象组成。</target>
        </trans-unit>
        <trans-unit id="e27c7321ec2c09e2c1e41b0fb7ac933d7973957f" translate="yes" xml:space="preserve">
          <source>This arrangement allow for very flexible use of arrays. One thing that it allows is simple changes of the metadata to change the interpretation of the array buffer. Changing the byteorder of the array is a simple change involving no rearrangement of the data. The shape of the array can be changed very easily without changing anything in the data buffer or any data copying at all</source>
          <target state="translated">这种安排允许非常灵活地使用数组。它允许简单地改变元数据以改变数组缓冲区的解释。改变数组的字节顺序是一个简单的改变,不需要重新安排数据。数组的形状可以很容易地改变,而不需要改变数据缓冲区中的任何东西或任何数据复制。</target>
        </trans-unit>
        <trans-unit id="13b0f80cc0af4acb749cdb54d3ae94021e334ad5" translate="yes" xml:space="preserve">
          <source>This array creation routine allows for the convenient creation of a new array matching an existing array&amp;rsquo;s shapes and memory layout, possibly changing the layout and/or data type.</source>
          <target state="translated">该数组创建例程可方便地创建与现有数组的形状和内存布局匹配的新数组，并可能更改布局和/或数据类型。</target>
        </trans-unit>
        <trans-unit id="b6ad81be881df54f2faa5255b14c490a53a2cd92" translate="yes" xml:space="preserve">
          <source>This array is a copy of some other array. The C-API function PyArray_ResolveWritebackIfCopy must be called before deallocating to the base array will be updated with the contents of this array.</source>
          <target state="translated">这个数组是其他数组的拷贝。C-API函数PyArray_ResolveWritebackIfCopy必须在deallocating之前被调用,基数组将被更新为这个数组的内容。</target>
        </trans-unit>
        <trans-unit id="9975deeda2df7b42c75df625b9b5fc69426c2203" translate="yes" xml:space="preserve">
          <source>This array is stored in memory as 40 bytes, one after the other (known as a contiguous block of memory). The strides of an array tell us how many bytes we have to skip in memory to move to the next position along a certain axis. For example, we have to skip 4 bytes (1 value) to move to the next column, but 20 bytes (5 values) to get to the same position in the next row. As such, the strides for the array &lt;code&gt;x&lt;/code&gt; will be &lt;code&gt;(20, 4)&lt;/code&gt;.</source>
          <target state="translated">此数组以40字节的形式存储在内存中，一个接一个（又称为连续内存块）。数组的步幅告诉我们在内存中必须跳过多少字节才能沿着某个轴移动到下一个位置。例如，我们必须跳过4个字节（1个值）才能移至下一列，但要跳过20个字节（5个值）才能移至下一行中的相同位置。这样，数组 &lt;code&gt;x&lt;/code&gt; 的步幅将为 &lt;code&gt;(20, 4)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38cb8241a835a683d594eee86aed4e56e6c6635d" translate="yes" xml:space="preserve">
          <source>This array is the mask for all &lt;a href=&quot;../generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;writemasked&lt;/code&gt;&lt;/a&gt; operands. Code uses the &lt;code&gt;writemasked&lt;/code&gt; flag which indicates that only elements where the chosen ARRAYMASK operand is True will be written to. In general, the iterator does not enforce this, it is up to the code doing the iteration to follow that promise.</source>
          <target state="translated">该数组是所有&lt;a href=&quot;../generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;writemasked&lt;/code&gt; &lt;/a&gt;掩码操作数的掩码。代码使用 &lt;code&gt;writemasked&lt;/code&gt; 标志，该标志指示仅将所选ARRAYMASK操作数为True的元素写入。通常，迭代器不会强制执行此操作，这取决于代码进行迭代以遵循该承诺。</target>
        </trans-unit>
        <trans-unit id="6ed5fe179d122dc6d0ff4af8af1bf207796107b0" translate="yes" xml:space="preserve">
          <source>This array is the mask for all &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;writemasked&lt;/code&gt;&lt;/a&gt; operands. Code uses the &lt;code&gt;writemasked&lt;/code&gt; flag which indicates that only elements where the chosen ARRAYMASK operand is True will be written to. In general, the iterator does not enforce this, it is up to the code doing the iteration to follow that promise.</source>
          <target state="translated">该数组是所有&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;writemasked&lt;/code&gt; &lt;/a&gt;掩码操作数的掩码。代码使用 &lt;code&gt;writemasked&lt;/code&gt; 标志，该标志指示仅将所选ARRAYMASK操作数为True的元素写入。通常，迭代器不会强制执行此操作，而是由代码执行迭代来遵循该承诺。</target>
        </trans-unit>
        <trans-unit id="da76cf9484436ae5f595cbe33ce62d99eee348ae" translate="yes" xml:space="preserve">
          <source>This array is used in computing an N-d index from a 1-d index. It contains needed products of the dimensions.</source>
          <target state="translated">这个数组用于从1-d索引计算N-d索引。它包含了所需的维度的乘积。</target>
        </trans-unit>
        <trans-unit id="2950d768bc15bd8305b22a36aa90ddcbd53411a1" translate="yes" xml:space="preserve">
          <source>This array method can be conveniently chained:</source>
          <target state="translated">这个数组方法可以方便地进行连锁。</target>
        </trans-unit>
        <trans-unit id="cd59928fafb5b8b3afd2257d5348ff12e61a3751" translate="yes" xml:space="preserve">
          <source>This array must contain integers in &lt;code&gt;[0, n-1]&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of choices, unless &lt;code&gt;mode=wrap&lt;/code&gt; or &lt;code&gt;mode=clip&lt;/code&gt;, in which cases any integers are permissible.</source>
          <target state="translated">此数组必须在 &lt;code&gt;[0, n-1]&lt;/code&gt; 包含整数，其中 &lt;code&gt;n&lt;/code&gt; 是选择的数目，除非 &lt;code&gt;mode=wrap&lt;/code&gt; 或 &lt;code&gt;mode=clip&lt;/code&gt; ，在这种情况下，任何整数都是允许的。</target>
        </trans-unit>
        <trans-unit id="2801e85aeaae18790917a73e502d7026a3a34d08" translate="yes" xml:space="preserve">
          <source>This array must contain integers in &lt;code&gt;[0, n-1]&lt;/code&gt;, where n is the number of choices.</source>
          <target state="translated">此数组必须在 &lt;code&gt;[0, n-1]&lt;/code&gt; 包含整数，其中n是选择的数量。</target>
        </trans-unit>
        <trans-unit id="7231182809746ea9e4a7a5bcc665f806413fd373" translate="yes" xml:space="preserve">
          <source>This assumes that you have forked &lt;a href=&quot;https://github.com/scipy/scipy.org&quot;&gt;https://github.com/scipy/scipy.org&lt;/a&gt;:</source>
          <target state="translated">假设您已分叉&lt;a href=&quot;https://github.com/scipy/scipy.org&quot;&gt;https://github.com/scipy/scipy.org&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="3397e055cb40235a1ae2818b229475b2582745a3" translate="yes" xml:space="preserve">
          <source>This attribute allows simple but flexible determination of which sub- type should be considered &amp;ldquo;primary&amp;rdquo; when an operation involving two or more sub-types arises. In operations where different sub-types are being used, the sub-type with the largest &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; attribute will determine the sub-type of the output(s). If two sub- types have the same &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; then the sub-type of the first argument determines the output. The default &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; attribute returns a value of 0.0 for the base ndarray type and 1.0 for a sub-type. This attribute can also be defined by objects that are not sub-types of the ndarray and can be used to determine which &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method should be called for the return output.</source>
          <target state="translated">当涉及两个或多个子类型的操作出现时，此属性允许简单而灵活地确定应将哪个子类型视为&amp;ldquo;主要&amp;rdquo;。在使用不同子类型的操作中，具有最大&lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;属性的子类型将确定输出的子类型。如果两个子类型具有相同的&lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; ,&lt;/a&gt;则第一个参数的子类型将确定输出。默认的&lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;属性对于基本ndarray类型返回值0.0，对于子类型返回1.0。该属性还可以由非ndarray子类型的对象定义，并可以用于确定应为返回输出调用哪个&lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="a1937d99c6f34bca77e93395a42e2a63ca828dcf" translate="yes" xml:space="preserve">
          <source>This attribute can also be an object exposing the &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#bufferobjects&quot;&gt;buffer interface&lt;/a&gt; which will be used to share the data. If this key is not present (or returns None), then memory sharing will be done through the buffer interface of the object itself. In this case, the offset key can be used to indicate the start of the buffer. A reference to the object exposing the array interface must be stored by the new object if the memory area is to be secured.</source>
          <target state="translated">此属性也可以是一个对象，该对象公开将用于共享数据的&lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#bufferobjects&quot;&gt;缓冲区接口&lt;/a&gt;。如果此键不存在（或返回None），则将通过对象本身的缓冲区接口完成内存共享。在这种情况下，偏移键可用于指示缓冲区的开始。如果要保护存储区，则必须由新对象存储对暴露数组接口的对象的引用。</target>
        </trans-unit>
        <trans-unit id="19820dc6931f03b4ce34d1e382ce5208e82ba583" translate="yes" xml:space="preserve">
          <source>This attribute can also be an object exposing the &lt;a href=&quot;https://docs.python.org/dev/c-api/objbuffer.html#c.PyObject_AsCharBuffer&quot;&gt;&lt;code&gt;buffer interface&lt;/code&gt;&lt;/a&gt; which will be used to share the data. If this key is not present (or returns &lt;code&gt;None&lt;/code&gt;), then memory sharing will be done through the buffer interface of the object itself. In this case, the offset key can be used to indicate the start of the buffer. A reference to the object exposing the array interface must be stored by the new object if the memory area is to be secured.</source>
          <target state="translated">此属性也可以是一个对象，该对象公开将用于共享数据的&lt;a href=&quot;https://docs.python.org/dev/c-api/objbuffer.html#c.PyObject_AsCharBuffer&quot;&gt; &lt;code&gt;buffer interface&lt;/code&gt; &lt;/a&gt;。如果此键不存在（或返回 &lt;code&gt;None&lt;/code&gt; ），则将通过对象本身的缓冲区接口完成内存共享。在这种情况下，偏移键可用于指示缓冲区的开始。如果要保护存储区，则必须由新对象存储对暴露数组接口的对象的引用。</target>
        </trans-unit>
        <trans-unit id="357acc58797c34ec7ee3526baa5d4678b200c571" translate="yes" xml:space="preserve">
          <source>This attribute can also be an object exposing the &lt;code&gt;buffer interface&lt;/code&gt; which will be used to share the data. If this key is not present (or returns None), then memory sharing will be done through the buffer interface of the object itself. In this case, the offset key can be used to indicate the start of the buffer. A reference to the object exposing the array interface must be stored by the new object if the memory area is to be secured.</source>
          <target state="translated">此属性也可以是一个对象，该对象公开将用于共享数据的 &lt;code&gt;buffer interface&lt;/code&gt; 。如果此键不存在（或返回None），则将通过对象本身的缓冲区接口完成内存共享。在这种情况下，偏移键可用于指示缓冲区的开始。如果要保护存储区，则必须由新对象存储对暴露数组接口的对象的引用。</target>
        </trans-unit>
        <trans-unit id="99486092092808fe1a7a3c63950908fb38dd3c25" translate="yes" xml:space="preserve">
          <source>This attribute creates an object that makes it easier to use arrays when calling shared libraries with the ctypes module. The returned object has, among others, data, shape, and strides attributes (see Notes below) which themselves return ctypes objects that can be used as arguments to a shared library.</source>
          <target state="translated">这个属性创建了一个对象,使其在使用ctypes模块调用共享库时更容易使用数组。返回的对象除此之外还有data、shape和strides属性(见下面的注释),这些属性本身也会返回ctypes对象,可以作为共享库的参数。</target>
        </trans-unit>
        <trans-unit id="94f279541eccc23ec8d58b2be974fecc119fa4c7" translate="yes" xml:space="preserve">
          <source>This basic behavior can be augmented by passing a 2-tuple in as the file argument. The first element of the tuple should specify the relative path (under the package install directory) where the remaining sequence of files should be installed to (it has nothing to do with the file-names in the source distribution). The second element of the tuple is the sequence of files that should be installed. The files in this sequence can be filenames, relative paths, or absolute paths. For absolute paths the file will be installed in the top-level package installation directory (regardless of the first argument). Filenames and relative path names will be installed in the package install directory under the path name given as the first element of the tuple.</source>
          <target state="translated">这个基本行为可以通过传递一个 2-tuple 作为文件参数来增强。元组的第一个元素应该指定相对路径(在软件包安装目录下),剩余的文件序列应该被安装到那里(它与源码发行版中的文件名无关)。元组的第二个元素是应该被安装的文件序列。这个序列中的文件可以是文件名、相对路径或绝对路径。对于绝对路径,文件将被安装在顶层的软件包安装目录中(不管第一个参数是什么)。文件名和相对路径名将被安装在包的安装目录下,作为元组的第一个元素给出的路径名。</target>
        </trans-unit>
        <trans-unit id="38d8b59be8238ec40cd52d11a1691c2db5ac9b19" translate="yes" xml:space="preserve">
          <source>This broadcasting can also be achieved using the function &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">也可以使用功能&lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; 进行广播&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="040d755c45914cdad7e449ca2485bc004cd21eb5" translate="yes" xml:space="preserve">
          <source>This bug causes Python before 3.4 to not reliably show warnings again after they have been ignored once (even within catch_warnings). It means that no &amp;ldquo;ignore&amp;rdquo; filter can be used easily, since following tests might need to see the warning. Additionally it allows easier specificity for testing warnings and can be nested.</source>
          <target state="translated">此错误导致3.4之前的Python在一次被忽略之后（即使在catch_warnings中）也无法可靠地再次显示警告。这意味着不能轻易使用&amp;ldquo;忽略&amp;rdquo;过滤器，因为后续测试可能需要查看警告。此外，它还可以简化测试警告的特异性，并且可以嵌套。</target>
        </trans-unit>
        <trans-unit id="b97776ec43283f6527b6b56ee297ecb07c0e7a5e" translate="yes" xml:space="preserve">
          <source>This builds NumPy first, so the first time it may take a few minutes. If you specify &lt;code&gt;-n&lt;/code&gt;, the tests are run against the version of NumPy (if any) found on current PYTHONPATH.</source>
          <target state="translated">这将首先构建NumPy，因此第一次可能需要几分钟。如果指定 &lt;code&gt;-n&lt;/code&gt; ，则针对当前PYTHONPATH上找到的NumPy版本（如果有）运行测试。</target>
        </trans-unit>
        <trans-unit id="25f8c2b712d454554ccb3b1572df7e3d85a8d6a8" translate="yes" xml:space="preserve">
          <source>This can be done via &lt;em&gt;interactive rebasing&lt;/em&gt;.</source>
          <target state="translated">这可以通过&lt;em&gt;交互式重&lt;/em&gt;定基来完成。</target>
        </trans-unit>
        <trans-unit id="3d1ccaf9367b320b45fde18f5d1b6d26c14c28d1" translate="yes" xml:space="preserve">
          <source>This can be used on multidimensional arrays too:</source>
          <target state="translated">这也可以用在多维数组上。</target>
        </trans-unit>
        <trans-unit id="4619f696b33e2f5aafe4335faf3807d265baaeed" translate="yes" xml:space="preserve">
          <source>This can have multiple paragraphs.</source>
          <target state="translated">这可以有多个段落。</target>
        </trans-unit>
        <trans-unit id="7b0866e6d60c935d1c1a437309972ddf022e2bfb" translate="yes" xml:space="preserve">
          <source>This chapter will review many of the tools that are available for the purpose of accessing code written in other compiled languages. There are many resources available for learning to call other compiled libraries from Python and the purpose of this Chapter is not to make you an expert. The main goal is to make you aware of some of the possibilities so that you will know what to &amp;ldquo;Google&amp;rdquo; in order to learn more.</source>
          <target state="translated">本章将回顾许多可用于访问以其他编译语言编写的代码的工具。有很多资源可用于学习从Python调用其他已编译的库，本章的目的不是让您成为专家。主要目标是使您意识到其中的一些可能性，以便您了解&amp;ldquo; Google&amp;rdquo;的内容，以了解更多信息。</target>
        </trans-unit>
        <trans-unit id="f7b07ef80d0cc13652d9fe61895de6904fd8ef60" translate="yes" xml:space="preserve">
          <source>This class implements the special methods for almost all of Python&amp;rsquo;s builtin operators defined in the &lt;a href=&quot;https://docs.python.org/dev/library/operator.html#module-operator&quot;&gt;&lt;code&gt;operator&lt;/code&gt;&lt;/a&gt; module, including comparisons (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, etc.) and arithmetic (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, etc.), by deferring to the &lt;code&gt;__array_ufunc__&lt;/code&gt; method, which subclasses must implement.</source>
          <target state="translated">此类通过遵循 &lt;code&gt;__array_ufunc__&lt;/code&gt; 方法，为&lt;a href=&quot;https://docs.python.org/dev/library/operator.html#module-operator&quot;&gt; &lt;code&gt;operator&lt;/code&gt; &lt;/a&gt;模块中定义的几乎所有Python内置操作符实现了特殊方法，包括比较（ &lt;code&gt;==&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; 等）和算术（ &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; 等），必须实现哪些子类。</target>
        </trans-unit>
        <trans-unit id="4c89b01b7f4a0346b82c2ab3f988792b632fe09a" translate="yes" xml:space="preserve">
          <source>This class is provided for numarray backward-compatibility. New code (not concerned with numarray compatibility) should use arrays of type &lt;a href=&quot;../arrays.scalars#numpy.string_&quot;&gt;&lt;code&gt;string_&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../arrays.scalars#numpy.unicode_&quot;&gt;&lt;code&gt;unicode_&lt;/code&gt;&lt;/a&gt; and use the free functions in &lt;code&gt;numpy.char&lt;/code&gt; for fast vectorized string operations instead.</source>
          <target state="translated">提供此类是为了实现numarray向后兼容。新的代码（不涉及numarray兼容性）应该使用类型的数组&lt;a href=&quot;../arrays.scalars#numpy.string_&quot;&gt; &lt;code&gt;string_&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../arrays.scalars#numpy.unicode_&quot;&gt; &lt;code&gt;unicode_&lt;/code&gt; &lt;/a&gt;并使用免费的功能 &lt;code&gt;numpy.char&lt;/code&gt; 快速矢量字符串操作代替。</target>
        </trans-unit>
        <trans-unit id="cbc453ece1fc4bcfba8a214ebb68dae3ad49689e" translate="yes" xml:space="preserve">
          <source>This class is provided for numarray backward-compatibility. New code (not concerned with numarray compatibility) should use arrays of type &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt; and use the free functions in &lt;code&gt;numpy.char&lt;/code&gt; for fast vectorized string operations instead.</source>
          <target state="translated">提供此类是为了实现numarray向后兼容。新的代码（不涉及numarray兼容性）应该使用类型的数组 &lt;code&gt;string_&lt;/code&gt; 或 &lt;code&gt;unicode_&lt;/code&gt; 并使用免费的功能 &lt;code&gt;numpy.char&lt;/code&gt; 快速矢量字符串操作代替。</target>
        </trans-unit>
        <trans-unit id="817afa6aa8358446cc6150c81d202fd10664d253" translate="yes" xml:space="preserve">
          <source>This class isn&amp;rsquo;t very useful, because it has the same constructor as the bare ndarray object, including passing in buffers and shapes and so on. We would probably prefer the constructor to be able to take an already formed ndarray from the usual numpy calls to &lt;code&gt;np.array&lt;/code&gt; and return an object.</source>
          <target state="translated">此类不是很有用，因为它具有与裸ndarray对象相同的构造函数，包括传入缓冲区和形状等。我们可能希望构造函数能够从对np.array的常规numpy调用中 &lt;code&gt;np.array&lt;/code&gt; 已经形成的ndarray并返回一个对象。</target>
        </trans-unit>
        <trans-unit id="547d58e17f08661cffe0028727466b3bfecb1f09" translate="yes" xml:space="preserve">
          <source>This class may at some point be turned into a factory function which returns a view into an mmap buffer.</source>
          <target state="translated">这个类在某些时候可能会变成一个工厂函数,将视图返回到一个mmap缓冲区。</target>
        </trans-unit>
        <trans-unit id="9f0e2bd2c54e1831a429118c49099c40d4fc6a31" translate="yes" xml:space="preserve">
          <source>This code can be compiled and linked into an extension module named filter using:</source>
          <target state="translated">这段代码可以被编译并链接到一个名为filter的扩展模块中,使用。</target>
        </trans-unit>
        <trans-unit id="051a76f1d3dcebdcceb5b6a498f248ede74e08da" translate="yes" xml:space="preserve">
          <source>This code has a significant amount of error handling. Note the &lt;code&gt;SWIG_fail&lt;/code&gt; is a macro for &lt;code&gt;goto fail&lt;/code&gt;, referring to the label at line 28. If the user provides the wrong number of arguments, this will be caught at line 10. If construction of the NumPy array fails or produces an array with the wrong number of dimensions, these errors are caught at line 17. And finally, if an error is detected, memory is still managed correctly at line 30.</source>
          <target state="translated">此代码具有大量错误处理。请注意， &lt;code&gt;SWIG_fail&lt;/code&gt; 是 &lt;code&gt;goto fail&lt;/code&gt; 的宏，请参考第28行的标签。如果用户提供的参数数量错误，则将在第10行捕获该错误。如果NumPy数组的构造失败或生成的数组错误数量，这些错误将在第17行捕获。最后，如果检测到错误，则在第30行仍然可以正确管理内存。</target>
        </trans-unit>
        <trans-unit id="3999b914a2658c99b5fe639f3ab379867f2570ac" translate="yes" xml:space="preserve">
          <source>This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment and goals. Please try to follow this code in spirit as much as in letter, to create a friendly and productive environment that enriches the surrounding community.</source>
          <target state="translated">本守则并非详尽无遗或完整无缺。它是为了提炼出我们对合作、共享环境和目标的共同理解。请尽量在精神上和文字上遵守这一守则,以创造一个友好和富有成效的环境,丰富周围的社区。</target>
        </trans-unit>
        <trans-unit id="dc2f712a7c05e996ac3e38345d45b7f3d7e23038" translate="yes" xml:space="preserve">
          <source>This code loads the shared library named &lt;code&gt;code.{ext}&lt;/code&gt; located in the same path as this file. It then adds a return type of void to the functions contained in the library. It also adds argument checking to the functions in the library so that ndarrays can be passed as the first three arguments along with an integer (large enough to hold a pointer on the platform) as the fourth argument.</source>
          <target state="translated">此代码加载与该文件位于相同路径的名为 &lt;code&gt;code.{ext}&lt;/code&gt; 的共享库。然后，它向库中包含的函数添加void的返回类型。它还将参数检查添加到库中的函数，以便可以将ndarrays作为前三个参数以及整数（足以在平台上容纳指针）作为第四个参数传递。</target>
        </trans-unit>
        <trans-unit id="533c867c6a351c2be81a48161bc93203ea12c76d" translate="yes" xml:space="preserve">
          <source>This code of conduct applies to all spaces managed by the NumPy project, including all public and private mailing lists, issue trackers, wikis, blogs, Twitter, and any other communication channel used by our community. The NumPy project does not organise in-person events, however events related to our community should have a code of conduct similar in spirit to this one.</source>
          <target state="translated">本行为准则适用于NumPy项目管理的所有空间,包括所有公共和私人邮件列表、问题跟踪器、维基、博客、Twitter以及我们社区使用的任何其他交流渠道。NumPy项目不组织面对面的活动,但是与我们社区相关的活动应该有一个类似于这个行为准则的精神。</target>
        </trans-unit>
        <trans-unit id="cff208b4a7eacc934c607e5c41003491618977d7" translate="yes" xml:space="preserve">
          <source>This code of conduct should be honored by everyone who participates in the NumPy community formally or informally, or claims any affiliation with the project, in any project-related activities and especially when representing the project, in any role.</source>
          <target state="translated">每一个正式或非正式参与NumPy社区的人,或声称与项目有任何联系的人,在任何与项目有关的活动中,特别是在以任何角色代表项目时,都应遵守本行为准则。</target>
        </trans-unit>
        <trans-unit id="0f194434e38b3846c0fd28dc955d7908e8501694" translate="yes" xml:space="preserve">
          <source>This command builds (see &lt;code&gt;-c&lt;/code&gt; flag, execute &lt;code&gt;python -m numpy.f2py&lt;/code&gt; without arguments to see the explanation of command line options) an extension module &lt;code&gt;fib1.so&lt;/code&gt; (see &lt;code&gt;-m&lt;/code&gt; flag) to the current directory. Now, in Python the Fortran subroutine &lt;code&gt;FIB&lt;/code&gt; is accessible via &lt;code&gt;fib1.fib&lt;/code&gt;:</source>
          <target state="translated">此命令构建（参见 &lt;code&gt;-c&lt;/code&gt; 标志，执行 &lt;code&gt;python -m numpy.f2py&lt;/code&gt; 不带参数看到的命令行选项的说明）的扩展模块 &lt;code&gt;fib1.so&lt;/code&gt; （见 &lt;code&gt;-m&lt;/code&gt; 标志）为当前目录。现在，在Python中，可以通过 &lt;code&gt;fib1.fib&lt;/code&gt; 访问Fortran子例程 &lt;code&gt;FIB&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ac9bee6274aa8d66ef375e679babd25ee76812a2" translate="yes" xml:space="preserve">
          <source>This command leaves a file named add.{ext} in the current directory (where {ext} is the appropriate extension for a Python extension module on your platform &amp;mdash; so, pyd, &lt;em&gt;etc.&lt;/em&gt; ). This module may then be imported from Python. It will contain a method for each subroutine in add (zadd, cadd, dadd, sadd). The docstring of each method contains information about how the module method may be called:</source>
          <target state="translated">此命令在当前目录中保留一个名为add。{ext}的文件（其中{ext}是平台上Python扩展模块的适当扩展名-pyd&lt;em&gt;等&lt;/em&gt;）。然后可以从Python导入此模块。它将为add中的每个子例程包含一个方法（zadd，cadd，dadd，sadd）。每个方法的文档字符串包含有关如何调用模块方法的信息：</target>
        </trans-unit>
        <trans-unit id="bbb1615a9d0e074d0b52d81da555b5659d5320b3" translate="yes" xml:space="preserve">
          <source>This command leaves a file named add.{ext} in the current directory (where {ext} is the appropriate extension for a python extension module on your platform &amp;mdash; so, pyd, &lt;em&gt;etc.&lt;/em&gt; ). This module may then be imported from Python. It will contain a method for each subroutine in add (zadd, cadd, dadd, sadd). The docstring of each method contains information about how the module method may be called:</source>
          <target state="translated">此命令在当前目录中保留一个名为add。{ext}的文件（其中{ext}是平台上python扩展模块的适当扩展名-pyd&lt;em&gt;等&lt;/em&gt;）。然后可以从Python导入此模块。它将为add中的每个子例程包含一个方法（zadd，cadd，dadd，sadd）。每个方法的文档字符串包含有关如何调用模块方法的信息：</target>
        </trans-unit>
        <trans-unit id="b8208674ec726acd6f311802a0a4f9952791f4b6" translate="yes" xml:space="preserve">
          <source>This command leaves the file add.pyf in the current directory. The section of this file corresponding to zadd is:</source>
          <target state="translated">该命令将文件add.pyf留在当前目录中。该文件中与zadd对应的部分是。</target>
        </trans-unit>
        <trans-unit id="4e0a485b84958d1031e7018c2536aa8e72a66489" translate="yes" xml:space="preserve">
          <source>This condition is broadcast over the input. At locations where the condition is True, the &lt;code&gt;out&lt;/code&gt; array will be set to the ufunc result. Elsewhere, the &lt;code&gt;out&lt;/code&gt; array will retain its original value. Note that if an uninitialized &lt;code&gt;out&lt;/code&gt; array is created via the default &lt;code&gt;out=None&lt;/code&gt;, locations within it where the condition is False will remain uninitialized.</source>
          <target state="translated">此条件通过输入广播。在条件为True的位置，将 &lt;code&gt;out&lt;/code&gt; 数组设置为ufunc结果。在其他地方， &lt;code&gt;out&lt;/code&gt; 数组将保留其原始值。请注意，如果通过默认的 &lt;code&gt;out=None&lt;/code&gt; 创建了未初始化的 &lt;code&gt;out&lt;/code&gt; 数组，则条件为False的数组中的位置将保持未初始化。</target>
        </trans-unit>
        <trans-unit id="ee4c6c49dffb551e0984368af8f98c122bd3ccfb" translate="yes" xml:space="preserve">
          <source>This constructor can be compared to &lt;code&gt;empty&lt;/code&gt;: it creates a new record array but does not fill it with data. To create a record array from data, use one of the following methods:</source>
          <target state="translated">可以将此构造函数与 &lt;code&gt;empty&lt;/code&gt; 进行比较：它创建一个新的记录数组，但不用数据填充它。要从数据创建记录数组，请使用以下方法之一：</target>
        </trans-unit>
        <trans-unit id="33c942d2092f2a81aa60d19a082d10077f5b892d" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='Fortran'&lt;/code&gt;, in which case &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">如果不是 &lt;code&gt;None&lt;/code&gt; ，则此构造函数使用 &lt;code&gt;buffer&lt;/code&gt; （带有 &lt;code&gt;offset&lt;/code&gt; 和&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;）创建数组。如果 &lt;code&gt;buffer&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，则构造一个新数组，&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;为&amp;ldquo; C order&amp;rdquo;，除非 &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; 和 &lt;code&gt;order='Fortran'&lt;/code&gt; 在这种情况下，&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;为&amp;ldquo; Fortran order&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="953bdd8047346bccedc501390c7ed7305dc6711a" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='F'&lt;/code&gt;, in which case &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">如果不为 &lt;code&gt;None&lt;/code&gt; ，则此构造方法使用 &lt;code&gt;buffer&lt;/code&gt; （带有 &lt;code&gt;offset&lt;/code&gt; 和&lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;）创建数组。如果 &lt;code&gt;buffer&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，则构造一个新数组，其&lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;为&amp;ldquo; C顺序&amp;rdquo;，除非 &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; 和 &lt;code&gt;order='F'&lt;/code&gt; 在此情况下，&lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;为&amp;ldquo; Fortran顺序&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="244906121f35fcb6808baef572df1faf5ecac2b9" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='Fortran'&lt;/code&gt;, in which case &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">如果不是 &lt;code&gt;None&lt;/code&gt; ，则此构造函数使用 &lt;code&gt;buffer&lt;/code&gt; （带有 &lt;code&gt;offset&lt;/code&gt; 和&lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;）创建数组。如果 &lt;code&gt;buffer&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，则构造一个新数组，&lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;为&amp;ldquo; C order&amp;rdquo;，除非 &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; 和 &lt;code&gt;order='Fortran'&lt;/code&gt; 在这种情况下，&lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;为&amp;ldquo; Fortran order&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="472735a82ef7af1ec4165da8f5b7c128444159de" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='F'&lt;/code&gt;, in which case &lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">如果不为 &lt;code&gt;None&lt;/code&gt; ，则此构造方法使用 &lt;code&gt;buffer&lt;/code&gt; （带有 &lt;code&gt;offset&lt;/code&gt; 和&lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;）创建数组。如果 &lt;code&gt;buffer&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，则构造一个新数组，其&lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;为&amp;ldquo; C顺序&amp;rdquo;，除非 &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; 和 &lt;code&gt;order='F'&lt;/code&gt; 在此情况下，&lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;为&amp;ldquo; Fortran顺序&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="25eee032d6ea1636789f057c08bed3526280036b" translate="yes" xml:space="preserve">
          <source>This could then be registered to convert doubles to floats using the code:</source>
          <target state="translated">然后可以使用代码注册将双数转换为浮点数。</target>
        </trans-unit>
        <trans-unit id="a5986918bf935c1ed16d4421ab17b1ade1eafe40" translate="yes" xml:space="preserve">
          <source>This declares that the corresponding argument depends on the values of variables in the list &lt;code&gt;&amp;lt;names&amp;gt;&lt;/code&gt;. For example, &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; may use the values of other arguments. Using information given by &lt;code&gt;depend(..)&lt;/code&gt; attributes, F2PY ensures that arguments are initialized in a proper order. If &lt;code&gt;depend(..)&lt;/code&gt; attribute is not used then F2PY determines dependence relations automatically. Use &lt;code&gt;depend()&lt;/code&gt; to disable dependence relations generated by F2PY.</source>
          <target state="translated">这声明相应的参数取决于列表 &lt;code&gt;&amp;lt;names&amp;gt;&lt;/code&gt; 中变量的值。例如， &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; 可以使用其他参数的值。使用 &lt;code&gt;depend(..)&lt;/code&gt; 属性给出的信息，F2PY确保以正确的顺序初始化参数。如果未使用 &lt;code&gt;depend(..)&lt;/code&gt; 属性，则F2PY自动确定依赖关系。使用 &lt;code&gt;depend()&lt;/code&gt; 禁用由F2PY生成的依赖关系。</target>
        </trans-unit>
        <trans-unit id="c221f7f1dff9c4b5017181532f28da44b16fcb82" translate="yes" xml:space="preserve">
          <source>This decorator can be used to filter DeprecationWarning&amp;rsquo;s, to avoid printing them during the test suite run, while checking that the test actually raises a DeprecationWarning.</source>
          <target state="translated">该装饰器可用于过滤DeprecationWarning，以避免在测试套件运行期间打印它们，同时检查测试是否实际引发了DeprecationWarning。</target>
        </trans-unit>
        <trans-unit id="50d52a319d15baa1479e649a743cee7e5d09023b" translate="yes" xml:space="preserve">
          <source>This decorator can&amp;rsquo;t use the nose namespace, because it can be called from a non-test module. See also &lt;code&gt;istest&lt;/code&gt; and &lt;code&gt;nottest&lt;/code&gt; in &lt;code&gt;nose.tools&lt;/code&gt;.</source>
          <target state="translated">该装饰器不能使用鼻子命名空间，因为可以从非测试模块中调用它。又见 &lt;code&gt;istest&lt;/code&gt; 和 &lt;code&gt;nottest&lt;/code&gt; 在 &lt;code&gt;nose.tools&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67fd7e1d7456c74a698475b7f144fadff01137fb" translate="yes" xml:space="preserve">
          <source>This default iterator selects a sub-array of dimension</source>
          <target state="translated">这个默认的迭代器选择一个维度的子数组。</target>
        </trans-unit>
        <trans-unit id="cfb9c1da992a1d1aaddfb397e6c91ff1039b17da" translate="yes" xml:space="preserve">
          <source>This default threshold is designed to detect rank deficiency accounting for the numerical errors of the SVD computation. Imagine that there is a column in &lt;code&gt;M&lt;/code&gt; that is an exact (in floating point) linear combination of other columns in &lt;code&gt;M&lt;/code&gt;. Computing the SVD on &lt;code&gt;M&lt;/code&gt; will not produce a singular value exactly equal to 0 in general: any difference of the smallest SVD value from 0 will be caused by numerical imprecision in the calculation of the SVD. Our threshold for small SVD values takes this numerical imprecision into account, and the default threshold will detect such numerical rank deficiency. The threshold may declare a matrix &lt;code&gt;M&lt;/code&gt; rank deficient even if the linear combination of some columns of &lt;code&gt;M&lt;/code&gt; is not exactly equal to another column of &lt;code&gt;M&lt;/code&gt; but only numerically very close to another column of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">此默认阈值旨在检测由于SVD计算的数值误差而导致的秩不足。想象有在一列 &lt;code&gt;M&lt;/code&gt; 线性在其他列的组合是一种精确（浮点） &lt;code&gt;M&lt;/code&gt; 。通常，在 &lt;code&gt;M&lt;/code&gt; 上计算SVD 不会产生精确等于0的奇异值：最小SVD值与0的任何差异将由SVD计算中的数值不精确性引起。我们的小SVD值阈值考虑了此数字不精确性，默认阈值将检测到此类数字秩不​​足。该阈值可以声明一个矩阵 &lt;code&gt;M&lt;/code&gt; 秩亏即使某些列的线性组合 &lt;code&gt;M&lt;/code&gt; 不完全等于 &lt;code&gt;M&lt;/code&gt; 的另一列，而在数值上仅非常接近 &lt;code&gt;M&lt;/code&gt; 的另一列。</target>
        </trans-unit>
        <trans-unit id="a0285819f9fc91ea6c1e91e579241c01b00956ba" translate="yes" xml:space="preserve">
          <source>This design was retracted almost immediately after it was proposed, in &amp;lt;&lt;a href=&quot;https://mail.python.org/pipermail/numpy-discussion/2006-June/020995.html&quot;&gt;https://mail.python.org/pipermail/numpy-discussion/2006-June/020995.html&lt;/a&gt;&amp;gt;. Despite 14 years of documentation to the contrary, at no point was it valid to assume that &lt;code&gt;__array_interface__&lt;/code&gt; capsules held this tuple content.</source>
          <target state="translated">该设计在提出后几乎立即在&amp;lt; &lt;a href=&quot;https://mail.python.org/pipermail/numpy-discussion/2006-June/020995.html&quot;&gt;https://mail.python.org/pipermail/numpy-discussion/2006-June/020995.html&lt;/a&gt; &amp;gt;中撤回。尽管有14年的相反文献记录，但假定 &lt;code&gt;__array_interface__&lt;/code&gt; 胶囊容纳了该元组内容是毫无道理的。</target>
        </trans-unit>
        <trans-unit id="b6968499a16ad7614bdea90ae8f3aad570e0c60e" translate="yes" xml:space="preserve">
          <source>This document describes the syntax and best practices for docstrings used with the numpydoc extension for &lt;a href=&quot;http://sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt;.</source>
          <target state="translated">本文档介绍了与&lt;a href=&quot;http://sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt;的numpydoc扩展一起使用的文档字符串的语法和最佳实践。</target>
        </trans-unit>
        <trans-unit id="b45b65ecc52b644a63152b28ad1bde6a3a5e1f70" translate="yes" xml:space="preserve">
          <source>This document gives coding conventions for the C code comprising the C implementation of NumPy. Note, rules are there to be broken. Two good reasons to break a particular rule:</source>
          <target state="translated">本文档给出了NumPy的C代码组成的C实现的编码约定。注意,规则是用来打破的。打破某条规则的两个好理由。</target>
        </trans-unit>
        <trans-unit id="8c3b557b3201940ffcbe7e57b7ac3945729bb630" translate="yes" xml:space="preserve">
          <source>This document itself was written in ReStructuredText. &lt;a href=&quot;#example&quot;&gt;An example&lt;/a&gt; of the format shown here is available.</source>
          <target state="translated">该文档本身是用ReStructuredText编写的。&lt;a href=&quot;#example&quot;&gt;提供&lt;/a&gt;了此处所示格式的示例。</target>
        </trans-unit>
        <trans-unit id="2007e99c49141c98bee8b2f4b8b703b1ff66930c" translate="yes" xml:space="preserve">
          <source>This does not compute the usual correlation: if op2 is larger than op1, the arguments are swapped, and the conjugate is never taken for complex arrays. See PyArray_Correlate2 for the usual signal processing correlation.</source>
          <target state="translated">这并不是计算通常的相关性:如果 op2 大于 op1,参数会被调换,对于复杂数组,永远不会取共轭。参见PyArray_Correlate2,了解通常的信号处理相关性。</target>
        </trans-unit>
        <trans-unit id="2ac0e7432126a7d32cb5b22ed347524b29026575" translate="yes" xml:space="preserve">
          <source>This enables the iterator to reason about data dependency, possibly avoiding unnecessary copies.</source>
          <target state="translated">这使得迭代器能够推理数据的依赖性,可能避免不必要的拷贝。</target>
        </trans-unit>
        <trans-unit id="fb73eae3981c0a0cbcb09d6d3ccfc761b4660a9a" translate="yes" xml:space="preserve">
          <source>This example makes use of Python 3 &lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt;&lt;code&gt;concurrent.futures&lt;/code&gt;&lt;/a&gt; to fill an array using multiple threads. Threads are long-lived so that repeated calls do not require any additional overheads from thread creation.</source>
          <target state="translated">本示例使用的Python 3个&lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt; &lt;code&gt;concurrent.futures&lt;/code&gt; &lt;/a&gt;填补使用多线程的阵列。线程是长期存在的，因此重复调用不需要线程创建带来的任何额外开销。</target>
        </trans-unit>
        <trans-unit id="ff3d50ffaaf1fbc724fd92676a9a6bf2dd386440" translate="yes" xml:space="preserve">
          <source>This example makes use of Python 3 &lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt;&lt;code&gt;concurrent.futures&lt;/code&gt;&lt;/a&gt; to fill an array using multiple threads. Threads are long-lived so that repeated calls do not require any additional overheads from thread creation. The underlying BitGenerator is &lt;code&gt;PCG64&lt;/code&gt; which is fast, has a long period and supports using &lt;code&gt;PCG64.jumped&lt;/code&gt; to return a new generator while advancing the state. The random numbers generated are reproducible in the sense that the same seed will produce the same outputs.</source>
          <target state="translated">本示例使用的Python 3个&lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt; &lt;code&gt;concurrent.futures&lt;/code&gt; &lt;/a&gt;填补使用多线程的阵列。线程是长期存在的，因此重复调用不需要线程创建带来的任何额外开销。底层的BitGenerator是 &lt;code&gt;PCG64&lt;/code&gt; ，它运行速度快，周期长并且支持使用 &lt;code&gt;PCG64.jumped&lt;/code&gt; 在前进状态时返回新的生成器。在相同种子将产生相同输出的意义上，所产生的随机数是可再现的。</target>
        </trans-unit>
        <trans-unit id="40004ca036e22114daf23d8e12216a484254a12b" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;converters&lt;/code&gt; can be used to convert a field with a trailing minus sign into a negative number.</source>
          <target state="translated">本示例说明如何使用 &lt;code&gt;converters&lt;/code&gt; 将带有尾随减号的字段转换为负数。</target>
        </trans-unit>
        <trans-unit id="b788d751d6a8b5a6ea3f2e12485a26037e6ed998" translate="yes" xml:space="preserve">
          <source>This example shows how numba can be used to produce Box-Muller normals using a pure Python implementation which is then compiled. The random numbers are provided by &lt;code&gt;ctypes.next_double&lt;/code&gt;.</source>
          <target state="translated">本示例说明了如何使用numba使用纯Python实现来生成Box-Muller法线，然后将其编译。随机数由 &lt;code&gt;ctypes.next_double&lt;/code&gt; 提供。</target>
        </trans-unit>
        <trans-unit id="c43d650067bf3f7811ad3426eb67449ba8f8d778" translate="yes" xml:space="preserve">
          <source>This example shows how numba can be used to produce gaussian samples using a pure Python implementation which is then compiled. The random numbers are provided by &lt;code&gt;ctypes.next_double&lt;/code&gt;.</source>
          <target state="translated">本示例说明了如何使用numba并使用纯Python实现来生成高斯样本，然后将其编译。随机数由 &lt;code&gt;ctypes.next_double&lt;/code&gt; 提供。</target>
        </trans-unit>
        <trans-unit id="21f8a7f3cdbbf2fa9d3bdab5400251540901f919" translate="yes" xml:space="preserve">
          <source>This example shows how to create a ufunc for a structured array dtype. For the example we show a trivial ufunc for adding two arrays with dtype &amp;lsquo;u8,u8,u8&amp;rsquo;. The process is a bit different from the other examples since a call to &lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_FromFuncAndData&quot;&gt;&lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t fully register ufuncs for custom dtypes and structured array dtypes. We need to also call &lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_RegisterLoopForDescr&quot;&gt;&lt;code&gt;PyUFunc_RegisterLoopForDescr&lt;/code&gt;&lt;/a&gt; to finish setting up the ufunc.</source>
          <target state="translated">本示例说明如何为结构化数组dtype创建ufunc。对于该示例，我们展示了一个简单的ufunc，用于添加两个类型为dtype'u8，u8，u8'的数组。该过程与其他示例略有不同，因为对&lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_FromFuncAndData&quot;&gt; &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; &lt;/a&gt;的调用未完全为自定义dtype和结构化数组dtype注册ufunc。我们还需要调用&lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_RegisterLoopForDescr&quot;&gt; &lt;code&gt;PyUFunc_RegisterLoopForDescr&lt;/code&gt; &lt;/a&gt;以完成ufunc的设置。</target>
        </trans-unit>
        <trans-unit id="2f7280fcf983a91daf5dc16e89c6643dc47e38c1" translate="yes" xml:space="preserve">
          <source>This example shows that a negative value can be returned when the input is an array of signed integers.</source>
          <target state="translated">这个例子表明,当输入是一个有符号整数数组时,可以返回一个负值。</target>
        </trans-unit>
        <trans-unit id="15659709a5e32bf1f77ae2078941bf91dc0f1586" translate="yes" xml:space="preserve">
          <source>This example uses a temporary file so that doctest doesn&amp;rsquo;t write files to your directory. You would use a &amp;lsquo;normal&amp;rsquo; filename.</source>
          <target state="translated">本示例使用一个临时文件，以便doctest不会将文件写入目录。您将使用&amp;ldquo;普通&amp;rdquo;文件名。</target>
        </trans-unit>
        <trans-unit id="c6a6109259025b3790be906b9d5fd08b4a7ddd22" translate="yes" xml:space="preserve">
          <source>This explanation of &lt;code&gt;fmt&lt;/code&gt; is not complete, for an exhaustive specification see &lt;a href=&quot;#r672d4d5b6143-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">关于 &lt;code&gt;fmt&lt;/code&gt; 的解释还不完整，有关详细说明，请参见&lt;a href=&quot;#r672d4d5b6143-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6f060f066c80d886f242a9ad00dc6b69ec16949" translate="yes" xml:space="preserve">
          <source>This feature lets you make local decisions about when and how to split up streams without coordination between processes. You do not have to preallocate space to avoid overlapping or request streams from a common global service. This general &amp;ldquo;tree-hashing&amp;rdquo; scheme is &lt;a href=&quot;https://www.iro.umontreal.ca/~lecuyer/myftp/papers/parallel-rng-imacs.pdf&quot;&gt;not unique to numpy&lt;/a&gt; but not yet widespread. Python has increasingly-flexible mechanisms for parallelization available, and this scheme fits in very well with that kind of use.</source>
          <target state="translated">使用此功能，您可以在何时以及如何拆分流的情况下做出本地决策，而无需在流程之间进行协调。您不必预先分配空间来避免重叠或从通用全局服务请求流。这种通用的&amp;ldquo;树哈希&amp;rdquo;方案&lt;a href=&quot;https://www.iro.umontreal.ca/~lecuyer/myftp/papers/parallel-rng-imacs.pdf&quot;&gt;不是numpy独有的，&lt;/a&gt;但尚未普及。Python具有越来越灵活的并行化机制，该方案非常适合这种使用。</target>
        </trans-unit>
        <trans-unit id="1eaab0e05e888941195d61599512548e7a521f9d" translate="yes" xml:space="preserve">
          <source>This file contains a walkthrough of the NumPy 1.14.5 release on Linux, modified for building on azure and uploading to anaconda.org The commands can be copied into the command line, but be sure to replace 1.14.5 by the correct version.</source>
          <target state="translated">这个文件包含了Linux上NumPy 1.14.5版本的演练,为了在azure上构建和上传到anaconda.org而进行了修改,这些命令可以复制到命令行中,但一定要用正确的版本替换1.14.5。</target>
        </trans-unit>
        <trans-unit id="ce7f900d77aa58f2ad5d408dd151ca95c6ec2123" translate="yes" xml:space="preserve">
          <source>This file contains a walkthrough of the NumPy 1.19.0 release on Linux, modified for building on azure and uploading to anaconda.org The commands can be copied into the command line, but be sure to replace 1.19.0 by the correct version.</source>
          <target state="translated">这个文件包含了Linux上NumPy 1.19.0版本的演练,为了在azure上构建和上传到anaconda.org而进行了修改,这些命令可以复制到命令行中,但一定要用正确的版本替换1.19.0。</target>
        </trans-unit>
        <trans-unit id="bbd2bf0596d8530c916e2a9e88d889eff818ebc6" translate="yes" xml:space="preserve">
          <source>This file gives an overview of what is necessary to build binary releases for NumPy.</source>
          <target state="translated">这个文件给出了为NumPy构建二进制版本所需的概述。</target>
        </trans-unit>
        <trans-unit id="482a4249cfca9480f9fad090626bdeb4f2b9945b" translate="yes" xml:space="preserve">
          <source>This file is installed to the package installation directory.</source>
          <target state="translated">这个文件安装到包的安装目录。</target>
        </trans-unit>
        <trans-unit id="53df6470e0b1cc077e937e47a1974181b9abe4c8" translate="yes" xml:space="preserve">
          <source>This flag can only be used with &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; when &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt; is enabled. This is because without buffering, the inner loop is always the size of the innermost iteration dimension, and allowing it to get cut up would require special handling, effectively making it more like the buffered version.</source>
          <target state="translated">此标志只能与使用&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;时&lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt;启用。这是因为，如果没有缓冲，则内部循环始终是最内部的迭代维的大小，并且允许对其进行分割将需要进行特殊处理，从而使其更像是缓冲的版本。</target>
        </trans-unit>
        <trans-unit id="b15ae805eec5e668ba73f9b0b01c1bc16e63444d" translate="yes" xml:space="preserve">
          <source>This flag has effect only if &lt;code&gt;NPY_ITER_COPY_IF_OVERLAP&lt;/code&gt; is enabled on the iterator.</source>
          <target state="translated">仅当在迭代器上启用 &lt;code&gt;NPY_ITER_COPY_IF_OVERLAP&lt;/code&gt; 时,此标志才有效。</target>
        </trans-unit>
        <trans-unit id="9da2bfdfbda0e7663b5a969172c32a000741b205" translate="yes" xml:space="preserve">
          <source>This flag is incompatible with &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此标志与&lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt;不兼容。</target>
        </trans-unit>
        <trans-unit id="f18364f6e6e63625675c7a8e617237459cb62263" translate="yes" xml:space="preserve">
          <source>This flag is true if the underlying array is &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;. It is used to simplify calculations when possible.</source>
          <target state="translated">如果基础数组是&lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; ,&lt;/a&gt;则此标志为true 。如果可能的话，它用于简化计算。</target>
        </trans-unit>
        <trans-unit id="dded0adeb2bd9373f814af71190afe223e5d417b" translate="yes" xml:space="preserve">
          <source>This flag is true if the underlying array is &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;. It is used to simplify calculations when possible.</source>
          <target state="translated">如果基础数组是&lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; ,&lt;/a&gt;则此标志为true 。如果可能的话，它用于简化计算。</target>
        </trans-unit>
        <trans-unit id="8bd5458653c4b0d4b9801dcf72f3813b331fc2dd" translate="yes" xml:space="preserve">
          <source>This flag is useful for arrays that must be in C-contiguous order and aligned. These kinds of arrays are usually input arrays for some algorithm.</source>
          <target state="translated">这个标志对于必须以C-连续顺序排列的数组很有用。这类数组通常是某些算法的输入数组。</target>
        </trans-unit>
        <trans-unit id="174700adc5b2ef69a266d85c159fde8b55bae281" translate="yes" xml:space="preserve">
          <source>This flag is useful to specify an array that is in C-contiguous order, is aligned, and can be written to as well. Such an array is usually returned as output (although normally such output arrays are created from scratch).</source>
          <target state="translated">这个标志很有用,可以指定一个C-连续顺序的数组,它是对齐的,也可以写入。这样的数组通常作为输出返回(尽管通常这样的输出数组是从头开始创建的)。</target>
        </trans-unit>
        <trans-unit id="5677601b0eb842974f94991fa89b82f29f0accae" translate="yes" xml:space="preserve">
          <source>This flag is useful to specify an array that will be used for both input and output. &lt;a href=&quot;../reference/c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; must be called before &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; at the end of the interface routine to write back the temporary data into the original array passed in. Use of the &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags requires that the input object is already an array (because other objects cannot be automatically updated in this fashion). If an error occurs use &lt;a href=&quot;../reference/c-api/array#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt; (obj) on an array with these flags set. This will set the underlying base array writable without causing the contents to be copied back into the original array.</source>
          <target state="translated">该标志对于指定将用于输入和输出的数组很有用。&lt;a href=&quot;../reference/c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;必须之前调用&lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt; &lt;code&gt;Py_DECREF&lt;/code&gt; &lt;/a&gt;在界面例程结束到临时数据写回原始阵列英寸的使用通过&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;标志要求输入物体已经是一个阵列（因为其他对象不能被自动更新以这种方式）。如果发生错误，请在设置了这些标志的数组上使用&lt;a href=&quot;../reference/c-api/array#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt;（obj）。这将使基础基本数组设置为可写，而不会导致将内容复制回原始数组。</target>
        </trans-unit>
        <trans-unit id="e07be9168d02cb1629420a221f75d6ebada0e23c" translate="yes" xml:space="preserve">
          <source>This flag only affects writing from the buffer back to the array. This means that if the operand is also &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt;&lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt;&lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt;&lt;/a&gt;, code doing iteration can write to this operand to control which elements will be untouched and which ones will be modified. This is useful when the mask should be a combination of input masks.</source>
          <target state="translated">该标志仅影响从缓冲区写回到阵列。这意味着，如果操作数也为&lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt; &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt; &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; &lt;/a&gt;，则执行迭代的代码可以写入该操作数，以控制哪些元素将保持不变，哪些元素将被修改。当掩码应为输入掩码的组合时，这很有用。</target>
        </trans-unit>
        <trans-unit id="61e9f59feb262d0f073bfa393f7c68aa5599a46b" translate="yes" xml:space="preserve">
          <source>This form also makes it possible to specify struct dtypes with overlapping fields, functioning like the &amp;lsquo;union&amp;rsquo; type in C. This usage is discouraged, however, and the union mechanism is preferred.</source>
          <target state="translated">这种形式还可以指定具有重叠字段的struct dtype，其功能类似于C中的&amp;ldquo; union&amp;rdquo;类型。但是，不鼓励使用此方法，并且首选并集机制。</target>
        </trans-unit>
        <trans-unit id="0d302c80ebc9e23237f250ea17213abaf97a46db" translate="yes" xml:space="preserve">
          <source>This form is discouraged because Python dictionaries do not preserve order in Python versions before Python 3.6, and the order of the fields in a structured dtype has meaning. &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt; may be specified by using a 3-tuple, see below.</source>
          <target state="translated">不建议使用此格式，因为Python字典不会在Python 3.6之前的Python版本中保留顺序，并且结构化dtype中字段的顺序具有含义。&lt;a href=&quot;#titles&quot;&gt;字段标题&lt;/a&gt;可以使用三元组指定，请参见下文。</target>
        </trans-unit>
        <trans-unit id="eee7324318b68cf58364fb2712f6b7aa7bb3937e" translate="yes" xml:space="preserve">
          <source>This forms part of the old polynomial API. Since version 1.4, the new polynomial API defined in &lt;a href=&quot;../routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt; is preferred. A summary of the differences can be found in the &lt;a href=&quot;../routines.polynomials&quot;&gt;transition guide&lt;/a&gt;.</source>
          <target state="translated">这构成了旧式多项式API的一部分。从1.4版开始，首选在&lt;a href=&quot;../routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; 中&lt;/a&gt;定义的新多项式API 。差异的摘要可以在&lt;a href=&quot;../routines.polynomials&quot;&gt;过渡指南中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="55ceb45713d06ac7d3696f87a18d50201d0b6641" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;steals a reference&lt;/strong&gt; to &lt;code&gt;obj&lt;/code&gt; and sets it as the base property of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">该函数&lt;strong&gt;窃取&lt;/strong&gt;对 &lt;code&gt;obj&lt;/code&gt; &lt;strong&gt;的引用&lt;/strong&gt;，并将其设置为 &lt;code&gt;arr&lt;/code&gt; 的基本属性。</target>
        </trans-unit>
        <trans-unit id="d09c0732b811d51b99b90004b51ceb77de43b711" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;steals a reference&lt;/strong&gt; to &lt;code&gt;op&lt;/code&gt; and makes sure that &lt;code&gt;op&lt;/code&gt; is a base-class ndarray. It special cases array scalars, but otherwise calls &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;op&lt;/code&gt;, NULL, 0, 0, &lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt;&lt;/a&gt;, NULL).</source>
          <target state="translated">该函数&lt;strong&gt;窃取了&lt;/strong&gt;对 &lt;code&gt;op&lt;/code&gt; &lt;strong&gt;的引用&lt;/strong&gt;，并确保 &lt;code&gt;op&lt;/code&gt; 是基类ndarray。它在特殊情况下是数组标量，但否则调用&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;op&lt;/code&gt; ，NULL，0，0，&lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt; &lt;/a&gt;，NULL）。</target>
        </trans-unit>
        <trans-unit id="39a0c64e238756c013e69a01cf344f4e1849a8a1" translate="yes" xml:space="preserve">
          <source>This function accepts but discards arguments &lt;code&gt;bias&lt;/code&gt; and &lt;code&gt;ddof&lt;/code&gt;. This is for backwards compatibility with previous versions of this function. These arguments had no effect on the return values of the function and can be safely ignored in this and previous versions of numpy.</source>
          <target state="translated">该函数接受但丢弃参数 &lt;code&gt;bias&lt;/code&gt; 和 &lt;code&gt;ddof&lt;/code&gt; 。这是为了与该功能的先前版本向后兼容。这些参数对函数的返回值没有影响，在此版本和以前的numpy版本中可以安全地忽略它们。</target>
        </trans-unit>
        <trans-unit id="f2fa4598ed049a537ca6f0801826008a1fe6bde0" translate="yes" xml:space="preserve">
          <source>This function aims to be a fast reader for simply formatted files. The &lt;a href=&quot;numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; function provides more sophisticated handling of, e.g., lines with missing values.</source>
          <target state="translated">此功能旨在成为简单格式文件的快速阅读器。该&lt;a href=&quot;numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;功能提供了更复杂的处理，例如，与缺失值线。</target>
        </trans-unit>
        <trans-unit id="ff21c5d7fbe80ce59f5b300cd13fc6a4fc144e9d" translate="yes" xml:space="preserve">
          <source>This function allows one set of bins to be computed, and reused across multiple histograms:</source>
          <target state="translated">该功能允许计算一组信道,并在多个直方图中重复使用。</target>
        </trans-unit>
        <trans-unit id="8a2a88415c2050cb4cd9564db4ec54b1d4908d16" translate="yes" xml:space="preserve">
          <source>This function allows the user to register a 1-d loop with an already- created ufunc to be used whenever the ufunc is called with any of its input arguments as the user-defined data-type. This is needed in order to make ufuncs work with built-in data-types. The data-type must have been previously registered with the numpy system. The loop is passed in as &lt;em&gt;function&lt;/em&gt;. This loop can take arbitrary data which should be passed in as &lt;em&gt;data&lt;/em&gt;. The data-types the loop requires are passed in as &lt;em&gt;arg_types&lt;/em&gt; which must be a pointer to memory at least as large as ufunc-&amp;gt;nargs.</source>
          <target state="translated">此功能允许用户在使用任何输入参数作为用户定义的数据类型调用ufunc时，向已创建的ufunc注册一维循环。为了使ufunc与内置数据类型一起使用，这是必需的。数据类型必须事先已在numpy系统中注册。循环作为&lt;em&gt;函数&lt;/em&gt;传递。此循环可以获取应作为&lt;em&gt;data&lt;/em&gt;传递的任意&lt;em&gt;数据&lt;/em&gt;。循环所需的数据类型以&lt;em&gt;arg_types的&lt;/em&gt;形式传入，该&lt;em&gt;arg_types&lt;/em&gt;必须是至少与ufunc-&amp;gt; nargs一样大的内存指针。</target>
        </trans-unit>
        <trans-unit id="f1576babab462c2253d07a719792b0ff878bb525" translate="yes" xml:space="preserve">
          <source>This function allows you to alter the tp_str and tp_repr methods of the array object to any Python function. Thus you can alter what happens for all arrays when str(arr) or repr(arr) is called from Python. The function to be called is passed in as &lt;em&gt;op&lt;/em&gt;. If &lt;em&gt;repr&lt;/em&gt; is non-zero, then this function will be called in response to repr(arr), otherwise the function will be called in response to str(arr). No check on whether or not &lt;em&gt;op&lt;/em&gt; is callable is performed. The callable passed in to &lt;em&gt;op&lt;/em&gt; should expect an array argument and should return a string to be printed.</source>
          <target state="translated">此函数使您可以将数组对象的tp_str和tp_repr方法更改为任何Python函数。因此，当从Python调用str（arr）或repr（arr）时，您可以更改所有数组的处理方式。要调用的函数作为&lt;em&gt;op&lt;/em&gt;传入。如果&lt;em&gt;repr&lt;/em&gt;不为零，则将响应repr（arr）调用此函数，否则将响应str（arr）调用该函数。不检查&lt;em&gt;op&lt;/em&gt;是否可调用。传递给&lt;em&gt;op&lt;/em&gt;的callable 应该有一个数组参数，并且应该返回要打印的字符串。</target>
        </trans-unit>
        <trans-unit id="3bb2d31f5b88cf1b316b3ceb02135e04993b15e9" translate="yes" xml:space="preserve">
          <source>This function assigns from the old to the new array by name, so the value of a field in the output array is the value of the field with the same name in the source array. This has the effect of creating a new ndarray containing only the fields &amp;ldquo;required&amp;rdquo; by the required_dtype.</source>
          <target state="translated">此函数按名称将旧数组分配给新数组，因此输出数组中字段的值就是源数组中具有相同名称的字段的值。这具有创建仅包含required_dtype&amp;ldquo;必需&amp;rdquo;字段的新ndarray的效果。</target>
        </trans-unit>
        <trans-unit id="12c8f95658bf6b7edc09d3adda4d0c4816cea136" translate="yes" xml:space="preserve">
          <source>This function behaves like PyUFunc_RegisterLoopForType above, except that it allows the user to register a 1-d loop using PyArray_Descr objects instead of dtype type num values. This allows a 1-d loop to be registered for structured array data-dtypes and custom data-types instead of scalar data-types.</source>
          <target state="translated">这个函数与上面的PyUFunc_RegisterLoopForType类似,只是它允许用户使用PyArray_Descr对象而不是dtype类型num值来注册一个1-d循环。这允许为结构化数组数据类型和自定义数据类型而不是标量数据类型注册一个1-d循环。</target>
        </trans-unit>
        <trans-unit id="e6245a8e454db1361715a92d11f03ae0bff098bc" translate="yes" xml:space="preserve">
          <source>This function can be exponentially slow for some inputs, unless &lt;code&gt;max_work&lt;/code&gt; is set to a finite number or &lt;code&gt;MAY_SHARE_BOUNDS&lt;/code&gt;. If in doubt, use &lt;a href=&quot;numpy.may_share_memory#numpy.may_share_memory&quot;&gt;&lt;code&gt;numpy.may_share_memory&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">除非将 &lt;code&gt;max_work&lt;/code&gt; 设置为有限数或 &lt;code&gt;MAY_SHARE_BOUNDS&lt;/code&gt; ，否则对于某些输入，此函数可能会呈指数级降低。如有疑问，请改用&lt;a href=&quot;numpy.may_share_memory#numpy.may_share_memory&quot;&gt; &lt;code&gt;numpy.may_share_memory&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="71ac25efd0c9fb7e70f813509afc2d6139c57b07" translate="yes" xml:space="preserve">
          <source>This function changes the fill value of the masked array &lt;code&gt;a&lt;/code&gt; in place. If &lt;code&gt;a&lt;/code&gt; is not a masked array, the function returns silently, without doing anything.</source>
          <target state="translated">此函数在适当位置更改被遮罩数组 &lt;code&gt;a&lt;/code&gt; 的填充值。如果 &lt;code&gt;a&lt;/code&gt; 不是掩码数组，该函数将不执行任何操作而以静默方式返回。</target>
        </trans-unit>
        <trans-unit id="dc2a1bc44c01911d64ceae9284770c887ff15ab1" translate="yes" xml:space="preserve">
          <source>This function checks to see if &lt;em&gt;arr&lt;/em&gt; is a 0-dimensional array and, if so, returns the appropriate array scalar. It should be used whenever 0-dimensional arrays could be returned to Python.</source>
          <target state="translated">此函数检查&lt;em&gt;arr&lt;/em&gt;是否为0维数组，如果是，则返回适当的数组标量。只要0维数组可以返回给Python，就应该使用它。</target>
        </trans-unit>
        <trans-unit id="6e0d86a376dbbcdcd20b9ab0ced8ac2eae8ffe8a" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;N&lt;/em&gt;-dimensional discrete Fourier Transform over any number of axes in an &lt;em&gt;M&lt;/em&gt;-dimensional array by means of the Fast Fourier Transform (FFT).</source>
          <target state="translated">此函数通过快速傅立叶变换（FFT）计算&lt;em&gt;M&lt;/em&gt;维数组中任意数量轴上的&lt;em&gt;N&lt;/em&gt;维离散傅立叶变换。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f34d917f1e7128a56a07b81dc929875f904b8a8c" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;n&lt;/em&gt;-dimensional discrete Fourier Transform over any axes in an &lt;em&gt;M&lt;/em&gt;-dimensional array by means of the Fast Fourier Transform (FFT). By default, the transform is computed over the last two axes of the input array, i.e., a 2-dimensional FFT.</source>
          <target state="translated">此函数通过快速傅立叶变换（FFT）计算&lt;em&gt;M&lt;/em&gt;维数组中任何轴上的&lt;em&gt;n&lt;/em&gt;维离散傅立叶变换。默认情况下，转换是在输入数组的最后两个轴上进行的，即二维FFT。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8915bccc6bfc2e5b959f002fb985788d011a64f" translate="yes" xml:space="preserve">
          <source>This function computes the N-dimensional discrete Fourier Transform over any number of axes in an M-dimensional real array by means of the Fast Fourier Transform (FFT). By default, all axes are transformed, with the real transform performed over the last axis, while the remaining transforms are complex.</source>
          <target state="translated">该函数通过快速傅立叶变换(FFT)计算M维实数组中任意数量轴上的N维离散傅立叶变换。默认情况下,所有轴都被变换,实数变换在最后一个轴上进行,而其余的变换是复数变换。</target>
        </trans-unit>
        <trans-unit id="b8c7b22438d176337766fd2e49c4b7cfc3e07bab" translate="yes" xml:space="preserve">
          <source>This function computes the correlation as generally defined in signal processing texts:</source>
          <target state="translated">该函数计算信号处理文本中一般定义的相关度。</target>
        </trans-unit>
        <trans-unit id="cd6ec7a4da9a308e6c6acab0d22d9735b9865d50" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the 2-dimensional discrete Fourier Transform over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;ifft2(fft2(a)) == a&lt;/code&gt; to within numerical accuracy. By default, the inverse transform is computed over the last two axes of the input array.</source>
          <target state="translated">此函数通过快速傅立叶变换（FFT）计算M维数组中任意数量的轴上的二维离散傅立叶变换的逆。换句话说， &lt;code&gt;ifft2(fft2(a)) == a&lt;/code&gt; 在数值精度内。默认情况下，逆变换是在输入数组的最后两个轴上计算的。</target>
        </trans-unit>
        <trans-unit id="1a4ebaf525beaf877d17151690d3a34bb9c59baf" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the N-dimensional discrete Fourier Transform for real input over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;irfftn(rfftn(a), a.shape) == a&lt;/code&gt; to within numerical accuracy. (The &lt;code&gt;a.shape&lt;/code&gt; is necessary like &lt;code&gt;len(a)&lt;/code&gt; is for &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt;, and for the same reason.)</source>
          <target state="translated">此函数通过快速傅立叶变换（FFT）计算M维数组中任意数量轴上的实际输入的N维离散傅立叶变换的逆。换句话说， &lt;code&gt;irfftn(rfftn(a), a.shape) == a&lt;/code&gt; 在数值精度内。（ &lt;code&gt;a.shape&lt;/code&gt; 是必需的，就像 &lt;code&gt;len(a)&lt;/code&gt; 出于&lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; 一样&lt;/a&gt;，并且出于相同的原因。）</target>
        </trans-unit>
        <trans-unit id="0c7a0cee522d4ce9c957b628834b82e1d28defa5" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the N-dimensional discrete Fourier Transform over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;ifftn(fftn(a)) == a&lt;/code&gt; to within numerical accuracy. For a description of the definitions and conventions used, see &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数通过快速傅立叶变换（FFT）在M维数组中的任意数量的轴上计算N维离散傅立叶变换的逆。换句话说， &lt;code&gt;ifftn(fftn(a)) == a&lt;/code&gt; 在数值精度内。有关使用的定义和约定的描述，请参见&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2f9d73633ea8b8eb82a0685fcd08ea3505d9a66" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform of real input computed by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;. In other words, &lt;code&gt;irfft(rfft(a), len(a)) == a&lt;/code&gt; to within numerical accuracy. (See Notes below for why &lt;code&gt;len(a)&lt;/code&gt; is necessary here.)</source>
          <target state="translated">此函数计算由&lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt;计算的实际输入的一维&lt;em&gt;n&lt;/em&gt;点离散傅立叶变换的逆。换句话说， &lt;code&gt;irfft(rfft(a), len(a)) == a&lt;/code&gt; 在数值精度内。（有关为什么在这里需要 &lt;code&gt;len(a)&lt;/code&gt; 的信息,请参见下面的注释。）</target>
        </trans-unit>
        <trans-unit id="82bfb7db090395ddadcdd09fad9b5160012346cf" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier transform computed by &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;. In other words, &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; to within numerical accuracy. For a general description of the algorithm and definitions, see &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数计算由&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;计算的一维&lt;em&gt;n&lt;/em&gt;点离散傅立叶变换的逆函数。换句话说， &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; 在数值精度内。有关算法和定义的一般说明，请参见&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="35acba32b3eea01535885b216d423da5ad809ed9" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier transform computed by &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;. In other words, &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; to within numerical accuracy. For a general description of the algorithm and definitions, see &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数计算由&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;计算的一维&lt;em&gt;n&lt;/em&gt;点离散傅立叶变换的逆函数。换句话说， &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; 在数值精度内。有关算法和定义的一般说明，请参见&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad9d7d69d57ac9facd5b4f82ac6ba6f908913a31" translate="yes" xml:space="preserve">
          <source>This function computes the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform (DFT) of a real-valued array by means of an efficient algorithm called the Fast Fourier Transform (FFT).</source>
          <target state="translated">此函数通过称为快速傅里叶变换（FFT）的高效算法来计算实值数组的一维&lt;em&gt;n&lt;/em&gt;点离散傅里叶变换（DFT）。</target>
        </trans-unit>
        <trans-unit id="68ec181d19ee1190284573e044b4ba392f94f385" translate="yes" xml:space="preserve">
          <source>This function computes the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform (DFT) with the efficient Fast Fourier Transform (FFT) algorithm [CT].</source>
          <target state="translated">此函数使用高效的快速傅立叶变换（FFT）算法[CT] 计算一维&lt;em&gt;n&lt;/em&gt;点离散傅立叶变换（DFT）。</target>
        </trans-unit>
        <trans-unit id="30a498de56241e50f5fd1a10939273e87357615d" translate="yes" xml:space="preserve">
          <source>This function continues to be supported for backward compatibility, but you should prefer &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt;&lt;code&gt;moveaxis&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt;&lt;code&gt;moveaxis&lt;/code&gt;&lt;/a&gt; function was added in NumPy 1.11.</source>
          <target state="translated">继续支持此功能以实现向后兼容，但您最好选择&lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt; &lt;code&gt;moveaxis&lt;/code&gt; &lt;/a&gt;。该&lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt; &lt;code&gt;moveaxis&lt;/code&gt; &lt;/a&gt;在与NumPy 1.11添加功能。</target>
        </trans-unit>
        <trans-unit id="307209890a37b51bcd317c1d8679c25cf8cf32dc" translate="yes" xml:space="preserve">
          <source>This function creates a new neighborhood iterator from an existing iterator. The neighborhood will be computed relatively to the position currently pointed by &lt;em&gt;iter&lt;/em&gt;, the bounds define the shape of the neighborhood iterator, and the mode argument the boundaries handling mode.</source>
          <target state="translated">此函数从现有迭代器创建一个新的邻域迭代器。邻域将相对于&lt;em&gt;iter&lt;/em&gt;当前指向的位置进行计算，边界定义邻域迭代器的形状，而mode参数则是边界处理模式。</target>
        </trans-unit>
        <trans-unit id="33522609896e19e2c62ce4cc185c0f8e169d65db" translate="yes" xml:space="preserve">
          <source>This function does &lt;em&gt;not&lt;/em&gt; initialize the returned array; to do that use &lt;a href=&quot;numpy.zeros_like#numpy.zeros_like&quot;&gt;&lt;code&gt;zeros_like&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.ones_like#numpy.ones_like&quot;&gt;&lt;code&gt;ones_like&lt;/code&gt;&lt;/a&gt; instead. It may be marginally faster than the functions that do set the array values.</source>
          <target state="translated">此功能&lt;em&gt;未&lt;/em&gt;初始化返回的数组; 为此，请使用&lt;a href=&quot;numpy.zeros_like#numpy.zeros_like&quot;&gt; &lt;code&gt;zeros_like&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;numpy.ones_like#numpy.ones_like&quot;&gt; &lt;code&gt;ones_like&lt;/code&gt; &lt;/a&gt;。它可能比设置数组值的函数快一些。</target>
        </trans-unit>
        <trans-unit id="0decc5010e2e82ceb19b7a45f9d7da5f4f237524" translate="yes" xml:space="preserve">
          <source>This function does &lt;em&gt;not&lt;/em&gt; initialize the returned array; to do that use &lt;code&gt;zeros_like&lt;/code&gt; or &lt;code&gt;ones_like&lt;/code&gt; instead. It may be marginally faster than the functions that do set the array values.</source>
          <target state="translated">此功能&lt;em&gt;未&lt;/em&gt;初始化返回的数组; 为此，请使用 &lt;code&gt;zeros_like&lt;/code&gt; 或 &lt;code&gt;ones_like&lt;/code&gt; 。它可能比设置数组值的函数快一些。</target>
        </trans-unit>
        <trans-unit id="960581e2e13399cd79a7bf3c883aeb7b8d2e979d" translate="yes" xml:space="preserve">
          <source>This function does not check the contents of the input, only that the type is MaskType. In particular, this function returns False if the mask has a flexible dtype.</source>
          <target state="translated">这个函数不检查输入的内容,只检查类型是否为MaskType。特别是,如果掩码具有灵活的dtype,该函数返回False。</target>
        </trans-unit>
        <trans-unit id="0a232150acd8a12e027d94aeed56f5ff4aae9f46" translate="yes" xml:space="preserve">
          <source>This function does not enforce that the blocks lie on a fixed grid. &lt;code&gt;np.block([[a, b], [c, d]])&lt;/code&gt; is not restricted to arrays of the form:</source>
          <target state="translated">此功能不强制块位于固定的网格上。 &lt;code&gt;np.block([[a, b], [c, d]])&lt;/code&gt; 不限于以下形式的数组：</target>
        </trans-unit>
        <trans-unit id="6dc40074e04bdcad2b344dd285961cdc7ff85df9" translate="yes" xml:space="preserve">
          <source>This function does not losslessly round-trip in either direction.</source>
          <target state="translated">这个功能在两个方向上都不会无损往返。</target>
        </trans-unit>
        <trans-unit id="b71c712d42350c6a8a0c257c490e077558876dad" translate="yes" xml:space="preserve">
          <source>This function encapsulates the broadcasting rules. The &lt;em&gt;mit&lt;/em&gt; container should already contain iterators for all the arrays that need to be broadcast. On return, these iterators will be adjusted so that iteration over each simultaneously will accomplish the broadcasting. A negative number is returned if an error occurs.</source>
          <target state="translated">该功能封装了广播规则。在&lt;em&gt;麻省理工学院的&lt;/em&gt;容器应该已经包含了所有的阵列需要进行广播迭代器。返回时，将对这些迭代器进行调整，以便每个迭代器同时进行迭代将完成广播。如果发生错误，则返回负数。</target>
        </trans-unit>
        <trans-unit id="9bf48997cebca64928a72fe75ea6eb1ebc70dbfb" translate="yes" xml:space="preserve">
          <source>This function handles NaN comparisons as if NaN was a &amp;ldquo;normal&amp;rdquo; number. That is, AssertionError is not raised if both objects have NaNs in the same positions. This is in contrast to the IEEE standard on NaNs, which says that NaN compared to anything must return False.</source>
          <target state="translated">此函数处理NaN比较，就好像NaN是&amp;ldquo;正常&amp;rdquo;数字一样。也就是说，如果两个对象在相同位置都具有NaN，则不会引发AssertionError。这与NaNs的IEEE标准相反，后者说NaN与任何东西相比都必须返回False。</target>
        </trans-unit>
        <trans-unit id="b02f77dc9fbab1956d3050387654fd71594ea916" translate="yes" xml:space="preserve">
          <source>This function handles NaN comparisons as if NaN was a &amp;ldquo;normal&amp;rdquo; number. That is, no assertion is raised if both objects have NaNs in the same positions. This is in contrast to the IEEE standard on NaNs, which says that NaN compared to anything must return False.</source>
          <target state="translated">此函数处理NaN比较，就好像NaN是&amp;ldquo;正常&amp;rdquo;数字一样。也就是说，如果两个对象在相同位置都具有NaN，则不会引发任何断言。这与NaN的IEEE标准相反，后者说NaN与任何东西相比都必须返回False。</target>
        </trans-unit>
        <trans-unit id="d5f910d97d6aeb7075f641616a02d523dd4438a4" translate="yes" xml:space="preserve">
          <source>This function has been deprecated. Use randint instead.</source>
          <target state="translated">此函数已被废弃。使用randint代替。</target>
        </trans-unit>
        <trans-unit id="77fe5df00c0c7c8132af4661573c5a4cca000d13" translate="yes" xml:space="preserve">
          <source>This function has to be used with extreme care, see notes.</source>
          <target state="translated">此功能的使用要格外小心,请看说明。</target>
        </trans-unit>
        <trans-unit id="eade9f90c736ff6d6151ab5c5bf1151931416ec5" translate="yes" xml:space="preserve">
          <source>This function instead copies &amp;ldquo;by field name&amp;rdquo;, such that fields in the dst are assigned from the identically named field in the src. This applies recursively for nested structures. This is how structure assignment worked in numpy &amp;gt;= 1.6 to &amp;lt;= 1.13.</source>
          <target state="translated">相反，此函数复制&amp;ldquo;按字段名称&amp;rdquo;，以便从src中相同名称的字段分配dst中的字段。递归适用于嵌套结构。这是在numpy&amp;gt; = 1.6到&amp;lt;= 1.13中进行结构分配的方式。</target>
        </trans-unit>
        <trans-unit id="965a01bc9232ab2e9c3c470747ee3c2312761abb" translate="yes" xml:space="preserve">
          <source>This function is a compatibility alias for tobytes.</source>
          <target state="translated">这个函数是toby字节的兼容别名。</target>
        </trans-unit>
        <trans-unit id="a3014854fc3aff1db547e25e4accc358bdc45e8a" translate="yes" xml:space="preserve">
          <source>This function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.</source>
          <target state="translated">这个函数是tobytes的兼容别名。尽管它的名字叫 &quot;字节&quot;,但它返回的是字节而不是字符串。</target>
        </trans-unit>
        <trans-unit id="5bced6280c853e5763696660107e62b1e9050b26" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;mask_rowcols&lt;/code&gt; with &lt;code&gt;axis&lt;/code&gt; equal to 0.</source>
          <target state="translated">此功能的快捷方式 &lt;code&gt;mask_rowcols&lt;/code&gt; 与 &lt;code&gt;axis&lt;/code&gt; 等于0。</target>
        </trans-unit>
        <trans-unit id="892aad8c63a29b7082fcd31d81f9eafb9d342e8e" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;mask_rowcols&lt;/code&gt; with &lt;code&gt;axis&lt;/code&gt; equal to 1.</source>
          <target state="translated">此功能的快捷方式 &lt;code&gt;mask_rowcols&lt;/code&gt; 与 &lt;code&gt;axis&lt;/code&gt; 等于1。</target>
        </trans-unit>
        <trans-unit id="ebac1dd8653756fd79c832147de01fce0d7f87ae" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x != value).</source>
          <target state="translated">该函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =（x！=值）。</target>
        </trans-unit>
        <trans-unit id="ab411b054ab6959d52991c7253cba72df24e6757" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;gt; value).</source>
          <target state="translated">此函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =（x&amp;gt;值）。</target>
        </trans-unit>
        <trans-unit id="bf30dbf11727720fe8d30e29bf375cde077485f8" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;gt;= value).</source>
          <target state="translated">此函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =（x&amp;gt; =值）。</target>
        </trans-unit>
        <trans-unit id="af1053b8f0ec97d05015f270566c5b82959272a7" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;lt; value).</source>
          <target state="translated">该函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =（x &amp;lt;值）。</target>
        </trans-unit>
        <trans-unit id="f9189002c6a19182c690d1c6efc00b46a33f7232" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;lt;= value).</source>
          <target state="translated">该函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =（x &amp;lt;=值）。</target>
        </trans-unit>
        <trans-unit id="f46637928627180e5c802e1527edd637c13a58b6" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x == value). For floating point arrays, consider using &lt;code&gt;masked_values(x, value)&lt;/code&gt;.</source>
          <target state="translated">此函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =（x ==值）。对于浮点数组，请考虑使用 &lt;code&gt;masked_values(x, value)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4434dee55a64bbfebaafbec40077ada7cc2e4b4" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = ~(np.isfinite(a)). Any pre-existing mask is conserved. Only applies to arrays with a dtype where NaNs or infs make sense (i.e. floating point types), but accepts any array_like object.</source>
          <target state="translated">此函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =〜（np.isfinite（a））。保留任何先前存在的掩码。仅适用于具有NaN或infs有意义的dtype的数组（即浮点类型），但可以接受任何array_like对象。</target>
        </trans-unit>
        <trans-unit id="f28b126f5c6b2ce96d11bc92753f383ad4cd6485" translate="yes" xml:space="preserve">
          <source>This function is able to return one of eight different matrix norms, or one of an infinite number of vector norms (described below), depending on the value of the &lt;code&gt;ord&lt;/code&gt; parameter.</source>
          <target state="translated">根据 &lt;code&gt;ord&lt;/code&gt; 参数的值，此函数能够返回八个不同的矩阵范数之一，或无穷多个矢量范数之一（如下所述）。</target>
        </trans-unit>
        <trans-unit id="c1758140bc8fa9fd28fc8bc131c3f6321c42d5db" translate="yes" xml:space="preserve">
          <source>This function is capable of returning the condition number using one of seven different norms, depending on the value of &lt;code&gt;p&lt;/code&gt; (see Parameters below).</source>
          <target state="translated">此函数能够使用七个不同规范之一返回条件编号，具体取决于 &lt;code&gt;p&lt;/code&gt; 的值（请参见下面的参数）。</target>
        </trans-unit>
        <trans-unit id="7f257a627b846a11d8d82d4b0986234672c8d024" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;a href=&quot;#numpy.ma.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; except that masked values are treated as equal (default) or unequal, depending on the &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt;&lt;code&gt;masked_equal&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">此函数等效于&lt;a href=&quot;#numpy.ma.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; ,&lt;/a&gt;不同之处在于，根据&lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt; &lt;code&gt;masked_equal&lt;/code&gt; &lt;/a&gt;参数，将掩码值视为相等（默认值）或不相等。</target>
        </trans-unit>
        <trans-unit id="dd8713725fce28207d278a6136fdd184217d0bb8" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;a href=&quot;numpy.allclose#numpy.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; except that masked values are treated as equal (default) or unequal, depending on the &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt;&lt;code&gt;masked_equal&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">此函数等效于&lt;a href=&quot;numpy.allclose#numpy.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; ,&lt;/a&gt;不同之处在于，根据&lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt; &lt;code&gt;masked_equal&lt;/code&gt; &lt;/a&gt;参数，将掩码值视为相等（默认值）或不相等。</target>
        </trans-unit>
        <trans-unit id="a3debc8695bd72584953abb12e719fb90548f7dd" translate="yes" xml:space="preserve">
          <source>This function is equivalent to calling the &amp;ldquo;compressed&amp;rdquo; method of a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt;&lt;code&gt;MaskedArray.compressed&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">此函数等效于调用&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;的&amp;ldquo; compressed&amp;rdquo;方法，有关详细信息，请参见&lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt; &lt;code&gt;MaskedArray.compressed&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5a91f899ffc50b531674413c041bb92c6104a7d" translate="yes" xml:space="preserve">
          <source>This function is equivalent to calling the &amp;ldquo;compressed&amp;rdquo; method of a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;ma.MaskedArray&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt;&lt;code&gt;ma.MaskedArray.compressed&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">此函数等效于调用&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;ma.MaskedArray&lt;/code&gt; &lt;/a&gt;的&amp;ldquo; compressed&amp;rdquo;方法，有关详细信息，请参见&lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt; &lt;code&gt;ma.MaskedArray.compressed&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="614f9af44de8bf025b95f7feb6cfbfad93376ecb" translate="yes" xml:space="preserve">
          <source>This function is equivalent to tuple axis arguments to reorderable ufuncs with keepdims=True. Tuple axis arguments to ufuncs have been available since version 1.7.0.</source>
          <target state="translated">这个函数相当于keepdims=True的可重排序ufuncs的元组轴参数。从1.7.0版本开始,ufuncs的元组轴参数就可以使用了。</target>
        </trans-unit>
        <trans-unit id="3c5d87f95304bba4f22f4f3bc79a0366620caeda" translate="yes" xml:space="preserve">
          <source>This function is exactly equivalent to &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;numpy.transpose&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数与&lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;numpy.transpose&lt;/code&gt; &lt;/a&gt;完全等效。</target>
        </trans-unit>
        <trans-unit id="0a042d76cb2129f19b61e5085381910d8b99bdbc" translate="yes" xml:space="preserve">
          <source>This function is intended to be used in EXTERNAL_LOOP mode only, and will produce some wrong answers when that mode is not enabled.</source>
          <target state="translated">该函数仅用于EXTERNAL_LOOP模式,当该模式未启用时,会产生一些错误的答案。</target>
        </trans-unit>
        <trans-unit id="d3aeb8a347cc701a9fec8946ae6c740c1103bc20" translate="yes" xml:space="preserve">
          <source>This function is not defined for complex-valued arguments; for the so-called argument of complex values, use &lt;a href=&quot;numpy.angle#numpy.angle&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">未为复数值参数定义此函数；对于所谓的复数参数，请使用&lt;a href=&quot;numpy.angle#numpy.angle&quot;&gt; &lt;code&gt;angle&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42c780622358a45155401477993b5d9d0b335549" translate="yes" xml:space="preserve">
          <source>This function is not designed to work with integers.</source>
          <target state="translated">这个函数不是设计用来处理整数的。</target>
        </trans-unit>
        <trans-unit id="ea62cc16ec217ef39d7f7c8e5969148da37fd3a3" translate="yes" xml:space="preserve">
          <source>This function is not implemented yet.</source>
          <target state="translated">这个功能还没有实现。</target>
        </trans-unit>
        <trans-unit id="b2f9356116ad7b6b9ba74a0d07b768457fca53e0" translate="yes" xml:space="preserve">
          <source>This function is obsolete and, because of changes due to relaxed stride checking, its return value for the same array may differ for versions of NumPy &amp;gt;= 1.10.0 and previous versions. If you only want to check if an array is Fortran contiguous use &lt;code&gt;a.flags.f_contiguous&lt;/code&gt; instead.</source>
          <target state="translated">此函数已过时，并且由于宽松的步幅检查导致的更改，对于NumPy&amp;gt; = 1.10.0的版本和以前的版本，同一数组的返回值可能会有所不同。如果只想检查数组是否为Fortran连续数组，请改用 &lt;code&gt;a.flags.f_contiguous&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="258358cbdd467c9c344ce8e3f9c85d0cd7f428e4" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt;&lt;code&gt;masked_values&lt;/code&gt;&lt;/a&gt;, but only suitable for object arrays: for floating point, use &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt;&lt;code&gt;masked_values&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此函数类似于&lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt; &lt;code&gt;masked_values&lt;/code&gt; &lt;/a&gt;，但仅适用于对象数组：对于浮点，请改用&lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt; &lt;code&gt;masked_values&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42e4240c2bc84555a7f741757d674e8c82e565ad" translate="yes" xml:space="preserve">
          <source>This function is superceded by &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数由&lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; &lt;/a&gt;和/或&lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; &lt;/a&gt;取代。</target>
        </trans-unit>
        <trans-unit id="f3e20de601f3ca24a5ff2472df08d779de8dd632" translate="yes" xml:space="preserve">
          <source>This function is superceded by &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数由&lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; &lt;/a&gt;取代。</target>
        </trans-unit>
        <trans-unit id="223dd6fd50941f5cca2c485c95e8e5dc687d05fb" translate="yes" xml:space="preserve">
          <source>This function is superseded by &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数由&lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; &lt;/a&gt;和/或&lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; &lt;/a&gt;取代。</target>
        </trans-unit>
        <trans-unit id="cc0b6a66579ee7b8e064413a2fb5429da45dba58" translate="yes" xml:space="preserve">
          <source>This function is superseded by &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数已被&lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; &lt;/a&gt;取代。</target>
        </trans-unit>
        <trans-unit id="5b1ff7898f391050d07732317e1b4b4bc976ee58" translate="yes" xml:space="preserve">
          <source>This function is symmetric, but rarely associative.</source>
          <target state="translated">这个函数是对称的,但很少有关联的。</target>
        </trans-unit>
        <trans-unit id="fb34e601302a103a0946045a1719e9ad4309bf62" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;numpy.diag&lt;/code&gt;&lt;/a&gt; that takes masked values into account, see &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;numpy.diag&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">此函数等效于&lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;numpy.diag&lt;/code&gt; &lt;/a&gt;，它考虑了掩码值，有关详细信息，请参见&lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;numpy.diag&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="762735a831cc238bcd6be4852c06ac0013225a54" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.dot#numpy.dot&quot;&gt;&lt;code&gt;numpy.dot&lt;/code&gt;&lt;/a&gt; that takes masked values into account. Note that &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; are in different position than in the method version. In order to maintain compatibility with the corresponding method, it is recommended that the optional arguments be treated as keyword only. At some point that may be mandatory.</source>
          <target state="translated">此函数等效于&lt;a href=&quot;numpy.dot#numpy.dot&quot;&gt; &lt;code&gt;numpy.dot&lt;/code&gt; &lt;/a&gt;，它考虑了掩码值。请注意， &lt;code&gt;strict&lt;/code&gt; 和 &lt;code&gt;out&lt;/code&gt; 与方法版本中的位置不同。为了保持与相应方法的兼容性，建议将可选参数仅视为关键字。在某些时候这可能是强制性的。</target>
        </trans-unit>
        <trans-unit id="b3449fce446ccae1d5ae6c6d55107b82701f20fd" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt;&lt;code&gt;numpy.ediff1d&lt;/code&gt;&lt;/a&gt; that takes masked values into account, see &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt;&lt;code&gt;numpy.ediff1d&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">此函数等效于&lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt; &lt;code&gt;numpy.ediff1d&lt;/code&gt; &lt;/a&gt;，其中将掩码值考虑在内，有关详细信息，请参见&lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt; &lt;code&gt;numpy.ediff1d&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc125d9cdb2114a10df5933b4e6f500d1c08539d" translate="yes" xml:space="preserve">
          <source>This function is used to simplify access to fields nested in other fields.</source>
          <target state="translated">该函数用于简化对嵌套在其他字段中的字段的访问。</target>
        </trans-unit>
        <trans-unit id="48492051f92b9e0c98dfd72175da1464af62c22d" translate="yes" xml:space="preserve">
          <source>This function is useful for calculating a fill value suitable for taking the maximum of an array with a given dtype.</source>
          <target state="translated">这个函数对于计算一个适合于取一个给定dtype的数组的最大值的填充值很有用。</target>
        </trans-unit>
        <trans-unit id="eeb9d1e68f6032230d3ff5e76ccad6bac584a6b3" translate="yes" xml:space="preserve">
          <source>This function is useful for calculating a fill value suitable for taking the minimum of an array with a given dtype.</source>
          <target state="translated">这个函数对于计算一个适合于取一个给定dtype的数组的最小值的填充值很有用。</target>
        </trans-unit>
        <trans-unit id="514144ea48299b81c7b15dfcf631d31668bd3186" translate="yes" xml:space="preserve">
          <source>This function is useful for determining a common type that two or more arrays can be converted to. It only works for non-flexible array types as no itemsize information is passed. The &lt;em&gt;mintype&lt;/em&gt; argument represents the minimum type acceptable, and &lt;em&gt;op&lt;/em&gt; represents the object that will be converted to an array. The return value is the enumerated typenumber that represents the data-type that &lt;em&gt;op&lt;/em&gt; should have.</source>
          <target state="translated">此功能对于确定可以将两个或多个数组转换为的通用类型很有用。它仅适用于非灵活数组类型，因为没有传递项目大小信息。所述&lt;em&gt;mintype&lt;/em&gt;参数表示的最低可接受的类型，和&lt;em&gt;运算&lt;/em&gt;表示将被转换为一个数组的对象。返回值是枚举的类型编号，表示&lt;em&gt;op&lt;/em&gt;应该具有的数据类型。</target>
        </trans-unit>
        <trans-unit id="66ea2fa9dfd3553ca39f3787970de46499229028" translate="yes" xml:space="preserve">
          <source>This function is useful to be sure that an array with the correct flags is returned for passing to compiled code (perhaps through ctypes).</source>
          <target state="translated">这个函数很有用,可以确保返回一个带有正确标志的数组,以便传递给编译后的代码(也许通过ctypes)。</target>
        </trans-unit>
        <trans-unit id="8e9b1bcfe6f895f9426e7973caf7f080e53d5b02" translate="yes" xml:space="preserve">
          <source>This function is very similar to &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; above, but has an extra &lt;em&gt;identity_value&lt;/em&gt; argument, to define an arbitrary identity for the ufunc when &lt;code&gt;identity&lt;/code&gt; is passed as &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;.</source>
          <target state="translated">此函数与上面的 &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; 非常相似，但是具有一个额外的&lt;em&gt;identity_value&lt;/em&gt;参数，用于在将 &lt;code&gt;identity&lt;/code&gt; 作为 &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; 传递时定义ufunc的任意身份。</target>
        </trans-unit>
        <trans-unit id="e6ae878f05630a69160b11c652744c88c73b83f7" translate="yes" xml:space="preserve">
          <source>This function is very similar to PyUFunc_FromFuncAndData above, but has an extra &lt;em&gt;signature&lt;/em&gt; argument, to define a &lt;a href=&quot;c-api.generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;generalized universal functions&lt;/a&gt;. Similarly to how ufuncs are built around an element-by-element operation, gufuncs are around subarray-by-subarray operations, the &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; defining the subarrays to operate on.</source>
          <target state="translated">该函数与上面的PyUFunc_FromFuncAndData非常相似，但是具有一个额外的&lt;em&gt;签名&lt;/em&gt;参数，以定义&lt;a href=&quot;c-api.generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;通用的通用函数&lt;/a&gt;。与如何在逐个元素的操作周围构建ufunc相似，gufuncs围绕每个子数组操作（&lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;签名&lt;/a&gt;定义要对其进行操作的子数组）。</target>
        </trans-unit>
        <trans-unit id="7d7c3c059d66b50ac25de48e14a9110e6ed62010" translate="yes" xml:space="preserve">
          <source>This function is very similar to PyUFunc_FromFuncAndData above, but has an extra &lt;em&gt;signature&lt;/em&gt; argument, to define a &lt;a href=&quot;generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;generalized universal functions&lt;/a&gt;. Similarly to how ufuncs are built around an element-by-element operation, gufuncs are around subarray-by-subarray operations, the &lt;a href=&quot;generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; defining the subarrays to operate on.</source>
          <target state="translated">该函数与上面的PyUFunc_FromFuncAndData非常相似，但是具有一个额外的&lt;em&gt;签名&lt;/em&gt;参数，以定义&lt;a href=&quot;generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;通用的通用函数&lt;/a&gt;。与如何在逐个元素的操作周围构建ufunc相似，gufuncs围绕每个子数组一个子数组操作，&lt;a href=&quot;generalized-ufuncs#details-of-signature&quot;&gt;签名&lt;/a&gt;定义了要对其进行操作的子数组。</target>
        </trans-unit>
        <trans-unit id="0dc77b4e140ac75bc9ac3e89d41f38fc73185d22" translate="yes" xml:space="preserve">
          <source>This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.stack#numpy.stack&quot;&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.block#numpy.block&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; provide more general stacking and concatenation operations.</source>
          <target state="translated">此功能对于最多3维的数组最有意义。例如，对于具有高度（第一轴），宽度（第二轴）和r / g / b通道（第三轴）的像素数据。函数&lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.stack#numpy.stack&quot;&gt; &lt;code&gt;stack&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.block#numpy.block&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt;提供更多常规的堆叠和串联操作。</target>
        </trans-unit>
        <trans-unit id="f7b019770de00d4d47b09eabe135d2ae721a995a" translate="yes" xml:space="preserve">
          <source>This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions &lt;a href=&quot;numpy.ma.concatenate#numpy.ma.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.ma.stack#numpy.ma.stack&quot;&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;block&lt;/code&gt; provide more general stacking and concatenation operations.</source>
          <target state="translated">此功能对于最多3维的数组最有意义。例如，对于具有高度（第一轴），宽度（第二轴）和r / g / b通道（第三轴）的像素数据。函数&lt;a href=&quot;numpy.ma.concatenate#numpy.ma.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.ma.stack#numpy.ma.stack&quot;&gt; &lt;code&gt;stack&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;block&lt;/code&gt; 提供更多常规的堆叠和串联操作。</target>
        </trans-unit>
        <trans-unit id="f15e5fa1742619380116b3f34a00c85d55366c55" translate="yes" xml:space="preserve">
          <source>This function may also be used as a decorator.</source>
          <target state="translated">此功能也可作为装饰器使用。</target>
        </trans-unit>
        <trans-unit id="d585b637d27940cc37d90ebf4940a9aa2e521b5d" translate="yes" xml:space="preserve">
          <source>This function may be safely called without holding the Python GIL.</source>
          <target state="translated">这个函数可以在不持有Python GIL的情况下安全调用。</target>
        </trans-unit>
        <trans-unit id="cd200e9dfe3f17be99d159e426b6fa9331db61ec" translate="yes" xml:space="preserve">
          <source>This function may only be called if the iterator is tracking a multi-index and if &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt;&lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt;&lt;/a&gt; was used to prevent an axis from being iterated in reverse order.</source>
          <target state="translated">仅当迭代器正在跟踪多索引并且使用&lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt; &lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt; &lt;/a&gt;来防止以相反的顺序迭代轴时，才可以调用此函数。</target>
        </trans-unit>
        <trans-unit id="6ca18036fbf762cae2043baf8ac3fa8494d28495" translate="yes" xml:space="preserve">
          <source>This function must be called in the initialization section of a module that will make use of the C-API. It imports the module where the function-pointer table is stored and points the correct variable to it.</source>
          <target state="translated">这个函数必须在一个将使用C-API的模块的初始化部分被调用。它导入存储函数指针表的模块,并将正确的变量指向它。</target>
        </trans-unit>
        <trans-unit id="cf5ee49acb54388d21032f90f2de16dca9ddb6c3" translate="yes" xml:space="preserve">
          <source>This function must take two arguments, &lt;code&gt;func(a, axis)&lt;/code&gt;.</source>
          <target state="translated">此函数必须 &lt;code&gt;func(a, axis)&lt;/code&gt; 两个参数func（a，axis）。</target>
        </trans-unit>
        <trans-unit id="dba1259c24481a4a54d81a8fdecff9fadce8f02f" translate="yes" xml:space="preserve">
          <source>This function only shuffles the array along the first axis of a multi-dimensional array. The order of sub-arrays is changed but their contents remains the same.</source>
          <target state="translated">这个函数只是沿着多维数组的第一轴对数组进行洗牌。子数组的顺序被改变,但其内容保持不变。</target>
        </trans-unit>
        <trans-unit id="68ca7042b267a7f2923f8a89cc886956d3a640a1" translate="yes" xml:space="preserve">
          <source>This function provides greater precision than &lt;code&gt;exp(x) - 1&lt;/code&gt; for small values of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">对于较小的 &lt;code&gt;x&lt;/code&gt; ,此函数提供的精度比 &lt;code&gt;exp(x) - 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40a3f0ad0a26c2dcd1667ccf5fd0beae55099939" translate="yes" xml:space="preserve">
          <source>This function reads from the system entropy pool and so samples are not reproducible. In particular, it does &lt;em&gt;NOT&lt;/em&gt; make use of a BitGenerator, and so &lt;code&gt;seed&lt;/code&gt; and setting &lt;code&gt;state&lt;/code&gt; have no effect.</source>
          <target state="translated">此函数从系统熵池中读取数据，因此样本不可重现。特别是，它&lt;em&gt;不是&lt;/em&gt;利用一个BitGenerator的，所以 &lt;code&gt;seed&lt;/code&gt; 和设置 &lt;code&gt;state&lt;/code&gt; 没有任何效果。</target>
        </trans-unit>
        <trans-unit id="2db0a89599aa1f9e0af20f69fdc08455be79db8b" translate="yes" xml:space="preserve">
          <source>This function returns True if &lt;code&gt;x&lt;/code&gt; is an instance of MaskedArray and returns False otherwise. Any object is accepted as input.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是MaskedArray的实例，则此函数返回True ，否则返回False。任何对象都可以接受作为输入。</target>
        </trans-unit>
        <trans-unit id="326a3290cbe737031cbcfe2c255c104d77bb6d98" translate="yes" xml:space="preserve">
          <source>This function returns a (C-style) contiguous and behaved function array from any nested sequence or array interface exporting object, &lt;em&gt;op&lt;/em&gt;, of (non-flexible) type given by the enumerated &lt;em&gt;typenum&lt;/em&gt;, of minimum depth &lt;em&gt;min_depth&lt;/em&gt;, and of maximum depth &lt;em&gt;max_depth&lt;/em&gt;. Equivalent to a call to &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; with requirements set to &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; and the type_num member of the type argument set to &lt;em&gt;typenum&lt;/em&gt;.</source>
          <target state="translated">此函数从枚举&lt;em&gt;typenum&lt;/em&gt;给出的（非灵活）类型，最小深度&lt;em&gt;min_depth&lt;/em&gt;和最大深度&lt;em&gt;max_depth的&lt;/em&gt;任何嵌套序列或数组接口导出对象&lt;em&gt;op&lt;/em&gt;返回一个（C风格）连续且行为良好的函数数组。等效于对&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;的调用，其要求设置为&lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; ,&lt;/a&gt;并且类型参数的type_num成员设置为&lt;em&gt;typenum&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd99a05c88fddf54e9c57ac9cd52857632e3d1f8" translate="yes" xml:space="preserve">
          <source>This function returns a boolean ndarray with all entries False, that can be used in common mask manipulations. If a complex dtype is specified, the type of each field is converted to a boolean type.</source>
          <target state="translated">该函数返回一个布尔型ndarray,所有条目均为False,可用于常见的掩码操作。如果指定了复杂的dtype,则每个字段的类型会被转换为布尔类型。</target>
        </trans-unit>
        <trans-unit id="02eca326759cd81f17376a545937c3d2382a2a50" translate="yes" xml:space="preserve">
          <source>This function returns a well-behaved C-style contiguous array from any nested sequence or array-interface exporting object. The minimum number of dimensions the array can have is given by &lt;code&gt;min_depth&lt;/code&gt; while the maximum is &lt;code&gt;max_depth&lt;/code&gt;. This is equivalent to call &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; with requirements &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数从任何嵌套序列或数组接口导出对象返回行为良好的C样式连续数组。数组可以具有的最小维数由 &lt;code&gt;min_depth&lt;/code&gt; 给出，而最大值为 &lt;code&gt;max_depth&lt;/code&gt; 。这相当于调用&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;符合要求&lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5e7626c8e43009c9d0e23e7f2d941b6cb967b32" translate="yes" xml:space="preserve">
          <source>This function returns the absolute values (positive magnitude) of the data in &lt;code&gt;x&lt;/code&gt;. Complex values are not handled, use &lt;a href=&quot;numpy.absolute#numpy.absolute&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; to find the absolute values of complex data.</source>
          <target state="translated">此函数返回 &lt;code&gt;x&lt;/code&gt; 中数据的绝对值（正值）。不处理复杂值，请使用&lt;a href=&quot;numpy.absolute#numpy.absolute&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt;查找复杂数据的绝对值。</target>
        </trans-unit>
        <trans-unit id="89fee3e999f1c558b74709781bf21911d5dc8fa4" translate="yes" xml:space="preserve">
          <source>This function returns the value</source>
          <target state="translated">该函数返回值</target>
        </trans-unit>
        <trans-unit id="1cc55e517c256ea42c557b8b54e3efb3b6cafcb6" translate="yes" xml:space="preserve">
          <source>This function returns the values:</source>
          <target state="translated">该函数返回值。</target>
        </trans-unit>
        <trans-unit id="a6d07b33b778389f427bd3ca9fc11f04feb25982" translate="yes" xml:space="preserve">
          <source>This function should accept 1-D arrays. It is applied to 1-D slices of &lt;code&gt;arr&lt;/code&gt; along the specified axis.</source>
          <target state="translated">此函数应接受一维数组。它将沿指定轴应用于 &lt;code&gt;arr&lt;/code&gt; 的一维切片。</target>
        </trans-unit>
        <trans-unit id="5cfabdc0232ab8cc8ac575fbc0d4dec6b2dd7bf7" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;arr&lt;/em&gt;.</source>
          <target state="translated">该函数窃取了对&lt;em&gt;arr&lt;/em&gt;的引用。</target>
        </trans-unit>
        <trans-unit id="3ceff3d1be740072d08fa441617d883813e56f19" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt; if it is not NULL.</source>
          <target state="translated">如果该函数不为NULL，则它将窃取对&lt;em&gt;descr&lt;/em&gt;的引用。</target>
        </trans-unit>
        <trans-unit id="37fa48e8e102e5c7fe97151e437a12d635c87f86" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt; if it is not NULL. This array creation routine allows for the convenient creation of a new array matching an existing array&amp;rsquo;s shapes and memory layout, possibly changing the layout and/or data type.</source>
          <target state="translated">如果该函数不为NULL，则该函数将窃取对&lt;em&gt;descr&lt;/em&gt;的引用。该数组创建例程可方便地创建与现有数组的形状和内存布局匹配的新数组，并可能更改布局和/或数据类型。</target>
        </trans-unit>
        <trans-unit id="8281b58eb98855581eef0364cfa182f403baf433" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="translated">该函数窃取了对&lt;em&gt;descr&lt;/em&gt;的引用。</target>
        </trans-unit>
        <trans-unit id="71bb778b3ae86d2314883f6bdb50a6590499183c" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt;. The easiest way to get one is using &lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数窃取了对&lt;em&gt;descr&lt;/em&gt;的引用。最简单的方法是使用&lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6d42633714a13d2a78f3f69e93cf9d52e8a857e" translate="yes" xml:space="preserve">
          <source>This function supports both indexing conventions through the indexing keyword argument. Giving the string &amp;lsquo;ij&amp;rsquo; returns a meshgrid with matrix indexing, while &amp;lsquo;xy&amp;rsquo; returns a meshgrid with Cartesian indexing. In the 2-D case with inputs of length M and N, the outputs are of shape (N, M) for &amp;lsquo;xy&amp;rsquo; indexing and (M, N) for &amp;lsquo;ij&amp;rsquo; indexing. In the 3-D case with inputs of length M, N and P, outputs are of shape (N, M, P) for &amp;lsquo;xy&amp;rsquo; indexing and (M, N, P) for &amp;lsquo;ij&amp;rsquo; indexing. The difference is illustrated by the following code snippet:</source>
          <target state="translated">此函数通过indexing关键字参数支持两种索引约定。给定字符串&amp;ldquo; ij&amp;rdquo;将返回带有矩阵索引的网格，而&amp;ldquo; xy&amp;rdquo;将返回带有笛卡尔索引的网格。在输入长度为M和N的2-D情况下，对于&amp;ldquo; xy&amp;rdquo;索引，输出的形状为（N，M），对于&amp;ldquo; ij&amp;rdquo;索引，输出的形状为（M，N）。在输入长度为M，N和P的3-D情况下，对于&amp;ldquo; xy&amp;rdquo;索引，输出的形状为（N，M，P），对于&amp;ldquo; ij&amp;rdquo;索引的输出的形状为（M，N，P）。以下代码片段说明了这种差异：</target>
        </trans-unit>
        <trans-unit id="e857d76db9c7bac209f1715cec1437cf523540d8" translate="yes" xml:space="preserve">
          <source>This function swaps half-spaces for all axes listed (defaults to all). Note that &lt;code&gt;y[0]&lt;/code&gt; is the Nyquist component only if &lt;code&gt;len(x)&lt;/code&gt; is even.</source>
          <target state="translated">此功能为列出的所有轴交换半角空格（默认为全部）。注意，仅当 &lt;code&gt;len(x)&lt;/code&gt; 为偶数时， &lt;code&gt;y[0]&lt;/code&gt; 是奈奎斯特分量。</target>
        </trans-unit>
        <trans-unit id="a7870153b27cca4d6c02a86ec8c830b616e4b3c3" translate="yes" xml:space="preserve">
          <source>This function takes N 1-D sequences and returns N outputs with N dimensions each, such that the shape is 1 in all but one dimension and the dimension with the non-unit shape value cycles through all N dimensions.</source>
          <target state="translated">这个函数接收N个1-D序列,并返回N个输出,每个输出有N个维度,这样除了一个维度外,其他维度的形状都是1,并且非单位形状值的维度在所有N个维度中循环。</target>
        </trans-unit>
        <trans-unit id="b4e43f62f7a361a5fb222fc70fbd3c26bd5104e6" translate="yes" xml:space="preserve">
          <source>This function takes a multi-iterator object that has been previously &amp;ldquo;broadcasted,&amp;rdquo; finds the dimension with the smallest &amp;ldquo;sum of strides&amp;rdquo; in the broadcasted result and adapts all the iterators so as not to iterate over that dimension (by effectively making them of length-1 in that dimension). The corresponding dimension is returned unless &lt;em&gt;mit&lt;/em&gt; -&amp;gt;nd is 0, then -1 is returned. This function is useful for constructing ufunc-like routines that broadcast their inputs correctly and then call a strided 1-d version of the routine as the inner-loop. This 1-d version is usually optimized for speed and for this reason the loop should be performed over the axis that won&amp;rsquo;t require large stride jumps.</source>
          <target state="translated">此函数采用一个先前已&amp;ldquo;广播&amp;rdquo;的多迭代器对象，在广播结果中找到具有最小&amp;ldquo;步长和&amp;rdquo;的维度，并调整所有迭代器，以免在该维度上进行迭代（通过有效地使它们成为该尺寸的长度为1）。除非&lt;em&gt;mit-&lt;/em&gt; &amp;gt; nd为0，否则返回相应的维，然后返回-1。此函数对于构造类似ufunc的例程非常有用，这些例程可以正确广播其输入，然后将该例程的跨步1-d版本称为内部循环。通常针对速度优化此一维版本，因此，应在不需要大步幅跳动的轴上执行循环。</target>
        </trans-unit>
        <trans-unit id="102958a161ae2e87757cf73f96956c3988a66269" translate="yes" xml:space="preserve">
          <source>This function uses the same algorithm as the builtin python &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_left&quot;&gt;&lt;code&gt;bisect.bisect_left&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;side='left'&lt;/code&gt;) and &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_right&quot;&gt;&lt;code&gt;bisect.bisect_right&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;side='right'&lt;/code&gt;) functions, which is also vectorized in the &lt;code&gt;v&lt;/code&gt; argument.</source>
          <target state="translated">该函数使用与内置python &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_left&quot;&gt; &lt;code&gt;bisect.bisect_left&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;side='left'&lt;/code&gt; ）和&lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_right&quot;&gt; &lt;code&gt;bisect.bisect_right&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;side='right'&lt;/code&gt; ）函数相同的算法，它们也在 &lt;code&gt;v&lt;/code&gt; 参数中向量化。</target>
        </trans-unit>
        <trans-unit id="f4a094c15ea96c9120e1bb02da934b3ab9299caa" translate="yes" xml:space="preserve">
          <source>This function will not demote complex to float or anything to boolean, but will demote a signed integer to an unsigned integer when the scalar value is positive.</source>
          <target state="translated">这个函数不会将复数降级为float,也不会将任何东西降级为boolean,但会在标量值为正值时将有符号整数降级为无符号整数。</target>
        </trans-unit>
        <trans-unit id="e431cb683c0bc7c35e7633e888e952e4559756e5" translate="yes" xml:space="preserve">
          <source>This function will not preserve masking of MaskedArray inputs.</source>
          <target state="translated">这个函数不会保留MaskedArray输入的掩码。</target>
        </trans-unit>
        <trans-unit id="2a9b1f287c173d330577d2300449ee4dfd3daa91" translate="yes" xml:space="preserve">
          <source>This function works on subclasses of ndarray like &lt;a href=&quot;numpy.ma.array#numpy.ma.array&quot;&gt;&lt;code&gt;ma.array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数适用于ndarray的子​​类，如&lt;a href=&quot;numpy.ma.array#numpy.ma.array&quot;&gt; &lt;code&gt;ma.array&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6a52abd835e7532e9891ffc574fd5f4220e58bc" translate="yes" xml:space="preserve">
          <source>This function works similarly to &lt;a href=&quot;#c.PyArray_ObjectType&quot;&gt;&lt;code&gt;PyArray_ObjectType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) except it handles flexible arrays. The &lt;em&gt;mintype&lt;/em&gt; argument can have an itemsize member and the &lt;em&gt;outtype&lt;/em&gt; argument will have an itemsize member at least as big but perhaps bigger depending on the object &lt;em&gt;op&lt;/em&gt;.</source>
          <target state="translated">此函数与&lt;a href=&quot;#c.PyArray_ObjectType&quot;&gt; &lt;code&gt;PyArray_ObjectType&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）相似，但它处理灵活的数组。该&lt;em&gt;mintype&lt;/em&gt;参数可以有一个itemsize部件和&lt;em&gt;outtype&lt;/em&gt;参数将有至少一个itemsize成员一样大，但也许更大的取决于物体&lt;em&gt;运&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="24bfcaf02c26210c6ce475ff904488dd4e86859f" translate="yes" xml:space="preserve">
          <source>This functionality can be obtained via &lt;a href=&quot;numpy.diag_indices#numpy.diag_indices&quot;&gt;&lt;code&gt;diag_indices&lt;/code&gt;&lt;/a&gt;, but internally this version uses a much faster implementation that never constructs the indices and uses simple slicing.</source>
          <target state="translated">可以通过&lt;a href=&quot;numpy.diag_indices#numpy.diag_indices&quot;&gt; &lt;code&gt;diag_indices&lt;/code&gt; &lt;/a&gt;获得此功能，但是在内部，此版本使用更快的实现，该实现从不构造索引并且使用简单的切片。</target>
        </trans-unit>
        <trans-unit id="8df0c373fc062bf47c7c593de18498c118dd2c34" translate="yes" xml:space="preserve">
          <source>This general purpose 1-d core function assumes that &lt;em&gt;func&lt;/em&gt; is a string representing a method of the input object that takes one argument. The first argument in &lt;em&gt;args&lt;/em&gt; is the method whose function is called, the second argument in &lt;em&gt;args&lt;/em&gt; is the argument passed to the function. The output of the function is stored in the third entry of &lt;em&gt;args&lt;/em&gt;.</source>
          <target state="translated">该通用的1-d核心函数假定&lt;em&gt;func&lt;/em&gt;是一个字符串，表示一个输入参数的方法，该方法采用一个参数。在第一个参数&lt;em&gt;ARGS&lt;/em&gt;是其功能被调用时，在第二个参数的方法&lt;em&gt;ARGS&lt;/em&gt;是传递给函数的自变量。函数的输出存储在&lt;em&gt;args&lt;/em&gt;的第三项中。</target>
        </trans-unit>
        <trans-unit id="71fb70d934e71392e5b977e3d5908e6d14ba65f1" translate="yes" xml:space="preserve">
          <source>This general purpose 1-d core function assumes that &lt;em&gt;func&lt;/em&gt; is a string representing a method of the input object. For each iteration of the loop, the Python object is extracted from the array and its &lt;em&gt;func&lt;/em&gt; method is called returning the result to the output array.</source>
          <target state="translated">该通用的1-d核心函数假定&lt;em&gt;func&lt;/em&gt;是表示输入对象的方法的字符串。对于循环的每次迭代，都会从数组中提取Python对象，并调用其&lt;em&gt;func&lt;/em&gt;方法，将结果返回到输出数组。</target>
        </trans-unit>
        <trans-unit id="ebe1403d50c0fdb0002abff6822f498479faa88e" translate="yes" xml:space="preserve">
          <source>This geometrical property can be seen in two dimensions by plotting generated data-points:</source>
          <target state="translated">这种几何属性可以通过绘制生成的数据点在二维度上看到。</target>
        </trans-unit>
        <trans-unit id="e1dc7a565ca8eeac49fa065474eb2fca785df357" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; data pointers. If &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; was not specified, each data pointer points to the current data item of the iterator. If no inner iteration was specified, it points to the first data item of the inner loop.</source>
          <target state="translated">这将返回一个指向 &lt;code&gt;nop&lt;/code&gt; 数据指针的指针。如果未指定&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;，则每个数据指针都指向迭代器的当前数据项。如果未指定内部迭代，则它指向内部循环的第一个数据项。</target>
        </trans-unit>
        <trans-unit id="ad9e42c674af93de7c3d00b721f840bb2a3ba388" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; data type Descrs for the objects being iterated. The result points into &lt;code&gt;iter&lt;/code&gt;, so the caller does not gain any references to the Descrs.</source>
          <target state="translated">这将返回指向要迭代的对象的 &lt;code&gt;nop&lt;/code&gt; 数据类型Descrs 的指针。结果指向 &lt;code&gt;iter&lt;/code&gt; ，因此调用方不会获得对Descrs的任何引用。</target>
        </trans-unit>
        <trans-unit id="04484c93294b17e48ec0072eb06cb15b6ce824d8" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; operand PyObjects that are being iterated. The result points into &lt;code&gt;iter&lt;/code&gt;, so the caller does not gain any references to the PyObjects.</source>
          <target state="translated">这将返回指向正在迭代的 &lt;code&gt;nop&lt;/code&gt; 操作数PyObject 的指针。结果指向 &lt;code&gt;iter&lt;/code&gt; ，因此调用方不会获得对PyObjects的任何引用。</target>
        </trans-unit>
        <trans-unit id="de4914e9685130ac5234ec503748e2bb51b5d569" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the index being tracked, or NULL if no index is being tracked. It is only useable if one of the flags &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt; were specified during construction.</source>
          <target state="translated">这将返回指向被跟踪索引的指针，如果没有索引被跟踪，则返回NULL。仅在构造期间指定了标志&lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; &lt;/a&gt;之一时才可用。</target>
        </trans-unit>
        <trans-unit id="76e1c3a277ebfaa2cffaf967d76cec0c7e8df194" translate="yes" xml:space="preserve">
          <source>This gives back a reference to a new ndarray view, which is a view into the i-th object in the array &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt;, whose dimensions and strides match the internal optimized iteration pattern. A C-order iteration of this view is equivalent to the iterator&amp;rsquo;s iteration order.</source>
          <target state="translated">这将返回对新ndarray视图的引用，该视图是对&lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt; &lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt; &lt;/a&gt;数组中第i个对象的视图，其尺寸和步幅与内部优化的迭代模式匹配。此视图的C顺序迭代等效于迭代器的迭代顺序。</target>
        </trans-unit>
        <trans-unit id="5203e44570d99c05fcfa2df4337f300e46c186be" translate="yes" xml:space="preserve">
          <source>This group is used to call code that may take some time but does not use any Python C-API calls. Thus, the GIL should be released during its calculation.</source>
          <target state="translated">该组用于调用可能需要一些时间但不使用任何 Python C-API 调用的代码。因此,GIL应该在其计算过程中被释放。</target>
        </trans-unit>
        <trans-unit id="5bcd38e59fd6cf93688e83d10245c536ddb55a3a" translate="yes" xml:space="preserve">
          <source>This group is used to re-acquire the Python GIL after it has been released. For example, suppose the GIL has been released (using the previous calls), and then some path in the code (perhaps in a different subroutine) requires use of the Python C-API, then these macros are useful to acquire the GIL. These macros accomplish essentially a reverse of the previous three (acquire the LOCK saving what state it had) and then re-release it with the saved state.</source>
          <target state="translated">这组用于在Python GIL被释放后重新获取它。例如,假设 GIL 已经被释放 (使用前面的调用),然后在代码中的某些路径 (可能在不同的子程序中)需要使用 Python C-API,那么这些宏就可以用来获取 GIL。这些宏基本上完成了前面三个宏的反转(获取LOCK保存它的状态),然后用保存的状态重新释放它。</target>
        </trans-unit>
        <trans-unit id="4ba46b0017074bb74d18814c42399e783717828c" translate="yes" xml:space="preserve">
          <source>This guide is an overview and explains the important features; details are found in &lt;a href=&quot;../reference/index#reference&quot;&gt;NumPy Reference&lt;/a&gt;.</source>
          <target state="translated">本指南是概述，并解释了重要功能；有关详细信息，请参见《&lt;a href=&quot;../reference/index#reference&quot;&gt;NumPy参考》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c9e84e903bf2e483b137abd67c279312344ab01" translate="yes" xml:space="preserve">
          <source>This guide will help you decide what to contribute and how to submit it to the official NumPy documentation.</source>
          <target state="translated">本指南将帮助你决定贡献什么以及如何提交到NumPy官方文档中。</target>
        </trans-unit>
        <trans-unit id="22e8bed5de814991ce18d8f44ecb60dc6c28da78" translate="yes" xml:space="preserve">
          <source>This info dict can then be used as input to a &lt;a href=&quot;../distutils#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; instance:</source>
          <target state="translated">然后可以将此信息字典用作&lt;a href=&quot;../distutils#numpy.distutils.misc_util.Configuration&quot;&gt; &lt;code&gt;Configuration&lt;/code&gt; &lt;/a&gt;实例的输入：</target>
        </trans-unit>
        <trans-unit id="594238b01d9d524cb6fb409e28f8c563967eda11" translate="yes" xml:space="preserve">
          <source>This information will be collected in writing, and whenever possible the group&amp;rsquo;s deliberations will be recorded and retained (i.e. chat transcripts, email discussions, recorded conference calls, summaries of voice conversations, etc).</source>
          <target state="translated">这些信息将以书面形式收集，并尽可能记录并保留小组的讨论情况（例如，聊天记录，电子邮件讨论，录制的电话会议，语音对话摘要等）。</target>
        </trans-unit>
        <trans-unit id="11fb823e6d137af2611381a853679838cd294872" translate="yes" xml:space="preserve">
          <source>This interface describes homogeneous arrays in the sense that each item of the array has the same &amp;ldquo;type&amp;rdquo;. This type can be very simple or it can be a quite arbitrary and complicated C-like structure.</source>
          <target state="translated">从某种意义上说，此接口从阵列的每个项目具有相同的&amp;ldquo;类型&amp;rdquo;的角度描述同类阵列。这种类型可以非常简单，也可以是相当任意和复杂的类C结构。</target>
        </trans-unit>
        <trans-unit id="669065ebaf0e163f0816c64449775393f24910fd" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;numpy.flatiter#numpy.flatiter&quot;&gt;&lt;code&gt;numpy.flatiter&lt;/code&gt;&lt;/a&gt; instance, which acts similarly to, but is not a subclass of, Python&amp;rsquo;s built-in iterator object.</source>
          <target state="translated">这是一个&lt;a href=&quot;numpy.flatiter#numpy.flatiter&quot;&gt; &lt;code&gt;numpy.flatiter&lt;/code&gt; &lt;/a&gt;实例，其行为类似于Python的内置迭代器对象，但不是其子类。</target>
        </trans-unit>
        <trans-unit id="c616752b11f5b5590e848100c7afe1eff6eb31fb" translate="yes" xml:space="preserve">
          <source>This is a convenience function for quick storage of array data. Information on endianness and precision is lost, so this method is not a good choice for files intended to archive data or transport data between machines with different endianness. Some of these problems can be overcome by outputting the data as text files, at the expense of speed and file size.</source>
          <target state="translated">这是一个快速存储阵列数据的方便功能。由于丢失了迭度和精度的信息,所以这种方法并不适合用于存档数据或在不同迭度的机器之间传输数据的文件。其中一些问题可以通过将数据输出为文本文件来解决,但要牺牲速度和文件大小。</target>
        </trans-unit>
        <trans-unit id="e143678de16b85b14841ff12151066d84f46e8b0" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于用户从Matlab移植代码来说，这是一种便利功能，它包装&lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt; &lt;code&gt;random_sample&lt;/code&gt; &lt;/a&gt;。该函数使用一个元组来指定输出的大小，这与其他NumPy函数（例如&lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; )一致&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a6640731207cc17f5b282e72b4960d28e172178" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;a href=&quot;numpy.random.randomstate.random_sample#numpy.random.RandomState.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于用户从Matlab移植代码来说，这是一种便利功能，它包装&lt;a href=&quot;numpy.random.randomstate.random_sample#numpy.random.RandomState.random_sample&quot;&gt; &lt;code&gt;random_sample&lt;/code&gt; &lt;/a&gt;。该函数使用一个元组来指定输出的大小，这与其他NumPy函数（例如&lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; )一致&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e91ed9ba3b995348d0b712c7cd0f68c854820dd9" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;a href=&quot;numpy.random.randomstate.standard_normal#numpy.random.RandomState.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于用户从Matlab移植代码来说，这是一个便利功能，它包装了&lt;a href=&quot;numpy.random.randomstate.standard_normal#numpy.random.RandomState.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt;。该函数使用一个元组来指定输出的大小，这与其他NumPy函数（例如&lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; )一致&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="637f2f7f4587e6fab14f3bc29737254f8ece5452" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;a href=&quot;numpy.random.standard_normal#numpy.random.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于用户从Matlab移植代码来说，这是一个便利功能，它包装了&lt;a href=&quot;numpy.random.standard_normal#numpy.random.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt;。该函数使用一个元组来指定输出的大小，这与其他NumPy函数（例如&lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; )一致&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aebce3c953e4d7a8aa40a69097fcdae621194f4a" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;code&gt;numpy.random.random_sample&lt;/code&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于用户从Matlab移植代码来说，这是一个便利功能，它包装了 &lt;code&gt;numpy.random.random_sample&lt;/code&gt; 。该函数使用一个元组来指定输出的大小，这与其他NumPy函数（例如&lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; )一致&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a8395276aef2b1c09ac3507c06c6aeae1c56edd" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;code&gt;numpy.random.standard_normal&lt;/code&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于用户从Matlab移植代码来说，这是一个便利功能，它包装了 &lt;code&gt;numpy.random.standard_normal&lt;/code&gt; 。该函数使用一个元组来指定输出的大小，这与其他NumPy函数（例如&lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; )一致&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14bed771c7ecf5fb5c7f3988c3e80ea720b90d56" translate="yes" xml:space="preserve">
          <source>This is a convenience, legacy function.</source>
          <target state="translated">这是一个方便、遗留的功能。</target>
        </trans-unit>
        <trans-unit id="8386d98dd4fd3fd3372da264e738d2eec8c472de" translate="yes" xml:space="preserve">
          <source>This is a default converter for output arrays given to functions. If &lt;em&gt;obj&lt;/em&gt; is &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt;&lt;code&gt;Py_None&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;NULL&lt;/code&gt;, then &lt;em&gt;*address&lt;/em&gt; will be &lt;code&gt;NULL&lt;/code&gt; but the call will succeed. If &lt;a href=&quot;#c.PyArray_Check&quot;&gt;&lt;code&gt;PyArray_Check&lt;/code&gt;&lt;/a&gt; ( &lt;em&gt;obj&lt;/em&gt;) is TRUE then it is returned in &lt;em&gt;*address&lt;/em&gt; without incrementing its reference count.</source>
          <target state="translated">这是给函数提供输出数组的默认转换器。如果&lt;em&gt;obj&lt;/em&gt;是&lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt; &lt;code&gt;Py_None&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;NULL&lt;/code&gt; ，则&lt;em&gt;* address&lt;/em&gt;将为 &lt;code&gt;NULL&lt;/code&gt; ,但调用将成功。如果&lt;a href=&quot;#c.PyArray_Check&quot;&gt; &lt;code&gt;PyArray_Check&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;obj&lt;/em&gt;）为TRUE，则它将在&lt;em&gt;* address中&lt;/em&gt;返回而不增加其引用计数。</target>
        </trans-unit>
        <trans-unit id="ebf6bd0b70f0575c64ee3df5fdd00ac441de460d" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to C99 copysign: return x with the same sign as y. Works for any value, including inf and nan. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">这个函数相当于C99的copysign:返回与y相同符号的x。对任何值都有效,包括inf和nan。后缀f和l可用于单精度和扩展精度。</target>
        </trans-unit>
        <trans-unit id="9c5d9b74232b5b43fdac1227d638313277afa572" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to C99 nextafter: return next representable floating point value from x in the direction of y. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">这是一个相当于C99 nextafter的函数:从x向y的方向返回下一个可表示的浮点数,单精度和扩展精度可以用后缀f和l来表示。</target>
        </trans-unit>
        <trans-unit id="6cef9e65ee084ca1f09a67a21a4b3ef4b9523383" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to Fortran intrinsic. Return distance between x and next representable floating point value from x, e.g. spacing(1) == eps. spacing of nan and +/- inf return nan. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">这是一个相当于Fortran本征的函数。返回 x 与 x 之间的距离,例如 spacing(1)==eps.间距为 nan 和 +/-inf 返回 nan.单个和扩展的精度可以用后缀f和l来表示。</target>
        </trans-unit>
        <trans-unit id="f691a7cca2d5bab9d5322a451f5071b060431b18" translate="yes" xml:space="preserve">
          <source>This is a function pointer for getting the current iterator multi-index, returned by &lt;a href=&quot;#c.NpyIter_GetGetMultiIndex&quot;&gt;&lt;code&gt;NpyIter_GetGetMultiIndex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是一个函数指针，用于获取由&lt;a href=&quot;#c.NpyIter_GetGetMultiIndex&quot;&gt; &lt;code&gt;NpyIter_GetGetMultiIndex&lt;/code&gt; &lt;/a&gt;返回的当前迭代器多索引。</target>
        </trans-unit>
        <trans-unit id="afe9f9d9e5612f0c43f0b6f2ab1ddbf98d2077ed" translate="yes" xml:space="preserve">
          <source>This is a function pointer for the iteration loop, returned by &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt;&lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是迭代循环的函数指针，由&lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt; &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt; &lt;/a&gt;返回。</target>
        </trans-unit>
        <trans-unit id="682e5efdefc09e15bb711f19c6e22c6512c8e3c9" translate="yes" xml:space="preserve">
          <source>This is a list of flags for each operand. At minimum, one of &lt;code&gt;readonly&lt;/code&gt;, &lt;code&gt;readwrite&lt;/code&gt;, or &lt;code&gt;writeonly&lt;/code&gt; must be specified.</source>
          <target state="translated">这是每个操作数的标志的列表。至少必须指定 &lt;code&gt;readonly&lt;/code&gt; ， &lt;code&gt;readwrite&lt;/code&gt; 或 &lt;code&gt;writeonly&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="daee1c27087ebe5008ffab37bf86e6cef5520692" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isfinite: works for single, double and extended precision, and return a non 0 value is x is neither a NaN nor an infinity.</source>
          <target state="translated">这是一个宏,相当于C99 isfinite:适用于单精度、双精度和扩展精度,并返回一个非0值,即x既不是NaN也不是无穷大。</target>
        </trans-unit>
        <trans-unit id="80381bd72606c65ade88008349bbceb47f771261" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isinf: works for single, double and extended precision, and return a non 0 value is x is infinite (positive and negative).</source>
          <target state="translated">这是一个宏,相当于C99 isinf:适用于单精度、双精度和扩展精度,并返回一个非0值,即x是无限的(正和负)。</target>
        </trans-unit>
        <trans-unit id="0a2766c5fc1ee9982025de76ae4aa9f68ecd22db" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isnan: works for single, double and extended precision, and return a non 0 value is x is a NaN.</source>
          <target state="translated">这是一个宏,相当于C99 isnan:适用于单精度、双精度和扩展精度,并在x是NaN时返回一个非0值。</target>
        </trans-unit>
        <trans-unit id="ba072edcddb8314e48393832fd145a168df5e278" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 signbit: works for single, double and extended precision, and return a non 0 value is x has the signbit set (that is the number is negative).</source>
          <target state="translated">这是一个宏,相当于C99的signbit:适用于单精度、双精度和扩展精度,并在x有signbit设置时返回一个非0值(即数字为负)。</target>
        </trans-unit>
        <trans-unit id="90bdfe8753787f61c5537ce6dde698f20d3651a1" translate="yes" xml:space="preserve">
          <source>This is a quick overview of algebra and arrays in NumPy. It demonstrates how n-dimensional (</source>
          <target state="translated">这是一个关于NumPy中代数和数组的快速概述。它演示了n维(</target>
        </trans-unit>
        <trans-unit id="e912c91523a3cdb66f72696d355ab45d0a9a414f" translate="yes" xml:space="preserve">
          <source>This is a relatively robust method to compare two arrays whose amplitude is variable.</source>
          <target state="translated">这是一种比较稳健的方法,用于比较两个振幅可变的数组。</target>
        </trans-unit>
        <trans-unit id="f9e98f643e268bceb892d520470f87f06bd3ffa1" translate="yes" xml:space="preserve">
          <source>This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="daaf8424b18b172abdada56262484be0114cb050" translate="yes" xml:space="preserve">
          <source>This is a setup.py file for the above code. As before, the module can be build via calling python setup.py build at the command prompt, or installed to site-packages via python setup.py install.</source>
          <target state="translated">这是上述代码的setup.py文件。和之前一样,模块可以通过在命令提示符下调用python setup.py build来构建,或者通过python setup.py install安装到站点包中。</target>
        </trans-unit>
        <trans-unit id="5b6ff4b3ee0d226dd43f100afc9a5e9fc743a95d" translate="yes" xml:space="preserve">
          <source>This is a simple way to build up arrays quickly. There are two use cases.</source>
          <target state="translated">这是一种快速建立数组的简单方法。有两个用例。</target>
        </trans-unit>
        <trans-unit id="5bf246dfc26ef7aa2b64da9e4b03eace45db2857" translate="yes" xml:space="preserve">
          <source>This is a special flag that is set if this array represents a copy made because a user required certain flags in &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; and a copy had to be made of some other array (and the user asked for this flag to be set in such a situation). The base attribute then points to the &amp;ldquo;misbehaved&amp;rdquo; array (which is set read_only). :c:func`PyArray_ResolveWritebackIfCopy` will copy its contents back to the &amp;ldquo;misbehaved&amp;rdquo; array (casting if necessary) and will reset the &amp;ldquo;misbehaved&amp;rdquo; array to &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;. If the &amp;ldquo;misbehaved&amp;rdquo; array was not &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; to begin with then &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; would have returned an error because &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; would not have been possible.</source>
          <target state="translated">这是一个特殊标志，如果此数组表示由于用户需要&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; 中的&lt;/a&gt;某些标志而必须复制某个其他数组（并且用户要求在这种情况下设置此标志）而制作的副本，则设置该标志。 。然后，基本属性指向&amp;ldquo;行为异常&amp;rdquo;数组（设置为read_only）。 ：c：func`PyArray_ResolveWritebackIfCopy`将其内容复制回&amp;ldquo;行为不当&amp;rdquo;数组（如有必要，进行广播），并将&amp;ldquo;行为不当&amp;rdquo;数组重置为&lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;。如果&amp;ldquo;不当行为&amp;rdquo;数组不是以&lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;开头的，则&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;将返回错误，因为&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d494bbd6ea4e55e23b6320030cf19b92084fb2cb" translate="yes" xml:space="preserve">
          <source>This is a very flexible function; &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.array_str#numpy.array_str&quot;&gt;&lt;code&gt;array_str&lt;/code&gt;&lt;/a&gt; are using &lt;a href=&quot;#numpy.array2string&quot;&gt;&lt;code&gt;array2string&lt;/code&gt;&lt;/a&gt; internally so keywords with the same name should work identically in all three functions.</source>
          <target state="translated">这是一个非常灵活的功能；&lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.array_str#numpy.array_str&quot;&gt; &lt;code&gt;array_str&lt;/code&gt; &lt;/a&gt;在内部使用&lt;a href=&quot;#numpy.array2string&quot;&gt; &lt;code&gt;array2string&lt;/code&gt; ,&lt;/a&gt;因此具有相同名称的关键字在所有三个函数中应相同地工作。</target>
        </trans-unit>
        <trans-unit id="4a20d6c5e13bf5949cf2f01fed00be4a85ee83c8" translate="yes" xml:space="preserve">
          <source>This is a wrapper around &lt;code&gt;cPickle.dump&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;cPickle.dump&lt;/code&gt; 的包装。</target>
        </trans-unit>
        <trans-unit id="72c0baacc027dca1b05db754f60ee813fa6dbfcf" translate="yes" xml:space="preserve">
          <source>This is a wrapper around &lt;code&gt;cPickle.dumps&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;cPickle.dumps&lt;/code&gt; 的包装。</target>
        </trans-unit>
        <trans-unit id="b6ae9c5b7de866ac0dd1b4b58c7a54bd18149043" translate="yes" xml:space="preserve">
          <source>This is almost the same as the result of PyArray_CanCastTypeTo(PyArray_MinScalarType(arr), totype, casting), but it also handles a special case arising because the set of uint values is not a subset of the int values for types with the same number of bits.</source>
          <target state="translated">这与PyArray_CanCastTypeTo(PyArray_MinScalarType(arr),totype,casting)的结果几乎是一样的,但它也处理了一种特殊情况,因为uint值的集合不是具有相同位数的类型的int值的子集。</target>
        </trans-unit>
        <trans-unit id="06d558ced35712eb9368208c693942a96aac9510" translate="yes" xml:space="preserve">
          <source>This is an alias of &lt;a href=&quot;generated/numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;generated/numpy.random.random_sample#numpy.random.random_sample&quot;&gt; &lt;code&gt;random_sample&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="6be9e8aa17773bdb0efb0eec1cc4294398d93d4d" translate="yes" xml:space="preserve">
          <source>This is an alias of &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt; for the complete documentation.</source>
          <target state="translated">这是&lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt; &lt;code&gt;random_sample&lt;/code&gt; &lt;/a&gt;的别名。有关完整的文档，请参见&lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt; &lt;code&gt;random_sample&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abef17cd5a41150617b797dd34026cad2a72bcf3" translate="yes" xml:space="preserve">
          <source>This is an example of a func specialized for addition of doubles returning doubles.</source>
          <target state="translated">这是一个专门用于双倍加法返回双倍的函数的例子。</target>
        </trans-unit>
        <trans-unit id="8d1fbd89490e7598a40d0ab430364ea01d0cff36" translate="yes" xml:space="preserve">
          <source>This is an interface to the LAPACK routines &lt;code&gt;dgeqrf&lt;/code&gt;, &lt;code&gt;zgeqrf&lt;/code&gt;, &lt;code&gt;dorgqr&lt;/code&gt;, and &lt;code&gt;zungqr&lt;/code&gt;.</source>
          <target state="translated">这是LAPACK例程 &lt;code&gt;dgeqrf&lt;/code&gt; ， &lt;code&gt;zgeqrf&lt;/code&gt; ， &lt;code&gt;dorgqr&lt;/code&gt; 和 &lt;code&gt;zungqr&lt;/code&gt; 的接口。</target>
        </trans-unit>
        <trans-unit id="944d000b70e8d3d375939368b9ee8662949fdd56" translate="yes" xml:space="preserve">
          <source>This is an iterator object that makes it easy to loop over an N-dimensional array. It is the object returned from the flat attribute of an ndarray. It is also used extensively throughout the implementation internals to loop over an N-dimensional array. The tp_as_mapping interface is implemented so that the iterator object can be indexed (using 1-d indexing), and a few methods are implemented through the tp_methods table. This object implements the next method and can be used anywhere an iterator can be used in Python.</source>
          <target state="translated">这是一个迭代器对象,它可以很容易地对一个N维数组进行循环。它是由ndarray的flat属性返回的对象。在整个实现内部,它也被广泛地用于在一个N维数组上循环。tp_as_mapping接口的实现使得迭代器对象可以被索引(使用1-d索引),并且通过tp_methods表实现了一些方法。这个对象实现了下一个方法,可以在Python中任何可以使用迭代器的地方使用。</target>
        </trans-unit>
        <trans-unit id="39877197a88959914be74b4d252daeba988b0567" translate="yes" xml:space="preserve">
          <source>This is an iterator object that makes it easy to loop over an N-dimensional neighborhood.</source>
          <target state="translated">这是一个迭代器对象,可以很容易地在一个N维邻域上进行循环。</target>
        </trans-unit>
        <trans-unit id="ed4488f4638f84c1e1e4b827cf0b8579c8c851e4" translate="yes" xml:space="preserve">
          <source>This is an opaque pointer type for the iterator. Access to its contents can only be done through the iterator API.</source>
          <target state="translated">这是迭代器的不透明指针类型。对其内容的访问只能通过迭代器API来完成。</target>
        </trans-unit>
        <trans-unit id="b4c12ec7da04774c2971488c28da077dd954ab73" translate="yes" xml:space="preserve">
          <source>This is defined for &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;, &lt;strong&gt;SHORT&lt;/strong&gt;, &lt;strong&gt;INT&lt;/strong&gt;, &lt;strong&gt;LONG&lt;/strong&gt;, &lt;strong&gt;LONGLONG&lt;/strong&gt;, &lt;strong&gt;INTP&lt;/strong&gt;</source>
          <target state="translated">为 &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;，&lt;strong&gt;SHORT&lt;/strong&gt;，&lt;strong&gt;INT&lt;/strong&gt;，&lt;strong&gt;LONG&lt;/strong&gt;，&lt;strong&gt;LONGLONG&lt;/strong&gt;，&lt;strong&gt;INTP定义&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1cb38ad4a8a5f0f7eaad9358f9b24fff730b48c2" translate="yes" xml:space="preserve">
          <source>This is defined for all defined for &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;, &lt;strong&gt;UBYTE&lt;/strong&gt;, &lt;strong&gt;SHORT&lt;/strong&gt;, &lt;strong&gt;USHORT&lt;/strong&gt;, &lt;strong&gt;INT&lt;/strong&gt;, &lt;strong&gt;UINT&lt;/strong&gt;, &lt;strong&gt;LONG&lt;/strong&gt;, &lt;strong&gt;ULONG&lt;/strong&gt;, &lt;strong&gt;LONGLONG&lt;/strong&gt;, &lt;strong&gt;ULONGLONG&lt;/strong&gt;, &lt;strong&gt;INTP&lt;/strong&gt;, &lt;strong&gt;UINTP&lt;/strong&gt;</source>
          <target state="translated">为 &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;，&lt;strong&gt;UBYTE&lt;/strong&gt;，&lt;strong&gt;SHORT&lt;/strong&gt;，&lt;strong&gt;USHORT&lt;/strong&gt;，&lt;strong&gt;INT&lt;/strong&gt;，&lt;strong&gt;UINT&lt;/strong&gt;，&lt;strong&gt;LONG&lt;/strong&gt;，&lt;strong&gt;ULONG&lt;/strong&gt;，&lt;strong&gt;LONGLONG&lt;/strong&gt;，&lt;strong&gt;ULONGLONG&lt;/strong&gt;，&lt;strong&gt;INTP&lt;/strong&gt;，&lt;strong&gt;UINTP&lt;/strong&gt;定义的所有定义&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e53b90b8b35ae60046587f59e89f7b60e6df85a" translate="yes" xml:space="preserve">
          <source>This is different from &lt;a href=&quot;numpy.load#numpy.load&quot;&gt;&lt;code&gt;numpy.load&lt;/code&gt;&lt;/a&gt;, which does not use cPickle but loads the NumPy binary .npy format.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.load#numpy.load&quot;&gt; &lt;code&gt;numpy.load&lt;/code&gt; &lt;/a&gt;不同，后者不使用cPickle而是加载NumPy二进制.npy格式。</target>
        </trans-unit>
        <trans-unit id="ad4d2eb9b0ee11d28c4e5a349ba480c6768dfc79" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt; and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">这等效于（但比其快）以下对&lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; 的使用&lt;/a&gt;，后者将 &lt;code&gt;ii&lt;/code&gt; 和 &lt;code&gt;kk&lt;/code&gt; 设置为索引元组：</target>
        </trans-unit>
        <trans-unit id="f5170749efab413ba3776c33568562d9c4634a7d" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">这等效于（但比其快）以下对&lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; 的&lt;/a&gt;使用，它将 &lt;code&gt;ii&lt;/code&gt; ， &lt;code&gt;jj&lt;/code&gt; 和 &lt;code&gt;kk&lt;/code&gt; 中的每一个设置为一个索引元组：</target>
        </trans-unit>
        <trans-unit id="f723a36a0fdceaf5add767f4dfa10dbdef0cf27e" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;code&gt;ndindex&lt;/code&gt; and &lt;code&gt;s_&lt;/code&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">这等效于（但比其快）以下对 &lt;code&gt;ndindex&lt;/code&gt; 和 &lt;code&gt;s_&lt;/code&gt; 的使用，它将 &lt;code&gt;ii&lt;/code&gt; ， &lt;code&gt;jj&lt;/code&gt; 和 &lt;code&gt;kk&lt;/code&gt; 中的每一个设置为一个索引元组：</target>
        </trans-unit>
        <trans-unit id="9623032760a445ce084ed7cad1f49c8e81cbc730" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.compress(ravel(condition), ravel(arr))&lt;/code&gt;. If &lt;code&gt;condition&lt;/code&gt; is boolean &lt;code&gt;np.extract&lt;/code&gt; is equivalent to &lt;code&gt;arr[condition]&lt;/code&gt;.</source>
          <target state="translated">这等效于 &lt;code&gt;np.compress(ravel(condition), ravel(arr))&lt;/code&gt; 。如果 &lt;code&gt;condition&lt;/code&gt; 为布尔值，则 &lt;code&gt;np.extract&lt;/code&gt; 等效于 &lt;code&gt;arr[condition]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="270d637e7c2130210ad3ee654e7e3067ac01221d" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt;, see &lt;a href=&quot;numpy.ma.compress_rowcols#numpy.ma.compress_rowcols&quot;&gt;&lt;code&gt;compress_rowcols&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">这等效于 &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt; ，有关详细信息，请参见&lt;a href=&quot;numpy.ma.compress_rowcols#numpy.ma.compress_rowcols&quot;&gt; &lt;code&gt;compress_rowcols&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="512416aca8fa4fb317d305f7a3902a8f4f57268d" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt;, see &lt;code&gt;extras.compress_rowcols&lt;/code&gt; for details.</source>
          <target state="translated">这等效于 &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt; ，有关详细信息，请参见 &lt;code&gt;extras.compress_rowcols&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6ffd133d65cdedb57e33b341f8909e0c883dd56" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt;, see &lt;a href=&quot;numpy.ma.compress_rowcols#numpy.ma.compress_rowcols&quot;&gt;&lt;code&gt;compress_rowcols&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">这等效于 &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt; ，有关详细信息，请参见&lt;a href=&quot;numpy.ma.compress_rowcols#numpy.ma.compress_rowcols&quot;&gt; &lt;code&gt;compress_rowcols&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1aabefa5df0b67ecae64f8e5a2fb2a4d5dd2e5ee" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt;, see &lt;code&gt;extras.compress_rowcols&lt;/code&gt; for details.</source>
          <target state="translated">这等效于 &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt; ，有关详细信息，请参见 &lt;code&gt;extras.compress_rowcols&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e12dd8fc795d33b8f8bcabb847c3e158c738c5e" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the first axis after 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N)&lt;/code&gt;. Rebuilds arrays divided by &lt;a href=&quot;numpy.vsplit#numpy.vsplit&quot;&gt;&lt;code&gt;vsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这等效于形状 &lt;code&gt;(N,)&lt;/code&gt; 的一维数组已重整为 &lt;code&gt;(1,N)&lt;/code&gt; 后沿第一轴进行连接。重建除以&lt;a href=&quot;numpy.vsplit#numpy.vsplit&quot;&gt; &lt;code&gt;vsplit&lt;/code&gt; 的&lt;/a&gt;数组。</target>
        </trans-unit>
        <trans-unit id="8a1612db7b39849ef3a6bd08b64bed8c3240f816" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the first axis after 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N)&lt;/code&gt;. Rebuilds arrays divided by &lt;code&gt;vsplit&lt;/code&gt;.</source>
          <target state="translated">这等效于形状 &lt;code&gt;(N,)&lt;/code&gt; 的一维数组已重整为 &lt;code&gt;(1,N)&lt;/code&gt; 后沿第一轴进行连接。重建除以 &lt;code&gt;vsplit&lt;/code&gt; 的数组。</target>
        </trans-unit>
        <trans-unit id="e9676c88264ef3cd76556860f143548d10e94eb6" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the second axis, except for 1-D arrays where it concatenates along the first axis. Rebuilds arrays divided by &lt;a href=&quot;numpy.hsplit#numpy.hsplit&quot;&gt;&lt;code&gt;hsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这等效于沿第二个轴的串联，除了一维数组沿第一个轴的串联。重建除以&lt;a href=&quot;numpy.hsplit#numpy.hsplit&quot;&gt; &lt;code&gt;hsplit&lt;/code&gt; 的&lt;/a&gt;数组。</target>
        </trans-unit>
        <trans-unit id="e6a5b26fca5a2a732affc24a30a8305bc7f4ee4d" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the second axis, except for 1-D arrays where it concatenates along the first axis. Rebuilds arrays divided by &lt;a href=&quot;numpy.ma.hsplit#numpy.ma.hsplit&quot;&gt;&lt;code&gt;hsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这等效于沿第二个轴的串联，除了一维数组沿第一个轴的串联。重建除以&lt;a href=&quot;numpy.ma.hsplit#numpy.ma.hsplit&quot;&gt; &lt;code&gt;hsplit&lt;/code&gt; 的&lt;/a&gt;数组。</target>
        </trans-unit>
        <trans-unit id="5f3f85e2c1a9f572b9f43cddeb78f8794cecabcf" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the third axis after 2-D arrays of shape &lt;code&gt;(M,N)&lt;/code&gt; have been reshaped to &lt;code&gt;(M,N,1)&lt;/code&gt; and 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N,1)&lt;/code&gt;. Rebuilds arrays divided by &lt;a href=&quot;numpy.dsplit#numpy.dsplit&quot;&gt;&lt;code&gt;dsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这等效于形状 &lt;code&gt;(M,N)&lt;/code&gt; 的 2-D数组已重塑为 &lt;code&gt;(M,N,1)&lt;/code&gt; 和形状 &lt;code&gt;(N,)&lt;/code&gt; 的 1-D数组已重塑为 &lt;code&gt;(1,N,1)&lt;/code&gt; 。重建除以&lt;a href=&quot;numpy.dsplit#numpy.dsplit&quot;&gt; &lt;code&gt;dsplit&lt;/code&gt; 的&lt;/a&gt;数组。</target>
        </trans-unit>
        <trans-unit id="5c6f9c31ab715a660b4d23dc2f49389f45ea5bda" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the third axis after 2-D arrays of shape &lt;code&gt;(M,N)&lt;/code&gt; have been reshaped to &lt;code&gt;(M,N,1)&lt;/code&gt; and 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N,1)&lt;/code&gt;. Rebuilds arrays divided by &lt;code&gt;dsplit&lt;/code&gt;.</source>
          <target state="translated">这等效于形状 &lt;code&gt;(M,N)&lt;/code&gt; 的 2-D数组已重塑为 &lt;code&gt;(M,N,1)&lt;/code&gt; 和形状 &lt;code&gt;(N,)&lt;/code&gt; 的 1-D数组已重塑为 &lt;code&gt;(1,N,1)&lt;/code&gt; 。重建除以 &lt;code&gt;dsplit&lt;/code&gt; 的数组。</target>
        </trans-unit>
        <trans-unit id="d218a0a3e8c4c5860255504a9ba19c22b6fab14a" translate="yes" xml:space="preserve">
          <source>This is equivalent to np.nonzero(np.ravel(a))[0].</source>
          <target state="translated">这相当于np.nonzero(np.ravel(a))[0]。</target>
        </trans-unit>
        <trans-unit id="c1506fb5159fec603ce600935782977e9cc4a640" translate="yes" xml:space="preserve">
          <source>This is equivalent to the &lt;code&gt;density&lt;/code&gt; argument, but produces incorrect results for unequal bin widths. It should not be used.</source>
          <target state="translated">这等效于 &lt;code&gt;density&lt;/code&gt; 参数，但是对于不等的箱宽会产生不正确的结果。不应使用。</target>
        </trans-unit>
        <trans-unit id="59cfbae4022883700bb27212977a0aea4a1ca893" translate="yes" xml:space="preserve">
          <source>This is equivalent to the buffer object structure in Python up to the ptr member. On 32-bit platforms (&lt;em&gt;i.e.&lt;/em&gt; if &lt;a href=&quot;c-api.config#c.NPY_SIZEOF_INT&quot;&gt;&lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt;&lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt;), the len member also matches an equivalent member of the buffer object. It is useful to represent a generic single-segment chunk of memory.</source>
          <target state="translated">这等效于Python中直到ptr成员的缓冲区对象结构。在32位平台上（&lt;em&gt;即，&lt;/em&gt;如果&lt;a href=&quot;c-api.config#c.NPY_SIZEOF_INT&quot;&gt; &lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt; &lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt; ），len成员还匹配缓冲区对象的等效成员。表示通用的单段内存块很有用。</target>
        </trans-unit>
        <trans-unit id="4854fe34aab22a7dfbbaf3a63f41795215d42fdd" translate="yes" xml:space="preserve">
          <source>This is equivalent to the buffer object structure in Python up to the ptr member. On 32-bit platforms (&lt;em&gt;i.e.&lt;/em&gt; if &lt;a href=&quot;config#c.NPY_SIZEOF_INT&quot;&gt;&lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt;&lt;/a&gt; == &lt;a href=&quot;config#c.NPY_SIZEOF_INTP&quot;&gt;&lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt;&lt;/a&gt;), the len member also matches an equivalent member of the buffer object. It is useful to represent a generic single-segment chunk of memory.</source>
          <target state="translated">这等效于Python中直到ptr成员的缓冲区对象结构。在32位平台上（&lt;em&gt;即，&lt;/em&gt;如果&lt;a href=&quot;config#c.NPY_SIZEOF_INT&quot;&gt; &lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt; &lt;/a&gt; == &lt;a href=&quot;config#c.NPY_SIZEOF_INTP&quot;&gt; &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt; &lt;/a&gt;），len成员还匹配缓冲区对象的等效成员。表示通用的单段内存块很有用。</target>
        </trans-unit>
        <trans-unit id="0f80c76f4b696fc66848fb5ef4ea2fb36f89e0f9" translate="yes" xml:space="preserve">
          <source>This is equivalent to the buffer object structure in Python up to the ptr member. On 32-bit platforms (&lt;em&gt;i.e.&lt;/em&gt; if &lt;a href=&quot;config#c.NPY_SIZEOF_INT&quot;&gt;&lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt;&lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt;), the len member also matches an equivalent member of the buffer object. It is useful to represent a generic single-segment chunk of memory.</source>
          <target state="translated">这等效于Python中直到ptr成员的缓冲区对象结构。在32位平台上（&lt;em&gt;即，&lt;/em&gt;如果&lt;a href=&quot;config#c.NPY_SIZEOF_INT&quot;&gt; &lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt; &lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt; ），len成员还匹配缓冲区对象的等效成员。表示通用的单段内存块很有用。</target>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">这相当于:</target>
        </trans-unit>
        <trans-unit id="71a0da6263af85d6d95df709a66cce1cab814a13" translate="yes" xml:space="preserve">
          <source>This is for output arrays, and requires that the flag &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt;&lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt;&lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt;&lt;/a&gt; be set. If &lt;code&gt;op[i]&lt;/code&gt; is NULL, creates a new array with the final broadcast dimensions, and a layout matching the iteration order of the iterator.</source>
          <target state="translated">这是针对输出数组的，要求设置标志&lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt; &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt; &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;op[i]&lt;/code&gt; 为NULL，则创建一个具有最终广播尺寸的新数组，以及一个与迭代器的迭代顺序匹配的布局。</target>
        </trans-unit>
        <trans-unit id="e43476e1c5b08d4915c75da838fbd060f4d5522a" translate="yes" xml:space="preserve">
          <source>This is how subclasses of the ndarray class are able to return views that preserve the class type. When taking a view, the standard ndarray machinery creates the new ndarray object with something like:</source>
          <target state="translated">这就是ndarray类的子类如何能够返回保留类类型的视图。当取一个视图时,标准的ndarray机械会创建新的ndarray对象,其内容类似。</target>
        </trans-unit>
        <trans-unit id="271064c73ce5e7dc4de339611f7b4db1a780a7f2" translate="yes" xml:space="preserve">
          <source>This is implemented using the &lt;code&gt;_geev&lt;/code&gt; LAPACK routines which compute the eigenvalues and eigenvectors of general square arrays.</source>
          <target state="translated">这是使用 &lt;code&gt;_geev&lt;/code&gt; LAPACK例程实现的，该例程计算通用方阵的特征值和特征向量。</target>
        </trans-unit>
        <trans-unit id="caec4ff4a054237a51c7a499531b302398f70bf8" translate="yes" xml:space="preserve">
          <source>This is indicated in the documentation via input parameter specifications such as &lt;code&gt;a : (..., M, M) array_like&lt;/code&gt;. This means that if for instance given an input array &lt;code&gt;a.shape == (N, M, M)&lt;/code&gt;, it is interpreted as a &amp;ldquo;stack&amp;rdquo; of N matrices, each of size M-by-M. Similar specification applies to return values, for instance the determinant has &lt;code&gt;det : (...)&lt;/code&gt; and will in this case return an array of shape &lt;code&gt;det(a).shape == (N,)&lt;/code&gt;. This generalizes to linear algebra operations on higher-dimensional arrays: the last 1 or 2 dimensions of a multidimensional array are interpreted as vectors or matrices, as appropriate for each operation.</source>
          <target state="translated">这在文档中通过输入参数规范来指示，例如 &lt;code&gt;a : (..., M, M) array_like&lt;/code&gt; 。这意味着，例如，如果给定输入数组 &lt;code&gt;a.shape == (N, M, M)&lt;/code&gt; ，则将其解释为N个矩阵的&amp;ldquo;堆栈&amp;rdquo;，每个矩阵的大小为M&amp;times;M。类似的规范适用于返回值，例如行列式具有 &lt;code&gt;det : (...)&lt;/code&gt; ，在这种情况下将返回一个形状为 &lt;code&gt;det(a).shape == (N,)&lt;/code&gt; 的数组。这可以概括为对高维数组的线性代数运算：多维数组的最后1或2维被视作矢量或矩阵，视每个运算而定。</target>
        </trans-unit>
        <trans-unit id="142401db7b88684f56ec37cbd8f1ca65b6bf6771" translate="yes" xml:space="preserve">
          <source>This is intended for working with source directories that are in an SVN repository.</source>
          <target state="translated">这是为处理SVN仓库中的源目录而设计的。</target>
        </trans-unit>
        <trans-unit id="2fa46c7f117cac1c645f428d7403c2f212b4011c" translate="yes" xml:space="preserve">
          <source>This is like the builtin &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#issubclass&quot;&gt;&lt;code&gt;issubclass&lt;/code&gt;&lt;/a&gt;, but for &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">这就像内置的&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#issubclass&quot;&gt; &lt;code&gt;issubclass&lt;/code&gt; &lt;/a&gt;，但&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;秒。</target>
        </trans-unit>
        <trans-unit id="f497c1d2afa9510500c0e5d52cafff444023b2a6" translate="yes" xml:space="preserve">
          <source>This is needed by all Python objects. It consists of (at least) a reference count member ( &lt;code&gt;ob_refcnt&lt;/code&gt; ) and a pointer to the typeobject ( &lt;code&gt;ob_type&lt;/code&gt; ). (Other elements may also be present if Python was compiled with special options see Include/object.h in the Python source tree for more information). The ob_type member points to a Python type object.</source>
          <target state="translated">所有Python对象都需要这样做。它至少由一个引用计数成员（ &lt;code&gt;ob_refcnt&lt;/code&gt; ）和一个指向类型对象的指针（ &lt;code&gt;ob_type&lt;/code&gt; ）组成。（如果使用特殊选项编译Python，则其他元素也可能存在，有关更多信息，请参见Python源代码树中的Include / object.h）。ob_type成员指向Python类型对象。</target>
        </trans-unit>
        <trans-unit id="1833467ed646c8f15235c25f8dda305acdfb6a3c" translate="yes" xml:space="preserve">
          <source>This is not a comprehensive &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; reference. It&amp;rsquo;s tailored to the &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; hosting service. You may well find better or quicker ways of getting stuff done with &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;, but these should get you started.</source>
          <target state="translated">这不是全面的&lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;参考。它是为&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;托管服务量身定制的。您可能会找到更好或更快的方法来用&lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;完成工作，但是这些应该可以帮助您入门。</target>
        </trans-unit>
        <trans-unit id="d2a35d83e287759b7b772b39fa92c000861d127f" translate="yes" xml:space="preserve">
          <source>This is often used when a function returns multiple values:</source>
          <target state="translated">当一个函数返回多个值时,经常会用到这一点。</target>
        </trans-unit>
        <trans-unit id="daec8aebc5133f38a1a0c690c98645fa0bf3cd6e" translate="yes" xml:space="preserve">
          <source>This is particularly useful for evaluating functions of multiple dimensions on a regular grid.</source>
          <target state="translated">这对于评估规则网格上的多维函数特别有用。</target>
        </trans-unit>
        <trans-unit id="26d53d8ee495c7f638b914dab0d30642c949b736" translate="yes" xml:space="preserve">
          <source>This is presumably the most common case of large array creation. The details, of course, depend greatly on the format of data on disk and so this section can only give general pointers on how to handle various formats.</source>
          <target state="translated">这大概是最常见的创建大型阵列的情况。当然,具体的细节很大程度上取决于磁盘上的数据格式,所以本节只能就如何处理各种格式给出一般性的提示。</target>
        </trans-unit>
        <trans-unit id="dd8997d00c105166c9b4b9f773f5d0cdd6fa01f2" translate="yes" xml:space="preserve">
          <source>This is raised when an binary operation is passed Poly objects with different domains.</source>
          <target state="translated">当二进制操作被传递给具有不同域的Poly对象时,会引发此问题。</target>
        </trans-unit>
        <trans-unit id="e57f721854d8f362e4016c48c315f6301f247f80" translate="yes" xml:space="preserve">
          <source>This is really &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt; with different defaults. For more details see &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用不同的默认值确实很&lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt; &lt;code&gt;irfftn&lt;/code&gt; &lt;/a&gt;。有关更多详细信息，请参见&lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt; &lt;code&gt;irfftn&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed9f359368f007790ca5657cc8ec4082492a200b" translate="yes" xml:space="preserve">
          <source>This is really just &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt; with different default behavior. For more details see &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这实际上只是具有不同默认行为的&lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt;。有关更多详细信息，请参见&lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="77938c782ff5f0e5fde7cba046a7d880a01771f8" translate="yes" xml:space="preserve">
          <source>This is reasonable enough, but watch out if you want to use Python&amp;rsquo;s &lt;code&gt;+=&lt;/code&gt; construct, as it may not do what you expect:</source>
          <target state="translated">这足够合理，但是请注意是否要使用Python的 &lt;code&gt;+=&lt;/code&gt; 构造，因为它可能无法满足您的期望：</target>
        </trans-unit>
        <trans-unit id="5ef26806f6ea74b6485ab483c2778eff715e4572" translate="yes" xml:space="preserve">
          <source>This is short-hand for &lt;code&gt;np.r_['-1,2,0', index expression]&lt;/code&gt;, which is useful because of its common occurrence. In particular, arrays will be stacked along their last axis after being upgraded to at least 2-D with 1&amp;rsquo;s post-pended to the shape (column vectors made out of 1-D arrays).</source>
          <target state="translated">这是 &lt;code&gt;np.r_['-1,2,0', index expression]&lt;/code&gt; ，因为它很常见，所以很有用。特别是，在将阵列升级到至少2维且其后缀为1的形状（列矢量由1维阵列组成）之后，阵列将沿其最后一个轴堆叠。</target>
        </trans-unit>
        <trans-unit id="1c88394abdc65a1b05a8dd5d8683693375531a89" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) except you specify the data-type descriptor with &lt;em&gt;type_num&lt;/em&gt; and &lt;em&gt;itemsize&lt;/em&gt;, where &lt;em&gt;type_num&lt;/em&gt; corresponds to a builtin (or user-defined) type. If the type always has the same number of bytes, then itemsize is ignored. Otherwise, itemsize specifies the particular size of this array.</source>
          <target state="translated">这类似于&lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt;（&amp;hellip;），不同之处在于您使用&lt;em&gt;type_num&lt;/em&gt;和&lt;em&gt;itemsize&lt;/em&gt;指定数据类型描述符，其中&lt;em&gt;type_num&lt;/em&gt;对应于内置（或用户定义）类型。如果类型始终具有相同的字节数，则将忽略itemsize。否则，itemsize指定此数组的特定大小。</target>
        </trans-unit>
        <trans-unit id="ed43500d52b0e3a9d4bae70ddb5bfbe100ff1dd8" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;numpy.logspace#numpy.logspace&quot;&gt;&lt;code&gt;logspace&lt;/code&gt;&lt;/a&gt;, but with endpoints specified directly. Each output sample is a constant multiple of the previous.</source>
          <target state="translated">这类似于&lt;a href=&quot;numpy.logspace#numpy.logspace&quot;&gt; &lt;code&gt;logspace&lt;/code&gt; &lt;/a&gt;，但是直接指定了端点。每个输出样本是前一个样本的恒定倍数。</target>
        </trans-unit>
        <trans-unit id="c5fcd33629df929b0bdb1a57cfbe776ef13fe120" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;apply_along_axis&lt;/code&gt;, but treats the fields of a structured array as an extra axis. The fields are all first cast to a common type following the type-promotion rules from &lt;a href=&quot;../reference/generated/numpy.result_type#numpy.result_type&quot;&gt;&lt;code&gt;numpy.result_type&lt;/code&gt;&lt;/a&gt; applied to the field&amp;rsquo;s dtypes.</source>
          <target state="translated">这类似于 &lt;code&gt;apply_along_axis&lt;/code&gt; ，但是将结构化数组的字段视为额外的轴。首先&lt;a href=&quot;../reference/generated/numpy.result_type#numpy.result_type&quot;&gt; &lt;code&gt;numpy.result_type&lt;/code&gt; &lt;/a&gt;应用于字段dtype的numpy.result_type的类型提升规则，将所有字段都强制转换为通用类型。</target>
        </trans-unit>
        <trans-unit id="852b3e753a1b8cdcb6346c93877a110d2d715f72" translate="yes" xml:space="preserve">
          <source>This is similar to choose or select, except that functions are evaluated on elements of &lt;code&gt;x&lt;/code&gt; that satisfy the corresponding condition from &lt;code&gt;condlist&lt;/code&gt;.</source>
          <target state="translated">这类似于select或select，不同之处在于，对满足 &lt;code&gt;condlist&lt;/code&gt; 中相应条件的 &lt;code&gt;x&lt;/code&gt; 元素求值函数。</target>
        </trans-unit>
        <trans-unit id="2c3a50a4a39023a7aa06d7ec91f3ecdac2409160" translate="yes" xml:space="preserve">
          <source>This is the &amp;ldquo;average&amp;rdquo; periodically compounded rate of return that gives a net present value of 0.0; for a more complete explanation, see Notes below.</source>
          <target state="translated">这是&amp;ldquo;平均&amp;rdquo;定期复合回报率，其净现值为0.0。有关更完整的说明，请参见下面的注释。</target>
        </trans-unit>
        <trans-unit id="0dbc891d865ae88284f9bfa0a0edbf0c765484c8" translate="yes" xml:space="preserve">
          <source>This is the 1-d core function used by the dynamic ufuncs created by umath.frompyfunc(function, nin, nout). In this case &lt;em&gt;func&lt;/em&gt; is a pointer to a &lt;a href=&quot;#c.PyUFunc_PyFuncData&quot;&gt;&lt;code&gt;PyUFunc_PyFuncData&lt;/code&gt;&lt;/a&gt; structure which has definition</source>
          <target state="translated">这是umath.frompyfunc（function，nin，nout）创建的动态ufunc使用的一维核心函数。在这种情况下，&lt;em&gt;func&lt;/em&gt;是指向具有定义的&lt;a href=&quot;#c.PyUFunc_PyFuncData&quot;&gt; &lt;code&gt;PyUFunc_PyFuncData&lt;/code&gt; &lt;/a&gt;结构的指针</target>
        </trans-unit>
        <trans-unit id="692a8cf195747eb5dfe92c87d684aef132c27f68" translate="yes" xml:space="preserve">
          <source>This is the NumPy implementation of the C library function fmod, the remainder has the same sign as the dividend &lt;code&gt;x1&lt;/code&gt;. It is equivalent to the Matlab(TM) &lt;code&gt;rem&lt;/code&gt; function and should not be confused with the Python modulus operator &lt;code&gt;x1 % x2&lt;/code&gt;.</source>
          <target state="translated">这是C库函数fmod的NumPy实现，其余部分与被除数 &lt;code&gt;x1&lt;/code&gt; 具有相同的符号。它等效于Matlab&amp;trade; &lt;code&gt;rem&lt;/code&gt; 函数，不应与Python模运算符 &lt;code&gt;x1 % x2&lt;/code&gt; 混淆。</target>
        </trans-unit>
        <trans-unit id="9f70c1d8b15029e4bba377d8eb228f8ad3621041" translate="yes" xml:space="preserve">
          <source>This is the code that handles the situation whenever the input and/or output arrays are either misaligned or of the wrong data-type (including being byte-swapped) from what the underlying 1-D loop expects. The arrays are also assumed to be non-contiguous. The code works very much like the strided-loop except for the inner 1-D loop is modified so that pre-processing is performed on the inputs and post- processing is performed on the outputs in bufsize chunks (where bufsize is a user-settable parameter). The underlying 1-D computational loop is called on data that is copied over (if it needs to be). The setup code and the loop code is considerably more complicated in this case because it has to handle:</source>
          <target state="translated">这是处理输入和/或输出数组错位或数据类型错误(包括被字节交换)的情况的代码,与底层一维循环的期望值不同。数组也被假定为非连续的。这段代码的工作方式与strided-loop非常相似,除了内部的1-D循环被修改为在输入上进行预处理,在输出上以bufsize块的形式进行后处理(其中bufsize是一个用户可设置的参数)。底层的一维计算循环会对复制过来的数据进行调用(如果需要的话)。在这种情况下,设置代码和循环代码要复杂得多,因为它必须处理。</target>
        </trans-unit>
        <trans-unit id="97fdbbb09a00c84ec3c672ccc77676c7df568ed7" translate="yes" xml:space="preserve">
          <source>This is the docstring for the example.py module. Modules names should have short, all-lowercase names. The module name may have underscores if this improves readability.</source>
          <target state="translated">这是example.py模块的docstring。模块名应该是短小的,全小写的。如果能提高可读性,模块名可以用下划线。</target>
        </trans-unit>
        <trans-unit id="938b03b0272fe214e0bd4545d8c331ea33459bae" translate="yes" xml:space="preserve">
          <source>This is the exact same method signature for &lt;code&gt;np.sum&lt;/code&gt;, so now if a user calls &lt;code&gt;np.sum&lt;/code&gt; on this object, numpy will call the object&amp;rsquo;s own &lt;code&gt;sum&lt;/code&gt; method and pass in these arguments enumerated above in the signature, and no errors will be raised because the signatures are completely compatible with each other.</source>
          <target state="translated">这与 &lt;code&gt;np.sum&lt;/code&gt; 的方法签名完全相同，因此，如果用户在此对象上调用 &lt;code&gt;np.sum&lt;/code&gt; ，则numpy将调用该对象自己的 &lt;code&gt;sum&lt;/code&gt; 方法并传入签名中上面枚举的这些参数，并且不会引发任何错误。因为签名彼此完全兼容。</target>
        </trans-unit>
        <trans-unit id="754ab86dfdc616fd9f3289ae80c9fb161f6f47b6" translate="yes" xml:space="preserve">
          <source>This is the main array creation function. Most new arrays are created with this flexible function.</source>
          <target state="translated">这是主要的数组创建函数。大多数新的数组都是用这个灵活的函数创建的。</target>
        </trans-unit>
        <trans-unit id="ae96a364309b5dfa1ba1a5f179699cc1e3ea0752" translate="yes" xml:space="preserve">
          <source>This is the main function used to obtain an array from any nested sequence, or object that exposes the array interface, &lt;em&gt;op&lt;/em&gt;. The parameters allow specification of the required &lt;em&gt;dtype&lt;/em&gt;, the minimum (&lt;em&gt;min_depth&lt;/em&gt;) and maximum (&lt;em&gt;max_depth&lt;/em&gt;) number of dimensions acceptable, and other &lt;em&gt;requirements&lt;/em&gt; for the array. This function &lt;strong&gt;steals a reference&lt;/strong&gt; to the dtype argument, which needs to be a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure indicating the desired data-type (including required byteorder). The &lt;em&gt;dtype&lt;/em&gt; argument may be &lt;code&gt;NULL&lt;/code&gt;, indicating that any data-type (and byteorder) is acceptable. Unless &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt; is present in &lt;code&gt;flags&lt;/code&gt;, this call will generate an error if the data type cannot be safely obtained from the object. If you want to use &lt;code&gt;NULL&lt;/code&gt; for the &lt;em&gt;dtype&lt;/em&gt; and ensure the array is notswapped then use &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt;&lt;code&gt;PyArray_CheckFromAny&lt;/code&gt;&lt;/a&gt;. A value of 0 for either of the depth parameters causes the parameter to be ignored. Any of the following array flags can be added (&lt;em&gt;e.g.&lt;/em&gt; using |) to get the &lt;em&gt;requirements&lt;/em&gt; argument. If your code can handle general (&lt;em&gt;e.g.&lt;/em&gt; strided, byte-swapped, or unaligned arrays) then &lt;em&gt;requirements&lt;/em&gt; may be 0. Also, if &lt;em&gt;op&lt;/em&gt; is not already an array (or does not expose the array interface), then a new array will be created (and filled from &lt;em&gt;op&lt;/em&gt; using the sequence protocol). The new array will have &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; as its flags member. The &lt;em&gt;context&lt;/em&gt; argument is passed to the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method of &lt;em&gt;op&lt;/em&gt; and is only used if the array is constructed that way. Almost always this parameter is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">这是用于从任何嵌套序列或公开数组接口&lt;em&gt;op的&lt;/em&gt;对象获取数组的主要功能。参数允许所需的规格&lt;em&gt;D型细胞&lt;/em&gt;，最小（&lt;em&gt;min_depth&lt;/em&gt;）和最大值（&lt;em&gt;MAX_DEPTH&lt;/em&gt;尺寸上可接受的）号码，以及其它&lt;em&gt;的要求&lt;/em&gt;对阵列。此函数&lt;strong&gt;窃取&lt;/strong&gt;对dtype参数&lt;strong&gt;的引用&lt;/strong&gt;，该&lt;strong&gt;引用&lt;/strong&gt;必须是&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;结构，以指示所需的数据类型（包括所需的字节序）。的&lt;em&gt;D型&lt;/em&gt;参数可以是 &lt;code&gt;NULL&lt;/code&gt; ，表示任何数据类型（和字节顺序）是可接受的。除非&lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt; &lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt; &lt;/a&gt;如果 &lt;code&gt;flags&lt;/code&gt; 中存在，则如果不能从对象安全地获取数据类型，则此调用将产生错误。如果你想使用 &lt;code&gt;NULL&lt;/code&gt; 的&lt;em&gt;D型&lt;/em&gt;和保证阵列notswapped然后使用&lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt; &lt;code&gt;PyArray_CheckFromAny&lt;/code&gt; &lt;/a&gt;。任一深度参数的值0都会导致忽略该参数。可以添加以下任何数组标志（&lt;em&gt;例如，&lt;/em&gt;使用|）以获取&lt;em&gt;需求&lt;/em&gt;参数。如果您的代码可以处理常规代码（&lt;em&gt;例如，&lt;/em&gt;跨步，字节交换或未对齐的数组），则&lt;em&gt;要求&lt;/em&gt;可能为0。此外，如果&lt;em&gt;op&lt;/em&gt;还不是数组（或不公开数组接口），则将创建一个新数组（并使用序列协议从&lt;em&gt;op&lt;/em&gt;填充）。新数组将以&lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; &lt;/a&gt;作为其flags成员。的&lt;em&gt;上下文&lt;/em&gt;参数被传递给&lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;的方法&lt;em&gt;运算&lt;/em&gt;，如果该阵列被构造这种方式仅使用。这个参数几乎总是 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ef891de4e312961f5d43ee05c17aa291119de54" translate="yes" xml:space="preserve">
          <source>This is the main function used to obtain an array from any nested sequence, or object that exposes the array interface, &lt;em&gt;op&lt;/em&gt;. The parameters allow specification of the required &lt;em&gt;dtype&lt;/em&gt;, the minimum (&lt;em&gt;min_depth&lt;/em&gt;) and maximum (&lt;em&gt;max_depth&lt;/em&gt;) number of dimensions acceptable, and other &lt;em&gt;requirements&lt;/em&gt; for the array. This function &lt;strong&gt;steals a reference&lt;/strong&gt; to the dtype argument, which needs to be a &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure indicating the desired data-type (including required byteorder). The &lt;em&gt;dtype&lt;/em&gt; argument may be &lt;code&gt;NULL&lt;/code&gt;, indicating that any data-type (and byteorder) is acceptable. Unless &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt; is present in &lt;code&gt;flags&lt;/code&gt;, this call will generate an error if the data type cannot be safely obtained from the object. If you want to use &lt;code&gt;NULL&lt;/code&gt; for the &lt;em&gt;dtype&lt;/em&gt; and ensure the array is notswapped then use &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt;&lt;code&gt;PyArray_CheckFromAny&lt;/code&gt;&lt;/a&gt;. A value of 0 for either of the depth parameters causes the parameter to be ignored. Any of the following array flags can be added (&lt;em&gt;e.g.&lt;/em&gt; using |) to get the &lt;em&gt;requirements&lt;/em&gt; argument. If your code can handle general (&lt;em&gt;e.g.&lt;/em&gt; strided, byte-swapped, or unaligned arrays) then &lt;em&gt;requirements&lt;/em&gt; may be 0. Also, if &lt;em&gt;op&lt;/em&gt; is not already an array (or does not expose the array interface), then a new array will be created (and filled from &lt;em&gt;op&lt;/em&gt; using the sequence protocol). The new array will have &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; as its flags member. The &lt;em&gt;context&lt;/em&gt; argument is unused.</source>
          <target state="translated">这是用于从任何嵌套序列或公开数组接口&lt;em&gt;op的&lt;/em&gt;对象获取数组的主要功能。参数允许所需的规格&lt;em&gt;D型细胞&lt;/em&gt;，最小（&lt;em&gt;min_depth&lt;/em&gt;）和最大值（&lt;em&gt;MAX_DEPTH&lt;/em&gt;尺寸上可接受的）号码，以及其它&lt;em&gt;的要求&lt;/em&gt;对阵列。该函数&lt;strong&gt;窃取了对&lt;/strong&gt;&lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;参数&lt;strong&gt;的引用&lt;/strong&gt;，该&lt;strong&gt;引用&lt;/strong&gt;必须是一个PyArray_Descr结构，该结构指示所需的数据类型（包括所需的字节序）。的&lt;em&gt;D型&lt;/em&gt;参数可以是 &lt;code&gt;NULL&lt;/code&gt; ，表示任何数据类型（和字节顺序）是可接受的。除非&lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt; &lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt; &lt;/a&gt;如果 &lt;code&gt;flags&lt;/code&gt; 中存在，则如果不能从对象安全地获取数据类型，则此调用将产生错误。如果你想使用 &lt;code&gt;NULL&lt;/code&gt; 的&lt;em&gt;D型&lt;/em&gt;和保证阵列notswapped然后使用&lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt; &lt;code&gt;PyArray_CheckFromAny&lt;/code&gt; &lt;/a&gt;。任一深度参数的值0都会导致忽略该参数。可以添加以下任何数组标志（&lt;em&gt;例如，&lt;/em&gt;使用|），以获取&lt;em&gt;需求&lt;/em&gt;参数。如果您的代码可以处理常规代码（&lt;em&gt;例如，&lt;/em&gt;跨步，字节交换或未对齐的数组），则&lt;em&gt;要求&lt;/em&gt;可能为0。此外，如果&lt;em&gt;op&lt;/em&gt;还不是数组（或不公开数组接口），则将创建一个新数组（并使用序列协议从&lt;em&gt;op&lt;/em&gt;填充）。新数组将以&lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; &lt;/a&gt;作为其flags成员。该&lt;em&gt;情境&lt;/em&gt;的说法是不使用的。</target>
        </trans-unit>
        <trans-unit id="0edcab26afcb3f2afd03c8c948c52b8fae9f82e5" translate="yes" xml:space="preserve">
          <source>This is the manual followed by NumPy&amp;rsquo;s Code of Conduct Committee. It&amp;rsquo;s used when we respond to an issue to make sure we&amp;rsquo;re consistent and fair.</source>
          <target state="translated">这是NumPy行为准则委员会遵循的手册。当我们对问题做出回应时，可以使用它来确保我们保持一致和公正。</target>
        </trans-unit>
        <trans-unit id="5ec8c6b5a6fa5ea604ca73fde0faa7f48e61f60d" translate="yes" xml:space="preserve">
          <source>This is the masked array version of &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt;. For details see &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt;的掩码数组版本。有关详细信息，请参见&lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5b5fdafede3bb67234ee18c22a5b997e8095961" translate="yes" xml:space="preserve">
          <source>This is the masked array version of &lt;code&gt;lib.index_tricks.RClass&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;lib.index_tricks.RClass&lt;/code&gt; 的掩码数组版本。</target>
        </trans-unit>
        <trans-unit id="bf3cf3ae9cebee8b7306a5e44915e23de00facf1" translate="yes" xml:space="preserve">
          <source>This is the masked equivalent of the &lt;a href=&quot;numpy.resize#numpy.resize&quot;&gt;&lt;code&gt;numpy.resize&lt;/code&gt;&lt;/a&gt; function. The new array is filled with repeated copies of &lt;code&gt;x&lt;/code&gt; (in the order that the data are stored in memory). If &lt;code&gt;x&lt;/code&gt; is masked, the new array will be masked, and the new mask will be a repetition of the old one.</source>
          <target state="translated">这是&lt;a href=&quot;numpy.resize#numpy.resize&quot;&gt; &lt;code&gt;numpy.resize&lt;/code&gt; &lt;/a&gt;函数的掩码等效项。新数组中填充了 &lt;code&gt;x&lt;/code&gt; 的重复副本（以数据存储在内存中的顺序）。如果 &lt;code&gt;x&lt;/code&gt; 被屏蔽，新的数组将被屏蔽，新的掩码将是旧数组的重复。</target>
        </trans-unit>
        <trans-unit id="0cb42e32affa717b335b3825c72824c3d8e04997" translate="yes" xml:space="preserve">
          <source>This is the most flexible form of specification since it allows control over the byte-offsets of the fields and the itemsize of the structure.</source>
          <target state="translated">这是最灵活的规范形式,因为它允许控制字段的字节偏移量和结构的项目大小。</target>
        </trans-unit>
        <trans-unit id="e638e46153cb5bd9d2b2cfadb202d5a4f7f60071" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;ndarray.all&lt;/code&gt;&lt;/a&gt;, but it returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;ndarray.all&lt;/code&gt; &lt;/a&gt;相同，但是它返回一个&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="b28c44c91a00424416f03ba6b4985acf74627eb2" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt; would return an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; &lt;/a&gt;相同，但是返回一个&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象，其中&lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; &lt;/a&gt;将返回一个&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22b8e33a3b4d40024b90c85a13a94be90c9158a1" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt; would return an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; &lt;/a&gt;相同，但是返回一个&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象，其中&lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; &lt;/a&gt;将返回一个&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1090f814c7b352e9c36a05ce2322d963cddbde3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt; would return an ndarray.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; &lt;/a&gt;相同，但是返回一个&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象，其中&lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; &lt;/a&gt;将返回一个ndarray。</target>
        </trans-unit>
        <trans-unit id="74e44d918d1f15516605ec010845ff539cc17530" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt; would return an ndarray.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; &lt;/a&gt;相同，但是返回一个&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象，其中&lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; &lt;/a&gt;将返回一个ndarray。</target>
        </trans-unit>
        <trans-unit id="124e720446d4f3612122d427a64991837042df14" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.std#numpy.ndarray.std&quot;&gt;&lt;code&gt;ndarray.std&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.std#numpy.ndarray.std&quot;&gt; &lt;code&gt;ndarray.std&lt;/code&gt; &lt;/a&gt;相同，除了返回&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 的&lt;/a&gt;地方是返回&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="a0acdb03a11a0405720f9b33ec10bd3e67d6e4fa" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt;&lt;code&gt;ndarray.sum&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt; &lt;code&gt;ndarray.sum&lt;/code&gt; &lt;/a&gt;相同，除了返回&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 的&lt;/a&gt;地方是返回&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="1b894bff66f53b91713c65daaeb95b50cb72fdfc" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.var#numpy.ndarray.var&quot;&gt;&lt;code&gt;ndarray.var&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.var#numpy.ndarray.var&quot;&gt; &lt;code&gt;ndarray.var&lt;/code&gt; &lt;/a&gt;相同，除了返回&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 的&lt;/a&gt;地方是返回&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="d6c0a4b3ef29201f690f9b9b88a69b8608d63748" translate="yes" xml:space="preserve">
          <source>This is the same for half-precision float as npy_nextafter and npy_nextafterf described in the low-level floating point section.</source>
          <target state="translated">这与低级浮点部分描述的npy_nextafter和npy_nextafterf对半精度浮点来说是一样的。</target>
        </trans-unit>
        <trans-unit id="5a28a11e64cd4476f1fd45344cb04aff7bece602" translate="yes" xml:space="preserve">
          <source>This is the same for half-precision float as npy_spacing and npy_spacingf described in the low-level floating point section.</source>
          <target state="translated">这与低级浮点部分描述的npy_spacing和npy_spacingf对于半精度浮点是一样的。</target>
        </trans-unit>
        <trans-unit id="69592e67862b42a94f582425221058b3b2e662f2" translate="yes" xml:space="preserve">
          <source>This is the same polynomial as obtained by:</source>
          <target state="translated">这与下列方法得到的多项式相同:</target>
        </trans-unit>
        <trans-unit id="8f841f69094513c4d7f4558bcdd113fb62e5f1f7" translate="yes" xml:space="preserve">
          <source>This is the simplest case of all. The ufunc is executed by calling the underlying 1-D loop exactly once. This is possible only when we have aligned data of the correct type (including byte-order) for both input and output and all arrays have uniform strides (either contiguous, 0-D, or 1-D). In this case, the 1-D computational loop is called once to compute the calculation for the entire array. Note that the hardware error flags are only checked after the entire calculation is complete.</source>
          <target state="translated">这是最简单的情况。ufunc通过调用底层的1-D循环精确地执行一次。只有当我们的输入和输出都有正确类型的对齐数据(包括字节顺序),并且所有的数组都有统一的步长(连续、0-D或1-D)时,这才是可能的。在这种情况下,1-D计算循环会被调用一次来计算整个数组的计算。需要注意的是,只有在整个计算完成后才会检查硬件错误标志。</target>
        </trans-unit>
        <trans-unit id="963cd66868f04208a7a1c2183e363716e0ef0cf2" translate="yes" xml:space="preserve">
          <source>This is the type which exposes the iterator to Python. Currently, no API is exposed which provides access to the values of a Python-created iterator. If an iterator is created in Python, it must be used in Python and vice versa. Such an API will likely be created in a future version.</source>
          <target state="translated">这是一个向 Python 公开迭代器的类型。目前,还没有暴露出任何 API 来提供对 Python 创建的迭代器值的访问。如果一个迭代器是在 Python 中创建的,那么它必须在 Python 中使用,反之亦然。这样的 API 可能会在未来的版本中被创建。</target>
        </trans-unit>
        <trans-unit id="4b42439256132aabca2f53b261c973f7c679d369" translate="yes" xml:space="preserve">
          <source>This is useful for setting up an accumulation loop, for example. The iterator can first be created with all the dimensions, including the accumulation axis, so that the output gets created correctly. Then, the accumulation axis can be removed, and the calculation done in a nested fashion.</source>
          <target state="translated">例如,这对于设置一个累积循环很有用。迭代器可以首先创建所有的维度,包括累加轴,以便正确创建输出。然后,累积轴可以被移除,并以嵌套的方式进行计算。</target>
        </trans-unit>
        <trans-unit id="5300cb088270de52a08527e24f73ff59ea30c2bb" translate="yes" xml:space="preserve">
          <source>This is useful in a setup.py script for adding sub-packages to a package.</source>
          <target state="translated">这在setup.py脚本中很有用,可以将子包添加到一个包中。</target>
        </trans-unit>
        <trans-unit id="6e4aa46e2220dff2f0d0703b94a0af6befef5473" translate="yes" xml:space="preserve">
          <source>This is wonderful because the function writer doesn&amp;rsquo;t have to manually propagate infs or nans.</source>
          <target state="translated">这很棒，因为函数编写者不必手动传播infs或nans。</target>
        </trans-unit>
        <trans-unit id="82959a96175cd052449eddf58c5c4610e0b21bd3" translate="yes" xml:space="preserve">
          <source>This iterates over matching 1d slices oriented along the specified axis in the index and data arrays, and uses the former to look up values in the latter. These slices can be different lengths.</source>
          <target state="translated">它迭代索引和数据数组中沿指定轴方向的匹配的1d切片,并使用前者查找后者中的值。这些切片可以是不同的长度。</target>
        </trans-unit>
        <trans-unit id="5c175a7e11a936be20457fa33dc8778b062c8741" translate="yes" xml:space="preserve">
          <source>This iterates over matching 1d slices oriented along the specified axis in the index and data arrays, and uses the former to place values into the latter. These slices can be different lengths.</source>
          <target state="translated">它迭代索引和数据数组中沿指定轴方向的匹配的1d切片,并使用前者将值放入后者。这些切片可以是不同的长度。</target>
        </trans-unit>
        <trans-unit id="1d9086a3e8f6e523e455adb859a4bc6cbea3019a" translate="yes" xml:space="preserve">
          <source>This iterator returns elements of the array to be iterated over in &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt;&lt;code&gt;Arrayterator&lt;/code&gt;&lt;/a&gt; one by one. It is similar to &lt;code&gt;flatiter&lt;/code&gt;.</source>
          <target state="translated">此迭代器返回要在&lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt; &lt;code&gt;Arrayterator&lt;/code&gt; 中&lt;/a&gt;一一进行迭代的数组元素。它类似于 &lt;code&gt;flatiter&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3aa62850b827d280ac62636d6a8e3df18a980ad" translate="yes" xml:space="preserve">
          <source>This just returns the value &lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt;&lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt;&lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt;&lt;/a&gt; changes whenever the API changes (e.g. a function is added). A changed value does not always require a recompile.</source>
          <target state="translated">这只是返回值&lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt; &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; &lt;/a&gt;。每当API更改（例如，添加功能）时，&lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt; &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; &lt;/a&gt;都会更改。更改的值并不总是需要重新编译。</target>
        </trans-unit>
        <trans-unit id="9621dd1cff206294072ec88c5bdff12776a1ac23" translate="yes" xml:space="preserve">
          <source>This just returns the value &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; changes whenever a backward incompatible change at the ABI level. Because it is in the C-API, however, comparing the output of this function from the value defined in the current header gives a way to test if the C-API has changed thus requiring a re-compilation of extension modules that use the C-API. This is automatically checked in the function &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这仅返回值&lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt;。只要在ABI级别上向后不兼容更改，&lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt;就会更改。由于它在C-API中，因此，将此函数的输出与当前标头中定义的值进行比较，可以测试C-API是否已更改，因此需要重新编译使用C的扩展模块。 -API。这是在函数&lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; 中&lt;/a&gt;自动检查的。</target>
        </trans-unit>
        <trans-unit id="75e16e673218df8f16a0a1029a429a437c420b9d" translate="yes" xml:space="preserve">
          <source>This just returns the value &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt;. &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; changes whenever the API changes (e.g. a function is added). A changed value does not always require a recompile.</source>
          <target state="translated">这只是返回值 &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; 。每当API更改（例如，添加功能）时， &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; 都会更改。更改的值并不总是需要重新编译。</target>
        </trans-unit>
        <trans-unit id="57131d2cbf8754e0c0045e65c405a8ff98703b38" translate="yes" xml:space="preserve">
          <source>This macro is defined to +inf.</source>
          <target state="translated">此宏定义为+inf。</target>
        </trans-unit>
        <trans-unit id="8ca63ad5bc4e1dded64f0ca2a056ab5d5c7f090f" translate="yes" xml:space="preserve">
          <source>This macro is defined to -1.0.</source>
          <target state="translated">此宏定义为-1.0。</target>
        </trans-unit>
        <trans-unit id="b30ee77ae33429489972a6d1172613ede0e766a9" translate="yes" xml:space="preserve">
          <source>This macro is defined to -inf.</source>
          <target state="translated">此宏定义为-inf。</target>
        </trans-unit>
        <trans-unit id="b8842c8583817136af82824b8e5fdbb3f9c76f6e" translate="yes" xml:space="preserve">
          <source>This macro is defined to 1.0.</source>
          <target state="translated">该宏定义为1.0。</target>
        </trans-unit>
        <trans-unit id="bd01732ce89574cb085cbbd769f60ac683ce37ab" translate="yes" xml:space="preserve">
          <source>This macro is defined to a NaN (Not a Number), and is guaranteed to have the signbit unset (&amp;lsquo;positive&amp;rsquo; NaN). The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">此宏定义为NaN（非数字），并确保未设置符号位（&amp;ldquo;正&amp;rdquo; NaN）。带有后缀F和L的是相应的单精度和扩展精度宏。</target>
        </trans-unit>
        <trans-unit id="305a7f44534276994ed187e38461a42eaeb6b275" translate="yes" xml:space="preserve">
          <source>This macro is defined to a NaN value, guaranteed to have its sign bit unset.</source>
          <target state="translated">该宏定义为NaN值,保证其符号位不被设置。</target>
        </trans-unit>
        <trans-unit id="15a2136199da842d310792facc84af7246036426" translate="yes" xml:space="preserve">
          <source>This macro is defined to a positive inf. The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">该宏定义为正向的信息。相应的单精度宏和扩展精度宏的后缀为F和L。</target>
        </trans-unit>
        <trans-unit id="c5ea17d1f0932fffe7fa9472293549c952ff5b71" translate="yes" xml:space="preserve">
          <source>This macro is defined to negative zero (that is with the sign bit set). The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">该宏定义为负零(即设置了符号位)。相应的单精度和扩展精度宏的后缀为F和L。</target>
        </trans-unit>
        <trans-unit id="28ffbdfd1fb5a238c0e6b132bd7b25e886a8862b" translate="yes" xml:space="preserve">
          <source>This macro is defined to negative zero.</source>
          <target state="translated">此宏定义为负零。</target>
        </trans-unit>
        <trans-unit id="6499719d1e23e1af1e93848438b61bc7bf9fb167" translate="yes" xml:space="preserve">
          <source>This macro is defined to positive zero.</source>
          <target state="translated">此宏定义为正零。</target>
        </trans-unit>
        <trans-unit id="c804fcf19685f98f19d42c1dc7c110945817d41e" translate="yes" xml:space="preserve">
          <source>This macro is defined to positive zero. The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">此宏定义为正零。相应的单精度和扩展精度宏都可以用后缀F和L来表示。</target>
        </trans-unit>
        <trans-unit id="4c35e4d492b4b66e88cf91e279bf815b9c6ef74c" translate="yes" xml:space="preserve">
          <source>This manual contains many examples of use, usually prefixed with the Python prompt &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; (which is not a part of the example code). The examples assume that you have first entered:</source>
          <target state="translated">本手册包含许多使用示例，通常以Python提示符 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 为前缀（这不是示例代码的一部分）。这些示例假定您首先输入：</target>
        </trans-unit>
        <trans-unit id="fc87f3907c86c15e0fab69c802c5a342d7203e00" translate="yes" xml:space="preserve">
          <source>This may be clearer with an example.</source>
          <target state="translated">举个例子可能会更清楚。</target>
        </trans-unit>
        <trans-unit id="bc3434d0927f2e6cdc4fb04c1ef64578863b34f8" translate="yes" xml:space="preserve">
          <source>This may be used to read an existing file or create a new one.</source>
          <target state="translated">这可以用来读取一个现有的文件或创建一个新的文件。</target>
        </trans-unit>
        <trans-unit id="bb4ec39a1dbea334a71074f67fa1cd07017f1cdf" translate="yes" xml:space="preserve">
          <source>This may be used when you want to match up operand axes in some fashion, then remove them with &lt;a href=&quot;#c.NpyIter_RemoveAxis&quot;&gt;&lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt;&lt;/a&gt; to handle their processing manually. By calling this function before removing the axes, you can get the strides for the manual processing.</source>
          <target state="translated">当您想以某种方式匹配操作数轴，然后使用&lt;a href=&quot;#c.NpyIter_RemoveAxis&quot;&gt; &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; &lt;/a&gt;删除它们以手动处理它们时，可以使用此方法。通过在拆下轴之前调用此函数，可以大步进行手动处理。</target>
        </trans-unit>
        <trans-unit id="c451240677ff61c1a609e49bd0f07f461a99c611" translate="yes" xml:space="preserve">
          <source>This may be used when you want to match up operand axes in some fashion, then remove them with &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; to handle their processing manually. By calling this function before removing the axes, you can get the strides for the manual processing.</source>
          <target state="translated">当您想以某种方式匹配操作数轴，然后使用 &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; 删除它们以手动处理它们时，可以使用此方法。通过在拆下轴之前调用此函数，您可以大步进行手动处理。</target>
        </trans-unit>
        <trans-unit id="272240144b37c5af402b352038a269eb5d08f543" translate="yes" xml:space="preserve">
          <source>This may mainly help you if you are not running the python and/or NumPy version you are expecting to run.</source>
          <target state="translated">这可能主要帮助你,如果你没有运行你期望运行的python和/或NumPy版本。</target>
        </trans-unit>
        <trans-unit id="c92d427e914a0dd599016040f8fd75a2d48dc062" translate="yes" xml:space="preserve">
          <source>This means that (i) we want to edit the commit message for &lt;code&gt;13d7934&lt;/code&gt;, and (ii) collapse the last three commits into one. Now we save and quit the editor.</source>
          <target state="translated">这意味着（i）我们要编辑 &lt;code&gt;13d7934&lt;/code&gt; 的提交消息，并且（ii）将最后三个提交合为一体。现在，我们保存并退出编辑器。</target>
        </trans-unit>
        <trans-unit id="c9eb6e1f385480cd888cdacc62c2f757c4de3926" translate="yes" xml:space="preserve">
          <source>This mechanism should support all compilers and it doesn&amp;rsquo;t require any compiler-specific extension, but at the same time it is adds a few steps to normal compilation that are explained as follows:</source>
          <target state="translated">该机制应该支持所有编译器，并且不需要任何特定于编译器的扩展，但是同时它为常规编译添加了一些步骤，解释如下：</target>
        </trans-unit>
        <trans-unit id="85b5c517a58e8aeec834229928a8cecac10d6dff" translate="yes" xml:space="preserve">
          <source>This member allows array objects to have weak references (using the weakref module).</source>
          <target state="translated">该成员允许数组对象拥有弱引用(使用弱引用模块)。</target>
        </trans-unit>
        <trans-unit id="ed18bc4ba4db4fad433f89f2b494c6f4723892b5" translate="yes" xml:space="preserve">
          <source>This member is used to hold a pointer to another Python object that is related to this array. There are two use cases:</source>
          <target state="translated">该成员用于持有指向与该数组相关的另一个 Python 对象的指针。有两个用例。</target>
        </trans-unit>
        <trans-unit id="9d7f481ab5f8b1d226ed9ed47a9904d6a830df77" translate="yes" xml:space="preserve">
          <source>This member points to an element in the ndarray indicated by the index.</source>
          <target state="translated">该成员指向索引所指的ndarray中的一个元素。</target>
        </trans-unit>
        <trans-unit id="74643da87d06b0da62bc7a9a046a5adf218ab99e" translate="yes" xml:space="preserve">
          <source>This method directly exposes the the raw underlying pseudo-random number generator. All values are returned as unsigned 64-bit values irrespective of the number of bits produced by the PRNG.</source>
          <target state="translated">这个方法直接暴露了原始的底层伪随机数生成器,所有的值都以无符号64位的方式返回,而不管PRNG生成的位数是多少。无论PRNG产生的位数是多少,所有的值都以无符号64位值返回。</target>
        </trans-unit>
        <trans-unit id="d818e6497cca20e6d8e8f1bc817ba9a89c8a342e" translate="yes" xml:space="preserve">
          <source>This method does nothing, except raise a ValueError exception. A masked array does not own its data and therefore cannot safely be resized in place. Use the &lt;a href=&quot;numpy.ma.resize#numpy.ma.resize&quot;&gt;&lt;code&gt;numpy.ma.resize&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">此方法不执行任何操作，除了引发ValueError异常。掩码数组不拥有其数据，因此无法安全地在适当位置调整大小。请改用&lt;a href=&quot;numpy.ma.resize#numpy.ma.resize&quot;&gt; &lt;code&gt;numpy.ma.resize&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="9518a02e6b8dc4cd7e3170e82e29518e38adcb79" translate="yes" xml:space="preserve">
          <source>This method does the heavy lifting for the &lt;a href=&quot;numpy.testing.tester.test#numpy.testing.Tester.test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; method. It takes all the same arguments, for details see &lt;a href=&quot;numpy.testing.tester.test#numpy.testing.Tester.test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该方法为&lt;a href=&quot;numpy.testing.tester.test#numpy.testing.Tester.test&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt;方法带来了沉重的负担。它采用所有相同的参数，有关详细信息，请参见&lt;a href=&quot;numpy.testing.tester.test#numpy.testing.Tester.test&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f55c9dffed1c2a6b5a2a9bf81f22b788e98f67b4" translate="yes" xml:space="preserve">
          <source>This method is called whenever the system internally allocates a new array from &lt;em&gt;obj&lt;/em&gt;, where &lt;em&gt;obj&lt;/em&gt; is a subclass (subtype) of the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. It can be used to change attributes of &lt;em&gt;self&lt;/em&gt; after construction (so as to ensure a 2-d matrix for example), or to update meta-information from the &amp;ldquo;parent.&amp;rdquo; Subclasses inherit a default implementation of this method that does nothing.</source>
          <target state="translated">每当系统内部从&lt;em&gt;obj&lt;/em&gt;分配新数组时，都会调用此方法，其中&lt;em&gt;obj&lt;/em&gt;是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;的子类（子类型）。它可用于在构造后更改&lt;em&gt;self的&lt;/em&gt;属性（例如，以确保二维矩阵），或用于更新&amp;ldquo;父级&amp;rdquo;的元信息。子类继承此方法的默认实现，该实现不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="5957d72b0ca4a0dc20466e5e727abd34e77443e1" translate="yes" xml:space="preserve">
          <source>This method is difficult to implement safely and may be deprecated in future releases of NumPy.</source>
          <target state="translated">这个方法很难安全地实现,在未来的NumPy版本中可能会被废弃。</target>
        </trans-unit>
        <trans-unit id="7aaa9616f6dcdd0184bee8a152bd13d1e550b310" translate="yes" xml:space="preserve">
          <source>This method is for backward compatibility only: do not use.</source>
          <target state="translated">此方法仅用于向后兼容:不要使用。</target>
        </trans-unit>
        <trans-unit id="0ecb5e08ef8d16754216c422058e3a81999abee2" translate="yes" xml:space="preserve">
          <source>This method removes any overlaps and reorders the fields in memory so they have increasing byte offsets, and adds or removes padding bytes depending on the &lt;code&gt;align&lt;/code&gt; option, which behaves like the &lt;code&gt;align&lt;/code&gt; option to &lt;code&gt;np.dtype&lt;/code&gt;.</source>
          <target state="translated">此方法删除所有重叠部分，并对内存中的字段重新排序，以使它们具有增加的字节偏移量，并根据 &lt;code&gt;align&lt;/code&gt; 选项（其行为类似于 &lt;code&gt;np.dtype&lt;/code&gt; 的 &lt;code&gt;align&lt;/code&gt; 选项）来添加或删除填充字节。</target>
        </trans-unit>
        <trans-unit id="83e657ddca83d2881d8a63d1d77710e25b3d7e94" translate="yes" xml:space="preserve">
          <source>This method scans files named __version__.py, &amp;lt;packagename&amp;gt;_version.py, version.py, and __svn_version__.py for string variables version, __version__, and &amp;lt;packagename&amp;gt;_version, until a version number is found.</source>
          <target state="translated">此方法扫描名为__version __。py，&amp;lt;packagename&amp;gt; _version.py，version.py和__svn_version__.py的文件中的字符串变量version，__ version__和&amp;lt;packagename&amp;gt; _version，直到找到版本号。</target>
        </trans-unit>
        <trans-unit id="f89805770623a7cfcc87bb87063713e7dd822816" translate="yes" xml:space="preserve">
          <source>This module contains all functions in the &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; namespace, with the following replacement functions that return &lt;a href=&quot;generated/numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrices&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该模块包含&lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt;名称空间中的所有函数，以及以下替换函数，这些函数返回&lt;a href=&quot;generated/numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrices&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="265d65d83193df044b48a623f0d3f0dda63b008d" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Chebyshev series, including a &lt;a href=&quot;generated/numpy.polynomial.chebyshev.chebyshev#numpy.polynomial.chebyshev.Chebyshev&quot;&gt;&lt;code&gt;Chebyshev&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多用于处理Chebyshev系列的对象（主要是函数），包括封装常规算术运算的&lt;a href=&quot;generated/numpy.polynomial.chebyshev.chebyshev#numpy.polynomial.chebyshev.Chebyshev&quot;&gt; &lt;code&gt;Chebyshev&lt;/code&gt; &lt;/a&gt;类。（有关此模块如何表示和使用此类多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; &amp;ldquo;父&amp;rdquo;子包numpy.polynomial的文档字符串中）。</target>
        </trans-unit>
        <trans-unit id="e0c12fd4ebad36a4626d24020b78132a2c170962" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Hermite series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite.hermite#numpy.polynomial.hermite.Hermite&quot;&gt;&lt;code&gt;Hermite&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多用于处理Hermite系列的对象（主要是函数），包括封装常规算术运算的&lt;a href=&quot;generated/numpy.polynomial.hermite.hermite#numpy.polynomial.hermite.Hermite&quot;&gt; &lt;code&gt;Hermite&lt;/code&gt; &lt;/a&gt;类。 （有关此模块如何表示和使用这些多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; &amp;ldquo;父&amp;rdquo;子程序包numpy.polynomial的文档字符串）。</target>
        </trans-unit>
        <trans-unit id="009a1c885b932c48bc61dd45e0e34c3c31b1f286" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with HermiteE series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt;&lt;code&gt;HermiteE&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多对象（主要是函数），可用于处理HermiteE系列，包括封装常规算术运算的&lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt; &lt;code&gt;HermiteE&lt;/code&gt; &lt;/a&gt;类。（有关此模块如何表示和使用此类多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; &amp;ldquo;父&amp;rdquo;子包numpy.polynomial的文档字符串中）。</target>
        </trans-unit>
        <trans-unit id="68d5327723a8c86e153df7ff9955c4a06be0ce20" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Hermite_e series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt;&lt;code&gt;HermiteE&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多用于处理Hermite_e系列的对象（主要是函数），包括封装常规算术运算的&lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt; &lt;code&gt;HermiteE&lt;/code&gt; &lt;/a&gt;类。（有关此模块如何表示和使用此类多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt;&amp;ldquo;父&amp;rdquo;子包numpy.polynomial的文档字符串中）。</target>
        </trans-unit>
        <trans-unit id="0d0299f154387dc04b7a01cfe822909405b30805" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Laguerre series, including a &lt;a href=&quot;generated/numpy.polynomial.laguerre.laguerre#numpy.polynomial.laguerre.Laguerre&quot;&gt;&lt;code&gt;Laguerre&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多对象（主要是函数），可用于处理Laguerre系列，包括封装了常规算术运算的&lt;a href=&quot;generated/numpy.polynomial.laguerre.laguerre#numpy.polynomial.laguerre.Laguerre&quot;&gt; &lt;code&gt;Laguerre&lt;/code&gt; &lt;/a&gt;类。（有关此模块如何表示和使用此类多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; &amp;ldquo;父&amp;rdquo;子包numpy.polynomial的文档字符串中）。</target>
        </trans-unit>
        <trans-unit id="97167a7dd7012c05d960d350608d944b8fc4844a" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Legendre series, including a &lt;a href=&quot;generated/numpy.polynomial.legendre.legendre#numpy.polynomial.legendre.Legendre&quot;&gt;&lt;code&gt;Legendre&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多用于处理Legendre系列的对象（主要是函数），包括封装常规算术运算的&lt;a href=&quot;generated/numpy.polynomial.legendre.legendre#numpy.polynomial.legendre.Legendre&quot;&gt; &lt;code&gt;Legendre&lt;/code&gt; &lt;/a&gt;类。（有关此模块如何表示和使用这些多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; &amp;ldquo;父&amp;rdquo;子包numpy.polynomial的文档字符串中）。</target>
        </trans-unit>
        <trans-unit id="27218660297bbc1672326aa7fc0091aba0aa4b36" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Polynomial series, including a &lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt;&lt;code&gt;Polynomial&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多用于处理多项式系列的对象（主要是函数），包括封装了常用算术运算的&lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt; &lt;code&gt;Polynomial&lt;/code&gt; &lt;/a&gt;类。（有关此模块如何表示和使用这些多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; &amp;ldquo;父&amp;rdquo;子包numpy.polynomial的文档字符串中）。</target>
        </trans-unit>
        <trans-unit id="1ab4c28fb83b693800bce3d9c0cb03cd8615a6cd" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with polynomials, including a &lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt;&lt;code&gt;Polynomial&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with polynomial objects is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多可用于处理多项式的对象（主要是函数），包括封装常用算术运算的&lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt; &lt;code&gt;Polynomial&lt;/code&gt; &lt;/a&gt;类。（有关此模块如何表示和使用多项式对象的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt;&amp;ldquo;父&amp;rdquo;子包numpy.polynomial的文档字符串）。</target>
        </trans-unit>
        <trans-unit id="6505e2a54b4c90d04c624c70346ad867092f98b2" translate="yes" xml:space="preserve">
          <source>This module provides: error and warning objects; a polynomial base class; and some routines used in both the &lt;code&gt;polynomial&lt;/code&gt; and &lt;code&gt;chebyshev&lt;/code&gt; modules.</source>
          <target state="translated">该模块提供：错误和警告对象；多项式基类；以及在 &lt;code&gt;polynomial&lt;/code&gt; 和 &lt;code&gt;chebyshev&lt;/code&gt; 模块中使用的一些例程。</target>
        </trans-unit>
        <trans-unit id="a2e1ca0b050299a02c26006ffc538095c291c293" translate="yes" xml:space="preserve">
          <source>This module shows use of the &lt;code&gt;cimport&lt;/code&gt; statement to load the definitions from the &lt;code&gt;numpy.pxd&lt;/code&gt; header that ships with Cython. It looks like NumPy is imported twice; &lt;code&gt;cimport&lt;/code&gt; only makes the NumPy C-API available, while the regular &lt;code&gt;import&lt;/code&gt; causes a Python-style import at runtime and makes it possible to call into the familiar NumPy Python API.</source>
          <target state="translated">此模块显示了如何使用 &lt;code&gt;cimport&lt;/code&gt; 语句从 &lt;code&gt;numpy.pxd&lt;/code&gt; 附带的numpy.pxd标头中加载定义。看起来NumPy被导入了两次； &lt;code&gt;cimport&lt;/code&gt; 仅使NumPy C-API可用，而常规 &lt;code&gt;import&lt;/code&gt; 会在运行时导致Python样式的导入，并可以调用熟悉的NumPy Python API。</target>
        </trans-unit>
        <trans-unit id="6f02b8e116f7a7bed4ba561da0ffe80943392202" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Chebyshev series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">该模块表示 &lt;code&gt;off + scl*x&lt;/code&gt; 的Chebyshev系列的。</target>
        </trans-unit>
        <trans-unit id="a628eacd0f4bb9dd57ff71e63c578eed78e261b5" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Hermite series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">此模块代表 &lt;code&gt;off + scl*x&lt;/code&gt; 的Hermite系列。</target>
        </trans-unit>
        <trans-unit id="9ab2b6eda8208cc86132d50e5e53a2cf2e15859d" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Laguerre series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">此模块代表 &lt;code&gt;off + scl*x&lt;/code&gt; 的Laguerre系列。</target>
        </trans-unit>
        <trans-unit id="23eb81bc9bb7a5f0cbd08a18f3b739c712c791cf" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Legendre series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">此模块代表 &lt;code&gt;off + scl*x&lt;/code&gt; 的Legendre系列。</target>
        </trans-unit>
        <trans-unit id="d92e37a5c688f24c68244c7cd58f9c4410908a50" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the linear polynomial &lt;code&gt;off +
scl*x&lt;/code&gt;.</source>
          <target state="translated">此模块表示线性多项式 &lt;code&gt;off + scl*x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cce1c3ab116538df151878b9366f2e0db3802d6b" translate="yes" xml:space="preserve">
          <source>This needs to be done after all installers are downloaded, but before the pavement file is updated for continued development:</source>
          <target state="translated">这需要在所有安装程序下载完毕后,但在更新路面文件之前进行,以便继续开发。</target>
        </trans-unit>
        <trans-unit id="a5151a066bb85cc108b39c4156d9c6c1e5f15d97" translate="yes" xml:space="preserve">
          <source>This obeys the structured array assignment rules described above. For example, this means that one can swap the values of two fields using appropriate multi-field indexes:</source>
          <target state="translated">这服从于上面描述的结构化数组赋值规则。例如,这意味着可以使用适当的多字段索引交换两个字段的值。</target>
        </trans-unit>
        <trans-unit id="1c93b1abaa0ee7234b376edaae74a000aa2ccbab" translate="yes" xml:space="preserve">
          <source>This object is no longer compatible with &lt;code&gt;np.sum&lt;/code&gt; because if you call &lt;code&gt;np.sum&lt;/code&gt;, it will pass in unexpected arguments &lt;code&gt;out&lt;/code&gt; and &lt;code&gt;keepdims&lt;/code&gt;, causing a TypeError to be raised.</source>
          <target state="translated">该对象不再与 &lt;code&gt;np.sum&lt;/code&gt; 兼容，因为如果调用 &lt;code&gt;np.sum&lt;/code&gt; ，它将把意外的参数传递 &lt;code&gt;out&lt;/code&gt; 并 &lt;code&gt;keepdims&lt;/code&gt; ，从而引发TypeError。</target>
        </trans-unit>
        <trans-unit id="b628f2a020e67ee402c9861512476edcb4af1ebf" translate="yes" xml:space="preserve">
          <source>This object is now compatible with &lt;code&gt;np.sum&lt;/code&gt; again because any extraneous arguments (i.e. keywords that are not &lt;code&gt;axis&lt;/code&gt; or &lt;code&gt;dtype&lt;/code&gt;) will be hidden away in the &lt;code&gt;**unused_kwargs&lt;/code&gt; parameter.</source>
          <target state="translated">这个对象是目前兼容 &lt;code&gt;np.sum&lt;/code&gt; 再次因为（不属于即关键字任何无关的论点 &lt;code&gt;axis&lt;/code&gt; 或 &lt;code&gt;dtype&lt;/code&gt; ）将在被藏起来 &lt;code&gt;**unused_kwargs&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="75a22002edc0d8d423cb72bfe9efb4e65f38427c" translate="yes" xml:space="preserve">
          <source>This only affects the iterator when &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is specified for the order parameter. By default with &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, the iterator reverses axes which have negative strides, so that memory is traversed in a forward direction. This disables this step. Use this flag if you want to use the underlying memory-ordering of the axes, but don&amp;rsquo;t want an axis reversed. This is the behavior of &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt;, for instance.</source>
          <target state="translated">仅当为order参数指定&lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt;时，这才影响迭代器。默认情况下，使用&lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt;，迭代器反转具有负步幅的轴，以便沿正向遍历内存。这将禁用此步骤。如果要使用轴的基础存储顺序，但不希望轴反转，请使用此标志。例如，这就是 &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt; 的行为。</target>
        </trans-unit>
        <trans-unit id="eaa2fd8c1567b66e551b17269b1ebbbc61f96243" translate="yes" xml:space="preserve">
          <source>This only affects the iterator when &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is specified for the order parameter. By default with &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, the iterator reverses axes which have negative strides, so that memory is traversed in a forward direction. This disables this step. Use this flag if you want to use the underlying memory-ordering of the axes, but don&amp;rsquo;t want an axis reversed. This is the behavior of &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt;, for instance.</source>
          <target state="translated">仅当为order参数指定&lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt;时，这才影响迭代器。默认情况下，使用&lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt;，迭代器反转具有负步幅的轴，以便沿正向遍历内存。这将禁用此步骤。如果要使用轴的基础内存顺序，但不希望轴反转，请使用此标志。例如，这就是 &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt; 的行为。</target>
        </trans-unit>
        <trans-unit id="dfc0d7340cbb0038d2b37c47d460673f198c8e36" translate="yes" xml:space="preserve">
          <source>This operation, dividing an array by a scalar, works because of NumPy&amp;rsquo;s &lt;a href=&quot;theory.broadcasting#array-broadcasting-in-numpy&quot;&gt;broadcasting rules&lt;/a&gt;). (Note that in real-world applications, it would be better to use, for example, the &lt;a href=&quot;https://scikit-image.org/docs/stable/api/skimage.html#skimage.img_as_float&quot;&gt;&lt;code&gt;img_as_float&lt;/code&gt;&lt;/a&gt; utility function from &lt;code&gt;scikit-image&lt;/code&gt;).</source>
          <target state="translated">由于NumPy的&lt;a href=&quot;theory.broadcasting#array-broadcasting-in-numpy&quot;&gt;广播规则&lt;/a&gt;，此操作将数组除以标量就可以工作。（请注意，在实际应用程序中，最好使用 &lt;code&gt;scikit-image&lt;/code&gt; 中的&lt;a href=&quot;https://scikit-image.org/docs/stable/api/skimage.html#skimage.img_as_float&quot;&gt; &lt;code&gt;img_as_float&lt;/code&gt; &lt;/a&gt;实用程序函数）。</target>
        </trans-unit>
        <trans-unit id="c162c5fa5c56025420698950fd9023cbce377364" translate="yes" xml:space="preserve">
          <source>This option is deprecated. Use &lt;code&gt;usercode&lt;/code&gt; statement to specify C code snippets directly in signature files.</source>
          <target state="translated">不建议使用此选项。使用 &lt;code&gt;usercode&lt;/code&gt; 语句直接在签名文件中指定C代码片段。</target>
        </trans-unit>
        <trans-unit id="ae6b1796953475091b5cdaeb39e4d7e996e315e6" translate="yes" xml:space="preserve">
          <source>This optional parameter specifies the interpolation method to use when the desired percentile lies between two data points &lt;code&gt;i &amp;lt; j&lt;/code&gt;:</source>
          <target state="translated">此可选参数指定当所需百分比位于两个数据点 &lt;code&gt;i &amp;lt; j&lt;/code&gt; 之间时要使用的插值方法：</target>
        </trans-unit>
        <trans-unit id="002fb17667dbbd628eca51b6e4ff99f2217649e0" translate="yes" xml:space="preserve">
          <source>This optional parameter specifies the interpolation method to use when the desired quantile lies between two data points &lt;code&gt;i &amp;lt; j&lt;/code&gt;:</source>
          <target state="translated">此可选参数指定当所需分位数位于两个数据点 &lt;code&gt;i &amp;lt; j&lt;/code&gt; 之间时要使用的插值方法：</target>
        </trans-unit>
        <trans-unit id="c342edf9966c2e18280c4d355db707b32be4bff5" translate="yes" xml:space="preserve">
          <source>This package was developed independently of NumPy and was integrated in version 1.17.0. The original repo is at &lt;a href=&quot;https://github.com/bashtage/randomgen&quot;&gt;https://github.com/bashtage/randomgen&lt;/a&gt;.</source>
          <target state="translated">该软件包独立于NumPy开发，并已集成到1.17.0版中。原始存储库位于&lt;a href=&quot;https://github.com/bashtage/randomgen&quot;&gt;https://github.com/bashtage/randomgen&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c427139240278bee81f47cf48768438afbe39755" translate="yes" xml:space="preserve">
          <source>This page describes the numpy-specific API for accessing the contents of a numpy array from other C extensions. &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; &amp;ndash; &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#c.PyObject_GetBuffer&quot;&gt;&lt;code&gt;The Revised Buffer Protocol&lt;/code&gt;&lt;/a&gt; introduces similar, standardized API to Python 2.6 and 3.0 for any extension module to use. &lt;a href=&quot;http://cython.org/&quot;&gt;Cython&lt;/a&gt;&amp;rsquo;s buffer array support uses the &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; API; see the &lt;a href=&quot;https://github.com/cython/cython/wiki/tutorials-numpy&quot;&gt;Cython numpy tutorial&lt;/a&gt;. Cython provides a way to write code that supports the buffer protocol with Python versions older than 2.6 because it has a backward-compatible implementation utilizing the array interface described here.</source>
          <target state="translated">此页面描述了特定于numpy的API，用于从其他C扩展访问numpy数组的内容。&lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; &amp;ndash; &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#c.PyObject_GetBuffer&quot;&gt; &lt;code&gt;The Revised Buffer Protocol&lt;/code&gt; &lt;/a&gt;为Python 2.6和3.0引入了类似的标准化API，供任何扩展模块使用。&lt;a href=&quot;http://cython.org/&quot;&gt;Cython&lt;/a&gt;的缓冲阵列支持使用&lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; API；请参见&lt;a href=&quot;https://github.com/cython/cython/wiki/tutorials-numpy&quot;&gt;Cython numpy教程&lt;/a&gt;。Cython提供了一种方法来编写支持2.6版以上Python版本的缓冲区协议的代码，因为它具有使用此处描述的数组接口向后兼容的实现。</target>
        </trans-unit>
        <trans-unit id="4df30a5dfa3e83d5a58c4b3babfef2e8f4555a00" translate="yes" xml:space="preserve">
          <source>This page documents the API for the iterator. The iterator is named &lt;code&gt;NpyIter&lt;/code&gt; and functions are named &lt;code&gt;NpyIter_*&lt;/code&gt;.</source>
          <target state="translated">此页面记录了迭代器的API。迭代器名为 &lt;code&gt;NpyIter&lt;/code&gt; ，函数名为 &lt;code&gt;NpyIter_*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3ed57ed2270d94087c1c0c02f79e8407d0327af" translate="yes" xml:space="preserve">
          <source>This page tackles common applications; for the full collection of I/O routines, see &lt;a href=&quot;../reference/routines.io#routines-io&quot;&gt;Input and output&lt;/a&gt;.</source>
          <target state="translated">该页面介绍了常见的应用程序；有关I / O例程的完整集合，请参见&lt;a href=&quot;../reference/routines.io#routines-io&quot;&gt;输入和输出&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ef493fa5f7ddfcfa2e56b59880c2ca13b04b480" translate="yes" xml:space="preserve">
          <source>This plot is not so readable since the lines seem to be over each other, so let&amp;rsquo;s summarize in a more elaborate plot. We&amp;rsquo;ll plot the real data when available, and show the cubic fit for unavailable data, using this fit to compute an estimate to the observed number of cases on January 28th 2020, 7 days after the beginning of the records:</source>
          <target state="translated">由于线似乎彼此重叠，因此该图不太易读，因此让我们在一个更详细的图中进行总结。我们将绘制可用的实际数据，并显示不可用数据的三次拟合，使用该拟合来计算对记录开始后7天（2020年1月28日）观察到的病例数的估计：</target>
        </trans-unit>
        <trans-unit id="b79e823ebc32815d2b3460b90e34d0a2f9bed7dc" translate="yes" xml:space="preserve">
          <source>This pointer may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it.</source>
          <target state="translated">该指针可能在迭代循环之前被缓存，调用 &lt;code&gt;iternext&lt;/code&gt; 不会更改它。</target>
        </trans-unit>
        <trans-unit id="484a465c1e928c7fbd45d4d74c7fee12a21c59d4" translate="yes" xml:space="preserve">
          <source>This pointer may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it. This function may be safely called without holding the Python GIL.</source>
          <target state="translated">该指针可能在迭代循环之前被缓存，调用 &lt;code&gt;iternext&lt;/code&gt; 不会更改它。无需持有Python GIL即可安全地调用此函数。</target>
        </trans-unit>
        <trans-unit id="bb65fa9e55962767929fe75ece2f7703e6ac5b10" translate="yes" xml:space="preserve">
          <source>This produces the correct answer, but if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; each contain millions of numbers, we will pay the price for the inefficiencies of looping in Python. We could accomplish the same task much more quickly in C by writing (for clarity we neglect variable declarations and initializations, memory allocation, etc.)</source>
          <target state="translated">这会产生正确的答案，但是如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 都包含数百万个数字，我们将为Python循环效率低下付出代价。我们可以通过编写C语言来更快地完成同一任务（为清楚起见，我们忽略了变量声明和初始化，内存分配等）。</target>
        </trans-unit>
        <trans-unit id="fc50269460cb12e12865cbec85480d4b3e10a0a9" translate="yes" xml:space="preserve">
          <source>This property can be very useful in assignments:</source>
          <target state="translated">这个属性在作业中是非常有用的。</target>
        </trans-unit>
        <trans-unit id="af7b379b2fcb530df7b5c66e85d1051773a408df" translate="yes" xml:space="preserve">
          <source>This property is a view on the imaginary part of this &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此属性是此&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;的虚部的视图。</target>
        </trans-unit>
        <trans-unit id="00b60d7136524e649c297d22303044023139f2d1" translate="yes" xml:space="preserve">
          <source>This property is a view on the imaginary part of this &lt;code&gt;MaskedArray&lt;/code&gt;.</source>
          <target state="translated">此属性是此 &lt;code&gt;MaskedArray&lt;/code&gt; 的虚部的视图。</target>
        </trans-unit>
        <trans-unit id="9c2a714f693725c88c94ac2607ed6abee0322d99" translate="yes" xml:space="preserve">
          <source>This property is a view on the real part of this &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此属性是此&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;实际部分的视图。</target>
        </trans-unit>
        <trans-unit id="a4989179ebd897375fad9fc4e97f158afedfb6f9" translate="yes" xml:space="preserve">
          <source>This property is a view on the real part of this &lt;code&gt;MaskedArray&lt;/code&gt;.</source>
          <target state="translated">此属性是此 &lt;code&gt;MaskedArray&lt;/code&gt; 实际部分的视图。</target>
        </trans-unit>
        <trans-unit id="56ae11e0e5ca2982f115765c5eb4aa5c0c2cf88d" translate="yes" xml:space="preserve">
          <source>This reallocates space for the data area if necessary.</source>
          <target state="translated">必要时,这将重新分配数据区域的空间。</target>
        </trans-unit>
        <trans-unit id="3875a2efa104b3c26f06d6992550d8f8f4acd93f" translate="yes" xml:space="preserve">
          <source>This reference manual details functions, modules, and objects included in NumPy, describing what they are and what they do. For learning how to use NumPy, see also &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/index.html#user&quot;&gt;NumPy User Guide&lt;/a&gt;.</source>
          <target state="translated">该参考手册详细介绍了NumPy中包含的功能，模块和对象，描述了它们的功能和作用。有关学习如何使用NumPy的信息，另请参阅《&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/index.html#user&quot;&gt;NumPy用户指南》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b66394de331bbd119ed305c44c97cddcc296f65" translate="yes" xml:space="preserve">
          <source>This reference manual details functions, modules, and objects included in NumPy, describing what they are and what they do. For learning how to use NumPy, see the &lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;complete documentation&lt;/a&gt;.</source>
          <target state="translated">该参考手册详细介绍了NumPy中包含的功能，模块和对象，并描述了它们的功能和作用。要了解如何使用NumPy，请参阅&lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;完整的文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="49d7d34fc7b59b4f57a8fc699678974df3138f8f" translate="yes" xml:space="preserve">
          <source>This returns a tuple of indices that can be used to access the main diagonal of an array &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; dimensions and shape (n, n, &amp;hellip;, n). For &lt;code&gt;a.ndim = 2&lt;/code&gt; this is the usual diagonal, for &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; this is the set of indices to access &lt;code&gt;a[i, i, ..., i]&lt;/code&gt; for &lt;code&gt;i = [0..n-1]&lt;/code&gt;.</source>
          <target state="translated">这将返回可以用于访问阵列的主对角线索引的元组 &lt;code&gt;a&lt;/code&gt; 与 &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; 的尺寸和形状（N，N，...，N）。对于 &lt;code&gt;a.ndim = 2&lt;/code&gt; ，这是通常的对角线，用于 &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; 这是组索引访问 &lt;code&gt;a[i, i, ..., i]&lt;/code&gt; 为 &lt;code&gt;i = [0..n-1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="445408c5f27be1f1d331536d4e933a74a8f78cb0" translate="yes" xml:space="preserve">
          <source>This returns the base object of the array. In most cases, this means the object which owns the memory the array is pointing at.</source>
          <target state="translated">这将返回数组的基础对象。在大多数情况下,这意味着拥有数组指向的内存的对象。</target>
        </trans-unit>
        <trans-unit id="86f639de88fe17b751b6b11b662442ef7819d4d2" translate="yes" xml:space="preserve">
          <source>This routine simply adds the elements in two contiguous arrays and places the result in a third. The memory for all three arrays must be provided by the calling routine. A very basic interface to this routine can be automatically generated by f2py:</source>
          <target state="translated">这个例程只是将两个连续数组中的元素相加,并将结果放入第三个数组中。这三个数组的内存必须由调用例程提供。这个例程的一个非常基本的接口可以由f2py自动生成。</target>
        </trans-unit>
        <trans-unit id="a52ed8eb1e1cedf938d67a58ab208207008af6c7" translate="yes" xml:space="preserve">
          <source>This routine succeeds where ordinary &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt; does not:</source>
          <target state="translated">该例程在普通&lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;无法执行的情况下成功执行：</target>
        </trans-unit>
        <trans-unit id="9bca535321764a180aeb878b90cecb0b41abe3ad" translate="yes" xml:space="preserve">
          <source>This rule helps you anticipate how a vector will be printed, and conversely how to find the index of any of the printed elements. For instance, in the example, the last two values of 8&amp;rsquo;s index must be 0 and 2. Since 8 appears in the second of the two 2x3&amp;rsquo;s, the first index must be 1:</source>
          <target state="translated">此规则可帮助您预期如何打印矢量，以及相反如何找到任何已打印元素的索引。例如，在示例中，8的索引的最后两个值必须为0和2。由于8在两个2x3的第二个中出现，因此第一个索引必须为1：</target>
        </trans-unit>
        <trans-unit id="bb5cd927267b8c85989f3387ce0a0d2359a4663d" translate="yes" xml:space="preserve">
          <source>This saves all the overhead involved in interpreting the Python code and manipulating Python objects, but at the expense of the benefits gained from coding in Python. Furthermore, the coding work required increases with the dimensionality of our data. In the case of a 2-D array, for example, the C code (abridged as before) expands to</source>
          <target state="translated">这节省了解释Python代码和操作Python对象所涉及的所有开销,但却牺牲了用Python编码所获得的好处。此外,所需的编码工作会随着我们数据的维度而增加。以一个 2-D 数组为例,C 代码 (简略如前)展开为</target>
        </trans-unit>
        <trans-unit id="eb7064b0e5d0b37eaed95ef4ac40f47e88476c2d" translate="yes" xml:space="preserve">
          <source>This scheme does require that you avoid reusing stream IDs. This may require coordination between the parallel processes.</source>
          <target state="translated">这个方案确实要求你避免重复使用流ID。这可能需要并行进程之间的协调。</target>
        </trans-unit>
        <trans-unit id="1aa4791ff179e31578c8776ff4ea075ff10d4756" translate="yes" xml:space="preserve">
          <source>This section and the next describe in detail how to set up git for working with the NumPy source code. If you have git already set up, skip to &lt;a href=&quot;../development_workflow#development-workflow&quot;&gt;Development workflow&lt;/a&gt;.</source>
          <target state="translated">本节和下一节将详细描述如何设置git以使用NumPy源代码。如果您已经设置了git，请跳至&lt;a href=&quot;../development_workflow#development-workflow&quot;&gt;开发工作流程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e071a3347f38c194bd96c7f6d94e6b8f7990250d" translate="yes" xml:space="preserve">
          <source>This section describes how the basic universal function computation loop is setup and executed for each of the three different kinds of execution. If &lt;a href=&quot;c-api/array#c.NPY_ALLOW_THREADS&quot;&gt;&lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; is defined during compilation, then as long as no object arrays are involved, the Python Global Interpreter Lock (GIL) is released prior to calling the loops. It is re-acquired if necessary to handle error conditions. The hardware error flags are checked only after the 1-D loop is completed.</source>
          <target state="translated">本节描述了如何为三种不同类型的执行中的每种执行建立和执行基本的通用函数计算循环。如果在编译期间定义了&lt;a href=&quot;c-api/array#c.NPY_ALLOW_THREADS&quot;&gt; &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt;，则只要不涉及对象数组，就在调用循环之前释放Python全局解释器锁（GIL）。如有必要，可以重新获取它以处理错误情况。仅在完成一维循环后才检查硬件错误标志。</target>
        </trans-unit>
        <trans-unit id="d2295424cf2146c8c588e01472068b4499bd8664" translate="yes" xml:space="preserve">
          <source>This section describes how the basic universal function computation loop is setup and executed for each of the three different kinds of execution. If &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined during compilation, then as long as no object arrays are involved, the Python Global Interpreter Lock (GIL) is released prior to calling the loops. It is re-acquired if necessary to handle error conditions. The hardware error flags are checked only after the 1-D loop is completed.</source>
          <target state="translated">本节描述了如何为三种不同类型的执行中的每种执行建立和执行基本的通用函数计算循环。如果在编译期间定义了 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; ，则只要不涉及对象数组，就在调用循环之前释放Python全局解释器锁（GIL）。如有必要，可以重新获取它以处理错误情况。仅在完成一维循环后才检查硬件错误标志。</target>
        </trans-unit>
        <trans-unit id="36d38a5b23b654b48926d888ff2f70f4fd6663ca" translate="yes" xml:space="preserve">
          <source>This section describes the governance and leadership model of The Project.</source>
          <target state="translated">本节介绍 &quot;项目 &quot;的治理和领导模式。</target>
        </trans-unit>
        <trans-unit id="387c13e7d204cf584e66117f50223922b47b0d67" translate="yes" xml:space="preserve">
          <source>This section should be used judiciously, i.e., only for errors that are non-obvious or have a large chance of getting raised.</source>
          <target state="translated">这一部分要慎重使用,即只适用于不明显或有较大几率被提出的错误。</target>
        </trans-unit>
        <trans-unit id="cf292081ef6e3f6d3a2a86d3bb95335c9be71e92" translate="yes" xml:space="preserve">
          <source>This section should use the &lt;code&gt;deprecated&lt;/code&gt; Sphinx directive instead of an underlined section header.</source>
          <target state="translated">本节应使用 &lt;code&gt;deprecated&lt;/code&gt; 建议使用的Sphinx指令，而不是带下划线的节标题。</target>
        </trans-unit>
        <trans-unit id="0a9b94d3eaea207d20a5173591fa4612902baa5c" translate="yes" xml:space="preserve">
          <source>This section will not cover means of replicating, joining, or otherwise expanding or mutating existing arrays. Nor will it cover creating object arrays or structured arrays. Both of those are covered in their own sections.</source>
          <target state="translated">本节将不涉及复制、加入或以其他方式扩展或突变现有数组的方法,也不涉及创建对象数组或结构化数组。也不涉及创建对象数组或结构化数组。这两方面的内容将在各自的章节中介绍。</target>
        </trans-unit>
        <trans-unit id="9a18449ed2fc82d845556e8871f21b5f905f1f97" translate="yes" xml:space="preserve">
          <source>This should be read together with the general directions in &lt;code&gt;releasing&lt;/code&gt;.</source>
          <target state="translated">这应该与一般的方向一起读 &lt;code&gt;releasing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af85e32a0a54092009ceae627c9327451013292e" translate="yes" xml:space="preserve">
          <source>This should not be confused with:</source>
          <target state="translated">这不应与以下情况混淆:</target>
        </trans-unit>
        <trans-unit id="281bd1fc18f2200e68ef811b640b0f24111b0170" translate="yes" xml:space="preserve">
          <source>This simply has the effect of switching the definitions of &lt;code&gt;arg1&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt; in lines 3 and 4 of the generated code above, and their assignments in lines 19 and 20.</source>
          <target state="translated">这只是在上面生成的代码的第3行和第4行中切换 &lt;code&gt;arg1&lt;/code&gt; 和 &lt;code&gt;arg2&lt;/code&gt; 的定义以及在第19行和第20行中分配它们的作用。</target>
        </trans-unit>
        <trans-unit id="54a1fbc955c54345f701059c4adac18f9144af8f" translate="yes" xml:space="preserve">
          <source>This single module should provide all the common functionality for numpy tests in a single location, so that &lt;a href=&quot;../dev/development_environment#development-environment&quot;&gt;test scripts&lt;/a&gt; can just import it and work right away. For background, see the &lt;a href=&quot;testing#testing-guidelines&quot;&gt;Testing Guidelines&lt;/a&gt;</source>
          <target state="translated">这个模块应该在一个位置为numpy测试提供所有通用功能，以便&lt;a href=&quot;../dev/development_environment#development-environment&quot;&gt;测试脚本&lt;/a&gt;可以将其导入并立即运行。有关背景，请参见&lt;a href=&quot;testing#testing-guidelines&quot;&gt;测试准则&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5f0ce6428ed7ce9a3f007ac820d6ad83fbe35d9" translate="yes" xml:space="preserve">
          <source>This single module should provide all the common functionality for numpy tests in a single location, so that &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/dev/development_environment.html#development-environment&quot;&gt;test scripts&lt;/a&gt; can just import it and work right away. For background, see the &lt;a href=&quot;testing#testing-guidelines&quot;&gt;Testing Guidelines&lt;/a&gt;</source>
          <target state="translated">这个模块应该在一个位置为numpy测试提供所有通用功能，以便&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/dev/development_environment.html#development-environment&quot;&gt;测试脚本&lt;/a&gt;可以将其导入并立即运行。有关背景，请参见&lt;a href=&quot;testing#testing-guidelines&quot;&gt;测试准则&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e97f89b724acb7f31f3f94df4fb5ca630be7277b" translate="yes" xml:space="preserve">
          <source>This sort of mutation is not allowed by the types. Users who want to write statically typed code should insted use the &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;numpy.ndarray.view&lt;/code&gt;&lt;/a&gt; method to create a view of the array with a different dtype.</source>
          <target state="translated">类型不允许这种类型的突变。想要编写静态类型代码的用户应使用&lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;numpy.ndarray.view&lt;/code&gt; &lt;/a&gt;方法来创建具有不同dtype的数组的视图。</target>
        </trans-unit>
        <trans-unit id="feb22e5bb35e33b30ed01dab66654627fe20956a" translate="yes" xml:space="preserve">
          <source>This specifies the &amp;ldquo;intention&amp;rdquo; of the corresponding argument. &lt;code&gt;&amp;lt;intentspec&amp;gt;&lt;/code&gt; is a comma separated list of the following keys:</source>
          <target state="translated">这指定了相应参数的&amp;ldquo;意图&amp;rdquo;。 &lt;code&gt;&amp;lt;intentspec&amp;gt;&lt;/code&gt; 是以下键的逗号分隔列表：</target>
        </trans-unit>
        <trans-unit id="5e999bfd9ee7986bb74545207acc796f3e46abd8" translate="yes" xml:space="preserve">
          <source>This specifies which warnings to configure as &amp;lsquo;raise&amp;rsquo; instead of being shown once during the test execution. Valid strings are:</source>
          <target state="translated">这指定将哪些警告配置为&amp;ldquo;升高&amp;rdquo;，而不是在测试执行期间显示一次。有效字符串为：</target>
        </trans-unit>
        <trans-unit id="355c08a8b685b52031d6593cc7642f8973231125" translate="yes" xml:space="preserve">
          <source>This step is only needed for final releases and can be skipped for pre-releases. &lt;code&gt;make merge-doc&lt;/code&gt; clones the &lt;code&gt;numpy/doc&lt;/code&gt; repo into &lt;code&gt;doc/build/merge&lt;/code&gt; and updates it with the new documentation:</source>
          <target state="translated">仅对于最终版本，才需要执行此步骤，对于预发布版本，可以跳过此步骤。 &lt;code&gt;make merge-doc&lt;/code&gt; 将 &lt;code&gt;numpy/doc&lt;/code&gt; 存储库克隆到 &lt;code&gt;doc/build/merge&lt;/code&gt; 中，并使用新文档进行更新：</target>
        </trans-unit>
        <trans-unit id="f04c1b598b018608346e9a082214a1abd34ac499" translate="yes" xml:space="preserve">
          <source>This string will be used as the marker for missing data for all the columns</source>
          <target state="translated">这个字符串将被用作所有列的缺失数据的标记。</target>
        </trans-unit>
        <trans-unit id="d96875a0b29939a3e2bb067cb066089a92949861" translate="yes" xml:space="preserve">
          <source>This structure is very useful when shape and/or strides information is supposed to be interpreted. The structure is:</source>
          <target state="translated">当需要解释形状和/或步幅信息时,这个结构非常有用。该结构是:</target>
        </trans-unit>
        <trans-unit id="f5377b9ec1ee34b1b46afca48f12d70eda083569" translate="yes" xml:space="preserve">
          <source>This style allows passing in the &lt;a href=&quot;generated/numpy.dtype.fields#numpy.dtype.fields&quot;&gt;&lt;code&gt;fields&lt;/code&gt;&lt;/a&gt; attribute of a data-type object.</source>
          <target state="translated">这种样式允许传入数据类型对象的&lt;a href=&quot;generated/numpy.dtype.fields#numpy.dtype.fields&quot;&gt; &lt;code&gt;fields&lt;/code&gt; &lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="8baa5c3fa91f9d82d5f372676363ca92358b6704" translate="yes" xml:space="preserve">
          <source>This style does not accept &lt;em&gt;align&lt;/em&gt; in the &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; constructor as it is assumed that all of the memory is accounted for by the array interface description.</source>
          <target state="translated">此样式在&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;构造函数中不接受&lt;em&gt;align&lt;/em&gt;，因为假定所有内存均由数组接口描述解决。</target>
        </trans-unit>
        <trans-unit id="63b067d6a5e8e9587ae90576ba34210d81e53f6b" translate="yes" xml:space="preserve">
          <source>This style has two required and three optional keys. The &lt;em&gt;names&lt;/em&gt; and &lt;em&gt;formats&lt;/em&gt; keys are required. Their respective values are equal-length lists with the field names and the field formats. The field names must be strings and the field formats can be any object accepted by &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">此样式具有两个必需键和三个可选键。该&lt;em&gt;名称&lt;/em&gt;和&lt;em&gt;格式&lt;/em&gt;的密钥是必需的。它们各自的值是等长列表，其中包含字段名称和字段格式。字段名称必须是字符串，并且字段格式可以是&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;构造函数接受的任何对象。</target>
        </trans-unit>
        <trans-unit id="9fd39c592746d75bfe12bf10bab5bf15e715d323" translate="yes" xml:space="preserve">
          <source>This subclass of ndarray has some unpleasant interactions with some operations, because it doesn&amp;rsquo;t quite fit properly as a subclass. An alternative to using this subclass is to create the &lt;code&gt;mmap&lt;/code&gt; object yourself, then create an ndarray with ndarray.__new__ directly, passing the object created in its &amp;lsquo;buffer=&amp;rsquo; parameter.</source>
          <target state="translated">ndarray的该子类与某些操作有一些不愉快的交互，因为它不太适合作为子类。使用此子类的另一种方法是自己创建 &lt;code&gt;mmap&lt;/code&gt; 对象，然后直接使用ndarray .__ new__创建一个ndarray，并在其'buffer ='参数中传递创建的对象。</target>
        </trans-unit>
        <trans-unit id="8a52b4cb6a8af65abce36bb79c9c41aa8777063c" translate="yes" xml:space="preserve">
          <source>This tells you that you are currently on the &lt;code&gt;master&lt;/code&gt; branch, and that you also have a &lt;code&gt;remote&lt;/code&gt; connection to &lt;code&gt;origin/master&lt;/code&gt;. What remote repository is &lt;code&gt;remote/origin&lt;/code&gt;? Try &lt;code&gt;git remote -v&lt;/code&gt; to see the URLs for the remote. They will point to your &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; fork.</source>
          <target state="translated">这告诉您您当前在 &lt;code&gt;master&lt;/code&gt; 分支上，并且还具有到 &lt;code&gt;origin/master&lt;/code&gt; 的 &lt;code&gt;remote&lt;/code&gt; 连接。哪个远程存储库是 &lt;code&gt;remote/origin&lt;/code&gt; ？尝试使用 &lt;code&gt;git remote -v&lt;/code&gt; 查看远程URL。他们将指向您的&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;分支。</target>
        </trans-unit>
        <trans-unit id="49e089f7d3412f57a533b95b4289e1725ee616b3" translate="yes" xml:space="preserve">
          <source>This template converter will replicate all &lt;strong&gt;function&lt;/strong&gt; and &lt;strong&gt;subroutine&lt;/strong&gt; blocks in the file with names that contain &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; according to the rules in &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo;. The number of comma-separated words in &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; determines the number of times the block is repeated. What these words are indicates what that repeat rule, &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo;, should be replaced with in each block. All of the repeat rules in a block must contain the same number of comma-separated words indicating the number of times that block should be repeated. If the word in the repeat rule needs a comma, leftarrow, or rightarrow, then prepend it with a backslash &amp;lsquo; &amp;lsquo;. If a word in the repeat rule matches &amp;lsquo; \&amp;lt;index&amp;gt;&amp;rsquo; then it will be replaced with the &amp;lt;index&amp;gt;-th word in the same repeat specification. There are two forms for the repeat rule: named and short.</source>
          <target state="translated">该模板转换器将复制所有&lt;strong&gt;功能&lt;/strong&gt;和&lt;strong&gt;子例程&lt;/strong&gt;根据&amp;ldquo; &amp;lt;&amp;hellip;&amp;gt;&amp;rdquo;中的规则，使用名称包含&amp;ldquo; &amp;lt;&amp;hellip;&amp;gt;&amp;rdquo;的文件中的块。 &amp;ldquo; &amp;lt;&amp;hellip;&amp;gt;&amp;rdquo;中逗号分隔的单词数决定了该块重复的次数。这些单词表示在每个块中应将重复规则&amp;ldquo; &amp;lt;&amp;hellip;&amp;gt;&amp;rdquo;替换为什么。块中的所有重复规则必须包含相同数量的逗号分隔的单词，以指示该块应重复的次数。如果重复规则中的单词需要逗号，左箭头或右箭头，则在其前面加上反斜杠&amp;ldquo;&amp;rdquo;。如果重复规则中的单词与&amp;ldquo; \ &amp;lt;index&amp;gt;&amp;rdquo;匹配，则它将被同一重复规范中的第&amp;lt;index&amp;gt;个单词替换。重复规则有两种形式：named和short。</target>
        </trans-unit>
        <trans-unit id="7b0c224585cc04560ef8f7427d408f831662e6b0" translate="yes" xml:space="preserve">
          <source>This tutorial is for people who have a basic understanding of NumPy and want to understand how masked arrays and the &lt;a href=&quot;../reference/maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module can be used in practice.</source>
          <target state="translated">本教程适用于对NumPy有基本了解并且想要了解如何在实践中使用掩码数组和&lt;a href=&quot;../reference/maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt;模块的人员。</target>
        </trans-unit>
        <trans-unit id="e17f08578fff4f4b7f45b2cc421b1a2466a7ddfd" translate="yes" xml:space="preserve">
          <source>This tutorial is for people who have a basic understanding of linear algebra and arrays in NumPy and want to understand how n-dimensional (</source>
          <target state="translated">本教程适合对NumPy中的线性代数和数组有基本了解,并想了解n维(</target>
        </trans-unit>
        <trans-unit id="1f4e248732bbeee435a6603f84a77d8416a7d7b4" translate="yes" xml:space="preserve">
          <source>This tutorial is intended as a quick overview of algebra and arrays in NumPy and want to understand how n-dimensional (</source>
          <target state="translated">本教程旨在快速浏览NumPy中的代数和数组,想要了解n维(</target>
        </trans-unit>
        <trans-unit id="f3fb6c8e0c4b1a20c93f451ff612ab566979e83c" translate="yes" xml:space="preserve">
          <source>This type provides an iterator that encapsulates the concept of broadcasting. It allows</source>
          <target state="translated">该类型提供了一个封装广播概念的迭代器。它允许</target>
        </trans-unit>
        <trans-unit id="1cc43cfc53c5139a19951c354fea30226e0f77c2" translate="yes" xml:space="preserve">
          <source>This updates your feature branch with changes from the upstream &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy github&lt;/a&gt; repo. If you do not absolutely need to do this, try to avoid doing it, except perhaps when you are finished. The first step will be to update the remote repository with new commits from upstream:</source>
          <target state="translated">这将通过上游&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy github存储库中的&lt;/a&gt;更改来更新功能分支。如果您并非绝对需要这样做，请尝试避免这样做，除非您可能已完成。第一步将使用来自上游的新提交来更新远程存储库：</target>
        </trans-unit>
        <trans-unit id="fedc2274acc4b818673988228fa9cde0f7271aad" translate="yes" xml:space="preserve">
          <source>This usage is discouraged, because it is ambiguous with the other dict-based construction method. If you have a field called &amp;lsquo;names&amp;rsquo; and a field called &amp;lsquo;formats&amp;rsquo; there will be a conflict.</source>
          <target state="translated">不鼓励这种用法，因为它与其他基于dict的构造方法不明确。如果您有一个名为&amp;ldquo;名称&amp;rdquo;的字段和一个名为&amp;ldquo;格式&amp;rdquo;的字段，则将发生冲突。</target>
        </trans-unit>
        <trans-unit id="57872c5abdb149b7d4963cf4f155c74d4913dff4" translate="yes" xml:space="preserve">
          <source>This version replaces the ASCII string (which in practice was latin1) with a utf8-encoded string, so supports structured types with any unicode field names.</source>
          <target state="translated">这个版本用utf8编码的字符串替换了ASCII字符串(实际上是latin1),所以支持任何unicode字段名的结构化类型。</target>
        </trans-unit>
        <trans-unit id="edc2f7bd6317d38177dd997f322c5b71aa234a4f" translate="yes" xml:space="preserve">
          <source>This view has the same dtype and itemsize as the indexed field, so it is typically a non-structured array, except in the case of nested structures.</source>
          <target state="translated">这个视图的dtype和itemsize与索引字段相同,所以它通常是一个非结构化数组,除非是嵌套结构。</target>
        </trans-unit>
        <trans-unit id="f66a767f0f656eca452c102d2e2bcfa75e3b2eec" translate="yes" xml:space="preserve">
          <source>This way of working helps to keep work well organized and the history as clear as possible.</source>
          <target state="translated">这种工作方式有助于使工作有条不紊,历史沿革尽量清晰。</target>
        </trans-unit>
        <trans-unit id="bd10a8b1d06600ccbaab74bb218a771768eae1ee" translate="yes" xml:space="preserve">
          <source>This will ask for your key PGP passphrase, in order to sign the built source packages.</source>
          <target state="translated">这将要求你提供PGP密码,以便对构建的源码包进行签名。</target>
        </trans-unit>
        <trans-unit id="3b6efd49b695f694142bfb54798d0f3fc1890e14" translate="yes" xml:space="preserve">
          <source>This will be a new view object if possible; otherwise, it will be a copy. Note there is no guarantee of the &lt;em&gt;memory layout&lt;/em&gt; (C- or Fortran- contiguous) of the returned array.</source>
          <target state="translated">如果可能，这将是一个新的视图对象；否则，它将是副本。注意，不能保证返回数组的&lt;em&gt;内存布局&lt;/em&gt;（C或Fortran连续）。</target>
        </trans-unit>
        <trans-unit id="8a5efb1ea8118b8207bdfa5a6ca70f84b9755cf3" translate="yes" xml:space="preserve">
          <source>This will be the default for all columns</source>
          <target state="translated">这将是所有列的默认值</target>
        </trans-unit>
        <trans-unit id="6ee2bb240a6f906f9c6caaca502a22c771c78509" translate="yes" xml:space="preserve">
          <source>This will compile numpy on 4 CPUs and install it into the specified prefix. to perform a parallel in-place build, run:</source>
          <target state="translated">这将在4个CPU上编译numpy,并将其安装到指定的前缀中。要执行并行原地构建,请运行。</target>
        </trans-unit>
        <trans-unit id="82de4d27fe00c2e50e0f9b4ff494406f1e8a2a9f" translate="yes" xml:space="preserve">
          <source>This will create a report in &lt;code&gt;build/coverage&lt;/code&gt;, which can be viewed with:</source>
          <target state="translated">这将在 &lt;code&gt;build/coverage&lt;/code&gt; 中创建一个报告，该报告可以通过以下方式查看：</target>
        </trans-unit>
        <trans-unit id="8933167843c02b6efd0369f05c57b0cadbffbc22" translate="yes" xml:space="preserve">
          <source>This will install the file foo.ini into the directory package_dir/lib, and the foo.ini file will be generated from foo.ini.in, where each &lt;code&gt;@version@&lt;/code&gt; will be replaced by &lt;code&gt;subst_dict['version']&lt;/code&gt;. The dictionary has an additional prefix substitution rule automatically added, which contains the install prefix (since this is not easy to get from setup.py). npy-pkg-config files can also be installed at the same location as used for numpy, using the path returned from &lt;code&gt;get_npy_pkg_dir&lt;/code&gt; function.</source>
          <target state="translated">这会将foo.ini文件安装到package_dir / lib目录中，并且foo.ini文件将从foo.ini.in生成，其中每个 &lt;code&gt;@version@&lt;/code&gt; 都将由 &lt;code&gt;subst_dict['version']&lt;/code&gt; 替换。该词典有一个自动添加的附加前缀替换规则，其中包含安装前缀（因为从setup.py很难获得此前缀）。还可以使用 &lt;code&gt;get_npy_pkg_dir&lt;/code&gt; 函数返回的路径将npy-pkg-config文件安装在与numpy相同的位置。</target>
        </trans-unit>
        <trans-unit id="520884ce9a07e1b7b3267f965a90c87f51ddd2d6" translate="yes" xml:space="preserve">
          <source>This will open an editor with the following text in it:</source>
          <target state="translated">这将打开一个编辑器,里面有以下文字。</target>
        </trans-unit>
        <trans-unit id="939c7c1369b63ae063d5f436c52d25c44b07c327" translate="yes" xml:space="preserve">
          <source>This will produce an extension module named filter.so in the current directory with a method named dfilter2d that returns a filtered version of the input.</source>
          <target state="translated">这将在当前目录下产生一个名为filter.so的扩展模块,其中有一个名为dfilter2d的方法,它将返回输入的过滤版本。</target>
        </trans-unit>
        <trans-unit id="da4b4079ec57ef48d099df7ab2d17f04629ceaf5" translate="yes" xml:space="preserve">
          <source>This will work with MSVC, which otherwise chokes on very long strings.</source>
          <target state="translated">这将与MSVC一起工作,否则会对非常长的字符串感到窒息。</target>
        </trans-unit>
        <trans-unit id="09f5f63667326a5abebdc8b9ee9a7240e62a05f5" translate="yes" xml:space="preserve">
          <source>This will write the settings into your git configuration file, which should now contain a user section with your name and email:</source>
          <target state="translated">这将会把设置写入你的 git 配置文件中,现在该文件应该包含一个包含你的名字和电子邮件的用户部分。</target>
        </trans-unit>
        <trans-unit id="00582fa3dde2e164fba27e484b480804eaaba584" translate="yes" xml:space="preserve">
          <source>This works for both standard installs and in-place builds, i.e. the &lt;code&gt;@prefix@&lt;/code&gt; refer to the source directory for in-place builds.</source>
          <target state="translated">这适用于标准安装和就地构建，即 &lt;code&gt;@prefix@&lt;/code&gt; 指代就地构建的源目录。</target>
        </trans-unit>
        <trans-unit id="8dbc0909265236a8e2f517b68e39944b2e4da272" translate="yes" xml:space="preserve">
          <source>Those can be useful for precise floating point comparison.</source>
          <target state="translated">这些可以用于精确的浮点比较。</target>
        </trans-unit>
        <trans-unit id="ae29a3649bad434c98c44c18fb3c7ec696b132a3" translate="yes" xml:space="preserve">
          <source>Those who want really good performance out of their low level operations should strongly consider directly using the iteration API provided in C, but for those who are not comfortable with C or C++, Cython is a good middle ground with reasonable performance tradeoffs. For the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object, this means letting the iterator take care of broadcasting, dtype conversion, and buffering, while giving the inner loop to Cython.</source>
          <target state="translated">那些希望通过低级操作获得真正好的性能的人应该强烈考虑直接使用C中提供的迭代API，但是对于那些不熟悉C或C ++的人，Cython是一个很好的中间点，可以进行合理的性能折衷。对于&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;对象，这意味着让迭代器负责广播，dtype转换和缓冲，同时为Cython提供内部循环。</target>
        </trans-unit>
        <trans-unit id="69a5e45c8dfd90560d7c862ef6ebab38e4725ee6" translate="yes" xml:space="preserve">
          <source>Though the demonstrated way of wrapping Fortran routines to Python is very straightforward, it has several drawbacks (see the comments above). These drawbacks are due to the fact that there is no way that F2PY can determine what is the actual intention of one or the other argument, is it input or output argument, or both, or something else. So, F2PY conservatively assumes that all arguments are input arguments by default.</source>
          <target state="translated">虽然演示的将Fortran例程封装到Python的方式非常简单,但它有几个缺点(见上面的注释)。这些缺点是由于F2PY没有办法确定一个或另一个参数的实际意图是什么,是输入参数还是输出参数,还是两者都是,或者是其他什么。所以,F2PY保守地假设所有的参数都是默认的输入参数。</target>
        </trans-unit>
        <trans-unit id="4ea9f95f9e9b92d3d1f748e1eafd1b88bb106fab" translate="yes" xml:space="preserve">
          <source>Though we welcome people fluent in all languages, NumPy development is conducted in English.</source>
          <target state="translated">虽然我们欢迎精通各种语言的人,但NumPy的开发是用英语进行的。</target>
        </trans-unit>
        <trans-unit id="98cd6421fe23fe93d73ba2b3eea2e1d452707c95" translate="yes" xml:space="preserve">
          <source>Thread safe f2py callback functions</source>
          <target state="translated">线程安全的f2py回调函数</target>
        </trans-unit>
        <trans-unit id="35e557dff981ec6af1be9c041d1715ad421f55bd" translate="yes" xml:space="preserve">
          <source>Threading support</source>
          <target state="translated">线程支持</target>
        </trans-unit>
        <trans-unit id="2d3ac6352887bde0f838813d8ea2d7bd7a567c2f" translate="yes" xml:space="preserve">
          <source>Three common use cases are:</source>
          <target state="translated">三个常见的使用案例是:</target>
        </trans-unit>
        <trans-unit id="cfe35da7de09a2e27452780257d1fa8fced9ae75" translate="yes" xml:space="preserve">
          <source>Three ways to wrap - getting started</source>
          <target state="translated">三种包装方式--入门</target>
        </trans-unit>
        <trans-unit id="987f8885750fc51202cc3964c96525b26400aa8c" translate="yes" xml:space="preserve">
          <source>Three-by-two array of random numbers from [-5, 0):</source>
          <target state="translated">从[-5,0)开始的三乘二随机数组。</target>
        </trans-unit>
        <trans-unit id="648f2b8e04236f9ba0d33739777255491d46f3b0" translate="yes" xml:space="preserve">
          <source>Threshold below which SVD values are considered zero. If &lt;code&gt;tol&lt;/code&gt; is None, and &lt;code&gt;S&lt;/code&gt; is an array with singular values for &lt;code&gt;M&lt;/code&gt;, and &lt;code&gt;eps&lt;/code&gt; is the epsilon value for datatype of &lt;code&gt;S&lt;/code&gt;, then &lt;code&gt;tol&lt;/code&gt; is set to &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt;.</source>
          <target state="translated">低于该阈值的SVD值被视为零。如果 &lt;code&gt;tol&lt;/code&gt; 为None，并且 &lt;code&gt;S&lt;/code&gt; 为具有 &lt;code&gt;M&lt;/code&gt; 的奇异值的数组，并且 &lt;code&gt;eps&lt;/code&gt; 为 &lt;code&gt;S&lt;/code&gt; 的数据类型的epsilon值，则 &lt;code&gt;tol&lt;/code&gt; 设置为 &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a18ce980b9b6a0af6ba5335aa5043a3f61a2139" translate="yes" xml:space="preserve">
          <source>Throw a dice 20 times:</source>
          <target state="translated">扔一个骰子20次。</target>
        </trans-unit>
        <trans-unit id="e8597c496d58a52fd023424932f79f11d89743f4" translate="yes" xml:space="preserve">
          <source>Thus, tuples might be thought of as the native Python equivalent to numpy&amp;rsquo;s structured types, much like native python integers are the equivalent to numpy&amp;rsquo;s integer types. Structured scalars may be converted to a tuple by calling &lt;a href=&quot;../reference/generated/numpy.ndarray.item#numpy.ndarray.item&quot;&gt;&lt;code&gt;numpy.ndarray.item&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">因此，元组可以被视为等同于numpy的结构化类型的本机Python，就像本机python整数等效于numpy的整数类型一样。可以通过调用&lt;a href=&quot;../reference/generated/numpy.ndarray.item#numpy.ndarray.item&quot;&gt; &lt;code&gt;numpy.ndarray.item&lt;/code&gt; &lt;/a&gt;将结构化标量转换为元组：</target>
        </trans-unit>
        <trans-unit id="c6c62c18ed666f3768ae228e6da435d58941de5d" translate="yes" xml:space="preserve">
          <source>Thus, tuples might be thought of as the native Python equivalent to numpy&amp;rsquo;s structured types, much like native python integers are the equivalent to numpy&amp;rsquo;s integer types. Structured scalars may be converted to a tuple by calling &lt;code&gt;ndarray.item&lt;/code&gt;:</source>
          <target state="translated">因此，元组可以被视为等同于numpy的结构化类型的本机Python，就像本机python整数等效于numpy的整数类型一样。可以通过调用 &lt;code&gt;ndarray.item&lt;/code&gt; 将结构化标量转换为元组：</target>
        </trans-unit>
        <trans-unit id="699ce8b0c5a25495e7df7b31eb754f06f5937265" translate="yes" xml:space="preserve">
          <source>Tile an array.</source>
          <target state="translated">铺设一个阵列。</target>
        </trans-unit>
        <trans-unit id="9478b387e78ee7ed878f28def0d9d737a40db3cf" translate="yes" xml:space="preserve">
          <source>Tiling arrays</source>
          <target state="translated">平铺阵列</target>
        </trans-unit>
        <trans-unit id="ae9e32a7bf76d858a6643fb3d615f4e6b741df45" translate="yes" xml:space="preserve">
          <source>Time span (absolute)</source>
          <target state="translated">时间跨度(绝对值)</target>
        </trans-unit>
        <trans-unit id="83a0b67f984af7843f2cd5f9c4c4a4937a96b824" translate="yes" xml:space="preserve">
          <source>Time span (relative)</source>
          <target state="translated">时间跨度(相对)</target>
        </trans-unit>
        <trans-unit id="f427901653e2f16331f232b03616db8d30b0bf3e" translate="yes" xml:space="preserve">
          <source>Timedelta</source>
          <target state="translated">Timedelta</target>
        </trans-unit>
        <trans-unit id="4c953c5dc449ee95c79ccb8a9c6463f3dce00860" translate="yes" xml:space="preserve">
          <source>Timedelta64</source>
          <target state="translated">Timedelta64</target>
        </trans-unit>
        <trans-unit id="a836f04893b4c22a5902f8a189928c3d93f72795" translate="yes" xml:space="preserve">
          <source>Timezone information to use when displaying the datetime. If &amp;lsquo;UTC&amp;rsquo;, end with a Z to indicate UTC time. If &amp;lsquo;local&amp;rsquo;, convert to the local timezone first, and suffix with a +-#### timezone offset. If a tzinfo object, then do as with &amp;lsquo;local&amp;rsquo;, but use the specified timezone.</source>
          <target state="translated">显示日期时间时要使用的时区信息。如果为&amp;ldquo; UTC&amp;rdquo;，则以Z结尾以指示UTC时间。如果为'local'，请先转换为本地时区，并以+-####时区偏移量作为后缀。如果是tzinfo对象，则使用'local'，但使用指定的时区。</target>
        </trans-unit>
        <trans-unit id="73a38ab3a76b2ed7df0194513c7633ac39221da4" translate="yes" xml:space="preserve">
          <source>Timing of individual tests with &lt;code&gt;nose-timer&lt;/code&gt; (which needs to be installed). If True, time tests and report on all of them. If an integer (say &lt;code&gt;N&lt;/code&gt;), report timing results for &lt;code&gt;N&lt;/code&gt; slowest tests.</source>
          <target state="translated">使用 &lt;code&gt;nose-timer&lt;/code&gt; （需要安装）进行单个测试的时间安排。如果为True，则时间测试并报告所有这些结果。如果为整数（例如 &lt;code&gt;N&lt;/code&gt; ），则报告 &lt;code&gt;N&lt;/code&gt; 个最慢测试的计时结果。</target>
        </trans-unit>
        <trans-unit id="661d4063b8ec8980f63428513015c42d7d7a39d4" translate="yes" xml:space="preserve">
          <source>Timings</source>
          <target state="translated">Timings</target>
        </trans-unit>
        <trans-unit id="535904f7958066905a2c6d516287e9eeaaa0c6e1" translate="yes" xml:space="preserve">
          <source>Timsort and radix sort have replaced mergesort for stable sorting</source>
          <target state="translated">Timsort和radix sort取代了mergesort,实现了稳定的排序。</target>
        </trans-unit>
        <trans-unit id="18696f01e06a1b84af54b40680c306637cf01d64" translate="yes" xml:space="preserve">
          <source>Timsort is added for better performance on already or nearly sorted data. On random data timsort is almost identical to mergesort. It is now used for stable sort while quicksort is still the default sort if none is chosen. For details of timsort, refer to &lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt&lt;/a&gt;. &amp;lsquo;mergesort&amp;rsquo; and &amp;lsquo;stable&amp;rsquo; are mapped to radix sort for integer data types. Radix sort is an O(n) sort instead of O(n log n).</source>
          <target state="translated">添加Timsort可以提高对已分类或已分类数据的性能。在随机数据上，timsort与mergesort几乎相同。现在，它用于稳定排序，而如果未选择，则快速排序仍是默认排序。有关timsort的详细信息，请参见&lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt&lt;/a&gt;。'mergesort'和'stable'被映射为整数数据类型的基数排序。基数排序是O（n）排序，而不是O（n log n）。</target>
        </trans-unit>
        <trans-unit id="4c9ab7d1647422ac2345aafe56b9ec321ff2ddfd" translate="yes" xml:space="preserve">
          <source>Timsort is added for better performance on already or nearly sorted data. On random data timsort is almost identical to mergesort. It is now used for stable sort while quicksort is still the default sort if none is chosen. For timsort details, refer to &lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt&lt;/a&gt;. &amp;lsquo;mergesort&amp;rsquo; and &amp;lsquo;stable&amp;rsquo; are mapped to radix sort for integer data types. Radix sort is an O(n) sort instead of O(n log n).</source>
          <target state="translated">添加Timsort可以提高对已分类或已分类数据的性能。在随机数据上，timsort与mergesort几乎相同。现在，它用于稳定排序，而如果未选择，则快速排序仍是默认排序。有关音符的详细信息，请参阅&lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt&lt;/a&gt;。 'mergesort'和'stable'映射为整数数据类型的基数排序。基数排序是O（n）排序，而不是O（n log n）。</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="e4a5f9b37a824ec47658f0ce1a5ad5ba55b84339" translate="yes" xml:space="preserve">
          <source>Tip: &lt;code&gt;entry&lt;/code&gt; statement can be used to describe the signature of an arbitrary routine allowing F2PY to generate a number of wrappers from only one routine block signature. There are few restrictions while doing this: &lt;code&gt;fortranname&lt;/code&gt; cannot be used, &lt;code&gt;callstatement&lt;/code&gt; and &lt;code&gt;callprotoargument&lt;/code&gt; can be used only if they are valid for all entry routines, etc.</source>
          <target state="translated">提示： &lt;code&gt;entry&lt;/code&gt; 语句可用于描述任意例程的签名，从而允许F2PY仅从一个例程块签名生成许多包装器。有，而这样做一些限制： &lt;code&gt;fortranname&lt;/code&gt; 不能使用， &lt;code&gt;callstatement&lt;/code&gt; 和 &lt;code&gt;callprotoargument&lt;/code&gt; 只能如果它们是适用于所有入境程序等使用</target>
        </trans-unit>
        <trans-unit id="e96f3984eaaf637764ee32773288dabcc604bf6b" translate="yes" xml:space="preserve">
          <source>Tips &amp;amp; Tricks</source>
          <target state="translated">提示与技巧</target>
        </trans-unit>
        <trans-unit id="caa39d36bfce368de59fb6b06774c2bd179f06cf" translate="yes" xml:space="preserve">
          <source>Title case words start with uppercase characters, all remaining cased characters are lowercase.</source>
          <target state="translated">标题大小写字以大写字符开头,其余大小写字符均为小写。</target>
        </trans-unit>
        <trans-unit id="45c41172aa1c58d7ba017f081fcd4e2ace4e86f0" translate="yes" xml:space="preserve">
          <source>Title that is printed in the string representation of &lt;a href=&quot;#numpy.MachAr&quot;&gt;&lt;code&gt;MachAr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">以&lt;a href=&quot;#numpy.MachAr&quot;&gt; &lt;code&gt;MachAr&lt;/code&gt; &lt;/a&gt;的字符串表示形式打印的标题。</target>
        </trans-unit>
        <trans-unit id="20fb23c1b6aaaab924d80202c9bd41b9e867e2de" translate="yes" xml:space="preserve">
          <source>To Cython-ize this function, we replace the inner loop (y[&amp;hellip;] += x*x) with Cython code that&amp;rsquo;s specialized for the float64 dtype. With the &amp;lsquo;external_loop&amp;rsquo; flag enabled, the arrays provided to the inner loop will always be one-dimensional, so very little checking needs to be done.</source>
          <target state="translated">为了用Cython实现此功能，我们用专用于float64 dtype的Cython代码替换了内部循环（y [&amp;hellip;] + = x * x）。启用&amp;ldquo; external_loop&amp;rdquo;标志后，提供给内部循环的数组将始终是一维的，因此几乎不需要进行检查。</target>
        </trans-unit>
        <trans-unit id="36e086a6bd3eb648c4aebbd467026f4cd1c91bb0" translate="yes" xml:space="preserve">
          <source>To achieve a behaviour similar to the basic slicing above, broadcasting can be used. The function &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; can help with this broadcasting. This is best understood with an example.</source>
          <target state="translated">为了实现类似于上述基本切片的行为，可以使用广播。功能&lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt;可以帮助进行广播。最好用一个例子来理解。</target>
        </trans-unit>
        <trans-unit id="157492b79c5123115a363aac40a6322c3b4d23a2" translate="yes" xml:space="preserve">
          <source>To achieve what we want, we will make the following changes to it:</source>
          <target state="translated">为了达到我们的目的,我们将对其进行以下修改。</target>
        </trans-unit>
        <trans-unit id="d82eff9778b88421c109607c96725b336dc7bcf8" translate="yes" xml:space="preserve">
          <source>To actually build the binaries after everything is set up correctly, the release.sh script can be used. For details of the build process itself, it is best to read the pavement.py script.</source>
          <target state="translated">在一切设置正确后,可以使用release.sh脚本来实际构建二进制文件。关于编译过程本身的细节,最好阅读pavement.py脚本。</target>
        </trans-unit>
        <trans-unit id="c76b68b96c698129b0e21483e667a083f4f8f28a" translate="yes" xml:space="preserve">
          <source>To add the rows or the columns in a 2D array, you would specify the axis.</source>
          <target state="translated">要在二维数组中添加行或列,你需要指定轴。</target>
        </trans-unit>
        <trans-unit id="3f0b09a56b5f5cb6866275af7bae4ae9b88cd546" translate="yes" xml:space="preserve">
          <source>To add titles when using the list-of-tuples form of dtype specification, the field name may be specified as a tuple of two strings instead of a single string, which will be the field&amp;rsquo;s title and field name respectively. For example:</source>
          <target state="translated">要在使用dtype规范的元组列表形式时添加标题，可以将字段名指定为两个字符串的元组，而不是单个字符串，这将分别是字段的标题和字段名。例如：</target>
        </trans-unit>
        <trans-unit id="03c09cbfb1aed4718ffc26452a3968e86a1cd3bc" translate="yes" xml:space="preserve">
          <source>To allow the datetime to be used in contexts where only certain days of the week are valid, NumPy includes a set of &amp;ldquo;busday&amp;rdquo; (business day) functions.</source>
          <target state="translated">为了允许仅在一周中的某些天有效的上下文中使用日期时间，NumPy包括一组&amp;ldquo; busday&amp;rdquo;（工作日）功能。</target>
        </trans-unit>
        <trans-unit id="846af85fcfe300adce4c3f84895144d6dc4a75b5" translate="yes" xml:space="preserve">
          <source>To be completed.</source>
          <target state="translated">有待完成。</target>
        </trans-unit>
        <trans-unit id="f6ad91f78d6c9353549254a135a4c203ecca9427" translate="yes" xml:space="preserve">
          <source>To be consistent with surrounding code that also breaks it (maybe for historic reasons) &amp;ndash; although this is also an opportunity to clean up someone else&amp;rsquo;s mess.</source>
          <target state="translated">与也会破坏它的周围代码保持一致（也许是出于历史原因）&amp;ndash;尽管这也是清理他人混乱的机会。</target>
        </trans-unit>
        <trans-unit id="172099588df066f08374020a56522cb6cad0b84f" translate="yes" xml:space="preserve">
          <source>To become eligible to join the Steering Council, an individual must be a Project Contributor who has produced contributions that are substantial in quality and quantity, and sustained over at least one year. Potential Council Members are nominated by existing Council members, and become members following consensus of the existing Council members, and confirmation that the potential Member is interested and willing to serve in that capacity. The Council will be initially formed from the set of existing Core Developers who, as of late 2015, have been significantly active over the last year.</source>
          <target state="translated">要想加入指导委员会,个人必须是项目贡献者,在质量和数量上都做出了实质性的贡献,并且持续了至少一年。潜在的理事会成员由现有的理事会成员提名,在现有的理事会成员达成共识,并确认潜在的成员有兴趣和愿意担任该职务后,就会成为理事会成员。理事会将从现有核心发展商中初步组建,截至2015年底,这些核心发展商在过去一年中一直非常活跃。</target>
        </trans-unit>
        <trans-unit id="85134bce24b996ec39a48245eda44b01d4da42e0" translate="yes" xml:space="preserve">
          <source>To begin to make use of the new data-type, you need to first define a new Python type to hold the scalars of your new data-type. It should be acceptable to inherit from one of the array scalars if your new type has a binary compatible layout. This will allow your new data type to have the methods and attributes of array scalars. New data- types must have a fixed memory size (if you want to define a data-type that needs a flexible representation, like a variable-precision number, then use a pointer to the object as the data-type). The memory layout of the object structure for the new Python type must be PyObject_HEAD followed by the fixed-size memory needed for the data- type. For example, a suitable structure for the new Python type is:</source>
          <target state="translated">要开始使用新的数据类型,您需要首先定义一个新的 Python 类型来保存新数据类型的标量。如果您的新类型有一个二进制兼容的布局,那么从一个数组标量继承应该是可以接受的。这将允许你的新数据类型拥有数组标量的方法和属性。新的数据类型必须有一个固定的内存大小(如果你想定义一个需要灵活表示的数据类型,比如可变精度的数字,那么就使用一个指向对象的指针作为数据类型)。新的Python类型的对象结构的内存布局必须是PyObject_HEAD,然后是数据类型所需的固定大小的内存。例如,一个适合新Python类型的结构是。</target>
        </trans-unit>
        <trans-unit id="8c381239eecf186cabc8bbf33e7f7340c36dd415" translate="yes" xml:space="preserve">
          <source>To build an extension module, use</source>
          <target state="translated">要建立一个扩展模块,使用</target>
        </trans-unit>
        <trans-unit id="262ab678dba163772e713fb5aa569cad52138f55" translate="yes" xml:space="preserve">
          <source>To build any extension modules for Python, you&amp;rsquo;ll need a C compiler. Various NumPy modules use FORTRAN 77 libraries, so you&amp;rsquo;ll also need a FORTRAN 77 compiler installed.</source>
          <target state="translated">要为Python构建任何扩展模块，您将需要C编译器。各种NumPy模块都使用FORTRAN 77库，因此您还需要安装FORTRAN 77编译器。</target>
        </trans-unit>
        <trans-unit id="e7e5cfb4630032e513b61c1b673be491694cda68" translate="yes" xml:space="preserve">
          <source>To build docs, run &lt;code&gt;make&lt;/code&gt; from the &lt;code&gt;doc&lt;/code&gt; directory. &lt;code&gt;make help&lt;/code&gt; lists all targets. For example, to build the HTML documentation, you can run:</source>
          <target state="translated">要生成文档，请从 &lt;code&gt;doc&lt;/code&gt; 目录运行 &lt;code&gt;make&lt;/code&gt; 。 &lt;code&gt;make help&lt;/code&gt; 列出所有目标。例如，要构建HTML文档，可以运行：</target>
        </trans-unit>
        <trans-unit id="0116b47532b1c9e3e3765cf9819856a98d018b60" translate="yes" xml:space="preserve">
          <source>To build the PDF documentation, do instead:</source>
          <target state="translated">要建立PDF文档,请改用以下方法</target>
        </trans-unit>
        <trans-unit id="06915cfab63303daaadd53bd88f46eb60701ce38" translate="yes" xml:space="preserve">
          <source>To build the development version of NumPy and run tests, spawn interactive shells with the Python import paths properly set up etc., do one of:</source>
          <target state="translated">要构建NumPy的开发版并运行测试,生成交互式shell,正确设置Python导入路径等,请做其中一项。</target>
        </trans-unit>
        <trans-unit id="62e6dd105e1e44140e34cc1b1405df856709feb0" translate="yes" xml:space="preserve">
          <source>To build the final approximation matrix, we must understand how multiplication across different axes works.</source>
          <target state="translated">为了建立最终的近似矩阵,我们必须了解跨不同轴的乘法是如何工作的。</target>
        </trans-unit>
        <trans-unit id="9057f4f734687a0b8a5f3961b0c067a8d6921992" translate="yes" xml:space="preserve">
          <source>To change the dimensions of an array, you can omit one of the sizes which will then be deduced automatically:</source>
          <target state="translated">要改变数组的尺寸,你可以省略其中一个尺寸,然后会自动推导出来。</target>
        </trans-unit>
        <trans-unit id="59e2711afc65081105d063104c0dfaff7b844b23" translate="yes" xml:space="preserve">
          <source>To commit the staged files into the local copy of your repo, do &lt;code&gt;git
commit&lt;/code&gt;. At this point, a text editor will open up to allow you to write a commit message. Read the &lt;a href=&quot;#writing-the-commit-message&quot;&gt;commit message section&lt;/a&gt; to be sure that you are writing a properly formatted and sufficiently detailed commit message. After saving your message and closing the editor, your commit will be saved. For trivial commits, a short commit message can be passed in through the command line using the &lt;code&gt;-m&lt;/code&gt; flag. For example, &lt;code&gt;git commit -am &quot;ENH: Some message&quot;&lt;/code&gt;.</source>
          <target state="translated">要将暂存的文件提交到您的仓库的本地副本中，请执行 &lt;code&gt;git commit&lt;/code&gt; 。此时，将打开一个文本编辑器，使您可以编写提交消息。阅读&lt;a href=&quot;#writing-the-commit-message&quot;&gt;提交消息部分&lt;/a&gt;，以确保您正在编写格式正确且足够详细的提交消息。保存您的消息并关闭编辑器后，您的提交将被保存。对于琐碎的提交，可以使用 &lt;code&gt;-m&lt;/code&gt; 标志通过命令行传递简短的提交消息。例如， &lt;code&gt;git commit -am &quot;ENH: Some message&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e713f5c0c4fc2dee368727d5468ec1ab8e8b8170" translate="yes" xml:space="preserve">
          <source>To construct an extension module, use</source>
          <target state="translated">要构建一个扩展模块,使用</target>
        </trans-unit>
        <trans-unit id="4163e693f0e52983099e011b7813c35728efe745" translate="yes" xml:space="preserve">
          <source>To contribute code or documentation, you first need</source>
          <target state="translated">要贡献代码或文档,你首先需要</target>
        </trans-unit>
        <trans-unit id="1d3a9fa41ffe14d77bbc445c74fe6fd7a66d7a2d" translate="yes" xml:space="preserve">
          <source>To convert the type of an array, use the .astype() method (preferred) or the type itself as a function. For example:</source>
          <target state="translated">要转换数组的类型,请使用.astype()方法(首选)或将类型本身作为一个函数。例如:.astype()方法</target>
        </trans-unit>
        <trans-unit id="982c13e7b2d67cdbdf6848604f9d8f779a4cdca3" translate="yes" xml:space="preserve">
          <source>To create a NumPy array, you can use the function &lt;code&gt;np.array()&lt;/code&gt;.</source>
          <target state="translated">要创建NumPy数组，可以使用函数 &lt;code&gt;np.array()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8941cedf9a3b3622178e2a604f85c6f9966d6beb" translate="yes" xml:space="preserve">
          <source>To create a masked array where all values close to 1.e20 are invalid, we would do:</source>
          <target state="translated">要创建一个掩码数组,所有接近1.e20的值都是无效的,我们可以这样做。</target>
        </trans-unit>
        <trans-unit id="e67f8cba1a223a6d273b67fa4a3d036f127fda38" translate="yes" xml:space="preserve">
          <source>To create a sub-type, a similar procedure must be followed except only behaviors that are different require new entries in the type- object structure. All other entries can be NULL and will be filled in by &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt;&lt;code&gt;PyType_Ready&lt;/code&gt;&lt;/a&gt; with appropriate functions from the parent type(s). In particular, to create a sub-type in C follow these steps:</source>
          <target state="translated">要创建子类型，必须遵循类似的过程，只是只有不同的行为才需要在类型对象结构中添加新的条目。所有其他条目可以为NULL，并将由&lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt; &lt;code&gt;PyType_Ready&lt;/code&gt; &lt;/a&gt;填充，并带有来自父类型的适当函数。特别是，要在C中创建子类型，请按照以下步骤操作：</target>
        </trans-unit>
        <trans-unit id="fdf86d74a7427ac0a22c6f0a9b96d12080099d0c" translate="yes" xml:space="preserve">
          <source>To create an array with the second element invalid, we would do:</source>
          <target state="translated">要创建一个第二个元素无效的数组,我们可以这样做。</target>
        </trans-unit>
        <trans-unit id="27de4fde4d9713bb683ffd50eb85f9b3570fc745" translate="yes" xml:space="preserve">
          <source>To create sequences of numbers, NumPy provides the &lt;code&gt;arange&lt;/code&gt; function which is analogous to the Python built-in &lt;code&gt;range&lt;/code&gt;, but returns an array.</source>
          <target state="translated">为了创建数字序列，NumPy提供了 &lt;code&gt;arange&lt;/code&gt; 函数，该函数类似于Python内置的 &lt;code&gt;range&lt;/code&gt; ，但是返回一个数组。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
