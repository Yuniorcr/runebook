<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="214b3e9bcd5e1ce4cb3eb03f1746f3231f71c70e" translate="yes" xml:space="preserve">
          <source>New argument &lt;code&gt;norm&lt;/code&gt; to fft functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65d7f57dba91d1ed262b55abe89bdb164eff1d3" translate="yes" xml:space="preserve">
          <source>New argument to searchsorted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ecd4c7f94907d59305751bcafdcb9bad4a770c" translate="yes" xml:space="preserve">
          <source>New array creation function &lt;code&gt;geomspace&lt;/code&gt; added</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e0f24a840910ce77406e6c3faa2578e0ee8b90e" translate="yes" xml:space="preserve">
          <source>New array holding the result. If &lt;code&gt;out&lt;/code&gt; was specified, &lt;code&gt;out&lt;/code&gt; is returned.</source>
          <target state="translated">保存结果的新数组。如果 &lt;code&gt;out&lt;/code&gt; 指定， &lt;code&gt;out&lt;/code&gt; 则返回。</target>
        </trans-unit>
        <trans-unit id="38a5ab042919ce6f9d90bed68a738e6b078703dd" translate="yes" xml:space="preserve">
          <source>New array object with the dtype reflecting given change to the byte order.</source>
          <target state="translated">新的数组对象,其dtype反映了字节顺序的变化。</target>
        </trans-unit>
        <trans-unit id="71c51f79a440f52228e3edc751262a54d784d72f" translate="yes" xml:space="preserve">
          <source>New arrays can be constructed using the routines detailed in &lt;a href=&quot;routines.array-creation#routines-array-creation&quot;&gt;Array creation routines&lt;/a&gt;, and also by using the low-level &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; constructor:</source>
          <target state="translated">可以使用&lt;a href=&quot;routines.array-creation#routines-array-creation&quot;&gt;数组创建&lt;/a&gt;例程中详细介绍的例程来构造新数组，也可以使用低级&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;构造函数来构造新数组：</target>
        </trans-unit>
        <trans-unit id="171d410052cdb806b8270b25492c77025be74bc9" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;beta&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cffff670843dfb9c0209b60c46aed2a371bf04f" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;binomial&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26f06dfea4989e03ded567fcf990909f64fe7a1b" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;bytes&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab73f8a053a8d7603a1ba3284ebf04a0cb4f5b26" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;chisquare&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff95d4b24affe14b38acf3a4f05097d027326b61" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;choice&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="810ddb7c73829ca1b11159711180eed6bdf298f8" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;dirichlet&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eff0e31b26d49dd31eab76312d58576defadded4" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;exponential&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a1f23667f3debaa0d5dad4b05d0bf9dd800a308" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;f&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863fe8e16ea8cf251cf8b75a0794768adbd5e19b" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;gamma&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d83501d2e47192ef9e558154d555c7af6bf5a142" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;geometric&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f398ef6f42411ae99c1be5057213134e7aefdd1" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;gumbel&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5caecc46d9e2db4b4dc3ddac5b14df755b96f7a8" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;hypergeometric&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d0bd0f23607b6a00d80e1a135d263c0b3a2d589" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;integers&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b146720c7b5beb691c175bc8d6133f4df04fad" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;laplace&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf2ea3da048678b1fd17aa5bdb6b0017070b41d5" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;logistic&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f20e1b036b5791309e4885f9712ff7d420fdb3f1" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;lognormal&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc81a8e289d1619c5a927dd2eeae6fad204c5d2" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;logseries&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a849187c7a7894e3c4fc532f06660cb8fca0acd" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;multinomial&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d262a35e7e1c75e8a96b8cf1427ef29c40d66fdf" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;multivariate_normal&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c120b4ae85cf6cdc45d6f39dac3452ac7eb10da" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;negative_binomial&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b298bfc6d69f7fdf1f7afc4e419a7ed4d362f6a" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;noncentral_chisquare&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2644fd3abdb9b2878b3acdf066708bf4e23a9048" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;noncentral_f&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d6abd7095afeedb3f59c2d223473297d51403b" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;normal&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fadc73cb7cfe1e6bef035a727a08b81ec772d0d3" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;pareto&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96da2b59f6be3d26aaf3f7d4324c1e3de79fc470" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;permutation&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1b0299f9d2894173387ef8694563574dcb8be4" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;poisson&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b680c7ecf2d643cd406c1177c4c336f34694c522" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;power&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a017206711ace0b1b97a7e42a04e71a0e5982012" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;random&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be17b5cd0dc90469226bf91f90efe1df93e17d1c" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;rayleigh&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee81aaeebdc3dc6b356c6841cff5f7dc32dbf030" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;shuffle&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a998f12fa0bbe11a43238b40925fb6abdc4ba8e2" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;standard_cauchy&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f9ecb8f49e49a96ca12a99388d668d8568e7922" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;standard_exponential&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f431ecdfcfdbf687b67efdfc75f20461efd443da" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;standard_gamma&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2deb36da1eb6008e0a94bc084199bf695927d39" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;standard_normal&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9da65098d760cf54df03c58d021a89712dfacf20" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;standard_t&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90be4f7e314f60aa91447e5c1e77face7b2e213" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;triangular&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52481287e1d0448289d4ee4d2673357148c8e596" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;uniform&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34212f4cca25aa5b12187f26fe9b5122d4385c6" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;vonmises&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5620d832e69c50aee31825758d784280631276a" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;wald&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27755dba110a36474ef83c380bc0c63ce0d295c" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;weibull&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d08eaae6cfc8ec885fc4d2bb796cfcfbcb2d22" translate="yes" xml:space="preserve">
          <source>New code should use the &lt;code&gt;zipf&lt;/code&gt; method of a &lt;code&gt;default_rng()&lt;/code&gt; instance instead; see &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91db2d550765d15c7bc0c86d31aca58322c1d9a" translate="yes" xml:space="preserve">
          <source>New constant</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92796569bc787a5317a674c0a2c01f4c91c6c29" translate="yes" xml:space="preserve">
          <source>New context manager clear_and_catch_warnings for testing warnings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f42ec046563ca3f650842a147efcd2db12b887" translate="yes" xml:space="preserve">
          <source>New context manager for testing warnings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4fac23052b1dcb2b4624f5d9cba16c9e7c228c" translate="yes" xml:space="preserve">
          <source>New data types</source>
          <target state="translated">新数据类型</target>
        </trans-unit>
        <trans-unit id="489e817669af0fe309daf24d3c8181f6ed2fe8a3" translate="yes" xml:space="preserve">
          <source>New defines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c32fc380f2a0bdf89b8091b364037917be177e72" translate="yes" xml:space="preserve">
          <source>New deprecations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba85c7a6d9f8bb8efc5f21139a7cecc28876866" translate="yes" xml:space="preserve">
          <source>New dtype object with the given change to the byte order.</source>
          <target state="translated">新的dtype对象,其字节顺序有变化。</target>
        </trans-unit>
        <trans-unit id="ecee79d2168b42f41b5fbd6e8dace38d4f923313" translate="yes" xml:space="preserve">
          <source>New extensible &lt;code&gt;numpy.random&lt;/code&gt; module with selectable random number generators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8949499e3a35fbaba06d97fa566b77440c7e8d3" translate="yes" xml:space="preserve">
          <source>New features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3fc86d82a6de0b53298449d9ac80dd1fc6055d8" translate="yes" xml:space="preserve">
          <source>New from template - creating a new instance from a template instance. Examples include returning slices from a subclassed array, creating return types from ufuncs, and copying arrays. See &lt;a href=&quot;#new-from-template&quot;&gt;Creating new from template&lt;/a&gt; for more details</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80f552ed9855f5f22bd255b9e183a71156e1a87e" translate="yes" xml:space="preserve">
          <source>New function isclose</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699fa1d8f3dd23b6272374314d111a1a05bcd46d" translate="yes" xml:space="preserve">
          <source>New function np.broadcast_to for invoking array broadcasting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95573c0399238806000a58dc9794a803b87b7dba" translate="yes" xml:space="preserve">
          <source>New function numpy.random.choice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c26c5df57351c4d8d4b65eecfea922ecbd1c45" translate="yes" xml:space="preserve">
          <source>New functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc101081cdff7103bbf8028f0127a109fbfb47c2" translate="yes" xml:space="preserve">
          <source>New functions &lt;code&gt;full&lt;/code&gt; and &lt;code&gt;full_like&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4327774b0d57954dcba1f03a8291a4420263a323" translate="yes" xml:space="preserve">
          <source>New functions &lt;code&gt;nanmean&lt;/code&gt;, &lt;code&gt;nanvar&lt;/code&gt; and &lt;code&gt;nanstd&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b00810d12ab9f41c2ac3f03cba9ba0517a7c4f50" translate="yes" xml:space="preserve">
          <source>New functions &lt;code&gt;npy_get_floatstatus_barrier&lt;/code&gt; and &lt;code&gt;npy_clear_floatstatus_barrier&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67156330df303fa1457bae58f51d051f7cfbed7" translate="yes" xml:space="preserve">
          <source>New functions &lt;code&gt;partition&lt;/code&gt; and &lt;code&gt;argpartition&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5de72a4252ab8f9cac47a6df57c940e02e2a54e8" translate="yes" xml:space="preserve">
          <source>New in version 1.10.</source>
          <target state="translated">1.10版本的新内容。</target>
        </trans-unit>
        <trans-unit id="ee74779525ce6ea3a8b1fc727a0ddc5193261706" translate="yes" xml:space="preserve">
          <source>New in version 1.10.0.</source>
          <target state="translated">1.10.0版本的新内容。</target>
        </trans-unit>
        <trans-unit id="2137c292e37fe9b62a7e56dcac5cca8d87c732c0" translate="yes" xml:space="preserve">
          <source>New in version 1.10.2.</source>
          <target state="translated">1.10.2版本的新内容。</target>
        </trans-unit>
        <trans-unit id="b57cc8087c9358677643b8f46aefe5ea6a0ebecf" translate="yes" xml:space="preserve">
          <source>New in version 1.11.0.</source>
          <target state="translated">1.11.0版本的新内容。</target>
        </trans-unit>
        <trans-unit id="1f52d8d8231fcffc9a4988e057ca01cae7f187ff" translate="yes" xml:space="preserve">
          <source>New in version 1.12.</source>
          <target state="translated">1.12版本的新内容。</target>
        </trans-unit>
        <trans-unit id="2face774ecc2c81a3c162fc20b62b01c5a40600b" translate="yes" xml:space="preserve">
          <source>New in version 1.12.0.</source>
          <target state="translated">1.12.0版本的新内容。</target>
        </trans-unit>
        <trans-unit id="32bc036cd949326de853c34209b68daa86ff42a4" translate="yes" xml:space="preserve">
          <source>New in version 1.13.</source>
          <target state="translated">在1.13版本中新增。</target>
        </trans-unit>
        <trans-unit id="812239edd4c38dabb4bc944f5a4da690ae31f9fb" translate="yes" xml:space="preserve">
          <source>New in version 1.13.0.</source>
          <target state="translated">1.13.0版本的新内容。</target>
        </trans-unit>
        <trans-unit id="a7fcdebd6983bded23b35d285d786921ce208679" translate="yes" xml:space="preserve">
          <source>New in version 1.14.</source>
          <target state="translated">在1.14版本中新增。</target>
        </trans-unit>
        <trans-unit id="6b2dcd4a8e241be9f4eae8bcb83efab5457748ea" translate="yes" xml:space="preserve">
          <source>New in version 1.14.0.</source>
          <target state="translated">1.14.0版本的新内容。</target>
        </trans-unit>
        <trans-unit id="0c7220d3e19e89998d3991680045d41d18ccc08e" translate="yes" xml:space="preserve">
          <source>New in version 1.15.</source>
          <target state="translated">1.15版本的新内容。</target>
        </trans-unit>
        <trans-unit id="09e4bf640113b06a25e56a4fbced8359329ae65c" translate="yes" xml:space="preserve">
          <source>New in version 1.15.0.</source>
          <target state="translated">1.15.0版本的新内容。</target>
        </trans-unit>
        <trans-unit id="85339f6ed2b31c74822cb66dd6a2d31bfa788c2c" translate="yes" xml:space="preserve">
          <source>New in version 1.16.</source>
          <target state="translated">在1.16版本中新增。</target>
        </trans-unit>
        <trans-unit id="61f4d2a2c8ffd5cf207c22ed59f99b38e13075d9" translate="yes" xml:space="preserve">
          <source>New in version 1.16.0.</source>
          <target state="translated">1.16.0版本的新内容。</target>
        </trans-unit>
        <trans-unit id="62d4a9f6a334052c56ff0415a29a69f7c240cf9f" translate="yes" xml:space="preserve">
          <source>New in version 1.16: Now handles ufunc kwargs</source>
          <target state="translated">1.16版的新功能:现在可以处理ufunc kwargs。</target>
        </trans-unit>
        <trans-unit id="42dfbb15856498938c409aa40c4ada4a73e21225" translate="yes" xml:space="preserve">
          <source>New in version 1.17.</source>
          <target state="translated">在1.17版本中新增。</target>
        </trans-unit>
        <trans-unit id="5cea599387052388cbd15216728091ac0d338428" translate="yes" xml:space="preserve">
          <source>New in version 1.17.0.</source>
          <target state="translated">1.17.0版本的新内容。</target>
        </trans-unit>
        <trans-unit id="c8ac6e33ef2c306d6498f7cc4dabea4fd31d2ac3" translate="yes" xml:space="preserve">
          <source>New in version 1.18.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac2278dfd928db5f1e499314ec867999dd07d93" translate="yes" xml:space="preserve">
          <source>New in version 1.18.0: Complex dtypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="614a21cd691ac6ee3804a1fbba7e4f187921edac" translate="yes" xml:space="preserve">
          <source>New in version 1.19.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f0af1a4dfa46010272d778c802279254c6462c9" translate="yes" xml:space="preserve">
          <source>New in version 1.3.0.</source>
          <target state="translated">1.3.0版本的新内容。</target>
        </trans-unit>
        <trans-unit id="9527813b2a3a3264011530b12d4eddf3ee7657b0" translate="yes" xml:space="preserve">
          <source>New in version 1.4.0.</source>
          <target state="translated">1.4.0版本的新内容。</target>
        </trans-unit>
        <trans-unit id="458a5758c6edd3424a27a61b460f5140fa37df00" translate="yes" xml:space="preserve">
          <source>New in version 1.5.</source>
          <target state="translated">在1.5版本中新增。</target>
        </trans-unit>
        <trans-unit id="c49cc9996bfcd59e0da5f20e5bce367a012c5e0f" translate="yes" xml:space="preserve">
          <source>New in version 1.5.0.</source>
          <target state="translated">1.5.0版本的新内容。</target>
        </trans-unit>
        <trans-unit id="5d1d2b91339374b014df11afd4f98aa79d1344f9" translate="yes" xml:space="preserve">
          <source>New in version 1.6.</source>
          <target state="translated">1.6版本中的新功能。</target>
        </trans-unit>
        <trans-unit id="dfdfe03f7110f5405041e6eca339a00633ba49ec" translate="yes" xml:space="preserve">
          <source>New in version 1.6.0.</source>
          <target state="translated">1.6.0版本的新内容。</target>
        </trans-unit>
        <trans-unit id="f7f92c6e6757974911ee86348b393509f5bdd7e0" translate="yes" xml:space="preserve">
          <source>New in version 1.7.</source>
          <target state="translated">在1.7版本中新增。</target>
        </trans-unit>
        <trans-unit id="3dcb523c8b35ef7bba188a1b72a37583d73585c0" translate="yes" xml:space="preserve">
          <source>New in version 1.7.0.</source>
          <target state="translated">1.7.0版本的新内容。</target>
        </trans-unit>
        <trans-unit id="1c84e255c5c378cd467bff47f5dd6753f326781e" translate="yes" xml:space="preserve">
          <source>New in version 1.7.0: When &lt;code&gt;comments&lt;/code&gt; is set to &lt;code&gt;None&lt;/code&gt;, no lines are treated as comments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636a6686cd06672fd21e245ea6635b6a844c2465" translate="yes" xml:space="preserve">
          <source>New in version 1.8.0.</source>
          <target state="translated">1.8.0版本的新内容。</target>
        </trans-unit>
        <trans-unit id="0fafb453d87efde6f16b32de7b47ff78521304b8" translate="yes" xml:space="preserve">
          <source>New in version 1.9.0.</source>
          <target state="translated">1.9.0版本的新内容。</target>
        </trans-unit>
        <trans-unit id="f8cec398c70fd8647fa6846f110c387ca17f4512" translate="yes" xml:space="preserve">
          <source>New in version 1.9.1.</source>
          <target state="translated">1.9.1版本的新内容。</target>
        </trans-unit>
        <trans-unit id="b8491900b81de43a6e32f0c78b17bad686513b91" translate="yes" xml:space="preserve">
          <source>New instance of generator jumped iter times</source>
          <target state="translated">生成器跳转次数的新实例</target>
        </trans-unit>
        <trans-unit id="fc2b6cc9627169b86508e4b8ab48bafeca6f7653" translate="yes" xml:space="preserve">
          <source>New instance of series with reduced degree.</source>
          <target state="translated">程度降低的系列的新实例。</target>
        </trans-unit>
        <trans-unit id="a5da6859165928f5c813a374a7d4b0543322485c" translate="yes" xml:space="preserve">
          <source>New instance of series with truncated coefficients.</source>
          <target state="translated">具有截断系数的序列的新实例。</target>
        </trans-unit>
        <trans-unit id="c6676cbd100e57f0cf1ec7cc325f32be5a2a8788" translate="yes" xml:space="preserve">
          <source>New instances of an ndarray subclass can also come about by a very similar mechanism to &lt;a href=&quot;#view-casting&quot;&gt;View casting&lt;/a&gt;, when numpy finds it needs to create a new instance from a template instance. The most obvious place this has to happen is when you are taking slices of subclassed arrays. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db00cc0ebdc2d69779c426ff23dfc78dc603a1ea" translate="yes" xml:space="preserve">
          <source>New iterator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6863f282d2bea7803e28fd5da0cdfaa90f3ad8" translate="yes" xml:space="preserve">
          <source>New iterators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef8bbaa32a82338b1a59df6751668e54a976333" translate="yes" xml:space="preserve">
          <source>New keywords added to &lt;code&gt;nan_to_num&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a96bfb6558aadfb4da204bf5a8956ecfe8210d" translate="yes" xml:space="preserve">
          <source>New masked array functions &lt;code&gt;ma.convolve&lt;/code&gt; and &lt;code&gt;ma.correlate&lt;/code&gt; added</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf93926f71505d428d341a1359b00cf5aeded8f" translate="yes" xml:space="preserve">
          <source>New mode &amp;ldquo;empty&amp;rdquo; for &lt;code&gt;pad&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a51c6c05bfb85b762792a9c8ebe6fb9ee936ee" translate="yes" xml:space="preserve">
          <source>New modes for qr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523ec3c57808292a3bf17f8c1297cfd60287c32f" translate="yes" xml:space="preserve">
          <source>New nanfunctions &lt;code&gt;nancumsum&lt;/code&gt; and &lt;code&gt;nancumprod&lt;/code&gt; added</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f3ea68bd7336e5347f53af975acad8f603c4f2" translate="yes" xml:space="preserve">
          <source>New polynomial evaluation function &lt;code&gt;polyvalfromroots&lt;/code&gt; added</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61e1029a6f8ab7f576d054948d33959140f495f6" translate="yes" xml:space="preserve">
          <source>New polynomial support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec4eec2219ca618ced51cc8f879058123677579" translate="yes" xml:space="preserve">
          <source>New recommended way of obtaining the same functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02c9ab716cd5d08c0fc39e2b190c65f62de6f0b" translate="yes" xml:space="preserve">
          <source>New since June 16, 2006:</source>
          <target state="translated">自2006年6月16日以来,新。</target>
        </trans-unit>
        <trans-unit id="71c457dffb57af010a339225925606446ae8f1c8" translate="yes" xml:space="preserve">
          <source>New ufuncs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627b8828449adbe008d0354d8596b48d56e939d5" translate="yes" xml:space="preserve">
          <source>New value &lt;code&gt;unscaled&lt;/code&gt; for option &lt;code&gt;cov&lt;/code&gt; in &lt;code&gt;np.polyfit&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="163a2d38fe73630c6f811cc1ebd4ca50c54bc0cf" translate="yes" xml:space="preserve">
          <source>New view of array with the same data.</source>
          <target state="translated">具有相同数据的数组的新视图。</target>
        </trans-unit>
        <trans-unit id="8c38aca7649def5a3434c6c996d36271b6eb6ab0" translate="yes" xml:space="preserve">
          <source>New views into arrays mean the object reference counts for the data buffer increase. Simply doing away with the original array object will not remove the data buffer if other views of it still exist.</source>
          <target state="translated">新的视图进入数组意味着数据缓冲区的对象引用次数增加。如果数据缓冲区的其他视图仍然存在,那么简单地取消原数组对象并不会删除数据缓冲区。</target>
        </trans-unit>
        <trans-unit id="8949ee1ec6ebd06bb3b176ea29d7ed7db2f74765" translate="yes" xml:space="preserve">
          <source>Newline to use when reading text file.</source>
          <target state="translated">读取文本文件时使用新行。</target>
        </trans-unit>
        <trans-unit id="50bc63095955b830ba997c7e6236445603ecf3c8" translate="yes" xml:space="preserve">
          <source>Next we create a histogram H with random bin content:</source>
          <target state="translated">接下来我们创建一个随机宾语内容的直方图H。</target>
        </trans-unit>
        <trans-unit id="bf23ce5ad9347090c46307e02b73cc0fb49a03e6" translate="yes" xml:space="preserve">
          <source>Next you need to write a Python script that invokes the C code whose execution you want to debug. For instance &lt;code&gt;mytest.py&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e57e92090bec2209645d4afb9ffad76205ecb4b" translate="yes" xml:space="preserve">
          <source>Next, an appropriate 1-D loop is selected from the 1-D loops available to the ufunc based on the input array types. This 1-D loop is selected by trying to match the signature of the data-types of the inputs against the available signatures. The signatures corresponding to built-in types are stored in the types member of the ufunc structure. The signatures corresponding to user-defined types are stored in a linked-list of function-information with the head element stored as a &lt;code&gt;CObject&lt;/code&gt; in the userloops dictionary keyed by the data-type number (the first user-defined type in the argument list is used as the key). The signatures are searched until a signature is found to which the input arrays can all be cast safely (ignoring any scalar arguments which are not allowed to determine the type of the result). The implication of this search procedure is that &amp;ldquo;lesser types&amp;rdquo; should be placed below &amp;ldquo;larger types&amp;rdquo; when the signatures are stored. If no 1-D loop is found, then an error is reported. Otherwise, the argument_list is updated with the stored signature &amp;mdash; in case casting is necessary and to fix the output types assumed by the 1-D loop.</source>
          <target state="translated">接下来，根据输入数组类型，从ufunc可用的1-D循环中选择适当的1-D循环。通过尝试将输入数据类型的签名与可用签名进行匹配来选择此一维循环。与内置类型相对应的签名存储在ufunc结构的type成员中。与用户定义类型相对应的签名存储在功能信息的链接列表中，头元素存储为 &lt;code&gt;CObject&lt;/code&gt; 在userloops词典中，以数据类型编号为键（参数列表中的第一个用户定义类型用作键）。搜索签名直到找到一个签名，所有输入数组都可以安全地投射到该签名（忽略不允许确定结果类型的任何标量参数）。此搜索过程的含义是，在存储签名时，应将&amp;ldquo;较小类型&amp;rdquo;放在&amp;ldquo;较大类型&amp;rdquo;下面。如果未找到一维循环，则报告错误。否则，将使用存储的签名更新arguments_list，以防万一需要强制转换并修复一维循环假定的输出类型。</target>
        </trans-unit>
        <trans-unit id="ca0df18be061d5dd78cd954902c95b86a71b79a8" translate="yes" xml:space="preserve">
          <source>Next, define a simple selection function that chooses which addition function to call in the shared library based on the data-type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32a35c866721c17fa1127788996e925157bbd5de" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll teach F2PY that the argument &lt;code&gt;n&lt;/code&gt; is an input argument (use &lt;code&gt;intent(in)&lt;/code&gt; attribute) and that the result, i.e. the contents of &lt;code&gt;a&lt;/code&gt; after calling Fortran function &lt;code&gt;FIB&lt;/code&gt;, should be returned to Python (use &lt;code&gt;intent(out)&lt;/code&gt; attribute). In addition, an array &lt;code&gt;a&lt;/code&gt; should be created dynamically using the size given by the input argument &lt;code&gt;n&lt;/code&gt; (use &lt;code&gt;depend(n)&lt;/code&gt; attribute to indicate dependence relation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3157cc60eb952860e4c3cca9c33515b18c93d15" translate="yes" xml:space="preserve">
          <source>Next, you need to update the feature branch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf186c484ce590fa10a51c09653de8be6d2834d2" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;__init__&lt;/code&gt; method is needed because the array is fully initialized after the &lt;code&gt;__new__&lt;/code&gt; method.</source>
          <target state="translated">不需要 &lt;code&gt;__init__&lt;/code&gt; 方法，因为数组是在 &lt;code&gt;__new__&lt;/code&gt; 方法之后完全初始化的。</target>
        </trans-unit>
        <trans-unit id="dd455b9529fecdbb04a2c8c80d81baca756fcca7" translate="yes" xml:space="preserve">
          <source>No Copy at All</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c7932583e083f39f650d8f061e29114fcc4b6a" translate="yes" xml:space="preserve">
          <source>No binaries are provided, but successful builds on Solaris and BSD have been reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c3dcc853e64dc42c790ee26da7efc4e746bf63" translate="yes" xml:space="preserve">
          <source>No changes are ever committed without review and approval by a core team member.Please ask politely on the PR or on the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-devel&quot;&gt;mailing list&lt;/a&gt; if you get no response to your pull request within a week.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8570c197653fe6b0eacc0ca96f49ba723bf2032" translate="yes" xml:space="preserve">
          <source>No check is performed to ensure &lt;code&gt;a_min &amp;lt; a_max&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516f0b8a0fa428e243c33ed546e2201d8645fde8" translate="yes" xml:space="preserve">
          <source>No compiler warnings with major compilers (gcc, VC++, a few others). Note: NumPy still produces compiler warnings that need to be addressed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cae83812416c083c256005088174c317c5a449a" translate="yes" xml:space="preserve">
          <source>No copy is performed if the input is already an &lt;code&gt;ndarray&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is a subclass of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, a base class &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果输入已经是 &lt;code&gt;ndarray&lt;/code&gt; ,则不执行复制。如果 &lt;code&gt;a&lt;/code&gt; 是&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;的子类，则返回基类&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e80f03a42fee08fa1b92e4b2dfdac69d694ebb2" translate="yes" xml:space="preserve">
          <source>No dependencies on other tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac6674ae66d20f8612e6a9033f82febe3be33252" translate="yes" xml:space="preserve">
          <source>No line should be longer than 80 characters. If this and the previous rule together don&amp;rsquo;t give you enough room to code, your code is too complicated, consider using subroutines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c6ee0e85803f223f758290809cc2dcf9fe96c3" translate="yes" xml:space="preserve">
          <source>No line should end in whitespace. If you think you need significant trailing whitespace, think again, somebody&amp;rsquo;s editor might delete it as a matter of routine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77355bfbd3431219dd73add4389cf42f70c6c798" translate="yes" xml:space="preserve">
          <source>No matter how you identify yourself or how others perceive you: we welcome you. Though no list can hope to be comprehensive, we explicitly honour diversity in: age, culture, ethnicity, genotype, gender identity or expression, language, national origin, neurotype, phenotype, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, subculture and technical ability, to the extent that these do not conflict with this code of conduct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76323b6da52d7b072aa3d27e6e9d4ecedea40add" translate="yes" xml:space="preserve">
          <source>Non-Fortran files use a separate syntax for defining template blocks that should be repeated using a variable expansion similar to the named repeat rules of the Fortran-specific repeats.</source>
          <target state="translated">非Fortran文件使用单独的语法来定义应该重复的模板块,使用类似于Fortran专用重复的命名重复规则的变量扩展。</target>
        </trans-unit>
        <trans-unit id="4a8530b9290c7b89c5a133ea25958b92a0343e30" translate="yes" xml:space="preserve">
          <source>Non-centrality parameter, the sum of the squares of the numerator means, must be &amp;gt;= 0.</source>
          <target state="translated">非中心参数（分子平均值的平方和）必须&amp;gt; = 0。</target>
        </trans-unit>
        <trans-unit id="9c0b7a927a0015195afa15eb9f2b48afcee390b4" translate="yes" xml:space="preserve">
          <source>Non-centrality, must be non-negative.</source>
          <target state="translated">非中心性,必须是非负数。</target>
        </trans-unit>
        <trans-unit id="9e2fb3f8fa482f96121ea5da26a76031530ab359" translate="yes" xml:space="preserve">
          <source>Non-integer reduction axis indexes are deprecated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad580bcb2a86f0517a2cf15d8c2a98b1cd0d7d2" translate="yes" xml:space="preserve">
          <source>Non-integer scalars for sequence repetition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71fc6b4ffd723235e15c0640143427962ad2248d" translate="yes" xml:space="preserve">
          <source>Non-logical {0,1} inputs: NumPy&amp;rsquo;s output is the bitwise AND of the inputs. Matlab treats any non-zero value as 1 and returns the logical AND. For example (3 &amp;amp; 4) in NumPy is 0, while in Matlab both 3 and 4 are considered logical true and (3 &amp;amp; 4) returns 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="f7041ff08b00120258d466a2faf6be32fb853f32" translate="yes" xml:space="preserve">
          <source>None &amp;ndash; Same as &amp;lsquo;A&amp;rsquo;.</source>
          <target state="translated">无&amp;ndash;与&amp;ldquo; A&amp;rdquo;相同。</target>
        </trans-unit>
        <trans-unit id="b888371d49cbde0d245f7788f812064eb17c0ad9" translate="yes" xml:space="preserve">
          <source>None of these methods is completely satisfactory if some entries have been marked as invalid. As a general rule, where a representation of the array is required without any masked entries, it is recommended to fill the array with the &lt;a href=&quot;generated/numpy.ma.filled#numpy.ma.filled&quot;&gt;&lt;code&gt;filled&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果某些条目被标记为无效，则这些方法都不能完全令人满意。通常，在不需要任何屏蔽条目的情况下需要数组表示的情况下，建议使用&lt;a href=&quot;generated/numpy.ma.filled#numpy.ma.filled&quot;&gt; &lt;code&gt;filled&lt;/code&gt; &lt;/a&gt;方法填充数组。</target>
        </trans-unit>
        <trans-unit id="7b7d2f7d6998508985f3f62c5db9370568a0fb76" translate="yes" xml:space="preserve">
          <source>None or &amp;lsquo;&amp;rsquo; - run all tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c95bcb0dc763b3f457f528928d9f7c63ec8ca3" translate="yes" xml:space="preserve">
          <source>None or an object exposing the array interface. All elements of the mask array should be interpreted only as true or not true indicating which elements of this array are valid. The shape of this object should be &lt;code&gt;&amp;ldquo;broadcastable&amp;rdquo;&lt;/code&gt; to the shape of the original array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e8532c794e2fc5caff50dd156382c7720e5446" translate="yes" xml:space="preserve">
          <source>None or no argument: reverses the order of the axes.</source>
          <target state="translated">无或无参数:颠倒轴的顺序。</target>
        </trans-unit>
        <trans-unit id="e47d8eef8570b0e18926c18050534f730ab8e5c8" translate="yes" xml:space="preserve">
          <source>Norm of the matrix or vector(s).</source>
          <target state="translated">矩阵或向量的规范。</target>
        </trans-unit>
        <trans-unit id="b8c54e5e1e867a54e9d75697c450f4be835f910e" translate="yes" xml:space="preserve">
          <source>Normalization</source>
          <target state="translated">Normalization</target>
        </trans-unit>
        <trans-unit id="0b0217a85ab435c082afb52e02247358f17b1f00" translate="yes" xml:space="preserve">
          <source>Normalization mode (see &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt;). Default is None.</source>
          <target state="translated">规范化模式（请参阅&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt;）。默认为无。</target>
        </trans-unit>
        <trans-unit id="c445e9b30ac2ceb289c3da952d2d450daf883a7c" translate="yes" xml:space="preserve">
          <source>Normalized &lt;code&gt;start&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3993a186bf900c9e7069eda8aac128d0fadacaa" translate="yes" xml:space="preserve">
          <source>Normalized covariance matrix</source>
          <target state="translated">归一化协方差矩阵</target>
        </trans-unit>
        <trans-unit id="44902c8cdeca3ae591a8f52f4136e69394f62f9d" translate="yes" xml:space="preserve">
          <source>Normally in numpy &amp;gt;= 1.14, assignment of one structured array to another copies fields &amp;ldquo;by position&amp;rdquo;, meaning that the first field from the src is copied to the first field of the dst, and so on, regardless of field name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41da0906993e9cfde34cf41207ccd4c7df0e4a4" translate="yes" xml:space="preserve">
          <source>Normally, all project decisions will be made by consensus of all interested Contributors. The primary goal of this approach is to ensure that the people who are most affected by and involved in any given change can contribute their knowledge in the confidence that their voices will be heard, because thoughtful review from a broad community is the best mechanism we know of for creating high-quality software.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc19d5f7dd31b35abbf5fbcd85986e7c1aaed7a5" translate="yes" xml:space="preserve">
          <source>Normals</source>
          <target state="translated">Normals</target>
        </trans-unit>
        <trans-unit id="0cbceae856b9c0cbd7495596dcc85b9b32547ec4" translate="yes" xml:space="preserve">
          <source>Normals (&lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">法线（&lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="1f42a8cc1d95dfa1e8aaac37d55ee0fd4cbf72c7" translate="yes" xml:space="preserve">
          <source>Norms and other numbers</source>
          <target state="translated">规范和其他数字</target>
        </trans-unit>
        <trans-unit id="d624a05adbd192dbe2a67a3ef1a9be0886fcc8bd" translate="yes" xml:space="preserve">
          <source>Not a Number (NaN), positive infinity and negative infinity evaluate to &lt;code&gt;True&lt;/code&gt; because these are not equal to zero.</source>
          <target state="translated">非数字（NaN），正无穷大和负无穷大的取值为 &lt;code&gt;True&lt;/code&gt; ,因为它们不等于零。</target>
        </trans-unit>
        <trans-unit id="8356fe7ff6e3e49c80008f397fe45e20cb3a2f85" translate="yes" xml:space="preserve">
          <source>Not a Number, positive infinity and negative infinity are considered to be non-finite.</source>
          <target state="translated">不是一个数,正无穷和负无穷被认为是非无穷的。</target>
        </trans-unit>
        <trans-unit id="e52d39123568232ca635480c53e43b0469ba9eab" translate="yes" xml:space="preserve">
          <source>Not a Number, positive infinity and negative infinity.</source>
          <target state="translated">不是一个数字,正无穷和负无穷。</target>
        </trans-unit>
        <trans-unit id="fe1dd107a8241c2c29b3e39d5565478e3e048114" translate="yes" xml:space="preserve">
          <source>Not a coder? Not a problem! NumPy is multi-faceted, and we can use a lot of help. These are all activities we&amp;rsquo;d like to get help with (they&amp;rsquo;re all important, so we list them in alphabetical order):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281287633ba6aa760863c08cbb0b3b45f5a5c723" translate="yes" xml:space="preserve">
          <source>Not as flexible as manual wrapping</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c846f67ecb1917ec7e71fb5a8684749f42f0bc4f" translate="yes" xml:space="preserve">
          <source>Not implemented (virtual attribute)</source>
          <target state="translated">未执行(虚拟属性)</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="9afbacf486c94c55e4d034463db7bf2d4c536c67" translate="yes" xml:space="preserve">
          <source>Note : Although tile may be used for broadcasting, it is strongly recommended to use numpy&amp;rsquo;s broadcasting operations and functions.</source>
          <target state="translated">注意：尽管可以将tile用于广播，但强烈建议使用numpy的广播操作和功能。</target>
        </trans-unit>
        <trans-unit id="259d59fbe7f0cc857f345f0e3e7e778ac1aa68e9" translate="yes" xml:space="preserve">
          <source>Note how</source>
          <target state="translated">请注意</target>
        </trans-unit>
        <trans-unit id="af3f83322f07820f94f42dd87d4f38eaa0e197b2" translate="yes" xml:space="preserve">
          <source>Note how in all cases the leading coefficient is always 1.</source>
          <target state="translated">请注意在所有情况下,前导系数总是1。</target>
        </trans-unit>
        <trans-unit id="d26d19110910e4826f9f87789fa949520b0996d8" translate="yes" xml:space="preserve">
          <source>Note how the convolution operator flips the second array before &amp;ldquo;sliding&amp;rdquo; the two across one another:</source>
          <target state="translated">请注意，卷积运算符如何翻转第二个数组，然后才将它们&amp;ldquo;滑动&amp;rdquo;在一起：</target>
        </trans-unit>
        <trans-unit id="73485c551679de8ea4306656d0c9328c71ffa786" translate="yes" xml:space="preserve">
          <source>Note on string types</source>
          <target state="translated">关于字符串类型的说明</target>
        </trans-unit>
        <trans-unit id="da7038b6159ab37164aeb7442907c881108aff7e" translate="yes" xml:space="preserve">
          <source>Note that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b12eb74ee5a29a04ee8a4cf874454eec65e1b8" translate="yes" xml:space="preserve">
          <source>Note that +0 and -0 are distinct floating point numbers, as are +inf and -inf.</source>
          <target state="translated">请注意,+0和-0是不同的浮点数,+inf和-inf也是如此。</target>
        </trans-unit>
        <trans-unit id="413f63febbc514d91f5b20aa1b682b931fd8a13f" translate="yes" xml:space="preserve">
          <source>Note that 3 = 6 / 2!, and that the constants are given in the order of integrations. Constant of the highest-order polynomial term comes first:</source>
          <target state="translated">请注意,3=6/2!,常数是按照积分的顺序给出的。最高阶多项式项的常数在前。</target>
        </trans-unit>
        <trans-unit id="33ed96a05ac01ee77e6588fa7daed4c8d2903c35" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#c.npy_clear_floatstatus_barrier&quot;&gt;&lt;code&gt;npy_clear_floatstatus_barrier&lt;/code&gt;&lt;/a&gt; is preferable as it prevents aggressive compiler optimizations reordering the call relative to the code setting the status, which could lead to incorrect results.</source>
          <target state="translated">请注意，&lt;a href=&quot;#c.npy_clear_floatstatus_barrier&quot;&gt; &lt;code&gt;npy_clear_floatstatus_barrier&lt;/code&gt; &lt;/a&gt;是可取的，因为它可以防止积极的编译器优化相对于设置状态的代码对调用进行重新排序，这可能导致错误的结果。</target>
        </trans-unit>
        <trans-unit id="85b21f1a6771aff0ba6f35f6104e5f5ecceb9fb5" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#c.npy_get_floatstatus_barrier&quot;&gt;&lt;code&gt;npy_get_floatstatus_barrier&lt;/code&gt;&lt;/a&gt; is preferable as it prevents aggressive compiler optimizations reordering the call relative to the code setting the status, which could lead to incorrect results.</source>
          <target state="translated">请注意，&lt;a href=&quot;#c.npy_get_floatstatus_barrier&quot;&gt; &lt;code&gt;npy_get_floatstatus_barrier&lt;/code&gt; &lt;/a&gt;是可取的，因为它可以防止积极的编译器优化相对于设置状态的代码对调用进行重新排序，这可能导致错误的结果。</target>
        </trans-unit>
        <trans-unit id="884c974c1824245efec48b1737298664c2d93974" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#numpy.vdot&quot;&gt;&lt;code&gt;vdot&lt;/code&gt;&lt;/a&gt; handles multidimensional arrays differently than &lt;a href=&quot;numpy.dot#numpy.dot&quot;&gt;&lt;code&gt;dot&lt;/code&gt;&lt;/a&gt;: it does &lt;em&gt;not&lt;/em&gt; perform a matrix product, but flattens input arguments to 1-D vectors first. Consequently, it should only be used for vectors.</source>
          <target state="translated">注意，&lt;a href=&quot;#numpy.vdot&quot;&gt; &lt;code&gt;vdot&lt;/code&gt; &lt;/a&gt;处理多维数组不同于&lt;a href=&quot;numpy.dot#numpy.dot&quot;&gt; &lt;code&gt;dot&lt;/code&gt; &lt;/a&gt;：它&lt;em&gt;不&lt;/em&gt;首先执行一个矩阵的产品，但平坦化输入参数1-d向量。因此，它仅应用于向量。</target>
        </trans-unit>
        <trans-unit id="43b655e0c3385ff52e0a83639474b14aafde8528" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;generated/numpy.asarray#numpy.asarray&quot;&gt;&lt;code&gt;asarray&lt;/code&gt;&lt;/a&gt; always returns the base-class ndarray. If you are confident that your use of the array object can handle any subclass of an ndarray, then &lt;a href=&quot;generated/numpy.asanyarray#numpy.asanyarray&quot;&gt;&lt;code&gt;asanyarray&lt;/code&gt;&lt;/a&gt; can be used to allow subclasses to propagate more cleanly through your subroutine. In principal a subclass could redefine any aspect of the array and therefore, under strict guidelines, &lt;a href=&quot;generated/numpy.asanyarray#numpy.asanyarray&quot;&gt;&lt;code&gt;asanyarray&lt;/code&gt;&lt;/a&gt; would rarely be useful. However, most subclasses of the array object will not redefine certain aspects of the array object such as the buffer interface, or the attributes of the array. One important example, however, of why your subroutine may not be able to handle an arbitrary subclass of an array is that matrices redefine the &amp;ldquo;*&amp;rdquo; operator to be matrix-multiplication, rather than element-by-element multiplication.</source>
          <target state="translated">请注意，&lt;a href=&quot;generated/numpy.asarray#numpy.asarray&quot;&gt; &lt;code&gt;asarray&lt;/code&gt; &lt;/a&gt;始终返回基类ndarray。如果您确信使用数组对象可以处理ndarray的任何子类，则可以使用&lt;a href=&quot;generated/numpy.asanyarray#numpy.asanyarray&quot;&gt; &lt;code&gt;asanyarray&lt;/code&gt; &lt;/a&gt;允许子类通过您的子例程更清晰地传播。原则上，子类可以重新定义数组的任何方面，因此，在严格的指导下，&lt;a href=&quot;generated/numpy.asanyarray#numpy.asanyarray&quot;&gt; &lt;code&gt;asanyarray&lt;/code&gt; &lt;/a&gt;很少有用。但是，数组对象的大多数子类都不会重新定义数组对象的某些方面，例如缓冲区接口或数组的属性。但是，为什么子例程可能无法处理数组的任意子类的一个重要示例是，矩阵将&amp;ldquo; *&amp;rdquo;运算符重新定义为矩阵乘法，而不是逐元素乘法。</target>
        </trans-unit>
        <trans-unit id="2994c8b1000ee96c6bafac35b90d5196f4331cc6" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;numpy.extract#numpy.extract&quot;&gt;&lt;code&gt;extract&lt;/code&gt;&lt;/a&gt; does the exact opposite of &lt;a href=&quot;#numpy.place&quot;&gt;&lt;code&gt;place&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，&lt;a href=&quot;numpy.extract#numpy.extract&quot;&gt; &lt;code&gt;extract&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;#numpy.place&quot;&gt; &lt;code&gt;place&lt;/code&gt; &lt;/a&gt;完全相反。</target>
        </trans-unit>
        <trans-unit id="8afbc898891b0fe68b1eecfbf68a1cf24bd85a7a" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;numpy.place#numpy.place&quot;&gt;&lt;code&gt;place&lt;/code&gt;&lt;/a&gt; does the exact opposite of &lt;a href=&quot;#numpy.extract&quot;&gt;&lt;code&gt;extract&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，&lt;a href=&quot;numpy.place#numpy.place&quot;&gt; &lt;code&gt;place&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;#numpy.extract&quot;&gt; &lt;code&gt;extract&lt;/code&gt; &lt;/a&gt;完全相反。</target>
        </trans-unit>
        <trans-unit id="4f0cd8ed70085b11cd28942641b9028c9aba83b5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;config.paths&lt;/code&gt; method is applied to all lists that may contain paths. &lt;code&gt;extra_info&lt;/code&gt; is a dictionary or a list of dictionaries that content will be appended to keyword arguments. The list &lt;code&gt;depends&lt;/code&gt; contains paths to files or directories that the sources of the extension module depend on. If any path in the &lt;code&gt;depends&lt;/code&gt; list is newer than the extension module, then the module will be rebuilt.</source>
          <target state="translated">请注意， &lt;code&gt;config.paths&lt;/code&gt; 方法适用于可能包含路径的所有列表。 &lt;code&gt;extra_info&lt;/code&gt; 是一个字典或词典列表，其内容将附加到关键字参数中。该列表 &lt;code&gt;depends&lt;/code&gt; 包含扩展模块源所依赖的文件或目录的路径。如果 &lt;code&gt;depends&lt;/code&gt; 列表中的任何路径都比扩展模块新，则将重建该模块。</target>
        </trans-unit>
        <trans-unit id="13ca491ea761bf62a2d2e0b70d53573f8b01deeb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mask&lt;/code&gt; is set to &lt;code&gt;nomask&lt;/code&gt; if possible.</source>
          <target state="translated">请注意，如果可能，将 &lt;code&gt;mask&lt;/code&gt; 设置为 &lt;code&gt;nomask&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f32117a86809996e4d811806f7ba20a69124b56e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;olduint&lt;/code&gt; returns a value after printing Deprecation Warning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="852bb168026a6f86202fbafca98fe5b5ed851902" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;s&lt;/code&gt; has a particular shape: it has only one dimension. This means that some linear algebra functions that expect 2d arrays might not work. For example, from the theory, one might expect &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;Vt&lt;/code&gt; to be compatible for multiplication. However, this is not true as &lt;code&gt;s&lt;/code&gt; does not have a second axis. Executing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38015f9859f4a5945500318393061704a6af069b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;self&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; listed as the first parameter of methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="653a93daba5d03116d06838a5a76a1330934f611" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;str&lt;/code&gt; refers to either null terminated bytes or unicode strings depending on the Python version. In code targeting both Python 2 and 3 &lt;code&gt;np.unicode_&lt;/code&gt; should be used as a dtype for strings. See &lt;a href=&quot;#string-dtype-note&quot;&gt;Note on string types&lt;/a&gt;.</source>
          <target state="translated">请注意，根据Python版本的不同， &lt;code&gt;str&lt;/code&gt; 表示以null结尾的字节或unicode字符串。在针对Python 2和3的 &lt;code&gt;np.unicode_&lt;/code&gt; 应将np.unicode_用作字符串的dtype。请参见&lt;a href=&quot;#string-dtype-note&quot;&gt;有关字符串类型的注释&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="577f40a867da04018fffaab4749ee48c7ab85bee" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;test_&lt;/code&gt; functions or methods should not have a docstring, because that makes it hard to identify the test from the output of running the test suite with &lt;code&gt;verbose=2&lt;/code&gt; (or similar verbosity setting). Use plain comments (&lt;code&gt;#&lt;/code&gt;) if necessary.</source>
          <target state="translated">请注意， &lt;code&gt;test_&lt;/code&gt; 函数或方法不应包含文档字符串，因为这使得从以 &lt;code&gt;verbose=2&lt;/code&gt; （或类似的详细程度设置）运行测试套件的输出中很难识别测试。如有必要，请使用纯注释（ &lt;code&gt;#&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="02e2af0a66e4601c973f5ec5d0ddca41b2da6bef" translate="yes" xml:space="preserve">
          <source>Note that C++ type &lt;code&gt;bool&lt;/code&gt; is not supported in the list in the &lt;a href=&quot;#available-typemaps&quot;&gt;Available Typemaps&lt;/a&gt; section. NumPy bools are a single byte, while the C++ &lt;code&gt;bool&lt;/code&gt; is four bytes (at least on my system). Therefore:</source>
          <target state="translated">请注意，&amp;ldquo; &lt;a href=&quot;#available-typemaps&quot;&gt;可用类型映射&amp;rdquo;&lt;/a&gt;部分的列表中不支持C ++类型 &lt;code&gt;bool&lt;/code&gt; 。NumPy &lt;code&gt;bool&lt;/code&gt; 是一个字节，而C ++ 布尔是四个字节（至少在我的系统上）。因此：</target>
        </trans-unit>
        <trans-unit id="b7fb7bda276a077f32e3518dd51fb7c92f1227b3" translate="yes" xml:space="preserve">
          <source>Note that F2PY found that the second argument &lt;code&gt;n&lt;/code&gt; is the dimension of the first array argument &lt;code&gt;a&lt;/code&gt;. Since by default all arguments are input-only arguments, F2PY concludes that &lt;code&gt;n&lt;/code&gt; can be optional with the default value &lt;code&gt;len(a)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa71944aea37a075fc5603b1c286b6996796fc2" translate="yes" xml:space="preserve">
          <source>Note that LaTeX is not particularly easy to read, so use equations sparingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc512ad322760dff623f859eafd23590a132e18" translate="yes" xml:space="preserve">
          <source>Note that NumPy is developed mainly using GNU compilers and tested on MSVC and Clang compilers. Compilers from other vendors such as Intel, Absoft, Sun, NAG, Compaq, Vast, Portland, Lahey, HP, IBM are only supported in the form of community feedback, and may not work out of the box. GCC 4.x (and later) compilers are recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6fea2f832bdac55a57e8bcf7203f52e450af3e1" translate="yes" xml:space="preserve">
          <source>Note that NumPy submodules still use a file named &lt;code&gt;info.py&lt;/code&gt; in which the module docstring and &lt;code&gt;__all__&lt;/code&gt; dict are defined. These files will be removed at some point.</source>
          <target state="translated">请注意，NumPy子模块仍使用名为 &lt;code&gt;info.py&lt;/code&gt; 的文件，在其中定义了模块docstring和 &lt;code&gt;__all__&lt;/code&gt; dict。这些文件有时会被删除。</target>
        </trans-unit>
        <trans-unit id="cd1c6148abd4d8a68d9037726f201b07b6224a50" translate="yes" xml:space="preserve">
          <source>Note that a Fortran source file can contain many routines, and not necessarily all routines are needed to be used from Python. So, you can either specify which routines should be wrapped (in &lt;code&gt;only: .. :&lt;/code&gt; part) or which routines F2PY should ignored (in &lt;code&gt;skip: .. :&lt;/code&gt; part).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243df166efa690ac8a711211a7fdea37ebc1d718" translate="yes" xml:space="preserve">
          <source>Note that although almost all modern C compilers pad in this way by default, padding in C structs is C-implementation-dependent so this memory layout is not guaranteed to exactly match that of a corresponding struct in a C program. Some work may be needed, either on the numpy side or the C side, to obtain exact correspondence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a0319be442be6ef174d641d2057417bdd72b054" translate="yes" xml:space="preserve">
          <source>Note that another approach would be to to use &lt;code&gt;getattr(ufunc,
methods)(*inputs, **kwargs)&lt;/code&gt; instead of the &lt;code&gt;super&lt;/code&gt; call. For this example, the result would be identical, but there is a difference if another operand also defines &lt;code&gt;__array_ufunc__&lt;/code&gt;. E.g., lets assume that we evalulate &lt;code&gt;np.add(a, b)&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is an instance of another class &lt;code&gt;B&lt;/code&gt; that has an override. If you use &lt;code&gt;super&lt;/code&gt; as in the example, &lt;code&gt;ndarray.__array_ufunc__&lt;/code&gt; will notice that &lt;code&gt;b&lt;/code&gt; has an override, which means it cannot evaluate the result itself. Thus, it will return &lt;code&gt;NotImplemented&lt;/code&gt; and so will our class &lt;code&gt;A&lt;/code&gt;. Then, control will be passed over to &lt;code&gt;b&lt;/code&gt;, which either knows how to deal with us and produces a result, or does not and returns &lt;code&gt;NotImplemented&lt;/code&gt;, raising a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3a7170281d96c749df00a8822f6364f1c668d7" translate="yes" xml:space="preserve">
          <source>Note that another way to do an inplace build visible outside the repo base dir is with &lt;code&gt;python setup.py develop&lt;/code&gt;. Instead of adjusting &lt;code&gt;PYTHONPATH&lt;/code&gt;, this installs a &lt;code&gt;.egg-link&lt;/code&gt; file into your site-packages as well as adjusts the &lt;code&gt;easy-install.pth&lt;/code&gt; there, so its a more permanent (and magical) operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0bc3c9921682280a85d9ad74708f6af3774f00" translate="yes" xml:space="preserve">
          <source>Note that arrays with hard-coded dimensions are not supported. These cannot follow the double pointer signatures of these typemaps.</source>
          <target state="translated">请注意,不支持具有硬编码尺寸的数组。这些数组不能遵循这些类型图的双指针签名。</target>
        </trans-unit>
        <trans-unit id="48706be1cfd595ac0f989289e2a8fb9947cff916" translate="yes" xml:space="preserve">
          <source>Note that as the order of the arguments are reversed, the side must be too. The &lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt;&lt;code&gt;searchsorted&lt;/code&gt;&lt;/a&gt; call is marginally faster, as it does not do any monotonicity checks. Perhaps more importantly, it supports all dtypes.</source>
          <target state="translated">请注意，随着参数顺序的颠倒，侧面也必须相同。搜索&lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt; &lt;code&gt;searchsorted&lt;/code&gt; &lt;/a&gt;调用稍快一些，因为它不执行任何单调性检查。也许更重要的是，它支持所有dtype。</target>
        </trans-unit>
        <trans-unit id="b5450d42b830584acc5db98da979017850552b6b" translate="yes" xml:space="preserve">
          <source>Note that assignments may result in changes if assigning higher types to lower types (like floats to ints) or even exceptions (assigning complex to floats or ints):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1107611495a4cef20786212c1426d524434253be" translate="yes" xml:space="preserve">
          <source>Note that building the documentation on Windows is currently not actively supported, though it should be possible. (See &lt;a href=&quot;http://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; documentation for more information.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7ba7f496bb7ba121307112b93618161ad3c991" translate="yes" xml:space="preserve">
          <source>Note that by default using single &lt;code&gt;intent(out)&lt;/code&gt; also implies &lt;code&gt;intent(hide)&lt;/code&gt;. Arguments that have the &lt;code&gt;intent(hide)&lt;/code&gt; attribute specified will not be listed in the argument list of a wrapper function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4dd030963aaaf3be4bd9f6afb2a54167cbe9671" translate="yes" xml:space="preserve">
          <source>Note that computing a monthly mortgage payment is only one use for this function. For example, pmt returns the periodic deposit one must make to achieve a specified future balance given an initial deposit, a fixed, periodically compounded interest rate, and the total number of periods.</source>
          <target state="translated">请注意,计算每月的抵押贷款付款只是这个函数的一个用途。例如,pmt 返回为了达到指定的未来余额而必须支付的定期存款,给定的初始存款、固定的定期复利利率和总的周期数。</target>
        </trans-unit>
        <trans-unit id="a3299a2dbf1b83250c6148ada8e7d466fe67fe1d" translate="yes" xml:space="preserve">
          <source>Note that despite the name of this function it does not accept &lt;code&gt;str&lt;/code&gt; instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d023cb473537055d9b3a4020206aea9635b5fe" translate="yes" xml:space="preserve">
          <source>Note that dictionaries are not stored in any specific order. Also, most mutable (see &lt;em&gt;immutable&lt;/em&gt; below) objects, such as lists, may not be used as keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b262586803e1839adc1dd7ba61528562de1c4dc" translate="yes" xml:space="preserve">
          <source>Note that element</source>
          <target state="translated">请注意,元素</target>
        </trans-unit>
        <trans-unit id="3361278c66a9a950ab868f2606daa6d980ba0742" translate="yes" xml:space="preserve">
          <source>Note that fitting polynomial coefficients is inherently badly conditioned when the degree of the polynomial is large or the interval of sample points is badly centered. The quality of the fit should always be checked in these cases. When polynomial fits are not satisfactory, splines may be a good alternative.</source>
          <target state="translated">需要注意的是,当多项式的度数很大或样本点的区间居中不好时,拟合多项式系数本身就有不好的条件。在这些情况下应该随时检查拟合的质量。当多项式拟合不满意时,花键可能是一个很好的选择。</target>
        </trans-unit>
        <trans-unit id="0754d929f5032a758a77b70b619d10e1a6b0a14a" translate="yes" xml:space="preserve">
          <source>Note that for complex numbers, the absolute value is taken before squaring, so that the result is always real and nonnegative.</source>
          <target state="translated">需要注意的是,对于复数,先取绝对值再进行平方,所以结果总是实数,而且是非负数。</target>
        </trans-unit>
        <trans-unit id="17ba305768334a737a4dfbed178a872a09842e7e" translate="yes" xml:space="preserve">
          <source>Note that for documentation within numpy, it is not necessary to do &lt;code&gt;import numpy as np&lt;/code&gt; at the beginning of an example. However, some sub-modules, such as &lt;code&gt;fft&lt;/code&gt;, are not imported by default, and you have to include them explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c532f8402b234b1805dc32ad508ed06d2d992bc4" translate="yes" xml:space="preserve">
          <source>Note that for floating-point input, the mean is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;code&gt;float32&lt;/code&gt; (see example below). Specifying a higher-precision accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="translated">请注意，对于浮点输入，将使用与输入相同的精度来计算平均值。根据输入数据，这可能导致结果不准确，尤其是对于 &lt;code&gt;float32&lt;/code&gt; （请参见下面的示例）。使用&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;关键字指定更高精度的累加器可以缓解此问题。</target>
        </trans-unit>
        <trans-unit id="28ec6b24f09abee0bf153ce2a68e94e6fc60a244" translate="yes" xml:space="preserve">
          <source>Note that for floating-point input, the mean is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;code&gt;float32&lt;/code&gt;. Specifying a higher-precision accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="translated">请注意，对于浮点输入，将使用与输入相同的精度来计算平均值。根据输入数据，这可能导致结果不准确，尤其是对于 &lt;code&gt;float32&lt;/code&gt; 而言。使用&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;关键字指定更高精度的累加器可以缓解此问题。</target>
        </trans-unit>
        <trans-unit id="9429c3e4d702a779857d710d5ba3d4bb8d91e3db" translate="yes" xml:space="preserve">
          <source>Note that for higher dimensional inserts &lt;code&gt;obj=0&lt;/code&gt; behaves very different from &lt;code&gt;obj=[0]&lt;/code&gt; just like &lt;code&gt;arr[:,0,:] = values&lt;/code&gt; is different from &lt;code&gt;arr[:,[0],:] = values&lt;/code&gt;.</source>
          <target state="translated">请注意，对于高维插入， &lt;code&gt;obj=0&lt;/code&gt; 的行为与 &lt;code&gt;obj=[0]&lt;/code&gt; 的行为大不相同，就像 &lt;code&gt;arr[:,0,:] = values&lt;/code&gt; 与 &lt;code&gt;arr[:,[0],:] = values&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64098939d0cc3bd11f1e190ea4842decacbcc08d" translate="yes" xml:space="preserve">
          <source>Note that higher-dimensional arrays are flattened!</source>
          <target state="translated">注意,高维数组是扁平化的!</target>
        </trans-unit>
        <trans-unit id="08dbdae6232197f6e8ea8b77dc3750bf740014ac" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;threads&lt;/code&gt; is not set by the user, it will be determined by &lt;code&gt;multiprocessing.cpu_count()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e03a6fba50452828f3483eb33a462b6c52de935" translate="yes" xml:space="preserve">
          <source>Note that if a field has the same name as an ndarray attribute, the ndarray attribute takes precedence. Such fields will be inaccessible by attribute but will still be accessible by index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c7921c177ba1f557c86613521ffad6b35f74d0" translate="yes" xml:space="preserve">
          <source>Note that if an operand is given the flag &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt;&lt;code&gt;NPY_ITER_COPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, a copy will be made in preference to buffering. Buffering will still occur when the array was broadcast so elements need to be duplicated to get a constant stride.</source>
          <target state="translated">请注意，如果为操作数指定了标记&lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt; &lt;code&gt;NPY_ITER_COPY&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;，则将优先于缓冲区进行复制。广播数组时，缓冲仍然会发生，因此需要复制元素以获得恒定的步幅。</target>
        </trans-unit>
        <trans-unit id="b29d0e1167132199e264175b7a1e173cb2ad60e1" translate="yes" xml:space="preserve">
          <source>Note that if an uninitialized return array is created, values of False will leave those values &lt;strong&gt;uninitialized&lt;/strong&gt;.</source>
          <target state="translated">请注意，如果创建了未初始化的返回数组，则False的值将使这些值保持&lt;strong&gt;未初始化的状态&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="8aa598501b8ebf0323315a582a961e1c62a8f937" translate="yes" xml:space="preserve">
          <source>Note that if one indexes a multidimensional array with fewer indices than dimensions, one gets a subdimensional array. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d909696047578f38bea71bdf411f55070df9d2" translate="yes" xml:space="preserve">
          <source>Note that if the C function signature was in a different order:</source>
          <target state="translated">注意,如果C函数签名的顺序不同。</target>
        </trans-unit>
        <trans-unit id="01a168adfe5fe1f5dd6875481bec15e4f9aa1985" translate="yes" xml:space="preserve">
          <source>Note that if you want to do a reduction on an automatically allocated output, you must use &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt; to get its reference, then set every value to the reduction unit before doing the iteration loop. In the case of a buffered reduction, this means you must also specify the flag &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt;&lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt;&lt;/a&gt;, then reset the iterator after initializing the allocated operand to prepare the buffers.</source>
          <target state="translated">请注意，如果要对自动分配的输出进行约简，则必须使用&lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt; &lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt; &lt;/a&gt;获取其引用，然后在进行迭代循环之前将每个值都设置为约简单位。在缓冲减少的情况下，这意味着还必须指定标志&lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt; &lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt; &lt;/a&gt;，然后在初始化分配的操作数以准备缓冲区之后重置迭代器。</target>
        </trans-unit>
        <trans-unit id="2b010bbfdb300bcd389c385bed7ea27b3386f09b" translate="yes" xml:space="preserve">
          <source>Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000, and 32 = 0010 0000.</source>
          <target state="translated">请注意,在二进制中160=1010 0000,64=0100 0000,192=1100 0000,32=0010 0000。</target>
        </trans-unit>
        <trans-unit id="a6ebb270150b81af72246532a75002f3434d09b6" translate="yes" xml:space="preserve">
          <source>Note that in the code snippets below, &lt;code&gt;upstream&lt;/code&gt; refers to the root repository on github and &lt;code&gt;origin&lt;/code&gt; to a fork in your personal account. You may need to make adjustments if you have not forked the repository but simply cloned it locally. You can also edit &lt;code&gt;.git/config&lt;/code&gt; and add &lt;code&gt;upstream&lt;/code&gt; if it isn&amp;rsquo;t already present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0deb1edca6a6f101961c6c8ff2fdf5eb19dff4d3" translate="yes" xml:space="preserve">
          <source>Note that integer divide-by-zero is handled by the same machinery. These behaviors are set on a per-thread basis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6720060be8821678605a9cb8b96c71daf2200a5d" translate="yes" xml:space="preserve">
          <source>Note that it is not required for &lt;code&gt;__array_function__&lt;/code&gt; implementations to include &lt;em&gt;all&lt;/em&gt; of the corresponding NumPy function&amp;rsquo;s optional arguments (e.g., &lt;code&gt;broadcast_to&lt;/code&gt; above omits the irrelevant &lt;code&gt;subok&lt;/code&gt; argument). Optional arguments are only passed in to &lt;code&gt;__array_function__&lt;/code&gt; if they were explicitly used in the NumPy function call.</source>
          <target state="translated">需要注意的是它不需要 &lt;code&gt;__array_function__&lt;/code&gt; 实现，包括&lt;em&gt;所有&lt;/em&gt;的相应NumPy的功能的可选参数（例如， &lt;code&gt;broadcast_to&lt;/code&gt; 以上省略了不相关的 &lt;code&gt;subok&lt;/code&gt; 参数）。如果在NumPy函数调用中显式使用了可选参数，则仅将它们传递给 &lt;code&gt;__array_function__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="401f22bf499be24336e06ca8c727f49552e9ba96" translate="yes" xml:space="preserve">
          <source>Note that it would be more straightforward in the above example to extract the required elements directly with &lt;code&gt;x[:2, :3]&lt;/code&gt;.</source>
          <target state="translated">请注意，在上面的示例中，直接使用 &lt;code&gt;x[:2, :3]&lt;/code&gt; 提取所需元素会更直接。</target>
        </trans-unit>
        <trans-unit id="640acbca975ba8209807d8f3d4cb4b40d4247c4c" translate="yes" xml:space="preserve">
          <source>Note that license and author info, while often included in source files, do not belong in docstrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaaef84f5e6e416f2f83a03c812a03e6bee63048" translate="yes" xml:space="preserve">
          <source>Note that not all data-type information can be supplied with a type-object: for example, &lt;code&gt;flexible&lt;/code&gt; data-types have a default &lt;em&gt;itemsize&lt;/em&gt; of 0, and require an explicitly given size to be useful.</source>
          <target state="translated">请注意，并非所有数据类型信息都可以提供一个类型对象：例如， &lt;code&gt;flexible&lt;/code&gt; 数据类型的默认项目&lt;em&gt;大小&lt;/em&gt;为0，并且需要显式指定的大小才有用。</target>
        </trans-unit>
        <trans-unit id="780756f1773042c233a75d985a3181931209c4b9" translate="yes" xml:space="preserve">
          <source>Note that np.copy is a shallow copy and will not copy object elements within arrays. This is mainly important for arrays containing Python objects. The new array will contain the same object which may lead to surprises if that object can be modified (is mutable):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e81c263eba620a31c6f05237f30bb45194a05fe" translate="yes" xml:space="preserve">
          <source>Note that once the iterator is closed we can not access &lt;a href=&quot;generated/numpy.nditer.operands#numpy.nditer.operands&quot;&gt;&lt;code&gt;operands&lt;/code&gt;&lt;/a&gt; and must use a reference created inside the context manager.</source>
          <target state="translated">请注意，一旦关闭迭代器，我们将无法访问&lt;a href=&quot;generated/numpy.nditer.operands#numpy.nditer.operands&quot;&gt; &lt;code&gt;operands&lt;/code&gt; &lt;/a&gt;并且必须使用在上下文管理器内部创建的引用。</target>
        </trans-unit>
        <trans-unit id="a0072c6c9282c50699dd3bb094606976a4136251" translate="yes" xml:space="preserve">
          <source>Note that operations on integer scalar types (such as &lt;code&gt;int16&lt;/code&gt;) are handled like floating point, and are affected by these settings.</source>
          <target state="translated">请注意，对整数标量类型（例如 &lt;code&gt;int16&lt;/code&gt; ）的操作就像浮点一样处理，并且受这些设置的影响。</target>
        </trans-unit>
        <trans-unit id="b5c0500d98fa9cc106c3d86fe8d639514bc7b011" translate="yes" xml:space="preserve">
          <source>Note that slices of arrays do not copy the internal array data but only produce new views of the original data. This is different from list or tuple slicing and an explicit &lt;code&gt;copy()&lt;/code&gt; is recommended if the original data is not required anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f50c6ff377ac0a2ca64d0c66fbaa9d2065ec9a" translate="yes" xml:space="preserve">
          <source>Note that some examples may use &lt;code&gt;None&lt;/code&gt; instead of &lt;code&gt;np.newaxis&lt;/code&gt;. These are the same objects:</source>
          <target state="translated">请注意，某些示例可能使用 &lt;code&gt;None&lt;/code&gt; 而不是 &lt;code&gt;np.newaxis&lt;/code&gt; 。这些是相同的对象：</target>
        </trans-unit>
        <trans-unit id="4f987286ad6faa40518b3a8186b7c20cb6434a93" translate="yes" xml:space="preserve">
          <source>Note that sometimes builds, like tests, fail for unrelated reasons and you will need to restart them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa9fecdeba09a0f43a75d04eeb01c1da54d7720" translate="yes" xml:space="preserve">
          <source>Note that sorting is first according to the elements of &lt;code&gt;a&lt;/code&gt;. Secondary sorting is according to the elements of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">请注意，排序首先是根据的元素进行 &lt;code&gt;a&lt;/code&gt; 。根据 &lt;code&gt;b&lt;/code&gt; 的元素进行二次排序。</target>
        </trans-unit>
        <trans-unit id="2ab2cbf3d7d05721e26131cbe4f74f5e6c689750" translate="yes" xml:space="preserve">
          <source>Note that the above may not produce exact integers:</source>
          <target state="translated">需要注意的是,上面可能不会产生精确的整数。</target>
        </trans-unit>
        <trans-unit id="816b54542ce937e025129bb5a02d396360440696" translate="yes" xml:space="preserve">
          <source>Note that the covariance matrix must be positive semidefinite (a.k.a. nonnegative-definite). Otherwise, the behavior of this method is undefined and backwards compatibility is not guaranteed.</source>
          <target state="translated">请注意,协方差矩阵必须是正半定型(也就是非负定型)。否则,该方法的行为是未定义的,并且不能保证向后的兼容性。</target>
        </trans-unit>
        <trans-unit id="ce6b6a669d0954769df5e326b05520fbeb05f879" translate="yes" xml:space="preserve">
          <source>Note that the dtype of the second argument may change the dtype of the result and can lead to unexpected results in some cases (see &lt;a href=&quot;../ufuncs#ufuncs-casting&quot;&gt;Casting Rules&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="891f0fa3122015805e6600a7a4bd2235d2515ff8" translate="yes" xml:space="preserve">
          <source>Note that the length of the 1D boolean array must coincide with the length of the dimension (or axis) you want to slice. In the previous example, &lt;code&gt;b1&lt;/code&gt; has length 3 (the number of &lt;em&gt;rows&lt;/em&gt; in &lt;code&gt;a&lt;/code&gt;), and &lt;code&gt;b2&lt;/code&gt; (of length 4) is suitable to index the 2nd axis (columns) of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fdfec7c0c161ff5cf20da12ebf59920f92cef4" translate="yes" xml:space="preserve">
          <source>Note that the order in which the diagonal is filled varies depending on the flip function.</source>
          <target state="translated">请注意,对角线的填充顺序因翻转函数的不同而不同。</target>
        </trans-unit>
        <trans-unit id="724f6e013fa8829f11659c1f81abf24921dbd546" translate="yes" xml:space="preserve">
          <source>Note that the order in which the diagonal is retrieved varies depending on the flip function.</source>
          <target state="translated">请注意,对角线的检索顺序根据翻转函数的不同而不同。</target>
        </trans-unit>
        <trans-unit id="a99c18cf39a32483fd943f4224186f409906587f" translate="yes" xml:space="preserve">
          <source>Note that the output of &lt;a href=&quot;generated/numpy.ma.compressed#numpy.ma.compressed&quot;&gt;&lt;code&gt;compressed&lt;/code&gt;&lt;/a&gt; is always 1D.</source>
          <target state="translated">请注意，&lt;a href=&quot;generated/numpy.ma.compressed#numpy.ma.compressed&quot;&gt; &lt;code&gt;compressed&lt;/code&gt; &lt;/a&gt;的输出始终为1D。</target>
        </trans-unit>
        <trans-unit id="fe6f42e3829661cf63ecd7296a8f95be4fb61504" translate="yes" xml:space="preserve">
          <source>Note that the result of each integration is &lt;em&gt;multiplied&lt;/em&gt; by &lt;code&gt;scl&lt;/code&gt;. Why is this important to note? Say one is making a linear change of variable</source>
          <target state="translated">需要注意的是每个积分的结果&lt;em&gt;乘以&lt;/em&gt;通过 &lt;code&gt;scl&lt;/code&gt; 。为什么要注意这一点很重要？说一个正在使变量线性变化</target>
        </trans-unit>
        <trans-unit id="87d64ab0ec81404f96e3a3fd6a0cf4af1b48cd4a" translate="yes" xml:space="preserve">
          <source>Note that the result shape is identical to the (broadcast) indexing array shapes &lt;code&gt;ind_1, ..., ind_N&lt;/code&gt;.</source>
          <target state="translated">注意，结果形状与（广播）索引数组形状 &lt;code&gt;ind_1, ..., ind_N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="970776667a9fe553514eecc1dd1a72278348d24e" translate="yes" xml:space="preserve">
          <source>Note that the scalar types are not &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; objects, even though they can be used in place of one whenever a data type specification is needed in NumPy.</source>
          <target state="translated">请注意，标量类型不是&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;对象，即使在NumPy中需要数据类型规范时也可以使用它们代替一个。</target>
        </trans-unit>
        <trans-unit id="c59a59639135c22037a5377f994f5afdc88bff2a" translate="yes" xml:space="preserve">
          <source>Note that the strided-copy and strided-cast code are deeply intertwined and so any arrays being processed by them must be both uint and true aligned, even though the copy-code only needs uint alignment and the cast code only true alignment. If there is ever a big rewrite of this code it would be good to allow them to use different alignments.</source>
          <target state="translated">请注意,strided-copy和strided-cast代码是深深交织在一起的,所以任何被它们处理的数组都必须是uint和true对齐的,尽管copy代码只需要uint对齐,而cast代码只需要true对齐。如果有一天对这个代码进行大的重写,允许它们使用不同的对齐方式也是好事。</target>
        </trans-unit>
        <trans-unit id="66c05a00c87427b26e39bf9edf93e478c145e10d" translate="yes" xml:space="preserve">
          <source>Note that the terms in the multi-line Boolean expression are indented so as to make the beginning of the code block clearly visible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fecfca7c041f47ec9751b796cf84238ada1da72a" translate="yes" xml:space="preserve">
          <source>Note that the ufunc (&lt;code&gt;np.add&lt;/code&gt;) has called the &lt;code&gt;__array_wrap__&lt;/code&gt; method with arguments &lt;code&gt;self&lt;/code&gt; as &lt;code&gt;obj&lt;/code&gt;, and &lt;code&gt;out_arr&lt;/code&gt; as the (ndarray) result of the addition. In turn, the default &lt;code&gt;__array_wrap__&lt;/code&gt; (&lt;code&gt;ndarray.__array_wrap__&lt;/code&gt;) has cast the result to class &lt;code&gt;MySubClass&lt;/code&gt;, and called &lt;code&gt;__array_finalize__&lt;/code&gt; - hence the copying of the &lt;code&gt;info&lt;/code&gt; attribute. This has all happened at the C level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d91192b6712228963707a6381dc069bd269f72d" translate="yes" xml:space="preserve">
          <source>Note that there are no new elements in the array, just that the dimensionality is increased. This can be handy to combine two arrays in a way that otherwise would require explicitly reshaping operations. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c86d4295cc278f91db8c615a2b6f47dcfb069bb" translate="yes" xml:space="preserve">
          <source>Note that there are some subtleties regarding the last usage that the user should be aware of that are described in the arange docstring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3272a5f558b3fab42d4539ad3dc738bcb4ce852" translate="yes" xml:space="preserve">
          <source>Note that there are three parts to the long version of the printout. The first is the coefficients, the second is the domain, and the third is the window:</source>
          <target state="translated">注意,长版打印出来的内容有三部分。第一部分是系数,第二部分是域,第三部分是窗口。</target>
        </trans-unit>
        <trans-unit id="3a9c78ac3abf35e5e3337780f5e62c12c7df494d" translate="yes" xml:space="preserve">
          <source>Note that this distribution is very similar to the binomial distribution, except that in this case, samples are drawn without replacement, whereas in the Binomial case samples are drawn with replacement (or the sample space is infinite). As the sample space becomes large, this distribution approaches the binomial.</source>
          <target state="translated">请注意,这种分布与二项式分布非常相似,只是在这种情况下,样本是在没有替换的情况下抽取的,而在二项式的情况下,样本是在有替换的情况下抽取的(或者样本空间是无限的)。当样本空间变大时,这种分布就会接近二项式分布。</target>
        </trans-unit>
        <trans-unit id="71bb480ec02fbb938cca2004bc6943842a328aaa" translate="yes" xml:space="preserve">
          <source>Note that this matches the precision of the builtin python &lt;code&gt;complex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c75e7f017341538d8b3f779cf45143d903afb1a" translate="yes" xml:space="preserve">
          <source>Note that this matches the precision of the builtin python &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207f864735403916ab64725fc35836347eea06c9" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;data_as&lt;/code&gt;, a reference will not be kept to the array: code like &lt;code&gt;ctypes.c_void_p((a + b).ctypes.data)&lt;/code&gt; will result in a pointer to a deallocated array, and should be spelt &lt;code&gt;(a + b).ctypes.data_as(ctypes.c_void_p)&lt;/code&gt;</source>
          <target state="translated">请注意，与 &lt;code&gt;data_as&lt;/code&gt; 不同，引用将不会保留到数组： &lt;code&gt;ctypes.c_void_p((a + b).ctypes.data)&lt;/code&gt; 将导致指向释放数组的指针，应将其拼写为 &lt;code&gt;(a + b).ctypes.data_as(ctypes.c_void_p)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa5eae61b870cb56e093988870d6dd9877647aa6" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;numpy.ndarray&lt;/code&gt;, &lt;code&gt;ArrayLike&lt;/code&gt; does not allow operations with arbitrary, unrecognized types. This ensures that interactions with ArrayLike preserve a well-defined casting hierarchy.</source>
          <target state="translated">请注意，与 &lt;code&gt;numpy.ndarray&lt;/code&gt; 不同， &lt;code&gt;ArrayLike&lt;/code&gt; 不允许对任意，无法识别的类型进行操作。这样可以确保与ArrayLike的交互保留定义明确的转换层次结构。</target>
        </trans-unit>
        <trans-unit id="43c59c07e98c965f271cd8992d38ce79563e80fe" translate="yes" xml:space="preserve">
          <source>Note that we can assign each color channel to a separate matrix using the slice syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="448e8d337bf988d0c2429a16c43ede94f241e3d0" translate="yes" xml:space="preserve">
          <source>Note that we had to use only the first &lt;code&gt;k&lt;/code&gt; rows of &lt;code&gt;Vt&lt;/code&gt;, since all other rows would be multiplied by the zeros corresponding to the singular values we eliminated from this approximation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6653eb59198778eef2da729298a76ec147105c9f" translate="yes" xml:space="preserve">
          <source>Note that we picked datetimes that cross a DST boundary. Passing in a &lt;code&gt;pytz&lt;/code&gt; timezone object will print the appropriate offset</source>
          <target state="translated">请注意，我们选择了跨越DST边界的日期时间。在传递 &lt;code&gt;pytz&lt;/code&gt; 时区对象将打印相应的偏移</target>
        </trans-unit>
        <trans-unit id="ff6a8871cdaa44abafcf71b9b33d5e54dbc5be42" translate="yes" xml:space="preserve">
          <source>Note that we support &lt;code&gt;DATA_TYPE*&lt;/code&gt; argout typemaps in 1D, but not 2D or 3D. This is because of a quirk with the &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemap syntax and cannot be avoided. Note that for these types of 1D typemaps, the Python function will take a single argument representing &lt;code&gt;DIM1&lt;/code&gt;.</source>
          <target state="translated">请注意，我们在1D中支持 &lt;code&gt;DATA_TYPE*&lt;/code&gt; argout类型映射，但不支持2D或3D。这是由于使用&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemap语法的古怪之处而无法避免的。请注意，这些类型的1D typemaps，Python的功能将代表一个参数 &lt;code&gt;DIM1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11034ab53fb8599a1310cf4207146288e154fc02" translate="yes" xml:space="preserve">
          <source>Note that when &lt;code&gt;a == 1&lt;/code&gt;, the normalization factor &lt;code&gt;v1 / (v1**2 - ddof * v2)&lt;/code&gt; goes over to &lt;code&gt;1 / (np.sum(f) - ddof)&lt;/code&gt; as it should.</source>
          <target state="translated">请注意，当 &lt;code&gt;a == 1&lt;/code&gt; ，归一化因子 &lt;code&gt;v1 / (v1**2 - ddof * v2)&lt;/code&gt; 会适当地升至 &lt;code&gt;1 / (np.sum(f) - ddof)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98530ea6c0be02d22c92fb9a99dc0d9aff053c64" translate="yes" xml:space="preserve">
          <source>Note that when type-casting is required and there is possible loss of information (e.g. when type-casting float to integer or complex to float), F2PY does not raise any exception. In complex to real type-casting only the real part of a complex number is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23123ffca4ff0e0a4a42f0653d7d9ea09cd17620" translate="yes" xml:space="preserve">
          <source>Note that whenever &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; is used, &lt;code&gt;optional&lt;/code&gt; attribute is set automatically by F2PY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0fb9212f997bf3174d26345ac37f18f11183de" translate="yes" xml:space="preserve">
          <source>Note that without the &lt;code&gt;np.ix_&lt;/code&gt; call, only the diagonal elements would be selected, as was used in the previous example. This difference is the most important thing to remember about indexing with multiple advanced indexes.</source>
          <target state="translated">注意，没有 &lt;code&gt;np.ix_&lt;/code&gt; 调用，将仅选择对角线元素，如前一个示例中所使用的。对于使用多个高级索引建立索引，要记住的最重要的事情是。</target>
        </trans-unit>
        <trans-unit id="b5412b8a5c5e8aa3576931f3f122d134b272fe13" translate="yes" xml:space="preserve">
          <source>Note that you can eg. install NumPy to a temporary location and set the PYTHONPATH environment variable appropriately. Alternatively, if using Python virtual environments (via e.g. &lt;code&gt;conda&lt;/code&gt;, &lt;code&gt;virtualenv&lt;/code&gt; or the &lt;code&gt;venv&lt;/code&gt; module), installing numpy into a new virtual environment is recommended. All of the necessary dependencies for building the NumPy docs can be installed with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3edd40f42578284bf324094d774023e21eda09" translate="yes" xml:space="preserve">
          <source>Note that you get the time reversed, complex conjugated result when the two input sequences change places, i.e., &lt;code&gt;c_{va}[k] = c^{*}_{av}[-k]&lt;/code&gt;:</source>
          <target state="translated">请注意，当两个输入序列更改位置时，即 &lt;code&gt;c_{va}[k] = c^{*}_{av}[-k]&lt;/code&gt; ，您将获得时间倒数的复杂共轭结果：</target>
        </trans-unit>
        <trans-unit id="dc4f36c08ee65f253c387ba6c97a8e2ba7041327" translate="yes" xml:space="preserve">
          <source>Note that, above, we use the &lt;em&gt;Python&lt;/em&gt; float object as a dtype. NumPy knows that &lt;code&gt;int&lt;/code&gt; refers to &lt;code&gt;np.int_&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt; means &lt;code&gt;np.bool_&lt;/code&gt;, that &lt;code&gt;float&lt;/code&gt; is &lt;code&gt;np.float_&lt;/code&gt; and &lt;code&gt;complex&lt;/code&gt; is &lt;code&gt;np.complex_&lt;/code&gt;. The other data-types do not have Python equivalents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5c8fb85c6ca6f109e49af951ef9e99c064bb30" translate="yes" xml:space="preserve">
          <source>Note that, for complex numbers, &lt;a href=&quot;#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; takes the absolute value before squaring, so that the result is always real and nonnegative.</source>
          <target state="translated">请注意，对于复数，&lt;a href=&quot;#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt;在平方之前取绝对值，因此结果始终是实数和非负数。</target>
        </trans-unit>
        <trans-unit id="67ff0ed45eb77e75fcc2a8d19c65a90ea73589bb" translate="yes" xml:space="preserve">
          <source>Note that, for complex numbers, &lt;a href=&quot;numpy.std#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; takes the absolute value before squaring, so that the result is always real and nonnegative.</source>
          <target state="translated">请注意，对于复数，&lt;a href=&quot;numpy.std#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt;在平方之前取绝对值，因此结果始终是实数和非负数。</target>
        </trans-unit>
        <trans-unit id="70d9a8c143ac6b7cff84e338754a98ad2f6ecebc" translate="yes" xml:space="preserve">
          <source>Note that, in linear algebra, the dimension of a vector refers to the number of entries in an array. In NumPy, it instead defines the number of axes. For example, a 1D array is a vector such as &lt;code&gt;[1, 2, 3]&lt;/code&gt;, a 2D array is a matrix, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e93cf7b4b44a5b77a394d19e4276d3eaadfbbd" translate="yes" xml:space="preserve">
          <source>Note that, in the old API that was deprecated in version 1.7, this function had the return type &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">请注意，在版本1.7中弃用的旧API中，此函数的返回类型为 &lt;code&gt;int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7589de457b1bf436d7dda2480bd2ade65f60a09f" translate="yes" xml:space="preserve">
          <source>Note that, since NaN is unsortable, &lt;code&gt;xp&lt;/code&gt; also cannot contain NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c60913e9a1e7e3a8383e344378c5f7011cb280cd" translate="yes" xml:space="preserve">
          <source>Note that, when we modify x, y changes, but not z:</source>
          <target state="translated">请注意,当我们修改x时,y会改变,但z不会改变。</target>
        </trans-unit>
        <trans-unit id="a663ed58f0a095b16634564fa9a49f9e01516158" translate="yes" xml:space="preserve">
          <source>Note the array &lt;code&gt;dtype&lt;/code&gt; above of &lt;code&gt;&amp;gt;i2&lt;/code&gt;. The &lt;code&gt;&amp;gt;&lt;/code&gt; means &amp;lsquo;big-endian&amp;rsquo; (&lt;code&gt;&amp;lt;&lt;/code&gt; is little-endian) and &lt;code&gt;i2&lt;/code&gt; means &amp;lsquo;signed 2-byte integer&amp;rsquo;. For example, if our data represented a single unsigned 4-byte little-endian integer, the dtype string would be &lt;code&gt;&amp;lt;u4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf42915649d8c90d2411a01638407672b7fa26fe" translate="yes" xml:space="preserve">
          <source>Note the array has not changed in memory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7868473a32c7a3c40bb3a312d03eac57c7a37527" translate="yes" xml:space="preserve">
          <source>Note the order of the parameters. &lt;a href=&quot;#numpy.arctan2&quot;&gt;&lt;code&gt;arctan2&lt;/code&gt;&lt;/a&gt; is defined also when &lt;code&gt;x2&lt;/code&gt; = 0 and at several other special points, obtaining values in the range &lt;code&gt;[-pi, pi]&lt;/code&gt;:</source>
          <target state="translated">注意参数的顺序。当 &lt;code&gt;x2&lt;/code&gt; = 0且在其他几个特殊点时，也定义&lt;a href=&quot;#numpy.arctan2&quot;&gt; &lt;code&gt;arctan2&lt;/code&gt; &lt;/a&gt;，以获得 &lt;code&gt;[-pi, pi]&lt;/code&gt; 范围内的值：</target>
        </trans-unit>
        <trans-unit id="3999859e7edf0b6850997e2b685c81e41f6bf30b" translate="yes" xml:space="preserve">
          <source>Note the unusual interpretation of sample when an array_like:</source>
          <target state="translated">请注意,当一个array_like时,sample的解释不寻常。</target>
        </trans-unit>
        <trans-unit id="4959b44a65b76595dc01fa81f812b74fb283e1a6" translate="yes" xml:space="preserve">
          <source>Note to those used to IDL or Fortran memory order as it relates to indexing. NumPy uses C-order indexing. That means that the last index usually represents the most rapidly changing memory location, unlike Fortran or IDL, where the first index represents the most rapidly changing location in memory. This difference represents a great potential for confusion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111feaa1cd8151a1eb25cfbf746ea648c6673cdc" translate="yes" xml:space="preserve">
          <source>Note: Prior to NumPy 1.10.0, less strict checks were in place: missing core dimensions were created by prepending 1&amp;rsquo;s to the shape as necessary, core dimensions with the same label were broadcast together, and undetermined dimensions were created with size 1.</source>
          <target state="translated">注意：在NumPy 1.10.0之前，没有进行严格的检查：通过在必要的形状前面加1来创建缺少的核心尺寸，将具有相同标签的核心尺寸一起广播，并使用大小1创建未确定的尺寸。</target>
        </trans-unit>
        <trans-unit id="d21079fa664fe20f0bcb604959e5d77d12a5f0cb" translate="yes" xml:space="preserve">
          <source>Note: This function returns an array with at least one-dimension (1-d) so it will not preserve 0-d arrays.</source>
          <target state="translated">注意:这个函数返回一个至少有一个维度(1-d)的数组,所以它不会保留0-d数组。</target>
        </trans-unit>
        <trans-unit id="4a1a649c093516be216b047d4a6e07a8bfed16fc" translate="yes" xml:space="preserve">
          <source>Note: cannot use equality to test NaNs. E.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="046d816b2cced12f2b8341cea27cc367cd961583" translate="yes" xml:space="preserve">
          <source>Notes about the implementation algorithm (if needed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a08e04c0814f8e83ad56517e19ff3c0721fcd94" translate="yes" xml:space="preserve">
          <source>Notes and Warnings : If there are points in the docstring that deserve special emphasis, the reST directives for a note or warning can be used in the vicinity of the context of the warning (inside a section). Syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="f57a8f12c91535f8b3bf8808e86d3137e06887d9" translate="yes" xml:space="preserve">
          <source>Nothing happens if &lt;code&gt;a&lt;/code&gt; is not a masked array.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 不是掩码数组，则什么也不会发生。</target>
        </trans-unit>
        <trans-unit id="a10912bd64eec5f116a9c3fe1369faded07c9f4b" translate="yes" xml:space="preserve">
          <source>Nothing returned by this function.</source>
          <target state="translated">本函数没有返回任何内容。</target>
        </trans-unit>
        <trans-unit id="184b0a59161cac7480934a6869880704e9ffc1c5" translate="yes" xml:space="preserve">
          <source>Notice how the final element of the &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt; output is the complex conjugate of the second element, for real input. For &lt;a href=&quot;#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, this symmetry is exploited to compute only the non-negative frequency terms.</source>
          <target state="translated">注意，对于实际输入，&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;输出的最后一个元素如何是第二个元素的复共轭。对于&lt;a href=&quot;#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt;，利用此对称性仅计算非负频率项。</target>
        </trans-unit>
        <trans-unit id="9d24afb4770f955e79718f663c68d81c2708b5a7" translate="yes" xml:space="preserve">
          <source>Notice how the last term in the input to the ordinary &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt; is the complex conjugate of the second term, and the output has zero imaginary part everywhere. When calling &lt;a href=&quot;#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt;, the negative frequencies are not specified, and the output array is purely real.</source>
          <target state="translated">请注意，普通&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt;输入中的最后一项是第二项的复共轭，并且输出到处虚部为零。调用&lt;a href=&quot;#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; 时&lt;/a&gt;，未指定负频率，并且输出数组是纯实数。</target>
        </trans-unit>
        <trans-unit id="ed100c4959db20fe84fd87eecf37518e6739a62d" translate="yes" xml:space="preserve">
          <source>Notice that Cython is an extension-module generator only. Unlike f2py, it includes no automatic facility for compiling and linking the extension module (which must be done in the usual fashion). It does provide a modified distutils class called &lt;code&gt;build_ext&lt;/code&gt; which lets you build an extension module from a &lt;code&gt;.pyx&lt;/code&gt; source. Thus, you could write in a &lt;code&gt;setup.py&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb564d7e3f343c55b0fae22523656706209711d" translate="yes" xml:space="preserve">
          <source>Notice that the above 3 flags are defined so that a new, well- behaved array has these flags defined as true.</source>
          <target state="translated">注意以上3个标志的定义,使一个新的、行为良好的数组将这些标志定义为真。</target>
        </trans-unit>
        <trans-unit id="933e026efdbeaa2316ba75443c7fec80dcb22b12" translate="yes" xml:space="preserve">
          <source>Notice that the full PyArrayObject is used as the first entry in order to ensure that the binary layout of instances of the new type is identical to the PyArrayObject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="847535dd495885c3e2ed82b62e1abcb626ece607" translate="yes" xml:space="preserve">
          <source>Notice that the initial value is used as one of the elements for which the maximum is determined, unlike for the default argument Python&amp;rsquo;s max function, which is only used for empty iterables.</source>
          <target state="translated">请注意，初始值用作确定最大值的元素之一，这与默认参数Python的max函数不同，后者仅用于空的可迭代对象。</target>
        </trans-unit>
        <trans-unit id="98ab17cc2cf9317019aeddb2bbabfef19cd3a629" translate="yes" xml:space="preserve">
          <source>Notice that the initial value is used as one of the elements for which the minimum is determined, unlike for the default argument Python&amp;rsquo;s max function, which is only used for empty iterables.</source>
          <target state="translated">请注意，初始值用作确定最小值的元素之一，这与默认参数Python的max函数不同，后者仅用于空的可迭代对象。</target>
        </trans-unit>
        <trans-unit id="7a3bf5045be1e646ff0b1cf93fe99f156e23026b" translate="yes" xml:space="preserve">
          <source>Notice that the resulting wrapper to &lt;code&gt;FIB&lt;/code&gt; is as &amp;ldquo;smart&amp;rdquo; as in previous case:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492b4a295e5558fecc78ff637653ffa8b09ca97f" translate="yes" xml:space="preserve">
          <source>Notice that the return type is a standard &lt;code&gt;numpy.ndarray&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95fad7b0d0de8433821f8ae84856c18eccd090df" translate="yes" xml:space="preserve">
          <source>Notice that the second &lt;code&gt;usercode&lt;/code&gt; statement must be defined inside an &lt;code&gt;interface&lt;/code&gt; block and where the module dictionary is available through the variable &lt;code&gt;d&lt;/code&gt; (see &lt;code&gt;f2py var.pyf&lt;/code&gt;-generated &lt;code&gt;varmodule.c&lt;/code&gt; for additional details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b99552cfe5ebf21e89509d47400467670883a7d" translate="yes" xml:space="preserve">
          <source>Notice that this isn&amp;rsquo;t the same as Python&amp;rsquo;s &lt;code&gt;default&lt;/code&gt; argument.</source>
          <target state="translated">请注意，这与Python的 &lt;code&gt;default&lt;/code&gt; 参数不同。</target>
        </trans-unit>
        <trans-unit id="86ca463fe236705953b4cb323c8e44dbe110c67f" translate="yes" xml:space="preserve">
          <source>Notice the automatic conversion to the correct format that occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75917695664ab58d7b5d23aff9664353427c773e" translate="yes" xml:space="preserve">
          <source>Now all those people can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70bfcb10a3d92ea0cb076fb11e889a3f7696c2f5" translate="yes" xml:space="preserve">
          <source>Now editing a Python source file in NumPy allows you to immediately test and use your changes (in &lt;code&gt;.py&lt;/code&gt; files), by simply restarting the interpreter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f1d525547aac9ec4fc5c41b72c69bb1f2c8bfa" translate="yes" xml:space="preserve">
          <source>Now go to your fork and make a pull request for the branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1562b378f268443ad7a3ad7b80f355a383c82822" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s tackle &lt;code&gt;__array_function__&lt;/code&gt;. We&amp;rsquo;ll create dict that maps numpy functions to our custom variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4854dca388c79f7bb12e14a8a161b7a492c001a" translate="yes" xml:space="preserve">
          <source>Now multiply a diagonal matrix by &lt;code&gt;Q&lt;/code&gt; on one side and by &lt;code&gt;Q.T&lt;/code&gt; on the other:</source>
          <target state="translated">现在将对角矩阵的一侧乘以 &lt;code&gt;Q&lt;/code&gt; ，另一侧乘以 &lt;code&gt;Q.T&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d9aee1cf03a85f2c9234d34f54fa504a0ad159f3" translate="yes" xml:space="preserve">
          <source>Now our custom array type passes through numpy functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="653b19d1d4883b62177051122cc7aeebf0172920" translate="yes" xml:space="preserve">
          <source>Now returns an empty list instead of None for a fully masked array</source>
          <target state="translated">现在,对于一个完全掩码的数组,返回一个空列表,而不是None。</target>
        </trans-unit>
        <trans-unit id="ec58b2146d74f6a1fb2a7b312c2b04a59b639bdc" translate="yes" xml:space="preserve">
          <source>Now the array &lt;em&gt;has&lt;/em&gt; changed in memory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5721d6e90bb96b54d081e10fa69a0fa60aa41ba" translate="yes" xml:space="preserve">
          <source>Now wait. If you get nervous at the amount of time taken &amp;ndash; the builds can take a while &amp;ndash; you can check the build progress by following the links provided at &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt; to check the build status. Check if all the needed wheels have been built and uploaded before proceeding. There should currently be 21 of them at &lt;a href=&quot;https://anaconda.org/multibuild-wheels-staging/numpy/files&quot;&gt;https://anaconda.org/multibuild-wheels-staging/numpy/files&lt;/a&gt;, 3 for Mac, 6 for Windows, and 12 for Linux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a3bd4e9414b13e38275e5df8769440d431b61f" translate="yes" xml:space="preserve">
          <source>Now we are ready to apply the SVD:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f39ae5d13c5ad14506d67df0c86ac586848a064" translate="yes" xml:space="preserve">
          <source>Now we can iterate over &lt;code&gt;a_itor&lt;/code&gt;, and it will return arrays of size two. Since &lt;code&gt;buf_size&lt;/code&gt; was smaller than any dimension, the first dimension will be iterated over first:</source>
          <target state="translated">现在我们可以遍历 &lt;code&gt;a_itor&lt;/code&gt; ，它将返回大小为2的数组。由于 &lt;code&gt;buf_size&lt;/code&gt; 小于任何维度，因此第一个维度将在第一个维度上进行迭代：</target>
        </trans-unit>
        <trans-unit id="bf7432fe9f7d1de2712d47dd480396ec30fe9d54" translate="yes" xml:space="preserve">
          <source>Now we create an array &lt;code&gt;b1&lt;/code&gt; by slicing &lt;code&gt;a&lt;/code&gt; and modify the first element of &lt;code&gt;b1&lt;/code&gt;. This will modify the corresponding element in &lt;code&gt;a&lt;/code&gt; as well!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76ea020d2e734b4cfb0d824a7cb637d663128ae" translate="yes" xml:space="preserve">
          <source>Now we want to do the same kind of operation, but to all three colors. Our first instinct might be to repeat the same operation we did above to each color matrix individually. However, NumPy&amp;rsquo;s &lt;code&gt;broadcasting&lt;/code&gt; takes care of this for us.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be6dd4a7bf7c5c8f068a6e558d5c8ec36b5c692a" translate="yes" xml:space="preserve">
          <source>Now we write implementations of numpy functions for &lt;code&gt;DiagonalArray&lt;/code&gt;. For completeness, to support the usage &lt;code&gt;arr.sum()&lt;/code&gt; add a method &lt;code&gt;sum&lt;/code&gt; that calls &lt;code&gt;numpy.sum(self)&lt;/code&gt;, and the same for &lt;code&gt;mean&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc172f812b48628145c33844eeb0c5e41365a9a" translate="yes" xml:space="preserve">
          <source>Now you are ready to generate the docs, so write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae5aab236f57788a41324d9fac04d9f996796fb" translate="yes" xml:space="preserve">
          <source>Now you can do the following to test your module:</source>
          <target state="translated">现在你可以做以下工作来测试你的模块。</target>
        </trans-unit>
        <trans-unit id="93e01758207ef7eac9898579c0a0ad53ac2cbd99" translate="yes" xml:space="preserve">
          <source>Now you can make the release commit and tag. We recommend you don&amp;rsquo;t push the commit or tag immediately, just in case you need to do more cleanup. We prefer to defer the push of the tag until we&amp;rsquo;re confident this is the exact form of the released code (see: &lt;a href=&quot;#push-tag-and-commit&quot;&gt;Push the release tag and commit&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d14145f90c1ed14c03e17b7327ce3f007834c2f" translate="yes" xml:space="preserve">
          <source>Now you need to apply the changes from master to this branch using &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html&quot;&gt;git cherry-pick&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da29f0210a502c721dd0dd5c83f6b4fa9f50c915" translate="yes" xml:space="preserve">
          <source>Now you want to connect to the upstream &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy github&lt;/a&gt; repository, so you can merge in changes from trunk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99261818f6547b5ed54374d3a2426ea44c25412d" translate="yes" xml:space="preserve">
          <source>Now,</source>
          <target state="translated">Now,</target>
        </trans-unit>
        <trans-unit id="1a849066ed1f230f65474fee40b0e94a7d98faa2" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;git remote -v&lt;/code&gt; will show two remote repositories named:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1e590b12ac969204974436ab86b73a66b484b9" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;h&lt;/code&gt; is called a &lt;code&gt;House&lt;/code&gt; instance. An instance is therefore a specific realisation of a class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d9c91fe6808bc153fedc3a3be54f274b18ccbd" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;img&lt;/code&gt; is a NumPy array, as we can see when using the &lt;code&gt;type&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ef6adb474c75b77cfec6493b6e37127e46dd0c" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;img_gray&lt;/code&gt; has shape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5e3ab134c32e63476e019b6cc1db7108c6756a" translate="yes" xml:space="preserve">
          <source>Now, applying the &lt;a href=&quot;../reference/generated/numpy.linalg.svd#numpy.linalg.svd&quot;&gt;&lt;code&gt;linalg.svd&lt;/code&gt;&lt;/a&gt; function to this matrix, we obtain the following decomposition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4103944902505e88c56a448e8658e10eed8eb1b4" translate="yes" xml:space="preserve">
          <source>Now, do one experiment throwing the dice 10 time, and 10 times again, and another throwing the dice 20 times, and 20 times again:</source>
          <target state="translated">现在,做一个扔骰子的实验,扔10次,再扔10次,再扔20次,再扔20次。</target>
        </trans-unit>
        <trans-unit id="d2ea454c7baf7564ea6fcb77c917ce2269209f53" translate="yes" xml:space="preserve">
          <source>Now, if we wish to rebuild the full SVD (with no approximation), we can do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79503e4a7bcf0bb6045b13fb5038f72cea2083ab" translate="yes" xml:space="preserve">
          <source>Now, the function can be called in a much more robust way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0435f8dfb75dd633a8592e953b3a61869c66ed" translate="yes" xml:space="preserve">
          <source>Now, throw the dice 20 times, and 20 times again:</source>
          <target state="translated">现在,扔20次骰子,再扔20次。</target>
        </trans-unit>
        <trans-unit id="e886cde483c798665f26429d663d928161ab6acf" translate="yes" xml:space="preserve">
          <source>Now, to build our approximation, we first need to make sure that our singular values are ready for multiplication, so we build our &lt;code&gt;Sigma&lt;/code&gt; matrix similarly to what we did before. The &lt;code&gt;Sigma&lt;/code&gt; array must have dimensions &lt;code&gt;(3, 768, 1024)&lt;/code&gt;. In order to add the singular values to the diagonal of &lt;code&gt;Sigma&lt;/code&gt;, we will use the &lt;code&gt;fill_diagonal&lt;/code&gt; function from NumPy, using each of the 3 rows in &lt;code&gt;s&lt;/code&gt; as the diagonal for each of the 3 matrices in &lt;code&gt;Sigma&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="565f463048564fa2ff4bfcbc1dc8859dde3aeacc" translate="yes" xml:space="preserve">
          <source>Now, to do the approximation, we must choose only the first &lt;code&gt;k&lt;/code&gt; singular values for each color channel. This can be done using the following syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a0393525e01988d9f9cb1a6b35b57bda883e2e" translate="yes" xml:space="preserve">
          <source>Now, we create indices to manipulate a 3-D array:</source>
          <target state="translated">现在,我们创建指数来操作一个三维数组。</target>
        </trans-unit>
        <trans-unit id="c7902891716f837cf46001e7e450e13862b8420f" translate="yes" xml:space="preserve">
          <source>Now, we want to check if the reconstructed &lt;code&gt;U @ Sigma @ Vt&lt;/code&gt; is close to the original &lt;code&gt;img_gray&lt;/code&gt; matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f06f8937e93eb4f141bfb2a705595fcdf67626f" translate="yes" xml:space="preserve">
          <source>Now, when we define a function, we can &amp;ldquo;decorate&amp;rdquo; it using &lt;code&gt;log&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc7b2e6b23e5632ad7c5158bf566b73a38ffebf" translate="yes" xml:space="preserve">
          <source>Now, whenever you want to switch to the virtual environment, you can use the command &lt;code&gt;source numpy-dev/bin/activate&lt;/code&gt;, and &lt;code&gt;deactivate&lt;/code&gt; to exit from the virtual environment and back to your previous shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="198b66dda9dfc0b0d1d736fde28782e16d5483f5" translate="yes" xml:space="preserve">
          <source>Now, you can go ahead and repeat this experiment with other values of &lt;code&gt;k&lt;/code&gt;, and each of your experiments should give you a slightly better (or worse) image depending on the value you choose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd61014c9008087889fd725668b3c8d4970463d" translate="yes" xml:space="preserve">
          <source>Now, you can run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61d4e29999f717e20a2ffa02fda03db9cc09177" translate="yes" xml:space="preserve">
          <source>Now:</source>
          <target state="translated">Now:</target>
        </trans-unit>
        <trans-unit id="8b7fcaae0aa22776c49d066644c2b1975dfe6da1" translate="yes" xml:space="preserve">
          <source>NpyAuxData (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a30eac154cabdf7a90e0db5f0c2478a5065e89" translate="yes" xml:space="preserve">
          <source>NpyAuxData_CloneFunc</source>
          <target state="translated">NpyAuxData_CloneFunc</target>
        </trans-unit>
        <trans-unit id="34e8b7730172c8e3d3adc73c058819a6f92f117f" translate="yes" xml:space="preserve">
          <source>NpyAuxData_CloneFunc (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4fef0ec03464a7b11bd65b370680102da32d76" translate="yes" xml:space="preserve">
          <source>NpyAuxData_FreeFunc</source>
          <target state="translated">NpyAuxData_FreeFunc</target>
        </trans-unit>
        <trans-unit id="97e892e902cfe2bd9ee7b43a2c987c5ba8273d80" translate="yes" xml:space="preserve">
          <source>NpyAuxData_FreeFunc (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3a83bac5637b7f866d954fa04d5054091c36cc" translate="yes" xml:space="preserve">
          <source>NpyIter</source>
          <target state="translated">NpyIter</target>
        </trans-unit>
        <trans-unit id="82a0508669bbb7771cac0c8d3e2c866a68070845" translate="yes" xml:space="preserve">
          <source>NpyIter (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c5db212050a32c003c23a2e475d5c5ce78e2df" translate="yes" xml:space="preserve">
          <source>NpyIter_AdvancedNew (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af20c5dee7afb2fdfe083ea49a8e985dcebda12" translate="yes" xml:space="preserve">
          <source>NpyIter_AdvancedNew()</source>
          <target state="translated">NpyIter_AdvancedNew()</target>
        </trans-unit>
        <trans-unit id="4b68aef05b915f8c4d85c85d6e5e698604e22d5b" translate="yes" xml:space="preserve">
          <source>NpyIter_Copy (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b997b8b2b511720cd1069c024299823f83302c9e" translate="yes" xml:space="preserve">
          <source>NpyIter_Copy()</source>
          <target state="translated">NpyIter_Copy()</target>
        </trans-unit>
        <trans-unit id="dead001979a949af7bc216d40e317c11b1627b50" translate="yes" xml:space="preserve">
          <source>NpyIter_CreateCompatibleStrides (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fb78c3f62b576c1af874d751640db8eff8c9979" translate="yes" xml:space="preserve">
          <source>NpyIter_CreateCompatibleStrides()</source>
          <target state="translated">NpyIter_CreateCompatibleStrides()</target>
        </trans-unit>
        <trans-unit id="bd5f39811c4a438e4611fe7324c733dae8e18e94" translate="yes" xml:space="preserve">
          <source>NpyIter_Deallocate (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad45ab8ae95fe7da10aaac502dcfd57dbf572fa" translate="yes" xml:space="preserve">
          <source>NpyIter_Deallocate()</source>
          <target state="translated">NpyIter_Deallocate()</target>
        </trans-unit>
        <trans-unit id="9e58f50382b305a7c644ed30e9dbf73ab673b658" translate="yes" xml:space="preserve">
          <source>NpyIter_EnableExternalLoop (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39e8d7265758ca02d07e1e363c5debc0123f813" translate="yes" xml:space="preserve">
          <source>NpyIter_EnableExternalLoop()</source>
          <target state="translated">NpyIter_EnableExternalLoop()</target>
        </trans-unit>
        <trans-unit id="329ae7e5f8f4f861595a2f3783d09679b3a68e75" translate="yes" xml:space="preserve">
          <source>NpyIter_GetAxisStrideArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb2c139e38956ebdf5ce855ccf3149ea641f8b05" translate="yes" xml:space="preserve">
          <source>NpyIter_GetAxisStrideArray()</source>
          <target state="translated">NpyIter_GetAxisStrideArray()</target>
        </trans-unit>
        <trans-unit id="11e9224b826aa03f20a5575963d1a61c21bde7ea" translate="yes" xml:space="preserve">
          <source>NpyIter_GetBufferSize (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c71d1d0e6fd6d70024c7dd931246be434c73502" translate="yes" xml:space="preserve">
          <source>NpyIter_GetBufferSize()</source>
          <target state="translated">NpyIter_GetBufferSize()</target>
        </trans-unit>
        <trans-unit id="efd6b812e98d492f8edfd24e4ba12b4a6b2f06ff" translate="yes" xml:space="preserve">
          <source>NpyIter_GetDataPtrArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a85869fc34454e6204a9b83263efd25b3b19a8" translate="yes" xml:space="preserve">
          <source>NpyIter_GetDataPtrArray()</source>
          <target state="translated">NpyIter_GetDataPtrArray()</target>
        </trans-unit>
        <trans-unit id="4818f80260586e06d259cc413bb89e872d11d852" translate="yes" xml:space="preserve">
          <source>NpyIter_GetDescrArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62cedbb3cbc591b2ae980b3bc6c8c39f71d0c16b" translate="yes" xml:space="preserve">
          <source>NpyIter_GetDescrArray()</source>
          <target state="translated">NpyIter_GetDescrArray()</target>
        </trans-unit>
        <trans-unit id="b2e4a49c346fdbeb713aed872c544759f393dc2a" translate="yes" xml:space="preserve">
          <source>NpyIter_GetGetMultiIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d029059dda4dad1438f1bd80a75d454f99834d6" translate="yes" xml:space="preserve">
          <source>NpyIter_GetGetMultiIndex()</source>
          <target state="translated">NpyIter_GetGetMultiIndex()</target>
        </trans-unit>
        <trans-unit id="0b61a40f2f042effaff1a816288916e29182e78d" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIndexPtr (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66611101d6de9d68cce0bd7a8cf2f113e7678aaf" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIndexPtr()</source>
          <target state="translated">NpyIter_GetIndexPtr()</target>
        </trans-unit>
        <trans-unit id="709bac1bb4a069b2df14e08fa3d634e04e1b48d8" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInitialDataPtrArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca4420e7f21331a3412d9afdd62effd1a37e0d5" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInitialDataPtrArray()</source>
          <target state="translated">NpyIter_GetInitialDataPtrArray()</target>
        </trans-unit>
        <trans-unit id="ce42d7c0034eff3c7307f8b08adc8d1d3d5232be" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerFixedStrideArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2852a223ce3a2b4862d0d75cd1f8c82ebb096d" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerFixedStrideArray()</source>
          <target state="translated">NpyIter_GetInnerFixedStrideArray()</target>
        </trans-unit>
        <trans-unit id="320bab14d48a2be5366699d949e501506d8b52ef" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerLoopSizePtr (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28fb690d09a18949fd479bfd69414cd7025ffd8" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerLoopSizePtr()</source>
          <target state="translated">NpyIter_GetInnerLoopSizePtr()</target>
        </trans-unit>
        <trans-unit id="2741ed5c537a092cf9f55caeb0d6909844811cae" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerStrideArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="459e9e1f94992501dfb6860694a283afdd8b7cd8" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerStrideArray()</source>
          <target state="translated">NpyIter_GetInnerStrideArray()</target>
        </trans-unit>
        <trans-unit id="916bfb4b9ccc85a495812e9b0ef709804cf83e7b" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b51d4d2bf86336410a4e52bb5d565c6529f946c" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterIndex()</source>
          <target state="translated">NpyIter_GetIterIndex()</target>
        </trans-unit>
        <trans-unit id="4f98f4187c0881fc46fb9149b68116d68e20d9ea" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterIndexRange (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f9917bbb45a59125169b7d51e52942d1ae839d" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterIndexRange()</source>
          <target state="translated">NpyIter_GetIterIndexRange()</target>
        </trans-unit>
        <trans-unit id="6ac9c145de13db3cda86b9108539ac806761dc14" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterNext (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb93380537687af5addf300e0da2d51122534b79" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterSize (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7b47088c34a7caf54317e4c555ce5eeee306bf9" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterSize()</source>
          <target state="translated">NpyIter_GetIterSize()</target>
        </trans-unit>
        <trans-unit id="971f351012eac4ac6bf123d19280ff6e83e62e85" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterView (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37332e2ac83c27d275077f93c1a5465ad79ccdf" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterView()</source>
          <target state="translated">NpyIter_GetIterView()</target>
        </trans-unit>
        <trans-unit id="260ac3818c138694453f685279c2631308cb9db4" translate="yes" xml:space="preserve">
          <source>NpyIter_GetMultiIndexFunc</source>
          <target state="translated">NpyIter_GetMultiIndexFunc</target>
        </trans-unit>
        <trans-unit id="268c5739b883afa9c178c9d12b961525ac033a81" translate="yes" xml:space="preserve">
          <source>NpyIter_GetMultiIndexFunc (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12fef6dc6e8adca628a81ab1f9f58214b8989570" translate="yes" xml:space="preserve">
          <source>NpyIter_GetNDim (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e9bba8a229eb928a91402e6ca604c155e3edd64" translate="yes" xml:space="preserve">
          <source>NpyIter_GetNDim()</source>
          <target state="translated">NpyIter_GetNDim()</target>
        </trans-unit>
        <trans-unit id="68db817bd7a88e9a2db3bf2cfbe83efefe3a7b98" translate="yes" xml:space="preserve">
          <source>NpyIter_GetNOp (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50db8bb821c577506b545754506219ead592b053" translate="yes" xml:space="preserve">
          <source>NpyIter_GetNOp()</source>
          <target state="translated">NpyIter_GetNOp()</target>
        </trans-unit>
        <trans-unit id="4be079e1aeeda5c22d683667022b51cf015a2c21" translate="yes" xml:space="preserve">
          <source>NpyIter_GetOperandArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af90f6f35483cf45c99c7df56d9615992da54dd" translate="yes" xml:space="preserve">
          <source>NpyIter_GetOperandArray()</source>
          <target state="translated">NpyIter_GetOperandArray()</target>
        </trans-unit>
        <trans-unit id="4b047889d28074e88029d8a1e07fab68c9e1b2a6" translate="yes" xml:space="preserve">
          <source>NpyIter_GetReadFlags (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30bb289b8e86739e36ea60928a2ed64312d2fec" translate="yes" xml:space="preserve">
          <source>NpyIter_GetReadFlags()</source>
          <target state="translated">NpyIter_GetReadFlags()</target>
        </trans-unit>
        <trans-unit id="72287467289d08139728b9bd588cb1fba0d298e1" translate="yes" xml:space="preserve">
          <source>NpyIter_GetShape (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3fe550cadce766e0ebaa92151a7d483873ef4a" translate="yes" xml:space="preserve">
          <source>NpyIter_GetShape()</source>
          <target state="translated">NpyIter_GetShape()</target>
        </trans-unit>
        <trans-unit id="16f7d0a2122c563a659425f4ce571bbbba298beb" translate="yes" xml:space="preserve">
          <source>NpyIter_GetWriteFlags (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd9a2ff8ce509672e11ffa76fdbabff9b0c7181" translate="yes" xml:space="preserve">
          <source>NpyIter_GetWriteFlags()</source>
          <target state="translated">NpyIter_GetWriteFlags()</target>
        </trans-unit>
        <trans-unit id="6668661c9c3f5c1e327bd4f2c42ad82f1605c898" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3120c654191cddf0b70bae47a341b3c86669393" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoIndex()</source>
          <target state="translated">NpyIter_GotoIndex()</target>
        </trans-unit>
        <trans-unit id="32885a42e6fb8b031f26299bec0d11656e3b1eaa" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoIterIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1654c5ff8fe66cc2194f6b61e83a8e796fe628" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoIterIndex()</source>
          <target state="translated">NpyIter_GotoIterIndex()</target>
        </trans-unit>
        <trans-unit id="e135f8536fc5fd83a52cd6bbd2bce201e704280c" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoMultiIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d041142525a40cf564e2e7e029c65f6509b0a323" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoMultiIndex()</source>
          <target state="translated">NpyIter_GotoMultiIndex()</target>
        </trans-unit>
        <trans-unit id="1d5b6a575bb6f461dea653952d455489a8ea3d4a" translate="yes" xml:space="preserve">
          <source>NpyIter_HasDelayedBufAlloc (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0864809f09d890d29d15054f92994f033a3f43" translate="yes" xml:space="preserve">
          <source>NpyIter_HasDelayedBufAlloc()</source>
          <target state="translated">NpyIter_HasDelayedBufAlloc()</target>
        </trans-unit>
        <trans-unit id="8d6631cc570fdeba0443b204635f61ead9da9cc0" translate="yes" xml:space="preserve">
          <source>NpyIter_HasExternalLoop (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02c750ba9fcfc1c225387cebcaf21e29ccbc7ab1" translate="yes" xml:space="preserve">
          <source>NpyIter_HasExternalLoop()</source>
          <target state="translated">NpyIter_HasExternalLoop()</target>
        </trans-unit>
        <trans-unit id="01ff965a16adc18e1fe09a249c239ef993e1e4cd" translate="yes" xml:space="preserve">
          <source>NpyIter_HasIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1495f8b014a812b7d5168151357e69d6e80056fa" translate="yes" xml:space="preserve">
          <source>NpyIter_HasIndex()</source>
          <target state="translated">NpyIter_HasIndex()</target>
        </trans-unit>
        <trans-unit id="524724e0000bf6ba5bb9fefb1e4de88d3ce724e6" translate="yes" xml:space="preserve">
          <source>NpyIter_HasMultiIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca93af25bd286e2ffe55a87884c419afcd79bfcd" translate="yes" xml:space="preserve">
          <source>NpyIter_HasMultiIndex()</source>
          <target state="translated">NpyIter_HasMultiIndex()</target>
        </trans-unit>
        <trans-unit id="b4e6deeafbbcf71e1a3f6bc2ac6366e5bd6c1b90" translate="yes" xml:space="preserve">
          <source>NpyIter_IsBuffered (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="476b949116e329f3c582aec5e76ce2e141633429" translate="yes" xml:space="preserve">
          <source>NpyIter_IsBuffered()</source>
          <target state="translated">NpyIter_IsBuffered()</target>
        </trans-unit>
        <trans-unit id="7304a6b23051f3e1aaa8d76004af420f8c287e9d" translate="yes" xml:space="preserve">
          <source>NpyIter_IsFirstVisit (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9bbd57db7393e50498619291fc91b81f37f813" translate="yes" xml:space="preserve">
          <source>NpyIter_IsFirstVisit()</source>
          <target state="translated">NpyIter_IsFirstVisit()</target>
        </trans-unit>
        <trans-unit id="c71ca1fe83aa6474b8db38df750b5605a0ad4041" translate="yes" xml:space="preserve">
          <source>NpyIter_IsGrowInner (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0a2dba542604a7f3103127f1353c17a14acca2" translate="yes" xml:space="preserve">
          <source>NpyIter_IsGrowInner()</source>
          <target state="translated">NpyIter_IsGrowInner()</target>
        </trans-unit>
        <trans-unit id="89d075475c669dbbf16b180a78f6a538e870d992" translate="yes" xml:space="preserve">
          <source>NpyIter_IterNextFunc</source>
          <target state="translated">NpyIter_IterNextFunc</target>
        </trans-unit>
        <trans-unit id="ed5e1d448ea8ab46ae13594b26e85229c0f707c9" translate="yes" xml:space="preserve">
          <source>NpyIter_IterNextFunc (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7035ada01b636882b1ed7a431b18b92987e61d41" translate="yes" xml:space="preserve">
          <source>NpyIter_MultiNew (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="959108f7b8a46be14788dcc6f2c656a40adf98c1" translate="yes" xml:space="preserve">
          <source>NpyIter_MultiNew()</source>
          <target state="translated">NpyIter_MultiNew()</target>
        </trans-unit>
        <trans-unit id="ed094cc005976d6753311589b5d73c8f2c8e5e4f" translate="yes" xml:space="preserve">
          <source>NpyIter_New (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75df925e997f8a9b01f4fc38c2a52f970f929a3f" translate="yes" xml:space="preserve">
          <source>NpyIter_RemoveMultiIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0fc99dccddcd13dec9ec17ac48fd49dd80c577" translate="yes" xml:space="preserve">
          <source>NpyIter_RemoveMultiIndex()</source>
          <target state="translated">NpyIter_RemoveMultiIndex()</target>
        </trans-unit>
        <trans-unit id="71dc9b48fe46c56aa709225d6c3eb5faead7860b" translate="yes" xml:space="preserve">
          <source>NpyIter_RequiresBuffering (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a202ae5802958f468dad8c3e99a4bb5293a4dde8" translate="yes" xml:space="preserve">
          <source>NpyIter_RequiresBuffering()</source>
          <target state="translated">NpyIter_RequiresBuffering()</target>
        </trans-unit>
        <trans-unit id="082f6c0216a14a9d8e91d9d0eb80091b4c8e7c17" translate="yes" xml:space="preserve">
          <source>NpyIter_Reset (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c109fda112a4bfc0725b7a5833fd46c5602a3173" translate="yes" xml:space="preserve">
          <source>NpyIter_Reset()</source>
          <target state="translated">NpyIter_Reset()</target>
        </trans-unit>
        <trans-unit id="70f5ee8ee0cc17ab92992d6cf6ee393f1e4520e7" translate="yes" xml:space="preserve">
          <source>NpyIter_ResetBasePointers (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1294ce3152cab7ceda644b504d717770b89e5c7" translate="yes" xml:space="preserve">
          <source>NpyIter_ResetBasePointers()</source>
          <target state="translated">NpyIter_ResetBasePointers()</target>
        </trans-unit>
        <trans-unit id="14a37f97f8b6e5b56b6e83ff5eb67b7c25067c0c" translate="yes" xml:space="preserve">
          <source>NpyIter_ResetToIterIndexRange (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0acf29df8ba8a7bb014f05220b41b68cf91300" translate="yes" xml:space="preserve">
          <source>NpyIter_ResetToIterIndexRange()</source>
          <target state="translated">NpyIter_ResetToIterIndexRange()</target>
        </trans-unit>
        <trans-unit id="73626c9be0436b0d908d20d700956f6f6ce365b0" translate="yes" xml:space="preserve">
          <source>NpyIter_Type</source>
          <target state="translated">NpyIter_Type</target>
        </trans-unit>
        <trans-unit id="61c3b0ba34d7f397bd9f7eff4691cefedb4d278d" translate="yes" xml:space="preserve">
          <source>NpyIter_Type (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114cc06627557f63febd03e44f39195669b3db75" translate="yes" xml:space="preserve">
          <source>NumFOCUS Subcommittee</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148fb3e1f0f3a0a5a25d7af63d9dc5d6da0841ea" translate="yes" xml:space="preserve">
          <source>NumPy</source>
          <target state="translated">NumPy</target>
        </trans-unit>
        <trans-unit id="a9d2a1b57f4f20938978d4d1c165136857a81954" translate="yes" xml:space="preserve">
          <source>NumPy &amp;mdash; it provides packages like:</source>
          <target state="translated">NumPy &amp;mdash;它提供以下软件包：</target>
        </trans-unit>
        <trans-unit id="766bc7e1c62d6bf447df2796935c0002e01046b4" translate="yes" xml:space="preserve">
          <source>NumPy (&lt;strong&gt;Numerical Python&lt;/strong&gt;) is an open source Python library that&amp;rsquo;s used in almost every field of science and engineering. It&amp;rsquo;s the universal standard for working with numerical data in Python, and it&amp;rsquo;s at the core of the scientific Python and PyData ecosystems. NumPy users include everyone from beginning coders to experienced researchers doing state-of-the-art scientific and industrial research and development. The NumPy API is used extensively in Pandas, SciPy, Matplotlib, scikit-learn, scikit-image and most other data science and scientific Python packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd7856c2dbbcca63221ed726f4aced6db4c3c7ff" translate="yes" xml:space="preserve">
          <source>NumPy API Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41afbb931d30bf51df3c5d024df1c8569665b6f" translate="yes" xml:space="preserve">
          <source>NumPy Array Scalars and SWIG</source>
          <target state="translated">NumPy Array Scalars和SWIG。</target>
        </trans-unit>
        <trans-unit id="51ad55a9768d51db51dfc0fe1a4177bdd94eb2e8" translate="yes" xml:space="preserve">
          <source>NumPy C API</source>
          <target state="translated">NumPy C API</target>
        </trans-unit>
        <trans-unit id="3ee0e4047919b43a08c3c67ba0e3fc5e60d9cdaa" translate="yes" xml:space="preserve">
          <source>NumPy C Code Explanations</source>
          <target state="translated">NumPy C代码解释</target>
        </trans-unit>
        <trans-unit id="e338b3196336652494be7c1852eae3cde59bd702" translate="yes" xml:space="preserve">
          <source>NumPy C Style Guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6796af8c026b629052c1b19daa9ac3e40093d9f" translate="yes" xml:space="preserve">
          <source>NumPy C-API</source>
          <target state="translated">NumPy C-API</target>
        </trans-unit>
        <trans-unit id="a1586bc86c3a6e96b55470571a3b7966155b62c1" translate="yes" xml:space="preserve">
          <source>NumPy Code of Conduct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1435e02825452fed2fb68e6c73bfa4d34ac784c1" translate="yes" xml:space="preserve">
          <source>NumPy Code of Conduct - How to follow up on a report</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68b43adfe65e0ada7943e8e901732e697fd8106" translate="yes" xml:space="preserve">
          <source>NumPy Contributor Guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9b8569488631e17e9c539e945f4151de6b16a5" translate="yes" xml:space="preserve">
          <source>NumPy Distutils - Users Guide</source>
          <target state="translated">NumPy Distutils-用户指南</target>
        </trans-unit>
        <trans-unit id="c956147a86ea5dbf2bd113161d5a9a92844fee2c" translate="yes" xml:space="preserve">
          <source>NumPy Distutils preprocesses C source files (extension: &lt;code&gt;.c.src&lt;/code&gt;) written in a custom templating language to generate C code. The &lt;code&gt;@&lt;/code&gt; symbol is used to wrap macro-style variables to empower a string substitution mechanism that might describe (for instance) a set of data types.</source>
          <target state="translated">NumPy Distutils预处理以自定义模板语言编写的C源文件（扩展名： &lt;code&gt;.c.src&lt;/code&gt; ）以生成C代码。在 &lt;code&gt;@&lt;/code&gt; 符号用于包装宏观变量风格授权，可能描述（例如）的字符串替换机制的一组数据类型。</target>
        </trans-unit>
        <trans-unit id="6d3daec11f336cbe9aa58a4987acc6154b7a71ca" translate="yes" xml:space="preserve">
          <source>NumPy Docs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87b70e72189be1c91039076031182a00ca8a4a2" translate="yes" xml:space="preserve">
          <source>NumPy Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11f236a358860bc1630b35d02b897f965a3abe6" translate="yes" xml:space="preserve">
          <source>NumPy Enhancement Proposal (NEP) 32, &lt;a href=&quot;https://numpy.org/neps/nep-0032-remove-financial-functions.html&quot;&gt;https://numpy.org/neps/nep-0032-remove-financial-functions.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f4b91200bead38a769f70a1e46a5128f09c922" translate="yes" xml:space="preserve">
          <source>NumPy Enhancement Proposals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b610e33661eed30d2fd4d5c8298056db2d15c3b" translate="yes" xml:space="preserve">
          <source>NumPy How Tos</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b77a99ad474e5c770e0ddd949ded46acfaf38e" translate="yes" xml:space="preserve">
          <source>NumPy Issues: &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;https://github.com/numpy/numpy/issues&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07568fa1b23354307b498eba5947dd449b1ae50" translate="yes" xml:space="preserve">
          <source>NumPy License</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1797f9e232d63f819933885e2ac94ec0352d11" translate="yes" xml:space="preserve">
          <source>NumPy Reference</source>
          <target state="translated">NumPy参考</target>
        </trans-unit>
        <trans-unit id="23bd4c05c1a40776eacbfc3e62d23e6f2151bb0f" translate="yes" xml:space="preserve">
          <source>NumPy Reference, section &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html&quot;&gt;Generalized Universal Function API&lt;/a&gt;.</source>
          <target state="translated">NumPy参考资料的&amp;ldquo; &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html&quot;&gt;通用函数API&amp;rdquo;部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bcf67cf31bc3a7972c91a07dd966f1740a8d146e" translate="yes" xml:space="preserve">
          <source>NumPy Tutorials</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da31cee45cf66b17220997ed18c1c784b896e561" translate="yes" xml:space="preserve">
          <source>NumPy User Guide, section &lt;a href=&quot;https://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html&quot;&gt;I/O with NumPy&lt;/a&gt;.</source>
          <target state="translated">NumPy用户指南，&lt;a href=&quot;https://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html&quot;&gt;使用NumPy的I / O&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="dfb797f6ad28f48ccb741b2ddb48976e23e00a3f" translate="yes" xml:space="preserve">
          <source>NumPy allows the subtraction of two Datetime values, an operation which produces a number with a time unit. Because NumPy doesn&amp;rsquo;t have a physical quantities system in its core, the timedelta64 data type was created to complement datetime64.</source>
          <target state="translated">NumPy允许两个Datetime值相减，该操作以时间单位产生数字。由于NumPy的核心没有物理量系统，因此创建了timedelta64数据类型以补充datetime64。</target>
        </trans-unit>
        <trans-unit id="f9dacbde768b51aaba6413e3c788f0b194b5b375" translate="yes" xml:space="preserve">
          <source>NumPy allows the subtraction of two Datetime values, an operation which produces a number with a time unit. Because NumPy doesn&amp;rsquo;t have a physical quantities system in its core, the timedelta64 data type was created to complement datetime64. The arguments for timedelta64 are a number, to represent the number of units, and a date/time unit, such as (D)ay, (M)onth, (Y)ear, (h)ours, (m)inutes, or (s)econds. The timedelta64 data type also accepts the string &amp;ldquo;NAT&amp;rdquo; in place of the number for a &amp;ldquo;Not A Time&amp;rdquo; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750ef31835ba51a139fefe6ca7653831fa1d642d" translate="yes" xml:space="preserve">
          <source>NumPy also performs aggregation functions. In addition to &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, and &lt;code&gt;sum&lt;/code&gt;, you can easily run &lt;code&gt;mean&lt;/code&gt; to get the average, &lt;code&gt;prod&lt;/code&gt; to get the result of multiplying the elements together, &lt;code&gt;std&lt;/code&gt; to get the standard deviation, and more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3681d5d48b000e09eb74bcf9d80a233df272bb0f" translate="yes" xml:space="preserve">
          <source>NumPy and SWIG</source>
          <target state="translated">NumPy和SWIG</target>
        </trans-unit>
        <trans-unit id="c826d8c52c25e4bbad4a786ac8dfdcf96c8f11ac" translate="yes" xml:space="preserve">
          <source>NumPy and Swig</source>
          <target state="translated">NumPy和Swig</target>
        </trans-unit>
        <trans-unit id="bd9f76864b0123b6e81c3abbfaba07bd1a398902" translate="yes" xml:space="preserve">
          <source>NumPy arrays are faster and more compact than Python lists. An array consumes less memory and is convenient to use. NumPy uses much less memory to store data and it provides a mechanism of specifying the data types. This allows the code to be optimized even further.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e9cb3043e5f97824505a55cbdfc5294d3ba613" translate="yes" xml:space="preserve">
          <source>NumPy arrays consist of two major components, the raw array data (from now on, referred to as the data buffer), and the information about the raw array data. The data buffer is typically what people think of as arrays in C or Fortran, a contiguous (and fixed) block of memory containing fixed sized data items. NumPy also contains a significant set of data that describes how to interpret the data in the data buffer. This extra information contains (among other things):</source>
          <target state="translated">NumPy数组由两大部分组成,一是原始数组数据(以下简称数据缓冲区),二是原始数组数据的信息。数据缓冲区通常是人们认为的C或Fortran中的数组,是一个连续(且固定)的内存块,包含固定大小的数据项。NumPy还包含一组重要的数据,描述了如何解释数据缓冲区中的数据。这个额外的信息包含(除其他外)。</target>
        </trans-unit>
        <trans-unit id="064ff558785222ad92d746322b42cf271317a323" translate="yes" xml:space="preserve">
          <source>NumPy arrays facilitate advanced mathematical and other types of operations on large numbers of data. Typically, such operations are executed more efficiently and with less code than is possible using Python&amp;rsquo;s built-in sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9df6ed13e1a0bf8dd7a4da9cdb0f04829d71462" translate="yes" xml:space="preserve">
          <source>NumPy arrays have a fixed size at creation, unlike Python lists (which can grow dynamically). Changing the size of an &lt;code&gt;ndarray&lt;/code&gt; will create a new array and delete the original.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a2b1964b63758771b415bd46c81a550e3302e2" translate="yes" xml:space="preserve">
          <source>NumPy arrays may be indexed with other arrays (or any other sequence- like object that can be converted to an array, such as lists, with the exception of tuples; see the end of this document for why this is). The use of index arrays ranges from simple, straightforward cases to complex, hard-to-understand cases. For all cases of index arrays, what is returned is a copy of the original data, not a view as one gets for slices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f594d6227d1e21e95a87fa36149ce8ba56ba3bd8" translate="yes" xml:space="preserve">
          <source>NumPy arrays with a structured dtype can also be viewed as &lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;recarray&lt;/code&gt;&lt;/a&gt;, where a field can be accessed as if it were an attribute. For that reason, we may need to make sure that the field name doesn&amp;rsquo;t contain any space or invalid character, or that it does not correspond to the name of a standard attribute (like &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;shape&lt;/code&gt;), which would confuse the interpreter. &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; accepts three optional arguments that provide a finer control on the names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac46c4db4be1d2bf47d471c892c8666f70fae9c0" translate="yes" xml:space="preserve">
          <source>NumPy basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5ee6decc812823bbb32d4c52868169ed0e2dc6" translate="yes" xml:space="preserve">
          <source>NumPy benchmarks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acba6e54dd52e6409526789be99f698cf4b66810" translate="yes" xml:space="preserve">
          <source>NumPy binary files (NPY, NPZ)</source>
          <target state="translated">NumPy二进制文件(NPY,NPZ)</target>
        </trans-unit>
        <trans-unit id="e2731ffa90b7c735aae8e17474bd85f4ca800f4d" translate="yes" xml:space="preserve">
          <source>NumPy can do operations on arrays whose shapes are mismatched:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d16a651e79e36287ab38bac721290bfd05bc2a01" translate="yes" xml:space="preserve">
          <source>NumPy comes with 24 builtin data-types. While this covers a large majority of possible use cases, it is conceivable that a user may have a need for an additional data-type. There is some support for adding an additional data-type into the NumPy system. This additional data- type will behave much like a regular data-type except ufuncs must have 1-d loops registered to handle it separately. Also checking for whether or not other data-types can be cast &amp;ldquo;safely&amp;rdquo; to and from this new type or not will always return &amp;ldquo;can cast&amp;rdquo; unless you also register which types your new data-type can be cast to and from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f2beec853b334d966939a6cfbd8740cabbc29f" translate="yes" xml:space="preserve">
          <source>NumPy community</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="587dfdb00740f1bca4ab2388a780e1daaf9e9438" translate="yes" xml:space="preserve">
          <source>NumPy contains both an &lt;code&gt;array&lt;/code&gt; class and a &lt;code&gt;matrix&lt;/code&gt; class. The &lt;code&gt;array&lt;/code&gt; class is intended to be a general-purpose n-dimensional array for many kinds of numerical computing, while &lt;code&gt;matrix&lt;/code&gt; is intended to facilitate linear algebra computations specifically. In practice there are only a handful of key differences between the two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e0392d352bfceb00b69b8aae489d3cfcd35b94" translate="yes" xml:space="preserve">
          <source>NumPy core libraries</source>
          <target state="translated">NumPy核心库</target>
        </trans-unit>
        <trans-unit id="ccf16bd0788fff6636ddfa05a6cb0f611b1a5988" translate="yes" xml:space="preserve">
          <source>NumPy core math library</source>
          <target state="translated">NumPy核心数学库</target>
        </trans-unit>
        <trans-unit id="973c555328d9b9a87fd43d16a1a900328d00f946" translate="yes" xml:space="preserve">
          <source>NumPy data type descriptions are instances of the &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">NumPy数据类型描述是&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;类的实例。</target>
        </trans-unit>
        <trans-unit id="be9b40e5263a5085939745fd3402fa19fc002ecb" translate="yes" xml:space="preserve">
          <source>NumPy distutils - users guide</source>
          <target state="translated">NumPy distutils-用户指南</target>
        </trans-unit>
        <trans-unit id="7682241df5064b6dcd3fa7f5b4aadf68c8c520d1" translate="yes" xml:space="preserve">
          <source>NumPy distutils supports automatic conversion of source files named &amp;lt;somefile&amp;gt;.src. This facility can be used to maintain very similar code blocks requiring only simple changes between blocks. During the build phase of setup, if a template file named &amp;lt;somefile&amp;gt;.src is encountered, a new file named &amp;lt;somefile&amp;gt; is constructed from the template and placed in the build directory to be used instead. Two forms of template conversion are supported. The first form occurs for files named &amp;lt;file&amp;gt;.ext.src where ext is a recognized Fortran extension (f, f90, f95, f77, for, ftn, pyf). The second form is used for all other cases.</source>
          <target state="translated">NumPy distutils支持自动转换名为&amp;lt;somefile&amp;gt; .src的源文件。此功能可用于维护非常相似的代码块，仅需在块之间进行简单更改即可。在安装程序的构建阶段，如果遇到名为&amp;lt;somefile&amp;gt; .src的模板文件，则将从模板中构建一个名为&amp;lt;somefile&amp;gt;的新文件，并将其放置在构建目录中以供使用。支持两种形式的模板转换。第一种形式出现在名为&amp;lt;file&amp;gt; .ext.src的文件中，其中ext是公认的Fortran扩展名（f，f90，f95，f77，用于ftn，pyf）。第二种形式用于所有其他情况。</target>
        </trans-unit>
        <trans-unit id="52e91b4c51a9db40b4247ecf6771ad0f610935f6" translate="yes" xml:space="preserve">
          <source>NumPy distutils supports automatic conversion of source files named &amp;lt;somefile&amp;gt;.src. This facility can be used to maintain very similar code blocks requiring only simple changes between blocks. During the build phase of setup, if a template file named &amp;lt;somefile&amp;gt;.src is encountered, a new file named &amp;lt;somefile&amp;gt; is constructed from the template and placed in the build directory to be used instead. Two forms of template conversion are supported. The first form occurs for files named &amp;lt;file&amp;gt;.ext.src where ext is a recognized Fortran extension (f, f90, f95, f77, for, ftn, pyf). The second form is used for all other cases. See &lt;a href=&quot;distutils_guide#templating&quot;&gt;Conversion of .src files using Templates&lt;/a&gt;.</source>
          <target state="translated">NumPy distutils支持自动转换名为&amp;lt;somefile&amp;gt; .src的源文件。此功能可用于维护非常相似的代码块，仅需在块之间进行简单更改即可。在安装程序的构建阶段，如果遇到名为&amp;lt;somefile&amp;gt; .src的模板文件，则将从模板中构建一个名为&amp;lt;somefile&amp;gt;的新文件，并将其放置在构建目录中以供使用。支持两种形式的模板转换。第一种形式出现在名为&amp;lt;file&amp;gt; .ext.src的文件中，其中ext是公认的Fortran扩展名（f，f90，f95，f77，用于ftn，pyf）。第二种形式用于所有其他情况。请参阅&lt;a href=&quot;distutils_guide#templating&quot;&gt;使用模板转换.src文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ec067cc97926d6f20fb73fa3184c126e233e754" translate="yes" xml:space="preserve">
          <source>NumPy does not provide a dtype with more precision than C&amp;rsquo;s &lt;code&gt;long double&lt;/code&gt;; in particular, the 128-bit IEEE quad precision data type (FORTRAN&amp;rsquo;s &lt;code&gt;REAL*16&lt;/code&gt;) is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5d51a5b62b750c1604f2d01dcf736580720f16" translate="yes" xml:space="preserve">
          <source>NumPy does not require any external linear algebra libraries to be installed. However, if these are available, NumPy&amp;rsquo;s setup script can detect them and use them for building. A number of different LAPACK library setups can be used, including optimized LAPACK libraries such as OpenBLAS or MKL. The choice and location of these libraries as well as include paths and other such build options can be specified in a &lt;code&gt;site.cfg&lt;/code&gt; file located in the NumPy root repository or a &lt;code&gt;.numpy-site.cfg&lt;/code&gt; file in your home directory. See the &lt;code&gt;site.cfg.example&lt;/code&gt; example file included in the NumPy repository or sdist for documentation, and below for specifying search priority from environmental variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a95170c1892d84e44be0593492dbf2a5886a93" translate="yes" xml:space="preserve">
          <source>NumPy doesn&amp;rsquo;t have a C function documentation standard at this time, but needs one. Most numpy functions are not documented in the code and that should change. One possibility is Doxygen with a plugin so that the same NumPy style used for Python functions can also be used for documenting C functions, see the files in doc/cdoc/.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d7988a962e51ca82f6767321b92e79ba1d8ec3" translate="yes" xml:space="preserve">
          <source>NumPy for Matlab users</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4cda8cf1f381ff8936b6e543e5a88f49fb98417" translate="yes" xml:space="preserve">
          <source>NumPy fully supports an object-oriented approach, starting, once again, with &lt;code&gt;ndarray&lt;/code&gt;. For example, &lt;code&gt;ndarray&lt;/code&gt; is a class, possessing numerous methods and attributes. Many of its methods are mirrored by functions in the outer-most NumPy namespace, allowing the programmer to code in whichever paradigm they prefer. This flexibility has allowed the NumPy array dialect and NumPy &lt;code&gt;ndarray&lt;/code&gt; class to become the &lt;em&gt;de-facto&lt;/em&gt; language of multi-dimensional data interchange used in Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4900e8d811971de762aa8ebe80dcd63c7e850d2e" translate="yes" xml:space="preserve">
          <source>NumPy functions now always support overrides with &lt;code&gt;__array_function__&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2f30850bdb0a0d23d96244e831d9063c220901" translate="yes" xml:space="preserve">
          <source>NumPy functions now support overrides with &lt;code&gt;__array_function__&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="832b7ee6576dfafa6af4c3707e511d8557196774" translate="yes" xml:space="preserve">
          <source>NumPy generally returns elements of arrays as array scalars (a scalar with an associated dtype). Array scalars differ from Python scalars, but for the most part they can be used interchangeably (the primary exception is for versions of Python older than v2.x, where integer array scalars cannot act as indices for lists and tuples). There are some exceptions, such as when code requires very specific attributes of a scalar or when it checks specifically whether a value is a Python scalar. Generally, problems are easily fixed by explicitly converting array scalars to Python scalars, using the corresponding Python type function (e.g., &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;complex&lt;/code&gt;, &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;unicode&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890be7939c4a57f24699a49e8b1d3523457ca863" translate="yes" xml:space="preserve">
          <source>NumPy gives us the best of both worlds: element-by-element operations are the &amp;ldquo;default mode&amp;rdquo; when an &lt;code&gt;ndarray&lt;/code&gt; is involved, but the element-by-element operation is speedily executed by pre-compiled C code. In NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e59636db0bed7b9eb085bfb86e99aa0957bc34" translate="yes" xml:space="preserve">
          <source>NumPy gives you an enormous range of fast and efficient ways of creating arrays and manipulating numerical data inside them. While a Python list can contain different data types within a single list, all of the elements in a NumPy array should be homogenous. The mathematical operations that are meant to be performed on arrays would be extremely inefficient if the arrays weren&amp;rsquo;t homogenous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce24f4bb69b1ac53e640f756f04696d112954c58" translate="yes" xml:space="preserve">
          <source>NumPy governance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33fab98fb581f98170a2f8d5e454b21a4a9ae970" translate="yes" xml:space="preserve">
          <source>NumPy has a Documentation Team. We have open meetings on Zoom every three weeks and invite everyone to join. Don&amp;rsquo;t hesitate to reach out if you have questions or just need someone to guide you through your first steps - we&amp;rsquo;re always happy to help. Meetings are usually announced on the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion mailing list&lt;/a&gt;. Meeting minutes are taken &lt;a href=&quot;https://hackmd.io/oB_boakvRqKR-_2jRV-Qjg&quot;&gt;on hackmd.io&lt;/a&gt; and stored in the &lt;a href=&quot;https://github.com/numpy/archive&quot;&gt;NumPy Archive repository&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1252a4902fb7242313c7e4fd534a4effe97cd036" translate="yes" xml:space="preserve">
          <source>NumPy has a few import-time, compile-time, or runtime options which change the global behaviour. Most of these are related to performance or for debugging purposes and will not be interesting to the vast majority of users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99117692035516c5cb720484aff4e4e585660600" translate="yes" xml:space="preserve">
          <source>NumPy has a set of rules for dealing with arrays that have differing shapes which are applied whenever functions take multiple operands which combine element-wise. This is called &lt;a href=&quot;ufuncs#ufuncs-broadcasting&quot;&gt;broadcasting&lt;/a&gt;. The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object can apply these rules for you when you need to write such a function.</source>
          <target state="translated">NumPy具有一组规则，用于处理形状不同的数组，只要函数采用多个按元素组合的操作数，就会应用这些规则。这称为&lt;a href=&quot;ufuncs#ufuncs-broadcasting&quot;&gt;广播&lt;/a&gt;。当您需要编写这样的函数时，&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;对象可以为您应用这些规则。</target>
        </trans-unit>
        <trans-unit id="333e27cc5487f69edc109f8bd0d8086fc2dbda03" translate="yes" xml:space="preserve">
          <source>NumPy has built-in functions for creating arrays from scratch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60168f40b56e28aca9cf44fb018703394a1b278b" translate="yes" xml:space="preserve">
          <source>NumPy has the following versioning scheme (numbers given are examples; they can be &amp;gt; 9) in principle):</source>
          <target state="translated">NumPy具有以下版本控制方案（给出的数字为示例；原则上可以为&amp;gt; 9）：</target>
        </trans-unit>
        <trans-unit id="79eee1716a93d0c26d644ba6dc16d49583d1dea3" translate="yes" xml:space="preserve">
          <source>NumPy includes several constants:</source>
          <target state="translated">NumPy包括几个常量。</target>
        </trans-unit>
        <trans-unit id="7f95e3acee5a2de64945dfe9e2cae9083154d9ea" translate="yes" xml:space="preserve">
          <source>NumPy internals</source>
          <target state="translated">NumPy的内部结构</target>
        </trans-unit>
        <trans-unit id="6dae93447071b4ec5703dcc87628e48329941095" translate="yes" xml:space="preserve">
          <source>NumPy is a community-owned and community-run project. To the maximum extent possible, decisions about project direction are made by community consensus (but note that &amp;ldquo;consensus&amp;rdquo; here has a somewhat technical meaning that might not match everyone&amp;rsquo;s expectations &amp;ndash; see below). Some members of the community additionally contribute by serving on the NumPy steering council, where they are responsible for facilitating the establishment of community consensus, for stewarding project resources, and &amp;ndash; in extreme cases &amp;ndash; for making project decisions if the normal community-based process breaks down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f4695ea1e6796c3681301e16dfcf7c8b735296" translate="yes" xml:space="preserve">
          <source>NumPy is a distributed, volunteer, open-source project. &lt;em&gt;You&lt;/em&gt; can help us make it better; if you believe something should be improved either in functionality or in documentation, don&amp;rsquo;t hesitate to contact us &amp;mdash; or even better, contact us and participate in fixing the problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991ba5f7e8a9558d2bf270584d8056914d9ad664" translate="yes" xml:space="preserve">
          <source>NumPy is a successor for two earlier scientific Python libraries: Numeric and Numarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0402fb92221bd3cd2c68208cc2865ddc5a180086" translate="yes" xml:space="preserve">
          <source>NumPy is based on Python, which was designed from the outset to be an excellent general-purpose programming language. While Matlab&amp;rsquo;s syntax for some array manipulations is more compact than NumPy&amp;rsquo;s, NumPy (by virtue of being an add-on to Python) can do many things that Matlab just cannot, for instance dealing properly with stacks of matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eab1c6f817d74852716edac9ada3c155fd78dc5" translate="yes" xml:space="preserve">
          <source>NumPy is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0da01ca615e98a9d3de5876bf011bc4feb765cc1" translate="yes" xml:space="preserve">
          <source>NumPy is the fundamental package needed for scientific computing with Python. This package contains:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0842da7a3c9a631b811fb55a0710af0d36229b7" translate="yes" xml:space="preserve">
          <source>NumPy itself is normally intentionally limited to a single thread during function calls, however it does support multiple Python threads running at the same time. Note that for performant linear algebra NumPy uses a BLAS backend such as OpenBLAS or MKL, which may use multiple threads that may be controlled by environment variables such as &lt;code&gt;OMP_NUM_THREADS&lt;/code&gt; depending on what is used. One way to control the number of threads is the package &lt;a href=&quot;https://pypi.org/project/threadpoolctl/&quot;&gt;threadpoolctl&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6c5b9ca35b73a4c5ad8cc11ecf764298cf0bacc" translate="yes" xml:space="preserve">
          <source>NumPy may be built with relaxed stride checking debugging</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e53e90e7b656a00b8ffca88bb6b89ffe64b4a95" translate="yes" xml:space="preserve">
          <source>NumPy numerical types are instances of &lt;code&gt;dtype&lt;/code&gt; (data-type) objects, each having unique characteristics. Once you have imported NumPy using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="385beaafbdefdbe97d289ec18bd9e262a0ed8458" translate="yes" xml:space="preserve">
          <source>NumPy offers more indexing facilities than regular Python sequences. In addition to indexing by integers and slices, as we saw before, arrays can be indexed by arrays of integers and arrays of booleans.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ac2c9d8a2fd7d4b8f16afdbb4951561e207021" translate="yes" xml:space="preserve">
          <source>NumPy operations are usually done on pairs of arrays on an element-by-element basis. In the simplest case, the two arrays must have exactly the same shape, as in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aab5ecc0999cd974eb3c7668641606fa9f4eb6b" translate="yes" xml:space="preserve">
          <source>NumPy project governance and decision-making</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344b2ccffdbc846784cb6ec3e6e0955c7148fb58" translate="yes" xml:space="preserve">
          <source>NumPy provides &lt;a href=&quot;../reference/generated/numpy.iinfo#numpy.iinfo&quot;&gt;&lt;code&gt;numpy.iinfo&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.finfo#numpy.finfo&quot;&gt;&lt;code&gt;numpy.finfo&lt;/code&gt;&lt;/a&gt; to verify the minimum or maximum values of NumPy integer and floating point values respectively</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b798355ee6b0ba0edb9030dee01599200313df" translate="yes" xml:space="preserve">
          <source>NumPy provides a C-API to enable users to extend the system and get access to the array object for use in other routines. The best way to truly understand the C-API is to read the source code. If you are unfamiliar with (C) source code, however, this can be a daunting experience at first. Be assured that the task becomes easier with practice, and you may be surprised at how simple the C-code can be to understand. Even if you don&amp;rsquo;t think you can write C-code from scratch, it is much easier to understand and modify already-written source code than create it &lt;em&gt;de novo&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8046368fea8bda3d4541728b814c2be74d1348d" translate="yes" xml:space="preserve">
          <source>NumPy provides a C-API to enable users to extend the system and get access to the array object for use in other routines. The best way to truly understand the C-API is to read the source code. If you are unfamiliar with (C) source code, however, this can be a daunting experience at first. Be assured that the task becomes easier with practice, and you may be surprised at how simple the C-code can be to understand. Even if you don&amp;rsquo;t think you can write C-code from scratch, it is much easier to understand and modify already-written source code then create it &lt;em&gt;de novo&lt;/em&gt;.</source>
          <target state="translated">NumPy提供了一个C-API，使用户能够扩展系统并获得对数组对象的访问权，以供其他例程使用。真正理解C-API的最好方法是阅读源代码。但是，如果您不熟悉（C）源代码，那么一开始可能会令人生畏。可以肯定的是，随着练习的进行，该任务将变得更加容易，并且您可能会对C代码的理解如此简单而感到惊讶。即使您认为您不能从头开始编写C代码，理解和修改已经编写的源代码也要&lt;em&gt;从头&lt;/em&gt;创建它要容易得多。</target>
        </trans-unit>
        <trans-unit id="93fc0aec43944a02522a3921ad457b6e9255c9c4" translate="yes" xml:space="preserve">
          <source>NumPy provides a convenience function called &lt;code&gt;ctypeslib.load_library&lt;/code&gt; (name, path). This function takes the name of the shared library (including any prefix like &amp;lsquo;lib&amp;rsquo; but excluding the extension) and a path where the shared library can be located. It returns a ctypes library object or raises an &lt;code&gt;OSError&lt;/code&gt; if the library cannot be found or raises an &lt;code&gt;ImportError&lt;/code&gt; if the ctypes module is not available. (Windows users: the ctypes library object loaded using &lt;code&gt;load_library&lt;/code&gt; is always loaded assuming cdecl calling convention. See the ctypes documentation under &lt;code&gt;ctypes.windll&lt;/code&gt; and/or &lt;code&gt;ctypes.oledll&lt;/code&gt; for ways to load libraries under other calling conventions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a7d5fdc3538cf929aee4c511ed8f06972767b8" translate="yes" xml:space="preserve">
          <source>NumPy provides an N-dimensional array type, the &lt;a href=&quot;arrays.ndarray#arrays-ndarray&quot;&gt;ndarray&lt;/a&gt;, which describes a collection of &amp;ldquo;items&amp;rdquo; of the same type. The items can be &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;indexed&lt;/a&gt; using for example N integers.</source>
          <target state="translated">NumPy提供了N维数组类型&lt;a href=&quot;arrays.ndarray#arrays-ndarray&quot;&gt;ndarray&lt;/a&gt;，它描述了相同类型的&amp;ldquo;项目&amp;rdquo;的集合。可以使用例如N个整数来&lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;索引&lt;/a&gt;项目。</target>
        </trans-unit>
        <trans-unit id="1a75765bb40779d587b945d346fd4f25656a32a8" translate="yes" xml:space="preserve">
          <source>NumPy provides enhanced distutils functionality to make it easier to build and install sub-packages, auto-generate code, and extension modules that use Fortran-compiled libraries. To use features of NumPy distutils, use the &lt;code&gt;setup&lt;/code&gt; command from &lt;code&gt;numpy.distutils.core&lt;/code&gt;. A useful &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; class is also provided in &lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt; that can make it easier to construct keyword arguments to pass to the setup function (by passing the dictionary obtained from the todict() method of the class). More information is available in the &lt;a href=&quot;distutils_guide#distutils-user-guide&quot;&gt;NumPy Distutils - Users Guide&lt;/a&gt;.</source>
          <target state="translated">NumPy提供了增强的distutils功能，可以更轻松地构建和安装使用Fortran编译库的子程序包，自动生成代码和扩展模块。要使用NumPy distutils的功能，请使用 &lt;code&gt;numpy.distutils.core&lt;/code&gt; 中的 &lt;code&gt;setup&lt;/code&gt; 命令。&lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt; &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; &lt;/a&gt;中还提供了一个有用的&lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt; &lt;code&gt;Configuration&lt;/code&gt; &lt;/a&gt;类，该类可以使构造关键字参数更容易地传递给设置函数（通过传递从该类的todict（）方法获得的字典）。&lt;a href=&quot;distutils_guide#distutils-user-guide&quot;&gt;NumPy Distutils-用户指南中&lt;/a&gt;提供了更多信息。</target>
        </trans-unit>
        <trans-unit id="dc45b2b061a3c987c044eb3531af83d969814354" translate="yes" xml:space="preserve">
          <source>NumPy provides enhanced distutils functionality to make it easier to build and install sub-packages, auto-generate code, and extension modules that use Fortran-compiled libraries. To use features of NumPy distutils, use the &lt;code&gt;setup&lt;/code&gt; command from &lt;code&gt;numpy.distutils.core&lt;/code&gt;. A useful &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; class is also provided in &lt;a href=&quot;distutils/misc_util#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt; that can make it easier to construct keyword arguments to pass to the setup function (by passing the dictionary obtained from the todict() method of the class). More information is available in the &lt;a href=&quot;distutils_guide#distutils-user-guide&quot;&gt;NumPy Distutils - Users Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a083cfd3cae0f2b0c71ffa2d89ecb4205930693" translate="yes" xml:space="preserve">
          <source>NumPy provides familiar mathematical functions such as sin, cos, and exp. In NumPy, these are called &amp;ldquo;universal functions&amp;rdquo;(&lt;code&gt;ufunc&lt;/code&gt;). Within NumPy, these functions operate elementwise on an array, producing an array as output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a62542984876095dd49786ce30743b4af981559" translate="yes" xml:space="preserve">
          <source>NumPy provides several functions to create arrays from tabular data. We focus here on the &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23cd70d7e4f84112d992fc760c41c139b7d9150b" translate="yes" xml:space="preserve">
          <source>NumPy provides several hooks that classes can customize:</source>
          <target state="translated">NumPy提供了几个可以自定义类的钩子。</target>
        </trans-unit>
        <trans-unit id="db997f8d5529d90e4e824067ebfe5d83669d3578" translate="yes" xml:space="preserve">
          <source>NumPy provides the &lt;a href=&quot;generated/numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;recarray&lt;/code&gt;&lt;/a&gt; class which allows accessing the fields of a structured array as attributes, and a corresponding scalar data type object &lt;a href=&quot;generated/numpy.record#numpy.record&quot;&gt;&lt;code&gt;record&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPy提供了&lt;a href=&quot;generated/numpy.recarray#numpy.recarray&quot;&gt; &lt;code&gt;recarray&lt;/code&gt; &lt;/a&gt;类，该类允许将结构化数组的字段作为属性访问，并提供相应的标量数据类型对象&lt;a href=&quot;generated/numpy.record#numpy.record&quot;&gt; &lt;code&gt;record&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2334ad60fc95510fca18811e881286378efc5596" translate="yes" xml:space="preserve">
          <source>NumPy refers to each dimension as an &lt;code&gt;axis&lt;/code&gt;. Because of how &lt;code&gt;imread&lt;/code&gt; works, the &lt;em&gt;first index in the 3rd axis&lt;/em&gt; is the red pixel data for our image. We can access this by using the syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaeae0e0ef5087fb1cba7dbba1eef7ee4ab1c725" translate="yes" xml:space="preserve">
          <source>NumPy searches for optimized linear algebra libraries such as BLAS and LAPACK. There are specific orders for searching these libraries, as described below and in the &lt;code&gt;site.cfg.example&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0ea34766b2df6ce15b555bccc153c9453e468d7" translate="yes" xml:space="preserve">
          <source>NumPy slicing creates a &lt;a href=&quot;../glossary#term-view&quot;&gt;view&lt;/a&gt; instead of a copy as in the case of builtin Python sequences such as string, tuple and list. Care must be taken when extracting a small portion from a large array which becomes useless after the extraction, because the small portion extracted contains a reference to the large original array whose memory will not be released until all arrays derived from it are garbage-collected. In such cases an explicit &lt;code&gt;copy()&lt;/code&gt; is recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50bd9e44504ee882f7d36e3a1a29183cd10ae09" translate="yes" xml:space="preserve">
          <source>NumPy slicing creates a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;view&lt;/a&gt; instead of a copy as in the case of builtin Python sequences such as string, tuple and list. Care must be taken when extracting a small portion from a large array which becomes useless after the extraction, because the small portion extracted contains a reference to the large original array whose memory will not be released until all arrays derived from it are garbage-collected. In such cases an explicit &lt;code&gt;copy()&lt;/code&gt; is recommended.</source>
          <target state="translated">NumPy切片会创建&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;视图，&lt;/a&gt;而不是像内置Python序列（例如字符串，元组和列表）那样复制副本。从大型数组中提取一小部分时必须小心，提取后变得无用，因为提取的一小部分包含对大型原始数组的引用，该原始数组的内存只有在从其派生的所有数组被垃圾回收之前才会释放。在这种情况下，建议使用显式的 &lt;code&gt;copy()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9315eaa766c603c7ff5592ed435945f3c4e579c8" translate="yes" xml:space="preserve">
          <source>NumPy stores an internal table of Python callable objects that are used to implement arithmetic operations for arrays as well as certain array calculation methods. This function allows the user to replace any or all of these Python objects with their own versions. The keys of the dictionary, &lt;em&gt;dict&lt;/em&gt;, are the named functions to replace and the paired value is the Python callable object to use. Care should be taken that the function used to replace an internal array operation does not itself call back to that internal array operation (unless you have designed the function to handle that), or an unchecked infinite recursion can result (possibly causing program crash). The key names that represent operations that can be replaced are:</source>
          <target state="translated">NumPy存储Python可调用对象的内部表，该表可用于对数组以及某些数组计算方法实施算术运算。此功能允许用户用自己的版本替换任何或所有这些Python对象。字典的键&lt;em&gt;dict&lt;/em&gt;是要替换的命名函数，而配对的值是要使用的Python可调用对象。请注意，用于替换内部数组操作的函数本身不会回调该内部数组操作（除非您已设计了处理该函数的函数），否则可能会导致未经检查的无限递归（可能导致程序崩溃）。代表可以替换的操作的键名是：</target>
        </trans-unit>
        <trans-unit id="e0ffae4d5e74817321bd554d6e22d7ad10db9e4c" translate="yes" xml:space="preserve">
          <source>NumPy supports PEP 3141 numbers:</source>
          <target state="translated">NumPy支持PEP 3141号码。</target>
        </trans-unit>
        <trans-unit id="a30e09b28bd3a22ee136145ff9e9655f237427ce" translate="yes" xml:space="preserve">
          <source>NumPy supports a much greater variety of numerical types than Python does. This section shows which are available, and how to modify an array&amp;rsquo;s data-type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233a312424d8a0ad1356c1a0f6d65ae323b75b8a" translate="yes" xml:space="preserve">
          <source>NumPy understands that the multiplication should happen with each cell. That concept is called &lt;strong&gt;broadcasting&lt;/strong&gt;. Broadcasting is a mechanism that allows NumPy to perform operations on arrays of different shapes. The dimensions of your array must be compatible, for example, when the dimensions of both arrays are equal or when one of them is 1. If the dimensions are not compatible, you will get a &lt;code&gt;ValueError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9253086c7c4965c63bda0ce6993cc9b981baa4c" translate="yes" xml:space="preserve">
          <source>NumPy uses a series of tests to probe the compiler and libc libraries for funtions. The results are stored in &lt;code&gt;_numpyconfig.h&lt;/code&gt; and &lt;code&gt;config.h&lt;/code&gt; files using &lt;code&gt;HAVE_XXX&lt;/code&gt; definitions. These tests are run during the &lt;code&gt;build_src&lt;/code&gt; phase of the &lt;code&gt;_multiarray_umath&lt;/code&gt; module in the &lt;code&gt;generate_config_h&lt;/code&gt; and &lt;code&gt;generate_numpyconfig_h&lt;/code&gt; functions. Since the output of these calls includes many compiler warnings and errors, by default it is run quietly. If you wish to see this output, you can run the &lt;code&gt;build_src&lt;/code&gt; stage verbosely:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7fbc5d580827f690776ae9fde2ddf99b3716968" translate="yes" xml:space="preserve">
          <source>NumPy uses both methods with a preference for the second method because it can be safer. The ctypes attribute of the ndarray returns an object that has an &lt;code&gt;_as_parameter_&lt;/code&gt; attribute which returns an integer representing the address of the ndarray to which it is associated. As a result, one can pass this ctypes attribute object directly to a function expecting a pointer to the data in your ndarray. The caller must be sure that the ndarray object is of the correct type, shape, and has the correct flags set or risk nasty crashes if the data-pointer to inappropriate arrays are passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fddaf9c91d8d4012f023752f68ed0149bce87d6e" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754).</source>
          <target state="translated">NumPy使用IEEE标准的二进制浮点运算(IEEE 754)。</target>
        </trans-unit>
        <trans-unit id="8667558f0f51c03b2587a599efedda1f9f4468ac" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). Negative zero is considered to be a finite number.</source>
          <target state="translated">NumPy使用IEEE标准的二进制浮点运算(IEEE 754)。负零被认为是一个有限的数字。</target>
        </trans-unit>
        <trans-unit id="d23202e89199272fb59380a61ef4cc7654a36b65" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). Positive zero is considered to be a finite number.</source>
          <target state="translated">NumPy使用IEEE标准的二进制浮点运算(IEEE 754)。正零被认为是一个有限的数字。</target>
        </trans-unit>
        <trans-unit id="f42533d92c39de593371e6aa3dde32696064d2b8" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity.</source>
          <target state="translated">NumPy使用IEEE标准的二进制浮点运算(IEEE 754)。这意味着Not a Number不等于无穷大。</target>
        </trans-unit>
        <trans-unit id="af1c83a08aa63e00fff2b45b2f860192ca21bcf1" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. Also that positive infinity is not equivalent to negative infinity. But infinity is equivalent to positive infinity.</source>
          <target state="translated">NumPy使用IEEE标准的二进制浮点运算(IEEE 754)。这意味着Not a Number不等同于无穷大。同时,正无穷也不等同于负无穷。但无穷大等于正无穷大。</target>
        </trans-unit>
        <trans-unit id="389fed054ec853b5b8bb20d440426bf9262e8e46" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. Also that positive infinity is not equivalent to negative infinity. But infinity is equivalent to positive infinity. Errors result if the second argument is also supplied when &lt;code&gt;x&lt;/code&gt; is a scalar input, or if first and second arguments have different shapes.</source>
          <target state="translated">NumPy使用IEEE标准算术二进制浮点（IEEE 754）。这意味着非数字不等于无穷大。同样，正无穷不等于负无穷。但是无穷大等于正无穷大。如果在 &lt;code&gt;x&lt;/code&gt; 是标量输入时也提供第二个参数，或者如果第一个和第二个参数具有不同的形状，则会导致错误。</target>
        </trans-unit>
        <trans-unit id="35a6249b4224925e0bdcfa0f8624c08fcc4790ef" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. Positive infinity is treated as a very large number and negative infinity is treated as a very small (i.e. negative) number.</source>
          <target state="translated">NumPy使用IEEE标准的二进制浮点运算(IEEE 754)。这意味着Not a Number不等同于无穷大。正无穷是作为一个非常大的数,而负无穷是作为一个非常小的数(即负数)。</target>
        </trans-unit>
        <trans-unit id="4026f26ee4d1cd9de2a496e4e3dd03a3e5a7f962" translate="yes" xml:space="preserve">
          <source>NumPy v1.19 Manual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ea0a36ef00ca34de0c91ee7b58a561c1bb0550a" translate="yes" xml:space="preserve">
          <source>NumPy version comparison</source>
          <target state="translated">NumPy版本比较</target>
        </trans-unit>
        <trans-unit id="8ba9f463515e23b0f299b2ffc9d54837e3d43200" translate="yes" xml:space="preserve">
          <source>NumPy version string (&lt;code&gt;np.__version__&lt;/code&gt;).</source>
          <target state="translated">NumPy版本字符串（ &lt;code&gt;np.__version__&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9b3a90b67fc6e7751631f73fbd200fedcaf6517b" translate="yes" xml:space="preserve">
          <source>NumPy will gather implementations of &lt;code&gt;__array_function__&lt;/code&gt; from all specified inputs and call them in order: subclasses before superclasses, and otherwise left to right. Note that in some edge cases involving subclasses, this differs slightly from the &lt;a href=&quot;https://bugs.python.org/issue30140&quot;&gt;current behavior&lt;/a&gt; of Python.</source>
          <target state="translated">NumPy 将从所有指定的输入中收集 &lt;code&gt;__array_function__&lt;/code&gt; 的实现，并按以下顺序调用它们：子类在超类之前，否则从左到右。请注意，在某些涉及子类的极端情况下，这与Python 的&lt;a href=&quot;https://bugs.python.org/issue30140&quot;&gt;当前行为&lt;/a&gt;略有不同。</target>
        </trans-unit>
        <trans-unit id="2fb311f19fa41c253fcda50763e8cfca7eec45cb" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s &lt;code&gt;np.flip()&lt;/code&gt; function allows you to flip, or reverse, the contents of an array along an axis. When using &lt;code&gt;np.flip&lt;/code&gt;, specify the array you would like to reverse and the axis. If you don&amp;rsquo;t specify the axis, NumPy will reverse the contents along all of the axes of your input array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b39796df6889956cc3b3ff1db77e20497876b0e" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c194038698da06d4deba03ca0f701303ee7a9e" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s array class is called &lt;code&gt;ndarray&lt;/code&gt;. It is also known by the alias &lt;code&gt;array&lt;/code&gt;. Note that &lt;code&gt;numpy.array&lt;/code&gt; is not the same as the Standard Python Library class &lt;code&gt;array.array&lt;/code&gt;, which only handles one-dimensional arrays and offers less functionality. The more important attributes of an &lt;code&gt;ndarray&lt;/code&gt; object are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0132beeeb0b4ce70a8210a70bdb9c78c481e563b" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s broadcasting rule relaxes this constraint when the arrays&amp;rsquo; shapes meet certain constraints. The simplest broadcasting example occurs when an array and a scalar value are combined in an operation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6e87a1254c0e2518a18db62672d9b8b4222aec" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s documentation uses several custom extensions to Sphinx. These are shipped in the &lt;code&gt;sphinxext/&lt;/code&gt; directory (as git submodules, as discussed above), and are automatically enabled when building NumPy&amp;rsquo;s documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a23df3dc68bb04fcd72ce4a7accb7a59c107ed5" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s main object is the homogeneous multidimensional array. It is a table of elements (usually numbers), all of the same type, indexed by a tuple of non-negative integers. In NumPy dimensions are called &lt;em&gt;axes&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e72e3b2d20e9ce05fa10cf5b67fd4a5d867f2b5" translate="yes" xml:space="preserve">
          <source>NumPy, &lt;a href=&quot;http://www.scipy.org&quot;&gt;SciPy&lt;/a&gt;, and the scikits follow a common convention for docstrings that provides for consistency, while also allowing our toolchain to produce well-formatted reference guides. This document describes the current community consensus for such a standard. If you have suggestions for improvements, post them on the &lt;a href=&quot;http://scipy.org/scipylib/mailing-lists.html&quot;&gt;numpy-discussion list&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65980c8f8cdaffbdb9dc6b41c004c578cf994ed4" translate="yes" xml:space="preserve">
          <source>NumPy, or rather Python, has similar facilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b99044d84c351a4ed63efec49bbe1ae3bf320ae" translate="yes" xml:space="preserve">
          <source>NumPy-specific help functions</source>
          <target state="translated">NumPy特有的帮助功能</target>
        </trans-unit>
        <trans-unit id="8e5883940f8591fc18bd2d38714b4441d0bc3808" translate="yes" xml:space="preserve">
          <source>NumPy-specific workflow is in &lt;a href=&quot;development_workflow#development-workflow&quot;&gt;numpy-development-workflow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61e66899eea7ee7ff7294019b3070d639ae0728" translate="yes" xml:space="preserve">
          <source>NumPy: the absolute basics for beginners</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f40cf39f0e25d8cf6f052959da2085155ae248" translate="yes" xml:space="preserve">
          <source>Numba</source>
          <target state="translated">Numba</target>
        </trans-unit>
        <trans-unit id="2ad094bf2eb6f204e2abae88bcc155073c5a7b5d" translate="yes" xml:space="preserve">
          <source>Numba can be used with either CTypes or CFFI. The current iteration of the BitGenerators all export a small set of functions through both interfaces.</source>
          <target state="translated">Numba可以和CTypes或者CFFI一起使用。目前迭代的BitGenerators都通过这两个接口导出了一小套函数。</target>
        </trans-unit>
        <trans-unit id="858e21b5a976ec86aff538495ea9c4f65e263a29" translate="yes" xml:space="preserve">
          <source>Number of &amp;lsquo;guard digits&amp;rsquo; used when truncating the product of two mantissas to fit the representation.</source>
          <target state="translated">截尾两个尾数的乘积以适合表示形式时使用的&amp;ldquo;保护位数&amp;rdquo;数。</target>
        </trans-unit>
        <trans-unit id="bbf91dba201dcc9eece0dc41a5e6c527d91e56cf" translate="yes" xml:space="preserve">
          <source>Number of Threads used for Linear Algebra</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be768826cc42fcf995f3aef93d52ff0cd53e9ae" translate="yes" xml:space="preserve">
          <source>Number of array dimensions.</source>
          <target state="translated">阵列维数。</target>
        </trans-unit>
        <trans-unit id="a97fad0d0844aff9a71f23c56eb56e01fb752db2" translate="yes" xml:space="preserve">
          <source>Number of array items in summary at beginning and end of each dimension (default 3).</source>
          <target state="translated">在每个维度的开头和结尾处的数组项目的数量(默认为3)。</target>
        </trans-unit>
        <trans-unit id="9201c088075dba2ae62f215d4d2fdd9a8a777253" translate="yes" xml:space="preserve">
          <source>Number of array items in summary at beginning and end of each dimension. Defaults to &lt;code&gt;numpy.get_printoptions()['edgeitems']&lt;/code&gt;.</source>
          <target state="translated">每个维度的开始和结束处摘要中的数组项目数。默认为 &lt;code&gt;numpy.get_printoptions()['edgeitems']&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4574e45463a4337cd6208d1b13e93be562f45874" translate="yes" xml:space="preserve">
          <source>Number of base-&lt;code&gt;ibeta&lt;/code&gt; digits in the floating point mantissa M.</source>
          <target state="translated">浮点数尾数M中的基 &lt;code&gt;ibeta&lt;/code&gt; 位数。</target>
        </trans-unit>
        <trans-unit id="3ada3f66dbd1b40b353be9a0f81e475922b90cd9" translate="yes" xml:space="preserve">
          <source>Number of bits in data types</source>
          <target state="translated">数据类型中的位数</target>
        </trans-unit>
        <trans-unit id="f0e91946bba240191d8f8b60627edef4c8d6081d" translate="yes" xml:space="preserve">
          <source>Number of bits in the exponent (including its sign and bias).</source>
          <target state="translated">指数中的位数(包括其符号和偏差)。</target>
        </trans-unit>
        <trans-unit id="3a305056bc0be0ed46faf9a5c4020bd05011c494" translate="yes" xml:space="preserve">
          <source>Number of bits to remove at the right of &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">在 &lt;code&gt;x1&lt;/code&gt; 右边要删除的位数。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="bcd1696318c5332018bcf91295a29c11afe64192" translate="yes" xml:space="preserve">
          <source>Number of bytes to skip before beginning the element view.</source>
          <target state="translated">开始元素视图前要跳过的字节数。</target>
        </trans-unit>
        <trans-unit id="2bd38d497915bde99690ede2a81fd5739730552b" translate="yes" xml:space="preserve">
          <source>Number of columns in the array. By default, &lt;code&gt;M&lt;/code&gt; is taken equal to &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">数组中的列数。默认情况下， &lt;code&gt;M&lt;/code&gt; 被取等于 &lt;code&gt;N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27e78e98de656ac1f174b228b3b3cfaba70b125d" translate="yes" xml:space="preserve">
          <source>Number of columns in the output, defaults to &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">输出中的列数，默认为 &lt;code&gt;n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00044a0ba0541a7997dd2599a4f9b91182edde55" translate="yes" xml:space="preserve">
          <source>Number of columns in the output. If &lt;code&gt;N&lt;/code&gt; is not specified, a square array is returned (&lt;code&gt;N = len(x)&lt;/code&gt;).</source>
          <target state="translated">输出中的列数。如果未指定 &lt;code&gt;N&lt;/code&gt; ，则返回一个正方形数组（ &lt;code&gt;N = len(x)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a06d5e776ba9dffd0e77cd97b2c7b86bb26acb1a" translate="yes" xml:space="preserve">
          <source>Number of columns in the output. If None, defaults to &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">输出中的列数。如果无，默认为 &lt;code&gt;N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0217140ca3d5b8f088751040a1594d26b45a1b44" translate="yes" xml:space="preserve">
          <source>Number of compounding periods</source>
          <target state="translated">复利期数</target>
        </trans-unit>
        <trans-unit id="97af9143d62e7223493889f6bc88440f1ed78209" translate="yes" xml:space="preserve">
          <source>Number of core dimensions of each argument</source>
          <target state="translated">每个论点的核心维度数量</target>
        </trans-unit>
        <trans-unit id="33246fa87d0b3d8cf0cd33d590270d0d5b8977dd" translate="yes" xml:space="preserve">
          <source>Number of decimal places to round to (default: 0). If decimals is negative, it specifies the number of positions to the left of the decimal point.</source>
          <target state="translated">四舍五入的小数位数(默认:0)。如果小数为负数,则指定小数点左边的位数。</target>
        </trans-unit>
        <trans-unit id="6d7f7a5c3f27de2bb3c70596c0f42aef8c17be9e" translate="yes" xml:space="preserve">
          <source>Number of decimals to round to. May be negative.</source>
          <target state="translated">四舍五入的小数。可以是负数。</target>
        </trans-unit>
        <trans-unit id="d0f39eca925aa79a0a6c1e41a38d8c60caef28f9" translate="yes" xml:space="preserve">
          <source>Number of degrees of freedom, must be &amp;gt; 0.</source>
          <target state="translated">自由度数，必须&amp;gt; 0。</target>
        </trans-unit>
        <trans-unit id="947cb948510d628b02b33a2e4f5d937c49f48f16" translate="yes" xml:space="preserve">
          <source>Number of derivatives taken, must be non-negative. (Default: 1)</source>
          <target state="translated">所取的导数,必须为非负数。(默认值:1)</target>
        </trans-unit>
        <trans-unit id="97245ef113e26038c737c690b9b01b48fa8ebd7e" translate="yes" xml:space="preserve">
          <source>Number of digits of precision for floating point output (default 8). May be &lt;code&gt;None&lt;/code&gt; if &lt;code&gt;floatmode&lt;/code&gt; is not &lt;code&gt;fixed&lt;/code&gt;, to print as many digits as necessary to uniquely specify the value.</source>
          <target state="translated">浮点输出的精度位数（默认为8）。如果 &lt;code&gt;floatmode&lt;/code&gt; 不 &lt;code&gt;fixed&lt;/code&gt; ，则可能为 &lt;code&gt;None&lt;/code&gt; ，以打印必要的位数以唯一地指定该值。</target>
        </trans-unit>
        <trans-unit id="f527b9aa37b022d773444c86018ada827757d9b4" translate="yes" xml:space="preserve">
          <source>Number of digits of precision for floating point output (default 8). May be None if &lt;code&gt;floatmode&lt;/code&gt; is not &lt;code&gt;fixed&lt;/code&gt;, to print as many digits as necessary to uniquely specify the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d97ec2f2e677c40d4431d2275107bedf5755ab8" translate="yes" xml:space="preserve">
          <source>Number of dimensions of broadcasted result.</source>
          <target state="translated">播出结果的维度数。</target>
        </trans-unit>
        <trans-unit id="e3508cd09f84a8328fcc45ebfc715b277ccf9575" translate="yes" xml:space="preserve">
          <source>Number of dimensions of broadcasted result. Alias for &lt;a href=&quot;numpy.broadcast.nd#numpy.broadcast.nd&quot;&gt;&lt;code&gt;nd&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">广播结果的维数。&lt;a href=&quot;numpy.broadcast.nd#numpy.broadcast.nd&quot;&gt; &lt;code&gt;nd&lt;/code&gt; 的&lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="f2d295ce1b14b658fe281bd20aab41d9aab0b616" translate="yes" xml:space="preserve">
          <source>Number of dimensions of broadcasted result. For code intended for NumPy 1.12.0 and later the more consistent &lt;a href=&quot;numpy.broadcast.ndim#numpy.broadcast.ndim&quot;&gt;&lt;code&gt;ndim&lt;/code&gt;&lt;/a&gt; is preferred.</source>
          <target state="translated">广播结果的维数。对于打算用于NumPy 1.12.0及更高版本的代码，首选更一致的&lt;a href=&quot;numpy.broadcast.ndim#numpy.broadcast.ndim&quot;&gt; &lt;code&gt;ndim&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b135521e22bf0efd0692b304dc2944b4be1550dd" translate="yes" xml:space="preserve">
          <source>Number of dimensions of the sub-array if this data type describes a sub-array, and &lt;code&gt;0&lt;/code&gt; otherwise.</source>
          <target state="translated">如果此数据类型描述子数组，则子数组的维数，否则为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19ea598f5fd4c1ee639980fee9928d5377e30cf8" translate="yes" xml:space="preserve">
          <source>Number of distinct core dimension names in the signature</source>
          <target state="translated">签字中不同核心维度名称的数量</target>
        </trans-unit>
        <trans-unit id="30b78d11ec827a9cb1ca1519eabc00a62b47ac43" translate="yes" xml:space="preserve">
          <source>Number of draws to advance the RNG. Must be less than the size state variable in the underlying RNG.</source>
          <target state="translated">推进RNG的抽签次数。必须小于底层RNG的大小状态变量。</target>
        </trans-unit>
        <trans-unit id="70e37b72989cb2f41b3fc9d963c59f76fe6543ba" translate="yes" xml:space="preserve">
          <source>Number of elements along the specified axis.</source>
          <target state="translated">沿着指定轴线的元素数量。</target>
        </trans-unit>
        <trans-unit id="807011d441713287a8ad8dac9e44680a221be633" translate="yes" xml:space="preserve">
          <source>Number of elements in the array.</source>
          <target state="translated">数组中元素的数量。</target>
        </trans-unit>
        <trans-unit id="9dd78b22d2ed99e0d773b0892f1882002390793b" translate="yes" xml:space="preserve">
          <source>Number of experiments.</source>
          <target state="translated">实验次数:</target>
        </trans-unit>
        <trans-unit id="f483027559825fca9bfa4da6e5eb78910571331a" translate="yes" xml:space="preserve">
          <source>Number of first indices that are involved in the inverse sum. Must be a positive integer, default is 2.</source>
          <target state="translated">参与反和的第一个指数的数量。必须是正整数,默认为2。</target>
        </trans-unit>
        <trans-unit id="b1779d0462b8633175ab393ef9880942bb660fa7" translate="yes" xml:space="preserve">
          <source>Number of items sampled. Must be at least 1 and at most &lt;code&gt;ngood + nbad&lt;/code&gt;.</source>
          <target state="translated">抽样的项目数。必须至少为1，最大为 &lt;code&gt;ngood + nbad&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eafdf0d454dc2aa43f8a71aaefeb0feceae0766e" translate="yes" xml:space="preserve">
          <source>Number of items sampled. Must be nonnegative and less than &lt;code&gt;ngood + nbad&lt;/code&gt;.</source>
          <target state="translated">抽样的项目数。必须为非负且小于 &lt;code&gt;ngood + nbad&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="897014b016e872c41c97ea0a9d1726a5e3c782d9" translate="yes" xml:space="preserve">
          <source>Number of items to read. &lt;code&gt;-1&lt;/code&gt; means all data in the buffer.</source>
          <target state="translated">要读取的项目数。 &lt;code&gt;-1&lt;/code&gt; 表示缓冲区中的所有数据。</target>
        </trans-unit>
        <trans-unit id="b39ddea78956da2963bde4fd3e57272e8d0acb35" translate="yes" xml:space="preserve">
          <source>Number of items to read. &lt;code&gt;-1&lt;/code&gt; means all items (i.e., the complete file).</source>
          <target state="translated">要读取的项目数。 &lt;code&gt;-1&lt;/code&gt; 表示所有项目（即完整文件）。</target>
        </trans-unit>
        <trans-unit id="166e4814f7850463b72419995efff990410c931d" translate="yes" xml:space="preserve">
          <source>Number of iterators possessed by the broadcasted result.</source>
          <target state="translated">广播结果所拥有的迭代器数量。</target>
        </trans-unit>
        <trans-unit id="4211a9fc555cfccd24b355f573ae3f8ff77483ef" translate="yes" xml:space="preserve">
          <source>Number of non-zero values in the array along a given axis. Otherwise, the total number of non-zero values in the array is returned.</source>
          <target state="translated">数组中沿给定轴线的非零值的数量,否则返回数组中非零值的总数。否则,将返回数组中非零值的总数。</target>
        </trans-unit>
        <trans-unit id="10474dca8982c65317e69ff33c6161fee40334b7" translate="yes" xml:space="preserve">
          <source>Number of point pairs to return. The default value is 100.</source>
          <target state="translated">要返回的点对数量。默认值是100。</target>
        </trans-unit>
        <trans-unit id="551051df538e93f92abd0e4d70bab9ebd0a9979c" translate="yes" xml:space="preserve">
          <source>Number of points along transformation axis in the input to use. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used.</source>
          <target state="translated">要使用的输入中沿变换轴的点数。如果 &lt;code&gt;n&lt;/code&gt; 小于输入的长度，则裁剪输入。如果较大，则输入将填充零。如果未指定 &lt;code&gt;n&lt;/code&gt; ，则使用输入沿由axis指定的 &lt;code&gt;axis&lt;/code&gt; 长度。</target>
        </trans-unit>
        <trans-unit id="1f1a0e92249dd7ea05411a06963194533d7918c7" translate="yes" xml:space="preserve">
          <source>Number of points in the output window. If zero or less, an empty array is returned.</source>
          <target state="translated">输出窗口中的点的数量。如果为零或更少,则返回一个空数组。</target>
        </trans-unit>
        <trans-unit id="79e81bd3a9cf8f13e4e087ed6b9ef489d7061b0e" translate="yes" xml:space="preserve">
          <source>Number of random bytes.</source>
          <target state="translated">随机字节数。</target>
        </trans-unit>
        <trans-unit id="53975b0c071abdcd5131d1862834f5b08e87e264" translate="yes" xml:space="preserve">
          <source>Number of rows (and columns) in &lt;code&gt;n&lt;/code&gt; x &lt;code&gt;n&lt;/code&gt; output.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; x &lt;code&gt;n&lt;/code&gt; 输出中的行（和列）数。</target>
        </trans-unit>
        <trans-unit id="ba04adb79f4c3bf3f6caa8c01f8f929a74cbf8dc" translate="yes" xml:space="preserve">
          <source>Number of rows in the array.</source>
          <target state="translated">阵列中的行数。</target>
        </trans-unit>
        <trans-unit id="9371726ac94e49726635264017eacaef06541bb1" translate="yes" xml:space="preserve">
          <source>Number of rows in the output.</source>
          <target state="translated">输出中的行数。</target>
        </trans-unit>
        <trans-unit id="89c00ebdcc34147d25718afd7dbd46f5e2d21937" translate="yes" xml:space="preserve">
          <source>Number of sample points and weights. It must be &amp;gt;= 1.</source>
          <target state="translated">采样点数和权重。它必须&amp;gt; = 1。</target>
        </trans-unit>
        <trans-unit id="394bbce360690b00428b0808fa6c2c7bc474b75c" translate="yes" xml:space="preserve">
          <source>Number of sample points desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f13e51c56d80088f553a736484516fc0a17451a" translate="yes" xml:space="preserve">
          <source>Number of samples to generate. Default is 50.</source>
          <target state="translated">要生成的样本数量。默认为50。</target>
        </trans-unit>
        <trans-unit id="b944ba1a6a786da2de285aee44ef64df7a0334c1" translate="yes" xml:space="preserve">
          <source>Number of samples to generate. Default is 50. Must be non-negative.</source>
          <target state="translated">要生成的样本数量。默认值是50。必须为非负数。</target>
        </trans-unit>
        <trans-unit id="b8477012cd08123303aba533415512dffd6caae6" translate="yes" xml:space="preserve">
          <source>Number of times the array is rotated by 90 degrees.</source>
          <target state="translated">阵列旋转90度的次数。</target>
        </trans-unit>
        <trans-unit id="43c5f5739f871a7eba2351b02c5057ed709b7574" translate="yes" xml:space="preserve">
          <source>Number of times to jump the state of the bit generator returned</source>
          <target state="translated">返回位发生器状态的跳转次数。</target>
        </trans-unit>
        <trans-unit id="612ea9a9fedd365d5dfed6db5fa33a0bb992e5bc" translate="yes" xml:space="preserve">
          <source>Number of values padded to the edges of each axis. ((before_1, after_1), &amp;hellip; (before_N, after_N)) unique pad widths for each axis. ((before, after),) yields same before and after pad for each axis. (pad,) or int is a shortcut for before = after = pad width for all axes.</source>
          <target state="translated">填充到每个轴边缘的值的数量。（（before_1，after_1），&amp;hellip;（before_N，after_N））每个轴的唯一焊盘宽度。（（before，after），）对于每个轴在pad之前和之后产生相同的结果。（pad）或int是所有轴前=后=垫宽度的快捷方式。</target>
        </trans-unit>
        <trans-unit id="21f1fbd39c40968c76006276fee34189d50015b9" translate="yes" xml:space="preserve">
          <source>Number of ways to make a bad selection. Must be nonnegative and less than 10**9.</source>
          <target state="translated">劣选方式的数量。必须是非负数且小于10**9。</target>
        </trans-unit>
        <trans-unit id="4fbe2e90660c2e70b194a26e014711298205f94b" translate="yes" xml:space="preserve">
          <source>Number of ways to make a bad selection. Must be nonnegative.</source>
          <target state="translated">做出错误选择的方式数量。必须为非负数。</target>
        </trans-unit>
        <trans-unit id="3f0216b57e4ddf8587c6f571d9e2b9562f1ca140" translate="yes" xml:space="preserve">
          <source>Number of ways to make a good selection. Must be nonnegative and less than 10**9.</source>
          <target state="translated">好的选择方式的数量。必须是非负数且小于10**9。</target>
        </trans-unit>
        <trans-unit id="e7a90f9a528b46c6111a9dd205b3c9485855546b" translate="yes" xml:space="preserve">
          <source>Number of ways to make a good selection. Must be nonnegative.</source>
          <target state="translated">做好选择的方法数量。必须为非负数。</target>
        </trans-unit>
        <trans-unit id="f8ef4addb29288d67ee3b4225212bd0c25d2c82e" translate="yes" xml:space="preserve">
          <source>Number of zeros padded on the left. Default is 0 (no padding).</source>
          <target state="translated">左边填充的零的数量,默认为0(无填充)。默认为0(无填充)。</target>
        </trans-unit>
        <trans-unit id="c42ce792573d252e0e5bfedf479c34b63dd69907" translate="yes" xml:space="preserve">
          <source>Number of zeros to append to &lt;code&gt;x1&lt;/code&gt;. Has to be non-negative. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">要附加到 &lt;code&gt;x1&lt;/code&gt; 的零数。必须为非负数。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="48744031d20b47daf05a16a7cf85445cecfa69bb" translate="yes" xml:space="preserve">
          <source>Number(s) to append at the end of the returned differences.</source>
          <target state="translated">在返回的差值末尾添加的数字。</target>
        </trans-unit>
        <trans-unit id="b058e82a0ebd1af4fdfdc76f108d0c56ee2817ee" translate="yes" xml:space="preserve">
          <source>Number(s) to prepend at the beginning of the returned differences.</source>
          <target state="translated">要在返回的差额开头加上数字。</target>
        </trans-unit>
        <trans-unit id="415e3bf4df03605336c3914770641333dc739919" translate="yes" xml:space="preserve">
          <source>Numerator degrees of freedom in &lt;code&gt;random.noncentral_f&lt;/code&gt; need only be positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef085dad0112ed12e20c9ac768d68c02abb5c39" translate="yes" xml:space="preserve">
          <source>Numerator degrees of freedom, must be &amp;gt; 0.</source>
          <target state="translated">分子自由度，必须&amp;gt; 0。</target>
        </trans-unit>
        <trans-unit id="915427ef41bad72baf07ece61495d7f8349cc6ce" translate="yes" xml:space="preserve">
          <source>Numerator.</source>
          <target state="translated">Numerator.</target>
        </trans-unit>
        <trans-unit id="725a001aa87d95c548766f8d2dce89bbb2b6023f" translate="yes" xml:space="preserve">
          <source>Numeric Compatibility: If you used old typecode characters in your Numeric code (which was never recommended), you will need to change some of them to the new characters. In particular, the needed changes are &lt;code&gt;c -&amp;gt; S1&lt;/code&gt;, &lt;code&gt;b -&amp;gt; B&lt;/code&gt;, &lt;code&gt;1 -&amp;gt; b&lt;/code&gt;, &lt;code&gt;s -&amp;gt; h&lt;/code&gt;, &lt;code&gt;w -&amp;gt;
H&lt;/code&gt;, and &lt;code&gt;u -&amp;gt; I&lt;/code&gt;. These changes make the type character convention more consistent with other Python modules such as the &lt;a href=&quot;https://docs.python.org/dev/library/struct.html#module-struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">数字兼容性：如果您在数字代码中使用了旧的打字代码字符（从未建议过），则需要将其中一些更改为新字符。具体地，所需要的变化是 &lt;code&gt;c -&amp;gt; S1&lt;/code&gt; ， &lt;code&gt;b -&amp;gt; B&lt;/code&gt; ， &lt;code&gt;1 -&amp;gt; b&lt;/code&gt; ， &lt;code&gt;s -&amp;gt; h&lt;/code&gt; ， &lt;code&gt;w -&amp;gt; H&lt;/code&gt; ，和 &lt;code&gt;u -&amp;gt; I&lt;/code&gt; 。这些更改使类型字符约定与其他Python模块（例如&lt;a href=&quot;https://docs.python.org/dev/library/struct.html#module-struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt;模块）更加一致。</target>
        </trans-unit>
        <trans-unit id="cb439f202c0c83a4476c0493068474885a0d04ea" translate="yes" xml:space="preserve">
          <source>Numeric characters include digit characters, and all characters that have the Unicode numeric value property, e.g. &lt;code&gt;U+2155,
VULGAR FRACTION ONE FIFTH&lt;/code&gt;.</source>
          <target state="translated">数字字符包括数字字符，以及所有具有Unicode数值属性的字符，例如 &lt;code&gt;U+2155, VULGAR FRACTION ONE FIFTH&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef5636617d28e515f0b65e76f0f4004b94b623c0" translate="yes" xml:space="preserve">
          <source>Numerical negative, element-wise.</source>
          <target state="translated">数值负数,元素方面。</target>
        </trans-unit>
        <trans-unit id="4370eb3bfbe7ac1a30c0f9e9ca59a934adb66660" translate="yes" xml:space="preserve">
          <source>Numerical operations</source>
          <target state="translated">数学运算</target>
        </trans-unit>
        <trans-unit id="42eddc11b63fd08bdfea69adf3f079710df9af97" translate="yes" xml:space="preserve">
          <source>Numerical operations can be easily performed without worrying about missing values, dividing by zero, square roots of negative numbers, etc.:</source>
          <target state="translated">数值运算可以轻松进行,而不用担心漏值、除以零、负数的平方根等问题。</target>
        </trans-unit>
        <trans-unit id="4259f28206bfbca56d0e23c019e2fc661e9b9dc6" translate="yes" xml:space="preserve">
          <source>Numerical positive, element-wise.</source>
          <target state="translated">数值正,元素方面。</target>
        </trans-unit>
        <trans-unit id="52d7754f5a98c840b507e69ac61f5c2741e65c9f" translate="yes" xml:space="preserve">
          <source>Numerical ranges</source>
          <target state="translated">数值范围</target>
        </trans-unit>
        <trans-unit id="6466751f790e1e415eaeb56dd6736b61b1be5ff5" translate="yes" xml:space="preserve">
          <source>Numpy Alignment Goals</source>
          <target state="translated">Numpy对齐目标</target>
        </trans-unit>
        <trans-unit id="5e9d87ae4602a83bd12085c965654deb5c3d6e16" translate="yes" xml:space="preserve">
          <source>Numpy has switched to using pytest instead of nose for testing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ecbc9f20872e5d771f0c6a8fd21f4eb8338d6ff" translate="yes" xml:space="preserve">
          <source>Numpy no longer monkey-patches &lt;code&gt;ctypes&lt;/code&gt; with &lt;code&gt;__array_interface__&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="924ed3491b77ccfa9befdd61777a79adde9bfe4c" translate="yes" xml:space="preserve">
          <source>Numpy type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa7af780a848cf7ff977252465dc8e7c6177248" translate="yes" xml:space="preserve">
          <source>Numpy uses one of two methods to automatically determine the field byte offsets and the overall itemsize of a structured datatype, depending on whether &lt;code&gt;align=True&lt;/code&gt; was specified as a keyword argument to &lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bfbe596058b381b5d62de809d86afe7e25ae53f" translate="yes" xml:space="preserve">
          <source>Numpy uses two different forms of alignment to achieve these goals: &amp;ldquo;True alignment&amp;rdquo; and &amp;ldquo;Uint alignment&amp;rdquo;.</source>
          <target state="translated">Numpy使用两种不同形式的对齐方式来实现这些目标：&amp;ldquo;正确对齐&amp;rdquo;和&amp;ldquo; Uint对齐&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0bb9027c1066c8ed830e4c8560442711a99e34e6" translate="yes" xml:space="preserve">
          <source>Numpy&amp;rsquo;s dispatch mechanism, introduced in numpy version v1.16 is the recommended approach for writing custom N-dimensional array containers that are compatible with the numpy API and provide custom implementations of numpy functionality. Applications include &lt;a href=&quot;http://dask.pydata.org&quot;&gt;dask&lt;/a&gt; arrays, an N-dimensional array distributed across multiple nodes, and &lt;a href=&quot;https://docs-cupy.chainer.org/en/stable/&quot;&gt;cupy&lt;/a&gt; arrays, an N-dimensional array on a GPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893f750b4312b0bd2ff35bac0b6f12ab34ffa8d1" translate="yes" xml:space="preserve">
          <source>Numpy&amp;rsquo;s random number routines produce pseudo random numbers using combinations of a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; to create sequences and a &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; to use those sequences to sample from different statistical distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="964f31d6716dc00a266686a77065b8428590080d" translate="yes" xml:space="preserve">
          <source>Numpy&amp;rsquo;s random number routines produce pseudo random numbers using combinations of a &lt;code&gt;BitGenerator&lt;/code&gt; to create sequences and a &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; to use those sequences to sample from different statistical distributions:</source>
          <target state="translated">Numpy的随机数例程使用 &lt;code&gt;BitGenerator&lt;/code&gt; 组合以创建序列和&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;来使用这些序列从不同的统计分布中采样来生成伪随机数：</target>
        </trans-unit>
        <trans-unit id="dbcd930c38d963d5846a86153db381c82c24485e" translate="yes" xml:space="preserve">
          <source>NumpyVersion (class in numpy.lib)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1987fcddaae88d3445636d103d2f655d68cf7145" translate="yes" xml:space="preserve">
          <source>NumpyVersion class added</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="76403535a8ec16748017a87f4c76e50c07884d6f" translate="yes" xml:space="preserve">
          <source>O&amp;rsquo;Neill, Melissa E. &lt;a href=&quot;https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf&quot;&gt;&amp;ldquo;PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation&amp;rdquo;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc75cd71fe8ecc45d16e8fbe4ca608d05d1efe0" translate="yes" xml:space="preserve">
          <source>O(n)</source>
          <target state="translated">O(n)</target>
        </trans-unit>
        <trans-unit id="cd32e6ddbd41be3c5a4eb16b6f1ed3f8efca53a5" translate="yes" xml:space="preserve">
          <source>O(n*log(n))</source>
          <target state="translated">O(n*log(n))</target>
        </trans-unit>
        <trans-unit id="65ac5f452cfa676b59863240cc6b58ed94146182" translate="yes" xml:space="preserve">
          <source>O(n^2)</source>
          <target state="translated">O(n^2)</target>
        </trans-unit>
        <trans-unit id="16e21f4d3aaf4aa65a40bf94fc12335c25429454" translate="yes" xml:space="preserve">
          <source>O. McNoleg, &amp;ldquo;The integration of GIS, remote sensing, expert systems and adaptive co-kriging for environmental habitat modelling of the Highland Haggis using object-oriented, fuzzy-logic and neural-network techniques,&amp;rdquo; Computers &amp;amp; Geosciences, vol. 22, pp. 585-588, 1996.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce3bd4224c8c1780db56b4125ecf3f24bf748b7" translate="yes" xml:space="preserve">
          <source>OK</source>
          <target state="translated">OK</target>
        </trans-unit>
        <trans-unit id="9954b5cb646af3e1d62f8936ee802e399e164efe" translate="yes" xml:space="preserve">
          <source>OS X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4363d346523c5b2cd1bf247b95c174fae0de6fec" translate="yes" xml:space="preserve">
          <source>OS X builds on travis currently use &lt;code&gt;clang&lt;/code&gt;. It appears that binary wheels for OSX &amp;gt;= 10.6 can be safely built from the travis-ci OSX 10.9 VMs when building against the Python from the Python.org installers;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3edf589ebc096e6f9b1588e4ff5155e67b354878" translate="yes" xml:space="preserve">
          <source>OS X versions &amp;gt;= 10.9 are supported, for Python version support see &lt;a href=&quot;https://numpy.org/neps/nep-0029-deprecation_policy.html&quot;&gt;NEP 29&lt;/a&gt;. We build binary wheels for OSX that are compatible with Python.org Python, system Python, homebrew and macports - see this &lt;a href=&quot;https://github.com/MacPython/wiki/wiki/Spinning-wheels&quot;&gt;OSX wheel building summary&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8803bb33e936d33e0faf20b780197077a08628ad" translate="yes" xml:space="preserve">
          <source>OSX: x64_86 OSX wheels built using travis-ci;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fce725b9aa55e80045f38a3d07a2d5daf8ad25e" translate="yes" xml:space="preserve">
          <source>OWNDATA / O</source>
          <target state="translated">OWNDATA/O</target>
        </trans-unit>
        <trans-unit id="77cbefcb956b9d9d63f0f7b3f93654f940febe59" translate="yes" xml:space="preserve">
          <source>Object (i.e. the memory contains a pointer to &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">对象（即内存包含指向&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject&lt;/code&gt; &lt;/a&gt;的指针）</target>
        </trans-unit>
        <trans-unit id="afdc54032033cacfee557f2ce2a005fa3b70eafb" translate="yes" xml:space="preserve">
          <source>Object array equality comparisons</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3760fc40824fa6cae9e794ba9f7b99a3316407ab" translate="yes" xml:space="preserve">
          <source>Object that defines the index or indices before which &lt;code&gt;values&lt;/code&gt; is inserted.</source>
          <target state="translated">定义在其之前插入 &lt;code&gt;values&lt;/code&gt; 或多个索引的对象。</target>
        </trans-unit>
        <trans-unit id="d05ef3a802418a7aebbd13573f51be0ead5f4193" translate="yes" xml:space="preserve">
          <source>Object to be converted to a data type object.</source>
          <target state="translated">要转换为数据类型对象的对象。</target>
        </trans-unit>
        <trans-unit id="a8900e78cbf680bcf40ca195f2953f79bcfe04f2" translate="yes" xml:space="preserve">
          <source>Observe that we are using the dataptr array inside the iterator, not copying the values to a local temporary. This is possible because when &lt;code&gt;iternext()&lt;/code&gt; is called, these pointers will be overwritten with fresh values, not incrementally updated.</source>
          <target state="translated">观察到我们在迭代器内部使用了dataptr数组，没有将这些值复制到本地临时目录中。这是可能的，因为在 &lt;code&gt;iternext()&lt;/code&gt; 时，这些指针将被新值覆盖，而不是增量更新。</target>
        </trans-unit>
        <trans-unit id="f7b6a1c7c2ab92717708ab52dfb304953f89b662" translate="yes" xml:space="preserve">
          <source>Observe that with the default of keeping native memory order, the iterator is able to provide a single one-dimensional chunk, whereas when forcing Fortran order, it has to provide three chunks of two elements each.</source>
          <target state="translated">请注意,在保持本机内存顺序的默认情况下,迭代器能够提供一个一维的分块,而当强制Fortran顺序时,它必须提供三个分块,每个分块有两个元素。</target>
        </trans-unit>
        <trans-unit id="d9a0a259d7da286202ed894d68d15acb64fcfe1b" translate="yes" xml:space="preserve">
          <source>Obtain the agreement of the reported person(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b79a5cda4ce7e7ddd9f792b9921027f93e2741" translate="yes" xml:space="preserve">
          <source>Obtain the agreement of the reporter(s). The reporter(s) have complete freedom to decline the mediation idea, or to propose an alternate mediator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8499c2c896d61295bd16e3c134140b4e72b522" translate="yes" xml:space="preserve">
          <source>Occasionally there may be simple issues with old or bad installations of NumPy. In this case you may just try to uninstall and reinstall NumPy. Make sure that NumPy is not found after uninstalling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa8a40208cbec6893957fea3d09da8c32d4bb67b" translate="yes" xml:space="preserve">
          <source>Of Chebyshev series coefficients representing the quotient and remainder.</source>
          <target state="translated">代表商和余数的切比雪夫数列系数中。</target>
        </trans-unit>
        <trans-unit id="95a193973a1a38f794d62d2292b358ed61a158d4" translate="yes" xml:space="preserve">
          <source>Of Chebyshev series coefficients representing their difference.</source>
          <target state="translated">的切比雪夫系列系数代表它们的差值。</target>
        </trans-unit>
        <trans-unit id="f6f11800879153b66dc0982f5c4e19a52fd99bfd" translate="yes" xml:space="preserve">
          <source>Of Chebyshev series coefficients representing their product.</source>
          <target state="translated">代表其乘积的切比雪夫系列系数的。</target>
        </trans-unit>
        <trans-unit id="1e744292f68f81ff06c4af2891c2284d51276990" translate="yes" xml:space="preserve">
          <source>Of Hermite series coefficients representing the quotient and remainder.</source>
          <target state="translated">代表商和余数的赫米特系列系数中。</target>
        </trans-unit>
        <trans-unit id="68e73a174e70afa8021e3a5b69b172f5340b60a0" translate="yes" xml:space="preserve">
          <source>Of Hermite series coefficients representing their difference.</source>
          <target state="translated">的赫米特系列系数代表它们的差异。</target>
        </trans-unit>
        <trans-unit id="584dca0bbf2ee8dea79e52251025d455fc466309" translate="yes" xml:space="preserve">
          <source>Of Hermite series coefficients representing their product.</source>
          <target state="translated">代表其乘积的赫米特系列系数的。</target>
        </trans-unit>
        <trans-unit id="f835afbe8ca3fee3a7aaf7264b53bfe89607c7f1" translate="yes" xml:space="preserve">
          <source>Of Laguerre series coefficients representing the quotient and remainder.</source>
          <target state="translated">在代表商和余数的拉格尔系列系数中。</target>
        </trans-unit>
        <trans-unit id="90b47b338ded7c0b1d451aae2b6b202ac054bd26" translate="yes" xml:space="preserve">
          <source>Of Laguerre series coefficients representing their difference.</source>
          <target state="translated">在代表其差异的拉格尔系列系数中。</target>
        </trans-unit>
        <trans-unit id="9b96161c3659cfd1e35cc2549dc17860026b7cdc" translate="yes" xml:space="preserve">
          <source>Of Laguerre series coefficients representing their product.</source>
          <target state="translated">代表其乘积的拉格尔系列系数中。</target>
        </trans-unit>
        <trans-unit id="bd7f06a962c25e759bd9ef64c710ec6053768d88" translate="yes" xml:space="preserve">
          <source>Of Legendre series coefficients representing the quotient and remainder.</source>
          <target state="translated">表示商和余数的Legendre系列系数中。</target>
        </trans-unit>
        <trans-unit id="3059e37623b23a53a523c2b1352662c0102ac1da" translate="yes" xml:space="preserve">
          <source>Of Legendre series coefficients representing their difference.</source>
          <target state="translated">的Legendre系列系数,代表它们的差值。</target>
        </trans-unit>
        <trans-unit id="50248795d9f87718e76bae1fc0c734509f84b250" translate="yes" xml:space="preserve">
          <source>Of Legendre series coefficients representing their product.</source>
          <target state="translated">代表其乘积的Legendre系列系数的。</target>
        </trans-unit>
        <trans-unit id="d8427b6e14c2b373d5a6dab581028bfc5f363679" translate="yes" xml:space="preserve">
          <source>Of coefficient series representing the quotient and remainder.</source>
          <target state="translated">代表商和余数的系数系列中。</target>
        </trans-unit>
        <trans-unit id="d290318bfec96b6b8a0b5657cb6aa25c8656f248" translate="yes" xml:space="preserve">
          <source>Of coefficients representing their difference.</source>
          <target state="translated">代表其差异的系数中。</target>
        </trans-unit>
        <trans-unit id="6a85fe85cc5899aa41f4c1b4360a890de25aa1af" translate="yes" xml:space="preserve">
          <source>Of course you&amp;rsquo;ll need to replace &lt;code&gt;Your Name&lt;/code&gt; and &lt;code&gt;you@yourdomain.example.com&lt;/code&gt; with your actual name and email address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3f315ee6b4ab53b8b92ba8326227f97899e80b" translate="yes" xml:space="preserve">
          <source>Of course, a test can be unconditionally skipped or marked as a known failure by using &lt;code&gt;skip&lt;/code&gt; or &lt;code&gt;xfail&lt;/code&gt; without argument, respectively.</source>
          <target state="translated">当然，可以通过使用不带参数的 &lt;code&gt;skip&lt;/code&gt; 或 &lt;code&gt;xfail&lt;/code&gt; 分别无条件地跳过测试或将其标记为已知失败。</target>
        </trans-unit>
        <trans-unit id="fbcd4dc2b30c5efc09e8b8e0ac34e1195e3be111" translate="yes" xml:space="preserve">
          <source>Of course, this is not the best method to &lt;em&gt;approximate&lt;/em&gt; an image. However, there is, in fact, a result in linear algebra that says that the approximation we built above is the best we can get to the original matrix in terms of the norm of the difference. For more information, see &lt;em&gt;G. H. Golub and C. F. Van Loan, Matrix Computations, Baltimore, MD, Johns Hopkins University Press, 1985&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8a45899d21a287f8cee5fcbf7d53b28d2a2524" translate="yes" xml:space="preserve">
          <source>Of the coefficients of their product.</source>
          <target state="translated">其产品的系数中。</target>
        </trans-unit>
        <trans-unit id="609c29eaa3c81a7bde19a799569654e9420a8d39" translate="yes" xml:space="preserve">
          <source>Offset into a memmap:</source>
          <target state="translated">偏移到memmap中。</target>
        </trans-unit>
        <trans-unit id="0bc2c6922816779fd173b29551f1ab7c3175a4b8" translate="yes" xml:space="preserve">
          <source>Offset is limited to C int, which is signed and usually 32 bits. If present, the optional title can be any object (if it is a string or unicode then it will also be a key in the fields dictionary, otherwise it&amp;rsquo;s meta-data). Notice also that the first two elements of the tuple can be passed directly as arguments to the &lt;code&gt;ndarray.getfield&lt;/code&gt; and &lt;code&gt;ndarray.setfield&lt;/code&gt; methods.</source>
          <target state="translated">偏移量仅限于C int，它是有符号的，通常为32位。如果存在，则可选标题可以是任何对象（如果它是字符串或unicode，则它也将是字段字典中的键，否则为元数据）。还要注意，元组的前两个元素可以作为参数直接传递给 &lt;code&gt;ndarray.getfield&lt;/code&gt; 和 &lt;code&gt;ndarray.setfield&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="86ce02382c3cd06f8561677ae11ec555fdb1fe4e" translate="yes" xml:space="preserve">
          <source>Offset of array data in buffer.</source>
          <target state="translated">缓冲区内数组数据的偏移量。</target>
        </trans-unit>
        <trans-unit id="680177996996fd2c23e4d0d5181bef8478a843b3" translate="yes" xml:space="preserve">
          <source>Offset of the diagonal from the main diagonal. Can be both positive and negative. Defaults to 0.</source>
          <target state="translated">对角线与主对角线的偏移。可以是正值和负值。默认值为0。</target>
        </trans-unit>
        <trans-unit id="6b6b5a41310e8f5b4f7075c43a048e4d2e50484a" translate="yes" xml:space="preserve">
          <source>Offset of the diagonal from the main diagonal. Can be positive or negative. Defaults to main diagonal (0).</source>
          <target state="translated">对角线与主对角线的偏移。可以是正值或负值,默认为主对角线(0)。默认为主对角线(0)。</target>
        </trans-unit>
        <trans-unit id="efcd2ae12c66734a66a7aa79ae569a447152e17b" translate="yes" xml:space="preserve">
          <source>Offset position in the file.</source>
          <target state="translated">文件中的偏移位置。</target>
        </trans-unit>
        <trans-unit id="e5143224a659eeda117fd7431883f438f099ac14" translate="yes" xml:space="preserve">
          <source>Offsets in bytes, here 0 and 25:</source>
          <target state="translated">偏移量以字节为单位,这里是0和25。</target>
        </trans-unit>
        <trans-unit id="7329966e05964c08e33b7a47b16c9992cb5a4adf" translate="yes" xml:space="preserve">
          <source>Offsets may be chosen such that the fields overlap, though this will mean that assigning to one field may clobber any overlapping field&amp;rsquo;s data. As an exception, fields of &lt;code&gt;numpy.object&lt;/code&gt; type cannot overlap with other fields, because of the risk of clobbering the internal object pointer and then dereferencing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967a38eb8129ad7778f2c9f5678f5fdf3c82cadb" translate="yes" xml:space="preserve">
          <source>Often it is preferable to use a boolean mask. For example:</source>
          <target state="translated">通常情况下,最好使用布尔掩码。例如:</target>
        </trans-unit>
        <trans-unit id="6904502646c7743d277053efc8b47079c56c46bb" translate="yes" xml:space="preserve">
          <source>Often seen in method signatures, &lt;code&gt;self&lt;/code&gt; refers to the instance of the associated class. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b563fa4cc80accab04bf13505ac3eb5aa2b458" translate="yes" xml:space="preserve">
          <source>Often, the elements of an array are originally unknown, but its size is known. Hence, NumPy offers several functions to create arrays with initial placeholder content. These minimize the necessity of growing arrays, an expensive operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f9c3f125b2ae3755f9cc2e88d97945e0b2e6b1" translate="yes" xml:space="preserve">
          <source>Old, no conjugate, version of correlate.</source>
          <target state="translated">旧的,没有共轭,版本的相关。</target>
        </trans-unit>
        <trans-unit id="22b35a56584d02836f725dd51b4643aaa3081190" translate="yes" xml:space="preserve">
          <source>Older Equivalent</source>
          <target state="translated">旧的等价物</target>
        </trans-unit>
        <trans-unit id="950780760d17e16ea15a84017774640eae55ce02" translate="yes" xml:space="preserve">
          <source>On Unix-like machines, reads from &lt;code&gt;/dev/urandom&lt;/code&gt;. On Windows machines reads from the RSA algorithm provided by the cryptographic service provider.</source>
          <target state="translated">在类似Unix的计算机上，从 &lt;code&gt;/dev/urandom&lt;/code&gt; 中读取。在Windows机器上，从加密服务提供者提供的RSA算法中读取。</target>
        </trans-unit>
        <trans-unit id="2d3188b9edd47b7b8e155f7d62759b49e4bbd63c" translate="yes" xml:space="preserve">
          <source>On array access use the &lt;code&gt;f-&amp;gt;getitem&lt;/code&gt; function pointer instead of the standard conversion to an array scalar. Must use if you don&amp;rsquo;t define an array scalar to go along with the data-type.</source>
          <target state="translated">在数组访问中，使用 &lt;code&gt;f-&amp;gt;getitem&lt;/code&gt; 函数指针，而不是标准转换为数组标量。如果您没有定义数组标量与数据类型一起使用，则必须使用。</target>
        </trans-unit>
        <trans-unit id="4dcefd1cec20f7966d92a38bf6e10deb907560ec" translate="yes" xml:space="preserve">
          <source>On compilers which support a #warning mechanism, NumPy issues a compiler warning if you do not define the symbol NPY_NO_DEPRECATED_API. This way, the fact that there are deprecations will be flagged for third-party developers who may not have read the release notes closely.</source>
          <target state="translated">在支持#警告机制的编译器上,如果你没有定义符号NPY_NO_DEPRECATED_API,NumPy会发出编译器警告。这样一来,对于可能没有仔细阅读发布说明的第三方开发者来说,存在废弃的事实就会被标记出来。</target>
        </trans-unit>
        <trans-unit id="c713072ca3a05590ed7b22ab2b7c84fab6d46af9" translate="yes" xml:space="preserve">
          <source>On some platforms (&lt;em&gt;e.g.&lt;/em&gt; Windows), a shared library requires a .def file that specifies the functions to be exported. For example a mylib.def file might contain:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b6987bb053c195d4d4a88861df5cc0bec8c735" translate="yes" xml:space="preserve">
          <source>On the other hand, coolhelper.c would contain at the top:</source>
          <target state="translated">另一方面,coolhelper.c将在顶部包含。</target>
        </trans-unit>
        <trans-unit id="e97323f6987cba1f587e924c7a9998279536c754" translate="yes" xml:space="preserve">
          <source>On the other hand, the function &lt;code&gt;row_stack&lt;/code&gt; is equivalent to &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt; for any input arrays. In fact, &lt;code&gt;row_stack&lt;/code&gt; is an alias for &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8085f065b43ca0612f8f5a0dd702c78428f8a7" translate="yes" xml:space="preserve">
          <source>On this machine, building the .pyx file into a module looked like the following, but you may have to find some Cython tutorials to tell you the specifics for your system configuration.:</source>
          <target state="translated">在这台机器上,将.pyx文件构建成一个模块的过程如下,但你可能需要找到一些Cython教程来告诉你系统配置的具体情况......。</target>
        </trans-unit>
        <trans-unit id="9a506ebe097fd976b21e552ba29fd40b62947df8" translate="yes" xml:space="preserve">
          <source>Once a busdaycalendar object is created, the weekmask and holidays cannot be modified.</source>
          <target state="translated">一旦创建了busdaycalendar对象,就不能修改星期屏蔽和假日。</target>
        </trans-unit>
        <trans-unit id="eba82deb0932802c527a81a17b1d4d366fc0af03" translate="yes" xml:space="preserve">
          <source>Once a new &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure is created and filled with the needed information and useful functions you call &lt;a href=&quot;../reference/c-api/array#c.PyArray_RegisterDataType&quot;&gt;&lt;code&gt;PyArray_RegisterDataType&lt;/code&gt;&lt;/a&gt; (new_descr). The return value from this call is an integer providing you with a unique type_number that specifies your data-type. This type number should be stored and made available by your module so that other modules can use it to recognize your data-type (the other mechanism for finding a user-defined data-type number is to search based on the name of the type-object associated with the data-type using &lt;code&gt;PyArray_TypeNumFromName&lt;/code&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5183e36c12674d881f64d8eaa0dea9c0fa03d80d" translate="yes" xml:space="preserve">
          <source>Once a resolution is agreed upon, but before it is enacted, the committee will contact the original reporter and any other affected parties and explain the proposed resolution. The committee will ask if this resolution is acceptable, and must note feedback for the record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d441f19f98ee4b31cf802d2cbf0a4fb74d4c8d91" translate="yes" xml:space="preserve">
          <source>Once everything seems satisfactory, commit and upload the changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d8ca7f94183ec448b711283a3a7fa64f6c8872" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;scipy/xxx/tests/test_yyy.py&lt;/code&gt; is written, its possible to run the tests by going to the &lt;code&gt;tests/&lt;/code&gt; directory and typing:</source>
          <target state="translated">一旦 &lt;code&gt;scipy/xxx/tests/test_yyy.py&lt;/code&gt; 写入，其可能通过进入运行测试 &lt;code&gt;tests/&lt;/code&gt; 目录并键入：</target>
        </trans-unit>
        <trans-unit id="ac70209362afce77775660280fe98f52f86f930f" translate="yes" xml:space="preserve">
          <source>Once the SeedSequence is instantiated, you can call the &lt;a href=&quot;numpy.random.seedsequence.generate_state#numpy.random.SeedSequence.generate_state&quot;&gt;&lt;code&gt;generate_state&lt;/code&gt;&lt;/a&gt; method to get an appropriately sized seed. Calling &lt;a href=&quot;numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;spawn(n)&lt;/code&gt;&lt;/a&gt; will create &lt;code&gt;n&lt;/code&gt; SeedSequences that can be used to seed independent BitGenerators, i.e. for different threads.</source>
          <target state="translated">实例化SeedSequence之后，可以调用&lt;a href=&quot;numpy.random.seedsequence.generate_state#numpy.random.SeedSequence.generate_state&quot;&gt; &lt;code&gt;generate_state&lt;/code&gt; &lt;/a&gt;方法来获取适当大小的种子。调用&lt;a href=&quot;numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt; &lt;code&gt;spawn(n)&lt;/code&gt; &lt;/a&gt;将创建 &lt;code&gt;n&lt;/code&gt; 个 SeedSequences，可用于为独立的BitGenerator设置种子，即用于不同的线程。</target>
        </trans-unit>
        <trans-unit id="9b8c845df2375661d6c8904939512353e20ecd41" translate="yes" xml:space="preserve">
          <source>Once the conversions to the appropriate C-structures and C data-types have been performed, the next step in the wrapper is to call the underlying function. This is straightforward if the underlying function is in C or C++. However, in order to call Fortran code you must be familiar with how Fortran subroutines are called from C/C++ using your compiler and platform. This can vary somewhat platforms and compilers (which is another reason f2py makes life much simpler for interfacing Fortran code) but generally involves underscore mangling of the name and the fact that all variables are passed by reference (i.e. all arguments are pointers).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fd5de6f03a0c2c385081a0d6f534ba7e379838a" translate="yes" xml:space="preserve">
          <source>Once the file is defined and open for reading, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; splits each non-empty line into a sequence of strings. Empty or commented lines are just skipped. The &lt;code&gt;delimiter&lt;/code&gt; keyword is used to define how the splitting should take place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b7cac8dde7cbe137262c702e77fb0ca9ad5356" translate="yes" xml:space="preserve">
          <source>Once the header is parsed by &lt;code&gt;ffi.cdef&lt;/code&gt;, the functions can be accessed directly from the &lt;code&gt;_generator&lt;/code&gt; shared object, using the &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator.cffi#numpy.random.BitGenerator.cffi&quot;&gt;&lt;code&gt;BitGenerator.cffi&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="231d4308334f05ae25082dce13bc3cf1e18cdbf8" translate="yes" xml:space="preserve">
          <source>Once the iterator is prepared for iteration (after a reset if &lt;code&gt;NPY_DELAY_BUFALLOC&lt;/code&gt; was used), call this to get the strides which may be used to select a fast inner loop function. For example, if the stride is 0, that means the inner loop can always load its value into a variable once, then use the variable throughout the loop, or if the stride equals the itemsize, a contiguous version for that operand may be used.</source>
          <target state="translated">一旦迭代器准备好进行迭代（如果使用了 &lt;code&gt;NPY_DELAY_BUFALLOC&lt;/code&gt; ,则在重置后），调用此函数可获得可用于选择快速内部循环函数的步幅。例如，如果跨度为0，则意味着内部循环始终可以将其值一次加载到变量中，然后在整个循环中使用该变量，或者如果跨度等于项大小，则可以使用该操作数的连续版本。</target>
        </trans-unit>
        <trans-unit id="c04dbd1660afe1562d16b591f18b1bb40507aaa1" translate="yes" xml:space="preserve">
          <source>Once the spam module is imported into python, you can call logit via spam.logit. Note that the function used above cannot be applied as-is to numpy arrays. To do so we must call numpy.vectorize on it. For example, if a python interpreter is opened in the file containing the spam library or spam has been installed, one can perform the following commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993e871933c3573c232eaa172843213039b4efd1" translate="yes" xml:space="preserve">
          <source>Once the wheels have been built and downloaded without errors, go back to your numpy repository in the maintenance branch and tag the &lt;code&gt;REL&lt;/code&gt; commit, signing it with your gpg key:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44934f86865426c152af6fe43faca7909cb74599" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve created your arrays, you can start to work with them. Let&amp;rsquo;s say, for example, that you&amp;rsquo;ve created two arrays, one called &amp;ldquo;data&amp;rdquo; and one called &amp;ldquo;ones&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71c392b0b03965e8b7e58ba06da44426e1525511" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve created your matrices, you can add and multiply them using arithmetic operators if you have two matrices that are the same size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77517b16ad949bec662df3d2780dff01b3a28d3c" translate="yes" xml:space="preserve">
          <source>One Loop</source>
          <target state="translated">一环</target>
        </trans-unit>
        <trans-unit id="fb74c341b98c307818ac342dee77af9f705b8e7e" translate="yes" xml:space="preserve">
          <source>One big advantage of Cython-generated extension modules is that they are easy to distribute. In summary, Cython is a very capable tool for either gluing C code or generating an extension module quickly and should not be over-looked. It is especially useful for people that can&amp;rsquo;t or won&amp;rsquo;t write C or Fortran code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444c9c354929cf1b3a58f15b3f0b2168f58f68f7" translate="yes" xml:space="preserve">
          <source>One can also instantiate &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; directly with a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; instance. To use the older &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; algorithm, one can instantiate it directly and pass it to &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8524b74ddf89508f43aa1069be40f8c206f86f89" translate="yes" xml:space="preserve">
          <source>One can also instantiate &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; directly with a &lt;code&gt;BitGenerator&lt;/code&gt; instance. To use the older &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; algorithm, one can instantiate it directly and pass it to &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">也可以直接使用 &lt;code&gt;BitGenerator&lt;/code&gt; 实例实例化&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;。要使用较旧的&lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt;算法，可以直接实例化并将其传递给&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="070709f2e07ce3e32b6abdd9998a1049f1bd5e84" translate="yes" xml:space="preserve">
          <source>One can index and assign to a structured array with a multi-field index, where the index is a list of field names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3340151bf466504ea342e74247a72d1486385a" translate="yes" xml:space="preserve">
          <source>One can use &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; to declare a more general ufunc. The argument list is the same as &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt;, with an additional argument specifying the signature as C string.</source>
          <target state="translated">可以使用 &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; 声明更通用的ufunc。参数列表与 &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; 相同，另外一个参数将签名指定为C字符串。</target>
        </trans-unit>
        <trans-unit id="e6a96a24425a79d2472bdd027a95e9628f8491bc" translate="yes" xml:space="preserve">
          <source>One can use different values for optional &lt;code&gt;n&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56899b43e5156c96d1005f04cd69878206c68abd" translate="yes" xml:space="preserve">
          <source>One common algorithmic requirement is to be able to walk over all elements in a multidimensional array. The array iterator object makes this easy to do in a generic way that works for arrays of any dimension. Naturally, if you know the number of dimensions you will be using, then you can always write nested for loops to accomplish the iteration. If, however, you want to write code that works with any number of dimensions, then you can make use of the array iterator. An array iterator object is returned when accessing the .flat attribute of an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81089507935f358c69911644b087b72a2a0a612b" translate="yes" xml:space="preserve">
          <source>One common source of reference-count errors is the &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.Py_BuildValue&quot;&gt;&lt;code&gt;Py_BuildValue&lt;/code&gt;&lt;/a&gt; function. Pay careful attention to the difference between the &amp;lsquo;N&amp;rsquo; format character and the &amp;lsquo;O&amp;rsquo; format character. If you create a new object in your subroutine (such as an output array), and you are passing it back in a tuple of return values, then you should most- likely use the &amp;lsquo;N&amp;rsquo; format character in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.Py_BuildValue&quot;&gt;&lt;code&gt;Py_BuildValue&lt;/code&gt;&lt;/a&gt;. The &amp;lsquo;O&amp;rsquo; character will increase the reference count by one. This will leave the caller with two reference counts for a brand-new array. When the variable is deleted and the reference count decremented by one, there will still be that extra reference count, and the array will never be deallocated. You will have a reference-counting induced memory leak. Using the &amp;lsquo;N&amp;rsquo; character will avoid this situation as it will return to the caller an object (inside the tuple) with a single reference count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d4e9404ec123b91b7f0181eb9f23e04fe59bd2" translate="yes" xml:space="preserve">
          <source>One deviation from the current behavior of &lt;code&gt;__array_ufunc__&lt;/code&gt; is that NumPy will only call &lt;code&gt;__array_function__&lt;/code&gt; on the &lt;em&gt;first&lt;/em&gt; argument of each unique type. This matches Python&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#object.__ror__&quot;&gt;rule for calling reflected methods&lt;/a&gt;, and this ensures that checking overloads has acceptable performance even when there are a large number of overloaded arguments.</source>
          <target state="translated">与 &lt;code&gt;__array_ufunc__&lt;/code&gt; 当前行为的一个偏差是NumPy将仅在每种唯一类型的&lt;em&gt;第一个&lt;/em&gt;参数上调用 &lt;code&gt;__array_function__&lt;/code&gt; 。这符合Python &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#object.__ror__&quot;&gt;调用反射方法&lt;/a&gt;的规则，并且即使在有大量重载参数的情况下，也可以确保检查重载具有可接受的性能。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b47e08224aaf497fafd8b89783b8a17e95a05214" translate="yes" xml:space="preserve">
          <source>One dimensional array:</source>
          <target state="translated">一维数组。</target>
        </trans-unit>
        <trans-unit id="bbfcf4855e8547b3c2c018358506a526943e1c9a" translate="yes" xml:space="preserve">
          <source>One fundamental aspect of the ndarray is that an array is seen as a &amp;ldquo;chunk&amp;rdquo; of memory starting at some location. The interpretation of this memory depends on the stride information. For each dimension in an</source>
          <target state="translated">ndarray的一个基本方面是，将数组视为从某个位置开始的内存&amp;ldquo;块&amp;rdquo;。此内存的解释取决于步幅信息。对于一个</target>
        </trans-unit>
        <trans-unit id="16275c9ae04e235f8070983e66409df72503b036" translate="yes" xml:space="preserve">
          <source>One is returned for slices that are all-NaN or empty.</source>
          <target state="translated">对于全NaN或空的片子,会返回一个。</target>
        </trans-unit>
        <trans-unit id="e2800fbab71db8fc98d5d383e0fd87d0d933e41f" translate="yes" xml:space="preserve">
          <source>One of &amp;ldquo;always&amp;rdquo;, &amp;ldquo;once&amp;rdquo;, &amp;ldquo;module&amp;rdquo;, or &amp;ldquo;location&amp;rdquo;. Analogous to the usual warnings module filter mode, it is useful to reduce noise mostly on the outmost level. Unsuppressed and unrecorded warnings will be forwarded based on this rule. Defaults to &amp;ldquo;always&amp;rdquo;. &amp;ldquo;location&amp;rdquo; is equivalent to the warnings &amp;ldquo;default&amp;rdquo;, match by exact location the warning warning originated from.</source>
          <target state="translated">&amp;ldquo;总是&amp;rdquo;，&amp;ldquo;一次&amp;rdquo;，&amp;ldquo;模块&amp;rdquo;或&amp;ldquo;位置&amp;rdquo;之一。与通常的警告模块过滤器模式类似，主要在最外层降低噪声很有用。未抑制和未记录的警告将根据此规则转发。默认为&amp;ldquo;始终&amp;rdquo;。&amp;ldquo;位置&amp;rdquo;等同于警告&amp;ldquo;默认&amp;rdquo;，通过警告警告的确切位置进行匹配。</target>
        </trans-unit>
        <trans-unit id="a089b8e63dd4e8eb30432f942f75f4b932e1fd5a" translate="yes" xml:space="preserve">
          <source>One of None, &amp;lsquo;auto&amp;rsquo;, or a &lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;datetime unit&lt;/a&gt;.</source>
          <target state="translated">None，'auto'或&lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;datetime单位之一&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f39ed1de2c370ff6c78c1184ddb58d4c6a6a7345" translate="yes" xml:space="preserve">
          <source>One of the built-in data-types, the void data-type allows for arbitrary structured types containing 1 or more fields as elements of the array. A field is simply another data-type object along with an offset into the current structured type. In order to support arbitrarily nested fields, several recursive implementations of data-type access are implemented for the void type. A common idiom is to cycle through the elements of the dictionary and perform a specific operation based on the data-type object stored at the given offset. These offsets can be arbitrary numbers. Therefore, the possibility of encountering mis- aligned data must be recognized and taken into account if necessary.</source>
          <target state="translated">作为内置的数据类型之一,void数据类型允许包含1个或多个字段作为数组元素的任意结构类型。一个字段只是另一个数据类型对象以及一个偏移到当前结构化类型的对象。为了支持任意嵌套的字段,虚空类型实现了几种数据类型访问的递归实现。一个常见的习惯是循环浏览字典的元素,并根据存储在给定偏移量的数据类型对象执行特定的操作。这些偏移量可以是任意的数字。因此,必须认识到遇到错误对齐数据的可能性,并在必要时加以考虑。</target>
        </trans-unit>
        <trans-unit id="7f15581ffc61dc8d280c89c7bfaccc5af8a60a18" translate="yes" xml:space="preserve">
          <source>One of the elements in &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt;&lt;code&gt;PyObject_HEAD&lt;/code&gt;&lt;/a&gt; is a pointer to a type-object structure. A new Python type is created by creating a new type-object structure and populating it with functions and pointers to describe the desired behavior of the type. Typically, a new C-structure is also created to contain the instance-specific information needed for each object of the type as well. For example, &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt; is a pointer to the type-object table for the ndarray while a &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; variable is a pointer to a particular instance of an ndarray (one of the members of the ndarray structure is, in turn, a pointer to the type- object table &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;). Finally &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt;&lt;code&gt;PyType_Ready&lt;/code&gt;&lt;/a&gt; (&amp;lt;pointer_to_type_object&amp;gt;) must be called for every new Python type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800f0527f171cc2cc2f96013ed1d0d73822e318b" translate="yes" xml:space="preserve">
          <source>One of the enumerated types or &lt;a href=&quot;../reference/c-api/dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; if the data-type should be determined from the object itself. The C-based names can be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8bb917d30f8e918beefbd1feb7c9a171676de0" translate="yes" xml:space="preserve">
          <source>One of the following string values or a user supplied function.</source>
          <target state="translated">以下字符串值之一或用户提供的函数。</target>
        </trans-unit>
        <trans-unit id="c247d033f683cfebb6311017bf9488ea1b3de438" translate="yes" xml:space="preserve">
          <source>One of the lesser-used features that has been lurking in Python since 2.2 is the ability to sub-class types in C. This facility is one of the important reasons for basing NumPy off of the Numeric code-base which was already in C. A sub-type in C allows much more flexibility with regards to memory management. Sub-typing in C is not difficult even if you have only a rudimentary understanding of how to create new types for Python. While it is easiest to sub-type from a single parent type, sub-typing from multiple parent types is also possible. Multiple inheritance in C is generally less useful than it is in Python because a restriction on Python sub-types is that they have a binary compatible memory layout. Perhaps for this reason, it is somewhat easier to sub-type from a single parent type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27403d9ce40c15186aafb846c5de4d2a9de532c0" translate="yes" xml:space="preserve">
          <source>One of the problems that ndarray solves is keeping track of memory ownership of ndarrays and their views. Consider the case where we have created an ndarray, &lt;code&gt;arr&lt;/code&gt; and have taken a slice with &lt;code&gt;v = arr[1:]&lt;/code&gt;. The two objects are looking at the same memory. NumPy keeps track of where the data came from for a particular array or view, with the &lt;code&gt;base&lt;/code&gt; attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3967d3ba22f4ac7f4c1ab09bac9634bd847ca9c" translate="yes" xml:space="preserve">
          <source>One of:</source>
          <target state="translated">其中一个:</target>
        </trans-unit>
        <trans-unit id="eb28eadbd381d78c0578e9d33fcdb60f914be747" translate="yes" xml:space="preserve">
          <source>One or more array-like sequences. Non-array inputs are converted to arrays. Arrays that already have three or more dimensions are preserved.</source>
          <target state="translated">一个或多个类似数组的序列。非数组输入被转换为数组。已经有三个或更多维度的数组被保留。</target>
        </trans-unit>
        <trans-unit id="30e8ba24447e6b42366fd8b8bb4f9518361510cc" translate="yes" xml:space="preserve">
          <source>One or more array-like sequences. Non-array inputs are converted to arrays. Arrays that already have two or more dimensions are preserved.</source>
          <target state="translated">一个或多个类似数组的序列。非数组输入被转换为数组。已经有两个或两个以上维度的数组被保留。</target>
        </trans-unit>
        <trans-unit id="b5ac146eea9a6c289d467e482f8a257b9519c8d8" translate="yes" xml:space="preserve">
          <source>One or more input arrays.</source>
          <target state="translated">一个或多个输入阵列。</target>
        </trans-unit>
        <trans-unit id="c995dd2d01832787cd57c037ae2c18a3ecd49592" translate="yes" xml:space="preserve">
          <source>One padding, Outside bounds values will be 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce4e66d66f3f25393b9b9092b14d986216b8ea91" translate="yes" xml:space="preserve">
          <source>One relatively simple and reliable way to check for the compiler used to build a library is to use ldd on the library. If libg2c.so is a dependency, this means that g77 has been used (note: g77 is no longer supported for building NumPy). If libgfortran.so is a dependency, gfortran has been used. If both are dependencies, this means both have been used, which is almost always a very bad idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6362eba61fec5cf9abb4f9817d64b7cd0aed92b" translate="yes" xml:space="preserve">
          <source>One sees that the &lt;code&gt;super&lt;/code&gt; call, which goes to &lt;code&gt;ndarray.__new__&lt;/code&gt;, passes &lt;code&gt;__array_finalize__&lt;/code&gt; the new object, of our own class (&lt;code&gt;self&lt;/code&gt;) as well as the object from which the view has been taken (&lt;code&gt;obj&lt;/code&gt;). As you can see from the output above, the &lt;code&gt;self&lt;/code&gt; is always a newly created instance of our subclass, and the type of &lt;code&gt;obj&lt;/code&gt; differs for the three instance creation methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ec8922f9be1aeeb6fe45b52431c5e822f5d065" translate="yes" xml:space="preserve">
          <source>One simple way to achieve this is to install the released version in site-packages, by using a binary installer or pip for example, and set up the development version in a virtualenv. First install &lt;a href=&quot;http://www.virtualenv.org/&quot;&gt;virtualenv&lt;/a&gt; (optionally use &lt;a href=&quot;http://www.doughellmann.com/projects/virtualenvwrapper/&quot;&gt;virtualenvwrapper&lt;/a&gt;), then create your virtualenv (named numpy-dev here) with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01bd59e7480ae8ee0b30eea6aab25ec69688345a" translate="yes" xml:space="preserve">
          <source>One thing to watch out for is conversions back to the original data type when using a read-write or write-only operand. A common case is to implement the inner loop in terms of 64-bit floats, and use &amp;lsquo;same_kind&amp;rsquo; casting to allow the other floating-point types to be processed as well. While in read-only mode, an integer array could be provided, read-write mode will raise an exception because conversion back to the array would violate the casting rule.</source>
          <target state="translated">要注意的一件事是使用读写或仅写操作数时，转换回原始数据类型。一个常见的情况是用64位浮点数实现内部循环，并使用'same_kind'强制转换来允许处理其他浮点类型。在只读模式下，可以提供一个整数数组，而读写模式将引发异常，因为转换回该数组将违反强制转换规则。</target>
        </trans-unit>
        <trans-unit id="2cc36f9c20276e56c093db5e52fdeb366528fc58" translate="yes" xml:space="preserve">
          <source>One vector with dimension 2.</source>
          <target state="translated">一个维度为2的向量。</target>
        </trans-unit>
        <trans-unit id="99918e2f05caf6cd6ec60dc844a473737b719247" translate="yes" xml:space="preserve">
          <source>One very nice feature of testing is allowing easy testing across a range of parameters - a nasty problem for standard unit tests. Use the &lt;code&gt;dec.paramaterize&lt;/code&gt; decorator.</source>
          <target state="translated">测试的一个非常不错的功能是允许对一系列参数进行轻松测试-对于标准单元测试而言这是一个棘手的问题。使用 &lt;code&gt;dec.paramaterize&lt;/code&gt; 装饰器。</target>
        </trans-unit>
        <trans-unit id="bd9c1c4f351a78f93a1ea46f7fb6388f8d6e8ce8" translate="yes" xml:space="preserve">
          <source>One way we can initialize NumPy arrays is from Python lists, using nested lists for two- or higher-dimensional data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd980620fd6bb0d38c87e52f67df303553acf634" translate="yes" xml:space="preserve">
          <source>One-character strings</source>
          <target state="translated">一个字符的字符串</target>
        </trans-unit>
        <trans-unit id="7dd48564d3a850a05467a68a151727d64b2ad461" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays are then printed as rows, bidimensionals as matrices and tridimensionals as lists of matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5131dc464a794c785bc59aee87c51ca82227aaed" translate="yes" xml:space="preserve">
          <source>One-dimensional linear interpolation.</source>
          <target state="translated">一维线性插值。</target>
        </trans-unit>
        <trans-unit id="cd572fc9dc51ce4fd31312f0bb79afc0c6e4432a" translate="yes" xml:space="preserve">
          <source>One-dimensional, two-dimensional, three-dimensional and four-dimensional arrays.</source>
          <target state="translated">一维、二维、三维和四维阵列。</target>
        </trans-unit>
        <trans-unit id="3b7777f0a5babbc2cd6ca70c30ebaa80abc0442d" translate="yes" xml:space="preserve">
          <source>One-input, one-output, and two-input, one-output core 1-d functions for the &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; data type. These functions handle reference count issues and return early on error. The actual function to call is &lt;em&gt;func&lt;/em&gt; and it must accept calls with the signature &lt;code&gt;(PyObject*)
(PyObject*)&lt;/code&gt; for &lt;a href=&quot;#c.PyUFunc_O_O&quot;&gt;&lt;code&gt;PyUFunc_O_O&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;(PyObject*)(PyObject *,
PyObject *)&lt;/code&gt; for &lt;a href=&quot;#c.PyUFunc_OO_O&quot;&gt;&lt;code&gt;PyUFunc_OO_O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; &lt;/a&gt;数据类型的一输入一输出和两输入一输出内核1-d函数。这些函数处理引用计数问题，并在错误时尽早返回。要调用的实际功能是&lt;em&gt;FUNC&lt;/em&gt;，它必须接受签名调用 &lt;code&gt;(PyObject*) (PyObject*)&lt;/code&gt; 为&lt;a href=&quot;#c.PyUFunc_O_O&quot;&gt; &lt;code&gt;PyUFunc_O_O&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;(PyObject*)(PyObject *, PyObject *)&lt;/code&gt; 为&lt;a href=&quot;#c.PyUFunc_OO_O&quot;&gt; &lt;code&gt;PyUFunc_OO_O&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c1f106f50e29c9c2b8a1ac2b65d27f3773387b3" translate="yes" xml:space="preserve">
          <source>One-input, one-output, and two-input, one-output core 1-d functions for the &lt;a href=&quot;dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; data type. These functions handle reference count issues and return early on error. The actual function to call is &lt;em&gt;func&lt;/em&gt; and it must accept calls with the signature &lt;code&gt;(PyObject*)
(PyObject*)&lt;/code&gt; for &lt;a href=&quot;#c.PyUFunc_O_O&quot;&gt;&lt;code&gt;PyUFunc_O_O&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;(PyObject*)(PyObject *,
PyObject *)&lt;/code&gt; for &lt;a href=&quot;#c.PyUFunc_OO_O&quot;&gt;&lt;code&gt;PyUFunc_OO_O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd47ce11e1fa9754d28954cfcd5881bbc1273cc" translate="yes" xml:space="preserve">
          <source>Ones and zeros</source>
          <target state="translated">1和0</target>
        </trans-unit>
        <trans-unit id="cb940bbbd02e7c31b4ae50aac2139276e3822e9f" translate="yes" xml:space="preserve">
          <source>Ones are returned for slices that are all-NaN or empty.</source>
          <target state="translated">全NaN或空的片子会返回1。</target>
        </trans-unit>
        <trans-unit id="09f22eb6b2adcce43b85d8b07506fb5c95ab640d" translate="yes" xml:space="preserve">
          <source>Only a few, unrelated commits then prefer rebasing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b697531330130760eafc916bd6f1be5353ebde" translate="yes" xml:space="preserve">
          <source>Only a survey of the choices. Little detail on how each works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1addd7b3649a3c34fc344240c254d5a275033117" translate="yes" xml:space="preserve">
          <source>Only accepts 1-D arrays.</source>
          <target state="translated">只接受一维数组。</target>
        </trans-unit>
        <trans-unit id="bde044c10adb7133cf0f3ad6c4862788f16172f1" translate="yes" xml:space="preserve">
          <source>Only accepts 2-D arrays at most.</source>
          <target state="translated">最多只能接受二维数组。</target>
        </trans-unit>
        <trans-unit id="7afe5b0a4d7cbceb0c653cfc81e1d454858d38ee" translate="yes" xml:space="preserve">
          <source>Only allow casts which will not cause values to be rounded, truncated, or otherwise changed.</source>
          <target state="translated">只允许不会导致值被四舍五入、截断或其他改变的投掷。</target>
        </trans-unit>
        <trans-unit id="c3582e0ecb066430ad3be065ab374165ffa609f3" translate="yes" xml:space="preserve">
          <source>Only allow identical types.</source>
          <target state="translated">只允许相同的类型。</target>
        </trans-unit>
        <trans-unit id="603519900a2e75cc37ace5a2f71e7c45cdb8b832" translate="yes" xml:space="preserve">
          <source>Only an integer decimal number can be used.</source>
          <target state="translated">只能使用整数的十进制数。</target>
        </trans-unit>
        <trans-unit id="cae35f53e6308f43d551d7ad3a2026ad04e15e23" translate="yes" xml:space="preserve">
          <source>Only contiguous arrays (data elements consecutive in memory) can be resized.</source>
          <target state="translated">只有连续的数组(内存中连续的数据元素)可以调整大小。</target>
        </trans-unit>
        <trans-unit id="e992238c6b6cf34041def067b036cda1362cc0ed" translate="yes" xml:space="preserve">
          <source>Only integer and boolean types are handled.</source>
          <target state="translated">只处理整数和布尔类型。</target>
        </trans-unit>
        <trans-unit id="ce974e565e6e54262541b566a10f88e312bc9462" translate="yes" xml:space="preserve">
          <source>Only integer and boolean types are handled. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">仅处理整数和布尔类型。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="7329167d275db4d33debe4e1e78cc7c194228992" translate="yes" xml:space="preserve">
          <source>Only on intel (windows?)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e46a9dd5cfa9d4541737997e2a69c528376429" translate="yes" xml:space="preserve">
          <source>Only return the middle values of the convolution. Contains boundary effects, where zeros are taken into account:</source>
          <target state="translated">只返回卷积的中间值。包含边界效应,其中零被考虑在内。</target>
        </trans-unit>
        <trans-unit id="c646c2238b413bc43301092aedff89ef1f867724" translate="yes" xml:space="preserve">
          <source>Only returned if &lt;code&gt;retstep&lt;/code&gt; is True</source>
          <target state="translated">仅在 &lt;code&gt;retstep&lt;/code&gt; 为True时返回</target>
        </trans-unit>
        <trans-unit id="e429b326ee86d54ede5217418c8826c4e767d391" translate="yes" xml:space="preserve">
          <source>Only the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be changed by the user, via direct assignment to the attribute or dictionary entry, or by calling &lt;a href=&quot;numpy.ndarray.setflags#numpy.ndarray.setflags&quot;&gt;&lt;code&gt;ndarray.setflags&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用户只能通过直接分配给属性或字典条目或调用&lt;a href=&quot;numpy.ndarray.setflags#numpy.ndarray.setflags&quot;&gt; &lt;code&gt;ndarray.setflags&lt;/code&gt; &lt;/a&gt;来更改WRITEBACKIFCOPY，UPDATEIFCOPY，WRITEABLE和ALIGNED标志。</target>
        </trans-unit>
        <trans-unit id="ba8823766a1477c99c5d6107c4aad19cb79aa3fe" translate="yes" xml:space="preserve">
          <source>Only the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be changed by the user, via direct assignment to the attribute or dictionary entry, or by calling &lt;code&gt;ndarray.setflags&lt;/code&gt;.</source>
          <target state="translated">用户只能通过直接分配给属性或字典条目或调用 &lt;code&gt;ndarray.setflags&lt;/code&gt; 来更改WRITEBACKIFCOPY，UPDATEIFCOPY，WRITEABLE和ALIGNED标志。</target>
        </trans-unit>
        <trans-unit id="14128c80bfe87033c27d2c8a406f61e4d63d6d90" translate="yes" xml:space="preserve">
          <source>Only the memory bounds of a and b are checked by default.</source>
          <target state="translated">默认只检查a和b的内存边界。</target>
        </trans-unit>
        <trans-unit id="a133ec60f230a1d745372bd29522c9608116df62" translate="yes" xml:space="preserve">
          <source>Only the memory bounds of a and b are checked.</source>
          <target state="translated">只检查a和b的内存边界。</target>
        </trans-unit>
        <trans-unit id="2828ce3af0ec6cf22589ee67ae2d61139d97726f" translate="yes" xml:space="preserve">
          <source>Only used in &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt;&lt;code&gt;PyArray_CheckFromAny&lt;/code&gt;&lt;/a&gt; to over-ride the byteorder of the data-type object passed in.</source>
          <target state="translated">仅在&lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt; &lt;code&gt;PyArray_CheckFromAny&lt;/code&gt; 中&lt;/a&gt;用于覆盖传入的数据类型对象的字节顺序。</target>
        </trans-unit>
        <trans-unit id="c499db64f45476fb60b7a934c6b0e9eae67b09aa" translate="yes" xml:space="preserve">
          <source>Only useful in forcing objects in object arrays on Python 3 to be pickled in a Python 2 compatible way. If &lt;code&gt;fix_imports&lt;/code&gt; is True, pickle will try to map the new Python 3 names to the old module names used in Python 2, so that the pickle data stream is readable with Python 2.</source>
          <target state="translated">仅用于强制以Python 2兼容方式对Python 3上的对象数组中的对象进行腌制。如果 &lt;code&gt;fix_imports&lt;/code&gt; 为True，则pickle将尝试将新的Python 3名称映射到Python 2中使用的旧模块名称，以便pickle数据流可被Python 2读取。</target>
        </trans-unit>
        <trans-unit id="9be2bb2a7cf937c49df50863791a7e2b8e618032" translate="yes" xml:space="preserve">
          <source>Only useful when loading Python 2 generated pickled files on Python 3, which includes npy/npz files containing object arrays. If &lt;code&gt;fix_imports&lt;/code&gt; is True, pickle will try to map the old Python 2 names to the new names used in Python 3.</source>
          <target state="translated">仅在在Python 3上加载Python 2生成的腌制文件时有用，该文件包括包含对象数组的npy / npz文件。如果 &lt;code&gt;fix_imports&lt;/code&gt; 为True，则pickle将尝试将旧的Python 2名称映射到Python 3中使用的新名称。</target>
        </trans-unit>
        <trans-unit id="17ffc3b0833d539654e5ad58b641d1cef1d2a7bc" translate="yes" xml:space="preserve">
          <source>Open and return file-like object.</source>
          <target state="translated">打开并返回类文件对象。</target>
        </trans-unit>
        <trans-unit id="bb7abb02e2506f465eda9d56007ed5a7e2b0bd98" translate="yes" xml:space="preserve">
          <source>Open existing file for reading and writing.</source>
          <target state="translated">打开现有文件进行读写。</target>
        </trans-unit>
        <trans-unit id="bd185b75f1b59e945b739489c944a7512ff51fd8" translate="yes" xml:space="preserve">
          <source>Open existing file for reading only.</source>
          <target state="translated">打开现有的文件,仅供阅读。</target>
        </trans-unit>
        <trans-unit id="96179d121ec9cf7124c6c2755cce0f345158530b" translate="yes" xml:space="preserve">
          <source>Open file object or filename.</source>
          <target state="translated">打开文件对象或文件名。</target>
        </trans-unit>
        <trans-unit id="a6f0b5cd06c0857fa1094ec1c01c44ffc62a3722" translate="yes" xml:space="preserve">
          <source>Open text file with given encoding. The default encoding will be what &lt;a href=&quot;https://docs.python.org/dev/library/io.html#io.open&quot;&gt;&lt;code&gt;io.open&lt;/code&gt;&lt;/a&gt; uses.</source>
          <target state="translated">使用给定的编码打开文本文件。默认编码将是&lt;a href=&quot;https://docs.python.org/dev/library/io.html#io.open&quot;&gt; &lt;code&gt;io.open&lt;/code&gt; &lt;/a&gt;使用的编码。</target>
        </trans-unit>
        <trans-unit id="988a0621a69f95c126d429edd6ad72b8b9753d30" translate="yes" xml:space="preserve">
          <source>OpenBLAS</source>
          <target state="translated">OpenBLAS</target>
        </trans-unit>
        <trans-unit id="9e6729afd8b62e6a17fee3a65c668dbe74656c3a" translate="yes" xml:space="preserve">
          <source>OpenBLAS ILP64 with &lt;code&gt;64_&lt;/code&gt; symbol suffix (&lt;code&gt;openblas64_&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db258279bc027edbc14a901c4f72c25179352f5" translate="yes" xml:space="preserve">
          <source>OpenBLAS ILP64 without symbol suffix (&lt;code&gt;openblas_ilp64&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9413e771602d364356d827e1ba5484c54b2980c" translate="yes" xml:space="preserve">
          <source>OpenGL Half Float Pixel Support</source>
          <target state="translated">支持OpenGL半浮动像素</target>
        </trans-unit>
        <trans-unit id="92b199ce7b8a6cd2b986683aff11b8b6f7fca3cd" translate="yes" xml:space="preserve">
          <source>Openness &amp;amp; Transparency</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1fdaa6b2a846c8fcf18d414bf8c61db610eda6a" translate="yes" xml:space="preserve">
          <source>Operations</source>
          <target state="translated">Operations</target>
        </trans-unit>
        <trans-unit id="ba63388b76fb2354877e0a00827567f3e7dd9beb" translate="yes" xml:space="preserve">
          <source>Operations on masked arrays</source>
          <target state="translated">对掩码数组的操作</target>
        </trans-unit>
        <trans-unit id="52f32163af2ed7163e716ed54ad45e1abac6d362" translate="yes" xml:space="preserve">
          <source>Operations on masks</source>
          <target state="translated">面罩的操作</target>
        </trans-unit>
        <trans-unit id="ee87ced5cf49f6083697398814cf1d512f44d6ad" translate="yes" xml:space="preserve">
          <source>Operations on np.memmap objects return numpy arrays in most cases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ca78838064bd04174cc1a2b7101984f13a328d5" translate="yes" xml:space="preserve">
          <source>Operators &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt;, functions &lt;code&gt;dot()&lt;/code&gt;, and &lt;code&gt;multiply()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0563fccbe64a1dfd8037f51262c4fd0530cd94" translate="yes" xml:space="preserve">
          <source>Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing. Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.</source>
          <target state="translated">Oppenheim,A.V.,and R.W.Schafer.离散时间信号处理。Upper Saddle River,NJ:Prentice-Hall,1999,pp.468-471.</target>
        </trans-unit>
        <trans-unit id="dc6761ca91dcee4424a2851cbb50045197345e3f" translate="yes" xml:space="preserve">
          <source>Optimal &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (best usage pattern in some use cases): ~110ms</source>
          <target state="translated">最佳&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;（某些情况下为最佳使用模式）：〜110ms</target>
        </trans-unit>
        <trans-unit id="a6005faa183a89f9948e43f5a980447b421fb158" translate="yes" xml:space="preserve">
          <source>Optimizations for operations of the form &lt;code&gt;A.T @ A&lt;/code&gt; and &lt;code&gt;A @ A.T&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a9abbcaa67a245b7df3c4aa99c089ac4fab21b" translate="yes" xml:space="preserve">
          <source>Optimizing a looping block by specialized code. In a traditional sense, vectorization performs the same operation on multiple elements with fixed strides between them via specialized hardware. Compilers know how to take advantage of well-constructed loops to implement such optimizations. NumPy uses &lt;a href=&quot;user/whatisnumpy#whatis-vectorization&quot;&gt;vectorization&lt;/a&gt; to mean any optimization via specialized code performing the same operations on multiple elements, typically achieving speedups by avoiding some of the overhead in looking up and converting the elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92272bcec6c59382899a85edc8fe1911432803d7" translate="yes" xml:space="preserve">
          <source>Option whether to print a line feed or not. Defaults to True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1be0f36b97d1f66b6be8a1b7591fde1a83a0d94" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;axis&lt;/code&gt; argument for methods like &lt;a href=&quot;generated/numpy.random.generator.choice#numpy.random.Generator.choice&quot;&gt;&lt;code&gt;choice&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt;&lt;code&gt;permutation&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt; that controls which axis an operation is performed over for multi-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb8be51f4f30d13faa44a6de0502a01108e24089" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;dtype&lt;/code&gt; argument that accepts &lt;code&gt;np.float32&lt;/code&gt; or &lt;code&gt;np.float64&lt;/code&gt; to produce either single or double prevision uniform random variables for select distributions</source>
          <target state="translated">可选 &lt;code&gt;dtype&lt;/code&gt; 接受参数 &lt;code&gt;np.float32&lt;/code&gt; 或 &lt;code&gt;np.float64&lt;/code&gt; 以产生用于选择分布可以是单或双预知均匀随机变量</target>
        </trans-unit>
        <trans-unit id="12126826f76c7f0467a4ffb91534c1d1ec680e4d" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;out&lt;/code&gt; argument that allows existing arrays to be filled for select distributions</source>
          <target state="translated">可选的 &lt;code&gt;out&lt;/code&gt; 参数，允许为选择分布填充现有数组</target>
        </trans-unit>
        <trans-unit id="01273e336bfe0a367b1748fe162d52aafeac5e31" translate="yes" xml:space="preserve">
          <source>Optional arguments &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are interpreted as in slice notation.</source>
          <target state="translated">可选参数 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 解释为切片表示法。</target>
        </trans-unit>
        <trans-unit id="ad0126e97a8970efb03fe063de9451fa05d68f3f" translate="yes" xml:space="preserve">
          <source>Optional arguments &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are interpreted as slice notation to specify the range in which to count.</source>
          <target state="translated">可选参数 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 被解释为切片符号，以指定要计数的范围。</target>
        </trans-unit>
        <trans-unit id="4dd32917dfd5f66fb159ebdd50889a1b4bed7749" translate="yes" xml:space="preserve">
          <source>Optional array of integer indices that sort array a into ascending order. They are typically the result of argsort.</source>
          <target state="translated">可选的整数指数数组,对数组a进行升序排序。它们通常是argsort的结果。</target>
        </trans-unit>
        <trans-unit id="6024e1a91279063fb7e7889daf1b6251045d44cb" translate="yes" xml:space="preserve">
          <source>Optional character strings placed as the first element of the index expression can be used to change the output. The strings &amp;lsquo;r&amp;rsquo; or &amp;lsquo;c&amp;rsquo; result in matrix output. If the result is 1-D and &amp;lsquo;r&amp;rsquo; is specified a 1 x N (row) matrix is produced. If the result is 1-D and &amp;lsquo;c&amp;rsquo; is specified, then a N x 1 (column) matrix is produced. If the result is 2-D then both provide the same matrix result.</source>
          <target state="translated">放置在索引表达式的第一个元素中的可选字符串可用于更改输出。字符串&amp;ldquo; r&amp;rdquo;或&amp;ldquo; c&amp;rdquo;产生矩阵输出。如果结果为1-D并且指定了&amp;ldquo; r&amp;rdquo;，则将生成1 x N（行）矩阵。如果结果为1-D并且指定了'c'，则将生成N x 1（列）矩阵。如果结果为二维，则两者都提供相同的矩阵结果。</target>
        </trans-unit>
        <trans-unit id="fa7999c926f6055eca464cd4cd0189771a96574e" translate="yes" xml:space="preserve">
          <source>Optional keyword arguments</source>
          <target state="translated">可选关键词参数</target>
        </trans-unit>
        <trans-unit id="957ed642dc25daf64f22e9ce4f2d86f58626bccf" translate="yes" xml:space="preserve">
          <source>Optional keyword parameters have default values, which are displayed as part of the function signature. They can also be detailed in the description:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5739d18910534a4fc38a98f7f49af50c8efbd3" translate="yes" xml:space="preserve">
          <source>Optional reduced verbosity for np.distutils</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e7d5ecd852396fa81676288ee6a2c196a7a5edc" translate="yes" xml:space="preserve">
          <source>Optional: Check which files have changed with &lt;code&gt;git status&lt;/code&gt; (see &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-status.html&quot;&gt;git status&lt;/a&gt;). You&amp;rsquo;ll see a listing like this one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6f5f42f191b45dd21642dce26f8c271e45fd28" translate="yes" xml:space="preserve">
          <source>Optional: Compare the changes with the previous version using with &lt;code&gt;git
diff&lt;/code&gt; (&lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-diff.html&quot;&gt;git diff&lt;/a&gt;). This brings up a simple text browser interface that highlights the difference between your files and the previous version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb0ace95d7206d55e77238265b3a66f3d4c761a" translate="yes" xml:space="preserve">
          <source>Optionally Scipy-accelerated routines (&lt;code&gt;numpy.dual&lt;/code&gt;)</source>
          <target state="translated">可选的Scipy加速例程（ &lt;code&gt;numpy.dual&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="a841da812f87c91971335f8748cac5433932b134" translate="yes" xml:space="preserve">
          <source>Optionally Scipy-accelerated routines (numpy.dual)</source>
          <target state="translated">可选的Scipy加速例程(numpy.dual)</target>
        </trans-unit>
        <trans-unit id="8836fa518e3fcc554024b475844ea5ac0ecd26c6" translate="yes" xml:space="preserve">
          <source>Optionally, F2PY created signature files can be edited to optimize wrappers functions, make them &amp;ldquo;smarter&amp;rdquo; and more &amp;ldquo;Pythonic&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19671beddc2d78364aeb52dc43b5315cb3a7f11" translate="yes" xml:space="preserve">
          <source>Or a non uniform one:</source>
          <target state="translated">或者非统一的。</target>
        </trans-unit>
        <trans-unit id="8fe65c617425af9e2c3d6f2775ea339d5f9f089e" translate="yes" xml:space="preserve">
          <source>Or a similar way from the command line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="953f087657473d16d4beb73a89ced5320c3f6acc" translate="yes" xml:space="preserve">
          <source>Or an array filled with &lt;code&gt;1&lt;/code&gt;&amp;rsquo;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7ef857cc1fde38181b075860bab6fb0bd52da8" translate="yes" xml:space="preserve">
          <source>Or as a decorator:</source>
          <target state="translated">或者作为一个装饰者。</target>
        </trans-unit>
        <trans-unit id="c7e6a42ed35b95f820330f765f1edafa77be23aa" translate="yes" xml:space="preserve">
          <source>Or even an empty array! The function &lt;code&gt;empty&lt;/code&gt; creates an array whose initial content is random and depends on the state of the memory. The reason to use &lt;code&gt;empty&lt;/code&gt; over &lt;code&gt;zeros&lt;/code&gt; (or something similar) is speed - just make sure to fill every element afterwards!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de9b2d57a173de94af257f54a0e80ee07c9cf0f4" translate="yes" xml:space="preserve">
          <source>Or for a vectorized convolution:</source>
          <target state="translated">或者对于矢量化卷积。</target>
        </trans-unit>
        <trans-unit id="b0d8b33e98de773e2f38b3003cb0a7e130e442fc" translate="yes" xml:space="preserve">
          <source>Or from the command line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60d67dbe290ba345acdc7d9f67357d1c9ca90c84" translate="yes" xml:space="preserve">
          <source>Or if you add &lt;code&gt;scipy/xxx/tests/&lt;/code&gt; to the Python path, you could run the tests interactively in the interpreter like this:</source>
          <target state="translated">或者，如果将 &lt;code&gt;scipy/xxx/tests/&lt;/code&gt; 添加到Python路径，则可以在解释器中以交互方式运行测试，如下所示：</target>
        </trans-unit>
        <trans-unit id="86168e460ad3421414419c2552c4c8f1c87145ff" translate="yes" xml:space="preserve">
          <source>Or more generally, the f2cmap file must contain a dictionary with items:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a034f1d60dd7621f858f2d8cd0dbc13046363fae" translate="yes" xml:space="preserve">
          <source>Or reverse only the &lt;em&gt;columns&lt;/em&gt; with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="002d2f07f89a6dd55f4dbdba5b6f9608201e1d77" translate="yes" xml:space="preserve">
          <source>Or select specific elements to include:</source>
          <target state="translated">或者选择特定的元素来包含。</target>
        </trans-unit>
        <trans-unit id="91f70ad6cdb41e4acfd7bf765e82bbdee8fa8d5e" translate="yes" xml:space="preserve">
          <source>Or stack them horizontally with &lt;code&gt;hstack&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c3ddf3aab6700d937d53be3d5b45771f361386" translate="yes" xml:space="preserve">
          <source>Or wish to add a constant to all negative elements:</source>
          <target state="translated">或希望在所有负数元素中增加一个常数。</target>
        </trans-unit>
        <trans-unit id="9ed306dae12d1d39fff858942862ae59bbc4399d" translate="yes" xml:space="preserve">
          <source>Or without &lt;code&gt;np.ix_&lt;/code&gt; (compare the integer array examples):</source>
          <target state="translated">或不使用 &lt;code&gt;np.ix_&lt;/code&gt; （比较整数数组示例）：</target>
        </trans-unit>
        <trans-unit id="05b188193e465d376dab17b5c2f6bf78bee37c0c" translate="yes" xml:space="preserve">
          <source>Or you can open the file any time with a text editor!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97c15fab9ba4d55adcaf397914137e45e790605" translate="yes" xml:space="preserve">
          <source>Or you can select elements that satisfy two conditions using the &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt; operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522e527e2f2a0e03657e01d30970c004e213dc85" translate="yes" xml:space="preserve">
          <source>Or, for a column vector, you can insert an axis along the second dimension:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0c3124f81c1d85f2179239c9449534ba1cd1e5" translate="yes" xml:space="preserve">
          <source>Or, if you start with these arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="57f93044bc0a408687e6b01e33395f89ff4d70a4" translate="yes" xml:space="preserve">
          <source>Order of differentiation (default: 1)</source>
          <target state="translated">分化顺序(默认:1</target>
        </trans-unit>
        <trans-unit id="788c2fe754b6f79f4fc9b0b665993b8ce7234c19" translate="yes" xml:space="preserve">
          <source>Order of integration, must be positive. (Default: 1)</source>
          <target state="translated">整合顺序,必须为正值。(缺省:1)</target>
        </trans-unit>
        <trans-unit id="a5353df5e917b478408b634f2bf535553074c600" translate="yes" xml:space="preserve">
          <source>Order of operations optimization in &lt;code&gt;np.einsum&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ad4bbf3f62befe7c196979bd8380406f97a913" translate="yes" xml:space="preserve">
          <source>Order of the antiderivative. (Default: 1)</source>
          <target state="translated">反赋值的顺序。(缺省:1)</target>
        </trans-unit>
        <trans-unit id="c2ecce42b9cac400a1b6d5085507c247c9b755ae" translate="yes" xml:space="preserve">
          <source>Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</source>
          <target state="translated">多维数组的数据顺序。C,Fortran,或与原数组相同。</target>
        </trans-unit>
        <trans-unit id="1c001b919a2f52d0fbb20d49a83e3f37a24b3cfa" translate="yes" xml:space="preserve">
          <source>Order of the data item in the copy. Default is &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">副本中数据项的顺序。默认值为&amp;ldquo; C&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="46f142fafd57c235130d4ec687878d429370c853" translate="yes" xml:space="preserve">
          <source>Order of the norm (see table under &lt;code&gt;Notes&lt;/code&gt;). inf means numpy&amp;rsquo;s &lt;code&gt;inf&lt;/code&gt; object.</source>
          <target state="translated">规范的顺序（请参阅&amp;ldquo; &lt;code&gt;Notes&lt;/code&gt; 下的表）。inf表示numpy的 &lt;code&gt;inf&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="b66f9f860fc227b1d5431e30c1b51053269954ff" translate="yes" xml:space="preserve">
          <source>Order of the norm (see table under &lt;code&gt;Notes&lt;/code&gt;). inf means numpy&amp;rsquo;s &lt;code&gt;inf&lt;/code&gt; object. The default is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="accc210a4b093569ae3685cc2f2612720dea8f1e" translate="yes" xml:space="preserve">
          <source>Order of the norm:</source>
          <target state="translated">规范的秩序。</target>
        </trans-unit>
        <trans-unit id="b8a7abb1120bc925fdb57310f93f2fa464fdc7ae" translate="yes" xml:space="preserve">
          <source>Order of the powers of the columns. If True, the powers increase from left to right, if False (the default) they are reversed.</source>
          <target state="translated">列的幂的顺序。如果为True,则从左到右递增,如果为False(默认),则相反。</target>
        </trans-unit>
        <trans-unit id="9ad696b93bae4cfca8937f28f2148899d7322e0a" translate="yes" xml:space="preserve">
          <source>Order statistics</source>
          <target state="translated">订单统计</target>
        </trans-unit>
        <trans-unit id="422e3f686c9f8818631b86e59adef2a48327ba9b" translate="yes" xml:space="preserve">
          <source>Ordered list of field names, or &lt;code&gt;None&lt;/code&gt; if there are no fields.</source>
          <target state="translated">字段名称的有序列表，如果没有字段，则为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="8d44d98096c18e71b1176f355d8b6f0c7c16e1d1" translate="yes" xml:space="preserve">
          <source>Ordinary inner product for vectors:</source>
          <target state="translated">向量的普通内积。</target>
        </trans-unit>
        <trans-unit id="191b600520d98586a88c24fcdd4e2889be08fced" translate="yes" xml:space="preserve">
          <source>Ordinary inner product of vectors for 1-D arrays (without complex conjugation), in higher dimensions a sum product over the last axes.</source>
          <target state="translated">一维数组向量的普通内积(无复共轭),在更高维度上是最后一轴的和积。</target>
        </trans-unit>
        <trans-unit id="eb7dc7265e25691a9373e1ca80276306cb88c7ca" translate="yes" xml:space="preserve">
          <source>Ordinate or &amp;ldquo;dependent variable&amp;rdquo; values.</source>
          <target state="translated">普通或&amp;ldquo;因变量&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="8c7ff7749bfea5af2d2c09b7c86b2dbdfee56f2a" translate="yes" xml:space="preserve">
          <source>Ordinate or &amp;ldquo;dependent variable&amp;rdquo; values. If &lt;code&gt;b&lt;/code&gt; is two-dimensional, the least-squares solution is calculated for each of the &lt;code&gt;K&lt;/code&gt; columns of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">普通或&amp;ldquo;因变量&amp;rdquo;值。如果 &lt;code&gt;b&lt;/code&gt; 是二维的，则为 &lt;code&gt;b&lt;/code&gt; 的 &lt;code&gt;K&lt;/code&gt; 列中的每列计算最小二乘解。</target>
        </trans-unit>
        <trans-unit id="bedfebf0ecf8e3c63711ee41881ab8ce7f77971c" translate="yes" xml:space="preserve">
          <source>Original Source</source>
          <target state="translated">原始来源</target>
        </trans-unit>
        <trans-unit id="92bff9048309d096b7578598a0790ad0978b76db" translate="yes" xml:space="preserve">
          <source>Original Source of the Generator and BitGenerators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d77937700b7f6304cd9cc6f6f114b310986845" translate="yes" xml:space="preserve">
          <source>Original positions of the axes to move. These must be unique.</source>
          <target state="translated">要移动的轴的原始位置。这些位置必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="34d7150cfcec917eee04da671286a02a27c1a6b8" translate="yes" xml:space="preserve">
          <source>Other (void * &amp;ndash; each item is a fixed-size chunk of memory)</source>
          <target state="translated">其他（无效* &amp;ndash;每个项目都是固定大小的内存块）</target>
        </trans-unit>
        <trans-unit id="16863278e548d66fae935c08b81b275cea6f9914" translate="yes" xml:space="preserve">
          <source>Other C-Structures</source>
          <target state="translated">其他C型结构</target>
        </trans-unit>
        <trans-unit id="c5164a0d79a937ac6a201b20d3ffe5ea4af04bc1" translate="yes" xml:space="preserve">
          <source>Other Common Types: bool</source>
          <target state="translated">其他常见类型:bool</target>
        </trans-unit>
        <trans-unit id="9a529214aef07d296fc3d4d086152694a3e98921" translate="yes" xml:space="preserve">
          <source>Other Common Types: complex</source>
          <target state="translated">其他常见类型:复杂</target>
        </trans-unit>
        <trans-unit id="708bf6f62e354ff314651598e7eebc62fd8d2bb2" translate="yes" xml:space="preserve">
          <source>Other Parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0faa321ae463cf423d057b0fb19c09b0142f3c2a" translate="yes" xml:space="preserve">
          <source>Other Parameters:</source>
          <target state="translated">其他参数:</target>
        </trans-unit>
        <trans-unit id="3a704886f69c3b776903fa1eae3b74661fb05227" translate="yes" xml:space="preserve">
          <source>Other Polynomial Constructors</source>
          <target state="translated">其他多项式构造器</target>
        </trans-unit>
        <trans-unit id="407cab4f45e3f1e45a4d3d8364006412c6cfc5cd" translate="yes" xml:space="preserve">
          <source>Other Situations</source>
          <target state="translated">其他情况</target>
        </trans-unit>
        <trans-unit id="d042bb243a9d93f7d217c6e5a0c1a49c971c43e7" translate="yes" xml:space="preserve">
          <source>Other attributes</source>
          <target state="translated">其他属性</target>
        </trans-unit>
        <trans-unit id="e84477e1de2ec14b541d8664b31b8881de493393" translate="yes" xml:space="preserve">
          <source>Other axes remain in their original order.</source>
          <target state="translated">其他轴保持原来的顺序。</target>
        </trans-unit>
        <trans-unit id="94a56f444dca5dd30ab9a1fe9100b3b01d86f467" translate="yes" xml:space="preserve">
          <source>Other build options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767a6c3afafd0ae34a74385fb566d6175cb96b17" translate="yes" xml:space="preserve">
          <source>Other constants</source>
          <target state="translated">其他常数</target>
        </trans-unit>
        <trans-unit id="ed4b1121b10e2ed9c2b0a79e79f85e8ad19d33ae" translate="yes" xml:space="preserve">
          <source>Other conversions</source>
          <target state="translated">其他转换</target>
        </trans-unit>
        <trans-unit id="b0c0a3787c5b36b4fe5b178d91a655c6a5cbdf6b" translate="yes" xml:space="preserve">
          <source>Other files</source>
          <target state="translated">其他文件</target>
        </trans-unit>
        <trans-unit id="e12e322f5b694198963cd183428de579cc666876" translate="yes" xml:space="preserve">
          <source>Other functions</source>
          <target state="translated">其他功能</target>
        </trans-unit>
        <trans-unit id="1cddb5c0e17d84098d16d9325f9cc36b4d8d05b6" translate="yes" xml:space="preserve">
          <source>Other indexing options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b002f2786124a662470fe9d1d4b2061560ed34" translate="yes" xml:space="preserve">
          <source>Other keys that can be used to set a group of types at once are:</source>
          <target state="translated">其他可用于同时设置一组类型的键是:</target>
        </trans-unit>
        <trans-unit id="ee6b0460067623519cc565a472bd480c100039cf" translate="yes" xml:space="preserve">
          <source>Other modules</source>
          <target state="translated">其他模块</target>
        </trans-unit>
        <trans-unit id="486d94e1070b48b0053b9b70f1f9be9f4d9d5bf1" translate="yes" xml:space="preserve">
          <source>Other new functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="599ffbd6e95e9102a19874cfc765e0666e6a5f25" translate="yes" xml:space="preserve">
          <source>Other options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a99a2c4e58511e531864aed996a281648e9837a1" translate="yes" xml:space="preserve">
          <source>Other points to keep in mind</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312a81da2e8af18ed2deb2ba9e65ed60e75f7dbe" translate="yes" xml:space="preserve">
          <source>Other related special value functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56243f47f05b7964d5f4fc1a7a1d5dc330f1664" translate="yes" xml:space="preserve">
          <source>Other special functions</source>
          <target state="translated">其他特殊功能</target>
        </trans-unit>
        <trans-unit id="9cc692beb493cdd7b095a31706521fdb297cd3ab" translate="yes" xml:space="preserve">
          <source>Other statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b28f6f004c86b1b4979a17c950470ea4d696d78" translate="yes" xml:space="preserve">
          <source>Other than the view syntax, the function is immediately readable to a Python programmer. Static typing of the variable &lt;code&gt;i&lt;/code&gt; is implicit. Instead of the view syntax, we could also have used Cython&amp;rsquo;s special NumPy array syntax, but the view syntax is preferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db156a16585b32767d434efac29632f353ee893f" translate="yes" xml:space="preserve">
          <source>Other useful flags that can be OR&amp;rsquo;d as additional requirements are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80ae13d27005970d36a64205ad27c701906310c" translate="yes" xml:space="preserve">
          <source>Other useful related constants are</source>
          <target state="translated">其他有用的相关常数有</target>
        </trans-unit>
        <trans-unit id="da626da9b3eb80a71166ddec09244cef236be1ee" translate="yes" xml:space="preserve">
          <source>Other ways to contribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b60a0a7b60b2c507b8c7be2f403c23dd728c5542" translate="yes" xml:space="preserve">
          <source>Otherwise F2PY makes a contiguous copy (with a proper dtype) of the input array and passes C pointer of the copy to Fortran subroutine. As a result, any possible changes to the (copy of) input array have no effect to the original argument, as demonstrated below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01dc3acd71c35a47919d5dc18e67e38bbe2ca711" translate="yes" xml:space="preserve">
          <source>Otherwise we recommend simply learning to reverse the usual order of indices when accessing elements of an array. Granted, it goes against the grain, but it is more in line with Python semantics and the natural order of the data.</source>
          <target state="translated">否则,我们建议简单地学习在访问数组元素时将通常的索引顺序反过来。诚然,这有违常理,但它更符合Python语义和数据的自然顺序。</target>
        </trans-unit>
        <trans-unit id="29b9f8169fedb0ad1c9be824eca55314fa16d94e" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt; is called on each array, and the resulting data types are all combined with &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">否则，将在每个数组上调用&lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; &lt;/a&gt;，并且将所得的数据类型都与&lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt;组合在一起以产生返回值。</target>
        </trans-unit>
        <trans-unit id="fae9e7a3585b77fe783d86ad593d20c5ecc3f354" translate="yes" xml:space="preserve">
          <source>Otherwise, PyArray_MinScalarType is called on each array, and the resulting data types are all combined with &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt;&lt;code&gt;PyArray_PromoteTypes&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">否则，将在每个数组上调用PyArray_MinScalarType，并将结果数据类型全部与&lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt; &lt;code&gt;PyArray_PromoteTypes&lt;/code&gt; &lt;/a&gt;组合以产生返回值。</target>
        </trans-unit>
        <trans-unit id="a5347d369bb3cc80acdc3e9eec52dbe20542bf3e" translate="yes" xml:space="preserve">
          <source>Otherwise, only the &lt;code&gt;zip&lt;/code&gt; and &lt;code&gt;pdf&lt;/code&gt; links should be updated with the new tag name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd38ba9fb1f1dbc35dcac58860b6157e6882b67" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;MySubClass.__new__&lt;/code&gt; method only gets called in the case of the explicit constructor call, so we can&amp;rsquo;t rely on &lt;code&gt;MySubClass.__new__&lt;/code&gt; or &lt;code&gt;MySubClass.__init__&lt;/code&gt; to deal with the view casting and new-from-template. It turns out that &lt;code&gt;MySubClass.__array_finalize__&lt;/code&gt;&lt;em&gt;does&lt;/em&gt; get called for all three methods of object creation, so this is where our object creation housekeeping usually goes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5388893497a63e10962c70e1e04399dd9d5a42e3" translate="yes" xml:space="preserve">
          <source>Our custom array can be instantiated like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf78b3f6f52a00f298a7bfb0726e5baf2bd452dd" translate="yes" xml:space="preserve">
          <source>Our docstring standard uses &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;re-structured text (reST)&lt;/a&gt; syntax and is rendered using &lt;a href=&quot;http://sphinx.pocoo.org&quot;&gt;Sphinx&lt;/a&gt; (a pre-processor that understands the particular documentation style we are using). While a rich set of markup is available, we limit ourselves to a very basic subset, in order to provide docstrings that are easy to read on text-only terminals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699b767a44afe4a72b5254c097705dfd2fc0c0eb" translate="yes" xml:space="preserve">
          <source>Our final example is a ufunc with multiple arguments. It is a modification of the code for a logit ufunc for data with a single dtype. We compute (A*B, logit(A*B)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4eb13334b28d2a094a12f8ab9ba2e910911e99a" translate="yes" xml:space="preserve">
          <source>Our goal is that every module and package in SciPy and NumPy should have a thorough set of unit tests. These tests should exercise the full functionality of a given routine as well as its robustness to erroneous or unexpected input arguments. Long experience has shown that by far the best time to write the tests is before you write or change the code - this is &lt;a href=&quot;https://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;test-driven development&lt;/a&gt;. The arguments for this can sound rather abstract, but we can assure you that you will find that writing the tests first leads to more robust and better designed code. Well-designed tests with good coverage make an enormous difference to the ease of refactoring. Whenever a new bug is found in a routine, you should write a new test for that specific case and add it to the test suite to prevent that bug from creeping back in unnoticed.</source>
          <target state="translated">我们的目标是SciPy和NumPy中的每个模块和软件包都应具有一套完整的单元测试。这些测试应使用给定例程的全部功能，以及对错误或意外输入参数的鲁棒性。长期的经验表明，到目前为止，编写测试的最佳时间是在编写或更改代码之前-这是&lt;a href=&quot;https://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;测试驱动的开发&lt;/a&gt;。这听起来很抽象，但是我们可以向您保证，您会发现编写测试首先会导致更健壮和更好地设计代码。设计良好且覆盖面广的测试对重构的便利性产生了巨大的影响。每当在例程中发现新错误时，您都应针对该特定情况编写一个新测试，并将其添加到测试套件中，以防止该错误再次被发现。</target>
        </trans-unit>
        <trans-unit id="d68e5db67be9b03d20fd91c37de52993f3c9d547" translate="yes" xml:space="preserve">
          <source>Our main means of communication are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="092ac50b2f1d2b5a2fd5de4d521d3e71263ef97d" translate="yes" xml:space="preserve">
          <source>Our own &lt;a href=&quot;http://matthew-brett.github.com/pydagogue/foundation.html&quot;&gt;git foundation&lt;/a&gt; expands on the &lt;a href=&quot;http://tom.preston-werner.com/2009/05/19/the-git-parable.html&quot;&gt;git parable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="154d74419b6aca893341269b8ba48a9e26a16006" translate="yes" xml:space="preserve">
          <source>Out has the same shape as &lt;code&gt;x&lt;/code&gt;. Its real part is in &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt; (&lt;code&gt;arctan(+/-inf)&lt;/code&gt; returns &lt;code&gt;+/-pi/2&lt;/code&gt;). This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Out与 &lt;code&gt;x&lt;/code&gt; 具有相同的形状。它的实部在 &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt; （ &lt;code&gt;arctan(+/-inf)&lt;/code&gt; 返回 &lt;code&gt;+/-pi/2&lt;/code&gt; ）。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="851f8da769fc08fe920a7a332149d07bd3e21638" translate="yes" xml:space="preserve">
          <source>Out of the box, &lt;code&gt;numpy.i&lt;/code&gt; provides typemaps that support conversion between NumPy arrays and C arrays:</source>
          <target state="translated">现成的 &lt;code&gt;numpy.i&lt;/code&gt; 提供了支持NumPy数组和C数组之间转换的类型映射：</target>
        </trans-unit>
        <trans-unit id="b99f04d1fc495fb457ec6ab4bb045f1b70e94783" translate="yes" xml:space="preserve">
          <source>Outer Product Iteration</source>
          <target state="translated">外部产品迭代</target>
        </trans-unit>
        <trans-unit id="c6ee0caa49ecd5d48b8b76e247cdb1d691fc307b" translate="yes" xml:space="preserve">
          <source>Outer product, same as &lt;code&gt;outer(x, y)&lt;/code&gt;:</source>
          <target state="translated">外部乘积，与 &lt;code&gt;outer(x, y)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f31dd41cdb77529134dabee0a5149b6913233527" translate="yes" xml:space="preserve">
          <source>Outer product.</source>
          <target state="translated">外品。</target>
        </trans-unit>
        <trans-unit id="a8eb7f250550fb11f31a150896a2c233c22e5afb" translate="yes" xml:space="preserve">
          <source>Output Arrays</source>
          <target state="translated">输出阵列</target>
        </trans-unit>
        <trans-unit id="69721e85622681a00d5e83b618b8602f51f2805c" translate="yes" xml:space="preserve">
          <source>Output a 3x8000 array:</source>
          <target state="translated">输出一个3x8000的阵列。</target>
        </trans-unit>
        <trans-unit id="7156471f771c478a3049744cdf9adc5be3b74b53" translate="yes" xml:space="preserve">
          <source>Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for &lt;code&gt;dot(a, b)&lt;/code&gt;. This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e70b270c18c83f26e6230a7a984b1fb40cee94" translate="yes" xml:space="preserve">
          <source>Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for &lt;code&gt;dot(a,b)&lt;/code&gt;. This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.</source>
          <target state="translated">输出参数。如果没有使用，则必须具有返回的确切类型。特别是，它必须具有正确的类型，必须是C连续的，并且它的dtype必须是为 &lt;code&gt;dot(a,b)&lt;/code&gt; 返回的dtype 。这是一项性能功能。因此，如果不满足这些条件，则会引发异常，而不是尝试变得灵活。</target>
        </trans-unit>
        <trans-unit id="6e978531d306139571810dad3cc0f8a44d943b22" translate="yes" xml:space="preserve">
          <source>Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for &lt;code&gt;ma.dot(a,b)&lt;/code&gt;. This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a83f71ed49812b1c51736e820cd87f0f9865fcb1" translate="yes" xml:space="preserve">
          <source>Output arguments to ufuncs can be tuples also for ufunc methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f12acadc64d21e2feac22d1a1b4692fb105ee3" translate="yes" xml:space="preserve">
          <source>Output array</source>
          <target state="translated">输出阵列</target>
        </trans-unit>
        <trans-unit id="f89327ce1837e2c79277b79c5f26d1462b21d4b0" translate="yes" xml:space="preserve">
          <source>Output array for the exponent. Must have the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">指数的输出数组。必须具有与 &lt;code&gt;x&lt;/code&gt; 相同的形状。</target>
        </trans-unit>
        <trans-unit id="ce4222d68677642db5d8cd581c2069a152c5cd0e" translate="yes" xml:space="preserve">
          <source>Output array for the mantissa. Must have the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">尾数的输出数组。必须具有与 &lt;code&gt;x&lt;/code&gt; 相同的形状。</target>
        </trans-unit>
        <trans-unit id="d1138d70b1d22742de8a7eec1ca180e5192ab003" translate="yes" xml:space="preserve">
          <source>Output array is same shape and type as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">输出数组的形状和类型与 &lt;code&gt;x&lt;/code&gt; 相同。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="9ef051a2e330bee8268ab4c049205eb02d245cc1" translate="yes" xml:space="preserve">
          <source>Output array of &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, depending on input types of the same shape as &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string_&lt;/code&gt; 或 &lt;code&gt;unicode_&lt;/code&gt; 的输出数组，取决于形状与 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 相同的输入类型。</target>
        </trans-unit>
        <trans-unit id="5cd088a12712ab8d4c2c426261156c01f4ed1606" translate="yes" xml:space="preserve">
          <source>Output array of bools</source>
          <target state="translated">输出的bool数组</target>
        </trans-unit>
        <trans-unit id="32b7b13439f3e6221fd4780b32449d5d4d7f2b86" translate="yes" xml:space="preserve">
          <source>Output array of bools, or a single bool if x1 and x2 are scalars.</source>
          <target state="translated">输出bool数组,如果x1和x2是标量,则输出单个bool。</target>
        </trans-unit>
        <trans-unit id="59628506899dd565c36cb8637802ca8d03d5a7e8" translate="yes" xml:space="preserve">
          <source>Output array of indices, of same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;x&lt;/code&gt; 形状相同的索引输出数组。</target>
        </trans-unit>
        <trans-unit id="5ee5c2cea50e4665a7ae56f4b3614a03fe2437d2" translate="yes" xml:space="preserve">
          <source>Output array of integers</source>
          <target state="translated">输出整数数组</target>
        </trans-unit>
        <trans-unit id="7e2593695a5d88e14bbbac4809c3409ae05309b7" translate="yes" xml:space="preserve">
          <source>Output array of ints.</source>
          <target state="translated">输出的ints数组。</target>
        </trans-unit>
        <trans-unit id="52a772b58c524d2ad00244b1064922aec6a445c6" translate="yes" xml:space="preserve">
          <source>Output array of ints. Return -1 on failure.</source>
          <target state="translated">输出ints数组。失败时返回-1。</target>
        </trans-unit>
        <trans-unit id="a30063ccd5b6202d238ce61d0b6db2952ded8310" translate="yes" xml:space="preserve">
          <source>Output array of ints. Returns -1 if &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">输出int数组。如果未找到 &lt;code&gt;sub&lt;/code&gt; ,则返回-1 。</target>
        </trans-unit>
        <trans-unit id="9735bcc93d569bce2b6e7befd7418f0ba4b716c9" translate="yes" xml:space="preserve">
          <source>Output array of same shape as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">输出形状与 &lt;code&gt;x&lt;/code&gt; 相同的数组。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="a38bebcd0d7b96b1c608bbee88ef6bc304e314b0" translate="yes" xml:space="preserve">
          <source>Output array of str or unicode, depending on input type</source>
          <target state="translated">根据输入类型,输出str或unicode数组。</target>
        </trans-unit>
        <trans-unit id="58c2378e8c8946ae97f1ea7dac73a13c10abcd50" translate="yes" xml:space="preserve">
          <source>Output array of str or unicode, depending on input type. The output array will have an extra dimension with 3 elements per input element.</source>
          <target state="translated">输出str或unicode的数组,取决于输入类型。输出数组将有一个额外的维度,每个输入元素有3个元素。</target>
        </trans-unit>
        <trans-unit id="64d5dcb1c0c304c381fa58f443d7ded824e0bc47" translate="yes" xml:space="preserve">
          <source>Output array of str or unicode, depending on input types</source>
          <target state="translated">根据输入类型,输出str或unicode数组。</target>
        </trans-unit>
        <trans-unit id="fd13d84379a70df2e078233919d2189882423201" translate="yes" xml:space="preserve">
          <source>Output array of string or unicode, depending on input type. The output array will have an extra dimension with 3 elements per input element.</source>
          <target state="translated">输出字符串或unicode的数组,取决于输入类型。输出数组将有一个额外的维度,每个输入元素有3个元素。</target>
        </trans-unit>
        <trans-unit id="f7c9fa3972ed6e6a39e0733beb489d1ce3ad7791" translate="yes" xml:space="preserve">
          <source>Output array which has the same shape as &lt;code&gt;a&lt;/code&gt;, except along the given axis.</source>
          <target state="translated">输出阵列，其具有相同的形状作为 &lt;code&gt;a&lt;/code&gt; ，除了沿给定轴。</target>
        </trans-unit>
        <trans-unit id="b3c1a1cbd46397d96a8e1319b9f70d2c4e83a943" translate="yes" xml:space="preserve">
          <source>Output array, containing the indices of the elements of &lt;code&gt;a.ravel()&lt;/code&gt; that are non-zero.</source>
          <target state="translated">输出数组，包含非零的 &lt;code&gt;a.ravel()&lt;/code&gt; 元素的索引。</target>
        </trans-unit>
        <trans-unit id="307c943561bf0b8b5ee1a6f51fb083d57904faed" translate="yes" xml:space="preserve">
          <source>Output array, element-wise comparison of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;. Typically of type bool, unless &lt;code&gt;dtype=object&lt;/code&gt; is passed. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">输出数组， &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 的逐元素比较。通常为bool类型，除非传递了 &lt;code&gt;dtype=object&lt;/code&gt; 。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="2e21fc9917d319d6359f007add3068ca89130f62" translate="yes" xml:space="preserve">
          <source>Output array, element-wise exponential of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">输出数组， &lt;code&gt;x&lt;/code&gt; 的按元素指数。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="16e86016f9dd58438b33f8fa3832e0a84ce8bad6" translate="yes" xml:space="preserve">
          <source>Output array, or reference to &lt;code&gt;out&lt;/code&gt; if that was supplied. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">输出数组，如果提供则引用 &lt;code&gt;out&lt;/code&gt; 。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="1c4ffa82eda162fa8929d170e0a0f647fbc47d46" translate="yes" xml:space="preserve">
          <source>Output array, with the same shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">输出数组，与相同形状的 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c7fe807ab5dc7a002fea6ec306d2d20dd6cd310" translate="yes" xml:space="preserve">
          <source>Output array.</source>
          <target state="translated">输出阵列。</target>
        </trans-unit>
        <trans-unit id="bfcf0a026c1c1c3df16d07e5c463c5d22ef8d769" translate="yes" xml:space="preserve">
          <source>Output array. Its type is preserved and it must be of the right shape to hold the output.</source>
          <target state="translated">输出数组。它的类型被保留下来,并且必须是正确的形状来容纳输出。</target>
        </trans-unit>
        <trans-unit id="21470ea6838153d93bb789847f1e781e9233d56c" translate="yes" xml:space="preserve">
          <source>Output formatting</source>
          <target state="translated">输出格式化</target>
        </trans-unit>
        <trans-unit id="ebe7bf947438344dfee2f421c7f0822ca9d92fa3" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. Default is None, in which case a vector of length &lt;code&gt;k&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a267ec8ecd4cabb56c1672c1c1515df13c271b4b" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn from the 1-d &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has more than one dimension, the &lt;code&gt;size&lt;/code&gt; shape will be inserted into the &lt;code&gt;axis&lt;/code&gt; dimension, so the output &lt;code&gt;ndim&lt;/code&gt; will be &lt;code&gt;a.ndim - 1 +
len(size)&lt;/code&gt;. Default is None, in which case a single value is returned.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则从1-d &lt;code&gt;a&lt;/code&gt; 提取 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果 &lt;code&gt;a&lt;/code&gt; 具有多个尺寸，则将 &lt;code&gt;size&lt;/code&gt; 形状插入到 &lt;code&gt;axis&lt;/code&gt; 尺寸中，因此输出 &lt;code&gt;ndim&lt;/code&gt; 将为 &lt;code&gt;a.ndim - 1 + len(size)&lt;/code&gt; 。默认值为无，在这种情况下，将返回一个值。</target>
        </trans-unit>
        <trans-unit id="d2424a491af135ae36f950b7ab0516bd18ace8df" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. Default is None, in which case a single value is returned.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。默认值为无，在这种情况下，将返回一个值。</target>
        </trans-unit>
        <trans-unit id="89e56aa13faf2ac19ffb0b3e5e716f7bfddc1ab9" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(a, b).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），则如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 均为标量，则返回单个值。否则，将 &lt;code&gt;np.broadcast(a, b).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="55b478ddcb62162e8ce07219dee1d9d6ca7a8be6" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;a&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(a).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），则当 &lt;code&gt;a&lt;/code&gt; 为标量时返回单个值。否则，将绘制 &lt;code&gt;np.array(a).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="bad13c9c05fba2155bd76b001de567b59798e200" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;df&lt;/code&gt; and &lt;code&gt;nonc&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(df, nonc).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），并且 &lt;code&gt;df&lt;/code&gt; 和 &lt;code&gt;nonc&lt;/code&gt; 均为标量，则返回单个值。否则，将 &lt;code&gt;np.broadcast(df, nonc).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="738b6886d61591bdc17ae069de249790d6b71087" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;df&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(df).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），并且 &lt;code&gt;df&lt;/code&gt; 是标量，则返回单个值。否则，将绘制 &lt;code&gt;np.array(df).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="ae475a1d95fefab6fd2f2bedb6223f991fcc41b6" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;dfnum&lt;/code&gt; and &lt;code&gt;dfden&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(dfnum, dfden).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），并且 &lt;code&gt;dfnum&lt;/code&gt; 和 &lt;code&gt;dfden&lt;/code&gt; 均为标量，则返回单个值。否则，将 &lt;code&gt;np.broadcast(dfnum, dfden).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="46a9903f305b04fd0f7d5079b4658c01625926e1" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;dfnum&lt;/code&gt;, &lt;code&gt;dfden&lt;/code&gt;, and &lt;code&gt;nonc&lt;/code&gt; are all scalars. Otherwise, &lt;code&gt;np.broadcast(dfnum, dfden, nonc).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），并且 &lt;code&gt;dfnum&lt;/code&gt; ， &lt;code&gt;dfden&lt;/code&gt; 和 &lt;code&gt;nonc&lt;/code&gt; 均为标量，则返回单个值。否则，将 &lt;code&gt;np.broadcast(dfnum, dfden, nonc).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="cf9a357ee338f25bf2bcb1c6a39d7e36ff751b6d" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;lam&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(lam).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），则如果 &lt;code&gt;lam&lt;/code&gt; 是标量，则返回单个值。否则，将绘制 &lt;code&gt;np.array(lam).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="6bfc36fdff77cbd952a127d76db752bf9585b331" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;mode&lt;/code&gt;, and &lt;code&gt;right&lt;/code&gt; are all scalars. Otherwise, &lt;code&gt;np.broadcast(left, mode, right).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），则当 &lt;code&gt;left&lt;/code&gt; ， &lt;code&gt;mode&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 是所有标量时，将返回单个值。否则，将 &lt;code&gt;np.broadcast(left, mode, right).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="221f43b3f6b78ea4ffc570a2b4686a11e53b9689" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;loc&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(loc, scale).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），并且 &lt;code&gt;loc&lt;/code&gt; 和 &lt;code&gt;scale&lt;/code&gt; 均为标量，则返回单个值。否则，将 &lt;code&gt;np.broadcast(loc, scale).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="4282c4067b87ca3f0f86b5fc7e0e58c780e280c3" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;low&lt;/code&gt; and &lt;code&gt;high&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(low, high).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），则 &lt;code&gt;low&lt;/code&gt; 和 &lt;code&gt;high&lt;/code&gt; 均为标量，则返回单个值。否则，将 &lt;code&gt;np.broadcast(low, high).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="d0683da40c0442ae9f7198c7d720ea85a5de1b4d" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;mean&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(mean, scale).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），并且 &lt;code&gt;mean&lt;/code&gt; 和 &lt;code&gt;scale&lt;/code&gt; 均为标量，则返回单个值。否则，将 &lt;code&gt;np.broadcast(mean, scale).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="0de49618d9158d1b17813c0b098c763f862b1d88" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;mean&lt;/code&gt; and &lt;code&gt;sigma&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(mean, sigma).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），并且 &lt;code&gt;mean&lt;/code&gt; 和 &lt;code&gt;sigma&lt;/code&gt; 均为标量，则返回单个值。否则，将 &lt;code&gt;np.broadcast(mean, sigma).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="4e92a7af3b2b74719c734b754039059712af838b" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;mu&lt;/code&gt; and &lt;code&gt;kappa&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(mu, kappa).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），则当 &lt;code&gt;mu&lt;/code&gt; 和 &lt;code&gt;kappa&lt;/code&gt; 均为标量时，将返回单个值。否则，将 &lt;code&gt;np.broadcast(mu, kappa).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="508329c1fbd22ad6be84a6836708268204490867" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(n, p).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），则如果 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt; 均为标量，则返回单个值。否则，将 &lt;code&gt;np.broadcast(n, p).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="b122820c89df713b07cfbc58626294123f0af0a3" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;ngood&lt;/code&gt;, &lt;code&gt;nbad&lt;/code&gt;, and &lt;code&gt;nsample&lt;/code&gt; are all scalars. Otherwise, &lt;code&gt;np.broadcast(ngood, nbad, nsample).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），则如果 &lt;code&gt;ngood&lt;/code&gt; ， &lt;code&gt;nbad&lt;/code&gt; 和 &lt;code&gt;nsample&lt;/code&gt; 均为标量，则返回单个值。否则，将 &lt;code&gt;np.broadcast(ngood, nbad, nsample).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="27d2ec43f10ca379398aac021ba6a41147bbbdc4" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;p&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(p).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），则当 &lt;code&gt;p&lt;/code&gt; 为标量时返回单个值。否则，将绘制 &lt;code&gt;np.array(p).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="df56295e78bed4d72315ff68acac7d0f9dadfb30" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;scale&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(scale).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），则在 &lt;code&gt;scale&lt;/code&gt; 为标量时返回单个值。否则，将绘制 &lt;code&gt;np.array(scale).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="948b72efe91fbed7c1a9b81472148fc726a10ddb" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(shape, scale).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），则 &lt;code&gt;shape&lt;/code&gt; 和 &lt;code&gt;scale&lt;/code&gt; 均为标量时，将返回单个值。否则，将 &lt;code&gt;np.broadcast(shape, scale).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="eb5df5a3ebce059571acee730f004ee96866a67f" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;shape&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(shape).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">输出形状。如果给定的形状是例如 &lt;code&gt;(m, n, k)&lt;/code&gt; ，则绘制 &lt;code&gt;m * n * k&lt;/code&gt; 样本。如果size为 &lt;code&gt;None&lt;/code&gt; （默认值），则在 &lt;code&gt;shape&lt;/code&gt; 为标量的情况下返回单个值。否则，将绘制 &lt;code&gt;np.array(shape).size&lt;/code&gt; 样本。</target>
        </trans-unit>
        <trans-unit id="93434be0fa874141cd4c8b5151bed934649c82c6" translate="yes" xml:space="preserve">
          <source>Output to existing array instead of creating new one, must have same shape as expected output</source>
          <target state="translated">输出到现有的数组中,而不是创建一个新的数组,必须与预期的输出形状相同。</target>
        </trans-unit>
        <trans-unit id="84eedc132f8f3afc97e2735311f70af181b638d1" translate="yes" xml:space="preserve">
          <source>Output type determination</source>
          <target state="translated">输出类型确定</target>
        </trans-unit>
        <trans-unit id="25c6817215cc63aae8850c0698a2094523318f20" translate="yes" xml:space="preserve">
          <source>Output values. Used for performance testing since the generated values are not returned.</source>
          <target state="translated">输出值。用于性能测试,因为生成的值不返回。</target>
        </trans-unit>
        <trans-unit id="645e7318aeb0e81470723bb7fa3e333eeb197cd2" translate="yes" xml:space="preserve">
          <source>Output view is of shape &lt;code&gt;(self.size,)&lt;/code&gt; (or &lt;code&gt;(np.ma.product(self.shape),)&lt;/code&gt;).</source>
          <target state="translated">输出视图的形状为 &lt;code&gt;(self.size,)&lt;/code&gt; （或 &lt;code&gt;(np.ma.product(self.shape),)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="75eaf4cf3feb6b5ab1173e2bce737a946dc189fe" translate="yes" xml:space="preserve">
          <source>Outputs an array of bools.</source>
          <target state="translated">输出一个bool数组。</target>
        </trans-unit>
        <trans-unit id="0ba159acbd720278d8203620bd6051e07665bfbd" translate="yes" xml:space="preserve">
          <source>Outside the context the error handling behavior has not changed:</source>
          <target state="translated">在上下文之外,错误处理行为没有改变。</target>
        </trans-unit>
        <trans-unit id="8a528519bdaba69c0bdc57fdcdf7b370f2e098f2" translate="yes" xml:space="preserve">
          <source>Overall</source>
          <target state="translated">Overall</target>
        </trans-unit>
        <trans-unit id="3b4b69a29c016e758ecb737d47f6f3d84f5ea925" translate="yes" xml:space="preserve">
          <source>Overall view of discrete Fourier transforms, with definitions and conventions used.</source>
          <target state="translated">离散傅立叶变换的整体观点,并附有定义和使用的惯例。</target>
        </trans-unit>
        <trans-unit id="bd6510575c0d6b439267f2e4a3758c5ec63354f0" translate="yes" xml:space="preserve">
          <source>Overflow Errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e247da042a068cd8a71502e0fd76c6b94f4ca5d" translate="yes" xml:space="preserve">
          <source>Overflow: result too large to be expressed.</source>
          <target state="translated">溢出:结果太大,无法表达。</target>
        </trans-unit>
        <trans-unit id="2efc34a90711b7a3d99847c32b113347fb82c866" translate="yes" xml:space="preserve">
          <source>Override the default nditer flags for the ufunc.</source>
          <target state="translated">覆盖ufunc的默认nditer标志。</target>
        </trans-unit>
        <trans-unit id="75e6a3ee5dadc59620ad485d88ddab650173edc7" translate="yes" xml:space="preserve">
          <source>Override the default operand flags for each ufunc operand.</source>
          <target state="translated">覆盖每个ufunc操作数的默认操作数标志。</target>
        </trans-unit>
        <trans-unit id="c7112a2f014dc699135617be0b1abde474ac316b" translate="yes" xml:space="preserve">
          <source>Overrideable operand flags in ufunc C-API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e2dc0135e076adb3e9a12f5a92b84ec65a0542" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;normed&lt;/code&gt; keyword if given.</source>
          <target state="translated">如果指定，则覆盖 &lt;code&gt;normed&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="3a7540b1b3a0dda7242487679ca9b11862d3a4ba" translate="yes" xml:space="preserve">
          <source>Overrides the data type of the result.</source>
          <target state="translated">覆盖结果的数据类型。</target>
        </trans-unit>
        <trans-unit id="cb013ea80decaa67cad8a4fef77945440ec27842" translate="yes" xml:space="preserve">
          <source>Overrides the dtype of the calculation and output arrays. Similar to &lt;em&gt;signature&lt;/em&gt;.</source>
          <target state="translated">覆盖计算和输出数组的dtype。类似于&lt;em&gt;签名&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7006d2b6fc1325bb6529d58eb36199d98e2b6962" translate="yes" xml:space="preserve">
          <source>Overrides the memory layout of the result. &amp;lsquo;C&amp;rsquo; means C-order, &amp;lsquo;F&amp;rsquo; means F-order, &amp;lsquo;A&amp;rsquo; means &amp;lsquo;F&amp;rsquo; if &lt;code&gt;a&lt;/code&gt; is Fortran contiguous, &amp;lsquo;C&amp;rsquo; otherwise. &amp;lsquo;K&amp;rsquo; means match the layout of &lt;code&gt;a&lt;/code&gt; as closely as possible.</source>
          <target state="translated">覆盖结果的内存布局。'C'表示C阶，'F'表示F阶，'a'表示'F'（如果 &lt;code&gt;a&lt;/code&gt; 与Fortran相邻），否则为'C'。&amp;ldquo;K&amp;rdquo;的装置的布局匹配 &lt;code&gt;a&lt;/code&gt; 尽可能接近。</target>
        </trans-unit>
        <trans-unit id="ddaf5efe8542a3a691f6af72e37e55e4e33af102" translate="yes" xml:space="preserve">
          <source>Overrides the memory layout of the result. &amp;lsquo;C&amp;rsquo; means C-order, &amp;lsquo;F&amp;rsquo; means F-order, &amp;lsquo;A&amp;rsquo; means &amp;lsquo;F&amp;rsquo; if &lt;code&gt;prototype&lt;/code&gt; is Fortran contiguous, &amp;lsquo;C&amp;rsquo; otherwise. &amp;lsquo;K&amp;rsquo; means match the layout of &lt;code&gt;prototype&lt;/code&gt; as closely as possible.</source>
          <target state="translated">覆盖结果的内存布局。&amp;ldquo; C&amp;rdquo;表示C阶，&amp;ldquo; F&amp;rdquo;表示F阶，如果 &lt;code&gt;prototype&lt;/code&gt; 是Fortran连续的，&amp;ldquo; A&amp;rdquo;表示&amp;ldquo; F&amp;rdquo; ，否则为&amp;ldquo; C&amp;rdquo;。&amp;ldquo; K&amp;rdquo;表示尽可能匹配 &lt;code&gt;prototype&lt;/code&gt; 的布局。</target>
        </trans-unit>
        <trans-unit id="4bd31b5015136a3790d4ea1e4b56f5e23f60c98d" translate="yes" xml:space="preserve">
          <source>Overrides the shape of the result. If order=&amp;rsquo;K&amp;rsquo; and the number of dimensions is unchanged, will try to keep order, otherwise, order=&amp;rsquo;C&amp;rsquo; is implied.</source>
          <target state="translated">覆盖结果的形状。如果order ='K'并且尺寸的数量不变，将尝试保持顺序，否则，隐含order ='C'。</target>
        </trans-unit>
        <trans-unit id="3ab7f8eaa264cb0094ba3f9ca231b49fca803e1c" translate="yes" xml:space="preserve">
          <source>Overriding Ufunc behavior</source>
          <target state="translated">覆盖Ufunc行为</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="4b0a4170e8329f03d8b135ba293e3ad03fce2389" translate="yes" xml:space="preserve">
          <source>Overview of numpy type hierarchy.</source>
          <target state="translated">numpy类型层次结构概述。</target>
        </trans-unit>
        <trans-unit id="34ec4594b7176e776330d622e2702954b1c3e9ee" translate="yes" xml:space="preserve">
          <source>Overwrite existing signature file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="aa00a8efe8f9b81ac75da5a75a43b320bd64395d" translate="yes" xml:space="preserve">
          <source>P. R. Peebles Jr., &amp;ldquo;Central Limit Theorem&amp;rdquo; in &amp;ldquo;Probability, Random Variables and Random Signal Principles&amp;rdquo;, 4th ed., 2001, pp. 51, 51, 125.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb033dba7abb6161a0c83b9f27fd0eb075c43755" translate="yes" xml:space="preserve">
          <source>PCG-64 - The default. A fast generator that supports many parallel streams and can be advanced by an arbitrary amount. See the documentation for &lt;a href=&quot;generated/numpy.random.pcg64.advance#numpy.random.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt;. PCG-64 has a period of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="852c68657fb7b98de4c0c80a1fc558db4eb1cb65" translate="yes" xml:space="preserve">
          <source>PCG-64 - The default. A fast generator that supports many parallel streams and can be advanced by an arbitrary amount. See the documentation for &lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt;. PCG-64 has a period of</source>
          <target state="translated">PCG-64-默认。快速生成器，支持许多并行流，并且可以任意增加。请参阅文件&lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt; &lt;code&gt;advance&lt;/code&gt; &lt;/a&gt;。PCG-64的期限为</target>
        </trans-unit>
        <trans-unit id="ec3f94c212b0721b903c3ee685e360e3ef15a646" translate="yes" xml:space="preserve">
          <source>PCG-64 is a 128-bit implementation of O&amp;rsquo;Neill&amp;rsquo;s permutation congruential generator (&lt;a href=&quot;#r4523891264fe-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;#r4523891264fe-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;). PCG-64 has a period of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1cc812d4eb7fa422b89cbdb7060063b9828124" translate="yes" xml:space="preserve">
          <source>PCG-64 is a 128-bit implementation of O&amp;rsquo;Neill&amp;rsquo;s permutation congruential generator (&lt;a href=&quot;#r7c40bac0730f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;#r7c40bac0730f-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;). PCG-64 has a period of</source>
          <target state="translated">PCG-64是O'Neill置换同余生成器（&lt;a href=&quot;#r7c40bac0730f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;，&lt;a href=&quot;#r7c40bac0730f-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;）的128位实现。PCG-64的期限为</target>
        </trans-unit>
        <trans-unit id="4af2a60ae4795c459c6aaf972e39b31efa85a47c" translate="yes" xml:space="preserve">
          <source>PCG64</source>
          <target state="translated">PCG64</target>
        </trans-unit>
        <trans-unit id="8b80c7ece909214affee51ebe9e335eee960dd93" translate="yes" xml:space="preserve">
          <source>PCG64 (class in numpy.random)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3f1df54c65ec3141b5ad7708d8f310bb35110f" translate="yes" xml:space="preserve">
          <source>PCG64.advance()</source>
          <target state="translated">PCG64.advance()</target>
        </trans-unit>
        <trans-unit id="f8024fbbc3a3aef5b6b9fb19f286aa8ddd8b1f19" translate="yes" xml:space="preserve">
          <source>PCG64.cffi</source>
          <target state="translated">PCG64.cffi</target>
        </trans-unit>
        <trans-unit id="b27789fa8622c7f5407c0a21c98dc4e2c03c99f5" translate="yes" xml:space="preserve">
          <source>PCG64.ctypes</source>
          <target state="translated">PCG64.ctypes</target>
        </trans-unit>
        <trans-unit id="010490775ec92003581521aea797462d39c6844f" translate="yes" xml:space="preserve">
          <source>PCG64.jumped()</source>
          <target state="translated">PCG64.jumped()</target>
        </trans-unit>
        <trans-unit id="e1d334c49d4a4c7a9578ef9b5cd8b69493afac43" translate="yes" xml:space="preserve">
          <source>PCG64.state</source>
          <target state="translated">PCG64.state</target>
        </trans-unit>
        <trans-unit id="b4ff946c27bb613726f09f76ac9051fb9b0f1727" translate="yes" xml:space="preserve">
          <source>PEP 3141 numeric objects (including builtins)</source>
          <target state="translated">PEP 3141 数字对象(包括内置的)</target>
        </trans-unit>
        <trans-unit id="93b1d16c8417eaf68b67a446e7919aa4647e6c45" translate="yes" xml:space="preserve">
          <source>PINF (in module numpy)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="728c523d01503026dd65bbe13e4eb1af6cdeb12e" translate="yes" xml:space="preserve">
          <source>PY_ARRAY_UNIQUE_SYMBOL</source>
          <target state="translated">PY_ARRAY_UNIQUE_SYMBOL</target>
        </trans-unit>
        <trans-unit id="bf891340ec2a11d1acd9aa49c131d2652c5c5626" translate="yes" xml:space="preserve">
          <source>PY_ARRAY_UNIQUE_SYMBOL (C macro)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adb71a4a1fa67dfff7b23658e29a4c4a31b4cbc" translate="yes" xml:space="preserve">
          <source>PY_UFUNC_UNIQUE_SYMBOL (C variable)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61443247e63f7e1c0daa436e40747dc59c5d67e" translate="yes" xml:space="preserve">
          <source>PZERO (in module numpy)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6424a476b9cde6f4b3f1412e542dd2b247eca9" translate="yes" xml:space="preserve">
          <source>PZERO : Defines positive zero.</source>
          <target state="translated">PZERO:定义正零。</target>
        </trans-unit>
        <trans-unit id="3a39b68c35be609fae3db651a70893a29f102145" translate="yes" xml:space="preserve">
          <source>Packaging</source>
          <target state="translated">Packaging</target>
        </trans-unit>
        <trans-unit id="187a0323079ad9d1ef0a509dbcf41c04c294cb65" translate="yes" xml:space="preserve">
          <source>Packaging (&lt;code&gt;numpy.distutils&lt;/code&gt;)</source>
          <target state="translated">打包（ &lt;code&gt;numpy.distutils&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f08e1747044acab6d3f1cde93a671bbd941456b2" translate="yes" xml:space="preserve">
          <source>Packaging (numpy.distutils)</source>
          <target state="translated">包装 (numpy.distutils)</target>
        </trans-unit>
        <trans-unit id="ed87cf15ee01e886c94b1a38b3e93dd2cc6fc493" translate="yes" xml:space="preserve">
          <source>Packs the elements of a binary-valued array into bits in a uint8 array.</source>
          <target state="translated">将二进制数组中的元素打包成一个uint8数组中的位。</target>
        </trans-unit>
        <trans-unit id="bd1a1b48e12df64d08abc99d20b4177d10bc8831" translate="yes" xml:space="preserve">
          <source>Pad an array.</source>
          <target state="translated">垫一个数组。</target>
        </trans-unit>
        <trans-unit id="623338c7d8c79f8103d39448c8e5b48ec92bd71f" translate="yes" xml:space="preserve">
          <source>Pad the exponent with zeros until it contains at least this many digits. If omitted, the exponent will be at least 2 digits.</source>
          <target state="translated">用0填充指数,直到它至少包含这么多的数字。如果省略,指数将至少是2位数。</target>
        </trans-unit>
        <trans-unit id="b75a7faadf1505590310ce2efd9e725c23bd6630" translate="yes" xml:space="preserve">
          <source>Pad the left side of the string with whitespace until at least that many characters are to the left of the decimal point.</source>
          <target state="translated">在字符串的左边用空格垫起,直到小数点左边至少有这么多字符。</target>
        </trans-unit>
        <trans-unit id="5afbc760d761bf736b4d58352656b475cf0c23ca" translate="yes" xml:space="preserve">
          <source>Pad the right side of the string with whitespace until at least that many characters are to the right of the decimal point.</source>
          <target state="translated">在字符串的右边用空格填充,直到小数点右边至少有这么多字符。</target>
        </trans-unit>
        <trans-unit id="d76599ff9339cbc70b09ca989f2b38f16c5bb949" translate="yes" xml:space="preserve">
          <source>Padded array of rank equal to &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; with shape increased according to &lt;code&gt;pad_width&lt;/code&gt;.</source>
          <target state="translated">根据 &lt;code&gt;pad_width&lt;/code&gt; ,填充的秩等于等于形状增加的&lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ee9a393873e0b61a69dbdfe6eb9af32cf2ca2765" translate="yes" xml:space="preserve">
          <source>Padding Arrays</source>
          <target state="translated">填充数组</target>
        </trans-unit>
        <trans-unit id="0e79fa15dcf3528049b2a29ae0606a9732799d3f" translate="yes" xml:space="preserve">
          <source>Padding arrays</source>
          <target state="translated">填充数组</target>
        </trans-unit>
        <trans-unit id="7d526b53b9f3056522af85f26a2d434f580eafad" translate="yes" xml:space="preserve">
          <source>Padding function, see Notes.</source>
          <target state="translated">填充功能,见注释。</target>
        </trans-unit>
        <trans-unit id="ed38b70d664fac1df990b27835f8a3a31c0260f4" translate="yes" xml:space="preserve">
          <source>Pads with a constant value.</source>
          <target state="translated">具有恒定值的垫子。</target>
        </trans-unit>
        <trans-unit id="d9f2ac48720b42a9d74674f19c7f64e1c0499c32" translate="yes" xml:space="preserve">
          <source>Pads with the edge values of array.</source>
          <target state="translated">数组边缘值的焊盘。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
