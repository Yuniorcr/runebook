<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="1f9c9c4e9b69dcd6586dbf80815cf3c44f18d220" translate="yes" xml:space="preserve">
          <source>Highlights</source>
          <target state="translated">Highlights</target>
        </trans-unit>
        <trans-unit id="00b07925679220cb801f1a4855d71039bbcccecc" translate="yes" xml:space="preserve">
          <source>Hiroshi Haramoto, Makoto Matsumoto, Takuji Nishimura, Fran&amp;ccedil;ois Panneton, Pierre L&amp;rsquo;Ecuyer, &amp;ldquo;Efficient Jump Ahead for F2-Linear Random Number Generators&amp;rdquo;, INFORMS JOURNAL ON COMPUTING, Vol. 20, No. 3, Summer 2008, pp. 385-390.</source>
          <target state="translated">原本博史，松本诚，西村拓uji，弗朗索瓦&amp;middot;潘尼顿，皮埃尔&amp;middot;拉库尔（Pierre L'Ecuyer），&amp;ldquo; F2线性随机数发生器的高效前行&amp;rdquo;，《计算机信息学杂志》，第1卷。20，第3号，2008年夏季，第385-390页。</target>
        </trans-unit>
        <trans-unit id="5fb511a742639c34c53d07c644e43f8a516d0a8b" translate="yes" xml:space="preserve">
          <source>Hiroshi Haramoto, Makoto Matsumoto, and Pierre L&amp;rsquo;Ecuyer, &amp;ldquo;A Fast Jump Ahead Algorithm for Linear Recurrences in a Polynomial Space&amp;rdquo;, Sequences and Their Applications - SETA, 290&amp;ndash;298, 2008.</source>
          <target state="translated">原本博，松本诚和Pierre L'Ecuyer，&amp;ldquo;多项式空间中线性递归的快速跳转算法&amp;rdquo;，序列及其应用-SETA，290&amp;ndash;298，2008年。</target>
        </trans-unit>
        <trans-unit id="f16459104f92ab6b38aa265adb4ecbfc3768e303" translate="yes" xml:space="preserve">
          <source>Histogram</source>
          <target state="translated">Histogram</target>
        </trans-unit>
        <trans-unit id="9f573dd516c5fae818d100652937d22c8be8a33c" translate="yes" xml:space="preserve">
          <source>Histograms</source>
          <target state="translated">Histograms</target>
        </trans-unit>
        <trans-unit id="4ae9938f95b0f1ddca2c84e6c590258bb6c7a2fc" translate="yes" xml:space="preserve">
          <source>Historically, NumPy has provided a special matrix type, &lt;code&gt;np.matrix&lt;/code&gt;, which is a subclass of ndarray which makes binary operations linear algebra operations. You may see it used in some existing code instead of &lt;code&gt;np.array&lt;/code&gt;. So, which one to use?</source>
          <target state="translated">从历史上看，NumPy提供了一种特殊的矩阵类型 &lt;code&gt;np.matrix&lt;/code&gt; ，它是ndarray的子​​类，它使二进制运算成为线性代数运算。您可能会看到它在某些现有代码中使用，而不是 &lt;code&gt;np.array&lt;/code&gt; 。那么，该使用哪一个呢？</target>
        </trans-unit>
        <trans-unit id="08c95aa82b69eff297d0839c133733de00ba649c" translate="yes" xml:space="preserve">
          <source>Hit the &lt;code&gt;{Publish,Update} release&lt;/code&gt; button at the bottom.</source>
          <target state="translated">点击底部的 &lt;code&gt;{Publish,Update} release&lt;/code&gt; 按钮。</target>
        </trans-unit>
        <trans-unit id="34329cbed12573fba3127f8cc749498a60eadbb9" translate="yes" xml:space="preserve">
          <source>Hook in &lt;code&gt;numpy/__init__.py&lt;/code&gt; to run distribution-specific checks</source>
          <target state="translated">胡克 &lt;code&gt;numpy/__init__.py&lt;/code&gt; 运行具体分配的检查</target>
        </trans-unit>
        <trans-unit id="02f07bc7a75153468adfa0658b0fd2c34d3ff7ae" translate="yes" xml:space="preserve">
          <source>Horner&amp;rsquo;s scheme &lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is used to evaluate the polynomial. Even so, for polynomials of high degree the values may be inaccurate due to rounding errors. Use carefully.</source>
          <target state="translated">Horner的方案&lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;用于评估多项式。即使这样，对于高次多项式，由于舍入误差，值可能仍然不准确。小心使用。</target>
        </trans-unit>
        <trans-unit id="a0bb6d60bdafa1c8cd27af7d704ca6a159830aba" translate="yes" xml:space="preserve">
          <source>How Tos</source>
          <target state="translated">如何使用</target>
        </trans-unit>
        <trans-unit id="37544ef44c5ec43acf39ee75fa75aed3630c67b7" translate="yes" xml:space="preserve">
          <source>How can we pass our custom array type through this function? Numpy allows a class to indicate that it would like to handle computations in a custom-defined way through the interfaces &lt;code&gt;__array_ufunc__&lt;/code&gt; and &lt;code&gt;__array_function__&lt;/code&gt;. Let&amp;rsquo;s take one at a time, starting with &lt;code&gt;_array_ufunc__&lt;/code&gt;. This method covers &lt;a href=&quot;../reference/ufuncs#ufuncs&quot;&gt;Universal functions (ufunc)&lt;/a&gt;, a class of functions that includes, for example, &lt;a href=&quot;../reference/generated/numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;numpy.multiply&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.sin#numpy.sin&quot;&gt;&lt;code&gt;numpy.sin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">我们如何通过此函数传递自定义数组类型？Numpy允许一个类指示它想通过接口 &lt;code&gt;__array_ufunc__&lt;/code&gt; 和 &lt;code&gt;__array_function__&lt;/code&gt; 以自定义方式处理计算。让我们一次以 &lt;code&gt;_array_ufunc__&lt;/code&gt; 开始。此方法涵盖&lt;a href=&quot;../reference/ufuncs#ufuncs&quot;&gt;通用函数（ufunc）&lt;/a&gt;，这是一类函数，例如，包括&lt;a href=&quot;../reference/generated/numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;numpy.multiply&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../reference/generated/numpy.sin#numpy.sin&quot;&gt; &lt;code&gt;numpy.sin&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6fb47cd6d16a30a926efe82eaad98fb5865139f5" translate="yes" xml:space="preserve">
          <source>How do we construct a 2D array from a list of equally-sized row vectors? In MATLAB this is quite easy: if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are two vectors of the same length you only need do &lt;code&gt;m=[x;y]&lt;/code&gt;. In NumPy this works via the functions &lt;code&gt;column_stack&lt;/code&gt;, &lt;code&gt;dstack&lt;/code&gt;, &lt;code&gt;hstack&lt;/code&gt; and &lt;code&gt;vstack&lt;/code&gt;, depending on the dimension in which the stacking is to be done. For example:</source>
          <target state="translated">我们如何从大小相等的行向量列表中构建2D数组？在MATLAB中，这非常容易：如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是两个相同长度的向量，则只需要 &lt;code&gt;m=[x;y]&lt;/code&gt; 即可。在NumPy的通过此功能工作 &lt;code&gt;column_stack&lt;/code&gt; ， &lt;code&gt;dstack&lt;/code&gt; ， &lt;code&gt;hstack&lt;/code&gt; 和 &lt;code&gt;vstack&lt;/code&gt; ，这取决于堆叠是必须要做的尺寸。例如：</target>
        </trans-unit>
        <trans-unit id="0c6749c478409711ffa23534cffe66364ec264e6" translate="yes" xml:space="preserve">
          <source>How do we know when consensus has been achieved? In principle, this is rather difficult, since consensus is defined by the absence of vetos, which requires us to somehow prove a negative. In practice, we use a combination of our best judgement (e.g., a simple and uncontroversial bug fix posted on GitHub and reviewed by a core developer is probably fine) and best efforts (e.g., all substantive API changes must be posted to the mailing list in order to give the broader community a chance to catch any problems and suggest improvements; we assume that anyone who cares enough about NumPy to invoke their veto right should be on the mailing list). If no-one bothers to comment on the mailing list after a few days, then it&amp;rsquo;s probably fine. And worst case, if a change is more controversial than expected, or a crucial critique is delayed because someone was on vacation, then it&amp;rsquo;s no big deal: we apologize for misjudging the situation, &lt;a href=&quot;http://producingoss.com/en/producingoss.html#version-control-relaxation&quot;&gt;back up, and sort things out&lt;/a&gt;.</source>
          <target state="translated">我们如何知道何时达成共识？从原则上讲，这是相当困难的，因为共识是由缺乏维托斯来定义的，这需要我们以某种方式证明是消极的。在实践中，我们结合了最佳判断力（例如，在GitHub上发布的简单且无争议的错误修复程序，并由核心开发人员审查过）和尽力而为（例如，所有实质性的API更改都必须发布到邮件列表中）为了使广大社区有机会发现任何问题并提出改进建议；我们认为对NumPy足够关心的人可以行使其否决权。如果几天后没人愿意在邮件列表上发表评论，那可能就好了。最糟糕的情况是，如果变更比预期的更具争议性，或因为某人正在休假而延迟了关键的批判，那么没什么大不了的：我们为错误判断情况道歉，&lt;a href=&quot;http://producingoss.com/en/producingoss.html#version-control-relaxation&quot;&gt;备份，然后整理一下&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2fbb3731558c54237c322aa799a621ca3c7d2a1" translate="yes" xml:space="preserve">
          <source>How do you know the shape and size of an array?</source>
          <target state="translated">如何知道数组的形状和大小?</target>
        </trans-unit>
        <trans-unit id="45e254592757b5e545a9eb104e6529f78a4c37d7" translate="yes" xml:space="preserve">
          <source>How many bytes needed to jump from the end of a dimension back to its beginning. Note that &lt;code&gt;backstrides[k] == strides[k] *
dims_m1[k]&lt;/code&gt;, but it is stored here as an optimization.</source>
          <target state="translated">从维的末尾跳回其开始需要多少字节。注意 &lt;code&gt;backstrides[k] == strides[k] * dims_m1[k]&lt;/code&gt; ，但它是作为优化存储在这里的。</target>
        </trans-unit>
        <trans-unit id="50be7c0770c6ecdb4f48559d001a760ebacd49cf" translate="yes" xml:space="preserve">
          <source>How many trials succeeded after a single run?</source>
          <target state="translated">一次运行后,有多少次试验成功?</target>
        </trans-unit>
        <trans-unit id="b58aa8864964e56b91e5cf3a16abe6db4861d007" translate="yes" xml:space="preserve">
          <source>How numpy handles numerical exceptions</source>
          <target state="translated">numpy如何处理数字异常</target>
        </trans-unit>
        <trans-unit id="769ef91e51259c0af4889f9e0ba44a7641bc888d" translate="yes" xml:space="preserve">
          <source>How the committee will respond to reports</source>
          <target state="translated">委员会将如何对报告作出回应</target>
        </trans-unit>
        <trans-unit id="8a9fac3d5f2ed22d26d8e65434409a64b568a19a" translate="yes" xml:space="preserve">
          <source>How to Prepare a Release</source>
          <target state="translated">如何准备发布</target>
        </trans-unit>
        <trans-unit id="f2421f501c3d9da50b64e18ac9aabab538f44d78" translate="yes" xml:space="preserve">
          <source>How to access the docstring for more information</source>
          <target state="translated">如何获取docstring的更多信息</target>
        </trans-unit>
        <trans-unit id="acdb5801edd59835ce1589b37b87df7e5921dc32" translate="yes" xml:space="preserve">
          <source>How to check the ABI of BLAS/LAPACK libraries</source>
          <target state="translated">如何检查BLAS/LAPACK库的ABI?</target>
        </trans-unit>
        <trans-unit id="7aec4c512fe995b8565d4654ce7ac7f7406a4e3f" translate="yes" xml:space="preserve">
          <source>How to contribute to the NumPy documentation</source>
          <target state="translated">如何为NumPy文档做贡献?</target>
        </trans-unit>
        <trans-unit id="f9221bbb4c993e17b159a09a015a8cfb26163b6a" translate="yes" xml:space="preserve">
          <source>How to contribute to this documentation (user and API)</source>
          <target state="translated">如何对该文档做出贡献(用户和API)?</target>
        </trans-unit>
        <trans-unit id="b16ba9588c01309cec829be39d4d7fa37da2d3d4" translate="yes" xml:space="preserve">
          <source>How to convert a 1D array into a 2D array (how to add a new axis to an array)</source>
          <target state="translated">如何将一维数组转换为二维数组(如何在数组中添加新轴)</target>
        </trans-unit>
        <trans-unit id="767132203b56ed5a732938158524dc8930f4e863" translate="yes" xml:space="preserve">
          <source>How to create a basic array</source>
          <target state="translated">如何创建一个基本数组</target>
        </trans-unit>
        <trans-unit id="484181d716d9291c06f7d7ef08909d7d6fab3e0a" translate="yes" xml:space="preserve">
          <source>How to create an array from existing data</source>
          <target state="translated">如何从现有数据中创建一个数组</target>
        </trans-unit>
        <trans-unit id="9cc4cf70f5442751464e426079ad36aeb36f19be" translate="yes" xml:space="preserve">
          <source>How to do common tasks with NumPy</source>
          <target state="translated">如何使用NumPy完成常见的任务?</target>
        </trans-unit>
        <trans-unit id="0cf433e8cb198db7bf7c955d6715ae5e9750b810" translate="yes" xml:space="preserve">
          <source>How to extend NumPy</source>
          <target state="translated">如何扩展NumPy</target>
        </trans-unit>
        <trans-unit id="666793dffdb7a87d947a14c2cbc94401669fb6a1" translate="yes" xml:space="preserve">
          <source>How to get unique items and counts</source>
          <target state="translated">如何获得独特的项目和计数</target>
        </trans-unit>
        <trans-unit id="85f78c1b7c6c2daa9f22d71b7624a2bf3c525a6f" translate="yes" xml:space="preserve">
          <source>How to import NumPy</source>
          <target state="translated">如何导入NumPy</target>
        </trans-unit>
        <trans-unit id="5f492f4c3e2bb0aa4c599fef867f4b321aedf559" translate="yes" xml:space="preserve">
          <source>How to read and write data using NumPy</source>
          <target state="translated">如何使用NumPy读写数据?</target>
        </trans-unit>
        <trans-unit id="25e26bd806025536efd64003099ee09d64aa0000" translate="yes" xml:space="preserve">
          <source>How to reverse an array</source>
          <target state="translated">如何反转一个数组</target>
        </trans-unit>
        <trans-unit id="9a0ae6b713025a426e1208163ee26bcb0e742b0a" translate="yes" xml:space="preserve">
          <source>How to save and load NumPy objects</source>
          <target state="translated">如何保存和加载NumPy对象。</target>
        </trans-unit>
        <trans-unit id="41cd522ba4633ce6d4277a1ec4fd27e9f6066b5f" translate="yes" xml:space="preserve">
          <source>How to treat dates that do not fall on a valid day. The default is &amp;lsquo;raise&amp;rsquo;.</source>
          <target state="translated">如何处理非有效日期的日期。默认值为&amp;ldquo; raise&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="32eab6d31082447f7e78feb7ff06453c5204497b" translate="yes" xml:space="preserve">
          <source>How to use an array iterator on a C-level is explained more fully in later sections. Typically, you do not need to concern yourself with the internal structure of the iterator object, and merely interact with it through the use of the macros &lt;a href=&quot;array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it), &lt;a href=&quot;array#c.PyArray_ITER_GOTO&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt;&lt;/a&gt; (it, dest), or &lt;a href=&quot;array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; (it, index). All of these macros require the argument &lt;em&gt;it&lt;/em&gt; to be a &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在后面的小节中将更全面地说明如何在C级上使用数组迭代器。通常，您不需要关心迭代器对象的内部结构，而只需要使用宏&lt;a href=&quot;array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt;（it），&lt;a href=&quot;array#c.PyArray_ITER_GOTO&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt; &lt;/a&gt;（it，dest）或&lt;a href=&quot;array#c.PyArray_ITER_GOTO1D&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt; &lt;/a&gt;（it，index）与它进行交互。所有这些宏需要论证&lt;em&gt;它&lt;/em&gt;是一个&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject *&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="031b673efec683dbe6f1648f1b6820d5445558f5" translate="yes" xml:space="preserve">
          <source>How to use an array iterator on a C-level is explained more fully in later sections. Typically, you do not need to concern yourself with the internal structure of the iterator object, and merely interact with it through the use of the macros &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it), &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt;&lt;/a&gt; (it, dest), or &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; (it, index). All of these macros require the argument &lt;em&gt;it&lt;/em&gt; to be a &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在后面的部分中将更全面地说明如何在C级上使用数组迭代器。通常，您不需要关心迭代器对象的内部结构，而只需通过使用宏&lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt;（it），&lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt; &lt;/a&gt;（it，dest）或&lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt; &lt;/a&gt;（it，index）与它进行交互。所有这些宏需要论证&lt;em&gt;它&lt;/em&gt;是一个&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject *&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4fbdd9c0dbdc8228af43d264039755fa6f4f95d7" translate="yes" xml:space="preserve">
          <source>How to write a NumPy how-to</source>
          <target state="translated">如何编写NumPy教程</target>
        </trans-unit>
        <trans-unit id="9bcd1bde0a6ac509c8c0a0f1ece3cf8687c68de6" translate="yes" xml:space="preserve">
          <source>How to write docstrings in the numpydoc format</source>
          <target state="translated">如何用numpydoc格式编写docstrings?</target>
        </trans-unit>
        <trans-unit id="a9ce4fa1ba9129e1c9bcea4c3de2267bc0616f3b" translate="yes" xml:space="preserve">
          <source>How-tos</source>
          <target state="translated">How-tos</target>
        </trans-unit>
        <trans-unit id="5a2138ee0afb6e0df456b908537065dae83cea13" translate="yes" xml:space="preserve">
          <source>How-tos bring people into the site and help them discover other information that&amp;rsquo;s here .</source>
          <target state="translated">操作方法将人们带入该站点，并帮助他们发现此处的其他信息。</target>
        </trans-unit>
        <trans-unit id="ba325398237c63a9d5322f9272d833f53cda40ea" translate="yes" xml:space="preserve">
          <source>How-tos get straight to the point &amp;ndash; they</source>
          <target state="translated">操作方法直截了当&amp;ndash;它们</target>
        </trans-unit>
        <trans-unit id="e6a6228c232d3f69fb7834193a60b8402989b6d1" translate="yes" xml:space="preserve">
          <source>How-tos make the site less forbidding to non-experts.</source>
          <target state="translated">如何让网站对非专家不那么禁忌。</target>
        </trans-unit>
        <trans-unit id="a2e4974ddfecbf0d517a464e620b926746339cbe" translate="yes" xml:space="preserve">
          <source>However, F2PY provides a hook to overcome this difficulty, namely, users can define their own &amp;lt;Fortran type&amp;gt; to &amp;lt;C type&amp;gt; maps. For example, if Fortran 90 code contains:</source>
          <target state="translated">但是，F2PY提供了一个克服此困难的方法，即用户可以定义自己的&amp;lt;Fortran类型&amp;gt;到&amp;lt;C类型&amp;gt;映射。例如，如果Fortran 90代码包含：</target>
        </trans-unit>
        <trans-unit id="1fba89386b8ecb89961d14d41f66fbec5ccd1d21" translate="yes" xml:space="preserve">
          <source>However, array scalars are immutable, so none of the array scalar attributes are settable.</source>
          <target state="translated">但是,数组标量是不可变的,所以数组标量的属性都是不可设置的。</target>
        </trans-unit>
        <trans-unit id="1e80ea7cc9443be2dc987f1f00e1482c24f952ab" translate="yes" xml:space="preserve">
          <source>However, for a 2D array, &lt;code&gt;tolist&lt;/code&gt; applies recursively:</source>
          <target state="translated">但是，对于2D数组， &lt;code&gt;tolist&lt;/code&gt; 递归适用：</target>
        </trans-unit>
        <trans-unit id="015eddccae9844f7be37e7464bfea1ad89cd5089" translate="yes" xml:space="preserve">
          <source>However, if editing Fortran codes is acceptable, then the generation of an intermediate signature file can be skipped in most cases. Namely, F2PY specific attributes can be inserted directly to Fortran source codes using the so-called F2PY directive. A F2PY directive defines special comment lines (starting with &lt;code&gt;Cf2py&lt;/code&gt;, for example) which are ignored by Fortran compilers but F2PY interprets them as normal lines.</source>
          <target state="translated">但是，如果编辑Fortran代码是可以接受的，则在大多数情况下可以跳过中间签名文件的生成。即，可以使用所谓的F2PY指令将F2PY特定的属性直接插入到Fortran源代码中。F2PY指令定义了特殊注释行（例如，以 &lt;code&gt;Cf2py&lt;/code&gt; 开头），Fortran编译器会忽略这些注释行，但F2PY会将其解释为普通行。</target>
        </trans-unit>
        <trans-unit id="b575af53d48fbf01519f17fa75457eb6160cea6e" translate="yes" xml:space="preserve">
          <source>However, if one wants to perform an operation on each element in the array, one can use the &lt;code&gt;flat&lt;/code&gt; attribute which is an &lt;a href=&quot;https://docs.python.org/tutorial/classes.html#iterators&quot;&gt;iterator&lt;/a&gt; over all the elements of the array:</source>
          <target state="translated">但是，如果要对数组中的每个元素执行操作，则可以使用 &lt;code&gt;flat&lt;/code&gt; 属性，该属性是数组的所有元素上的&lt;a href=&quot;https://docs.python.org/tutorial/classes.html#iterators&quot;&gt;迭代器&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="538a59374ec076485a1ecbe77f4b8f8bcaeb6930" translate="yes" xml:space="preserve">
          <source>However, if the step length is a &lt;strong&gt;complex number&lt;/strong&gt; (e.g. 5j), then the integer part of its magnitude is interpreted as specifying the number of points to create between the start and stop values, where the stop value &lt;strong&gt;is inclusive&lt;/strong&gt;.</source>
          <target state="translated">但是，如果步长是一个&lt;strong&gt;复数&lt;/strong&gt;（例如5j），则将其幅度的整数部分解释为指定要在起始值和终止值之间创建的点数，其中终止值&lt;strong&gt;是包含端点的&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c7b350918e2c3c187f55b17296e6170af94589d5" translate="yes" xml:space="preserve">
          <source>However, it also provides a filter mechanism to work around &lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180&lt;/a&gt;.</source>
          <target state="translated">但是，它也提供了一种过滤器机制来解决&lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180的问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a0d3e8aabdd09f6d1c5b5cc067196fd48077165" translate="yes" xml:space="preserve">
          <source>However, on Windows accessing an attribute of the &lt;code&gt;cdll&lt;/code&gt; method will load the first DLL by that name found in the current directory or on the PATH. Loading the absolute path name requires a little finesse for cross-platform work since the extension of shared libraries varies. There is a &lt;code&gt;ctypes.util.find_library&lt;/code&gt; utility available that can simplify the process of finding the library to load but it is not foolproof. Complicating matters, different platforms have different default extensions used by shared libraries (e.g. .dll &amp;ndash; Windows, .so &amp;ndash; Linux, .dylib &amp;ndash; Mac OS X). This must also be taken into account if you are using ctypes to wrap code that needs to work on several platforms.</source>
          <target state="translated">但是，在Windows上，访问 &lt;code&gt;cdll&lt;/code&gt; 方法的属性将通过在当前目录或PATH中找到的名称加载第一个DLL。加载绝对路径名对于跨平台工作需要一些技巧，因为共享库的扩展会有所不同。有一个可用的 &lt;code&gt;ctypes.util.find_library&lt;/code&gt; 实用程序可以简化查找要加载的库的过程，但并非万无一失。复杂的是，不同的平台具有共享库使用的默认扩展名（例如，.dll &amp;ndash; Windows，.so &amp;ndash; Linux，.dylib &amp;ndash; Mac OS X）。如果您使用ctypes包装需要在多个平台上工作的代码，则也必须考虑到这一点。</target>
        </trans-unit>
        <trans-unit id="72730352a2b8f129f65e5ce4d2975cad73414281" translate="yes" xml:space="preserve">
          <source>However, since the indexing arrays above just repeat themselves, broadcasting can be used (compare operations such as &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt;) to simplify this:</source>
          <target state="translated">但是，由于上面的索引数组只会重复自身，因此可以使用广播（比较操作，例如 &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt; ）来简化此操作：</target>
        </trans-unit>
        <trans-unit id="5598df37564d4f9b7b446978966b782318a91f69" translate="yes" xml:space="preserve">
          <source>However, the Council&amp;rsquo;s primary responsibility is to facilitate the ordinary community-based decision making procedure described above. If we ever have to step in and formally override the community for the health of the Project, then we will do so, but we will consider reaching this point to indicate a failure in our leadership.</source>
          <target state="translated">但是，理事会的主要责任是促进上述基于社区的普通决策程序。如果我们不得不介入并正式超越社区，以维护项目的健康，那么我们将这样做，但是我们将考虑达到这一点，以表明我们领导层的失败。</target>
        </trans-unit>
        <trans-unit id="148e0e3942c54a4e1382c28056e669f5ec70ca70" translate="yes" xml:space="preserve">
          <source>However, the recommended way to get changes made by Fortran subroutine back to Python is to use &lt;code&gt;intent(out)&lt;/code&gt; attribute. It is more efficient and a cleaner solution.</source>
          <target state="translated">但是，建议将Fortran子例程所做的更改返回给Python，建议的方法是使用 &lt;code&gt;intent(out)&lt;/code&gt; 属性。它是更有效和更清洁的解决方案。</target>
        </trans-unit>
        <trans-unit id="076196cf7f29cbacc06332dc3a19baa5b6deb43a" translate="yes" xml:space="preserve">
          <source>However, there are ways (see below) how to &amp;ldquo;teach&amp;rdquo; F2PY about the true intentions (among other things) of function arguments; and then F2PY is able to generate more Pythonic (more explicit, easier to use, and less error prone) wrappers to Fortran functions.</source>
          <target state="translated">但是，有一些方法（见下文）如何&amp;ldquo;教&amp;rdquo; F2PY函数参数的真实意图（除其他事项外）。然后F2PY能够为Fortran函数生成更多的Pythonic（更显式，更易于使用且更不易出错）包装器。</target>
        </trans-unit>
        <trans-unit id="517b2fc5c448904cbaf5099f9fa2e17572271c41" translate="yes" xml:space="preserve">
          <source>However, this class is not run directly. Rather, it serves as a base class to several other python classes, each one specific to a particular data type. The &lt;code&gt;VectorTestCase&lt;/code&gt; class stores two strings for typing information:</source>
          <target state="translated">但是，此类不能直接运行。相反，它是其他几个python类的基类，每个python类都特定于一种特定的数据类型。该 &lt;code&gt;VectorTestCase&lt;/code&gt; 类存储两个字符串的打字信息：</target>
        </trans-unit>
        <trans-unit id="2a6f4657816e90073e4efa70d32c1dabe823c21d" translate="yes" xml:space="preserve">
          <source>However, we can not do this by putting &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; into an array, because this array will be interpreted as indexing the first dimension of a.</source>
          <target state="translated">但是，我们无法通过将 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 放入数组来完成此操作，因为该数组将被解释为索引a的第一维。</target>
        </trans-unit>
        <trans-unit id="d0b3b9f48e63d95c45789879b62e0b7dfb5a4009" translate="yes" xml:space="preserve">
          <source>However, when the list of indices contains repetitions, the assignment is done several times, leaving behind the last value:</source>
          <target state="translated">但是,当索引列表中包含重复时,赋值会进行多次,留下最后一个值。</target>
        </trans-unit>
        <trans-unit id="521bc3c12a73492e24db294a1945beb730dec9cb" translate="yes" xml:space="preserve">
          <source>Human-readable</source>
          <target state="translated">Human-readable</target>
        </trans-unit>
        <trans-unit id="baf7f433a664b8146a9906ca7ff1abe3cab252ff" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine, element-wise.</source>
          <target state="translated">双曲余弦,元素方面。</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">双曲函数</target>
        </trans-unit>
        <trans-unit id="b87cce3c91c3e9d2649c00af3ce0c941c00a9a8f" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine, element-wise.</source>
          <target state="translated">双曲正弦,元素方面。</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="32232530b1100268522739a98df9e054ce98ef4f" translate="yes" xml:space="preserve">
          <source>I() (numpy.matrix property)</source>
          <target state="translated">I()(numpy.matrix 属性)</target>
        </trans-unit>
        <trans-unit id="c586011e018241bf43412c51ec75d78e1897bbe7" translate="yes" xml:space="preserve">
          <source>I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng. trans. Ed.), &lt;em&gt;Handbook of Mathematics&lt;/em&gt;, New York, Van Nostrand Reinhold Co., 1985, pg. 720.</source>
          <target state="translated">在Bronshtein，KA Semendyayev和KA Hirsch（英语译）中，&lt;em&gt;《数学手册》&lt;/em&gt;，纽约，范&amp;middot;诺斯特兰德&amp;middot;莱因霍尔德（Van Nostrand Reinhold Co.），第1985页。720。</target>
        </trans-unit>
        <trans-unit id="447fb9923a27f15d934b8afdf5c0a4f010eb6dd4" translate="yes" xml:space="preserve">
          <source>I/O with NumPy</source>
          <target state="translated">用NumPy进行I/O</target>
        </trans-unit>
        <trans-unit id="58fa487987fc3870763b0f9db01323f264726e65" translate="yes" xml:space="preserve">
          <source>IBM/POWER big-endian - CPU feature names</source>
          <target state="translated">IBM/POWER big-endian-CPU功能名称</target>
        </trans-unit>
        <trans-unit id="2ccc4b37b2ad4aa5276bee6f26efc4659da58371" translate="yes" xml:space="preserve">
          <source>IBM/POWER little-endian - CPU feature names</source>
          <target state="translated">IBM/POWER小字型--CPU功能名称。</target>
        </trans-unit>
        <trans-unit id="afc08020472b5f8bfb4430d0521200fb31b0b681" translate="yes" xml:space="preserve">
          <source>IEEE 754 Floating Point Special Values</source>
          <target state="translated">IEEE 754 浮点特殊值</target>
        </trans-unit>
        <trans-unit id="0ee225f319b80c76b05dae881594a3894bf4661e" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of (positive) infinity.</source>
          <target state="translated">IEEE 754浮点表示(正)无穷大。</target>
        </trans-unit>
        <trans-unit id="ff3e6480ff45af971d6b3762d77291c710637eb0" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of Not a Number (NaN).</source>
          <target state="translated">IEEE 754浮点表示的不是一个数字(NaN)。</target>
        </trans-unit>
        <trans-unit id="824566ddb199752efcc7660bd7d421e1b2678da4" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative infinity.</source>
          <target state="translated">IEEE 754浮点表示负无穷大。</target>
        </trans-unit>
        <trans-unit id="2e340e10314a130edadd8cad9f96f416538b858d" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative zero.</source>
          <target state="translated">IEEE 754 负零的浮点表示。</target>
        </trans-unit>
        <trans-unit id="b287f77a659c8b69b20168ee840f1a54628cc862" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of positive zero.</source>
          <target state="translated">IEEE 754浮点表示正零。</target>
        </trans-unit>
        <trans-unit id="8b686ac7097f2666dfedf8d88871747de97f1028" translate="yes" xml:space="preserve">
          <source>IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2008, pp.1-70, 2008, &lt;a href=&quot;https://www.doi.org/10.1109/IEEESTD.2008.4610935&quot;&gt;http://www.doi.org/10.1109/IEEESTD.2008.4610935&lt;/a&gt;</source>
          <target state="translated">IEEE浮点算法标准，IEEE Std 754-2008，第1-70页，2008年，&lt;a href=&quot;https://www.doi.org/10.1109/IEEESTD.2008.4610935&quot;&gt;http：//www.doi.org/10.1109/IEEESTD.2008.4610935&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="72cabc0c250f4a292eec84ba99be92816a937afe" translate="yes" xml:space="preserve">
          <source>INSTALL.rst.txt</source>
          <target state="translated">INSTALL.rst.txt</target>
        </trans-unit>
        <trans-unit id="ab585ec9c005c8ff11ee6135d8e5382d325fbd66" translate="yes" xml:space="preserve">
          <source>IO compatibility with large files</source>
          <target state="translated">对大文件的IO兼容性</target>
        </trans-unit>
        <trans-unit id="e274113d3320e2ddaa1955ecaa00f8ecd732ab0e" translate="yes" xml:space="preserve">
          <source>IO performance improvements</source>
          <target state="translated">改善IO性能</target>
        </trans-unit>
        <trans-unit id="a7aaaf8103e147f7508e66b5f7be824742d34faa" translate="yes" xml:space="preserve">
          <source>IOError</source>
          <target state="translated">IOError</target>
        </trans-unit>
        <trans-unit id="401e5d8be22ba7ec21a65d4ac42f63626cf30eac" translate="yes" xml:space="preserve">
          <source>ISO/IEC standard 9899:1999, &amp;ldquo;Programming language C.&amp;rdquo;</source>
          <target state="translated">ISO / IEC标准9899：1999，&amp;ldquo;编程语言C&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a192903ac36265b2268a1b63fb4343f1bc34ccf1" translate="yes" xml:space="preserve">
          <source>ISeedSequence.generate_state()</source>
          <target state="translated">ISeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="7817ae1e33233084a2765c4156676391d76c8dd8" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.generate_state()</source>
          <target state="translated">ISpawnableSeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="266493f5f6f829a5601662541a1f5723f1a321cc" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.spawn()</source>
          <target state="translated">ISpawnableSeedSequence.spawn()</target>
        </trans-unit>
        <trans-unit id="08673d1ddebe80d6502dff08e88d404531dbe20b" translate="yes" xml:space="preserve">
          <source>Identifies the benchmarks to run. This can be a string to pass to the nosetests executable with the &amp;lsquo;-A&amp;rsquo; option, or one of several special values. Special values are:</source>
          <target state="translated">确定要运行的基准。这可以是使用'-A'选项传递到鼻子测试可执行文件的字符串，也可以是几个特殊值之一。特殊值是：</target>
        </trans-unit>
        <trans-unit id="2938dea7757a31542d1346c3f1074719ce51ad4d" translate="yes" xml:space="preserve">
          <source>Identifies the tests to run. This can be a string to pass to the nosetests executable with the &amp;lsquo;-A&amp;rsquo; option, or one of several special values. Special values are:</source>
          <target state="translated">标识要运行的测试。这可以是使用'-A'选项传递到鼻子测试可执行文件的字符串，也可以是几个特殊值之一。特殊值是：</target>
        </trans-unit>
        <trans-unit id="84791116b8cc2df6bbeaf0d85f3bf0937f9761c0" translate="yes" xml:space="preserve">
          <source>Identify the commit hash of the release, e.g. 1b2e1d63ff.</source>
          <target state="translated">识别该版本的提交哈希值,如1b2e1d63ff。</target>
        </trans-unit>
        <trans-unit id="fd1dd04c1dd17aedd6c4e7a39f0e9308f130b433" translate="yes" xml:space="preserve">
          <source>Identity for reduction, when &lt;a href=&quot;#c.PyUFuncObject.identity&quot;&gt;&lt;code&gt;PyUFuncObject.identity&lt;/code&gt;&lt;/a&gt; is equal to &lt;a href=&quot;ufunc#c.PyUFunc_IdentityValue&quot;&gt;&lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当&lt;a href=&quot;#c.PyUFuncObject.identity&quot;&gt; &lt;code&gt;PyUFuncObject.identity&lt;/code&gt; &lt;/a&gt;等于&lt;a href=&quot;ufunc#c.PyUFunc_IdentityValue&quot;&gt; &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; &lt;/a&gt;时，用于简化的标识。</target>
        </trans-unit>
        <trans-unit id="111e795804fa7bde03948ba63ec2cb3f6f402b39" translate="yes" xml:space="preserve">
          <source>Identity function.</source>
          <target state="translated">身份功能。</target>
        </trans-unit>
        <trans-unit id="ef2cb61738111c3044b6a344dba03012a1f3066b" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;inner&amp;rsquo;, returns the elements common to both r1 and r2. If &amp;lsquo;outer&amp;rsquo;, returns the common elements as well as the elements of r1 not in r2 and the elements of not in r2. If &amp;lsquo;leftouter&amp;rsquo;, returns the common elements and the elements of r1 not in r2.</source>
          <target state="translated">如果为&amp;ldquo; inner&amp;rdquo;，则返回r1和r2共同的元素。如果为'outer'，则返回公共元素以及r1中不在r2中的元素和not在r2中的元素。如果为'leftouter'，则返回公共元素和r1不在r2中的元素。</target>
        </trans-unit>
        <trans-unit id="c9a8c69d524e3737d8a52d7c063a710ab1820ab4" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;left&amp;rsquo;, the index of the first suitable location found is given. If &amp;lsquo;right&amp;rsquo;, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">如果为&amp;ldquo; left&amp;rdquo;，则给出找到的第一个合适位置的索引。如果为&amp;ldquo;正确&amp;rdquo;，则返回最后一个这样的索引。如果没有合适的索引，返回0或N（其中N是的长度 &lt;code&gt;a&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0b2ac55fdba7a6077870f65fb651eb209decd3f7" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;out&amp;rsquo; is None (the default), a uninitialized return array is created. The output array is then filled with the results of the ufunc in the places that the broadcast &amp;lsquo;where&amp;rsquo; is True. If &amp;lsquo;where&amp;rsquo; is the scalar True (the default), then this corresponds to the entire output being filled. Note that outputs not explicitly filled are left with their uninitialized values.</source>
          <target state="translated">如果'out'为None（默认值），则会创建一个未初始化的返回数组。然后，在广播&amp;ldquo; where&amp;rdquo;为True的地方，用ufunc的结果填充输出数组。如果&amp;ldquo; where&amp;rdquo;是标量True（默认值），则它对应于要填充的整个输出。请注意，未明确填充的输出将保留其未初始化的值。</target>
        </trans-unit>
        <trans-unit id="b221bc8f0d9f3564598fa735c4c298856c0dd2e9" translate="yes" xml:space="preserve">
          <source>If -1/NULL values are passed to &lt;code&gt;oa_ndim&lt;/code&gt;, &lt;code&gt;op_axes&lt;/code&gt;, &lt;code&gt;itershape&lt;/code&gt;, and &lt;code&gt;buffersize&lt;/code&gt;, it is equivalent to &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果将-1 / NULL值传递给 &lt;code&gt;oa_ndim&lt;/code&gt; ， &lt;code&gt;op_axes&lt;/code&gt; ， &lt;code&gt;itershape&lt;/code&gt; 和 &lt;code&gt;buffersize&lt;/code&gt; ，则等效于&lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="07ab4829841dadccaa2d85de36af5f3925367c25" translate="yes" xml:space="preserve">
          <source>If 64-bit integers are still too small the result may be cast to a floating point number. Floating point numbers offer a larger, but inexact, range of possible values.</source>
          <target state="translated">如果64位整数仍然太小,结果可能会被转换为浮点数。浮点数提供了一个更大的,但不精确的,可能的值范围。</target>
        </trans-unit>
        <trans-unit id="79d46b4b066a6ba67bd08b99b0faa98132c0c54b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is #defined, regardless of whether &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is, the C-API is declared to be &lt;code&gt;extern void**&lt;/code&gt;, so it is expected to be defined in another compilation unit.</source>
          <target state="translated">如果&lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; &lt;/a&gt;是#defined定义的，则不管&lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt;是否为C，都将C-API声明为 &lt;code&gt;extern void**&lt;/code&gt; ，因此应在另一个编译单元中对其进行定义。</target>
        </trans-unit>
        <trans-unit id="f636b5861ee4fae57e7d457d50fef770ecd7b810" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; was called, you may want to enable the flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;. This flag is not permitted together with &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt;, so this function is provided to enable the feature after &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; is called. This function also resets the iterator to its initial state.</source>
          <target state="translated">如果&lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; &lt;/a&gt;，则可能要启用标记&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;。不允许将此标志与&lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt;一起使用，因此提供此函数以在&lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; &lt;/a&gt;之后启用该功能。此功能还可以将迭代器重置为其初始状态。</target>
        </trans-unit>
        <trans-unit id="1cac2a31adf2200c294f5c075bb6c153e55fa5a2" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is #defined, but &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is not, the C-API is declared to be &lt;code&gt;void**&lt;/code&gt;, so that it will also be visible to other compilation units.</source>
          <target state="translated">如果&lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt;定义了PY_ARRAY_UNIQUE_SYMBOL，但没有定义&lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; &lt;/a&gt;，则C-API被声明为 &lt;code&gt;void**&lt;/code&gt; ，因此其他编译单元也可以看到它。</target>
        </trans-unit>
        <trans-unit id="b3b296f263651378da8d936805870023810c7d29" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is not specified, but &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is specified (and is not an ndarray sub-class), the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; of the MaskedArray will be reset. If neither &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are specified (or if &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is an ndarray sub-class), then the fill value is preserved. Finally, if &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is specified, but &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not, the fill value is set to the specified value.</source>
          <target state="translated">如果&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;未指定，但&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;被指定（并且不是ndarray亚类），则&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;的MaskedArray的将被复位。如果既没有&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;也不&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;被指定的（或如果&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;是ndarray亚类），那么填充值被保留。最后，如果&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;指定，但&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;是没有的，而填充值被设置为指定的值。</target>
        </trans-unit>
        <trans-unit id="f0fe9dfd78027e91a1bff4d801d8eb87a4610a71" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is not specified, but &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is specified (and is not an ndarray sub-class), the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; of the MaskedArray will be reset. If neither &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are specified (or if &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is an ndarray sub-class), then the fill value is preserved. Finally, if &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is specified, but &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not, the fill value is set to the specified value.</source>
          <target state="translated">如果&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;未指定，但&lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;被指定（并且不是ndarray亚类），则&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;的MaskedArray的将被复位。如果既没有&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;也不&lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;被指定的（或如果&lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;是ndarray亚类），那么填充值被保留。最后，如果&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;指定，但&lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;是没有的，而填充值被设置为指定的值。</target>
        </trans-unit>
        <trans-unit id="bd7a3692bd40eb6528a52fa63a028a54110d3c3d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; is 1-D, the function &lt;code&gt;ufunc.accumulate(array)&lt;/code&gt; is the same as &lt;code&gt;ufunc.reduceat(array, indices)[::2]&lt;/code&gt; where &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;range(len(array) - 1)&lt;/code&gt; with a zero placed in every other element: &lt;code&gt;indices = zeros(2 * len(array) - 1)&lt;/code&gt;, &lt;code&gt;indices[1::2] = range(1, len(array))&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt;是1- d，函数 &lt;code&gt;ufunc.accumulate(array)&lt;/code&gt; 是一样的 &lt;code&gt;ufunc.reduceat(array, indices)[::2]&lt;/code&gt; ，其中&lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt;是 &lt;code&gt;range(len(array) - 1)&lt;/code&gt; 具有零放置在每其他元素： &lt;code&gt;indices = zeros(2 * len(array) - 1)&lt;/code&gt; ， &lt;code&gt;indices[1::2] = range(1, len(array))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc062e126b3bd61e02f7b3e167657fb84a747f47" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation</source>
          <target state="translated">如果&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;None&lt;/code&gt; ，&lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt; &lt;code&gt;numpy.format_parser&lt;/code&gt; &lt;/a&gt;这些参数传递给numpy.format_parser来构造dtype。请参阅该功能以获取详细文档</target>
        </trans-unit>
        <trans-unit id="f05f58b7f416905ebe6f79d07e2a76e9b7837051" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation.</source>
          <target state="translated">如果&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;None&lt;/code&gt; ，&lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt; &lt;code&gt;numpy.format_parser&lt;/code&gt; &lt;/a&gt;这些参数传递给numpy.format_parser来构造dtype。有关详细文档，请参见该功能。</target>
        </trans-unit>
        <trans-unit id="b6b83b00b9ce96c4a5e91132daa4d55535f9e96d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is set, array is copied only if dtype does not match:</source>
          <target state="translated">如果设置了&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;，则仅当dtype不匹配时才复制数组：</target>
        </trans-unit>
        <trans-unit id="4fc8bcfc9864193d76a4195dd238fe6624ed9a71" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is not one dimensional, the output also has these dimensions.</source>
          <target state="translated">如果&lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt;不是一维，则输出也具有这些维。</target>
        </trans-unit>
        <trans-unit id="6ede9f1a1e5701156394dbca76c84f8a340a9cea" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is not specified, but &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is specified (and is not an ndarray sub-class), the &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; of the MaskedArray will be reset. If neither &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are specified (or if &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is an ndarray sub-class), then the fill value is preserved. Finally, if &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is specified, but &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not, the fill value is set to the specified value.</source>
          <target state="translated">如果&lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;未指定，但&lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;被指定（并且不是ndarray亚类），则&lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;的MaskedArray的将被复位。如果既没有&lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;也不&lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;被指定的（或如果&lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;是ndarray亚类），那么填充值被保留。最后，如果&lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt;指定，但&lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;是没有的，而填充值被设置为指定的值。</target>
        </trans-unit>
        <trans-unit id="8d5ce8d43810f8659a3ffbe656fd3c96f0228399" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is a string, it is interpreted as a matrix with commas or spaces separating columns, and semicolons separating rows.</source>
          <target state="translated">如果&lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt;是字符串，则将其解释为矩阵，其中用逗号或空格分隔列，用分号分隔行。</target>
        </trans-unit>
        <trans-unit id="006799ea3355b83be37fd21ad89f661aac343125" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, then this flag determines whether the data is copied (the default), or whether a view is constructed.</source>
          <target state="translated">如果&lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt;已经是&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，则此标志确定是否复制数据（默认值）或是否构造视图。</target>
        </trans-unit>
        <trans-unit id="ad28cc6c8a4f0eed400b04898af33bdfb6744bee" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; has length one i.e. &lt;code&gt;(N,)&lt;/code&gt;, or is a scalar &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;out&lt;/code&gt; becomes a single row matrix of shape &lt;code&gt;(1,N)&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; 的&lt;/a&gt;长度为一个，即 &lt;code&gt;(N,)&lt;/code&gt; 或为标量 &lt;code&gt;N&lt;/code&gt; ，则 &lt;code&gt;out&lt;/code&gt; 变为形状 &lt;code&gt;(1,N)&lt;/code&gt; 的单行矩阵。</target>
        </trans-unit>
        <trans-unit id="f12c5c9464a76ef6881e238c0f45cc6cb56cab96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;filename.pyf&amp;gt;&lt;/code&gt; is specified as &lt;code&gt;stdout&lt;/code&gt; then signatures are send to standard output instead of a file.</source>
          <target state="translated">如果将 &lt;code&gt;&amp;lt;filename.pyf&amp;gt;&lt;/code&gt; 指定为 &lt;code&gt;stdout&lt;/code&gt; ,则签名将发送到标准输出而不是文件。</target>
        </trans-unit>
        <trans-unit id="22e7424cfa201c4ec783e98a6da198e97606627a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; contains a signature file, then a source for an extension module is constructed, all Fortran and C sources are compiled, and finally all object and library files are linked to the extension module &lt;code&gt;&amp;lt;modulename&amp;gt;.so&lt;/code&gt; which is saved into the current directory.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; 包含签名文件，则将构建扩展模块的源，编译所有Fortran和C源，最后将所有对象和库文件链接到扩展模块 &lt;code&gt;&amp;lt;modulename&amp;gt;.so&lt;/code&gt; ，将其保存到当前目录。</target>
        </trans-unit>
        <trans-unit id="207fbf09fcd7223478aec74725e5d0380117e758" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; does not contain a signature file, then an extension module is constructed by scanning all Fortran source codes for routine signatures.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; 不包含签名文件，则通过扫描所有Fortran源代码以获取常规签名来构建扩展模块。</target>
        </trans-unit>
        <trans-unit id="3b197e7232928483bec23ab77c22b02eb5eeb910" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt;, &lt;code&gt;reps&lt;/code&gt; is promoted to &lt;code&gt;A&lt;/code&gt;.ndim by pre-pending 1&amp;rsquo;s to it. Thus for an &lt;code&gt;A&lt;/code&gt; of shape (2, 3, 4, 5), a &lt;code&gt;reps&lt;/code&gt; of (2, 2) is treated as (1, 1, 2, 2).</source>
          <target state="translated">如果 &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt; ，则通过 &lt;code&gt;A&lt;/code&gt; 前面加上1 来将 &lt;code&gt;reps&lt;/code&gt; 提升为A.ndim。因此，对于 &lt;code&gt;A&lt;/code&gt; 形状（2，3，4，5）的，一个 &lt;code&gt;reps&lt;/code&gt; 的（2,2）被视为（1,1，2,2）。</target>
        </trans-unit>
        <trans-unit id="dbe88f61ce8f631b9b28c692a7753b41fb5fe9e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is promoted to be d-dimensional by prepending new axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication, or shape (1, 1, 3) for 3-D replication. If this is not the desired behavior, promote &lt;code&gt;A&lt;/code&gt; to d-dimensions manually before calling this function.</source>
          <target state="translated">如果 &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt; ，则通过添加新轴将 &lt;code&gt;A&lt;/code&gt; 提升为d维。因此，将形状（3，）阵列提升为（1，3）以进行2D复制，或将形状（1、1、3）提升为3D复制。如果这不是所需的行为，请在调用此函数之前手动 &lt;code&gt;A&lt;/code&gt; 提升为d维。</target>
        </trans-unit>
        <trans-unit id="7f85c71b217560bd561bde5602b4923ab34868ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, the result will contain the number of samples in each bin. If &lt;code&gt;True&lt;/code&gt;, the result is the value of the probability &lt;em&gt;density&lt;/em&gt; function at the bin, normalized such that the &lt;em&gt;integral&lt;/em&gt; over the range is 1. Note that the sum of the histogram values will not be equal to 1 unless bins of unity width are chosen; it is not a probability &lt;em&gt;mass&lt;/em&gt; function.</source>
          <target state="translated">如果为 &lt;code&gt;False&lt;/code&gt; ，则结果将包含每个bin中的样本数。如果为 &lt;code&gt;True&lt;/code&gt; ，则结果是bin处的概率&lt;em&gt;密度&lt;/em&gt;函数的值，将其标准化以使该范围内的&lt;em&gt;积分&lt;/em&gt;为1。注意，除非选择了单位宽度的bin，否则直方图值的总和将不等于1；它不是概率&lt;em&gt;质量&lt;/em&gt;函数。</target>
        </trans-unit>
        <trans-unit id="ca7cba1e4456723daee790d09bd9b4e007a0b7f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;None&lt;/code&gt; (default), all constants are assumed to be zero. If &lt;code&gt;m = 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">如果为 &lt;code&gt;None&lt;/code&gt; （默认），则所有常量均假定为零。如果 &lt;code&gt;m = 1&lt;/code&gt; ，则可以给出单个标量而不是列表。</target>
        </trans-unit>
        <trans-unit id="aec21489ec4d901f1aa321dc3743c87fb290d768" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, swap bytes in-place, default is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">如果为 &lt;code&gt;True&lt;/code&gt; ，则就地交换字节，默认值为 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2e3fbb074311bdb46e2b67afbf7fb14e162de56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, the cutoff of &lt;code&gt;precision&lt;/code&gt; digits refers to the total number of digits after the decimal point, including leading zeros. If &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;precision&lt;/code&gt; refers to the total number of significant digits, before or after the decimal point, ignoring leading zeros.</source>
          <target state="translated">如果为 &lt;code&gt;True&lt;/code&gt; ，则 &lt;code&gt;precision&lt;/code&gt; 数字的截止点是指小数点后的位数总数，包括前导零。如果为 &lt;code&gt;False&lt;/code&gt; ，则 &lt;code&gt;precision&lt;/code&gt; 是指小数点前后的有效位数总数，忽略了前导零。</target>
        </trans-unit>
        <trans-unit id="a29f76a184d9fb35f364bb63d222c84be040ac5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, then cache the first function call that determines the number of outputs if &lt;code&gt;otypes&lt;/code&gt; is not provided.</source>
          <target state="translated">如果为 &lt;code&gt;True&lt;/code&gt; ，则在未提供 &lt;code&gt;otypes&lt;/code&gt; 的情况下，缓存确定输出数量的第一个函数调用。</target>
        </trans-unit>
        <trans-unit id="7faac3985b746b05ac26d42bd00cce4fcc2669d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">如果为 &lt;code&gt;True&lt;/code&gt; ，则使用数字生成策略，该策略给出最短的表示形式，通过明​​智的舍入，可以从相同类型的其他值中唯一标识浮点数。如果省略了 &lt;code&gt;precision&lt;/code&gt; ，则打印所有必需的数字，否则在 &lt;code&gt;precision&lt;/code&gt; 数字后将切断数字生成，并将剩余值四舍五入。如果为 &lt;code&gt;False&lt;/code&gt; ，则生成数字，就好像打印一个无限精度的值并在 &lt;code&gt;precision&lt;/code&gt; 数字之后停止一样，将剩余值四舍五入。</target>
        </trans-unit>
        <trans-unit id="d46a903cfc558730b35e63368d27aca2360607f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print out all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">如果为 &lt;code&gt;True&lt;/code&gt; ，则使用数字生成策略，该策略给出最短的表示形式，通过明​​智的舍入，可以从相同类型的其他值中唯一标识浮点数。如果省略了 &lt;code&gt;precision&lt;/code&gt; ，则输出所有必需的数字，否则在 &lt;code&gt;precision&lt;/code&gt; 数字后将中断数字生成，并将剩余值四舍五入。如果为 &lt;code&gt;False&lt;/code&gt; ，则生成数字，就好像打印一个无限精度的值并在 &lt;code&gt;precision&lt;/code&gt; 数字之后停止一样，将剩余值四舍五入。</target>
        </trans-unit>
        <trans-unit id="e630a68b772e53281799a75b2daa484538be6573" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; ，则 &lt;code&gt;V&lt;/code&gt; 的列按顺序对应于形状为（xdeg + 1，ydeg + 1）的二维系数数组 &lt;code&gt;c&lt;/code&gt; 的元素</target>
        </trans-unit>
        <trans-unit id="8cbfd70f5cc4a9c80c1b3f4ac628ba80decf75d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; ，然后的列 &lt;code&gt;V&lt;/code&gt; 对应于3-d系数数组的元素 &lt;code&gt;c&lt;/code&gt; 形状（xdeg + 1的ydeg + 1，...，ZDEG + 1）按顺序</target>
        </trans-unit>
        <trans-unit id="00bfc10fc177e8c4f7b6b34693c411592fe272c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt; ，则 &lt;code&gt;V&lt;/code&gt; 的列按顺序对应于形状为（xdeg + 1，ydeg + 1）的二维系数数组 &lt;code&gt;c&lt;/code&gt; 的元素</target>
        </trans-unit>
        <trans-unit id="a7c811e070f694575d65f49ba72909eaec417a6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; ，然后的列 &lt;code&gt;V&lt;/code&gt; 对应于3-d系数数组的元素 &lt;code&gt;c&lt;/code&gt; 形状（xdeg + 1的ydeg + 1，...，ZDEG + 1）按顺序</target>
        </trans-unit>
        <trans-unit id="262fc8f05dc54d641c4705041f46d8b6c771c1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; ，则 &lt;code&gt;V&lt;/code&gt; 的列按顺序对应于形状为（xdeg + 1，ydeg + 1）的二维系数数组 &lt;code&gt;c&lt;/code&gt; 的元素</target>
        </trans-unit>
        <trans-unit id="066ad3b1f4c835bc91d8b4d1ca954772c0457a46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; ，然后的列 &lt;code&gt;V&lt;/code&gt; 对应于3-d系数数组的元素 &lt;code&gt;c&lt;/code&gt; 形状（xdeg + 1的ydeg + 1，...，ZDEG + 1）按顺序</target>
        </trans-unit>
        <trans-unit id="6596fc02b05eb1b57c388bcee28f45c0fa647e79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; ，则 &lt;code&gt;V&lt;/code&gt; 的列按顺序对应于形状为（xdeg + 1，ydeg + 1）的二维系数数组 &lt;code&gt;c&lt;/code&gt; 的元素</target>
        </trans-unit>
        <trans-unit id="658f3ceb580a0341f1c8e14be933e5829c9b95b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; ，然后的列 &lt;code&gt;V&lt;/code&gt; 对应于3-d系数阵列的元件 &lt;code&gt;c&lt;/code&gt; 形状的（xdeg + 1，ydeg + 1，ZDEG + 1）按顺序</target>
        </trans-unit>
        <trans-unit id="102bddd53317314797d80d0b03e0de44ee8eec62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; ，则 &lt;code&gt;V&lt;/code&gt; 的列按顺序对应于形状为（xdeg + 1，ydeg + 1）的二维系数数组 &lt;code&gt;c&lt;/code&gt; 的元素</target>
        </trans-unit>
        <trans-unit id="f9e4383801f2b61b08f9300b1b7fdf17e1c3f488" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; ，然后的列 &lt;code&gt;V&lt;/code&gt; 对应于3-d系数阵列的元件 &lt;code&gt;c&lt;/code&gt; 形状的（xdeg + 1，ydeg + 1，ZDEG + 1）按顺序</target>
        </trans-unit>
        <trans-unit id="c691cf5dd3bcc26326919122a716b1456743d83e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; ，则 &lt;code&gt;V&lt;/code&gt; 的列按顺序对应于形状为（xdeg + 1，ydeg + 1）的二维系数数组 &lt;code&gt;c&lt;/code&gt; 的元素</target>
        </trans-unit>
        <trans-unit id="3795a0fc387856e1a4fb9463ff23e8e2dc033c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">如果 &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; ，然后的列 &lt;code&gt;V&lt;/code&gt; 对应于3-d系数数组的元素 &lt;code&gt;c&lt;/code&gt; 形状（xdeg + 1的ydeg + 1，...，ZDEG + 1）按顺序</target>
        </trans-unit>
        <trans-unit id="f8959bef2f1f180cd1904ca3003b3eeaecf0bbcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt;, return the fill value, otherwise return None.</source>
          <target state="translated">如果 &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt; ，则返回填充值，否则返回None。</target>
        </trans-unit>
        <trans-unit id="8f6e1a60280ed3603677c79dbcdebfa7ff398c42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt;, then the dimensions specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are removed, and a new axis inserted at the end corresponding to the diagonal.</source>
          <target state="translated">如果 &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; ，则将删除由 &lt;code&gt;axis1&lt;/code&gt; 和 &lt;code&gt;axis2&lt;/code&gt; 指定的尺寸，并在与对角线相对应的一端插入新的轴。</target>
        </trans-unit>
        <trans-unit id="64c4131bb0fe8a413fc2bc1ebe219f3e36ea1e9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim&lt;/code&gt; is 0, then since the depth of the nested list is 0, it will not be a list at all, but a simple Python scalar.</source>
          <target state="translated">如果 &lt;code&gt;a.ndim&lt;/code&gt; 为0，则由于嵌套列表的深度为0，因此它根本不是列表，而是简单的Python标量。</target>
        </trans-unit>
        <trans-unit id="355d7bac3059f5072f60fecea5ae0b7d9ef0b74d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.shape&lt;/code&gt; is (5,1), &lt;code&gt;b.shape&lt;/code&gt; is (1,6), &lt;code&gt;c.shape&lt;/code&gt; is (6,) and &lt;code&gt;d.shape&lt;/code&gt; is () so that &lt;em&gt;d&lt;/em&gt; is a scalar, then &lt;em&gt;a&lt;/em&gt;, &lt;em&gt;b&lt;/em&gt;, &lt;em&gt;c&lt;/em&gt;, and &lt;em&gt;d&lt;/em&gt; are all broadcastable to dimension (5,6); and</source>
          <target state="translated">如果 &lt;code&gt;a.shape&lt;/code&gt; 为（5,1）， &lt;code&gt;b.shape&lt;/code&gt; 为（1,6）， &lt;code&gt;c.shape&lt;/code&gt; 为（6，）和 &lt;code&gt;d.shape&lt;/code&gt; 为（）使得&lt;em&gt;d&lt;/em&gt;为标量，则&lt;em&gt;a&lt;/em&gt;，&lt;em&gt;b&lt;/em&gt;，&lt;em&gt;c&lt;/em&gt;，和&lt;em&gt;d&lt;/em&gt;都可广播至维度（5,6）；和</target>
        </trans-unit>
        <trans-unit id="61914428b3107b079ee31cfc27e080d8a722c6a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are nonscalar, their last dimensions must match.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 是非标量的，则它们的最后尺寸必须匹配。</target>
        </trans-unit>
        <trans-unit id="b4f4e526a35a19438379df1f3dbff9a3882d194d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and each choice array are not all broadcastable to the same shape.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 和每一个选择阵列是不是所有broadcastable到相同的形状。</target>
        </trans-unit>
        <trans-unit id="6714bc3434562dda36e8035d926f1d408c7a5936" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; does not own its own data or references or views to it exist, and the data memory must be changed. PyPy only: will always raise if the data memory must be changed, since there is no reliable way to determine if references or views to it exist.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 不拥有自己的数据或存在对其的引用或视图，则必须更改数据存储器。仅限于PyPy：如果必须更改数据存储器，将始终升高，因为没有可靠的方法来确定是否存在对其的引用或视图。</target>
        </trans-unit>
        <trans-unit id="d46ad13c1a8181bf81ec49d29f19d0a4e8222929" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then broadcasting rules apply, as explained in &lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;Linear algebra on several matrices at once&lt;/a&gt;. This means that SVD is working in &amp;ldquo;stacked&amp;rdquo; mode: it iterates over all indices of the first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions and for each combination SVD is applied to the last two indices. The matrix &lt;code&gt;a&lt;/code&gt; can be reconstructed from the decomposition with either &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; or &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt;. (The &lt;code&gt;@&lt;/code&gt; operator can be replaced by the function &lt;code&gt;np.matmul&lt;/code&gt; for python versions below 3.5.)</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 具有两个以上的维，则适用广播规则，如&lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;一次线性代数在多个矩阵上所述&lt;/a&gt;。这意味着SVD在&amp;ldquo;堆叠&amp;rdquo;模式下工作：迭代第一个 &lt;code&gt;a.ndim - 2&lt;/code&gt; 维的所有索引，并且对于每种组合，SVD应用于最后两个索引。可以使用 &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; 或 &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt; 从分解中重建矩阵 &lt;code&gt;a&lt;/code&gt; 。 （对于3.5以下的python版本， &lt;code&gt;@&lt;/code&gt; 运算符可以由 &lt;code&gt;np.matmul&lt;/code&gt; 函数代替。）</target>
        </trans-unit>
        <trans-unit id="0f5e97c2878caebdac54716045091816869ce6d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by axis1 and axis2 are used to determine the 2-D sub-arrays whose traces are returned. The shape of the resulting array is the same as that of &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; removed.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 具有两个以上的维，则使用axis1和axis2指定的轴来确定要返回其迹线的2-D子数组。所得数组的形状与除去了 &lt;code&gt;axis1&lt;/code&gt; 和 &lt;code&gt;axis2&lt;/code&gt; 的 &lt;code&gt;a&lt;/code&gt; 的形状相同。</target>
        </trans-unit>
        <trans-unit id="1b46ead587370435670ac4bc03b81d9c95e42b33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 1-D, the function &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; is the same as &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; where &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;range(len(array) - 1)&lt;/code&gt; with a zero placed in every other element: &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt;, &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是1-d，函数 &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; 是相同的 &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; ，其中&lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt;是 &lt;code&gt;range(len(array) - 1)&lt;/code&gt; 具有零放置在每其他元素： &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt; ， &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b8db921b8261a5150c028a4a52e2a78422e254b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, returns the diagonal of &lt;code&gt;a&lt;/code&gt; with the given offset, i.e., the collection of elements of the form &lt;code&gt;a[i, i+offset]&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are used to determine the 2-D sub-array whose diagonal is returned. The shape of the resulting array can be determined by removing &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; and appending an index to the right equal to the size of the resulting diagonals.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是2-D，则返回给定偏移量 &lt;code&gt;a&lt;/code&gt; 的对角线，即，形式为 &lt;code&gt;a[i, i+offset]&lt;/code&gt; 的元素的集合。如果 &lt;code&gt;a&lt;/code&gt; 具有两个以上的维，则使用 &lt;code&gt;axis1&lt;/code&gt; 和 &lt;code&gt;axis2&lt;/code&gt; 指定的轴来确定返回对角线的2-D子数组。可以通过删除 &lt;code&gt;axis1&lt;/code&gt; 和 &lt;code&gt;axis2&lt;/code&gt; 并在右边添加一个等于所得对角线大小的索引来确定所得数组的形状。</target>
        </trans-unit>
        <trans-unit id="016f6a15e05ea7909f939f7c56abdd96bd940bcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along its diagonal with the given offset is returned, i.e., the sum of elements &lt;code&gt;a[i,i+offset]&lt;/code&gt; for all i.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 为2-D，则返回沿其对角线具有给定偏移的和，即，所有i 的元素 &lt;code&gt;a[i,i+offset]&lt;/code&gt; 和。</target>
        </trans-unit>
        <trans-unit id="821330dbafd930ef241f18ef291a677b001e3d1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along the diagonal is returned. If &lt;code&gt;a&lt;/code&gt; has larger dimensions, then an array of sums along diagonals is returned.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 为二维，则返回沿对角线的总和。如果 &lt;code&gt;a&lt;/code&gt; 的尺寸较大，则返回沿对角线的总和数组。</target>
        </trans-unit>
        <trans-unit id="20e0991e165d15052f7414c1d9067709a6741ba8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, then a 1-D array containing the diagonal and of the same type as &lt;code&gt;a&lt;/code&gt; is returned unless &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, in which case a 1-D array rather than a (2-D) &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; is returned in order to maintain backward compatibility.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是2- d，然后将含有对角线和一个1-d阵列作为相同类型的 &lt;code&gt;a&lt;/code&gt; 被返回，除非 &lt;code&gt;a&lt;/code&gt; 是一个&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;在这种情况下，1-d阵列而不是一个（2-d），&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;被返回为了保持向后兼容。</target>
        </trans-unit>
        <trans-unit id="65772464bb82fc9b6e011b51f1c71a9673e3a5fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;matrix&lt;/code&gt; object (as opposed to an &lt;code&gt;ndarray&lt;/code&gt;), then so are all the return values.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是一个 &lt;code&gt;matrix&lt;/code&gt; 对象（与 &lt;code&gt;ndarray&lt;/code&gt; 相对），那么所有返回值也是如此。</target>
        </trans-unit>
        <trans-unit id="cea4b92a7534a3149383f752281c310050f705b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a reference to &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;(a is b) == True&lt;/code&gt;. Therefore, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are different names for the same Python object.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是对 &lt;code&gt;b&lt;/code&gt; 的引用，则 &lt;code&gt;(a is b) == True&lt;/code&gt; 。因此， &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 是同一Python对象的不同名称。</target>
        </trans-unit>
        <trans-unit id="f198160018800c5362e7b3890cbfcb18e618a7b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a subclass of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, its class is conserved. No copy is performed if the input is already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;的子类，则其类是保守的。如果输入已经是&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; ,则不&lt;/a&gt;执行复制。</target>
        </trans-unit>
        <trans-unit id="edeed84f3c81e9ebf31ecd438474825302f801e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a subclass of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, its class is conserved. No copy is performed if the input is already an &lt;code&gt;ndarray&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;的子类，则其类是保守的。如果输入已经是 &lt;code&gt;ndarray&lt;/code&gt; ,则不执行复制。</target>
        </trans-unit>
        <trans-unit id="79b3d97ca6a58beeb5178bade7556181ec643eb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is a 1-D array, it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是ND数组， &lt;code&gt;b&lt;/code&gt; 是1-D数组，则它是 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的最后一个轴的总和。</target>
        </trans-unit>
        <trans-unit id="41bd115d2530c0df6f893d58055a4e7bbeb51a86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is an M-D array (where &lt;code&gt;M&amp;gt;=2&lt;/code&gt;), it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and the second-to-last axis of &lt;code&gt;b&lt;/code&gt;:</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是一个ND阵列和 &lt;code&gt;b&lt;/code&gt; 是MD阵列（其中， &lt;code&gt;M&amp;gt;=2&lt;/code&gt; ），这是在最后一个轴和积 &lt;code&gt;a&lt;/code&gt; 和第二到最后一个的轴 &lt;code&gt;b&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e2d3d6c358f256f08097a63c0a16dbce473bc638" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is complex the complex conjugate is taken before calculation of the dot product.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是复数，则在计算点积之前采用复共轭。</target>
        </trans-unit>
        <trans-unit id="eccde6fba477d4d0328834eeb9139f4c209a7f8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;a&lt;/code&gt; itself is returned. If &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fill_value&lt;/code&gt; is None, &lt;code&gt;fill_value&lt;/code&gt; is set to &lt;code&gt;a.fill_value&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 不是&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;，则返回 &lt;code&gt;a&lt;/code&gt; 本身。如果 &lt;code&gt;a&lt;/code&gt; 为&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;并且 &lt;code&gt;fill_value&lt;/code&gt; 为None，则 &lt;code&gt;fill_value&lt;/code&gt; 设置为 &lt;code&gt;a.fill_value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ac306a4eb2b5b20798f61a7b119dddd329017ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not square or inversion fails.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 不是正方形或反转失败。</target>
        </trans-unit>
        <trans-unit id="dc36615c1be692990452f6adc2c02bec7979d9d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is real, the type of &lt;code&gt;a&lt;/code&gt; is used for the output. If &lt;code&gt;a&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是真实的类型， &lt;code&gt;a&lt;/code&gt; 用于输出。如果 &lt;code&gt;a&lt;/code&gt; 具有复杂元素，则返回的类型为float。</target>
        </trans-unit>
        <trans-unit id="49742c1cee8e9efafb1c7fbbe431a8e95469bbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not &amp;lsquo;square&amp;rsquo; (in the above sense).</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 是单数或不是&amp;ldquo;方形&amp;rdquo;（在上述的意义上）。</target>
        </trans-unit>
        <trans-unit id="2e9b74892f6f35d0326c1dc235300557d874f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not square.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 为奇数或非正方形。</target>
        </trans-unit>
        <trans-unit id="ceece9b2545779310cb6355ec10529e551268898" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=False&lt;/code&gt;, this method produces a &amp;ldquo;packed&amp;rdquo; memory layout in which each field starts at the byte the previous field ended, and any padding bytes are removed.</source>
          <target state="translated">如果 &lt;code&gt;align=False&lt;/code&gt; ，则此方法将产生&amp;ldquo;打包&amp;rdquo;内存布局，其中每个字段都从上一个字段结束的字节开始，然后删除所有填充字节。</target>
        </trans-unit>
        <trans-unit id="460932656f30d1ee879c1ced09e2eca3e1ff623d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=True&lt;/code&gt; is set, numpy will pad the structure in the same way many C compilers would pad a C-struct. Aligned structures can give a performance improvement in some cases, at the cost of increased datatype size. Padding bytes are inserted between fields such that each field&amp;rsquo;s byte offset will be a multiple of that field&amp;rsquo;s alignment, which is usually equal to the field&amp;rsquo;s size in bytes for simple datatypes, see &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr.alignment&quot;&gt;&lt;code&gt;PyArray_Descr.alignment&lt;/code&gt;&lt;/a&gt;. The structure will also have trailing padding added so that its itemsize is a multiple of the largest field&amp;rsquo;s alignment.</source>
          <target state="translated">如果设置了 &lt;code&gt;align=True&lt;/code&gt; ，numpy将以许多C编译器填充C结构的相同方式填充该结构。在某些情况下，对齐的结构可以提高性能，但要增加数据类型的大小。在字段之间插入填充字节，以便每个字段的字节偏移量将是该字段对齐方式的倍数，对于简单数据类型，该偏移量通常等于该字段的大小（以字节为单位），请参阅&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr.alignment&quot;&gt; &lt;code&gt;PyArray_Descr.alignment&lt;/code&gt; &lt;/a&gt;。该结构还将添加尾随填充，以便其项大小是最大字段对齐方式的倍数。</target>
        </trans-unit>
        <trans-unit id="3b8c190caa583967ef3d50f42e6abb370b98e8c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=True&lt;/code&gt;, this methods produces an &amp;ldquo;aligned&amp;rdquo; memory layout in which each field&amp;rsquo;s offset is a multiple of its alignment, and the total itemsize is a multiple of the largest alignment, by adding padding bytes as needed.</source>
          <target state="translated">如果 &lt;code&gt;align=True&lt;/code&gt; ，则此方法通过根据需要添加填充字节来生成&amp;ldquo;对齐的&amp;rdquo;内存布局，其中每个字段的偏移量是其对齐方式的倍数，总项大小是最大对齐方式的倍数。</target>
        </trans-unit>
        <trans-unit id="18f554f1ca3b0160e94e964322795aa916ef0365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr&lt;/code&gt; doesn&amp;rsquo;t have a shape attribute (i.e. not an ndarray)</source>
          <target state="translated">如果 &lt;code&gt;arr&lt;/code&gt; 没有shape属性（即不是ndarray）</target>
        </trans-unit>
        <trans-unit id="6f94c014869b41cb6e3e090bab6cec3fc3652e46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axes&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;axes&lt;/code&gt; 大于 &lt;code&gt;a&lt;/code&gt; 的最后一个轴。</target>
        </trans-unit>
        <trans-unit id="fb5967cac1f9c838f629289b9701f4f5d967c63e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 0, only rows are masked.</source>
          <target state="translated">如果 &lt;code&gt;axis&lt;/code&gt; 为0，则仅屏蔽行。</target>
        </trans-unit>
        <trans-unit id="e77d1c339b65acf6a89a949d1d50328c8561be33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 1 or -1, only columns are masked.</source>
          <target state="translated">如果 &lt;code&gt;axis&lt;/code&gt; 为1或-1，则仅掩盖列。</target>
        </trans-unit>
        <trans-unit id="527dba2aee917b7e820a9015382f439872829fc2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, rows &lt;em&gt;and&lt;/em&gt; columns are masked.</source>
          <target state="translated">如果 &lt;code&gt;axis&lt;/code&gt; 为None，则将屏蔽行&lt;em&gt;和&lt;/em&gt;列。</target>
        </trans-unit>
        <trans-unit id="1c5e761c4a44d3d8422fc68aeed03dd9853a0a7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, the result is a scalar. Otherwise, if &lt;code&gt;axis&lt;/code&gt; is given and the array is at least 2-D, the result is a masked array with dimension one smaller than the array on which &lt;a href=&quot;#numpy.ma.masked_array.mini&quot;&gt;&lt;code&gt;mini&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">如果 &lt;code&gt;axis&lt;/code&gt; 为None，则结果为标量。否则，如果给定 &lt;code&gt;axis&lt;/code&gt; 并且该数组至少为2D，则结果是一个掩码数组，其维数比调用&lt;a href=&quot;#numpy.ma.masked_array.mini&quot;&gt; &lt;code&gt;mini&lt;/code&gt; &lt;/a&gt;的数组小一。</target>
        </trans-unit>
        <trans-unit id="042bc001a4914cd7d0d232c6f0fb346989909740" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is an integer, it specifies the axis of &lt;code&gt;x&lt;/code&gt; along which to compute the vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If &lt;code&gt;axis&lt;/code&gt; is None then either a vector norm (when &lt;code&gt;x&lt;/code&gt; is 1-D) or a matrix norm (when &lt;code&gt;x&lt;/code&gt; is 2-D) is returned.</source>
          <target state="translated">如果 &lt;code&gt;axis&lt;/code&gt; 是整数，则它指定 &lt;code&gt;x&lt;/code&gt; 的轴，沿着该轴计算矢量范数。如果 &lt;code&gt;axis&lt;/code&gt; 是2元组，则它指定保存2D矩阵的轴，并计算这些矩阵的矩阵范数。如果 &lt;code&gt;axis&lt;/code&gt; 为None，则返回向量范数（当 &lt;code&gt;x&lt;/code&gt; 为1-D时）或矩阵范数（当 &lt;code&gt;x&lt;/code&gt; 为2-D时）。</target>
        </trans-unit>
        <trans-unit id="bfadfc7eb4a4188168e39022bbb71c1c25d02efa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is an integer, it specifies the axis of &lt;code&gt;x&lt;/code&gt; along which to compute the vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If &lt;code&gt;axis&lt;/code&gt; is None then either a vector norm (when &lt;code&gt;x&lt;/code&gt; is 1-D) or a matrix norm (when &lt;code&gt;x&lt;/code&gt; is 2-D) is returned. The default is None.</source>
          <target state="translated">如果 &lt;code&gt;axis&lt;/code&gt; 是整数，则它指定 &lt;code&gt;x&lt;/code&gt; 的轴，沿着该轴计算矢量范数。如果 &lt;code&gt;axis&lt;/code&gt; 是2元组，则它指定保存2D矩阵的轴，并计算这些矩阵的矩阵范数。如果 &lt;code&gt;axis&lt;/code&gt; 为None，则返回向量范数（当 &lt;code&gt;x&lt;/code&gt; 为1-D时）或矩阵范数（当 &lt;code&gt;x&lt;/code&gt; 为2-D时）。默认值为&amp;ldquo;无&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="523d86ecb59b40a9d925f2a1e78fa6cb76926a2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is given, the number of varargs must equal the number of axes. Default: 1.</source>
          <target state="translated">如果给定 &lt;code&gt;axis&lt;/code&gt; ，则可变参数的数量必须等于轴的数量。默认值：1。</target>
        </trans-unit>
        <trans-unit id="86e33ec8c24f94e2430b0659a5ab81a91a91d564" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;axis&lt;/code&gt; 大于 &lt;code&gt;a&lt;/code&gt; 的最后一个轴。</target>
        </trans-unit>
        <trans-unit id="b10999639108c4b4999de59d1e8da7d5676f431c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, and an axis being squeezed is not of length 1</source>
          <target state="translated">如果 &lt;code&gt;axis&lt;/code&gt; 不为 &lt;code&gt;None&lt;/code&gt; ，并且被压缩的轴的长度不为1</target>
        </trans-unit>
        <trans-unit id="048ac1275e643db0f79c87e34405c76349afe0b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not None, and an axis being squeezed is not of length 1</source>
          <target state="translated">如果 &lt;code&gt;axis&lt;/code&gt; 不为None，并且被压缩的轴的长度不为1</target>
        </trans-unit>
        <trans-unit id="62e5f5a4f466db64bba565371ecaf3c0accbb2cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b = a[:100]&lt;/code&gt; is used instead, &lt;code&gt;a&lt;/code&gt; is referenced by &lt;code&gt;b&lt;/code&gt; and will persist in memory even if &lt;code&gt;del a&lt;/code&gt; is executed.</source>
          <target state="translated">如果改用 &lt;code&gt;b = a[:100]&lt;/code&gt; ，则 &lt;code&gt;a&lt;/code&gt; 被 &lt;code&gt;b&lt;/code&gt; 引用，并且即使执行 &lt;code&gt;del a&lt;/code&gt; 也将保留在内存中。</target>
        </trans-unit>
        <trans-unit id="b1ba1d797cf86b71e14a5b8da31b21199908a909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is a matrix, then all array results are returned as matrices.</source>
          <target state="translated">如果 &lt;code&gt;b&lt;/code&gt; 是矩阵，则所有数组结果都作为矩阵返回。</target>
        </trans-unit>
        <trans-unit id="ca0b482dcb07a6085a21a5bc1b0dde224b2f172c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string from the list below, &lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt; will use the method chosen to calculate the optimal bin width and consequently the number of bins (see &lt;code&gt;Notes&lt;/code&gt; for more detail on the estimators) from the data that falls within the requested range. While the bin width will be optimal for the actual data in the range, the number of bins will be computed to fill the entire range, including the empty portions. For visualisation, using the &amp;lsquo;auto&amp;rsquo; option is suggested. Weighted data is not supported for automated bin size selection.</source>
          <target state="translated">如果 &lt;code&gt;bins&lt;/code&gt; 是下面列表中的字符串，则&lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; &lt;/a&gt;将使用选择的方法来计算最佳bin宽度，从而从落入请求范围内的数据计算出bin的数量（有关估计量的更多信息，请参见&amp;ldquo; &lt;code&gt;Notes&lt;/code&gt; &amp;rdquo;）。虽然仓宽对于该范围内的实际数据而言是最佳的，但是仓数将被计算为填充整个范围，包括空白部分。为了可视化，建议使用&amp;ldquo;自动&amp;rdquo;选项。自动箱大小选择不支持加权数据。</target>
        </trans-unit>
        <trans-unit id="b70a91ff0eb4c89d18a81d985f393eb13ac7933f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string, it defines the method used to calculate the optimal bin width, as defined by &lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;bins&lt;/code&gt; 是字符串，则它定义用于计算最佳bin宽度的方法，如&lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; &lt;/a&gt;所定义。</target>
        </trans-unit>
        <trans-unit id="cbffbf31546ec9af5b6fd778dfc3e0a7e49fc75c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">如果 &lt;code&gt;bins&lt;/code&gt; 是一个int，则它定义给定范围内的等宽垃圾箱数（默认为10个）。如果 &lt;code&gt;bins&lt;/code&gt; 是序列，则它将定义bin边缘（包括最右边）的单调递增数组，从而允许非均匀的bin宽度。</target>
        </trans-unit>
        <trans-unit id="b4024bb04b779936a7803a2173c03bd8c96f6ec1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines the bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">如果 &lt;code&gt;bins&lt;/code&gt; 是一个int，则它定义给定范围内的等宽垃圾箱数（默认为10个）。如果 &lt;code&gt;bins&lt;/code&gt; 是序列，则它将定义bin边缘（包括最右边），从而允许非均匀的bin宽度。</target>
        </trans-unit>
        <trans-unit id="f3d0d1457dc2c27ebf07eb8b8d37fdfe4b5b5f86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is not monotonic.</source>
          <target state="translated">如果 &lt;code&gt;bins&lt;/code&gt; 不是单调的。</target>
        </trans-unit>
        <trans-unit id="f1d57ef4cb7d5156a4314b6ea06d7045fe52a5fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is None, then only &lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;order&lt;/code&gt; are used.</source>
          <target state="translated">如果 &lt;code&gt;buffer&lt;/code&gt; 为None，则仅使用&lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb00c687c7393dfd8dae48855df788062a7f7eb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is None, then only &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;order&lt;/code&gt; are used.</source>
          <target state="translated">如果 &lt;code&gt;buffer&lt;/code&gt; 为None，则仅使用&lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3f34c748ade1a438e4af494b9939bb52d6b65ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is an object exposing the buffer interface, then all keywords are interpreted.</source>
          <target state="translated">如果 &lt;code&gt;buffer&lt;/code&gt; 是暴露buffer接口的对象，则将解释所有关键字。</target>
        </trans-unit>
        <trans-unit id="f67df360e18cb83b99203eea7e5b2b66896eaba4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffersize&lt;/code&gt; is zero, a default buffer size is used, otherwise it specifies how big of a buffer to use. Buffers which are powers of 2 such as 4096 or 8192 are recommended.</source>
          <target state="translated">如果 &lt;code&gt;buffersize&lt;/code&gt; 为零，则使用默认的缓冲区大小，否则它指定要使用的缓冲区大小。建议使用2的幂的缓冲区，例如4096或8192。</target>
        </trans-unit>
        <trans-unit id="beb58b828353ed80b8e0bbe892a75cbfcebae43d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than 3 dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 的尺寸少于3个，则将其隐式附加到其形状以使其成为3D。结果的形状将为c.shape [3：] + x.shape。</target>
        </trans-unit>
        <trans-unit id="f7c13f789159cee3609188e9f6918f23db3edd6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than three dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape + y.shape + z.shape.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 的尺寸少于三个，则将其隐式附加到其形状以使其成为3-D。结果的形状将为c.shape [3：] + x.shape + y.shape + z.shape。</target>
        </trans-unit>
        <trans-unit id="210c7187323274ff624491c071d18c59ba05eaa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape + y.shape.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 的尺寸少于二维，则将其隐式附加到其形状以使其成为二维。结果的形状将为c.shape [2：] + x.shape + y.shape。</target>
        </trans-unit>
        <trans-unit id="4b9c82b7f7444c244d3d87499e2e6abb52d1e818" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 的尺寸少于二维，则将其隐式附加到其形状以使其成为二维。结果的形状将为c.shape [2：] + x.shape。</target>
        </trans-unit>
        <trans-unit id="b813783672e3b8b110dcc3caed6943e29c499cf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array a one is implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是一维数组，则将其隐式附加到其形状以使其成为二维数组。结果的形状将为c.shape [2：] + x.shape。</target>
        </trans-unit>
        <trans-unit id="9b697950a550c5d2ac6bfd1a90d0ee0cf3873621" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermevander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermeval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of HermiteE series of the same degree and sample points.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是系数为 &lt;code&gt;n + 1&lt;/code&gt; 的一维数组，而 &lt;code&gt;V&lt;/code&gt; 是数组 &lt;code&gt;V = hermevander(x, n)&lt;/code&gt; ，则 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 和 &lt;code&gt;hermeval(x, c)&lt;/code&gt; 相同，直到四舍五入。这种等效性对于最小二乘拟合和评估相同程度和采样点的大量HermiteE系列都是有用的。</target>
        </trans-unit>
        <trans-unit id="8795163ae21f93104b677b1ca18c8738fd9a209a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Hermite series of the same degree and sample points.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是系数为 &lt;code&gt;n + 1&lt;/code&gt; 的一维数组，而 &lt;code&gt;V&lt;/code&gt; 是数组 &lt;code&gt;V = hermvander(x, n)&lt;/code&gt; ，则 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 和 &lt;code&gt;hermval(x, c)&lt;/code&gt; 相同，直到四舍五入。这种等效性对于最小二乘拟合和评估相同程度和采样点的大量Hermite级数都是有用的。</target>
        </trans-unit>
        <trans-unit id="41e4b417db13b3be059bf5b8693dedddbf2d39c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = lagvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;lagval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Laguerre series of the same degree and sample points.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是系数为 &lt;code&gt;n + 1&lt;/code&gt; 的一维数组，而 &lt;code&gt;V&lt;/code&gt; 是数组 &lt;code&gt;V = lagvander(x, n)&lt;/code&gt; ，则 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 和 &lt;code&gt;lagval(x, c)&lt;/code&gt; 相同，直到四舍五入。这种等效性对于最小二乘拟合以及对相同度数和采样点的大量Laguerre级数的评估都是有用的。</target>
        </trans-unit>
        <trans-unit id="a1b597f29a3697113f705d9c197e77e09839d912" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = legvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;legval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Legendre series of the same degree and sample points.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是系数为 &lt;code&gt;n + 1&lt;/code&gt; 的一维数组，而 &lt;code&gt;V&lt;/code&gt; 是数组 &lt;code&gt;V = legvander(x, n)&lt;/code&gt; ，则 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 和 &lt;code&gt;legval(x, c)&lt;/code&gt; 相同，直到四舍五入。这种等效性对于最小二乘拟合以及对相同程度和采样点的大量Legendre级数的评估都是有用的。</target>
        </trans-unit>
        <trans-unit id="b7f0c7e082f8807f04eefbe2acbae592bdec65ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = chebvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;chebval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Chebyshev series of the same degree and sample points.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是系数为 &lt;code&gt;n + 1&lt;/code&gt; 的一维数组，并且 &lt;code&gt;V&lt;/code&gt; 是矩阵 &lt;code&gt;V = chebvander(x, n)&lt;/code&gt; ，则 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 和 &lt;code&gt;chebval(x, c)&lt;/code&gt; 相同，直到四舍五入。这种等效性对于最小二乘拟合以及对相同程度和采样点的大量Chebyshev级数的评估都是有用的。</target>
        </trans-unit>
        <trans-unit id="4e382928aa8d32a6b35f8adca3a6cffe61170326" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = polyvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;polyval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of polynomials of the same degree and sample points.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是系数为 &lt;code&gt;n + 1&lt;/code&gt; 的一维数组，并且 &lt;code&gt;V&lt;/code&gt; 是矩阵 &lt;code&gt;V = polyvander(x, n)&lt;/code&gt; ，则 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 和 &lt;code&gt;polyval(x, c)&lt;/code&gt; 相同，直到四舍五入。这种等效性对于最小二乘拟合以及对相同度数和采样点的大量多项式的评估都是有用的。</target>
        </trans-unit>
        <trans-unit id="8e80660168c2556d80131aae5098ce463a202c8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is true the shape will be c.shape[1:] + x.shape. If &lt;code&gt;tensor&lt;/code&gt; is false the shape will be c.shape[1:]. Note that scalars have shape (,).</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是一维数组，则 &lt;code&gt;p(x)&lt;/code&gt; 将具有与 &lt;code&gt;x&lt;/code&gt; 相同的形状。如果 &lt;code&gt;c&lt;/code&gt; 是多维的，则结果的形状取决于 &lt;code&gt;tensor&lt;/code&gt; 的值。如果 &lt;code&gt;tensor&lt;/code&gt; 为真，则形状将为c.shape [1：] + x.shape。如果 &lt;code&gt;tensor&lt;/code&gt; 为假，则形状将为c.shape [1：]。请注意，标量具有形状（，）。</target>
        </trans-unit>
        <trans-unit id="0a3728daa3b2e189e758d347ca0d72357650db3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 的长度为 &lt;code&gt;n + 1&lt;/code&gt; ，则此函数返回值</target>
        </trans-unit>
        <trans-unit id="e3ad7dc6a355dfc8a1c8aa46843f5488897fd4ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value:</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 的长度为 &lt;code&gt;n + 1&lt;/code&gt; ，则此函数返回值：</target>
        </trans-unit>
        <trans-unit id="6a970efb45caa036763049ac1a92ee21b5440b3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;check(..)&lt;/code&gt; is not used then F2PY generates few standard checks (e.g. in a case of an array argument, check for the proper shape and size) automatically. Use &lt;code&gt;check()&lt;/code&gt; to disable checks generated by F2PY.</source>
          <target state="translated">如果未使用 &lt;code&gt;check(..)&lt;/code&gt; ,则F2PY会自动生成少量标准检查（例如，在使用数组参数的情况下，检查适当的形状和大小）。使用 &lt;code&gt;check()&lt;/code&gt; 禁用F2PY生成的检查。</target>
        </trans-unit>
        <trans-unit id="ce30f3388eee45516fb0d109b2a57581be93d2fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cmp_op&lt;/code&gt; is not valid.</source>
          <target state="translated">如果 &lt;code&gt;cmp_op&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="f3791f18c578dee37c08b1f05312986ce4a1234a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;condition&lt;/code&gt; is boolean:</source>
          <target state="translated">如果 &lt;code&gt;condition&lt;/code&gt; 为布尔值：</target>
        </trans-unit>
        <trans-unit id="945ce76f24a4c673d6aa37d9ae7569a5f68abd37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is provided, it must stay alive for the life of the array. One way to manage this is through &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">如果提供了 &lt;code&gt;data&lt;/code&gt; ，则该数据必须在阵列的生命周期内保持有效。一种管理方法是通过&lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58463c629975ec8a9511dbc013fc3e05064ff197" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;device&lt;/code&gt; does not have a &lt;code&gt;write()&lt;/code&gt; or &lt;code&gt;flush()&lt;/code&gt; method.</source>
          <target state="translated">如果 &lt;code&gt;device&lt;/code&gt; 没有 &lt;code&gt;write()&lt;/code&gt; 或 &lt;code&gt;flush()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="799e69512e3ae47752ad1a4389491bce54790cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation</source>
          <target state="translated">如果 &lt;code&gt;dtype&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，&lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt; &lt;code&gt;numpy.format_parser&lt;/code&gt; &lt;/a&gt;这些参数传递给numpy.format_parser来构造dtype。请参阅该功能以获取详细文档</target>
        </trans-unit>
        <trans-unit id="eb15e22b2a7d43231c255a7fc2569fdb2ab36892" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation.</source>
          <target state="translated">如果 &lt;code&gt;dtype&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，&lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt; &lt;code&gt;numpy.format_parser&lt;/code&gt; &lt;/a&gt;这些参数传递给numpy.format_parser来构造dtype。有关详细文档，请参见该功能。</target>
        </trans-unit>
        <trans-unit id="68051abdc74ce34a8cd57f65aadeda23f8c9fb89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, then it requires that data type. If copying is allowed, it will make a temporary copy if the data is castable. If &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; is enabled, it will also copy the data back with another cast upon iterator destruction.</source>
          <target state="translated">如果 &lt;code&gt;dtype&lt;/code&gt; 不为 &lt;code&gt;NULL&lt;/code&gt; ，则它需要该数据类型。如果允许复制，则在数据可转换时将进行临时复制。如果启用了&lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;，它还将在销毁迭代器时将数据复制回另一个强制类型。</target>
        </trans-unit>
        <trans-unit id="760548f2e1b1246d013e160a44370e64f44dc286" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enddates&lt;/code&gt; specifies a date value that is earlier than the corresponding &lt;code&gt;begindates&lt;/code&gt; date value, the count will be negative.</source>
          <target state="translated">如果 &lt;code&gt;enddates&lt;/code&gt; 指定的日期值早于相应的 &lt;code&gt;begindates&lt;/code&gt; 日期值，则该计数为负数。</target>
        </trans-unit>
        <trans-unit id="417859000cee8d29cc7044346e37933b08a0f1c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fieldname&lt;/code&gt; is the empty string &lt;code&gt;''&lt;/code&gt;, the field will be given a default name of the form &lt;code&gt;f#&lt;/code&gt;, where &lt;code&gt;#&lt;/code&gt; is the integer index of the field, counting from 0 from the left:</source>
          <target state="translated">如果 &lt;code&gt;fieldname&lt;/code&gt; 是空字符串 &lt;code&gt;''&lt;/code&gt; ，则将为该字段提供默认名称，形式为 &lt;code&gt;f#&lt;/code&gt; ，其中 &lt;code&gt;#&lt;/code&gt; 是该字段的整数索引，从左侧的0开始计数：</target>
        </trans-unit>
        <trans-unit id="ea2d55579b57bf31daf1f1c848f07e4ba4a33873" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fortranname&lt;/code&gt; statement is used without &lt;code&gt;&amp;lt;actual Fortran/C routine name&amp;gt;&lt;/code&gt; then a dummy wrapper is generated.</source>
          <target state="translated">如果在没有 &lt;code&gt;&amp;lt;actual Fortran/C routine name&amp;gt;&lt;/code&gt; 情况下使用了 &lt;code&gt;fortranname&lt;/code&gt; 语句，则会生成一个虚拟包装器。</target>
        </trans-unit>
        <trans-unit id="cb4a6b4dd2e4a7b67147341a42f6c8197722c973" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is a 1-D array of sorted integers, the entries indicate where along &lt;code&gt;axis&lt;/code&gt; the array is split. For example, &lt;code&gt;[2, 3]&lt;/code&gt; would, for &lt;code&gt;axis=0&lt;/code&gt;, result in</source>
          <target state="translated">如果 &lt;code&gt;indices_or_sections&lt;/code&gt; 是一维排序的整数数组，则条目指示沿 &lt;code&gt;axis&lt;/code&gt; 在哪里拆分该数组。例如，对于 &lt;code&gt;axis=0&lt;/code&gt; ， &lt;code&gt;[2, 3]&lt;/code&gt; 将导致</target>
        </trans-unit>
        <trans-unit id="750e535a910db315f0680626cd7e38f07dd476ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is an integer, N, the array will be divided into N equal arrays along &lt;code&gt;axis&lt;/code&gt;. If such a split is not possible, an error is raised.</source>
          <target state="translated">如果 &lt;code&gt;indices_or_sections&lt;/code&gt; 是整数N，则该数组将沿 &lt;code&gt;axis&lt;/code&gt; 分为N个相等的数组。如果无法进行此类拆分，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="c2fbdd32f871ea7c6656b8280d919dff6251170e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is given as an integer, but a split does not result in equal division.</source>
          <target state="translated">如果 &lt;code&gt;indices_or_sections&lt;/code&gt; 是整数，但是分割不会导致相等的除法。</target>
        </trans-unit>
        <trans-unit id="64c4e0e507acd8c3f4b71cfa7cf2cf1d38b76639" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;intent(c)&lt;/code&gt; is used as a statement but without an entity declaration list, then F2PY adds the &lt;code&gt;intent(c)&lt;/code&gt; attribute to all arguments.</source>
          <target state="translated">如果将 &lt;code&gt;intent(c)&lt;/code&gt; 用作语句但没有实体声明列表，则F2PY将 &lt;code&gt;intent(c)&lt;/code&gt; 属性添加到所有参数。</target>
        </trans-unit>
        <trans-unit id="820239142587f3701cc156b154b6624dd5007ecf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;intent(copy)&lt;/code&gt; or &lt;code&gt;intent(overwrite)&lt;/code&gt; is used, then an additional optional argument is introduced with a name &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; and a default value 0 or 1, respectively.</source>
          <target state="translated">如果使用了 &lt;code&gt;intent(copy)&lt;/code&gt; 或 &lt;code&gt;intent(overwrite)&lt;/code&gt; ，则将引入一个附加的可选参数，其名称分别为 &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; 和默认值0或1。</target>
        </trans-unit>
        <trans-unit id="c296e3258dbc49519e8602388ede880a24772142" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k &amp;gt; l&lt;/code&gt;, then only &lt;code&gt;x_1, ..., x_l&lt;/code&gt; are set.</source>
          <target state="translated">如果 &lt;code&gt;k &amp;gt; l&lt;/code&gt; ，则仅设置 &lt;code&gt;x_1, ..., x_l&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="271207c6144fe7ced9054709b41446a9de60c700" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k &amp;lt; l&lt;/code&gt;, then &lt;code&gt;y_{k + 1}, ..., y_l&lt;/code&gt; are ignored.</source>
          <target state="translated">如果 &lt;code&gt;k &amp;lt; l&lt;/code&gt; ，则 &lt;code&gt;y_{k + 1}, ..., y_l&lt;/code&gt; 被忽略。</target>
        </trans-unit>
        <trans-unit id="e99e0454406f9add7ef291687419a1330612a513" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;legacy&lt;/code&gt; is False, or the BitGenerator is not MT19937, then state is returned as a dictionary.</source>
          <target state="translated">如果 &lt;code&gt;legacy&lt;/code&gt; 是False，或者BitGenerator不是MT19937，则状态将作为字典返回。</target>
        </trans-unit>
        <trans-unit id="ce1a7ad82e3cfecd360d23c388ed9b15e3542af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;legacy&lt;/code&gt; is False, or the BitGenerator is not NT19937, then state is returned as a dictionary.</source>
          <target state="translated">如果 &lt;code&gt;legacy&lt;/code&gt; 为False，或者BitGenerator不是NT19937，则状态作为字典返回。</target>
        </trans-unit>
        <trans-unit id="146abcde4c240659f226130b295dbaf50c55deac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 0&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;m &amp;lt; 0&lt;/code&gt; ， &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; ， &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; 或 &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c2df004cd887df3e646568cfffdf17b3ac0ffbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 1&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;m &amp;lt; 1&lt;/code&gt; ， &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; ， &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; 或 &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e220ffcadc52e486b28727579ddc1e86ad96fbcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; have different flexible dtypes.</source>
          <target state="translated">如果 &lt;code&gt;m1&lt;/code&gt; 和 &lt;code&gt;m2&lt;/code&gt; 具有不同的灵活dtype。</target>
        </trans-unit>
        <trans-unit id="0cda2eb48aaf0ad93b34e30066de3169d0688cac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m&lt;/code&gt; has a single column then that column is returned as the single row of a matrix. Otherwise &lt;code&gt;m&lt;/code&gt; is returned. The returned matrix is always either &lt;code&gt;m&lt;/code&gt; itself or a view into &lt;code&gt;m&lt;/code&gt;. Supplying an axis keyword argument will not affect the returned matrix but it may cause an error to be raised.</source>
          <target state="translated">如果 &lt;code&gt;m&lt;/code&gt; 具有单个列，则该列将作为矩阵的单个行返回。否则，返回 &lt;code&gt;m&lt;/code&gt; 。返回的矩阵始终为 &lt;code&gt;m&lt;/code&gt; 本身或看到 &lt;code&gt;m&lt;/code&gt; 。提供axis关键字参数不会影响返回的矩阵，但可能会引起错误。</target>
        </trans-unit>
        <trans-unit id="d089e6b20e99bc8aa35211116381511548d1fc6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done, the rightmost ones.</source>
          <target state="translated">如果给出了 &lt;code&gt;maxsplit&lt;/code&gt; ,则最多完成 &lt;code&gt;maxsplit&lt;/code&gt; 拆分，最右边的拆分完成。</target>
        </trans-unit>
        <trans-unit id="f3a2beabba4d5e799494083ff0f67c424eaf8432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done.</source>
          <target state="translated">如果给出 &lt;code&gt;maxsplit&lt;/code&gt; ,则最多完成 &lt;code&gt;maxsplit&lt;/code&gt; 分割。</target>
        </trans-unit>
        <trans-unit id="6e310688fa6d65057ce51d85bd5439d15eeafd62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n + p &amp;lt;= m&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_n, e_1, ..., e_p)&lt;/code&gt; is called.</source>
          <target state="translated">如果 &lt;code&gt;n + p &amp;lt;= m&lt;/code&gt; 然后 &lt;code&gt;gun(a_1, ..., a_n, e_1, ..., e_p)&lt;/code&gt; 被调用。</target>
        </trans-unit>
        <trans-unit id="75d4baac79ac0ec79605a8d87c557699bd33432f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n + p&lt;/code&gt; is less than the number of required arguments to &lt;code&gt;gun&lt;/code&gt; then an exception is raised.</source>
          <target state="translated">如果 &lt;code&gt;n + p&lt;/code&gt; 小于 &lt;code&gt;gun&lt;/code&gt; 所需的参数个数，则会引发异常。</target>
        </trans-unit>
        <trans-unit id="a6773ebb7a73c0cf9641c3fc6c53898d5654dcdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is even, &lt;code&gt;A[-1]&lt;/code&gt; contains the term representing both positive and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely real. If &lt;code&gt;n&lt;/code&gt; is odd, there is no term at fs/2; &lt;code&gt;A[-1]&lt;/code&gt; contains the largest positive frequency (fs/2*(n-1)/n), and is complex in the general case.</source>
          <target state="translated">如果 &lt;code&gt;n&lt;/code&gt; 为偶数，则 &lt;code&gt;A[-1]&lt;/code&gt; 包含代表正和负奈奎斯特频率（+ fs / 2和-fs / 2）的项，并且也必须是纯实数。如果 &lt;code&gt;n&lt;/code&gt; 为奇数，则fs / 2处无项； &lt;code&gt;A[-1]&lt;/code&gt; 包含最大正频率（fs / 2 *（n-1）/ n），在一般情况下很复杂。</target>
        </trans-unit>
        <trans-unit id="d002795222f44b6308a6ac63aedd1a3723557506" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;names&lt;/code&gt; is True, the field names are read from the first line after the first &lt;code&gt;skip_header&lt;/code&gt; lines. This line can optionally be proceeded by a comment delimiter. If &lt;code&gt;names&lt;/code&gt; is a sequence or a single-string of comma-separated names, the names will be used to define the field names in a structured dtype. If &lt;code&gt;names&lt;/code&gt; is None, the names of the dtype fields will be used, if any.</source>
          <target state="translated">如果 &lt;code&gt;names&lt;/code&gt; 为True，则从第一行 &lt;code&gt;skip_header&lt;/code&gt; 行之后的第一行读取字段名称。此行可以选择用注释定界符继续。如果 &lt;code&gt;names&lt;/code&gt; 是序列或逗号分隔名称的单字符串，则这些名称将用于以结构化dtype定义字段名称。如果 &lt;code&gt;names&lt;/code&gt; 为None，则将使用dtype字段的名称（如果有）。</target>
        </trans-unit>
        <trans-unit id="07b76e3a08f68e2d41d08bcc90944dfb38bf1854" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;names=None&lt;/code&gt; but a structured dtype is expected, names are defined with the standard NumPy default of &lt;code&gt;&quot;f%i&quot;&lt;/code&gt;, yielding names like &lt;code&gt;f0&lt;/code&gt;, &lt;code&gt;f1&lt;/code&gt; and so forth:</source>
          <target state="translated">如果 &lt;code&gt;names=None&lt;/code&gt; 但需要结构化的dtype，则使用标准的NumPy默认值 &lt;code&gt;&quot;f%i&quot;&lt;/code&gt; 定义名称，并产生诸如 &lt;code&gt;f0&lt;/code&gt; ， &lt;code&gt;f1&lt;/code&gt; 之类的名称，依此类推：</target>
        </trans-unit>
        <trans-unit id="9d8d4bbddf580197e193ef2ab5f3260ca263687d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. In contrast to &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt; it makes no attempt to copy the data from &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; This undoes &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called after an error when you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input.</source>
          <target state="translated">如果 &lt;code&gt;obj.flags&lt;/code&gt; 具有&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;或（不建议使用）&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;，则此函数将清除标志 &lt;code&gt;DECREF&lt;/code&gt; 的 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 并使其可写，并将 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 设置为NULL。与&lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt;相比，它不尝试从 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 复制数据。这撤消了&lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; &lt;/a&gt;。通常，在完成 &lt;code&gt;obj&lt;/code&gt; 后在错误之后， &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; 之前调用此方法。可以多次调用它，或者使用 &lt;code&gt;NULL&lt;/code&gt; 输入。</target>
        </trans-unit>
        <trans-unit id="8f43e6f1e973bd0d462747acc6303f4251ae23b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. It then copies &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; to &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt;, and returns the error state of the copy operation. This is the opposite of &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called once you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input. See also &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;obj.flags&lt;/code&gt; 具有&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;或（不建议使用）&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;，则此函数将清除标志 &lt;code&gt;DECREF&lt;/code&gt; 的 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 并使其可写，并将 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 设置为NULL。然后，它将 &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; 复制到 &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt; ，并返回复制操作的错误状态。这与&lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; &lt;/a&gt;相反。通常，在完成 &lt;code&gt;obj&lt;/code&gt; 之后，即在 &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; 之前调用此方法。它可以被多次调用，或 &lt;code&gt;NULL&lt;/code&gt; 输入。另见&lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90c51090e68a386a4d8166c7cdb0f79785d7f6e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;../glossary#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt; ，则 &lt;code&gt;x[obj]&lt;/code&gt; 返回一维数组，其中填充了与&lt;em&gt;obj&lt;/em&gt;的&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt;值相对应的&lt;em&gt;x&lt;/em&gt;元素。搜索顺序将是C风格的&lt;a href=&quot;../glossary#term-row-major&quot;&gt;行&lt;/a&gt;优先。如果&lt;em&gt;obj&lt;/em&gt;在&lt;em&gt;x&lt;/em&gt;的边界之外的条目上具有&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt;值，则将引发索引错误。如果&lt;em&gt;obj&lt;/em&gt;小于&lt;em&gt;x&lt;/em&gt;，则等同于用&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt;填充它。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="19e346c07517b41525b586a4ff8685ed9ba6dbe8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;code&gt;True&lt;/code&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;../glossary#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;code&gt;True&lt;/code&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt; ，则 &lt;code&gt;x[obj]&lt;/code&gt; 返回一维数组，其中填充了与&lt;em&gt;obj&lt;/em&gt;的 &lt;code&gt;True&lt;/code&gt; 值相对应的&lt;em&gt;x&lt;/em&gt;元素。搜索顺序将是C风格的&lt;a href=&quot;../glossary#term-row-major&quot;&gt;行&lt;/a&gt;优先。如果&lt;em&gt;obj&lt;/em&gt;在&lt;em&gt;x&lt;/em&gt;的边界之外的条目上具有 &lt;code&gt;True&lt;/code&gt; 值，则将引发索引错误。如果&lt;em&gt;obj&lt;/em&gt;小于&lt;em&gt;x&lt;/em&gt;，则等同于用 &lt;code&gt;False&lt;/code&gt; 填充它。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b9effe7f71bd1a595880c87c20422da0870723e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;code&gt;True&lt;/code&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;code&gt;True&lt;/code&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt; ，则 &lt;code&gt;x[obj]&lt;/code&gt; 返回一维数组，其中填充了与&lt;em&gt;obj&lt;/em&gt;的 &lt;code&gt;True&lt;/code&gt; 值相对应的&lt;em&gt;x&lt;/em&gt;元素。搜索顺序将是C风格的&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;行&lt;/a&gt;优先。如果&lt;em&gt;obj&lt;/em&gt;在&lt;em&gt;x&lt;/em&gt;的边界之外的条目上具有 &lt;code&gt;True&lt;/code&gt; 值，则将引发索引错误。如果&lt;em&gt;obj&lt;/em&gt;小于&lt;em&gt;x&lt;/em&gt;，则等同于用 &lt;code&gt;False&lt;/code&gt; 填充它。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c24698bfa7f55b1863fd1ee853e61b9963b6226" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then call the &lt;a href=&quot;numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;recarray&lt;/code&gt;&lt;/a&gt; constructor. If &lt;code&gt;obj&lt;/code&gt; is a string, then call the &lt;a href=&quot;numpy.fromstring#numpy.fromstring&quot;&gt;&lt;code&gt;fromstring&lt;/code&gt;&lt;/a&gt; constructor. If &lt;code&gt;obj&lt;/code&gt; is a list or a tuple, then if the first object is an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, call &lt;a href=&quot;numpy.core.records.fromarrays#numpy.core.records.fromarrays&quot;&gt;&lt;code&gt;fromarrays&lt;/code&gt;&lt;/a&gt;, otherwise call &lt;a href=&quot;numpy.core.records.fromrecords#numpy.core.records.fromrecords&quot;&gt;&lt;code&gt;fromrecords&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;obj&lt;/code&gt; is a &lt;a href=&quot;numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;recarray&lt;/code&gt;&lt;/a&gt;, then make a copy of the data in the recarray (if &lt;code&gt;copy=True&lt;/code&gt;) and use the new formats, names, and titles. If &lt;code&gt;obj&lt;/code&gt; is a file, then call &lt;a href=&quot;numpy.fromfile#numpy.fromfile&quot;&gt;&lt;code&gt;fromfile&lt;/code&gt;&lt;/a&gt;. Finally, if obj is an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, then return &lt;code&gt;obj.view(recarray)&lt;/code&gt;, making a copy of the data if &lt;code&gt;copy=True&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;obj&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，则调用&lt;a href=&quot;numpy.recarray#numpy.recarray&quot;&gt; &lt;code&gt;recarray&lt;/code&gt; &lt;/a&gt;构造函数。如果 &lt;code&gt;obj&lt;/code&gt; 是字符串，则调用&lt;a href=&quot;numpy.fromstring#numpy.fromstring&quot;&gt; &lt;code&gt;fromstring&lt;/code&gt; &lt;/a&gt;构造函数。如果 &lt;code&gt;obj&lt;/code&gt; 是列表或元组，则如果第一个对象是&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，则调用&lt;a href=&quot;numpy.core.records.fromarrays#numpy.core.records.fromarrays&quot;&gt; &lt;code&gt;fromarrays&lt;/code&gt; &lt;/a&gt;，否则调用&lt;a href=&quot;numpy.core.records.fromrecords#numpy.core.records.fromrecords&quot;&gt; &lt;code&gt;fromrecords&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;obj&lt;/code&gt; 是一个&lt;a href=&quot;numpy.recarray#numpy.recarray&quot;&gt; &lt;code&gt;recarray&lt;/code&gt; &lt;/a&gt;，则在recarray中复制数据（如果 &lt;code&gt;copy=True&lt;/code&gt; ），并使用新的格式，名称和标题。如果 &lt;code&gt;obj&lt;/code&gt; 是文件，则调用&lt;a href=&quot;numpy.fromfile#numpy.fromfile&quot;&gt; &lt;code&gt;fromfile&lt;/code&gt; &lt;/a&gt;。最后，如果obj是&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，则返回 &lt;code&gt;obj.view(recarray)&lt;/code&gt; ，如果 &lt;code&gt;copy=True&lt;/code&gt; ,则复制数据。</target>
        </trans-unit>
        <trans-unit id="0cb8b5f8682e528917b9dad63d5ce0f0a15864d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; isn&amp;rsquo;t a suitable numeric type.</source>
          <target state="translated">如果 &lt;code&gt;obj&lt;/code&gt; 不是合适的数字类型。</target>
        </trans-unit>
        <trans-unit id="bd67812cd1998c40abb29425bc518b926e6b0841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to &lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt;&lt;code&gt;Py_NotImplemented&lt;/code&gt;&lt;/a&gt; and no error condition is set.</source>
          <target state="translated">如果 &lt;code&gt;op&lt;/code&gt; 实现了数组接口的任何部分，则 &lt;code&gt;out&lt;/code&gt; 将包含使用该接口对新创建的ndarray的新引用，或者 &lt;code&gt;out&lt;/code&gt; 将包含 &lt;code&gt;NULL&lt;/code&gt; (如果在转换期间发生错误）。否则，out将包含对&lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt; &lt;code&gt;Py_NotImplemented&lt;/code&gt; &lt;/a&gt;的借用引用，并且未设置任何错误条件。</target>
        </trans-unit>
        <trans-unit id="12f75ca0900af5198142d436cbdd5e1ee389cfd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to Py_NotImplemented and no error condition is set. This version allows setting of the dtype in the part of the array interface that looks for the &lt;a href=&quot;../arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; attribute. &lt;code&gt;context&lt;/code&gt; is unused.</source>
          <target state="translated">如果 &lt;code&gt;op&lt;/code&gt; 实现了数组接口的任何部分，则 &lt;code&gt;out&lt;/code&gt; 将包含使用该接口对新创建的ndarray的新引用，或者 &lt;code&gt;out&lt;/code&gt; 将包含 &lt;code&gt;NULL&lt;/code&gt; (如果在转换期间发生错误）。否则，out将包含对Py_NotImplemented的借用引用，并且未设置任何错误条件。此版本允许在查找&lt;a href=&quot;../arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;属性的数组接口部分中设置dtype。 &lt;code&gt;context&lt;/code&gt; 未使用。</target>
        </trans-unit>
        <trans-unit id="98dbfb53c5754a6749d968f5df5fe9eebecd4ff8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to Py_NotImplemented and no error condition is set. This version allows setting of the type and context in the part of the array interface that looks for the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">如果 &lt;code&gt;op&lt;/code&gt; 实现了数组接口的任何部分，则 &lt;code&gt;out&lt;/code&gt; 将包含使用该接口对新创建的ndarray的新引用，或者 &lt;code&gt;out&lt;/code&gt; 将包含 &lt;code&gt;NULL&lt;/code&gt; (如果在转换期间发生错误）。否则，out将包含对Py_NotImplemented的借用引用，并且未设置任何错误条件。此版本允许在数组接口中寻找&lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;属性的部分中设置类型和上下文。</target>
        </trans-unit>
        <trans-unit id="ed83570f54caf00535275cbf2433364d3dc43b7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; is already (C-style) contiguous and well-behaved then just return a reference, otherwise return a (contiguous and well-behaved) copy of the array. The parameter op must be a (sub-class of an) ndarray and no checking for that is done.</source>
          <target state="translated">如果 &lt;code&gt;op&lt;/code&gt; 已经（C风格）连续且行为良好，则仅返回引用，否则返回数组的（连续且行为良好）副本。参数op必须是ndarray（的子类），并且不对此进行检查。</target>
        </trans-unit>
        <trans-unit id="3efc82f6eb8962f2bbdd61dd48e5d36f40ab01fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_dtypes&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, it specifies a data type or &lt;code&gt;NULL&lt;/code&gt; for each &lt;code&gt;op[i]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;op_dtypes&lt;/code&gt; 不为 &lt;code&gt;NULL&lt;/code&gt; ，则为每个 &lt;code&gt;op[i]&lt;/code&gt; 指定一种数据类型或 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49913a9d3761c3c5184d0fb1b55beebafb026c1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;otypes&lt;/code&gt; is not specified, then a call to the function with the first argument will be used to determine the number of outputs. The results of this call will be cached if &lt;code&gt;cache&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; to prevent calling the function twice. However, to implement the cache, the original function must be wrapped which will slow down subsequent calls, so only do this if your function is expensive.</source>
          <target state="translated">如果未指定 &lt;code&gt;otypes&lt;/code&gt; ，则将使用对带有第一个参数的函数的调用来确定输出数量。如果 &lt;code&gt;cache&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则将缓存此调用的结果，以防止两次调用该函数。但是，要实现缓存，必须包装原始函数，这会减慢后续调用的速度，因此仅在函数昂贵时才这样做。</target>
        </trans-unit>
        <trans-unit id="3aa37ff615f56f9b7e65eaa58699e643fd032326" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, a shuffled copy of &lt;code&gt;x&lt;/code&gt; is returned. Otherwise, the shuffled array is stored in &lt;code&gt;out&lt;/code&gt;, and &lt;code&gt;out&lt;/code&gt; is returned</source>
          <target state="translated">如果 &lt;code&gt;out&lt;/code&gt; 为None，则返回 &lt;code&gt;x&lt;/code&gt; 的随机组合副本。否则，将改组后的数组存储在 &lt;code&gt;out&lt;/code&gt; 中，并返回 &lt;code&gt;out&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6567b2686e797d9822a7bbf895363486cc94afc9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array.</source>
          <target state="translated">如果 &lt;code&gt;out&lt;/code&gt; 为None，则返回包含标准偏差的新数组，否则返回对输出数组的引用。</target>
        </trans-unit>
        <trans-unit id="089152cfcf81b924028fc82e4f2ab4321cd32c01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">如果 &lt;code&gt;out&lt;/code&gt; 为None，则返回包含标准偏差的新数组，否则返回对输出数组的引用。如果ddof&amp;gt; ==切片中非NaN元素的数量，或者该切片仅包含NaN，则该切片的结果为NaN。</target>
        </trans-unit>
        <trans-unit id="a3cf56d56f9711ddb9fe165ac4a15d1c897a7d62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the variance, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">如果 &lt;code&gt;out&lt;/code&gt; 为None，则返回包含差异的新数组，否则返回对输出数组的引用。如果ddof&amp;gt; ==切片中非NaN元素的数量，或者该切片仅包含NaN，则该切片的结果为NaN。</target>
        </trans-unit>
        <trans-unit id="bd3ed46fb1ad18e3f54a87922d109c78bc224796" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is provided, the function writes the result into it, and returns a reference to &lt;code&gt;out&lt;/code&gt;. (See Examples)</source>
          <target state="translated">如果提供 &lt;code&gt;out&lt;/code&gt; ，则函数将结果写入其中，并返回对 &lt;code&gt;out&lt;/code&gt; 的引用。（请参见示例）</target>
        </trans-unit>
        <trans-unit id="d0b860961bc5b4a4c45189c0fd4de5c2d61f1ab4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned.</source>
          <target state="translated">如果 &lt;code&gt;out=None&lt;/code&gt; ，则返回一个包含平均值的新数组，否则返回对输出数组的引用。</target>
        </trans-unit>
        <trans-unit id="d2bfee9ac0986058c6155b92fa93c7a62c8953a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned. Nan is returned for slices that contain only NaNs.</source>
          <target state="translated">如果 &lt;code&gt;out=None&lt;/code&gt; ，则返回一个包含平均值的新数组，否则返回对输出数组的引用。对于仅包含NaN的切片，将返回Nan。</target>
        </trans-unit>
        <trans-unit id="64277711f0130f08ef89a03256433633c6256165" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the variance; otherwise, a reference to the output array is returned.</source>
          <target state="translated">如果 &lt;code&gt;out=None&lt;/code&gt; ，则返回包含方差的新数组；否则，返回新数组。否则，返回对输出数组的引用。</target>
        </trans-unit>
        <trans-unit id="9b1c9c61ff9f1ab4238c3c9129f3c3d7264b97ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;output&lt;/code&gt; not supplied then source code is printed to screen (sys.stdout). File object must be created with either write &amp;lsquo;w&amp;rsquo; or append &amp;lsquo;a&amp;rsquo; modes.</source>
          <target state="translated">如果未提供 &lt;code&gt;output&lt;/code&gt; 则将源代码打印到屏幕（sys.stdout）。必须使用写'w'或附加'a'模式创建文件对象。</target>
        </trans-unit>
        <trans-unit id="710d73ebab70d58eff0ea577b59d52767457dc24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p &amp;gt; m&lt;/code&gt; then &lt;code&gt;gun(e_1, ..., e_m)&lt;/code&gt; is called.</source>
          <target state="translated">如果 &lt;code&gt;p &amp;gt; m&lt;/code&gt; ，然后 &lt;code&gt;gun(e_1, ..., e_m)&lt;/code&gt; 被调用。</target>
        </trans-unit>
        <trans-unit id="7ffd83286f9552326735c9e9997d8b928bd7d08a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p &amp;lt;= m &amp;lt; n + p&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_q, e_1, ..., e_p)&lt;/code&gt; is called, here &lt;code&gt;q=m-p&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;p &amp;lt;= m &amp;lt; n + p&lt;/code&gt; 则 &lt;code&gt;gun(a_1, ..., a_q, e_1, ..., e_p)&lt;/code&gt; ，这里 &lt;code&gt;q=m-p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16e928ca77781f5fb31deca2051e51b1031bced3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p == 0&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_q)&lt;/code&gt; is called, here &lt;code&gt;q = min(m, n)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;p == 0&lt;/code&gt; 则 &lt;code&gt;gun(a_1, ..., a_q)&lt;/code&gt; 被调用时，这里 &lt;code&gt;q = min(m, n)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04c444cb5aa197d63b68cfea78d90d29188a9456" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is of length N, this function returns the value:</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 的长度为N，则此函数返回值：</target>
        </trans-unit>
        <trans-unit id="fe3f05df5768add8f656a94f10e13fc6943b0c1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is the returned series, then &lt;code&gt;p(x) == x&lt;/code&gt; for all values of x.</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 是返回的序列，则对于 &lt;code&gt;p(x) == x&lt;/code&gt; 的所有值，p（x）== x。</target>
        </trans-unit>
        <trans-unit id="f5468a2ba10e85782ab3beca18220db469f1d944" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, it will be downloaded, stored in the &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; directory and opened from there.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 是URL，它将被下载，存储在&lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt;目录中并从那里打开。</target>
        </trans-unit>
        <trans-unit id="24260df7d2aad1e014a4c9af35e7ef7678f51548" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, then &lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt;&lt;code&gt;abspath&lt;/code&gt;&lt;/a&gt; will return either the location the file exists locally or the location it would exist when opened using the &lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 是URL，则&lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt; &lt;code&gt;abspath&lt;/code&gt; &lt;/a&gt;将返回文件在本地存在的位置或使用&lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;方法打开时将存在的位置。</target>
        </trans-unit>
        <trans-unit id="9e52fcae8c89336b9d76db6bc95e2d2ecd5abb9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple percentiles are given, first axis of the result corresponds to the percentiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">如果 &lt;code&gt;q&lt;/code&gt; 是单个百分位数，而 &lt;code&gt;axis=None&lt;/code&gt; ，则结果是标量。如果给出了多个百分位数，则结果的第一个轴对应于百分位数。其他轴是 &lt;code&gt;a&lt;/code&gt; 减小后剩余的轴。如果输入包含小于 &lt;code&gt;float64&lt;/code&gt; 的整数或浮点数，则输出数据类型为 &lt;code&gt;float64&lt;/code&gt; 。否则，输出数据类型与输入的数据类型相同。如果指定 &lt;code&gt;out&lt;/code&gt; ，则返回该数组。</target>
        </trans-unit>
        <trans-unit id="4219d6c9d1025bc747faeaba10649824d1b4aa46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">如果 &lt;code&gt;q&lt;/code&gt; 是单个百分位数，而 &lt;code&gt;axis=None&lt;/code&gt; ，则结果是标量。如果给出了多个分位数，则结果的第一轴对应于分位数。其他轴是 &lt;code&gt;a&lt;/code&gt; 减小后剩余的轴。如果输入包含小于 &lt;code&gt;float64&lt;/code&gt; 的整数或浮点数，则输出数据类型为 &lt;code&gt;float64&lt;/code&gt; 。否则，输出数据类型与输入的数据类型相同。如果指定 &lt;code&gt;out&lt;/code&gt; ，则返回该数组。</target>
        </trans-unit>
        <trans-unit id="adb7c2f1dd4ba6f271e782ab821bd6ce35c48378" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single quantile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">如果 &lt;code&gt;q&lt;/code&gt; 是单个分位数并且 &lt;code&gt;axis=None&lt;/code&gt; ，则结果是标量。如果给出了多个分位数，则结果的第一轴对应于分位数。其他轴是 &lt;code&gt;a&lt;/code&gt; 减小后剩余的轴。如果输入包含小于 &lt;code&gt;float64&lt;/code&gt; 的整数或浮点数，则输出数据类型为 &lt;code&gt;float64&lt;/code&gt; 。否则，输出数据类型与输入的数据类型相同。如果指定 &lt;code&gt;out&lt;/code&gt; ，则返回该数组。</target>
        </trans-unit>
        <trans-unit id="9da6831f27b77e8b6677e8aad5c341d985befa99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;r&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor is ``True`&lt;/code&gt; the shape will be r.shape[1:] + x.shape; that is, each polynomial is evaluated at every value of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the shape will be r.shape[1:]; that is, each polynomial is evaluated only for the corresponding broadcast value of &lt;code&gt;x&lt;/code&gt;. Note that scalars have shape (,).</source>
          <target state="translated">如果 &lt;code&gt;r&lt;/code&gt; 是一维数组，则 &lt;code&gt;p(x)&lt;/code&gt; 将具有与 &lt;code&gt;x&lt;/code&gt; 相同的形状。如果 &lt;code&gt;r&lt;/code&gt; 是多维的，则结果的形状取决于 &lt;code&gt;tensor&lt;/code&gt; 的值。如果 &lt;code&gt;tensor is ``True`&lt;/code&gt; 则形状将为r.shape [1：] + x.shape; 也就是说，每个多项式都是在 &lt;code&gt;x&lt;/code&gt; 的每个值处求值的。如果 &lt;code&gt;tensor&lt;/code&gt; 为 &lt;code&gt;False&lt;/code&gt; ，则形状将为r.shape [1：];。也就是说，仅针对 &lt;code&gt;x&lt;/code&gt; 的相应广播值评估每个多项式。请注意，标量具有形状（，）。</target>
        </trans-unit>
        <trans-unit id="16d6bbf3ace149a532102c10ab8ede2738b896bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is of length &lt;code&gt;N&lt;/code&gt;, this function returns the value</source>
          <target state="translated">如果 &lt;code&gt;r&lt;/code&gt; 的长度为 &lt;code&gt;N&lt;/code&gt; ，则此函数返回值</target>
        </trans-unit>
        <trans-unit id="6bc06c8f2ea0c3500f46f216948ca646bd403c39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep&lt;/code&gt; is an instance of a scalar dtype, True is returned. If not, False is returned.</source>
          <target state="translated">如果 &lt;code&gt;rep&lt;/code&gt; 是标量dtype的实例，则返回True。如果不是，则返回False。</target>
        </trans-unit>
        <trans-unit id="caf6ef0eb6bbcb3c4e7a4a5b04998bc1341e6eb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reps&lt;/code&gt; has length &lt;code&gt;d&lt;/code&gt;, the result will have dimension of &lt;code&gt;max(d, A.ndim)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;reps&lt;/code&gt; 的长度为 &lt;code&gt;d&lt;/code&gt; ，则结果的尺寸将为 &lt;code&gt;max(d, A.ndim)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15d930e73a09a54bb69273b247bbe9349e70a0c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rowvar&lt;/code&gt; is True (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations.</source>
          <target state="translated">如果 &lt;code&gt;rowvar&lt;/code&gt; 为True（默认值），则每一行代表一个变量，各列中带有观察值。否则，该关系将转置：每一列代表一个变量，而行包含观察值。</target>
        </trans-unit>
        <trans-unit id="0e485a675b3c010a2a7eedd59e29811b56d30eeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length, or &lt;code&gt;axes&lt;/code&gt; not given and &lt;code&gt;len(s) != 2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;axes&lt;/code&gt; 长度不同，或者未指定 &lt;code&gt;axes&lt;/code&gt; 且 &lt;code&gt;len(s) != 2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1a95f9d4c94712a6711035b0d38ca6007922134" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;axes&lt;/code&gt; 长度不同。</target>
        </trans-unit>
        <trans-unit id="7c3cc7c092c11cc91fc3de1425949e6b1c9585a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sctype&lt;/code&gt; is an object for which the type can not be inferred.</source>
          <target state="translated">如果 &lt;code&gt;sctype&lt;/code&gt; 是无法推断类型的对象。</target>
        </trans-unit>
        <trans-unit id="9a8f382549c758d89f2c430b015281fc763e47f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;seed&lt;/code&gt; is not a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;, a new &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; is instantiated. This function does not manage a default global instance.</source>
          <target state="translated">如果 &lt;code&gt;seed&lt;/code&gt; 不是&lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt;实例化一个新的BitGenerator。此功能不管理默认的全局实例。</target>
        </trans-unit>
        <trans-unit id="0aeaeba3f41f378516fdce780d9277e8a4ccfffb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.shape[k] == 1&lt;/code&gt; then for any legal index &lt;code&gt;index[k] == 0&lt;/code&gt;. This means that in the formula for the offset</source>
          <target state="translated">如果 &lt;code&gt;self.shape[k] == 1&lt;/code&gt; 那么对于任何合法索引 &lt;code&gt;index[k] == 0&lt;/code&gt; 。这意味着在公式中的偏移量</target>
        </trans-unit>
        <trans-unit id="5df5fe3df9ec97e65980a43dfd1884e4e357c660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is non-singular, &lt;code&gt;ret&lt;/code&gt; is such that &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size))&lt;/code&gt; all return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 是非 &lt;code&gt;np.matrix(np.eye(self[0,:].size))&lt;/code&gt; ，则 &lt;code&gt;ret&lt;/code&gt; 使得 &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == np.matrix（np.eye（self [0，：]。size））都返回 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e5eb20061bb0d5a1e031a6a1b5daa75d4a16cad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is non-singular, &lt;code&gt;ret&lt;/code&gt; is such that &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; all return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 是非奇异的，则 &lt;code&gt;ret&lt;/code&gt; 使得 &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; 都返回 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b27bb431dc045601d86e73a474de86c64d035384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is singular.</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 是奇异的。</target>
        </trans-unit>
        <trans-unit id="a097af1908df1ac936bba64c59e9507a0eb901d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified or &lt;code&gt;None&lt;/code&gt;, any whitespace string is a separator.</source>
          <target state="translated">如果未指定 &lt;code&gt;sep&lt;/code&gt; 或 &lt;code&gt;None&lt;/code&gt; ，则任何空格字符串都是分隔符。</target>
        </trans-unit>
        <trans-unit id="6b286f3e58c7b02612a4551d6a9dcb5406b09f75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified or None, any whitespace string is a separator.</source>
          <target state="translated">如果未指定 &lt;code&gt;sep&lt;/code&gt; 或无，则任何空格字符串都是分隔符。</target>
        </trans-unit>
        <trans-unit id="768a6e9085deaf336653d5c9857ddf9b254027d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; has length one i.e. &lt;code&gt;(N,)&lt;/code&gt;, or is a scalar &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;out&lt;/code&gt; becomes a single row matrix of shape &lt;code&gt;(1,N)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;shape&lt;/code&gt; 长度为一个，即 &lt;code&gt;(N,)&lt;/code&gt; 或为标量 &lt;code&gt;N&lt;/code&gt; ，则 &lt;code&gt;out&lt;/code&gt; 变为形状 &lt;code&gt;(1,N)&lt;/code&gt; 的单行矩阵。</target>
        </trans-unit>
        <trans-unit id="afe85dc9a909b4503b3e7da810ec90771fac4a7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sources&lt;/code&gt; does not contain a signature files, then F2PY is used to scan Fortran source files for routine signatures to construct the wrappers to Fortran codes.</source>
          <target state="translated">如果 &lt;code&gt;sources&lt;/code&gt; 不包含签名文件，则使用F2PY扫描Fortran源文件以获取常规签名，以将包装器构造为Fortran代码。</target>
        </trans-unit>
        <trans-unit id="5d3a0815985e487dc8833e6a9544cd8f4d19132e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tol&lt;/code&gt; &amp;lt; 0</source>
          <target state="translated">如果 &lt;code&gt;tol&lt;/code&gt; &amp;lt;0</target>
        </trans-unit>
        <trans-unit id="525464d43ab5c9d447229756137cbe7b0c9e5673" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;upstream&lt;/code&gt; isn&amp;rsquo;t there, it will be added after you access the NumPy repo with a command like &lt;code&gt;git fetch&lt;/code&gt; or &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;upstream&lt;/code&gt; 不存在，则将在您使用 &lt;code&gt;git fetch&lt;/code&gt; 或 &lt;code&gt;git pull&lt;/code&gt; 之类的命令访问NumPy存储库后将其添加。</target>
        </trans-unit>
        <trans-unit id="6cf15e83c2fdf72b1f29bfc75044966bd6bc1399" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is a 2-D array, return a copy of its &lt;code&gt;k&lt;/code&gt;-th diagonal. If &lt;code&gt;v&lt;/code&gt; is a 1-D array, return a 2-D array with &lt;code&gt;v&lt;/code&gt; on the &lt;code&gt;k&lt;/code&gt;-th diagonal.</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 是二维数组，则返回其第 &lt;code&gt;k&lt;/code&gt; 个对角线的副本。如果 &lt;code&gt;v&lt;/code&gt; 是一维数组，则返回一个二维数组，其中 &lt;code&gt;v&lt;/code&gt; 在第 &lt;code&gt;k&lt;/code&gt; 个对角线上。</target>
        </trans-unit>
        <trans-unit id="8349a8e04c4275fccf8d4c40bdfe6166a838f29e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is longer than &lt;code&gt;a&lt;/code&gt;, the arrays are swapped before computation.</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 大于 &lt;code&gt;a&lt;/code&gt; ，则在计算之前交换数组。</target>
        </trans-unit>
        <trans-unit id="bfdbe84100978bde6f35b9bd48d4f5ad4bf72c8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is not the same size as &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;mask&lt;/code&gt; then it will repeat. This gives behavior different from &lt;code&gt;a[mask] = values&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;values&lt;/code&gt; 的大小与 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;mask&lt;/code&gt; 的大小不同，则它将重复。这给出的行为不同于 &lt;code&gt;a[mask] = values&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54792a3abbf75ac3395cbad014c19ac2ff1595e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is smaller than &lt;code&gt;a&lt;/code&gt; it is repeated:</source>
          <target state="translated">如果 &lt;code&gt;values&lt;/code&gt; 小于 &lt;code&gt;a&lt;/code&gt; ，则重复：</target>
        </trans-unit>
        <trans-unit id="d3b50be1f74d03f550d5fd9dbbf8a888d565797b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x2&lt;/code&gt; is a scalar, its sign will be copied to all elements of &lt;code&gt;x1&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x2&lt;/code&gt; 是标量，则其符号将被复制到 &lt;code&gt;x1&lt;/code&gt; 的所有元素。</target>
        </trans-unit>
        <trans-unit id="2e770d7b527b709ad5e13ef5b77aecccd75244de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; contains negative inputs, the answer is computed and returned in the complex domain.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 包含负输入，则将计算答案并在复数域中返回。</target>
        </trans-unit>
        <trans-unit id="60fec046bd42368c53fb89df3120786c8d0bd4a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; contains negative values, the output is converted to the complex domain.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 包含负值，则输出将转换为复数域。</target>
        </trans-unit>
        <trans-unit id="b5f780e2f5cb497ee27a4b50260d939ccb5e1976" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是列表或元组，则将其转换为ndarray，否则将保持不变并被视为标量。在任何一种情况下， &lt;code&gt;x&lt;/code&gt; 或其元素必须支持与自身以及 &lt;code&gt;c&lt;/code&gt; 元素的加法和乘法。</target>
        </trans-unit>
        <trans-unit id="e9289f94a42ce2a055130aa0322c6aa21e4c7a12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是列表或元组，则将其转换为ndarray，否则将保持不变并被视为标量。在任何一种情况下， &lt;code&gt;x&lt;/code&gt; 或其元素必须支持与自身以及 &lt;code&gt;r&lt;/code&gt; 元素的加法和乘法。</target>
        </trans-unit>
        <trans-unit id="0f3c93ccc6b110d8957f1eff605f32da46911a50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a multi-dimensional array, it is only shuffled along its first index.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是多维数组，则仅沿其第一个索引随机排列。</target>
        </trans-unit>
        <trans-unit id="10902731cd32fb924a9fa6246d242dab230b11a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a poly1d instance, the result is the composition of the two polynomials, i.e., &lt;code&gt;x&lt;/code&gt; is &amp;ldquo;substituted&amp;rdquo; in &lt;code&gt;p&lt;/code&gt; and the simplified result is returned. In addition, the type of &lt;code&gt;x&lt;/code&gt; - array_like or poly1d - governs the type of the output: &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like, &lt;code&gt;x&lt;/code&gt; a poly1d object =&amp;gt; &lt;code&gt;values&lt;/code&gt; is also.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是一个poly1d实例，则结果是两个多项式的组合，即 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;p&lt;/code&gt; 中被&amp;ldquo;取代&amp;rdquo;，并返回简化的结果。另外， &lt;code&gt;x&lt;/code&gt; 的类型-array_like或poly1d-决定输出的类型： &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like， &lt;code&gt;x&lt;/code&gt; a poly1d object =&amp;gt; &lt;code&gt;values&lt;/code&gt; 也是如此。</target>
        </trans-unit>
        <trans-unit id="d6a5280b73875b8ad0b036e2ed1535be94a86966" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a sequence, then &lt;code&gt;p(x)&lt;/code&gt; is returned for each element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is another polynomial then the composite polynomial &lt;code&gt;p(x(t))&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是一个序列，则 &lt;code&gt;p(x)&lt;/code&gt; 的每个元素被返回 &lt;code&gt;x&lt;/code&gt; 。如果 &lt;code&gt;x&lt;/code&gt; 是另一个多项式，则返回复合多项式 &lt;code&gt;p(x(t))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e418b1b9672c946b1ca5e8afc3125fd05c313b38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a subtype of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; the return value will be of the same type.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;的子类型，则返回值将是同一类型。</target>
        </trans-unit>
        <trans-unit id="2f55968163fb644f21e767c8ca56c7265582f682" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an integer, randomly permute &lt;code&gt;np.arange(x)&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is an array, make a copy and shuffle the elements randomly.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是整数，则随机置换 &lt;code&gt;np.arange(x)&lt;/code&gt; 。如果 &lt;code&gt;x&lt;/code&gt; 是一个数组，请进行复制并随机随机排列这些元素。</target>
        </trans-unit>
        <trans-unit id="8675c9efb1c5ad5afa002d06cb6dcceef7c6f2a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is inexact, NaN is replaced by zero or by the user defined value in &lt;a href=&quot;../constants#numpy.nan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt; keyword, infinity is replaced by the largest finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;posinf&lt;/code&gt; keyword and -infinity is replaced by the most negative finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;neginf&lt;/code&gt; keyword.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 不精确，将NaN替换为零或&lt;a href=&quot;../constants#numpy.nan&quot;&gt; &lt;code&gt;nan&lt;/code&gt; &lt;/a&gt;关键字中的用户定义值，将infinity替换为 &lt;code&gt;x.dtype&lt;/code&gt; 可表示的最大有限浮点值，或替换为 &lt;code&gt;posinf&lt;/code&gt; 关键字中的用户定义值，并将-infinity替换为由 &lt;code&gt;x.dtype&lt;/code&gt; 或 &lt;code&gt;neginf&lt;/code&gt; 关键字中用户定义的值表示的最负的有限浮点值。</target>
        </trans-unit>
        <trans-unit id="a12bcfaac2b6a0d5eb775110eb5d113a7ffcf89b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not inexact, then no replacements are made.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 不精确，则不进行替换。</target>
        </trans-unit>
        <trans-unit id="dab92b609c96bcdc43f19efa69fe1680ecbcb0cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is of a signed integer type, then the output type is the default platform integer:</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为带符号整数类型，则输出类型为默认平台整数：</target>
        </trans-unit>
        <trans-unit id="9b8211170506c6269c7986617b768331c6cb9374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;xp&lt;/code&gt; and &lt;code&gt;fp&lt;/code&gt; have different length If &lt;code&gt;xp&lt;/code&gt; or &lt;code&gt;fp&lt;/code&gt; are not 1-D sequences If &lt;code&gt;period == 0&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;xp&lt;/code&gt; 和 &lt;code&gt;fp&lt;/code&gt; 的长度不同如果 &lt;code&gt;xp&lt;/code&gt; 或 &lt;code&gt;fp&lt;/code&gt; 不是一维序列如果 &lt;code&gt;period == 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c2455250a9da7702638a12b7e54e59f4d21fc53" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;arr&lt;/em&gt; is an array, returns its data type descriptor, but if &lt;em&gt;arr&lt;/em&gt; is an array scalar (has 0 dimensions), it finds the data type of smallest size to which the value may be converted without overflow or truncation to an integer.</source>
          <target state="translated">如果&lt;em&gt;arr&lt;/em&gt;是一个数组，则返回其数据类型描述符，但是如果&lt;em&gt;arr&lt;/em&gt;是一个数组标量（维数为0），它将找到最小大小的数据类型，该值可以转换为该大小而不会发生溢出或截断，得到整数。</target>
        </trans-unit>
        <trans-unit id="a70ed9437e4a5163189d25b472581eabce8d5ceb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is &lt;em&gt;None&lt;/em&gt; (the default), the array is treated as a 1-D array and the operation is performed over the entire array. This behavior is also the default if self is a 0-dimensional array or array scalar. (An array scalar is an instance of the types/classes float32, float64, etc., whereas a 0-dimensional array is an ndarray instance containing precisely one array scalar.)</source>
          <target state="translated">如果&lt;em&gt;axis&lt;/em&gt;为&lt;em&gt;None&lt;/em&gt;（默认值），则将该数组视为一维数组，并在整个数组上执行该操作。如果self是0维数组或数组标量，则此行为也是默认行为。（数组标量是float32，float64等类型/类的实例，而0维数组是仅包含一个数组标量的ndarray实例。）</target>
        </trans-unit>
        <trans-unit id="9235232429102d093beb5f545c26b8fef229f79b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is an integer, then the operation is done over the given axis (for each 1-D subarray that can be created along the given axis).</source>
          <target state="translated">如果&lt;em&gt;axis&lt;/em&gt;是整数，则将在给定的轴上进行操作（对于可沿给定轴创建的每个1-D子数组）。</target>
        </trans-unit>
        <trans-unit id="1b1a4ec186584bdfde20daf47a6283f1daa2a542" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then new unitinialized memory will be allocated and &lt;em&gt;flags&lt;/em&gt; can be non-zero to indicate a Fortran-style contiguous array. Use &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt;&lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt;&lt;/a&gt; to initialize the memory.</source>
          <target state="translated">如果&lt;em&gt;data&lt;/em&gt;为 &lt;code&gt;NULL&lt;/code&gt; ，则将分配新的单位化内存，并且&lt;em&gt;标志&lt;/em&gt;可以为非零，以指示Fortran样式的连续数组。使用&lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt; &lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt; &lt;/a&gt;初始化内存。</target>
        </trans-unit>
        <trans-unit id="b7bd71ee3411fe6c23b731a500527ae1ac46e705" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, then it is assumed to point to the memory to be used for the array and the &lt;em&gt;flags&lt;/em&gt; argument is used as the new flags for the array (except the state of &lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags of the new array will be reset).</source>
          <target state="translated">如果&lt;em&gt;data&lt;/em&gt;不为 &lt;code&gt;NULL&lt;/code&gt; ，则假定它指向要用于该数组的内存，并且&lt;em&gt;flags&lt;/em&gt;参数用作该数组的新标志（新数组的&lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt; &lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;标志的状态除外）重置）。</target>
        </trans-unit>
        <trans-unit id="6b3854bd1e23682951d79d6393e1c1b2b19835be" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, then it is assumed to point to the memory to be used for the array and the &lt;em&gt;flags&lt;/em&gt; argument is used as the new flags for the array (except the state of &lt;code&gt;NPY_OWNDATA&lt;/code&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags of the new array will be reset).</source>
          <target state="translated">如果&lt;em&gt;data&lt;/em&gt;不为 &lt;code&gt;NULL&lt;/code&gt; ，则假定它指向要用于数组的内存，并且&lt;em&gt;flags&lt;/em&gt;参数用作数组的新标志（新数组的 &lt;code&gt;NPY_OWNDATA&lt;/code&gt; ，&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;标志的状态除外）重置）。</target>
        </trans-unit>
        <trans-unit id="9cebbbbcc1739892f8b12e053651c131570cd283" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;descr&lt;/em&gt; is NULL, the data type of &lt;em&gt;prototype&lt;/em&gt; is used.</source>
          <target state="translated">如果&lt;em&gt;descr&lt;/em&gt;为NULL，则使用&lt;em&gt;原型&lt;/em&gt;的数据类型。</target>
        </trans-unit>
        <trans-unit id="aec9506a456027cf0203832745240a439d9ff187" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dtype&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the returned array will have the same data type as &lt;em&gt;self&lt;/em&gt;. The new data-type must be consistent with the size of &lt;em&gt;self&lt;/em&gt;. Either the itemsizes must be identical, or &lt;em&gt;self&lt;/em&gt; must be single-segment and the total number of bytes must be the same. In the latter case the dimensions of the returned array will be altered in the last (or first for Fortran-style contiguous arrays) dimension. The data area of the returned array and self is exactly the same.</source>
          <target state="translated">如果&lt;em&gt;dtype&lt;/em&gt;为 &lt;code&gt;NULL&lt;/code&gt; ，则返回的数组将具有与&lt;em&gt;self&lt;/em&gt;相同的数据类型。新的数据类型必须与&lt;em&gt;self&lt;/em&gt;的大小一致。项目大小必须相同，或者&lt;em&gt;self&lt;/em&gt;必须为单段，并且字节总数必须相同。在后一种情况下，将在最后一个（对于Fortran样式的连续数组来说，第一个）维中更改返回数组的维。返回的数组和self的数据区域完全相同。</target>
        </trans-unit>
        <trans-unit id="b00215400909f507a463937ff52555cace4d8945" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;op&lt;/em&gt; is already an array, but does not satisfy the requirements, then a copy is made (which will satisfy the requirements). If this flag is present and a copy (of an object that is already an array) must be made, then the corresponding &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag is set in the returned copy and &lt;em&gt;op&lt;/em&gt; is made to be read-only. You must be sure to call &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; to copy the contents back into &lt;em&gt;op&lt;/em&gt; and the &lt;em&gt;op&lt;/em&gt; array will be made writeable again. If &lt;em&gt;op&lt;/em&gt; is not writeable to begin with, or if it is not already an array, then an error is raised.</source>
          <target state="translated">如果&lt;em&gt;op&lt;/em&gt;已经是一个数组，但不满足要求，那么将进行复制（将满足要求）。如果存在此标志，并且必须创建（已经是数组的对象的）副本，则在返回的副本中设置相应的&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;标志，并将&lt;em&gt;op&lt;/em&gt;设为只读。您必须确保调用&lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;将内容复制回&lt;em&gt;op中&lt;/em&gt;，并且&lt;em&gt;op&lt;/em&gt;数组将再次变为可写状态。如果&lt;em&gt;op&lt;/em&gt;从一开始就不可写，或者它还不是数组，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="2b3d523872c6239b2b47533fe932fb9b935c7ec9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, the shape of the result is</source>
          <target state="translated">如果&lt;em&gt;permute&lt;/em&gt;为 &lt;code&gt;NULL&lt;/code&gt; ，则结果的形状为</target>
        </trans-unit>
        <trans-unit id="864a2871c8455778be67517dc3e9f63ae59a60fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subok&lt;/em&gt; is 1, the newly created array will use the sub-type of &lt;em&gt;prototype&lt;/em&gt; to create the new array, otherwise it will create a base-class array.</source>
          <target state="translated">如果&lt;em&gt;subok&lt;/em&gt;为1，则新创建的数组将使用&lt;em&gt;原型&lt;/em&gt;的子类型创建新数组，否则将创建基类数组。</target>
        </trans-unit>
        <trans-unit id="d7c8774de40710ea170a99b3d842fc0b2a6f66b4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subtype&lt;/em&gt; is of an array subclass instead of the base &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;obj&lt;/em&gt; is the object to pass to the &lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; method of the subclass.</source>
          <target state="translated">如果&lt;em&gt;子类型&lt;/em&gt;属于数组子类，而不是基础&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt; &lt;/a&gt;，则&lt;em&gt;obj&lt;/em&gt;是要传递给子类的&lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; &lt;/a&gt;方法的对象。</target>
        </trans-unit>
        <trans-unit id="3703a88bcd847e1448a723a502192b0e8fa8fa65" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subtype&lt;/em&gt; is of an array subclass instead of the base &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;obj&lt;/em&gt; is the object to pass to the &lt;a href=&quot;../arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; method of the subclass.</source>
          <target state="translated">如果&lt;em&gt;子类型&lt;/em&gt;属于数组子类，而不是基类&lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt; &lt;/a&gt;，则&lt;em&gt;obj&lt;/em&gt;是要传递给子类的&lt;a href=&quot;../arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; &lt;/a&gt;方法的对象。</target>
        </trans-unit>
        <trans-unit id="c808aeb714f46484081440736a2f659eda1cb00f" translate="yes" xml:space="preserve">
          <source>If A = qr such that q is orthonormal (which is always possible via Gram-Schmidt), then &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt;. (In numpy practice, however, we simply use &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt;&lt;code&gt;lstsq&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">如果A = qr使得q是正交的（通过Gram-Schmidt总是可以的），则 &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt; 。（但是，在numpy练习中，我们仅使用&lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt; &lt;code&gt;lstsq&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="a5523a2784c429b6ba47e45d47c8a0bb942c669e" translate="yes" xml:space="preserve">
          <source>If False, a view into the original arrays are returned in order to conserve memory. Default is True. Please note that &lt;code&gt;sparse=False, copy=False&lt;/code&gt; will likely return non-contiguous arrays. Furthermore, more than one element of a broadcast array may refer to a single memory location. If you need to write to the arrays, make copies first.</source>
          <target state="translated">如果为False，则返回原始数组的视图以节省内存。默认值为True。请注意， &lt;code&gt;sparse=False, copy=False&lt;/code&gt; 可能会返回非连续数组。此外，广播阵列的一个以上的元素可以引用单个存储位置。如果需要写入阵列，请先进行复制。</target>
        </trans-unit>
        <trans-unit id="343caea52a4d2f3f220c6f641bc3ef525fc8ff10" translate="yes" xml:space="preserve">
          <source>If False, reference count will not be checked. Default is True.</source>
          <target state="translated">如果为False,将不检查参考次数。默认为True。</target>
        </trans-unit>
        <trans-unit id="cc82a0ba7e27b536a6fe2ae6adeaa5a186566e3c" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt;.</source>
          <target state="translated">如果默认值为False，则返回每个bin中的样本数。如果为True，则在bin &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt; 处返回概率&lt;em&gt;密度&lt;/em&gt;函数。</target>
        </trans-unit>
        <trans-unit id="023ffe5319599a1faa2198b591752fc4467344db" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt;.</source>
          <target state="translated">如果默认值为False，则返回每个bin中的样本数。如果为True，则在bin处返回概率&lt;em&gt;密度&lt;/em&gt;函数 &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fff9762cd2d96487b93950bfb4f1067d252f526d" translate="yes" xml:space="preserve">
          <source>If GitHub indicates that the branch of your Pull Request can no longer be merged automatically, you have to incorporate changes that have been made since you started into your branch. Our recommended way to do this is to &lt;a href=&quot;development_workflow#rebasing-on-master&quot;&gt;rebase on master&lt;/a&gt;.</source>
          <target state="translated">如果GitHub指示不再可以自动合并您的&amp;ldquo;拉取请求&amp;rdquo;的分支，则必须将自开始以来所做的更改合并到分支中。我们推荐的方法是&lt;a href=&quot;development_workflow#rebasing-on-master&quot;&gt;基于master&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a65d3c4015ca8415c134fa3b89bccc8e92003c36" translate="yes" xml:space="preserve">
          <source>If K = min(M, N), then</source>
          <target state="translated">如果K=min(M,N),则</target>
        </trans-unit>
        <trans-unit id="c8fe35dc8be08c32dcc7a321c29a26e840a0b0cb" translate="yes" xml:space="preserve">
          <source>If None, the index is into the flattened array, otherwise along the specified axis</source>
          <target state="translated">如果为None,则索引进入扁平化数组,否则沿着指定的坐标轴</target>
        </trans-unit>
        <trans-unit id="b2ed776381411dcc06237a74c5e85611ae70c52e" translate="yes" xml:space="preserve">
          <source>If None, then the path is assumed to be the local path plus the subpackage_name. If a setup.py file is not found in the subpackage_path, then a default configuration is used.</source>
          <target state="translated">如果为None,则假设路径为本地路径加上subpackage_name。如果在subpackage_path中没有找到setup.py文件,则使用默认配置。</target>
        </trans-unit>
        <trans-unit id="7ed2128e955055b733a7b269ab15855f518690e5" translate="yes" xml:space="preserve">
          <source>If None, use a MaskType instance. Otherwise, use a new datatype with the same fields as &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, converted to boolean types.</source>
          <target state="translated">如果为None，则使用MaskType实例。否则，请使用与&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;相同字段的新数据类型，并将其转换为布尔类型。</target>
        </trans-unit>
        <trans-unit id="7f68badbcb18a0e633a2cc1aee70bc74cc566792" translate="yes" xml:space="preserve">
          <source>If None, use a MaskType instance. Otherwise, use a new datatype with the same fields as &lt;code&gt;dtype&lt;/code&gt;, converted to boolean types.</source>
          <target state="translated">如果为None，则使用MaskType实例。否则，请使用与 &lt;code&gt;dtype&lt;/code&gt; 相同字段的新数据类型，并将其转换为布尔类型。</target>
        </trans-unit>
        <trans-unit id="858f084d421de6a09702f1940e95232bb37adf96" translate="yes" xml:space="preserve">
          <source>If Python &lt;code&gt;None&lt;/code&gt; object is used as a required argument, the argument is treated as optional. That is, in the case of array argument, the memory is allocated. And if &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; is given, the corresponding initialization is carried out.</source>
          <target state="translated">如果将Python &lt;code&gt;None&lt;/code&gt; 对象用作必需参数，则该参数被视为可选参数。也就是说，在使用数组参数的情况下，将分配内存。如果给出了 &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; ，则执行相应的初始化。</target>
        </trans-unit>
        <trans-unit id="b88b29f182ab4a1e89998e5d778c700419477eb5" translate="yes" xml:space="preserve">
          <source>If SVD computation does not converge.</source>
          <target state="translated">如果SVD计算不收敛。</target>
        </trans-unit>
        <trans-unit id="1c8e91eba4c31b07d056c5e107cd3dbd66e73c1f" translate="yes" xml:space="preserve">
          <source>If True (default) make a copy of &lt;code&gt;a&lt;/code&gt; in the result. If False modify &lt;code&gt;a&lt;/code&gt; in place and return a view.</source>
          <target state="translated">如果为True（默认），则在结果中复制 &lt;code&gt;a&lt;/code&gt; 。如果假修改 &lt;code&gt;a&lt;/code&gt; 到位，并返回一个视图。</target>
        </trans-unit>
        <trans-unit id="5f05298246a514cfbe30605192f5c3eec0c39e89" translate="yes" xml:space="preserve">
          <source>If True (default), &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;vh&lt;/code&gt; have the shapes &lt;code&gt;(..., M, M)&lt;/code&gt; and &lt;code&gt;(..., N, N)&lt;/code&gt;, respectively. Otherwise, the shapes are &lt;code&gt;(..., M, K)&lt;/code&gt; and &lt;code&gt;(..., K, N)&lt;/code&gt;, respectively, where &lt;code&gt;K = min(M, N)&lt;/code&gt;.</source>
          <target state="translated">如果为True（默认），则 &lt;code&gt;u&lt;/code&gt; 和 &lt;code&gt;vh&lt;/code&gt; 分别具有 &lt;code&gt;(..., M, M)&lt;/code&gt; 和 &lt;code&gt;(..., N, N)&lt;/code&gt; 的形状。否则，形状分别为 &lt;code&gt;(..., M, K)&lt;/code&gt; 和 &lt;code&gt;(..., K, N)&lt;/code&gt; ，其中 &lt;code&gt;K = min(M, N)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7193bd03fb8a4044e82de41b9072ea59ef18024" translate="yes" xml:space="preserve">
          <source>If True (default), the function for pretty printing (&lt;code&gt;__repr__&lt;/code&gt;) is set, if False the function that returns the default string representation (&lt;code&gt;__str__&lt;/code&gt;) is set.</source>
          <target state="translated">如果为True（默认值），则设置漂亮打印功能（ &lt;code&gt;__repr__&lt;/code&gt; ），如果为False，则设置返回默认字符串表示形式的函数（ &lt;code&gt;__str__&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="303e2928545dd79ae7d3ee948a353e0207edca4f" translate="yes" xml:space="preserve">
          <source>If True a sparse grid is returned in order to conserve memory. Default is False.</source>
          <target state="translated">如果为True,则返回一个稀疏网格,以节省内存。默认为False。</target>
        </trans-unit>
        <trans-unit id="963fdb4eb1744c24416dda1302569ec977b1039b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;M&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">如果为True，则将 &lt;code&gt;M&lt;/code&gt; 假定为Hermitian（如果为实数，则为对称），从而可以更有效地找到奇异值。默认为False。</target>
        </trans-unit>
        <trans-unit id="7ff6382ed5c39a63563e9ed1fd085cab5037a2b5" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;a&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">如果为True，则将 &lt;code&gt;a&lt;/code&gt; 假定为Hermitian（如果为实值，则为对称），从而可以更有效地找到奇异值。默认为False。</target>
        </trans-unit>
        <trans-unit id="e36b410b04f66dbee1ad8585d5ab761e08ac7f58" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;c_or_r&lt;/code&gt; specifies the polynomial&amp;rsquo;s roots; the default is False.</source>
          <target state="translated">如果为True，则 &lt;code&gt;c_or_r&lt;/code&gt; 指定多项式的根。默认值为False。</target>
        </trans-unit>
        <trans-unit id="d928194afbe2c2b929bfedb481313d712d7c8b8b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">如果为True，则 &lt;code&gt;stop&lt;/code&gt; 是最后一个样本。否则，不包括在内。默认值为True。</target>
        </trans-unit>
        <trans-unit id="7b47be5e3a5ad40d6f18921eb27fcceb85292f89" translate="yes" xml:space="preserve">
          <source>If True, NaNs will compare equal.</source>
          <target state="translated">如果True,NaNs将比较平等。</target>
        </trans-unit>
        <trans-unit id="cf238e83938a09d87961a742f48c2f2620eb27d1" translate="yes" xml:space="preserve">
          <source>If True, align the fields by padding as the C-compiler would. Default is False.</source>
          <target state="translated">如果为True,就像C编译器一样用padding对齐字段。默认为False。</target>
        </trans-unit>
        <trans-unit id="9aac1833ab9bd35419c20a57ebf8fcbcb3fe9e5b" translate="yes" xml:space="preserve">
          <source>If True, also repack nested structures.</source>
          <target state="translated">如果True,也要重新打包嵌套结构。</target>
        </trans-unit>
        <trans-unit id="fac02997269b77136285be7a5e579ac29dadfffd" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of &lt;code&gt;ar&lt;/code&gt; (along the specified axis, if provided, or in the flattened array) that result in the unique array.</source>
          <target state="translated">如果为True，则还返回 &lt;code&gt;ar&lt;/code&gt; 的索引（沿着指定的轴，如果提供的话，或者在展平的数组中），这将导致唯一的数组。</target>
        </trans-unit>
        <trans-unit id="5ba4a4047dcee50611d5129a3a15323121b0e960" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of the unique array (for the specified axis, if provided) that can be used to reconstruct &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">如果为True，则还返回可用于重建 &lt;code&gt;ar&lt;/code&gt; 的唯一数组的索引（对于指定的轴（如果提供））。</target>
        </trans-unit>
        <trans-unit id="399ee9e74026589c23b2445da8094594d73ae5dd" translate="yes" xml:space="preserve">
          <source>If True, also return the number of times each unique item appears in &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">如果为True，则还返回每个唯一项出现在 &lt;code&gt;ar&lt;/code&gt; 中的次数。</target>
        </trans-unit>
        <trans-unit id="66852352128b1c7e34ad7789302cdfe6ede485bb" translate="yes" xml:space="preserve">
          <source>If True, always print floating point numbers using fixed point notation, in which case numbers equal to zero in the current precision will print as zero. If False, then scientific notation is used when absolute value of the smallest number is &amp;lt; 1e-4 or the ratio of the maximum absolute value to the minimum is &amp;gt; 1e3. The default is False.</source>
          <target state="translated">如果为True，则始终使用定点表示法打印浮点数，在这种情况下，当前精度中等于零的数字将打印为零。如果为False，则当最小数的绝对值&amp;lt;1e-4或最大绝对值与最小值之比&amp;gt; 1e3时使用科学计数法。默认值为False。</target>
        </trans-unit>
        <trans-unit id="cbca430a42a0182aa9ea6441a3957e8ab3c8a25b" translate="yes" xml:space="preserve">
          <source>If True, always returns a tuple.</source>
          <target state="translated">如果为真,总是返回一个元组。</target>
        </trans-unit>
        <trans-unit id="7f126462d85653c6dda1dce20f661e9fd87395a7" translate="yes" xml:space="preserve">
          <source>If True, an exception is raised if an inconsistency is detected in the number of columns. If False, a warning is emitted and the offending lines are skipped.</source>
          <target state="translated">如果为真,如果检测到列数不一致,就会引发异常。如果为False,则会发出警告,并跳过违规的行。</target>
        </trans-unit>
        <trans-unit id="00dd94f809ecdc81e9a20bf00165ace3a76e2409" translate="yes" xml:space="preserve">
          <source>If True, do not raise errors for invalid values.</source>
          <target state="translated">如果为True,则不会为无效值出错。</target>
        </trans-unit>
        <trans-unit id="75ba0a561e02b7ed5e7fa180639d41ec79419f2b" translate="yes" xml:space="preserve">
          <source>If True, field names are case sensitive. If False or &amp;lsquo;upper&amp;rsquo;, field names are converted to upper case. If &amp;lsquo;lower&amp;rsquo;, field names are converted to lower case.</source>
          <target state="translated">如果为True，则字段名称区分大小写。如果为False或&amp;ldquo; upper&amp;rdquo;，则字段名称将转换为大写。如果为&amp;ldquo; lower&amp;rdquo;，则字段名称将转换为小写。</target>
        </trans-unit>
        <trans-unit id="d130bfc0ef6421a7c1dc4437f4b7a0f3775ccf94" translate="yes" xml:space="preserve">
          <source>If True, fields in the dst for which there was no matching field in the src are filled with the value 0 (zero). This was the behavior of numpy &amp;lt;= 1.13. If False, those fields are not modified.</source>
          <target state="translated">如果为True，则dst中src中没有匹配字段的字段将填充为值0（零）。这是numpy &amp;lt;= 1.13的行为。如果为False，则不会修改这些字段。</target>
        </trans-unit>
        <trans-unit id="7d57971ed0ca8f21d400e58c76703f43cbfc417c" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises a &lt;code&gt;ValueError&lt;/code&gt; exception when some values are missing.</source>
          <target state="translated">如果为True，则屏蔽的值将成对传播：如果某个值在 &lt;code&gt;x&lt;/code&gt; 中被屏蔽，则相应的值在 &lt;code&gt;y&lt;/code&gt; 中被屏蔽。如果为False，则在缺少某些值时会引发 &lt;code&gt;ValueError&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="73add7a762002fef273e9b4ffea7ca56d1fceed2" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises an exception. Because &lt;code&gt;bias&lt;/code&gt; is deprecated, this argument needs to be treated as keyword only to avoid a warning.</source>
          <target state="translated">如果为True，则屏蔽的值将成对传播：如果某个值在 &lt;code&gt;x&lt;/code&gt; 中被屏蔽，则相应的值在 &lt;code&gt;y&lt;/code&gt; 中被屏蔽。如果为False，则引发异常。由于不建议使用 &lt;code&gt;bias&lt;/code&gt; ，因此仅在避免警告时才需要将此参数视为关键字。</target>
        </trans-unit>
        <trans-unit id="3151423c1b8495757a74a9c40933465afccfc94a" translate="yes" xml:space="preserve">
          <source>If True, report coverage of NumPy code. Default is False. (This requires the &lt;a href=&quot;https://nedbatchelder.com/code/modules/coveragehtml&quot;&gt;coverage module&lt;/a&gt;).</source>
          <target state="translated">如果为True，则报告NumPy代码的覆盖率。默认值为False。（这需要&lt;a href=&quot;https://nedbatchelder.com/code/modules/coveragehtml&quot;&gt;coverage模块&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3f2788b0d6fce7deb3124b031af49411eebfd85f" translate="yes" xml:space="preserve">
          <source>If True, return (&lt;code&gt;samples&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;), where &lt;code&gt;step&lt;/code&gt; is the spacing between samples.</source>
          <target state="translated">如果为True，则返回（ &lt;code&gt;samples&lt;/code&gt; ， &lt;code&gt;step&lt;/code&gt; ），其中 &lt;code&gt;step&lt;/code&gt; 是样本之间的间隔。</target>
        </trans-unit>
        <trans-unit id="273f09f29e0c5b2094a6e70e74f740f3fc0e31da" translate="yes" xml:space="preserve">
          <source>If True, return a &lt;a href=&quot;https://docs.python.org/dev/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;subprocess.CompletedProcess&lt;/code&gt;&lt;/a&gt; containing the stdout and stderr of the compile process, instead of just the status code.</source>
          <target state="translated">如果为True，则返回一个&lt;a href=&quot;https://docs.python.org/dev/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;subprocess.CompletedProcess&lt;/code&gt; ,&lt;/a&gt;其中包含编译过程的stdout和stderr，而不仅仅是状态码。</target>
        </trans-unit>
        <trans-unit id="1ec0fbd07daef19f7914b14e4eca0f4fd562cd19" translate="yes" xml:space="preserve">
          <source>If True, return a masked array. If False, return a regular array.</source>
          <target state="translated">如果为真,返回一个掩码数组。如果为False,返回一个常规数组。</target>
        </trans-unit>
        <trans-unit id="6adea9a68fb349bf8bb3df130607e9340ead5b74" translate="yes" xml:space="preserve">
          <source>If True, run doctests in module. Default is False.</source>
          <target state="translated">如果为真,在模块中运行doctests。默认为False。</target>
        </trans-unit>
        <trans-unit id="23ec8ba9608d7abff50b6dc8fd3f7629dafcce5d" translate="yes" xml:space="preserve">
          <source>If True, specifies that the decorated callable is a test. If False, specifies that the decorated callable is not a test. Default is True.</source>
          <target state="translated">如果为True,指定被装饰的callable是一个测试。如果为False,则指定被装饰的callable不是测试。默认为True。</target>
        </trans-unit>
        <trans-unit id="528d6459701fb35380cbc7e9b626e72c7e5fe90f" translate="yes" xml:space="preserve">
          <source>If True, sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).</source>
          <target state="translated">如果为True,子类将被传递,否则返回的数组将被强制为基类数组(默认)。</target>
        </trans-unit>
        <trans-unit id="392d55a0a9d04db7b0ca9f8c7072e4cdcc499491" translate="yes" xml:space="preserve">
          <source>If True, subclasses are preserved.</source>
          <target state="translated">如果为True,则保留子类。</target>
        </trans-unit>
        <trans-unit id="8d750c3ba08e3d89b81f148fbacf7cfd56b0a5f8" translate="yes" xml:space="preserve">
          <source>If True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">如果为True，则缩小的轴将保留为尺寸1的尺寸。使用此选项，结果将针对原始 &lt;code&gt;arr&lt;/code&gt; 正确广播。</target>
        </trans-unit>
        <trans-unit id="b2006dd9c76a3ff3a106ec273dd3c8e1e765c752" translate="yes" xml:space="preserve">
          <source>If True, the conflicting values are appended to the error message.</source>
          <target state="translated">如果为True,则将冲突的值附加到错误信息中。</target>
        </trans-unit>
        <trans-unit id="d8ba5d3712bb2ee2efcfc81e8a867c710618acda" translate="yes" xml:space="preserve">
          <source>If True, the indices which correspond to the intersection of the two arrays are returned. The first instance of a value is used if there are multiple. Default is False.</source>
          <target state="translated">如果为True,返回两个数组的交点对应的索引。如果有多个数组,则使用第一个值的实例。默认值为False。</target>
        </trans-unit>
        <trans-unit id="796c55d79196f76e9a5e82ed451d32129c18b457" translate="yes" xml:space="preserve">
          <source>If True, the input arrays are both assumed to be unique, which can speed up the calculation. Default is False.</source>
          <target state="translated">如果为True,则假设输入数组都是唯一的,这样可以加快计算速度。默认为False。</target>
        </trans-unit>
        <trans-unit id="262ad12226b8d86b75ded0db8c7b0c32d50e89e8" translate="yes" xml:space="preserve">
          <source>If True, the input arrays are both assumed to be unique, which can speed up the calculation. If True but &lt;code&gt;ar1&lt;/code&gt; or &lt;code&gt;ar2&lt;/code&gt; are not unique, incorrect results and out-of-bounds indices could result. Default is False.</source>
          <target state="translated">如果为True，则假定输入数组都是唯一的，这可以加快计算速度。如果True但 &lt;code&gt;ar1&lt;/code&gt; 或 &lt;code&gt;ar2&lt;/code&gt; 不是唯一的，则可能导致错误的结果和越界索引。默认值为False。</target>
        </trans-unit>
        <trans-unit id="4faadc5e6554004b31ce5928d5d80bd241c02388" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with either the &lt;code&gt;c_index&lt;/code&gt; or the &lt;code&gt;f_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">如果为True，则使用 &lt;code&gt;c_index&lt;/code&gt; 或 &lt;code&gt;f_index&lt;/code&gt; 标志创建迭代器，并且可以使用属性&lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt;来检索它。</target>
        </trans-unit>
        <trans-unit id="78e99fe24c914b8497fc3d013aec906afbe03579" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;delay_bufalloc&lt;/code&gt; flag, and no reset() function was called on it yet.</source>
          <target state="translated">如果为True，则使用 &lt;code&gt;delay_bufalloc&lt;/code&gt; 标志创建迭代器，并且尚未对其调用reset（）函数。</target>
        </trans-unit>
        <trans-unit id="78a4539bda923dafd78fad0e5fb97c6b43556f2b" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;multi_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt;&lt;code&gt;multi_index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">如果为True，则使用 &lt;code&gt;multi_index&lt;/code&gt; 标志创建迭代器，并且可以使用属性&lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt; &lt;code&gt;multi_index&lt;/code&gt; &lt;/a&gt;来检索它。</target>
        </trans-unit>
        <trans-unit id="cd78b05e62a74691621672060edfaaaf7c932b8a" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = genfromtxt(...)&lt;/code&gt;. When used with a structured data-type, arrays are returned for each field. Default is False.</source>
          <target state="translated">如果为True，则对返回的数组进行转置，以便可以使用 &lt;code&gt;x, y, z = genfromtxt(...)&lt;/code&gt; 解压缩参数。与结构化数据类型一起使用时，将为每个字段返回数组。默认值为False。</target>
        </trans-unit>
        <trans-unit id="f4229174699f5726402f68c65f4921612f023a93" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;</source>
          <target state="translated">如果为True，则对返回的数组进行转置，以便可以使用 &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt; 解压缩参数。</target>
        </trans-unit>
        <trans-unit id="b9bf7edcd483311b9596b9cc1a4efa43974ee453" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;. When used with a structured data-type, arrays are returned for each field. Default is False.</source>
          <target state="translated">如果为True，则对返回的数组进行转置，以便可以使用 &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt; 解压缩参数。与结构化数据类型一起使用时，将为每个字段返回数组。默认值为False。</target>
        </trans-unit>
        <trans-unit id="d43fcdb1c52440e31bff4cb2f390cb23f384392a" translate="yes" xml:space="preserve">
          <source>If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;c&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;c&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;c&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">如果为True，则系数数组的形状在右侧扩展为1， &lt;code&gt;x&lt;/code&gt; 的每个维度都为1。标量对此操作的尺寸为0。结果是，对 &lt;code&gt;x&lt;/code&gt; 的每个元素都评估 &lt;code&gt;c&lt;/code&gt; 中的每一列系数。如果为False，则 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;c&lt;/code&gt; 的列上广播以进行评估。当 &lt;code&gt;c&lt;/code&gt; 为多维时，此关键字很有用。默认值是true。</target>
        </trans-unit>
        <trans-unit id="959391ebb6591b28733d37c72b179dc2ae1393e8" translate="yes" xml:space="preserve">
          <source>If True, the shape of the roots array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;r&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;r&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;r&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">如果为True，则将根数组的形状在右侧扩展为1，每个 &lt;code&gt;x&lt;/code&gt; 维度均扩展为1。标量对此操作的尺寸为0。结果是，对 &lt;code&gt;x&lt;/code&gt; 的每个元素都评估 &lt;code&gt;r&lt;/code&gt; 中的每一列系数。如果为False，则 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;r&lt;/code&gt; 的列上广播以进行评估。当 &lt;code&gt;r&lt;/code&gt; 为多维时，此关键字很有用。默认值是true。</target>
        </trans-unit>
        <trans-unit id="6f56bb6f69c7a79b2fcb0eba261866b1784e5a91" translate="yes" xml:space="preserve">
          <source>If True, the spaces at the end of Strings are removed before the comparison.</source>
          <target state="translated">如果为True,则在比较之前,Strings结尾的空格会被删除。</target>
        </trans-unit>
        <trans-unit id="201e227337fd7a8180e5a7ed35ba4fd5fc02b88e" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted (that is, False where an element of &lt;code&gt;ar1&lt;/code&gt; is in &lt;code&gt;ar2&lt;/code&gt; and True otherwise). Default is False. &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; is equivalent to (but is faster than) &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt;.</source>
          <target state="translated">如果为True，则返回的数组中的值将被反转（即，在 &lt;code&gt;ar1&lt;/code&gt; 中的一个元素位于 &lt;code&gt;ar2&lt;/code&gt; 中时为False，否则为True）。默认值为False。 &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; 等效于（但比 &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt; 更快）。</target>
        </trans-unit>
        <trans-unit id="259b3152dca6c438bfe50af972160ce0a4a1de26" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted, as if calculating &lt;code&gt;element not in test_elements&lt;/code&gt;. Default is False. &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; is equivalent to (but faster than) &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt;.</source>
          <target state="translated">如果为True，则返回数组中的值将被反转，就像计算 &lt;code&gt;element not in test_elements&lt;/code&gt; 。默认值为False。 &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; 等效于（但比 &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt; 更快）。</target>
        </trans-unit>
        <trans-unit id="945e8f6a0cee215b87f641fdb7d3287ee26a3bd1" translate="yes" xml:space="preserve">
          <source>If True, then allow the input array &lt;code&gt;a&lt;/code&gt; to be modified by intermediate calculations, to save memory. In this case, the contents of the input &lt;code&gt;a&lt;/code&gt; after this function completes is undefined.</source>
          <target state="translated">如果为True，则允许通过中间计算来修改输入数组 &lt;code&gt;a&lt;/code&gt; ，以节省内存。在这种情况下，此功能完成后输入 &lt;code&gt;a&lt;/code&gt; 的内容是不确定的。</target>
        </trans-unit>
        <trans-unit id="3dbfbe1abf097059eac31485586e156e13dcab2c" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array (a) for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. Note that, if &lt;code&gt;overwrite_input&lt;/code&gt; is True, and the input is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">如果为True，则允许使用输入数组（a）的内存进行计算。输入数组将通过调用中位数进行修改。当您不需要保留输入数组的内容时，这将节省内存。将输入视为未定义，但可能会完全或部分排序。默认值为False。请注意，如果 &lt;code&gt;overwrite_input&lt;/code&gt; 为True，并且输入还不是&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="efffbf4abfcfd3dab70b2b5adf8fd6ea45c7060a" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array (a) for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. Note that, if &lt;code&gt;overwrite_input&lt;/code&gt; is True, and the input is not already an &lt;code&gt;ndarray&lt;/code&gt;, an error will be raised.</source>
          <target state="translated">如果为True，则允许使用输入数组（a）的内存进行计算。输入数组将通过调用中位数进行修改。当您不需要保留输入数组的内容时，这将节省内存。将输入视为未定义，但可能会完全或部分排序。默认值为False。请注意，如果 &lt;code&gt;overwrite_input&lt;/code&gt; 为True，并且输入还不是 &lt;code&gt;ndarray&lt;/code&gt; ，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="453475060bdf9f6ca07ca2a9d367c0c72b7c7341" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">如果为True，则允许使用输入数组 &lt;code&gt;a&lt;/code&gt; 的内存进行计算。输入数组将通过调用&lt;a href=&quot;#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt;来修改。当您不需要保留输入数组的内容时，这将节省内存。将输入视为未定义，但可能会完全或部分排序。默认值为False。如果 &lt;code&gt;overwrite_input&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; 并且 &lt;code&gt;a&lt;/code&gt; 还不是&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，将引发错误。</target>
        </trans-unit>
        <trans-unit id="bf48ed6030d0efc488f7b3086097c6ad325b803d" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;numpy.median#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">如果为True，则允许使用输入数组 &lt;code&gt;a&lt;/code&gt; 的内存进行计算。输入数组将通过调用&lt;a href=&quot;numpy.median#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt;来修改。当您不需要保留输入数组的内容时，这将节省内存。将输入视为未定义，但可能会完全或部分排序。默认值为False。如果 &lt;code&gt;overwrite_input&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; 并且 &lt;code&gt;a&lt;/code&gt; 还不是&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，将引发错误。</target>
        </trans-unit>
        <trans-unit id="727bb21e15aa63ae35b6dc8fc80a632c45207cf3" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array.</source>
          <target state="translated">如果为True,那么子类将被传递(默认),否则返回的数组将被强制为基类数组。</target>
        </trans-unit>
        <trans-unit id="4ceb06545ceed82d0fd2c4e74fddc1a8387d729b" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).</source>
          <target state="translated">如果为True,那么子类将被传递,否则返回的数组将被强制为基类数组(默认)。</target>
        </trans-unit>
        <trans-unit id="7931866e33bf18d405c7c9da5047f41db3dc88c3" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (defaults to False).</source>
          <target state="translated">如果为True,那么子类将被传递,否则返回的数组将被强制为基类数组(默认为False)。</target>
        </trans-unit>
        <trans-unit id="9752fe228ae3462d649576fdb0cd4757647ae348" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned arrays will be forced to be a base-class array (default).</source>
          <target state="translated">如果为True,那么子类将被传递,否则返回的数组将被强制为基类数组(默认)。</target>
        </trans-unit>
        <trans-unit id="066838f1ffe5aa12c7d71f9b1de32afdb88ee10e" translate="yes" xml:space="preserve">
          <source>If True, then the newly created array will use the sub-class type of &amp;lsquo;a&amp;rsquo;, otherwise it will be a base-class array. Defaults to True.</source>
          <target state="translated">如果为True，则新创建的数组将使用'a'的子类类型，否则它将是基类数组。默认为True。</target>
        </trans-unit>
        <trans-unit id="637f994c43dad54f98722e59d623faad4b72d12f" translate="yes" xml:space="preserve">
          <source>If True, then the newly created array will use the sub-class type of &lt;code&gt;a&lt;/code&gt;, otherwise it will be a base-class array. Defaults to True.</source>
          <target state="translated">如果为True，则新创建的数组将使用子类型的 &lt;code&gt;a&lt;/code&gt; ，否则这将是一个基类数组。默认为True。</target>
        </trans-unit>
        <trans-unit id="2dc991539e6e09a358dd637bc4a93159f28455ae" translate="yes" xml:space="preserve">
          <source>If True, then the newly created array will use the sub-class type of &lt;code&gt;prototype&lt;/code&gt;, otherwise it will be a base-class array. Defaults to True.</source>
          <target state="translated">如果为True，则新创建的数组将使用 &lt;code&gt;prototype&lt;/code&gt; 的子类类型，否则它将是基类数组。默认为True。</target>
        </trans-unit>
        <trans-unit id="9ba9655ceab858d8e0fbfbe35222ace33db08fb2" translate="yes" xml:space="preserve">
          <source>If [array, array], the bin edges in each dimension (x_edges, y_edges = bins).</source>
          <target state="translated">如果[数组,数组],则每个维度的bin边(x_edges,y_edges=bins)。</target>
        </trans-unit>
        <trans-unit id="74d7f2b29106e8ca088ed3ddc192d60c869742ea" translate="yes" xml:space="preserve">
          <source>If [int, int], the number of bins in each dimension (nx, ny = bins).</source>
          <target state="translated">如果[int,int],则每个维度中的宾格数(nx,ny=宾格)。</target>
        </trans-unit>
        <trans-unit id="63952cde8568ab7ec41b2ac80ecf7fdc353a6855" translate="yes" xml:space="preserve">
          <source>If __svn_version__.py existed before, nothing is done.</source>
          <target state="translated">如果之前存在__svn_version__.py,则什么都不做。</target>
        </trans-unit>
        <trans-unit id="2973727add43998ece2695a952786574b37deff8" translate="yes" xml:space="preserve">
          <source>If a &amp;lt; 1.</source>
          <target state="translated">如果&amp;lt;1。</target>
        </trans-unit>
        <trans-unit id="d6288450796b9bb41fb24a4a3b5f478c44715bdc" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;python module&lt;/code&gt; block contains two or more &lt;code&gt;common&lt;/code&gt; blocks with the same name, the variables from the additional declarations are appended. The types of variables in &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt; are defined using &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt;. Note that the corresponding &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt; may contain array specifications; then you don&amp;rsquo;t need to specify these in &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;python module&lt;/code&gt; 块包含两个或更多个具有相同名称的 &lt;code&gt;common&lt;/code&gt; 块，则会附加来自附加声明的变量。在变量的类型 &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt; 使用定义 &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt; 。请注意，相应的 &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt; 可能包含数组规范。那么您就无需在 &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt; 中指定它们。</target>
        </trans-unit>
        <trans-unit id="949f92ee120b49054523e5f48bcc0be73d87cf4a" translate="yes" xml:space="preserve">
          <source>If a Council member becomes inactive in the project for a period of one year, they will be considered for removal from the Council. Before removal, inactive Member will be approached to see if they plan on returning to active participation. If not they will be removed immediately upon a Council vote. If they plan on returning to active participation soon, they will be given a grace period of one year. If they don&amp;rsquo;t return to active participation within that time period they will be removed by vote of the Council without further grace period. All former Council members can be considered for membership again at any time in the future, like any other Project Contributor. Retired Council members will be listed on the project website, acknowledging the period during which they were active in the Council.</source>
          <target state="translated">如果理事会成员在该项目中闲置了一年，则将考虑将其从理事会中撤职。在删除之前，将与不活跃的成员联系，以了解他们是否计划恢复活跃的参与。否则，将在理事会表决后立即将其删除。如果他们计划很快恢复积极参与，他们将获得一年的宽限期。如果他们在此期间内未恢复积极参与，则将由安理会投票将其罢免，而没有进一步的宽限期。像其他任何项目贡献者一样，将来任何时候都可以再次考虑所有前理事会成员的身份。退休理事会成员将列在项目网站上，并确认他们活跃于理事会的时期。</target>
        </trans-unit>
        <trans-unit id="0f5ac51d599581ab3e8a496c55fdc29ce07640e8" translate="yes" xml:space="preserve">
          <source>If a F2PY generated wrapper function expects the following call-back argument:</source>
          <target state="translated">如果一个F2PY生成的包装函数期待以下回调参数。</target>
        </trans-unit>
        <trans-unit id="736cfd31de35553aafebed98e2d227e880ff08c4" translate="yes" xml:space="preserve">
          <source>If a byteorder of &lt;a href=&quot;#c.NPY_IGNORE&quot;&gt;&lt;code&gt;NPY_IGNORE&lt;/code&gt;&lt;/a&gt; is encountered it is left alone. If newendian is &lt;a href=&quot;#c.NPY_SWAP&quot;&gt;&lt;code&gt;NPY_SWAP&lt;/code&gt;&lt;/a&gt;, then all byte-orders are swapped. Other valid newendian values are &lt;a href=&quot;#c.NPY_NATIVE&quot;&gt;&lt;code&gt;NPY_NATIVE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_LITTLE&quot;&gt;&lt;code&gt;NPY_LITTLE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_BIG&quot;&gt;&lt;code&gt;NPY_BIG&lt;/code&gt;&lt;/a&gt; which all cause the returned data-typed descriptor (and all it&amp;rsquo;s referenced data-type descriptors) to have the corresponding byte- order.</source>
          <target state="translated">如果遇到NPY_IGNORE的&lt;a href=&quot;#c.NPY_IGNORE&quot;&gt; &lt;code&gt;NPY_IGNORE&lt;/code&gt; &lt;/a&gt;顺序，则将其保留下来。如果newendian为&lt;a href=&quot;#c.NPY_SWAP&quot;&gt; &lt;code&gt;NPY_SWAP&lt;/code&gt; &lt;/a&gt;，则所有字节顺序都将交换。其他有效的newendian值是&lt;a href=&quot;#c.NPY_NATIVE&quot;&gt; &lt;code&gt;NPY_NATIVE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_LITTLE&quot;&gt; &lt;code&gt;NPY_LITTLE&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NPY_BIG&quot;&gt; &lt;code&gt;NPY_BIG&lt;/code&gt; &lt;/a&gt;，它们都使返回的数据类型的描述符（及其所有引用的数据类型的描述符）具有相应的字节顺序。</target>
        </trans-unit>
        <trans-unit id="ea1873bd2a58371aec0e3e9712cc84313c25ffe3" translate="yes" xml:space="preserve">
          <source>If a class (ndarray subclass or not) having the &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method is used as the output object of an &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, results will &lt;em&gt;not&lt;/em&gt; be written to the object returned by &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt;. This practice will return &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">如果具有一个类（子类ndarray与否）&lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;方法被用作一个的输出对象&lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;，结果将&lt;em&gt;不&lt;/em&gt;被写入到由返回的对象&lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;。这种做法将返回 &lt;code&gt;TypeError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5279f6f16ca5cb6814a2ac00854340dc9cd2fbb" translate="yes" xml:space="preserve">
          <source>If a class (ndarray subclass or not) having the &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method is used as the output object of an &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, results will be written to the object returned by &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt;. Similar conversion is done on input arrays.</source>
          <target state="translated">如果具有一个类（子类ndarray与否）&lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;方法被用作一个的输出对象&lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;，结果将被写入到由返回的对象&lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;。在输入数组上完成类似的转换。</target>
        </trans-unit>
        <trans-unit id="874568bcf37ebe0e2a8a8d54069b92c02f85f23a" translate="yes" xml:space="preserve">
          <source>If a class defines the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, this disables the &lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; mechanism described below for ufuncs (which may eventually be deprecated).</source>
          <target state="translated">如果一个类定义了&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;方法，这将禁用&lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;机制下面描述用于ufuncs（其可以最终被弃用）。</target>
        </trans-unit>
        <trans-unit id="0577aaede06ac434e631d772788e0f369a956f02" translate="yes" xml:space="preserve">
          <source>If a compile-time fixed buffer is being used (both flags &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;), the inner size may be used as a signal as well. The size is guaranteed to become zero when &lt;code&gt;iternext()&lt;/code&gt; returns false, enabling the following loop construct. Note that if you use this construct, you should not pass &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; as a flag, because it will cause larger sizes under some circumstances.</source>
          <target state="translated">如果正在使用编译时固定缓冲区（标志&lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;），则内部大小也可用作信号。当 &lt;code&gt;iternext()&lt;/code&gt; 返回false时，保证大小变为零，从而启用以下循环构造。请注意，如果使用此构造，则不&lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt;作为标志传递，因为在某些情况下它将导致更大的尺寸。</target>
        </trans-unit>
        <trans-unit id="9d666b71ab2db0f6cb052dc4a309c02e840cf132" translate="yes" xml:space="preserve">
          <source>If a dimension is given as -1 in a reshaping operation, the other dimensions are automatically calculated:</source>
          <target state="translated">如果在重塑操作中给定一个尺寸为-1,其他尺寸将自动计算。</target>
        </trans-unit>
        <trans-unit id="769025cc778c9102b36d6a70ef7aed0a8fe51c05" translate="yes" xml:space="preserve">
          <source>If a field name in the required_dtype does not exist in the input array, that field is created and set to 0 in the output array.</source>
          <target state="translated">如果在输入数组中不存在required_dtype中的字段名,则在输出数组中创建该字段并设置为0。</target>
        </trans-unit>
        <trans-unit id="4a3ce99d9611a27292277b44f279f72466bca938" translate="yes" xml:space="preserve">
          <source>If a field whose dtype object has this attribute is retrieved, then the extra dimensions implied by &lt;em&gt;shape&lt;/em&gt; are tacked on to the end of the retrieved array.</source>
          <target state="translated">如果检索到其dtype对象具有此属性的字段，则&lt;em&gt;形状&lt;/em&gt;隐含的额外维将附加到检索到的数组的末尾。</target>
        </trans-unit>
        <trans-unit id="aa639d13854427042e288c4d7a227d11cd8e9453" translate="yes" xml:space="preserve">
          <source>If a file &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; does not exist, the &lt;code&gt;include&lt;/code&gt; statement is ignored. Otherwise, the file &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; is included to a signature file. &lt;code&gt;include&lt;/code&gt; statements can be used in any part of a signature file, also outside the Fortran/C routine signature blocks.</source>
          <target state="translated">如果文件 &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; 不存在，则会忽略 &lt;code&gt;include&lt;/code&gt; 语句。否则，文件 &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; 将包含在签名文件中。 &lt;code&gt;include&lt;/code&gt; 语句可以在签名文件的任何部分中使用，也可以在Fortran / C例程签名块之外使用。</target>
        </trans-unit>
        <trans-unit id="24439780a6864c35956999c18798d43f08d60388" translate="yes" xml:space="preserve">
          <source>If a formatter is specified for a certain type, the &lt;code&gt;precision&lt;/code&gt; keyword is ignored for that type.</source>
          <target state="translated">如果为特定类型指定了格式化程序，则将忽略该类型的 &lt;code&gt;precision&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="687f359e5176c0f016578fb6a4154929ee305cd5" translate="yes" xml:space="preserve">
          <source>If a given array does not satisfy the specified restrictions.</source>
          <target state="translated">如果一个给定的数组不满足指定的限制。</target>
        </trans-unit>
        <trans-unit id="516fd825a9c72297363bd8dd8c84b3bb2fcfe3f7" translate="yes" xml:space="preserve">
          <source>If a how-to has many steps:</source>
          <target state="translated">如果一个攻略有很多步骤。</target>
        </trans-unit>
        <trans-unit id="0f9748bf845ac9d150692dd01c4e3cac7093889e" translate="yes" xml:space="preserve">
          <source>If a is a matrix object, then the return value is a matrix as well:</source>
          <target state="translated">如果a是一个矩阵对象,那么返回值也是一个矩阵。</target>
        </trans-unit>
        <trans-unit id="8ca1d1baf4aebfbd38dd688686cce7228cb6bc88" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if a or p are not 1-dimensional, if a is an array-like of size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size</source>
          <target state="translated">如果a是一个int且小于0,如果a或p不是一维的,如果a是一个大小为0的类数组,如果p不是一个概率向量,如果a和p有不同的长度,或者如果replace=False,且样本量大于人口数量。</target>
        </trans-unit>
        <trans-unit id="45d749c722fde2f54ef7349c75a2d911b0caf469" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if p is not 1-dimensional, if a is array-like with a size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size.</source>
          <target state="translated">如果a是一个int且小于0,如果p不是一维的,如果a是大小为0的类数组,如果p不是概率的向量,如果a和p的长度不同,或者如果replace=False且样本数大于人口数。</target>
        </trans-unit>
        <trans-unit id="6a821a28e324f16f0f4bf4708058f9a3d079d082" translate="yes" xml:space="preserve">
          <source>If a list of strings, each string should represent a dtype. If array_like, the character representation of the array dtype is used.</source>
          <target state="translated">如果是字符串列表,每个字符串应该代表一个dtype。如果是array_like,则使用数组dtype的字符表示。</target>
        </trans-unit>
        <trans-unit id="f0978a6e619ec2d43693907e27d2eb435814d97e" translate="yes" xml:space="preserve">
          <source>If a report doesn&amp;rsquo;t contain enough information, the committee will obtain all relevant data before acting. The committee is empowered to act on the Steering Council&amp;rsquo;s behalf in contacting any individuals involved to get a more complete account of events.</source>
          <target state="translated">如果报告中没有足够的信息，委员会将在采取行动之前获得所有相关数据。该委员会有权代表指导委员会采取行动，与任何相关人员联系，以获取有关事件的更完整说明。</target>
        </trans-unit>
        <trans-unit id="63795a6ab48fcba94623b51f8a7753fc963d4b8e" translate="yes" xml:space="preserve">
          <source>If a scalar dtype, the corresponding string character is returned. If an object, &lt;a href=&quot;#numpy.sctype2char&quot;&gt;&lt;code&gt;sctype2char&lt;/code&gt;&lt;/a&gt; tries to infer its scalar type and then return the corresponding string character.</source>
          <target state="translated">如果是标量dtype，则返回相应的字符串字符。如果是对象，则&lt;a href=&quot;#numpy.sctype2char&quot;&gt; &lt;code&gt;sctype2char&lt;/code&gt; &lt;/a&gt;尝试推断其标量类型，然后返回相应的字符串字符。</target>
        </trans-unit>
        <trans-unit id="98a2233adc7ab93848107f159b490659bfa27e57" translate="yes" xml:space="preserve">
          <source>If a scalar value is passed in.</source>
          <target state="translated">如果传入一个标量值。</target>
        </trans-unit>
        <trans-unit id="15bc103dab402117d3913395fb8b40bbeeb0b897" translate="yes" xml:space="preserve">
          <source>If a second argument is supplied the result is stored there. If the type of that array is a numeric type the result is represented as zeros and ones, if the type is boolean then as False and True. The return value &lt;code&gt;out&lt;/code&gt; is then a reference to that array.</source>
          <target state="translated">如果提供了第二个参数，则结果存储在那里。如果该数组的类型是数字类型，则结果表示为零和一，如果类型为布尔值，则表示为False和True。然后，返回值 &lt;code&gt;out&lt;/code&gt; 是对该数组的引用。</target>
        </trans-unit>
        <trans-unit id="342304e655e812ee2a83e5789793e22172924b42" translate="yes" xml:space="preserve">
          <source>If a second argument is supplied the result is stored there. The return value &lt;code&gt;out&lt;/code&gt; is then a reference to that array.</source>
          <target state="translated">如果提供了第二个参数，则结果存储在此处。然后，返回值 &lt;code&gt;out&lt;/code&gt; 是对该数组的引用。</target>
        </trans-unit>
        <trans-unit id="ceb1ddfcab0f3cbec5d42431c301b1cc28fccf65" translate="yes" xml:space="preserve">
          <source>If a zero dimensional array is present in the index &lt;em&gt;and&lt;/em&gt; it is a full integer index the result will be a &lt;em&gt;scalar&lt;/em&gt; and not a zero dimensional array. (Advanced indexing is not triggered.)</source>
          <target state="translated">如果索引中存在零维数组，&lt;em&gt;并且&lt;/em&gt;它是全整数索引，则结果将是&lt;em&gt;标量，&lt;/em&gt;而不是零维数组。（不会触发高级索引。）</target>
        </trans-unit>
        <trans-unit id="64c5c963ea9794eafa3b89f1dd216c6a8ebfd684" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal up to specified precision.</source>
          <target state="translated">如果实际值和期望值不相等,达到指定精度。</target>
        </trans-unit>
        <trans-unit id="39bbb6143ab84f37b65c3d7880c2778b652d186d" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal.</source>
          <target state="translated">如果实际和期望不相等。</target>
        </trans-unit>
        <trans-unit id="fcebdf6acdb7662938a429c761fa5ad9e5471b67" translate="yes" xml:space="preserve">
          <source>If actual and desired objects are not equal.</source>
          <target state="translated">如果实际对象和期望对象不相等。</target>
        </trans-unit>
        <trans-unit id="8aa394119b239dde7365c85e156833625438bfa9" translate="yes" xml:space="preserve">
          <source>If all &lt;code&gt;__array_function__&lt;/code&gt; methods return &lt;code&gt;NotImplemented&lt;/code&gt;, NumPy will raise &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">如果所有 &lt;code&gt;__array_function__&lt;/code&gt; 方法都返回 &lt;code&gt;NotImplemented&lt;/code&gt; ，则NumPy将引发 &lt;code&gt;TypeError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="454ac4064cbf860208005757a60b81b3482b89cb" translate="yes" xml:space="preserve">
          <source>If all of the commits are related, create a merge commit:</source>
          <target state="translated">如果所有的提交都是相关的,创建一个合并提交。</target>
        </trans-unit>
        <trans-unit id="85985aaa1b2d2d353f8a23ec019a6f4085543d14" translate="yes" xml:space="preserve">
          <source>If all proposals for resolving some issue are vetoed, then the status quo wins by default.</source>
          <target state="translated">如果所有解决某个问题的建议都被否决,那么现状就会自动胜出。</target>
        </trans-unit>
        <trans-unit id="eab8ea3dfbb5bbbb71e7908ef2deef22ffee42c7" translate="yes" xml:space="preserve">
          <source>If all the arrays are 1-D, &lt;a href=&quot;#numpy.where&quot;&gt;&lt;code&gt;where&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="translated">如果所有的阵列是1-d，&lt;a href=&quot;#numpy.where&quot;&gt; &lt;code&gt;where&lt;/code&gt; &lt;/a&gt;等效于：</target>
        </trans-unit>
        <trans-unit id="4680fc5e031229cdb3ef2e322dccd91736ba09de" translate="yes" xml:space="preserve">
          <source>If all values are masked, return None. Otherwise, return a list of two tuples, corresponding to the indices of the first and last unmasked values respectively.</source>
          <target state="translated">如果所有的值都被屏蔽了,返回None。否则,返回两个元组的列表,分别对应第一个和最后一个未屏蔽值的索引。</target>
        </trans-unit>
        <trans-unit id="517ad1e00b3a93fbecfebfae5c6590d4c6fe64a9" translate="yes" xml:space="preserve">
          <source>If an argument has no &lt;code&gt;&amp;lt;argument type declaration&amp;gt;&lt;/code&gt;, its type is determined by applying &lt;code&gt;implicit&lt;/code&gt; rules to its name.</source>
          <target state="translated">如果参数没有 &lt;code&gt;&amp;lt;argument type declaration&amp;gt;&lt;/code&gt; ，则通过对其名称应用 &lt;code&gt;implicit&lt;/code&gt; 规则来确定其类型。</target>
        </trans-unit>
        <trans-unit id="2edcb18bec5f7aa2d4bb57f912992d616edce150" translate="yes" xml:space="preserve">
          <source>If an array does not own its memory, then its &lt;a href=&quot;reference/generated/numpy.ndarray.base&quot;&gt;base&lt;/a&gt; attribute returns the object whose memory the array is referencing. That object may be referencing the memory from still another object, so the owning object may be &lt;code&gt;a.base.base.base...&lt;/code&gt;. Some writers erroneously claim that testing &lt;code&gt;base&lt;/code&gt; determines if arrays are &lt;a href=&quot;#term-view&quot;&gt;view&lt;/a&gt;s. For the correct way, see &lt;a href=&quot;reference/generated/numpy.shares_memory#numpy.shares_memory&quot;&gt;&lt;code&gt;numpy.shares_memory&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果数组不拥有其内存，则其&lt;a href=&quot;reference/generated/numpy.ndarray.base&quot;&gt;基本&lt;/a&gt;属性将返回该数组正在引用其内存的对象。这个对象可能会从另一个对象引用的内存，所以拥有对象可能是 &lt;code&gt;a.base.base.base...&lt;/code&gt; 。一些作者错误地声称测试 &lt;code&gt;base&lt;/code&gt; 确定数组是否为&lt;a href=&quot;#term-view&quot;&gt;view&lt;/a&gt;。有关正确的方法，请参见&lt;a href=&quot;reference/generated/numpy.shares_memory#numpy.shares_memory&quot;&gt; &lt;code&gt;numpy.shares_memory&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a0b2100814d2bab89059c0f2bc3adff904ee9a6" translate="yes" xml:space="preserve">
          <source>If an array has a very small or very large determinant, then a call to &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt; may overflow or underflow. This routine is more robust against such issues, because it computes the logarithm of the determinant rather than the determinant itself.</source>
          <target state="translated">如果数组的行列式很小或很大，则对&lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;的调用可能会溢出或下溢。此例程针对此类问题更健壮，因为它计算行列式的对数，而不是行列式本身。</target>
        </trans-unit>
        <trans-unit id="089dc283ee6bf525b9e1357cb2890636154add48" translate="yes" xml:space="preserve">
          <source>If an array has no elements (&lt;code&gt;self.size == 0&lt;/code&gt;) there is no legal index and the strides are never used. Any array with no elements may be considered C-style and Fortran-style contiguous.</source>
          <target state="translated">如果数组没有元素（ &lt;code&gt;self.size == 0&lt;/code&gt; ），则没有合法索引，并且不会使用步幅。没有元素的任何数组都可以视为C样式和Fortran样式的连续数组。</target>
        </trans-unit>
        <trans-unit id="c5c598efb3988281532c1be87569879df34d1935" translate="yes" xml:space="preserve">
          <source>If an array is created using a data-type describing a sub-array, the dimensions of the sub-array are appended to the shape of the array when the array is created. Sub-arrays in a field of a structured type behave differently, see &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;Field Access&lt;/a&gt;.</source>
          <target state="translated">如果使用描述子数组的数据类型创建数组，则在创建数组时会将子数组的尺寸附加到数组的形状上。结构化类型的字段中的子数组的行为不同，请参见&lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;Field Access&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bf36df6b09764d99c53b04e05c8fe53411949d03" translate="yes" xml:space="preserve">
          <source>If an array is created with this method, simply adding &amp;lsquo;itemsize&amp;rsquo; for each iteration will traverse the new array matching the iterator.</source>
          <target state="translated">如果使用此方法创建数组，则只需为每次迭代添加&amp;ldquo; itemsize&amp;rdquo;，将遍历与迭代器匹配的新数组。</target>
        </trans-unit>
        <trans-unit id="1497d51c68c81f921994ed240661dbb7879d05a8" translate="yes" xml:space="preserve">
          <source>If an array is too large to be printed, NumPy automatically skips the central part of the array and only prints the corners:</source>
          <target state="translated">如果一个数组太大,无法打印,NumPy会自动跳过数组的中心部分,只打印角落。</target>
        </trans-unit>
        <trans-unit id="5e8325ebccad64f5436323a863f272d5f091c76c" translate="yes" xml:space="preserve">
          <source>If an element of &lt;code&gt;axes&lt;/code&gt; is larger than than the number of axes of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;axes&lt;/code&gt; 的元素大于 &lt;code&gt;a&lt;/code&gt; 的轴数。</target>
        </trans-unit>
        <trans-unit id="bc51d7d23e7dc12f32f8e1785a950a943342d4c8" translate="yes" xml:space="preserve">
          <source>If an index exceeds the dimension of the array along &lt;code&gt;axis&lt;/code&gt;, an empty sub-array is returned correspondingly.</source>
          <target state="translated">如果索引沿 &lt;code&gt;axis&lt;/code&gt; 超出数组的维数，则将相应返回一个空的子数组。</target>
        </trans-unit>
        <trans-unit id="d50315439445c5e53d7c5cb2eca5a37deb22722b" translate="yes" xml:space="preserve">
          <source>If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the &lt;a href=&quot;../glossary#term-ufunc&quot;&gt;ufunc&lt;/a&gt; will simply not step along that dimension (the &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;stride&lt;/a&gt; will be 0 for that dimension).</source>
          <target state="translated">如果输入形状的尺寸大小为1，则该尺寸中的第一个数据条目将用于沿该尺寸的所有计算。换句话说，&lt;a href=&quot;../glossary#term-ufunc&quot;&gt;ufunc&lt;/a&gt;的步进机械将根本不会沿该尺寸步进（该尺寸的&lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;跨度&lt;/a&gt;将为0）。</target>
        </trans-unit>
        <trans-unit id="99fec5dbaf9a5723fb1db21784554641e2d086b8" translate="yes" xml:space="preserve">
          <source>If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; will simply not step along that dimension (the &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;stride&lt;/a&gt; will be 0 for that dimension).</source>
          <target state="translated">如果输入形状的尺寸大小为1，则该尺寸中的第一个数据条目将用于沿该尺寸的所有计算。换句话说，&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt;的步进机械将根本不会沿该尺寸步进（该尺寸的&lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;跨度&lt;/a&gt;将为0）。</target>
        </trans-unit>
        <trans-unit id="981216fcb80286728db3aa0467d4b1e8a655fef5" translate="yes" xml:space="preserve">
          <source>If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if a were np.arange(a)</source>
          <target state="translated">如果是ndarray,则从它的元素中产生一个随机样本。如果是一个int,随机样本的产生就像np.arrange(a)一样。</target>
        </trans-unit>
        <trans-unit id="6bcff738f855376346fed2a54471feef4ca0479d" translate="yes" xml:space="preserve">
          <source>If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated from np.arange(a).</source>
          <target state="translated">如果是ndarray,则从它的元素中产生一个随机样本。如果是int,则从np.arrange(a)中产生随机样本。</target>
        </trans-unit>
        <trans-unit id="b055403a11a75cdadf358d2e4b16e4aaac100a0a" translate="yes" xml:space="preserve">
          <source>If an object is provided, its write method should take one argument, a string.</source>
          <target state="translated">如果提供了一个对象,它的写方法应该接受一个参数,一个字符串。</target>
        </trans-unit>
        <trans-unit id="c6eb2fb826e8cbc6182574444dd579783c5b9225" translate="yes" xml:space="preserve">
          <source>If any input is array_like, &lt;code&gt;pv&lt;/code&gt; returns an array of equal shape. Let&amp;rsquo;s compare different interest rates in the example above:</source>
          <target state="translated">如果有任何输入类似于array_like，则 &lt;code&gt;pv&lt;/code&gt; 返回形状相同的数组。让我们在上面的示例中比较不同的利率：</target>
        </trans-unit>
        <trans-unit id="ffa8ae9c8e4ca204b853aaf38ee0943c2276d1c9" translate="yes" xml:space="preserve">
          <source>If any input is array_like, returns an array of equal shape. Let&amp;rsquo;s compare different interest rates from the example above.</source>
          <target state="translated">如果有任何输入为array_like，则返回形状相同的数组。让我们比较上面示例中的不同利率。</target>
        </trans-unit>
        <trans-unit id="dce7db3f12e1e92b36fcbe9af677f929557b423e" translate="yes" xml:space="preserve">
          <source>If any read/write overlap exists, this flag ensures the result of the operation is the same as if all operands were copied. In cases where copies would need to be made, &lt;strong&gt;the result of the computation may be undefined without this flag!&lt;/strong&gt;</source>
          <target state="translated">如果存在任何读/写重叠，则此标志确保操作结果与复制所有操作数相同。在需要复制的情况下，如果&lt;strong&gt;没有该标志，则计算结果可能不确定！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e0c40f81e19502941982ef1a412a173673233b4" translate="yes" xml:space="preserve">
          <source>If any value in &lt;code&gt;alpha&lt;/code&gt; is less than or equal to zero</source>
          <target state="translated">如果 &lt;code&gt;alpha&lt;/code&gt; 中的任何值小于或等于零</target>
        </trans-unit>
        <trans-unit id="5a8f0d595ba6a3701f0ba4d0bf45fa3cd44ca9ce" translate="yes" xml:space="preserve">
          <source>If any value in alpha is less than or equal to zero</source>
          <target state="translated">如果alpha中的任何数值小于或等于零</target>
        </trans-unit>
        <trans-unit id="bc219d3a8300527c6efa92537ff8d0dcdb1108df" translate="yes" xml:space="preserve">
          <source>If any write operand has overlap with any read operand, eliminate all overlap by making temporary copies (enabling UPDATEIFCOPY for write operands, if necessary). A pair of operands has overlap if there is a memory address that contains data common to both arrays.</source>
          <target state="translated">如果任何写操作数与任何读操作数有重叠,则通过制作临时副本来消除所有重叠(必要时为写操作数启用UPDATEIFCOPY)。如果有一个内存地址包含两个数组共同的数据,则一对操作数有重叠。</target>
        </trans-unit>
        <trans-unit id="2a45557faccf378e4b524258e3744f14e01d0549" translate="yes" xml:space="preserve">
          <source>If argument consists exclusively of int dtypes.</source>
          <target state="translated">如果参数完全由int dtypes组成。</target>
        </trans-unit>
        <trans-unit id="c785d849c18fc327cf9bee37bc11741d006f8fa7" translate="yes" xml:space="preserve">
          <source>If arguments are passed in with no keywords, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file, are &amp;lsquo;arr_0&amp;rsquo;, &amp;lsquo;arr_1&amp;rsquo;, etc. If keyword arguments are given, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file will match the keyword names.</source>
          <target state="translated">如果传入的参数没有关键字，则 &lt;code&gt;.npz&lt;/code&gt; 文件中的相应变量名称为'arr_0'，'arr_1'等。如果给出了关键字参数，则 &lt;code&gt;.npz&lt;/code&gt; 文件中的相应变量名称将与关键字名称。</target>
        </trans-unit>
        <trans-unit id="3d1c7a0f1e977aad5bcdfcdc2989a2f748b0274f" translate="yes" xml:space="preserve">
          <source>If array_like, the bin edges for the two dimensions (x_edges=y_edges=bins).</source>
          <target state="translated">如果是array_like,则是两个维度的bin边(x_edges=y_edges=bins)。</target>
        </trans-unit>
        <trans-unit id="8ad413f7fc8dfff3a6c2ee36c2613993e6279848" translate="yes" xml:space="preserve">
          <source>If at least one of &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is a non-string array</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt; 中的至少一个是非字符串数组</target>
        </trans-unit>
        <trans-unit id="b3c56f840baa3a689fec388e92d6ba86ff952aa7" translate="yes" xml:space="preserve">
          <source>If at some point an existing Institutional Partner stops having any contributing employees, then a one year grace period commences. If at the end of this one year period they continue not to have any contributing employees, then their Institutional Partnership will lapse, and resuming it will require going through the normal process for new Partnerships.</source>
          <target state="translated">如果现有的机构伙伴在某一时刻不再有任何缴款雇员,那么一年的宽限期就开始了。如果在这一年宽限期结束时,他们仍然没有任何缴款雇员,那么他们的机构合作伙伴关系就会失效,要恢复这种关系,就必须通过新合作伙伴关系的正常程序。</target>
        </trans-unit>
        <trans-unit id="8a90d0b3d22bdc0f93b285a7398aa4703fe73214" translate="yes" xml:space="preserve">
          <source>If axis is 0, only rows are suppressed.</source>
          <target state="translated">如果轴为0,则只压制行。</target>
        </trans-unit>
        <trans-unit id="0782bc28993b5f00e72a0af1dcec69356d31839c" translate="yes" xml:space="preserve">
          <source>If axis is 1 or -1, only columns are suppressed.</source>
          <target state="translated">如果轴为1或-1,则只压制列。</target>
        </trans-unit>
        <trans-unit id="9506a7c18a807c059cd952ed93d5c51207a2a07d" translate="yes" xml:space="preserve">
          <source>If axis is None, both rows and columns are suppressed.</source>
          <target state="translated">如果轴为None,则行和列都被压制。</target>
        </trans-unit>
        <trans-unit id="c5149a1f08013bd4c50d9514785f4f44208d1f0b" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a product is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">如果 axis 是一个 ints 的元组,则在元组中指定的所有轴上执行乘积,而不是像之前那样在单个轴或所有轴上执行乘积。</target>
        </trans-unit>
        <trans-unit id="8de953aea1cde5c7cd7a932c7c1cd638dd5b48f8" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">如果 axis 是一个 ints 的元组,则在元组中指定的所有轴上进行求和,而不是像之前那样对单个轴或所有轴进行求和。</target>
        </trans-unit>
        <trans-unit id="b7d9ad0b67d074ec073be5ef4e15eeecb68acdae" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, averaging is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">如果 axis 是 ints 的元组,则对元组中指定的所有轴进行平均,而不是像之前那样对单个轴或所有轴进行平均。</target>
        </trans-unit>
        <trans-unit id="288d1e6c0a612db41ca8d2410d35c52a79ba7795" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, flipping is performed on all of the axes specified in the tuple.</source>
          <target state="translated">如果 axis 是 ints 的元组,则在元组中指定的所有轴上进行翻转。</target>
        </trans-unit>
        <trans-unit id="4a67a427d1a7cbcfc229fb55b05bdd5b239d1bd3" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 1-D arrays, it is inner product of vectors (without complex conjugation).</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 都是一维数组，则它是向量的内积（无复共轭）。</target>
        </trans-unit>
        <trans-unit id="c28be53ff292bd7a51506b92f27ed7a94fd2ec15" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2-D arrays, it is matrix multiplication, but using &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;matmul&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;a @ b&lt;/code&gt; is preferred.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 均为二维数组，则为矩阵乘法，但最好使用&lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;matmul&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;a @ b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76c96acc4a781ea364ff42aad287e5f7651eee5d" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;formats&lt;/code&gt; and &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="translated">如果这两个 &lt;code&gt;formats&lt;/code&gt; 和&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;为无，那么这将自动检测格式。使用元组列表而不是列表列表可以加快处理速度。</target>
        </trans-unit>
        <trans-unit id="194f3cee9e7df2b602bf5ba80d6118fb502e2eaf" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;formats&lt;/code&gt; and &lt;code&gt;dtype&lt;/code&gt; are None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="translated">如果这两个 &lt;code&gt;formats&lt;/code&gt; 和 &lt;code&gt;dtype&lt;/code&gt; 为无，那么这将自动检测格式。使用元组列表而不是列表列表可以加快处理速度。</target>
        </trans-unit>
        <trans-unit id="368fd1e825cc7f1439018ab086e3ca74379697e1" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;code&gt;NULL&lt;/code&gt;, then return &lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt;&lt;code&gt;PyArray_Nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;condition&lt;/em&gt;). Otherwise, both &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; must be given and the object returned is shaped like &lt;em&gt;condition&lt;/em&gt; and has elements of &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; where &lt;em&gt;condition&lt;/em&gt; is respectively True or False.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 均为 &lt;code&gt;NULL&lt;/code&gt; ，则返回&lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt; &lt;code&gt;PyArray_Nonzero&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;condition&lt;/em&gt;）。否则，必须同时给出&lt;em&gt;x&lt;/em&gt;和&lt;em&gt;y，&lt;/em&gt;并且返回的对象的形状类似于&lt;em&gt;condition&lt;/em&gt;并具有&lt;em&gt;x&lt;/em&gt;和&lt;em&gt;y的&lt;/em&gt;元素，其中&lt;em&gt;condition&lt;/em&gt;分别为True或False。</target>
        </trans-unit>
        <trans-unit id="7d34c61041bcc07e55093729fc859031c36d6999" translate="yes" xml:space="preserve">
          <source>If both arguments are 2-D they are multiplied like conventional matrices.</source>
          <target state="translated">如果两个参数都是二维的,它们就会像传统的矩阵一样相乘。</target>
        </trans-unit>
        <trans-unit id="bf26496158ed7aff00fe3f64e66aa6a508289463" translate="yes" xml:space="preserve">
          <source>If both positive and negative infinity are present, the sum will be Not A Number (NaN).</source>
          <target state="translated">如果同时存在正数和负数的无穷大,那么总和将是Not A数(NaN)。</target>
        </trans-unit>
        <trans-unit id="c6be65ffe7d2b7c519b021c7a585a65d749c5cc8" translate="yes" xml:space="preserve">
          <source>If both the name and type are specified, the &lt;strong&gt;Returns&lt;/strong&gt; section takes the same form as the &lt;strong&gt;Parameters&lt;/strong&gt; section:</source>
          <target state="translated">如果同时指定了名称和类型，则&amp;ldquo;&lt;strong&gt;返回&amp;rdquo;&lt;/strong&gt;部分的形式与&amp;ldquo;&lt;strong&gt;参数&amp;rdquo;&lt;/strong&gt;部分的形式相同：</target>
        </trans-unit>
        <trans-unit id="10140359cb73a0890a92d9b94e958a4d9feb7bea" translate="yes" xml:space="preserve">
          <source>If both the name and type are specified, the &lt;strong&gt;Yields&lt;/strong&gt; section takes the same form as the &lt;strong&gt;Returns&lt;/strong&gt; section:</source>
          <target state="translated">如果同时指定了名称和类型，则&lt;strong&gt;Yields&lt;/strong&gt;部分采用与&lt;strong&gt;Returns&lt;/strong&gt;部分相同的形式：</target>
        </trans-unit>
        <trans-unit id="4d89fb74ad22e53fe87d261e5d40a2d4a0331e92" translate="yes" xml:space="preserve">
          <source>If called with all arguments other than the warning class omitted, may be used as a context manager:</source>
          <target state="translated">如果调用时省略了除警告类以外的所有参数,可以作为上下文管理器使用。</target>
        </trans-unit>
        <trans-unit id="e1f9fb2b578de1420ef1d4182da3c75ca58e3552" translate="yes" xml:space="preserve">
          <source>If complex input returns a real array if complex parts are close to zero.</source>
          <target state="translated">如果复杂的输入部分接近于零,则返回一个实数组。</target>
        </trans-unit>
        <trans-unit id="4ec7acf826794e4e37207136e102eb50e7632b5f" translate="yes" xml:space="preserve">
          <source>If computation does not converge.</source>
          <target state="translated">如果计算不收敛。</target>
        </trans-unit>
        <trans-unit id="66501fc9abcadb23835ebb60ef928268453bb410" translate="yes" xml:space="preserve">
          <source>If condition is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, missing values are considered as &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">如果condition为&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;，则将缺少的值视为 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bd71f3d3293e73ba78bbdd8102f9b41323ceaaa" translate="yes" xml:space="preserve">
          <source>If copy is False and one of the inputs is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;, return a view of the other input mask. Defaults to False.</source>
          <target state="translated">如果copy为False并且输入之一为&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;，则返回另一个输入掩码的视图。默认为False。</target>
        </trans-unit>
        <trans-unit id="6d1cb15d43c2ba3971e5b54fc0a9bc261de3fb39" translate="yes" xml:space="preserve">
          <source>If data is passed to &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.PyArray_New&quot;&gt;&lt;code&gt;PyArray_New&lt;/code&gt;&lt;/a&gt;, this memory must not be deallocated until the new array is deleted. If this data came from another Python object, this can be accomplished using &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; on that object and setting the base member of the new array to point to that object. If strides are passed in they must be consistent with the dimensions, the itemsize, and the data of the array.</source>
          <target state="translated">如果将数据传递给&lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#c.PyArray_New&quot;&gt; &lt;code&gt;PyArray_New&lt;/code&gt; &lt;/a&gt;，则在删除新数组之前，不得释放该内存。如果此数据来自另一个Python对象，则可以使用该对象上的&lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt;并将新数组的基本成员设置为指向该对象来实现。如果传递了步幅，则步幅必须与维度，项目大小和数组数据一致。</target>
        </trans-unit>
        <trans-unit id="8cd71bec9bf23486f57ed709deb2da7e823cdd37" translate="yes" xml:space="preserve">
          <source>If defined, the axis of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; that defines the vector(s) and cross product(s). Overrides &lt;code&gt;axisa&lt;/code&gt;, &lt;code&gt;axisb&lt;/code&gt; and &lt;code&gt;axisc&lt;/code&gt;.</source>
          <target state="translated">如果定义，则定义矢量和叉积的 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 轴。覆盖 &lt;code&gt;axisa&lt;/code&gt; ， &lt;code&gt;axisb&lt;/code&gt; 和 &lt;code&gt;axisc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13711ea532b05dfaebf7f20551317865f1c997fe" translate="yes" xml:space="preserve">
          <source>If dtype is not supplied, this specifies the field names for the output dtype, in order. The field dtypes will be the same as the input array.</source>
          <target state="translated">如果没有提供dtype,则按顺序指定输出dtype的字段名。字段dtypes将与输入数组相同。</target>
        </trans-unit>
        <trans-unit id="1d0ca2bca36fd3ca611fb59e9f429be6ca1dfcef" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is 0-D (scalar), it is equivalent to &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;multiply&lt;/code&gt;&lt;/a&gt; and using &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; or &lt;code&gt;a * b&lt;/code&gt; is preferred.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt; 为0-D（标量），则等效于&lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;multiply&lt;/code&gt; &lt;/a&gt;并且最好使用 &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; 或 &lt;code&gt;a * b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="849e7230439a12b395b3d9d948e074f889418b25" translate="yes" xml:space="preserve">
          <source>If either argument is N-D, N &amp;gt; 2, it is treated as a stack of matrices residing in the last two indexes and broadcast accordingly.</source>
          <target state="translated">如果任何一个参数为ND，N&amp;gt; 2，则将其视为驻留在最后两个索引中的一组矩阵，并进行相应广播。</target>
        </trans-unit>
        <trans-unit id="cc8e18e241d0267fb4cce88d0332bc823b722b5a" translate="yes" xml:space="preserve">
          <source>If either array contains one or more NaNs, False is returned. Infs are treated as equal if they are in the same place and of the same sign in both arrays.</source>
          <target state="translated">如果任何一个数组包含一个或多个NaNs,则返回False。如果两个数组中的Infs在同一位置且符号相同,则被视为相等。</target>
        </trans-unit>
        <trans-unit id="281de8e5c6dae1e0aea9ae6d89d002bae88a2963" translate="yes" xml:space="preserve">
          <source>If element has complex type with zero complex part, the return value for that element is True.</source>
          <target state="translated">如果元素的复杂类型为零,则该元素的返回值为True。</target>
        </trans-unit>
        <trans-unit id="5d17dff94d5eaef97820ea5c6ea029508947d3b9" translate="yes" xml:space="preserve">
          <source>If factoring fails.</source>
          <target state="translated">如果保理失败。</target>
        </trans-unit>
        <trans-unit id="d31081e35606566d9542bf752ae043c7bb856921" translate="yes" xml:space="preserve">
          <source>If file is a string or a path-like object then that file is opened, else it is assumed to be a file object. The file object must support random access (i.e. it must have tell and seek methods).</source>
          <target state="translated">如果文件是一个字符串或类似路径的对象,那么该文件就会被打开,否则就会被认为是一个文件对象。文件对象必须支持随机访问(即它必须有告诉和寻找方法)。</target>
        </trans-unit>
        <trans-unit id="c92c0b980c98427841fd06fc2e90c17e3f8c8cf4" translate="yes" xml:space="preserve">
          <source>If filters are added and the &lt;code&gt;module&lt;/code&gt; keyword is given, the warning registry of this module will additionally be cleared when applying it, entering the context, or exiting it. This could cause warnings to appear a second time after leaving the context if they were configured to be printed once (default) and were already printed before the context was entered.</source>
          <target state="translated">如果添加了过滤器并指定了 &lt;code&gt;module&lt;/code&gt; 关键字，则在应用，进入上下文或退出该模块时，还将清除该模块的警告注册表。如果警告被配置为打印一次（默认）并且在进入上下文之前已经被打印，则警告可能会在离开上下文后第二次出现。</target>
        </trans-unit>
        <trans-unit id="aa86a09a4bd6f04a9393e4d4dd4d45d0b7a047d8" translate="yes" xml:space="preserve">
          <source>If formats is None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="translated">如果 formats 为 None,则会自动检测格式。使用tuples列表而不是list列表来加快处理速度。</target>
        </trans-unit>
        <trans-unit id="e7cf286f1082970c195a5ac9a9af060a6972f46c" translate="yes" xml:space="preserve">
          <source>If given and not &lt;code&gt;False&lt;/code&gt;, return not just the estimate but also its covariance matrix. By default, the covariance are scaled by chi2/dof, where dof = M - (deg + 1), i.e., the weights are presumed to be unreliable except in a relative sense and everything is scaled such that the reduced chi2 is unity. This scaling is omitted if &lt;code&gt;cov='unscaled'&lt;/code&gt;, as is relevant for the case that the weights are 1/sigma**2, with sigma known to be a reliable estimate of the uncertainty.</source>
          <target state="translated">如果给定且不为 &lt;code&gt;False&lt;/code&gt; ，则不仅返回估计值，还返回其协方差矩阵。默认情况下，协方差按chi2 / dof进行缩放，其中dof = M-（deg + 1），即，除相对意义外，假定权重不可靠，并且按比例缩放所有内容，以使减少的chi2统一。如果 &lt;code&gt;cov='unscaled'&lt;/code&gt; ，则忽略此缩放，这与权重为1 / sigma ** 2的情况相关，其中sigma是对不确定性的可靠估计。</target>
        </trans-unit>
        <trans-unit id="9c65522b5d0c56fc6284329915c9ff282e0a064e" translate="yes" xml:space="preserve">
          <source>If given and not &lt;code&gt;False&lt;/code&gt;, return not just the estimate but also its covariance matrix. By default, the covariance are scaled by chi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable except in a relative sense and everything is scaled such that the reduced chi2 is unity. This scaling is omitted if &lt;code&gt;cov='unscaled'&lt;/code&gt;, as is relevant for the case that the weights are 1/sigma**2, with sigma known to be a reliable estimate of the uncertainty.</source>
          <target state="translated">如果给出且不为 &lt;code&gt;False&lt;/code&gt; ，则不仅返回估计值，还返回其协方差矩阵。默认情况下，协方差按chi2 / sqrt（N-dof）进行缩放，即，权重假定为相对可靠（除非相对），并且所有内容均按比例缩放，以使减少的chi2统一。如果 &lt;code&gt;cov='unscaled'&lt;/code&gt; ，则忽略此缩放，这与权重为1 / sigma ** 2的情况有关，已知sigma是不确定性的可靠估计。</target>
        </trans-unit>
        <trans-unit id="4a01bcc692f66d3a6d58bd9dd10d9c51e6240bfa" translate="yes" xml:space="preserve">
          <source>If given, any string of the form &lt;code&gt;@key@&lt;/code&gt; will be replaced by &lt;code&gt;subst_dict[key]&lt;/code&gt; in the template file when installed. The install prefix is always available through the variable &lt;code&gt;@prefix@&lt;/code&gt;, since the install prefix is not easy to get reliably from setup.py.</source>
          <target state="translated">如果已提供，则在安装时，模板文件中所有格式为 &lt;code&gt;@key@&lt;/code&gt; 字符串都将替换为 &lt;code&gt;subst_dict[key]&lt;/code&gt; 。安装前缀始终可以通过变量 &lt;code&gt;@prefix@&lt;/code&gt; 来获得，因为从setup.py中很难轻易获得安装前缀。</target>
        </trans-unit>
        <trans-unit id="f229986316849fc58c19699184e093af0322102f" translate="yes" xml:space="preserve">
          <source>If given, should be a sequence of additional directories where to look for npy-pkg-config files. Those directories are searched prior to the NumPy directory.</source>
          <target state="translated">如果给定的话,应该是一系列寻找 npy-pkg-config 文件的附加目录。这些目录会在 NumPy 目录之前进行搜索。</target>
        </trans-unit>
        <trans-unit id="282b0a219b18c48a317e72503d2100cde36f84f8" translate="yes" xml:space="preserve">
          <source>If given, the array must be of the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the domain. If None is given then the class domain is used. The default is None.</source>
          <target state="translated">如果给定，则数组的格式必须为 &lt;code&gt;[beg, end]&lt;/code&gt; ，其中 &lt;code&gt;beg&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 是域的端点。如果没有给出，则使用类域。默认为无。</target>
        </trans-unit>
        <trans-unit id="0dd507ea0f76e3b5e94e32d9b92c028c04854d11" translate="yes" xml:space="preserve">
          <source>If given, the resulting array must be if the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the window. If None is given then the class window is used. The default is None.</source>
          <target state="translated">如果给定，则结果数组必须为 &lt;code&gt;[beg, end]&lt;/code&gt; 形式，其中 &lt;code&gt;beg&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 是窗口的端点。如果没有给出，则使用类窗口。默认为无。</target>
        </trans-unit>
        <trans-unit id="d16d5189bfa0fff58db67c1477d4b5ae0a2a03f6" translate="yes" xml:space="preserve">
          <source>If given, this is returned for objects whose types can not be determined. If not given, None is returned for those objects.</source>
          <target state="translated">如果给定,对于那些类型无法确定的对象,将返回None。如果不给定,则对这些对象返回None。</target>
        </trans-unit>
        <trans-unit id="a5160dd116d677ef1f0e36c955a207aad3b93f5a" translate="yes" xml:space="preserve">
          <source>If given, this is the destinaton of the shuffled array. If &lt;code&gt;out&lt;/code&gt; is None, a shuffled copy of the array is returned.</source>
          <target state="translated">如果给出的话，这就是改组后的数组的目的地。如果 &lt;code&gt;out&lt;/code&gt; 为None，则返回数组的随机组合副本。</target>
        </trans-unit>
        <trans-unit id="4c9471fb7a9f3abaf682e7276b2ee9a3f16f1ed9" translate="yes" xml:space="preserve">
          <source>If input array &lt;code&gt;a&lt;/code&gt; is not 2D.</source>
          <target state="translated">如果输入数组 &lt;code&gt;a&lt;/code&gt; 不是2D。</target>
        </trans-unit>
        <trans-unit id="03697161ee2c8ff90aa05356bdc85cfdd7ffe30e" translate="yes" xml:space="preserve">
          <source>If input is complex with all imaginary parts close to zero, return real parts.</source>
          <target state="translated">如果输入是复杂的,所有虚部都接近于零,则返回实部。</target>
        </trans-unit>
        <trans-unit id="f96f22e66784df0c0e7c7e7a77f909c0ac407de2" translate="yes" xml:space="preserve">
          <source>If input is the wrong shape (the input must be a 1-D or square 2-D array).</source>
          <target state="translated">如果输入是错误的形状(输入必须是一维或二维正方形阵列)。</target>
        </trans-unit>
        <trans-unit id="c9a78f52b99ab1c1f8aad79c5f4b73ab06b85a94" translate="yes" xml:space="preserve">
          <source>If instead, we replace our &lt;code&gt;super&lt;/code&gt; call with &lt;code&gt;getattr(ufunc, method)&lt;/code&gt;, we effectively do &lt;code&gt;np.add(a.view(np.ndarray), b)&lt;/code&gt;. Again, &lt;code&gt;B.__array_ufunc__&lt;/code&gt; will be called, but now it sees an &lt;code&gt;ndarray&lt;/code&gt; as the other argument. Likely, it will know how to handle this, and return a new instance of the &lt;code&gt;B&lt;/code&gt; class to us. Our example class is not set up to handle this, but it might well be the best approach if, e.g., one were to re-implement &lt;code&gt;MaskedArray&lt;/code&gt; using &lt;code&gt;__array_ufunc__&lt;/code&gt;.</source>
          <target state="translated">如果相反，我们用 &lt;code&gt;getattr(ufunc, method)&lt;/code&gt; 替换我们的 &lt;code&gt;super&lt;/code&gt; 调用，就可以有效地执行 &lt;code&gt;np.add(a.view(np.ndarray), b)&lt;/code&gt; 。同样，将调用 &lt;code&gt;B.__array_ufunc__&lt;/code&gt; ，但是现在它将 &lt;code&gt;ndarray&lt;/code&gt; 视为另一个参数。可能，它将知道如何处理此问题，并将 &lt;code&gt;B&lt;/code&gt; 类的新实例返回给我们。我们的例子类不成立处理这个问题，但它很可能是最好的办法，如果，例如，一个人要重新实现 &lt;code&gt;MaskedArray&lt;/code&gt; 使用 &lt;code&gt;__array_ufunc__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="570a12b7ce63be7a2ce71fba3d8c9da77deb9d9d" translate="yes" xml:space="preserve">
          <source>If int, the number of bins for the two dimensions (nx=ny=bins).</source>
          <target state="translated">如果是int,则为两个维度的仓数(nx=ny=仓)。</target>
        </trans-unit>
        <trans-unit id="f4fb4d5bcb48df147e2cef0a0ea5928ac8067b9e" translate="yes" xml:space="preserve">
          <source>If it becomes necessary for the Steering Council to produce a formal decision, then they will use a form of the &lt;a href=&quot;https://www.apache.org/foundation/voting.html&quot;&gt;Apache Foundation voting process&lt;/a&gt;. This is a formalized version of consensus, in which +1 votes indicate agreement, -1 votes are vetoes (and must be accompanied with a rationale, as above), and one can also vote fractionally (e.g. -0.5, +0.5) if one wishes to express an opinion without registering a full veto. These numeric votes are also often used informally as a way of getting a general sense of people&amp;rsquo;s feelings on some issue, and should not normally be taken as formal votes. A formal vote only occurs if explicitly declared, and if this does occur then the vote should be held open for long enough to give all interested Council Members a chance to respond &amp;ndash; at least one week.</source>
          <target state="translated">如果指导委员会有必要做出正式决定，则他们将使用&lt;a href=&quot;https://www.apache.org/foundation/voting.html&quot;&gt;Apache Foundation投票程序的&lt;/a&gt;一种形式。这是共识的形式化版本，其中+1票表示同意，-1票表示否决（如上所述，并且必须附有理由），如果有1票，也可以进行小数表决（例如-0.5，+ 0.5）希望发表意见而不注册全部否决权。这些数字投票通常也被非正式地用作在某些问题上获得人们的一般感觉的一种方式，通常不应被视为正式投票。正式表决只有在明确宣布后才进行，如果确实发生，则表决应进行足够长的时间，以使所有感兴趣的安理会成员都有机会做出回应-至少一周。</target>
        </trans-unit>
        <trans-unit id="46b4bbe660909db346ad59c7951f05bdd8332431" translate="yes" xml:space="preserve">
          <source>If it is necessary to explain a private method (use with care!), it can be referred to in the &lt;strong&gt;Extended Summary&lt;/strong&gt; or the &lt;strong&gt;Notes&lt;/strong&gt; section. Do not list private methods in the &lt;strong&gt;methods&lt;/strong&gt; section.</source>
          <target state="translated">如果有必要解释私有方法（谨慎使用！），请在&lt;strong&gt;扩展摘要&lt;/strong&gt;或&amp;ldquo;&lt;strong&gt;注释&amp;rdquo;&lt;/strong&gt;部分中进行引用。不要在&lt;strong&gt;方法&lt;/strong&gt;部分列出私有方法。</target>
        </trans-unit>
        <trans-unit id="c2941a8c3ef7e42aa1704dd826466efd7a289a13" translate="yes" xml:space="preserve">
          <source>If it is not necessary to specify a keyword argument, use &lt;code&gt;optional&lt;/code&gt;:</source>
          <target state="translated">如果没有必要指定关键字参数，请使用 &lt;code&gt;optional&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="14206cf495608dab3bc0c9563f466018da9e1b11" translate="yes" xml:space="preserve">
          <source>If it went wrong, recovery is again possible as explained &lt;a href=&quot;#recovering-from-mess-up&quot;&gt;above&lt;/a&gt;.</source>
          <target state="translated">如果出了问题，则&lt;a href=&quot;#recovering-from-mess-up&quot;&gt;如上所述&lt;/a&gt;可以再次进行恢复。</target>
        </trans-unit>
        <trans-unit id="3a1bd74933e0b346982972b3334dd2af53c8b3cb" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, then filenames are taken from the keywords. If arguments are passed in with no keywords, then stored file names are arr_0, arr_1, etc.</source>
          <target state="translated">如果给了关键字参数,那么文件名就取自关键字。如果传入的参数没有关键字,那么存储的文件名就是arr_0、arr_1等。</target>
        </trans-unit>
        <trans-unit id="a05e5457e182b0de28998599a17f81c2384bc52a" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, then filenames are taken from the keywords. If arguments are passed in with no keywords, then stored filenames are arr_0, arr_1, etc.</source>
          <target state="translated">如果给了关键字参数,那么文件名就取自关键字。如果传入的参数中没有关键字,那么存储的文件名是arr_0、arr_1等。</target>
        </trans-unit>
        <trans-unit id="68f5690b1b20b80392957d2cc602580121727a3e" translate="yes" xml:space="preserve">
          <source>If list depths are mismatched - for instance, &lt;code&gt;[[a, b], c]&lt;/code&gt; is illegal, and should be spelt &lt;code&gt;[[a, b], [c]]&lt;/code&gt;</source>
          <target state="translated">如果列表深度不匹配-例如 &lt;code&gt;[[a, b], c]&lt;/code&gt; 是非法的，应将其拼写为 &lt;code&gt;[[a, b], [c]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f609da24233a507af66f8b7969941dc9c31d8838" translate="yes" xml:space="preserve">
          <source>If lists are empty - for instance, &lt;code&gt;[[a, b], []]&lt;/code&gt;</source>
          <target state="translated">如果列表为空-例如 &lt;code&gt;[[a, b], []]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0fa6317253cb5f3105874e72d36c2e7ed1eb2af" translate="yes" xml:space="preserve">
          <source>If multi-dimension input, returns a new ndarray of indices to the minimum values along the given axis. Otherwise, returns a scalar of index to the minimum values along the given axis.</source>
          <target state="translated">如果是多维度的输入,返回一个新的ndarray的指数,沿给定轴的最小值。否则,返回沿给定轴的最小值的索引标量。</target>
        </trans-unit>
        <trans-unit id="3be2da634ae4e1a50b6a61b6e2a72b4b4858161d" translate="yes" xml:space="preserve">
          <source>If necessary, will be flattened before the differences are taken.</source>
          <target state="translated">如有必要,将在取差前进行平整。</target>
        </trans-unit>
        <trans-unit id="301925ec926932bb64f4f4002e984f88f86a2131" translate="yes" xml:space="preserve">
          <source>If needed create a new C-structure to handle each instance of your type. A typical C-structure would be:</source>
          <target state="translated">如果需要,创建一个新的C结构来处理你的类型的每个实例。一个典型的C结构是</target>
        </trans-unit>
        <trans-unit id="0a3c8652ca0e3dccf381651d80f187b5ac1a5a74" translate="yes" xml:space="preserve">
          <source>If neither is defined, the C-API is declared to be &lt;code&gt;static void**&lt;/code&gt;, so it is only visible within the compilation unit that #includes numpy/arrayobject.h.</source>
          <target state="translated">如果两个都没有定义，则C-API被声明为 &lt;code&gt;static void**&lt;/code&gt; ，因此它仅在#includes numpy / arrayobject.h的编译单元中可见。</target>
        </trans-unit>
        <trans-unit id="853b03d065feffbc6ac6731a7bbb396016c51c2b" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;__array_function__&lt;/code&gt; methods exists, NumPy will default to calling its own implementation, intended for use on NumPy arrays. This case arises, for example, when all array-like arguments are Python numbers or lists. (NumPy arrays do have a &lt;code&gt;__array_function__&lt;/code&gt; method, given below, but it always returns &lt;code&gt;NotImplemented&lt;/code&gt; if any argument other than a NumPy array subclass implements &lt;code&gt;__array_function__&lt;/code&gt;.)</source>
          <target state="translated">如果不存在 &lt;code&gt;__array_function__&lt;/code&gt; 方法，则NumPy将默认调用其自己的实现，该实现用于NumPy数组。例如，当所有类似数组的参数都是Python数字或列表时，就会出现这种情况。（NumPy数组确实具有 &lt;code&gt;__array_function__&lt;/code&gt; 方法，如下所示，但是如果NumPy数组子类以外的任何参数实现 &lt;code&gt;__array_function__&lt;/code&gt; ，则它始终返回 &lt;code&gt;NotImplemented&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="9e9935f1dd70f7a86b993ae6eeed6ce9464e1229" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;intent(in | inout | out | hide)&lt;/code&gt; is specified, &lt;code&gt;intent(in)&lt;/code&gt; is assumed.</source>
          <target state="translated">如果未指定 &lt;code&gt;intent(in | inout | out | hide)&lt;/code&gt; ，则假定为 &lt;code&gt;intent(in)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="505142361ce7d844b31c251e5147e86fce3849fd" translate="yes" xml:space="preserve">
          <source>If none of the inputs overrides the ufunc, then all output arrays will be passed to the &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; methods of the input (besides &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;, and scalars) that defines it &lt;strong&gt;and&lt;/strong&gt; has the highest &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of any other input to the universal function. The default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of the ndarray is 0.0, and the default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of a subtype is 0.0. Matrices have &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; equal to 10.0.</source>
          <target state="translated">如果没有输入覆盖ufunc，那么所有的输出阵列将被传递到&lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;输入的方法（除了&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;，和标量）定义它&lt;strong&gt;和&lt;/strong&gt;具有最高&lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;任何其他输入到通用的功能。默认&lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;的ndarray的是0.0，而默认&lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;亚型的是0.0。矩阵的&lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;等于10.0。</target>
        </trans-unit>
        <trans-unit id="96625db984c22cd52ed20b5b293895185469b2c4" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; normalization is by &lt;code&gt;(N - ddof)&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of observations; this overrides the value implied by &lt;code&gt;bias&lt;/code&gt;. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果不是 &lt;code&gt;None&lt;/code&gt; 正常化是通过 &lt;code&gt;(N - ddof)&lt;/code&gt; ，其中 &lt;code&gt;N&lt;/code&gt; 是观测数目; 这将覆盖由 &lt;code&gt;bias&lt;/code&gt; 隐含的值。默认值为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e98fcdb4d2a9bfdfbe2eeae9c39d82ef88da39fa" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; the default value implied by &lt;code&gt;bias&lt;/code&gt; is overridden. Note that &lt;code&gt;ddof=1&lt;/code&gt; will return the unbiased estimate, even if both &lt;code&gt;fweights&lt;/code&gt; and &lt;code&gt;aweights&lt;/code&gt; are specified, and &lt;code&gt;ddof=0&lt;/code&gt; will return the simple average. See the notes for the details. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果不是&amp;ldquo; &lt;code&gt;None&lt;/code&gt; 则将覆盖由 &lt;code&gt;bias&lt;/code&gt; 隐含的默认值。请注意，即使同时指定了 &lt;code&gt;fweights&lt;/code&gt; 和 &lt;code&gt;aweights&lt;/code&gt; ， &lt;code&gt;ddof=1&lt;/code&gt; 也将返回无偏估计，而 &lt;code&gt;ddof=0&lt;/code&gt; 将返回简单平均值。有关详细信息，请参见注释。默认值为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcf87e157fa41fe29ae78434e407f9e7ee68fcea" translate="yes" xml:space="preserve">
          <source>If not None, the keys should indicate the type(s) that the respective formatting function applies to. Callables should return a string. Types that are not specified (by their corresponding keys) are handled by the default formatters. Individual types for which a formatter can be set are:</source>
          <target state="translated">如果不是None,则键应表示各自的格式化函数所适用的类型。可调用函数应该返回一个字符串。未指定的类型(由其对应的键)由默认格式化器处理。可以设置格式化器的单个类型有:。</target>
        </trans-unit>
        <trans-unit id="bb477c8d5a32ba9dc9b4018fd2f3af6fa9009c49" translate="yes" xml:space="preserve">
          <source>If not None, the specified domain is used instead of that of the calling instance. It should be of the form &lt;code&gt;[beg,end]&lt;/code&gt;. The default is None which case the class domain is used.</source>
          <target state="translated">如果不是None，则使用指定的域而不是调用实例的域。它的形式应为 &lt;code&gt;[beg,end]&lt;/code&gt; 。默认值为无，在这种情况下将使用类域。</target>
        </trans-unit>
        <trans-unit id="9fd5a8f72ea35597060cfb26a58e00837b4119cd" translate="yes" xml:space="preserve">
          <source>If not None, then memory-map the file, using the given mode (see &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt;&lt;code&gt;numpy.memmap&lt;/code&gt;&lt;/a&gt; for a detailed description of the modes). A memory-mapped array is kept on disk. However, it can be accessed and sliced like any ndarray. Memory mapping is especially useful for accessing small fragments of large files without reading the entire file into memory.</source>
          <target state="translated">如果不是None，则使用给定的模式对文件进行内存映射（有关模式的详细说明，请参见&lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt; &lt;code&gt;numpy.memmap&lt;/code&gt; &lt;/a&gt;）。内存映射的阵列保留在磁盘上。但是，可以像访问任何ndarray一样对其进行访问和切片。内存映射对于访问大文件的小片段而不将整个文件读入内存特别有用。</target>
        </trans-unit>
        <trans-unit id="1dde66b48fa13cf03c30ed219d07e5b09a8bd837" translate="yes" xml:space="preserve">
          <source>If obj is an ndarray (&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt;), then the data-area of the ndarray is pointed to by the void* pointer &lt;a href=&quot;../reference/c-api/array#c.PyArray_DATA&quot;&gt;&lt;code&gt;PyArray_DATA&lt;/code&gt;&lt;/a&gt; (obj) or the char* pointer &lt;a href=&quot;../reference/c-api/array#c.PyArray_BYTES&quot;&gt;&lt;code&gt;PyArray_BYTES&lt;/code&gt;&lt;/a&gt; (obj). Remember that (in general) this data-area may not be aligned according to the data-type, it may represent byte-swapped data, and/or it may not be writeable. If the data area is aligned and in native byte-order, then how to get at a specific element of the array is determined only by the array of npy_intp variables, &lt;a href=&quot;../reference/c-api/array#c.PyArray_STRIDES&quot;&gt;&lt;code&gt;PyArray_STRIDES&lt;/code&gt;&lt;/a&gt; (obj). In particular, this c-array of integers shows how many &lt;strong&gt;bytes&lt;/strong&gt; must be added to the current element pointer to get to the next element in each dimension. For arrays less than 4-dimensions there are &lt;code&gt;PyArray_GETPTR{k}&lt;/code&gt; (obj, &amp;hellip;) macros where {k} is the integer 1, 2, 3, or 4 that make using the array strides easier. The arguments &amp;hellip;. represent {k} non- negative integer indices into the array. For example, suppose &lt;code&gt;E&lt;/code&gt; is a 3-dimensional ndarray. A (void*) pointer to the element &lt;code&gt;E[i,j,k]&lt;/code&gt; is obtained as &lt;a href=&quot;../reference/c-api/array#c.PyArray_GETPTR3&quot;&gt;&lt;code&gt;PyArray_GETPTR3&lt;/code&gt;&lt;/a&gt; (E, i, j, k).</source>
          <target state="translated">如果obj是ndarray（&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt;），则ndarray的数据区域由void *指针&lt;a href=&quot;../reference/c-api/array#c.PyArray_DATA&quot;&gt; &lt;code&gt;PyArray_DATA&lt;/code&gt; &lt;/a&gt;（obj）或char *指针&lt;a href=&quot;../reference/c-api/array#c.PyArray_BYTES&quot;&gt; &lt;code&gt;PyArray_BYTES&lt;/code&gt; &lt;/a&gt;（obj）指向。请记住，（通常）此数据区域可能未根据数据类型对齐，可能表示字节交换数据，并且/或者可能不可写。如果数据区域是对齐的并且是本机字节顺序，则如何获取数组的特定元素仅由npy_intp变量数组&lt;a href=&quot;../reference/c-api/array#c.PyArray_STRIDES&quot;&gt; &lt;code&gt;PyArray_STRIDES&lt;/code&gt; &lt;/a&gt;（obj）确定。特别是，此整数c数组显示必须将多少&lt;strong&gt;个字节&lt;/strong&gt;添加到当前元素指针才能到达每个维度中的下一个元素。对于小于4维的数组，有 &lt;code&gt;PyArray_GETPTR{k}&lt;/code&gt; （obj，&amp;hellip;）宏，其中{k}是整数1、2、3或4，这使得使用数组的步幅更加容易。争论...。表示数组中的{k}个非负整数索引。例如，假设 &lt;code&gt;E&lt;/code&gt; 是3维ndarray。获得指向元素 &lt;code&gt;E[i,j,k]&lt;/code&gt; 的（void *）指针作为&lt;a href=&quot;../reference/c-api/array#c.PyArray_GETPTR3&quot;&gt; &lt;code&gt;PyArray_GETPTR3&lt;/code&gt; &lt;/a&gt;（E，i，j，k）。</target>
        </trans-unit>
        <trans-unit id="9280c1d0944bd8756c1f5111dc408efcc4ac592a" translate="yes" xml:space="preserve">
          <source>If offsets were specified using the optional &lt;code&gt;offsets&lt;/code&gt; key in the dictionary-based dtype specification, setting &lt;code&gt;align=True&lt;/code&gt; will check that each field&amp;rsquo;s offset is a multiple of its size and that the itemsize is a multiple of the largest field size, and raise an exception if not.</source>
          <target state="translated">如果在基于字典的dtype规范中使用可选的 &lt;code&gt;offsets&lt;/code&gt; 键指定了偏移量，则设置 &lt;code&gt;align=True&lt;/code&gt; 将检查每个字段的偏移量是其大小的倍数，而itemsize是最大字段大小的倍数，并引发异常如果不。</target>
        </trans-unit>
        <trans-unit id="7e8ee117c63f729e22bf227e3e07bb22de12fa90" translate="yes" xml:space="preserve">
          <source>If one argument: a scalar, only used in case &lt;code&gt;a&lt;/code&gt; is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</source>
          <target state="translated">如果一个参数：一标量，只有在情况下使用 &lt;code&gt;a&lt;/code&gt; 是大小为1，如果两个参数：最后一个参数是要设置的值，并且必须是一个标量，该第一参数指定的单个阵列元素位置。它是一个int或一个元组。</target>
        </trans-unit>
        <trans-unit id="57c6aeb84d68fcc852763a7a13de57615e4d20cf" translate="yes" xml:space="preserve">
          <source>If one does need to invoke a formal veto, then it should consist of:</source>
          <target state="translated">如果确实需要行使正式的否决权,那么它应该包括:</target>
        </trans-unit>
        <trans-unit id="071afc2f1bb001ecc847b5f0833d4155cd8fca5d" translate="yes" xml:space="preserve">
          <source>If one of the commands breaks in the middle, which is not uncommon, you may need to selectively upload the remaining files because PyPI does not allow the same file to be uploaded twice. The source file should be uploaded last to avoid synchronization problems if pip users access the files while this is in process. Note that PyPI only allows a single source distribution, here we have chosen the zip archive.</source>
          <target state="translated">如果其中一个命令在中途中断,这并不罕见,你可能需要有选择地上传剩余的文件,因为PyPI不允许同一个文件上传两次。源文件应该最后上传,以避免在上传过程中pip用户访问文件时出现同步问题。需要注意的是,PyPI只允许单一的源码分发,这里我们选择的是zip压缩包。</target>
        </trans-unit>
        <trans-unit id="6b366b75bdd6732eac035ef513f1831e74291371" translate="yes" xml:space="preserve">
          <source>If one of the commands breaks in the middle, you may need to selectively upload the remaining files because PyPI does not allow the same file to be uploaded twice. The source file should be uploaded last to avoid synchronization problems that might occur if pip users access the files while this is in process. Note that PyPI only allows a single source distribution, here we have chosen the zip archive.</source>
          <target state="translated">如果其中一个命令中途中断,你可能需要有选择地上传剩下的文件,因为 PyPI 不允许同一个文件上传两次。源文件应该最后上传,以避免在此过程中,pip用户访问文件时可能出现的同步问题。需要注意的是,PyPI只允许单一的源码分发,这里我们选择的是zip压缩包。</target>
        </trans-unit>
        <trans-unit id="6981fed895201194d2f8c788e92aaa4d462ed21a" translate="yes" xml:space="preserve">
          <source>If one of the input or output arguments has a &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, it is executed &lt;em&gt;instead&lt;/em&gt; of the ufunc. If more than one of the arguments implements &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;, they are tried in the order: subclasses before superclasses, inputs before outputs, otherwise left to right. The first routine returning something other than &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; determines the result. If all of the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; operations return &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">如果输入或输出参数之一具有&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;方法，则将执行该方法&lt;em&gt;而不是&lt;/em&gt; ufunc。如果多个参数实现&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;，则按以下顺序尝试：子类在超类之前，输入在输出之前，否则从左到右。返回非&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt;以外的东西的第一个例程确定结果。如果所有&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;操作都返回&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt;，则引发&lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="078513303dc00f49a54bb48b4a05d01efff2507a" translate="yes" xml:space="preserve">
          <source>If one or more elements differ by more than &lt;code&gt;maxulp&lt;/code&gt;.</source>
          <target state="translated">如果一个或多个元素的差异大于 &lt;code&gt;maxulp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00b891e47fe38237c020d297bb43b5693729c6dd" translate="yes" xml:space="preserve">
          <source>If one throws a die repeatedly until the third time a &amp;ldquo;1&amp;rdquo; appears, then the probability distribution of the number of non-&amp;ldquo;1&amp;rdquo;s that appear before the third &amp;ldquo;1&amp;rdquo; is a negative binomial distribution.</source>
          <target state="translated">如果一个人反复掷骰子直到第三次出现&amp;ldquo; 1&amp;rdquo;，那么出现在第三次&amp;ldquo; 1&amp;rdquo;之前的非&amp;ldquo; 1&amp;rdquo;数目的概率分布为负二项式分布。</target>
        </trans-unit>
        <trans-unit id="f25e55ccd77b879343ce3ca049a9d0e4b78987e8" translate="yes" xml:space="preserve">
          <source>If one uses the same dimension name in multiple locations, this enforces the same size of the corresponding dimensions.</source>
          <target state="translated">如果在多个位置使用相同的维度名称,这将强制执行相应维度的相同大小。</target>
        </trans-unit>
        <trans-unit id="341d0c5af878a988a0ac05e9410e510da00aae4c" translate="yes" xml:space="preserve">
          <source>If operand flags &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; are used the operands may be views into the original data with the &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag. In this case &lt;a href=&quot;#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; must be used as a context manager or the &lt;a href=&quot;numpy.nditer.close#numpy.nditer.close&quot;&gt;&lt;code&gt;nditer.close&lt;/code&gt;&lt;/a&gt; method must be called before using the result. The temporary data will be written back to the original data when the &lt;code&gt;__exit__&lt;/code&gt; function is called but not before:</source>
          <target state="translated">如果使用操作数标志 &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; 或 &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; ，则操作数可能是带有 &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; 标志的原始数据视图。在这种情况下，必须将&lt;a href=&quot;#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;用作上下文管理器，或者必须在使用结果之前调用&lt;a href=&quot;numpy.nditer.close#numpy.nditer.close&quot;&gt; &lt;code&gt;nditer.close&lt;/code&gt; &lt;/a&gt;方法。调用 &lt;code&gt;__exit__&lt;/code&gt; 函数时，临时数据将被写回到原始数据，但不能在此之前：</target>
        </trans-unit>
        <trans-unit id="9d0e3c2e03d57620541ba508399723e46a30af16" translate="yes" xml:space="preserve">
          <source>If operand flags &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; are used the operands may be views into the original data with the &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag. In this case nditer must be used as a context manager or the nditer.close method must be called before using the result. The temporary data will be written back to the original data when the &lt;code&gt;__exit__&lt;/code&gt; function is called but not before:</source>
          <target state="translated">如果使用操作数标志 &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; 或 &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; ，则操作数可能是带有 &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; 标志的原始数据视图。在这种情况下，必须将nditer用作上下文管理器，或者必须在使用结果之前调用nditer.close方法。当调用 &lt;code&gt;__exit__&lt;/code&gt; 函数时，临时数据将被写回到原始数据，但不会在此之前：</target>
        </trans-unit>
        <trans-unit id="6bcdbb4b2db72f15cd471674f6106b51d73bea1c" translate="yes" xml:space="preserve">
          <source>If our array has more than two dimensions, then the SVD can be applied to all axes at once. However, the linear algebra functions in NumPy expect to see an array of the form &lt;code&gt;(N, M, M)&lt;/code&gt;, where the first axis represents the number of matrices.</source>
          <target state="translated">如果我们的数组有两个以上的维，则可以将SVD一次应用于所有轴。但是，NumPy中的线性代数函数希望看到形式为 &lt;code&gt;(N, M, M)&lt;/code&gt; 的数组，其中第一个轴代表矩阵的数量。</target>
        </trans-unit>
        <trans-unit id="7979a86d632f406a43fda9a7bbc242f0b6aa48c1" translate="yes" xml:space="preserve">
          <source>If out is given and does not have a mask attribute, the mask of a is lost!</source>
          <target state="translated">如果给了out,并且没有 mask属性,那么a的 mask就会丢失!</target>
        </trans-unit>
        <trans-unit id="540ba134ebef3a60b12504ba1dddaea7cf0cec06" translate="yes" xml:space="preserve">
          <source>If passed a single ndarray or scalar (a nested list of depth 0), this is returned unmodified (and not copied).</source>
          <target state="translated">如果传递的是单个ndarray或标量(深度为0的嵌套列表),则会不加修改地返回(而不是复制)。</target>
        </trans-unit>
        <trans-unit id="2ca82b5f657729109e0a486900feb42978dd8189" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.RandomState.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">如果提供正int_like参数，&lt;a href=&quot;#numpy.random.RandomState.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt;产生形状的阵列 &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; ，填充有从单变量采样随机浮点数均值为0，方差为1的单个浮子的&amp;ldquo;正常&amp;rdquo;（高斯）分布如果未提供任何参数，则从分布中随机抽样。</target>
        </trans-unit>
        <trans-unit id="96808216b5aaeeafcea0d1c6dd5a1e0894eaaeca" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">如果提供正int_like参数，&lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt;产生形状的阵列 &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; ，填充有从单变量采样随机浮点数均值为0，方差为1的单个浮子的&amp;ldquo;正常&amp;rdquo;（高斯）分布如果未提供任何参数，则从分布中随机抽样。</target>
        </trans-unit>
        <trans-unit id="6cd43f42d93868c2f881ad2d0e04b27cc3b3d230" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">如果提供正int_like参数，&lt;a href=&quot;#numpy.random.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt;产生形状的阵列 &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; ，填充有从单变量采样随机浮点数均值为0，方差为1的单个浮子的&amp;ldquo;正常&amp;rdquo;（高斯）分布如果未提供任何参数，则从分布中随机抽样。</target>
        </trans-unit>
        <trans-unit id="bfcb0d73efeb90f5b4e3ce5ebdfcfa5192159dee" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;numpy.random.randn#numpy.random.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">如果提供正int_like参数，&lt;a href=&quot;numpy.random.randn#numpy.random.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt;产生形状的阵列 &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; ，填充有从单变量采样随机浮点数均值为0，方差为1的单个浮子的&amp;ldquo;正常&amp;rdquo;（高斯）分布如果未提供任何参数，则从分布中随机抽样。</target>
        </trans-unit>
        <trans-unit id="55be54163f14c3cf436fe9e5956719fe1ba33eba" translate="yes" xml:space="preserve">
          <source>If provided, forces the calculation to use the data type specified. Note that you may have to also give a more liberal &lt;code&gt;casting&lt;/code&gt; parameter to allow the conversions. Default is None.</source>
          <target state="translated">如果提供，则强制计算使用指定的数据类型。请注意，您可能还必须提供一个更宽松的 &lt;code&gt;casting&lt;/code&gt; 参数以允许进行转换。默认为无。</target>
        </trans-unit>
        <trans-unit id="e083348afe334fd6151280febab9e53c63ddbb1c" translate="yes" xml:space="preserve">
          <source>If provided, is a list of ints or None for each operands. The list of axes for an operand is a mapping from the dimensions of the iterator to the dimensions of the operand. A value of -1 can be placed for entries, causing that dimension to be treated as &lt;a href=&quot;../constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果提供，则为每个操作数的整数或无列表。操作数的轴列表是从迭代器的尺寸到操作数的尺寸的映射。可以为输入放置值-1，从而将该尺寸视为&lt;a href=&quot;../constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5d381c2d7955b7fd1c70c985e306d9e2f555e38" translate="yes" xml:space="preserve">
          <source>If provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;). If array-like, must contain integer values</source>
          <target state="translated">如果提供，则从分布中得出的最大（有符号）整数上方一个整数（如果 &lt;code&gt;high=None&lt;/code&gt; ,请参见上面的行为）。如果为数组，则必须包含整数值</target>
        </trans-unit>
        <trans-unit id="95838d6d878826fc55d5a3e35ced6032cc48a529" translate="yes" xml:space="preserve">
          <source>If provided, the calculation is done into this array.</source>
          <target state="translated">如果提供,则计算到这个数组中。</target>
        </trans-unit>
        <trans-unit id="ea0c1f6bb199f46cbf91a8a029c842a1c97612d0" translate="yes" xml:space="preserve">
          <source>If provided, the destination array will have this dtype. Cannot be provided together with &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">如果提供，目标数组将具有此dtype。不能与 &lt;code&gt;out&lt;/code&gt; 一起提供。</target>
        </trans-unit>
        <trans-unit id="af1a016b36ff8a1ba521445122b451501db1dbf6" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what concatenate would have returned if no out argument were specified.</source>
          <target state="translated">如果提供,则是放置结果的目的地。形状必须正确,与没有指定out参数的情况下concat返回的形状一致。</target>
        </trans-unit>
        <trans-unit id="c1c663fe8abb225f988d791716021ba47f8cdb72" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what stack would have returned if no out argument were specified.</source>
          <target state="translated">如果提供,则是放置结果的目的地。形状必须正确,与没有指定out参数时堆栈返回的形状一致。</target>
        </trans-unit>
        <trans-unit id="f5316b9b72a00d5e03e3e99cc76713f526033f92" translate="yes" xml:space="preserve">
          <source>If provided, the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;).</source>
          <target state="translated">如果提供，则从分布中得出最大（有符号）整数（如果 &lt;code&gt;high=None&lt;/code&gt; ,请参见上面的行为）。</target>
        </trans-unit>
        <trans-unit id="9522e8e010639b210e9e797758ab5c3b994ee6ec" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果提供，结果将被插入此数组。它应该具有适当的形状和&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="95c405f27ca318550aa8a5e9d68fd036459e5597" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">如果提供，结果将被插入此数组。它应该具有适当的形状和 &lt;code&gt;dtype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5aa5842b82d356df663381019439d99b6de6d45f" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype.</source>
          <target state="translated">如果提供,结果将被插入到这个数组中。它应该是适当的形状和dtype。</target>
        </trans-unit>
        <trans-unit id="cb7c8c85e64a3a49b66549989ff45cf1e28fbfc9" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">如果提供，结果将被插入此数组。它应该具有适当的形状和dtype。注意，如果 &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; ，则 &lt;code&gt;out&lt;/code&gt; 总是被缓冲；使用其他模式以获得更好的性能。</target>
        </trans-unit>
        <trans-unit id="81a5da5dc747b4213d85b5feaae67db0441d8c96" translate="yes" xml:space="preserve">
          <source>If provided, the result will be placed in this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">如果提供，结果将放置在此数组中。它应该具有适当的形状和dtype。注意，如果 &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; ，则 &lt;code&gt;out&lt;/code&gt; 总是被缓冲；使用其他模式以获得更好的性能。</target>
        </trans-unit>
        <trans-unit id="930ff5cfb0e50021c5f5a8e94b02d45dd7e7a78b" translate="yes" xml:space="preserve">
          <source>If provided, this array is filled with the result.</source>
          <target state="translated">如果提供了,这个数组将被填入结果。</target>
        </trans-unit>
        <trans-unit id="11fa623532ff8e1a6968612e0395b44c20331e38" translate="yes" xml:space="preserve">
          <source>If set to False, the returned array will always be readonly. Otherwise it will be writable if the original array was. It is advisable to set this to False if possible (see Notes).</source>
          <target state="translated">如果设置为False,返回的数组将始终是只读的。否则,如果原始数组是可写的,那么它将是可写的。如果可能的话,建议将其设置为False(见注释)。</target>
        </trans-unit>
        <trans-unit id="2bff5e445257625fab4df9171fbb5cbef9e23081" translate="yes" xml:space="preserve">
          <source>If set to the string &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; enables 1.13 legacy printing mode. This approximates numpy 1.13 print output by including a space in the sign position of floats and different behavior for 0d arrays. If set to &lt;code&gt;False&lt;/code&gt;, disables legacy mode. Unrecognized strings will be ignored with a warning for forward compatibility.</source>
          <target state="translated">如果设置为字符串 &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; 启用1.13旧版打印模式。通过在浮点数的符号位置包含一个空格以及0d数组的不同行为，这近似于numpy 1.13打印输出。如果设置为 &lt;code&gt;False&lt;/code&gt; ，则禁用旧模式。无法识别的字符串将被警告，并带有向前兼容性的警告。</target>
        </trans-unit>
        <trans-unit id="fe72d8f764239876f5476ff64d033c4aa157117d" translate="yes" xml:space="preserve">
          <source>If slice notation is used, the syntax &lt;code&gt;start:stop:step&lt;/code&gt; is equivalent to &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; inside of the brackets. However, if &lt;code&gt;step&lt;/code&gt; is an imaginary number (i.e. 100j) then its integer portion is interpreted as a number-of-points desired and the start and stop are inclusive. In other words &lt;code&gt;start:stop:stepj&lt;/code&gt; is interpreted as &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; inside of the brackets. After expansion of slice notation, all comma separated sequences are concatenated together.</source>
          <target state="translated">如果使用切片符号，则语法 &lt;code&gt;start:stop:step&lt;/code&gt; 等效于方括号内的 &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; 。但是，如果 &lt;code&gt;step&lt;/code&gt; 是一个虚数（即100j），则将其整数部分解释为所需的点数，并且开始和结束都包括在内。换句话说， &lt;code&gt;start:stop:stepj&lt;/code&gt; 被解释为方括号内的 &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; 。切片符号扩展后，所有逗号分隔的序列将连接在一起。</target>
        </trans-unit>
        <trans-unit id="d852188873e81a9c252d600a61b8e6669ecb8d51" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected (and &lt;a href=&quot;numpy.full#numpy.full&quot;&gt;&lt;code&gt;full&lt;/code&gt;&lt;/a&gt; == &lt;code&gt;False&lt;/code&gt;), a &lt;a href=&quot;numpy.rankwarning#numpy.RankWarning&quot;&gt;&lt;code&gt;RankWarning&lt;/code&gt;&lt;/a&gt; will be raised. This means that the coefficient values may be poorly determined. Fitting to a lower order polynomial will usually get rid of the warning (but may not be what you want, of course; if you have independent reason(s) for choosing the degree which isn&amp;rsquo;t working, you may have to: a) reconsider those reasons, and/or b) reconsider the quality of your data). The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">如果 &lt;code&gt;V&lt;/code&gt; 的某些奇异值太小以至于它们被忽略（并且&lt;a href=&quot;numpy.full#numpy.full&quot;&gt; &lt;code&gt;full&lt;/code&gt; &lt;/a&gt;== &lt;code&gt;False&lt;/code&gt; ），则将引发&lt;a href=&quot;numpy.rankwarning#numpy.RankWarning&quot;&gt; &lt;code&gt;RankWarning&lt;/code&gt; &lt;/a&gt;。这意味着系数值可能难以确定。拟合低阶多项式通常会摆脱警告（但是，当然不是您想要的警告；如果您有独立的理由选择不起作用的度数，则可能必须：a）重新考虑这些原因，和/或b）重新考虑数据的质量）。也可以将 &lt;code&gt;rcond&lt;/code&gt; 参数设置为小于其默认值的值，但是最终的拟合可能是虚假的，并且由于舍入误差而产生很大的影响。</target>
        </trans-unit>
        <trans-unit id="81a87ade0c2eb6eb2f3e1b57567f9837157177e2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected (and &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt;), a &lt;code&gt;RankWarning&lt;/code&gt; will be raised. This means that the coefficient values may be poorly determined. Fitting to a lower order polynomial will usually get rid of the warning (but may not be what you want, of course; if you have independent reason(s) for choosing the degree which isn&amp;rsquo;t working, you may have to: a) reconsider those reasons, and/or b) reconsider the quality of your data). The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">如果 &lt;code&gt;V&lt;/code&gt; 的某些奇异值太小以至于它们被忽略（并且 &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt; ），则将引发 &lt;code&gt;RankWarning&lt;/code&gt; 。这意味着系数值可能难以确定。拟合低阶多项式通常会摆脱警告（但不一定是您想要的警告；当然，如果您有选择不起作用的次数的独立原因，则可能必须：a）重新考虑这些原因，和/或b）重新考虑数据的质量）。也可以将 &lt;code&gt;rcond&lt;/code&gt; 参数设置为小于其默认值的值，但是最终的拟合可能是虚假的，并且由于舍入误差而产生很大的影响。</target>
        </trans-unit>
        <trans-unit id="0219410592b277d18d42730ec323b9fe9d5cac7f" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected, then a &lt;a href=&quot;numpy.rankwarning#numpy.RankWarning&quot;&gt;&lt;code&gt;RankWarning&lt;/code&gt;&lt;/a&gt; will be issued. This means that the coefficient values may be poorly determined. Using a lower order fit will usually get rid of the warning. The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">如果 &lt;code&gt;V&lt;/code&gt; 的某些奇异值太小而被忽略，则将发出&lt;a href=&quot;numpy.rankwarning#numpy.RankWarning&quot;&gt; &lt;code&gt;RankWarning&lt;/code&gt; &lt;/a&gt;。这意味着系数值可能难以确定。使用低阶拟合通常会摆脱警告。也可以将 &lt;code&gt;rcond&lt;/code&gt; 参数设置为小于其默认值的值，但是结果拟合可能是虚假的，并且由于舍入误差而产生很大的影响。</target>
        </trans-unit>
        <trans-unit id="279580d9404d9230f24c863b3bff92a3996533c2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected, then a &lt;code&gt;RankWarning&lt;/code&gt; will be issued. This means that the coefficient values may be poorly determined. Using a lower order fit will usually get rid of the warning. The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">如果 &lt;code&gt;V&lt;/code&gt; 的某些奇异值太小以至于它们被忽略，则将发出 &lt;code&gt;RankWarning&lt;/code&gt; 。这意味着系数值可能难以确定。使用低阶拟合通常会摆脱警告。也可以将 &lt;code&gt;rcond&lt;/code&gt; 参数设置为小于其默认值的值，但是结果拟合可能是虚假的，并且由于舍入误差而产生很大的影响。</target>
        </trans-unit>
        <trans-unit id="965baa6e6f17f07c36f67c069da20d4c8b056bfe" translate="yes" xml:space="preserve">
          <source>If sparse is False:</source>
          <target state="translated">如果稀疏为False。</target>
        </trans-unit>
        <trans-unit id="d3cfaef438df28358b3d4e747b777d350c839464" translate="yes" xml:space="preserve">
          <source>If sparse is True:</source>
          <target state="translated">如果稀疏为真。</target>
        </trans-unit>
        <trans-unit id="da499c4730990d0eca07f07d81ecedd5eee01e35" translate="yes" xml:space="preserve">
          <source>If sparse is set to true, the grid will be returned in a sparse representation.</source>
          <target state="translated">如果sparse被设置为true,网格将以稀疏的方式返回。</target>
        </trans-unit>
        <trans-unit id="a0b2e0085e9bacd8c444b0a0e2e8508a5f8b81ab" translate="yes" xml:space="preserve">
          <source>If specified, all the fields will be changed to the provided byte-order. Otherwise, the default byte-order is used. For all available string specifiers, see &lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt;&lt;code&gt;dtype.newbyteorder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果指定，所有字段将更改为提供的字节顺序。否则，将使用默认字节顺序。有关所有可用的字符串说明符，请参见&lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt; &lt;code&gt;dtype.newbyteorder&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="524227865d52e8b4442de30061c3ce0262f46831" translate="yes" xml:space="preserve">
          <source>If specified, it must be a tuple or list which contains a permutation of [0,1,..,N-1] where N is the number of axes of a. The i&amp;rsquo;th axis of the returned array will correspond to the axis numbered &lt;code&gt;axes[i]&lt;/code&gt; of the input. If not specified, defaults to &lt;code&gt;range(a.ndim)[::-1]&lt;/code&gt;, which reverses the order of the axes.</source>
          <target state="translated">如果指定，它必须是包含[0,1，.. N-1]的排列的元组或列表，其中N是a的轴数。返回数组的第i轴将对应于输入的轴编号axis &lt;code&gt;axes[i]&lt;/code&gt; 。如果未指定，则默认为 &lt;code&gt;range(a.ndim)[::-1]&lt;/code&gt; ，这将反转轴的顺序。</target>
        </trans-unit>
        <trans-unit id="f824fc5934f1c56555b7168823af2d5da98b5dab" translate="yes" xml:space="preserve">
          <source>If state is a dictionary, it is directly set using the BitGenerators &lt;code&gt;state&lt;/code&gt; property.</source>
          <target state="translated">如果state是字典，则可以使用BitG​​enerators &lt;code&gt;state&lt;/code&gt; 属性直接设置它。</target>
        </trans-unit>
        <trans-unit id="8bed509b136f4d80f9b83488488a97c842996d12" translate="yes" xml:space="preserve">
          <source>If steps 1 and 2 are done correctly, compiling the release should not give a warning &amp;ldquo;API mismatch detect at the beginning of the build&amp;rdquo;.</source>
          <target state="translated">如果步骤1和2正确完成，则编译发行版时不应发出警告&amp;ldquo;在构建开始时检测到API不匹配&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ebc779ce22e3bc8704e258c3f6aa49989598231f" translate="yes" xml:space="preserve">
          <source>If the (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flags are set, it has a different meaning, namely base is the array into which the current array will be copied upon copy resolution. This overloading of the base property for two functions is likely to change in a future version of NumPy.</source>
          <target state="translated">如果设置了（不建议使用的）&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;标志，则它具有不同的含义，即base是在复制分辨率下将当前数组复制到的数组。两个函数的基本属性的重载可能会在NumPy的未来版本中改变。</target>
        </trans-unit>
        <trans-unit id="cfe3d233f0d1b6d420d00f98b03a5ffbba4bbec2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; attribute is a CObject, then the pointer must be a pointer to a function with the signature:</source>
          <target state="translated">如果&lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; &lt;/a&gt;属性是CObject，则该指针必须是指向具有签名的函数的指针：</target>
        </trans-unit>
        <trans-unit id="b7883df78258ee376bc6906db165b3539bd009bc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; attribute is not None nor a CObject, then it must be a Python method that takes the parent array as an argument (which could be None if there is no parent), and returns nothing. Errors in this method will be caught and handled.</source>
          <target state="translated">如果&lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; &lt;/a&gt;属性既不是None也不不是CObject，则它必须是一个将父数组作为参数的Python方法（如果没有父级，则可以为None），并且不返回任何内容。此方法中的错误将被捕获并处理。</target>
        </trans-unit>
        <trans-unit id="35bc1249e520730be2802640a0588a9755304660" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object is a structured array the &lt;a href=&quot;../glossary#term-field&quot;&gt;fields&lt;/a&gt; of the array can be accessed by indexing the array with strings, dictionary-like.</source>
          <target state="translated">如果&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;对象是结构化数组，则可以通过使用类似于字典的字符串对数组进行索引来访问数组的&lt;a href=&quot;../glossary#term-field&quot;&gt;字段&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f501c2023177671c00839603f74082e5dd3d055" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object is a structured array the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;fields&lt;/a&gt; of the array can be accessed by indexing the array with strings, dictionary-like.</source>
          <target state="translated">如果&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;对象是结构化数组，则可以通过使用类似于字典的字符串对数组进行索引来访问数组的&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;字段&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0646be9a4620b324160297ec7386ae7d381a6d92" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;order&lt;/code&gt; keyword argument is specified. This behaviour is a bug in NumPy.</source>
          <target state="translated">如果指定了 &lt;code&gt;order&lt;/code&gt; 关键字参数。此行为是NumPy中的错误。</target>
        </trans-unit>
        <trans-unit id="95474ba24abf246463d023b7d37164eff549d001" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;width&lt;/code&gt; value is insufficient, it will be ignored, and &lt;code&gt;num&lt;/code&gt; will be returned in binary (&lt;code&gt;num&lt;/code&gt; &amp;gt; 0) or two&amp;rsquo;s complement (&lt;code&gt;num&lt;/code&gt; &amp;lt; 0) form with its width equal to the minimum number of bits needed to represent the number in the designated form. This behavior is deprecated and will later raise an error.</source>
          <target state="translated">如果 &lt;code&gt;width&lt;/code&gt; 值不足，它将被忽略，并且 &lt;code&gt;num&lt;/code&gt; 将以二进制（ &lt;code&gt;num&lt;/code&gt; &amp;gt; 0）或二进制补码（ &lt;code&gt;num&lt;/code&gt; &amp;lt;0）的形式返回，其宽度等于表示数字中所需的最小位数。指定表格。不建议使用此行为，以后将引发错误。</target>
        </trans-unit>
        <trans-unit id="e55f68c7edc654033798e55316d9b9691f5ca17e" translate="yes" xml:space="preserve">
          <source>If the API has changed, increment the C_API_VERSION in setup_common.py. The API is unchanged only if any code compiled against the current API will be backward compatible with the last released NumPy version. Any changes to C structures or additions to the public interface will make the new API not backward compatible.</source>
          <target state="translated">如果API发生了变化,请在setup_common.py中增加C_API_VERSION。只有当任何根据当前API编译的代码将向后兼容最后发布的NumPy版本时,API才不会改变。任何对 C 结构的修改或对公共接口的添加都会使新的 API 无法向后兼容。</target>
        </trans-unit>
        <trans-unit id="e8d9f657403ca89274645800f9ef39c0a2acef7a" translate="yes" xml:space="preserve">
          <source>If the CPU feature is not supported by the user platform or compiler, it will be skipped rather than raising a fatal error.</source>
          <target state="translated">如果用户平台或编译器不支持CPU功能,它将被跳过,而不是引发一个致命的错误。</target>
        </trans-unit>
        <trans-unit id="846345b681ee07e5dd05c26de91938c5750e96ed" translate="yes" xml:space="preserve">
          <source>If the C_API_VERSION in the first step has changed, or if the hash of the API has changed, the cversions.txt file needs to be updated. To check the hash, run the script numpy/core/cversions.py and note the API hash that is printed. If that hash does not match the last hash in numpy/core/code_generators/cversions.txt the hash has changed. Using both the appropriate C_API_VERSION and hash, add a new entry to cversions.txt. If the API version was not changed, but the hash differs, you will need to comment out the previous entry for that API version. For instance, in NumPy 1.9 annotations were added, which changed the hash, but the API was the same as in 1.8. The hash serves as a check for API changes, but it is not definitive.</source>
          <target state="translated">如果第一步中的C_API_VERSION发生了变化,或者API的哈希值发生了变化,则需要更新cversions.txt文件。要检查哈希值,运行脚本numpy/core/cversions.py,并注意打印出的API哈希值。如果该哈希值与 numpy/core/code_generators/cversions.txt 中的最后一个哈希值不匹配,则说明该哈希值已经改变。使用适当的 C_API_VERSION 和哈希值,在 cversions.txt 中添加一个新条目。如果API版本没有改变,但哈希值不同,你需要注释掉之前的API版本条目。例如,在 NumPy 1.9 中添加了注解,从而改变了哈希值,但 API 和 1.8 中是一样的。哈希值可以用来检查 API 的变化,但它不是确定的。</target>
        </trans-unit>
        <trans-unit id="307258bcc851f5976aadd2f56343dad80fcf2a38" translate="yes" xml:space="preserve">
          <source>If the PR relates to any issues, you can add the text &lt;code&gt;xref gh-xxxx&lt;/code&gt; where &lt;code&gt;xxxx&lt;/code&gt; is the number of the issue to github comments. Likewise, if the PR solves an issue, replace the &lt;code&gt;xref&lt;/code&gt; with &lt;code&gt;closes&lt;/code&gt;, &lt;code&gt;fixes&lt;/code&gt; or any of the other flavors &lt;a href=&quot;https://help.github.com/en/articles/closing-issues-using-keywords&quot;&gt;github accepts&lt;/a&gt;.</source>
          <target state="translated">如果PR与任何问题有关，则可以在文本注释中添加文本 &lt;code&gt;xref gh-xxxx&lt;/code&gt; ，其中 &lt;code&gt;xxxx&lt;/code&gt; 是问题的编号。同样，如果PR解决了问题，则用 &lt;code&gt;closes&lt;/code&gt; ， &lt;code&gt;fixes&lt;/code&gt; 或&lt;a href=&quot;https://help.github.com/en/articles/closing-issues-using-keywords&quot;&gt;github接受&lt;/a&gt;的其他任何 &lt;code&gt;xref&lt;/code&gt; 替换外部参照。</target>
        </trans-unit>
        <trans-unit id="049594537957d0705cc457b562940a40a3ed3347" translate="yes" xml:space="preserve">
          <source>If the SVD computation does not converge.</source>
          <target state="translated">如果SVD计算不收敛。</target>
        </trans-unit>
        <trans-unit id="532b7abf588e485b512986621b48cdfb34aabd33" translate="yes" xml:space="preserve">
          <source>If the Sphinx build issues a warning of the form &lt;code&gt;WARNING: Unknown target name: &quot;example&quot;&lt;/code&gt;, then that is what is happening. To avoid this problem, use the inline hyperlink form:</source>
          <target state="translated">如果Sphinx版本发出警告，形式是 &lt;code&gt;WARNING: Unknown target name: &quot;example&quot;&lt;/code&gt; ，那就是正在发生的事情。为避免此问题，请使用内联超链接形式：</target>
        </trans-unit>
        <trans-unit id="64f36babe99dcf796b7778a9ef584cf09c04cb03" translate="yes" xml:space="preserve">
          <source>If the accessed field is a sub-array, the dimensions of the sub-array are appended to the shape of the result.</source>
          <target state="translated">如果访问的字段是一个子数组,子数组的尺寸会附加到结果的形状上。</target>
        </trans-unit>
        <trans-unit id="7e63ccdf53ce8ac8b2fb2a0fbc4aad1e23cbc4dc" translate="yes" xml:space="preserve">
          <source>If the accessed field is a subarray, the dimensions of the subarray are appended to the shape of the result:</source>
          <target state="translated">如果访问的字段是一个子数组,子数组的尺寸会附加到结果的形状上。</target>
        </trans-unit>
        <trans-unit id="ba28bd784223a2a08bea18d126c6d98be59cd057" translate="yes" xml:space="preserve">
          <source>If the accumulator is too small, overflow occurs:</source>
          <target state="translated">如果蓄能器太小,就会发生溢流。</target>
        </trans-unit>
        <trans-unit id="f2dce957332c62c691a49ddcc68e31de7ff97f8b" translate="yes" xml:space="preserve">
          <source>If the array has no mask, the address of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is returned. This address is typically not close to the data in memory:</source>
          <target state="translated">如果数组没有掩码，则返回&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;的地址。此地址通常不接近内存中的数据：</target>
        </trans-unit>
        <trans-unit id="d51f2eaee63f2842d7a7119019788b97cb6ca340" translate="yes" xml:space="preserve">
          <source>If the array has no mask, the address of &lt;code&gt;nomask&lt;/code&gt; is returned. This address is typically not close to the data in memory:</source>
          <target state="translated">如果数组没有掩码，则返回 &lt;code&gt;nomask&lt;/code&gt; 的地址。该地址通常不接近内存中的数据：</target>
        </trans-unit>
        <trans-unit id="0e4bd5d4fdacecd1895716db48cb1cac490ae19c" translate="yes" xml:space="preserve">
          <source>If the array is not compatible with the new shape according to NumPy&amp;rsquo;s broadcasting rules.</source>
          <target state="translated">根据NumPy的广播规则，该数组是否与新形状不兼容。</target>
        </trans-unit>
        <trans-unit id="1b3a1026c96ba9547fc879c6163e5467ed414876" translate="yes" xml:space="preserve">
          <source>If the axis argument isn&amp;rsquo;t passed, your 2D array will be flattened.</source>
          <target state="translated">如果未传递axis参数，则2D数组将被展平。</target>
        </trans-unit>
        <trans-unit id="9556db7609e9b52c8da71258e9ebc1e23d97b8b8" translate="yes" xml:space="preserve">
          <source>If the buffer has data that is not in machine byte-order, this should be specified as part of the data-type, e.g.:</source>
          <target state="translated">如果缓冲区中的数据不是按机器字节顺序排列的,则应将其作为数据类型的一部分来指定,例如:。</target>
        </trans-unit>
        <trans-unit id="707be1af574eabd0a2204881f5336941a1d0fb1f" translate="yes" xml:space="preserve">
          <source>If the columns have names, we can also select which columns to import by giving their name to the &lt;code&gt;usecols&lt;/code&gt; argument, either as a sequence of strings or a comma-separated string:</source>
          <target state="translated">如果列具有名称，我们还可以通过将其名称赋予 &lt;code&gt;usecols&lt;/code&gt; 参数来选择要导入的列，这些列可以是字符串序列或逗号分隔的字符串：</target>
        </trans-unit>
        <trans-unit id="a9172eee727e3bc5966a060de8a7a54e3be2870d" translate="yes" xml:space="preserve">
          <source>If the common data type is known ahead of time, don&amp;rsquo;t use this flag. Instead, set the requested dtype for all the operands.</source>
          <target state="translated">如果公共数据类型提前知道，请不要使用此标志。而是为所有操作数设置请求的dtype。</target>
        </trans-unit>
        <trans-unit id="c0b42d9b2195e628dbcfcb8e55fe0f75a169d8db" translate="yes" xml:space="preserve">
          <source>If the condition is a callable, it is used at runtime to dynamically make the decision. This is useful for tests that may require costly imports, to delay the cost until the test suite is actually executed.</source>
          <target state="translated">如果条件是可调用的,那么它就会在运行时被用来动态地做出决定。这对于那些可能需要昂贵的导入的测试来说是很有用的,可以将成本延迟到测试套件实际执行的时候。</target>
        </trans-unit>
        <trans-unit id="da8929bf843323251f47496e7bd27572472297dd" translate="yes" xml:space="preserve">
          <source>If the conversion is not possible</source>
          <target state="translated">如果不可能进行转换</target>
        </trans-unit>
        <trans-unit id="bf41eeaf999250f9cdaa16bd479da6c16a96c8f5" translate="yes" xml:space="preserve">
          <source>If the ctypes module is not available, then the ctypes attribute of array objects still returns something useful, but ctypes objects are not returned and errors may be raised instead. In particular, the object will still have the &lt;code&gt;as_parameter&lt;/code&gt; attribute which will return an integer equal to the data attribute.</source>
          <target state="translated">如果ctypes模块不可用，则数组对象的ctypes属性仍然返回有用的内容，但不会返回ctypes对象，而可能会引发错误。特别是，对象仍将具有 &lt;code&gt;as_parameter&lt;/code&gt; 属性，该属性将返回等于data属性的整数。</target>
        </trans-unit>
        <trans-unit id="882469c86c3e266d61a4e68ca724a4e1e6d70bb9" translate="yes" xml:space="preserve">
          <source>If the current domain is the interval &lt;code&gt;[l1, r1]&lt;/code&gt; and the window is &lt;code&gt;[l2, r2]&lt;/code&gt;, then the linear mapping function &lt;code&gt;L&lt;/code&gt; is defined by the equations:</source>
          <target state="translated">如果当前域是区间 &lt;code&gt;[l1, r1]&lt;/code&gt; ，窗口是 &lt;code&gt;[l2, r2]&lt;/code&gt; ，则线性映射函数 &lt;code&gt;L&lt;/code&gt; 由以下等式定义：</target>
        </trans-unit>
        <trans-unit id="4ed8629dcca88646587124e3779205aed8a1ff8c" translate="yes" xml:space="preserve">
          <source>If the data or the mode is invalid.</source>
          <target state="translated">如果数据或模式无效。</target>
        </trans-unit>
        <trans-unit id="74cde2bcb160b06069d73cce52e519943212158c" translate="yes" xml:space="preserve">
          <source>If the data type is &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, an aggregate of other data types, (&lt;em&gt;e.g.&lt;/em&gt;, describing an array item consisting of an integer and a float),</source>
          <target state="translated">如果数据类型是&lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;结构化数据类型&lt;/a&gt;，则是其他数据类型的集合（&lt;em&gt;例如&lt;/em&gt;，描述由整数和浮点数组成的数组项），</target>
        </trans-unit>
        <trans-unit id="b7e4177a6acaf9fb51b7f55a4c29b9a1f7f66006" translate="yes" xml:space="preserve">
          <source>If the data type is &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, an aggregate of other data types, (&lt;em&gt;e.g.&lt;/em&gt;, describing an array item consisting of an integer and a float),</source>
          <target state="translated">如果数据类型是&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;结构化数据类型&lt;/a&gt;，则为其他数据类型的集合（&lt;em&gt;例如&lt;/em&gt;，描述由整数和浮点数组成的数组项），</target>
        </trans-unit>
        <trans-unit id="0cecddf950b77d1003b9474189d29ff0bfdb6282" translate="yes" xml:space="preserve">
          <source>If the data type is a sub-array, what is its shape and data type.</source>
          <target state="translated">如果数据类型是子数组,其形状和数据类型是什么。</target>
        </trans-unit>
        <trans-unit id="5b7ff57105753a62bcfc1055c91f35344e435758" translate="yes" xml:space="preserve">
          <source>If the decomposition fails, for example, if &lt;code&gt;a&lt;/code&gt; is not positive-definite.</source>
          <target state="translated">如果分解失败，例如，如果 &lt;code&gt;a&lt;/code&gt; 不是正定的。</target>
        </trans-unit>
        <trans-unit id="ee52413e2abf8d484ea3208ee7d3358a43d8e634" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.all&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;子类的&lt;a href=&quot;#numpy.all&quot;&gt; &lt;code&gt;all&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="206ca5be0da6c825b1f0142de708ea22958f4d55" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amax&quot;&gt;&lt;code&gt;amax&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;子类的&lt;a href=&quot;#numpy.amax&quot;&gt; &lt;code&gt;amax&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="f05780b3efb83cb7999e12324775e7fa0e8c55fe" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amin&quot;&gt;&lt;code&gt;amin&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果默认值被传递，然后 &lt;code&gt;keepdims&lt;/code&gt; 不会被通过所传递&lt;a href=&quot;#numpy.amin&quot;&gt; &lt;code&gt;amin&lt;/code&gt; &lt;/a&gt;的亚类的方法&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，然而任何非默认值将是。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="4bb758877f868372bd36b970799d233d6c9b6b2e" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果默认值被传递，然后 &lt;code&gt;keepdims&lt;/code&gt; 不会被通过所传递&lt;a href=&quot;#numpy.any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt;的亚类的方法&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，然而任何非默认值将是。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="4f36bf742dff79ee7a2535335e60a655538367af" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给 &lt;code&gt;ndarray&lt;/code&gt; 子类的&lt;a href=&quot;#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="e936312beb89ed94ea31f46b832a3128132ea8c3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;的子类的&lt;a href=&quot;#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="cccfcc112e296f9db67affb5426a407a1e1b1ab3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;的子类的&lt;a href=&quot;#numpy.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都会传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="f6aec8996590d19051796274c83c4f7439695ce8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ptp&quot;&gt;&lt;code&gt;ptp&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;的子类的&lt;a href=&quot;#numpy.ptp&quot;&gt; &lt;code&gt;ptp&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="04b4fba4bb9497e64959763e9e88bb419b385930" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;的子类的&lt;a href=&quot;#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="3ec6e98470abd2d3a8abe5e8029889dd09ba623f" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;的子类的&lt;a href=&quot;#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="2d09798a597d9e0c839ab8917b5d5016554acbc8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;子类的&lt;a href=&quot;#numpy.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="83795d27b8fbf6727fc73ba1d3ba1433b7f48097" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给 &lt;code&gt;ndarray&lt;/code&gt; 子类的&lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="3a3ccfe6612fdaf74f2303bcfe7218060615e3b7" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;numpy.var#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果传递了默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 不会传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;的子类的&lt;a href=&quot;numpy.var#numpy.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt;方法，但是任何非默认值都将传递。如果子类的方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="f36f9bb6a297ac4fc949ef700d42398954026ba5" translate="yes" xml:space="preserve">
          <source>If the dimension of &lt;code&gt;a&lt;/code&gt; is less than 2.</source>
          <target state="translated">如果的尺寸 &lt;code&gt;a&lt;/code&gt; 小于2。</target>
        </trans-unit>
        <trans-unit id="a923921d01ae62bb1aaf773e7e11bc37201f68aa" translate="yes" xml:space="preserve">
          <source>If the discontinuity in &lt;code&gt;p&lt;/code&gt; is smaller than &lt;code&gt;pi&lt;/code&gt;, but larger than &lt;code&gt;discont&lt;/code&gt;, no unwrapping is done because taking the 2*pi complement would only make the discontinuity larger.</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 中的不连续性小于 &lt;code&gt;pi&lt;/code&gt; ，但大于 &lt;code&gt;discont&lt;/code&gt; ，则不进行解包，因为采用2 * pi补码只会使不连续性变大。</target>
        </trans-unit>
        <trans-unit id="dd1746ba40294ba18df6698853992dfa2b70977c" translate="yes" xml:space="preserve">
          <source>If the dtypes of two void structured arrays are equal, testing the equality of the arrays will result in a boolean array with the dimensions of the original arrays, with elements set to &lt;code&gt;True&lt;/code&gt; where all fields of the corresponding structures are equal. Structured dtypes are equal if the field names, dtypes and titles are the same, ignoring endianness, and the fields are in the same order:</source>
          <target state="translated">如果两个void结构化数组的dtype相等，则测试数组的相等性将导致布尔数组具有原始数组的尺寸，并且将元素设置为 &lt;code&gt;True&lt;/code&gt; ，其中对应结构的所有字段均相等。如果字段名称，dtype和标题相同（忽略字节序）且字段顺序相同，则结构化dtype相等。</target>
        </trans-unit>
        <trans-unit id="769e103ab2e97d0544e3e9203d0c4335be336adf" translate="yes" xml:space="preserve">
          <source>If the eigenvalue computation does not converge.</source>
          <target state="translated">如果特征值计算不收敛。</target>
        </trans-unit>
        <trans-unit id="18adc01c0eaa64bd3fe6f5b836944558dd579c54" translate="yes" xml:space="preserve">
          <source>If the element you&amp;rsquo;re looking for doesn&amp;rsquo;t exist in the array, then the returned array of indices will be empty. For example:</source>
          <target state="translated">如果要查找的元素在数组中不存在，则返回的索引数组将为空。例如：</target>
        </trans-unit>
        <trans-unit id="ae5f5ebbdda43d87574658252f8456304a3e6d83" translate="yes" xml:space="preserve">
          <source>If the file contains pickle data, then whatever object is stored in the pickle is returned.</source>
          <target state="translated">如果文件中包含pickle数据,那么将返回pickle中存储的任何对象。</target>
        </trans-unit>
        <trans-unit id="52f9285704aeec7c0050eb73ae0eedae9e536c15" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npy&lt;/code&gt; file, then a single array is returned.</source>
          <target state="translated">如果文件是 &lt;code&gt;.npy&lt;/code&gt; 文件，则返回单个数组。</target>
        </trans-unit>
        <trans-unit id="c850dbbea34f89942e452ade066952afb4aff87b" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, the returned value supports the context manager protocol in a similar fashion to the open function:</source>
          <target state="translated">如果文件是 &lt;code&gt;.npz&lt;/code&gt; 文件，则返回的值以类似于open函数的方式支持上下文管理器协议：</target>
        </trans-unit>
        <trans-unit id="6dd34773e8e6fce245333f3661e9174ce50590a5" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, then a dictionary-like object is returned, containing &lt;code&gt;{filename: array}&lt;/code&gt; key-value pairs, one for each file in the archive.</source>
          <target state="translated">如果文件是 &lt;code&gt;.npz&lt;/code&gt; 文件，则将返回一个类似于字典的对象，其中包含 &lt;code&gt;{filename: array}&lt;/code&gt; 键值对，对于归档中的每个文件一个。</target>
        </trans-unit>
        <trans-unit id="0a517df17f23da0350e5f4238549fbfa3ccd5684" translate="yes" xml:space="preserve">
          <source>If the file is not found or cannot be opened correctly.</source>
          <target state="translated">如果找不到文件或无法正确打开。</target>
        </trans-unit>
        <trans-unit id="3eb136618e35fc45bcfb6109a519b0397c62a7f3" translate="yes" xml:space="preserve">
          <source>If the filename ends in &lt;code&gt;.gz&lt;/code&gt;, the file is automatically saved in compressed gzip format. &lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt;&lt;code&gt;loadtxt&lt;/code&gt;&lt;/a&gt; understands gzipped files transparently.</source>
          <target state="translated">如果文件名以 &lt;code&gt;.gz&lt;/code&gt; 结尾，则文件将以压缩的gzip格式自动保存。&lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt; &lt;code&gt;loadtxt&lt;/code&gt; &lt;/a&gt;可以透明地理解gzip压缩文件。</target>
        </trans-unit>
        <trans-unit id="3cd5e67735dce4fe85460703c53dc9836515a450" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as a row vector. If the last argument is 1-D it is treated as a column vector. The other arguments must be 2-D.</source>
          <target state="translated">如果第一个参数是1-D,则作为行向量处理。如果最后一个参数是1-D,则作为列向量处理。其他参数必须是2-D的。</target>
        </trans-unit>
        <trans-unit id="02ed5193bd3dcf84d786340881fcb3d577ef57f7" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as row vector. If the last argument is 1-D it is treated as column vector. The other arguments must be 2-D.</source>
          <target state="translated">如果第一个参数是1-D,则作为行向量处理。如果最后一个参数是1-D,则作为列向量处理。其他参数必须是2-D。</target>
        </trans-unit>
        <trans-unit id="0a74c0a74431c3bd3b43bf07934fe3d61fd80338" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D, it is promoted to a matrix by prepending a 1 to its dimensions. After matrix multiplication the prepended 1 is removed.</source>
          <target state="translated">如果第一个参数是1-D,则通过在其维度上预置1,将其提升为一个矩阵。矩阵乘法后,去掉预置的1。</target>
        </trans-unit>
        <trans-unit id="89db4e5dab2cb1ce35a7fb31edd3413095e85f3c" translate="yes" xml:space="preserve">
          <source>If the first argument is a tuple, other arguments are ignored:</source>
          <target state="translated">如果第一个参数是元组,其他参数将被忽略。</target>
        </trans-unit>
        <trans-unit id="727e22f05290aaa6c2959157d7df0bc582e3c538" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then &lt;a href=&quot;#numpy.ma.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; returns True:</source>
          <target state="translated">如果以下方程式为元素式True，则&lt;a href=&quot;#numpy.ma.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; &lt;/a&gt;返回True：</target>
        </trans-unit>
        <trans-unit id="a4e333405efef301e87eb01476249ca72db784ba" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then &lt;a href=&quot;numpy.allclose#numpy.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; returns True:</source>
          <target state="translated">如果以下方程式为元素式True，则&lt;a href=&quot;numpy.allclose#numpy.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; &lt;/a&gt;返回True：</target>
        </trans-unit>
        <trans-unit id="94cbab458f248cbb972811c2359461201e9861d5" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then allclose returns True.</source>
          <target state="translated">如果下面的等式元素为True,那么allclose返回True。</target>
        </trans-unit>
        <trans-unit id="1386561a26e41c95c312db50b7ef52259e4517da" translate="yes" xml:space="preserve">
          <source>If the given strings are equal, &lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt;&lt;code&gt;assert_string_equal&lt;/code&gt;&lt;/a&gt; does nothing. If they are not equal, an AssertionError is raised, and the diff between the strings is shown.</source>
          <target state="translated">如果给定的字符串相等，则&lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt; &lt;code&gt;assert_string_equal&lt;/code&gt; &lt;/a&gt;不执行任何操作。如果它们不相等，则会引发AssertionError，并显示字符串之间的差异。</target>
        </trans-unit>
        <trans-unit id="f5f5e437a85f1a89c55d54e0a09b57161df68a13" translate="yes" xml:space="preserve">
          <source>If the header file that contains the prototype for &lt;code&gt;double dot()&lt;/code&gt; also contains other prototypes that you want to wrap, so that you need to &lt;code&gt;%include&lt;/code&gt; this header file, then you will also need a &lt;code&gt;%ignore
dot;&lt;/code&gt; directive, placed after the &lt;code&gt;%rename&lt;/code&gt; and before the &lt;code&gt;%include&lt;/code&gt; directives. Or, if the function in question is a class method, you will want to use &lt;code&gt;%extend&lt;/code&gt; rather than &lt;code&gt;%inline&lt;/code&gt; in addition to &lt;code&gt;%ignore&lt;/code&gt;.</source>
          <target state="translated">如果包含 &lt;code&gt;double dot()&lt;/code&gt; 原型的头文件还包含您要包装的其他原型，那么您需要 &lt;code&gt;%include&lt;/code&gt; 这个头文件，那么您还将需要 &lt;code&gt;%ignore dot;&lt;/code&gt; 指令，位于 &lt;code&gt;%rename&lt;/code&gt; 之后和 &lt;code&gt;%include&lt;/code&gt; 指令之前。或者，如果所讨论的函数是类方法，则除了 &lt;code&gt;%ignore&lt;/code&gt; 之外，还希望使用 &lt;code&gt;%extend&lt;/code&gt; 而不是 &lt;code&gt;%inline&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e4a3d5e2d4e2e2a3ebb889979e38306c67da7f4" translate="yes" xml:space="preserve">
          <source>If the index arrays do not have the same shape, there is an attempt to broadcast them to the same shape. If they cannot be broadcast to the same shape, an exception is raised:</source>
          <target state="translated">如果索引数组没有相同的形状,就会尝试将它们广播成相同的形状。如果它们不能被广播到相同的形状,就会引发一个异常。</target>
        </trans-unit>
        <trans-unit id="f745354786d48a61873aeb74a86c334de5c7a7b4" translate="yes" xml:space="preserve">
          <source>If the index expression contains comma separated arrays, then stack them along their first axis.</source>
          <target state="translated">如果索引表达式包含逗号分隔的数组,那么就沿着它们的第一个轴堆叠它们。</target>
        </trans-unit>
        <trans-unit id="34ad012e6ac2224c1d99e1fa90fb54c844437b0d" translate="yes" xml:space="preserve">
          <source>If the index expression contains slice notation or scalars then create a 1-D array with a range indicated by the slice notation.</source>
          <target state="translated">如果索引表达式包含分片符号或标量,那么就创建一个一维数组,其范围由分片符号表示。</target>
        </trans-unit>
        <trans-unit id="b729e3ef7cf0f40d514ca0e064da63fa121cea95" translate="yes" xml:space="preserve">
          <source>If the information is already documented and succinct enough for a how-to, just link to it, possibly after an introduction (&amp;ldquo;Three km/mi, take a right&amp;rdquo;).</source>
          <target state="translated">如果信息已经记录在案并且足够简洁，那么只需将其链接即可，可能需要在介绍之后进行链接（&amp;ldquo;三公里/英里，走一圈&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="70dea339f55810f6be3e1b0c9e7aefd88107ebbf" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;a&lt;/code&gt; contains an imaginary part, it is silently discarded.</source>
          <target state="translated">如果输入 &lt;code&gt;a&lt;/code&gt; 包含虚部，则将其静默丢弃。</target>
        </trans-unit>
        <trans-unit id="4637e99d70ef2c1cb40679370ac10807b840a3f4" translate="yes" xml:space="preserve">
          <source>If the input file does not exist or cannot be read.</source>
          <target state="translated">如果输入文件不存在或无法读取。</target>
        </trans-unit>
        <trans-unit id="bbf06b38d2758769a67207876edd570ca41378d4" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.max.</source>
          <target state="translated">如果输入为整数类型,则函数等同于np.max。</target>
        </trans-unit>
        <trans-unit id="7895a434c9eeafd563766c2013458a9eca1c5fea" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.min.</source>
          <target state="translated">如果输入为整数类型,则函数等同于np.min。</target>
        </trans-unit>
        <trans-unit id="b307c09a45c4aabb639976a619f0171d6a01d0dd" translate="yes" xml:space="preserve">
          <source>If the input is 2d and axis is specified, the result is a list of lists.</source>
          <target state="translated">如果输入的是2D,并且指定了轴,结果是一个列表。</target>
        </trans-unit>
        <trans-unit id="7ed38fa8c8d2f0a335bd5a040aeda16b9d1b796e" translate="yes" xml:space="preserve">
          <source>If the input is not 1-dimensional, or contains elements with negative values, or if &lt;code&gt;minlength&lt;/code&gt; is negative.</source>
          <target state="translated">如果输入不是一维的，或者包含具有负值的元素，或者 &lt;code&gt;minlength&lt;/code&gt; 为负。</target>
        </trans-unit>
        <trans-unit id="10296cda117e24158759559beefea304129412f0" translate="yes" xml:space="preserve">
          <source>If the input parameter &lt;code&gt;n&lt;/code&gt; is larger than the size of the input, the input is padded by appending zeros at the end. Even though this is the common approach, it might lead to surprising results. If a different padding is desired, it must be performed before calling &lt;a href=&quot;#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果输入参数 &lt;code&gt;n&lt;/code&gt; 大于输入的大小，则通过在末尾附加零来填充输入。即使这是常用方法，也可能导致令人惊讶的结果。如果需要不同的填充，则必须在调用&lt;a href=&quot;#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt;之前执行。</target>
        </trans-unit>
        <trans-unit id="3fc060b3dda78a5634929550749227bb1804a61d" translate="yes" xml:space="preserve">
          <source>If the inputs are ndarrays, then np.greater is equivalent to &amp;lsquo;&amp;gt;&amp;rsquo;.</source>
          <target state="translated">如果输入是ndarrays，则np.greater等效于'&amp;gt;'。</target>
        </trans-unit>
        <trans-unit id="36e6b94197e7b6e49557830166101a92fecb27ad" translate="yes" xml:space="preserve">
          <source>If the inputs or dtype are complex, the output will follow a logarithmic spiral in the complex plane. (There are an infinite number of spirals passing through two points; the output will follow the shortest such path.)</source>
          <target state="translated">如果输入或dtype是复数,输出将遵循复数平面上的对数螺旋。(通过两点的螺旋线的数量是无限的,输出将遵循最短的路径)。</target>
        </trans-unit>
        <trans-unit id="ce8f1e8f63cbe617564d9cd3d7c5c8bc3e2530ae" translate="yes" xml:space="preserve">
          <source>If the iterator is buffered, returns the size of the buffer being used, otherwise returns 0.</source>
          <target state="translated">如果迭代器是缓冲区,返回正在使用的缓冲区大小,否则返回0。</target>
        </trans-unit>
        <trans-unit id="f3c918834625c8823bdade73b25f11346749b818" translate="yes" xml:space="preserve">
          <source>If the iterator is tracking a multi-index, this strips support for them, and does further iterator optimizations that are possible if multi-indices are not needed. This function also resets the iterator to its initial state.</source>
          <target state="translated">如果迭代器正在跟踪多索引,这将剥离对它们的支持,并做进一步的迭代器优化,如果不需要多索引,则有可能。这个函数也会将迭代器重置为初始状态。</target>
        </trans-unit>
        <trans-unit id="7df15990c36906ed5503360d9305db9b7bfe762b" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; has different size.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的最后一个尺寸具有不同的大小。</target>
        </trans-unit>
        <trans-unit id="5f26098ec8a9cbafe4e4d839766540a822d41056" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; is not the same size as the second-to-last dimension of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 的最后一个尺寸与 &lt;code&gt;b&lt;/code&gt; 的倒数第二个尺寸不同。</target>
        </trans-unit>
        <trans-unit id="eb81ca8cc652031a811f2c78a93956ac1f2c926b" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;x1&lt;/code&gt; is not the same size as the second-to-last dimension of &lt;code&gt;x2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x1&lt;/code&gt; 的最后一个尺寸与 &lt;code&gt;x2&lt;/code&gt; 的倒数第二个尺寸不同。</target>
        </trans-unit>
        <trans-unit id="6d1f7f126415ee26c19732032b0ebefd0ac4317a" translate="yes" xml:space="preserve">
          <source>If the masked array has named fields, accessing a single entry returns a &lt;a href=&quot;arrays.scalars#numpy.void&quot;&gt;&lt;code&gt;numpy.void&lt;/code&gt;&lt;/a&gt; object if none of the fields are masked, or a 0d masked array with the same dtype as the initial array if at least one of the fields is masked.</source>
          <target state="translated">如果被屏蔽的数组具有命名字段，如果没有一个字段被屏蔽，则访问单个条目将返回&lt;a href=&quot;arrays.scalars#numpy.void&quot;&gt; &lt;code&gt;numpy.void&lt;/code&gt; &lt;/a&gt;对象；如果至少一个字段被屏蔽，则访问具有与初始数组相同的dtype的0d被屏蔽的数组。</target>
        </trans-unit>
        <trans-unit id="2fd0d252831ab8d15d091d4ef1abf6e28cded875" translate="yes" xml:space="preserve">
          <source>If the masked array has named fields, accessing a single entry returns a &lt;code&gt;numpy.void&lt;/code&gt; object if none of the fields are masked, or a 0d masked array with the same dtype as the initial array if at least one of the fields is masked.</source>
          <target state="translated">如果被屏蔽的数组具有命名字段，则如果没有一个字段被屏蔽，则访问单个条目将返回 &lt;code&gt;numpy.void&lt;/code&gt; 对象；如果至少一个字段被屏蔽，则访问具有与初始数组相同的dtype的0d被屏蔽的数组。</target>
        </trans-unit>
        <trans-unit id="ddd5cbab3c6e64e2766e2597df7dd32b3c4a768b" translate="yes" xml:space="preserve">
          <source>If the mode is a &amp;ldquo;write&amp;rdquo; mode, then this is the version of the file format used to create the file. None means use the oldest supported version that is able to store the data. Default: None</source>
          <target state="translated">如果该模式是&amp;ldquo;写入&amp;rdquo;模式，则这是用于创建文件的文件格式的版本。&amp;ldquo;无&amp;rdquo;表示使用能够存储数据的最早的受支持版本。默认值：无</target>
        </trans-unit>
        <trans-unit id="8ec6f09c123aa3a76dc4dc9103d999ab337134eb" translate="yes" xml:space="preserve">
          <source>If the mode is constant filling (&lt;code&gt;NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING&lt;/code&gt;), fill_value should point to an array object which holds the filling value (the first item will be the filling value if the array contains more than one item). For other cases, fill_value may be NULL.</source>
          <target state="translated">如果模式是恒定填充（ &lt;code&gt;NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING&lt;/code&gt; ），则fill_value应该指向一个保存填充值的数组对象（如果数组包含多个项目，则第一项将是填充值）。对于其他情况，fill_value可以为NULL。</target>
        </trans-unit>
        <trans-unit id="510c4eb8a3d20ab4214058c75f9744c994e75f43" translate="yes" xml:space="preserve">
          <source>If the mode is constant filling (NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING), fill_value should point to an array object which holds the filling value (the first item will be the filling value if the array contains more than one item). For other cases, fill_value may be NULL.</source>
          <target state="translated">如果模式是恒定填充(NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING),fill_value应该指向一个持有填充值的数组对象(如果数组中包含多个项目,则第一个项目将是填充值)。对于其他情况,fill_value可以是NULL。</target>
        </trans-unit>
        <trans-unit id="be7395567c47ed030147671e19ef0b8f24978bfe" translate="yes" xml:space="preserve">
          <source>If the name is suffixed with the &amp;ldquo;?&amp;rdquo; modifier, the dimension is a core dimension only if it exists on all inputs and outputs that share it; otherwise it is ignored (and replaced by a dimension of size 1 for the elementary function).</source>
          <target state="translated">如果名称后缀&amp;ldquo;？&amp;rdquo; 修改器，只有在共享该维度的所有输入和输出中都存在该维度时，该维度才是核心维度；否则，它将被忽略（并为基本函数替换为尺寸为1的尺寸）。</target>
        </trans-unit>
        <trans-unit id="c3d1c518bb585ba44b9ba4aaf335820db98fa4f5" translate="yes" xml:space="preserve">
          <source>If the new array is larger than the original array, then the new array is filled with repeated copies of &lt;code&gt;a&lt;/code&gt;. Note that this behavior is different from a.resize(new_shape) which fills with zeros instead of repeated copies of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">如果新数组大于原始数组，则新数组将填充 &lt;code&gt;a&lt;/code&gt; 的重复副本。请注意，这种行为是从a.resize（new_shape）不同，其用零代替重复副本填充 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5041b424abd93910d43bf1d34adce8cb0f61f85" translate="yes" xml:space="preserve">
          <source>If the number of objects in the selection tuple is less than &lt;em&gt;N&lt;/em&gt; , then &lt;code&gt;:&lt;/code&gt; is assumed for any subsequent dimensions.</source>
          <target state="translated">如果选择元组中的对象数小于&lt;em&gt;N&lt;/em&gt;，则对于任何后续维，均假定 &lt;code&gt;:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f2a8e76e80cc97243c0461015d68ab374ad3374" translate="yes" xml:space="preserve">
          <source>If the number of objects in the selection tuple is less than &lt;em&gt;N&lt;/em&gt;, then &lt;code&gt;:&lt;/code&gt; is assumed for any subsequent dimensions.</source>
          <target state="translated">如果选择元组中的对象数小于&lt;em&gt;N&lt;/em&gt;，则对于任何后续维，均假定 &lt;code&gt;:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2928aac7d9000dc7b0628e4b095667d7efc04498" translate="yes" xml:space="preserve">
          <source>If the object in question is compiled in a language other than Python, using &lt;code&gt;??&lt;/code&gt; will return the same information as &lt;code&gt;?&lt;/code&gt;. You&amp;rsquo;ll find this with a lot of built-in objects and types, for example:</source>
          <target state="translated">如果所讨论的对象是用Python以外的语言编译的，请使用 &lt;code&gt;??&lt;/code&gt; 。将返回与相同的信息 &lt;code&gt;?&lt;/code&gt; 。您会发现许多内置对象和类型，例如：</target>
        </trans-unit>
        <trans-unit id="c5a6c4456ec6f4292b9cf18dc4d579bb22a84db3" translate="yes" xml:space="preserve">
          <source>If the object provided is an array, this function traverses the chain of &lt;code&gt;base&lt;/code&gt; pointers so that each array points to the owner of the memory directly. Once the base is set, it may not be changed to another value.</source>
          <target state="translated">如果提供的对象是数组，则此函数将遍历 &lt;code&gt;base&lt;/code&gt; 指针链，以便每个数组直接指向内存的所有者。一旦设置了基准，就不能将其更改为另一个值。</target>
        </trans-unit>
        <trans-unit id="89a89c71a1b9f2da8de85eabab619e5820532ff8" translate="yes" xml:space="preserve">
          <source>If the offsets of the fields and itemsize of a structured array satisfy the alignment conditions, the array will have the &lt;code&gt;ALIGNED&lt;/code&gt;&lt;a href=&quot;../reference/generated/numpy.ndarray.flags#numpy.ndarray.flags&quot;&gt;&lt;code&gt;flag&lt;/code&gt;&lt;/a&gt; set.</source>
          <target state="translated">如果结构化数组的字段和项目大小的偏移量满足对齐条件，则该数组将设置 &lt;code&gt;ALIGNED&lt;/code&gt; &lt;a href=&quot;../reference/generated/numpy.ndarray.flags#numpy.ndarray.flags&quot;&gt; &lt;code&gt;flag&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="657e1806ea99b60e1959c9ce313bdaa2fd70aa64" translate="yes" xml:space="preserve">
          <source>If the operand is flagged as write-only and a copy is needed, an uninitialized temporary array will be created and then copied to back to &lt;code&gt;op[i]&lt;/code&gt; on calling &lt;code&gt;NpyIter_Deallocate&lt;/code&gt;, instead of doing the unnecessary copy operation.</source>
          <target state="translated">如果操作数被标记为只写且需要复制，则将创建未初始化的临时数组，然后在调用 &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; 时将其复制回 &lt;code&gt;op[i]&lt;/code&gt; ，而不执行不必要的复制操作。</target>
        </trans-unit>
        <trans-unit id="17f4400245338f1e4a33ed23afc91ef7ab8c40c6" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; is given, only the first &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; occurrences are replaced.</source>
          <target state="translated">如果给出了可选的参数&lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;，则仅替换第一个出现的&lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="650baf4400147a0e58c70982764ea43290cfecc2" translate="yes" xml:space="preserve">
          <source>If the package is not found.</source>
          <target state="translated">如果找不到包。</target>
        </trans-unit>
        <trans-unit id="2ad175da47137fbc79b21402b2a0b69af4d4bc0f" translate="yes" xml:space="preserve">
          <source>If the position of iter is changed, any subsequent call to PyArrayNeighborhoodIter_Next is undefined behavior, and PyArrayNeighborhoodIter_Reset must be called.</source>
          <target state="translated">如果改变了iter的位置,后续对PyArrayNeighborhoodIter_Next的任何调用都是未定义的行为,必须调用PyArrayNeighborhoodIter_Reset。</target>
        </trans-unit>
        <trans-unit id="66cca6496635da39ce18c4666654d2018c778c20" translate="yes" xml:space="preserve">
          <source>If the question is broad, narrow and redirect it</source>
          <target state="translated">如果问题宽泛,则要缩小范围,调整方向</target>
        </trans-unit>
        <trans-unit id="16e630a04286a25caaca20cb641690b37ba91ed8" translate="yes" xml:space="preserve">
          <source>If the release series is a new one, you will need to add a new section to the &lt;code&gt;doc/build/merge/index.html&lt;/code&gt; front page just after the &amp;ldquo;insert here&amp;rdquo; comment:</source>
          <target state="translated">如果该发行系列是新发行的，则需要在&amp;ldquo;在此处插入&amp;rdquo;注释之后的 &lt;code&gt;doc/build/merge/index.html&lt;/code&gt; 主页中添加一个新部分：</target>
        </trans-unit>
        <trans-unit id="8c927b8ff30da3cc5f4b149881b61cbe3118f463" translate="yes" xml:space="preserve">
          <source>If the requested data type is in non-native byte order, the NBO flag overrides it and the requested data type is converted to be in native byte order.</source>
          <target state="translated">如果所请求的数据类型为非本地字节顺序,NBO标志将覆盖它,所请求的数据类型将被转换为本地字节顺序。</target>
        </trans-unit>
        <trans-unit id="8a5c6764b6f67871837f5bb9b64736c18fe7a7ad" translate="yes" xml:space="preserve">
          <source>If the returned coefficients are &lt;code&gt;c&lt;/code&gt;, then</source>
          <target state="translated">如果返回的系数为 &lt;code&gt;c&lt;/code&gt; ，则</target>
        </trans-unit>
        <trans-unit id="054023bbbbd71a4d456dd16da82bfb709a02f2cc" translate="yes" xml:space="preserve">
          <source>If the second argument is 1-D, it is promoted to a matrix by appending a 1 to its dimensions. After matrix multiplication the appended 1 is removed.</source>
          <target state="translated">如果第二个参数是1-D,则通过在其维度上追加1,将其提升为矩阵。矩阵乘法后,去掉附加的1。</target>
        </trans-unit>
        <trans-unit id="b4b38312a537fa220f815af5dcf5f4139bad3681" translate="yes" xml:space="preserve">
          <source>If the selection tuple has all entries &lt;code&gt;:&lt;/code&gt; except the &lt;em&gt;p&lt;/em&gt;-th entry which is a slice object &lt;code&gt;i:j:k&lt;/code&gt;, then the returned array has dimension &lt;em&gt;N&lt;/em&gt; formed by concatenating the sub-arrays returned by integer indexing of elements &lt;em&gt;i&lt;/em&gt;, &lt;em&gt;i+k&lt;/em&gt;, &amp;hellip;, &lt;em&gt;i + (m - 1) k &amp;lt; j&lt;/em&gt;,</source>
          <target state="translated">如果选择元组具有所有条目 &lt;code&gt;:&lt;/code&gt; 除第&lt;em&gt;p&lt;/em&gt;个条目（它是切片对象 &lt;code&gt;i:j:k&lt;/code&gt; )之外，则返回数组的维数&lt;em&gt;N&lt;/em&gt;是通过串联元素&lt;em&gt;i&lt;/em&gt;，&lt;em&gt;i + k的&lt;/em&gt;整数索引返回的子数组而形成的，&amp;hellip;，&lt;em&gt;i +（m-1）k &amp;lt;j&lt;/em&gt;，</target>
        </trans-unit>
        <trans-unit id="203e38312fd98260c8d96e3f0a471d9a5a4a4689" translate="yes" xml:space="preserve">
          <source>If the shapes are not compatible and cannot be broadcast according to NumPy&amp;rsquo;s broadcasting rules.</source>
          <target state="translated">如果形状不兼容并且无法根据NumPy的广播规则进行广播。</target>
        </trans-unit>
        <trans-unit id="9a652cfa7a533eb64735eb374de6f3a4977f5b9c" translate="yes" xml:space="preserve">
          <source>If the spacing between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; for one or more elements is larger than &lt;code&gt;nulp&lt;/code&gt;.</source>
          <target state="translated">如果一个或多个元素的 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 之间的间距大于 &lt;code&gt;nulp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3600ee510b36714644dcc89a19bb177b5b6c4ba7" translate="yes" xml:space="preserve">
          <source>If the string is not the correct size to satisfy the requested &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">如果字符串的大小不正确，不能满足要求的&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8431a3b44693b10770bc98218be6d44b926dbd16" translate="yes" xml:space="preserve">
          <source>If the transition to C++ goes through it is possible that this form will be relaxed so that short class methods meant to be inlined can have the return type on the same line as the function name. However, that is yet to be determined.</source>
          <target state="translated">如果向C++的过渡顺利进行,这种形式有可能会被放宽,这样短类方法的内联类型就可以和函数名放在同一行。不过,这一点还有待确定。</target>
        </trans-unit>
        <trans-unit id="ebc3886c14d49cd40506d4084002663f28dbcdd3" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;x&lt;/code&gt; is unsigned, then the output type is the unsigned platform integer:</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 的类型是无符号的，则输出类型是无符号的平台整数：</target>
        </trans-unit>
        <trans-unit id="183bc4d9ba8fd4894a95c0f09db6946e16642c92" translate="yes" xml:space="preserve">
          <source>If the type of the input is complex.</source>
          <target state="translated">如果输入的类型是复杂的。</target>
        </trans-unit>
        <trans-unit id="95366e62fbbbe64ba41cdcaa0c22be8d3f384cd4" translate="yes" xml:space="preserve">
          <source>If the type of the input is float or complex.</source>
          <target state="translated">如果输入的类型是浮点数或复数。</target>
        </trans-unit>
        <trans-unit id="25291949b6396c31462d4c34b8e8b5c2797cb90a" translate="yes" xml:space="preserve">
          <source>If the ufunc has 2 inputs and 1 output and the second input is an Object array then a special-case check is performed so that NotImplemented is returned if the second input is not an ndarray, has the __array_priority__ attribute, and has an __r{op}__ special method. In this way, Python is signaled to give the other object a chance to complete the operation instead of using generic object-array calculations. This allows (for example) sparse matrices to override the multiplication operator 1-D loop.</source>
          <target state="translated">如果ufunc有2个输入和1个输出,并且第二个输入是一个对象数组,那么就会进行特殊情况下的检查,所以如果第二个输入不是ndarray,有__array_priority__属性,并且有__r{op}__特殊方法,就会返回NotImplemented。通过这种方式,Python 会发出信号,让另一个对象有机会完成操作,而不是使用通用的对象-数组计算。这允许(例如)稀疏矩阵覆盖乘法运算符 1-D 循环。</target>
        </trans-unit>
        <trans-unit id="a4dffd94a98e9a9ee0037afd472e661e6232061e" translate="yes" xml:space="preserve">
          <source>If the underlying data is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it is returned as such.</source>
          <target state="translated">如果基础数据是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt;的子类，则将其返回。</target>
        </trans-unit>
        <trans-unit id="c8138c9410f7b3ce9c5c6bb9d0523e6e1ea7bd8e" translate="yes" xml:space="preserve">
          <source>If the underlying data is a subclass of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it is returned as such.</source>
          <target state="translated">如果基础数据是&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt;的子类，则将其返回。</target>
        </trans-unit>
        <trans-unit id="10f03c3143f8af1fee84b593563d21e127566799" translate="yes" xml:space="preserve">
          <source>If the user tries to use any numpy functions not included in &lt;code&gt;HANDLED_FUNCTIONS&lt;/code&gt;, a &lt;code&gt;TypeError&lt;/code&gt; will be raised by numpy, indicating that this operation is not supported. For example, concatenating two &lt;code&gt;DiagonalArrays&lt;/code&gt; does not produce another diagonal array, so it is not supported.</source>
          <target state="translated">如果用户尝试使用 &lt;code&gt;HANDLED_FUNCTIONS&lt;/code&gt; 中未包含的任何numpy函数，则numpy会引发 &lt;code&gt;TypeError&lt;/code&gt; ，指示不支持此操作。例如，连接两个 &lt;code&gt;DiagonalArrays&lt;/code&gt; 不会产生另一个对角线数组，因此不支持它。</target>
        </trans-unit>
        <trans-unit id="23122d3c8d35684d3c1d392886f730d15f172384" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果值不是默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 将传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;子类的&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt;方法。如果子类方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="2abfa832de7674bd2d08ad1f7e2b845f18a0059c" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果该值不是默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 将传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;子类的&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt;方法。如果子类方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="fb8acc52d13221f0fba6edb05a42e80cbebd0a2e" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; methods of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">如果值不是默认值，则 &lt;code&gt;keepdims&lt;/code&gt; 将传递给&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;子类的&lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;方法。如果子类方法未实现 &lt;code&gt;keepdims&lt;/code&gt; ,则将引发任何异常。</target>
        </trans-unit>
        <trans-unit id="287f0d6b5f9e62921d595f7d469377b448c9303e" translate="yes" xml:space="preserve">
          <source>If there are many steps, break them up</source>
          <target state="translated">如果有很多步骤,就把它们分开</target>
        </trans-unit>
        <trans-unit id="33c6901ff2ee0db95c77f2b313983f44526bb314" translate="yes" xml:space="preserve">
          <source>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt;&lt;code&gt;PyArray_PromoteTypes&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">如果仅存在标量或标量的最大类别高于数组的最大类别，则将数据类型与&lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt; &lt;code&gt;PyArray_PromoteTypes&lt;/code&gt; &lt;/a&gt;组合以生成返回值。</target>
        </trans-unit>
        <trans-unit id="33fe4c771f7142c020971d30614039b35a541395" translate="yes" xml:space="preserve">
          <source>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">如果仅存在标量，或者标量的最大类别高于数组的最大类别，则将数据类型与&lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt;组合以产生返回值。</target>
        </trans-unit>
        <trans-unit id="713f3b36701faad5c729c8225f4c0508fcfe41f1" translate="yes" xml:space="preserve">
          <source>If there is no dictionary passed in or &lt;code&gt;vardict&lt;/code&gt; is None then returns NumPy arrays in the globals() dictionary (all NumPy arrays in the namespace).</source>
          <target state="translated">如果没有传入字典，或者 &lt;code&gt;vardict&lt;/code&gt; 为None，则在globals（）字典中返回NumPy数组（名称空间中的所有NumPy数组）。</target>
        </trans-unit>
        <trans-unit id="d0c11d30de5e96bdaa85cb78bb53dddd3ba03ebc" translate="yes" xml:space="preserve">
          <source>If there is no library with the expected extension, or the library is defective and cannot be loaded.</source>
          <target state="translated">如果没有预期的扩展库,或者库有缺陷,无法加载。</target>
        </trans-unit>
        <trans-unit id="ef27bb26cd9e20ec5eb81bab137d2b6e00a224b0" translate="yes" xml:space="preserve">
          <source>If there is only one Boolean array and no integer indexing array present, this is straight forward. Care must only be taken to make sure that the boolean index has &lt;em&gt;exactly&lt;/em&gt; as many dimensions as it is supposed to work with.</source>
          <target state="translated">如果仅存在一个布尔数组，而没有整数索引数组，则这很简单。必须注意只能采取以确保布尔指数具有&lt;em&gt;完全相同&lt;/em&gt;的许多方面，它应该是与工作。</target>
        </trans-unit>
        <trans-unit id="e046df75fb04a45aea0ca0b9e3343d606d4ffa89" translate="yes" xml:space="preserve">
          <source>If there&amp;rsquo;s related background (tutorial, explanation, reference, alternative approach), bring it to the user&amp;rsquo;s attention with a link (&amp;ldquo;Directions from Route 7,&amp;rdquo; &amp;ldquo;Why so few filling stations?&amp;rdquo;).</source>
          <target state="translated">如果有相关背景（教程，解释，参考，替代方法），请通过链接（&amp;ldquo;路线7的方向&amp;rdquo;，&amp;ldquo;为什么加油站为什么这么少&amp;rdquo;）引起用户注意。</target>
        </trans-unit>
        <trans-unit id="6e268d3c7b0192c893825d9fa07e4e49b28360ad" translate="yes" xml:space="preserve">
          <source>If these arrays are all collected in a structured array, then &lt;a href=&quot;#c.PyArray_Sort&quot;&gt;&lt;code&gt;PyArray_Sort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can also be used to sort the array directly.</source>
          <target state="translated">如果所有这些数组都收集在一个结构化数组中，则&lt;a href=&quot;#c.PyArray_Sort&quot;&gt; &lt;code&gt;PyArray_Sort&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）也可用于直接对该数组排序。</target>
        </trans-unit>
        <trans-unit id="54dc9b5be81c958064f5d558fe01980eec4eadde" translate="yes" xml:space="preserve">
          <source>If these conditions are not met, a &lt;code&gt;ValueError: operands could not be broadcast together&lt;/code&gt; exception is thrown, indicating that the arrays have incompatible shapes. The size of the resulting array is the size that is not 1 along each axis of the inputs.</source>
          <target state="translated">如果不满足这些条件，则将引发 &lt;code&gt;ValueError: operands could not be broadcast together&lt;/code&gt; 异常，这表明数组的形状不兼容。所得数组的大小沿输入的每个轴的大小不为1。</target>
        </trans-unit>
        <trans-unit id="4b5797d27d90ecc738ae241c7f2d88131ab4d780" translate="yes" xml:space="preserve">
          <source>If these conditions hold, &lt;code&gt;__array_function__&lt;/code&gt; should return the result from calling its implementation for &lt;code&gt;func(*args, **kwargs)&lt;/code&gt;. Otherwise, it should return the sentinel value &lt;code&gt;NotImplemented&lt;/code&gt;, indicating that the function is not implemented by these types.</source>
          <target state="translated">如果这些条件成立，则 &lt;code&gt;__array_function__&lt;/code&gt; 应该从调用 &lt;code&gt;func(*args, **kwargs)&lt;/code&gt; 实现中返回结果。否则，它应该返回前哨值 &lt;code&gt;NotImplemented&lt;/code&gt; ，指示该功能不是由这些类型实现的。</target>
        </trans-unit>
        <trans-unit id="c80ca8262eeedd9bef78dbd28fb2dc07a4582c48" translate="yes" xml:space="preserve">
          <source>If this array does not own its own memory, then base points to the Python object that owns it (perhaps another array object)</source>
          <target state="translated">如果这个数组没有自己的内存,那么base指向拥有它的Python对象(可能是另一个数组对象)</target>
        </trans-unit>
        <trans-unit id="f79009d9f8b9e9859082a3efe68d074e3e908ff8" translate="yes" xml:space="preserve">
          <source>If this array has the (deprecated) &lt;a href=&quot;array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set, then this array is a working copy of a &amp;ldquo;misbehaved&amp;rdquo; array.</source>
          <target state="translated">如果此阵列设置了（不建议使用的）&lt;a href=&quot;array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;标志，则此阵列是&amp;ldquo;行为不当&amp;rdquo;阵列的工作副本。</target>
        </trans-unit>
        <trans-unit id="f63b91f81d86b6356e230f230ee7da044adca895" translate="yes" xml:space="preserve">
          <source>If this array has the (deprecated) &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set, then this array is a working copy of a &amp;ldquo;misbehaved&amp;rdquo; array.</source>
          <target state="translated">如果此阵列设置了（不建议使用的）&lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;标志，则此阵列是&amp;ldquo;行为不当&amp;rdquo;阵列的工作副本。</target>
        </trans-unit>
        <trans-unit id="2e1498e4add4060095cafec2d44c32b17e6ac395" translate="yes" xml:space="preserve">
          <source>If this condition is not met, a &lt;code&gt;ValueError('frames are not aligned')&lt;/code&gt; exception is thrown indicating that the arrays have incompatible shapes. The size of the result array created by broadcast operations is the maximum size along each dimension from the input arrays. Note that the rule does not say anything about the two arrays needing to have the same number of dimensions. So, for example, if you have a 256 x 256 x 3 array of RGB values, and you want to scale each color in the image by a different value, you can multiply the image by a one-dimensional array with 3 values. Lining up the sizes of the trailing axes of these arrays according to the broadcast rule shows that they are compatible</source>
          <target state="translated">如果不满足此条件，则 &lt;code&gt;ValueError('frames are not aligned')&lt;/code&gt; 异常，表明数组的形状不兼容。通过广播操作创建的结果数组的大小是沿输入数组中每个维度的最大大小。请注意，该规则并未说明需要具有相同维数的两个数组。因此，例如，如果您具有256 x 256 x 3的RGB值数组，并且想要按不同的值缩放图像中的每种颜色，则可以将图像乘以一维数组，并带有3个值。根据广播规则来排列这些数组的尾轴的大小表明它们是兼容的</target>
        </trans-unit>
        <trans-unit id="b54640e63d198f32f1e8358a28ce29bc6179e6f7" translate="yes" xml:space="preserve">
          <source>If this function returns true, the caller should also check the inner loop stride of the operand, because if that stride is 0, then only the first element of the innermost external loop is being visited for the first time.</source>
          <target state="translated">如果这个函数返回true,调用者还应该检查操作数的内循环跨度,因为如果该跨度为0,那么第一次只访问了最里面的外部循环的第一个元素。</target>
        </trans-unit>
        <trans-unit id="24a22c06faef1b4b61f295517b88ec97d1fc0a84" translate="yes" xml:space="preserve">
          <source>If this is &lt;code&gt;None&lt;/code&gt;, a reduction is performed over all the axes. If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">如果为 &lt;code&gt;None&lt;/code&gt; ，则对所有轴进行归约。如果这是一个整数元组，则在多个轴上执行归约，而不是像以前那样在单个轴或所有轴上执行归约。</target>
        </trans-unit>
        <trans-unit id="33f579e70b917db4493a3111bc7067b3dc4d2ff2" translate="yes" xml:space="preserve">
          <source>If this is None, a reduction is performed over all the axes. If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">如果是None,则在所有轴上进行缩减。如果是ints的元组,则在多个轴上进行还原,而不是像之前那样在单个轴或所有轴上进行还原。</target>
        </trans-unit>
        <trans-unit id="e4599c6e53b844db2376ed9e56ed7b49e63c6ec3" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a mean is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">如果这是一个ints的元组,则在多个轴上执行平均数,而不是像以前那样在一个轴或所有轴上执行。</target>
        </trans-unit>
        <trans-unit id="04767d2c5f5bbd4aab7323a751a31f226739a396" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">如果这是一个ints的元组,则会在多个轴上进行还原,而不是像之前那样在单个轴或所有轴上进行还原。</target>
        </trans-unit>
        <trans-unit id="e11ec2c8b461dd6b1390de16d518719c4d72ce55" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a standard deviation is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">如果这是一个ints的元组,则在多个轴上执行标准偏差,而不是像以前那样在一个轴或所有轴上执行标准偏差。</target>
        </trans-unit>
        <trans-unit id="cdec667610de13f7517139e9ece6f88d2d290194" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a variance is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">如果这是一个ints的元组,则会在多个轴上进行方差,而不是像之前那样在单个轴或所有轴上进行方差。</target>
        </trans-unit>
        <trans-unit id="d50012ee6c384ff0215bab7085fcf98c562bc452" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the count is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">如果这是一个ints的元组,则在多个轴上进行计数,而不是像以前那样在单个轴或所有轴上进行计数。</target>
        </trans-unit>
        <trans-unit id="c674e367c6b1c23d3abf3ddc4c5a7a14ff593b5a" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the maximum is selected over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">如果这是一个ints的元组,则在多个轴上选择最大值,而不是像以前那样选择单个轴或所有轴。</target>
        </trans-unit>
        <trans-unit id="a0756a48081a9a9cb1bfbc79e9843f0007e55c1d" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the minimum is selected over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">如果这是一个ints的元组,则在多个轴上选择最小值,而不是像以前那样选择单个轴或所有轴。</target>
        </trans-unit>
        <trans-unit id="7573da3ff564f7261e16d53ba17d4d7c25b6abc9" translate="yes" xml:space="preserve">
          <source>If this is anything but the default value it will be passed through (in the special case of an empty array) to the &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; function of the underlying array. If the array is a sub-class and &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; does not have the kwarg &lt;code&gt;keepdims&lt;/code&gt; this will raise a RuntimeError.</source>
          <target state="translated">如果这不是默认值，它将通过（在特殊情况下为空数组）传递给基础数组的&lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;函数。如果数组是子类，并且&lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt;没有kwarg &lt;code&gt;keepdims&lt;/code&gt; ,则将引发RuntimeError。</target>
        </trans-unit>
        <trans-unit id="25b5fe8a90e7aa983d49aeb7de528ca7dae28481" translate="yes" xml:space="preserve">
          <source>If this is non- &lt;code&gt;NULL&lt;/code&gt;, then this data-type descriptor is a C-style contiguous array of another data-type descriptor. In other-words, each element that this descriptor describes is actually an array of some other base descriptor. This is most useful as the data-type descriptor for a field in another data-type descriptor. The fields member should be &lt;code&gt;NULL&lt;/code&gt; if this is non- &lt;code&gt;NULL&lt;/code&gt; (the fields member of the base descriptor can be non- &lt;code&gt;NULL&lt;/code&gt; however).</source>
          <target state="translated">如果这是非 &lt;code&gt;NULL&lt;/code&gt; ，则此数据类型描述符是另一个数据类型描述符的C样式连续数组。换句话说，此描述符描述的每个元素实际上是一些其他基本描述符的数组。作为另一个数据类型描述符中字段的数据类型描述符，这是最有用的。字段构件应该是 &lt;code&gt;NULL&lt;/code&gt; ，如果这是不 &lt;code&gt;NULL&lt;/code&gt; （基描述符的字段构件可以是非 &lt;code&gt;NULL&lt;/code&gt; 不过）。</target>
        </trans-unit>
        <trans-unit id="9eef22bd67c15e89cde5d92734a40aa76d92e691" translate="yes" xml:space="preserve">
          <source>If this is non- &lt;code&gt;NULL&lt;/code&gt;, then this data-type descriptor is a C-style contiguous array of another data-type descriptor. In other-words, each element that this descriptor describes is actually an array of some other base descriptor. This is most useful as the data-type descriptor for a field in another data-type descriptor. The fields member should be &lt;code&gt;NULL&lt;/code&gt; if this is non- &lt;code&gt;NULL&lt;/code&gt; (the fields member of the base descriptor can be non- &lt;code&gt;NULL&lt;/code&gt; however). The &lt;code&gt;PyArray_ArrayDescr&lt;/code&gt; structure is defined using</source>
          <target state="translated">如果这是非 &lt;code&gt;NULL&lt;/code&gt; ，则此数据类型描述符是另一个数据类型描述符的C样式连续数组。换句话说，此描述符描述的每个元素实际上是一些其他基本描述符的数组。作为另一个数据类型描述符中字段的数据类型描述符，这是最有用的。字段构件应该是 &lt;code&gt;NULL&lt;/code&gt; ，如果这是不 &lt;code&gt;NULL&lt;/code&gt; （基描述符的字段构件可以是非 &lt;code&gt;NULL&lt;/code&gt; 不过）。该 &lt;code&gt;PyArray_ArrayDescr&lt;/code&gt; 结构使用定义</target>
        </trans-unit>
        <trans-unit id="2824d770011e81edcc48aaca00be40fe5064246e" translate="yes" xml:space="preserve">
          <source>If this is non-NULL, then this data-type-descriptor has fields described by a Python dictionary whose keys are names (and also titles if given) and whose values are tuples that describe the fields. Recall that a data-type-descriptor always describes a fixed-length set of bytes. A field is a named sub-region of that total, fixed-length collection. A field is described by a tuple composed of another data- type-descriptor and a byte offset. Optionally, the tuple may contain a title which is normally a Python string. These tuples are placed in this dictionary keyed by name (and also title if given).</source>
          <target state="translated">如果这个是非NULL,那么这个数据类型描述符的字段由Python字典描述,它的键是名称(如果给定,也包括标题),它的值是描述字段的元组。回想一下,一个数据类型描述符总是描述一个固定长度的字节集。字段是这个总的、固定长度的集合的一个命名的子区域。字段由另一个数据类型描述符和一个字节偏移量组成的元组来描述。可选地,元组可以包含一个标题,它通常是一个 Python 字符串。这些元组被放置在这个按名称(如果给定的话,还包括标题)键的字典中。</target>
        </trans-unit>
        <trans-unit id="0d86cba4ba7294ed9f7338e68f7b4f37b35c1557" translate="yes" xml:space="preserve">
          <source>If this is not desirable, then the array should be cast to a larger integer type first:</source>
          <target state="translated">如果不希望这样做,那么应该先将数组转为一个较大的整数类型。</target>
        </trans-unit>
        <trans-unit id="1ae38fd1d446748062bddf73d4866a0b315e1322" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;True&lt;/code&gt;, axes which are reduced over will be left in the result as a dimension with size one, so that the result will broadcast correctly against the inputs. This option can only be used for generalized ufuncs that operate on inputs that all have the same number of core dimensions and with outputs that have no core dimensions , i.e., with signatures like &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; or &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt;. If used, the location of the dimensions in the output can be controlled with &lt;code&gt;axes&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">如果将其设置为 &lt;code&gt;True&lt;/code&gt; ，则缩小的轴将作为尺寸为1的尺寸保留在结果中，以便可以正确地对输入广播结果。此选项仅可用于对所有具有相同核心尺寸的输入和没有核心尺寸的输出进行操作的通用ufunc，即具有 &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; 或 &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt; 。如果使用的话，在输出尺寸的位置就可以与被控制 &lt;code&gt;axes&lt;/code&gt; 和 &lt;code&gt;axis&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a675290349084bcd281fdfbd331891015b07aca9" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;True&lt;/code&gt;, axes which are reduced over will be left in the result as a dimension with size one, so that the result will broadcast correctly against the inputs. This option can only be used for generalized ufuncs that operate on inputs that all have the same number of core dimensions and with outputs that have no core dimensions, i.e., with signatures like &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; or &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt;. If used, the location of the dimensions in the output can be controlled with &lt;code&gt;axes&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">如果将其设置为 &lt;code&gt;True&lt;/code&gt; ，则缩小的轴将作为尺寸为1的尺寸保留在结果中，以便结果将正确地针对输入进行广播。此选项仅适用于对所有具有相同核心尺寸的输入和没有核心尺寸的输出（即具有 &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; 或 &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt; ）之类的签名）进行操作的通用ufunc。，m）-&amp;gt;（）。如果使用的话，在输出尺寸的位置就可以与被控制 &lt;code&gt;axes&lt;/code&gt; 和 &lt;code&gt;axis&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86e30e948710dc5b2db29b7dc82437914fd08740" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes that are counted are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</source>
          <target state="translated">如果设置为True,则被计算的轴将作为尺寸为1的尺寸留在结果中。有了这个选项,结果将正确地对着输入数组广播。</target>
        </trans-unit>
        <trans-unit id="74585a8bd339c6874f448a64d5fe0ba3642c10c6" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are normed over are left in the result as dimensions with size one. With this option the result will broadcast correctly against the original &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">如果将其设置为True，则归一化后的轴将保留为尺寸为1的尺寸。使用此选项，结果将针对原始 &lt;code&gt;x&lt;/code&gt; 正确广播。</target>
        </trans-unit>
        <trans-unit id="526b620d34688cc0c68a7ee67814781d453388f5" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the array.</source>
          <target state="translated">如果这个选项被设置为True,被缩减的轴将作为尺寸为1的尺寸留在结果中。使用这个选项,结果将正确地在数组中广播。</target>
        </trans-unit>
        <trans-unit id="015e500928e7c3f86f2c9b5121c746246fcd7a9f" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</source>
          <target state="translated">如果设置为True,被缩小的轴将作为尺寸为1的尺寸留在结果中。使用这个选项,结果将正确地在输入数组中广播。</target>
        </trans-unit>
        <trans-unit id="4d739fbcafd1b0f422661a57db4976a28b66ef61" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果将其设置为True，则缩小的轴将保留为尺寸为1的尺寸。使用此选项，结果将针对原始&lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt;正确广播。</target>
        </trans-unit>
        <trans-unit id="caf30df07a09579107c0faa5c9aaad9ad8721644" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">如果将其设置为True，则缩小的轴将保留为尺寸1的尺寸。使用此选项，结果将相对于原始 &lt;code&gt;a&lt;/code&gt; 正确广播。</target>
        </trans-unit>
        <trans-unit id="668624d9e02d10dc8924733d51742fcc1923286c" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">如果将其设置为True，则缩小的轴将保留为尺寸1的尺寸。使用此选项，结果将针对原始 &lt;code&gt;arr&lt;/code&gt; 正确广播。</target>
        </trans-unit>
        <trans-unit id="813c59426f99f6e2035686f0669f18c79ec2fc97" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">如果将其设置为True，则缩小的轴将保留为尺寸1的尺寸。使用此选项，结果将针对原始数组 &lt;code&gt;a&lt;/code&gt; 正确广播。</target>
        </trans-unit>
        <trans-unit id="28e1fe971ad9fdc32699e38250e14da5caf0bb91" translate="yes" xml:space="preserve">
          <source>If this value is anything but the default it is passed through as-is to the relevant functions of the sub-classes. If these functions do not have a &lt;code&gt;keepdims&lt;/code&gt; kwarg, a RuntimeError will be raised.</source>
          <target state="translated">如果该值不是默认值，它将按原样传递给子类的相关函数。如果这些函数没有 &lt;code&gt;keepdims&lt;/code&gt; kwarg，则会引发RuntimeError。</target>
        </trans-unit>
        <trans-unit id="dd4ec2a983c899a1017fcabb86ae5785ce4793ab" translate="yes" xml:space="preserve">
          <source>If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, etc.).</source>
          <target state="translated">如果为true（默认值），则复制对象。否则，仅当__array__返回副本，obj是嵌套序列或满足其他任何要求（&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;order&lt;/code&gt; 等）需要副本时，才进行副本。</target>
        </trans-unit>
        <trans-unit id="a6f5f638d5dadad294989835332dc69ea08c7e48" translate="yes" xml:space="preserve">
          <source>If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (&lt;code&gt;itemsize&lt;/code&gt;, unicode, &lt;code&gt;order&lt;/code&gt;, etc.).</source>
          <target state="translated">如果为true（默认值），则复制对象。否则，仅当__array__返回副本，obj为嵌套序列或满足其他任何要求（ &lt;code&gt;itemsize&lt;/code&gt; ，unicode， &lt;code&gt;order&lt;/code&gt; 等）需要副本时，才创建副本。</target>
        </trans-unit>
        <trans-unit id="7cfded7f1f4f8985525752f730c915f025bbc3bd" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">如果为true，则 &lt;code&gt;stop&lt;/code&gt; 是最后一个样本。否则，不包括在内。默认值为True。</target>
        </trans-unit>
        <trans-unit id="89363179f510b5ee9e2706f4cf949aff38e269d9" translate="yes" xml:space="preserve">
          <source>If true, sample from the interval [low, high] instead of the default [low, high) Defaults to False</source>
          <target state="translated">如果为真,从区间[低,高]取样,而不是默认的[低,高]默认为假。</target>
        </trans-unit>
        <trans-unit id="ade7c82d0d30db8fc4ef391480e9db75f4fe6678" translate="yes" xml:space="preserve">
          <source>If true, use an &amp;ldquo;aligned&amp;rdquo; memory layout, otherwise use a &amp;ldquo;packed&amp;rdquo; layout.</source>
          <target state="translated">如果为true，请使用&amp;ldquo;对齐&amp;rdquo;内存布局，否则请使用&amp;ldquo;打包&amp;rdquo;布局。</target>
        </trans-unit>
        <trans-unit id="3ef0d38b764385bc39d70e5ad26d095da7b5d3f0" translate="yes" xml:space="preserve">
          <source>If used with &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;, the inner loop for the caller may get larger chunks than would be possible without buffering, because of how the strides are laid out.</source>
          <target state="translated">如果与&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;一起使用，则调用程序的内部循环可能会获得比没有缓冲的情况更大的块，这是因为步幅的布局方式。</target>
        </trans-unit>
        <trans-unit id="e6e87a78ddc8c45866e59f696a01a91d82f291c2" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;x&lt;/code&gt; are beyond the bounds of &lt;code&gt;bins&lt;/code&gt;, 0 or &lt;code&gt;len(bins)&lt;/code&gt; is returned as appropriate.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 中的值超出 &lt;code&gt;bins&lt;/code&gt; 的范围，则将适当地返回0或 &lt;code&gt;len(bins)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adc126c0d80d4b8b968260ca8a9cd270dc0bc84e" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;x&lt;/code&gt; are such that they fall outside the bin range, attempting to index &lt;code&gt;bins&lt;/code&gt; with the indices that &lt;a href=&quot;#numpy.digitize&quot;&gt;&lt;code&gt;digitize&lt;/code&gt;&lt;/a&gt; returns will result in an IndexError.</source>
          <target state="translated">如果值 &lt;code&gt;x&lt;/code&gt; 是这样的，它们落在垃圾桶范围之外，试图指数 &lt;code&gt;bins&lt;/code&gt; 与指数是&lt;a href=&quot;#numpy.digitize&quot;&gt; &lt;code&gt;digitize&lt;/code&gt; &lt;/a&gt;回报率将导致IndexError。</target>
        </trans-unit>
        <trans-unit id="1061c821f897c8eeb5e101d31b7da69483d53c77" translate="yes" xml:space="preserve">
          <source>If we add another set of variables and observations &lt;code&gt;yarr&lt;/code&gt;, we can compute the row-wise Pearson correlation coefficients between the variables in &lt;code&gt;xarr&lt;/code&gt; and &lt;code&gt;yarr&lt;/code&gt;.</source>
          <target state="translated">如果添加另一组变量和观测值 &lt;code&gt;yarr&lt;/code&gt; ，则可以计算 &lt;code&gt;xarr&lt;/code&gt; 和 &lt;code&gt;yarr&lt;/code&gt; 中的变量之间的逐行Pearson相关系数。</target>
        </trans-unit>
        <trans-unit id="b223152b4e60f22e3efa048a66b57e829307cf69" translate="yes" xml:space="preserve">
          <source>If we designed &lt;code&gt;rms&lt;/code&gt;, we probably made it a routine that takes an input-only array of length &lt;code&gt;n&lt;/code&gt; of &lt;code&gt;double&lt;/code&gt; values called &lt;code&gt;seq&lt;/code&gt; and returns the root mean square. The default behavior of &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;, however, will be to create a wrapper function that compiles, but is nearly impossible to use from the scripting language in the way the C routine was intended.</source>
          <target state="translated">如果我们设计 &lt;code&gt;rms&lt;/code&gt; ，则可能使它成为一个例程，该例程接受长度为 &lt;code&gt;n&lt;/code&gt; 的 &lt;code&gt;double&lt;/code&gt; 值（称为 &lt;code&gt;seq&lt;/code&gt; )的仅输入数组，并返回均方根。但是，&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;的默认行为是创建一个包装函数，该函数可以进行编译，但几乎不可能以脚本语言的预期方式使用C例程。</target>
        </trans-unit>
        <trans-unit id="4a0434833c99496818e97fed2718d44b211d156f" translate="yes" xml:space="preserve">
          <source>If we do not know you yet, consider introducing yourself in &lt;a href=&quot;https://numpy.org/community/&quot;&gt;the mailing list or Slack&lt;/a&gt; before you start reviewing pull requests.</source>
          <target state="translated">如果我们还不认识您，请在开始审查请求请求之前考虑在&lt;a href=&quot;https://numpy.org/community/&quot;&gt;邮件列表或Slack中&lt;/a&gt;介绍您自己。</target>
        </trans-unit>
        <trans-unit id="4cd7980a2cd59fdcee19fe4e74bfa7516ad561f7" translate="yes" xml:space="preserve">
          <source>If we exit and restart our Python interpreter, we&amp;rsquo;ll see that we generate the same random numbers again:</source>
          <target state="translated">如果退出并重新启动Python解释器，则会看到我们再次生成了相同的随机数：</target>
        </trans-unit>
        <trans-unit id="5905e93ff273c8c1408a7481f0933e6b894f0ba3" translate="yes" xml:space="preserve">
          <source>If we look at the &lt;code&gt;nbcases_ma&lt;/code&gt; masked array, this is what we have:</source>
          <target state="translated">如果我们看一下 &lt;code&gt;nbcases_ma&lt;/code&gt; 掩码数组，这就是我们所拥有的：</target>
        </trans-unit>
        <trans-unit id="995e94e98f9bf00d5fa392b05fcaad89987b6cf9" translate="yes" xml:space="preserve">
          <source>If we operate on &lt;code&gt;arr&lt;/code&gt; with a numpy function, numpy will again use the &lt;code&gt;__array__&lt;/code&gt; interface to convert it to an array and then apply the function in the usual way.</source>
          <target state="translated">如果我们使用numpy函数对 &lt;code&gt;arr&lt;/code&gt; 进行操作，则numpy将再次使用 &lt;code&gt;__array__&lt;/code&gt; 接口将其转换为数组，然后以通常的方式应用该函数。</target>
        </trans-unit>
        <trans-unit id="a6db540dfc4c0d47c11450fd1091b665ccd4f2fc" translate="yes" xml:space="preserve">
          <source>If we subclass ndarray, we need to deal not only with explicit construction of our array type, but also &lt;a href=&quot;#view-casting&quot;&gt;View casting&lt;/a&gt; or &lt;a href=&quot;#new-from-template&quot;&gt;Creating new from template&lt;/a&gt;. NumPy has the machinery to do this, and it is this machinery that makes subclassing slightly non-standard.</source>
          <target state="translated">如果我们将ndarray子类化，则不仅需要处理数组类型的显式构造，还需要处理&lt;a href=&quot;#view-casting&quot;&gt;View强制转换&lt;/a&gt;或&lt;a href=&quot;#new-from-template&quot;&gt;从template创建new&lt;/a&gt;。NumPy拥有执行此操作的机制，正是这种机制使子类化稍微不符合标准。</target>
        </trans-unit>
        <trans-unit id="f97977f7edcb7ebd515a426a761fd048280b35b8" translate="yes" xml:space="preserve">
          <source>If we subclass ndarray, we need to deal not only with explicit construction of our array type, but also &lt;a href=&quot;#view-casting&quot;&gt;View casting&lt;/a&gt; or &lt;a href=&quot;#new-from-template&quot;&gt;Creating new from template&lt;/a&gt;. NumPy has the machinery to do this, and this machinery that makes subclassing slightly non-standard.</source>
          <target state="translated">如果我们将ndarray子类化，则不仅需要处理数组类型的显式构造，还需要处理&lt;a href=&quot;#view-casting&quot;&gt;View强制转换&lt;/a&gt;或&lt;a href=&quot;#new-from-template&quot;&gt;从template创建new&lt;/a&gt;。NumPy拥有执行此操作的机制，并且这种使子类化成为稍微不标准的机制。</target>
        </trans-unit>
        <trans-unit id="be3492efc8039f75947121fd3b30a1fa61841ee0" translate="yes" xml:space="preserve">
          <source>If we want to get the max and min at the same time, we can stack the indices first</source>
          <target state="translated">如果我们想同时得到最大和最小值,我们可以先把指数堆叠起来。</target>
        </trans-unit>
        <trans-unit id="0b08db0a15b738091c43209c89bb138ad98fa1a5" translate="yes" xml:space="preserve">
          <source>If writing to the value in &amp;lsquo;op&amp;rsquo; is desired, set the boolean &amp;lsquo;writeable&amp;rsquo; to 1. This raises an error when &amp;lsquo;op&amp;rsquo; is a scalar, list of lists, or other non-writeable &amp;lsquo;op&amp;rsquo;. This differs from passing &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; to PyArray_FromAny, where the writeable array may be a copy of the input.</source>
          <target state="translated">如果需要写入&amp;ldquo; op&amp;rdquo;中的值，请将布尔值&amp;ldquo; writeable&amp;rdquo;设置为1。如果&amp;ldquo; op&amp;rdquo;是标量，列表列表或其他不可写的&amp;ldquo; op&amp;rdquo;，则会引发错误。这与将&lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;传递给PyArray_FromAny 有所不同，在PyArray_FromAny中，可写数组可能是输入的副本。</target>
        </trans-unit>
        <trans-unit id="d75e358b391e7be55d7e5cd127dec8c0712acdf8" translate="yes" xml:space="preserve">
          <source>If you already have Matplotlib installed, you can import it with:</source>
          <target state="translated">如果你已经安装了Matplotlib,你可以用以下方法导入它。</target>
        </trans-unit>
        <trans-unit id="7cdef2e4118adffef01cdccc2d7928ddab94e772" translate="yes" xml:space="preserve">
          <source>If you already have Python, you can install NumPy with:</source>
          <target state="translated">如果你已经有了Python,你可以用以下方法安装NumPy。</target>
        </trans-unit>
        <trans-unit id="541c45cda5d06a312d0d288fb58df06c65cc4253" translate="yes" xml:space="preserve">
          <source>If you are a first-time contributor:</source>
          <target state="translated">如果你是第一次投稿。</target>
        </trans-unit>
        <trans-unit id="f5262e9ba4f1ea7a14023d90619c6e73faa9ab31" translate="yes" xml:space="preserve">
          <source>If you are a maintainer, and it is not obvious from the PR description, add a short explanation of what a branch did to the merge message and, if closing an issue, also add &amp;ldquo;Closes gh-123&amp;rdquo; where 123 is the issue number.</source>
          <target state="translated">如果您是维护者，并且从PR描述中看不出来，则对合并消息添加分支的简要说明，如果关闭问题，还添加&amp;ldquo; Closes gh-123&amp;rdquo;，其中123是问题编号。</target>
        </trans-unit>
        <trans-unit id="62b5ecb7cbb27b133b9256518444e81bd1675873" translate="yes" xml:space="preserve">
          <source>If you are a subsequent reviewer on an already approved PR, please use the same review method as for a new PR (focus on the larger issues, resist the temptation to add only a few nitpicks). If you have commit rights and think no more review is needed, merge the PR.</source>
          <target state="translated">如果你是一个已经批准的 PR 的后续审稿人,请使用与新 PR 相同的审稿方法(专注于较大的问题,抵制只添加一些小毛病的诱惑)。如果你有提交权,并且认为不需要更多的审查,请合并该 PR。</target>
        </trans-unit>
        <trans-unit id="df553e5d4398ed0e4dcd8bdb41c75c9a32748a9c" translate="yes" xml:space="preserve">
          <source>If you are constructing an array using the C API, and specifying your own memory, you should use the function &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt; to set the base to an object which owns the memory.</source>
          <target state="translated">如果要使用C API构造数组并指定自己的内存，则应使用函数&lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; &lt;/a&gt;将基设置为拥有内存的对象。</target>
        </trans-unit>
        <trans-unit id="348c2da24ae5fb5879e487ab21af4e5f5e066f22" translate="yes" xml:space="preserve">
          <source>If you are executing the commands above in the IPython shell, it might be necessary to use the command &lt;code&gt;plt.show()&lt;/code&gt; to show the image window.</source>
          <target state="translated">如果要在IPython Shell中执行上述命令，则可能有必要使用命令 &lt;code&gt;plt.show()&lt;/code&gt; 来显示图像窗口。</target>
        </trans-unit>
        <trans-unit id="c6a49d79de12888270772f40fca378141c156019" translate="yes" xml:space="preserve">
          <source>If you are executing the commands above in the IPython shell, it might be necessary to use the command &lt;code&gt;plt.show()&lt;/code&gt; to show the image window. Note also that we use a semicolon at the end of a line to suppress its output, but this is optional.</source>
          <target state="translated">如果要在IPython Shell中执行上述命令，则可能有必要使用命令 &lt;code&gt;plt.show()&lt;/code&gt; 来显示图像窗口。还要注意，我们在行的末尾使用分号来禁止其输出，但这是可选的。</target>
        </trans-unit>
        <trans-unit id="39a6add3139de0ce389e24494d0e34b85d48e6cd" translate="yes" xml:space="preserve">
          <source>If you are not a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend your class define special methods like &lt;code&gt;__add__&lt;/code&gt; and &lt;code&gt;__lt__&lt;/code&gt; that delegate to ufuncs just like ndarray does. An easy way to do this is to subclass from &lt;a href=&quot;generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt;&lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您不是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;的子类，我们建议您的类定义 &lt;code&gt;__add__&lt;/code&gt; 和 &lt;code&gt;__lt__&lt;/code&gt; 之类的特殊方法，就像ndarray 一样，它们委托给ufuncs。一种简单的方法是从&lt;a href=&quot;generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt; &lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt; 继承&lt;/a&gt;子类。</target>
        </trans-unit>
        <trans-unit id="7c035b2fcdae27121ab8105788f03a3cf705ba84" translate="yes" xml:space="preserve">
          <source>If you are unfamiliar with git/GitHub or the process of submitting a pull request (PR), check our &lt;a href=&quot;index#devindex&quot;&gt;Contributor Guide&lt;/a&gt;.</source>
          <target state="translated">如果您不熟悉git / GitHub或提交请求请求（PR）的过程，请查看我们的&lt;a href=&quot;index#devindex&quot;&gt;贡献者指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad4921cf970b61f597c75ff9a8df48494b979251" translate="yes" xml:space="preserve">
          <source>If you are unsure whether your tutorial is useful to the community, consider submitting an issue on GitHub suggesting it, or asking on the mailing list or Stack Overflow.</source>
          <target state="translated">如果你不确定你的教程对社区是否有用,可以考虑在GitHub上提交一个问题来提出建议,或者在邮件列表或Stack Overflow上询问。</target>
        </trans-unit>
        <trans-unit id="0e97815d05cf1a3f4e8ef4ccabd6db0958203378" translate="yes" xml:space="preserve">
          <source>If you are using a development setup, make sure to run &lt;code&gt;git clean -xdf&lt;/code&gt; to delete all files not under version control (be careful not to lose any modifications you made, e.g. &lt;code&gt;site.cfg&lt;/code&gt;). In many cases files from old builds may lead to incorrect builds.</source>
          <target state="translated">如果使用开发设置，请确保运行 &lt;code&gt;git clean -xdf&lt;/code&gt; 删除所有不受版本控制的文件（请注意不要丢失所做的任何修改，例如 &lt;code&gt;site.cfg&lt;/code&gt; ）。在许多情况下，旧版本的文件可能会导致错误的版本。</target>
        </trans-unit>
        <trans-unit id="b1cb5159432a421c78854c686fcae1e006f9ca62" translate="yes" xml:space="preserve">
          <source>If you are using your own image, this command might take a while to run, depending on the size of your image and your hardware. Don&amp;rsquo;t worry, this is normal! The SVD can be a pretty intensive computation.</source>
          <target state="translated">如果您使用自己的映像，则此命令可能需要一段时间才能运行，具体取决于映像和硬件的大小。别担心，这很正常！SVD可能是一个非常密集的计算。</target>
        </trans-unit>
        <trans-unit id="430c1a827d0587f2549b92fdcd570838e5c44e06" translate="yes" xml:space="preserve">
          <source>If you are writing a package that you&amp;rsquo;d like to become part of NumPy, please write the tests as you develop the package. Every Python module, extension module, or subpackage in the NumPy package directory should have a corresponding &lt;code&gt;test_&amp;lt;name&amp;gt;.py&lt;/code&gt; file. Pytest examines these files for test methods (named &lt;code&gt;test*&lt;/code&gt;) and test classes (named &lt;code&gt;Test*&lt;/code&gt;).</source>
          <target state="translated">如果您要编写的程序包希望成为NumPy的一部分，请在开发程序包时编写测试。NumPy软件包目录中的每个Python模块，扩展模块或子软件包均应具有相应的 &lt;code&gt;test_&amp;lt;name&amp;gt;.py&lt;/code&gt; 文件。Pytest检查这些文件中的测试方法（名为 &lt;code&gt;test*&lt;/code&gt; ）和测试类（名为 &lt;code&gt;Test*&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="773329737315bec4048498e2cb47eae44fac50c7" translate="yes" xml:space="preserve">
          <source>If you are writing a tutorial or how-to, we encourage you to use real images and data (provided they are appropriately licensed and available). This makes the material more engaging for readers, and choosing the right data can add pedagogical value to your content.</source>
          <target state="translated">如果您正在编写教程或攻略,我们鼓励您使用真实的图像和数据(只要它们得到适当的授权和可用)。这将使材料更吸引读者,选择正确的数据可以为您的内容增加教学价值。</target>
        </trans-unit>
        <trans-unit id="d4136f331004a4bb7cc67364f6afc023fd507b25" translate="yes" xml:space="preserve">
          <source>If you are writing an extension module that will include quite a bit of your own algorithmic code as well, then Cython is a good match. Among its features is the ability to easily and quickly work with multidimensional arrays.</source>
          <target state="translated">如果你要写一个扩展模块,其中也会包含不少自己的算法代码,那么Cython是一个很好的选择。在它的功能中,有一个特点就是能够方便快捷地处理多维数组。</target>
        </trans-unit>
        <trans-unit id="97bfbc5e92312fd81c84cc357b8b556f1c360029" translate="yes" xml:space="preserve">
          <source>If you are writing code that needs to support older versions of numpy, note that prior to 1.15, &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; was not a context manager and did not have a &lt;code&gt;close&lt;/code&gt; method. Instead it relied on the destructor to initiate the writeback of the buffer.</source>
          <target state="translated">如果编写的代码需要支持较旧版本的numpy，请注意，在1.15之前，&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;不是上下文管理器，并且没有 &lt;code&gt;close&lt;/code&gt; 方法。相反，它依靠析构函数来启动缓冲区的写回。</target>
        </trans-unit>
        <trans-unit id="36ae6f737ad58a255ae0b7d304bf552b5362f8bf" translate="yes" xml:space="preserve">
          <source>If you are writing the algorithm, then I recommend that you use the stride information contained in the array to access the elements of the array (the &lt;a href=&quot;../reference/c-api/array#c.PyArray_GetPtr&quot;&gt;&lt;code&gt;PyArray_GetPtr&lt;/code&gt;&lt;/a&gt; macros make this painless). Then, you can relax your requirements so as not to force a single-segment array and the data-copying that might result.</source>
          <target state="translated">如果您正在编写算法，则建议您使用数组中包含的步幅信息来访问数组的元素（&lt;a href=&quot;../reference/c-api/array#c.PyArray_GetPtr&quot;&gt; &lt;code&gt;PyArray_GetPtr&lt;/code&gt; &lt;/a&gt;宏使此操作很轻松）。然后，您可以放宽要求，以免强制执行单段阵列以及可能导致的数据复制。</target>
        </trans-unit>
        <trans-unit id="b55dd90ddf002e60cb33ced8fd77f1baf2f3e711" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t already comfortable with reading tutorials that contain a lot of code, you might not know how to interpret a code block that looks like this:</source>
          <target state="translated">如果您不习惯阅读包含很多代码的教程，则可能不知道如何解释如下所示的代码块：</target>
        </trans-unit>
        <trans-unit id="0aadabdedda0a7396088f7e7156f2221bf29f201" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t familiar with this style, it&amp;rsquo;s very easy to understand. If you see &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, you&amp;rsquo;re looking at &lt;strong&gt;input&lt;/strong&gt;, or the code that you would enter. Everything that doesn&amp;rsquo;t have &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; in front of it is &lt;strong&gt;output&lt;/strong&gt;, or the results of running your code. This is the style you see when you run &lt;code&gt;python&lt;/code&gt; on the command line, but if you&amp;rsquo;re using IPython, you might see a different style.</source>
          <target state="translated">如果您不熟悉这种风格，则很容易理解。如果看到 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; ，则说明正在查看&lt;strong&gt;input&lt;/strong&gt;或要输入的代码。前面没有 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 的所有内容都是&lt;strong&gt;output&lt;/strong&gt;或运行代码的结果。这是在命令行上运行 &lt;code&gt;python&lt;/code&gt; 时看到的样式，但是如果使用的是IPython，则可能会看到其他样式。</target>
        </trans-unit>
        <trans-unit id="bb14ac1edba829d3112a46c925f71b9aef58fe4d" translate="yes" xml:space="preserve">
          <source>If you begin with a 1D array like this one:</source>
          <target state="translated">如果你从像这样的一维数组开始。</target>
        </trans-unit>
        <trans-unit id="241e24cd0257dc01f27616c2644b10c2652843e7" translate="yes" xml:space="preserve">
          <source>If you can&amp;rsquo;t avoid or eliminate missing values, but don&amp;rsquo;t want to deal with &lt;a href=&quot;../reference/constants#numpy.nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt; (Not A Number) values in your operations.</source>
          <target state="translated">如果您无法避免或消除缺失的值，但又不想在操作中处理&lt;a href=&quot;../reference/constants#numpy.nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt;（非数字）值。</target>
        </trans-unit>
        <trans-unit id="50d785ffa376c738acba9fd3062d7ce8c3507854" translate="yes" xml:space="preserve">
          <source>If you construct an array by passing in your own memory buffer as a parameter, you need to set the array&amp;rsquo;s &lt;code&gt;base&lt;/code&gt; property to ensure the lifetime of the memory buffer is appropriate.</source>
          <target state="translated">如果通过传入自己的内存缓冲区作为参数来构造数组，则需要设置数组的 &lt;code&gt;base&lt;/code&gt; 属性以确保内存缓冲区的生存期合适。</target>
        </trans-unit>
        <trans-unit id="5a09672523495c2e56a3b155436551396bec1686" translate="yes" xml:space="preserve">
          <source>If you created this array &amp;ldquo;a&amp;rdquo;</source>
          <target state="translated">如果您创建此数组&amp;ldquo; a&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="72ea524f17d30ae2b5b06f8b246da402ecc0aab1" translate="yes" xml:space="preserve">
          <source>If you define &lt;code&gt;__array_ufunc__&lt;/code&gt;:</source>
          <target state="translated">如果定义 &lt;code&gt;__array_ufunc__&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ad02ce8758b2b7ef1353b5d6ceccf301d0d32341" translate="yes" xml:space="preserve">
          <source>If you depend on the current behavior, then we suggest copying the returned array explicitly, i.e., use &lt;code&gt;np.diagonal(a).copy()&lt;/code&gt; instead of just &lt;code&gt;np.diagonal(a)&lt;/code&gt;. This will work with both past and future versions of NumPy.</source>
          <target state="translated">如果依赖当前行为，则建议显式复制返回的数组，即，使用 &lt;code&gt;np.diagonal(a).copy()&lt;/code&gt; 而不是仅使用 &lt;code&gt;np.diagonal(a)&lt;/code&gt; 。这将适用于过去和将来的NumPy版本。</target>
        </trans-unit>
        <trans-unit id="e04ecd6da4be5a785c0ba7636ed164c9197444de" translate="yes" xml:space="preserve">
          <source>If you didn&amp;rsquo;t actually mess up but there are merge conflicts, you need to resolve those. This can be one of the trickier things to get right. For a good description of how to do this, see &lt;a href=&quot;https://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging#Basic-Merge-Conflicts&quot;&gt;this article on merging conflicts&lt;/a&gt;.</source>
          <target state="translated">如果您实际上并没有搞砸，但存在合并冲突，则需要解决这些冲突。这可能是正确的棘手事情之一。有关如何执行此操作的详细说明，请参阅&lt;a href=&quot;https://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging#Basic-Merge-Conflicts&quot;&gt;有关合并冲突的本文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e434a6791515ca1be095b9c944cc43b7244bf754" translate="yes" xml:space="preserve">
          <source>If you do this often, consider making CDN_URL and NPY_WHLS part of your default environment.</source>
          <target state="translated">如果你经常这样做,可以考虑将CDN_URL和NPY_WHLS作为默认环境的一部分。</target>
        </trans-unit>
        <trans-unit id="48d4a9d3c1a910573f5c99d8162fc661353211a4" translate="yes" xml:space="preserve">
          <source>If you do want to use Fortran ordering realize that there are two approaches to consider: 1) accept that the first index is just not the most rapidly changing in memory and have all your I/O routines reorder your data when going from memory to disk or visa versa, or use numpy&amp;rsquo;s mechanism for mapping the first index to the most rapidly varying data. We recommend the former if possible. The disadvantage of the latter is that many of numpy&amp;rsquo;s functions will yield arrays without Fortran ordering unless you are careful to use the &amp;lsquo;order&amp;rsquo; keyword. Doing this would be highly inconvenient.</source>
          <target state="translated">如果您确实想使用Fortran排序，请意识到有两种方法可供考虑：1）接受第一个索引并不是内存中变化最快的方法，并让所有I / O例程在从内存到磁盘的过程中对数据进行重新排序反之亦然，或者使用numpy的机制将第一个索引映射到变化最快的数据。如果可能，我们建议使用前者。后者的缺点是，除非小心使用'order'关键字，否则许多numpy函数都会产生没有Fortran排序的数组。这样做非常不方便。</target>
        </trans-unit>
        <trans-unit id="e095aad5306acb61c4cd71ef6f17e3d170477a48" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have Python yet, you might want to consider using &lt;a href=&quot;https://www.anaconda.com/&quot;&gt;Anaconda&lt;/a&gt;. It&amp;rsquo;s the easiest way to get started. The good thing about getting this distribution is the fact that you don&amp;rsquo;t need to worry too much about separately installing NumPy or any of the major packages that you&amp;rsquo;ll be using for your data analyses, like pandas, Scikit-Learn, etc.</source>
          <target state="translated">如果您还没有Python，则可能要考虑使用&lt;a href=&quot;https://www.anaconda.com/&quot;&gt;Anaconda&lt;/a&gt;。这是最简单的入门方法。获得这种分布的好处是，您不必担心单独安装NumPy或将用于数据分析的任何主要软件包，例如pandas，Scikit-Learn等。</target>
        </trans-unit>
        <trans-unit id="a32666f1e22aaef44f676905cda497776944f399" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; account, go to the &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; page, and make one.</source>
          <target state="translated">如果您没有&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;帐户，请转到&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;页面并创建一个。</target>
        </trans-unit>
        <trans-unit id="a5bbc2f6b8c16d724bb2e3ebb23419fa6ae79cb5" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a GitHub account, visit &lt;a href=&quot;https://github.com/join&quot;&gt;https://github.com/join&lt;/a&gt; to create one.</source>
          <target state="translated">如果您没有GitHub帐户，请访问&lt;a href=&quot;https://github.com/join&quot;&gt;https://github.com/join&lt;/a&gt;来创建一个。</target>
        </trans-unit>
        <trans-unit id="00332ddab35edaceba6aacb138a662dde934bdb6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t write to the array returned by this function, then you can just ignore all of the above.</source>
          <target state="translated">如果您不写此函数返回的数组，则可以忽略以上所有内容。</target>
        </trans-unit>
        <trans-unit id="ddf01261f92656913e0a2ec2a624205e1c2e4b27" translate="yes" xml:space="preserve">
          <source>If you forgot to make a backup branch:</source>
          <target state="translated">如果你忘了做一个备份分支。</target>
        </trans-unit>
        <trans-unit id="fe80a2730dc1732963891b3491f20ea69996dc7b" translate="yes" xml:space="preserve">
          <source>If you get a Python error that looks like the following:</source>
          <target state="translated">如果你得到一个类似下面的Python错误。</target>
        </trans-unit>
        <trans-unit id="a53df4d5bfbd08adf0a5725999a9e0795dcb81f8" translate="yes" xml:space="preserve">
          <source>If you have a collection of tests that must be run multiple times with minor variations, it can be helpful to create a base class containing all the common tests, and then create a subclass for each variation. Several examples of this technique exist in NumPy; below are excerpts from one in &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py&quot;&gt;numpy/linalg/tests/test_linalg.py&lt;/a&gt;:</source>
          <target state="translated">如果您有一组测试，这些测试必须在有较小的变体的情况下运行多次，那么创建包含所有通用测试的基类，然后为每个变体创建一个子类将很有帮助。NumPy中存在该技术的几个示例。以下是&lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py&quot;&gt;numpy / linalg / tests / test_linalg.py中的摘录&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="b76d68a8292694b360bf5a2e8b28bbbb6775f004" translate="yes" xml:space="preserve">
          <source>If you have already decided which type of document you want to write, you can check out the following specific guides:</source>
          <target state="translated">如果你已经决定了要写哪种类型的文档,你可以查看以下具体指南。</target>
        </trans-unit>
        <trans-unit id="edd73a9e41446ceec5844edddba90601c9a86d6a" translate="yes" xml:space="preserve">
          <source>If you have an array of datetime64 day values, and you want a count of how many of them are valid dates, you can do this:</source>
          <target state="translated">如果你有一个datetime64日值的数组,并且你想统计其中有多少是有效日期,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="afdea327e298d690859d2830125b0506072aa9c8" translate="yes" xml:space="preserve">
          <source>If you have made changes to files that have changed also upstream, this may generate merge conflicts that you need to resolve. See &lt;a href=&quot;#recovering-from-mess-up&quot;&gt;below&lt;/a&gt; for help in this case.</source>
          <target state="translated">如果您对也在上游更改的文件进行了更改，则可能会产生需要解决的合并冲突。在这种情况下，请参见&lt;a href=&quot;#recovering-from-mess-up&quot;&gt;下面&lt;/a&gt;的帮助。</target>
        </trans-unit>
        <trans-unit id="3940d12fada6e74d3a4f390741c7084734cc9f7c" translate="yes" xml:space="preserve">
          <source>If you have worked before with only one- or two-dimensional arrays in NumPy, you might use &lt;a href=&quot;../reference/generated/numpy.dot#numpy.dot&quot;&gt;&lt;code&gt;numpy.dot&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;numpy.matmul&lt;/code&gt;&lt;/a&gt; (or the &lt;code&gt;@&lt;/code&gt; operator) interchangeably. However, for n-dimensional arrays, they work in very different ways. For more details, check the documentation &lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;numpy.matmul&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果以前在NumPy中仅处理一维或二维数组，则可以&lt;a href=&quot;../reference/generated/numpy.dot#numpy.dot&quot;&gt; &lt;code&gt;numpy.dot&lt;/code&gt; &lt;/a&gt;使用numpy.dot和&lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;numpy.matmul&lt;/code&gt; &lt;/a&gt;（或 &lt;code&gt;@&lt;/code&gt; 运算符）。但是，对于n维数组，它们以非常不同的方式工作。有关更多详细信息，请查看文档&lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;numpy.matmul&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61245264d3565a00eccec23e4c121348aa40e38c" translate="yes" xml:space="preserve">
          <source>If you index &lt;code&gt;x&lt;/code&gt; at position 1 you get a structure:</source>
          <target state="translated">如果在位置1处索引 &lt;code&gt;x&lt;/code&gt; ，则会得到一个结构：</target>
        </trans-unit>
        <trans-unit id="19e171dd0ccd0c17916e231c961dda814be7cba5" translate="yes" xml:space="preserve">
          <source>If you just use Cython to compile a standard Python module, then you will get a C extension module that typically runs a bit faster than the equivalent Python module. Further speed increases can be gained by using the &lt;code&gt;cdef&lt;/code&gt; keyword to statically define C variables.</source>
          <target state="translated">如果仅使用Cython来编译标准的Python模块，那么您将获得一个C扩展模块，该模块的运行速度通常比等效的Python模块要快一些。通过使用 &lt;code&gt;cdef&lt;/code&gt; 关键字静态定义C变量，可以进一步提高速度。</target>
        </trans-unit>
        <trans-unit id="d4f3f5ddc9a07a1a97f869fb8e6afa7a875ab6d2" translate="yes" xml:space="preserve">
          <source>If you know you have boolean arguments, you can get away with using NumPy&amp;rsquo;s bitwise operators, but be careful with parentheses, like this: &lt;code&gt;z
= (x &amp;gt; 1) &amp;amp; (x &amp;lt; 2)&lt;/code&gt;. The absence of NumPy operator forms of &lt;code&gt;logical_and&lt;/code&gt; and &lt;code&gt;logical_or&lt;/code&gt; is an unfortunate consequence of Python&amp;rsquo;s design.</source>
          <target state="translated">如果您知道自己具有布尔参数，则可以使用NumPy的按位运算符，但请小心括号，例如： &lt;code&gt;z = (x &amp;gt; 1) &amp;amp; (x &amp;lt; 2)&lt;/code&gt; 。缺少NumPy运算符形式的 &lt;code&gt;logical_and&lt;/code&gt; 和 &lt;code&gt;logical_or&lt;/code&gt; 是Python设计的不幸结果。</target>
        </trans-unit>
        <trans-unit id="0c28db0c64cef3fce82c680e83d5a3bf5a7d6611" translate="yes" xml:space="preserve">
          <source>If you know you have boolean arguments, you can get away with using NumPy&amp;rsquo;s bitwise operators, but be careful with parentheses, like this: z = (x &amp;gt; 1) &amp;amp; (x &amp;lt; 2). The absence of NumPy operator forms of logical_and and logical_or is an unfortunate consequence of Python&amp;rsquo;s design.</source>
          <target state="translated">如果您知道自己具有布尔参数，则可以使用NumPy的按位运算符，但请小心括号，例如：z =（x&amp;gt; 1）＆（x &amp;lt;2）。缺少NumPy运算符形式的logical_and和logical_or是Python设计的不幸结果。</target>
        </trans-unit>
        <trans-unit id="b50bdabfd893e921c2545949ea3927871fd9123c" translate="yes" xml:space="preserve">
          <source>If you mess up during a rebase:</source>
          <target state="translated">如果你在复盘时搞砸了。</target>
        </trans-unit>
        <trans-unit id="d5b391b72fd29e26b5330f8bc73fd6e0406a58fe" translate="yes" xml:space="preserve">
          <source>If you need a stricter way to identify a &lt;em&gt;numerical&lt;/em&gt; scalar, use &lt;code&gt;isinstance(x, numbers.Number)&lt;/code&gt;, as that returns &lt;code&gt;False&lt;/code&gt; for most non-numerical elements such as strings.</source>
          <target state="translated">如果需要更严格的方法来标识&lt;em&gt;数字&lt;/em&gt;标量，请使用 &lt;code&gt;isinstance(x, numbers.Number)&lt;/code&gt; ，因为对于大多数非数字元素（例如字符串），该方法返回 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4cb8ac1ba0fb6fc334cc562794b2ebe83f971f7" translate="yes" xml:space="preserve">
          <source>If you need help writing replies in reviews, check out some &lt;a href=&quot;https://scikit-learn.org/stable/developers/tips.html#saved-replies&quot;&gt;Standard replies for reviewing&lt;/a&gt;.</source>
          <target state="translated">如果您需要在评论中撰写回复的帮助，请查看一些&lt;a href=&quot;https://scikit-learn.org/stable/developers/tips.html#saved-replies&quot;&gt;标准&lt;/a&gt;评论以进行评论。</target>
        </trans-unit>
        <trans-unit id="6b620559920ae0493b1df8c4590d21b79ff5570f" translate="yes" xml:space="preserve">
          <source>If you need to generate a good seed &amp;ldquo;offline&amp;rdquo;, then &lt;code&gt;SeedSequence().entropy&lt;/code&gt; or using &lt;code&gt;secrets.randbits(128)&lt;/code&gt; from the standard library are both convenient ways.</source>
          <target state="translated">如果需要生成良好的&amp;ldquo;离线&amp;rdquo;种子，则使用 &lt;code&gt;SeedSequence().entropy&lt;/code&gt; 或使用标准库中的secrets.randbits &lt;code&gt;secrets.randbits(128)&lt;/code&gt; 都是方便的方法。</target>
        </trans-unit>
        <trans-unit id="9dadc35707bb7693c411ca705b6a79a8fd4bc6a1" translate="yes" xml:space="preserve">
          <source>If you need to generate a plot for your values, it&amp;rsquo;s very simple with &lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;.</source>
          <target state="translated">如果您需要为值生成图，则使用&lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;非常简单。</target>
        </trans-unit>
        <trans-unit id="cd4f29a22f2d83f814cd7d3d9fed381be8da6e41" translate="yes" xml:space="preserve">
          <source>If you notice you messed up after the rebase:</source>
          <target state="translated">如果你注意到你搞砸了后的重垒。</target>
        </trans-unit>
        <trans-unit id="ee201455e7a9931a5a44547dd0593d53785f3676" translate="yes" xml:space="preserve">
          <source>If you obtained NumPy via git, get also the git submodules that contain additional parts required for building the documentation:</source>
          <target state="translated">如果你是通过git获得NumPy的,也可以获得git子模块,其中包含了构建文档所需的额外部分。</target>
        </trans-unit>
        <trans-unit id="fafc92af92f970e1f9bc871b99562e2a4dcbfd58" translate="yes" xml:space="preserve">
          <source>If you only had $150/month to pay towards the loan, how long would it take to pay-off a loan of $8,000 at 7% annual interest?</source>
          <target state="translated">如果你只有150元/月的贷款,按年息7%计算,需要多长时间才能还清8000元的贷款?</target>
        </trans-unit>
        <trans-unit id="f1851d09e17596b6fef1418fbf6cd4eb3f3c1218" translate="yes" xml:space="preserve">
          <source>If you only want to get the documentation, note that pre-built versions can be found at</source>
          <target state="translated">如果您只想获得文档,请注意,预构建的版本可以在以下网站找到</target>
        </trans-unit>
        <trans-unit id="cdaa058c528b9ed4b2670e6e57274ac82ee4b4cf" translate="yes" xml:space="preserve">
          <source>If you plan a new feature or API change, it&amp;rsquo;s wisest to first email the NumPy &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;mailing list&lt;/a&gt; asking for comment. If you haven&amp;rsquo;t heard back in a week, it&amp;rsquo;s OK to ping the list again.</source>
          <target state="translated">如果您计划新功能或API更改，最明智的做法是先通过电子邮件发送给NumPy&lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;邮件列表以&lt;/a&gt;征求评论。如果您一周没有收到回复，可以再次ping通该列表。</target>
        </trans-unit>
        <trans-unit id="4ba77d4ac4c0346cf08567fdade124408903e3ad" translate="yes" xml:space="preserve">
          <source>If you prefer, you can use your own image as you work through this tutorial. In order to transform your image into a NumPy array that can be manipulated, you can use the &lt;code&gt;imread&lt;/code&gt; function from the &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.html#module-matplotlib.pyplot&quot;&gt;&lt;code&gt;matplotlib.pyplot&lt;/code&gt;&lt;/a&gt; submodule. Alternatively, you can use the &lt;a href=&quot;https://imageio.readthedocs.io/en/stable/userapi.html#imageio.imread&quot;&gt;&lt;code&gt;imageio.imread&lt;/code&gt;&lt;/a&gt; function from the &lt;code&gt;imageio&lt;/code&gt; library. Be aware that if you use your own image, you&amp;rsquo;ll likely need to adapt the steps below. For more information on how images are treated when converted to NumPy arrays, see &lt;a href=&quot;https://scikit-image.org/docs/stable/user_guide/numpy_images.html&quot;&gt;A crash course on NumPy for images&lt;/a&gt; from the &lt;code&gt;scikit-image&lt;/code&gt; documentation.</source>
          <target state="translated">如果您愿意，可以在使用本教程时使用自己的图像。为了将图像转换为可以操纵的NumPy数组，可以使用&lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.html#module-matplotlib.pyplot&quot;&gt; &lt;code&gt;matplotlib.pyplot&lt;/code&gt; &lt;/a&gt;子模块中的 &lt;code&gt;imread&lt;/code&gt; 函数。另外，您也可以使用&lt;a href=&quot;https://imageio.readthedocs.io/en/stable/userapi.html#imageio.imread&quot;&gt; &lt;code&gt;imageio.imread&lt;/code&gt; &lt;/a&gt;从功能 &lt;code&gt;imageio&lt;/code&gt; 库。请注意，如果您使用自己的图像，则可能需要调整以下步骤。有关如何，当转换成NumPy的阵列的图像处理的详细信息，请参阅&lt;a href=&quot;https://scikit-image.org/docs/stable/user_guide/numpy_images.html&quot;&gt;上NumPy的甲速成为图像&lt;/a&gt;从 &lt;code&gt;scikit-image&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="163df9c9003b7c4450bb235f2c67b2a07c0207a6" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;f2py&lt;/code&gt; with no arguments, and the line &lt;code&gt;numpy Version&lt;/code&gt; at the end matches the NumPy version printed from &lt;code&gt;python -m numpy.f2py&lt;/code&gt;, then you can use the shorter version. If not, or if you cannot run &lt;code&gt;f2py&lt;/code&gt;, you should replace all calls to &lt;code&gt;f2py&lt;/code&gt; here with the longer version.</source>
          <target state="translated">如果您 &lt;code&gt;f2py&lt;/code&gt; 带任何参数运行f2py，并且末尾的 &lt;code&gt;numpy Version&lt;/code&gt; 行与从 &lt;code&gt;python -m numpy.f2py&lt;/code&gt; 打印的NumPy版本匹配，则可以使用较短的版本。如果不是，或者您无法运行 &lt;code&gt;f2py&lt;/code&gt; ，则应将此处的所有对 &lt;code&gt;f2py&lt;/code&gt; 的调用替换为较长的版本。</target>
        </trans-unit>
        <trans-unit id="e2ea4dd191a98ee740334a65dcfa6ac018c3ad8c" translate="yes" xml:space="preserve">
          <source>If you run across outside material that would be a useful addition to the NumPy docs, let us know by &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;opening an issue&lt;/a&gt;.</source>
          <target state="translated">如果您碰巧是NumPy文档的有用补充的外部材料，请&lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;打开一个问题&lt;/a&gt;让我们知道。</target>
        </trans-unit>
        <trans-unit id="c2f8a5ed085feb6d7cb818c6bb6a9239c65b61dd" translate="yes" xml:space="preserve">
          <source>If you run into a situation where a function or method is returning a pointer to an array, your best bet is to write your own version of the function to be wrapped, either with &lt;code&gt;%extend&lt;/code&gt; for the case of class methods or &lt;code&gt;%ignore&lt;/code&gt; and &lt;code&gt;%rename&lt;/code&gt; for the case of functions.</source>
          <target state="translated">如果遇到函数或方法返回指向数组的指针的情况，则最好的选择是编写自己要包装的函数版本，对于类方法，使用 &lt;code&gt;%extend&lt;/code&gt; 或 &lt;code&gt;%ignore&lt;/code&gt; 和 &lt;code&gt;%rename&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="2a7a60ee3a192da84e7197524a79fee3ab370312" translate="yes" xml:space="preserve">
          <source>If you see a good tutorial, how-to or explanation that is not included in the official documentation, you can suggest it to be added by &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;opening an issue on GitHub&lt;/a&gt;. Similarly, opening issues to suggest a tutorial, how-to or explanation that you can&amp;rsquo;t find anywhere is a great way to help the documentation team direct efforts towards what users are looking for. &lt;a href=&quot;https://github.com/numpy/numpy/issues/15760&quot;&gt;See this issue&lt;/a&gt; for an example of how to do this.</source>
          <target state="translated">如果您看到正式文档中未包含好的教程，操作方法或说明，则可以通过&lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;在GitHub上打开问题&lt;/a&gt;来建议添加该教程。同样，打开问题来建议教程，如何做或在任何地方都找不到的解释是一种很好的方法，可以帮助文档团队将工作方向转向用户的需求。&lt;a href=&quot;https://github.com/numpy/numpy/issues/15760&quot;&gt;有关&lt;/a&gt;如何执行此操作的示例，请参见此问题。</target>
        </trans-unit>
        <trans-unit id="c084a3f2a6106a54039205662cc0565194fa0738" translate="yes" xml:space="preserve">
          <source>If you specify an &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;a&lt;/code&gt; must be zero-padded or truncated, the extra/removed values will be added/removed at high frequencies. One can thus resample a series to &lt;code&gt;m&lt;/code&gt; points via Fourier interpolation by: &lt;code&gt;a_resamp = irfft(rfft(a), m)&lt;/code&gt;.</source>
          <target state="translated">如果您指定一个 &lt;code&gt;n&lt;/code&gt; 使得必须对 &lt;code&gt;a&lt;/code&gt; 进行零填充或截断，那么多余的/已删除的值将在高频下被添加/删除。因此，可以通过以下方式通过傅里叶插值将序列重新采样为 &lt;code&gt;m&lt;/code&gt; 个点： &lt;code&gt;a_resamp = irfft(rfft(a), m)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd256004a74583cc184f8439d5d048c30d412fb7" translate="yes" xml:space="preserve">
          <source>If you start with these arrays:</source>
          <target state="translated">如果你从这些数组开始。</target>
        </trans-unit>
        <trans-unit id="b2448ad4b64da661ec458b63dd3b9923ea02aca5" translate="yes" xml:space="preserve">
          <source>If you start with this array:</source>
          <target state="translated">如果你从这个数组开始。</target>
        </trans-unit>
        <trans-unit id="777d1be2db0dc4450d7b4eef96ddf2f8d5888d83" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend that you put all your override logic in &lt;code&gt;__array_ufunc__&lt;/code&gt; and not also override special methods. This ensures the class hierarchy is determined in only one place rather than separately by the ufunc machinery and by the binary operation rules (which gives preference to special methods of subclasses; the alternative way to enforce a one-place only hierarchy, of setting &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, would seem very unexpected and thus confusing, as then the subclass would not work at all with ufuncs).</source>
          <target state="translated">如果你的子类&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，我们建议您把所有的重写逻辑 &lt;code&gt;__array_ufunc__&lt;/code&gt; ，而不是还覆盖的特殊方法。这确保了类层次结构仅在一个地方确定，而不是由ufunc机制和二进制操作规则（它优先于子类的特殊方法；这是强制实施仅一个地方的层次结构的另一种方法，将&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;设置为&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，这似乎是非常出乎意料的，因此会造成混乱，因为那时子类对ufuncs完全无效。</target>
        </trans-unit>
        <trans-unit id="2b988c177dc2b27c86ba6dc5904e8834a5cbf804" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend that you put all your override logic in &lt;code&gt;__array_ufunc__&lt;/code&gt; and not also override special methods. This ensures the class hierarchy is determined in only one place rather than separately by the ufunc machinery and by the binary operation rules (which gives preference to special methods of subclasses; the alternative way to enforce a one-place only hierarchy, of setting &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; to None, would seem very unexpected and thus confusing, as then the subclass would not work at all with ufuncs).</source>
          <target state="translated">如果你的子类&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，我们建议您把所有的重写逻辑 &lt;code&gt;__array_ufunc__&lt;/code&gt; ，而不是还覆盖的特殊方法。这确保了类层次结构仅在一个地方确定，而不是由ufunc机制和二进制操作规则（它优先于子类的特殊方法；这是强制实施仅一个地方的层次结构的另一种方法，将&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt;设置为）来确定。没有，这看起来非常出乎意料，因此令人困惑，因为那时子类对于ufuncs根本不起作用）。</target>
        </trans-unit>
        <trans-unit id="68630e24ebcf26648c6330182b68ffff11c7fe21" translate="yes" xml:space="preserve">
          <source>If you want to allow your new data-type to also be able to share in the scalar coercion rules, then you need to specify the scalarkind function in the data-type object&amp;rsquo;s &amp;ldquo;.f&amp;rdquo; member to return the kind of scalar the new data-type should be seen as (the value of the scalar is available to that function). Then, you can register data-types that can be cast to separately for each scalar kind that may be returned from your user-defined data-type. If you don&amp;rsquo;t register scalar coercion handling, then all of your user-defined data-types will be seen as &lt;a href=&quot;../reference/c-api/array#c.NPY_NOSCALAR&quot;&gt;&lt;code&gt;NPY_NOSCALAR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要允许新数据类型也可以在标量强制规则中共享，则需要在数据类型对象的&amp;ldquo; .f&amp;rdquo;成员中指定scalarkind函数，以返回新数据标量的类型-type应该被视为（标量的值可用于该函数）。然后，您可以注册可以从用户定义的数据类型返回的每种标量类型分别转换为的数据类型。如果您没有注册标量强制处理，那么所有用户定义的数据类型都将被视为&lt;a href=&quot;../reference/c-api/array#c.NPY_NOSCALAR&quot;&gt; &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b381b011cdbc746e6a1a9147256650f6139d3056" translate="yes" xml:space="preserve">
          <source>If you want to be able to run the examples in this tutorial, you should also have &lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt; and &lt;a href=&quot;https://scipy.org&quot;&gt;SciPy&lt;/a&gt; installed on your computer.</source>
          <target state="translated">如果您希望能够运行本教程中的示例，则还应该在计算机上安装&lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt;和&lt;a href=&quot;https://scipy.org&quot;&gt;SciPy&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0e8bade3a2638408b33822bff54e29660bf3ff4" translate="yes" xml:space="preserve">
          <source>If you want to be able to run the examples in this tutorial, you should also have &lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt; installed on your computer.</source>
          <target state="translated">如果您希望能够运行本教程中的示例，则还应该在计算机上安装&lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aaf81dbd7051e065aedb8dd44063737fadd7deaa" translate="yes" xml:space="preserve">
          <source>If you want to build NumPy in order to work on NumPy itself, use &lt;code&gt;runtests.py&lt;/code&gt;.To run NumPy&amp;rsquo;s full test suite:</source>
          <target state="translated">如果要构建NumPy以便在NumPy本身上运行，请使用 &lt;code&gt;runtests.py&lt;/code&gt; 。要运行NumPy的完整测试套件，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="2bd528b5e948a367e7029016eb9b4a7e59a0c3cc" translate="yes" xml:space="preserve">
          <source>If you want to check your array, you can run::</source>
          <target state="translated">如果你想检查你的数组,你可以运行:。</target>
        </trans-unit>
        <trans-unit id="239d78c449f1143da9fe3cab0308bfd5b8c57120" translate="yes" xml:space="preserve">
          <source>If you want to distribute your f2py extension module, then you only need to include the .pyf file and the Fortran code. The distutils extensions in NumPy allow you to define an extension module entirely in terms of this interface file. A valid &lt;code&gt;setup.py&lt;/code&gt; file allowing distribution of the &lt;code&gt;add.f&lt;/code&gt; module (as part of the package &lt;code&gt;f2py_examples&lt;/code&gt; so that it would be loaded as &lt;code&gt;f2py_examples.add&lt;/code&gt;) is:</source>
          <target state="translated">如果要分发f2py扩展模块，则只需包含.pyf文件和Fortran代码。NumPy中的distutils扩展允许您完全根据此接口文件定义扩展模块。允许分发 &lt;code&gt;add.f&lt;/code&gt; 模块（作为软件包 &lt;code&gt;f2py_examples&lt;/code&gt; 的一部分，以便将其作为 &lt;code&gt;f2py_examples.add&lt;/code&gt; 加载）的有效 &lt;code&gt;setup.py&lt;/code&gt; 文件为：</target>
        </trans-unit>
        <trans-unit id="205839ed0e5eb197529b1363e1bb132c099c8dee" translate="yes" xml:space="preserve">
          <source>If you want to edit an array with aligned &lt;code&gt;double&lt;/code&gt; code, but the order doesn&amp;rsquo;t matter, you would use this.</source>
          <target state="translated">如果要使用对齐的 &lt;code&gt;double&lt;/code&gt; 代码编辑数组，但顺序无关紧要，则可以使用它。</target>
        </trans-unit>
        <trans-unit id="354259176d8d4848edf2f2ea177ee9321090388c" translate="yes" xml:space="preserve">
          <source>If you want to generate a list of coordinates where the elements exist, you can zip the arrays, iterate over the list of coordinates, and print them. For example:</source>
          <target state="translated">如果你想生成元素存在的坐标列表,你可以压缩数组,迭代坐标列表,然后打印出来。例如</target>
        </trans-unit>
        <trans-unit id="09988ae17a5580ba08c41432cf193fcdceccc334" translate="yes" xml:space="preserve">
          <source>If you want to get the unique rows or columns, make sure to pass the &lt;code&gt;axis&lt;/code&gt; argument. To find the unique rows, specify &lt;code&gt;axis=0&lt;/code&gt; and for columns, specify &lt;code&gt;axis=1&lt;/code&gt;.</source>
          <target state="translated">如果要获取唯一的行或列，请确保传递 &lt;code&gt;axis&lt;/code&gt; 参数。要查找唯一的行，请指定 &lt;code&gt;axis=0&lt;/code&gt; ，对于列，请指定 &lt;code&gt;axis=1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a706c6c7d842fe3c84f0f98172224bf53de48486" translate="yes" xml:space="preserve">
          <source>If you want to learn more about C and Fortran order, you can &lt;a href=&quot;../reference/internals#numpy-internals&quot;&gt;read more about the internal organization of NumPy arrays here&lt;/a&gt;. Essentially, C and Fortran orders have to do with how indices correspond to the order the array is stored in memory. In Fortran, when moving through the elements of a two-dimensional array as it is stored in memory, the &lt;strong&gt;first&lt;/strong&gt; index is the most rapidly varying index. As the first index moves to the next row as it changes, the matrix is stored one column at a time. This is why Fortran is thought of as a &lt;strong&gt;Column-major language&lt;/strong&gt;. In C on the other hand, the &lt;strong&gt;last&lt;/strong&gt; index changes the most rapidly. The matrix is stored by rows, making it a &lt;strong&gt;Row-major language&lt;/strong&gt;. What you do for C or Fortran depends on whether it&amp;rsquo;s more important to preserve the indexing convention or not reorder the data.</source>
          <target state="translated">如果您想了解有关C和Fortran顺序的更多信息，可以&lt;a href=&quot;../reference/internals#numpy-internals&quot;&gt;在此处阅读有关NumPy数组的内部组织的更多信息&lt;/a&gt;。本质上，C和Fortran顺序与索引如何与数组在内存中存储的顺序相对应有关。在Fortran中，当移动存储在内存中的二维数组的元素时，第&lt;strong&gt;一个&lt;/strong&gt;索引是变化最快的索引。当第一个索引更改时移动到下一行时，矩阵一次存储一列。这就是为什么将Fortran视为&lt;strong&gt;列主要语言的原因&lt;/strong&gt;。另一方面，在C中，&lt;strong&gt;最后一个&lt;/strong&gt;索引变化最快。矩阵按行存储，使其成为&lt;strong&gt;行主要语言&lt;/strong&gt;。对C或Fortran所做的操作取决于保留索引约定还是不对数据重新排序是否更为重要。</target>
        </trans-unit>
        <trans-unit id="90eb7317f80793824fd5ca68d969b076155c2b6b" translate="yes" xml:space="preserve">
          <source>If you want to make use of these extensions in third-party projects, they are available on &lt;a href=&quot;https://pypi.org/&quot;&gt;PyPi&lt;/a&gt; as the &lt;a href=&quot;https://python.org/pypi/numpydoc&quot;&gt;numpydoc&lt;/a&gt; package.</source>
          <target state="translated">如果你想使用第三方项目这些扩展，它们可在&lt;a href=&quot;https://pypi.org/&quot;&gt;PyPI中&lt;/a&gt;作为&lt;a href=&quot;https://python.org/pypi/numpydoc&quot;&gt;numpydoc&lt;/a&gt;包。</target>
        </trans-unit>
        <trans-unit id="ce326a8e1b86089803e6e52c507c14343be2d322" translate="yes" xml:space="preserve">
          <source>If you want to print your reversed array, you can run:</source>
          <target state="translated">如果你想打印你的反向数组,你可以运行。</target>
        </trans-unit>
        <trans-unit id="0c1156594a53dfa7f56ad636c35e9f1ff1d1bf58" translate="yes" xml:space="preserve">
          <source>If you want to reset both the &lt;code&gt;iterindex&lt;/code&gt; range and the base pointers at the same time, you can do the following to avoid extra buffer copying (be sure to add the return code error checks when you copy this code).</source>
          <target state="translated">如果要同时重置 &lt;code&gt;iterindex&lt;/code&gt; 范围和基指针，则可以执行以下操作以避免额外的缓冲区复制（确保在复制此代码时添加返回代码错误检查）。</target>
        </trans-unit>
        <trans-unit id="64b7d79c9f444db203d014596ebfe464ce993392" translate="yes" xml:space="preserve">
          <source>If you want to select values from your array that fulfill certain conditions, it&amp;rsquo;s straightforward with NumPy.</source>
          <target state="translated">如果要从数组中选择满足某些条件的值，则使用NumPy很简单。</target>
        </trans-unit>
        <trans-unit id="37f52b8408b71a5a1ecc2762c718ea9d22604602" translate="yes" xml:space="preserve">
          <source>If you want to store a single ndarray object, store it as a .npy file using &lt;code&gt;np.save&lt;/code&gt;. If you want to store more than one ndarray object in a single file, save it as a .npz file using &lt;code&gt;np.savez&lt;/code&gt;. You can also save several arrays into a single file in compressed npz format with &lt;a href=&quot;../reference/generated/numpy.savez_compressed#numpy.savez_compressed&quot;&gt;&lt;code&gt;savez_compressed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要存储单个ndarray对象，请使用 &lt;code&gt;np.save&lt;/code&gt; 将其存储为.npy文件。如果要在一个文件中存储多个ndarray对象，请使用 &lt;code&gt;np.savez&lt;/code&gt; 将其另存为.npz文件。您还可以使用&lt;a href=&quot;../reference/generated/numpy.savez_compressed#numpy.savez_compressed&quot;&gt; &lt;code&gt;savez_compressed&lt;/code&gt; &lt;/a&gt;将多个数组以npz压缩格式保存到单个文件中。</target>
        </trans-unit>
        <trans-unit id="88094cb7e9cc7094508fd58f64e280384e2b183f" translate="yes" xml:space="preserve">
          <source>If you want to work on some stuff with other people, where you are all committing into the same repository, or even the same branch, then just share it via &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;.</source>
          <target state="translated">如果您想与其他人一起从事某些工作，而您都将它们提交到同一存储库，甚至是同一分支中，那么只需通过&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;共享即可。</target>
        </trans-unit>
        <trans-unit id="3d8a79d78dafc5ad7f75ccfea604d3c282656ec2" translate="yes" xml:space="preserve">
          <source>If you wanted to split this array into three equally shaped arrays, you would run:</source>
          <target state="translated">如果你想把这个数组分割成三个形状相同的数组,你可以运行。</target>
        </trans-unit>
        <trans-unit id="fe157cf65afca39aaf28e7392b7bcce12c2fa490" translate="yes" xml:space="preserve">
          <source>If you wanted to split your array after the third and fourth column, you&amp;rsquo;d run:</source>
          <target state="translated">如果要在第三列和第四列之后拆分数组，请运行：</target>
        </trans-unit>
        <trans-unit id="f154266a0558b92de5f9f6ffafaf54fec025441e" translate="yes" xml:space="preserve">
          <source>If you wish to build against OpenBLAS but you also have BLIS available one may predefine the order of searching via the environment variable &lt;code&gt;NPY_BLAS_ORDER&lt;/code&gt; which is a comma-separated list of the above names which is used to determine what to search for, for instance:</source>
          <target state="translated">如果您希望针对OpenBLAS进行构建，但又可以使用BLIS，则可以通过环境变量 &lt;code&gt;NPY_BLAS_ORDER&lt;/code&gt; 预先定义搜索顺序，该变量是上述名称的逗号分隔列表，用于确定要搜索的内容，例如：</target>
        </trans-unit>
        <trans-unit id="591a2b4b56f13d91fd0f488df05b473dc7163812" translate="yes" xml:space="preserve">
          <source>If you wish to build against OpenBLAS but you also have MKL available one may predefine the order of searching via the environment variable &lt;code&gt;NPY_LAPACK_ORDER&lt;/code&gt; which is a comma-separated list of the above names, for instance:</source>
          <target state="translated">如果您希望针对OpenBLAS进行构建，但同时也可以使用MKL，则可以通过环境变量 &lt;code&gt;NPY_LAPACK_ORDER&lt;/code&gt; 预先定义搜索顺序，该变量是上述名称的逗号分隔列表，例如：</target>
        </trans-unit>
        <trans-unit id="05bc8da7a227df06fa8b2e6100a971876a03d9e2" translate="yes" xml:space="preserve">
          <source>If you wish to maintain compatibility with numpy and its subsequent versions (which might add new keyword arguments) but do not want to surface all of numpy&amp;rsquo;s arguments, your function&amp;rsquo;s signature should accept &lt;code&gt;**kwargs&lt;/code&gt;. For example:</source>
          <target state="translated">如果您希望保持与numpy及其后续版本（可能会添加新的关键字参数）的兼容性，但又不想公开所有numpy的参数，则函数的签名应接受 &lt;code&gt;**kwargs&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="97b99e9167303c0b41027781a2b137980415f644" translate="yes" xml:space="preserve">
          <source>If you wish to work the examples in this tutorial, you must also have some software installed on your computer. Please see &lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https://scipy.org/install.html&lt;/a&gt; for instructions.</source>
          <target state="translated">如果您希望使用本教程中的示例，则还必须在计算机上安装一些软件。有关说明，请参阅&lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https://scipy.org/install.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6c90b5dde9be10d805961ffa80c714fdcbfb4da" translate="yes" xml:space="preserve">
          <source>If you write a missing doc you join the front line of open source, but it&amp;rsquo;s a meaningful contribution just to let us know what&amp;rsquo;s missing. If you want to compose a doc, run your thoughts by the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;mailing list&lt;/a&gt; for futher ideas and feedback. If you want to alert us to a gap, &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;open an issue&lt;/a&gt;. See &lt;a href=&quot;https://github.com/numpy/numpy/issues/15760&quot;&gt;this issue&lt;/a&gt; for an example.</source>
          <target state="translated">如果您编写缺少的文档，那么您将加入开源的第一线，但这是有意义的贡献，只是让我们知道缺少的内容。如果您要撰写文档，请通过&lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;邮件列表发表&lt;/a&gt;想法，以获取更多想法和反馈。如果您想提醒我们有空白，请提出&lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;一个问题&lt;/a&gt;。有关示例，请参&lt;a href=&quot;https://github.com/numpy/numpy/issues/15760&quot;&gt;见此问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="435688685c403e3c5d5db1511c607affa0cd6d4f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a code contributor writing a docstring, see &lt;a href=&quot;docs/howto_document#docstring-intro&quot;&gt;Docstrings&lt;/a&gt;.</source>
          <target state="translated">如果您是编写文档字符串的代码贡献者，请参阅&lt;a href=&quot;docs/howto_document#docstring-intro&quot;&gt;Docstrings&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9781eb57d03c99a0c0070bb4df55efb82815ef3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a writer contributing ordinary (non-docstring) documentation, see &lt;a href=&quot;docs/howto_document#userdoc-guide&quot;&gt;User documentation&lt;/a&gt;.</source>
          <target state="translated">如果您是撰写普通（非文档字符串）文档的作家，请参阅《&lt;a href=&quot;docs/howto_document#userdoc-guide&quot;&gt;用户文档》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84b984ed21d4b1689868017ea7336aed57363a70" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re happy about the current status, mark the pull request as Approved (same way as Changes requested). Alternatively (for maintainers): merge the pull request, if you think it is ready to be merged.</source>
          <target state="translated">如果您对当前状态感到满意，请将拉取请求标记为&amp;ldquo;已批准&amp;rdquo;（与&amp;ldquo;更改请求&amp;rdquo;相同）。或者（对于维护者）：如果您准备好合并合并请求，则合并合并请求。</target>
        </trans-unit>
        <trans-unit id="7557e5e98e1d6b39d314fab8f9700d862099c3ca" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in learning more about Pandas, take a look at the &lt;a href=&quot;https://pandas.pydata.org/index.html&quot;&gt;official Pandas documentation&lt;/a&gt;. Learn how to install Pandas with the &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/install.html&quot;&gt;official Pandas installation information&lt;/a&gt;.</source>
          <target state="translated">如果您想了解有关Pandas的更多信息，请查看&lt;a href=&quot;https://pandas.pydata.org/index.html&quot;&gt;官方的Pandas文档&lt;/a&gt;。通过&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/install.html&quot;&gt;官方的Pandas安装信息&lt;/a&gt;了解如何安装Pandas 。</target>
        </trans-unit>
        <trans-unit id="0da7f308127a1fe361554b03665675b46523369c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re looking for subjects, our formal roadmap for documentation is a &lt;em&gt;NumPy Enhancement Proposal (NEP)&lt;/em&gt;, &lt;a href=&quot;https://www.numpy.org/neps/nep-0044-restructuring-numpy-docs&quot;&gt;NEP 44 - Restructuring the NumPy Documentation&lt;/a&gt;. It identifies areas where our docs need help and lists several additions we&amp;rsquo;d like to see, including Jupyter notebooks.</source>
          <target state="translated">如果您正在寻找主题，我们的正式文档编制指南是&lt;em&gt;NumPy增强提案（NEP）&lt;/em&gt;，&lt;a href=&quot;https://www.numpy.org/neps/nep-0044-restructuring-numpy-docs&quot;&gt;NEP 44-重构NumPy文档&lt;/a&gt;。它确定了我们的文档需要帮助的区域，并列出了我们希望看到的其他功能，包括Jupyter笔记本。</target>
        </trans-unit>
        <trans-unit id="2ed6aac4fbb9a95f912d9c4a1bba39294044ad2e" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re reading this page, you probably want to help. This guide is meant to help you decide which kind of content you&amp;rsquo;ll write, as well as give you some tips and instructions for submitting it to the official NumPy documentation (that is, the documentation that ships with NumPy and lives on the &lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;official project pages&lt;/a&gt;). Keep in mind that if you don&amp;rsquo;t want to do this, writing a tutorial on your own blog, creating a YouTube video or answering questions on social media or Stack Overflow are also great contributions!</source>
          <target state="translated">如果您正在阅读此页面，则可能需要帮助。本指南旨在帮助您决定编写哪种类型的内容，并为您提供一些技巧和说明，以将其提交给NumPy官方文档（即NumPy附带并存在于&lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;官方项目中&lt;/a&gt;的文档）。页）。请记住，如果您不想这样做，则可以在自己的博客上撰写教程，创建YouTube视频或在社交媒体或Stack Overflow上回答问题，这也是很棒的贡献！</target>
        </trans-unit>
        <trans-unit id="fc7594579a51a68345b4192c0906de63f2aaa750" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using the command line, you can read your saved CSV any time with a command such as:</source>
          <target state="translated">如果您使用的是命令行，则可以随时使用以下命令读取已保存的CSV：</target>
        </trans-unit>
        <trans-unit id="d439391f6f76ed7b2f3c8457a29af3bd829a0ea7" translate="yes" xml:space="preserve">
          <source>If your PR is large or complicated, asking for input on the numpy-discussion mailing list may also be useful.</source>
          <target state="translated">如果你的PR比较大或复杂,在numpy-discussion邮件列表上征求意见也是很有用的。</target>
        </trans-unit>
        <trans-unit id="bb1dc4c88210c13fc91fb612afbe4d0471d01d47" translate="yes" xml:space="preserve">
          <source>If your change introduces a deprecation, make sure to discuss this first on GitHub or the mailing list first. If agreement on the deprecation is reached, follow &lt;a href=&quot;http://www.numpy.org/neps/nep-0023-backwards-compatibility.html&quot;&gt;NEP 23 deprecation policy&lt;/a&gt; to add the deprecation.</source>
          <target state="translated">如果您的更改导致弃用，请确保首先在GitHub或邮件列表上进行讨论。如果达成关于弃用的协议，请遵循&lt;a href=&quot;http://www.numpy.org/neps/nep-0023-backwards-compatibility.html&quot;&gt;NEP 23弃用策略&lt;/a&gt;以添加弃用。</target>
        </trans-unit>
        <trans-unit id="85accb86465121a186b8d95e3c7a59851c6c91da" translate="yes" xml:space="preserve">
          <source>If your change introduces a deprecation, make sure to discuss this first on GitHub or the mailing list first. If agreement on the deprecation is reached, follow &lt;a href=&quot;https://numpy.org/neps/nep-0023-backwards-compatibility.html#nep23&quot;&gt;NEP 23 deprecation policy&lt;/a&gt; to add the deprecation.</source>
          <target state="translated">如果您的更改导致弃用，请确保首先在GitHub或邮件列表上进行讨论。如果达成关于弃用的协议，请遵循&lt;a href=&quot;https://numpy.org/neps/nep-0023-backwards-compatibility.html#nep23&quot;&gt;NEP 23弃用策略&lt;/a&gt;以添加弃用。</target>
        </trans-unit>
        <trans-unit id="0ae48eb5fc08b6f0ede5d882f3a65c937350363d" translate="yes" xml:space="preserve">
          <source>If your changes involve modifications to the API or addition/modification of a function, add a release note to the &lt;code&gt;doc/release/upcoming_changes/&lt;/code&gt; directory, following the instructions and format in the &lt;code&gt;doc/release/upcoming_changes/README.rst&lt;/code&gt; file.</source>
          <target state="translated">如果更改涉及对API的修改或对功能的添加/修改，请按照 &lt;code&gt;doc/release/upcoming_changes/README.rst&lt;/code&gt; 文件中的说明和格式，将发行说明添加到 &lt;code&gt;doc/release/upcoming_changes/&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="383746919525c98ba38f05552e38f10fc7e17a76" translate="yes" xml:space="preserve">
          <source>If your changes involve modifications to the API or addition/modification of a function, you should</source>
          <target state="translated">如果您的修改涉及到对API的修改或对函数的添加/修改,您应该做到以下几点</target>
        </trans-unit>
        <trans-unit id="d57214d0288965780d58c7b4b54223afc06a658d" translate="yes" xml:space="preserve">
          <source>If your commit introduces a new feature or changes functionality, post on the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-devel&quot;&gt;mailing list&lt;/a&gt; to explain your changes. For bug fixes, documentation updates, etc., this is generally not necessary, though if you do not get any reaction, do feel free to ask for review.</source>
          <target state="translated">如果您的提交引入了新功能或更改功能，请在&lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-devel&quot;&gt;邮件列表中发布&lt;/a&gt;以解释您的更改。对于错误修复，文档更新等，通常没有必要，尽管如果您没有任何反应，请随时提出要求。</target>
        </trans-unit>
        <trans-unit id="9b42fea7ef12344e2f07dc65d3a5d4a69a61f251" translate="yes" xml:space="preserve">
          <source>If your commit introduces a new feature or changes functionality, post on the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;mailing list&lt;/a&gt; to explain your changes. For bug fixes, documentation updates, etc., this is generally not necessary, though if you do not get any reaction, do feel free to ask for review.</source>
          <target state="translated">如果您的提交引入了新功能或更改功能，请在&lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;邮件列表中发布&lt;/a&gt;以解释您的更改。对于错误修复，文档更新等，通常没有必要，尽管如果您没有任何反应，请随时提出要求。</target>
        </trans-unit>
        <trans-unit id="ceebca4c980fce897cd94c7ea4093efdb4e34dd2" translate="yes" xml:space="preserve">
          <source>If your goal is to print such values with a fixed number of decimals, it is preferable to use numpy&amp;rsquo;s float printing routines to limit the number of printed decimals:</source>
          <target state="translated">如果您的目标是使用固定的小数位数打印这些值，则最好使用numpy的float打印例程来限制打印的小数位数：</target>
        </trans-unit>
        <trans-unit id="5e8a3ab9024a9447fbb66b46a34249a781d9bca6" translate="yes" xml:space="preserve">
          <source>If your report involves any members of the committee, or if they feel they have a conflict of interest in handling it, then they will recuse themselves from considering your report. Alternatively, if for any reason you feel uncomfortable making a report to the committee, then you can also contact:</source>
          <target state="translated">如果你的报告涉及到委员会的任何成员,或者他们认为他们在处理报告时有利益冲突,那么他们将回避审议你的报告。另外,如果出于任何原因,你觉得不方便向委员会提交报告,你也可以联系:</target>
        </trans-unit>
        <trans-unit id="3b1e83353521c6fb2d9909d1a47041f20fbc218d" translate="yes" xml:space="preserve">
          <source>If, however, you decide to deviate from this signature and do something like this:</source>
          <target state="translated">但是,如果你决定偏离这个签名,做一些像这样的事情。</target>
        </trans-unit>
        <trans-unit id="c323f3cd6a35ba341fff7e94a4d83cd135d073a2" translate="yes" xml:space="preserve">
          <source>Ignoring extreme values</source>
          <target state="translated">忽略极端值</target>
        </trans-unit>
        <trans-unit id="d887ce439b6be40447269f7cc275bae88c7965c1" translate="yes" xml:space="preserve">
          <source>Illustration image: &lt;a href=&quot;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&quot;&gt;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&lt;/a&gt;</source>
          <target state="translated">插图图片：&lt;a href=&quot;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&quot;&gt;https&lt;/a&gt; : //en.wikipedia.org/wiki/File : Composite_trapezoidal_rule_illustration.png</target>
        </trans-unit>
        <trans-unit id="8dc5a9232d67823e896b05855151653c2378fa30" translate="yes" xml:space="preserve">
          <source>Illustration, using the fact that the eigenvalues of a diagonal matrix are its diagonal elements, that multiplying a matrix on the left by an orthogonal matrix, &lt;code&gt;Q&lt;/code&gt;, and on the right by &lt;code&gt;Q.T&lt;/code&gt; (the transpose of &lt;code&gt;Q&lt;/code&gt;), preserves the eigenvalues of the &amp;ldquo;middle&amp;rdquo; matrix. In other words, if &lt;code&gt;Q&lt;/code&gt; is orthogonal, then &lt;code&gt;Q * A * Q.T&lt;/code&gt; has the same eigenvalues as &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">举例说明，利用对角矩阵的特征值是其对角元素这一事实，将左边的矩阵乘以正交矩阵 &lt;code&gt;Q&lt;/code&gt; ，将右边的矩阵乘以 &lt;code&gt;Q.T&lt;/code&gt; （ &lt;code&gt;Q&lt;/code&gt; 的转置），可以保留&amp;ldquo;中间&amp;rdquo;矩阵。换句话说，如果 &lt;code&gt;Q&lt;/code&gt; 是正交的，则 &lt;code&gt;Q * A * Q.T&lt;/code&gt; 具有与 &lt;code&gt;A&lt;/code&gt; 相同的特征值：</target>
        </trans-unit>
        <trans-unit id="aa91fcf02d0f861f5dcc65de755f413adabac4c5" translate="yes" xml:space="preserve">
          <source>Illustration:</source>
          <target state="translated">Illustration:</target>
        </trans-unit>
        <trans-unit id="50e19fda0d5b4b74a4a1a1d584e56578693a4ea4" translate="yes" xml:space="preserve">
          <source>Image</source>
          <target state="translated">Image</target>
        </trans-unit>
        <trans-unit id="536fc5481730660eaf684050e171a85c03ce521a" translate="yes" xml:space="preserve">
          <source>Image &lt;a href=&quot;#r7aa6c77779c0-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; illustrates trapezoidal rule &amp;ndash; y-axis locations of points will be taken from &lt;code&gt;y&lt;/code&gt; array, by default x-axis distances between points will be 1.0, alternatively they can be provided with &lt;code&gt;x&lt;/code&gt; array or with &lt;code&gt;dx&lt;/code&gt; scalar. Return value will be equal to combined area under the red lines.</source>
          <target state="translated">图像&lt;a href=&quot;#r7aa6c77779c0-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;说明了梯形法则&amp;ndash;点的y轴位置将从 &lt;code&gt;y&lt;/code&gt; 数组中获取，默认情况下，点之间的x轴距离为1.0，或者可以为它们提供 &lt;code&gt;x&lt;/code&gt; 数组或 &lt;code&gt;dx&lt;/code&gt; 标量。返回值将等于红线下方的总面积。</target>
        </trans-unit>
        <trans-unit id="a9fdbeb05caca869c7ab036893a4d3951315842f" translate="yes" xml:space="preserve">
          <source>Image filter in Cython</source>
          <target state="translated">Cython中的图像过滤器</target>
        </trans-unit>
        <trans-unit id="d6766ee0177892e2089a490e4a43072e37a3688f" translate="yes" xml:space="preserve">
          <source>Images and real-life data make text more engaging and powerful, but be sure what you use is appropriately licensed and available. Here again, even a rough idea for artwork can be polished by others.</source>
          <target state="translated">图片和现实生活中的数据让文字更有吸引力和力量,但要确保你所使用的东西是经过适当授权和可用的。在这里,即使是一个粗略的艺术作品的想法,也可以被其他人打磨。</target>
        </trans-unit>
        <trans-unit id="9e3e609852befab966299ce3a62b4f677877a107" translate="yes" xml:space="preserve">
          <source>Images are allowed, but should not be central to the explanation; users viewing the docstring as text must be able to comprehend its meaning without resorting to an image viewer. These additional illustrations are included using:</source>
          <target state="translated">图片是允许的,但不应该是解释的核心;用户在将docstring作为文本查看时,必须能够理解其含义,而不需要借助于图片浏览器。这些额外的插图包括使用。</target>
        </trans-unit>
        <trans-unit id="4796b475dca83b62f81a07c968464a3ec0ce36b3" translate="yes" xml:space="preserve">
          <source>Imagine a series of commits A, B, C, D&amp;hellip; Imagine that there are two branches, &lt;em&gt;topic&lt;/em&gt; and &lt;em&gt;master&lt;/em&gt;. You branched &lt;em&gt;topic&lt;/em&gt; off &lt;em&gt;master&lt;/em&gt; when &lt;em&gt;master&lt;/em&gt; was at commit &amp;lsquo;E&amp;rsquo;. The graph of the commits looks like this:</source>
          <target state="translated">想象一下一系列的提交A，B，C，D ...想象一下，有两个分支，即&lt;em&gt;topic&lt;/em&gt;和&lt;em&gt;master&lt;/em&gt;。当&lt;em&gt;master&lt;/em&gt;处于提交'E'时，您从&lt;em&gt;master&lt;/em&gt;分支了&lt;em&gt;主题&lt;/em&gt;。提交的图形如下所示：&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d1a70afdce8219e6a6ff23faf95244260258e23" translate="yes" xml:space="preserve">
          <source>Imagine an array of 32-bit integers (each 4 bytes):</source>
          <target state="translated">想象一个32位整数的数组(每个4个字节)。</target>
        </trans-unit>
        <trans-unit id="56024d919b5d6ee0185b1f966812231e966a9f22" translate="yes" xml:space="preserve">
          <source>Immediately disconnect the originator from all NumPy communication channels.</source>
          <target state="translated">立即断开发起人与所有NumPy通信通道的连接。</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">实施细节</target>
        </trans-unit>
        <trans-unit id="c12c46e2305d0716b258ac51f2e79f55da8c1069" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;__array_function__&lt;/code&gt; indicate that they can handle the operation by returning any value other than &lt;code&gt;NotImplemented&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__array_function__&lt;/code&gt; 的实现指示它们可以通过返回 &lt;code&gt;NotImplemented&lt;/code&gt; 以外的任何值来处理该操作。</target>
        </trans-unit>
        <trans-unit id="45682c285dcaa4b3e31e357f40fa088a415ce505" translate="yes" xml:space="preserve">
          <source>Implementing this formula is simple and straightforward in NumPy:</source>
          <target state="translated">在NumPy中实现这个公式很简单,也很直接。</target>
        </trans-unit>
        <trans-unit id="0e028e89dfea3c1cba7d9fc7a23453fc7abac732" translate="yes" xml:space="preserve">
          <source>Implements exec_command function that is (almost) equivalent to commands.getstatusoutput function but on NT, DOS systems the returned status is actually correct (though, the returned status values may be different by a factor). In addition, exec_command takes keyword arguments for (re-)defining environment variables.</source>
          <target state="translated">实现exec_command函数,(几乎)等同于command.getstatusoutput函数,但在NT、DOS系统上,返回的状态实际上是正确的(虽然,返回的状态值可能会有一定的差异)。此外,exec_command还接受关键字参数,用于(重新)定义环境变量。</target>
        </trans-unit>
        <trans-unit id="b794a9ed38f8d441574ce1ea158c0a341f3db730" translate="yes" xml:space="preserve">
          <source>Implements the complex comparisons between two complex numbers (structures with a real and imag member) using NumPy&amp;rsquo;s definition of the ordering which is lexicographic: comparing the real parts first and then the complex parts if the real parts are equal.</source>
          <target state="translated">使用字典顺序的NumPy定义在两个复数（带有实成员和imag成员的结构）之间进行复杂比较：如果实部分相等，则先比较实部分，然后比较复杂部分。</target>
        </trans-unit>
        <trans-unit id="8c1ede9f9fcf093439f0e008232b895dda53883b" translate="yes" xml:space="preserve">
          <source>Implements the rules for scalar coercion. Scalars are only silently coerced from thistype to neededtype if this function returns nonzero. If scalar is &lt;a href=&quot;#c.NPY_NOSCALAR&quot;&gt;&lt;code&gt;NPY_NOSCALAR&lt;/code&gt;&lt;/a&gt;, then this function is equivalent to &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt;&lt;code&gt;PyArray_CanCastSafely&lt;/code&gt;&lt;/a&gt;. The rule is that scalars of the same KIND can be coerced into arrays of the same KIND. This rule means that high-precision scalars will never cause low-precision arrays of the same KIND to be upcast.</source>
          <target state="translated">实施标量强制的规则。如果此函数返回非零值，则仅将标量从此类型静默转换为需要的类型。如果标量为&lt;a href=&quot;#c.NPY_NOSCALAR&quot;&gt; &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; &lt;/a&gt;，则此函数等效于&lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt; &lt;code&gt;PyArray_CanCastSafely&lt;/code&gt; &lt;/a&gt;。规则是可以将相同KIND的标量强制转换为相同KIND的数组。该规则意味着高精度标量将永远不会导致相同KIND的低精度数组被泛滥。</target>
        </trans-unit>
        <trans-unit id="22af89867a4595ad888fcb4ec7aff9a5775524c5" translate="yes" xml:space="preserve">
          <source>Implements the rules for scalar coercion. Scalars are only silently coerced from thistype to neededtype if this function returns nonzero. If scalar is &lt;code&gt;NPY_NOSCALAR&lt;/code&gt;, then this function is equivalent to &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt;&lt;code&gt;PyArray_CanCastSafely&lt;/code&gt;&lt;/a&gt;. The rule is that scalars of the same KIND can be coerced into arrays of the same KIND. This rule means that high-precision scalars will never cause low-precision arrays of the same KIND to be upcast.</source>
          <target state="translated">实施标量强制的规则。如果此函数返回非零值，则仅将标量从此类型静默转换为需要的类型。如果标量为 &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; ，则此函数等效于&lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt; &lt;code&gt;PyArray_CanCastSafely&lt;/code&gt; &lt;/a&gt;。规则是可以将相同KIND的标量强制转换为相同KIND的数组。该规则意味着高精度标量将永远不会导致相同KIND的低精度数组被泛滥。</target>
        </trans-unit>
        <trans-unit id="cc6b2c01f5b15596a7e379b52c69cde1905611b5" translate="yes" xml:space="preserve">
          <source>Implications for subclassing</source>
          <target state="translated">对子类划分的影响</target>
        </trans-unit>
        <trans-unit id="9b1ecf27a94cea1bc5736c0891a645368078e452" translate="yes" xml:space="preserve">
          <source>Implicit rules are used to determine the type specification of a variable (from the first-letter of its name) if the variable is not defined using &lt;code&gt;&amp;lt;variable type declaration&amp;gt;&lt;/code&gt;. Default implicit rule is given by</source>
          <target state="translated">如果未使用 &lt;code&gt;&amp;lt;variable type declaration&amp;gt;&lt;/code&gt; 定义变量，则使用隐式规则来确定变量的类型说明（从其名称的第一个字母开始）。默认的隐式规则由</target>
        </trans-unit>
        <trans-unit id="696ba2ae8759bcaca0a74feee3fb3d26911b302c" translate="yes" xml:space="preserve">
          <source>Implies</source>
          <target state="translated">Implies</target>
        </trans-unit>
        <trans-unit id="0951af8ad6c339672abaff4e57cd5d78b54b3d59" translate="yes" xml:space="preserve">
          <source>Import conventions</source>
          <target state="translated">进口惯例</target>
        </trans-unit>
        <trans-unit id="361838ee748707501d1086cda1d546a0bca541ea" translate="yes" xml:space="preserve">
          <source>ImportError</source>
          <target state="translated">ImportError</target>
        </trans-unit>
        <trans-unit id="2fdd9172a8740a8589e6db75bd8b770e98070548" translate="yes" xml:space="preserve">
          <source>Importing and exporting a CSV</source>
          <target state="translated">导入和导出CSV</target>
        </trans-unit>
        <trans-unit id="a0b02515f5c051785b53791b2ce9293238d373b1" translate="yes" xml:space="preserve">
          <source>Importing data with &lt;code&gt;genfromtxt&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;genfromtxt&lt;/code&gt; 导入数据</target>
        </trans-unit>
        <trans-unit id="5ce37d23b2e6f8bbdca3d0d3d416305b155ec2af" translate="yes" xml:space="preserve">
          <source>Importing data with genfromtxt</source>
          <target state="translated">用genfromtxt导入数据</target>
        </trans-unit>
        <trans-unit id="c27d990de6ba5889ef7140c6c7a668ba89dfd7cb" translate="yes" xml:space="preserve">
          <source>Importing the API</source>
          <target state="translated">导入API</target>
        </trans-unit>
        <trans-unit id="dd37ac12c1ad8599b8ebf308693dc3e055ea4be3" translate="yes" xml:space="preserve">
          <source>Improve detection of CPU features</source>
          <target state="translated">改进对CPU特征的检测</target>
        </trans-unit>
        <trans-unit id="3cf92b1447d3f56d21aa04032c4a2bb6319ee3e3" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;numpy.pad&lt;/code&gt;</source>
          <target state="translated">提高 &lt;code&gt;numpy.pad&lt;/code&gt; 的性能</target>
        </trans-unit>
        <trans-unit id="fc1f2a7f430fee41352adede4b4563f47e652af5" translate="yes" xml:space="preserve">
          <source>Improved automated bin estimators for &lt;code&gt;histogram&lt;/code&gt;</source>
          <target state="translated">改进的 &lt;code&gt;histogram&lt;/code&gt; 自动bin估计器</target>
        </trans-unit>
        <trans-unit id="c1f0700651c0f4723ea34b9b380874940d8f5904" translate="yes" xml:space="preserve">
          <source>Improved conversion from ctypes objects</source>
          <target state="translated">改进了从ctypes对象的转换</target>
        </trans-unit>
        <trans-unit id="518dff1009456384a218feffc1efa6923feaa474" translate="yes" xml:space="preserve">
          <source>Improved handling of zero-width string/unicode dtypes</source>
          <target state="translated">改进了对零宽度字符串/unicode dtypes的处理。</target>
        </trans-unit>
        <trans-unit id="58ab9853fb47f5464aeb249a62f870635c06737e" translate="yes" xml:space="preserve">
          <source>Improved precision of &lt;code&gt;ndarray.mean&lt;/code&gt; for float16 arrays</source>
          <target state="translated">改进float16数组 &lt;code&gt;ndarray.mean&lt;/code&gt; 的精度</target>
        </trans-unit>
        <trans-unit id="38934ca4956698ef07754fc3267371731cc1f9a9" translate="yes" xml:space="preserve">
          <source>Improved set operations</source>
          <target state="translated">改进设置操作</target>
        </trans-unit>
        <trans-unit id="e19dfb0830377f2d40e7f347e095cf658ce8a748" translate="yes" xml:space="preserve">
          <source>Improved string representation for polynomials (&lt;code&gt;__str__&lt;/code&gt;)</source>
          <target state="translated">多项式（ &lt;code&gt;__str__&lt;/code&gt; ）的改进的字符串表示形式</target>
        </trans-unit>
        <trans-unit id="df66ef4f9fec541e48971fe99984a92ee3d241bf" translate="yes" xml:space="preserve">
          <source>Improvements</source>
          <target state="translated">Improvements</target>
        </trans-unit>
        <trans-unit id="75cb8c222cfbf4c46e4378aa465749528ac0f696" translate="yes" xml:space="preserve">
          <source>Improvements to build warnings</source>
          <target state="translated">改进建筑警告</target>
        </trans-unit>
        <trans-unit id="21535b2ca395b919fe7ab1e068c3e3d0e600eb23" translate="yes" xml:space="preserve">
          <source>Improving the basic interface</source>
          <target state="translated">改进基本接口</target>
        </trans-unit>
        <trans-unit id="651ad1981d9513aaa48106696e9dc28fdbdbb95a" translate="yes" xml:space="preserve">
          <source>In &amp;lsquo;clip&amp;rsquo; mode, a negative index which would normally wrap will clip to 0 instead.</source>
          <target state="translated">在&amp;ldquo;剪辑&amp;rdquo;模式下，通常会自动换行的负索引将改为剪辑为0。</target>
        </trans-unit>
        <trans-unit id="0a5b493d076f809b633ada78947b9be3536bf476" translate="yes" xml:space="preserve">
          <source>In 1.16 a number of functions have been introduced in the &lt;a href=&quot;#module-numpy.lib.recfunctions&quot;&gt;&lt;code&gt;numpy.lib.recfunctions&lt;/code&gt;&lt;/a&gt; module to help users account for this change. These are &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.lib.recfunctions.structured_to_unstructured&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.structured_to_unstructured&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.lib.recfunctions.unstructured_to_structured&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.unstructured_to_structured&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.lib.recfunctions.apply_along_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.apply_along_fields&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.lib.recfunctions.assign_fields_by_name&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.assign_fields_by_name&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#numpy.lib.recfunctions.require_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.require_fields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在1.16版本中，&lt;a href=&quot;#module-numpy.lib.recfunctions&quot;&gt; &lt;code&gt;numpy.lib.recfunctions&lt;/code&gt; &lt;/a&gt;模块中引入了许多功能，以帮助用户说明此更改。这些是&lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;#numpy.lib.recfunctions.structured_to_unstructured&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.structured_to_unstructured&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#numpy.lib.recfunctions.unstructured_to_structured&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.unstructured_to_structured&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#numpy.lib.recfunctions.apply_along_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.apply_along_fields&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#numpy.lib.recfunctions.assign_fields_by_name&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.assign_fields_by_name&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#numpy.lib.recfunctions.require_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.require_fields&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2fa6844c3d81a6fe2067c8e0e928cef4f2f272dc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;range(6)&lt;/code&gt;, information on what kind of rounding is done in addition, and on how underflow is handled.</source>
          <target state="translated">在 &lt;code&gt;range(6)&lt;/code&gt; 中，此外还提供有关如何进行四舍五入以及如何处理下溢的信息。</target>
        </trans-unit>
        <trans-unit id="50fbd12243b4769e24084faa8adf2287f6b3d6cd" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;explicit mode&lt;/em&gt; the output can be directly controlled by specifying output subscript labels. This requires the identifier &amp;lsquo;-&amp;gt;&amp;rsquo; as well as the list of output subscript labels. This feature increases the flexibility of the function since summing can be disabled or forced when required. The call &lt;code&gt;np.einsum('i-&amp;gt;', a)&lt;/code&gt; is like &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;np.sum(a, axis=-1)&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; is like &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;np.diag(a)&lt;/code&gt;&lt;/a&gt;. The difference is that &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; does not allow broadcasting by default. Additionally &lt;code&gt;np.einsum('ij,jh-&amp;gt;ih', a, b)&lt;/code&gt; directly specifies the order of the output subscript labels and therefore returns matrix multiplication, unlike the example above in implicit mode.</source>
          <target state="translated">在&lt;em&gt;显式模式下&lt;/em&gt;，可以通过指定输出下标标签直接控制输出。这需要标识符&amp;ldquo;-&amp;gt;&amp;rdquo;以及输出下标标签的列表。此功能增加了功能的灵活性，因为可以在需要时禁用或强制求和。调用 &lt;code&gt;np.einsum('i-&amp;gt;', a)&lt;/code&gt; 就像&lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;np.sum(a, axis=-1)&lt;/code&gt; &lt;/a&gt;，而 &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; 就像&lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;np.diag(a)&lt;/code&gt; &lt;/a&gt;。区别在于&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;默认情况下不允许广播。另外，与上面的隐式模式示例不同 &lt;code&gt;np.einsum('ij,jh-&amp;gt;ih', a, b)&lt;/code&gt; 直接指定输出下标标签的顺序，因此返回矩阵乘法。</target>
        </trans-unit>
        <trans-unit id="c0145016518b0031bebdd7367da2ce7b6495c4d5" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;explicit&lt;/em&gt; mode, &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; provides further flexibility to compute other array operations that might not be considered classical Einstein summation operations, by disabling, or forcing summation over specified subscript labels.</source>
          <target state="translated">在&lt;em&gt;显式&lt;/em&gt;模式下，&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;通过禁用或强制对指定下标标签进行求和，从而提供了更大的灵活性来计算其他数组操作（可能不被视为经典的爱因斯坦求和操作）。</target>
        </trans-unit>
        <trans-unit id="4c8b68052719d1c1d5215bfd711f82950ca7a1df" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;implicit mode&lt;/em&gt;, the chosen subscripts are important since the axes of the output are reordered alphabetically. This means that &lt;code&gt;np.einsum('ij', a)&lt;/code&gt; doesn&amp;rsquo;t affect a 2D array, while &lt;code&gt;np.einsum('ji', a)&lt;/code&gt; takes its transpose. Additionally, &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; returns a matrix multiplication, while, &lt;code&gt;np.einsum('ij,jh', a, b)&lt;/code&gt; returns the transpose of the multiplication since subscript &amp;lsquo;h&amp;rsquo; precedes subscript &amp;lsquo;i&amp;rsquo;.</source>
          <target state="translated">在&lt;em&gt;隐式模式下&lt;/em&gt;，选择的下标很重要，因为输出的轴按字母顺序重新排序。这意味着 &lt;code&gt;np.einsum('ij', a)&lt;/code&gt; 不影响2D数组，而 &lt;code&gt;np.einsum('ji', a)&lt;/code&gt; 进行转置。此外， &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; 返回矩阵乘法，而 &lt;code&gt;np.einsum('ij,jh', a, b)&lt;/code&gt; 返回乘法转置，因为下标'h'在下标之前'一世'。</target>
        </trans-unit>
        <trans-unit id="065543ba7b7c467e5ff1cf1108109daa4f6f9b2e" translate="yes" xml:space="preserve">
          <source>In C, there is no equivalent to the deprecation warnings that Python supports. One way to do deprecations is to flag them in the documentation and release notes, then remove or change the deprecated features in a future major version (NumPy 2.0 and beyond). Minor versions of NumPy should not have major C-API changes, however, that prevent code that worked on a previous minor release. For example, we will do our best to ensure that code that compiled and worked on NumPy 1.4 should continue to work on NumPy 1.7 (but perhaps with compiler warnings).</source>
          <target state="translated">在C语言中,没有与Python支持的recrecation警告相对应的功能。一种方法是在文档和发布说明中标记它们,然后在未来的主要版本中(NumPy 2.0及以后的版本)删除或更改被废弃的特性。然而,NumPy的小版本不应该有重大的C-API变化,这些变化阻止了在以前的小版本上工作的代码。例如,我们会尽最大努力确保在NumPy 1.4上编译和工作的代码在NumPy 1.7上继续工作(但可能会有编译器警告)。</target>
        </trans-unit>
        <trans-unit id="a9ca8be4f66144d7c2dcc488bdd409f6a21dcaf9" translate="yes" xml:space="preserve">
          <source>In IPython it is also possible to run individual examples simply by copy-pasting them in doctest mode:</source>
          <target state="translated">在IPython中,也可以通过复制粘贴在doctest模式下运行单个例子。</target>
        </trans-unit>
        <trans-unit id="1971f366d86d58fc78c8e9d3d0151d96fbd74efd" translate="yes" xml:space="preserve">
          <source>In MATLAB the main tool available to you for customizing the environment is to modify the search path with the locations of your favorite functions. You can put such customizations into a startup script that MATLAB will run on startup.</source>
          <target state="translated">在MATLAB中,您可用于自定义环境的主要工具是用您喜欢的函数的位置修改搜索路径。你可以把这样的自定义放入一个启动脚本中,MATLAB将在启动时运行。</target>
        </trans-unit>
        <trans-unit id="494eed34e26fa744c79b6950c743fa3931771a94" translate="yes" xml:space="preserve">
          <source>In MATLAB&amp;reg; the main tool available to you for customizing the environment is to modify the search path with the locations of your favorite functions. You can put such customizations into a startup script that MATLAB will run on startup.</source>
          <target state="translated">在MATLAB&amp;reg;中，可用于自定义环境的主要工具是使用您喜欢的函数的位置来修改搜索路径。您可以将此类自定义放入启动脚本中，以便MATLAB在启动时运行。</target>
        </trans-unit>
        <trans-unit id="05b064c6c8d4ad79dd43510f89eb8bbc99cffd4b" translate="yes" xml:space="preserve">
          <source>In MATLAB&amp;reg;, arrays have pass-by-value semantics, with a lazy copy-on-write scheme to prevent actually creating copies until they are actually needed. Slice operations copy parts of the array.</source>
          <target state="translated">在MATLAB&amp;reg;中，数组具有按值传递的语义，并且具有惰性的写入时复制方案，可以防止在实际需要之前创建实际的副本。切片操作将复制阵列的某些部分。</target>
        </trans-unit>
        <trans-unit id="35c279433c70eb2d4b30f568fbc349c5cc15292b" translate="yes" xml:space="preserve">
          <source>In MATLAB&amp;reg;, the basic data type is a multidimensional array of double precision floating point numbers. Most expressions take such arrays and return such arrays. Operations on the 2-D instances of these arrays are designed to act more or less like matrix operations in linear algebra.</source>
          <target state="translated">在MATLAB&amp;reg;中，基本数据类型是双精度浮点数的多维数组。大多数表达式采用此类数组并返回此类数组。这些数组的2-D实例上的运算被设计为或多或少地像线性代数中的矩阵运算一样起作用。</target>
        </trans-unit>
        <trans-unit id="7b6b97a69c13a8b76d236409c27d01def9d5d4b3" translate="yes" xml:space="preserve">
          <source>In MATLAB, the basic type, even for scalars, is a multidimensional array. Array assignments in MATLAB are stored as 2D arrays of double precision floating point numbers, unless you specify the number of dimensions and type. Operations on the 2D instances of these arrays are modeled on matrix operations in linear algebra.</source>
          <target state="translated">在MATLAB中,即使是标量,其基本类型也是多维数组。MATLAB中的数组赋值被存储为双精度浮点数的二维数组,除非您指定维数和类型。对这些数组的二维实例的操作是以线性代数中的矩阵操作为模型的。</target>
        </trans-unit>
        <trans-unit id="a7fc4e4e9aaf59319f61cb1b2c8333ad9f8d065b" translate="yes" xml:space="preserve">
          <source>In NumPy 1.16, you need to set the environment variable &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1&lt;/code&gt; before importing NumPy to use NumPy function overrides.</source>
          <target state="translated">在NumPy 1.16中，您需要在导入NumPy以使用NumPy函数替代之前设置环境变量 &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d05b90f328ed41700350ed32107071a1f6f3fbc" translate="yes" xml:space="preserve">
          <source>In NumPy 1.17, the protocol is enabled by default, but can be disabled with &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0&lt;/code&gt;.</source>
          <target state="translated">在NumPy 1.17中，默认情况下启用该协议，但可以使用 &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0&lt;/code&gt; 禁用该协议。</target>
        </trans-unit>
        <trans-unit id="1b4938fa72e1c7213ec03de65817f46747825eb5" translate="yes" xml:space="preserve">
          <source>In NumPy 1.6.0, a type promotion API was created to encapsulate the mechanism for determining output types. See the functions &lt;a href=&quot;generated/numpy.result_type#numpy.result_type&quot;&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">在NumPy 1.6.0中，创建了类型升级API以封装用于确定输出类型的机制。有关更多详细信息，请参见函数&lt;a href=&quot;generated/numpy.result_type#numpy.result_type&quot;&gt; &lt;code&gt;result_type&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;generated/numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;generated/numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6817ac22605fc4c2d0f573a2b14f3a89cb1e8f22" translate="yes" xml:space="preserve">
          <source>In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal, but depending on this fact is deprecated. Writing to the resulting array continues to work as it used to, but a FutureWarning is issued.</source>
          <target state="translated">在NumPy 1.7和1.8中,它继续返回对角线的副本,但根据这一事实,它已被废弃。写入结果的数组继续像以前一样工作,但会发出未来警告。</target>
        </trans-unit>
        <trans-unit id="117fbe2ef07a30dba33092bb43c1ec1f63fe2b7a" translate="yes" xml:space="preserve">
          <source>In NumPy 1.7 and later, this form allows &lt;code&gt;base_dtype&lt;/code&gt; to be interpreted as a structured dtype. Arrays created with this dtype will have underlying dtype &lt;code&gt;base_dtype&lt;/code&gt; but will have fields and flags taken from &lt;code&gt;new_dtype&lt;/code&gt;. This is useful for creating custom structured dtypes, as done in &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record arrays&lt;/a&gt;.</source>
          <target state="translated">在NumPy 1.7和更高版本中，此格式允许将 &lt;code&gt;base_dtype&lt;/code&gt; 解释为结构化dtype。使用此 &lt;code&gt;base_dtype&lt;/code&gt; 创建的数组将具有基础dtype base_dtype，但具有从 &lt;code&gt;new_dtype&lt;/code&gt; 获取的字段和标志。这对于创建自定义结构化dtype很有用，就像在&lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record array中一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11387d0f86941bf54bf7c514e7a5b1f0fd171696" translate="yes" xml:space="preserve">
          <source>In NumPy arrays have pass-by-reference semantics. Slice operations are views into an array.</source>
          <target state="translated">在NumPy中,数组具有逐次引用的语义。切片操作是对数组的视图。</target>
        </trans-unit>
        <trans-unit id="0193a49a749beca871335b39ba584f160aa0e7bd" translate="yes" xml:space="preserve">
          <source>In NumPy the basic type is a multidimensional &lt;code&gt;array&lt;/code&gt;. Operations on these arrays in all dimensionalities including 2D are element-wise operations. One needs to use specific functions for linear algebra (though for matrix multiplication, one can use the &lt;code&gt;@&lt;/code&gt; operator in python 3.5 and above).</source>
          <target state="translated">在NumPy中，基本类型是多维 &lt;code&gt;array&lt;/code&gt; 。在包括2D在内的所有维度上对这些数组进行的操作都是按元素进行的操作。一个人需要对线性代数使用特定的函数（尽管对于矩阵乘法，可以在python 3.5及更高版本中使用 &lt;code&gt;@&lt;/code&gt; 运算符）。</target>
        </trans-unit>
        <trans-unit id="3b53f7eb15b7831e508349b1a60777dcdbd79a0e" translate="yes" xml:space="preserve">
          <source>In NumPy versions &amp;lt;= 1.9.0 Nan is returned for slices that are all-NaN or empty. In later versions zero is returned.</source>
          <target state="translated">在NumPy版本&amp;lt;= 1.9.0中，对于全NaN或空的片返回Nan。在更高版本中，返回零。</target>
        </trans-unit>
        <trans-unit id="36d3e5a6749595663c6dacbe6e7c386adcf1a912" translate="yes" xml:space="preserve">
          <source>In NumPy, dimensions are called &lt;strong&gt;axes&lt;/strong&gt;. This means that if you have a 2D array that looks like this:</source>
          <target state="translated">在NumPy中，尺寸称为&lt;strong&gt;轴&lt;/strong&gt;。这意味着，如果您有一个如下所示的2D数组：</target>
        </trans-unit>
        <trans-unit id="175572b3b0d248e7569a97712bffa8366f334be5" translate="yes" xml:space="preserve">
          <source>In NumPy, the basic type is a multidimensional &lt;code&gt;array&lt;/code&gt;. Array assignments in NumPy are usually stored as &lt;a href=&quot;../reference/arrays#arrays&quot;&gt;n-dimensional arrays&lt;/a&gt; with the minimum type required to hold the objects in sequence, unless you specify the number of dimensions and type. NumPy performs operations element-by-element, so multiplying 2D arrays with &lt;code&gt;*&lt;/code&gt; is not a matrix multiplication &amp;ndash; it&amp;rsquo;s an element-by-element multiplication. (The &lt;code&gt;@&lt;/code&gt; operator, available since Python 3.5, can be used for conventional matrix multiplication.)</source>
          <target state="translated">在NumPy中，基本类型是多维 &lt;code&gt;array&lt;/code&gt; 。 NumPy中的数组分配通常以&lt;a href=&quot;../reference/arrays#arrays&quot;&gt;n维数组的&lt;/a&gt;形式存储，具有按顺序保存对象所需的最小类型，除非您指定维数和类型。 NumPy执行逐个元素的操作，因此将2D数组与 &lt;code&gt;*&lt;/code&gt; 相乘不是矩阵乘法，而是一个逐个元素的乘法。 （ &lt;code&gt;@&lt;/code&gt; 运算符自Python 3.5起可用，可用于常规矩阵乘法。）</target>
        </trans-unit>
        <trans-unit id="ed78411a5f19815c75577c53c9647b97f455af34" translate="yes" xml:space="preserve">
          <source>In NumPy, there are 24 new fundamental Python types to describe different types of scalars. These type descriptors are mostly based on the types available in the C language that CPython is written in, with several additional types compatible with Python&amp;rsquo;s types.</source>
          <target state="translated">在NumPy中，有24种新的基本Python类型来描述不同类型的标量。这些类型描述符主要基于编写CPython的C语言中可用的类型，以及与Python类型兼容的其他几种类型。</target>
        </trans-unit>
        <trans-unit id="72d772d403bb9e7043a8b7f8c594e1144a74fb8c" translate="yes" xml:space="preserve">
          <source>In NumPy, universal functions are instances of the &lt;a href=&quot;generated/numpy.ufunc#numpy.ufunc&quot;&gt;&lt;code&gt;numpy.ufunc&lt;/code&gt;&lt;/a&gt; class. Many of the built-in functions are implemented in compiled C code. The basic ufuncs operate on scalars, but there is also a generalized kind for which the basic elements are sub-arrays (vectors, matrices, etc.), and broadcasting is done over other dimensions. One can also produce custom &lt;a href=&quot;generated/numpy.ufunc#numpy.ufunc&quot;&gt;&lt;code&gt;ufunc&lt;/code&gt;&lt;/a&gt; instances using the &lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt;&lt;code&gt;frompyfunc&lt;/code&gt;&lt;/a&gt; factory function.</source>
          <target state="translated">在NumPy中，通用函数是&lt;a href=&quot;generated/numpy.ufunc#numpy.ufunc&quot;&gt; &lt;code&gt;numpy.ufunc&lt;/code&gt; &lt;/a&gt;类的实例。许多内置函数是在已编译的C代码中实现的。基本ufunc在标量上运行，但是也存在一种通用类型，其基本元素是子数组（向量，矩阵等），并且在其他维度上进行广播。你也可以定制生产&lt;a href=&quot;generated/numpy.ufunc#numpy.ufunc&quot;&gt; &lt;code&gt;ufunc&lt;/code&gt; &lt;/a&gt;使用情况&lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt; &lt;code&gt;frompyfunc&lt;/code&gt; &lt;/a&gt;工厂函数。</target>
        </trans-unit>
        <trans-unit id="0c775f1e9d60e517f99b3f4fb5fbef2cd48f1233" translate="yes" xml:space="preserve">
          <source>In NumPy, universal functions are instances of the &lt;code&gt;numpy.ufunc&lt;/code&gt; class. Many of the built-in functions are implemented in compiled C code. The basic ufuncs operate on scalars, but there is also a generalized kind for which the basic elements are sub-arrays (vectors, matrices, etc.), and broadcasting is done over other dimensions. One can also produce custom &lt;code&gt;ufunc&lt;/code&gt; instances using the &lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt;&lt;code&gt;frompyfunc&lt;/code&gt;&lt;/a&gt; factory function.</source>
          <target state="translated">在NumPy中，通用函数是 &lt;code&gt;numpy.ufunc&lt;/code&gt; 类的实例。许多内置函数是在已编译的C代码中实现的。基本ufunc在标量上运行，但是也存在一种通用类型，其基本元素是子数组（向量，矩阵等），并且在其他维度上进行广播。你也可以定制生产 &lt;code&gt;ufunc&lt;/code&gt; 使用情况&lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt; &lt;code&gt;frompyfunc&lt;/code&gt; &lt;/a&gt;工厂函数。</target>
        </trans-unit>
        <trans-unit id="15ce5a6b4ac0eac09144a9d2b2aa63ae33e8eb97" translate="yes" xml:space="preserve">
          <source>In NumPy, usually a synonym for &lt;a href=&quot;#term-array-scalar&quot;&gt;array scalar&lt;/a&gt;.</source>
          <target state="translated">在NumPy中，通常是&lt;a href=&quot;#term-array-scalar&quot;&gt;array scalar&lt;/a&gt;的同义词。</target>
        </trans-unit>
        <trans-unit id="5a0e80530034196e1f24b0c9706df1a29c31a997" translate="yes" xml:space="preserve">
          <source>In NumPy, usually a synonym for &lt;a href=&quot;#term-dtype&quot;&gt;dtype&lt;/a&gt;. For the more general Python meaning, &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-type&quot;&gt;see here.&lt;/a&gt;</source>
          <target state="translated">在NumPy中，通常是&lt;a href=&quot;#term-dtype&quot;&gt;dtype&lt;/a&gt;的同义词。有关更一般的Python含义，&lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-type&quot;&gt;请参见此处。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="774635ebbde845fd67b0f22449de4d887322609c" translate="yes" xml:space="preserve">
          <source>In Numeric, the ancestor of Numpy, broadcasting was implemented in several lines of code buried deep in ufuncobject.c. In NumPy, the notion of broadcasting has been abstracted so that it can be performed in multiple places. Broadcasting is handled by the function &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt;. This function requires a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; (or something that is a binary equivalent) to be passed in. The &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the broadcast number of dimensions and size in each dimension along with the total size of the broadcast result. It also keeps track of the number of arrays being broadcast and a pointer to an iterator for each of the arrays being broadcast.</source>
          <target state="translated">在Numpy的祖先Numeric中，广播是通过深埋在ufuncobject.c中的几行代码实现的。在NumPy中，广播的概念已被抽象化，因此可以在多个地方进行广播。广播由函数&lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt;处理。此函数需要&lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;一个PyArrayMultiIterObject（或等效的二进制文件）&lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;跟踪广播的维数和​​每个维的大小以及广播结果的总大小。它还跟踪正在广播的阵列的数量，以及每个正在广播的阵列的指向迭代器的指针。</target>
        </trans-unit>
        <trans-unit id="8922bb1c700cbaf5cb6e489ccc3a2d78c8e39611" translate="yes" xml:space="preserve">
          <source>In Numeric, the ancestor of Numpy, broadcasting was implemented in several lines of code buried deep in ufuncobject.c. In NumPy, the notion of broadcasting has been abstracted so that it can be performed in multiple places. Broadcasting is handled by the function &lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt;. This function requires a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; (or something that is a binary equivalent) to be passed in. The &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the broadcast number of dimensions and size in each dimension along with the total size of the broadcast result. It also keeps track of the number of arrays being broadcast and a pointer to an iterator for each of the arrays being broadcast.</source>
          <target state="translated">在Numpy的祖先Numeric中，广播是通过深埋在ufuncobject.c中的几行代码实现的。在NumPy中，广播的概念已被抽象化，因此可以在多个地方进行广播。广播由函数&lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt;处理。此函数需要&lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;一个PyArrayMultiIterObject（或等效的二进制文件）&lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt;跟踪广播的维数和​​每个维的大小以及广播结果的总大小。它还跟踪正在广播的数组的数量以及每个正在广播的数组的指向迭代器的指针。</target>
        </trans-unit>
        <trans-unit id="22b48541001b861013a36c818439e26a1074dfe7" translate="yes" xml:space="preserve">
          <source>In Numpy 1.15, indexing an array with a multi-field index returned a copy of the result above, but with fields packed together in memory as if passed through &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在Numpy 1.15中，对具有多字段索引的数组建立索引将返回上述结果的副本，但&lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt; &lt;/a&gt;字段打包在一起，就像通过numpy.lib.recfunctions.repack_fields一样。</target>
        </trans-unit>
        <trans-unit id="1b22fd0d42a99bd19673ecd40259cf68612486f3" translate="yes" xml:space="preserve">
          <source>In Python 3.0, &lt;code&gt;//&lt;/code&gt; is the floor division operator and &lt;code&gt;/&lt;/code&gt; the true division operator. The &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; function is equivalent to true division in Python.</source>
          <target state="translated">在Python 3.0中， &lt;code&gt;//&lt;/code&gt; 是下位除法运算符和 &lt;code&gt;/&lt;/code&gt; 是真正的除法运算符。所述 &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; 函数等同于在Python真实划分。</target>
        </trans-unit>
        <trans-unit id="62fa547333a8d1dc9c0d4f4c02b89f627c6e6bc6" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;//&lt;/code&gt; is the floor division operator and &lt;code&gt;/&lt;/code&gt; the true division operator. The &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; function is equivalent to true division in Python.</source>
          <target state="translated">在Python中， &lt;code&gt;//&lt;/code&gt; 是下位除法运算符和 &lt;code&gt;/&lt;/code&gt; 是真正的除法运算符。所述 &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; 函数等同于在Python真实划分。</target>
        </trans-unit>
        <trans-unit id="c2ae9f01dfbac70b64c2f45fa3c211ed297fec42" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;arr[i, j]&lt;/code&gt; is exactly the same as &lt;code&gt;arr[(i, j)]&lt;/code&gt;&amp;mdash;so we can put &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; in a &lt;code&gt;tuple&lt;/code&gt; and then do the indexing with that.</source>
          <target state="translated">在Python中， &lt;code&gt;arr[i, j]&lt;/code&gt; 与 &lt;code&gt;arr[(i, j)]&lt;/code&gt; 完全相同&amp;mdash;因此我们可以将 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 放入一个 &lt;code&gt;tuple&lt;/code&gt; ，然后对其进行索引。</target>
        </trans-unit>
        <trans-unit id="060ed7eb6876dfc9a447b37757dfa0a45bd6069c" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;x[(exp1, exp2, ..., expN)]&lt;/code&gt; is equivalent to &lt;code&gt;x[exp1, exp2, ..., expN]&lt;/code&gt;; the latter is just syntactic sugar for the former.</source>
          <target state="translated">在Python中， &lt;code&gt;x[(exp1, exp2, ..., expN)]&lt;/code&gt; 等效于 &lt;code&gt;x[exp1, exp2, ..., expN]&lt;/code&gt; ; 后者只是前者的语法糖。</target>
        </trans-unit>
        <trans-unit id="667b044648896477b62af8727dbe5136eaaff74b" translate="yes" xml:space="preserve">
          <source>In Python:</source>
          <target state="translated">在Python中。</target>
        </trans-unit>
        <trans-unit id="269b609eb84c47b360c36d70b62b2cd1bb86a5a5" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, each sub-type is called a &lt;code&gt;field&lt;/code&gt;. The &lt;code&gt;field&lt;/code&gt; has a name (a string), a type (any valid dtype), and an optional &lt;code&gt;title&lt;/code&gt;. See &lt;a href=&quot;reference/arrays.dtypes#arrays-dtypes&quot;&gt;Data type objects (dtype)&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;#term-structured-data-type&quot;&gt;结构化数据类型中&lt;/a&gt;，每个子类型都称为 &lt;code&gt;field&lt;/code&gt; 。该 &lt;code&gt;field&lt;/code&gt; 具有名称（字符串），类型（任何有效的dtype）和可选的 &lt;code&gt;title&lt;/code&gt; 。请参见&lt;a href=&quot;reference/arrays.dtypes#arrays-dtypes&quot;&gt;数据类型对象（dtype）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78662ce2ae98004557ba9c8d13d5c59518b52877" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, each subtype is called a &lt;code&gt;field&lt;/code&gt;. The &lt;code&gt;field&lt;/code&gt; has a name (a string), a type (any valid dtype), and an optional &lt;code&gt;title&lt;/code&gt;. See &lt;a href=&quot;reference/arrays.dtypes#arrays-dtypes&quot;&gt;Data type objects (dtype)&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;#term-structured-data-type&quot;&gt;结构化数据类型中&lt;/a&gt;，每个子类型都称为 &lt;code&gt;field&lt;/code&gt; 。该 &lt;code&gt;field&lt;/code&gt; 具有名称（字符串），类型（任何有效的dtype）和可选的 &lt;code&gt;title&lt;/code&gt; 。请参阅&lt;a href=&quot;reference/arrays.dtypes#arrays-dtypes&quot;&gt;数据类型对象（dtype）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7514faa85354deb212fc2851d0e9a73ad2bab680" translate="yes" xml:space="preserve">
          <source>In a dtype declaration, indicates that the data is &lt;a href=&quot;#term-big-endian&quot;&gt;big-endian&lt;/a&gt; (the bracket is big on the left).</source>
          <target state="translated">在dtype声明中，指示数据是&lt;a href=&quot;#term-big-endian&quot;&gt;大端的&lt;/a&gt;（括号在左边大）。</target>
        </trans-unit>
        <trans-unit id="00f212b64142d015b24d77af65f90b372712d4ee" translate="yes" xml:space="preserve">
          <source>In a dtype declaration, indicates that the data is &lt;a href=&quot;#term-little-endian&quot;&gt;little-endian&lt;/a&gt; (the bracket is big on the right).</source>
          <target state="translated">在dtype声明中，指示数据为&lt;a href=&quot;#term-little-endian&quot;&gt;低位字节序&lt;/a&gt;（右括号为大）。</target>
        </trans-unit>
        <trans-unit id="2721403cc827c0b84ea65a28ef2dffa50ceb53e2" translate="yes" xml:space="preserve">
          <source>In a nutshell, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; runs two main loops. The first loop converts each line of the file in a sequence of strings. The second loop converts each string to the appropriate data type. This mechanism is slower than a single loop, but gives more flexibility. In particular, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; is able to take missing data into account, when other faster and simpler functions like &lt;a href=&quot;../reference/generated/numpy.loadtxt#numpy.loadtxt&quot;&gt;&lt;code&gt;loadtxt&lt;/code&gt;&lt;/a&gt; cannot.</source>
          <target state="translated">简而言之，&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;运行两个主循环。第一个循环按字符串序列转换文件的每一行。第二个循环将每个字符串转换为适当的数据类型。这种机制比单循环慢，但具有更大的灵活性。特别是，当其他更快更简单的功能（如&lt;a href=&quot;../reference/generated/numpy.loadtxt#numpy.loadtxt&quot;&gt; &lt;code&gt;loadtxt&lt;/code&gt; )&lt;/a&gt;无法执行时，&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;能够考虑丢失的数据。</target>
        </trans-unit>
        <trans-unit id="0643c04fa6f173d8a3f9cc4f3ce84f7f07625090" translate="yes" xml:space="preserve">
          <source>In a study, testing for a specific alternative to the null hypothesis requires use of the Noncentral F distribution. We need to calculate the area in the tail of the distribution that exceeds the value of the F distribution for the null hypothesis. We&amp;rsquo;ll plot the two probability distributions for comparison.</source>
          <target state="translated">在一项研究中，测试零假设的特定替代方法需要使用非中心F分布。我们需要为零假设计算分布尾部中超过F分布值的面积。我们将绘制两个概率分布以进行比较。</target>
        </trans-unit>
        <trans-unit id="4a555d5f0fdb6581c9697563824e3d61c23e3de4" translate="yes" xml:space="preserve">
          <source>In a two&amp;rsquo;s-complement system negative numbers are represented by the two&amp;rsquo;s complement of the absolute value. This is the most common method of representing signed integers on computers &lt;a href=&quot;#r962252997619-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. A N-bit two&amp;rsquo;s-complement system can represent every integer in the range</source>
          <target state="translated">在二进制补码系统中，负数由绝对值的二进制补码表示。这是在计算机上表示带符号整数的最常见方法&lt;a href=&quot;#r962252997619-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。N位二进制补码系统可以表示范围内的每个整数</target>
        </trans-unit>
        <trans-unit id="77d7c8f0da722bad85b21b1524a660b76382145e" translate="yes" xml:space="preserve">
          <source>In a two-dimensional vector, the elements of axis 0 are rows and the elements of axis 1 are columns.</source>
          <target state="translated">在一个二维向量中,0轴的元素是行,1轴的元素是列。</target>
        </trans-unit>
        <trans-unit id="6ec708a7d401df6aafb3a323298b5e8a10e70e10" translate="yes" xml:space="preserve">
          <source>In addition &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; may be scalars, in which case:</source>
          <target state="translated">另外， &lt;code&gt;a&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt; 可以是标量，在这种情况下：</target>
        </trans-unit>
        <trans-unit id="85652b9aa303fc72ea7ade73af4f0dda2d5084d0" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;numpy.lib.io&lt;/code&gt; module provides several convenience functions derived from &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;. These functions work the same way as the original, but they have different default values.</source>
          <target state="translated">除了&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; 之外&lt;/a&gt;， &lt;code&gt;numpy.lib.io&lt;/code&gt; 模块还提供了一些从&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;派生的便利功能。这些函数的工作方式与原始函数相同，但是它们具有不同的默认值。</target>
        </trans-unit>
        <trans-unit id="a6237f20922b3630e0de0aceabbe18bc44178c19" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;numpy.lib.npyio&lt;/code&gt; module provides several convenience functions derived from &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;. These functions work the same way as the original, but they have different default values.</source>
          <target state="translated">除了&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; 之外&lt;/a&gt;， &lt;code&gt;numpy.lib.npyio&lt;/code&gt; 模块还提供了一些从&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;派生的便利功能。这些函数的工作方式与原始函数相同，但是它们具有不同的默认值。</target>
        </trans-unit>
        <trans-unit id="3b2e8925339289db83edc8e4d5703c4e6627acaa" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;__array_wrap__&lt;/code&gt;, which is called on the way out of the ufunc, there is also an &lt;code&gt;__array_prepare__&lt;/code&gt; method which is called on the way into the ufunc, after the output arrays are created but before any computation has been performed. The default implementation does nothing but pass through the array. &lt;code&gt;__array_prepare__&lt;/code&gt; should not attempt to access the array data or resize the array, it is intended for setting the output array type, updating attributes and metadata, and performing any checks based on the input that may be desired before computation begins. Like &lt;code&gt;__array_wrap__&lt;/code&gt;, &lt;code&gt;__array_prepare__&lt;/code&gt; must return an ndarray or subclass thereof or raise an error.</source>
          <target state="translated">除了 &lt;code&gt;__array_wrap__&lt;/code&gt; ，这就是所谓的出路ufunc的，也有一个 &lt;code&gt;__array_prepare__&lt;/code&gt; 被称为在途中进入ufunc，被创建的输出阵列之后但在已经执行任何计算之前方法。默认实现只对数组进行传递。 &lt;code&gt;__array_prepare__&lt;/code&gt; 不应尝试访问数组数据或调整数组大小，它旨在设置输出数组类型，更新属性和元数据，并根据计算开始之前可能需要的输入执行任何检查。像 &lt;code&gt;__array_wrap__&lt;/code&gt; ， &lt;code&gt;__array_prepare__&lt;/code&gt; 必须返回ndarray或子类或其引发错误。</target>
        </trans-unit>
        <trans-unit id="0202a847e7f1c55dfe19c04653df757ab3188d4f" translate="yes" xml:space="preserve">
          <source>In addition to attributes that can be specified via keyword arguments to &lt;code&gt;Configuration&lt;/code&gt; constructor, &lt;code&gt;Configuration&lt;/code&gt; instance (let us denote as &lt;code&gt;config&lt;/code&gt;) has the following attributes that can be useful in writing setup scripts:</source>
          <target state="translated">除了可以通过 &lt;code&gt;Configuration&lt;/code&gt; 构造函数的关键字参数指定的属性外， &lt;code&gt;Configuration&lt;/code&gt; 实例（让我们表示为 &lt;code&gt;config&lt;/code&gt; ）具有以下属性，这些属性在编写安装脚本时可能会有用：</target>
        </trans-unit>
        <trans-unit id="9205eb129a4d89ef4a9eb5c8d77614ae87b40a33" translate="yes" xml:space="preserve">
          <source>In addition to field names, fields may also have an associated &lt;a href=&quot;../glossary#term-title&quot;&gt;title&lt;/a&gt;, an alternate name, which is sometimes used as an additional description or alias for the field. The title may be used to index an array, just like a field name.</source>
          <target state="translated">除了字段名称之外，字段还可以具有关联的&lt;a href=&quot;../glossary#term-title&quot;&gt;标题&lt;/a&gt;（备用名称），该名称有时用作字段的附加描述或别名。标题可以像字段名一样用于索引数组。</target>
        </trans-unit>
        <trans-unit id="1ee5bd9d7a0e50bb5b466ac30e311415eba3cdbd" translate="yes" xml:space="preserve">
          <source>In addition to field names, structured array fields may have an associated &lt;a href=&quot;user/basics.rec#titles&quot;&gt;title&lt;/a&gt; which is an alias to the name and is commonly used for plotting.</source>
          <target state="translated">除字段名称外，结构化数组字段可能还具有关联的&lt;a href=&quot;user/basics.rec#titles&quot;&gt;标题&lt;/a&gt;，该标题是该名称的别名，通常用于绘图。</target>
        </trans-unit>
        <trans-unit id="5d8a9cc27249ffd4d0b1366a65411d876d2aa7c5" translate="yes" xml:space="preserve">
          <source>In addition to sort, which returns a sorted copy of an array, you can use:</source>
          <target state="translated">除了返回一个数组的排序副本的sort之外,你还可以使用:</target>
        </trans-unit>
        <trans-unit id="29ec49c4a4c9a814e9bec074f3eabcbf7dea786f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; class, the &lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module defines several constants.</source>
          <target state="translated">除了&lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;类之外，&lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt;模块还定义了几个常量。</target>
        </trans-unit>
        <trans-unit id="7b236bba71a2e6d9bbb7e9f54e04010c73fd209b" translate="yes" xml:space="preserve">
          <source>In addition to the Python C-API, there is a full and rich C-API for NumPy allowing sophisticated manipulations on a C-level. However, for most applications, only a few API calls will typically be used. For example, if you need to just extract a pointer to memory along with some shape information to pass to another calculation routine, then you will use very different calls than if you are trying to create a new array-like type or add a new data type for ndarrays. This chapter documents the API calls and macros that are most commonly used.</source>
          <target state="translated">除了Python C-API之外,NumPy还有一个完整而丰富的C-API,允许在C级上进行复杂的操作。然而,对于大多数应用来说,通常只会使用一些 API 调用。例如,如果你只需要提取一个指向内存的指针以及一些形状信息传递给另一个计算例程,那么你使用的调用将与你试图创建一个新的类似数组的类型或为ndarrays添加一个新的数据类型时截然不同。本章记录了最常用的API调用和宏。</target>
        </trans-unit>
        <trans-unit id="4c1e50029232768a84bc4dc52748436e5f14647c" translate="yes" xml:space="preserve">
          <source>In addition, F2PY introduces the following statements:</source>
          <target state="translated">此外,F2PY还引入了以下语句:</target>
        </trans-unit>
        <trans-unit id="50f7370be70d6fe0e899df628f5a07f23f4c4044" translate="yes" xml:space="preserve">
          <source>In addition, building the documentation requires the Sphinx extension &lt;code&gt;plot_directive&lt;/code&gt;, which is shipped with &lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;. This Sphinx extension can be installed by installing Matplotlib. You will also need Python&amp;gt;=3.6.</source>
          <target state="translated">另外，构建文档需要 &lt;code&gt;plot_directive&lt;/code&gt; 附带的Sphinx扩展&lt;a href=&quot;https://matplotlib.org/&quot;&gt;plot_directive&lt;/a&gt;。可以通过安装Matplotlib来安装此Sphinx扩展。您还需要Python&amp;gt; = 3.6。</target>
        </trans-unit>
        <trans-unit id="55ae7a3680f09394c2ee157c2db0452e71e75c1c" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;em&gt;data&lt;/em&gt; is non-NULL, then &lt;em&gt;strides&lt;/em&gt; can also be provided. If &lt;em&gt;strides&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the array strides are computed as C-style contiguous (default) or Fortran-style contiguous (&lt;em&gt;flags&lt;/em&gt; is nonzero for &lt;em&gt;data&lt;/em&gt; = &lt;code&gt;NULL&lt;/code&gt; or &lt;em&gt;flags&lt;/em&gt; &amp;amp; &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; is nonzero non-NULL &lt;em&gt;data&lt;/em&gt;). Any provided &lt;em&gt;dims&lt;/em&gt; and &lt;em&gt;strides&lt;/em&gt; are copied into newly allocated dimension and strides arrays for the new array object.</source>
          <target state="translated">此外，如果&lt;em&gt;数据&lt;/em&gt;为非NULL，则还可以提供&lt;em&gt;跨度&lt;/em&gt;。如果&lt;em&gt;strides&lt;/em&gt;为 &lt;code&gt;NULL&lt;/code&gt; ，则将数组的步长计算为C风格的连续（默认）或Fortran风格的连续（&lt;em&gt;数据的&lt;/em&gt;&lt;em&gt;标志&lt;/em&gt;为非零= &lt;code&gt;NULL&lt;/code&gt; 或&lt;em&gt;标志&lt;/em&gt;＆&lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;为非零的非NULL &lt;em&gt;数据&lt;/em&gt;）。提供的所有&lt;em&gt;暗淡&lt;/em&gt;和&lt;em&gt;步幅&lt;/em&gt;都将复制到新分配的维度和步幅数组中，以用于新的数组对象。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="176596f4a4076180f296c1297a5a4088a9dfbec9" translate="yes" xml:space="preserve">
          <source>In all the cases but the first one, the output will be a 1D array with a structured dtype. This dtype has as many fields as items in the sequence. The field names are defined with the &lt;code&gt;names&lt;/code&gt; keyword.</source>
          <target state="translated">在除第一种情况以外的所有情况下，输出都是具有结构化dtype的一维数组。此dtype具有与序列中的项目一样多的字段。字段名称是使用 &lt;code&gt;names&lt;/code&gt; 关键字定义的。</target>
        </trans-unit>
        <trans-unit id="9d28ba92ccb218b4c16f2db7077723c632363102" translate="yes" xml:space="preserve">
          <source>In all the examples so far, the elements of &lt;code&gt;a&lt;/code&gt; are provided by the iterator one at a time, because all the looping logic is internal to the iterator. While this is simple and convenient, it is not very efficient. A better approach is to move the one-dimensional innermost loop into your code, external to the iterator. This way, NumPy&amp;rsquo;s vectorized operations can be used on larger chunks of the elements being visited.</source>
          <target state="translated">到目前为止的所有示例中，a的元素 &lt;code&gt;a&lt;/code&gt; 都由迭代器提供，因为所有循环逻辑都在迭代器内部。尽管这既简单又方便，但是效率不是很高。更好的方法是将一维最内层循环移到代码中，位于迭代器外部。这样，NumPy的矢量化操作可用于要访问的元素的较大块。</target>
        </trans-unit>
        <trans-unit id="8389ffaf8c2e94e518381d310c79dd3ec1608070" translate="yes" xml:space="preserve">
          <source>In almost all cases &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; should be used instead of this function, as that will also return true for 0d arrays. This is how numpy overloads functions in the style of the &lt;code&gt;dx&lt;/code&gt; arguments to &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt;&lt;code&gt;gradient&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;bins&lt;/code&gt; argument to &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;. Some key differences:</source>
          <target state="translated">在几乎所有情况下，应使用 &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; 代替此函数，因为对于0d数组，该函数也将返回true。这就是numpy重载如何以 &lt;code&gt;dx&lt;/code&gt; 参数的形式&lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt; &lt;code&gt;gradient&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;bins&lt;/code&gt; 参数的&lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt;。一些主要区别：</target>
        </trans-unit>
        <trans-unit id="09406f1061497030999a27047c2ac1dba1e1fddd" translate="yes" xml:space="preserve">
          <source>In both cases, set the &lt;code&gt;BUILD_COMMIT&lt;/code&gt; variable to the current release tag - e.g. &lt;code&gt;v1.19.0&lt;/code&gt;:</source>
          <target state="translated">在这两种情况下，都将 &lt;code&gt;BUILD_COMMIT&lt;/code&gt; 变量设置为当前的发行标签-例如 &lt;code&gt;v1.19.0&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d0889b5074f2eea4eb02e68278d5fa430d814a4a" translate="yes" xml:space="preserve">
          <source>In case of merge conflicts, ask the PR submitter to &lt;a href=&quot;development_workflow#rebasing-on-master&quot;&gt;rebase on master&lt;/a&gt;.</source>
          <target state="translated">如果发生合并冲突，请PR提交者以&lt;a href=&quot;development_workflow#rebasing-on-master&quot;&gt;master为基础&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e277da1826bb81328288e7b48e1bc36cb3d9f8b" translate="yes" xml:space="preserve">
          <source>In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence are returned.</source>
          <target state="translated">如果最大值多次出现,则返回第一次出现的指数。</target>
        </trans-unit>
        <trans-unit id="27e7146cba1027fb05de967eb96a8d0d4f3188c0" translate="yes" xml:space="preserve">
          <source>In case of multiple occurrences of the minimum values, the indices corresponding to the first occurrence are returned.</source>
          <target state="translated">如果最小值出现多次,则返回第一次出现的指数。</target>
        </trans-unit>
        <trans-unit id="e0a4f4799ebef164e20467e93383e4d4633f2709" translate="yes" xml:space="preserve">
          <source>In case of severe and obvious breaches, e.g. personal threat or violent, sexist or racist language, we will immediately disconnect the originator from NumPy communication channels; please see the manual for details.</source>
          <target state="translated">如果出现严重和明显的违规行为,如人身威胁或暴力、性别歧视或种族主义语言,我们将立即断开发起人与NumPy的通信渠道;详情请见手册。</target>
        </trans-unit>
        <trans-unit id="ae3b7f089e082a13dedd4fd05f16654244713a03" translate="yes" xml:space="preserve">
          <source>In cases not involving clear severe and obvious breaches of this code of conduct, the process for acting on any received code of conduct violation report will be:</source>
          <target state="translated">在不涉及明显严重和明显违反本行为守则的情况下,对收到的任何违反行为守则的报告采取行动的程序是:</target>
        </trans-unit>
        <trans-unit id="b7695ef954df8bd205d22a810fa2781d2a8a8dfc" translate="yes" xml:space="preserve">
          <source>In certain cases a failed installation or setup issue can cause you to see the following error message:</source>
          <target state="translated">在某些情况下,安装或设置失败的问题会导致你看到以下错误信息。</target>
        </trans-unit>
        <trans-unit id="77e954d7daee979232398ad08ec5cc70a6a273a6" translate="yes" xml:space="preserve">
          <source>In code, arrays are often conveniently expressed as nested lists:</source>
          <target state="translated">在代码中,数组经常被方便地表达为嵌套列表。</target>
        </trans-unit>
        <trans-unit id="c38db33a30014f091c11009d703bc2b8cd0eeadd" translate="yes" xml:space="preserve">
          <source>In complex cases, &lt;a href=&quot;../reference/generated/numpy.r_#numpy.r_&quot;&gt;&lt;code&gt;r_&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.c_#numpy.c_&quot;&gt;&lt;code&gt;c_&lt;/code&gt;&lt;/a&gt; are useful for creating arrays by stacking numbers along one axis. They allow the use of range literals (&amp;ldquo;:&amp;rdquo;)</source>
          <target state="translated">在复杂的情况下，&lt;a href=&quot;../reference/generated/numpy.r_#numpy.r_&quot;&gt; &lt;code&gt;r_&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../reference/generated/numpy.c_#numpy.c_&quot;&gt; &lt;code&gt;c_&lt;/code&gt; &lt;/a&gt;对于通过沿一个轴堆叠数字来创建数组很有用。它们允许使用范围文字（&amp;ldquo;：&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="298a2b20fe81aca60c55bf455754cf5365f9ba46" translate="yes" xml:space="preserve">
          <source>In contrast to Python, where slicing creates a copy, in NumPy slicing creates a &lt;a href=&quot;#term-view&quot;&gt;view&lt;/a&gt;.</source>
          <target state="translated">与Python相比，切片可创建副本，而在NumPy中，切片可创建&lt;a href=&quot;#term-view&quot;&gt;view&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="15906ca68f2a7d7e2f6c027ec51f5d69dd3bed29" translate="yes" xml:space="preserve">
          <source>In copying mode, &amp;lsquo;copy&amp;rsquo; is specified as a per-operand flag. This is done to provide control in a per-operand fashion. Buffering mode is specified as an iterator flag.</source>
          <target state="translated">在复制模式下，&amp;ldquo; copy&amp;rdquo;被​​指定为每个操作数标志。这样做是为了以每个操作数的方式提供控制。缓冲模式被指定为迭代器标志。</target>
        </trans-unit>
        <trans-unit id="d217a2b2edd5733cc1a08fd36e52adeffd147a5f" translate="yes" xml:space="preserve">
          <source>In ctypes, the return-value of a function is set to be &amp;lsquo;int&amp;rsquo; by default. This behavior can be changed by setting the restype attribute of the function. Use None for the restype if the function has no return value (&amp;lsquo;void&amp;rsquo;):</source>
          <target state="translated">在ctypes中，默认情况下，函数的返回值设置为'int'。可以通过设置函数的restype属性来更改此行为。如果函数没有返回值（&amp;ldquo; void&amp;rdquo;），请对None类型使用None：</target>
        </trans-unit>
        <trans-unit id="20601c7341dfe87ba7a45fcff8c92729cd267fbb" translate="yes" xml:space="preserve">
          <source>In depth explanation of concepts, best practices and techniques</source>
          <target state="translated">深入解释概念、最佳做法和技术。</target>
        </trans-unit>
        <trans-unit id="2913833b48b2894352d88e1660f11e59aa09d3c6" translate="yes" xml:space="preserve">
          <source>In detail</source>
          <target state="translated">详细来说</target>
        </trans-unit>
        <trans-unit id="18557e967a450637ab72e77508fbfb08c6b092fc" translate="yes" xml:space="preserve">
          <source>In effect, the slice and index array operation are independent. The slice operation extracts columns with index 1 and 2, (i.e. the 2nd and 3rd columns), followed by the index array operation which extracts rows with index 0, 2 and 4 (i.e the first, third and fifth rows).</source>
          <target state="translated">实际上,分片操作和索引数组操作是独立的。分片操作提取索引1和2的列(即第2列和第3列),然后是索引数组操作,提取索引0、2和4的行(即第1、3和5行)。</target>
        </trans-unit>
        <trans-unit id="0401f70e9e9ccb692db031dd68efec8a8e548588" translate="yes" xml:space="preserve">
          <source>In every case, the &amp;lsquo;descr&amp;rsquo; key is optional, but of course provides more information which may be important for various applications:</source>
          <target state="translated">在每种情况下，&amp;ldquo; descr&amp;rdquo;键都是可选的，但是当然会提供更多信息，这些信息对于各种应用程序可能很重要：</target>
        </trans-unit>
        <trans-unit id="ed0824a3a5c26008c8df28fe72abd00f4b7f2a94" translate="yes" xml:space="preserve">
          <source>In every case, the moderator should make a reasonable effort to contact the originator, and tell them specifically how their language or actions qualify as a &amp;ldquo;clear and severe breach&amp;rdquo;. The moderator should also say that, if the originator believes this is unfair or they want to be reconnected to NumPy, they have the right to ask for a review, as below, by the Code of Conduct Committee. The moderator should copy this explanation to the Code of Conduct Committee.</source>
          <target state="translated">在每种情况下，主持人都应做出合理的努力与发起人联系，并特别告诉他们其语言或行为如何被视为&amp;ldquo;明显和严重的违反行为&amp;rdquo;。主持人还应该说，如果发起人认为这不公平，或者他们想与NumPy重新建立联系，则他们有权要求行为准则委员会进行如下审查。主持人应将此解释复制到《行为准则》委员会。</target>
        </trans-unit>
        <trans-unit id="7eac15d5d1d96d05ac021a41eb29548e9ee61a69" translate="yes" xml:space="preserve">
          <source>In fact, why don&amp;rsquo;t we try that?</source>
          <target state="translated">实际上，我们为什么不尝试呢？</target>
        </trans-unit>
        <trans-unit id="a50f2ab9bd768752351c518eb56b5f190e77022a" translate="yes" xml:space="preserve">
          <source>In general how to set and check your environment variables depends on your system. If you can open a correct python shell, you can also run the following in python:</source>
          <target state="translated">一般来说,如何设置和检查环境变量取决于你的系统。如果你能打开一个正确的python shell,你也可以在python中运行以下内容。</target>
        </trans-unit>
        <trans-unit id="51a2782158f2135b3873b2bc91584160c3224ec1" translate="yes" xml:space="preserve">
          <source>In general if an index includes a Boolean array, the result will be identical to inserting &lt;code&gt;obj.nonzero()&lt;/code&gt; into the same position and using the integer array indexing mechanism described above. &lt;code&gt;x[ind_1, boolean_array, ind_2]&lt;/code&gt; is equivalent to &lt;code&gt;x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]&lt;/code&gt;.</source>
          <target state="translated">通常，如果索引包含布尔数组，则结果将与将 &lt;code&gt;obj.nonzero()&lt;/code&gt; 插入相同位置并使用上述整数数组索引机制相同。 &lt;code&gt;x[ind_1, boolean_array, ind_2]&lt;/code&gt; 等效于 &lt;code&gt;x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0426d4d5e9174343610861881dfacd8c07a4e5a" translate="yes" xml:space="preserve">
          <source>In general, a scalar argument of a F2PY generated wrapper function can be an ordinary Python scalar (integer, float, complex number) as well as an arbitrary sequence object (list, tuple, array, string) of scalars. In the latter case, the first element of the sequence object is passed to Fortran routine as a scalar argument.</source>
          <target state="translated">一般来说,F2PY生成的封装函数的标量参数可以是普通的Python标量(整数、浮点数、复数),也可以是任意的标量序列对象(list、元组、数组、字符串)。在后一种情况下,序列对象的第一个元素作为一个标量参数传递给Fortran例程。</target>
        </trans-unit>
        <trans-unit id="41b09ab4340a010ae2242f6c23854be608350193" translate="yes" xml:space="preserve">
          <source>In general, array arguments of F2PY generated wrapper functions accept arbitrary sequences that can be transformed to NumPy array objects. An exception is &lt;code&gt;intent(inout)&lt;/code&gt; array arguments that always must be proper-contiguous and have proper type, otherwise an exception is raised. Another exception is &lt;code&gt;intent(inplace)&lt;/code&gt; array arguments that attributes will be changed &lt;em&gt;in situ&lt;/em&gt; if the argument has different type than expected (see &lt;code&gt;intent(inplace)&lt;/code&gt; attribute for more information).</source>
          <target state="translated">通常，F2PY生成的包装函数的数组参数接受可以转换为NumPy数组对象的任意序列。异常是 &lt;code&gt;intent(inout)&lt;/code&gt; 数组参数，该参数必须始终是适当连续的且具有适当的类型，否则会引发异常。另一个例外是 &lt;code&gt;intent(inplace)&lt;/code&gt; 数组参数，如果参数的类型与预期的类型不同，则属性将&lt;em&gt;在原位&lt;/em&gt;更改 &lt;code&gt;intent(inplace)&lt;/code&gt; 有关更多信息，请参见intent（inplace）属性）。</target>
        </trans-unit>
        <trans-unit id="ce9f087f4c4d9805ec9d46a8db9fd36d60eeb431" translate="yes" xml:space="preserve">
          <source>In general, for &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">一般而言，对于 &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4732749a65786e199f581dd65439c32d67356e7" translate="yes" xml:space="preserve">
          <source>In general, for arrays with more than two dimensions, &lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt; stacks along their second axes, &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt; stacks along their first axes, and &lt;a href=&quot;../reference/generated/numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt; allows for an optional arguments giving the number of the axis along which the concatenation should happen.</source>
          <target state="translated">通常，对于具有多于两个尺寸，阵列&lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt;沿其第二轴线栈，&lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt; &lt;code&gt;vstack&lt;/code&gt; &lt;/a&gt;堆叠沿它们的第一轴线，和&lt;a href=&quot;../reference/generated/numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt;允许一个可选参数给级联应沿着哪个发生的轴的数量。</target>
        </trans-unit>
        <trans-unit id="31150963fe6ef250ba4e833d06b222cca1c2cb70" translate="yes" xml:space="preserve">
          <source>In general, if a NumPy array is proper-contiguous and has a proper type then it is directly passed to wrapped Fortran/C function. Otherwise, an element-wise copy of an input array is made and the copy, being proper-contiguous and with proper type, is used as an array argument.</source>
          <target state="translated">一般来说,如果一个NumPy数组是合适的连续数组,并且有合适的类型,那么它就会直接传递给封装的Fortran/C函数。否则,将对一个输入数组进行元素复制,然后将这个具有适当连续性和适当类型的副本作为数组参数使用。</target>
        </trans-unit>
        <trans-unit id="13ea723c2a24ed6ef1771c5f258ea31816238b49" translate="yes" xml:space="preserve">
          <source>In general, if the array owns its own memory, as for &lt;code&gt;arr&lt;/code&gt; in this case, then &lt;code&gt;arr.base&lt;/code&gt; will be None - there are some exceptions to this - see the numpy book for more details.</source>
          <target state="translated">通常，如果数组拥有自己的内存（如本例中的 &lt;code&gt;arr&lt;/code&gt; )，则 &lt;code&gt;arr.base&lt;/code&gt; 将为None-对此有一些例外-有关更多详细信息，请参见numpy书。</target>
        </trans-unit>
        <trans-unit id="5abc873332e6b6be31064612f2de6812b8a80d3b" translate="yes" xml:space="preserve">
          <source>In general, it is not necessary to list class methods. Those that are not part of the public API have names that start with an underscore. In some cases, however, a class may have a great many methods, of which only a few are relevant (e.g., subclasses of ndarray). Then, it becomes useful to have an additional &lt;strong&gt;Methods&lt;/strong&gt; section:</source>
          <target state="translated">通常，没有必要列出类方法。那些不属于公共API的名称的名称以下划线开头。但是，在某些情况下，一个类可能有很多方法，其中只有少数几个是相关的（例如ndarray的子​​类）。然后，增加一个&amp;ldquo;&lt;strong&gt;方法&amp;rdquo;&lt;/strong&gt;部分将变得很有用：</target>
        </trans-unit>
        <trans-unit id="fcbe439e71ce76a6bc1cdecd65ffad854f695844" translate="yes" xml:space="preserve">
          <source>In general, numerical data arranged in an array-like structure in Python can be converted to arrays through the use of the array() function. The most obvious examples are lists and tuples. See the documentation for array() for details for its use. Some objects may support the array-protocol and allow conversion to arrays this way. A simple way to find out if the object can be converted to a numpy array using array() is simply to try it interactively and see if it works! (The Python Way).</source>
          <target state="translated">一般来说,在Python中以类似数组的结构排列的数值数据可以通过使用array()函数转换为数组。最明显的例子是列表和元组。关于它的使用细节,请参见 array()的文档。一些对象可能支持array-protocol,并允许以这种方式转换为数组。一个简单的方法可以找出是否可以使用 array()将对象转换为 numpy 数组,就是简单的交互式尝试,看看它是否有效! (Python方式)。</target>
        </trans-unit>
        <trans-unit id="4879f4fa7efdef399be3e3db9bf5ed36f36adbd1" translate="yes" xml:space="preserve">
          <source>In general, prefer &lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt;&lt;code&gt;numpy.save&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.load#numpy.load&quot;&gt;&lt;code&gt;numpy.load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常，更喜欢&lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt; &lt;code&gt;numpy.save&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../reference/generated/numpy.load#numpy.load&quot;&gt; &lt;code&gt;numpy.load&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2636b2d2555459756347b2bec78d067967d80c45" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one C-series by another results in quotient and remainder terms that are not in the Chebyshev polynomial basis set. Thus, to express these results as C-series, it is typically necessary to &amp;ldquo;reproject&amp;rdquo; the results onto said basis set, which typically produces &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">通常，一个C系列除以（多项式）所得的商和余项不在Chebyshev多项式基集中。因此，为了将这些结果表示为C系列，通常需要将结果&amp;ldquo;重新投影&amp;rdquo;到所述基集上，该基集通常会产生&amp;ldquo;不直观&amp;rdquo;（但正确）的结果。请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="e3455fcce926f7a356d4db4cbb1cca4337cab9da" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Hermite series by another results in quotient and remainder terms that are not in the Hermite polynomial basis set. Thus, to express these results as a Hermite series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Hermite basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">通常，一个Hermite级数的（多项式）除法会导致商和余数项不在Hermite多项式基集中。因此，要将这些结果表示为Hermite系列，有必要将结果&amp;ldquo;重新投影&amp;rdquo;到Hermite基础集上，这可能会产生&amp;ldquo;不直观&amp;rdquo;（但正确）的结果；请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="efbd236c04665a122a8e3491beed41d349724880" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Laguerre series by another results in quotient and remainder terms that are not in the Laguerre polynomial basis set. Thus, to express these results as a Laguerre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Laguerre basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">通常，一个Laguerre级数的（多项式）除法会导致商和余项项不在Laguerre多项式基集中。因此，要将这些结果表示为Laguerre级数，必须将结果&amp;ldquo;重新投影&amp;rdquo;到Laguerre基集上，这可能会产生&amp;ldquo;不直观&amp;rdquo;（但正确）的结果；请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="3e8f9ae8eb5287a2e2ca75de1027864d1ea7dce3" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Legendre series by another results in quotient and remainder terms that are not in the Legendre polynomial basis set. Thus, to express these results as a Legendre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Legendre basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">通常，一个勒让德系列的（多项式）除法会导致商和余项不在勒让德多项式基集中。因此，要将这些结果表示为Legendre系列，有必要将结果&amp;ldquo;重新投影&amp;rdquo;到Legendre基集上，这可能会产生&amp;ldquo;不直观&amp;rdquo;（但正确）的结果。请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="747e8b05b6e447bd7c26bc6951f1c707ad59f09d" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Chebyshev polynomial basis set. Thus, to express the product as a C-series, it is typically necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which typically produces &amp;ldquo;unintuitive live&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">通常，两个C系列的（多项式）乘积的结果不在Chebyshev多项式基集中。因此，为了将产品表示为C系列，通常需要将产品&amp;ldquo;重新投影&amp;rdquo;到所述基集上，这通常会产生&amp;ldquo;不直观的实时&amp;rdquo;（但正确的）结果；请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="140624c01263c11121eb8733a7573189c8b35148" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Hermite polynomial basis set. Thus, to express the product as a Hermite series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">通常，两个C系列的（多项式）乘积的结果不在Hermite多项式基集中。因此，要将产品表示为Hermite系列，有必要将产品&amp;ldquo;重新投影&amp;rdquo;到所述基集上，这可能会产生&amp;ldquo;不直观&amp;rdquo;（但正确）的结果；请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="4be0c1b381e26e882c60023195f1e89d336414ac" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Laguerre polynomial basis set. Thus, to express the product as a Laguerre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">通常，两个C系列的（多项式）乘积的结果不在Laguerre多项式基集中。因此，要将产品表示为Laguerre系列，有必要将产品&amp;ldquo;重新投影&amp;rdquo;到所述基集上，这可能会产生&amp;ldquo;不直观&amp;rdquo;（但正确）的结果。请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="54659a570a760a1d9fe356eba1a0141427eabe1f" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Legendre polynomial basis set. Thus, to express the product as a Legendre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">通常，两个C系列的（多项式）乘积的结果不在勒让德多项式基集中。因此，要将产品表示为Legendre系列，有必要将产品&amp;ldquo;重新投影&amp;rdquo;到所述基础集上，这可能会产生&amp;ldquo;不直观&amp;rdquo;（但正确）的结果；请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="afe18211391947a00635543978b5840ef054bbac" translate="yes" xml:space="preserve">
          <source>In general, the contents of signature files is case-sensitive. When scanning Fortran codes and writing a signature file, F2PY lowers all cases automatically except in multiline blocks or when &lt;code&gt;--no-lower&lt;/code&gt; option is used.</source>
          <target state="translated">通常，签名文件的内容区分大小写。扫描Fortran代码并写入签名文件时，F2PY会自动降低所有情况，除非在多行块中或使用 &lt;code&gt;--no-lower&lt;/code&gt; 选项时。</target>
        </trans-unit>
        <trans-unit id="de938489906c2e0d2c954a8201ef415c1aa719ca" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a C-series needs to be &amp;ldquo;reprojected&amp;rdquo; onto the C-series basis set. Thus, typically, the result of this function is &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">通常，区分C系列的结果需要&amp;ldquo;重新投影&amp;rdquo;到C系列基础集上。因此，通常，此功能的结果是&amp;ldquo;不直观的&amp;rdquo;，尽管是正确的。请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="dc47191395ffa64cfa2441fe3b165eeaca46d090" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Hermite series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">通常，区分Hermite级数的结果与幂级数的运算不同。因此，此功能的结果可能是&amp;ldquo;不直观的&amp;rdquo;，尽管是正确的。请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="c6b49ce2210116245bad6e5bb6d187bba65b38de" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Laguerre series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">通常，对Laguerre序列求微的结果与幂级数的运算不同。因此，此功能的结果可能是&amp;ldquo;不直观的&amp;rdquo;，尽管是正确的。请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="68d490300c846fea9862fc337043383e53cf549a" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Legendre series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">通常，区分Legendre系列的结果与幂级数的运算不同。因此，此功能的结果可能是&amp;ldquo;不直观的&amp;rdquo;，尽管是正确的。请参阅下面的示例部分。</target>
        </trans-unit>
        <trans-unit id="ebd1b8db4b2a00ae669c478fea3d4050ecbe0184" translate="yes" xml:space="preserve">
          <source>In general, the shape of the resultant array will be the concatenation of the shape of the index array (or the shape that all the index arrays were broadcast to) with the shape of any unused dimensions (those not indexed) in the array being indexed.</source>
          <target state="translated">一般来说,结果数组的形状将是索引数组的形状(或所有索引数组被广播到的形状)与被索引数组中任何未使用的维度(那些未被索引的维度)的形状的连接。</target>
        </trans-unit>
        <trans-unit id="a88de0d014385ccfe1e16b471b5821f10438fddf" translate="yes" xml:space="preserve">
          <source>In general, we follow the &lt;a href=&quot;https://developers.google.com/style&quot;&gt;Google developer documentation style guide&lt;/a&gt;.</source>
          <target state="translated">通常，我们遵循&lt;a href=&quot;https://developers.google.com/style&quot;&gt;Google开发者文档样式指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f5de4ef25adb6cfc3610a2fc23a9d5023b6dda95" translate="yes" xml:space="preserve">
          <source>In general, when the boolean array has fewer dimensions than the array being indexed, this is equivalent to y[b, &amp;hellip;], which means y is indexed by b followed by as many : as are needed to fill out the rank of y. Thus the shape of the result is one dimension containing the number of True elements of the boolean array, followed by the remaining dimensions of the array being indexed.</source>
          <target state="translated">通常，当布尔数组的维数少于要建立索引的数组的维数时，这等效于y [b，&amp;hellip;]，这意味着y由b进行索引，后跟任意多个：用来填充y的等级。因此，结果的形状是一维，其中包含布尔数组的True元素的数量，其后是要索引的数组的其余维。</target>
        </trans-unit>
        <trans-unit id="a094c205647147c910d02f3a8f4ccd59ee07b5bd" translate="yes" xml:space="preserve">
          <source>In general, you should target these typemap signatures specifically where you want them, and then clear them after you are done.</source>
          <target state="translated">一般来说,你应该专门针对这些类型地图签名的位置,然后在你完成后清除它们。</target>
        </trans-unit>
        <trans-unit id="dd3e08bc1a57887f18c581f1dbde91b2bd716911" translate="yes" xml:space="preserve">
          <source>In higher dimensions, FFTs are used, e.g., for image analysis and filtering. The computational efficiency of the FFT means that it can also be a faster way to compute large convolutions, using the property that a convolution in the time domain is equivalent to a point-by-point multiplication in the frequency domain.</source>
          <target state="translated">在更高的维度上,FFT被用于,例如,图像分析和滤波。FFT的计算效率意味着它也可以是一种更快的计算大卷积的方法,利用时域的卷积相当于频域的逐点乘法的特性。</target>
        </trans-unit>
        <trans-unit id="712c1e0b0bab41b8c1ae0fb7e5f87af642c68f33" translate="yes" xml:space="preserve">
          <source>In higher dimensions, the picture changes. NumPy prints higher-dimensional vectors as replications of row-by-column building blocks, as in this three-dimensional vector:</source>
          <target state="translated">在更高的维度上,画面会发生变化。NumPy打印的高维向量是逐行逐列的积木复制,就像这个三维向量一样。</target>
        </trans-unit>
        <trans-unit id="b07ddb1ceb7095c96bdb1f519b0d36703eda5462" translate="yes" xml:space="preserve">
          <source>In interactions between &lt;code&gt;ArrayLike&lt;/code&gt; objects and numbers or numpy arrays, the result is always another &lt;code&gt;ArrayLike&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;ArrayLike&lt;/code&gt; 对象与数字或numpy数组之间的交互中，结果始终是另一个 &lt;code&gt;ArrayLike&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="859968bca8846c38eabf846201d96ee61f1cb6f0" translate="yes" xml:space="preserve">
          <source>In linear space, the sequence starts at &lt;code&gt;base ** start&lt;/code&gt; (&lt;code&gt;base&lt;/code&gt; to the power of &lt;code&gt;start&lt;/code&gt;) and ends with &lt;code&gt;base ** stop&lt;/code&gt; (see &lt;code&gt;endpoint&lt;/code&gt; below).</source>
          <target state="translated">线性空间，在序列开始 &lt;code&gt;base ** start&lt;/code&gt; （ &lt;code&gt;base&lt;/code&gt; 到的功率 &lt;code&gt;start&lt;/code&gt; ），并用端部 &lt;code&gt;base ** stop&lt;/code&gt; （参见 &lt;code&gt;endpoint&lt;/code&gt; 下文）。</target>
        </trans-unit>
        <trans-unit id="e8987c188d2dc12518e96e9c96bc6fb94bc0c364" translate="yes" xml:space="preserve">
          <source>In many circumstances, datasets can be incomplete or tainted by the presence of invalid data. For example, a sensor may have failed to record a data, or recorded an invalid value. The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module provides a convenient way to address this issue, by introducing masked arrays.</source>
          <target state="translated">在许多情况下，数据集可能不完整或被无效数据污染。例如，传感器可能无法记录数据或记录了无效值。所述&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt;模块提供一种方便的方式通过引入掩蔽阵列来解决这个问题，。</target>
        </trans-unit>
        <trans-unit id="af19adb5953933b119cf6e38053a7bd63ddf0076" translate="yes" xml:space="preserve">
          <source>In memory overlap checks, assume that operands with &lt;code&gt;NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE&lt;/code&gt; enabled are accessed only in the iterator order.</source>
          <target state="translated">在内存重叠检查中，假定仅以迭代器顺序访问启用了 &lt;code&gt;NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE&lt;/code&gt; 的操作数。</target>
        </trans-unit>
        <trans-unit id="bd53b438575f194778c1656e57b318d6b487ca6a" translate="yes" xml:space="preserve">
          <source>In more detail</source>
          <target state="translated">更详细的情况</target>
        </trans-unit>
        <trans-unit id="f9e0501d6a0c7c31ee0e8c5ea3ca4747d4c70398" translate="yes" xml:space="preserve">
          <source>In most cases &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; should be used instead of this function, as that will also return true for 0d arrays. This is how numpy overloads functions in the style of the &lt;code&gt;dx&lt;/code&gt; arguments to &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt;&lt;code&gt;gradient&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;bins&lt;/code&gt; argument to &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;. Some key differences:</source>
          <target state="translated">在大多数情况下，应使用 &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; 代替此函数，因为对于0d数组，该函数也将返回true。这就是numpy重载函数的方式，即 &lt;code&gt;dx&lt;/code&gt; 参数传递给&lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt; &lt;code&gt;gradient&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;bins&lt;/code&gt; 参数传递给&lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt;。一些主要区别：</target>
        </trans-unit>
        <trans-unit id="a5c743fe265d56156ca24d5e10903518aede0334" translate="yes" xml:space="preserve">
          <source>In most use cases the best way to install NumPy on your system is by using a pre-built package for your operating system. Please see &lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https://scipy.org/install.html&lt;/a&gt; for links to available options.</source>
          <target state="translated">在大多数情况下，在系统上安装NumPy的最佳方法是使用针对操作系统的预构建软件包。请参阅&lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https://scipy.org/install.html&lt;/a&gt;，以获取指向可用选项的链接。</target>
        </trans-unit>
        <trans-unit id="763b6e76c1532989efe227d788422ad02bd06f94" translate="yes" xml:space="preserve">
          <source>In normal buffering, the size of each inner loop is equal to the buffer size, or possibly larger if &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; is specified. If &lt;a href=&quot;#c.NPY_ITER_REDUCE_OK&quot;&gt;&lt;code&gt;NPY_ITER_REDUCE_OK&lt;/code&gt;&lt;/a&gt; is enabled and a reduction occurs, the inner loops may become smaller depending on the structure of the reduction.</source>
          <target state="translated">在普通缓冲中，每个内部循环的大小等于缓冲区大小，如果指定了&lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; ,&lt;/a&gt;则可能更大。如果启用&lt;a href=&quot;#c.NPY_ITER_REDUCE_OK&quot;&gt; &lt;code&gt;NPY_ITER_REDUCE_OK&lt;/code&gt; &lt;/a&gt;并发生缩减，则根据缩减的结构，内部循环可能会变小。</target>
        </trans-unit>
        <trans-unit id="2c60bcd4aa111fe243ec4d9e38a39cdb9410fc32" translate="yes" xml:space="preserve">
          <source>In numpy versions &amp;gt;= 1.7.0 the &lt;code&gt;basis&lt;/code&gt; and &lt;code&gt;cast&lt;/code&gt; class methods are also available. The cast method works like the convert method while the basis method returns the basis polynomial of given degree:</source>
          <target state="translated">在numpy的版本&amp;gt; = 1.7.0的 &lt;code&gt;basis&lt;/code&gt; 和 &lt;code&gt;cast&lt;/code&gt; 类的方法也是可用的。强制转换方法的工作方式类似于转换方法，而基本方法则返回给定度数的基本多项式：</target>
        </trans-unit>
        <trans-unit id="9a36a11020261b9ce301df38d29f32b272d351ef" translate="yes" xml:space="preserve">
          <source>In order to add a Python package to SciPy, its build script (&lt;code&gt;setup.py&lt;/code&gt;) must meet certain requirements. The most important requirement is that the package define a &lt;code&gt;configuration(parent_package='',top_path=None)&lt;/code&gt; function which returns a dictionary suitable for passing to &lt;code&gt;numpy.distutils.core.setup(..)&lt;/code&gt;. To simplify the construction of this dictionary, &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; provides the &lt;code&gt;Configuration&lt;/code&gt; class, described below.</source>
          <target state="translated">为了将Python软件包添加到SciPy，其构建脚本（ &lt;code&gt;setup.py&lt;/code&gt; ）必须满足某些要求。最重要的要求是，程序包定义一个 &lt;code&gt;configuration(parent_package='',top_path=None)&lt;/code&gt; 函数，该函数返回适合传递给 &lt;code&gt;numpy.distutils.core.setup(..)&lt;/code&gt; 的字典。为了简化此字典的构造， &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; 提供了 &lt;code&gt;Configuration&lt;/code&gt; 类，如下所述。</target>
        </trans-unit>
        <trans-unit id="9195216b823d914ae553da6509b9641a3f8c45ff" translate="yes" xml:space="preserve">
          <source>In order to extract information from a given matrix, we can use the SVD to obtain 3 arrays which can be multiplied to obtain the original matrix. From the theory of linear algebra, given a matrix</source>
          <target state="translated">为了从一个给定的矩阵中提取信息,我们可以利用SVD得到3个数组,将其相乘得到原始矩阵。从线性代数理论来看,给定一个矩阵</target>
        </trans-unit>
        <trans-unit id="60fc69a196f8bf024afb0ed60ca3a78c46194201" translate="yes" xml:space="preserve">
          <source>In order to improve the interface, directives should be provided. This is accomplished by constructing an interface definition file. It is usually best to start from the interface file that f2py can produce (where it gets its default behavior from). To get f2py to generate the interface file use the -h option:</source>
          <target state="translated">为了改进接口,应该提供指令。这可以通过构造一个接口定义文件来实现。通常最好从f2py能够生成的接口文件开始(它的默认行为就是从那里获得的)。要让f2py生成接口文件,使用-h选项。</target>
        </trans-unit>
        <trans-unit id="d5eaeb15f58484d8774fc878d68cb55c966f0844" translate="yes" xml:space="preserve">
          <source>In order to make use of the C-API from another extension module, the &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt; function must be called. If the extension module is self-contained in a single .c file, then that is all that needs to be done. If, however, the extension module involves multiple files where the C-API is needed then some additional steps must be taken.</source>
          <target state="translated">为了使用另一个扩展模块中的C-API，必须调用&lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; &lt;/a&gt;函数。如果扩展模块是独立包含在单个.c文件中的，那么这就是所有要做的事情。但是，如果扩展模块涉及需要C-API的多个文件，则必须采取一些其他步骤。</target>
        </trans-unit>
        <trans-unit id="c34adc34291107e6d105c5cd2a716fc5c0f9914c" translate="yes" xml:space="preserve">
          <source>In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained today, a monthly payment of $1,854.02 would be required. Note that this example illustrates usage of &lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt;&lt;code&gt;fv&lt;/code&gt;&lt;/a&gt; having a default value of 0.</source>
          <target state="translated">为了还清（即，终值为0）今天获得的$ 200,000，每月需要支付$ 1,854.02。请注意，此示例说明了默认值为0 的&lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt; &lt;code&gt;fv&lt;/code&gt; 的&lt;/a&gt;用法。</target>
        </trans-unit>
        <trans-unit id="c095a095337ad13b3d70a4b6ebd36dbc52f1334a" translate="yes" xml:space="preserve">
          <source>In order to prevent clobbering object pointers in fields of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; type, numpy currently does not allow views of structured arrays containing objects.</source>
          <target state="translated">为了防止在领域重挫对象指针&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt;类型，numpy的目前不允许视图包含对象结构化阵列。</target>
        </trans-unit>
        <trans-unit id="5f37a6feac047af18be703227c7a9f994a3a9fcc" translate="yes" xml:space="preserve">
          <source>In order to prevent clobbering object pointers in fields of &lt;code&gt;numpy.object&lt;/code&gt; type, numpy currently does not allow views of structured arrays containing objects.</source>
          <target state="translated">为了防止破坏 &lt;code&gt;numpy.object&lt;/code&gt; 类型的字段中的对象指针，numpy当前不允许包含对象的结构化数组的视图。</target>
        </trans-unit>
        <trans-unit id="1b7199a5c1d305f9cc30b6b7f154cecb0f39e6d3" translate="yes" xml:space="preserve">
          <source>In order to remove elements from an array, it&amp;rsquo;s simple to use indexing to select the elements that you want to keep.</source>
          <target state="translated">为了从数组中删除元素，使用索引选择要保留的元素很简单。</target>
        </trans-unit>
        <trans-unit id="b465797b5de029b2baabd94edf6595fe5ee0db1d" translate="yes" xml:space="preserve">
          <source>In order to start using NumPy and all of the functions available in NumPy, you&amp;rsquo;ll need to import it. This can be easily done with this import statement:</source>
          <target state="translated">为了开始使用NumPy和NumPy中的所有可用功能，您需要将其导入。可以使用以下import语句轻松完成此操作：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
