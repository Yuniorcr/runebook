<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="307209890a37b51bcd317c1d8679c25cf8cf32dc" translate="yes" xml:space="preserve">
          <source>This function creates a new neighborhood iterator from an existing iterator. The neighborhood will be computed relatively to the position currently pointed by &lt;em&gt;iter&lt;/em&gt;, the bounds define the shape of the neighborhood iterator, and the mode argument the boundaries handling mode.</source>
          <target state="translated">此函数从现有迭代器创建一个新的邻域迭代器。邻域将相对于&lt;em&gt;iter&lt;/em&gt;当前指向的位置进行计算，边界定义邻域迭代器的形状，而mode参数则是边界处理模式。</target>
        </trans-unit>
        <trans-unit id="33522609896e19e2c62ce4cc185c0f8e169d65db" translate="yes" xml:space="preserve">
          <source>This function does &lt;em&gt;not&lt;/em&gt; initialize the returned array; to do that use &lt;a href=&quot;numpy.zeros_like#numpy.zeros_like&quot;&gt;&lt;code&gt;zeros_like&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.ones_like#numpy.ones_like&quot;&gt;&lt;code&gt;ones_like&lt;/code&gt;&lt;/a&gt; instead. It may be marginally faster than the functions that do set the array values.</source>
          <target state="translated">此功能&lt;em&gt;未&lt;/em&gt;初始化返回的数组; 为此，请使用&lt;a href=&quot;numpy.zeros_like#numpy.zeros_like&quot;&gt; &lt;code&gt;zeros_like&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;numpy.ones_like#numpy.ones_like&quot;&gt; &lt;code&gt;ones_like&lt;/code&gt; &lt;/a&gt;。它可能比设置数组值的函数快一些。</target>
        </trans-unit>
        <trans-unit id="0decc5010e2e82ceb19b7a45f9d7da5f4f237524" translate="yes" xml:space="preserve">
          <source>This function does &lt;em&gt;not&lt;/em&gt; initialize the returned array; to do that use &lt;code&gt;zeros_like&lt;/code&gt; or &lt;code&gt;ones_like&lt;/code&gt; instead. It may be marginally faster than the functions that do set the array values.</source>
          <target state="translated">此功能&lt;em&gt;未&lt;/em&gt;初始化返回的数组; 为此，请使用 &lt;code&gt;zeros_like&lt;/code&gt; 或 &lt;code&gt;ones_like&lt;/code&gt; 。它可能比设置数组值的函数快一些。</target>
        </trans-unit>
        <trans-unit id="960581e2e13399cd79a7bf3c883aeb7b8d2e979d" translate="yes" xml:space="preserve">
          <source>This function does not check the contents of the input, only that the type is MaskType. In particular, this function returns False if the mask has a flexible dtype.</source>
          <target state="translated">这个函数不检查输入的内容,只检查类型是否为MaskType。特别是,如果掩码具有灵活的dtype,该函数返回False。</target>
        </trans-unit>
        <trans-unit id="0a232150acd8a12e027d94aeed56f5ff4aae9f46" translate="yes" xml:space="preserve">
          <source>This function does not enforce that the blocks lie on a fixed grid. &lt;code&gt;np.block([[a, b], [c, d]])&lt;/code&gt; is not restricted to arrays of the form:</source>
          <target state="translated">此功能不强制块位于固定的网格上。 &lt;code&gt;np.block([[a, b], [c, d]])&lt;/code&gt; 不限于以下形式的数组：</target>
        </trans-unit>
        <trans-unit id="6dc40074e04bdcad2b344dd285961cdc7ff85df9" translate="yes" xml:space="preserve">
          <source>This function does not losslessly round-trip in either direction.</source>
          <target state="translated">这个功能在两个方向上都不会无损往返。</target>
        </trans-unit>
        <trans-unit id="b71c712d42350c6a8a0c257c490e077558876dad" translate="yes" xml:space="preserve">
          <source>This function encapsulates the broadcasting rules. The &lt;em&gt;mit&lt;/em&gt; container should already contain iterators for all the arrays that need to be broadcast. On return, these iterators will be adjusted so that iteration over each simultaneously will accomplish the broadcasting. A negative number is returned if an error occurs.</source>
          <target state="translated">该功能封装了广播规则。在&lt;em&gt;麻省理工学院的&lt;/em&gt;容器应该已经包含了所有的阵列需要进行广播迭代器。返回时，将对这些迭代器进行调整，以便每个迭代器同时进行迭代将完成广播。如果发生错误，则返回负数。</target>
        </trans-unit>
        <trans-unit id="b02f77dc9fbab1956d3050387654fd71594ea916" translate="yes" xml:space="preserve">
          <source>This function handles NaN comparisons as if NaN was a &amp;ldquo;normal&amp;rdquo; number. That is, no assertion is raised if both objects have NaNs in the same positions. This is in contrast to the IEEE standard on NaNs, which says that NaN compared to anything must return False.</source>
          <target state="translated">此函数处理NaN比较，就好像NaN是&amp;ldquo;正常&amp;rdquo;数字一样。也就是说，如果两个对象在相同位置都具有NaN，则不会引发任何断言。这与NaN的IEEE标准相反，后者说NaN与任何东西相比都必须返回False。</target>
        </trans-unit>
        <trans-unit id="d5f910d97d6aeb7075f641616a02d523dd4438a4" translate="yes" xml:space="preserve">
          <source>This function has been deprecated. Use randint instead.</source>
          <target state="translated">此函数已被废弃。使用randint代替。</target>
        </trans-unit>
        <trans-unit id="77fe5df00c0c7c8132af4661573c5a4cca000d13" translate="yes" xml:space="preserve">
          <source>This function has to be used with extreme care, see notes.</source>
          <target state="translated">此功能的使用要格外小心,请看说明。</target>
        </trans-unit>
        <trans-unit id="965a01bc9232ab2e9c3c470747ee3c2312761abb" translate="yes" xml:space="preserve">
          <source>This function is a compatibility alias for tobytes.</source>
          <target state="translated">这个函数是toby字节的兼容别名。</target>
        </trans-unit>
        <trans-unit id="a3014854fc3aff1db547e25e4accc358bdc45e8a" translate="yes" xml:space="preserve">
          <source>This function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.</source>
          <target state="translated">这个函数是tobytes的兼容别名。尽管它的名字叫 &quot;字节&quot;,但它返回的是字节而不是字符串。</target>
        </trans-unit>
        <trans-unit id="5bced6280c853e5763696660107e62b1e9050b26" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;mask_rowcols&lt;/code&gt; with &lt;code&gt;axis&lt;/code&gt; equal to 0.</source>
          <target state="translated">此功能的快捷方式 &lt;code&gt;mask_rowcols&lt;/code&gt; 与 &lt;code&gt;axis&lt;/code&gt; 等于0。</target>
        </trans-unit>
        <trans-unit id="892aad8c63a29b7082fcd31d81f9eafb9d342e8e" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;mask_rowcols&lt;/code&gt; with &lt;code&gt;axis&lt;/code&gt; equal to 1.</source>
          <target state="translated">此功能的快捷方式 &lt;code&gt;mask_rowcols&lt;/code&gt; 与 &lt;code&gt;axis&lt;/code&gt; 等于1。</target>
        </trans-unit>
        <trans-unit id="ebac1dd8653756fd79c832147de01fce0d7f87ae" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x != value).</source>
          <target state="translated">该函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =（x！=值）。</target>
        </trans-unit>
        <trans-unit id="ab411b054ab6959d52991c7253cba72df24e6757" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;gt; value).</source>
          <target state="translated">此函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =（x&amp;gt;值）。</target>
        </trans-unit>
        <trans-unit id="bf30dbf11727720fe8d30e29bf375cde077485f8" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;gt;= value).</source>
          <target state="translated">此函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =（x&amp;gt; =值）。</target>
        </trans-unit>
        <trans-unit id="af1053b8f0ec97d05015f270566c5b82959272a7" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;lt; value).</source>
          <target state="translated">该函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =（x &amp;lt;值）。</target>
        </trans-unit>
        <trans-unit id="f9189002c6a19182c690d1c6efc00b46a33f7232" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;lt;= value).</source>
          <target state="translated">该函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =（x &amp;lt;=值）。</target>
        </trans-unit>
        <trans-unit id="f46637928627180e5c802e1527edd637c13a58b6" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x == value). For floating point arrays, consider using &lt;code&gt;masked_values(x, value)&lt;/code&gt;.</source>
          <target state="translated">此函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =（x ==值）。对于浮点数组，请考虑使用 &lt;code&gt;masked_values(x, value)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4434dee55a64bbfebaafbec40077ada7cc2e4b4" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = ~(np.isfinite(a)). Any pre-existing mask is conserved. Only applies to arrays with a dtype where NaNs or infs make sense (i.e. floating point types), but accepts any array_like object.</source>
          <target state="translated">此函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =〜（np.isfinite（a））。保留任何先前存在的掩码。仅适用于具有NaN或infs有意义的dtype的数组（即浮点类型），但可以接受任何array_like对象。</target>
        </trans-unit>
        <trans-unit id="f28b126f5c6b2ce96d11bc92753f383ad4cd6485" translate="yes" xml:space="preserve">
          <source>This function is able to return one of eight different matrix norms, or one of an infinite number of vector norms (described below), depending on the value of the &lt;code&gt;ord&lt;/code&gt; parameter.</source>
          <target state="translated">根据 &lt;code&gt;ord&lt;/code&gt; 参数的值，此函数能够返回八个不同的矩阵范数之一，或无穷多个矢量范数之一（如下所述）。</target>
        </trans-unit>
        <trans-unit id="c1758140bc8fa9fd28fc8bc131c3f6321c42d5db" translate="yes" xml:space="preserve">
          <source>This function is capable of returning the condition number using one of seven different norms, depending on the value of &lt;code&gt;p&lt;/code&gt; (see Parameters below).</source>
          <target state="translated">此函数能够使用七个不同规范之一返回条件编号，具体取决于 &lt;code&gt;p&lt;/code&gt; 的值（请参见下面的参数）。</target>
        </trans-unit>
        <trans-unit id="7f257a627b846a11d8d82d4b0986234672c8d024" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;a href=&quot;#numpy.ma.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; except that masked values are treated as equal (default) or unequal, depending on the &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt;&lt;code&gt;masked_equal&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">此函数等效于&lt;a href=&quot;#numpy.ma.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; ,&lt;/a&gt;不同之处在于，根据&lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt; &lt;code&gt;masked_equal&lt;/code&gt; &lt;/a&gt;参数，将掩码值视为相等（默认值）或不相等。</target>
        </trans-unit>
        <trans-unit id="a3debc8695bd72584953abb12e719fb90548f7dd" translate="yes" xml:space="preserve">
          <source>This function is equivalent to calling the &amp;ldquo;compressed&amp;rdquo; method of a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt;&lt;code&gt;MaskedArray.compressed&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">此函数等效于调用&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;的&amp;ldquo; compressed&amp;rdquo;方法，有关详细信息，请参见&lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt; &lt;code&gt;MaskedArray.compressed&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="614f9af44de8bf025b95f7feb6cfbfad93376ecb" translate="yes" xml:space="preserve">
          <source>This function is equivalent to tuple axis arguments to reorderable ufuncs with keepdims=True. Tuple axis arguments to ufuncs have been available since version 1.7.0.</source>
          <target state="translated">这个函数相当于keepdims=True的可重排序ufuncs的元组轴参数。从1.7.0版本开始,ufuncs的元组轴参数就可以使用了。</target>
        </trans-unit>
        <trans-unit id="3c5d87f95304bba4f22f4f3bc79a0366620caeda" translate="yes" xml:space="preserve">
          <source>This function is exactly equivalent to &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;numpy.transpose&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数与&lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;numpy.transpose&lt;/code&gt; &lt;/a&gt;完全等效。</target>
        </trans-unit>
        <trans-unit id="0a042d76cb2129f19b61e5085381910d8b99bdbc" translate="yes" xml:space="preserve">
          <source>This function is intended to be used in EXTERNAL_LOOP mode only, and will produce some wrong answers when that mode is not enabled.</source>
          <target state="translated">该函数仅用于EXTERNAL_LOOP模式,当该模式未启用时,会产生一些错误的答案。</target>
        </trans-unit>
        <trans-unit id="d3aeb8a347cc701a9fec8946ae6c740c1103bc20" translate="yes" xml:space="preserve">
          <source>This function is not defined for complex-valued arguments; for the so-called argument of complex values, use &lt;a href=&quot;numpy.angle#numpy.angle&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">未为复数值参数定义此函数；对于所谓的复数参数，请使用&lt;a href=&quot;numpy.angle#numpy.angle&quot;&gt; &lt;code&gt;angle&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42c780622358a45155401477993b5d9d0b335549" translate="yes" xml:space="preserve">
          <source>This function is not designed to work with integers.</source>
          <target state="translated">这个函数不是设计用来处理整数的。</target>
        </trans-unit>
        <trans-unit id="ea62cc16ec217ef39d7f7c8e5969148da37fd3a3" translate="yes" xml:space="preserve">
          <source>This function is not implemented yet.</source>
          <target state="translated">这个功能还没有实现。</target>
        </trans-unit>
        <trans-unit id="b2f9356116ad7b6b9ba74a0d07b768457fca53e0" translate="yes" xml:space="preserve">
          <source>This function is obsolete and, because of changes due to relaxed stride checking, its return value for the same array may differ for versions of NumPy &amp;gt;= 1.10.0 and previous versions. If you only want to check if an array is Fortran contiguous use &lt;code&gt;a.flags.f_contiguous&lt;/code&gt; instead.</source>
          <target state="translated">此函数已过时，并且由于宽松的步幅检查导致的更改，对于NumPy&amp;gt; = 1.10.0的版本和以前的版本，同一数组的返回值可能会有所不同。如果只想检查数组是否为Fortran连续数组，请改用 &lt;code&gt;a.flags.f_contiguous&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="258358cbdd467c9c344ce8e3f9c85d0cd7f428e4" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt;&lt;code&gt;masked_values&lt;/code&gt;&lt;/a&gt;, but only suitable for object arrays: for floating point, use &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt;&lt;code&gt;masked_values&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此函数类似于&lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt; &lt;code&gt;masked_values&lt;/code&gt; &lt;/a&gt;，但仅适用于对象数组：对于浮点，请改用&lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt; &lt;code&gt;masked_values&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42e4240c2bc84555a7f741757d674e8c82e565ad" translate="yes" xml:space="preserve">
          <source>This function is superceded by &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数由&lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; &lt;/a&gt;和/或&lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; &lt;/a&gt;取代。</target>
        </trans-unit>
        <trans-unit id="f3e20de601f3ca24a5ff2472df08d779de8dd632" translate="yes" xml:space="preserve">
          <source>This function is superceded by &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数由&lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; &lt;/a&gt;取代。</target>
        </trans-unit>
        <trans-unit id="5b1ff7898f391050d07732317e1b4b4bc976ee58" translate="yes" xml:space="preserve">
          <source>This function is symmetric, but rarely associative.</source>
          <target state="translated">这个函数是对称的,但很少有关联的。</target>
        </trans-unit>
        <trans-unit id="fb34e601302a103a0946045a1719e9ad4309bf62" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;numpy.diag&lt;/code&gt;&lt;/a&gt; that takes masked values into account, see &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;numpy.diag&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">此函数等效于&lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;numpy.diag&lt;/code&gt; &lt;/a&gt;，它考虑了掩码值，有关详细信息，请参见&lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;numpy.diag&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="762735a831cc238bcd6be4852c06ac0013225a54" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.dot#numpy.dot&quot;&gt;&lt;code&gt;numpy.dot&lt;/code&gt;&lt;/a&gt; that takes masked values into account. Note that &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; are in different position than in the method version. In order to maintain compatibility with the corresponding method, it is recommended that the optional arguments be treated as keyword only. At some point that may be mandatory.</source>
          <target state="translated">此函数等效于&lt;a href=&quot;numpy.dot#numpy.dot&quot;&gt; &lt;code&gt;numpy.dot&lt;/code&gt; &lt;/a&gt;，它考虑了掩码值。请注意， &lt;code&gt;strict&lt;/code&gt; 和 &lt;code&gt;out&lt;/code&gt; 与方法版本中的位置不同。为了保持与相应方法的兼容性，建议将可选参数仅视为关键字。在某些时候这可能是强制性的。</target>
        </trans-unit>
        <trans-unit id="b3449fce446ccae1d5ae6c6d55107b82701f20fd" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt;&lt;code&gt;numpy.ediff1d&lt;/code&gt;&lt;/a&gt; that takes masked values into account, see &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt;&lt;code&gt;numpy.ediff1d&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">此函数等效于&lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt; &lt;code&gt;numpy.ediff1d&lt;/code&gt; &lt;/a&gt;，其中将掩码值考虑在内，有关详细信息，请参见&lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt; &lt;code&gt;numpy.ediff1d&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48492051f92b9e0c98dfd72175da1464af62c22d" translate="yes" xml:space="preserve">
          <source>This function is useful for calculating a fill value suitable for taking the maximum of an array with a given dtype.</source>
          <target state="translated">这个函数对于计算一个适合于取一个给定dtype的数组的最大值的填充值很有用。</target>
        </trans-unit>
        <trans-unit id="514144ea48299b81c7b15dfcf631d31668bd3186" translate="yes" xml:space="preserve">
          <source>This function is useful for determining a common type that two or more arrays can be converted to. It only works for non-flexible array types as no itemsize information is passed. The &lt;em&gt;mintype&lt;/em&gt; argument represents the minimum type acceptable, and &lt;em&gt;op&lt;/em&gt; represents the object that will be converted to an array. The return value is the enumerated typenumber that represents the data-type that &lt;em&gt;op&lt;/em&gt; should have.</source>
          <target state="translated">此功能对于确定可以将两个或多个数组转换为的通用类型很有用。它仅适用于非灵活数组类型，因为没有传递项目大小信息。所述&lt;em&gt;mintype&lt;/em&gt;参数表示的最低可接受的类型，和&lt;em&gt;运算&lt;/em&gt;表示将被转换为一个数组的对象。返回值是枚举的类型编号，表示&lt;em&gt;op&lt;/em&gt;应该具有的数据类型。</target>
        </trans-unit>
        <trans-unit id="66ea2fa9dfd3553ca39f3787970de46499229028" translate="yes" xml:space="preserve">
          <source>This function is useful to be sure that an array with the correct flags is returned for passing to compiled code (perhaps through ctypes).</source>
          <target state="translated">这个函数很有用,可以确保返回一个带有正确标志的数组,以便传递给编译后的代码(也许通过ctypes)。</target>
        </trans-unit>
        <trans-unit id="8e9b1bcfe6f895f9426e7973caf7f080e53d5b02" translate="yes" xml:space="preserve">
          <source>This function is very similar to &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; above, but has an extra &lt;em&gt;identity_value&lt;/em&gt; argument, to define an arbitrary identity for the ufunc when &lt;code&gt;identity&lt;/code&gt; is passed as &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;.</source>
          <target state="translated">此函数与上面的 &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; 非常相似，但是具有一个额外的&lt;em&gt;identity_value&lt;/em&gt;参数，用于在将 &lt;code&gt;identity&lt;/code&gt; 作为 &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; 传递时定义ufunc的任意身份。</target>
        </trans-unit>
        <trans-unit id="e6ae878f05630a69160b11c652744c88c73b83f7" translate="yes" xml:space="preserve">
          <source>This function is very similar to PyUFunc_FromFuncAndData above, but has an extra &lt;em&gt;signature&lt;/em&gt; argument, to define a &lt;a href=&quot;c-api.generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;generalized universal functions&lt;/a&gt;. Similarly to how ufuncs are built around an element-by-element operation, gufuncs are around subarray-by-subarray operations, the &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; defining the subarrays to operate on.</source>
          <target state="translated">该函数与上面的PyUFunc_FromFuncAndData非常相似，但是具有一个额外的&lt;em&gt;签名&lt;/em&gt;参数，以定义&lt;a href=&quot;c-api.generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;通用的通用函数&lt;/a&gt;。与如何在逐个元素的操作周围构建ufunc相似，gufuncs围绕每个子数组操作（&lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;签名&lt;/a&gt;定义要对其进行操作的子数组）。</target>
        </trans-unit>
        <trans-unit id="0dc77b4e140ac75bc9ac3e89d41f38fc73185d22" translate="yes" xml:space="preserve">
          <source>This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.stack#numpy.stack&quot;&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.block#numpy.block&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; provide more general stacking and concatenation operations.</source>
          <target state="translated">此功能对于最多3维的数组最有意义。例如，对于具有高度（第一轴），宽度（第二轴）和r / g / b通道（第三轴）的像素数据。函数&lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.stack#numpy.stack&quot;&gt; &lt;code&gt;stack&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.block#numpy.block&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt;提供更多常规的堆叠和串联操作。</target>
        </trans-unit>
        <trans-unit id="f7b019770de00d4d47b09eabe135d2ae721a995a" translate="yes" xml:space="preserve">
          <source>This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions &lt;a href=&quot;numpy.ma.concatenate#numpy.ma.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.ma.stack#numpy.ma.stack&quot;&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;block&lt;/code&gt; provide more general stacking and concatenation operations.</source>
          <target state="translated">此功能对于最多3维的数组最有意义。例如，对于具有高度（第一轴），宽度（第二轴）和r / g / b通道（第三轴）的像素数据。函数&lt;a href=&quot;numpy.ma.concatenate#numpy.ma.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.ma.stack#numpy.ma.stack&quot;&gt; &lt;code&gt;stack&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;block&lt;/code&gt; 提供更多常规的堆叠和串联操作。</target>
        </trans-unit>
        <trans-unit id="d585b637d27940cc37d90ebf4940a9aa2e521b5d" translate="yes" xml:space="preserve">
          <source>This function may be safely called without holding the Python GIL.</source>
          <target state="translated">这个函数可以在不持有Python GIL的情况下安全调用。</target>
        </trans-unit>
        <trans-unit id="cd200e9dfe3f17be99d159e426b6fa9331db61ec" translate="yes" xml:space="preserve">
          <source>This function may only be called if the iterator is tracking a multi-index and if &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt;&lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt;&lt;/a&gt; was used to prevent an axis from being iterated in reverse order.</source>
          <target state="translated">仅当迭代器正在跟踪多索引并且使用&lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt; &lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt; &lt;/a&gt;来防止以相反的顺序迭代轴时，才可以调用此函数。</target>
        </trans-unit>
        <trans-unit id="6ca18036fbf762cae2043baf8ac3fa8494d28495" translate="yes" xml:space="preserve">
          <source>This function must be called in the initialization section of a module that will make use of the C-API. It imports the module where the function-pointer table is stored and points the correct variable to it.</source>
          <target state="translated">这个函数必须在一个将使用C-API的模块的初始化部分被调用。它导入存储函数指针表的模块,并将正确的变量指向它。</target>
        </trans-unit>
        <trans-unit id="cf5ee49acb54388d21032f90f2de16dca9ddb6c3" translate="yes" xml:space="preserve">
          <source>This function must take two arguments, &lt;code&gt;func(a, axis)&lt;/code&gt;.</source>
          <target state="translated">此函数必须 &lt;code&gt;func(a, axis)&lt;/code&gt; 两个参数func（a，axis）。</target>
        </trans-unit>
        <trans-unit id="dba1259c24481a4a54d81a8fdecff9fadce8f02f" translate="yes" xml:space="preserve">
          <source>This function only shuffles the array along the first axis of a multi-dimensional array. The order of sub-arrays is changed but their contents remains the same.</source>
          <target state="translated">这个函数只是沿着多维数组的第一轴对数组进行洗牌。子数组的顺序被改变,但其内容保持不变。</target>
        </trans-unit>
        <trans-unit id="68ca7042b267a7f2923f8a89cc886956d3a640a1" translate="yes" xml:space="preserve">
          <source>This function provides greater precision than &lt;code&gt;exp(x) - 1&lt;/code&gt; for small values of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">对于较小的 &lt;code&gt;x&lt;/code&gt; ,此函数提供的精度比 &lt;code&gt;exp(x) - 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40a3f0ad0a26c2dcd1667ccf5fd0beae55099939" translate="yes" xml:space="preserve">
          <source>This function reads from the system entropy pool and so samples are not reproducible. In particular, it does &lt;em&gt;NOT&lt;/em&gt; make use of a BitGenerator, and so &lt;code&gt;seed&lt;/code&gt; and setting &lt;code&gt;state&lt;/code&gt; have no effect.</source>
          <target state="translated">此函数从系统熵池中读取数据，因此样本不可重现。特别是，它&lt;em&gt;不是&lt;/em&gt;利用一个BitGenerator的，所以 &lt;code&gt;seed&lt;/code&gt; 和设置 &lt;code&gt;state&lt;/code&gt; 没有任何效果。</target>
        </trans-unit>
        <trans-unit id="326a3290cbe737031cbcfe2c255c104d77bb6d98" translate="yes" xml:space="preserve">
          <source>This function returns a (C-style) contiguous and behaved function array from any nested sequence or array interface exporting object, &lt;em&gt;op&lt;/em&gt;, of (non-flexible) type given by the enumerated &lt;em&gt;typenum&lt;/em&gt;, of minimum depth &lt;em&gt;min_depth&lt;/em&gt;, and of maximum depth &lt;em&gt;max_depth&lt;/em&gt;. Equivalent to a call to &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; with requirements set to &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; and the type_num member of the type argument set to &lt;em&gt;typenum&lt;/em&gt;.</source>
          <target state="translated">此函数从枚举&lt;em&gt;typenum&lt;/em&gt;给出的（非灵活）类型，最小深度&lt;em&gt;min_depth&lt;/em&gt;和最大深度&lt;em&gt;max_depth的&lt;/em&gt;任何嵌套序列或数组接口导出对象&lt;em&gt;op&lt;/em&gt;返回一个（C风格）连续且行为良好的函数数组。等效于对&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;的调用，其要求设置为&lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; ,&lt;/a&gt;并且类型参数的type_num成员设置为&lt;em&gt;typenum&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd99a05c88fddf54e9c57ac9cd52857632e3d1f8" translate="yes" xml:space="preserve">
          <source>This function returns a boolean ndarray with all entries False, that can be used in common mask manipulations. If a complex dtype is specified, the type of each field is converted to a boolean type.</source>
          <target state="translated">该函数返回一个布尔型ndarray,所有条目均为False,可用于常见的掩码操作。如果指定了复杂的dtype,则每个字段的类型会被转换为布尔类型。</target>
        </trans-unit>
        <trans-unit id="d5e7626c8e43009c9d0e23e7f2d941b6cb967b32" translate="yes" xml:space="preserve">
          <source>This function returns the absolute values (positive magnitude) of the data in &lt;code&gt;x&lt;/code&gt;. Complex values are not handled, use &lt;a href=&quot;numpy.absolute#numpy.absolute&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; to find the absolute values of complex data.</source>
          <target state="translated">此函数返回 &lt;code&gt;x&lt;/code&gt; 中数据的绝对值（正值）。不处理复杂值，请使用&lt;a href=&quot;numpy.absolute#numpy.absolute&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt;查找复杂数据的绝对值。</target>
        </trans-unit>
        <trans-unit id="89fee3e999f1c558b74709781bf21911d5dc8fa4" translate="yes" xml:space="preserve">
          <source>This function returns the value</source>
          <target state="translated">该函数返回值</target>
        </trans-unit>
        <trans-unit id="1cc55e517c256ea42c557b8b54e3efb3b6cafcb6" translate="yes" xml:space="preserve">
          <source>This function returns the values:</source>
          <target state="translated">该函数返回值。</target>
        </trans-unit>
        <trans-unit id="a6d07b33b778389f427bd3ca9fc11f04feb25982" translate="yes" xml:space="preserve">
          <source>This function should accept 1-D arrays. It is applied to 1-D slices of &lt;code&gt;arr&lt;/code&gt; along the specified axis.</source>
          <target state="translated">此函数应接受一维数组。它将沿指定轴应用于 &lt;code&gt;arr&lt;/code&gt; 的一维切片。</target>
        </trans-unit>
        <trans-unit id="5cfabdc0232ab8cc8ac575fbc0d4dec6b2dd7bf7" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;arr&lt;/em&gt;.</source>
          <target state="translated">该函数窃取了对&lt;em&gt;arr&lt;/em&gt;的引用。</target>
        </trans-unit>
        <trans-unit id="3ceff3d1be740072d08fa441617d883813e56f19" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt; if it is not NULL.</source>
          <target state="translated">如果该函数不为NULL，则它将窃取对&lt;em&gt;descr&lt;/em&gt;的引用。</target>
        </trans-unit>
        <trans-unit id="8281b58eb98855581eef0364cfa182f403baf433" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="translated">该函数窃取了对&lt;em&gt;descr&lt;/em&gt;的引用。</target>
        </trans-unit>
        <trans-unit id="71bb778b3ae86d2314883f6bdb50a6590499183c" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt;. The easiest way to get one is using &lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数窃取了对&lt;em&gt;descr&lt;/em&gt;的引用。最简单的方法是使用&lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6d42633714a13d2a78f3f69e93cf9d52e8a857e" translate="yes" xml:space="preserve">
          <source>This function supports both indexing conventions through the indexing keyword argument. Giving the string &amp;lsquo;ij&amp;rsquo; returns a meshgrid with matrix indexing, while &amp;lsquo;xy&amp;rsquo; returns a meshgrid with Cartesian indexing. In the 2-D case with inputs of length M and N, the outputs are of shape (N, M) for &amp;lsquo;xy&amp;rsquo; indexing and (M, N) for &amp;lsquo;ij&amp;rsquo; indexing. In the 3-D case with inputs of length M, N and P, outputs are of shape (N, M, P) for &amp;lsquo;xy&amp;rsquo; indexing and (M, N, P) for &amp;lsquo;ij&amp;rsquo; indexing. The difference is illustrated by the following code snippet:</source>
          <target state="translated">此函数通过indexing关键字参数支持两种索引约定。给定字符串&amp;ldquo; ij&amp;rdquo;将返回带有矩阵索引的网格，而&amp;ldquo; xy&amp;rdquo;将返回带有笛卡尔索引的网格。在输入长度为M和N的2-D情况下，对于&amp;ldquo; xy&amp;rdquo;索引，输出的形状为（N，M），对于&amp;ldquo; ij&amp;rdquo;索引，输出的形状为（M，N）。在输入长度为M，N和P的3-D情况下，对于&amp;ldquo; xy&amp;rdquo;索引，输出的形状为（N，M，P），对于&amp;ldquo; ij&amp;rdquo;索引的输出的形状为（M，N，P）。以下代码片段说明了这种差异：</target>
        </trans-unit>
        <trans-unit id="e857d76db9c7bac209f1715cec1437cf523540d8" translate="yes" xml:space="preserve">
          <source>This function swaps half-spaces for all axes listed (defaults to all). Note that &lt;code&gt;y[0]&lt;/code&gt; is the Nyquist component only if &lt;code&gt;len(x)&lt;/code&gt; is even.</source>
          <target state="translated">此功能为列出的所有轴交换半角空格（默认为全部）。注意，仅当 &lt;code&gt;len(x)&lt;/code&gt; 为偶数时， &lt;code&gt;y[0]&lt;/code&gt; 是奈奎斯特分量。</target>
        </trans-unit>
        <trans-unit id="a7870153b27cca4d6c02a86ec8c830b616e4b3c3" translate="yes" xml:space="preserve">
          <source>This function takes N 1-D sequences and returns N outputs with N dimensions each, such that the shape is 1 in all but one dimension and the dimension with the non-unit shape value cycles through all N dimensions.</source>
          <target state="translated">这个函数接收N个1-D序列,并返回N个输出,每个输出有N个维度,这样除了一个维度外,其他维度的形状都是1,并且非单位形状值的维度在所有N个维度中循环。</target>
        </trans-unit>
        <trans-unit id="b4e43f62f7a361a5fb222fc70fbd3c26bd5104e6" translate="yes" xml:space="preserve">
          <source>This function takes a multi-iterator object that has been previously &amp;ldquo;broadcasted,&amp;rdquo; finds the dimension with the smallest &amp;ldquo;sum of strides&amp;rdquo; in the broadcasted result and adapts all the iterators so as not to iterate over that dimension (by effectively making them of length-1 in that dimension). The corresponding dimension is returned unless &lt;em&gt;mit&lt;/em&gt; -&amp;gt;nd is 0, then -1 is returned. This function is useful for constructing ufunc-like routines that broadcast their inputs correctly and then call a strided 1-d version of the routine as the inner-loop. This 1-d version is usually optimized for speed and for this reason the loop should be performed over the axis that won&amp;rsquo;t require large stride jumps.</source>
          <target state="translated">此函数采用一个先前已&amp;ldquo;广播&amp;rdquo;的多迭代器对象，在广播结果中找到具有最小&amp;ldquo;步长和&amp;rdquo;的维度，并调整所有迭代器，以免在该维度上进行迭代（通过有效地使它们成为该尺寸的长度为1）。除非&lt;em&gt;mit-&lt;/em&gt; &amp;gt; nd为0，否则返回相应的维，然后返回-1。此函数对于构造类似ufunc的例程非常有用，这些例程可以正确广播其输入，然后将该例程的跨步1-d版本称为内部循环。通常针对速度优化此一维版本，因此，应在不需要大步幅跳动的轴上执行循环。</target>
        </trans-unit>
        <trans-unit id="102958a161ae2e87757cf73f96956c3988a66269" translate="yes" xml:space="preserve">
          <source>This function uses the same algorithm as the builtin python &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_left&quot;&gt;&lt;code&gt;bisect.bisect_left&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;side='left'&lt;/code&gt;) and &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_right&quot;&gt;&lt;code&gt;bisect.bisect_right&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;side='right'&lt;/code&gt;) functions, which is also vectorized in the &lt;code&gt;v&lt;/code&gt; argument.</source>
          <target state="translated">该函数使用与内置python &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_left&quot;&gt; &lt;code&gt;bisect.bisect_left&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;side='left'&lt;/code&gt; ）和&lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_right&quot;&gt; &lt;code&gt;bisect.bisect_right&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;side='right'&lt;/code&gt; ）函数相同的算法，它们也在 &lt;code&gt;v&lt;/code&gt; 参数中向量化。</target>
        </trans-unit>
        <trans-unit id="f4a094c15ea96c9120e1bb02da934b3ab9299caa" translate="yes" xml:space="preserve">
          <source>This function will not demote complex to float or anything to boolean, but will demote a signed integer to an unsigned integer when the scalar value is positive.</source>
          <target state="translated">这个函数不会将复数降级为float,也不会将任何东西降级为boolean,但会在标量值为正值时将有符号整数降级为无符号整数。</target>
        </trans-unit>
        <trans-unit id="e431cb683c0bc7c35e7633e888e952e4559756e5" translate="yes" xml:space="preserve">
          <source>This function will not preserve masking of MaskedArray inputs.</source>
          <target state="translated">这个函数不会保留MaskedArray输入的掩码。</target>
        </trans-unit>
        <trans-unit id="2a9b1f287c173d330577d2300449ee4dfd3daa91" translate="yes" xml:space="preserve">
          <source>This function works on subclasses of ndarray like &lt;a href=&quot;numpy.ma.array#numpy.ma.array&quot;&gt;&lt;code&gt;ma.array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数适用于ndarray的子​​类，如&lt;a href=&quot;numpy.ma.array#numpy.ma.array&quot;&gt; &lt;code&gt;ma.array&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6a52abd835e7532e9891ffc574fd5f4220e58bc" translate="yes" xml:space="preserve">
          <source>This function works similarly to &lt;a href=&quot;#c.PyArray_ObjectType&quot;&gt;&lt;code&gt;PyArray_ObjectType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) except it handles flexible arrays. The &lt;em&gt;mintype&lt;/em&gt; argument can have an itemsize member and the &lt;em&gt;outtype&lt;/em&gt; argument will have an itemsize member at least as big but perhaps bigger depending on the object &lt;em&gt;op&lt;/em&gt;.</source>
          <target state="translated">此函数与&lt;a href=&quot;#c.PyArray_ObjectType&quot;&gt; &lt;code&gt;PyArray_ObjectType&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）相似，但它处理灵活的数组。该&lt;em&gt;mintype&lt;/em&gt;参数可以有一个itemsize部件和&lt;em&gt;outtype&lt;/em&gt;参数将有至少一个itemsize成员一样大，但也许更大的取决于物体&lt;em&gt;运&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="24bfcaf02c26210c6ce475ff904488dd4e86859f" translate="yes" xml:space="preserve">
          <source>This functionality can be obtained via &lt;a href=&quot;numpy.diag_indices#numpy.diag_indices&quot;&gt;&lt;code&gt;diag_indices&lt;/code&gt;&lt;/a&gt;, but internally this version uses a much faster implementation that never constructs the indices and uses simple slicing.</source>
          <target state="translated">可以通过&lt;a href=&quot;numpy.diag_indices#numpy.diag_indices&quot;&gt; &lt;code&gt;diag_indices&lt;/code&gt; &lt;/a&gt;获得此功能，但是在内部，此版本使用更快的实现，该实现从不构造索引并且使用简单的切片。</target>
        </trans-unit>
        <trans-unit id="8df0c373fc062bf47c7c593de18498c118dd2c34" translate="yes" xml:space="preserve">
          <source>This general purpose 1-d core function assumes that &lt;em&gt;func&lt;/em&gt; is a string representing a method of the input object that takes one argument. The first argument in &lt;em&gt;args&lt;/em&gt; is the method whose function is called, the second argument in &lt;em&gt;args&lt;/em&gt; is the argument passed to the function. The output of the function is stored in the third entry of &lt;em&gt;args&lt;/em&gt;.</source>
          <target state="translated">该通用的1-d核心函数假定&lt;em&gt;func&lt;/em&gt;是一个字符串，表示一个输入参数的方法，该方法采用一个参数。在第一个参数&lt;em&gt;ARGS&lt;/em&gt;是其功能被调用时，在第二个参数的方法&lt;em&gt;ARGS&lt;/em&gt;是传递给函数的自变量。函数的输出存储在&lt;em&gt;args&lt;/em&gt;的第三项中。</target>
        </trans-unit>
        <trans-unit id="71fb70d934e71392e5b977e3d5908e6d14ba65f1" translate="yes" xml:space="preserve">
          <source>This general purpose 1-d core function assumes that &lt;em&gt;func&lt;/em&gt; is a string representing a method of the input object. For each iteration of the loop, the Python object is extracted from the array and its &lt;em&gt;func&lt;/em&gt; method is called returning the result to the output array.</source>
          <target state="translated">该通用的1-d核心函数假定&lt;em&gt;func&lt;/em&gt;是表示输入对象的方法的字符串。对于循环的每次迭代，都会从数组中提取Python对象，并调用其&lt;em&gt;func&lt;/em&gt;方法，将结果返回到输出数组。</target>
        </trans-unit>
        <trans-unit id="ebe1403d50c0fdb0002abff6822f498479faa88e" translate="yes" xml:space="preserve">
          <source>This geometrical property can be seen in two dimensions by plotting generated data-points:</source>
          <target state="translated">这种几何属性可以通过绘制生成的数据点在二维度上看到。</target>
        </trans-unit>
        <trans-unit id="e1dc7a565ca8eeac49fa065474eb2fca785df357" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; data pointers. If &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; was not specified, each data pointer points to the current data item of the iterator. If no inner iteration was specified, it points to the first data item of the inner loop.</source>
          <target state="translated">这将返回一个指向 &lt;code&gt;nop&lt;/code&gt; 数据指针的指针。如果未指定&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;，则每个数据指针都指向迭代器的当前数据项。如果未指定内部迭代，则它指向内部循环的第一个数据项。</target>
        </trans-unit>
        <trans-unit id="ad9e42c674af93de7c3d00b721f840bb2a3ba388" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; data type Descrs for the objects being iterated. The result points into &lt;code&gt;iter&lt;/code&gt;, so the caller does not gain any references to the Descrs.</source>
          <target state="translated">这将返回指向要迭代的对象的 &lt;code&gt;nop&lt;/code&gt; 数据类型Descrs 的指针。结果指向 &lt;code&gt;iter&lt;/code&gt; ，因此调用方不会获得对Descrs的任何引用。</target>
        </trans-unit>
        <trans-unit id="04484c93294b17e48ec0072eb06cb15b6ce824d8" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; operand PyObjects that are being iterated. The result points into &lt;code&gt;iter&lt;/code&gt;, so the caller does not gain any references to the PyObjects.</source>
          <target state="translated">这将返回指向正在迭代的 &lt;code&gt;nop&lt;/code&gt; 操作数PyObject 的指针。结果指向 &lt;code&gt;iter&lt;/code&gt; ，因此调用方不会获得对PyObjects的任何引用。</target>
        </trans-unit>
        <trans-unit id="de4914e9685130ac5234ec503748e2bb51b5d569" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the index being tracked, or NULL if no index is being tracked. It is only useable if one of the flags &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt; were specified during construction.</source>
          <target state="translated">这将返回指向被跟踪索引的指针，如果没有索引被跟踪，则返回NULL。仅在构造期间指定了标志&lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; &lt;/a&gt;之一时才可用。</target>
        </trans-unit>
        <trans-unit id="76e1c3a277ebfaa2cffaf967d76cec0c7e8df194" translate="yes" xml:space="preserve">
          <source>This gives back a reference to a new ndarray view, which is a view into the i-th object in the array &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt;, whose dimensions and strides match the internal optimized iteration pattern. A C-order iteration of this view is equivalent to the iterator&amp;rsquo;s iteration order.</source>
          <target state="translated">这将返回对新ndarray视图的引用，该视图是对&lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt; &lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt; &lt;/a&gt;数组中第i个对象的视图，其尺寸和步幅与内部优化的迭代模式匹配。此视图的C顺序迭代等效于迭代器的迭代顺序。</target>
        </trans-unit>
        <trans-unit id="5203e44570d99c05fcfa2df4337f300e46c186be" translate="yes" xml:space="preserve">
          <source>This group is used to call code that may take some time but does not use any Python C-API calls. Thus, the GIL should be released during its calculation.</source>
          <target state="translated">该组用于调用可能需要一些时间但不使用任何 Python C-API 调用的代码。因此,GIL应该在其计算过程中被释放。</target>
        </trans-unit>
        <trans-unit id="5bcd38e59fd6cf93688e83d10245c536ddb55a3a" translate="yes" xml:space="preserve">
          <source>This group is used to re-acquire the Python GIL after it has been released. For example, suppose the GIL has been released (using the previous calls), and then some path in the code (perhaps in a different subroutine) requires use of the Python C-API, then these macros are useful to acquire the GIL. These macros accomplish essentially a reverse of the previous three (acquire the LOCK saving what state it had) and then re-release it with the saved state.</source>
          <target state="translated">这组用于在Python GIL被释放后重新获取它。例如,假设 GIL 已经被释放 (使用前面的调用),然后在代码中的某些路径 (可能在不同的子程序中)需要使用 Python C-API,那么这些宏就可以用来获取 GIL。这些宏基本上完成了前面三个宏的反转(获取LOCK保存它的状态),然后用保存的状态重新释放它。</target>
        </trans-unit>
        <trans-unit id="11fb823e6d137af2611381a853679838cd294872" translate="yes" xml:space="preserve">
          <source>This interface describes homogeneous arrays in the sense that each item of the array has the same &amp;ldquo;type&amp;rdquo;. This type can be very simple or it can be a quite arbitrary and complicated C-like structure.</source>
          <target state="translated">从某种意义上说，此接口从阵列的每个项目具有相同的&amp;ldquo;类型&amp;rdquo;的角度描述同类阵列。这种类型可以非常简单，也可以是相当任意和复杂的类C结构。</target>
        </trans-unit>
        <trans-unit id="669065ebaf0e163f0816c64449775393f24910fd" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;numpy.flatiter#numpy.flatiter&quot;&gt;&lt;code&gt;numpy.flatiter&lt;/code&gt;&lt;/a&gt; instance, which acts similarly to, but is not a subclass of, Python&amp;rsquo;s built-in iterator object.</source>
          <target state="translated">这是一个&lt;a href=&quot;numpy.flatiter#numpy.flatiter&quot;&gt; &lt;code&gt;numpy.flatiter&lt;/code&gt; &lt;/a&gt;实例，其行为类似于Python的内置迭代器对象，但不是其子类。</target>
        </trans-unit>
        <trans-unit id="c616752b11f5b5590e848100c7afe1eff6eb31fb" translate="yes" xml:space="preserve">
          <source>This is a convenience function for quick storage of array data. Information on endianness and precision is lost, so this method is not a good choice for files intended to archive data or transport data between machines with different endianness. Some of these problems can be overcome by outputting the data as text files, at the expense of speed and file size.</source>
          <target state="translated">这是一个快速存储阵列数据的方便功能。由于丢失了迭度和精度的信息,所以这种方法并不适合用于存档数据或在不同迭度的机器之间传输数据的文件。其中一些问题可以通过将数据输出为文本文件来解决,但要牺牲速度和文件大小。</target>
        </trans-unit>
        <trans-unit id="aebce3c953e4d7a8aa40a69097fcdae621194f4a" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;code&gt;numpy.random.random_sample&lt;/code&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于用户从Matlab移植代码来说，这是一个便利功能，它包装了 &lt;code&gt;numpy.random.random_sample&lt;/code&gt; 。该函数使用一个元组来指定输出的大小，这与其他NumPy函数（例如&lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; )一致&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a8395276aef2b1c09ac3507c06c6aeae1c56edd" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;code&gt;numpy.random.standard_normal&lt;/code&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于用户从Matlab移植代码来说，这是一个便利功能，它包装了 &lt;code&gt;numpy.random.standard_normal&lt;/code&gt; 。该函数使用一个元组来指定输出的大小，这与其他NumPy函数（例如&lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; )一致&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14bed771c7ecf5fb5c7f3988c3e80ea720b90d56" translate="yes" xml:space="preserve">
          <source>This is a convenience, legacy function.</source>
          <target state="translated">这是一个方便、遗留的功能。</target>
        </trans-unit>
        <trans-unit id="8386d98dd4fd3fd3372da264e738d2eec8c472de" translate="yes" xml:space="preserve">
          <source>This is a default converter for output arrays given to functions. If &lt;em&gt;obj&lt;/em&gt; is &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt;&lt;code&gt;Py_None&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;NULL&lt;/code&gt;, then &lt;em&gt;*address&lt;/em&gt; will be &lt;code&gt;NULL&lt;/code&gt; but the call will succeed. If &lt;a href=&quot;#c.PyArray_Check&quot;&gt;&lt;code&gt;PyArray_Check&lt;/code&gt;&lt;/a&gt; ( &lt;em&gt;obj&lt;/em&gt;) is TRUE then it is returned in &lt;em&gt;*address&lt;/em&gt; without incrementing its reference count.</source>
          <target state="translated">这是给函数提供输出数组的默认转换器。如果&lt;em&gt;obj&lt;/em&gt;是&lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt; &lt;code&gt;Py_None&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;NULL&lt;/code&gt; ，则&lt;em&gt;* address&lt;/em&gt;将为 &lt;code&gt;NULL&lt;/code&gt; ,但调用将成功。如果&lt;a href=&quot;#c.PyArray_Check&quot;&gt; &lt;code&gt;PyArray_Check&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;obj&lt;/em&gt;）为TRUE，则它将在&lt;em&gt;* address中&lt;/em&gt;返回而不增加其引用计数。</target>
        </trans-unit>
        <trans-unit id="ebf6bd0b70f0575c64ee3df5fdd00ac441de460d" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to C99 copysign: return x with the same sign as y. Works for any value, including inf and nan. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">这个函数相当于C99的copysign:返回与y相同符号的x。对任何值都有效,包括inf和nan。后缀f和l可用于单精度和扩展精度。</target>
        </trans-unit>
        <trans-unit id="9c5d9b74232b5b43fdac1227d638313277afa572" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to C99 nextafter: return next representable floating point value from x in the direction of y. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">这是一个相当于C99 nextafter的函数:从x向y的方向返回下一个可表示的浮点数,单精度和扩展精度可以用后缀f和l来表示。</target>
        </trans-unit>
        <trans-unit id="6cef9e65ee084ca1f09a67a21a4b3ef4b9523383" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to Fortran intrinsic. Return distance between x and next representable floating point value from x, e.g. spacing(1) == eps. spacing of nan and +/- inf return nan. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">这是一个相当于Fortran本征的函数。返回 x 与 x 之间的距离,例如 spacing(1)==eps.间距为 nan 和 +/-inf 返回 nan.单个和扩展的精度可以用后缀f和l来表示。</target>
        </trans-unit>
        <trans-unit id="f691a7cca2d5bab9d5322a451f5071b060431b18" translate="yes" xml:space="preserve">
          <source>This is a function pointer for getting the current iterator multi-index, returned by &lt;a href=&quot;#c.NpyIter_GetGetMultiIndex&quot;&gt;&lt;code&gt;NpyIter_GetGetMultiIndex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是一个函数指针，用于获取由&lt;a href=&quot;#c.NpyIter_GetGetMultiIndex&quot;&gt; &lt;code&gt;NpyIter_GetGetMultiIndex&lt;/code&gt; &lt;/a&gt;返回的当前迭代器多索引。</target>
        </trans-unit>
        <trans-unit id="afe9f9d9e5612f0c43f0b6f2ab1ddbf98d2077ed" translate="yes" xml:space="preserve">
          <source>This is a function pointer for the iteration loop, returned by &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt;&lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是迭代循环的函数指针，由&lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt; &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt; &lt;/a&gt;返回。</target>
        </trans-unit>
        <trans-unit id="682e5efdefc09e15bb711f19c6e22c6512c8e3c9" translate="yes" xml:space="preserve">
          <source>This is a list of flags for each operand. At minimum, one of &lt;code&gt;readonly&lt;/code&gt;, &lt;code&gt;readwrite&lt;/code&gt;, or &lt;code&gt;writeonly&lt;/code&gt; must be specified.</source>
          <target state="translated">这是每个操作数的标志的列表。至少必须指定 &lt;code&gt;readonly&lt;/code&gt; ， &lt;code&gt;readwrite&lt;/code&gt; 或 &lt;code&gt;writeonly&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="daee1c27087ebe5008ffab37bf86e6cef5520692" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isfinite: works for single, double and extended precision, and return a non 0 value is x is neither a NaN nor an infinity.</source>
          <target state="translated">这是一个宏,相当于C99 isfinite:适用于单精度、双精度和扩展精度,并返回一个非0值,即x既不是NaN也不是无穷大。</target>
        </trans-unit>
        <trans-unit id="80381bd72606c65ade88008349bbceb47f771261" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isinf: works for single, double and extended precision, and return a non 0 value is x is infinite (positive and negative).</source>
          <target state="translated">这是一个宏,相当于C99 isinf:适用于单精度、双精度和扩展精度,并返回一个非0值,即x是无限的(正和负)。</target>
        </trans-unit>
        <trans-unit id="0a2766c5fc1ee9982025de76ae4aa9f68ecd22db" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isnan: works for single, double and extended precision, and return a non 0 value is x is a NaN.</source>
          <target state="translated">这是一个宏,相当于C99 isnan:适用于单精度、双精度和扩展精度,并在x是NaN时返回一个非0值。</target>
        </trans-unit>
        <trans-unit id="ba072edcddb8314e48393832fd145a168df5e278" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 signbit: works for single, double and extended precision, and return a non 0 value is x has the signbit set (that is the number is negative).</source>
          <target state="translated">这是一个宏,相当于C99的signbit:适用于单精度、双精度和扩展精度,并在x有signbit设置时返回一个非0值(即数字为负)。</target>
        </trans-unit>
        <trans-unit id="e912c91523a3cdb66f72696d355ab45d0a9a414f" translate="yes" xml:space="preserve">
          <source>This is a relatively robust method to compare two arrays whose amplitude is variable.</source>
          <target state="translated">这是一种比较稳健的方法,用于比较两个振幅可变的数组。</target>
        </trans-unit>
        <trans-unit id="f9e98f643e268bceb892d520470f87f06bd3ffa1" translate="yes" xml:space="preserve">
          <source>This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="5b6ff4b3ee0d226dd43f100afc9a5e9fc743a95d" translate="yes" xml:space="preserve">
          <source>This is a simple way to build up arrays quickly. There are two use cases.</source>
          <target state="translated">这是一种快速建立数组的简单方法。有两个用例。</target>
        </trans-unit>
        <trans-unit id="5bf246dfc26ef7aa2b64da9e4b03eace45db2857" translate="yes" xml:space="preserve">
          <source>This is a special flag that is set if this array represents a copy made because a user required certain flags in &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; and a copy had to be made of some other array (and the user asked for this flag to be set in such a situation). The base attribute then points to the &amp;ldquo;misbehaved&amp;rdquo; array (which is set read_only). :c:func`PyArray_ResolveWritebackIfCopy` will copy its contents back to the &amp;ldquo;misbehaved&amp;rdquo; array (casting if necessary) and will reset the &amp;ldquo;misbehaved&amp;rdquo; array to &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;. If the &amp;ldquo;misbehaved&amp;rdquo; array was not &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; to begin with then &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; would have returned an error because &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; would not have been possible.</source>
          <target state="translated">这是一个特殊标志，如果此数组表示由于用户需要&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; 中的&lt;/a&gt;某些标志而必须复制某个其他数组（并且用户要求在这种情况下设置此标志）而制作的副本，则设置该标志。 。然后，基本属性指向&amp;ldquo;行为异常&amp;rdquo;数组（设置为read_only）。 ：c：func`PyArray_ResolveWritebackIfCopy`将其内容复制回&amp;ldquo;行为不当&amp;rdquo;数组（如有必要，进行广播），并将&amp;ldquo;行为不当&amp;rdquo;数组重置为&lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;。如果&amp;ldquo;不当行为&amp;rdquo;数组不是以&lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;开头的，则&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;将返回错误，因为&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d494bbd6ea4e55e23b6320030cf19b92084fb2cb" translate="yes" xml:space="preserve">
          <source>This is a very flexible function; &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.array_str#numpy.array_str&quot;&gt;&lt;code&gt;array_str&lt;/code&gt;&lt;/a&gt; are using &lt;a href=&quot;#numpy.array2string&quot;&gt;&lt;code&gt;array2string&lt;/code&gt;&lt;/a&gt; internally so keywords with the same name should work identically in all three functions.</source>
          <target state="translated">这是一个非常灵活的功能；&lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.array_str#numpy.array_str&quot;&gt; &lt;code&gt;array_str&lt;/code&gt; &lt;/a&gt;在内部使用&lt;a href=&quot;#numpy.array2string&quot;&gt; &lt;code&gt;array2string&lt;/code&gt; ,&lt;/a&gt;因此具有相同名称的关键字在所有三个函数中应相同地工作。</target>
        </trans-unit>
        <trans-unit id="4a20d6c5e13bf5949cf2f01fed00be4a85ee83c8" translate="yes" xml:space="preserve">
          <source>This is a wrapper around &lt;code&gt;cPickle.dump&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;cPickle.dump&lt;/code&gt; 的包装。</target>
        </trans-unit>
        <trans-unit id="72c0baacc027dca1b05db754f60ee813fa6dbfcf" translate="yes" xml:space="preserve">
          <source>This is a wrapper around &lt;code&gt;cPickle.dumps&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;cPickle.dumps&lt;/code&gt; 的包装。</target>
        </trans-unit>
        <trans-unit id="b6ae9c5b7de866ac0dd1b4b58c7a54bd18149043" translate="yes" xml:space="preserve">
          <source>This is almost the same as the result of PyArray_CanCastTypeTo(PyArray_MinScalarType(arr), totype, casting), but it also handles a special case arising because the set of uint values is not a subset of the int values for types with the same number of bits.</source>
          <target state="translated">这与PyArray_CanCastTypeTo(PyArray_MinScalarType(arr),totype,casting)的结果几乎是一样的,但它也处理了一种特殊情况,因为uint值的集合不是具有相同位数的类型的int值的子集。</target>
        </trans-unit>
        <trans-unit id="abef17cd5a41150617b797dd34026cad2a72bcf3" translate="yes" xml:space="preserve">
          <source>This is an example of a func specialized for addition of doubles returning doubles.</source>
          <target state="translated">这是一个专门用于双倍加法返回双倍的函数的例子。</target>
        </trans-unit>
        <trans-unit id="8d1fbd89490e7598a40d0ab430364ea01d0cff36" translate="yes" xml:space="preserve">
          <source>This is an interface to the LAPACK routines &lt;code&gt;dgeqrf&lt;/code&gt;, &lt;code&gt;zgeqrf&lt;/code&gt;, &lt;code&gt;dorgqr&lt;/code&gt;, and &lt;code&gt;zungqr&lt;/code&gt;.</source>
          <target state="translated">这是LAPACK例程 &lt;code&gt;dgeqrf&lt;/code&gt; ， &lt;code&gt;zgeqrf&lt;/code&gt; ， &lt;code&gt;dorgqr&lt;/code&gt; 和 &lt;code&gt;zungqr&lt;/code&gt; 的接口。</target>
        </trans-unit>
        <trans-unit id="944d000b70e8d3d375939368b9ee8662949fdd56" translate="yes" xml:space="preserve">
          <source>This is an iterator object that makes it easy to loop over an N-dimensional array. It is the object returned from the flat attribute of an ndarray. It is also used extensively throughout the implementation internals to loop over an N-dimensional array. The tp_as_mapping interface is implemented so that the iterator object can be indexed (using 1-d indexing), and a few methods are implemented through the tp_methods table. This object implements the next method and can be used anywhere an iterator can be used in Python.</source>
          <target state="translated">这是一个迭代器对象,它可以很容易地对一个N维数组进行循环。它是由ndarray的flat属性返回的对象。在整个实现内部,它也被广泛地用于在一个N维数组上循环。tp_as_mapping接口的实现使得迭代器对象可以被索引(使用1-d索引),并且通过tp_methods表实现了一些方法。这个对象实现了下一个方法,可以在Python中任何可以使用迭代器的地方使用。</target>
        </trans-unit>
        <trans-unit id="39877197a88959914be74b4d252daeba988b0567" translate="yes" xml:space="preserve">
          <source>This is an iterator object that makes it easy to loop over an N-dimensional neighborhood.</source>
          <target state="translated">这是一个迭代器对象,可以很容易地在一个N维邻域上进行循环。</target>
        </trans-unit>
        <trans-unit id="ed4488f4638f84c1e1e4b827cf0b8579c8c851e4" translate="yes" xml:space="preserve">
          <source>This is an opaque pointer type for the iterator. Access to its contents can only be done through the iterator API.</source>
          <target state="translated">这是迭代器的不透明指针类型。对其内容的访问只能通过迭代器API来完成。</target>
        </trans-unit>
        <trans-unit id="b4c12ec7da04774c2971488c28da077dd954ab73" translate="yes" xml:space="preserve">
          <source>This is defined for &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;, &lt;strong&gt;SHORT&lt;/strong&gt;, &lt;strong&gt;INT&lt;/strong&gt;, &lt;strong&gt;LONG&lt;/strong&gt;, &lt;strong&gt;LONGLONG&lt;/strong&gt;, &lt;strong&gt;INTP&lt;/strong&gt;</source>
          <target state="translated">为 &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;，&lt;strong&gt;SHORT&lt;/strong&gt;，&lt;strong&gt;INT&lt;/strong&gt;，&lt;strong&gt;LONG&lt;/strong&gt;，&lt;strong&gt;LONGLONG&lt;/strong&gt;，&lt;strong&gt;INTP定义&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1cb38ad4a8a5f0f7eaad9358f9b24fff730b48c2" translate="yes" xml:space="preserve">
          <source>This is defined for all defined for &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;, &lt;strong&gt;UBYTE&lt;/strong&gt;, &lt;strong&gt;SHORT&lt;/strong&gt;, &lt;strong&gt;USHORT&lt;/strong&gt;, &lt;strong&gt;INT&lt;/strong&gt;, &lt;strong&gt;UINT&lt;/strong&gt;, &lt;strong&gt;LONG&lt;/strong&gt;, &lt;strong&gt;ULONG&lt;/strong&gt;, &lt;strong&gt;LONGLONG&lt;/strong&gt;, &lt;strong&gt;ULONGLONG&lt;/strong&gt;, &lt;strong&gt;INTP&lt;/strong&gt;, &lt;strong&gt;UINTP&lt;/strong&gt;</source>
          <target state="translated">为 &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;，&lt;strong&gt;UBYTE&lt;/strong&gt;，&lt;strong&gt;SHORT&lt;/strong&gt;，&lt;strong&gt;USHORT&lt;/strong&gt;，&lt;strong&gt;INT&lt;/strong&gt;，&lt;strong&gt;UINT&lt;/strong&gt;，&lt;strong&gt;LONG&lt;/strong&gt;，&lt;strong&gt;ULONG&lt;/strong&gt;，&lt;strong&gt;LONGLONG&lt;/strong&gt;，&lt;strong&gt;ULONGLONG&lt;/strong&gt;，&lt;strong&gt;INTP&lt;/strong&gt;，&lt;strong&gt;UINTP&lt;/strong&gt;定义的所有定义&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e53b90b8b35ae60046587f59e89f7b60e6df85a" translate="yes" xml:space="preserve">
          <source>This is different from &lt;a href=&quot;numpy.load#numpy.load&quot;&gt;&lt;code&gt;numpy.load&lt;/code&gt;&lt;/a&gt;, which does not use cPickle but loads the NumPy binary .npy format.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.load#numpy.load&quot;&gt; &lt;code&gt;numpy.load&lt;/code&gt; &lt;/a&gt;不同，后者不使用cPickle而是加载NumPy二进制.npy格式。</target>
        </trans-unit>
        <trans-unit id="ad4d2eb9b0ee11d28c4e5a349ba480c6768dfc79" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt; and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">这等效于（但比其快）以下对&lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; 的使用&lt;/a&gt;，后者将 &lt;code&gt;ii&lt;/code&gt; 和 &lt;code&gt;kk&lt;/code&gt; 设置为索引元组：</target>
        </trans-unit>
        <trans-unit id="f5170749efab413ba3776c33568562d9c4634a7d" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">这等效于（但比其快）以下对&lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; 的&lt;/a&gt;使用，它将 &lt;code&gt;ii&lt;/code&gt; ， &lt;code&gt;jj&lt;/code&gt; 和 &lt;code&gt;kk&lt;/code&gt; 中的每一个设置为一个索引元组：</target>
        </trans-unit>
        <trans-unit id="f723a36a0fdceaf5add767f4dfa10dbdef0cf27e" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;code&gt;ndindex&lt;/code&gt; and &lt;code&gt;s_&lt;/code&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">这等效于（但比其快）以下对 &lt;code&gt;ndindex&lt;/code&gt; 和 &lt;code&gt;s_&lt;/code&gt; 的使用，它将 &lt;code&gt;ii&lt;/code&gt; ， &lt;code&gt;jj&lt;/code&gt; 和 &lt;code&gt;kk&lt;/code&gt; 中的每一个设置为一个索引元组：</target>
        </trans-unit>
        <trans-unit id="9623032760a445ce084ed7cad1f49c8e81cbc730" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.compress(ravel(condition), ravel(arr))&lt;/code&gt;. If &lt;code&gt;condition&lt;/code&gt; is boolean &lt;code&gt;np.extract&lt;/code&gt; is equivalent to &lt;code&gt;arr[condition]&lt;/code&gt;.</source>
          <target state="translated">这等效于 &lt;code&gt;np.compress(ravel(condition), ravel(arr))&lt;/code&gt; 。如果 &lt;code&gt;condition&lt;/code&gt; 为布尔值，则 &lt;code&gt;np.extract&lt;/code&gt; 等效于 &lt;code&gt;arr[condition]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="512416aca8fa4fb317d305f7a3902a8f4f57268d" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt;, see &lt;code&gt;extras.compress_rowcols&lt;/code&gt; for details.</source>
          <target state="translated">这等效于 &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt; ，有关详细信息，请参见 &lt;code&gt;extras.compress_rowcols&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1aabefa5df0b67ecae64f8e5a2fb2a4d5dd2e5ee" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt;, see &lt;code&gt;extras.compress_rowcols&lt;/code&gt; for details.</source>
          <target state="translated">这等效于 &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt; ，有关详细信息，请参见 &lt;code&gt;extras.compress_rowcols&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e12dd8fc795d33b8f8bcabb847c3e158c738c5e" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the first axis after 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N)&lt;/code&gt;. Rebuilds arrays divided by &lt;a href=&quot;numpy.vsplit#numpy.vsplit&quot;&gt;&lt;code&gt;vsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这等效于形状 &lt;code&gt;(N,)&lt;/code&gt; 的一维数组已重整为 &lt;code&gt;(1,N)&lt;/code&gt; 后沿第一轴进行连接。重建除以&lt;a href=&quot;numpy.vsplit#numpy.vsplit&quot;&gt; &lt;code&gt;vsplit&lt;/code&gt; 的&lt;/a&gt;数组。</target>
        </trans-unit>
        <trans-unit id="8a1612db7b39849ef3a6bd08b64bed8c3240f816" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the first axis after 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N)&lt;/code&gt;. Rebuilds arrays divided by &lt;code&gt;vsplit&lt;/code&gt;.</source>
          <target state="translated">这等效于形状 &lt;code&gt;(N,)&lt;/code&gt; 的一维数组已重整为 &lt;code&gt;(1,N)&lt;/code&gt; 后沿第一轴进行连接。重建除以 &lt;code&gt;vsplit&lt;/code&gt; 的数组。</target>
        </trans-unit>
        <trans-unit id="e9676c88264ef3cd76556860f143548d10e94eb6" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the second axis, except for 1-D arrays where it concatenates along the first axis. Rebuilds arrays divided by &lt;a href=&quot;numpy.hsplit#numpy.hsplit&quot;&gt;&lt;code&gt;hsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这等效于沿第二个轴的串联，除了一维数组沿第一个轴的串联。重建除以&lt;a href=&quot;numpy.hsplit#numpy.hsplit&quot;&gt; &lt;code&gt;hsplit&lt;/code&gt; 的&lt;/a&gt;数组。</target>
        </trans-unit>
        <trans-unit id="e6a5b26fca5a2a732affc24a30a8305bc7f4ee4d" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the second axis, except for 1-D arrays where it concatenates along the first axis. Rebuilds arrays divided by &lt;a href=&quot;numpy.ma.hsplit#numpy.ma.hsplit&quot;&gt;&lt;code&gt;hsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这等效于沿第二个轴的串联，除了一维数组沿第一个轴的串联。重建除以&lt;a href=&quot;numpy.ma.hsplit#numpy.ma.hsplit&quot;&gt; &lt;code&gt;hsplit&lt;/code&gt; 的&lt;/a&gt;数组。</target>
        </trans-unit>
        <trans-unit id="5f3f85e2c1a9f572b9f43cddeb78f8794cecabcf" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the third axis after 2-D arrays of shape &lt;code&gt;(M,N)&lt;/code&gt; have been reshaped to &lt;code&gt;(M,N,1)&lt;/code&gt; and 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N,1)&lt;/code&gt;. Rebuilds arrays divided by &lt;a href=&quot;numpy.dsplit#numpy.dsplit&quot;&gt;&lt;code&gt;dsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这等效于形状 &lt;code&gt;(M,N)&lt;/code&gt; 的 2-D数组已重塑为 &lt;code&gt;(M,N,1)&lt;/code&gt; 和形状 &lt;code&gt;(N,)&lt;/code&gt; 的 1-D数组已重塑为 &lt;code&gt;(1,N,1)&lt;/code&gt; 。重建除以&lt;a href=&quot;numpy.dsplit#numpy.dsplit&quot;&gt; &lt;code&gt;dsplit&lt;/code&gt; 的&lt;/a&gt;数组。</target>
        </trans-unit>
        <trans-unit id="5c6f9c31ab715a660b4d23dc2f49389f45ea5bda" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the third axis after 2-D arrays of shape &lt;code&gt;(M,N)&lt;/code&gt; have been reshaped to &lt;code&gt;(M,N,1)&lt;/code&gt; and 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N,1)&lt;/code&gt;. Rebuilds arrays divided by &lt;code&gt;dsplit&lt;/code&gt;.</source>
          <target state="translated">这等效于形状 &lt;code&gt;(M,N)&lt;/code&gt; 的 2-D数组已重塑为 &lt;code&gt;(M,N,1)&lt;/code&gt; 和形状 &lt;code&gt;(N,)&lt;/code&gt; 的 1-D数组已重塑为 &lt;code&gt;(1,N,1)&lt;/code&gt; 。重建除以 &lt;code&gt;dsplit&lt;/code&gt; 的数组。</target>
        </trans-unit>
        <trans-unit id="d218a0a3e8c4c5860255504a9ba19c22b6fab14a" translate="yes" xml:space="preserve">
          <source>This is equivalent to np.nonzero(np.ravel(a))[0].</source>
          <target state="translated">这相当于np.nonzero(np.ravel(a))[0]。</target>
        </trans-unit>
        <trans-unit id="c1506fb5159fec603ce600935782977e9cc4a640" translate="yes" xml:space="preserve">
          <source>This is equivalent to the &lt;code&gt;density&lt;/code&gt; argument, but produces incorrect results for unequal bin widths. It should not be used.</source>
          <target state="translated">这等效于 &lt;code&gt;density&lt;/code&gt; 参数，但是对于不等的箱宽会产生不正确的结果。不应使用。</target>
        </trans-unit>
        <trans-unit id="59cfbae4022883700bb27212977a0aea4a1ca893" translate="yes" xml:space="preserve">
          <source>This is equivalent to the buffer object structure in Python up to the ptr member. On 32-bit platforms (&lt;em&gt;i.e.&lt;/em&gt; if &lt;a href=&quot;c-api.config#c.NPY_SIZEOF_INT&quot;&gt;&lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt;&lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt;), the len member also matches an equivalent member of the buffer object. It is useful to represent a generic single-segment chunk of memory.</source>
          <target state="translated">这等效于Python中直到ptr成员的缓冲区对象结构。在32位平台上（&lt;em&gt;即，&lt;/em&gt;如果&lt;a href=&quot;c-api.config#c.NPY_SIZEOF_INT&quot;&gt; &lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt; &lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt; ），len成员还匹配缓冲区对象的等效成员。表示通用的单段内存块很有用。</target>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">这相当于:</target>
        </trans-unit>
        <trans-unit id="71a0da6263af85d6d95df709a66cce1cab814a13" translate="yes" xml:space="preserve">
          <source>This is for output arrays, and requires that the flag &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt;&lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt;&lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt;&lt;/a&gt; be set. If &lt;code&gt;op[i]&lt;/code&gt; is NULL, creates a new array with the final broadcast dimensions, and a layout matching the iteration order of the iterator.</source>
          <target state="translated">这是针对输出数组的，要求设置标志&lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt; &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt; &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;op[i]&lt;/code&gt; 为NULL，则创建一个具有最终广播尺寸的新数组，以及一个与迭代器的迭代顺序匹配的布局。</target>
        </trans-unit>
        <trans-unit id="271064c73ce5e7dc4de339611f7b4db1a780a7f2" translate="yes" xml:space="preserve">
          <source>This is implemented using the &lt;code&gt;_geev&lt;/code&gt; LAPACK routines which compute the eigenvalues and eigenvectors of general square arrays.</source>
          <target state="translated">这是使用 &lt;code&gt;_geev&lt;/code&gt; LAPACK例程实现的，该例程计算通用方阵的特征值和特征向量。</target>
        </trans-unit>
        <trans-unit id="caec4ff4a054237a51c7a499531b302398f70bf8" translate="yes" xml:space="preserve">
          <source>This is indicated in the documentation via input parameter specifications such as &lt;code&gt;a : (..., M, M) array_like&lt;/code&gt;. This means that if for instance given an input array &lt;code&gt;a.shape == (N, M, M)&lt;/code&gt;, it is interpreted as a &amp;ldquo;stack&amp;rdquo; of N matrices, each of size M-by-M. Similar specification applies to return values, for instance the determinant has &lt;code&gt;det : (...)&lt;/code&gt; and will in this case return an array of shape &lt;code&gt;det(a).shape == (N,)&lt;/code&gt;. This generalizes to linear algebra operations on higher-dimensional arrays: the last 1 or 2 dimensions of a multidimensional array are interpreted as vectors or matrices, as appropriate for each operation.</source>
          <target state="translated">这在文档中通过输入参数规范来指示，例如 &lt;code&gt;a : (..., M, M) array_like&lt;/code&gt; 。这意味着，例如，如果给定输入数组 &lt;code&gt;a.shape == (N, M, M)&lt;/code&gt; ，则将其解释为N个矩阵的&amp;ldquo;堆栈&amp;rdquo;，每个矩阵的大小为M&amp;times;M。类似的规范适用于返回值，例如行列式具有 &lt;code&gt;det : (...)&lt;/code&gt; ，在这种情况下将返回一个形状为 &lt;code&gt;det(a).shape == (N,)&lt;/code&gt; 的数组。这可以概括为对高维数组的线性代数运算：多维数组的最后1或2维被视作矢量或矩阵，视每个运算而定。</target>
        </trans-unit>
        <trans-unit id="142401db7b88684f56ec37cbd8f1ca65b6bf6771" translate="yes" xml:space="preserve">
          <source>This is intended for working with source directories that are in an SVN repository.</source>
          <target state="translated">这是为处理SVN仓库中的源目录而设计的。</target>
        </trans-unit>
        <trans-unit id="f497c1d2afa9510500c0e5d52cafff444023b2a6" translate="yes" xml:space="preserve">
          <source>This is needed by all Python objects. It consists of (at least) a reference count member ( &lt;code&gt;ob_refcnt&lt;/code&gt; ) and a pointer to the typeobject ( &lt;code&gt;ob_type&lt;/code&gt; ). (Other elements may also be present if Python was compiled with special options see Include/object.h in the Python source tree for more information). The ob_type member points to a Python type object.</source>
          <target state="translated">所有Python对象都需要这样做。它至少由一个引用计数成员（ &lt;code&gt;ob_refcnt&lt;/code&gt; ）和一个指向类型对象的指针（ &lt;code&gt;ob_type&lt;/code&gt; ）组成。（如果使用特殊选项编译Python，则其他元素也可能存在，有关更多信息，请参见Python源代码树中的Include / object.h）。ob_type成员指向Python类型对象。</target>
        </trans-unit>
        <trans-unit id="dd8997d00c105166c9b4b9f773f5d0cdd6fa01f2" translate="yes" xml:space="preserve">
          <source>This is raised when an binary operation is passed Poly objects with different domains.</source>
          <target state="translated">当二进制操作被传递给具有不同域的Poly对象时,会引发此问题。</target>
        </trans-unit>
        <trans-unit id="e57f721854d8f362e4016c48c315f6301f247f80" translate="yes" xml:space="preserve">
          <source>This is really &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt; with different defaults. For more details see &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用不同的默认值确实很&lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt; &lt;code&gt;irfftn&lt;/code&gt; &lt;/a&gt;。有关更多详细信息，请参见&lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt; &lt;code&gt;irfftn&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed9f359368f007790ca5657cc8ec4082492a200b" translate="yes" xml:space="preserve">
          <source>This is really just &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt; with different default behavior. For more details see &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这实际上只是具有不同默认行为的&lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt;。有关更多详细信息，请参见&lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ef26806f6ea74b6485ab483c2778eff715e4572" translate="yes" xml:space="preserve">
          <source>This is short-hand for &lt;code&gt;np.r_['-1,2,0', index expression]&lt;/code&gt;, which is useful because of its common occurrence. In particular, arrays will be stacked along their last axis after being upgraded to at least 2-D with 1&amp;rsquo;s post-pended to the shape (column vectors made out of 1-D arrays).</source>
          <target state="translated">这是 &lt;code&gt;np.r_['-1,2,0', index expression]&lt;/code&gt; ，因为它很常见，所以很有用。特别是，在将阵列升级到至少2维且其后缀为1的形状（列矢量由1维阵列组成）之后，阵列将沿其最后一个轴堆叠。</target>
        </trans-unit>
        <trans-unit id="1c88394abdc65a1b05a8dd5d8683693375531a89" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) except you specify the data-type descriptor with &lt;em&gt;type_num&lt;/em&gt; and &lt;em&gt;itemsize&lt;/em&gt;, where &lt;em&gt;type_num&lt;/em&gt; corresponds to a builtin (or user-defined) type. If the type always has the same number of bytes, then itemsize is ignored. Otherwise, itemsize specifies the particular size of this array.</source>
          <target state="translated">这类似于&lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt;（&amp;hellip;），不同之处在于您使用&lt;em&gt;type_num&lt;/em&gt;和&lt;em&gt;itemsize&lt;/em&gt;指定数据类型描述符，其中&lt;em&gt;type_num&lt;/em&gt;对应于内置（或用户定义）类型。如果类型始终具有相同的字节数，则将忽略itemsize。否则，itemsize指定此数组的特定大小。</target>
        </trans-unit>
        <trans-unit id="ed43500d52b0e3a9d4bae70ddb5bfbe100ff1dd8" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;numpy.logspace#numpy.logspace&quot;&gt;&lt;code&gt;logspace&lt;/code&gt;&lt;/a&gt;, but with endpoints specified directly. Each output sample is a constant multiple of the previous.</source>
          <target state="translated">这类似于&lt;a href=&quot;numpy.logspace#numpy.logspace&quot;&gt; &lt;code&gt;logspace&lt;/code&gt; &lt;/a&gt;，但是直接指定了端点。每个输出样本是前一个样本的恒定倍数。</target>
        </trans-unit>
        <trans-unit id="852b3e753a1b8cdcb6346c93877a110d2d715f72" translate="yes" xml:space="preserve">
          <source>This is similar to choose or select, except that functions are evaluated on elements of &lt;code&gt;x&lt;/code&gt; that satisfy the corresponding condition from &lt;code&gt;condlist&lt;/code&gt;.</source>
          <target state="translated">这类似于select或select，不同之处在于，对满足 &lt;code&gt;condlist&lt;/code&gt; 中相应条件的 &lt;code&gt;x&lt;/code&gt; 元素求值函数。</target>
        </trans-unit>
        <trans-unit id="2c3a50a4a39023a7aa06d7ec91f3ecdac2409160" translate="yes" xml:space="preserve">
          <source>This is the &amp;ldquo;average&amp;rdquo; periodically compounded rate of return that gives a net present value of 0.0; for a more complete explanation, see Notes below.</source>
          <target state="translated">这是&amp;ldquo;平均&amp;rdquo;定期复合回报率，其净现值为0.0。有关更完整的说明，请参见下面的注释。</target>
        </trans-unit>
        <trans-unit id="0dbc891d865ae88284f9bfa0a0edbf0c765484c8" translate="yes" xml:space="preserve">
          <source>This is the 1-d core function used by the dynamic ufuncs created by umath.frompyfunc(function, nin, nout). In this case &lt;em&gt;func&lt;/em&gt; is a pointer to a &lt;a href=&quot;#c.PyUFunc_PyFuncData&quot;&gt;&lt;code&gt;PyUFunc_PyFuncData&lt;/code&gt;&lt;/a&gt; structure which has definition</source>
          <target state="translated">这是umath.frompyfunc（function，nin，nout）创建的动态ufunc使用的一维核心函数。在这种情况下，&lt;em&gt;func&lt;/em&gt;是指向具有定义的&lt;a href=&quot;#c.PyUFunc_PyFuncData&quot;&gt; &lt;code&gt;PyUFunc_PyFuncData&lt;/code&gt; &lt;/a&gt;结构的指针</target>
        </trans-unit>
        <trans-unit id="692a8cf195747eb5dfe92c87d684aef132c27f68" translate="yes" xml:space="preserve">
          <source>This is the NumPy implementation of the C library function fmod, the remainder has the same sign as the dividend &lt;code&gt;x1&lt;/code&gt;. It is equivalent to the Matlab(TM) &lt;code&gt;rem&lt;/code&gt; function and should not be confused with the Python modulus operator &lt;code&gt;x1 % x2&lt;/code&gt;.</source>
          <target state="translated">这是C库函数fmod的NumPy实现，其余部分与被除数 &lt;code&gt;x1&lt;/code&gt; 具有相同的符号。它等效于Matlab&amp;trade; &lt;code&gt;rem&lt;/code&gt; 函数，不应与Python模运算符 &lt;code&gt;x1 % x2&lt;/code&gt; 混淆。</target>
        </trans-unit>
        <trans-unit id="9f70c1d8b15029e4bba377d8eb228f8ad3621041" translate="yes" xml:space="preserve">
          <source>This is the code that handles the situation whenever the input and/or output arrays are either misaligned or of the wrong data-type (including being byte-swapped) from what the underlying 1-D loop expects. The arrays are also assumed to be non-contiguous. The code works very much like the strided-loop except for the inner 1-D loop is modified so that pre-processing is performed on the inputs and post- processing is performed on the outputs in bufsize chunks (where bufsize is a user-settable parameter). The underlying 1-D computational loop is called on data that is copied over (if it needs to be). The setup code and the loop code is considerably more complicated in this case because it has to handle:</source>
          <target state="translated">这是处理输入和/或输出数组错位或数据类型错误(包括被字节交换)的情况的代码,与底层一维循环的期望值不同。数组也被假定为非连续的。这段代码的工作方式与strided-loop非常相似,除了内部的1-D循环被修改为在输入上进行预处理,在输出上以bufsize块的形式进行后处理(其中bufsize是一个用户可设置的参数)。底层的一维计算循环会对复制过来的数据进行调用(如果需要的话)。在这种情况下,设置代码和循环代码要复杂得多,因为它必须处理。</target>
        </trans-unit>
        <trans-unit id="754ab86dfdc616fd9f3289ae80c9fb161f6f47b6" translate="yes" xml:space="preserve">
          <source>This is the main array creation function. Most new arrays are created with this flexible function.</source>
          <target state="translated">这是主要的数组创建函数。大多数新的数组都是用这个灵活的函数创建的。</target>
        </trans-unit>
        <trans-unit id="ae96a364309b5dfa1ba1a5f179699cc1e3ea0752" translate="yes" xml:space="preserve">
          <source>This is the main function used to obtain an array from any nested sequence, or object that exposes the array interface, &lt;em&gt;op&lt;/em&gt;. The parameters allow specification of the required &lt;em&gt;dtype&lt;/em&gt;, the minimum (&lt;em&gt;min_depth&lt;/em&gt;) and maximum (&lt;em&gt;max_depth&lt;/em&gt;) number of dimensions acceptable, and other &lt;em&gt;requirements&lt;/em&gt; for the array. This function &lt;strong&gt;steals a reference&lt;/strong&gt; to the dtype argument, which needs to be a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure indicating the desired data-type (including required byteorder). The &lt;em&gt;dtype&lt;/em&gt; argument may be &lt;code&gt;NULL&lt;/code&gt;, indicating that any data-type (and byteorder) is acceptable. Unless &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt; is present in &lt;code&gt;flags&lt;/code&gt;, this call will generate an error if the data type cannot be safely obtained from the object. If you want to use &lt;code&gt;NULL&lt;/code&gt; for the &lt;em&gt;dtype&lt;/em&gt; and ensure the array is notswapped then use &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt;&lt;code&gt;PyArray_CheckFromAny&lt;/code&gt;&lt;/a&gt;. A value of 0 for either of the depth parameters causes the parameter to be ignored. Any of the following array flags can be added (&lt;em&gt;e.g.&lt;/em&gt; using |) to get the &lt;em&gt;requirements&lt;/em&gt; argument. If your code can handle general (&lt;em&gt;e.g.&lt;/em&gt; strided, byte-swapped, or unaligned arrays) then &lt;em&gt;requirements&lt;/em&gt; may be 0. Also, if &lt;em&gt;op&lt;/em&gt; is not already an array (or does not expose the array interface), then a new array will be created (and filled from &lt;em&gt;op&lt;/em&gt; using the sequence protocol). The new array will have &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; as its flags member. The &lt;em&gt;context&lt;/em&gt; argument is passed to the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method of &lt;em&gt;op&lt;/em&gt; and is only used if the array is constructed that way. Almost always this parameter is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">这是用于从任何嵌套序列或公开数组接口&lt;em&gt;op的&lt;/em&gt;对象获取数组的主要功能。参数允许所需的规格&lt;em&gt;D型细胞&lt;/em&gt;，最小（&lt;em&gt;min_depth&lt;/em&gt;）和最大值（&lt;em&gt;MAX_DEPTH&lt;/em&gt;尺寸上可接受的）号码，以及其它&lt;em&gt;的要求&lt;/em&gt;对阵列。此函数&lt;strong&gt;窃取&lt;/strong&gt;对dtype参数&lt;strong&gt;的引用&lt;/strong&gt;，该&lt;strong&gt;引用&lt;/strong&gt;必须是&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;结构，以指示所需的数据类型（包括所需的字节序）。的&lt;em&gt;D型&lt;/em&gt;参数可以是 &lt;code&gt;NULL&lt;/code&gt; ，表示任何数据类型（和字节顺序）是可接受的。除非&lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt; &lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt; &lt;/a&gt;如果 &lt;code&gt;flags&lt;/code&gt; 中存在，则如果不能从对象安全地获取数据类型，则此调用将产生错误。如果你想使用 &lt;code&gt;NULL&lt;/code&gt; 的&lt;em&gt;D型&lt;/em&gt;和保证阵列notswapped然后使用&lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt; &lt;code&gt;PyArray_CheckFromAny&lt;/code&gt; &lt;/a&gt;。任一深度参数的值0都会导致忽略该参数。可以添加以下任何数组标志（&lt;em&gt;例如，&lt;/em&gt;使用|）以获取&lt;em&gt;需求&lt;/em&gt;参数。如果您的代码可以处理常规代码（&lt;em&gt;例如，&lt;/em&gt;跨步，字节交换或未对齐的数组），则&lt;em&gt;要求&lt;/em&gt;可能为0。此外，如果&lt;em&gt;op&lt;/em&gt;还不是数组（或不公开数组接口），则将创建一个新数组（并使用序列协议从&lt;em&gt;op&lt;/em&gt;填充）。新数组将以&lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; &lt;/a&gt;作为其flags成员。的&lt;em&gt;上下文&lt;/em&gt;参数被传递给&lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;的方法&lt;em&gt;运算&lt;/em&gt;，如果该阵列被构造这种方式仅使用。这个参数几乎总是 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ec8c6b5a6fa5ea604ca73fde0faa7f48e61f60d" translate="yes" xml:space="preserve">
          <source>This is the masked array version of &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt;. For details see &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt;的掩码数组版本。有关详细信息，请参见&lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5b5fdafede3bb67234ee18c22a5b997e8095961" translate="yes" xml:space="preserve">
          <source>This is the masked array version of &lt;code&gt;lib.index_tricks.RClass&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;lib.index_tricks.RClass&lt;/code&gt; 的掩码数组版本。</target>
        </trans-unit>
        <trans-unit id="bf3cf3ae9cebee8b7306a5e44915e23de00facf1" translate="yes" xml:space="preserve">
          <source>This is the masked equivalent of the &lt;a href=&quot;numpy.resize#numpy.resize&quot;&gt;&lt;code&gt;numpy.resize&lt;/code&gt;&lt;/a&gt; function. The new array is filled with repeated copies of &lt;code&gt;x&lt;/code&gt; (in the order that the data are stored in memory). If &lt;code&gt;x&lt;/code&gt; is masked, the new array will be masked, and the new mask will be a repetition of the old one.</source>
          <target state="translated">这是&lt;a href=&quot;numpy.resize#numpy.resize&quot;&gt; &lt;code&gt;numpy.resize&lt;/code&gt; &lt;/a&gt;函数的掩码等效项。新数组中填充了 &lt;code&gt;x&lt;/code&gt; 的重复副本（以数据存储在内存中的顺序）。如果 &lt;code&gt;x&lt;/code&gt; 被屏蔽，新的数组将被屏蔽，新的掩码将是旧数组的重复。</target>
        </trans-unit>
        <trans-unit id="e638e46153cb5bd9d2b2cfadb202d5a4f7f60071" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;ndarray.all&lt;/code&gt;&lt;/a&gt;, but it returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;ndarray.all&lt;/code&gt; &lt;/a&gt;相同，但是它返回一个&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="b28c44c91a00424416f03ba6b4985acf74627eb2" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt; would return an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; &lt;/a&gt;相同，但是返回一个&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象，其中&lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; &lt;/a&gt;将返回一个&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22b8e33a3b4d40024b90c85a13a94be90c9158a1" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt; would return an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; &lt;/a&gt;相同，但是返回一个&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象，其中&lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; &lt;/a&gt;将返回一个&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1090f814c7b352e9c36a05ce2322d963cddbde3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt; would return an ndarray.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; &lt;/a&gt;相同，但是返回一个&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象，其中&lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; &lt;/a&gt;将返回一个ndarray。</target>
        </trans-unit>
        <trans-unit id="74e44d918d1f15516605ec010845ff539cc17530" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt; would return an ndarray.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; &lt;/a&gt;相同，但是返回一个&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象，其中&lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; &lt;/a&gt;将返回一个ndarray。</target>
        </trans-unit>
        <trans-unit id="124e720446d4f3612122d427a64991837042df14" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.std#numpy.ndarray.std&quot;&gt;&lt;code&gt;ndarray.std&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.std#numpy.ndarray.std&quot;&gt; &lt;code&gt;ndarray.std&lt;/code&gt; &lt;/a&gt;相同，除了返回&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 的&lt;/a&gt;地方是返回&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="a0acdb03a11a0405720f9b33ec10bd3e67d6e4fa" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt;&lt;code&gt;ndarray.sum&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt; &lt;code&gt;ndarray.sum&lt;/code&gt; &lt;/a&gt;相同，除了返回&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 的&lt;/a&gt;地方是返回&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="1b894bff66f53b91713c65daaeb95b50cb72fdfc" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.var#numpy.ndarray.var&quot;&gt;&lt;code&gt;ndarray.var&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.var#numpy.ndarray.var&quot;&gt; &lt;code&gt;ndarray.var&lt;/code&gt; &lt;/a&gt;相同，除了返回&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 的&lt;/a&gt;地方是返回&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="d6c0a4b3ef29201f690f9b9b88a69b8608d63748" translate="yes" xml:space="preserve">
          <source>This is the same for half-precision float as npy_nextafter and npy_nextafterf described in the low-level floating point section.</source>
          <target state="translated">这与低级浮点部分描述的npy_nextafter和npy_nextafterf对半精度浮点来说是一样的。</target>
        </trans-unit>
        <trans-unit id="5a28a11e64cd4476f1fd45344cb04aff7bece602" translate="yes" xml:space="preserve">
          <source>This is the same for half-precision float as npy_spacing and npy_spacingf described in the low-level floating point section.</source>
          <target state="translated">这与低级浮点部分描述的npy_spacing和npy_spacingf对于半精度浮点是一样的。</target>
        </trans-unit>
        <trans-unit id="69592e67862b42a94f582425221058b3b2e662f2" translate="yes" xml:space="preserve">
          <source>This is the same polynomial as obtained by:</source>
          <target state="translated">这与下列方法得到的多项式相同:</target>
        </trans-unit>
        <trans-unit id="8f841f69094513c4d7f4558bcdd113fb62e5f1f7" translate="yes" xml:space="preserve">
          <source>This is the simplest case of all. The ufunc is executed by calling the underlying 1-D loop exactly once. This is possible only when we have aligned data of the correct type (including byte-order) for both input and output and all arrays have uniform strides (either contiguous, 0-D, or 1-D). In this case, the 1-D computational loop is called once to compute the calculation for the entire array. Note that the hardware error flags are only checked after the entire calculation is complete.</source>
          <target state="translated">这是最简单的情况。ufunc通过调用底层的1-D循环精确地执行一次。只有当我们的输入和输出都有正确类型的对齐数据(包括字节顺序),并且所有的数组都有统一的步长(连续、0-D或1-D)时,这才是可能的。在这种情况下,1-D计算循环会被调用一次来计算整个数组的计算。需要注意的是,只有在整个计算完成后才会检查硬件错误标志。</target>
        </trans-unit>
        <trans-unit id="963cd66868f04208a7a1c2183e363716e0ef0cf2" translate="yes" xml:space="preserve">
          <source>This is the type which exposes the iterator to Python. Currently, no API is exposed which provides access to the values of a Python-created iterator. If an iterator is created in Python, it must be used in Python and vice versa. Such an API will likely be created in a future version.</source>
          <target state="translated">这是一个向 Python 公开迭代器的类型。目前,还没有暴露出任何 API 来提供对 Python 创建的迭代器值的访问。如果一个迭代器是在 Python 中创建的,那么它必须在 Python 中使用,反之亦然。这样的 API 可能会在未来的版本中被创建。</target>
        </trans-unit>
        <trans-unit id="4b42439256132aabca2f53b261c973f7c679d369" translate="yes" xml:space="preserve">
          <source>This is useful for setting up an accumulation loop, for example. The iterator can first be created with all the dimensions, including the accumulation axis, so that the output gets created correctly. Then, the accumulation axis can be removed, and the calculation done in a nested fashion.</source>
          <target state="translated">例如,这对于设置一个累积循环很有用。迭代器可以首先创建所有的维度,包括累加轴,以便正确创建输出。然后,累积轴可以被移除,并以嵌套的方式进行计算。</target>
        </trans-unit>
        <trans-unit id="5300cb088270de52a08527e24f73ff59ea30c2bb" translate="yes" xml:space="preserve">
          <source>This is useful in a setup.py script for adding sub-packages to a package.</source>
          <target state="translated">这在setup.py脚本中很有用,可以将子包添加到一个包中。</target>
        </trans-unit>
        <trans-unit id="82959a96175cd052449eddf58c5c4610e0b21bd3" translate="yes" xml:space="preserve">
          <source>This iterates over matching 1d slices oriented along the specified axis in the index and data arrays, and uses the former to look up values in the latter. These slices can be different lengths.</source>
          <target state="translated">它迭代索引和数据数组中沿指定轴方向的匹配的1d切片,并使用前者查找后者中的值。这些切片可以是不同的长度。</target>
        </trans-unit>
        <trans-unit id="5c175a7e11a936be20457fa33dc8778b062c8741" translate="yes" xml:space="preserve">
          <source>This iterates over matching 1d slices oriented along the specified axis in the index and data arrays, and uses the former to place values into the latter. These slices can be different lengths.</source>
          <target state="translated">它迭代索引和数据数组中沿指定轴方向的匹配的1d切片,并使用前者将值放入后者。这些切片可以是不同的长度。</target>
        </trans-unit>
        <trans-unit id="1d9086a3e8f6e523e455adb859a4bc6cbea3019a" translate="yes" xml:space="preserve">
          <source>This iterator returns elements of the array to be iterated over in &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt;&lt;code&gt;Arrayterator&lt;/code&gt;&lt;/a&gt; one by one. It is similar to &lt;code&gt;flatiter&lt;/code&gt;.</source>
          <target state="translated">此迭代器返回要在&lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt; &lt;code&gt;Arrayterator&lt;/code&gt; 中&lt;/a&gt;一一进行迭代的数组元素。它类似于 &lt;code&gt;flatiter&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9621dd1cff206294072ec88c5bdff12776a1ac23" translate="yes" xml:space="preserve">
          <source>This just returns the value &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; changes whenever a backward incompatible change at the ABI level. Because it is in the C-API, however, comparing the output of this function from the value defined in the current header gives a way to test if the C-API has changed thus requiring a re-compilation of extension modules that use the C-API. This is automatically checked in the function &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这仅返回值&lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt;。只要在ABI级别上向后不兼容更改，&lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt;就会更改。由于它在C-API中，因此，将此函数的输出与当前标头中定义的值进行比较，可以测试C-API是否已更改，因此需要重新编译使用C的扩展模块。 -API。这是在函数&lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; 中&lt;/a&gt;自动检查的。</target>
        </trans-unit>
        <trans-unit id="75e16e673218df8f16a0a1029a429a437c420b9d" translate="yes" xml:space="preserve">
          <source>This just returns the value &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt;. &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; changes whenever the API changes (e.g. a function is added). A changed value does not always require a recompile.</source>
          <target state="translated">这只是返回值 &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; 。每当API更改（例如，添加功能）时， &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; 都会更改。更改的值并不总是需要重新编译。</target>
        </trans-unit>
        <trans-unit id="57131d2cbf8754e0c0045e65c405a8ff98703b38" translate="yes" xml:space="preserve">
          <source>This macro is defined to +inf.</source>
          <target state="translated">此宏定义为+inf。</target>
        </trans-unit>
        <trans-unit id="8ca63ad5bc4e1dded64f0ca2a056ab5d5c7f090f" translate="yes" xml:space="preserve">
          <source>This macro is defined to -1.0.</source>
          <target state="translated">此宏定义为-1.0。</target>
        </trans-unit>
        <trans-unit id="b30ee77ae33429489972a6d1172613ede0e766a9" translate="yes" xml:space="preserve">
          <source>This macro is defined to -inf.</source>
          <target state="translated">此宏定义为-inf。</target>
        </trans-unit>
        <trans-unit id="b8842c8583817136af82824b8e5fdbb3f9c76f6e" translate="yes" xml:space="preserve">
          <source>This macro is defined to 1.0.</source>
          <target state="translated">该宏定义为1.0。</target>
        </trans-unit>
        <trans-unit id="bd01732ce89574cb085cbbd769f60ac683ce37ab" translate="yes" xml:space="preserve">
          <source>This macro is defined to a NaN (Not a Number), and is guaranteed to have the signbit unset (&amp;lsquo;positive&amp;rsquo; NaN). The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">此宏定义为NaN（非数字），并确保未设置符号位（&amp;ldquo;正&amp;rdquo; NaN）。带有后缀F和L的是相应的单精度和扩展精度宏。</target>
        </trans-unit>
        <trans-unit id="305a7f44534276994ed187e38461a42eaeb6b275" translate="yes" xml:space="preserve">
          <source>This macro is defined to a NaN value, guaranteed to have its sign bit unset.</source>
          <target state="translated">该宏定义为NaN值,保证其符号位不被设置。</target>
        </trans-unit>
        <trans-unit id="15a2136199da842d310792facc84af7246036426" translate="yes" xml:space="preserve">
          <source>This macro is defined to a positive inf. The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">该宏定义为正向的信息。相应的单精度宏和扩展精度宏的后缀为F和L。</target>
        </trans-unit>
        <trans-unit id="c5ea17d1f0932fffe7fa9472293549c952ff5b71" translate="yes" xml:space="preserve">
          <source>This macro is defined to negative zero (that is with the sign bit set). The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">该宏定义为负零(即设置了符号位)。相应的单精度和扩展精度宏的后缀为F和L。</target>
        </trans-unit>
        <trans-unit id="28ffbdfd1fb5a238c0e6b132bd7b25e886a8862b" translate="yes" xml:space="preserve">
          <source>This macro is defined to negative zero.</source>
          <target state="translated">此宏定义为负零。</target>
        </trans-unit>
        <trans-unit id="6499719d1e23e1af1e93848438b61bc7bf9fb167" translate="yes" xml:space="preserve">
          <source>This macro is defined to positive zero.</source>
          <target state="translated">此宏定义为正零。</target>
        </trans-unit>
        <trans-unit id="c804fcf19685f98f19d42c1dc7c110945817d41e" translate="yes" xml:space="preserve">
          <source>This macro is defined to positive zero. The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">此宏定义为正零。相应的单精度和扩展精度宏都可以用后缀F和L来表示。</target>
        </trans-unit>
        <trans-unit id="c451240677ff61c1a609e49bd0f07f461a99c611" translate="yes" xml:space="preserve">
          <source>This may be used when you want to match up operand axes in some fashion, then remove them with &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; to handle their processing manually. By calling this function before removing the axes, you can get the strides for the manual processing.</source>
          <target state="translated">当您想以某种方式匹配操作数轴，然后使用 &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; 删除它们以手动处理它们时，可以使用此方法。通过在拆下轴之前调用此函数，您可以大步进行手动处理。</target>
        </trans-unit>
        <trans-unit id="85b5c517a58e8aeec834229928a8cecac10d6dff" translate="yes" xml:space="preserve">
          <source>This member allows array objects to have weak references (using the weakref module).</source>
          <target state="translated">该成员允许数组对象拥有弱引用(使用弱引用模块)。</target>
        </trans-unit>
        <trans-unit id="ed18bc4ba4db4fad433f89f2b494c6f4723892b5" translate="yes" xml:space="preserve">
          <source>This member is used to hold a pointer to another Python object that is related to this array. There are two use cases:</source>
          <target state="translated">该成员用于持有指向与该数组相关的另一个 Python 对象的指针。有两个用例。</target>
        </trans-unit>
        <trans-unit id="9d7f481ab5f8b1d226ed9ed47a9904d6a830df77" translate="yes" xml:space="preserve">
          <source>This member points to an element in the ndarray indicated by the index.</source>
          <target state="translated">该成员指向索引所指的ndarray中的一个元素。</target>
        </trans-unit>
        <trans-unit id="74643da87d06b0da62bc7a9a046a5adf218ab99e" translate="yes" xml:space="preserve">
          <source>This method directly exposes the the raw underlying pseudo-random number generator. All values are returned as unsigned 64-bit values irrespective of the number of bits produced by the PRNG.</source>
          <target state="translated">这个方法直接暴露了原始的底层伪随机数生成器,所有的值都以无符号64位的方式返回,而不管PRNG生成的位数是多少。无论PRNG产生的位数是多少,所有的值都以无符号64位值返回。</target>
        </trans-unit>
        <trans-unit id="d818e6497cca20e6d8e8f1bc817ba9a89c8a342e" translate="yes" xml:space="preserve">
          <source>This method does nothing, except raise a ValueError exception. A masked array does not own its data and therefore cannot safely be resized in place. Use the &lt;a href=&quot;numpy.ma.resize#numpy.ma.resize&quot;&gt;&lt;code&gt;numpy.ma.resize&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">此方法不执行任何操作，除了引发ValueError异常。掩码数组不拥有其数据，因此无法安全地在适当位置调整大小。请改用&lt;a href=&quot;numpy.ma.resize#numpy.ma.resize&quot;&gt; &lt;code&gt;numpy.ma.resize&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="f55c9dffed1c2a6b5a2a9bf81f22b788e98f67b4" translate="yes" xml:space="preserve">
          <source>This method is called whenever the system internally allocates a new array from &lt;em&gt;obj&lt;/em&gt;, where &lt;em&gt;obj&lt;/em&gt; is a subclass (subtype) of the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. It can be used to change attributes of &lt;em&gt;self&lt;/em&gt; after construction (so as to ensure a 2-d matrix for example), or to update meta-information from the &amp;ldquo;parent.&amp;rdquo; Subclasses inherit a default implementation of this method that does nothing.</source>
          <target state="translated">每当系统内部从&lt;em&gt;obj&lt;/em&gt;分配新数组时，都会调用此方法，其中&lt;em&gt;obj&lt;/em&gt;是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;的子类（子类型）。它可用于在构造后更改&lt;em&gt;self的&lt;/em&gt;属性（例如，以确保二维矩阵），或用于更新&amp;ldquo;父级&amp;rdquo;的元信息。子类继承此方法的默认实现，该实现不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="5957d72b0ca4a0dc20466e5e727abd34e77443e1" translate="yes" xml:space="preserve">
          <source>This method is difficult to implement safely and may be deprecated in future releases of NumPy.</source>
          <target state="translated">这个方法很难安全地实现,在未来的NumPy版本中可能会被废弃。</target>
        </trans-unit>
        <trans-unit id="7aaa9616f6dcdd0184bee8a152bd13d1e550b310" translate="yes" xml:space="preserve">
          <source>This method is for backward compatibility only: do not use.</source>
          <target state="translated">此方法仅用于向后兼容:不要使用。</target>
        </trans-unit>
        <trans-unit id="83e657ddca83d2881d8a63d1d77710e25b3d7e94" translate="yes" xml:space="preserve">
          <source>This method scans files named __version__.py, &amp;lt;packagename&amp;gt;_version.py, version.py, and __svn_version__.py for string variables version, __version__, and &amp;lt;packagename&amp;gt;_version, until a version number is found.</source>
          <target state="translated">此方法扫描名为__version __。py，&amp;lt;packagename&amp;gt; _version.py，version.py和__svn_version__.py的文件中的字符串变量version，__ version__和&amp;lt;packagename&amp;gt; _version，直到找到版本号。</target>
        </trans-unit>
        <trans-unit id="f89805770623a7cfcc87bb87063713e7dd822816" translate="yes" xml:space="preserve">
          <source>This module contains all functions in the &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; namespace, with the following replacement functions that return &lt;a href=&quot;generated/numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrices&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该模块包含&lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt;名称空间中的所有函数，以及以下替换函数，这些函数返回&lt;a href=&quot;generated/numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrices&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="265d65d83193df044b48a623f0d3f0dda63b008d" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Chebyshev series, including a &lt;a href=&quot;generated/numpy.polynomial.chebyshev.chebyshev#numpy.polynomial.chebyshev.Chebyshev&quot;&gt;&lt;code&gt;Chebyshev&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多用于处理Chebyshev系列的对象（主要是函数），包括封装常规算术运算的&lt;a href=&quot;generated/numpy.polynomial.chebyshev.chebyshev#numpy.polynomial.chebyshev.Chebyshev&quot;&gt; &lt;code&gt;Chebyshev&lt;/code&gt; &lt;/a&gt;类。（有关此模块如何表示和使用此类多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; &amp;ldquo;父&amp;rdquo;子包numpy.polynomial的文档字符串中）。</target>
        </trans-unit>
        <trans-unit id="e0c12fd4ebad36a4626d24020b78132a2c170962" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Hermite series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite.hermite#numpy.polynomial.hermite.Hermite&quot;&gt;&lt;code&gt;Hermite&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多用于处理Hermite系列的对象（主要是函数），包括封装常规算术运算的&lt;a href=&quot;generated/numpy.polynomial.hermite.hermite#numpy.polynomial.hermite.Hermite&quot;&gt; &lt;code&gt;Hermite&lt;/code&gt; &lt;/a&gt;类。 （有关此模块如何表示和使用这些多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; &amp;ldquo;父&amp;rdquo;子程序包numpy.polynomial的文档字符串）。</target>
        </trans-unit>
        <trans-unit id="009a1c885b932c48bc61dd45e0e34c3c31b1f286" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with HermiteE series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt;&lt;code&gt;HermiteE&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多对象（主要是函数），可用于处理HermiteE系列，包括封装常规算术运算的&lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt; &lt;code&gt;HermiteE&lt;/code&gt; &lt;/a&gt;类。（有关此模块如何表示和使用此类多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; &amp;ldquo;父&amp;rdquo;子包numpy.polynomial的文档字符串中）。</target>
        </trans-unit>
        <trans-unit id="0d0299f154387dc04b7a01cfe822909405b30805" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Laguerre series, including a &lt;a href=&quot;generated/numpy.polynomial.laguerre.laguerre#numpy.polynomial.laguerre.Laguerre&quot;&gt;&lt;code&gt;Laguerre&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多对象（主要是函数），可用于处理Laguerre系列，包括封装了常规算术运算的&lt;a href=&quot;generated/numpy.polynomial.laguerre.laguerre#numpy.polynomial.laguerre.Laguerre&quot;&gt; &lt;code&gt;Laguerre&lt;/code&gt; &lt;/a&gt;类。（有关此模块如何表示和使用此类多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; &amp;ldquo;父&amp;rdquo;子包numpy.polynomial的文档字符串中）。</target>
        </trans-unit>
        <trans-unit id="97167a7dd7012c05d960d350608d944b8fc4844a" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Legendre series, including a &lt;a href=&quot;generated/numpy.polynomial.legendre.legendre#numpy.polynomial.legendre.Legendre&quot;&gt;&lt;code&gt;Legendre&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多用于处理Legendre系列的对象（主要是函数），包括封装常规算术运算的&lt;a href=&quot;generated/numpy.polynomial.legendre.legendre#numpy.polynomial.legendre.Legendre&quot;&gt; &lt;code&gt;Legendre&lt;/code&gt; &lt;/a&gt;类。（有关此模块如何表示和使用这些多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; &amp;ldquo;父&amp;rdquo;子包numpy.polynomial的文档字符串中）。</target>
        </trans-unit>
        <trans-unit id="27218660297bbc1672326aa7fc0091aba0aa4b36" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Polynomial series, including a &lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt;&lt;code&gt;Polynomial&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多用于处理多项式系列的对象（主要是函数），包括封装了常用算术运算的&lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt; &lt;code&gt;Polynomial&lt;/code&gt; &lt;/a&gt;类。（有关此模块如何表示和使用这些多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; &amp;ldquo;父&amp;rdquo;子包numpy.polynomial的文档字符串中）。</target>
        </trans-unit>
        <trans-unit id="6505e2a54b4c90d04c624c70346ad867092f98b2" translate="yes" xml:space="preserve">
          <source>This module provides: error and warning objects; a polynomial base class; and some routines used in both the &lt;code&gt;polynomial&lt;/code&gt; and &lt;code&gt;chebyshev&lt;/code&gt; modules.</source>
          <target state="translated">该模块提供：错误和警告对象；多项式基类；以及在 &lt;code&gt;polynomial&lt;/code&gt; 和 &lt;code&gt;chebyshev&lt;/code&gt; 模块中使用的一些例程。</target>
        </trans-unit>
        <trans-unit id="6f02b8e116f7a7bed4ba561da0ffe80943392202" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Chebyshev series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">该模块表示 &lt;code&gt;off + scl*x&lt;/code&gt; 的Chebyshev系列的。</target>
        </trans-unit>
        <trans-unit id="a628eacd0f4bb9dd57ff71e63c578eed78e261b5" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Hermite series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">此模块代表 &lt;code&gt;off + scl*x&lt;/code&gt; 的Hermite系列。</target>
        </trans-unit>
        <trans-unit id="9ab2b6eda8208cc86132d50e5e53a2cf2e15859d" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Laguerre series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">此模块代表 &lt;code&gt;off + scl*x&lt;/code&gt; 的Laguerre系列。</target>
        </trans-unit>
        <trans-unit id="23eb81bc9bb7a5f0cbd08a18f3b739c712c791cf" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Legendre series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">此模块代表 &lt;code&gt;off + scl*x&lt;/code&gt; 的Legendre系列。</target>
        </trans-unit>
        <trans-unit id="d92e37a5c688f24c68244c7cd58f9c4410908a50" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the linear polynomial &lt;code&gt;off +
scl*x&lt;/code&gt;.</source>
          <target state="translated">此模块表示线性多项式 &lt;code&gt;off + scl*x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eaa2fd8c1567b66e551b17269b1ebbbc61f96243" translate="yes" xml:space="preserve">
          <source>This only affects the iterator when &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is specified for the order parameter. By default with &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, the iterator reverses axes which have negative strides, so that memory is traversed in a forward direction. This disables this step. Use this flag if you want to use the underlying memory-ordering of the axes, but don&amp;rsquo;t want an axis reversed. This is the behavior of &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt;, for instance.</source>
          <target state="translated">仅当为order参数指定&lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt;时，这才影响迭代器。默认情况下，使用&lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt;，迭代器反转具有负步幅的轴，以便沿正向遍历内存。这将禁用此步骤。如果要使用轴的基础内存顺序，但不希望轴反转，请使用此标志。例如，这就是 &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt; 的行为。</target>
        </trans-unit>
        <trans-unit id="ae6b1796953475091b5cdaeb39e4d7e996e315e6" translate="yes" xml:space="preserve">
          <source>This optional parameter specifies the interpolation method to use when the desired percentile lies between two data points &lt;code&gt;i &amp;lt; j&lt;/code&gt;:</source>
          <target state="translated">此可选参数指定当所需百分比位于两个数据点 &lt;code&gt;i &amp;lt; j&lt;/code&gt; 之间时要使用的插值方法：</target>
        </trans-unit>
        <trans-unit id="002fb17667dbbd628eca51b6e4ff99f2217649e0" translate="yes" xml:space="preserve">
          <source>This optional parameter specifies the interpolation method to use when the desired quantile lies between two data points &lt;code&gt;i &amp;lt; j&lt;/code&gt;:</source>
          <target state="translated">此可选参数指定当所需分位数位于两个数据点 &lt;code&gt;i &amp;lt; j&lt;/code&gt; 之间时要使用的插值方法：</target>
        </trans-unit>
        <trans-unit id="c342edf9966c2e18280c4d355db707b32be4bff5" translate="yes" xml:space="preserve">
          <source>This package was developed independently of NumPy and was integrated in version 1.17.0. The original repo is at &lt;a href=&quot;https://github.com/bashtage/randomgen&quot;&gt;https://github.com/bashtage/randomgen&lt;/a&gt;.</source>
          <target state="translated">该软件包独立于NumPy开发，并已集成到1.17.0版中。原始存储库位于&lt;a href=&quot;https://github.com/bashtage/randomgen&quot;&gt;https://github.com/bashtage/randomgen&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c427139240278bee81f47cf48768438afbe39755" translate="yes" xml:space="preserve">
          <source>This page describes the numpy-specific API for accessing the contents of a numpy array from other C extensions. &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; &amp;ndash; &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#c.PyObject_GetBuffer&quot;&gt;&lt;code&gt;The Revised Buffer Protocol&lt;/code&gt;&lt;/a&gt; introduces similar, standardized API to Python 2.6 and 3.0 for any extension module to use. &lt;a href=&quot;http://cython.org/&quot;&gt;Cython&lt;/a&gt;&amp;rsquo;s buffer array support uses the &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; API; see the &lt;a href=&quot;https://github.com/cython/cython/wiki/tutorials-numpy&quot;&gt;Cython numpy tutorial&lt;/a&gt;. Cython provides a way to write code that supports the buffer protocol with Python versions older than 2.6 because it has a backward-compatible implementation utilizing the array interface described here.</source>
          <target state="translated">此页面描述了特定于numpy的API，用于从其他C扩展访问numpy数组的内容。&lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; &amp;ndash; &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#c.PyObject_GetBuffer&quot;&gt; &lt;code&gt;The Revised Buffer Protocol&lt;/code&gt; &lt;/a&gt;为Python 2.6和3.0引入了类似的标准化API，供任何扩展模块使用。&lt;a href=&quot;http://cython.org/&quot;&gt;Cython&lt;/a&gt;的缓冲阵列支持使用&lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; API；请参见&lt;a href=&quot;https://github.com/cython/cython/wiki/tutorials-numpy&quot;&gt;Cython numpy教程&lt;/a&gt;。Cython提供了一种方法来编写支持2.6版以上Python版本的缓冲区协议的代码，因为它具有使用此处描述的数组接口向后兼容的实现。</target>
        </trans-unit>
        <trans-unit id="4df30a5dfa3e83d5a58c4b3babfef2e8f4555a00" translate="yes" xml:space="preserve">
          <source>This page documents the API for the iterator. The iterator is named &lt;code&gt;NpyIter&lt;/code&gt; and functions are named &lt;code&gt;NpyIter_*&lt;/code&gt;.</source>
          <target state="translated">此页面记录了迭代器的API。迭代器名为 &lt;code&gt;NpyIter&lt;/code&gt; ，函数名为 &lt;code&gt;NpyIter_*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b79e823ebc32815d2b3460b90e34d0a2f9bed7dc" translate="yes" xml:space="preserve">
          <source>This pointer may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it.</source>
          <target state="translated">该指针可能在迭代循环之前被缓存，调用 &lt;code&gt;iternext&lt;/code&gt; 不会更改它。</target>
        </trans-unit>
        <trans-unit id="484a465c1e928c7fbd45d4d74c7fee12a21c59d4" translate="yes" xml:space="preserve">
          <source>This pointer may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it. This function may be safely called without holding the Python GIL.</source>
          <target state="translated">该指针可能在迭代循环之前被缓存，调用 &lt;code&gt;iternext&lt;/code&gt; 不会更改它。无需持有Python GIL即可安全地调用此函数。</target>
        </trans-unit>
        <trans-unit id="af7b379b2fcb530df7b5c66e85d1051773a408df" translate="yes" xml:space="preserve">
          <source>This property is a view on the imaginary part of this &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此属性是此&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;的虚部的视图。</target>
        </trans-unit>
        <trans-unit id="9c2a714f693725c88c94ac2607ed6abee0322d99" translate="yes" xml:space="preserve">
          <source>This property is a view on the real part of this &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此属性是此&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;实际部分的视图。</target>
        </trans-unit>
        <trans-unit id="56ae11e0e5ca2982f115765c5eb4aa5c0c2cf88d" translate="yes" xml:space="preserve">
          <source>This reallocates space for the data area if necessary.</source>
          <target state="translated">必要时,这将重新分配数据区域的空间。</target>
        </trans-unit>
        <trans-unit id="3875a2efa104b3c26f06d6992550d8f8f4acd93f" translate="yes" xml:space="preserve">
          <source>This reference manual details functions, modules, and objects included in NumPy, describing what they are and what they do. For learning how to use NumPy, see also &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/index.html#user&quot;&gt;NumPy User Guide&lt;/a&gt;.</source>
          <target state="translated">该参考手册详细介绍了NumPy中包含的功能，模块和对象，描述了它们的功能和作用。有关学习如何使用NumPy的信息，另请参阅《&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/index.html#user&quot;&gt;NumPy用户指南》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="49d7d34fc7b59b4f57a8fc699678974df3138f8f" translate="yes" xml:space="preserve">
          <source>This returns a tuple of indices that can be used to access the main diagonal of an array &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; dimensions and shape (n, n, &amp;hellip;, n). For &lt;code&gt;a.ndim = 2&lt;/code&gt; this is the usual diagonal, for &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; this is the set of indices to access &lt;code&gt;a[i, i, ..., i]&lt;/code&gt; for &lt;code&gt;i = [0..n-1]&lt;/code&gt;.</source>
          <target state="translated">这将返回可以用于访问阵列的主对角线索引的元组 &lt;code&gt;a&lt;/code&gt; 与 &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; 的尺寸和形状（N，N，...，N）。对于 &lt;code&gt;a.ndim = 2&lt;/code&gt; ，这是通常的对角线，用于 &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; 这是组索引访问 &lt;code&gt;a[i, i, ..., i]&lt;/code&gt; 为 &lt;code&gt;i = [0..n-1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="445408c5f27be1f1d331536d4e933a74a8f78cb0" translate="yes" xml:space="preserve">
          <source>This returns the base object of the array. In most cases, this means the object which owns the memory the array is pointing at.</source>
          <target state="translated">这将返回数组的基础对象。在大多数情况下,这意味着拥有数组指向的内存的对象。</target>
        </trans-unit>
        <trans-unit id="a52ed8eb1e1cedf938d67a58ab208207008af6c7" translate="yes" xml:space="preserve">
          <source>This routine succeeds where ordinary &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt; does not:</source>
          <target state="translated">该例程在普通&lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;无法执行的情况下成功执行：</target>
        </trans-unit>
        <trans-unit id="eb7064b0e5d0b37eaed95ef4ac40f47e88476c2d" translate="yes" xml:space="preserve">
          <source>This scheme does require that you avoid reusing stream IDs. This may require coordination between the parallel processes.</source>
          <target state="translated">这个方案确实要求你避免重复使用流ID。这可能需要并行进程之间的协调。</target>
        </trans-unit>
        <trans-unit id="d2295424cf2146c8c588e01472068b4499bd8664" translate="yes" xml:space="preserve">
          <source>This section describes how the basic universal function computation loop is setup and executed for each of the three different kinds of execution. If &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined during compilation, then as long as no object arrays are involved, the Python Global Interpreter Lock (GIL) is released prior to calling the loops. It is re-acquired if necessary to handle error conditions. The hardware error flags are checked only after the 1-D loop is completed.</source>
          <target state="translated">本节描述了如何为三种不同类型的执行中的每种执行建立和执行基本的通用函数计算循环。如果在编译期间定义了 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; ，则只要不涉及对象数组，就在调用循环之前释放Python全局解释器锁（GIL）。如有必要，可以重新获取它以处理错误情况。仅在完成一维循环后才检查硬件错误标志。</target>
        </trans-unit>
        <trans-unit id="af85e32a0a54092009ceae627c9327451013292e" translate="yes" xml:space="preserve">
          <source>This should not be confused with:</source>
          <target state="translated">这不应与以下情况混淆:</target>
        </trans-unit>
        <trans-unit id="281bd1fc18f2200e68ef811b640b0f24111b0170" translate="yes" xml:space="preserve">
          <source>This simply has the effect of switching the definitions of &lt;code&gt;arg1&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt; in lines 3 and 4 of the generated code above, and their assignments in lines 19 and 20.</source>
          <target state="translated">这只是在上面生成的代码的第3行和第4行中切换 &lt;code&gt;arg1&lt;/code&gt; 和 &lt;code&gt;arg2&lt;/code&gt; 的定义以及在第19行和第20行中分配它们的作用。</target>
        </trans-unit>
        <trans-unit id="d5f0ce6428ed7ce9a3f007ac820d6ad83fbe35d9" translate="yes" xml:space="preserve">
          <source>This single module should provide all the common functionality for numpy tests in a single location, so that &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/dev/development_environment.html#development-environment&quot;&gt;test scripts&lt;/a&gt; can just import it and work right away. For background, see the &lt;a href=&quot;testing#testing-guidelines&quot;&gt;Testing Guidelines&lt;/a&gt;</source>
          <target state="translated">这个模块应该在一个位置为numpy测试提供所有通用功能，以便&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/dev/development_environment.html#development-environment&quot;&gt;测试脚本&lt;/a&gt;可以将其导入并立即运行。有关背景，请参见&lt;a href=&quot;testing#testing-guidelines&quot;&gt;测试准则&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d96875a0b29939a3e2bb067cb066089a92949861" translate="yes" xml:space="preserve">
          <source>This structure is very useful when shape and/or strides information is supposed to be interpreted. The structure is:</source>
          <target state="translated">当需要解释形状和/或步幅信息时,这个结构非常有用。该结构是:</target>
        </trans-unit>
        <trans-unit id="f5377b9ec1ee34b1b46afca48f12d70eda083569" translate="yes" xml:space="preserve">
          <source>This style allows passing in the &lt;a href=&quot;generated/numpy.dtype.fields#numpy.dtype.fields&quot;&gt;&lt;code&gt;fields&lt;/code&gt;&lt;/a&gt; attribute of a data-type object.</source>
          <target state="translated">这种样式允许传入数据类型对象的&lt;a href=&quot;generated/numpy.dtype.fields#numpy.dtype.fields&quot;&gt; &lt;code&gt;fields&lt;/code&gt; &lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="8baa5c3fa91f9d82d5f372676363ca92358b6704" translate="yes" xml:space="preserve">
          <source>This style does not accept &lt;em&gt;align&lt;/em&gt; in the &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; constructor as it is assumed that all of the memory is accounted for by the array interface description.</source>
          <target state="translated">此样式在&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;构造函数中不接受&lt;em&gt;align&lt;/em&gt;，因为假定所有内存均由数组接口描述解决。</target>
        </trans-unit>
        <trans-unit id="63b067d6a5e8e9587ae90576ba34210d81e53f6b" translate="yes" xml:space="preserve">
          <source>This style has two required and three optional keys. The &lt;em&gt;names&lt;/em&gt; and &lt;em&gt;formats&lt;/em&gt; keys are required. Their respective values are equal-length lists with the field names and the field formats. The field names must be strings and the field formats can be any object accepted by &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">此样式具有两个必需键和三个可选键。该&lt;em&gt;名称&lt;/em&gt;和&lt;em&gt;格式&lt;/em&gt;的密钥是必需的。它们各自的值是等长列表，其中包含字段名称和字段格式。字段名称必须是字符串，并且字段格式可以是&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;构造函数接受的任何对象。</target>
        </trans-unit>
        <trans-unit id="9fd39c592746d75bfe12bf10bab5bf15e715d323" translate="yes" xml:space="preserve">
          <source>This subclass of ndarray has some unpleasant interactions with some operations, because it doesn&amp;rsquo;t quite fit properly as a subclass. An alternative to using this subclass is to create the &lt;code&gt;mmap&lt;/code&gt; object yourself, then create an ndarray with ndarray.__new__ directly, passing the object created in its &amp;lsquo;buffer=&amp;rsquo; parameter.</source>
          <target state="translated">ndarray的该子类与某些操作有一些不愉快的交互，因为它不太适合作为子类。使用此子类的另一种方法是自己创建 &lt;code&gt;mmap&lt;/code&gt; 对象，然后直接使用ndarray .__ new__创建一个ndarray，并在其'buffer ='参数中传递创建的对象。</target>
        </trans-unit>
        <trans-unit id="49e089f7d3412f57a533b95b4289e1725ee616b3" translate="yes" xml:space="preserve">
          <source>This template converter will replicate all &lt;strong&gt;function&lt;/strong&gt; and &lt;strong&gt;subroutine&lt;/strong&gt; blocks in the file with names that contain &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; according to the rules in &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo;. The number of comma-separated words in &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; determines the number of times the block is repeated. What these words are indicates what that repeat rule, &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo;, should be replaced with in each block. All of the repeat rules in a block must contain the same number of comma-separated words indicating the number of times that block should be repeated. If the word in the repeat rule needs a comma, leftarrow, or rightarrow, then prepend it with a backslash &amp;lsquo; &amp;lsquo;. If a word in the repeat rule matches &amp;lsquo; \&amp;lt;index&amp;gt;&amp;rsquo; then it will be replaced with the &amp;lt;index&amp;gt;-th word in the same repeat specification. There are two forms for the repeat rule: named and short.</source>
          <target state="translated">该模板转换器将复制所有&lt;strong&gt;功能&lt;/strong&gt;和&lt;strong&gt;子例程&lt;/strong&gt;根据&amp;ldquo; &amp;lt;&amp;hellip;&amp;gt;&amp;rdquo;中的规则，使用名称包含&amp;ldquo; &amp;lt;&amp;hellip;&amp;gt;&amp;rdquo;的文件中的块。 &amp;ldquo; &amp;lt;&amp;hellip;&amp;gt;&amp;rdquo;中逗号分隔的单词数决定了该块重复的次数。这些单词表示在每个块中应将重复规则&amp;ldquo; &amp;lt;&amp;hellip;&amp;gt;&amp;rdquo;替换为什么。块中的所有重复规则必须包含相同数量的逗号分隔的单词，以指示该块应重复的次数。如果重复规则中的单词需要逗号，左箭头或右箭头，则在其前面加上反斜杠&amp;ldquo;&amp;rdquo;。如果重复规则中的单词与&amp;ldquo; \ &amp;lt;index&amp;gt;&amp;rdquo;匹配，则它将被同一重复规范中的第&amp;lt;index&amp;gt;个单词替换。重复规则有两种形式：named和short。</target>
        </trans-unit>
        <trans-unit id="f3fb6c8e0c4b1a20c93f451ff612ab566979e83c" translate="yes" xml:space="preserve">
          <source>This type provides an iterator that encapsulates the concept of broadcasting. It allows</source>
          <target state="translated">该类型提供了一个封装广播概念的迭代器。它允许</target>
        </trans-unit>
        <trans-unit id="fedc2274acc4b818673988228fa9cde0f7271aad" translate="yes" xml:space="preserve">
          <source>This usage is discouraged, because it is ambiguous with the other dict-based construction method. If you have a field called &amp;lsquo;names&amp;rsquo; and a field called &amp;lsquo;formats&amp;rsquo; there will be a conflict.</source>
          <target state="translated">不鼓励这种用法，因为它与其他基于dict的构造方法不明确。如果您有一个名为&amp;ldquo;名称&amp;rdquo;的字段和一个名为&amp;ldquo;格式&amp;rdquo;的字段，则将发生冲突。</target>
        </trans-unit>
        <trans-unit id="57872c5abdb149b7d4963cf4f155c74d4913dff4" translate="yes" xml:space="preserve">
          <source>This version replaces the ASCII string (which in practice was latin1) with a utf8-encoded string, so supports structured types with any unicode field names.</source>
          <target state="translated">这个版本用utf8编码的字符串替换了ASCII字符串(实际上是latin1),所以支持任何unicode字段名的结构化类型。</target>
        </trans-unit>
        <trans-unit id="3b6efd49b695f694142bfb54798d0f3fc1890e14" translate="yes" xml:space="preserve">
          <source>This will be a new view object if possible; otherwise, it will be a copy. Note there is no guarantee of the &lt;em&gt;memory layout&lt;/em&gt; (C- or Fortran- contiguous) of the returned array.</source>
          <target state="translated">如果可能，这将是一个新的视图对象；否则，它将是副本。注意，不能保证返回数组的&lt;em&gt;内存布局&lt;/em&gt;（C或Fortran连续）。</target>
        </trans-unit>
        <trans-unit id="8933167843c02b6efd0369f05c57b0cadbffbc22" translate="yes" xml:space="preserve">
          <source>This will install the file foo.ini into the directory package_dir/lib, and the foo.ini file will be generated from foo.ini.in, where each &lt;code&gt;@version@&lt;/code&gt; will be replaced by &lt;code&gt;subst_dict['version']&lt;/code&gt;. The dictionary has an additional prefix substitution rule automatically added, which contains the install prefix (since this is not easy to get from setup.py). npy-pkg-config files can also be installed at the same location as used for numpy, using the path returned from &lt;code&gt;get_npy_pkg_dir&lt;/code&gt; function.</source>
          <target state="translated">这会将foo.ini文件安装到package_dir / lib目录中，并且foo.ini文件将从foo.ini.in生成，其中每个 &lt;code&gt;@version@&lt;/code&gt; 都将由 &lt;code&gt;subst_dict['version']&lt;/code&gt; 替换。该词典有一个自动添加的附加前缀替换规则，其中包含安装前缀（因为从setup.py很难获得此前缀）。还可以使用 &lt;code&gt;get_npy_pkg_dir&lt;/code&gt; 函数返回的路径将npy-pkg-config文件安装在与numpy相同的位置。</target>
        </trans-unit>
        <trans-unit id="00582fa3dde2e164fba27e484b480804eaaba584" translate="yes" xml:space="preserve">
          <source>This works for both standard installs and in-place builds, i.e. the &lt;code&gt;@prefix@&lt;/code&gt; refer to the source directory for in-place builds.</source>
          <target state="translated">这适用于标准安装和就地构建，即 &lt;code&gt;@prefix@&lt;/code&gt; 指代就地构建的源目录。</target>
        </trans-unit>
        <trans-unit id="8dbc0909265236a8e2f517b68e39944b2e4da272" translate="yes" xml:space="preserve">
          <source>Those can be useful for precise floating point comparison.</source>
          <target state="translated">这些可以用于精确的浮点比较。</target>
        </trans-unit>
        <trans-unit id="ae29a3649bad434c98c44c18fb3c7ec696b132a3" translate="yes" xml:space="preserve">
          <source>Those who want really good performance out of their low level operations should strongly consider directly using the iteration API provided in C, but for those who are not comfortable with C or C++, Cython is a good middle ground with reasonable performance tradeoffs. For the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object, this means letting the iterator take care of broadcasting, dtype conversion, and buffering, while giving the inner loop to Cython.</source>
          <target state="translated">那些希望通过低级操作获得真正好的性能的人应该强烈考虑直接使用C中提供的迭代API，但是对于那些不熟悉C或C ++的人，Cython是一个很好的中间点，可以进行合理的性能折衷。对于&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;对象，这意味着让迭代器负责广播，dtype转换和缓冲，同时为Cython提供内部循环。</target>
        </trans-unit>
        <trans-unit id="35e557dff981ec6af1be9c041d1715ad421f55bd" translate="yes" xml:space="preserve">
          <source>Threading support</source>
          <target state="translated">线程支持</target>
        </trans-unit>
        <trans-unit id="2d3ac6352887bde0f838813d8ea2d7bd7a567c2f" translate="yes" xml:space="preserve">
          <source>Three common use cases are:</source>
          <target state="translated">三个常见的使用案例是:</target>
        </trans-unit>
        <trans-unit id="987f8885750fc51202cc3964c96525b26400aa8c" translate="yes" xml:space="preserve">
          <source>Three-by-two array of random numbers from [-5, 0):</source>
          <target state="translated">从[-5,0)开始的三乘二随机数组。</target>
        </trans-unit>
        <trans-unit id="648f2b8e04236f9ba0d33739777255491d46f3b0" translate="yes" xml:space="preserve">
          <source>Threshold below which SVD values are considered zero. If &lt;code&gt;tol&lt;/code&gt; is None, and &lt;code&gt;S&lt;/code&gt; is an array with singular values for &lt;code&gt;M&lt;/code&gt;, and &lt;code&gt;eps&lt;/code&gt; is the epsilon value for datatype of &lt;code&gt;S&lt;/code&gt;, then &lt;code&gt;tol&lt;/code&gt; is set to &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt;.</source>
          <target state="translated">低于该阈值的SVD值被视为零。如果 &lt;code&gt;tol&lt;/code&gt; 为None，并且 &lt;code&gt;S&lt;/code&gt; 为具有 &lt;code&gt;M&lt;/code&gt; 的奇异值的数组，并且 &lt;code&gt;eps&lt;/code&gt; 为 &lt;code&gt;S&lt;/code&gt; 的数据类型的epsilon值，则 &lt;code&gt;tol&lt;/code&gt; 设置为 &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a18ce980b9b6a0af6ba5335aa5043a3f61a2139" translate="yes" xml:space="preserve">
          <source>Throw a dice 20 times:</source>
          <target state="translated">扔一个骰子20次。</target>
        </trans-unit>
        <trans-unit id="699ce8b0c5a25495e7df7b31eb754f06f5937265" translate="yes" xml:space="preserve">
          <source>Tile an array.</source>
          <target state="translated">铺设一个阵列。</target>
        </trans-unit>
        <trans-unit id="9478b387e78ee7ed878f28def0d9d737a40db3cf" translate="yes" xml:space="preserve">
          <source>Tiling arrays</source>
          <target state="translated">平铺阵列</target>
        </trans-unit>
        <trans-unit id="ae9e32a7bf76d858a6643fb3d615f4e6b741df45" translate="yes" xml:space="preserve">
          <source>Time span (absolute)</source>
          <target state="translated">时间跨度(绝对值)</target>
        </trans-unit>
        <trans-unit id="83a0b67f984af7843f2cd5f9c4c4a4937a96b824" translate="yes" xml:space="preserve">
          <source>Time span (relative)</source>
          <target state="translated">时间跨度(相对)</target>
        </trans-unit>
        <trans-unit id="f427901653e2f16331f232b03616db8d30b0bf3e" translate="yes" xml:space="preserve">
          <source>Timedelta</source>
          <target state="translated">Timedelta</target>
        </trans-unit>
        <trans-unit id="a836f04893b4c22a5902f8a189928c3d93f72795" translate="yes" xml:space="preserve">
          <source>Timezone information to use when displaying the datetime. If &amp;lsquo;UTC&amp;rsquo;, end with a Z to indicate UTC time. If &amp;lsquo;local&amp;rsquo;, convert to the local timezone first, and suffix with a +-#### timezone offset. If a tzinfo object, then do as with &amp;lsquo;local&amp;rsquo;, but use the specified timezone.</source>
          <target state="translated">显示日期时间时要使用的时区信息。如果为&amp;ldquo; UTC&amp;rdquo;，则以Z结尾以指示UTC时间。如果为'local'，请先转换为本地时区，并以+-####时区偏移量作为后缀。如果是tzinfo对象，则使用'local'，但使用指定的时区。</target>
        </trans-unit>
        <trans-unit id="661d4063b8ec8980f63428513015c42d7d7a39d4" translate="yes" xml:space="preserve">
          <source>Timings</source>
          <target state="translated">Timings</target>
        </trans-unit>
        <trans-unit id="18696f01e06a1b84af54b40680c306637cf01d64" translate="yes" xml:space="preserve">
          <source>Timsort is added for better performance on already or nearly sorted data. On random data timsort is almost identical to mergesort. It is now used for stable sort while quicksort is still the default sort if none is chosen. For details of timsort, refer to &lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt&lt;/a&gt;. &amp;lsquo;mergesort&amp;rsquo; and &amp;lsquo;stable&amp;rsquo; are mapped to radix sort for integer data types. Radix sort is an O(n) sort instead of O(n log n).</source>
          <target state="translated">添加Timsort可以提高对已分类或已分类数据的性能。在随机数据上，timsort与mergesort几乎相同。现在，它用于稳定排序，而如果未选择，则快速排序仍是默认排序。有关timsort的详细信息，请参见&lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt&lt;/a&gt;。'mergesort'和'stable'被映射为整数数据类型的基数排序。基数排序是O（n）排序，而不是O（n log n）。</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="e96f3984eaaf637764ee32773288dabcc604bf6b" translate="yes" xml:space="preserve">
          <source>Tips &amp;amp; Tricks</source>
          <target state="translated">提示与技巧</target>
        </trans-unit>
        <trans-unit id="caa39d36bfce368de59fb6b06774c2bd179f06cf" translate="yes" xml:space="preserve">
          <source>Title case words start with uppercase characters, all remaining cased characters are lowercase.</source>
          <target state="translated">标题大小写字以大写字符开头,其余大小写字符均为小写。</target>
        </trans-unit>
        <trans-unit id="45c41172aa1c58d7ba017f081fcd4e2ace4e86f0" translate="yes" xml:space="preserve">
          <source>Title that is printed in the string representation of &lt;a href=&quot;#numpy.MachAr&quot;&gt;&lt;code&gt;MachAr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">以&lt;a href=&quot;#numpy.MachAr&quot;&gt; &lt;code&gt;MachAr&lt;/code&gt; &lt;/a&gt;的字符串表示形式打印的标题。</target>
        </trans-unit>
        <trans-unit id="20fb23c1b6aaaab924d80202c9bd41b9e867e2de" translate="yes" xml:space="preserve">
          <source>To Cython-ize this function, we replace the inner loop (y[&amp;hellip;] += x*x) with Cython code that&amp;rsquo;s specialized for the float64 dtype. With the &amp;lsquo;external_loop&amp;rsquo; flag enabled, the arrays provided to the inner loop will always be one-dimensional, so very little checking needs to be done.</source>
          <target state="translated">为了用Cython实现此功能，我们用专用于float64 dtype的Cython代码替换了内部循环（y [&amp;hellip;] + = x * x）。启用&amp;ldquo; external_loop&amp;rdquo;标志后，提供给内部循环的数组将始终是一维的，因此几乎不需要进行检查。</target>
        </trans-unit>
        <trans-unit id="36e086a6bd3eb648c4aebbd467026f4cd1c91bb0" translate="yes" xml:space="preserve">
          <source>To achieve a behaviour similar to the basic slicing above, broadcasting can be used. The function &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; can help with this broadcasting. This is best understood with an example.</source>
          <target state="translated">为了实现类似于上述基本切片的行为，可以使用广播。功能&lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt;可以帮助进行广播。最好用一个例子来理解。</target>
        </trans-unit>
        <trans-unit id="03c09cbfb1aed4718ffc26452a3968e86a1cd3bc" translate="yes" xml:space="preserve">
          <source>To allow the datetime to be used in contexts where only certain days of the week are valid, NumPy includes a set of &amp;ldquo;busday&amp;rdquo; (business day) functions.</source>
          <target state="translated">为了允许仅在一周中的某些天有效的上下文中使用日期时间，NumPy包括一组&amp;ldquo; busday&amp;rdquo;（工作日）功能。</target>
        </trans-unit>
        <trans-unit id="8941cedf9a3b3622178e2a604f85c6f9966d6beb" translate="yes" xml:space="preserve">
          <source>To create a masked array where all values close to 1.e20 are invalid, we would do:</source>
          <target state="translated">要创建一个掩码数组,所有接近1.e20的值都是无效的,我们可以这样做。</target>
        </trans-unit>
        <trans-unit id="fdf86d74a7427ac0a22c6f0a9b96d12080099d0c" translate="yes" xml:space="preserve">
          <source>To create an array with the second element invalid, we would do:</source>
          <target state="translated">要创建一个第二个元素无效的数组,我们可以这样做。</target>
        </trans-unit>
        <trans-unit id="97ab86f3d69d58ce3be53a871603ed078f8824cf" translate="yes" xml:space="preserve">
          <source>To describe the type of scalar data, there are several &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;built-in scalar types&lt;/a&gt; in NumPy for various precision of integers, floating-point numbers, &lt;em&gt;etc&lt;/em&gt;. An item extracted from an array, &lt;em&gt;e.g.&lt;/em&gt;, by indexing, will be a Python object whose type is the scalar type associated with the data type of the array.</source>
          <target state="translated">为了描述标量数据的&lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;类型&lt;/a&gt;，NumPy中有几种内置标量类型，用于整数，浮点数&lt;em&gt;等的&lt;/em&gt;各种精度。从数组（&lt;em&gt;例如&lt;/em&gt;通过索引）提取的项目将是Python对象，其类型是与数组的数据类型关联的标量类型。</target>
        </trans-unit>
        <trans-unit id="42815d30b39c91ade5f76679c62182278601bee8" translate="yes" xml:space="preserve">
          <source>To do buffered reduction requires yet another adjustment during the setup. Normally the iterator construction involves copying the first buffer of data from the readable arrays into the buffer. Any reduction operand is readable, so it may be read into a buffer. Unfortunately, initialization of the operand after this buffering operation is complete will not be reflected in the buffer that the iteration starts with, and garbage results will be produced.</source>
          <target state="translated">要进行缓冲区缩减,需要在设置过程中再进行一次调整。通常迭代器的构造包括将第一个缓冲区的数据从可读数组中复制到缓冲区中。任何还原操作数都是可读的,所以可以将其读入缓冲区。遗憾的是,在这个缓冲操作完成后,操作数的初始化将不会反映在迭代开始的缓冲区中,并且会产生垃圾结果。</target>
        </trans-unit>
        <trans-unit id="2a3fff7f3035206492b3a95d3cbf852432de0dee" translate="yes" xml:space="preserve">
          <source>To enable and control broadcasting, use an ellipsis. Default NumPy-style broadcasting is done by adding an ellipsis to the left of each term, like &lt;code&gt;np.einsum('...ii-&amp;gt;...i', a)&lt;/code&gt;. To take the trace along the first and last axes, you can do &lt;code&gt;np.einsum('i...i', a)&lt;/code&gt;, or to do a matrix-matrix product with the left-most indices instead of rightmost, one can do &lt;code&gt;np.einsum('ij...,jk...-&amp;gt;ik...', a, b)&lt;/code&gt;.</source>
          <target state="translated">要启用和控制广播，请使用省略号。默认的NumPy样式广播是通过在每个术语的左侧添加省略号来完成的，例如 &lt;code&gt;np.einsum('...ii-&amp;gt;...i', a)&lt;/code&gt; 。要沿第一个轴和最后一个轴进行跟踪，可以执行 &lt;code&gt;np.einsum('i...i', a)&lt;/code&gt; ，或者使用最左边的索引而不是最右边的索引做矩阵矩阵乘积， &lt;code&gt;np.einsum('ij...,jk...-&amp;gt;ik...', a, b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09fc0ca575462761f878d637a2fecf46e1ccd71c" translate="yes" xml:space="preserve">
          <source>To facilitate this many similar unit tests, some high-level programming techniques are employed, including C and &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; macros, as well as Python inheritance. The purpose of this document is to describe the testing infrastructure employed to verify that the &lt;code&gt;numpy.i&lt;/code&gt; typemaps are working as expected.</source>
          <target state="translated">为了促进许多类似的单元测试，采用了一些高级编程技术，包括C和&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;宏以及Python继承。本文档的目的是描述用于验证 &lt;code&gt;numpy.i&lt;/code&gt; 类型图是否按预期工作的测试基础结构。</target>
        </trans-unit>
        <trans-unit id="df1248d3a4c3c276bf78a49ecea34ca2333414db" translate="yes" xml:space="preserve">
          <source>To find how many valid days there are in a specified range of datetime64 dates, use &lt;a href=&quot;generated/numpy.busday_count#numpy.busday_count&quot;&gt;&lt;code&gt;busday_count&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要查找在指定的datetime64日期范围内有多少有效天，请使用&lt;a href=&quot;generated/numpy.busday_count#numpy.busday_count&quot;&gt; &lt;code&gt;busday_count&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="381cf7b173efa6d304977d6f48b6eab1589b8ebf" translate="yes" xml:space="preserve">
          <source>To find the union of more than two arrays, use functools.reduce:</source>
          <target state="translated">要找到两个以上数组的联合,使用functools.reduce.commit。</target>
        </trans-unit>
        <trans-unit id="8cb65420b2ca2983f196bbc9804b56531579abff" translate="yes" xml:space="preserve">
          <source>To group the indices by element, rather than dimension, use &lt;a href=&quot;numpy.argwhere#numpy.argwhere&quot;&gt;&lt;code&gt;argwhere&lt;/code&gt;&lt;/a&gt;, which returns a row for each non-zero element.</source>
          <target state="translated">要将索引按元素而不是维度进行&lt;a href=&quot;numpy.argwhere#numpy.argwhere&quot;&gt; &lt;code&gt;argwhere&lt;/code&gt; &lt;/a&gt;，请使用argwhere，它为每个非零元素返回一行。</target>
        </trans-unit>
        <trans-unit id="dd77da9e3cc0e1b206296360b148e66d7e5bf3e1" translate="yes" xml:space="preserve">
          <source>To group the indices by element, rather than dimension, use instead:</source>
          <target state="translated">要按元素而不是按维度对指数进行分组,请使用。</target>
        </trans-unit>
        <trans-unit id="5ceadcdbd2ecba0b0b71d04b040d27f4a8978392" translate="yes" xml:space="preserve">
          <source>To intersect more than two arrays, use functools.reduce:</source>
          <target state="translated">要与两个以上的数组相交,请使用 functools.reduce.reduce。</target>
        </trans-unit>
        <trans-unit id="68755700558e4129caf4a1646cfbb8316cee0dd6" translate="yes" xml:space="preserve">
          <source>To make an iterator similar to the old iterator, this should work.</source>
          <target state="translated">要做一个类似于老迭代器的迭代器,这个应该可以。</target>
        </trans-unit>
        <trans-unit id="dcb62bb890eb45640b1d129077fff1a1982947c5" translate="yes" xml:space="preserve">
          <source>To make the necessary build options available to third parties, you could use the &lt;code&gt;npy-pkg-config&lt;/code&gt; mechanism implemented in &lt;a href=&quot;#module-numpy.distutils&quot;&gt;&lt;code&gt;numpy.distutils&lt;/code&gt;&lt;/a&gt;. This mechanism is based on a .ini file which contains all the options. A .ini file is very similar to .pc files as used by the pkg-config unix utility:</source>
          <target state="translated">为了进行必要的编译选项提供给第三方，您可以使用 &lt;code&gt;npy-pkg-config&lt;/code&gt; 中实现机制&lt;a href=&quot;#module-numpy.distutils&quot;&gt; &lt;code&gt;numpy.distutils&lt;/code&gt; &lt;/a&gt;。此机制基于包含所有选项的.ini文件。.ini文件与pkg-config unix实用程序使用的.pc文件非常相似：</target>
        </trans-unit>
        <trans-unit id="02d722ee9de32d295a3f1aa488c332a62e29240a" translate="yes" xml:space="preserve">
          <source>To put back the default options, you can use:</source>
          <target state="translated">要放回默认选项,你可以使用。</target>
        </trans-unit>
        <trans-unit id="33f422775354a46e3c9c41ff160bfb3c38d25920" translate="yes" xml:space="preserve">
          <source>To reduce the chance of misinterpretation, even though the following &amp;ldquo;abuse&amp;rdquo; is nominally supported, &lt;code&gt;choices&lt;/code&gt; should neither be, nor be thought of as, a single array, i.e., the outermost sequence-like container should be either a list or a tuple.</source>
          <target state="translated">为了减少错误解释的机会，即使名义上支持以下&amp;ldquo;滥用&amp;rdquo;， &lt;code&gt;choices&lt;/code&gt; 也不应该也不应被视为单个数组，即，最外面的类似于序列的容器应该是列表或元组。</target>
        </trans-unit>
        <trans-unit id="69f7fdf215ee6723757c121f1000e16153523a1d" translate="yes" xml:space="preserve">
          <source>To retrieve only the valid entries, we can use the inverse of the mask as an index. The inverse of the mask can be calculated with the &lt;a href=&quot;generated/numpy.logical_not#numpy.logical_not&quot;&gt;&lt;code&gt;numpy.logical_not&lt;/code&gt;&lt;/a&gt; function or simply with the &lt;code&gt;~&lt;/code&gt; operator:</source>
          <target state="translated">要仅检索有效条目，我们可以使用掩码的倒数作为索引。可以使用&lt;a href=&quot;generated/numpy.logical_not#numpy.logical_not&quot;&gt; &lt;code&gt;numpy.logical_not&lt;/code&gt; &lt;/a&gt;函数或仅使用 &lt;code&gt;~&lt;/code&gt; 运算符来计算掩码的逆：</target>
        </trans-unit>
        <trans-unit id="e546770d4089912cdd192abaecf0b1e29a9e2943" translate="yes" xml:space="preserve">
          <source>To return the indices of the values common to the input arrays along with the intersected values:</source>
          <target state="translated">返回与输入数组共同的值的索引以及相交的值。</target>
        </trans-unit>
        <trans-unit id="67e6eaca69e6f48eb1845e3b15fc19b5fce3851f" translate="yes" xml:space="preserve">
          <source>To run SciPy&amp;rsquo;s full test suite, use the following:</source>
          <target state="translated">要运行SciPy的完整测试套件，请使用以下命令：</target>
        </trans-unit>
        <trans-unit id="9661928d3b7e0b0f53e4248625106d96b260f714" translate="yes" xml:space="preserve">
          <source>To sample from N evenly spaced floating-point numbers between a and b, use:</source>
          <target state="translated">要从a和b之间的N个间隔均匀的浮点数字中取样,使用。</target>
        </trans-unit>
        <trans-unit id="a4d884174d72a1ce55f9ee4b7d870c154a7a32b7" translate="yes" xml:space="preserve">
          <source>To skip a test, simply use &lt;code&gt;skipif&lt;/code&gt;:</source>
          <target state="translated">要跳过测试，只需使用 &lt;code&gt;skipif&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="673335eebf9011c1628160cca5d99d26576f081d" translate="yes" xml:space="preserve">
          <source>To take the running sum of four successive values:</source>
          <target state="translated">要取四个连续值的运行之和。</target>
        </trans-unit>
        <trans-unit id="54587f602166cab38648eb3409cd921150aa4e7e" translate="yes" xml:space="preserve">
          <source>To test a datetime64 value to see if it is a valid day, use &lt;a href=&quot;generated/numpy.is_busday#numpy.is_busday&quot;&gt;&lt;code&gt;is_busday&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要测试datetime64值以查看其是否为有效日期，请使用&lt;a href=&quot;generated/numpy.is_busday#numpy.is_busday&quot;&gt; &lt;code&gt;is_busday&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ecbd73988a92874f75c5ca6f8256cc9806ceef6d" translate="yes" xml:space="preserve">
          <source>To unmask all masked entries of a masked array (provided the mask isn&amp;rsquo;t a hard mask), the simplest solution is to assign the constant &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; to the mask:</source>
          <target state="translated">要取消屏蔽已屏蔽数组的所有已屏蔽条目（假设该掩码不是硬掩码），最简单的解决方案是将常量&lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;分配给该掩码：</target>
        </trans-unit>
        <trans-unit id="573c20b6a49882f7eb74a61c9d6cc94e9816cad4" translate="yes" xml:space="preserve">
          <source>To unmask one or several specific entries, we can just assign one or several new valid values to them:</source>
          <target state="translated">要解除对一个或几个特定条目的屏蔽,我们只需给它们分配一个或几个新的有效值。</target>
        </trans-unit>
        <trans-unit id="678a8d94c4368f39ac59f5979ae212033bfc0aa2" translate="yes" xml:space="preserve">
          <source>To use the NPY_NO_DEPRECATED_API mechanism, you need to #define it to the target API version of NumPy before #including any NumPy headers. If you want to confirm that your code is clean against 1.7, use:</source>
          <target state="translated">要使用NPY_NO_DEPRECATED_API机制,你需要在#包含任何NumPy头文件之前,将其定义为NumPy的目标API版本。如果你想确认你的代码在1.7的情况下是干净的,请使用:</target>
        </trans-unit>
        <trans-unit id="a6632c1bd45113f2d4d1587bfeed07e24b0355a1" translate="yes" xml:space="preserve">
          <source>To use the core math library in your own extension, you need to add the npymath compile and link options to your extension in your setup.py:</source>
          <target state="translated">要在你自己的扩展中使用核心数学库,你需要在setup.py中为你的扩展添加npymath编译和链接选项。</target>
        </trans-unit>
        <trans-unit id="9b09eedfc76bdeeb31bc979256f245ac870f03de" translate="yes" xml:space="preserve">
          <source>Toggle between low-endian and big-endian data representation by returning a byteswapped array, optionally swapped in-place.</source>
          <target state="translated">通过返回一个字节交换的数组,在低字节和大字节数据表示之间切换,可以选择就地交换。</target>
        </trans-unit>
        <trans-unit id="7b37ca94c4e2eda42b84355ca6a25cdc55774133" translate="yes" xml:space="preserve">
          <source>Tolerance in machine epsilons for the complex part of the elements in the array.</source>
          <target state="translated">阵列中元素的复杂部分的机器epsilons公差。</target>
        </trans-unit>
        <trans-unit id="eb34b2131d6523965cdff1a43f4d01b982373d17" translate="yes" xml:space="preserve">
          <source>Tolerance parameters passed on to &lt;code&gt;isclose&lt;/code&gt;</source>
          <target state="translated">公差参数传递给 &lt;code&gt;isclose&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6670aa4fd96fc23b9c267762a58d3e2634e5e33d" translate="yes" xml:space="preserve">
          <source>Tolerance when checking the singular values in covariance matrix. cov is cast to double before the check.</source>
          <target state="translated">检查协方差矩阵中的奇异值时的容忍度,cov在检查前被转为双倍。</target>
        </trans-unit>
        <trans-unit id="62511550774b90e55fa9f4d081340a2b9a412907" translate="yes" xml:space="preserve">
          <source>Total bytes consumed by the elements of the array.</source>
          <target state="translated">数组元素消耗的总字节数。</target>
        </trans-unit>
        <trans-unit id="f98da7ab34ca5eed412ebdc84c5c6ee4a001f890" translate="yes" xml:space="preserve">
          <source>Total number of array elements which trigger summarization rather than full repr (default 1000).</source>
          <target state="translated">触发摘要而非完全重写的数组元素总数(默认1000)。</target>
        </trans-unit>
        <trans-unit id="d7665d1d201c9ce2fd429127a2f276d913bba99d" translate="yes" xml:space="preserve">
          <source>Total number of array elements which trigger summarization rather than full repr. Defaults to &lt;code&gt;numpy.get_printoptions()['threshold']&lt;/code&gt;.</source>
          <target state="translated">触发汇总而不是完整表示的数组元素总数。默认为 &lt;code&gt;numpy.get_printoptions()['threshold']&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b009fd84652963a9ad5cd24ef82072817ddee41" translate="yes" xml:space="preserve">
          <source>Total size of broadcasted result.</source>
          <target state="translated">播出结果的总规模。</target>
        </trans-unit>
        <trans-unit id="77cca581150b844f956409245e7a5aa4e911b340" translate="yes" xml:space="preserve">
          <source>Trace of a matrix:</source>
          <target state="translated">矩阵的痕迹。</target>
        </trans-unit>
        <trans-unit id="b67024bc850bfd9a0093e89cd78bf7093386c17c" translate="yes" xml:space="preserve">
          <source>Trace of an array, &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;numpy.trace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">数组的跟踪&lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;numpy.trace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed0e339a8e0484e2fd0a0d26f8fea815f7ce8155" translate="yes" xml:space="preserve">
          <source>Tracking an Index or Multi-Index</source>
          <target state="translated">跟踪一个指数或多个指数</target>
        </trans-unit>
        <trans-unit id="4cf0fc0db43adb86a6609aeef379773c878c22d3" translate="yes" xml:space="preserve">
          <source>Tracking an index or multi-index is incompatible with using an external loop, because it requires a different index value per element. If you try to combine these flags, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object will raise an exception</source>
          <target state="translated">跟踪索引或多索引与使用外部循环不兼容，因为它要求每个元素具有不同的索引值。如果尝试组合这些标志，则&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;对象将引发异常</target>
        </trans-unit>
        <trans-unit id="0de8c9ca9943956fbbe74f36e563016e4ecbb6f6" translate="yes" xml:space="preserve">
          <source>Trailing (i.e., highest order) elements with absolute value less than or equal to &lt;code&gt;tol&lt;/code&gt; (default value is zero) are removed.</source>
          <target state="translated">绝对值小于或等于 &lt;code&gt;tol&lt;/code&gt; （默认值为零）的尾随（即最高阶）元素将被删除。</target>
        </trans-unit>
        <trans-unit id="556492d634d78a1f54a40b4fbbb6e6c53716147d" translate="yes" xml:space="preserve">
          <source>Trailing zeros in the coefficients will be used in the evaluation, so they should be avoided if efficiency is a concern.</source>
          <target state="translated">系数中的尾数零将在评估中使用,所以如果担心效率,应该避免使用。</target>
        </trans-unit>
        <trans-unit id="745b5ecf9a2d85dc724cf9ddd7a6df396eb1df69" translate="yes" xml:space="preserve">
          <source>Transforms a masked array into a flexible-type array.</source>
          <target state="translated">将掩码数组转换为灵活型数组。</target>
        </trans-unit>
        <trans-unit id="5335ed0e86bcde3b96f32fd1545910f420f14d2e" translate="yes" xml:space="preserve">
          <source>Transition notice</source>
          <target state="translated">过渡通知</target>
        </trans-unit>
        <trans-unit id="d362208ff2e702ca3538568841ed00ca61c441f9" translate="yes" xml:space="preserve">
          <source>Translate slice objects to concatenation along the first axis.</source>
          <target state="translated">将切片对象转化为沿第一轴的连接。</target>
        </trans-unit>
        <trans-unit id="c42fc49440b8d06a906b44be13eb608ca2ffc1dd" translate="yes" xml:space="preserve">
          <source>Translates slice objects to concatenation along the first axis.</source>
          <target state="translated">将切片对象转化为沿第一轴的连接。</target>
        </trans-unit>
        <trans-unit id="ff7c65a71ec845e39d241d138fd72490df88fa74" translate="yes" xml:space="preserve">
          <source>Translates slice objects to concatenation along the second axis.</source>
          <target state="translated">将切片对象转化为沿第二轴的连接。</target>
        </trans-unit>
        <trans-unit id="8def3943422e0dc87b7f47772bd3dc4ad8ea550b" translate="yes" xml:space="preserve">
          <source>Transpose-like operations</source>
          <target state="translated">类似换位操作</target>
        </trans-unit>
        <trans-unit id="1dfdbda20e491607190c97bd4edf114a4a693811" translate="yes" xml:space="preserve">
          <source>Transposing a 1-D array returns an unchanged view of the original array.</source>
          <target state="translated">转置一个一维数组,返回的是原数组的不变视图。</target>
        </trans-unit>
        <trans-unit id="66408bfa15c9ed2902e447a43b1f7abcdee55a60" translate="yes" xml:space="preserve">
          <source>Transpositions and permutations, &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;numpy.transpose&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">换位和置换&lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;numpy.transpose&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8cd1d8f1121212090792af3b195766028fb3300b" translate="yes" xml:space="preserve">
          <source>Treatment for division by zero.</source>
          <target state="translated">除以零的处理方法。</target>
        </trans-unit>
        <trans-unit id="c576a1cfdbaf816c1398a32382e59edc28900bee" translate="yes" xml:space="preserve">
          <source>Treatment for floating-point overflow.</source>
          <target state="translated">浮点溢出的处理方法。</target>
        </trans-unit>
        <trans-unit id="17721dd3ac43e33f85ad621f2dc25c086c0470c0" translate="yes" xml:space="preserve">
          <source>Treatment for floating-point underflow.</source>
          <target state="translated">对浮点下溢的处理。</target>
        </trans-unit>
        <trans-unit id="a13040b51033dafdb26f7572598a0d12e22e4ffe" translate="yes" xml:space="preserve">
          <source>Treatment for invalid floating-point operation.</source>
          <target state="translated">浮点运算无效的处理方法。</target>
        </trans-unit>
        <trans-unit id="3a49a3516e9535a98c78b0ab59efaa267faaaeac" translate="yes" xml:space="preserve">
          <source>Triggers &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt;&lt;code&gt;NPY_ITER_COPY&lt;/code&gt;&lt;/a&gt;, and when an array operand is flagged for writing and is copied, causes the data in a copy to be copied back to &lt;code&gt;op[i]&lt;/code&gt; when &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; is called.</source>
          <target state="translated">触发&lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt; &lt;code&gt;NPY_ITER_COPY&lt;/code&gt; &lt;/a&gt;，当将数组操作数标记为要写入并被复制时，将导致在调用 &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; 时将副本中的数据复制回 &lt;code&gt;op[i]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="translated">三角函数</target>
        </trans-unit>
        <trans-unit id="58cf0aee76fad599f97ff1db8c6a47d2270860db" translate="yes" xml:space="preserve">
          <source>Trigonometric inverse cosine, element-wise.</source>
          <target state="translated">三角形反余弦,元素式。</target>
        </trans-unit>
        <trans-unit id="b0b82a06c2ae28e8fcf146e965d0c41fd4531e3a" translate="yes" xml:space="preserve">
          <source>Trigonometric inverse tangent, element-wise.</source>
          <target state="translated">三角形反切线,元素式。</target>
        </trans-unit>
        <trans-unit id="ce4f3fa4852db4b9b207eedadc12e11135e46d85" translate="yes" xml:space="preserve">
          <source>Trigonometric sine, element-wise.</source>
          <target state="translated">三角形正弦,元素方面。</target>
        </trans-unit>
        <trans-unit id="10a283c17897bbd0b4cb4fd810a9eeb88aa8ef58" translate="yes" xml:space="preserve">
          <source>Trim the leading and/or trailing zeros from a 1-D array or sequence.</source>
          <target state="translated">从一维数组或序列中修剪前导零和/或后导零。</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="dec064efe14ed7a73f97fa4832f7dc39f8d37259" translate="yes" xml:space="preserve">
          <source>True divide self by other in-place.</source>
          <target state="translated">真正的将自己与其他原地划分。</target>
        </trans-unit>
        <trans-unit id="39cf2a1ac05eb7ec1f611fa8df3b32f9cff1d558" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;m.dtype.type&lt;/code&gt; is MaskType, False otherwise.</source>
          <target state="translated">如果 &lt;code&gt;m.dtype.type&lt;/code&gt; 为MaskType，则为 True ，否则为False。</target>
        </trans-unit>
        <trans-unit id="c7e5263b6e49f0164ce122995ea161e565df58fa" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;num&lt;/code&gt; is a scalar type, False if it is not.</source>
          <target state="translated">如果 &lt;code&gt;num&lt;/code&gt; 是标量类型，则为True；否则为False。</target>
        </trans-unit>
        <trans-unit id="2655b1728487edfb72db0ecd08ff9ea666177ee0" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;path&lt;/code&gt; exists.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 存在，则为真。</target>
        </trans-unit>
        <trans-unit id="0acadbce2849d20449e701a26739adbff1b98e78" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;x&lt;/code&gt; is a MaskedArray with masked values, False otherwise.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是具有掩码值的MaskedArray，则为True ，否则为False。</target>
        </trans-unit>
        <trans-unit id="05ff71445923acdd0c38d736b463809c9ccd39de" translate="yes" xml:space="preserve">
          <source>True if a Fortran 77 compiler is available (because a simple Fortran 77 code was able to be compiled successfully).</source>
          <target state="translated">如果有Fortran 77编译器,则为真(因为一个简单的Fortran 77代码能够被成功编译)。</target>
        </trans-unit>
        <trans-unit id="00cd0fd9fd4e9fcf05a5961ba064f7c5fc57b8ef" translate="yes" xml:space="preserve">
          <source>True if a Fortran 90 compiler is available (because a simple Fortran 90 code was able to be compiled successfully)</source>
          <target state="translated">如果有Fortran 90编译器,则为真(因为一个简单的Fortran 90代码能够被成功编译)。</target>
        </trans-unit>
        <trans-unit id="213506708b75038d86119f896c93fd459688fdaa" translate="yes" xml:space="preserve">
          <source>True if byteorder characters ( &lt;code&gt;NPY_LITTLE&lt;/code&gt;, &lt;code&gt;NPY_BIG&lt;/code&gt;, &lt;code&gt;NPY_NATIVE&lt;/code&gt;, &lt;code&gt;NPY_IGNORE&lt;/code&gt; ) are either equal or equivalent as to their specification of a native byte order. Thus, on a little-endian machine &lt;code&gt;NPY_LITTLE&lt;/code&gt; and &lt;code&gt;NPY_NATIVE&lt;/code&gt; are equivalent where they are not equivalent on a big-endian machine.</source>
          <target state="translated">如果字节序字符（ &lt;code&gt;NPY_LITTLE&lt;/code&gt; ， &lt;code&gt;NPY_BIG&lt;/code&gt; ， &lt;code&gt;NPY_NATIVE&lt;/code&gt; ， &lt;code&gt;NPY_IGNORE&lt;/code&gt; ）在本机字节序的规范上相等或相等，则为true。因此，在小端序计算机上， &lt;code&gt;NPY_LITTLE&lt;/code&gt; 和 &lt;code&gt;NPY_NATIVE&lt;/code&gt; 是等效的，而在大端序计算机上则不相等。</target>
        </trans-unit>
        <trans-unit id="ba3294550f0a20e5d9deb7f04a95fb8e4b4d1d46" translate="yes" xml:space="preserve">
          <source>True if cast can occur according to the casting rule.</source>
          <target state="translated">如果根据铸造规则可以发生铸造,则为真。</target>
        </trans-unit>
        <trans-unit id="1f63565b32d103f3a4de31640d426343af47dd7d" translate="yes" xml:space="preserve">
          <source>True if equivalent, False otherwise.</source>
          <target state="translated">如果等价,则为真,否则为假。</target>
        </trans-unit>
        <trans-unit id="1e741019d05ad4b1c0222d2d53486f99a6732190" translate="yes" xml:space="preserve">
          <source>True if other is same class as self</source>
          <target state="translated">如果other与self同级,则为true</target>
        </trans-unit>
        <trans-unit id="70fbd415e3863800b42dd70f2afc2d0435498df0" translate="yes" xml:space="preserve">
          <source>True if the coefficients are the same, False otherwise.</source>
          <target state="translated">如果系数相同则为真,否则为假。</target>
        </trans-unit>
        <trans-unit id="a6afbacb41b3137cec218f989dffb959ca4f44cd" translate="yes" xml:space="preserve">
          <source>True if the domains are the same, False otherwise.</source>
          <target state="translated">如果域名相同则为真,否则为假。</target>
        </trans-unit>
        <trans-unit id="4bc2a6d6f70eb24c8def5df03724644edb474780" translate="yes" xml:space="preserve">
          <source>True if the windows are the same, False otherwise.</source>
          <target state="translated">如果窗口相同则为true,否则为False。</target>
        </trans-unit>
        <trans-unit id="24f9df4fb7133abd7e86f4b5f0391c10a93621e7" translate="yes" xml:space="preserve">
          <source>True if two arrays have the same shape and elements, False otherwise.</source>
          <target state="translated">如果两个数组的形状和元素相同,则为真,否则为假。</target>
        </trans-unit>
        <trans-unit id="755e15abf3303ababe3ade30f10af71c607d4530" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is NaN, false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为NaN，则为true，否则为false。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="dc0b3f0e3c0fa8c731e1bcdadee661ee71b2ddb8" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is NaT, false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是NaT，则为true，否则为false。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="cd270c6be47d5f9045a9640d5cc8ead8711407bc" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is not positive infinity, negative infinity, or NaN; false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">当 &lt;code&gt;x&lt;/code&gt; 不是正无穷大，负无穷大或NaN时为真；否则为假。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="3170e8eb3762dd10d0e3ab109761eb5c944e9ac1" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is positive or negative infinity, false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">当 &lt;code&gt;x&lt;/code&gt; 为正或负无穷大时为true，否则为false。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="425b939d0909e079d100ad47521c0febc0bd307a" translate="yes" xml:space="preserve">
          <source>Truncate s values at 50 so plot is interesting:</source>
          <target state="translated">将s值截断在50处,这样绘图才有趣。</target>
        </trans-unit>
        <trans-unit id="8726579bd5d3f34275a243eb604a9ceb6cbd38eb" translate="yes" xml:space="preserve">
          <source>Truncate series to length &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">将系列截短为长度 &lt;code&gt;size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adcf68c15599690309b811decf083d5555853eeb" translate="yes" xml:space="preserve">
          <source>Truncate series to the given degree.</source>
          <target state="translated">将系列截断到给定的程度。</target>
        </trans-unit>
        <trans-unit id="d78b8c914ad90242aebfa1ad45be017c8a4ed426" translate="yes" xml:space="preserve">
          <source>Truth value of an array (&lt;code&gt;bool&lt;/code&gt;):</source>
          <target state="translated">数组的真值（ &lt;code&gt;bool&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="d14d79df6800bf8b855c978794baaad558b55ab7" translate="yes" xml:space="preserve">
          <source>Truth value testing</source>
          <target state="translated">真值测试</target>
        </trans-unit>
        <trans-unit id="a34d6317df428f3a0882e4fcc17ec8a423d926fc" translate="yes" xml:space="preserve">
          <source>Truth-value testing of an array invokes &lt;a href=&quot;generated/numpy.ndarray.__bool__#numpy.ndarray.__bool__&quot;&gt;&lt;code&gt;ndarray.__bool__&lt;/code&gt;&lt;/a&gt;, which raises an error if the number of elements in the array is larger than 1, because the truth value of such arrays is ambiguous. Use &lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt;&lt;code&gt;.any()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;.all()&lt;/code&gt;&lt;/a&gt; instead to be clear about what is meant in such cases. (If the number of elements is 0, the array evaluates to &lt;code&gt;False&lt;/code&gt;.)</source>
          <target state="translated">数组的真值测试会调用&lt;a href=&quot;generated/numpy.ndarray.__bool__#numpy.ndarray.__bool__&quot;&gt; &lt;code&gt;ndarray.__bool__&lt;/code&gt; &lt;/a&gt;，如果数组中的元素数大于1，则会引发错误，因为此类数组的真值不明确。使用&lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt; &lt;code&gt;.any()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;.all()&lt;/code&gt; &lt;/a&gt;，而不是要清楚什么是在这种情况下的意思。（如果元素数为0，则数组的值为 &lt;code&gt;False&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="2ecf59a43e289ad2b017cf95dec49da40904a53e" translate="yes" xml:space="preserve">
          <source>Try to get version string of a package.</source>
          <target state="translated">尝试获取一个软件包的版本字符串。</target>
        </trans-unit>
        <trans-unit id="78b28b6348f61eb4f458af0454cbb48914113f96" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;(item_dtype, shape)&lt;/code&gt; if this &lt;a href=&quot;#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; describes a sub-array, and None otherwise.</source>
          <target state="translated">如果此&lt;a href=&quot;#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;描述子数组， &lt;code&gt;(item_dtype, shape)&lt;/code&gt; 元组（item_dtype，shape），否则为None。</target>
        </trans-unit>
        <trans-unit id="3e6ddb0c1b967dfa42de0aef208f74bd1f3fd6c6" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;(item_dtype, shape)&lt;/code&gt; if this &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; describes a sub-array, and None otherwise.</source>
          <target state="translated">如果此&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;描述子数组， &lt;code&gt;(item_dtype, shape)&lt;/code&gt; 元组（item_dtype，shape），否则为None。</target>
        </trans-unit>
        <trans-unit id="f3757a0166a586f2a2125cefab21784843d386d2" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;(item_dtype, shape)&lt;/code&gt; if this &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; describes a sub-array, and None otherwise.</source>
          <target state="translated">如果此&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;描述子数组， &lt;code&gt;(item_dtype, shape)&lt;/code&gt; 元组（item_dtype，shape），否则为None。</target>
        </trans-unit>
        <trans-unit id="84be13d7b7fcc75e7ec8441a86e66cf302003bb9" translate="yes" xml:space="preserve">
          <source>Tuple axis arguments to ufuncs are equivalent:</source>
          <target state="translated">ufuncs的元组轴参数是等价的。</target>
        </trans-unit>
        <trans-unit id="288ea08ff10a961743d4d8b925f5d1931f661310" translate="yes" xml:space="preserve">
          <source>Tuple of array dimensions.</source>
          <target state="translated">阵列维数的元组。</target>
        </trans-unit>
        <trans-unit id="119e92503836c54689c5f8c6dff4e15a28816a46" translate="yes" xml:space="preserve">
          <source>Tuple of bytes to step in each dimension when traversing an array.</source>
          <target state="translated">当遍历一个数组时,在每个维度上要步进的字节元组。</target>
        </trans-unit>
        <trans-unit id="a39e9bc9ce6796bfca6ebd0c63299d64e075f553" translate="yes" xml:space="preserve">
          <source>Tuple whose elements are the array size in each dimension. Each entry is an integer (a Python int or long). Note that these integers could be larger than the platform &amp;ldquo;int&amp;rdquo; or &amp;ldquo;long&amp;rdquo; could hold (a Python int is a C long). It is up to the code using this attribute to handle this appropriately; either by raising an error when overflow is possible, or by using &lt;code&gt;Py_LONG_LONG&lt;/code&gt; as the C type for the shapes.</source>
          <target state="translated">元组的元素是每个维中的数组大小。每个条目都是一个整数（Python int或long）。请注意，这些整数可能大于平台&amp;ldquo; int&amp;rdquo;或&amp;ldquo; long&amp;rdquo;可容纳的整数（Python int为C long）。取决于使用此属性的代码来适当地处理此问题。在可能发生溢出时引发错误，或者使用 &lt;code&gt;Py_LONG_LONG&lt;/code&gt; 作为形状的C类型。</target>
        </trans-unit>
        <trans-unit id="eff015ed2b91595519ef0f82b5da310790ed8380" translate="yes" xml:space="preserve">
          <source>Two groups, children of diabetics (25 people) and children from people without diabetes (25 controls). Fasting blood glucose was measured, case group had a mean value of 86.1, controls had a mean value of 82.2. Standard deviations were 2.09 and 2.49 respectively. Are these data consistent with the null hypothesis that the parents diabetic status does not affect their children&amp;rsquo;s blood glucose levels? Calculating the F statistic from the data gives a value of 36.01.</source>
          <target state="translated">两组分别为糖尿病儿童（25人）和非糖尿病儿童（25人）。测量空腹血糖，病例组的平均值为86.1，对照组的平均值为82.2。标准偏差分别为2.09和2.49。这些数据是否与父母的糖尿病状况不影响孩子的血糖水平的零假设相符？从数据计算F统计量得出的值为36.01。</target>
        </trans-unit>
        <trans-unit id="9a29304c220b1dd3134936cc76050af186cb5278" translate="yes" xml:space="preserve">
          <source>Two times the reciprocal of pi (</source>
          <target state="translated">pi的倒数的2倍 (</target>
        </trans-unit>
        <trans-unit id="c6b3128dd2f1c22ff8a2b286be1379fe8a8fe179" translate="yes" xml:space="preserve">
          <source>Two-by-four array of samples from</source>
          <target state="translated">二乘四的样品阵列</target>
        </trans-unit>
        <trans-unit id="b1f6d6c8746a437f90f0dee674c0b93df2f99381" translate="yes" xml:space="preserve">
          <source>Two-by-four array of samples from N(3, 6.25):</source>
          <target state="translated">N(3,6.25)的二乘四样品阵列。</target>
        </trans-unit>
        <trans-unit id="3db221513448342ff7f1391357dc023cdf6dc3dc" translate="yes" xml:space="preserve">
          <source>Two-by-four matrix of samples from</source>
          <target state="translated">二乘四样本矩阵</target>
        </trans-unit>
        <trans-unit id="862d5ad68d4b198349fd0cc9c98a5797e23f13c7" translate="yes" xml:space="preserve">
          <source>Two-dimensional array:</source>
          <target state="translated">二维阵列。</target>
        </trans-unit>
        <trans-unit id="4ca814bb64ef6897ea819d313fffbc4815334f0e" translate="yes" xml:space="preserve">
          <source>Two-dimensional arrays are tested in exactly the same manner. The above description applies, but with &lt;code&gt;Matrix&lt;/code&gt; substituted for &lt;code&gt;Vector&lt;/code&gt;. For three-dimensional tests, substitute &lt;code&gt;Tensor&lt;/code&gt; for &lt;code&gt;Vector&lt;/code&gt;. For four-dimensional tests, substitute &lt;code&gt;SuperTensor&lt;/code&gt; for &lt;code&gt;Vector&lt;/code&gt;. For flat in-place array tests, substitute &lt;code&gt;Flat&lt;/code&gt; for &lt;code&gt;Vector&lt;/code&gt;. For the descriptions that follow, we will reference the &lt;code&gt;Vector&lt;/code&gt; tests, but the same information applies to &lt;code&gt;Matrix&lt;/code&gt;, &lt;code&gt;Tensor&lt;/code&gt; and &lt;code&gt;SuperTensor&lt;/code&gt; tests.</source>
          <target state="translated">以完全相同的方式测试二维数组。上面的描述适用，但是用 &lt;code&gt;Matrix&lt;/code&gt; 代替了 &lt;code&gt;Vector&lt;/code&gt; 。对于三维测试，用 &lt;code&gt;Tensor&lt;/code&gt; 代替 &lt;code&gt;Vector&lt;/code&gt; 。对于四维测试，用 &lt;code&gt;SuperTensor&lt;/code&gt; 代替 &lt;code&gt;Vector&lt;/code&gt; 。对于平面就地数组测试，用 &lt;code&gt;Flat&lt;/code&gt; 代替 &lt;code&gt;Vector&lt;/code&gt; 。对于以下描述，我们将引用 &lt;code&gt;Vector&lt;/code&gt; 测试，但是相同的信息适用于 &lt;code&gt;Matrix&lt;/code&gt; ， &lt;code&gt;Tensor&lt;/code&gt; 和 &lt;code&gt;SuperTensor&lt;/code&gt; 测试。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="546ef13b4643b6acadc0951eac37d6f468caac3d" translate="yes" xml:space="preserve">
          <source>Type description examples</source>
          <target state="translated">类型描述示例</target>
        </trans-unit>
        <trans-unit id="966782d7443e2170cf499e59f9a8368a7b7380cd" translate="yes" xml:space="preserve">
          <source>Type has fields associated with it.</source>
          <target state="translated">类型有与之相关的字段。</target>
        </trans-unit>
        <trans-unit id="ad1651cc08eba91d6dce8f9e7cbe0420ed624c49" translate="yes" xml:space="preserve">
          <source>Type has no size information attached, and can be resized. Should only be called on flexible dtypes. Types that are attached to an array will always be sized, hence the array form of this macro not existing.</source>
          <target state="translated">类型没有附加的尺寸信息,并且可以调整大小。应该只对灵活的dtypes调用。附加在数组上的类型总是有大小的,因此这个宏的数组形式不存在。</target>
        </trans-unit>
        <trans-unit id="00fea5456fe9ccd4a61fecaaa45953e334c1c594" translate="yes" xml:space="preserve">
          <source>Type is either flexible or user-defined.</source>
          <target state="translated">类型可以是灵活的,也可以是用户定义的。</target>
        </trans-unit>
        <trans-unit id="fd89c694ef19c6e785630016c5d715bce35c6076" translate="yes" xml:space="preserve">
          <source>Type is preserved for boolean arrays, so the result will contain &lt;code&gt;False&lt;/code&gt; when consecutive elements are the same and &lt;code&gt;True&lt;/code&gt; when they differ.</source>
          <target state="translated">类型是为布尔数组保留的，因此当连续元素相同时，结果将包含 &lt;code&gt;False&lt;/code&gt; ,而在连续元素不同时将包含 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c36d17e1133f5c5a545edd7db2e2ccd0a71a9cf5" translate="yes" xml:space="preserve">
          <source>Type of the data (integer, float, Python object, etc.)</source>
          <target state="translated">数据类型(整数、浮点数、Python对象等)</target>
        </trans-unit>
        <trans-unit id="dd429360d0a73315317719cd2b034bd7849c79e3" translate="yes" xml:space="preserve">
          <source>Type of the returned array and of the accumulator in which the elements are summed. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not specified, it defaults to the dtype of &lt;code&gt;a&lt;/code&gt;, unless &lt;code&gt;a&lt;/code&gt; has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.</source>
          <target state="translated">返回的数组和累加器的类型，元素在其中累加。如果&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;未指定，则默认为的D型 &lt;code&gt;a&lt;/code&gt; ，除非 &lt;code&gt;a&lt;/code&gt; 具有精度小于默认平台整数的整数D型。在这种情况下，将使用默认平台整数。</target>
        </trans-unit>
        <trans-unit id="07bc03c5a2d510ae05b611f9e4728e3dfbb4d656" translate="yes" xml:space="preserve">
          <source>Type of the returned array, as well as of the accumulator in which the elements are multiplied. If &lt;em&gt;dtype&lt;/em&gt; is not specified, it defaults to the dtype of &lt;code&gt;a&lt;/code&gt;, unless &lt;code&gt;a&lt;/code&gt; has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used instead.</source>
          <target state="translated">返回数组的类型，以及与元素相乘的累加器的类型。如果&lt;em&gt;D型&lt;/em&gt;未指定，则默认为的D型 &lt;code&gt;a&lt;/code&gt; ，除非 &lt;code&gt;a&lt;/code&gt; 具有精度小于默认平台整数的整数D型。在这种情况下，将使用默认平台整数。</target>
        </trans-unit>
        <trans-unit id="36795fd8406bf11fda0ac3128a88df4463dd2892" translate="yes" xml:space="preserve">
          <source>Type of the returned view, e.g., ndarray or matrix. Again, the default None results in type preservation.</source>
          <target state="translated">返回视图的类型,例如,ndarray或矩阵。同样,默认的None会导致类型保留。</target>
        </trans-unit>
        <trans-unit id="9d0b3189219da3d7ba109eef463be8e2071fbe7e" translate="yes" xml:space="preserve">
          <source>Type promotion in NumPy works similarly to the rules in languages like C++, with some slight differences. When both scalars and arrays are used, the array&amp;rsquo;s type takes precedence and the actual value of the scalar is taken into account.</source>
          <target state="translated">NumPy中的类型提升与C ++等语言中的规则类似，但略有不同。当同时使用标量和数组时，数组的类型优先，并且标量的实际值也要考虑在内。</target>
        </trans-unit>
        <trans-unit id="66585ef6b68c044b299bc7220f22788121e21167" translate="yes" xml:space="preserve">
          <source>Type provided:</source>
          <target state="translated">提供的类型:</target>
        </trans-unit>
        <trans-unit id="bc25fc1327a92506da2b55272b3113fcffa65d61" translate="yes" xml:space="preserve">
          <source>Type represents Boolean data type.</source>
          <target state="translated">类型代表布尔数据类型。</target>
        </trans-unit>
        <trans-unit id="60db025c166ec63b9a181b61c24b20c5d24b0648" translate="yes" xml:space="preserve">
          <source>Type represents a signed integer.</source>
          <target state="translated">类型代表一个有符号的整数。</target>
        </trans-unit>
        <trans-unit id="acb6256437982d272438054c848d82884163b4d8" translate="yes" xml:space="preserve">
          <source>Type represents a string data type.</source>
          <target state="translated">类型代表一个字符串数据类型。</target>
        </trans-unit>
        <trans-unit id="08f325041fae51a65ee6e08f868548827f3e2b61" translate="yes" xml:space="preserve">
          <source>Type represents a user-defined type.</source>
          <target state="translated">类型代表用户定义的类型。</target>
        </trans-unit>
        <trans-unit id="f5f87b05bbeb10ab3c2ec34871c51fb7f3e190f2" translate="yes" xml:space="preserve">
          <source>Type represents an enumerated type corresponding to one of the standard Python scalar (bool, int, float, or complex).</source>
          <target state="translated">Type 表示对应于标准 Python 标量之一的枚举类型 (bool、int、float 或 complex)。</target>
        </trans-unit>
        <trans-unit id="6fc847c0dbefe834d836a7b9b36c518b8a349fc4" translate="yes" xml:space="preserve">
          <source>Type represents an unsigned integer.</source>
          <target state="translated">类型代表一个无符号整数。</target>
        </trans-unit>
        <trans-unit id="f8e7a296ef6aceb534615bd823bf7fad61a5043e" translate="yes" xml:space="preserve">
          <source>Type represents any complex floating point number.</source>
          <target state="translated">类型代表任何复杂的浮点数。</target>
        </trans-unit>
        <trans-unit id="28cd3b87be44c11187d7cc10075315e307082083" translate="yes" xml:space="preserve">
          <source>Type represents any floating point number.</source>
          <target state="translated">类型代表任何浮点数。</target>
        </trans-unit>
        <trans-unit id="579601ba7e8ea9eb8623a33cadfe20f9eaea6f83" translate="yes" xml:space="preserve">
          <source>Type represents any integer, floating point, or complex floating point number.</source>
          <target state="translated">类型代表任何整数、浮点或复杂的浮点数。</target>
        </trans-unit>
        <trans-unit id="051ab06f1a62606ef03aadb95e9e56f705f31488" translate="yes" xml:space="preserve">
          <source>Type represents any integer.</source>
          <target state="translated">类型代表任何整数。</target>
        </trans-unit>
        <trans-unit id="a2ba1da5781162c52e0abb1d3993de06d380b834" translate="yes" xml:space="preserve">
          <source>Type represents object data type.</source>
          <target state="translated">类型代表对象数据类型。</target>
        </trans-unit>
        <trans-unit id="20eece7c06865b2554e5d1db1375400953d56528" translate="yes" xml:space="preserve">
          <source>Type represents one of the flexible array types ( &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">Type表示灵活数组类型之一（&lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt; &lt;code&gt;NPY_STRING&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt; &lt;code&gt;NPY_UNICODE&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt; &lt;code&gt;NPY_VOID&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cab551b16a69b24d82e03c4a0d668cc3040d4465" translate="yes" xml:space="preserve">
          <source>Type specific, core 1-d functions for ufuncs where each calculation is obtained by calling a function taking one input argument and returning one output. This function is passed in &lt;code&gt;func&lt;/code&gt;. The letters correspond to dtypechar&amp;rsquo;s of the supported data types ( &lt;code&gt;e&lt;/code&gt; - half, &lt;code&gt;f&lt;/code&gt; - float, &lt;code&gt;d&lt;/code&gt; - double, &lt;code&gt;g&lt;/code&gt; - long double, &lt;code&gt;F&lt;/code&gt; - cfloat, &lt;code&gt;D&lt;/code&gt; - cdouble, &lt;code&gt;G&lt;/code&gt; - clongdouble). The argument &lt;em&gt;func&lt;/em&gt; must support the same signature. The _As_X_X variants assume ndarray&amp;rsquo;s of one data type but cast the values to use an underlying function that takes a different data type. Thus, &lt;a href=&quot;#c.PyUFunc_f_f_As_d_d&quot;&gt;&lt;code&gt;PyUFunc_f_f_As_d_d&lt;/code&gt;&lt;/a&gt; uses ndarrays of data type &lt;a href=&quot;c-api.dtype#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; but calls out to a C-function that takes double and returns double.</source>
          <target state="translated">类型特定的ufunc核心1-d函数，其中的每个计算都是通过调用一个具有一个输入参数并返回一个输出的函数来获得的。该函数在 &lt;code&gt;func&lt;/code&gt; 中传递。字母对应于受支持的数据类型的dtypechar（ &lt;code&gt;e&lt;/code&gt; -一半， &lt;code&gt;f&lt;/code&gt; -浮点数， &lt;code&gt;d&lt;/code&gt; -两倍， &lt;code&gt;g&lt;/code&gt; -长双倍， &lt;code&gt;F&lt;/code&gt; -cfloat， &lt;code&gt;D&lt;/code&gt; -cdouble， &lt;code&gt;G&lt;/code&gt; -clongdouble）。参数&lt;em&gt;func&lt;/em&gt;必须支持相同的签名。 _As_X_X变体假定一种数据类型的ndarray，但将其值强制转换为使用具有不同数据类型的基础函数。因此，&lt;a href=&quot;#c.PyUFunc_f_f_As_d_d&quot;&gt; &lt;code&gt;PyUFunc_f_f_As_d_d&lt;/code&gt; &lt;/a&gt;使用数据类型为&lt;a href=&quot;c-api.dtype#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; 的ndarrays,&lt;/a&gt;但调用C函数，该函数需要double并返回double。</target>
        </trans-unit>
        <trans-unit id="2718d921f0c8c7bb73eed2147fee6ea79b6b6859" translate="yes" xml:space="preserve">
          <source>Type specific, core 1-d functions for ufuncs where each calculation is obtained by calling a function taking two input arguments and returning one output. The underlying function to call is passed in as &lt;em&gt;func&lt;/em&gt;. The letters correspond to dtypechar&amp;rsquo;s of the specific data type supported by the general-purpose function. The argument &lt;code&gt;func&lt;/code&gt; must support the corresponding signature. The &lt;code&gt;_As_XX_X&lt;/code&gt; variants assume ndarrays of one data type but cast the values at each iteration of the loop to use the underlying function that takes a different data type.</source>
          <target state="translated">类型特定的ufunc核心1-d函数，其中的每个计算都是通过调用带有两个输入参数并返回一个输出的函数来获得的。调用的基础函数作为&lt;em&gt;func&lt;/em&gt;传递。字母对应于通用功能支持的特定数据类型的dtypechar。参数 &lt;code&gt;func&lt;/code&gt; 必须支持相应的签名。所述 &lt;code&gt;_As_XX_X&lt;/code&gt; 变体假定一个数据类型的ndarrays但在循环中使用的底层函数采用不同的数据类型的每个迭代投的值。</target>
        </trans-unit>
        <trans-unit id="ef2ee12d948765f441a77e0dc116238b4eb26327" translate="yes" xml:space="preserve">
          <source>Type specifier strings are convertible to dtypes and can therefore be used instead of dtypes:</source>
          <target state="translated">类型指定符字符串可以转换为dtypes,因此可以代替dtypes使用。</target>
        </trans-unit>
        <trans-unit id="f7df157385540da09117c232afd23b684eee205b" translate="yes" xml:space="preserve">
          <source>Type strings</source>
          <target state="translated">字符串类型</target>
        </trans-unit>
        <trans-unit id="b6e792a3d08a7bd144dac10e42edb461fd3dd2e3" translate="yes" xml:space="preserve">
          <source>Type to use in computing the mean. For integer inputs, the default is &lt;code&gt;float64&lt;/code&gt;; for floating point inputs, it is the same as the input dtype.</source>
          <target state="translated">用于计算平均值的类型。对于整数输入，默认值为 &lt;code&gt;float64&lt;/code&gt; ；对于浮点输入，它与输入dtype相同。</target>
        </trans-unit>
        <trans-unit id="9f9df4fba8dcd1fb7d56164c04214c5a4ba9ba6b" translate="yes" xml:space="preserve">
          <source>Type to use in computing the mean. For integer inputs, the default is &lt;code&gt;float64&lt;/code&gt;; for inexact inputs, it is the same as the input dtype.</source>
          <target state="translated">用于计算平均值的类型。对于整数输入，默认值为 &lt;code&gt;float64&lt;/code&gt; ；对于不精确的输入，它与输入dtype相同。</target>
        </trans-unit>
        <trans-unit id="3131a42adb40886f91b9db8d1e4f4fee7e5c8913" translate="yes" xml:space="preserve">
          <source>Type to use in computing the standard deviation. For arrays of integer type the default is float64, for arrays of float types it is the same as the array type.</source>
          <target state="translated">计算标准差时使用的类型。对于整数类型的数组,默认为float64,对于浮动类型的数组,它与数组类型相同。</target>
        </trans-unit>
        <trans-unit id="80e97dffa22c435830b854e8d6fb1c6cb57a1b46" translate="yes" xml:space="preserve">
          <source>Type to use in computing the variance. For arrays of integer type</source>
          <target state="translated">计算方差时使用的类型。对于整数类型的数组</target>
        </trans-unit>
        <trans-unit id="c52f694878c4817d9cf0e30a93a5ac5c826ca338" translate="yes" xml:space="preserve">
          <source>Type to use in computing the variance. For arrays of integer type the default is &lt;code&gt;float32&lt;/code&gt;; for arrays of float types it is the same as the array type.</source>
          <target state="translated">用于计算方差的类型。对于整数类型的数组，默认值为 &lt;code&gt;float32&lt;/code&gt; ；对于float类型的数组，它与数组类型相同。</target>
        </trans-unit>
        <trans-unit id="d160c5845a8a77a5befb4851a7053d8bdf35eb94" translate="yes" xml:space="preserve">
          <source>Typecode or data-type to which the array is cast.</source>
          <target state="translated">数组被投向的类型代码或数据类型。</target>
        </trans-unit>
        <trans-unit id="23cf72e69c01c79ece86b50f4bc0e1b659346558" translate="yes" xml:space="preserve">
          <source>Typemap conversions for complex floating-point types is also not supported automatically. This is because Python and NumPy are written in C, which does not have native complex types. Both Python and NumPy implement their own (essentially equivalent) &lt;code&gt;struct&lt;/code&gt; definitions for complex variables:</source>
          <target state="translated">还不自动支持复杂浮点类型的Typemap转换。这是因为Python和NumPy是用C编写的，它没有本机复杂类型。Python和NumPy都为复杂变量实现了它们自己的（基本上等效的） &lt;code&gt;struct&lt;/code&gt; 定义：</target>
        </trans-unit>
        <trans-unit id="f2014cb40164abd5b9ac9cf3258c64ef343de062" translate="yes" xml:space="preserve">
          <source>Typemaps are keyed off a list of one or more function arguments, either by type or by type and name. We will refer to such lists as &lt;em&gt;signatures&lt;/em&gt;. One of the many typemaps defined by &lt;code&gt;numpy.i&lt;/code&gt; is used above and has the signature &lt;code&gt;(double* IN_ARRAY1, int DIM1)&lt;/code&gt;. The argument names are intended to suggest that the &lt;code&gt;double*&lt;/code&gt; argument is an input array of one dimension and that the &lt;code&gt;int&lt;/code&gt; represents the size of that dimension. This is precisely the pattern in the &lt;code&gt;rms&lt;/code&gt; prototype.</source>
          <target state="translated">类型映射从一个或多个函数参数的列表中键入（按类型或类型和名称）。我们将这些列表称为&lt;em&gt;签名&lt;/em&gt;。上面使用了numpy.i定义的许多类型映射 &lt;code&gt;numpy.i&lt;/code&gt; ，并且具有签名 &lt;code&gt;(double* IN_ARRAY1, int DIM1)&lt;/code&gt; 。参数名称旨在建议 &lt;code&gt;double*&lt;/code&gt; 参数是一维的输入数组，而 &lt;code&gt;int&lt;/code&gt; 表示该维的大小。这正是 &lt;code&gt;rms&lt;/code&gt; 原型中的模式。</target>
        </trans-unit>
        <trans-unit id="908f34305dca26ca1d02c401b17bcc9125b1ab5c" translate="yes" xml:space="preserve">
          <source>Types with &lt;code&gt;.dtype&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.dtype&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="translated">典型用途:</target>
        </trans-unit>
        <trans-unit id="e390f0c6d81411459ef6be418905b3473133c360" translate="yes" xml:space="preserve">
          <source>Typically a &amp;lsquo;greedy&amp;rsquo; algorithm is applied which empirical tests have shown returns the optimal path in the majority of cases. In some cases &amp;lsquo;optimal&amp;rsquo; will return the superlative path through a more expensive, exhaustive search. For iterative calculations it may be advisable to calculate the optimal path once and reuse that path by supplying it as an argument. An example is given below.</source>
          <target state="translated">通常，采用&amp;ldquo;贪心&amp;rdquo;算法，根据经验测试，该算法在大多数情况下会返回最佳路径。在某些情况下，&amp;ldquo;最优&amp;rdquo;将通过更昂贵，更详尽的搜索返回最高级路径。对于迭代计算，建议一次计算最佳路径并通过将其作为参数提供来重用该路径。下面给出一个例子。</target>
        </trans-unit>
        <trans-unit id="291bb923a1cf51e55db8c8127cc92200f5117732" translate="yes" xml:space="preserve">
          <source>Typically these new versions of the array metadata but the same data buffer are new &amp;lsquo;views&amp;rsquo; into the data buffer. There is a different ndarray object, but it uses the same data buffer. This is why it is necessary to force copies through use of the .copy() method if one really wants to make a new and independent copy of the data buffer.</source>
          <target state="translated">通常，这些新版本的数组元数据和相同的数据缓冲区是数据缓冲区的新&amp;ldquo;视图&amp;rdquo;。有一个不同的ndarray对象，但是它使用相同的数据缓冲区。这就是为什么如果真的想制作一个新的独立的数据缓冲区副本，则必须通过使用.copy（）方法来强制进行复制的原因。</target>
        </trans-unit>
        <trans-unit id="54a23bec4dd6b17bf03f7139f1786ecb950b41b8" translate="yes" xml:space="preserve">
          <source>Typically this value will be one more than what you might expect because all ufuncs take the optional &amp;ldquo;out&amp;rdquo; argument.</source>
          <target state="translated">通常，此值将比您期望的值大一个，因为所有ufunc都采用可选的&amp;ldquo; out&amp;rdquo;参数。</target>
        </trans-unit>
        <trans-unit id="3fadc3f723273062c4d9c5a6483a39eed14f9c66" translate="yes" xml:space="preserve">
          <source>Typically, the size of all core dimensions in an output will be determined by the size of a core dimension with the same label in an input array. This is not a requirement, and it is possible to define a signature where a label comes up for the first time in an output, although some precautions must be taken when calling such a function. An example would be the function &lt;code&gt;euclidean_pdist(a)&lt;/code&gt;, with signature &lt;code&gt;(n,d)-&amp;gt;(p)&lt;/code&gt;, that given an array of &lt;code&gt;n&lt;/code&gt;&lt;code&gt;d&lt;/code&gt;-dimensional vectors, computes all unique pairwise Euclidean distances among them. The output dimension &lt;code&gt;p&lt;/code&gt; must therefore be equal to &lt;code&gt;n * (n - 1) / 2&lt;/code&gt;, but it is the caller&amp;rsquo;s responsibility to pass in an output array of the right size. If the size of a core dimension of an output cannot be determined from a passed in input or output array, an error will be raised.</source>
          <target state="translated">通常，输出中所有核心尺寸的大小将由输入数组中具有相同标签的核心尺寸的大小确定。这不是必需的，并且可以定义一个签名，在该签名中输出中第一次出现标签，尽管在调用此类函数时必须采取一些预防措施。一个示例是具有签名 &lt;code&gt;(n,d)-&amp;gt;(p)&lt;/code&gt; 的函数 &lt;code&gt;euclidean_pdist(a)&lt;/code&gt; ，该函数给定 &lt;code&gt;n&lt;/code&gt; &lt;code&gt;d&lt;/code&gt; 维矢量的数组，计算其中所有唯一的成对欧几里德距离。因此，输出尺寸 &lt;code&gt;p&lt;/code&gt; 必须等于 &lt;code&gt;n * (n - 1) / 2&lt;/code&gt; ，但是传递正确大小的输出数组是调用者的责任。如果无法根据传入的输入或输出数组确定输出核心尺寸的大小，则会产生错误。</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="054ec2a1c571b996a33a40629d7bbd3a2c7c7a03" translate="yes" xml:space="preserve">
          <source>UFUNC_CHECK_ERROR()</source>
          <target state="translated">UFUNC_CHECK_ERROR()</target>
        </trans-unit>
        <trans-unit id="d2291265ceb8694acf9ebd2a0083ea66791f6665" translate="yes" xml:space="preserve">
          <source>UFUNC_CHECK_STATUS()</source>
          <target state="translated">UFUNC_CHECK_STATUS()</target>
        </trans-unit>
        <trans-unit id="7c45c7778c0f3c31bbfb06962ea0f2b3d024a473" translate="yes" xml:space="preserve">
          <source>UFUNC_ERR_{HANDLER}</source>
          <target state="translated">UFUNC_ERR_{HANDLER}</target>
        </trans-unit>
        <trans-unit id="46518eb931ec8d24ef410f576a7160b8b457bb69" translate="yes" xml:space="preserve">
          <source>UFunc API</source>
          <target state="translated">UFunc API</target>
        </trans-unit>
        <trans-unit id="779cd7c4bcd3367298526e617162cab51fe8f735" translate="yes" xml:space="preserve">
          <source>UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;</source>
          <target state="translated">UPDATEIFCOPY (U)(已废弃),被WRITEBACKIFCOPY取代。</target>
        </trans-unit>
        <trans-unit id="4eab2a5ea17917129ec8fa19b15a7cfda3fe1d46" translate="yes" xml:space="preserve">
          <source>UPDATEIFCOPY / U</source>
          <target state="translated">UPDATEIFCOPY/U</target>
        </trans-unit>
        <trans-unit id="8c955f87125d1d07da79b0f8b10f03f3519e41af" translate="yes" xml:space="preserve">
          <source>UPDATEIFCOPY can only be set &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">UPDATEIFCOPY只能设置为 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7033cb6e00b408f93174a1cb4dc874e5ec8f4436" translate="yes" xml:space="preserve">
          <source>URLs require a scheme string (&lt;code&gt;http://&lt;/code&gt;) to be used, without it they will fail:</source>
          <target state="translated">URL需要使用方案字符串（ &lt;code&gt;http://&lt;/code&gt; ），否则将失败：</target>
        </trans-unit>
        <trans-unit id="01787e5708f1880517c980a345514f0ac0d4f3a1" translate="yes" xml:space="preserve">
          <source>Ufuncs allow other array-like classes to be passed seamlessly through the interface in that inputs of a particular class will induce the outputs to be of that same class. The mechanism by which this works is the following. If any of the inputs are not ndarrays and define the &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method, then the class with the largest &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; attribute determines the type of all the outputs (with the exception of any output arrays passed in). The &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method of the input array will be called with the ndarray being returned from the ufunc as it&amp;rsquo;s input. There are two calling styles of the &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; function supported. The first takes the ndarray as the first argument and a tuple of &amp;ldquo;context&amp;rdquo; as the second argument. The context is (ufunc, arguments, output argument number). This is the first call tried. If a TypeError occurs, then the function is called with just the ndarray as the first argument.</source>
          <target state="translated">Ufunc允许其他类似数组的类通过接口无缝传递，因为特定类的输入将导致输出属于同一类。其工作机制如下。如果有任何的输入不是ndarrays并定义&lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;方法，则具有最大的类&lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;属性确定所有输出的类型（与传递的任何输出阵列的除外）。所述&lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;输入数组的方法将用来自ufunc因为它的输入返回的感ndarray被调用。&lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;有两种调用样式功能支持。第一个将ndarray作为第一个参数，将&amp;ldquo; context&amp;rdquo;的元组作为第二个参数。上下文是（ufunc，自变量，输出自变量编号）。这是第一次尝试通话。如果发生TypeError，则仅使用ndarray作为第一个参数来调用该函数。</target>
        </trans-unit>
        <trans-unit id="bb1e7beaee60184f94b2766ad490881fcda15d1a" translate="yes" xml:space="preserve">
          <source>Ufuncs also have a fifth method that allows in place operations to be performed using fancy indexing. No buffering is used on the dimensions where fancy indexing is used, so the fancy index can list an item more than once and the operation will be performed on the result of the previous operation for that item.</source>
          <target state="translated">Ufuncs还有第五种方法,可以使用花式索引进行到位操作。在使用花式索引的维度上不使用缓冲,所以花式索引可以不止一次地列出一个项目,并且会对该项目的前一次操作结果进行操作。</target>
        </trans-unit>
        <trans-unit id="ebe1370731077d311895107006a4816f68d36e75" translate="yes" xml:space="preserve">
          <source>Ufuncs: If the &lt;code&gt;ALIGNED&lt;/code&gt; flag of an array is False, ufuncs will buffer/cast the array before evaluation. This is needed since ufunc inner loops access raw elements directly, which might fail on some archs if the elements are not true-aligned.</source>
          <target state="translated">Ufuncs：如果数组的 &lt;code&gt;ALIGNED&lt;/code&gt; 标志为False，则Ufuncs将在评估之前缓冲/广播该数组。这是必需的，因为ufunc内部循环直接访问原始元素，如果元素未真正对齐，则在某些拱形上可能会失败。</target>
        </trans-unit>
        <trans-unit id="52313eed90dffcad6d336fc2df812a51c07afa3f" translate="yes" xml:space="preserve">
          <source>Un-sized flexible data-type objects do not have this attribute.</source>
          <target state="translated">非大小灵活的数据类型对象没有这个属性。</target>
        </trans-unit>
        <trans-unit id="b7fcaea31c03023df34e5b7b17cd0d3a054b94c0" translate="yes" xml:space="preserve">
          <source>Unary operations:</source>
          <target state="translated">单元操作。</target>
        </trans-unit>
        <trans-unit id="56332d95dfcc595c6bea8676636a72713f221f0a" translate="yes" xml:space="preserve">
          <source>Underflow: result so close to zero that some precision was lost.</source>
          <target state="translated">下溢:结果如此接近于零,以至于损失了一些精度。</target>
        </trans-unit>
        <trans-unit id="de8fa4e24f45bc650b9e48b7af77833b4a2c462a" translate="yes" xml:space="preserve">
          <source>Undoes &lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;, shifts zero-frequency terms to beginning of array.</source>
          <target state="translated">撤消&lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt;，将零频率项移到数组的开头。</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="4fee0b7959c07c12abdb6224e31004ed0e03fe8f" translate="yes" xml:space="preserve">
          <source>Unicode (fixed-length sequence of &lt;a href=&quot;https://docs.python.org/dev/c-api/unicode.html#c.Py_UNICODE&quot;&gt;&lt;code&gt;Py_UNICODE&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">Unicode（&lt;a href=&quot;https://docs.python.org/dev/c-api/unicode.html#c.Py_UNICODE&quot;&gt; &lt;code&gt;Py_UNICODE&lt;/code&gt; 的&lt;/a&gt;固定长度序列）</target>
        </trans-unit>
        <trans-unit id="1b41da839119c4860ed2bab536f19149822ad0f7" translate="yes" xml:space="preserve">
          <source>Unicode string</source>
          <target state="translated">统一码字符串</target>
        </trans-unit>
        <trans-unit id="b817c790c0e1eb2da135f6728ba7e7a734d36d2a" translate="yes" xml:space="preserve">
          <source>Uniforms</source>
          <target state="translated">Uniforms</target>
        </trans-unit>
        <trans-unit id="bd181d4ea0c5f747e6be59067008be3f6a568280" translate="yes" xml:space="preserve">
          <source>Uniforms (&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.random.generator.integers#numpy.random.Generator.integers&quot;&gt;&lt;code&gt;integers&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">制服（&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;generated/numpy.random.generator.integers#numpy.random.Generator.integers&quot;&gt; &lt;code&gt;integers&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="7d19a005048195442e1a0367112ec40ef36c8dd2" translate="yes" xml:space="preserve">
          <source>Unique, sorted union of the input arrays.</source>
          <target state="translated">输入数组的唯一、排序联合。</target>
        </trans-unit>
        <trans-unit id="76a96316e226896e4f1438a10bfe2c7d74733b0a" translate="yes" xml:space="preserve">
          <source>Unit Conversion</source>
          <target state="translated">单位换算</target>
        </trans-unit>
        <trans-unit id="2b379c9399e276f2dc8f9383decfb02923fa06dd" translate="yes" xml:space="preserve">
          <source>Unitary array(s). The first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions have the same size as those of the input &lt;code&gt;a&lt;/code&gt;. The size of the last two dimensions depends on the value of &lt;code&gt;full_matrices&lt;/code&gt;. Only returned when &lt;code&gt;compute_uv&lt;/code&gt; is True.</source>
          <target state="translated">单一数组。前 &lt;code&gt;a.ndim - 2&lt;/code&gt; 维的大小与输入 &lt;code&gt;a&lt;/code&gt; 的大小相同。最后两个维度的大小取决于 &lt;code&gt;full_matrices&lt;/code&gt; 的值。仅在 &lt;code&gt;compute_uv&lt;/code&gt; 为True 时返回。</target>
        </trans-unit>
        <trans-unit id="89952e170b7f249d54c02c56dc948ea92d581887" translate="yes" xml:space="preserve">
          <source>Universal Functions</source>
          <target state="translated">通用功能</target>
        </trans-unit>
        <trans-unit id="c4ed03ac8db5e6ac9dfa92939a06553bcbad44ab" translate="yes" xml:space="preserve">
          <source>Universal functions</source>
          <target state="translated">通用功能</target>
        </trans-unit>
        <trans-unit id="e3950ded82824788c1d59c1dc67f67776133fd02" translate="yes" xml:space="preserve">
          <source>Universal functions (&lt;code&gt;ufunc&lt;/code&gt;)</source>
          <target state="translated">通用功能（ &lt;code&gt;ufunc&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="825ac503579fb05389d22b5b4afa49b44dc3e914" translate="yes" xml:space="preserve">
          <source>Universal functions (ufunc)</source>
          <target state="translated">通用功能(ufunc)</target>
        </trans-unit>
        <trans-unit id="1c8ff35a75bf6e5497766666bbe2a77eb53892e4" translate="yes" xml:space="preserve">
          <source>Universal functions are callable objects that take</source>
          <target state="translated">通用函数是可调用的对象,它们以</target>
        </trans-unit>
        <trans-unit id="14ef4c614fdbba7fe91a08e7e1d79eb5845cd489" translate="yes" xml:space="preserve">
          <source>Universal functions can trip special floating-point status registers in your hardware (such as divide-by-zero). If available on your platform, these registers will be regularly checked during calculation. Error handling is controlled on a per-thread basis, and can be configured using the functions</source>
          <target state="translated">通用函数可以跳转你的硬件中的特殊浮点状态寄存器(如除以零)。如果你的平台上有这些寄存器,那么在计算过程中会定期检查。错误处理是在每个线程的基础上进行控制的,可以使用函数</target>
        </trans-unit>
        <trans-unit id="f2a6f922fe59febd69c7ec0550beca70f253abf6" translate="yes" xml:space="preserve">
          <source>Universal functions in NumPy are flexible enough to have mixed type signatures. Thus, for example, a universal function could be defined that works with floating-point and integer values. See &lt;a href=&quot;generated/numpy.ldexp#numpy.ldexp&quot;&gt;&lt;code&gt;ldexp&lt;/code&gt;&lt;/a&gt; for an example.</source>
          <target state="translated">NumPy中的通用函数足够灵活，可以具有混合类型签名。因此，例如，可以定义一个通用函数，该函数可用于浮点数和整数值。有关&lt;a href=&quot;generated/numpy.ldexp#numpy.ldexp&quot;&gt; &lt;code&gt;ldexp&lt;/code&gt; &lt;/a&gt;，请参见ldexp。</target>
        </trans-unit>
        <trans-unit id="dc2928ef9066faa49b65eacee08cc9ff5b8df03a" translate="yes" xml:space="preserve">
          <source>Unlabeled tests like the ones above are run in the default &lt;code&gt;scipy.test()&lt;/code&gt; run. If you want to label your test as slow - and therefore reserved for a full &lt;code&gt;scipy.test(label='full')&lt;/code&gt; run, you can label it with a decorator:</source>
          <target state="translated">如上的未标记测试在默认的 &lt;code&gt;scipy.test()&lt;/code&gt; 运行中运行。如果您想将测试标记为缓慢-因此保留用于完整的 &lt;code&gt;scipy.test(label='full')&lt;/code&gt; 运行，则可以使用装饰器将其标记为：</target>
        </trans-unit>
        <trans-unit id="f80a919f246626907387dd0726bbe89b8b51b4df" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">除非&lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;为False且满足返回输入数组的其他条件（请参见&lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;输入参数的描述）， &lt;code&gt;arr_t&lt;/code&gt; 是形状与输入数组相同的新数组，其类型为dtype，顺序为&lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef7dd27d4664eeedf99baaa7e0c49db6deaa478b" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">除非&lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;为False且满足返回输入数组的其他条件（请参见&lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;输入参数的描述）， &lt;code&gt;arr_t&lt;/code&gt; 是形状与输入数组相同的新数组，其类型为dtype，顺序为&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd72f00597798516e6971a2dbcb92a29bbbdaed9" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">除非&lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;为False且满足返回输入数组的其他条件（请参见&lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;输入参数的描述）， &lt;code&gt;arr_t&lt;/code&gt; 是形状与输入数组相同的新数组，其类型为dtype，顺序为&lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e2517e50c2cd18f9fa374a65d4b11b6882475bf" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;refcheck&lt;/code&gt; is False:</source>
          <target state="translated">除非 &lt;code&gt;refcheck&lt;/code&gt; 为False：</target>
        </trans-unit>
        <trans-unit id="b12a052540dd37bc0bf5e60cc41fc32cdcbd4cfa" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt;&lt;code&gt;numpy.equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">与&lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt; &lt;code&gt;numpy.equal&lt;/code&gt; &lt;/a&gt;不同，此比较是通过首先从字符串末尾去除空格字符来执行的。提供此行为是为了与numarray向后兼容。</target>
        </trans-unit>
        <trans-unit id="6b2b2c64bbd5177dd4a58ffb6ba3be3f39244e9c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.fft.fftfreq#numpy.fft.fftfreq&quot;&gt;&lt;code&gt;fftfreq&lt;/code&gt;&lt;/a&gt; (but like &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.rfftfreq.html#scipy.fftpack.rfftfreq&quot;&gt;&lt;code&gt;scipy.fftpack.rfftfreq&lt;/code&gt;&lt;/a&gt;) the Nyquist frequency component is considered to be positive.</source>
          <target state="translated">与&lt;a href=&quot;numpy.fft.fftfreq#numpy.fft.fftfreq&quot;&gt; &lt;code&gt;fftfreq&lt;/code&gt; &lt;/a&gt;（但类似于&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.rfftfreq.html#scipy.fftpack.rfftfreq&quot;&gt; &lt;code&gt;scipy.fftpack.rfftfreq&lt;/code&gt; &lt;/a&gt;）不同，奈奎斯特频率分量被认为是正数。</target>
        </trans-unit>
        <trans-unit id="5f3a2cd1365b2531abc2f011c55c5607d024f719" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.greater#numpy.greater&quot;&gt;&lt;code&gt;numpy.greater&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">与&lt;a href=&quot;numpy.greater#numpy.greater&quot;&gt; &lt;code&gt;numpy.greater&lt;/code&gt; &lt;/a&gt;不同，此比较是通过首先从字符串末尾去除空格字符来执行的。提供此行为是为了与numarray向后兼容。</target>
        </trans-unit>
        <trans-unit id="8db96ae1e185ea43483bbcf2e2a064fdf5d5ac53" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.greater_equal#numpy.greater_equal&quot;&gt;&lt;code&gt;numpy.greater_equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">与&lt;a href=&quot;numpy.greater_equal#numpy.greater_equal&quot;&gt; &lt;code&gt;numpy.greater_equal&lt;/code&gt; &lt;/a&gt;不同，此比较是通过首先从字符串末尾去除空格字符来执行的。提供此行为是为了与numarray向后兼容。</target>
        </trans-unit>
        <trans-unit id="cc98934fa39c9d5a378edf27cd9d3fdf09aca64f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.less_equal#numpy.less_equal&quot;&gt;&lt;code&gt;numpy.less_equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">与&lt;a href=&quot;numpy.less_equal#numpy.less_equal&quot;&gt; &lt;code&gt;numpy.less_equal&lt;/code&gt; &lt;/a&gt;不同，此比较是通过首先从字符串末尾去除空格字符来执行的。提供此行为是为了与numarray向后兼容。</target>
        </trans-unit>
        <trans-unit id="13463cefef0c63fb378a22fb3869ee59d3559110" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.asmatrix&quot;&gt;&lt;code&gt;asmatrix&lt;/code&gt;&lt;/a&gt; does not make a copy if the input is already a matrix or an ndarray. Equivalent to &lt;code&gt;matrix(data, copy=False)&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;不同，如果输入已经是矩阵或ndarray ，则&lt;a href=&quot;#numpy.asmatrix&quot;&gt; &lt;code&gt;asmatrix&lt;/code&gt; &lt;/a&gt;不会复制。等效于 &lt;code&gt;matrix(data, copy=False)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0d5bc239c5d20908848ae252443d0a4e4413dd3" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.asmatrix#numpy.asmatrix&quot;&gt;&lt;code&gt;asmatrix&lt;/code&gt;&lt;/a&gt; does not make a copy if the input is already a matrix or an ndarray. Equivalent to &lt;code&gt;matrix(data, copy=False)&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;不同，如果输入已经是矩阵或ndarray ，则&lt;a href=&quot;numpy.asmatrix#numpy.asmatrix&quot;&gt; &lt;code&gt;asmatrix&lt;/code&gt; &lt;/a&gt;不会复制。等效于 &lt;code&gt;matrix(data, copy=False)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5b1299452ddecaa69fc7626dc84ab62f7aec6df" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.not_equal#numpy.not_equal&quot;&gt;&lt;code&gt;numpy.not_equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">与&lt;a href=&quot;numpy.not_equal#numpy.not_equal&quot;&gt; &lt;code&gt;numpy.not_equal&lt;/code&gt; &lt;/a&gt;不同，此比较是通过首先从字符串末尾去除空格字符来执行的。提供此行为是为了与numarray向后兼容。</target>
        </trans-unit>
        <trans-unit id="70d4d959a48f1152d15702553262318c5fb98806" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Chebyshev series is a Chebyshev series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个Chebyshev级数的差是一个Chebyshev级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此减法就像&amp;ldquo;标准&amp;rdquo;多项式一样，只是&amp;ldquo;按分量&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="e46cc304c2f214fabbfe81dd6c99872edb6df227" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Hermite series is a Hermite series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个Hermite级数的差是一个Hermite级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此减法就像&amp;ldquo;标准&amp;rdquo;多项式的减法一样，只是&amp;ldquo;按分量进行&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0beee9ca9d008b84130a4966827a4791db0f0fc1" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Laguerre series is a Laguerre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个Laguerre级数的差是Laguerre级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此减法就像&amp;ldquo;标准&amp;rdquo;多项式一样，只是&amp;ldquo;按分量进行&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="853913b39ae1eac706caf9dd0fbf8022480e5898" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Legendre series is a Legendre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个勒让德级数的差是勒让德级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此减法就像&amp;ldquo;标准&amp;rdquo;多项式一样，只是&amp;ldquo;按分量&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="817c653b37e40c515ff2966447fe5fceb6d50c2b" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Chebyshev series is a Chebyshev series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个Chebyshev级数的和是一个Chebyshev级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此加法就像&amp;ldquo;标准&amp;rdquo;多项式的加法一样，只是&amp;ldquo;逐分量&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="96e94bebc99e72aa93e0ba2b3e9d976f9a242788" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Hermite series is a Hermite series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个Hermite系列的总和是一个Hermite系列（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此加法就像&amp;ldquo;标准&amp;rdquo;多项式的加法一样，只是&amp;ldquo;按分量进行&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="a1bfae60ca127fe23c05d0fcb5e3af8c025e808e" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Laguerre series is a Laguerre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个Laguerre级数的和是Laguerre级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此加法就像&amp;ldquo;标准&amp;rdquo;多项式的加法一样，只是&amp;ldquo;逐分量&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="479fccdc37cae736330d681081d02fd22d2b4c05" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Legendre series is a Legendre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个勒让德级数的总和是勒让德级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此加法就像&amp;ldquo;标准&amp;rdquo;多项式的加法一样，只是&amp;ldquo;按分量进行&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="6138c52b3d14f1f06df9ad9cd32f8b7c13aad36f" translate="yes" xml:space="preserve">
          <source>Unlike the built-in &lt;a href=&quot;https://docs.python.org/dev/library/math.html#math.isclose&quot;&gt;&lt;code&gt;math.isclose&lt;/code&gt;&lt;/a&gt;, the above equation is not symmetric in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; &amp;ndash; it assumes &lt;code&gt;b&lt;/code&gt; is the reference value &amp;ndash; so that &lt;code&gt;isclose(a, b)&lt;/code&gt; might be different from &lt;code&gt;isclose(b, a)&lt;/code&gt;. Furthermore, the default value of atol is not zero, and is used to determine what small values should be considered close to zero. The default value is appropriate for expected values of order unity: if the expected values are significantly smaller than one, it can result in false positives. &lt;code&gt;atol&lt;/code&gt; should be carefully selected for the use case at hand. A zero value for &lt;code&gt;atol&lt;/code&gt; will result in &lt;code&gt;False&lt;/code&gt; if either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is zero.</source>
          <target state="translated">与内置&lt;a href=&quot;https://docs.python.org/dev/library/math.html#math.isclose&quot;&gt; &lt;code&gt;math.isclose&lt;/code&gt; 不同&lt;/a&gt;，上述方程式在 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 中不对称-假定 &lt;code&gt;b&lt;/code&gt; 是参考值-因此 &lt;code&gt;isclose(a, b)&lt;/code&gt; 可能与 &lt;code&gt;isclose(b, a)&lt;/code&gt; 。此外，atol的默认值不为零，用于确定应将哪些较小的值视为接近零。默认值适用于阶数为1的期望值：如果期望值明显小于1，则可能导致误报。应该仔细选择 &lt;code&gt;atol&lt;/code&gt; 作为手边的用例。零值 &lt;code&gt;atol&lt;/code&gt; 会导致 &lt;code&gt;False&lt;/code&gt; 如果任 &lt;code&gt;a&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt; 为零。</target>
        </trans-unit>
        <trans-unit id="b9b43bc2298a20c8156a6023d94ab148e7869ea1" translate="yes" xml:space="preserve">
          <source>Unlike the free function &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, this method on &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; allows the elements of the shape parameter to be passed in as separate arguments. For example, &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; is equivalent to &lt;code&gt;a.reshape((10, 11))&lt;/code&gt;.</source>
          <target state="translated">不同于免费功能&lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt;，在此方法&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;允许形状参数中的元素，以作为单独的参数传递。例如， &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; 等效于 &lt;code&gt;a.reshape((10, 11))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c055ec1da31f5b3a36529d3d52329cd0cef8c5de" translate="yes" xml:space="preserve">
          <source>Unlike the free function &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, this method on &lt;code&gt;ndarray&lt;/code&gt; allows the elements of the shape parameter to be passed in as separate arguments. For example, &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; is equivalent to &lt;code&gt;a.reshape((10, 11))&lt;/code&gt;.</source>
          <target state="translated">不同于免费功能&lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt;，在此方法 &lt;code&gt;ndarray&lt;/code&gt; 允许形状参数中的元素，以作为单独的参数传递。例如， &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; 等效于 &lt;code&gt;a.reshape((10, 11))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0206a9a6a08e980ce9de3768f0db78bc718405ea" translate="yes" xml:space="preserve">
          <source>Unlike the standard numpy comparison operators, the ones in the &lt;code&gt;char&lt;/code&gt; module strip trailing whitespace characters before performing the comparison.</source>
          <target state="translated">与标准numpy比较运算符不同， &lt;code&gt;char&lt;/code&gt; 模块中的运算符在执行比较之前会删除尾随空白字符。</target>
        </trans-unit>
        <trans-unit id="7fbacb4b6a81b741ccf818cdd058fa9d9f52d43b" translate="yes" xml:space="preserve">
          <source>Unmasking an entry</source>
          <target state="translated">解除屏蔽条目</target>
        </trans-unit>
        <trans-unit id="c37a5ee094534c733a693e498e6b83c12096d6e0" translate="yes" xml:space="preserve">
          <source>Unmasking an entry by direct assignment will silently fail if the masked array has a &lt;em&gt;hard&lt;/em&gt; mask, as shown by the &lt;code&gt;hardmask&lt;/code&gt; attribute. This feature was introduced to prevent overwriting the mask. To force the unmasking of an entry where the array has a hard mask, the mask must first to be softened using the &lt;a href=&quot;generated/numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt;&lt;code&gt;soften_mask&lt;/code&gt;&lt;/a&gt; method before the allocation. It can be re-hardened with &lt;a href=&quot;generated/numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt;&lt;code&gt;harden_mask&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果被掩码的数组具有&lt;em&gt;硬&lt;/em&gt;掩码，则通过直接分配取消对条目的掩码将自动失败，如 &lt;code&gt;hardmask&lt;/code&gt; 属性所示。引入此功能是为了防止覆盖掩码。要在阵列具有硬掩码的情况下强制取消条目的掩码，必须先在分配之前使用&lt;a href=&quot;generated/numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt; &lt;code&gt;soften_mask&lt;/code&gt; &lt;/a&gt;方法将掩码软化。可以使用&lt;a href=&quot;generated/numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt; &lt;code&gt;harden_mask&lt;/code&gt; &lt;/a&gt;重新加固它：</target>
        </trans-unit>
        <trans-unit id="5724dd60c593622fc16f28573a8be39237c1817b" translate="yes" xml:space="preserve">
          <source>Unmodified core dimensions that share the same name must have the same size. Each dimension name typically corresponds to one level of looping in the elementary function&amp;rsquo;s implementation.</source>
          <target state="translated">具有相同名称的未修改核心尺寸必须具有相同的大小。每个维名称通常对应于基本函数实现中的一个循环级别。</target>
        </trans-unit>
        <trans-unit id="0c8c8df9f7c1cb71b2c99863e55f28b2342c49c8" translate="yes" xml:space="preserve">
          <source>Unpacks elements of a uint8 array into a binary-valued output array.</source>
          <target state="translated">将一个uint8数组中的元素解包成一个二进制值的输出数组。</target>
        </trans-unit>
        <trans-unit id="9b27e09825b38c1619e31484868bfeb48e96d8d2" translate="yes" xml:space="preserve">
          <source>Unsigned integer</source>
          <target state="translated">无符号整数</target>
        </trans-unit>
        <trans-unit id="432373371510943ee2651ebf21148b86384d0a29" translate="yes" xml:space="preserve">
          <source>Unsigned integers:</source>
          <target state="translated">无符号整数。</target>
        </trans-unit>
        <trans-unit id="c824dd22d12bde4feee6277b067eb0b05fa4fdf1" translate="yes" xml:space="preserve">
          <source>Unsigned versions of the integers can be defined by pre-pending a &amp;lsquo;u&amp;rsquo; to the front of the integer name.</source>
          <target state="translated">整数的无符号版本可以通过在整数名称的前面添加&amp;ldquo; u&amp;rdquo;来定义。</target>
        </trans-unit>
        <trans-unit id="91aa49f62879d325c6707e96a59652eaa942e8ca" translate="yes" xml:space="preserve">
          <source>Until the 1.15 release, NumPy used the &lt;a href=&quot;https://nose.readthedocs.io/en/latest/&quot;&gt;nose&lt;/a&gt; testing framework, it now uses the &lt;a href=&quot;https://pytest.readthedocs.io&quot;&gt;pytest&lt;/a&gt; framework. The older framework is still maintained in order to support downstream projects that use the old numpy framework, but all tests for NumPy should use pytest.</source>
          <target state="translated">在1.15版之前，NumPy使用&lt;a href=&quot;https://nose.readthedocs.io/en/latest/&quot;&gt;鼻子&lt;/a&gt;测试框架，现在使用&lt;a href=&quot;https://pytest.readthedocs.io&quot;&gt;pytest&lt;/a&gt;框架。为了支持使用旧numpy框架的下游项目，仍旧维护旧框架，但是所有针对NumPy的测试都应使用pytest。</target>
        </trans-unit>
        <trans-unit id="f13be7738e1389f72c0f88aa84d17719f746bf4a" translate="yes" xml:space="preserve">
          <source>Unused.</source>
          <target state="translated">Unused.</target>
        </trans-unit>
        <trans-unit id="91235b6cec5e2bdecb806fae5c6f1c673c46dd54" translate="yes" xml:space="preserve">
          <source>Unwrap by changing deltas between values to 2*pi complement.</source>
          <target state="translated">将数值之间的三角区改为2*pi补全,就可以解开。</target>
        </trans-unit>
        <trans-unit id="cba2ade8e0d37d0f36a249f716f7633b555a4616" translate="yes" xml:space="preserve">
          <source>Unwrap radian phase &lt;code&gt;p&lt;/code&gt; by changing absolute jumps greater than &lt;code&gt;discont&lt;/code&gt; to their 2*pi complement along the given axis.</source>
          <target state="translated">通过改变大于给定轴上2 * pi补码的绝对跳 &lt;code&gt;discont&lt;/code&gt; 来解开弧度相位 &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31f87bfbdb61e41f06f9d6ba5c2c33b85dec73cd" translate="yes" xml:space="preserve">
          <source>Upcasting:</source>
          <target state="translated">Upcasting:</target>
        </trans-unit>
        <trans-unit id="777088119e41bc0469a64ccb283496abe08bc95e" translate="yes" xml:space="preserve">
          <source>Updated version of PyArray_Correlate, which uses the usual definition of correlation for 1d arrays. The correlation is computed at each output point by multiplying &lt;em&gt;op1&lt;/em&gt; by a shifted version of &lt;em&gt;op2&lt;/em&gt; and summing the result. As a result of the shift, needed values outside of the defined range of &lt;em&gt;op1&lt;/em&gt; and &lt;em&gt;op2&lt;/em&gt; are interpreted as zero. The mode determines how many shifts to return: 0 - return only shifts that did not need to assume zero- values; 1 - return an object that is the same size as &lt;em&gt;op1&lt;/em&gt;, 2 - return all possible shifts (any overlap at all is accepted).</source>
          <target state="translated">PyArray_Correlate的更新版本，它使用一维数组的常规相关定义。通过将&lt;em&gt;op1&lt;/em&gt;乘以&lt;em&gt;op2&lt;/em&gt;的移位版本并求和，可以在每个输出点计算相关性。移位的结果是，超出&lt;em&gt;op1&lt;/em&gt;和&lt;em&gt;op2&lt;/em&gt;定义范围的所需值被解释为零。该模式确定要返回的班次：0-仅返回不需要采用零值的班次；否则，返回0。1-返回与&lt;em&gt;op1&lt;/em&gt;大小相同的对象，2-返回所有可能的移位（任何重叠都被接受）。</target>
        </trans-unit>
        <trans-unit id="80d1841e63317d86d0b2bbae07f2e08dc59ff7f9" translate="yes" xml:space="preserve">
          <source>Upper boundary of the output interval. All values generated will be less than high. The default value is 1.0.</source>
          <target state="translated">输出区间的上界。所有生成的值都将小于高值。默认值为1.0。</target>
        </trans-unit>
        <trans-unit id="52be5864b9af229753de85f916fa14a1fa97d3a1" translate="yes" xml:space="preserve">
          <source>Upper limit, must be larger than &lt;code&gt;left&lt;/code&gt;.</source>
          <target state="translated">上限，必须大于 &lt;code&gt;left&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="528933f6438e2665073f1a6a0a370889bd9e0bae" translate="yes" xml:space="preserve">
          <source>Upper or lower-triangular Cholesky factor of &lt;code&gt;a&lt;/code&gt;. Returns a matrix object if &lt;code&gt;a&lt;/code&gt; is a matrix object.</source>
          <target state="translated">上或下三角的Cholesky因数 &lt;code&gt;a&lt;/code&gt; 。如果 &lt;code&gt;a&lt;/code&gt; 是矩阵对象，则返回矩阵对象。</target>
        </trans-unit>
        <trans-unit id="57bb98258946012ee6623d2627640ef4f5f0bbc8" translate="yes" xml:space="preserve">
          <source>Upper triangle of an array.</source>
          <target state="translated">阵列的上三角。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="a15df8cc43a52230464924d2366701940520ece7" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt; because &lt;a href=&quot;#numpy.Inf&quot;&gt;&lt;code&gt;Inf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.Infinity&quot;&gt;&lt;code&gt;Infinity&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.PINF&quot;&gt;&lt;code&gt;PINF&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#numpy.infty&quot;&gt;&lt;code&gt;infty&lt;/code&gt;&lt;/a&gt; are aliases for &lt;a href=&quot;#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt;. For more details, see &lt;a href=&quot;#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; &lt;/a&gt;是因为&lt;a href=&quot;#numpy.Inf&quot;&gt; &lt;code&gt;Inf&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#numpy.Infinity&quot;&gt; &lt;code&gt;Infinity&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#numpy.PINF&quot;&gt; &lt;code&gt;PINF&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#numpy.infty&quot;&gt; &lt;code&gt;infty&lt;/code&gt; &lt;/a&gt;是&lt;a href=&quot;#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; 的&lt;/a&gt;别名。有关更多详细信息，请参见&lt;a href=&quot;#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="315e845b90149a11b36b35f1bf0bf7c4eadadf53" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f81e110951d1c31f755b7eda89bda400f45185fe" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt;&lt;code&gt;assert_allclose&lt;/code&gt;&lt;/a&gt; or one of the nulp (number of floating point values) functions for these cases instead:</source>
          <target state="translated">在这些情况下，请使用&lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt; &lt;code&gt;assert_allclose&lt;/code&gt; &lt;/a&gt;或nulp（浮点值的数量）函数之一：</target>
        </trans-unit>
        <trans-unit id="279c8e9cb261d8451ee87221b2c4c3c0acff77e2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;atleast1d&lt;/code&gt; explicitly if this behavior is deliberate.</source>
          <target state="translated">如果此行为是故意的， &lt;code&gt;atleast1d&lt;/code&gt; 显式使用atleast1d。</target>
        </trans-unit>
        <trans-unit id="c8f354d8129891e4371211f7e2b02c3e86182e68" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;np.rec.fromrecords&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;np.rec.fromrecords&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b891c3328df6ed66c13f42757acead75f849207" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;transpose(a, argsort(axes))&lt;/code&gt; to invert the transposition of tensors when using the &lt;code&gt;axes&lt;/code&gt; keyword argument.</source>
          <target state="translated">使用 &lt;code&gt;axes&lt;/code&gt; 关键字参数时 &lt;code&gt;transpose(a, argsort(axes))&lt;/code&gt; 使用transpose（a，argsort（axes））反转张量的转置。</target>
        </trans-unit>
        <trans-unit id="e79cdecbdf930a5fc02d963ddb3cee0b341e1836" translate="yes" xml:space="preserve">
          <source>Use an index array to construct a new array from a set of choices.</source>
          <target state="translated">使用一个索引数组从一组选择中构造一个新的数组。</target>
        </trans-unit>
        <trans-unit id="b449716c39e8e2ad1701598e0a781904fd930dad" translate="yes" xml:space="preserve">
          <source>Use boolean indexing to select all rows adding up to an even number. At the same time columns 0 and 2 should be selected with an advanced integer index. Using the &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; function this can be done with:</source>
          <target state="translated">使用布尔索引来选择所有相加为偶数的行。同时，应使用高级整数索引选择第0列和第2列。使用&lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt;函数可以通过以下方式完成：</target>
        </trans-unit>
        <trans-unit id="8f82174ebfd083d8637822ce00a0c4c91588113b" translate="yes" xml:space="preserve">
          <source>Use frompyfunc to add broadcasting to the Python function &lt;code&gt;oct&lt;/code&gt;:</source>
          <target state="translated">使用frompyfunc将广播添加到Python函数 &lt;code&gt;oct&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1985c7d495449d5cb406d70622b9f8f51933acf4" translate="yes" xml:space="preserve">
          <source>Use integers()</source>
          <target state="translated">使用integers()</target>
        </trans-unit>
        <trans-unit id="dc8e632ae2c46f77a697535ec370bf0774d7d3a3" translate="yes" xml:space="preserve">
          <source>Use it inside source generating function to ensure that setup distribution instance has been initialized.</source>
          <target state="translated">在源生成函数中使用它来确保设置分发实例已经初始化。</target>
        </trans-unit>
        <trans-unit id="71894ec37f432f11f7de9a5b9b593a7cdf8ac0f3" translate="yes" xml:space="preserve">
          <source>Use of internal buffers</source>
          <target state="translated">内部缓冲器的使用</target>
        </trans-unit>
        <trans-unit id="375ee90511f8800725237c9c32010dd6bfc434d9" translate="yes" xml:space="preserve">
          <source>Use one of the two predefined instances &lt;code&gt;index_exp&lt;/code&gt; or &lt;a href=&quot;#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt; rather than directly using &lt;code&gt;IndexExpression&lt;/code&gt;.</source>
          <target state="translated">使用两个预定义实例 &lt;code&gt;index_exp&lt;/code&gt; 或&lt;a href=&quot;#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; 之一,&lt;/a&gt;而不是直接使用 &lt;code&gt;IndexExpression&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="563d6ccf41351782f370e56a915df0b3956e26f4" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;buf&lt;/code&gt; keyword.</source>
          <target state="translated">使用 &lt;code&gt;buf&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="6e0dab0efbd30d7f80d43f09e327292cfe0afdb8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;endpoint&lt;/code&gt; kwarg to adjust the inclusion or exclution of the &lt;code&gt;high&lt;/code&gt; interval endpoint</source>
          <target state="translated">使用 &lt;code&gt;endpoint&lt;/code&gt; kwarg调整 &lt;code&gt;high&lt;/code&gt; 间隔端点的包含或排除</target>
        </trans-unit>
        <trans-unit id="1a4a01452f45e746c6cb102d0e1fd6cdbe229239" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;order&lt;/code&gt; keyword to specify a field to use when sorting a structured array:</source>
          <target state="translated">使用 &lt;code&gt;order&lt;/code&gt; 关键字指定对结构化数组进行排序时要使用的字段：</target>
        </trans-unit>
        <trans-unit id="25cbadfbabe4aec8c49a2fe4ad5d41f89ab2957d" translate="yes" xml:space="preserve">
          <source>Use the indices of the non-zero elements as an index array to extract these elements:</source>
          <target state="translated">使用非零元素的指数作为索引数组来提取这些元素。</target>
        </trans-unit>
        <trans-unit id="fd6f1513bb6f3e4a98050539792c7f3cbaf760a6" translate="yes" xml:space="preserve">
          <source>Used as-is.</source>
          <target state="translated">按原样使用。</target>
        </trans-unit>
        <trans-unit id="86d25879dd6e8e65f51cfd2c9e310da0aa3fb93c" translate="yes" xml:space="preserve">
          <source>Used for an array, &lt;em&gt;op&lt;/em&gt;, that contains any Python objects. It decrements the reference count of every object in the array according to the data-type of &lt;em&gt;op&lt;/em&gt;. Normal return value is 0. A -1 is returned if an error occurs.</source>
          <target state="translated">用于包含任何Python对象的数组&lt;em&gt;op&lt;/em&gt;。它根据&lt;em&gt;op&lt;/em&gt;的数据类型递减数组中每个对象的引用计数。正常返回值为0。如果发生错误，则返回-1。</target>
        </trans-unit>
        <trans-unit id="12676328e0f8258da10db691bf737e9cd286a726" translate="yes" xml:space="preserve">
          <source>Used for an array, &lt;em&gt;op&lt;/em&gt;, that contains any Python objects. It increments the reference count of every object in the array according to the data-type of &lt;em&gt;op&lt;/em&gt;. A -1 is returned if an error occurs, otherwise 0 is returned.</source>
          <target state="translated">用于包含任何Python对象的数组&lt;em&gt;op&lt;/em&gt;。它根据&lt;em&gt;op&lt;/em&gt;的数据类型增加数组中每个对象的引用计数。如果发生错误，则返回-1，否则返回0。</target>
        </trans-unit>
        <trans-unit id="2a13b41ea5661dcbc4d05b7183bc9d474dd67bb8" translate="yes" xml:space="preserve">
          <source>Used if &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy&lt;/code&gt;&lt;/a&gt; is called on an array.</source>
          <target state="translated">如果使用&lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy&lt;/code&gt; &lt;/a&gt;被称为阵列上。</target>
        </trans-unit>
        <trans-unit id="b1500692edf9e6d67bd590cb2e6428fecab9820c" translate="yes" xml:space="preserve">
          <source>Used if &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy&lt;/code&gt;&lt;/a&gt; is called on an array. Returns a copy of the array.</source>
          <target state="translated">如果使用&lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy&lt;/code&gt; &lt;/a&gt;被称为阵列上。返回数组的副本。</target>
        </trans-unit>
        <trans-unit id="054ce70cbf81d2356ba6ae20aa8fb864ef13bf9e" translate="yes" xml:space="preserve">
          <source>Used if &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy&lt;/code&gt;&lt;/a&gt; is called on an array.</source>
          <target state="translated">如果使用&lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.deepcopy&quot;&gt; &lt;code&gt;copy.deepcopy&lt;/code&gt; &lt;/a&gt;被称为阵列上。</target>
        </trans-unit>
        <trans-unit id="df1278433c263cdbbd69170e679d3f52bb78e816" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;constant&amp;rsquo;. The values to set the padded values for each axis.</source>
          <target state="translated">在&amp;ldquo;常量&amp;rdquo;中使用。用于设置每个轴的填充值的值。</target>
        </trans-unit>
        <trans-unit id="465b8fcd19cd5e2ed77adff74f2ff5a3fc18db79" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;linear_ramp&amp;rsquo;. The values used for the ending value of the linear_ramp and that will form the edge of the padded array.</source>
          <target state="translated">在'linear_ramp'中使用。用于linear_ramp结束值的值，它将形成填充数组的边缘。</target>
        </trans-unit>
        <trans-unit id="d71d6f65b16e9b35cb9fcf9b7569838936b2caa2" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;maximum&amp;rsquo;, &amp;lsquo;mean&amp;rsquo;, &amp;lsquo;median&amp;rsquo;, and &amp;lsquo;minimum&amp;rsquo;. Number of values at edge of each axis used to calculate the statistic value.</source>
          <target state="translated">用于&amp;ldquo;最大&amp;rdquo;，&amp;ldquo;平均&amp;rdquo;，&amp;ldquo;中位数&amp;rdquo;和&amp;ldquo;最小&amp;rdquo;。每个轴边缘上用于计算统计值的值的数量。</target>
        </trans-unit>
        <trans-unit id="4325f42e7e418215aac0a73c897c39904b4d0a1e" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;reflect&amp;rsquo;, and &amp;lsquo;symmetric&amp;rsquo;. The &amp;lsquo;even&amp;rsquo; style is the default with an unaltered reflection around the edge value. For the &amp;lsquo;odd&amp;rsquo; style, the extended part of the array is created by subtracting the reflected values from two times the edge value.</source>
          <target state="translated">用于&amp;ldquo;反射&amp;rdquo;和&amp;ldquo;对称&amp;rdquo;。默认设置为&amp;ldquo;偶数&amp;rdquo;样式，边缘值周围的反射不变。对于&amp;ldquo;奇数&amp;rdquo;样式，通过从两倍的边缘值中减去反射值来创建数组的扩展部分。</target>
        </trans-unit>
        <trans-unit id="1b7f1793a4a4b44dd1933f922f757d629d3be5a3" translate="yes" xml:space="preserve">
          <source>Used in universal function code to only release the Python GIL if loop-&amp;gt;obj is not true (&lt;em&gt;i.e.&lt;/em&gt; this is not an OBJECT array loop). Requires use of &lt;a href=&quot;c-api.array#c.NPY_BEGIN_THREADS_DEF&quot;&gt;&lt;code&gt;NPY_BEGIN_THREADS_DEF&lt;/code&gt;&lt;/a&gt; in variable declaration area.</source>
          <target state="translated">在通用功能代码中使用，仅当loop-&amp;gt; obj不为真（&lt;em&gt;即，&lt;/em&gt;这不是OBJECT数组循环）时才释放Python GIL 。需要在变量声明区域中使用&lt;a href=&quot;c-api.array#c.NPY_BEGIN_THREADS_DEF&quot;&gt; &lt;code&gt;NPY_BEGIN_THREADS_DEF&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="10031fc1a49c2cbba6bbb424956b8667cda6fefa" translate="yes" xml:space="preserve">
          <source>Used in universal function code to re-acquire the Python GIL if it was released (because loop-&amp;gt;obj was not true).</source>
          <target state="translated">在通用功能代码中用于重新获取Python GIL（如果它已发行）（因为loop-&amp;gt; obj不是true）。</target>
        </trans-unit>
        <trans-unit id="c23b41a6c14497a2fa2fb894918e5ebdff35b118" translate="yes" xml:space="preserve">
          <source>Used to construct the convolution operator.</source>
          <target state="translated">用于构造卷积算子。</target>
        </trans-unit>
        <trans-unit id="c5c64c33615821368bc9743122d8a6c96ff848fe" translate="yes" xml:space="preserve">
          <source>Used to fill the array with data.</source>
          <target state="translated">用于在数组中填充数据。</target>
        </trans-unit>
        <trans-unit id="4b06029f962bdaa60d205631cac84f36f3e29d6f" translate="yes" xml:space="preserve">
          <source>Useful functions in &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; 中的有用函数</target>
        </trans-unit>
        <trans-unit id="7dc863346a17f843606dc78b7fd5eaa70c18759a" translate="yes" xml:space="preserve">
          <source>Useful math constants</source>
          <target state="translated">有用的数学常数</target>
        </trans-unit>
        <trans-unit id="d7e7cae700d3c37685c439282d2378cb79df959c" translate="yes" xml:space="preserve">
          <source>Useful to regain the GIL in situations where it was released using the BEGIN form of this macro.</source>
          <target state="translated">在使用此宏的BEGIN形式释放GIL的情况下,恢复GIL是有用的。</target>
        </trans-unit>
        <trans-unit id="d580b2c9b4825f08cb2691c40cd94404df444f3e" translate="yes" xml:space="preserve">
          <source>Useful to release the GIL only if &lt;em&gt;dtype&lt;/em&gt; does not contain arbitrary Python objects which may need the Python interpreter during execution of the loop. Equivalent to</source>
          <target state="translated">仅当&lt;em&gt;dtype&lt;/em&gt;不包含任意Python对象（在循环执行期间可能需要Python解释器）时才释放GIL有用。相当于</target>
        </trans-unit>
        <trans-unit id="2978535fda1f10395442e618746112da0bb87d3a" translate="yes" xml:space="preserve">
          <source>Useful to release the GIL only if &lt;em&gt;loop_size&lt;/em&gt; exceeds a minimum threshold, currently set to 500. Should be matched with a &lt;a href=&quot;#c.NPY_END_THREADS&quot;&gt;&lt;code&gt;NPY_END_THREADS&lt;/code&gt;&lt;/a&gt; to regain the GIL.</source>
          <target state="translated">仅当&lt;em&gt;loop_size&lt;/em&gt;超过当前设置为最小阈值的最小阈值时才有用，以释放GIL。应与&lt;a href=&quot;#c.NPY_END_THREADS&quot;&gt; &lt;code&gt;NPY_END_THREADS&lt;/code&gt; &lt;/a&gt;匹配以重新获得GIL。</target>
        </trans-unit>
        <trans-unit id="2637443926c71ce03a091c2e95bf9b5610348992" translate="yes" xml:space="preserve">
          <source>Using &amp;lsquo;r&amp;rsquo; or &amp;lsquo;c&amp;rsquo; as a first string argument creates a matrix.</source>
          <target state="translated">将&amp;ldquo; r&amp;rdquo;或&amp;ldquo; c&amp;rdquo;用作第一个字符串参数将创建一个矩阵。</target>
        </trans-unit>
        <trans-unit id="65fcf8542af4dfa98c8e336c7ebb663b2e96f530" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; one can quickly construct index arrays that will index the cross product. &lt;code&gt;a[np.ix_([1,3],[2,5])]&lt;/code&gt; returns the array &lt;code&gt;[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]&lt;/code&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; ,&lt;/a&gt;可以快速构造索引数组，该索引数组将对叉积进行索引。 &lt;code&gt;a[np.ix_([1,3],[2,5])]&lt;/code&gt; 返回数组 &lt;code&gt;[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32ece8fbb6c1ed850bf1c3c8fb0f4d5a7300c2c0" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt; with **kwds, the arrays are saved with the keyword names.</source>
          <target state="translated">将&lt;a href=&quot;#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; &lt;/a&gt;与** kwds一起使用时，将使用关键字名称保存数组。</target>
        </trans-unit>
        <trans-unit id="8c36d4099fe15bc91bbfe91acb74cd64e75d6b3f" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt; with *args, the arrays are saved with default names.</source>
          <target state="translated">将&lt;a href=&quot;#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; &lt;/a&gt;与* args结合使用时，将使用默认名称保存阵列。</target>
        </trans-unit>
        <trans-unit id="d4ecb91f09183edc4f23a5cc314556ac8c1af3c8" translate="yes" xml:space="preserve">
          <source>Using a flexible &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">使用灵活的 &lt;code&gt;dtype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cfac66afdbdc20a411f9f9f200f87cdcbe870cdd" translate="yes" xml:space="preserve">
          <source>Using a view to convert an array to a recarray:</source>
          <target state="translated">使用视图将一个数组转换为一个recarray。</target>
        </trans-unit>
        <trans-unit id="a4fb72e0c5f0602466b0b452237f4e23496663cc" translate="yes" xml:space="preserve">
          <source>Using an External Loop</source>
          <target state="translated">使用外部环路</target>
        </trans-unit>
        <trans-unit id="f210f428b873c49c7b2b57aa15cfa3164fde53af" translate="yes" xml:space="preserve">
          <source>Using an instance of &lt;a href=&quot;#numpy.errstate&quot;&gt;&lt;code&gt;errstate&lt;/code&gt;&lt;/a&gt; as a context manager allows statements in that context to execute with a known error handling behavior. Upon entering the context the error handling is set with &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;, and upon exiting it is reset to what it was before.</source>
          <target state="translated">将&lt;a href=&quot;#numpy.errstate&quot;&gt; &lt;code&gt;errstate&lt;/code&gt; &lt;/a&gt;实例用作上下文管理器可以使该上下文中的语句以已知的错误处理行为执行。输入上下文后，将使用&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt;设置错误处理，退出后将其重置为之前的状态。</target>
        </trans-unit>
        <trans-unit id="7af0c7a348040b3b4ff1744a0608d17163c9138e" translate="yes" xml:space="preserve">
          <source>Using array-protocol type strings:</source>
          <target state="translated">使用数组协议类型的字符串。</target>
        </trans-unit>
        <trans-unit id="fd7054fa064ad2611d4b7d00df8240d7735e3c37" translate="yes" xml:space="preserve">
          <source>Using array-scalar type:</source>
          <target state="translated">使用数组标量类型。</target>
        </trans-unit>
        <trans-unit id="03a2b430abf28e746816ea1cff1b193db00a94c9" translate="yes" xml:space="preserve">
          <source>Using comma-separated field formats. The shape is (2,3):</source>
          <target state="translated">使用逗号分隔的字段格式。形状为(2,3)。</target>
        </trans-unit>
        <trans-unit id="e282c417933d97d3a53a56d481d1f405a74c7c0d" translate="yes" xml:space="preserve">
          <source>Using complex sequences:</source>
          <target state="translated">使用复杂的序列。</target>
        </trans-unit>
        <trans-unit id="26e522c98bd807e94f2ab9fc3a1975ce203f287e" translate="yes" xml:space="preserve">
          <source>Using dictionaries. Two fields named &amp;lsquo;gender&amp;rsquo; and &amp;lsquo;age&amp;rsquo;:</source>
          <target state="translated">使用字典。两个字段分别称为&amp;ldquo;性别&amp;rdquo;和&amp;ldquo;年龄&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="af330b02f13d207e5fac3c22b8c9bdbaab36afee" translate="yes" xml:space="preserve">
          <source>Using dtype = None</source>
          <target state="translated">使用dtype=None</target>
        </trans-unit>
        <trans-unit id="8d2131672fafcfdf449f29b29350743e40c17d69" translate="yes" xml:space="preserve">
          <source>Using months for the unit:</source>
          <target state="translated">以月为单位。</target>
        </trans-unit>
        <trans-unit id="2f696379652fe6905a66fc5fd2b9273fa2471296" translate="yes" xml:space="preserve">
          <source>Using numpy.i</source>
          <target state="translated">使用numpy.i</target>
        </trans-unit>
        <trans-unit id="e8111da9fdc8286f7fa1decedd3c62fdfaa40d28" translate="yes" xml:space="preserve">
          <source>Using numpy.ma</source>
          <target state="translated">使用numpy.ma</target>
        </trans-unit>
        <trans-unit id="03252764a2ca129ee8f53a1ebcd3c94ffd3382b7" translate="yes" xml:space="preserve">
          <source>Using poly1d objects:</source>
          <target state="translated">使用poly1d对象。</target>
        </trans-unit>
        <trans-unit id="79eb3bbcb08c7d6704be86d77b0727b917270b3d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;axis&lt;/code&gt; argument to compute matrix norms:</source>
          <target state="translated">使用 &lt;code&gt;axis&lt;/code&gt; 参数计算矩阵范数：</target>
        </trans-unit>
        <trans-unit id="9e684f49459c0d5aba4c5f2579aeb17add74610d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;axis&lt;/code&gt; argument to compute vector norms:</source>
          <target state="translated">使用 &lt;code&gt;axis&lt;/code&gt; 参数计算向量范数：</target>
        </trans-unit>
        <trans-unit id="b9ba36c2f053a06ac3abc3a930f4a1d05aada052" translate="yes" xml:space="preserve">
          <source>Using the Convenience Classes</source>
          <target state="translated">使用方便类</target>
        </trans-unit>
        <trans-unit id="1bd2966f639ab87086919a9a710a3ff850eadf79" translate="yes" xml:space="preserve">
          <source>Using the Einstein summation convention, many common multi-dimensional, linear algebraic array operations can be represented in a simple fashion. In &lt;em&gt;implicit&lt;/em&gt; mode &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; computes these values.</source>
          <target state="translated">使用爱因斯坦求和约定，可以以简单的方式表示许多常见的多维线性代数数组运算。在&lt;em&gt;隐式&lt;/em&gt;模式下，&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;计算这些值。</target>
        </trans-unit>
        <trans-unit id="75da2a462c666654f41a122b8cf7201ccca6f453" translate="yes" xml:space="preserve">
          <source>Using the casting rules</source>
          <target state="translated">使用铸造规则</target>
        </trans-unit>
        <trans-unit id="0e2a18ad6df592872579dd4bbee44818b7034db3" translate="yes" xml:space="preserve">
          <source>Using these #defines you can use the C-API in multiple files for a single extension module. In each file you must define &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to some name that will hold the C-API (&lt;em&gt;e.g.&lt;/em&gt; myextension_ARRAY_API). This must be done &lt;strong&gt;before&lt;/strong&gt; including the numpy/arrayobject.h file. In the module initialization routine you call &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt;. In addition, in the files that do not have the module initialization sub_routine define &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; prior to including numpy/arrayobject.h.</source>
          <target state="translated">使用这些#defines，您可以在单个扩展模块的多个文件中使用C-API。在每个文件中，必须将&lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt;定义为将包含C-API的名称（&lt;em&gt;例如&lt;/em&gt; myextension_ARRAY_API）。必须&lt;strong&gt;在&lt;/strong&gt;包含numpy / arrayobject.h文件&lt;strong&gt;之前&lt;/strong&gt;完成此操作。在模块初始化例程中，调用&lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; &lt;/a&gt;。此外，在没有初始化模块sub_routine的文件定义&lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; &lt;/a&gt;之前，包括numpy的/ arrayobject.h。</target>
        </trans-unit>
        <trans-unit id="315900bdae1d95768693f5caf49a459c0e9247e8" translate="yes" xml:space="preserve">
          <source>Using this result to index &lt;code&gt;a&lt;/code&gt; is equivalent to using the mask directly:</source>
          <target state="translated">使用此结果索引 &lt;code&gt;a&lt;/code&gt; 等同于直接使用掩码：</target>
        </trans-unit>
        <trans-unit id="f1e207983fdf75c13618b12af3dac2cc9b09a86a" translate="yes" xml:space="preserve">
          <source>Using this scheme, an upper bound on the probability of a collision can be estimated if one knows the number of streams that you derive. &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; hashes its inputs, both the seed and the spawn-tree-path, down to a 128-bit pool by default. The probability that there is a collision in that pool, pessimistically-estimated (&lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;), will be about</source>
          <target state="translated">使用这种方案，如果知道您派生的流的数量，就可以估算出发生冲突的可能性的上限。&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;其输入（包括种子和生成树路径）散列到128位池中。悲观估计（&lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;），该池中发生冲突的概率约为</target>
        </trans-unit>
        <trans-unit id="81f2b8dfbfc71c96c12b186f5770d7cbd6cb20f2" translate="yes" xml:space="preserve">
          <source>Using tuples. &lt;code&gt;int&lt;/code&gt; is a fixed type, 3 the field&amp;rsquo;s shape. &lt;code&gt;void&lt;/code&gt; is a flexible type, here of size 10:</source>
          <target state="translated">使用元组。 &lt;code&gt;int&lt;/code&gt; 是固定类型的3字段的形状。 &lt;code&gt;void&lt;/code&gt; 是一种灵活的类型，大小为10：</target>
        </trans-unit>
        <trans-unit id="ef8b4345a7cc12338d15d1fb67d9e4a4feb23426" translate="yes" xml:space="preserve">
          <source>Usually denoted</source>
          <target state="translated">通常表示为</target>
        </trans-unit>
        <trans-unit id="a5abc30aa6f2b926c1472fe22071db5adb16a0bc" translate="yes" xml:space="preserve">
          <source>Usually, however, adding the &lt;code&gt;tests/&lt;/code&gt; directory to the python path isn&amp;rsquo;t desirable. Instead it would better to invoke the test straight from the module &lt;code&gt;xxx&lt;/code&gt;. To this end, simply place the following lines at the end of your package&amp;rsquo;s &lt;code&gt;__init__.py&lt;/code&gt; file:</source>
          <target state="translated">但是，通常不希望将 &lt;code&gt;tests/&lt;/code&gt; 目录添加到python路径。相反，最好直接从模块 &lt;code&gt;xxx&lt;/code&gt; 调用测试。为此，只需将以 &lt;code&gt;__init__.py&lt;/code&gt; 放在包的__init__.py文件的末尾：</target>
        </trans-unit>
        <trans-unit id="6be23322b56766a1db9b8621387497e594f16d2d" translate="yes" xml:space="preserve">
          <source>Utility classes and functions for the polynomial modules.</source>
          <target state="translated">多项式模块的实用类和函数。</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="3522db33c6e586ed6f52f3af3bea08c2509cdaed" translate="yes" xml:space="preserve">
          <source>Value indicating that a masked array has no invalid entry. &lt;a href=&quot;#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is used internally to speed up computations when the mask is not needed.</source>
          <target state="translated">指示掩码数组没有无效条目的值。当不需要遮罩时，内部使用&lt;a href=&quot;#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;来加快计算速度。</target>
        </trans-unit>
        <trans-unit id="0b9ec234c1eee91fedfeaba35509216217fe21cd" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;operands&lt;/code&gt; at current iteration. Normally, this is a tuple of array scalars, but if the flag &lt;code&gt;external_loop&lt;/code&gt; is used, it is a tuple of one dimensional arrays.</source>
          <target state="translated">当前迭代中 &lt;code&gt;operands&lt;/code&gt; 值。通常，这是数组标量的元组，但是如果使用标志 &lt;code&gt;external_loop&lt;/code&gt; ，则它是一维数组的元组。</target>
        </trans-unit>
        <trans-unit id="d866e0938fcfdf12b88042317593d4295facb33c" translate="yes" xml:space="preserve">
          <source>Value to be placed in field.</source>
          <target state="translated">要放在字段中的值。</target>
        </trans-unit>
        <trans-unit id="4ba37300f6a7d1d653bfd085d1c3e62828c53205" translate="yes" xml:space="preserve">
          <source>Value to be used to fill NaN values. If no value is passed then NaN values will be replaced with 0.0.</source>
          <target state="translated">用来填充NaN值的值。如果没有传递值,那么NaN值将被替换为0.0。</target>
        </trans-unit>
        <trans-unit id="73822c64a61d90da64aca29978cabf65524aa150" translate="yes" xml:space="preserve">
          <source>Value to be used to fill negative infinity values. If no value is passed then negative infinity values will be replaced with a very small (or negative) number.</source>
          <target state="translated">用来填充负无穷值的值。如果没有传递任何值,那么负的无限值将被一个非常小的(或负的)数字代替。</target>
        </trans-unit>
        <trans-unit id="f4796b06e4cb3d07bcdfe89591ec37b878b0609f" translate="yes" xml:space="preserve">
          <source>Value to be used to fill positive infinity values. If no value is passed then positive infinity values will be replaced with a very large number.</source>
          <target state="translated">用来填充正无穷值的值。如果没有传递值,那么正无穷值将被一个非常大的数字代替。</target>
        </trans-unit>
        <trans-unit id="f7cccdf775f458dbd65351fa14dd9eb110134681" translate="yes" xml:space="preserve">
          <source>Value to be written on the diagonal, its type must be compatible with that of the array a.</source>
          <target state="translated">要写在对角线上的值,其类型必须与数组a的类型一致。</target>
        </trans-unit>
        <trans-unit id="715dcdd8f6ff522d4658e491027e9aae31a8b5e6" translate="yes" xml:space="preserve">
          <source>Value to format.</source>
          <target state="translated">要格式化的值。</target>
        </trans-unit>
        <trans-unit id="3d3e32ccc4b0ab4e1f0dc806d286fb59b6c443d6" translate="yes" xml:space="preserve">
          <source>Value to return for &lt;code&gt;x &amp;gt; xp[-1]&lt;/code&gt;, default is &lt;code&gt;fp[-1]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x &amp;gt; xp[-1]&lt;/code&gt; 返回值，默认值为 &lt;code&gt;fp[-1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26d4865cbe90216e1386cb06fe27a2a8a2fdea6f" translate="yes" xml:space="preserve">
          <source>Value to return for &lt;code&gt;x &amp;lt; xp[0]&lt;/code&gt;, default is &lt;code&gt;fp[0]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x &amp;lt; xp[0]&lt;/code&gt; 返回值，默认值为 &lt;code&gt;fp[0]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7a5e0e3824dade99c632ba9171e408c2ecc5e00" translate="yes" xml:space="preserve">
          <source>Value used for fixing invalid data. Default is None, in which case the &lt;code&gt;a.fill_value&lt;/code&gt; is used.</source>
          <target state="translated">用于修复无效数据的值。默认值为无，在这种情况下，将使用 &lt;code&gt;a.fill_value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69ddc9b73f581b3343b0affbf7e4377d672439b1" translate="yes" xml:space="preserve">
          <source>Value used internally for the masked values. If &lt;code&gt;fill_value&lt;/code&gt; is not None, it supersedes &lt;code&gt;endwith&lt;/code&gt;.</source>
          <target state="translated">内部用于掩码值的值。如果 &lt;code&gt;fill_value&lt;/code&gt; 不为None，它将取代 &lt;code&gt;endwith&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="328663db0b3aba67f0d82903937cd9193c3e207c" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values when necessary. If None, a default based on the data-type is used.</source>
          <target state="translated">用于在必要时填充掩码值的值。如果无,则使用基于数据类型的默认值。</target>
        </trans-unit>
        <trans-unit id="ac07a9705ce80720af8585478b1d81e8b7b8b456" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values.</source>
          <target state="translated">用于填充掩码值的值。</target>
        </trans-unit>
        <trans-unit id="86e71cf73f1d7bc170999262699205370f1f93e4" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. Default is None, in which case &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;MaskedArray.fill_value&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">用于填充掩码值的值。默认值为无，在这种情况下，将使用&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;MaskedArray.fill_value&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="19866b65a013a0eb3c733fc479da8433fc02a5f3" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, the output of maximum_fill_value(self._data) is used instead.</source>
          <target state="translated">用于填充掩码值的值。如果为None,则使用maximum_fill_value(self._data)的输出。</target>
        </trans-unit>
        <trans-unit id="5c0a58c6eeb18776376a78bc0a9866ce44b1ad27" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, the output of minimum_fill_value(self._data) is used instead.</source>
          <target state="translated">用于填充掩码值的值。如果为None,则使用最小填充值(self._data)的输出。</target>
        </trans-unit>
        <trans-unit id="752e711d9ae184609f9efa220ffeb98e2623ff23" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, use the output of &lt;code&gt;minimum_fill_value&lt;/code&gt;.</source>
          <target state="translated">用于填充掩码值的值。如果为None，则使用 &lt;code&gt;minimum_fill_value&lt;/code&gt; 的输出。</target>
        </trans-unit>
        <trans-unit id="94b3fde97e6b1196d461cd6d1087f12e6dea54b2" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, use the output of maximum_fill_value().</source>
          <target state="translated">用于填充掩码值的值。如果为None,则使用maximum_fill_value()的输出。</target>
        </trans-unit>
        <trans-unit id="eddd55b4550fcb347a1d6bf73a696e1497719104" translate="yes" xml:space="preserve">
          <source>Values are appended to a copy of this array.</source>
          <target state="translated">值被附加到这个数组的副本中。</target>
        </trans-unit>
        <trans-unit id="24421420351a973d79bcca3d2ef0e453017e616f" translate="yes" xml:space="preserve">
          <source>Values are generated within the half-open interval &lt;code&gt;[start, stop)&lt;/code&gt; (in other words, the interval including &lt;code&gt;start&lt;/code&gt; but excluding &lt;code&gt;stop&lt;/code&gt;). For integer arguments the function is equivalent to the Python built-in &lt;code&gt;range&lt;/code&gt; function, but returns an ndarray rather than a list.</source>
          <target state="translated">在半开间隔 &lt;code&gt;[start, stop)&lt;/code&gt; （换句话说，包括 &lt;code&gt;start&lt;/code&gt; 但不包括 &lt;code&gt;stop&lt;/code&gt; 的间隔）内生成值。对于整数参数，该函数等效于Python内置的 &lt;code&gt;range&lt;/code&gt; 函数，但返回ndarray而不是列表。</target>
        </trans-unit>
        <trans-unit id="38b38aff8e14ce007107a5b62d7837a43399e916" translate="yes" xml:space="preserve">
          <source>Values at which the weight function will be computed.</source>
          <target state="translated">计算权重函数的数值。</target>
        </trans-unit>
        <trans-unit id="8afc1edfb8d26a9a4bac7610a9a2ed43bc17c240" translate="yes" xml:space="preserve">
          <source>Values from which to choose. &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;condition&lt;/code&gt; need to be broadcastable to some shape.</source>
          <target state="translated">从中选择的值。 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;condition&lt;/code&gt; 需要广播为某种形状。</target>
        </trans-unit>
        <trans-unit id="55fd9fa348e62e91b8d05086f74314a1ab640581" translate="yes" xml:space="preserve">
          <source>Values in &lt;code&gt;i&lt;/code&gt; of less than 0 are treated as 0 (which yields an empty string).</source>
          <target state="translated">在值 &lt;code&gt;i&lt;/code&gt; 的小于0被视为0（它产生一个空字符串）。</target>
        </trans-unit>
        <trans-unit id="c0da0f066601a2a9367e697b89519e6b0c50e33e" translate="yes" xml:space="preserve">
          <source>Values to change the sign of.</source>
          <target state="translated">要改变符号的数值。</target>
        </trans-unit>
        <trans-unit id="4158750ed1844d81234e02100fb4f6a0ce246137" translate="yes" xml:space="preserve">
          <source>Values to find the next representable value of.</source>
          <target state="translated">找到下一个可表示的值。</target>
        </trans-unit>
        <trans-unit id="beb9a9be5bcba10dec2aa7359c7898f16a9d7ca8" translate="yes" xml:space="preserve">
          <source>Values to find the spacing of.</source>
          <target state="translated">找出间距的数值。</target>
        </trans-unit>
        <trans-unit id="3b61fff151ba4cdc5d10abd1dbdd04d94f432686" translate="yes" xml:space="preserve">
          <source>Values to insert into &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">值插入到 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19b54e21994fdcbd2ab01d7104b74c970245cfe1" translate="yes" xml:space="preserve">
          <source>Values to insert into &lt;code&gt;arr&lt;/code&gt;. If the type of &lt;code&gt;values&lt;/code&gt; is different from that of &lt;code&gt;arr&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt; is converted to the type of &lt;code&gt;arr&lt;/code&gt;. &lt;code&gt;values&lt;/code&gt; should be shaped so that &lt;code&gt;arr[...,obj,...] = values&lt;/code&gt; is legal.</source>
          <target state="translated">要插入到 &lt;code&gt;arr&lt;/code&gt; 中的值。如果类型 &lt;code&gt;values&lt;/code&gt; 不同于不同 &lt;code&gt;arr&lt;/code&gt; ， &lt;code&gt;values&lt;/code&gt; 被转换为的类型 &lt;code&gt;arr&lt;/code&gt; 。 &lt;code&gt;values&lt;/code&gt; 形状应使 &lt;code&gt;arr[...,obj,...] = values&lt;/code&gt; 合法。</target>
        </trans-unit>
        <trans-unit id="817bf23706b268004f4bf56ee98317c1ad7d150d" translate="yes" xml:space="preserve">
          <source>Values to place in &lt;code&gt;a&lt;/code&gt; at target indices. If &lt;code&gt;v&lt;/code&gt; is shorter than &lt;code&gt;ind&lt;/code&gt; it will be repeated as necessary.</source>
          <target state="translated">价值观在放置 &lt;code&gt;a&lt;/code&gt; 在目标指数。如果 &lt;code&gt;v&lt;/code&gt; 小于 &lt;code&gt;ind&lt;/code&gt; ，则将在必要时将其重复。</target>
        </trans-unit>
        <trans-unit id="a9be9f0fa346eb48800661efe4c9cdccf0a4d68a" translate="yes" xml:space="preserve">
          <source>Values to place in self._data copy at target indices.</source>
          <target state="translated">要放在目标索引的self._data副本中的值。</target>
        </trans-unit>
        <trans-unit id="81f73f98efd45554f2765f8a372cd020b7023051" translate="yes" xml:space="preserve">
          <source>Values to prepend or append to &amp;ldquo;a&amp;rdquo; along axis prior to performing the difference. Scalar values are expanded to arrays with length 1 in the direction of axis and the shape of the input array in along all other axes. Otherwise the dimension and shape must match &amp;ldquo;a&amp;rdquo; except along axis.</source>
          <target state="translated">在执行差分之前，要沿轴在&amp;ldquo; a&amp;rdquo;之前或之后附加的值。标量值将扩展为在轴方向上长度为1的数组，并在所有其他轴上扩展为输入数组的形状。否则，尺寸和形状必须沿轴匹配&amp;ldquo; a&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="462c5daaa1bebf27712ab1f9e6dff7991b7d4f2b" translate="yes" xml:space="preserve">
          <source>Values to put into &lt;code&gt;a&lt;/code&gt; where &lt;code&gt;mask&lt;/code&gt; is True. If &lt;code&gt;values&lt;/code&gt; is smaller than &lt;code&gt;a&lt;/code&gt; it will be repeated.</source>
          <target state="translated">值投入 &lt;code&gt;a&lt;/code&gt; 地方 &lt;code&gt;mask&lt;/code&gt; 是真。如果 &lt;code&gt;values&lt;/code&gt; 小于 &lt;code&gt;a&lt;/code&gt; ，将重复执行。</target>
        </trans-unit>
        <trans-unit id="25e7a819f368d39546137552cf420f108ade4ace" translate="yes" xml:space="preserve">
          <source>Values to put into &lt;code&gt;a&lt;/code&gt;. Only the first N elements are used, where N is the number of True values in &lt;code&gt;mask&lt;/code&gt;. If &lt;code&gt;vals&lt;/code&gt; is smaller than N, it will be repeated, and if elements of &lt;code&gt;a&lt;/code&gt; are to be masked, this sequence must be non-empty.</source>
          <target state="translated">值投入 &lt;code&gt;a&lt;/code&gt; 。仅使用前N个元素，其中N是 &lt;code&gt;mask&lt;/code&gt; 中的True值的数量。如果 &lt;code&gt;vals&lt;/code&gt; 小于N，它将被重复，并且如果元素 &lt;code&gt;a&lt;/code&gt; 都被掩蔽，该序列必须是非空的。</target>
        </trans-unit>
        <trans-unit id="60bd6b681e5d46e176fd602e7f740408a4b90a97" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix for powers.</source>
          <target state="translated">幂的范德蒙德矩阵。</target>
        </trans-unit>
        <trans-unit id="6401e380553d40526975bfbedfb18608ca5c00ad" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of Chebyshev series.</source>
          <target state="translated">Chebyshev系列的Vandermonde矩阵。</target>
        </trans-unit>
        <trans-unit id="ae6e82d94a52ea695163be06dc24993156d990a5" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of Hermite series.</source>
          <target state="translated">Hermite系列的Vandermonde矩阵。</target>
        </trans-unit>
        <trans-unit id="a2d6130252c264087c83a0456898053f5cce8c9b" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of Legendre series.</source>
          <target state="translated">Vandermonde矩阵或Legendre系列。</target>
        </trans-unit>
        <trans-unit id="5d2bf93649140d94c435a78c84579d541c1303f5" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of given degree.</source>
          <target state="translated">给定度的Vandermonde矩阵。</target>
        </trans-unit>
        <trans-unit id="315c420145ba2a2de3ef508e657b666b667d7db9" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix. If &lt;code&gt;increasing&lt;/code&gt; is False, the first column is &lt;code&gt;x^(N-1)&lt;/code&gt;, the second &lt;code&gt;x^(N-2)&lt;/code&gt; and so forth. If &lt;code&gt;increasing&lt;/code&gt; is True, the columns are &lt;code&gt;x^0, x^1, ..., x^(N-1)&lt;/code&gt;.</source>
          <target state="translated">范德蒙矩阵。如果 &lt;code&gt;increasing&lt;/code&gt; 为False，则第一列为 &lt;code&gt;x^(N-1)&lt;/code&gt; ，第二 &lt;code&gt;x^(N-2)&lt;/code&gt; ，依此类推。如果 &lt;code&gt;increasing&lt;/code&gt; 为True，则列为 &lt;code&gt;x^0, x^1, ..., x^(N-1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef7476851367ab64af3bc4c81c52e5e1e6857c25" translate="yes" xml:space="preserve">
          <source>Variables in Numpy which control and describe alignment</source>
          <target state="translated">Numpy中控制和描述对齐的变量。</target>
        </trans-unit>
        <trans-unit id="2a1f6fba473be39ef3c80a51eed0db143c77f764" translate="yes" xml:space="preserve">
          <source>Variance while not ignoring NaNs</source>
          <target state="translated">不忽略NaNs时的差异</target>
        </trans-unit>
        <trans-unit id="407b9055a29b3862ad6596884f933fb2e3b90801" translate="yes" xml:space="preserve">
          <source>Various windows</source>
          <target state="translated">各种窗口</target>
        </trans-unit>
        <trans-unit id="690a0d6330a132cb4527e3e44d7a2347c9a06b3a" translate="yes" xml:space="preserve">
          <source>Vector cross product(s).</source>
          <target state="translated">矢量交叉积。</target>
        </trans-unit>
        <trans-unit id="28cb052426ac62f08e613cbe9ac7789542c3593f" translate="yes" xml:space="preserve">
          <source>Vector cross-product.</source>
          <target state="translated">矢量交叉产品。</target>
        </trans-unit>
        <trans-unit id="0fe94b620577959abe98d342c3396c44b95bc9ac" translate="yes" xml:space="preserve">
          <source>Vector inner and outer products, &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt;&lt;code&gt;numpy.inner&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;numpy.outer#numpy.outer&quot;&gt;&lt;code&gt;numpy.outer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">向量内部和外部乘积&lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt; &lt;code&gt;numpy.inner&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;numpy.outer#numpy.outer&quot;&gt; &lt;code&gt;numpy.outer&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc155524d5d2ad1522cc08f2291c52dc38dcecf1" translate="yes" xml:space="preserve">
          <source>Vector inner products:</source>
          <target state="translated">矢量内制品。</target>
        </trans-unit>
        <trans-unit id="7b8a7176d65340f9da0fa7937d046de8633e6685" translate="yes" xml:space="preserve">
          <source>Vector outer product:</source>
          <target state="translated">矢量外积。</target>
        </trans-unit>
        <trans-unit id="acae4c791d04e4455a560ff6e41306cbb57dcf51" translate="yes" xml:space="preserve">
          <source>Vector(s) with the singular values, within each vector sorted in descending order. The first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions have the same size as those of the input &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">每个向量中具有奇异值的向量，它们按降序排列。前 &lt;code&gt;a.ndim - 2&lt;/code&gt; 维的大小与输入 &lt;code&gt;a&lt;/code&gt; 的大小相同。</target>
        </trans-unit>
        <trans-unit id="2a5acfbe842fd0541792480526462188b04dde53" translate="yes" xml:space="preserve">
          <source>Vector, vector returns the scalar inner product, but neither argument is complex-conjugated:</source>
          <target state="translated">向量,向量返回标量内积,但这两个参数都不是复数共轭的。</target>
        </trans-unit>
        <trans-unit id="c6ec9d2e3c00c48eca40b4ca66a3c4d474b90630" translate="yes" xml:space="preserve">
          <source>Vectorized function.</source>
          <target state="translated">矢量化函数。</target>
        </trans-unit>
        <trans-unit id="7bfe5238ce1d36e9bfcb089f4f57728d117a113e" translate="yes" xml:space="preserve">
          <source>Verify the mean and the variance:</source>
          <target state="translated">验证平均值和方差。</target>
        </trans-unit>
        <trans-unit id="01e4cae31c98991a3d53edad9d5a04ca08ed4f3b" translate="yes" xml:space="preserve">
          <source>Version numbering</source>
          <target state="translated">版本编号</target>
        </trans-unit>
        <trans-unit id="51eea7cbb443c92981917f3f8bfdb384f15a6153" translate="yes" xml:space="preserve">
          <source>Version of this function that preserves the shape of ar1.</source>
          <target state="translated">这个函数的版本,保留了ar1的形状。</target>
        </trans-unit>
        <trans-unit id="224aeb6086ba7022d83156756ac873c6ff737642" translate="yes" xml:space="preserve">
          <source>Versus a regular NumPy array of type &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;unicode&lt;/code&gt;, this class adds the following functionality:</source>
          <target state="translated">与类型为&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;unicode&lt;/code&gt; 的常规NumPy数组相比，此类增加了以下功能：</target>
        </trans-unit>
        <trans-unit id="a21f850c092874207e85425f1992b2d1d4a0daef" translate="yes" xml:space="preserve">
          <source>Versus a regular NumPy array of type &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;unicode&lt;/code&gt;, this class adds the following functionality:</source>
          <target state="translated">与类型为 &lt;code&gt;str&lt;/code&gt; 或 &lt;code&gt;unicode&lt;/code&gt; 的常规NumPy数组相比，此类增加了以下功能：</target>
        </trans-unit>
        <trans-unit id="ba00ebd75f3175e23b4f09615b45ef3560ac5818" translate="yes" xml:space="preserve">
          <source>View based and advanced indexing is mixed. In this case the view based indexing defines a collection of subarrays that are combined by the advanced indexing. For example, &lt;code&gt;arr[[1, 2, 3], :]&lt;/code&gt; is created by vertically stacking the subarrays &lt;code&gt;arr[1, :]&lt;/code&gt;, &lt;code&gt;arr[2,:]&lt;/code&gt;, and &lt;code&gt;arr[3, :]&lt;/code&gt;.</source>
          <target state="translated">基于视图的索引和高级索引混合在一起。在这种情况下，基于视图的索引定义了由高级索引组合的子数组的集合。例如， &lt;code&gt;arr[[1, 2, 3], :]&lt;/code&gt; 是通过垂直堆叠的子阵列创建 &lt;code&gt;arr[1, :]&lt;/code&gt; ， &lt;code&gt;arr[2,:]&lt;/code&gt; ，和 &lt;code&gt;arr[3, :]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2ca30abe686b95f053f55957fa5266ab07dca0a" translate="yes" xml:space="preserve">
          <source>View inputs as arrays with at least three dimensions.</source>
          <target state="translated">将输入视为至少有三个维度的数组。</target>
        </trans-unit>
        <trans-unit id="45fb889525ea027b940786067638d779d675de17" translate="yes" xml:space="preserve">
          <source>View inputs as arrays with at least two dimensions.</source>
          <target state="translated">将输入视为至少有两个维度的数组。</target>
        </trans-unit>
        <trans-unit id="6e4fbf98b4a2f11308bf6ec449635485ea8cdb89" translate="yes" xml:space="preserve">
          <source>View of &lt;code&gt;a&lt;/code&gt; with the number of dimensions increased by one.</source>
          <target state="translated">观 &lt;code&gt;a&lt;/code&gt; ，尺寸的数量增加了一个。</target>
        </trans-unit>
        <trans-unit id="cbf2e6fd5608dfcde8e1d428501030442d53386c" translate="yes" xml:space="preserve">
          <source>View of &lt;code&gt;a&lt;/code&gt;, with axes suitably permuted.</source>
          <target state="translated">查看的 &lt;code&gt;a&lt;/code&gt; ，与轴适当地置换。</target>
        </trans-unit>
        <trans-unit id="690413363bd8aafde5497bc7e1d13a4d8e5f2372" translate="yes" xml:space="preserve">
          <source>View the array as a record array:</source>
          <target state="translated">以记录数组的形式查看数组。</target>
        </trans-unit>
        <trans-unit id="81d42abd80c44b454ac926e28ee7856a84a169a3" translate="yes" xml:space="preserve">
          <source>Viewing array data using a different type and dtype:</source>
          <target state="translated">使用不同类型和dtype查看数组数据。</target>
        </trans-unit>
        <trans-unit id="59879f373c87da4a2c95c0412230c3555cfc240e" translate="yes" xml:space="preserve">
          <source>Views returned from einsum are now writeable whenever the input array is writeable. For example, &lt;code&gt;np.einsum('ijk...-&amp;gt;kji...', a)&lt;/code&gt; will now have the same effect as &lt;a href=&quot;numpy.swapaxes#numpy.swapaxes&quot;&gt;&lt;code&gt;np.swapaxes(a, 0, 2)&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; will return a writeable view of the diagonal of a 2D array.</source>
          <target state="translated">现在，只要输入数组可写，从einsum返回的视图就可以写。例如， &lt;code&gt;np.einsum('ijk...-&amp;gt;kji...', a)&lt;/code&gt; 现在将与&lt;a href=&quot;numpy.swapaxes#numpy.swapaxes&quot;&gt; &lt;code&gt;np.swapaxes(a, 0, 2)&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; 将返回2D数组对角线的可写视图。</target>
        </trans-unit>
        <trans-unit id="212733d972db48c77aaab9351402436eae4fd2ff" translate="yes" xml:space="preserve">
          <source>Views share data:</source>
          <target state="translated">观点共享数据。</target>
        </trans-unit>
        <trans-unit id="c9d8f3fc365bae8c1e0312cb68b7341a485aec6e" translate="yes" xml:space="preserve">
          <source>Views that change the dtype size (bytes per entry) should normally be avoided on arrays defined by slices, transposes, fortran-ordering, etc.:</source>
          <target state="translated">通常应该避免在由slices、transposes、fortran-ordering等定义的数组上使用改变dtype大小(每个条目的字节数)的视图。</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="3cd2f9e2b1f25c2f5e7b93f7ce911077d7d964a4" translate="yes" xml:space="preserve">
          <source>W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery, &amp;ldquo;Numerical Recipes (3rd edition)&amp;rdquo;, Cambridge University Press, 2007, page 795.</source>
          <target state="translated">WH Press，SA Teukolsky，WT Vetterling和BP Flannery，&amp;ldquo;数字食谱（第3版）&amp;rdquo;，剑桥大学出版社，2007年，第795页。</target>
        </trans-unit>
        <trans-unit id="e9c669c28770b602c0d3307e40af975f3d6ab286" translate="yes" xml:space="preserve">
          <source>W.H. Press, B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling, &amp;ldquo;Numerical Recipes&amp;rdquo;, Cambridge University Press, 1986, page 425.</source>
          <target state="translated">WH出版社，BP Flannery，SA Teukolsky和WT Vetterling，&amp;ldquo;数字食谱&amp;rdquo;，剑桥大学出版社，1986年，第425页。</target>
        </trans-unit>
        <trans-unit id="dbd0b2fdf754a4d650097a931842e3ce01d68c23" translate="yes" xml:space="preserve">
          <source>W.H. Press, B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling, &amp;ldquo;Numerical Recipes&amp;rdquo;, Cambridge University Press, 1986, page 429.</source>
          <target state="translated">WH出版社，BP Flannery，SA Teukolsky和WT Vetterling，&amp;ldquo;数字食谱&amp;rdquo;，剑桥大学出版社，1986年，第429页。</target>
        </trans-unit>
        <trans-unit id="4d8b44b86ac9762795ccf1eb37bf4871143a380a" translate="yes" xml:space="preserve">
          <source>WRITEABLE (W) the data area can be written to;</source>
          <target state="translated">WRITEABLE (W)可写入数据区域。</target>
        </trans-unit>
        <trans-unit id="a6dcab075be566e2b98d550a936f8cae5ce9422f" translate="yes" xml:space="preserve">
          <source>WRITEABLE / W</source>
          <target state="translated">可写/W</target>
        </trans-unit>
        <trans-unit id="73fb58e7589a9ff67f327a9e1cfb0abcae369bb5" translate="yes" xml:space="preserve">
          <source>WRITEABLE can only be set &lt;code&gt;True&lt;/code&gt; if the array owns its own memory or the ultimate owner of the memory exposes a writeable buffer interface or is a string.</source>
          <target state="translated">仅当阵列拥有自己的内存或内存的最终所有者公开了可写缓冲区接口或为字符串时，才可以将WRITEABLE设置为 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ca2fe3e818dba5a5804a5bb3a831dd89c500d7a" translate="yes" xml:space="preserve">
          <source>WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced by .base). When the C-API function PyArray_ResolveWritebackIfCopy is called, the base array will be updated with the contents of this array.</source>
          <target state="translated">WRITEBACKIFCOPY (X)这个数组是其他数组的副本(由.base引用),当调用C-API函数PyArray_ResolveWritebackIfCopy时,这个数组的内容将被更新。当C-API函数PyArray_ResolveWritebackIfCopy被调用时,base数组将被更新为这个数组的内容。</target>
        </trans-unit>
        <trans-unit id="3b243b9b37eb143e3a1ec8091e9c80e424b7cb17" translate="yes" xml:space="preserve">
          <source>WRITEBACKIFCOPY / X</source>
          <target state="translated">WRITEBACKIFCOPY/X</target>
        </trans-unit>
        <trans-unit id="09fcb82609179c1f7885c137f520c527fdcb1905" translate="yes" xml:space="preserve">
          <source>WRITEBACKIFCOPY can only be set &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">只能将WRITEBACKIFCOPY设置为 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fd7081253d772e7a32e41421d2cdf6a9cabced2" translate="yes" xml:space="preserve">
          <source>Waloddi Weibull, &amp;ldquo;A Statistical Distribution Function of Wide Applicability&amp;rdquo;, Journal Of Applied Mechanics ASME Paper 1951.</source>
          <target state="translated">Waloddi Weibull，&amp;ldquo;广泛适用性的统计分布函数&amp;rdquo;，《应用力学杂志》 ASME，1951年发表。</target>
        </trans-unit>
        <trans-unit id="db8ff1d3b42b8d1fe40e88e8148de81cccee175c" translate="yes" xml:space="preserve">
          <source>Waloddi Weibull, Royal Technical University, Stockholm, 1939 &amp;ldquo;A Statistical Theory Of The Strength Of Materials&amp;rdquo;, Ingeniorsvetenskapsakademiens Handlingar Nr 151, 1939, Generalstabens Litografiska Anstalts Forlag, Stockholm.</source>
          <target state="translated">Waloddi Weibull，皇家技术大学，斯德哥尔摩，1939年，&amp;ldquo;材料强度的统计理论&amp;rdquo;，Ingeniorsvetenskapsakademiens Handlingar Nr 151，1939年，斯德哥尔摩，Generalstabens Litografiska Anstalt公司。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="4754f4fe525f9c37d19fda1322550a0b26e13158" translate="yes" xml:space="preserve">
          <source>Warning class to filter</source>
          <target state="translated">警告类过滤</target>
        </trans-unit>
        <trans-unit id="f88a191846138392ad4758d4ff77a36f017f6d00" translate="yes" xml:space="preserve">
          <source>Warning objects</source>
          <target state="translated">警告对象</target>
        </trans-unit>
        <trans-unit id="37361059464af82221d16eb1a2018e9694f9cd57" translate="yes" xml:space="preserve">
          <source>Warning: This attribute exists specifically for &lt;code&gt;__array_interface__&lt;/code&gt;, and is not a datatype description compatible with &lt;code&gt;np.dtype&lt;/code&gt;.</source>
          <target state="translated">警告：此属性专门用于 &lt;code&gt;__array_interface__&lt;/code&gt; ，并且不是与 &lt;code&gt;np.dtype&lt;/code&gt; 兼容的数据类型描述。</target>
        </trans-unit>
        <trans-unit id="67f63aaa6eb093a2b8631aeb7aa1f1f56dd3fc86" translate="yes" xml:space="preserve">
          <source>Warning: This functionality does &lt;strong&gt;not&lt;/strong&gt; consider axes separately, i.e. it does not apply interpolation/extrapolation. It fills the return array with the required number of elements, taken from &lt;code&gt;a&lt;/code&gt; as they are laid out in memory, disregarding strides and axes. (This is in case the new shape is smaller. For larger, see above.) This functionality is therefore not suitable to resize images, or data where each axis represents a separate and distinct entity.</source>
          <target state="translated">警告：此功能并&lt;strong&gt;不会&lt;/strong&gt;单独考虑轴，即它并不适用插/外推。它填补与所需数量的元素，取自返回阵列 &lt;code&gt;a&lt;/code&gt; ，因为它们是在存储器布局，忽略进展和轴。 （这是在新形状较小的情况下。对于较大的形状，请参见上文。）因此，此功能不适用于调整图像或数据的大小，其中每个轴代表一个单独且不同的实体。</target>
        </trans-unit>
        <trans-unit id="1430f976c596795274458abcfbc4f280cbfcebac" translate="yes" xml:space="preserve">
          <source>Warnings</source>
          <target state="translated">Warnings</target>
        </trans-unit>
        <trans-unit id="6fcbb55cbf3a317fd9e559a46404d4ffc0901e5d" translate="yes" xml:space="preserve">
          <source>Warns:</source>
          <target state="translated">Warns:</target>
        </trans-unit>
        <trans-unit id="2877e71e929aa29b0e79a512d385261189d70371" translate="yes" xml:space="preserve">
          <source>Wave heights tend to follow a Rayleigh distribution. If the mean wave height is 1 meter, what fraction of waves are likely to be larger than 3 meters?</source>
          <target state="translated">波高往往遵循雷利分布。如果平均波高为1米,那么大于3米的波高可能占多大比例?</target>
        </trans-unit>
        <trans-unit id="d199611fe572f9a604421aeb87fed868192644af" translate="yes" xml:space="preserve">
          <source>We can begin with a chain dot example. In this case, it is optimal to contract the &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; tensors first as represented by the first element of the path &lt;code&gt;(1, 2)&lt;/code&gt;. The resulting tensor is added to the end of the contraction and the remaining contraction &lt;code&gt;(0, 1)&lt;/code&gt; is then completed.</source>
          <target state="translated">我们可以从一个链点示例开始。在这种情况下，最好先收缩 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 张量，如路径 &lt;code&gt;(1, 2)&lt;/code&gt; 的第一个元素所示。将所得张量添加到收缩的末尾，然后完成剩余的收缩 &lt;code&gt;(0, 1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66a6a3c1aa8ab5615ae93578f83c6c2bc137c427" translate="yes" xml:space="preserve">
          <source>We can now compute the mean of the dataset, without taking the invalid data into account:</source>
          <target state="translated">现在我们可以计算数据集的平均值,而不考虑无效数据。</target>
        </trans-unit>
        <trans-unit id="07dfd0de116a4118d2e8d7ab1e0ba4c4055ce110" translate="yes" xml:space="preserve">
          <source>We can replace the maximum values with:</source>
          <target state="translated">我们可以将最大值替换为:</target>
        </trans-unit>
        <trans-unit id="e6a512625d0cb7e17ddcfbaaf190c6f0c94959ed" translate="yes" xml:space="preserve">
          <source>We can reset the function to the default:</source>
          <target state="translated">我们可以将该函数重置为默认值。</target>
        </trans-unit>
        <trans-unit id="b52b8758d686451191a4e1193e567d392d717d53" translate="yes" xml:space="preserve">
          <source>We can rewrite the line equation as &lt;code&gt;y = Ap&lt;/code&gt;, where &lt;code&gt;A = [[x 1]]&lt;/code&gt; and &lt;code&gt;p = [[m], [c]]&lt;/code&gt;. Now use &lt;a href=&quot;#numpy.linalg.lstsq&quot;&gt;&lt;code&gt;lstsq&lt;/code&gt;&lt;/a&gt; to solve for &lt;code&gt;p&lt;/code&gt;:</source>
          <target state="translated">我们可以将线方程改写为 &lt;code&gt;y = Ap&lt;/code&gt; ，其中 &lt;code&gt;A = [[x 1]]&lt;/code&gt; 和 &lt;code&gt;p = [[m], [c]]&lt;/code&gt; 。现在使用&lt;a href=&quot;#numpy.linalg.lstsq&quot;&gt; &lt;code&gt;lstsq&lt;/code&gt; &lt;/a&gt;求解 &lt;code&gt;p&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bcf794d24d8964269b87153ebb1affba96ff631d" translate="yes" xml:space="preserve">
          <source>We can sort either by using sort directly, or argsort and this function</source>
          <target state="translated">我们既可以直接使用排序,也可以使用argsort和这个函数进行排序。</target>
        </trans-unit>
        <trans-unit id="23502bd41157dbb482cc4d93fe154b6f35759b68" translate="yes" xml:space="preserve">
          <source>We can verify this, approximating the derivative with &lt;code&gt;(f(x + h) - f(x))/h&lt;/code&gt;:</source>
          <target state="translated">我们可以用 &lt;code&gt;(f(x + h) - f(x))/h&lt;/code&gt; 近似导数来验证这一点：</target>
        </trans-unit>
        <trans-unit id="1edbc1babc558648a370766b66d6bf09ff4d2327" translate="yes" xml:space="preserve">
          <source>We chose our default threshold because it is in wide use. Other thresholds are possible. For example, elsewhere in the 2007 edition of &lt;em&gt;Numerical recipes&lt;/em&gt; there is an alternative threshold of &lt;code&gt;S.max() *
np.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.)&lt;/code&gt;. The authors describe this threshold as being based on &amp;ldquo;expected roundoff error&amp;rdquo; (p 71).</source>
          <target state="translated">我们选择了默认阈值，因为它已被广泛使用。其他阈值也是可能的。例如，在2007年版《&lt;em&gt;数字食谱》的&lt;/em&gt;其他地方，还有一个替代阈值 &lt;code&gt;S.max() * np.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.)&lt;/code&gt; 。作者将这个阈值描述为基于&amp;ldquo;预期的舍入误差&amp;rdquo;（第71页）。</target>
        </trans-unit>
        <trans-unit id="d8ba993fff071da05f22748cefa6f6b8ad24e53b" translate="yes" xml:space="preserve">
          <source>We could have implemented:</source>
          <target state="translated">我们本可以实施。</target>
        </trans-unit>
        <trans-unit id="59bec2d1c76c534a2fc4afd9318e87ce91e937b9" translate="yes" xml:space="preserve">
          <source>We default to using a 128-bit integer using entropy gathered from the OS. This is a good amount of entropy to initialize all of the generators that we have in numpy. We do not recommend using small seeds below 32 bits for general use. Using just a small set of seeds to instantiate larger state spaces means that there are some initial states that are impossible to reach. This creates some biases if everyone uses such values.</source>
          <target state="translated">我们默认使用从操作系统中收集的熵来使用128位的整数。这对于初始化我们在numpy中的所有生成器来说是一个很好的熵量。我们不推荐使用低于32位的小种子,用于一般用途。只使用小的种子集来实例化更大的状态空间,意味着有一些初始状态是不可能达到的。如果大家都使用这样的值,就会产生一些偏差。</target>
        </trans-unit>
        <trans-unit id="6c39690106b67e736bf72e53ea7082db75a8ca14" translate="yes" xml:space="preserve">
          <source>We expect the arccos of 1 to be 0, and of -1 to be pi:</source>
          <target state="translated">我们期望1的arccos是0,而-1的arccos是pi。</target>
        </trans-unit>
        <trans-unit id="44f2a9cfd92075d83d3f564752917c6115d7836b" translate="yes" xml:space="preserve">
          <source>We expect the arctan of 0 to be 0, and of 1 to be pi/4:</source>
          <target state="translated">我们期望0的arctan是0,1的arctan是pi/4。</target>
        </trans-unit>
        <trans-unit id="60136b35f0997a97a43dcb76040b0f18f3536c81" translate="yes" xml:space="preserve">
          <source>We have 10 degrees of freedom, so is the sample mean within 95% of the recommended value?</source>
          <target state="translated">我们有10个自由度,那么样本均值是否在推荐值的95%以内?</target>
        </trans-unit>
        <trans-unit id="3e23f0ad561893af23edd41efd72f4bd368c5b95" translate="yes" xml:space="preserve">
          <source>We intend to re-implement numpy functions as (generalized) Ufunc, in which case it will become possible for them to be overridden by the &lt;code&gt;__array_ufunc__&lt;/code&gt; method. A prime candidate is &lt;a href=&quot;generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;matmul&lt;/code&gt;&lt;/a&gt;, which currently is not a Ufunc, but could be relatively easily be rewritten as a (set of) generalized Ufuncs. The same may happen with functions such as &lt;a href=&quot;generated/numpy.median#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;min&lt;/code&gt;, and &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">我们打算将numpy函数重新实现为（通用的）Ufunc，在这种情况下，有可能被 &lt;code&gt;__array_ufunc__&lt;/code&gt; 方法覆盖。最主要的候选者是&lt;a href=&quot;generated/numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;matmul&lt;/code&gt; &lt;/a&gt;，它目前不是Ufunc，但是可以相对容易地重写为（一组）广义Ufuncs。函数可能发生同样的情况，例如中&lt;a href=&quot;generated/numpy.median#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;min&lt;/code&gt; 和&lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3cf3455d01dd7db3c5c070359dd30cf5e39de43" translate="yes" xml:space="preserve">
          <source>We need to stress that this behavior may not be systematic, that masked data may be affected by the operation in some cases and therefore users should not rely on this data remaining unchanged.</source>
          <target state="translated">我们需要强调的是,这种行为可能并不是系统性的,被屏蔽的数据在某些情况下可能会受到操作的影响,因此用户不应该依赖这些数据保持不变。</target>
        </trans-unit>
        <trans-unit id="58ff07099c06b392c411860c04ae360c63b97582" translate="yes" xml:space="preserve">
          <source>We only show a few blocks for clarity:</source>
          <target state="translated">为了清楚起见,我们只展示几个区块。</target>
        </trans-unit>
        <trans-unit id="673c3f49f8ee0b4069fb17ea81837a33f48d70f3" translate="yes" xml:space="preserve">
          <source>We recommend using &lt;a href=&quot;numpy.isin#numpy.isin&quot;&gt;&lt;code&gt;isin&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#numpy.in1d&quot;&gt;&lt;code&gt;in1d&lt;/code&gt;&lt;/a&gt; for new code.</source>
          <target state="translated">我们建议使用&lt;a href=&quot;numpy.isin#numpy.isin&quot;&gt; &lt;code&gt;isin&lt;/code&gt; &lt;/a&gt;代替&lt;a href=&quot;#numpy.in1d&quot;&gt; &lt;code&gt;in1d&lt;/code&gt; &lt;/a&gt;对新代码。</target>
        </trans-unit>
        <trans-unit id="7ca33c6b93a76db017c3cdc61675ace9bc2b416c" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;code&gt;.npy&lt;/code&gt; and &lt;code&gt;.npz&lt;/code&gt; extensions for files saved in this format. This is by no means a requirement; applications may wish to use these file formats but use an extension specific to the application. In the absence of an obvious alternative, however, we suggest using &lt;code&gt;.npy&lt;/code&gt; and &lt;code&gt;.npz&lt;/code&gt;.</source>
          <target state="translated">对于以这种格式保存的文件，我们建议使用 &lt;code&gt;.npy&lt;/code&gt; 和 &lt;code&gt;.npz&lt;/code&gt; 扩展名。这绝不是必须的；应用程序可能希望使用这些文件格式，但使用特定于该应用程序的扩展名。但是，在没有明显替代方案的情况下，我们建议使用 &lt;code&gt;.npy&lt;/code&gt; 和 &lt;code&gt;.npz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33c0514953dd33becf83ed3bc37cb8f06826d505" translate="yes" xml:space="preserve">
          <source>We then define a new test case class for each supported data type with a short definition such as:</source>
          <target state="translated">然后我们为每个支持的数据类型定义一个新的测试用例类,并给出一个简短的定义,如:。</target>
        </trans-unit>
        <trans-unit id="ad180c1380373588b422b6f9367e1dfa995335a7" translate="yes" xml:space="preserve">
          <source>We use the algorithm published by Clenshaw &lt;a href=&quot;#rfd38a370b188-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; and referenced by Abramowitz and Stegun &lt;a href=&quot;#rfd38a370b188-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;, for which the function domain is partitioned into the two intervals [0,8] and (8,inf), and Chebyshev polynomial expansions are employed in each interval. Relative error on the domain [0,30] using IEEE arithmetic is documented &lt;a href=&quot;#rfd38a370b188-3&quot; id=&quot;id3&quot;&gt;[3]&lt;/a&gt; as having a peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).</source>
          <target state="translated">我们使用由Clenshaw &lt;a href=&quot;#rfd38a370b188-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;发布并由Abramowitz和Stegun &lt;a href=&quot;#rfd38a370b188-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;引用的算法，针对该算法，功能域被划分为两个区间[0,8]和（8，inf），而Chebyshev多项式展开式则用于每个间隔。使用IEEE算术在域[0,30]上的相对误差记录为&lt;a href=&quot;#rfd38a370b188-3&quot; id=&quot;id3&quot;&gt;[3]&lt;/a&gt;，具有5.8e-16的峰值和均方根值为1.4e-16（n = 30000）。</target>
        </trans-unit>
        <trans-unit id="c9afbb264decb0b7e5bd769fa476b27d49621056" translate="yes" xml:space="preserve">
          <source>We will deal with the domain and window when we get to fitting, for the moment we ignore them and run through the basic algebraic and arithmetic operations.</source>
          <target state="translated">我们在进行拟合的时候会处理域和窗口的问题,目前我们先忽略它们,运行基本的代数和算术运算。</target>
        </trans-unit>
        <trans-unit id="82a72786c4fe5d6bfb5f753a25b0cbc3ef629d6d" translate="yes" xml:space="preserve">
          <source>We wish to mark the fourth entry as invalid. The easiest is to create a masked array:</source>
          <target state="translated">我们希望将第四个条目标记为无效。最简单的方法是创建一个掩码数组。</target>
        </trans-unit>
        <trans-unit id="2678a6cb2f01328bc5e5792424e05e77b5265e7c" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll do a simple outer product, placing the dimensions of the first operand before the dimensions of the second operand. The &lt;code&gt;op_axes&lt;/code&gt; parameter needs one list of axes for each operand, and provides a mapping from the iterator&amp;rsquo;s axes to the axes of the operand.</source>
          <target state="translated">我们将做一个简单的外部乘积，将第一个操作数的尺寸放在第二个操作数的尺寸之前。所述 &lt;code&gt;op_axes&lt;/code&gt; 参数需要轴中的一个列表中的每个操作数，并从迭代器的轴来的操作数的轴提供了一个映射。</target>
        </trans-unit>
        <trans-unit id="ced2186a63444cfbd458cebaed4de6214b500394" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll show how this works by creating a function &lt;a href=&quot;generated/numpy.square#numpy.square&quot;&gt;&lt;code&gt;square&lt;/code&gt;&lt;/a&gt; which squares its input. Let&amp;rsquo;s start with a minimal function definition excluding &amp;lsquo;out&amp;rsquo; parameter support.</source>
          <target state="translated">我们将通过创建一个平方其输入的函数&lt;a href=&quot;generated/numpy.square#numpy.square&quot;&gt; &lt;code&gt;square&lt;/code&gt; &lt;/a&gt;来说明其工作原理。让我们从不包含&amp;ldquo; out&amp;rdquo;参数支持的最小功能定义开始。</target>
        </trans-unit>
        <trans-unit id="0d014927573cadb3b0b374c9809c25adaa8d709f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve seen that 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. The invert or bit-wise NOT of 13 is then:</source>
          <target state="translated">我们已经看到13由 &lt;code&gt;00001101&lt;/code&gt; 表示。那么13的取反或按位非为：</target>
        </trans-unit>
        <trans-unit id="9f5117721c82b02552e432ea3720cde40d7059ad" translate="yes" xml:space="preserve">
          <source>Weight function of the Hermite polynomials.</source>
          <target state="translated">赫米特多项式的权重函数。</target>
        </trans-unit>
        <trans-unit id="95800a204e1bbd4903f4870d8343853257206077" translate="yes" xml:space="preserve">
          <source>Weight function of the Hermite_e polynomials.</source>
          <target state="translated">Hermite_e多项式的权重函数。</target>
        </trans-unit>
        <trans-unit id="5f860b19432a865263496fdce430b1e33571bfe5" translate="yes" xml:space="preserve">
          <source>Weight function of the Laguerre polynomials.</source>
          <target state="translated">拉格尔多项式的权重函数。</target>
        </trans-unit>
        <trans-unit id="79be08f88c623301ce3bc873b7c9affda9625a90" translate="yes" xml:space="preserve">
          <source>Weight function of the Legendre polynomials.</source>
          <target state="translated">Legendre多项式的权重函数。</target>
        </trans-unit>
        <trans-unit id="c74e4e7c5caf95682fb65872b5814741f06c7fac" translate="yes" xml:space="preserve">
          <source>Weighted average</source>
          <target state="translated">加权平均数</target>
        </trans-unit>
        <trans-unit id="d8f6b85e664320ad22c47352d13059c9a94e57ff" translate="yes" xml:space="preserve">
          <source>Weighted average.</source>
          <target state="translated">加权平均数:</target>
        </trans-unit>
        <trans-unit id="50616113e0953b16858a840423f52798108ba636" translate="yes" xml:space="preserve">
          <source>Weights to apply to the y-coordinates of the sample points. For gaussian uncertainties, use 1/sigma (not 1/sigma**2).</source>
          <target state="translated">对样本点的y坐标进行加权。对于高斯不确定度,使用1/sigma(不是1/sigma**2)。</target>
        </trans-unit>
        <trans-unit id="5a7070233023bbad210855f921220f6a37969ec7" translate="yes" xml:space="preserve">
          <source>Weights, array of the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">权重，与 &lt;code&gt;x&lt;/code&gt; 形状相同的数组。</target>
        </trans-unit>
        <trans-unit id="946476c654c11a5e92f8b55850bb98a1263ad96b" translate="yes" xml:space="preserve">
          <source>Weights. If not None the contribution of each point &lt;code&gt;(x[i],y[i])&lt;/code&gt; to the fit is weighted by &lt;code&gt;w[i]&lt;/code&gt;. Ideally the weights are chosen so that the errors of the products &lt;code&gt;w[i]*y[i]&lt;/code&gt; all have the same variance. The default value is None.</source>
          <target state="translated">重量。如果不是 &lt;code&gt;(x[i],y[i])&lt;/code&gt; 则用 &lt;code&gt;w[i]&lt;/code&gt; 加权每个点（x [i]，y [i]）对拟合的贡献。理想地，选择权重以使得乘积 &lt;code&gt;w[i]*y[i]&lt;/code&gt; 的误差均具有相同的方差。默认值为&amp;ldquo;无&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="1c25ee55e973a0ac3876804d2f28cc0929f53254" translate="yes" xml:space="preserve">
          <source>Weights. If not None, the contribution of each point &lt;code&gt;(x[i],y[i])&lt;/code&gt; to the fit is weighted by &lt;code&gt;w[i]&lt;/code&gt;. Ideally the weights are chosen so that the errors of the products &lt;code&gt;w[i]*y[i]&lt;/code&gt; all have the same variance. The default value is None.</source>
          <target state="translated">重量。如果不为None，则每个点 &lt;code&gt;(x[i],y[i])&lt;/code&gt; 对拟合的贡献均由 &lt;code&gt;w[i]&lt;/code&gt; 加权。理想地，选择权重以使得乘积 &lt;code&gt;w[i]*y[i]&lt;/code&gt; 的误差均具有相同的方差。默认值为&amp;ldquo;无&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="890907bf4b6e9a3c2721945116f4521c292ba997" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Binomial Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/BinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/BinomialDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein，EricW。&amp;ldquo;二项式分布&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/BinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/BinomialDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="44532eacfd8a477fb8d811692e1a730faf373cda" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Cauchy Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/CauchyDistribution.html&quot;&gt;http://mathworld.wolfram.com/CauchyDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein，EricW。&amp;ldquo;漂亮的分布&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/CauchyDistribution.html&quot;&gt;http://mathworld.wolfram.com/CauchyDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ce6b4d0490f5c6c29f7bd660e93014a010601e88" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Gamma Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/GammaDistribution.html&quot;&gt;http://mathworld.wolfram.com/GammaDistribution.html&lt;/a&gt;</source>
          <target state="translated">韦斯斯坦，埃里克&amp;middot;W。&amp;ldquo;伽玛分布&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/GammaDistribution.html&quot;&gt;http://mathworld.wolfram.com/GammaDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="250b4512032938435df06c099254026086b0b46d" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Hypergeometric Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/HypergeometricDistribution.html&quot;&gt;http://mathworld.wolfram.com/HypergeometricDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein，EricW。&amp;ldquo;超几何分布&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/HypergeometricDistribution.html&quot;&gt;http://mathworld.wolfram.com/HypergeometricDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="403ee22c6c9f5dfb6128b5015952af83dc7fe1f5" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Laplace Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/LaplaceDistribution.html&quot;&gt;http://mathworld.wolfram.com/LaplaceDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein，EricW。&amp;ldquo;拉普拉斯分布&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/LaplaceDistribution.html&quot;&gt;http://mathworld.wolfram.com/LaplaceDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c85ee5175b40c6661962e1c4dcdc7232b8e5568a" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Logistic Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/LogisticDistribution.html&quot;&gt;http://mathworld.wolfram.com/LogisticDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein，EricW。&amp;ldquo;物流配送&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/LogisticDistribution.html&quot;&gt;http://mathworld.wolfram.com/LogisticDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1938577c4f79d7fadb65a22f0b9b9cba0e6904e" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Negative Binomial Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein，EricW。&amp;ldquo;负二项分布&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed9cdcffdd5a34db501b8269560f163da34bcfda" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Noncentral F-Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/NoncentralF-Distribution.html&quot;&gt;http://mathworld.wolfram.com/NoncentralF-Distribution.html&lt;/a&gt;</source>
          <target state="translated">魏斯汀，埃里克&amp;middot;W。&amp;ldquo;非中心F分布&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/NoncentralF-Distribution.html&quot;&gt;http://mathworld.wolfram.com/NoncentralF-Distribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6786c23a16b57cae22a2a2fe8c5eef583bfac0cc" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Poisson Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/PoissonDistribution.html&quot;&gt;http://mathworld.wolfram.com/PoissonDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein，Eric W.&amp;ldquo;泊松分布&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/PoissonDistribution.html&quot;&gt;http://mathworld.wolfram.com/PoissonDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="87ff1415ce102e6420c0e0f61ef322d348a5f507" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Sinc Function.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/SincFunction.html&quot;&gt;http://mathworld.wolfram.com/SincFunction.html&lt;/a&gt;</source>
          <target state="translated">Weisstein，Eric W.&amp;ldquo; Sinc函数&amp;rdquo;。来自MathWorld &amp;ndash; Wolfram Web资源。&lt;a href=&quot;http://mathworld.wolfram.com/SincFunction.html&quot;&gt;http://mathworld.wolfram.com/SincFunction.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3fef717821661f9806ec19067704e1d37a6e1a47" translate="yes" xml:space="preserve">
          <source>What are the least-squares-best &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;y0&lt;/code&gt; in &lt;code&gt;y = y0 + mx&lt;/code&gt; for the following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points and you&amp;rsquo;ll see that it should be y0 = 0, m = 1.) The answer is provided by solving the over-determined matrix equation &lt;code&gt;Ax = b&lt;/code&gt;, where:</source>
          <target state="translated">对于以下数据，{=（0,1），（1,0），（1,2），（2,1）} 在 &lt;code&gt;y = y0 + mx&lt;/code&gt; ，最小二乘最佳 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;y0&lt;/code&gt; 是多少。（绘制点，您将看到它应该为y0 = 0，m =1。）答案是通过求解超定矩阵方程 &lt;code&gt;Ax = b&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="3e9b892da0c44e54a5a3d94ba212b74404ec1950" translate="yes" xml:space="preserve">
          <source>What can be converted to a data-type object is described below:</source>
          <target state="translated">下面介绍可以转换为数据类型对象的内容。</target>
        </trans-unit>
        <trans-unit id="7f1eadc1a60d1383bbd27a5874b7f7b346ec84b4" translate="yes" xml:space="preserve">
          <source>What encoding to use when reading Python 2 strings. Only useful when loading Python 2 generated pickled files in Python 3, which includes npy/npz files containing object arrays. Values other than &amp;lsquo;latin1&amp;rsquo;, &amp;lsquo;ASCII&amp;rsquo;, and &amp;lsquo;bytes&amp;rsquo; are not allowed, as they can corrupt numerical data. Default: &amp;lsquo;ASCII&amp;rsquo;</source>
          <target state="translated">读取Python 2字符串时使用哪种编码。仅当在Python 3中加载Python 2生成的腌制文件时有用，该文件包括包含对象数组的npy / npz文件。不允许使用&amp;ldquo; latin1&amp;rdquo;，&amp;ldquo; ASCII&amp;rdquo;和&amp;ldquo; bytes&amp;rdquo;以外的其他值，因为它们会破坏数字数据。默认值：&amp;ldquo; ASCII&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="1e1fa581e9e916507b4446a529a092d8e86437db" translate="yes" xml:space="preserve">
          <source>What is a masked array?</source>
          <target state="translated">什么是掩码数组?</target>
        </trans-unit>
        <trans-unit id="437c59796bebb67cae1bb453196d12e5dabd418f" translate="yes" xml:space="preserve">
          <source>What is compared are values, not types. So an int (1) and an array of length one can evaluate as True:</source>
          <target state="translated">比较的是值,而不是类型。所以一个int(1)和一个长度为1的数组可以评价为True。</target>
        </trans-unit>
        <trans-unit id="ed5c56f4637ad63b06ae7f91c4fda9c76b610d6b" translate="yes" xml:space="preserve">
          <source>What is tested is whether the input has a non-zero imaginary part, not if the input type is complex.</source>
          <target state="translated">测试的是输入的虚部是否为非零,而不是输入类型是否为复数。</target>
        </trans-unit>
        <trans-unit id="010a5d0834f679e03164332d6d50425424fc97f8" translate="yes" xml:space="preserve">
          <source>What is the amortization schedule for a 1 year loan of $2500 at 8.24% interest per year compounded monthly?</source>
          <target state="translated">贷款1年2500元,年息8.24%,月复利,其摊还期是多少?</target>
        </trans-unit>
        <trans-unit id="59aacf2a72313a7cde0de3da40cb764e30627fa7" translate="yes" xml:space="preserve">
          <source>What is the future value after 10 years of saving $100 now, with an additional monthly savings of $100. Assume the interest rate is 5% (annually) compounded monthly?</source>
          <target state="translated">现在存100元,每月多存100元,10年后的未来价值是多少。假设利率为5%(年),每月复利?</target>
        </trans-unit>
        <trans-unit id="68f86a620521000717f405763a7c2c87aeacd919" translate="yes" xml:space="preserve">
          <source>What is the monthly payment needed to pay off a $200,000 loan in 15 years at an annual interest rate of 7.5%?</source>
          <target state="translated">按年利率7.5%计算,15年内还清20万元贷款需要多少月供?</target>
        </trans-unit>
        <trans-unit id="bd55b3638089456ad2fcd33f8ddb002a9ff2afef" translate="yes" xml:space="preserve">
          <source>What is the present value (e.g., the initial investment) of an investment that needs to total $15692.93 after 10 years of saving $100 every month? Assume the interest rate is 5% (annually) compounded monthly.</source>
          <target state="translated">某项投资10年后,每月存100元,共需15692.93元,现值(如初始投资)是多少?假设利率为5%(年),每月复利。</target>
        </trans-unit>
        <trans-unit id="80bbcabaec75450b003887ef27bbf523c85b5a9f" translate="yes" xml:space="preserve">
          <source>What is the right way to index multi-dimensional arrays? Before you jump to conclusions about the one and true way to index multi-dimensional arrays, it pays to understand why this is a confusing issue. This section will try to explain in detail how numpy indexing works and why we adopt the convention we do for images, and when it may be appropriate to adopt other conventions.</source>
          <target state="translated">多维数组的正确索引方式是什么?在你对多维数组索引的正确方法下结论之前,最好先了解一下为什么这是一个令人困惑的问题。本节将尝试详细解释numpy索引是如何工作的,以及为什么我们对图像采用这种约定,什么时候采用其他约定是合适的。</target>
        </trans-unit>
        <trans-unit id="0bd771107f7afe976fc592b463f0e0c3505ed432" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s New or Different</source>
          <target state="translated">有什么新变化</target>
        </trans-unit>
        <trans-unit id="9f2949fbd884fd2e87977bc6442d7541c249e9bc" translate="yes" xml:space="preserve">
          <source>What’s New or Different</source>
          <target state="translated">什么是新的或不同的</target>
        </trans-unit>
        <trans-unit id="7c1df74199c25c42832661082d6ca6ac9e56b175" translate="yes" xml:space="preserve">
          <source>Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May). Open Document Format for Office Applications (OpenDocument)v1.2, Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version, Pre-Draft 12. Organization for the Advancement of Structured Information Standards (OASIS). Billerica, MA, USA. [ODT Document]. Available: &lt;a href=&quot;http://www.oasis-open.org/committees/documents.php&quot;&gt;http://www.oasis-open.org/committees/documents.php&lt;/a&gt; ?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt</source>
          <target state="translated">惠勒（Wheeler，DA），拉瑟克（E.Rathke）和威尔（R.Weir）（编辑）（2009年5月）。 Office应用程序的开放文档格式（OpenDocument）v1.2，第2部分：重新计算的公式（OpenFormula）格式-带注释的版本，预草案12。结构化信息标准促进组织（OASIS）。美国马萨诸塞州比勒里卡。 [ODT文件]。可用：&lt;a href=&quot;http://www.oasis-open.org/committees/documents.php&quot;&gt;http&lt;/a&gt; : //www.oasis-open.org/committees/documents.php？wg_abbrev = office-formulaOpenDocument-formula-20090508.odt</target>
        </trans-unit>
        <trans-unit id="030c83d2119f52206dbf3733046b420a1749a0e1" translate="yes" xml:space="preserve">
          <source>Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May). Open Document Format for Office Applications (OpenDocument)v1.2, Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version, Pre-Draft 12. Organization for the Advancement of Structured Information Standards (OASIS). Billerica, MA, USA. [ODT Document]. Available: &lt;a href=&quot;http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula&quot;&gt;http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula&lt;/a&gt; OpenDocument-formula-20090508.odt</source>
          <target state="translated">惠勒（Wheeler，DA），拉瑟克（E.Rathke）和威尔（R.Weir）（编辑）（2009年5月）。Office应用程序的开放文档格式（OpenDocument）v1.2，第2部分：重新计算的公式（OpenFormula）格式-带注释的版本，预草案12。结构化信息标准促进组织（OASIS）。美国马萨诸塞州比勒里卡。[ODT文件]。可用：&lt;a href=&quot;http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula&quot;&gt;http&lt;/a&gt; : //www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula OpenDocument-formula-20090508.odt</target>
        </trans-unit>
        <trans-unit id="28b30ef805c7fb044e119b47e7ac08078b5b70cf" translate="yes" xml:space="preserve">
          <source>When &amp;lsquo;decimals&amp;rsquo; is negative, it specifies the number of positions to the left of the decimal point. The real and imaginary parts of complex numbers are rounded separately. Nothing is done if the array is not of float type and &amp;lsquo;decimals&amp;rsquo; is greater than or equal to 0.</source>
          <target state="translated">当&amp;ldquo;小数&amp;rdquo;为负数时，它指定小数点左侧的位置数。复数的实部和虚部分别取整。如果数组不是浮点型并且'decimals'大于或等于0，则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="f209cff1399437b00b7cd0ee8730d177efc65293" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; is specified, the typical inner loop construct is as follows.</source>
          <target state="translated">当指定&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; 时&lt;/a&gt;，典型的内部循环结构如下。</target>
        </trans-unit>
        <trans-unit id="e3bd2b595c2ff9c9cbf3b48defe560bc708bb864" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#numpy.ma.MaskedArray.tofile&quot;&gt;&lt;code&gt;tofile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">何时&lt;a href=&quot;#numpy.ma.MaskedArray.tofile&quot;&gt; &lt;code&gt;tofile&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d17005044d622bf07127624dd5d1775dbe22cd5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not a valid dtype for a structured array.</source>
          <target state="translated">当&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;不是结构化数组的有效dtype时。</target>
        </trans-unit>
        <trans-unit id="105e60976ea8fbfb90203db8ab4a0a320369170d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;A = rfft(a)&lt;/code&gt; and fs is the sampling frequency, &lt;code&gt;A[0]&lt;/code&gt; contains the zero-frequency term 0*fs, which is real due to Hermitian symmetry.</source>
          <target state="translated">当 &lt;code&gt;A = rfft(a)&lt;/code&gt; 且fs为采样频率时， &lt;code&gt;A[0]&lt;/code&gt; 包含零频率项0 * fs，由于厄米对称性，该频率为实数。</target>
        </trans-unit>
        <trans-unit id="fb065328be54e2c3569cb5f58bbc8287bcb1fb7d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; is called, the array pointed to by base will be updated with the contents of this array.</source>
          <target state="translated">当 &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; 被调用时，该阵列所指向的基将与此数组的内容进行更新。</target>
        </trans-unit>
        <trans-unit id="6087c2287fac970fe48c994c66e9668908c28aae" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a = 1&lt;/code&gt;, the Weibull distribution reduces to the exponential distribution.</source>
          <target state="translated">当 &lt;code&gt;a = 1&lt;/code&gt; ，威布尔分布减小为指数分布。</target>
        </trans-unit>
        <trans-unit id="3234eec63d682a68b39f821bda537d5249018389" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is a 2D array, it is factorized as &lt;code&gt;u @ np.diag(s) @ vh
= (u * s) @ vh&lt;/code&gt;, where &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;vh&lt;/code&gt; are 2D unitary arrays and &lt;code&gt;s&lt;/code&gt; is a 1D array of &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s singular values. When &lt;code&gt;a&lt;/code&gt; is higher-dimensional, SVD is applied in stacked mode as explained below.</source>
          <target state="translated">当 &lt;code&gt;a&lt;/code&gt; 被2D阵列，它被分解为 &lt;code&gt;u @ np.diag(s) @ vh = (u * s) @ vh&lt;/code&gt; ，其中 &lt;code&gt;u&lt;/code&gt; 和 &lt;code&gt;vh&lt;/code&gt; 是2D阵列酉和 &lt;code&gt;s&lt;/code&gt; 是一维数组 &lt;code&gt;a&lt;/code&gt; 的奇异值。当 &lt;code&gt;a&lt;/code&gt; 高维时，如下所述，SVD以堆叠模式应用。</target>
        </trans-unit>
        <trans-unit id="40bcbe29998f385e3a1059191be0f61338a8c763" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is a structured array, this argument specifies which fields to compare first, second, and so on. This list does not need to include all of the fields.</source>
          <target state="translated">当 &lt;code&gt;a&lt;/code&gt; 是结构化数组时，此参数指定要比较的字段第一，第二，依此类推。该列表不需要包括所有字段。</target>
        </trans-unit>
        <trans-unit id="c171b92b4bddf9c8ebd2e75ee317f0b5fe3e94eb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</source>
          <target state="translated">当 &lt;code&gt;a&lt;/code&gt; 是定义了字段的数组时，此参数指定要比较的字段的第一个，第二个等。单个字段可以指定为字符串，并且不需要指定所有字段，但是仍将使用未指定的字段。他们以dtype出现的顺序来打破关系。</target>
        </trans-unit>
        <trans-unit id="78f75090c501ced3a2b9ede8c30345a037a7c202" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need to be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</source>
          <target state="translated">当 &lt;code&gt;a&lt;/code&gt; 是定义了字段的数组时，此参数指定要比较的字段的第一个，第二个等。单个字段可以指定为字符串，并且不需要指定所有字段，但仍将使用未指定的字段他们在dtype中出现的顺序，以打破平局。</target>
        </trans-unit>
        <trans-unit id="2cd3e98c67109375f859806b9beef061a4ef694a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string. Not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</source>
          <target state="translated">当 &lt;code&gt;a&lt;/code&gt; 是定义了字段的数组时，此参数指定要比较第一，第二等的字段。可以将单个字段指定为字符串。并非所有字段都需要指定，但是未指定的字段仍会按照在dtype中出现的顺序使用，以打破联系。</target>
        </trans-unit>
        <trans-unit id="b2ce72a40e12e2d7dda3e8c60930788493a39d27" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. Not all fields need be specified.</source>
          <target state="translated">当 &lt;code&gt;a&lt;/code&gt; 是定义了字段的数组时，此参数指定要比较的字段的第一个，第二个等。并非所有字段都需要指定。</target>
        </trans-unit>
        <trans-unit id="d9212747ec3985b5dbc30be906a85b9cd4a58814" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;axes&lt;/code&gt; is integer_like, the sequence for evaluation will be: first the -Nth axis in &lt;code&gt;a&lt;/code&gt; and 0th axis in &lt;code&gt;b&lt;/code&gt;, and the -1th axis in &lt;code&gt;a&lt;/code&gt; and Nth axis in &lt;code&gt;b&lt;/code&gt; last.</source>
          <target state="translated">当 &lt;code&gt;axes&lt;/code&gt; 为integer_like时，求值顺序为：首先是a中的-N轴和 &lt;code&gt;b&lt;/code&gt; 中 &lt;code&gt;a&lt;/code&gt; 第0轴，最后是 &lt;code&gt;b&lt;/code&gt; 中 &lt;code&gt;a&lt;/code&gt; 和N轴中的第-1轴。</target>
        </trans-unit>
        <trans-unit id="a0e5c01c245527cc066079729775f892bf5a93e0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;axis&lt;/code&gt; is specified, &lt;code&gt;values&lt;/code&gt; must have the correct shape.</source>
          <target state="translated">当 &lt;code&gt;axis&lt;/code&gt; 被指定， &lt;code&gt;values&lt;/code&gt; 必须具有正确的形状。</target>
        </trans-unit>
        <trans-unit id="3a3f207a74aef7083c1eb02bef5c64216a30b6fc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;condition&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt; contain masked values.</source>
          <target state="translated">当 &lt;code&gt;condition&lt;/code&gt; 或 &lt;code&gt;a&lt;/code&gt; 包含掩蔽值。</target>
        </trans-unit>
        <trans-unit id="f3581744e88f263225956bbed713e5c867c6bf74" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;copy=False&lt;/code&gt; and a copy is made for other reasons, the result is the same as if &lt;code&gt;copy=True&lt;/code&gt;, with some exceptions for &lt;code&gt;A&lt;/code&gt;, see the Notes section. The default order is &amp;lsquo;K&amp;rsquo;.</source>
          <target state="translated">如果 &lt;code&gt;copy=False&lt;/code&gt; 且由于其他原因进行了复制，则结果与 &lt;code&gt;copy=True&lt;/code&gt; 相同，但 &lt;code&gt;A&lt;/code&gt; 例外，请参见&amp;ldquo;注释&amp;rdquo;部分。默认顺序为&amp;ldquo; K&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2e1ae66e35c85b2fe34abaa8efd6e58beb3b3355" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;df&lt;/code&gt; &amp;lt;= 0 or when an inappropriate &lt;code&gt;size&lt;/code&gt; (e.g. &lt;code&gt;size=-1&lt;/code&gt;) is given.</source>
          <target state="translated">当 &lt;code&gt;df&lt;/code&gt; &amp;lt;= 0或给出不合适的 &lt;code&gt;size&lt;/code&gt; （例如 &lt;code&gt;size=-1&lt;/code&gt; ）时。</target>
        </trans-unit>
        <trans-unit id="6647686e555ae4abe6c033723e872acfb1bd3153" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;df&lt;/code&gt; independent random variables, each with standard normal distributions (mean 0, variance 1), are squared and summed, the resulting distribution is chi-square (see Notes). This distribution is often used in hypothesis testing.</source>
          <target state="translated">对每个具有标准正态分布（均值0，方差1）的 &lt;code&gt;df&lt;/code&gt; 独立随机变量进行平方和求和时，所得分布为卡方（见注）。此分布通常用于假设检验中。</target>
        </trans-unit>
        <trans-unit id="ffb0cfba1c0d31cbfd6e3e6d57d32a4b67d07be0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;high&lt;/code&gt; == &lt;code&gt;low&lt;/code&gt;, values of &lt;code&gt;low&lt;/code&gt; will be returned. If &lt;code&gt;high&lt;/code&gt; &amp;lt; &lt;code&gt;low&lt;/code&gt;, the results are officially undefined and may eventually raise an error, i.e. do not rely on this function to behave when passed arguments satisfying that inequality condition.</source>
          <target state="translated">当 &lt;code&gt;high&lt;/code&gt; == &lt;code&gt;low&lt;/code&gt; ，值 &lt;code&gt;low&lt;/code&gt; 将被退回。如果 &lt;code&gt;high&lt;/code&gt; &amp;lt; &lt;code&gt;low&lt;/code&gt; ，则结果在官方上是不确定的，并且最终可能会引发错误，即，在传递满足该不等式条件的参数时，不要依赖此函数的行为。</target>
        </trans-unit>
        <trans-unit id="f9aa8b45107567c376fa7741eff97cb12f0255ea" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;normed&lt;/code&gt; is True, then the returned histogram is the sample density, defined such that the sum over bins of the product &lt;code&gt;bin_value * bin_area&lt;/code&gt; is 1.</source>
          <target state="translated">当 &lt;code&gt;normed&lt;/code&gt; 为True时，返回的直方图就是样本密度，定义为使得乘积 &lt;code&gt;bin_value * bin_area&lt;/code&gt; bin上的总和为1。</target>
        </trans-unit>
        <trans-unit id="d3c1a253c347320a48abee4b8144700cbe11dedb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;op[i]&lt;/code&gt; is NULL, the requested data type &lt;code&gt;op_dtypes[i]&lt;/code&gt; may be NULL as well, in which case it is automatically generated from the dtypes of the arrays which are flagged as readable. The rules for generating the dtype are the same is for UFuncs. Of special note is handling of byte order in the selected dtype. If there is exactly one input, the input&amp;rsquo;s dtype is used as is. Otherwise, if more than one input dtypes are combined together, the output will be in native byte order.</source>
          <target state="translated">当 &lt;code&gt;op[i]&lt;/code&gt; 为NULL时，请求的数据类型 &lt;code&gt;op_dtypes[i]&lt;/code&gt; 也可以为NULL，在这种情况下，它是根据标记为可读的数组的dtypes自动生成的。生成dtype的规则与UFunc相同。特别要注意的是在选定的dtype中处理字节顺序。如果只有一个输入，则按原样使用输入的dtype。否则，如果将多个输入dtypes组合在一起，则输出将以本机字节顺序。</target>
        </trans-unit>
        <trans-unit id="8b2b29bdbe08a7c3e8ddf1683de5150728b2dbef" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;order&lt;/code&gt; is &amp;lsquo;A&amp;rsquo;, it will preserve the array&amp;rsquo;s &amp;lsquo;C&amp;rsquo; or &amp;lsquo;F&amp;rsquo; ordering:</source>
          <target state="translated">当 &lt;code&gt;order&lt;/code&gt; 为'A'时，它将保留数组的'C'或'F'顺序：</target>
        </trans-unit>
        <trans-unit id="6b8f346f1161f4e387f8b7fce9c3c4eab735e268" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;order&lt;/code&gt; is &amp;lsquo;K&amp;rsquo;, it will preserve orderings that are neither &amp;lsquo;C&amp;rsquo; nor &amp;lsquo;F&amp;rsquo;, but won&amp;rsquo;t reverse axes:</source>
          <target state="translated">当 &lt;code&gt;order&lt;/code&gt; 为'K'时，它将保留既不是'C'也不是'F'的顺序，但不会反转轴：</target>
        </trans-unit>
        <trans-unit id="08a648e9a0d7c320ff7a951bdd5b53abf89293b1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;p&lt;/code&gt; cannot be converted to a rank-1 array.</source>
          <target state="translated">当 &lt;code&gt;p&lt;/code&gt; 无法转换为等级1数组时。</target>
        </trans-unit>
        <trans-unit id="e45ca1a69513367d482121e776e438a0bc2c1c76" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;path&lt;/code&gt; is an URL, &lt;a href=&quot;#numpy.DataSource.exists&quot;&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/a&gt; will return True if it&amp;rsquo;s either stored locally in the &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; directory, or is a valid remote URL. &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; does not discriminate between the two, the file is accessible if it exists in either location.</source>
          <target state="translated">当 &lt;code&gt;path&lt;/code&gt; 是URL时，如果它是本地存储在&lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt;目录中或是有效的远程URL ，则&lt;a href=&quot;#numpy.DataSource.exists&quot;&gt; &lt;code&gt;exists&lt;/code&gt; &lt;/a&gt;将返回True 。&lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt;不会区分这两者，如果文件在任一位置都可以访问。</target>
        </trans-unit>
        <trans-unit id="25d6d2d2a499c808880c721a0e1b19db64d43932" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;seed&lt;/code&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, a new &lt;code&gt;BitGenerator&lt;/code&gt; and &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; will be instantiated each time. This function does not manage a default global instance.</source>
          <target state="translated">如果省略 &lt;code&gt;seed&lt;/code&gt; 或 &lt;code&gt;None&lt;/code&gt; ，则每次都会实例化一个新的 &lt;code&gt;BitGenerator&lt;/code&gt; 和&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;。此功能不管理默认的全局实例。</target>
        </trans-unit>
        <trans-unit id="548ec80d9148e8694deef2af35ec844cd9f8fe80" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;writemasked&lt;/code&gt; flag is used, and this operand is buffered, this changes how data is copied from the buffer into the array. A masked copying routine is used, which only copies the elements in the buffer for which &lt;code&gt;writemasked&lt;/code&gt; returns true from the corresponding element in the ARRAYMASK operand.</source>
          <target state="translated">当使用 &lt;code&gt;writemasked&lt;/code&gt; 标志并且对该操作数进行缓冲时，这将更改如何将数据从缓冲区复制到数组中。使用屏蔽的复制例程，该例程仅从ARRAYMASK操作数中的对应元素复制缓冲区中的那些元素，对于这些元素， &lt;code&gt;writemasked&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="e06542a52ac6a1f85d560afb9efd573db44bd48f" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, the result order is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;prototype&lt;/em&gt; is a fortran array, &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt; otherwise. When &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, the result order matches that of &lt;em&gt;prototype&lt;/em&gt;, even when the axes of &lt;em&gt;prototype&lt;/em&gt; aren&amp;rsquo;t in C or Fortran order.</source>
          <target state="translated">当&lt;em&gt;order&lt;/em&gt;为&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; 时&lt;/a&gt;，如果&lt;em&gt;原型&lt;/em&gt;为fortran数组，则结果顺序为&lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt;，否则为&lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt;。当&lt;em&gt;顺序&lt;/em&gt;是&lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt;，结果顺序匹配的那个&lt;em&gt;原型&lt;/em&gt;，即使当轴&lt;em&gt;原型&lt;/em&gt;不是C或Fortran的顺序。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad9397f3e6e3e4c72dcb47695405ed9d0b6444eb" translate="yes" xml:space="preserve">
          <source>When NumPy is built, information about system configuration is recorded, and is made available for extension modules using NumPy&amp;rsquo;s C API. These are mostly defined in &lt;code&gt;numpyconfig.h&lt;/code&gt; (included in &lt;code&gt;ndarrayobject.h&lt;/code&gt;). The public symbols are prefixed by &lt;code&gt;NPY_*&lt;/code&gt;. NumPy also offers some functions for querying information about the platform in use.</source>
          <target state="translated">构建NumPy时，将记录有关系统配置的信息，并使用NumPy的C API将其提供给扩展模块。这些大多在 &lt;code&gt;numpyconfig.h&lt;/code&gt; 中定义（包含在 &lt;code&gt;ndarrayobject.h&lt;/code&gt; 中）。公用符号以 &lt;code&gt;NPY_*&lt;/code&gt; 为前缀。 NumPy还提供了一些用于查询有关所使用平台的信息的功能。</target>
        </trans-unit>
        <trans-unit id="f9eebd0d248f1a6803fb5b3cabe894035e7a712b" translate="yes" xml:space="preserve">
          <source>When True, trailing zeros are removed from the inputs. When False, the inputs are passed through intact.</source>
          <target state="translated">当为 &quot;真 &quot;时,输入的尾部零会被删除。当为 &quot;False &quot;时,输入将完整地通过。</target>
        </trans-unit>
        <trans-unit id="97a14729b31bf94d828802c225db2f870571e19a" translate="yes" xml:space="preserve">
          <source>When a &lt;em&gt;casting&lt;/em&gt; error occurs during assignment (for example updating a numerical array using a sequence of strings), the array being assigned to may end up in an unpredictable partially updated state. However, if any other error (such as an out of bounds index) occurs, the array will remain unchanged.</source>
          <target state="translated">如果在分配过程中发生&lt;em&gt;转换&lt;/em&gt;错误（例如，使用字符串序列更新数字数组），则分配给该数组的结果可能会以不可预测的部分更新状态结束。但是，如果发生任何其他错误（例如越界索引），则数组将保持不变。</target>
        </trans-unit>
        <trans-unit id="0d0060f5095733a108d2028d216426111947fd92" translate="yes" xml:space="preserve">
          <source>When a broadcasting error occurs, the iterator raises an exception which includes the input shapes to help diagnose the problem.</source>
          <target state="translated">当发生广播错误时,迭代器会引发一个异常,其中包括输入形状以帮助诊断问题。</target>
        </trans-unit>
        <trans-unit id="bb6f21e3a640b767ac7aa4f3739c198a4f93da24" translate="yes" xml:space="preserve">
          <source>When a memmap causes a file to be created or extended beyond its current size in the filesystem, the contents of the new part are unspecified. On systems with POSIX filesystem semantics, the extended part will be filled with zero bytes.</source>
          <target state="translated">当memmap导致文件被创建或扩展到文件系统中超过其当前大小时,新部分的内容是未指定的。在具有POSIX文件系统语义的系统中,扩展部分将被零字节填充。</target>
        </trans-unit>
        <trans-unit id="9b87e186d194de6f9d4cd9e098a815eab1dbc5b7" translate="yes" xml:space="preserve">
          <source>When a recording filter is added, matching warnings are stored in the &lt;code&gt;log&lt;/code&gt; attribute as well as in the list returned by &lt;code&gt;record&lt;/code&gt;.</source>
          <target state="translated">添加记录过滤器后，匹配的警告将存储在 &lt;code&gt;log&lt;/code&gt; 属性以及 &lt;code&gt;record&lt;/code&gt; 返回的列表中。</target>
        </trans-unit>
        <trans-unit id="ba1de10f5ac1f9d67feabe34568ca76340334549" translate="yes" xml:space="preserve">
          <source>When a ufunc is called, many things must be done. The information collected from these setup operations is stored in a loop-object. This loop object is a C-structure (that could become a Python object but is not initialized as such because it is only used internally). This loop object has the layout needed to be used with PyArray_Broadcast so that the broadcasting can be handled in the same way as it is handled in other sections of code.</source>
          <target state="translated">当一个ufunc被调用时,必须做很多事情。从这些设置操作中收集到的信息被存储在一个 loop-对象中。这个循环对象是一个 C-结构 (它可以成为一个 Python 对象,但没有被初始化,因为它只在内部使用)。这个循环对象具有与PyArray_Broadcast一起使用所需的布局,因此可以用处理其他代码部分的方式来处理广播。</target>
        </trans-unit>
        <trans-unit id="bed1032321553c178be0f4aa76322e048587c74c" translate="yes" xml:space="preserve">
          <source>When a view is desired in as many cases as possible, &lt;code&gt;arr.reshape(-1)&lt;/code&gt; may be preferable.</source>
          <target state="translated">在尽可能多的情况下需要查看时， &lt;code&gt;arr.reshape(-1)&lt;/code&gt; 可能是首选。</target>
        </trans-unit>
        <trans-unit id="3d973a2064387ee8231885f5fb66b3c4832468fa" translate="yes" xml:space="preserve">
          <source>When accessing a single entry of a masked array with no named fields, the output is either a scalar (if the corresponding entry of the mask is &lt;code&gt;False&lt;/code&gt;) or the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; (if the corresponding entry of the mask is &lt;code&gt;True&lt;/code&gt;):</source>
          <target state="translated">当访问没有命名字段的被掩码数组的单个条目时，输出要么是标量（如果掩码的相应条目为 &lt;code&gt;False&lt;/code&gt; ），要么是&lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;的特殊值（如果掩码的相应条目为 &lt;code&gt;True&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="06a15d5053f26aa57bf4b46b8d10d7192f9bc439" translate="yes" xml:space="preserve">
          <source>When accessing a slice, the output is a masked array whose &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; attribute is a view of the original data, and whose mask is either &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (if there was no invalid entries in the original array) or a view of the corresponding slice of the original mask. The view is required to ensure propagation of any modification of the mask to the original.</source>
          <target state="translated">访问切片时，输出是被掩码的数组，其&lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt;属性是原始数据的视图，并且其掩码是&lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;（如果原始数组中没有无效的条目）或原始的相应切片的视图面具。需要该视图以确保将蒙版的任何修改传播到原始蒙版。</target>
        </trans-unit>
        <trans-unit id="4d92b7829e88a948fb9eb65ffcf73c11643904a9" translate="yes" xml:space="preserve">
          <source>When added within a context, filters are only added inside the context and will be forgotten when the context is exited.</source>
          <target state="translated">当在上下文中添加时,过滤器只在上下文中添加,退出上下文时将被遗忘。</target>
        </trans-unit>
        <trans-unit id="9541e02340938d50efa6e54249172d0ce37841bb" translate="yes" xml:space="preserve">
          <source>When adding the &amp;lsquo;out&amp;rsquo; parameter, we have to explicitly provide those flags, because if someone passes in an array as &amp;lsquo;out&amp;rsquo;, the iterator will default to &amp;lsquo;readonly&amp;rsquo;, and our inner loop would fail. The reason &amp;lsquo;readonly&amp;rsquo; is the default for input arrays is to prevent confusion about unintentionally triggering a reduction operation. If the default were &amp;lsquo;readwrite&amp;rsquo;, any broadcasting operation would also trigger a reduction, a topic which is covered later in this document.</source>
          <target state="translated">添加'out'参数时，我们必须显式提供这些标志，因为如果有人将数组作为'out'传递，则迭代器将默认为'readonly'，并且我们的内部循环将失败。输入数组的默认值&amp;ldquo;只读&amp;rdquo;的原因是为了避免因意外触发归约操作而引起的混乱。如果默认值为&amp;ldquo; readwrite&amp;rdquo;，则任何广播操作都将触发减少操作，该主题将在本文档后面介绍。</target>
        </trans-unit>
        <trans-unit id="4db060a24fc0c2ce0739cc8fe613a0f3bd607af5" translate="yes" xml:space="preserve">
          <source>When advanced indices are next to each other transposing may be necessary. All necessary transposing is handled by &lt;code&gt;PyArray_MapIterSwapAxes&lt;/code&gt; and has to be handled by the caller unless &lt;code&gt;PyArray_MapIterNew&lt;/code&gt; is asked to allocate the result.</source>
          <target state="translated">当高级索引彼此相邻时，可能需要转置。除非要求 &lt;code&gt;PyArray_MapIterNew&lt;/code&gt; 分配结果，否则所有必需的转置都由 &lt;code&gt;PyArray_MapIterSwapAxes&lt;/code&gt; 处理，并且必须由调用方处理。</target>
        </trans-unit>
        <trans-unit id="d51d0efd85b1005294bf85e6a8973d000ac30965" translate="yes" xml:space="preserve">
          <source>When all weights along axis are zero. See &lt;a href=&quot;numpy.ma.average#numpy.ma.average&quot;&gt;&lt;code&gt;numpy.ma.average&lt;/code&gt;&lt;/a&gt; for a version robust to this type of error.</source>
          <target state="translated">沿轴的所有权重均为零时。请参阅&lt;a href=&quot;numpy.ma.average#numpy.ma.average&quot;&gt; &lt;code&gt;numpy.ma.average&lt;/code&gt; &lt;/a&gt;以获取对此类错误更可靠的版本。</target>
        </trans-unit>
        <trans-unit id="c8f93d8039436724f69d84838e7be89d226d23fc" translate="yes" xml:space="preserve">
          <source>When an array, each row is a coordinate in a D-dimensional space - such as &lt;code&gt;histogramgramdd(np.array([p1, p2, p3]))&lt;/code&gt;.</source>
          <target state="translated">当是数组时，每一行都是D维空间中的坐标-例如 &lt;code&gt;histogramgramdd(np.array([p1, p2, p3]))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82d8732b0393645ea59279b9ddb8a309ed548c77" translate="yes" xml:space="preserve">
          <source>When an array_like, each element is the list of values for single coordinate - such as &lt;code&gt;histogramgramdd((X, Y, Z))&lt;/code&gt;.</source>
          <target state="translated">当为array_like时，每个元素都是单个坐标的值的列表-例如 &lt;code&gt;histogramgramdd((X, Y, Z))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="355be91097240a30b4454a31696bf68a0b258227" translate="yes" xml:space="preserve">
          <source>When an axis is specified the subarrays indexed by the axis are sorted. This is done by making the specified axis the first dimension of the array and then flattening the subarrays in C order. The flattened subarrays are then viewed as a structured type with each element given a label, with the effect that we end up with a 1-D array of structured types that can be treated in the same way as any other 1-D array. The result is that the flattened subarrays are sorted in lexicographic order starting with the first element.</source>
          <target state="translated">当指定一个轴时,由轴索引的子数组将被排序。这是通过将指定的轴作为数组的第一维,然后按C顺序对子数组进行扁平化处理来实现的。扁平化后的子数组被看作是一个结构化类型,每个元素都被赋予一个标签,其效果是我们最终得到一个结构化类型的1-D数组,可以用与其他1-D数组相同的方式处理。结果是,扁平化子数组从第一个元素开始按词法顺序排序。</target>
        </trans-unit>
        <trans-unit id="6b69f1e4103645c38ed661fd82fe69ef3f4b8546" translate="yes" xml:space="preserve">
          <source>When an ellipsis (&lt;code&gt;...&lt;/code&gt;) is present but has no size (i.e. replaces zero &lt;code&gt;:&lt;/code&gt;) the result will still always be an array. A view if no advanced index is present, otherwise a copy.</source>
          <target state="translated">当一个省略号（ &lt;code&gt;...&lt;/code&gt; ）存在，但没有大小（即取代零 &lt;code&gt;:&lt;/code&gt; ）的结果仍然将永远是一个数组。如果没有高级索引，则为视图，否则为副本。</target>
        </trans-unit>
        <trans-unit id="3d4c4fe16d2ce5d90f03758ae48eb086b0f73e4f" translate="yes" xml:space="preserve">
          <source>When an input date falls on the weekend or a holiday, &lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt;&lt;code&gt;busday_offset&lt;/code&gt;&lt;/a&gt; first applies a rule to roll the date to a valid business day, then applies the offset. The default rule is &amp;lsquo;raise&amp;rsquo;, which simply raises an exception. The rules most typically used are &amp;lsquo;forward&amp;rsquo; and &amp;lsquo;backward&amp;rsquo;.</source>
          <target state="translated">当输入日期是在周末或假日时，&lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt; &lt;code&gt;busday_offset&lt;/code&gt; &lt;/a&gt;首先应用规则将日期滚动到有效的工作日，然后应用偏移量。默认规则是&amp;ldquo; raise&amp;rdquo;，它只会引发一个异常。最常用的规则是&amp;ldquo;前进&amp;rdquo;和&amp;ldquo;后退&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="64e5ff0649d57b71884c5f5309f3367e78576ca8" translate="yes" xml:space="preserve">
          <source>When applied to masked arrays, this function drops the mask information if the &lt;code&gt;to_begin&lt;/code&gt; and/or &lt;code&gt;to_end&lt;/code&gt; parameters are used.</source>
          <target state="translated">当应用到屏蔽数组时，如果使用 &lt;code&gt;to_begin&lt;/code&gt; 和/或 &lt;code&gt;to_end&lt;/code&gt; 参数，此函数将删除屏蔽信息。</target>
        </trans-unit>
        <trans-unit id="f9f55c2f275cd5eebce400c5d632f8721b4b827a" translate="yes" xml:space="preserve">
          <source>When axis is not None, this function does the same thing as &amp;ldquo;fancy&amp;rdquo; indexing (indexing arrays using arrays); however, it can be easier to use if you need elements along a given axis. A call such as &lt;code&gt;np.take(arr, indices, axis=3)&lt;/code&gt; is equivalent to &lt;code&gt;arr[:,:,:,indices,...]&lt;/code&gt;.</source>
          <target state="translated">当axis不为None时，此功能与&amp;ldquo;奇特&amp;rdquo;索引（使用数组索引数组）具有相同的作用；但是，如果您需要沿给定轴的元素，则使用起来会更容易。诸如 &lt;code&gt;np.take(arr, indices, axis=3)&lt;/code&gt; 类的调用等效于 &lt;code&gt;arr[:,:,:,indices,...]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98c8d4285d8be1f6c2247d830229aff2863b6c70" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, controls the size of the temporary buffers. Set to 0 for the default value.</source>
          <target state="translated">启用缓冲时,控制临时缓冲区的大小。默认值设置为0。</target>
        </trans-unit>
        <trans-unit id="16e4f331a390aab5d5358796f242e2ca6c555d93" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, this allows the size of the inner loop to grow when buffering isn&amp;rsquo;t necessary. This option is best used if you&amp;rsquo;re doing a straight pass through all the data, rather than anything with small cache-friendly arrays of temporary values for each inner loop.</source>
          <target state="translated">启用缓冲后，如果不需要缓冲，则允许内部循环的大小增加。如果您要直接通过所有数据，而不是每个内部循环都使用小型缓存友好型临时值数组的任何内容，则最好使用此选项。</target>
        </trans-unit>
        <trans-unit id="b51f6738b373830fc8b3cc055c675ac17c018d38" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, this also switches to a special buffering mode which reduces the loop length as necessary to not trample on values being reduced.</source>
          <target state="translated">当启用缓冲时,这也会切换到一个特殊的缓冲模式,根据需要减少循环长度,以免践踏被减少的值。</target>
        </trans-unit>
        <trans-unit id="41819020a24f8ece45999c2f5c36e5cb1be0993f" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, this delays allocation of the buffers until &lt;a href=&quot;#c.NpyIter_Reset&quot;&gt;&lt;code&gt;NpyIter_Reset&lt;/code&gt;&lt;/a&gt; or another reset function is called. This flag exists to avoid wasteful copying of buffer data when making multiple copies of a buffered iterator for multi-threaded iteration.</source>
          <target state="translated">启用缓冲后，这会延迟缓冲区的分配，直到&lt;a href=&quot;#c.NpyIter_Reset&quot;&gt; &lt;code&gt;NpyIter_Reset&lt;/code&gt; &lt;/a&gt;或另一个复位函数为止。存在此标志以避免在为多线程迭代创建缓冲迭代器的多个副本时避免浪费地复制缓冲区数据。</target>
        </trans-unit>
        <trans-unit id="230c13e7258bcd1f717539097a4dd43ccf64c97d" translate="yes" xml:space="preserve">
          <source>When calculating the power of an experiment (power = probability of rejecting the null hypothesis when a specific alternative is true) the non-central F statistic becomes important. When the null hypothesis is true, the F statistic follows a central F distribution. When the null hypothesis is not true, then it follows a non-central F statistic.</source>
          <target state="translated">在计算实验的功率时(功率=当一个特定的备选方案为真时拒绝零假设的概率),非中心F统计量变得很重要。当零假设为真时,F统计量遵循中心F分布。当零假设不为真时,则遵循非中心F统计量。</target>
        </trans-unit>
        <trans-unit id="67a93e8e91305afaf6fc0532016e5191c667e052" translate="yes" xml:space="preserve">
          <source>When called on a zero-d array or scalar, &lt;code&gt;nonzero(a)&lt;/code&gt; is treated as &lt;code&gt;nonzero(atleast1d(a))&lt;/code&gt;.</source>
          <target state="translated">当一个零d阵列或标量，在称为 &lt;code&gt;nonzero(a)&lt;/code&gt; 被视为 &lt;code&gt;nonzero(atleast1d(a))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05271cb09f7d75c6bfb61cf24594f89c89131399" translate="yes" xml:space="preserve">
          <source>When called with only scalars, &lt;code&gt;np.block&lt;/code&gt; is equivalent to an ndarray call. So &lt;code&gt;np.block([[1, 2], [3, 4]])&lt;/code&gt; is equivalent to &lt;code&gt;np.array([[1, 2], [3, 4]])&lt;/code&gt;.</source>
          <target state="translated">仅使用标量调用时， &lt;code&gt;np.block&lt;/code&gt; 等效于ndarray调用。因此 &lt;code&gt;np.block([[1, 2], [3, 4]])&lt;/code&gt; 等效于 &lt;code&gt;np.array([[1, 2], [3, 4]])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb3fc5492e5904c93f3605a33709fbb0c2bb0c5b" translate="yes" xml:space="preserve">
          <source>When casting from complex to float or int. To avoid this, one should use &lt;code&gt;a.real.astype(t)&lt;/code&gt;.</source>
          <target state="translated">从复数转换为浮点数或整数时。为了避免这种情况，应该使用 &lt;code&gt;a.real.astype(t)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3afb0a37a10edd1baec0a1dc8d2095269323f16d" translate="yes" xml:space="preserve">
          <source>When creating a 0-d array from an array scalar use &lt;code&gt;f-&amp;gt;setitem&lt;/code&gt; instead of the standard copy from an array scalar. Must use if you don&amp;rsquo;t define an array scalar to go along with the data-type.</source>
          <target state="translated">从数组标量创建0维数组时，请使用 &lt;code&gt;f-&amp;gt;setitem&lt;/code&gt; 而不是从数组标量中复制标准副本。如果您没有定义数组标量与数据类型一起使用，则必须使用。</target>
        </trans-unit>
        <trans-unit id="8887c1561ce70af56f037b9ba953356547c232a4" translate="yes" xml:space="preserve">
          <source>When creating a new masked array with a simple, non-structured datatype, the mask is initially set to the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;, that corresponds roughly to the boolean &lt;code&gt;False&lt;/code&gt;. Trying to set an element of &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; will fail with a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception, as a boolean does not support item assignment.</source>
          <target state="translated">当使用简单的&lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;数据类型创建新的掩码数组时，掩码最初设置为特殊值nomask，该值大致对应于布尔 &lt;code&gt;False&lt;/code&gt; 。尝试设置&lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;的元素将失败，并出现&lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;异常，因为布尔值不支持项目分配。</target>
        </trans-unit>
        <trans-unit id="4e6d2af630e30f862a489ba6df45674126eb3cd4" translate="yes" xml:space="preserve">
          <source>When creating an array of datetimes from a string, it is still possible to automatically select the unit from the inputs, by using the datetime type with generic units.</source>
          <target state="translated">当从一个字符串创建一个日期时间数组时,仍然可以通过使用通用单位的日期时间类型,从输入中自动选择单位。</target>
        </trans-unit>
        <trans-unit id="36a5c7d333e9c484967d9590699c121ae8287b5d" translate="yes" xml:space="preserve">
          <source>When either of the elements is masked, the result is masked as well, but the underlying boolean data are still set, with self and other considered equal if both are masked, and unequal otherwise.</source>
          <target state="translated">当其中任何一个元素被遮蔽时,结果也被遮蔽,但底层的布尔数据仍然被设置,如果两个元素都被遮蔽,则self和other视为相等,否则不相等。</target>
        </trans-unit>
        <trans-unit id="2c15c829ea1146c460c63d87fff55a43784eaa99" translate="yes" xml:space="preserve">
          <source>When estimating the standard error of a proportion in a population by using a random sample, the normal distribution works well unless the product p*n &amp;lt;=5, where p = population proportion estimate, and n = number of samples, in which case the binomial distribution is used instead. For example, a sample of 15 people shows 4 who are left handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4, so the binomial distribution should be used in this case.</source>
          <target state="translated">当使用随机样本估算总体中某个比例的标准误时，正态分布很好，除非乘积p * n &amp;lt;= 5，其中p =总体比例估算，n =样本数量，在这种情况下而是使用二项式分布。例如，一个15个人的样本显示了4个左撇子和11个右撇子。那么p = 4/15 = 27％。0.27 * 15 = 4，因此在这种情况下应使用二项式分布。</target>
        </trans-unit>
        <trans-unit id="b79bfc37b770b9a9d472063cecf571e647616c67" translate="yes" xml:space="preserve">
          <source>When fid is a file object, array contents are directly written to the file, bypassing the file object&amp;rsquo;s &lt;code&gt;write&lt;/code&gt; method. As a result, tofile cannot be used with files objects supporting compression (e.g., GzipFile) or file-like objects that do not support &lt;code&gt;fileno()&lt;/code&gt; (e.g., BytesIO).</source>
          <target state="translated">当fid是文件对象时，将数组内容直接写入文件，而绕过文件对象的 &lt;code&gt;write&lt;/code&gt; 方法。结果，tofile不能与支持压缩的文件对象（例如GzipFile）或不支持 &lt;code&gt;fileno()&lt;/code&gt; 的类似文件的对象（例如BytesIO）一起使用。</target>
        </trans-unit>
        <trans-unit id="b8650f4614cacd7afc4a45f34e856756be0c8acc" translate="yes" xml:space="preserve">
          <source>When forcing an iteration order, we observed that the external loop option may provide the elements in smaller chunks because the elements can&amp;rsquo;t be visited in the appropriate order with a constant stride. When writing C code, this is generally fine, however in pure Python code this can cause a significant reduction in performance.</source>
          <target state="translated">在强制执行迭代顺序时，我们观察到外部循环选项可能会以较小的块提供元素，因为无法以恒定的步幅按适当的顺序访问元素。在编写C代码时，这通常很好，但是在纯Python代码中，这可能会导致性能显着降低。</target>
        </trans-unit>
        <trans-unit id="63eda21eb7811aeacc325fcf56f657d21ccc05f4" translate="yes" xml:space="preserve">
          <source>When one or more of the arrays to be concatenated is a MaskedArray, this function will return a MaskedArray object instead of an ndarray, but the input masks are &lt;em&gt;not&lt;/em&gt; preserved. In cases where a MaskedArray is expected as input, use the ma.concatenate function from the masked array module instead.</source>
          <target state="translated">当要串联的一个或多个数组为MaskedArray时，此函数将返回MaskedArray对象而不是ndarray，但&lt;em&gt;不会&lt;/em&gt;保留输入掩码。如果需要使用MaskedArray作为输入，请改用MaskedArray模块中的ma.concatenate函数。</target>
        </trans-unit>
        <trans-unit id="eccfc4e1a7be21e04b2017257495e340f746e64f" translate="yes" xml:space="preserve">
          <source>When only &lt;code&gt;condition&lt;/code&gt; is provided, this function is a shorthand for &lt;code&gt;np.asarray(condition).nonzero()&lt;/code&gt;. Using &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt; directly should be preferred, as it behaves correctly for subclasses. The rest of this documentation covers only the case where all three arguments are provided.</source>
          <target state="translated">仅提供 &lt;code&gt;condition&lt;/code&gt; ，此函数是 &lt;code&gt;np.asarray(condition).nonzero()&lt;/code&gt; 的简写。最好直接使用&lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt;，因为它对于子类的行为正确。本文档的其余部分仅涉及提供所有三个参数的情况。</target>
        </trans-unit>
        <trans-unit id="b8419db09cea322048fba5bff5f136770a8b6713" translate="yes" xml:space="preserve">
          <source>When only &lt;code&gt;condition&lt;/code&gt; is provided, this function is identical to &lt;a href=&quot;numpy.ma.nonzero#numpy.ma.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;. The rest of this documentation covers only the case where all three arguments are provided.</source>
          <target state="translated">仅提供 &lt;code&gt;condition&lt;/code&gt; ，此函数&lt;a href=&quot;numpy.ma.nonzero#numpy.ma.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt;。本文档的其余部分仅涉及提供所有三个参数的情况。</target>
        </trans-unit>
        <trans-unit id="a83dea336fc44b86e10fe7d04631005f6869d53b" translate="yes" xml:space="preserve">
          <source>When opening the saved &lt;code&gt;.npz&lt;/code&gt; file with &lt;a href=&quot;numpy.load#numpy.load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; a &lt;code&gt;NpzFile&lt;/code&gt; object is returned. This is a dictionary-like object which can be queried for its list of arrays (with the &lt;code&gt;.files&lt;/code&gt; attribute), and for the arrays themselves.</source>
          <target state="translated">当打开保存 &lt;code&gt;.npz&lt;/code&gt; 与文件&lt;a href=&quot;numpy.load#numpy.load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt;一个 &lt;code&gt;NpzFile&lt;/code&gt; 被返回的对象。这是一个类似于字典的对象，可以查询其数组列表（带有 &lt;code&gt;.files&lt;/code&gt; 属性）以及数组本身。</target>
        </trans-unit>
        <trans-unit id="26e6b9fa52377f35e02d57b8c33d212f74b50ae3" translate="yes" xml:space="preserve">
          <source>When order is &amp;lsquo;A&amp;rsquo; and &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; is an array in neither &amp;lsquo;C&amp;rsquo; nor &amp;lsquo;F&amp;rsquo; order, and a copy is forced by a change in dtype, then the order of the result is not necessarily &amp;lsquo;C&amp;rsquo; as expected. This is likely a bug.</source>
          <target state="translated">当order为'A'并且&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt;是既不是'C'也不是'F'的数组，并且由于dtype的改变而强制执行复制时，结果的顺序不一定是预期的'C'。这可能是一个错误。</target>
        </trans-unit>
        <trans-unit id="5be535caa0bb6516144fc1de604b8372d3c9991d" translate="yes" xml:space="preserve">
          <source>When payments are due (&amp;lsquo;begin&amp;rsquo; (1) or &amp;lsquo;end&amp;rsquo; (0))</source>
          <target state="translated">付款到期时（&amp;ldquo;开始&amp;rdquo;（1）或&amp;ldquo;结束&amp;rdquo;（0））</target>
        </trans-unit>
        <trans-unit id="9149bcf3649f5259f262c786b3a7a6478a7a8e0f" translate="yes" xml:space="preserve">
          <source>When payments are due (&amp;lsquo;begin&amp;rsquo; (1) or &amp;lsquo;end&amp;rsquo; (0)). Defaults to {&amp;lsquo;end&amp;rsquo;, 0}.</source>
          <target state="translated">付款到期时（&amp;ldquo;开始&amp;rdquo;（1）或&amp;ldquo;结束&amp;rdquo;（0））。默认为{'end'，0}。</target>
        </trans-unit>
        <trans-unit id="6642df63420a359718ac20ea567420cbe3b18377" translate="yes" xml:space="preserve">
          <source>When performance is important for manipulating many business dates with one particular choice of weekmask and holidays, there is an object &lt;a href=&quot;generated/numpy.busdaycalendar#numpy.busdaycalendar&quot;&gt;&lt;code&gt;busdaycalendar&lt;/code&gt;&lt;/a&gt; which stores the data necessary in an optimized form.</source>
          <target state="translated">当性能对于使用多个特殊的选择的工作日和假期来处理许多业务日期很重要时，有一个对象&lt;a href=&quot;generated/numpy.busdaycalendar#numpy.busdaycalendar&quot;&gt; &lt;code&gt;busdaycalendar&lt;/code&gt; &lt;/a&gt;以优化的形式存储必要的数据。</target>
        </trans-unit>
        <trans-unit id="fd00b76d3636aeca15fb36d92b84ae47d7409ff3" translate="yes" xml:space="preserve">
          <source>When positive infinity and negative infinity are present:</source>
          <target state="translated">当正无穷和负无穷出现时。</target>
        </trans-unit>
        <trans-unit id="57212127eb9536990cda5db105b01bdf8367e735" translate="yes" xml:space="preserve">
          <source>When spaces are used as delimiters, or when no delimiter has been given as input, there should not be any missing data between two fields.</source>
          <target state="translated">当使用空格作为定界符时,或者当输入时没有给出定界符时,两个字段之间不应该有任何缺失的数据。</target>
        </trans-unit>
        <trans-unit id="2c6d6090a315dc06167791d55632ca0e61a0eb7f" translate="yes" xml:space="preserve">
          <source>When studying hypothesis tests that assume normality, seeing how the tests perform on data from a Cauchy distribution is a good indicator of their sensitivity to a heavy-tailed distribution, since the Cauchy looks very much like a Gaussian distribution, but with heavier tails.</source>
          <target state="translated">在研究假设正态性的假设检验时,看检验在Cauchy分布的数据上的表现是一个很好的指标,说明它们对重尾分布的敏感性,因为Cauchy看起来很像高斯分布,但尾部更重。</target>
        </trans-unit>
        <trans-unit id="83471109ed39b7eca8654b0b5b56f710df2f0ed6" translate="yes" xml:space="preserve">
          <source>When success (0 return value) is returned, either out_arr is filled with a non-NULL PyArrayObject and the rest of the parameters are untouched, or out_arr is filled with NULL, and the rest of the parameters are filled.</source>
          <target state="translated">当返回成功(返回值为0)时,要么用一个非NULL的PyArrayObject填充out_arr,其余参数不被触动,要么用NULL填充out_arr,其余参数被填充。</target>
        </trans-unit>
        <trans-unit id="c5848cbfcc751d6fb624a1cce409c076b5cc5302" translate="yes" xml:space="preserve">
          <source>When the &amp;ldquo;external_loop&amp;rdquo; was not used during construction, but is desired, this modifies the iterator to behave as if the flag was specified.</source>
          <target state="translated">如果在构造过程中未使用&amp;ldquo; external_loop&amp;rdquo;，但希望使用&amp;ldquo; external_loop&amp;rdquo;，则它将修改迭代器，使其表现得就像指定了标志。</target>
        </trans-unit>
        <trans-unit id="a1da80e9817b29febb418ac2727dd8feb1e9ca57" translate="yes" xml:space="preserve">
          <source>When the &amp;ldquo;multi_index&amp;rdquo; flag was specified, this removes it, allowing the internal iteration structure to be optimized further.</source>
          <target state="translated">指定&amp;ldquo; multi_index&amp;rdquo;标志后，将其删除，从而可以进一步优化内部迭代结构。</target>
        </trans-unit>
        <trans-unit id="ea45d329df78eba717c22414db760106850fd424" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;axis&lt;/code&gt; keyword is specified an array of appropriate size is returned.</source>
          <target state="translated">当 &lt;code&gt;axis&lt;/code&gt; 指定的关键字被返回适当大小的阵列。</target>
        </trans-unit>
        <trans-unit id="3fdd0f5189c6dc8a23dfca9586f442b975510baf" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;axis&lt;/code&gt; keyword is used an array is returned.</source>
          <target state="translated">使用 &lt;code&gt;axis&lt;/code&gt; 关键字时，将返回一个数组。</target>
        </trans-unit>
        <trans-unit id="53c50ce51f38684cf2835cdea8b4002b8bbf92a8" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;c_index&lt;/code&gt; or &lt;code&gt;f_index&lt;/code&gt; flag was used, this property provides access to the index. Raises a ValueError if accessed and &lt;code&gt;has_index&lt;/code&gt; is False.</source>
          <target state="translated">当使用 &lt;code&gt;c_index&lt;/code&gt; 或 &lt;code&gt;f_index&lt;/code&gt; 标志时，此属性提供对索引的访问。如果已访问且 &lt;code&gt;has_index&lt;/code&gt; 为False，则引发ValueError 。</target>
        </trans-unit>
        <trans-unit id="76706b5098ca6b382b941c090b506c3f0587d432" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;multi_index&lt;/code&gt; flag was used, this property provides access to the index. Raises a ValueError if accessed accessed and &lt;code&gt;has_multi_index&lt;/code&gt; is False.</source>
          <target state="translated">使用 &lt;code&gt;multi_index&lt;/code&gt; 标志时，此属性提供对索引的访问。如果访问已访问且 &lt;code&gt;has_multi_index&lt;/code&gt; 为False，则引发ValueError 。</target>
        </trans-unit>
        <trans-unit id="ac5d59cc3a2303eaecb29429bf707b0c3c3bedde" translate="yes" xml:space="preserve">
          <source>When the DFT is computed for purely real input, the output is Hermitian-symmetric, i.e. the negative frequency terms are just the complex conjugates of the corresponding positive-frequency terms, and the negative-frequency terms are therefore redundant. This function does not compute the negative frequency terms, and the length of the transformed axis of the output is therefore &lt;code&gt;n//2 + 1&lt;/code&gt;.</source>
          <target state="translated">当为纯实数输入计算DFT时，输出是Hermitian对称的，即负频率项只是相应正频率项的复共轭，因此负频率项是多余的。此函数不计算负频率项，因此输出的变换轴的长度为 &lt;code&gt;n//2 + 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3d4a45bb9288ccb26e83539df4a7489dddcf142" translate="yes" xml:space="preserve">
          <source>When the data type of &lt;code&gt;a&lt;/code&gt; is longdouble or clongdouble, item() returns a scalar array object because there is no available Python scalar that would not lose information. Void arrays return a buffer object for item(), unless fields are defined, in which case a tuple is returned.</source>
          <target state="translated">当的数据类型 &lt;code&gt;a&lt;/code&gt; 是longdouble或clongdouble，项（）返回一个标阵列对象，因为不存在可用的Python标量不会丢失信息。除非定义了字段，否则无效数组将为item（）返回一个缓冲区对象，在这种情况下，将返回一个元组。</target>
        </trans-unit>
        <trans-unit id="6d7c5ae7d2e5fed7aeaee002bc1ee17b1c24ba0a" translate="yes" xml:space="preserve">
          <source>When the dimension of the vector(s) in &lt;code&gt;a&lt;/code&gt; and/or &lt;code&gt;b&lt;/code&gt; does not equal 2 or 3.</source>
          <target state="translated">当 &lt;code&gt;a&lt;/code&gt; 和/或 &lt;code&gt;b&lt;/code&gt; 中的向量的维数不等于2或3。</target>
        </trans-unit>
        <trans-unit id="dd1fba0c6bb426cf1f952081182426781d82c79b" translate="yes" xml:space="preserve">
          <source>When the error handling for a floating-point error (one of &amp;ldquo;divide&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, or &amp;ldquo;invalid&amp;rdquo;) is set to &amp;lsquo;call&amp;rsquo; or &amp;lsquo;log&amp;rsquo;, the function that is called or the log instance that is written to is returned by &lt;a href=&quot;#numpy.geterrcall&quot;&gt;&lt;code&gt;geterrcall&lt;/code&gt;&lt;/a&gt;. This function or log instance has been set with &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当对浮点错误的错误处理（&amp;ldquo;除&amp;rdquo;，&amp;ldquo;上&amp;rdquo;，&amp;ldquo;下&amp;rdquo;或&amp;ldquo;无效&amp;rdquo;之一）设置为&amp;ldquo;调用&amp;rdquo;或&amp;ldquo;日志&amp;rdquo;时，被调用的函数或日志实例写入的内容由&lt;a href=&quot;#numpy.geterrcall&quot;&gt; &lt;code&gt;geterrcall&lt;/code&gt; &lt;/a&gt;返回。此功能或日志实例已使用&lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt;设置。</target>
        </trans-unit>
        <trans-unit id="3a105e739e37e79639871fe00f74a7608f41e18f" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; is used, the code needs to know the parameters for doing the inner loop. These functions provide that information.</source>
          <target state="translated">当使用标志&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; 时&lt;/a&gt;，代码需要知道进行内部循环的参数。这些功能提供了该信息。</target>
        </trans-unit>
        <trans-unit id="a3b33dbd60831369f7fef62a2b038dc2ad278fa8" translate="yes" xml:space="preserve">
          <source>When the flags attribute is retrieved from Python, a special builtin object of this type is constructed. This special type makes it easier to work with the different flags by accessing them as attributes or by accessing them as if the object were a dictionary with the flag names as entries.</source>
          <target state="translated">当从 Python 中获取 flags 属性时,会构造一个特殊的内置对象。这个特殊的类型使我们可以更容易地使用不同的标志,把它们作为属性来访问,或者像访问一个以标志名作为条目的字典一样访问它们。</target>
        </trans-unit>
        <trans-unit id="6997b127e257f2d9de0f0028a03e8903521c7172" translate="yes" xml:space="preserve">
          <source>When the index consists of as many integer arrays as the array being indexed has dimensions, the indexing is straight forward, but different from slicing.</source>
          <target state="translated">当索引由与被索引数组的维数一样多的整数数组组成时,索引是直接的,但与分片不同。</target>
        </trans-unit>
        <trans-unit id="e3539c51a85d030896869c59fab4a3546a18e92e" translate="yes" xml:space="preserve">
          <source>When the input &lt;code&gt;a&lt;/code&gt; is a time-domain signal and &lt;code&gt;A = fft(a)&lt;/code&gt;, &lt;code&gt;np.abs(A)&lt;/code&gt; is its amplitude spectrum and &lt;code&gt;np.abs(A)**2&lt;/code&gt; is its power spectrum. The phase spectrum is obtained by &lt;code&gt;np.angle(A)&lt;/code&gt;.</source>
          <target state="translated">当输入 &lt;code&gt;a&lt;/code&gt; 是时域信号且 &lt;code&gt;A = fft(a)&lt;/code&gt; ， &lt;code&gt;np.abs(A)&lt;/code&gt; 是其幅度谱， &lt;code&gt;np.abs(A)**2&lt;/code&gt; 是其功率谱。通过 &lt;code&gt;np.angle(A)&lt;/code&gt; 获得相位谱。</target>
        </trans-unit>
        <trans-unit id="1367f160bbb5fedd65e0cbb76f7f60e11a8156e2" translate="yes" xml:space="preserve">
          <source>When the input and output arrays are aligned and of the correct type, but the striding is not uniform (non-contiguous and 2-D or larger), then a second looping structure is employed for the calculation. This approach converts all of the iterators for the input and output arguments to iterate over all but the largest dimension. The inner loop is then handled by the underlying 1-D computational loop. The outer loop is a standard iterator loop on the converted iterators. The hardware error flags are checked after each 1-D loop is completed.</source>
          <target state="translated">当输入和输出数组是对齐的,并且类型正确,但跨度不一致(非连续和2-D或更大)时,则采用第二个循环结构进行计算。这种方法将输入和输出参数的所有迭代器转换为除最大维度外的所有迭代器。内循环则由底层的1-D计算循环来处理。外循环是对转换后的迭代器进行标准迭代循环。在每个1-D循环完成后,都会检查硬件错误标志。</target>
        </trans-unit>
        <trans-unit id="34e3c1c18b6a533eb7d5554f7595a67b84951780" translate="yes" xml:space="preserve">
          <source>When the input is purely real, its transform is Hermitian, i.e., the component at frequency</source>
          <target state="translated">当输入为纯实数时,它的变换是赫米特式的,即频率上的分量为</target>
        </trans-unit>
        <trans-unit id="52b34b95d5e176ad47f62260446b195804a6cada" translate="yes" xml:space="preserve">
          <source>When the length of 1D &lt;code&gt;weights&lt;/code&gt; is not the same as the shape of &lt;code&gt;a&lt;/code&gt; along axis.</source>
          <target state="translated">当1D的长度 &lt;code&gt;weights&lt;/code&gt; 是不一样的形状 &lt;code&gt;a&lt;/code&gt; 沿轴线。</target>
        </trans-unit>
        <trans-unit id="af1eaf8889fe184a62b6fd5a964889299281ae31" translate="yes" xml:space="preserve">
          <source>When the nested list is two levels deep, this allows block matrices to be constructed from their components.</source>
          <target state="translated">当嵌套列表的深度为两层时,可以从它们的组件中构造块矩阵。</target>
        </trans-unit>
        <trans-unit id="e5f5bbbcfb6705ce5d9a02195d69308545da2c5f" translate="yes" xml:space="preserve">
          <source>When the optional keys &lt;em&gt;offsets&lt;/em&gt; and &lt;em&gt;titles&lt;/em&gt; are provided, their values must each be lists of the same length as the &lt;em&gt;names&lt;/em&gt; and &lt;em&gt;formats&lt;/em&gt; lists. The &lt;em&gt;offsets&lt;/em&gt; value is a list of byte offsets (limited to &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt;&lt;code&gt;ctypes.c_int&lt;/code&gt;&lt;/a&gt;) for each field, while the &lt;em&gt;titles&lt;/em&gt; value is a list of titles for each field (&lt;code&gt;None&lt;/code&gt; can be used if no title is desired for that field). The &lt;em&gt;titles&lt;/em&gt; can be any &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;unicode&lt;/code&gt; object and will add another entry to the fields dictionary keyed by the title and referencing the same field tuple which will contain the title as an additional tuple member.</source>
          <target state="translated">提供可选键&lt;em&gt;偏移量&lt;/em&gt;和&lt;em&gt;标题时&lt;/em&gt;，它们的值都必须是与&lt;em&gt;名称&lt;/em&gt;和&lt;em&gt;格式&lt;/em&gt;列表长度相同的列表。该&lt;em&gt;偏移&lt;/em&gt;值是字节偏移（限于列表&lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt; &lt;code&gt;ctypes.c_int&lt;/code&gt; &lt;/a&gt;）对于每个字段，而&lt;em&gt;标题&lt;/em&gt;值是标题的每个字段的列表（ &lt;code&gt;None&lt;/code&gt; 可以如果没有标题期望该字段中使用）。的&lt;em&gt;标题&lt;/em&gt;可以是任何 &lt;code&gt;string&lt;/code&gt; 或 &lt;code&gt;unicode&lt;/code&gt; 的对象，并且将添加另一条目的字段字典由标题键和引用相同的字段的元组，其将包含标题作为附加元组构件。</target>
        </trans-unit>
        <trans-unit id="0c89441828aa0daf46fb0989feeaa96e8f46c4c3" translate="yes" xml:space="preserve">
          <source>When the result of an advanced indexing operation has no elements but an individual index is out of bounds, whether or not an &lt;code&gt;IndexError&lt;/code&gt; is raised is undefined (e.g. &lt;code&gt;x[[], [123]]&lt;/code&gt; with &lt;code&gt;123&lt;/code&gt; being out of bounds).</source>
          <target state="translated">如果高级索引操作的结果没有元素，但单个索引超出范围，则不确定是否引发 &lt;code&gt;IndexError&lt;/code&gt; （例如 &lt;code&gt;x[[], [123]]&lt;/code&gt; 其中 &lt;code&gt;123&lt;/code&gt; 超出范围）。</target>
        </trans-unit>
        <trans-unit id="cb9d5c54f477f497096e6733fd299984beb835c4" translate="yes" xml:space="preserve">
          <source>When the variables are named (either by a flexible dtype or with &lt;code&gt;names&lt;/code&gt;, there must not be any header in the file (else a ValueError exception is raised).</source>
          <target state="translated">命名变量时（通过灵活的dtype或使用 &lt;code&gt;names&lt;/code&gt; 命名)，文件中不得包含任何标头（否则将引发ValueError异常）。</target>
        </trans-unit>
        <trans-unit id="1ce6824829e37ca585156c8e8abdeb7e7047b4a6" translate="yes" xml:space="preserve">
          <source>When there is at least one slice (&lt;code&gt;:&lt;/code&gt;), ellipsis (&lt;code&gt;...&lt;/code&gt;) or &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; in the index (or the array has more dimensions than there are advanced indexes), then the behaviour can be more complicated. It is like concatenating the indexing result for each advanced index element</source>
          <target state="translated">当存在至少一个片（ &lt;code&gt;:&lt;/code&gt; ），省略号（ &lt;code&gt;...&lt;/code&gt; ）或&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;在索引（或阵列具有多个尺寸比有先进的索引），则行为可以更复杂。就像将每个高级索引元素的索引结果连接起来一样</target>
        </trans-unit>
        <trans-unit id="7fc05435c156ef19015ca040276948a66576f250" translate="yes" xml:space="preserve">
          <source>When there is more than one axis to sum over - and they are not the last (first) axes of &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) - the argument &lt;code&gt;axes&lt;/code&gt; should consist of two sequences of the same length, with the first axis to sum over given first in both sequences, the second axis second, and so forth.</source>
          <target state="translated">如果有多个轴求和-并且它们不是 &lt;code&gt;a&lt;/code&gt; （ &lt;code&gt;b&lt;/code&gt; ）的最后（第一个）轴，则参数 &lt;code&gt;axes&lt;/code&gt; 应由两个长度相同的序列组成，第一个轴求和于给定的第一个轴两个序列，第二个轴第二个，依此类推。</target>
        </trans-unit>
        <trans-unit id="aca72761c1059e14a576d5243f55b005214eb5e7" translate="yes" xml:space="preserve">
          <source>When there is only one operand, no axes are summed, and no output parameter is provided, a view into the operand is returned instead of a new array. Thus, taking the diagonal as &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; produces a view (changed in version 1.10.0).</source>
          <target state="translated">当只有一个操作数时，没有轴求和，也没有提供输出参数，则返回对该操作数的视图，而不是新的数组。因此，将对角线作为 &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; 会生成一个视图（在版本1.10.0中进行了更改）。</target>
        </trans-unit>
        <trans-unit id="d6560fa9a8a1164ba82db1ff6a46fb84089bde5d" translate="yes" xml:space="preserve">
          <source>When true, the resulting &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; can contain Unicode characters, when false only 8-bit characters. If unicode is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;obj&lt;/code&gt; is one of the following:</source>
          <target state="translated">如果为true，则结果字符&lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;可以包含Unicode字符；如果为false，则仅8位字符。如果unicode为 &lt;code&gt;None&lt;/code&gt; 且 &lt;code&gt;obj&lt;/code&gt; 为以下之一：</target>
        </trans-unit>
        <trans-unit id="a283e044d3ebfd4430bd993011e5610365921585" translate="yes" xml:space="preserve">
          <source>When true, the resulting &lt;code&gt;chararray&lt;/code&gt; can contain Unicode characters, when false only 8-bit characters. If unicode is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;obj&lt;/code&gt; is one of the following:</source>
          <target state="translated">如果为true，则结果字符 &lt;code&gt;chararray&lt;/code&gt; 可以包含Unicode字符；如果为false，则仅8位字符。如果unicode为 &lt;code&gt;None&lt;/code&gt; 且 &lt;code&gt;obj&lt;/code&gt; 为以下之一：</target>
        </trans-unit>
        <trans-unit id="436bc3d73aa6565d86aefabb54c9292e559b97a5" translate="yes" xml:space="preserve">
          <source>When used interactively with an object, &lt;code&gt;np.info(obj)&lt;/code&gt; is equivalent to &lt;code&gt;help(obj)&lt;/code&gt; on the Python prompt or &lt;code&gt;obj?&lt;/code&gt; on the IPython prompt.</source>
          <target state="translated">与对象交互使用时， &lt;code&gt;np.info(obj)&lt;/code&gt; 等同于Python提示符或 &lt;code&gt;obj?&lt;/code&gt; 上的 &lt;code&gt;help(obj)&lt;/code&gt; 。在IPython提示符下。</target>
        </trans-unit>
        <trans-unit id="a8bcdc54785df618c23c01dc97dc1468fe9c49c4" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;jumped&lt;/code&gt;, one does have to take care not to jump to a stream that was already used. In the above example, one could not later use &lt;code&gt;blocked_rng[0].jumped()&lt;/code&gt; as it would overlap with &lt;code&gt;blocked_rng[1]&lt;/code&gt;. Like with the independent streams, if the main process here wants to split off 10 more streams by jumping, then it needs to start with &lt;code&gt;range(10, 20)&lt;/code&gt;, otherwise it would recreate the same streams. On the other hand, if you carefully construct the streams, then you are guaranteed to have streams that do not overlap.</source>
          <target state="translated">使用 &lt;code&gt;jumped&lt;/code&gt; 时，必须注意不要跳转到已使用的流。在上面的示例中，以后将无法使用 &lt;code&gt;blocked_rng[0].jumped()&lt;/code&gt; 因为它将与 &lt;code&gt;blocked_rng[1]&lt;/code&gt; 重叠。像独立流一样，如果此处的主进程希望通过跳转将更多的流分成10个，则它需要从 &lt;code&gt;range(10, 20)&lt;/code&gt; ，否则它将重新创建相同的流。另一方面，如果您精心构造流，那么可以保证流不会重叠。</target>
        </trans-unit>
        <trans-unit id="724bc629cdbfec6a4e5af9a220d38930424c297d" translate="yes" xml:space="preserve">
          <source>When using a non-integer step, such as 0.1, the results will often not be consistent. It is better to use &lt;a href=&quot;numpy.linspace#numpy.linspace&quot;&gt;&lt;code&gt;numpy.linspace&lt;/code&gt;&lt;/a&gt; for these cases.</source>
          <target state="translated">当使用非整数步骤（例如0.1）时，结果通常将不一致。对于这些情况，最好使用&lt;a href=&quot;numpy.linspace#numpy.linspace&quot;&gt; &lt;code&gt;numpy.linspace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27718ed960a95a721b47ff1931021ed4073bbe48" translate="yes" xml:space="preserve">
          <source>When using a string for &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; it is possible to get multiple results.</source>
          <target state="translated">当使用字符串作为&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt;时，可以获得多个结果。</target>
        </trans-unit>
        <trans-unit id="4483d4c2e345ca8073aa1a9817270cc3cdb40e82" translate="yes" xml:space="preserve">
          <source>When using a subclass (especially one which manipulates its shape), the default &lt;code&gt;ndarray.__setitem__&lt;/code&gt; behaviour will call &lt;code&gt;__getitem__&lt;/code&gt; for &lt;em&gt;basic&lt;/em&gt; indexing but not for &lt;em&gt;advanced&lt;/em&gt; indexing. For such a subclass it may be preferable to call &lt;code&gt;ndarray.__setitem__&lt;/code&gt; with a &lt;em&gt;base class&lt;/em&gt; ndarray view on the data. This &lt;em&gt;must&lt;/em&gt; be done if the subclasses &lt;code&gt;__getitem__&lt;/code&gt; does not return views.</source>
          <target state="translated">当使用一个子类（尤其是其操纵它的形状），默认 &lt;code&gt;ndarray.__setitem__&lt;/code&gt; 行为将调用 &lt;code&gt;__getitem__&lt;/code&gt; 为&lt;em&gt;基础&lt;/em&gt;的索引，但不是&lt;em&gt;先进的&lt;/em&gt;索引。对于此类子类，可能最好在数据上使用&lt;em&gt;基类&lt;/em&gt; ndarray视图调用 &lt;code&gt;ndarray.__setitem__&lt;/code&gt; 。这&lt;em&gt;必须&lt;/em&gt;如果子类来实现 &lt;code&gt;__getitem__&lt;/code&gt; 不返回意见。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc311b69f41b3e0c41508f3b081d2280ad7970ec" translate="yes" xml:space="preserve">
          <source>When using broadcasting with uint64 dtypes, the maximum value (2**64) cannot be represented as a standard integer type. The high array (or low if high is None) must have object dtype, e.g., array([2**64]).</source>
          <target state="translated">当使用带有uint64 dtypes的广播时,最大值(2**64)不能用标准整数类型表示。高数组(如果高数组为None,则低数组)必须有对象dtype,如array([2**64])。</target>
        </trans-unit>
        <trans-unit id="c04978427f46ec116ad24550bbf1c67bfbb16f61" translate="yes" xml:space="preserve">
          <source>When using signed integer types the result is the two&amp;rsquo;s complement of the result for the unsigned type:</source>
          <target state="translated">当使用有符号整数类型时，结果是无符号类型结果的二进制补码：</target>
        </trans-unit>
        <trans-unit id="fefd781e401a9acf4994aa658770a54631a31aac" translate="yes" xml:space="preserve">
          <source>When using the iterator in multi-threaded code or in code not holding the Python GIL, care must be taken to only call functions which are safe in that context. &lt;a href=&quot;#c.NpyIter_Copy&quot;&gt;&lt;code&gt;NpyIter_Copy&lt;/code&gt;&lt;/a&gt; cannot be safely called without the Python GIL, because it increments Python references. The &lt;code&gt;Reset*&lt;/code&gt; and some other functions may be safely called by passing in the &lt;code&gt;errmsg&lt;/code&gt; parameter as non-NULL, so that the functions will pass back errors through it instead of setting a Python exception.</source>
          <target state="translated">在多线程代码或不包含Python GIL的代码中使用迭代器时，必须注意仅调用在该上下文中安全的函数。没有Python GIL不能安全地调用&lt;a href=&quot;#c.NpyIter_Copy&quot;&gt; &lt;code&gt;NpyIter_Copy&lt;/code&gt; &lt;/a&gt;，因为它会增加Python引用。该 &lt;code&gt;Reset*&lt;/code&gt; 和其他一些功能可以通过传递安全地调用 &lt;code&gt;errmsg&lt;/code&gt; 参数非NULL，这样的功能将通过它传回错误，而不是设置一个Python异常。</target>
        </trans-unit>
        <trans-unit id="e0e93c50be29a8db34812f3b063181378aab17d0" translate="yes" xml:space="preserve">
          <source>When working along a given axis, a slice along that axis is returned in &lt;code&gt;output&lt;/code&gt; for each index where &lt;code&gt;condition&lt;/code&gt; evaluates to True. When working on a 1-D array, &lt;a href=&quot;#numpy.compress&quot;&gt;&lt;code&gt;compress&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;a href=&quot;numpy.extract#numpy.extract&quot;&gt;&lt;code&gt;extract&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">沿给定轴工作时，沿着该轴的切片返回在 &lt;code&gt;output&lt;/code&gt; 为每个索引，其中 &lt;code&gt;condition&lt;/code&gt; 评估为真。处理一维数组时，&lt;a href=&quot;#numpy.compress&quot;&gt; &lt;code&gt;compress&lt;/code&gt; &lt;/a&gt;等效于&lt;a href=&quot;numpy.extract#numpy.extract&quot;&gt; &lt;code&gt;extract&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d7c565731670a0f048fc0a67ffb9fb36e062b00" translate="yes" xml:space="preserve">
          <source>When working with more complex dtypes which are composed of other dtypes, such as the struct dtype, creating inner loops that manipulate the dtypes requires carrying along additional data. NumPy supports this idea through a struct &lt;a href=&quot;#c.NpyAuxData&quot;&gt;&lt;code&gt;NpyAuxData&lt;/code&gt;&lt;/a&gt;, mandating a few conventions so that it is possible to do this.</source>
          <target state="translated">当使用由其他dtype（例如struct dtype）组成的更复杂的dtype时，创建操纵dtype的内部循环需要携带附加数据。 NumPy通过结构&lt;a href=&quot;#c.NpyAuxData&quot;&gt; &lt;code&gt;NpyAuxData&lt;/code&gt; &lt;/a&gt;支持该想法，规定了一些约定，以便可以执行此操作。</target>
        </trans-unit>
        <trans-unit id="aaa9ed3a1aa18ac3b534d99cdc2037422344dc84" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;%apply&lt;/code&gt; directive, as is usually necessary to use &lt;code&gt;numpy.i&lt;/code&gt;, it will remain in effect until you tell &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; that it shouldn&amp;rsquo;t be. If the arguments to the functions or methods that you are wrapping have common names, such as &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;vector&lt;/code&gt;, these typemaps may get applied in situations you do not expect or want. Therefore, it is always a good idea to add a &lt;code&gt;%clear&lt;/code&gt; directive after you are done with a specific typemap:</source>
          <target state="translated">当您使用 &lt;code&gt;%apply&lt;/code&gt; 指令（通常使用 &lt;code&gt;numpy.i&lt;/code&gt; 必需)时，该指令将一直有效，直到您告诉&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;不应这样做为止。如果要包装的函数或方法的参数具有通用名称，例如 &lt;code&gt;length&lt;/code&gt; 或 &lt;code&gt;vector&lt;/code&gt; ，则这些类型映射可能会在您不希望或不希望使用的情况下应用。因此，在完成特定的类型映射后，最好添加 &lt;code&gt;%clear&lt;/code&gt; 指令：</target>
        </trans-unit>
        <trans-unit id="89f82c7a5bbe0891c1df2aa46cbdf990d1794aa1" translate="yes" xml:space="preserve">
          <source>Whenever &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; != PyArray_GetNDArrayCVersion, the extension has to be recompiled (ABI incompatibility).</source>
          <target state="translated">每当&lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt;！= PyArray_GetNDArrayCVersion时，都必须重新编译扩展名（ABI不兼容）。</target>
        </trans-unit>
        <trans-unit id="3e2b99bc93c54f0bc24f4acf841fece1023b07a0" translate="yes" xml:space="preserve">
          <source>Whenever &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is #defined, it also changes the name of the variable holding the C-API, which defaults to &lt;code&gt;PyArray_API&lt;/code&gt;, to whatever the macro is #defined to.</source>
          <target state="translated">每当&lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt;被定义时，它也会将保存C-API的变量名（默认为 &lt;code&gt;PyArray_API&lt;/code&gt; ）更改为#defined定义的宏。</target>
        </trans-unit>
        <trans-unit id="934b37ef17a0c4c0c83c595fef5a62578238ee15" translate="yes" xml:space="preserve">
          <source>Whenever a data-type is required in a NumPy function or method, either a &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; object or something that can be converted to one can be supplied. Such conversions are done by the &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; constructor:</source>
          <target state="translated">每当NumPy函数或方法中需要数据类型时，都可以提供&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;对象或可以转换为一个的对象。此类转换由&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;构造函数完成：</target>
        </trans-unit>
        <trans-unit id="80254bc9efba4102e15f18db7d8295d8697a0360" translate="yes" xml:space="preserve">
          <source>Whenever a writeable operand has fewer elements than the full iteration space, that operand is undergoing a reduction. The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object requires that any reduction operand be flagged as read-write, and only allows reductions when &amp;lsquo;reduce_ok&amp;rsquo; is provided as an iterator flag.</source>
          <target state="translated">只要可写操作数的元素数少于完整的迭代空间，该操作数就会减少。所述&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;对象要求的任何减少操作数仅标记为可读写的，并且允许减少当&amp;ldquo;reduce_ok&amp;rdquo;作为一个迭代标志被提供。</target>
        </trans-unit>
        <trans-unit id="090346f0957607fc5beeda4f38e177d1918c4444" translate="yes" xml:space="preserve">
          <source>Where True, yield &lt;code&gt;x&lt;/code&gt;, otherwise yield &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">如果为True，则产生 &lt;code&gt;x&lt;/code&gt; ，否则产生 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b58703967453c474e94cf57585adb3b2a50448ed" translate="yes" xml:space="preserve">
          <source>Where the library can be found.</source>
          <target state="translated">在哪里可以找到图书馆。</target>
        </trans-unit>
        <trans-unit id="54df46f7307aa74c464486f1ea35cde9a77febe6" translate="yes" xml:space="preserve">
          <source>Where to install the npy-pkg config file, relatively to the current package path.</source>
          <target state="translated">安装npy-pkg配置文件的位置,相对于当前软件包的路径。</target>
        </trans-unit>
        <trans-unit id="93d30f1df70c77ec829a136f4d8b2ef0c3b96d94" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;arg1&lt;/code&gt; is a subclass of &lt;code&gt;arg2&lt;/code&gt; or not.</source>
          <target state="translated">无论 &lt;code&gt;arg1&lt;/code&gt; 是的子类 &lt;code&gt;arg2&lt;/code&gt; 与否。</target>
        </trans-unit>
        <trans-unit id="7ded38313492e3b9340e10eb5e7bd8c5c0bea96c" translate="yes" xml:space="preserve">
          <source>Whether iteration requires access to the Python API, for example if one of the operands is an object array.</source>
          <target state="translated">迭代是否需要访问Python API,例如如果操作数之一是一个对象数组。</target>
        </trans-unit>
        <trans-unit id="08ba3ba6d86470ddcf5c7c987a831ffff108d8b4" translate="yes" xml:space="preserve">
          <source>Whether masked data are propagated (True) or set to 0 (False) for the computation. Default is False. Propagating the mask means that if a masked value appears in a row or column, the whole row or column is considered masked.</source>
          <target state="translated">掩码数据是否被传播(True)或设置为0(False)进行计算。默认为False。传播掩码意味着如果掩码值出现在某行或某列中,则整行或整列都被视为掩码。</target>
        </trans-unit>
        <trans-unit id="8637ce438fa1d406f7ec1653600c39aad46d9db8" translate="yes" xml:space="preserve">
          <source>Whether masked values in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equal (True) or not (False). They are considered equal by default.</source>
          <target state="translated">是否将 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 中的掩码值视为相等（真）或不相等（假）。默认情况下，它们被视为相等。</target>
        </trans-unit>
        <trans-unit id="6867499c63cb6abaeab85ff30463c9432618d2ee" translate="yes" xml:space="preserve">
          <source>Whether masked values in a or b are considered equal (True) or not (False).</source>
          <target state="translated">a或b中的掩码值是否被视为相等(True)或不相等(False)。</target>
        </trans-unit>
        <trans-unit id="288daa4940dd3020af5ede621755e8ef6fcd2c3a" translate="yes" xml:space="preserve">
          <source>Whether missing values (if any) should be treated as the largest values (True) or the smallest values (False) When the array contains unmasked values at the same extremes of the datatype, the ordering of these values and the masked values is undefined.</source>
          <target state="translated">当数组在数据类型的同一极端包含未屏蔽的值时,这些值和被屏蔽的值的顺序是未定义的。</target>
        </trans-unit>
        <trans-unit id="7da3b2e79fc5148bb637715841cccf76fc788e07" translate="yes" xml:space="preserve">
          <source>Whether missing values (if any) should be treated as the largest values (True) or the smallest values (False) When the array contains unmasked values sorting at the same extremes of the datatype, the ordering of these values and the masked values is undefined.</source>
          <target state="translated">缺失的值(如果有的话)是否应该作为最大的值(True)或最小的值(False)来处理。 当数组包含未屏蔽的值,在数据类型的同一极端进行排序时,这些值和屏蔽的值的排序是未定义的。</target>
        </trans-unit>
        <trans-unit id="ec0eb17948661387af03eedbd16c0982b256d2ca" translate="yes" xml:space="preserve">
          <source>Whether or not there are iterations left.</source>
          <target state="translated">是否还有迭代。</target>
        </trans-unit>
        <trans-unit id="6c6ce4cbc91d3e04017743bd327936e59b4be559" translate="yes" xml:space="preserve">
          <source>Whether or not to compute &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;vh&lt;/code&gt; in addition to &lt;code&gt;s&lt;/code&gt;. True by default.</source>
          <target state="translated">除 &lt;code&gt;s&lt;/code&gt; 外是否计算 &lt;code&gt;u&lt;/code&gt; 和 &lt;code&gt;vh&lt;/code&gt; 。默认为True。</target>
        </trans-unit>
        <trans-unit id="34608785e0c8e6698e050294c20a41fc581a7a43" translate="yes" xml:space="preserve">
          <source>Whether the array data is Fortran-contiguous or not. Since Fortran-contiguous arrays are a common form of non-C-contiguity, we allow them to be written directly to disk for efficiency.</source>
          <target state="translated">数组数据是否为Fortran-contiguous。由于Fortran-contiguous数组是一种常见的非C-contiguity形式,为了提高效率,我们允许其直接写入磁盘。</target>
        </trans-unit>
        <trans-unit id="a7b87db28e0b29fd77663f2df3cc4a859b46d1b1" translate="yes" xml:space="preserve">
          <source>Whether the array is to interpreted as C-order or Fortran-order.</source>
          <target state="translated">数组的解释是C-order还是Fortran-order。</target>
        </trans-unit>
        <trans-unit id="944c20a06f71d4591f2972a6198b951c5988e169" translate="yes" xml:space="preserve">
          <source>Whether the buffer is read-only</source>
          <target state="translated">缓冲区是否为只读</target>
        </trans-unit>
        <trans-unit id="4f5043b4a62f84c7d0a89c1a7427fe7e0a42c45d" translate="yes" xml:space="preserve">
          <source>Whether the iteration over the operands is finished or not.</source>
          <target state="translated">操作数的迭代是否结束。</target>
        </trans-unit>
        <trans-unit id="13a09493df9f77aae557913a37ecafb9bbcd240e" translate="yes" xml:space="preserve">
          <source>Whether the mask is shared between masked arrays can be seen from the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.sharedmask&quot;&gt;&lt;code&gt;sharedmask&lt;/code&gt;&lt;/a&gt; property. &lt;a href=&quot;#numpy.ma.MaskedArray.unshare_mask&quot;&gt;&lt;code&gt;unshare_mask&lt;/code&gt;&lt;/a&gt; ensures the mask is not shared. A copy of the mask is only made if it was shared.</source>
          <target state="translated">从&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.sharedmask&quot;&gt; &lt;code&gt;sharedmask&lt;/code&gt; &lt;/a&gt;属性可以看到掩码是否在掩码数组之间共享。&lt;a href=&quot;#numpy.ma.MaskedArray.unshare_mask&quot;&gt; &lt;code&gt;unshare_mask&lt;/code&gt; &lt;/a&gt;确保不共享掩码。仅当共享蒙版时才复制它。</target>
        </trans-unit>
        <trans-unit id="db7611d744e4dcdca549d1fbd74911098f577c62" translate="yes" xml:space="preserve">
          <source>Whether the mask of a masked array is hard or soft is determined by its &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt;&lt;code&gt;hardmask&lt;/code&gt;&lt;/a&gt; property. &lt;a href=&quot;numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt;&lt;code&gt;harden_mask&lt;/code&gt;&lt;/a&gt; sets &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt;&lt;code&gt;hardmask&lt;/code&gt;&lt;/a&gt; to True.</source>
          <target state="translated">被遮罩阵列的遮罩是硬还是软取决于其&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt; &lt;code&gt;hardmask&lt;/code&gt; &lt;/a&gt;遮罩属性。&lt;a href=&quot;numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt; &lt;code&gt;harden_mask&lt;/code&gt; &lt;/a&gt;将&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt; &lt;code&gt;hardmask&lt;/code&gt; &lt;/a&gt;掩码设置为True。</target>
        </trans-unit>
        <trans-unit id="b8f17f77435a0793df30f7927fd68842a3c16557" translate="yes" xml:space="preserve">
          <source>Whether the mask of a masked array is hard or soft is determined by its &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt;&lt;code&gt;hardmask&lt;/code&gt;&lt;/a&gt; property. &lt;a href=&quot;numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt;&lt;code&gt;soften_mask&lt;/code&gt;&lt;/a&gt; sets &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt;&lt;code&gt;hardmask&lt;/code&gt;&lt;/a&gt; to False.</source>
          <target state="translated">被遮罩阵列的遮罩是硬还是软取决于其&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt; &lt;code&gt;hardmask&lt;/code&gt; &lt;/a&gt;遮罩属性。&lt;a href=&quot;numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt; &lt;code&gt;soften_mask&lt;/code&gt; &lt;/a&gt;将&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt; &lt;code&gt;hardmask&lt;/code&gt; &lt;/a&gt;掩码设置为False。</target>
        </trans-unit>
        <trans-unit id="7f3e122a9b529992b197b46b09923f9ca3bd360b" translate="yes" xml:space="preserve">
          <source>Whether the mask of a masked array is hard or soft is determined by its &lt;code&gt;hardmask&lt;/code&gt; property. &lt;a href=&quot;#numpy.ma.harden_mask&quot;&gt;&lt;code&gt;harden_mask&lt;/code&gt;&lt;/a&gt; sets &lt;code&gt;hardmask&lt;/code&gt; to True.</source>
          <target state="translated">被遮罩阵列的遮罩是硬还是软取决于其 &lt;code&gt;hardmask&lt;/code&gt; 遮罩属性。&lt;a href=&quot;#numpy.ma.harden_mask&quot;&gt; &lt;code&gt;harden_mask&lt;/code&gt; &lt;/a&gt;将 &lt;code&gt;hardmask&lt;/code&gt; 掩码设置为True。</target>
        </trans-unit>
        <trans-unit id="01426ffe48ebece03a2678d8f2d6adc220725bf0" translate="yes" xml:space="preserve">
          <source>Whether the mask of a masked array is hard or soft is determined by its &lt;code&gt;hardmask&lt;/code&gt; property. &lt;a href=&quot;#numpy.ma.soften_mask&quot;&gt;&lt;code&gt;soften_mask&lt;/code&gt;&lt;/a&gt; sets &lt;code&gt;hardmask&lt;/code&gt; to False.</source>
          <target state="translated">被遮罩阵列的遮罩是硬还是软取决于其 &lt;code&gt;hardmask&lt;/code&gt; 遮罩属性。&lt;a href=&quot;#numpy.ma.soften_mask&quot;&gt; &lt;code&gt;soften_mask&lt;/code&gt; &lt;/a&gt;将 &lt;code&gt;hardmask&lt;/code&gt; 掩码设置为False。</target>
        </trans-unit>
        <trans-unit id="ee9da79319e6c0e3169d3748cede2f00813142ab" translate="yes" xml:space="preserve">
          <source>Whether the output should be stored in row-major (C-style) or column-major (Fortran-style) order in memory.</source>
          <target state="translated">在内存中是按行大写(C-style)还是列大写(Fortran-style)的顺序存储输出。</target>
        </trans-unit>
        <trans-unit id="92d233bcb4830096541e589ec9f4a1ebacbac55b" translate="yes" xml:space="preserve">
          <source>Whether the sample is shuffled when sampling without replacement. Default is True, False provides a speedup.</source>
          <target state="translated">取样时,是否对样本进行洗牌,而不进行替换。默认为True,False提供了一个加速。</target>
        </trans-unit>
        <trans-unit id="da175c30578215af592bdb3c0536af196e7c720a" translate="yes" xml:space="preserve">
          <source>Whether the sample is with or without replacement</source>
          <target state="translated">无论样品有无更换</target>
        </trans-unit>
        <trans-unit id="f7a933f70353e3ad1ecdef0da587770caa9c5376" translate="yes" xml:space="preserve">
          <source>Whether to automatically strip white spaces from the variables.</source>
          <target state="translated">是否从变量中自动去掉空白。</target>
        </trans-unit>
        <trans-unit id="442a6c8414200886a8391269e4fbd9de7abf0966" translate="yes" xml:space="preserve">
          <source>Whether to collapse a mask full of False to &lt;code&gt;nomask&lt;/code&gt;.</source>
          <target state="translated">是否将充满False的蒙版折叠为 &lt;code&gt;nomask&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4050a74967f8f69856c2fbd0e3e619300a40e0f0" translate="yes" xml:space="preserve">
          <source>Whether to collapse a mask full of False to nomask</source>
          <target state="translated">是否要把满是False的面具折叠到nomask上?</target>
        </trans-unit>
        <trans-unit id="c052f30967f49a9b943b88084eb17b8a3c940aea" translate="yes" xml:space="preserve">
          <source>Whether to combine &lt;code&gt;mask&lt;/code&gt; with the mask of the input data, if any (True), or to use only &lt;code&gt;mask&lt;/code&gt; for the output (False). Default is True.</source>
          <target state="translated">是否将 &lt;code&gt;mask&lt;/code&gt; 与输入数据的掩码（如果有的话）组合（真），或仅将 &lt;code&gt;mask&lt;/code&gt; 用于输出（假）。默认值为True。</target>
        </trans-unit>
        <trans-unit id="eddff56e50fafc8cb9b530fe24b021eae68e3c92" translate="yes" xml:space="preserve">
          <source>Whether to compare NaN&amp;rsquo;s as equal. If True, NaN&amp;rsquo;s in &lt;code&gt;a&lt;/code&gt; will be considered equal to NaN&amp;rsquo;s in &lt;code&gt;b&lt;/code&gt; in the output array.</source>
          <target state="translated">是否将NaN比较相等。如果为True，NaN的在 &lt;code&gt;a&lt;/code&gt; 将被视为在等于NaN的 &lt;code&gt;b&lt;/code&gt; 输出数组英寸</target>
        </trans-unit>
        <trans-unit id="10fe679c9d66f1cf6761f7d27d834a6040161f28" translate="yes" xml:space="preserve">
          <source>Whether to copy the input data (True), or to use a reference instead. Default is False.</source>
          <target state="translated">是复制输入数据(True),还是使用引用。默认为False。</target>
        </trans-unit>
        <trans-unit id="5fe509663979cfcace796559b2e65ed21543a41a" translate="yes" xml:space="preserve">
          <source>Whether to create a copy of &lt;code&gt;x&lt;/code&gt; (True) or to replace values in-place (False). The in-place operation only occurs if casting to an array does not require a copy. Default is True.</source>
          <target state="translated">是创建 &lt;code&gt;x&lt;/code&gt; 的副本（True）还是就地替换值（False）。仅当强制转换为数组不需要副本时才执行就地操作。默认值为True。</target>
        </trans-unit>
        <trans-unit id="cb3a38e23cd94158d3fb92938c528fabce71a1cc" translate="yes" xml:space="preserve">
          <source>Whether to force compression of an empty mask. Default is True.</source>
          <target state="translated">是否强制压缩空掩模。默认为True。</target>
        </trans-unit>
        <trans-unit id="954b794bdd577e9151cce4c13b30b4547a80cce1" translate="yes" xml:space="preserve">
          <source>Whether to force the output to be a &lt;code&gt;pure&lt;/code&gt; ndarray (False) or to return a subclass of ndarray if appropriate (True, default).</source>
          <target state="translated">是否将输出强制为 &lt;code&gt;pure&lt;/code&gt; ndarray（False）还是在适当时返回ndarray的子​​类（True，默认）。</target>
        </trans-unit>
        <trans-unit id="e3b6a28cf1ae69fa2745e3bf0096fffb2681b0f4" translate="yes" xml:space="preserve">
          <source>Whether to import sub-modules in packages. Default is True.</source>
          <target state="translated">是否导入包中的子模块。默认为True。</target>
        </trans-unit>
        <trans-unit id="560758d583a48f61c5f8c924a74ada989d313f2e" translate="yes" xml:space="preserve">
          <source>Whether to raise an AssertionError when a doctest fails. Default is True.</source>
          <target state="translated">是否在doctest失败时引发断言错误。默认为True。</target>
        </trans-unit>
        <trans-unit id="9da66ee12a4e35260c8d865d944cf7e0c6ffd0fb" translate="yes" xml:space="preserve">
          <source>Whether to re-generate the docstring cache. Default is False.</source>
          <target state="translated">是否重新生成docstring缓存。默认为False。</target>
        </trans-unit>
        <trans-unit id="fe2c4419241a17141e2305c4b8dcba97409a61c9" translate="yes" xml:space="preserve">
          <source>Whether to return a copy of &lt;code&gt;m&lt;/code&gt; (True) or &lt;code&gt;m&lt;/code&gt; itself (False).</source>
          <target state="translated">是返回 &lt;code&gt;m&lt;/code&gt; （True）还是 &lt;code&gt;m&lt;/code&gt; 本身（False）的副本。</target>
        </trans-unit>
        <trans-unit id="d8e552974363003f8c300f894365cd71e993d9cb" translate="yes" xml:space="preserve">
          <source>Whether to return a copy of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">是否返回 &lt;code&gt;x&lt;/code&gt; 的副本。</target>
        </trans-unit>
        <trans-unit id="037c91325bbf0eb3057c152573c6cd848efe298f" translate="yes" xml:space="preserve">
          <source>Whether to return a subclass of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; if possible (True) or a plain &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;. Default is True.</source>
          <target state="translated">是否尽可能返回&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;的子类（True）还是简单的&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;。默认值为True。</target>
        </trans-unit>
        <trans-unit id="0ae760f9c4f41fa0fbb26a77403a1c22ab55b573" translate="yes" xml:space="preserve">
          <source>Whether to show the sign for positive values.</source>
          <target state="translated">是否显示正值的符号。</target>
        </trans-unit>
        <trans-unit id="1b8be26bfc8b0e89327240212310466b2cf75c4c" translate="yes" xml:space="preserve">
          <source>Whether to shrink &lt;code&gt;m&lt;/code&gt; to &lt;code&gt;nomask&lt;/code&gt; if all its values are False.</source>
          <target state="translated">如果其所有值均为False，是否将 &lt;code&gt;m&lt;/code&gt; 缩小为 &lt;code&gt;nomask&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3178cfeee0adef6924aedc74760260f82717be37" translate="yes" xml:space="preserve">
          <source>Whether to shrink the output to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; if all its values are False. Defaults to True.</source>
          <target state="translated">如果其所有值均为False，是否将输出缩小为&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;。默认为True。</target>
        </trans-unit>
        <trans-unit id="d9db91db6f9220d3637c22a670ce2fece1ba8892" translate="yes" xml:space="preserve">
          <source>Whether to store matrix in C- or Fortran-contiguous order, default is &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">是否以C或Fortran连续顺序存储矩阵，默认值为'C'。</target>
        </trans-unit>
        <trans-unit id="f47e8ef32095f56286465eeec2aded155a972a62" translate="yes" xml:space="preserve">
          <source>Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.</source>
          <target state="translated">在内存中是按行大写(C式)还是列大写(Fortran式)的顺序存储多维数据。</target>
        </trans-unit>
        <trans-unit id="91845ffd71912999afe1ae31aecba568b6c77126" translate="yes" xml:space="preserve">
          <source>Whether to store multidimensional data in C- or Fortran-contiguous (row- or column-wise) order in memory.</source>
          <target state="translated">在内存中是按C语言还是Fortran语言连续(按行或列)的顺序存储多维数据。</target>
        </trans-unit>
        <trans-unit id="dab7c3794a646540de7acd62a59e0fb24a52ca93" translate="yes" xml:space="preserve">
          <source>Whether to store the result in C- or Fortran-contiguous order, default is &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">是否以C或Fortran连续顺序存储结果，默认值为'C'。</target>
        </trans-unit>
        <trans-unit id="bfc4130ee9478e47e13d28dd5c7bbedd301de36f" translate="yes" xml:space="preserve">
          <source>Whether to use a copy of &lt;code&gt;a&lt;/code&gt; (True) or to fix &lt;code&gt;a&lt;/code&gt; in place (False). Default is True.</source>
          <target state="translated">是否使用副本 &lt;code&gt;a&lt;/code&gt; （True）还是固定 &lt;code&gt;a&lt;/code&gt; 到位（假）。默认值为True。</target>
        </trans-unit>
        <trans-unit id="aebefd02adf3850b379921c027ca5f73a9e89812" translate="yes" xml:space="preserve">
          <source>Whether to use a hard mask or not. With a hard mask, masked values cannot be unmasked. Default is False.</source>
          <target state="translated">是否使用硬掩码。使用硬掩码时,掩码的值不能被取消掩码。默认为False。</target>
        </trans-unit>
        <trans-unit id="5e961f550eaad97e3dafff75ba96d8df26719652" translate="yes" xml:space="preserve">
          <source>Whether to use row-major (&amp;lsquo;C&amp;rsquo;) or column-major (&amp;lsquo;FORTRAN&amp;rsquo;) memory representation. Default is &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">是使用行优先（'C'）还是列优先（'FORTRAN'）内存表示形式。默认值为&amp;ldquo; C&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="cc497678cbe7ddcd1c3ae01eed475a06c838ec4e" translate="yes" xml:space="preserve">
          <source>Whether to use row-major (C-style) or column-major (Fortran-style) memory representation. Defaults to &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">是使用行优先（C风格）还是列优先（Fortran风格）内存表示形式。默认为&amp;ldquo; C&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="25195d8226c7af7ee557736e882797435cd7c507" translate="yes" xml:space="preserve">
          <source>Which columns to read, with 0 being the first. For example, &lt;code&gt;usecols = (1, 4, 5)&lt;/code&gt; will extract the 2nd, 5th and 6th columns.</source>
          <target state="translated">要读取的列，第一列为0。例如， &lt;code&gt;usecols = (1, 4, 5)&lt;/code&gt; 将提取第二，第五和第六列。</target>
        </trans-unit>
        <trans-unit id="ef9e92c2b540fbcf01177bb037dde03eb96de271" translate="yes" xml:space="preserve">
          <source>Which columns to read, with 0 being the first. For example, &lt;code&gt;usecols = (1,4,5)&lt;/code&gt; will extract the 2nd, 5th and 6th columns. The default, None, results in all columns being read.</source>
          <target state="translated">要读取的列，第一列为0。例如， &lt;code&gt;usecols = (1,4,5)&lt;/code&gt; 将提取第二，第五和第六列。默认值为&amp;ldquo;无&amp;rdquo;，将导致读取所有列。</target>
        </trans-unit>
        <trans-unit id="13f9686c4e3a41f3f30b2ea464209b867b694965" translate="yes" xml:space="preserve">
          <source>Which gives more easily comparable results than using separate bins for each histogram:</source>
          <target state="translated">这比对每个直方图使用单独的分仓更容易得到可比的结果。</target>
        </trans-unit>
        <trans-unit id="a1a80f0fc41db0ca1b3afb508f48229204eeb48b" translate="yes" xml:space="preserve">
          <source>Which gives the polynomial &lt;code&gt;p&lt;/code&gt; in Chebyshev form. This works because</source>
          <target state="translated">这给出了切比雪夫形式的多项式 &lt;code&gt;p&lt;/code&gt; 。这行得通，因为</target>
        </trans-unit>
        <trans-unit id="559b97a21645e20b96438fa99ddc59b3a9a0af7c" translate="yes" xml:space="preserve">
          <source>While a C-style and Fortran-style contiguous array, which has the corresponding flags set, can be addressed with the above strides, the actual strides may be different. This can happen in two cases:</source>
          <target state="translated">虽然一个C风格和Fortran风格的连续数组,设置了相应的标志,可以用上述跨步来寻址,但实际的跨步可能不同。这可能发生在两种情况下。</target>
        </trans-unit>
        <trans-unit id="d1df1b5a0658c69d8a413e038e320119a5eacba2" translate="yes" xml:space="preserve">
          <source>While the nonzero values can be obtained with &lt;code&gt;a[nonzero(a)]&lt;/code&gt;, it is recommended to use &lt;code&gt;x[x.astype(bool)]&lt;/code&gt; or &lt;code&gt;x[x != 0]&lt;/code&gt; instead, which will correctly handle 0-d arrays.</source>
          <target state="translated">虽然可以使用 &lt;code&gt;x[x.astype(bool)]&lt;/code&gt; &lt;code&gt;a[nonzero(a)]&lt;/code&gt; 获得非零值，但建议改用x [x.astype（bool）]或 &lt;code&gt;x[x != 0]&lt;/code&gt; ，它们将正确处理0-d数组。</target>
        </trans-unit>
        <trans-unit id="95abe15b68efd387eb8c7edc6a4c57dd87ccf623" translate="yes" xml:space="preserve">
          <source>While we&amp;rsquo;re at it, let&amp;rsquo;s also introduce the &amp;lsquo;no_broadcast&amp;rsquo; flag, which will prevent the output from being broadcast. This is important, because we only want one input value for each output. Aggregating more than one input value is a reduction operation which requires special handling. It would already raise an error because reductions must be explicitly enabled in an iterator flag, but the error message that results from disabling broadcasting is much more understandable for end-users. To see how to generalize the square function to a reduction, look at the sum of squares function in the section about Cython.</source>
          <target state="translated">在讨论的同时，我们还引入了'no_broadcast'标志，该标志将防止广播输出。这很重要，因为我们只希望每个输出一个输入值。汇总多个输入值是一种减少操作，需要特殊处理。因为已经必须在迭代器标志中显式启用减少功能，所以它已经引发了错误，但是对于最终用户而言，禁用广播所导致的错误消息更加容易理解。若要查看如何将平方函数归纳为约简，请参阅关于Cython的部分中的平方和函数。</target>
        </trans-unit>
        <trans-unit id="fdf453fd16b5200319b11da91be27d0c70481271" translate="yes" xml:space="preserve">
          <source>White spaces are ignored.</source>
          <target state="translated">白色空间被忽略。</target>
        </trans-unit>
        <trans-unit id="7da3ad366450168b425d91b2ecc5364e5b9f6133" translate="yes" xml:space="preserve">
          <source>Why is There a Second File?</source>
          <target state="translated">为什么会有第二档案?</target>
        </trans-unit>
        <trans-unit id="a5faa59dd442eb9f9b067a10198b95685727452a" translate="yes" xml:space="preserve">
          <source>Width of string to left-fill elements in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">字符串的左填充元素的宽度 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a87a9df3bc292d00475af99a19cfb5bace676377" translate="yes" xml:space="preserve">
          <source>Wikipedia page: &lt;a href=&quot;https://en.wikipedia.org/wiki/Trapezoidal_rule&quot;&gt;https://en.wikipedia.org/wiki/Trapezoidal_rule&lt;/a&gt;</source>
          <target state="translated">维基百科页面：&lt;a href=&quot;https://en.wikipedia.org/wiki/Trapezoidal_rule&quot;&gt;https&lt;/a&gt;：//en.wikipedia.org/wiki/Trapezoidal_rule</target>
        </trans-unit>
        <trans-unit id="f57f881086e09b1ae09664bdf831c36a611c6436" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Binomial distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Binomial_distribution&quot;&gt;https://en.wikipedia.org/wiki/Binomial_distribution&lt;/a&gt;</source>
          <target state="translated">维基百科，&amp;ldquo;二项式分布&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Binomial_distribution&quot;&gt;https：//en.wikipedia.org/wiki/Binomial_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06cf28156832f9d8c24f1184dfe95f4c17b24eb4" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Cauchy distribution&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Cauchy_distribution&quot;&gt;https://en.wikipedia.org/wiki/Cauchy_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo; Cauchy发行版&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Cauchy_distribution&quot;&gt;https://en.wikipedia.org/wiki/Cauchy_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5f4dafaf375cb5ca788c45f1e6be90dcf059029c" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Convolution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;https://en.wikipedia.org/wiki/Convolution&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo;卷积&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;https：//en.wikipedia.org/wiki/Convolution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aefec7a4eb1a5aecabb180014fe85015da54a986" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Curve fitting&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Curve_fitting&quot;&gt;https://en.wikipedia.org/wiki/Curve_fitting&lt;/a&gt;</source>
          <target state="translated">维基百科，&amp;ldquo;曲线拟合&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Curve_fitting&quot;&gt;https：//en.wikipedia.org/wiki/Curve_fitting&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ceebe5e149c9b6f7b481dab32a8b80c5a5e67177" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Dirichlet distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Dirichlet_distribution&quot;&gt;https://en.wikipedia.org/wiki/Dirichlet_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo; Dirichlet分发&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Dirichlet_distribution&quot;&gt;https：//en.wikipedia.org/wiki/Dirichlet_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c274fb3e94d194d553ba10a5c9ba49ab92ab9ab3" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Exponential distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_distribution&quot;&gt;https://en.wikipedia.org/wiki/Exponential_distribution&lt;/a&gt;</source>
          <target state="translated">维基百科，&amp;ldquo;指数分布&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_distribution&quot;&gt;https：//en.wikipedia.org/wiki/Exponential_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0748ca7a20f6367685397b634c58b22d1101a55" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Exponential function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_function&quot;&gt;https://en.wikipedia.org/wiki/Exponential_function&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo;指数函数&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_function&quot;&gt;https：//en.wikipedia.org/wiki/Exponential_function&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="450a7618a7ae64b3deba48000f4698be90e329a4" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;F-distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/F-distribution&quot;&gt;https://en.wikipedia.org/wiki/F-distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo; F-发行&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/F-distribution&quot;&gt;https：//en.wikipedia.org/wiki/F-发行&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17b148f03642613eb714110e8ca6f8c433f95ee5" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Gamma distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Gamma_distribution&quot;&gt;https://en.wikipedia.org/wiki/Gamma_distribution&lt;/a&gt;</source>
          <target state="translated">维基百科，&amp;ldquo;伽玛分布&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Gamma_distribution&quot;&gt;https：//en.wikipedia.org/wiki/Gamma_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="607958a0e56c238af4c16a4ba8a36ed9dd6aae60" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Hyperbolic function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyperbolic_function&quot;&gt;https://en.wikipedia.org/wiki/Hyperbolic_function&lt;/a&gt;</source>
          <target state="translated">维基百科，&amp;ldquo;双曲线函数&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Hyperbolic_function&quot;&gt;https：//en.wikipedia.org/wiki/Hyperbolic_function&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2ed497979708d30048971b5f912f3a976a07c07" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Hypergeometric distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Hypergeometric_distribution&quot;&gt;https://en.wikipedia.org/wiki/Hypergeometric_distribution&lt;/a&gt;</source>
          <target state="translated">维基百科，&amp;ldquo;超几何分布&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Hypergeometric_distribution&quot;&gt;https：&lt;/a&gt; //en.wikipedia.org/wiki/Hypergeometric_distribution</target>
        </trans-unit>
        <trans-unit id="f6c41ede2dc056083c46b6379a06aec4ce640792" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Inverse Gaussian distribution&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution&quot;&gt;https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo;高斯逆​​分布&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution&quot;&gt;https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c81f68efd7be19a13fb16b9d3ede8e0916b2b3ba" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Inverse hyperbolic function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Arccosh&quot;&gt;https://en.wikipedia.org/wiki/Arccosh&lt;/a&gt;</source>
          <target state="translated">维基百科，&amp;ldquo;反双曲函数&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Arccosh&quot;&gt;https：//en.wikipedia.org/wiki/Arccosh&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="788ea2b2b4739c5aba7340cb8614d021cf776477" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Inverse hyperbolic function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Arcsinh&quot;&gt;https://en.wikipedia.org/wiki/Arcsinh&lt;/a&gt;</source>
          <target state="translated">维基百科，&amp;ldquo;反双曲函数&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Arcsinh&quot;&gt;https：//en.wikipedia.org/wiki/Arcsinh&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7afed20bd82634dc688b205c679d736b6a3ca9fd" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Inverse hyperbolic function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Arctanh&quot;&gt;https://en.wikipedia.org/wiki/Arctanh&lt;/a&gt;</source>
          <target state="translated">维基百科，&amp;ldquo;反双曲函数&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Arctanh&quot;&gt;https：//en.wikipedia.org/wiki/Arctanh&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8cbf65d4c8a1edb6485c9090716aa502b1cad498" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Laplace distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Laplace_distribution&quot;&gt;https://en.wikipedia.org/wiki/Laplace_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo;拉普拉斯分布&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Laplace_distribution&quot;&gt;https：//en.wikipedia.org/wiki/Laplace_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a5dafa467113c3ca3efc06f2332310e05c7a2741" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Logarithm&amp;rdquo;. &lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithm&quot;&gt;https://en.wikipedia.org/wiki/Logarithm&lt;/a&gt;</source>
          <target state="translated">维基百科，&amp;ldquo;对数&amp;rdquo;。&lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithm&quot;&gt;https://zh.wikipedia.org/wiki/对数&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c49c2d4eec5ab9e21b7777f19f27c237fceb82c5" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Logarithmic distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithmic_distribution&quot;&gt;https://en.wikipedia.org/wiki/Logarithmic_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo;对数分布&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithmic_distribution&quot;&gt;https：//en.wikipedia.org/wiki/Logarithmic_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78ccdc5f379af6bc4c7ea04cc13613370465bc4d" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Logistic-distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Logistic_distribution&quot;&gt;https://en.wikipedia.org/wiki/Logistic_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo;物流分布&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Logistic_distribution&quot;&gt;https：//en.wikipedia.org/wiki/Logistic_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c3fd20f148f2b77555334569014216015267361" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Negative binomial distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Negative_binomial_distribution&quot;&gt;https://en.wikipedia.org/wiki/Negative_binomial_distribution&lt;/a&gt;</source>
          <target state="translated">维基百科，&amp;ldquo;负二项式分布&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Negative_binomial_distribution&quot;&gt;https：//en.wikipedia.org/wiki/Negative_binomial_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="785913c64c1118d2e5699ad155c8010ddb5608e2" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Noncentral F-distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Noncentral_F-distribution&quot;&gt;https://en.wikipedia.org/wiki/Noncentral_F-distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo;非中央F分布&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Noncentral_F-distribution&quot;&gt;https：&lt;/a&gt; //en.wikipedia.org/wiki/Noncentral_F-distribution</target>
        </trans-unit>
        <trans-unit id="290d1f296088408d1c3d2c95c7a7428e7d2c6df3" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Noncentral chi-squared distribution&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution&quot;&gt;https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution&lt;/a&gt;</source>
          <target state="translated">维基百科，&amp;ldquo;非中心卡方分布&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution&quot;&gt;https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f54672c52ce6e2a5669a3fc7c140d35832003af5" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Normal distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;https://en.wikipedia.org/wiki/Normal_distribution&lt;/a&gt;</source>
          <target state="translated">维基百科，&amp;ldquo;正态分布&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;https：//en.wikipedia.org/wiki/Normal_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="47b80170417ddd59eaf50cda77d4edfc322816d8" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Pareto distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Pareto_distribution&quot;&gt;https://en.wikipedia.org/wiki/Pareto_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo;帕累托分布&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Pareto_distribution&quot;&gt;https：//en.wikipedia.org/wiki/Pareto_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d689426c6cd7a9b7cf6ef5d58b51175bf540f33b" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Poisson distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Poisson_distribution&quot;&gt;https://en.wikipedia.org/wiki/Poisson_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo;泊松分布&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Poisson_distribution&quot;&gt;https：//en.wikipedia.org/wiki/Poisson_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8adc5c562751b6b393b3aa2c35d2e2c7be11d14b" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Poisson process&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Poisson_process&quot;&gt;https://en.wikipedia.org/wiki/Poisson_process&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo;泊松过程&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Poisson_process&quot;&gt;https：//en.wikipedia.org/wiki/Poisson_process&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ca57768f5ed62a15abd4e259a3842bfc684623e" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Polynomial interpolation&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_interpolation&quot;&gt;https://en.wikipedia.org/wiki/Polynomial_interpolation&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo;多项式插值&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_interpolation&quot;&gt;https：//en.wikipedia.org/wiki/Polynomial_interpolation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ca489fd77451dbec195b0cb37e2326fd572ee535" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Rayleigh distribution&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Rayleigh_distribution&quot;&gt;https://en.wikipedia.org/wiki/Rayleigh_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo; Rayleigh发行版&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Rayleigh_distribution&quot;&gt;https://en.wikipedia.org/wiki/Rayleigh_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56ead22f9041996687e49f69c8aa068b4de6264b" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Sinc function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_function&quot;&gt;https://en.wikipedia.org/wiki/Sinc_function&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo; Sinc函数&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_function&quot;&gt;https：&lt;/a&gt; //en.wikipedia.org/wiki/Sinc_function</target>
        </trans-unit>
        <trans-unit id="bdeeaa545061fb4a54e4c2ef8adfce392d92d540" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Student&amp;rsquo;s t-distribution&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Student's_t-distribution&quot;&gt;https://en.wikipedia.org/wiki/Student&amp;rsquo;s_t-distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo;学生的t-分布&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Student's_t-distribution&quot;&gt;https://en.wikipedia.org/wiki/&lt;/a&gt;学生的_t-分布</target>
        </trans-unit>
        <trans-unit id="890688a22e8725c7cf1acbafe1abacdd0f27f3f0" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Triangular distribution&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_distribution&quot;&gt;https://en.wikipedia.org/wiki/Triangular_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo;三角分布&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_distribution&quot;&gt;https://en.wikipedia.org/wiki/Triangular_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d2b813725fc8f5761f54e225edc22f4a2afa8f7" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Two&amp;rsquo;s complement&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;https://en.wikipedia.org/wiki/Two&amp;rsquo;s_complement&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo;互为补充&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;https：//en.wikipedia.org/wiki/Two's_complement&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ecbb6d74623f82d0937cf4a5246298d1b6f5e329" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Weibull distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Weibull_distribution&quot;&gt;https://en.wikipedia.org/wiki/Weibull_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo; Weibull分发&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Weibull_distribution&quot;&gt;https：//en.wikipedia.org/wiki/Weibull_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98885a7cf6a7f9d6ba5424eda905db3584405b75" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Window function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function&quot;&gt;https://en.wikipedia.org/wiki/Window_function&lt;/a&gt;</source>
          <target state="translated">Wikipedia，&amp;ldquo;窗口函数&amp;rdquo;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function&quot;&gt;https：//en.wikipedia.org/wiki/Window_function&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="49c2c96ddc19c930b5486ff7f81f0ce35e375ba2" translate="yes" xml:space="preserve">
          <source>Will install data-files to the locations:</source>
          <target state="translated">将安装数据文件到这些位置。</target>
        </trans-unit>
        <trans-unit id="0c6212fef9bffd0b18c4eb2da8c005e9e5030130" translate="yes" xml:space="preserve">
          <source>Will need to add this in Python exposure</source>
          <target state="translated">需要在Python暴露中添加这个</target>
        </trans-unit>
        <trans-unit id="77b99d58f8024a3322642cff8a7f3229ae7fe238" translate="yes" xml:space="preserve">
          <source>Window for the returned series. If None the class window is used. The default is None.</source>
          <target state="translated">返回系列的窗口。如果无,则使用类窗口。默认为None。</target>
        </trans-unit>
        <trans-unit id="cec65d78532248828b5443e4752a3df7fc4931aa" translate="yes" xml:space="preserve">
          <source>Window functions</source>
          <target state="translated">窗口功能</target>
        </trans-unit>
        <trans-unit id="e640f561d38642c76bd680b6e8d0ccf0fad3f32d" translate="yes" xml:space="preserve">
          <source>Window length.</source>
          <target state="translated">窗口长度。</target>
        </trans-unit>
        <trans-unit id="42e8204afc5c4121e8aabab0c8c2df383aac93dd" translate="yes" xml:space="preserve">
          <source>Window shape</source>
          <target state="translated">窗口形状</target>
        </trans-unit>
        <trans-unit id="ef32d19ad6db1a011986e848a81515a21a4878bf" translate="yes" xml:space="preserve">
          <source>Window to use for the returned series. The default value is the default class domain</source>
          <target state="translated">用于返回系列的窗口。默认值是默认的类域</target>
        </trans-unit>
        <trans-unit id="092e83dcd0b17c063ad8bac69729a61bcd90390f" translate="yes" xml:space="preserve">
          <source>Window, see &lt;a href=&quot;numpy.polynomial.chebyshev.chebyshev.domain#numpy.polynomial.chebyshev.Chebyshev.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; for its use. The default value is [-1, 1].</source>
          <target state="translated">窗口，请参见其使用&lt;a href=&quot;numpy.polynomial.chebyshev.chebyshev.domain#numpy.polynomial.chebyshev.Chebyshev.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt;。默认值为[-1，1]。</target>
        </trans-unit>
        <trans-unit id="26cbe48bc40af2be9b95617385514366c179f8c5" translate="yes" xml:space="preserve">
          <source>Window, see &lt;a href=&quot;numpy.polynomial.hermite.hermite.domain#numpy.polynomial.hermite.Hermite.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; for its use. The default value is [-1, 1].</source>
          <target state="translated">窗口，请参见其使用&lt;a href=&quot;numpy.polynomial.hermite.hermite.domain#numpy.polynomial.hermite.Hermite.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt;。默认值为[-1，1]。</target>
        </trans-unit>
        <trans-unit id="e22365565e3904f47ab3840e3c565f4c9730ed9d" translate="yes" xml:space="preserve">
          <source>Window, see &lt;a href=&quot;numpy.polynomial.hermite_e.hermitee.domain#numpy.polynomial.hermite_e.HermiteE.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; for its use. The default value is [-1, 1].</source>
          <target state="translated">窗口，请参见其使用&lt;a href=&quot;numpy.polynomial.hermite_e.hermitee.domain#numpy.polynomial.hermite_e.HermiteE.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt;。默认值为[-1，1]。</target>
        </trans-unit>
        <trans-unit id="9ae30d11df20bd6d7701709f6c7a07d9a4c0c35b" translate="yes" xml:space="preserve">
          <source>Window, see &lt;a href=&quot;numpy.polynomial.laguerre.laguerre.domain#numpy.polynomial.laguerre.Laguerre.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; for its use. The default value is [0, 1].</source>
          <target state="translated">窗口，请参见其使用&lt;a href=&quot;numpy.polynomial.laguerre.laguerre.domain#numpy.polynomial.laguerre.Laguerre.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt;。默认值为[0，1]。</target>
        </trans-unit>
        <trans-unit id="f003de753cd9362865426af3e4947b5f99fe6dc8" translate="yes" xml:space="preserve">
          <source>Window, see &lt;a href=&quot;numpy.polynomial.legendre.legendre.domain#numpy.polynomial.legendre.Legendre.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; for its use. The default value is [-1, 1].</source>
          <target state="translated">窗口，请参见其使用&lt;a href=&quot;numpy.polynomial.legendre.legendre.domain#numpy.polynomial.legendre.Legendre.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt;。默认值为[-1，1]。</target>
        </trans-unit>
        <trans-unit id="88febbc72ccac8a306fb0efe81d8a0b92e99d8f9" translate="yes" xml:space="preserve">
          <source>Window, see &lt;a href=&quot;numpy.polynomial.polynomial.polynomial.domain#numpy.polynomial.polynomial.Polynomial.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; for its use. The default value is [-1, 1].</source>
          <target state="translated">窗口，请参见其使用&lt;a href=&quot;numpy.polynomial.polynomial.polynomial.domain#numpy.polynomial.polynomial.Polynomial.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt;。默认值为[-1，1]。</target>
        </trans-unit>
        <trans-unit id="3a11c9632c71bf466541bc0b135a1a92817671b6" translate="yes" xml:space="preserve">
          <source>Windows 98, Python 2.1.1. Idle 0.8</source>
          <target state="translated">Windows 98,Python 2.1.1,Idle 0.8。</target>
        </trans-unit>
        <trans-unit id="838d226af82740a98f0145b002fc6c84c21c7131" translate="yes" xml:space="preserve">
          <source>Windows Me Python 2.3(EE), Idle 1.0, PyCrust 0.7.2 Python 2.1.1 Idle 0.8</source>
          <target state="translated">Windows Me Python 2.3(EE),Idle 1.0,PyCrust 0.7.2 Python 2.1.1 Idle 0.8</target>
        </trans-unit>
        <trans-unit id="2d2f4a4fca6daeabadddf9bee05651305943de5c" translate="yes" xml:space="preserve">
          <source>Windows XP, Python 2.3.3</source>
          <target state="translated">Windows XP,Python 2.3.3</target>
        </trans-unit>
        <trans-unit id="32efd2d58393af190f568a67689ea6a3e549d28a" translate="yes" xml:space="preserve">
          <source>With a context manager:</source>
          <target state="translated">有了上下文管理器。</target>
        </trans-unit>
        <trans-unit id="f3558ac1d15b5a57abf53ea4474761a5d8cd7257" translate="yes" xml:space="preserve">
          <source>With a higher dimensional array the split is still along the first axis.</source>
          <target state="translated">对于较高维数组,分割仍沿第一轴。</target>
        </trans-unit>
        <trans-unit id="ee544b31e6fafc07fbb87de84c67e07d54295002" translate="yes" xml:space="preserve">
          <source>With a higher dimensional array the split is still along the second axis.</source>
          <target state="translated">对于高维数组来说,分割仍然是沿第二轴。</target>
        </trans-unit>
        <trans-unit id="ab0ad2552c2290da0b4beaf3ab8b39ed880b7892" translate="yes" xml:space="preserve">
          <source>With a list of depth 1, &lt;a href=&quot;#numpy.block&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; can be used as &lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">具有深度1的列表，&lt;a href=&quot;#numpy.block&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt;可用作&lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4a6ca14b02d06fe44564f452a8db5dc0b8887f51" translate="yes" xml:space="preserve">
          <source>With a list of depth 2, &lt;a href=&quot;#numpy.block&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; can be used in place of &lt;a href=&quot;numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">具有深度2的列表，可以使用&lt;a href=&quot;#numpy.block&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt;代替&lt;a href=&quot;numpy.vstack#numpy.vstack&quot;&gt; &lt;code&gt;vstack&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="5f9ff7e20abf4e4beec43f72205b5efc96b3cabc" translate="yes" xml:space="preserve">
          <source>With a similar procedure the forward/backward approximations used for boundaries can be derived.</source>
          <target state="translated">通过类似的程序,可以得出用于边界的前/后近似值。</target>
        </trans-unit>
        <trans-unit id="07af3a8001dd5a2cff9dc94ccf6ded3daafa9ec6" translate="yes" xml:space="preserve">
          <source>With instances:</source>
          <target state="translated">与实例。</target>
        </trans-unit>
        <trans-unit id="98601db3737fbbb6544e879545b48b394db52bb5" translate="yes" xml:space="preserve">
          <source>With optional &lt;code&gt;start&lt;/code&gt;, test beginning at that position. With optional &lt;code&gt;end&lt;/code&gt;, stop comparing at that position.</source>
          <target state="translated">使用可选的 &lt;code&gt;start&lt;/code&gt; ，从该位置开始测试。使用可选的 &lt;code&gt;end&lt;/code&gt; ，停止在该位置进行比较。</target>
        </trans-unit>
        <trans-unit id="c2d93c630b90cc0cf1d738f44caa66baf4d85928" translate="yes" xml:space="preserve">
          <source>With types:</source>
          <target state="translated">有类型:</target>
        </trans-unit>
        <trans-unit id="5297c5a4978350f9e16a1aab9a51984e592036fa" translate="yes" xml:space="preserve">
          <source>Within a compiled Python module, &lt;code&gt;import_array()&lt;/code&gt; should only get called once. This could be in a C/C++ file that you have written and is linked to the module. If this is the case, then none of your interface files should &lt;code&gt;#define SWIG_FILE_WITH_INIT&lt;/code&gt; or call &lt;code&gt;import_array()&lt;/code&gt;. Or, this initialization call could be in a wrapper file generated by &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; from an interface file that has the &lt;code&gt;%init&lt;/code&gt; block as above. If this is the case, and you have more than one &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; interface file, then only one interface file should &lt;code&gt;#define SWIG_FILE_WITH_INIT&lt;/code&gt; and call &lt;code&gt;import_array()&lt;/code&gt;.</source>
          <target state="translated">在已编译的Python模块中， &lt;code&gt;import_array()&lt;/code&gt; 应该仅被调用一次。这可能在您编写并链接到模块的C / C ++文件中。如果是这种情况，那么您的接口文件都不应 &lt;code&gt;#define SWIG_FILE_WITH_INIT&lt;/code&gt; 或调用 &lt;code&gt;import_array()&lt;/code&gt; 。或者，此初始化调用可能位于&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;从具有上述 &lt;code&gt;%init&lt;/code&gt; 块的接口文件生成的包装文件中。如果是这种情况，并且您有多个&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;接口文件，则仅一个接口文件应 &lt;code&gt;#define SWIG_FILE_WITH_INIT&lt;/code&gt; 并调用 &lt;code&gt;import_array()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42a24f4738db07788648f7de55bbb8493bc76610" translate="yes" xml:space="preserve">
          <source>Within these test methods, &lt;code&gt;assert_()&lt;/code&gt; and related functions are used to test whether a certain assumption is valid. If the assertion fails, the test fails. Note that the Python builtin &lt;code&gt;assert&lt;/code&gt; should not be used, because it is stripped during compilation with &lt;code&gt;-O&lt;/code&gt;.</source>
          <target state="translated">在这些测试方法中， &lt;code&gt;assert_()&lt;/code&gt; 和相关函数用于测试某个假设是否有效。如果断言失败，则测试失败。请注意，不应使用Python内置的 &lt;code&gt;assert&lt;/code&gt; ，因为在使用 &lt;code&gt;-O&lt;/code&gt; 进行编译时会将其删除。</target>
        </trans-unit>
        <trans-unit id="2729aa84fd8dbce5d8f5065881c86da559d3b68c" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;np.ix_&lt;/code&gt; call or only the diagonal elements would be selected.</source>
          <target state="translated">如果不调用 &lt;code&gt;np.ix_&lt;/code&gt; 或仅选择对角线元素。</target>
        </trans-unit>
        <trans-unit id="eb6d460982da286faa01241fe0e8688fe713d131" translate="yes" xml:space="preserve">
          <source>Working on the flattened array does not return slices along an axis but selects elements.</source>
          <target state="translated">在扁平化数组上工作不会沿轴返回切片,而是选择元素。</target>
        </trans-unit>
        <trans-unit id="20669d5d64b568db66a362c01f09d0be2912bdf7" translate="yes" xml:space="preserve">
          <source>Works only with 2-D arrays at the moment.</source>
          <target state="translated">目前只适用于二维阵列。</target>
        </trans-unit>
        <trans-unit id="10b18b3520a07a5cef88cf768f74798c3a76c969" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;code&gt;cPickle.load&lt;/code&gt; which accepts either a file-like object or a filename.</source>
          <target state="translated">&lt;code&gt;cPickle.load&lt;/code&gt; 周围的包装器，它可以接受类似文件的对象或文件名。</target>
        </trans-unit>
        <trans-unit id="9462c7fa9fecb835eb7e04e6564736baefd4da76" translate="yes" xml:space="preserve">
          <source>Wrapper functions to more user-friendly calling of certain math functions whose output data-type is different than the input data-type in certain domains of the input.</source>
          <target state="translated">封装函数,以更方便地调用某些数学函数,这些函数的输出数据类型与输入数据类型在某些领域的输入不同。</target>
        </trans-unit>
        <trans-unit id="4a3455d09d842fa89e3426820a565b99b12203bd" translate="yes" xml:space="preserve">
          <source>Wraps an index to the valid range if it is out of bounds.</source>
          <target state="translated">如果索引出界,则将其包裹到有效范围。</target>
        </trans-unit>
        <trans-unit id="7a347606df979a4d48c841a72544818a00c72b80" translate="yes" xml:space="preserve">
          <source>Wraps the numpy array and sets the mask according to context.</source>
          <target state="translated">包裹numpy数组并根据上下文设置掩码。</target>
        </trans-unit>
        <trans-unit id="e18273e50d37416e99772f5cab31d35dc76b18b6" translate="yes" xml:space="preserve">
          <source>Write any changes in the array to the file on disk.</source>
          <target state="translated">将阵列中的任何变化写入磁盘上的文件。</target>
        </trans-unit>
        <trans-unit id="17ca7c9b94fb6b9ea51995accba9353b9d7605ae" translate="yes" xml:space="preserve">
          <source>Write array to a file as text or binary (default).</source>
          <target state="translated">将数组以文本或二进制形式写入文件(默认)。</target>
        </trans-unit>
        <trans-unit id="b0ef5a1f165fa86b8ee546df97daa724c33481fa" translate="yes" xml:space="preserve">
          <source>Write data to memmap array:</source>
          <target state="translated">向memmap数组写入数据。</target>
        </trans-unit>
        <trans-unit id="39de007639c1cf0174274b49579ea3af01d9afca" translate="yes" xml:space="preserve">
          <source>Write the contents of &lt;em&gt;self&lt;/em&gt; to the file pointer &lt;em&gt;fp&lt;/em&gt; in C-style contiguous fashion. Write the data as binary bytes if &lt;em&gt;sep&lt;/em&gt; is the string &amp;ldquo;&amp;rdquo;or &lt;code&gt;NULL&lt;/code&gt;. Otherwise, write the contents of &lt;em&gt;self&lt;/em&gt; as text using the &lt;em&gt;sep&lt;/em&gt; string as the item separator. Each item will be printed to the file. If the &lt;em&gt;format&lt;/em&gt; string is not &lt;code&gt;NULL&lt;/code&gt; or &amp;ldquo;&amp;rdquo;, then it is a Python print statement format string showing how the items are to be written.</source>
          <target state="translated">以C样式连续的方式将&lt;em&gt;self&lt;/em&gt;的内容写入文件指针&lt;em&gt;fp&lt;/em&gt;。如果&lt;em&gt;sep&lt;/em&gt;是字符串&amp;ldquo;&amp;rdquo;或 &lt;code&gt;NULL&lt;/code&gt; ,则将数据写为二进制字节。否则，使用&lt;em&gt;sep&lt;/em&gt;字符串作为项目分隔符，将&lt;em&gt;self&lt;/em&gt;的内容写为文本。每个项目将被打印到文件中。如果&lt;em&gt;格式&lt;/em&gt;字符串不是 &lt;code&gt;NULL&lt;/code&gt; 或&amp;ldquo;&amp;rdquo;，则它是Python打印语句格式字符串，显示如何写入项目。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d00c80b2825b910b28f217d40888491f74cea96" translate="yes" xml:space="preserve">
          <source>Writeable returned arrays (since version 1.10.0):</source>
          <target state="translated">可写的返回数组(从1.10.0版本开始)。</target>
        </trans-unit>
        <trans-unit id="6ebe08ad44f2f2a207e761b2763be6cc2be06253" translate="yes" xml:space="preserve">
          <source>Writing tests for the &lt;code&gt;numpy.i&lt;/code&gt;&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; interface file is a combinatorial headache. At present, 12 different data types are supported, each with 74 different argument signatures, for a total of 888 typemaps supported &amp;ldquo;out of the box&amp;rdquo;. Each of these typemaps, in turn, might require several unit tests in order to verify expected behavior for both proper and improper inputs. Currently, this results in more than 1,000 individual unit tests executed when &lt;code&gt;make test&lt;/code&gt; is run in the &lt;code&gt;numpy/tools/swig&lt;/code&gt; subdirectory.</source>
          <target state="translated">为 &lt;code&gt;numpy.i&lt;/code&gt; &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;接口文件编写测试是一个组合难题。目前，支持12种不同的数据类型，每种数据类型具有74个不同的参数签名，总共支持888个&amp;ldquo;即开即用&amp;rdquo;的类型映射。这些类型映射中的每一个可能反过来可能都需要进行多个单元测试，以验证正确和不正确输入的预期行为。当前，当在 &lt;code&gt;numpy/tools/swig&lt;/code&gt; 子目录中运行 &lt;code&gt;make test&lt;/code&gt; 时，将执行1,000多个单独的单元测试。</target>
        </trans-unit>
        <trans-unit id="aecfd6c8b6bdc8850ec5e6c24472a391088658d3" translate="yes" xml:space="preserve">
          <source>Writing typemaps can be a bit nonintuitive. If you have specific questions about writing &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemaps for NumPy, the developers of &lt;code&gt;numpy.i&lt;/code&gt; do monitor the &lt;a href=&quot;mailto:Numpy-discussion%40python.org&quot;&gt;Numpy-discussion&lt;/a&gt; and &lt;a href=&quot;mailto:Swig-user%40lists.sourceforge.net&quot;&gt;Swig-user&lt;/a&gt; mail lists.</source>
          <target state="translated">编写类型图可能有点不直观。如果您有关于写作的具体问题&lt;a href=&quot;http://www.swig.org&quot;&gt;呷&lt;/a&gt; typemaps为NumPy的，开发商 &lt;code&gt;numpy.i&lt;/code&gt; 做监测&lt;a href=&quot;mailto:Numpy-discussion%40python.org&quot;&gt;与NumPy的讨论&lt;/a&gt;和&lt;a href=&quot;mailto:Swig-user%40lists.sourceforge.net&quot;&gt;痛饮用户&lt;/a&gt;邮件列表。</target>
        </trans-unit>
        <trans-unit id="67b3075df8e687d02e42240f00e9c97b2d568182" translate="yes" xml:space="preserve">
          <source>Writing your own tests</source>
          <target state="translated">编写自己的测试</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="3e44498549b3ccfc159cdee6bdb9318868914b00" translate="yes" xml:space="preserve">
          <source>Yet another possibility is to use any of the following functions:</source>
          <target state="translated">然而,另一种可能性是使用以下任何一种功能:</target>
        </trans-unit>
        <trans-unit id="d4a5fe8b97704af411fc68344f43f8175b5a17c2" translate="yes" xml:space="preserve">
          <source>You can also put the common two last lines into an extension-local header file as long as you make sure that NO_IMPORT_ARRAY is #defined before #including that file.</source>
          <target state="translated">你也可以把常用的最后两行放到扩展本地头文件中,只要你在#包含该文件之前确保NO_IMPORT_ARRAY是#定义的。</target>
        </trans-unit>
        <trans-unit id="bd5bdd1d6f2605746dfa5444603a80a8e39ed12e" translate="yes" xml:space="preserve">
          <source>You can also start the product with a value other than one:</source>
          <target state="translated">你也可以用一个以外的值来启动产品。</target>
        </trans-unit>
        <trans-unit id="9238d7ca5ba3e22758c44fc16cfa76bade93b524" translate="yes" xml:space="preserve">
          <source>You can also start the sum with a value other than zero:</source>
          <target state="translated">你也可以用一个零以外的值开始计算。</target>
        </trans-unit>
        <trans-unit id="dbae01da7fe0ab4f2d4dfea82533b37281dc1510" translate="yes" xml:space="preserve">
          <source>You can check whether this option was enabled when your NumPy was built by looking at the value of &lt;code&gt;np.ones((10,1),
order='C').flags.f_contiguous&lt;/code&gt;. If this is &lt;code&gt;True&lt;/code&gt;, then your NumPy has relaxed strides checking enabled.</source>
          <target state="translated">您可以通过查看 &lt;code&gt;np.ones((10,1), order='C').flags.f_contiguous&lt;/code&gt; 的值来检查在构建NumPy时是否启用了此选项。如果这是 &lt;code&gt;True&lt;/code&gt; ，则您的NumPy已启用宽松的步幅检查。</target>
        </trans-unit>
        <trans-unit id="9f727d609d02021feb25c56ec5c7d4115e505da2" translate="yes" xml:space="preserve">
          <source>You can do all this with &lt;code&gt;slice()&lt;/code&gt; plus a few special objects, but there&amp;rsquo;s a lot to remember and this version is simpler because it uses the standard array indexing syntax.</source>
          <target state="translated">您可以使用 &lt;code&gt;slice()&lt;/code&gt; 加上一些特殊对象来完成所有这些操作，但是要记住很多事情，并且此版本更简单，因为它使用了标准的数组索引语法。</target>
        </trans-unit>
        <trans-unit id="8032e81ac40a6f0f1a73b54a1b7839b994061479" translate="yes" xml:space="preserve">
          <source>You can think of reshaping as first raveling the array (using the given index order), then inserting the elements from the raveled array into the new array using the same kind of index ordering as was used for the raveling.</source>
          <target state="translated">你可以认为重塑是首先对数组进行veling(使用给定的索引顺序),然后使用与veling相同的索引顺序从veling数组中插入元素到新数组中。</target>
        </trans-unit>
        <trans-unit id="6a1a526e2dfcefc7502bbfe7d5198a1cfd393800" translate="yes" xml:space="preserve">
          <source>You can use an initial value to compute the maximum of an empty slice, or to initialize it to a different value:</source>
          <target state="translated">您可以使用初始值来计算空片的最大值,或者将其初始化为不同的值。</target>
        </trans-unit>
        <trans-unit id="7d0bef869069e40769f21f1de600d0fc6d747dfa" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;initial&lt;/code&gt; keyword argument to initialize the reduction with a different value, and &lt;code&gt;where&lt;/code&gt; to select specific elements to include:</source>
          <target state="translated">您可以使用 &lt;code&gt;initial&lt;/code&gt; 关键字参数以不同的值初始化归约，以及 &lt;code&gt;where&lt;/code&gt; 选择要包括的特定元素：</target>
        </trans-unit>
        <trans-unit id="91fa0d476f571316eb9194c7c7392edcc2d88959" translate="yes" xml:space="preserve">
          <source>You can use the code in &lt;code&gt;numpy.i&lt;/code&gt; to write your own typemaps. For example, if you had a five-dimensional array as a function argument, you could cut-and-paste the appropriate four-dimensional typemaps into your interface file. The modifications for the fourth dimension would be trivial.</source>
          <target state="translated">您可以使用 &lt;code&gt;numpy.i&lt;/code&gt; 中的代码编写自己的类型映射。例如，如果有一个五维数组作为函数参数，则可以将适当的四维类型映射剪切并粘贴到接口文件中。第四维的修改将是微不足道的。</target>
        </trans-unit>
        <trans-unit id="98e9f88bd4a89aebe54d98a979717885fd9d0412" translate="yes" xml:space="preserve">
          <source>You may use slicing to set values in the array, but (unlike lists) you can never grow the array. The size of the value to be set in &lt;code&gt;x[obj] = value&lt;/code&gt; must be (broadcastable) to the same shape as &lt;code&gt;x[obj]&lt;/code&gt;.</source>
          <target state="translated">您可以使用切片来设置数组中的值，但是（与列表不同）您永远无法增长数组。要在 &lt;code&gt;x[obj] = value&lt;/code&gt; 设置的值的大小必须（可广播）为与 &lt;code&gt;x[obj]&lt;/code&gt; 相同的形状。</target>
        </trans-unit>
        <trans-unit id="f3568ae4f766e37d7c5effd4c8f672ee7bd5f8ce" translate="yes" xml:space="preserve">
          <source>You should note that, while included in the table for completeness, the &amp;lsquo;S&amp;rsquo;, &amp;lsquo;U&amp;rsquo;, and &amp;lsquo;V&amp;rsquo; types cannot be operated on by ufuncs. Also, note that on a 32-bit system the integer types may have different sizes, resulting in a slightly altered table.</source>
          <target state="translated">您应该注意，尽管出于完整性考虑，该表中包括了&amp;ldquo; S&amp;rdquo;，&amp;ldquo; U&amp;rdquo;和&amp;ldquo; V&amp;rdquo;类型，但它们不能由ufunc操作。另外，请注意，在32位系统上，整数类型可能具有不同的大小，从而导致表稍有变化。</target>
        </trans-unit>
        <trans-unit id="f357b2fe6ddb759961311e43e7970103d0b441f0" translate="yes" xml:space="preserve">
          <source>You will also need to add the tests directory in the configuration section of your setup.py:</source>
          <target state="translated">你还需要在setup.py的配置部分添加测试目录。</target>
        </trans-unit>
        <trans-unit id="1e16810e3242991af56a001ed6a884d632c200f8" translate="yes" xml:space="preserve">
          <source>Zero matrix of given shape, dtype, and order.</source>
          <target state="translated">给定形状、dtype和顺序的零矩阵。</target>
        </trans-unit>
        <trans-unit id="e45e696eb3d4f02d39791369c3d3958a76ab90d1" translate="yes" xml:space="preserve">
          <source>Zero matrix.</source>
          <target state="translated">零矩阵。</target>
        </trans-unit>
        <trans-unit id="dc9379a72db3a8937472e62bd1e9326e04e14e35" translate="yes" xml:space="preserve">
          <source>Zero-padding, analogously with &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, is performed by appending zeros to the input along the specified dimension. Although this is the common approach, it might lead to surprising results. If another form of zero padding is desired, it must be performed before &lt;a href=&quot;#numpy.fft.ifft2&quot;&gt;&lt;code&gt;ifft2&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">类似于&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt;，零填充是通过沿指定维度在输入上附加零来执行的。尽管这是常见的方法，但可能会导致令人惊讶的结果。如果需要另一种形式的零填充，则必须在&lt;a href=&quot;#numpy.fft.ifft2&quot;&gt; &lt;code&gt;ifft2&lt;/code&gt; &lt;/a&gt;之前执行。</target>
        </trans-unit>
        <trans-unit id="64a64c98f6885c75110c036526d556b9a4c44be0" translate="yes" xml:space="preserve">
          <source>Zero-padding, analogously with &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, is performed by appending zeros to the input along the specified dimension. Although this is the common approach, it might lead to surprising results. If another form of zero padding is desired, it must be performed before &lt;a href=&quot;#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">类似于&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt;，零填充是通过沿指定维度在输入上附加零来执行的。尽管这是常见的方法，但可能会导致令人惊讶的结果。如果需要另一种形式的零填充，则必须在&lt;a href=&quot;#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt;之前执行。</target>
        </trans-unit>
        <trans-unit id="517f56a81e423e64373bd116eb0759a041c8ad2f" translate="yes" xml:space="preserve">
          <source>Zeros are returned for slices that are all-NaN or empty.</source>
          <target state="translated">对于全NaN或空的片子,会返回0。</target>
        </trans-unit>
        <trans-unit id="acacd887197bd2babb7be61e73a56d1f99561e0f" translate="yes" xml:space="preserve">
          <source>Zipf, G. K., &amp;ldquo;Selected Studies of the Principle of Relative Frequency in Language,&amp;rdquo; Cambridge, MA: Harvard Univ. Press, 1932.</source>
          <target state="translated">Zipf，GK，&amp;ldquo;语言中相对频率原理的精选研究&amp;rdquo;，马萨诸塞州剑桥：哈佛大学。出版社，1932年。</target>
        </trans-unit>
        <trans-unit id="ed86773f64d57f9b3c7ee4020ed0f191241f3769" translate="yes" xml:space="preserve">
          <source>[ 1678 AD, 2262 AD]</source>
          <target state="translated">[公元1678年，公元2262年]</target>
        </trans-unit>
        <trans-unit id="402b4dc5670a23bc318ab3cb00cdc7fa9f64de7f" translate="yes" xml:space="preserve">
          <source>[ 1969 AD, 1970 AD]</source>
          <target state="translated">[1969年，1970年]</target>
        </trans-unit>
        <trans-unit id="bd183430653087be5ae12502c45fc000d3da0d92" translate="yes" xml:space="preserve">
          <source>[ 2.9e8 BC, 2.9e8 AD]</source>
          <target state="translated">[公元前2.9e8，公元2.9e8]</target>
        </trans-unit>
        <trans-unit id="dc7f3e791b46510c11bbde8e0bb893651cf79bee" translate="yes" xml:space="preserve">
          <source>[1.0e15 BC, 1.0e15 AD]</source>
          <target state="translated">[公元前1.0e15，公元1.0e15]</target>
        </trans-unit>
        <trans-unit id="06a7557ae8ce0cfbe48cae36c42a5043941673e5" translate="yes" xml:space="preserve">
          <source>[1.7e13 BC, 1.7e13 AD]</source>
          <target state="translated">[公元前1.7e13，公元1.7e13]</target>
        </trans-unit>
        <trans-unit id="d122eae6bae0b58d08b1fd88854423fb5b4631e6" translate="yes" xml:space="preserve">
          <source>[1.7e17 BC, 1.7e17 AD]</source>
          <target state="translated">[公元前1.7e17，公元1.7e17]</target>
        </trans-unit>
        <trans-unit id="af9678a88e0692bf413856f430540a50579b7921" translate="yes" xml:space="preserve">
          <source>[2.5e16 BC, 2.5e16 AD]</source>
          <target state="translated">[2.5e16 BC，2.5e16 AD]</target>
        </trans-unit>
        <trans-unit id="fb54cef9abe0ffb09a025ee28bfe888680b86ee0" translate="yes" xml:space="preserve">
          <source>[2.9e11 BC, 2.9e11 AD]</source>
          <target state="translated">[公元前2.9e11，公元2.9e11]</target>
        </trans-unit>
        <trans-unit id="9b1e4a9e31badd5faa858bd32af6c4bab33690b0" translate="yes" xml:space="preserve">
          <source>[290301 BC, 294241 AD]</source>
          <target state="translated">[公元前290301年，公元294241年]</target>
        </trans-unit>
        <trans-unit id="2212219fa92d0d55a2e83f844d81d7dc4a36dd7d" translate="yes" xml:space="preserve">
          <source>[7.6e17 BC, 7.6e17 AD]</source>
          <target state="translated">[公元前7.6e17，公元7.6e17]</target>
        </trans-unit>
        <trans-unit id="7855213bc11a8db7fc6daa3f131f06c9977a3960" translate="yes" xml:space="preserve">
          <source>[9.2e18 BC, 9.2e18 AD]</source>
          <target state="translated">[公元前9.2e18年，公元9.2e18]</target>
        </trans-unit>
        <trans-unit id="faf24ac10ab74f225b601311df4355d76763fa97" translate="yes" xml:space="preserve">
          <source>[CT]</source>
          <target state="translated">[CT]</target>
        </trans-unit>
        <trans-unit id="7d2f4bdb1926f2cbbdd65bcf6b74603f5acdf8c8" translate="yes" xml:space="preserve">
          <source>[G]</source>
          <target state="translated">[G]</target>
        </trans-unit>
        <trans-unit id="3d6c6c6111149819e43b6089c9a7b9c8a2431938" translate="yes" xml:space="preserve">
          <source>[NR]</source>
          <target state="translated">[NR]</target>
        </trans-unit>
        <trans-unit id="1b8941d3b1d081473898f4b2e4a8ff850cc6de82" translate="yes" xml:space="preserve">
          <source>[R5cc1f1f25381-1]</source>
          <target state="translated">[R5cc1f1f25381-1]</target>
        </trans-unit>
        <trans-unit id="0c4d5826769047e816879e0f7216ecf388ea499b" translate="yes" xml:space="preserve">
          <source>[Re860718f5533-1]</source>
          <target state="translated">[Re860718f5533-1]</target>
        </trans-unit>
        <trans-unit id="6b6f9491cb308db36a45d25a8dcf1db55932e083" translate="yes" xml:space="preserve">
          <source>[WRW]</source>
          <target state="translated">[WRW]</target>
        </trans-unit>
        <trans-unit id="3897c72013a6887de9a1de9869c3e948fd9696d2" translate="yes" xml:space="preserve">
          <source>__array_data__</source>
          <target state="translated">__array_data__</target>
        </trans-unit>
        <trans-unit id="81f5d0f249cae6e54a5453d7972fcd0943accd0e" translate="yes" xml:space="preserve">
          <source>__array_descr__</source>
          <target state="translated">__array_descr__</target>
        </trans-unit>
        <trans-unit id="c0a201183273449f8bd82be2d062468aa25df323" translate="yes" xml:space="preserve">
          <source>__array_interface__</source>
          <target state="translated">__array_interface__</target>
        </trans-unit>
        <trans-unit id="0a9ff3eb9a1e79e8a4cdf02304244a5327adcb47" translate="yes" xml:space="preserve">
          <source>__array_mask__</source>
          <target state="translated">__array_mask__</target>
        </trans-unit>
        <trans-unit id="ac7e7fcdcffb075d0e09e72d92d910d4b9351cdb" translate="yes" xml:space="preserve">
          <source>__array_offset__</source>
          <target state="translated">__array_offset__</target>
        </trans-unit>
        <trans-unit id="238f299c155456fe6a848580f0ef9d3e6bb2a8de" translate="yes" xml:space="preserve">
          <source>__array_shape__</source>
          <target state="translated">__array_shape__</target>
        </trans-unit>
        <trans-unit id="2f3678a5595fd628d8dfae6d631c1ae1fb6ef8da" translate="yes" xml:space="preserve">
          <source>__array_strides__</source>
          <target state="translated">__array_strides__</target>
        </trans-unit>
        <trans-unit id="aa0ad955aed8601e1764fbffe3d43f4a00fe14f0" translate="yes" xml:space="preserve">
          <source>__array_typestr__</source>
          <target state="translated">__array_typestr__</target>
        </trans-unit>
        <trans-unit id="96401488135b817c2f1747197a83525ae296049e" translate="yes" xml:space="preserve">
          <source>a (fixed) payment, &lt;a href=&quot;numpy.pmt#numpy.pmt&quot;&gt;&lt;code&gt;pmt&lt;/code&gt;&lt;/a&gt;, paid either</source>
          <target state="translated">（固定）付款&lt;a href=&quot;numpy.pmt#numpy.pmt&quot;&gt; &lt;code&gt;pmt&lt;/code&gt; &lt;/a&gt;支付</target>
        </trans-unit>
        <trans-unit id="d5166cddbf23a08b5074c2edc9aec3c68a5f3663" translate="yes" xml:space="preserve">
          <source>a 1-D array of 624 unsigned integer keys.</source>
          <target state="translated">624个无符号整数键的一维数组。</target>
        </trans-unit>
        <trans-unit id="e95c05fdf3a7626457c027e91f7b377539d00b22" translate="yes" xml:space="preserve">
          <source>a 1-D array of 624 unsigned integers &lt;code&gt;keys&lt;/code&gt;.</source>
          <target state="translated">由624个无符号整数 &lt;code&gt;keys&lt;/code&gt; 的一维数组。</target>
        </trans-unit>
        <trans-unit id="72fdfe6550961319f36cdd5e343cde12faf15445" translate="yes" xml:space="preserve">
          <source>a 1-d view of scalar</source>
          <target state="translated">标量的一维视图</target>
        </trans-unit>
        <trans-unit id="74f70982e8ed106bd95f08838212248bb41b2355" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt;,</source>
          <target state="translated">一个&lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;，</target>
        </trans-unit>
        <trans-unit id="8f21ea65027d34d0f525219a53334dc35cb5bbea" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;chararray&lt;/code&gt;,</source>
          <target state="translated">一个 &lt;code&gt;chararray&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="cb4065b0f0de4de8cc6afb691ce3365727df08a4" translate="yes" xml:space="preserve">
          <source>a Python str or unicode object,</source>
          <target state="translated">一个Python str或unicode对象。</target>
        </trans-unit>
        <trans-unit id="753cc1b7cdb86a0a582f834f17fe8e4f8e20365f" translate="yes" xml:space="preserve">
          <source>a binary string for the data</source>
          <target state="translated">数据的二进制字符串</target>
        </trans-unit>
        <trans-unit id="7be660f83fa27f597e95280a8283a2c0611d9749" translate="yes" xml:space="preserve">
          <source>a binary string for the mask.</source>
          <target state="translated">掩码的二进制字符串。</target>
        </trans-unit>
        <trans-unit id="da3d248ac1b46ab9b40ccba358d7b76cb5f95a1a" translate="yes" xml:space="preserve">
          <source>a binary string with the data (or a list if &amp;lsquo;a&amp;rsquo; is an object array)</source>
          <target state="translated">带有数据的二进制字符串（如果&amp;ldquo; a&amp;rdquo;是对象数组，则为列表）</target>
        </trans-unit>
        <trans-unit id="165258a094d59f96169a00b9e5b85c293cfac672" translate="yes" xml:space="preserve">
          <source>a flat iterator on the array.</source>
          <target state="translated">数组上的一个平面迭代器。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
