<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="0716cf4800278ada150f876e9ddcae3c99250b13" translate="yes" xml:space="preserve">
          <source>Their are two basic approaches to calling compiled code: writing an extension module that is then imported to Python using the import command, or calling a shared-library subroutine directly from Python using the &lt;a href=&quot;https://docs.python.org/3/library/ctypes.html&quot;&gt;ctypes&lt;/a&gt; module. Writing an extension module is the most common method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13617ef6d1ed670620e3eee1fe6521faed558f33" translate="yes" xml:space="preserve">
          <source>Their contents are described below.</source>
          <target state="translated">其内容介绍如下。</target>
        </trans-unit>
        <trans-unit id="d67a14bba38674d133aa6326e1d56a5430227ffd" translate="yes" xml:space="preserve">
          <source>Then modify it as follows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18de376fec5af9b24c105e03578c15d330983aed" translate="yes" xml:space="preserve">
          <source>Then you can obtain a lot of useful information (first details about &lt;code&gt;a&lt;/code&gt; itself, followed by the docstring of &lt;code&gt;ndarray&lt;/code&gt; of which &lt;code&gt;a&lt;/code&gt; is an instance):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beca14a81e09ec62e1fbfc41746f56a23c04a2b2" translate="yes" xml:space="preserve">
          <source>Then, I can compile the extension module using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa5af99f0618068c146112b2487469ac95f27c4" translate="yes" xml:space="preserve">
          <source>Then, all the HTML files will be generated in &lt;code&gt;doc/build/html/&lt;/code&gt;. Since the documentation is based on docstrings, the appropriate version of numpy must be installed in the host python used to run sphinx.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bbaffa25ddeac5ba58545ce47397f8a88d6c19f" translate="yes" xml:space="preserve">
          <source>Then, create a new branch based on the master branch of the upstream repository:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64f3ff6d48531fcbe93b1b844e9cc7950b3eeb4" translate="yes" xml:space="preserve">
          <source>Then, go to your forked repository github page, say &lt;code&gt;https://github.com/your-user-name/numpy&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="2a2d6eb0d79238cba7c8636b58f3ce6ad4b5b344" translate="yes" xml:space="preserve">
          <source>There are 4 relevant uses of the word &lt;code&gt;align&lt;/code&gt; used in numpy:</source>
          <target state="translated">numpy中使用 &lt;code&gt;align&lt;/code&gt; 一词有4种相关用法：</target>
        </trans-unit>
        <trans-unit id="d627a19c8c5bea4de4ec9dd15face492281b6f90" translate="yes" xml:space="preserve">
          <source>There are 5 basic numerical types representing booleans (bool), integers (int), unsigned integers (uint) floating point (float) and complex. Those with numbers in their name indicate the bitsize of the type (i.e. how many bits are needed to represent a single value in memory). Some types, such as &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;intp&lt;/code&gt;, have differing bitsizes, dependent on the platforms (e.g. 32-bit vs. 64-bit machines). This should be taken into account when interfacing with low-level code (such as C or Fortran) where the raw memory is addressed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17bb2653ac2aa7153e927fc1353ff32c9d0fadd9" translate="yes" xml:space="preserve">
          <source>There are 5 general mechanisms for creating arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7e737fa7ec2df18d82d046fe4547a421ecb3b7" translate="yes" xml:space="preserve">
          <source>There are 6 (binary) flags that describe the memory area used by the data buffer. These constants are defined in &lt;code&gt;arrayobject.h&lt;/code&gt; and determine the bit-position of the flag. Python exposes a nice attribute- based interface as well as a dictionary-like interface for getting (and, if appropriate, setting) these flags.</source>
          <target state="translated">有6个（二进制）标志描述了数据缓冲区使用的存储区域。这些常量在 &lt;code&gt;arrayobject.h&lt;/code&gt; 中定义，并确定标志的位位置。Python公开了一个不错的基于属性的接口以及一个类似于字典的接口，用于获取（以及在适当情况下设置）这些标志。</target>
        </trans-unit>
        <trans-unit id="92880b58f6bd9442d0573770c5bcc16b810e1cdc" translate="yes" xml:space="preserve">
          <source>There are &lt;code&gt;num&lt;/code&gt; equally spaced samples in the closed interval &lt;code&gt;[start, stop]&lt;/code&gt; or the half-open interval &lt;code&gt;[start, stop)&lt;/code&gt; (depending on whether &lt;code&gt;endpoint&lt;/code&gt; is True or False).</source>
          <target state="translated">在关闭间隔 &lt;code&gt;[start, stop]&lt;/code&gt; 或半开间隔 &lt;code&gt;[start, stop)&lt;/code&gt; ]中有 &lt;code&gt;num&lt;/code&gt; 个等间距的样本（取决于 &lt;code&gt;endpoint&lt;/code&gt; 是True还是False）。</target>
        </trans-unit>
        <trans-unit id="8269e59da4433043c91490542198a44ae2a7bd22" translate="yes" xml:space="preserve">
          <source>There are a few commonly reported issues depending on your system/setup. If none of the following tips help you, please be sure to note the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f20349ffc92d6259aa973ed6765d972938b14bd" translate="yes" xml:space="preserve">
          <source>There are a number of ways to assign values to a structured array: Using python tuples, using scalar values, or using other structured arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aabadb6a5aa99979671de060b5cf5eb2bfdc73b8" translate="yes" xml:space="preserve">
          <source>There are a variety of approaches one can use. If the file has a relatively simple format then one can write a simple I/O library and use the numpy fromfile() function and .tofile() method to read and write numpy arrays directly (mind your byteorder though!) If a good C or C++ library exists that read the data, one can wrap that library with a variety of techniques though that certainly is much more work and requires significantly more advanced knowledge to interface with C or C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6009b813cfbdbc400ba73901cd26bc8dc165215e" translate="yes" xml:space="preserve">
          <source>There are also typedefs for signed integers, unsigned integers, floating point, and complex floating point types of specific bit- widths. The available type names are</source>
          <target state="translated">还有有符号整数、无符号整数、浮点数和特定位宽的复杂浮点数类型的类型定义。可用的类型名称有</target>
        </trans-unit>
        <trans-unit id="2cd3e7355c4c3985bff39b5837a16202e8c1540c" translate="yes" xml:space="preserve">
          <source>There are currently more than 60 universal functions defined in &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; on one or more types, covering a wide variety of operations. Some of these ufuncs are called automatically on arrays when the relevant infix notation is used (&lt;em&gt;e.g.&lt;/em&gt;, &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add(a, b)&lt;/code&gt;&lt;/a&gt; is called internally when &lt;code&gt;a + b&lt;/code&gt; is written and &lt;em&gt;a&lt;/em&gt; or &lt;em&gt;b&lt;/em&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;). Nevertheless, you may still want to use the ufunc call in order to use the optional output argument(s) to place the output(s) in an object (or objects) of your choice.</source>
          <target state="translated">目前，在&lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; 中&lt;/a&gt;针对一种或多种类型定义了60多种通用函数，涵盖了多种操作。当使用相关的后缀表示法时，其中的一些ufunc会在数组上自动调用（&lt;em&gt;例如&lt;/em&gt;，当写入 &lt;code&gt;a + b&lt;/code&gt; 且&lt;em&gt;a&lt;/em&gt;或&lt;em&gt;b&lt;/em&gt;是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;时&lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt; &lt;code&gt;add(a, b)&lt;/code&gt; &lt;/a&gt;内部会调用add（a，b））。但是，您可能仍想使用ufunc调用，以便使用可选的输出参数将输出放置在您选择的一个或多个对象中。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="775b5ff21441ff77356a90016945326f51981b32" translate="yes" xml:space="preserve">
          <source>There are fairly common issues when using PyCharm together with Anaconda, please see the &lt;a href=&quot;https://www.jetbrains.com/help/pycharm/conda-support-creating-conda-virtual-environment.html&quot;&gt;PyCharm support&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3438358c09e82d3e17ac10e9485821f710c7159e" translate="yes" xml:space="preserve">
          <source>There are libraries that can be used to generate arrays for special purposes and it isn&amp;rsquo;t possible to enumerate all of them. The most common uses are use of the many array generation functions in random that can generate arrays of random values, and some utility functions to generate special matrices (e.g. diagonal).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c69a32040141b3969da2a2cbb310c56f38084713" translate="yes" xml:space="preserve">
          <source>There are lots of examples of how to use &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; throughout the NumPy source code. The standard usage is like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b9dbbab83df5d12e3f17adf9850959d4114286" translate="yes" xml:space="preserve">
          <source>There are many C or C++ array/NumPy array situations not covered by a simple &lt;code&gt;%include &quot;numpy.i&quot;&lt;/code&gt; and subsequent &lt;code&gt;%apply&lt;/code&gt; directives.</source>
          <target state="translated">简单的 &lt;code&gt;%include &quot;numpy.i&quot;&lt;/code&gt; 和后续的 &lt;code&gt;%apply&lt;/code&gt; 指令未涵盖许多C或C ++数组/ NumPy数组的情况。</target>
        </trans-unit>
        <trans-unit id="a3c7bbd8e8aff936bd091f138c70193c9efdefe3" translate="yes" xml:space="preserve">
          <source>There are many online tutorials to help you &lt;a href=&quot;https://www.atlassian.com/git/tutorials/&quot;&gt;learn git&lt;/a&gt;. For discussions of specific git workflows, see these discussions on &lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;linux git workflow&lt;/a&gt;, and &lt;a href=&quot;http://mail.python.org/pipermail/ipython-dev/2010-October/006746.html&quot;&gt;ipython git workflow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e7a362f552d6539941413dc2279097986613078" translate="yes" xml:space="preserve">
          <source>There are many ways of working with &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;; here are some posts on the rules of thumb that other projects have come up with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850bf20dccfb45fbea5bb3bf4cc123a24de9ce74" translate="yes" xml:space="preserve">
          <source>There are many ways to define the DFT, varying in the sign of the exponent, normalization, etc. In this implementation, the DFT is defined as</source>
          <target state="translated">定义DFT的方法有很多,在指数的符号、归一化等方面有所不同。在本实施例中,DFT被定义为</target>
        </trans-unit>
        <trans-unit id="76da8844fec054fd5276e6ad85d740b68fcb82e8" translate="yes" xml:space="preserve">
          <source>There are no general requirements on the return value from &lt;code&gt;__array_function__&lt;/code&gt;, although most sensible implementations should probably return array(s) with the same type as one of the function&amp;rsquo;s arguments.</source>
          <target state="translated">&lt;code&gt;__array_function__&lt;/code&gt; 的返回值没有一般要求，尽管大多数明智的实现可能应该返回与该函数的参数之一具有相同类型的数组。</target>
        </trans-unit>
        <trans-unit id="06faa5c6fcba06f9dd8ca92063029df6a41e4c58" translate="yes" xml:space="preserve">
          <source>There are often instances where we want NumPy to initialize the values of an array. NumPy offers functions like &lt;code&gt;ones()&lt;/code&gt; and &lt;code&gt;zeros()&lt;/code&gt;, and the &lt;code&gt;random.Generator&lt;/code&gt; class for random number generation for that. All you need to do is pass in the number of elements you want it to generate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95381d820ed4d179172c69e3a1efc8e39007df94" translate="yes" xml:space="preserve">
          <source>There are only integer array indices so that no subarray exists.</source>
          <target state="translated">只有整数组索引,所以不存在子数组。</target>
        </trans-unit>
        <trans-unit id="115526010a225042aa40f787fc2f47f797982daf" translate="yes" xml:space="preserve">
          <source>There are other points in the use of ndarrays where we need such views, such as copying arrays (&lt;code&gt;c_arr.copy()&lt;/code&gt;), creating ufunc output arrays (see also &lt;a href=&quot;#array-wrap&quot;&gt;__array_wrap__ for ufuncs and other functions&lt;/a&gt;), and reducing methods (like &lt;code&gt;c_arr.mean()&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e1214b4766467e55cb3f8f030a4456afbf45a2" translate="yes" xml:space="preserve">
          <source>There are other wrapping situations in which &lt;code&gt;numpy.i&lt;/code&gt; may be helpful when you encounter them.</source>
          <target state="translated">在其他包装情况下，遇到 &lt;code&gt;numpy.i&lt;/code&gt; 可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="318856ec210de70f7b88df3c75c2a12aaa8c93b2" translate="yes" xml:space="preserve">
          <source>There are pros and cons to using both:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83bfa0078610ce5c1a2e851fa86300b3de47263" translate="yes" xml:space="preserve">
          <source>There are several disadvantages of using Cython:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c928426bd7e5582ef0057cd443cd0554ec0f93c" translate="yes" xml:space="preserve">
          <source>There are several examples of using the multi-iterator in the NumPy source code as it makes N-dimensional broadcasting-code very simple to write. Browse the source for more examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27bf18c3e68f395d5dcf853e32e810c666f7a43d" translate="yes" xml:space="preserve">
          <source>There are several requirements for a shared library that can be used with ctypes that are platform specific. This guide assumes you have some familiarity with making a shared library on your system (or simply have a shared library available to you). Items to remember are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b82ec3b39568bfec9a11840bdb7b6ec4c84323cc" translate="yes" xml:space="preserve">
          <source>There are several ways to construct a masked array.</source>
          <target state="translated">有几种方法可以构建一个掩码数组。</target>
        </trans-unit>
        <trans-unit id="c4a7e4b025b48bc40d3703a29b57ae48e3043f29" translate="yes" xml:space="preserve">
          <source>There are several ways to create arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffbc541dfd45825fd321c5ec3bdf633ecc4c702b" translate="yes" xml:space="preserve">
          <source>There are some informational attributes that universal functions possess. None of the attributes can be set.</source>
          <target state="translated">通用函数具有一些信息属性。这些属性都是不能设置的。</target>
        </trans-unit>
        <trans-unit id="25b081aeb44044a8abafdf90f986afb1775ac9ea" translate="yes" xml:space="preserve">
          <source>There are sometimes issues reported on Raspberry Pi setups when installing using &lt;code&gt;pip3 install&lt;/code&gt; (or &lt;code&gt;pip&lt;/code&gt; install). These will typically mention:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014e04d63bbb11cf7242b7931500c73711d0520d" translate="yes" xml:space="preserve">
          <source>There are standard variable types for each of the numeric data types and the bool data type. Some of these are already available in the C-specification. You can create variables in extension code with these types.</source>
          <target state="translated">数字数据类型和布尔数据类型都有标准的变量类型。其中一些变量类型已经在C规范中提供。你可以用这些类型在扩展代码中创建变量。</target>
        </trans-unit>
        <trans-unit id="d266f8d3fc00db82d70a1cf8a8ecaaaa80431033" translate="yes" xml:space="preserve">
          <source>There are three independent testing frameworks supported, for one-, two-, and three-dimensional arrays respectively. For one-dimensional arrays, there are two C++ files, a header and a source, named:</source>
          <target state="translated">支持的独立测试框架有三个,分别针对一维、二维和三维数组。对于一维数组,有两个C++文件,一个是头文件,一个是源文件,分别命名为。</target>
        </trans-unit>
        <trans-unit id="a98d06ff6365cb9b94028f7c87529f8503c9281a" translate="yes" xml:space="preserve">
          <source>There are three methods of ufuncs that require calculation similar to the general-purpose ufuncs. These are reduce, accumulate, and reduceat. Each of these methods requires a setup command followed by a loop. There are four loop styles possible for the methods corresponding to no-elements, one-element, strided-loop, and buffered- loop. These are the same basic loop styles as implemented for the general purpose function call except for the no-element and one- element cases which are special-cases occurring when the input array objects have 0 and 1 elements respectively.</source>
          <target state="translated">ufuncs有三种方法需要计算,类似于通用的ufuncs。这三种方法是reduce、accumulate和reduceat。每一种方法都需要一个设置命令,然后是一个循环。有四种可能的循环方式,分别对应于no-elements、one-element、strided-loop和buffered-loop。除了无元素和一元素的情况外,这些基本的循环方式和通用函数调用的基本循环方式是一样的,而无元素和一元素的情况是特殊情况,分别发生在输入数组对象有0和1个元素的时候。</target>
        </trans-unit>
        <trans-unit id="79149af5bd80302b7d9a0d00bba8113083202d98" translate="yes" xml:space="preserve">
          <source>There are three steps to the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d692f23dd01af5033268a8ed1b02fd45c32c1c" translate="yes" xml:space="preserve">
          <source>There are three strategies implemented that can be used to produce repeatable pseudo-random numbers across multiple processes (local or distributed).</source>
          <target state="translated">有三种策略实施,可以用来在多个进程(本地或分布式)中产生可重复的伪随机数。</target>
        </trans-unit>
        <trans-unit id="9dfb3a62923157363de4f21bfcb4cc89da91a3e2" translate="yes" xml:space="preserve">
          <source>There are three use-cases related to memory alignment in numpy (as of 1.14):</source>
          <target state="translated">在numpy中,有三个与内存对齐有关的用例(从1.14开始)。</target>
        </trans-unit>
        <trans-unit id="1878e6ac9e299677e2b59b09c76f88c728c9412d" translate="yes" xml:space="preserve">
          <source>There are times when it is important to visit the elements of an array in a specific order, irrespective of the layout of the elements in memory. The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object provides an &lt;code&gt;order&lt;/code&gt; parameter to control this aspect of iteration. The default, having the behavior described above, is order=&amp;rsquo;K&amp;rsquo; to keep the existing order. This can be overridden with order=&amp;rsquo;C&amp;rsquo; for C order and order=&amp;rsquo;F&amp;rsquo; for Fortran order.</source>
          <target state="translated">在某些时候，重要的是要以特定顺序访问数组的元素，而不管元素在内存中的布局如何。所述&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;对象提供一个 &lt;code&gt;order&lt;/code&gt; 参数来控制迭代的这一方面。具有上述行为的默认值是order ='K'，以保留现有订单。对于C订单，可以使用order ='C'覆盖；对于Fortran订单，可以使用order ='F'覆盖。</target>
        </trans-unit>
        <trans-unit id="8bcb408782f4cab8808f9329f353388438a050d8" translate="yes" xml:space="preserve">
          <source>There are times when it is necessary to treat an array as a different data type than it is stored as. For instance, one may want to do all computations on 64-bit floats, even if the arrays being manipulated are 32-bit floats. Except when writing low-level C code, it&amp;rsquo;s generally better to let the iterator handle the copying or buffering instead of casting the data type yourself in the inner loop.</source>
          <target state="translated">有时，有必要将数组视为不同于存储类型的数据类型。例如，即使要处理的数组是32位浮点数，也可能要对64位浮点数进行所有计算。除了编写低级C代码时，通常最好让迭代器处理复制或缓冲，而不要自己在内部循环中强制转换数据类型。</target>
        </trans-unit>
        <trans-unit id="49296589bf54025f71f98956452ad22438eb00b7" translate="yes" xml:space="preserve">
          <source>There are times when you might want to carry out an operation between an array and a single number (also called &lt;em&gt;an operation between a vector and a scalar&lt;/em&gt;) or between arrays of two different sizes. For example, your array (we&amp;rsquo;ll call it &amp;ldquo;data&amp;rdquo;) might contain information about distance in miles but you want to convert the information to kilometers. You can perform this operation with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52cac18f5846d7a58eabeae3e5d687453dc981d9" translate="yes" xml:space="preserve">
          <source>There are two Timedelta units (&amp;lsquo;Y&amp;rsquo;, years and &amp;lsquo;M&amp;rsquo;, months) which are treated specially, because how much time they represent changes depending on when they are used. While a timedelta day unit is equivalent to 24 hours, there is no way to convert a month unit into days, because different months have different numbers of days.</source>
          <target state="translated">有两个Timedelta单位（&amp;ldquo; Y&amp;rdquo;，年和&amp;ldquo; M&amp;rdquo;，月）被特别处理，因为它们表示多少时间取决于使用时间。尽管timedelta天单位等于24小时，但无法将一个月单位转换为天，因为不同的月份有不同的天数。</target>
        </trans-unit>
        <trans-unit id="47ec50226de8d5ba6a84cfb19309924a297ce7ae" translate="yes" xml:space="preserve">
          <source>There are two aspects to the machinery that ndarray uses to support views and new-from-template in subclasses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced97d88ae2c849acfa28a2cee713cefa36672d2" translate="yes" xml:space="preserve">
          <source>There are two major new types: the ndarray ( &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; ) and the ufunc ( &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt;&lt;code&gt;PyUFunc_Type&lt;/code&gt;&lt;/a&gt; ). Additional types play a supportive role: the &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt;&lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; . The &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt; is the type for a flat iterator for an ndarray (the object that is returned when getting the flat attribute). The &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt;&lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt;&lt;/a&gt; is the type of the object returned when calling &lt;code&gt;broadcast&lt;/code&gt; (). It handles iteration and broadcasting over a collection of nested sequences. Also, the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the data-type-descriptor type whose instances describe the data. Finally, there are 21 new scalar-array types which are new Python scalars corresponding to each of the fundamental data types available for arrays. An additional 10 other types are place holders that allow the array scalars to fit into a hierarchy of actual Python types.</source>
          <target state="translated">有两种主要的新类型：ndarray（&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;）和&lt;a href=&quot;#c.PyUFunc_Type&quot;&gt; &lt;code&gt;PyUFunc_Type&lt;/code&gt; &lt;/a&gt;（PyUFunc_Type）。其他类型起支持作用：&lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt; &lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt;。该&lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; &lt;/a&gt;是用于为ndarray（获取属性平坦时返回的对象）的平坦迭代器类型。所述&lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt; &lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt; &lt;/a&gt;是调用当对象的类型返回 &lt;code&gt;broadcast&lt;/code&gt; （）。它处理嵌套序列的集合上的迭代和广播。另外，&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt;是其实例描述数据的数据类型描述符类型。最后，有21种新的标量数组类型，它们是与数组可用的每种基本数据类型相对应的Python新标量。其他10种类型是占位符，它们允许数组标量适合实际的Python类型的层次结构。</target>
        </trans-unit>
        <trans-unit id="c37fba99ab33d4532607fe9319066dc8a4405878" translate="yes" xml:space="preserve">
          <source>There are two mechanisms which allow this to be done, temporary copies and buffering mode. With temporary copies, a copy of the entire array is made with the new data type, then iteration is done in the copy. Write access is permitted through a mode which updates the original array after all the iteration is complete. The major drawback of temporary copies is that the temporary copy may consume a large amount of memory, particularly if the iteration data type has a larger itemsize than the original one.</source>
          <target state="translated">有两种机制可以做到这一点,临时拷贝和缓冲模式。对于临时拷贝,用新的数据类型对整个数组进行拷贝,然后在拷贝中进行迭代。通过模式允许写访问,在所有迭代完成后更新原始数组。临时拷贝的主要缺点是,临时拷贝可能会消耗大量的内存,特别是当迭代数据类型的项目size比原来的大时。</target>
        </trans-unit>
        <trans-unit id="bbd0e93d84494368770e6b417effb4b358f4babd" translate="yes" xml:space="preserve">
          <source>There are two modes of creating an array using &lt;code&gt;__new__&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;__new__&lt;/code&gt; 创建数组的方式有两种：</target>
        </trans-unit>
        <trans-unit id="e95a2d13ee09be4667ba99a7e23d783a62c61eb8" translate="yes" xml:space="preserve">
          <source>There are two popular ways to flatten an array: &lt;code&gt;.flatten()&lt;/code&gt; and &lt;code&gt;.ravel()&lt;/code&gt;. The primary difference between the two is that the new array created using &lt;code&gt;ravel()&lt;/code&gt; is actually a reference to the parent array (i.e., a &amp;ldquo;view&amp;rdquo;). This means that any changes to the new array will affect the parent array as well. Since &lt;code&gt;ravel&lt;/code&gt; does not create a copy, it&amp;rsquo;s memory efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97769fec67515ece6f805db56bd64883845242d0" translate="yes" xml:space="preserve">
          <source>There are two types of proper-contiguous NumPy arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0373fb682b5018f30be6571b2e08840bdbbdebff" translate="yes" xml:space="preserve">
          <source>There are two ways to capture floating-point error messages. The first is to set the error-handler to &amp;lsquo;call&amp;rsquo;, using &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;. Then, set the function to call using this function.</source>
          <target state="translated">有两种捕获浮点错误消息的方法。首先是使用&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;将错误处理程序设置为&amp;ldquo; call&amp;rdquo; 。然后，将该函数设置为使用此函数进行调用。</target>
        </trans-unit>
        <trans-unit id="7822fba8682a2c5b4fec5101c082332701ec52bb" translate="yes" xml:space="preserve">
          <source>There are two ways to effectively define a new array scalar type (apart from composing structured types &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtypes&lt;/a&gt; from the built-in scalar types): One way is to simply subclass the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and overwrite the methods of interest. This will work to a degree, but internally certain behaviors are fixed by the data type of the array. To fully customize the data type of an array you need to define a new data-type, and register it with NumPy. Such new types can only be defined in C, using the &lt;a href=&quot;c-api#c-api&quot;&gt;NumPy C-API&lt;/a&gt;.</source>
          <target state="translated">有效定义新数组标量类型的方法有两种（除了从内置标量类型构成结构化类型&lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtype&lt;/a&gt;之外）：一种方法是简单地对&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;进行子类化并覆盖感兴趣的方法。这将在一定程度上起作用，但是在内部，某些行为由数组的数据类型固定。要完全自定义数组的数据类型，您需要定义一个新的数据类型，并将其注册到NumPy。此类新类型只能使用&lt;a href=&quot;c-api#c-api&quot;&gt;NumPy C-API&lt;/a&gt;在C中定义。</target>
        </trans-unit>
        <trans-unit id="5c78474a57486cf4a85d9232cd27ee1937bd696d" translate="yes" xml:space="preserve">
          <source>There are two ways to effectively define a new array scalar type (apart from composing structured types &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtypes&lt;/a&gt; from the built-in scalar types): One way is to simply subclass the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and overwrite the methods of interest. This will work to a degree, but internally certain behaviors are fixed by the data type of the array. To fully customize the data type of an array you need to define a new data-type, and register it with NumPy. Such new types can only be defined in C, using the &lt;a href=&quot;c-api/index#c-api&quot;&gt;NumPy C-API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cedb91ab21e9adb6003c75e29f535939f4382660" translate="yes" xml:space="preserve">
          <source>There are two ways to update the source release on PyPI, the first one is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07256ff1dd075c50fc2daea66eb388157aacb269" translate="yes" xml:space="preserve">
          <source>There are two ways to use the interface: A Python side and a C-side. Both are separate attributes.</source>
          <target state="translated">界面的使用有两种方式。一个是Python端,一个是C端。两者都是独立的属性。</target>
        </trans-unit>
        <trans-unit id="b03a9c50082003b4ef01f90e63c960011178dda8" translate="yes" xml:space="preserve">
          <source>There has been no consistent prefix for NumPy public functions, but they all begin with a prefix of some sort, followed by an underscore, and are in camel case: &lt;code&gt;PyArray_DescrAlignConverter&lt;/code&gt;, &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;. In the future the names should be of the form &lt;code&gt;Npy*_PublicFunction&lt;/code&gt;, where the star is something appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dde43af7d13c44f94f0d79c46e9390e7c8216335" translate="yes" xml:space="preserve">
          <source>There is a Python type for each of the different built-in data types that can be present in the array Most of these are simple wrappers around the corresponding data type in C. The C-names for these types are &lt;code&gt;Py{TYPE}ArrType_Type&lt;/code&gt; where &lt;code&gt;{TYPE}&lt;/code&gt; can be</source>
          <target state="translated">数组中可以存在每种不同的内置数据类型的Python类型，其中大多数都是C中对应数据类型的简单包装。这些类型的C名称为 &lt;code&gt;Py{TYPE}ArrType_Type&lt;/code&gt; 其中 &lt;code&gt;{TYPE}&lt;/code&gt; 可以是</target>
        </trans-unit>
        <trans-unit id="07c5411b83a37216eb927b90741cd5630b9b2108" translate="yes" xml:space="preserve">
          <source>There is a clear distinction between element-wise operations and linear algebra operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d05d2bbb1d4347eb1dace6314a1a3b989e2daa" translate="yes" xml:space="preserve">
          <source>There is a fragment for converting a Python integer to a C &lt;code&gt;long&lt;/code&gt;. There is a different fragment that converts a Python integer to a C &lt;code&gt;int&lt;/code&gt;, that calls the routine defined in the &lt;code&gt;long&lt;/code&gt; fragment. We can make the changes we want here by changing the definition for the &lt;code&gt;long&lt;/code&gt; fragment. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; determines the active definition for a fragment using a &amp;ldquo;first come, first served&amp;rdquo; system. That is, we need to define the fragment for &lt;code&gt;long&lt;/code&gt; conversions prior to &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; doing it internally. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; allows us to do this by putting our fragment definitions in the file &lt;code&gt;pyfragments.swg&lt;/code&gt;. If we were to put the new fragment definitions in &lt;code&gt;numpy.i&lt;/code&gt;, they would be ignored.</source>
          <target state="translated">有一个将Python整数转换为C &lt;code&gt;long&lt;/code&gt; 的片段。有一个不同的片段将Python整数转换为C &lt;code&gt;int&lt;/code&gt; ，它调用了 &lt;code&gt;long&lt;/code&gt; 片段中定义的例程。我们可以通过更改 &lt;code&gt;long&lt;/code&gt; 片段的定义来进行所需的更改。&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;使用&amp;ldquo;先到先得&amp;rdquo;系统确定片段的有效定义。也就是说，我们需要先定义片段以进行 &lt;code&gt;long&lt;/code&gt; 转换，然后再在&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;内部进行操作。&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;允许我们通过将片段定义放在 &lt;code&gt;pyfragments.swg&lt;/code&gt; 文件中来执行此操作。如果我们将新的片段定义放在 &lt;code&gt;numpy.i&lt;/code&gt; ，它们将被忽略。</target>
        </trans-unit>
        <trans-unit id="d31593a379a881f2302877c7bf40c8ae65305ffb" translate="yes" xml:space="preserve">
          <source>There is a general need for looping over not only functions on scalars but also over functions on vectors (or arrays). This concept is realized in NumPy by generalizing the universal functions (ufuncs). In regular ufuncs, the elementary function is limited to element-by-element operations, whereas the generalized version (gufuncs) supports &amp;ldquo;sub-array&amp;rdquo; by &amp;ldquo;sub-array&amp;rdquo; operations. The Perl vector library PDL provides a similar functionality and its terms are re-used in the following.</source>
          <target state="translated">通常，不仅需要遍历标量上的函数，还需要遍历矢量（或数组）上的函数。NumPy通过泛化通用函数（ufuncs）来实现此概念。在常规ufunc中，基本功能仅限于逐个元素的操作，而通用版本（gufuncs）通过&amp;ldquo;子数组&amp;rdquo;操作支持&amp;ldquo;子数组&amp;rdquo;。Perl矢量库PDL提供了类似的功能，其术语在下面重新使用。</target>
        </trans-unit>
        <trans-unit id="16ce9fcfde9d0ef11eba9dffd6932b4fb7fe6e10" translate="yes" xml:space="preserve">
          <source>There is a list of enumerated types defined providing the basic 24 data types plus some useful generic names. Whenever the code requires a type number, one of these enumerated types is requested. The types are all called &lt;code&gt;NPY_{NAME}&lt;/code&gt;:</source>
          <target state="translated">定义了一系列枚举类型，提供了24种基本数据类型以及一些有用的通用名称。每当代码需要类型编号时，就会要求使用这些枚举类型之一。这些类型都称为 &lt;code&gt;NPY_{NAME}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fd095b1a939a3168566a681ecc0b30a59e81e682" translate="yes" xml:space="preserve">
          <source>There is a small difference between &lt;a href=&quot;#numpy.ma.masked_array.mini&quot;&gt;&lt;code&gt;mini&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.ma.min#numpy.ma.min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="426d6a71d6ada6c4fe36711b0bf2acc4eb8a1d92" translate="yes" xml:space="preserve">
          <source>There is a subarray but it has exactly one element. This case can be handled as if there is no subarray, but needs some care during setup.</source>
          <target state="translated">有一个子数组,但它只有一个元素。这种情况可以像没有子数组一样处理,但在设置时需要注意。</target>
        </trans-unit>
        <trans-unit id="a1e2cb9284c447866f4fcfbd5e36a19034ca7940" translate="yes" xml:space="preserve">
          <source>There is also a &amp;ldquo;flat&amp;rdquo; in-place array for situations in which you would like to modify or process each element, regardless of the number of dimensions. One example is a &amp;ldquo;quantization&amp;rdquo; function that quantizes each element of an array in-place, be it 1D, 2D or whatever. This form checks for continuity but allows either C or Fortran ordering.</source>
          <target state="translated">还有一个&amp;ldquo;平面&amp;rdquo;原位数组，用于您要修改或处理每个元素的情况，而与维数无关。一个示例是&amp;ldquo;量化&amp;rdquo;功能，该功能可以就地量化数组的每个元素，无论是1D，2D或其他任何元素。此表单检查连续性，但允许使用C或Fortran排序。</target>
        </trans-unit>
        <trans-unit id="42d7ce17e767848814f251a3d945724bdcad4394" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;introductory guide to array iteration&lt;/a&gt; which may be of interest for those using this C API. In many instances, testing out ideas by creating the iterator in Python is a good idea before writing the C iteration code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b73fe8185f285d3a10cd617f08eb8cadb40473" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;arrays.nditer#arrays-nditer&quot;&gt;introductory guide to array iteration&lt;/a&gt; which may be of interest for those using this C API. In many instances, testing out ideas by creating the iterator in Python is a good idea before writing the C iteration code.</source>
          <target state="translated">有一个&lt;a href=&quot;arrays.nditer#arrays-nditer&quot;&gt;数组迭代&lt;/a&gt;的入门指南，对于使用此C API的用户可能会感兴趣。在许多情况下，在编写C迭代代码之前，通过在Python中创建迭代器来测试想法是一个好主意。</target>
        </trans-unit>
        <trans-unit id="606a479ef2292dc711e91c789c67dff3002d3e8e" translate="yes" xml:space="preserve">
          <source>There is an ongoing effort to improve the API. It is important in this effort to ensure that code that compiles for NumPy 1.X continues to compile for NumPy 1.X. At the same time, certain API&amp;rsquo;s will be marked as deprecated so that future-looking code can avoid these API&amp;rsquo;s and follow better practices.</source>
          <target state="translated">正在进行改进API的工作。在此过程中，重要的是要确保为NumPy 1.X编译的代码继续为NumPy 1.X编译。同时，某些API将被标记为已弃用，以便将来使用的代码可以避免使用这些API并遵循更好的做法。</target>
        </trans-unit>
        <trans-unit id="2d9dbfa834497f6482a194ae6bc42d9b31e1c027" translate="yes" xml:space="preserve">
          <source>There is exactly one function that must be defined in your C-code in order for Python to use it as an extension module. The function must be called init{name} where {name} is the name of the module from Python. This function must be declared so that it is visible to code outside of the routine. Besides adding the methods and constants you desire, this subroutine must also contain calls like &lt;code&gt;import_array()&lt;/code&gt; and/or &lt;code&gt;import_ufunc()&lt;/code&gt; depending on which C-API is needed. Forgetting to place these commands will show itself as an ugly segmentation fault (crash) as soon as any C-API subroutine is actually called. It is actually possible to have multiple init{name} functions in a single file in which case multiple modules will be defined by that file. However, there are some tricks to get that to work correctly and it is not covered here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c951415e0655e2f1d542beb400e29df172840589" translate="yes" xml:space="preserve">
          <source>There is more than one definition of sign in common use for complex numbers. The definition used here is equivalent to</source>
          <target state="translated">对于复数,常用的符号定义不止一个。这里使用的定义相当于</target>
        </trans-unit>
        <trans-unit id="81f07ae1e9b8a43b5991326dbec6dd373febf78b" translate="yes" xml:space="preserve">
          <source>There is no need to use &lt;code&gt;intent(c)&lt;/code&gt; for one-dimensional arrays, no matter if the wrapped function is either a Fortran or a C function. This is because the concepts of Fortran- and C contiguity overlap in one-dimensional cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1c5400df70c93e783da6a5dac7fee87f2f1e727" translate="yes" xml:space="preserve">
          <source>There is no standard way in Python distutils to create a standard shared library (an extension module is a &amp;ldquo;special&amp;rdquo; shared library Python understands) in a cross-platform manner. Thus, a big disadvantage of ctypes at the time of writing this book is that it is difficult to distribute in a cross-platform manner a Python extension that uses ctypes and includes your own code which should be compiled as a shared library on the users system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23297908101e96f4ab7052c44ca172ce18526477" translate="yes" xml:space="preserve">
          <source>There is one indexing array and it, as well as the assignment array, can be iterated trivially. For example they may be contiguous. Also the indexing array must be of &lt;code&gt;intp&lt;/code&gt; type and the value array in assignments should be of the correct type. This is purely a fast path.</source>
          <target state="translated">有一个索引数组，它以及赋值数组都可以被简单地迭代。例如，它们可以是连续的。另外，索引数组必须为 &lt;code&gt;intp&lt;/code&gt; 类型，赋值中的值数组应为正确的类型。这纯粹是一条捷径。</target>
        </trans-unit>
        <trans-unit id="d8fac7ab155f3d88da854276783ffad458c19c82" translate="yes" xml:space="preserve">
          <source>There is one notable exception to this behavior: if the optional argument &lt;code&gt;names=True&lt;/code&gt;, the first commented line will be examined for names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df9a641fbd94988d395fb4542afcc38f2bd13355" translate="yes" xml:space="preserve">
          <source>There must be at least 1 argument, and define the last argument as &lt;em&gt;item&lt;/em&gt;. Then, &lt;code&gt;a.itemset(*args)&lt;/code&gt; is equivalent to but faster than &lt;code&gt;a[args] = item&lt;/code&gt;. The item should be a scalar value and &lt;code&gt;args&lt;/code&gt; must select a single item in the array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">必须至少有一个参数，并将最后一个参数定义为&lt;em&gt;item&lt;/em&gt;。然后， &lt;code&gt;a.itemset(*args)&lt;/code&gt; 等同于但比 &lt;code&gt;a[args] = item&lt;/code&gt; 更快。该项目应为标量值，并且 &lt;code&gt;args&lt;/code&gt; 必须在数组 &lt;code&gt;a&lt;/code&gt; 中选择一个项目。</target>
        </trans-unit>
        <trans-unit id="bc33808ec0ca031cf8b9c1fdd7c9278c78f0db38" translate="yes" xml:space="preserve">
          <source>There was no __array_interface__ attribute instead all of the keys (except for version) in the __array_interface__ dictionary were their own attribute: Thus to obtain the Python-side information you had to access separately the attributes:</source>
          <target state="translated">没有__array_interface__属性,相反,__array_interface__字典中的所有键(除了版本)都是它们自己的属性。因此,为了获得Python方面的信息,你必须分别访问这些属性。</target>
        </trans-unit>
        <trans-unit id="1d3ca63c0d0c4fb92d45d132b89354f4e2a0e2fc" translate="yes" xml:space="preserve">
          <source>There will not be anything &lt;em&gt;wrong&lt;/em&gt; with the results, per se; even a seed of 0 is perfectly fine thanks to the processing that &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; does. If you just need &lt;em&gt;some&lt;/em&gt; fixed value for unit tests or debugging, feel free to use whatever seed you like. But if you want to make inferences from the results or publish them, drawing from a larger set of seeds is good practice.</source>
          <target state="translated">结果本身不会有任何&lt;em&gt;问题&lt;/em&gt;。由于&lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;的处理，即使是0的种子也非常好。如果您只需要&lt;em&gt;一些&lt;/em&gt;固定值用于单元测试或调试，请随时使用所需的任何种子。但是，如果您想根据结果进行推断或将其发布，则从大量种子中提取是一种很好的做法。</target>
        </trans-unit>
        <trans-unit id="1a33a5d0a80b8b553aad5ef6b8b9d3cf3a744293" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s an embarrassing typo in a commit you made? Or perhaps the you made several false starts you would like the posterity not to see.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5a5e9111615649ff06d77b214a9aa4744c2e9e" translate="yes" xml:space="preserve">
          <source>These Boolean-valued flags affect how numpy interprets the memory area used by &lt;code&gt;a&lt;/code&gt; (see Notes below). The ALIGNED flag can only be set to True if the data is actually aligned according to the type. The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set to True. The flag WRITEABLE can only be set to True if the array owns its own memory, or the ultimate owner of the memory exposes a writeable buffer interface, or is a string. (The exception for string is made so that unpickling can be done without copying memory.)</source>
          <target state="translated">这些布尔值标志影响numpy解释 &lt;code&gt;a&lt;/code&gt; 使用的内存区域的方式（请参见下面的注释）。如果数据实际上根据类型对齐，则ALIGNED标志只能设置为True。 WRITEBACKIFCOPY和（不建议使用）UPDATEIFCOPY标志永远不能设置为True。如果数组拥有自己的内存，或者内存的最终所有者公开了可写的缓冲区接口，或者为字符串，则只能将标志WRITEABLE设置为True。 （对string进行了例外处理，因此可以在不复制内存的情况下进行解腌。）</target>
        </trans-unit>
        <trans-unit id="a6788920c31464c6803c23f30203598688f71c50" translate="yes" xml:space="preserve">
          <source>These additional dependencies for building the documentation are listed in &lt;code&gt;doc_requirements.txt&lt;/code&gt; and can be conveniently installed with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7faf38a4c03dd7b8b5f6a940a17e52f4253526ca" translate="yes" xml:space="preserve">
          <source>These all achieve the same result:</source>
          <target state="translated">这些都能达到同样的效果。</target>
        </trans-unit>
        <trans-unit id="ca33633bc8f8738d475e05fabdb7eda73e305c81" translate="yes" xml:space="preserve">
          <source>These are defined for &lt;code&gt;{bits}&lt;/code&gt; = 8, 16, 32, 64, 128, and 256 and provide the maximum (minimum) value of the corresponding (unsigned) integer type. Note: the actual integer type may not be available on all platforms (i.e. 128-bit and 256-bit integers are rare).</source>
          <target state="translated">它们是针对 &lt;code&gt;{bits}&lt;/code&gt; = 8、16、32、64、128和256定义的，并提供了相应（无符号）整数类型的最大值（最小值）。注意：实际的整数类型可能并非在所有平台上都可用（即，很少使用128位和256位整数）。</target>
        </trans-unit>
        <trans-unit id="8ddb00a13475a7300c7d1510545ce91de444184f" translate="yes" xml:space="preserve">
          <source>These are enhanced arrays of either &lt;code&gt;string_&lt;/code&gt; type or &lt;code&gt;unicode_&lt;/code&gt; type. These arrays inherit from the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, but specially-define the operations &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt; on a (broadcasting) element-by-element basis. These operations are not available on the standard &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; of character type. In addition, the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; has all of the standard &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; (and &lt;code&gt;unicode&lt;/code&gt;) methods, executing them on an element-by-element basis. Perhaps the easiest way to create a chararray is to use &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;self.view(chararray)&lt;/code&gt;&lt;/a&gt; where &lt;em&gt;self&lt;/em&gt; is an ndarray of str or unicode data-type. However, a chararray can also be created using the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;numpy.chararray&lt;/code&gt;&lt;/a&gt; constructor, or via the &lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt;&lt;code&gt;numpy.char.array&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">这些是 &lt;code&gt;string_&lt;/code&gt; 类型或 &lt;code&gt;unicode_&lt;/code&gt; 类型的增强数组。这些数组继承自&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;，但是在逐个元素的基础上特别定义了 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt; 操作。这些操作在字符类型的标准&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;上不可用。另外，&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;具有所有标准&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt;（和 &lt;code&gt;unicode&lt;/code&gt; ）方法，它们在逐个元素的基础上执行。创建chararray的最简单方法可能是使用&lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;self.view(chararray)&lt;/code&gt; &lt;/a&gt;，其中&lt;em&gt;self&lt;/em&gt;是str或unicode数据类型的ndarray。但是，也可以使用&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;numpy.chararray&lt;/code&gt; &lt;/a&gt;构造函数或通过&lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt; &lt;code&gt;numpy.char.array&lt;/code&gt; &lt;/a&gt;函数创建chararray：</target>
        </trans-unit>
        <trans-unit id="5c5d09f4ce60946e76740852fd56ca7c8c49e5bd" translate="yes" xml:space="preserve">
          <source>These are roughly ordered from least-to-most precision.</source>
          <target state="translated">这些大致是由最少到最精确的顺序。</target>
        </trans-unit>
        <trans-unit id="2ce5765c6141294e2d5121321badaf2a8b57c10d" translate="yes" xml:space="preserve">
          <source>These are some detailed notes, which are not of importance for day to day indexing (in no particular order):</source>
          <target state="translated">这些都是一些详细的注意事项,对于日常的索引并不重要(排名不分先后)。</target>
        </trans-unit>
        <trans-unit id="3f20305498e715f2e7a95c2c0aa48306a2b1d79a" translate="yes" xml:space="preserve">
          <source>These are the arrays for the operation.</source>
          <target state="translated">这些是操作的数组。</target>
        </trans-unit>
        <trans-unit id="7a1ac004102d237171aefc6abd621531cd490cc4" translate="yes" xml:space="preserve">
          <source>These are the constants and functions for accessing the ufunc C-API from extension modules in precisely the same way as the array C-API can be accessed. The &lt;code&gt;import_ufunc&lt;/code&gt; () function must always be called (in the initialization subroutine of the extension module). If your extension module is in one file then that is all that is required. The other two constants are useful if your extension module makes use of multiple files. In that case, define &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to something unique to your code and then in source files that do not contain the module initialization function but still need access to the UFUNC API, define &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to the same name used previously and also define &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt;&lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这些是用于以与访问数组C-API完全相同的方式从扩展模块访问ufunc C-API的常量和函数。该 &lt;code&gt;import_ufunc&lt;/code&gt; （）函数必须始终（在扩展模块的初始化子程序）被调用。如果您的扩展模块在一个文件中，则仅需这些。如果扩展模块使用多个文件，则其他两个常量很有用。在这种情况下，定义&lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt;以独特的代码，然后在不包含模块初始化函数，但到UFUNC API仍需要访问，定义源文件的东西&lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt;同名以前用过，也定义&lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt; &lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0aaea1e5f2c4b6d0e0dc28a8aa40e102fa58beb" translate="yes" xml:space="preserve">
          <source>These are the indices that would allow you to access the upper triangular part of any 3x3 array:</source>
          <target state="translated">这些是允许你访问任何3x3数组的上三角部分的索引。</target>
        </trans-unit>
        <trans-unit id="38bc2b8e25d17f4fb4231aea381549f2e431c561" translate="yes" xml:space="preserve">
          <source>These are the instructions if you just want to follow the latest &lt;em&gt;NumPy&lt;/em&gt; source, but you don&amp;rsquo;t need to do any development for now. If you do want to contribute a patch (excellent!) or do more extensive NumPy development, see &lt;a href=&quot;../development_workflow#development-workflow&quot;&gt;Development workflow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43efdc6f451764645e6025c80a5a83f304f68569" translate="yes" xml:space="preserve">
          <source>These are typically used in situations where in C/C++, you would allocate a(n) array(s) on the heap, and call the function to fill the array(s) values. In Python, the arrays are allocated for you and returned as new array objects.</source>
          <target state="translated">这些函数通常用于在 C/C++中,在堆上分配一个(n)数组,然后调用函数来填充数组的值。在 Python 中,数组是为你分配的,并作为新的数组对象返回。</target>
        </trans-unit>
        <trans-unit id="f04a7bcc6ce293328ac2b1079d0f95ad7b19da67" translate="yes" xml:space="preserve">
          <source>These are written in doctest format, and should illustrate how to use the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93c5dc49de55891886f179425b788a1c6ad1b35" translate="yes" xml:space="preserve">
          <source>These arrays are views on the original arrays. They are typically not contiguous. Furthermore, more than one element of a broadcasted array may refer to a single memory location. If you need to write to the arrays, make copies first. While you can set the &lt;code&gt;writable&lt;/code&gt; flag True, writing to a single output value may end up changing more than one location in the output array.</source>
          <target state="translated">这些阵列是原始阵列的视图。它们通常不连续。此外，广播阵列中的一个以上元素可以引用单个存储位置。如果需要写入阵列，请先进行复制。虽然可以将 &lt;code&gt;writable&lt;/code&gt; 标志设置为True，但是写入单个输出值可能最终会更改输出数组中的多个位置。</target>
        </trans-unit>
        <trans-unit id="95e5069d3636251c2ff01dcc947b04bbf8ba1923" translate="yes" xml:space="preserve">
          <source>These behaviors can be set for all kinds of errors or specific ones:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f0acac4ec85b4b4bd7ae1e0ff5a3f9603fcfbc3" translate="yes" xml:space="preserve">
          <source>These constants are used in &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; (and its macro forms) to specify desired properties of the new array.</source>
          <target state="translated">这些常量在&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;（及其宏格式）中用于指定新数组的所需属性。</target>
        </trans-unit>
        <trans-unit id="3d245bb5214c903868626d468b5ef8607e3f9a4a" translate="yes" xml:space="preserve">
          <source>These cover almost the whole array (two diagonals right of the main one):</source>
          <target state="translated">这些几乎覆盖了整个阵列(主阵列右边的两个对角线)。</target>
        </trans-unit>
        <trans-unit id="f7e900132de2199b00f5d74615e0a1848ce14490" translate="yes" xml:space="preserve">
          <source>These cover only a small part of the whole array (two diagonals right of the main one):</source>
          <target state="translated">这些只覆盖整个阵列的一小部分(主阵列右边的两个对角线)。</target>
        </trans-unit>
        <trans-unit id="1adc6f5a53325e3aa2e7cccdff9469027b73b4ce" translate="yes" xml:space="preserve">
          <source>These documents are intended as an introductory overview of NumPy and its features. For detailed reference documentation of the functions and classes contained in the package, see the &lt;a href=&quot;../reference/index#reference&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca02dca00e56b01dd5323ec3c2c51c9bba04e9a2" translate="yes" xml:space="preserve">
          <source>These documents are intended as recipes to common tasks using NumPy. For detailed reference documentation of the functions and classes contained in the package, see the &lt;a href=&quot;../reference/index#reference&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1b854bfa000aee75512c8df139be2e2841e0fd" translate="yes" xml:space="preserve">
          <source>These documents are intended to explain in detail the concepts and techniques used in NumPy. For the reference documentation of the functions and classes contained in the package, see the &lt;a href=&quot;../reference/index#reference&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63868acfbf699fe963e728a55308e7d3a9b22eb9" translate="yes" xml:space="preserve">
          <source>These examples illustrate the low-level &lt;a href=&quot;#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; constructor. Refer to the &lt;code&gt;See Also&lt;/code&gt; section above for easier ways of constructing an ndarray.</source>
          <target state="translated">这些示例说明了低级&lt;a href=&quot;#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;构造函数。 &lt;code&gt;See Also&lt;/code&gt; 构造ndarray的更简便方法，请参阅上面的&amp;ldquo; 另请参见&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="8a348b17d2fb1b33a90b7baa8a557d9af808a018" translate="yes" xml:space="preserve">
          <source>These function all require integer arguments and they manipulate the bit-pattern of those arguments.</source>
          <target state="translated">这些函数都需要整数参数,并对这些参数的位型进行操作。</target>
        </trans-unit>
        <trans-unit id="d7e647d09c10f9f4521e851e5661f2624622c65e" translate="yes" xml:space="preserve">
          <source>These functions along with a minimal setup file are included in the examples folder.</source>
          <target state="translated">这些功能和一个最小的设置文件都包含在例子文件夹中。</target>
        </trans-unit>
        <trans-unit id="47c8ad5dd0ea816b255a3666826ae66a37ff3a15" translate="yes" xml:space="preserve">
          <source>These functions and macros provide easy access to elements of the ndarray from C. These work for all arrays. You may need to take care when accessing the data in the array, however, if it is not in machine byte-order, misaligned, or not writeable. In other words, be sure to respect the state of the flags unless you know what you are doing, or have previously guaranteed an array that is writeable, aligned, and in machine byte-order using &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt;. If you wish to handle all types of arrays, the copyswap function for each type is useful for handling misbehaved arrays. Some platforms (e.g. Solaris) do not like misaligned data and will crash if you de-reference a misaligned pointer. Other platforms (e.g. x86 Linux) will just work more slowly with misaligned data.</source>
          <target state="translated">这些函数和宏使您可以轻松地从C访问ndarray的元素。它们适用于所有数组。但是，如果访问数组中的数据不是机器字节顺序，未对齐或不可写，则可能需要小心。换句话说，除非您知道自己在做什么，否则请确保尊重标记的状态，或者使用&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;先前已保证可写，对齐且以机器字节顺序排列的数组。如果要处理所有类型的数组，则每种类型的copyswap函数对于处理行为异常的数组很有用。某些平台（例如Solaris）不喜欢未对齐的数据，如果取消引用未对齐的指针，则会崩溃。其他平台（例如x86 Linux）对未对齐的数据的处理只会更慢。</target>
        </trans-unit>
        <trans-unit id="a0b164307df93568d43c0a9ad269b4dbe393e0e6" translate="yes" xml:space="preserve">
          <source>These functions are included here because they are used at least once in the array object&amp;rsquo;s methods. The function returns -1 (without setting a Python Error) if one of the objects being assigned is not callable.</source>
          <target state="translated">之所以包含这些函数，是因为它们在数组对象的方法中至少使用了一次。如果分配的对象之一不可调用，则该函数返回-1（未设置Python错误）。</target>
        </trans-unit>
        <trans-unit id="8de7e7b6b1e1ede303832d725868059c022d2d0a" translate="yes" xml:space="preserve">
          <source>These functions are very similar to functions without keyword arguments. The only difference is that the function signature is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474e0e7c22745c37837977d2aed3d481ae32dc24" translate="yes" xml:space="preserve">
          <source>These identities allow a Chebyshev series to be expressed as a finite, symmetric Laurent series. In this module, this sort of Laurent series is referred to as a &amp;ldquo;z-series.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a58240a1702d16b3630637ee0890f803946e53fd" translate="yes" xml:space="preserve">
          <source>These macros access the &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure members and are defined in &lt;code&gt;ndarraytypes.h&lt;/code&gt;. The input argument, &lt;em&gt;arr&lt;/em&gt;, can be any &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that is directly interpretable as a &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; (any instance of the &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and itssub-types).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13b269cced89ab6392bc06c8030f96e4b737c057" translate="yes" xml:space="preserve">
          <source>These macros all access the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure members. The input argument, arr, can be any &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that is directly interpretable as a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; (any instance of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and its sub-types).</source>
          <target state="translated">这些宏都访问&lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;结构成员。输入参数，ARR，可以是任何&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt;是作为一个直接可解释&lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt;（的任何实例&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;及其子类型）。</target>
        </trans-unit>
        <trans-unit id="0b21dcbffd2b61b3d3ee30959d3bc33fc08a9c74" translate="yes" xml:space="preserve">
          <source>These macros are only meaningful if &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; evaluates True during compilation of the extension module. Otherwise, these macros are equivalent to whitespace. Python uses a single Global Interpreter Lock (GIL) for each Python process so that only a single thread may execute at a time (even on multi-cpu machines). When calling out to a compiled function that may take time to compute (and does not have side-effects for other threads like updated global variables), the GIL should be released so that other Python threads can run while the time-consuming calculations are performed. This can be accomplished using two groups of macros. Typically, if one macro in a group is used in a code block, all of them must be used in the same code block. Currently, &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined to the python-defined &lt;code&gt;WITH_THREADS&lt;/code&gt; constant unless the environment variable &lt;code&gt;NPY_NOSMP&lt;/code&gt; is set in which case &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined to be 0.</source>
          <target state="translated">仅当 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 在扩展模块的编译期间评估为True时，这些宏才有意义。否则，这些宏等效于空白。 Python为每个Python进程使用一个全局解释器锁（GIL），以便一次只能执行一个线程（即使在多cpu机器上）。当调用可能花费时间进行计算的已编译函数（并且对其他线程（如更新的全局变量）没有副作用）时，应释放GIL，以便其他Python线程可以在执行耗时的计算时运行。这可以使用两组宏来完成。通常，如果在代码块中使用了组中的一个宏，则所有宏都必须在同一代码块中使用。目前， &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 除非已设置环境变量 &lt;code&gt;NPY_NOSMP&lt;/code&gt; ，在这种情况下 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 定义为0，否则将定义为python定义的 &lt;code&gt;WITH_THREADS&lt;/code&gt; 常量。</target>
        </trans-unit>
        <trans-unit id="da2fff533a172874c502697494e5cdbf3a7c39b3" translate="yes" xml:space="preserve">
          <source>These macros use different memory allocators, depending on the constant &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt;. The system malloc is used when &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; is 0, if &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; is 1, then the Python memory allocator is used.</source>
          <target state="translated">这些宏使用不同的内存分配器，具体取决于常量 &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; 。当 &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; 为0 时使用系统malloc ，如果 &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; 为1，则使用Python内存分配器。</target>
        </trans-unit>
        <trans-unit id="512de4565bde2a4a800d6eb7f4ecd21ece637307" translate="yes" xml:space="preserve">
          <source>These members are both pointers to functions to copy data from &lt;em&gt;src&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;swap&lt;/em&gt; if indicated. The value of arr is only used for flexible ( &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ) arrays (and is obtained from &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; ). The second function copies a single value, while the first loops over n values with the provided strides. These functions can deal with misbehaved &lt;em&gt;src&lt;/em&gt; data. If &lt;em&gt;src&lt;/em&gt; is NULL then no copy is performed. If &lt;em&gt;swap&lt;/em&gt; is 0, then no byteswapping occurs. It is assumed that &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;src&lt;/em&gt; do not overlap. If they overlap, then use &lt;code&gt;memmove&lt;/code&gt; (&amp;hellip;) first followed by &lt;code&gt;copyswap(n)&lt;/code&gt; with NULL valued &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">这些成员都是指向将数据从&lt;em&gt;src&lt;/em&gt;复制到&lt;em&gt;dest&lt;/em&gt;并在需要时&lt;em&gt;交换的&lt;/em&gt;函数的指针。 arr的值仅用于灵活的（&lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt; &lt;code&gt;NPY_STRING&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt; &lt;code&gt;NPY_UNICODE&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt; &lt;code&gt;NPY_VOID&lt;/code&gt; &lt;/a&gt;）数组（从 &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; 获得）。第二个函数复制单个值，而第一个函数以提供的步幅循环n个值。这些功能可以处理行为异常的&lt;em&gt;src&lt;/em&gt;数据。如果&lt;em&gt;src&lt;/em&gt;为NULL，则不执行任何复制。如果&lt;em&gt;swap&lt;/em&gt;为0，则不会发生字节&lt;em&gt;交换&lt;/em&gt;。假设&lt;em&gt;dest&lt;/em&gt;和&lt;em&gt;src&lt;/em&gt;不要重叠。如果它们重叠，则首先使用 &lt;code&gt;memmove&lt;/code&gt; （...），然后使用NULL值为 &lt;code&gt;src&lt;/code&gt; 的 &lt;code&gt;copyswap(n)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a72dfa72e903b9f6c19523d338aa7b21c3b5f83" translate="yes" xml:space="preserve">
          <source>These members are both pointers to functions to copy data from &lt;em&gt;src&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;swap&lt;/em&gt; if indicated. The value of arr is only used for flexible ( &lt;a href=&quot;dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ) arrays (and is obtained from &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; ). The second function copies a single value, while the first loops over n values with the provided strides. These functions can deal with misbehaved &lt;em&gt;src&lt;/em&gt; data. If &lt;em&gt;src&lt;/em&gt; is NULL then no copy is performed. If &lt;em&gt;swap&lt;/em&gt; is 0, then no byteswapping occurs. It is assumed that &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;src&lt;/em&gt; do not overlap. If they overlap, then use &lt;code&gt;memmove&lt;/code&gt; (&amp;hellip;) first followed by &lt;code&gt;copyswap(n)&lt;/code&gt; with NULL valued &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6721252244f80ca68ee960086197a2ea6f31616" translate="yes" xml:space="preserve">
          <source>These numbers in the previous line represent (0, 0) to machine precision</source>
          <target state="translated">前面一行的数字代表(0,0)到机器的精度。</target>
        </trans-unit>
        <trans-unit id="dc06d74801540c694b86fd1603123c1d29a31d44" translate="yes" xml:space="preserve">
          <source>These options determine the way floating point numbers, arrays and other NumPy objects are displayed.</source>
          <target state="translated">这些选项决定了浮点数字、数组和其他NumPy对象的显示方式。</target>
        </trans-unit>
        <trans-unit id="c7caafe15667a4da0d6093971259ebc7a46a9f78" translate="yes" xml:space="preserve">
          <source>These pages describe a general &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; and &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; workflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df150acba8d3f0417e81ddcccc29e42e2e807db8" translate="yes" xml:space="preserve">
          <source>These paths both use the same machinery. We make the distinction here, because they result in different input to your methods. Specifically, &lt;a href=&quot;#view-casting&quot;&gt;View casting&lt;/a&gt; means you have created a new instance of your array type from any potential subclass of ndarray. &lt;a href=&quot;#new-from-template&quot;&gt;Creating new from template&lt;/a&gt; means you have created a new instance of your class from a pre-existing instance, allowing you - for example - to copy across attributes that are particular to your subclass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcba0fcabfaea90dcbb4dedc9f83dbe704fc9440" translate="yes" xml:space="preserve">
          <source>These pointers are different from the pointers accepted by &lt;code&gt;NpyIter_ResetBasePointers&lt;/code&gt;, because the direction along some axes may have been reversed.</source>
          <target state="translated">这些指针与 &lt;code&gt;NpyIter_ResetBasePointers&lt;/code&gt; 接受的指针不同，因为沿某些轴的方向可能已反转。</target>
        </trans-unit>
        <trans-unit id="2936192ef68f1082cb1baded7a4cc1332510cdca" translate="yes" xml:space="preserve">
          <source>These properties together mean that we can safely mix together the usual user-provided seed with simple incrementing counters to get &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; states that are (to very high probability) independent of each other. We can wrap this together into an API that is easy to use and difficult to misuse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a8a14f212cc60aa00fe9447268d1975d32ef40" translate="yes" xml:space="preserve">
          <source>These properties together mean that we can safely mix together the usual user-provided seed with simple incrementing counters to get &lt;code&gt;BitGenerator&lt;/code&gt; states that are (to very high probability) independent of each other. We can wrap this together into an API that is easy to use and difficult to misuse.</source>
          <target state="translated">这些属性共同意味着我们可以安全地将用户提供的常规种子与简单的递增计数器安全地混合在一起，以获得（非常有可能）彼此独立的 &lt;code&gt;BitGenerator&lt;/code&gt; 状态。我们可以将它们包装到一个易于使用且难以滥用的API中。</target>
        </trans-unit>
        <trans-unit id="a6a12c973c6b3912e3652bb2e3ed402ca4234700" translate="yes" xml:space="preserve">
          <source>These tools have been found useful by others using Python and so are included here. They are discussed separately because they are either older ways to do things now handled by f2py, Cython, or ctypes (SWIG, PyFort) or because I don&amp;rsquo;t know much about them (SIP, Boost). I have not added links to these methods because my experience is that you can find the most relevant link faster using Google or some other search engine, and any links provided here would be quickly dated. Do not assume that just because it is included in this list, I don&amp;rsquo;t think the package deserves your attention. I&amp;rsquo;m including information about these packages because many people have found them useful and I&amp;rsquo;d like to give you as many options as possible for tackling the problem of easily integrating your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0fbc806872e828602fd0c760ad7240ac769262d" translate="yes" xml:space="preserve">
          <source>These two macros are similar and obtain the pointer to the data-buffer for the array. The first macro can (and should be) assigned to a particular pointer where the second is for generic processing. If you have not guaranteed a contiguous and/or aligned array then be sure you understand how to access the data in the array to avoid memory and/or alignment problems.</source>
          <target state="translated">这两个宏类似于获取数组数据缓冲区的指针。第一个宏可以(也应该)分配给一个特定的指针,第二个宏用于通用处理。如果你没有保证一个连续的和/或对齐的数组,那么请确保你了解如何访问数组中的数据以避免内存和/或对齐问题。</target>
        </trans-unit>
        <trans-unit id="e28f8dd7e1d385fa1bfc87cb75abfbb7c4a8ade7" translate="yes" xml:space="preserve">
          <source>These type names are part of the C-API and can therefore be created in extension C-code. There is also a &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; and a &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; that are simple substitutes for one of the integer types that can hold a pointer on the platform. The structure of these scalar objects is not exposed to C-code. The function &lt;a href=&quot;array#c.PyArray_ScalarAsCtype&quot;&gt;&lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt;&lt;/a&gt; (..) can be used to extract the C-type value from the array scalar and the function &lt;a href=&quot;array#c.PyArray_Scalar&quot;&gt;&lt;code&gt;PyArray_Scalar&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to construct an array scalar from a C-value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4a900566749a67d476933d0258a41ade60543e" translate="yes" xml:space="preserve">
          <source>These type names are part of the C-API and can therefore be created in extension C-code. There is also a &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; and a &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; that are simple substitutes for one of the integer types that can hold a pointer on the platform. The structure of these scalar objects is not exposed to C-code. The function &lt;a href=&quot;c-api.array#c.PyArray_ScalarAsCtype&quot;&gt;&lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt;&lt;/a&gt; (..) can be used to extract the C-type value from the array scalar and the function &lt;a href=&quot;c-api.array#c.PyArray_Scalar&quot;&gt;&lt;code&gt;PyArray_Scalar&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to construct an array scalar from a C-value.</source>
          <target state="translated">这些类型名称是C-API的一部分，因此可以在扩展C代码中创建。还有一个 &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; 和 &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; ，它们可以简单地替代可以在平台上保存指针的整数类型之一。这些标量对象的结构不暴露于C代码。函数&lt;a href=&quot;c-api.array#c.PyArray_ScalarAsCtype&quot;&gt; &lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt; &lt;/a&gt;（..）可用于从数组标量中提取C类型的值，函数&lt;a href=&quot;c-api.array#c.PyArray_Scalar&quot;&gt; &lt;code&gt;PyArray_Scalar&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）可用于从C值构造数组中的标量。</target>
        </trans-unit>
        <trans-unit id="39c33e43ad465d1114668c2913272d120aead183" translate="yes" xml:space="preserve">
          <source>These typemaps now check to make sure that the &lt;code&gt;INPLACE_ARRAY&lt;/code&gt; arguments use native byte ordering. If not, an exception is raised.</source>
          <target state="translated">现在，这些类型映射检查以确保 &lt;code&gt;INPLACE_ARRAY&lt;/code&gt; 参数使用本机字节顺序。如果不是，则引发异常。</target>
        </trans-unit>
        <trans-unit id="afffd3e5751f118e6c4a8e5fa416a0de7397d2ff" translate="yes" xml:space="preserve">
          <source>These values are appended to a copy of &lt;code&gt;a&lt;/code&gt;. It must be of the correct shape (the same shape as &lt;code&gt;a&lt;/code&gt;, excluding &lt;code&gt;axis&lt;/code&gt;). If &lt;code&gt;axis&lt;/code&gt; is not specified, &lt;code&gt;b&lt;/code&gt; can be any shape and will be flattened before use.</source>
          <target state="translated">这些值附加的副本 &lt;code&gt;a&lt;/code&gt; 。它必须是正确的形状（相同的形状的 &lt;code&gt;a&lt;/code&gt; ，不包括 &lt;code&gt;axis&lt;/code&gt; ）。如果未指定 &lt;code&gt;axis&lt;/code&gt; ，则 &lt;code&gt;b&lt;/code&gt; 可以是任何形状，并且在使用前将被展平。</target>
        </trans-unit>
        <trans-unit id="612fafedc61071a5e61db03c65c0f553ab91df63" translate="yes" xml:space="preserve">
          <source>These values are appended to a copy of &lt;code&gt;arr&lt;/code&gt;. It must be of the correct shape (the same shape as &lt;code&gt;arr&lt;/code&gt;, excluding &lt;code&gt;axis&lt;/code&gt;). If &lt;code&gt;axis&lt;/code&gt; is not specified, &lt;code&gt;values&lt;/code&gt; can be any shape and will be flattened before use.</source>
          <target state="translated">这些值将附加到 &lt;code&gt;arr&lt;/code&gt; 的副本中。它必须具有正确的形状（与 &lt;code&gt;arr&lt;/code&gt; 相同的形状，但 &lt;code&gt;axis&lt;/code&gt; 除外）。如果未指定 &lt;code&gt;axis&lt;/code&gt; ，则 &lt;code&gt;values&lt;/code&gt; 可以是任何形状，并且在使用前将被展平。</target>
        </trans-unit>
        <trans-unit id="c265d10397c2203b05e143772f5cfb33ffa2cf8c" translate="yes" xml:space="preserve">
          <source>These values are only returned if &lt;code&gt;full&lt;/code&gt; = True</source>
          <target state="translated">仅当 &lt;code&gt;full&lt;/code&gt; = True 时才返回这些值</target>
        </trans-unit>
        <trans-unit id="94c85fa0224cf9a04b1b6ccf08fcebfe46c06507" translate="yes" xml:space="preserve">
          <source>These values will be element-wise interpolated into the string.</source>
          <target state="translated">这些值将被逐个元素插值到字符串中。</target>
        </trans-unit>
        <trans-unit id="8f43e0b4384b8a2ab0accbd750c1e3d8364a7037" translate="yes" xml:space="preserve">
          <source>They are the standard vector/matrix/tensor type of numpy. Many numpy functions return arrays, not matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d528fd04772fea95a1dd88b443f26490baf33962" translate="yes" xml:space="preserve">
          <source>Things are a little bit more tricky when combining reduction and allocated operands. Before iteration is started, any reduction operand must be initialized to its starting values. Here&amp;rsquo;s how we can do this, taking sums along the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">当组合归约操作数和分配的操作数时，事情要复杂一些。在开始迭代之前，必须将任何归约操作数初始化为其初始值。沿a的最后一个轴求和 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d8c3ebfdc398f463f36600d7ef80c9d888a357d" translate="yes" xml:space="preserve">
          <source>Things become more complex when multidimensional arrays are indexed, particularly with multidimensional index arrays. These tend to be more unusual uses, but they are permitted, and they are useful for some problems. We&amp;rsquo;ll start with the simplest multidimensional case (using the array y from the previous examples):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="998943208ea6deef89245cfe0875a67c35f9b773" translate="yes" xml:space="preserve">
          <source>Think of &lt;a href=&quot;#numpy.linalg.multi_dot&quot;&gt;&lt;code&gt;multi_dot&lt;/code&gt;&lt;/a&gt; as:</source>
          <target state="translated">将&lt;a href=&quot;#numpy.linalg.multi_dot&quot;&gt; &lt;code&gt;multi_dot&lt;/code&gt; &lt;/a&gt;视为：</target>
        </trans-unit>
        <trans-unit id="80d13b605601d6c6ca920c19b73c5be17b635404" translate="yes" xml:space="preserve">
          <source>This 2-d averaging filter runs quickly because the loop is in C and the pointer computations are done only as needed. If the code above is compiled as a module &lt;code&gt;image&lt;/code&gt;, then a 2-d image, &lt;code&gt;img&lt;/code&gt;, can be filtered using this code very quickly using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269959a51cb8489ddd62f29ffab3f7d5a6b40d53" translate="yes" xml:space="preserve">
          <source>This Chapter attempts to explain the logic behind some of the new pieces of code. The purpose behind these explanations is to enable somebody to be able to understand the ideas behind the implementation somewhat more easily than just staring at the code. Perhaps in this way, the algorithms can be improved on, borrowed from, and/or optimized by more people.</source>
          <target state="translated">本章试图解释一些新代码背后的逻辑。这些解释背后的目的是为了让人能够更容易理解实现背后的思想,而不是仅仅盯着代码看。也许通过这种方式,算法可以被更多人改进、借鉴和/或优化。</target>
        </trans-unit>
        <trans-unit id="d6d4a7a2f523794d0b16e4b9b049698c812e64fd" translate="yes" xml:space="preserve">
          <source>This Subcommittee shall NOT make decisions about the direction, scope or technical direction of the Project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e344df267f24877e3c878787dee0c7157b282950" translate="yes" xml:space="preserve">
          <source>This Subcommittee will have 5 members, 4 of whom will be current Council Members and 1 of whom will be external to the Steering Council. No more than 2 Subcommittee Members can report to one person through employment or contracting work (including the reportee, i.e. the reportee + 1 is the max). This avoids effective majorities resting on one person.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8eb7804ceb212518c04178ca9353c5652cddc34" translate="yes" xml:space="preserve">
          <source>This address may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it. The value itself may change during iteration, in particular if buffering is enabled. This function may be safely called without holding the Python GIL.</source>
          <target state="translated">该地址可能在迭代循环之前被缓存，调用 &lt;code&gt;iternext&lt;/code&gt; 不会更改它。该值本身在迭代过程中可能会更改，特别是如果启用了缓冲。无需持有Python GIL即可安全地调用此函数。</target>
        </trans-unit>
        <trans-unit id="2dacb6ef0aabe4e0449ac2f7d6e826edb424af8c" translate="yes" xml:space="preserve">
          <source>This advanced indexing occurs when obj is an array object of Boolean type, such as may be returned from comparison operators. A single boolean index array is practically identical to &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; where, as described above, &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;obj.nonzero()&lt;/code&gt;&lt;/a&gt; returns a tuple (of length &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt;&lt;code&gt;obj.ndim&lt;/code&gt;&lt;/a&gt;) of integer index arrays showing the &lt;code&gt;True&lt;/code&gt; elements of &lt;em&gt;obj&lt;/em&gt;. However, it is faster when &lt;code&gt;obj.shape == x.shape&lt;/code&gt;.</source>
          <target state="translated">当obj是布尔类型的数组对象（例如，可以从比较运算符返回）时，就会发生这种高级索引。单个布尔索引数组实际上与 &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; 相同，如上所述，&lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;obj.nonzero()&lt;/code&gt; &lt;/a&gt;返回整数索引数组的元组（长度为&lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt; &lt;code&gt;obj.ndim&lt;/code&gt; &lt;/a&gt;），该数组显示&lt;em&gt;obj&lt;/em&gt;的 &lt;code&gt;True&lt;/code&gt; 元素。但是，当 &lt;code&gt;obj.shape == x.shape&lt;/code&gt; 时，速度更快。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="710121ccc37af7c57d603d19a46f2cadc801d4ee" translate="yes" xml:space="preserve">
          <source>This allows multithreading to fill large arrays in chunks using suitable BitGenerators in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af03503ddeac7c1214ea6c40abe67021cd6a3a66" translate="yes" xml:space="preserve">
          <source>This allows you to import the in-place built NumPy &lt;em&gt;from the repo base directory only&lt;/em&gt;. If you want the in-place build to be visible outside that base dir, you need to point your &lt;code&gt;PYTHONPATH&lt;/code&gt; environment variable to this directory. Some IDEs (&lt;a href=&quot;https://www.spyder-ide.org/&quot;&gt;Spyder&lt;/a&gt; for example) have utilities to manage &lt;code&gt;PYTHONPATH&lt;/code&gt;. On Linux and OSX, you can run the command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a10be423c319c36683d60f03c4235ea58ef43ca" translate="yes" xml:space="preserve">
          <source>This also works for functions and other objects that &lt;strong&gt;you&lt;/strong&gt; create. Just remember to include a docstring with your function using a string literal (&lt;code&gt;&quot;&quot;&quot; &quot;&quot;&quot;&lt;/code&gt; or &lt;code&gt;''' '''&lt;/code&gt; around your documentation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1c39c0afd071dc6e571fc8d1273c278aad6faa3" translate="yes" xml:space="preserve">
          <source>This also works with 2D arrays! If you start with this array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d160c6be16a498bbc805a56a17ad9724ae3c358b" translate="yes" xml:space="preserve">
          <source>This applies type promotion to all the inputs, using the NumPy rules for combining scalars and arrays, to determine the output type of a set of operands. This is the same result type that ufuncs produce. The specific algorithm used is as follows.</source>
          <target state="translated">它对所有的输入进行类型升级,使用NumPy的标量和数组组合规则来确定操作数集的输出类型。这和ufuncs产生的结果类型是一样的。具体使用的算法如下。</target>
        </trans-unit>
        <trans-unit id="2e8bc0cbcc5f069a41dc6497b9c0a909fd514a44" translate="yes" xml:space="preserve">
          <source>This approach to the array interface allows for faster access to an array using only one attribute lookup and a well-defined C-structure.</source>
          <target state="translated">这种数组接口的方法,只需使用一个属性查找和一个定义良好的C结构,就可以更快地访问数组。</target>
        </trans-unit>
        <trans-unit id="b2cfa3868ca6d5d3eec71f613d2a281e952e696d" translate="yes" xml:space="preserve">
          <source>This approach to the interface consists of the object having an &lt;a href=&quot;#__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">这种接口方法由具有&lt;a href=&quot;#__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; &lt;/a&gt;属性的对象组成。</target>
        </trans-unit>
        <trans-unit id="e27c7321ec2c09e2c1e41b0fb7ac933d7973957f" translate="yes" xml:space="preserve">
          <source>This arrangement allow for very flexible use of arrays. One thing that it allows is simple changes of the metadata to change the interpretation of the array buffer. Changing the byteorder of the array is a simple change involving no rearrangement of the data. The shape of the array can be changed very easily without changing anything in the data buffer or any data copying at all</source>
          <target state="translated">这种安排允许非常灵活地使用数组。它允许简单地改变元数据以改变数组缓冲区的解释。改变数组的字节顺序是一个简单的改变,不需要重新安排数据。数组的形状可以很容易地改变,而不需要改变数据缓冲区中的任何东西或任何数据复制。</target>
        </trans-unit>
        <trans-unit id="13b0f80cc0af4acb749cdb54d3ae94021e334ad5" translate="yes" xml:space="preserve">
          <source>This array creation routine allows for the convenient creation of a new array matching an existing array&amp;rsquo;s shapes and memory layout, possibly changing the layout and/or data type.</source>
          <target state="translated">该数组创建例程可方便地创建与现有数组的形状和内存布局匹配的新数组，并可能更改布局和/或数据类型。</target>
        </trans-unit>
        <trans-unit id="b6ad81be881df54f2faa5255b14c490a53a2cd92" translate="yes" xml:space="preserve">
          <source>This array is a copy of some other array. The C-API function PyArray_ResolveWritebackIfCopy must be called before deallocating to the base array will be updated with the contents of this array.</source>
          <target state="translated">这个数组是其他数组的拷贝。C-API函数PyArray_ResolveWritebackIfCopy必须在deallocating之前被调用,基数组将被更新为这个数组的内容。</target>
        </trans-unit>
        <trans-unit id="9975deeda2df7b42c75df625b9b5fc69426c2203" translate="yes" xml:space="preserve">
          <source>This array is stored in memory as 40 bytes, one after the other (known as a contiguous block of memory). The strides of an array tell us how many bytes we have to skip in memory to move to the next position along a certain axis. For example, we have to skip 4 bytes (1 value) to move to the next column, but 20 bytes (5 values) to get to the same position in the next row. As such, the strides for the array &lt;code&gt;x&lt;/code&gt; will be &lt;code&gt;(20, 4)&lt;/code&gt;.</source>
          <target state="translated">此数组以40字节的形式存储在内存中，一个接一个（又称为连续内存块）。数组的步幅告诉我们在内存中必须跳过多少字节才能沿着某个轴移动到下一个位置。例如，我们必须跳过4个字节（1个值）才能移至下一列，但要跳过20个字节（5个值）才能移至下一行中的相同位置。这样，数组 &lt;code&gt;x&lt;/code&gt; 的步幅将为 &lt;code&gt;(20, 4)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38cb8241a835a683d594eee86aed4e56e6c6635d" translate="yes" xml:space="preserve">
          <source>This array is the mask for all &lt;a href=&quot;../generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;writemasked&lt;/code&gt;&lt;/a&gt; operands. Code uses the &lt;code&gt;writemasked&lt;/code&gt; flag which indicates that only elements where the chosen ARRAYMASK operand is True will be written to. In general, the iterator does not enforce this, it is up to the code doing the iteration to follow that promise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed5fe179d122dc6d0ff4af8af1bf207796107b0" translate="yes" xml:space="preserve">
          <source>This array is the mask for all &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;writemasked&lt;/code&gt;&lt;/a&gt; operands. Code uses the &lt;code&gt;writemasked&lt;/code&gt; flag which indicates that only elements where the chosen ARRAYMASK operand is True will be written to. In general, the iterator does not enforce this, it is up to the code doing the iteration to follow that promise.</source>
          <target state="translated">该数组是所有&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;writemasked&lt;/code&gt; &lt;/a&gt;掩码操作数的掩码。代码使用 &lt;code&gt;writemasked&lt;/code&gt; 标志，该标志指示仅将所选ARRAYMASK操作数为True的元素写入。通常，迭代器不会强制执行此操作，而是由代码执行迭代来遵循该承诺。</target>
        </trans-unit>
        <trans-unit id="da76cf9484436ae5f595cbe33ce62d99eee348ae" translate="yes" xml:space="preserve">
          <source>This array is used in computing an N-d index from a 1-d index. It contains needed products of the dimensions.</source>
          <target state="translated">这个数组用于从1-d索引计算N-d索引。它包含了所需的维度的乘积。</target>
        </trans-unit>
        <trans-unit id="2950d768bc15bd8305b22a36aa90ddcbd53411a1" translate="yes" xml:space="preserve">
          <source>This array method can be conveniently chained:</source>
          <target state="translated">这个数组方法可以方便地进行连锁。</target>
        </trans-unit>
        <trans-unit id="cd59928fafb5b8b3afd2257d5348ff12e61a3751" translate="yes" xml:space="preserve">
          <source>This array must contain integers in &lt;code&gt;[0, n-1]&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of choices, unless &lt;code&gt;mode=wrap&lt;/code&gt; or &lt;code&gt;mode=clip&lt;/code&gt;, in which cases any integers are permissible.</source>
          <target state="translated">此数组必须在 &lt;code&gt;[0, n-1]&lt;/code&gt; 包含整数，其中 &lt;code&gt;n&lt;/code&gt; 是选择的数目，除非 &lt;code&gt;mode=wrap&lt;/code&gt; 或 &lt;code&gt;mode=clip&lt;/code&gt; ，在这种情况下，任何整数都是允许的。</target>
        </trans-unit>
        <trans-unit id="2801e85aeaae18790917a73e502d7026a3a34d08" translate="yes" xml:space="preserve">
          <source>This array must contain integers in &lt;code&gt;[0, n-1]&lt;/code&gt;, where n is the number of choices.</source>
          <target state="translated">此数组必须在 &lt;code&gt;[0, n-1]&lt;/code&gt; 包含整数，其中n是选择的数量。</target>
        </trans-unit>
        <trans-unit id="7231182809746ea9e4a7a5bcc665f806413fd373" translate="yes" xml:space="preserve">
          <source>This assumes that you have forked &lt;a href=&quot;https://github.com/scipy/scipy.org&quot;&gt;https://github.com/scipy/scipy.org&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3397e055cb40235a1ae2818b229475b2582745a3" translate="yes" xml:space="preserve">
          <source>This attribute allows simple but flexible determination of which sub- type should be considered &amp;ldquo;primary&amp;rdquo; when an operation involving two or more sub-types arises. In operations where different sub-types are being used, the sub-type with the largest &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; attribute will determine the sub-type of the output(s). If two sub- types have the same &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; then the sub-type of the first argument determines the output. The default &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; attribute returns a value of 0.0 for the base ndarray type and 1.0 for a sub-type. This attribute can also be defined by objects that are not sub-types of the ndarray and can be used to determine which &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method should be called for the return output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19820dc6931f03b4ce34d1e382ce5208e82ba583" translate="yes" xml:space="preserve">
          <source>This attribute can also be an object exposing the &lt;a href=&quot;https://docs.python.org/dev/c-api/objbuffer.html#c.PyObject_AsCharBuffer&quot;&gt;&lt;code&gt;buffer interface&lt;/code&gt;&lt;/a&gt; which will be used to share the data. If this key is not present (or returns &lt;code&gt;None&lt;/code&gt;), then memory sharing will be done through the buffer interface of the object itself. In this case, the offset key can be used to indicate the start of the buffer. A reference to the object exposing the array interface must be stored by the new object if the memory area is to be secured.</source>
          <target state="translated">此属性也可以是一个对象，该对象公开将用于共享数据的&lt;a href=&quot;https://docs.python.org/dev/c-api/objbuffer.html#c.PyObject_AsCharBuffer&quot;&gt; &lt;code&gt;buffer interface&lt;/code&gt; &lt;/a&gt;。如果此键不存在（或返回 &lt;code&gt;None&lt;/code&gt; ），则将通过对象本身的缓冲区接口完成内存共享。在这种情况下，偏移键可用于指示缓冲区的开始。如果要保护存储区，则必须由新对象存储对暴露数组接口的对象的引用。</target>
        </trans-unit>
        <trans-unit id="357acc58797c34ec7ee3526baa5d4678b200c571" translate="yes" xml:space="preserve">
          <source>This attribute can also be an object exposing the &lt;code&gt;buffer interface&lt;/code&gt; which will be used to share the data. If this key is not present (or returns None), then memory sharing will be done through the buffer interface of the object itself. In this case, the offset key can be used to indicate the start of the buffer. A reference to the object exposing the array interface must be stored by the new object if the memory area is to be secured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99486092092808fe1a7a3c63950908fb38dd3c25" translate="yes" xml:space="preserve">
          <source>This attribute creates an object that makes it easier to use arrays when calling shared libraries with the ctypes module. The returned object has, among others, data, shape, and strides attributes (see Notes below) which themselves return ctypes objects that can be used as arguments to a shared library.</source>
          <target state="translated">这个属性创建了一个对象,使其在使用ctypes模块调用共享库时更容易使用数组。返回的对象除此之外还有data、shape和strides属性(见下面的注释),这些属性本身也会返回ctypes对象,可以作为共享库的参数。</target>
        </trans-unit>
        <trans-unit id="94f279541eccc23ec8d58b2be974fecc119fa4c7" translate="yes" xml:space="preserve">
          <source>This basic behavior can be augmented by passing a 2-tuple in as the file argument. The first element of the tuple should specify the relative path (under the package install directory) where the remaining sequence of files should be installed to (it has nothing to do with the file-names in the source distribution). The second element of the tuple is the sequence of files that should be installed. The files in this sequence can be filenames, relative paths, or absolute paths. For absolute paths the file will be installed in the top-level package installation directory (regardless of the first argument). Filenames and relative path names will be installed in the package install directory under the path name given as the first element of the tuple.</source>
          <target state="translated">这个基本行为可以通过传递一个 2-tuple 作为文件参数来增强。元组的第一个元素应该指定相对路径(在软件包安装目录下),剩余的文件序列应该被安装到那里(它与源码发行版中的文件名无关)。元组的第二个元素是应该被安装的文件序列。这个序列中的文件可以是文件名、相对路径或绝对路径。对于绝对路径,文件将被安装在顶层的软件包安装目录中(不管第一个参数是什么)。文件名和相对路径名将被安装在包的安装目录下,作为元组的第一个元素给出的路径名。</target>
        </trans-unit>
        <trans-unit id="38d8b59be8238ec40cd52d11a1691c2db5ac9b19" translate="yes" xml:space="preserve">
          <source>This broadcasting can also be achieved using the function &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">也可以使用功能&lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; 进行广播&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="040d755c45914cdad7e449ca2485bc004cd21eb5" translate="yes" xml:space="preserve">
          <source>This bug causes Python before 3.4 to not reliably show warnings again after they have been ignored once (even within catch_warnings). It means that no &amp;ldquo;ignore&amp;rdquo; filter can be used easily, since following tests might need to see the warning. Additionally it allows easier specificity for testing warnings and can be nested.</source>
          <target state="translated">此错误导致3.4之前的Python在一次被忽略之后（即使在catch_warnings中）也无法可靠地再次显示警告。这意味着不能轻易使用&amp;ldquo;忽略&amp;rdquo;过滤器，因为后续测试可能需要查看警告。此外，它还可以简化测试警告的特异性，并且可以嵌套。</target>
        </trans-unit>
        <trans-unit id="b97776ec43283f6527b6b56ee297ecb07c0e7a5e" translate="yes" xml:space="preserve">
          <source>This builds NumPy first, so the first time it may take a few minutes. If you specify &lt;code&gt;-n&lt;/code&gt;, the tests are run against the version of NumPy (if any) found on current PYTHONPATH.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f8c2b712d454554ccb3b1572df7e3d85a8d6a8" translate="yes" xml:space="preserve">
          <source>This can be done via &lt;em&gt;interactive rebasing&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d1ccaf9367b320b45fde18f5d1b6d26c14c28d1" translate="yes" xml:space="preserve">
          <source>This can be used on multidimensional arrays too:</source>
          <target state="translated">这也可以用在多维数组上。</target>
        </trans-unit>
        <trans-unit id="4619f696b33e2f5aafe4335faf3807d265baaeed" translate="yes" xml:space="preserve">
          <source>This can have multiple paragraphs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0866e6d60c935d1c1a437309972ddf022e2bfb" translate="yes" xml:space="preserve">
          <source>This chapter will review many of the tools that are available for the purpose of accessing code written in other compiled languages. There are many resources available for learning to call other compiled libraries from Python and the purpose of this Chapter is not to make you an expert. The main goal is to make you aware of some of the possibilities so that you will know what to &amp;ldquo;Google&amp;rdquo; in order to learn more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b07ef80d0cc13652d9fe61895de6904fd8ef60" translate="yes" xml:space="preserve">
          <source>This class implements the special methods for almost all of Python&amp;rsquo;s builtin operators defined in the &lt;a href=&quot;https://docs.python.org/dev/library/operator.html#module-operator&quot;&gt;&lt;code&gt;operator&lt;/code&gt;&lt;/a&gt; module, including comparisons (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, etc.) and arithmetic (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, etc.), by deferring to the &lt;code&gt;__array_ufunc__&lt;/code&gt; method, which subclasses must implement.</source>
          <target state="translated">此类通过遵循 &lt;code&gt;__array_ufunc__&lt;/code&gt; 方法，为&lt;a href=&quot;https://docs.python.org/dev/library/operator.html#module-operator&quot;&gt; &lt;code&gt;operator&lt;/code&gt; &lt;/a&gt;模块中定义的几乎所有Python内置操作符实现了特殊方法，包括比较（ &lt;code&gt;==&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; 等）和算术（ &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; 等），必须实现哪些子类。</target>
        </trans-unit>
        <trans-unit id="cbc453ece1fc4bcfba8a214ebb68dae3ad49689e" translate="yes" xml:space="preserve">
          <source>This class is provided for numarray backward-compatibility. New code (not concerned with numarray compatibility) should use arrays of type &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt; and use the free functions in &lt;code&gt;numpy.char&lt;/code&gt; for fast vectorized string operations instead.</source>
          <target state="translated">提供此类是为了实现numarray向后兼容。新的代码（不涉及numarray兼容性）应该使用类型的数组 &lt;code&gt;string_&lt;/code&gt; 或 &lt;code&gt;unicode_&lt;/code&gt; 并使用免费的功能 &lt;code&gt;numpy.char&lt;/code&gt; 快速矢量字符串操作代替。</target>
        </trans-unit>
        <trans-unit id="817afa6aa8358446cc6150c81d202fd10664d253" translate="yes" xml:space="preserve">
          <source>This class isn&amp;rsquo;t very useful, because it has the same constructor as the bare ndarray object, including passing in buffers and shapes and so on. We would probably prefer the constructor to be able to take an already formed ndarray from the usual numpy calls to &lt;code&gt;np.array&lt;/code&gt; and return an object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="547d58e17f08661cffe0028727466b3bfecb1f09" translate="yes" xml:space="preserve">
          <source>This class may at some point be turned into a factory function which returns a view into an mmap buffer.</source>
          <target state="translated">这个类在某些时候可能会变成一个工厂函数,将视图返回到一个mmap缓冲区。</target>
        </trans-unit>
        <trans-unit id="9f0e2bd2c54e1831a429118c49099c40d4fc6a31" translate="yes" xml:space="preserve">
          <source>This code can be compiled and linked into an extension module named filter using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="051a76f1d3dcebdcceb5b6a498f248ede74e08da" translate="yes" xml:space="preserve">
          <source>This code has a significant amount of error handling. Note the &lt;code&gt;SWIG_fail&lt;/code&gt; is a macro for &lt;code&gt;goto fail&lt;/code&gt;, referring to the label at line 28. If the user provides the wrong number of arguments, this will be caught at line 10. If construction of the NumPy array fails or produces an array with the wrong number of dimensions, these errors are caught at line 17. And finally, if an error is detected, memory is still managed correctly at line 30.</source>
          <target state="translated">此代码具有大量错误处理。请注意， &lt;code&gt;SWIG_fail&lt;/code&gt; 是 &lt;code&gt;goto fail&lt;/code&gt; 的宏，请参考第28行的标签。如果用户提供的参数数量错误，则将在第10行捕获该错误。如果NumPy数组的构造失败或生成的数组错误数量，这些错误将在第17行捕获。最后，如果检测到错误，则在第30行仍然可以正确管理内存。</target>
        </trans-unit>
        <trans-unit id="3999b914a2658c99b5fe639f3ab379867f2570ac" translate="yes" xml:space="preserve">
          <source>This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment and goals. Please try to follow this code in spirit as much as in letter, to create a friendly and productive environment that enriches the surrounding community.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2f712a7c05e996ac3e38345d45b7f3d7e23038" translate="yes" xml:space="preserve">
          <source>This code loads the shared library named &lt;code&gt;code.{ext}&lt;/code&gt; located in the same path as this file. It then adds a return type of void to the functions contained in the library. It also adds argument checking to the functions in the library so that ndarrays can be passed as the first three arguments along with an integer (large enough to hold a pointer on the platform) as the fourth argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="533c867c6a351c2be81a48161bc93203ea12c76d" translate="yes" xml:space="preserve">
          <source>This code of conduct applies to all spaces managed by the NumPy project, including all public and private mailing lists, issue trackers, wikis, blogs, Twitter, and any other communication channel used by our community. The NumPy project does not organise in-person events, however events related to our community should have a code of conduct similar in spirit to this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff208b4a7eacc934c607e5c41003491618977d7" translate="yes" xml:space="preserve">
          <source>This code of conduct should be honored by everyone who participates in the NumPy community formally or informally, or claims any affiliation with the project, in any project-related activities and especially when representing the project, in any role.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f194434e38b3846c0fd28dc955d7908e8501694" translate="yes" xml:space="preserve">
          <source>This command builds (see &lt;code&gt;-c&lt;/code&gt; flag, execute &lt;code&gt;python -m numpy.f2py&lt;/code&gt; without arguments to see the explanation of command line options) an extension module &lt;code&gt;fib1.so&lt;/code&gt; (see &lt;code&gt;-m&lt;/code&gt; flag) to the current directory. Now, in Python the Fortran subroutine &lt;code&gt;FIB&lt;/code&gt; is accessible via &lt;code&gt;fib1.fib&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb1615a9d0e074d0b52d81da555b5659d5320b3" translate="yes" xml:space="preserve">
          <source>This command leaves a file named add.{ext} in the current directory (where {ext} is the appropriate extension for a python extension module on your platform &amp;mdash; so, pyd, &lt;em&gt;etc.&lt;/em&gt; ). This module may then be imported from Python. It will contain a method for each subroutine in add (zadd, cadd, dadd, sadd). The docstring of each method contains information about how the module method may be called:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8208674ec726acd6f311802a0a4f9952791f4b6" translate="yes" xml:space="preserve">
          <source>This command leaves the file add.pyf in the current directory. The section of this file corresponding to zadd is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0a485b84958d1031e7018c2536aa8e72a66489" translate="yes" xml:space="preserve">
          <source>This condition is broadcast over the input. At locations where the condition is True, the &lt;code&gt;out&lt;/code&gt; array will be set to the ufunc result. Elsewhere, the &lt;code&gt;out&lt;/code&gt; array will retain its original value. Note that if an uninitialized &lt;code&gt;out&lt;/code&gt; array is created via the default &lt;code&gt;out=None&lt;/code&gt;, locations within it where the condition is False will remain uninitialized.</source>
          <target state="translated">此条件通过输入广播。在条件为True的位置，将 &lt;code&gt;out&lt;/code&gt; 数组设置为ufunc结果。在其他地方， &lt;code&gt;out&lt;/code&gt; 数组将保留其原始值。请注意，如果通过默认的 &lt;code&gt;out=None&lt;/code&gt; 创建了未初始化的 &lt;code&gt;out&lt;/code&gt; 数组，则条件为False的数组中的位置将保持未初始化。</target>
        </trans-unit>
        <trans-unit id="ee4c6c49dffb551e0984368af8f98c122bd3ccfb" translate="yes" xml:space="preserve">
          <source>This constructor can be compared to &lt;code&gt;empty&lt;/code&gt;: it creates a new record array but does not fill it with data. To create a record array from data, use one of the following methods:</source>
          <target state="translated">可以将此构造函数与 &lt;code&gt;empty&lt;/code&gt; 进行比较：它创建一个新的记录数组，但不用数据填充它。要从数据创建记录数组，请使用以下方法之一：</target>
        </trans-unit>
        <trans-unit id="33c942d2092f2a81aa60d19a082d10077f5b892d" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='Fortran'&lt;/code&gt;, in which case &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">如果不是 &lt;code&gt;None&lt;/code&gt; ，则此构造函数使用 &lt;code&gt;buffer&lt;/code&gt; （带有 &lt;code&gt;offset&lt;/code&gt; 和&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;）创建数组。如果 &lt;code&gt;buffer&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，则构造一个新数组，&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;为&amp;ldquo; C order&amp;rdquo;，除非 &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; 和 &lt;code&gt;order='Fortran'&lt;/code&gt; 在这种情况下，&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;为&amp;ldquo; Fortran order&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="953bdd8047346bccedc501390c7ed7305dc6711a" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='F'&lt;/code&gt;, in which case &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244906121f35fcb6808baef572df1faf5ecac2b9" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='Fortran'&lt;/code&gt;, in which case &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">如果不是 &lt;code&gt;None&lt;/code&gt; ，则此构造函数使用 &lt;code&gt;buffer&lt;/code&gt; （带有 &lt;code&gt;offset&lt;/code&gt; 和&lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;）创建数组。如果 &lt;code&gt;buffer&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，则构造一个新数组，&lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;为&amp;ldquo; C order&amp;rdquo;，除非 &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; 和 &lt;code&gt;order='Fortran'&lt;/code&gt; 在这种情况下，&lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt;为&amp;ldquo; Fortran order&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="472735a82ef7af1ec4165da8f5b7c128444159de" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='F'&lt;/code&gt;, in which case &lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25eee032d6ea1636789f057c08bed3526280036b" translate="yes" xml:space="preserve">
          <source>This could then be registered to convert doubles to floats using the code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5986918bf935c1ed16d4421ab17b1ade1eafe40" translate="yes" xml:space="preserve">
          <source>This declares that the corresponding argument depends on the values of variables in the list &lt;code&gt;&amp;lt;names&amp;gt;&lt;/code&gt;. For example, &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; may use the values of other arguments. Using information given by &lt;code&gt;depend(..)&lt;/code&gt; attributes, F2PY ensures that arguments are initialized in a proper order. If &lt;code&gt;depend(..)&lt;/code&gt; attribute is not used then F2PY determines dependence relations automatically. Use &lt;code&gt;depend()&lt;/code&gt; to disable dependence relations generated by F2PY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c221f7f1dff9c4b5017181532f28da44b16fcb82" translate="yes" xml:space="preserve">
          <source>This decorator can be used to filter DeprecationWarning&amp;rsquo;s, to avoid printing them during the test suite run, while checking that the test actually raises a DeprecationWarning.</source>
          <target state="translated">该装饰器可用于过滤DeprecationWarning，以避免在测试套件运行期间打印它们，同时检查测试是否实际引发了DeprecationWarning。</target>
        </trans-unit>
        <trans-unit id="50d52a319d15baa1479e649a743cee7e5d09023b" translate="yes" xml:space="preserve">
          <source>This decorator can&amp;rsquo;t use the nose namespace, because it can be called from a non-test module. See also &lt;code&gt;istest&lt;/code&gt; and &lt;code&gt;nottest&lt;/code&gt; in &lt;code&gt;nose.tools&lt;/code&gt;.</source>
          <target state="translated">该装饰器不能使用鼻子命名空间，因为可以从非测试模块中调用它。又见 &lt;code&gt;istest&lt;/code&gt; 和 &lt;code&gt;nottest&lt;/code&gt; 在 &lt;code&gt;nose.tools&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67fd7e1d7456c74a698475b7f144fadff01137fb" translate="yes" xml:space="preserve">
          <source>This default iterator selects a sub-array of dimension</source>
          <target state="translated">这个默认的迭代器选择一个维度的子数组。</target>
        </trans-unit>
        <trans-unit id="cfb9c1da992a1d1aaddfb397e6c91ff1039b17da" translate="yes" xml:space="preserve">
          <source>This default threshold is designed to detect rank deficiency accounting for the numerical errors of the SVD computation. Imagine that there is a column in &lt;code&gt;M&lt;/code&gt; that is an exact (in floating point) linear combination of other columns in &lt;code&gt;M&lt;/code&gt;. Computing the SVD on &lt;code&gt;M&lt;/code&gt; will not produce a singular value exactly equal to 0 in general: any difference of the smallest SVD value from 0 will be caused by numerical imprecision in the calculation of the SVD. Our threshold for small SVD values takes this numerical imprecision into account, and the default threshold will detect such numerical rank deficiency. The threshold may declare a matrix &lt;code&gt;M&lt;/code&gt; rank deficient even if the linear combination of some columns of &lt;code&gt;M&lt;/code&gt; is not exactly equal to another column of &lt;code&gt;M&lt;/code&gt; but only numerically very close to another column of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">此默认阈值旨在检测由于SVD计算的数值误差而导致的秩不足。想象有在一列 &lt;code&gt;M&lt;/code&gt; 线性在其他列的组合是一种精确（浮点） &lt;code&gt;M&lt;/code&gt; 。通常，在 &lt;code&gt;M&lt;/code&gt; 上计算SVD 不会产生精确等于0的奇异值：最小SVD值与0的任何差异将由SVD计算中的数值不精确性引起。我们的小SVD值阈值考虑了此数字不精确性，默认阈值将检测到此类数字秩不​​足。该阈值可以声明一个矩阵 &lt;code&gt;M&lt;/code&gt; 秩亏即使某些列的线性组合 &lt;code&gt;M&lt;/code&gt; 不完全等于 &lt;code&gt;M&lt;/code&gt; 的另一列，而在数值上仅非常接近 &lt;code&gt;M&lt;/code&gt; 的另一列。</target>
        </trans-unit>
        <trans-unit id="b6968499a16ad7614bdea90ae8f3aad570e0c60e" translate="yes" xml:space="preserve">
          <source>This document describes the syntax and best practices for docstrings used with the numpydoc extension for &lt;a href=&quot;http://sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45b65ecc52b644a63152b28ad1bde6a3a5e1f70" translate="yes" xml:space="preserve">
          <source>This document gives coding conventions for the C code comprising the C implementation of NumPy. Note, rules are there to be broken. Two good reasons to break a particular rule:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3b557b3201940ffcbe7e57b7ac3945729bb630" translate="yes" xml:space="preserve">
          <source>This document itself was written in ReStructuredText. &lt;a href=&quot;#example&quot;&gt;An example&lt;/a&gt; of the format shown here is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2007e99c49141c98bee8b2f4b8b703b1ff66930c" translate="yes" xml:space="preserve">
          <source>This does not compute the usual correlation: if op2 is larger than op1, the arguments are swapped, and the conjugate is never taken for complex arrays. See PyArray_Correlate2 for the usual signal processing correlation.</source>
          <target state="translated">这并不是计算通常的相关性:如果 op2 大于 op1,参数会被调换,对于复杂数组,永远不会取共轭。参见PyArray_Correlate2,了解通常的信号处理相关性。</target>
        </trans-unit>
        <trans-unit id="2ac0e7432126a7d32cb5b22ed347524b29026575" translate="yes" xml:space="preserve">
          <source>This enables the iterator to reason about data dependency, possibly avoiding unnecessary copies.</source>
          <target state="translated">这使得迭代器能够推理数据的依赖性,可能避免不必要的拷贝。</target>
        </trans-unit>
        <trans-unit id="fb73eae3981c0a0cbcb09d6d3ccfc761b4660a9a" translate="yes" xml:space="preserve">
          <source>This example makes use of Python 3 &lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt;&lt;code&gt;concurrent.futures&lt;/code&gt;&lt;/a&gt; to fill an array using multiple threads. Threads are long-lived so that repeated calls do not require any additional overheads from thread creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff3d50ffaaf1fbc724fd92676a9a6bf2dd386440" translate="yes" xml:space="preserve">
          <source>This example makes use of Python 3 &lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt;&lt;code&gt;concurrent.futures&lt;/code&gt;&lt;/a&gt; to fill an array using multiple threads. Threads are long-lived so that repeated calls do not require any additional overheads from thread creation. The underlying BitGenerator is &lt;code&gt;PCG64&lt;/code&gt; which is fast, has a long period and supports using &lt;code&gt;PCG64.jumped&lt;/code&gt; to return a new generator while advancing the state. The random numbers generated are reproducible in the sense that the same seed will produce the same outputs.</source>
          <target state="translated">本示例使用的Python 3个&lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt; &lt;code&gt;concurrent.futures&lt;/code&gt; &lt;/a&gt;填补使用多线程的阵列。线程是长期存在的，因此重复调用不需要线程创建带来的任何额外开销。底层的BitGenerator是 &lt;code&gt;PCG64&lt;/code&gt; ，它运行速度快，周期长并且支持使用 &lt;code&gt;PCG64.jumped&lt;/code&gt; 在前进状态时返回新的生成器。在相同种子将产生相同输出的意义上，所产生的随机数是可再现的。</target>
        </trans-unit>
        <trans-unit id="40004ca036e22114daf23d8e12216a484254a12b" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;converters&lt;/code&gt; can be used to convert a field with a trailing minus sign into a negative number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b788d751d6a8b5a6ea3f2e12485a26037e6ed998" translate="yes" xml:space="preserve">
          <source>This example shows how numba can be used to produce Box-Muller normals using a pure Python implementation which is then compiled. The random numbers are provided by &lt;code&gt;ctypes.next_double&lt;/code&gt;.</source>
          <target state="translated">本示例说明了如何使用numba使用纯Python实现来生成Box-Muller法线，然后将其编译。随机数由 &lt;code&gt;ctypes.next_double&lt;/code&gt; 提供。</target>
        </trans-unit>
        <trans-unit id="c43d650067bf3f7811ad3426eb67449ba8f8d778" translate="yes" xml:space="preserve">
          <source>This example shows how numba can be used to produce gaussian samples using a pure Python implementation which is then compiled. The random numbers are provided by &lt;code&gt;ctypes.next_double&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21f8a7f3cdbbf2fa9d3bdab5400251540901f919" translate="yes" xml:space="preserve">
          <source>This example shows how to create a ufunc for a structured array dtype. For the example we show a trivial ufunc for adding two arrays with dtype &amp;lsquo;u8,u8,u8&amp;rsquo;. The process is a bit different from the other examples since a call to &lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_FromFuncAndData&quot;&gt;&lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t fully register ufuncs for custom dtypes and structured array dtypes. We need to also call &lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_RegisterLoopForDescr&quot;&gt;&lt;code&gt;PyUFunc_RegisterLoopForDescr&lt;/code&gt;&lt;/a&gt; to finish setting up the ufunc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7280fcf983a91daf5dc16e89c6643dc47e38c1" translate="yes" xml:space="preserve">
          <source>This example shows that a negative value can be returned when the input is an array of signed integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15659709a5e32bf1f77ae2078941bf91dc0f1586" translate="yes" xml:space="preserve">
          <source>This example uses a temporary file so that doctest doesn&amp;rsquo;t write files to your directory. You would use a &amp;lsquo;normal&amp;rsquo; filename.</source>
          <target state="translated">本示例使用一个临时文件，以便doctest不会将文件写入目录。您将使用&amp;ldquo;普通&amp;rdquo;文件名。</target>
        </trans-unit>
        <trans-unit id="c6a6109259025b3790be906b9d5fd08b4a7ddd22" translate="yes" xml:space="preserve">
          <source>This explanation of &lt;code&gt;fmt&lt;/code&gt; is not complete, for an exhaustive specification see &lt;a href=&quot;#r672d4d5b6143-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">关于 &lt;code&gt;fmt&lt;/code&gt; 的解释还不完整，有关详细说明，请参见&lt;a href=&quot;#r672d4d5b6143-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6f060f066c80d886f242a9ad00dc6b69ec16949" translate="yes" xml:space="preserve">
          <source>This feature lets you make local decisions about when and how to split up streams without coordination between processes. You do not have to preallocate space to avoid overlapping or request streams from a common global service. This general &amp;ldquo;tree-hashing&amp;rdquo; scheme is &lt;a href=&quot;https://www.iro.umontreal.ca/~lecuyer/myftp/papers/parallel-rng-imacs.pdf&quot;&gt;not unique to numpy&lt;/a&gt; but not yet widespread. Python has increasingly-flexible mechanisms for parallelization available, and this scheme fits in very well with that kind of use.</source>
          <target state="translated">使用此功能，您可以在何时以及如何拆分流的情况下做出本地决策，而无需在流程之间进行协调。您不必预先分配空间来避免重叠或从通用全局服务请求流。这种通用的&amp;ldquo;树哈希&amp;rdquo;方案&lt;a href=&quot;https://www.iro.umontreal.ca/~lecuyer/myftp/papers/parallel-rng-imacs.pdf&quot;&gt;不是numpy独有的，&lt;/a&gt;但尚未普及。Python具有越来越灵活的并行化机制，该方案非常适合这种使用。</target>
        </trans-unit>
        <trans-unit id="1eaab0e05e888941195d61599512548e7a521f9d" translate="yes" xml:space="preserve">
          <source>This file contains a walkthrough of the NumPy 1.14.5 release on Linux, modified for building on azure and uploading to anaconda.org The commands can be copied into the command line, but be sure to replace 1.14.5 by the correct version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbd2bf0596d8530c916e2a9e88d889eff818ebc6" translate="yes" xml:space="preserve">
          <source>This file gives an overview of what is necessary to build binary releases for NumPy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482a4249cfca9480f9fad090626bdeb4f2b9945b" translate="yes" xml:space="preserve">
          <source>This file is installed to the package installation directory.</source>
          <target state="translated">这个文件安装到包的安装目录。</target>
        </trans-unit>
        <trans-unit id="53df6470e0b1cc077e937e47a1974181b9abe4c8" translate="yes" xml:space="preserve">
          <source>This flag can only be used with &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; when &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt; is enabled. This is because without buffering, the inner loop is always the size of the innermost iteration dimension, and allowing it to get cut up would require special handling, effectively making it more like the buffered version.</source>
          <target state="translated">此标志只能与使用&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;时&lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt;启用。这是因为，如果没有缓冲，则内部循环始终是最内部的迭代维的大小，并且允许对其进行分割将需要进行特殊处理，从而使其更像是缓冲的版本。</target>
        </trans-unit>
        <trans-unit id="b15ae805eec5e668ba73f9b0b01c1bc16e63444d" translate="yes" xml:space="preserve">
          <source>This flag has effect only if &lt;code&gt;NPY_ITER_COPY_IF_OVERLAP&lt;/code&gt; is enabled on the iterator.</source>
          <target state="translated">仅当在迭代器上启用 &lt;code&gt;NPY_ITER_COPY_IF_OVERLAP&lt;/code&gt; 时,此标志才有效。</target>
        </trans-unit>
        <trans-unit id="9da2bfdfbda0e7663b5a969172c32a000741b205" translate="yes" xml:space="preserve">
          <source>This flag is incompatible with &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此标志与&lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt;不兼容。</target>
        </trans-unit>
        <trans-unit id="f18364f6e6e63625675c7a8e617237459cb62263" translate="yes" xml:space="preserve">
          <source>This flag is true if the underlying array is &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;. It is used to simplify calculations when possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dded0adeb2bd9373f814af71190afe223e5d417b" translate="yes" xml:space="preserve">
          <source>This flag is true if the underlying array is &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;. It is used to simplify calculations when possible.</source>
          <target state="translated">如果基础数组是&lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; ,&lt;/a&gt;则此标志为true 。如果可能的话，它用于简化计算。</target>
        </trans-unit>
        <trans-unit id="8bd5458653c4b0d4b9801dcf72f3813b331fc2dd" translate="yes" xml:space="preserve">
          <source>This flag is useful for arrays that must be in C-contiguous order and aligned. These kinds of arrays are usually input arrays for some algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="174700adc5b2ef69a266d85c159fde8b55bae281" translate="yes" xml:space="preserve">
          <source>This flag is useful to specify an array that is in C-contiguous order, is aligned, and can be written to as well. Such an array is usually returned as output (although normally such output arrays are created from scratch).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5677601b0eb842974f94991fa89b82f29f0accae" translate="yes" xml:space="preserve">
          <source>This flag is useful to specify an array that will be used for both input and output. &lt;a href=&quot;../reference/c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; must be called before &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; at the end of the interface routine to write back the temporary data into the original array passed in. Use of the &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags requires that the input object is already an array (because other objects cannot be automatically updated in this fashion). If an error occurs use &lt;a href=&quot;../reference/c-api/array#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt; (obj) on an array with these flags set. This will set the underlying base array writable without causing the contents to be copied back into the original array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07be9168d02cb1629420a221f75d6ebada0e23c" translate="yes" xml:space="preserve">
          <source>This flag only affects writing from the buffer back to the array. This means that if the operand is also &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt;&lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt;&lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt;&lt;/a&gt;, code doing iteration can write to this operand to control which elements will be untouched and which ones will be modified. This is useful when the mask should be a combination of input masks.</source>
          <target state="translated">该标志仅影响从缓冲区写回到阵列。这意味着，如果操作数也为&lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt; &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt; &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; &lt;/a&gt;，则执行迭代的代码可以写入该操作数，以控制哪些元素将保持不变，哪些元素将被修改。当掩码应为输入掩码的组合时，这很有用。</target>
        </trans-unit>
        <trans-unit id="61e9f59feb262d0f073bfa393f7c68aa5599a46b" translate="yes" xml:space="preserve">
          <source>This form also makes it possible to specify struct dtypes with overlapping fields, functioning like the &amp;lsquo;union&amp;rsquo; type in C. This usage is discouraged, however, and the union mechanism is preferred.</source>
          <target state="translated">这种形式还可以指定具有重叠字段的struct dtype，其功能类似于C中的&amp;ldquo; union&amp;rdquo;类型。但是，不鼓励使用此方法，并且首选并集机制。</target>
        </trans-unit>
        <trans-unit id="0d302c80ebc9e23237f250ea17213abaf97a46db" translate="yes" xml:space="preserve">
          <source>This form is discouraged because Python dictionaries do not preserve order in Python versions before Python 3.6, and the order of the fields in a structured dtype has meaning. &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt; may be specified by using a 3-tuple, see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ceb45713d06ac7d3696f87a18d50201d0b6641" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;steals a reference&lt;/strong&gt; to &lt;code&gt;obj&lt;/code&gt; and sets it as the base property of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">该函数&lt;strong&gt;窃取&lt;/strong&gt;对 &lt;code&gt;obj&lt;/code&gt; &lt;strong&gt;的引用&lt;/strong&gt;，并将其设置为 &lt;code&gt;arr&lt;/code&gt; 的基本属性。</target>
        </trans-unit>
        <trans-unit id="d09c0732b811d51b99b90004b51ceb77de43b711" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;steals a reference&lt;/strong&gt; to &lt;code&gt;op&lt;/code&gt; and makes sure that &lt;code&gt;op&lt;/code&gt; is a base-class ndarray. It special cases array scalars, but otherwise calls &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;op&lt;/code&gt;, NULL, 0, 0, &lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt;&lt;/a&gt;, NULL).</source>
          <target state="translated">该函数&lt;strong&gt;窃取了&lt;/strong&gt;对 &lt;code&gt;op&lt;/code&gt; &lt;strong&gt;的引用&lt;/strong&gt;，并确保 &lt;code&gt;op&lt;/code&gt; 是基类ndarray。它在特殊情况下是数组标量，但否则调用&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;op&lt;/code&gt; ，NULL，0，0，&lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt; &lt;/a&gt;，NULL）。</target>
        </trans-unit>
        <trans-unit id="39a0c64e238756c013e69a01cf344f4e1849a8a1" translate="yes" xml:space="preserve">
          <source>This function accepts but discards arguments &lt;code&gt;bias&lt;/code&gt; and &lt;code&gt;ddof&lt;/code&gt;. This is for backwards compatibility with previous versions of this function. These arguments had no effect on the return values of the function and can be safely ignored in this and previous versions of numpy.</source>
          <target state="translated">该函数接受但丢弃参数 &lt;code&gt;bias&lt;/code&gt; 和 &lt;code&gt;ddof&lt;/code&gt; 。这是为了与该功能的先前版本向后兼容。这些参数对函数的返回值没有影响，在此版本和以前的numpy版本中可以安全地忽略它们。</target>
        </trans-unit>
        <trans-unit id="f2fa4598ed049a537ca6f0801826008a1fe6bde0" translate="yes" xml:space="preserve">
          <source>This function aims to be a fast reader for simply formatted files. The &lt;a href=&quot;numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; function provides more sophisticated handling of, e.g., lines with missing values.</source>
          <target state="translated">此功能旨在成为简单格式文件的快速阅读器。该&lt;a href=&quot;numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt;功能提供了更复杂的处理，例如，与缺失值线。</target>
        </trans-unit>
        <trans-unit id="ff21c5d7fbe80ce59f5b300cd13fc6a4fc144e9d" translate="yes" xml:space="preserve">
          <source>This function allows one set of bins to be computed, and reused across multiple histograms:</source>
          <target state="translated">该功能允许计算一组信道,并在多个直方图中重复使用。</target>
        </trans-unit>
        <trans-unit id="8a2a88415c2050cb4cd9564db4ec54b1d4908d16" translate="yes" xml:space="preserve">
          <source>This function allows the user to register a 1-d loop with an already- created ufunc to be used whenever the ufunc is called with any of its input arguments as the user-defined data-type. This is needed in order to make ufuncs work with built-in data-types. The data-type must have been previously registered with the numpy system. The loop is passed in as &lt;em&gt;function&lt;/em&gt;. This loop can take arbitrary data which should be passed in as &lt;em&gt;data&lt;/em&gt;. The data-types the loop requires are passed in as &lt;em&gt;arg_types&lt;/em&gt; which must be a pointer to memory at least as large as ufunc-&amp;gt;nargs.</source>
          <target state="translated">此功能允许用户在使用任何输入参数作为用户定义的数据类型调用ufunc时，向已创建的ufunc注册一维循环。为了使ufunc与内置数据类型一起使用，这是必需的。数据类型必须事先已在numpy系统中注册。循环作为&lt;em&gt;函数&lt;/em&gt;传递。此循环可以获取应作为&lt;em&gt;data&lt;/em&gt;传递的任意&lt;em&gt;数据&lt;/em&gt;。循环所需的数据类型以&lt;em&gt;arg_types的&lt;/em&gt;形式传入，该&lt;em&gt;arg_types&lt;/em&gt;必须是至少与ufunc-&amp;gt; nargs一样大的内存指针。</target>
        </trans-unit>
        <trans-unit id="f1576babab462c2253d07a719792b0ff878bb525" translate="yes" xml:space="preserve">
          <source>This function allows you to alter the tp_str and tp_repr methods of the array object to any Python function. Thus you can alter what happens for all arrays when str(arr) or repr(arr) is called from Python. The function to be called is passed in as &lt;em&gt;op&lt;/em&gt;. If &lt;em&gt;repr&lt;/em&gt; is non-zero, then this function will be called in response to repr(arr), otherwise the function will be called in response to str(arr). No check on whether or not &lt;em&gt;op&lt;/em&gt; is callable is performed. The callable passed in to &lt;em&gt;op&lt;/em&gt; should expect an array argument and should return a string to be printed.</source>
          <target state="translated">此函数使您可以将数组对象的tp_str和tp_repr方法更改为任何Python函数。因此，当从Python调用str（arr）或repr（arr）时，您可以更改所有数组的处理方式。要调用的函数作为&lt;em&gt;op&lt;/em&gt;传入。如果&lt;em&gt;repr&lt;/em&gt;不为零，则将响应repr（arr）调用此函数，否则将响应str（arr）调用该函数。不检查&lt;em&gt;op&lt;/em&gt;是否可调用。传递给&lt;em&gt;op&lt;/em&gt;的callable 应该有一个数组参数，并且应该返回要打印的字符串。</target>
        </trans-unit>
        <trans-unit id="3bb2d31f5b88cf1b316b3ceb02135e04993b15e9" translate="yes" xml:space="preserve">
          <source>This function assigns from the old to the new array by name, so the value of a field in the output array is the value of the field with the same name in the source array. This has the effect of creating a new ndarray containing only the fields &amp;ldquo;required&amp;rdquo; by the required_dtype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c8f95658bf6b7edc09d3adda4d0c4816cea136" translate="yes" xml:space="preserve">
          <source>This function behaves like PyUFunc_RegisterLoopForType above, except that it allows the user to register a 1-d loop using PyArray_Descr objects instead of dtype type num values. This allows a 1-d loop to be registered for structured array data-dtypes and custom data-types instead of scalar data-types.</source>
          <target state="translated">这个函数与上面的PyUFunc_RegisterLoopForType类似,只是它允许用户使用PyArray_Descr对象而不是dtype类型num值来注册一个1-d循环。这允许为结构化数组数据类型和自定义数据类型而不是标量数据类型注册一个1-d循环。</target>
        </trans-unit>
        <trans-unit id="e6245a8e454db1361715a92d11f03ae0bff098bc" translate="yes" xml:space="preserve">
          <source>This function can be exponentially slow for some inputs, unless &lt;code&gt;max_work&lt;/code&gt; is set to a finite number or &lt;code&gt;MAY_SHARE_BOUNDS&lt;/code&gt;. If in doubt, use &lt;a href=&quot;numpy.may_share_memory#numpy.may_share_memory&quot;&gt;&lt;code&gt;numpy.may_share_memory&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ac25efd0c9fb7e70f813509afc2d6139c57b07" translate="yes" xml:space="preserve">
          <source>This function changes the fill value of the masked array &lt;code&gt;a&lt;/code&gt; in place. If &lt;code&gt;a&lt;/code&gt; is not a masked array, the function returns silently, without doing anything.</source>
          <target state="translated">此函数在适当位置更改被遮罩数组 &lt;code&gt;a&lt;/code&gt; 的填充值。如果 &lt;code&gt;a&lt;/code&gt; 不是掩码数组，该函数将不执行任何操作而以静默方式返回。</target>
        </trans-unit>
        <trans-unit id="dc2a1bc44c01911d64ceae9284770c887ff15ab1" translate="yes" xml:space="preserve">
          <source>This function checks to see if &lt;em&gt;arr&lt;/em&gt; is a 0-dimensional array and, if so, returns the appropriate array scalar. It should be used whenever 0-dimensional arrays could be returned to Python.</source>
          <target state="translated">此函数检查&lt;em&gt;arr&lt;/em&gt;是否为0维数组，如果是，则返回适当的数组标量。只要0维数组可以返回给Python，就应该使用它。</target>
        </trans-unit>
        <trans-unit id="6e0d86a376dbbcdcd20b9ab0ced8ac2eae8ffe8a" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;N&lt;/em&gt;-dimensional discrete Fourier Transform over any number of axes in an &lt;em&gt;M&lt;/em&gt;-dimensional array by means of the Fast Fourier Transform (FFT).</source>
          <target state="translated">此函数通过快速傅立叶变换（FFT）计算&lt;em&gt;M&lt;/em&gt;维数组中任意数量轴上的&lt;em&gt;N&lt;/em&gt;维离散傅立叶变换。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f34d917f1e7128a56a07b81dc929875f904b8a8c" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;n&lt;/em&gt;-dimensional discrete Fourier Transform over any axes in an &lt;em&gt;M&lt;/em&gt;-dimensional array by means of the Fast Fourier Transform (FFT). By default, the transform is computed over the last two axes of the input array, i.e., a 2-dimensional FFT.</source>
          <target state="translated">此函数通过快速傅立叶变换（FFT）计算&lt;em&gt;M&lt;/em&gt;维数组中任何轴上的&lt;em&gt;n&lt;/em&gt;维离散傅立叶变换。默认情况下，转换是在输入数组的最后两个轴上进行的，即二维FFT。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8915bccc6bfc2e5b959f002fb985788d011a64f" translate="yes" xml:space="preserve">
          <source>This function computes the N-dimensional discrete Fourier Transform over any number of axes in an M-dimensional real array by means of the Fast Fourier Transform (FFT). By default, all axes are transformed, with the real transform performed over the last axis, while the remaining transforms are complex.</source>
          <target state="translated">该函数通过快速傅立叶变换(FFT)计算M维实数组中任意数量轴上的N维离散傅立叶变换。默认情况下,所有轴都被变换,实数变换在最后一个轴上进行,而其余的变换是复数变换。</target>
        </trans-unit>
        <trans-unit id="b8c7b22438d176337766fd2e49c4b7cfc3e07bab" translate="yes" xml:space="preserve">
          <source>This function computes the correlation as generally defined in signal processing texts:</source>
          <target state="translated">该函数计算信号处理文本中一般定义的相关度。</target>
        </trans-unit>
        <trans-unit id="cd6ec7a4da9a308e6c6acab0d22d9735b9865d50" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the 2-dimensional discrete Fourier Transform over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;ifft2(fft2(a)) == a&lt;/code&gt; to within numerical accuracy. By default, the inverse transform is computed over the last two axes of the input array.</source>
          <target state="translated">此函数通过快速傅立叶变换（FFT）计算M维数组中任意数量的轴上的二维离散傅立叶变换的逆。换句话说， &lt;code&gt;ifft2(fft2(a)) == a&lt;/code&gt; 在数值精度内。默认情况下，逆变换是在输入数组的最后两个轴上计算的。</target>
        </trans-unit>
        <trans-unit id="1a4ebaf525beaf877d17151690d3a34bb9c59baf" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the N-dimensional discrete Fourier Transform for real input over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;irfftn(rfftn(a), a.shape) == a&lt;/code&gt; to within numerical accuracy. (The &lt;code&gt;a.shape&lt;/code&gt; is necessary like &lt;code&gt;len(a)&lt;/code&gt; is for &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt;, and for the same reason.)</source>
          <target state="translated">此函数通过快速傅立叶变换（FFT）计算M维数组中任意数量轴上的实际输入的N维离散傅立叶变换的逆。换句话说， &lt;code&gt;irfftn(rfftn(a), a.shape) == a&lt;/code&gt; 在数值精度内。（ &lt;code&gt;a.shape&lt;/code&gt; 是必需的，就像 &lt;code&gt;len(a)&lt;/code&gt; 出于&lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; 一样&lt;/a&gt;，并且出于相同的原因。）</target>
        </trans-unit>
        <trans-unit id="0c7a0cee522d4ce9c957b628834b82e1d28defa5" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the N-dimensional discrete Fourier Transform over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;ifftn(fftn(a)) == a&lt;/code&gt; to within numerical accuracy. For a description of the definitions and conventions used, see &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数通过快速傅立叶变换（FFT）在M维数组中的任意数量的轴上计算N维离散傅立叶变换的逆。换句话说， &lt;code&gt;ifftn(fftn(a)) == a&lt;/code&gt; 在数值精度内。有关使用的定义和约定的描述，请参见&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2f9d73633ea8b8eb82a0685fcd08ea3505d9a66" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform of real input computed by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;. In other words, &lt;code&gt;irfft(rfft(a), len(a)) == a&lt;/code&gt; to within numerical accuracy. (See Notes below for why &lt;code&gt;len(a)&lt;/code&gt; is necessary here.)</source>
          <target state="translated">此函数计算由&lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt;计算的实际输入的一维&lt;em&gt;n&lt;/em&gt;点离散傅立叶变换的逆。换句话说， &lt;code&gt;irfft(rfft(a), len(a)) == a&lt;/code&gt; 在数值精度内。（有关为什么在这里需要 &lt;code&gt;len(a)&lt;/code&gt; 的信息,请参见下面的注释。）</target>
        </trans-unit>
        <trans-unit id="35acba32b3eea01535885b216d423da5ad809ed9" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier transform computed by &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;. In other words, &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; to within numerical accuracy. For a general description of the algorithm and definitions, see &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数计算由&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt;计算的一维&lt;em&gt;n&lt;/em&gt;点离散傅立叶变换的逆函数。换句话说， &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; 在数值精度内。有关算法和定义的一般说明，请参见&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad9d7d69d57ac9facd5b4f82ac6ba6f908913a31" translate="yes" xml:space="preserve">
          <source>This function computes the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform (DFT) of a real-valued array by means of an efficient algorithm called the Fast Fourier Transform (FFT).</source>
          <target state="translated">此函数通过称为快速傅里叶变换（FFT）的高效算法来计算实值数组的一维&lt;em&gt;n&lt;/em&gt;点离散傅里叶变换（DFT）。</target>
        </trans-unit>
        <trans-unit id="68ec181d19ee1190284573e044b4ba392f94f385" translate="yes" xml:space="preserve">
          <source>This function computes the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform (DFT) with the efficient Fast Fourier Transform (FFT) algorithm [CT].</source>
          <target state="translated">此函数使用高效的快速傅立叶变换（FFT）算法[CT] 计算一维&lt;em&gt;n&lt;/em&gt;点离散傅立叶变换（DFT）。</target>
        </trans-unit>
        <trans-unit id="30a498de56241e50f5fd1a10939273e87357615d" translate="yes" xml:space="preserve">
          <source>This function continues to be supported for backward compatibility, but you should prefer &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt;&lt;code&gt;moveaxis&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt;&lt;code&gt;moveaxis&lt;/code&gt;&lt;/a&gt; function was added in NumPy 1.11.</source>
          <target state="translated">继续支持此功能以实现向后兼容，但您最好选择&lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt; &lt;code&gt;moveaxis&lt;/code&gt; &lt;/a&gt;。该&lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt; &lt;code&gt;moveaxis&lt;/code&gt; &lt;/a&gt;在与NumPy 1.11添加功能。</target>
        </trans-unit>
        <trans-unit id="307209890a37b51bcd317c1d8679c25cf8cf32dc" translate="yes" xml:space="preserve">
          <source>This function creates a new neighborhood iterator from an existing iterator. The neighborhood will be computed relatively to the position currently pointed by &lt;em&gt;iter&lt;/em&gt;, the bounds define the shape of the neighborhood iterator, and the mode argument the boundaries handling mode.</source>
          <target state="translated">此函数从现有迭代器创建一个新的邻域迭代器。邻域将相对于&lt;em&gt;iter&lt;/em&gt;当前指向的位置进行计算，边界定义邻域迭代器的形状，而mode参数则是边界处理模式。</target>
        </trans-unit>
        <trans-unit id="33522609896e19e2c62ce4cc185c0f8e169d65db" translate="yes" xml:space="preserve">
          <source>This function does &lt;em&gt;not&lt;/em&gt; initialize the returned array; to do that use &lt;a href=&quot;numpy.zeros_like#numpy.zeros_like&quot;&gt;&lt;code&gt;zeros_like&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.ones_like#numpy.ones_like&quot;&gt;&lt;code&gt;ones_like&lt;/code&gt;&lt;/a&gt; instead. It may be marginally faster than the functions that do set the array values.</source>
          <target state="translated">此功能&lt;em&gt;未&lt;/em&gt;初始化返回的数组; 为此，请使用&lt;a href=&quot;numpy.zeros_like#numpy.zeros_like&quot;&gt; &lt;code&gt;zeros_like&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;numpy.ones_like#numpy.ones_like&quot;&gt; &lt;code&gt;ones_like&lt;/code&gt; &lt;/a&gt;。它可能比设置数组值的函数快一些。</target>
        </trans-unit>
        <trans-unit id="0decc5010e2e82ceb19b7a45f9d7da5f4f237524" translate="yes" xml:space="preserve">
          <source>This function does &lt;em&gt;not&lt;/em&gt; initialize the returned array; to do that use &lt;code&gt;zeros_like&lt;/code&gt; or &lt;code&gt;ones_like&lt;/code&gt; instead. It may be marginally faster than the functions that do set the array values.</source>
          <target state="translated">此功能&lt;em&gt;未&lt;/em&gt;初始化返回的数组; 为此，请使用 &lt;code&gt;zeros_like&lt;/code&gt; 或 &lt;code&gt;ones_like&lt;/code&gt; 。它可能比设置数组值的函数快一些。</target>
        </trans-unit>
        <trans-unit id="960581e2e13399cd79a7bf3c883aeb7b8d2e979d" translate="yes" xml:space="preserve">
          <source>This function does not check the contents of the input, only that the type is MaskType. In particular, this function returns False if the mask has a flexible dtype.</source>
          <target state="translated">这个函数不检查输入的内容,只检查类型是否为MaskType。特别是,如果掩码具有灵活的dtype,该函数返回False。</target>
        </trans-unit>
        <trans-unit id="0a232150acd8a12e027d94aeed56f5ff4aae9f46" translate="yes" xml:space="preserve">
          <source>This function does not enforce that the blocks lie on a fixed grid. &lt;code&gt;np.block([[a, b], [c, d]])&lt;/code&gt; is not restricted to arrays of the form:</source>
          <target state="translated">此功能不强制块位于固定的网格上。 &lt;code&gt;np.block([[a, b], [c, d]])&lt;/code&gt; 不限于以下形式的数组：</target>
        </trans-unit>
        <trans-unit id="6dc40074e04bdcad2b344dd285961cdc7ff85df9" translate="yes" xml:space="preserve">
          <source>This function does not losslessly round-trip in either direction.</source>
          <target state="translated">这个功能在两个方向上都不会无损往返。</target>
        </trans-unit>
        <trans-unit id="b71c712d42350c6a8a0c257c490e077558876dad" translate="yes" xml:space="preserve">
          <source>This function encapsulates the broadcasting rules. The &lt;em&gt;mit&lt;/em&gt; container should already contain iterators for all the arrays that need to be broadcast. On return, these iterators will be adjusted so that iteration over each simultaneously will accomplish the broadcasting. A negative number is returned if an error occurs.</source>
          <target state="translated">该功能封装了广播规则。在&lt;em&gt;麻省理工学院的&lt;/em&gt;容器应该已经包含了所有的阵列需要进行广播迭代器。返回时，将对这些迭代器进行调整，以便每个迭代器同时进行迭代将完成广播。如果发生错误，则返回负数。</target>
        </trans-unit>
        <trans-unit id="9bf48997cebca64928a72fe75ea6eb1ebc70dbfb" translate="yes" xml:space="preserve">
          <source>This function handles NaN comparisons as if NaN was a &amp;ldquo;normal&amp;rdquo; number. That is, AssertionError is not raised if both objects have NaNs in the same positions. This is in contrast to the IEEE standard on NaNs, which says that NaN compared to anything must return False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02f77dc9fbab1956d3050387654fd71594ea916" translate="yes" xml:space="preserve">
          <source>This function handles NaN comparisons as if NaN was a &amp;ldquo;normal&amp;rdquo; number. That is, no assertion is raised if both objects have NaNs in the same positions. This is in contrast to the IEEE standard on NaNs, which says that NaN compared to anything must return False.</source>
          <target state="translated">此函数处理NaN比较，就好像NaN是&amp;ldquo;正常&amp;rdquo;数字一样。也就是说，如果两个对象在相同位置都具有NaN，则不会引发任何断言。这与NaN的IEEE标准相反，后者说NaN与任何东西相比都必须返回False。</target>
        </trans-unit>
        <trans-unit id="d5f910d97d6aeb7075f641616a02d523dd4438a4" translate="yes" xml:space="preserve">
          <source>This function has been deprecated. Use randint instead.</source>
          <target state="translated">此函数已被废弃。使用randint代替。</target>
        </trans-unit>
        <trans-unit id="77fe5df00c0c7c8132af4661573c5a4cca000d13" translate="yes" xml:space="preserve">
          <source>This function has to be used with extreme care, see notes.</source>
          <target state="translated">此功能的使用要格外小心,请看说明。</target>
        </trans-unit>
        <trans-unit id="eade9f90c736ff6d6151ab5c5bf1151931416ec5" translate="yes" xml:space="preserve">
          <source>This function instead copies &amp;ldquo;by field name&amp;rdquo;, such that fields in the dst are assigned from the identically named field in the src. This applies recursively for nested structures. This is how structure assignment worked in numpy &amp;gt;= 1.6 to &amp;lt;= 1.13.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965a01bc9232ab2e9c3c470747ee3c2312761abb" translate="yes" xml:space="preserve">
          <source>This function is a compatibility alias for tobytes.</source>
          <target state="translated">这个函数是toby字节的兼容别名。</target>
        </trans-unit>
        <trans-unit id="a3014854fc3aff1db547e25e4accc358bdc45e8a" translate="yes" xml:space="preserve">
          <source>This function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.</source>
          <target state="translated">这个函数是tobytes的兼容别名。尽管它的名字叫 &quot;字节&quot;,但它返回的是字节而不是字符串。</target>
        </trans-unit>
        <trans-unit id="5bced6280c853e5763696660107e62b1e9050b26" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;mask_rowcols&lt;/code&gt; with &lt;code&gt;axis&lt;/code&gt; equal to 0.</source>
          <target state="translated">此功能的快捷方式 &lt;code&gt;mask_rowcols&lt;/code&gt; 与 &lt;code&gt;axis&lt;/code&gt; 等于0。</target>
        </trans-unit>
        <trans-unit id="892aad8c63a29b7082fcd31d81f9eafb9d342e8e" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;mask_rowcols&lt;/code&gt; with &lt;code&gt;axis&lt;/code&gt; equal to 1.</source>
          <target state="translated">此功能的快捷方式 &lt;code&gt;mask_rowcols&lt;/code&gt; 与 &lt;code&gt;axis&lt;/code&gt; 等于1。</target>
        </trans-unit>
        <trans-unit id="ebac1dd8653756fd79c832147de01fce0d7f87ae" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x != value).</source>
          <target state="translated">该函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =（x！=值）。</target>
        </trans-unit>
        <trans-unit id="ab411b054ab6959d52991c7253cba72df24e6757" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;gt; value).</source>
          <target state="translated">此函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =（x&amp;gt;值）。</target>
        </trans-unit>
        <trans-unit id="bf30dbf11727720fe8d30e29bf375cde077485f8" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;gt;= value).</source>
          <target state="translated">此函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =（x&amp;gt; =值）。</target>
        </trans-unit>
        <trans-unit id="af1053b8f0ec97d05015f270566c5b82959272a7" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;lt; value).</source>
          <target state="translated">该函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =（x &amp;lt;值）。</target>
        </trans-unit>
        <trans-unit id="f9189002c6a19182c690d1c6efc00b46a33f7232" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;lt;= value).</source>
          <target state="translated">该函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =（x &amp;lt;=值）。</target>
        </trans-unit>
        <trans-unit id="f46637928627180e5c802e1527edd637c13a58b6" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x == value). For floating point arrays, consider using &lt;code&gt;masked_values(x, value)&lt;/code&gt;.</source>
          <target state="translated">此函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =（x ==值）。对于浮点数组，请考虑使用 &lt;code&gt;masked_values(x, value)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4434dee55a64bbfebaafbec40077ada7cc2e4b4" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = ~(np.isfinite(a)). Any pre-existing mask is conserved. Only applies to arrays with a dtype where NaNs or infs make sense (i.e. floating point types), but accepts any array_like object.</source>
          <target state="translated">此函数是 &lt;code&gt;masked_where&lt;/code&gt; 的快捷方式， &lt;code&gt;condition&lt;/code&gt; =〜（np.isfinite（a））。保留任何先前存在的掩码。仅适用于具有NaN或infs有意义的dtype的数组（即浮点类型），但可以接受任何array_like对象。</target>
        </trans-unit>
        <trans-unit id="f28b126f5c6b2ce96d11bc92753f383ad4cd6485" translate="yes" xml:space="preserve">
          <source>This function is able to return one of eight different matrix norms, or one of an infinite number of vector norms (described below), depending on the value of the &lt;code&gt;ord&lt;/code&gt; parameter.</source>
          <target state="translated">根据 &lt;code&gt;ord&lt;/code&gt; 参数的值，此函数能够返回八个不同的矩阵范数之一，或无穷多个矢量范数之一（如下所述）。</target>
        </trans-unit>
        <trans-unit id="c1758140bc8fa9fd28fc8bc131c3f6321c42d5db" translate="yes" xml:space="preserve">
          <source>This function is capable of returning the condition number using one of seven different norms, depending on the value of &lt;code&gt;p&lt;/code&gt; (see Parameters below).</source>
          <target state="translated">此函数能够使用七个不同规范之一返回条件编号，具体取决于 &lt;code&gt;p&lt;/code&gt; 的值（请参见下面的参数）。</target>
        </trans-unit>
        <trans-unit id="7f257a627b846a11d8d82d4b0986234672c8d024" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;a href=&quot;#numpy.ma.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; except that masked values are treated as equal (default) or unequal, depending on the &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt;&lt;code&gt;masked_equal&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">此函数等效于&lt;a href=&quot;#numpy.ma.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; ,&lt;/a&gt;不同之处在于，根据&lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt; &lt;code&gt;masked_equal&lt;/code&gt; &lt;/a&gt;参数，将掩码值视为相等（默认值）或不相等。</target>
        </trans-unit>
        <trans-unit id="a3debc8695bd72584953abb12e719fb90548f7dd" translate="yes" xml:space="preserve">
          <source>This function is equivalent to calling the &amp;ldquo;compressed&amp;rdquo; method of a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt;&lt;code&gt;MaskedArray.compressed&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">此函数等效于调用&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;的&amp;ldquo; compressed&amp;rdquo;方法，有关详细信息，请参见&lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt; &lt;code&gt;MaskedArray.compressed&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="614f9af44de8bf025b95f7feb6cfbfad93376ecb" translate="yes" xml:space="preserve">
          <source>This function is equivalent to tuple axis arguments to reorderable ufuncs with keepdims=True. Tuple axis arguments to ufuncs have been available since version 1.7.0.</source>
          <target state="translated">这个函数相当于keepdims=True的可重排序ufuncs的元组轴参数。从1.7.0版本开始,ufuncs的元组轴参数就可以使用了。</target>
        </trans-unit>
        <trans-unit id="3c5d87f95304bba4f22f4f3bc79a0366620caeda" translate="yes" xml:space="preserve">
          <source>This function is exactly equivalent to &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;numpy.transpose&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数与&lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;numpy.transpose&lt;/code&gt; &lt;/a&gt;完全等效。</target>
        </trans-unit>
        <trans-unit id="0a042d76cb2129f19b61e5085381910d8b99bdbc" translate="yes" xml:space="preserve">
          <source>This function is intended to be used in EXTERNAL_LOOP mode only, and will produce some wrong answers when that mode is not enabled.</source>
          <target state="translated">该函数仅用于EXTERNAL_LOOP模式,当该模式未启用时,会产生一些错误的答案。</target>
        </trans-unit>
        <trans-unit id="d3aeb8a347cc701a9fec8946ae6c740c1103bc20" translate="yes" xml:space="preserve">
          <source>This function is not defined for complex-valued arguments; for the so-called argument of complex values, use &lt;a href=&quot;numpy.angle#numpy.angle&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">未为复数值参数定义此函数；对于所谓的复数参数，请使用&lt;a href=&quot;numpy.angle#numpy.angle&quot;&gt; &lt;code&gt;angle&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42c780622358a45155401477993b5d9d0b335549" translate="yes" xml:space="preserve">
          <source>This function is not designed to work with integers.</source>
          <target state="translated">这个函数不是设计用来处理整数的。</target>
        </trans-unit>
        <trans-unit id="ea62cc16ec217ef39d7f7c8e5969148da37fd3a3" translate="yes" xml:space="preserve">
          <source>This function is not implemented yet.</source>
          <target state="translated">这个功能还没有实现。</target>
        </trans-unit>
        <trans-unit id="b2f9356116ad7b6b9ba74a0d07b768457fca53e0" translate="yes" xml:space="preserve">
          <source>This function is obsolete and, because of changes due to relaxed stride checking, its return value for the same array may differ for versions of NumPy &amp;gt;= 1.10.0 and previous versions. If you only want to check if an array is Fortran contiguous use &lt;code&gt;a.flags.f_contiguous&lt;/code&gt; instead.</source>
          <target state="translated">此函数已过时，并且由于宽松的步幅检查导致的更改，对于NumPy&amp;gt; = 1.10.0的版本和以前的版本，同一数组的返回值可能会有所不同。如果只想检查数组是否为Fortran连续数组，请改用 &lt;code&gt;a.flags.f_contiguous&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="258358cbdd467c9c344ce8e3f9c85d0cd7f428e4" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt;&lt;code&gt;masked_values&lt;/code&gt;&lt;/a&gt;, but only suitable for object arrays: for floating point, use &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt;&lt;code&gt;masked_values&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">此函数类似于&lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt; &lt;code&gt;masked_values&lt;/code&gt; &lt;/a&gt;，但仅适用于对象数组：对于浮点，请改用&lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt; &lt;code&gt;masked_values&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42e4240c2bc84555a7f741757d674e8c82e565ad" translate="yes" xml:space="preserve">
          <source>This function is superceded by &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数由&lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; &lt;/a&gt;和/或&lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; &lt;/a&gt;取代。</target>
        </trans-unit>
        <trans-unit id="f3e20de601f3ca24a5ff2472df08d779de8dd632" translate="yes" xml:space="preserve">
          <source>This function is superceded by &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数由&lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; &lt;/a&gt;取代。</target>
        </trans-unit>
        <trans-unit id="223dd6fd50941f5cca2c485c95e8e5dc687d05fb" translate="yes" xml:space="preserve">
          <source>This function is superseded by &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0b6a66579ee7b8e064413a2fb5429da45dba58" translate="yes" xml:space="preserve">
          <source>This function is superseded by &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1ff7898f391050d07732317e1b4b4bc976ee58" translate="yes" xml:space="preserve">
          <source>This function is symmetric, but rarely associative.</source>
          <target state="translated">这个函数是对称的,但很少有关联的。</target>
        </trans-unit>
        <trans-unit id="fb34e601302a103a0946045a1719e9ad4309bf62" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;numpy.diag&lt;/code&gt;&lt;/a&gt; that takes masked values into account, see &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;numpy.diag&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">此函数等效于&lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;numpy.diag&lt;/code&gt; &lt;/a&gt;，它考虑了掩码值，有关详细信息，请参见&lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;numpy.diag&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="762735a831cc238bcd6be4852c06ac0013225a54" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.dot#numpy.dot&quot;&gt;&lt;code&gt;numpy.dot&lt;/code&gt;&lt;/a&gt; that takes masked values into account. Note that &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; are in different position than in the method version. In order to maintain compatibility with the corresponding method, it is recommended that the optional arguments be treated as keyword only. At some point that may be mandatory.</source>
          <target state="translated">此函数等效于&lt;a href=&quot;numpy.dot#numpy.dot&quot;&gt; &lt;code&gt;numpy.dot&lt;/code&gt; &lt;/a&gt;，它考虑了掩码值。请注意， &lt;code&gt;strict&lt;/code&gt; 和 &lt;code&gt;out&lt;/code&gt; 与方法版本中的位置不同。为了保持与相应方法的兼容性，建议将可选参数仅视为关键字。在某些时候这可能是强制性的。</target>
        </trans-unit>
        <trans-unit id="b3449fce446ccae1d5ae6c6d55107b82701f20fd" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt;&lt;code&gt;numpy.ediff1d&lt;/code&gt;&lt;/a&gt; that takes masked values into account, see &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt;&lt;code&gt;numpy.ediff1d&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">此函数等效于&lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt; &lt;code&gt;numpy.ediff1d&lt;/code&gt; &lt;/a&gt;，其中将掩码值考虑在内，有关详细信息，请参见&lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt; &lt;code&gt;numpy.ediff1d&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc125d9cdb2114a10df5933b4e6f500d1c08539d" translate="yes" xml:space="preserve">
          <source>This function is used to simplify access to fields nested in other fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48492051f92b9e0c98dfd72175da1464af62c22d" translate="yes" xml:space="preserve">
          <source>This function is useful for calculating a fill value suitable for taking the maximum of an array with a given dtype.</source>
          <target state="translated">这个函数对于计算一个适合于取一个给定dtype的数组的最大值的填充值很有用。</target>
        </trans-unit>
        <trans-unit id="514144ea48299b81c7b15dfcf631d31668bd3186" translate="yes" xml:space="preserve">
          <source>This function is useful for determining a common type that two or more arrays can be converted to. It only works for non-flexible array types as no itemsize information is passed. The &lt;em&gt;mintype&lt;/em&gt; argument represents the minimum type acceptable, and &lt;em&gt;op&lt;/em&gt; represents the object that will be converted to an array. The return value is the enumerated typenumber that represents the data-type that &lt;em&gt;op&lt;/em&gt; should have.</source>
          <target state="translated">此功能对于确定可以将两个或多个数组转换为的通用类型很有用。它仅适用于非灵活数组类型，因为没有传递项目大小信息。所述&lt;em&gt;mintype&lt;/em&gt;参数表示的最低可接受的类型，和&lt;em&gt;运算&lt;/em&gt;表示将被转换为一个数组的对象。返回值是枚举的类型编号，表示&lt;em&gt;op&lt;/em&gt;应该具有的数据类型。</target>
        </trans-unit>
        <trans-unit id="66ea2fa9dfd3553ca39f3787970de46499229028" translate="yes" xml:space="preserve">
          <source>This function is useful to be sure that an array with the correct flags is returned for passing to compiled code (perhaps through ctypes).</source>
          <target state="translated">这个函数很有用,可以确保返回一个带有正确标志的数组,以便传递给编译后的代码(也许通过ctypes)。</target>
        </trans-unit>
        <trans-unit id="8e9b1bcfe6f895f9426e7973caf7f080e53d5b02" translate="yes" xml:space="preserve">
          <source>This function is very similar to &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; above, but has an extra &lt;em&gt;identity_value&lt;/em&gt; argument, to define an arbitrary identity for the ufunc when &lt;code&gt;identity&lt;/code&gt; is passed as &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;.</source>
          <target state="translated">此函数与上面的 &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; 非常相似，但是具有一个额外的&lt;em&gt;identity_value&lt;/em&gt;参数，用于在将 &lt;code&gt;identity&lt;/code&gt; 作为 &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; 传递时定义ufunc的任意身份。</target>
        </trans-unit>
        <trans-unit id="e6ae878f05630a69160b11c652744c88c73b83f7" translate="yes" xml:space="preserve">
          <source>This function is very similar to PyUFunc_FromFuncAndData above, but has an extra &lt;em&gt;signature&lt;/em&gt; argument, to define a &lt;a href=&quot;c-api.generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;generalized universal functions&lt;/a&gt;. Similarly to how ufuncs are built around an element-by-element operation, gufuncs are around subarray-by-subarray operations, the &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; defining the subarrays to operate on.</source>
          <target state="translated">该函数与上面的PyUFunc_FromFuncAndData非常相似，但是具有一个额外的&lt;em&gt;签名&lt;/em&gt;参数，以定义&lt;a href=&quot;c-api.generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;通用的通用函数&lt;/a&gt;。与如何在逐个元素的操作周围构建ufunc相似，gufuncs围绕每个子数组操作（&lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;签名&lt;/a&gt;定义要对其进行操作的子数组）。</target>
        </trans-unit>
        <trans-unit id="7d7c3c059d66b50ac25de48e14a9110e6ed62010" translate="yes" xml:space="preserve">
          <source>This function is very similar to PyUFunc_FromFuncAndData above, but has an extra &lt;em&gt;signature&lt;/em&gt; argument, to define a &lt;a href=&quot;generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;generalized universal functions&lt;/a&gt;. Similarly to how ufuncs are built around an element-by-element operation, gufuncs are around subarray-by-subarray operations, the &lt;a href=&quot;generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; defining the subarrays to operate on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc77b4e140ac75bc9ac3e89d41f38fc73185d22" translate="yes" xml:space="preserve">
          <source>This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.stack#numpy.stack&quot;&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.block#numpy.block&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; provide more general stacking and concatenation operations.</source>
          <target state="translated">此功能对于最多3维的数组最有意义。例如，对于具有高度（第一轴），宽度（第二轴）和r / g / b通道（第三轴）的像素数据。函数&lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.stack#numpy.stack&quot;&gt; &lt;code&gt;stack&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.block#numpy.block&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt;提供更多常规的堆叠和串联操作。</target>
        </trans-unit>
        <trans-unit id="f7b019770de00d4d47b09eabe135d2ae721a995a" translate="yes" xml:space="preserve">
          <source>This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions &lt;a href=&quot;numpy.ma.concatenate#numpy.ma.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.ma.stack#numpy.ma.stack&quot;&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;block&lt;/code&gt; provide more general stacking and concatenation operations.</source>
          <target state="translated">此功能对于最多3维的数组最有意义。例如，对于具有高度（第一轴），宽度（第二轴）和r / g / b通道（第三轴）的像素数据。函数&lt;a href=&quot;numpy.ma.concatenate#numpy.ma.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.ma.stack#numpy.ma.stack&quot;&gt; &lt;code&gt;stack&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;block&lt;/code&gt; 提供更多常规的堆叠和串联操作。</target>
        </trans-unit>
        <trans-unit id="f15e5fa1742619380116b3f34a00c85d55366c55" translate="yes" xml:space="preserve">
          <source>This function may also be used as a decorator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d585b637d27940cc37d90ebf4940a9aa2e521b5d" translate="yes" xml:space="preserve">
          <source>This function may be safely called without holding the Python GIL.</source>
          <target state="translated">这个函数可以在不持有Python GIL的情况下安全调用。</target>
        </trans-unit>
        <trans-unit id="cd200e9dfe3f17be99d159e426b6fa9331db61ec" translate="yes" xml:space="preserve">
          <source>This function may only be called if the iterator is tracking a multi-index and if &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt;&lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt;&lt;/a&gt; was used to prevent an axis from being iterated in reverse order.</source>
          <target state="translated">仅当迭代器正在跟踪多索引并且使用&lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt; &lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt; &lt;/a&gt;来防止以相反的顺序迭代轴时，才可以调用此函数。</target>
        </trans-unit>
        <trans-unit id="6ca18036fbf762cae2043baf8ac3fa8494d28495" translate="yes" xml:space="preserve">
          <source>This function must be called in the initialization section of a module that will make use of the C-API. It imports the module where the function-pointer table is stored and points the correct variable to it.</source>
          <target state="translated">这个函数必须在一个将使用C-API的模块的初始化部分被调用。它导入存储函数指针表的模块,并将正确的变量指向它。</target>
        </trans-unit>
        <trans-unit id="cf5ee49acb54388d21032f90f2de16dca9ddb6c3" translate="yes" xml:space="preserve">
          <source>This function must take two arguments, &lt;code&gt;func(a, axis)&lt;/code&gt;.</source>
          <target state="translated">此函数必须 &lt;code&gt;func(a, axis)&lt;/code&gt; 两个参数func（a，axis）。</target>
        </trans-unit>
        <trans-unit id="dba1259c24481a4a54d81a8fdecff9fadce8f02f" translate="yes" xml:space="preserve">
          <source>This function only shuffles the array along the first axis of a multi-dimensional array. The order of sub-arrays is changed but their contents remains the same.</source>
          <target state="translated">这个函数只是沿着多维数组的第一轴对数组进行洗牌。子数组的顺序被改变,但其内容保持不变。</target>
        </trans-unit>
        <trans-unit id="68ca7042b267a7f2923f8a89cc886956d3a640a1" translate="yes" xml:space="preserve">
          <source>This function provides greater precision than &lt;code&gt;exp(x) - 1&lt;/code&gt; for small values of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">对于较小的 &lt;code&gt;x&lt;/code&gt; ,此函数提供的精度比 &lt;code&gt;exp(x) - 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40a3f0ad0a26c2dcd1667ccf5fd0beae55099939" translate="yes" xml:space="preserve">
          <source>This function reads from the system entropy pool and so samples are not reproducible. In particular, it does &lt;em&gt;NOT&lt;/em&gt; make use of a BitGenerator, and so &lt;code&gt;seed&lt;/code&gt; and setting &lt;code&gt;state&lt;/code&gt; have no effect.</source>
          <target state="translated">此函数从系统熵池中读取数据，因此样本不可重现。特别是，它&lt;em&gt;不是&lt;/em&gt;利用一个BitGenerator的，所以 &lt;code&gt;seed&lt;/code&gt; 和设置 &lt;code&gt;state&lt;/code&gt; 没有任何效果。</target>
        </trans-unit>
        <trans-unit id="326a3290cbe737031cbcfe2c255c104d77bb6d98" translate="yes" xml:space="preserve">
          <source>This function returns a (C-style) contiguous and behaved function array from any nested sequence or array interface exporting object, &lt;em&gt;op&lt;/em&gt;, of (non-flexible) type given by the enumerated &lt;em&gt;typenum&lt;/em&gt;, of minimum depth &lt;em&gt;min_depth&lt;/em&gt;, and of maximum depth &lt;em&gt;max_depth&lt;/em&gt;. Equivalent to a call to &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; with requirements set to &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; and the type_num member of the type argument set to &lt;em&gt;typenum&lt;/em&gt;.</source>
          <target state="translated">此函数从枚举&lt;em&gt;typenum&lt;/em&gt;给出的（非灵活）类型，最小深度&lt;em&gt;min_depth&lt;/em&gt;和最大深度&lt;em&gt;max_depth的&lt;/em&gt;任何嵌套序列或数组接口导出对象&lt;em&gt;op&lt;/em&gt;返回一个（C风格）连续且行为良好的函数数组。等效于对&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;的调用，其要求设置为&lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; ,&lt;/a&gt;并且类型参数的type_num成员设置为&lt;em&gt;typenum&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd99a05c88fddf54e9c57ac9cd52857632e3d1f8" translate="yes" xml:space="preserve">
          <source>This function returns a boolean ndarray with all entries False, that can be used in common mask manipulations. If a complex dtype is specified, the type of each field is converted to a boolean type.</source>
          <target state="translated">该函数返回一个布尔型ndarray,所有条目均为False,可用于常见的掩码操作。如果指定了复杂的dtype,则每个字段的类型会被转换为布尔类型。</target>
        </trans-unit>
        <trans-unit id="d5e7626c8e43009c9d0e23e7f2d941b6cb967b32" translate="yes" xml:space="preserve">
          <source>This function returns the absolute values (positive magnitude) of the data in &lt;code&gt;x&lt;/code&gt;. Complex values are not handled, use &lt;a href=&quot;numpy.absolute#numpy.absolute&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; to find the absolute values of complex data.</source>
          <target state="translated">此函数返回 &lt;code&gt;x&lt;/code&gt; 中数据的绝对值（正值）。不处理复杂值，请使用&lt;a href=&quot;numpy.absolute#numpy.absolute&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt;查找复杂数据的绝对值。</target>
        </trans-unit>
        <trans-unit id="89fee3e999f1c558b74709781bf21911d5dc8fa4" translate="yes" xml:space="preserve">
          <source>This function returns the value</source>
          <target state="translated">该函数返回值</target>
        </trans-unit>
        <trans-unit id="1cc55e517c256ea42c557b8b54e3efb3b6cafcb6" translate="yes" xml:space="preserve">
          <source>This function returns the values:</source>
          <target state="translated">该函数返回值。</target>
        </trans-unit>
        <trans-unit id="a6d07b33b778389f427bd3ca9fc11f04feb25982" translate="yes" xml:space="preserve">
          <source>This function should accept 1-D arrays. It is applied to 1-D slices of &lt;code&gt;arr&lt;/code&gt; along the specified axis.</source>
          <target state="translated">此函数应接受一维数组。它将沿指定轴应用于 &lt;code&gt;arr&lt;/code&gt; 的一维切片。</target>
        </trans-unit>
        <trans-unit id="5cfabdc0232ab8cc8ac575fbc0d4dec6b2dd7bf7" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;arr&lt;/em&gt;.</source>
          <target state="translated">该函数窃取了对&lt;em&gt;arr&lt;/em&gt;的引用。</target>
        </trans-unit>
        <trans-unit id="3ceff3d1be740072d08fa441617d883813e56f19" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt; if it is not NULL.</source>
          <target state="translated">如果该函数不为NULL，则它将窃取对&lt;em&gt;descr&lt;/em&gt;的引用。</target>
        </trans-unit>
        <trans-unit id="8281b58eb98855581eef0364cfa182f403baf433" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="translated">该函数窃取了对&lt;em&gt;descr&lt;/em&gt;的引用。</target>
        </trans-unit>
        <trans-unit id="71bb778b3ae86d2314883f6bdb50a6590499183c" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt;. The easiest way to get one is using &lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数窃取了对&lt;em&gt;descr&lt;/em&gt;的引用。最简单的方法是使用&lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6d42633714a13d2a78f3f69e93cf9d52e8a857e" translate="yes" xml:space="preserve">
          <source>This function supports both indexing conventions through the indexing keyword argument. Giving the string &amp;lsquo;ij&amp;rsquo; returns a meshgrid with matrix indexing, while &amp;lsquo;xy&amp;rsquo; returns a meshgrid with Cartesian indexing. In the 2-D case with inputs of length M and N, the outputs are of shape (N, M) for &amp;lsquo;xy&amp;rsquo; indexing and (M, N) for &amp;lsquo;ij&amp;rsquo; indexing. In the 3-D case with inputs of length M, N and P, outputs are of shape (N, M, P) for &amp;lsquo;xy&amp;rsquo; indexing and (M, N, P) for &amp;lsquo;ij&amp;rsquo; indexing. The difference is illustrated by the following code snippet:</source>
          <target state="translated">此函数通过indexing关键字参数支持两种索引约定。给定字符串&amp;ldquo; ij&amp;rdquo;将返回带有矩阵索引的网格，而&amp;ldquo; xy&amp;rdquo;将返回带有笛卡尔索引的网格。在输入长度为M和N的2-D情况下，对于&amp;ldquo; xy&amp;rdquo;索引，输出的形状为（N，M），对于&amp;ldquo; ij&amp;rdquo;索引，输出的形状为（M，N）。在输入长度为M，N和P的3-D情况下，对于&amp;ldquo; xy&amp;rdquo;索引，输出的形状为（N，M，P），对于&amp;ldquo; ij&amp;rdquo;索引的输出的形状为（M，N，P）。以下代码片段说明了这种差异：</target>
        </trans-unit>
        <trans-unit id="e857d76db9c7bac209f1715cec1437cf523540d8" translate="yes" xml:space="preserve">
          <source>This function swaps half-spaces for all axes listed (defaults to all). Note that &lt;code&gt;y[0]&lt;/code&gt; is the Nyquist component only if &lt;code&gt;len(x)&lt;/code&gt; is even.</source>
          <target state="translated">此功能为列出的所有轴交换半角空格（默认为全部）。注意，仅当 &lt;code&gt;len(x)&lt;/code&gt; 为偶数时， &lt;code&gt;y[0]&lt;/code&gt; 是奈奎斯特分量。</target>
        </trans-unit>
        <trans-unit id="a7870153b27cca4d6c02a86ec8c830b616e4b3c3" translate="yes" xml:space="preserve">
          <source>This function takes N 1-D sequences and returns N outputs with N dimensions each, such that the shape is 1 in all but one dimension and the dimension with the non-unit shape value cycles through all N dimensions.</source>
          <target state="translated">这个函数接收N个1-D序列,并返回N个输出,每个输出有N个维度,这样除了一个维度外,其他维度的形状都是1,并且非单位形状值的维度在所有N个维度中循环。</target>
        </trans-unit>
        <trans-unit id="b4e43f62f7a361a5fb222fc70fbd3c26bd5104e6" translate="yes" xml:space="preserve">
          <source>This function takes a multi-iterator object that has been previously &amp;ldquo;broadcasted,&amp;rdquo; finds the dimension with the smallest &amp;ldquo;sum of strides&amp;rdquo; in the broadcasted result and adapts all the iterators so as not to iterate over that dimension (by effectively making them of length-1 in that dimension). The corresponding dimension is returned unless &lt;em&gt;mit&lt;/em&gt; -&amp;gt;nd is 0, then -1 is returned. This function is useful for constructing ufunc-like routines that broadcast their inputs correctly and then call a strided 1-d version of the routine as the inner-loop. This 1-d version is usually optimized for speed and for this reason the loop should be performed over the axis that won&amp;rsquo;t require large stride jumps.</source>
          <target state="translated">此函数采用一个先前已&amp;ldquo;广播&amp;rdquo;的多迭代器对象，在广播结果中找到具有最小&amp;ldquo;步长和&amp;rdquo;的维度，并调整所有迭代器，以免在该维度上进行迭代（通过有效地使它们成为该尺寸的长度为1）。除非&lt;em&gt;mit-&lt;/em&gt; &amp;gt; nd为0，否则返回相应的维，然后返回-1。此函数对于构造类似ufunc的例程非常有用，这些例程可以正确广播其输入，然后将该例程的跨步1-d版本称为内部循环。通常针对速度优化此一维版本，因此，应在不需要大步幅跳动的轴上执行循环。</target>
        </trans-unit>
        <trans-unit id="102958a161ae2e87757cf73f96956c3988a66269" translate="yes" xml:space="preserve">
          <source>This function uses the same algorithm as the builtin python &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_left&quot;&gt;&lt;code&gt;bisect.bisect_left&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;side='left'&lt;/code&gt;) and &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_right&quot;&gt;&lt;code&gt;bisect.bisect_right&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;side='right'&lt;/code&gt;) functions, which is also vectorized in the &lt;code&gt;v&lt;/code&gt; argument.</source>
          <target state="translated">该函数使用与内置python &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_left&quot;&gt; &lt;code&gt;bisect.bisect_left&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;side='left'&lt;/code&gt; ）和&lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_right&quot;&gt; &lt;code&gt;bisect.bisect_right&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;side='right'&lt;/code&gt; ）函数相同的算法，它们也在 &lt;code&gt;v&lt;/code&gt; 参数中向量化。</target>
        </trans-unit>
        <trans-unit id="f4a094c15ea96c9120e1bb02da934b3ab9299caa" translate="yes" xml:space="preserve">
          <source>This function will not demote complex to float or anything to boolean, but will demote a signed integer to an unsigned integer when the scalar value is positive.</source>
          <target state="translated">这个函数不会将复数降级为float,也不会将任何东西降级为boolean,但会在标量值为正值时将有符号整数降级为无符号整数。</target>
        </trans-unit>
        <trans-unit id="e431cb683c0bc7c35e7633e888e952e4559756e5" translate="yes" xml:space="preserve">
          <source>This function will not preserve masking of MaskedArray inputs.</source>
          <target state="translated">这个函数不会保留MaskedArray输入的掩码。</target>
        </trans-unit>
        <trans-unit id="2a9b1f287c173d330577d2300449ee4dfd3daa91" translate="yes" xml:space="preserve">
          <source>This function works on subclasses of ndarray like &lt;a href=&quot;numpy.ma.array#numpy.ma.array&quot;&gt;&lt;code&gt;ma.array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数适用于ndarray的子​​类，如&lt;a href=&quot;numpy.ma.array#numpy.ma.array&quot;&gt; &lt;code&gt;ma.array&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6a52abd835e7532e9891ffc574fd5f4220e58bc" translate="yes" xml:space="preserve">
          <source>This function works similarly to &lt;a href=&quot;#c.PyArray_ObjectType&quot;&gt;&lt;code&gt;PyArray_ObjectType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) except it handles flexible arrays. The &lt;em&gt;mintype&lt;/em&gt; argument can have an itemsize member and the &lt;em&gt;outtype&lt;/em&gt; argument will have an itemsize member at least as big but perhaps bigger depending on the object &lt;em&gt;op&lt;/em&gt;.</source>
          <target state="translated">此函数与&lt;a href=&quot;#c.PyArray_ObjectType&quot;&gt; &lt;code&gt;PyArray_ObjectType&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）相似，但它处理灵活的数组。该&lt;em&gt;mintype&lt;/em&gt;参数可以有一个itemsize部件和&lt;em&gt;outtype&lt;/em&gt;参数将有至少一个itemsize成员一样大，但也许更大的取决于物体&lt;em&gt;运&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="24bfcaf02c26210c6ce475ff904488dd4e86859f" translate="yes" xml:space="preserve">
          <source>This functionality can be obtained via &lt;a href=&quot;numpy.diag_indices#numpy.diag_indices&quot;&gt;&lt;code&gt;diag_indices&lt;/code&gt;&lt;/a&gt;, but internally this version uses a much faster implementation that never constructs the indices and uses simple slicing.</source>
          <target state="translated">可以通过&lt;a href=&quot;numpy.diag_indices#numpy.diag_indices&quot;&gt; &lt;code&gt;diag_indices&lt;/code&gt; &lt;/a&gt;获得此功能，但是在内部，此版本使用更快的实现，该实现从不构造索引并且使用简单的切片。</target>
        </trans-unit>
        <trans-unit id="8df0c373fc062bf47c7c593de18498c118dd2c34" translate="yes" xml:space="preserve">
          <source>This general purpose 1-d core function assumes that &lt;em&gt;func&lt;/em&gt; is a string representing a method of the input object that takes one argument. The first argument in &lt;em&gt;args&lt;/em&gt; is the method whose function is called, the second argument in &lt;em&gt;args&lt;/em&gt; is the argument passed to the function. The output of the function is stored in the third entry of &lt;em&gt;args&lt;/em&gt;.</source>
          <target state="translated">该通用的1-d核心函数假定&lt;em&gt;func&lt;/em&gt;是一个字符串，表示一个输入参数的方法，该方法采用一个参数。在第一个参数&lt;em&gt;ARGS&lt;/em&gt;是其功能被调用时，在第二个参数的方法&lt;em&gt;ARGS&lt;/em&gt;是传递给函数的自变量。函数的输出存储在&lt;em&gt;args&lt;/em&gt;的第三项中。</target>
        </trans-unit>
        <trans-unit id="71fb70d934e71392e5b977e3d5908e6d14ba65f1" translate="yes" xml:space="preserve">
          <source>This general purpose 1-d core function assumes that &lt;em&gt;func&lt;/em&gt; is a string representing a method of the input object. For each iteration of the loop, the Python object is extracted from the array and its &lt;em&gt;func&lt;/em&gt; method is called returning the result to the output array.</source>
          <target state="translated">该通用的1-d核心函数假定&lt;em&gt;func&lt;/em&gt;是表示输入对象的方法的字符串。对于循环的每次迭代，都会从数组中提取Python对象，并调用其&lt;em&gt;func&lt;/em&gt;方法，将结果返回到输出数组。</target>
        </trans-unit>
        <trans-unit id="ebe1403d50c0fdb0002abff6822f498479faa88e" translate="yes" xml:space="preserve">
          <source>This geometrical property can be seen in two dimensions by plotting generated data-points:</source>
          <target state="translated">这种几何属性可以通过绘制生成的数据点在二维度上看到。</target>
        </trans-unit>
        <trans-unit id="e1dc7a565ca8eeac49fa065474eb2fca785df357" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; data pointers. If &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; was not specified, each data pointer points to the current data item of the iterator. If no inner iteration was specified, it points to the first data item of the inner loop.</source>
          <target state="translated">这将返回一个指向 &lt;code&gt;nop&lt;/code&gt; 数据指针的指针。如果未指定&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;，则每个数据指针都指向迭代器的当前数据项。如果未指定内部迭代，则它指向内部循环的第一个数据项。</target>
        </trans-unit>
        <trans-unit id="ad9e42c674af93de7c3d00b721f840bb2a3ba388" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; data type Descrs for the objects being iterated. The result points into &lt;code&gt;iter&lt;/code&gt;, so the caller does not gain any references to the Descrs.</source>
          <target state="translated">这将返回指向要迭代的对象的 &lt;code&gt;nop&lt;/code&gt; 数据类型Descrs 的指针。结果指向 &lt;code&gt;iter&lt;/code&gt; ，因此调用方不会获得对Descrs的任何引用。</target>
        </trans-unit>
        <trans-unit id="04484c93294b17e48ec0072eb06cb15b6ce824d8" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; operand PyObjects that are being iterated. The result points into &lt;code&gt;iter&lt;/code&gt;, so the caller does not gain any references to the PyObjects.</source>
          <target state="translated">这将返回指向正在迭代的 &lt;code&gt;nop&lt;/code&gt; 操作数PyObject 的指针。结果指向 &lt;code&gt;iter&lt;/code&gt; ，因此调用方不会获得对PyObjects的任何引用。</target>
        </trans-unit>
        <trans-unit id="de4914e9685130ac5234ec503748e2bb51b5d569" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the index being tracked, or NULL if no index is being tracked. It is only useable if one of the flags &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt; were specified during construction.</source>
          <target state="translated">这将返回指向被跟踪索引的指针，如果没有索引被跟踪，则返回NULL。仅在构造期间指定了标志&lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; &lt;/a&gt;之一时才可用。</target>
        </trans-unit>
        <trans-unit id="76e1c3a277ebfaa2cffaf967d76cec0c7e8df194" translate="yes" xml:space="preserve">
          <source>This gives back a reference to a new ndarray view, which is a view into the i-th object in the array &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt;, whose dimensions and strides match the internal optimized iteration pattern. A C-order iteration of this view is equivalent to the iterator&amp;rsquo;s iteration order.</source>
          <target state="translated">这将返回对新ndarray视图的引用，该视图是对&lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt; &lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt; &lt;/a&gt;数组中第i个对象的视图，其尺寸和步幅与内部优化的迭代模式匹配。此视图的C顺序迭代等效于迭代器的迭代顺序。</target>
        </trans-unit>
        <trans-unit id="5203e44570d99c05fcfa2df4337f300e46c186be" translate="yes" xml:space="preserve">
          <source>This group is used to call code that may take some time but does not use any Python C-API calls. Thus, the GIL should be released during its calculation.</source>
          <target state="translated">该组用于调用可能需要一些时间但不使用任何 Python C-API 调用的代码。因此,GIL应该在其计算过程中被释放。</target>
        </trans-unit>
        <trans-unit id="5bcd38e59fd6cf93688e83d10245c536ddb55a3a" translate="yes" xml:space="preserve">
          <source>This group is used to re-acquire the Python GIL after it has been released. For example, suppose the GIL has been released (using the previous calls), and then some path in the code (perhaps in a different subroutine) requires use of the Python C-API, then these macros are useful to acquire the GIL. These macros accomplish essentially a reverse of the previous three (acquire the LOCK saving what state it had) and then re-release it with the saved state.</source>
          <target state="translated">这组用于在Python GIL被释放后重新获取它。例如,假设 GIL 已经被释放 (使用前面的调用),然后在代码中的某些路径 (可能在不同的子程序中)需要使用 Python C-API,那么这些宏就可以用来获取 GIL。这些宏基本上完成了前面三个宏的反转(获取LOCK保存它的状态),然后用保存的状态重新释放它。</target>
        </trans-unit>
        <trans-unit id="22e8bed5de814991ce18d8f44ecb60dc6c28da78" translate="yes" xml:space="preserve">
          <source>This info dict can then be used as input to a &lt;a href=&quot;../distutils#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594238b01d9d524cb6fb409e28f8c563967eda11" translate="yes" xml:space="preserve">
          <source>This information will be collected in writing, and whenever possible the group&amp;rsquo;s deliberations will be recorded and retained (i.e. chat transcripts, email discussions, recorded conference calls, summaries of voice conversations, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11fb823e6d137af2611381a853679838cd294872" translate="yes" xml:space="preserve">
          <source>This interface describes homogeneous arrays in the sense that each item of the array has the same &amp;ldquo;type&amp;rdquo;. This type can be very simple or it can be a quite arbitrary and complicated C-like structure.</source>
          <target state="translated">从某种意义上说，此接口从阵列的每个项目具有相同的&amp;ldquo;类型&amp;rdquo;的角度描述同类阵列。这种类型可以非常简单，也可以是相当任意和复杂的类C结构。</target>
        </trans-unit>
        <trans-unit id="669065ebaf0e163f0816c64449775393f24910fd" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;numpy.flatiter#numpy.flatiter&quot;&gt;&lt;code&gt;numpy.flatiter&lt;/code&gt;&lt;/a&gt; instance, which acts similarly to, but is not a subclass of, Python&amp;rsquo;s built-in iterator object.</source>
          <target state="translated">这是一个&lt;a href=&quot;numpy.flatiter#numpy.flatiter&quot;&gt; &lt;code&gt;numpy.flatiter&lt;/code&gt; &lt;/a&gt;实例，其行为类似于Python的内置迭代器对象，但不是其子类。</target>
        </trans-unit>
        <trans-unit id="c616752b11f5b5590e848100c7afe1eff6eb31fb" translate="yes" xml:space="preserve">
          <source>This is a convenience function for quick storage of array data. Information on endianness and precision is lost, so this method is not a good choice for files intended to archive data or transport data between machines with different endianness. Some of these problems can be overcome by outputting the data as text files, at the expense of speed and file size.</source>
          <target state="translated">这是一个快速存储阵列数据的方便功能。由于丢失了迭度和精度的信息,所以这种方法并不适合用于存档数据或在不同迭度的机器之间传输数据的文件。其中一些问题可以通过将数据输出为文本文件来解决,但要牺牲速度和文件大小。</target>
        </trans-unit>
        <trans-unit id="e143678de16b85b14841ff12151066d84f46e8b0" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637f2f7f4587e6fab14f3bc29737254f8ece5452" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;a href=&quot;numpy.random.standard_normal#numpy.random.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aebce3c953e4d7a8aa40a69097fcdae621194f4a" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;code&gt;numpy.random.random_sample&lt;/code&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于用户从Matlab移植代码来说，这是一个便利功能，它包装了 &lt;code&gt;numpy.random.random_sample&lt;/code&gt; 。该函数使用一个元组来指定输出的大小，这与其他NumPy函数（例如&lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; )一致&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a8395276aef2b1c09ac3507c06c6aeae1c56edd" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;code&gt;numpy.random.standard_normal&lt;/code&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于用户从Matlab移植代码来说，这是一个便利功能，它包装了 &lt;code&gt;numpy.random.standard_normal&lt;/code&gt; 。该函数使用一个元组来指定输出的大小，这与其他NumPy函数（例如&lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; )一致&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14bed771c7ecf5fb5c7f3988c3e80ea720b90d56" translate="yes" xml:space="preserve">
          <source>This is a convenience, legacy function.</source>
          <target state="translated">这是一个方便、遗留的功能。</target>
        </trans-unit>
        <trans-unit id="8386d98dd4fd3fd3372da264e738d2eec8c472de" translate="yes" xml:space="preserve">
          <source>This is a default converter for output arrays given to functions. If &lt;em&gt;obj&lt;/em&gt; is &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt;&lt;code&gt;Py_None&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;NULL&lt;/code&gt;, then &lt;em&gt;*address&lt;/em&gt; will be &lt;code&gt;NULL&lt;/code&gt; but the call will succeed. If &lt;a href=&quot;#c.PyArray_Check&quot;&gt;&lt;code&gt;PyArray_Check&lt;/code&gt;&lt;/a&gt; ( &lt;em&gt;obj&lt;/em&gt;) is TRUE then it is returned in &lt;em&gt;*address&lt;/em&gt; without incrementing its reference count.</source>
          <target state="translated">这是给函数提供输出数组的默认转换器。如果&lt;em&gt;obj&lt;/em&gt;是&lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt; &lt;code&gt;Py_None&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;NULL&lt;/code&gt; ，则&lt;em&gt;* address&lt;/em&gt;将为 &lt;code&gt;NULL&lt;/code&gt; ,但调用将成功。如果&lt;a href=&quot;#c.PyArray_Check&quot;&gt; &lt;code&gt;PyArray_Check&lt;/code&gt; &lt;/a&gt;（&lt;em&gt;obj&lt;/em&gt;）为TRUE，则它将在&lt;em&gt;* address中&lt;/em&gt;返回而不增加其引用计数。</target>
        </trans-unit>
        <trans-unit id="ebf6bd0b70f0575c64ee3df5fdd00ac441de460d" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to C99 copysign: return x with the same sign as y. Works for any value, including inf and nan. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">这个函数相当于C99的copysign:返回与y相同符号的x。对任何值都有效,包括inf和nan。后缀f和l可用于单精度和扩展精度。</target>
        </trans-unit>
        <trans-unit id="9c5d9b74232b5b43fdac1227d638313277afa572" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to C99 nextafter: return next representable floating point value from x in the direction of y. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">这是一个相当于C99 nextafter的函数:从x向y的方向返回下一个可表示的浮点数,单精度和扩展精度可以用后缀f和l来表示。</target>
        </trans-unit>
        <trans-unit id="6cef9e65ee084ca1f09a67a21a4b3ef4b9523383" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to Fortran intrinsic. Return distance between x and next representable floating point value from x, e.g. spacing(1) == eps. spacing of nan and +/- inf return nan. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">这是一个相当于Fortran本征的函数。返回 x 与 x 之间的距离,例如 spacing(1)==eps.间距为 nan 和 +/-inf 返回 nan.单个和扩展的精度可以用后缀f和l来表示。</target>
        </trans-unit>
        <trans-unit id="f691a7cca2d5bab9d5322a451f5071b060431b18" translate="yes" xml:space="preserve">
          <source>This is a function pointer for getting the current iterator multi-index, returned by &lt;a href=&quot;#c.NpyIter_GetGetMultiIndex&quot;&gt;&lt;code&gt;NpyIter_GetGetMultiIndex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是一个函数指针，用于获取由&lt;a href=&quot;#c.NpyIter_GetGetMultiIndex&quot;&gt; &lt;code&gt;NpyIter_GetGetMultiIndex&lt;/code&gt; &lt;/a&gt;返回的当前迭代器多索引。</target>
        </trans-unit>
        <trans-unit id="afe9f9d9e5612f0c43f0b6f2ab1ddbf98d2077ed" translate="yes" xml:space="preserve">
          <source>This is a function pointer for the iteration loop, returned by &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt;&lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是迭代循环的函数指针，由&lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt; &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt; &lt;/a&gt;返回。</target>
        </trans-unit>
        <trans-unit id="682e5efdefc09e15bb711f19c6e22c6512c8e3c9" translate="yes" xml:space="preserve">
          <source>This is a list of flags for each operand. At minimum, one of &lt;code&gt;readonly&lt;/code&gt;, &lt;code&gt;readwrite&lt;/code&gt;, or &lt;code&gt;writeonly&lt;/code&gt; must be specified.</source>
          <target state="translated">这是每个操作数的标志的列表。至少必须指定 &lt;code&gt;readonly&lt;/code&gt; ， &lt;code&gt;readwrite&lt;/code&gt; 或 &lt;code&gt;writeonly&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="daee1c27087ebe5008ffab37bf86e6cef5520692" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isfinite: works for single, double and extended precision, and return a non 0 value is x is neither a NaN nor an infinity.</source>
          <target state="translated">这是一个宏,相当于C99 isfinite:适用于单精度、双精度和扩展精度,并返回一个非0值,即x既不是NaN也不是无穷大。</target>
        </trans-unit>
        <trans-unit id="80381bd72606c65ade88008349bbceb47f771261" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isinf: works for single, double and extended precision, and return a non 0 value is x is infinite (positive and negative).</source>
          <target state="translated">这是一个宏,相当于C99 isinf:适用于单精度、双精度和扩展精度,并返回一个非0值,即x是无限的(正和负)。</target>
        </trans-unit>
        <trans-unit id="0a2766c5fc1ee9982025de76ae4aa9f68ecd22db" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isnan: works for single, double and extended precision, and return a non 0 value is x is a NaN.</source>
          <target state="translated">这是一个宏,相当于C99 isnan:适用于单精度、双精度和扩展精度,并在x是NaN时返回一个非0值。</target>
        </trans-unit>
        <trans-unit id="ba072edcddb8314e48393832fd145a168df5e278" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 signbit: works for single, double and extended precision, and return a non 0 value is x has the signbit set (that is the number is negative).</source>
          <target state="translated">这是一个宏,相当于C99的signbit:适用于单精度、双精度和扩展精度,并在x有signbit设置时返回一个非0值(即数字为负)。</target>
        </trans-unit>
        <trans-unit id="e912c91523a3cdb66f72696d355ab45d0a9a414f" translate="yes" xml:space="preserve">
          <source>This is a relatively robust method to compare two arrays whose amplitude is variable.</source>
          <target state="translated">这是一种比较稳健的方法,用于比较两个振幅可变的数组。</target>
        </trans-unit>
        <trans-unit id="f9e98f643e268bceb892d520470f87f06bd3ffa1" translate="yes" xml:space="preserve">
          <source>This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="daaf8424b18b172abdada56262484be0114cb050" translate="yes" xml:space="preserve">
          <source>This is a setup.py file for the above code. As before, the module can be build via calling python setup.py build at the command prompt, or installed to site-packages via python setup.py install.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6ff4b3ee0d226dd43f100afc9a5e9fc743a95d" translate="yes" xml:space="preserve">
          <source>This is a simple way to build up arrays quickly. There are two use cases.</source>
          <target state="translated">这是一种快速建立数组的简单方法。有两个用例。</target>
        </trans-unit>
        <trans-unit id="5bf246dfc26ef7aa2b64da9e4b03eace45db2857" translate="yes" xml:space="preserve">
          <source>This is a special flag that is set if this array represents a copy made because a user required certain flags in &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; and a copy had to be made of some other array (and the user asked for this flag to be set in such a situation). The base attribute then points to the &amp;ldquo;misbehaved&amp;rdquo; array (which is set read_only). :c:func`PyArray_ResolveWritebackIfCopy` will copy its contents back to the &amp;ldquo;misbehaved&amp;rdquo; array (casting if necessary) and will reset the &amp;ldquo;misbehaved&amp;rdquo; array to &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;. If the &amp;ldquo;misbehaved&amp;rdquo; array was not &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; to begin with then &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; would have returned an error because &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; would not have been possible.</source>
          <target state="translated">这是一个特殊标志，如果此数组表示由于用户需要&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; 中的&lt;/a&gt;某些标志而必须复制某个其他数组（并且用户要求在这种情况下设置此标志）而制作的副本，则设置该标志。 。然后，基本属性指向&amp;ldquo;行为异常&amp;rdquo;数组（设置为read_only）。 ：c：func`PyArray_ResolveWritebackIfCopy`将其内容复制回&amp;ldquo;行为不当&amp;rdquo;数组（如有必要，进行广播），并将&amp;ldquo;行为不当&amp;rdquo;数组重置为&lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;。如果&amp;ldquo;不当行为&amp;rdquo;数组不是以&lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;开头的，则&lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt;将返回错误，因为&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d494bbd6ea4e55e23b6320030cf19b92084fb2cb" translate="yes" xml:space="preserve">
          <source>This is a very flexible function; &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.array_str#numpy.array_str&quot;&gt;&lt;code&gt;array_str&lt;/code&gt;&lt;/a&gt; are using &lt;a href=&quot;#numpy.array2string&quot;&gt;&lt;code&gt;array2string&lt;/code&gt;&lt;/a&gt; internally so keywords with the same name should work identically in all three functions.</source>
          <target state="translated">这是一个非常灵活的功能；&lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.array_str#numpy.array_str&quot;&gt; &lt;code&gt;array_str&lt;/code&gt; &lt;/a&gt;在内部使用&lt;a href=&quot;#numpy.array2string&quot;&gt; &lt;code&gt;array2string&lt;/code&gt; ,&lt;/a&gt;因此具有相同名称的关键字在所有三个函数中应相同地工作。</target>
        </trans-unit>
        <trans-unit id="4a20d6c5e13bf5949cf2f01fed00be4a85ee83c8" translate="yes" xml:space="preserve">
          <source>This is a wrapper around &lt;code&gt;cPickle.dump&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;cPickle.dump&lt;/code&gt; 的包装。</target>
        </trans-unit>
        <trans-unit id="72c0baacc027dca1b05db754f60ee813fa6dbfcf" translate="yes" xml:space="preserve">
          <source>This is a wrapper around &lt;code&gt;cPickle.dumps&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;cPickle.dumps&lt;/code&gt; 的包装。</target>
        </trans-unit>
        <trans-unit id="b6ae9c5b7de866ac0dd1b4b58c7a54bd18149043" translate="yes" xml:space="preserve">
          <source>This is almost the same as the result of PyArray_CanCastTypeTo(PyArray_MinScalarType(arr), totype, casting), but it also handles a special case arising because the set of uint values is not a subset of the int values for types with the same number of bits.</source>
          <target state="translated">这与PyArray_CanCastTypeTo(PyArray_MinScalarType(arr),totype,casting)的结果几乎是一样的,但它也处理了一种特殊情况,因为uint值的集合不是具有相同位数的类型的int值的子集。</target>
        </trans-unit>
        <trans-unit id="06d558ced35712eb9368208c693942a96aac9510" translate="yes" xml:space="preserve">
          <source>This is an alias of &lt;a href=&quot;generated/numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be9e8aa17773bdb0efb0eec1cc4294398d93d4d" translate="yes" xml:space="preserve">
          <source>This is an alias of &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt; for the complete documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abef17cd5a41150617b797dd34026cad2a72bcf3" translate="yes" xml:space="preserve">
          <source>This is an example of a func specialized for addition of doubles returning doubles.</source>
          <target state="translated">这是一个专门用于双倍加法返回双倍的函数的例子。</target>
        </trans-unit>
        <trans-unit id="8d1fbd89490e7598a40d0ab430364ea01d0cff36" translate="yes" xml:space="preserve">
          <source>This is an interface to the LAPACK routines &lt;code&gt;dgeqrf&lt;/code&gt;, &lt;code&gt;zgeqrf&lt;/code&gt;, &lt;code&gt;dorgqr&lt;/code&gt;, and &lt;code&gt;zungqr&lt;/code&gt;.</source>
          <target state="translated">这是LAPACK例程 &lt;code&gt;dgeqrf&lt;/code&gt; ， &lt;code&gt;zgeqrf&lt;/code&gt; ， &lt;code&gt;dorgqr&lt;/code&gt; 和 &lt;code&gt;zungqr&lt;/code&gt; 的接口。</target>
        </trans-unit>
        <trans-unit id="944d000b70e8d3d375939368b9ee8662949fdd56" translate="yes" xml:space="preserve">
          <source>This is an iterator object that makes it easy to loop over an N-dimensional array. It is the object returned from the flat attribute of an ndarray. It is also used extensively throughout the implementation internals to loop over an N-dimensional array. The tp_as_mapping interface is implemented so that the iterator object can be indexed (using 1-d indexing), and a few methods are implemented through the tp_methods table. This object implements the next method and can be used anywhere an iterator can be used in Python.</source>
          <target state="translated">这是一个迭代器对象,它可以很容易地对一个N维数组进行循环。它是由ndarray的flat属性返回的对象。在整个实现内部,它也被广泛地用于在一个N维数组上循环。tp_as_mapping接口的实现使得迭代器对象可以被索引(使用1-d索引),并且通过tp_methods表实现了一些方法。这个对象实现了下一个方法,可以在Python中任何可以使用迭代器的地方使用。</target>
        </trans-unit>
        <trans-unit id="39877197a88959914be74b4d252daeba988b0567" translate="yes" xml:space="preserve">
          <source>This is an iterator object that makes it easy to loop over an N-dimensional neighborhood.</source>
          <target state="translated">这是一个迭代器对象,可以很容易地在一个N维邻域上进行循环。</target>
        </trans-unit>
        <trans-unit id="ed4488f4638f84c1e1e4b827cf0b8579c8c851e4" translate="yes" xml:space="preserve">
          <source>This is an opaque pointer type for the iterator. Access to its contents can only be done through the iterator API.</source>
          <target state="translated">这是迭代器的不透明指针类型。对其内容的访问只能通过迭代器API来完成。</target>
        </trans-unit>
        <trans-unit id="b4c12ec7da04774c2971488c28da077dd954ab73" translate="yes" xml:space="preserve">
          <source>This is defined for &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;, &lt;strong&gt;SHORT&lt;/strong&gt;, &lt;strong&gt;INT&lt;/strong&gt;, &lt;strong&gt;LONG&lt;/strong&gt;, &lt;strong&gt;LONGLONG&lt;/strong&gt;, &lt;strong&gt;INTP&lt;/strong&gt;</source>
          <target state="translated">为 &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;，&lt;strong&gt;SHORT&lt;/strong&gt;，&lt;strong&gt;INT&lt;/strong&gt;，&lt;strong&gt;LONG&lt;/strong&gt;，&lt;strong&gt;LONGLONG&lt;/strong&gt;，&lt;strong&gt;INTP定义&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1cb38ad4a8a5f0f7eaad9358f9b24fff730b48c2" translate="yes" xml:space="preserve">
          <source>This is defined for all defined for &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;, &lt;strong&gt;UBYTE&lt;/strong&gt;, &lt;strong&gt;SHORT&lt;/strong&gt;, &lt;strong&gt;USHORT&lt;/strong&gt;, &lt;strong&gt;INT&lt;/strong&gt;, &lt;strong&gt;UINT&lt;/strong&gt;, &lt;strong&gt;LONG&lt;/strong&gt;, &lt;strong&gt;ULONG&lt;/strong&gt;, &lt;strong&gt;LONGLONG&lt;/strong&gt;, &lt;strong&gt;ULONGLONG&lt;/strong&gt;, &lt;strong&gt;INTP&lt;/strong&gt;, &lt;strong&gt;UINTP&lt;/strong&gt;</source>
          <target state="translated">为 &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;，&lt;strong&gt;UBYTE&lt;/strong&gt;，&lt;strong&gt;SHORT&lt;/strong&gt;，&lt;strong&gt;USHORT&lt;/strong&gt;，&lt;strong&gt;INT&lt;/strong&gt;，&lt;strong&gt;UINT&lt;/strong&gt;，&lt;strong&gt;LONG&lt;/strong&gt;，&lt;strong&gt;ULONG&lt;/strong&gt;，&lt;strong&gt;LONGLONG&lt;/strong&gt;，&lt;strong&gt;ULONGLONG&lt;/strong&gt;，&lt;strong&gt;INTP&lt;/strong&gt;，&lt;strong&gt;UINTP&lt;/strong&gt;定义的所有定义&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e53b90b8b35ae60046587f59e89f7b60e6df85a" translate="yes" xml:space="preserve">
          <source>This is different from &lt;a href=&quot;numpy.load#numpy.load&quot;&gt;&lt;code&gt;numpy.load&lt;/code&gt;&lt;/a&gt;, which does not use cPickle but loads the NumPy binary .npy format.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.load#numpy.load&quot;&gt; &lt;code&gt;numpy.load&lt;/code&gt; &lt;/a&gt;不同，后者不使用cPickle而是加载NumPy二进制.npy格式。</target>
        </trans-unit>
        <trans-unit id="ad4d2eb9b0ee11d28c4e5a349ba480c6768dfc79" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt; and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">这等效于（但比其快）以下对&lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; 的使用&lt;/a&gt;，后者将 &lt;code&gt;ii&lt;/code&gt; 和 &lt;code&gt;kk&lt;/code&gt; 设置为索引元组：</target>
        </trans-unit>
        <trans-unit id="f5170749efab413ba3776c33568562d9c4634a7d" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">这等效于（但比其快）以下对&lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; 的&lt;/a&gt;使用，它将 &lt;code&gt;ii&lt;/code&gt; ， &lt;code&gt;jj&lt;/code&gt; 和 &lt;code&gt;kk&lt;/code&gt; 中的每一个设置为一个索引元组：</target>
        </trans-unit>
        <trans-unit id="f723a36a0fdceaf5add767f4dfa10dbdef0cf27e" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;code&gt;ndindex&lt;/code&gt; and &lt;code&gt;s_&lt;/code&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">这等效于（但比其快）以下对 &lt;code&gt;ndindex&lt;/code&gt; 和 &lt;code&gt;s_&lt;/code&gt; 的使用，它将 &lt;code&gt;ii&lt;/code&gt; ， &lt;code&gt;jj&lt;/code&gt; 和 &lt;code&gt;kk&lt;/code&gt; 中的每一个设置为一个索引元组：</target>
        </trans-unit>
        <trans-unit id="9623032760a445ce084ed7cad1f49c8e81cbc730" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.compress(ravel(condition), ravel(arr))&lt;/code&gt;. If &lt;code&gt;condition&lt;/code&gt; is boolean &lt;code&gt;np.extract&lt;/code&gt; is equivalent to &lt;code&gt;arr[condition]&lt;/code&gt;.</source>
          <target state="translated">这等效于 &lt;code&gt;np.compress(ravel(condition), ravel(arr))&lt;/code&gt; 。如果 &lt;code&gt;condition&lt;/code&gt; 为布尔值，则 &lt;code&gt;np.extract&lt;/code&gt; 等效于 &lt;code&gt;arr[condition]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="512416aca8fa4fb317d305f7a3902a8f4f57268d" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt;, see &lt;code&gt;extras.compress_rowcols&lt;/code&gt; for details.</source>
          <target state="translated">这等效于 &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt; ，有关详细信息，请参见 &lt;code&gt;extras.compress_rowcols&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1aabefa5df0b67ecae64f8e5a2fb2a4d5dd2e5ee" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt;, see &lt;code&gt;extras.compress_rowcols&lt;/code&gt; for details.</source>
          <target state="translated">这等效于 &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt; ，有关详细信息，请参见 &lt;code&gt;extras.compress_rowcols&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e12dd8fc795d33b8f8bcabb847c3e158c738c5e" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the first axis after 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N)&lt;/code&gt;. Rebuilds arrays divided by &lt;a href=&quot;numpy.vsplit#numpy.vsplit&quot;&gt;&lt;code&gt;vsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这等效于形状 &lt;code&gt;(N,)&lt;/code&gt; 的一维数组已重整为 &lt;code&gt;(1,N)&lt;/code&gt; 后沿第一轴进行连接。重建除以&lt;a href=&quot;numpy.vsplit#numpy.vsplit&quot;&gt; &lt;code&gt;vsplit&lt;/code&gt; 的&lt;/a&gt;数组。</target>
        </trans-unit>
        <trans-unit id="8a1612db7b39849ef3a6bd08b64bed8c3240f816" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the first axis after 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N)&lt;/code&gt;. Rebuilds arrays divided by &lt;code&gt;vsplit&lt;/code&gt;.</source>
          <target state="translated">这等效于形状 &lt;code&gt;(N,)&lt;/code&gt; 的一维数组已重整为 &lt;code&gt;(1,N)&lt;/code&gt; 后沿第一轴进行连接。重建除以 &lt;code&gt;vsplit&lt;/code&gt; 的数组。</target>
        </trans-unit>
        <trans-unit id="e9676c88264ef3cd76556860f143548d10e94eb6" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the second axis, except for 1-D arrays where it concatenates along the first axis. Rebuilds arrays divided by &lt;a href=&quot;numpy.hsplit#numpy.hsplit&quot;&gt;&lt;code&gt;hsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这等效于沿第二个轴的串联，除了一维数组沿第一个轴的串联。重建除以&lt;a href=&quot;numpy.hsplit#numpy.hsplit&quot;&gt; &lt;code&gt;hsplit&lt;/code&gt; 的&lt;/a&gt;数组。</target>
        </trans-unit>
        <trans-unit id="e6a5b26fca5a2a732affc24a30a8305bc7f4ee4d" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the second axis, except for 1-D arrays where it concatenates along the first axis. Rebuilds arrays divided by &lt;a href=&quot;numpy.ma.hsplit#numpy.ma.hsplit&quot;&gt;&lt;code&gt;hsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这等效于沿第二个轴的串联，除了一维数组沿第一个轴的串联。重建除以&lt;a href=&quot;numpy.ma.hsplit#numpy.ma.hsplit&quot;&gt; &lt;code&gt;hsplit&lt;/code&gt; 的&lt;/a&gt;数组。</target>
        </trans-unit>
        <trans-unit id="5f3f85e2c1a9f572b9f43cddeb78f8794cecabcf" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the third axis after 2-D arrays of shape &lt;code&gt;(M,N)&lt;/code&gt; have been reshaped to &lt;code&gt;(M,N,1)&lt;/code&gt; and 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N,1)&lt;/code&gt;. Rebuilds arrays divided by &lt;a href=&quot;numpy.dsplit#numpy.dsplit&quot;&gt;&lt;code&gt;dsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这等效于形状 &lt;code&gt;(M,N)&lt;/code&gt; 的 2-D数组已重塑为 &lt;code&gt;(M,N,1)&lt;/code&gt; 和形状 &lt;code&gt;(N,)&lt;/code&gt; 的 1-D数组已重塑为 &lt;code&gt;(1,N,1)&lt;/code&gt; 。重建除以&lt;a href=&quot;numpy.dsplit#numpy.dsplit&quot;&gt; &lt;code&gt;dsplit&lt;/code&gt; 的&lt;/a&gt;数组。</target>
        </trans-unit>
        <trans-unit id="5c6f9c31ab715a660b4d23dc2f49389f45ea5bda" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the third axis after 2-D arrays of shape &lt;code&gt;(M,N)&lt;/code&gt; have been reshaped to &lt;code&gt;(M,N,1)&lt;/code&gt; and 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N,1)&lt;/code&gt;. Rebuilds arrays divided by &lt;code&gt;dsplit&lt;/code&gt;.</source>
          <target state="translated">这等效于形状 &lt;code&gt;(M,N)&lt;/code&gt; 的 2-D数组已重塑为 &lt;code&gt;(M,N,1)&lt;/code&gt; 和形状 &lt;code&gt;(N,)&lt;/code&gt; 的 1-D数组已重塑为 &lt;code&gt;(1,N,1)&lt;/code&gt; 。重建除以 &lt;code&gt;dsplit&lt;/code&gt; 的数组。</target>
        </trans-unit>
        <trans-unit id="d218a0a3e8c4c5860255504a9ba19c22b6fab14a" translate="yes" xml:space="preserve">
          <source>This is equivalent to np.nonzero(np.ravel(a))[0].</source>
          <target state="translated">这相当于np.nonzero(np.ravel(a))[0]。</target>
        </trans-unit>
        <trans-unit id="c1506fb5159fec603ce600935782977e9cc4a640" translate="yes" xml:space="preserve">
          <source>This is equivalent to the &lt;code&gt;density&lt;/code&gt; argument, but produces incorrect results for unequal bin widths. It should not be used.</source>
          <target state="translated">这等效于 &lt;code&gt;density&lt;/code&gt; 参数，但是对于不等的箱宽会产生不正确的结果。不应使用。</target>
        </trans-unit>
        <trans-unit id="59cfbae4022883700bb27212977a0aea4a1ca893" translate="yes" xml:space="preserve">
          <source>This is equivalent to the buffer object structure in Python up to the ptr member. On 32-bit platforms (&lt;em&gt;i.e.&lt;/em&gt; if &lt;a href=&quot;c-api.config#c.NPY_SIZEOF_INT&quot;&gt;&lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt;&lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt;), the len member also matches an equivalent member of the buffer object. It is useful to represent a generic single-segment chunk of memory.</source>
          <target state="translated">这等效于Python中直到ptr成员的缓冲区对象结构。在32位平台上（&lt;em&gt;即，&lt;/em&gt;如果&lt;a href=&quot;c-api.config#c.NPY_SIZEOF_INT&quot;&gt; &lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt; &lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt; ），len成员还匹配缓冲区对象的等效成员。表示通用的单段内存块很有用。</target>
        </trans-unit>
        <trans-unit id="0f80c76f4b696fc66848fb5ef4ea2fb36f89e0f9" translate="yes" xml:space="preserve">
          <source>This is equivalent to the buffer object structure in Python up to the ptr member. On 32-bit platforms (&lt;em&gt;i.e.&lt;/em&gt; if &lt;a href=&quot;config#c.NPY_SIZEOF_INT&quot;&gt;&lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt;&lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt;), the len member also matches an equivalent member of the buffer object. It is useful to represent a generic single-segment chunk of memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">这相当于:</target>
        </trans-unit>
        <trans-unit id="71a0da6263af85d6d95df709a66cce1cab814a13" translate="yes" xml:space="preserve">
          <source>This is for output arrays, and requires that the flag &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt;&lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt;&lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt;&lt;/a&gt; be set. If &lt;code&gt;op[i]&lt;/code&gt; is NULL, creates a new array with the final broadcast dimensions, and a layout matching the iteration order of the iterator.</source>
          <target state="translated">这是针对输出数组的，要求设置标志&lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt; &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt; &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;op[i]&lt;/code&gt; 为NULL，则创建一个具有最终广播尺寸的新数组，以及一个与迭代器的迭代顺序匹配的布局。</target>
        </trans-unit>
        <trans-unit id="e43476e1c5b08d4915c75da838fbd060f4d5522a" translate="yes" xml:space="preserve">
          <source>This is how subclasses of the ndarray class are able to return views that preserve the class type. When taking a view, the standard ndarray machinery creates the new ndarray object with something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="271064c73ce5e7dc4de339611f7b4db1a780a7f2" translate="yes" xml:space="preserve">
          <source>This is implemented using the &lt;code&gt;_geev&lt;/code&gt; LAPACK routines which compute the eigenvalues and eigenvectors of general square arrays.</source>
          <target state="translated">这是使用 &lt;code&gt;_geev&lt;/code&gt; LAPACK例程实现的，该例程计算通用方阵的特征值和特征向量。</target>
        </trans-unit>
        <trans-unit id="caec4ff4a054237a51c7a499531b302398f70bf8" translate="yes" xml:space="preserve">
          <source>This is indicated in the documentation via input parameter specifications such as &lt;code&gt;a : (..., M, M) array_like&lt;/code&gt;. This means that if for instance given an input array &lt;code&gt;a.shape == (N, M, M)&lt;/code&gt;, it is interpreted as a &amp;ldquo;stack&amp;rdquo; of N matrices, each of size M-by-M. Similar specification applies to return values, for instance the determinant has &lt;code&gt;det : (...)&lt;/code&gt; and will in this case return an array of shape &lt;code&gt;det(a).shape == (N,)&lt;/code&gt;. This generalizes to linear algebra operations on higher-dimensional arrays: the last 1 or 2 dimensions of a multidimensional array are interpreted as vectors or matrices, as appropriate for each operation.</source>
          <target state="translated">这在文档中通过输入参数规范来指示，例如 &lt;code&gt;a : (..., M, M) array_like&lt;/code&gt; 。这意味着，例如，如果给定输入数组 &lt;code&gt;a.shape == (N, M, M)&lt;/code&gt; ，则将其解释为N个矩阵的&amp;ldquo;堆栈&amp;rdquo;，每个矩阵的大小为M&amp;times;M。类似的规范适用于返回值，例如行列式具有 &lt;code&gt;det : (...)&lt;/code&gt; ，在这种情况下将返回一个形状为 &lt;code&gt;det(a).shape == (N,)&lt;/code&gt; 的数组。这可以概括为对高维数组的线性代数运算：多维数组的最后1或2维被视作矢量或矩阵，视每个运算而定。</target>
        </trans-unit>
        <trans-unit id="142401db7b88684f56ec37cbd8f1ca65b6bf6771" translate="yes" xml:space="preserve">
          <source>This is intended for working with source directories that are in an SVN repository.</source>
          <target state="translated">这是为处理SVN仓库中的源目录而设计的。</target>
        </trans-unit>
        <trans-unit id="f497c1d2afa9510500c0e5d52cafff444023b2a6" translate="yes" xml:space="preserve">
          <source>This is needed by all Python objects. It consists of (at least) a reference count member ( &lt;code&gt;ob_refcnt&lt;/code&gt; ) and a pointer to the typeobject ( &lt;code&gt;ob_type&lt;/code&gt; ). (Other elements may also be present if Python was compiled with special options see Include/object.h in the Python source tree for more information). The ob_type member points to a Python type object.</source>
          <target state="translated">所有Python对象都需要这样做。它至少由一个引用计数成员（ &lt;code&gt;ob_refcnt&lt;/code&gt; ）和一个指向类型对象的指针（ &lt;code&gt;ob_type&lt;/code&gt; ）组成。（如果使用特殊选项编译Python，则其他元素也可能存在，有关更多信息，请参见Python源代码树中的Include / object.h）。ob_type成员指向Python类型对象。</target>
        </trans-unit>
        <trans-unit id="1833467ed646c8f15235c25f8dda305acdfb6a3c" translate="yes" xml:space="preserve">
          <source>This is not a comprehensive &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; reference. It&amp;rsquo;s tailored to the &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; hosting service. You may well find better or quicker ways of getting stuff done with &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;, but these should get you started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a35d83e287759b7b772b39fa92c000861d127f" translate="yes" xml:space="preserve">
          <source>This is often used when a function returns multiple values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daec8aebc5133f38a1a0c690c98645fa0bf3cd6e" translate="yes" xml:space="preserve">
          <source>This is particularly useful for evaluating functions of multiple dimensions on a regular grid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d53d8ee495c7f638b914dab0d30642c949b736" translate="yes" xml:space="preserve">
          <source>This is presumably the most common case of large array creation. The details, of course, depend greatly on the format of data on disk and so this section can only give general pointers on how to handle various formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8997d00c105166c9b4b9f773f5d0cdd6fa01f2" translate="yes" xml:space="preserve">
          <source>This is raised when an binary operation is passed Poly objects with different domains.</source>
          <target state="translated">当二进制操作被传递给具有不同域的Poly对象时,会引发此问题。</target>
        </trans-unit>
        <trans-unit id="e57f721854d8f362e4016c48c315f6301f247f80" translate="yes" xml:space="preserve">
          <source>This is really &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt; with different defaults. For more details see &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用不同的默认值确实很&lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt; &lt;code&gt;irfftn&lt;/code&gt; &lt;/a&gt;。有关更多详细信息，请参见&lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt; &lt;code&gt;irfftn&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed9f359368f007790ca5657cc8ec4082492a200b" translate="yes" xml:space="preserve">
          <source>This is really just &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt; with different default behavior. For more details see &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这实际上只是具有不同默认行为的&lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt;。有关更多详细信息，请参见&lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="77938c782ff5f0e5fde7cba046a7d880a01771f8" translate="yes" xml:space="preserve">
          <source>This is reasonable enough, but watch out if you want to use Python&amp;rsquo;s &lt;code&gt;+=&lt;/code&gt; construct, as it may not do what you expect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef26806f6ea74b6485ab483c2778eff715e4572" translate="yes" xml:space="preserve">
          <source>This is short-hand for &lt;code&gt;np.r_['-1,2,0', index expression]&lt;/code&gt;, which is useful because of its common occurrence. In particular, arrays will be stacked along their last axis after being upgraded to at least 2-D with 1&amp;rsquo;s post-pended to the shape (column vectors made out of 1-D arrays).</source>
          <target state="translated">这是 &lt;code&gt;np.r_['-1,2,0', index expression]&lt;/code&gt; ，因为它很常见，所以很有用。特别是，在将阵列升级到至少2维且其后缀为1的形状（列矢量由1维阵列组成）之后，阵列将沿其最后一个轴堆叠。</target>
        </trans-unit>
        <trans-unit id="1c88394abdc65a1b05a8dd5d8683693375531a89" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) except you specify the data-type descriptor with &lt;em&gt;type_num&lt;/em&gt; and &lt;em&gt;itemsize&lt;/em&gt;, where &lt;em&gt;type_num&lt;/em&gt; corresponds to a builtin (or user-defined) type. If the type always has the same number of bytes, then itemsize is ignored. Otherwise, itemsize specifies the particular size of this array.</source>
          <target state="translated">这类似于&lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt;（&amp;hellip;），不同之处在于您使用&lt;em&gt;type_num&lt;/em&gt;和&lt;em&gt;itemsize&lt;/em&gt;指定数据类型描述符，其中&lt;em&gt;type_num&lt;/em&gt;对应于内置（或用户定义）类型。如果类型始终具有相同的字节数，则将忽略itemsize。否则，itemsize指定此数组的特定大小。</target>
        </trans-unit>
        <trans-unit id="ed43500d52b0e3a9d4bae70ddb5bfbe100ff1dd8" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;numpy.logspace#numpy.logspace&quot;&gt;&lt;code&gt;logspace&lt;/code&gt;&lt;/a&gt;, but with endpoints specified directly. Each output sample is a constant multiple of the previous.</source>
          <target state="translated">这类似于&lt;a href=&quot;numpy.logspace#numpy.logspace&quot;&gt; &lt;code&gt;logspace&lt;/code&gt; &lt;/a&gt;，但是直接指定了端点。每个输出样本是前一个样本的恒定倍数。</target>
        </trans-unit>
        <trans-unit id="c5fcd33629df929b0bdb1a57cfbe776ef13fe120" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;apply_along_axis&lt;/code&gt;, but treats the fields of a structured array as an extra axis. The fields are all first cast to a common type following the type-promotion rules from &lt;a href=&quot;../reference/generated/numpy.result_type#numpy.result_type&quot;&gt;&lt;code&gt;numpy.result_type&lt;/code&gt;&lt;/a&gt; applied to the field&amp;rsquo;s dtypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="852b3e753a1b8cdcb6346c93877a110d2d715f72" translate="yes" xml:space="preserve">
          <source>This is similar to choose or select, except that functions are evaluated on elements of &lt;code&gt;x&lt;/code&gt; that satisfy the corresponding condition from &lt;code&gt;condlist&lt;/code&gt;.</source>
          <target state="translated">这类似于select或select，不同之处在于，对满足 &lt;code&gt;condlist&lt;/code&gt; 中相应条件的 &lt;code&gt;x&lt;/code&gt; 元素求值函数。</target>
        </trans-unit>
        <trans-unit id="2c3a50a4a39023a7aa06d7ec91f3ecdac2409160" translate="yes" xml:space="preserve">
          <source>This is the &amp;ldquo;average&amp;rdquo; periodically compounded rate of return that gives a net present value of 0.0; for a more complete explanation, see Notes below.</source>
          <target state="translated">这是&amp;ldquo;平均&amp;rdquo;定期复合回报率，其净现值为0.0。有关更完整的说明，请参见下面的注释。</target>
        </trans-unit>
        <trans-unit id="0dbc891d865ae88284f9bfa0a0edbf0c765484c8" translate="yes" xml:space="preserve">
          <source>This is the 1-d core function used by the dynamic ufuncs created by umath.frompyfunc(function, nin, nout). In this case &lt;em&gt;func&lt;/em&gt; is a pointer to a &lt;a href=&quot;#c.PyUFunc_PyFuncData&quot;&gt;&lt;code&gt;PyUFunc_PyFuncData&lt;/code&gt;&lt;/a&gt; structure which has definition</source>
          <target state="translated">这是umath.frompyfunc（function，nin，nout）创建的动态ufunc使用的一维核心函数。在这种情况下，&lt;em&gt;func&lt;/em&gt;是指向具有定义的&lt;a href=&quot;#c.PyUFunc_PyFuncData&quot;&gt; &lt;code&gt;PyUFunc_PyFuncData&lt;/code&gt; &lt;/a&gt;结构的指针</target>
        </trans-unit>
        <trans-unit id="692a8cf195747eb5dfe92c87d684aef132c27f68" translate="yes" xml:space="preserve">
          <source>This is the NumPy implementation of the C library function fmod, the remainder has the same sign as the dividend &lt;code&gt;x1&lt;/code&gt;. It is equivalent to the Matlab(TM) &lt;code&gt;rem&lt;/code&gt; function and should not be confused with the Python modulus operator &lt;code&gt;x1 % x2&lt;/code&gt;.</source>
          <target state="translated">这是C库函数fmod的NumPy实现，其余部分与被除数 &lt;code&gt;x1&lt;/code&gt; 具有相同的符号。它等效于Matlab&amp;trade; &lt;code&gt;rem&lt;/code&gt; 函数，不应与Python模运算符 &lt;code&gt;x1 % x2&lt;/code&gt; 混淆。</target>
        </trans-unit>
        <trans-unit id="9f70c1d8b15029e4bba377d8eb228f8ad3621041" translate="yes" xml:space="preserve">
          <source>This is the code that handles the situation whenever the input and/or output arrays are either misaligned or of the wrong data-type (including being byte-swapped) from what the underlying 1-D loop expects. The arrays are also assumed to be non-contiguous. The code works very much like the strided-loop except for the inner 1-D loop is modified so that pre-processing is performed on the inputs and post- processing is performed on the outputs in bufsize chunks (where bufsize is a user-settable parameter). The underlying 1-D computational loop is called on data that is copied over (if it needs to be). The setup code and the loop code is considerably more complicated in this case because it has to handle:</source>
          <target state="translated">这是处理输入和/或输出数组错位或数据类型错误(包括被字节交换)的情况的代码,与底层一维循环的期望值不同。数组也被假定为非连续的。这段代码的工作方式与strided-loop非常相似,除了内部的1-D循环被修改为在输入上进行预处理,在输出上以bufsize块的形式进行后处理(其中bufsize是一个用户可设置的参数)。底层的一维计算循环会对复制过来的数据进行调用(如果需要的话)。在这种情况下,设置代码和循环代码要复杂得多,因为它必须处理。</target>
        </trans-unit>
        <trans-unit id="97fdbbb09a00c84ec3c672ccc77676c7df568ed7" translate="yes" xml:space="preserve">
          <source>This is the docstring for the example.py module. Modules names should have short, all-lowercase names. The module name may have underscores if this improves readability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="938b03b0272fe214e0bd4545d8c331ea33459bae" translate="yes" xml:space="preserve">
          <source>This is the exact same method signature for &lt;code&gt;np.sum&lt;/code&gt;, so now if a user calls &lt;code&gt;np.sum&lt;/code&gt; on this object, numpy will call the object&amp;rsquo;s own &lt;code&gt;sum&lt;/code&gt; method and pass in these arguments enumerated above in the signature, and no errors will be raised because the signatures are completely compatible with each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="754ab86dfdc616fd9f3289ae80c9fb161f6f47b6" translate="yes" xml:space="preserve">
          <source>This is the main array creation function. Most new arrays are created with this flexible function.</source>
          <target state="translated">这是主要的数组创建函数。大多数新的数组都是用这个灵活的函数创建的。</target>
        </trans-unit>
        <trans-unit id="ae96a364309b5dfa1ba1a5f179699cc1e3ea0752" translate="yes" xml:space="preserve">
          <source>This is the main function used to obtain an array from any nested sequence, or object that exposes the array interface, &lt;em&gt;op&lt;/em&gt;. The parameters allow specification of the required &lt;em&gt;dtype&lt;/em&gt;, the minimum (&lt;em&gt;min_depth&lt;/em&gt;) and maximum (&lt;em&gt;max_depth&lt;/em&gt;) number of dimensions acceptable, and other &lt;em&gt;requirements&lt;/em&gt; for the array. This function &lt;strong&gt;steals a reference&lt;/strong&gt; to the dtype argument, which needs to be a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure indicating the desired data-type (including required byteorder). The &lt;em&gt;dtype&lt;/em&gt; argument may be &lt;code&gt;NULL&lt;/code&gt;, indicating that any data-type (and byteorder) is acceptable. Unless &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt; is present in &lt;code&gt;flags&lt;/code&gt;, this call will generate an error if the data type cannot be safely obtained from the object. If you want to use &lt;code&gt;NULL&lt;/code&gt; for the &lt;em&gt;dtype&lt;/em&gt; and ensure the array is notswapped then use &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt;&lt;code&gt;PyArray_CheckFromAny&lt;/code&gt;&lt;/a&gt;. A value of 0 for either of the depth parameters causes the parameter to be ignored. Any of the following array flags can be added (&lt;em&gt;e.g.&lt;/em&gt; using |) to get the &lt;em&gt;requirements&lt;/em&gt; argument. If your code can handle general (&lt;em&gt;e.g.&lt;/em&gt; strided, byte-swapped, or unaligned arrays) then &lt;em&gt;requirements&lt;/em&gt; may be 0. Also, if &lt;em&gt;op&lt;/em&gt; is not already an array (or does not expose the array interface), then a new array will be created (and filled from &lt;em&gt;op&lt;/em&gt; using the sequence protocol). The new array will have &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; as its flags member. The &lt;em&gt;context&lt;/em&gt; argument is passed to the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method of &lt;em&gt;op&lt;/em&gt; and is only used if the array is constructed that way. Almost always this parameter is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">这是用于从任何嵌套序列或公开数组接口&lt;em&gt;op的&lt;/em&gt;对象获取数组的主要功能。参数允许所需的规格&lt;em&gt;D型细胞&lt;/em&gt;，最小（&lt;em&gt;min_depth&lt;/em&gt;）和最大值（&lt;em&gt;MAX_DEPTH&lt;/em&gt;尺寸上可接受的）号码，以及其它&lt;em&gt;的要求&lt;/em&gt;对阵列。此函数&lt;strong&gt;窃取&lt;/strong&gt;对dtype参数&lt;strong&gt;的引用&lt;/strong&gt;，该&lt;strong&gt;引用&lt;/strong&gt;必须是&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;结构，以指示所需的数据类型（包括所需的字节序）。的&lt;em&gt;D型&lt;/em&gt;参数可以是 &lt;code&gt;NULL&lt;/code&gt; ，表示任何数据类型（和字节顺序）是可接受的。除非&lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt; &lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt; &lt;/a&gt;如果 &lt;code&gt;flags&lt;/code&gt; 中存在，则如果不能从对象安全地获取数据类型，则此调用将产生错误。如果你想使用 &lt;code&gt;NULL&lt;/code&gt; 的&lt;em&gt;D型&lt;/em&gt;和保证阵列notswapped然后使用&lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt; &lt;code&gt;PyArray_CheckFromAny&lt;/code&gt; &lt;/a&gt;。任一深度参数的值0都会导致忽略该参数。可以添加以下任何数组标志（&lt;em&gt;例如，&lt;/em&gt;使用|）以获取&lt;em&gt;需求&lt;/em&gt;参数。如果您的代码可以处理常规代码（&lt;em&gt;例如，&lt;/em&gt;跨步，字节交换或未对齐的数组），则&lt;em&gt;要求&lt;/em&gt;可能为0。此外，如果&lt;em&gt;op&lt;/em&gt;还不是数组（或不公开数组接口），则将创建一个新数组（并使用序列协议从&lt;em&gt;op&lt;/em&gt;填充）。新数组将以&lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; &lt;/a&gt;作为其flags成员。的&lt;em&gt;上下文&lt;/em&gt;参数被传递给&lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt;的方法&lt;em&gt;运算&lt;/em&gt;，如果该阵列被构造这种方式仅使用。这个参数几乎总是 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ef891de4e312961f5d43ee05c17aa291119de54" translate="yes" xml:space="preserve">
          <source>This is the main function used to obtain an array from any nested sequence, or object that exposes the array interface, &lt;em&gt;op&lt;/em&gt;. The parameters allow specification of the required &lt;em&gt;dtype&lt;/em&gt;, the minimum (&lt;em&gt;min_depth&lt;/em&gt;) and maximum (&lt;em&gt;max_depth&lt;/em&gt;) number of dimensions acceptable, and other &lt;em&gt;requirements&lt;/em&gt; for the array. This function &lt;strong&gt;steals a reference&lt;/strong&gt; to the dtype argument, which needs to be a &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure indicating the desired data-type (including required byteorder). The &lt;em&gt;dtype&lt;/em&gt; argument may be &lt;code&gt;NULL&lt;/code&gt;, indicating that any data-type (and byteorder) is acceptable. Unless &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt; is present in &lt;code&gt;flags&lt;/code&gt;, this call will generate an error if the data type cannot be safely obtained from the object. If you want to use &lt;code&gt;NULL&lt;/code&gt; for the &lt;em&gt;dtype&lt;/em&gt; and ensure the array is notswapped then use &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt;&lt;code&gt;PyArray_CheckFromAny&lt;/code&gt;&lt;/a&gt;. A value of 0 for either of the depth parameters causes the parameter to be ignored. Any of the following array flags can be added (&lt;em&gt;e.g.&lt;/em&gt; using |) to get the &lt;em&gt;requirements&lt;/em&gt; argument. If your code can handle general (&lt;em&gt;e.g.&lt;/em&gt; strided, byte-swapped, or unaligned arrays) then &lt;em&gt;requirements&lt;/em&gt; may be 0. Also, if &lt;em&gt;op&lt;/em&gt; is not already an array (or does not expose the array interface), then a new array will be created (and filled from &lt;em&gt;op&lt;/em&gt; using the sequence protocol). The new array will have &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; as its flags member. The &lt;em&gt;context&lt;/em&gt; argument is unused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0edcab26afcb3f2afd03c8c948c52b8fae9f82e5" translate="yes" xml:space="preserve">
          <source>This is the manual followed by NumPy&amp;rsquo;s Code of Conduct Committee. It&amp;rsquo;s used when we respond to an issue to make sure we&amp;rsquo;re consistent and fair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec8c6b5a6fa5ea604ca73fde0faa7f48e61f60d" translate="yes" xml:space="preserve">
          <source>This is the masked array version of &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt;. For details see &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt;的掩码数组版本。有关详细信息，请参见&lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5b5fdafede3bb67234ee18c22a5b997e8095961" translate="yes" xml:space="preserve">
          <source>This is the masked array version of &lt;code&gt;lib.index_tricks.RClass&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;lib.index_tricks.RClass&lt;/code&gt; 的掩码数组版本。</target>
        </trans-unit>
        <trans-unit id="bf3cf3ae9cebee8b7306a5e44915e23de00facf1" translate="yes" xml:space="preserve">
          <source>This is the masked equivalent of the &lt;a href=&quot;numpy.resize#numpy.resize&quot;&gt;&lt;code&gt;numpy.resize&lt;/code&gt;&lt;/a&gt; function. The new array is filled with repeated copies of &lt;code&gt;x&lt;/code&gt; (in the order that the data are stored in memory). If &lt;code&gt;x&lt;/code&gt; is masked, the new array will be masked, and the new mask will be a repetition of the old one.</source>
          <target state="translated">这是&lt;a href=&quot;numpy.resize#numpy.resize&quot;&gt; &lt;code&gt;numpy.resize&lt;/code&gt; &lt;/a&gt;函数的掩码等效项。新数组中填充了 &lt;code&gt;x&lt;/code&gt; 的重复副本（以数据存储在内存中的顺序）。如果 &lt;code&gt;x&lt;/code&gt; 被屏蔽，新的数组将被屏蔽，新的掩码将是旧数组的重复。</target>
        </trans-unit>
        <trans-unit id="0cb42e32affa717b335b3825c72824c3d8e04997" translate="yes" xml:space="preserve">
          <source>This is the most flexible form of specification since it allows control over the byte-offsets of the fields and the itemsize of the structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e638e46153cb5bd9d2b2cfadb202d5a4f7f60071" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;ndarray.all&lt;/code&gt;&lt;/a&gt;, but it returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;ndarray.all&lt;/code&gt; &lt;/a&gt;相同，但是它返回一个&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="b28c44c91a00424416f03ba6b4985acf74627eb2" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt; would return an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; &lt;/a&gt;相同，但是返回一个&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象，其中&lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; &lt;/a&gt;将返回一个&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22b8e33a3b4d40024b90c85a13a94be90c9158a1" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt; would return an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; &lt;/a&gt;相同，但是返回一个&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象，其中&lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; &lt;/a&gt;将返回一个&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1090f814c7b352e9c36a05ce2322d963cddbde3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt; would return an ndarray.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; &lt;/a&gt;相同，但是返回一个&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象，其中&lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; &lt;/a&gt;将返回一个ndarray。</target>
        </trans-unit>
        <trans-unit id="74e44d918d1f15516605ec010845ff539cc17530" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt; would return an ndarray.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; &lt;/a&gt;相同，但是返回一个&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象，其中&lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; &lt;/a&gt;将返回一个ndarray。</target>
        </trans-unit>
        <trans-unit id="124e720446d4f3612122d427a64991837042df14" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.std#numpy.ndarray.std&quot;&gt;&lt;code&gt;ndarray.std&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.std#numpy.ndarray.std&quot;&gt; &lt;code&gt;ndarray.std&lt;/code&gt; &lt;/a&gt;相同，除了返回&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 的&lt;/a&gt;地方是返回&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="a0acdb03a11a0405720f9b33ec10bd3e67d6e4fa" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt;&lt;code&gt;ndarray.sum&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt; &lt;code&gt;ndarray.sum&lt;/code&gt; &lt;/a&gt;相同，除了返回&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 的&lt;/a&gt;地方是返回&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="1b894bff66f53b91713c65daaeb95b50cb72fdfc" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.var#numpy.ndarray.var&quot;&gt;&lt;code&gt;ndarray.var&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">这与&lt;a href=&quot;numpy.ndarray.var#numpy.ndarray.var&quot;&gt; &lt;code&gt;ndarray.var&lt;/code&gt; &lt;/a&gt;相同，除了返回&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 的&lt;/a&gt;地方是返回&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="d6c0a4b3ef29201f690f9b9b88a69b8608d63748" translate="yes" xml:space="preserve">
          <source>This is the same for half-precision float as npy_nextafter and npy_nextafterf described in the low-level floating point section.</source>
          <target state="translated">这与低级浮点部分描述的npy_nextafter和npy_nextafterf对半精度浮点来说是一样的。</target>
        </trans-unit>
        <trans-unit id="5a28a11e64cd4476f1fd45344cb04aff7bece602" translate="yes" xml:space="preserve">
          <source>This is the same for half-precision float as npy_spacing and npy_spacingf described in the low-level floating point section.</source>
          <target state="translated">这与低级浮点部分描述的npy_spacing和npy_spacingf对于半精度浮点是一样的。</target>
        </trans-unit>
        <trans-unit id="69592e67862b42a94f582425221058b3b2e662f2" translate="yes" xml:space="preserve">
          <source>This is the same polynomial as obtained by:</source>
          <target state="translated">这与下列方法得到的多项式相同:</target>
        </trans-unit>
        <trans-unit id="8f841f69094513c4d7f4558bcdd113fb62e5f1f7" translate="yes" xml:space="preserve">
          <source>This is the simplest case of all. The ufunc is executed by calling the underlying 1-D loop exactly once. This is possible only when we have aligned data of the correct type (including byte-order) for both input and output and all arrays have uniform strides (either contiguous, 0-D, or 1-D). In this case, the 1-D computational loop is called once to compute the calculation for the entire array. Note that the hardware error flags are only checked after the entire calculation is complete.</source>
          <target state="translated">这是最简单的情况。ufunc通过调用底层的1-D循环精确地执行一次。只有当我们的输入和输出都有正确类型的对齐数据(包括字节顺序),并且所有的数组都有统一的步长(连续、0-D或1-D)时,这才是可能的。在这种情况下,1-D计算循环会被调用一次来计算整个数组的计算。需要注意的是,只有在整个计算完成后才会检查硬件错误标志。</target>
        </trans-unit>
        <trans-unit id="963cd66868f04208a7a1c2183e363716e0ef0cf2" translate="yes" xml:space="preserve">
          <source>This is the type which exposes the iterator to Python. Currently, no API is exposed which provides access to the values of a Python-created iterator. If an iterator is created in Python, it must be used in Python and vice versa. Such an API will likely be created in a future version.</source>
          <target state="translated">这是一个向 Python 公开迭代器的类型。目前,还没有暴露出任何 API 来提供对 Python 创建的迭代器值的访问。如果一个迭代器是在 Python 中创建的,那么它必须在 Python 中使用,反之亦然。这样的 API 可能会在未来的版本中被创建。</target>
        </trans-unit>
        <trans-unit id="4b42439256132aabca2f53b261c973f7c679d369" translate="yes" xml:space="preserve">
          <source>This is useful for setting up an accumulation loop, for example. The iterator can first be created with all the dimensions, including the accumulation axis, so that the output gets created correctly. Then, the accumulation axis can be removed, and the calculation done in a nested fashion.</source>
          <target state="translated">例如,这对于设置一个累积循环很有用。迭代器可以首先创建所有的维度,包括累加轴,以便正确创建输出。然后,累积轴可以被移除,并以嵌套的方式进行计算。</target>
        </trans-unit>
        <trans-unit id="5300cb088270de52a08527e24f73ff59ea30c2bb" translate="yes" xml:space="preserve">
          <source>This is useful in a setup.py script for adding sub-packages to a package.</source>
          <target state="translated">这在setup.py脚本中很有用,可以将子包添加到一个包中。</target>
        </trans-unit>
        <trans-unit id="6e4aa46e2220dff2f0d0703b94a0af6befef5473" translate="yes" xml:space="preserve">
          <source>This is wonderful because the function writer doesn&amp;rsquo;t have to manually propagate infs or nans.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82959a96175cd052449eddf58c5c4610e0b21bd3" translate="yes" xml:space="preserve">
          <source>This iterates over matching 1d slices oriented along the specified axis in the index and data arrays, and uses the former to look up values in the latter. These slices can be different lengths.</source>
          <target state="translated">它迭代索引和数据数组中沿指定轴方向的匹配的1d切片,并使用前者查找后者中的值。这些切片可以是不同的长度。</target>
        </trans-unit>
        <trans-unit id="5c175a7e11a936be20457fa33dc8778b062c8741" translate="yes" xml:space="preserve">
          <source>This iterates over matching 1d slices oriented along the specified axis in the index and data arrays, and uses the former to place values into the latter. These slices can be different lengths.</source>
          <target state="translated">它迭代索引和数据数组中沿指定轴方向的匹配的1d切片,并使用前者将值放入后者。这些切片可以是不同的长度。</target>
        </trans-unit>
        <trans-unit id="1d9086a3e8f6e523e455adb859a4bc6cbea3019a" translate="yes" xml:space="preserve">
          <source>This iterator returns elements of the array to be iterated over in &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt;&lt;code&gt;Arrayterator&lt;/code&gt;&lt;/a&gt; one by one. It is similar to &lt;code&gt;flatiter&lt;/code&gt;.</source>
          <target state="translated">此迭代器返回要在&lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt; &lt;code&gt;Arrayterator&lt;/code&gt; 中&lt;/a&gt;一一进行迭代的数组元素。它类似于 &lt;code&gt;flatiter&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9621dd1cff206294072ec88c5bdff12776a1ac23" translate="yes" xml:space="preserve">
          <source>This just returns the value &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; changes whenever a backward incompatible change at the ABI level. Because it is in the C-API, however, comparing the output of this function from the value defined in the current header gives a way to test if the C-API has changed thus requiring a re-compilation of extension modules that use the C-API. This is automatically checked in the function &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这仅返回值&lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt;。只要在ABI级别上向后不兼容更改，&lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt;就会更改。由于它在C-API中，因此，将此函数的输出与当前标头中定义的值进行比较，可以测试C-API是否已更改，因此需要重新编译使用C的扩展模块。 -API。这是在函数&lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; 中&lt;/a&gt;自动检查的。</target>
        </trans-unit>
        <trans-unit id="75e16e673218df8f16a0a1029a429a437c420b9d" translate="yes" xml:space="preserve">
          <source>This just returns the value &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt;. &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; changes whenever the API changes (e.g. a function is added). A changed value does not always require a recompile.</source>
          <target state="translated">这只是返回值 &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; 。每当API更改（例如，添加功能）时， &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; 都会更改。更改的值并不总是需要重新编译。</target>
        </trans-unit>
        <trans-unit id="57131d2cbf8754e0c0045e65c405a8ff98703b38" translate="yes" xml:space="preserve">
          <source>This macro is defined to +inf.</source>
          <target state="translated">此宏定义为+inf。</target>
        </trans-unit>
        <trans-unit id="8ca63ad5bc4e1dded64f0ca2a056ab5d5c7f090f" translate="yes" xml:space="preserve">
          <source>This macro is defined to -1.0.</source>
          <target state="translated">此宏定义为-1.0。</target>
        </trans-unit>
        <trans-unit id="b30ee77ae33429489972a6d1172613ede0e766a9" translate="yes" xml:space="preserve">
          <source>This macro is defined to -inf.</source>
          <target state="translated">此宏定义为-inf。</target>
        </trans-unit>
        <trans-unit id="b8842c8583817136af82824b8e5fdbb3f9c76f6e" translate="yes" xml:space="preserve">
          <source>This macro is defined to 1.0.</source>
          <target state="translated">该宏定义为1.0。</target>
        </trans-unit>
        <trans-unit id="bd01732ce89574cb085cbbd769f60ac683ce37ab" translate="yes" xml:space="preserve">
          <source>This macro is defined to a NaN (Not a Number), and is guaranteed to have the signbit unset (&amp;lsquo;positive&amp;rsquo; NaN). The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">此宏定义为NaN（非数字），并确保未设置符号位（&amp;ldquo;正&amp;rdquo; NaN）。带有后缀F和L的是相应的单精度和扩展精度宏。</target>
        </trans-unit>
        <trans-unit id="305a7f44534276994ed187e38461a42eaeb6b275" translate="yes" xml:space="preserve">
          <source>This macro is defined to a NaN value, guaranteed to have its sign bit unset.</source>
          <target state="translated">该宏定义为NaN值,保证其符号位不被设置。</target>
        </trans-unit>
        <trans-unit id="15a2136199da842d310792facc84af7246036426" translate="yes" xml:space="preserve">
          <source>This macro is defined to a positive inf. The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">该宏定义为正向的信息。相应的单精度宏和扩展精度宏的后缀为F和L。</target>
        </trans-unit>
        <trans-unit id="c5ea17d1f0932fffe7fa9472293549c952ff5b71" translate="yes" xml:space="preserve">
          <source>This macro is defined to negative zero (that is with the sign bit set). The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">该宏定义为负零(即设置了符号位)。相应的单精度和扩展精度宏的后缀为F和L。</target>
        </trans-unit>
        <trans-unit id="28ffbdfd1fb5a238c0e6b132bd7b25e886a8862b" translate="yes" xml:space="preserve">
          <source>This macro is defined to negative zero.</source>
          <target state="translated">此宏定义为负零。</target>
        </trans-unit>
        <trans-unit id="6499719d1e23e1af1e93848438b61bc7bf9fb167" translate="yes" xml:space="preserve">
          <source>This macro is defined to positive zero.</source>
          <target state="translated">此宏定义为正零。</target>
        </trans-unit>
        <trans-unit id="c804fcf19685f98f19d42c1dc7c110945817d41e" translate="yes" xml:space="preserve">
          <source>This macro is defined to positive zero. The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">此宏定义为正零。相应的单精度和扩展精度宏都可以用后缀F和L来表示。</target>
        </trans-unit>
        <trans-unit id="4c35e4d492b4b66e88cf91e279bf815b9c6ef74c" translate="yes" xml:space="preserve">
          <source>This manual contains many examples of use, usually prefixed with the Python prompt &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; (which is not a part of the example code). The examples assume that you have first entered:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc87f3907c86c15e0fab69c802c5a342d7203e00" translate="yes" xml:space="preserve">
          <source>This may be clearer with an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c451240677ff61c1a609e49bd0f07f461a99c611" translate="yes" xml:space="preserve">
          <source>This may be used when you want to match up operand axes in some fashion, then remove them with &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; to handle their processing manually. By calling this function before removing the axes, you can get the strides for the manual processing.</source>
          <target state="translated">当您想以某种方式匹配操作数轴，然后使用 &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; 删除它们以手动处理它们时，可以使用此方法。通过在拆下轴之前调用此函数，您可以大步进行手动处理。</target>
        </trans-unit>
        <trans-unit id="272240144b37c5af402b352038a269eb5d08f543" translate="yes" xml:space="preserve">
          <source>This may mainly help you if you are not running the python and/or NumPy version you are expecting to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c92d427e914a0dd599016040f8fd75a2d48dc062" translate="yes" xml:space="preserve">
          <source>This means that (i) we want to edit the commit message for &lt;code&gt;13d7934&lt;/code&gt;, and (ii) collapse the last three commits into one. Now we save and quit the editor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b5c517a58e8aeec834229928a8cecac10d6dff" translate="yes" xml:space="preserve">
          <source>This member allows array objects to have weak references (using the weakref module).</source>
          <target state="translated">该成员允许数组对象拥有弱引用(使用弱引用模块)。</target>
        </trans-unit>
        <trans-unit id="ed18bc4ba4db4fad433f89f2b494c6f4723892b5" translate="yes" xml:space="preserve">
          <source>This member is used to hold a pointer to another Python object that is related to this array. There are two use cases:</source>
          <target state="translated">该成员用于持有指向与该数组相关的另一个 Python 对象的指针。有两个用例。</target>
        </trans-unit>
        <trans-unit id="9d7f481ab5f8b1d226ed9ed47a9904d6a830df77" translate="yes" xml:space="preserve">
          <source>This member points to an element in the ndarray indicated by the index.</source>
          <target state="translated">该成员指向索引所指的ndarray中的一个元素。</target>
        </trans-unit>
        <trans-unit id="74643da87d06b0da62bc7a9a046a5adf218ab99e" translate="yes" xml:space="preserve">
          <source>This method directly exposes the the raw underlying pseudo-random number generator. All values are returned as unsigned 64-bit values irrespective of the number of bits produced by the PRNG.</source>
          <target state="translated">这个方法直接暴露了原始的底层伪随机数生成器,所有的值都以无符号64位的方式返回,而不管PRNG生成的位数是多少。无论PRNG产生的位数是多少,所有的值都以无符号64位值返回。</target>
        </trans-unit>
        <trans-unit id="d818e6497cca20e6d8e8f1bc817ba9a89c8a342e" translate="yes" xml:space="preserve">
          <source>This method does nothing, except raise a ValueError exception. A masked array does not own its data and therefore cannot safely be resized in place. Use the &lt;a href=&quot;numpy.ma.resize#numpy.ma.resize&quot;&gt;&lt;code&gt;numpy.ma.resize&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">此方法不执行任何操作，除了引发ValueError异常。掩码数组不拥有其数据，因此无法安全地在适当位置调整大小。请改用&lt;a href=&quot;numpy.ma.resize#numpy.ma.resize&quot;&gt; &lt;code&gt;numpy.ma.resize&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="9518a02e6b8dc4cd7e3170e82e29518e38adcb79" translate="yes" xml:space="preserve">
          <source>This method does the heavy lifting for the &lt;a href=&quot;numpy.testing.tester.test#numpy.testing.Tester.test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; method. It takes all the same arguments, for details see &lt;a href=&quot;numpy.testing.tester.test#numpy.testing.Tester.test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f55c9dffed1c2a6b5a2a9bf81f22b788e98f67b4" translate="yes" xml:space="preserve">
          <source>This method is called whenever the system internally allocates a new array from &lt;em&gt;obj&lt;/em&gt;, where &lt;em&gt;obj&lt;/em&gt; is a subclass (subtype) of the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. It can be used to change attributes of &lt;em&gt;self&lt;/em&gt; after construction (so as to ensure a 2-d matrix for example), or to update meta-information from the &amp;ldquo;parent.&amp;rdquo; Subclasses inherit a default implementation of this method that does nothing.</source>
          <target state="translated">每当系统内部从&lt;em&gt;obj&lt;/em&gt;分配新数组时，都会调用此方法，其中&lt;em&gt;obj&lt;/em&gt;是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;的子类（子类型）。它可用于在构造后更改&lt;em&gt;self的&lt;/em&gt;属性（例如，以确保二维矩阵），或用于更新&amp;ldquo;父级&amp;rdquo;的元信息。子类继承此方法的默认实现，该实现不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="5957d72b0ca4a0dc20466e5e727abd34e77443e1" translate="yes" xml:space="preserve">
          <source>This method is difficult to implement safely and may be deprecated in future releases of NumPy.</source>
          <target state="translated">这个方法很难安全地实现,在未来的NumPy版本中可能会被废弃。</target>
        </trans-unit>
        <trans-unit id="7aaa9616f6dcdd0184bee8a152bd13d1e550b310" translate="yes" xml:space="preserve">
          <source>This method is for backward compatibility only: do not use.</source>
          <target state="translated">此方法仅用于向后兼容:不要使用。</target>
        </trans-unit>
        <trans-unit id="0ecb5e08ef8d16754216c422058e3a81999abee2" translate="yes" xml:space="preserve">
          <source>This method removes any overlaps and reorders the fields in memory so they have increasing byte offsets, and adds or removes padding bytes depending on the &lt;code&gt;align&lt;/code&gt; option, which behaves like the &lt;code&gt;align&lt;/code&gt; option to &lt;code&gt;np.dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83e657ddca83d2881d8a63d1d77710e25b3d7e94" translate="yes" xml:space="preserve">
          <source>This method scans files named __version__.py, &amp;lt;packagename&amp;gt;_version.py, version.py, and __svn_version__.py for string variables version, __version__, and &amp;lt;packagename&amp;gt;_version, until a version number is found.</source>
          <target state="translated">此方法扫描名为__version __。py，&amp;lt;packagename&amp;gt; _version.py，version.py和__svn_version__.py的文件中的字符串变量version，__ version__和&amp;lt;packagename&amp;gt; _version，直到找到版本号。</target>
        </trans-unit>
        <trans-unit id="f89805770623a7cfcc87bb87063713e7dd822816" translate="yes" xml:space="preserve">
          <source>This module contains all functions in the &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; namespace, with the following replacement functions that return &lt;a href=&quot;generated/numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrices&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该模块包含&lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt;名称空间中的所有函数，以及以下替换函数，这些函数返回&lt;a href=&quot;generated/numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrices&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="265d65d83193df044b48a623f0d3f0dda63b008d" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Chebyshev series, including a &lt;a href=&quot;generated/numpy.polynomial.chebyshev.chebyshev#numpy.polynomial.chebyshev.Chebyshev&quot;&gt;&lt;code&gt;Chebyshev&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多用于处理Chebyshev系列的对象（主要是函数），包括封装常规算术运算的&lt;a href=&quot;generated/numpy.polynomial.chebyshev.chebyshev#numpy.polynomial.chebyshev.Chebyshev&quot;&gt; &lt;code&gt;Chebyshev&lt;/code&gt; &lt;/a&gt;类。（有关此模块如何表示和使用此类多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; &amp;ldquo;父&amp;rdquo;子包numpy.polynomial的文档字符串中）。</target>
        </trans-unit>
        <trans-unit id="e0c12fd4ebad36a4626d24020b78132a2c170962" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Hermite series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite.hermite#numpy.polynomial.hermite.Hermite&quot;&gt;&lt;code&gt;Hermite&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多用于处理Hermite系列的对象（主要是函数），包括封装常规算术运算的&lt;a href=&quot;generated/numpy.polynomial.hermite.hermite#numpy.polynomial.hermite.Hermite&quot;&gt; &lt;code&gt;Hermite&lt;/code&gt; &lt;/a&gt;类。 （有关此模块如何表示和使用这些多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; &amp;ldquo;父&amp;rdquo;子程序包numpy.polynomial的文档字符串）。</target>
        </trans-unit>
        <trans-unit id="009a1c885b932c48bc61dd45e0e34c3c31b1f286" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with HermiteE series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt;&lt;code&gt;HermiteE&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多对象（主要是函数），可用于处理HermiteE系列，包括封装常规算术运算的&lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt; &lt;code&gt;HermiteE&lt;/code&gt; &lt;/a&gt;类。（有关此模块如何表示和使用此类多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; &amp;ldquo;父&amp;rdquo;子包numpy.polynomial的文档字符串中）。</target>
        </trans-unit>
        <trans-unit id="68d5327723a8c86e153df7ff9955c4a06be0ce20" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Hermite_e series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt;&lt;code&gt;HermiteE&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d0299f154387dc04b7a01cfe822909405b30805" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Laguerre series, including a &lt;a href=&quot;generated/numpy.polynomial.laguerre.laguerre#numpy.polynomial.laguerre.Laguerre&quot;&gt;&lt;code&gt;Laguerre&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多对象（主要是函数），可用于处理Laguerre系列，包括封装了常规算术运算的&lt;a href=&quot;generated/numpy.polynomial.laguerre.laguerre#numpy.polynomial.laguerre.Laguerre&quot;&gt; &lt;code&gt;Laguerre&lt;/code&gt; &lt;/a&gt;类。（有关此模块如何表示和使用此类多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; &amp;ldquo;父&amp;rdquo;子包numpy.polynomial的文档字符串中）。</target>
        </trans-unit>
        <trans-unit id="97167a7dd7012c05d960d350608d944b8fc4844a" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Legendre series, including a &lt;a href=&quot;generated/numpy.polynomial.legendre.legendre#numpy.polynomial.legendre.Legendre&quot;&gt;&lt;code&gt;Legendre&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多用于处理Legendre系列的对象（主要是函数），包括封装常规算术运算的&lt;a href=&quot;generated/numpy.polynomial.legendre.legendre#numpy.polynomial.legendre.Legendre&quot;&gt; &lt;code&gt;Legendre&lt;/code&gt; &lt;/a&gt;类。（有关此模块如何表示和使用这些多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; &amp;ldquo;父&amp;rdquo;子包numpy.polynomial的文档字符串中）。</target>
        </trans-unit>
        <trans-unit id="27218660297bbc1672326aa7fc0091aba0aa4b36" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Polynomial series, including a &lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt;&lt;code&gt;Polynomial&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">该模块提供了许多用于处理多项式系列的对象（主要是函数），包括封装了常用算术运算的&lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt; &lt;code&gt;Polynomial&lt;/code&gt; &lt;/a&gt;类。（有关此模块如何表示和使用这些多项式的一般信息，&lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; &amp;ldquo;父&amp;rdquo;子包numpy.polynomial的文档字符串中）。</target>
        </trans-unit>
        <trans-unit id="1ab4c28fb83b693800bce3d9c0cb03cd8615a6cd" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with polynomials, including a &lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt;&lt;code&gt;Polynomial&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with polynomial objects is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6505e2a54b4c90d04c624c70346ad867092f98b2" translate="yes" xml:space="preserve">
          <source>This module provides: error and warning objects; a polynomial base class; and some routines used in both the &lt;code&gt;polynomial&lt;/code&gt; and &lt;code&gt;chebyshev&lt;/code&gt; modules.</source>
          <target state="translated">该模块提供：错误和警告对象；多项式基类；以及在 &lt;code&gt;polynomial&lt;/code&gt; 和 &lt;code&gt;chebyshev&lt;/code&gt; 模块中使用的一些例程。</target>
        </trans-unit>
        <trans-unit id="a2e1ca0b050299a02c26006ffc538095c291c293" translate="yes" xml:space="preserve">
          <source>This module shows use of the &lt;code&gt;cimport&lt;/code&gt; statement to load the definitions from the &lt;code&gt;numpy.pxd&lt;/code&gt; header that ships with Cython. It looks like NumPy is imported twice; &lt;code&gt;cimport&lt;/code&gt; only makes the NumPy C-API available, while the regular &lt;code&gt;import&lt;/code&gt; causes a Python-style import at runtime and makes it possible to call into the familiar NumPy Python API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f02b8e116f7a7bed4ba561da0ffe80943392202" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Chebyshev series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">该模块表示 &lt;code&gt;off + scl*x&lt;/code&gt; 的Chebyshev系列的。</target>
        </trans-unit>
        <trans-unit id="a628eacd0f4bb9dd57ff71e63c578eed78e261b5" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Hermite series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">此模块代表 &lt;code&gt;off + scl*x&lt;/code&gt; 的Hermite系列。</target>
        </trans-unit>
        <trans-unit id="9ab2b6eda8208cc86132d50e5e53a2cf2e15859d" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Laguerre series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">此模块代表 &lt;code&gt;off + scl*x&lt;/code&gt; 的Laguerre系列。</target>
        </trans-unit>
        <trans-unit id="23eb81bc9bb7a5f0cbd08a18f3b739c712c791cf" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Legendre series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">此模块代表 &lt;code&gt;off + scl*x&lt;/code&gt; 的Legendre系列。</target>
        </trans-unit>
        <trans-unit id="d92e37a5c688f24c68244c7cd58f9c4410908a50" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the linear polynomial &lt;code&gt;off +
scl*x&lt;/code&gt;.</source>
          <target state="translated">此模块表示线性多项式 &lt;code&gt;off + scl*x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cce1c3ab116538df151878b9366f2e0db3802d6b" translate="yes" xml:space="preserve">
          <source>This needs to be done after all installers are downloaded, but before the pavement file is updated for continued development:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5151a066bb85cc108b39c4156d9c6c1e5f15d97" translate="yes" xml:space="preserve">
          <source>This obeys the structured array assignment rules described above. For example, this means that one can swap the values of two fields using appropriate multi-field indexes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c93b1abaa0ee7234b376edaae74a000aa2ccbab" translate="yes" xml:space="preserve">
          <source>This object is no longer compatible with &lt;code&gt;np.sum&lt;/code&gt; because if you call &lt;code&gt;np.sum&lt;/code&gt;, it will pass in unexpected arguments &lt;code&gt;out&lt;/code&gt; and &lt;code&gt;keepdims&lt;/code&gt;, causing a TypeError to be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b628f2a020e67ee402c9861512476edcb4af1ebf" translate="yes" xml:space="preserve">
          <source>This object is now compatible with &lt;code&gt;np.sum&lt;/code&gt; again because any extraneous arguments (i.e. keywords that are not &lt;code&gt;axis&lt;/code&gt; or &lt;code&gt;dtype&lt;/code&gt;) will be hidden away in the &lt;code&gt;**unused_kwargs&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a22002edc0d8d423cb72bfe9efb4e65f38427c" translate="yes" xml:space="preserve">
          <source>This only affects the iterator when &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is specified for the order parameter. By default with &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, the iterator reverses axes which have negative strides, so that memory is traversed in a forward direction. This disables this step. Use this flag if you want to use the underlying memory-ordering of the axes, but don&amp;rsquo;t want an axis reversed. This is the behavior of &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt;, for instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa2fd8c1567b66e551b17269b1ebbbc61f96243" translate="yes" xml:space="preserve">
          <source>This only affects the iterator when &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is specified for the order parameter. By default with &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, the iterator reverses axes which have negative strides, so that memory is traversed in a forward direction. This disables this step. Use this flag if you want to use the underlying memory-ordering of the axes, but don&amp;rsquo;t want an axis reversed. This is the behavior of &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt;, for instance.</source>
          <target state="translated">仅当为order参数指定&lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt;时，这才影响迭代器。默认情况下，使用&lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt;，迭代器反转具有负步幅的轴，以便沿正向遍历内存。这将禁用此步骤。如果要使用轴的基础内存顺序，但不希望轴反转，请使用此标志。例如，这就是 &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt; 的行为。</target>
        </trans-unit>
        <trans-unit id="dfc0d7340cbb0038d2b37c47d460673f198c8e36" translate="yes" xml:space="preserve">
          <source>This operation, dividing an array by a scalar, works because of NumPy&amp;rsquo;s &lt;a href=&quot;theory.broadcasting#array-broadcasting-in-numpy&quot;&gt;broadcasting rules&lt;/a&gt;). (Note that in real-world applications, it would be better to use, for example, the &lt;a href=&quot;https://scikit-image.org/docs/stable/api/skimage.html#skimage.img_as_float&quot;&gt;&lt;code&gt;img_as_float&lt;/code&gt;&lt;/a&gt; utility function from &lt;code&gt;scikit-image&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c162c5fa5c56025420698950fd9023cbce377364" translate="yes" xml:space="preserve">
          <source>This option is deprecated. Use &lt;code&gt;usercode&lt;/code&gt; statement to specify C code snippets directly in signature files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae6b1796953475091b5cdaeb39e4d7e996e315e6" translate="yes" xml:space="preserve">
          <source>This optional parameter specifies the interpolation method to use when the desired percentile lies between two data points &lt;code&gt;i &amp;lt; j&lt;/code&gt;:</source>
          <target state="translated">此可选参数指定当所需百分比位于两个数据点 &lt;code&gt;i &amp;lt; j&lt;/code&gt; 之间时要使用的插值方法：</target>
        </trans-unit>
        <trans-unit id="002fb17667dbbd628eca51b6e4ff99f2217649e0" translate="yes" xml:space="preserve">
          <source>This optional parameter specifies the interpolation method to use when the desired quantile lies between two data points &lt;code&gt;i &amp;lt; j&lt;/code&gt;:</source>
          <target state="translated">此可选参数指定当所需分位数位于两个数据点 &lt;code&gt;i &amp;lt; j&lt;/code&gt; 之间时要使用的插值方法：</target>
        </trans-unit>
        <trans-unit id="c342edf9966c2e18280c4d355db707b32be4bff5" translate="yes" xml:space="preserve">
          <source>This package was developed independently of NumPy and was integrated in version 1.17.0. The original repo is at &lt;a href=&quot;https://github.com/bashtage/randomgen&quot;&gt;https://github.com/bashtage/randomgen&lt;/a&gt;.</source>
          <target state="translated">该软件包独立于NumPy开发，并已集成到1.17.0版中。原始存储库位于&lt;a href=&quot;https://github.com/bashtage/randomgen&quot;&gt;https://github.com/bashtage/randomgen&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c427139240278bee81f47cf48768438afbe39755" translate="yes" xml:space="preserve">
          <source>This page describes the numpy-specific API for accessing the contents of a numpy array from other C extensions. &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; &amp;ndash; &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#c.PyObject_GetBuffer&quot;&gt;&lt;code&gt;The Revised Buffer Protocol&lt;/code&gt;&lt;/a&gt; introduces similar, standardized API to Python 2.6 and 3.0 for any extension module to use. &lt;a href=&quot;http://cython.org/&quot;&gt;Cython&lt;/a&gt;&amp;rsquo;s buffer array support uses the &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; API; see the &lt;a href=&quot;https://github.com/cython/cython/wiki/tutorials-numpy&quot;&gt;Cython numpy tutorial&lt;/a&gt;. Cython provides a way to write code that supports the buffer protocol with Python versions older than 2.6 because it has a backward-compatible implementation utilizing the array interface described here.</source>
          <target state="translated">此页面描述了特定于numpy的API，用于从其他C扩展访问numpy数组的内容。&lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; &amp;ndash; &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#c.PyObject_GetBuffer&quot;&gt; &lt;code&gt;The Revised Buffer Protocol&lt;/code&gt; &lt;/a&gt;为Python 2.6和3.0引入了类似的标准化API，供任何扩展模块使用。&lt;a href=&quot;http://cython.org/&quot;&gt;Cython&lt;/a&gt;的缓冲阵列支持使用&lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; API；请参见&lt;a href=&quot;https://github.com/cython/cython/wiki/tutorials-numpy&quot;&gt;Cython numpy教程&lt;/a&gt;。Cython提供了一种方法来编写支持2.6版以上Python版本的缓冲区协议的代码，因为它具有使用此处描述的数组接口向后兼容的实现。</target>
        </trans-unit>
        <trans-unit id="4df30a5dfa3e83d5a58c4b3babfef2e8f4555a00" translate="yes" xml:space="preserve">
          <source>This page documents the API for the iterator. The iterator is named &lt;code&gt;NpyIter&lt;/code&gt; and functions are named &lt;code&gt;NpyIter_*&lt;/code&gt;.</source>
          <target state="translated">此页面记录了迭代器的API。迭代器名为 &lt;code&gt;NpyIter&lt;/code&gt; ，函数名为 &lt;code&gt;NpyIter_*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b79e823ebc32815d2b3460b90e34d0a2f9bed7dc" translate="yes" xml:space="preserve">
          <source>This pointer may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it.</source>
          <target state="translated">该指针可能在迭代循环之前被缓存，调用 &lt;code&gt;iternext&lt;/code&gt; 不会更改它。</target>
        </trans-unit>
        <trans-unit id="484a465c1e928c7fbd45d4d74c7fee12a21c59d4" translate="yes" xml:space="preserve">
          <source>This pointer may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it. This function may be safely called without holding the Python GIL.</source>
          <target state="translated">该指针可能在迭代循环之前被缓存，调用 &lt;code&gt;iternext&lt;/code&gt; 不会更改它。无需持有Python GIL即可安全地调用此函数。</target>
        </trans-unit>
        <trans-unit id="bb65fa9e55962767929fe75ece2f7703e6ac5b10" translate="yes" xml:space="preserve">
          <source>This produces the correct answer, but if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; each contain millions of numbers, we will pay the price for the inefficiencies of looping in Python. We could accomplish the same task much more quickly in C by writing (for clarity we neglect variable declarations and initializations, memory allocation, etc.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc50269460cb12e12865cbec85480d4b3e10a0a9" translate="yes" xml:space="preserve">
          <source>This property can be very useful in assignments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af7b379b2fcb530df7b5c66e85d1051773a408df" translate="yes" xml:space="preserve">
          <source>This property is a view on the imaginary part of this &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此属性是此&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;的虚部的视图。</target>
        </trans-unit>
        <trans-unit id="9c2a714f693725c88c94ac2607ed6abee0322d99" translate="yes" xml:space="preserve">
          <source>This property is a view on the real part of this &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此属性是此&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;实际部分的视图。</target>
        </trans-unit>
        <trans-unit id="56ae11e0e5ca2982f115765c5eb4aa5c0c2cf88d" translate="yes" xml:space="preserve">
          <source>This reallocates space for the data area if necessary.</source>
          <target state="translated">必要时,这将重新分配数据区域的空间。</target>
        </trans-unit>
        <trans-unit id="3875a2efa104b3c26f06d6992550d8f8f4acd93f" translate="yes" xml:space="preserve">
          <source>This reference manual details functions, modules, and objects included in NumPy, describing what they are and what they do. For learning how to use NumPy, see also &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/index.html#user&quot;&gt;NumPy User Guide&lt;/a&gt;.</source>
          <target state="translated">该参考手册详细介绍了NumPy中包含的功能，模块和对象，描述了它们的功能和作用。有关学习如何使用NumPy的信息，另请参阅《&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/index.html#user&quot;&gt;NumPy用户指南》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b66394de331bbd119ed305c44c97cddcc296f65" translate="yes" xml:space="preserve">
          <source>This reference manual details functions, modules, and objects included in NumPy, describing what they are and what they do. For learning how to use NumPy, see the &lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;complete documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49d7d34fc7b59b4f57a8fc699678974df3138f8f" translate="yes" xml:space="preserve">
          <source>This returns a tuple of indices that can be used to access the main diagonal of an array &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; dimensions and shape (n, n, &amp;hellip;, n). For &lt;code&gt;a.ndim = 2&lt;/code&gt; this is the usual diagonal, for &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; this is the set of indices to access &lt;code&gt;a[i, i, ..., i]&lt;/code&gt; for &lt;code&gt;i = [0..n-1]&lt;/code&gt;.</source>
          <target state="translated">这将返回可以用于访问阵列的主对角线索引的元组 &lt;code&gt;a&lt;/code&gt; 与 &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; 的尺寸和形状（N，N，...，N）。对于 &lt;code&gt;a.ndim = 2&lt;/code&gt; ，这是通常的对角线，用于 &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; 这是组索引访问 &lt;code&gt;a[i, i, ..., i]&lt;/code&gt; 为 &lt;code&gt;i = [0..n-1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="445408c5f27be1f1d331536d4e933a74a8f78cb0" translate="yes" xml:space="preserve">
          <source>This returns the base object of the array. In most cases, this means the object which owns the memory the array is pointing at.</source>
          <target state="translated">这将返回数组的基础对象。在大多数情况下,这意味着拥有数组指向的内存的对象。</target>
        </trans-unit>
        <trans-unit id="86f639de88fe17b751b6b11b662442ef7819d4d2" translate="yes" xml:space="preserve">
          <source>This routine simply adds the elements in two contiguous arrays and places the result in a third. The memory for all three arrays must be provided by the calling routine. A very basic interface to this routine can be automatically generated by f2py:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a52ed8eb1e1cedf938d67a58ab208207008af6c7" translate="yes" xml:space="preserve">
          <source>This routine succeeds where ordinary &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt; does not:</source>
          <target state="translated">该例程在普通&lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;无法执行的情况下成功执行：</target>
        </trans-unit>
        <trans-unit id="bb5cd927267b8c85989f3387ce0a0d2359a4663d" translate="yes" xml:space="preserve">
          <source>This saves all the overhead involved in interpreting the Python code and manipulating Python objects, but at the expense of the benefits gained from coding in Python. Furthermore, the coding work required increases with the dimensionality of our data. In the case of a 2-D array, for example, the C code (abridged as before) expands to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb7064b0e5d0b37eaed95ef4ac40f47e88476c2d" translate="yes" xml:space="preserve">
          <source>This scheme does require that you avoid reusing stream IDs. This may require coordination between the parallel processes.</source>
          <target state="translated">这个方案确实要求你避免重复使用流ID。这可能需要并行进程之间的协调。</target>
        </trans-unit>
        <trans-unit id="1aa4791ff179e31578c8776ff4ea075ff10d4756" translate="yes" xml:space="preserve">
          <source>This section and the next describe in detail how to set up git for working with the NumPy source code. If you have git already set up, skip to &lt;a href=&quot;../development_workflow#development-workflow&quot;&gt;Development workflow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2295424cf2146c8c588e01472068b4499bd8664" translate="yes" xml:space="preserve">
          <source>This section describes how the basic universal function computation loop is setup and executed for each of the three different kinds of execution. If &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined during compilation, then as long as no object arrays are involved, the Python Global Interpreter Lock (GIL) is released prior to calling the loops. It is re-acquired if necessary to handle error conditions. The hardware error flags are checked only after the 1-D loop is completed.</source>
          <target state="translated">本节描述了如何为三种不同类型的执行中的每种执行建立和执行基本的通用函数计算循环。如果在编译期间定义了 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; ，则只要不涉及对象数组，就在调用循环之前释放Python全局解释器锁（GIL）。如有必要，可以重新获取它以处理错误情况。仅在完成一维循环后才检查硬件错误标志。</target>
        </trans-unit>
        <trans-unit id="36d38a5b23b654b48926d888ff2f70f4fd6663ca" translate="yes" xml:space="preserve">
          <source>This section describes the governance and leadership model of The Project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387c13e7d204cf584e66117f50223922b47b0d67" translate="yes" xml:space="preserve">
          <source>This section should be used judiciously, i.e., only for errors that are non-obvious or have a large chance of getting raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf292081ef6e3f6d3a2a86d3bb95335c9be71e92" translate="yes" xml:space="preserve">
          <source>This section should use the &lt;code&gt;deprecated&lt;/code&gt; Sphinx directive instead of an underlined section header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9b94d3eaea207d20a5173591fa4612902baa5c" translate="yes" xml:space="preserve">
          <source>This section will not cover means of replicating, joining, or otherwise expanding or mutating existing arrays. Nor will it cover creating object arrays or structured arrays. Both of those are covered in their own sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a18449ed2fc82d845556e8871f21b5f905f1f97" translate="yes" xml:space="preserve">
          <source>This should be read together with the general directions in &lt;code&gt;releasing&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af85e32a0a54092009ceae627c9327451013292e" translate="yes" xml:space="preserve">
          <source>This should not be confused with:</source>
          <target state="translated">这不应与以下情况混淆:</target>
        </trans-unit>
        <trans-unit id="281bd1fc18f2200e68ef811b640b0f24111b0170" translate="yes" xml:space="preserve">
          <source>This simply has the effect of switching the definitions of &lt;code&gt;arg1&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt; in lines 3 and 4 of the generated code above, and their assignments in lines 19 and 20.</source>
          <target state="translated">这只是在上面生成的代码的第3行和第4行中切换 &lt;code&gt;arg1&lt;/code&gt; 和 &lt;code&gt;arg2&lt;/code&gt; 的定义以及在第19行和第20行中分配它们的作用。</target>
        </trans-unit>
        <trans-unit id="54a1fbc955c54345f701059c4adac18f9144af8f" translate="yes" xml:space="preserve">
          <source>This single module should provide all the common functionality for numpy tests in a single location, so that &lt;a href=&quot;../dev/development_environment#development-environment&quot;&gt;test scripts&lt;/a&gt; can just import it and work right away. For background, see the &lt;a href=&quot;testing#testing-guidelines&quot;&gt;Testing Guidelines&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f0ce6428ed7ce9a3f007ac820d6ad83fbe35d9" translate="yes" xml:space="preserve">
          <source>This single module should provide all the common functionality for numpy tests in a single location, so that &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/dev/development_environment.html#development-environment&quot;&gt;test scripts&lt;/a&gt; can just import it and work right away. For background, see the &lt;a href=&quot;testing#testing-guidelines&quot;&gt;Testing Guidelines&lt;/a&gt;</source>
          <target state="translated">这个模块应该在一个位置为numpy测试提供所有通用功能，以便&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/dev/development_environment.html#development-environment&quot;&gt;测试脚本&lt;/a&gt;可以将其导入并立即运行。有关背景，请参见&lt;a href=&quot;testing#testing-guidelines&quot;&gt;测试准则&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="feb22e5bb35e33b30ed01dab66654627fe20956a" translate="yes" xml:space="preserve">
          <source>This specifies the &amp;ldquo;intention&amp;rdquo; of the corresponding argument. &lt;code&gt;&amp;lt;intentspec&amp;gt;&lt;/code&gt; is a comma separated list of the following keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e999bfd9ee7986bb74545207acc796f3e46abd8" translate="yes" xml:space="preserve">
          <source>This specifies which warnings to configure as &amp;lsquo;raise&amp;rsquo; instead of being shown once during the test execution. Valid strings are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="355c08a8b685b52031d6593cc7642f8973231125" translate="yes" xml:space="preserve">
          <source>This step is only needed for final releases and can be skipped for pre-releases. &lt;code&gt;make merge-doc&lt;/code&gt; clones the &lt;code&gt;numpy/doc&lt;/code&gt; repo into &lt;code&gt;doc/build/merge&lt;/code&gt; and updates it with the new documentation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04c1b598b018608346e9a082214a1abd34ac499" translate="yes" xml:space="preserve">
          <source>This string will be used as the marker for missing data for all the columns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96875a0b29939a3e2bb067cb066089a92949861" translate="yes" xml:space="preserve">
          <source>This structure is very useful when shape and/or strides information is supposed to be interpreted. The structure is:</source>
          <target state="translated">当需要解释形状和/或步幅信息时,这个结构非常有用。该结构是:</target>
        </trans-unit>
        <trans-unit id="f5377b9ec1ee34b1b46afca48f12d70eda083569" translate="yes" xml:space="preserve">
          <source>This style allows passing in the &lt;a href=&quot;generated/numpy.dtype.fields#numpy.dtype.fields&quot;&gt;&lt;code&gt;fields&lt;/code&gt;&lt;/a&gt; attribute of a data-type object.</source>
          <target state="translated">这种样式允许传入数据类型对象的&lt;a href=&quot;generated/numpy.dtype.fields#numpy.dtype.fields&quot;&gt; &lt;code&gt;fields&lt;/code&gt; &lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="8baa5c3fa91f9d82d5f372676363ca92358b6704" translate="yes" xml:space="preserve">
          <source>This style does not accept &lt;em&gt;align&lt;/em&gt; in the &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; constructor as it is assumed that all of the memory is accounted for by the array interface description.</source>
          <target state="translated">此样式在&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;构造函数中不接受&lt;em&gt;align&lt;/em&gt;，因为假定所有内存均由数组接口描述解决。</target>
        </trans-unit>
        <trans-unit id="63b067d6a5e8e9587ae90576ba34210d81e53f6b" translate="yes" xml:space="preserve">
          <source>This style has two required and three optional keys. The &lt;em&gt;names&lt;/em&gt; and &lt;em&gt;formats&lt;/em&gt; keys are required. Their respective values are equal-length lists with the field names and the field formats. The field names must be strings and the field formats can be any object accepted by &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">此样式具有两个必需键和三个可选键。该&lt;em&gt;名称&lt;/em&gt;和&lt;em&gt;格式&lt;/em&gt;的密钥是必需的。它们各自的值是等长列表，其中包含字段名称和字段格式。字段名称必须是字符串，并且字段格式可以是&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;构造函数接受的任何对象。</target>
        </trans-unit>
        <trans-unit id="9fd39c592746d75bfe12bf10bab5bf15e715d323" translate="yes" xml:space="preserve">
          <source>This subclass of ndarray has some unpleasant interactions with some operations, because it doesn&amp;rsquo;t quite fit properly as a subclass. An alternative to using this subclass is to create the &lt;code&gt;mmap&lt;/code&gt; object yourself, then create an ndarray with ndarray.__new__ directly, passing the object created in its &amp;lsquo;buffer=&amp;rsquo; parameter.</source>
          <target state="translated">ndarray的该子类与某些操作有一些不愉快的交互，因为它不太适合作为子类。使用此子类的另一种方法是自己创建 &lt;code&gt;mmap&lt;/code&gt; 对象，然后直接使用ndarray .__ new__创建一个ndarray，并在其'buffer ='参数中传递创建的对象。</target>
        </trans-unit>
        <trans-unit id="8a52b4cb6a8af65abce36bb79c9c41aa8777063c" translate="yes" xml:space="preserve">
          <source>This tells you that you are currently on the &lt;code&gt;master&lt;/code&gt; branch, and that you also have a &lt;code&gt;remote&lt;/code&gt; connection to &lt;code&gt;origin/master&lt;/code&gt;. What remote repository is &lt;code&gt;remote/origin&lt;/code&gt;? Try &lt;code&gt;git remote -v&lt;/code&gt; to see the URLs for the remote. They will point to your &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; fork.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49e089f7d3412f57a533b95b4289e1725ee616b3" translate="yes" xml:space="preserve">
          <source>This template converter will replicate all &lt;strong&gt;function&lt;/strong&gt; and &lt;strong&gt;subroutine&lt;/strong&gt; blocks in the file with names that contain &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; according to the rules in &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo;. The number of comma-separated words in &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; determines the number of times the block is repeated. What these words are indicates what that repeat rule, &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo;, should be replaced with in each block. All of the repeat rules in a block must contain the same number of comma-separated words indicating the number of times that block should be repeated. If the word in the repeat rule needs a comma, leftarrow, or rightarrow, then prepend it with a backslash &amp;lsquo; &amp;lsquo;. If a word in the repeat rule matches &amp;lsquo; \&amp;lt;index&amp;gt;&amp;rsquo; then it will be replaced with the &amp;lt;index&amp;gt;-th word in the same repeat specification. There are two forms for the repeat rule: named and short.</source>
          <target state="translated">该模板转换器将复制所有&lt;strong&gt;功能&lt;/strong&gt;和&lt;strong&gt;子例程&lt;/strong&gt;根据&amp;ldquo; &amp;lt;&amp;hellip;&amp;gt;&amp;rdquo;中的规则，使用名称包含&amp;ldquo; &amp;lt;&amp;hellip;&amp;gt;&amp;rdquo;的文件中的块。 &amp;ldquo; &amp;lt;&amp;hellip;&amp;gt;&amp;rdquo;中逗号分隔的单词数决定了该块重复的次数。这些单词表示在每个块中应将重复规则&amp;ldquo; &amp;lt;&amp;hellip;&amp;gt;&amp;rdquo;替换为什么。块中的所有重复规则必须包含相同数量的逗号分隔的单词，以指示该块应重复的次数。如果重复规则中的单词需要逗号，左箭头或右箭头，则在其前面加上反斜杠&amp;ldquo;&amp;rdquo;。如果重复规则中的单词与&amp;ldquo; \ &amp;lt;index&amp;gt;&amp;rdquo;匹配，则它将被同一重复规范中的第&amp;lt;index&amp;gt;个单词替换。重复规则有两种形式：named和short。</target>
        </trans-unit>
        <trans-unit id="e17f08578fff4f4b7f45b2cc421b1a2466a7ddfd" translate="yes" xml:space="preserve">
          <source>This tutorial is for people who have a basic understanding of linear algebra and arrays in NumPy and want to understand how n-dimensional (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4e248732bbeee435a6603f84a77d8416a7d7b4" translate="yes" xml:space="preserve">
          <source>This tutorial is intended as a quick overview of algebra and arrays in NumPy and want to understand how n-dimensional (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3fb6c8e0c4b1a20c93f451ff612ab566979e83c" translate="yes" xml:space="preserve">
          <source>This type provides an iterator that encapsulates the concept of broadcasting. It allows</source>
          <target state="translated">该类型提供了一个封装广播概念的迭代器。它允许</target>
        </trans-unit>
        <trans-unit id="1cc43cfc53c5139a19951c354fea30226e0f77c2" translate="yes" xml:space="preserve">
          <source>This updates your feature branch with changes from the upstream &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy github&lt;/a&gt; repo. If you do not absolutely need to do this, try to avoid doing it, except perhaps when you are finished. The first step will be to update the remote repository with new commits from upstream:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fedc2274acc4b818673988228fa9cde0f7271aad" translate="yes" xml:space="preserve">
          <source>This usage is discouraged, because it is ambiguous with the other dict-based construction method. If you have a field called &amp;lsquo;names&amp;rsquo; and a field called &amp;lsquo;formats&amp;rsquo; there will be a conflict.</source>
          <target state="translated">不鼓励这种用法，因为它与其他基于dict的构造方法不明确。如果您有一个名为&amp;ldquo;名称&amp;rdquo;的字段和一个名为&amp;ldquo;格式&amp;rdquo;的字段，则将发生冲突。</target>
        </trans-unit>
        <trans-unit id="57872c5abdb149b7d4963cf4f155c74d4913dff4" translate="yes" xml:space="preserve">
          <source>This version replaces the ASCII string (which in practice was latin1) with a utf8-encoded string, so supports structured types with any unicode field names.</source>
          <target state="translated">这个版本用utf8编码的字符串替换了ASCII字符串(实际上是latin1),所以支持任何unicode字段名的结构化类型。</target>
        </trans-unit>
        <trans-unit id="edc2f7bd6317d38177dd997f322c5b71aa234a4f" translate="yes" xml:space="preserve">
          <source>This view has the same dtype and itemsize as the indexed field, so it is typically a non-structured array, except in the case of nested structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f66a767f0f656eca452c102d2e2bcfa75e3b2eec" translate="yes" xml:space="preserve">
          <source>This way of working helps to keep work well organized and the history as clear as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd10a8b1d06600ccbaab74bb218a771768eae1ee" translate="yes" xml:space="preserve">
          <source>This will ask for your key PGP passphrase, in order to sign the built source packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6efd49b695f694142bfb54798d0f3fc1890e14" translate="yes" xml:space="preserve">
          <source>This will be a new view object if possible; otherwise, it will be a copy. Note there is no guarantee of the &lt;em&gt;memory layout&lt;/em&gt; (C- or Fortran- contiguous) of the returned array.</source>
          <target state="translated">如果可能，这将是一个新的视图对象；否则，它将是副本。注意，不能保证返回数组的&lt;em&gt;内存布局&lt;/em&gt;（C或Fortran连续）。</target>
        </trans-unit>
        <trans-unit id="8a5efb1ea8118b8207bdfa5a6ca70f84b9755cf3" translate="yes" xml:space="preserve">
          <source>This will be the default for all columns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee2bb240a6f906f9c6caaca502a22c771c78509" translate="yes" xml:space="preserve">
          <source>This will compile numpy on 4 CPUs and install it into the specified prefix. to perform a parallel in-place build, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82de4d27fe00c2e50e0f9b4ff494406f1e8a2a9f" translate="yes" xml:space="preserve">
          <source>This will create a report in &lt;code&gt;build/coverage&lt;/code&gt;, which can be viewed with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8933167843c02b6efd0369f05c57b0cadbffbc22" translate="yes" xml:space="preserve">
          <source>This will install the file foo.ini into the directory package_dir/lib, and the foo.ini file will be generated from foo.ini.in, where each &lt;code&gt;@version@&lt;/code&gt; will be replaced by &lt;code&gt;subst_dict['version']&lt;/code&gt;. The dictionary has an additional prefix substitution rule automatically added, which contains the install prefix (since this is not easy to get from setup.py). npy-pkg-config files can also be installed at the same location as used for numpy, using the path returned from &lt;code&gt;get_npy_pkg_dir&lt;/code&gt; function.</source>
          <target state="translated">这会将foo.ini文件安装到package_dir / lib目录中，并且foo.ini文件将从foo.ini.in生成，其中每个 &lt;code&gt;@version@&lt;/code&gt; 都将由 &lt;code&gt;subst_dict['version']&lt;/code&gt; 替换。该词典有一个自动添加的附加前缀替换规则，其中包含安装前缀（因为从setup.py很难获得此前缀）。还可以使用 &lt;code&gt;get_npy_pkg_dir&lt;/code&gt; 函数返回的路径将npy-pkg-config文件安装在与numpy相同的位置。</target>
        </trans-unit>
        <trans-unit id="520884ce9a07e1b7b3267f965a90c87f51ddd2d6" translate="yes" xml:space="preserve">
          <source>This will open an editor with the following text in it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="939c7c1369b63ae063d5f436c52d25c44b07c327" translate="yes" xml:space="preserve">
          <source>This will produce an extension module named filter.so in the current directory with a method named dfilter2d that returns a filtered version of the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4b4079ec57ef48d099df7ab2d17f04629ceaf5" translate="yes" xml:space="preserve">
          <source>This will work with MSVC, which otherwise chokes on very long strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f5f63667326a5abebdc8b9ee9a7240e62a05f5" translate="yes" xml:space="preserve">
          <source>This will write the settings into your git configuration file, which should now contain a user section with your name and email:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00582fa3dde2e164fba27e484b480804eaaba584" translate="yes" xml:space="preserve">
          <source>This works for both standard installs and in-place builds, i.e. the &lt;code&gt;@prefix@&lt;/code&gt; refer to the source directory for in-place builds.</source>
          <target state="translated">这适用于标准安装和就地构建，即 &lt;code&gt;@prefix@&lt;/code&gt; 指代就地构建的源目录。</target>
        </trans-unit>
        <trans-unit id="8dbc0909265236a8e2f517b68e39944b2e4da272" translate="yes" xml:space="preserve">
          <source>Those can be useful for precise floating point comparison.</source>
          <target state="translated">这些可以用于精确的浮点比较。</target>
        </trans-unit>
        <trans-unit id="ae29a3649bad434c98c44c18fb3c7ec696b132a3" translate="yes" xml:space="preserve">
          <source>Those who want really good performance out of their low level operations should strongly consider directly using the iteration API provided in C, but for those who are not comfortable with C or C++, Cython is a good middle ground with reasonable performance tradeoffs. For the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object, this means letting the iterator take care of broadcasting, dtype conversion, and buffering, while giving the inner loop to Cython.</source>
          <target state="translated">那些希望通过低级操作获得真正好的性能的人应该强烈考虑直接使用C中提供的迭代API，但是对于那些不熟悉C或C ++的人，Cython是一个很好的中间点，可以进行合理的性能折衷。对于&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;对象，这意味着让迭代器负责广播，dtype转换和缓冲，同时为Cython提供内部循环。</target>
        </trans-unit>
        <trans-unit id="69a5e45c8dfd90560d7c862ef6ebab38e4725ee6" translate="yes" xml:space="preserve">
          <source>Though the demonstrated way of wrapping Fortran routines to Python is very straightforward, it has several drawbacks (see the comments above). These drawbacks are due to the fact that there is no way that F2PY can determine what is the actual intention of one or the other argument, is it input or output argument, or both, or something else. So, F2PY conservatively assumes that all arguments are input arguments by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea9f95f9e9b92d3d1f748e1eafd1b88bb106fab" translate="yes" xml:space="preserve">
          <source>Though we welcome people fluent in all languages, NumPy development is conducted in English.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35e557dff981ec6af1be9c041d1715ad421f55bd" translate="yes" xml:space="preserve">
          <source>Threading support</source>
          <target state="translated">线程支持</target>
        </trans-unit>
        <trans-unit id="2d3ac6352887bde0f838813d8ea2d7bd7a567c2f" translate="yes" xml:space="preserve">
          <source>Three common use cases are:</source>
          <target state="translated">三个常见的使用案例是:</target>
        </trans-unit>
        <trans-unit id="cfe35da7de09a2e27452780257d1fa8fced9ae75" translate="yes" xml:space="preserve">
          <source>Three ways to wrap - getting started</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987f8885750fc51202cc3964c96525b26400aa8c" translate="yes" xml:space="preserve">
          <source>Three-by-two array of random numbers from [-5, 0):</source>
          <target state="translated">从[-5,0)开始的三乘二随机数组。</target>
        </trans-unit>
        <trans-unit id="648f2b8e04236f9ba0d33739777255491d46f3b0" translate="yes" xml:space="preserve">
          <source>Threshold below which SVD values are considered zero. If &lt;code&gt;tol&lt;/code&gt; is None, and &lt;code&gt;S&lt;/code&gt; is an array with singular values for &lt;code&gt;M&lt;/code&gt;, and &lt;code&gt;eps&lt;/code&gt; is the epsilon value for datatype of &lt;code&gt;S&lt;/code&gt;, then &lt;code&gt;tol&lt;/code&gt; is set to &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt;.</source>
          <target state="translated">低于该阈值的SVD值被视为零。如果 &lt;code&gt;tol&lt;/code&gt; 为None，并且 &lt;code&gt;S&lt;/code&gt; 为具有 &lt;code&gt;M&lt;/code&gt; 的奇异值的数组，并且 &lt;code&gt;eps&lt;/code&gt; 为 &lt;code&gt;S&lt;/code&gt; 的数据类型的epsilon值，则 &lt;code&gt;tol&lt;/code&gt; 设置为 &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a18ce980b9b6a0af6ba5335aa5043a3f61a2139" translate="yes" xml:space="preserve">
          <source>Throw a dice 20 times:</source>
          <target state="translated">扔一个骰子20次。</target>
        </trans-unit>
        <trans-unit id="c6c62c18ed666f3768ae228e6da435d58941de5d" translate="yes" xml:space="preserve">
          <source>Thus, tuples might be thought of as the native Python equivalent to numpy&amp;rsquo;s structured types, much like native python integers are the equivalent to numpy&amp;rsquo;s integer types. Structured scalars may be converted to a tuple by calling &lt;code&gt;ndarray.item&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699ce8b0c5a25495e7df7b31eb754f06f5937265" translate="yes" xml:space="preserve">
          <source>Tile an array.</source>
          <target state="translated">铺设一个阵列。</target>
        </trans-unit>
        <trans-unit id="9478b387e78ee7ed878f28def0d9d737a40db3cf" translate="yes" xml:space="preserve">
          <source>Tiling arrays</source>
          <target state="translated">平铺阵列</target>
        </trans-unit>
        <trans-unit id="ae9e32a7bf76d858a6643fb3d615f4e6b741df45" translate="yes" xml:space="preserve">
          <source>Time span (absolute)</source>
          <target state="translated">时间跨度(绝对值)</target>
        </trans-unit>
        <trans-unit id="83a0b67f984af7843f2cd5f9c4c4a4937a96b824" translate="yes" xml:space="preserve">
          <source>Time span (relative)</source>
          <target state="translated">时间跨度(相对)</target>
        </trans-unit>
        <trans-unit id="f427901653e2f16331f232b03616db8d30b0bf3e" translate="yes" xml:space="preserve">
          <source>Timedelta</source>
          <target state="translated">Timedelta</target>
        </trans-unit>
        <trans-unit id="a836f04893b4c22a5902f8a189928c3d93f72795" translate="yes" xml:space="preserve">
          <source>Timezone information to use when displaying the datetime. If &amp;lsquo;UTC&amp;rsquo;, end with a Z to indicate UTC time. If &amp;lsquo;local&amp;rsquo;, convert to the local timezone first, and suffix with a +-#### timezone offset. If a tzinfo object, then do as with &amp;lsquo;local&amp;rsquo;, but use the specified timezone.</source>
          <target state="translated">显示日期时间时要使用的时区信息。如果为&amp;ldquo; UTC&amp;rdquo;，则以Z结尾以指示UTC时间。如果为'local'，请先转换为本地时区，并以+-####时区偏移量作为后缀。如果是tzinfo对象，则使用'local'，但使用指定的时区。</target>
        </trans-unit>
        <trans-unit id="73a38ab3a76b2ed7df0194513c7633ac39221da4" translate="yes" xml:space="preserve">
          <source>Timing of individual tests with &lt;code&gt;nose-timer&lt;/code&gt; (which needs to be installed). If True, time tests and report on all of them. If an integer (say &lt;code&gt;N&lt;/code&gt;), report timing results for &lt;code&gt;N&lt;/code&gt; slowest tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661d4063b8ec8980f63428513015c42d7d7a39d4" translate="yes" xml:space="preserve">
          <source>Timings</source>
          <target state="translated">Timings</target>
        </trans-unit>
        <trans-unit id="535904f7958066905a2c6d516287e9eeaaa0c6e1" translate="yes" xml:space="preserve">
          <source>Timsort and radix sort have replaced mergesort for stable sorting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18696f01e06a1b84af54b40680c306637cf01d64" translate="yes" xml:space="preserve">
          <source>Timsort is added for better performance on already or nearly sorted data. On random data timsort is almost identical to mergesort. It is now used for stable sort while quicksort is still the default sort if none is chosen. For details of timsort, refer to &lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt&lt;/a&gt;. &amp;lsquo;mergesort&amp;rsquo; and &amp;lsquo;stable&amp;rsquo; are mapped to radix sort for integer data types. Radix sort is an O(n) sort instead of O(n log n).</source>
          <target state="translated">添加Timsort可以提高对已分类或已分类数据的性能。在随机数据上，timsort与mergesort几乎相同。现在，它用于稳定排序，而如果未选择，则快速排序仍是默认排序。有关timsort的详细信息，请参见&lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt&lt;/a&gt;。'mergesort'和'stable'被映射为整数数据类型的基数排序。基数排序是O（n）排序，而不是O（n log n）。</target>
        </trans-unit>
        <trans-unit id="4c9ab7d1647422ac2345aafe56b9ec321ff2ddfd" translate="yes" xml:space="preserve">
          <source>Timsort is added for better performance on already or nearly sorted data. On random data timsort is almost identical to mergesort. It is now used for stable sort while quicksort is still the default sort if none is chosen. For timsort details, refer to &lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt&lt;/a&gt;. &amp;lsquo;mergesort&amp;rsquo; and &amp;lsquo;stable&amp;rsquo; are mapped to radix sort for integer data types. Radix sort is an O(n) sort instead of O(n log n).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="e4a5f9b37a824ec47658f0ce1a5ad5ba55b84339" translate="yes" xml:space="preserve">
          <source>Tip: &lt;code&gt;entry&lt;/code&gt; statement can be used to describe the signature of an arbitrary routine allowing F2PY to generate a number of wrappers from only one routine block signature. There are few restrictions while doing this: &lt;code&gt;fortranname&lt;/code&gt; cannot be used, &lt;code&gt;callstatement&lt;/code&gt; and &lt;code&gt;callprotoargument&lt;/code&gt; can be used only if they are valid for all entry routines, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96f3984eaaf637764ee32773288dabcc604bf6b" translate="yes" xml:space="preserve">
          <source>Tips &amp;amp; Tricks</source>
          <target state="translated">提示与技巧</target>
        </trans-unit>
        <trans-unit id="caa39d36bfce368de59fb6b06774c2bd179f06cf" translate="yes" xml:space="preserve">
          <source>Title case words start with uppercase characters, all remaining cased characters are lowercase.</source>
          <target state="translated">标题大小写字以大写字符开头,其余大小写字符均为小写。</target>
        </trans-unit>
        <trans-unit id="45c41172aa1c58d7ba017f081fcd4e2ace4e86f0" translate="yes" xml:space="preserve">
          <source>Title that is printed in the string representation of &lt;a href=&quot;#numpy.MachAr&quot;&gt;&lt;code&gt;MachAr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">以&lt;a href=&quot;#numpy.MachAr&quot;&gt; &lt;code&gt;MachAr&lt;/code&gt; &lt;/a&gt;的字符串表示形式打印的标题。</target>
        </trans-unit>
        <trans-unit id="20fb23c1b6aaaab924d80202c9bd41b9e867e2de" translate="yes" xml:space="preserve">
          <source>To Cython-ize this function, we replace the inner loop (y[&amp;hellip;] += x*x) with Cython code that&amp;rsquo;s specialized for the float64 dtype. With the &amp;lsquo;external_loop&amp;rsquo; flag enabled, the arrays provided to the inner loop will always be one-dimensional, so very little checking needs to be done.</source>
          <target state="translated">为了用Cython实现此功能，我们用专用于float64 dtype的Cython代码替换了内部循环（y [&amp;hellip;] + = x * x）。启用&amp;ldquo; external_loop&amp;rdquo;标志后，提供给内部循环的数组将始终是一维的，因此几乎不需要进行检查。</target>
        </trans-unit>
        <trans-unit id="36e086a6bd3eb648c4aebbd467026f4cd1c91bb0" translate="yes" xml:space="preserve">
          <source>To achieve a behaviour similar to the basic slicing above, broadcasting can be used. The function &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; can help with this broadcasting. This is best understood with an example.</source>
          <target state="translated">为了实现类似于上述基本切片的行为，可以使用广播。功能&lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt;可以帮助进行广播。最好用一个例子来理解。</target>
        </trans-unit>
        <trans-unit id="157492b79c5123115a363aac40a6322c3b4d23a2" translate="yes" xml:space="preserve">
          <source>To achieve what we want, we will make the following changes to it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d82eff9778b88421c109607c96725b336dc7bcf8" translate="yes" xml:space="preserve">
          <source>To actually build the binaries after everything is set up correctly, the release.sh script can be used. For details of the build process itself, it is best to read the pavement.py script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76b68b96c698129b0e21483e667a083f4f8f28a" translate="yes" xml:space="preserve">
          <source>To add the rows or the columns in a 2D array, you would specify the axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0b09a56b5f5cb6866275af7bae4ae9b88cd546" translate="yes" xml:space="preserve">
          <source>To add titles when using the list-of-tuples form of dtype specification, the field name may be specified as a tuple of two strings instead of a single string, which will be the field&amp;rsquo;s title and field name respectively. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c09cbfb1aed4718ffc26452a3968e86a1cd3bc" translate="yes" xml:space="preserve">
          <source>To allow the datetime to be used in contexts where only certain days of the week are valid, NumPy includes a set of &amp;ldquo;busday&amp;rdquo; (business day) functions.</source>
          <target state="translated">为了允许仅在一周中的某些天有效的上下文中使用日期时间，NumPy包括一组&amp;ldquo; busday&amp;rdquo;（工作日）功能。</target>
        </trans-unit>
        <trans-unit id="846af85fcfe300adce4c3f84895144d6dc4a75b5" translate="yes" xml:space="preserve">
          <source>To be completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ad91f78d6c9353549254a135a4c203ecca9427" translate="yes" xml:space="preserve">
          <source>To be consistent with surrounding code that also breaks it (maybe for historic reasons) &amp;ndash; although this is also an opportunity to clean up someone else&amp;rsquo;s mess.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172099588df066f08374020a56522cb6cad0b84f" translate="yes" xml:space="preserve">
          <source>To become eligible to join the Steering Council, an individual must be a Project Contributor who has produced contributions that are substantial in quality and quantity, and sustained over at least one year. Potential Council Members are nominated by existing Council members, and become members following consensus of the existing Council members, and confirmation that the potential Member is interested and willing to serve in that capacity. The Council will be initially formed from the set of existing Core Developers who, as of late 2015, have been significantly active over the last year.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85134bce24b996ec39a48245eda44b01d4da42e0" translate="yes" xml:space="preserve">
          <source>To begin to make use of the new data-type, you need to first define a new Python type to hold the scalars of your new data-type. It should be acceptable to inherit from one of the array scalars if your new type has a binary compatible layout. This will allow your new data type to have the methods and attributes of array scalars. New data- types must have a fixed memory size (if you want to define a data-type that needs a flexible representation, like a variable-precision number, then use a pointer to the object as the data-type). The memory layout of the object structure for the new Python type must be PyObject_HEAD followed by the fixed-size memory needed for the data- type. For example, a suitable structure for the new Python type is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c381239eecf186cabc8bbf33e7f7340c36dd415" translate="yes" xml:space="preserve">
          <source>To build an extension module, use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="262ab678dba163772e713fb5aa569cad52138f55" translate="yes" xml:space="preserve">
          <source>To build any extension modules for Python, you&amp;rsquo;ll need a C compiler. Various NumPy modules use FORTRAN 77 libraries, so you&amp;rsquo;ll also need a FORTRAN 77 compiler installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7e5cfb4630032e513b61c1b673be491694cda68" translate="yes" xml:space="preserve">
          <source>To build docs, run &lt;code&gt;make&lt;/code&gt; from the &lt;code&gt;doc&lt;/code&gt; directory. &lt;code&gt;make help&lt;/code&gt; lists all targets. For example, to build the HTML documentation, you can run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0116b47532b1c9e3e3765cf9819856a98d018b60" translate="yes" xml:space="preserve">
          <source>To build the PDF documentation, do instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06915cfab63303daaadd53bd88f46eb60701ce38" translate="yes" xml:space="preserve">
          <source>To build the development version of NumPy and run tests, spawn interactive shells with the Python import paths properly set up etc., do one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e6dd105e1e44140e34cc1b1405df856709feb0" translate="yes" xml:space="preserve">
          <source>To build the final approximation matrix, we must understand how multiplication across different axes works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9057f4f734687a0b8a5f3961b0c067a8d6921992" translate="yes" xml:space="preserve">
          <source>To change the dimensions of an array, you can omit one of the sizes which will then be deduced automatically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e2711afc65081105d063104c0dfaff7b844b23" translate="yes" xml:space="preserve">
          <source>To commit the staged files into the local copy of your repo, do &lt;code&gt;git
commit&lt;/code&gt;. At this point, a text editor will open up to allow you to write a commit message. Read the &lt;a href=&quot;#writing-the-commit-message&quot;&gt;commit message section&lt;/a&gt; to be sure that you are writing a properly formatted and sufficiently detailed commit message. After saving your message and closing the editor, your commit will be saved. For trivial commits, a short commit message can be passed in through the command line using the &lt;code&gt;-m&lt;/code&gt; flag. For example, &lt;code&gt;git commit -am &quot;ENH: Some message&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e713f5c0c4fc2dee368727d5468ec1ab8e8b8170" translate="yes" xml:space="preserve">
          <source>To construct an extension module, use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3a9fa41ffe14d77bbc445c74fe6fd7a66d7a2d" translate="yes" xml:space="preserve">
          <source>To convert the type of an array, use the .astype() method (preferred) or the type itself as a function. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982c13e7b2d67cdbdf6848604f9d8f779a4cdca3" translate="yes" xml:space="preserve">
          <source>To create a NumPy array, you can use the function &lt;code&gt;np.array()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8941cedf9a3b3622178e2a604f85c6f9966d6beb" translate="yes" xml:space="preserve">
          <source>To create a masked array where all values close to 1.e20 are invalid, we would do:</source>
          <target state="translated">要创建一个掩码数组,所有接近1.e20的值都是无效的,我们可以这样做。</target>
        </trans-unit>
        <trans-unit id="e67f8cba1a223a6d273b67fa4a3d036f127fda38" translate="yes" xml:space="preserve">
          <source>To create a sub-type, a similar procedure must be followed except only behaviors that are different require new entries in the type- object structure. All other entries can be NULL and will be filled in by &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt;&lt;code&gt;PyType_Ready&lt;/code&gt;&lt;/a&gt; with appropriate functions from the parent type(s). In particular, to create a sub-type in C follow these steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdf86d74a7427ac0a22c6f0a9b96d12080099d0c" translate="yes" xml:space="preserve">
          <source>To create an array with the second element invalid, we would do:</source>
          <target state="translated">要创建一个第二个元素无效的数组,我们可以这样做。</target>
        </trans-unit>
        <trans-unit id="27de4fde4d9713bb683ffd50eb85f9b3570fc745" translate="yes" xml:space="preserve">
          <source>To create sequences of numbers, NumPy provides the &lt;code&gt;arange&lt;/code&gt; function which is analogous to the Python built-in &lt;code&gt;range&lt;/code&gt;, but returns an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ab86f3d69d58ce3be53a871603ed078f8824cf" translate="yes" xml:space="preserve">
          <source>To describe the type of scalar data, there are several &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;built-in scalar types&lt;/a&gt; in NumPy for various precision of integers, floating-point numbers, &lt;em&gt;etc&lt;/em&gt;. An item extracted from an array, &lt;em&gt;e.g.&lt;/em&gt;, by indexing, will be a Python object whose type is the scalar type associated with the data type of the array.</source>
          <target state="translated">为了描述标量数据的&lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;类型&lt;/a&gt;，NumPy中有几种内置标量类型，用于整数，浮点数&lt;em&gt;等的&lt;/em&gt;各种精度。从数组（&lt;em&gt;例如&lt;/em&gt;通过索引）提取的项目将是Python对象，其类型是与数组的数据类型关联的标量类型。</target>
        </trans-unit>
        <trans-unit id="44e1fab9f28a4fa50d8975e0a1e46a2e64c1e9dc" translate="yes" xml:space="preserve">
          <source>To determine the type of an array, look at the dtype attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f971fbdece5884152a2421faf1e4b6e44db96d0" translate="yes" xml:space="preserve">
          <source>To disable this behaviour and force NumPy to print the entire array, you can change the printing options using &lt;code&gt;set_printoptions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42815d30b39c91ade5f76679c62182278601bee8" translate="yes" xml:space="preserve">
          <source>To do buffered reduction requires yet another adjustment during the setup. Normally the iterator construction involves copying the first buffer of data from the readable arrays into the buffer. Any reduction operand is readable, so it may be read into a buffer. Unfortunately, initialization of the operand after this buffering operation is complete will not be reflected in the buffer that the iteration starts with, and garbage results will be produced.</source>
          <target state="translated">要进行缓冲区缩减,需要在设置过程中再进行一次调整。通常迭代器的构造包括将第一个缓冲区的数据从可读数组中复制到缓冲区中。任何还原操作数都是可读的,所以可以将其读入缓冲区。遗憾的是,在这个缓冲操作完成后,操作数的初始化将不会反映在迭代开始的缓冲区中,并且会产生垃圾结果。</target>
        </trans-unit>
        <trans-unit id="7bb73bf7d0560f6eb01b8f605dab2705b707dec2" translate="yes" xml:space="preserve">
          <source>To do this we need two files. The first is the C file which contains the actual code, and the second is the setup.py file used to create the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3fff7f3035206492b3a95d3cbf852432de0dee" translate="yes" xml:space="preserve">
          <source>To enable and control broadcasting, use an ellipsis. Default NumPy-style broadcasting is done by adding an ellipsis to the left of each term, like &lt;code&gt;np.einsum('...ii-&amp;gt;...i', a)&lt;/code&gt;. To take the trace along the first and last axes, you can do &lt;code&gt;np.einsum('i...i', a)&lt;/code&gt;, or to do a matrix-matrix product with the left-most indices instead of rightmost, one can do &lt;code&gt;np.einsum('ij...,jk...-&amp;gt;ik...', a, b)&lt;/code&gt;.</source>
          <target state="translated">要启用和控制广播，请使用省略号。默认的NumPy样式广播是通过在每个术语的左侧添加省略号来完成的，例如 &lt;code&gt;np.einsum('...ii-&amp;gt;...i', a)&lt;/code&gt; 。要沿第一个轴和最后一个轴进行跟踪，可以执行 &lt;code&gt;np.einsum('i...i', a)&lt;/code&gt; ，或者使用最左边的索引而不是最右边的索引做矩阵矩阵乘积， &lt;code&gt;np.einsum('ij...,jk...-&amp;gt;ik...', a, b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73e17138c97818c1d4c0e646e333300b5a17a016" translate="yes" xml:space="preserve">
          <source>To enforce summaries when doing merges (&lt;code&gt;~/.gitconfig&lt;/code&gt; file again):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b64a95ca31ed1440ed9609a8efdae966875477" translate="yes" xml:space="preserve">
          <source>To ensure all elements within an &lt;code&gt;object&lt;/code&gt; array are copied, use &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d44cf88fb39b36da11cf8bbe02f976134b23c7" translate="yes" xml:space="preserve">
          <source>To facilitate easy matching of array shapes with expressions and in assignments, the np.newaxis object can be used within array indices to add new dimensions with a size of 1. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09fc0ca575462761f878d637a2fecf46e1ccd71c" translate="yes" xml:space="preserve">
          <source>To facilitate this many similar unit tests, some high-level programming techniques are employed, including C and &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; macros, as well as Python inheritance. The purpose of this document is to describe the testing infrastructure employed to verify that the &lt;code&gt;numpy.i&lt;/code&gt; typemaps are working as expected.</source>
          <target state="translated">为了促进许多类似的单元测试，采用了一些高级编程技术，包括C和&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;宏以及Python继承。本文档的目的是描述用于验证 &lt;code&gt;numpy.i&lt;/code&gt; 类型图是否按预期工作的测试基础结构。</target>
        </trans-unit>
        <trans-unit id="df1248d3a4c3c276bf78a49ecea34ca2333414db" translate="yes" xml:space="preserve">
          <source>To find how many valid days there are in a specified range of datetime64 dates, use &lt;a href=&quot;generated/numpy.busday_count#numpy.busday_count&quot;&gt;&lt;code&gt;busday_count&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要查找在指定的datetime64日期范围内有多少有效天，请使用&lt;a href=&quot;generated/numpy.busday_count#numpy.busday_count&quot;&gt; &lt;code&gt;busday_count&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="319db282e290412afdbf4c23744ae53a90ac551e" translate="yes" xml:space="preserve">
          <source>To find the number of dimensions of the array, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3533d0798888b92292cdc274cd5cbd4e7bdef89" translate="yes" xml:space="preserve">
          <source>To find the total number of elements in the array, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381cf7b173efa6d304977d6f48b6eab1589b8ebf" translate="yes" xml:space="preserve">
          <source>To find the union of more than two arrays, use functools.reduce:</source>
          <target state="translated">要找到两个以上数组的联合,使用functools.reduce.commit。</target>
        </trans-unit>
        <trans-unit id="f20ef83823da30eba7178dbce314c99b1ef83b27" translate="yes" xml:space="preserve">
          <source>To get a feel for writing custom array containers, we&amp;rsquo;ll begin with a simple example that has rather narrow utility but illustrates the concepts involved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a3751da83fe0d7f7a6c4230ed886f73729cca0" translate="yes" xml:space="preserve">
          <source>To get back to a plain ndarray both the dtype and type must be reset. The following view does so, taking into account the unusual case that the recordarr was not a structured type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4469a3b55f422122d26688e1424f485904a4794e" translate="yes" xml:space="preserve">
          <source>To get the indices of unique values in a NumPy array (an array of first index positions of unique values in the array), just pass the &lt;code&gt;return_index&lt;/code&gt; argument in &lt;code&gt;np.unique()&lt;/code&gt; as well as your array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05508b4b1612d928370bd8d22c78ce6740d7d75" translate="yes" xml:space="preserve">
          <source>To get the necessary information for the npymath library from NumPy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b92fc58e63db5aa668493a43f6017a9433c467a" translate="yes" xml:space="preserve">
          <source>To get the unique rows, index position, and occurrence count, you can use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb65420b2ca2983f196bbc9804b56531579abff" translate="yes" xml:space="preserve">
          <source>To group the indices by element, rather than dimension, use &lt;a href=&quot;numpy.argwhere#numpy.argwhere&quot;&gt;&lt;code&gt;argwhere&lt;/code&gt;&lt;/a&gt;, which returns a row for each non-zero element.</source>
          <target state="translated">要将索引按元素而不是维度进行&lt;a href=&quot;numpy.argwhere#numpy.argwhere&quot;&gt; &lt;code&gt;argwhere&lt;/code&gt; &lt;/a&gt;，请使用argwhere，它为每个非零元素返回一行。</target>
        </trans-unit>
        <trans-unit id="dd77da9e3cc0e1b206296360b148e66d7e5bf3e1" translate="yes" xml:space="preserve">
          <source>To group the indices by element, rather than dimension, use instead:</source>
          <target state="translated">要按元素而不是按维度对指数进行分组,请使用。</target>
        </trans-unit>
        <trans-unit id="ee4cd0adbfaa4d4a1d76673c36c93886ead4c8dd" translate="yes" xml:space="preserve">
          <source>To have a particular script file executed when the interactive Python interpreter is started, define the &lt;code&gt;PYTHONSTARTUP&lt;/code&gt; environment variable to contain the name of your startup script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01fa3621bdaf741ed6a071c7af18f6f77c074d16" translate="yes" xml:space="preserve">
          <source>To implement the second method, NumPy provides the class-factory function &lt;a href=&quot;#ndpointer&quot;&gt;&lt;code&gt;ndpointer&lt;/code&gt;&lt;/a&gt; in the &lt;a href=&quot;../reference/routines.ctypeslib#module-numpy.ctypeslib&quot;&gt;&lt;code&gt;numpy.ctypeslib&lt;/code&gt;&lt;/a&gt; module. This class-factory function produces an appropriate class that can be placed in an argtypes attribute entry of a ctypes function. The class will contain a from_param method which ctypes will use to convert any ndarray passed in to the function to a ctypes-recognized object. In the process, the conversion will perform checking on any properties of the ndarray that were specified by the user in the call to &lt;a href=&quot;#ndpointer&quot;&gt;&lt;code&gt;ndpointer&lt;/code&gt;&lt;/a&gt;. Aspects of the ndarray that can be checked include the data-type, the number-of-dimensions, the shape, and/or the state of the flags on any array passed. The return value of the from_param method is the ctypes attribute of the array which (because it contains the &lt;code&gt;_as_parameter_&lt;/code&gt; attribute pointing to the array data area) can be used by ctypes directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d801e69012a04f7e0e0473d58cee9ab38e87fd" translate="yes" xml:space="preserve">
          <source>To install NumPy, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5ace9a611ff0639bf97923787f31ff3babad6c" translate="yes" xml:space="preserve">
          <source>To install NumPy, we strongly recommend using a scientific Python distribution. If you&amp;rsquo;re looking for the full instructions for installing NumPy on your operating system, you can &lt;a href=&quot;https://www.scipy.org/install.html&quot;&gt;find all of the details here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ceadcdbd2ecba0b0b71d04b040d27f4a8978392" translate="yes" xml:space="preserve">
          <source>To intersect more than two arrays, use functools.reduce:</source>
          <target state="translated">要与两个以上的数组相交,请使用 functools.reduce.reduce。</target>
        </trans-unit>
        <trans-unit id="1eeff99dc3325ea11208d15f34bf3ae08056f134" translate="yes" xml:space="preserve">
          <source>To keep in sync with changes in NumPy, you want to set up your repository so it pulls from &lt;code&gt;upstream&lt;/code&gt; by default. This can be done with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422eea08f184929b902e9a6c5257e9028826306a" translate="yes" xml:space="preserve">
          <source>To learn more about finding the unique elements in an array, see &lt;a href=&quot;../reference/generated/numpy.unique#numpy.unique&quot;&gt;&lt;code&gt;unique&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f5278c1b18ea2b8e10ed17f38664074c6889df4" translate="yes" xml:space="preserve">
          <source>To learn more about transposing and reshaping arrays, see &lt;a href=&quot;../reference/generated/numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;reshape&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68755700558e4129caf4a1646cfbb8316cee0dd6" translate="yes" xml:space="preserve">
          <source>To make an iterator similar to the old iterator, this should work.</source>
          <target state="translated">要做一个类似于老迭代器的迭代器,这个应该可以。</target>
        </trans-unit>
        <trans-unit id="6d696015c14a0cbcd57511007788b5810594a8d0" translate="yes" xml:space="preserve">
          <source>To make its properties more readily accessible during iteration, &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; has an alternative syntax for iterating, which works explicitly with the iterator object itself. With this looping construct, the current value is accessible by indexing into the iterator. Other properties, such as tracked indices remain as before. The examples below produce identical results to the ones in the previous section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb62bb890eb45640b1d129077fff1a1982947c5" translate="yes" xml:space="preserve">
          <source>To make the necessary build options available to third parties, you could use the &lt;code&gt;npy-pkg-config&lt;/code&gt; mechanism implemented in &lt;a href=&quot;#module-numpy.distutils&quot;&gt;&lt;code&gt;numpy.distutils&lt;/code&gt;&lt;/a&gt;. This mechanism is based on a .ini file which contains all the options. A .ini file is very similar to .pc files as used by the pkg-config unix utility:</source>
          <target state="translated">为了进行必要的编译选项提供给第三方，您可以使用 &lt;code&gt;npy-pkg-config&lt;/code&gt; 中实现机制&lt;a href=&quot;#module-numpy.distutils&quot;&gt; &lt;code&gt;numpy.distutils&lt;/code&gt; &lt;/a&gt;。此机制基于包含所有选项的.ini文件。.ini文件与pkg-config unix实用程序使用的.pc文件非常相似：</target>
        </trans-unit>
        <trans-unit id="33556655b7ed4636c5875606d6d2c0f4cbb51bbb" translate="yes" xml:space="preserve">
          <source>To make your key more readily identifiable as you, consider sending your key to public keyservers, with a command such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c1e38c6bb6394f66a0d335e612f3011262ff50" translate="yes" xml:space="preserve">
          <source>To measure the test coverage, install &lt;a href=&quot;https://pytest-cov.readthedocs.io/en/latest/&quot;&gt;pytest-cov&lt;/a&gt; and then run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6239277562da98f7f93ad4e57c8a93f41fe39464" translate="yes" xml:space="preserve">
          <source>To modify your Python search path to include the locations of your own modules, define the &lt;code&gt;PYTHONPATH&lt;/code&gt; environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1963ae310b977b5fdaf7c01ceaf03485096cb4" translate="yes" xml:space="preserve">
          <source>To override the automatic detection of available memory, set the environment variable &lt;code&gt;NPY_AVAILABLE_MEM&lt;/code&gt;, for example &lt;code&gt;NPY_AVAILABLE_MEM=32GB&lt;/code&gt;, or using pytest &lt;code&gt;--available-memory=32GB&lt;/code&gt; target option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1c61949e0ad3dc492f05ebb9e5438319174c320" translate="yes" xml:space="preserve">
          <source>To perform an in-place build that can be run from the source folder run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c334cf8d4bed58e0564b6be3f28b72afdf600e2c" translate="yes" xml:space="preserve">
          <source>To proceed, import the linear algebra submodule from NumPy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02d722ee9de32d295a3f1aa488c332a62e29240a" translate="yes" xml:space="preserve">
          <source>To put back the default options, you can use:</source>
          <target state="translated">要放回默认选项,你可以使用。</target>
        </trans-unit>
        <trans-unit id="4f4e1d38162c68bbafa8964bc64bfa72b23866db" translate="yes" xml:space="preserve">
          <source>To read more about Matplotlib and what it can do, take a look at &lt;a href=&quot;https://matplotlib.org/&quot;&gt;the official documentation&lt;/a&gt;. For directions regarding installing Matplotlib, see the official &lt;a href=&quot;https://matplotlib.org/users/installing.html&quot;&gt;installation section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98026c8318a10abcb126d49806744b4ae23d3123" translate="yes" xml:space="preserve">
          <source>To read more about concatenate, see: &lt;a href=&quot;../reference/generated/numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="425cb75a01c3201b08612ec800f1a7971e0378d1" translate="yes" xml:space="preserve">
          <source>To read more about sorting an array, see: &lt;a href=&quot;../reference/generated/numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f422775354a46e3c9c41ff160bfb3c38d25920" translate="yes" xml:space="preserve">
          <source>To reduce the chance of misinterpretation, even though the following &amp;ldquo;abuse&amp;rdquo; is nominally supported, &lt;code&gt;choices&lt;/code&gt; should neither be, nor be thought of as, a single array, i.e., the outermost sequence-like container should be either a list or a tuple.</source>
          <target state="translated">为了减少错误解释的机会，即使名义上支持以下&amp;ldquo;滥用&amp;rdquo;， &lt;code&gt;choices&lt;/code&gt; 也不应该也不应被视为单个数组，即，最外面的类似于序列的容器应该是列表或元组。</target>
        </trans-unit>
        <trans-unit id="69f7fdf215ee6723757c121f1000e16153523a1d" translate="yes" xml:space="preserve">
          <source>To retrieve only the valid entries, we can use the inverse of the mask as an index. The inverse of the mask can be calculated with the &lt;a href=&quot;generated/numpy.logical_not#numpy.logical_not&quot;&gt;&lt;code&gt;numpy.logical_not&lt;/code&gt;&lt;/a&gt; function or simply with the &lt;code&gt;~&lt;/code&gt; operator:</source>
          <target state="translated">要仅检索有效条目，我们可以使用掩码的倒数作为索引。可以使用&lt;a href=&quot;generated/numpy.logical_not#numpy.logical_not&quot;&gt; &lt;code&gt;numpy.logical_not&lt;/code&gt; &lt;/a&gt;函数或仅使用 &lt;code&gt;~&lt;/code&gt; 运算符来计算掩码的逆：</target>
        </trans-unit>
        <trans-unit id="e546770d4089912cdd192abaecf0b1e29a9e2943" translate="yes" xml:space="preserve">
          <source>To return the indices of the values common to the input arrays along with the intersected values:</source>
          <target state="translated">返回与输入数组共同的值的索引以及相交的值。</target>
        </trans-unit>
        <trans-unit id="67e6eaca69e6f48eb1845e3b15fc19b5fce3851f" translate="yes" xml:space="preserve">
          <source>To run SciPy&amp;rsquo;s full test suite, use the following:</source>
          <target state="translated">要运行SciPy的完整测试套件，请使用以下命令：</target>
        </trans-unit>
        <trans-unit id="402853161da9a462a3784d2121c2566aac78b1d2" translate="yes" xml:space="preserve">
          <source>To run a benchmark defined in a class, such as &lt;code&gt;Mandelbrot&lt;/code&gt; from &lt;code&gt;bench_avx.py&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3862a782eb6529a8c99b98cef4c13299f47f23c0" translate="yes" xml:space="preserve">
          <source>To run all benchmarks, navigate to the root NumPy directory at the command line and execute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12365d76682fb967acae76310ae656f9290fed8d" translate="yes" xml:space="preserve">
          <source>To run benchmarks from a particular benchmark module, such as &lt;code&gt;bench_core.py&lt;/code&gt;, simply append the filename without the extension:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9661928d3b7e0b0f53e4248625106d96b260f714" translate="yes" xml:space="preserve">
          <source>To sample from N evenly spaced floating-point numbers between a and b, use:</source>
          <target state="translated">要从a和b之间的N个间隔均匀的浮点数字中取样,使用。</target>
        </trans-unit>
        <trans-unit id="cd520022e6b8a6d4a06e76bb94b1b7fee07bd6cf" translate="yes" xml:space="preserve">
          <source>To scan Fortran sources and generate a signature file, use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67f8780eccc675b04bcebf369f6ed02655b97ea2" translate="yes" xml:space="preserve">
          <source>To see a graphical representation of the repository branches and commits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39780ed9cf55125c359d05489224449255a114a4" translate="yes" xml:space="preserve">
          <source>To see a linear list of commits for this branch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79f07a6533e986fa44fe540266db879b8c346cb7" translate="yes" xml:space="preserve">
          <source>To see if an approximation is reasonable, we can check the values in &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc4aaad8d81152b0e7e6f7703b5cec989fcf2cef" translate="yes" xml:space="preserve">
          <source>To see if this makes sense in our image, we should use a colormap from &lt;code&gt;matplotlib&lt;/code&gt; corresponding to the color we wish to see in out image (otherwise, &lt;code&gt;matplotlib&lt;/code&gt; will default to a colormap that does not correspond to the real data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74691658cd7769d44a45cda5e12dd3bc908a227e" translate="yes" xml:space="preserve">
          <source>To see whether F2PY generated interface performs copies of array arguments, use &lt;code&gt;-DF2PY_REPORT_ON_ARRAY_COPY=&amp;lt;int&amp;gt;&lt;/code&gt;. When the size of an array argument is larger than &lt;code&gt;&amp;lt;int&amp;gt;&lt;/code&gt;, a message about the coping is sent to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed1275cdacf759ff47d03a08e3787f0594bb1bb" translate="yes" xml:space="preserve">
          <source>To set up on another computer, you can copy your &lt;code&gt;~/.gitconfig&lt;/code&gt; file, or run the commands above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d884174d72a1ce55f9ee4b7d870c154a7a32b7" translate="yes" xml:space="preserve">
          <source>To skip a test, simply use &lt;code&gt;skipif&lt;/code&gt;:</source>
          <target state="translated">要跳过测试，只需使用 &lt;code&gt;skipif&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3dc6e4230f5944b1098c8c2df7bd61f24c145894" translate="yes" xml:space="preserve">
          <source>To submit your contribution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceffd750378d21341a7019937d0c789148b4f90a" translate="yes" xml:space="preserve">
          <source>To support it, we need to define the Python interfaces &lt;code&gt;__add__&lt;/code&gt;, &lt;code&gt;__lt__&lt;/code&gt;, and so on to dispatch to the corresponding ufunc. We can achieve this conveniently by inheriting from the mixin &lt;a href=&quot;../reference/generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt;&lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="673335eebf9011c1628160cca5d99d26576f081d" translate="yes" xml:space="preserve">
          <source>To take the running sum of four successive values:</source>
          <target state="translated">要取四个连续值的运行之和。</target>
        </trans-unit>
        <trans-unit id="54587f602166cab38648eb3409cd921150aa4e7e" translate="yes" xml:space="preserve">
          <source>To test a datetime64 value to see if it is a valid day, use &lt;a href=&quot;generated/numpy.is_busday#numpy.is_busday&quot;&gt;&lt;code&gt;is_busday&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要测试datetime64值以查看其是否为有效日期，请使用&lt;a href=&quot;generated/numpy.is_busday#numpy.is_busday&quot;&gt; &lt;code&gt;is_busday&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="054b90fbdf163bc568eceff518fb7e05620b88d4" translate="yes" xml:space="preserve">
          <source>To test the performance of F2PY generated interfaces, use &lt;code&gt;-DF2PY_REPORT_ATEXIT&lt;/code&gt;. Then a report of various timings is printed out at the exit of Python. This feature may not work on all platforms, currently only Linux platform is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b5e9d9370a428c2b83ae13e33fb71722d9bb4f" translate="yes" xml:space="preserve">
          <source>To test whether an array is C-contiguous, use the &lt;code&gt;.flags.c_contiguous&lt;/code&gt; attribute of NumPy arrays. To test for Fortran contiguity, use the &lt;code&gt;.flags.f_contiguous&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab2b1e95b971bb4c5c35b359a5634bf815d8fa6" translate="yes" xml:space="preserve">
          <source>To the extent possible under law, the authors have waived all copyright and related or neighboring rights to the NumPy project governance and decision-making document, as per the &lt;a href=&quot;https://creativecommons.org/publicdomain/zero/1.0/&quot;&gt;CC-0 public domain dedication / license&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b06b82cac8a278e2d618ab82ddb18a2d508ecee" translate="yes" xml:space="preserve">
          <source>To the maximum extent possible, Council discussions and activities will be public and done in collaboration and discussion with the Project Contributors and Community. The Council will have a private mailing list that will be used sparingly and only when a specific matter requires privacy. When private communications and decisions are needed, the Council will do its best to summarize those to the Community after eliding personal/private/sensitive information that should not be posted to the public internet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb8696297023077cd0b0457359ff13c01cdb0ce" translate="yes" xml:space="preserve">
          <source>To transform input arrays to column major storage order before passing them to Fortran routines, use the function &lt;code&gt;numpy.asfortranarray(&amp;lt;array&amp;gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecbd73988a92874f75c5ca6f8256cc9806ceef6d" translate="yes" xml:space="preserve">
          <source>To unmask all masked entries of a masked array (provided the mask isn&amp;rsquo;t a hard mask), the simplest solution is to assign the constant &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; to the mask:</source>
          <target state="translated">要取消屏蔽已屏蔽数组的所有已屏蔽条目（假设该掩码不是硬掩码），最简单的解决方案是将常量&lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;分配给该掩码：</target>
        </trans-unit>
        <trans-unit id="573c20b6a49882f7eb74a61c9d6cc94e9816cad4" translate="yes" xml:space="preserve">
          <source>To unmask one or several specific entries, we can just assign one or several new valid values to them:</source>
          <target state="translated">要解除对一个或几个特定条目的屏蔽,我们只需给它们分配一个或几个新的有效值。</target>
        </trans-unit>
        <trans-unit id="9a8a0e07a3236c692c34f1277c4ab67311d7e811" translate="yes" xml:space="preserve">
          <source>To update your PR, make your changes on your local repository, commit, &lt;strong&gt;run tests, and only if they succeed&lt;/strong&gt; push to your fork. As soon as those changes are pushed up (to the same branch as before) the PR will update automatically. If you have no idea how to fix the test failures, you may push your changes anyway and ask for help in a PR comment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334270275fd281b533f438d90c3f3ba9ca0332d2" translate="yes" xml:space="preserve">
          <source>To use ctypes you must</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678a8d94c4368f39ac59f5979ae212033bfc0aa2" translate="yes" xml:space="preserve">
          <source>To use the NPY_NO_DEPRECATED_API mechanism, you need to #define it to the target API version of NumPy before #including any NumPy headers. If you want to confirm that your code is clean against 1.7, use:</source>
          <target state="translated">要使用NPY_NO_DEPRECATED_API机制,你需要在#包含任何NumPy头文件之前,将其定义为NumPy的目标API版本。如果你想确认你的代码在1.7的情况下是干净的,请使用:</target>
        </trans-unit>
        <trans-unit id="a6632c1bd45113f2d4d1587bfeed07e24b0355a1" translate="yes" xml:space="preserve">
          <source>To use the core math library in your own extension, you need to add the npymath compile and link options to your extension in your setup.py:</source>
          <target state="translated">要在你自己的扩展中使用核心数学库,你需要在setup.py中为你的扩展添加npymath编译和链接选项。</target>
        </trans-unit>
        <trans-unit id="500206efd24c09b049a15922610b46ea489a6382" translate="yes" xml:space="preserve">
          <source>To use the setup.py file, place setup.py and spammodule.c in the same folder. Then python setup.py build will build the module to import, or setup.py install will install the module to your site-packages directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b09eedfc76bdeeb31bc979256f245ac870f03de" translate="yes" xml:space="preserve">
          <source>Toggle between low-endian and big-endian data representation by returning a byteswapped array, optionally swapped in-place.</source>
          <target state="translated">通过返回一个字节交换的数组,在低字节和大字节数据表示之间切换,可以选择就地交换。</target>
        </trans-unit>
        <trans-unit id="7ff4f3dd9acfe46112f7adc4d9246b8e34598f79" translate="yes" xml:space="preserve">
          <source>Toggle between low-endian and big-endian data representation by returning a byteswapped array, optionally swapped in-place. Arrays of byte-strings are not swapped. The real and imaginary parts of a complex number are swapped individually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b37ca94c4e2eda42b84355ca6a25cdc55774133" translate="yes" xml:space="preserve">
          <source>Tolerance in machine epsilons for the complex part of the elements in the array.</source>
          <target state="translated">阵列中元素的复杂部分的机器epsilons公差。</target>
        </trans-unit>
        <trans-unit id="eb34b2131d6523965cdff1a43f4d01b982373d17" translate="yes" xml:space="preserve">
          <source>Tolerance parameters passed on to &lt;code&gt;isclose&lt;/code&gt;</source>
          <target state="translated">公差参数传递给 &lt;code&gt;isclose&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6670aa4fd96fc23b9c267762a58d3e2634e5e33d" translate="yes" xml:space="preserve">
          <source>Tolerance when checking the singular values in covariance matrix. cov is cast to double before the check.</source>
          <target state="translated">检查协方差矩阵中的奇异值时的容忍度,cov在检查前被转为双倍。</target>
        </trans-unit>
        <trans-unit id="849d7597da246bfdf3ea363c9c3966af6e67a060" translate="yes" xml:space="preserve">
          <source>Tool chain</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62511550774b90e55fa9f4d081340a2b9a412907" translate="yes" xml:space="preserve">
          <source>Total bytes consumed by the elements of the array.</source>
          <target state="translated">数组元素消耗的总字节数。</target>
        </trans-unit>
        <trans-unit id="f98da7ab34ca5eed412ebdc84c5c6ee4a001f890" translate="yes" xml:space="preserve">
          <source>Total number of array elements which trigger summarization rather than full repr (default 1000).</source>
          <target state="translated">触发摘要而非完全重写的数组元素总数(默认1000)。</target>
        </trans-unit>
        <trans-unit id="af14b2afdcc9cc3c661815c98f45cde11a73254a" translate="yes" xml:space="preserve">
          <source>Total number of array elements which trigger summarization rather than full repr (default 1000). To always use the full repr without summarization, pass &lt;a href=&quot;https://docs.python.org/dev/library/sys.html#sys.maxsize&quot;&gt;&lt;code&gt;sys.maxsize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7665d1d201c9ce2fd429127a2f276d913bba99d" translate="yes" xml:space="preserve">
          <source>Total number of array elements which trigger summarization rather than full repr. Defaults to &lt;code&gt;numpy.get_printoptions()['threshold']&lt;/code&gt;.</source>
          <target state="translated">触发汇总而不是完整表示的数组元素总数。默认为 &lt;code&gt;numpy.get_printoptions()['threshold']&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b009fd84652963a9ad5cd24ef82072817ddee41" translate="yes" xml:space="preserve">
          <source>Total size of broadcasted result.</source>
          <target state="translated">播出结果的总规模。</target>
        </trans-unit>
        <trans-unit id="77cca581150b844f956409245e7a5aa4e911b340" translate="yes" xml:space="preserve">
          <source>Trace of a matrix:</source>
          <target state="translated">矩阵的痕迹。</target>
        </trans-unit>
        <trans-unit id="b67024bc850bfd9a0093e89cd78bf7093386c17c" translate="yes" xml:space="preserve">
          <source>Trace of an array, &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;numpy.trace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">数组的跟踪&lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;numpy.trace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed0e339a8e0484e2fd0a0d26f8fea815f7ce8155" translate="yes" xml:space="preserve">
          <source>Tracking an Index or Multi-Index</source>
          <target state="translated">跟踪一个指数或多个指数</target>
        </trans-unit>
        <trans-unit id="4cf0fc0db43adb86a6609aeef379773c878c22d3" translate="yes" xml:space="preserve">
          <source>Tracking an index or multi-index is incompatible with using an external loop, because it requires a different index value per element. If you try to combine these flags, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object will raise an exception</source>
          <target state="translated">跟踪索引或多索引与使用外部循环不兼容，因为它要求每个元素具有不同的索引值。如果尝试组合这些标志，则&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;对象将引发异常</target>
        </trans-unit>
        <trans-unit id="d235c585e89d9d88a2fc997aec36a615cac97376" translate="yes" xml:space="preserve">
          <source>Tracking an index or multi-index is incompatible with using an external loop, because it requires a different index value per element. If you try to combine these flags, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object will raise an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de8c9ca9943956fbbe74f36e563016e4ecbb6f6" translate="yes" xml:space="preserve">
          <source>Trailing (i.e., highest order) elements with absolute value less than or equal to &lt;code&gt;tol&lt;/code&gt; (default value is zero) are removed.</source>
          <target state="translated">绝对值小于或等于 &lt;code&gt;tol&lt;/code&gt; （默认值为零）的尾随（即最高阶）元素将被删除。</target>
        </trans-unit>
        <trans-unit id="60e5d748c9218c048de8740bcac1703e7a50da1a" translate="yes" xml:space="preserve">
          <source>Trailing comments should be used sparingly. Instead of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556492d634d78a1f54a40b4fbbb6e6c53716147d" translate="yes" xml:space="preserve">
          <source>Trailing zeros in the coefficients will be used in the evaluation, so they should be avoided if efficiency is a concern.</source>
          <target state="translated">系数中的尾数零将在评估中使用,所以如果担心效率,应该避免使用。</target>
        </trans-unit>
        <trans-unit id="745b5ecf9a2d85dc724cf9ddd7a6df396eb1df69" translate="yes" xml:space="preserve">
          <source>Transforms a masked array into a flexible-type array.</source>
          <target state="translated">将掩码数组转换为灵活型数组。</target>
        </trans-unit>
        <trans-unit id="5335ed0e86bcde3b96f32fd1545910f420f14d2e" translate="yes" xml:space="preserve">
          <source>Transition notice</source>
          <target state="translated">过渡通知</target>
        </trans-unit>
        <trans-unit id="d362208ff2e702ca3538568841ed00ca61c441f9" translate="yes" xml:space="preserve">
          <source>Translate slice objects to concatenation along the first axis.</source>
          <target state="translated">将切片对象转化为沿第一轴的连接。</target>
        </trans-unit>
        <trans-unit id="c42fc49440b8d06a906b44be13eb608ca2ffc1dd" translate="yes" xml:space="preserve">
          <source>Translates slice objects to concatenation along the first axis.</source>
          <target state="translated">将切片对象转化为沿第一轴的连接。</target>
        </trans-unit>
        <trans-unit id="ff7c65a71ec845e39d241d138fd72490df88fa74" translate="yes" xml:space="preserve">
          <source>Translates slice objects to concatenation along the second axis.</source>
          <target state="translated">将切片对象转化为沿第二轴的连接。</target>
        </trans-unit>
        <trans-unit id="59ccc78dea6365b58077aeb5bd29c68b822c1ef5" translate="yes" xml:space="preserve">
          <source>Translating content</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8def3943422e0dc87b7f47772bd3dc4ad8ea550b" translate="yes" xml:space="preserve">
          <source>Transpose-like operations</source>
          <target state="translated">类似换位操作</target>
        </trans-unit>
        <trans-unit id="1dfdbda20e491607190c97bd4edf114a4a693811" translate="yes" xml:space="preserve">
          <source>Transposing a 1-D array returns an unchanged view of the original array.</source>
          <target state="translated">转置一个一维数组,返回的是原数组的不变视图。</target>
        </trans-unit>
        <trans-unit id="cfbc312acbc39b5f0298bdc7c7b5f4e1b759968b" translate="yes" xml:space="preserve">
          <source>Transposing and reshaping a matrix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66408bfa15c9ed2902e447a43b1f7abcdee55a60" translate="yes" xml:space="preserve">
          <source>Transpositions and permutations, &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;numpy.transpose&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">换位和置换&lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;numpy.transpose&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7b41f9df87a78abbe8128d5a249676911368def" translate="yes" xml:space="preserve">
          <source>Travis Oliphant - Project Founder / Emeritus Leader (served: 2005-2012)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd1d8f1121212090792af3b195766028fb3300b" translate="yes" xml:space="preserve">
          <source>Treatment for division by zero.</source>
          <target state="translated">除以零的处理方法。</target>
        </trans-unit>
        <trans-unit id="c576a1cfdbaf816c1398a32382e59edc28900bee" translate="yes" xml:space="preserve">
          <source>Treatment for floating-point overflow.</source>
          <target state="translated">浮点溢出的处理方法。</target>
        </trans-unit>
        <trans-unit id="17721dd3ac43e33f85ad621f2dc25c086c0470c0" translate="yes" xml:space="preserve">
          <source>Treatment for floating-point underflow.</source>
          <target state="translated">对浮点下溢的处理。</target>
        </trans-unit>
        <trans-unit id="a13040b51033dafdb26f7572598a0d12e22e4ffe" translate="yes" xml:space="preserve">
          <source>Treatment for invalid floating-point operation.</source>
          <target state="translated">浮点运算无效的处理方法。</target>
        </trans-unit>
        <trans-unit id="1150736fa84c0c4e53f25517e34313dcdeeed227" translate="yes" xml:space="preserve">
          <source>Tricks and Tips</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa2b8a97e48dc7878c0a5d70afe5d62a641a9fe" translate="yes" xml:space="preserve">
          <source>Trigger a build by pushing a commit of your edits to the repository. Note that you can do this on a branch, but it must be pushed upstream to the &lt;code&gt;MacPython/numpy-wheels&lt;/code&gt; repository to trigger uploads since only that repo has the appropriate tokens to allow uploads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba6ba3648cadff3a99f26c6371ef76b8f5ec198" translate="yes" xml:space="preserve">
          <source>Trigger the wheel builds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be7bc22dfdfa583bec627625a7e1101bc895967" translate="yes" xml:space="preserve">
          <source>Trigger the wheels build by pointing the numpy-wheels repository at this commit. This can take up to an hour. The numpy-wheels repository is cloned from &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt;. Start with a pull as the repo may have been accessed and changed by someone else and a push will fail:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a49a3516e9535a98c78b0ab59efaa267faaaeac" translate="yes" xml:space="preserve">
          <source>Triggers &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt;&lt;code&gt;NPY_ITER_COPY&lt;/code&gt;&lt;/a&gt;, and when an array operand is flagged for writing and is copied, causes the data in a copy to be copied back to &lt;code&gt;op[i]&lt;/code&gt; when &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; is called.</source>
          <target state="translated">触发&lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt; &lt;code&gt;NPY_ITER_COPY&lt;/code&gt; &lt;/a&gt;，当将数组操作数标记为要写入并被复制时，将导致在调用 &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; 时将副本中的数据复制回 &lt;code&gt;op[i]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="translated">三角函数</target>
        </trans-unit>
        <trans-unit id="58cf0aee76fad599f97ff1db8c6a47d2270860db" translate="yes" xml:space="preserve">
          <source>Trigonometric inverse cosine, element-wise.</source>
          <target state="translated">三角形反余弦,元素式。</target>
        </trans-unit>
        <trans-unit id="b0b82a06c2ae28e8fcf146e965d0c41fd4531e3a" translate="yes" xml:space="preserve">
          <source>Trigonometric inverse tangent, element-wise.</source>
          <target state="translated">三角形反切线,元素式。</target>
        </trans-unit>
        <trans-unit id="ce4f3fa4852db4b9b207eedadc12e11135e46d85" translate="yes" xml:space="preserve">
          <source>Trigonometric sine, element-wise.</source>
          <target state="translated">三角形正弦,元素方面。</target>
        </trans-unit>
        <trans-unit id="10a283c17897bbd0b4cb4fd810a9eeb88aa8ef58" translate="yes" xml:space="preserve">
          <source>Trim the leading and/or trailing zeros from a 1-D array or sequence.</source>
          <target state="translated">从一维数组或序列中修剪前导零和/或后导零。</target>
        </trans-unit>
        <trans-unit id="e488bb5cb2e281f3b003ce95222b8e4917db65a6" translate="yes" xml:space="preserve">
          <source>Troubleshooting ImportError</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="dec064efe14ed7a73f97fa4832f7dc39f8d37259" translate="yes" xml:space="preserve">
          <source>True divide self by other in-place.</source>
          <target state="translated">真正的将自己与其他原地划分。</target>
        </trans-unit>
        <trans-unit id="7c6199295c88c515de03909ca69e74e54d8c40d0" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;element&lt;/code&gt; is a scalar type, False if it is not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39cf2a1ac05eb7ec1f611fa8df3b32f9cff1d558" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;m.dtype.type&lt;/code&gt; is MaskType, False otherwise.</source>
          <target state="translated">如果 &lt;code&gt;m.dtype.type&lt;/code&gt; 为MaskType，则为 True ，否则为False。</target>
        </trans-unit>
        <trans-unit id="c7e5263b6e49f0164ce122995ea161e565df58fa" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;num&lt;/code&gt; is a scalar type, False if it is not.</source>
          <target state="translated">如果 &lt;code&gt;num&lt;/code&gt; 是标量类型，则为True；否则为False。</target>
        </trans-unit>
        <trans-unit id="2655b1728487edfb72db0ecd08ff9ea666177ee0" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;path&lt;/code&gt; exists.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 存在，则为真。</target>
        </trans-unit>
        <trans-unit id="0acadbce2849d20449e701a26739adbff1b98e78" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;x&lt;/code&gt; is a MaskedArray with masked values, False otherwise.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是具有掩码值的MaskedArray，则为True ，否则为False。</target>
        </trans-unit>
        <trans-unit id="05ff71445923acdd0c38d736b463809c9ccd39de" translate="yes" xml:space="preserve">
          <source>True if a Fortran 77 compiler is available (because a simple Fortran 77 code was able to be compiled successfully).</source>
          <target state="translated">如果有Fortran 77编译器,则为真(因为一个简单的Fortran 77代码能够被成功编译)。</target>
        </trans-unit>
        <trans-unit id="00cd0fd9fd4e9fcf05a5961ba064f7c5fc57b8ef" translate="yes" xml:space="preserve">
          <source>True if a Fortran 90 compiler is available (because a simple Fortran 90 code was able to be compiled successfully)</source>
          <target state="translated">如果有Fortran 90编译器,则为真(因为一个简单的Fortran 90代码能够被成功编译)。</target>
        </trans-unit>
        <trans-unit id="213506708b75038d86119f896c93fd459688fdaa" translate="yes" xml:space="preserve">
          <source>True if byteorder characters ( &lt;code&gt;NPY_LITTLE&lt;/code&gt;, &lt;code&gt;NPY_BIG&lt;/code&gt;, &lt;code&gt;NPY_NATIVE&lt;/code&gt;, &lt;code&gt;NPY_IGNORE&lt;/code&gt; ) are either equal or equivalent as to their specification of a native byte order. Thus, on a little-endian machine &lt;code&gt;NPY_LITTLE&lt;/code&gt; and &lt;code&gt;NPY_NATIVE&lt;/code&gt; are equivalent where they are not equivalent on a big-endian machine.</source>
          <target state="translated">如果字节序字符（ &lt;code&gt;NPY_LITTLE&lt;/code&gt; ， &lt;code&gt;NPY_BIG&lt;/code&gt; ， &lt;code&gt;NPY_NATIVE&lt;/code&gt; ， &lt;code&gt;NPY_IGNORE&lt;/code&gt; ）在本机字节序的规范上相等或相等，则为true。因此，在小端序计算机上， &lt;code&gt;NPY_LITTLE&lt;/code&gt; 和 &lt;code&gt;NPY_NATIVE&lt;/code&gt; 是等效的，而在大端序计算机上则不相等。</target>
        </trans-unit>
        <trans-unit id="ba3294550f0a20e5d9deb7f04a95fb8e4b4d1d46" translate="yes" xml:space="preserve">
          <source>True if cast can occur according to the casting rule.</source>
          <target state="translated">如果根据铸造规则可以发生铸造,则为真。</target>
        </trans-unit>
        <trans-unit id="1f63565b32d103f3a4de31640d426343af47dd7d" translate="yes" xml:space="preserve">
          <source>True if equivalent, False otherwise.</source>
          <target state="translated">如果等价,则为真,否则为假。</target>
        </trans-unit>
        <trans-unit id="1e741019d05ad4b1c0222d2d53486f99a6732190" translate="yes" xml:space="preserve">
          <source>True if other is same class as self</source>
          <target state="translated">如果other与self同级,则为true</target>
        </trans-unit>
        <trans-unit id="70fbd415e3863800b42dd70f2afc2d0435498df0" translate="yes" xml:space="preserve">
          <source>True if the coefficients are the same, False otherwise.</source>
          <target state="translated">如果系数相同则为真,否则为假。</target>
        </trans-unit>
        <trans-unit id="a6afbacb41b3137cec218f989dffb959ca4f44cd" translate="yes" xml:space="preserve">
          <source>True if the domains are the same, False otherwise.</source>
          <target state="translated">如果域名相同则为真,否则为假。</target>
        </trans-unit>
        <trans-unit id="4bc2a6d6f70eb24c8def5df03724644edb474780" translate="yes" xml:space="preserve">
          <source>True if the windows are the same, False otherwise.</source>
          <target state="translated">如果窗口相同则为true,否则为False。</target>
        </trans-unit>
        <trans-unit id="24f9df4fb7133abd7e86f4b5f0391c10a93621e7" translate="yes" xml:space="preserve">
          <source>True if two arrays have the same shape and elements, False otherwise.</source>
          <target state="translated">如果两个数组的形状和元素相同,则为真,否则为假。</target>
        </trans-unit>
        <trans-unit id="755e15abf3303ababe3ade30f10af71c607d4530" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is NaN, false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为NaN，则为true，否则为false。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="dc0b3f0e3c0fa8c731e1bcdadee661ee71b2ddb8" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is NaT, false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是NaT，则为true，否则为false。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="cd270c6be47d5f9045a9640d5cc8ead8711407bc" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is not positive infinity, negative infinity, or NaN; false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">当 &lt;code&gt;x&lt;/code&gt; 不是正无穷大，负无穷大或NaN时为真；否则为假。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="3170e8eb3762dd10d0e3ab109761eb5c944e9ac1" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is positive or negative infinity, false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">当 &lt;code&gt;x&lt;/code&gt; 为正或负无穷大时为true，否则为false。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="425b939d0909e079d100ad47521c0febc0bd307a" translate="yes" xml:space="preserve">
          <source>Truncate s values at 50 so plot is interesting:</source>
          <target state="translated">将s值截断在50处,这样绘图才有趣。</target>
        </trans-unit>
        <trans-unit id="8726579bd5d3f34275a243eb604a9ceb6cbd38eb" translate="yes" xml:space="preserve">
          <source>Truncate series to length &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">将系列截短为长度 &lt;code&gt;size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adcf68c15599690309b811decf083d5555853eeb" translate="yes" xml:space="preserve">
          <source>Truncate series to the given degree.</source>
          <target state="translated">将系列截断到给定的程度。</target>
        </trans-unit>
        <trans-unit id="d78b8c914ad90242aebfa1ad45be017c8a4ed426" translate="yes" xml:space="preserve">
          <source>Truth value of an array (&lt;code&gt;bool&lt;/code&gt;):</source>
          <target state="translated">数组的真值（ &lt;code&gt;bool&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="d14d79df6800bf8b855c978794baaad558b55ab7" translate="yes" xml:space="preserve">
          <source>Truth value testing</source>
          <target state="translated">真值测试</target>
        </trans-unit>
        <trans-unit id="a34d6317df428f3a0882e4fcc17ec8a423d926fc" translate="yes" xml:space="preserve">
          <source>Truth-value testing of an array invokes &lt;a href=&quot;generated/numpy.ndarray.__bool__#numpy.ndarray.__bool__&quot;&gt;&lt;code&gt;ndarray.__bool__&lt;/code&gt;&lt;/a&gt;, which raises an error if the number of elements in the array is larger than 1, because the truth value of such arrays is ambiguous. Use &lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt;&lt;code&gt;.any()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;.all()&lt;/code&gt;&lt;/a&gt; instead to be clear about what is meant in such cases. (If the number of elements is 0, the array evaluates to &lt;code&gt;False&lt;/code&gt;.)</source>
          <target state="translated">数组的真值测试会调用&lt;a href=&quot;generated/numpy.ndarray.__bool__#numpy.ndarray.__bool__&quot;&gt; &lt;code&gt;ndarray.__bool__&lt;/code&gt; &lt;/a&gt;，如果数组中的元素数大于1，则会引发错误，因为此类数组的真值不明确。使用&lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt; &lt;code&gt;.any()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;.all()&lt;/code&gt; &lt;/a&gt;，而不是要清楚什么是在这种情况下的意思。（如果元素数为0，则数组的值为 &lt;code&gt;False&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="2ecf59a43e289ad2b017cf95dec49da40904a53e" translate="yes" xml:space="preserve">
          <source>Try to get version string of a package.</source>
          <target state="translated">尝试获取一个软件包的版本字符串。</target>
        </trans-unit>
        <trans-unit id="d41c38be32c336059996707815d0e3ddc6359848" translate="yes" xml:space="preserve">
          <source>Try to keep the runtime of the benchmark reasonable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b28b6348f61eb4f458af0454cbb48914113f96" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;(item_dtype, shape)&lt;/code&gt; if this &lt;a href=&quot;#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; describes a sub-array, and None otherwise.</source>
          <target state="translated">如果此&lt;a href=&quot;#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;描述子数组， &lt;code&gt;(item_dtype, shape)&lt;/code&gt; 元组（item_dtype，shape），否则为None。</target>
        </trans-unit>
        <trans-unit id="3e6ddb0c1b967dfa42de0aef208f74bd1f3fd6c6" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;(item_dtype, shape)&lt;/code&gt; if this &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; describes a sub-array, and None otherwise.</source>
          <target state="translated">如果此&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;描述子数组， &lt;code&gt;(item_dtype, shape)&lt;/code&gt; 元组（item_dtype，shape），否则为None。</target>
        </trans-unit>
        <trans-unit id="f3757a0166a586f2a2125cefab21784843d386d2" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;(item_dtype, shape)&lt;/code&gt; if this &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; describes a sub-array, and None otherwise.</source>
          <target state="translated">如果此&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;描述子数组， &lt;code&gt;(item_dtype, shape)&lt;/code&gt; 元组（item_dtype，shape），否则为None。</target>
        </trans-unit>
        <trans-unit id="84be13d7b7fcc75e7ec8441a86e66cf302003bb9" translate="yes" xml:space="preserve">
          <source>Tuple axis arguments to ufuncs are equivalent:</source>
          <target state="translated">ufuncs的元组轴参数是等价的。</target>
        </trans-unit>
        <trans-unit id="92e7c78c7d4063f090081adef280802cf975a20b" translate="yes" xml:space="preserve">
          <source>Tuple object dtypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="288ea08ff10a961743d4d8b925f5d1931f661310" translate="yes" xml:space="preserve">
          <source>Tuple of array dimensions.</source>
          <target state="translated">阵列维数的元组。</target>
        </trans-unit>
        <trans-unit id="119e92503836c54689c5f8c6dff4e15a28816a46" translate="yes" xml:space="preserve">
          <source>Tuple of bytes to step in each dimension when traversing an array.</source>
          <target state="translated">当遍历一个数组时,在每个维度上要步进的字节元组。</target>
        </trans-unit>
        <trans-unit id="a39e9bc9ce6796bfca6ebd0c63299d64e075f553" translate="yes" xml:space="preserve">
          <source>Tuple whose elements are the array size in each dimension. Each entry is an integer (a Python int or long). Note that these integers could be larger than the platform &amp;ldquo;int&amp;rdquo; or &amp;ldquo;long&amp;rdquo; could hold (a Python int is a C long). It is up to the code using this attribute to handle this appropriately; either by raising an error when overflow is possible, or by using &lt;code&gt;Py_LONG_LONG&lt;/code&gt; as the C type for the shapes.</source>
          <target state="translated">元组的元素是每个维中的数组大小。每个条目都是一个整数（Python int或long）。请注意，这些整数可能大于平台&amp;ldquo; int&amp;rdquo;或&amp;ldquo; long&amp;rdquo;可容纳的整数（Python int为C long）。取决于使用此属性的代码来适当地处理此问题。在可能发生溢出时引发错误，或者使用 &lt;code&gt;Py_LONG_LONG&lt;/code&gt; 作为形状的C类型。</target>
        </trans-unit>
        <trans-unit id="20d441ae2c7520e9597892d62d069dab012afe76" translate="yes" xml:space="preserve">
          <source>Turns pure python into efficient machine code through jit-like optimizations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9bd3e52f2caf4d6594b811b3960a4952fbdcd14" translate="yes" xml:space="preserve">
          <source>Tutorial: Linear algebra on n-dimensional arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="a3aad8fcfc1fb793d988e46dd13b4c587f04cc94" translate="yes" xml:space="preserve">
          <source>Tutorials and summaries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e8bc0a325097293ba3968264a6e780fc207371f" translate="yes" xml:space="preserve">
          <source>Tweaking the conversion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84f46a1bd48b0888bd11bac416f31bd455192d4" translate="yes" xml:space="preserve">
          <source>Two and three dots in difference specs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eff015ed2b91595519ef0f82b5da310790ed8380" translate="yes" xml:space="preserve">
          <source>Two groups, children of diabetics (25 people) and children from people without diabetes (25 controls). Fasting blood glucose was measured, case group had a mean value of 86.1, controls had a mean value of 82.2. Standard deviations were 2.09 and 2.49 respectively. Are these data consistent with the null hypothesis that the parents diabetic status does not affect their children&amp;rsquo;s blood glucose levels? Calculating the F statistic from the data gives a value of 36.01.</source>
          <target state="translated">两组分别为糖尿病儿童（25人）和非糖尿病儿童（25人）。测量空腹血糖，病例组的平均值为86.1，对照组的平均值为82.2。标准偏差分别为2.09和2.49。这些数据是否与父母的糖尿病状况不影响孩子的血糖水平的零假设相符？从数据计算F统计量得出的值为36.01。</target>
        </trans-unit>
        <trans-unit id="9a29304c220b1dd3134936cc76050af186cb5278" translate="yes" xml:space="preserve">
          <source>Two times the reciprocal of pi (</source>
          <target state="translated">pi的倒数的2倍 (</target>
        </trans-unit>
        <trans-unit id="c6b3128dd2f1c22ff8a2b286be1379fe8a8fe179" translate="yes" xml:space="preserve">
          <source>Two-by-four array of samples from</source>
          <target state="translated">二乘四的样品阵列</target>
        </trans-unit>
        <trans-unit id="b1f6d6c8746a437f90f0dee674c0b93df2f99381" translate="yes" xml:space="preserve">
          <source>Two-by-four array of samples from N(3, 6.25):</source>
          <target state="translated">N(3,6.25)的二乘四样品阵列。</target>
        </trans-unit>
        <trans-unit id="3db221513448342ff7f1391357dc023cdf6dc3dc" translate="yes" xml:space="preserve">
          <source>Two-by-four matrix of samples from</source>
          <target state="translated">二乘四样本矩阵</target>
        </trans-unit>
        <trans-unit id="862d5ad68d4b198349fd0cc9c98a5797e23f13c7" translate="yes" xml:space="preserve">
          <source>Two-dimensional array:</source>
          <target state="translated">二维阵列。</target>
        </trans-unit>
        <trans-unit id="4ca814bb64ef6897ea819d313fffbc4815334f0e" translate="yes" xml:space="preserve">
          <source>Two-dimensional arrays are tested in exactly the same manner. The above description applies, but with &lt;code&gt;Matrix&lt;/code&gt; substituted for &lt;code&gt;Vector&lt;/code&gt;. For three-dimensional tests, substitute &lt;code&gt;Tensor&lt;/code&gt; for &lt;code&gt;Vector&lt;/code&gt;. For four-dimensional tests, substitute &lt;code&gt;SuperTensor&lt;/code&gt; for &lt;code&gt;Vector&lt;/code&gt;. For flat in-place array tests, substitute &lt;code&gt;Flat&lt;/code&gt; for &lt;code&gt;Vector&lt;/code&gt;. For the descriptions that follow, we will reference the &lt;code&gt;Vector&lt;/code&gt; tests, but the same information applies to &lt;code&gt;Matrix&lt;/code&gt;, &lt;code&gt;Tensor&lt;/code&gt; and &lt;code&gt;SuperTensor&lt;/code&gt; tests.</source>
          <target state="translated">以完全相同的方式测试二维数组。上面的描述适用，但是用 &lt;code&gt;Matrix&lt;/code&gt; 代替了 &lt;code&gt;Vector&lt;/code&gt; 。对于三维测试，用 &lt;code&gt;Tensor&lt;/code&gt; 代替 &lt;code&gt;Vector&lt;/code&gt; 。对于四维测试，用 &lt;code&gt;SuperTensor&lt;/code&gt; 代替 &lt;code&gt;Vector&lt;/code&gt; 。对于平面就地数组测试，用 &lt;code&gt;Flat&lt;/code&gt; 代替 &lt;code&gt;Vector&lt;/code&gt; 。对于以下描述，我们将引用 &lt;code&gt;Vector&lt;/code&gt; 测试，但是相同的信息适用于 &lt;code&gt;Matrix&lt;/code&gt; ， &lt;code&gt;Tensor&lt;/code&gt; 和 &lt;code&gt;SuperTensor&lt;/code&gt; 测试。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="4f87d1dd8d472cbdfec76a8cf89933a4a1cf8dbd" translate="yes" xml:space="preserve">
          <source>Type Promotion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315f6367d2e7e25cde681d099ca28e1c2c774de1" translate="yes" xml:space="preserve">
          <source>Type declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="546ef13b4643b6acadc0951eac37d6f468caac3d" translate="yes" xml:space="preserve">
          <source>Type description examples</source>
          <target state="translated">类型描述示例</target>
        </trans-unit>
        <trans-unit id="966782d7443e2170cf499e59f9a8368a7b7380cd" translate="yes" xml:space="preserve">
          <source>Type has fields associated with it.</source>
          <target state="translated">类型有与之相关的字段。</target>
        </trans-unit>
        <trans-unit id="ad1651cc08eba91d6dce8f9e7cbe0420ed624c49" translate="yes" xml:space="preserve">
          <source>Type has no size information attached, and can be resized. Should only be called on flexible dtypes. Types that are attached to an array will always be sized, hence the array form of this macro not existing.</source>
          <target state="translated">类型没有附加的尺寸信息,并且可以调整大小。应该只对灵活的dtypes调用。附加在数组上的类型总是有大小的,因此这个宏的数组形式不存在。</target>
        </trans-unit>
        <trans-unit id="00fea5456fe9ccd4a61fecaaa45953e334c1c594" translate="yes" xml:space="preserve">
          <source>Type is either flexible or user-defined.</source>
          <target state="translated">类型可以是灵活的,也可以是用户定义的。</target>
        </trans-unit>
        <trans-unit id="fd89c694ef19c6e785630016c5d715bce35c6076" translate="yes" xml:space="preserve">
          <source>Type is preserved for boolean arrays, so the result will contain &lt;code&gt;False&lt;/code&gt; when consecutive elements are the same and &lt;code&gt;True&lt;/code&gt; when they differ.</source>
          <target state="translated">类型是为布尔数组保留的，因此当连续元素相同时，结果将包含 &lt;code&gt;False&lt;/code&gt; ,而在连续元素不同时将包含 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f129dda4a5f86710986e28a3910cacd0ab66b0a" translate="yes" xml:space="preserve">
          <source>Type of comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c36d17e1133f5c5a545edd7db2e2ccd0a71a9cf5" translate="yes" xml:space="preserve">
          <source>Type of the data (integer, float, Python object, etc.)</source>
          <target state="translated">数据类型(整数、浮点数、Python对象等)</target>
        </trans-unit>
        <trans-unit id="dd429360d0a73315317719cd2b034bd7849c79e3" translate="yes" xml:space="preserve">
          <source>Type of the returned array and of the accumulator in which the elements are summed. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not specified, it defaults to the dtype of &lt;code&gt;a&lt;/code&gt;, unless &lt;code&gt;a&lt;/code&gt; has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.</source>
          <target state="translated">返回的数组和累加器的类型，元素在其中累加。如果&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;未指定，则默认为的D型 &lt;code&gt;a&lt;/code&gt; ，除非 &lt;code&gt;a&lt;/code&gt; 具有精度小于默认平台整数的整数D型。在这种情况下，将使用默认平台整数。</target>
        </trans-unit>
        <trans-unit id="07bc03c5a2d510ae05b611f9e4728e3dfbb4d656" translate="yes" xml:space="preserve">
          <source>Type of the returned array, as well as of the accumulator in which the elements are multiplied. If &lt;em&gt;dtype&lt;/em&gt; is not specified, it defaults to the dtype of &lt;code&gt;a&lt;/code&gt;, unless &lt;code&gt;a&lt;/code&gt; has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used instead.</source>
          <target state="translated">返回数组的类型，以及与元素相乘的累加器的类型。如果&lt;em&gt;D型&lt;/em&gt;未指定，则默认为的D型 &lt;code&gt;a&lt;/code&gt; ，除非 &lt;code&gt;a&lt;/code&gt; 具有精度小于默认平台整数的整数D型。在这种情况下，将使用默认平台整数。</target>
        </trans-unit>
        <trans-unit id="2fbcc881be006ea806d10d1a75e79dec487e047f" translate="yes" xml:space="preserve">
          <source>Type of the returned view, e.g., ndarray or matrix. Again, omission of the parameter results in type preservation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36795fd8406bf11fda0ac3128a88df4463dd2892" translate="yes" xml:space="preserve">
          <source>Type of the returned view, e.g., ndarray or matrix. Again, the default None results in type preservation.</source>
          <target state="translated">返回视图的类型,例如,ndarray或矩阵。同样,默认的None会导致类型保留。</target>
        </trans-unit>
        <trans-unit id="e3dd48b9d6f09dc7416ab4d63d6ccc2dc14a5715" translate="yes" xml:space="preserve">
          <source>Type of the returned view, either ndarray or a subclass. The default None results in type preservation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d0b3189219da3d7ba109eef463be8e2071fbe7e" translate="yes" xml:space="preserve">
          <source>Type promotion in NumPy works similarly to the rules in languages like C++, with some slight differences. When both scalars and arrays are used, the array&amp;rsquo;s type takes precedence and the actual value of the scalar is taken into account.</source>
          <target state="translated">NumPy中的类型提升与C ++等语言中的规则类似，但略有不同。当同时使用标量和数组时，数组的类型优先，并且标量的实际值也要考虑在内。</target>
        </trans-unit>
        <trans-unit id="66585ef6b68c044b299bc7220f22788121e21167" translate="yes" xml:space="preserve">
          <source>Type provided:</source>
          <target state="translated">提供的类型:</target>
        </trans-unit>
        <trans-unit id="bc25fc1327a92506da2b55272b3113fcffa65d61" translate="yes" xml:space="preserve">
          <source>Type represents Boolean data type.</source>
          <target state="translated">类型代表布尔数据类型。</target>
        </trans-unit>
        <trans-unit id="60db025c166ec63b9a181b61c24b20c5d24b0648" translate="yes" xml:space="preserve">
          <source>Type represents a signed integer.</source>
          <target state="translated">类型代表一个有符号的整数。</target>
        </trans-unit>
        <trans-unit id="acb6256437982d272438054c848d82884163b4d8" translate="yes" xml:space="preserve">
          <source>Type represents a string data type.</source>
          <target state="translated">类型代表一个字符串数据类型。</target>
        </trans-unit>
        <trans-unit id="08f325041fae51a65ee6e08f868548827f3e2b61" translate="yes" xml:space="preserve">
          <source>Type represents a user-defined type.</source>
          <target state="translated">类型代表用户定义的类型。</target>
        </trans-unit>
        <trans-unit id="f5f87b05bbeb10ab3c2ec34871c51fb7f3e190f2" translate="yes" xml:space="preserve">
          <source>Type represents an enumerated type corresponding to one of the standard Python scalar (bool, int, float, or complex).</source>
          <target state="translated">Type 表示对应于标准 Python 标量之一的枚举类型 (bool、int、float 或 complex)。</target>
        </trans-unit>
        <trans-unit id="6fc847c0dbefe834d836a7b9b36c518b8a349fc4" translate="yes" xml:space="preserve">
          <source>Type represents an unsigned integer.</source>
          <target state="translated">类型代表一个无符号整数。</target>
        </trans-unit>
        <trans-unit id="f8e7a296ef6aceb534615bd823bf7fad61a5043e" translate="yes" xml:space="preserve">
          <source>Type represents any complex floating point number.</source>
          <target state="translated">类型代表任何复杂的浮点数。</target>
        </trans-unit>
        <trans-unit id="28cd3b87be44c11187d7cc10075315e307082083" translate="yes" xml:space="preserve">
          <source>Type represents any floating point number.</source>
          <target state="translated">类型代表任何浮点数。</target>
        </trans-unit>
        <trans-unit id="579601ba7e8ea9eb8623a33cadfe20f9eaea6f83" translate="yes" xml:space="preserve">
          <source>Type represents any integer, floating point, or complex floating point number.</source>
          <target state="translated">类型代表任何整数、浮点或复杂的浮点数。</target>
        </trans-unit>
        <trans-unit id="051ab06f1a62606ef03aadb95e9e56f705f31488" translate="yes" xml:space="preserve">
          <source>Type represents any integer.</source>
          <target state="translated">类型代表任何整数。</target>
        </trans-unit>
        <trans-unit id="a2ba1da5781162c52e0abb1d3993de06d380b834" translate="yes" xml:space="preserve">
          <source>Type represents object data type.</source>
          <target state="translated">类型代表对象数据类型。</target>
        </trans-unit>
        <trans-unit id="20eece7c06865b2554e5d1db1375400953d56528" translate="yes" xml:space="preserve">
          <source>Type represents one of the flexible array types ( &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">Type表示灵活数组类型之一（&lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt; &lt;code&gt;NPY_STRING&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt; &lt;code&gt;NPY_UNICODE&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt; &lt;code&gt;NPY_VOID&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8e6c44e27b4edb7108b331e3527612380352acbf" translate="yes" xml:space="preserve">
          <source>Type represents one of the flexible array types ( &lt;a href=&quot;dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab551b16a69b24d82e03c4a0d668cc3040d4465" translate="yes" xml:space="preserve">
          <source>Type specific, core 1-d functions for ufuncs where each calculation is obtained by calling a function taking one input argument and returning one output. This function is passed in &lt;code&gt;func&lt;/code&gt;. The letters correspond to dtypechar&amp;rsquo;s of the supported data types ( &lt;code&gt;e&lt;/code&gt; - half, &lt;code&gt;f&lt;/code&gt; - float, &lt;code&gt;d&lt;/code&gt; - double, &lt;code&gt;g&lt;/code&gt; - long double, &lt;code&gt;F&lt;/code&gt; - cfloat, &lt;code&gt;D&lt;/code&gt; - cdouble, &lt;code&gt;G&lt;/code&gt; - clongdouble). The argument &lt;em&gt;func&lt;/em&gt; must support the same signature. The _As_X_X variants assume ndarray&amp;rsquo;s of one data type but cast the values to use an underlying function that takes a different data type. Thus, &lt;a href=&quot;#c.PyUFunc_f_f_As_d_d&quot;&gt;&lt;code&gt;PyUFunc_f_f_As_d_d&lt;/code&gt;&lt;/a&gt; uses ndarrays of data type &lt;a href=&quot;c-api.dtype#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; but calls out to a C-function that takes double and returns double.</source>
          <target state="translated">类型特定的ufunc核心1-d函数，其中的每个计算都是通过调用一个具有一个输入参数并返回一个输出的函数来获得的。该函数在 &lt;code&gt;func&lt;/code&gt; 中传递。字母对应于受支持的数据类型的dtypechar（ &lt;code&gt;e&lt;/code&gt; -一半， &lt;code&gt;f&lt;/code&gt; -浮点数， &lt;code&gt;d&lt;/code&gt; -两倍， &lt;code&gt;g&lt;/code&gt; -长双倍， &lt;code&gt;F&lt;/code&gt; -cfloat， &lt;code&gt;D&lt;/code&gt; -cdouble， &lt;code&gt;G&lt;/code&gt; -clongdouble）。参数&lt;em&gt;func&lt;/em&gt;必须支持相同的签名。 _As_X_X变体假定一种数据类型的ndarray，但将其值强制转换为使用具有不同数据类型的基础函数。因此，&lt;a href=&quot;#c.PyUFunc_f_f_As_d_d&quot;&gt; &lt;code&gt;PyUFunc_f_f_As_d_d&lt;/code&gt; &lt;/a&gt;使用数据类型为&lt;a href=&quot;c-api.dtype#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; 的ndarrays,&lt;/a&gt;但调用C函数，该函数需要double并返回double。</target>
        </trans-unit>
        <trans-unit id="e494b69883a66d9ceddef7c995f1d4e3172789f0" translate="yes" xml:space="preserve">
          <source>Type specific, core 1-d functions for ufuncs where each calculation is obtained by calling a function taking one input argument and returning one output. This function is passed in &lt;code&gt;func&lt;/code&gt;. The letters correspond to dtypechar&amp;rsquo;s of the supported data types ( &lt;code&gt;e&lt;/code&gt; - half, &lt;code&gt;f&lt;/code&gt; - float, &lt;code&gt;d&lt;/code&gt; - double, &lt;code&gt;g&lt;/code&gt; - long double, &lt;code&gt;F&lt;/code&gt; - cfloat, &lt;code&gt;D&lt;/code&gt; - cdouble, &lt;code&gt;G&lt;/code&gt; - clongdouble). The argument &lt;em&gt;func&lt;/em&gt; must support the same signature. The _As_X_X variants assume ndarray&amp;rsquo;s of one data type but cast the values to use an underlying function that takes a different data type. Thus, &lt;a href=&quot;#c.PyUFunc_f_f_As_d_d&quot;&gt;&lt;code&gt;PyUFunc_f_f_As_d_d&lt;/code&gt;&lt;/a&gt; uses ndarrays of data type &lt;a href=&quot;dtype#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; but calls out to a C-function that takes double and returns double.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2718d921f0c8c7bb73eed2147fee6ea79b6b6859" translate="yes" xml:space="preserve">
          <source>Type specific, core 1-d functions for ufuncs where each calculation is obtained by calling a function taking two input arguments and returning one output. The underlying function to call is passed in as &lt;em&gt;func&lt;/em&gt;. The letters correspond to dtypechar&amp;rsquo;s of the specific data type supported by the general-purpose function. The argument &lt;code&gt;func&lt;/code&gt; must support the corresponding signature. The &lt;code&gt;_As_XX_X&lt;/code&gt; variants assume ndarrays of one data type but cast the values at each iteration of the loop to use the underlying function that takes a different data type.</source>
          <target state="translated">类型特定的ufunc核心1-d函数，其中的每个计算都是通过调用带有两个输入参数并返回一个输出的函数来获得的。调用的基础函数作为&lt;em&gt;func&lt;/em&gt;传递。字母对应于通用功能支持的特定数据类型的dtypechar。参数 &lt;code&gt;func&lt;/code&gt; 必须支持相应的签名。所述 &lt;code&gt;_As_XX_X&lt;/code&gt; 变体假定一个数据类型的ndarrays但在循环中使用的底层函数采用不同的数据类型的每个迭代投的值。</target>
        </trans-unit>
        <trans-unit id="ef2ee12d948765f441a77e0dc116238b4eb26327" translate="yes" xml:space="preserve">
          <source>Type specifier strings are convertible to dtypes and can therefore be used instead of dtypes:</source>
          <target state="translated">类型指定符字符串可以转换为dtypes,因此可以代替dtypes使用。</target>
        </trans-unit>
        <trans-unit id="f7df157385540da09117c232afd23b684eee205b" translate="yes" xml:space="preserve">
          <source>Type strings</source>
          <target state="translated">字符串类型</target>
        </trans-unit>
        <trans-unit id="b6e792a3d08a7bd144dac10e42edb461fd3dd2e3" translate="yes" xml:space="preserve">
          <source>Type to use in computing the mean. For integer inputs, the default is &lt;code&gt;float64&lt;/code&gt;; for floating point inputs, it is the same as the input dtype.</source>
          <target state="translated">用于计算平均值的类型。对于整数输入，默认值为 &lt;code&gt;float64&lt;/code&gt; ；对于浮点输入，它与输入dtype相同。</target>
        </trans-unit>
        <trans-unit id="9f9df4fba8dcd1fb7d56164c04214c5a4ba9ba6b" translate="yes" xml:space="preserve">
          <source>Type to use in computing the mean. For integer inputs, the default is &lt;code&gt;float64&lt;/code&gt;; for inexact inputs, it is the same as the input dtype.</source>
          <target state="translated">用于计算平均值的类型。对于整数输入，默认值为 &lt;code&gt;float64&lt;/code&gt; ；对于不精确的输入，它与输入dtype相同。</target>
        </trans-unit>
        <trans-unit id="3131a42adb40886f91b9db8d1e4f4fee7e5c8913" translate="yes" xml:space="preserve">
          <source>Type to use in computing the standard deviation. For arrays of integer type the default is float64, for arrays of float types it is the same as the array type.</source>
          <target state="translated">计算标准差时使用的类型。对于整数类型的数组,默认为float64,对于浮动类型的数组,它与数组类型相同。</target>
        </trans-unit>
        <trans-unit id="80e97dffa22c435830b854e8d6fb1c6cb57a1b46" translate="yes" xml:space="preserve">
          <source>Type to use in computing the variance. For arrays of integer type</source>
          <target state="translated">计算方差时使用的类型。对于整数类型的数组</target>
        </trans-unit>
        <trans-unit id="c52f694878c4817d9cf0e30a93a5ac5c826ca338" translate="yes" xml:space="preserve">
          <source>Type to use in computing the variance. For arrays of integer type the default is &lt;code&gt;float32&lt;/code&gt;; for arrays of float types it is the same as the array type.</source>
          <target state="translated">用于计算方差的类型。对于整数类型的数组，默认值为 &lt;code&gt;float32&lt;/code&gt; ；对于float类型的数组，它与数组类型相同。</target>
        </trans-unit>
        <trans-unit id="251490cecef7141a0dccef6fed5a02c3f5f10907" translate="yes" xml:space="preserve">
          <source>Type to use in computing the variance. For arrays of integer type the default is &lt;code&gt;float64&lt;/code&gt;; for arrays of float types it is the same as the array type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d160c5845a8a77a5befb4851a7053d8bdf35eb94" translate="yes" xml:space="preserve">
          <source>Typecode or data-type to which the array is cast.</source>
          <target state="translated">数组被投向的类型代码或数据类型。</target>
        </trans-unit>
        <trans-unit id="41a5cdb8ef55e142306841748946bd3431f088b4" translate="yes" xml:space="preserve">
          <source>Typed versions of many of the &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; methods as well as the classes themselves can be accessed directly from Cython via</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23cf72e69c01c79ece86b50f4bc0e1b659346558" translate="yes" xml:space="preserve">
          <source>Typemap conversions for complex floating-point types is also not supported automatically. This is because Python and NumPy are written in C, which does not have native complex types. Both Python and NumPy implement their own (essentially equivalent) &lt;code&gt;struct&lt;/code&gt; definitions for complex variables:</source>
          <target state="translated">还不自动支持复杂浮点类型的Typemap转换。这是因为Python和NumPy是用C编写的，它没有本机复杂类型。Python和NumPy都为复杂变量实现了它们自己的（基本上等效的） &lt;code&gt;struct&lt;/code&gt; 定义：</target>
        </trans-unit>
        <trans-unit id="f2014cb40164abd5b9ac9cf3258c64ef343de062" translate="yes" xml:space="preserve">
          <source>Typemaps are keyed off a list of one or more function arguments, either by type or by type and name. We will refer to such lists as &lt;em&gt;signatures&lt;/em&gt;. One of the many typemaps defined by &lt;code&gt;numpy.i&lt;/code&gt; is used above and has the signature &lt;code&gt;(double* IN_ARRAY1, int DIM1)&lt;/code&gt;. The argument names are intended to suggest that the &lt;code&gt;double*&lt;/code&gt; argument is an input array of one dimension and that the &lt;code&gt;int&lt;/code&gt; represents the size of that dimension. This is precisely the pattern in the &lt;code&gt;rms&lt;/code&gt; prototype.</source>
          <target state="translated">类型映射从一个或多个函数参数的列表中键入（按类型或类型和名称）。我们将这些列表称为&lt;em&gt;签名&lt;/em&gt;。上面使用了numpy.i定义的许多类型映射 &lt;code&gt;numpy.i&lt;/code&gt; ，并且具有签名 &lt;code&gt;(double* IN_ARRAY1, int DIM1)&lt;/code&gt; 。参数名称旨在建议 &lt;code&gt;double*&lt;/code&gt; 参数是一维的输入数组，而 &lt;code&gt;int&lt;/code&gt; 表示该维的大小。这正是 &lt;code&gt;rms&lt;/code&gt; 原型中的模式。</target>
        </trans-unit>
        <trans-unit id="908f34305dca26ca1d02c401b17bcc9125b1ab5c" translate="yes" xml:space="preserve">
          <source>Types with &lt;code&gt;.dtype&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.dtype&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="translated">典型用途:</target>
        </trans-unit>
        <trans-unit id="e390f0c6d81411459ef6be418905b3473133c360" translate="yes" xml:space="preserve">
          <source>Typically a &amp;lsquo;greedy&amp;rsquo; algorithm is applied which empirical tests have shown returns the optimal path in the majority of cases. In some cases &amp;lsquo;optimal&amp;rsquo; will return the superlative path through a more expensive, exhaustive search. For iterative calculations it may be advisable to calculate the optimal path once and reuse that path by supplying it as an argument. An example is given below.</source>
          <target state="translated">通常，采用&amp;ldquo;贪心&amp;rdquo;算法，根据经验测试，该算法在大多数情况下会返回最佳路径。在某些情况下，&amp;ldquo;最优&amp;rdquo;将通过更昂贵，更详尽的搜索返回最高级路径。对于迭代计算，建议一次计算最佳路径并通过将其作为参数提供来重用该路径。下面给出一个例子。</target>
        </trans-unit>
        <trans-unit id="291bb923a1cf51e55db8c8127cc92200f5117732" translate="yes" xml:space="preserve">
          <source>Typically these new versions of the array metadata but the same data buffer are new &amp;lsquo;views&amp;rsquo; into the data buffer. There is a different ndarray object, but it uses the same data buffer. This is why it is necessary to force copies through use of the .copy() method if one really wants to make a new and independent copy of the data buffer.</source>
          <target state="translated">通常，这些新版本的数组元数据和相同的数据缓冲区是数据缓冲区的新&amp;ldquo;视图&amp;rdquo;。有一个不同的ndarray对象，但是它使用相同的数据缓冲区。这就是为什么如果真的想制作一个新的独立的数据缓冲区副本，则必须通过使用.copy（）方法来强制进行复制的原因。</target>
        </trans-unit>
        <trans-unit id="54a23bec4dd6b17bf03f7139f1786ecb950b41b8" translate="yes" xml:space="preserve">
          <source>Typically this value will be one more than what you might expect because all ufuncs take the optional &amp;ldquo;out&amp;rdquo; argument.</source>
          <target state="translated">通常，此值将比您期望的值大一个，因为所有ufunc都采用可选的&amp;ldquo; out&amp;rdquo;参数。</target>
        </trans-unit>
        <trans-unit id="2db839a7e94204fc83aa9e6a4d27e6c5c452f385" translate="yes" xml:space="preserve">
          <source>Typically though, &lt;code&gt;self.min(axis=axis)&lt;/code&gt; is sufficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32606a7a80aee72f839ad47d7de51922ee1b0957" translate="yes" xml:space="preserve">
          <source>Typically you get a new reference to a variable when it is created or is the return value of some function (there are some prominent exceptions, however &amp;mdash; such as getting an item out of a tuple or a dictionary). When you own the reference, you are responsible to make sure that &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; (var) is called when the variable is no longer necessary (and no other function has &amp;ldquo;stolen&amp;rdquo; its reference). Also, if you are passing a Python object to a function that will &amp;ldquo;steal&amp;rdquo; the reference, then you need to make sure you own it (or use &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; to get your own reference). You will also encounter the notion of borrowing a reference. A function that borrows a reference does not alter the reference count of the object and does not expect to &amp;ldquo;hold on &amp;ldquo;to the reference. It&amp;rsquo;s just going to use the object temporarily. When you use &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_UnpackTuple&quot;&gt;&lt;code&gt;PyArg_UnpackTuple&lt;/code&gt;&lt;/a&gt; you receive a borrowed reference to the objects in the tuple and should not alter their reference count inside your function. With practice, you can learn to get reference counting right, but it can be frustrating at first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fadc3f723273062c4d9c5a6483a39eed14f9c66" translate="yes" xml:space="preserve">
          <source>Typically, the size of all core dimensions in an output will be determined by the size of a core dimension with the same label in an input array. This is not a requirement, and it is possible to define a signature where a label comes up for the first time in an output, although some precautions must be taken when calling such a function. An example would be the function &lt;code&gt;euclidean_pdist(a)&lt;/code&gt;, with signature &lt;code&gt;(n,d)-&amp;gt;(p)&lt;/code&gt;, that given an array of &lt;code&gt;n&lt;/code&gt;&lt;code&gt;d&lt;/code&gt;-dimensional vectors, computes all unique pairwise Euclidean distances among them. The output dimension &lt;code&gt;p&lt;/code&gt; must therefore be equal to &lt;code&gt;n * (n - 1) / 2&lt;/code&gt;, but it is the caller&amp;rsquo;s responsibility to pass in an output array of the right size. If the size of a core dimension of an output cannot be determined from a passed in input or output array, an error will be raised.</source>
          <target state="translated">通常，输出中所有核心尺寸的大小将由输入数组中具有相同标签的核心尺寸的大小确定。这不是必需的，并且可以定义一个签名，在该签名中输出中第一次出现标签，尽管在调用此类函数时必须采取一些预防措施。一个示例是具有签名 &lt;code&gt;(n,d)-&amp;gt;(p)&lt;/code&gt; 的函数 &lt;code&gt;euclidean_pdist(a)&lt;/code&gt; ，该函数给定 &lt;code&gt;n&lt;/code&gt; &lt;code&gt;d&lt;/code&gt; 维矢量的数组，计算其中所有唯一的成对欧几里德距离。因此，输出尺寸 &lt;code&gt;p&lt;/code&gt; 必须等于 &lt;code&gt;n * (n - 1) / 2&lt;/code&gt; ，但是传递正确大小的输出数组是调用者的责任。如果无法根据传入的输入或输出数组确定输出核心尺寸的大小，则会产生错误。</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="f1bad5a5addf87c78243a0908ff2f26f2b5c976f" translate="yes" xml:space="preserve">
          <source>UC Berkeley (Stefan van der Walt, Sebastian Berg, Warren Weckesser, Ross Barnowski)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054ec2a1c571b996a33a40629d7bbd3a2c7c7a03" translate="yes" xml:space="preserve">
          <source>UFUNC_CHECK_ERROR()</source>
          <target state="translated">UFUNC_CHECK_ERROR()</target>
        </trans-unit>
        <trans-unit id="d2291265ceb8694acf9ebd2a0083ea66791f6665" translate="yes" xml:space="preserve">
          <source>UFUNC_CHECK_STATUS()</source>
          <target state="translated">UFUNC_CHECK_STATUS()</target>
        </trans-unit>
        <trans-unit id="7c45c7778c0f3c31bbfb06962ea0f2b3d024a473" translate="yes" xml:space="preserve">
          <source>UFUNC_ERR_{HANDLER}</source>
          <target state="translated">UFUNC_ERR_{HANDLER}</target>
        </trans-unit>
        <trans-unit id="46518eb931ec8d24ef410f576a7160b8b457bb69" translate="yes" xml:space="preserve">
          <source>UFunc API</source>
          <target state="translated">UFunc API</target>
        </trans-unit>
        <trans-unit id="779cd7c4bcd3367298526e617162cab51fe8f735" translate="yes" xml:space="preserve">
          <source>UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;</source>
          <target state="translated">UPDATEIFCOPY (U)(已废弃),被WRITEBACKIFCOPY取代。</target>
        </trans-unit>
        <trans-unit id="4eab2a5ea17917129ec8fa19b15a7cfda3fe1d46" translate="yes" xml:space="preserve">
          <source>UPDATEIFCOPY / U</source>
          <target state="translated">UPDATEIFCOPY/U</target>
        </trans-unit>
        <trans-unit id="8c955f87125d1d07da79b0f8b10f03f3519e41af" translate="yes" xml:space="preserve">
          <source>UPDATEIFCOPY can only be set &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">UPDATEIFCOPY只能设置为 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7033cb6e00b408f93174a1cb4dc874e5ec8f4436" translate="yes" xml:space="preserve">
          <source>URLs require a scheme string (&lt;code&gt;http://&lt;/code&gt;) to be used, without it they will fail:</source>
          <target state="translated">URL需要使用方案字符串（ &lt;code&gt;http://&lt;/code&gt; ），否则将失败：</target>
        </trans-unit>
        <trans-unit id="76298f39f520148528f0c1a12443b1e9a612a67d" translate="yes" xml:space="preserve">
          <source>Ufunc API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07fbda00eaafb6ceaaf8098d7abd7adf2f3fa665" translate="yes" xml:space="preserve">
          <source>Ufunc behavior for overlapping inputs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01787e5708f1880517c980a345514f0ac0d4f3a1" translate="yes" xml:space="preserve">
          <source>Ufuncs allow other array-like classes to be passed seamlessly through the interface in that inputs of a particular class will induce the outputs to be of that same class. The mechanism by which this works is the following. If any of the inputs are not ndarrays and define the &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method, then the class with the largest &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; attribute determines the type of all the outputs (with the exception of any output arrays passed in). The &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method of the input array will be called with the ndarray being returned from the ufunc as it&amp;rsquo;s input. There are two calling styles of the &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; function supported. The first takes the ndarray as the first argument and a tuple of &amp;ldquo;context&amp;rdquo; as the second argument. The context is (ufunc, arguments, output argument number). This is the first call tried. If a TypeError occurs, then the function is called with just the ndarray as the first argument.</source>
          <target state="translated">Ufunc允许其他类似数组的类通过接口无缝传递，因为特定类的输入将导致输出属于同一类。其工作机制如下。如果有任何的输入不是ndarrays并定义&lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;方法，则具有最大的类&lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt;属性确定所有输出的类型（与传递的任何输出阵列的除外）。所述&lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;输入数组的方法将用来自ufunc因为它的输入返回的感ndarray被调用。&lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;有两种调用样式功能支持。第一个将ndarray作为第一个参数，将&amp;ldquo; context&amp;rdquo;的元组作为第二个参数。上下文是（ufunc，自变量，输出自变量编号）。这是第一次尝试通话。如果发生TypeError，则仅使用ndarray作为第一个参数来调用该函数。</target>
        </trans-unit>
        <trans-unit id="bb1e7beaee60184f94b2766ad490881fcda15d1a" translate="yes" xml:space="preserve">
          <source>Ufuncs also have a fifth method that allows in place operations to be performed using fancy indexing. No buffering is used on the dimensions where fancy indexing is used, so the fancy index can list an item more than once and the operation will be performed on the result of the previous operation for that item.</source>
          <target state="translated">Ufuncs还有第五种方法,可以使用花式索引进行到位操作。在使用花式索引的维度上不使用缓冲,所以花式索引可以不止一次地列出一个项目,并且会对该项目的前一次操作结果进行操作。</target>
        </trans-unit>
        <trans-unit id="ebe1370731077d311895107006a4816f68d36e75" translate="yes" xml:space="preserve">
          <source>Ufuncs: If the &lt;code&gt;ALIGNED&lt;/code&gt; flag of an array is False, ufuncs will buffer/cast the array before evaluation. This is needed since ufunc inner loops access raw elements directly, which might fail on some archs if the elements are not true-aligned.</source>
          <target state="translated">Ufuncs：如果数组的 &lt;code&gt;ALIGNED&lt;/code&gt; 标志为False，则Ufuncs将在评估之前缓冲/广播该数组。这是必需的，因为ufunc内部循环直接访问原始元素，如果元素未真正对齐，则在某些拱形上可能会失败。</target>
        </trans-unit>
        <trans-unit id="781ffa6fd9f0234942bb6847c5bb2f8924769498" translate="yes" xml:space="preserve">
          <source>Umath and multiarray c-extension modules merged into a single module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52313eed90dffcad6d336fc2df812a51c07afa3f" translate="yes" xml:space="preserve">
          <source>Un-sized flexible data-type objects do not have this attribute.</source>
          <target state="translated">非大小灵活的数据类型对象没有这个属性。</target>
        </trans-unit>
        <trans-unit id="b7fcaea31c03023df34e5b7b17cd0d3a054b94c0" translate="yes" xml:space="preserve">
          <source>Unary operations:</source>
          <target state="translated">单元操作。</target>
        </trans-unit>
        <trans-unit id="eb11f871299eef811cd072499c803b05b282a2bf" translate="yes" xml:space="preserve">
          <source>Under certain conditions, &lt;code&gt;nditer&lt;/code&gt; must be used in a context manager</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a813a893f115799fcd0b6f6dee8828d16c00cb4d" translate="yes" xml:space="preserve">
          <source>Under-the-hood Documentation for developers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee256bb7a636957391cc28f26fc314ab3aeba52b" translate="yes" xml:space="preserve">
          <source>Under-the-hood docs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56332d95dfcc595c6bea8676636a72713f221f0a" translate="yes" xml:space="preserve">
          <source>Underflow: result so close to zero that some precision was lost.</source>
          <target state="translated">下溢:结果如此接近于零,以至于损失了一些精度。</target>
        </trans-unit>
        <trans-unit id="59c608e219e1ef1b3832d726571dbc3af32612af" translate="yes" xml:space="preserve">
          <source>Understand axis and shape properties for n-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a82cdb76fef36e8a84963b1363d0b9e06ddc672" translate="yes" xml:space="preserve">
          <source>Understand how to apply some linear algebra operations to n-dimensional arrays without using for-loops;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54944247198ee020e57c96492a8adaa8f1c26ce" translate="yes" xml:space="preserve">
          <source>Understand the difference between one-, two- and n-dimensional arrays in NumPy;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233fa68a512b31fd9c7e11c16b1a271f55f3bf8e" translate="yes" xml:space="preserve">
          <source>Understanding the code &amp;amp; getting started</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de8fa4e24f45bc650b9e48b7af77833b4a2c462a" translate="yes" xml:space="preserve">
          <source>Undoes &lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;, shifts zero-frequency terms to beginning of array.</source>
          <target state="translated">撤消&lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt;，将零频率项移到数组的开头。</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="4fee0b7959c07c12abdb6224e31004ed0e03fe8f" translate="yes" xml:space="preserve">
          <source>Unicode (fixed-length sequence of &lt;a href=&quot;https://docs.python.org/dev/c-api/unicode.html#c.Py_UNICODE&quot;&gt;&lt;code&gt;Py_UNICODE&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">Unicode（&lt;a href=&quot;https://docs.python.org/dev/c-api/unicode.html#c.Py_UNICODE&quot;&gt; &lt;code&gt;Py_UNICODE&lt;/code&gt; 的&lt;/a&gt;固定长度序列）</target>
        </trans-unit>
        <trans-unit id="1b41da839119c4860ed2bab536f19149822ad0f7" translate="yes" xml:space="preserve">
          <source>Unicode string</source>
          <target state="translated">统一码字符串</target>
        </trans-unit>
        <trans-unit id="b817c790c0e1eb2da135f6728ba7e7a734d36d2a" translate="yes" xml:space="preserve">
          <source>Uniforms</source>
          <target state="translated">Uniforms</target>
        </trans-unit>
        <trans-unit id="bd181d4ea0c5f747e6be59067008be3f6a568280" translate="yes" xml:space="preserve">
          <source>Uniforms (&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.random.generator.integers#numpy.random.Generator.integers&quot;&gt;&lt;code&gt;integers&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">制服（&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;generated/numpy.random.generator.integers#numpy.random.Generator.integers&quot;&gt; &lt;code&gt;integers&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="e9cccdf4596cb9bd6da09d86e9aec754328ad900" translate="yes" xml:space="preserve">
          <source>Uniforms (&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2697f04d1c34bc0fd003a5d4f2f248be3c9842cb" translate="yes" xml:space="preserve">
          <source>Union types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d19a005048195442e1a0367112ec40ef36c8dd2" translate="yes" xml:space="preserve">
          <source>Unique, sorted union of the input arrays.</source>
          <target state="translated">输入数组的唯一、排序联合。</target>
        </trans-unit>
        <trans-unit id="76a96316e226896e4f1438a10bfe2c7d74733b0a" translate="yes" xml:space="preserve">
          <source>Unit Conversion</source>
          <target state="translated">单位换算</target>
        </trans-unit>
        <trans-unit id="2b379c9399e276f2dc8f9383decfb02923fa06dd" translate="yes" xml:space="preserve">
          <source>Unitary array(s). The first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions have the same size as those of the input &lt;code&gt;a&lt;/code&gt;. The size of the last two dimensions depends on the value of &lt;code&gt;full_matrices&lt;/code&gt;. Only returned when &lt;code&gt;compute_uv&lt;/code&gt; is True.</source>
          <target state="translated">单一数组。前 &lt;code&gt;a.ndim - 2&lt;/code&gt; 维的大小与输入 &lt;code&gt;a&lt;/code&gt; 的大小相同。最后两个维度的大小取决于 &lt;code&gt;full_matrices&lt;/code&gt; 的值。仅在 &lt;code&gt;compute_uv&lt;/code&gt; 为True 时返回。</target>
        </trans-unit>
        <trans-unit id="89952e170b7f249d54c02c56dc948ea92d581887" translate="yes" xml:space="preserve">
          <source>Universal Functions</source>
          <target state="translated">通用功能</target>
        </trans-unit>
        <trans-unit id="7d5959424165b0a7771ddfd877626852ebcf0b02" translate="yes" xml:space="preserve">
          <source>Universal function. A fast element-wise, &lt;a href=&quot;#term-vectorization&quot;&gt;vectorized&lt;/a&gt; array operation. Examples include &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt; and &lt;code&gt;logical_or&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4ed03ac8db5e6ac9dfa92939a06553bcbad44ab" translate="yes" xml:space="preserve">
          <source>Universal functions</source>
          <target state="translated">通用功能</target>
        </trans-unit>
        <trans-unit id="e3950ded82824788c1d59c1dc67f67776133fd02" translate="yes" xml:space="preserve">
          <source>Universal functions (&lt;code&gt;ufunc&lt;/code&gt;)</source>
          <target state="translated">通用功能（ &lt;code&gt;ufunc&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="825ac503579fb05389d22b5b4afa49b44dc3e914" translate="yes" xml:space="preserve">
          <source>Universal functions (ufunc)</source>
          <target state="translated">通用功能(ufunc)</target>
        </trans-unit>
        <trans-unit id="1c8ff35a75bf6e5497766666bbe2a77eb53892e4" translate="yes" xml:space="preserve">
          <source>Universal functions are callable objects that take</source>
          <target state="translated">通用函数是可调用的对象,它们以</target>
        </trans-unit>
        <trans-unit id="14ef4c614fdbba7fe91a08e7e1d79eb5845cd489" translate="yes" xml:space="preserve">
          <source>Universal functions can trip special floating-point status registers in your hardware (such as divide-by-zero). If available on your platform, these registers will be regularly checked during calculation. Error handling is controlled on a per-thread basis, and can be configured using the functions</source>
          <target state="translated">通用函数可以跳转你的硬件中的特殊浮点状态寄存器(如除以零)。如果你的平台上有这些寄存器,那么在计算过程中会定期检查。错误处理是在每个线程的基础上进行控制的,可以使用函数</target>
        </trans-unit>
        <trans-unit id="f2a6f922fe59febd69c7ec0550beca70f253abf6" translate="yes" xml:space="preserve">
          <source>Universal functions in NumPy are flexible enough to have mixed type signatures. Thus, for example, a universal function could be defined that works with floating-point and integer values. See &lt;a href=&quot;generated/numpy.ldexp#numpy.ldexp&quot;&gt;&lt;code&gt;ldexp&lt;/code&gt;&lt;/a&gt; for an example.</source>
          <target state="translated">NumPy中的通用函数足够灵活，可以具有混合类型签名。因此，例如，可以定义一个通用函数，该函数可用于浮点数和整数值。有关&lt;a href=&quot;generated/numpy.ldexp#numpy.ldexp&quot;&gt; &lt;code&gt;ldexp&lt;/code&gt; &lt;/a&gt;，请参见ldexp。</target>
        </trans-unit>
        <trans-unit id="dc2928ef9066faa49b65eacee08cc9ff5b8df03a" translate="yes" xml:space="preserve">
          <source>Unlabeled tests like the ones above are run in the default &lt;code&gt;scipy.test()&lt;/code&gt; run. If you want to label your test as slow - and therefore reserved for a full &lt;code&gt;scipy.test(label='full')&lt;/code&gt; run, you can label it with a decorator:</source>
          <target state="translated">如上的未标记测试在默认的 &lt;code&gt;scipy.test()&lt;/code&gt; 运行中运行。如果您想将测试标记为缓慢-因此保留用于完整的 &lt;code&gt;scipy.test(label='full')&lt;/code&gt; 运行，则可以使用装饰器将其标记为：</target>
        </trans-unit>
        <trans-unit id="f80a919f246626907387dd0726bbe89b8b51b4df" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">除非&lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;为False且满足返回输入数组的其他条件（请参见&lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;输入参数的描述）， &lt;code&gt;arr_t&lt;/code&gt; 是形状与输入数组相同的新数组，其类型为dtype，顺序为&lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef7dd27d4664eeedf99baaa7e0c49db6deaa478b" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">除非&lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;为False且满足返回输入数组的其他条件（请参见&lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;输入参数的描述）， &lt;code&gt;arr_t&lt;/code&gt; 是形状与输入数组相同的新数组，其类型为dtype，顺序为&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5fb1f8307f01c7e357482bf17ec2115ae4f2033" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd72f00597798516e6971a2dbcb92a29bbbdaed9" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">除非&lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;为False且满足返回输入数组的其他条件（请参见&lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;输入参数的描述）， &lt;code&gt;arr_t&lt;/code&gt; 是形状与输入数组相同的新数组，其类型为dtype，顺序为&lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e2517e50c2cd18f9fa374a65d4b11b6882475bf" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;refcheck&lt;/code&gt; is False:</source>
          <target state="translated">除非 &lt;code&gt;refcheck&lt;/code&gt; 为False：</target>
        </trans-unit>
        <trans-unit id="5c06c023a0677199fe16b8704d88475521f3247a" translate="yes" xml:space="preserve">
          <source>Unless NumPy is made aware of an issue with this, this function is scheduled for rapid removal without replacement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b12a052540dd37bc0bf5e60cc41fc32cdcbd4cfa" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt;&lt;code&gt;numpy.equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">与&lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt; &lt;code&gt;numpy.equal&lt;/code&gt; &lt;/a&gt;不同，此比较是通过首先从字符串末尾去除空格字符来执行的。提供此行为是为了与numarray向后兼容。</target>
        </trans-unit>
        <trans-unit id="6b2b2c64bbd5177dd4a58ffb6ba3be3f39244e9c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.fft.fftfreq#numpy.fft.fftfreq&quot;&gt;&lt;code&gt;fftfreq&lt;/code&gt;&lt;/a&gt; (but like &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.rfftfreq.html#scipy.fftpack.rfftfreq&quot;&gt;&lt;code&gt;scipy.fftpack.rfftfreq&lt;/code&gt;&lt;/a&gt;) the Nyquist frequency component is considered to be positive.</source>
          <target state="translated">与&lt;a href=&quot;numpy.fft.fftfreq#numpy.fft.fftfreq&quot;&gt; &lt;code&gt;fftfreq&lt;/code&gt; &lt;/a&gt;（但类似于&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.rfftfreq.html#scipy.fftpack.rfftfreq&quot;&gt; &lt;code&gt;scipy.fftpack.rfftfreq&lt;/code&gt; &lt;/a&gt;）不同，奈奎斯特频率分量被认为是正数。</target>
        </trans-unit>
        <trans-unit id="5f3a2cd1365b2531abc2f011c55c5607d024f719" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.greater#numpy.greater&quot;&gt;&lt;code&gt;numpy.greater&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">与&lt;a href=&quot;numpy.greater#numpy.greater&quot;&gt; &lt;code&gt;numpy.greater&lt;/code&gt; &lt;/a&gt;不同，此比较是通过首先从字符串末尾去除空格字符来执行的。提供此行为是为了与numarray向后兼容。</target>
        </trans-unit>
        <trans-unit id="8db96ae1e185ea43483bbcf2e2a064fdf5d5ac53" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.greater_equal#numpy.greater_equal&quot;&gt;&lt;code&gt;numpy.greater_equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">与&lt;a href=&quot;numpy.greater_equal#numpy.greater_equal&quot;&gt; &lt;code&gt;numpy.greater_equal&lt;/code&gt; &lt;/a&gt;不同，此比较是通过首先从字符串末尾去除空格字符来执行的。提供此行为是为了与numarray向后兼容。</target>
        </trans-unit>
        <trans-unit id="cc98934fa39c9d5a378edf27cd9d3fdf09aca64f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.less_equal#numpy.less_equal&quot;&gt;&lt;code&gt;numpy.less_equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">与&lt;a href=&quot;numpy.less_equal#numpy.less_equal&quot;&gt; &lt;code&gt;numpy.less_equal&lt;/code&gt; &lt;/a&gt;不同，此比较是通过首先从字符串末尾去除空格字符来执行的。提供此行为是为了与numarray向后兼容。</target>
        </trans-unit>
        <trans-unit id="13463cefef0c63fb378a22fb3869ee59d3559110" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.asmatrix&quot;&gt;&lt;code&gt;asmatrix&lt;/code&gt;&lt;/a&gt; does not make a copy if the input is already a matrix or an ndarray. Equivalent to &lt;code&gt;matrix(data, copy=False)&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;不同，如果输入已经是矩阵或ndarray ，则&lt;a href=&quot;#numpy.asmatrix&quot;&gt; &lt;code&gt;asmatrix&lt;/code&gt; &lt;/a&gt;不会复制。等效于 &lt;code&gt;matrix(data, copy=False)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0d5bc239c5d20908848ae252443d0a4e4413dd3" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.asmatrix#numpy.asmatrix&quot;&gt;&lt;code&gt;asmatrix&lt;/code&gt;&lt;/a&gt; does not make a copy if the input is already a matrix or an ndarray. Equivalent to &lt;code&gt;matrix(data, copy=False)&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt;不同，如果输入已经是矩阵或ndarray ，则&lt;a href=&quot;numpy.asmatrix#numpy.asmatrix&quot;&gt; &lt;code&gt;asmatrix&lt;/code&gt; &lt;/a&gt;不会复制。等效于 &lt;code&gt;matrix(data, copy=False)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5b1299452ddecaa69fc7626dc84ab62f7aec6df" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.not_equal#numpy.not_equal&quot;&gt;&lt;code&gt;numpy.not_equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">与&lt;a href=&quot;numpy.not_equal#numpy.not_equal&quot;&gt; &lt;code&gt;numpy.not_equal&lt;/code&gt; &lt;/a&gt;不同，此比较是通过首先从字符串末尾去除空格字符来执行的。提供此行为是为了与numarray向后兼容。</target>
        </trans-unit>
        <trans-unit id="1df4f0edb26736c54c37d1f3f53f3c4e05be97d2" translate="yes" xml:space="preserve">
          <source>Unlike MATLAB&amp;reg;, where anything on your path can be called immediately, with Python you need to first do an &amp;lsquo;import&amp;rsquo; statement to make functions in a particular file accessible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd2a67552682e7936714b3e48fc7203a2e15901a" translate="yes" xml:space="preserve">
          <source>Unlike in many matrix languages, the product operator &lt;code&gt;*&lt;/code&gt; operates elementwise in NumPy arrays. The matrix product can be performed using the &lt;code&gt;@&lt;/code&gt; operator (in python &amp;gt;=3.5) or the &lt;code&gt;dot&lt;/code&gt; function or method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991d558a10f3fed386601ea572b9a25a236458aa" translate="yes" xml:space="preserve">
          <source>Unlike in the case of integer index arrays, in the boolean case, the result is a 1-D array containing all the elements in the indexed array corresponding to all the true elements in the boolean array. The elements in the indexed array are always iterated and returned in &lt;a href=&quot;../glossary#term-row-major&quot;&gt;row-major&lt;/a&gt; (C-style) order. The result is also identical to &lt;code&gt;y[np.nonzero(b)]&lt;/code&gt;. As with index arrays, what is returned is a copy of the data, not a view as one gets with slices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9e6d341e111d5abaa8c91d594d12353e24be13" translate="yes" xml:space="preserve">
          <source>Unlike lists and tuples, numpy arrays support multidimensional indexing for multidimensional arrays. That means that it is not necessary to separate each dimension&amp;rsquo;s index into its own set of square brackets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70d4d959a48f1152d15702553262318c5fb98806" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Chebyshev series is a Chebyshev series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个Chebyshev级数的差是一个Chebyshev级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此减法就像&amp;ldquo;标准&amp;rdquo;多项式一样，只是&amp;ldquo;按分量&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="e46cc304c2f214fabbfe81dd6c99872edb6df227" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Hermite series is a Hermite series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个Hermite级数的差是一个Hermite级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此减法就像&amp;ldquo;标准&amp;rdquo;多项式的减法一样，只是&amp;ldquo;按分量进行&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0beee9ca9d008b84130a4966827a4791db0f0fc1" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Laguerre series is a Laguerre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个Laguerre级数的差是Laguerre级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此减法就像&amp;ldquo;标准&amp;rdquo;多项式一样，只是&amp;ldquo;按分量进行&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="853913b39ae1eac706caf9dd0fbf8022480e5898" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Legendre series is a Legendre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个勒让德级数的差是勒让德级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此减法就像&amp;ldquo;标准&amp;rdquo;多项式一样，只是&amp;ldquo;按分量&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="817c653b37e40c515ff2966447fe5fceb6d50c2b" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Chebyshev series is a Chebyshev series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个Chebyshev级数的和是一个Chebyshev级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此加法就像&amp;ldquo;标准&amp;rdquo;多项式的加法一样，只是&amp;ldquo;逐分量&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="96e94bebc99e72aa93e0ba2b3e9d976f9a242788" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Hermite series is a Hermite series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个Hermite系列的总和是一个Hermite系列（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此加法就像&amp;ldquo;标准&amp;rdquo;多项式的加法一样，只是&amp;ldquo;按分量进行&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="a1bfae60ca127fe23c05d0fcb5e3af8c025e808e" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Laguerre series is a Laguerre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个Laguerre级数的和是Laguerre级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此加法就像&amp;ldquo;标准&amp;rdquo;多项式的加法一样，只是&amp;ldquo;逐分量&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="479fccdc37cae736330d681081d02fd22d2b4c05" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Legendre series is a Legendre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">与乘法，除法等不同，两个勒让德级数的总和是勒让德级数（不必将结果&amp;ldquo;重新投影&amp;rdquo;到基集上），因此加法就像&amp;ldquo;标准&amp;rdquo;多项式的加法一样，只是&amp;ldquo;按分量进行&amp;rdquo; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="c37836d2f2fa6578d699e351ca0672a2d96cc650" translate="yes" xml:space="preserve">
          <source>Unlike other numpy scalars, structured scalars are mutable and act like views into the original array, such that modifying the scalar will modify the original array. Structured scalars also support access and assignment by field name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191384b28da289c339b69142c174b4bdb8ca4902" translate="yes" xml:space="preserve">
          <source>Unlike some of the references (such as array and mask indices) assignments are always made to the original data in the array (indeed, nothing else would make sense!). Note though, that some actions may not work as one may naively expect. This particular example is often surprising to people:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6138c52b3d14f1f06df9ad9cd32f8b7c13aad36f" translate="yes" xml:space="preserve">
          <source>Unlike the built-in &lt;a href=&quot;https://docs.python.org/dev/library/math.html#math.isclose&quot;&gt;&lt;code&gt;math.isclose&lt;/code&gt;&lt;/a&gt;, the above equation is not symmetric in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; &amp;ndash; it assumes &lt;code&gt;b&lt;/code&gt; is the reference value &amp;ndash; so that &lt;code&gt;isclose(a, b)&lt;/code&gt; might be different from &lt;code&gt;isclose(b, a)&lt;/code&gt;. Furthermore, the default value of atol is not zero, and is used to determine what small values should be considered close to zero. The default value is appropriate for expected values of order unity: if the expected values are significantly smaller than one, it can result in false positives. &lt;code&gt;atol&lt;/code&gt; should be carefully selected for the use case at hand. A zero value for &lt;code&gt;atol&lt;/code&gt; will result in &lt;code&gt;False&lt;/code&gt; if either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is zero.</source>
          <target state="translated">与内置&lt;a href=&quot;https://docs.python.org/dev/library/math.html#math.isclose&quot;&gt; &lt;code&gt;math.isclose&lt;/code&gt; 不同&lt;/a&gt;，上述方程式在 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 中不对称-假定 &lt;code&gt;b&lt;/code&gt; 是参考值-因此 &lt;code&gt;isclose(a, b)&lt;/code&gt; 可能与 &lt;code&gt;isclose(b, a)&lt;/code&gt; 。此外，atol的默认值不为零，用于确定应将哪些较小的值视为接近零。默认值适用于阶数为1的期望值：如果期望值明显小于1，则可能导致误报。应该仔细选择 &lt;code&gt;atol&lt;/code&gt; 作为手边的用例。零值 &lt;code&gt;atol&lt;/code&gt; 会导致 &lt;code&gt;False&lt;/code&gt; 如果任 &lt;code&gt;a&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt; 为零。</target>
        </trans-unit>
        <trans-unit id="b9b43bc2298a20c8156a6023d94ab148e7869ea1" translate="yes" xml:space="preserve">
          <source>Unlike the free function &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, this method on &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; allows the elements of the shape parameter to be passed in as separate arguments. For example, &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; is equivalent to &lt;code&gt;a.reshape((10, 11))&lt;/code&gt;.</source>
          <target state="translated">不同于免费功能&lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt;，在此方法&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;允许形状参数中的元素，以作为单独的参数传递。例如， &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; 等效于 &lt;code&gt;a.reshape((10, 11))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c055ec1da31f5b3a36529d3d52329cd0cef8c5de" translate="yes" xml:space="preserve">
          <source>Unlike the free function &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, this method on &lt;code&gt;ndarray&lt;/code&gt; allows the elements of the shape parameter to be passed in as separate arguments. For example, &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; is equivalent to &lt;code&gt;a.reshape((10, 11))&lt;/code&gt;.</source>
          <target state="translated">不同于免费功能&lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt;，在此方法 &lt;code&gt;ndarray&lt;/code&gt; 允许形状参数中的元素，以作为单独的参数传递。例如， &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; 等效于 &lt;code&gt;a.reshape((10, 11))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0206a9a6a08e980ce9de3768f0db78bc718405ea" translate="yes" xml:space="preserve">
          <source>Unlike the standard numpy comparison operators, the ones in the &lt;code&gt;char&lt;/code&gt; module strip trailing whitespace characters before performing the comparison.</source>
          <target state="translated">与标准numpy比较运算符不同， &lt;code&gt;char&lt;/code&gt; 模块中的运算符在执行比较之前会删除尾随空白字符。</target>
        </trans-unit>
        <trans-unit id="7fbacb4b6a81b741ccf818cdd058fa9d9f52d43b" translate="yes" xml:space="preserve">
          <source>Unmasking an entry</source>
          <target state="translated">解除屏蔽条目</target>
        </trans-unit>
        <trans-unit id="c37a5ee094534c733a693e498e6b83c12096d6e0" translate="yes" xml:space="preserve">
          <source>Unmasking an entry by direct assignment will silently fail if the masked array has a &lt;em&gt;hard&lt;/em&gt; mask, as shown by the &lt;code&gt;hardmask&lt;/code&gt; attribute. This feature was introduced to prevent overwriting the mask. To force the unmasking of an entry where the array has a hard mask, the mask must first to be softened using the &lt;a href=&quot;generated/numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt;&lt;code&gt;soften_mask&lt;/code&gt;&lt;/a&gt; method before the allocation. It can be re-hardened with &lt;a href=&quot;generated/numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt;&lt;code&gt;harden_mask&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果被掩码的数组具有&lt;em&gt;硬&lt;/em&gt;掩码，则通过直接分配取消对条目的掩码将自动失败，如 &lt;code&gt;hardmask&lt;/code&gt; 属性所示。引入此功能是为了防止覆盖掩码。要在阵列具有硬掩码的情况下强制取消条目的掩码，必须先在分配之前使用&lt;a href=&quot;generated/numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt; &lt;code&gt;soften_mask&lt;/code&gt; &lt;/a&gt;方法将掩码软化。可以使用&lt;a href=&quot;generated/numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt; &lt;code&gt;harden_mask&lt;/code&gt; &lt;/a&gt;重新加固它：</target>
        </trans-unit>
        <trans-unit id="5724dd60c593622fc16f28573a8be39237c1817b" translate="yes" xml:space="preserve">
          <source>Unmodified core dimensions that share the same name must have the same size. Each dimension name typically corresponds to one level of looping in the elementary function&amp;rsquo;s implementation.</source>
          <target state="translated">具有相同名称的未修改核心尺寸必须具有相同的大小。每个维名称通常对应于基本函数实现中的一个循环级别。</target>
        </trans-unit>
        <trans-unit id="0c8c8df9f7c1cb71b2c99863e55f28b2342c49c8" translate="yes" xml:space="preserve">
          <source>Unpacks elements of a uint8 array into a binary-valued output array.</source>
          <target state="translated">将一个uint8数组中的元素解包成一个二进制值的输出数组。</target>
        </trans-unit>
        <trans-unit id="cfb0e26f84a72aa991cbd86d2a8e70f9268c36da" translate="yes" xml:space="preserve">
          <source>Unpickling while loading requires explicit opt-in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2316b90ad07a17bab89992c697827520a7c1a76" translate="yes" xml:space="preserve">
          <source>Unsafe int casting of the num attribute in &lt;code&gt;linspace&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b27e09825b38c1619e31484868bfeb48e96d8d2" translate="yes" xml:space="preserve">
          <source>Unsigned integer</source>
          <target state="translated">无符号整数</target>
        </trans-unit>
        <trans-unit id="19201d9c175004fe2d2c285a14b33dc2f3c58964" translate="yes" xml:space="preserve">
          <source>Unsigned integer (0 to 18446744073709551615)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d614ab4b08ea51c529ca2afd42bd5cb8f14039b7" translate="yes" xml:space="preserve">
          <source>Unsigned integer (0 to 255)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece1b13212dbdde6f6979b0eb6cfffcea163e303" translate="yes" xml:space="preserve">
          <source>Unsigned integer (0 to 4294967295)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5280260c5f39b844aa889ca5265bd63ac321070f" translate="yes" xml:space="preserve">
          <source>Unsigned integer (0 to 65535)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432373371510943ee2651ebf21148b86384d0a29" translate="yes" xml:space="preserve">
          <source>Unsigned integers:</source>
          <target state="translated">无符号整数。</target>
        </trans-unit>
        <trans-unit id="c824dd22d12bde4feee6277b067eb0b05fa4fdf1" translate="yes" xml:space="preserve">
          <source>Unsigned versions of the integers can be defined by pre-pending a &amp;lsquo;u&amp;rsquo; to the front of the integer name.</source>
          <target state="translated">整数的无符号版本可以通过在整数名称的前面添加&amp;ldquo; u&amp;rdquo;来定义。</target>
        </trans-unit>
        <trans-unit id="3b4a1ed161e3d5d468bc7819a4a4469e69fb390c" translate="yes" xml:space="preserve">
          <source>Unstructured array or dtype to convert.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8443c9cc12807ec6c811788bbce2592aaf619083" translate="yes" xml:space="preserve">
          <source>Unstructured array with one more dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd4f4dc80803ac1f52848ab12f25d8e2d5b8e16f" translate="yes" xml:space="preserve">
          <source>Until Python 3.5 the only disadvantage of using the array type was that you had to use &lt;code&gt;dot&lt;/code&gt; instead of &lt;code&gt;*&lt;/code&gt; to multiply (reduce) two tensors (scalar product, matrix vector multiplication etc.). Since Python 3.5 you can use the matrix multiplication &lt;code&gt;@&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91aa49f62879d325c6707e96a59652eaa942e8ca" translate="yes" xml:space="preserve">
          <source>Until the 1.15 release, NumPy used the &lt;a href=&quot;https://nose.readthedocs.io/en/latest/&quot;&gt;nose&lt;/a&gt; testing framework, it now uses the &lt;a href=&quot;https://pytest.readthedocs.io&quot;&gt;pytest&lt;/a&gt; framework. The older framework is still maintained in order to support downstream projects that use the old numpy framework, but all tests for NumPy should use pytest.</source>
          <target state="translated">在1.15版之前，NumPy使用&lt;a href=&quot;https://nose.readthedocs.io/en/latest/&quot;&gt;鼻子&lt;/a&gt;测试框架，现在使用&lt;a href=&quot;https://pytest.readthedocs.io&quot;&gt;pytest&lt;/a&gt;框架。为了支持使用旧numpy框架的下游项目，仍旧维护旧框架，但是所有针对NumPy的测试都应使用pytest。</target>
        </trans-unit>
        <trans-unit id="f13be7738e1389f72c0f88aa84d17719f746bf4a" translate="yes" xml:space="preserve">
          <source>Unused.</source>
          <target state="translated">Unused.</target>
        </trans-unit>
        <trans-unit id="52bd5ee224646394816a409132afdc6f181c7d8b" translate="yes" xml:space="preserve">
          <source>Unwelcome sexual attention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91235b6cec5e2bdecb806fae5c6f1c673c46dd54" translate="yes" xml:space="preserve">
          <source>Unwrap by changing deltas between values to 2*pi complement.</source>
          <target state="translated">将数值之间的三角区改为2*pi补全,就可以解开。</target>
        </trans-unit>
        <trans-unit id="cba2ade8e0d37d0f36a249f716f7633b555a4616" translate="yes" xml:space="preserve">
          <source>Unwrap radian phase &lt;code&gt;p&lt;/code&gt; by changing absolute jumps greater than &lt;code&gt;discont&lt;/code&gt; to their 2*pi complement along the given axis.</source>
          <target state="translated">通过改变大于给定轴上2 * pi补码的绝对跳 &lt;code&gt;discont&lt;/code&gt; 来解开弧度相位 &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31f87bfbdb61e41f06f9d6ba5c2c33b85dec73cd" translate="yes" xml:space="preserve">
          <source>Upcasting:</source>
          <target state="translated">Upcasting:</target>
        </trans-unit>
        <trans-unit id="579edc70cbe349fcc3048fa42d7c965a563d10ae" translate="yes" xml:space="preserve">
          <source>Update PyPI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a305b240bddfefe147af5326421c8f0107898199" translate="yes" xml:space="preserve">
          <source>Update Release documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a858dc159ecba3062c1406c8e0fb587c83eace91" translate="yes" xml:space="preserve">
          <source>Update policy documents such as this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="676d87bea990c4c73ff4081f6b93aae5ebcc7dac" translate="yes" xml:space="preserve">
          <source>Update scipy.org</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e81e08ab40d294f4651a8208d4e909d5156cbf" translate="yes" xml:space="preserve">
          <source>Update the Milestones in Trac.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8117487cd3d843fb21b5965b5f6cf86d9fd9d8a6" translate="yes" xml:space="preserve">
          <source>Update the release notes with a Highlights section. Mention some of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd25c09dc3e898187644d607cbbc12c4edc2554e" translate="yes" xml:space="preserve">
          <source>Update the release status and create a release &amp;ldquo;tag&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1db22e1acc193e90fbde99ab0d68584a24cec01a" translate="yes" xml:space="preserve">
          <source>Update the version of the master branch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777088119e41bc0469a64ccb283496abe08bc95e" translate="yes" xml:space="preserve">
          <source>Updated version of PyArray_Correlate, which uses the usual definition of correlation for 1d arrays. The correlation is computed at each output point by multiplying &lt;em&gt;op1&lt;/em&gt; by a shifted version of &lt;em&gt;op2&lt;/em&gt; and summing the result. As a result of the shift, needed values outside of the defined range of &lt;em&gt;op1&lt;/em&gt; and &lt;em&gt;op2&lt;/em&gt; are interpreted as zero. The mode determines how many shifts to return: 0 - return only shifts that did not need to assume zero- values; 1 - return an object that is the same size as &lt;em&gt;op1&lt;/em&gt;, 2 - return all possible shifts (any overlap at all is accepted).</source>
          <target state="translated">PyArray_Correlate的更新版本，它使用一维数组的常规相关定义。通过将&lt;em&gt;op1&lt;/em&gt;乘以&lt;em&gt;op2&lt;/em&gt;的移位版本并求和，可以在每个输出点计算相关性。移位的结果是，超出&lt;em&gt;op1&lt;/em&gt;和&lt;em&gt;op2&lt;/em&gt;定义范围的所需值被解释为零。该模式确定要返回的班次：0-仅返回不需要采用零值的班次；否则，返回0。1-返回与&lt;em&gt;op1&lt;/em&gt;大小相同的对象，2-返回所有可能的移位（任何重叠都被接受）。</target>
        </trans-unit>
        <trans-unit id="a7409084cf2605b5cad89ac1878143241b496ed1" translate="yes" xml:space="preserve">
          <source>Updating the code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab89ee68187f5c809160685dea5430718e73ea0" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;doc/changelog/1.14.5-changelog.rst&lt;/code&gt; as a binary file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8242899ac44525eea3639fc9196319bcd5798e1" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;release/README.rst&lt;/code&gt; as a binary file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be4f20f37deddb1b1a33a72c43f77bfa0490a76" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;release/installers/numpy-1.14.5.tar.gz&lt;/code&gt; as a binary file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f92deadaf10f46166261ad542bc8986cab5d64" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;release/installers/numpy-1.14.5.zip&lt;/code&gt; as a binary file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feca53bac4346b96bf1a7a8af5a58f9b95162f3b" translate="yes" xml:space="preserve">
          <source>Upload documents to numpy.org</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc2fac0bfff4c1c9d6c6f5a22fc6d38d8b5119c" translate="yes" xml:space="preserve">
          <source>Upload files to github</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ea156fa200c4b1e62bfc88ad83c78600949638" translate="yes" xml:space="preserve">
          <source>Upload to PyPI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c16ab259dc55f6326fdf3044018a5aed36c63fd1" translate="yes" xml:space="preserve">
          <source>Upload to PyPI using &lt;code&gt;twine&lt;/code&gt;. A recent version of &lt;code&gt;twine&lt;/code&gt; of is needed after recent PyPI changes, version &lt;code&gt;1.11.0&lt;/code&gt; was used here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6565e74e2ff5bcf02b09c60c49c14fcfab1feb84" translate="yes" xml:space="preserve">
          <source>Uploading to PyPI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d1841e63317d86d0b2bbae07f2e08dc59ff7f9" translate="yes" xml:space="preserve">
          <source>Upper boundary of the output interval. All values generated will be less than high. The default value is 1.0.</source>
          <target state="translated">输出区间的上界。所有生成的值都将小于高值。默认值为1.0。</target>
        </trans-unit>
        <trans-unit id="94608c7ff5f4700d78cab2cf3285f4a9e6dc1615" translate="yes" xml:space="preserve">
          <source>Upper boundary of the output interval. All values generated will be less than or equal to high. The default value is 1.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52be5864b9af229753de85f916fa14a1fa97d3a1" translate="yes" xml:space="preserve">
          <source>Upper limit, must be larger than &lt;code&gt;left&lt;/code&gt;.</source>
          <target state="translated">上限，必须大于 &lt;code&gt;left&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="528933f6438e2665073f1a6a0a370889bd9e0bae" translate="yes" xml:space="preserve">
          <source>Upper or lower-triangular Cholesky factor of &lt;code&gt;a&lt;/code&gt;. Returns a matrix object if &lt;code&gt;a&lt;/code&gt; is a matrix object.</source>
          <target state="translated">上或下三角的Cholesky因数 &lt;code&gt;a&lt;/code&gt; 。如果 &lt;code&gt;a&lt;/code&gt; 是矩阵对象，则返回矩阵对象。</target>
        </trans-unit>
        <trans-unit id="57bb98258946012ee6623d2627640ef4f5f0bbc8" translate="yes" xml:space="preserve">
          <source>Upper triangle of an array.</source>
          <target state="translated">阵列的上三角。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="a6ddf950ead3f5a277ec641c8bb4408b4523e874" translate="yes" xml:space="preserve">
          <source>Usage of ATLAS and other accelerated libraries in NumPy can be disabled via:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="f8422a8af0050351fb69661fa171b15f26430c90" translate="yes" xml:space="preserve">
          <source>Use 4-space indents and no tabs at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4f4f55257b83792366b61f4d5627bfeafb83aa3" translate="yes" xml:space="preserve">
          <source>Use 64-bit integer size on 64-bit platforms in fallback lapack_lite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15df8cc43a52230464924d2366701940520ece7" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt; because &lt;a href=&quot;#numpy.Inf&quot;&gt;&lt;code&gt;Inf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.Infinity&quot;&gt;&lt;code&gt;Infinity&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.PINF&quot;&gt;&lt;code&gt;PINF&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#numpy.infty&quot;&gt;&lt;code&gt;infty&lt;/code&gt;&lt;/a&gt; are aliases for &lt;a href=&quot;#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt;. For more details, see &lt;a href=&quot;#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; &lt;/a&gt;是因为&lt;a href=&quot;#numpy.Inf&quot;&gt; &lt;code&gt;Inf&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#numpy.Infinity&quot;&gt; &lt;code&gt;Infinity&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#numpy.PINF&quot;&gt; &lt;code&gt;PINF&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#numpy.infty&quot;&gt; &lt;code&gt;infty&lt;/code&gt; &lt;/a&gt;是&lt;a href=&quot;#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; 的&lt;/a&gt;别名。有关更多详细信息，请参见&lt;a href=&quot;#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6250a8c021e0b5f57d8def96501e9671eb570fb3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;SeedSequence.spawn&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315e845b90149a11b36b35f1bf0bf7c4eadadf53" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6cd23ceb7d31c81e1ae51bfa02cfeb8d16da6862" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/hawkowl/towncrier&quot;&gt;towncrier&lt;/a&gt; to build the release note and commit the changes. This will remove all the fragments from &lt;code&gt;doc/release/upcoming_changes&lt;/code&gt; and add &lt;code&gt;doc/release/&amp;lt;version&amp;gt;-note.rst&lt;/code&gt;. Note that currently towncrier must be installed from its master branch as the last release (19.2.0) is outdated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239d871fd4cf571322892166220cc9bdd722de95" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;numpy.printoptions#numpy.printoptions&quot;&gt;&lt;code&gt;printoptions&lt;/code&gt;&lt;/a&gt; as a context manager to set the values temporarily.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81e110951d1c31f755b7eda89bda400f45185fe" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt;&lt;code&gt;assert_allclose&lt;/code&gt;&lt;/a&gt; or one of the nulp (number of floating point values) functions for these cases instead:</source>
          <target state="translated">在这些情况下，请使用&lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt; &lt;code&gt;assert_allclose&lt;/code&gt; &lt;/a&gt;或nulp（浮点值的数量）函数之一：</target>
        </trans-unit>
        <trans-unit id="c2c3133adfff844d3d7390f3b12e049c01cfbf85" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;*italics*&lt;/code&gt;, &lt;code&gt;**bold**&lt;/code&gt; and &lt;code&gt;``monospace``&lt;/code&gt; if needed in any explanations (but not for variable names and doctest code or multi-line code). Variable, module, function, and class names should be written between single back-ticks (&lt;code&gt;`numpy`&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f96b961e5f74e075163f17783fa068cb28fd7dac" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Py_BEGIN_ALLOW_THREADS .. Py_END_ALLOW_THREADS&lt;/code&gt; block around the call to Fortran/C function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="279c8e9cb261d8451ee87221b2c4c3c0acff77e2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;atleast1d&lt;/code&gt; explicitly if this behavior is deliberate.</source>
          <target state="translated">如果此行为是故意的， &lt;code&gt;atleast1d&lt;/code&gt; 显式使用atleast1d。</target>
        </trans-unit>
        <trans-unit id="1f3c1a16eb9a2500b8452a8a5360fe793c9d0e80" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;integers(0, np.iinfo(np.int_).max,&lt;/code&gt;&lt;code&gt;endpoint=False)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9990e788a91877bc1314e512b42f5fa96b72afa8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;intent(callback)&lt;/code&gt; in situations where a Fortran/C code assumes that a user implements a function with given prototype and links it to an executable. Don&amp;rsquo;t use &lt;code&gt;intent(callback)&lt;/code&gt; if function appears in the argument list of a Fortran routine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f354d8129891e4371211f7e2b02c3e86182e68" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;np.rec.fromrecords&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;np.rec.fromrecords&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b891c3328df6ed66c13f42757acead75f849207" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;transpose(a, argsort(axes))&lt;/code&gt; to invert the transposition of tensors when using the &lt;code&gt;axes&lt;/code&gt; keyword argument.</source>
          <target state="translated">使用 &lt;code&gt;axes&lt;/code&gt; 关键字参数时 &lt;code&gt;transpose(a, argsort(axes))&lt;/code&gt; 使用transpose（a，argsort（axes））反转张量的转置。</target>
        </trans-unit>
        <trans-unit id="464b9132a697ad83a17ca6141a5f052f243225bc" translate="yes" xml:space="preserve">
          <source>Use AVX512 intrinsic to implement &lt;code&gt;np.exp&lt;/code&gt; when input is &lt;code&gt;np.float64&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54252b83acef1c2d4145831c1849100189007324" translate="yes" xml:space="preserve">
          <source>Use C99 (that is, the standard defined by ISO/IEC 9899:1999).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711cfaf9a47519e9f223142a373928a92e01f581" translate="yes" xml:space="preserve">
          <source>Use C99 complex functions when available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98bf81203a370aca52162542f86441968d5a857b" translate="yes" xml:space="preserve">
          <source>Use a code checker:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e79cdecbdf930a5fc02d963ddb3cee0b341e1836" translate="yes" xml:space="preserve">
          <source>Use an index array to construct a new array from a set of choices.</source>
          <target state="translated">使用一个索引数组从一组选择中构造一个新的数组。</target>
        </trans-unit>
        <trans-unit id="b449716c39e8e2ad1701598e0a781904fd930dad" translate="yes" xml:space="preserve">
          <source>Use boolean indexing to select all rows adding up to an even number. At the same time columns 0 and 2 should be selected with an advanced integer index. Using the &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; function this can be done with:</source>
          <target state="translated">使用布尔索引来选择所有相加为偶数的行。同时，应使用高级整数索引选择第0列和第2列。使用&lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt;函数可以通过以下方式完成：</target>
        </trans-unit>
        <trans-unit id="8f82174ebfd083d8637822ce00a0c4c91588113b" translate="yes" xml:space="preserve">
          <source>Use frompyfunc to add broadcasting to the Python function &lt;code&gt;oct&lt;/code&gt;:</source>
          <target state="translated">使用frompyfunc将广播添加到Python函数 &lt;code&gt;oct&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1985c7d495449d5cb406d70622b9f8f51933acf4" translate="yes" xml:space="preserve">
          <source>Use integers()</source>
          <target state="translated">使用integers()</target>
        </trans-unit>
        <trans-unit id="dc8e632ae2c46f77a697535ec370bf0774d7d3a3" translate="yes" xml:space="preserve">
          <source>Use it inside source generating function to ensure that setup distribution instance has been initialized.</source>
          <target state="translated">在源生成函数中使用它来确保设置分发实例已经初始化。</target>
        </trans-unit>
        <trans-unit id="2ee4c011b47d55b7bfff5ce2a411098048a912df" translate="yes" xml:space="preserve">
          <source>Use numpy data types instead of strings (&lt;code&gt;np.uint8&lt;/code&gt; instead of &lt;code&gt;&quot;uint8&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2623e95742f95738b81e96ff23790e2857ea53b8" translate="yes" xml:space="preserve">
          <source>Use of Special Libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71894ec37f432f11f7de9a5b9b593a7cdf8ac0f3" translate="yes" xml:space="preserve">
          <source>Use of internal buffers</source>
          <target state="translated">内部缓冲器的使用</target>
        </trans-unit>
        <trans-unit id="19e9181ca40527ae40c5f3d764f8d2f436e1e1db" translate="yes" xml:space="preserve">
          <source>Use of special library functions (e.g., random)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375ee90511f8800725237c9c32010dd6bfc434d9" translate="yes" xml:space="preserve">
          <source>Use one of the two predefined instances &lt;code&gt;index_exp&lt;/code&gt; or &lt;a href=&quot;#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt; rather than directly using &lt;code&gt;IndexExpression&lt;/code&gt;.</source>
          <target state="translated">使用两个预定义实例 &lt;code&gt;index_exp&lt;/code&gt; 或&lt;a href=&quot;#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; 之一,&lt;/a&gt;而不是直接使用 &lt;code&gt;IndexExpression&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4baff69e242f9bdf1683765ea1f2508b120d6009" translate="yes" xml:space="preserve">
          <source>Use statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f399bcf7c74a9a9e383f645bfc3f3a24ebea505e" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--f2cmap&lt;/code&gt; command-line option to pass the file name to F2PY. By default, F2PY assumes file name is &lt;code&gt;.f2py_f2cmap&lt;/code&gt; in the current working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563d6ccf41351782f370e56a915df0b3956e26f4" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;buf&lt;/code&gt; keyword.</source>
          <target state="translated">使用 &lt;code&gt;buf&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="6e0dab0efbd30d7f80d43f09e327292cfe0afdb8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;endpoint&lt;/code&gt; kwarg to adjust the inclusion or exclution of the &lt;code&gt;high&lt;/code&gt; interval endpoint</source>
          <target state="translated">使用 &lt;code&gt;endpoint&lt;/code&gt; kwarg调整 &lt;code&gt;high&lt;/code&gt; 间隔端点的包含或排除</target>
        </trans-unit>
        <trans-unit id="1a4a01452f45e746c6cb102d0e1fd6cdbe229239" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;order&lt;/code&gt; keyword to specify a field to use when sorting a structured array:</source>
          <target state="translated">使用 &lt;code&gt;order&lt;/code&gt; 关键字指定对结构化数组进行排序时要使用的字段：</target>
        </trans-unit>
        <trans-unit id="bd1412430a20e73aea7c2107ffe5351cd94a8833" translate="yes" xml:space="preserve">
          <source>Use the following import conventions:</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
