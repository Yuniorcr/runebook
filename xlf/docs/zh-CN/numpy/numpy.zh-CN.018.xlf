<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="58f4a5191b04c275b13b1266e03ae0e69f92c2c1" translate="yes" xml:space="preserve">
          <source>Structured type, two fields: the first field contains an unsigned int, the second an int32:</source>
          <target state="translated">结构化类型,两个字段:第一个字段包含一个无符号int,第二个字段包含一个int32。</target>
        </trans-unit>
        <trans-unit id="ca4456203ca66897ff0941bbafc31276906d7671" translate="yes" xml:space="preserve">
          <source>Structured view(s) of &lt;a href=&quot;numpy.nditer.operands#numpy.nditer.operands&quot;&gt;&lt;code&gt;operands&lt;/code&gt;&lt;/a&gt; in memory, matching the reordered and optimized iterator access pattern. Valid only before the iterator is closed.</source>
          <target state="translated">内存中&lt;a href=&quot;numpy.nditer.operands#numpy.nditer.operands&quot;&gt; &lt;code&gt;operands&lt;/code&gt; &lt;/a&gt;结构化视图，与重新排序和优化的迭代器访问模式匹配。仅在关闭迭代器之前有效。</target>
        </trans-unit>
        <trans-unit id="64b82b877494406e2f3a32e02b06a27f71eea3a4" translate="yes" xml:space="preserve">
          <source>Style Guide for C Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d5cb7a8cd071c4380d4985485547b9c9160ad6" translate="yes" xml:space="preserve">
          <source>Style Guide for Python Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0404cfe2117190faccc065f3c4e76c4322b57e18" translate="yes" xml:space="preserve">
          <source>Stylistic Guidelines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="803fd087e54001bfefdde2c389864825258535d4" translate="yes" xml:space="preserve">
          <source>Sub-arrays always have a C-contiguous memory layout.</source>
          <target state="translated">子数组的内存布局总是C型连续的。</target>
        </trans-unit>
        <trans-unit id="b5f988ec613aba03f62b8fb5c8cfc27a7a1a6d0f" translate="yes" xml:space="preserve">
          <source>Sub-optimal &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (due to repeated path calculation time): ~330ms</source>
          <target state="translated">次优&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;（由于重复的路径计算时间）：〜330ms</target>
        </trans-unit>
        <trans-unit id="fa0a23c0a00071a5375730590cb136590b810c95" translate="yes" xml:space="preserve">
          <source>Subclasses of &lt;code&gt;ndarray&lt;/code&gt; are preserved except for the &amp;lsquo;raw&amp;rsquo; mode. So if &lt;code&gt;a&lt;/code&gt; is of type &lt;code&gt;matrix&lt;/code&gt;, all the return values will be matrices too.</source>
          <target state="translated">除&amp;ldquo;原始&amp;rdquo;模式外，保留 &lt;code&gt;ndarray&lt;/code&gt; 的子类。因此，如果 &lt;code&gt;a&lt;/code&gt; 为 &lt;code&gt;matrix&lt;/code&gt; 类型，则所有返回值也将为矩阵。</target>
        </trans-unit>
        <trans-unit id="a9ce918753c36dd7a183b105790cb0ccc1e3d737" translate="yes" xml:space="preserve">
          <source>Subclassing a &lt;code&gt;numpy.ndarray&lt;/code&gt; is possible but if your goal is to create an array with &lt;em&gt;modified&lt;/em&gt; behavior, as do dask arrays for distributed computation and cupy arrays for GPU-based computation, subclassing is discouraged. Instead, using numpy&amp;rsquo;s &lt;a href=&quot;../user/basics.dispatch#basics-dispatch&quot;&gt;dispatch mechanism&lt;/a&gt; is recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d147ab8047bc6066411af552791a9504b59a189" translate="yes" xml:space="preserve">
          <source>Subclassing a &lt;code&gt;numpy.ndarray&lt;/code&gt; is possible but if your goal is to create an array with &lt;em&gt;modified&lt;/em&gt; behavior, as do dask arrays for distributed computation and cupy arrays for GPU-based computation, subclassing is discouraged. Instead, using numpy&amp;rsquo;s &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.dispatch.html#basics-dispatch&quot;&gt;dispatch mechanism&lt;/a&gt; is recommended.</source>
          <target state="translated">可以对 &lt;code&gt;numpy.ndarray&lt;/code&gt; 进行子类化，但是如果您的目标是创建具有&lt;em&gt;经过修改的&lt;/em&gt;行为的数组（例如，用于分布式计算的dask数组和用于基于GPU的计算的cupy数组），则不建议使用子类化。相反，建议使用numpy的&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.dispatch.html#basics-dispatch&quot;&gt;调度机制&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="272f065bb249898427d153b9ddec706f4a4c8ea8" translate="yes" xml:space="preserve">
          <source>Subclassing and Downstream Compatibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33bc88cf96b41fa0646c461894f505af99f67ac1" translate="yes" xml:space="preserve">
          <source>Subclassing is preserved. This means that if, e.g., the data part of the masked array is a recarray, &lt;a href=&quot;numpy.ma.filled#numpy.ma.filled&quot;&gt;&lt;code&gt;filled&lt;/code&gt;&lt;/a&gt; returns a recarray:</source>
          <target state="translated">子类保留。这意味着，如果，例如，掩蔽阵列的数据部分是一个recarray，&lt;a href=&quot;numpy.ma.filled#numpy.ma.filled&quot;&gt; &lt;code&gt;filled&lt;/code&gt; &lt;/a&gt;返回一个recarray：</target>
        </trans-unit>
        <trans-unit id="dcd026d87f16ab5d865099378d38748e1049d4d8" translate="yes" xml:space="preserve">
          <source>Subclassing ndarray</source>
          <target state="translated">ndarray的子类</target>
        </trans-unit>
        <trans-unit id="b7c286e3d93f3ece394b3827e135e8a12233cdf1" translate="yes" xml:space="preserve">
          <source>Subclassing ndarray is complicated by the fact that new instances of ndarray classes can come about in three different ways. These are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a44ddbc8fd0076edc9e53d1235eba11c7929dc0" translate="yes" xml:space="preserve">
          <source>Subclassing ndarray is relatively simple, but it has some complications compared to other Python objects. On this page we explain the machinery that allows you to subclass ndarray, and the implications for implementing a subclass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f32464b42a864e77739b2bee513b261ea02191" translate="yes" xml:space="preserve">
          <source>Subcommittees</source>
          <target state="translated">Subcommittees</target>
        </trans-unit>
        <trans-unit id="d9952117e8cb53d0fd7ca6ba7d99ad537965d8c9" translate="yes" xml:space="preserve">
          <source>Subdivide &lt;code&gt;int16&lt;/code&gt; into 2 &lt;code&gt;int8&lt;/code&gt;&amp;rsquo;s, called x and y. 0 and 1 are the offsets in bytes:</source>
          <target state="translated">将 &lt;code&gt;int16&lt;/code&gt; 细分为2个 &lt;code&gt;int8&lt;/code&gt; ，分别称为x和y。0和1是字节偏移量：</target>
        </trans-unit>
        <trans-unit id="7cd760711c541e202c788fb098af0b33b391721e" translate="yes" xml:space="preserve">
          <source>Subsequence with trailing zeros removed. If the resulting sequence would be empty, return the first element. The returned sequence may or may not be a view.</source>
          <target state="translated">去掉尾部零的子序列。如果生成的序列为空,返回第一个元素。返回的序列可能是也可能不是视图。</target>
        </trans-unit>
        <trans-unit id="c763109714f2536fc1c4a6c89fdf2646454177e1" translate="yes" xml:space="preserve">
          <source>Substantial portions of this document were adapted from the &lt;a href=&quot;https://github.com/jupyter/governance/blob/master/governance.md&quot;&gt;Jupyter/IPython project&amp;rsquo;s governance document&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259ff26648e77d2b9a5ec16a4f186ec8e1c65753" translate="yes" xml:space="preserve">
          <source>Substitute a polynomial for x and expand the result. Here we substitute p in itself leading to a new polynomial of degree 4 after expansion. If the polynomials are regarded as functions this is composition of functions:</source>
          <target state="translated">将一个多项式代入x,然后展开结果。这里我们将p代入本身,展开后得到一个新的4度多项式。如果将多项式视为函数,这就是函数的组成。</target>
        </trans-unit>
        <trans-unit id="8d18e7a773fc8ec030ec151dbf7cd596c836697a" translate="yes" xml:space="preserve">
          <source>Substitution:</source>
          <target state="translated">Substitution:</target>
        </trans-unit>
        <trans-unit id="976370d3324e5eaaec19ed99a261ec090486b0fa" translate="yes" xml:space="preserve">
          <source>Subtract arguments, element-wise.</source>
          <target state="translated">减去参数,元素方面。</target>
        </trans-unit>
        <trans-unit id="8567fbb4d729f4cd5b7fbe5674c01c465635fa47" translate="yes" xml:space="preserve">
          <source>Subtract one Chebyshev series from another.</source>
          <target state="translated">从另一个切比雪夫数列中减去一个。</target>
        </trans-unit>
        <trans-unit id="a494f472ea255a2aaa4f1c8f52b90c62196690f5" translate="yes" xml:space="preserve">
          <source>Subtract one Hermite series from another.</source>
          <target state="translated">从另一个Hermite系列中减去一个。</target>
        </trans-unit>
        <trans-unit id="60b31c93b32c6d82ec367e99b58e2a7fd1690435" translate="yes" xml:space="preserve">
          <source>Subtract one Laguerre series from another.</source>
          <target state="translated">从另一个Laguerre系列中减去一个。</target>
        </trans-unit>
        <trans-unit id="09477810015d786e3a1ce0d9827bfd9d00039de6" translate="yes" xml:space="preserve">
          <source>Subtract one Legendre series from another.</source>
          <target state="translated">从另一个Legendre系列中减去一个。</target>
        </trans-unit>
        <trans-unit id="a2407a57a6647eba13b915586134c7e1d7534217" translate="yes" xml:space="preserve">
          <source>Subtract one polynomial from another.</source>
          <target state="translated">用一个多项式减去另一个多项式。</target>
        </trans-unit>
        <trans-unit id="5de67be97d964e12a293477e154e8fa146741938" translate="yes" xml:space="preserve">
          <source>Subtract other from self in-place.</source>
          <target state="translated">从自己身上原地减去其他。</target>
        </trans-unit>
        <trans-unit id="b3957443ea74659d4523c7bc9e466d304ba155cf" translate="yes" xml:space="preserve">
          <source>Subtract other from self, and return a new masked array.</source>
          <target state="translated">从self中减去other,并返回一个新的掩码数组。</target>
        </trans-unit>
        <trans-unit id="6cf676697a4c117ec3074a618da8a2b0fca9cd14" translate="yes" xml:space="preserve">
          <source>Subtract self from other, and return a new masked array.</source>
          <target state="translated">从other中减去self,并返回一个新的掩码数组。</target>
        </trans-unit>
        <trans-unit id="77a74ccf7fd60ada9c57d2300edad576a2eb6285" translate="yes" xml:space="preserve">
          <source>Subtyping the ndarray in C</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b818b7784e48b243d98be89f763b62cb9fc7bd" translate="yes" xml:space="preserve">
          <source>Successfully tested on:</source>
          <target state="translated">成功测试上。</target>
        </trans-unit>
        <trans-unit id="7f477dc5121884706ef8fed21e4d11c24e6db091" translate="yes" xml:space="preserve">
          <source>Sum across array propagating NaNs.</source>
          <target state="translated">整个阵列传播NaNs的总和。</target>
        </trans-unit>
        <trans-unit id="b2cc82eaee79a7562889de3502bb827b013693aa" translate="yes" xml:space="preserve">
          <source>Sum along diagonals.</source>
          <target state="translated">沿对角线求和。</target>
        </trans-unit>
        <trans-unit id="b221abad8e52361732192c7acb9613f67b076ac3" translate="yes" xml:space="preserve">
          <source>Sum array elements.</source>
          <target state="translated">数组元素之和。</target>
        </trans-unit>
        <trans-unit id="96c00e26cd369dd11b081a1035d4633225e7965d" translate="yes" xml:space="preserve">
          <source>Sum of array elements over a given axis.</source>
          <target state="translated">给定轴上的数组元素之和。</target>
        </trans-unit>
        <trans-unit id="6302a8aa98d30db8a3e7186cb73eb9e4337d618b" translate="yes" xml:space="preserve">
          <source>Sum over an axis (requires explicit form):</source>
          <target state="translated">在一个轴上求和(需要明确的形式)。</target>
        </trans-unit>
        <trans-unit id="1c979daf2b6e4cef98bd537ad236de258dbc0d5a" translate="yes" xml:space="preserve">
          <source>Sum over axes 0 and 2. The result has same number of dimensions as the original array:</source>
          <target state="translated">在0轴和2轴上求和。结果与原数组的维数相同。</target>
        </trans-unit>
        <trans-unit id="1103f1f7acbd2c5b9349bcbddbb45121fae537eb" translate="yes" xml:space="preserve">
          <source>Sum products over arbitrary axes.</source>
          <target state="translated">在任意轴上求积。</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="bf661fd6213ae079ce34c2c9dd00db526c359e2b" translate="yes" xml:space="preserve">
          <source>Sums of residuals; squared Euclidean 2-norm for each column in &lt;code&gt;b - a*x&lt;/code&gt;. If the rank of &lt;code&gt;a&lt;/code&gt; is &amp;lt; N or M &amp;lt;= N, this is an empty array. If &lt;code&gt;b&lt;/code&gt; is 1-dimensional, this is a (1,) shape array. Otherwise the shape is (K,).</source>
          <target state="translated">残差之和； &lt;code&gt;b - a*x&lt;/code&gt; 每一列的平方欧几里德2-范数。如果秩 &lt;code&gt;a&lt;/code&gt; 是&amp;lt;N或M &amp;lt;= N，这是一个空数组。如果 &lt;code&gt;b&lt;/code&gt; 为一维，则为（1，）形状数组。否则，形状为（K，）。</target>
        </trans-unit>
        <trans-unit id="b6c71b95244ccde5ac8df906b9633b9278b04563" translate="yes" xml:space="preserve">
          <source>Sums, products, differences</source>
          <target state="translated">总和、产品、差异</target>
        </trans-unit>
        <trans-unit id="56cedb0b6384ebe895f048d3113a97e19adce9ed" translate="yes" xml:space="preserve">
          <source>SunOS 5.9, Python 2.2, 2.3.2</source>
          <target state="translated">SunOS 5.9,Python 2.2,2.3.2.</target>
        </trans-unit>
        <trans-unit id="67fd60fec12a23f41f4967a1b913d9c8325a3d58" translate="yes" xml:space="preserve">
          <source>Superposes arrays fields by fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f3a3e0dca6bfb201866f4e02f7f0f252f0503d" translate="yes" xml:space="preserve">
          <source>Supplying additional compiler flags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd465d5e53c115d109beacd89675429e7fe9e2eb" translate="yes" xml:space="preserve">
          <source>Support for 64-bit OpenBLAS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05979ff1799bf4b31c7aaaf6575b3a44600e6938" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;decimal.Decimal&lt;/code&gt; in &lt;code&gt;np.lib.financial&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94bf5963bbdc6b1a3677d96a194c63df08cc0ebe" translate="yes" xml:space="preserve">
          <source>Support for PGI flang compiler on Windows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dcbec54e843ff9113eeef63ba5ba94427429af2" translate="yes" xml:space="preserve">
          <source>Support for cross-platform builds for iOS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4312602ded392453d6506535641b2fe8fc3f434" translate="yes" xml:space="preserve">
          <source>Support for linear algebra on stacked arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1486bb007dde41a6cd27d40051180a9824cbf65" translate="yes" xml:space="preserve">
          <source>Support for median and percentile in nanfunctions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5732c875d678ed7bc376f8bdb01c865cd0e57b5f" translate="yes" xml:space="preserve">
          <source>Support for multiple insertions when &lt;code&gt;obj&lt;/code&gt; is a single scalar or a sequence with one element (similar to calling insert multiple times).</source>
          <target state="translated">当 &lt;code&gt;obj&lt;/code&gt; 是单个标量或具有一个元素的序列时，支持多次插入（类似于多次调用insert）。</target>
        </trans-unit>
        <trans-unit id="4c2c6be525f6d9a610c57848f9ef0612672209f9" translate="yes" xml:space="preserve">
          <source>Support for reading lzma compressed text files in Python 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ebd340f9cd250715efd00bc82361318ecaf77c" translate="yes" xml:space="preserve">
          <source>Support for returning arrays of arbitrary dimensions in &lt;code&gt;apply_along_axis&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d5e2188fd70bec3fdf433ddaeea9f504cb04b41" translate="yes" xml:space="preserve">
          <source>Support for the &amp;lsquo;@&amp;rsquo; operator in Python 3.5+</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96793ccd7b743fcb4b68f47fc4a80f55eade2824" translate="yes" xml:space="preserve">
          <source>Support for the &lt;strong&gt;Yields&lt;/strong&gt; section was added in &lt;a href=&quot;https://github.com/numpy/numpydoc&quot;&gt;numpydoc&lt;/a&gt; version 0.6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="729714232faf9c660ac35de89eac7db896893cb6" translate="yes" xml:space="preserve">
          <source>Support for tracemalloc in Python 3.6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08bf3021612bda0edd29ed3bce556141bfaab8f8" translate="yes" xml:space="preserve">
          <source>Support of object arrays in &lt;code&gt;matmul&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="738f921dd6d285f914885c453cfc677ad8fc0e6b" translate="yes" xml:space="preserve">
          <source>Support path-like objects for more functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d95257e0d6b5ee52701ed6e60955d7b5cf2355f" translate="yes" xml:space="preserve">
          <source>Supported BitGenerators</source>
          <target state="translated">支持的位元发生器</target>
        </trans-unit>
        <trans-unit id="35d1294934e4cc4b101779bccdbe627fdf3b5b49" translate="yes" xml:space="preserve">
          <source>Supported platforms and versions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090678b79c24d0799aa7434df5ba4e013c0ea2ff" translate="yes" xml:space="preserve">
          <source>Supports Fortran-contiguous arrays directly.</source>
          <target state="translated">直接支持Fortran连续数组。</target>
        </trans-unit>
        <trans-unit id="62c4a407a3644c899b58964ef70d8d5ea099dfdd" translate="yes" xml:space="preserve">
          <source>Supports full broadcasting of the inputs.</source>
          <target state="translated">支持输入的全部广播。</target>
        </trans-unit>
        <trans-unit id="12f46de9102cae348756a951378fba972f726b07" translate="yes" xml:space="preserve">
          <source>Supports rolling over multiple dimensions simultaneously.</source>
          <target state="translated">支持同时在多个尺寸上滚动。</target>
        </trans-unit>
        <trans-unit id="c531221221ae570c082e108201b731a1c902860f" translate="yes" xml:space="preserve">
          <source>Supports the method &lt;a href=&quot;generated/numpy.random.pcg64.advance#numpy.random.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt; to advance the RNG an arbitrary number of steps. The state of the PCG-64 RNG is represented by 2 128-bit unsigned integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97b0cce7cf0a1a8ea78834b26b7eaa1e93207d9" translate="yes" xml:space="preserve">
          <source>Supports the method &lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt; to advance the RNG an arbitrary number of steps. The state of the PCG-64 RNG is represented by 2 128-bit unsigned integers.</source>
          <target state="translated">支持方法&lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt; &lt;code&gt;advance&lt;/code&gt; &lt;/a&gt;将RNG前进任意步数。PCG-64 RNG的状态由2个128位无符号整数表示。</target>
        </trans-unit>
        <trans-unit id="34c5f00d14223115d609ab63804b8bf6dbd38059" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;x.shape&lt;/code&gt; is (10,20,30) and &lt;code&gt;ind&lt;/code&gt; is a (2,3,4)-shaped indexing &lt;code&gt;intp&lt;/code&gt; array, then &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; has shape (10,2,3,4,30) because the (20,)-shaped subspace has been replaced with a (2,3,4)-shaped broadcasted indexing subspace. If we let &lt;em&gt;i, j, k&lt;/em&gt; loop over the (2,3,4)-shaped subspace then &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt;. This example produces the same result as &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">假设 &lt;code&gt;x.shape&lt;/code&gt; 为（10,20,30）并且 &lt;code&gt;ind&lt;/code&gt; 为（2,3,4）形索引 &lt;code&gt;intp&lt;/code&gt; 数组，则 &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; 形状为（10,2,3 ，4,30），因为（20，）形状的子空间已被（2,3,4）形状的广播索引子空间替换。如果我们让&lt;em&gt;i，j，k&lt;/em&gt;在（2,3,4）形子空间上循环，则 &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt; 。本示例产生的结果与&lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt; &lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab6e03b971eeb9906907892d695f98f70c00c465" translate="yes" xml:space="preserve">
          <source>Suppose I have two files coolmodule.c and coolhelper.c which need to be compiled and linked into a single extension module. Suppose coolmodule.c contains the required initcool module initialization function (with the import_array() function called). Then, coolmodule.c would have at the top:</source>
          <target state="translated">假设我有两个文件coolmodule.c和coolhelper.c,它们需要被编译并链接到一个扩展模块中。假设coolmodule.c包含所需的initcool模块初始化函数(调用import_array()函数)。那么,coolmodule.c的顶部就会有以下内容。</target>
        </trans-unit>
        <trans-unit id="1a06be2cc716b778d6a1c32b124922e42d2cce52" translate="yes" xml:space="preserve">
          <source>Suppose now that we wish to print that same data, but with the missing values replaced by the average value.</source>
          <target state="translated">假设现在我们想打印同样的数据,但用平均值代替缺失值。</target>
        </trans-unit>
        <trans-unit id="c30e0906e4415225d057040ed0740bd62f0ab08e" translate="yes" xml:space="preserve">
          <source>Suppose that the commit history looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dca6dc181cc53601add013bc2ada72709458943" translate="yes" xml:space="preserve">
          <source>Suppose the first operand is one dimensional and the second operand is two dimensional. The iterator will have three dimensions, so &lt;code&gt;op_axes&lt;/code&gt; will have two 3-element lists. The first list picks out the one axis of the first operand, and is -1 for the rest of the iterator axes, with a final result of [0, -1, -1]. The second list picks out the two axes of the second operand, but shouldn&amp;rsquo;t overlap with the axes picked out in the first operand. Its list is [-1, 0, 1]. The output operand maps onto the iterator axes in the standard manner, so we can provide None instead of constructing another list.</source>
          <target state="translated">假设第一个操作数是一维的，第二个操作数是二维的。迭代器将具有三个维度，因此 &lt;code&gt;op_axes&lt;/code&gt; 将具有两个3元素列表。第一个列表挑选出第一个操作数的一个轴，其余迭代器轴为-1，最终结果为[0，-1，-1]。第二个列表选择第二个操作数的两个轴，但不应与第一个操作数中选择的轴重叠。它的列表是[-1，0，1]。输出操作数以标准方式映射到迭代器轴，因此我们可以提供None而不是构造另一个列表。</target>
        </trans-unit>
        <trans-unit id="ffbff519fe81519b5859278de1db83d3776384bb" translate="yes" xml:space="preserve">
          <source>Suppose you have a SciPy module &lt;code&gt;scipy/xxx/yyy.py&lt;/code&gt; containing a function &lt;code&gt;zzz()&lt;/code&gt;. To test this function you would create a test module called &lt;code&gt;test_yyy.py&lt;/code&gt;. If you only need to test one aspect of &lt;code&gt;zzz&lt;/code&gt;, you can simply add a test function:</source>
          <target state="translated">假设你有一个SciPy的模块 &lt;code&gt;scipy/xxx/yyy.py&lt;/code&gt; 包含函数 &lt;code&gt;zzz()&lt;/code&gt; 。要测试此功能，您将创建一个名为 &lt;code&gt;test_yyy.py&lt;/code&gt; 的测试模块。如果只需要测试 &lt;code&gt;zzz&lt;/code&gt; 的一个方面，则只需添加一个测试功能即可：</target>
        </trans-unit>
        <trans-unit id="561e62ec5d03ac50c21e0a257548d3eb990ac028" translate="yes" xml:space="preserve">
          <source>Suppose you have an urn with 15 white and 15 black marbles. If you pull 15 marbles at random, how likely is it that 12 or more of them are one color?</source>
          <target state="translated">假设你有一个瓮,里面有15个白色和15个黑色的弹珠。如果你随机抽取15个弹珠,那么其中12个或更多的弹珠是一种颜色的可能性有多大?</target>
        </trans-unit>
        <trans-unit id="7c7cd36a0c21d430e2827a371600cad0b35b80b7" translate="yes" xml:space="preserve">
          <source>Suppress the rows and/or columns of a 2-D array that contain masked values.</source>
          <target state="translated">抑制包含屏蔽值的二维数组的行和/或列。</target>
        </trans-unit>
        <trans-unit id="00f54cf02ad98c4bd3014ede43830053636d4545" translate="yes" xml:space="preserve">
          <source>Suppress whole columns of a 2-D array that contain masked values.</source>
          <target state="translated">抑制包含屏蔽值的二维数组的整列。</target>
        </trans-unit>
        <trans-unit id="685b0c43425911b6f904fe6d170e96c0345d4cbf" translate="yes" xml:space="preserve">
          <source>Suppress whole rows of a 2-D array that contain masked values.</source>
          <target state="translated">抑制包含屏蔽值的二维数组的整行。</target>
        </trans-unit>
        <trans-unit id="b11d9a95741366c39b17b9d4fd94445d808b15b4" translate="yes" xml:space="preserve">
          <source>Swap the bytes of the array elements</source>
          <target state="translated">交换数组元素的字节</target>
        </trans-unit>
        <trans-unit id="bbdcf90ffec6f9d47a9ac51cf19b00a93a140fa9" translate="yes" xml:space="preserve">
          <source>Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned.</source>
          <target state="translated">决定返回值性质的开关。当为False(默认)时,只返回系数,当为True时,也会返回奇异值分解的诊断信息。</target>
        </trans-unit>
        <trans-unit id="6b3384dea957229bd45073ab4c8cae823f791969" translate="yes" xml:space="preserve">
          <source>Switch determining the nature of the return value. When &lt;code&gt;False&lt;/code&gt; (the default) just the coefficients are returned; when &lt;code&gt;True&lt;/code&gt;, diagnostic information from the singular value decomposition (used to solve the fit&amp;rsquo;s matrix equation) is also returned.</source>
          <target state="translated">开关确定返回值的性质。如果为 &lt;code&gt;False&lt;/code&gt; （默认值），则仅返回系数。如果为 &lt;code&gt;True&lt;/code&gt; ，则还返回来自奇异值分解（用于求解拟合矩阵方程）的诊断信息。</target>
        </trans-unit>
        <trans-unit id="7af38070c59fd5383f5319f90871324cb011240a" translate="yes" xml:space="preserve">
          <source>System Entropy</source>
          <target state="translated">熵系统</target>
        </trans-unit>
        <trans-unit id="1b1430441b7b7dd5a90d83f42f914deacc5fd0e5" translate="yes" xml:space="preserve">
          <source>System configuration</source>
          <target state="translated">系统配置</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="29f1b70dfc7cd7e2755985e321ea4063c37e7f58" translate="yes" xml:space="preserve">
          <source>T (numpy.char.chararray attribute)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08fb6d4b20d17768263265c26a0d6392cfb83ed1" translate="yes" xml:space="preserve">
          <source>T() (numpy.ma.masked_array property)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="494db6c744e0093634443456957eafcc51937e81" translate="yes" xml:space="preserve">
          <source>THE RESULTING LOGIT FUNCTION IS NOT FAST! numpy.vectorize simply loops over spam.logit. The loop is done at the C level, but the numpy array is constantly being parsed and build back up. This is expensive. When the author compared numpy.vectorize(spam.logit) against the logit ufuncs constructed below, the logit ufuncs were almost exactly 4 times faster. Larger or smaller speedups are, of course, possible depending on the nature of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d06ee651a160babb28eda47548bd9fad2ca6df2" translate="yes" xml:space="preserve">
          <source>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &amp;ldquo;AS IS&amp;rdquo; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0d354392fe3fc9d2a5d83e7fd5a6f24a2b815a" translate="yes" xml:space="preserve">
          <source>TODO: Maybe it would be better to introduce a function &lt;code&gt;NpyIter_GetWrappedOutput&lt;/code&gt; and remove this flag?</source>
          <target state="translated">TODO：也许最好引入一个函数 &lt;code&gt;NpyIter_GetWrappedOutput&lt;/code&gt; 并删除该标志？</target>
        </trans-unit>
        <trans-unit id="c398f641b79127cbb5368a052c9c18ee4b191edd" translate="yes" xml:space="preserve">
          <source>TODO: This feature can be easily extended for Fortran 90 codes as well. Let us know if you would need such a feature.</source>
          <target state="translated">TODO:这个功能也可以很容易地扩展到Fortran 90代码。如果您需要这一功能,请告诉我们。</target>
        </trans-unit>
        <trans-unit id="8cfd932f7721749006331a6f950d4068e186ddf4" translate="yes" xml:space="preserve">
          <source>Table of Rough MATLAB-NumPy Equivalents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e0fad2c7303a14e3d40f2816778e4a945515d7" translate="yes" xml:space="preserve">
          <source>Tag the release</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2bf59208074c19e062d597b69c91e24c1b3f65d" translate="yes" xml:space="preserve">
          <source>Take a sequence of 1-D arrays and stack them as columns to make a single 2-D array. 2-D arrays are stacked as-is, just like with &lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;. 1-D arrays are turned into 2-D columns first.</source>
          <target state="translated">采取一系列一维数组并将其堆叠为列以构成单个二维数组。二维数组按原样堆叠，就像使用&lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; 一样&lt;/a&gt;。首先将一维数组转换为二维列。</target>
        </trans-unit>
        <trans-unit id="a7063ff9c282b69776d4b6c1965ce5cc8d3d21f1" translate="yes" xml:space="preserve">
          <source>Take a sequence of 1-D arrays and stack them as columns to make a single 2-D array. 2-D arrays are stacked as-is, just like with &lt;a href=&quot;numpy.ma.hstack#numpy.ma.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;. 1-D arrays are turned into 2-D columns first.</source>
          <target state="translated">采取一系列一维数组并将其堆叠为列以构成单个二维数组。二维数组按原样堆叠，就像使用&lt;a href=&quot;numpy.ma.hstack#numpy.ma.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; 一样&lt;/a&gt;。首先将一维数组转换为二维列。</target>
        </trans-unit>
        <trans-unit id="948650b27c1b2b9784a79436cafe48d7d653c938" translate="yes" xml:space="preserve">
          <source>Take along an axis, using the same indices for every 1d slice</source>
          <target state="translated">沿着轴线,对每一个1d的片子使用相同的指数。</target>
        </trans-unit>
        <trans-unit id="750d821c9fa304621f4be0f3b88564bf9278e152" translate="yes" xml:space="preserve">
          <source>Take elements by matching the array and the index arrays</source>
          <target state="translated">通过匹配数组和索引数组来获取元素。</target>
        </trans-unit>
        <trans-unit id="e11fd16230a195030272e04871b014d038eef9ab" translate="yes" xml:space="preserve">
          <source>Take elements from an array along an axis.</source>
          <target state="translated">从一个数组中沿轴取元素。</target>
        </trans-unit>
        <trans-unit id="2bd0abec8d18fb4f628e5467a962eaf329bb6905" translate="yes" xml:space="preserve">
          <source>Take elements using a boolean mask</source>
          <target state="translated">使用布尔掩码获取元素</target>
        </trans-unit>
        <trans-unit id="b8cd92f0049ea13b3db726f84fc3411287caeddf" translate="yes" xml:space="preserve">
          <source>Take the fields dictionary, &lt;em&gt;dict&lt;/em&gt;, such as the one attached to a data-type object and construct an ordered-list of field names such as is stored in the names field of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">拿字段字典&lt;em&gt;dict&lt;/em&gt;（例如附加到数据类型对象的字典），构造字段名称的有序列表，例如存储在&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;对象的names字段中。</target>
        </trans-unit>
        <trans-unit id="8588b385cd332763c111b95b02976dcd4b8a50f6" translate="yes" xml:space="preserve">
          <source>Take the fields dictionary, &lt;em&gt;dict&lt;/em&gt;, such as the one attached to a data-type object and construct an ordered-list of field names such as is stored in the names field of the &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="673397230d0da22f7147b4eeece871fd1294c5ff" translate="yes" xml:space="preserve">
          <source>Take values from the input array by matching 1d index and data slices</source>
          <target state="translated">通过匹配1d索引和数据片,从输入数组中取值。</target>
        </trans-unit>
        <trans-unit id="7f4b8f1ca46302f3d1aba5fbdc3749dad60f0480" translate="yes" xml:space="preserve">
          <source>Take values from the input array by matching 1d index and data slices.</source>
          <target state="translated">通过匹配1d索引和数据片从输入数组中取值。</target>
        </trans-unit>
        <trans-unit id="567aaaa85050a78f736c937e4e349477825e7c6c" translate="yes" xml:space="preserve">
          <source>Takes an arbitrary Python function and returns a NumPy ufunc.</source>
          <target state="translated">读取一个任意的Python函数并返回一个NumPy ufunc。</target>
        </trans-unit>
        <trans-unit id="ad884a5ab2796ce61beab25497caa48a0c350a18" translate="yes" xml:space="preserve">
          <source>Takes an arbitrary Python function and returns a ufunc</source>
          <target state="translated">读取一个任意的Python函数并返回一个ufunc。</target>
        </trans-unit>
        <trans-unit id="4fe8421f7b4bac2910c2919a03e01d32f910e006" translate="yes" xml:space="preserve">
          <source>Taking an example cited in Wikipedia, this distribution can be used if one wanted to cut strings (each of initial length 1.0) into K pieces with different lengths, where each piece had, on average, a designated average length, but allowing some variation in the relative sizes of the pieces.</source>
          <target state="translated">以维基百科中引用的一个例子为例,如果想把字符串(每个初始长度为1.0)切割成K个不同长度的片段,其中每个片段平均有一个指定的平均长度,但允许片段的相对大小有一些变化,就可以使用这种分布。</target>
        </trans-unit>
        <trans-unit id="a8980c440e8f502e5c59dc6cdcc36215481bcc7e" translate="yes" xml:space="preserve">
          <source>Taking no further action</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1237aaefe517f485a7a53e6bb8a3bb8a86a6a4" translate="yes" xml:space="preserve">
          <source>Target array.</source>
          <target state="translated">目标阵列:</target>
        </trans-unit>
        <trans-unit id="51038a1a794fec6114fafbb47a8bce902f23294f" translate="yes" xml:space="preserve">
          <source>Target indices, interpreted as integers.</source>
          <target state="translated">目标指数,解释为整数。</target>
        </trans-unit>
        <trans-unit id="695f8bb0287f4fc300e17fa93e5262f0b53e9bb1" translate="yes" xml:space="preserve">
          <source>Temporary directories are deleted when the DataSource is deleted.</source>
          <target state="translated">当DataSource被删除时,临时目录会被删除。</target>
        </trans-unit>
        <trans-unit id="b3d2d960e69084c198868bb0c51081b279e6d57d" translate="yes" xml:space="preserve">
          <source>Temporary elision</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6701dda5ea2a62c52d8395d7a5c8f390a0ab64df" translate="yes" xml:space="preserve">
          <source>Tensor contraction:</source>
          <target state="translated">张量收缩。</target>
        </trans-unit>
        <trans-unit id="7e786b6ecaa33c3bfa2a663250579b348bbb6678" translate="yes" xml:space="preserve">
          <source>Tensor contractions, &lt;a href=&quot;numpy.tensordot#numpy.tensordot&quot;&gt;&lt;code&gt;numpy.tensordot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">张量收缩&lt;a href=&quot;numpy.tensordot#numpy.tensordot&quot;&gt; &lt;code&gt;numpy.tensordot&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8aa53899fcc2f4722e3aaa13b02a9f0c21a58b0c" translate="yes" xml:space="preserve">
          <source>Tensor to &amp;lsquo;invert&amp;rsquo;. Its shape must be &amp;lsquo;square&amp;rsquo;, i. e., &lt;code&gt;prod(a.shape[:ind]) == prod(a.shape[ind:])&lt;/code&gt;.</source>
          <target state="translated">张量&amp;ldquo;反转&amp;rdquo;。它的形状必须为&amp;ldquo;正方形&amp;rdquo;，即 &lt;code&gt;prod(a.shape[:ind]) == prod(a.shape[ind:])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a7912060e7ae8d981d410c16692b658bc5a8653" translate="yes" xml:space="preserve">
          <source>Tensors to &amp;ldquo;dot&amp;rdquo;.</source>
          <target state="translated">张量为&amp;ldquo;点&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="71218d40834bc4913fe2fbb95e52de19a584b43a" translate="yes" xml:space="preserve">
          <source>Test Running</source>
          <target state="translated">测试运行</target>
        </trans-unit>
        <trans-unit id="2ec99dbb44d0090912e3c4ddf71222f3cee61914" translate="yes" xml:space="preserve">
          <source>Test Support (&lt;code&gt;numpy.testing&lt;/code&gt;)</source>
          <target state="translated">测试支持（ &lt;code&gt;numpy.testing&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c35554b04739c6c6869f7c83d9841e0dda4c5073" translate="yes" xml:space="preserve">
          <source>Test Support (numpy.testing)</source>
          <target state="translated">测试支持 (numpy.testing)</target>
        </trans-unit>
        <trans-unit id="a0b0d520e3181fa7765d42a80050b97cb70dbe30" translate="yes" xml:space="preserve">
          <source>Test coverage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59afddee1692b59da457c30d92a5b65f5e31115a" translate="yes" xml:space="preserve">
          <source>Test element-wise for NaN and return result as a boolean array.</source>
          <target state="translated">对NaN进行逐元素测试,并以布尔数组形式返回结果。</target>
        </trans-unit>
        <trans-unit id="ed391a308f11ca7f40c17a765e9b20cc4e1035a2" translate="yes" xml:space="preserve">
          <source>Test element-wise for NaT (not a time) and return result as a boolean array.</source>
          <target state="translated">对NaT(不是时间)进行元素测试,并以布尔数组的形式返回结果。</target>
        </trans-unit>
        <trans-unit id="9f34997c659f4457d18a667e13e9b54ff7ea7b5d" translate="yes" xml:space="preserve">
          <source>Test element-wise for finiteness (not infinity or not Not a Number).</source>
          <target state="translated">从元素上测试有限性(不是无穷大,也不是Not a Number)。</target>
        </trans-unit>
        <trans-unit id="b73482f0dd7c13ea3e95362c875b37244def5b6c" translate="yes" xml:space="preserve">
          <source>Test element-wise for negative infinity, return result as bool array.</source>
          <target state="translated">逐元素测试负无穷大,返回结果为bool数组。</target>
        </trans-unit>
        <trans-unit id="f441420173d81baeaa59a4fb443d5293972df75a" translate="yes" xml:space="preserve">
          <source>Test element-wise for positive infinity, return result as bool array.</source>
          <target state="translated">逐元素测试是否为正无穷大,返回结果为bool数组。</target>
        </trans-unit>
        <trans-unit id="f76286ad13fcd1d6939365b38ad9443c5711054b" translate="yes" xml:space="preserve">
          <source>Test element-wise for positive or negative infinity.</source>
          <target state="translated">从元素上检验正负无穷大。</target>
        </trans-unit>
        <trans-unit id="a54ae1b5fd87138bbeb065cc5056362be6e773bd" translate="yes" xml:space="preserve">
          <source>Test if &lt;code&gt;path&lt;/code&gt; exists as (and in this order):</source>
          <target state="translated">测试 &lt;code&gt;path&lt;/code&gt; 存在（以该顺序）：</target>
        </trans-unit>
        <trans-unit id="6db21c53daecd81068cb27c5716c17cf9ec8f853" translate="yes" xml:space="preserve">
          <source>Test if path exists.</source>
          <target state="translated">测试路径是否存在。</target>
        </trans-unit>
        <trans-unit id="ab9c97d91f47360ac72bf2e9386f7b26c75db7d2" translate="yes" xml:space="preserve">
          <source>Test if two strings are equal.</source>
          <target state="translated">测试两个字符串是否相等。</target>
        </trans-unit>
        <trans-unit id="90c99592ef3a4e369f5b8438543a142bc4a6d8c8" translate="yes" xml:space="preserve">
          <source>Test support</source>
          <target state="translated">测试支持</target>
        </trans-unit>
        <trans-unit id="fe6e53750db930a15ff2a9eb0786f6b4b0dd49e8" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;ary&lt;/code&gt; is contiguous. If so, return 1. Otherwise, set a Python error and return 0.</source>
          <target state="translated">测试 &lt;code&gt;ary&lt;/code&gt; 是否连续。如果是，则返回1。否则，设置Python错误并返回0。</target>
        </trans-unit>
        <trans-unit id="e52099e2b541a96f27cc77aa438f266ac05e538f" translate="yes" xml:space="preserve">
          <source>Test whether all array elements along a given axis evaluate to True.</source>
          <target state="translated">测试是否所有沿给定轴的数组元素都为True。</target>
        </trans-unit>
        <trans-unit id="7d4c1c04414d7af36c37c81837979d62019dac75" translate="yes" xml:space="preserve">
          <source>Test whether all elements along a given axis evaluate to True.</source>
          <target state="translated">测试是否所有沿给定轴的元素都为True。</target>
        </trans-unit>
        <trans-unit id="8dcb7ed405671230192b179ae33bab118c7f5996" translate="yes" xml:space="preserve">
          <source>Test whether all matrix elements along a given axis evaluate to True.</source>
          <target state="translated">测试是否所有的矩阵元素沿着给定的轴计算为True。</target>
        </trans-unit>
        <trans-unit id="a8cd365e47952360dc676cadf55d3bc2ecae44b5" translate="yes" xml:space="preserve">
          <source>Test whether any array element along a given axis evaluates to True.</source>
          <target state="translated">测试沿给定轴的任何数组元素是否为True。</target>
        </trans-unit>
        <trans-unit id="e54011a9e26f7c9e97e1ca23a771785990f7e7d4" translate="yes" xml:space="preserve">
          <source>Test whether any element along a given axis evaluates to True.</source>
          <target state="translated">测试沿给定轴的任何元素是否为True。</target>
        </trans-unit>
        <trans-unit id="3c5d24b0586eac0954dbcb6d49897a1641c89d36" translate="yes" xml:space="preserve">
          <source>Test whether each element of a 1-D array is also present in a second array.</source>
          <target state="translated">测试一个一维数组的每个元素是否也存在于第二个数组中。</target>
        </trans-unit>
        <trans-unit id="025a700084bfede250ccd79227b915c047f7f35d" translate="yes" xml:space="preserve">
          <source>Test whether input is an instance of MaskedArray.</source>
          <target state="translated">测试输入是否是MaskedArray的实例。</target>
        </trans-unit>
        <trans-unit id="5904fc9bcfebbe0d053c7cdc88d0d4fdd88cf00c" translate="yes" xml:space="preserve">
          <source>Tester (in module numpy.testing)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="43d2fa7f4fbc625f4df01f08ea6653e49f950cbd" translate="yes" xml:space="preserve">
          <source>Testing Guidelines</source>
          <target state="translated">测试指南</target>
        </trans-unit>
        <trans-unit id="ef9606fae34bdb52d82ad257949ec42aea0b9b12" translate="yes" xml:space="preserve">
          <source>Testing Header Files</source>
          <target state="translated">测试头文件</target>
        </trans-unit>
        <trans-unit id="d322a0e8fe52f19dbe7d5bd52156ee63071b90d8" translate="yes" xml:space="preserve">
          <source>Testing Organization</source>
          <target state="translated">测试机构</target>
        </trans-unit>
        <trans-unit id="e3148b0ff766bdb8347a198898838253aab4da96" translate="yes" xml:space="preserve">
          <source>Testing Python Scripts</source>
          <target state="translated">测试Python脚本</target>
        </trans-unit>
        <trans-unit id="8c3a61a48bb499744371cb7fc30761102d86f229" translate="yes" xml:space="preserve">
          <source>Testing SWIG Interface Files</source>
          <target state="translated">测试SWIG接口文件</target>
        </trans-unit>
        <trans-unit id="34d08d85bddb11f11da76ad84dab43a94d74c7ed" translate="yes" xml:space="preserve">
          <source>Testing Source Files</source>
          <target state="translated">测试源文件</target>
        </trans-unit>
        <trans-unit id="ad0aa0ce3fefa4686bfefac5eb7c9ff2df0a50c6" translate="yes" xml:space="preserve">
          <source>Testing builds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7704b172077f920ddd46d5adbcffe86730e58a19" translate="yes" xml:space="preserve">
          <source>Testing looks for module-level or class-level setup and teardown functions by name; thus:</source>
          <target state="translated">测试按名称查找模块级或类级的设置和拆卸函数;因此。</target>
        </trans-unit>
        <trans-unit id="45ece46e91d1fe305feeee99aed2fad182be7b30" translate="yes" xml:space="preserve">
          <source>Testing the numpy.i Typemaps</source>
          <target state="translated">测试 numpy.i Typemaps</target>
        </trans-unit>
        <trans-unit id="00774e7f83f997b0fda8acccd1c59071701a2ddf" translate="yes" xml:space="preserve">
          <source>Tests can also be run with &lt;code&gt;pytest numpy&lt;/code&gt;, however then the NumPy-specific plugin is not found which causes strange side effects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f86100126c53e2e34ca1a3d91679a3a06b6d132" translate="yes" xml:space="preserve">
          <source>Tests for a module should ideally cover all code in that module, i.e., statement coverage should be at 100%.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417d130b240483956f423e540d6cb689832b6f9e" translate="yes" xml:space="preserve">
          <source>Tests on random data</source>
          <target state="translated">随机数据的测试</target>
        </trans-unit>
        <trans-unit id="f3d72180c504c070f745ad049bd21c11042867d1" translate="yes" xml:space="preserve">
          <source>Tests on random data are good, but since test failures are meant to expose new bugs or regressions, a test that passes most of the time but fails occasionally with no code changes is not helpful. Make the random data deterministic by setting the random number seed before generating it. Use either Python&amp;rsquo;s &lt;code&gt;random.seed(some_number)&lt;/code&gt; or NumPy&amp;rsquo;s &lt;code&gt;numpy.random.seed(some_number)&lt;/code&gt;, depending on the source of random numbers.</source>
          <target state="translated">对随机数据进行测试是好的，但是由于测试失败是为了暴露新的错误或回归，因此在大多数情况下通过但偶尔失败且没有代码更改的测试无济于事。通过在生成随机数种子之前对其进行设置，使随机数据具有确定性。使用Python的 &lt;code&gt;random.seed(some_number)&lt;/code&gt; 或NumPy的 &lt;code&gt;numpy.random.seed(some_number)&lt;/code&gt; ，具体取决于随机数的来源。</target>
        </trans-unit>
        <trans-unit id="927f696caa5bf0529c4f0991bbe8b99afb2fa55b" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float has a value equal to zero. This may be slightly faster than calling npy_half_eq(h, NPY_ZERO).</source>
          <target state="translated">测试半精度的浮点数是否等于零,这比调用npy_half_eq(h,NPY_ZERO)稍快。这可能比调用npy_half_eq(h,NPY_ZERO)稍快。</target>
        </trans-unit>
        <trans-unit id="b3be553d33f0513a6775eaa86f3391147a1aac09" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is a NaN.</source>
          <target state="translated">测试半精度浮点数是否为NaN。</target>
        </trans-unit>
        <trans-unit id="6424a62751d70065c8ad2d16d22d5e29e4d2e45c" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is finite (not NaN or Inf).</source>
          <target state="translated">测试半精度浮点数是否有限(不是NaN或Inf)。</target>
        </trans-unit>
        <trans-unit id="b796fd95ec3aee28c84902e310b3fcc5e87bd087" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is plus or minus Inf.</source>
          <target state="translated">测试半精度浮点数是正还是负Inf。</target>
        </trans-unit>
        <trans-unit id="9cad929af9630184e2ec9f960cd674271afcf718" translate="yes" xml:space="preserve">
          <source>Tests, that send messages to stderr, fail when executed from MSYS prompt because the messages are lost at some point.</source>
          <target state="translated">向stderr发送消息的测试,在MSYS提示下执行时失败,因为消息在某些时候丢失了。</target>
        </trans-unit>
        <trans-unit id="d627254d7ccb3ce266ce9cf0341eff8096cd2a09" translate="yes" xml:space="preserve">
          <source>Texlive (or MikTeX on Windows)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a988a505d4f9bd1f41a57f4c2458a2423baedc7" translate="yes" xml:space="preserve">
          <source>Text files</source>
          <target state="translated">文本文件</target>
        </trans-unit>
        <trans-unit id="4ba343aecd438b7c22876dbbd27f537f09be5607" translate="yes" xml:space="preserve">
          <source>Text formatting options</source>
          <target state="translated">文本格式选项</target>
        </trans-unit>
        <trans-unit id="839b1da5d3ca352faa5ce69a674d5b04a8fa489d" translate="yes" xml:space="preserve">
          <source>Thanks to Yarik Halchenko for this explanation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5219411122630dca47bf818c11bfaef89c8f5266" translate="yes" xml:space="preserve">
          <source>That also takes extra arguments, like &lt;code&gt;--pdb&lt;/code&gt; which drops you into the Python debugger when a test fails or an exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e8faeace432448f3522160a796443560f628f2" translate="yes" xml:space="preserve">
          <source>That can be one of 12 different scalar types: &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;unsigned long long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">那可以是12种不同的标量类型之一：有 &lt;code&gt;signed char&lt;/code&gt; ， &lt;code&gt;unsigned char&lt;/code&gt; ， &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;unsigned short&lt;/code&gt; ， &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;unsigned int&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; ， &lt;code&gt;unsigned long&lt;/code&gt; ， &lt;code&gt;long long&lt;/code&gt; ， &lt;code&gt;unsigned long long&lt;/code&gt; ， &lt;code&gt;float&lt;/code&gt; 和 &lt;code&gt;double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be4b72468f984c83d93633e8f8bf75388e94a047" translate="yes" xml:space="preserve">
          <source>That is a looser test than originally documented, but agrees with what the actual implementation did up to rounding vagaries. An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">这是一个比最初记录的更宽松的测试,但与实际执行的情况一致,直到四舍五入的变化。在形状不匹配或值冲突时,会引发一个异常。与 numpy 中的标准用法不同,NaNs 是像数字一样进行比较的,如果两个对象的 NaNs 在相同的位置,则不会引发断言。</target>
        </trans-unit>
        <trans-unit id="31ca174a88927a9e0e7f8f15283f8ce9b3459f51" translate="yes" xml:space="preserve">
          <source>That is a looser test than originally documented, but agrees with what the actual implementation in &lt;a href=&quot;numpy.testing.assert_array_almost_equal#numpy.testing.assert_array_almost_equal&quot;&gt;&lt;code&gt;assert_array_almost_equal&lt;/code&gt;&lt;/a&gt; did up to rounding vagaries. An exception is raised at conflicting values. For ndarrays this delegates to assert_array_almost_equal</source>
          <target state="translated">这是一个比最初记录的测试宽松的测试，但与&lt;a href=&quot;numpy.testing.assert_array_almost_equal#numpy.testing.assert_array_almost_equal&quot;&gt; &lt;code&gt;assert_array_almost_equal&lt;/code&gt; 中&lt;/a&gt;的实际实现对舍入变幻莫测的结果是一致的。值冲突时会引发异常。对于ndarray，这委托给assert_array_almost_equal</target>
        </trans-unit>
        <trans-unit id="89910f6f21cfa928fbf09ccc006fad6eb4f77601" translate="yes" xml:space="preserve">
          <source>That is, each index specified selects the array corresponding to the rest of the dimensions selected. In the above example, choosing 0 means that the remaining dimension of length 5 is being left unspecified, and that what is returned is an array of that dimensionality and size. It must be noted that the returned array is not a copy of the original, but points to the same values in memory as does the original array. In this case, the 1-D array at the first position (0) is returned. So using a single index on the returned array, results in a single element being returned. That is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9424a0780491d95b42071bfcb7519b4471231e07" translate="yes" xml:space="preserve">
          <source>That solves the problem of returning views of the same type, but now we have a new problem. The machinery of ndarray can set the class this way, in its standard methods for taking views, but the ndarray &lt;code&gt;__new__&lt;/code&gt; method knows nothing of what we have done in our own &lt;code&gt;__new__&lt;/code&gt; method in order to set attributes, and so on. (Aside - why not call &lt;code&gt;obj = subdtype.__new__(...&lt;/code&gt; then? Because we may not have a &lt;code&gt;__new__&lt;/code&gt; method with the same call signature).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5240cf478eeccab2d778da09495ef32dd780cc8" translate="yes" xml:space="preserve">
          <source>That support 74 different argument signatures for each data type, including:</source>
          <target state="translated">这支持每个数据类型的74种不同的论点签名,包括:</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="5c4c1c79691cc97764af36fe5679519dac98f423" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;busday&amp;rdquo; functions can additionally check a list of &amp;ldquo;holiday&amp;rdquo; dates, specific dates that are not valid days.</source>
          <target state="translated">&amp;ldquo; busday&amp;rdquo;功能还可以检查&amp;ldquo;假期&amp;rdquo;列表，这些日期不是有效日期。</target>
        </trans-unit>
        <trans-unit id="b6c70d4694de1c6fa7fc40232e3591d1a1b102a5" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;count&amp;rdquo; algorithm is roughly equivalent to the following numpy code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2e889671201d8619d4999f2673b8d825f07526" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;count&amp;rdquo; algorithm uses a temporary array of integers with length &lt;code&gt;sum(colors)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701df984a45b35c07efc7a2ab11dc3b2d9004e29" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;four quadrant&amp;rdquo; arctan of the angle formed by (&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;) and the positive &lt;code&gt;x&lt;/code&gt;-axis.</source>
          <target state="translated">由（ &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; ）和正 &lt;code&gt;x&lt;/code&gt; 轴形成的角度的&amp;ldquo;四象限&amp;rdquo;反正切。</target>
        </trans-unit>
        <trans-unit id="7af7d8f19766359bdf4ea2069305031d08b0663c" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;marginals&amp;rdquo; algorithm generates a variate by using repeated calls to the univariate hypergeometric sampler. It is roughly equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e5831aa41d1e2f9af8c987044c60e05af0be5f" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;smart way&amp;rdquo; of wrapping Fortran functions, as explained above, is suitable for wrapping (e.g. third party) Fortran codes for which modifications to their source codes are not desirable nor even possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2adc5d4e116d43dd248737cacbfac03ed3ef63f9" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;y-intercept&amp;rdquo; and &amp;ldquo;slope&amp;rdquo; of the line, respectively.</source>
          <target state="translated">线的&amp;ldquo; y截距&amp;rdquo;和&amp;ldquo;斜率&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e4a0235cef14b392c275cecc105837cde82d5723" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;a&amp;rsquo; variable is unstripped from c[1] because whitespace leading.</source>
          <target state="translated">因为空格领先，所以'a'变量未从c [1]中剥离。</target>
        </trans-unit>
        <trans-unit id="bda37a7da4e6885245e567c4fedb24dc646e8a1c" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;out&amp;rsquo; keyword argument is expected to be a tuple with one entry per output (which can be &lt;code&gt;None&lt;/code&gt; for arrays to be allocated by the ufunc). For ufuncs with a single output, passing a single array (instead of a tuple holding a single array) is also valid.</source>
          <target state="translated">关键字'out'参数应为每个输出只有一个条目的元组（对于由ufunc分配的数组，可以为 &lt;code&gt;None&lt;/code&gt; ）。对于具有单个输出的ufunc，传递单个数组（而不是包含单个数组的元组）也是有效的。</target>
        </trans-unit>
        <trans-unit id="db204a13b36f2cf86d7bd1794820137a1ac066ee" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;out&amp;rsquo; keyword argument is expected to be a tuple with one entry per output (which can be None for arrays to be allocated by the ufunc). For ufuncs with a single output, passing a single array (instead of a tuple holding a single array) is also valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34701f78458bf915d5b828bf9386058d6824fbe4" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;per&amp;rsquo; variable represents the periods of the loan. Remember that financial equations start the period count at 1!</source>
          <target state="translated">&amp;ldquo;每&amp;rdquo;变量代表贷款的期限。请记住，财务方程式从1开始计算期间！</target>
        </trans-unit>
        <trans-unit id="cb090179fdd970838b19c1b214a4530cfcd16ee3" translate="yes" xml:space="preserve">
          <source>The (non-conjugated) transpose of the matrix.</source>
          <target state="translated">矩阵的(非共轭)转置。</target>
        </trans-unit>
        <trans-unit id="2c0a3ac18c0e35ff547f3a4005419b0e018f9e8e" translate="yes" xml:space="preserve">
          <source>The 1.6 implementation of datetime does not convert between units correctly.:</source>
          <target state="translated">1.6实现的datetime不能正确转换单位。</target>
        </trans-unit>
        <trans-unit id="f72725eb7318a896f41cd0cf447d8c91f324fb0d" translate="yes" xml:space="preserve">
          <source>The 1.6 implementation of datetime only works correctly for a small subset of arithmetic operations. Here we show some simple cases.:</source>
          <target state="translated">1.6版本的datetime只在一小部分算术运算中正确运行。这里我们展示了一些简单的案例。</target>
        </trans-unit>
        <trans-unit id="887cfe3b8a793575511e5fe48982dbd8c7813d6e" translate="yes" xml:space="preserve">
          <source>The 2-D output array.</source>
          <target state="translated">二维输出阵列。</target>
        </trans-unit>
        <trans-unit id="8d40d72287619706da0622aa60cf9b527faa81be" translate="yes" xml:space="preserve">
          <source>The 24 built-in &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;array scalar type objects&lt;/a&gt; all convert to an associated data-type object. This is true for their sub-classes as well.</source>
          <target state="translated">24个内置&lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;数组标量类型对象&lt;/a&gt;都转换为关联的数据类型对象。他们的子类别也是如此。</target>
        </trans-unit>
        <trans-unit id="3182f1dfa2639174f8b34fe5f092a96393f1cf6d" translate="yes" xml:space="preserve">
          <source>The 64-bit OpenBLAS with &lt;code&gt;64_&lt;/code&gt; symbol suffix is obtained by compiling OpenBLAS with settings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44abfc0b778e06539587a775fdc8b33ee9085231" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; array flags can be &amp;ldquo;calculated&amp;rdquo; from the array object itself. This routine updates one or more of these flags of &lt;em&gt;arr&lt;/em&gt; as specified in &lt;em&gt;flagmask&lt;/em&gt; by performing the required calculation.</source>
          <target state="translated">的&lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;从阵列对象本身阵列标志可&amp;ldquo;计算&amp;rdquo;。此例程通过执行所需的计算来更新标志&lt;em&gt;掩码中&lt;/em&gt;指定的&lt;em&gt;arr&lt;/em&gt;标志中的一个或多个。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5ab1d9e20a833c167142777c07717d8769b7541" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the built-in type of the data-type-descriptor objects used to describe how the bytes comprising the array are to be interpreted. There are 21 statically-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects for the built-in data-types. While these participate in reference counting, their reference count should never reach zero. There is also a dynamic table of user-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects that is also maintained. Once a data-type-descriptor object is &amp;ldquo;registered&amp;rdquo; it should never be deallocated either. The function &lt;a href=&quot;array#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to retrieve a &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object from an enumerated type-number (either built-in or user- defined).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83e501c171dddeb86862ef16beddd704b5bc114a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the built-in type of the data-type-descriptor objects used to describe how the bytes comprising the array are to be interpreted. There are 21 statically-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects for the built-in data-types. While these participate in reference counting, their reference count should never reach zero. There is also a dynamic table of user-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects that is also maintained. Once a data-type-descriptor object is &amp;ldquo;registered&amp;rdquo; it should never be deallocated either. The function &lt;a href=&quot;c-api.array#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to retrieve a &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object from an enumerated type-number (either built-in or user- defined).</source>
          <target state="translated">该&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt;是内置型的数据类型描述符的对象用于描述包含在阵列中的字节是如何被解释。内置数据类型有21个静态定义的&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;对象。尽管这些都参与了参考计数，但它们的参考计数绝不能达到零。还存在一个用户定义的&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;对象的动态表。一旦数据类型描述符对象被&amp;ldquo;注册&amp;rdquo;，它也绝不能被释放。函数&lt;a href=&quot;c-api.array#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt;（&amp;hellip;）可用于从枚举的类型号（内置的或用户定义的）中检索&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="3bd6fb4bf6c794847df919e4e53f9f40e8a12e37" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure is defined so that NumPy and other extension modules can use the rapid array interface protocol. The &lt;code&gt;__array_struct__&lt;/code&gt; method of an object that supports the rapid array interface protocol should return a &lt;code&gt;PyCObject&lt;/code&gt; that contains a pointer to a &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure with the relevant details of the array. After the new array is created, the attribute should be &lt;code&gt;DECREF&lt;/code&gt;&amp;rsquo;d which will free the &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure. Remember to &lt;code&gt;INCREF&lt;/code&gt; the object (whose &lt;code&gt;__array_struct__&lt;/code&gt; attribute was retrieved) and point the base member of the new &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; to this same object. In this way the memory for the array will be managed correctly.</source>
          <target state="translated">该&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;结构被限定为使得NumPy的和其它的扩展模块可以使用快速阵列接口协议。所述 &lt;code&gt;__array_struct__&lt;/code&gt; 的对象的方法，该方法支持快速阵列接口协议应返回 &lt;code&gt;PyCObject&lt;/code&gt; 包含一个指向&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;与阵列的相关细节结构。创建新数组后，该属性应为 &lt;code&gt;DECREF&lt;/code&gt; ，这将释放&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt;结构。记得 &lt;code&gt;INCREF&lt;/code&gt; 对象（其 &lt;code&gt;__array_struct__&lt;/code&gt; 属性被检索）和指向新的基体构件&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;到同一对象。这样，将正确管理阵列的内存。</target>
        </trans-unit>
        <trans-unit id="cd84e3bef1191839ce6ab3739e785dd2e1559188" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; C-structure contains all of the required information for an array. All instances of an ndarray (and its subclasses) will have this structure. For future compatibility, these structure members should normally be accessed using the provided macros. If you need a shorter name, then you can make use of &lt;code&gt;NPY_AO&lt;/code&gt; (deprecated) which is defined to be equivalent to &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; C-结构包含所有用于阵列所需的信息。ndarray（及其子类）的所有实例都将具有此结构。为了将来的兼容性，通常应使用提供的宏来访问这些结构成员。如果您需要一个较短的名称，则可以使用 &lt;code&gt;NPY_AO&lt;/code&gt; （已弃用），其定义与&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;等效。</target>
        </trans-unit>
        <trans-unit id="ef190e5abe2d8e5d647d302d7a90a94792c8ed21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; C-structure contains all of the required information for an array. All instances of an ndarray (and its subclasses) will have this structure. For future compatibility, these structure members should normally be accessed using the provided macros. If you need a shorter name, then you can make use of &lt;code&gt;NPY_AO&lt;/code&gt; (deprecated) which is defined to be equivalent to &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;. Direct access to the struct fields are deprecated. Use the &lt;code&gt;PyArray_*(arr)&lt;/code&gt; form instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d2c044849f6b8be8bb6f06a8ac4ced885f369cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure lies at the heart of the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt;. While it is described here for completeness, it should be considered internal to NumPy and manipulated via &lt;code&gt;PyArrayDescr_*&lt;/code&gt; or &lt;code&gt;PyDataType*&lt;/code&gt; functions and macros. The size of this structure is subject to change across versions of NumPy. To ensure compatibility:</source>
          <target state="translated">该&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;结构熟记于的心脏&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt;。尽管此处出于完整性的目的对其进行了说明，但应将其视为NumPy的内部内容，并通过 &lt;code&gt;PyArrayDescr_*&lt;/code&gt; 或 &lt;code&gt;PyDataType*&lt;/code&gt; 函数和宏进行操作。此结构的大小可能会在NumPy的各个版本中发生变化。为确保兼容性：</target>
        </trans-unit>
        <trans-unit id="2e3e60e01ee7ee0a4514d09bc8a1e601d0467625" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; typeobject implements many of the features of &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyTypeObject&quot;&gt;&lt;code&gt;Python objects&lt;/code&gt;&lt;/a&gt; including the &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_number&quot;&gt;&lt;code&gt;tp_as_number&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence&quot;&gt;&lt;code&gt;tp_as_sequence&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping&quot;&gt;&lt;code&gt;tp_as_mapping&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer&quot;&gt;&lt;code&gt;tp_as_buffer&lt;/code&gt;&lt;/a&gt; interfaces. The &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.richcmpfunc&quot;&gt;&lt;code&gt;rich comparison&lt;/code&gt;&lt;/a&gt;) is also used along with new-style attribute lookup for member (&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_members&quot;&gt;&lt;code&gt;tp_members&lt;/code&gt;&lt;/a&gt;) and properties (&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_getset&quot;&gt;&lt;code&gt;tp_getset&lt;/code&gt;&lt;/a&gt;). The &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; can also be sub-typed.</source>
          <target state="translated">该&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; typeobject实现了许多的功能&lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyTypeObject&quot;&gt; &lt;code&gt;Python objects&lt;/code&gt; &lt;/a&gt;包括&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_number&quot;&gt; &lt;code&gt;tp_as_number&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence&quot;&gt; &lt;code&gt;tp_as_sequence&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping&quot;&gt; &lt;code&gt;tp_as_mapping&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer&quot;&gt; &lt;code&gt;tp_as_buffer&lt;/code&gt; &lt;/a&gt;接口。在&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.richcmpfunc&quot;&gt; &lt;code&gt;rich comparison&lt;/code&gt; &lt;/a&gt;）也与新样式属性查找会员（用于沿&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_members&quot;&gt; &lt;code&gt;tp_members&lt;/code&gt; &lt;/a&gt;）和属性（&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_getset&quot;&gt; &lt;code&gt;tp_getset&lt;/code&gt; &lt;/a&gt;）。该&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;也可以是子类型。</target>
        </trans-unit>
        <trans-unit id="aa6c6f999e9bb42f4a925a834755e66032534d3b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.bitgen_t&quot;&gt;&lt;code&gt;bitgen_t&lt;/code&gt;&lt;/a&gt; holds the current state of the BitGenerator and pointers to functions that return standard C types while advancing the state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f36b5d156bf75520af226984583d62ec445b7c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module provides a set of vectorized string operations for arrays of type &lt;code&gt;numpy.string_&lt;/code&gt; or &lt;code&gt;numpy.unicode_&lt;/code&gt;. All of them are based on the string methods in the Python standard library.</source>
          <target state="translated">所述&lt;a href=&quot;#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;模块提供类型的数组的一组矢量的字符串操作的 &lt;code&gt;numpy.string_&lt;/code&gt; 或 &lt;code&gt;numpy.unicode_&lt;/code&gt; 。它们全部基于Python标准库中的字符串方法。</target>
        </trans-unit>
        <trans-unit id="2314014335c763a38d9f2613dc7158883ea47e7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module can be used as an addition to &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">所述&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt;模块可以被用作除了&lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; 的&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="bc31921d14e06fe1077c1cf00e508c39081a2db7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module comes with a specific implementation of most ufuncs. Unary and binary functions that have a validity domain (such as &lt;a href=&quot;generated/numpy.log#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.divide#numpy.divide&quot;&gt;&lt;code&gt;divide&lt;/code&gt;&lt;/a&gt;) return the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; constant whenever the input is masked or falls outside the validity domain:</source>
          <target state="translated">该&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt;模块配备了一个具体实施最ufuncs的。具有有效域（例如&lt;a href=&quot;generated/numpy.log#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;generated/numpy.divide#numpy.divide&quot;&gt; &lt;code&gt;divide&lt;/code&gt; &lt;/a&gt;）的一元和二进制函数在输入被屏蔽或超出有效域范围时返回&lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;常量：</target>
        </trans-unit>
        <trans-unit id="b2581729cb5a508c4225155bce5e9d0c211d34fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;存在与Numarray向后兼容类，所以不推荐在新的发展。从numpy的1.4开始，如果字符串中的一个需要数组，建议使用数组&lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; ， &lt;code&gt;string_&lt;/code&gt; 或 &lt;code&gt;unicode_&lt;/code&gt; ，以及在使用免费的功能&lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;快速矢量字符串操作模块。</target>
        </trans-unit>
        <trans-unit id="bfd56b98bdff55bc0967f4255e8d608e0cada88c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.char.chararray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.char.chararray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;物可类似于字典的（如在被访问 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ），或通过使用小写属性名称（如在 &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短标志名仅在字典访问中受支持。</target>
        </trans-unit>
        <trans-unit id="5b3e9186bfdffbf3c12bbb5a751b0411b0862a0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;存在与Numarray向后兼容类，所以不推荐在新的发展。从numpy的1.4开始，如果字符串中的一个需要数组，建议使用数组&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; ， &lt;code&gt;string_&lt;/code&gt; 或 &lt;code&gt;unicode_&lt;/code&gt; ，以及在使用免费的功能&lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;快速矢量字符串操作模块。</target>
        </trans-unit>
        <trans-unit id="680a1891b2c8f5bcdb98b3e8673e99320813b4a5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.chararray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c48c115471617c80e93a7432dc970b4f61e8b90" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.MaskedArray.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt;, as a regular &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt; of any shape or datatype (the data).</source>
          <target state="translated">的&lt;a href=&quot;#numpy.ma.MaskedArray.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt;，作为常规&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt;任何形状或数据类型（数据）的。</target>
        </trans-unit>
        <trans-unit id="a0df6452154474f3f899180d65ac301d22c1fea9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.MaskedArray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.ma.MaskedArray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;物可类似于字典的（如在被访问 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ），或通过使用小写属性名称（如在 &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短标志名仅在字典访问中受支持。</target>
        </trans-unit>
        <trans-unit id="768878a0d288c4cac805d022d60e3e5c74cdd571" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; constant is a special case of &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, with a float datatype and a null shape. It is used to test whether a specific entry of a masked array is masked, or to mask one or several entries of a masked array:</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt;常数的特殊情况&lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;，具有float数据类型和一个空的形状。它用于测试是否屏蔽了掩码数组的特定条目，或掩码了掩码数组的一个或多个条目：</target>
        </trans-unit>
        <trans-unit id="7aed7dc2945cfed4e354b7948f5becc4b487bdfa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.masked_array.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146a5b50c3ebb2fb745630d24192949df345a171" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.matrix.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.matrix.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;物可类似于字典的（如在被访问 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ），或通过使用小写属性名称（如在 &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短标志名仅在字典访问中受支持。</target>
        </trans-unit>
        <trans-unit id="3f13797b1afe52954d80b3598ced06b92d07000d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.memmap.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59336961ce31b9039ac38b42d5319606fa0f917b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ndarray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.ndarray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;物可类似于字典的（如在被访问 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ），或通过使用小写属性名称（如在 &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短标志名仅在字典访问中受支持。</target>
        </trans-unit>
        <trans-unit id="6d0bd00bbf169f78d9e7d2f8db44466c1472859d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; provides access to a wide range of distributions, and served as a replacement for &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. The main difference between the two is that &lt;code&gt;Generator&lt;/code&gt; relies on an additional BitGenerator to manage state and generate the random bits, which are then transformed into random values from useful distributions. The default BitGenerator used by &lt;code&gt;Generator&lt;/code&gt; is &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt;. The BitGenerator can be changed by passing an instantized BitGenerator to &lt;code&gt;Generator&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550894140eb6b413b0c8bb49cded0a5d50198b4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; provides access to a wide range of distributions, and served as a replacement for &lt;code&gt;RandomState&lt;/code&gt;. The main difference between the two is that &lt;code&gt;Generator&lt;/code&gt; relies on an additional BitGenerator to manage state and generate the random bits, which are then transformed into random values from useful distributions. The default BitGenerator used by &lt;code&gt;Generator&lt;/code&gt; is &lt;code&gt;PCG64&lt;/code&gt;. The BitGenerator can be changed by passing an instantized BitGenerator to &lt;code&gt;Generator&lt;/code&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;可以访问广泛分布的，并作为一个替换 &lt;code&gt;RandomState&lt;/code&gt; 。两者之间的主要区别在于 &lt;code&gt;Generator&lt;/code&gt; 依赖于附加的BitGenerator来管理状态并生成随机位，然后将这些随机位从有用的分布转换为随机值。 &lt;code&gt;Generator&lt;/code&gt; 使用的默认BitGenerator 为 &lt;code&gt;PCG64&lt;/code&gt; 。可以通过将实例化的BitGenerator传递给 &lt;code&gt;Generator&lt;/code&gt; 来更改BitGenerator 。</target>
        </trans-unit>
        <trans-unit id="f79d27f6e9c849366cec196aa3ca02a3888f3ef3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; provides access to legacy generators. This generator is considered frozen and will have no further improvements. It is guaranteed to produce the same values as the final point release of NumPy v1.16. These all depend on Box-Muller normals or inverse CDF exponentials or gammas. This class should only be used if it is essential to have randoms that are identical to what would have been produced by previous versions of NumPy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a823e24105a263472e6db5aa11ef1abc5d69b0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; provides access to legacy generators. This generator is considered frozen and will have no further improvements. It is guaranteed to produce the same values as the final point release of NumPy v1.16. These all depend on Box-Muller normals or inverse CDF exponentials or gammas. This class should only be used if it is essential to have randoms that are identical to what would have been produced by previous versions of NumPy.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;提供访问旧式发电机。该生成器被认为是冻结的，将没有进一步的改进。保证产生与NumPy v1.16的最终版本相同的值。这些都取决于Box-Muller法线或反CDF指数或伽马。仅当必须具有与以前版本的NumPy产生的随机数相同的随机数时，才应使用此类。</target>
        </trans-unit>
        <trans-unit id="81979ac862ad90b476e52b55f8477208f98b95b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.recarray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">所述&lt;a href=&quot;#numpy.recarray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt;物可类似于字典的（如在被访问 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ），或通过使用小写属性名称（如在 &lt;code&gt;a.flags.writeable&lt;/code&gt; ）。短标志名仅在字典访问中受支持。</target>
        </trans-unit>
        <trans-unit id="84da36ced33272fa147152f5a355ea7313e10b52" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.sign&quot;&gt;&lt;code&gt;sign&lt;/code&gt;&lt;/a&gt; function returns &lt;code&gt;-1 if x &amp;lt; 0, 0 if x==0, 1 if x &amp;gt; 0&lt;/code&gt;. nan is returned for nan inputs.</source>
          <target state="translated">的&lt;a href=&quot;#numpy.sign&quot;&gt; &lt;code&gt;sign&lt;/code&gt; &lt;/a&gt;函数返回 &lt;code&gt;-1 if x &amp;lt; 0, 0 if x==0, 1 if x &amp;gt; 0&lt;/code&gt; 。返回nan作为nan输入。</target>
        </trans-unit>
        <trans-unit id="158d36e54da803a47a7693e104765168fbd40d0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.testing.dec.deprecated&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt; decorator itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f5bdf7e480a14edfbd94978da2fd35d2b6fd26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.testing.decorators.deprecated&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt; decorator itself.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.testing.decorators.deprecated&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;装饰本身。</target>
        </trans-unit>
        <trans-unit id="f00c158e6b19c749648df9ba6c6e65d03c7d496b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.vectorize&quot;&gt;&lt;code&gt;vectorize&lt;/code&gt;&lt;/a&gt; function is provided primarily for convenience, not for performance. The implementation is essentially a for loop.</source>
          <target state="translated">该&lt;a href=&quot;#numpy.vectorize&quot;&gt; &lt;code&gt;vectorize&lt;/code&gt; &lt;/a&gt;功能主要是为了方便而提供，而不是性能。该实现实质上是一个for循环。</target>
        </trans-unit>
        <trans-unit id="5870961c86339efdff46c3532a51705af2f592f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;datetime unit&lt;/a&gt; on which this dtype is based.</source>
          <target state="translated">此dtype所基于的&lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;datetime单位&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3bf8c2953924a9568aac6e665e279dc1312c55ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/c-api/array#c.PyArray_IterAllButAxis&quot;&gt;&lt;code&gt;PyArray_IterAllButAxis&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;array&lt;/code&gt;, &lt;code&gt;&amp;amp;dim&lt;/code&gt; ) constructs an iterator object that is modified so that it will not iterate over the dimension indicated by dim. The only restriction on this iterator object, is that the &lt;code&gt;PyArray_Iter_GOTO1D&lt;/code&gt; ( &lt;code&gt;it&lt;/code&gt;, &lt;code&gt;ind&lt;/code&gt; ) macro cannot be used (thus flat indexing won&amp;rsquo;t work either if you pass this object back to Python &amp;mdash; so you shouldn&amp;rsquo;t do this). Note that the returned object from this routine is still usually cast to PyArrayIterObject *. All that&amp;rsquo;s been done is to modify the strides and dimensions of the returned iterator to simulate iterating over array[&amp;hellip;,0,&amp;hellip;] where 0 is placed on the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c941be06c3bf21e3b8632eab293bedde5eb0c6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; function can be used to combine different vectors so as to obtain the result for each n-uplet. For example, if you want to compute all the a+b*c for all the triplets taken from each of the vectors a, b and c:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7647b692ad78d569f80f8f518b4edab8e65fa5cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/generated/numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;reshape&lt;/code&gt;&lt;/a&gt; function returns its argument with a modified shape, whereas the &lt;a href=&quot;../reference/generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt;&lt;code&gt;ndarray.resize&lt;/code&gt;&lt;/a&gt; method modifies the array itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28dfdb3c00777ce3fdb3f61c50c67ab257910e81" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/routines.linalg#module-numpy.linalg&quot;&gt;&lt;code&gt;linalg&lt;/code&gt;&lt;/a&gt; module includes a &lt;code&gt;norm&lt;/code&gt; function, which computes the norm of a vector or matrix represented in a NumPy array. For example, from the SVD explanation above, we would expect the norm of the difference between &lt;code&gt;img_gray&lt;/code&gt; and the reconstructed SVD product to be small. As expected, you should see something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a98bd2e9d383259ba90aad2f3b46a4c0ddbbec99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../routines.testing#module-numpy.testing&quot;&gt;&lt;code&gt;numpy.testing&lt;/code&gt;&lt;/a&gt; module includes &lt;code&gt;import decorators as dec&lt;/code&gt;. A test can be decorated as slow like this:</source>
          <target state="translated">该&lt;a href=&quot;../routines.testing#module-numpy.testing&quot;&gt; &lt;code&gt;numpy.testing&lt;/code&gt; &lt;/a&gt;模块包括 &lt;code&gt;import decorators as dec&lt;/code&gt; 。可以像这样缓慢地装饰测试：</target>
        </trans-unit>
        <trans-unit id="081ce1a530a1e04a18f2e8f054e26ae81b0c4d57" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; has a limited set of responsibilities. It manages state and provides functions to produce random doubles and random unsigned 32- and 64-bit values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4d94d478ef39d11efc586cafc38818b04af19cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; function takes the iterators that have already been defined and uses them to determine the broadcast shape in each dimension (to create the iterators at the same time that broadcasting occurs then use the &lt;code&gt;PyMultiIter_New&lt;/code&gt; function). Then, the iterators are adjusted so that each iterator thinks it is iterating over an array with the broadcast size. This is done by adjusting the iterators number of dimensions, and the shape in each dimension. This works because the iterator strides are also adjusted. Broadcasting only adjusts (or adds) length-1 dimensions. For these dimensions, the strides variable is simply set to 0 so that the data-pointer for the iterator over that array doesn&amp;rsquo;t move as the broadcasting operation operates over the extended dimension.</source>
          <target state="translated">所述&lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt;函数采用已定义的迭代器和使用它们来确定在每个维度广播形状（在同一时间创建迭代器广播发生然后使用 &lt;code&gt;PyMultiIter_New&lt;/code&gt; 功能）。然后，调整迭代器，以便每个迭代器都认为它正在广播大小的数组上进行迭代。这可以通过调整迭代器的维数以及每个维中的形状来完成。这是可行的，因为还调整了迭代器的步幅。广播仅调整（或添加）长度为1的尺寸。对于这些维度，将strides变量简单地设置为0，以便当广播操作在扩展维度上进行操作时，该数组上迭代器的数据指针不会移动。</target>
        </trans-unit>
        <trans-unit id="725a4957fd19b096134c24b6194f54dd74c72c01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; function takes the iterators that have already been defined and uses them to determine the broadcast shape in each dimension (to create the iterators at the same time that broadcasting occurs then use the &lt;code&gt;PyMultiIter_New&lt;/code&gt; function). Then, the iterators are adjusted so that each iterator thinks it is iterating over an array with the broadcast size. This is done by adjusting the iterators number of dimensions, and the shape in each dimension. This works because the iterator strides are also adjusted. Broadcasting only adjusts (or adds) length-1 dimensions. For these dimensions, the strides variable is simply set to 0 so that the data-pointer for the iterator over that array doesn&amp;rsquo;t move as the broadcasting operation operates over the extended dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36f842f2997c8193b726b30df3debd673ecb729" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object can be used in all slicing operations to create an axis of length one. &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; is an alias for &amp;lsquo;None&amp;rsquo;, and &amp;lsquo;None&amp;rsquo; can be used in place of this with the same result.</source>
          <target state="translated">所述&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;对象可以在所有的限幅操作被用来创建一个长度的轴线。&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;是'None'的别名，可以使用'None'代替它并得到相同的结果。</target>
        </trans-unit>
        <trans-unit id="149f4058a1754093961b02f9ea6b9d5dd9c10925" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">该&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt;存在与Numarray向后兼容类，所以不推荐在新的发展。从numpy的1.4开始，如果字符串中的一个需要数组，建议使用数组&lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; ， &lt;code&gt;string_&lt;/code&gt; 或 &lt;code&gt;unicode_&lt;/code&gt; ，以及在使用免费的功能&lt;a href=&quot;routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt;快速矢量字符串操作模块。</target>
        </trans-unit>
        <trans-unit id="f9537bf435fae2ec4edc2520b8aeb23abd0ca21e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; can be inherited from (in Python or in C) if desired. Therefore, it can form a foundation for many useful classes. Often whether to sub-class the array object or to simply use the core array component as an internal part of a new class is a difficult decision, and can be simply a matter of choice. NumPy has several tools for simplifying how your new object interacts with other array objects, and so the choice may not be significant in the end. One way to simplify the question is by asking yourself if the object you are interested in can be replaced as a single array or does it really require two or more arrays at its core.</source>
          <target state="translated">如果&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;可以从（在Python或C语言中）继承ndarray。因此，它可以为许多有用的类奠定基础。通常是对数组对象进行子类化还是将核心数组组件简单地用作新类的内部部分是一个困难的决定，并且可能只是选择问题。 NumPy有几个工具可以简化新对象与其他数组对象的交互方式，因此最终选择可能并不重要。简化问题的一种方法是问自己是否可以将感兴趣的对象替换为单个数组，或者它的核心确实需要两个或多个数组。</target>
        </trans-unit>
        <trans-unit id="c0cd171dc2a149543f352698d4bc596e7f8afac8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; will try to provide chunks that are as large as possible to the inner loop. By forcing &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; order, we get different external loop sizes. This mode is enabled by specifying an iterator flag.</source>
          <target state="translated">该&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;将尝试提供尽可能大的内循环块。通过强制执行&amp;ldquo; C&amp;rdquo;和&amp;ldquo; F&amp;rdquo;顺序，我们获得了不同的外部循环大小。通过指定迭代器标志启用此模式。</target>
        </trans-unit>
        <trans-unit id="60bea32ad7ce3442c75308b468830ac8ceb23fe9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; is the user-facing object that is nearly identical to &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. The canonical method to initialize a generator passes a &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; bit generator as the sole argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0287b2a9be936e86bf33e5d1e69557ad4042b14" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; is the user-facing object that is nearly identical to &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. The canonical method to initialize a generator passes a &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; bit generator as the sole argument.</source>
          <target state="translated">该&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;是面向用户的对象，它是几乎相同的&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;。初始化生成器的规范方法将&lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt;位生成器作为唯一参数。</target>
        </trans-unit>
        <trans-unit id="a44536d85a990a438123d796af5725162190334f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;random generator&lt;/code&gt;&lt;/a&gt; takes the bit generator-provided stream and transforms them into more useful distributions, e.g., simulated normal random values. This structure allows alternative bit generators to be used with little code duplication.</source>
          <target state="translated">所述&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;random generator&lt;/code&gt; &lt;/a&gt;取位发生器提供的流，并将它们转换成更加有用的分布，例如，模拟正常的随机值。这种结构允许使用很少的代码重复就可以使用替代位生成器。</target>
        </trans-unit>
        <trans-unit id="65fbb3e3590895ec54d650742d5a8544c871fca6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tom.preston-werner.com/2009/05/19/the-git-parable.html&quot;&gt;git parable&lt;/a&gt; is an easy read explaining the concepts behind git.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f755efceb36d8200d20dc31c04e76cd3c9faf2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; type checking and conversion system is a complicated combination of C macros, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; macros, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemaps and &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; fragments. Fragments are a way to conditionally insert code into your wrapper file if it is needed, and not insert it if not needed. If multiple typemaps require the same fragment, the fragment only gets inserted into your wrapper code once.</source>
          <target state="translated">所述&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;类型检查和转换系统是C宏的复杂组合&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;宏&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemaps和&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;片段。片段是一种在需要时有条件地将代码插入包装文件的方法，而在不需要时则不插入代码。如果多个类型映射需要相同的片段，则该片段仅被插入到您的包装器代码中一次。</target>
        </trans-unit>
        <trans-unit id="03230fc37f6936da8ac6bdd751efc6bea8b56636" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://book.git-scm.com/&quot;&gt;git community book&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e8045e59daf616aee34810d48dbb7db178f9f3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python tutorial&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ce3d1a866c8fe3ec8d4e7bfc02ebc4b98d4d1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://git-scm.com/book/&quot;&gt;pro git book&lt;/a&gt; is a good in-depth book on git.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b683753cdf3b551962126ba95310173bb4c1cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/gittutorial.html&quot;&gt;git tutorial&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bccf408a44196396f7493f86e249b28e7b329b3e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/user-manual.html&quot;&gt;git user manual&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a20426fc7bb4d929b1ae303283b379020fbc254" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;numpy.polynomial.polynomial.polynomial.fit#numpy.polynomial.polynomial.Polynomial.fit&quot;&gt;&lt;code&gt;Polynomial.fit&lt;/code&gt;&lt;/a&gt; class method is recommended for new code as it is more stable numerically. See the documentation of the method for more information.</source>
          <target state="translated">对于新代码，建议使用&lt;a href=&quot;numpy.polynomial.polynomial.polynomial.fit#numpy.polynomial.polynomial.Polynomial.fit&quot;&gt; &lt;code&gt;Polynomial.fit&lt;/code&gt; &lt;/a&gt;类方法，因为它在数值上更稳定。有关更多信息，请参见该方法的文档。</target>
        </trans-unit>
        <trans-unit id="3210c2d9abaca33a8760be87735591310e75c5cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; operators always return &lt;code&gt;False&lt;/code&gt; when comparing void structured arrays, and arithmetic and bitwise operations are not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efea03dca2b9d161f9ef2bba68b5604f07ac3fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;argument/variable attribute statement&amp;gt;&lt;/code&gt; is &lt;code&gt;&amp;lt;argument/variable type declaration&amp;gt;&lt;/code&gt; without &lt;code&gt;&amp;lt;typespec&amp;gt;&lt;/code&gt;. In addition, in an attribute statement one cannot use other attributes, also &lt;code&gt;&amp;lt;entitydecl&amp;gt;&lt;/code&gt; can be only a list of names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa4578e6de9d14302f059bb642ff99cac46413e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;other statement&amp;gt;&lt;/code&gt; part refers to any other Fortran language constructs that are not described above. F2PY ignores most of them except</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03addd0e1d3adac1696638d2556f4f3e8a49b2fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-s&lt;/code&gt; flag makes a PGP (usually GPG) signed tag. Please do sign the release tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f02257b982558ed0038cd836405c4aaec01705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-v&lt;/code&gt; flag gives verbose feedback, &lt;code&gt;-s&lt;/code&gt; causes the script to sign the wheels with your GPG key before upload. Don&amp;rsquo;t forget to upload the wheels before the source tarball, so there is no period for which people switch from an expected binary install to a source install from PyPI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea1937064d555fd6f04fc2b57ae9e905ce9bf17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npy&lt;/code&gt; format is the standard binary file format in NumPy for persisting a &lt;em&gt;single&lt;/em&gt; arbitrary NumPy array on disk. The format stores all of the shape and dtype information necessary to reconstruct the array correctly even on another machine with a different architecture. The format is designed to be as simple as possible while achieving its limited goals.</source>
          <target state="translated">所述 &lt;code&gt;.npy&lt;/code&gt; 格式是在NumPy的用于持久化一个标准二进制文件格式&lt;em&gt;单&lt;/em&gt;上磁盘任意NumPy的阵列。该格式存储正确地重建阵列所需的所有形状和dtype信息，即使在具有不同体系结构的另一台机器上也是如此。该格式旨在在达到其有限目标的同时尽可能地简单。</target>
        </trans-unit>
        <trans-unit id="d25fde9120bc920bdf839700f32d6b700adf8720" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npy&lt;/code&gt; format, including motivation for creating it and a comparison of alternatives, is described in the &lt;a href=&quot;https://www.numpy.org/neps/nep-0001-npy-format.html&quot;&gt;&amp;ldquo;npy-format&amp;rdquo; NEP&lt;/a&gt;, however details have evolved with time and this document is more current.</source>
          <target state="translated">该 &lt;code&gt;.npy&lt;/code&gt; 格式，包括动机，创造它和替代的比较，在描述&lt;a href=&quot;https://www.numpy.org/neps/nep-0001-npy-format.html&quot;&gt;&amp;ldquo;NPY格式&amp;rdquo; NEP&lt;/a&gt;，但细节已经演变随着时间的推移而这个文件是更大的电流。</target>
        </trans-unit>
        <trans-unit id="22e53f126c53ee44cfae93fe323456796e3a7525" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; file format is a zipped archive of files named after the variables they contain. The archive is compressed with &lt;code&gt;zipfile.ZIP_DEFLATED&lt;/code&gt; and each file in the archive contains one variable in &lt;code&gt;.npy&lt;/code&gt; format. For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;.npz&lt;/code&gt; 文件格式是它们所包含的变量命名的文件的压缩文档。压缩文件使用 &lt;code&gt;zipfile.ZIP_DEFLATED&lt;/code&gt; 压缩，并且压缩文件中的每个文件都包含一个 &lt;code&gt;.npy&lt;/code&gt; 格式的变量。有关 &lt;code&gt;.npy&lt;/code&gt; 格式的说明，请参见&lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b51e4d01309ff5a759f392af08bb39d1e99043e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; file format is a zipped archive of files named after the variables they contain. The archive is not compressed and each file in the archive contains one variable in &lt;code&gt;.npy&lt;/code&gt; format. For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;.npz&lt;/code&gt; 文件格式是它们所包含的变量命名的文件的压缩文档。档案未压缩，档案中的每个文件都包含一个 &lt;code&gt;.npy&lt;/code&gt; 格式的变量。有关 &lt;code&gt;.npy&lt;/code&gt; 格式的说明，请参见&lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5c00dd2aa73f26e18024a200e3875179deacef9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; format is the standard format for persisting &lt;em&gt;multiple&lt;/em&gt; NumPy arrays on disk. A &lt;code&gt;.npz&lt;/code&gt; file is a zip file containing multiple &lt;code&gt;.npy&lt;/code&gt; files, one for each array.</source>
          <target state="translated">所述 &lt;code&gt;.npz&lt;/code&gt; 格式是用于持久化的标准格式&lt;em&gt;的多个&lt;/em&gt;磁盘上NumPy的阵列。甲 &lt;code&gt;.npz&lt;/code&gt; 文件是包含多个压缩文件 &lt;code&gt;.npy&lt;/code&gt; 文件，一个用于每个阵列。</target>
        </trans-unit>
        <trans-unit id="19658579206ac4f8753c064c0302ad76f2f72a46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ALIGNED&lt;/code&gt; flag of an ndarray, computed in &lt;code&gt;IsAligned&lt;/code&gt; and checked by &lt;code&gt;PyArray_ISALIGNED&lt;/code&gt;. This is computed from &lt;code&gt;dtype.alignment&lt;/code&gt;. It is set to &lt;code&gt;True&lt;/code&gt; if every item in the array is at a memory location consistent with &lt;code&gt;dtype.alignment&lt;/code&gt;, which is the case if the data ptr and all strides of the array are multiples of that alignment.</source>
          <target state="translated">所述 &lt;code&gt;ALIGNED&lt;/code&gt; 一个ndarray的标志，计算在 &lt;code&gt;IsAligned&lt;/code&gt; 和通过检查 &lt;code&gt;PyArray_ISALIGNED&lt;/code&gt; 。这是从 &lt;code&gt;dtype.alignment&lt;/code&gt; 计算的。如果数组中的每个项目都位于与 &lt;code&gt;dtype.alignment&lt;/code&gt; 一致的内存位置，则将其设置为 &lt;code&gt;True&lt;/code&gt; ,如果数据ptr和数组的所有跨度是该对齐的倍数，则为true。</target>
        </trans-unit>
        <trans-unit id="85388f353d8827d53025cb4498ec7c4f7175db9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BitGenerator&lt;/code&gt; has a limited set of responsibilities. It manages state and provides functions to produce random doubles and random unsigned 32- and 64-bit values.</source>
          <target state="translated">该 &lt;code&gt;BitGenerator&lt;/code&gt; 有一组有限的责任。它管理状态并提供产生随机双精度数和随机无符号32位和64位值的功能。</target>
        </trans-unit>
        <trans-unit id="29642d4a46e1b1f330f5d899a27d8931b3675855" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Configuration&lt;/code&gt; constructor has a fourth optional argument, &lt;code&gt;package_path&lt;/code&gt;, that can be used when package files are located in a different location than the directory of the &lt;code&gt;setup.py&lt;/code&gt; file.</source>
          <target state="translated">该 &lt;code&gt;Configuration&lt;/code&gt; 构造有第四个可选参数， &lt;code&gt;package_path&lt;/code&gt; ，当包文件位于不同的位置比所在的目录可以使用 &lt;code&gt;setup.py&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="831e4b75031bb8f9a8d29e89a9890ddda53ce469" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LibraryInfo&lt;/code&gt; instance containing the build information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d942d62411c592ee85272583cee21a0d612eb9cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MT19937&lt;/code&gt; state vector consists of a 624-element array of 32-bit unsigned integers plus a single integer value between 0 and 624 that indexes the current position within the main array.</source>
          <target state="translated">所述 &lt;code&gt;MT19937&lt;/code&gt; 状态向量由32位无符号整数一个624个元素的数组加一个整数值的0和624的索引主阵列内的当前位置。</target>
        </trans-unit>
        <trans-unit id="a95fd45cabac9b94aa97772f024779835dc306b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Makefile&lt;/code&gt; calls &lt;code&gt;swig&lt;/code&gt; to generate &lt;code&gt;Vector.py&lt;/code&gt; and &lt;code&gt;Vector_wrap.cxx&lt;/code&gt;, and also executes the &lt;code&gt;setup.py&lt;/code&gt; script that compiles &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; and links together the extension module &lt;code&gt;_Vector.so&lt;/code&gt; or &lt;code&gt;_Vector.dylib&lt;/code&gt;, depending on the platform. This extension module and the proxy file &lt;code&gt;Vector.py&lt;/code&gt; are both placed in a subdirectory under the &lt;code&gt;build&lt;/code&gt; directory.</source>
          <target state="translated">在 &lt;code&gt;Makefile&lt;/code&gt; 文件调用 &lt;code&gt;swig&lt;/code&gt; 生成 &lt;code&gt;Vector.py&lt;/code&gt; 和 &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; ，并执行 &lt;code&gt;setup.py&lt;/code&gt; ，编译脚本 &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; 和链接在一起的扩展模块 &lt;code&gt;_Vector.so&lt;/code&gt; 或 &lt;code&gt;_Vector.dylib&lt;/code&gt; ，根据不同的平台上。该扩展模块和代理文件 &lt;code&gt;Vector.py&lt;/code&gt; 都位于 &lt;code&gt;build&lt;/code&gt; 目录下的子目录中。</target>
        </trans-unit>
        <trans-unit id="a509290375510505b589158f3b8f2b07b506f6b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MaskedArray&lt;/code&gt; class</source>
          <target state="translated">该 &lt;code&gt;MaskedArray&lt;/code&gt; 类</target>
        </trans-unit>
        <trans-unit id="b55e755e6d26d2135c464a8b79f8ff9c154dcada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; constants are defined so that sizeof information is available to the pre-processor.</source>
          <target state="translated">所述 &lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; 常数定义为使得的sizeof信息是提供给预处理器。</target>
        </trans-unit>
        <trans-unit id="d0911aba3c1681f9c5a1ccf39d3f2fd5866ac6b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NpzFile&lt;/code&gt; returned by &lt;code&gt;np.savez&lt;/code&gt; is now a &lt;code&gt;collections.abc.Mapping&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d918fc830e6f124f45ecb19bab96030d1a7583a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PCG64&lt;/code&gt; state vector consists of 2 unsigned 128-bit values, which are represented externally as Python ints. One is the state of the PRNG, which is advanced by a linear congruential generator (LCG). The second is a fixed odd increment used in the LCG.</source>
          <target state="translated">所述 &lt;code&gt;PCG64&lt;/code&gt; 状态矢量由2无符号的128位值，其在外部表示为整数的Python的。一种是PRNG的状态，它由线性同余生成器（LCG）进行高级处理。第二个是LCG中使用的固定奇数增量。</target>
        </trans-unit>
        <trans-unit id="c1a90ac63bb863a062bb153b73df1e64c4857aff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Philox&lt;/code&gt; state vector consists of a 256-bit value encoded as a 4-element uint64 array and a 128-bit value encoded as a 2-element uint64 array. The former is a counter which is incremented by 1 for every 4 64-bit randoms produced. The second is a key which determined the sequence produced. Using different keys produces independent sequences.</source>
          <target state="translated">所述 &lt;code&gt;Philox&lt;/code&gt; 状态向量由编码为4元件阵列UINT64一个256位的值的和一个128位的值编码为2元件UINT64阵列。前者是一个计数器，每产生4个64位随机数，计数器就会增加1。第二个是确定生成顺序的键。使用不同的键会产生独立的序列。</target>
        </trans-unit>
        <trans-unit id="4d1f94165781d8145f1fd80c467f6bd0f760f0b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SFC64&lt;/code&gt; state vector consists of 4 unsigned 64-bit values. The last is a 64-bit counter that increments by 1 each iteration.</source>
          <target state="translated">所述 &lt;code&gt;SFC64&lt;/code&gt; 状态向量由4无符号的64位值。最后一个是64位计数器，每次迭代递增1。</target>
        </trans-unit>
        <trans-unit id="a79e711795f6e28c85d83994efa93c2930d50249" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__array_ufunc__&lt;/code&gt; receives:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be3375866469167b9378a498844a5222b829ab9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__complex__&lt;/code&gt; method has been implemented for the ndarrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="395b8858a352467f67b6a09c4a5fc424e26cfad2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__init__.py&lt;/code&gt; file</source>
          <target state="translated">该 &lt;code&gt;__init__.py&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="55e0b71eae2cfd6e566258a88d10c513a1a5a113" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; keyword of the dtype constructor, which only affects structured arrays. If the structure&amp;rsquo;s field offsets are not manually provided numpy determines offsets automatically. In that case, &lt;code&gt;align=True&lt;/code&gt; pads the structure so that each field is &amp;ldquo;true&amp;rdquo; aligned in memory and sets &lt;code&gt;dtype.alignment&lt;/code&gt; to be the largest of the field &amp;ldquo;true&amp;rdquo; alignments. This is like what C-structs usually do. Otherwise if offsets or itemsize were manually provided &lt;code&gt;align=True&lt;/code&gt; simply checks that all the fields are &amp;ldquo;true&amp;rdquo; aligned and that the total itemsize is a multiple of the largest field alignment. In either case &lt;code&gt;dtype.isalignedstruct&lt;/code&gt; is also set to True.</source>
          <target state="translated">dtype构造函数的 &lt;code&gt;align&lt;/code&gt; 关键字，仅影响结构化数组。如果未手动提供结构的字段偏移量，则numpy会自动确定偏移量。在这种情况下， &lt;code&gt;align=True&lt;/code&gt; &lt;code&gt;dtype.alignment&lt;/code&gt; 结构，以便每个字段在内存中都是&amp;ldquo; true&amp;rdquo;对齐的，并将dtype.alignment设置为字段&amp;ldquo; true&amp;rdquo;对齐中的最大对齐。这就像C结构通常所做的那样。否则，如果手动提供了偏移量或项目大小，则 &lt;code&gt;align=True&lt;/code&gt; 仅检查所有字段是否为&amp;ldquo; true&amp;rdquo;对齐，并且总项目大小为最大字段对齐的倍数。无论哪种情况， &lt;code&gt;dtype.isalignedstruct&lt;/code&gt; 也都设置为True。</target>
        </trans-unit>
        <trans-unit id="ed305f750328762db1dc6ead8c6be67eaf77ffcb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;array&lt;/code&gt; constructor &lt;strong&gt;takes (nested) Python sequences as initializers&lt;/strong&gt;. As in, &lt;code&gt;array([[1,2,3],[4,5,6]])&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7af29f13d56d1534071fc5be1d8e6902e6aa373" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;array&lt;/code&gt; is thus much more advisable to use. Indeed, we intend to deprecate &lt;code&gt;matrix&lt;/code&gt; eventually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd27c9fa716237737a1b850fd84a88e9e84db97b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt;-clause of the &lt;code&gt;with&lt;/code&gt;-statement gives the current print options:</source>
          <target state="translated">该 &lt;code&gt;as&lt;/code&gt; 的-clause &lt;code&gt;with&lt;/code&gt; 语句来给出当前打印选项：</target>
        </trans-unit>
        <trans-unit id="2c28e104a97f1a1f15fc38cbcd9f731be438b4c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autostrip&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad906fe89b0c268cf5fd9b3376621745175a9a41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; argument to &lt;code&gt;numpy.ma.mask_cols&lt;/code&gt; and &lt;code&gt;numpy.ma.mask_row&lt;/code&gt; is deprecated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa858c948295450c18bcef4c572e68d7eda67a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; keyword can be used to specify a subset of axes of which the gradient is calculated</source>
          <target state="translated">所述 &lt;code&gt;axis&lt;/code&gt; 关键字可以被用来指定一个被计算的梯度轴的一个子集</target>
        </trans-unit>
        <trans-unit id="c68a2d64e2aeed4fdf4077c45259bb4b7c07822e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; parameter specifies the index of the new axis in the dimensions of the result. For example, if &lt;code&gt;axis=0&lt;/code&gt; it will be the first dimension and if &lt;code&gt;axis=-1&lt;/code&gt; it will be the last dimension.</source>
          <target state="translated">所述 &lt;code&gt;axis&lt;/code&gt; 参数指定新轴的在结果的尺寸的索引。例如，如果 &lt;code&gt;axis=0&lt;/code&gt; ，它将是第一个尺寸；如果 &lt;code&gt;axis=-1&lt;/code&gt; ，它将是最后的尺寸。</target>
        </trans-unit>
        <trans-unit id="285d55a28a1a269db45a5f84582658fc7e3a43b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base&lt;/code&gt; attribute is useful in being able to tell whether we have a view or the original array. This in turn can be useful if we need to know whether or not to do some specific cleanup when the subclassed array is deleted. For example, we may only want to do the cleanup if the original array is deleted, but not the views. For an example of how this can work, have a look at the &lt;code&gt;memmap&lt;/code&gt; class in &lt;code&gt;numpy.core&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4cb66724d02c13ff5f50a065c67d6d75a20a6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool_&lt;/code&gt; data type is very similar to the Python &lt;code&gt;BooleanType&lt;/code&gt; but does not inherit from it because Python&amp;rsquo;s &lt;code&gt;BooleanType&lt;/code&gt; does not allow itself to be inherited from, and on the C-level the size of the actual bool data is not the same as a Python Boolean scalar.</source>
          <target state="translated">该 &lt;code&gt;bool_&lt;/code&gt; 数据类型是非常相似的Python &lt;code&gt;BooleanType&lt;/code&gt; 但不继承它，因为Python的 &lt;code&gt;BooleanType&lt;/code&gt; 不允许自己被继承，并在C级的实际布尔数据的大小是不一样的一个Python布尔标量。</target>
        </trans-unit>
        <trans-unit id="1a9ec4df6ec3fb7357baf90864b29d969f59440a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool_&lt;/code&gt; type is not a subclass of the &lt;code&gt;int_&lt;/code&gt; type (the &lt;code&gt;bool_&lt;/code&gt; is not even a number type). This is different than Python&amp;rsquo;s default implementation of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; as a sub-class of int.</source>
          <target state="translated">所述 &lt;code&gt;bool_&lt;/code&gt; 类型不是的一个子类 &lt;code&gt;int_&lt;/code&gt; 类型（ &lt;code&gt;bool_&lt;/code&gt; 甚至不是一个数类型）。这与Python 作为int的子类的&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;的默认实现不同。</target>
        </trans-unit>
        <trans-unit id="3f5c3b6d52d4becfb53cc5a7dd0ae6b04cdb9085" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a prefix or suffix; rather, all combinations of its values are stripped.</source>
          <target state="translated">的 &lt;code&gt;chars&lt;/code&gt; 参数是要除去的字符串指定的字符集。如果省略或为None，则 &lt;code&gt;chars&lt;/code&gt; 参数默认为删除空格。该 &lt;code&gt;chars&lt;/code&gt; 参数不是前缀或后缀; 而是删除其值的所有组合。</target>
        </trans-unit>
        <trans-unit id="44ca716c299a61027880c154634feb6b89178fc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a prefix; rather, all combinations of its values are stripped.</source>
          <target state="translated">的 &lt;code&gt;chars&lt;/code&gt; 参数是要除去的字符串指定的字符集。如果省略或为None，则 &lt;code&gt;chars&lt;/code&gt; 参数默认为删除空格。该 &lt;code&gt;chars&lt;/code&gt; 参数不是前缀; 而是删除其值的所有组合。</target>
        </trans-unit>
        <trans-unit id="3ab81d1fe754db2126af526470043294b9859fdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a suffix; rather, all combinations of its values are stripped.</source>
          <target state="translated">的 &lt;code&gt;chars&lt;/code&gt; 参数是要除去的字符串指定的字符集。如果省略或为None，则 &lt;code&gt;chars&lt;/code&gt; 参数默认为删除空格。该 &lt;code&gt;chars&lt;/code&gt; 参数不是后缀; 而是删除其值的所有组合。</target>
        </trans-unit>
        <trans-unit id="c5f389d1809eca65fc531558b3a6934398b93db5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;code.c&lt;/code&gt; file also contains the function &lt;code&gt;dfilter2d&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1062b010a751d11306d8dd6990fc1281fafefff6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;comments&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f924ee1f48ac861086d833eab7f0e461342200" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;converters&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf25618f0e89873a8966e075d9cc930c281ddb2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; method makes a complete copy of the array and its data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c7d601eb1b28391adc5c0db2ef77348e27c0e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defaultfmt&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a534898d388f95602366c3e92d612246a0ec8f63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delimiter&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961750d0f31ee27657eeda3c0b92ff071d0d3872" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doc/swig&lt;/code&gt; directory moved</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f33c0fec12debe8698b9f3d00999bb3fb759ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype.alignment&lt;/code&gt; attribute (&lt;code&gt;descr-&amp;gt;alignment&lt;/code&gt; in C). This is meant to reflect the &amp;ldquo;true alignment&amp;rdquo; of the type. It has arch-dependent default values for all datatypes, with the exception of structured types created with &lt;code&gt;align=True&lt;/code&gt; as described below.</source>
          <target state="translated">所述 &lt;code&gt;dtype.alignment&lt;/code&gt; 属性（ &lt;code&gt;descr-&amp;gt;alignment&lt;/code&gt; 在C）。这是为了反映类型的&amp;ldquo;真实对齐&amp;rdquo;。对于所有数据类型，它都有与拱有关的默认值，但使用 &lt;code&gt;align=True&lt;/code&gt; 创建的结构化类型除外，如下所述。</target>
        </trans-unit>
        <trans-unit id="323a6b614fe91ba8419451439d97b4868d61c2a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype.fields&lt;/code&gt; dictionary will contain titles as keys, if any titles are used. This means effectively that a field with a title will be represented twice in the fields dictionary. The tuple values for these fields will also have a third element, the field title. Because of this, and because the &lt;code&gt;names&lt;/code&gt; attribute preserves the field order while the &lt;code&gt;fields&lt;/code&gt; attribute may not, it is recommended to iterate through the fields of a dtype using the &lt;code&gt;names&lt;/code&gt; attribute of the dtype, which will not list titles, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0428300bbf21ef1b533ffa3e86adb5ceddd8dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype&lt;/code&gt; parameter defines the underlying data type.</source>
          <target state="translated">的 &lt;code&gt;dtype&lt;/code&gt; 参数定义的底层数据的类型。</target>
        </trans-unit>
        <trans-unit id="93f7d511e2846b265125fabe4d5030e15709832e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;excluded&lt;/code&gt; argument can be used to prevent vectorizing over certain arguments. This can be useful for array-like arguments of a fixed length such as the coefficients for a polynomial as in &lt;a href=&quot;numpy.polyval#numpy.polyval&quot;&gt;&lt;code&gt;polyval&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在 &lt;code&gt;excluded&lt;/code&gt; 参数可以用来防止向量化对某些参数。这对于固定长度的类似数组的参数很有用，例如在&lt;a href=&quot;numpy.polyval#numpy.polyval&quot;&gt; &lt;code&gt;polyval&lt;/code&gt; 中&lt;/a&gt;的多项式系数：</target>
        </trans-unit>
        <trans-unit id="359c30915e6710377793414f9e99d77e6eeeea63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;f2py -c&lt;/code&gt; option must be applied either to an existing &lt;code&gt;.pyf&lt;/code&gt; file (plus the source/object/library files) or one must specify the &lt;code&gt;-m &amp;lt;modulename&amp;gt;&lt;/code&gt; option (plus the sources/object/library files). Use one of the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2beff53e54fda1bd096a7e81c4708f352287d275" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; attribute of the &lt;code&gt;PyArrayObject&lt;/code&gt; structure contains important information about the memory used by the array (pointed to by the data member) This flag information must be kept accurate or strange results and even segfaults may result.</source>
          <target state="translated">&lt;code&gt;PyArrayObject&lt;/code&gt; 结构的 &lt;code&gt;flags&lt;/code&gt; 属性包含有关数组使用的内存的重要信息（由数据成员指向）。必须保留此标志信息的准确性或奇怪的结果，甚至可能导致段错误。</target>
        </trans-unit>
        <trans-unit id="8cff4dd26e77da7e42ef944b6a6e55860dbd33d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;genfromtxt&lt;/code&gt; function provides two other complementary mechanisms: the &lt;code&gt;missing_values&lt;/code&gt; argument is used to recognize missing data and a second argument, &lt;code&gt;filling_values&lt;/code&gt;, is used to process these missing data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b08d522b6b1cfd800cd6bda4d86b04d644f1baf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int_&lt;/code&gt; type does &lt;strong&gt;not&lt;/strong&gt; inherit from the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; built-in under Python 3, because type &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; is no longer a fixed-width integer type.</source>
          <target state="translated">所述 &lt;code&gt;int_&lt;/code&gt; 类型并&lt;strong&gt;没有&lt;/strong&gt;从继承&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;内置Python 3下，因为型&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;不再是固定宽度的整数类型。</target>
        </trans-unit>
        <trans-unit id="5032550323e57bc7dec27d8af2d8f9df18642750" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;itershape&lt;/code&gt; parameter allows you to force the iterator to have a specific iteration shape. It is an array of length &lt;code&gt;oa_ndim&lt;/code&gt;. When an entry is negative, its value is determined from the operands. This parameter allows automatically allocated outputs to get additional dimensions which don&amp;rsquo;t match up with any dimension of an input.</source>
          <target state="translated">使用 &lt;code&gt;itershape&lt;/code&gt; 参数可以强制迭代器具有特定的迭代形状。它是一个长度为 &lt;code&gt;oa_ndim&lt;/code&gt; 的数组。当条目为负数时，其值由操作数确定。此参数允许自动分配的输出获得与输入的任何尺寸都不匹配的其他尺寸。</target>
        </trans-unit>
        <trans-unit id="d1b139e99319cf8723f8471165f727072e0de12d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;k&lt;/code&gt; different &amp;ldquo;columns&amp;rdquo; to be sorted. The last column (or row if &lt;code&gt;keys&lt;/code&gt; is a 2D array) is the primary sort key.</source>
          <target state="translated">要排序的 &lt;code&gt;k&lt;/code&gt; 个不同的&amp;ldquo;列&amp;rdquo;。最后一列（如果 &lt;code&gt;keys&lt;/code&gt; 是2D数组，则为行）是主排序键。</target>
        </trans-unit>
        <trans-unit id="bf501ea6ca94cccfb99a424407f3991a7fe0b23a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mask&lt;/code&gt; can be initialized with an array of boolean values with the same shape as &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a81ce30e9985e9cc6aff4a084478e80352aabd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;matrix&lt;/code&gt; constructor additionally &lt;strong&gt;takes a convenient string initializer&lt;/strong&gt;. As in &lt;code&gt;matrix(&quot;[1&amp;nbsp;2&amp;nbsp;3;&amp;nbsp;4&amp;nbsp;5&amp;nbsp;6]&quot;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab61433b884d13cbf28918d009f77e172c843e81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt; arrays of indices corresponding to the locations where &lt;code&gt;mask_func(np.ones((n, n)), k)&lt;/code&gt; is True.</source>
          <target state="translated">对应于 &lt;code&gt;mask_func(np.ones((n, n)), k)&lt;/code&gt; 为True 的位置的索引的 &lt;code&gt;n&lt;/code&gt; 个数组。</target>
        </trans-unit>
        <trans-unit id="69bba282bdcb3fd4a040d50fe46e42c40f81a639" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;names&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e43d8a15f5f97ea384a5e71f1342015a6bc434" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ndarray&lt;/code&gt; is an object that provide a python array interface to data in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68dcfe0b1fdf3a267f300958e2039277e48ae02c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new_order&lt;/code&gt; code can be any from the following:</source>
          <target state="translated">该 &lt;code&gt;new_order&lt;/code&gt; 代码可以是任何从以下方面：</target>
        </trans-unit>
        <trans-unit id="8693a0f592844bcf9978c5fbaa78f4621036206e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nonzero&lt;/code&gt; method of the condition array can also be called.</source>
          <target state="translated">也可以调用条件数组的 &lt;code&gt;nonzero&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="119598850fcb719f758c8505ecbfd545e55a9647" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;np.einsum&lt;/code&gt; function will use BLAS when possible and optimize by default</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03ccb4d87ad4f35f1ad3c43da765c8e7da17640" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;np.percentile&lt;/code&gt; &amp;lsquo;midpoint&amp;rsquo; interpolation method fixed for exact indices</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabf6694e45f9bef7f8445dcaf6ddb978e5e6f05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;npy_3kcompat.h&lt;/code&gt; header changed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18c665ad6cff39ded6fc90bc8648963ab9ee138" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; file contains several macros and routines that it uses internally to build its typemaps. However, these functions may be useful elsewhere in your interface file. These macros and routines are implemented as fragments, which are described briefly in the previous section. If you try to use one or more of the following macros or functions, but your compiler complains that it does not recognize the symbol, then you need to force these fragments to appear in your code using:</source>
          <target state="translated">该 &lt;code&gt;numpy.i&lt;/code&gt; 文件包含几个宏和例程，它在内部使用，以建立自己的typemaps。但是，这些功能在界面文件中的其他位置可能很有用。这些宏和例程作为片段实现，在上一节中进行了简要描述。如果尝试使用以下一个或多个宏或函数，但是编译器抱怨它无法识别该符号，则需要使用以下命令强制这些片段出现在代码中：</target>
        </trans-unit>
        <trans-unit id="9f4cb37fdc51e8b1f5c2b248e5fd15fdd94aa9b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; file is currently located in the &lt;code&gt;tools/swig&lt;/code&gt; sub-directory under the &lt;code&gt;numpy&lt;/code&gt; installation directory. Typically, you will want to copy it to the directory where you are developing your wrappers.</source>
          <target state="translated">该 &lt;code&gt;numpy.i&lt;/code&gt; 当前文件位于 &lt;code&gt;tools/swig&lt;/code&gt; 下子目录 &lt;code&gt;numpy&lt;/code&gt; 的安装目录。通常，您需要将其复制到开发包装程序的目录中。</target>
        </trans-unit>
        <trans-unit id="96831ff16133b13c87cfe870992604959917c570" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file also provides additional tools for wrapper developers, including:</source>
          <target state="translated">该 &lt;code&gt;numpy.i&lt;/code&gt; 接口文件还提供了额外的工具，用于包装的开发，其中包括：</target>
        </trans-unit>
        <trans-unit id="d04832f55eba99f2bc4cc0dceb3d718f68b6cac8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file does not support typemaps for output arrays, for several reasons. First, C/C++ return arguments are limited to a single value. This prevents obtaining dimension information in a general way. Second, arrays with hard-coded lengths are not permitted as return arguments. In other words:</source>
          <target state="translated">该 &lt;code&gt;numpy.i&lt;/code&gt; 接口文件不支持typemaps输出数组，有几个原因。首先，C / C ++返回参数限制为单个值。这阻止了以一般方式获得尺寸信息。其次，不允许将具有硬编码长度的数组作为返回参数。换一种说法：</target>
        </trans-unit>
        <trans-unit id="65e8b572ae6dc55c16aea9abc0f0766e897fe055" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file uses the &lt;code&gt;%numpy_typemaps&lt;/code&gt; macro to implement typemaps for the following C data types and &lt;code&gt;int&lt;/code&gt; dimension types:</source>
          <target state="translated">所述 &lt;code&gt;numpy.i&lt;/code&gt; 接口文件使用 &lt;code&gt;%numpy_typemaps&lt;/code&gt; 宏实施typemaps为下面的C数据类型和 &lt;code&gt;int&lt;/code&gt; 尺寸类型：</target>
        </trans-unit>
        <trans-unit id="d99e0e96fa984690444350c5bb3087380beb5586" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.ma&lt;/code&gt; module</source>
          <target state="translated">该 &lt;code&gt;numpy.ma&lt;/code&gt; 模块</target>
        </trans-unit>
        <trans-unit id="1f4db4ab31f145b9bac6edb4b0915cc64c0ea3a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.ndarray&lt;/code&gt; constructor no longer interprets &lt;code&gt;strides=()&lt;/code&gt; as &lt;code&gt;strides=None&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a302d51ef0fc934fa61a7faa2fee138940dfc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.rec&lt;/code&gt; module provides a number of other convenience functions for creating record arrays, see &lt;a href=&quot;../reference/routines.array-creation#routines-array-creation-rec&quot;&gt;record array creation routines&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8ade543f0e1c46d97cf061c562c3116b9639d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;order&lt;/code&gt; keyword gives the index ordering both for &lt;em&gt;fetching&lt;/em&gt; the values from &lt;code&gt;a&lt;/code&gt;, and then &lt;em&gt;placing&lt;/em&gt; the values into the output array. For example, let&amp;rsquo;s say you have an array:</source>
          <target state="translated">的 &lt;code&gt;order&lt;/code&gt; 关键字给出的索引用于订购两者&lt;em&gt;取&lt;/em&gt;从值 &lt;code&gt;a&lt;/code&gt; ，然后&lt;em&gt;把&lt;/em&gt;该值代入输出阵列。例如，假设您有一个数组：</target>
        </trans-unit>
        <trans-unit id="b38e6e5718f484c9be916df67070a4920d8e24c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repr&lt;/code&gt; of &lt;code&gt;np.polynomial&lt;/code&gt; classes is more explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7075c0200f067381f77164e531b354de40ba5d19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;savetxt()&lt;/code&gt; and &lt;code&gt;loadtxt()&lt;/code&gt; functions accept additional optional parameters such as header, footer, and delimiter. While text files can be easier for sharing, .npy and .npz files are smaller and faster to read. If you need more sophisticated handling of your text file (for example, if you need to work with lines that contain missing values), you will want to use the &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022ed8cd0b6cf9d8c83ca5b8b482f20886ea6324" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;series&lt;/code&gt; is expected to be an instance of some polynomial series of one of the types supported by by the numpy.polynomial module, but could be some other class that supports the convert method.</source>
          <target state="translated">该 &lt;code&gt;series&lt;/code&gt; 应为numpy.polynomial模块支持的一种类型的多项式系列的实例，但也可以是其他支持convert方法的类。</target>
        </trans-unit>
        <trans-unit id="f4910f2b9024b32efada1e65d4c1134f65374f1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setup.py&lt;/code&gt; file</source>
          <target state="translated">该 &lt;code&gt;setup.py&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="0948550106d7d72b97910c4e4918bcddbe3d6d6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;signature&lt;/code&gt; argument allows for vectorizing functions that act on non-scalar arrays of fixed length. For example, you can use it for a vectorized calculation of Pearson correlation coefficient and its p-value:</source>
          <target state="translated">的 &lt;code&gt;signature&lt;/code&gt; 参数允许向量化上的固定长度的非标量阵列作用的功能。例如，可以将其用于皮尔逊相关系数及其p值的矢量化计算：</target>
        </trans-unit>
        <trans-unit id="692ace7013c4ccf7dfcd73ad9c88abfaeb03c00c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip_header&lt;/code&gt; and &lt;code&gt;skip_footer&lt;/code&gt; arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19cc10b9b9bd6104c6aeb8b9be441a8dc8445028" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; argument must be a sequence that contains the following elements:</source>
          <target state="translated">的 &lt;code&gt;state&lt;/code&gt; 参数必须是包含下列元素的序列：</target>
        </trans-unit>
        <trans-unit id="28db18b99085783cc1cb19c430887ae4c1bd2dc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; tuple has the following items:</source>
          <target state="translated">该 &lt;code&gt;state&lt;/code&gt; 元组有以下三个项目：</target>
        </trans-unit>
        <trans-unit id="0e4c35736a2eec986972a33d172a5be16d326f7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tp_as_number&lt;/code&gt; methods use a generic approach to call whatever function has been registered for handling the operation. When the &lt;code&gt;_multiarray_umath module&lt;/code&gt; is imported, it sets the numeric operations for all arrays to the corresponding ufuncs. This choice can be changed with &lt;a href=&quot;c-api.ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt;&lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt;&lt;/a&gt; The &lt;code&gt;tp_str&lt;/code&gt; and &lt;code&gt;tp_repr&lt;/code&gt; methods can also be altered using &lt;a href=&quot;c-api.array#c.PyArray_SetStringFunction&quot;&gt;&lt;code&gt;PyArray_SetStringFunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;tp_as_number&lt;/code&gt; 方法使用一个通用的方法来调用函数的任何已登记处理操作。当 &lt;code&gt;_multiarray_umath module&lt;/code&gt; 被导入，它为所有阵列到相应ufuncs数字操作。这种选择可以改变&lt;a href=&quot;c-api.ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt; &lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;tp_str&lt;/code&gt; 和 &lt;code&gt;tp_repr&lt;/code&gt; 方法也可以使用改变&lt;a href=&quot;c-api.array#c.PyArray_SetStringFunction&quot;&gt; &lt;code&gt;PyArray_SetStringFunction&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="008291952c69e3c178208fe3d11495f165132897" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tp_as_number&lt;/code&gt; methods use a generic approach to call whatever function has been registered for handling the operation. When the &lt;code&gt;_multiarray_umath module&lt;/code&gt; is imported, it sets the numeric operations for all arrays to the corresponding ufuncs. This choice can be changed with &lt;a href=&quot;ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt;&lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt;&lt;/a&gt; The &lt;code&gt;tp_str&lt;/code&gt; and &lt;code&gt;tp_repr&lt;/code&gt; methods can also be altered using &lt;a href=&quot;array#c.PyArray_SetStringFunction&quot;&gt;&lt;code&gt;PyArray_SetStringFunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5f797071b24065d3a9e203b1fcea474546397a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usecols&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5186f89054917ad06c4418d857ded8a6ad552d9f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Documentation&lt;/em&gt; for a software project is the set of reference, instructional, educational, informative material generated by the project developers and contributors, as well as discussions, presentations, videos and other user-generated content. It may include learning-oriented content (such as tutorials and how-tos), use-cases or in-depth explanations and reference for developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a54cde186ec5ee99014b55275737fd8ded4abc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;bounds&lt;/em&gt; argument is expected to be a (2 * iter-&amp;gt;ao-&amp;gt;nd) arrays, such as the range bound[2*i]-&amp;gt;bounds[2*i+1] defines the range where to walk for dimension i (both bounds are included in the walked coordinates). The bounds should be ordered for each dimension (bounds[2*i] &amp;lt;= bounds[2*i+1]).</source>
          <target state="translated">的&lt;em&gt;边界&lt;/em&gt;参数预期为一个（2 * iter-&amp;gt; AO-&amp;gt; ND）阵列，诸如结合的范围[2 * I] - &amp;gt;界[2 * I + 1]定义的范围内，其中以步行尺寸我（两个边界都包含在行走坐标中）。每个维度的边界应排序（bounds [2 * i] &amp;lt;= bounds [2 * i + 1]）。</target>
        </trans-unit>
        <trans-unit id="167173497ff130611588ae9a0a550c00ffde124f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;compile-time&lt;/em&gt; environment variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1fe523a0552e237800f38d8997bfcb72c8d0f5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;func&lt;/em&gt;, &lt;em&gt;data&lt;/em&gt;, &lt;em&gt;types&lt;/em&gt;, &lt;em&gt;name&lt;/em&gt;, and &lt;em&gt;doc&lt;/em&gt; arguments are not copied by &lt;a href=&quot;#c.PyUFunc_FromFuncAndData&quot;&gt;&lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt;&lt;/a&gt;. The caller must ensure that the memory used by these arrays is not freed as long as the ufunc object is alive.</source>
          <target state="translated">该&lt;em&gt;FUNC&lt;/em&gt;，&lt;em&gt;数据&lt;/em&gt;，&lt;em&gt;类型&lt;/em&gt;，&lt;em&gt;名称&lt;/em&gt;，和&lt;em&gt;文档&lt;/em&gt;参数不被复制&lt;a href=&quot;#c.PyUFunc_FromFuncAndData&quot;&gt; &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; &lt;/a&gt;。只要ufunc对象处于活动状态，调用者必须确保不释放这些数组使用的内存。</target>
        </trans-unit>
        <trans-unit id="20c9d63d4d93167ef641a021fb26c115a182b092" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;itemsize&lt;/em&gt; key allows the total size of the dtype to be set, and must be an integer large enough so all the fields are within the dtype. If the dtype being constructed is aligned, the &lt;em&gt;itemsize&lt;/em&gt; must also be divisible by the struct alignment. Total dtype &lt;em&gt;itemsize&lt;/em&gt; is limited to &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt;&lt;code&gt;ctypes.c_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">项目&lt;em&gt;大小&lt;/em&gt;键允许设置&lt;em&gt;dtype&lt;/em&gt;的总大小，并且必须是足够大的整数，以便所有字段都在dtype内。如果正在构造的&lt;em&gt;dtype&lt;/em&gt;是对齐的，则&lt;em&gt;itemsize&lt;/em&gt;也必须可以被struct对齐整除。&lt;em&gt;dtype项的&lt;/em&gt;总&lt;em&gt;大小&lt;/em&gt;限制为&lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt; &lt;code&gt;ctypes.c_int&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ed9f0881461d81b2f7af8ce5229589ca6d28abd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-dimensional FFT of real input.</source>
          <target state="translated">实数输入的&lt;em&gt;n&lt;/em&gt;维FFT。</target>
        </trans-unit>
        <trans-unit id="35066a9f7cb50260dfe6cd2d771163f62f1011ce" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">在&lt;em&gt;&amp;ntilde;&lt;/em&gt;维FFT。</target>
        </trans-unit>
        <trans-unit id="1f82e353fb8bee88c46f056efaf0e1b9b205e05a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;out&lt;/em&gt; argument to &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt; is not supported, &lt;code&gt;third&lt;/code&gt; has to be None.</source>
          <target state="translated">不支持&lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt;的&lt;em&gt;out&lt;/em&gt;参数， &lt;code&gt;third&lt;/code&gt; 必须为None。</target>
        </trans-unit>
        <trans-unit id="17d0c90784f11b0394d45b1939c2a01c10fdf407" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;shape&lt;/em&gt; is the fixed shape of the sub-array described by this data type, and &lt;em&gt;item_dtype&lt;/em&gt; the data type of the array.</source>
          <target state="translated">该&lt;em&gt;形状&lt;/em&gt;是由该数据类型所描述的子阵列的固定形状，并且&lt;em&gt;item_dtype&lt;/em&gt;阵列的数据类型。</target>
        </trans-unit>
        <trans-unit id="e35e90d2e4f0ba849a49c1795babe3ab2a9f08fe" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;side&lt;/em&gt; argument indicates whether the index returned should be that of the first suitable location (if &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt;) or of the last (if &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt;).</source>
          <target state="translated">所述&lt;em&gt;侧&lt;/em&gt;参数指示返回的索引是否应该是第一合适的位置的（如果 &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt; ）或最后的（如果 &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="099bc64f90d3db4f6c006d553b07493bf40349bd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sorter&lt;/em&gt; argument, if not &lt;code&gt;NULL&lt;/code&gt;, must be a 1D array of integer indices the same length as &lt;em&gt;self&lt;/em&gt;, that sorts it into ascending order. This is typically the result of a call to &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt;&lt;code&gt;PyArray_ArgSort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) Binary search is used to find the required insertion points.</source>
          <target state="translated">在&lt;em&gt;分选器&lt;/em&gt;的参数，如果不是 &lt;code&gt;NULL&lt;/code&gt; ，必须是整数索引的一维数组的长度相同&lt;em&gt;自我&lt;/em&gt;，即排序成升序排列。这通常是调用&lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt; &lt;code&gt;PyArray_ArgSort&lt;/code&gt; &lt;/a&gt;（...）的结果。二进制搜索用于查找所需的插入点。</target>
        </trans-unit>
        <trans-unit id="9171c42e0d10b56599a94002523d8b2e0c0e8b3e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;.npy&lt;/strong&gt; and &lt;strong&gt;.npz&lt;/strong&gt; files store data, shape, dtype, and other information required to reconstruct the ndarray in a way that allows the array to be correctly retrieved, even when the file is on another machine with different architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a635945c029e67349a5e1c329cf33ef8efa9b4ec" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;dots&lt;/strong&gt; (&lt;code&gt;...&lt;/code&gt;) represent as many colons as needed to produce a complete indexing tuple. For example, if &lt;code&gt;x&lt;/code&gt; is an array with 5 axes, then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fad9b84d117a49a76f66aa7359451abb9299209" translate="yes" xml:space="preserve">
          <source>The API exposed by NumPy for third-party extensions has grown over years of releases, and has allowed programmers to directly access NumPy functionality from C. This API can be best described as &amp;ldquo;organic&amp;rdquo;. It has emerged from multiple competing desires and from multiple points of view over the years, strongly influenced by the desire to make it easy for users to move to NumPy from Numeric and Numarray. The core API originated with Numeric in 1995 and there are patterns such as the heavy use of macros written to mimic Python&amp;rsquo;s C-API as well as account for compiler technology of the late 90&amp;rsquo;s. There is also only a small group of volunteers who have had very little time to spend on improving this API.</source>
          <target state="translated">NumPy公开的用于第三方扩展的API已经增长了许多年，并且允许程序员直接从C访问NumPy功能。此API最好描述为&amp;ldquo;有机&amp;rdquo;。多年来，它已经从多种竞争需求和多种观点中脱颖而出，强烈地受到了使用户易于从Numeric和Numarray迁移到NumPy的渴望的影响。核心API起源于Numeric于1995年，其模式有很多，例如大量使用模仿Python的C-API编写的宏以及90年代后期的编译器技术。也只有一小部分志愿者花很少的时间来改善此API。</target>
        </trans-unit>
        <trans-unit id="00284168716cc312202174053f58f3f176efd9f0" translate="yes" xml:space="preserve">
          <source>The Array Interface</source>
          <target state="translated">阵列接口</target>
        </trans-unit>
        <trans-unit id="0126a67e2a45442b450ea70b10470e175bf968af" translate="yes" xml:space="preserve">
          <source>The Bartlett window is defined as</source>
          <target state="translated">Bartlett窗口定义为</target>
        </trans-unit>
        <trans-unit id="937ca2e1b9d54c371bf73ce20e57493839ccf829" translate="yes" xml:space="preserve">
          <source>The Bartlett window is very similar to a triangular window, except that the end points are at zero. It is often used in signal processing for tapering a signal, without generating too much ripple in the frequency domain.</source>
          <target state="translated">巴特利特窗与三角窗非常相似,只是端点在零点。在信号处理中,它经常被用来对信号进行渐变,而不会在频域内产生过多的波纹。</target>
        </trans-unit>
        <trans-unit id="a093f7952b1838c4dd6aeda28ea5e1fc38030960" translate="yes" xml:space="preserve">
          <source>The Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c87b609239622a7f33fd7054a79bbe3b69d99bf" translate="yes" xml:space="preserve">
          <source>The Beta distribution is a special case of the Dirichlet distribution, and is related to the Gamma distribution. It has the probability distribution function</source>
          <target state="translated">Beta分布是Dirichlet分布的一种特例,与Gamma分布有关。它的概率分布函数为</target>
        </trans-unit>
        <trans-unit id="2fd0f76d8d8eab0518886bc71aed9b0148fca33e" translate="yes" xml:space="preserve">
          <source>The BitGenerator can also be directly accessed using the members of the &lt;code&gt;bitgen_t&lt;/code&gt; struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b111fe41355b271c80f9d028d2e71b1df692e910" translate="yes" xml:space="preserve">
          <source>The BitGenerator can also be directly accessed using the members of the basic RNG structure.</source>
          <target state="translated">也可以使用基本RNG结构的成员直接访问BitGenerator。</target>
        </trans-unit>
        <trans-unit id="fe9a0ff0e1aba5f3307dd340548f412e309bd12d" translate="yes" xml:space="preserve">
          <source>The BitGenerators have been designed to be extendable using standard tools for high-performance Python &amp;ndash; numba and Cython. The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; object can also be used with user-provided BitGenerators as long as these export a small set of required functions.</source>
          <target state="translated">BitGenerators设计为可使用用于高性能Python的标准工具numba和Cython进行扩展。该&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt;目的也可以使用用户提供的BitGenerators使用，只要这些出口一小部分的所需功能。</target>
        </trans-unit>
        <trans-unit id="d038e7d7a9d5b6013d6bf710bb0f42c26b9ffb86" translate="yes" xml:space="preserve">
          <source>The Blackman window is a taper formed by using the first three terms of a summation of cosines. It was designed to have close to the minimal leakage possible. It is close to optimal, only slightly worse than a Kaiser window.</source>
          <target state="translated">布莱克曼窗是利用余弦相加的前三个项形成的锥度。它被设计为具有接近于最小的泄漏可能。它接近于最佳状态,只比凯撒窗稍差。</target>
        </trans-unit>
        <trans-unit id="df8aff554aa2b04bd579ded0666721d3f45ae21e" translate="yes" xml:space="preserve">
          <source>The Blackman window is defined as</source>
          <target state="translated">布莱克曼窗口定义为</target>
        </trans-unit>
        <trans-unit id="b108efac05f697f2e430596f72b3bb61068c8903" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using &lt;code&gt;Generator&lt;/code&gt; for the normal distribution or any other distribution that relies on the normal such as the &lt;a href=&quot;generated/numpy.random.generator.gamma#numpy.random.Generator.gamma&quot;&gt;&lt;code&gt;Generator.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.generator.standard_t#numpy.random.Generator.standard_t&quot;&gt;&lt;code&gt;Generator.standard_t&lt;/code&gt;&lt;/a&gt;. If you require bitwise backward compatible streams, use &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, i.e., &lt;a href=&quot;generated/numpy.random.randomstate.gamma#numpy.random.RandomState.gamma&quot;&gt;&lt;code&gt;RandomState.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.randomstate.standard_t#numpy.random.RandomState.standard_t&quot;&gt;&lt;code&gt;RandomState.standard_t&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201133c822c73c7e6eedbd7735bf455db76c868e" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using &lt;code&gt;Generator&lt;/code&gt; for the normal distribution or any other distribution that relies on the normal such as the &lt;code&gt;gamma&lt;/code&gt; or &lt;code&gt;standard_t&lt;/code&gt;. If you require bitwise backward compatible streams, use &lt;code&gt;RandomState&lt;/code&gt;.</source>
          <target state="translated">用于生成NumPy法线的Box-Muller方法在&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 中&lt;/a&gt;不再可用。使用 &lt;code&gt;Generator&lt;/code&gt; 不能针对正态分布或依赖于法线的任何其他分布（例如 &lt;code&gt;gamma&lt;/code&gt; 或 &lt;code&gt;standard_t&lt;/code&gt; )使用精确的随机值进行再现。如果需要按位向后兼容的流，请使用 &lt;code&gt;RandomState&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="530afb1a91925fe435a9294f8360e96b319ffb64" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using Generator for the normal distribution or any other distribution that relies on the normal such as the &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.gamma#numpy.random.mtrand.RandomState.gamma&quot;&gt;&lt;code&gt;RandomState.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.standard_t#numpy.random.mtrand.RandomState.standard_t&quot;&gt;&lt;code&gt;RandomState.standard_t&lt;/code&gt;&lt;/a&gt;. If you require bitwise backward compatible streams, use &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于生成NumPy法线的Box-Muller方法在&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 中&lt;/a&gt;不再可用。使用Generator不能为正态分布或任何其他依赖于正态的分布（例如&lt;a href=&quot;generated/numpy.random.mtrand.randomstate.gamma#numpy.random.mtrand.RandomState.gamma&quot;&gt; &lt;code&gt;RandomState.gamma&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;generated/numpy.random.mtrand.randomstate.standard_t#numpy.random.mtrand.RandomState.standard_t&quot;&gt; &lt;code&gt;RandomState.standard_t&lt;/code&gt; )&lt;/a&gt;再现精确的随机值。如果需要按位向后兼容的流，请使用&lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21ca435d6d38aadf77947319cb2cc6cd824fa4fc" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using Generator for the normal distribution or any other distribution that relies on the normal such as the &lt;a href=&quot;generated/numpy.random.randomstate.gamma#numpy.random.RandomState.gamma&quot;&gt;&lt;code&gt;RandomState.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.randomstate.standard_t#numpy.random.RandomState.standard_t&quot;&gt;&lt;code&gt;RandomState.standard_t&lt;/code&gt;&lt;/a&gt;. If you require bitwise backward compatible streams, use &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ca8f1d4aa8ba16007dde802489e6ef41f52bf0" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available.</source>
          <target state="translated">用于生成NumPy法线的Box-Muller方法不再可用。</target>
        </trans-unit>
        <trans-unit id="2ae4a149c67359ea20a856b43946c0a1b6f16635" translate="yes" xml:space="preserve">
          <source>The Broadcasting Rule</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9895a5af5b1d937c582f3977255f2f51e2fa8cde" translate="yes" xml:space="preserve">
          <source>The C ABI version number in numpy/core/setup_common.py should only be updated for a major release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f1ca425ef21b0d3713606817fa90d6d2d43ef46" translate="yes" xml:space="preserve">
          <source>The C API version needs to be tracked in three places</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c85becd504bcc9e1840ed9b25393915f66f319" translate="yes" xml:space="preserve">
          <source>The C code to be wrapped for argoutview arrays are characterized by pointers: pointers to the dimensions and double pointers to the data, so that these values can be passed back to the user. The argoutview typemap signatures are therefore</source>
          <target state="translated">argoutview数组要封装的C代码的特点是指针:指向维度的指针和指向数据的双指针,因此这些值可以传回给用户。因此,argoutview的类型映射签名为</target>
        </trans-unit>
        <trans-unit id="21de11f0f6aeb101275d43918daa34e6c36dce23" translate="yes" xml:space="preserve">
          <source>The C file is given below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce59a78e88c7f509dea5f34f975be44fdfb7e3ba" translate="yes" xml:space="preserve">
          <source>The C file is given below. The ufunc generated takes two arguments A and B. It returns a tuple whose first element is A*B and whose second element is logit(A*B). Note that it automatically supports broadcasting, as well as all other properties of a ufunc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b86dcfa016c911d4342c93c728710eb6da34647" translate="yes" xml:space="preserve">
          <source>The C-API is actually an array of function pointers. This array is created (and pointed to by a global variable) by import_ufunc. The global variable is either statically defined or allowed to be seen by other files depending on the state of &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt;&lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C-API实际上是一个函数指针数组。此数组由import_ufunc创建（并由全局变量指向）。根据&lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt; &lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt; &lt;/a&gt;的状态，全局变量是静态定义的，还是允许其他文件查看。</target>
        </trans-unit>
        <trans-unit id="96e666c1c0b5a663da4c4f946173e189e8d49d4f" translate="yes" xml:space="preserve">
          <source>The C-code generated by Cython is hard to read and modify (and typically compiles with annoying but harmless warnings).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ac48dd933ed72b23987767613d8001cf662454" translate="yes" xml:space="preserve">
          <source>The C-structure corresponding to an object of &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; is used to keep track of a pointer into an N-dimensional array. It contains associated information used to quickly march through the array. The pointer can be adjusted in three basic ways: 1) advance to the &amp;ldquo;next&amp;rdquo; position in the array in a C-style contiguous fashion, 2) advance to an arbitrary N-dimensional coordinate in the array, and 3) advance to an arbitrary one-dimensional index into the array. The members of the &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure are used in these calculations. Iterator objects keep their own dimension and strides information about an array. This can be adjusted as needed for &amp;ldquo;broadcasting,&amp;rdquo; or to loop over only specific dimensions.</source>
          <target state="translated">对应于&lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; &lt;/a&gt;对象的C结构是&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;。所述&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;被用于跟踪的指针的成N维阵列。它包含用于快速遍历阵列的关联信息。可以通过三种基本方式来调整指针：1）以C样式的连续方式前进到数组中的&amp;ldquo;下一个&amp;rdquo;位置； 2）前进到数组中任意N维坐标，以及3）前进到数组中的任意N维坐标。数组中的任意一维索引。&lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;的成员这些计算中使用结构。迭代器对象保留其自己的尺寸，并遍历有关数组的信息。可以根据需要进行&amp;ldquo;广播&amp;rdquo;调整，也可以仅在特定尺寸上循环播放。</target>
        </trans-unit>
        <trans-unit id="5b65035b5e2ef1f9ddd680e8269d8b6e8cd78edf" translate="yes" xml:space="preserve">
          <source>The C-structure corresponding to an object of &lt;a href=&quot;#c.PyArrayNeighborhoodIter_Type&quot;&gt;&lt;code&gt;PyArrayNeighborhoodIter_Type&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;#c.PyArrayNeighborhoodIterObject&quot;&gt;&lt;code&gt;PyArrayNeighborhoodIterObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对应于&lt;a href=&quot;#c.PyArrayNeighborhoodIter_Type&quot;&gt; &lt;code&gt;PyArrayNeighborhoodIter_Type&lt;/code&gt; &lt;/a&gt;对象的C结构是&lt;a href=&quot;#c.PyArrayNeighborhoodIterObject&quot;&gt; &lt;code&gt;PyArrayNeighborhoodIterObject&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b70a592ea3e52c944c4250fca143b3a7150ee3c2" translate="yes" xml:space="preserve">
          <source>The Cauchy distribution arises in the solution to the driven harmonic oscillator problem, and also describes spectral line broadening. It also describes the distribution of values at which a line tilted at a random angle will cut the x axis.</source>
          <target state="translated">Cauchy分布是在解决驱动谐波振荡器问题时产生的,也描述了谱线拓宽。它还描述了以随机角度倾斜的线将切断x轴的值的分布。</target>
        </trans-unit>
        <trans-unit id="7e16b7bac76fd95a18826e75104c29f03fcae229" translate="yes" xml:space="preserve">
          <source>The Chebyshev class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the methods listed below.</source>
          <target state="translated">Chebyshev类提供标准的Python数值方法'+'，'-'，'*'，'//'，'％'，'divmod'，'**'和'（）'以及列出的方法下面。</target>
        </trans-unit>
        <trans-unit id="c6a112ce3f849b264d8d346313df28993dc02ff9" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the first kind are the points &lt;code&gt;cos(x)&lt;/code&gt;, where &lt;code&gt;x = [pi*(k + .5)/npts for k in range(npts)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b0a900a5e45540387f1b83ea73e67c934d19eae" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the first kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca4f0f30abc65b046f7d9e6e691b51c78603fec0" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the second kind are the points &lt;code&gt;cos(x)&lt;/code&gt;, where &lt;code&gt;x = [pi*k/(npts - 1) for k in range(npts)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196d20b8bbd6f4729eb062a203e433edbc71fdcc" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the second kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18aa36d5e6637359f0f8c985312900157e497010" translate="yes" xml:space="preserve">
          <source>The Chebyshev polynomials used in the interpolation are orthogonal when sampled at the Chebyshev points of the first kind. If it is desired to constrain some of the coefficients they can simply be set to the desired value after the interpolation, no new interpolation or fit is needed. This is especially useful if it is known apriori that some of coefficients are zero. For instance, if the function is even then the coefficients of the terms of odd degree in the result can be set to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993466511b9f370f4f72797c543b0fe46fcac4af" translate="yes" xml:space="preserve">
          <source>The Chebyshev series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Chebyshev系列基础多项式不是 &lt;code&gt;x&lt;/code&gt; 的幂，因此此函数的结果似乎不直观。</target>
        </trans-unit>
        <trans-unit id="46d5d357969a2c2d8e943734dcd70f209f532e7d" translate="yes" xml:space="preserve">
          <source>The Cholesky decomposition is often used as a fast way of solving</source>
          <target state="translated">Cholesky分解法经常被用来作为快速解决</target>
        </trans-unit>
        <trans-unit id="794b3c9b410012bd85aeaac5a58c341f1529d513" translate="yes" xml:space="preserve">
          <source>The Code of Conduct Committee should aim to have a resolution agreed upon within two weeks. In the event that a resolution can&amp;rsquo;t be determined in that time, the committee will respond to the reporter(s) with an update and projected timeline for resolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5489514988058a36fb9ae08de6595979ec21a6" translate="yes" xml:space="preserve">
          <source>The Code of Conduct Committee will formally review and sign off on all cases where this mechanism has been applied to make sure it is not being used to control ordinary heated disagreement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3bda4dc5a743a992fdb89cad8080af0867b844" translate="yes" xml:space="preserve">
          <source>The Council can create subcommittees that provide leadership and guidance for specific aspects of the project. Like the Council as a whole, subcommittees should conduct their business in an open and public manner unless privacy is specifically called for. Private subcommittee communications should happen on the main private mailing list of the Council unless specifically called for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cca4e29456fdc96aaa3058f6b88f125bd4fb528" translate="yes" xml:space="preserve">
          <source>The Council reserves the right to eject current Members, if they are deemed to be actively harmful to the project&amp;rsquo;s well-being, and attempts at communication and conflict resolution have failed. This requires the consensus of the remaining Members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777c1bc322cb9c22bf40b3217235aef27f1cd1cf" translate="yes" xml:space="preserve">
          <source>The Council will maintain one narrowly focused subcommittee to manage its interactions with NumFOCUS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7319ec02e3cbbaab7add308cd0a417516f369a3b" translate="yes" xml:space="preserve">
          <source>The DFT is defined, with the conventions used in this implementation, in the documentation for the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">使用此实现中使用的约定在&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt;模块的文档中定义了DFT。</target>
        </trans-unit>
        <trans-unit id="c850428d828f95dc2c92af14d3b7a369fbb6f873" translate="yes" xml:space="preserve">
          <source>The DFT is in general defined for complex inputs and outputs, and a single-frequency component at linear frequency</source>
          <target state="translated">一般来说,DFT是针对复杂的输入和输出而定义的,在线性频率下的单频分量。</target>
        </trans-unit>
        <trans-unit id="e1f0dbe8081449397bad0aa2cc6ad0fe41215d23" translate="yes" xml:space="preserve">
          <source>The Datetime and Timedelta data types support a large number of time units, as well as generic units which can be coerced into any of the other units based on input data.</source>
          <target state="translated">Datetime和Timedelta数据类型支持大量的时间单位,以及通用单位,这些单位可以根据输入数据被强制成任何其他单位。</target>
        </trans-unit>
        <trans-unit id="fcc8fbde1f068047c588e86f64b1d9bca100dc12" translate="yes" xml:space="preserve">
          <source>The Dirichlet distribution is a distribution over vectors</source>
          <target state="translated">Dirichlet分布是一个在向量上的分布。</target>
        </trans-unit>
        <trans-unit id="a4edf1637ded5c0257b8e49c407baa1302046498" translate="yes" xml:space="preserve">
          <source>The Einstein summation convention can be used to compute many multi-dimensional, linear algebraic array operations. &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; provides a succinct way of representing these.</source>
          <target state="translated">爱因斯坦求和约定可用于计算许多多维的线性代数数组运算。&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt;提供了一种简洁的表示方式。</target>
        </trans-unit>
        <trans-unit id="28b073ac0a61d366802edc13aac74cfca673e0d2" translate="yes" xml:space="preserve">
          <source>The Euler constant</source>
          <target state="translated">欧拉常数</target>
        </trans-unit>
        <trans-unit id="e516b8e0c93fdf83378c5af74b4c3f11ab8b2eec" translate="yes" xml:space="preserve">
          <source>The F statistic is used to compare in-group variances to between-group variances. Calculating the distribution depends on the sampling, and so it is a function of the respective degrees of freedom in the problem. The variable &lt;code&gt;dfnum&lt;/code&gt; is the number of samples minus one, the between-groups degrees of freedom, while &lt;code&gt;dfden&lt;/code&gt; is the within-groups degrees of freedom, the sum of the number of samples in each group minus the number of groups.</source>
          <target state="translated">F统计量用于比较组内方差与组间方差。计算分布取决于采样，因此它是问题中各个自由度的函数。变量 &lt;code&gt;dfnum&lt;/code&gt; 是样本数减去一，即组间自由度，而 &lt;code&gt;dfden&lt;/code&gt; 是组内自由度，即每组样本数的总和减去组数。</target>
        </trans-unit>
        <trans-unit id="ec341083311bc5d9e93dc0e719289499e7876f9f" translate="yes" xml:space="preserve">
          <source>The F2PY interface to Fortran 90 module data is similar to Fortran 77 common blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="255611abe871551a6f0d10449c721d9ac320d3a5" translate="yes" xml:space="preserve">
          <source>The Frobenius norm is given by &lt;a href=&quot;#rac1c834adb66-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="translated">Frobenius范数由&lt;a href=&quot;#rac1c834adb66-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;给出：</target>
        </trans-unit>
        <trans-unit id="4ebf7b4a74f003f8630476569ef53bec8c91caed" translate="yes" xml:space="preserve">
          <source>The GIL is released for all &lt;code&gt;np.einsum&lt;/code&gt; variations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7783b7563d5c19477bd0cec8f560b128f37ead00" translate="yes" xml:space="preserve">
          <source>The Gamma distribution is often used to model the times to failure of electronic components, and arises naturally in processes for which the waiting times between Poisson distributed events are relevant.</source>
          <target state="translated">Gamma分布经常被用来模拟电子元件的失效时间,并且自然而然地出现在与泊松分布事件之间的等待时间相关的过程中。</target>
        </trans-unit>
        <trans-unit id="9c990e445bfb7966adc1e3b9adac640f1e0e9113" translate="yes" xml:space="preserve">
          <source>The Generator&amp;rsquo;s normal, exponential and gamma functions use 256-step Ziggurat methods which are 2-10 times faster than NumPy&amp;rsquo;s Box-Muller or inverse CDF implementations.</source>
          <target state="translated">Generator的常规，指数和伽马函数使用256步Ziggurat方法，比NumPy的Box-Muller或CDF逆实现快2-10倍。</target>
        </trans-unit>
        <trans-unit id="5fd129bc188ef44c6bd32a38b068d9f3ddc783f7" translate="yes" xml:space="preserve">
          <source>The Gumbel (named for German mathematician Emil Julius Gumbel) was used very early in the hydrology literature, for modeling the occurrence of flood events. It is also used for modeling maximum wind speed and rainfall rates. It is a &amp;ldquo;fat-tailed&amp;rdquo; distribution - the probability of an event in the tail of the distribution is larger than if one used a Gaussian, hence the surprisingly frequent occurrence of 100-year floods. Floods were initially modeled as a Gaussian process, which underestimated the frequency of extreme events.</source>
          <target state="translated">Gumbel（以德国数学家Emil Julius Gumbel的名字命名）在水文学中很早就被用来模拟洪水事件的发生。它也用于建模最大风速和降雨量。这是一种&amp;ldquo;肥尾&amp;rdquo;分布-分布尾部发生事件的可能性大于使用高斯分布的情况，因此令人惊讶地频繁发生了100年的洪水。洪水最初被建模为高斯过程，这高估了极端事件的发生频率。</target>
        </trans-unit>
        <trans-unit id="aa1cbdb34f4d0d2f5ba482222c9284e53a83897b" translate="yes" xml:space="preserve">
          <source>The Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme Value Type I) distribution is one of a class of Generalized Extreme Value (GEV) distributions used in modeling extreme value problems. The Gumbel is a special case of the Extreme Value Type I distribution for maximums from distributions with &amp;ldquo;exponential-like&amp;rdquo; tails.</source>
          <target state="translated">Gumbel（或最小极值（SEV）或I最小极值类型）分布是用于建模极值问题的一类广义极值（GEV）分布之一。Gumbel是I极值类型分布的一种特例，用于从带有&amp;ldquo;指数状&amp;rdquo;尾部的分布中获得最大值。</target>
        </trans-unit>
        <trans-unit id="d38e3c533241c1cffef7a77e2fb316d839d0e953" translate="yes" xml:space="preserve">
          <source>The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and is described in Blackman and Tukey. It was recommended for smoothing the truncated autocovariance function in the time domain. Most references to the Hamming window come from the signal processing literature, where it is used as one of many windowing functions for smoothing values. It is also known as an apodization (which means &amp;ldquo;removing the foot&amp;rdquo;, i.e. smoothing discontinuities at the beginning and end of the sampled signal) or tapering function.</source>
          <target state="translated">Hamming以JW Tukey的合伙人RW Hamming的名字命名，并在Blackman和Tukey中进行了描述。建议在时域中平滑截断的自协方差函数。对汉明窗的大多数参考来自信号处理文献，在该文献中，汉明窗用作平滑值的许多窗函数之一。这也被称为切趾（apodization）（意思是&amp;ldquo;移开脚&amp;rdquo;，即在采样信号的开始和结束处平滑不连续点）或渐缩功能。</target>
        </trans-unit>
        <trans-unit id="f6f99a10c7b1d0ed496e360cabc47ad0e8b4f95f" translate="yes" xml:space="preserve">
          <source>The Hamming window is a taper formed by using a weighted cosine.</source>
          <target state="translated">汉明窗是利用加权余弦形成的锥度。</target>
        </trans-unit>
        <trans-unit id="c543c8775de7884a498fb8d25199a6da7865f313" translate="yes" xml:space="preserve">
          <source>The Hamming window is defined as</source>
          <target state="translated">汉明窗口定义为</target>
        </trans-unit>
        <trans-unit id="c53c036c06b914f30dfda36ac484fab584082b10" translate="yes" xml:space="preserve">
          <source>The Hanning was named for Julius von Hann, an Austrian meteorologist. It is also known as the Cosine Bell. Some authors prefer that it be called a Hann window, to help avoid confusion with the very similar Hamming window.</source>
          <target state="translated">汉宁号是以奥地利气象学家Julius von Hann的名字命名的。它也被称为余弦钟。有些作者喜欢把它称为汉恩窗,以避免与非常相似的汉明窗相混淆。</target>
        </trans-unit>
        <trans-unit id="ff9ff54dbcac5fb28018a438cebbfd23097afaae" translate="yes" xml:space="preserve">
          <source>The Hanning window is a taper formed by using a weighted cosine.</source>
          <target state="translated">汉宁窗是利用加权余弦形成的锥度。</target>
        </trans-unit>
        <trans-unit id="7063e81cb7e74fa0cdbf05d1c6333c059e7c5e09" translate="yes" xml:space="preserve">
          <source>The Hanning window is defined as</source>
          <target state="translated">汉宁窗口定义为</target>
        </trans-unit>
        <trans-unit id="48a86546760e1edd4295f33a270bba0337fe9c75" translate="yes" xml:space="preserve">
          <source>The Heaviside step function is defined as:</source>
          <target state="translated">Heaviside阶梯函数定义为:</target>
        </trans-unit>
        <trans-unit id="a4ab8a335073ed439b508ce34550cc0419ac6836" translate="yes" xml:space="preserve">
          <source>The Hermite class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Hermite类提供标准的Python数值方法'+'，'-'，'*'，'//'，'％'，'divmod'，'**'和'（）'以及属性和 &lt;code&gt;ABCPolyBase&lt;/code&gt; 文档中列出的方法。</target>
        </trans-unit>
        <trans-unit id="18c51c2fe8d0823ca52707c91973d012f1770684" translate="yes" xml:space="preserve">
          <source>The Hermite series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Hermite系列基础多项式不是 &lt;code&gt;x&lt;/code&gt; 的幂，因此此函数的结果似乎不直观。</target>
        </trans-unit>
        <trans-unit id="29f886dede3063b00d8467b1f756a147bc393097" translate="yes" xml:space="preserve">
          <source>The HermiteE class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">HermiteE类提供标准的Python数值方法'+'，'-'，'*'，'//'，'％'，'divmod'，'**'和'（）'以及属性和 &lt;code&gt;ABCPolyBase&lt;/code&gt; 文档中列出的方法。</target>
        </trans-unit>
        <trans-unit id="8cc8b1724a44c8d63d2cfd0d81bc585f17fc260c" translate="yes" xml:space="preserve">
          <source>The HermiteE series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">HermiteE系列基础多项式不是 &lt;code&gt;x&lt;/code&gt; 的幂，因此此函数的结果似乎不直观。</target>
        </trans-unit>
        <trans-unit id="d4c697a75ca6fe93876f5946baa1a9463872c64a" translate="yes" xml:space="preserve">
          <source>The IRR is perhaps best understood through an example (illustrated using np.irr in the Examples section below). Suppose one invests 100 units and then makes the following withdrawals at regular (fixed) intervals: 39, 59, 55, 20. Assuming the ending value is 0, one&amp;rsquo;s 100 unit investment yields 173 units; however, due to the combination of compounding and the periodic withdrawals, the &amp;ldquo;average&amp;rdquo; rate of return is neither simply 0.73/4 nor (1.73)^0.25-1. Rather, it is the solution (for</source>
          <target state="translated">可以通过一个示例（在下面的&amp;ldquo;示例&amp;rdquo;部分中使用np.irr进行说明）来最好地理解IRR。假设某人投资100个单位，然后以固定的（固定的）时间间隔进行以下提取：39、59、55、20。假设最终值为0，则某人的100个单位投资产生173个单位；然而，由于复利和定期提款的结合，&amp;ldquo;平均&amp;rdquo;回报率既不是简单的0.73 / 4也不是（1.73）^ 0.25-1。而是解决方案</target>
        </trans-unit>
        <trans-unit id="ddbfb62d79e442dbada344aa5b0b7d3f75bd62fd" translate="yes" xml:space="preserve">
          <source>The Kaiser can approximate many other windows by varying the beta parameter.</source>
          <target state="translated">凯撒可以通过改变β参数来近似其他许多窗口。</target>
        </trans-unit>
        <trans-unit id="61a6a7b7c0a7a3c07a636b9187a5aa5c8ed22e80" translate="yes" xml:space="preserve">
          <source>The Kaiser was named for Jim Kaiser, who discovered a simple approximation to the DPSS window based on Bessel functions. The Kaiser window is a very good approximation to the Digital Prolate Spheroidal Sequence, or Slepian window, which is the transform which maximizes the energy in the main lobe of the window relative to total energy.</source>
          <target state="translated">Kaiser是以Jim Kaiser命名的,他发现了一个基于Bessel函数的DPSS窗口的简单近似。Kaiser窗是数字普罗尔球体序列的一个非常好的近似,或者说是Slepian窗,它是相对于总能量而言,使窗口主叶的能量最大化的变换。</target>
        </trans-unit>
        <trans-unit id="3c47d6f84b8a7a5230ef01c3b24f485faf045505" translate="yes" xml:space="preserve">
          <source>The Kaiser window is a taper formed by using a Bessel function.</source>
          <target state="translated">凯撒窗是利用贝塞尔函数形成的锥度。</target>
        </trans-unit>
        <trans-unit id="d40317952ac62ac63be6a7eb42d8bb031447a844" translate="yes" xml:space="preserve">
          <source>The Kaiser window is defined as</source>
          <target state="translated">凯撒窗的定义为</target>
        </trans-unit>
        <trans-unit id="de389ba4bc7accb91ca973f3199d4d09bb36d074" translate="yes" xml:space="preserve">
          <source>The Laguerre class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Laguerre类提供标准的Python数值方法'+'，'-'，'*'，'//'，'％'，'divmod'，'**'和'（）'以及属性和 &lt;code&gt;ABCPolyBase&lt;/code&gt; 文档中列出的方法。</target>
        </trans-unit>
        <trans-unit id="673da347447c32096475798f43cd3eae37f1e962" translate="yes" xml:space="preserve">
          <source>The Laguerre series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Laguerre系列基础多项式不是 &lt;code&gt;x&lt;/code&gt; 的幂，因此此函数的结果似乎不直观。</target>
        </trans-unit>
        <trans-unit id="beacaa427ac9dd11f90d057bc9c94b6f47608f00" translate="yes" xml:space="preserve">
          <source>The Laplace distribution is similar to the Gaussian/normal distribution, but is sharper at the peak and has fatter tails. It represents the difference between two independent, identically distributed exponential random variables.</source>
          <target state="translated">拉普拉斯分布类似于高斯/正态分布,但其峰值更尖锐,尾部更粗。它表示两个独立的、相同分布的指数随机变量之间的差异。</target>
        </trans-unit>
        <trans-unit id="9f6965544802824fa340cc542a5a8e5ec41b1a8a" translate="yes" xml:space="preserve">
          <source>The Legendre class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Legendre类提供标准的Python数值方法'+'，'-'，'*'，'//'，'％'，'divmod'，'**'和'（）'以及属性和 &lt;code&gt;ABCPolyBase&lt;/code&gt; 文档中列出的方法。</target>
        </trans-unit>
        <trans-unit id="083c119f1df4d844bfc4b2160deea854a1daea76" translate="yes" xml:space="preserve">
          <source>The Legendre series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">勒让德级数基础多项式不是 &lt;code&gt;x&lt;/code&gt; 的幂，因此此函数的结果似乎不直观。</target>
        </trans-unit>
        <trans-unit id="191a6c01d66efbf4468b0c4b76d708edbb3efb30" translate="yes" xml:space="preserve">
          <source>The Logistic distribution is used in Extreme Value problems where it can act as a mixture of Gumbel distributions, in Epidemiology, and by the World Chess Federation (FIDE) where it is used in the Elo ranking system, assuming the performance of each player is a logistically distributed random variable.</source>
          <target state="translated">Logistic分布被用于极值问题中,它可以作为Gumbel分布的混合物,在流行病学中,世界棋联(FIDE)在Elo排名系统中使用它,假设每个棋手的表现是一个逻辑分布的随机变量。</target>
        </trans-unit>
        <trans-unit id="7e46f1b490ad93ea0aa4b70cea1c8217c1eeec4d" translate="yes" xml:space="preserve">
          <source>The Lomax or Pareto II distribution is a shifted Pareto distribution. The classical Pareto distribution can be obtained from the Lomax distribution by adding 1 and multiplying by the scale parameter &lt;code&gt;m&lt;/code&gt; (see Notes). The smallest value of the Lomax distribution is zero while for the classical Pareto distribution it is &lt;code&gt;mu&lt;/code&gt;, where the standard Pareto distribution has location &lt;code&gt;mu = 1&lt;/code&gt;. Lomax can also be considered as a simplified version of the Generalized Pareto distribution (available in SciPy), with the scale set to one and the location set to zero.</source>
          <target state="translated">Lomax或Pareto II分布是移位的Pareto分布。可以通过将Lomax分布加1并乘以比例参数 &lt;code&gt;m&lt;/code&gt; 来获得经典的Pareto分布（请参见注释）。Lomax分布的最小值为零，而经典Pareto分布的最小值为 &lt;code&gt;mu&lt;/code&gt; ，而标准Pareto分布的位置为 &lt;code&gt;mu = 1&lt;/code&gt; 。Lomax也可以被视为Generalized Pareto分布的简化版本（在SciPy中可用），比例设置为1，位置设置为零。</target>
        </trans-unit>
        <trans-unit id="913eec14ed443e489cdc77c2f2c24950a32724fd" translate="yes" xml:space="preserve">
          <source>The MATLAB &lt;code&gt;rem&lt;/code&gt; function and or the C &lt;code&gt;%&lt;/code&gt; operator which is the complement to &lt;code&gt;int(x1 / x2)&lt;/code&gt;.</source>
          <target state="translated">MATLAB &lt;code&gt;rem&lt;/code&gt; 函数和/或C &lt;code&gt;%&lt;/code&gt; 运算符，它是 &lt;code&gt;int(x1 / x2)&lt;/code&gt; 的补充。</target>
        </trans-unit>
        <trans-unit id="accc4f84d711af6e82c6efbbd034211d91d17fc7" translate="yes" xml:space="preserve">
          <source>The MaskedArray class</source>
          <target state="translated">MaskedArray类</target>
        </trans-unit>
        <trans-unit id="5110aa799914ad12dc0bd211beae0c5585bdbc96" translate="yes" xml:space="preserve">
          <source>The Matrix class</source>
          <target state="translated">矩阵类</target>
        </trans-unit>
        <trans-unit id="aae8587a9f8f2d6d760d4e3f9211a40fc1df3fef" translate="yes" xml:space="preserve">
          <source>The N-dimensional array (&lt;code&gt;ndarray&lt;/code&gt;)</source>
          <target state="translated">N维数组（ &lt;code&gt;ndarray&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ebbab7ca4ee7572bcfa080543866bf18ac7ca419" translate="yes" xml:space="preserve">
          <source>The N-dimensional array (ndarray)</source>
          <target state="translated">N维数组(ndarray)</target>
        </trans-unit>
        <trans-unit id="9062ffe94800b2d5eac1ade12a3d3195e3fb90d9" translate="yes" xml:space="preserve">
          <source>The NPV of the input cash flow series &lt;code&gt;values&lt;/code&gt; at the discount &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">输入现金流系列的NPV &lt;code&gt;values&lt;/code&gt; 的折现&lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb50b084062a9f4384d9b2a21c7bda6e285e1c12" translate="yes" xml:space="preserve">
          <source>The NumFOCUS Subcommittee is comprised of 5 persons who manage project funding that comes through NumFOCUS. It is expected that these funds will be spent in a manner that is consistent with the non-profit mission of NumFOCUS and the direction of the Project as determined by the full Council.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06341e3da348b45983c3d2e0a0cf15e91944f0fa" translate="yes" xml:space="preserve">
          <source>The NumPy 1.6 release includes a more primitive datetime data type than 1.7. This section documents many of the changes that have taken place.</source>
          <target state="translated">NumPy 1.6版本包含了比1.7更原始的数据时间类型。本节记录了许多已经发生的变化。</target>
        </trans-unit>
        <trans-unit id="5b56ea0dc221ea864b938eecd7f439b2151cafda" translate="yes" xml:space="preserve">
          <source>The NumPy &lt;code&gt;histogram&lt;/code&gt; function applied to an array returns a pair of vectors: the histogram of the array and a vector of the bin edges. Beware: &lt;code&gt;matplotlib&lt;/code&gt; also has a function to build histograms (called &lt;code&gt;hist&lt;/code&gt;, as in Matlab) that differs from the one in NumPy. The main difference is that &lt;code&gt;pylab.hist&lt;/code&gt; plots the histogram automatically, while &lt;code&gt;numpy.histogram&lt;/code&gt; only generates the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7115851ea78ca88c35b2190db524dfdbfb383870" translate="yes" xml:space="preserve">
          <source>The NumPy C coding conventions are based on Python PEP-0007 by Guido van Rossum with a few added strictures. There are many C coding conventions and it must be emphasized that the primary goal of the NumPy conventions isn&amp;rsquo;t to choose the &amp;lsquo;best&amp;rsquo;, about which there is certain to be disagreement, but to achieve uniformity. Because the NumPy conventions are very close to those in PEP-0007, that PEP is used as a template below with the NumPy additions and variations in the appropriate spots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04034fa7b7a5e94b567d768903257e06b83fadc3" translate="yes" xml:space="preserve">
          <source>The NumPy Project (The Project) is an open source software project affiliated with the 501(c)3 NumFOCUS Foundation. The goal of The Project is to develop open source software for array-based computing in Python, and in particular the &lt;code&gt;numpy&lt;/code&gt; package, along with related software such as &lt;code&gt;f2py&lt;/code&gt; and the NumPy Sphinx extensions. The Software developed by The Project is released under the BSD (or similar) open source license, developed openly and hosted on public GitHub repositories under the &lt;code&gt;numpy&lt;/code&gt; GitHub organization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318543629420726d92de226b61b0ea2568472ff7" translate="yes" xml:space="preserve">
          <source>The NumPy library contains multidimensional array and matrix data structures (you&amp;rsquo;ll find more information about this in later sections). It provides &lt;strong&gt;ndarray&lt;/strong&gt;, a homogeneous n-dimensional array object, with methods to efficiently operate on it. NumPy can be used to perform a wide variety of mathematical operations on arrays. It adds powerful data structures to Python that guarantee efficient calculations with arrays and matrices and it supplies an enormous library of high-level mathematical functions that operate on these arrays and matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22808a8257a77bd3771514110cd88913c8cbfe31" translate="yes" xml:space="preserve">
          <source>The NumPy linear algebra functions rely on BLAS and LAPACK to provide efficient low level implementations of standard linear algebra algorithms. Those libraries may be provided by NumPy itself using C versions of a subset of their reference implementations but, when possible, highly optimized libraries that take advantage of specialized processor functionality are preferred. Examples of such libraries are &lt;a href=&quot;https://www.openblas.net/&quot;&gt;OpenBLAS&lt;/a&gt;, MKL (TM), and ATLAS. Because those libraries are multithreaded and processor dependent, environmental variables and external packages such as &lt;a href=&quot;https://github.com/joblib/threadpoolctl&quot;&gt;threadpoolctl&lt;/a&gt; may be needed to control the number of threads or specify the processor architecture.</source>
          <target state="translated">NumPy线性代数函数依靠BLAS和LAPACK提供标准线性代数算法的有效低层实现。这些库可以由NumPy本身使用其参考实现的子集的C版本提供，但在可能的情况下，最好使用充分利用专用处理器功能的高度优化的库。此类库的示例是&lt;a href=&quot;https://www.openblas.net/&quot;&gt;OpenBLAS&lt;/a&gt;，MKL（TM）和ATLAS。由于这些库是多线程的，并且取决于处理器，因此可能需要环境变量和外部程序包（例如&lt;a href=&quot;https://github.com/joblib/threadpoolctl&quot;&gt;threadpoolctl）&lt;/a&gt;来控制线程数或指定处理器体系结构。</target>
        </trans-unit>
        <trans-unit id="d47a0c6ae88af6350c5a45d963a159c319eddcab" translate="yes" xml:space="preserve">
          <source>The NumPy project welcomes and encourages participation by everyone. We are committed to being a community that everyone enjoys being part of. Although we may not always be able to accommodate each individual&amp;rsquo;s preferences, we try our best to treat everyone kindly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3df208d2d18d19aa23dcbfeea9ad1c54e2544eb" translate="yes" xml:space="preserve">
          <source>The NumPy source code includes an example of a custom data-type as part of its test suite. The file &lt;code&gt;_rational_tests.c.src&lt;/code&gt; in the source code directory &lt;code&gt;numpy/numpy/core/src/umath/&lt;/code&gt; contains an implementation of a data-type that represents a rational number as the ratio of two 32 bit integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abe575872513074969d9820a4d531c3d12a22f7" translate="yes" xml:space="preserve">
          <source>The Pareto distribution must be greater than zero, and is unbounded above. It is also known as the &amp;ldquo;80-20 rule&amp;rdquo;. In this distribution, 80 percent of the weights are in the lowest 20 percent of the range, while the other 20 percent fill the remaining 80 percent of the range.</source>
          <target state="translated">帕累托分布必须大于零，并且在上方无界。它也被称为&amp;ldquo; 80-20规则&amp;rdquo;。在此分布中，80％的权重在范围的最低20％中，而其他20％占其余的80％。</target>
        </trans-unit>
        <trans-unit id="b64969899a77da87dee3d04492ed6838966132f3" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#r3973533a530a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc6e3f7c2b1acfa8159e10332ced928c3809746" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#r4338a4b3d731-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5b998678bc3c838f5d54a5f0beb5816b99470d" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#r8689274e67cd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">以意大利经济学家维尔弗雷多&amp;middot;帕累托（Vilfredo Pareto）的名字命名的帕累托分布是一种幂律概率分布，可用于许多现实世界中的问题。在经济学领域之外，通常将其称为Bradford分布。帕累托（Pareto）建立了分布来描述经济中财富的分布。还发现它可用于保险，网页访问统计，油田规模以及许多其他问题，包括Sourceforge &lt;a href=&quot;#r8689274e67cd-1&quot; id=&quot;id1&quot;&gt;[1]中&lt;/a&gt;项目的下载频率。它是所谓的&amp;ldquo;胖尾&amp;rdquo;分布之一。</target>
        </trans-unit>
        <trans-unit id="2867a07ee69e6406fe64c658305fdda7fb7b8075" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#rc338d9f74bfc-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">以意大利经济学家维尔弗雷多&amp;middot;帕累托（Vilfredo Pareto）的名字命名的帕累托分布是一种幂律概率分布，可用于许多现实世界中的问题。在经济学领域之外，通常将其称为Bradford分布。帕累托（Pareto）建立了分布来描述经济中财富的分布。还发现它可用于保险，网页访问统计，油田规模以及许多其他问题，包括Sourceforge &lt;a href=&quot;#rc338d9f74bfc-1&quot; id=&quot;id1&quot;&gt;[1]中&lt;/a&gt;项目的下载频率。它是所谓的&amp;ldquo;胖尾&amp;rdquo;分布之一。</target>
        </trans-unit>
        <trans-unit id="8aa87161535a17c7b4517b9679a26277a14402b5" translate="yes" xml:space="preserve">
          <source>The Poisson distribution</source>
          <target state="translated">泊松分布</target>
        </trans-unit>
        <trans-unit id="0ebdde94b2528198e1aa6a1394f362ff4a94706c" translate="yes" xml:space="preserve">
          <source>The Poisson distribution is the limit of the binomial distribution for large N.</source>
          <target state="translated">泊松分布是大N时二项分布的极限。</target>
        </trans-unit>
        <trans-unit id="9280ad29766a65718d4060a0ccabd4c148a5c905" translate="yes" xml:space="preserve">
          <source>The Polynomial class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Polynomial类提供标准的Python数值方法'+'，'-'，'*'，'//'，'％'，'divmod'，'**'和'（）'以及属性和 &lt;code&gt;ABCPolyBase&lt;/code&gt; 文档中列出的方法。</target>
        </trans-unit>
        <trans-unit id="ababcd2092c790cd48094defea5bb6fa5036c0d6" translate="yes" xml:space="preserve">
          <source>The Project</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd0ae31276093703b68264061cf438be92cd228" translate="yes" xml:space="preserve">
          <source>The Project Community consists of all Contributors and Users of the Project. Contributors work on behalf of and are responsible to the larger Project Community and we strive to keep the barrier between Contributors and Users as low as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d50f5379e9d76b5e7242532277a2b9c64fd49c0" translate="yes" xml:space="preserve">
          <source>The Project is developed by a team of distributed developers, called Contributors. Contributors are individuals who have contributed code, documentation, designs or other work to the Project. Anyone can be a Contributor. Contributors can be affiliated with any legal entity or none. Contributors participate in the project by submitting, reviewing and discussing GitHub Pull Requests and Issues and participating in open and public Project discussions on GitHub, mailing lists, and other channels. The foundation of Project participation is openness and transparency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c2647aef99f143f4382e220b44eada277008ef" translate="yes" xml:space="preserve">
          <source>The Project is formally affiliated with the 501(c)3 NumFOCUS Foundation (&lt;a href=&quot;http://numfocus.org&quot;&gt;http://numfocus.org&lt;/a&gt;), which serves as its fiscal sponsor, may hold project trademarks and other intellectual property, helps manage project donations and acts as a parent legal entity. NumFOCUS is the only legal entity that has a formal relationship with the project (see Institutional Partners section below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f211023ee392fd3cd9d9691f710a52d06a9bae2" translate="yes" xml:space="preserve">
          <source>The Project will have a Steering Council that consists of Project Contributors who have produced contributions that are substantial in quality and quantity, and sustained over at least one year. The overall role of the Council is to ensure, with input from the Community, the long-term well-being of the project, both technically and as a community.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="827ba55564ba45b324c36aacf3e17c27674e9dcd" translate="yes" xml:space="preserve">
          <source>The PyArrayInterface structure had no descr member at the end (and therefore no flag ARR_HAS_DESCR)</source>
          <target state="translated">PyArrayInterface结构的最后没有descr成员(因此没有标志ARR_HAS_DESCR)</target>
        </trans-unit>
        <trans-unit id="41d158f9c0cb59631db3742cfa40b5047248d25c" translate="yes" xml:space="preserve">
          <source>The PyArrayInterface structure is defined in &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; as:</source>
          <target state="translated">PyArrayInterface结构在 &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; 中定义为：</target>
        </trans-unit>
        <trans-unit id="5f9e4e5af356a67d9cce5fec6bebfc002a3fe5b0" translate="yes" xml:space="preserve">
          <source>The Python exposure supplies two iteration interfaces, one which follows the Python iterator protocol, and another which mirrors the C-style do-while pattern. The native Python approach is better in most cases, but if you need the coordinates or index of an iterator, use the C-style pattern.</source>
          <target state="translated">Python暴露提供了两个迭代接口,一个是遵循Python迭代器协议,另一个是镜像C风格的do-while模式。在大多数情况下,原生的Python方法更好,但如果你需要迭代器的坐标或索引,请使用C风格模式。</target>
        </trans-unit>
        <trans-unit id="52c071d4e6dd56561ca8fc870ab3c5e829454e91" translate="yes" xml:space="preserve">
          <source>The Python function &lt;code&gt;max()&lt;/code&gt; will find the maximum over a one-dimensional array, but it will do so using a slower sequence interface. The reduce method of the maximum ufunc is much faster. Also, the &lt;code&gt;max()&lt;/code&gt; method will not give answers you might expect for arrays with greater than one dimension. The reduce method of minimum also allows you to compute a total minimum over an array.</source>
          <target state="translated">Python函数 &lt;code&gt;max()&lt;/code&gt; 将在一维数组中找到最大值，但是它将使用较慢的序列接口来找到最大值。最大ufunc的reduce方法要快得多。另外， &lt;code&gt;max()&lt;/code&gt; 方法不会提供您对大于一维的数组可能期望的答案。最小值的reduce方法还允许您计算数组的总最小值。</target>
        </trans-unit>
        <trans-unit id="faf8bfa039d6b92e8c05db35a7f948162088fe3f" translate="yes" xml:space="preserve">
          <source>The Python interactive interpreter unfortunately prints out the values of expressions inside the while loop during each iteration of the loop. We have modified the output in the examples using this looping construct in order to be more readable.</source>
          <target state="translated">遗憾的是,Python交互式解释器在每次循环迭代的过程中,都会打印出while循环里面的表达式的值。我们使用这种循环结构修改了示例中的输出,以便使其更易读。</target>
        </trans-unit>
        <trans-unit id="4b9b366242a59401489f5a3a46b627dbab76f505" translate="yes" xml:space="preserve">
          <source>The Python interface that we want is:</source>
          <target state="translated">我们想要的Python接口是。</target>
        </trans-unit>
        <trans-unit id="a4e789fdc99a292c8a541209ecbc17b1d6c5f8c7" translate="yes" xml:space="preserve">
          <source>The Python iterator protocol doesn&amp;rsquo;t have a natural way to query these additional values from the iterator, so we introduce an alternate syntax for iterating with an &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;. This syntax explicitly works with the iterator object itself, so its properties are readily accessible during iteration. With this looping construct, the current value is accessible by indexing into the iterator, and the index being tracked is the property &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;multi_index&lt;/code&gt; depending on what was requested.</source>
          <target state="translated">Python迭代器协议没有从迭代器中查询这些&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt;的自然方法，因此我们引入了另一种语法，用于使用nditer进行迭代。该语法显式地与迭代器对象本身一起使用，因此在迭代过程中可以轻松访问其属性。使用这种循环结构，可以通过索引到迭代器中来访问当前值，并且所跟踪的索引是属性 &lt;code&gt;index&lt;/code&gt; 或 &lt;code&gt;multi_index&lt;/code&gt; ,具体取决于所请求的内容。</target>
        </trans-unit>
        <trans-unit id="6867d7144d35416337495ca1b602061770d80f10" translate="yes" xml:space="preserve">
          <source>The Python list representation of the masked array.</source>
          <target state="translated">掩码数组的Python列表表示。</target>
        </trans-unit>
        <trans-unit id="10730a9ceb03252e7c33bf729de07821aa7c70e5" translate="yes" xml:space="preserve">
          <source>The Python object this chunk of memory comes from. Needed so that memory can be accounted for properly.</source>
          <target state="translated">这块内存来自的 Python 对象。需要,这样才能正确计算内存。</target>
        </trans-unit>
        <trans-unit id="0d4a1c83a85c3f9ef90edda93dbe3641642446d4" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator with a number of methods that are similar to the ones available in &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0585dac865895f74c0e37d281119c6e2073a73" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator with a number of methods that are similar to the ones available in &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Python stdlib模块&amp;ldquo;随机&amp;rdquo;还包含Mersenne Twister伪随机数生成器，该生成器具有许多与&lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; 中&lt;/a&gt;可用的方法相似的方法。除了具有NumPy感知能力外，&lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt;还具有以下优点：它提供了更多的概率分布供您选择。</target>
        </trans-unit>
        <trans-unit id="e2bba830daa553cb7faa782d38dcb55b1552bd1f" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator.</source>
          <target state="translated">Python stdlib模块&amp;ldquo;随机&amp;rdquo;还包含Mersenne Twister伪随机数生成器。</target>
        </trans-unit>
        <trans-unit id="d16bb9351563ad26c9ac5328e3a25381d78f799b" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; contains pseudo-random number generator with a number of methods that are similar to the ones available in &lt;code&gt;Generator&lt;/code&gt;. It uses Mersenne Twister, and this bit generator can be accessed using &lt;code&gt;MT19937&lt;/code&gt;. &lt;code&gt;Generator&lt;/code&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Python stdlib模块&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt;包含伪随机数生成器，其中的许多方法类似于 &lt;code&gt;Generator&lt;/code&gt; 中可用的方法。它使用Mersenne Twister，并且可以使用 &lt;code&gt;MT19937&lt;/code&gt; 访问此位生成器。 &lt;code&gt;Generator&lt;/code&gt; 除了具有NumPy感知能力外，还具有提供大量概率分布可供选择的优势。</target>
        </trans-unit>
        <trans-unit id="da363cfdc7ce6e2caf650d00ffad698f370feca3" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &lt;a href=&quot;generated/numpy.random.random#numpy.random.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; contains pseudo-random number generator with a number of methods that are similar to the ones available in &lt;code&gt;Generator&lt;/code&gt;. It uses Mersenne Twister, and this bit generator can be accessed using &lt;code&gt;MT19937&lt;/code&gt;. &lt;code&gt;Generator&lt;/code&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbfe8c34ab4f057b17acc33f18a11bfdb2e17b46" translate="yes" xml:space="preserve">
          <source>The Python type of the ndarray is &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. In C, every ndarray is a pointer to a &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure. The ob_type member of this structure contains a pointer to the &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; typeobject.</source>
          <target state="translated">ndarray的Python类型是&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt;。在C语言中，每个ndarray都是指向&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;结构的指针。此结构的ob_type成员包含一个指向&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; 类型&lt;/a&gt;对象的指针。</target>
        </trans-unit>
        <trans-unit id="92e614f1f8b5e40429cf0717c65db8d5a132db4d" translate="yes" xml:space="preserve">
          <source>The Rayleigh distribution would arise, for example, if the East and North components of the wind velocity had identical zero-mean Gaussian distributions. Then the wind speed would have a Rayleigh distribution.</source>
          <target state="translated">例如,如果风速的东、北两部分具有相同的零均值高斯分布,就会出现雷利分布。那么风速就会有雷利分布。</target>
        </trans-unit>
        <trans-unit id="d73f8fe753523f4db33185ee7a9f4cc2e7b4d46f" translate="yes" xml:space="preserve">
          <source>The SciPy Code of Conduct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e766ac17c08bb4c8b9b072ff682fb439dd2765" translate="yes" xml:space="preserve">
          <source>The SciPy library also contains a &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt;&lt;code&gt;linalg&lt;/code&gt;&lt;/a&gt; submodule, and there is overlap in the functionality provided by the SciPy and NumPy submodules. SciPy contains functions not found in &lt;a href=&quot;#module-numpy.linalg&quot;&gt;&lt;code&gt;numpy.linalg&lt;/code&gt;&lt;/a&gt;, such as functions related to LU decomposition and the Schur decomposition, multiple ways of calculating the pseudoinverse, and matrix transcendentals such as the matrix logarithm. Some functions that exist in both have augmented functionality in &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt;&lt;code&gt;scipy.linalg&lt;/code&gt;&lt;/a&gt;. For example, &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eig.html#scipy.linalg.eig&quot;&gt;&lt;code&gt;scipy.linalg.eig&lt;/code&gt;&lt;/a&gt; can take a second matrix argument for solving generalized eigenvalue problems. Some functions in NumPy, however, have more flexible broadcasting options. For example, &lt;a href=&quot;generated/numpy.linalg.solve#numpy.linalg.solve&quot;&gt;&lt;code&gt;numpy.linalg.solve&lt;/code&gt;&lt;/a&gt; can handle &amp;ldquo;stacked&amp;rdquo; arrays, while &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve.html#scipy.linalg.solve&quot;&gt;&lt;code&gt;scipy.linalg.solve&lt;/code&gt;&lt;/a&gt; accepts only a single square array as its first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0175f443d47358199cf2723ff7e49526482ab828" translate="yes" xml:space="preserve">
          <source>The Simple Wrapper and Interface Generator (or &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;) is a powerful tool for generating wrapper code for interfacing to a wide variety of scripting languages. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; can parse header files, and using only the code prototypes, create an interface to the target language. But &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; is not omnipotent. For example, it cannot know from the prototype:</source>
          <target state="translated">Simple Wrapper和Interface Generator（或&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;）是一个强大的工具，用于生成用于与各种脚本语言接口的包装器代码。&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;可以解析头文件，并且仅使用代码原型创建目标语言的接口。但是&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;并不是万能的。例如，它不能从原型中知道：</target>
        </trans-unit>
        <trans-unit id="50fd73730ba7e10c720fa72fd00d9f7e0810994f" translate="yes" xml:space="preserve">
          <source>The Steering Council and its Members play a special role in certain situations. In particular, the Council may, if necessary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd611f012e4b731c3416db83b8b9fa4821f6de96" translate="yes" xml:space="preserve">
          <source>The Steering Council are the primary leadership for the project. No outside institution, individual or legal entity has the ability to own, control, usurp or influence the project other than by participating in the Project as Contributors and Council Members. However, because institutions can be an important funding mechanism for the project, it is important to formally acknowledge institutional participation in the project. These are Institutional Partners.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3486112e5f71acaa9b7cc7fff52d1dbfa7f50dd3" translate="yes" xml:space="preserve">
          <source>The Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where the last index is the power of &lt;code&gt;x&lt;/code&gt;. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">范德蒙矩阵。返回矩阵的形状为 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; ，其中最后一个索引是 &lt;code&gt;x&lt;/code&gt; 的幂。dtype将与转换后的 &lt;code&gt;x&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="39a7c567f58b9f21ca516451a55bb90e053dd395" translate="yes" xml:space="preserve">
          <source>The Weibull (or Type III asymptotic extreme value distribution for smallest values, SEV Type III, or Rosin-Rammler distribution) is one of a class of Generalized Extreme Value (GEV) distributions used in modeling extreme value problems. This class includes the Gumbel and Frechet distributions.</source>
          <target state="translated">Weibull(或最小值的III型渐进极值分布,SEV III型,或Rosin-Rammler分布)是一类用于极值问题建模的广义极值(GEV)分布之一。这类分布包括Gumbel分布和Frechet分布。</target>
        </trans-unit>
        <trans-unit id="201b34b560ffa9f638b13b95cb2b860322d162bb" translate="yes" xml:space="preserve">
          <source>The Zipf distribution (also known as the zeta distribution) is a continuous probability distribution that satisfies Zipf&amp;rsquo;s law: the frequency of an item is inversely proportional to its rank in a frequency table.</source>
          <target state="translated">Zipf分布（也称为zeta分布）是满足Zipf定律的连续概率分布：某项的频率与它在频率表中的排名成反比。</target>
        </trans-unit>
        <trans-unit id="9f96ae0b2c3d21dc0c18c679782e710a2d562c21" translate="yes" xml:space="preserve">
          <source>The __array_finalize__ method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8acfe985a2bfa5e5957d0281e0418889b56a0c2" translate="yes" xml:space="preserve">
          <source>The __array_priority__ attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c8638dacd7dbc859e55b29c8e0ee5d2ee1f9573" translate="yes" xml:space="preserve">
          <source>The __array_wrap__ method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb048510e93bd94f0172757e215cb9cb29cef573" translate="yes" xml:space="preserve">
          <source>The ability to be used as a context manager is new in NumPy v1.11.0.</source>
          <target state="translated">NumPy v1.11.0中新增了作为上下文管理器使用的功能。</target>
        </trans-unit>
        <trans-unit id="10ff963859461b5262a67238fd0cc7b697172b26" translate="yes" xml:space="preserve">
          <source>The above does not hold for in-place operators, for which &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; never returns &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt;. Hence, &lt;code&gt;arr += obj&lt;/code&gt; would always lead to a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. This is because for arrays in-place operations cannot generically be replaced by a simple reverse operation. (For instance, by default, &lt;code&gt;arr += obj&lt;/code&gt; would be translated to &lt;code&gt;arr =
arr + obj&lt;/code&gt;, i.e., &lt;code&gt;arr&lt;/code&gt; would be replaced, contrary to what is expected for in-place array operations.)</source>
          <target state="translated">上面的内容不适用于就地运算符，对于这些运算符，&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;永远不会返回&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt;。因此， &lt;code&gt;arr += obj&lt;/code&gt; 总是会导致&lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;。这是因为对于数组，就地操作通常不能用简单的反向操作代替。（例如，默认情况下， &lt;code&gt;arr += obj&lt;/code&gt; 将被转换为 &lt;code&gt;arr = arr + obj&lt;/code&gt; ，即，将 &lt;code&gt;arr&lt;/code&gt; 替换，这与就地数组操作所期望的相反。）</target>
        </trans-unit>
        <trans-unit id="68e86910bcee8988f5fee730ecb24162fd22e6a7" translate="yes" xml:space="preserve">
          <source>The above equation is not symmetric in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, so that &lt;code&gt;allclose(a, b)&lt;/code&gt; might be different from &lt;code&gt;allclose(b, a)&lt;/code&gt; in some rare cases.</source>
          <target state="translated">上面的方程在 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 中不是对称的，因此 &lt;code&gt;allclose(a, b)&lt;/code&gt; &lt;code&gt;allclose(b, a)&lt;/code&gt; 在某些罕见情况下可能与allclose（b，a）不同。</target>
        </trans-unit>
        <trans-unit id="6185045f653324c861d3553f34d55db24911888b" translate="yes" xml:space="preserve">
          <source>The above is &lt;strong&gt;not&lt;/strong&gt; true for advanced indexing.</source>
          <target state="translated">对于高级索引，以上内容&lt;strong&gt;不&lt;/strong&gt;适用。</target>
        </trans-unit>
        <trans-unit id="21db79b1f2f5936ea0ef3cfbbfc9697c308c56be" translate="yes" xml:space="preserve">
          <source>The above rules may be clearer in the following template source example:</source>
          <target state="translated">在下面的模板源例中,上述规则可能更加清晰。</target>
        </trans-unit>
        <trans-unit id="bbd30ffed27aefb02b7cc5cbecba164ede0884a8" translate="yes" xml:space="preserve">
          <source>The absolute tolerance parameter (see Notes).</source>
          <target state="translated">绝对公差参数(见注释)。</target>
        </trans-unit>
        <trans-unit id="b410151dc56a82d87375b78c87d1aad1438a967a" translate="yes" xml:space="preserve">
          <source>The absolute values of &lt;code&gt;x&lt;/code&gt;, the returned values are always floats. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的绝对值，返回值始终是浮点型的。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="a714cd42c4750db7daf108e375247bf95502ae46" translate="yes" xml:space="preserve">
          <source>The accumulate function is very similar to the reduce function in that the output and the second input both point to the output. The difference is that the second input points to memory one stride behind the current output pointer. Thus, the operation performed is</source>
          <target state="translated">累积函数与reduce函数非常相似,输出和第二个输入都指向输出。不同的是,第二个输入指向的内存比当前输出指针晚一个步长。因此,执行的操作是</target>
        </trans-unit>
        <trans-unit id="09fde86411dc88385ee0c9001b20e47aa778341c" translate="yes" xml:space="preserve">
          <source>The accumulated values. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">累计值。如果提供 &lt;code&gt;out&lt;/code&gt; ，则 &lt;code&gt;r&lt;/code&gt; 是对 &lt;code&gt;out&lt;/code&gt; 的引用。</target>
        </trans-unit>
        <trans-unit id="ea47ba00873e187022bea737541efbc8a18ba099" translate="yes" xml:space="preserve">
          <source>The actual object to check.</source>
          <target state="translated">要检查的实际对象。</target>
        </trans-unit>
        <trans-unit id="2c2156efeae8cdcc13e079cd68ed8ee62442ae55" translate="yes" xml:space="preserve">
          <source>The actual testing takes place with a Python script named:</source>
          <target state="translated">实际测试是通过一个名为Python的脚本进行的。</target>
        </trans-unit>
        <trans-unit id="b137bb987f3be59004e7fe6c03cebc2b50e503bc" translate="yes" xml:space="preserve">
          <source>The addition of an &lt;code&gt;axis&lt;/code&gt; keyword argument to methods such as &lt;a href=&quot;generated/numpy.random.generator.choice#numpy.random.Generator.choice&quot;&gt;&lt;code&gt;Generator.choice&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt;&lt;code&gt;Generator.permutation&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt;&lt;code&gt;Generator.shuffle&lt;/code&gt;&lt;/a&gt; improves support for sampling from and shuffling multi-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e611ef52ce3f87e2cae1cb595f38cf187d2711d5" translate="yes" xml:space="preserve">
          <source>The advanced indexes are all next to each other. For example &lt;code&gt;x[..., arr1, arr2, :]&lt;/code&gt; but &lt;em&gt;not&lt;/em&gt;&lt;code&gt;x[arr1, :, 1]&lt;/code&gt; since &lt;code&gt;1&lt;/code&gt; is an advanced index in this regard.</source>
          <target state="translated">高级索引彼此相邻。例如 &lt;code&gt;x[..., arr1, arr2, :]&lt;/code&gt; 但&lt;em&gt;不是&lt;/em&gt; &lt;code&gt;x[arr1, :, 1]&lt;/code&gt; 因为 &lt;code&gt;1&lt;/code&gt; 在这方面是高级索引。</target>
        </trans-unit>
        <trans-unit id="31c1e1991e0db334efbc077fcf4425ba78851bf7" translate="yes" xml:space="preserve">
          <source>The advanced indexes are separated by a slice, &lt;code&gt;Ellipsis&lt;/code&gt; or &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;. For example &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt;.</source>
          <target state="translated">先进的指标是通过切片，分离 &lt;code&gt;Ellipsis&lt;/code&gt; 或&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt;。例如 &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0943937a225e08eb4e31b510a59e3603b58c132" translate="yes" xml:space="preserve">
          <source>The advantage of the hand-generated wrapper is that you have complete control over how the C-library gets used and called which can lead to a lean and tight interface with minimal over-head. The disadvantage is that you have to write, debug, and maintain C-code, although most of it can be adapted using the time-honored technique of &amp;ldquo;cutting-pasting-and-modifying&amp;rdquo; from other extension modules. Because, the procedure of calling out to additional C-code is fairly regimented, code-generation procedures have been developed to make this process easier. One of these code-generation techniques is distributed with NumPy and allows easy integration with Fortran and (simple) C code. This package, f2py, will be covered briefly in the next section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d764668c927e5f32ce22801332fbd537f1d04076" translate="yes" xml:space="preserve">
          <source>The advantage of this creation function is that one can guarantee the number of elements and the starting and end point, which arange() generally will not do for arbitrary start, stop, and step values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51620b35cf3af304da0134bf0e98ad6e2d38905c" translate="yes" xml:space="preserve">
          <source>The advantage of this version of reduce compared to the normal ufunc.reduce is that it makes use of the &lt;a href=&quot;tentative_numpy_tutorial#head-c43f3f81719d84f09ae2b33a22eaf50b26333db8&quot;&gt;Broadcasting Rules&lt;/a&gt; in order to avoid creating an argument array the size of the output times the number of vectors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbeaf56d095a4acc2c96fd5080608f5dcf659b8a" translate="yes" xml:space="preserve">
          <source>The advantages over random generation include tools to replay and share failures without requiring a fixed seed, reporting &lt;em&gt;minimal&lt;/em&gt; examples for each failure, and better-than-naive-random techniques for triggering bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e14666a8704d081387416d669f25517240f5f545" translate="yes" xml:space="preserve">
          <source>The aim of this document is to describe how to add new tools to SciPy.</source>
          <target state="translated">本文档的目的是描述如何向SciPy添加新工具。</target>
        </trans-unit>
        <trans-unit id="ddbe83e4c507cabc5c6e4f89a6b5af846c612df5" translate="yes" xml:space="preserve">
          <source>The algorithm is carefully designed to eliminate a number of possible ways to collide. For example, if one only does one level of spawning, it is guaranteed that all states will be unique. But it&amp;rsquo;s easier to estimate the naive upper bound on a napkin and take comfort knowing that the probability is actually lower.</source>
          <target state="translated">该算法经过精心设计，消除了多种可能的碰撞方式。例如，如果仅执行一个级别的生成，则可以保证所有状态都是唯一的。但是，更容易估计餐巾纸上的天真上限，并知道该概率实际上较低，这会让您感到宽慰。</target>
        </trans-unit>
        <trans-unit id="31b40688fb93dbcbc32e9b43e4ccf1abfa448a2d" translate="yes" xml:space="preserve">
          <source>The algorithm relies on computing the eigenvalues of the companion matrix &lt;a href=&quot;#r01a8f58ef25b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">该算法依赖于计算伴随矩阵的特征值&lt;a href=&quot;#r01a8f58ef25b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ddd22305ce6ff69cc69c0e35a34dfdaaddbe6b6d" translate="yes" xml:space="preserve">
          <source>The algorithm works by first finding a &amp;ldquo;running dimension&amp;rdquo;, along which the blocks will be extracted. Given an array of dimensions &lt;code&gt;(d1, d2, ..., dn)&lt;/code&gt;, e.g. if &lt;code&gt;buf_size&lt;/code&gt; is smaller than &lt;code&gt;d1&lt;/code&gt;, the first dimension will be used. If, on the other hand, &lt;code&gt;d1 &amp;lt; buf_size &amp;lt; d1*d2&lt;/code&gt; the second dimension will be used, and so on. Blocks are extracted along this dimension, and when the last block is returned the process continues from the next dimension, until all elements have been read.</source>
          <target state="translated">该算法通过首先找到一个&amp;ldquo;运行维&amp;rdquo;来工作，沿着该维将提取块。给定维度数组 &lt;code&gt;(d1, d2, ..., dn)&lt;/code&gt; ，例如，如果 &lt;code&gt;buf_size&lt;/code&gt; 小于 &lt;code&gt;d1&lt;/code&gt; ，则将使用第一个维度。另一方面，如果 &lt;code&gt;d1 &amp;lt; buf_size &amp;lt; d1*d2&lt;/code&gt; ，则将使用第二维，依此类推。沿该维度提取块，并在返回最后一个块时，过程将从下一个维度继续进行，直到已读取所有元素。</target>
        </trans-unit>
        <trans-unit id="bddd09a9de7b4e7a6ce50c8c2ab936314f5f7ae0" translate="yes" xml:space="preserve">
          <source>The angle of the ray intersecting the unit circle at the given &lt;code&gt;x&lt;/code&gt;-coordinate in radians [0, pi]. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">在给定的 &lt;code&gt;x&lt;/code&gt; 坐标（弧度[0，pi]）下，射线与单位圆相交的角度。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="a13da23a8343744c8c54019aa364c899333968f0" translate="yes" xml:space="preserve">
          <source>The anti-diagonal can be filled by reversing the order of elements using either &lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt;&lt;code&gt;numpy.flipud&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt;&lt;code&gt;numpy.fliplr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt; &lt;code&gt;numpy.flipud&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt; &lt;code&gt;numpy.fliplr&lt;/code&gt; &lt;/a&gt;反转元素的顺序来填充反对角线。</target>
        </trans-unit>
        <trans-unit id="900a13fc7d937db8f345df515885761fbb0acd80" translate="yes" xml:space="preserve">
          <source>The anti-diagonal can be obtained by reversing the order of elements using either &lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt;&lt;code&gt;numpy.flipud&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt;&lt;code&gt;numpy.fliplr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以通过使用&lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt; &lt;code&gt;numpy.flipud&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt; &lt;code&gt;numpy.fliplr&lt;/code&gt; &lt;/a&gt;反转元素的顺序来获得反对角线。</target>
        </trans-unit>
        <trans-unit id="bdd6673496c6fd17d43bfb63694d67b1a23e7074" translate="yes" xml:space="preserve">
          <source>The approximate decimal resolution of this type, i.e., &lt;code&gt;10**-precision&lt;/code&gt;.</source>
          <target state="translated">此类型的近似十进制分辨率，即 &lt;code&gt;10**-precision&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6b2d49779da2fb225e5136c9ad3c68e119d3fee" translate="yes" xml:space="preserve">
          <source>The approximate number of decimal digits to which this kind of float is precise.</source>
          <target state="translated">这类浮点数精确到小数点后的约数。</target>
        </trans-unit>
        <trans-unit id="179dbf39b5fae7c06c4d27f6dfe6017b20eda9b8" translate="yes" xml:space="preserve">
          <source>The argument is considered as a return variable. It is appended to the &lt;code&gt;&amp;lt;returned variables&amp;gt;&lt;/code&gt; list. Using &lt;code&gt;intent(out)&lt;/code&gt; sets &lt;code&gt;intent(hide)&lt;/code&gt; automatically, unless also &lt;code&gt;intent(in)&lt;/code&gt; or &lt;code&gt;intent(inout)&lt;/code&gt; were used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c118204e070c804541b682daff7d70c7213a6696" translate="yes" xml:space="preserve">
          <source>The argument is considered as an input-only argument. It means that the value of the argument is passed to Fortran/C function and that function is expected not to change the value of an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7586639cfc35e105e2ea737d69664cf533fb71d1" translate="yes" xml:space="preserve">
          <source>The argument is considered as an input/output or &lt;em&gt;in situ&lt;/em&gt; output argument. &lt;code&gt;intent(inout)&lt;/code&gt; arguments can be only &amp;ldquo;contiguous&amp;rdquo; NumPy arrays with proper type and size. Here &amp;ldquo;contiguous&amp;rdquo; can be either in Fortran or C sense. The latter one coincides with the contiguous concept used in NumPy and is effective only if &lt;code&gt;intent(c)&lt;/code&gt; is used. Fortran contiguity is assumed by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="958b7637686a26352441daf916242ddf2818e972" translate="yes" xml:space="preserve">
          <source>The argument is considered as an input/output or &lt;em&gt;in situ&lt;/em&gt; output argument. &lt;code&gt;intent(inplace)&lt;/code&gt; arguments must be NumPy arrays with proper size. If the type of an array is not &amp;ldquo;proper&amp;rdquo; or the array is non-contiguous then the array will be changed in-place to fix the type and make it contiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f19b8026a1e189b122954edffa090fdbeb3a72f0" translate="yes" xml:space="preserve">
          <source>The argument is removed from the list of required or optional arguments. Typically &lt;code&gt;intent(hide)&lt;/code&gt; is used with &lt;code&gt;intent(out)&lt;/code&gt; or when &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; completely determines the value of the argument like in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898b40f4d53206c78d6c1d07150f357243064d8d" translate="yes" xml:space="preserve">
          <source>The argument is treated as a C scalar or C array argument. In the case of a scalar argument, its value is passed to C function as a C scalar argument (recall that Fortran scalar arguments are actually C pointer arguments). In the case of an array argument, the wrapper function is assumed to treat multidimensional arrays as C-contiguous arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f859808cd7ae59bcb9315c9be074383ed18866fa" translate="yes" xml:space="preserve">
          <source>The argument is treated as a junk of memory. No Fortran nor C contiguity checks are carried out. Using &lt;code&gt;intent(cache)&lt;/code&gt; makes sense only for array arguments, also in connection with &lt;code&gt;intent(hide)&lt;/code&gt; or &lt;code&gt;optional&lt;/code&gt; attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe8c5bbb5b2bd70ddad0ccf0217bddc268f6835" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;ngood&lt;/code&gt; and &lt;code&gt;nbad&lt;/code&gt; each must be less than &lt;code&gt;10**9&lt;/code&gt;. For extremely large arguments, the algorithm that is used to compute the samples &lt;a href=&quot;#r688e4aa3bfc3-4&quot; id=&quot;id1&quot;&gt;[4]&lt;/a&gt; breaks down because of loss of precision in floating point calculations. For such large values, if &lt;code&gt;nsample&lt;/code&gt; is not also large, the distribution can be approximated with the binomial distribution, &lt;code&gt;binomial(n=nsample, p=ngood/(ngood + nbad))&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;ngood&lt;/code&gt; 和 &lt;code&gt;nbad&lt;/code&gt; 都必须小于 &lt;code&gt;10**9&lt;/code&gt; 。对于极大的论点，由于浮点计算的精度损失，用于计算样本&lt;a href=&quot;#r688e4aa3bfc3-4&quot; id=&quot;id1&quot;&gt;[4]&lt;/a&gt;的算法崩溃了。对于这样的大值，如果 &lt;code&gt;nsample&lt;/code&gt; 也不太大，则可以使用二项式分布 &lt;code&gt;binomial(n=nsample, p=ngood/(ngood + nbad))&lt;/code&gt; 近似该分布。</target>
        </trans-unit>
        <trans-unit id="2d355dbffda7b60d25c8fd14c77261de1c537b59" translate="yes" xml:space="preserve">
          <source>The arguments of the &lt;code&gt;configuration&lt;/code&gt; function specify the name of parent SciPy package (&lt;code&gt;parent_package&lt;/code&gt;) and the directory location of the main &lt;code&gt;setup.py&lt;/code&gt; script (&lt;code&gt;top_path&lt;/code&gt;). These arguments, along with the name of the current package, should be passed to the &lt;code&gt;Configuration&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;configuration&lt;/code&gt; 函数的参数指定父SciPy包的名称（ &lt;code&gt;parent_package&lt;/code&gt; ）和主 &lt;code&gt;setup.py&lt;/code&gt; 脚本的目录位置（ &lt;code&gt;top_path&lt;/code&gt; ）。这些参数以及当前包的名称应传递给 &lt;code&gt;Configuration&lt;/code&gt; 构造函数。</target>
        </trans-unit>
        <trans-unit id="5e50719893eed3edf2e32e25c59bbd130545cd4a" translate="yes" xml:space="preserve">
          <source>The arguments that &lt;code&gt;__array_finalize__&lt;/code&gt; receives differ for the three methods of instance creation above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1212b40ba5f9b8205d7b64e2e9c20d35b415b3" translate="yes" xml:space="preserve">
          <source>The arithmetic mean is the sum of the elements along the axis divided by the number of elements.</source>
          <target state="translated">算术平均值是沿轴线的元素之和除以元素数。</target>
        </trans-unit>
        <trans-unit id="149dc5ada110e245afebc011f82badc7bfaf2c21" translate="yes" xml:space="preserve">
          <source>The arithmetic mean is the sum of the non-NaN elements along the axis divided by the number of non-NaN elements.</source>
          <target state="translated">算术平均数是沿轴线的非纳米元素之和除以非纳米元素的数量。</target>
        </trans-unit>
        <trans-unit id="893ac85ca56066bc9e23a82ef1519d73c4482726" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;v&lt;/code&gt; of eigenvectors may not be of maximum rank, that is, some of the columns may be linearly dependent, although round-off error may obscure that fact. If the eigenvalues are all different, then theoretically the eigenvectors are linearly independent and &lt;code&gt;a&lt;/code&gt; can be diagonalized by a similarity transformation using &lt;code&gt;v&lt;/code&gt;, i.e, &lt;code&gt;inv(v) @ a @ v&lt;/code&gt; is diagonal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a686d6fd794f1b48b235aeae1a3e22a10c775aa4" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;v&lt;/code&gt; of eigenvectors may not be of maximum rank, that is, some of the columns may be linearly dependent, although round-off error may obscure that fact. If the eigenvalues are all different, then theoretically the eigenvectors are linearly independent. Likewise, the (complex-valued) matrix of eigenvectors &lt;code&gt;v&lt;/code&gt; is unitary if the matrix &lt;code&gt;a&lt;/code&gt; is normal, i.e., if &lt;code&gt;dot(a, a.H) = dot(a.H, a)&lt;/code&gt;, where &lt;code&gt;a.H&lt;/code&gt; denotes the conjugate transpose of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">特征向量的数组 &lt;code&gt;v&lt;/code&gt; 可能没有最大秩，也就是说，某些列可能是线性相关的，尽管舍入误差可能会掩盖这一事实。如果特征值都不同，则理论上特征向量是线性独立的。同样，特征向量的（复值）矩阵 &lt;code&gt;v&lt;/code&gt; 是酉如果基质 &lt;code&gt;a&lt;/code&gt; 是正常的，即，如果 &lt;code&gt;dot(a, a.H) = dot(a.H, a)&lt;/code&gt; ，其中 &lt;code&gt;a.H&lt;/code&gt; 表示的共轭转置 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="539630988d5b7ef9eff53456e4a77b468fdbbd35" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;x&lt;/code&gt; is prefilled with its filling value.</source>
          <target state="translated">数组 &lt;code&gt;x&lt;/code&gt; 会预先填充其填充值。</target>
        </trans-unit>
        <trans-unit id="048ae46227673b90cff5c0388062d4ed48f2b030" translate="yes" xml:space="preserve">
          <source>The array assembled from the given blocks.</source>
          <target state="translated">由给定的块组合而成的数组。</target>
        </trans-unit>
        <trans-unit id="f6532b7ade94739e158787e37c1d9655afff859b" translate="yes" xml:space="preserve">
          <source>The array can be indexed using Python container-like syntax:</source>
          <target state="translated">数组可以使用类似Python容器的语法进行索引。</target>
        </trans-unit>
        <trans-unit id="a7b308d78b11f2c07c75c1db0756393dc3ae53a1" translate="yes" xml:space="preserve">
          <source>The array data-type or scalar for which the default fill value is returned.</source>
          <target state="translated">返回默认填充值的数组数据类型或标量。</target>
        </trans-unit>
        <trans-unit id="3821c84ea0df179e936beb82ec9c4a845023032b" translate="yes" xml:space="preserve">
          <source>The array element of the current iteration.</source>
          <target state="translated">当前迭代的数组元素。</target>
        </trans-unit>
        <trans-unit id="930ed301b34bfc297be655fe9a537d3e2971d137" translate="yes" xml:space="preserve">
          <source>The array flags cannot be set arbitrarily:</source>
          <target state="translated">阵列标志不能任意设置。</target>
        </trans-unit>
        <trans-unit id="67bdbd5d8bcbe5caab95cc4d4f8dabba43280775" translate="yes" xml:space="preserve">
          <source>The array for which the string representation of the pickle is returned.</source>
          <target state="translated">返回pickle的字符串表示的数组。</target>
        </trans-unit>
        <trans-unit id="2a33c6111cdd8f36d42a5e94437f624d1b58746f" translate="yes" xml:space="preserve">
          <source>The array for which to count non-zeros.</source>
          <target state="translated">要计算非零的数组。</target>
        </trans-unit>
        <trans-unit id="ceccbd318dae2746e4f8b98dac923588a6a52441" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays, will be at least 2-D.</source>
          <target state="translated">将给定的数组堆叠形成的数组,将至少是二维的。</target>
        </trans-unit>
        <trans-unit id="2568bf2e437e715b60f945dc9695881ce8ef667f" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays, will be at least 3-D.</source>
          <target state="translated">将给定的数组堆叠形成的数组,将至少是三维的。</target>
        </trans-unit>
        <trans-unit id="b2c061ec289a87d3c0d4e9e7c64e5126014d42ed" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays.</source>
          <target state="translated">由给定数组堆叠而成的数组。</target>
        </trans-unit>
        <trans-unit id="8e505b1ebbfcf9d9aa6a8f699f88f4ba40304f40" translate="yes" xml:space="preserve">
          <source>The array from which values are copied.</source>
          <target state="translated">复制值的数组。</target>
        </trans-unit>
        <trans-unit id="2d987760deb151bcafba733adc9b3a186c4d7f93" translate="yes" xml:space="preserve">
          <source>The array function protocol which allows array-like objects to hook into the NumPy API is currently enabled by default. This option exists since NumPy 1.16 and is enabled by default since NumPy 1.17. It can be disabled using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c8fb39bbbe950fa5ba32f6dec4764ff1752adf1" translate="yes" xml:space="preserve">
          <source>The array h contains the Householder reflectors that generate q along with r. The tau array contains scaling factors for the reflectors. In the deprecated &amp;lsquo;economic&amp;rsquo; mode only h is returned.</source>
          <target state="translated">数组h包含与q一起生成q的Householder反射器。 tau数组包含反射器的比例因子。在已弃用的&amp;ldquo;经济&amp;rdquo;模式下，仅返回h。</target>
        </trans-unit>
        <trans-unit id="d2932d4203636051c0cde3cab914ac5caf308f90" translate="yes" xml:space="preserve">
          <source>The array interface (sometimes called array protocol) was created in 2005 as a means for array-like Python objects to re-use each other&amp;rsquo;s data buffers intelligently whenever possible. The homogeneous N-dimensional array interface is a default mechanism for objects to share N-dimensional array memory and information. The interface consists of a Python-side and a C-side using two attributes. Objects wishing to be considered an N-dimensional array in application code should support at least one of these attributes. Objects wishing to support an N-dimensional array in application code should look for at least one of these attributes and use the information provided appropriately.</source>
          <target state="translated">数组接口（有时称为数组协议）创建于2005年，目的是使类似数组的Python对象在可能的情况下智能地重用彼此的数据缓冲区。同构N维数组接口是对象共享N维数组内存和信息的默认机制。该接口由使用两个属性的Python端和C端组成。希望在应用程序代码中被视为N维数组的对象应支持这些属性中的至少一个。希望在应用程序代码中支持N维数组的对象应查找这些属性中的至少一个，并使用适当提供的信息。</target>
        </trans-unit>
        <trans-unit id="3b7adbdac3eaf5c6305f1f61b91018f4287bec67" translate="yes" xml:space="preserve">
          <source>The array into which values are copied.</source>
          <target state="translated">复制值的数组。</target>
        </trans-unit>
        <trans-unit id="8a281d694c98742955f6444ee26a08d74603ea7a" translate="yes" xml:space="preserve">
          <source>The array is filled with a fill value before the string conversion.</source>
          <target state="translated">在字符串转换之前,数组中会填充一个填充值。</target>
        </trans-unit>
        <trans-unit id="fba8708c42061e69f757d72f0e5d1d004653f4bc" translate="yes" xml:space="preserve">
          <source>The array is rotated in the plane defined by the axes. Axes must be different.</source>
          <target state="translated">阵列在轴所定义的平面上旋转。轴必须是不同的。</target>
        </trans-unit>
        <trans-unit id="9a1223a8243cbae9aaa7753c7ea500a550cf52c0" translate="yes" xml:space="preserve">
          <source>The array iterator encapsulates many of the key features in ufuncs, allowing user code to support features like output parameters, preservation of memory layouts, and buffering of data with the wrong alignment or type, without requiring difficult coding.</source>
          <target state="translated">数组迭代器封装了ufuncs中的许多关键特性,允许用户代码支持输出参数、保存内存布局、缓冲错误对齐或类型的数据等特性,而不需要困难的编码。</target>
        </trans-unit>
        <trans-unit id="c6e1241b8c7d132ea91621f870c2bd3aaf572b4c" translate="yes" xml:space="preserve">
          <source>The array may be recreated via &lt;code&gt;a = np.array(a.tolist())&lt;/code&gt;, although this may sometimes lose precision.</source>
          <target state="translated">可以通过 &lt;code&gt;a = np.array(a.tolist())&lt;/code&gt; 重新创建数组，尽管有时可能会失去精度。</target>
        </trans-unit>
        <trans-unit id="1eee9d9d69514705c81523ac5b902691363a28a0" translate="yes" xml:space="preserve">
          <source>The array of UTC timestamps to format.</source>
          <target state="translated">要格式化的UTC时间戳数组。</target>
        </trans-unit>
        <trans-unit id="c75d57d539a00e02934380f0ab251d1c277b5e1c" translate="yes" xml:space="preserve">
          <source>The array of dates to process.</source>
          <target state="translated">要处理的日期数组。</target>
        </trans-unit>
        <trans-unit id="cc2f192e213603a4bcf402844b3339c10f79380e" translate="yes" xml:space="preserve">
          <source>The array of numbers for which the absolute values are required. If &lt;code&gt;x&lt;/code&gt; is a scalar, the result &lt;code&gt;y&lt;/code&gt; will also be a scalar.</source>
          <target state="translated">需要绝对值的数字数组。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则结果 &lt;code&gt;y&lt;/code&gt; 也将是标量。</target>
        </trans-unit>
        <trans-unit id="f9c4960d6bbbc8f2591cc039cfe68db4d8e24d90" translate="yes" xml:space="preserve">
          <source>The array of offsets, which is broadcast with &lt;code&gt;dates&lt;/code&gt;.</source>
          <target state="translated">偏移量数组，以 &lt;code&gt;dates&lt;/code&gt; 广播。</target>
        </trans-unit>
        <trans-unit id="2d674fe1383c12f697c52fd3b5198eb57b81bcb7" translate="yes" xml:space="preserve">
          <source>The array of rounded numbers</source>
          <target state="translated">四舍五入的数字阵列</target>
        </trans-unit>
        <trans-unit id="202adb7679573040b63e561db69df0e93b9eb75e" translate="yes" xml:space="preserve">
          <source>The array of the end dates for counting, which are excluded from the count themselves.</source>
          <target state="translated">计数的结束日期数组,该数组不包括计数本身。</target>
        </trans-unit>
        <trans-unit id="f508cbbca81c78d6c3819b4c01ca29622bef56f6" translate="yes" xml:space="preserve">
          <source>The array of the first dates for counting.</source>
          <target state="translated">用于计数的第一个日期的数组。</target>
        </trans-unit>
        <trans-unit id="a4e03a6eeebaef72c6a7e32f280b123bbf142ff2" translate="yes" xml:space="preserve">
          <source>The array or list to be shuffled.</source>
          <target state="translated">要洗牌的数组或列表。</target>
        </trans-unit>
        <trans-unit id="1f6abc9406bedaa275a3843a6290b585462b97a3" translate="yes" xml:space="preserve">
          <source>The array or matrix to be repeated.</source>
          <target state="translated">要重复的数组或矩阵。</target>
        </trans-unit>
        <trans-unit id="53aead7fb32cb3de7311369b48d13d4953d0adc5" translate="yes" xml:space="preserve">
          <source>The array owns the memory it uses or borrows it from another object.</source>
          <target state="translated">数组拥有它所使用的内存,或者从另一个对象那里借来。</target>
        </trans-unit>
        <trans-unit id="8abf01fdd64396d234195c26c60e850e4a12a8d7" translate="yes" xml:space="preserve">
          <source>The array scalar objects have an &lt;code&gt;array priority&lt;/code&gt; of &lt;a href=&quot;c-api.array#c.NPY_SCALAR_PRIORITY&quot;&gt;&lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt;&lt;/a&gt; (-1,000,000.0). They also do not (yet) have a &lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; attribute. Otherwise, they share the same attributes as arrays:</source>
          <target state="translated">数组标量对象的 &lt;code&gt;array priority&lt;/code&gt; 为&lt;a href=&quot;c-api.array#c.NPY_SCALAR_PRIORITY&quot;&gt; &lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt; &lt;/a&gt;（-1,000,000.0）。它们也还没有&lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt;属性。否则，它们与数组共享相同的属性：</target>
        </trans-unit>
        <trans-unit id="5774b39bb119ab7d3a197a6eee5e164f12892112" translate="yes" xml:space="preserve">
          <source>The array scalar objects have an &lt;code&gt;array priority&lt;/code&gt; of &lt;a href=&quot;c-api/array#c.NPY_SCALAR_PRIORITY&quot;&gt;&lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt;&lt;/a&gt; (-1,000,000.0). They also do not (yet) have a &lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; attribute. Otherwise, they share the same attributes as arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0162c81e2783b3bcbb0dd799de5c3ba91aba6a" translate="yes" xml:space="preserve">
          <source>The array scalars also offer the same methods and attributes as arrays with the intent that the same code can be used to support arbitrary dimensions (including 0-dimensions). The array scalars are read-only (immutable) with the exception of the void scalar which can also be written to so that structured array field setting works more naturally (a[0][&amp;lsquo;f1&amp;rsquo;] = &lt;code&gt;value&lt;/code&gt; ).</source>
          <target state="translated">数组标量还提供与数组相同的方法和属性，目的是可以使用相同的代码来支持任意维（包括0维）。数组标量是只读的（不可变的），除了void标量也可以写入，使得结构化数组字段设置更自然地工作（a [0] ['f1'] = &lt;code&gt;value&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d0afa5fdfdf427a8322c75c5712091eca91eabac" translate="yes" xml:space="preserve">
          <source>The array scalars offer a hierarchy of Python types that allow a one- to-one correspondence between the data-type stored in an array and the Python-type that is returned when an element is extracted from the array. An exception to this rule was made with object arrays. Object arrays are heterogeneous collections of arbitrary Python objects. When you select an item from an object array, you get back the original Python object (and not an object array scalar which does exist but is rarely used for practical purposes).</source>
          <target state="translated">数组标量提供了一个Python类型的层次结构,它允许存储在数组中的数据类型和从数组中提取元素时返回的Python类型之间有一对一的对应关系。这个规则的例外是对象数组。对象数组是任意 Python 对象的异构集合。当你从一个对象数组中选择一个项目时,你会得到原始的 Python 对象 (而不是对象数组标量,后者确实存在,但很少用于实际目的)。</target>
        </trans-unit>
        <trans-unit id="4e947f26c0ecf6d9ff639e9f27b5b5f852135d7e" translate="yes" xml:space="preserve">
          <source>The array to act on.</source>
          <target state="translated">要执行的数组。</target>
        </trans-unit>
        <trans-unit id="7000ca786d20479930ea43aa17e050c42578abc2" translate="yes" xml:space="preserve">
          <source>The array to be pickled.</source>
          <target state="translated">要腌制的数组。</target>
        </trans-unit>
        <trans-unit id="25694c63a056a35911c5654e87ce1708648d0cd3" translate="yes" xml:space="preserve">
          <source>The array to broadcast.</source>
          <target state="translated">要广播的数组。</target>
        </trans-unit>
        <trans-unit id="61fa35e69f8b8bb03ffef7462ad7cef9c9cdddeb" translate="yes" xml:space="preserve">
          <source>The array to mask. If not a MaskedArray instance (or if no array elements are masked). The result is a MaskedArray with &lt;code&gt;mask&lt;/code&gt; set to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (False). Must be a 2D array.</source>
          <target state="translated">要屏蔽的数组。如果不是MaskedArray实例（或者没有掩码的数组元素）。结果是MaskedArray，其 &lt;code&gt;mask&lt;/code&gt; 设置为&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;（False）。必须是2D数组。</target>
        </trans-unit>
        <trans-unit id="9a0afda668850edc1a593d4069db9a58418e2d74" translate="yes" xml:space="preserve">
          <source>The array to operate on. If not a MaskedArray instance (or if no array elements are masked), &lt;code&gt;x&lt;/code&gt; is interpreted as a MaskedArray with &lt;code&gt;mask&lt;/code&gt; set to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;. Must be a 2D array.</source>
          <target state="translated">要操作的阵列。如果不是一个MaskedArray实例（或如果没有数组元素被掩蔽）， &lt;code&gt;x&lt;/code&gt; 被解释为与MaskedArray &lt;code&gt;mask&lt;/code&gt; 设置为&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt;。必须是2D数组。</target>
        </trans-unit>
        <trans-unit id="da7df7a6420823a6b7e45bca218ba68631febc25" translate="yes" xml:space="preserve">
          <source>The array to pad.</source>
          <target state="translated">要垫的数组。</target>
        </trans-unit>
        <trans-unit id="8966af5b1934b124717f0c80ec9988807e784cf9" translate="yes" xml:space="preserve">
          <source>The array to perform in place operation on.</source>
          <target state="translated">要执行就地操作的数组。</target>
        </trans-unit>
        <trans-unit id="1a2586a66b67a305c2797e7e06685302608f4ea4" translate="yes" xml:space="preserve">
          <source>The array whose axes should be reordered.</source>
          <target state="translated">数组的轴应该重新排序。</target>
        </trans-unit>
        <trans-unit id="81f5ca8ebafc1afb8a9d51589c5e138b4b807e19" translate="yes" xml:space="preserve">
          <source>The array(s) to be iterated over. Valid only before the iterator is closed.</source>
          <target state="translated">迭代的数组。仅在迭代器关闭前有效。</target>
        </trans-unit>
        <trans-unit id="8c52ea12181e4277b350926a7c51f79608004cd5" translate="yes" xml:space="preserve">
          <source>The array(s) to iterate over.</source>
          <target state="translated">迭代的数组。</target>
        </trans-unit>
        <trans-unit id="ae34a0f5008cfcf7a204a6ae1b41350a0a8ffea9" translate="yes" xml:space="preserve">
          <source>The array-protocol typestring of this data-type object.</source>
          <target state="translated">该数据类型对象的数组-协议类型字符串。</target>
        </trans-unit>
        <trans-unit id="342be16484b97c95949f88958c455899735a9596" translate="yes" xml:space="preserve">
          <source>The arrays all have exactly the same shape.</source>
          <target state="translated">阵列都有完全相同的形状。</target>
        </trans-unit>
        <trans-unit id="d48d7d91bb3512b8a648b512669295a09d607ddf" translate="yes" xml:space="preserve">
          <source>The arrays all have the same number of dimensions and the length of each dimensions is either a common length or 1.</source>
          <target state="translated">数组的维数都是一样的,而且每个维数的长度都是共同长度或1。</target>
        </trans-unit>
        <trans-unit id="3b32b95e95ce590daa0a88406a7282f0b6f9ae1f" translate="yes" xml:space="preserve">
          <source>The arrays holding the elements to be compared. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">包含要比较的元素的数组。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="b72974524c2659f265dc742386bd383e243bc4a6" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the first axis. 1-D arrays must have the same length.</source>
          <target state="translated">除第一轴外,所有阵列必须具有相同的形状。一维阵列必须具有相同的长度。</target>
        </trans-unit>
        <trans-unit id="9548b85aa3e636c88bbbc65cfcdf4e6b5fff4585" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the second axis, except 1-D arrays which can be any length.</source>
          <target state="translated">除第二轴外,阵列必须沿所有轴线具有相同的形状,但一维阵列可以是任何长度。</target>
        </trans-unit>
        <trans-unit id="34736140b85990281116cda8321b303d602cfb2e" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the third axis. 1-D or 2-D arrays must have the same shape.</source>
          <target state="translated">除第三轴外,所有阵列必须具有相同的形状。一维或二维阵列必须具有相同的形状。</target>
        </trans-unit>
        <trans-unit id="250d7318b7910004f5ade9c6bf7fa2a62b2d0aa6" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape, except in the dimension corresponding to &lt;code&gt;axis&lt;/code&gt; (the first, by default).</source>
          <target state="translated">数组必须具有相同的形状，除了对应于 &lt;code&gt;axis&lt;/code&gt; 的尺寸（默认为第一个）。</target>
        </trans-unit>
        <trans-unit id="3650412314ab8d0d6cc595877979b22653a06cac" translate="yes" xml:space="preserve">
          <source>The arrays that have too few dimensions can have their shapes prepended with a dimension of length 1 to satisfy property 2.</source>
          <target state="translated">维度太少的数组,其形状可以用长度为1的维度前置,以满足属性2。</target>
        </trans-unit>
        <trans-unit id="3c7fb6624c1c578e967064538473cd4324bc56b1" translate="yes" xml:space="preserve">
          <source>The arrays to be added. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">要添加的数组。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="61831d63f8eb03ec54ea81f37b4edf92245e6861" translate="yes" xml:space="preserve">
          <source>The arrays to be subtracted from each other. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">彼此相减的数组。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="b989bf28be4c34813d52a00110756329cfab3199" translate="yes" xml:space="preserve">
          <source>The arrays to broadcast.</source>
          <target state="translated">要广播的数组。</target>
        </trans-unit>
        <trans-unit id="4bc127992ac15b346e5ebc50b22b2084cc253474" translate="yes" xml:space="preserve">
          <source>The available functions are defined in &amp;lt;numpy/npy_math.h&amp;gt; - please refer to this header when in doubt.</source>
          <target state="translated">可用的函数在&amp;lt;numpy / npy_math.h&amp;gt;中定义-如有疑问，请参考此头文件。</target>
        </trans-unit>
        <trans-unit id="4c1200844d5256d1bf5c45cf0a767eb7723d9e5e" translate="yes" xml:space="preserve">
          <source>The average along the specified axis. When returned is &lt;code&gt;True&lt;/code&gt;, return a tuple with the average as the first element and the sum of the weights as the second element. The return type is &lt;code&gt;np.float64&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is of integer type and floats smaller than &lt;code&gt;float64&lt;/code&gt;, or the input data-type, otherwise. If returned, &lt;code&gt;sum_of_weights&lt;/code&gt; is always &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">沿指定轴的平均值。当返回 &lt;code&gt;True&lt;/code&gt; 时，返回一个以平均值为第一个元素，权重之和为第二个元素的元组。如果 &lt;code&gt;a&lt;/code&gt; 为整数类型，并且浮点数小于 &lt;code&gt;float64&lt;/code&gt; 或输入数据类型，则返回类型为 &lt;code&gt;np.float64&lt;/code&gt; 。如果返回， &lt;code&gt;sum_of_weights&lt;/code&gt; 始终为 &lt;code&gt;float64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="542875b084a7c351a7a1f8a6d2d600675ca4d2a7" translate="yes" xml:space="preserve">
          <source>The average squared deviation is normally calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of the infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables. The standard deviation computed in this function is the square root of the estimated variance, so even with &lt;code&gt;ddof=1&lt;/code&gt;, it will not be an unbiased estimate of the standard deviation per se.</source>
          <target state="translated">均方差通常计算为 &lt;code&gt;x.sum() / N&lt;/code&gt; ，其中 &lt;code&gt;N = len(x)&lt;/code&gt; 。然而，如果 &lt;code&gt;ddof&lt;/code&gt; 指定，除数 &lt;code&gt;N - ddof&lt;/code&gt; 代替。在标准的统计实践中， &lt;code&gt;ddof=1&lt;/code&gt; 提供了无穷总体方差的无偏估计量。 &lt;code&gt;ddof=0&lt;/code&gt; 为正态分布变量提供方差的最大似然估计。在此函数中计算的标准偏差是估计方差的平方根，因此即使 &lt;code&gt;ddof=1&lt;/code&gt; ，也不会是标准偏差本身的无偏估计。</target>
        </trans-unit>
        <trans-unit id="21ebdcee890d352b954472165e15ea262b078aa8" translate="yes" xml:space="preserve">
          <source>The axes over which to compute the inverse fft. Default is the last two axes.</source>
          <target state="translated">计算反FFT的轴。默认为最后两个轴。</target>
        </trans-unit>
        <trans-unit id="3f6da36d69c95a72b5592c0677dd407fdc9cfa2c" translate="yes" xml:space="preserve">
          <source>The axis along which &lt;code&gt;v&lt;/code&gt; are appended. If &lt;code&gt;axis&lt;/code&gt; is not given, both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are flattened before use.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 所沿的轴。如果未指定 &lt;code&gt;axis&lt;/code&gt; ，则在使用前将 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 展平。</target>
        </trans-unit>
        <trans-unit id="071585631d8d75cc42162ae0da0a1b91474572d1" translate="yes" xml:space="preserve">
          <source>The axis along which &lt;code&gt;values&lt;/code&gt; are appended. If &lt;code&gt;axis&lt;/code&gt; is not given, both &lt;code&gt;arr&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; are flattened before use.</source>
          <target state="translated">沿其 &lt;code&gt;values&lt;/code&gt; 的轴。如果未指定 &lt;code&gt;axis&lt;/code&gt; ，则在使用前将 &lt;code&gt;arr&lt;/code&gt; 和 &lt;code&gt;values&lt;/code&gt; 都展平。</target>
        </trans-unit>
        <trans-unit id="d25eb0541fd006d52dcbebc548c80309c583cc52" translate="yes" xml:space="preserve">
          <source>The axis along which the arrays will be joined. Default is 0.</source>
          <target state="translated">连接数组的轴线。默认为0。</target>
        </trans-unit>
        <trans-unit id="ab324f8b42b072f0ce80303066858390de817e59" translate="yes" xml:space="preserve">
          <source>The axis along which the arrays will be joined. If axis is None, arrays are flattened before use. Default is 0.</source>
          <target state="translated">连接数组的轴线。如果坐标轴为None,则在使用前对数组进行扁平化处理。默认值为0。</target>
        </trans-unit>
        <trans-unit id="b85856e591095eebb92c2f542dccaa68776b00c8" translate="yes" xml:space="preserve">
          <source>The axis along which the difference is taken, default is the last axis.</source>
          <target state="translated">取差的轴线,默认为最后一个轴线。</target>
        </trans-unit>
        <trans-unit id="848f8430ea7a17384babb0b6d388a2e2e8bda711" translate="yes" xml:space="preserve">
          <source>The axis along which the selection is performed. The default, 0, selects by row.</source>
          <target state="translated">执行选择的轴。默认值0,按行选择。</target>
        </trans-unit>
        <trans-unit id="db9105950615faa8709d8dba888767b4f466811c" translate="yes" xml:space="preserve">
          <source>The axis along which to apply the accumulation; default is zero.</source>
          <target state="translated">应用累积的轴,默认为零。</target>
        </trans-unit>
        <trans-unit id="b45496da67ff059714d0b1ae6911029e831dd2fd" translate="yes" xml:space="preserve">
          <source>The axis along which to apply the reduceat.</source>
          <target state="translated">缩小的轴线。</target>
        </trans-unit>
        <trans-unit id="ef9dbd3a8e7509325fd10ad7183022f46facda83" translate="yes" xml:space="preserve">
          <source>The axis along which to delete the subarray defined by &lt;code&gt;obj&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;obj&lt;/code&gt; is applied to the flattened array.</source>
          <target state="translated">删除 &lt;code&gt;obj&lt;/code&gt; 定义的子数组所沿的轴。如果 &lt;code&gt;axis&lt;/code&gt; 为None，则 &lt;code&gt;obj&lt;/code&gt; 将应用于扁平化数组。</target>
        </trans-unit>
        <trans-unit id="3c27f5e5d6b589ff51ec356603f9f33684d0e877" translate="yes" xml:space="preserve">
          <source>The axis along which to find the minima. Default is None, in which case the minimum value in the whole array is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5932d4cf836b6b58485bd9f15e2f20474363c36f" translate="yes" xml:space="preserve">
          <source>The axis along which to integrate.</source>
          <target state="translated">沿着这个轴线进行整合。</target>
        </trans-unit>
        <trans-unit id="0011917dec1b66b996673fed4476058c1c23ee6e" translate="yes" xml:space="preserve">
          <source>The axis along which to repeat values. By default, use the flattened input array, and return a flat output array.</source>
          <target state="translated">重复值的轴。默认情况下,使用扁平化的输入数组,并返回一个扁平的输出数组。</target>
        </trans-unit>
        <trans-unit id="407371d3199afc3105f3e75619a63b4981063028" translate="yes" xml:space="preserve">
          <source>The axis along which to split, default is 0.</source>
          <target state="translated">分割的轴线,默认为0。</target>
        </trans-unit>
        <trans-unit id="40f4cb16df8166b16f689cc3f6a27ceb034ca2a8" translate="yes" xml:space="preserve">
          <source>The axis currently being calculated.</source>
          <target state="translated">当前正在计算的轴。</target>
        </trans-unit>
        <trans-unit id="779396c94c96c008627d39cce908fca96b699246" translate="yes" xml:space="preserve">
          <source>The axis in the result array along which the input arrays are stacked.</source>
          <target state="translated">结果数组中的轴,输入数组沿此轴堆叠。</target>
        </trans-unit>
        <trans-unit id="f53c3f1c70993fc128dae4ee501fb80cbace06f6" translate="yes" xml:space="preserve">
          <source>The axis in the result to store the samples. Relevant only if start or stop are array-like. By default (0), the samples will be along a new axis inserted at the beginning. Use -1 to get an axis at the end.</source>
          <target state="translated">结果中存储样本的轴。只有当start或stop是类似数组的时候才有意义。默认情况下(0),样本将沿着在开始时插入的新轴。使用-1可以在最后得到一个轴。</target>
        </trans-unit>
        <trans-unit id="5d9b30084a3b37c792a839c94c54a5cdb7a8cfce" translate="yes" xml:space="preserve">
          <source>The axis is rolled until it lies before this position. The default, 0, results in a &amp;ldquo;complete&amp;rdquo; roll.</source>
          <target state="translated">轴将滚动直到其位于该位置之前。默认值为0，将导致&amp;ldquo;完成&amp;rdquo;滚动。</target>
        </trans-unit>
        <trans-unit id="bb67daef266f9ea49c20107e1bf4911d74a22608" translate="yes" xml:space="preserve">
          <source>The axis over which to select values. By default, the flattened input array is used.</source>
          <target state="translated">选择值的轴。默认情况下,使用扁平化的输入数组。</target>
        </trans-unit>
        <trans-unit id="6a2ce88413f2bc22b3ef2d3c9420680ad19eebe6" translate="yes" xml:space="preserve">
          <source>The axis to be rolled. The positions of the other axes do not change relative to one another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0edfc48d57e03c356c790b28b9213c10fc98a8b" translate="yes" xml:space="preserve">
          <source>The axis to operate on. If None, &lt;code&gt;ar&lt;/code&gt; will be flattened. If an integer, the subarrays indexed by the given axis will be flattened and treated as the elements of a 1-D array with the dimension of the given axis, see the notes for more details. Object arrays or structured arrays that contain objects are not supported if the &lt;code&gt;axis&lt;/code&gt; kwarg is used. The default is None.</source>
          <target state="translated">要运行的轴。如果为None，则 &lt;code&gt;ar&lt;/code&gt; 将被展平。如果为整数，则由给定轴索引的子数组将被展平并视为具有给定轴尺寸的一维数组的元素，有关更多详细信息，请参见注释。如果使用 &lt;code&gt;axis&lt;/code&gt; kwarg，则不支持对象数组或包含对象的结构化数组。默认为无。</target>
        </trans-unit>
        <trans-unit id="b9493a9f29cafe569828c852de6864aa7f5d0ff6" translate="yes" xml:space="preserve">
          <source>The axis to roll backwards. The positions of the other axes do not change relative to one another.</source>
          <target state="translated">向后滚动的轴。其他轴的位置不会相对改变。</target>
        </trans-unit>
        <trans-unit id="340d3fc196833339a77972eea60efcdfd52ba73c" translate="yes" xml:space="preserve">
          <source>The axis to take 1d slices along. If axis is None, the destination array is treated as if a flattened 1d view had been created of it.</source>
          <target state="translated">沿着1d切片的轴。如果轴为None,目标数组将被视为已创建的扁平化1d视图。</target>
        </trans-unit>
        <trans-unit id="a049beb1044c250e5951941014a3acba639cb49d" translate="yes" xml:space="preserve">
          <source>The axis to take 1d slices along. If axis is None, the input array is treated as if it had first been flattened to 1d, for consistency with &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">沿其取一维切片的轴。如果axis为None，则将输入数组视为首先被展平为1d，以与&lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt;保持一致。</target>
        </trans-unit>
        <trans-unit id="a5f8cd862df0c3dc198b03cdec5c823ff5bfd3ca" translate="yes" xml:space="preserve">
          <source>The axis which &lt;code&gt;x&lt;/code&gt; is shuffled along. Default is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f5f1b01f9d6c3c18ebf1e91b8c1b0eb06217c1" translate="yes" xml:space="preserve">
          <source>The axis which &lt;code&gt;x&lt;/code&gt; is shuffled along. Default is 0. It is only supported on &lt;code&gt;ndarray&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8262154fa6203f128694759e7e2ae715f81f6fa1" translate="yes" xml:space="preserve">
          <source>The base BitGenerator.state must be overridden by a subclass</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98787e1071b5327d0b2e07537c81bb27588db08e" translate="yes" xml:space="preserve">
          <source>The base case for this recursion is a 0D array:</source>
          <target state="translated">这个递归的基本情况是一个0D数组。</target>
        </trans-unit>
        <trans-unit id="88d21dfd4e25736b7184078ba7f33b64bea753e0" translate="yes" xml:space="preserve">
          <source>The base of an array that owns its memory is None:</source>
          <target state="translated">拥有其内存的数组的基数是None。</target>
        </trans-unit>
        <trans-unit id="074b16b582d8ec2099beaee8dcbc987839646a35" translate="yes" xml:space="preserve">
          <source>The base of the log space. The step size between the elements in &lt;code&gt;ln(samples) / ln(base)&lt;/code&gt; (or &lt;code&gt;log_base(samples)&lt;/code&gt;) is uniform. Default is 10.0.</source>
          <target state="translated">日志空间的基础。 &lt;code&gt;ln(samples) / ln(base)&lt;/code&gt; （或 &lt;code&gt;log_base(samples)&lt;/code&gt; ）中元素之间的步长是均匀的。默认值为10.0。</target>
        </trans-unit>
        <trans-unit id="535897fba7f592c8b7dd04c68596d9a31edf2e11" translate="yes" xml:space="preserve">
          <source>The bases in &lt;code&gt;x1&lt;/code&gt; raised to the exponents in &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 中的基数上升到 &lt;code&gt;x2&lt;/code&gt; 中的指数。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="707f28b031c35e2bf30d29bbd42946a1e8c7dc8c" translate="yes" xml:space="preserve">
          <source>The bases.</source>
          <target state="translated">基地。</target>
        </trans-unit>
        <trans-unit id="5bc92f7e413935d311df16000ae397f9e815d85b" translate="yes" xml:space="preserve">
          <source>The basic data element&amp;rsquo;s size in bytes</source>
          <target state="translated">基本数据元素的大小（以字节为单位）</target>
        </trans-unit>
        <trans-unit id="68fe9eda4da762f1f4d04299c59c07412dcd5a69" translate="yes" xml:space="preserve">
          <source>The basic slice syntax is &lt;code&gt;i:j:k&lt;/code&gt; where &lt;em&gt;i&lt;/em&gt; is the starting index, &lt;em&gt;j&lt;/em&gt; is the stopping index, and &lt;em&gt;k&lt;/em&gt; is the step (</source>
          <target state="translated">基本切片语法为 &lt;code&gt;i:j:k&lt;/code&gt; ，其中&lt;em&gt;i&lt;/em&gt;是起始索引，&lt;em&gt;j&lt;/em&gt;是终止索引，&lt;em&gt;k&lt;/em&gt;是步骤（</target>
        </trans-unit>
        <trans-unit id="aeeddb45e8f2002e147b881df220bd44abec802b" translate="yes" xml:space="preserve">
          <source>The basic type character codes are:</source>
          <target state="translated">基本类型字符代码为:</target>
        </trans-unit>
        <trans-unit id="94f38793f86bdba698e5ca03402c847550f50738" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is a Chebyshev basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">缩放基本多项式，以便当 &lt;code&gt;c&lt;/code&gt; 是Chebyshev基本多项式时，伴随矩阵对称。与未缩放的情况相比，这提供了更好的特征值估计，对于基本多项式，如果使用&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;来获得特征值，则可以保证它们是实数。</target>
        </trans-unit>
        <trans-unit id="fd443fcafad8cfc7235ab73b5edb8fa2361feb5f" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an Hermite basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">缩放基础多项式，以便当 &lt;code&gt;c&lt;/code&gt; 是Hermite基础多项式时，伴随矩阵对称。与未缩放的情况相比，这提供了更好的特征值估计，对于基本多项式，如果使用&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;来获得特征值，则可以保证它们是实数。</target>
        </trans-unit>
        <trans-unit id="e1520a86bfcd397936d59363e21a13733e7a71b7" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an HermiteE basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">缩放基本多项式，以便当 &lt;code&gt;c&lt;/code&gt; 是HermiteE基本多项式时，伴随矩阵对称。与未缩放的情况相比，这提供了更好的特征值估计，对于基本多项式，如果使用&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;来获得特征值，则可以保证它们是实数。</target>
        </trans-unit>
        <trans-unit id="31e8496a7482cd5cd28cb680bd285957a80df61e" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an Legendre basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">缩放基本多项式，以便当 &lt;code&gt;c&lt;/code&gt; 是Legendre基本多项式时，伴随矩阵对称。与未缩放的情况相比，这提供了更好的特征值估计，对于基本多项式，如果使用&lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt;来获得特征值，则可以保证它们是实数。</target>
        </trans-unit>
        <trans-unit id="f437318ff72364f761b90a9b7cf38009e657db81" translate="yes" xml:space="preserve">
          <source>The behavior depends on the arguments in the following way.</source>
          <target state="translated">其行为取决于以下方式的参数。</target>
        </trans-unit>
        <trans-unit id="52cedd9e4737e7d41b9c0573b9212f2735c44e68" translate="yes" xml:space="preserve">
          <source>The behavior of multi-field indexes changed from Numpy 1.15 to Numpy 1.16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c61d26e0bac97d24671e4708fc43eaa9dd53127" translate="yes" xml:space="preserve">
          <source>The behaviour of NumPy and Python integer types differs significantly for integer overflows and may confuse users expecting NumPy integers to behave similar to Python&amp;rsquo;s &lt;code&gt;int&lt;/code&gt;. Unlike NumPy, the size of Python&amp;rsquo;s &lt;code&gt;int&lt;/code&gt; is flexible. This means Python integers may expand to accommodate any integer and will not overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226707a677bb2dfd051d5e6d30579822a26a8454" translate="yes" xml:space="preserve">
          <source>The benchmark parameters etc. should not depend on which NumPy version is installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a11e20913e7d4cf3019155d32cde05064b5abf" translate="yes" xml:space="preserve">
          <source>The benchmark suite should be importable with any NumPy version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2bdcfca6c07efc9e236b5653fc2391d3452350a" translate="yes" xml:space="preserve">
          <source>The best practice is to &lt;strong&gt;not&lt;/strong&gt; reseed a BitGenerator, rather to recreate a new one. This method is here for legacy reasons. This example demonstrates best practice.</source>
          <target state="translated">最佳实践是&lt;strong&gt;不要&lt;/strong&gt;播种BitGenerator，而要重新创建一个新的BitGenerator。由于遗留原因，此处使用此方法。此示例演示了最佳实践。</target>
        </trans-unit>
        <trans-unit id="c109a555c27db42b8f7688c8df998553f8ab7653" translate="yes" xml:space="preserve">
          <source>The best strategy to better understand the code base is to pick something you want to change and start reading the code to figure out how it works. When in doubt, you can ask questions on the mailing list. It is perfectly okay if your pull requests aren&amp;rsquo;t perfect, the community is always happy to help. As a volunteer project, things do sometimes get dropped and it&amp;rsquo;s totally fine to ping us if something has sat without a response for about two to four weeks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae59e3eb6aeca266807eb2b03def986d4d70e96" translate="yes" xml:space="preserve">
          <source>The best way to become familiar with the iterator is to look at its usage within the NumPy codebase itself. For example, here is a slightly tweaked version of the code for &lt;a href=&quot;array#c.PyArray_CountNonzero&quot;&gt;&lt;code&gt;PyArray_CountNonzero&lt;/code&gt;&lt;/a&gt;, which counts the number of non-zero elements in an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b917d701e1031f727f4614d1e3412a655c750b99" translate="yes" xml:space="preserve">
          <source>The best way to become familiar with the iterator is to look at its usage within the NumPy codebase itself. For example, here is a slightly tweaked version of the code for &lt;a href=&quot;c-api.array#c.PyArray_CountNonzero&quot;&gt;&lt;code&gt;PyArray_CountNonzero&lt;/code&gt;&lt;/a&gt;, which counts the number of non-zero elements in an array.</source>
          <target state="translated">熟悉迭代器的最佳方法是在NumPy代码库本身中查看其用法。例如，这是&lt;a href=&quot;c-api.array#c.PyArray_CountNonzero&quot;&gt; &lt;code&gt;PyArray_CountNonzero&lt;/code&gt; &lt;/a&gt;的代码的略微调整版本，该版本对数组中非零元素的数量进行计数。</target>
        </trans-unit>
        <trans-unit id="de71d7b03048d0ddf7e9d872a2d91138dd227be5" translate="yes" xml:space="preserve">
          <source>The best way to encode the options required to link against the specified C libraries is to use a &amp;ldquo;libname.ini&amp;rdquo; file, and use &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt; to retrieve the required options (see &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt;&lt;code&gt;add_npy_pkg_config&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="translated">编码链接到指定C库所需的选项的最佳方法是使用&amp;ldquo; libname.ini&amp;rdquo;文件，并使用&lt;a href=&quot;#numpy.distutils.misc_util.Configuration.get_info&quot;&gt; &lt;code&gt;get_info&lt;/code&gt; &lt;/a&gt;检索所需的选项（有关更多信息，请参见&lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt; &lt;code&gt;add_npy_pkg_config&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bd068dc6ad18c4bdc86034d17ab908d7b76c4670" translate="yes" xml:space="preserve">
          <source>The best way to encode the options required to link against the specified C libraries is to use a &amp;ldquo;libname.ini&amp;rdquo; file, and use &lt;a href=&quot;distutils/misc_util#numpy.distutils.misc_util.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt; to retrieve the required options (see &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt;&lt;code&gt;add_npy_pkg_config&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1969d49698b808b6d276d97e5d8d4c69483e3b58" translate="yes" xml:space="preserve">
          <source>The bi-dimensional histogram of samples &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Values in &lt;code&gt;x&lt;/code&gt; are histogrammed along the first dimension and values in &lt;code&gt;y&lt;/code&gt; are histogrammed along the second dimension.</source>
          <target state="translated">样本 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的二维直方图。 &lt;code&gt;x&lt;/code&gt; 中的值沿第一维直方图， &lt;code&gt;y&lt;/code&gt; 中的值沿第二维直方图。</target>
        </trans-unit>
        <trans-unit id="ccfae57716d7eef7191c06c0e81d2ccf59d9fed0" translate="yes" xml:space="preserve">
          <source>The biggest difficulty when writing extension modules is reference counting. It is an important reason for the popularity of f2py, weave, Cython, ctypes, etc&amp;hellip;. If you mis-handle reference counts you can get problems from memory-leaks to segmentation faults. The only strategy I know of to handle reference counts correctly is blood, sweat, and tears. First, you force it into your head that every Python variable has a reference count. Then, you understand exactly what each function does to the reference count of your objects, so that you can properly use DECREF and INCREF when you need them. Reference counting can really test the amount of patience and diligence you have towards your programming craft. Despite the grim depiction, most cases of reference counting are quite straightforward with the most common difficulty being not using DECREF on objects before exiting early from a routine due to some error. In second place, is the common error of not owning the reference on an object that is passed to a function or macro that is going to steal the reference ( &lt;em&gt;e.g.&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/dev/c-api/tuple.html#c.PyTuple_SET_ITEM&quot;&gt;&lt;code&gt;PyTuple_SET_ITEM&lt;/code&gt;&lt;/a&gt;, and most functions that take &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14050b2975e92118c403ebf94bd3985c0b813e9c" translate="yes" xml:space="preserve">
          <source>The bin edges along the first dimension.</source>
          <target state="translated">仓边沿第一维。</target>
        </trans-unit>
        <trans-unit id="4350d5e237c7d985f1cac8ee28f6158f7c836a6a" translate="yes" xml:space="preserve">
          <source>The bin edges along the second dimension.</source>
          <target state="translated">仓边沿二维。</target>
        </trans-unit>
        <trans-unit id="a2867162a2727e5c2d9c039d549ef3ce42449ec8" translate="yes" xml:space="preserve">
          <source>The bin specification:</source>
          <target state="translated">仓规格。</target>
        </trans-unit>
        <trans-unit id="60d93abeda71712ad2c6a79ef8adc26f40d2aa9b" translate="yes" xml:space="preserve">
          <source>The binwidth is proportional to the interquartile range (IQR) and inversely proportional to cube root of a.size. Can be too conservative for small datasets, but is quite good for large datasets. The IQR is very robust to outliers.</source>
          <target state="translated">二进制宽度与四分位数范围(IQR)成正比,与a.size的立方根成反比。对于小数据集来说可能过于保守,但对于大数据集来说是相当不错的。IQR对离群值的影响非常大。</target>
        </trans-unit>
        <trans-unit id="fcdd8e437719df337fcbc4c74083d021a1773472" translate="yes" xml:space="preserve">
          <source>The binwidth is proportional to the standard deviation of the data and inversely proportional to cube root of &lt;code&gt;x.size&lt;/code&gt;. Can be too conservative for small datasets, but is quite good for large datasets. The standard deviation is not very robust to outliers. Values are very similar to the Freedman-Diaconis estimator in the absence of outliers.</source>
          <target state="translated">binwidth与数据的标准偏差成正比，与 &lt;code&gt;x.size&lt;/code&gt; 的立方根成反比。对于小型数据集可能过于保守，但对于大型数据集则相当不错。标准偏差对异常值不是很稳健。在没有异常值的情况下，值与Freedman-Diaconis估计量非常相似。</target>
        </trans-unit>
        <trans-unit id="4bfe7be4cfb5e7ee31495fab431c2ade90ea37b4" translate="yes" xml:space="preserve">
          <source>The bit generator instance used by the generator</source>
          <target state="translated">生成器使用的位生成器实例</target>
        </trans-unit>
        <trans-unit id="1c9ceb11680f6c0c1b9aff1a5015653854b99511" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via &lt;a href=&quot;extending#random-cython&quot;&gt;Cython&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d3462c76522066d7ff9beefce9a7effa7d1a7a" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via &lt;a href=&quot;extending#randomgen-cython&quot;&gt;Cython&lt;/a&gt;.</source>
          <target state="translated">可以通过&lt;a href=&quot;extending#randomgen-cython&quot;&gt;Cython&lt;/a&gt;在下游项目中使用位生成器。</target>
        </trans-unit>
        <trans-unit id="bb60b63a1d593f422d320c08f605d5c913dee609" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via Cython.</source>
          <target state="translated">位生成器可以通过Cython在下游项目中使用。</target>
        </trans-unit>
        <trans-unit id="6e4e6fbd0cb3401b8c573dd3679e44e3f4f81dbf" translate="yes" xml:space="preserve">
          <source>The bit-width names can also be used (e.g. &lt;a href=&quot;c-api.dtype#c.NPY_INT32&quot;&gt;&lt;code&gt;NPY_INT32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_COMPLEX128&quot;&gt;&lt;code&gt;NPY_COMPLEX128&lt;/code&gt;&lt;/a&gt; ) if desired.</source>
          <target state="translated">如果需要，也可以使用位宽名称（例如&lt;a href=&quot;c-api.dtype#c.NPY_INT32&quot;&gt; &lt;code&gt;NPY_INT32&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.dtype#c.NPY_COMPLEX128&quot;&gt; &lt;code&gt;NPY_COMPLEX128&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bc2ab75ee612016fcf37354aa06f319d50bc9810" translate="yes" xml:space="preserve">
          <source>The bit-width names can also be used (e.g. &lt;a href=&quot;dtype#c.NPY_INT32&quot;&gt;&lt;code&gt;NPY_INT32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_COMPLEX128&quot;&gt;&lt;code&gt;NPY_COMPLEX128&lt;/code&gt;&lt;/a&gt; ) if desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d10a070991358c5aabcf2c4a0f8549725777dd" translate="yes" xml:space="preserve">
          <source>The bit-wise operators &amp;amp; and | are the proper way to perform element-by-element array comparisons. Be sure you understand the operator precedence: &lt;code&gt;(a &amp;gt; 2) &amp;amp; (a &amp;lt; 5)&lt;/code&gt; is the proper syntax because &lt;code&gt;a &amp;gt; 2 &amp;amp; a &amp;lt; 5&lt;/code&gt; will result in an error due to the fact that &lt;code&gt;2 &amp;amp; a&lt;/code&gt; is evaluated first.</source>
          <target state="translated">按位运算符＆和| 是执行逐元素数组比较的正确方法。请确保您了解运算符的优先级： &lt;code&gt;(a &amp;gt; 2) &amp;amp; (a &amp;lt; 5)&lt;/code&gt; 是正确的语法，因为 &lt;code&gt;a &amp;gt; 2 &amp;amp; a &amp;lt; 5&lt;/code&gt; 会由于首先计算 &lt;code&gt;2 &amp;amp; a&lt;/code&gt; 而导致错误。</target>
        </trans-unit>
        <trans-unit id="023be86065ffa72daa5873059c9ec3d6c37210a4" translate="yes" xml:space="preserve">
          <source>The bits that are inherited for the parent data-type if these bits are set in any field of the data-type. Currently ( &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt;&lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt;&lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt;&lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt;&lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">如果在数据类型的任何字段中设置了这些位，则为父数据类型继承的位。当前（&lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt; &lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt; &lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt; &lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt; &lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="eec4adb38715609db3c28173012b3acac012a710" translate="yes" xml:space="preserve">
          <source>The broadcasting mechanism permits index arrays to be combined with scalars for other indices. The effect is that the scalar value is used for all the corresponding values of the index arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cdfeeb979f5beeacca8e8ed28ded2c7c6f59236" translate="yes" xml:space="preserve">
          <source>The buffer size. If &lt;code&gt;buf_size&lt;/code&gt; is supplied, the maximum amount of data that will be read into memory is &lt;code&gt;buf_size&lt;/code&gt; elements. Default is None, which will read as many element as possible into memory.</source>
          <target state="translated">缓冲区大小。如果提供 &lt;code&gt;buf_size&lt;/code&gt; ，则将读入内存的最大数据量为 &lt;code&gt;buf_size&lt;/code&gt; 元素。默认值为&amp;ldquo;无&amp;rdquo;，它将把尽可能多的元素读入内存。</target>
        </trans-unit>
        <trans-unit id="2e41256de81634e573afba6a93755e0b3e1dcc73" translate="yes" xml:space="preserve">
          <source>The built-in scalar types are shown below. Along with their (mostly) C-derived names, the integer, float, and complex data-types are also available using a bit-width convention so that an array of the right size can always be ensured (e.g. &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;). Two aliases (&lt;code&gt;intp&lt;/code&gt; and &lt;code&gt;uintp&lt;/code&gt;) pointing to the integer type that is sufficiently large to hold a C pointer are also provided. The C-like names are associated with character codes, which are shown in the table. Use of the character codes, however, is discouraged.</source>
          <target state="translated">内置标量类型如下所示。除了它们（主要是C派生的名称）之外，还可以使用位宽约定来使用整数，浮点数和复杂数据类型，以便始终确保大小正确的数组（例如 &lt;code&gt;int8&lt;/code&gt; ， &lt;code&gt;float64&lt;/code&gt; ， &lt;code&gt;complex128&lt;/code&gt; ） 。还提供了两个别名（ &lt;code&gt;intp&lt;/code&gt; 和 &lt;code&gt;uintp&lt;/code&gt; ），它们分别指向足够容纳C指针的整数类型。类似于C的名称与字符代码相关联，如表所示。但是，不建议使用字符代码。</target>
        </trans-unit>
        <trans-unit id="c0f5f929adb8df8a6adc766b8c78557ffdeb6dfb" translate="yes" xml:space="preserve">
          <source>The byte offset of element &lt;code&gt;(i[0], i[1], ..., i[n])&lt;/code&gt; in an array &lt;code&gt;a&lt;/code&gt; is:</source>
          <target state="translated">数组 &lt;code&gt;a&lt;/code&gt; 中元素 &lt;code&gt;(i[0], i[1], ..., i[n])&lt;/code&gt; 的字节偏移为：</target>
        </trans-unit>
        <trans-unit id="4e1d8f651723be5f774ab2e5c504d861c7a87264" translate="yes" xml:space="preserve">
          <source>The byte offsets of the fields within the structure and the total structure itemsize are determined automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a157c5730d5626d8d468cb6666e1e8a306635908" translate="yes" xml:space="preserve">
          <source>The byte order of the data (which may not be the native byte order)</source>
          <target state="translated">数据的字节顺序(可能不是本地字节顺序)。</target>
        </trans-unit>
        <trans-unit id="54750603ecbabb9e0fbfb396fe440127b1696b3c" translate="yes" xml:space="preserve">
          <source>The byteswapped array. If &lt;code&gt;inplace&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this is a view to self.</source>
          <target state="translated">字节数组。如果 &lt;code&gt;inplace&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则这是对自身的看法。</target>
        </trans-unit>
        <trans-unit id="50ca95011c00b72a055aafd7f7fd748d3ee5666f" translate="yes" xml:space="preserve">
          <source>The calculation based on the Einstein summation convention.</source>
          <target state="translated">基于爱因斯坦求和惯例的计算。</target>
        </trans-unit>
        <trans-unit id="f28022cc3c759ea7fff9649dace591b586e47f2a" translate="yes" xml:space="preserve">
          <source>The call function takes two arguments. The first is a string describing the type of error (such as &amp;ldquo;divide by zero&amp;rdquo;, &amp;ldquo;overflow&amp;rdquo;, &amp;ldquo;underflow&amp;rdquo;, or &amp;ldquo;invalid value&amp;rdquo;), and the second is the status flag. The flag is a byte, whose four least-significant bits indicate the type of error, one of &amp;ldquo;divide&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, &amp;ldquo;invalid&amp;rdquo;:</source>
          <target state="translated">调用函数有两个参数。第一个是描述错误类型的字符串（例如&amp;ldquo;除以零&amp;rdquo;，&amp;ldquo;上溢&amp;rdquo;，&amp;ldquo;下溢&amp;rdquo;或&amp;ldquo;无效值&amp;rdquo;），第二个是状态标志。该标志是一个字节，其四个最低有效位指示错误的类型，即&amp;ldquo;除&amp;rdquo;，&amp;ldquo;上&amp;rdquo;，&amp;ldquo;下&amp;rdquo;，&amp;ldquo;无效&amp;rdquo;之一：</target>
        </trans-unit>
        <trans-unit id="65bfb33c8f536eca2e334a181b45563504281f94" translate="yes" xml:space="preserve">
          <source>The callable to test.</source>
          <target state="translated">要测试的callable。</target>
        </trans-unit>
        <trans-unit id="a3a1c9abf4ffccd45f5331c5f42edc1f3d2d1d9d" translate="yes" xml:space="preserve">
          <source>The callback function may also be explicitly set in the module. Then it is not necessary to pass the function in the argument list to the Fortran function. This may be desired if the Fortran function calling the python callback function is itself called by another Fortran function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="431e9b7795bdf48241d6bec5990fb4a0130d071a" translate="yes" xml:space="preserve">
          <source>The ceil of the scalar &lt;code&gt;x&lt;/code&gt; is the smallest integer &lt;code&gt;i&lt;/code&gt;, such that &lt;code&gt;i &amp;gt;= x&lt;/code&gt;. It is often denoted as</source>
          <target state="translated">标量 &lt;code&gt;x&lt;/code&gt; 的ceil 是最小的整数 &lt;code&gt;i&lt;/code&gt; ，使得 &lt;code&gt;i &amp;gt;= x&lt;/code&gt; 。它通常表示为</target>
        </trans-unit>
        <trans-unit id="e9d3cf326f9a7a53ec955615e43eb638c61eb8ef" translate="yes" xml:space="preserve">
          <source>The ceiling of each element in &lt;code&gt;x&lt;/code&gt;, with &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; dtype. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 中每个元素的上限，带有&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; dtype。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="39a8dcb488a9fc6fc34cf5a558688abf07d39d3f" translate="yes" xml:space="preserve">
          <source>The character representing the minimum-size type that was found.</source>
          <target state="translated">代表找到的最小尺寸类型的字符。</target>
        </trans-unit>
        <trans-unit id="97cbe8e263bc4b6b77075dcb6bab028e565a01e7" translate="yes" xml:space="preserve">
          <source>The character to use for padding</source>
          <target state="translated">用于填充的字符</target>
        </trans-unit>
        <trans-unit id="6c4bf24ea0f35b24c677f85fded0fd7b09f23149" translate="yes" xml:space="preserve">
          <source>The character used to indicate the start of a comment. All the characters occurring on a line after a comment are discarded</source>
          <target state="translated">用来表示注释的开始的字符。注释之后的行上出现的所有字符都将被丢弃。</target>
        </trans-unit>
        <trans-unit id="d85f382686a835461ae276491d1cc1f7d794fafc" translate="yes" xml:space="preserve">
          <source>The characteristic polynomial,</source>
          <target state="translated">特征多项式。</target>
        </trans-unit>
        <trans-unit id="95fe0ca98cff261937758debf60dec87c78a570a" translate="yes" xml:space="preserve">
          <source>The characters or list of characters used to indicate the start of a comment. None implies no comments. For backwards compatibility, byte strings will be decoded as &amp;lsquo;latin1&amp;rsquo;. The default is &amp;lsquo;#&amp;rsquo;.</source>
          <target state="translated">用于指示注释开始的字符或字符列表。无表示无评论。为了向后兼容，字节字符串将被解码为&amp;ldquo; latin1&amp;rdquo;。默认值为&amp;ldquo;＃&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="16535da2d1a6378c09b05298f374b6373da93c3c" translate="yes" xml:space="preserve">
          <source>The choice and location of linked libraries such as BLAS and LAPACK as well as include paths and other such build options can be specified in a &lt;code&gt;site.cfg&lt;/code&gt; file located in the NumPy root repository or a &lt;code&gt;.numpy-site.cfg&lt;/code&gt; file in your home directory. See the &lt;code&gt;site.cfg.example&lt;/code&gt; example file included in the NumPy repository or sdist for documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3f50108009441cc91c801c6a0d50e7f118400f" translate="yes" xml:space="preserve">
          <source>The class defining the warning that &lt;code&gt;func&lt;/code&gt; is expected to throw.</source>
          <target state="translated">定义警告预期 &lt;code&gt;func&lt;/code&gt; 引发的类。</target>
        </trans-unit>
        <trans-unit id="da74e7889b120a1d89220abab914f35b23ca6ac5" translate="yes" xml:space="preserve">
          <source>The clear choice to wrap Fortran code is &lt;a href=&quot;https://docs.scipy.org/doc/numpy/f2py/&quot;&gt;f2py&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3182c5f9b369539a27f1bc7716b92f10416add66" translate="yes" xml:space="preserve">
          <source>The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for these alternatives. For example, any of &amp;lsquo;&amp;gt;&amp;rsquo; or &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;brian&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">对于这些替代方案， &lt;code&gt;new_order&lt;/code&gt; 对new_order的第一个字母进行不区分大小写的检查。例如，&amp;ldquo;&amp;gt;&amp;rdquo;或&amp;ldquo; B&amp;rdquo;或&amp;ldquo; b&amp;rdquo;或&amp;ldquo; brian&amp;rdquo;中的任何一个都可以有效地指定big-endian。</target>
        </trans-unit>
        <trans-unit id="80380a308ceba94a9432deb39fde76dbd31d736a" translate="yes" xml:space="preserve">
          <source>The code in the second example is more efficient than that in the first because broadcasting moves less memory around during the multiplication (&lt;code&gt;b&lt;/code&gt; is a scalar rather than an array).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b154e2d8d3173f85d365231f520eaf5d3d14ed4d" translate="yes" xml:space="preserve">
          <source>The code to produce the figures is part of the &lt;a href=&quot;http://www.astroml.org/book_figures/appendix/fig_broadcast_visual.html&quot;&gt;AstroML book&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d7fde77cc6d2864c99d7d852dc9654a8a2c232a" translate="yes" xml:space="preserve">
          <source>The coefficient array representing their sum.</source>
          <target state="translated">代表其总和的系数数组。</target>
        </trans-unit>
        <trans-unit id="8877be945db0e0267ce25ed710aea10434e74470" translate="yes" xml:space="preserve">
          <source>The coefficient matrix of the coefficients &lt;code&gt;p&lt;/code&gt; is a Vandermonde matrix.</source>
          <target state="translated">系数 &lt;code&gt;p&lt;/code&gt; 的系数矩阵是范德蒙德矩阵。</target>
        </trans-unit>
        <trans-unit id="1749ca10e1fd82b0f81734b8e3040c222ba10138" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is 1 for monic polynomials in this form.</source>
          <target state="translated">对于这种形式的一元多项式,最后一项的系数为1。</target>
        </trans-unit>
        <trans-unit id="7f518b8b3d036f3e65aa1004d0ce4c9fe4f469f2" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Chebyshev form.</source>
          <target state="translated">对于切比雪夫形式的一元多项式,最后一项的系数一般不为1。</target>
        </trans-unit>
        <trans-unit id="c6e27aff7bd03298a7abe7cdd24c2851e78ffc19" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Hermite form.</source>
          <target state="translated">对于赫尔米特形式的一元多项式,最后一项的系数一般不为1。</target>
        </trans-unit>
        <trans-unit id="d8180193920e1d179284839e524518471959f55d" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in HermiteE form.</source>
          <target state="translated">对于HermiteE形式的一元多项式,最后一项的系数一般不为1。</target>
        </trans-unit>
        <trans-unit id="870417532aa77b335abb3ff61d44b3280649b54a" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Laguerre form.</source>
          <target state="translated">对于Laguerre形式的一元多项式,最后一项的系数一般不为1。</target>
        </trans-unit>
        <trans-unit id="d2eb9fcb4c7fc816e015e2f1263164865a84ea2c" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Legendre form.</source>
          <target state="translated">对于Legendre形式的一元多项式,最后一项的系数一般不为1。</target>
        </trans-unit>
        <trans-unit id="c0eab4462e93f35863c8383ff656ddde3733b00b" translate="yes" xml:space="preserve">
          <source>The coefficients are determined by multiplying together linear factors of the form &lt;code&gt;(x - r_i)&lt;/code&gt;, i.e.</source>
          <target state="translated">系数是通过将 &lt;code&gt;(x - r_i)&lt;/code&gt; 形式的线性因子相乘来确定的，即</target>
        </trans-unit>
        <trans-unit id="96b42532f49d3b3a4358a0737c1292c860f167f7" translate="yes" xml:space="preserve">
          <source>The column &lt;code&gt;v[:, i]&lt;/code&gt; is the normalized eigenvector corresponding to the eigenvalue &lt;code&gt;w[i]&lt;/code&gt;. Will return a matrix object if &lt;code&gt;a&lt;/code&gt; is a matrix object.</source>
          <target state="translated">列 &lt;code&gt;v[:, i]&lt;/code&gt; 是对应于特征值 &lt;code&gt;w[i]&lt;/code&gt; 的归一化特征向量。如果 &lt;code&gt;a&lt;/code&gt; 是矩阵对象，将返回一个矩阵对象。</target>
        </trans-unit>
        <trans-unit id="05afae6f6316038b8a077ed2d79753233c9700ab" translate="yes" xml:space="preserve">
          <source>The column dimension of the arrays for which the returned arrays will be valid. By default &lt;code&gt;m&lt;/code&gt; is taken equal to &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">返回数组将对其有效的数组的列维。默认情况下， &lt;code&gt;m&lt;/code&gt; 等于 &lt;code&gt;n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="049227627bd4dfed2d2a3d0a02023afddf2ece4d" translate="yes" xml:space="preserve">
          <source>The columns of the output matrix are powers of the input vector. The order of the powers is determined by the &lt;code&gt;increasing&lt;/code&gt; boolean argument. Specifically, when &lt;code&gt;increasing&lt;/code&gt; is False, the &lt;code&gt;i&lt;/code&gt;-th output column is the input vector raised element-wise to the power of &lt;code&gt;N - i - 1&lt;/code&gt;. Such a matrix with a geometric progression in each row is named for Alexandre- Theophile Vandermonde.</source>
          <target state="translated">输出矩阵的列是输入向量的幂。幂的顺序由 &lt;code&gt;increasing&lt;/code&gt; 布尔参数确定。具体来说，当 &lt;code&gt;increasing&lt;/code&gt; 为False时，第 &lt;code&gt;i&lt;/code&gt; 个输出列是逐元素提高到 &lt;code&gt;N - i - 1&lt;/code&gt; 的幂的输入向量。每行中具有几何级数的矩阵以Alexandre-Theophile Vandermonde的名字命名。</target>
        </trans-unit>
        <trans-unit id="fd5ff7ed1e1b0436ec4f4722206a381ca973b853" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;make test&lt;/code&gt; will ensure that all of the test software is built and then run all three test scripts.</source>
          <target state="translated">命令 &lt;code&gt;make test&lt;/code&gt; 将确保已构建所有测试软件，然后运行所有三个测试脚本。</target>
        </trans-unit>
        <trans-unit id="e66bb28254c2c47afebe31be29c7f178c6baf9ce" translate="yes" xml:space="preserve">
          <source>The committee must agree on a resolution by consensus. If the group cannot reach consensus and deadlocks for over a week, the group will turn the matter over to the Steering Council for resolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f296a348ca6c5f048bde7ff72475becfa99bfb54" translate="yes" xml:space="preserve">
          <source>The committee will never publicly discuss the issue; all public statements will be made by the chair of the Code of Conduct Committee or the NumPy Steering Council.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da455687a62d6eecd2b4975d23b71811215c8f1" translate="yes" xml:space="preserve">
          <source>The committee will respond to any report as soon as possible, and at most within 72 hours.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b080620b2cb81b4501691bc62009a0f3cdee2b1d" translate="yes" xml:space="preserve">
          <source>The committee will then review the incident and determine, to the best of their ability:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24aa155f0fb452987333532fc0871b6b96e25258" translate="yes" xml:space="preserve">
          <source>The common data type, which is the maximum of &lt;code&gt;array_types&lt;/code&gt; ignoring &lt;code&gt;scalar_types&lt;/code&gt;, unless the maximum of &lt;code&gt;scalar_types&lt;/code&gt; is of a different kind (&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt;&lt;code&gt;dtype.kind&lt;/code&gt;&lt;/a&gt;). If the kind is not understood, then None is returned.</source>
          <target state="translated">所述公共数据类型，这是最大的 &lt;code&gt;array_types&lt;/code&gt; 忽略 &lt;code&gt;scalar_types&lt;/code&gt; ，除非最大的 &lt;code&gt;scalar_types&lt;/code&gt; 是不同种类的（的&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt; &lt;code&gt;dtype.kind&lt;/code&gt; &lt;/a&gt;）。如果不了解种类，则返回None。</target>
        </trans-unit>
        <trans-unit id="6557c9bc2aa7a334ee156279cd2e6ed26882b290" translate="yes" xml:space="preserve">
          <source>The common fill value, or None.</source>
          <target state="translated">常用的填充值,或无。</target>
        </trans-unit>
        <trans-unit id="792a2de181f669c74b9db5a5aeebd6abe9c93185" translate="yes" xml:space="preserve">
          <source>The common situations in which you need to change byte ordering are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c4929011c41aa057f46d2bc4e51aaccf9a85a1" translate="yes" xml:space="preserve">
          <source>The companion matrix for power series cannot be made symmetric by scaling the basis, so this function differs from those for the orthogonal polynomials.</source>
          <target state="translated">幂级数的伴生矩阵不能通过缩放基数使其对称,所以这个函数与正交多项式的函数不同。</target>
        </trans-unit>
        <trans-unit id="50728cc7411772baf0d23ae9dab7a04fd085919c" translate="yes" xml:space="preserve">
          <source>The comparison of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; uses standard broadcasting, which means that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; need not have the same shape in order for &lt;code&gt;allclose(a, b)&lt;/code&gt; to evaluate to True. The same is true for &lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/a&gt; but not &lt;a href=&quot;numpy.array_equal#numpy.array_equal&quot;&gt;&lt;code&gt;array_equal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的比较使用标准广播，这意味着 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 不必具有相同的形状即可使 &lt;code&gt;allclose(a, b)&lt;/code&gt; 评估为True。对于&lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt; &lt;code&gt;equal&lt;/code&gt; ,&lt;/a&gt;但不是&lt;a href=&quot;numpy.array_equal#numpy.array_equal&quot;&gt; &lt;code&gt;array_equal&lt;/code&gt; ,&lt;/a&gt;这同样适用。</target>
        </trans-unit>
        <trans-unit id="ed9a376f5659e4753c56a46ffbea586e1c5b762b" translate="yes" xml:space="preserve">
          <source>The complex conjugate of &lt;code&gt;x&lt;/code&gt;, with same dtype as &lt;code&gt;y&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的复共轭，与 &lt;code&gt;y&lt;/code&gt; 的 dtype相同。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="d1ca0ff74dd3394813701dd385de23f306fa9c69" translate="yes" xml:space="preserve">
          <source>The complex conjugate of a complex number is obtained by changing the sign of its imaginary part.</source>
          <target state="translated">一个复数的复共轭是通过改变其虚部的符号得到的。</target>
        </trans-unit>
        <trans-unit id="41eb6fa093181f73897902c7f0874292edf29e51" translate="yes" xml:space="preserve">
          <source>The compressed array.</source>
          <target state="translated">压缩阵列。</target>
        </trans-unit>
        <trans-unit id="5eb5823a400c379807aed8ab125dee97f320721d" translate="yes" xml:space="preserve">
          <source>The concatenated array with any masked entries preserved.</source>
          <target state="translated">保留了任何掩码条目的连接数组。</target>
        </trans-unit>
        <trans-unit id="a37868502a5a0d6add95945d1a64803e757adeaa" translate="yes" xml:space="preserve">
          <source>The concatenated array.</source>
          <target state="translated">串联的数组。</target>
        </trans-unit>
        <trans-unit id="3af59c1bb124d9d3dff66fb6d58de527a5027e82" translate="yes" xml:space="preserve">
          <source>The concept of a behaved segment is used in the description of the function pointers. A behaved segment is one that is aligned and in native machine byte-order for the data-type. The &lt;code&gt;nonzero&lt;/code&gt;, &lt;code&gt;copyswap&lt;/code&gt;, &lt;code&gt;copyswapn&lt;/code&gt;, &lt;code&gt;getitem&lt;/code&gt;, and &lt;code&gt;setitem&lt;/code&gt; functions can (and must) deal with mis-behaved arrays. The other functions require behaved memory segments.</source>
          <target state="translated">行为段的概念在函数指针的描述中使用。正常运行的段是对齐的段，并按本机字节顺序排列为数据类型。的 &lt;code&gt;nonzero&lt;/code&gt; ， &lt;code&gt;copyswap&lt;/code&gt; ， &lt;code&gt;copyswapn&lt;/code&gt; ， &lt;code&gt;getitem&lt;/code&gt; 和 &lt;code&gt;setitem&lt;/code&gt; 功能可以（而且必须）处理误表现阵列。其他功能需要正常运行的内存段。</target>
        </trans-unit>
        <trans-unit id="46e686c81ff0f33a7ee42cbdb148b2206e722231" translate="yes" xml:space="preserve">
          <source>The condition number of &lt;code&gt;x&lt;/code&gt; is defined as the norm of &lt;code&gt;x&lt;/code&gt; times the norm of the inverse of &lt;code&gt;x&lt;/code&gt;&lt;a href=&quot;#r611900c44d60-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;; the norm can be the usual L2-norm (root-of-sum-of-squares) or one of a number of other matrix norms.</source>
          <target state="translated">的条件数 &lt;code&gt;x&lt;/code&gt; 被定义为的范数 &lt;code&gt;x&lt;/code&gt; 次的逆的范数 &lt;code&gt;x&lt;/code&gt; &lt;a href=&quot;#r611900c44d60-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; ; 范数可以是通常的L2范数（平方和），也可以是许多其他矩阵范数之一。</target>
        </trans-unit>
        <trans-unit id="7ed508e4defcab357510ceacda28d2924496cd06" translate="yes" xml:space="preserve">
          <source>The condition number of the matrix. May be infinite.</source>
          <target state="translated">矩阵的条件数。可能是无限的。</target>
        </trans-unit>
        <trans-unit id="c901451fe41cf6f1482465c84b6a4c739cbccbff" translate="yes" xml:space="preserve">
          <source>The config file generated from &lt;code&gt;template&lt;/code&gt; is installed in the given install directory, using &lt;code&gt;subst_dict&lt;/code&gt; for variable substitution.</source>
          <target state="translated">从 &lt;code&gt;template&lt;/code&gt; 生成的配置文件安装在给定的安装目录中，使用 &lt;code&gt;subst_dict&lt;/code&gt; 进行变量替换。</target>
        </trans-unit>
        <trans-unit id="2fe0070d6ccb31708b92b4e4ed2caabdfe3d249d" translate="yes" xml:space="preserve">
          <source>The constants &lt;strong&gt;NPY_INTP&lt;/strong&gt; and &lt;strong&gt;NPY_UINTP&lt;/strong&gt; refer to an enumerated integer type that is large enough to hold a pointer on the platform. Index arrays should always be converted to &lt;strong&gt;NPY_INTP&lt;/strong&gt; , because the dimension of the array is of type npy_intp.</source>
          <target state="translated">常量&lt;strong&gt;NPY_INTP&lt;/strong&gt;和&lt;strong&gt;NPY_UINTP&lt;/strong&gt;引用枚举的整数类型，该类型足够大以将指针保持在平台上。索引数组应始终转换为&lt;strong&gt;NPY_INTP&lt;/strong&gt;，因为数组的维类型为npy_intp。</target>
        </trans-unit>
        <trans-unit id="fd8a200b77c06e1513f552e8d61858be6438182d" translate="yes" xml:space="preserve">
          <source>The constructed array.</source>
          <target state="translated">构建的数组。</target>
        </trans-unit>
        <trans-unit id="8c8c3ae23d3b8b9d4c2965f608e114605317b1d2" translate="yes" xml:space="preserve">
          <source>The constructed extension module is saved as &lt;code&gt;&amp;lt;modulename&amp;gt;module.c&lt;/code&gt; to the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1564bd8e09196ae3556506f90562583aff6d8fc2" translate="yes" xml:space="preserve">
          <source>The content of a modified version of &lt;code&gt;fib1.pyf&lt;/code&gt; (saved as &lt;code&gt;fib2.pyf&lt;/code&gt;) is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f12164e316c899cbeec8a520db14b994fa35a8e" translate="yes" xml:space="preserve">
          <source>The contiguous constraint applies only to the inner loop, successive inner loops may have arbitrary pointer changes.</source>
          <target state="translated">连续约束只适用于内循环,连续的内循环可能有任意的指针变化。</target>
        </trans-unit>
        <trans-unit id="a28f32d0e2528be0855bfa01e7539cc0e939d215" translate="yes" xml:space="preserve">
          <source>The convenience classes provided by the polynomial package are:</source>
          <target state="translated">多项式包提供的方便类有:。</target>
        </trans-unit>
        <trans-unit id="5a4e9570e8f8bcacc96f206106a01eefad39bd6f" translate="yes" xml:space="preserve">
          <source>The convert method can also convert domain and window:</source>
          <target state="translated">转换方法还可以转换域和窗口。</target>
        </trans-unit>
        <trans-unit id="60131768e228b843852dbff6de95273c5e8b7bcb" translate="yes" xml:space="preserve">
          <source>The converted data-type.</source>
          <target state="translated">转换后的数据类型。</target>
        </trans-unit>
        <trans-unit id="1fc6b89fce1f12a34477c12a69d7cd751ad23c91" translate="yes" xml:space="preserve">
          <source>The convolution operator is often seen in signal processing, where it models the effect of a linear time-invariant system on a signal &lt;a href=&quot;#r95849f33d2b1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. In probability theory, the sum of two independent random variables is distributed according to the convolution of their individual distributions.</source>
          <target state="translated">卷积算子在信号处理中经常见到，它在信号上模拟了线性时不变系统的效果&lt;a href=&quot;#r95849f33d2b1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。在概率论中，两个独立随机变量之和是根据它们各自分布的卷积分布的。</target>
        </trans-unit>
        <trans-unit id="1b7a113f553d13745aed52a84f8c20493ad427e3" translate="yes" xml:space="preserve">
          <source>The coordinates member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure maintains the current N-d counter unless the underlying array is C-contiguous in which case the coordinate counting is by-passed. The index member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the current flat index of the iterator. It is updated by the &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">除非基础数组是C连续的，否则&lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;结构的坐标成员将维护当前的Nd计数器，在这种情况下，绕过坐标计数。&lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;的索引成员跟踪迭代器的当前平面索引。它由&lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt;宏更新。</target>
        </trans-unit>
        <trans-unit id="a60368fcddf184df8cd7ef5081ac979bc50c50f2" translate="yes" xml:space="preserve">
          <source>The coordinates member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure maintains the current N-d counter unless the underlying array is C-contiguous in which case the coordinate counting is by-passed. The index member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the current flat index of the iterator. It is updated by the &lt;a href=&quot;c-api/array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893c6dfe4a5a151e44d6687fac35fbd3b646a45a" translate="yes" xml:space="preserve">
          <source>The core dimensions are removed from all inputs and the remaining dimensions are broadcast together, defining the loop dimensions.</source>
          <target state="translated">核心维度从所有输入中移除,其余维度一起广播,定义循环维度。</target>
        </trans-unit>
        <trans-unit id="72b350bebf37a78a10162e24af07cb3168e9e839" translate="yes" xml:space="preserve">
          <source>The core of the ufunc is the &lt;a href=&quot;#c.PyUFuncObject&quot;&gt;&lt;code&gt;PyUFuncObject&lt;/code&gt;&lt;/a&gt; which contains all the information needed to call the underlying C-code loops that perform the actual work. While it is described here for completeness, it should be considered internal to NumPy and manipulated via &lt;code&gt;PyUFunc_*&lt;/code&gt; functions. The size of this structure is subject to change across versions of NumPy. To ensure compatibility:</source>
          <target state="translated">&lt;a href=&quot;#c.PyUFuncObject&quot;&gt; &lt;code&gt;PyUFuncObject&lt;/code&gt; &lt;/a&gt;的核心是PyUFuncObject，它包含调用执行实际工作的基础C代码循环所需的所有信息。虽然此处出于完整性考虑对其进行了描述，但应将其视为NumPy的内部内容，并通过 &lt;code&gt;PyUFunc_*&lt;/code&gt; 函数进行操作。此结构的大小可能会在NumPy的各个版本中发生变化。为确保兼容性：</target>
        </trans-unit>
        <trans-unit id="773b5bb85bcdc60b3e588df5ec27ee1692be9141" translate="yes" xml:space="preserve">
          <source>The correct interpretation of the hermitian input depends on the length of the original data, as given by &lt;code&gt;n&lt;/code&gt;. This is because each input shape could correspond to either an odd or even length signal. By default, &lt;a href=&quot;#numpy.fft.hfft&quot;&gt;&lt;code&gt;hfft&lt;/code&gt;&lt;/a&gt; assumes an even output length which puts the last entry at the Nyquist frequency; aliasing with its symmetric counterpart. By Hermitian symmetry, the value is thus treated as purely real. To avoid losing information, the shape of the full signal &lt;strong&gt;must&lt;/strong&gt; be given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b1507243ebb36968e1fec7c90425484cafd21a" translate="yes" xml:space="preserve">
          <source>The correct interpretation of the hermitian input depends on the length of the original data, as given by &lt;code&gt;n&lt;/code&gt;. This is because each input shape could correspond to either an odd or even length signal. By default, &lt;a href=&quot;#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; assumes an even output length which puts the last entry at the Nyquist frequency; aliasing with its symmetric counterpart. By Hermitian symmetry, the value is thus treated as purely real. To avoid losing information, the correct length of the real input &lt;strong&gt;must&lt;/strong&gt; be given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37beab5b2e24a56105c7c01133a885f5a78e9481" translate="yes" xml:space="preserve">
          <source>The correct interpretation of the hermitian input depends on the shape of the original data, as given by &lt;code&gt;s&lt;/code&gt;. This is because each input shape could correspond to either an odd or even length signal. By default, &lt;a href=&quot;#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt; assumes an even output length which puts the last entry at the Nyquist frequency; aliasing with its symmetric counterpart. When performing the final complex to real transform, the last value is thus treated as purely real. To avoid losing information, the correct shape of the real input &lt;strong&gt;must&lt;/strong&gt; be given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b4be14cc8fe5491309195ba608e3525321fc00" translate="yes" xml:space="preserve">
          <source>The correlation coefficient matrix of the variables.</source>
          <target state="translated">变量的相关系数矩阵。</target>
        </trans-unit>
        <trans-unit id="f4e710373f0588180cd5157b94f36ff64a509ad5" translate="yes" xml:space="preserve">
          <source>The corresponding angle in degrees. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的角度（以度为单位）。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="a2c63fcb50ab2a66bb9a9ad01ce9f4ff69c1d271" translate="yes" xml:space="preserve">
          <source>The corresponding angle in radians. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的角度（以弧度为单位）。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="1f2189e088542b025710d6c9de389530dc9fecea" translate="yes" xml:space="preserve">
          <source>The corresponding argument is a function provided by user. The signature of this so-called call-back function can be defined</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f35b3b067b2fb40c400d505d2d253ac20a239da1" translate="yes" xml:space="preserve">
          <source>The corresponding argument is considered as a required one. This is default. You need to specify &lt;code&gt;required&lt;/code&gt; only if there is a need to disable automatic &lt;code&gt;optional&lt;/code&gt; setting when &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b483a77dd25e17d676f790b212de11141a0187e" translate="yes" xml:space="preserve">
          <source>The corresponding argument is moved to the end of &lt;code&gt;&amp;lt;optional
arguments&amp;gt;&lt;/code&gt; list. A default value for an optional argument can be specified &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt;, see &lt;code&gt;entitydecl&lt;/code&gt; definition. Note that the default value must be given as a valid C expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2babda63010514076aef395fac45645683b9564" translate="yes" xml:space="preserve">
          <source>The corresponding array scalar type is &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="translated">对应的数组标量类型为 &lt;code&gt;int32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd11fa4205dd5b33a3e2b183413534954599bad7" translate="yes" xml:space="preserve">
          <source>The corresponding cosine values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">对应的余弦值。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="6d98f6605847a59a64fcad02a0b3d4fdfd44ca3d" translate="yes" xml:space="preserve">
          <source>The corresponding degree values; if &lt;code&gt;out&lt;/code&gt; was supplied this is a reference to it. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的度值；如果 &lt;code&gt;out&lt;/code&gt; 供给，这是它的一个引用。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="2584010810109879710934f24451582df80fa088" translate="yes" xml:space="preserve">
          <source>The corresponding hyperbolic sine values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的双曲正弦值。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="2f46b05f80b785698faf42d321e3104fa7625e8a" translate="yes" xml:space="preserve">
          <source>The corresponding hyperbolic tangent values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的双曲正切值。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="d9ca95035c9f509708b9e99487c1ebe9e3ab11bd" translate="yes" xml:space="preserve">
          <source>The corresponding radian values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的弧度值。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="c1e4a7360c69977ad10edc5bee560d5ac06dcf90" translate="yes" xml:space="preserve">
          <source>The corresponding tangent values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">相应的切线值。如果 &lt;code&gt;x&lt;/code&gt; 是标量，则这是标量。</target>
        </trans-unit>
        <trans-unit id="794da0dacd34a3a537b8957b7fa2b5dd6a0fb954" translate="yes" xml:space="preserve">
          <source>The corresponding user-provided Python function are then:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e664cdf4ef8fa1adefc68661d3976d497abf20" translate="yes" xml:space="preserve">
          <source>The corresponding variable is Fortran 90 allocatable array defined as Fortran 90 module data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e42f957c48b62c124f0261112a23bae77caa2c" translate="yes" xml:space="preserve">
          <source>The corresponding variable is a parameter and it must have a fixed value. F2PY replaces all parameter occurrences by their corresponding values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2320966ba7c65e57cb9263bdefeef1fa1cb2d7e" translate="yes" xml:space="preserve">
          <source>The corresponding variable is considered as an array with given dimensions in &lt;code&gt;&amp;lt;arrayspec&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1763b6e0e62ea8d29f68696fab1bd4ea96474d4" translate="yes" xml:space="preserve">
          <source>The cost for a matrix multiplication can be calculated with the following function:</source>
          <target state="translated">矩阵乘法的成本可以用以下函数计算:</target>
        </trans-unit>
        <trans-unit id="6933bada15117031adec212786a3dbdf77a91aff" translate="yes" xml:space="preserve">
          <source>The costs for the two different parenthesizations are as follows:</source>
          <target state="translated">两种不同括号的费用如下:</target>
        </trans-unit>
        <trans-unit id="71417050531966fa2bba7739241abcc4b67310e0" translate="yes" xml:space="preserve">
          <source>The counterclockwise angle from the positive real axis on the complex plane in the range &lt;code&gt;(-pi, pi]&lt;/code&gt;, with dtype as numpy.float64.</source>
          <target state="translated">与复平面上的正实轴的逆时针角度在 &lt;code&gt;(-pi, pi]&lt;/code&gt; 范围内， dtype为numpy.float64。</target>
        </trans-unit>
        <trans-unit id="1b6aacea9be65b883730cfcba5386d3d1b9a0223" translate="yes" xml:space="preserve">
          <source>The cov input is used to compute a factor matrix A such that &lt;code&gt;A @ A.T = cov&lt;/code&gt;. This argument is used to select the method used to compute the factor matrix A. The default method &amp;lsquo;svd&amp;rsquo; is the slowest, while &amp;lsquo;cholesky&amp;rsquo; is the fastest but less robust than the slowest method. The method &lt;code&gt;eigh&lt;/code&gt; uses eigen decomposition to compute A and is faster than svd but slower than cholesky.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="703b92f1857fec3346f55e95a27ed079fdf918ac" translate="yes" xml:space="preserve">
          <source>The covariance matrix of the variables.</source>
          <target state="translated">变量的协方差矩阵。</target>
        </trans-unit>
        <trans-unit id="f56bfc3801b5981a49e90ddd94a5011933b03e11" translate="yes" xml:space="preserve">
          <source>The cross product of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in</source>
          <target state="translated">的叉积 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 中</target>
        </trans-unit>
        <trans-unit id="430c46a913654deeda9ef3928a00e710ee9f7b73" translate="yes" xml:space="preserve">
          <source>The ctypes attribute of an ndarray is also endowed with additional attributes that may be convenient when passing additional information about the array into a ctypes function. The attributes &lt;strong&gt;data&lt;/strong&gt;, &lt;strong&gt;shape&lt;/strong&gt;, and &lt;strong&gt;strides&lt;/strong&gt; can provide ctypes compatible types corresponding to the data-area, the shape, and the strides of the array. The data attribute returns a &lt;code&gt;c_void_p&lt;/code&gt; representing a pointer to the data area. The shape and strides attributes each return an array of ctypes integers (or None representing a NULL pointer, if a 0-d array). The base ctype of the array is a ctype integer of the same size as a pointer on the platform. There are also methods &lt;code&gt;data_as({ctype})&lt;/code&gt;, &lt;code&gt;shape_as(&amp;lt;base ctype&amp;gt;)&lt;/code&gt;, and &lt;code&gt;strides_as(&amp;lt;base
ctype&amp;gt;)&lt;/code&gt;. These return the data as a ctype object of your choice and the shape/strides arrays using an underlying base type of your choice. For convenience, the &lt;code&gt;ctypeslib&lt;/code&gt; module also contains &lt;code&gt;c_intp&lt;/code&gt; as a ctypes integer data-type whose size is the same as the size of &lt;code&gt;c_void_p&lt;/code&gt; on the platform (its value is None if ctypes is not installed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70737d8a9b599cea578eef90e469f4ec5cade8d" translate="yes" xml:space="preserve">
          <source>The cumulative product for each column (i.e., over the rows) of &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">对于每列（即，在所述行）所述累积产 &lt;code&gt;a&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4974aaba8d216c55c50471b0bc56ddd6323d0ebc" translate="yes" xml:space="preserve">
          <source>The cumulative product for each row (i.e. over the columns) of &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">对于每一行（即在列）累计产品 &lt;code&gt;a&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="50631d91282d5f6763c8dcfd14a90d74339342d9" translate="yes" xml:space="preserve">
          <source>The current (1-d) index into the broadcasted result.</source>
          <target state="translated">当前(1-d)索引进入广播结果。</target>
        </trans-unit>
        <trans-unit id="8c233acaa927b0b3ae6437f9077a3fae3621ed5f" translate="yes" xml:space="preserve">
          <source>The current 1-d index into the array.</source>
          <target state="translated">数组中当前的1-d索引。</target>
        </trans-unit>
        <trans-unit id="2fbbd9d31a318df9bc191ffa89f350440a39a71f" translate="yes" xml:space="preserve">
          <source>The current Python interface to the &lt;code&gt;f2py&lt;/code&gt; module is not mature and may change in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb3baf8a681bbb5337a5050d23b30de4d838c39" translate="yes" xml:space="preserve">
          <source>The current error handler. If no handler was set through &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">当前的错误处理程序。如果没有通过&lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt;设置处理程序，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67a8fb2d19e8571c91416871498dce96f7ad1021" translate="yes" xml:space="preserve">
          <source>The current info on building and releasing NumPy and SciPy is scattered in several places. It should be summarized in one place, updated, and where necessary described in more detail. The sections below list all places where useful info can be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd1e82b97c62204928be3c1426e12c2f8f2093c" translate="yes" xml:space="preserve">
          <source>The current interface remains unchanged, and &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; can still be used to implement (specialized) ufuncs, consisting of scalar elementary functions.</source>
          <target state="translated">当前接口保持不变，并且 &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; 仍可用于实现（特殊的）ufunc，它由标量基本函数组成。</target>
        </trans-unit>
        <trans-unit id="0ec2778c22d5d6f2fae8e55f79998855331eeed7" translate="yes" xml:space="preserve">
          <source>The current membership of the NumFOCUS Subcommittee is listed at the page &lt;a href=&quot;people#governance-people&quot;&gt;Current steering council and institutional partners&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4809e84f7d3a9eb68e3d6e9384c7ac43b19e108c" translate="yes" xml:space="preserve">
          <source>The current version of the ndarray object (check to see if this variable is defined to guarantee the numpy/arrayobject.h header is being used).</source>
          <target state="translated">ndarray对象的当前版本(检查是否定义了这个变量以保证numpy/arrayobject.h头被使用)。</target>
        </trans-unit>
        <trans-unit id="d02692cc2b9183733a0e1ac33e907e722f2cb651" translate="yes" xml:space="preserve">
          <source>The data actually stored in object arrays (&lt;em&gt;i.e.&lt;/em&gt;, arrays having dtype &lt;code&gt;object_&lt;/code&gt;) are references to Python objects, not the objects themselves. Hence, object arrays behave more like usual Python &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt;&lt;code&gt;lists&lt;/code&gt;&lt;/a&gt;, in the sense that their contents need not be of the same Python type.</source>
          <target state="translated">实际上存储在对象数组（&lt;em&gt;即&lt;/em&gt;，具有 &lt;code&gt;object_&lt;/code&gt; 数组）中的数据是对Python对象的引用，而不是对象本身。因此，对象数组的行为更像是普通的Python &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt; &lt;code&gt;lists&lt;/code&gt; &lt;/a&gt;，从某种意义上说，它们的内容不必是相同的Python类型。</target>
        </trans-unit>
        <trans-unit id="2b8f4fa1516918fd8297afcfb360ffa13708823d" translate="yes" xml:space="preserve">
          <source>The data and all elements are aligned appropriately for the hardware.</source>
          <target state="translated">数据和所有的元素都是针对硬件进行适当的排列。</target>
        </trans-unit>
        <trans-unit id="3286aa81b485c3d7add58cb76776a5c44fcb4bf2" translate="yes" xml:space="preserve">
          <source>The data area and all array elements are aligned appropriately.</source>
          <target state="translated">数据区和所有的数组元素都适当地对齐。</target>
        </trans-unit>
        <trans-unit id="c1365a86184a90bddcccd2199d804c180d307014" translate="yes" xml:space="preserve">
          <source>The data area can be written to.</source>
          <target state="translated">可以写入数据区。</target>
        </trans-unit>
        <trans-unit id="539587e7a7889df8e80a73151cc3ac06f87c111c" translate="yes" xml:space="preserve">
          <source>The data area can be written to. Setting this to False locks the data, making it read-only. A view (slice, etc.) inherits WRITEABLE from its base array at creation time, but a view of a writeable array may be subsequently locked while the base array remains writeable. (The opposite is not true, in that a view of a locked array may not be made writeable. However, currently, locking a base object does not lock any views that already reference it, so under that circumstance it is possible to alter the contents of a locked array via a previously created writeable view onto it.) Attempting to change a non-writeable array raises a RuntimeError exception.</source>
          <target state="translated">数据区域可以被写入。将此设置为False会锁定数据,使其成为只读数据。视图(片等)在创建时从它的基数组继承WRITEABLE,但一个可写数组的视图可能随后被锁定,而基数组仍可写。(反之则不然,一个被锁定的数组的视图可能不会被变成可写的)。然而,目前,锁定一个基础对象并不会锁定任何已经引用它的视图,所以在这种情况下,可以通过先前创建的可写视图来改变一个锁定数组的内容。)试图改变一个非可写数组会引发一个RuntimeError异常。</target>
        </trans-unit>
        <trans-unit id="dfe7ced9a654feaf927f01f408558bf43f63134c" translate="yes" xml:space="preserve">
          <source>The data area is in C-style contiguous order (last index varies the fastest).</source>
          <target state="translated">数据区采用C式连续顺序(最后一个索引变化最快)。</target>
        </trans-unit>
        <trans-unit id="28271e4f2d83215b5c3293be14583eebd0638934" translate="yes" xml:space="preserve">
          <source>The data area is in Fortran-style contiguous order (first index varies the fastest).</source>
          <target state="translated">数据区按Fortran式的连续顺序(第一索引变化最快)。</target>
        </trans-unit>
        <trans-unit id="a2e621a0b9254b737a1faf535f1456a6f33c01ae" translate="yes" xml:space="preserve">
          <source>The data area is owned by this array.</source>
          <target state="translated">数据区由这个数组拥有。</target>
        </trans-unit>
        <trans-unit id="ca9e054ad351441ecdb18cea4952500858e11b12" translate="yes" xml:space="preserve">
          <source>The data area represents a (well-behaved) copy whose information should be transferred back to the original when &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">数据区域表示一个（行为良好的）副本，当&lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;时，其信息应传输回原始文件。</target>
        </trans-unit>
        <trans-unit id="15eb3cf2a1c1abdf07a79e9fe9ea7b5a63c62afd" translate="yes" xml:space="preserve">
          <source>The data in the array is returned as a single string. This function is similar to &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt;, the difference being that &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt; also returns information on the kind of array and its data type.</source>
          <target state="translated">数组中的数据作为单个字符串返回。此函数类似于&lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt;，不同之处在于&lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt;还返回有关数组类型及其数据类型的信息。</target>
        </trans-unit>
        <trans-unit id="4cbbe8ca710f692f60ad1bfe0fc2af00b27f6fa9" translate="yes" xml:space="preserve">
          <source>The data in the same field can be heterogeneous, they will be promoted to the highest data type. This method is intended for creating smaller record arrays. If used to create large array without formats defined</source>
          <target state="translated">同一字段中的数据可以是异构的,它们将被提升到最高的数据类型。此方法用于创建较小的记录数组。如果用于创建没有定义格式的大数组</target>
        </trans-unit>
        <trans-unit id="f030fb38724d73d189a884d6cd4eaca4e1c69e90" translate="yes" xml:space="preserve">
          <source>The data is in a single, C-style contiguous segment.</source>
          <target state="translated">数据是在一个单一的C型连续段中。</target>
        </trans-unit>
        <trans-unit id="5f1d8da4b437441472e9916d9ae01c496d02e5d4" translate="yes" xml:space="preserve">
          <source>The data is in a single, Fortran-style contiguous segment.</source>
          <target state="translated">数据是在一个单一的、Fortran式的连续段中。</target>
        </trans-unit>
        <trans-unit id="56a1a480524e7bf67ab594cb10c3c6101b00713c" translate="yes" xml:space="preserve">
          <source>The data of the resulting array will not be byteswapped, but will be interpreted correctly.</source>
          <target state="translated">结果数组的数据不会被字节交换,但会被正确解释。</target>
        </trans-unit>
        <trans-unit id="b88d2dbaff9987ad87362817ef4a120d93a6244e" translate="yes" xml:space="preserve">
          <source>The data to be histogrammed.</source>
          <target state="translated">要进行直方图测量的数据。</target>
        </trans-unit>
        <trans-unit id="5386b778229b14d65914edc6d972b4efb28b5001" translate="yes" xml:space="preserve">
          <source>The data type object associated with the array can be found in the &lt;a href=&quot;generated/numpy.ndarray.dtype#numpy.ndarray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; attribute:</source>
          <target state="translated">与数组关联的数据类型对象可以在&lt;a href=&quot;generated/numpy.ndarray.dtype#numpy.ndarray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;属性中找到：</target>
        </trans-unit>
        <trans-unit id="1c7886ffa6332318e280aa7625497d4df1ee7f24" translate="yes" xml:space="preserve">
          <source>The data type of &lt;code&gt;rep&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rep&lt;/code&gt; 的数据类型。</target>
        </trans-unit>
        <trans-unit id="4b822d3fbc39f811ebad48ba4194f76d214d3123" translate="yes" xml:space="preserve">
          <source>The data type of an operand with this flag should be either &lt;a href=&quot;c-api.dtype#c.NPY_BOOL&quot;&gt;&lt;code&gt;NPY_BOOL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_MASK&quot;&gt;&lt;code&gt;NPY_MASK&lt;/code&gt;&lt;/a&gt;, or a struct dtype whose fields are all valid mask dtypes. In the latter case, it must match up with a struct operand being WRITEMASKED, as it is specifying a mask for each field of that array.</source>
          <target state="translated">具有此标志的操作数的数据类型应为&lt;a href=&quot;c-api.dtype#c.NPY_BOOL&quot;&gt; &lt;code&gt;NPY_BOOL&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;c-api.dtype#c.NPY_MASK&quot;&gt; &lt;code&gt;NPY_MASK&lt;/code&gt; &lt;/a&gt;或结构dtype，其字段均为有效的掩码dtype。在后一种情况下，它必须与结构操作数WRITEMASKED相匹配，因为它正在为该数组的每个字段指定一个掩码。</target>
        </trans-unit>
        <trans-unit id="ba40ae5f60c6c9bf8317272fcf427a71c0e5f01a" translate="yes" xml:space="preserve">
          <source>The data type of an operand with this flag should be either &lt;a href=&quot;dtype#c.NPY_BOOL&quot;&gt;&lt;code&gt;NPY_BOOL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_MASK&quot;&gt;&lt;code&gt;NPY_MASK&lt;/code&gt;&lt;/a&gt;, or a struct dtype whose fields are all valid mask dtypes. In the latter case, it must match up with a struct operand being WRITEMASKED, as it is specifying a mask for each field of that array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11db59fda83e28216c250b45f855268127882d3e" translate="yes" xml:space="preserve">
          <source>The data type of the array; default: float. For binary input data, the data must be in exactly this format.</source>
          <target state="translated">数组的数据类型,默认:float。对于二进制输入数据,数据必须是这种格式。</target>
        </trans-unit>
        <trans-unit id="7ef4dd0c7cf28c23f4cb2015d84e3c63ca538a1e" translate="yes" xml:space="preserve">
          <source>The data type of the array; default: float. For binary input data, the data must be in exactly this format. Most builtin numeric types are supported and extension types may be supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6121c8d9cd39c4f61e9ffef0d098e3b7d36639d6" translate="yes" xml:space="preserve">
          <source>The data type of the output of &lt;code&gt;vectorized&lt;/code&gt; is determined by calling the function with the first element of the input. This can be avoided by specifying the &lt;code&gt;otypes&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;vectorized&lt;/code&gt; 输出的数据类型是通过使用输入的第一个元素调用函数来确定的。通过指定 &lt;code&gt;otypes&lt;/code&gt; 参数可以避免这种情况。</target>
        </trans-unit>
        <trans-unit id="bc2814a7f847db35d30b7458174ec64d03a7e7a5" translate="yes" xml:space="preserve">
          <source>The data type of the view. The dtype size of the view can not be larger than that of the array itself.</source>
          <target state="translated">视图的数据类型。视图的dtype大小不能大于数组本身。</target>
        </trans-unit>
        <trans-unit id="99643c3f7e25f9a00992f90ee5d0bdd7cb79f63e" translate="yes" xml:space="preserve">
          <source>The data types of the values provided in &lt;a href=&quot;numpy.nditer.value#numpy.nditer.value&quot;&gt;&lt;code&gt;value&lt;/code&gt;&lt;/a&gt;. This may be different from the operand data types if buffering is enabled. Valid only before the iterator is closed.</source>
          <target state="translated">value中提供的&lt;a href=&quot;numpy.nditer.value#numpy.nditer.value&quot;&gt; &lt;code&gt;value&lt;/code&gt; &lt;/a&gt;的数据类型。如果启用了缓冲，这可能与操作数数据类型不同。仅在关闭迭代器之前有效。</target>
        </trans-unit>
        <trans-unit id="9d016fef105a6db00651ac782a1c7e9c999e6600" translate="yes" xml:space="preserve">
          <source>The data-type is an important abstraction of the ndarray. Operations will look to the data-type to provide the key functionality that is needed to operate on the array. This functionality is provided in the list of function pointers pointed to by the &amp;lsquo;f&amp;rsquo; member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure. In this way, the number of data-types can be extended simply by providing a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure with suitable function pointers in the &amp;lsquo;f&amp;rsquo; member. For built-in types there are some optimizations that by-pass this mechanism, but the point of the data- type abstraction is to allow new data-types to be added.</source>
          <target state="translated">数据类型是ndarray的重要抽象。操作将寻找数据类型，以提供对阵列进行操作所需的关键功能。在&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;结构的'f'成员指向的函数指针列表中提供了此功能。这样，只需在&lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt;结构中为'f'成员提供适当的函数指针，即可扩展数据类型的数量。对于内置类型，有一些绕过此机制的优化，但是数据类型抽象的要点是允许添加新的数据类型。</target>
        </trans-unit>
        <trans-unit id="3bc7ca60ba414cbf4855ce7f1e99de3ef90f6929" translate="yes" xml:space="preserve">
          <source>The data-type is an important abstraction of the ndarray. Operations will look to the data-type to provide the key functionality that is needed to operate on the array. This functionality is provided in the list of function pointers pointed to by the &amp;lsquo;f&amp;rsquo; member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure. In this way, the number of data-types can be extended simply by providing a &lt;a href=&quot;c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure with suitable function pointers in the &amp;lsquo;f&amp;rsquo; member. For built-in types there are some optimizations that by-pass this mechanism, but the point of the data- type abstraction is to allow new data-types to be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b58fbdafeaa8107e58c408c096a3cb8ca5d659d7" translate="yes" xml:space="preserve">
          <source>The data-type of the returned array.</source>
          <target state="translated">返回数组的数据类型。</target>
        </trans-unit>
        <trans-unit id="5c8d679fa5d2836b35d4e189ea3c3c42c4a9bfcc" translate="yes" xml:space="preserve">
          <source>The data-type used to interpret the file contents. Default is &lt;code&gt;uint8&lt;/code&gt;.</source>
          <target state="translated">用于解释文件内容的数据类型。默认值为 &lt;code&gt;uint8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1e17b816f5aa8d3b539033dd4f8579bd040ce7c" translate="yes" xml:space="preserve">
          <source>The data-type used to represent the intermediate results. Defaults to the data-type of the output array if such is provided, or the the data-type of the input array if no output array is provided.</source>
          <target state="translated">用于表示中间结果的数据类型。如果有输出数组,默认为输出数组的数据类型,如果没有输出数组,默认为输入数组的数据类型。</target>
        </trans-unit>
        <trans-unit id="932e882a29033e270334b0a0ca27c7a0b749d38c" translate="yes" xml:space="preserve">
          <source>The data-type-descriptor object of the base-type.</source>
          <target state="translated">基类型的数据类型描述符对象。</target>
        </trans-unit>
        <trans-unit id="d6987a7425e0ff97a8320c32ec6abc8ee62f4f4d" translate="yes" xml:space="preserve">
          <source>The datatype determines which of &amp;lsquo;mergesort&amp;rsquo; or &amp;lsquo;timsort&amp;rsquo; is actually used, even if &amp;lsquo;mergesort&amp;rsquo; is specified. User selection at a finer scale is not currently available.</source>
          <target state="translated">即使指定了&amp;ldquo; mergesort&amp;rdquo;，数据类型也会确定实际使用的是&amp;ldquo; mergesort&amp;rdquo;还是&amp;ldquo; timsort&amp;rdquo;。目前尚无法进行更精细的用户选择。</target>
        </trans-unit>
        <trans-unit id="f8494cadb009486b1d5ee5b6a13352cbf85e331c" translate="yes" xml:space="preserve">
          <source>The datetime API is &lt;em&gt;experimental&lt;/em&gt; in 1.7.0, and may undergo changes in future versions of NumPy.</source>
          <target state="translated">datetime API 在1.7.0中处于&lt;em&gt;试验阶段&lt;/em&gt;，在以后的NumPy版本中可能会发生更改。</target>
        </trans-unit>
        <trans-unit id="5a29e38fde2fbef6d304ea68f9f28e90e826577d" translate="yes" xml:space="preserve">
          <source>The datetime object represents a single moment in time. If two datetimes have different units, they may still be representing the same moment of time, and converting from a bigger unit like months to a smaller unit like days is considered a &amp;lsquo;safe&amp;rsquo; cast because the moment of time is still being represented exactly.</source>
          <target state="translated">datetime对象表示单个时刻。如果两个日期时间具有不同的单位，则它们可能仍代表相同的时间，从较大的单位（如月份）转换为较小的单位（如日期）被认为是&amp;ldquo;安全&amp;rdquo;转换，因为时间段仍可以精确表示。</target>
        </trans-unit>
        <trans-unit id="96194d206533dca35ec887829a70fc8982e7d450" translate="yes" xml:space="preserve">
          <source>The datetime string parser in NumPy 1.6 is very liberal in what it accepts, and silently allows invalid input without raising errors. The parser in NumPy 1.7 is quite strict about only accepting ISO 8601 dates, with a few convenience extensions. 1.6 always creates microsecond (us) units by default, whereas 1.7 detects a unit based on the format of the string. Here is a comparison.:</source>
          <target state="translated">NumPy 1.6中的日期时间字符串解析器在接受的内容上非常自由,它允许无效的输入而不引起错误。NumPy 1.7中的解析器非常严格,只接受ISO 8601日期,并做了一些方便的扩展。1.6总是默认创建微秒(us)单位,而1.7则根据字符串的格式检测单位。下面是一个比较..:</target>
        </trans-unit>
        <trans-unit id="1369383d5a514fcfed8df04d6ed924de54d6f3b1" translate="yes" xml:space="preserve">
          <source>The datetime type works with many common NumPy functions, for example &lt;a href=&quot;generated/numpy.arange#numpy.arange&quot;&gt;&lt;code&gt;arange&lt;/code&gt;&lt;/a&gt; can be used to generate ranges of dates.</source>
          <target state="translated">datetime类型可与许多常见的NumPy函数一起使用，例如&lt;a href=&quot;generated/numpy.arange#numpy.arange&quot;&gt; &lt;code&gt;arange&lt;/code&gt; &lt;/a&gt;可用于生成日期范围。</target>
        </trans-unit>
        <trans-unit id="60d7f83834880a987611358eebe758ac593dc7d2" translate="yes" xml:space="preserve">
          <source>The decomposition is performed using LAPACK routine &lt;code&gt;_gesdd&lt;/code&gt;.</source>
          <target state="translated">使用LAPACK例程 &lt;code&gt;_gesdd&lt;/code&gt; 执行分解。</target>
        </trans-unit>
        <trans-unit id="e1516fc7b62e4a0344208958aa595053689db869" translate="yes" xml:space="preserve">
          <source>The decorated test &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">装饰性测试 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9657b7f30a96eb6a9709525e36cff8e84658cbb" translate="yes" xml:space="preserve">
          <source>The decorator itself is decorated with the &lt;code&gt;nose.tools.make_decorator&lt;/code&gt; function in order to transmit function name, and various other metadata.</source>
          <target state="translated">装饰器本身使用 &lt;code&gt;nose.tools.make_decorator&lt;/code&gt; 函数进行装饰，以传输函数名称以及其他各种元数据。</target>
        </trans-unit>
        <trans-unit id="4a37da8a9aa52a4088272dd54ccf6dae2a209ad8" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;atol&lt;/code&gt; is not appropriate for comparing numbers that are much smaller than one (see Notes).</source>
          <target state="translated">默认的 &lt;code&gt;atol&lt;/code&gt; 不适用于比较比1小得多的数字（请参见注释）。</target>
        </trans-unit>
        <trans-unit id="cb5293865f62263e0a19bbfa34c77f6486814f1d" translate="yes" xml:space="preserve">
          <source>The default __array_priority__ of matrix objects is 10.0, and therefore mixed operations with ndarrays always produce matrices.</source>
          <target state="translated">矩阵对象的默认__array_priority__是10.0,因此与ndarrays的混合操作总是产生矩阵。</target>
        </trans-unit>
        <trans-unit id="cd69cae26ca025156d4d72a557a24e650bb3e040" translate="yes" xml:space="preserve">
          <source>The default character, this is returned if none of the characters in &lt;code&gt;typechars&lt;/code&gt; matches a character in &lt;code&gt;typeset&lt;/code&gt;.</source>
          <target state="translated">默认的字符，如果没有在此字符返回 &lt;code&gt;typechars&lt;/code&gt; 在字符匹配 &lt;code&gt;typeset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9f67bac25f1e9fa1addb151018aeaf9def3b945" translate="yes" xml:space="preserve">
          <source>The default data type in NumPy is &lt;code&gt;float_&lt;/code&gt;.</source>
          <target state="translated">NumPy中的默认数据类型为 &lt;code&gt;float_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cb916c2a199dec22e3c7d35ff5ca943ade2af02" translate="yes" xml:space="preserve">
          <source>The default data type: &lt;code&gt;float_&lt;/code&gt;.</source>
          <target state="translated">默认数据类型： &lt;code&gt;float_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="585140e706eb572d257d276596c7c62733d99ac8" translate="yes" xml:space="preserve">
          <source>The default fill value.</source>
          <target state="translated">默认的填充值。</target>
        </trans-unit>
        <trans-unit id="a6dbb84bde95674721b5026ade7be2a1d41460db" translate="yes" xml:space="preserve">
          <source>The default filling value depends on the datatype of the input array or the type of the input scalar:</source>
          <target state="translated">默认的填充值取决于输入数组的数据类型或输入标量的类型。</target>
        </trans-unit>
        <trans-unit id="d172f7f7da97c607ca46d821dc996e8763c04a60" translate="yes" xml:space="preserve">
          <source>The default for busday functions is that the only valid days are Monday through Friday (the usual business days). The implementation is based on a &amp;ldquo;weekmask&amp;rdquo; containing 7 Boolean flags to indicate valid days; custom weekmasks are possible that specify other sets of valid days.</source>
          <target state="translated">busday功能的默认设置是唯一有效的日期是星期一至星期五（通常的工作日）。该实现基于包含7个布尔值标志的&amp;ldquo;周掩码&amp;rdquo;，以指示有效日期；可以使用自定义周掩码来指定其他有效日期集。</target>
        </trans-unit>
        <trans-unit id="b9e6f3b39a9841c2072fe28c903a4873d59b58cf" translate="yes" xml:space="preserve">
          <source>The default for most operations, raises an exception if an index is out of bounds.</source>
          <target state="translated">大多数操作的默认值,如果索引出界会引发异常。</target>
        </trans-unit>
        <trans-unit id="f01d70d1a58c31eb28ef483c3e412b7730114894" translate="yes" xml:space="preserve">
          <source>The default interface is a very literal translation of the fortran code into Python. The Fortran array arguments must now be NumPy arrays and the integer argument should be an integer. The interface will attempt to convert all arguments to their required types (and shapes) and issue an error if unsuccessful. However, because it knows nothing about the semantics of the arguments (such that C is an output and n should really match the array sizes), it is possible to abuse this function in ways that can cause Python to crash. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b3aadfe669f7dc7282a8bf3bc7021b967d5f363" translate="yes" xml:space="preserve">
          <source>The default is not to change the current behavior.</source>
          <target state="translated">默认情况是不改变当前行为。</target>
        </trans-unit>
        <trans-unit id="35460c572d36a32620dc9fa812780440e2fcffff" translate="yes" xml:space="preserve">
          <source>The default is to &lt;code&gt;'warn'&lt;/code&gt; for &lt;code&gt;invalid&lt;/code&gt;, &lt;code&gt;divide&lt;/code&gt;, and &lt;code&gt;overflow&lt;/code&gt; and &lt;code&gt;'ignore'&lt;/code&gt; for &lt;code&gt;underflow&lt;/code&gt;. But this can be changed, and it can be set individually for different kinds of exceptions. The different behaviors are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13f5430198109332da2b945e817fa963554a0039" translate="yes" xml:space="preserve">
          <source>The default iterator of an ndarray object is the default Python iterator of a sequence type. Thus, when the array object itself is used as an iterator. The default behavior is equivalent to:</source>
          <target state="translated">ndarray对象的默认迭代器是一个序列类型的默认Python迭代器。因此,当数组对象本身被用作迭代器时。默认行为等同于。</target>
        </trans-unit>
        <trans-unit id="aac361851a1a42c7bb314d3f5e868ac753b52020" translate="yes" xml:space="preserve">
          <source>The default method is &amp;ldquo;marginals&amp;rdquo;. For some cases (e.g. when &lt;code&gt;colors&lt;/code&gt; contains relatively small integers), the &amp;ldquo;count&amp;rdquo; method can be significantly faster than the &amp;ldquo;marginals&amp;rdquo; method. If performance of the algorithm is important, test the two methods with typical inputs to decide which works best.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a1e3c85492f9a28cfa2d6a52018d6303212281" translate="yes" xml:space="preserve">
          <source>The default normalization has the direct transforms unscaled and the inverse transforms are scaled by</source>
          <target state="translated">默认的归一化使直接变换不按比例放大,反变换按以下比例放大</target>
        </trans-unit>
        <trans-unit id="294bd9e52acfdc133dee5d5ce445aefb23018ef1" translate="yes" xml:space="preserve">
          <source>The default order for the libraries are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79f5666dde2a74098ca71f007435f35059e5b3e" translate="yes" xml:space="preserve">
          <source>The default threshold to detect rank deficiency is a test on the magnitude of the singular values of &lt;code&gt;M&lt;/code&gt;. By default, we identify singular values less than &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; as indicating rank deficiency (with the symbols defined above). This is the algorithm MATLAB uses [1]. It also appears in &lt;em&gt;Numerical recipes&lt;/em&gt; in the discussion of SVD solutions for linear least squares [2].</source>
          <target state="translated">检测秩不足的默认阈值是对 &lt;code&gt;M&lt;/code&gt; 的奇异值的大小的测试。默认情况下，我们将小于 &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; 奇异值标识为秩不足（使用上面定义的符号）。这是MATLAB使用的算法[1]。在有关线性最小二乘的SVD解决方案的讨论中，它也出现在&lt;em&gt;数值配方&lt;/em&gt;中[2]。</target>
        </trans-unit>
        <trans-unit id="fabcee56c3086c9123fae22826809a0d986ec9e3" translate="yes" xml:space="preserve">
          <source>The default type to use when no dtype is explicitly specified, for example when calling np.zero(shape). This is equivalent to &lt;a href=&quot;#c.NPY_DOUBLE&quot;&gt;&lt;code&gt;NPY_DOUBLE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当未显式指定dtype时（例如，在调用np.zero（shape）时）使用的默认类型。这等效于&lt;a href=&quot;#c.NPY_DOUBLE&quot;&gt; &lt;code&gt;NPY_DOUBLE&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a62d7fdf404d547735e1b655e9c601557613abc2" translate="yes" xml:space="preserve">
          <source>The default valid days are Monday through Friday (&amp;ldquo;business days&amp;rdquo;). A busdaycalendar object can be specified with any set of weekly valid days, plus an optional &amp;ldquo;holiday&amp;rdquo; dates that always will be invalid.</source>
          <target state="translated">默认的有效日期为星期一至星期五（&amp;ldquo;工作日&amp;rdquo;）。可以使用任何一组每周有效日期以及一个可选的&amp;ldquo;假日&amp;rdquo;日期来指定一个busdaycalendar对象，该日期总是无效的。</target>
        </trans-unit>
        <trans-unit id="203757e2bdf5bbe5e651d506c476783cf6e50edd" translate="yes" xml:space="preserve">
          <source>The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for the alternatives above. For example, any of &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;biggish&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">默认值（'S'）导致交换当前字节顺序。对于上述替代方案，代码对 &lt;code&gt;new_order&lt;/code&gt; 的第一个字母进行不区分大小写的检查。例如，&amp;ldquo; B&amp;rdquo;或&amp;ldquo; b&amp;rdquo;或&amp;ldquo; biggish&amp;rdquo;中的任何一个都可以有效地指定big-endian。</target>
        </trans-unit>
        <trans-unit id="86906072113e4cc2809d8408fb9acbe0a4443ef7" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;names&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;. If we give any other value to the keyword, the new names will overwrite the field names we may have defined with the dtype:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a5ab6c7c39a905e845eb64d8df075515c15636" translate="yes" xml:space="preserve">
          <source>The defining property of the antiderivative:</source>
          <target state="translated">反衍生物的定义属性。</target>
        </trans-unit>
        <trans-unit id="7a4397ef8c9f537d85068ef5bbb9a575412a21fb" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;C&lt;/code&gt; is the same as before, but for &lt;code&gt;D&lt;/code&gt;, the &lt;code&gt;__new__&lt;/code&gt; method returns an instance of class &lt;code&gt;C&lt;/code&gt; rather than &lt;code&gt;D&lt;/code&gt;. Note that the &lt;code&gt;__init__&lt;/code&gt; method of &lt;code&gt;D&lt;/code&gt; does not get called. In general, when the &lt;code&gt;__new__&lt;/code&gt; method returns an object of class other than the class in which it is defined, the &lt;code&gt;__init__&lt;/code&gt; method of that class is not called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1b5640a64fc73d8755c0223b335feaa121479d8" translate="yes" xml:space="preserve">
          <source>The definition of advanced indexing means that &lt;code&gt;x[(1,2,3),]&lt;/code&gt; is fundamentally different than &lt;code&gt;x[(1,2,3)]&lt;/code&gt;. The latter is equivalent to &lt;code&gt;x[1,2,3]&lt;/code&gt; which will trigger basic selection while the former will trigger advanced indexing. Be sure to understand why this occurs.</source>
          <target state="translated">高级索引的定义意味着 &lt;code&gt;x[(1,2,3),]&lt;/code&gt; 与 &lt;code&gt;x[(1,2,3)]&lt;/code&gt; 根本不同。后者等效于 &lt;code&gt;x[1,2,3]&lt;/code&gt; ，它将触发基本选择，而前者将触发高级索引。确保了解为什么会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="61496dee2f3816bd693a7ce0398282c8ea47a960" translate="yes" xml:space="preserve">
          <source>The definition of correlation above is not unique and sometimes correlation may be defined differently. Another common definition is:</source>
          <target state="translated">以上关于相关性的定义并不是唯一的,有时候相关性的定义可能会有所不同。另一种常见的定义是:</target>
        </trans-unit>
        <trans-unit id="938e670c022b166026c1f3d97b60b6e6eed3f831" translate="yes" xml:space="preserve">
          <source>The definition of the &lt;code&gt;&amp;lt;argument/variable type declaration&amp;gt;&lt;/code&gt; part is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f4801e8c8f57fdee23b9a4f5485bae04f50607" translate="yes" xml:space="preserve">
          <source>The definition of the &lt;code&gt;&amp;lt;common block statement&amp;gt;&lt;/code&gt; part is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ed0cf6ae14e241898a603f2c9052eee0f3ff8c" translate="yes" xml:space="preserve">
          <source>The definition of the &lt;code&gt;&amp;lt;use statement&amp;gt;&lt;/code&gt; part is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f33fe407bab51cea8bacccfd88b8a5036810dc" translate="yes" xml:space="preserve">
          <source>The degree of the series.</source>
          <target state="translated">系列的程度。</target>
        </trans-unit>
        <trans-unit id="155faa0de8c44a325761ca30fe7a5e7dbf74e6e4" translate="yes" xml:space="preserve">
          <source>The depends list contains paths to files or directories that the sources of the extension module depend on. If any path in the depends list is newer than the extension module, then the module will be rebuilt.</source>
          <target state="translated">依赖列表中包含了扩展模块的源代码所依赖的文件或目录的路径。如果依赖列表中的任何路径比扩展模块更新,那么该模块将被重建。</target>
        </trans-unit>
        <trans-unit id="8add200746bc778285c2910a22d91b2b8b258c85" translate="yes" xml:space="preserve">
          <source>The deprecated function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63644093036e4f3b360649808afd2f026edeffe7" translate="yes" xml:space="preserve">
          <source>The derivation of the t-distribution was first published in 1908 by William Gosset while working for the Guinness Brewery in Dublin. Due to proprietary issues, he had to publish under a pseudonym, and so he used the name Student.</source>
          <target state="translated">1908年,威廉-戈塞特在都柏林的吉尼斯啤酒厂工作时,首次发表了t分布的推导。由于专利问题,他不得不用假名发表,所以他使用了学生这个名字。</target>
        </trans-unit>
        <trans-unit id="7db2e5319fb072c88d575bc92b04bca324abdb47" translate="yes" xml:space="preserve">
          <source>The derivative of the polynomial</source>
          <target state="translated">多项式的导数</target>
        </trans-unit>
        <trans-unit id="e38da7322eec5dfeb19db7a40e7e799054f3e9fa" translate="yes" xml:space="preserve">
          <source>The desc member of the PyCObject returned from __array_struct__ was not specified. Usually, it was the object exposing the array (so that a reference to it could be kept and destroyed when the C-object was destroyed). Now it must be a tuple whose first element is a string with &amp;ldquo;PyArrayInterface Version #&amp;rdquo; and whose second element is the object exposing the array.</source>
          <target state="translated">未指定从__array_struct__返回的PyCObject的desc成员。通常，它是暴露数组的对象（以便在销毁C对象时可以保留和销毁对它的引用）。现在，它必须是一个元组，其第一个元素是带有&amp;ldquo; PyArrayInterface Version＃&amp;rdquo;的字符串，第二个元素是暴露数组的对象。</target>
        </trans-unit>
        <trans-unit id="d7dbcb2541cf001d7b26e25e4170575fd900c8ee" translate="yes" xml:space="preserve">
          <source>The description of the fourth element of the header therefore has become: &amp;ldquo;The next 4 bytes form a little-endian unsigned int: the length of the header data HEADER_LEN.&amp;rdquo;</source>
          <target state="translated">标头的第四个元素的描述因此变为：&amp;ldquo;接下来的4个字节形成一个低位无符号int：标头数据HEADER_LEN的长度。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="877e58bc0c85ccf0ef190f149115500e0d385da1" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array The default, None, means</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a52cabb32fca3b74ad0388e9c1cbe1cf8d25b1" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array, e.g., &lt;code&gt;numpy.int8&lt;/code&gt;. Default is &lt;code&gt;numpy.float64&lt;/code&gt;.</source>
          <target state="translated">数组的所需数据类型，例如 &lt;code&gt;numpy.int8&lt;/code&gt; 。默认值为 &lt;code&gt;numpy.float64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0a8a7651b0b383e3707246aaf8cd38e2e169098" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array. If not given, then the type will be determined as the minimum type required to hold the objects in the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7534f7cefc524ae1e988328a3c98ad10f344592" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array. If not given, then the type will be determined as the minimum type required to hold the objects in the sequence. This argument can only be used to &amp;lsquo;upcast&amp;rsquo; the array. For downcasting, use the .astype(t) method.</source>
          <target state="translated">数组所需的数据类型。如果未给出，则将类型确定为在序列中保存对象所需的最小类型。此参数只能用于&amp;ldquo;上载&amp;rdquo;阵列。对于向下转换，请使用.astype（t）方法。</target>
        </trans-unit>
        <trans-unit id="50dd3f94578e7376ef4b1fc5b09b342ebb1fed2e" translate="yes" xml:space="preserve">
          <source>The desired data-type for the matrix, default is float.</source>
          <target state="translated">矩阵的数据类型,默认为float。</target>
        </trans-unit>
        <trans-unit id="07d678da86d17478a0143d6947f08f3fa51a5f65" translate="yes" xml:space="preserve">
          <source>The desired data-type for the matrix, default is np.float64.</source>
          <target state="translated">矩阵的数据类型,默认为np.float64。</target>
        </trans-unit>
        <trans-unit id="d07509f4b4964e751a91c8805000083d2ee4926c" translate="yes" xml:space="preserve">
          <source>The desired data-type. By default, the data-type is determined from &lt;code&gt;formats&lt;/code&gt;, &lt;code&gt;names&lt;/code&gt;, &lt;code&gt;titles&lt;/code&gt;, &lt;code&gt;aligned&lt;/code&gt; and &lt;code&gt;byteorder&lt;/code&gt;.</source>
          <target state="translated">所需的数据类型。默认情况下，数据类型由 &lt;code&gt;formats&lt;/code&gt; ， &lt;code&gt;names&lt;/code&gt; ， &lt;code&gt;titles&lt;/code&gt; ， &lt;code&gt;aligned&lt;/code&gt; 和 &lt;code&gt;byteorder&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c998f357ef80cf65beb1c4220aff1c69081dd53" translate="yes" xml:space="preserve">
          <source>The desired shape of the array. If &lt;code&gt;mode == 'r'&lt;/code&gt; and the number of remaining bytes after &lt;code&gt;offset&lt;/code&gt; is not a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, you must specify &lt;a href=&quot;numpy.memmap.shape#numpy.memmap.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. By default, the returned array will be 1-D with the number of elements determined by file size and data-type.</source>
          <target state="translated">所需的阵列形状。如果 &lt;code&gt;mode == 'r'&lt;/code&gt; 和剩余字节后面的数字 &lt;code&gt;offset&lt;/code&gt; 不是字节大小的倍数&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt;，你必须指定&lt;a href=&quot;numpy.memmap.shape#numpy.memmap.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt;。默认情况下，返回的数组将为一维，其元素数由文件大小和数据类型确定。</target>
        </trans-unit>
        <trans-unit id="c217d27d3179585b289f1730298cd76c28917559" translate="yes" xml:space="preserve">
          <source>The desired shape of the array. If &lt;code&gt;mode == 'r'&lt;/code&gt; and the number of remaining bytes after &lt;code&gt;offset&lt;/code&gt; is not a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, you must specify &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. By default, the returned array will be 1-D with the number of elements determined by file size and data-type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd86af715375b55e1d483d875bf1753af5d922f" translate="yes" xml:space="preserve">
          <source>The desired shape of the iterator. This allows &lt;code&gt;allocate&lt;/code&gt; operands with a dimension mapped by op_axes not corresponding to a dimension of a different operand to get a value not equal to 1 for that dimension.</source>
          <target state="translated">所需的迭代器形状。这允许 &lt;code&gt;allocate&lt;/code&gt; 操作数具有与op_axes映射的维度不对应于另一个操作数的维度的操作数，以获取该维度的不等于1的值。</target>
        </trans-unit>
        <trans-unit id="84971317bba10bc74f9aaf650dccf1acca028d13" translate="yes" xml:space="preserve">
          <source>The desired, expected object.</source>
          <target state="translated">所需的、预期的对象。</target>
        </trans-unit>
        <trans-unit id="40c65673e654df212bffc77b7c4cf508b802ea94" translate="yes" xml:space="preserve">
          <source>The determinant is computed via LU factorization using the LAPACK routine &lt;code&gt;z/dgetrf&lt;/code&gt;.</source>
          <target state="translated">行列式使用LAPACK例程 &lt;code&gt;z/dgetrf&lt;/code&gt; 通过LU分解进行计算。</target>
        </trans-unit>
        <trans-unit id="94f9591a378d3f5d467509648f89e89bcee5af83" translate="yes" xml:space="preserve">
          <source>The determinant of a 2-D array &lt;code&gt;[[a, b], [c, d]]&lt;/code&gt; is &lt;code&gt;ad - bc&lt;/code&gt;:</source>
          <target state="translated">二维数组 &lt;code&gt;[[a, b], [c, d]]&lt;/code&gt; 的行列式为 &lt;code&gt;ad - bc&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="67af8ebad34e1dbafff04ba3dd64dccd7934523b" translate="yes" xml:space="preserve">
          <source>The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:</source>
          <target state="translated">二维数组[[a,b],[c,d]]的行列式为ad-bc。</target>
        </trans-unit>
        <trans-unit id="e56bde2e38a2da31d0e2d0f24b802753579a52ca" translate="yes" xml:space="preserve">
          <source>The determinant of a square Vandermonde matrix is the product of the differences between the values of the input vector:</source>
          <target state="translated">方范德蒙德矩阵的行列式是输入向量值之间的差值的乘积。</target>
        </trans-unit>
        <trans-unit id="60279460274321ba74cf96556a38bac9a87c73c6" translate="yes" xml:space="preserve">
          <source>The diagonal and diag functions return readonly views.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c13c034ad3086185d61530fb01b7940b4e4527" translate="yes" xml:space="preserve">
          <source>The dictionary contains three keys:</source>
          <target state="translated">该字典包含三个键。</target>
        </trans-unit>
        <trans-unit id="7980c83ed9b10778dab7b594015b0c4b8c1b820c" translate="yes" xml:space="preserve">
          <source>The dictionary has two required keys, &amp;lsquo;names&amp;rsquo; and &amp;lsquo;formats&amp;rsquo;, and four optional keys, &amp;lsquo;offsets&amp;rsquo;, &amp;lsquo;itemsize&amp;rsquo;, &amp;lsquo;aligned&amp;rsquo; and &amp;lsquo;titles&amp;rsquo;. The values for &amp;lsquo;names&amp;rsquo; and &amp;lsquo;formats&amp;rsquo; should respectively be a list of field names and a list of dtype specifications, of the same length. The optional &amp;lsquo;offsets&amp;rsquo; value should be a list of integer byte-offsets, one for each field within the structure. If &amp;lsquo;offsets&amp;rsquo; is not given the offsets are determined automatically. The optional &amp;lsquo;itemsize&amp;rsquo; value should be an integer describing the total size in bytes of the dtype, which must be large enough to contain all the fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd944e951e9799c3343f288ae6c347a06ac11e23" translate="yes" xml:space="preserve">
          <source>The dictionary is indexed by keys that are the names of the fields. Each entry in the dictionary is a tuple fully describing the field:</source>
          <target state="translated">该字典以字段名称的键为索引。字典中的每个条目都是一个元组,全面描述了该字段。</target>
        </trans-unit>
        <trans-unit id="fc72cbc84ea7846d80156db81f03031e6342d2d0" translate="yes" xml:space="preserve">
          <source>The dictionary with build information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88918f47eb3cf48e5a0737e099c91aa35bc38894" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the next smallest representable float larger than 1.0. For example, for 64-bit binary floats in the IEEE-754 standard, &lt;code&gt;eps = 2**-52&lt;/code&gt;, approximately 2.22e-16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d6f22ac980a152a56489087bf48f813ef3afe4" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the next smallest representable float less than 1.0. For example, for 64-bit binary floats in the IEEE-754 standard, &lt;code&gt;epsneg = 2**-53&lt;/code&gt;, approximately 1.11e-16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162f606f6e0310c46fbb8198beb3cd00b92c6224" translate="yes" xml:space="preserve">
          <source>The difference of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 之差，按元素进行。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="07942ea7f660d79ad7e6e73de1169306977fb28a" translate="yes" xml:space="preserve">
          <source>The differences between consecutive elements of an array.</source>
          <target state="translated">数组中连续元素之间的差异。</target>
        </trans-unit>
        <trans-unit id="f62761da3d9dc37e999ceb43677343bc26056903" translate="yes" xml:space="preserve">
          <source>The differences. Loosely, this is &lt;code&gt;ary.flat[1:] - ary.flat[:-1]&lt;/code&gt;.</source>
          <target state="translated">差异。 &lt;code&gt;ary.flat[1:] - ary.flat[:-1]&lt;/code&gt; 地，这是ary.flat [1：]-ary.flat [：-1]。</target>
        </trans-unit>
        <trans-unit id="e2f3cc77955898f687e1a89336e253a34038e978" translate="yes" xml:space="preserve">
          <source>The different types of interpolation can be visualized graphically:</source>
          <target state="translated">不同类型的插值可以用图形可视化。</target>
        </trans-unit>
        <trans-unit id="0f5b79f9447070c03232c2c0b7664e2645b9b9cd" translate="yes" xml:space="preserve">
          <source>The dimension over which bit-packing is done. &lt;code&gt;None&lt;/code&gt; implies packing the flattened array.</source>
          <target state="translated">完成位打包的尺寸。 &lt;code&gt;None&lt;/code&gt; 表示打包扁平化数组。</target>
        </trans-unit>
        <trans-unit id="dfa565d5af13bd83cac275f338d5f2b3b4b7544c" translate="yes" xml:space="preserve">
          <source>The dimension over which bit-unpacking is done. &lt;code&gt;None&lt;/code&gt; implies unpacking the flattened array.</source>
          <target state="translated">展开位的尺寸。 &lt;code&gt;None&lt;/code&gt; 表示解压缩展平的数组。</target>
        </trans-unit>
        <trans-unit id="db3013243a57c5e7a96cffb61f2f631ca09ac6ac" translate="yes" xml:space="preserve">
          <source>The dimensionality of each input/output of an elementary function is defined by its core dimensions (zero core dimensions correspond to a scalar input/output). The core dimensions are mapped to the last dimensions of the input/output arrays.</source>
          <target state="translated">一个基本函数的每个输入/输出的维度由它的核心维度定义(核心维度为零对应一个标量输入/输出)。核心维度被映射到输入/输出数组的最后维度。</target>
        </trans-unit>
        <trans-unit id="bbd2ce0767215831bee7913f7b1f8113fac9632a" translate="yes" xml:space="preserve">
          <source>The dimensionality of the output is equal to the greatest of: * the dimensionality of all the inputs * the depth to which the input list is nested</source>
          <target state="translated">输出的维度等于以下两项中的最大一项。*所有输入的维度*输入列表的嵌套深度。</target>
        </trans-unit>
        <trans-unit id="169b189aee12891e66fa6116bc6ee28490426b80" translate="yes" xml:space="preserve">
          <source>The dimensions beyond the core dimensions are called &amp;ldquo;loop&amp;rdquo; dimensions. In the above example, this corresponds to &lt;code&gt;(3, 5)&lt;/code&gt;.</source>
          <target state="translated">超出核心尺寸的尺寸称为&amp;ldquo;环形&amp;rdquo;尺寸。在上面的示例中，这对应于 &lt;code&gt;(3, 5)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f513b3b85fff0b6f84da786029bafd05ba0e618b" translate="yes" xml:space="preserve">
          <source>The dimensions of the iterator.</source>
          <target state="translated">迭代器的尺寸。</target>
        </trans-unit>
        <trans-unit id="5ecf20054a40c0975aa34c7a074c143c2ad5eb76" translate="yes" xml:space="preserve">
          <source>The dimensions of the returned array, must be non-negative. If no argument is given a single Python float is returned.</source>
          <target state="translated">返回数组的维数,必须是非负数。如果没有给出参数,则返回一个Python float。</target>
        </trans-unit>
        <trans-unit id="1962b62fe3553b6c10eaad6d82d38bd0027b1eca" translate="yes" xml:space="preserve">
          <source>The direction where to look for the next representable value of &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">查找 &lt;code&gt;x1&lt;/code&gt; 的下一个可表示值的方向。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="712dcab95da2336dfeef7d45bac02b258dccf977" translate="yes" xml:space="preserve">
          <source>The discount rate.</source>
          <target state="translated">贴现率;</target>
        </trans-unit>
        <trans-unit id="0706686baa5fd5b913d978e6a5e5bd325098b037" translate="yes" xml:space="preserve">
          <source>The discrete convolution operation is defined as</source>
          <target state="translated">离散卷积运算定义为</target>
        </trans-unit>
        <trans-unit id="0c3ebfde94166d29a8529279eac1b981ebfd74c7" translate="yes" xml:space="preserve">
          <source>The distance between a value and the nearest adjacent number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9069c190fd0543a41e23dc5a8c21be130414b2" translate="yes" xml:space="preserve">
          <source>The docstring consists of a number of sections separated by headings (except for the deprecation warning). Each heading should be underlined in hyphens, and the section ordering should be consistent with the description below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a1ae320e29367bfe14ad50414fe949007c38e7" translate="yes" xml:space="preserve">
          <source>The docstring for the function. If &lt;code&gt;None&lt;/code&gt;, the docstring will be the &lt;code&gt;pyfunc.__doc__&lt;/code&gt;.</source>
          <target state="translated">该函数的文档字符串。如果为 &lt;code&gt;None&lt;/code&gt; ，则文档字符串将为 &lt;code&gt;pyfunc.__doc__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f20cb6df02e7c9d27955f240a3eb4c2a8d28a69" translate="yes" xml:space="preserve">
          <source>The docstring for the function. If None, the docstring will be the &lt;code&gt;pyfunc.__doc__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a23a7f9d3c84d9ccb7d9d4e76905cf07195965" translate="yes" xml:space="preserve">
          <source>The docstring is taken from the input function to &lt;a href=&quot;#numpy.vectorize&quot;&gt;&lt;code&gt;vectorize&lt;/code&gt;&lt;/a&gt; unless it is specified:</source>
          <target state="translated">除非已指定，否则从输入函数获取文档字符串以进行&lt;a href=&quot;#numpy.vectorize&quot;&gt; &lt;code&gt;vectorize&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="82bd10e4e262158659ec5e27575297c3e33fb51b" translate="yes" xml:space="preserve">
          <source>The doctests are run as if they are in a fresh Python instance which has executed &lt;code&gt;import numpy as np&lt;/code&gt;. Tests that are part of a SciPy subpackage will have that subpackage already imported. E.g. for a test in &lt;code&gt;scipy/linalg/tests/&lt;/code&gt;, the namespace will be created such that &lt;code&gt;from scipy import linalg&lt;/code&gt; has already executed.</source>
          <target state="translated">像运行doctest一样，就像在新的Python实例中一样，该实例已执行 &lt;code&gt;import numpy as np&lt;/code&gt; 。作为SciPy子程序包一部分的测试将具有已导入的子程序包。例如，对于 &lt;code&gt;scipy/linalg/tests/&lt;/code&gt; 中的测试，将创建名称空间， &lt;code&gt;from scipy import linalg&lt;/code&gt; 已经从scipy导入linalg。</target>
        </trans-unit>
        <trans-unit id="4e34de0083248d68455464ce3b6cb6cff4a615e4" translate="yes" xml:space="preserve">
          <source>The doctests can be run by adding the &lt;code&gt;doctests&lt;/code&gt; argument to the &lt;code&gt;test()&lt;/code&gt; call; for example, to run all tests (including doctests) for numpy.lib:</source>
          <target state="translated">可以通过将 &lt;code&gt;doctests&lt;/code&gt; 参数添加到 &lt;code&gt;test()&lt;/code&gt; 调用来运行doctest。例如，运行numpy.lib的所有测试（包括doctests）：</target>
        </trans-unit>
        <trans-unit id="914dd900bd888e0ac2a856c709956c6c77b685df" translate="yes" xml:space="preserve">
          <source>The doctests can be run by the user/developer by adding the &lt;code&gt;doctests&lt;/code&gt; argument to the &lt;code&gt;test()&lt;/code&gt; call. For example, to run all tests (including doctests) for &lt;code&gt;numpy.lib&lt;/code&gt;:</source>
          <target state="translated">通过将 &lt;code&gt;doctests&lt;/code&gt; 参数添加到 &lt;code&gt;test()&lt;/code&gt; 调用，用户/开发人员可以运行doctest。例如，运行所有测试（包括文档测试）为 &lt;code&gt;numpy.lib&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f8aa7b1eda9c3eb10663105fc5334308467be1f5" translate="yes" xml:space="preserve">
          <source>The documentation for NumPy distributed at &lt;a href=&quot;https://numpy.org/doc&quot;&gt;https://numpy.org/doc&lt;/a&gt; in html and pdf format is also built with &lt;code&gt;make dist&lt;/code&gt;. See &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/HOWTO_RELEASE.rst.txt&quot;&gt;HOWTO RELEASE&lt;/a&gt; for details on how to update &lt;a href=&quot;https://numpy.org/doc&quot;&gt;https://numpy.org/doc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b422de92d847bc36480d44f7ae27cfbb5060f6f" translate="yes" xml:space="preserve">
          <source>The documentation includes mathematical formulae with LaTeX formatting. A working LaTeX document production system (e.g. &lt;a href=&quot;https://www.tug.org/texlive/&quot;&gt;texlive&lt;/a&gt;) is required for the proper rendering of the LaTeX math in the documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="400ca1ed6dc999bcaec7408745f9b97e9991d699" translate="yes" xml:space="preserve">
          <source>The documentation is written in restructuredText, which is the format required by Sphinx, the tool most Python projects use to automatically build and link the documentation within the project. You can read the &lt;a href=&quot;https://docutils.sourceforge.io/docs/user/rst/quickref.html&quot;&gt;Quick reStructuredText Guide&lt;/a&gt; or the &lt;a href=&quot;http://www.sphinx-doc.org/en/stable/usage/restructuredtext/basics.html&quot;&gt;reStructuredText Primer&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01857d163ce7be746891e6a1ddb4df8d280228b" translate="yes" xml:space="preserve">
          <source>The domain of the converted series. If the value is None, the default domain of &lt;code&gt;kind&lt;/code&gt; is used.</source>
          <target state="translated">转换后的系列的域。如果值为&amp;ldquo;无&amp;rdquo;，则使用默认的 &lt;code&gt;kind&lt;/code&gt; 域。</target>
        </trans-unit>
        <trans-unit id="3910d27792e65700eaf0cb459a12293f622c5605" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape (size, alpha.ndim).</source>
          <target state="translated">绘制的样本,形状(大小,alpha.ndim)。</target>
        </trans-unit>
        <trans-unit id="3a196841b4dbf99e3d83d366571811ca5768d106" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape &lt;code&gt;(size, k)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caba47af25cacb65ea654dc8b3910b7df6c6afc4" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape &lt;em&gt;size&lt;/em&gt;, if that was provided. If not, the shape is &lt;code&gt;(N,)&lt;/code&gt;.</source>
          <target state="translated">如果提供的话，抽取的样品的形状为&lt;em&gt;大小&lt;/em&gt;。如果不是，则形状为 &lt;code&gt;(N,)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40b0e929b6fe8b38b46b38ce838182fe7c7332dc" translate="yes" xml:space="preserve">
          <source>The drawn samples.</source>
          <target state="translated">抽到的样品。</target>
        </trans-unit>
        <trans-unit id="7c49825e402bb2a6069cc023cee23e3ad1ab0d7c" translate="yes" xml:space="preserve">
          <source>The dtype object also has a dictionary-like attribute, &lt;code&gt;fields&lt;/code&gt;, whose keys are the field names (and &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt;, see below) and whose values are tuples containing the dtype and byte offset of each field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa44e17b8461776ae7df4f43d6abddd8f6a24f76" translate="yes" xml:space="preserve">
          <source>The dtype object, which must be a &lt;code&gt;datetime64&lt;/code&gt; or &lt;code&gt;timedelta64&lt;/code&gt; type.</source>
          <target state="translated">dtype对象，必须是 &lt;code&gt;datetime64&lt;/code&gt; 或 &lt;code&gt;timedelta64&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="8fb6faafe66ffccb238a2fd43e44c5a7f5fbd5ca" translate="yes" xml:space="preserve">
          <source>The dtype of the masked array matches the dtype of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">掩码数组的dtype与 &lt;code&gt;arr&lt;/code&gt; 的dtype相匹配。</target>
        </trans-unit>
        <trans-unit id="1cb33880062e286521366b55fc98dd4daef4b644" translate="yes" xml:space="preserve">
          <source>The dtype of the output unstructured array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a55d71e165e1e48cb124a8472e43c4880e17aca7" translate="yes" xml:space="preserve">
          <source>The dtype to convert</source>
          <target state="translated">要转换的dtype</target>
        </trans-unit>
        <trans-unit id="5ecd0c1cb739e638a2efc7fc65026ccc752fcf9a" translate="yes" xml:space="preserve">
          <source>The dtype to convert.</source>
          <target state="translated">要转换的dtype。</target>
        </trans-unit>
        <trans-unit id="0d0946ed17f6fb426bc55c84df183c8474945340" translate="yes" xml:space="preserve">
          <source>The dummy argument is not used in this context and can be safely ignored. The &lt;em&gt;args&lt;/em&gt; argument contains all of the arguments passed in to the function as a tuple. You can do anything you want at this point, but usually the easiest way to manage the input arguments is to call &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; (args, format_string, addresses_to_C_variables&amp;hellip;) or &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_UnpackTuple&quot;&gt;&lt;code&gt;PyArg_UnpackTuple&lt;/code&gt;&lt;/a&gt; (tuple, &amp;ldquo;name&amp;rdquo;, min, max, &amp;hellip;). A good description of how to use the first function is contained in the Python C-API reference manual under section 5.5 (Parsing arguments and building values). You should pay particular attention to the &amp;ldquo;O&amp;amp;&amp;rdquo; format which uses converter functions to go between the Python object and the C object. All of the other format functions can be (mostly) thought of as special cases of this general rule. There are several converter functions defined in the NumPy C-API that may be of use. In particular, the &lt;a href=&quot;../reference/c-api/array#c.PyArray_DescrConverter&quot;&gt;&lt;code&gt;PyArray_DescrConverter&lt;/code&gt;&lt;/a&gt; function is very useful to support arbitrary data-type specification. This function transforms any valid data-type Python object into a &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; object. Remember to pass in the address of the C-variables that should be filled in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd01c48a9de1d18adee046a1ef49445b20e2304" translate="yes" xml:space="preserve">
          <source>The ease of implementing mathematical formulas that work on arrays is one of the things that make NumPy so widely used in the scientific Python community.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0624587fa2f7d6454c0f9d5829dab19d01e4bd1b" translate="yes" xml:space="preserve">
          <source>The easiest way to understand the situation may be to think in terms of the result shape. There are two parts to the indexing operation, the subspace defined by the basic indexing (excluding integers) and the subspace from the advanced indexing part. Two cases of index combination need to be distinguished:</source>
          <target state="translated">最简单的理解方式可能是从结果形状来考虑。索引操作有两个部分,一个是基本索引定义的子空间(不包括整数),一个是来自高级索引部分的子空间。需要区分索引组合的两种情况。</target>
        </trans-unit>
        <trans-unit id="f92b730683a3cb47168faa379ee22ac3235eed0f" translate="yes" xml:space="preserve">
          <source>The easy way to do conversions between polynomial basis sets is to use the convert method of a class instance.</source>
          <target state="translated">在多项式基集之间进行转换的简单方法是使用类实例的转换方法。</target>
        </trans-unit>
        <trans-unit id="7ad876c221bb9757cd689d05f17e08510f826f3e" translate="yes" xml:space="preserve">
          <source>The edges retuned by &lt;code&gt;histogram`&lt;/code&gt; and &lt;code&gt;histogramdd&lt;/code&gt; now match the data float type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc5d8b78173f52a2c49af3f59f052a25e59fb4f" translate="yes" xml:space="preserve">
          <source>The edges to pass into &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt;的边缘</target>
        </trans-unit>
        <trans-unit id="d2d8a6b76e19500caa5bf07c8a328b68c38bc616" translate="yes" xml:space="preserve">
          <source>The editing workflow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f1be0a37063a8a4026cc94c7cf86f62cf5bdd8" translate="yes" xml:space="preserve">
          <source>The effect of broadcasting.</source>
          <target state="translated">广播的效果。</target>
        </trans-unit>
        <trans-unit id="a34abd23a6e4bdf2596a3b4673affad53721777d" translate="yes" xml:space="preserve">
          <source>The eigenvalues are computed using LAPACK routines &lt;code&gt;_syevd&lt;/code&gt;, &lt;code&gt;_heevd&lt;/code&gt;.</source>
          <target state="translated">使用LAPACK例程 &lt;code&gt;_syevd&lt;/code&gt; ， &lt;code&gt;_heevd&lt;/code&gt; 计算特征值。</target>
        </trans-unit>
        <trans-unit id="7701e5ef9799c4995d19bac48ad9fa82db4dc5c5" translate="yes" xml:space="preserve">
          <source>The eigenvalues in ascending order, each repeated according to its multiplicity.</source>
          <target state="translated">按升序排列的特征值,每个特征值按其倍数重复。</target>
        </trans-unit>
        <trans-unit id="af42e28434cbe95fe6890df4d996c2c99e9b2481" translate="yes" xml:space="preserve">
          <source>The eigenvalues of real symmetric or complex Hermitian matrices are always real. &lt;a href=&quot;#rc702e98a756a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; The array &lt;code&gt;v&lt;/code&gt; of (column) eigenvectors is unitary and &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;dot(a, v[:, i]) = w[i] * v[:, i]&lt;/code&gt;.</source>
          <target state="translated">实对称或复Hermitian矩阵的特征值始终为实。&lt;a href=&quot;#rc702e98a756a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;（列）特征向量的数组 &lt;code&gt;v&lt;/code&gt; 是单一的，并且 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;w&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 满足等式 &lt;code&gt;dot(a, v[:, i]) = w[i] * v[:, i]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ff4d23698273b360b1d6366e444e95ea540f28f" translate="yes" xml:space="preserve">
          <source>The eigenvalues, each repeated according to its multiplicity. The eigenvalues are not necessarily ordered. The resulting array will be of complex type, unless the imaginary part is zero in which case it will be cast to a real type. When &lt;code&gt;a&lt;/code&gt; is real the resulting eigenvalues will be real (0 imaginary part) or occur in conjugate pairs</source>
          <target state="translated">特征值，每个特征值根据其多重性重复。特征值不一定是有序的。除非虚部为零，否则所得数组将为复杂类型，在这种情况下，它将被强制转换为实型。当 &lt;code&gt;a&lt;/code&gt; 为实数时，所得特征值将为实数（虚部为0）或出现在共轭对中</target>
        </trans-unit>
        <trans-unit id="9cfc7ae7c9df4df4270a01f781a7985d0061b823" translate="yes" xml:space="preserve">
          <source>The eigenvalues, each repeated according to its multiplicity. They are not necessarily ordered, nor are they necessarily real for real matrices.</source>
          <target state="translated">的特征值,每个特征值按其倍数重复。它们不一定是有序的,也不一定是实数矩阵的实数。</target>
        </trans-unit>
        <trans-unit id="fedbdf07c41c58b01420971d15b808683a8a1612" translate="yes" xml:space="preserve">
          <source>The eigenvalues/eigenvectors are computed using LAPACK routines &lt;code&gt;_syevd&lt;/code&gt;, &lt;code&gt;_heevd&lt;/code&gt;.</source>
          <target state="translated">使用LAPACK例程 &lt;code&gt;_syevd&lt;/code&gt; ， &lt;code&gt;_heevd&lt;/code&gt; 计算特征值/特征向量。</target>
        </trans-unit>
        <trans-unit id="672eac8f0267740479f9ff389b02d40f57b3ff35" translate="yes" xml:space="preserve">
          <source>The element inserted in &lt;code&gt;output&lt;/code&gt; when all conditions evaluate to False.</source>
          <target state="translated">当所有条件评估为False时，元素将插入 &lt;code&gt;output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c154db2e01512028a28319b3317262699278c799" translate="yes" xml:space="preserve">
          <source>The element size of this data-type object.</source>
          <target state="translated">该数据类型对象的元素大小。</target>
        </trans-unit>
        <trans-unit id="100849a009dc981ce005b4c12bbdd30342f43ac6" translate="yes" xml:space="preserve">
          <source>The element-wise remainder of the quotient &lt;code&gt;floor_divide(x1, x2)&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">商 &lt;code&gt;floor_divide(x1, x2)&lt;/code&gt; 的按元素的余数。如果 &lt;code&gt;x1&lt;/code&gt; 和 &lt;code&gt;x2&lt;/code&gt; 均为标量，则为标量。</target>
        </trans-unit>
        <trans-unit id="55f57b3f397334c809b04b980612f0a5ab349a62" translate="yes" xml:space="preserve">
          <source>The elements are binary-valued (0 or 1).</source>
          <target state="translated">元素为二进制值(0或1)。</target>
        </trans-unit>
        <trans-unit id="4e3cc7c953fc2e3ea61645fad74045ef41161886" translate="yes" xml:space="preserve">
          <source>The elements in a NumPy array are all required to be of the same data type, and thus will be the same size in memory. The exception: one can have arrays of (Python, including NumPy) objects, thereby allowing for arrays of different sized elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d658a71c2e23e5ce04fb215c6cdc657f3c41d2" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;a&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;m&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">使用此索引顺序读取 &lt;code&gt;a&lt;/code&gt; 的元素。 &amp;ldquo; C&amp;rdquo;表示以类似C的顺序索引元素，最后一个轴索引更改最快，而返回到第一个轴索引更改最慢。 &amp;ldquo; F&amp;rdquo;表示以类似Fortran的索引顺序索引元素，第一个索引更改最快，最后一个索引更改最慢。请注意，&amp;ldquo; C&amp;rdquo;和&amp;ldquo; F&amp;rdquo;选项不考虑基础数组的内存布局，仅参考轴索引的顺序。如果 &lt;code&gt;m&lt;/code&gt; 在内存中是&lt;em&gt;连续的&lt;/em&gt; Fortran，则&amp;ldquo; A&amp;rdquo;表示以类似于Fortran的索引顺序读取元素，否则为类似于C的顺序。 &amp;ldquo; K&amp;rdquo;表示按顺序在内存中读取元素，但当步幅为负时反转数据除外。默认情况下，使用&amp;ldquo; C&amp;rdquo;索引顺序。</target>
        </trans-unit>
        <trans-unit id="27ccf6e9acce055e532ad81d9bdd8638f9a4a262" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;a&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in row-major, C-style order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in column-major, Fortran-style order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;a&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">使用此索引顺序读取 &lt;code&gt;a&lt;/code&gt; 的元素。&amp;ldquo; C&amp;rdquo;表示以行优先，C样式的顺序索引元素，最后一个轴索引更改最快，回到第一个轴索引更改最慢。&amp;ldquo; F&amp;rdquo;表示以Fortran样式的列主顺序索引元素，第一个索引变化最快，最后一个索引变化最慢。请注意，&amp;ldquo; C&amp;rdquo;和&amp;ldquo; F&amp;rdquo;选项不考虑基础数组的内存布局，仅参考轴索引的顺序。如果 &lt;code&gt;a&lt;/code&gt; 是&lt;em&gt;连续的&lt;/em&gt; Fortran，则&amp;ldquo; A&amp;rdquo;表示以类似于Fortran的索引顺序读取元素&lt;em&gt;&lt;/em&gt;在内存中，否则类似C的顺序。&amp;ldquo; K&amp;rdquo;表示按步在内存中的顺序读取元素，但步幅为负时反转数据除外。默认情况下，使用&amp;ldquo; C&amp;rdquo;索引顺序。</target>
        </trans-unit>
        <trans-unit id="8bfe90d8bb9b3a44603b03bac0e42210874e7808" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;m&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;m&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">使用此索引顺序读取 &lt;code&gt;m&lt;/code&gt; 的元素。 &amp;ldquo; C&amp;rdquo;表示以类似C的顺序索引元素，最后一个轴索引更改最快，而返回到第一个轴索引更改最慢。 &amp;ldquo; F&amp;rdquo;表示以类似Fortran的索引顺序索引元素，第一个索引更改最快，最后一个索引更改最慢。请注意，&amp;ldquo; C&amp;rdquo;和&amp;ldquo; F&amp;rdquo;选项不考虑基础数组的内存布局，仅参考轴索引的顺序。如果 &lt;code&gt;m&lt;/code&gt; 在内存中是&lt;em&gt;连续的&lt;/em&gt; Fortran，则&amp;ldquo; A&amp;rdquo;表示以类似于Fortran的索引顺序读取元素，否则为类似于C的顺序。 &amp;ldquo; K&amp;rdquo;表示按顺序在内存中读取元素，但当步幅为负时反转数据除外。默认情况下，使用&amp;ldquo; C&amp;rdquo;索引顺序。</target>
        </trans-unit>
        <trans-unit id="d8d7a05ea4e76ed025da3efb7e37c3722ae9fddb" translate="yes" xml:space="preserve">
          <source>The elements of both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;a.T&lt;/code&gt; get traversed in the same order, namely the order they are stored in memory, whereas the elements of &lt;code&gt;a.T.copy(order=&amp;rsquo;C&amp;rsquo;)&lt;/code&gt; get visited in a different order because they have been put into a different memory layout.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;a.T&lt;/code&gt; 的元素以相同的顺序遍历，即它们存储在内存中的顺序，而 &lt;code&gt;a.T.copy(order=&amp;rsquo;C&amp;rsquo;)&lt;/code&gt; 的元素以不同的顺序访问，因为它们已放入不同的内存中布局。</target>
        </trans-unit>
        <trans-unit id="7c09282fb5ba8925fe26507ed54970dbeacf3bc3" translate="yes" xml:space="preserve">
          <source>The elements of the shape tuple give the lengths of the corresponding array dimensions.</source>
          <target state="translated">形状元组的元素给出了相应阵列尺寸的长度。</target>
        </trans-unit>
        <trans-unit id="d08dc6baf6d1de4ff7af87aa1f35d18925c1f47b" translate="yes" xml:space="preserve">
          <source>The elements of this structure are:</source>
          <target state="translated">这一结构的要素是:</target>
        </trans-unit>
        <trans-unit id="c3ccba03f1b5d3bd5cacb97014f1795b1e1620ff" translate="yes" xml:space="preserve">
          <source>The ellipsis syntax maybe used to indicate selecting in full any remaining unspecified dimensions. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0777cee700edf703f03cd8f123c44ac46b607f9" translate="yes" xml:space="preserve">
          <source>The end value of the sequence, unless &lt;code&gt;endpoint&lt;/code&gt; is set to False. In that case, the sequence consists of all but the last of &lt;code&gt;num + 1&lt;/code&gt; evenly spaced samples, so that &lt;code&gt;stop&lt;/code&gt; is excluded. Note that the step size changes when &lt;code&gt;endpoint&lt;/code&gt; is False.</source>
          <target state="translated">序列的最终值，除非将 &lt;code&gt;endpoint&lt;/code&gt; 设置为False。在这种情况下，该序列由除 &lt;code&gt;num + 1&lt;/code&gt; 均匀间隔的采样之外的所有采样组成，因此排除了 &lt;code&gt;stop&lt;/code&gt; 。请注意，当 &lt;code&gt;endpoint&lt;/code&gt; 为False 时，步长会更改。</target>
        </trans-unit>
        <trans-unit id="61c8a67ac747d5eb7d80852565d6317e805901a1" translate="yes" xml:space="preserve">
          <source>The endpoint of the interval can optionally be excluded.</source>
          <target state="translated">区间的端点可以选择排除。</target>
        </trans-unit>
        <trans-unit id="7c70e4957abd94f2cb0f87772d68554c90cbe5b2" translate="yes" xml:space="preserve">
          <source>The entropy for creating a &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">创建&lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt;的熵。</target>
        </trans-unit>
        <trans-unit id="0807164c2e58b526f47d2a17d970242e2786a8ed" translate="yes" xml:space="preserve">
          <source>The enumeration value for ASCII strings of a selectable size. The strings have a fixed maximum size within a given array.</source>
          <target state="translated">可选择大小的ASCII字符串的枚举值。在一个给定的数组中,字符串有一个固定的最大尺寸。</target>
        </trans-unit>
        <trans-unit id="4486c486e9b2ccc0519632048cae0af33e6f2bea" translate="yes" xml:space="preserve">
          <source>The enumeration value for UCS4 strings of a selectable size. The strings have a fixed maximum size within a given array.</source>
          <target state="translated">可选择大小的UCS4字符串的枚举值。在给定的数组中,字符串有一个固定的最大尺寸。</target>
        </trans-unit>
        <trans-unit id="ceb80d4c945347bb465d428088d951fae89cf7e9" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 128-bit/16-byte complex type made up of two NPY_DOUBLE values.</source>
          <target state="translated">由两个NPY_DOUBLE值组成的128位/16字节复杂类型的枚举值。</target>
        </trans-unit>
        <trans-unit id="022dd3242a4f7ab9f354ab53434df9783dde262d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte IEEE 754-2008 compatible floating point type.</source>
          <target state="translated">16位/2字节IEEE 754-2008兼容浮点类型的枚举值。</target>
        </trans-unit>
        <trans-unit id="54200391c747968ffe444d868d0f00fe22c905a7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte signed integer.</source>
          <target state="translated">16位/2字节有符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="24e698054b91536d27ff27c354d21704b0ff5fa7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte unsigned integer.</source>
          <target state="translated">16位/2字节无符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="48c93b25a09888099a2fa0e8cc423bbdd97aec51" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte IEEE 754 compatible floating point type.</source>
          <target state="translated">32位/4字节IEEE 754兼容浮点类型的枚举值。</target>
        </trans-unit>
        <trans-unit id="0767688f1013b974d66b67bec323cce162186c28" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte signed integer.</source>
          <target state="translated">32位/4字节有符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="61e002f4aaa6d35ff73356572d5e52edd07749bc" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte unsigned integer.</source>
          <target state="translated">32位/4字节无符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="13bb2de2cc37c2d6613c3c408dc1f6c1a04bcaf7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte IEEE 754 compatible floating point type.</source>
          <target state="translated">64位/8字节IEEE 754兼容浮点类型的枚举值。</target>
        </trans-unit>
        <trans-unit id="712e85738302795b01166defaa51ce15d788398b" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte complex type made up of two NPY_FLOAT values.</source>
          <target state="translated">由两个NPY_FLOAT值组成的64位/8字节复杂类型的枚举值。</target>
        </trans-unit>
        <trans-unit id="6fcce91d25d23bb25fdb72e7335d026c8e38fbfa" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte signed integer.</source>
          <target state="translated">64位/8字节有符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="d2fd87ac5f2fe419cf576e3d1240b873a7fd353f" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte unsigned integer.</source>
          <target state="translated">64位/8字节无符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="7aee8554ea2f116b0ced362cc168497aed3b5e7d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a data type which holds dates or datetimes with a precision based on selectable date or time units.</source>
          <target state="translated">数据类型的枚举值,该数据类型持有日期或日期时间,其精度基于可选择的日期或时间单位。</target>
        </trans-unit>
        <trans-unit id="81373e1b16d0b1374953b29f2c2ce84e5c1e7ca6" translate="yes" xml:space="preserve">
          <source>The enumeration value for a data type which holds lengths of times in integers of selectable date or time units.</source>
          <target state="translated">数据类型的枚举值,它以可选择的日期或时间单位的整数来保存时间长度。</target>
        </trans-unit>
        <trans-unit id="025565ff9d1efa7089189ec4ae9c78d4afba6baf" translate="yes" xml:space="preserve">
          <source>The enumeration value for a platform-specific complex floating point type which is made up of two NPY_LONGDOUBLE values.</source>
          <target state="translated">平台特有的复杂浮点类型的枚举值,它由两个NPY_LONGDOUBLE值组成。</target>
        </trans-unit>
        <trans-unit id="02ee59a76dc8246cf577894e400f4aef4b3c2cdb" translate="yes" xml:space="preserve">
          <source>The enumeration value for a platform-specific floating point type which is at least as large as NPY_DOUBLE, but larger on many platforms.</source>
          <target state="translated">平台特定浮点类型的枚举值,它至少和NPY_DOUBLE一样大,但在许多平台上更大。</target>
        </trans-unit>
        <trans-unit id="12bd9d6078665b062a610e653e29b9b8b5cd0f4d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a signed integer type which is the same size as a (void *) pointer. This is the type used by all arrays of indices.</source>
          <target state="translated">有符号整数类型的枚举值,其大小与(void *)指针相同。这是所有指数数组使用的类型。</target>
        </trans-unit>
        <trans-unit id="1915b2aac968e6b707b08a802a86e659f6b7b54c" translate="yes" xml:space="preserve">
          <source>The enumeration value for an 8-bit/1-byte signed integer.</source>
          <target state="translated">8位/1字节有符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="e2cde6e55c74a7eec76c04ac7971b58aabed014c" translate="yes" xml:space="preserve">
          <source>The enumeration value for an 8-bit/1-byte unsigned integer.</source>
          <target state="translated">8位/1字节无符号整数的枚举值。</target>
        </trans-unit>
        <trans-unit id="3bc60c39b304a6beb211c263d892c90730d59bf2" translate="yes" xml:space="preserve">
          <source>The enumeration value for an unsigned integer type which is the same size as a (void *) pointer.</source>
          <target state="translated">无符号整数类型的枚举值,其大小与(void *)指针相同。</target>
        </trans-unit>
        <trans-unit id="00cb2e716adb7d63188da00709d01e2a11b34089" translate="yes" xml:space="preserve">
          <source>The enumeration value for references to arbitrary Python objects.</source>
          <target state="translated">对任意 Python 对象引用的枚举值。</target>
        </trans-unit>
        <trans-unit id="dbec8c6917cdb1fb9cc672eba6fd415b762d7774" translate="yes" xml:space="preserve">
          <source>The enumeration value for the boolean type, stored as one byte. It may only be set to the values 0 and 1.</source>
          <target state="translated">布尔类型的枚举值,以一个字节的形式存储。它只能被设置为0和1。</target>
        </trans-unit>
        <trans-unit id="f6d7694b75b473ad222039c05e89641ad1c019cb" translate="yes" xml:space="preserve">
          <source>The enumeration value of the type used for masks, such as with the &lt;a href=&quot;c-api.iterator#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; iterator flag. This is equivalent to &lt;a href=&quot;#c.NPY_UINT8&quot;&gt;&lt;code&gt;NPY_UINT8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于掩码的类型的枚举值，例如带有&lt;a href=&quot;c-api.iterator#c.NPY_ITER_ARRAYMASK&quot;&gt; &lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt; &lt;/a&gt;迭代器标志的值。这等效于&lt;a href=&quot;#c.NPY_UINT8&quot;&gt; &lt;code&gt;NPY_UINT8&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="470c7c6a0fdea0ae871ac319202aa3679b0d2b38" translate="yes" xml:space="preserve">
          <source>The enumeration value of the type used for masks, such as with the &lt;a href=&quot;iterator#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; iterator flag. This is equivalent to &lt;a href=&quot;#c.NPY_UINT8&quot;&gt;&lt;code&gt;NPY_UINT8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60104b59eca7223d2be466212e148860409e987c" translate="yes" xml:space="preserve">
          <source>The equivalent for floating point data types.</source>
          <target state="translated">浮点数据类型的等价物。</target>
        </trans-unit>
        <trans-unit id="4e36288c483218b6153f62263e1c19e0918537e1" translate="yes" xml:space="preserve">
          <source>The equivalent for integer data types.</source>
          <target state="translated">整数数据类型的等价物。</target>
        </trans-unit>
        <trans-unit id="f007c7cbd53c8448e809d2bc2019ae342707c904" translate="yes" xml:space="preserve">
          <source>The error also has additional information to help you troubleshoot:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c428e56ed9d259c349566498573b0b72cf82c45" translate="yes" xml:space="preserve">
          <source>The error mask is a single integer that holds the treatment information on all four floating point errors. The information for each error type is contained in three bits of the integer. If we print it in base 8, we can see what treatment is set for &amp;ldquo;invalid&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, and &amp;ldquo;divide&amp;rdquo; (in that order). The printed string can be interpreted with</source>
          <target state="translated">错误掩码是一个整数，其中包含所有四个浮点错误的处理信息。每种错误类型的信息都包含在整数的三位中。如果将其打印在基数8中，则可以看到对&amp;ldquo;无效&amp;rdquo;，&amp;ldquo;不足&amp;rdquo;，&amp;ldquo;上方&amp;rdquo;和&amp;ldquo;分隔&amp;rdquo;（按该顺序）设置了什么处理。打印的字符串可以用</target>
        </trans-unit>
        <trans-unit id="6236f64a81230ccb9458bf1fe006ba3279baed6f" translate="yes" xml:space="preserve">
          <source>The error message to be printed in case of failure.</source>
          <target state="translated">失败时要打印的错误信息。</target>
        </trans-unit>
        <trans-unit id="46e36d39518380daadad6b1e62b8973365b854c8" translate="yes" xml:space="preserve">
          <source>The error object contains all information that defines the error handling behavior in NumPy. &lt;a href=&quot;#numpy.geterrobj&quot;&gt;&lt;code&gt;geterrobj&lt;/code&gt;&lt;/a&gt; is used internally by the other functions that get and set error handling behavior (&lt;a href=&quot;numpy.geterr#numpy.geterr&quot;&gt;&lt;code&gt;geterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.geterrcall#numpy.geterrcall&quot;&gt;&lt;code&gt;geterrcall&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">错误对象包含所有在NumPy中定义错误处理行为的信息。&lt;a href=&quot;#numpy.geterrobj&quot;&gt; &lt;code&gt;geterrobj&lt;/code&gt; &lt;/a&gt;由获取和设置错误处理行为的其他函数（&lt;a href=&quot;numpy.geterr#numpy.geterr&quot;&gt; &lt;code&gt;geterr&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.geterrcall#numpy.geterrcall&quot;&gt; &lt;code&gt;geterrcall&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt;）在内部使用。</target>
        </trans-unit>
        <trans-unit id="d7bceac49145568dab2a83ccab3ab1eea9b12faf" translate="yes" xml:space="preserve">
          <source>The error object contains all information that defines the error handling behavior in NumPy. &lt;a href=&quot;#numpy.seterrobj&quot;&gt;&lt;code&gt;seterrobj&lt;/code&gt;&lt;/a&gt; is used internally by the other functions that set error handling behavior (&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">错误对象包含所有在NumPy中定义错误处理行为的信息。&lt;a href=&quot;#numpy.seterrobj&quot;&gt; &lt;code&gt;seterrobj&lt;/code&gt; &lt;/a&gt;由设置错误处理行为的其他函数（&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt;）在内部使用。</target>
        </trans-unit>
        <trans-unit id="717ffb083d9a010e39e00d26ae4cbb3686fdec82" translate="yes" xml:space="preserve">
          <source>The error object, a list containing three elements: [internal numpy buffer size, error mask, error callback function].</source>
          <target state="translated">错误对象,一个包含三个元素的列表。[内部numpy缓冲区大小,错误掩码,错误回调函数]。</target>
        </trans-unit>
        <trans-unit id="9f5b3632192f41c961bfe841ce3532fd1faa0967" translate="yes" xml:space="preserve">
          <source>The evaluation uses Clenshaw recursion, aka synthetic division.</source>
          <target state="translated">评价使用了克伦肖递归,也就是合成除法。</target>
        </trans-unit>
        <trans-unit id="9a7486fe20eefd44f8d5d46a29c17743d8baf71d" translate="yes" xml:space="preserve">
          <source>The evaluation uses Horner&amp;rsquo;s method.</source>
          <target state="translated">评估使用霍纳法。</target>
        </trans-unit>
        <trans-unit id="db5640fe4648623a565ed032ffc116fcc6e293bd" translate="yes" xml:space="preserve">
          <source>The exact definition of a slow test is obviously both subjective and hardware-dependent, but in general any individual test that requires more than a second or two should be labeled as slow (the whole suite consists of thousands of tests, so even a second is significant).</source>
          <target state="translated">对慢速测试的准确定义显然既是主观的,也是取决于硬件的,但一般来说,任何单个测试如果需要一两秒以上的时间,都应该被贴上慢速的标签(整个套件由数千个测试组成,所以即使是一秒也是很重要的)。</target>
        </trans-unit>
        <trans-unit id="0fe09946a84bc00c7ff87cc3c4856ae88e30a696" translate="yes" xml:space="preserve">
          <source>The example also demonstrates Cython&amp;rsquo;s &amp;ldquo;typed memoryviews&amp;rdquo;, which are like NumPy arrays at the C level, in the sense that they are shaped and strided arrays that know their own extent (unlike a C array addressed through a bare pointer). The syntax &lt;code&gt;double complex[:]&lt;/code&gt; denotes a one-dimensional array (vector) of doubles, with arbitrary strides. A contiguous array of ints would be &lt;code&gt;int[::1]&lt;/code&gt;, while a matrix of floats would be &lt;code&gt;float[:, :]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3927b62f1cd7d72e0062722877a649b50aac359" translate="yes" xml:space="preserve">
          <source>The example code may be split across multiple lines, with each line after the first starting with &amp;lsquo;&amp;hellip; &amp;lsquo;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6b68db229268c95185c669cea481b3a1f2e9b2" translate="yes" xml:space="preserve">
          <source>The examples may assume that &lt;code&gt;import numpy as np&lt;/code&gt; is executed before the example code in &lt;em&gt;numpy&lt;/em&gt;. Additional examples may make use of &lt;em&gt;matplotlib&lt;/em&gt; for plotting, but should import it explicitly, e.g., &lt;code&gt;import matplotlib.pyplot as plt&lt;/code&gt;. All other imports, including the demonstrated function, must be explicit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a28216e8d502daba2aa9f77ed97bda4ac746a41" translate="yes" xml:space="preserve">
          <source>The exceptions to the above rules are given below:</source>
          <target state="translated">以下是上述规则的例外情况。</target>
        </trans-unit>
        <trans-unit id="ea2c7bd23b14b815638891431083c6a5af9b6f5a" translate="yes" xml:space="preserve">
          <source>The execution will now stop at the corresponding C function and you can step through it as usual. A number of useful Python-specific commands are available. For example to see where in the Python code you are, use &lt;code&gt;py-list&lt;/code&gt;. For more details, see &lt;a href=&quot;https://wiki.python.org/moin/DebuggingWithGdb&quot;&gt;DebuggingWithGdb&lt;/a&gt;. Here are some commonly used commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8953035a1ae2630eb8257139de6a8432deef2d8b" translate="yes" xml:space="preserve">
          <source>The expected object.</source>
          <target state="translated">预期的对象。</target>
        </trans-unit>
        <trans-unit id="ec4e2a0cf38710bdb603b5d339066519f8b6c301" translate="yes" xml:space="preserve">
          <source>The expected string.</source>
          <target state="translated">预期的字符串。</target>
        </trans-unit>
        <trans-unit id="59f101f805e4afd5d4f5aac41091912e82f52cce" translate="yes" xml:space="preserve">
          <source>The exponent can be any integer or long integer, positive, negative, or zero.</source>
          <target state="translated">指数可以是任何整数或长整数,正数、负数或零。</target>
        </trans-unit>
        <trans-unit id="48bfe58fce3c9524a47514144118fc15384f8ce9" translate="yes" xml:space="preserve">
          <source>The exponent that yields &lt;code&gt;eps&lt;/code&gt;.</source>
          <target state="translated">产生 &lt;code&gt;eps&lt;/code&gt; 的指数。</target>
        </trans-unit>
        <trans-unit id="8728d1625b1f4800f5da44ea73eddec8a90b29f7" translate="yes" xml:space="preserve">
          <source>The exponent that yields &lt;code&gt;epsneg&lt;/code&gt;.</source>
          <target state="translated">产生 &lt;code&gt;epsneg&lt;/code&gt; 的指数。</target>
        </trans-unit>
        <trans-unit id="3d2aac84d1e998e3af66433136551e2122fcd6db" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#r0dbb9b01ef9c-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#r0dbb9b01ef9c-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">指数分布是几何分布的连续模拟。它描述了许多常见的情况，例如在多次暴风雨中测得的雨滴的大小&lt;a href=&quot;#r0dbb9b01ef9c-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;或到Wikipedia的页面请求之间的时间&lt;a href=&quot;#r0dbb9b01ef9c-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="379909a59d38e5f49bfe83c94188ec2a18000b03" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#r3cbd6af2d0d3-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#r3cbd6af2d0d3-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0234d51209697de2e3092417cea04cdd633ab5" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#rcf497e7bc958-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#rcf497e7bc958-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">指数分布是几何分布的连续模拟。它描述了许多常见的情况，例如在多次暴风雨中测得的雨滴的大小&lt;a href=&quot;#rcf497e7bc958-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;或到Wikipedia的页面请求之间的时间&lt;a href=&quot;#rcf497e7bc958-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d68d926a5db1e2f83fa605bc0a4678131d567b9" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#rcfd3e98ffb09-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#rcfd3e98ffb09-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ed180d63f4fd6bda2a99808d388e4ba0b2acb0" translate="yes" xml:space="preserve">
          <source>The exponents. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">指数。如果 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; ，则必须将它们广播为通用形状（成为输出的形状）。</target>
        </trans-unit>
        <trans-unit id="4a0678b00019c9d465c7278be4782e4ae402fa1c" translate="yes" xml:space="preserve">
          <source>The expression within brackets in &lt;code&gt;b[i]&lt;/code&gt; is treated as an &lt;code&gt;i&lt;/code&gt; followed by as many instances of &lt;code&gt;:&lt;/code&gt; as needed to represent the remaining axes. NumPy also allows you to write this using dots as &lt;code&gt;b[i,...]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330beb4f458d2c8c447ab8cdae27158e06bf7cb9" translate="yes" xml:space="preserve">
          <source>The extracted diagonal or constructed diagonal array.</source>
          <target state="translated">提取的对角线或构造的对角线阵列。</target>
        </trans-unit>
        <trans-unit id="53a8a2b8a609081b147379c06e4ca152c3e8819c" translate="yes" xml:space="preserve">
          <source>The f2py method of linking compiled code is currently the most sophisticated and integrated approach. It allows clean separation of Python with compiled code while still allowing for separate distribution of the extension module. The only draw-back is that it requires the existence of a Fortran compiler in order for a user to install the code. However, with the existence of the free-compilers g77, gfortran, and g95, as well as high-quality commercial compilers, this restriction is not particularly onerous. In my opinion, Fortran is still the easiest way to write fast and clear code for scientific computing. It handles complex numbers, and multi-dimensional indexing in the most straightforward way. Be aware, however, that some Fortran compilers will not be able to optimize code as well as good hand- written C-code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555daf4232eb1ce31031f68a76fe276dbf717736" translate="yes" xml:space="preserve">
          <source>The f2py program is written in Python and can be run from inside your code to compile Fortran code at runtime, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e74a78df99ca864f56978dd8124a3fb8da4ff4" translate="yes" xml:space="preserve">
          <source>The field names may be modified by assigning to the &lt;code&gt;names&lt;/code&gt; attribute using a sequence of strings of the same length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76b262eba97deb65c7a5b3c9fb6314561e8e763" translate="yes" xml:space="preserve">
          <source>The field names, either specified as a comma-separated string in the form &lt;code&gt;'col1, col2, col3'&lt;/code&gt;, or as a list or tuple of strings in the form &lt;code&gt;['col1', 'col2', 'col3']&lt;/code&gt;. An empty list can be used, in that case default field names (&amp;lsquo;f0&amp;rsquo;, &amp;lsquo;f1&amp;rsquo;, &amp;hellip;) are used.</source>
          <target state="translated">字段名称，可以以逗号分隔的字符串形式 &lt;code&gt;'col1, col2, col3'&lt;/code&gt; 或以 &lt;code&gt;['col1', 'col2', 'col3']&lt;/code&gt; 形式的字符串列表或元组形式指定。可以使用一个空列表，在这种情况下，将使用默认字段名称（&amp;ldquo; f0&amp;rdquo;，&amp;ldquo; f1&amp;rdquo;，&amp;hellip;）。</target>
        </trans-unit>
        <trans-unit id="abdb8363ba033add56efe121cf142ecd7ff5e4f2" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;doc/changelog/1.14.5-changelog.rst&lt;/code&gt; should be updated to reflect the final list of changes and contributors. This text can be generated by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a3f62236ba0b0b8ce93c2fc463e81343db95a91" translate="yes" xml:space="preserve">
          <source>The file contains an object array, but allow_pickle=False given.</source>
          <target state="translated">文件中包含一个对象数组,但allow_pickle=False给定。</target>
        </trans-unit>
        <trans-unit id="cd858c6c51a98e96ec8ac35aea8fe45863b797ca" translate="yes" xml:space="preserve">
          <source>The file is opened in this mode:</source>
          <target state="translated">文件是在这种模式下打开的。</target>
        </trans-unit>
        <trans-unit id="5b33f093bafabe18517ca8ac91b17b43d100f40c" translate="yes" xml:space="preserve">
          <source>The file name or file object to be used as the array data buffer.</source>
          <target state="translated">要作为数组数据缓冲区的文件名或文件对象。</target>
        </trans-unit>
        <trans-unit id="26bdea2d86889049bdd7c48c4150155a14c6f9d5" translate="yes" xml:space="preserve">
          <source>The file or file name to load.</source>
          <target state="translated">要加载的文件或文件名。</target>
        </trans-unit>
        <trans-unit id="410bba1d09731e6c1884743045c51541ebe57e5e" translate="yes" xml:space="preserve">
          <source>The file to pickle &lt;code&gt;a&lt;/code&gt; to. If a string, the full path to the file.</source>
          <target state="translated">该文件咸菜 &lt;code&gt;a&lt;/code&gt; 对。如果是字符串，则为文件的完整路径。</target>
        </trans-unit>
        <trans-unit id="48b7a50cb95566779f051ba6cb8275f9d03a7f05" translate="yes" xml:space="preserve">
          <source>The file to read. File-like objects must support the &lt;code&gt;seek()&lt;/code&gt; and &lt;code&gt;read()&lt;/code&gt; methods. Pickled files require that the file-like object support the &lt;code&gt;readline()&lt;/code&gt; method as well.</source>
          <target state="translated">要读取的文件。类文件对象必须支持 &lt;code&gt;seek()&lt;/code&gt; 和 &lt;code&gt;read()&lt;/code&gt; 方法。腌制的文件要求类似文件的对象也支持 &lt;code&gt;readline()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="68f5b58fd976e02c0c3bbbefcb6355b0422acf86" translate="yes" xml:space="preserve">
          <source>The fill_value is set to &lt;code&gt;value&lt;/code&gt; and the mask is set to &lt;code&gt;nomask&lt;/code&gt; if possible.</source>
          <target state="translated">如果可能，将fill_value设置为 &lt;code&gt;value&lt;/code&gt; 并将mask设置为 &lt;code&gt;nomask&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac0cc14c76ce415edde3f9c0f5c15cc239b98f83" translate="yes" xml:space="preserve">
          <source>The filled array.</source>
          <target state="translated">填充数组。</target>
        </trans-unit>
        <trans-unit id="02297c05ffd69a001bc553284a8c48319db02e69" translate="yes" xml:space="preserve">
          <source>The filling value of the masked array is a scalar.</source>
          <target state="translated">掩码数组的填充值是一个标量。</target>
        </trans-unit>
        <trans-unit id="104abb4185415b9595a8eb2fd00671acf84e203a" translate="yes" xml:space="preserve">
          <source>The filling value of the masked array is a scalar. When setting, None will set to a default based on the data type.</source>
          <target state="translated">掩码数组的填充值是一个标量,设置时,None将根据数据类型设置为默认值。设置时,&quot;无 &quot;将根据数据类型设置为默认值。</target>
        </trans-unit>
        <trans-unit id="0bd5aa8a98810899514ee710bc2579712901ebe5" translate="yes" xml:space="preserve">
          <source>The final value of the sequence, unless &lt;code&gt;endpoint&lt;/code&gt; is False. In that case, &lt;code&gt;num + 1&lt;/code&gt; values are spaced over the interval in log-space, of which all but the last (a sequence of length &lt;code&gt;num&lt;/code&gt;) are returned.</source>
          <target state="translated">序列的最终值，除非 &lt;code&gt;endpoint&lt;/code&gt; 为False。在这种情况下， &lt;code&gt;num + 1&lt;/code&gt; 值在log-space的间隔中间隔开，返回除最后一个（长度为 &lt;code&gt;num&lt;/code&gt; 的序列）外的所有值。</target>
        </trans-unit>
        <trans-unit id="5b6f2d1ecce5ed0ec2d0e715086fccc9259a6627" translate="yes" xml:space="preserve">
          <source>The first 6 bytes are a magic string: exactly &lt;code&gt;\x93NUMPY&lt;/code&gt;.</source>
          <target state="translated">前6个字节是一个魔术字符串：恰好 &lt;code&gt;\x93NUMPY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df3f3dac6a267f56fafa2c760b8d38d59413267f" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;nargs&lt;/code&gt; elements of &lt;code&gt;steps&lt;/code&gt; remain the same as for scalar ufuncs. The following elements contain the strides of all core dimensions for all arguments in order.</source>
          <target state="translated">&lt;code&gt;steps&lt;/code&gt; 的前 &lt;code&gt;nargs&lt;/code&gt; 个元素与标量ufuncs相同。以下元素按顺序包含所有参数的所有核心维度的跨度。</target>
        </trans-unit>
        <trans-unit id="b9577dc8ae8dc3d75fe0e9351485a971c104657b" translate="yes" xml:space="preserve">
          <source>The first argument contains the Extension instance that can be useful to access its attributes like &lt;code&gt;depends&lt;/code&gt;, &lt;code&gt;sources&lt;/code&gt;, etc. lists and modify them during the building process. The second argument gives a path to a build directory that must be used when creating files to a disk.</source>
          <target state="translated">第一个参数包含Extension实例，可用于在构建过程中访问其属性，例如 &lt;code&gt;depends&lt;/code&gt; ， &lt;code&gt;sources&lt;/code&gt; 等列表，并对其进行修改。第二个参数提供了到磁盘创建文件时必须使用的构建目录的路径。</target>
        </trans-unit>
        <trans-unit id="98f417ae094b593aad4f373856f9d75fc3caadf1" translate="yes" xml:space="preserve">
          <source>The first argument is any object that can be converted into a fixed-size data-type object. The second argument is the desired shape of this type. If the shape parameter is 1, then the data-type object is equivalent to fixed dtype. If &lt;em&gt;shape&lt;/em&gt; is a tuple, then the new dtype defines a sub-array of the given shape.</source>
          <target state="translated">第一个参数是可以转换为固定大小的数据类型对象的任何对象。第二个参数是这种类型的所需形状。如果shape参数为1，则数据类型对象等效于固定dtype。如果&lt;em&gt;shape&lt;/em&gt;是一个元组，则新的dtype定义给定形状的子数组。</target>
        </trans-unit>
        <trans-unit id="8dca1bab679e35ad504daad1a00ee24ea2d780cc" translate="yes" xml:space="preserve">
          <source>The first argument is any object that can be converted into a fixed-size data-type object. The second argument is the desired shape of this type. If the shape parameter is 1, then the data-type object used to be equivalent to fixed dtype. This behaviour is deprecated since NumPy 1.17 and will raise an error in the future. If &lt;em&gt;shape&lt;/em&gt; is a tuple, then the new dtype defines a sub-array of the given shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb3620809413337a1b624decfe7e8c4e4d1dcd2" translate="yes" xml:space="preserve">
          <source>The first argument is the newly created sub-type. The second argument (if not NULL) is the &amp;ldquo;parent&amp;rdquo; array (if the array was created using slicing or some other operation where a clearly-distinguishable parent is present). This routine can do anything it wants to. It should return a -1 on error and 0 otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a0c10acae5d14d1b06af72f8c3df392eea96371" translate="yes" xml:space="preserve">
          <source>The first argument must be an object that is converted to a zero-sized flexible data-type object, the second argument is an integer providing the desired itemsize.</source>
          <target state="translated">第一个参数必须是一个被转换为零大小的灵活数据类型对象的对象,第二个参数是一个整数,提供所需的项目大小。</target>
        </trans-unit>
        <trans-unit id="4ab185078e9e031c6680e1f1eab45ad50f864a10" translate="yes" xml:space="preserve">
          <source>The first array shows the outcomes of throwing the dice 10 times, and the second shows the outcomes from throwing the dice 20 times.</source>
          <target state="translated">第一个阵列显示的是投掷骰子10次的结果,第二个阵列显示的是投掷骰子20次的结果。</target>
        </trans-unit>
        <trans-unit id="251cc7294c3d03a290266d04d53995289d0bed50" translate="yes" xml:space="preserve">
          <source>The first assert does not raise an exception:</source>
          <target state="translated">第一个断言没有引起例外。</target>
        </trans-unit>
        <trans-unit id="0135e65581d52468c8b55907d113ce790f408aef" translate="yes" xml:space="preserve">
          <source>The first business day on or after a date:</source>
          <target state="translated">日期当天或之后的第一个工作日。</target>
        </trans-unit>
        <trans-unit id="034408f6ac73256e0eb3a019833e3b1d26d2adb1" translate="yes" xml:space="preserve">
          <source>The first business day strictly after a date:</source>
          <target state="translated">严格在约会后的第一个工作日。</target>
        </trans-unit>
        <trans-unit id="d4d700653c3699a51205d4e8a1ce2d74d29df2ba" translate="yes" xml:space="preserve">
          <source>The first character specifies the kind of data and the remaining characters specify the number of bytes per item, except for Unicode, where it is interpreted as the number of characters. The item size must correspond to an existing type, or an error will be raised. The supported kinds are</source>
          <target state="translated">第一个字符指定数据的种类,其余字符指定每个项目的字节数,但Unicode除外,在Unicode中,它被解释为字符数。项的大小必须与现有的类型相对应,否则会出现错误。支持的类型有</target>
        </trans-unit>
        <trans-unit id="fce5520747cac508bb51c31e51bc43340f4f28dc" translate="yes" xml:space="preserve">
          <source>The first difference is given by &lt;code&gt;out[i] = a[i+1] - a[i]&lt;/code&gt; along the given axis, higher differences are calculated by using &lt;a href=&quot;#numpy.diff&quot;&gt;&lt;code&gt;diff&lt;/code&gt;&lt;/a&gt; recursively.</source>
          <target state="translated">沿给定轴的第一个差异为 &lt;code&gt;out[i] = a[i+1] - a[i]&lt;/code&gt; ，通过递归使用&lt;a href=&quot;#numpy.diff&quot;&gt; &lt;code&gt;diff&lt;/code&gt; &lt;/a&gt;计算更高的差异。</target>
        </trans-unit>
        <trans-unit id="a9df17052dacee8cafb40ea7e55b18075cf5de14" translate="yes" xml:space="preserve">
          <source>The first element, &lt;em&gt;field_name&lt;/em&gt;, is the field name (if this is &lt;code&gt;''&lt;/code&gt; then a standard field name, &lt;code&gt;'f#'&lt;/code&gt;, is assigned). The field name may also be a 2-tuple of strings where the first string is either a &amp;ldquo;title&amp;rdquo; (which may be any string or unicode string) or meta-data for the field which can be any object, and the second string is the &amp;ldquo;name&amp;rdquo; which must be a valid Python identifier.</source>
          <target state="translated">第一元件，&lt;em&gt;FIELD_NAME&lt;/em&gt;，是字段名称（如果这是 &lt;code&gt;''&lt;/code&gt; 则一个标准的字段名， &lt;code&gt;'f#'&lt;/code&gt; ，被分配）。字段名称也可以是2个字符串的字符串，其中第一个字符串可以是&amp;ldquo; title&amp;rdquo;（可以是任何字符串或unicode字符串），也可以是该字段的元数据，可以是任何对象，第二个字符串是&amp;ldquo;名称&amp;rdquo;，必须是有效的Python标识符。</target>
        </trans-unit>
        <trans-unit id="67d77719eacdaf274558e4a616994274e8d068b0" translate="yes" xml:space="preserve">
          <source>The first example integrates &lt;code&gt;p&lt;/code&gt; once, the second example integrates it twice. By default, the lower bound of the integration and the integration constant are 0, but both can be specified.:</source>
          <target state="translated">第一个示例 &lt;code&gt;p&lt;/code&gt; 一次积分，第二个示例对p进行两次积分。缺省情况下，积分的下界和积分常数为0，但都可以指定。</target>
        </trans-unit>
        <trans-unit id="311abfb54dbdf5d2ba16af23aef0589cc8d8cc86" translate="yes" xml:space="preserve">
          <source>The first form should be preferred.</source>
          <target state="translated">应首选第一种形式。</target>
        </trans-unit>
        <trans-unit id="efb03ce57a81f162cb7b4a2a4999809358d24fef" translate="yes" xml:space="preserve">
          <source>The first integer is the first byte of the array, the second integer is just past the last byte of the array. If &lt;code&gt;a&lt;/code&gt; is not contiguous it will not use every byte between the (&lt;code&gt;low&lt;/code&gt;, &lt;code&gt;high&lt;/code&gt;) values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19fd42d2f3f6ab1e3a2844cd4d5055ea1cbf31a0" translate="yes" xml:space="preserve">
          <source>The first is the use of the &lt;code&gt;ndarray.__new__&lt;/code&gt; method for the main work of object initialization, rather then the more usual &lt;code&gt;__init__&lt;/code&gt; method. The second is the use of the &lt;code&gt;__array_finalize__&lt;/code&gt; method to allow subclasses to clean up after the creation of views and new instances from templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb41b42b24f210f1f4be6981685ada6a1cb54412" translate="yes" xml:space="preserve">
          <source>The first law of Laplace, from 1774, states that the frequency of an error can be expressed as an exponential function of the absolute magnitude of the error, which leads to the Laplace distribution. For many problems in economics and health sciences, this distribution seems to model the data better than the standard Gaussian distribution.</source>
          <target state="translated">1774年的拉普拉斯第一定律指出,误差的频率可以表示为误差绝对值的指数函数,这就导致了拉普拉斯分布。对于经济学和健康科学中的许多问题,这种分布似乎比标准的高斯分布更能模拟数据。</target>
        </trans-unit>
        <trans-unit id="f7deea27a398e3cec5cdd6f79c6e53fb0be11445" translate="yes" xml:space="preserve">
          <source>The first output can be provided as either a positional or a keyword parameter. Keyword &amp;lsquo;out&amp;rsquo; arguments are incompatible with positional ones.</source>
          <target state="translated">第一输出可以作为位置参数或关键字参数提供。关键字&amp;ldquo; out&amp;rdquo;参数与位置参数不兼容。</target>
        </trans-unit>
        <trans-unit id="6c26c4fe0578c2071a8b45fe1c269e9b84d2d403" translate="yes" xml:space="preserve">
          <source>The first parameter, arr, must be an ndarray or subclass. The parameter, &lt;em&gt;flags&lt;/em&gt;, should be an integer consisting of bitwise combinations of the possible flags an array can have: &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">第一个参数arr必须是ndarray或子类。参数，&lt;em&gt;标志&lt;/em&gt;，应该是由可能的标志的阵列可具有的按位的组合的一个整数：&lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt; &lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a463555884e9f663755cbacb732bc60283f30e4e" translate="yes" xml:space="preserve">
          <source>The first rule of broadcasting is that if all input arrays do not have the same number of dimensions, a &amp;ldquo;1&amp;rdquo; will be repeatedly prepended to the shapes of the smaller arrays until all the arrays have the same number of dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8639bf3cb0cf6544a568d7a40bcc68d44fbb8c9" translate="yes" xml:space="preserve">
          <source>The first signature listed, &lt;code&gt;( DATA_TYPE IN_ARRAY[ANY] )&lt;/code&gt; is for one-dimensional arrays with hard-coded dimensions. Likewise, &lt;code&gt;( DATA_TYPE IN_ARRAY2[ANY][ANY] )&lt;/code&gt; is for two-dimensional arrays with hard-coded dimensions, and similarly for three-dimensional.</source>
          <target state="translated">列出的第一个签名 &lt;code&gt;( DATA_TYPE IN_ARRAY[ANY] )&lt;/code&gt; 用于具有硬编码维的一维数组。同样， &lt;code&gt;( DATA_TYPE IN_ARRAY2[ANY][ANY] )&lt;/code&gt; 用于具有硬编码维的二维数组，并且对于三维也是类似的。</target>
        </trans-unit>
        <trans-unit id="21bc00ee1c8a15912cb2e713abebe2d2f93cd1e7" translate="yes" xml:space="preserve">
          <source>The first thing done is to look-up in the thread-specific global dictionary the current values for the buffer-size, the error mask, and the associated error object. The state of the error mask controls what happens when an error condition is found. It should be noted that checking of the hardware error flags is only performed after each 1-D loop is executed. This means that if the input and output arrays are contiguous and of the correct type so that a single 1-D loop is performed, then the flags may not be checked until all elements of the array have been calculated. Looking up these values in a thread- specific dictionary takes time which is easily ignored for all but very small arrays.</source>
          <target state="translated">首先要做的是在线程特定的全局字典中查找缓冲区大小、错误掩码和相关错误对象的当前值。错误掩码的状态控制着发现错误条件时的情况。需要注意的是,对硬件错误标志的检查只在每个一维循环执行后进行。这意味着,如果输入和输出数组是连续的,并且类型正确,因此执行一个1-D循环,那么在数组的所有元素被计算出来之前,可能不会检查标志。在线程特定的字典中查找这些值需要花费时间,这对于除很小的数组外的所有数组来说很容易被忽略。</target>
        </trans-unit>
        <trans-unit id="eec0cb9e2856c8840ae3269c16ee7eee2770a458" translate="yes" xml:space="preserve">
          <source>The first thing to understand is that there are two conflicting conventions for indexing 2-dimensional arrays. Matrix notation uses the first index to indicate which row is being selected and the second index to indicate which column is selected. This is opposite the geometrically oriented-convention for images where people generally think the first index represents x position (i.e., column) and the second represents y position (i.e., row). This alone is the source of much confusion; matrix-oriented users and image-oriented users expect two different things with regard to indexing.</source>
          <target state="translated">首先要了解的是,二维数组的索引有两个相互冲突的约定。矩阵符号用第一个索引来表示选择哪一行,第二个索引来表示选择哪一列。这与图像的几何定向约定相反,人们一般认为第一个索引代表x位置(即列),第二个索引代表y位置(即行)。仅仅是这一点就造成了很多的混乱;面向矩阵的用户和面向图像的用户对索引有两种不同的期望。</target>
        </trans-unit>
        <trans-unit id="43a31061c48404a506dd1e24e7517ade62790639" translate="yes" xml:space="preserve">
          <source>The fixed size of NumPy numeric types may cause overflow errors when a value requires more memory than available in the data type. For example, &lt;a href=&quot;../reference/generated/numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt; evaluates &lt;code&gt;100 * 10 ** 8&lt;/code&gt; correctly for 64-bit integers, but gives 1874919424 (incorrect) for a 32-bit integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae27e752e6250bcf53dd15428c26bfc6c4aff24" translate="yes" xml:space="preserve">
          <source>The flags member may consist of 5 bits showing how the data should be interpreted and one bit showing how the Interface should be interpreted. The data-bits are &lt;code&gt;CONTIGUOUS&lt;/code&gt; (0x1), &lt;code&gt;FORTRAN&lt;/code&gt; (0x2), &lt;code&gt;ALIGNED&lt;/code&gt; (0x100), &lt;code&gt;NOTSWAPPED&lt;/code&gt; (0x200), and &lt;code&gt;WRITEABLE&lt;/code&gt; (0x400). A final flag &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; (0x800) indicates whether or not this structure has the arrdescr field. The field should not be accessed unless this flag is present.</source>
          <target state="translated">标志成员可以由5位和1位组成，其中5位表示应如何解释数据，而1位则应如何解释接口。该数据比特是 &lt;code&gt;CONTIGUOUS&lt;/code&gt; （为0x1）， &lt;code&gt;FORTRAN&lt;/code&gt; （0X2）， &lt;code&gt;ALIGNED&lt;/code&gt; （0x100的）， &lt;code&gt;NOTSWAPPED&lt;/code&gt; （为0x200）和 &lt;code&gt;WRITEABLE&lt;/code&gt; （0x400的）。最后一个标志 &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; （0x800）指示此结构是否具有arrdescr字段。除非存在此标志，否则不应访问该字段。</target>
        </trans-unit>
        <trans-unit id="80d94b3bc99b1a4e8e2a1a02a0e27c0ae964964b" translate="yes" xml:space="preserve">
          <source>The flexible type array that is returned will have two fields:</source>
          <target state="translated">返回的灵活类型数组将有两个字段。</target>
        </trans-unit>
        <trans-unit id="bd686ab267e11ccd8dcbb950337101a32f2aa2c7" translate="yes" xml:space="preserve">
          <source>The float printing routines use an accurate but much more computationally demanding algorithm to compute the number of digits after the decimal point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b521c71cd9d32371a352dcf94d2ff132ccb79f4" translate="yes" xml:space="preserve">
          <source>The floating-point exceptions are defined in the IEEE 754 standard &lt;a href=&quot;#r4cab4292821f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="translated">浮点异常在IEEE 754标准&lt;a href=&quot;#r4cab4292821f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;中定义：</target>
        </trans-unit>
        <trans-unit id="25cd839f1fa0397dfd8a073d288328126b03cd06" translate="yes" xml:space="preserve">
          <source>The floor division operator &lt;code&gt;//&lt;/code&gt; was added in Python 2.2 making &lt;code&gt;//&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; equivalent operators. The default floor division operation of &lt;code&gt;/&lt;/code&gt; can be replaced by true division with &lt;code&gt;from
__future__ import division&lt;/code&gt;.</source>
          <target state="translated">地板除法运算符 &lt;code&gt;//&lt;/code&gt; 是在Python 2.2中添加的 &lt;code&gt;//&lt;/code&gt; 和 &lt;code&gt;/&lt;/code&gt; 等效运算符。默认地板除法运算 &lt;code&gt;/&lt;/code&gt; 可真司被替换 &lt;code&gt;from __future__ import division&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
