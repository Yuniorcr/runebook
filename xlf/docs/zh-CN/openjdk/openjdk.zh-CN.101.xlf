<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="1c155ad46a4245a542e0a856a2e04822b42fb9f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;returnType&lt;/code&gt; is not one of the types defined in &lt;a href=&quot;xpathconstants&quot;&gt;&lt;code&gt;XPathConstants&lt;/code&gt;&lt;/a&gt;, then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果 &lt;code&gt;returnType&lt;/code&gt; 不是&lt;a href=&quot;xpathconstants&quot;&gt; &lt;code&gt;XPathConstants&lt;/code&gt; 中&lt;/a&gt;定义的类型之一，则抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d860614074042f19bdf291701426974c3c57e4a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;row&lt;/code&gt; is &amp;lt; 0 or &amp;gt;= &lt;code&gt;getRowCount&lt;/code&gt; this will have no effect.</source>
          <target state="translated">如果 &lt;code&gt;row&lt;/code&gt; &amp;lt;0或&amp;gt; = &lt;code&gt;getRowCount&lt;/code&gt; ,则将无效。</target>
        </trans-unit>
        <trans-unit id="876d8a672b3c54e715d8e73f684241ce161aa28e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s.length&lt;/code&gt; is zero, then no bytes are written. Otherwise, the character &lt;code&gt;s[0]&lt;/code&gt; is written first, then &lt;code&gt;s[1]&lt;/code&gt;, and so on; the last character written is &lt;code&gt;s[s.length-1]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;s.length&lt;/code&gt; 为零，则不写入任何字节。否则，先写字符 &lt;code&gt;s[0]&lt;/code&gt; ，然后写 &lt;code&gt;s[1]&lt;/code&gt; ，依此类推；最后写入 &lt;code&gt;s[s.length-1]&lt;/code&gt; 字符是s [s.length-1]。</target>
        </trans-unit>
        <trans-unit id="9e4b1baa5111d66d53cd12fc271e18655498ac09" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s.length&lt;/code&gt; is zero, then no bytes are written. Otherwise, the character &lt;code&gt;s[0]&lt;/code&gt; is written first, then &lt;code&gt;s[1]&lt;/code&gt;, and so on; the last character written is &lt;code&gt;s[s.length-1]&lt;/code&gt;. For each character, one byte is written, the low-order byte, in exactly the manner of the &lt;code&gt;writeByte&lt;/code&gt; method . The high-order eight bits of each character in the string are ignored.</source>
          <target state="translated">如果 &lt;code&gt;s.length&lt;/code&gt; 为零，则不写入任何字节。否则，先写字符 &lt;code&gt;s[0]&lt;/code&gt; ，然后写 &lt;code&gt;s[1]&lt;/code&gt; ，依此类推；最后写入 &lt;code&gt;s[s.length-1]&lt;/code&gt; 字符是s [s.length-1]。对于每个字符，完全按照 &lt;code&gt;writeByte&lt;/code&gt; 方法的方式写入一个字节，即低位字节。字符串中每个字符的高8位被忽略。</target>
        </trans-unit>
        <trans-unit id="edcdda7ec2d8edbea83d4e8f71c2458f937626bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s.length&lt;/code&gt; is zero, then no bytes are written. Otherwise, the character &lt;code&gt;s[0]&lt;/code&gt; is written first, then &lt;code&gt;s[1]&lt;/code&gt;, and so on; the last character written is &lt;code&gt;s[s.length-1]&lt;/code&gt;. For each character, one byte is written, the low-order byte, in exactly the manner of the &lt;code&gt;writeByte&lt;/code&gt; method. The high-order eight bits of each character in the string are ignored.</source>
          <target state="translated">如果 &lt;code&gt;s.length&lt;/code&gt; 为零，则不写入任何字节。否则，先写字符 &lt;code&gt;s[0]&lt;/code&gt; ，然后写 &lt;code&gt;s[1]&lt;/code&gt; ，依此类推；最后写入 &lt;code&gt;s[s.length-1]&lt;/code&gt; 字符是s [s.length-1]。对于每个字符，完全按照 &lt;code&gt;writeByte&lt;/code&gt; 方法的方式写入一个字节，即低位字节。字符串中每个字符的高8位被忽略。</target>
        </trans-unit>
        <trans-unit id="e875e2a67d01ff828275b31d43c1fbd127c980d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44817af6998c4077db388be5b4a7890f5a06339e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then the four characters &lt;code&gt;&quot;null&quot;&lt;/code&gt; are appended.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则附加四个字符 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="990d1368ff7f5774e8459cd4e9be500eb83cc4a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then the four characters &lt;code&gt;&quot;null&quot;&lt;/code&gt; are inserted into this sequence.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则将四个字符 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 插入到此序列中。</target>
        </trans-unit>
        <trans-unit id="b05ca4901f2ddfb6f0df8f458f94e1208be8876d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then this method appends characters as if the s parameter was a sequence containing the four characters &lt;code&gt;&quot;null&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则此方法追加字符，就好像s参数是包含四个字符 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 的序列一样。</target>
        </trans-unit>
        <trans-unit id="f17a7925b555b07f1177d7e0b04970042d705c0a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then this method inserts characters as if the s parameter was a sequence containing the four characters &lt;code&gt;&quot;null&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则此方法将插入字符，就像s参数是包含四个字符 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 的序列一样。</target>
        </trans-unit>
        <trans-unit id="9aac27d78dce887df2392eaea3ecd3f3fa4c1f8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setDestinationOffsets&lt;/code&gt; has not been called, a &lt;code&gt;Point&lt;/code&gt; with zero X and Y values is returned (which is the correct value).</source>
          <target state="translated">如果尚未调用 &lt;code&gt;setDestinationOffsets&lt;/code&gt; ，则返回X和Y值为零的 &lt;code&gt;Point&lt;/code&gt; （这是正确的值）。</target>
        </trans-unit>
        <trans-unit id="f3a9e603b0a4b8521e4750e1c066ac967b23512c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setSourceSubsampling&lt;/code&gt; has not been called, 0 is returned (which is the correct value).</source>
          <target state="translated">如果尚未调用 &lt;code&gt;setSourceSubsampling&lt;/code&gt; ，则返回0（这是正确的值）。</target>
        </trans-unit>
        <trans-unit id="79ac09906fe716bce01c69681d75a4bf9a9cb03d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setSourceSubsampling&lt;/code&gt; has not been called, 1 is returned (which is the correct value).</source>
          <target state="translated">如果尚未调用 &lt;code&gt;setSourceSubsampling&lt;/code&gt; ，则返回1（这是正确的值）。</target>
        </trans-unit>
        <trans-unit id="aa1ac4e940630f846fd22734fc11fce22cf0121f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setToolTipText&lt;/code&gt; has been invoked with a non-&lt;code&gt;null&lt;/code&gt; value, it will be returned, otherwise</source>
          <target state="translated">如果已使用非 &lt;code&gt;null&lt;/code&gt; 值调用 &lt;code&gt;setToolTipText&lt;/code&gt; ，则将返回它，否则返回</target>
        </trans-unit>
        <trans-unit id="61566ceca2a0f3c6f13616e2fc6f7a73b100c4e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sites&lt;/code&gt; contains a null element, a &lt;code&gt;NullPointerException&lt;/code&gt; will be raised. In this case, some non-null elements in the array may be processed before the method returns abnormally. Which elements these are (if any) is implementation-dependent.</source>
          <target state="translated">如果 &lt;code&gt;sites&lt;/code&gt; 包含null元素，则将引发 &lt;code&gt;NullPointerException&lt;/code&gt; 。在这种情况下，在方法异常返回之前，可能会处理数组中的一些非null元素。这些元素（如果有）是取决于实现的。</target>
        </trans-unit>
        <trans-unit id="cee89be3aeb95368cd40a9cab8c4abdc56959164" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;snk&lt;/code&gt; is an unconnected piped input stream and &lt;code&gt;src&lt;/code&gt; is an unconnected piped output stream, they may be connected by either the call:</source>
          <target state="translated">如果 &lt;code&gt;snk&lt;/code&gt; 是未连接的管道输入流，而 &lt;code&gt;src&lt;/code&gt; 是未连接的管道输出流，则可以通过以下任一调用将它们连接：</target>
        </trans-unit>
        <trans-unit id="690341647fe6d76e88ef315850f5a25397916209" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;snk&lt;/code&gt; is an unconnected piped reader and &lt;code&gt;src&lt;/code&gt; is an unconnected piped writer, they may be connected by either the call:</source>
          <target state="translated">如果 &lt;code&gt;snk&lt;/code&gt; 是未连接的管道读取器，而 &lt;code&gt;src&lt;/code&gt; 是未连接的管道写入器，则可以通过以下任一调用来连接它们：</target>
        </trans-unit>
        <trans-unit id="f9c5366be534f93ab5f5deefe308b27ed6664cd9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果 &lt;code&gt;source&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f3a2230d84b641f83bf303d40e79f1f03207242" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; is not an instance of one of the classes returned by &lt;code&gt;getInputTypes&lt;/code&gt;, the method should simply return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;source&lt;/code&gt; 不是 &lt;code&gt;getInputTypes&lt;/code&gt; 返回的类之一的实例，则该方法应简单地返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="637f0a7792b7cb0bc9a73c24b4e0f9994163e5c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; or &lt;code&gt;returnType&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果 &lt;code&gt;source&lt;/code&gt; 或 &lt;code&gt;returnType&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="219f0aba2e1ad229cd0601cb06d21c32b8f7d289" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown and the destination array is not modified.</source>
          <target state="translated">如果 &lt;code&gt;src&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则抛出 &lt;code&gt;NullPointerException&lt;/code&gt; ，并且不修改目标数组。</target>
        </trans-unit>
        <trans-unit id="5d71167d52ef22cb2f16571454a6827b101e0c9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; is an unconnected piped output stream and &lt;code&gt;snk&lt;/code&gt; is an unconnected piped input stream, they may be connected by either the call:</source>
          <target state="translated">如果 &lt;code&gt;src&lt;/code&gt; 是未连接的管道输出流，而 &lt;code&gt;snk&lt;/code&gt; 是未连接的管道输入流，则可以通过以下任一调用来连接它们：</target>
        </trans-unit>
        <trans-unit id="760f4c540dae14e4e4ea567bb935f8fcce39cb15" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; is an unconnected piped writer and &lt;code&gt;snk&lt;/code&gt; is an unconnected piped reader, they may be connected by either the call:</source>
          <target state="translated">如果 &lt;code&gt;src&lt;/code&gt; 是未连接的管道写入器，而 &lt;code&gt;snk&lt;/code&gt; 是未连接的管道读取器，则可以通过以下任一调用来连接它们：</target>
        </trans-unit>
        <trans-unit id="c619334825864b10343e14e3a5fa2edbf88f1438" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is &amp;plusmn;&lt;a href=&quot;double#MIN_VALUE&quot;&gt;&lt;code&gt;Double.MIN_VALUE&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;direction&lt;/code&gt; has a value such that the result should have a smaller magnitude, then a zero with the same sign as &lt;code&gt;start&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;start&lt;/code&gt; 为&amp;plusmn; &lt;a href=&quot;double#MIN_VALUE&quot;&gt; &lt;code&gt;Double.MIN_VALUE&lt;/code&gt; ,&lt;/a&gt;并且 &lt;code&gt;direction&lt;/code&gt; 的值应使结果的大小较小，则返回与 &lt;code&gt;start&lt;/code&gt; 具有相同符号的零。</target>
        </trans-unit>
        <trans-unit id="fae5b0093d13f14219d9322f18e9441f961ca477" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is &amp;plusmn;&lt;a href=&quot;float#MIN_VALUE&quot;&gt;&lt;code&gt;Float.MIN_VALUE&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;direction&lt;/code&gt; has a value such that the result should have a smaller magnitude, then a zero with the same sign as &lt;code&gt;start&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;start&lt;/code&gt; 为&amp;plusmn; &lt;a href=&quot;float#MIN_VALUE&quot;&gt; &lt;code&gt;Float.MIN_VALUE&lt;/code&gt; ,&lt;/a&gt;并且 &lt;code&gt;direction&lt;/code&gt; 具有一个值，使得结果的幅度应较小，则返回与 &lt;code&gt;start&lt;/code&gt; 具有相同符号的零。</target>
        </trans-unit>
        <trans-unit id="f66998e543c1a12b2ca918a211e06eae5f94b1c3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is equal to &amp;plusmn; &lt;a href=&quot;double#MAX_VALUE&quot;&gt;&lt;code&gt;Double.MAX_VALUE&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;direction&lt;/code&gt; has a value such that the result should have a larger magnitude, an infinity with same sign as &lt;code&gt;start&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;start&lt;/code&gt; 等于&amp;plusmn; &lt;a href=&quot;double#MAX_VALUE&quot;&gt; &lt;code&gt;Double.MAX_VALUE&lt;/code&gt; ,&lt;/a&gt;并且 &lt;code&gt;direction&lt;/code&gt; 具有一个值，使得结果应具有更大的幅度，则返回与 &lt;code&gt;start&lt;/code&gt; 具有相同符号的无穷大。</target>
        </trans-unit>
        <trans-unit id="a161a170f19a8906de8c9a6cfd3d5e37f8f5ff13" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is equal to &amp;plusmn; &lt;a href=&quot;float#MAX_VALUE&quot;&gt;&lt;code&gt;Float.MAX_VALUE&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;direction&lt;/code&gt; has a value such that the result should have a larger magnitude, an infinity with same sign as &lt;code&gt;start&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;start&lt;/code&gt; 等于&amp;plusmn; &lt;a href=&quot;float#MAX_VALUE&quot;&gt; &lt;code&gt;Float.MAX_VALUE&lt;/code&gt; ,&lt;/a&gt;并且 &lt;code&gt;direction&lt;/code&gt; 具有一个值，使得结果应具有更大的幅度，则返回与 &lt;code&gt;start&lt;/code&gt; 具有相同符号的无穷大。</target>
        </trans-unit>
        <trans-unit id="a58cc90d3a573be11a8ea4b0883f3c2086b63b6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is infinite and &lt;code&gt;direction&lt;/code&gt; has a value such that the result should have a smaller magnitude, &lt;a href=&quot;double#MAX_VALUE&quot;&gt;&lt;code&gt;Double.MAX_VALUE&lt;/code&gt;&lt;/a&gt; with the same sign as &lt;code&gt;start&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;start&lt;/code&gt; 是无限的，并且 &lt;code&gt;direction&lt;/code&gt; 具有一个值，使得结果应该具有较小的大小，则返回与 &lt;code&gt;start&lt;/code&gt; 具有相同符号的&lt;a href=&quot;double#MAX_VALUE&quot;&gt; &lt;code&gt;Double.MAX_VALUE&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ae7182c34098ff9d6f56022f88e1e7fdd3a318a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is infinite and &lt;code&gt;direction&lt;/code&gt; has a value such that the result should have a smaller magnitude, &lt;a href=&quot;float#MAX_VALUE&quot;&gt;&lt;code&gt;Float.MAX_VALUE&lt;/code&gt;&lt;/a&gt; with the same sign as &lt;code&gt;start&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;start&lt;/code&gt; 是无限的，并且 &lt;code&gt;direction&lt;/code&gt; 具有一个值，使得结果应具有较小的大小，则返回与 &lt;code&gt;start&lt;/code&gt; 具有相同符号的&lt;a href=&quot;float#MAX_VALUE&quot;&gt; &lt;code&gt;Float.MAX_VALUE&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6cd80221ac94b2f2e71b197d42d75c47e15af2c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;strict&lt;/code&gt; is false, when a tag that breaks flow, (&lt;code&gt;TagElement.breaksFlows&lt;/code&gt;) or trailing whitespace is encountered, all whitespace will be ignored until a non whitespace character is encountered. This appears to give behavior closer to the popular browsers.</source>
          <target state="translated">如果 &lt;code&gt;strict&lt;/code&gt; 为false，则遇到中 &lt;code&gt;TagElement.breaksFlows&lt;/code&gt; 的标记（TagElement.breaksFlows）或结尾的空白时，所有空白将被忽略，直到遇到非空白字符为止。这似乎使行为更接近流行的浏览器。</target>
        </trans-unit>
        <trans-unit id="dd9e9926b4084569dcc965ce6b61db0e47d85ad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subjectDN&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should contain a distinguished name, in RFC 2253 format.</source>
          <target state="translated">如果 &lt;code&gt;subjectDN&lt;/code&gt; 不为 &lt;code&gt;null&lt;/code&gt; ，则它应包含RFC 2253格式的专有名称。</target>
        </trans-unit>
        <trans-unit id="a8333161ec6b6561928b6f53c8cfefeeee4ccdf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subjectDN&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should contain a single DER encoded distinguished name, as defined in X.501. For the ASN.1 notation for this structure, see &lt;a href=&quot;#setIssuer(byte%5B%5D)&quot;&gt;&lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;subjectDN&lt;/code&gt; 不为 &lt;code&gt;null&lt;/code&gt; ，则它应包含X.501中定义的单个DER编码的专有名称。有关此结构的ASN.1表示法，请参见&lt;a href=&quot;#setIssuer(byte%5B%5D)&quot;&gt; &lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ea050f10d06248bcf9421ca5fbce2a0e9eb8454" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subjectDN&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should contain a single DER encoded distinguished name, as defined in X.501. For the ASN.1 notation for this structure, see &lt;a href=&quot;x509certselector#setIssuer-byte:A-&quot;&gt;&lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;subjectDN&lt;/code&gt; 不为 &lt;code&gt;null&lt;/code&gt; ，则它应包含X.501中定义的单个DER编码的专有名称。有关此结构的ASN.1表示法，请参见&lt;a href=&quot;x509certselector#setIssuer-byte:A-&quot;&gt; &lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2013740722fd95a1604400c614bd63582e466a8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subjectKeyID&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should contain a single DER encoded value corresponding to the contents of the extension value (not including the object identifier, criticality setting, and encapsulating OCTET STRING) for a SubjectKeyIdentifier extension. The ASN.1 notation for this structure follows.</source>
          <target state="translated">如果 &lt;code&gt;subjectKeyID&lt;/code&gt; 不为 &lt;code&gt;null&lt;/code&gt; ，则它应包含一个与SubjectKeyIdentifier扩展名的扩展值的内容相对应的DER编码值（不包括对象标识符，关键性设置和封装OCTET STRING）。遵循此结构的ASN.1表示法。</target>
        </trans-unit>
        <trans-unit id="a8a2d56ad412e7e8bed4d2deae78a648b54d9910" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;switchPoints&lt;/code&gt; contains a null element, a &lt;code&gt;NullPointerException&lt;/code&gt; will be raised. In this case, some non-null elements in the array may be processed before the method returns abnormally. Which elements these are (if any) is implementation-dependent.</source>
          <target state="translated">如果 &lt;code&gt;switchPoints&lt;/code&gt; 包含null元素，则将引发 &lt;code&gt;NullPointerException&lt;/code&gt; 。在这种情况下，在方法异常返回之前，可能会处理数组中的一些非null元素。这些元素（如果有）是取决于实现的。</target>
        </trans-unit>
        <trans-unit id="73066e095387b022012986549b34f1448bd7aa6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout&lt;/code&gt; is greater than 0, the method returns after &lt;code&gt;timeout&lt;/code&gt; milliseconds even if there is no change in state. In that case, this method returns &lt;code&gt;false&lt;/code&gt;; otherwise it returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;timeout&lt;/code&gt; 大于0，则即使状态没有变化，该方法也会在 &lt;code&gt;timeout&lt;/code&gt; 毫秒后返回。在这种情况下，此方法返回 &lt;code&gt;false&lt;/code&gt; 。否则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9110736d0ba8beddd891578c4cd267d3ed2df9b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trayIcon&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or was not added to the system tray, no exception is thrown and no action is performed.</source>
          <target state="translated">如果 &lt;code&gt;trayIcon&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; 或未添加到系统托盘，则不会引发任何异常并且不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="1dc73700c68c63f248dae219cde824ef4b8f9196" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; is returned, the JDBC driver must support the returning of auto-generated keys for at least SQL INSERT statements</source>
          <target state="translated">如果返回 &lt;code&gt;true&lt;/code&gt; ，则JDBC驱动程序必须至少支持为SQL INSERT语句返回自动生成的键。</target>
        </trans-unit>
        <trans-unit id="06115dacf5b34fb8d3c0d2c47a4c8739954912e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; the auto-scrolling is enabled.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则启用自动滚动。</target>
        </trans-unit>
        <trans-unit id="f5a6d295804593883ad2ce93da589746015b3c79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the protocol is allowed to use caching whenever it can.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则允许协议尽可能使用缓存。</target>
        </trans-unit>
        <trans-unit id="9165b89186b82d1302645d783c2a0c1050d0333c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the protocol is allowed to use caching whenever it can. If &lt;code&gt;false&lt;/code&gt;, the protocol must always try to get a fresh copy of the object.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则允许协议尽可能使用缓存。如果为 &lt;code&gt;false&lt;/code&gt; ，则协议必须始终尝试获取对象的新副本。</target>
        </trans-unit>
        <trans-unit id="28bab1545813399b6959c7a48698b477c2089f22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the protocol will automatically follow redirects.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则协议将自动跟随重定向。</target>
        </trans-unit>
        <trans-unit id="e68e3758b38fae66da1ed8095766c26a46ef65a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the protocol will automatically follow redirects. If &lt;code&gt;false&lt;/code&gt;, the protocol will not automatically follow redirects.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则协议将自动跟随重定向。如果为 &lt;code&gt;false&lt;/code&gt; ，则协议不会自动遵循重定向。</target>
        </trans-unit>
        <trans-unit id="5c2bff42d38b3e74f0a77d30306aa66a141445c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this &lt;code&gt;URL&lt;/code&gt; is being examined in a context in which it makes sense to allow user interactions such as popping up an authentication dialog.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则在允许用户交互（如弹出身份验证对话框）的意义下检查该 &lt;code&gt;URL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1347facf72554ede8e0ebdf4e21d8496b6b672a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this &lt;code&gt;URL&lt;/code&gt; is being examined in a context in which it makes sense to allow user interactions such as popping up an authentication dialog. If &lt;code&gt;false&lt;/code&gt;, then no user interaction is allowed.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则在允许用户交互（例如弹出身份验证对话框）的意义下检查该 &lt;code&gt;URL&lt;/code&gt; 。如果为 &lt;code&gt;false&lt;/code&gt; ，则不允许用户交互。</target>
        </trans-unit>
        <trans-unit id="5c993a9c8cd84f954007dac990e0fc740f486086" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this glyph absorbs all extra space at this and lower priority levels when it grows.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则此字形在增长时会吸收此优先级和较低优先级的所有额外空间。</target>
        </trans-unit>
        <trans-unit id="976048025c34666d0a2f1d2690ac8cc5cc20d7e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;,this glyph absorbs all remaining shrinkage at this and lower priority levels as it shrinks.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则此字形在收缩时会吸收此优先级和较低优先级的所有剩余收缩。</target>
        </trans-unit>
        <trans-unit id="d0224176165c2117154a3a0f83358aa57f06cb34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uris&lt;/code&gt; is empty, system property &lt;code&gt;javax.xml.catalog.files&lt;/code&gt;, as defined in &lt;a href=&quot;catalogfeatures&quot;&gt;&lt;code&gt;CatalogFeatures&lt;/code&gt;&lt;/a&gt;, will be read to locate the initial list of catalog files.</source>
          <target state="translated">如果 &lt;code&gt;uris&lt;/code&gt; 为空，则将读取&lt;a href=&quot;catalogfeatures&quot;&gt; &lt;code&gt;CatalogFeatures&lt;/code&gt; 中&lt;/a&gt;定义的系统属性 &lt;code&gt;javax.xml.catalog.files&lt;/code&gt; ，以查找目录文件的初始列表。</target>
        </trans-unit>
        <trans-unit id="adee4dfa9a0b08ac726e589fa9dfc1c09a04aa62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;useNative&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;color&lt;/code&gt; is created by using &lt;code&gt;Color.decode&lt;/code&gt; to convert the &lt;code&gt;
 String&lt;/code&gt; into a &lt;code&gt;Color&lt;/code&gt;. If &lt;code&gt;decode&lt;/code&gt; can not convert the &lt;code&gt;String&lt;/code&gt; into a &lt;code&gt;Color&lt;/code&gt; (&lt;code&gt;
 NumberFormatException&lt;/code&gt; is thrown) then a &lt;code&gt;
 ColorUIResource&lt;/code&gt; of black is used.</source>
          <target state="translated">如果 &lt;code&gt;useNative&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 时， &lt;code&gt;color&lt;/code&gt; 是通过使用创建 &lt;code&gt;Color.decode&lt;/code&gt; 的转换 &lt;code&gt; String&lt;/code&gt; 成一个 &lt;code&gt;Color&lt;/code&gt; 。如果 &lt;code&gt;decode&lt;/code&gt; 无法将 &lt;code&gt;String&lt;/code&gt; 转换为 &lt;code&gt;Color&lt;/code&gt; （引发 &lt;code&gt; NumberFormatException&lt;/code&gt; ），则使用黑色的 &lt;code&gt; ColorUIResource&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e12a5a71cacdb7a4b0cc546bbaf64c5c1947c59f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;useNative&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;color&lt;/code&gt; is the value of the field in &lt;code&gt;SystemColor&lt;/code&gt; with the same name as the &lt;code&gt;name&lt;/code&gt; of the &lt;code&gt;name-color&lt;/code&gt; pair. If the field is not valid, a &lt;code&gt;ColorUIResource&lt;/code&gt; of black is used.</source>
          <target state="translated">如果 &lt;code&gt;useNative&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;color&lt;/code&gt; 是 &lt;code&gt;SystemColor&lt;/code&gt; 中字段的值，其 &lt;code&gt;name&lt;/code&gt; 与 &lt;code&gt;name-color&lt;/code&gt; 对的名称相同。如果该字段无效，则使用黑色的 &lt;code&gt;ColorUIResource&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42c68be27b55a7fc86e8255ec96cc9fc619eff9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is a primitive array then &lt;code&gt;h&lt;/code&gt; is computed using the appropriate overloading of &lt;code&gt;java.util.Arrays.hashCode&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 是原始数组，则使用 &lt;code&gt;java.util.Arrays.hashCode&lt;/code&gt; 的适当重载来计算 &lt;code&gt;h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d6ba7534f9cf9c2b36675a6962310dd6297fdb3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is an object array then &lt;code&gt;h&lt;/code&gt; is computed using &lt;a href=&quot;../../../../java.base/java/util/arrays#deepHashCode(java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.deepHashCode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 是对象数组，则使用&lt;a href=&quot;../../../../java.base/java/util/arrays#deepHashCode(java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.deepHashCode&lt;/code&gt; &lt;/a&gt;计算 &lt;code&gt;h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="697fc3a2ae17f1968e68001fdcb19fb233006602" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is an object array then &lt;code&gt;h&lt;/code&gt; is computed using &lt;a href=&quot;../../../java.base/java/util/arrays#deepHashCode(java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.deepHashCode(Object[])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 是对象数组，则使用&lt;a href=&quot;../../../java.base/java/util/arrays#deepHashCode(java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.deepHashCode(Object[])&lt;/code&gt; &lt;/a&gt;计算 &lt;code&gt;h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7c2ed9b1d962075a2a4a29e826a8f5a3166754e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is an object array then &lt;code&gt;h&lt;/code&gt; is computed using &lt;a href=&quot;../../../java/util/arrays#deepHashCode-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.deepHashCode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 是对象数组，则使用&lt;a href=&quot;../../../java/util/arrays#deepHashCode-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.deepHashCode&lt;/code&gt; &lt;/a&gt;计算 &lt;code&gt;h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b9f393b2dc17964bf329368f78f1fec6ffbcc1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is an object array then &lt;code&gt;h&lt;/code&gt; is computed using &lt;a href=&quot;../../java/util/arrays#deepHashCode-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.deepHashCode(Object[])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 是对象数组，则使用&lt;a href=&quot;../../java/util/arrays#deepHashCode-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.deepHashCode(Object[])&lt;/code&gt; &lt;/a&gt;计算 &lt;code&gt;h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f9ca186e13d8a0b2f51cb3a886210bea7f10ac5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is null then &lt;code&gt;h&lt;/code&gt; is 0.</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 为null，则 &lt;code&gt;h&lt;/code&gt; 为0。</target>
        </trans-unit>
        <trans-unit id="6af7ae4e213065c80428b397aa23f3ea124048d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; this method will remove the property.</source>
          <target state="translated">如果 &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ,则此方法将删除该属性。</target>
        </trans-unit>
        <trans-unit id="cdf69f59b52da316eefe1f6713b87184e68ea952" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;variableName&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果 &lt;code&gt;variableName&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de58d32d92fa75ad61a38656206078ffc1357769" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weekOfYear&lt;/code&gt; is out of the valid week-of-year range in &lt;code&gt;weekYear&lt;/code&gt;, the &lt;code&gt;weekYear&lt;/code&gt; and &lt;code&gt;
 weekOfYear&lt;/code&gt; values are adjusted in lenient mode, or an &lt;code&gt;
 IllegalArgumentException&lt;/code&gt; is thrown in non-lenient mode.</source>
          <target state="translated">如果 &lt;code&gt;weekOfYear&lt;/code&gt; 是有效周的年范围内的出 &lt;code&gt;weekYear&lt;/code&gt; 的 &lt;code&gt;weekYear&lt;/code&gt; 和 &lt;code&gt; weekOfYear&lt;/code&gt; 值在宽松的方式进行调整，或者 &lt;code&gt; IllegalArgumentException&lt;/code&gt; 在非宽松的模式抛出。</target>
        </trans-unit>
        <trans-unit id="cf22cf86c23376b8eca15d02a9bb39702899c3a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weekOfYear&lt;/code&gt; is out of the valid week-of-year range in &lt;code&gt;weekYear&lt;/code&gt;, the &lt;code&gt;weekYear&lt;/code&gt; and &lt;code&gt;weekOfYear&lt;/code&gt; values are adjusted in lenient mode, or an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown in non-lenient mode.</source>
          <target state="translated">如果 &lt;code&gt;weekOfYear&lt;/code&gt; 是有效周的年范围内的出 &lt;code&gt;weekYear&lt;/code&gt; 的 &lt;code&gt;weekYear&lt;/code&gt; 和 &lt;code&gt;weekOfYear&lt;/code&gt; 值在宽松的方式进行调整，或者 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 在非宽松的模式抛出。</target>
        </trans-unit>
        <trans-unit id="2e04829a460140c9fa38864c5d9d7777958bc689" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;J&lt;/em&gt; has a method</source>
          <target state="translated">如果&lt;em&gt;J&lt;/em&gt;有一个方法</target>
        </trans-unit>
        <trans-unit id="780f93481eae7dbaf2119163257a12d0c3bdf665" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are primitives other than boolean, then a Java casting conversion (JLS 5.5) is applied. (Specifically, &lt;em&gt;T0&lt;/em&gt; will convert to &lt;em&gt;T1&lt;/em&gt; by widening and/or narrowing.)</source>
          <target state="translated">如果&lt;em&gt;T0&lt;/em&gt;和&lt;em&gt;T1&lt;/em&gt;是布尔值以外的其他原语，则将应用Java转换（JLS 5.5）。（具体来说，&lt;em&gt;T0&lt;/em&gt;将通过变宽和/或变窄转换为&lt;em&gt;T1&lt;/em&gt;。）</target>
        </trans-unit>
        <trans-unit id="8dac40b6866039e1587ae30b3906847041aa9167" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are primitives, then a Java method invocation conversion (JLS 5.3) is applied, if one exists. (Specifically, &lt;em&gt;T0&lt;/em&gt; must convert to &lt;em&gt;T1&lt;/em&gt; by a widening primitive conversion.)</source>
          <target state="translated">如果&lt;em&gt;T0&lt;/em&gt;和&lt;em&gt;T1&lt;/em&gt;是基元，那么将存在Java方法调用转换（JLS 5.3）。（具体来说，&lt;em&gt;T0&lt;/em&gt;必须通过扩展原始图元转换为&lt;em&gt;T1&lt;/em&gt;。）</target>
        </trans-unit>
        <trans-unit id="9ab9ec122966f4e63c48e8d018d94714edba20c1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are references, and &lt;em&gt;T1&lt;/em&gt; is an interface type, then the value of type &lt;em&gt;T0&lt;/em&gt; is passed as a &lt;em&gt;T1&lt;/em&gt; without a cast. (This treatment of interfaces follows the usage of the bytecode verifier.)</source>
          <target state="translated">如果&lt;em&gt;T0&lt;/em&gt;和&lt;em&gt;T1&lt;/em&gt;是引用，并且&lt;em&gt;T1&lt;/em&gt;是接口类型，则类型&lt;em&gt;T0&lt;/em&gt;的值将作为&lt;em&gt;T1&lt;/em&gt;传递而不进行强制转换。（接口的这种处理遵循字节码验证程序的使用。）</target>
        </trans-unit>
        <trans-unit id="79aeb4d5dd8cb350db9c0c092dba6e42f02a5549" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are references, then a cast to &lt;em&gt;T1&lt;/em&gt; is applied. (The types do not need to be related in any particular way. This is because a dynamic value of null can convert to any reference type.)</source>
          <target state="translated">如果&lt;em&gt;T0&lt;/em&gt;和&lt;em&gt;T1&lt;/em&gt;是引用，则对&lt;em&gt;T1&lt;/em&gt;进行强制转换。（不需要以任何特定方式关联类型。这是因为动态值null可以转换为任何引用类型。）</target>
        </trans-unit>
        <trans-unit id="4afc8d053d3eb053b07d58aea74885c54772acb0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; is a primitive and &lt;em&gt;T1&lt;/em&gt; a reference, a Java casting conversion (JLS 5.5) is applied if one exists. (Specifically, the value is boxed from &lt;em&gt;T0&lt;/em&gt; to its wrapper class, which is then widened as needed to &lt;em&gt;T1&lt;/em&gt;.)</source>
          <target state="translated">如果&lt;em&gt;T0&lt;/em&gt;是基元，&lt;em&gt;T1&lt;/em&gt;是引用，那么如果存在Java转换（JLS 5.5），则将其应用。（具体来说，该值从&lt;em&gt;T0&lt;/em&gt;装箱到其包装器类，然后根据需要扩展到&lt;em&gt;T1&lt;/em&gt;。）</target>
        </trans-unit>
        <trans-unit id="f9f655a906d4defe08e1ec4ccc11021ab6bc8df7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing conversion will be applied at runtime, possibly followed by a Java casting conversion (JLS 5.5) on the primitive value, possibly followed by a conversion from byte to boolean by testing the low-order bit.</source>
          <target state="translated">如果&lt;em&gt;T0&lt;/em&gt;是引用，而&lt;em&gt;T1&lt;/em&gt;是基元，则将在运行时应用拆箱转换，可能在基元值后进行Java转换（JLS 5.5），还可能通过测试低阶从字节到布尔的转换一点。</target>
        </trans-unit>
        <trans-unit id="db644feaac62822a15a472df6abb94d10f3b2937" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing conversion will be applied at runtime, possibly followed by a Java method invocation conversion (JLS 5.3) on the primitive value. (These are the primitive widening conversions.) &lt;em&gt;T0&lt;/em&gt; must be a wrapper class or a supertype of one. (In the case where &lt;em&gt;T0&lt;/em&gt; is Object, these are the conversions allowed by &lt;a href=&quot;../reflect/method#invoke(java.lang.Object,java.lang.Object...)&quot;&gt;&lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt;&lt;/a&gt;.) The unboxing conversion must have a possibility of success, which means that if &lt;em&gt;T0&lt;/em&gt; is not itself a wrapper class, there must exist at least one wrapper class &lt;em&gt;TW&lt;/em&gt; which is a subtype of &lt;em&gt;T0&lt;/em&gt; and whose unboxed primitive value can be widened to &lt;em&gt;T1&lt;/em&gt;.</source>
          <target state="translated">如果&lt;em&gt;T0&lt;/em&gt;是引用，&lt;em&gt;T1&lt;/em&gt;是基元，则将在运行时应用拆箱转换，可能在基元值上执行Java方法调用转换（JLS 5.3）。（这些是原始的扩展转换。）&lt;em&gt;T0&lt;/em&gt;必须是包装类或类的超类型。（在&lt;em&gt;T0&lt;/em&gt;是Object的情况下，这些是&lt;a href=&quot;../reflect/method#invoke(java.lang.Object,java.lang.Object...)&quot;&gt; &lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt; &lt;/a&gt;允许的转换。）拆箱转换必须具有成功的可能性，这意味着如果&lt;em&gt;T0&lt;/em&gt;本身不是包装器类，则必须存在至少一个包装器类&lt;em&gt;TW&lt;/em&gt;，它是&lt;em&gt;T0&lt;/em&gt;的子类型，并且其未装箱的原始值可以扩展为&lt;em&gt;T1&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="5e7880911e2e6fcd9ad74806ba0070443b27d0e7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing conversion will be applied at runtime, possibly followed by a Java method invocation conversion (JLS 5.3) on the primitive value. (These are the primitive widening conversions.) &lt;em&gt;T0&lt;/em&gt; must be a wrapper class or a supertype of one. (In the case where &lt;em&gt;T0&lt;/em&gt; is Object, these are the conversions allowed by &lt;a href=&quot;../reflect/method#invoke-java.lang.Object-java.lang.Object...-&quot;&gt;&lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt;&lt;/a&gt;.) The unboxing conversion must have a possibility of success, which means that if &lt;em&gt;T0&lt;/em&gt; is not itself a wrapper class, there must exist at least one wrapper class &lt;em&gt;TW&lt;/em&gt; which is a subtype of &lt;em&gt;T0&lt;/em&gt; and whose unboxed primitive value can be widened to &lt;em&gt;T1&lt;/em&gt;.</source>
          <target state="translated">如果&lt;em&gt;T0&lt;/em&gt;是引用，&lt;em&gt;T1&lt;/em&gt;是基元，则将在运行时应用拆箱转换，可能在基元值上进行Java方法调用转换（JLS 5.3）。（这些是原始的扩展转换。）&lt;em&gt;T0&lt;/em&gt;必须是包装类或类的超类型。（在&lt;em&gt;T0&lt;/em&gt;为Object 的情况下，这些是&lt;a href=&quot;../reflect/method#invoke-java.lang.Object-java.lang.Object...-&quot;&gt; &lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt; &lt;/a&gt;允许的转换。）拆箱转换必须具有成功的可能性，这意味着如果&lt;em&gt;T0&lt;/em&gt;本身不是包装器类，则必须存在至少一个包装器类&lt;em&gt;TW&lt;/em&gt;，它是&lt;em&gt;T0&lt;/em&gt;的子类型，并且其未装箱的原始值可以扩展为&lt;em&gt;T1&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="8960999c2c149641fb63da1b8b2e73d16c83837a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, and if the reference is null at runtime, a zero value is introduced.</source>
          <target state="translated">如果&lt;em&gt;T0&lt;/em&gt;是引用，&lt;em&gt;T1&lt;/em&gt;是基元，并且如果引用在运行时为null，则将引入零值。</target>
        </trans-unit>
        <trans-unit id="c411b97d9273d8806592b1669554d07cf4ebec56" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T0&lt;/em&gt; is boolean and &lt;em&gt;T1&lt;/em&gt; is another primitive, the boolean is converted to a byte value, 1 for true, 0 for false. (This treatment follows the usage of the bytecode verifier.)</source>
          <target state="translated">如果&lt;em&gt;T0&lt;/em&gt;是布尔值且&lt;em&gt;T1&lt;/em&gt;是另一个原语，则布尔值将转换为字节值，1表示true，0表示false。（此处理遵循字节码验证程序的使用。）</target>
        </trans-unit>
        <trans-unit id="11dcb0b6d39107c41f9d02034203e755a22bc31f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T1&lt;/em&gt; is boolean and &lt;em&gt;T0&lt;/em&gt; is another primitive, &lt;em&gt;T0&lt;/em&gt; is converted to byte via Java casting conversion (JLS 5.5), and the low order bit of the result is tested, as if by &lt;code&gt;(x &amp;amp; 1) != 0&lt;/code&gt;.</source>
          <target state="translated">如果&lt;em&gt;T1&lt;/em&gt;为布尔值且&lt;em&gt;T0&lt;/em&gt;为另一个原语，则&lt;em&gt;T0&lt;/em&gt;通过Java转换转换（JLS 5.5）转换为字节，并测试结果的低位，就像 &lt;code&gt;(x &amp;amp; 1) != 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e03b8b722d047ebd8ff3f27197eddd18529d96a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T&lt;/em&gt; is a non-generic non-array type, &lt;em&gt;genericstring(T)&lt;/em&gt; is the value returned by &lt;a href=&quot;../../../java.base/java/lang/class#getName()&quot;&gt;&lt;code&gt;Class.getName()&lt;/code&gt;&lt;/a&gt;, for example &lt;code&gt;&quot;int&quot;&lt;/code&gt; or &lt;code&gt;
      &quot;java.lang.String&quot;&lt;/code&gt;.</source>
          <target state="translated">如果&lt;em&gt;T&lt;/em&gt;是非通用非数组类型，则&lt;em&gt;genericstring（T）&lt;/em&gt;是&lt;a href=&quot;../../../java.base/java/lang/class#getName()&quot;&gt; &lt;code&gt;Class.getName()&lt;/code&gt; &lt;/a&gt;返回的值，例如 &lt;code&gt;&quot;int&quot;&lt;/code&gt; 或 &lt;code&gt; &quot;java.lang.String&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fd2145f2a73182fb43d09ea345dee1a6c4c8988" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T&lt;/em&gt; is a non-generic non-array type, &lt;em&gt;genericstring(T)&lt;/em&gt; is the value returned by &lt;a href=&quot;../../java/lang/class#getName--&quot;&gt;&lt;code&gt;Class.getName()&lt;/code&gt;&lt;/a&gt;, for example &lt;code&gt;&quot;int&quot;&lt;/code&gt; or &lt;code&gt;&quot;java.lang.String&quot;&lt;/code&gt;.</source>
          <target state="translated">如果&lt;em&gt;T&lt;/em&gt;是非通用非数组类型，则&lt;em&gt;genericstring（T）&lt;/em&gt;是&lt;a href=&quot;../../java/lang/class#getName--&quot;&gt; &lt;code&gt;Class.getName()&lt;/code&gt; &lt;/a&gt;返回的值，例如 &lt;code&gt;&quot;int&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;java.lang.String&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="860ba81ee558617e504db9f36e3c29f31a880b19" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T&lt;/em&gt; is an array &lt;em&gt;E[]&lt;/em&gt;, &lt;em&gt;genericstring(T)&lt;/em&gt; is &lt;em&gt;genericstring(E)&lt;/em&gt; followed by &lt;code&gt;&quot;[]&quot;&lt;/code&gt;. For example, &lt;em&gt;genericstring(&lt;code&gt;int[]&lt;/code&gt;)&lt;/em&gt; is &lt;code&gt;&quot;int[]&quot;&lt;/code&gt;, and &lt;em&gt;genericstring(&lt;code&gt;
      List&amp;lt;String&amp;gt;[][]&lt;/code&gt;)&lt;/em&gt; is &lt;code&gt;
      &quot;java.util.List&amp;lt;java.lang.String&amp;gt;[][]&quot;&lt;/code&gt;.</source>
          <target state="translated">如果&lt;em&gt;T&lt;/em&gt;是数组&lt;em&gt;E []&lt;/em&gt;，则&lt;em&gt;genericstring（T）&lt;/em&gt;是&lt;em&gt;genericstring（E），&lt;/em&gt;后跟 &lt;code&gt;&quot;[]&quot;&lt;/code&gt; 。例如，&lt;em&gt;genericstring（ &lt;code&gt;int[]&lt;/code&gt; ）&lt;/em&gt;是 &lt;code&gt;&quot;int[]&quot;&lt;/code&gt; ，&lt;em&gt;genericstring（ &lt;code&gt; List&amp;lt;String&amp;gt;[][]&lt;/code&gt; ）&lt;/em&gt;是 &lt;code&gt; &quot;java.util.List&amp;lt;java.lang.String&amp;gt;[][]&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fc604f0af1a190516ca2a3a164921e85df65901" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;T&lt;/em&gt; is an array &lt;em&gt;E[]&lt;/em&gt;, &lt;em&gt;genericstring(T)&lt;/em&gt; is &lt;em&gt;genericstring(E)&lt;/em&gt; followed by &lt;code&gt;&quot;[]&quot;&lt;/code&gt;. For example, &lt;em&gt;genericstring(&lt;code&gt;int[]&lt;/code&gt;)&lt;/em&gt; is &lt;code&gt;&quot;int[]&quot;&lt;/code&gt;, and &lt;em&gt;genericstring(&lt;code&gt;List&amp;lt;String&amp;gt;[][]&lt;/code&gt;)&lt;/em&gt; is &lt;code&gt;&quot;java.util.List&amp;lt;java.lang.String&amp;gt;[][]&quot;&lt;/code&gt;.</source>
          <target state="translated">如果&lt;em&gt;T&lt;/em&gt;是数组&lt;em&gt;E []&lt;/em&gt;，则&lt;em&gt;genericstring（T）&lt;/em&gt;是&lt;em&gt;genericstring（E），&lt;/em&gt;后跟 &lt;code&gt;&quot;[]&quot;&lt;/code&gt; 。例如，&lt;em&gt;genericstring（ &lt;code&gt;int[]&lt;/code&gt; ）&lt;/em&gt;是 &lt;code&gt;&quot;int[]&quot;&lt;/code&gt; ，&lt;em&gt;genericstring（ &lt;code&gt;List&amp;lt;String&amp;gt;[][]&lt;/code&gt; ）&lt;/em&gt;是 &lt;code&gt;&quot;java.util.List&amp;lt;java.lang.String&amp;gt;[][]&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5ada396ebd42f6281b2f214e6a5eb260e1d65b4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;opendata(J)&lt;/em&gt; is &lt;code&gt;CompositeData&lt;/code&gt; for a Java type &lt;em&gt;J&lt;/em&gt;, then either an instance of &lt;em&gt;J&lt;/em&gt; can be reconstructed from a &lt;code&gt;CompositeData&lt;/code&gt;, or &lt;em&gt;J&lt;/em&gt; is not reconstructible. If any item in the &lt;code&gt;CompositeData&lt;/code&gt; is not reconstructible, then &lt;em&gt;J&lt;/em&gt; is not reconstructible either.</source>
          <target state="translated">如果&lt;em&gt;opendata（J）&lt;/em&gt;是Java类型&lt;em&gt;J的&lt;/em&gt; &lt;code&gt;CompositeData&lt;/code&gt; ，则可以从 &lt;code&gt;CompositeData&lt;/code&gt; 重构&lt;em&gt;J&lt;/em&gt;的实例，或者&lt;em&gt;J&lt;/em&gt;是不可重构的。如果 &lt;code&gt;CompositeData&lt;/code&gt; 中的任何一项都是不可重构的，那么&lt;em&gt;J&lt;/em&gt;也是不可重构的。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8262855ebc180b3d6778bf226e7f53f50f72af47" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt;, then let &lt;code&gt;ct&lt;/code&gt; be its &lt;code&gt;CompositeType&lt;/code&gt; as returned by &lt;a href=&quot;compositedata#getCompositeType()&quot;&gt;&lt;code&gt;CompositeData.getCompositeType()&lt;/code&gt;&lt;/a&gt;. The result is true if &lt;code&gt;this&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt;&lt;code&gt;ct&lt;/code&gt;. This means that:</source>
          <target state="translated">如果 &lt;var&gt;obj&lt;/var&gt; 是实例 &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt; 中，然后让 &lt;code&gt;ct&lt;/code&gt; 是它 &lt;code&gt;CompositeType&lt;/code&gt; 通过返回的&lt;a href=&quot;compositedata#getCompositeType()&quot;&gt; &lt;code&gt;CompositeData.getCompositeType()&lt;/code&gt; &lt;/a&gt;。如果结果为真 &lt;code&gt;this&lt;/code&gt; 是&lt;em&gt;从分配&lt;/em&gt; &lt;code&gt;ct&lt;/code&gt; 。这意味着：</target>
        </trans-unit>
        <trans-unit id="55e80b82ba0e613e2bb9e96436b7f7884b762e6f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt;, then let &lt;code&gt;ct&lt;/code&gt; be its &lt;code&gt;CompositeType&lt;/code&gt; as returned by &lt;a href=&quot;compositedata#getCompositeType--&quot;&gt;&lt;code&gt;CompositeData.getCompositeType()&lt;/code&gt;&lt;/a&gt;. The result is true if &lt;code&gt;this&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt;&lt;code&gt;ct&lt;/code&gt;. This means that:</source>
          <target state="translated">如果 &lt;var&gt;obj&lt;/var&gt; 是实例 &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt; 中，然后让 &lt;code&gt;ct&lt;/code&gt; 是它 &lt;code&gt;CompositeType&lt;/code&gt; 通过返回的&lt;a href=&quot;compositedata#getCompositeType--&quot;&gt; &lt;code&gt;CompositeData.getCompositeType()&lt;/code&gt; &lt;/a&gt;。如果结果为真 &lt;code&gt;this&lt;/code&gt; 是&lt;em&gt;从分配&lt;/em&gt; &lt;code&gt;ct&lt;/code&gt; 。这意味着：</target>
        </trans-unit>
        <trans-unit id="e4299f574b0825744c73fc58489cb793e0aeb31f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt;, say &lt;code&gt;
 td&lt;/code&gt;, the result is true if this &lt;code&gt;TabularType&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt;&lt;a href=&quot;tabulardata#getTabularType()&quot;&gt;&lt;code&gt;td.getTabularType()&lt;/code&gt;&lt;/a&gt;, as defined in &lt;a href=&quot;compositetype#isValue(java.lang.Object)&quot;&gt;&lt;code&gt;CompositeType.isValue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;var&gt;obj&lt;/var&gt; 是实例 &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt; 中，说 &lt;code&gt; td&lt;/code&gt; ，如果这样做的结果是真实的 &lt;code&gt;TabularType&lt;/code&gt; 是&lt;em&gt;分配从&lt;/em&gt;&lt;a href=&quot;tabulardata#getTabularType()&quot;&gt; &lt;code&gt;td.getTabularType()&lt;/code&gt; &lt;/a&gt;，中定义&lt;a href=&quot;compositetype#isValue(java.lang.Object)&quot;&gt; &lt;code&gt;CompositeType.isValue&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5b21be35113bc2c3c5695016e41e7a8961aa607" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt;, say &lt;code&gt;td&lt;/code&gt;, the result is true if this &lt;code&gt;TabularType&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt;&lt;a href=&quot;tabulardata#getTabularType--&quot;&gt;&lt;code&gt;td.getTabularType()&lt;/code&gt;&lt;/a&gt;, as defined in &lt;a href=&quot;compositetype#isValue-java.lang.Object-&quot;&gt;&lt;code&gt;CompositeType.isValue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;var&gt;obj&lt;/var&gt; 是实例 &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt; 中，说 &lt;code&gt;td&lt;/code&gt; ，如果这样做的结果是真实的 &lt;code&gt;TabularType&lt;/code&gt; 是&lt;em&gt;分配从&lt;/em&gt;&lt;a href=&quot;tabulardata#getTabularType--&quot;&gt; &lt;code&gt;td.getTabularType()&lt;/code&gt; &lt;/a&gt;，中定义&lt;a href=&quot;compositetype#isValue-java.lang.Object-&quot;&gt; &lt;code&gt;CompositeType.isValue&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2bc555f2367ab62f427bf89fb970ff34e2a7eac" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is null or is not an instance of &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt;, &lt;code&gt;isValue&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;var&gt;obj&lt;/var&gt; 为null或不是 &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt; 的实例，则 &lt;code&gt;isValue&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7fca7400d753ab2ac94fb4572ae69584ddad617" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is null or is not an instance of &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt;, &lt;code&gt;isValue&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;var&gt;obj&lt;/var&gt; 为null或不是 &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt; 的实例，则 &lt;code&gt;isValue&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ee964581c68796c9de47e0f9fcc18bb6c0cdfe3" translate="yes" xml:space="preserve">
          <source>If B 'requires transitive' C, then A &quot;reads&quot; C as well as B. This augmentation is recursive: since A &quot;reads&quot; C, if C 'requires transitive' D, then A &quot;reads&quot; D as well as C and B.</source>
          <target state="translated">如果B'需要转折'C,那么A既 &quot;读 &quot;C,也 &quot;读 &quot;B,这种增强是递归的:因为A &quot;读 &quot;C,如果C &quot;需要转折 &quot;D,那么A既 &quot;读 &quot;D,也读C和B。</target>
        </trans-unit>
        <trans-unit id="217ddf9447b9b7371675e7e32d2dda97e83ca937" translate="yes" xml:space="preserve">
          <source>If B is an automatic module, then A &quot;reads&quot; every other enumerated automatic module. (It is &quot;as if&quot; an automatic module has 'requires transitive' directives for every other enumerated automatic module).</source>
          <target state="translated">如果B是一个自动模块,那么A就会 &quot;读取 &quot;每一个其他列举的自动模块。(这 &quot;就好像 &quot;一个自动模块对每一个其他列举的自动模块都有 &quot;需要转式 &quot;指令一样)。</target>
        </trans-unit>
        <trans-unit id="f6eb29fd93b0c765afc3bd3b512f90a195dcbb2f" translate="yes" xml:space="preserve">
          <source>If BeanContext parameter is null, then it shall associate the Applet with its appropriate Container by adding that Applet to its Container via an invocation of add(). If the BeanContext parameter is non-null, then it is the responsibility of the BeanContext to associate the Applet with its Container during the subsequent invocation of its addChildren() method.</source>
          <target state="translated">如果BeanContext参数为空,那么它应通过调用add()将Applet添加到它的Container中,从而将Applet与相应的Container关联起来。如果BeanContext参数为非空,那么BeanContext有责任在随后调用addChildren()方法时将Applet与它的Container关联起来。</target>
        </trans-unit>
        <trans-unit id="b3801f11fd37bcce7f8fba639fe8d4ee887aad7e" translate="yes" xml:space="preserve">
          <source>If C declares a public field with the name specified, that is the field to be reflected.</source>
          <target state="translated">如果C声明了一个指定名称的公共字段,那就是要反映的字段。</target>
        </trans-unit>
        <trans-unit id="e74b12226ef970b004e90369d97d9ef001f09d83" translate="yes" xml:space="preserve">
          <source>If C is a class other than &lt;code&gt;Object&lt;/code&gt;, then include the result of invoking this algorithm recursively on the superclass of C.</source>
          <target state="translated">如果C是 &lt;code&gt;Object&lt;/code&gt; 以外的其他类，则在C的超类上包括递归调用此算法的结果。</target>
        </trans-unit>
        <trans-unit id="ca26ee5702ced758c636159001396b48df22d8a6" translate="yes" xml:space="preserve">
          <source>If C is a class other than &lt;code&gt;Object&lt;/code&gt;, then this algorithm is invoked recursively on the superclass of C.</source>
          <target state="translated">如果C是 &lt;code&gt;Object&lt;/code&gt; 以外的其他类，则在C的超类上递归调用此算法。</target>
        </trans-unit>
        <trans-unit id="5e9b9649ab976d62198d1ec3dfed66527d11d467" translate="yes" xml:space="preserve">
          <source>If C is the class &lt;code&gt;Object&lt;/code&gt;, or if C is an interface, then the superinterfaces of C (if any) are searched for a matching method. If any such method is found, it is reflected.</source>
          <target state="translated">如果C是 &lt;code&gt;Object&lt;/code&gt; 类，或者C是接口，则在C的超接口（如果有）中搜索匹配方法。如果找到任何这样的方法，则将其反映出来。</target>
        </trans-unit>
        <trans-unit id="2d85abeeeb1aa21f2267ac0f2f921e008ecb6b5d" translate="yes" xml:space="preserve">
          <source>If CPU time measurement is enabled after the thread has started, the Java virtual machine implementation may choose any time up to and including the time that the capability is enabled as the point where CPU time measurement starts.</source>
          <target state="translated">如果在线程启动后启用了CPU时间测量,Java虚拟机实现可以选择任何时间(包括启用该功能的时间)作为CPU时间测量的起始点。</target>
        </trans-unit>
        <trans-unit id="96b2e184e73a9f507b63cab71f6b6a0fc51255aa" translate="yes" xml:space="preserve">
          <source>If CredentialClass is &quot;*&quot;, then access is granted to all private Credentials belonging to the specified &lt;code&gt;Subject&lt;/code&gt;. If &quot;PrincipalName&quot; is &quot;*&quot;, then access is granted to the specified Credential owned by any &lt;code&gt;Subject&lt;/code&gt; that has the specified &lt;code&gt;Principal&lt;/code&gt; (the actual PrincipalName doesn't matter). For example, the following grants access to the a.b.Credential owned by any &lt;code&gt;Subject&lt;/code&gt; that has an a.b.Principal.</source>
          <target state="translated">如果CredentialClass为&amp;ldquo; *&amp;rdquo;，那么将授予对属于指定 &lt;code&gt;Subject&lt;/code&gt; 的所有私有Credential的访问权限。如果&amp;ldquo; PrincipalName&amp;rdquo;为&amp;ldquo; *&amp;rdquo;，则将授予具有指定 &lt;code&gt;Principal&lt;/code&gt; 的任何 &lt;code&gt;Subject&lt;/code&gt; 拥有的指定凭据的访问权限（实际PrincipalName无关紧要）。例如，以下内容授予对具有abPrincipal的任何 &lt;code&gt;Subject&lt;/code&gt; 所拥有的abCredential的访问权限。</target>
        </trans-unit>
        <trans-unit id="a62e7a3eb9436a575105ab492afe79c76ff1b2cd" translate="yes" xml:space="preserve">
          <source>If Flight Recorder is already initialized when the listener is added, then the method &lt;a href=&quot;flightrecorderlistener#recorderInitialized(jdk.jfr.FlightRecorder)&quot;&gt;&lt;code&gt;FlightRecorderListener.recorderInitialized(FlightRecorder)&lt;/code&gt;&lt;/a&gt; method is invoked before returning from this method.</source>
          <target state="translated">如果添加侦听器时已经对Flight Recorder进行了初始化，则在&lt;a href=&quot;flightrecorderlistener#recorderInitialized(jdk.jfr.FlightRecorder)&quot;&gt; &lt;code&gt;FlightRecorderListener.recorderInitialized(FlightRecorder)&lt;/code&gt; &lt;/a&gt;方法返回之前，将调用FlightRecorderListener.recorderInitialized（FlightRecorder）方法。</target>
        </trans-unit>
        <trans-unit id="6a39eb1a01812d32c33a1ca34fe7c0a3f9fe824c" translate="yes" xml:space="preserve">
          <source>If January 1st is Friday then week 1 starts on January 4th</source>
          <target state="translated">如果1月1日是星期五,那么第一周就从1月4日开始。</target>
        </trans-unit>
        <trans-unit id="8212bef3cde7fd918667a428a4beb2926b2aaf30" translate="yes" xml:space="preserve">
          <source>If January 1st is Monday then week 1 starts on January 1st</source>
          <target state="translated">如果1月1日是星期一,那么第一周就从1月1日开始。</target>
        </trans-unit>
        <trans-unit id="4e1d8c7e06d2ed477961cc6b9bf02767f72d2e8e" translate="yes" xml:space="preserve">
          <source>If January 1st is Saturday then week 1 starts on January 3rd</source>
          <target state="translated">如果1月1日是星期六,那么第一周从1月3日开始。</target>
        </trans-unit>
        <trans-unit id="93384845075a732cc09f28c1fdb3a1493434370f" translate="yes" xml:space="preserve">
          <source>If January 1st is Sunday then week 1 starts on January 2nd</source>
          <target state="translated">如果1月1日是周日,那么第一周从1月2日开始。</target>
        </trans-unit>
        <trans-unit id="d773a45b8b76332ac1c9cf30d6d26cbed25b1ef6" translate="yes" xml:space="preserve">
          <source>If January 1st is Thursday then week 1 starts on December 29th of the previous standard year</source>
          <target state="translated">如果1月1日是星期四,那么第一周就从上一个标准年的12月29日开始。</target>
        </trans-unit>
        <trans-unit id="dff679f893694acfcb5844ad440b7fd91f379885" translate="yes" xml:space="preserve">
          <source>If January 1st is Tuesday then week 1 starts on December 31st of the previous standard year</source>
          <target state="translated">如果1月1日是星期二,那么第一周就从上一个标准年的12月31日开始。</target>
        </trans-unit>
        <trans-unit id="3b4487b7e39c0d7129e69d67e0df2749862989ef" translate="yes" xml:space="preserve">
          <source>If January 1st is Wednesday then week 1 starts on December 30th of the previous standard year</source>
          <target state="translated">如果1月1日是周三,那么第一周就从上一个标准年的12月30日开始。</target>
        </trans-unit>
        <trans-unit id="f38e0c7c32dd408bc04c87c04c2100fa3feb4c90" translate="yes" xml:space="preserve">
          <source>If N equals &lt;code&gt;className&lt;/code&gt;, the result is true.</source>
          <target state="translated">如果N等于 &lt;code&gt;className&lt;/code&gt; ，则结果为true。</target>
        </trans-unit>
        <trans-unit id="0ba990b0a52d90609129011e460cfce22958559a" translate="yes" xml:space="preserve">
          <source>If Q is not a primitive wrapper, cast Q to the base Wrapper(S); for example Number for numeric types</source>
          <target state="translated">如果 Q 不是基元包装器,则将 Q 投放到基元 Wrapper(S)上;例如数字类型的 Number</target>
        </trans-unit>
        <trans-unit id="703cac5535402dfbacd6e10480e5c86732963b2a" translate="yes" xml:space="preserve">
          <source>If SQL distinct or structured types are supported, then information on the individual types may be obtained from the getUDTs() method.</source>
          <target state="translated">如果支持SQL独特类型或结构化类型,那么可以从getUDTs()方法中获取各个类型的信息。</target>
        </trans-unit>
        <trans-unit id="b161924f4e548ad87c34d6fc35e9d529b38669ec" translate="yes" xml:space="preserve">
          <source>If TMFAIL is specified, the portion of work has failed. The resource manager may mark the transaction as rollback-only</source>
          <target state="translated">如果指定了TMFAIL,则表示该部分工作失败。资源管理人可以将事务标记为仅回滚的事务</target>
        </trans-unit>
        <trans-unit id="34e620dd9f663543c0cd6de489c85fce57f1d753" translate="yes" xml:space="preserve">
          <source>If TMSUCCESS is specified, the portion of work has completed successfully.</source>
          <target state="translated">如果指定了TMSUCCESS,则说明该部分工作已经成功完成。</target>
        </trans-unit>
        <trans-unit id="666f46da82bcae259e1d59dba9446d046eb56729" translate="yes" xml:space="preserve">
          <source>If TMSUSPEND is specified in the flags, the transaction branch is temporarily suspended in an incomplete state. The transaction context is in a suspended state and must be resumed via the &lt;code&gt;start&lt;/code&gt; method with TMRESUME specified.</source>
          <target state="translated">如果在标志中指定了TMSUSPEND，则事务分支将以不完整状态暂时挂起。事务上下文处于挂起状态，必须通过指定了TMRESUME的 &lt;code&gt;start&lt;/code&gt; 方法来恢复。</target>
        </trans-unit>
        <trans-unit id="d4e43d0787d6a1f0ea103acb6274a424055f2393" translate="yes" xml:space="preserve">
          <source>If UDP socket is used, TCP/IP related socket options will not apply.</source>
          <target state="translated">如果使用UDP套接字,TCP/IP相关套接字选项将不适用。</target>
        </trans-unit>
        <trans-unit id="d35b5e2d84fd7cadfe9d220ae2dd518e06e9f2d7" translate="yes" xml:space="preserve">
          <source>If XInclude markup is found in the document instance, should it be processed as specified in &lt;a href=&quot;http://www.w3.org/TR/xinclude/&quot;&gt; XML Inclusions (XInclude) Version 1.0&lt;/a&gt;.</source>
          <target state="translated">如果在文档实例中找到XInclude标记，则应按照&lt;a href=&quot;http://www.w3.org/TR/xinclude/&quot;&gt;XML包含（XInclude）版本1.0中的&lt;/a&gt;指定进行处理。</target>
        </trans-unit>
        <trans-unit id="44f2e533c81b55c008b79c7820101bd6e4826567" translate="yes" xml:space="preserve">
          <source>If XInclude markup is found in the document instance, should it be processed as specified in &lt;a href=&quot;https://www.w3.org/TR/xinclude/&quot;&gt; XML Inclusions (XInclude) Version 1.0&lt;/a&gt;.</source>
          <target state="translated">如果在文档实例中找到XInclude标记，则应按照&lt;a href=&quot;https://www.w3.org/TR/xinclude/&quot;&gt;XML包含（XInclude）版本1.0中的&lt;/a&gt;指定进行处理。</target>
        </trans-unit>
        <trans-unit id="cf93dc358d8e904b576e25277f8f25bb773404f0" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt; throws a &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; (or instances of its derived classes), then the &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; will abort the parsing and the caller of the &lt;code&gt;newSchema&lt;/code&gt; method will receive the same &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; &lt;/a&gt;抛出&lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;（或其派生类的实例），则&lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; &lt;/a&gt;将中止解析，并且 &lt;code&gt;newSchema&lt;/code&gt; 方法的调用者将收到相同的&lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d758c373d5c33100c18bb64f511e7cfa9ca774b0" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt; throws a &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; (or instances of its derived classes), then the &lt;a href=&quot;validator&quot;&gt;&lt;code&gt;Validator&lt;/code&gt;&lt;/a&gt; will abort the parsing and the caller of the &lt;code&gt;validate&lt;/code&gt; method will receive the same &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; &lt;/a&gt;抛出&lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;（或其派生类的实例），则&lt;a href=&quot;validator&quot;&gt; &lt;code&gt;Validator&lt;/code&gt; &lt;/a&gt;将中止解析，并且 &lt;code&gt;validate&lt;/code&gt; 方法的调用者将收到相同的&lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ff99926f4a6706109dc64ddd976098f7dbb7eca" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt; throws a &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; (or instances of its derived classes), then the &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; will abort the parsing and the caller of the &lt;code&gt;validate&lt;/code&gt; method will receive the same &lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; &lt;/a&gt;抛出&lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;（或其派生类的实例），则&lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt;将中止解析，并且 &lt;code&gt;validate&lt;/code&gt; 方法的调用者将收到相同的&lt;a href=&quot;../../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e9892804baed9af42e82a13b8ef76149b94c399" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../lang/securitymanager&quot;&gt;&lt;code&gt;SecurityManager&lt;/code&gt;&lt;/a&gt; is present and no factory is specified, then the default pool uses a factory supplying threads that have no &lt;a href=&quot;../../security/permissions&quot;&gt;&lt;code&gt;Permissions&lt;/code&gt;&lt;/a&gt; enabled. The system class loader is used to load these classes. Upon any error in establishing these settings, default parameters are used. It is possible to disable or limit the use of threads in the common pool by setting the parallelism property to zero, and/or using a factory that may return &lt;code&gt;null&lt;/code&gt;. However doing so may cause unjoined tasks to never be executed.</source>
          <target state="translated">如果存在&lt;a href=&quot;../../lang/securitymanager&quot;&gt; &lt;code&gt;SecurityManager&lt;/code&gt; &lt;/a&gt;且未指定工厂，则默认池将使用工厂提供未启用&lt;a href=&quot;../../security/permissions&quot;&gt; &lt;code&gt;Permissions&lt;/code&gt; &lt;/a&gt;线程。系统类加载器用于加载这些类。在建立这些设置时发生任何错误时，将使用默认参数。通过将parallelism属性设置为零和/或使用可能返回 &lt;code&gt;null&lt;/code&gt; 的工厂，可以禁用或限制公共池中线程的使用。但是，这样做可能导致未执行的任务永远不会执行。</target>
        </trans-unit>
        <trans-unit id="f56cfbf9c11a3bf93497432039e845c2caa01626" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&quot;..&quot;&lt;/code&gt; segment is preceded by a non-&lt;code&gt;&quot;..&quot;&lt;/code&gt; segment then both of these segments are removed. This step is repeated until it is no longer applicable.</source>
          <target state="translated">如果 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 段之前是非 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 段，则将这两个段都删除。重复此步骤，直到不再适用。</target>
        </trans-unit>
        <trans-unit id="f4a595fa88f9f83de3f8fcc49ca39b0b97a48f5f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;CONCURRENT&lt;/code&gt; collector is not also &lt;code&gt;UNORDERED&lt;/code&gt;, then it should only be evaluated concurrently if applied to an unordered data source.</source>
          <target state="translated">如果 &lt;code&gt;CONCURRENT&lt;/code&gt; 收集器也不是 &lt;code&gt;UNORDERED&lt;/code&gt; ，则仅当将其应用于无序数据源时，才应同时评估它。</target>
        </trans-unit>
        <trans-unit id="889b6a11619fbd0768ef25d463af6d6d1eb26b68" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;CachedRowSet&lt;/code&gt; object becomes part of a &lt;code&gt;JoinRowSet&lt;/code&gt; object, the keys defined by this method and the resulting constraints are maintained if the columns designated as key columns also become match columns.</source>
          <target state="translated">如果 &lt;code&gt;CachedRowSet&lt;/code&gt; 对象成为 &lt;code&gt;JoinRowSet&lt;/code&gt; 对象的一部分，则当指定为键列的列也变为匹配列时，将维护此方法定义的键和所产生的约束。</target>
        </trans-unit>
        <trans-unit id="023e1ebdfb712240675bc329abb0aeba8c03fd80" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Comparator&lt;/code&gt; has been specified for the column by the &lt;code&gt;setComparator&lt;/code&gt; method, use it.</source>
          <target state="translated">如果通过 &lt;code&gt;setComparator&lt;/code&gt; 方法为该列指定了 &lt;code&gt;Comparator&lt;/code&gt; ，请使用它。</target>
        </trans-unit>
        <trans-unit id="87a0262c290ea66e1e4a3ee02285d9a618034184" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DataLine&lt;/code&gt; is requested, and &lt;code&gt;info&lt;/code&gt; is an instance of &lt;code&gt;DataLine.Info&lt;/code&gt; specifying at least one fully qualified audio format, the last one will be used as the default format of the returned &lt;code&gt;DataLine&lt;/code&gt;.</source>
          <target state="translated">如果请求了 &lt;code&gt;DataLine&lt;/code&gt; ，并且 &lt;code&gt;info&lt;/code&gt; 是 &lt;code&gt;DataLine.Info&lt;/code&gt; 的实例，它指定至少一种完全限定的音频格式，则最后一种将用作返回的 &lt;code&gt;DataLine&lt;/code&gt; 的默认格式。</target>
        </trans-unit>
        <trans-unit id="822fd67bb76ff6305db4ff466cd709d70f4144a8" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DriverAction&lt;/code&gt; instance was specified when the JDBC driver was registered, its deregister method will be called prior to the driver being removed from the list of registered drivers.</source>
          <target state="translated">如果在注册JDBC驱动程序时指定了 &lt;code&gt;DriverAction&lt;/code&gt; 实例，则将在从已注册驱动程序列表中删除该驱动程序之前调用其deregister方法。</target>
        </trans-unit>
        <trans-unit id="0307105d00c9e2e53f227a7583fda0f66d0bdfee" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;FilteredRowSet&lt;/code&gt; implementation is shared using the inherited &lt;code&gt;createShared&lt;/code&gt; method in parent interfaces, the &lt;code&gt;Predicate&lt;/code&gt; should be shared without modification by all &lt;code&gt;FilteredRowSet&lt;/code&gt; instance clones.</source>
          <target state="translated">如果在父接口中使用继承的 &lt;code&gt;createShared&lt;/code&gt; 方法共享了 &lt;code&gt;FilteredRowSet&lt;/code&gt; 实现，则所有 &lt;code&gt;FilteredRowSet&lt;/code&gt; 实例克隆都应共享 &lt;code&gt;Predicate&lt;/code&gt; 而不进行任何修改。</target>
        </trans-unit>
        <trans-unit id="738e1b86e8d51219176a3aef7355506e4b762fc6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;JButton&lt;/code&gt; is being added, it is initially set to be disabled.</source>
          <target state="translated">如果要添加 &lt;code&gt;JButton&lt;/code&gt; ，则最初将其设置为禁用。</target>
        </trans-unit>
        <trans-unit id="baa9e0dcc52392fc3cfab576edd859e0065fab5d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;JMenuBar&lt;/code&gt; component is set on the &lt;code&gt;JRootPane&lt;/code&gt;, it is positioned along the upper edge of the frame. The &lt;code&gt;contentPane&lt;/code&gt; is adjusted in location and size to fill the remaining area. (The &lt;code&gt;JMenuBar&lt;/code&gt; and the &lt;code&gt;contentPane&lt;/code&gt; are added to the &lt;code&gt;layeredPane&lt;/code&gt; component at the &lt;code&gt;JLayeredPane.FRAME_CONTENT_LAYER&lt;/code&gt; layer.)</source>
          <target state="translated">如果在 &lt;code&gt;JRootPane&lt;/code&gt; 上设置了 &lt;code&gt;JMenuBar&lt;/code&gt; 组件，则该组件沿框架的上边缘放置。该 &lt;code&gt;contentPane&lt;/code&gt; 的是位置和大小调整，以填充剩余的区域。（将 &lt;code&gt;JMenuBar&lt;/code&gt; 和 &lt;code&gt;contentPane&lt;/code&gt; 添加到 &lt;code&gt;JLayeredPane.FRAME_CONTENT_LAYER&lt;/code&gt; 层的 &lt;code&gt;layeredPane&lt;/code&gt; 组件。）</target>
        </trans-unit>
        <trans-unit id="1d76683d65c14154863276b53c328991a5b273fb" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;JOptionPane&lt;/code&gt; has configured to all input &lt;code&gt;setWantsInput&lt;/code&gt; the bound property &lt;code&gt;JOptionPane.INPUT_VALUE_PROPERTY&lt;/code&gt; can also be listened to, to determine when the user has input or selected a value.</source>
          <target state="translated">如果 &lt;code&gt;JOptionPane&lt;/code&gt; 已配置为所有输入 &lt;code&gt;setWantsInput&lt;/code&gt; ，则还可以侦听绑定属性 &lt;code&gt;JOptionPane.INPUT_VALUE_PROPERTY&lt;/code&gt; ，以确定用户何时输入或选择了值。</target>
        </trans-unit>
        <trans-unit id="88dd2d3eceec11295d7042c434141f4e15854a11" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;JobPriority&lt;/code&gt; attribute is specified for a Print Job, it specifies a priority for scheduling the job. A higher value specifies a higher priority. The value 1 indicates the lowest possible priority. The value 100 indicates the highest possible priority. Among those jobs that are ready to print, a printer must print all jobs with a priority value of</source>
          <target state="translated">如果为&amp;ldquo;打印作业&amp;rdquo;指定了 &lt;code&gt;JobPriority&lt;/code&gt; 属性，则它指定用于调度作业的优先级。值越高，优先级越高。值1表示可能的最低优先级。值100表示​​可能的最高优先级。在准备打印的那些作业中，打印机必须打印优先级值为的所有作业。</target>
        </trans-unit>
        <trans-unit id="789dd14e5349e6a03d7591e97c806c5a4a9cec5f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;KeyTab&lt;/code&gt; object is obtained from &lt;a href=&quot;#getUnboundInstance()&quot;&gt;&lt;code&gt;getUnboundInstance()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#getUnboundInstance(java.io.File)&quot;&gt;&lt;code&gt;getUnboundInstance(java.io.File)&lt;/code&gt;&lt;/a&gt;, it is unbound and thus can be used by any service principal. Otherwise, if it's obtained from &lt;a href=&quot;#getInstance(javax.security.auth.kerberos.KerberosPrincipal)&quot;&gt;&lt;code&gt;getInstance(KerberosPrincipal)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#getInstance(javax.security.auth.kerberos.KerberosPrincipal,java.io.File)&quot;&gt;&lt;code&gt;getInstance(KerberosPrincipal, java.io.File)&lt;/code&gt;&lt;/a&gt;, it is bound to the specific service principal and can only be used by it.</source>
          <target state="translated">如果从&lt;a href=&quot;#getUnboundInstance()&quot;&gt; &lt;code&gt;getUnboundInstance()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#getUnboundInstance(java.io.File)&quot;&gt; &lt;code&gt;getUnboundInstance(java.io.File)&lt;/code&gt; &lt;/a&gt;获得 &lt;code&gt;KeyTab&lt;/code&gt; 对象，则该对象是未绑定的，因此可以由任何服务主体使用。否则，如果它是从&lt;a href=&quot;#getInstance(javax.security.auth.kerberos.KerberosPrincipal)&quot;&gt; &lt;code&gt;getInstance(KerberosPrincipal)&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#getInstance(javax.security.auth.kerberos.KerberosPrincipal,java.io.File)&quot;&gt; &lt;code&gt;getInstance(KerberosPrincipal, java.io.File)&lt;/code&gt; &lt;/a&gt;，则它将绑定到特定的服务主体，并且只能由它使用。</target>
        </trans-unit>
        <trans-unit id="96e5812f9668e1871b3f46e04c3c43773aa3cf41" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;KeyTab&lt;/code&gt; object is obtained from &lt;a href=&quot;keytab#getUnboundInstance--&quot;&gt;&lt;code&gt;getUnboundInstance()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keytab#getUnboundInstance-java.io.File-&quot;&gt;&lt;code&gt;getUnboundInstance(java.io.File)&lt;/code&gt;&lt;/a&gt;, it is unbound and thus can be used by any service principal. Otherwise, if it's obtained from &lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-&quot;&gt;&lt;code&gt;getInstance(KerberosPrincipal)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-java.io.File-&quot;&gt;&lt;code&gt;getInstance(KerberosPrincipal, java.io.File)&lt;/code&gt;&lt;/a&gt;, it is bound to the specific service principal and can only be used by it.</source>
          <target state="translated">如果从&lt;a href=&quot;keytab#getUnboundInstance--&quot;&gt; &lt;code&gt;getUnboundInstance()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;keytab#getUnboundInstance-java.io.File-&quot;&gt; &lt;code&gt;getUnboundInstance(java.io.File)&lt;/code&gt; &lt;/a&gt;获得 &lt;code&gt;KeyTab&lt;/code&gt; 对象，则该对象是未绑定的，因此可以由任何服务主体使用。否则，如果它是从&lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-&quot;&gt; &lt;code&gt;getInstance(KerberosPrincipal)&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-java.io.File-&quot;&gt; &lt;code&gt;getInstance(KerberosPrincipal, java.io.File)&lt;/code&gt; &lt;/a&gt;，则它将绑定到特定的服务主体，并且只能由它使用。</target>
        </trans-unit>
        <trans-unit id="b2450fb5c5add16e3fc12db422f9262f86c62d3c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Lookup&lt;/code&gt; on &lt;code&gt;LC&lt;/code&gt; in &lt;code&gt;M1&lt;/code&gt; has a previous lookup class &lt;code&gt;PLC&lt;/code&gt; on &lt;code&gt;M0&lt;/code&gt;, the lookup with &lt;a href=&quot;#PUBLIC&quot;&gt;&lt;code&gt;PUBLIC&lt;/code&gt;&lt;/a&gt; mode can access the intersection of all public types that are accessible to &lt;code&gt;M1&lt;/code&gt; with all public types that are accessible to &lt;code&gt;M0&lt;/code&gt;. &lt;code&gt;M0&lt;/code&gt; reads &lt;code&gt;M1&lt;/code&gt; and hence the set of accessible types includes:</source>
          <target state="translated">如果 &lt;code&gt;Lookup&lt;/code&gt; 的 &lt;code&gt;LC&lt;/code&gt; 在 &lt;code&gt;M1&lt;/code&gt; 具有以前的查找类 &lt;code&gt;PLC&lt;/code&gt; 上的 &lt;code&gt;M0&lt;/code&gt; ，与查找&lt;a href=&quot;#PUBLIC&quot;&gt; &lt;code&gt;PUBLIC&lt;/code&gt; &lt;/a&gt;模式可以访问所有公共类型，可访问的交集 &lt;code&gt;M1&lt;/code&gt; 与所有公共类型是可访问 &lt;code&gt;M0&lt;/code&gt; 。 &lt;code&gt;M0&lt;/code&gt; 读取 &lt;code&gt;M1&lt;/code&gt; ，因此可访问类型集包括：</target>
        </trans-unit>
        <trans-unit id="7d5b7a23be9db2dbf18af4ecce5e36c009a96a3d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Lookup&lt;/code&gt; on &lt;code&gt;LC&lt;/code&gt; in &lt;code&gt;M1&lt;/code&gt; has no previous lookup class, the lookup with &lt;a href=&quot;#PUBLIC&quot;&gt;&lt;code&gt;PUBLIC&lt;/code&gt;&lt;/a&gt; mode can access all public types in modules that are readable to &lt;code&gt;M1&lt;/code&gt; and the type is in a package that is exported at least to &lt;code&gt;M1&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Lookup&lt;/code&gt; 上 &lt;code&gt;LC&lt;/code&gt; 在 &lt;code&gt;M1&lt;/code&gt; 没有先前的查找类，与查找&lt;a href=&quot;#PUBLIC&quot;&gt; &lt;code&gt;PUBLIC&lt;/code&gt; &lt;/a&gt;模式可以访问所有公共类型中是可读至模块 &lt;code&gt;M1&lt;/code&gt; 和类型是在被导出的至少一个包 &lt;code&gt;M1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="169583703e821554fd005ef25ad00c1501c82436" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;MarshalException&lt;/code&gt; occurs during a remote method call, the call may or may not have reached the server. If the call did reach the server, parameters may have been deserialized. A call may not be retransmitted after a &lt;code&gt;MarshalException&lt;/code&gt; and reliably preserve &quot;at most once&quot; call semantics.</source>
          <target state="translated">如果在远程方法调用期间发生 &lt;code&gt;MarshalException&lt;/code&gt; ，则该调用可能到达或未到达服务器。如果呼叫确实到达服务器，则参数可能已反序列化。在 &lt;code&gt;MarshalException&lt;/code&gt; 之后，可能不会重新传输呼叫，并且可靠地保留&amp;ldquo;最多一次&amp;rdquo;的呼叫语义。</target>
        </trans-unit>
        <trans-unit id="7341cf2f876d3c7a46c61b0becb56d0668f2a5a7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;MaskFormatter&lt;/code&gt; is configured to only allow valid characters (&lt;code&gt;setAllowsInvalid(false)&lt;/code&gt;) literal characters will be skipped as necessary when editing. Consider a &lt;code&gt;MaskFormatter&lt;/code&gt; with the mask &quot;###-####&quot; and current value &quot;555-1212&quot;. Using the right arrow key to navigate through the field will result in (| indicates the position of the caret):</source>
          <target state="translated">如果将 &lt;code&gt;MaskFormatter&lt;/code&gt; 配置为仅允许有效字符（ &lt;code&gt;setAllowsInvalid(false)&lt;/code&gt; ），则在编辑时将根据需要跳过文字字符。考虑具有掩码&amp;ldquo; ###-####&amp;rdquo;和当前值&amp;ldquo; 555-1212&amp;rdquo;的 &lt;code&gt;MaskFormatter&lt;/code&gt; 。使用右箭头键浏览该字段将导致（|表示插入符号的位置）：</target>
        </trans-unit>
        <trans-unit id="ead077860ccdc5ff506c0098c7c9fa85462cc96f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;ModuleDescriptor&lt;/code&gt; cannot be created (by means of the &lt;a href=&quot;moduledescriptor.builder&quot;&gt;&lt;code&gt;ModuleDescriptor.Builder&lt;/code&gt;&lt;/a&gt; API) for an automatic module then &lt;code&gt;FindException&lt;/code&gt; is thrown. This can arise when the value of the &quot;&lt;code&gt;Automatic-Module-Name&lt;/code&gt;&quot; attribute is not a legal module name, a legal module name cannot be derived from the file name of the JAR file, where the JAR file contains a &lt;code&gt;.class&lt;/code&gt; in the top-level directory of the JAR file, where an entry in a service configuration file is not a legal class name or its package name is not in the set of packages derived for the module.</source>
          <target state="translated">如果 &lt;code&gt;ModuleDescriptor&lt;/code&gt; 无法创建（由的装置&lt;a href=&quot;moduledescriptor.builder&quot;&gt; &lt;code&gt;ModuleDescriptor.Builder&lt;/code&gt; &lt;/a&gt;用于自动模块API）然后 &lt;code&gt;FindException&lt;/code&gt; 被抛出。当&amp;ldquo; &lt;code&gt;Automatic-Module-Name&lt;/code&gt; &amp;rdquo;属性的值不是合法模块名称时，可能会出现这种情况，无法从JAR文件的文件名派生合法模块名称，该JAR文件的顶部包含一个 &lt;code&gt;.class&lt;/code&gt; 。 JAR文件的级别目录，其中服务配置文件中的条目不是合法的类名称，或者其程序包名称不在该模块派生的程序包集中。</target>
        </trans-unit>
        <trans-unit id="441cc4fd494fbe5b1ad39c7fa559b1582982d101" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Node&lt;/code&gt; is used in a different document than the one that created it (that doesn't support it).</source>
          <target state="translated">如果一个 &lt;code&gt;Node&lt;/code&gt; 在与创建它的文档不同的文档中使用（不支持它）。</target>
        </trans-unit>
        <trans-unit id="4644effb4a6d5ba07fcf8513d9d0cd6f314112a7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PageRanges&lt;/code&gt; attribute is not specified for a print job, all pages of the document will be printed. In other words, the default value for the &lt;code&gt;PageRanges&lt;/code&gt; attribute is always &lt;code&gt;{{1, Integer.MAX_VALUE}}&lt;/code&gt;.</source>
          <target state="translated">如果未为打印作业指定 &lt;code&gt;PageRanges&lt;/code&gt; 属性，则将打印文档的所有页面。换句话说， &lt;code&gt;PageRanges&lt;/code&gt; 属性的默认值始终为 &lt;code&gt;{{1, Integer.MAX_VALUE}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3283302ea3f0883d87077d68bd9cbb226e3ffd4" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;ParseException&lt;/code&gt; has not been thrown, and the value is outside the min/max a &lt;code&gt;ParseException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果尚未引发 &lt;code&gt;ParseException&lt;/code&gt; ，并且该值在最小/最大值之外，则引发 &lt;code&gt;ParseException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ea4836a2a47cbda56eec3b84a8b5aa80316b7db" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PreferencesFactory&lt;/code&gt; implementation class file has been installed in a jar file that is visible to the &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;&lt;code&gt;system class loader&lt;/code&gt;&lt;/a&gt;, and that jar file contains a provider-configuration file named &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. If more than one such jar file is provided, the first one found will be used. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">如果 &lt;code&gt;PreferencesFactory&lt;/code&gt; 实现类文件已安装在&lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt; &lt;code&gt;system class loader&lt;/code&gt; &lt;/a&gt;可见的jar文件中，并且该jar文件在资源目录 &lt;code&gt;META-INF/services&lt;/code&gt; 中包含名为 &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; 的提供程序配置文件，然后使用该文件中指定的第一个类名称。如果提供了多个这样的jar文件，则将使用找到的第一个。该类已加载并实例化；如果此过程失败，则会引发未指定的错误。</target>
        </trans-unit>
        <trans-unit id="d851531cc7c0ba18b4dbffa855d090b319da4df2" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PreferencesFactory&lt;/code&gt; implementation class file has been installed in a jar file that is visible to the &lt;a href=&quot;../../lang/classloader#getSystemClassLoader--&quot;&gt;&lt;code&gt;system class loader&lt;/code&gt;&lt;/a&gt;, and that jar file contains a provider-configuration file named &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. If more than one such jar file is provided, the first one found will be used. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">如果 &lt;code&gt;PreferencesFactory&lt;/code&gt; 实现类文件已安装在&lt;a href=&quot;../../lang/classloader#getSystemClassLoader--&quot;&gt; &lt;code&gt;system class loader&lt;/code&gt; &lt;/a&gt;可见的jar文件中，并且该jar文件在资源目录 &lt;code&gt;META-INF/services&lt;/code&gt; 中包含名为 &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; 的提供程序配置文件，然后使用该文件中指定的第一个类名称。如果提供了多个这样的jar文件，则将使用找到的第一个。该类已加载并实例化；如果此过程失败，则会引发未指定的错误。</target>
        </trans-unit>
        <trans-unit id="622c2551e9494318dc465bf15dd37446b19792a2" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;RenderingHints&lt;/code&gt; object is specified in the constructor, the interpolation hint and the rendering quality hint are used to set the interpolation type for this operation. The color rendering hint and the dithering hint can be used when color conversion is required.</source>
          <target state="translated">如果在构造函数中指定了 &lt;code&gt;RenderingHints&lt;/code&gt; 对象，则使用插值提示和渲染质量提示来设置此操作的插值类型。需要颜色转换时，可以使用显色提示和抖动提示。</target>
        </trans-unit>
        <trans-unit id="ef39b802886ff9b6ff97af1ea901d5330b3307e6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;RowSet&lt;/code&gt; implementation is instantiated with a specified provider and the specified provider has been properly registered, the requested provider is supplied. Otherwise a &lt;code&gt;SyncFactoryException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果用指定的提供程序实例化 &lt;code&gt;RowSet&lt;/code&gt; 实现，并且已正确注册了指定的提供程序，则将提供所请求的提供程序。否则将引发 &lt;code&gt;SyncFactoryException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da1a08658f1dbe589bccb3ea8d557b60263f9878" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;RowSet&lt;/code&gt; object attempts to obtain a &lt;code&gt;MyProvider&lt;/code&gt; object, the &lt;code&gt;SyncFactory&lt;/code&gt; will try to locate it. First it searches for it in the system properties, then it looks in the resource files, and finally it checks the JNDI context that has been set. The &lt;code&gt;SyncFactory&lt;/code&gt; instance verifies that the requested provider is a valid extension of the &lt;code&gt;SyncProvider&lt;/code&gt; abstract class and then gives it to the &lt;code&gt;RowSet&lt;/code&gt; object. In the following code fragment, a new &lt;code&gt;CachedRowSet&lt;/code&gt; object is created and initialized with</source>
          <target state="translated">如果 &lt;code&gt;RowSet&lt;/code&gt; 对象尝试获取 &lt;code&gt;MyProvider&lt;/code&gt; 对象，则 &lt;code&gt;SyncFactory&lt;/code&gt; 将尝试找到它。首先，它在系统属性中搜索它，然后在资源文件中查找，最后它检查已设置的JNDI上下文。该 &lt;code&gt;SyncFactory&lt;/code&gt; 实例验证请求提供者是一个有效扩展 &lt;code&gt;SyncProvider&lt;/code&gt; 抽象类，然后将其提供给 &lt;code&gt;RowSet&lt;/code&gt; 对象。在下面的代码片段中，创建了一个新的 &lt;code&gt;CachedRowSet&lt;/code&gt; 对象，并使用以下方法初始化了该对象：</target>
        </trans-unit>
        <trans-unit id="85924d6f4f84b3110f734f518f0de7bf01d0e847" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;RowSet&lt;/code&gt; object does not specify a &lt;code&gt;SyncProvider&lt;/code&gt; implementation and no additional &lt;code&gt;SyncProvider&lt;/code&gt; implementations are available, the reference implementation providers are supplied.</source>
          <target state="translated">如果 &lt;code&gt;RowSet&lt;/code&gt; 对象未指定 &lt;code&gt;SyncProvider&lt;/code&gt; 实现，并且没有可用的其他 &lt;code&gt;SyncProvider&lt;/code&gt; 实现，则将提供参考实现提供程序。</target>
        </trans-unit>
        <trans-unit id="005a68567a9c263db1c792152177b5d5b3c37e24" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SecurityManager&lt;/code&gt; is installed, the calling thread must be granted the &lt;code&gt;AWTPermission&lt;/code&gt; &quot;replaceKeyboardFocusManager&quot; in order to replace the the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt;. If this permission is not granted, this method will throw a &lt;code&gt;SecurityException&lt;/code&gt;, and the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; will be unchanged.</source>
          <target state="translated">如果安装了 &lt;code&gt;SecurityManager&lt;/code&gt; ，则必须为调用线程授予 &lt;code&gt;AWTPermission&lt;/code&gt; &amp;ldquo; replaceKeyboardFocusManager&amp;rdquo;才能替换当前的 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; 。如果未授予此权限，则此方法将引发 &lt;code&gt;SecurityException&lt;/code&gt; ，并且当前的 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; 将保持不变。</target>
        </trans-unit>
        <trans-unit id="bf0127e04708633ff438380e9063019f694d008f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SyncProvider&lt;/code&gt; object is specified and the &lt;code&gt;SyncFactory&lt;/code&gt; contains</source>
          <target state="translated">如果指定了 &lt;code&gt;SyncProvider&lt;/code&gt; 对象，并且 &lt;code&gt;SyncFactory&lt;/code&gt; 包含</target>
        </trans-unit>
        <trans-unit id="4f2c61caf99510b2cab1bf9c38fbc6348259df28" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SyncProvider&lt;/code&gt; object is specified and the &lt;code&gt;SyncFactory&lt;/code&gt; contains a reference to the provider, the requested provider is supplied.</source>
          <target state="translated">如果指定了 &lt;code&gt;SyncProvider&lt;/code&gt; 对象，并且 &lt;code&gt;SyncFactory&lt;/code&gt; 包含对提供程序的引用，则将提供所请求的提供程序。</target>
        </trans-unit>
        <trans-unit id="6536cee7d50ac1adadff34bddda00e1d72420e1a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SyncProviderException&lt;/code&gt; object is thrown, an application may use this method to generate a &lt;code&gt;SyncResolver&lt;/code&gt; object with which to resolve the conflict or conflicts that caused the exception to be thrown.</source>
          <target state="translated">如果引发了 &lt;code&gt;SyncProviderException&lt;/code&gt; 对象，则应用程序可以使用此方法来生成 &lt;code&gt;SyncResolver&lt;/code&gt; 对象，通过该对象可以解决导致引发异常的冲突。</target>
        </trans-unit>
        <trans-unit id="a2c0481cf37e4b6df1c957fb1176bf4576ce6d06" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;TableStringConverter&lt;/code&gt; has been specified, use it to convert the values to &lt;code&gt;String&lt;/code&gt;s and then use the &lt;code&gt;Comparator&lt;/code&gt; returned by &lt;code&gt;Collator.getInstance()&lt;/code&gt;.</source>
          <target state="translated">如果指定了 &lt;code&gt;TableStringConverter&lt;/code&gt; ，则使用它将值转换为 &lt;code&gt;String&lt;/code&gt; ，然后使用 &lt;code&gt;Collator.getInstance()&lt;/code&gt; 返回的 &lt;code&gt;Comparator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88f021219bb5adbaaf305230bab58b361bbbf62e" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;WebRowSet&lt;/code&gt; object does not specify a provider in its constructor, the &lt;code&gt;SyncFactory&lt;/code&gt; will give it an instance of &lt;code&gt;RIOptimisticProvider&lt;/code&gt;. However, the constructor for &lt;code&gt;WebRowSet&lt;/code&gt; is implemented to set the provider to the &lt;code&gt;RIXMLProvider&lt;/code&gt;, which reads and writes a &lt;code&gt;RowSet&lt;/code&gt; object in XML format.</source>
          <target state="translated">如果 &lt;code&gt;WebRowSet&lt;/code&gt; 对象未在其构造函数中指定提供程序，则 &lt;code&gt;SyncFactory&lt;/code&gt; 将为其提供 &lt;code&gt;RIOptimisticProvider&lt;/code&gt; 的实例。但是，实现了 &lt;code&gt;WebRowSet&lt;/code&gt; 的构造函数，以将提供程序设置为 &lt;code&gt;RIXMLProvider&lt;/code&gt; ，该RIXMLProvider读取和写入XML格式的 &lt;code&gt;RowSet&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="c6d143f1c9666cc7913e46a053fe559e1a96fe26" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;null Cursor&lt;/code&gt; is specified no exception will be thrown and default drag cursors will be used instead.</source>
          <target state="translated">如果指定的 &lt;code&gt;null Cursor&lt;/code&gt; 为空，则不会引发异常，而将使用默认的拖动游标。</target>
        </trans-unit>
        <trans-unit id="8f4b45cbcd2002bbfaa5e00b1ed409af80135472" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;null Transferable&lt;/code&gt; is specified &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果指定了 &lt;code&gt;null Transferable&lt;/code&gt; 则抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="4e14b0a6b6bb76cc2c0b6e35711b0ecf985814b3" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;null&lt;/code&gt; value is specified for the driver to be removed, then no action is taken.</source>
          <target state="translated">如果为要删除的驱动程序指定了 &lt;code&gt;null&lt;/code&gt; 值，则不采取任何措施。</target>
        </trans-unit>
        <trans-unit id="e52e706791f96fcec7c06d42e023ea2edd9c9435" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;#contains(double,double)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle&lt;/code&gt; bounds object according to the &lt;a href=&quot;#contains(double,double)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt;. Specifically:</source>
          <target state="translated">如果一个 &lt;code&gt;point&lt;/code&gt; 根据&lt;a href=&quot;#contains(double,double)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt;方法在 &lt;code&gt;shape&lt;/code&gt; 内，则根据边界的&lt;a href=&quot;#contains(double,double)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt;方法，该点必须位于返回的 &lt;code&gt;Rectangle&lt;/code&gt; bounds对象 &lt;code&gt;bounds&lt;/code&gt; 。具体来说：</target>
        </trans-unit>
        <trans-unit id="fee0a461ccedb0cec1c346f64b81ad734d6b4474" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;#contains(java.awt.geom.Point2D)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle2D&lt;/code&gt; bounds object according to the &lt;a href=&quot;#contains(java.awt.geom.Point2D)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt;. Specifically:</source>
          <target state="translated">如果 &lt;code&gt;point&lt;/code&gt; 是内部 &lt;code&gt;shape&lt;/code&gt; 根据&lt;a href=&quot;#contains(java.awt.geom.Point2D)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt;的方法，则它必须内部返回的是 &lt;code&gt;Rectangle2D&lt;/code&gt; 边界目的，根据&lt;a href=&quot;#contains(java.awt.geom.Point2D)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt;的方法的 &lt;code&gt;bounds&lt;/code&gt; 。具体来说：</target>
        </trans-unit>
        <trans-unit id="1ca6fa88cbddfe8774a575dd729aff8c4c1ff45e" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;../shape#contains(double,double)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle&lt;/code&gt; bounds object according to the &lt;a href=&quot;../shape#contains(double,double)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt;. Specifically:</source>
          <target state="translated">如果一个 &lt;code&gt;point&lt;/code&gt; 根据&lt;a href=&quot;../shape#contains(double,double)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt;方法在 &lt;code&gt;shape&lt;/code&gt; 内，则根据边界的&lt;a href=&quot;../shape#contains(double,double)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt;方法，该点必须位于返回的 &lt;code&gt;Rectangle&lt;/code&gt; bounds对象 &lt;code&gt;bounds&lt;/code&gt; 。具体来说：</target>
        </trans-unit>
        <trans-unit id="439453cd55d4370948e1a390997169512de7d762" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;../shape#contains(java.awt.geom.Point2D)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle2D&lt;/code&gt; bounds object according to the &lt;a href=&quot;../shape#contains(java.awt.geom.Point2D)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt;. Specifically:</source>
          <target state="translated">如果 &lt;code&gt;point&lt;/code&gt; 是内部 &lt;code&gt;shape&lt;/code&gt; 根据&lt;a href=&quot;../shape#contains(java.awt.geom.Point2D)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt;的方法，则它必须内部返回的是 &lt;code&gt;Rectangle2D&lt;/code&gt; 边界目的，根据&lt;a href=&quot;../shape#contains(java.awt.geom.Point2D)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt;的方法的 &lt;code&gt;bounds&lt;/code&gt; 。具体来说：</target>
        </trans-unit>
        <trans-unit id="c287b4bb12cc003fe3dff0af6571caedd594b2e6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;point&lt;/code&gt; is inside the &lt;code&gt;shape&lt;/code&gt; according to the &lt;a href=&quot;shape#contains(java.awt.geom.Point2D)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method, then it must be inside the returned &lt;code&gt;Rectangle2D&lt;/code&gt; bounds object according to the &lt;a href=&quot;shape#contains(java.awt.geom.Point2D)&quot;&gt;&lt;code&gt;contains(point)&lt;/code&gt;&lt;/a&gt; method of the &lt;code&gt;bounds&lt;/code&gt;. Specifically:</source>
          <target state="translated">如果 &lt;code&gt;point&lt;/code&gt; 是内部 &lt;code&gt;shape&lt;/code&gt; 根据&lt;a href=&quot;shape#contains(java.awt.geom.Point2D)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt;的方法，则它必须内部返回的是 &lt;code&gt;Rectangle2D&lt;/code&gt; 边界目的，根据&lt;a href=&quot;shape#contains(java.awt.geom.Point2D)&quot;&gt; &lt;code&gt;contains(point)&lt;/code&gt; &lt;/a&gt;的方法的 &lt;code&gt;bounds&lt;/code&gt; 。具体来说：</target>
        </trans-unit>
        <trans-unit id="23ec38983597030f5c01de386bdcfad6f3c016aa" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;point&lt;/code&gt; is not inside the &lt;code&gt;shape&lt;/code&gt;, then it might still be contained in the &lt;code&gt;bounds&lt;/code&gt; object:</source>
          <target state="translated">如果 &lt;code&gt;point&lt;/code&gt; 不在 &lt;code&gt;shape&lt;/code&gt; 内，则它可能仍包含在 &lt;code&gt;bounds&lt;/code&gt; 对象中：</target>
        </trans-unit>
        <trans-unit id="cb3f45e83272884b8fce5d6e7cf093613a1f0235" translate="yes" xml:space="preserve">
          <source>If a Class has been set for the values (&lt;code&gt;setValueClass&lt;/code&gt;), supers implementation is invoked to convert the value returned from &lt;code&gt;parseObject&lt;/code&gt; to the appropriate class.</source>
          <target state="translated">如果已经为值设置了一个Class（ &lt;code&gt;setValueClass&lt;/code&gt; ），则将调用supers实现，以将从 &lt;code&gt;parseObject&lt;/code&gt; 返回的值转换为适当的类。</target>
        </trans-unit>
        <trans-unit id="c22024a55d98f2d5bfb4a62cbb3885fd92657704" translate="yes" xml:space="preserve">
          <source>If a DRBG is not instantiated with a &lt;a href=&quot;drbgparameters.instantiation&quot;&gt;&lt;code&gt;DrbgParameters.Instantiation&lt;/code&gt;&lt;/a&gt; object explicitly, this implementation instantiates it with a default requested strength of 128 bits, no prediction resistance request, and no personalization string. These default instantiation parameters can also be customized with the &lt;code&gt;securerandom.drbg.config&lt;/code&gt; security property.</source>
          <target state="translated">如果未使用&lt;a href=&quot;drbgparameters.instantiation&quot;&gt; &lt;code&gt;DrbgParameters.Instantiation&lt;/code&gt; &lt;/a&gt;对象显式实例化DRBG，则此实现将使用默认的128位请求强度，无预测阻力请求和个性化字符串来实例化DRBG。这些默认实例化参数也可以使用 &lt;code&gt;securerandom.drbg.config&lt;/code&gt; 安全属性进行自定义。</target>
        </trans-unit>
        <trans-unit id="95e527be19ab2827e077013513499ad6b9cbcff0" translate="yes" xml:space="preserve">
          <source>If a GUI control is both an active &lt;code&gt;DropTarget&lt;/code&gt; and is also scrollable, it can receive notifications of autoscrolling gestures by the user from the DnD system by implementing this interface.</source>
          <target state="translated">如果GUI控件既是活动的 &lt;code&gt;DropTarget&lt;/code&gt; 也是可滚动的，则可以通过实现此接口从DnD系统接收用户的自动滚动手势通知。</target>
        </trans-unit>
        <trans-unit id="99e2b5ed00fcac649fe3f3623264074d666a2942" translate="yes" xml:space="preserve">
          <source>If a JobPriority attribute is specified for a Print Job, it specifies a priority for scheduling the job. A higher value specifies a higher priority. The value 1 indicates the lowest possible priority. The value 100 indicates the highest possible priority. Among those jobs that are ready to print, a printer must print all jobs with a priority value of</source>
          <target state="translated">如果为打印作业指定了 JobPriority 属性,则指定了调度作业的优先级。值越高,说明优先级越高。值1表示可能的最低优先级,值100表示可能的最高优先级。值100表示可能的最高优先级。在准备打印的作业中,打印机必须打印所有优先级为</target>
        </trans-unit>
        <trans-unit id="efa62e398135fa151e6296eb9565e2ee0a846e6d" translate="yes" xml:space="preserve">
          <source>If a PageRanges attribute is not specified for a print job, all pages of the document will be printed. In other words, the default value for the PageRanges attribute is always &lt;code&gt;{{1, Integer.MAX_VALUE}}&lt;/code&gt;.</source>
          <target state="translated">如果未为打印作业指定PageRanges属性，则将打印文档的所有页面。换句话说，PageRanges属性的默认值始终为 &lt;code&gt;{{1, Integer.MAX_VALUE}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56fcf828deb12fa7c8d023153792b45f6be1b50b" translate="yes" xml:space="preserve">
          <source>If a RenderingHints object is specified in the constructor, the color rendering hint and the dithering hint may be used to control color conversion.</source>
          <target state="translated">如果在构造函数中指定了RenderingHints对象,则可以使用颜色渲染提示和抖动提示来控制颜色转换。</target>
        </trans-unit>
        <trans-unit id="4df78250cfd2d96c297fc417911e5b1721cfe666" translate="yes" xml:space="preserve">
          <source>If a RenderingHints object is specified in the constructor, the color rendering hint and the dithering hint may be used when color conversion is required.</source>
          <target state="translated">如果在构造函数中指定了RenderingHints对象,当需要进行颜色转换时,可以使用颜色渲染提示和抖动提示。</target>
        </trans-unit>
        <trans-unit id="68b1d4751c3a4fe9ee24ce1abe018576aed949a4" translate="yes" xml:space="preserve">
          <source>If a SAX application needs information about notations and unparsed entities, then the application implements this interface and registers an instance with the SAX parser using the parser's setDTDHandler method. The parser uses the instance to report notation and unparsed entity declarations to the application.</source>
          <target state="translated">如果一个SAX应用程序需要关于符号和未解析实体的信息,那么应用程序就会实现这个接口,并使用解析器的setDTDHandler方法向SAX解析器注册一个实例。解析器使用该实例向应用程序报告符号和未解析实体声明。</target>
        </trans-unit>
        <trans-unit id="3ba5b890d7e1cdc89fd5a6bca00ab40e11acebb0" translate="yes" xml:space="preserve">
          <source>If a SAX application needs to implement customized error handling, it must implement this interface and then register an instance with the XML reader using the &lt;a href=&quot;xmlreader#setErrorHandler(org.xml.sax.ErrorHandler)&quot;&gt;&lt;code&gt;setErrorHandler&lt;/code&gt;&lt;/a&gt; method. The parser will then report all errors and warnings through this interface.</source>
          <target state="translated">如果SAX应用程序需要实现自定义的错误处理，则它必须实现此接口，然后使用&lt;a href=&quot;xmlreader#setErrorHandler(org.xml.sax.ErrorHandler)&quot;&gt; &lt;code&gt;setErrorHandler&lt;/code&gt; &lt;/a&gt;方法向XML阅读器注册实例。然后，解析器将通过该界面报告所有错误和警告。</target>
        </trans-unit>
        <trans-unit id="699d691146da85f7d6329e02b5ea8958eea65fcb" translate="yes" xml:space="preserve">
          <source>If a SAX application needs to implement customized handling for external entities, it must implement this interface and register an instance with the SAX driver using the &lt;a href=&quot;xmlreader#setEntityResolver(org.xml.sax.EntityResolver)&quot;&gt;&lt;code&gt;setEntityResolver&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果SAX应用程序需要实现对外部实体的自定义处理，则它必须实现此接口，并使用&lt;a href=&quot;xmlreader#setEntityResolver(org.xml.sax.EntityResolver)&quot;&gt; &lt;code&gt;setEntityResolver&lt;/code&gt; &lt;/a&gt;方法向SAX驱动程序注册实例。</target>
        </trans-unit>
        <trans-unit id="0cc9dd15259390fb3e7ac0a12e455bdc750c4cf5" translate="yes" xml:space="preserve">
          <source>If a SAX application requires the customized handling which this interface defines for external entities, it must ensure that it uses an XMLReader with the &lt;em&gt;http://xml.org/sax/features/use-entity-resolver2&lt;/em&gt; feature flag set to &lt;em&gt;true&lt;/em&gt; (which is its default value when the feature is recognized). If that flag is unrecognized, or its value is false, or the resolver does not implement this interface, then only the &lt;a href=&quot;../entityresolver&quot;&gt;&lt;code&gt;EntityResolver&lt;/code&gt;&lt;/a&gt; method will be used.</source>
          <target state="translated">如果SAX应用程序需要此接口为外部实体定义的自定义处理，则它必须确保其使用XMLReader，并且&lt;em&gt;http://xml.org/sax/features/use-entity-resolver2&lt;/em&gt;功能标记设置为&lt;em&gt;true&lt;/em&gt;（是识别功能时的默认值）。如果无法识别该标志，或者其值为false，或者解析器未实现此接口，则将仅使用&lt;a href=&quot;../entityresolver&quot;&gt; &lt;code&gt;EntityResolver&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="36e370cda70c2e439141820154cd61632fd96375" translate="yes" xml:space="preserve">
          <source>If a SAX parser provides location information to the SAX application, it does so by implementing this interface and then passing an instance to the application using the content handler's &lt;a href=&quot;contenthandler#setDocumentLocator(org.xml.sax.Locator)&quot;&gt;&lt;code&gt;setDocumentLocator&lt;/code&gt;&lt;/a&gt; method. The application can use the object to obtain the location of any other SAX event in the XML source document.</source>
          <target state="translated">如果SAX解析器将位置信息提供给SAX应用程序，则可以通过实现此接口，然后使用内容处理程序的&lt;a href=&quot;contenthandler#setDocumentLocator(org.xml.sax.Locator)&quot;&gt; &lt;code&gt;setDocumentLocator&lt;/code&gt; &lt;/a&gt;方法将实例传递给应用程序来实现。应用程序可以使用该对象来获取XML源文档中任何其他SAX事件的位置。</target>
        </trans-unit>
        <trans-unit id="33790afd26c1ed1a1a9f56f095ee280b02987ed3" translate="yes" xml:space="preserve">
          <source>If a SecurityManager is installed, the AWTPermission &lt;code&gt;accessSystemTray&lt;/code&gt; must be granted in order to create a &lt;code&gt;TrayIcon&lt;/code&gt;. Otherwise the constructor will throw a SecurityException.</source>
          <target state="translated">如果安装了SecurityManager，则必须授予AWTPermission &lt;code&gt;accessSystemTray&lt;/code&gt; 才能创建 &lt;code&gt;TrayIcon&lt;/code&gt; 。否则，构造函数将抛出SecurityException。</target>
        </trans-unit>
        <trans-unit id="23738716044ec44efb04a5c326db73bc15c62530" translate="yes" xml:space="preserve">
          <source>If a SecurityManager is installed, the AWTPermission &lt;code&gt;accessSystemTray&lt;/code&gt; must be granted in order to get the &lt;code&gt;SystemTray&lt;/code&gt; instance. Otherwise this method will throw a SecurityException.</source>
          <target state="translated">如果安装了SecurityManager，则必须授予AWTPermission &lt;code&gt;accessSystemTray&lt;/code&gt; 才能获取 &lt;code&gt;SystemTray&lt;/code&gt; 实例。否则，此方法将引发SecurityException。</target>
        </trans-unit>
        <trans-unit id="d6dfd5ce3a3f3a54e3b033911ffb2f2c1d054b1a" translate="yes" xml:space="preserve">
          <source>If a SecurityManager is installed, the calling thread must be granted the &quot;replaceKeyboardFocusManager&quot; AWTPermission. If this permission is not granted, this method will throw a SecurityException, and the current focus cycle root will not be changed.</source>
          <target state="translated">如果安装了SecurityManager,调用线程必须被授予 &quot;replaceKeyboardFocusManager &quot;AWTPermission。如果没有授予这个权限,这个方法将抛出一个SecurityException,并且当前的焦点周期根不会被改变。</target>
        </trans-unit>
        <trans-unit id="12612b7cb4320c32adc61321ec0710dfbe600dab" translate="yes" xml:space="preserve">
          <source>If a SecurityManager is installed, the calling thread must be granted the &quot;replaceKeyboardFocusManager&quot; AWTPermission. If this permission is not granted, this method will throw a SecurityException, and the current focus owner will not be cleared.</source>
          <target state="translated">如果安装了SecurityManager,调用线程必须被授予 &quot;replaceKeyboardFocusManager &quot;AWTPermission。如果这个权限没有被授予,这个方法将抛出一个SecurityException,并且当前焦点所有者不会被清除。</target>
        </trans-unit>
        <trans-unit id="1b4ef801a419d4c91c8ce0f0fe4a7ae44b83b337" translate="yes" xml:space="preserve">
          <source>If a SecurityManager is installed, the calling thread must be granted the AWTPermission &quot;replaceKeyboardFocusManager&quot; in order to replace the the current KeyboardFocusManager. If this permission is not granted, this method will throw a SecurityException, and the current KeyboardFocusManager will be unchanged.</source>
          <target state="translated">如果安装了SecurityManager,调用线程必须被授予AWTP权限 &quot;replaceKeyboardFocusManager &quot;才能替换当前的KeyboardFocusManager。如果没有授予这个权限,这个方法将抛出一个SecurityException,并且当前的KeyboardFocusManager将保持不变。</target>
        </trans-unit>
        <trans-unit id="3c085f80770d9292364ba49610a3d688b254c596" translate="yes" xml:space="preserve">
          <source>If a SecurityManager is installed, the calling thread must be granted the AWTPermission &quot;setWindowAlwaysOnTop&quot; in order to set the value of this property. If this permission is not granted, this method will throw a SecurityException, and the current value of the property will be left unchanged.</source>
          <target state="translated">如果安装了SecurityManager,调用线程必须被授予AWTP权限 &quot;setWindowAlwaysOnTop &quot;才能设置该属性的值。如果这个权限没有被授予,这个方法将抛出一个SecurityException,并且该属性的当前值将保持不变。</target>
        </trans-unit>
        <trans-unit id="419f51299062e187ed812366bb64fa93ee056e2e" translate="yes" xml:space="preserve">
          <source>If a Set of traversal keys has not been explicitly defined for this Component, then this Component's parent's Set is returned. If no Set has been explicitly defined for any of this Component's ancestors, then the current KeyboardFocusManager's default Set is returned.</source>
          <target state="translated">如果没有为该Component明确定义遍历键的Set,那么将返回该Component父代的Set。如果没有为该组件的任何祖先明确定义Set,那么将返回当前KeyboardFocusManager的默认Set。</target>
        </trans-unit>
        <trans-unit id="877904e5a9d9ff637ebc73df19af808b92b14754" translate="yes" xml:space="preserve">
          <source>If a Set of traversal keys has not been explicitly defined for this Container, then this Container's parent's Set is returned. If no Set has been explicitly defined for any of this Container's ancestors, then the current KeyboardFocusManager's default Set is returned.</source>
          <target state="translated">如果没有为这个容器明确定义遍历键集,那么将返回这个容器的父集。如果没有为这个容器的任何祖先明确定义Set,那么将返回当前KeyboardFocusManager的默认Set。</target>
        </trans-unit>
        <trans-unit id="54875f0ae002ae009f6261e6ee89713bac0fc513" translate="yes" xml:space="preserve">
          <source>If a Spliterator reports an inconsistent set of characteristics (either those returned from a single invocation or across multiple invocations), no guarantees can be made about any computation using this Spliterator.</source>
          <target state="translated">如果一个Spliterator报告了一组不一致的特征(无论是单次调用返回的特征还是多次调用返回的特征),就不能保证使用这个Spliterator进行的任何计算。</target>
        </trans-unit>
        <trans-unit id="a91c9f9234bda5620ef4d3e6ac923de910e62499" translate="yes" xml:space="preserve">
          <source>If a UDP socket is used, TCP/IP related socket options will not apply.</source>
          <target state="translated">如果使用UDP套接字,TCP/IP相关套接字选项将不适用。</target>
        </trans-unit>
        <trans-unit id="22b4fec2b9413e137341f86ae67c8350043b7d53" translate="yes" xml:space="preserve">
          <source>If a UDT does not have a direct super type, it is not listed here. A row of the &lt;code&gt;ResultSet&lt;/code&gt; object returned by this method describes the designated UDT and a direct supertype. A row has the following columns:</source>
          <target state="translated">如果UDT没有直接的超级类型，则不在此处列出。此方法返回的 &lt;code&gt;ResultSet&lt;/code&gt; 对象的一行描述指定的UDT和直接超类型。行包含以下列：</target>
        </trans-unit>
        <trans-unit id="27875d35d17c64c41e9933d166925700a1b171f4" translate="yes" xml:space="preserve">
          <source>If a binding is added to or removed from this context, its effect on an enumeration previously returned is undefined.</source>
          <target state="translated">如果在此上下文中添加或删除了一个绑定,那么它对之前返回的枚举的影响是未定义的。</target>
        </trans-unit>
        <trans-unit id="5d7601c05999ae661b9aa6d9768d23b6fac1b78b" translate="yes" xml:space="preserve">
          <source>If a border has been set on this component, returns the border's insets, else calls super.getInsets.</source>
          <target state="translated">如果在这个组件上设置了边框,返回边框的镶边,否则调用super.getInsets。</target>
        </trans-unit>
        <trans-unit id="60267cd6f737fd6024fc6b14a87a199eac11a918" translate="yes" xml:space="preserve">
          <source>If a border has been set on this component, returns the border's insets; otherwise calls &lt;code&gt;super.getInsets&lt;/code&gt;.</source>
          <target state="translated">如果在此组件上设置了边框，则返回边框的插图；否则，返回false。否则调用 &lt;code&gt;super.getInsets&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c4d13fb061d48c8e4e28fb887ecf8598eb732db" translate="yes" xml:space="preserve">
          <source>If a borrow occurs in the days field (in other words, if the computation needs to borrow 1 or -1 month to compensate days), then the computation fails by throwing an &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果在days字段中发生借入（换句话说，如果计算需要借用1或-1个月以补偿天数），则计算会因抛出&lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; 而&lt;/a&gt;失败。</target>
        </trans-unit>
        <trans-unit id="2b8644225e60775049f73144977a4d20b30637be" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;engineSetSeed&lt;/code&gt; had not occurred previously, the first call to this method forces this SecureRandom implementation to seed itself. This self-seeding will not occur if &lt;code&gt;engineSetSeed&lt;/code&gt; was previously called.</source>
          <target state="translated">如果以前未发生过对 &lt;code&gt;engineSetSeed&lt;/code&gt; 的调用，则对此方法的第一次调用将强制此SecureRandom实现自身进行播种。如果先前已调用 &lt;code&gt;engineSetSeed&lt;/code&gt; ,则不会发生这种自我播种。</target>
        </trans-unit>
        <trans-unit id="911ec002bf686d39657f3069553cf1c3b5b5def4" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;setSeed&lt;/code&gt; had not occurred previously, the first call to this method forces this SecureRandom object to seed itself. This self-seeding will not occur if &lt;code&gt;setSeed&lt;/code&gt; was previously called.</source>
          <target state="translated">如果之前未发生过对 &lt;code&gt;setSeed&lt;/code&gt; 的调用，则对此方法的第一次调用将强制此SecureRandom对象播种自身。如果先前调用过 &lt;code&gt;setSeed&lt;/code&gt; ,则不会发生这种自我播种。</target>
        </trans-unit>
        <trans-unit id="17ddc7ad6d330841c65c3723b7bd2743059a6602" translate="yes" xml:space="preserve">
          <source>If a call to a method such as &lt;code&gt;insertBefore&lt;/code&gt; or &lt;code&gt;removeChild&lt;/code&gt; would make the &lt;code&gt;Node&lt;/code&gt; invalid with respect to &quot;partial validity&quot;, this exception would be raised and the operation would not be done.</source>
          <target state="translated">如果对诸如 &lt;code&gt;insertBefore&lt;/code&gt; 或 &lt;code&gt;removeChild&lt;/code&gt; 之类的方法的调用会使 &lt;code&gt;Node&lt;/code&gt; 在&amp;ldquo;部分有效性&amp;rdquo;方面无效，则将引发此异常，并且该操作将无法完成。</target>
        </trans-unit>
        <trans-unit id="334736f49b8d7e0587d8194db7199baa9d06b47d" translate="yes" xml:space="preserve">
          <source>If a call to a method such as &lt;code&gt;insertBefore&lt;/code&gt; or &lt;code&gt;removeChild&lt;/code&gt; would make the &lt;code&gt;Node&lt;/code&gt; invalid with respect to &quot;partial validity&quot;, this exception would be raised and the operation would not be done. This code is used in [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-Val-20040127/&quot;&gt;DOM Level 3 Validation&lt;/a&gt;] . Refer to this specification for further information.</source>
          <target state="translated">如果对诸如 &lt;code&gt;insertBefore&lt;/code&gt; 或 &lt;code&gt;removeChild&lt;/code&gt; 之类的方法的调用会使 &lt;code&gt;Node&lt;/code&gt; 在&amp;ldquo;部分有效性&amp;rdquo;方面无效，则将引发此异常，并且该操作将无法完成。此代码在[ &lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-Val-20040127/&quot;&gt;DOM Level 3验证&lt;/a&gt;]中使用。有关更多信息，请参考此规范。</target>
        </trans-unit>
        <trans-unit id="4c4426a7db97055f91d096bc421ebd9b8de25263" translate="yes" xml:space="preserve">
          <source>If a call to a method such as &lt;code&gt;insertBefore&lt;/code&gt; or &lt;code&gt;removeChild&lt;/code&gt; would make the &lt;code&gt;Node&lt;/code&gt; invalid with respect to &quot;partial validity&quot;, this exception would be raised and the operation would not be done. This code is used in [&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Val-20040127/&quot;&gt;DOM Level 3 Validation&lt;/a&gt;] . Refer to this specification for further information.</source>
          <target state="translated">如果对诸如 &lt;code&gt;insertBefore&lt;/code&gt; 或 &lt;code&gt;removeChild&lt;/code&gt; 之类的方法的调用会使 &lt;code&gt;Node&lt;/code&gt; 在&amp;ldquo;部分有效性&amp;rdquo;方面无效，则将引发此异常，并且该操作将无法完成。此代码在[ &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Val-20040127/&quot;&gt;DOM Level 3验证&lt;/a&gt;]中使用。有关更多信息，请参考此规范。</target>
        </trans-unit>
        <trans-unit id="12d3ca455a566616659c43d38fa4c19d72a68ea1" translate="yes" xml:space="preserve">
          <source>If a card is present in this terminal when this method is called, it returns immediately.</source>
          <target state="translated">如果调用本方法时,本终端中存在一张卡,则立即返回。</target>
        </trans-unit>
        <trans-unit id="05d89b94bbc85cf7d77886e27828d6c62151d272" translate="yes" xml:space="preserve">
          <source>If a character &lt;code&gt;c&lt;/code&gt; is &lt;code&gt;\u0000&lt;/code&gt; or is in the range &lt;code&gt;\u0080&lt;/code&gt; through &lt;code&gt;\u07ff&lt;/code&gt;, then it is represented by two bytes, to be written in the order shown:</source>
          <target state="translated">如果字符 &lt;code&gt;c&lt;/code&gt; 是 &lt;code&gt;\u0000&lt;/code&gt; 或在 &lt;code&gt;\u0080&lt;/code&gt; 到 &lt;code&gt;\u07ff&lt;/code&gt; 范围内，则它由两个字节表示，并按所示顺序写入：</target>
        </trans-unit>
        <trans-unit id="cced7ce9329a5beb13d9d0de6d94d760dcc0c4e8" translate="yes" xml:space="preserve">
          <source>If a character &lt;code&gt;c&lt;/code&gt; is in the range &lt;code&gt;\u0001&lt;/code&gt; through &lt;code&gt;\u007f&lt;/code&gt;, it is represented by one byte:</source>
          <target state="translated">如果字符 &lt;code&gt;c&lt;/code&gt; 在 &lt;code&gt;\u0001&lt;/code&gt; 到 &lt;code&gt;\u007f&lt;/code&gt; 范围内，则用一个字节表示：</target>
        </trans-unit>
        <trans-unit id="07952f6eaca135b300da4ff28ea9b192ef542fea" translate="yes" xml:space="preserve">
          <source>If a character &lt;code&gt;c&lt;/code&gt; is in the range &lt;code&gt;\u0800&lt;/code&gt; through &lt;code&gt;uffff&lt;/code&gt;, then it is represented by three bytes, to be written in the order shown:</source>
          <target state="translated">如果字符 &lt;code&gt;c&lt;/code&gt; 在 &lt;code&gt;\u0800&lt;/code&gt; 到 &lt;code&gt;uffff&lt;/code&gt; 范围内，则用三个字节表示，并按所示顺序写入：</target>
        </trans-unit>
        <trans-unit id="0d5494a676f207ae321fc2c494aa6a96120e143c" translate="yes" xml:space="preserve">
          <source>If a character with value &lt;code&gt;ch&lt;/code&gt; occurs in the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object at an index no smaller than &lt;code&gt;fromIndex&lt;/code&gt;, then the index of the first such occurrence is returned. For values of &lt;code&gt;ch&lt;/code&gt; in the range from 0 to 0xFFFF (inclusive), this is the smallest value</source>
          <target state="translated">如果在此 &lt;code&gt;String&lt;/code&gt; 对象表示的字符序列中出现的值为 &lt;code&gt;ch&lt;/code&gt; 的字符的索引不小于 &lt;code&gt;fromIndex&lt;/code&gt; ，则返回第一次出现的索引。对于 &lt;code&gt;ch&lt;/code&gt; 值，范围是0到0xFFFF（包括0），这是最小值</target>
        </trans-unit>
        <trans-unit id="88d64da6fa30bc481b1c1898ad57b4a92324448a" translate="yes" xml:space="preserve">
          <source>If a charset listed in the &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot; id=&quot;iana&quot;&gt;&lt;i&gt;IANA Charset Registry&lt;/i&gt;&lt;/a&gt; is supported by an implementation of the Java platform then its canonical name must be the name listed in the registry. Many charsets are given more than one name in the registry, in which case the registry identifies one of the names as</source>
          <target state="translated">如果Java平台的实现支持&lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot; id=&quot;iana&quot;&gt;&lt;i&gt;IANA字符集注册表中&lt;/i&gt;&lt;/a&gt;列出的字符集，则其规范名称必须是注册表中列出的名称。在注册表中，给多个字符集指定了多个名称，在这种情况下，注册表将名称之一标识为</target>
        </trans-unit>
        <trans-unit id="835ccd3a2f50b48c8dbdc664f50805c5e332968a" translate="yes" xml:space="preserve">
          <source>If a charset listed in the &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;&lt;i&gt;IANA Charset Registry&lt;/i&gt;&lt;/a&gt; is supported by an implementation of the Java platform then its canonical name must be the name listed in the registry. Many charsets are given more than one name in the registry, in which case the registry identifies one of the names as</source>
          <target state="translated">如果Java平台的实现支持&lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;&lt;i&gt;IANA字符集注册表中&lt;/i&gt;&lt;/a&gt;列出的字符集，则其规范名称必须是注册表中列出的名称。注册表中给多个字符集提供了多个名称，在这种情况下，注册表将名称之一标识为</target>
        </trans-unit>
        <trans-unit id="cf9fdc46f7fdee2fea015ce250e33d2faa3ab015" translate="yes" xml:space="preserve">
          <source>If a charset listed in the &lt;a href=&quot;https://www.iana.org/assignments/character-sets&quot;&gt;&lt;i&gt;IANA Charset Registry&lt;/i&gt;&lt;/a&gt; is supported by an implementation of the Java platform then its canonical name must be the name listed in the registry. Many charsets are given more than one name in the registry, in which case the registry identifies one of the names as</source>
          <target state="translated">如果Java平台的实现支持&lt;a href=&quot;https://www.iana.org/assignments/character-sets&quot;&gt;&lt;i&gt;IANA字符集注册表中&lt;/i&gt;&lt;/a&gt;列出的字符集，则其规范名称必须是注册表中列出的名称。注册表中给多个字符集提供了多个名称，在这种情况下，注册表将名称之一标识为</target>
        </trans-unit>
        <trans-unit id="7a4670c109b4e15f0dcd8e95409c55e92f7d1ad1" translate="yes" xml:space="preserve">
          <source>If a class is defined in an &lt;em&gt;unnamed module&lt;/em&gt; then the second element is omitted as shown in &quot;&lt;code&gt;com.foo.loader//com.foo.bar.App.run(App.java:12)&lt;/code&gt;&quot;.</source>
          <target state="translated">如果在&lt;em&gt;未命名的模块中&lt;/em&gt;定义了一个类，则第二个元素将被省略，如&amp;ldquo; &lt;code&gt;com.foo.loader//com.foo.bar.App.run(App.java:12)&lt;/code&gt; &amp;rdquo;所示。</target>
        </trans-unit>
        <trans-unit id="6fc4948186617f7bd346a9a17fd3789662107304" translate="yes" xml:space="preserve">
          <source>If a class loader wishes to define a package with specific properties, such as version information, then the class loader should call this &lt;code&gt;definePackage&lt;/code&gt; method before calling &lt;code&gt;defineClass&lt;/code&gt;. Otherwise, the &lt;a href=&quot;#defineClass(java.lang.String,byte%5B%5D,int,int,java.security.ProtectionDomain)&quot;&gt;&lt;code&gt;defineClass&lt;/code&gt;&lt;/a&gt; method will define a package in this class loader corresponding to the package of the newly defined class; the properties of this defined package are specified by &lt;a href=&quot;package&quot;&gt;&lt;code&gt;Package&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果类加载器希望定义具有特定属性（例如版本信息）的包，则类加载器应在调用 &lt;code&gt;defineClass&lt;/code&gt; 之前调用此 &lt;code&gt;definePackage&lt;/code&gt; 方法。否则，&lt;a href=&quot;#defineClass(java.lang.String,byte%5B%5D,int,int,java.security.ProtectionDomain)&quot;&gt; &lt;code&gt;defineClass&lt;/code&gt; &lt;/a&gt;方法将在该类加载器中定义一个与新定义的类的包相对应的包；此定义的包的属性由&lt;a href=&quot;package&quot;&gt; &lt;code&gt;Package&lt;/code&gt; &lt;/a&gt;指定。</target>
        </trans-unit>
        <trans-unit id="2e1f6c2a012c9ee1480d2aea7e18a07e1c842c87" translate="yes" xml:space="preserve">
          <source>If a class provides explicit BeanInfo about itself then we add that to the BeanInfo information we obtained from analyzing any derived classes, but we regard the explicit information as being definitive for the current class and its base classes, and do not proceed any further up the superclass chain.</source>
          <target state="translated">如果一个类提供了关于它自己的显式BeanInfo,那么我们就把它添加到我们从分析任何派生类中获得的BeanInfo信息中,但我们把显式信息看作是当前类和它的基类的确定性信息,而不继续往上进行任何超类链。</target>
        </trans-unit>
        <trans-unit id="2cd6058bf392d70f519fdd4e9472bf934b1511bc" translate="yes" xml:space="preserve">
          <source>If a client wants to locate a printer supporting a resolution greater than some required minimum, then it may be necessary to exclude this attribute from a lookup request and to directly query the set of supported resolutions, and specify the one that most closely meets the client's requirements. In some cases this may be more simply achieved by specifying a &lt;code&gt;PrintQuality&lt;/code&gt; attribute which often controls resolution.</source>
          <target state="translated">如果客户希望找到支持比某个最低要求更高的分辨率的打印机，则可能有必要从查找请求中排除此属性，并直接查询一组受支持的分辨率，并指定最接近客户要求的分辨率。要求。在某些情况下，这可以通过指定通常控制分辨率的 &lt;code&gt;PrintQuality&lt;/code&gt; 属性来更简单地实现。</target>
        </trans-unit>
        <trans-unit id="acece6c1313b9c506151182d4c10bc5adcf63087" translate="yes" xml:space="preserve">
          <source>If a client wants to locate a printer supporting a resolution greater than some required minimum, then it may be necessary to exclude this attribute from a lookup request and to directly query the set of supported resolutions, and specify the one that most closely meets the client's requirements. In some cases this may be more simply achieved by specifying a PrintQuality attribute which often controls resolution.</source>
          <target state="translated">如果客户希望找到支持大于所需最低分辨率的打印机,那么可能有必要将该属性从查找请求中排除,直接查询所支持的分辨率集,并指定最符合客户要求的分辨率。在某些情况下,通过指定通常控制分辨率的PrintQuality属性可以更简单地实现这一点。</target>
        </trans-unit>
        <trans-unit id="94ce72ead2f2b5aae2c69c76ea112e52bebf52e8" translate="yes" xml:space="preserve">
          <source>If a collection refuses to add a particular element for any reason other than that it already contains the element, it</source>
          <target state="translated">如果一个集合因为任何原因而拒绝添加一个特定的元素,而不是因为它已经包含了这个元素,那么它就会在</target>
        </trans-unit>
        <trans-unit id="41ab0ee2bc38c356fcd8956baea5b131f76b3cf6" translate="yes" xml:space="preserve">
          <source>If a component hierarchy contains validate roots and the new optimized &lt;code&gt;invalidate()&lt;/code&gt; behavior is enabled, the &lt;code&gt;validate()&lt;/code&gt; method must be invoked on the validate root of a previously invalidated component to restore the validity of the hierarchy later. Otherwise, calling the &lt;code&gt;validate()&lt;/code&gt; method on the top-level container (such as a &lt;code&gt;Frame&lt;/code&gt; object) should be used to restore the validity of the component hierarchy.</source>
          <target state="translated">如果组件层次结构包含验证根，并且启用了新的优化的 &lt;code&gt;invalidate()&lt;/code&gt; 行为，则必须在先前无效的组件的验证根上调用 &lt;code&gt;validate()&lt;/code&gt; 方法，以稍后恢复层次结构的有效性。否则，应使用在顶级容器（例如 &lt;code&gt;Frame&lt;/code&gt; 对象）上调用 &lt;code&gt;validate()&lt;/code&gt; 方法来恢复组件层次结构的有效性。</target>
        </trans-unit>
        <trans-unit id="0d2698c7a918c9b4b3b198d13142ac40d60315ae" translate="yes" xml:space="preserve">
          <source>If a component spans rows it is aligned either to the baseline of the start row (if the baseline-resize behavior is &lt;code&gt;
 CONSTANT_ASCENT&lt;/code&gt;) or the end row (if the baseline-resize behavior is &lt;code&gt;CONSTANT_DESCENT&lt;/code&gt;). The row that the component is aligned to is called the &lt;em&gt;prevailing row&lt;/em&gt;.</source>
          <target state="translated">如果组件跨越行，则它与开始行（如果基线调整大小行为是 &lt;code&gt; CONSTANT_ASCENT&lt;/code&gt; ）或结束行（如果基线调整行为是 &lt;code&gt;CONSTANT_DESCENT&lt;/code&gt; ）的基线对齐。组件对齐的&lt;em&gt;行&lt;/em&gt;称为&lt;em&gt;主导行&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="6d2eb7a73c51f56dc6865791e43b959fff2b8eaf" translate="yes" xml:space="preserve">
          <source>If a connection cannot be established to a proxy (PROXY or SOCKS) servers then the caller should call the proxy selector's &lt;a href=&quot;#connectFailed(java.net.URI,java.net.SocketAddress,java.io.IOException)&quot;&gt;&lt;code&gt;connectFailed&lt;/code&gt;&lt;/a&gt; method to notify the proxy selector that the proxy server is unavailable.</source>
          <target state="translated">如果无法建立与代理服务器（PROXY或SOCKS）的连接，则调用者应调用代理选择器的&lt;a href=&quot;#connectFailed(java.net.URI,java.net.SocketAddress,java.io.IOException)&quot;&gt; &lt;code&gt;connectFailed&lt;/code&gt; &lt;/a&gt;方法，以通知代理选择器该代理服务器不可用。</target>
        </trans-unit>
        <trans-unit id="c4776000b1707ea1d8288ccc9e65458bb1c58a2d" translate="yes" xml:space="preserve">
          <source>If a connection cannot be established to a proxy (PROXY or SOCKS) servers then the caller should call the proxy selector's &lt;a href=&quot;proxyselector#connectFailed-java.net.URI-java.net.SocketAddress-java.io.IOException-&quot;&gt;&lt;code&gt;connectFailed&lt;/code&gt;&lt;/a&gt; method to notify the proxy selector that the proxy server is unavailable.</source>
          <target state="translated">如果无法建立与代理服务器（PROXY或SOCKS）的连接，则调用者应调用代理选择器的&lt;a href=&quot;proxyselector#connectFailed-java.net.URI-java.net.SocketAddress-java.io.IOException-&quot;&gt; &lt;code&gt;connectFailed&lt;/code&gt; &lt;/a&gt;方法，以通知代理选择器该代理服务器不可用。</target>
        </trans-unit>
        <trans-unit id="a4eae2f1f9567895366b2134e4a320c3d0b03090" translate="yes" xml:space="preserve">
          <source>If a constructor is annotated by the both &lt;code&gt;@java.beans.ConstructorProperties&lt;/code&gt; and &lt;code&gt;@javax.management.ConstructorParameters&lt;/code&gt; annotations the JMX introspection will give an absolute precedence to the latter one.</source>
          <target state="translated">如果 &lt;code&gt;@java.beans.ConstructorProperties&lt;/code&gt; 和 &lt;code&gt;@javax.management.ConstructorParameters&lt;/code&gt; 批注都注释了一个构造函数，那么JMX内省将绝对优先于后者。</target>
        </trans-unit>
        <trans-unit id="66d389f1702f33b50016c87da612c3454fb27ac7" translate="yes" xml:space="preserve">
          <source>If a cookie corresponding to the given URI already exists, then it is replaced with the new one.</source>
          <target state="translated">如果给定URI对应的cookie已经存在,那么就用新的cookie替换。</target>
        </trans-unit>
        <trans-unit id="a0e617630717a0b35f702c38de0ff62f4e555322" translate="yes" xml:space="preserve">
          <source>If a custom system class loader is configured (by means of the system property &lt;code&gt;java.system.class.loader&lt;/code&gt; as specified in the &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;&lt;code&gt;getSystemClassLoader&lt;/code&gt;&lt;/a&gt; method) then it must define the &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; method as specified in &lt;a href=&quot;instrumentation#appendToSystemClassLoaderSearch(java.util.jar.JarFile)&quot;&gt;&lt;code&gt;appendToSystemClassLoaderSearch&lt;/code&gt;&lt;/a&gt;. In other words, a custom system class loader must support the mechanism to add an agent JAR file to the system class loader search.</source>
          <target state="translated">如果自定义系统类加载器被配置（由系统属性的手段 &lt;code&gt;java.system.class.loader&lt;/code&gt; 作为指定&lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt; &lt;code&gt;getSystemClassLoader&lt;/code&gt; &lt;/a&gt;方法），那么它必须定义 &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; 如在指定的方法&lt;a href=&quot;instrumentation#appendToSystemClassLoaderSearch(java.util.jar.JarFile)&quot;&gt; &lt;code&gt;appendToSystemClassLoaderSearch&lt;/code&gt; &lt;/a&gt;。换句话说，定制系统类装入器必须支持将代理JAR文件添加到系统类装入器搜索的机制。</target>
        </trans-unit>
        <trans-unit id="df8f1040f8046d584674ec649bf9175bb489aff9" translate="yes" xml:space="preserve">
          <source>If a datagram is immediately available, or if this channel is in blocking mode and one eventually becomes available, then the datagram is copied into the given byte buffer and its source address is returned. If this channel is in non-blocking mode and a datagram is not immediately available then this method immediately returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果数据报立即可用，或者此通道处于阻塞模式并且最终变为可用，则将数据报复制到给定的字节缓冲区中，并返回其源地址。如果此通道处于非阻塞模式，并且数据报不立即可用，则此方法立即返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0818faad6aab3d19f4e535d7f7f60ce1951d12ec" translate="yes" xml:space="preserve">
          <source>If a decimal separator is present, a locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getDecimalSeparator()&quot;&gt;decimal separator&lt;/a&gt; is substituted.</source>
          <target state="translated">如果存在十进制分隔符，则将替换特定于语言环境的&lt;a href=&quot;../text/decimalformatsymbols#getDecimalSeparator()&quot;&gt;十进制分隔符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1a7a080897c03d2a2dec7ade95e887516b9ac13d" translate="yes" xml:space="preserve">
          <source>If a decimal separator is present, a locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getDecimalSeparator--&quot;&gt;decimal separator&lt;/a&gt; is substituted.</source>
          <target state="translated">如果存在十进制分隔符，则将替换特定于语言环境的&lt;a href=&quot;../text/decimalformatsymbols#getDecimalSeparator--&quot;&gt;十进制分隔符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c1f9b7f79d8ec91fb01ae3268899c778ab68a65" translate="yes" xml:space="preserve">
          <source>If a default context was set using the &lt;a href=&quot;#setDefault(javax.net.ssl.SSLContext)&quot;&gt;&lt;code&gt;SSLContext.setDefault()&lt;/code&gt;&lt;/a&gt; method, it is returned. Otherwise, the first call of this method triggers the call &lt;code&gt;SSLContext.getInstance(&quot;Default&quot;)&lt;/code&gt;. If successful, that object is made the default SSL context and returned.</source>
          <target state="translated">如果使用&lt;a href=&quot;#setDefault(javax.net.ssl.SSLContext)&quot;&gt; &lt;code&gt;SSLContext.setDefault()&lt;/code&gt; &lt;/a&gt;方法设置了默认上下文，则将其返回。否则，此方法的第一次调用将触发调用 &lt;code&gt;SSLContext.getInstance(&quot;Default&quot;)&lt;/code&gt; 。如果成功，该对象将成为默认的SSL上下文并返回。</target>
        </trans-unit>
        <trans-unit id="ef151b03b8bdfd0c5b1285060dc05b180bd41b5a" translate="yes" xml:space="preserve">
          <source>If a default context was set using the &lt;a href=&quot;sslcontext#setDefault-javax.net.ssl.SSLContext-&quot;&gt;&lt;code&gt;SSLContext.setDefault()&lt;/code&gt;&lt;/a&gt; method, it is returned. Otherwise, the first call of this method triggers the call &lt;code&gt;SSLContext.getInstance(&quot;Default&quot;)&lt;/code&gt;. If successful, that object is made the default SSL context and returned.</source>
          <target state="translated">如果使用&lt;a href=&quot;sslcontext#setDefault-javax.net.ssl.SSLContext-&quot;&gt; &lt;code&gt;SSLContext.setDefault()&lt;/code&gt; &lt;/a&gt;方法设置了默认上下文，则将其返回。否则，此方法的第一次调用将触发调用 &lt;code&gt;SSLContext.getInstance(&quot;Default&quot;)&lt;/code&gt; 。如果成功，该对象将成为默认的SSL上下文并返回。</target>
        </trans-unit>
        <trans-unit id="51c46ada07dadd84ce5e7fda86de6679eac1d1c4" translate="yes" xml:space="preserve">
          <source>If a descendant of this &lt;code&gt;JRootPane&lt;/code&gt; calls &lt;code&gt;revalidate&lt;/code&gt;, validate from here on down.</source>
          <target state="translated">如果此 &lt;code&gt;JRootPane&lt;/code&gt; 的后代调用 &lt;code&gt;revalidate&lt;/code&gt; ，则从此处开始进行验证。</target>
        </trans-unit>
        <trans-unit id="6749109880140700857e250f0be8ceceea7ff072" translate="yes" xml:space="preserve">
          <source>If a destination &lt;code&gt;URI&lt;/code&gt; is specified in a PrintRequest and it is not accessible for output by the &lt;code&gt;PrintService&lt;/code&gt;, a &lt;code&gt;PrintException&lt;/code&gt; will be thrown. The &lt;code&gt;PrintException&lt;/code&gt; may implement &lt;code&gt;URIException&lt;/code&gt; to provide a more specific cause.</source>
          <target state="translated">如果在PrintRequest中指定了目标 &lt;code&gt;URI&lt;/code&gt; ，并且 &lt;code&gt;PrintService&lt;/code&gt; 无法访问该目标URI，则将抛出 &lt;code&gt;PrintException&lt;/code&gt; 。该 &lt;code&gt;PrintException&lt;/code&gt; 可以实现 &lt;code&gt;URIException&lt;/code&gt; 提供更具体的原因。</target>
        </trans-unit>
        <trans-unit id="14abd8b4a751858e76b43b1c734186c7f7ef97b3" translate="yes" xml:space="preserve">
          <source>If a destination URI is specified in a PrintRequest and it is not accessible for output by the PrintService, a PrintException will be thrown. The PrintException may implement URIException to provide a more specific cause.</source>
          <target state="translated">如果在PrintRequest中指定了目标URI,但PrintService无法访问该URI并进行输出,则会抛出PrintException。PrintException可以实现URIException来提供更具体的原因。</target>
        </trans-unit>
        <trans-unit id="a783065a0322b1d63fdf38ac08e5357d228c2b53" translate="yes" xml:space="preserve">
          <source>If a destination is &lt;em&gt;not&lt;/em&gt; set, Flight Recorder retains the recording data until this recording is closed. Use the &lt;a href=&quot;#dump(java.nio.file.Path)&quot;&gt;&lt;code&gt;dump(Path)&lt;/code&gt;&lt;/a&gt; method to manually write data to a file.</source>
          <target state="translated">如果&lt;em&gt;未&lt;/em&gt;设置目的地，则Flight Recorder会保留记录数据，直到关闭该记录为止。使用&lt;a href=&quot;#dump(java.nio.file.Path)&quot;&gt; &lt;code&gt;dump(Path)&lt;/code&gt; &lt;/a&gt;方法将数据手动写入文件。</target>
        </trans-unit>
        <trans-unit id="6ce74666e9897477c3b28e650ebfa449dd59159a" translate="yes" xml:space="preserve">
          <source>If a destination is set, this recording is automatically closed after data is successfully copied to the destination path.</source>
          <target state="translated">如果设置了目的地,则在数据成功复制到目的地路径后,该记录会自动关闭。</target>
        </trans-unit>
        <trans-unit id="ce1a2c4f98ff2d6af0860f8597c46c4d0b903836" translate="yes" xml:space="preserve">
          <source>If a device name is specified, the resulting list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is searched: the first one with a matching name, and whose &lt;code&gt;MidiDevice&lt;/code&gt; implements the respective interface, will be returned. If no matching &lt;code&gt;MidiDevice.Info&lt;/code&gt; object is found, or the device name is not specified, the first suitable device from the resulting list will be returned. For Sequencer and Synthesizer, a device is suitable if it implements the respective interface; whereas for Receiver and Transmitter, a device is suitable if it implements neither Sequencer nor Synthesizer and provides at least one Receiver or Transmitter, respectively.</source>
          <target state="translated">如果指定了设备名称，则会搜索 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 对象的结果列表：将返回名称匹配的第一个对象，并且其 &lt;code&gt;MidiDevice&lt;/code&gt; 实现相应的接口。如果找不到匹配的 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 对象，或者未指定设备名称，则将返回结果列表中的第一个合适的设备。对于Sequencer和Synthesizer，如果设备实现了各自的接口，则该设备是合适的。而对于接收器和发送器，如果设备既未实现音序器也未实现合成器，并且分别提供至少一个接收器或发送器，则该设备是合适的。</target>
        </trans-unit>
        <trans-unit id="8bacc9e3344a41d79a4651f2c7e9da527b4943d5" translate="yes" xml:space="preserve">
          <source>If a device name is specified, the resulting list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is searched: the first one with a matching name, and whose &lt;code&gt;MidiDevice&lt;/code&gt; implements the respective interface, will be returned. If no matching &lt;code&gt;MidiDevice.Info&lt;/code&gt; object is found, or the device name is not specified, the first suitable device from the resulting list will be returned. For Sequencer and Synthesizer, a device is suitable if it implements the respective interface; whereas for Receiver and Transmitter, a device is suitable if it implements neither Sequencer nor Synthesizer and provides at least one Receiver or Transmitter, respectively. For example, the property &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; with a value &lt;code&gt;&quot;com.sun.media.sound.MidiProvider#SunMIDI1&quot;&lt;/code&gt; will have the following consequences when &lt;code&gt;getReceiver&lt;/code&gt; is called: if the class &lt;code&gt;com.sun.media.sound.MidiProvider&lt;/code&gt; exists in the list of installed MIDI device providers, the first &lt;code&gt;Receiver&lt;/code&gt; device with name &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; will be returned. If it cannot be found, the first &lt;code&gt;Receiver&lt;/code&gt; from that provider will be returned, regardless of name. If there is none, the first &lt;code&gt;Receiver&lt;/code&gt; with name &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; in the list of all devices (as returned by &lt;code&gt;getMidiDeviceInfo&lt;/code&gt;) will be returned, or, if not found, the first &lt;code&gt;Receiver&lt;/code&gt; that can be found in the list of all devices is returned. If that fails, too, a &lt;code&gt;MidiUnavailableException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果指定了设备名称，则会搜索 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 对象的结果列表：将返回名称匹配的第一个对象，并且其 &lt;code&gt;MidiDevice&lt;/code&gt; 实现相应的接口。如果找不到匹配的 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 对象，或者未指定设备名称，则将返回结果列表中的第一个合适的设备。对于序列发生器和合成器，如果设备实现了各自的接口，则该设备是合适的；对于接收器和发送器，如果设备既未实现音序器也未实现合成器，并且分别提供至少一个接收器或发送器，则该设备是合适的。例如，具有值的属性 &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; &lt;code&gt;&quot;com.sun.media.sound.MidiProvider#SunMIDI1&quot;&lt;/code&gt; 将产生以下后果时 &lt;code&gt;getReceiver&lt;/code&gt; 叫做：如果类 &lt;code&gt;com.sun.media.sound.MidiProvider&lt;/code&gt; 在已安装的MIDI设备供应商的列表，则第一 &lt;code&gt;Receiver&lt;/code&gt; 与设备将返回名称 &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; 。如果找不到，将返回该提供者的第一个 &lt;code&gt;Receiver&lt;/code&gt; ，而不管其名称如何。如果没有，则将返回所有设备列表中第一个名称为 &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; &lt;code&gt;Receiver&lt;/code&gt; （由 &lt;code&gt;getMidiDeviceInfo&lt;/code&gt; 返回），或者，如果没有找到，则返回第一个 &lt;code&gt;Receiver&lt;/code&gt; 返回所有设备列表中可以找到的内容。如果同样失败，则会抛出 &lt;code&gt;MidiUnavailableException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c348cf79394a1b079ec5b17aaca7e9df6caf0f51" translate="yes" xml:space="preserve">
          <source>If a disconnected &lt;code&gt;RowSet&lt;/code&gt; object modifies some of its data, and it has a writer associated with it, it may be implemented so that it calls on the writer's &lt;code&gt;writeData&lt;/code&gt; method internally to write the updates back to the data source. In order to do this, the writer must first establish a connection with the rowset's data source.</source>
          <target state="translated">如果断开连接的 &lt;code&gt;RowSet&lt;/code&gt; 对象修改了其某些数据，并且它具有与之关联的写入器，则可以实现该对象，以便它在内部调用写入器的 &lt;code&gt;writeData&lt;/code&gt; 方法以将更新写回到数据源。为此，编写者必须首先与行集的数据源建立连接。</target>
        </trans-unit>
        <trans-unit id="e9228071e448b214400800711814c0f475387695" translate="yes" xml:space="preserve">
          <source>If a doclet object is created and used without the above protocol being followed, then the doclet's behavior is not defined by this interface specification.</source>
          <target state="translated">如果一个doclet对象的创建和使用没有遵循上述协议,那么该doclet的行为就不会被这个接口规范所定义。</target>
        </trans-unit>
        <trans-unit id="96852e06c1dca016e17f4895cd5c8ddd5ec791ac" translate="yes" xml:space="preserve">
          <source>If a document is valid, or if a document contains some errors but none of them were fatal and the &lt;code&gt;ErrorHandler&lt;/code&gt; didn't throw any exception, then the method returns normally.</source>
          <target state="translated">如果文档有效，或者文档包含一些错误，但是没有一个是致命错误，并且 &lt;code&gt;ErrorHandler&lt;/code&gt; 没有引发任何异常，则该方法将正常返回。</target>
        </trans-unit>
        <trans-unit id="1dc1d0d7d632f8adb52a90a5d33de0f5ebfd86ab" translate="yes" xml:space="preserve">
          <source>If a factory is instantiated, it is invoked with the following parameters to produce the resulting context.</source>
          <target state="translated">如果实例化了一个工厂,就会用以下参数调用它,以产生结果的上下文。</target>
        </trans-unit>
        <trans-unit id="61b02e48c383e6261e3240e4271679924e0689b0" translate="yes" xml:space="preserve">
          <source>If a fieldValue is an object then the toString() method is called on it and its returned value is used as the value for the field enclosed in parenthesis.</source>
          <target state="translated">如果fieldValue是一个对象,那么对它调用toString()方法,并将其返回的值作为括号中的字段的值。</target>
        </trans-unit>
        <trans-unit id="7fbb5e24d20d361c0ea0a62c5f3f2f90aea684d9" translate="yes" xml:space="preserve">
          <source>If a file manager is provided, it must be able to handle all locations defined in &lt;a href=&quot;documentationtool.location&quot;&gt;&lt;code&gt;DocumentationTool.Location&lt;/code&gt;&lt;/a&gt;, as well as &lt;a href=&quot;standardlocation#SOURCE_PATH&quot;&gt;&lt;code&gt;StandardLocation.SOURCE_PATH&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardlocation#CLASS_PATH&quot;&gt;&lt;code&gt;StandardLocation.CLASS_PATH&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardlocation#PLATFORM_CLASS_PATH&quot;&gt;&lt;code&gt;StandardLocation.PLATFORM_CLASS_PATH&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果提供了文件管理器，则它必须能够处理&lt;a href=&quot;documentationtool.location&quot;&gt; &lt;code&gt;DocumentationTool.Location&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;standardlocation#SOURCE_PATH&quot;&gt; &lt;code&gt;StandardLocation.SOURCE_PATH&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;standardlocation#CLASS_PATH&quot;&gt; &lt;code&gt;StandardLocation.CLASS_PATH&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;standardlocation#PLATFORM_CLASS_PATH&quot;&gt; &lt;code&gt;StandardLocation.PLATFORM_CLASS_PATH&lt;/code&gt; 中&lt;/a&gt;定义的所有位置。</target>
        </trans-unit>
        <trans-unit id="cdbf6cb18404a64f45d2b8abf710d01eb9d7f2cb" translate="yes" xml:space="preserve">
          <source>If a file manager is provided, it must be able to handle all locations defined in &lt;a href=&quot;standardlocation&quot;&gt;&lt;code&gt;StandardLocation&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果提供了文件管理器，则它必须能够处理&lt;a href=&quot;standardlocation&quot;&gt; &lt;code&gt;StandardLocation&lt;/code&gt; 中&lt;/a&gt;定义的所有位置。</target>
        </trans-unit>
        <trans-unit id="6e77610d088ca1d95b7392fcd2274aef9c2f8d21" translate="yes" xml:space="preserve">
          <source>If a filter &lt;code&gt;F&lt;/code&gt; applies to the &lt;code&gt;N&lt;/code&gt;th argument of the target, then &lt;code&gt;F&lt;/code&gt; must be a method handle which takes exactly one argument. The type of &lt;code&gt;F&lt;/code&gt;'s sole argument replaces the corresponding argument type of the target in the resulting adapted method handle. The return type of &lt;code&gt;F&lt;/code&gt; must be identical to the corresponding parameter type of the target.</source>
          <target state="translated">如果将过滤器 &lt;code&gt;F&lt;/code&gt; 应用于目标的第 &lt;code&gt;N&lt;/code&gt; 个参数，则 &lt;code&gt;F&lt;/code&gt; 必须是仅使用一个参数的方法句柄。的类型的 &lt;code&gt;F&lt;/code&gt; 的唯一的参数替换在所得到的适用方法手柄靶的相应参数类型。 &lt;code&gt;F&lt;/code&gt; 的返回类型必须与目标的相应参数类型相同。</target>
        </trans-unit>
        <trans-unit id="8312dbe0498425dc3e432f47a6cc52909ff0f4aa" translate="yes" xml:space="preserve">
          <source>If a fini function is omitted, use a &lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;default value&lt;/a&gt; for the loop return type.</source>
          <target state="translated">如果省略了fini函数，请为循环返回类型使用&lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;默认值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f0b37f0970ece4cf3ea7a2708e4bc36a7d62db5" translate="yes" xml:space="preserve">
          <source>If a font in this environment has multiple programmable variations, such as Multiple-Master fonts, only one instance of that font is returned in the &lt;code&gt;Font&lt;/code&gt; array. The other variations must be derived by the application.</source>
          <target state="translated">如果此环境中的字体具有多个可编程的变体（例如，Multiple-Master字体），则在 &lt;code&gt;Font&lt;/code&gt; 数组中仅返回该字体的一个实例。其他变体必须由应用程序派生。</target>
        </trans-unit>
        <trans-unit id="ecbf1c32c9e3b6f42844e1b54331ad5f191681f7" translate="yes" xml:space="preserve">
          <source>If a formal parameter type is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned for it must accurately reflect the actual type arguments used in the source code.</source>
          <target state="translated">如果形式参数类型是参数化类型，则为其返回的 &lt;code&gt;Type&lt;/code&gt; 对象必须准确反映源代码中使用的实际类型参数。</target>
        </trans-unit>
        <trans-unit id="77fff40663a1f21028623e35281e042a8419f5f8" translate="yes" xml:space="preserve">
          <source>If a formal parameter type is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned for it must accurately reflect the actual type parameters used in the source code.</source>
          <target state="translated">如果形式参数类型是参数化类型，则为其返回的 &lt;code&gt;Type&lt;/code&gt; 对象必须准确反映源代码中使用的实际类型参数。</target>
        </trans-unit>
        <trans-unit id="48218943f2a8994e2b422a9456a012477f87f4f0" translate="yes" xml:space="preserve">
          <source>If a formal parameter type is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">如果形式参数类型是类型变量或参数化类型,则创建该类型。否则,它将被解析。</target>
        </trans-unit>
        <trans-unit id="8aa45ce5030fe67e696cd9c90f1c3d32a9e26312" translate="yes" xml:space="preserve">
          <source>If a format specifier contains a conversion character that is not applicable to the corresponding argument, then an &lt;a href=&quot;illegalformatconversionexception&quot;&gt;&lt;code&gt;IllegalFormatConversionException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果格式说明符包含不适用于相应参数的转换字符，则将引发&lt;a href=&quot;illegalformatconversionexception&quot;&gt; &lt;code&gt;IllegalFormatConversionException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47e2137fd18da09bdd7e054d7015bc33023b31e0" translate="yes" xml:space="preserve">
          <source>If a given &lt;code&gt;invokedynamic&lt;/code&gt; instruction specifies no static arguments, the instruction's bootstrap method will be invoked on three arguments, conveying the instruction's caller class, name, and method type. If the &lt;code&gt;invokedynamic&lt;/code&gt; instruction specifies one or more static arguments, those values will be passed as additional arguments to the method handle. (Note that because there is a limit of 255 arguments to any method, at most 251 extra arguments can be supplied, since the bootstrap method handle itself and its first three arguments must also be stacked.) The bootstrap method will be invoked as if by either &lt;code&gt;MethodHandle.invoke&lt;/code&gt; or &lt;code&gt;invokeWithArguments&lt;/code&gt;. (There is no way to tell the difference.)</source>
          <target state="translated">如果给定的 &lt;code&gt;invokedynamic&lt;/code&gt; 指令未指定任何静态参数，则该指令的bootstrap方法将在三个参数上调用，传达该指令的调用者类，名称和方法类型。如果 &lt;code&gt;invokedynamic&lt;/code&gt; 指令指定一个或多个静态参数，则这些值将作为其他参数传递给方法句柄。 （请注意，由于任何方法最多只能有255个参数，因此最多可以提供251个额外的参数，因为bootstrap方法本身会处理它的前三个参数。）要么 &lt;code&gt;MethodHandle.invoke&lt;/code&gt; 或 &lt;code&gt;invokeWithArguments&lt;/code&gt; 。 （无法分辨出区别。）</target>
        </trans-unit>
        <trans-unit id="a80d4c3ad4e53040c1a39d7a7bdca9679c68c78f" translate="yes" xml:space="preserve">
          <source>If a horizontal scrollbar is needed, it is treated like the column header (see the paragraph above regarding the vertical scrollbar).</source>
          <target state="translated">如果需要水平滚动条,则会像列头一样处理(参见上面关于垂直滚动条的段落)。</target>
        </trans-unit>
        <trans-unit id="1b302c4fa309e55608aa77d71aa898540e38e284" translate="yes" xml:space="preserve">
          <source>If a host is given then it is appended. If the host is a literal IPv6 address but is not enclosed in square brackets (&lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;) then the square brackets are added.</source>
          <target state="translated">如果提供了主机，则将其附加。如果主机是原义的IPv6地址，但没有括在方括号（ &lt;code&gt;'['&lt;/code&gt; 和 &lt;code&gt;']'&lt;/code&gt; ）中，则会添加方括号。</target>
        </trans-unit>
        <trans-unit id="3c059615b57ed62378344964e37548f3b0e6335b" translate="yes" xml:space="preserve">
          <source>If a list of several images was specified as a Window's icon, this method will return the first item of the list.</source>
          <target state="translated">如果指定了多个图像的列表作为窗口的图标,本方法将返回列表的第一项。</target>
        </trans-unit>
        <trans-unit id="7a15cd0977f55c58d7c0850d3c01c8a63da1d40d" translate="yes" xml:space="preserve">
          <source>If a logical line is spread across several natural lines, the backslash escaping the line terminator sequence, the line terminator sequence, and any white space at the start of the following line have no affect on the key or element values. The remainder of the discussion of key and element parsing (when loading) will assume all the characters constituting the key and element appear on a single natural line after line continuation characters have been removed. Note that it is</source>
          <target state="translated">如果一个逻辑行分布在几个自然行上,则行结束符序列、行结束符序列和下一行开始处的任何空白都不会影响键或元素值。在讨论键和元素解析的剩余部分(加载时),将假设所有构成键和元素的字符在去掉行延续字符后出现在一个自然行上。请注意,它是</target>
        </trans-unit>
        <trans-unit id="cd8e0bbcc783eadd4865fc925b200f06558d3ae6" translate="yes" xml:space="preserve">
          <source>If a look and feel is used that ignores this property, you can still begin a drag and drop operation by calling &lt;code&gt;exportAsDrag&lt;/code&gt; on the component's &lt;code&gt;TransferHandler&lt;/code&gt;.</source>
          <target state="translated">如果使用忽略该属性的外观，则仍可以通过在组件的 &lt;code&gt;TransferHandler&lt;/code&gt; 上调用 &lt;code&gt;exportAsDrag&lt;/code&gt; 来开始拖放操作。</target>
        </trans-unit>
        <trans-unit id="a6cc836fe190aff287b75e0daabe7ceb48e9d86e" translate="yes" xml:space="preserve">
          <source>If a look and feel is used that ignores this property, you can still begin a drag and drop operation by calling &lt;code&gt;exportAsDrag&lt;/code&gt; on the list's &lt;code&gt;TransferHandler&lt;/code&gt;.</source>
          <target state="translated">如果使用忽略该属性的外观，则仍可以通过在列表的 &lt;code&gt;TransferHandler&lt;/code&gt; 上调用 &lt;code&gt;exportAsDrag&lt;/code&gt; 来开始拖放操作。</target>
        </trans-unit>
        <trans-unit id="bfc09a82d3ef30f5685534ffe059fc2caa38aa88" translate="yes" xml:space="preserve">
          <source>If a look and feel is used that ignores this property, you can still begin a drag and drop operation by calling &lt;code&gt;exportAsDrag&lt;/code&gt; on the table's &lt;code&gt;TransferHandler&lt;/code&gt;.</source>
          <target state="translated">如果使用忽略该属性的外观，则仍可以通过在表的 &lt;code&gt;TransferHandler&lt;/code&gt; 上调用 &lt;code&gt;exportAsDrag&lt;/code&gt; 来开始拖放操作。</target>
        </trans-unit>
        <trans-unit id="ccd26ad32dd26739826327f4b3d5f7134a7882ee" translate="yes" xml:space="preserve">
          <source>If a look and feel is used that ignores this property, you can still begin a drag and drop operation by calling &lt;code&gt;exportAsDrag&lt;/code&gt; on the tree's &lt;code&gt;TransferHandler&lt;/code&gt;.</source>
          <target state="translated">如果使用忽略该属性的外观，则仍可以通过在树的 &lt;code&gt;TransferHandler&lt;/code&gt; 上调用 &lt;code&gt;exportAsDrag&lt;/code&gt; 来开始拖放操作。</target>
        </trans-unit>
        <trans-unit id="2255669d20b77ac21c330711ce13f6ea363e0b8f" translate="yes" xml:space="preserve">
          <source>If a mapping for &lt;code&gt;uiClassID&lt;/code&gt; exists or if the specified class can't be found, return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果存在 &lt;code&gt;uiClassID&lt;/code&gt; 的映射，或者找不到指定的类，则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a82003bc08000c8f46219ed82ab846fd6727cbe" translate="yes" xml:space="preserve">
          <source>If a match to the specified pattern is not found at the current position, then no input is skipped and a &lt;code&gt;NoSuchElementException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果在当前位置找不到与指定模式的匹配项，则不跳过任何输入，并引发 &lt;code&gt;NoSuchElementException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e40a20d79d378f273949a8affbffa48e1bdad009" translate="yes" xml:space="preserve">
          <source>If a matching &lt;code&gt;public&lt;/code&gt; entry is found, it is returned immediately.</source>
          <target state="translated">如果找到匹配的 &lt;code&gt;public&lt;/code&gt; 条目，则会立即返回。</target>
        </trans-unit>
        <trans-unit id="f69b5cff049ebc9630323ba63bb4d652364d38f2" translate="yes" xml:space="preserve">
          <source>If a matching &lt;code&gt;system&lt;/code&gt; entry exists, it is returned immediately.</source>
          <target state="translated">如果存在匹配的 &lt;code&gt;system&lt;/code&gt; 条目，则立即返回。</target>
        </trans-unit>
        <trans-unit id="42a4c103812a63e5b048b88e9e4af583a5c904c6" translate="yes" xml:space="preserve">
          <source>If a matching &lt;code&gt;uri&lt;/code&gt; entry is found, it is returned immediately.</source>
          <target state="translated">如果找到匹配的 &lt;code&gt;uri&lt;/code&gt; 条目，则会立即返回。</target>
        </trans-unit>
        <trans-unit id="041906718779e0735497b8d8a4420c278fc6dbb9" translate="yes" xml:space="preserve">
          <source>If a mechanism is listed in the &lt;code&gt;jdk.sasl.disabledMechanisms&lt;/code&gt; security property, it will be ignored and won't be negotiated.</source>
          <target state="translated">如果在 &lt;code&gt;jdk.sasl.disabledMechanisms&lt;/code&gt; 安全属性中列出了一种机制，则将忽略该机制，并且不会进行协商。</target>
        </trans-unit>
        <trans-unit id="6ce32eacabe9190e4c01f4f8f502405a2477637b" translate="yes" xml:space="preserve">
          <source>If a message or notification is immediately available, or if this channel is in blocking mode and one eventually becomes available, then the message or notification is returned or handled, respectively. If this channel is in non-blocking mode and a message or notification is not immediately available then this method immediately returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果消息或通知立即可用，或者此通道处于阻止模式并且最终变为可用，则分别返回或处理该消息或通知。如果此通道处于非阻塞模式，并且消息或通知不立即可用，则此方法立即返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03f7ab2c34aa311345e83cbc387505226e713e48" translate="yes" xml:space="preserve">
          <source>If a method handle for a caller-sensitive method is requested, the general rules for &lt;a href=&quot;methodhandles.lookup#equiv&quot;&gt;bytecode behaviors&lt;/a&gt; apply, but they take account of the lookup class in a special way. The resulting method handle behaves as if it were called from an instruction contained in the lookup class, so that the caller-sensitive method detects the lookup class. (By contrast, the invoker of the method handle is disregarded.) Thus, in the case of caller-sensitive methods, different lookup classes may give rise to differently behaving method handles.</source>
          <target state="translated">如果请求用于调用方敏感方法的方法句柄，则适用&lt;a href=&quot;methodhandles.lookup#equiv&quot;&gt;字节码行为&lt;/a&gt;的一般规则，但是它们以特殊方式考虑了lookup类。生成的方法句柄的行为就像是从查找类中包含的指令中调用的一样，因此，对调用者敏感的方法可以检测到查找类。 （通过对比，方法句柄的调用者被忽略。）因此，在调用者敏感方法的情况下，不同的查找类可能会导致行为不同的方法句柄。</target>
        </trans-unit>
        <trans-unit id="de9caf9128a5abc525b8ff949c024d6c3b7462b7" translate="yes" xml:space="preserve">
          <source>If a mixer name is specified, the resulting list of &lt;code&gt;Mixer.Info&lt;/code&gt; objects is searched: the first one with a matching name, and whose &lt;code&gt;Mixer&lt;/code&gt; provides the respective line interface, will be returned. If no matching &lt;code&gt;Mixer.Info&lt;/code&gt; object is found, or the mixer name is not specified, the first mixer from the resulting list, which provides the respective line interface, will be returned.</source>
          <target state="translated">如果指定了混音器名称，则搜索 &lt;code&gt;Mixer.Info&lt;/code&gt; 对象的结果列表：将返回第一个具有匹配名称的名称，并且其 &lt;code&gt;Mixer&lt;/code&gt; 提供相应的线路接口。如果找不到匹配的 &lt;code&gt;Mixer.Info&lt;/code&gt; 对象，或者未指定混合器名称，则将返回结果列表中的第一个混合器，该列表提供相应的线路接口。</target>
        </trans-unit>
        <trans-unit id="7f4e595c2df825132a51481c97b50495434dfe5e" translate="yes" xml:space="preserve">
          <source>If a mixer name is specified, the resulting list of &lt;code&gt;Mixer.Info&lt;/code&gt; objects is searched: the first one with a matching name, and whose &lt;code&gt;Mixer&lt;/code&gt; provides the respective line interface, will be returned. If no matching &lt;code&gt;Mixer.Info&lt;/code&gt; object is found, or the mixer name is not specified, the first mixer from the resulting list, which provides the respective line interface, will be returned. For example, the property &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; with a value &lt;code&gt;&quot;com.sun.media.sound.MixerProvider#SunClip&quot;&lt;/code&gt; will have the following consequences when &lt;code&gt;getLine&lt;/code&gt; is called requesting a &lt;code&gt;Clip&lt;/code&gt; instance: if the class &lt;code&gt;com.sun.media.sound.MixerProvider&lt;/code&gt; exists in the list of installed mixer providers, the first &lt;code&gt;Clip&lt;/code&gt; from the first mixer with name &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; will be returned. If it cannot be found, the first &lt;code&gt;Clip&lt;/code&gt; from the first mixer of the specified provider will be returned, regardless of name. If there is none, the first &lt;code&gt;Clip&lt;/code&gt; from the first &lt;code&gt;Mixer&lt;/code&gt; with name &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; in the list of all mixers (as returned by &lt;code&gt;getMixerInfo&lt;/code&gt;) will be returned, or, if not found, the first &lt;code&gt;Clip&lt;/code&gt; of the first &lt;code&gt;Mixer&lt;/code&gt;that can be found in the list of all mixers is returned. If that fails, too, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果指定了混音器名称，则会搜索 &lt;code&gt;Mixer.Info&lt;/code&gt; 对象的结果列表：将返回第一个具有匹配名称的名称，并且其 &lt;code&gt;Mixer&lt;/code&gt; 提供相应的线路接口。如果找不到匹配的 &lt;code&gt;Mixer.Info&lt;/code&gt; 对象，或者未指定混合器名称，则将返回结果列表中的第一个混合器，该列表提供相应的线路接口。例如，当调用 &lt;code&gt;getLine&lt;/code&gt; 请求 &lt;code&gt;Clip&lt;/code&gt; 实例时，值为 &lt;code&gt;&quot;com.sun.media.sound.MixerProvider#SunClip&quot;&lt;/code&gt; 的属性 &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; 将具有以下结果：如果类 &lt;code&gt;com.sun.media.sound.MixerProvider&lt;/code&gt; 在已安装的混音器提供程序列表中，如果第一个混音器名为 &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; 则将返回第一个 &lt;code&gt;Clip&lt;/code&gt; 。如果找不到，将返回指定提供者的第一个混合器的第一个 &lt;code&gt;Clip&lt;/code&gt; ，无论名称如何。如果没有，第一个 &lt;code&gt;Clip&lt;/code&gt; 从第一 &lt;code&gt;Mixer&lt;/code&gt; 与名 &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; 在所有混频器列表（由返回 &lt;code&gt;getMixerInfo&lt;/code&gt; ）将被退回，或者，如果没有找到，第一个 &lt;code&gt;Clip&lt;/code&gt; 的第一个 &lt;code&gt;Mixer&lt;/code&gt; ，可以发现在所有混音器列表中返回。如果同样失败，则抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57d4cb4422179df06d85df6edeaf036f2c77e296" translate="yes" xml:space="preserve">
          <source>If a module declares more than one provider then the providers are located in the order that its module descriptor &lt;a href=&quot;../lang/module/moduledescriptor.provides#providers()&quot;&gt;lists the providers&lt;/a&gt;. Providers added dynamically by instrumentation agents (see &lt;a href=&quot;../../../java.instrument/java/lang/instrument/instrumentation#redefineModule(java.lang.Module,java.util.Set,java.util.Map,java.util.Map,java.util.Set,java.util.Map)&quot;&gt;&lt;code&gt;redefineModule&lt;/code&gt;&lt;/a&gt;) are always located after providers declared by the module.</source>
          <target state="translated">如果模块声明了多个提供者，则按照其模块描述符&lt;a href=&quot;../lang/module/moduledescriptor.provides#providers()&quot;&gt;列出提供者&lt;/a&gt;的顺序来定位提供者。由检测代理动态添加的提供程序（请参见&lt;a href=&quot;../../../java.instrument/java/lang/instrument/instrumentation#redefineModule(java.lang.Module,java.util.Set,java.util.Map,java.util.Map,java.util.Set,java.util.Map)&quot;&gt; &lt;code&gt;redefineModule&lt;/code&gt; &lt;/a&gt;）始终位于模块声明的提供程序之后。</target>
        </trans-unit>
        <trans-unit id="efaf60a7b1c87aa4ff2f97aa446a4442865cc86e" translate="yes" xml:space="preserve">
          <source>If a module declares more than one provider then the providers are located in the order that its module descriptor &lt;a href=&quot;../lang/module/moduledescriptor.provides#providers()&quot;&gt;lists the providers&lt;/a&gt;. Providers added dynamically by instrumentation agents are always located after providers declared by the module.</source>
          <target state="translated">如果模块声明了多个提供者，则按照其模块描述符&lt;a href=&quot;../lang/module/moduledescriptor.provides#providers()&quot;&gt;列出提供者&lt;/a&gt;的顺序来定位提供者。由检测代理动态添加的提供者始终位于模块声明的提供者之后。</target>
        </trans-unit>
        <trans-unit id="2898de51e2cf727ad3969c2fe5a2e8ee04593e2d" translate="yes" xml:space="preserve">
          <source>If a mouse has more than three enabled buttons then more values are admissible (4, 5, etc.). There is no assigned constants for these extended buttons. The button masks for the extra buttons returned by this method have no assigned names like the first three button masks.</source>
          <target state="translated">如果一个鼠标有三个以上的启用按钮,那么允许更多的值(4,5等)。这些扩展按钮没有指定的常量。本方法返回的额外按钮的按钮掩码没有像前三个按钮掩码那样的指定名称。</target>
        </trans-unit>
        <trans-unit id="f8a0c1b372f5ed387a77d0a8139d565c090fb292" translate="yes" xml:space="preserve">
          <source>If a mutable target is not required, an &lt;code&gt;invokedynamic&lt;/code&gt; instruction may be permanently bound by means of a &lt;a href=&quot;constantcallsite&quot;&gt;constant call site&lt;/a&gt;.</source>
          <target state="translated">如果不需要可变目标，则可以通过&lt;a href=&quot;constantcallsite&quot;&gt;恒定的调用站点&lt;/a&gt;永久绑定 &lt;code&gt;invokedynamic&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="d153e3199dbf3a239e1e74edc668dcfac7b620a7" translate="yes" xml:space="preserve">
          <source>If a mutable target is required which has volatile variable semantics, because updates to the target must be immediately and reliably witnessed by other threads, a &lt;a href=&quot;volatilecallsite&quot;&gt;volatile call site&lt;/a&gt; may be used.</source>
          <target state="translated">如果需要具有可变变量语义的可变目标，因为必须立即由其他线程可靠地见证对目标的更新，因此可以使用&lt;a href=&quot;volatilecallsite&quot;&gt;可变调用站点&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aeca574c1ffd9cbc5b38291c6b65f0adb833dc01" translate="yes" xml:space="preserve">
          <source>If a name for the desired display language is not available, the method may fall back to some other language.</source>
          <target state="translated">如果所需显示语言的名称不可用,则该方法可能会返回到其他语言。</target>
        </trans-unit>
        <trans-unit id="657a9f6756d750ee4adc0e4bbc100a654dce7128" translate="yes" xml:space="preserve">
          <source>If a name is specified as a byte array, it should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is as follows.</source>
          <target state="translated">如果名称被指定为字节数组,则应包含X.501中定义的单一DER编码区分名称。该结构的ASN.1符号如下:</target>
        </trans-unit>
        <trans-unit id="7be17e75afa7fb0ce61b9792a5c8387c175a86f7" translate="yes" xml:space="preserve">
          <source>If a name is specified as a byte array, it should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is given in the documentation for &lt;a href=&quot;#setIssuerNames(java.util.Collection)&quot;&gt;&lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果将名称指定为字节数组，则它应包含X.501中定义的单个DER编码的专有名称。&lt;a href=&quot;#setIssuerNames(java.util.Collection)&quot;&gt; &lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt; &lt;/a&gt;的文档中给出了此结构的ASN.1表示法。</target>
        </trans-unit>
        <trans-unit id="82b7eb3aeab5135e75a853270d3a38d65b14ccb2" translate="yes" xml:space="preserve">
          <source>If a name is specified as a byte array, it should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is given in the documentation for &lt;a href=&quot;x509crlselector#setIssuerNames-java.util.Collection-&quot;&gt;&lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果将名称指定为字节数组，则它应包含X.501中定义的单个DER编码的专有名称。&lt;a href=&quot;x509crlselector#setIssuerNames-java.util.Collection-&quot;&gt; &lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt; &lt;/a&gt;的文档中给出了此结构的ASN.1表示法。</target>
        </trans-unit>
        <trans-unit id="96afaaa19f7e5c5798f8d8403e551ecc219a3743" translate="yes" xml:space="preserve">
          <source>If a native receiver provided by the default device does not implement the &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; interface, it will be wrapped in a wrapper class that implements the &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; interface. The corresponding &lt;code&gt;Receiver&lt;/code&gt; method calls will be forwarded to the native receiver.</source>
          <target state="translated">如果默认设备提供的本机接收器未实现 &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; 接口，则它将包装在实现 &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; 接口的包装器类中。相应的 &lt;code&gt;Receiver&lt;/code&gt; 方法调用将转发到本机接收器。</target>
        </trans-unit>
        <trans-unit id="f15617aacf84e28d7719762bc77a6e2a240fb2d8" translate="yes" xml:space="preserve">
          <source>If a native transmitter provided by the default device does not implement the &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; interface, it will be wrapped in a wrapper class that implements the &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; interface. The corresponding &lt;code&gt;Transmitter&lt;/code&gt; method calls will be forwarded to the native transmitter.</source>
          <target state="translated">如果默认设备提供的本机发送器未实现 &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; 接口，则它将包装在实现 &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; 接口的包装器类中。相应的 &lt;code&gt;Transmitter&lt;/code&gt; 方法调用将转发到本机发送器。</target>
        </trans-unit>
        <trans-unit id="5e81249a7f19b34aae5c963bc81798bff7133902" translate="yes" xml:space="preserve">
          <source>If a new logger is created its log level will be configured based on the LogManager and it will be configured to also send logging output to its parent's Handlers. It will be registered in the LogManager global namespace.</source>
          <target state="translated">如果创建了一个新的日志记录器,其日志级别将基于 LogManager 进行配置,并将其配置为也将日志输出发送到其父级处理程序。它将在 LogManager 全局命名空间中注册。</target>
        </trans-unit>
        <trans-unit id="e885f68e1bc095b374d6b1ebbe1a47153753c95e" translate="yes" xml:space="preserve">
          <source>If a new logger is created its log level will be configured based on the LogManager and it will configured to also send logging output to its parent's Handlers. It will be registered in the LogManager global namespace.</source>
          <target state="translated">如果创建了一个新的日志记录器,其日志级别将根据 LogManager 进行配置,并将配置为也将日志输出发送到其父级处理程序。它将在 LogManager 全局命名空间中注册。</target>
        </trans-unit>
        <trans-unit id="88b90c99db81cefd92b6c450a7c98a50da340a3f" translate="yes" xml:space="preserve">
          <source>If a new logger is created its log level will be configured based on the LogManager configuration and it will be configured to also send logging output to its parent's Handlers. It will be registered in the LogManager global namespace.</source>
          <target state="translated">如果创建了一个新的日志记录器,其日志级别将根据 LogManager 配置进行配置,并将配置为也将日志输出发送到其父级处理程序。它将在 LogManager 全局命名空间中注册。</target>
        </trans-unit>
        <trans-unit id="5e945b5d1146ab0148461e7bb66b4cc1b6317073" translate="yes" xml:space="preserve">
          <source>If a new logger is created its log level will be configured based on the LogManager configuration and it will configured to also send logging output to its parent's Handlers. It will be registered in the LogManager global namespace.</source>
          <target state="translated">如果创建了一个新的日志记录器,其日志级别将根据 LogManager 配置进行配置,并将配置为也将日志输出发送到其父级处理程序。它将在 LogManager 全局命名空间中注册。</target>
        </trans-unit>
        <trans-unit id="e3a4f0b05b5c2d22a20b05a71a5d7c135620cfeb" translate="yes" xml:space="preserve">
          <source>If a non-null &lt;code&gt;AbstractFormatter&lt;/code&gt; has not been found, use the default formatter.</source>
          <target state="translated">如果未找到非null的 &lt;code&gt;AbstractFormatter&lt;/code&gt; ，请使用默认格式器。</target>
        </trans-unit>
        <trans-unit id="e4374be394b79479c7e1fa5bcc1e8102ae6664e5" translate="yes" xml:space="preserve">
          <source>If a non-null CodeSource is supplied a ProtectionDomain is constructed and associated with the class being defined.</source>
          <target state="translated">如果提供了一个非空的CodeSource,则会构造一个ProtectionDomain并与被定义的类相关联。</target>
        </trans-unit>
        <trans-unit id="12aed712a666305d6484724aaf08bd2e1171c900" translate="yes" xml:space="preserve">
          <source>If a non-null message was supplied in a constructor it is returned. Otherwise, an implementation specific message or &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">如果在构造函数中提供了非null消息，则将其返回。否则，返回特定于实现的消息或 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed948d67e59d3b1ab1a6ab69b72cf90841f818b2" translate="yes" xml:space="preserve">
          <source>If a non-null value is returned, then the PropertyEditor should be prepared to parse that string back in setAsText().</source>
          <target state="translated">如果返回一个非空值,那么PropertyEditor应该准备好在setAsText()中解析回该字符串。</target>
        </trans-unit>
        <trans-unit id="f75d62399906604e72f84182bca91703960c54bf" translate="yes" xml:space="preserve">
          <source>If a null dispatcher is specified, if the specified dispatcher is not in the dispatcher chain, or if this KeyboardFocusManager is specified without having been explicitly re-registered, no action is taken and no exception is thrown.</source>
          <target state="translated">如果指定了一个空的调度器,如果指定的调度器不在调度器链中,或者指定的这个KeyboardFocusManager没有被明确地重新注册,则不会采取任何行动,也不会抛出异常。</target>
        </trans-unit>
        <trans-unit id="5f7c58a9060f8818a2c1c94eb51743d12a9a275a" translate="yes" xml:space="preserve">
          <source>If a null dispatcher is specified, no action is taken and no exception is thrown.</source>
          <target state="translated">如果指定了一个null调度器,则不会采取任何行动,也不会产生异常。</target>
        </trans-unit>
        <trans-unit id="9858a7d611d85aa9445822454181b23692a649db" translate="yes" xml:space="preserve">
          <source>If a null post-processor is specified, if the specified post-processor is not in the post-processor chain, or if this KeyboardFocusManager is specified without having been explicitly added, no action is taken and no exception is thrown.</source>
          <target state="translated">如果指定了一个空的后处理器,如果指定的后处理器不在后处理器链中,或者指定了这个KeyboardFocusManager但没有被明确添加,则不会采取任何操作,也不会抛出异常。</target>
        </trans-unit>
        <trans-unit id="80e5e24189da6aec4a702f1b11675b7d716e2c68" translate="yes" xml:space="preserve">
          <source>If a null post-processor is specified, no action is taken and no exception is thrown.</source>
          <target state="translated">如果指定了一个空的后处理程序,则不会采取任何行动,也不会产生异常。</target>
        </trans-unit>
        <trans-unit id="c9d7fb43a6f9ab347881ca798d47872764ac074f" translate="yes" xml:space="preserve">
          <source>If a number is preceded by &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; and a year has already been recognized, then the number is a time-zone offset. If the number is less than 24, it is an offset measured in hours. Otherwise, it is regarded as an offset in minutes, expressed in 24-hour time format without punctuation. A preceding &lt;code&gt;-&lt;/code&gt; means a westward offset. Time zone offsets are always relative to UTC (Greenwich). Thus, for example, &lt;code&gt;-5&lt;/code&gt; occurring in the string would mean &quot;five hours west of Greenwich&quot; and &lt;code&gt;+0430&lt;/code&gt; would mean &quot;four hours and thirty minutes east of Greenwich.&quot; It is permitted for the string to specify &lt;code&gt;GMT&lt;/code&gt;, &lt;code&gt;UT&lt;/code&gt;, or &lt;code&gt;UTC&lt;/code&gt; redundantly-for example, &lt;code&gt;GMT-5&lt;/code&gt; or &lt;code&gt;utc+0430&lt;/code&gt;.</source>
          <target state="translated">如果数字前面带有 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; 且已识别年份，则该数字为时区偏移量。如果数字小于24，则为以小时为单位的偏移量。否则，它被视为以分钟为单位的偏移量，以24小时时间格式表示，没有标点符号。前面的 &lt;code&gt;-&lt;/code&gt; 表示向西偏移。时区偏移量始终相对于UTC（格林威治标准时间）。因此，例如，字符串中出现的 &lt;code&gt;-5&lt;/code&gt; 表示&amp;ldquo;格林威治以西五个小时&amp;rdquo;，而 &lt;code&gt;+0430&lt;/code&gt; 表示&amp;ldquo;格林威治以东四个小时三十分钟&amp;rdquo;。允许该字符串冗余地指定 &lt;code&gt;GMT&lt;/code&gt; ， &lt;code&gt;UT&lt;/code&gt; 或 &lt;code&gt;UTC&lt;/code&gt; -例如， &lt;code&gt;GMT-5&lt;/code&gt; 或 &lt;code&gt;utc+0430&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="871e2115f882350e714e39955d71707aaebf9ba5" translate="yes" xml:space="preserve">
          <source>If a parameter or an operation is not supported by the underlying object.</source>
          <target state="translated">如果一个参数或一个操作不被底层对象支持。</target>
        </trans-unit>
        <trans-unit id="81c0651f2b5e452650a2ea674b863476cc997e33" translate="yes" xml:space="preserve">
          <source>If a parameterized type is being returned, its type element must not be contained within a generic outer class. The parameterized type &lt;code&gt;Outer&amp;lt;String&amp;gt;.Inner&amp;lt;Number&amp;gt;&lt;/code&gt;, for example, may be constructed by first using this method to get the type &lt;code&gt;Outer&amp;lt;String&amp;gt;&lt;/code&gt;, and then invoking &lt;a href=&quot;#getDeclaredType(javax.lang.model.type.DeclaredType,javax.lang.model.element.TypeElement,javax.lang.model.type.TypeMirror...)&quot;&gt;&lt;code&gt;getDeclaredType(DeclaredType, TypeElement, TypeMirror...)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果返回参数化类型，则其类型元素不得包含在通用外部类中。例如，可以通过首先使用此方法构造类型参数化类型 &lt;code&gt;Outer&amp;lt;String&amp;gt;.Inner&amp;lt;Number&amp;gt;&lt;/code&gt; ，以获取类型 &lt;code&gt;Outer&amp;lt;String&amp;gt;&lt;/code&gt; ，然后调用&lt;a href=&quot;#getDeclaredType(javax.lang.model.type.DeclaredType,javax.lang.model.element.TypeElement,javax.lang.model.type.TypeMirror...)&quot;&gt; &lt;code&gt;getDeclaredType(DeclaredType, TypeElement, TypeMirror...)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7e7b1f4d4e8c47890d4e04c211a6340b6dc972a" translate="yes" xml:space="preserve">
          <source>If a parameterized type is being returned, its type element must not be contained within a generic outer class. The parameterized type &lt;code&gt;Outer&amp;lt;String&amp;gt;.Inner&amp;lt;Number&amp;gt;&lt;/code&gt;, for example, may be constructed by first using this method to get the type &lt;code&gt;Outer&amp;lt;String&amp;gt;&lt;/code&gt;, and then invoking &lt;a href=&quot;types#getDeclaredType-javax.lang.model.type.DeclaredType-javax.lang.model.element.TypeElement-javax.lang.model.type.TypeMirror...-&quot;&gt;&lt;code&gt;getDeclaredType(DeclaredType, TypeElement, TypeMirror...)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要返回参数化类型，则其类型元素不得包含在通用外部类中。例如，可以通过以下方法构造参数化类型 &lt;code&gt;Outer&amp;lt;String&amp;gt;.Inner&amp;lt;Number&amp;gt;&lt;/code&gt; ：首先使用此方法来获取类型 &lt;code&gt;Outer&amp;lt;String&amp;gt;&lt;/code&gt; ，然后调用&lt;a href=&quot;types#getDeclaredType-javax.lang.model.type.DeclaredType-javax.lang.model.element.TypeElement-javax.lang.model.type.TypeMirror...-&quot;&gt; &lt;code&gt;getDeclaredType(DeclaredType, TypeElement, TypeMirror...)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="43ccbd75a69c5df862ae14549f2be12f58f6705e" translate="yes" xml:space="preserve">
          <source>If a parsing error occurs, the exception that is thrown will include information about the location of the error in the original XML document.</source>
          <target state="translated">如果发生解析错误,抛出的异常将包括原始XML文档中错误位置的信息。</target>
        </trans-unit>
        <trans-unit id="b860cee6c1daa1284a85c7a9b7c1c7d6c9380907" translate="yes" xml:space="preserve">
          <source>If a particular concrete charset provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates will be ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; this is not necessarily the class loader that loaded the file.</source>
          <target state="translated">如果特定的具体字符集提供程序类在多个配置文件中被命名,或者在同一个配置文件中被命名了不止一次,那么重复的内容将被忽略。命名特定提供程序的配置文件不需要与提供程序本身在同一个jar文件或其他发布单元中。提供者必须可以从最初被查询定位配置文件的同一个类加载器访问;这不一定是加载文件的类加载器。</target>
        </trans-unit>
        <trans-unit id="fbd441057e8700833c9533c87ba431e637f763c4" translate="yes" xml:space="preserve">
          <source>If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates are ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; note that this is not necessarily the class loader from which the file was actually loaded.</source>
          <target state="translated">如果某个具体的提供者类在多个配置文件中被命名,或者在同一个配置文件中被命名了不止一次,那么重复的类将被忽略。命名特定提供者的配置文件不需要和提供者本身在同一个jar文件或其他发布单元中。提供者必须可以从最初被查询定位配置文件的同一个类加载器中访问;注意,这不一定是实际加载文件的那个类加载器。</target>
        </trans-unit>
        <trans-unit id="5da4bf007198af6025012fc0fecd914082583539" translate="yes" xml:space="preserve">
          <source>If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates will be ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; this is not necessarily the class loader that loaded the file.</source>
          <target state="translated">如果一个特定的具体提供者类在多个配置文件中被命名,或者在同一个配置文件中被命名多次,那么重复的类将被忽略。命名特定提供者的配置文件不需要与提供者本身在同一个jar文件或其他发布单元中。提供者必须可以从最初被查询定位配置文件的同一个类加载器访问;这不一定是加载文件的类加载器。</target>
        </trans-unit>
        <trans-unit id="11cee8d3b1bf0c5f932f0904e55f7a8ab8555e41" translate="yes" xml:space="preserve">
          <source>If a particular provider is specified by a &lt;code&gt;RowSet&lt;/code&gt; object, and the &lt;code&gt;SyncFactory&lt;/code&gt; does not contain a reference to this provider, a &lt;code&gt;SyncFactoryException&lt;/code&gt; is thrown stating that the synchronization provider could not be found.</source>
          <target state="translated">如果 &lt;code&gt;RowSet&lt;/code&gt; 对象指定了特定的提供程序，并且 &lt;code&gt;SyncFactory&lt;/code&gt; 不包含对此提供程序的引用，则会引发 &lt;code&gt;SyncFactoryException&lt;/code&gt; ，指出找不到同步提供程序。</target>
        </trans-unit>
        <trans-unit id="29590084579273dadce0a572331ee22aa9d1bda8" translate="yes" xml:space="preserve">
          <source>If a partition has no elements, its value in the result Map will be an empty List.</source>
          <target state="translated">如果一个分区没有元素,它在结果Map中的值将是一个空List。</target>
        </trans-unit>
        <trans-unit id="42129ba221a5197a6e8db6241f12cd2c90200f85" translate="yes" xml:space="preserve">
          <source>If a partition has no elements, its value in the result Map will be obtained by calling the downstream collector's supplier function and then applying the finisher function.</source>
          <target state="translated">如果一个分区没有元素,它在结果Map中的值将通过调用下游收集器的供应商函数,然后应用finisher函数获得。</target>
        </trans-unit>
        <trans-unit id="d5668fe10c0723c5fca50dcc78c1b35e4b358bc9" translate="yes" xml:space="preserve">
          <source>If a path is given then it is appended. Any character not in the</source>
          <target state="translated">如果给出了路径,那么就会被附加。任何不在</target>
        </trans-unit>
        <trans-unit id="0e5a965d6474edf02c5830767daff8c0d82cf26d" translate="yes" xml:space="preserve">
          <source>If a pattern is to be used multiple times, compiling it once and reusing it will be more efficient than invoking this method each time.</source>
          <target state="translated">如果一个模式要被多次使用,编译一次并重复使用会比每次调用这个方法更有效率。</target>
        </trans-unit>
        <trans-unit id="89b4c008a45797eef3268e7fe508720bf307f893" translate="yes" xml:space="preserve">
          <source>If a permit is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">如果获得许可，则返回值 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42b24fec51a71ad010963ae360a48a8c5d862862" translate="yes" xml:space="preserve">
          <source>If a persistence delegate is associated with the given type by using the &lt;a href=&quot;#setPersistenceDelegate(java.lang.Class,java.beans.PersistenceDelegate)&quot;&gt;&lt;code&gt;setPersistenceDelegate(java.lang.Class&amp;lt;?&amp;gt;, java.beans.PersistenceDelegate)&lt;/code&gt;&lt;/a&gt; method it is returned.</source>
          <target state="translated">如果通过使用&lt;a href=&quot;#setPersistenceDelegate(java.lang.Class,java.beans.PersistenceDelegate)&quot;&gt; &lt;code&gt;setPersistenceDelegate(java.lang.Class&amp;lt;?&amp;gt;, java.beans.PersistenceDelegate)&lt;/code&gt; &lt;/a&gt;方法将持久性委托与给定类型相关联，则将其返回。</target>
        </trans-unit>
        <trans-unit id="619e1dee8db482adbcc19510b522caad9b3dd86b" translate="yes" xml:space="preserve">
          <source>If a persistence delegate is associated with the given type by using the &lt;a href=&quot;encoder#setPersistenceDelegate-java.lang.Class-java.beans.PersistenceDelegate-&quot;&gt;&lt;code&gt;setPersistenceDelegate(java.lang.Class&amp;lt;?&amp;gt;, java.beans.PersistenceDelegate)&lt;/code&gt;&lt;/a&gt; method it is returned.</source>
          <target state="translated">如果使用&lt;a href=&quot;encoder#setPersistenceDelegate-java.lang.Class-java.beans.PersistenceDelegate-&quot;&gt; &lt;code&gt;setPersistenceDelegate(java.lang.Class&amp;lt;?&amp;gt;, java.beans.PersistenceDelegate)&lt;/code&gt; &lt;/a&gt;方法将持久性委托与给定类型相关联，则将其返回。</target>
        </trans-unit>
        <trans-unit id="11d9ed1e56dc29ed992752f78c70910959ce2ab4" translate="yes" xml:space="preserve">
          <source>If a port number is given then a colon character (&lt;code&gt;':'&lt;/code&gt;) is appended, followed by the port number in decimal.</source>
          <target state="translated">如果给出了端口号，则将冒号（ &lt;code&gt;':'&lt;/code&gt; ）附加在其后，并以十进制表示端口号。</target>
        </trans-unit>
        <trans-unit id="d701428b48ae7874b54baebebd1df48be574b193" translate="yes" xml:space="preserve">
          <source>If a pred function is omitted, use a constant &lt;code&gt;true&lt;/code&gt; function. (This will keep the loop going, as far as this clause is concerned. Note that in such cases the corresponding fini function is unreachable.)</source>
          <target state="translated">如果省略了pred函数，请使用常量 &lt;code&gt;true&lt;/code&gt; 函数。（就此子句而言，这将使循环继续进行。请注意，在这种情况下，相应的fini函数不可访问。）</target>
        </trans-unit>
        <trans-unit id="1e2d6f69246267134b84e23e4dd1a1f828cae635" translate="yes" xml:space="preserve">
          <source>If a pred function returns &lt;code&gt;false&lt;/code&gt;, the corresponding fini function is called, and the resulting value (of type &lt;code&gt;R&lt;/code&gt;) is returned from the loop as a whole.</source>
          <target state="translated">如果pred函数返回 &lt;code&gt;false&lt;/code&gt; ，则调用相应的fini函数，并且从整个循环返回结果值（类型 &lt;code&gt;R&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="caf5336d5c7e67a44f03340f4fbe7da00052aa6b" translate="yes" xml:space="preserve">
          <source>If a print service provides any vendor extensions these may be made accessible to the user through a vendor supplied tab panel &lt;code&gt;Component&lt;/code&gt;. Such a vendor extension is encouraged to use Swing! and to support its accessibility APIs. The vendor extensions should return the settings as part of the &lt;code&gt;AttributeSet&lt;/code&gt;. Applications which want to preserve the user settings should use those settings to specify the print job. Note that this class is not referenced by any other part of the Java Print Service and may not be included in profiles which cannot depend on the presence of the AWT packages.</source>
          <target state="translated">如果打印服务提供了任何供应商扩展名，则可以通过供应商提供的选项卡面板 &lt;code&gt;Component&lt;/code&gt; 来使用户可以访问这些扩展名。鼓励这样的供应商扩展使用Swing！并支持其可访问性API。供应商扩展应将设置作为 &lt;code&gt;AttributeSet&lt;/code&gt; 的一部分返回。想要保留用户设置的应用程序应使用这些设置来指定打印作业。请注意，此类不会被Java Print Service的任何其他部分引用，并且可能不包含在配置文件中，而这些配置文件不依赖于AWT包的存在。</target>
        </trans-unit>
        <trans-unit id="38d056108653d02210141b2a751f0e69e31fb1fd" translate="yes" xml:space="preserve">
          <source>If a print service provides any vendor extensions these may be made accessible to the user through a vendor supplied tab panel Component. Such a vendor extension is encouraged to use Swing! and to support its accessibility APIs. The vendor extensions should return the settings as part of the AttributeSet. Applications which want to preserve the user settings should use those settings to specify the print job. Note that this class is not referenced by any other part of the Java Print Service and may not be included in profiles which cannot depend on the presence of the AWT packages.</source>
          <target state="translated">如果打印服务提供了任何供应商扩展,这些扩展可以通过供应商提供的标签面板组件让用户访问。鼓励此类供应商扩展使用Swing!并支持其可访问性API。厂商扩展应该返回设置作为AttributeSet的一部分。想要保留用户设置的应用程序应该使用这些设置来指定打印作业。请注意,该类不被 Java 打印服务的任何其他部分引用,也不能包含在不能依赖 AWT 包的配置文件中。</target>
        </trans-unit>
        <trans-unit id="59af891bcb7ad7848a092781a278ba855f208533" translate="yes" xml:space="preserve">
          <source>If a printer does not support the &lt;code&gt;SheetCollate&lt;/code&gt; attribute (meaning the client cannot specify any particular sheet collation), the printer must behave as though &lt;code&gt;SheetCollate&lt;/code&gt; were always set to &lt;code&gt;COLLATED&lt;/code&gt;.</source>
          <target state="translated">如果打印机不支持 &lt;code&gt;SheetCollate&lt;/code&gt; 属性（意味着客户端无法指定任何特定的纸张归类），则打印机的行为必须就像 &lt;code&gt;SheetCollate&lt;/code&gt; 始终设置为 &lt;code&gt;COLLATED&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="f29ea7b220242b9cb8462cb83e9acfd3082297b2" translate="yes" xml:space="preserve">
          <source>If a printer does not support the SheetCollate attribute (meaning the client cannot specify any particular sheet collation), the printer must behave as though SheetCollate were always set to COLLATED.</source>
          <target state="translated">如果打印机不支持SheetCollate属性(意味着客户端不能指定任何特定的纸张整理),则打印机的行为就像SheetCollate总是被设置为COLLATED一样。</target>
        </trans-unit>
        <trans-unit id="49665e43d0c605dc9888cfc626aa1ab47db7f814" translate="yes" xml:space="preserve">
          <source>If a processor object is created and used without the above protocol being followed, then the processor's behavior is not defined by this interface specification.</source>
          <target state="translated">如果一个处理器对象的创建和使用没有遵循上述协议,那么处理器的行为就不是本接口规范所定义的。</target>
        </trans-unit>
        <trans-unit id="81af254ec927065b733bde24b627fbd0490e34d9" translate="yes" xml:space="preserve">
          <source>If a processor throws an uncaught exception, the tool may cease other active annotation processors. If a processor raises an error, the current round will run to completion and the subsequent round will indicate an &lt;a href=&quot;roundenvironment#errorRaised()&quot;&gt;error was raised&lt;/a&gt;. Since annotation processors are run in a cooperative environment, a processor should throw an uncaught exception only in situations where no error recovery or reporting is feasible.</source>
          <target state="translated">如果处理器抛出未捕获的异常，则该工具可能会停止其他活动的注释处理器。如果处理器引发错误，则当前回合将运行完毕，而下一回合将指示&lt;a href=&quot;roundenvironment#errorRaised()&quot;&gt;引发&lt;/a&gt;了错误。由于注释处理器在协作环境中运行，因此处理器仅应在无法进行错误恢复或报告的情况下抛出未捕获的异常。</target>
        </trans-unit>
        <trans-unit id="ca6e8c92cea494ed3f4a024c3b0fdf6756539fd3" translate="yes" xml:space="preserve">
          <source>If a processor throws an uncaught exception, the tool may cease other active annotation processors. If a processor raises an error, the current round will run to completion and the subsequent round will indicate an &lt;a href=&quot;roundenvironment#errorRaised--&quot;&gt;error was raised&lt;/a&gt;. Since annotation processors are run in a cooperative environment, a processor should throw an uncaught exception only in situations where no error recovery or reporting is feasible.</source>
          <target state="translated">如果处理器抛出未捕获的异常，则该工具可能会停止其他活动的注释处理器。如果处理器引发错误，则当前回合将运行完成，而下一回合将指示&lt;a href=&quot;roundenvironment#errorRaised--&quot;&gt;引发&lt;/a&gt;了错误。由于注释处理器在协作环境中运行，因此处理器仅应在无法进行错误恢复或报告的情况下抛出未捕获的异常。</target>
        </trans-unit>
        <trans-unit id="cb6c65b34b95b44418e49ca6b3559cef82f09432" translate="yes" xml:space="preserve">
          <source>If a property has been set using &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt;, that value will be returned. Otherwise, if a property is explicitly specified in the stylesheet, that value will be returned. If the value of the property has been defaulted, that is, if no value has been set explicitly either with &lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt; or in the stylesheet, the result may vary depending on implementation and input stylesheet.</source>
          <target state="translated">如果使用&lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt;设置了属性，则将返回该值。否则，如果在样式表中明确指定了属性，则将返回该值。如果属性的值是默认值，即，如果没有使用&lt;a href=&quot;#setOutputProperty(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;setOutputProperty(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt;或在样式表中明确设置任何值，则结果可能会因实现和输入而异样式表。</target>
        </trans-unit>
        <trans-unit id="fe881171d1c239ccd44b6c4f0b3100103c51b330" translate="yes" xml:space="preserve">
          <source>If a property is indexed, then its entry in the result array belongs to the &lt;a href=&quot;indexedpropertydescriptor&quot;&gt;&lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt;&lt;/a&gt; subclass of the &lt;a href=&quot;propertydescriptor&quot;&gt;&lt;code&gt;PropertyDescriptor&lt;/code&gt;&lt;/a&gt; class. A client of the &lt;code&gt;getPropertyDescriptors&lt;/code&gt; method can use the &lt;code&gt;instanceof&lt;/code&gt; operator to check whether a given &lt;code&gt;PropertyDescriptor&lt;/code&gt; is an &lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt;.</source>
          <target state="translated">如果对属性进行索引，则其在结果数组中的条目属于&lt;a href=&quot;propertydescriptor&quot;&gt; &lt;code&gt;PropertyDescriptor&lt;/code&gt; &lt;/a&gt;类的&lt;a href=&quot;indexedpropertydescriptor&quot;&gt; &lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt; &lt;/a&gt;子类。 &lt;code&gt;getPropertyDescriptors&lt;/code&gt; 方法的客户端可以使用 &lt;code&gt;instanceof&lt;/code&gt; 运算符来检查给定的 &lt;code&gt;PropertyDescriptor&lt;/code&gt; 是否为 &lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73b5d72f7f083f370b03d87e8286e01120577634" translate="yes" xml:space="preserve">
          <source>If a property value is a directory name, all files under that directory will be passed also.</source>
          <target state="translated">如果属性值是一个目录名,那么该目录下的所有文件也将被传递。</target>
        </trans-unit>
        <trans-unit id="b052521b488218cd7b9b35156c5fdb24478e5826" translate="yes" xml:space="preserve">
          <source>If a prototype display value is specified, the preferred size of the combo box is calculated by configuring the renderer with the prototype display value and obtaining its preferred size. Specifying the preferred display value is often useful when the combo box will be displaying large amounts of data. If no prototype display value has been specified, the renderer must be configured for each value from the model and its preferred size obtained, which can be relatively expensive.</source>
          <target state="translated">如果指定了原型显示值,则通过使用原型显示值配置渲染器并获得其首选尺寸来计算组合框的首选尺寸。当组合框将显示大量数据时,指定首选显示值通常很有用。如果没有指定原型显示值,则必须为模型中的每个值配置渲染器,并获得其首选尺寸,这可能会相对昂贵。</target>
        </trans-unit>
        <trans-unit id="c1b2c9101e57a9172a322b33cabb0f6d7243ba95" translate="yes" xml:space="preserve">
          <source>If a provider class has been installed in a jar file that is visible to the system class loader, and that jar file contains a provider-configuration file named &lt;code&gt;com.sun.net.httpserver.HttpServerProvider&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. The class is loaded and instantiated; if this process fails then an unspecified unchecked error or exception is thrown.</source>
          <target state="translated">如果提供程序类已安装在系统类加载器可见的jar文件中，并且该jar文件在资源目录 &lt;code&gt;META-INF/services&lt;/code&gt; 中包含名为 &lt;code&gt;com.sun.net.httpserver.HttpServerProvider&lt;/code&gt; 的提供程序配置文件，然后使用该文件中指定的第一个类名称。该类已加载并实例化；如果此过程失败，则会引发未指定的未经检查的错误或异常。</target>
        </trans-unit>
        <trans-unit id="9c4d961909cb1d8509dc7e80ad518ce9be7c9742" translate="yes" xml:space="preserve">
          <source>If a provider class has been installed in a jar file that is visible to the system class loader, and that jar file contains a provider-configuration file named &lt;code&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">如果提供程序类已安装在系统类加载器可见的jar文件中，并且该jar文件在资源目录 &lt;code&gt;META-INF/services&lt;/code&gt; 中包含名为 &lt;code&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/code&gt; 的提供程序配置文件，然后采用该文件中指定的第一个类名称。该类已加载并实例化；如果此过程失败，则会引发未指定的错误。</target>
        </trans-unit>
        <trans-unit id="fdfa29d9e3e5dd048f606f387c561e986beb3b1f" translate="yes" xml:space="preserve">
          <source>If a provider class has been installed in a jar file that is visible to the system class loader, and that jar file contains a provider-configuration file named &lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">如果提供程序类已安装在系统类加载器可见的jar文件中，并且该jar文件在资源目录 &lt;code&gt;META-INF/services&lt;/code&gt; 中包含名为 &lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt; 的提供程序配置文件，然后采用该文件中指定的第一个类名称。该类已加载并实例化；如果此过程失败，则会引发未指定的错误。</target>
        </trans-unit>
        <trans-unit id="40aff6af09d58df40b7fd9256b872b6c75872438" translate="yes" xml:space="preserve">
          <source>If a proxy class implements a non-public interface, then it will be defined in the same package as that interface. Otherwise, the package of a proxy class is also unspecified. Note that package sealing will not prevent a proxy class from being successfully defined in a particular package at runtime, and neither will classes already defined by the same class loader and the same package with particular signers.</source>
          <target state="translated">如果一个代理类实现了一个非公共接口,那么它将被定义在与该接口相同的包中。否则,代理类的包也是不指定的。需要注意的是,封包不会阻止代理类在运行时成功地定义在某个特定的包中,已经被同一个类加载器和同一个包的特定签名者定义的类也不会。</target>
        </trans-unit>
        <trans-unit id="796aaf5cfdf7fbf122008c7936a12a38e2eb7d28" translate="yes" xml:space="preserve">
          <source>If a proxy interface contains a method with the same name and parameter signature as the &lt;code&gt;hashCode&lt;/code&gt;, &lt;code&gt;equals&lt;/code&gt;, or &lt;code&gt;toString&lt;/code&gt; methods of &lt;code&gt;java.lang.Object&lt;/code&gt;, when such a method is invoked on a proxy instance, the &lt;code&gt;Method&lt;/code&gt; object passed to the invocation handler will have &lt;code&gt;java.lang.Object&lt;/code&gt; as its declaring class. In other words, the public, non-final methods of &lt;code&gt;java.lang.Object&lt;/code&gt; logically precede all of the proxy interfaces for the determination of which &lt;code&gt;Method&lt;/code&gt; object to pass to the invocation handler.</source>
          <target state="translated">如果代理接口包含与 &lt;code&gt;java.lang.Object&lt;/code&gt; 的 &lt;code&gt;hashCode&lt;/code&gt; ， &lt;code&gt;equals&lt;/code&gt; 或 &lt;code&gt;toString&lt;/code&gt; 方法具有相同名称和参数签名的方法，则在代理实例上调用该 &lt;code&gt;Method&lt;/code&gt; 传递给调用处理程序的Method对象将将 &lt;code&gt;java.lang.Object&lt;/code&gt; 作为其声明类。换句话说， &lt;code&gt;java.lang.Object&lt;/code&gt; 的公共非最终方法在逻辑上位于所有代理接口之前，以确定将哪个 &lt;code&gt;Method&lt;/code&gt; 对象传递给调用处理程序。</target>
        </trans-unit>
        <trans-unit id="1d6e567397cafeb01c674366adf43d058fe31b2c" translate="yes" xml:space="preserve">
          <source>If a pushed value is a primitive type, it may be converted to a reference by boxing conversion. If the bootstrap method is a variable arity method (its modifier bit &lt;code&gt;0x0080&lt;/code&gt; is set), then some or all of the arguments specified here may be collected into a trailing array parameter. (This is not a special rule, but rather a useful consequence of the interaction between &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; constants, the modifier bit for variable arity methods, and the &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;&lt;code&gt;asVarargsCollector&lt;/code&gt;&lt;/a&gt; transformation.)</source>
          <target state="translated">如果推入的值是原始类型，则可以通过装箱转换将其转换为引用。如果bootstrap方法是可变arity方法（已设置其修饰符位 &lt;code&gt;0x0080&lt;/code&gt; ），则此处指定的部分或全部自变量可被收集到尾随数组参数中。（这不是一个特殊的规则，而是 &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; 常量，可变&lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt; &lt;code&gt;asVarargsCollector&lt;/code&gt; &lt;/a&gt;方法的修饰符位和asVarargsCollector转换之间的交互作用的有用结果。）</target>
        </trans-unit>
        <trans-unit id="da20e235784a287eb944654e195ab8c9e647b20d" translate="yes" xml:space="preserve">
          <source>If a query is given then a question-mark character (&lt;code&gt;'?'&lt;/code&gt;) is appended, followed by the query. Any character that is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is quoted.</source>
          <target state="translated">如果给出查询，则会附加一个问号字符（ &lt;code&gt;'?'&lt;/code&gt; ），然后是查询。引用了不是&lt;a href=&quot;#legal-chars&quot;&gt;合法URI字符的&lt;/a&gt;任何字符。</target>
        </trans-unit>
        <trans-unit id="01ac00789cb87665540b49de8050c0c6e5eace44" translate="yes" xml:space="preserve">
          <source>If a redefined class has instances then all those instances will have the fields defined by the redefined class at the completion of the call. Preexisting fields will retain their previous values. Any new fields will have their default values; no instance initializers or constructors are run.</source>
          <target state="translated">如果一个重新定义的类有实例,那么所有这些实例将在调用完成时拥有由重新定义的类定义的字段。之前存在的字段将保留它们之前的值。任何新的字段都会有它们的默认值;不会运行实例初始化器或构造函数。</target>
        </trans-unit>
        <trans-unit id="fd66988b876e62bc3940fc9fa272fb4aa056a6e8" translate="yes" xml:space="preserve">
          <source>If a redefined method has active stack frames, those active frames continue to run the bytecodes of the original method. The redefined method will be used on new invokes.</source>
          <target state="translated">如果一个重新定义的方法有活动的堆栈框架,这些活动框架将继续运行原方法的字节码。重新定义的方法将用于新的调用。</target>
        </trans-unit>
        <trans-unit id="a353f255cddb3e5f45349ee73fbfca26933c3382" translate="yes" xml:space="preserve">
          <source>If a remaining element exists, performs the given action on it, returning &lt;code&gt;true&lt;/code&gt;; else returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果存在剩余元素，则对它执行给定的操作，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回true。否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3cb610dc9a4ccd073a7cbb93e3b0cbe1831a23f" translate="yes" xml:space="preserve">
          <source>If a remaining element exists, performs the given action on it, returning &lt;code&gt;true&lt;/code&gt;; else returns &lt;code&gt;false&lt;/code&gt;. If this Spliterator is &lt;a href=&quot;#ORDERED&quot;&gt;&lt;code&gt;ORDERED&lt;/code&gt;&lt;/a&gt; the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.</source>
          <target state="translated">如果存在剩余元素，则对它执行给定的操作，返回 &lt;code&gt;true&lt;/code&gt; ；否则返回 &lt;code&gt;false&lt;/code&gt; 。如果此分隔符为&lt;a href=&quot;#ORDERED&quot;&gt; &lt;code&gt;ORDERED&lt;/code&gt; &lt;/a&gt;，则按遇到顺序对下一个元素执行操作。该操作引发的异常将中继到调用方。</target>
        </trans-unit>
        <trans-unit id="24ef3bceba0cb2aab5212a59ddb1c10b5a5728ca" translate="yes" xml:space="preserve">
          <source>If a remaining element exists, performs the given action on it, returning &lt;code&gt;true&lt;/code&gt;; else returns &lt;code&gt;false&lt;/code&gt;. If this Spliterator is &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;ORDERED&lt;/code&gt;&lt;/a&gt; the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.</source>
          <target state="translated">如果存在剩余元素，则对它执行给定的操作，返回 &lt;code&gt;true&lt;/code&gt; ；否则返回true。否则返回 &lt;code&gt;false&lt;/code&gt; 。如果此分隔符为&lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;ORDERED&lt;/code&gt; &lt;/a&gt;，则按遇到顺序对下一个元素执行操作。该操作引发的异常将中继到调用方。</target>
        </trans-unit>
        <trans-unit id="e159606ce958fbbed771df76f4f0eabd266798cd" translate="yes" xml:space="preserve">
          <source>If a remaining element exists, performs the given action on it, returning &lt;code&gt;true&lt;/code&gt;; else returns &lt;code&gt;false&lt;/code&gt;. If this Spliterator is &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt; the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.</source>
          <target state="translated">如果存在剩余元素，则对它执行给定的操作，返回 &lt;code&gt;true&lt;/code&gt; ；否则返回true。否则返回 &lt;code&gt;false&lt;/code&gt; 。如果此Spliterator为&lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; ,则按&lt;/a&gt;遇到顺序对下一个元素执行操作。该操作引发的异常将中继到调用方。</target>
        </trans-unit>
        <trans-unit id="1839ce02fdf0a084101d2dedb7a7ec30b1eddf93" translate="yes" xml:space="preserve">
          <source>If a request cannot be queued, a new thread is created unless this would exceed maximumPoolSize, in which case, the task will be rejected.</source>
          <target state="translated">如果请求不能排队,则会创建一个新的线程,除非这将超过maximumPoolSize,在这种情况下,任务将被拒绝。</target>
        </trans-unit>
        <trans-unit id="8dcd6f2eb2f000d41479fe75ebb34b375f18a3c4" translate="yes" xml:space="preserve">
          <source>If a requested access is allowed, &lt;code&gt;checkPermission&lt;/code&gt; returns quietly. If denied, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果允许请求的访问，则 &lt;code&gt;checkPermission&lt;/code&gt; 安静地返回。如果被拒绝，则抛出 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="887186d0f2e36f1ee7e723c9cc603e07ae277a39" translate="yes" xml:space="preserve">
          <source>If a requested access is allowed, &lt;code&gt;checkPermission&lt;/code&gt; returns quietly. If denied, an AccessControlException is thrown. AccessControlException can also be thrown if the requested permission is of an incorrect type or contains an invalid value. Such information is given whenever possible. Suppose the current thread traversed m callers, in the order of caller 1 to caller 2 to caller m. Then caller m invoked the &lt;code&gt;checkPermission&lt;/code&gt; method. The &lt;code&gt;checkPermission&lt;/code&gt; method determines whether access is granted or denied based on the following algorithm:</source>
          <target state="translated">如果允许请求的访问，则 &lt;code&gt;checkPermission&lt;/code&gt; 安静地返回。如果被拒绝，则抛出AccessControlException。如果请求的权限类型不正确或包含无效值，也可能引发AccessControlException。尽可能提供此类信息。假设当前线程遍历m个调用者，从调用者1到调用者2到调用者m的顺序。然后，调用者m调用了 &lt;code&gt;checkPermission&lt;/code&gt; 方法。所述 &lt;code&gt;checkPermission&lt;/code&gt; 方法确定是否授予访问权或者基于以下算法被拒绝：</target>
        </trans-unit>
        <trans-unit id="d5d7514de1aef2342f9130eb5c0a7ab75fbed7e9" translate="yes" xml:space="preserve">
          <source>If a resource named &lt;code&gt;META-INF/services/java.rmi.server.RMIClassLoaderSpi&lt;/code&gt; is visible to the system class loader, then the contents of that resource are interpreted as a provider-configuration file, and the first class name specified in that file is used as the provider class name. If a class with that name can be loaded by the system class loader and that class is assignable to &lt;a href=&quot;rmiclassloaderspi&quot;&gt;&lt;code&gt;RMIClassLoaderSpi&lt;/code&gt;&lt;/a&gt; and has a public no-argument constructor, then that constructor will be invoked to create the provider instance. If the resource is found but a provider cannot be instantiated as described, then an unspecified &lt;code&gt;Error&lt;/code&gt; will be thrown to code that attempts to use &lt;code&gt;RMIClassLoader&lt;/code&gt;, indicating the failure to obtain a provider instance.</source>
          <target state="translated">如果系统类加载器可见名为 &lt;code&gt;META-INF/services/java.rmi.server.RMIClassLoaderSpi&lt;/code&gt; 的资源，则该资源的内容将解释为提供程序配置文件，并且在该文件中指定的第一个类名是用作提供程序类名称。如果具有该名称的类可以由系统类加载器加载，并且该类可分配给&lt;a href=&quot;rmiclassloaderspi&quot;&gt; &lt;code&gt;RMIClassLoaderSpi&lt;/code&gt; &lt;/a&gt;并且具有公共无参数构造函数，则将调用该构造函数来创建提供程序实例。如果找到了资源，但无法按所述实例化提供程序，则尝试使用 &lt;code&gt;RMIClassLoader&lt;/code&gt; 的代码将抛出未指定的 &lt;code&gt;Error&lt;/code&gt; ，指示获取提供程序实例失败。</target>
        </trans-unit>
        <trans-unit id="ef31bdb236c1be020d8ae03fbd2d0a2a44475408" translate="yes" xml:space="preserve">
          <source>If a result is passed to the combiner or finisher function, and the same object is not returned from that function, it is never used again.</source>
          <target state="translated">如果一个结果被传递给组合函数或终结函数,并且没有从该函数中返回相同的对象,那么它就再也不会被使用。</target>
        </trans-unit>
        <trans-unit id="4f6485f2810241e1f59964a0306f13fb66de588c" translate="yes" xml:space="preserve">
          <source>If a retransformed method has active stack frames, those active frames continue to run the bytecodes of the original method. The retransformed method will be used on new invokes.</source>
          <target state="translated">如果一个重构的方法有活动的堆栈帧,这些活动帧将继续运行原方法的字节码。重构后的方法将用于新的调用。</target>
        </trans-unit>
        <trans-unit id="14bfd111544b6485485ff232a946c27189f15782" translate="yes" xml:space="preserve">
          <source>If a scheme is given then it is appended to the result, followed by a colon character (&lt;code&gt;':'&lt;/code&gt;).</source>
          <target state="translated">如果给出了方案，则将其附加到结果后，然后是冒号（ &lt;code&gt;':'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e5292412b3ee897a572e5c7195ad6e65ff3c8f5e" translate="yes" xml:space="preserve">
          <source>If a scheme is given then the path, if also given, must either be empty or begin with a slash character (&lt;code&gt;'/'&lt;/code&gt;). Otherwise a component of the new URI may be left undefined by passing &lt;code&gt;null&lt;/code&gt; for the corresponding parameter or, in the case of the &lt;code&gt;port&lt;/code&gt; parameter, by passing &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">如果给出了方案，则路径（如果也给出）必须为空或以斜杠字符（ &lt;code&gt;'/'&lt;/code&gt; ）开头。否则，新的URI的组分可以通过使可能保持未定义 &lt;code&gt;null&lt;/code&gt; 用于相应的参数，或者在所述的情况下 &lt;code&gt;port&lt;/code&gt; 参数，通过使 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7eb7b84865919239961f0fcc50c50d09850970cc" translate="yes" xml:space="preserve">
          <source>If a scheme is given then the path, if also given, must either be empty or begin with a slash character (&lt;code&gt;'/'&lt;/code&gt;). Otherwise a component of the new URI may be left undefined by passing &lt;code&gt;null&lt;/code&gt; for the corresponding parameter.</source>
          <target state="translated">如果给出了方案，则路径（如果也给出）必须为空或以斜杠字符（ &lt;code&gt;'/'&lt;/code&gt; ）开头。否则，可以通过为相应的参数传递 &lt;code&gt;null&lt;/code&gt; 来使新URI的组件保持未定义状态。</target>
        </trans-unit>
        <trans-unit id="952cc358b56318941d6e6ab799e6dc4bef4fa5ce" translate="yes" xml:space="preserve">
          <source>If a scheme-specific part is given then it is appended. Any character that is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.</source>
          <target state="translated">如果给出了特定于方案的部分，则将其追加。任何字符不是一个&lt;a href=&quot;#legal-chars&quot;&gt;合法的URI字符&lt;/a&gt;被&lt;a href=&quot;#quote&quot;&gt;引用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="13bf2d89737ab4f9e4f3365daa8c4a8a75373b41" translate="yes" xml:space="preserve">
          <source>If a search filter with invalid variable substitutions is provided to this method, the result is undefined. When changes are made to this DirContext, the effect on enumerations returned by prior calls to this method is undefined.</source>
          <target state="translated">如果向本方法提供了一个带有无效变量替换的搜索过滤器,则结果是未定义的。当对这个DirContext进行更改时,对之前调用本方法返回的枚举的影响是未定义的。</target>
        </trans-unit>
        <trans-unit id="21aa33f224ffda676da8658661118410003b3a1d" translate="yes" xml:space="preserve">
          <source>If a second-based field is present, but &lt;code&gt;LocalTime&lt;/code&gt; was not parsed, then the resolver ensures that milli, micro and nano second values are available to meet the contract of &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. These will be set to zero if missing.</source>
          <target state="translated">如果存在基于秒的字段，但未解析 &lt;code&gt;LocalTime&lt;/code&gt; ，则解析器确保可以使用毫秒，微秒和纳秒的值来满足&lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 的约定&lt;/a&gt;。如果丢失，这些将被设置为零。</target>
        </trans-unit>
        <trans-unit id="e18b76d1fe5541051eb8484610c674d8c7326195" translate="yes" xml:space="preserve">
          <source>If a security check fails, the method throws &lt;a href=&quot;../../../java.base/java/lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果安全检查失败，则该方法将引发&lt;a href=&quot;../../../java.base/java/lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e97fd2ab90897223be3d44a61e5dac3ab116baef" translate="yes" xml:space="preserve">
          <source>If a security check fails, the method throws &lt;a href=&quot;../../java/lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果安全检查失败，则该方法将引发&lt;a href=&quot;../../java/lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="221b98a86674d566a65e15145ec84aa3ec7800d3" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkExec(java.lang.String)&quot;&gt;&lt;code&gt;checkExec&lt;/code&gt;&lt;/a&gt; method is invoked with the first component of the array &lt;code&gt;cmdarray&lt;/code&gt; as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">如果存在安全管理器，则使用数组 &lt;code&gt;cmdarray&lt;/code&gt; 的第一个组件作为其参数来调用其&lt;a href=&quot;securitymanager#checkExec(java.lang.String)&quot;&gt; &lt;code&gt;checkExec&lt;/code&gt; &lt;/a&gt;方法。这可能会导致引发&lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9dea5876966fa5396ec8f16c92b8e2f701b1ace9" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkExec-java.lang.String-&quot;&gt;&lt;code&gt;checkExec&lt;/code&gt;&lt;/a&gt; method is invoked with the first component of the array &lt;code&gt;cmdarray&lt;/code&gt; as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">如果存在安全管理器，则使用数组 &lt;code&gt;cmdarray&lt;/code&gt; 的第一个组件作为其参数来调用其&lt;a href=&quot;securitymanager#checkExec-java.lang.String-&quot;&gt; &lt;code&gt;checkExec&lt;/code&gt; &lt;/a&gt;方法。这可能会导致引发&lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f62df6f0d1a2b5825cab2050a4ec3aeebeb23980" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission(&quot;getenv.&quot;+name)&lt;/code&gt;&lt;/a&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown. If no exception is thrown the value of the variable &lt;code&gt;name&lt;/code&gt; is returned.</source>
          <target state="translated">如果存在安全管理器，则使用&lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission(&quot;getenv.&quot;+name)&lt;/code&gt; &lt;/a&gt;权限调用其&lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt;方法。这可能会导致引发&lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。如果没有抛出异常，则返回变量 &lt;code&gt;name&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="f1619a19a25be011be70c741cc0c43a2226d965a" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission(&quot;getenv.*&quot;)&lt;/code&gt;&lt;/a&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">如果存在安全管理器，则使用&lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission(&quot;getenv.*&quot;)&lt;/code&gt; &lt;/a&gt;权限调用其&lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt;方法。这可能会导致引发&lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e6026eb4f64490fabd44f7ccd2cafba99ebb3a0" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;getenv.*&quot;)&lt;/code&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">如果存在安全管理器，则使用&lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;getenv.*&quot;)&lt;/code&gt; 权限调用其&lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt;方法。这可能会导致引发&lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53168f421aa4d312fe84c343c76a94712c016bae" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;getenv.*&quot;)&lt;/code&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">如果存在安全管理器，则使用&lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;getenv.*&quot;)&lt;/code&gt; 权限调用其&lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt;方法。这可能会导致引发&lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2be9fb106610b30c8cb7f763862c74ced2b9d9be" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.&quot;+name)&lt;/code&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown. If no exception is thrown the value of the variable &lt;code&gt;name&lt;/code&gt; is returned.</source>
          <target state="translated">如果存在安全管理器，则会使用 &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.&quot;+name)&lt;/code&gt; （&amp;ldquo; getenv。&amp;rdquo; +名称）权限来调用其&lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt;方法。这可能会导致引发&lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。如果没有抛出异常，则返回变量 &lt;code&gt;name&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="799c889390e9c989ec60d735a9738bf280d5b1a4" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.*&quot;)&lt;/code&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">如果存在安全管理器，则使用 &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.*&quot;)&lt;/code&gt; （&amp;ldquo; getenv。*&amp;rdquo;）权限调用其&lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt;方法。这可能会导致引发&lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2278e2e0ebd6f6139022aa0c469fba80c78c2df6" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called with a &lt;code&gt;SQLPermission(&quot;deregisterDriver&quot;)&lt;/code&gt; permission to check that the caller is allowed to deregister a JDBC Driver.</source>
          <target state="translated">如果存在安全管理器，则首先使用 &lt;code&gt;SQLPermission(&quot;deregisterDriver&quot;)&lt;/code&gt; 权限调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法，以检查是否允许调用方注销JDBC驱动程序。</target>
        </trans-unit>
        <trans-unit id="44b4a416183d3454eaa000dc618d86aeea1d6cfb" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called with a &lt;code&gt;SQLPermission(&quot;setLog&quot;)&lt;/code&gt; permission to check that the caller is allowed to call &lt;code&gt;setLogStream&lt;/code&gt;.</source>
          <target state="translated">如果存在安全管理器，则首先使用 &lt;code&gt;SQLPermission(&quot;setLog&quot;)&lt;/code&gt; 权限调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法，以检查是否允许调用方调用 &lt;code&gt;setLogStream&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e94ff9d44d0443fcf36a01243a61054d009a97a3" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called with a &lt;code&gt;SQLPermission(&quot;setLog&quot;)&lt;/code&gt; permission to check that the caller is allowed to call &lt;code&gt;setLogWriter&lt;/code&gt;.</source>
          <target state="translated">如果存在安全管理器，则首先使用 &lt;code&gt;SQLPermission(&quot;setLog&quot;)&lt;/code&gt; 权限调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法，以检查是否允许调用方调用 &lt;code&gt;setLogWriter&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8aaf18bef197785207f9f2d71a7845893529d83" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then for each new association setup this method verifies that the associations source address and port number are permitted by the security manager's &lt;a href=&quot;../../../../../java.base/java/lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果已安装安全管理器，则对于每个新的关联设置，此方法将验证安全管理器的&lt;a href=&quot;../../../../../java.base/java/lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt;方法是否允许关联源地址和端口号。</target>
        </trans-unit>
        <trans-unit id="b24ae23ffa5fda73be9414955876b95df729521b" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then for each new association setup this method verifies that the given remote peers address and port number are permitted by the security manager's &lt;a href=&quot;../../../../../java.base/java/lang/securitymanager#checkConnect(java.lang.String,int)&quot;&gt;&lt;code&gt;checkConnect&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果已安装安全管理器，则对于每个新的关联设置，此方法将验证安全管理器的&lt;a href=&quot;../../../../../java.base/java/lang/securitymanager#checkConnect(java.lang.String,int)&quot;&gt; &lt;code&gt;checkConnect&lt;/code&gt; &lt;/a&gt;方法是否允许给定的远程对等地址和端口号。</target>
        </trans-unit>
        <trans-unit id="ac15baf176232c8309b6dd5f252ba3a1e35fdc0a" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then for each new association this method verifies that the address and port number of the assocaitions's remote peer are permitted by the security manager's &lt;a href=&quot;../../../../../java.base/java/lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果已安装安全管理器，则对于每个新的关联，此方法将验证安全管理器的&lt;a href=&quot;../../../../../java.base/java/lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt;方法是否允许分配的远程对等方的地址和端口号。</target>
        </trans-unit>
        <trans-unit id="2028007eeb90e55bc59c501b744cac8fe55582db" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then it is invoked to check access to the remote address. Specifically, if the given &lt;code&gt;address&lt;/code&gt; is a &lt;a href=&quot;inetaddress#isMulticastAddress()&quot;&gt;&lt;code&gt;multicast address&lt;/code&gt;&lt;/a&gt;, the security manager's &lt;a href=&quot;../lang/securitymanager#checkMulticast(java.net.InetAddress)&quot;&gt;&lt;code&gt;checkMulticast&lt;/code&gt;&lt;/a&gt; method is invoked with the given &lt;code&gt;address&lt;/code&gt;. Otherwise, the security manager's &lt;a href=&quot;../lang/securitymanager#checkConnect(java.lang.String,int)&quot;&gt;&lt;code&gt;checkConnect&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; methods are invoked, with the given &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;, to verify that datagrams are permitted to be sent and received respectively.</source>
          <target state="translated">如果已安装安全管理器，则将调用它来检查对远程地址的访问。具体来说，如果给定 &lt;code&gt;address&lt;/code&gt; 是&lt;a href=&quot;inetaddress#isMulticastAddress()&quot;&gt; &lt;code&gt;multicast address&lt;/code&gt; &lt;/a&gt;，则使用给定 &lt;code&gt;address&lt;/code&gt; 调用安全管理器的&lt;a href=&quot;../lang/securitymanager#checkMulticast(java.net.InetAddress)&quot;&gt; &lt;code&gt;checkMulticast&lt;/code&gt; &lt;/a&gt;方法。否则，将使用给定的 &lt;code&gt;address&lt;/code&gt; 和 &lt;code&gt;port&lt;/code&gt; 调用安全管理器的&lt;a href=&quot;../lang/securitymanager#checkConnect(java.lang.String,int)&quot;&gt; &lt;code&gt;checkConnect&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt;方法，以验证分别允许发送和接收数据报。</target>
        </trans-unit>
        <trans-unit id="a1659595caad59762dfff687e8404d52f631d93f" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then it is invoked to check access to the remote address. Specifically, if the given &lt;code&gt;address&lt;/code&gt; is a &lt;a href=&quot;inetaddress#isMulticastAddress--&quot;&gt;&lt;code&gt;multicast address&lt;/code&gt;&lt;/a&gt;, the security manager's &lt;a href=&quot;../lang/securitymanager#checkMulticast-java.net.InetAddress-&quot;&gt;&lt;code&gt;checkMulticast&lt;/code&gt;&lt;/a&gt; method is invoked with the given &lt;code&gt;address&lt;/code&gt;. Otherwise, the security manager's &lt;a href=&quot;../lang/securitymanager#checkConnect-java.lang.String-int-&quot;&gt;&lt;code&gt;checkConnect&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; methods are invoked, with the given &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;, to verify that datagrams are permitted to be sent and received respectively.</source>
          <target state="translated">如果已安装安全管理器，则将调用它来检查对远程地址的访问。具体来说，如果给定 &lt;code&gt;address&lt;/code&gt; 是&lt;a href=&quot;inetaddress#isMulticastAddress--&quot;&gt; &lt;code&gt;multicast address&lt;/code&gt; &lt;/a&gt;，则使用给定 &lt;code&gt;address&lt;/code&gt; 调用安全管理器的&lt;a href=&quot;../lang/securitymanager#checkMulticast-java.net.InetAddress-&quot;&gt; &lt;code&gt;checkMulticast&lt;/code&gt; &lt;/a&gt;方法。否则，将使用给定的 &lt;code&gt;address&lt;/code&gt; 和 &lt;code&gt;port&lt;/code&gt; 调用安全管理器的&lt;a href=&quot;../lang/securitymanager#checkConnect-java.lang.String-int-&quot;&gt; &lt;code&gt;checkConnect&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt;方法，以验证分别允许发送和接收数据报。</target>
        </trans-unit>
        <trans-unit id="5ec3f03393550037c5eee923c4fe6688b7340633" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then it verifies that the address and port number of the connection's remote endpoint are permitted by the security manager's &lt;a href=&quot;../../lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; method. The permission check is performed with privileges that are restricted by the calling context of this method. If the permission check fails then the connection is closed and the operation completes with a &lt;a href=&quot;../../lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果已安装安全管理器，则它将验证安全管理器的&lt;a href=&quot;../../lang/securitymanager#checkAccept(java.lang.String,int)&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt;方法是否允许连接的远程端点的地址和端口号。使用此方法的调用上下文限制的特权执行权限检查。如果权限检查失败，则连接将关闭，并且操作将以&lt;a href=&quot;../../lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 结束&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e62ef67bcdaa9aa21e31d7d487c07bd914492ed8" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then it verifies that the address and port number of the connection's remote endpoint are permitted by the security manager's &lt;a href=&quot;../../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; method. The permission check is performed with privileges that are restricted by the calling context of this method. If the permission check fails then the connection is closed and the operation completes with a &lt;a href=&quot;../../lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果已安装安全管理器，则它将验证安全管理器的&lt;a href=&quot;../../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt;方法是否允许连接的远程端点的地址和端口号。使用此方法的调用上下文限制的特权执行权限检查。如果权限检查失败，则连接将关闭，并且操作将以&lt;a href=&quot;../../lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 结束&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6578d6ef881b16cbb3b208f98bde343d77e471ed" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then this method verifies that its &lt;a href=&quot;../../../../../java.base/java/lang/securitymanager#checkConnect(java.lang.String,int)&quot;&gt;&lt;code&gt;checkConnect&lt;/code&gt;&lt;/a&gt; method permits connecting to the address and port number of the given remote peer.</source>
          <target state="translated">如果已安装安全管理器，则此方法将验证其&lt;a href=&quot;../../../../../java.base/java/lang/securitymanager#checkConnect(java.lang.String,int)&quot;&gt; &lt;code&gt;checkConnect&lt;/code&gt; &lt;/a&gt;方法是否允许连接到给定远程对等方的地址和端口号。</target>
        </trans-unit>
        <trans-unit id="3f4c4a17220ef5e90aea04a442f8bc074ebea3c6" translate="yes" xml:space="preserve">
          <source>If a security manager is already set in the group VM, this method first calls the security manager's &lt;code&gt;checkSetFactory&lt;/code&gt; method. This could result in a &lt;code&gt;SecurityException&lt;/code&gt;. If your application needs to set a different security manager, you must ensure that the policy file specified by the group's &lt;code&gt;ActivationGroupDesc&lt;/code&gt; grants the group the necessary permissions to set a new security manager. (Note: This will be necessary if your group downloads and sets a security manager).</source>
          <target state="translated">如果组VM中已经设置了安全管理器，则此方法首先调用安全管理器的 &lt;code&gt;checkSetFactory&lt;/code&gt; 方法。这可能会导致 &lt;code&gt;SecurityException&lt;/code&gt; 。如果您的应用程序需要设置其他安全管理器，则必须确保由组的 &lt;code&gt;ActivationGroupDesc&lt;/code&gt; 指定的策略文件授予该组必要的权限，以设置新的安全管理器。（注意：如果您的小组下载并设置了安全管理器，则这是必需的）。</target>
        </trans-unit>
        <trans-unit id="774bb30d85acccb9e7832ec0c0d531eef6b9e9b6" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the string &lt;code&gt;&quot;clearProviderProperties.&quot;+name&lt;/code&gt; (where &lt;code&gt;name&lt;/code&gt; is the provider name) to see if it's ok to clear this provider.</source>
          <target state="translated">如果启用了安全管理器，则使用字符串 &lt;code&gt;&quot;clearProviderProperties.&quot;+name&lt;/code&gt; （其中 &lt;code&gt;name&lt;/code&gt; 是提供程序名称）来调用其 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 方法，以查看是否可以清除此提供程序。</target>
        </trans-unit>
        <trans-unit id="f35e03213aea8a9f7162a4e6061b476c733a84f5" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the string &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt;, where &lt;code&gt;name&lt;/code&gt; is the provider name, to see if it's ok to set this provider's property values.</source>
          <target state="translated">如果启用了安全管理器，则使用字符串 &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt; 调用其 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 方法，其中 &lt;code&gt;name&lt;/code&gt; 是提供程序名称，以查看是否可以设置此提供程序的属性值。</target>
        </trans-unit>
        <trans-unit id="97b050d112e298b259d22c6b122aa0f103951b1a" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the string &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt;, where &lt;code&gt;name&lt;/code&gt; is the provider name, to see if it's ok to remove this provider's properties.</source>
          <target state="translated">如果启用了安全管理器，则使用字符串 &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt; （其中 &lt;code&gt;name&lt;/code&gt; 是提供程序名称）来调用其 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 方法，以查看是否可以删除此提供程序的属性。</target>
        </trans-unit>
        <trans-unit id="ece65adbb64e89095abfe9c2349b473bbf31084f" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the strings &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt; and &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt;, where &lt;code&gt;name&lt;/code&gt; is the provider name, to see if it's ok to set this provider's property values and remove this provider's properties.</source>
          <target state="translated">如果启用了安全管理器，则使用字符串 &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt; 和 &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt; （其中 &lt;code&gt;name&lt;/code&gt; 是提供者名称）来调用其 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 方法，以查看是否可以设置该提供者的属性值并将其删除提供者的属性。</target>
        </trans-unit>
        <trans-unit id="cf20f936473755f39be868cd9845f771cb103a28" translate="yes" xml:space="preserve">
          <source>If a security manager is installed and the specified &lt;code&gt;AccessControlContext&lt;/code&gt; was not created by system code and the caller's &lt;code&gt;ProtectionDomain&lt;/code&gt; has not been granted the &quot;createAccessControlContext&quot; &lt;a href=&quot;securitypermission&quot;&gt;&lt;code&gt;SecurityPermission&lt;/code&gt;&lt;/a&gt;, then the action is performed with no permissions.</source>
          <target state="translated">如果安装了安全管理器，并且系统代码未创建指定的 &lt;code&gt;AccessControlContext&lt;/code&gt; ,并且未向调用方的 &lt;code&gt;ProtectionDomain&lt;/code&gt; 授予&amp;ldquo; createAccessControlContext&amp;rdquo; &lt;a href=&quot;securitypermission&quot;&gt; &lt;code&gt;SecurityPermission&lt;/code&gt; &lt;/a&gt;，则将在没有权限的情况下执行操作。</target>
        </trans-unit>
        <trans-unit id="dd8d2c5d44a3aa942e5df643c8cc56f8591079d9" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission before returning a reference to an existing file system. In the case of the &lt;a href=&quot;#getDefault()&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">如果安装了安全管理器，则提供程序实现可能需要在返回对现有文件系统的引用之前检查权限。对于&lt;a href=&quot;#getDefault()&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;文件系统，不需要权限检查。</target>
        </trans-unit>
        <trans-unit id="e3b5b0dd2a87988fc996fb7a1ac5c2588c90d706" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission before returning a reference to an existing file system. In the case of the &lt;a href=&quot;../filesystems#getDefault()&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">如果安装了安全管理器，则提供程序实现可能需要在返回对现有文件系统的引用之前检查权限。对于&lt;a href=&quot;../filesystems#getDefault()&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;文件系统，不需要权限检查。</target>
        </trans-unit>
        <trans-unit id="71505a5d56a109fcf20595110953779d866b2e80" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission before returning a reference to an existing file system. In the case of the &lt;a href=&quot;../filesystems#getDefault--&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">如果安装了安全管理器，则提供程序实现可能需要在返回对现有文件系统的引用之前检查权限。对于&lt;a href=&quot;../filesystems#getDefault--&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;文件系统，不需要权限检查。</target>
        </trans-unit>
        <trans-unit id="94817a0d003779bd7b3676c9e779ce36983364b9" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission before returning a reference to an existing file system. In the case of the &lt;a href=&quot;filesystems#getDefault--&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">如果安装了安全管理器，则提供程序实现可能需要在返回对现有文件系统的引用之前检查权限。对于&lt;a href=&quot;filesystems#getDefault--&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;文件系统，不需要权限检查。</target>
        </trans-unit>
        <trans-unit id="01e04465cdbf974bbd5f8ba0a91561e8dc8debf9" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission. In the case of the &lt;a href=&quot;../filesystems#getDefault()&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">如果安装了安全管理器，则提供程序实现可能需要检查权限。对于&lt;a href=&quot;../filesystems#getDefault()&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;文件系统，不需要权限检查。</target>
        </trans-unit>
        <trans-unit id="8d8b4d6a644688d37bf4f42e678ef49d5a579de5" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission. In the case of the &lt;a href=&quot;../filesystems#getDefault--&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">如果安装了安全管理器，则提供程序实现可能需要检查权限。对于&lt;a href=&quot;../filesystems#getDefault--&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;文件系统，不需要权限检查。</target>
        </trans-unit>
        <trans-unit id="143f1755f82fd54bafd1bbd2d643a9b8c831879a" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, and if a method is called which results in an attempt to open a connection, the caller must possess either:</source>
          <target state="translated">如果安装了安全管理器,并且如果调用的方法导致试图打开一个连接,那么调用者必须具备以下两种情况之一。</target>
        </trans-unit>
        <trans-unit id="b0d87efa51aa6969d6f0da372f01e957e877983c" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, and if a method is called which results in an attempt to open a connection, the caller must possess either:-</source>
          <target state="translated">如果安装了安全管理器,并且如果调用的方法导致试图打开一个连接,调用者必须具备以下两种情况:--------。</target>
        </trans-unit>
        <trans-unit id="1d45c9e8f126e9404c3d2b7c327aa338dc699327" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, in order to create a &lt;code&gt;GSSName&lt;/code&gt; that contains a Kerberos name element without providing its realm, a &lt;a href=&quot;../../../javax/security/auth/kerberos/servicepermission&quot;&gt;&lt;code&gt;ServicePermission&lt;/code&gt;&lt;/a&gt; must be granted and the service principal of the permission must minimally be inside the Kerberos name element's realm. For example, if the result of &lt;a href=&quot;gssmanager#createName(java.lang.String,org.ietf.jgss.Oid)&quot;&gt;&lt;code&gt;createName(&quot;user&quot;, NT_USER_NAME)&lt;/code&gt;&lt;/a&gt; contains a Kerberos name element &lt;code&gt;user@EXAMPLE.COM&lt;/code&gt;, then a &lt;code&gt;ServicePermission&lt;/code&gt; with service principal &lt;code&gt;host/www.example.com@EXAMPLE.COM&lt;/code&gt; (and any action) must be granted. Otherwise, the creation will throw a &lt;a href=&quot;gssexception&quot;&gt;&lt;code&gt;GSSException&lt;/code&gt;&lt;/a&gt; containing the &lt;code&gt;GSSException.FAILURE&lt;/code&gt; error code.</source>
          <target state="translated">如果安装了安全管理器，则为了创建包含Kerberos名称元素的 &lt;code&gt;GSSName&lt;/code&gt; 而不提供其领域，必须授予&lt;a href=&quot;../../../javax/security/auth/kerberos/servicepermission&quot;&gt; &lt;code&gt;ServicePermission&lt;/code&gt; ,&lt;/a&gt;并且该权限的服务主体必须至少位于Kerberos name元素的领域内。例如，如果&lt;a href=&quot;gssmanager#createName(java.lang.String,org.ietf.jgss.Oid)&quot;&gt; &lt;code&gt;createName(&quot;user&quot;, NT_USER_NAME)&lt;/code&gt; &lt;/a&gt;包含Kerberos名称元素 &lt;code&gt;user@EXAMPLE.COM&lt;/code&gt; ，则必须使用具有服务主体 &lt;code&gt;host/www.example.com@EXAMPLE.COM&lt;/code&gt; 的 &lt;code&gt;ServicePermission&lt;/code&gt; （以及任何操作）的确。否则，创建将抛出一个&lt;a href=&quot;gssexception&quot;&gt; &lt;code&gt;GSSException&lt;/code&gt; ,并&lt;/a&gt;包含 &lt;code&gt;GSSException.FAILURE&lt;/code&gt; 错误代码。</target>
        </trans-unit>
        <trans-unit id="2cf065c4d0904a0cb44740e8e70a65fae00e790f" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, the caller must have a &lt;a href=&quot;authpermission#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;AuthPermission(&quot;modifyPrincipals&quot;)&lt;/code&gt;&lt;/a&gt; permission to modify the returned set, or a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果安装了安全管理器，则调用者必须具有&lt;a href=&quot;authpermission#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;AuthPermission(&quot;modifyPrincipals&quot;)&lt;/code&gt; &lt;/a&gt;权限才能修改返回的集合，否则将抛出 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d705115f8db059c39a12d168cf6ae0c2ae12a28" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, the caller must have a &lt;a href=&quot;authpermission#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;AuthPermission(&quot;modifyPrivateCredentials&quot;)&lt;/code&gt;&lt;/a&gt; permission to modify the returned set, or a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果安装了安全管理器，则调用者必须具有&lt;a href=&quot;authpermission#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;AuthPermission(&quot;modifyPrivateCredentials&quot;)&lt;/code&gt; &lt;/a&gt;权限才能修改返回的集合，否则将抛出 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="277c3aef4348bc841723740d60214a68d5615799" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, the caller must have a &lt;a href=&quot;authpermission#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;AuthPermission(&quot;modifyPublicCredentials&quot;)&lt;/code&gt;&lt;/a&gt; permission to modify the returned set, or a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果安装了安全管理器，则调用者必须具有&lt;a href=&quot;authpermission#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;AuthPermission(&quot;modifyPublicCredentials&quot;)&lt;/code&gt; &lt;/a&gt;权限才能修改返回的集，否则将抛出 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf6549af10b8e67c5c26a129534c96167f417bb6" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, the caller must have a &lt;a href=&quot;privatecredentialpermission&quot;&gt;&lt;code&gt;PrivateCredentialPermission&lt;/code&gt;&lt;/a&gt; to access all of the requested Credentials, or a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果安装了安全管理器，则调用者必须具有&lt;a href=&quot;privatecredentialpermission&quot;&gt; &lt;code&gt;PrivateCredentialPermission&lt;/code&gt; &lt;/a&gt;才能访问所有请求的凭据，否则将引发 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e951d48b2804e2b72e838d29cf84001eb9605eaa" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, this constructor will check for the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked directly or indirectly by the constructor of a subclass which overrides the ObjectInputStream.readFields or ObjectInputStream.readUnshared methods.</source>
          <target state="translated">如果安装了安全管理器,当子类的构造函数直接或间接调用该构造函数时,该构造函数将检查 &quot;enableSubclassImplementation &quot;SerializablePermission是否覆盖了ObjectInputStream.readFields或ObjectInputStream.readUnshared方法。</target>
        </trans-unit>
        <trans-unit id="97bae6ffb96e1d4b174839ef22d4e1aad74be094" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, this constructor will check for the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked directly or indirectly by the constructor of a subclass which overrides the ObjectOutputStream.putFields or ObjectOutputStream.writeUnshared methods.</source>
          <target state="translated">如果安装了安全管理器,当子类的构造函数直接或间接调用该构造函数时,该构造函数将检查 &quot;enableSubclassImplementation &quot;SerializablePermission是否覆盖了ObjectOutputStream.putFields或ObjectOutputStream.writeUnshared方法。</target>
        </trans-unit>
        <trans-unit id="d92bb3509ac791abbf0139a9c7f57cc935e83b78" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, this method is caller sensitive. During any invocation of the target method handle via the returned wrapper, the original creator of the wrapper (the caller) will be visible to context checks requested by the security manager.</source>
          <target state="translated">如果安装了安全管理器,这个方法是调用者敏感的。在通过返回的包装器调用目标方法句柄的过程中,包装器的原始创建者(调用者)将在安全管理器要求的上下文检查中可见。</target>
        </trans-unit>
        <trans-unit id="747d29f4f67e3454f8c693e4e2a5bfb35d6699fd" translate="yes" xml:space="preserve">
          <source>If a security manager is present and the current lookup object does not have &lt;a href=&quot;#hasFullPrivilegeAccess()&quot;&gt;full privilege access&lt;/a&gt;, then &lt;a href=&quot;#defineClass(byte%5B%5D)&quot;&gt;&lt;code&gt;defineClass&lt;/code&gt;&lt;/a&gt; calls &lt;a href=&quot;../securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;smgr.checkPermission&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;RuntimePermission(&quot;defineClass&quot;)&lt;/code&gt;.</source>
          <target state="translated">如果存在安全管理器，并且当前的查找对象没有&lt;a href=&quot;#hasFullPrivilegeAccess()&quot;&gt;完全特权访问权&lt;/a&gt;，则&lt;a href=&quot;#defineClass(byte%5B%5D)&quot;&gt; &lt;code&gt;defineClass&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;smgr.checkPermission&lt;/code&gt; &lt;/a&gt;使用 &lt;code&gt;RuntimePermission(&quot;defineClass&quot;)&lt;/code&gt; 调用smgr.checkPermission。</target>
        </trans-unit>
        <trans-unit id="65b3db194eedd1b31a2888097e8d1e43da0bb0ea" translate="yes" xml:space="preserve">
          <source>If a security manager is present and the given &lt;code&gt;option&lt;/code&gt; is &lt;a href=&quot;stackwalker.option#RETAIN_CLASS_REFERENCE&quot;&gt;&lt;code&gt;Option.RETAIN_CLASS_REFERENCE&lt;/code&gt;&lt;/a&gt;, it calls its &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method for &lt;code&gt;RuntimePermission(&quot;getStackWalkerWithClassReference&quot;)&lt;/code&gt;.</source>
          <target state="translated">如果存在安全管理器且给定的 &lt;code&gt;option&lt;/code&gt; 为&lt;a href=&quot;stackwalker.option#RETAIN_CLASS_REFERENCE&quot;&gt; &lt;code&gt;Option.RETAIN_CLASS_REFERENCE&lt;/code&gt; &lt;/a&gt;，则它将为 &lt;code&gt;RuntimePermission(&quot;getStackWalkerWithClassReference&quot;)&lt;/code&gt; 调用其&lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="1670cbe57d528fea2424601e7c9d68d106c819ac" translate="yes" xml:space="preserve">
          <source>If a security manager is present and the given &lt;code&gt;options&lt;/code&gt; contains &lt;a href=&quot;stackwalker.option#RETAIN_CLASS_REFERENCE&quot;&gt;&lt;code&gt;Option.RETAIN_CLASS_REFERENCE&lt;/code&gt;&lt;/a&gt;, it calls its &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method for &lt;code&gt;RuntimePermission(&quot;getStackWalkerWithClassReference&quot;)&lt;/code&gt;.</source>
          <target state="translated">如果存在安全管理器，并且给定的 &lt;code&gt;options&lt;/code&gt; 包含&lt;a href=&quot;stackwalker.option#RETAIN_CLASS_REFERENCE&quot;&gt; &lt;code&gt;Option.RETAIN_CLASS_REFERENCE&lt;/code&gt; &lt;/a&gt;，它将为 &lt;code&gt;RuntimePermission(&quot;getStackWalkerWithClassReference&quot;)&lt;/code&gt; 调用其&lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="f235ec91b53b01416e59e95836269f2b24928eee" translate="yes" xml:space="preserve">
          <source>If a security manager is present then security checks are performed by the HTTP Client's sending methods. An appropriate &lt;a href=&quot;../../../../java.base/java/net/urlpermission&quot;&gt;&lt;code&gt;URLPermission&lt;/code&gt;&lt;/a&gt; is required to access the destination server, and proxy server if one has been configured. The form of the &lt;code&gt;URLPermission&lt;/code&gt; required to access a proxy has a &lt;code&gt;method&lt;/code&gt; parameter of &lt;code&gt;&quot;CONNECT&quot;&lt;/code&gt; (for all kinds of proxying) and a &lt;code&gt;URL&lt;/code&gt; string of the form &lt;code&gt;&quot;socket://host:port&quot;&lt;/code&gt; where host and port specify the proxy's address.</source>
          <target state="translated">如果存在安全管理器，则将通过HTTP客户端的发送方法执行安全检查。需要适当的&lt;a href=&quot;../../../../java.base/java/net/urlpermission&quot;&gt; &lt;code&gt;URLPermission&lt;/code&gt; &lt;/a&gt;才能访问目标服务器和代理服务器（如果已配置）。访问代理所需的 &lt;code&gt;URLPermission&lt;/code&gt; 形式具有 &lt;code&gt;method&lt;/code&gt; 参数 &lt;code&gt;&quot;CONNECT&quot;&lt;/code&gt; （用于各种代理）和形式为 &lt;code&gt;&quot;socket://host:port&quot;&lt;/code&gt; 的 &lt;code&gt;URL&lt;/code&gt; 字符串，其中主机和端口指定代理的地址。</target>
        </trans-unit>
        <trans-unit id="d8a665c3d954d0fc47740977c830812c0a85b298" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the caller's class loader is not null and the caller's class loader is not the same as or an ancestor of the class loader for the class whose class loader is requested, then this method calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to ensure it's ok to access the class loader for the class.</source>
          <target state="translated">如果存在安全管理器，并且调用方的类加载器不为null且调用者的类加载器与请求其类加载器的类的祖先或类加载器的祖先不同，则此方法调用安全管理器的 &lt;code&gt;checkPermission&lt;/code&gt; 方法具有 &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; 权限，以确保可以访问该类的类加载器。</target>
        </trans-unit>
        <trans-unit id="fae23e2153f023848b4e6ff03b38daa20b992dd7" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the invoker's class loader is not &lt;code&gt;null&lt;/code&gt; and is not an ancestor of this class loader, then this method invokes the security manager's &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method with a &lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; permission to verify access to the parent class loader is permitted. If not, a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果存在安全管理器，并且调用者的类加载器不为 &lt;code&gt;null&lt;/code&gt; 且不是该类加载器的祖先，则此方法将调用具有&lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt; &lt;/a&gt;权限的安全管理器的&lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt; &lt;/a&gt;方法，以验证对父类的访问允许加载程序。否则，将抛出 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d340f476b6c3ae11657fddd0392b049fcfa29b4e" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the invoker's class loader is not &lt;code&gt;null&lt;/code&gt; and is not the same as or an ancestor of the context class loader, then this method invokes the security manager's &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;getClassLoader&quot;)&lt;/code&gt; permission to verify that retrieval of the context class loader is permitted.</source>
          <target state="translated">如果存在安全管理器，并且调用者的类加载器不为 &lt;code&gt;null&lt;/code&gt; 且与上下文类加载器的祖先或父类不相同，则此方法将调用具有&lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;getClassLoader&quot;)&lt;/code&gt; 权限的安全管理器的&lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt;方法以进行验证允许检索上下文类加载器。</target>
        </trans-unit>
        <trans-unit id="9a7bab9ae3bc48ceb4d26ca9f16abf87e363a12c" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the invoker's class loader is not &lt;code&gt;null&lt;/code&gt; and the invoker's class loader is not the same as or an ancestor of the system class loader, then this method invokes the security manager's &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method with a &lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; permission to verify access to the system class loader. If not, a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果存在安全管理器，并且调用者的类加载器不为 &lt;code&gt;null&lt;/code&gt; ，并且调用者的类加载器与系统类加载器不同，或者其祖先，则此方法使用&lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt; &lt;/a&gt;调用安全管理器的&lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt; &lt;/a&gt;方法。）的权限，以验证对系统类加载器的访问权限。否则，将引发 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c67e806fb2de6670301476b333eef74af4db7033" translate="yes" xml:space="preserve">
          <source>If a security manager is present, its &lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is invoked with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;
 (&quot;setContextClassLoader&quot;)&lt;/code&gt; permission to see if setting the context ClassLoader is permitted.</source>
          <target state="translated">如果存在安全管理器，则会使用&lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt; (&quot;setContextClassLoader&quot;)&lt;/code&gt; 权限调用其&lt;a href=&quot;securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt;方法，以查看是否允许设置上下文ClassLoader。</target>
        </trans-unit>
        <trans-unit id="459bc04b32cd4cdbb41e230932994ba0a7971ad8" translate="yes" xml:space="preserve">
          <source>If a security manager is present, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is invoked with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;setContextClassLoader&quot;)&lt;/code&gt; permission to see if setting the context ClassLoader is permitted.</source>
          <target state="translated">如果存在安全管理器，则会使用&lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;setContextClassLoader&quot;)&lt;/code&gt; 权限调用其&lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt;方法，以查看是否允许设置上下文ClassLoader。</target>
        </trans-unit>
        <trans-unit id="78cdc9b5f5eda6e8145be430c39c840d355e0828" translate="yes" xml:space="preserve">
          <source>If a security manager is present, member and class lookups are subject to additional checks. From one to three calls are made to the security manager. Any of these calls can refuse access by throwing a &lt;a href=&quot;../securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;. Define &lt;code&gt;smgr&lt;/code&gt; as the security manager, &lt;code&gt;lookc&lt;/code&gt; as the lookup class of the current lookup object, &lt;code&gt;refc&lt;/code&gt; as the containing class in which the member is being sought, and &lt;code&gt;defc&lt;/code&gt; as the class in which the member is actually defined. (If a class or other type is being accessed, the &lt;code&gt;refc&lt;/code&gt; and &lt;code&gt;defc&lt;/code&gt; values are the class itself.) The value &lt;code&gt;lookc&lt;/code&gt; is defined as &lt;em&gt;not present&lt;/em&gt; if the current lookup object does not have &lt;a href=&quot;#hasFullPrivilegeAccess()&quot;&gt;full privilege access&lt;/a&gt;. The calls are made according to the following rules:</source>
          <target state="translated">如果存在安全管理器，则对成员和类的查找进行其他检查。会向安全管理器发出1到3个电话。这些调用中的任何一个都可以通过引发&lt;a href=&quot;../securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;拒绝访问。将 &lt;code&gt;smgr&lt;/code&gt; 定义为安全管理器，将 &lt;code&gt;lookc&lt;/code&gt; 定义为当前查找对象的查找类，将 &lt;code&gt;refc&lt;/code&gt; 定义为在其中查找成员的包含类，将 &lt;code&gt;defc&lt;/code&gt; 定义为实际在其中定义成员的类。（如果正在访问一个类或其他类型，则 &lt;code&gt;refc&lt;/code&gt; 和 &lt;code&gt;defc&lt;/code&gt; 值就是该类本身。）值 &lt;code&gt;lookc&lt;/code&gt; 定义为&lt;em&gt;不存在&lt;/em&gt;如果当前查找对象没有&lt;a href=&quot;#hasFullPrivilegeAccess()&quot;&gt;完全特权访问权&lt;/a&gt;。呼叫是根据以下规则进行的：</target>
        </trans-unit>
        <trans-unit id="e624bb62f16bc940f5cf53be80f8d86fd6570fa0" translate="yes" xml:space="preserve">
          <source>If a security manager is present, member and class lookups are subject to additional checks. From one to three calls are made to the security manager. Any of these calls can refuse access by throwing a &lt;a href=&quot;../securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;. Define &lt;code&gt;smgr&lt;/code&gt; as the security manager, &lt;code&gt;lookc&lt;/code&gt; as the lookup class of the current lookup object, &lt;code&gt;refc&lt;/code&gt; as the containing class in which the member is being sought, and &lt;code&gt;defc&lt;/code&gt; as the class in which the member is actually defined. (If a class or other type is being accessed, the &lt;code&gt;refc&lt;/code&gt; and &lt;code&gt;defc&lt;/code&gt; values are the class itself.) The value &lt;code&gt;lookc&lt;/code&gt; is defined as &lt;em&gt;not present&lt;/em&gt; if the current lookup object does not have &lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;private access&lt;/a&gt;. The calls are made according to the following rules:</source>
          <target state="translated">如果存在安全管理器，则对成员和类的查找进行其他检查。会向安全管理器发出1到3个电话。这些调用中的任何一个都可以通过引发&lt;a href=&quot;../securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;拒绝访问。将 &lt;code&gt;smgr&lt;/code&gt; 定义为安全管理器，将 &lt;code&gt;lookc&lt;/code&gt; 定义为当前查找对象的查找类，将 &lt;code&gt;refc&lt;/code&gt; 定义为在其中查找成员的包含类，将 &lt;code&gt;defc&lt;/code&gt; 定义为实际在其中定义成员的类。（如果正在访问一个类或其他类型，则 &lt;code&gt;refc&lt;/code&gt; 和 &lt;code&gt;defc&lt;/code&gt; 值就是该类本身。）值 &lt;code&gt;lookc&lt;/code&gt; 定义为&lt;em&gt;不存在&lt;/em&gt;如果当前查找对象没有&lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;私有访问权限&lt;/a&gt;。呼叫是根据以下规则进行的：</target>
        </trans-unit>
        <trans-unit id="944477a6804441726a3b8f252f78eae83726e3a4" translate="yes" xml:space="preserve">
          <source>If a security manager is present, member lookups are subject to additional checks. From one to three calls are made to the security manager. Any of these calls can refuse access by throwing a &lt;a href=&quot;../securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;. Define &lt;code&gt;smgr&lt;/code&gt; as the security manager, &lt;code&gt;lookc&lt;/code&gt; as the lookup class of the current lookup object, &lt;code&gt;refc&lt;/code&gt; as the containing class in which the member is being sought, and &lt;code&gt;defc&lt;/code&gt; as the class in which the member is actually defined. The value &lt;code&gt;lookc&lt;/code&gt; is defined as &lt;em&gt;not present&lt;/em&gt; if the current lookup object does not have &lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;private access&lt;/a&gt;. The calls are made according to the following rules:</source>
          <target state="translated">如果存在安全管理器，则对成员查找进行其他检查。会向安全管理器发出1到3个电话。这些调用中的任何一个都可以抛出&lt;a href=&quot;../securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;来拒绝访问。将 &lt;code&gt;smgr&lt;/code&gt; 定义为安全管理器，将 &lt;code&gt;lookc&lt;/code&gt; 定义为当前查找对象的查找类，将 &lt;code&gt;refc&lt;/code&gt; 定义为在其中查找成员的包含类，将 &lt;code&gt;defc&lt;/code&gt; 定义为实际在其中定义成员的类。如果当前查找对象没有&lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;私有访问权限&lt;/a&gt;&lt;em&gt;，&lt;/em&gt;则值 &lt;code&gt;lookc&lt;/code&gt; 定义为&lt;em&gt;不存在&lt;/em&gt;。呼叫是根据以下规则进行的：</target>
        </trans-unit>
        <trans-unit id="d370048efbe2c926a15f430ef8f627c5e5941de0" translate="yes" xml:space="preserve">
          <source>If a sequence of nodes is needed, the node contained in the &lt;code&gt;DOMStructure&lt;/code&gt; is the first node of the sequence and successive nodes can be accessed by invoking &lt;a href=&quot;../../../../../java.xml/org/w3c/dom/node#getNextSibling()&quot;&gt;&lt;code&gt;Node.getNextSibling()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果需要一个节点序列，则 &lt;code&gt;DOMStructure&lt;/code&gt; 中包含的节点是该序列的第一个节点，可以通过调用&lt;a href=&quot;../../../../../java.xml/org/w3c/dom/node#getNextSibling()&quot;&gt; &lt;code&gt;Node.getNextSibling()&lt;/code&gt; &lt;/a&gt;来访问连续的节点。</target>
        </trans-unit>
        <trans-unit id="7d5767eefb23c399e8079e08277dddc58e247bf9" translate="yes" xml:space="preserve">
          <source>If a serializable class does not explicitly declare a serialVersionUID, then the serialization runtime will calculate a default serialVersionUID value for that class based on various aspects of the class, as described in the Java Object Serialization Specification. This specification defines the serialVersionUID of an enum type to be 0L. However, it is &lt;em&gt;strongly recommended&lt;/em&gt; that all serializable classes other than enum types explicitly declare serialVersionUID values, since the default serialVersionUID computation is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected &lt;code&gt;InvalidClassException&lt;/code&gt;s during deserialization. Therefore, to guarantee a consistent serialVersionUID value across different java compiler implementations, a serializable class must declare an explicit serialVersionUID value. It is also strongly advised that explicit serialVersionUID declarations use the &lt;code&gt;private&lt;/code&gt; modifier where possible, since such declarations apply only to the immediately declaring class--serialVersionUID fields are not useful as inherited members. Array classes cannot declare an explicit serialVersionUID, so they always have the default computed value, but the requirement for matching serialVersionUID values is waived for array classes.</source>
          <target state="translated">如果可序列化的类未明确声明serialVersionUID，则序列化运行时将根据该类的各个方面为该类计算默认的serialVersionUID值，如Java对象序列化规范中所述。该规范将枚举类型的serialVersionUID定义为0L。但是，&lt;em&gt;强烈建议&lt;/em&gt;除枚举类型之外的所有可序列化类都明确声明serialVersionUID值，因为默认的serialVersionUID计算对类细节高度敏感，而类细节可能因编译器实现而异，因此可能导致意外的 &lt;code&gt;InvalidClassException&lt;/code&gt; 在反序列化过程中。因此，为了保证不同Java编译器实现之间的serialVersionUID值一致，可序列化的类必须声明一个显式的serialVersionUID值。还强烈建议显式serialVersionUID声明在可能的情况下使用 &lt;code&gt;private&lt;/code&gt; 修饰符，因为此类声明仅适用于立即声明的类-serialVersionUID字段作为继承成员没有用。数组类无法声明显式的serialVersionUID，因此它们始终具有默认的计算值，但是对于数组类，无需匹配serialVersionUID值。</target>
        </trans-unit>
        <trans-unit id="401c7fd6161f35837fa11c7a250b7f821910874a" translate="yes" xml:space="preserve">
          <source>If a serializable class does not explicitly declare a serialVersionUID, then the serialization runtime will calculate a default serialVersionUID value for that class based on various aspects of the class, as described in the Java(TM) Object Serialization Specification. However, it is &lt;em&gt;strongly recommended&lt;/em&gt; that all serializable classes explicitly declare serialVersionUID values, since the default serialVersionUID computation is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected &lt;code&gt;InvalidClassException&lt;/code&gt;s during deserialization. Therefore, to guarantee a consistent serialVersionUID value across different java compiler implementations, a serializable class must declare an explicit serialVersionUID value. It is also strongly advised that explicit serialVersionUID declarations use the &lt;code&gt;private&lt;/code&gt; modifier where possible, since such declarations apply only to the immediately declaring class--serialVersionUID fields are not useful as inherited members. Array classes cannot declare an explicit serialVersionUID, so they always have the default computed value, but the requirement for matching serialVersionUID values is waived for array classes.</source>
          <target state="translated">如果可序列化的类未明确声明serialVersionUID，则序列化运行时将根据该类的各个方面，为该类计算默认的serialVersionUID值，如Java&amp;trade;对象序列化规范中所述。但是，&lt;em&gt;强烈建议&lt;/em&gt;所有可序列化的类显式声明serialVersionUID值，因为默认的serialVersionUID计算对类详细信息高度敏感，类详细信息可能会因编译器的实现而有所不同，因此可能导致意外的 &lt;code&gt;InvalidClassException&lt;/code&gt; 在反序列化过程中。因此，为了保证不同Java编译器实现之间的serialVersionUID值一致，可序列化的类必须声明一个显式的serialVersionUID值。还强烈建议显式serialVersionUID声明在可能的情况下使用 &lt;code&gt;private&lt;/code&gt; 修饰符，因为此类声明仅适用于立即声明的类-serialVersionUID字段作为继承成员不起作用。数组类无法声明显式的serialVersionUID，因此它们始终具有默认的计算值，但是对于数组类，无需匹配serialVersionUID值。</target>
        </trans-unit>
        <trans-unit id="b8a284373bcb59e24e39e3dac459820aaa1124e2" translate="yes" xml:space="preserve">
          <source>If a service only supports registration for existing targets, an attempt to register for a nonexistent target results in a &lt;code&gt;NameNotFoundException&lt;/code&gt; being thrown as early as possible, preferably at the time &lt;code&gt;addNamingListener()&lt;/code&gt; is called, or if that is not possible, the listener will receive the exception through the &lt;code&gt;NamingExceptionEvent&lt;/code&gt;.</source>
          <target state="translated">如果服务仅支持对现有目标的注册，则尝试为不存在的目标注册会导致尽早抛出 &lt;code&gt;NameNotFoundException&lt;/code&gt; ，最好在调用 &lt;code&gt;addNamingListener()&lt;/code&gt; 时抛出，否则，侦听器将收到通过 &lt;code&gt;NamingExceptionEvent&lt;/code&gt; 引发的异常。</target>
        </trans-unit>
        <trans-unit id="f0a93070904cd7e6062d269f73ed4cf640917a73" translate="yes" xml:space="preserve">
          <source>If a service supports this method it cannot be concluded that job cancellation will always succeed. A job may not be able to be cancelled once it has reached and passed some point in its processing. A successful cancellation means only that the entire job was not printed, some portion may already have printed when cancel returns.</source>
          <target state="translated">如果一个服务支持这种方法,就不能断定作业取消一定会成功。作业一旦到达并通过了处理过程中的某个点,就可能无法取消。成功的取消只意味着整个作业没有被打印出来,当取消返回时,有些部分可能已经打印出来了。</target>
        </trans-unit>
        <trans-unit id="be2255c8ae3c0e253b4d1c3edfe6c7951b6b7652" translate="yes" xml:space="preserve">
          <source>If a signer, or codesource is granted this permission, then it is considered a trusted source for MBeans. Only MBeans from trusted sources may be registered in the MBeanServer.</source>
          <target state="translated">如果一个签名者或代码源被授予这个权限,那么它就被认为是MBeans的可信源。只有来自可信源的MBeans才可以在MBeanServer中注册。</target>
        </trans-unit>
        <trans-unit id="03ecf67fc16b1bbea18316b3fee73e9a01230e4e" translate="yes" xml:space="preserve">
          <source>If a single argument is parsed more than once in the string, then the later parse wins.</source>
          <target state="translated">如果一个参数在字符串中被解析超过一次,那么后面的解析就会获胜。</target>
        </trans-unit>
        <trans-unit id="f7c81fc364f1f00a7430bc8ff3d40572c48b36c2" translate="yes" xml:space="preserve">
          <source>If a socket bound to an endpoint represented by an &lt;code&gt;InetSocketAddress &lt;/code&gt; is &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return an &lt;code&gt;InetSocketAddress&lt;/code&gt; after the socket is closed. In that case the returned &lt;code&gt;InetSocketAddress&lt;/code&gt;'s address is the &lt;a href=&quot;inetaddress#isAnyLocalAddress()&quot;&gt;&lt;code&gt;wildcard&lt;/code&gt;&lt;/a&gt; address and its port is the local port that it was bound to.</source>
          <target state="translated">如果绑定到由 &lt;code&gt;InetSocketAddress &lt;/code&gt; 表示的端点的套接字已&lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;，则此方法在套接字关闭后将继续返回 &lt;code&gt;InetSocketAddress&lt;/code&gt; 。在这种情况下，返回的 &lt;code&gt;InetSocketAddress&lt;/code&gt; 的地址是&lt;a href=&quot;inetaddress#isAnyLocalAddress()&quot;&gt; &lt;code&gt;wildcard&lt;/code&gt; &lt;/a&gt;地址，并且其端口是绑定到的本地端口。</target>
        </trans-unit>
        <trans-unit id="31689da1ab6eb24083df20cceed8f165c2b092ae" translate="yes" xml:space="preserve">
          <source>If a socket bound to an endpoint represented by an &lt;code&gt;InetSocketAddress &lt;/code&gt; is &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return an &lt;code&gt;InetSocketAddress&lt;/code&gt; after the socket is closed. In that case the returned &lt;code&gt;InetSocketAddress&lt;/code&gt;'s address is the &lt;a href=&quot;inetaddress#isAnyLocalAddress--&quot;&gt;&lt;code&gt;wildcard&lt;/code&gt;&lt;/a&gt; address and its port is the local port that it was bound to.</source>
          <target state="translated">如果绑定到由 &lt;code&gt;InetSocketAddress &lt;/code&gt; 表示的端点的套接字已&lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;，则此方法在套接字关闭后将继续返回 &lt;code&gt;InetSocketAddress&lt;/code&gt; 。在这种情况下，返回的 &lt;code&gt;InetSocketAddress&lt;/code&gt; 的地址是&lt;a href=&quot;inetaddress#isAnyLocalAddress--&quot;&gt; &lt;code&gt;wildcard&lt;/code&gt; &lt;/a&gt;地址，并且其端口是绑定到的本地端口。</target>
        </trans-unit>
        <trans-unit id="bb0809c0cf763cd6b646a20d3b4af68f3b750ce9" translate="yes" xml:space="preserve">
          <source>If a special collation rule controlled by a &amp;lt;modifier&amp;gt; is specified it applies to the whole collator object.</source>
          <target state="translated">如果指定了由&amp;lt;modifier&amp;gt;控制的特殊整理规则，则该规则将应用于整个整理对象。</target>
        </trans-unit>
        <trans-unit id="427f94ff7874e329986bda9d7fe7b3d120876900" translate="yes" xml:space="preserve">
          <source>If a specified &lt;code&gt;DataFlavor&lt;/code&gt; is previously unknown to the data transfer subsystem, then invoking this method will establish a mapping in both directions between the specified &lt;code&gt;DataFlavor&lt;/code&gt; and an encoded version of its MIME type as its native.</source>
          <target state="translated">如果指定的 &lt;code&gt;DataFlavor&lt;/code&gt; 以前是数据传输子系统未知的，则调用此方法将在指定的 &lt;code&gt;DataFlavor&lt;/code&gt; 和其MIME类型的编码版本（作为其本机）之间建立双向映射。</target>
        </trans-unit>
        <trans-unit id="cdffd367cf1c3286a3204c998849759d715a852b" translate="yes" xml:space="preserve">
          <source>If a specified native is previously unknown to the data transfer subsystem, and that native has been properly encoded, then invoking this method will establish a mapping in both directions between the specified native and a &lt;code&gt;DataFlavor&lt;/code&gt; whose MIME type is a decoded version of the native.</source>
          <target state="translated">如果指定的本机以前对于数据传输子系统是未知的，并且该本机已经正确编码，则调用此方法将在指定的本机与MIME类型是本机的解码版本的 &lt;code&gt;DataFlavor&lt;/code&gt; 之间建立双向映射。</target>
        </trans-unit>
        <trans-unit id="5dcefe732742542e44af9fa0d4a6e91c269fcc8e" translate="yes" xml:space="preserve">
          <source>If a spliterator covers no elements then the reporting of additional characteristic values, beyond that of &lt;code&gt;SIZED&lt;/code&gt; and &lt;code&gt;SUBSIZED&lt;/code&gt;, does not aid clients to control, specialize or simplify computation. However, this does enable shared use of an immutable and empty spliterator instance (see &lt;a href=&quot;spliterators#emptySpliterator()&quot;&gt;&lt;code&gt;Spliterators.emptySpliterator()&lt;/code&gt;&lt;/a&gt;) for empty collections, and enables clients to determine if such a spliterator covers no elements.</source>
          <target state="translated">如果分隔符不包含任何元素，则报告除 &lt;code&gt;SIZED&lt;/code&gt; 和 &lt;code&gt;SUBSIZED&lt;/code&gt; 之外的其他特征值将无助于客户控制，专门化或简化计算。但是，这确实允许为空集合共享使用不可变且为空的splitter实例（请参见&lt;a href=&quot;spliterators#emptySpliterator()&quot;&gt; &lt;code&gt;Spliterators.emptySpliterator()&lt;/code&gt; &lt;/a&gt;），并使客户端能够确定此类spliterator是否不包含任何元素。</target>
        </trans-unit>
        <trans-unit id="dde854bb0f9389f51a8a547bcdbab6e693c555ad" translate="yes" xml:space="preserve">
          <source>If a spliterator covers no elements then the reporting of additional characteristic values, beyond that of &lt;code&gt;SIZED&lt;/code&gt; and &lt;code&gt;SUBSIZED&lt;/code&gt;, does not aid clients to control, specialize or simplify computation. However, this does enable shared use of an immutable and empty spliterator instance (see &lt;a href=&quot;spliterators#emptySpliterator--&quot;&gt;&lt;code&gt;Spliterators.emptySpliterator()&lt;/code&gt;&lt;/a&gt;) for empty collections, and enables clients to determine if such a spliterator covers no elements.</source>
          <target state="translated">如果分隔符不包含任何元素，则报告除 &lt;code&gt;SIZED&lt;/code&gt; 和 &lt;code&gt;SUBSIZED&lt;/code&gt; 之外的其他特征值，将无助于客户控制，专门化或简化计算。但是，这确实允许为空集合共享使用不可变且为空的spliterator实例（请参见&lt;a href=&quot;spliterators#emptySpliterator--&quot;&gt; &lt;code&gt;Spliterators.emptySpliterator()&lt;/code&gt; &lt;/a&gt;），并使客户端能够确定这样的splitter是否不包含任何元素。</target>
        </trans-unit>
        <trans-unit id="5b9f294ae09940094318e9c13a1774353137fae2" translate="yes" xml:space="preserve">
          <source>If a step function is omitted, use an &lt;a href=&quot;#identity(java.lang.Class)&quot;&gt;identity function&lt;/a&gt; of the clause's iteration variable type; insert dropped argument parameters before the identity function parameter for the non-&lt;code&gt;void&lt;/code&gt; iteration variables of preceding clauses. (This will turn the loop variable into a local loop invariant.)</source>
          <target state="translated">如果省略了步骤函数，则使用子句的迭代变量类型的&lt;a href=&quot;#identity(java.lang.Class)&quot;&gt;标识函数&lt;/a&gt;；否则，请使用该函数。在前面子句的非 &lt;code&gt;void&lt;/code&gt; 迭代变量的标识函数参数之前插入删除的参数参数。（这会将循环变量变成局部循环不变式。）</target>
        </trans-unit>
        <trans-unit id="377c4e71a3077730a1c7765115b7830cff588ee5" translate="yes" xml:space="preserve">
          <source>If a stream does contain tables, the tables given in a &lt;code&gt;JPEGImageReadParam&lt;/code&gt; are ignored. Furthermore, if the first image in a stream does contain tables and subsequent ones do not, then the tables given in the first image are used for all the abbreviated images. Once tables have been read from a stream, they can be overridden only by tables subsequently read from the same stream. In order to specify new tables, the &lt;a href=&quot;../../imagereader#setInput(java.lang.Object,boolean,boolean)&quot;&gt;&lt;code&gt;setInput&lt;/code&gt;&lt;/a&gt; method of the reader must be called to change the stream.</source>
          <target state="translated">如果流中确实包含表，则将忽略 &lt;code&gt;JPEGImageReadParam&lt;/code&gt; 中给定的表。此外，如果流中的第一个图像确实包含表，而后续的图像中不包含表，则将第一个图像中给出的表用于所有缩写图像。从流中读取表后，它们只能被随后从同一流中读取的表覆盖。为了指定新表，必须调用阅读器的&lt;a href=&quot;../../imagereader#setInput(java.lang.Object,boolean,boolean)&quot;&gt; &lt;code&gt;setInput&lt;/code&gt; &lt;/a&gt;方法来更改流。</target>
        </trans-unit>
        <trans-unit id="eceb3e8bdd7aa7928b72e084cf57d623f635838d" translate="yes" xml:space="preserve">
          <source>If a stream does contain tables, the tables given in a &lt;code&gt;JPEGImageReadParam&lt;/code&gt; are ignored. Furthermore, if the first image in a stream does contain tables and subsequent ones do not, then the tables given in the first image are used for all the abbreviated images. Once tables have been read from a stream, they can be overridden only by tables subsequently read from the same stream. In order to specify new tables, the &lt;a href=&quot;../../imagereader#setInput-java.lang.Object-boolean-boolean-&quot;&gt;&lt;code&gt;setInput&lt;/code&gt;&lt;/a&gt; method of the reader must be called to change the stream.</source>
          <target state="translated">如果流确实包含表，则 &lt;code&gt;JPEGImageReadParam&lt;/code&gt; 中给定的表将被忽略。此外，如果流中的第一张图像确实包含表，而后续的图像中不包含表，则将第一张图像中给定的表用于所有缩写图像。从流中读取表后，它们只能被随后从同一流中读取的表覆盖。为了指定新表，必须调用阅读器的&lt;a href=&quot;../../imagereader#setInput-java.lang.Object-boolean-boolean-&quot;&gt; &lt;code&gt;setInput&lt;/code&gt; &lt;/a&gt;方法来更改流。</target>
        </trans-unit>
        <trans-unit id="a2750feeb92c351bda0cd825237cf381d71b3604" translate="yes" xml:space="preserve">
          <source>If a stream is ordered, most operations are constrained to operate on the elements in their encounter order; if the source of a stream is a &lt;code&gt;List&lt;/code&gt; containing &lt;code&gt;[1, 2, 3]&lt;/code&gt;, then the result of executing &lt;code&gt;map(x -&amp;gt; x*2)&lt;/code&gt; must be &lt;code&gt;[2, 4, 6]&lt;/code&gt;. However, if the source has no defined encounter order, then any permutation of the values &lt;code&gt;[2, 4, 6]&lt;/code&gt; would be a valid result.</source>
          <target state="translated">如果对流进行了排序，则大多数操作将被约束为按其遇到顺序对元素进行操作；如果流的源是包含 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 的 &lt;code&gt;List&lt;/code&gt; ，则执行 &lt;code&gt;map(x -&amp;gt; x*2)&lt;/code&gt; 必须为 &lt;code&gt;[2, 4, 6]&lt;/code&gt; 。但是，如果源没有定义的遇到顺序，则值 &lt;code&gt;[2, 4, 6]&lt;/code&gt; 任何排列都是有效的结果。</target>
        </trans-unit>
        <trans-unit id="6b6959cca21a486ec06d3cce1668ff1458159cb0" translate="yes" xml:space="preserve">
          <source>If a stream is started, asynchronously or synchronously, it is stopped immediately or after the next flush. This method does &lt;em&gt;NOT&lt;/em&gt; guarantee that all registered actions are completed before return.</source>
          <target state="translated">如果以异步方式或同步方式启动流，则立即或在下一次刷新后将其停止。此方法&lt;em&gt;不能&lt;/em&gt;保证所有注册的动作在返回之前都已完成。</target>
        </trans-unit>
        <trans-unit id="ec3da9f5ed3a50caf2ebc15ff55bbd7387d78001" translate="yes" xml:space="preserve">
          <source>If a string quote character is encountered, then a string is recognized, consisting of all characters after (but not including) the string quote character, up to (but not including) the next occurrence of that same string quote character, or a line terminator, or end of file. The usual escape sequences such as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; and &lt;code&gt;&quot;\t&quot;&lt;/code&gt; are recognized and converted to single characters as the string is parsed.</source>
          <target state="translated">如果遇到字符串引号字符，则将识别出一个字符串，该字符串由该字符串引号字符之后（但不包括）之后的所有字符，直至（但不包括）该相同的字符串引号字符的下一次出现或行终止符组成，或文件末尾。在解析字符串时，通常的转义序列（例如 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;\t&quot;&lt;/code&gt; 被识别并转换为单个字符。</target>
        </trans-unit>
        <trans-unit id="9282cd8e98665287e6b1f89eff4485a0a4410646" translate="yes" xml:space="preserve">
          <source>If a style name field is not one of the valid style strings, it is interpreted as part of the font name, and the default style is used.</source>
          <target state="translated">如果样式名称字段不是有效的样式字符串之一,它将被解释为字体名称的一部分,并使用默认样式。</target>
        </trans-unit>
        <trans-unit id="b339629857a7b6f3977e054ffb46a3342349d262" translate="yes" xml:space="preserve">
          <source>If a suitable MIDI port is not available, the Receiver is retrieved from an installed synthesizer.</source>
          <target state="translated">如果没有合适的MIDI端口,则从已安装的合成器中提取接收器。</target>
        </trans-unit>
        <trans-unit id="f22bb50ef0204e8a05930a1ff9dfbe8e25939ae5" translate="yes" xml:space="preserve">
          <source>If a superinterface is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned for it must accurately reflect the actual type arguments used in the source code. The parameterized type representing each superinterface is created if it had not been created before. See the declaration of &lt;a href=&quot;reflect/parameterizedtype&quot;&gt;&lt;code&gt;ParameterizedType&lt;/code&gt;&lt;/a&gt; for the semantics of the creation process for parameterized types.</source>
          <target state="translated">如果超级接口是参数化类型，则为其返回的 &lt;code&gt;Type&lt;/code&gt; 对象必须准确反映源代码中使用的实际类型参数。如果尚未创建代表每个超级接口的参数化类型，则会创建该参数化类型。有关参数化类型的创建过程的语义，请参见&lt;a href=&quot;reflect/parameterizedtype&quot;&gt; &lt;code&gt;ParameterizedType&lt;/code&gt; &lt;/a&gt;的声明。</target>
        </trans-unit>
        <trans-unit id="cee086fbf4e72f394e2cd369d7a1a31214c885ef" translate="yes" xml:space="preserve">
          <source>If a superinterface is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned for it must accurately reflect the actual type parameters used in the source code. The parameterized type representing each superinterface is created if it had not been created before. See the declaration of &lt;a href=&quot;reflect/parameterizedtype&quot;&gt;&lt;code&gt;ParameterizedType&lt;/code&gt;&lt;/a&gt; for the semantics of the creation process for parameterized types.</source>
          <target state="translated">如果超级接口是参数化类型，则为其返回的 &lt;code&gt;Type&lt;/code&gt; 对象必须准确反映源代码中使用的实际类型参数。如果尚未创建代表每个超级接口的参数化类型，则会创建该参数化类型。有关参数化类型的创建过程的语义，请参见&lt;a href=&quot;reflect/parameterizedtype&quot;&gt; &lt;code&gt;ParameterizedType&lt;/code&gt; &lt;/a&gt;的声明。</target>
        </trans-unit>
        <trans-unit id="1534d214fc89bef5391048993cff1403fb779faa" translate="yes" xml:space="preserve">
          <source>If a supported attribute-value is specified in this attribute set, it will take precedence over the API settings for this print() operation only. The following behaviour is specified for PageFormat: If a client uses the Printable interface, then the &lt;code&gt;attributes&lt;/code&gt; parameter to this method is examined for attributes which specify media (by size), orientation, and imageable area, and those are used to construct a new PageFormat which is passed to the Printable object's print() method. See &lt;a href=&quot;printable&quot;&gt;&lt;code&gt;Printable&lt;/code&gt;&lt;/a&gt; for an explanation of the required behaviour of a Printable to ensure optimal printing via PrinterJob. For clients of the Pageable interface, the PageFormat will always be as supplied by that interface, on a per page basis.</source>
          <target state="translated">如果在此属性集中指定了受支持的属性值，则它将仅优先于此print（）操作的API设置。为PageFormat指定了以下行为：如果客户端使用Printable接口，则将检查此方法的 &lt;code&gt;attributes&lt;/code&gt; 参数以获取指定媒体（按大小），方向和可成像区域的属性，并使用这些属性来构造新的PageFormat它传递给Printable对象的print（）方法。请参阅&lt;a href=&quot;printable&quot;&gt; &lt;code&gt;Printable&lt;/code&gt; &lt;/a&gt;，以获取有关可打印的必需行为的说明，以确保通过PrinterJob进行最佳打印。对于Pageable接口的客户端，PageFormat将始终是该接口提供的（按页面）。</target>
        </trans-unit>
        <trans-unit id="155d85c2f3acb3ff96d47d191351e45387cd2b50" translate="yes" xml:space="preserve">
          <source>If a system property named &lt;code&gt;&quot;java.awt.headless&quot;&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; then the headless implementation of &lt;code&gt;Toolkit&lt;/code&gt; is used, otherwise the default platform-specific implementation of &lt;code&gt;Toolkit&lt;/code&gt; is used.</source>
          <target state="translated">如果命名的系统属性 &lt;code&gt;&quot;java.awt.headless&quot;&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 那么的无头的实施 &lt;code&gt;Toolkit&lt;/code&gt; 的使用，否则默认的平台，具体的实施 &lt;code&gt;Toolkit&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="2961ca3d285dda3c14ae9d20b0882642edd01c16" translate="yes" xml:space="preserve">
          <source>If a taglet object is created and used without the above protocol being followed, then the taglet's behavior is not defined by this interface specification.</source>
          <target state="translated">如果一个taglet对象的创建和使用没有遵循上述协议,那么这个接口规范就没有定义taglet的行为。</target>
        </trans-unit>
        <trans-unit id="879203c3fd36988e5bf767edbe8300f47a6e226a" translate="yes" xml:space="preserve">
          <source>If a target class &lt;code&gt;X&lt;/code&gt; is not accessible to &lt;code&gt;Lookup::in&lt;/code&gt; all access modes are dropped.</source>
          <target state="translated">如果 &lt;code&gt;Lookup::in&lt;/code&gt; 所有访问模式下，Lookup ::不能访问目标类 &lt;code&gt;X&lt;/code&gt; ，则将其删除。</target>
        </trans-unit>
        <trans-unit id="1a6f96de5e57069f6d14d17aca38943e0fdc8ff7" translate="yes" xml:space="preserve">
          <source>If a thread does not lock any object monitor or &lt;code&gt;lockedMonitors&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the returned &lt;code&gt;ThreadInfo&lt;/code&gt; object will have an empty &lt;code&gt;MonitorInfo&lt;/code&gt; array. Similarly, if a thread does not lock any synchronizer or &lt;code&gt;lockedSynchronizers&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the returned &lt;code&gt;ThreadInfo&lt;/code&gt; object will have an empty &lt;code&gt;LockInfo&lt;/code&gt; array.</source>
          <target state="translated">如果线程没有锁定任何对象监视器，或者 &lt;code&gt;lockedMonitors&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则返回的 &lt;code&gt;ThreadInfo&lt;/code&gt; 对象将具有一个空的 &lt;code&gt;MonitorInfo&lt;/code&gt; 数组。同样，如果线程不锁定任何同步器，或者 &lt;code&gt;lockedSynchronizers&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则返回的 &lt;code&gt;ThreadInfo&lt;/code&gt; 对象将具有一个空的 &lt;code&gt;LockInfo&lt;/code&gt; 数组。</target>
        </trans-unit>
        <trans-unit id="423d67d62c33ea4b987acaba9861af6927d6c017" translate="yes" xml:space="preserve">
          <source>If a thread initiates the loading of the installed file system providers and another thread invokes a method that also attempts to load the providers then the method will block until the loading completes.</source>
          <target state="translated">如果一个线程发起加载已安装的文件系统提供者,而另一个线程调用的方法也试图加载提供者,那么该方法将阻塞,直到加载完成。</target>
        </trans-unit>
        <trans-unit id="c16eea84f6a093216a1f6035633219e642c6696f" translate="yes" xml:space="preserve">
          <source>If a thread is &lt;a href=&quot;../../../lang/thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; while waiting then the wait will terminate, an &lt;a href=&quot;../../../lang/interruptedexception&quot;&gt;&lt;code&gt;InterruptedException&lt;/code&gt;&lt;/a&gt; will be thrown, and the thread's interrupted status will be cleared.</source>
          <target state="translated">如果线程在等待时被&lt;a href=&quot;../../../lang/thread#interrupt()&quot;&gt;中断&lt;/a&gt;，则等待将终止，将抛出&lt;a href=&quot;../../../lang/interruptedexception&quot;&gt; &lt;code&gt;InterruptedException&lt;/code&gt; &lt;/a&gt;，并清除线程的中断状态。</target>
        </trans-unit>
        <trans-unit id="c7ba95dc1b6c41c9659ab72fa979fc5c3b29d122" translate="yes" xml:space="preserve">
          <source>If a thread is &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting then the wait will terminate, an &lt;a href=&quot;../../../lang/interruptedexception&quot;&gt;&lt;code&gt;InterruptedException&lt;/code&gt;&lt;/a&gt; will be thrown, and the thread's interrupted status will be cleared.</source>
          <target state="translated">如果线程在等待时被&lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;中断&lt;/a&gt;，则等待将终止，将抛出&lt;a href=&quot;../../../lang/interruptedexception&quot;&gt; &lt;code&gt;InterruptedException&lt;/code&gt; &lt;/a&gt;，并清除线程的中断状态。</target>
        </trans-unit>
        <trans-unit id="26eeddc8ed4e366f2633c02e1ace6b55601c08d7" translate="yes" xml:space="preserve">
          <source>If a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the blocked thread's &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;&lt;code&gt;interrupt&lt;/code&gt;&lt;/a&gt; method. This will cause the channel to be closed, the blocked thread to receive a &lt;a href=&quot;closedbyinterruptexception&quot;&gt;&lt;code&gt;ClosedByInterruptException&lt;/code&gt;&lt;/a&gt;, and the blocked thread's interrupt status to be set.</source>
          <target state="translated">如果一个线程在可中断通道的I / O操作中被阻塞，则另一个线程可以调用被阻塞线程的&lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt; &lt;code&gt;interrupt&lt;/code&gt; &lt;/a&gt;方法。这将导致通道被关闭，阻塞线程将收到&lt;a href=&quot;closedbyinterruptexception&quot;&gt; &lt;code&gt;ClosedByInterruptException&lt;/code&gt; &lt;/a&gt;，并且阻塞线程的中断状态将被设置。</target>
        </trans-unit>
        <trans-unit id="9af6babb2d89b7b1bcb5f61c939d4682bb0b8bf3" translate="yes" xml:space="preserve">
          <source>If a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the blocked thread's &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;&lt;code&gt;interrupt&lt;/code&gt;&lt;/a&gt; method. This will cause the channel to be closed, the blocked thread to receive a &lt;a href=&quot;closedbyinterruptexception&quot;&gt;&lt;code&gt;ClosedByInterruptException&lt;/code&gt;&lt;/a&gt;, and the blocked thread's interrupt status to be set.</source>
          <target state="translated">如果一个线程在可中断通道的I / O操作中被阻塞，则另一个线程可以调用被阻塞线程的&lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt; &lt;code&gt;interrupt&lt;/code&gt; &lt;/a&gt;方法。这将导致通道被关闭，阻塞线程将收到&lt;a href=&quot;closedbyinterruptexception&quot;&gt; &lt;code&gt;ClosedByInterruptException&lt;/code&gt; &lt;/a&gt;，并且阻塞线程的中断状态将被设置。</target>
        </trans-unit>
        <trans-unit id="b319d96f8fb779e6cf6dbc96644a4c37d14e3fed" translate="yes" xml:space="preserve">
          <source>If a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the channel's &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. This will cause the blocked thread to receive an &lt;a href=&quot;asynchronouscloseexception&quot;&gt;&lt;code&gt;AsynchronousCloseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果线程在可中断通道的I / O操作中被阻塞，则另一个线程可以调用通道的&lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;方法。这将导致被阻塞的线程接收一个&lt;a href=&quot;asynchronouscloseexception&quot;&gt; &lt;code&gt;AsynchronousCloseException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd99bc1eee5eed72f1e348ec811d11b7678f072e" translate="yes" xml:space="preserve">
          <source>If a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the channel's &lt;a href=&quot;interruptiblechannel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. This will cause the blocked thread to receive an &lt;a href=&quot;asynchronouscloseexception&quot;&gt;&lt;code&gt;AsynchronousCloseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果某个线程在可中断通道的I / O操作中被阻塞，则另一个线程可以调用该通道的&lt;a href=&quot;interruptiblechannel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;方法。这将导致被阻塞的线程接收一个&lt;a href=&quot;asynchronouscloseexception&quot;&gt; &lt;code&gt;AsynchronousCloseException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="741c512b0e9856c5e2dfc36c34abb9cce44c9e8d" translate="yes" xml:space="preserve">
          <source>If a thread is currently blocked in one of this selector's selection methods then it is interrupted as if by invoking the selector's &lt;a href=&quot;#wakeup()&quot;&gt;&lt;code&gt;wakeup&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果线程当前在此选择器的选择方法之一中被阻止，则将其中断，就像通过调用选择器的&lt;a href=&quot;#wakeup()&quot;&gt; &lt;code&gt;wakeup&lt;/code&gt; &lt;/a&gt;方法一样。</target>
        </trans-unit>
        <trans-unit id="da330aea3c98594d1083e77da98a318f71baeb0d" translate="yes" xml:space="preserve">
          <source>If a thread is currently blocked in one of this selector's selection methods then it is interrupted as if by invoking the selector's &lt;a href=&quot;selector#wakeup--&quot;&gt;&lt;code&gt;wakeup&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果线程当前在此选择器的选择方法之一中被阻止，则将其中断，就像调用选择器的&lt;a href=&quot;selector#wakeup--&quot;&gt; &lt;code&gt;wakeup&lt;/code&gt; &lt;/a&gt;方法一样。</target>
        </trans-unit>
        <trans-unit id="dd825fe40f49db3b150afa3490d105cbd6aabd48" translate="yes" xml:space="preserve">
          <source>If a thread is currently blocked in the &lt;a href=&quot;#take()&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#poll(long,java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt; methods waiting for a key to be queued then it immediately receives a &lt;a href=&quot;closedwatchserviceexception&quot;&gt;&lt;code&gt;ClosedWatchServiceException&lt;/code&gt;&lt;/a&gt;. Any valid keys associated with this watch service are &lt;a href=&quot;watchkey#isValid()&quot;&gt;&lt;code&gt;invalidated&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果线程当前在&lt;a href=&quot;#take()&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#poll(long,java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;poll&lt;/code&gt; &lt;/a&gt;方法中被阻塞，等待键排队，那么它立即收到&lt;a href=&quot;closedwatchserviceexception&quot;&gt; &lt;code&gt;ClosedWatchServiceException&lt;/code&gt; &lt;/a&gt;。与该监视服务关联的所有有效密钥都将&lt;a href=&quot;watchkey#isValid()&quot;&gt; &lt;code&gt;invalidated&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5afbadf14eba91b88bef9af2e17ba1b04cf7b04" translate="yes" xml:space="preserve">
          <source>If a thread is currently blocked in the &lt;a href=&quot;watchservice#take--&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;watchservice#poll-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt; methods waiting for a key to be queued then it immediately receives a &lt;a href=&quot;closedwatchserviceexception&quot;&gt;&lt;code&gt;ClosedWatchServiceException&lt;/code&gt;&lt;/a&gt;. Any valid keys associated with this watch service are &lt;a href=&quot;watchkey#isValid--&quot;&gt;&lt;code&gt;invalidated&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果线程当前在&lt;a href=&quot;watchservice#take--&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;watchservice#poll-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;poll&lt;/code&gt; &lt;/a&gt;方法中被阻塞，等待键排队，则它立即收到&lt;a href=&quot;closedwatchserviceexception&quot;&gt; &lt;code&gt;ClosedWatchServiceException&lt;/code&gt; &lt;/a&gt;。与该监视服务关联的所有有效密钥均&lt;a href=&quot;watchkey#isValid--&quot;&gt; &lt;code&gt;invalidated&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="79a80fec9ac0e51a906db8a969589f57b8d53771" translate="yes" xml:space="preserve">
          <source>If a thread of the given ID is not alive or does not exist, this method will return &lt;code&gt;null&lt;/code&gt;. A thread is alive if it has been started and has not yet died.</source>
          <target state="translated">如果给定ID的线程不存在或不存在，则此方法将返回 &lt;code&gt;null&lt;/code&gt; 。如果线程已经启动但尚未死亡，则该线程是活动的。</target>
        </trans-unit>
        <trans-unit id="c7367fdf45de9116c0531a4eb673c46e4df10f0d" translate="yes" xml:space="preserve">
          <source>If a thread's interrupt status is already set and it invokes a blocking I/O operation upon a channel then the channel will be closed and the thread will immediately receive a &lt;a href=&quot;closedbyinterruptexception&quot;&gt;&lt;code&gt;ClosedByInterruptException&lt;/code&gt;&lt;/a&gt;; its interrupt status will remain set.</source>
          <target state="translated">如果已经设置了线程的中断状态，并且在通道上调用了阻塞I / O操作，则该通道将关闭，线程将立即收到&lt;a href=&quot;closedbyinterruptexception&quot;&gt; &lt;code&gt;ClosedByInterruptException&lt;/code&gt; &lt;/a&gt;；其中断状态将保持不变。</target>
        </trans-unit>
        <trans-unit id="f20c8ec4cbcd889326c0ec36148d75b1de4b78c0" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffers, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">如果指定了超时并且在操作完成之前已经超时，则它会以&lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt;异常完成。在发生超时的情况下，实现不能保证未读取字节，或无法将字节从通道读取到给定的缓冲区中，那么进一步尝试从通道读取将导致抛出不确定的运行时异常。</target>
        </trans-unit>
        <trans-unit id="085511ee4e6f8838601b8420555dabe5caf417db" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffer, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">如果指定了超时并且在操作完成之前已经超时，则它会以&lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt;异常完成。在发生超时的情况下，实现不能保证尚未将字节写入或将不会从给定的缓冲区写入字节，则进一步尝试写入该通道将导致抛出不确定的运行时异常。</target>
        </trans-unit>
        <trans-unit id="d1e6a9ea34cc15cb7dc234bc610d3da7fd2fd1d7" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffers, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">如果指定了超时并且在操作完成之前已经超时，则它会以&lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt;异常完成。在发生超时的情况下，实现不能保证尚未将字节写入或将不会从给定的缓冲区写入字节，则进一步尝试写入该通道将引发不确定的运行时异常。</target>
        </trans-unit>
        <trans-unit id="7aeea9b2c990269d554f71236286a06879279f31" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then the operation completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffer, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">如果指定了超时并且在操作完成之前已经超时，则操作将以&lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt;异常完成。在发生超时的情况下，实现不能保证未读取字节，或无法将字节从通道读取到给定的缓冲区中，那么进一步尝试从通道读取将导致引发非特定的运行时异常。</target>
        </trans-unit>
        <trans-unit id="b059429e7b4fbc4030cc099662067f32b6c7ab30" translate="yes" xml:space="preserve">
          <source>If a type is annotated with this annotation type, compilers are required to generate an error message unless:</source>
          <target state="translated">如果一个类型被注解为这个注解类型,编译器就需要产生一个错误信息,除非:。</target>
        </trans-unit>
        <trans-unit id="30a46db240d4202d821461d90b26ad19eebaf078" translate="yes" xml:space="preserve">
          <source>If a type map is explicitly supplied to a method that can perform custom mapping, that type map supersedes the connection's type map.</source>
          <target state="translated">如果类型映射被显式地提供给一个可以执行自定义映射的方法,那么该类型映射将取代连接的类型映射。</target>
        </trans-unit>
        <trans-unit id="cec90847ba71497dbb8ac58a8a03e00d0d13737f" translate="yes" xml:space="preserve">
          <source>If a value attribute is not specified for a FORM input element of type &quot;reset&quot;, then this default string is used.</source>
          <target state="translated">如果没有为类型为 &quot;reset &quot;的FORM输入元素指定值属性,那么将使用这个默认字符串。</target>
        </trans-unit>
        <trans-unit id="2b0d011a6bf2d15325c296c503e117073be6dd16" translate="yes" xml:space="preserve">
          <source>If a value attribute is not specified for a FORM input element of type &quot;submit&quot;, then this default string is used.</source>
          <target state="translated">如果没有为类型为 &quot;submit &quot;的FORM输入元素指定值属性,那么将使用这个默认字符串。</target>
        </trans-unit>
        <trans-unit id="f9870e38cea09b6406ac14017d5c924cd67267c1" translate="yes" xml:space="preserve">
          <source>If a value is not present, returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果不存在值，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="860fe4e2923a6695add73192da6784b1d700c654" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;Optional&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;Optional&lt;/code&gt; 中存在值，则返回该值，否则抛出 &lt;code&gt;NoSuchElementException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac19fb5ed0433a6a84bbf9870c3d0508394c1ec9" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;OptionalDouble&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;OptionalDouble&lt;/code&gt; 中存在值，则返回该值，否则抛出 &lt;code&gt;NoSuchElementException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77f8284a88fc486cd8c49e73e5157ec4382cced0" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;OptionalInt&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;OptionalInt&lt;/code&gt; 中存在值，则返回该值，否则抛出 &lt;code&gt;NoSuchElementException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b442beaf0679fd03d92130f9d3a16dff8abc1a47" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;OptionalLong&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;OptionalLong&lt;/code&gt; 中存在值，则返回该值，否则抛出 &lt;code&gt;NoSuchElementException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b332c643a29d3b80d91478304a9a05ebfa61d296" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present &lt;code&gt;Optional&lt;/code&gt;s must be unambiguously differentiable.</source>
          <target state="translated">如果存在值，则结果必须在结果中包括其字符串表示形式。空和存在 &lt;code&gt;Optional&lt;/code&gt; 必须明确区分。</target>
        </trans-unit>
        <trans-unit id="bc6398511731b6bf47b59801abf764ae618774f0" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present &lt;code&gt;OptionalDouble&lt;/code&gt;s must be unambiguously differentiable.</source>
          <target state="translated">如果存在值，则结果必须在结果中包括其字符串表示形式。空且存在的 &lt;code&gt;OptionalDouble&lt;/code&gt; 必须明确区分。</target>
        </trans-unit>
        <trans-unit id="d13847496ad6374cf53cad3b090b540d8f97008c" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present &lt;code&gt;OptionalInt&lt;/code&gt;s must be unambiguously differentiable.</source>
          <target state="translated">如果存在值，则结果必须在结果中包括其字符串表示形式。空的和存在的 &lt;code&gt;OptionalInt&lt;/code&gt; 必须是明确可区分的。</target>
        </trans-unit>
        <trans-unit id="32534cbdba6aa1b3be53d4a1e4bd73d3c27b87e1" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present &lt;code&gt;OptionalLong&lt;/code&gt;s must be unambiguously differentiable.</source>
          <target state="translated">如果存在值，则结果必须在结果中包括其字符串表示形式。空和当前的 &lt;code&gt;OptionalLong&lt;/code&gt; 必须是可区分的。</target>
        </trans-unit>
        <trans-unit id="d4e270a2bbe380815af7730e0b32eed7b9b310b0" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present Optionals must be unambiguously differentiable.</source>
          <target state="translated">如果一个值存在,结果中必须包括它的字符串表示。空的和存在的选项必须是可以明确区分的。</target>
        </trans-unit>
        <trans-unit id="53843db157010fe9437f6ec6848ceaa2431d68a8" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present instances must be unambiguously differentiable.</source>
          <target state="translated">如果一个值存在,结果中必须包括它的字符串表示。空和存在的实例必须是可以明确区分的。</target>
        </trans-unit>
        <trans-unit id="0706b2c7911a55318a829716b41ba2d3be31b10d" translate="yes" xml:space="preserve">
          <source>If a value is present, and the value matches the given predicate, return an &lt;code&gt;Optional&lt;/code&gt; describing the value, otherwise return an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">如果存在一个值，并且该值与给定的谓词匹配，则返回描述该值的 &lt;code&gt;Optional&lt;/code&gt; ，否则返回一个空的 &lt;code&gt;Optional&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1f67ed14ddaf89a0a9fae6c94b2add61c02da04" translate="yes" xml:space="preserve">
          <source>If a value is present, and the value matches the given predicate, returns an &lt;code&gt;Optional&lt;/code&gt; describing the value, otherwise returns an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">如果存在一个值，并且该值与给定的谓词匹配，则返回描述该值的 &lt;code&gt;Optional&lt;/code&gt; ，否则返回一个空的 &lt;code&gt;Optional&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="891603f3a0de1e1f312f4666b625f9fb23d2e9c9" translate="yes" xml:space="preserve">
          <source>If a value is present, apply the provided &lt;code&gt;Optional&lt;/code&gt;-bearing mapping function to it, return that result, otherwise return an empty &lt;code&gt;Optional&lt;/code&gt;. This method is similar to &lt;a href=&quot;optional#map-java.util.function.Function-&quot;&gt;&lt;code&gt;map(Function)&lt;/code&gt;&lt;/a&gt;, but the provided mapper is one whose result is already an &lt;code&gt;Optional&lt;/code&gt;, and if invoked, &lt;code&gt;flatMap&lt;/code&gt; does not wrap it with an additional &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">如果存在一个值，则对它应用提供的 &lt;code&gt;Optional&lt;/code&gt; -bearing映射函数，返回该结果，否则返回一个空的 &lt;code&gt;Optional&lt;/code&gt; 。此方法类似于&lt;a href=&quot;optional#map-java.util.function.Function-&quot;&gt; &lt;code&gt;map(Function)&lt;/code&gt; &lt;/a&gt;，但是提供的映射器是其结果已经是 &lt;code&gt;Optional&lt;/code&gt; 的映射器，并且如果被调用， &lt;code&gt;flatMap&lt;/code&gt; 不会使用附加的 &lt;code&gt;Optional&lt;/code&gt; 对其进行包装。</target>
        </trans-unit>
        <trans-unit id="a8b5560d2bb98c2edc06f003311054df22294d95" translate="yes" xml:space="preserve">
          <source>If a value is present, apply the provided mapping function to it, and if the result is non-null, return an &lt;code&gt;Optional&lt;/code&gt; describing the result. Otherwise return an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">如果存在值，则将提供的映射函数应用于该值，如果结果为非null，则返回描述结果的 &lt;code&gt;Optional&lt;/code&gt; 。否则，返回一个空的 &lt;code&gt;Optional&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fad40f63b1a2a9bdb013e89c0f84f329771e8703" translate="yes" xml:space="preserve">
          <source>If a value is present, invoke the specified consumer with the value, otherwise do nothing.</source>
          <target state="translated">如果有值,则用该值调用指定的消费者,否则什么也不做。</target>
        </trans-unit>
        <trans-unit id="5d567ac49757fc0782070c29f442b2ed3c10a3dd" translate="yes" xml:space="preserve">
          <source>If a value is present, performs the given action with the value, otherwise does nothing.</source>
          <target state="translated">如果存在一个值,则用该值执行给定的操作,否则什么也不做。</target>
        </trans-unit>
        <trans-unit id="80f1d15f081a557c0c89dfe542e08e6466937a4a" translate="yes" xml:space="preserve">
          <source>If a value is present, performs the given action with the value, otherwise performs the given empty-based action.</source>
          <target state="translated">如果存在一个值,则用该值执行给定的操作,否则执行给定的基于空的操作。</target>
        </trans-unit>
        <trans-unit id="7c76eb4f4aed61ec0dcaef4e6193ded7df1448b7" translate="yes" xml:space="preserve">
          <source>If a value is present, returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果存在值，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="990df4fbcc05f42f66d4bdbbd223d271fecafc58" translate="yes" xml:space="preserve">
          <source>If a value is present, returns a sequential &lt;a href=&quot;stream/doublestream&quot;&gt;&lt;code&gt;DoubleStream&lt;/code&gt;&lt;/a&gt; containing only that value, otherwise returns an empty &lt;code&gt;DoubleStream&lt;/code&gt;.</source>
          <target state="translated">如果存在值，则返回仅包含该值的顺序&lt;a href=&quot;stream/doublestream&quot;&gt; &lt;code&gt;DoubleStream&lt;/code&gt; &lt;/a&gt;，否则返回空 &lt;code&gt;DoubleStream&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="385631a2bb5e8e2699a3121cde109d9d5c428c7c" translate="yes" xml:space="preserve">
          <source>If a value is present, returns a sequential &lt;a href=&quot;stream/intstream&quot;&gt;&lt;code&gt;IntStream&lt;/code&gt;&lt;/a&gt; containing only that value, otherwise returns an empty &lt;code&gt;IntStream&lt;/code&gt;.</source>
          <target state="translated">如果存在值，则返回仅包含该值的顺序&lt;a href=&quot;stream/intstream&quot;&gt; &lt;code&gt;IntStream&lt;/code&gt; &lt;/a&gt;，否则返回空的 &lt;code&gt;IntStream&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="866cb2164afa2f09d3d5f20e37c35481f6eb4412" translate="yes" xml:space="preserve">
          <source>If a value is present, returns a sequential &lt;a href=&quot;stream/longstream&quot;&gt;&lt;code&gt;LongStream&lt;/code&gt;&lt;/a&gt; containing only that value, otherwise returns an empty &lt;code&gt;LongStream&lt;/code&gt;.</source>
          <target state="translated">如果存在值，则返回仅包含该值的顺序&lt;a href=&quot;stream/longstream&quot;&gt; &lt;code&gt;LongStream&lt;/code&gt; &lt;/a&gt;，否则返回空 &lt;code&gt;LongStream&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d3bb8d4c843a69020ffe62321e3f9054e0b137e" translate="yes" xml:space="preserve">
          <source>If a value is present, returns a sequential &lt;a href=&quot;stream/stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; containing only that value, otherwise returns an empty &lt;code&gt;Stream&lt;/code&gt;.</source>
          <target state="translated">如果存在值，则返回仅包含该值的顺序&lt;a href=&quot;stream/stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;，否则返回空 &lt;code&gt;Stream&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80b22e4088b80520ac0af98bec76415b35276b8f" translate="yes" xml:space="preserve">
          <source>If a value is present, returns an &lt;code&gt;Optional&lt;/code&gt; describing (as if by &lt;a href=&quot;#ofNullable(T)&quot;&gt;&lt;code&gt;ofNullable(T)&lt;/code&gt;&lt;/a&gt;) the result of applying the given mapping function to the value, otherwise returns an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">如果存在一个值，则返回一个 &lt;code&gt;Optional&lt;/code&gt; 描述（就像通过&lt;a href=&quot;#ofNullable(T)&quot;&gt; &lt;code&gt;ofNullable(T)&lt;/code&gt; 一样&lt;/a&gt;），将给定映射函数应用于该值的结果，否则返回一个空的 &lt;code&gt;Optional&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abd4d4cf8da044effb78b2adaaded70498203413" translate="yes" xml:space="preserve">
          <source>If a value is present, returns an &lt;code&gt;Optional&lt;/code&gt; describing the value, otherwise returns an &lt;code&gt;Optional&lt;/code&gt; produced by the supplying function.</source>
          <target state="translated">如果值存在时，返回一个 &lt;code&gt;Optional&lt;/code&gt; 描述的值，否则将返回一个 &lt;code&gt;Optional&lt;/code&gt; 产生通过供给功能。</target>
        </trans-unit>
        <trans-unit id="d4b5e82c51b8cf385fd5db9aef6045fbce1f3044" translate="yes" xml:space="preserve">
          <source>If a value is present, returns the result of applying the given &lt;code&gt;Optional&lt;/code&gt;-bearing mapping function to the value, otherwise returns an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">如果存在一个值，则返回将给定 &lt;code&gt;Optional&lt;/code&gt; -bearing映射函数应用于该值的结果，否则返回一个空的 &lt;code&gt;Optional&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f14d878112134ffc9ff4d14f0e3174e5576c31bb" translate="yes" xml:space="preserve">
          <source>If a value is present, returns the value, otherwise returns &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">如果存在值，则返回该值，否则返回 &lt;code&gt;other&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c50641617ef0d200da8db393fec3586af58ae1c" translate="yes" xml:space="preserve">
          <source>If a value is present, returns the value, otherwise returns the result produced by the supplying function.</source>
          <target state="translated">如果存在一个值,则返回该值,否则返回供应函数产生的结果。</target>
        </trans-unit>
        <trans-unit id="56c949f365a2890532569468d612418290144d9c" translate="yes" xml:space="preserve">
          <source>If a value is present, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">如果存在值，则返回该值，否则抛出 &lt;code&gt;NoSuchElementException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae9bed738425dfb5a5a5674c68f5303dddc05d71" translate="yes" xml:space="preserve">
          <source>If a value is present, returns the value, otherwise throws an exception produced by the exception supplying function.</source>
          <target state="translated">如果存在一个值,则返回该值,否则抛出一个由异常供应函数产生的异常。</target>
        </trans-unit>
        <trans-unit id="8eddee0588c954a17deb099f9dd61de2515231b4" translate="yes" xml:space="preserve">
          <source>If a value of null is specified for the Set, this Component inherits the Set from its parent. If all ancestors of this Component have null specified for the Set, then the current KeyboardFocusManager's default Set is used.</source>
          <target state="translated">如果为Set指定的值为null,则该组件从它的父代继承Set。如果这个组件的所有祖先都为Set指定了null,那么就会使用当前KeyboardFocusManager的默认Set。</target>
        </trans-unit>
        <trans-unit id="0f16c24760d5749166bc98a390f507c2d3216615" translate="yes" xml:space="preserve">
          <source>If a value of null is specified for the Set, this Container inherits the Set from its parent. If all ancestors of this Container have null specified for the Set, then the current KeyboardFocusManager's default Set is used.</source>
          <target state="translated">如果为Set指定的值为null,则该容器从其父代继承Set。如果这个容器的所有祖先都为Set指定了null值,那么就会使用当前KeyboardFocusManager的默认Set。</target>
        </trans-unit>
        <trans-unit id="387ee9cb7e9e0be3dd6915fcd912184178dc89a4" translate="yes" xml:space="preserve">
          <source>If a vertical scrollbar is needed, i.e. if the viewport's extent height is smaller than its view height or if the &lt;code&gt;displayPolicy&lt;/code&gt; is ALWAYS, it's treated like the row header with respect to its dimensions and is made visible.</source>
          <target state="translated">如果需要垂直滚动条，即，如果视口的范围高度小于其视线高度，或者 &lt;code&gt;displayPolicy&lt;/code&gt; 始终为ALWAYS，则在其尺寸方面将其视为行标题，并使其可见。</target>
        </trans-unit>
        <trans-unit id="8fc4cf82efa4121c970d3bd205365e50de294c4b" translate="yes" xml:space="preserve">
          <source>If a visitor returns a result of &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;
 NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果访问者返回的结果为 &lt;code&gt;null&lt;/code&gt; ,则抛出 &lt;code&gt; NullPointerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92cb4d374f2fe9448ca335ac55aeaabe71a1f569" translate="yes" xml:space="preserve">
          <source>If a visitor returns a result of &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果访问者返回的结果为 &lt;code&gt;null&lt;/code&gt; ,则抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e01b98873a0cadbbe64c47b2b726716a54e9964" translate="yes" xml:space="preserve">
          <source>If a watched file is not located on a local storage device then it is implementation specific if changes to the file can be detected. In particular, it is not required that changes to files carried out on remote systems be detected.</source>
          <target state="translated">如果一个被监视的文件不在本地存储设备上,那么是否能检测到文件的变化是具体实施的。特别是,不要求检测到对远程系统上的文件进行的更改。</target>
        </trans-unit>
        <trans-unit id="5650a3db9a7e2000acade2b25c2be5c4db496f6e" translate="yes" xml:space="preserve">
          <source>If a writer isRepairingNamespaces it will create a namespace declaration on the current StartElement for any attribute that does not currently have a namespace declaration in scope. If the StartElement has a uri but no prefix specified a prefix will be assigned, if the prefix has not been declared in a parent of the current StartElement it will be declared on the current StartElement. If the defaultNamespace is bound and in scope and the default namespace matches the URI of the attribute or StartElement QName no prefix will be assigned.</source>
          <target state="translated">如果写入者是RepairingNamespaces,它将在当前StartElement上为任何当前范围内没有命名空间声明的属性创建一个命名空间声明。如果StartElement有一个uri,但没有指定前缀,将分配一个前缀,如果前缀没有在当前StartElement的父节点上声明,将在当前StartElement上声明。如果defaultNamespace被绑定并在范围内,并且默认命名空间与属性的URI或StartElement QName相匹配,则不会分配前缀。</target>
        </trans-unit>
        <trans-unit id="73a81112b02af25fafd5aeb53509af8b9467d422" translate="yes" xml:space="preserve">
          <source>If aContainer is &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/FocusSpec.html#FocusTraversalPolicyProviders&quot;&gt;focus traversal policy provider&lt;/a&gt;, the focus is always transferred down-cycle.</source>
          <target state="translated">如果aContainer是&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/FocusSpec.html#FocusTraversalPolicyProviders&quot;&gt;焦点遍历策略提供者&lt;/a&gt;，则焦点总是向下循环转移。</target>
        </trans-unit>
        <trans-unit id="740f7c5f8d2ce7496496f12eb476ff1f2e840f4c" translate="yes" xml:space="preserve">
          <source>If aContainer is &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/java/awt/doc-files/FocusSpec.html#FocusTraversalPolicyProviders&quot;&gt;focus traversal policy provider&lt;/a&gt;, the focus is always transferred down-cycle.</source>
          <target state="translated">如果aContainer是&lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/java/awt/doc-files/FocusSpec.html#FocusTraversalPolicyProviders&quot;&gt;焦点遍历策略提供者&lt;/a&gt;，则焦点总是向下循环转移。</target>
        </trans-unit>
        <trans-unit id="bee200d444da7e51810a8f81ba5dffe16cc316fc" translate="yes" xml:space="preserve">
          <source>If addr specifies an IPv4 address an instance of Inet4Address will be returned; otherwise, an instance of Inet6Address will be returned.</source>
          <target state="translated">如果addr指定了一个IPv4地址,将返回一个Inet4Address的实例;否则,将返回一个Inet6Address的实例。</target>
        </trans-unit>
        <trans-unit id="923186511eab92209b32f15d3fb01aaacb2e442c" translate="yes" xml:space="preserve">
          <source>If adjacent parsing is active, then parsing must match exactly the specified number of digits in both strict and lenient modes. In addition, no positive or negative sign is permitted.</source>
          <target state="translated">如果相邻解析是主动的,那么在严格和宽松模式下,解析必须完全匹配指定的数字。此外,不允许使用正号或负号。</target>
        </trans-unit>
        <trans-unit id="200dbc311565e1132ebe3228cefc3d9aab1c06b2" translate="yes" xml:space="preserve">
          <source>If adjacent runs of text with the same &lt;code&gt;InputMethodHighlight&lt;/code&gt; need to be rendered separately, the &lt;code&gt;InputMethodHighlights&lt;/code&gt; should be wrapped in &lt;code&gt;Annotation&lt;/code&gt; instances.</source>
          <target state="translated">如果需要分别呈现具有相同 &lt;code&gt;InputMethodHighlight&lt;/code&gt; 的相邻文本行，则应将 &lt;code&gt;InputMethodHighlights&lt;/code&gt; 包装在 &lt;code&gt;Annotation&lt;/code&gt; 实例中。</target>
        </trans-unit>
        <trans-unit id="716099ad8a55cb2a7c2b3773b52c94f64ee203cb" translate="yes" xml:space="preserve">
          <source>If after the window location has been calculated, the upper, left, or right edge of the window is out of the screen, then the window is located in such a way that the upper, left, or right edge of the window coincides with the corresponding edge of the screen. If both left and right edges of the window are out of the screen, the window is placed at the left side of the screen. The similar placement will occur if both top and bottom edges are out of the screen. In that case, the window is placed at the top side of the screen.</source>
          <target state="translated">如果在计算出窗口位置后,窗口的上边、左边或右边都在屏幕外,那么窗口的位置就会使窗口的上边、左边或右边与屏幕的相应边缘重合。如果窗口的左、右边缘都在屏幕外,则窗口放置在屏幕的左侧。如果上边和下边都在屏幕外,则会出现类似的放置方式。在这种情况下,窗口将被放置在屏幕的顶部。</target>
        </trans-unit>
        <trans-unit id="44d02905089e1694a5a3552ec8bae0d4cda874a1" translate="yes" xml:space="preserve">
          <source>If agent classes need to link to classes in platform (or other) modules that are not in the boot layer then the application may need to be started in a way that ensures that these modules are in the boot layer. In the JDK implementation for example, the &lt;code&gt;--add-modules&lt;/code&gt; command line option can be used to add modules to the set of root modules to resolve at startup.</source>
          <target state="translated">如果代理类需要链接到不在引导层中的平台（或其他）模块中的类，则可能需要以确保这些模块在引导层中的方式来启动应用程序。例如，在JDK实现中，可以使用 &lt;code&gt;--add-modules&lt;/code&gt; 命令行选项将模块添加到一组根模块中，以便在启动时进行解析。</target>
        </trans-unit>
        <trans-unit id="bfa34a3f881c3ffb5525522b340dad76550fa33e" translate="yes" xml:space="preserve">
          <source>If all inputs are null, the &lt;code&gt;LSParser&lt;/code&gt; will report a &lt;code&gt;DOMError&lt;/code&gt; with its &lt;code&gt;DOMError.type&lt;/code&gt; set to &lt;code&gt;&quot;no-input-specified&quot;&lt;/code&gt; and its &lt;code&gt;DOMError.severity&lt;/code&gt; set to &lt;code&gt;DOMError.SEVERITY_FATAL_ERROR&lt;/code&gt;.</source>
          <target state="translated">如果所有输入均为空，则 &lt;code&gt;LSParser&lt;/code&gt; 将报告 &lt;code&gt;DOMError&lt;/code&gt; ，其 &lt;code&gt;DOMError.type&lt;/code&gt; 设置为 &lt;code&gt;&quot;no-input-specified&quot;&lt;/code&gt; 并且其 &lt;code&gt;DOMError.severity&lt;/code&gt; 设置为 &lt;code&gt;DOMError.SEVERITY_FATAL_ERROR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8c6c1fd23bed92157c4876b59e8a94de5ba0fe9" translate="yes" xml:space="preserve">
          <source>If all of the keys in the key set at the start of this step have empty interest sets then neither the selected-key set nor any of the keys' ready-operation sets will be updated.</source>
          <target state="translated">如果本步骤开始时钥匙集中的所有钥匙都有空的兴趣集,那么选定的钥匙集和任何钥匙的准备操作集都不会被更新。</target>
        </trans-unit>
        <trans-unit id="785bd1a03946e5c11649c06831e14c3b158e51f0" translate="yes" xml:space="preserve">
          <source>If all samples of both source and destination Rasters are of integral type and less than or equal to 32 bits in size, then calling this method is equivalent to executing the following code for all &lt;code&gt;x,y&lt;/code&gt; addresses valid in both Rasters.</source>
          <target state="translated">如果源和目标Raster的所有样本均为整数类型，并且大小均小于或等于32位，则调用此方法等效于对两个Raster中均有效的所有 &lt;code&gt;x,y&lt;/code&gt; 地址执行以下代码。</target>
        </trans-unit>
        <trans-unit id="f4ad16a03d874b1099d86cc284527a5d0fd4f2c9" translate="yes" xml:space="preserve">
          <source>If all that is desired is the simple identity transformation of a source to a result, then &lt;a href=&quot;transformerfactory&quot;&gt;&lt;code&gt;TransformerFactory&lt;/code&gt;&lt;/a&gt; provides a &lt;a href=&quot;transformerfactory#newTransformer()&quot;&gt;&lt;code&gt;TransformerFactory.newTransformer()&lt;/code&gt;&lt;/a&gt; method with no arguments. This method creates a Transformer that effectively copies the source to the result. This method may be used to create a DOM from SAX events or to create an XML or HTML stream from a DOM or SAX events.</source>
          <target state="translated">如果仅需要将源简单地标识转换为结果，则&lt;a href=&quot;transformerfactory&quot;&gt; &lt;code&gt;TransformerFactory&lt;/code&gt; &lt;/a&gt;提供不带参数的&lt;a href=&quot;transformerfactory#newTransformer()&quot;&gt; &lt;code&gt;TransformerFactory.newTransformer()&lt;/code&gt; &lt;/a&gt;方法。此方法创建一个Transformer，可将源有效复制到结果中。此方法可用于从SAX事件创建DOM或从DOM或SAX事件创建XML或HTML流。</target>
        </trans-unit>
        <trans-unit id="478f44b721763a191efa4a005ca8cf8c23dac1b2" translate="yes" xml:space="preserve">
          <source>If all the date objects being compared are in the same chronology, then the additional chronology stage is not required and only the local date is used. To compare the dates of two &lt;code&gt;TemporalAccessor&lt;/code&gt; instances, including dates in two different chronologies, use &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt; as a comparator.</source>
          <target state="translated">如果所有要比较的日期对象都在相同的时间顺序中，则不需要附加的时间顺序阶段，而仅使用本地日期。若要比较两个 &lt;code&gt;TemporalAccessor&lt;/code&gt; 实例的日期，包括两个不同时间的日期，请使用&lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt;作为比较器。</target>
        </trans-unit>
        <trans-unit id="920032b96bedf78cb11745b4b01ea2b9da62f86c" translate="yes" xml:space="preserve">
          <source>If all the date-time objects being compared are in the same chronology, then the additional chronology stage is not required and only the local date-time is used.</source>
          <target state="translated">如果所有被比较的日期-时间对象都在同一个年表中,那么就不需要额外的年表阶段,只使用本地的日期-时间。</target>
        </trans-unit>
        <trans-unit id="91e24b45b1050248e3d9b0f32a1bfe41649a4f37" translate="yes" xml:space="preserve">
          <source>If all the date-time objects being compared are in the same chronology, then the additional chronology stage is not required.</source>
          <target state="translated">如果所有被比较的日期-时间对象都在同一年表中,那么就不需要额外的年表阶段。</target>
        </trans-unit>
        <trans-unit id="eed6c18a7529e057741cc5ea4bc802b1033492a2" translate="yes" xml:space="preserve">
          <source>If all the date-times being compared are instances of &lt;code&gt;LocalDateTime&lt;/code&gt;, then the comparison will be entirely based on the date-time. If some dates being compared are in different chronologies, then the chronology is also considered, see &lt;a href=&quot;chrono/chronolocaldatetime#compareTo(java.time.chrono.ChronoLocalDateTime)&quot;&gt;&lt;code&gt;ChronoLocalDateTime.compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果所有要比较的日期时间都是 &lt;code&gt;LocalDateTime&lt;/code&gt; 的实例，则比较将完全基于日期时间。如果要比较的某些日期位于不同的时间顺序中，则也考虑该时间顺序，请参见&lt;a href=&quot;chrono/chronolocaldatetime#compareTo(java.time.chrono.ChronoLocalDateTime)&quot;&gt; &lt;code&gt;ChronoLocalDateTime.compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7af80a78ccebdf694054065e68649e1c92533dff" translate="yes" xml:space="preserve">
          <source>If all the date-times being compared are instances of &lt;code&gt;LocalDateTime&lt;/code&gt;, then the comparison will be entirely based on the date-time. If some dates being compared are in different chronologies, then the chronology is also considered, see &lt;a href=&quot;chrono/chronolocaldatetime#compareTo-java.time.chrono.ChronoLocalDateTime-&quot;&gt;&lt;code&gt;ChronoLocalDateTime.compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果所有要比较的日期时间都是 &lt;code&gt;LocalDateTime&lt;/code&gt; 的实例，则比较将完全基于日期时间。如果要比较的某些日期位于不同的时间顺序中，则还考虑该时间顺序，请参见&lt;a href=&quot;chrono/chronolocaldatetime#compareTo-java.time.chrono.ChronoLocalDateTime-&quot;&gt; &lt;code&gt;ChronoLocalDateTime.compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8b68f4d96414def1c9a247a1feae8028274ccf8" translate="yes" xml:space="preserve">
          <source>If all the dates being compared are instances of &lt;code&gt;LocalDate&lt;/code&gt;, then the comparison will be entirely based on the date. If some dates being compared are in different chronologies, then the chronology is also considered, see &lt;a href=&quot;chrono/chronolocaldate#compareTo(java.time.chrono.ChronoLocalDate)&quot;&gt;&lt;code&gt;ChronoLocalDate.compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果所有要比较的日期都是 &lt;code&gt;LocalDate&lt;/code&gt; 的实例，则比较将完全基于日期。如果要比较的某些日期位于不同的时间顺序中，则还应考虑该时间顺序，请参见&lt;a href=&quot;chrono/chronolocaldate#compareTo(java.time.chrono.ChronoLocalDate)&quot;&gt; &lt;code&gt;ChronoLocalDate.compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c70daeec02ec422b3471ddc6193b4b37b8cb8342" translate="yes" xml:space="preserve">
          <source>If all the dates being compared are instances of &lt;code&gt;LocalDate&lt;/code&gt;, then the comparison will be entirely based on the date. If some dates being compared are in different chronologies, then the chronology is also considered, see &lt;a href=&quot;chrono/chronolocaldate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt;&lt;code&gt;ChronoLocalDate.compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果所有要比较的日期都是 &lt;code&gt;LocalDate&lt;/code&gt; 的实例，则比较将完全基于日期。如果要比较的某些日期位于不同的时间顺序中，则也考虑该时间顺序，请参见&lt;a href=&quot;chrono/chronolocaldate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt; &lt;code&gt;ChronoLocalDate.compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="95938a0cd815321f6453791f7f4283d94220e212" translate="yes" xml:space="preserve">
          <source>If all the docs have the same binding specified, then any value of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; makes sense, and the printer's processing depends on the &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; value:</source>
          <target state="translated">如果所有文档都指定了相同的绑定，则&lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 的&lt;/a&gt;任何值都有意义，并且打印机的处理取决于&lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 的&lt;/a&gt;值：</target>
        </trans-unit>
        <trans-unit id="7869c5e4ed330a875f3cd70b80530f1cdf968256" translate="yes" xml:space="preserve">
          <source>If all the docs have the same number up value</source>
          <target state="translated">如果所有的文档都有相同的向上数值</target>
        </trans-unit>
        <trans-unit id="323feabb33d09245620f68d33109a728cd260051" translate="yes" xml:space="preserve">
          <source>If all the docs have the same page ranges specified, then any value of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; makes sense, and the printer's processing depends on the &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; value:</source>
          <target state="translated">如果所有文档都指定了相同的页面范围，则&lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 的&lt;/a&gt;任何值都有意义，并且打印机的处理取决于&lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 的&lt;/a&gt;值：</target>
        </trans-unit>
        <trans-unit id="7632f9c77b81ad5d1b5d6f09a7736f43de381a75" translate="yes" xml:space="preserve">
          <source>If all the docs have the same sheet collation specified, then the following combinations of &lt;code&gt;SheetCollate&lt;/code&gt; and &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; are permitted, and the printer reports an error when the job is submitted if any other combination is specified:</source>
          <target state="translated">如果所有文档均指定了相同的工作表排序规则，则允许以下 &lt;code&gt;SheetCollate&lt;/code&gt; 和&lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt;组合，并且如果指定了任何其他组合，则打印机在提交作业时报告错误：</target>
        </trans-unit>
        <trans-unit id="43de23ce23841ef0c6a6fa16c30e0adac32dff5f" translate="yes" xml:space="preserve">
          <source>If all the docs have the same sheet collation specified, then the following combinations of SheetCollate and &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; are permitted, and the printer reports an error when the job is submitted if any other combination is specified:</source>
          <target state="translated">如果所有文档都指定了相同的工作表排序规则，则允许以下SheetCollat​​e和&lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt;组合，并且如果指定了任何其他组合，则打印机在提交作业时报告错误：</target>
        </trans-unit>
        <trans-unit id="53f4aefa8b3b18b801db7105e517f135c3160808" translate="yes" xml:space="preserve">
          <source>If all the docs have the same sides value</source>
          <target state="translated">如果所有的文档都具有相同的边值</target>
        </trans-unit>
        <trans-unit id="3b7bb19ce2d8fc8ee789c0716e2955f9d1adbc31" translate="yes" xml:space="preserve">
          <source>If all the pred functions always return true, no fini function is ever invoked, and the loop cannot exit except by throwing an exception.</source>
          <target state="translated">如果所有的pred函数总是返回真,则永远不会调用fini函数,除了抛出异常,循环不能退出。</target>
        </trans-unit>
        <trans-unit id="e5b294fc85ac6bc7caf05040784ae5fbc6fd93b1" translate="yes" xml:space="preserve">
          <source>If all the proxy interfaces are in &lt;em&gt;exported&lt;/em&gt; or &lt;em&gt;open&lt;/em&gt; packages:</source>
          <target state="translated">如果所有代理接口都在&lt;em&gt;导出&lt;/em&gt;或&lt;em&gt;打开的&lt;/em&gt;程序包中：</target>
        </trans-unit>
        <trans-unit id="13b164fb9c908e01dba066b8fc6c58bae1a8266f" translate="yes" xml:space="preserve">
          <source>If all the weights are zero, all the extra space appears between the grids of the cell and the left and right edges.</source>
          <target state="translated">如果所有的权重都为零,所有的额外空间都会出现在单元格的网格和左右边缘之间。</target>
        </trans-unit>
        <trans-unit id="75e3f80e58848d10fc7b05443ed5b045728e7ed1" translate="yes" xml:space="preserve">
          <source>If all the weights are zero, all the extra space appears between the grids of the cell and the top and bottom edges.</source>
          <target state="translated">如果所有的权重都为零,所有的额外空间都会出现在单元格的网格和上下边缘之间。</target>
        </trans-unit>
        <trans-unit id="e98b6cadfd0e47989a3a1fb253438638f5a39323" translate="yes" xml:space="preserve">
          <source>If already detached from the virtual machine then invoking this method has no effect.</source>
          <target state="translated">如果已经脱离了虚拟机,那么调用这个方法就没有效果。</target>
        </trans-unit>
        <trans-unit id="eb8a32bf1903f2512087dd34b708c9f237e4fae2" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;#parsedExcessDays()&quot;&gt;excess number of days&lt;/a&gt; was parsed then it is added to the date if a date is available.</source>
          <target state="translated">如果解析了&lt;a href=&quot;#parsedExcessDays()&quot;&gt;过多的天数，&lt;/a&gt;则在有可用日期的情况下将其添加到日期中。</target>
        </trans-unit>
        <trans-unit id="4098503fbcb241fe10627044b2064dc72f141550" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; is thrown when accessing the directory after returned from this method, it is wrapped in an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; which will be thrown from the method that caused the access to take place.</source>
          <target state="translated">从此方法返回后，如果在访问目录时抛出&lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;，则它将包装在&lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; 中&lt;/a&gt;，该异常将由导致访问发生的方法抛出。</target>
        </trans-unit>
        <trans-unit id="088dd2d19f784625275b483d3f0f4f2ddbb175e3" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; is thrown when accessing the directory after this method has returned, it is wrapped in an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; which will be thrown from the method that caused the access to take place.</source>
          <target state="translated">如果在返回此方法后访问目录时抛出&lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;，则将其包装在&lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; 中&lt;/a&gt;，该异常将从导致访问发生的方法中抛出。</target>
        </trans-unit>
        <trans-unit id="448273579cd0c1573f50adb27cc551f6240ac792" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;datetimeformatter#parsedExcessDays--&quot;&gt;excess number of days&lt;/a&gt; was parsed then it is added to the date if a date is available.</source>
          <target state="translated">如果解析了&lt;a href=&quot;datetimeformatter#parsedExcessDays--&quot;&gt;过多的天数，&lt;/a&gt;则在有可用日期的情况下将其添加到日期中。</target>
        </trans-unit>
        <trans-unit id="f440d6e16437287ae444b44920a0eee99c549130" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; is thrown when accessing the underlying &lt;code&gt;BufferedReader&lt;/code&gt;, it is wrapped in an &lt;a href=&quot;uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; which will be thrown from the &lt;code&gt;Stream&lt;/code&gt; method that caused the read to take place. This method will return a Stream if invoked on a BufferedReader that is closed. Any operation on that stream that requires reading from the BufferedReader after it is closed, will cause an UncheckedIOException to be thrown.</source>
          <target state="translated">如果在访问基础 &lt;code&gt;BufferedReader&lt;/code&gt; 时抛出&lt;a href=&quot;ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;，则它将包装在&lt;a href=&quot;uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; 中&lt;/a&gt;，该异常将从导致读取发生的 &lt;code&gt;Stream&lt;/code&gt; 方法中抛出。如果在已关闭的BufferedReader上调用，则此方法将返回Stream。该流上需要在关闭后从BufferedReader中读取的任何操作，都将引发UncheckedIOException。</target>
        </trans-unit>
        <trans-unit id="959df27348a054da287e538a4f7d1a74313d32f5" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;@Target&lt;/code&gt; meta-annotation is not present on an annotation type &lt;code&gt;T&lt;/code&gt; , then an annotation of type &lt;code&gt;T&lt;/code&gt; may be written as a modifier for any declaration except a type parameter declaration.</source>
          <target state="translated">如果在注释类型 &lt;code&gt;T&lt;/code&gt; 上不存在 &lt;code&gt;@Target&lt;/code&gt; 元注释，则可以将类型 &lt;code&gt;T&lt;/code&gt; 的注释写为除类型参数声明之外的任何声明的修饰符。</target>
        </trans-unit>
        <trans-unit id="7444a73ead79fffd1052783fd985fdbe7c5cdbb4" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;@Target&lt;/code&gt; meta-annotation is not present on an annotation type &lt;code&gt;T&lt;/code&gt;, then an annotation of type &lt;code&gt;T&lt;/code&gt; may be written as a modifier for any declaration except a type parameter declaration.</source>
          <target state="translated">如果在注释类型 &lt;code&gt;T&lt;/code&gt; 上不存在 &lt;code&gt;@Target&lt;/code&gt; 元注释，则可以将类型 &lt;code&gt;T&lt;/code&gt; 的注释写为除类型参数声明之外的任何声明的修饰符。</target>
        </trans-unit>
        <trans-unit id="8371b963c2b6f04360837c6404d40bc176c92b9b" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;@Target&lt;/code&gt; meta-annotation is present, the compiler will enforce the usage restrictions indicated by &lt;code&gt;ElementType&lt;/code&gt; enum constants, in line with JLS 9.7.4.</source>
          <target state="translated">如果存在 &lt;code&gt;@Target&lt;/code&gt; 元注释，则编译器将强制执行 &lt;code&gt;ElementType&lt;/code&gt; 枚举常量指示的使用限制，以符合JLS 9.7.4的要求。</target>
        </trans-unit>
        <trans-unit id="0c49dc23b8bd2062de89ca86518931b5b9024793" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;AbstractFormatterFactory&lt;/code&gt; has not been explicitly set, one will be set based on the &lt;code&gt;Class&lt;/code&gt; of the value type after &lt;code&gt;setValue&lt;/code&gt; has been invoked (assuming value is non-null). For example, in the following code an appropriate &lt;code&gt;AbstractFormatterFactory&lt;/code&gt; and &lt;code&gt;AbstractFormatter&lt;/code&gt; will be created to handle formatting of numbers:</source>
          <target state="translated">如果尚未显式设置 &lt;code&gt;AbstractFormatterFactory&lt;/code&gt; ，则在调用 &lt;code&gt;setValue&lt;/code&gt; 之后（假设值非空），将根据值类型的 &lt;code&gt;Class&lt;/code&gt; 设置一个。例如，在下面的代码中，将创建适当的 &lt;code&gt;AbstractFormatterFactory&lt;/code&gt; 和 &lt;code&gt;AbstractFormatter&lt;/code&gt; 来处理数字格式：</target>
        </trans-unit>
        <trans-unit id="2413517d9fd5745a82ae6ddf00cd7489151ba27f" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;AffineTransform&lt;/code&gt; is passed to &lt;a href=&quot;#drawImage(java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver)&quot;&gt;&lt;code&gt;drawImage(Image, AffineTransform, ImageObserver)&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;AffineTransform&lt;/code&gt; is used to transform the bounding box from image space to user space. If no &lt;code&gt;AffineTransform&lt;/code&gt; is supplied, the bounding box is treated as if it is already in user space.</source>
          <target state="translated">如果将 &lt;code&gt;AffineTransform&lt;/code&gt; 传递给&lt;a href=&quot;#drawImage(java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver)&quot;&gt; &lt;code&gt;drawImage(Image, AffineTransform, ImageObserver)&lt;/code&gt; &lt;/a&gt;，则 &lt;code&gt;AffineTransform&lt;/code&gt; 用于将边界框从图像空间转换为用户空间。如果未提供 &lt;code&gt;AffineTransform&lt;/code&gt; ，则将边框视为已在用户空间中。</target>
        </trans-unit>
        <trans-unit id="9496a4d3cf27eda519ac141e2a00e405156b6ffb" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the stream is reset to a fixed state that depends on the particular type of the input stream and how it was created. The bytes that will be supplied to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method depend on the particular type of the input stream.</source>
          <target state="translated">如果未抛出 &lt;code&gt;IOException&lt;/code&gt; ，则将流重置为固定状态，具体取决于输入流的特定类型及其创建方式。将提供给 &lt;code&gt;read&lt;/code&gt; 方法的后续调用者的字节取决于输入流的特定类型。</target>
        </trans-unit>
        <trans-unit id="8be497ebd5fad36819e8bdb92f6d004796dc73ce" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;IndexColorModel&lt;/code&gt; object has a transparency value of &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;, then the &lt;code&gt;hasAlpha&lt;/code&gt; and &lt;code&gt;getNumComponents&lt;/code&gt; methods (both inherited from &lt;code&gt;ColorModel&lt;/code&gt;) return false and 3, respectively. For any other transparency value, &lt;code&gt;hasAlpha&lt;/code&gt; returns true and &lt;code&gt;getNumComponents&lt;/code&gt; returns 4.</source>
          <target state="translated">如果 &lt;code&gt;IndexColorModel&lt;/code&gt; 对象的透明度值为 &lt;code&gt;Transparency.OPAQUE&lt;/code&gt; ，则 &lt;code&gt;hasAlpha&lt;/code&gt; 和 &lt;code&gt;getNumComponents&lt;/code&gt; 方法（均从 &lt;code&gt;ColorModel&lt;/code&gt; 继承）分别返回false和3。对于任何其他透明度值， &lt;code&gt;hasAlpha&lt;/code&gt; 返回true，而 &lt;code&gt;getNumComponents&lt;/code&gt; 返回4。</target>
        </trans-unit>
        <trans-unit id="6de50cf0b5b005c73f2b22f23092356cfbc265a6" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Object&lt;/code&gt; reference was previously allowed, the previous settings are overwritten.</source>
          <target state="translated">如果以前允许 &lt;code&gt;Object&lt;/code&gt; 引用，则先前的设置将被覆盖。</target>
        </trans-unit>
        <trans-unit id="ce889769df21717dff5602aeddeab9f3a68fa96a" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;RMIServerImpl&lt;/code&gt; was supplied to the constructor, it is used.</source>
          <target state="translated">如果将 &lt;code&gt;RMIServerImpl&lt;/code&gt; 提供给构造函数，则使用它。</target>
        </trans-unit>
        <trans-unit id="c147456e60cfbfb343d2b171d44a03397a71498d" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;optionType&lt;/code&gt; was specified to this &lt;code&gt;ConfirmationCallback&lt;/code&gt;, this option may be specified as a &lt;code&gt;defaultOption&lt;/code&gt; or returned as the selected index.</source>
          <target state="translated">如果为该 &lt;code&gt;ConfirmationCallback&lt;/code&gt; 指定了 &lt;code&gt;optionType&lt;/code&gt; ，则该选项可以指定为 &lt;code&gt;defaultOption&lt;/code&gt; 或作为所选索引返回。</target>
        </trans-unit>
        <trans-unit id="8447b90738960e5c08b7001e6598b18a44c5ae38" translate="yes" xml:space="preserve">
          <source>If an ACL entry contains a &lt;a href=&quot;aclentry#principal()&quot;&gt;&lt;code&gt;user-principal&lt;/code&gt;&lt;/a&gt; that is not associated with the same provider as this attribute view then &lt;a href=&quot;../providermismatchexception&quot;&gt;&lt;code&gt;ProviderMismatchException&lt;/code&gt;&lt;/a&gt; is thrown. Additional validation, if any, is implementation dependent.</source>
          <target state="translated">如果ACL条目包含与该属性视图未与同一提供者关联的&lt;a href=&quot;aclentry#principal()&quot;&gt; &lt;code&gt;user-principal&lt;/code&gt; &lt;/a&gt;，则将抛出&lt;a href=&quot;../providermismatchexception&quot;&gt; &lt;code&gt;ProviderMismatchException&lt;/code&gt; &lt;/a&gt;。其他验证（如果有）取决于实现。</target>
        </trans-unit>
        <trans-unit id="bddc19f4e2a7499584504adbd2e120339e8a9d2c" translate="yes" xml:space="preserve">
          <source>If an ACL entry contains a &lt;a href=&quot;aclentry#principal--&quot;&gt;&lt;code&gt;user-principal&lt;/code&gt;&lt;/a&gt; that is not associated with the same provider as this attribute view then &lt;a href=&quot;../providermismatchexception&quot;&gt;&lt;code&gt;ProviderMismatchException&lt;/code&gt;&lt;/a&gt; is thrown. Additional validation, if any, is implementation dependent.</source>
          <target state="translated">如果ACL条目包含与该属性视图未与同一提供者关联的&lt;a href=&quot;aclentry#principal--&quot;&gt; &lt;code&gt;user-principal&lt;/code&gt; &lt;/a&gt;，则将抛出&lt;a href=&quot;../providermismatchexception&quot;&gt; &lt;code&gt;ProviderMismatchException&lt;/code&gt; &lt;/a&gt;。其他验证（如果有）取决于实现。</target>
        </trans-unit>
        <trans-unit id="6e691cd0ee7a41eeed3186a97648a8370581048b" translate="yes" xml:space="preserve">
          <source>If an I/O error is encountered when accessing the directory then it causes the &lt;code&gt;Iterator&lt;/code&gt;'s &lt;code&gt;hasNext&lt;/code&gt; or &lt;code&gt;next&lt;/code&gt; methods to throw &lt;a href=&quot;directoryiteratorexception&quot;&gt;&lt;code&gt;DirectoryIteratorException&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; as the cause. As stated above, the &lt;code&gt;hasNext&lt;/code&gt; method is guaranteed to read-ahead by at least one element. This means that if &lt;code&gt;hasNext&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt;, and is followed by a call to the &lt;code&gt;next&lt;/code&gt; method, then it is guaranteed that the &lt;code&gt;next&lt;/code&gt; method will not fail with a &lt;code&gt;DirectoryIteratorException&lt;/code&gt;.</source>
          <target state="translated">如果访问目录时遇到I / O错误，那么它会导致 &lt;code&gt;Iterator&lt;/code&gt; 的 &lt;code&gt;hasNext&lt;/code&gt; 或 &lt;code&gt;next&lt;/code&gt; 方法抛出&lt;a href=&quot;directoryiteratorexception&quot;&gt; &lt;code&gt;DirectoryIteratorException&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 异常&lt;/a&gt;的原因。如上所述，保证 &lt;code&gt;hasNext&lt;/code&gt; 方法至少要预读一个元素。这意味着，如果 &lt;code&gt;hasNext&lt;/code&gt; 方法返回 &lt;code&gt;true&lt;/code&gt; ，并随后调用 &lt;code&gt;next&lt;/code&gt; 方法，则可以确保 &lt;code&gt;next&lt;/code&gt; 方法不会因 &lt;code&gt;DirectoryIteratorException&lt;/code&gt; 而失败。</target>
        </trans-unit>
        <trans-unit id="feeedb640cf4499009e04bb26412c9322b88b5ad" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the file or writing to the output stream, then it may do so after some bytes have been read or written. Consequently the output stream may be in an inconsistent state. It is strongly recommended that the output stream be promptly closed if an I/O error occurs.</source>
          <target state="translated">如果从文件读取或向输出流写入发生I/O错误,那么它可能在读取或写入一些字节后才发生。因此,输出流可能处于不一致的状态。强烈建议在发生I/O错误时,立即关闭输出流。</target>
        </trans-unit>
        <trans-unit id="9c872125a1307797d25e4f9f64998713cf5ca5f3" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the input stream or writing to the file, then it may do so after the target file has been created and after some bytes have been read or written. Consequently the input stream may not be at end of stream and may be in an inconsistent state. It is strongly recommended that the input stream be promptly closed if an I/O error occurs.</source>
          <target state="translated">如果从输入流读取或向文件写入时发生I/O错误,那么可能是在目标文件创建后,在一些字节被读取或写入后发生的。因此,输入流可能不在流的末端,可能处于不一致的状态。强烈建议,如果发生I/O错误,应及时关闭输入流。</target>
        </trans-unit>
        <trans-unit id="e4515b55c84516838e1780f2824973489fcfac02" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the input stream or writing to the output stream, then it may do so after some bytes have been read or written. Consequently the input stream may not be at end of stream and one, or both, streams may be in an inconsistent state. It is strongly recommended that both streams be promptly closed if an I/O error occurs.</source>
          <target state="translated">如果从输入流读取或向输出流写入时发生了I/O错误,那么它可能在一些字节被读取或写入后才发生。因此,输入流可能没有到达流的末端,一个或两个流可能处于不一致的状态。强烈建议在发生I/O错误时,及时关闭两个流。</target>
        </trans-unit>
        <trans-unit id="c6575b29bb7b7702708e4556bb126e11740cace5" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the input stream, then it may do so after some, but not all, bytes have been read. Consequently the input stream may not be at end of stream and may be in an inconsistent state. It is strongly recommended that the stream be promptly closed if an I/O error occurs.</source>
          <target state="translated">如果从输入流读取时发生了I/O错误,那么它可能是在读取了一些(但不是全部)字节之后才发生的,因此,输入流可能没有达到流的终点,而且可能处于不一致的状态。因此,输入流可能不在流的末端,可能处于不一致的状态。强烈建议,如果发生I/O错误,应立即关闭流。</target>
        </trans-unit>
        <trans-unit id="8650ce7705399aaaa8cc71478fcf996136dfacc1" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the input stream, then it may do so after some, but not all, bytes of &lt;code&gt;b&lt;/code&gt; have been updated with data from the input stream. Consequently the input stream and &lt;code&gt;b&lt;/code&gt; may be in an inconsistent state. It is strongly recommended that the stream be promptly closed if an I/O error occurs.</source>
          <target state="translated">如果从输入流读取时发生I / O错误，则它可能会用输入流中的数据更新了 &lt;code&gt;b&lt;/code&gt; 部分（但不是全部）后，才这样做。因此，输入流和 &lt;code&gt;b&lt;/code&gt; 可能处于不一致状态。强烈建议在发生I / O错误时立即关闭流。</target>
        </trans-unit>
        <trans-unit id="b10fec173abaf89ed742106df0192bdc5dd2cd41" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the reader or writing to the writer, then it may do so after some characters have been read or written. Consequently the reader may not be at end of the stream and one, or both, streams may be in an inconsistent state. It is strongly recommended that both streams be promptly closed if an I/O error occurs.</source>
          <target state="translated">如果从读取器读取或向写入器写入时发生I/O错误,那么它可能是在一些字符被读取或写入后发生的。因此,读取器可能没有到达流的末端,一个或两个流可能处于不一致的状态。强烈建议在发生I/O错误时,立即关闭两个流。</target>
        </trans-unit>
        <trans-unit id="22ab8147923c63cb080ea7642bb58cee303b4eaf" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs, then the input stream may be in an inconsistent state. It is strongly recommended that the stream be promptly closed if an I/O error occurs.</source>
          <target state="translated">如果发生I/O错误,那么输入流可能处于不一致的状态。强烈建议,如果发生I/O错误,应立即关闭该流。</target>
        </trans-unit>
        <trans-unit id="8e94181111a51e17f16b6ca91b979e4213744c5a" translate="yes" xml:space="preserve">
          <source>If an I/O error or signing error occurs during the signing, then it may do so after some bytes have been written. Consequently, the output stream may be in an inconsistent state. It is strongly recommended that it be promptly closed in this case.</source>
          <target state="translated">如果在签名过程中发生I/O错误或签名错误,那么可能会在写入一些字节之后才发生。因此,输出流可能处于不一致的状态。在这种情况下,强烈建议及时关闭它。</target>
        </trans-unit>
        <trans-unit id="3e0e0bbd8cf71d8f39745254a8443c1668c16acb" translate="yes" xml:space="preserve">
          <source>If an InitialContextFactoryBuilder has been installed, it is used to create the factory for creating the initial context</source>
          <target state="translated">如果已经安装了InitialContextFactoryBuilder,那么它将被用来创建用于创建初始上下文的工厂。</target>
        </trans-unit>
        <trans-unit id="190c966c8992a3839001e7e1af1d2b89e9457c04" translate="yes" xml:space="preserve">
          <source>If an InitialContextFactoryBuilder has been installed, it is used to create the factory for creating the initial context. Otherwise, the class specified in the &lt;code&gt;Context.INITIAL_CONTEXT_FACTORY&lt;/code&gt; environment property is used. Note that an initial context factory (an object that implements the InitialContextFactory interface) must be public and must have a public constructor that accepts no arguments.</source>
          <target state="translated">如果已安装InitialContextFactoryBuilder，它将用于创建用于创建初始上下文的工厂。否则，将使用 &lt;code&gt;Context.INITIAL_CONTEXT_FACTORY&lt;/code&gt; 环境属性中指定的类。请注意，初始上下文工厂（实现InitialContextFactory接口的对象）必须是公共的，并且必须具有不接受任何参数的公共构造函数。</target>
        </trans-unit>
        <trans-unit id="98657208ee304eaeabe25e126ff14f176c167883" translate="yes" xml:space="preserve">
          <source>If an MBean implements the interface &lt;a href=&quot;privateclassloader&quot;&gt;&lt;code&gt;PrivateClassLoader&lt;/code&gt;&lt;/a&gt;, then it is not added to the class loader repository. The class &lt;a href=&quot;privatemlet&quot;&gt;&lt;code&gt;PrivateMLet&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;code&gt;MLet&lt;/code&gt; that implements &lt;code&gt;PrivateClassLoader&lt;/code&gt;.</source>
          <target state="translated">如果MBean实现接口&lt;a href=&quot;privateclassloader&quot;&gt; &lt;code&gt;PrivateClassLoader&lt;/code&gt; &lt;/a&gt;，则不会将其添加到类加载器存储库中。类&lt;a href=&quot;privatemlet&quot;&gt; &lt;code&gt;PrivateMLet&lt;/code&gt; &lt;/a&gt;是实现 &lt;code&gt;PrivateClassLoader&lt;/code&gt; 的 &lt;code&gt;MLet&lt;/code&gt; 的子类。</target>
        </trans-unit>
        <trans-unit id="f7dbdf0d0215e39ffb9e056dc435071a7e3d1afd" translate="yes" xml:space="preserve">
          <source>If an ObjectName is not a pattern, it must contain at least one key with its associated value.</source>
          <target state="translated">如果一个ObjectName不是一个模式,那么它必须至少包含一个键及其相关的值。</target>
        </trans-unit>
        <trans-unit id="3170aa0e22af44ef0aa7402074972e3d2fb9806f" translate="yes" xml:space="preserve">
          <source>If an RMI connector client or server receives from its peer an instance of a class that it does not know, and if dynamic code downloading is active for the RMI connection, then the class can be downloaded from a codebase specified by the peer. &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=rmi_guide&quot;&gt;Java RMI Guide&lt;/a&gt; explains this in more detail.</source>
          <target state="translated">如果RMI连接器客户端或服务器从其对等方接收到它不知道的类的实例，并且如果RMI连接的动态代码下载处于活动状态，则可以从对等方指定的代码库中下载该类。&lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=rmi_guide&quot;&gt;Java RMI指南&lt;/a&gt;对此进行了更详细的说明。</target>
        </trans-unit>
        <trans-unit id="58773dafdf455bae89181c8eface9c51e941a81b" translate="yes" xml:space="preserve">
          <source>If an RMI connector client or server receives from its peer an instance of a class that it does not know, and if dynamic code downloading is active for the RMI connection, then the class can be downloaded from a codebase specified by the peer. &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=rmi_guide&quot;&gt;Java RMI Guide&lt;/a&gt; explains this in more detail.</source>
          <target state="translated">如果RMI连接器客户端或服务器从其对等方接收到它不知道的类的实例，并且如果RMI连接的动态代码下载处于活动状态，则可以从对等方指定的代码库中下载该类。&lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=rmi_guide&quot;&gt;Java RMI指南&lt;/a&gt;对此进行了更详细的说明。</target>
        </trans-unit>
        <trans-unit id="e0bc3775989ff9a0fa2129381bf0e75ba0c93374" translate="yes" xml:space="preserve">
          <source>If an RMI connector client or server receives from its peer an instance of a class that it does not know, and if dynamic code downloading is active for the RMI connection, then the class can be downloaded from a codebase specified by the peer. The article &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/codebase.html&quot;&gt;&lt;em&gt;Dynamic code downloading using Java RMI&lt;/em&gt;&lt;/a&gt; explains this in more detail.</source>
          <target state="translated">如果RMI连接器客户端或服务器从其对等方接收到它不知道的类的实例，并且如果RMI连接的动态代码下载处于活动状态，则可以从对等方指定的代码库中下载该类。&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/codebase.html&quot;&gt;&lt;em&gt;使用Java RMI动态下载代码一&lt;/em&gt;&lt;/a&gt;文对此进行了详细说明。</target>
        </trans-unit>
        <trans-unit id="08988225aef79e54029028850710dc91fcab9d17" translate="yes" xml:space="preserve">
          <source>If an action has already been registered for the receiving container, with the same charCode and the same modifiers, &lt;code&gt;anAction&lt;/code&gt; will replace the action.</source>
          <target state="translated">如果已经使用相同的charCode和相同的修饰符为接收容器注册了动作，则 &lt;code&gt;anAction&lt;/code&gt; 将替换该动作。</target>
        </trans-unit>
        <trans-unit id="7baff14a90d603c3ca1182261c5d5d4493ea8f8d" translate="yes" xml:space="preserve">
          <source>If an action is not registered, an exception stack trace is printed to standard error.</source>
          <target state="translated">如果一个动作没有被注册,异常堆栈跟踪会被打印成标准错误。</target>
        </trans-unit>
        <trans-unit id="04d753d52266244d553b5ee79ecbe1175044fb7f" translate="yes" xml:space="preserve">
          <source>If an address does not have any associated segment, it is said to be &lt;em&gt;unchecked&lt;/em&gt;. Unchecked memory addresses do not feature known spatial or temporal bounds; as such, attempting a memory dereference operation using an unchecked memory address will result in a runtime exception. Unchecked addresses can be obtained e.g. by calling the &lt;a href=&quot;#ofLong(long)&quot;&gt;&lt;code&gt;ofLong(long)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果地址没有任何关联的段，则称其为&lt;em&gt;未选中的&lt;/em&gt;。未检查的内存地址不具有已知的空间或时间范围。这样，尝试使用未经检查的内存地址进行内存解除引用操作将导致运行时异常。可以通过调用&lt;a href=&quot;#ofLong(long)&quot;&gt; &lt;code&gt;ofLong(long)&lt;/code&gt; &lt;/a&gt;方法获得未经检查的地址。</target>
        </trans-unit>
        <trans-unit id="ac4ee4e3be7f792562359278f4f57ab7faea7f57" translate="yes" xml:space="preserve">
          <source>If an alpha sample is present, it corresponds the last index.</source>
          <target state="translated">如果存在α样本,则对应最后的指数。</target>
        </trans-unit>
        <trans-unit id="9c4c5268bcffbf9c0c5b98ecb4ed28911043818e" translate="yes" xml:space="preserve">
          <source>If an annotation of type</source>
          <target state="translated">如果一个类型为</target>
        </trans-unit>
        <trans-unit id="9df83510632408ed0d5232c4209c863ed75fc2b2" translate="yes" xml:space="preserve">
          <source>If an annotation returned by a method in this interface contains (directly or indirectly) a &lt;a href=&quot;../class&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt;-valued member referring to a class that is not accessible in this VM, attempting to read the class by calling the relevant Class-returning method on the returned annotation will result in a &lt;a href=&quot;../typenotpresentexception&quot;&gt;&lt;code&gt;TypeNotPresentException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果此接口中方法返回的注释包含（直接或间接）引用该VM中不可访问的类的&lt;a href=&quot;../class&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt;值成员，请尝试通过对返回的注释调用相关的Class-returning方法来读取该类将导致&lt;a href=&quot;../typenotpresentexception&quot;&gt; &lt;code&gt;TypeNotPresentException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0227ca62999d931b56d6f6658a6e345f41f26f21" translate="yes" xml:space="preserve">
          <source>If an annotation type</source>
          <target state="translated">如果一个注解类型</target>
        </trans-unit>
        <trans-unit id="ed99bca3e6f592b88e87557055d253e0c0b22f1a" translate="yes" xml:space="preserve">
          <source>If an application caches method handles for broad sharing, it should use &lt;code&gt;publicLookup()&lt;/code&gt; to create them. If there is a lookup of &lt;code&gt;Class.forName&lt;/code&gt;, it will fail, and the application must take appropriate action in that case. It may be that a later lookup, perhaps during the invocation of a bootstrap method, can incorporate the specific identity of the caller, making the method accessible.</source>
          <target state="translated">如果应用程序缓存方法句柄进行广泛共享，则应使用 &lt;code&gt;publicLookup()&lt;/code&gt; 创建它们。如果查找 &lt;code&gt;Class.forName&lt;/code&gt; ，它将失败，并且在这种情况下，应用程序必须采取适当的措施。可能是以后的查找（可能在引导方法调用期间）可以包含调用者的特定身份，从而使方法可访问。</target>
        </trans-unit>
        <trans-unit id="517b0d95c98c17f7230f34f43d8c177b399282df" translate="yes" xml:space="preserve">
          <source>If an application does &lt;em&gt;not&lt;/em&gt; register its own custom &lt;code&gt;ErrorListener&lt;/code&gt;, the default &lt;code&gt;ErrorListener&lt;/code&gt; is used which reports all warnings and errors to &lt;code&gt;System.err&lt;/code&gt; and does not throw any &lt;code&gt;Exception&lt;/code&gt;s. Applications are &lt;em&gt;strongly&lt;/em&gt; encouraged to register and use &lt;code&gt;ErrorListener&lt;/code&gt;s that insure proper behavior for warnings and errors.</source>
          <target state="translated">如果应用程序&lt;em&gt;没有&lt;/em&gt;注册自己的自定义 &lt;code&gt;ErrorListener&lt;/code&gt; ，默认的 &lt;code&gt;ErrorListener&lt;/code&gt; 使用哪个报告的所有警告和错误 &lt;code&gt;System.err&lt;/code&gt; 的，并不会引发任何 &lt;code&gt;Exception&lt;/code&gt; 秒。&lt;em&gt;强烈&lt;/em&gt;建议应用程序注册并使用 &lt;code&gt;ErrorListener&lt;/code&gt; ，以确保警告和错误的正确行为。</target>
        </trans-unit>
        <trans-unit id="607a97ae51696a6fd94c9201bbd08e82f31c7cfe" translate="yes" xml:space="preserve">
          <source>If an application does not provide a listener, the &lt;a href=&quot;transformerfactory&quot;&gt;&lt;code&gt;TransformerFactory&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;transformer&quot;&gt;&lt;code&gt;Transformer&lt;/code&gt;&lt;/a&gt; shall create one on its own. The default &lt;code&gt;ErrorListener&lt;/code&gt; may take no action for warnings and recoverable errors, and allow the transformation to continue. However, the &lt;code&gt;TransformerFactory&lt;/code&gt; or &lt;code&gt;Transformer&lt;/code&gt; may still throw &lt;code&gt;TransformerException&lt;/code&gt; when it decides it can not continue processing.</source>
          <target state="translated">如果应用程序不提供侦听器，则&lt;a href=&quot;transformerfactory&quot;&gt; &lt;code&gt;TransformerFactory&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;transformer&quot;&gt; &lt;code&gt;Transformer&lt;/code&gt; &lt;/a&gt;应自行创建一个侦听器。默认的 &lt;code&gt;ErrorListener&lt;/code&gt; 可能对警告和可恢复的错误不采取任何措施，并允许转换继续进行。但是，当 &lt;code&gt;TransformerFactory&lt;/code&gt; 或 &lt;code&gt;Transformer&lt;/code&gt; 决定无法继续处理时，它可能仍会引发 &lt;code&gt;TransformerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0dbacd8fdd96aa697bee57950998d0a96108abc1" translate="yes" xml:space="preserve">
          <source>If an application or a system is internationalized and provides localized resources for multiple locales, it sometimes needs to find one or more locales (or language tags) which meet each user's specific preferences. Note that a term &quot;language tag&quot; is used interchangeably with &quot;locale&quot; in this locale matching documentation.</source>
          <target state="translated">如果一个应用程序或系统是国际化的,并为多个地区提供本地化资源,它有时需要找到一个或多个符合每个用户特定偏好的地区语言(或语言标签)。请注意,在本语言匹配文档中,术语 &quot;语言标签 &quot;与 &quot;locale &quot;可互换使用。</target>
        </trans-unit>
        <trans-unit id="95627f13c311b8727d628cb2f5a559e1e571b551" translate="yes" xml:space="preserve">
          <source>If an application wants to perform some action based on a button being pressed and released, it should implement &lt;code&gt;ActionListener&lt;/code&gt; and register the new listener to receive events from this button, by calling the button's &lt;code&gt;addActionListener&lt;/code&gt; method. The application can make use of the button's action command as a messaging protocol.</source>
          <target state="translated">如果应用程序希望基于按下和释放的按钮执行某些操作，则应实现 &lt;code&gt;ActionListener&lt;/code&gt; 并注册新的侦听器，以通过调用按钮的 &lt;code&gt;addActionListener&lt;/code&gt; 方法来接收来自此按钮的事件。该应用程序可以将按钮的action命令用作消息传递协议。</target>
        </trans-unit>
        <trans-unit id="b2dd9b01f32a7dbe5dfc9a2ba9f8a990861694b9" translate="yes" xml:space="preserve">
          <source>If an application wants to perform some action based on an item in this list being selected or activated by the user, it should implement &lt;code&gt;ItemListener&lt;/code&gt; or &lt;code&gt;ActionListener&lt;/code&gt; as appropriate and register the new listener to receive events from this list.</source>
          <target state="translated">如果应用程序要基于用户选择或激活的列表中的某个项目执行某些操作，则应适当地实现 &lt;code&gt;ItemListener&lt;/code&gt; 或 &lt;code&gt;ActionListener&lt;/code&gt; 并注册新的侦听器以从该列表中接收事件。</target>
        </trans-unit>
        <trans-unit id="2c765f1f20083db8a0a74030169afc641514a1ce" translate="yes" xml:space="preserve">
          <source>If an application wants to set the ErrorHandler or EntityResolver for an XMLReader used during a transformation, it should use a URIResolver to return the SAXSource which provides (with getXMLReader) a reference to the XMLReader.</source>
          <target state="translated">如果一个应用程序想要为在转换过程中使用的XMLReader设置ErrorHandler或EntityResolver,它应该使用URIResolver来返回SAXSource,该SAXSource提供(与getXMLReader一起)对XMLReader的引用。</target>
        </trans-unit>
        <trans-unit id="f6d7860179acd56276c79c3590549cb4c6e64204" translate="yes" xml:space="preserve">
          <source>If an argument index is used for more than one format element in the pattern string, then the corresponding new format is used for all such format elements. If an argument index is not used for any format element in the pattern string, then the corresponding new format is ignored. If fewer formats are provided than needed, then only the formats for argument indices less than &lt;code&gt;newFormats.length&lt;/code&gt; are replaced.</source>
          <target state="translated">如果自变量索引用于模式字符串中的多个格式元素，则将相应的新格式用于所有此类格式元素。如果参数字符串未用于模式字符串中的任何格式元素，则将忽略相应的新格式。如果提供的格式少于需要的格式，则仅替换参数索引小于 &lt;code&gt;newFormats.length&lt;/code&gt; 的格式。</target>
        </trans-unit>
        <trans-unit id="1f72387046823cf7698e1a0b6d176b89054ec4a7" translate="yes" xml:space="preserve">
          <source>If an argument index is used for more than one format element in the pattern string, then the format used for the last such format element is returned in the array. If an argument index is not used for any format element in the pattern string, then null is returned in the array.</source>
          <target state="translated">如果一个参数索引被用于模式字符串中的一个以上的格式元素,那么数组中返回最后一个这样的格式元素所使用的格式,如果一个参数索引没有被用于模式字符串中的任何格式元素,那么数组中返回null。如果一个参数索引没有用于模式字符串中的任何格式元素,那么数组中返回null。</target>
        </trans-unit>
        <trans-unit id="60e1dcd8583415c6d79ee79aff279d16dea818d7" translate="yes" xml:space="preserve">
          <source>If an attempt is made to add an attribute that is already in use elsewhere.</source>
          <target state="translated">如果试图添加一个已经在其他地方使用的属性。</target>
        </trans-unit>
        <trans-unit id="a1629656009e8137e699c56c52cd43983c5570b7" translate="yes" xml:space="preserve">
          <source>If an attempt is made to create or change an object in a way which is incorrect with regard to namespaces.</source>
          <target state="translated">如果试图以不正确的命名空间方式创建或更改对象。</target>
        </trans-unit>
        <trans-unit id="24724cffc57a37c811ffa42d73d239354e6db8a1" translate="yes" xml:space="preserve">
          <source>If an attempt is made to modify an object where modifications are not allowed.</source>
          <target state="translated">如果试图修改一个不允许修改的对象。</target>
        </trans-unit>
        <trans-unit id="19d41b1964221f77e17c0e94a5badbf64e32ab22" translate="yes" xml:space="preserve">
          <source>If an attempt is made to modify the type of the underlying object.</source>
          <target state="translated">如果试图修改基础对象的类型。</target>
        </trans-unit>
        <trans-unit id="2a0bd5db21e0237af0e5f242375953f6a02b04f7" translate="yes" xml:space="preserve">
          <source>If an attempt is made to reference a &lt;code&gt;Node&lt;/code&gt; in a context where it does not exist.</source>
          <target state="translated">如果尝试在不存在的上下文中引用 &lt;code&gt;Node&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95f550c8bb30a788e989fe605398e29ff476452c" translate="yes" xml:space="preserve">
          <source>If an attempt is made to use an object that is not, or is no longer, usable.</source>
          <target state="translated">如果试图使用一个不可用或不再可用的对象;</target>
        </trans-unit>
        <trans-unit id="a897beabf4b5ef8fb695d39602ed612135397241" translate="yes" xml:space="preserve">
          <source>If an attempt was made to load a document, or an XML Fragment, using &lt;code&gt;LSParser&lt;/code&gt; and the processing has been stopped.</source>
          <target state="translated">如果尝试使用 &lt;code&gt;LSParser&lt;/code&gt; 加载文档或XML片段，则该处理已停止。</target>
        </trans-unit>
        <trans-unit id="e5cccc7a6e78ca84d0519ccae83f8865c3f31cba" translate="yes" xml:space="preserve">
          <source>If an attempt was made to serialize a &lt;code&gt;Node&lt;/code&gt; using &lt;code&gt;LSSerializer&lt;/code&gt; and the processing has been stopped.</source>
          <target state="translated">如果尝试使用 &lt;code&gt;LSSerializer&lt;/code&gt; 序列化 &lt;code&gt;Node&lt;/code&gt; ，则处理已停止。</target>
        </trans-unit>
        <trans-unit id="bd454c7aa8c21821eb903a4d4d4438d54e9d0c75" translate="yes" xml:space="preserve">
          <source>If an attribute class extends &lt;code&gt;EnumSyntax&lt;/code&gt;, and the value of the attribute is an IPP-compatible value, the attribute's &lt;code&gt;toString&lt;/code&gt; method returns the IPP string representation of the attribute value, such as &quot;processing-stopped&quot; for the &lt;a href=&quot;jobstate&quot;&gt;JobState&lt;/a&gt; attribute. However, because the &lt;code&gt;EnumSyntax&lt;/code&gt; class is extensible, vendors can define their own attribute values. If an attribute uses the &lt;code&gt;EnumSyntax&lt;/code&gt; class and is set to one of these vendor-defined values then the &lt;code&gt;toString&lt;/code&gt; method will not return the IPP string representation of the value.</source>
          <target state="translated">如果属性类扩展了 &lt;code&gt;EnumSyntax&lt;/code&gt; ，并且该属性的值是IPP兼容的值，则该属性的 &lt;code&gt;toString&lt;/code&gt; 方法返回该属性值的IPP字符串表示形式，例如&lt;a href=&quot;jobstate&quot;&gt;JobState&lt;/a&gt;属性的&amp;ldquo; processing-stopped&amp;rdquo; 。但是，由于 &lt;code&gt;EnumSyntax&lt;/code&gt; 类是可扩展的，因此供应商可以定义自己的属性值。如果属性使用 &lt;code&gt;EnumSyntax&lt;/code&gt; 类并且设置为这些供应商定义的值之一，则 &lt;code&gt;toString&lt;/code&gt; 方法将不会返回该值的IPP字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="4623c2eee5d41a35f73f5f405c0c8600ff819521" translate="yes" xml:space="preserve">
          <source>If an attribute implements &lt;a href=&quot;docattribute&quot;&gt;&lt;code&gt;DocAttribute&lt;/code&gt;&lt;/a&gt; as well as &lt;code&gt;PrintRequestAttribute&lt;/code&gt;, the client may include the attribute in a &lt;code&gt;Doc&lt;/code&gt;'s attribute set to specify a job setting which pertains just to that doc.</source>
          <target state="translated">如果属性工具&lt;a href=&quot;docattribute&quot;&gt; &lt;code&gt;DocAttribute&lt;/code&gt; &lt;/a&gt;以及 &lt;code&gt;PrintRequestAttribute&lt;/code&gt; ，则客户端可以包括在属性 &lt;code&gt;Doc&lt;/code&gt; 的属性设置为指定作业设置其所属刚刚访问该文档。</target>
        </trans-unit>
        <trans-unit id="a2271d961817d69ed166f3999b4fca55a2a3bfd1" translate="yes" xml:space="preserve">
          <source>If an attribute implements &lt;a href=&quot;docattribute&quot;&gt;&lt;code&gt;DocAttribute&lt;/code&gt;&lt;/a&gt; as well as PrintRequestAttribute, the client may include the attribute in a &lt;code&gt;Doc&lt;/code&gt;}'s attribute set to specify a job setting which pertains just to that doc.</source>
          <target state="translated">如果属性&lt;a href=&quot;docattribute&quot;&gt; &lt;code&gt;DocAttribute&lt;/code&gt; &lt;/a&gt;实现DocAttribute又实现PrintRequestAttribute，则客户端可以将该属性包括在 &lt;code&gt;Doc&lt;/code&gt; }的属性集中，以指定仅与该文档相关的作业设置。</target>
        </trans-unit>
        <trans-unit id="8553a6030a41f0e392620a86588d848a2d5646af" translate="yes" xml:space="preserve">
          <source>If an attribute of the given name already exists then its value is replaced. If the attribute does not exist then it is created. If it implementation specific if a test to check for the existence of the attribute and the creation of attribute are atomic with respect to other file system activities.</source>
          <target state="translated">如果给定名称的属性已经存在,则替换其值。如果属性不存在,则创建它。如果检查属性是否存在的测试和属性的创建相对于其他文件系统活动来说是原子的,那么它就是特定的实现。</target>
        </trans-unit>
        <trans-unit id="8a01717d98769d18078234570b7f435e850c09eb" translate="yes" xml:space="preserve">
          <source>If an authenticator is set on the HttpContext that owns this exchange, then this method will return the &lt;a href=&quot;httpprincipal&quot;&gt;&lt;code&gt;HttpPrincipal&lt;/code&gt;&lt;/a&gt; that represents the authenticated user for this HttpExchange.</source>
          <target state="translated">如果在拥有此交换的HttpContext上设置了身份验证器，则此方法将返回&lt;a href=&quot;httpprincipal&quot;&gt; &lt;code&gt;HttpPrincipal&lt;/code&gt; &lt;/a&gt;，该HttpPrincipal表示此HttpExchange的已身份验证用户。</target>
        </trans-unit>
        <trans-unit id="27440a763ede5ab8ba752691c8d7cfa12b2cc574" translate="yes" xml:space="preserve">
          <source>If an authority is given then the string &lt;code&gt;&quot;//&quot;&lt;/code&gt; is appended, followed by the authority. If the authority contains a literal IPv6 address then the address must be enclosed in square brackets (&lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;). Any character not in the</source>
          <target state="translated">如果给出了授权，则字符串 &lt;code&gt;&quot;//&quot;&lt;/code&gt; 被附加，后面是授权。如果授权机构包含原义的IPv6地址，则该地址必须括在方括号（ &lt;code&gt;'['&lt;/code&gt; 和 &lt;code&gt;']'&lt;/code&gt; ）中。不在的任何字符</target>
        </trans-unit>
        <trans-unit id="6b54c42030a2b2622209db57c79949e15fb60f06" translate="yes" xml:space="preserve">
          <source>If an child element is insert into a parent element, the parent element should report a change. If the child element also had elements inserted into it (grandchildren to the parent) these elements need not report change.</source>
          <target state="translated">如果一个子元素被插入到父元素中,父元素应该报告一个变化。如果子元素也被插入了元素(父元素的孙子元素),这些元素不需要报告变化。</target>
        </trans-unit>
        <trans-unit id="30c03b38fd51437f34d169d8c1845e0f976cba81" translate="yes" xml:space="preserve">
          <source>If an element &lt;code&gt;e&lt;/code&gt; is an array of a primitive type, it is converted to a string as by invoking the appropriate overloading of &lt;code&gt;Arrays.toString(e)&lt;/code&gt;. If an element &lt;code&gt;e&lt;/code&gt; is an array of a reference type, it is converted to a string as by invoking this method recursively.</source>
          <target state="translated">如果元素 &lt;code&gt;e&lt;/code&gt; 是原始类型的数组，则通过调用 &lt;code&gt;Arrays.toString(e)&lt;/code&gt; 的适当重载将其转换为字符串。如果元素 &lt;code&gt;e&lt;/code&gt; 是引用类型的数组，则通过递归调用此方法将其转换为字符串。</target>
        </trans-unit>
        <trans-unit id="7fadd0956f2848503358e60b1e94c3a6c5020fa1" translate="yes" xml:space="preserve">
          <source>If an element is a path to a directory of modules then each entry in the directory is a packaged module or the top-level directory of an exploded module. It is an error if a directory contains more than one module with the same name. If an element is a path to a directory, and that directory contains a file named &lt;code&gt;module-info.class&lt;/code&gt;, then the directory is treated as an exploded module rather than a directory of modules.</source>
          <target state="translated">如果元素是模块目录的路径，则目录中的每个条目都是打包模块或分解模块的顶级目录。如果一个目录包含多个具有相同名称的模块，则会出现错误。如果元素是目录的路径，并且该目录包含名为 &lt;code&gt;module-info.class&lt;/code&gt; 的文件，则该目录将被视为分解模块，而不是模块目录。</target>
        </trans-unit>
        <trans-unit id="4c8b1aa9c76b0a6c06cd6d1249058d6819f7727d" translate="yes" xml:space="preserve">
          <source>If an element or attribute name has a prefix, but is not bound to any namespace URI, then the prefix will be removed during serialization.</source>
          <target state="translated">如果一个元素或属性名有一个前缀,但没有绑定到任何命名空间URI,那么前缀将在序列化过程中被删除。</target>
        </trans-unit>
        <trans-unit id="9604ec88c64afb1d9f67cf4516415fedcdca634f" translate="yes" xml:space="preserve">
          <source>If an element or attribute name is bound to a prefix and there is a namespace declaration that binds that prefix to a different URI then that namespace declaration is either removed if the correct mapping is inherited from the parent context of that element, or changed to the namespace URI of the element or attribute using that prefix.</source>
          <target state="translated">如果一个元素或属性名称被绑定到一个前缀,并且有一个命名空间声明将该前缀绑定到一个不同的URI,那么如果正确的映射是从该元素的父上下文中继承的,那么该命名空间声明就会被删除,或者改为使用该前缀的元素或属性的命名空间URI。</target>
        </trans-unit>
        <trans-unit id="c29918c5773fbdbf37d6f7f698f089f0789ff358" translate="yes" xml:space="preserve">
          <source>If an element or attribute name uses a prefix that is bound to a different URI than that inherited from the namespace context of the parent of that element and there is no namespace declaration in the context of the current element then such a namespace declaration is added.</source>
          <target state="translated">如果一个元素或属性名使用的前缀与该元素父元素的命名空间上下文中继承的URI不同,而当前元素的上下文中没有命名空间声明,那么就会添加这样的命名空间声明。</target>
        </trans-unit>
        <trans-unit id="261e54ff065700a24467a3b37a05bc35f1bc1e0e" translate="yes" xml:space="preserve">
          <source>If an entry already exists for the specified alias, it is overridden.</source>
          <target state="translated">如果指定的别名已经存在一个条目,则会被覆盖。</target>
        </trans-unit>
        <trans-unit id="fd9f14cb55aec7f7c0b7e951ed92525cdc983689" translate="yes" xml:space="preserve">
          <source>If an error occurs during the initial handshake, this method returns an invalid session object which reports an invalid cipher suite of &quot;SSL_NULL_WITH_NULL_NULL&quot;.</source>
          <target state="translated">如果在初始握手过程中发生错误,该方法返回一个无效的会话对象,该对象报告一个无效的密码套件 &quot;SSL_NULL_WITH_NULL_NULL&quot;。</target>
        </trans-unit>
        <trans-unit id="ff4bf02a9e9b23d87b04df576e60bab4d6f37a68" translate="yes" xml:space="preserve">
          <source>If an error occurs in setting any of the client info properties, a &lt;code&gt;SQLClientInfoException&lt;/code&gt; is thrown. The &lt;code&gt;SQLClientInfoException&lt;/code&gt; contains information indicating which client info properties were not set. The state of the client information is unknown because some databases do not allow multiple client info properties to be set atomically. For those databases, one or more properties may have been set before the error occurred.</source>
          <target state="translated">如果在设置任何客户端信息属性时发生错误，则会引发 &lt;code&gt;SQLClientInfoException&lt;/code&gt; 。该 &lt;code&gt;SQLClientInfoException&lt;/code&gt; 包含指示该客户端信息属性未设置信息。客户信息的状态未知，因为某些数据库不允许原子设置多个客户信息属性。对于那些数据库，在错误发生之前可能已经设置了一个或多个属性。</target>
        </trans-unit>
        <trans-unit id="1773b2b10f572a15df1a83f51dfc4260cdf90a56" translate="yes" xml:space="preserve">
          <source>If an error occurs then the SSL socket is closed and an IOException is thrown. The underlying connection remains intact.</source>
          <target state="translated">如果发生错误,那么SSL套接字就会被关闭,并抛出一个IOException。底层连接保持完整。</target>
        </trans-unit>
        <trans-unit id="0571b6ce6440517f906763cbff3a06c35743d89b" translate="yes" xml:space="preserve">
          <source>If an error occurs while parsing, the caller is notified through the &lt;code&gt;ErrorHandler&lt;/code&gt; instance associated with the &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt;&quot; parameter of the &lt;code&gt;DOMConfiguration&lt;/code&gt;.</source>
          <target state="translated">如果解析时发生错误，则会通过与 &lt;code&gt;DOMConfiguration&lt;/code&gt; 的&amp;ldquo; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt; &amp;rdquo;参数关联的 &lt;code&gt;ErrorHandler&lt;/code&gt; 实例通知调用方。</target>
        </trans-unit>
        <trans-unit id="c6ef064ac38936491ed2c3e376ac7740ad6dc231" translate="yes" xml:space="preserve">
          <source>If an event doesn't have the annotation, then by default the event is enabled.</source>
          <target state="translated">如果一个事件没有注释,那么默认情况下该事件是启用的。</target>
        </trans-unit>
        <trans-unit id="6560375df8c26d01983629f3966222dadc471a6f" translate="yes" xml:space="preserve">
          <source>If an event is cancelable, the &lt;code&gt;preventDefault&lt;/code&gt; method is used to signify that the event is to be canceled, meaning any default action normally taken by the implementation as a result of the event will not occur.</source>
          <target state="translated">如果事件是可取消的，则 &lt;code&gt;preventDefault&lt;/code&gt; 方法用于表示该事件将被取消，这意味着实现通常不会由于该事件而执行任何默认操作。</target>
        </trans-unit>
        <trans-unit id="61a7893cf4ef57d2ac863b712446f1ad303120a8" translate="yes" xml:space="preserve">
          <source>If an event is cancelable, the &lt;code&gt;preventDefault&lt;/code&gt; method is used to signify that the event is to be canceled, meaning any default action normally taken by the implementation as a result of the event will not occur. If, during any stage of event flow, the &lt;code&gt;preventDefault&lt;/code&gt; method is called the event is canceled. Any default action associated with the event will not occur. Calling this method for a non-cancelable event has no effect. Once &lt;code&gt;preventDefault&lt;/code&gt; has been called it will remain in effect throughout the remainder of the event's propagation. This method may be used during any stage of event flow.</source>
          <target state="translated">如果事件是可取消的，则 &lt;code&gt;preventDefault&lt;/code&gt; 方法用于表示该事件将被取消，这意味着实现通常不会由于该事件而执行任何默认操作。如果在事件流的任何阶段 &lt;code&gt;preventDefault&lt;/code&gt; 了preventDefault方法，则将取消该事件。与该事件关联的任何默认操作都不会发生。对于不可取消的事件调用此方法无效。一旦 &lt;code&gt;preventDefault&lt;/code&gt; 被调用，它将在事件传播的其余整个过程中保持有效。在事件流的任何阶段都可以使用此方法。</target>
        </trans-unit>
        <trans-unit id="b50c4239d3f5ba08fc26d40f5cf9ea945de22195" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by &lt;code&gt;RemoteRef.invoke&lt;/code&gt; and that exception is a checked exception that is not assignable to any exception in the &lt;code&gt;throws&lt;/code&gt; clause of the method implemented by the &lt;code&gt;proxy&lt;/code&gt;'s class, then that exception is wrapped in an &lt;a href=&quot;../unexpectedexception&quot;&gt;&lt;code&gt;UnexpectedException&lt;/code&gt;&lt;/a&gt; and the wrapped exception is thrown. Otherwise, the exception thrown by &lt;code&gt;invoke&lt;/code&gt; is thrown by this method.</source>
          <target state="translated">如果 &lt;code&gt;RemoteRef.invoke&lt;/code&gt; 抛出异常，并且该异常是已检查的异常，并且不能分配给 &lt;code&gt;proxy&lt;/code&gt; 类实现的方法的 &lt;code&gt;throws&lt;/code&gt; 子句中的任何异常，则该异常将包装在&lt;a href=&quot;../unexpectedexception&quot;&gt; &lt;code&gt;UnexpectedException&lt;/code&gt; &lt;/a&gt;和包装的异常中被抛出。否则，此方法将引发 &lt;code&gt;invoke&lt;/code&gt; 引发的异常。</target>
        </trans-unit>
        <trans-unit id="0469e2eb38e10c985523abc8d2b5541786c72d7d" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during an enumeration, the enumeration becomes invalid. Subsequent invocation of any method on that enumeration will yield undefined results.</source>
          <target state="translated">如果在枚举过程中抛出异常,那么这个枚举就会失效。随后对该枚举的任何方法的调用将产生未定义的结果。</target>
        </trans-unit>
        <trans-unit id="a2b9719db0ece122f09c48cc72299d47645e3e63" translate="yes" xml:space="preserve">
          <source>If an exception is thrown from this method, it is considered to be equivalent of returning &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果从此方法引发异常，则认为该异常等同于返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="baf28062714220f5e512946ca5d9f8fcc778ea9f" translate="yes" xml:space="preserve">
          <source>If an exception is thrown from this method, resulting behavior is undefined.</source>
          <target state="translated">如果从这个方法中抛出了一个异常,那么产生的行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="4edf72f63744ff4e52753a8efa7493d7a0576ed0" translate="yes" xml:space="preserve">
          <source>If an exception type is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">如果异常类型是类型变量或参数化类型,则会被创建。否则,它将被解析。</target>
        </trans-unit>
        <trans-unit id="383733cb23b40d1a57028c685e2f09b242e4957b" translate="yes" xml:space="preserve">
          <source>If an exception, &lt;code&gt;E&lt;/code&gt; say, occurs during execution of the bootstrap method, then resolution fails and terminates abnormally. &lt;code&gt;E&lt;/code&gt; is rethrown if the type of &lt;code&gt;E&lt;/code&gt; is &lt;code&gt;Error&lt;/code&gt; or a subclass, otherwise a &lt;code&gt;BootstrapMethodError&lt;/code&gt; that wraps &lt;code&gt;E&lt;/code&gt; is thrown. If this happens, the same error will be thrown for all subsequent attempts to execute the &lt;code&gt;invokedynamic&lt;/code&gt; instruction or load the dynamically-computed constant.</source>
          <target state="translated">如果在执行bootstrap方法的过程中发生异常（例如 &lt;code&gt;E&lt;/code&gt; )，则解析失败并异常终止。 &lt;code&gt;E&lt;/code&gt; 被重新抛出，如果类型 &lt;code&gt;E&lt;/code&gt; 是 &lt;code&gt;Error&lt;/code&gt; 或子类，否则 &lt;code&gt;BootstrapMethodError&lt;/code&gt; 它包装 &lt;code&gt;E&lt;/code&gt; 被抛出。如果发生这种情况，则在随后的执行 &lt;code&gt;invokedynamic&lt;/code&gt; 指令或加载动态计算的常量的所有后续尝试中都将引发相同的错误。</target>
        </trans-unit>
        <trans-unit id="daaa77166dccaba4fc56b68f0c67338ce9025815" translate="yes" xml:space="preserve">
          <source>If an existing &lt;code&gt;Processor&lt;/code&gt; object is not being used, to create an instance of a processor the tool calls the no-arg constructor of the processor class.</source>
          <target state="translated">如果未使用现有的 &lt;code&gt;Processor&lt;/code&gt; 对象，则该工具将调用处理器类的no-arg构造函数以创建处理器的实例。</target>
        </trans-unit>
        <trans-unit id="e6c975a8f1f73672a8298c66b4c9a0fbbf3cedc1" translate="yes" xml:space="preserve">
          <source>If an explicit &lt;a href=&quot;httpclient.builder#executor(java.util.concurrent.Executor)&quot;&gt;executor&lt;/a&gt; has not been set for an &lt;code&gt;HttpClient&lt;/code&gt;, and a security manager has been installed, then the default executor will execute asynchronous and dependent tasks in a context that is granted no permissions. Custom &lt;a href=&quot;httprequest.bodypublisher&quot;&gt;request body publishers&lt;/a&gt;, &lt;a href=&quot;httpresponse.bodyhandler&quot;&gt;response body handlers&lt;/a&gt;, &lt;a href=&quot;httpresponse.bodysubscriber&quot;&gt;response body subscribers&lt;/a&gt;, and &lt;a href=&quot;websocket.listener&quot;&gt;WebSocket Listeners&lt;/a&gt;, if executing operations that require privileges, should do so within an appropriate &lt;a href=&quot;../../../../java.base/java/security/accesscontroller#doPrivileged(java.security.PrivilegedAction)&quot;&gt;privileged context&lt;/a&gt;.</source>
          <target state="translated">如果尚未为 &lt;code&gt;HttpClient&lt;/code&gt; 设置显式&lt;a href=&quot;httpclient.builder#executor(java.util.concurrent.Executor)&quot;&gt;执行&lt;/a&gt;程序，并且已安装安全管理器，则默认执行程序将在未授予任何权限的上下文中执行异步任务和相关任务。定制&lt;a href=&quot;httprequest.bodypublisher&quot;&gt;请求主体发布者&lt;/a&gt;，&lt;a href=&quot;httpresponse.bodyhandler&quot;&gt;响应主体处理程序&lt;/a&gt;，&lt;a href=&quot;httpresponse.bodysubscriber&quot;&gt;响应主体订阅者&lt;/a&gt;和&lt;a href=&quot;websocket.listener&quot;&gt;WebSocket侦听器&lt;/a&gt;，如果执行需要特权的操作，则应在适当的&lt;a href=&quot;../../../../java.base/java/security/accesscontroller#doPrivileged(java.security.PrivilegedAction)&quot;&gt;特权上下文中执行&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="334f0a371bfe2e32de25175071515e6114979f87" translate="yes" xml:space="preserve">
          <source>If an implementation does implement this interface, it is expected to understand the specific syntax of the shorthand properties, and apply their semantics; when the &lt;code&gt;margin&lt;/code&gt; property is set, for example, the &lt;code&gt;marginTop&lt;/code&gt;, &lt;code&gt;marginRight&lt;/code&gt;, &lt;code&gt;marginBottom&lt;/code&gt; and &lt;code&gt;marginLeft&lt;/code&gt; properties are actually being set by the underlying implementation.</source>
          <target state="translated">如果实现确实实现了此接口，则应该理解速记属性的特定语法，并应用其语义；例如，当设置 &lt;code&gt;margin&lt;/code&gt; 属性时，底层实现实际上会设置 &lt;code&gt;marginTop&lt;/code&gt; ， &lt;code&gt;marginRight&lt;/code&gt; ， &lt;code&gt;marginBottom&lt;/code&gt; 和 &lt;code&gt;marginLeft&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="7d315c92816e5851e4dc9c39278030e06b4e20d6" translate="yes" xml:space="preserve">
          <source>If an implementation does not support schemas, it should throw OperationNotSupportedException. If an implementation does support schemas, it should define this method to return the appropriate information.</source>
          <target state="translated">如果一个实现不支持模式,它应该抛出OperationNotSupportedException。如果一个实现确实支持模式,它应该定义这个方法来返回相应的信息。</target>
        </trans-unit>
        <trans-unit id="c4c73fde229aaf78d628130cf2dc942c93b26494" translate="yes" xml:space="preserve">
          <source>If an implementation has not been specified with the system property, then the system-default implementation class is instantiated, and the result is returned.</source>
          <target state="translated">如果没有用system属性指定实现,则实例化系统默认的实现类,并返回结果。</target>
        </trans-unit>
        <trans-unit id="0790bd1055cd2781acb9f390ec8d77d9efcbd487" translate="yes" xml:space="preserve">
          <source>If an implementation of this method returns &lt;code&gt;false&lt;/code&gt;, then the KeyEvent is passed to the next KeyEventDispatcher in the chain, ending with the current KeyboardFocusManager. If an implementation returns &lt;code&gt;true&lt;/code&gt;, the KeyEvent is assumed to have been dispatched (although this need not be the case), and the current KeyboardFocusManager will take no further action with regard to the KeyEvent. In such a case, &lt;code&gt;KeyboardFocusManager.dispatchEvent&lt;/code&gt; should return &lt;code&gt;true&lt;/code&gt; as well. If an implementation consumes the KeyEvent, but returns &lt;code&gt;false&lt;/code&gt;, the consumed event will still be passed to the next KeyEventDispatcher in the chain. It is important for developers to check whether the KeyEvent has been consumed before dispatching it to a target. By default, the current KeyboardFocusManager will not dispatch a consumed KeyEvent.</source>
          <target state="translated">如果此方法的实现返回 &lt;code&gt;false&lt;/code&gt; ，则将KeyEvent传递到链中的下一个KeyEventDispatcher，以当前的KeyboardFocusManager结尾。如果实现返回 &lt;code&gt;true&lt;/code&gt; ，则假定已调度KeyEvent（尽管不必如此），并且当前的KeyboardFocusManager将不对KeyEvent采取任何进一步的操作。在这种情况下， &lt;code&gt;KeyboardFocusManager.dispatchEvent&lt;/code&gt; 也应返回 &lt;code&gt;true&lt;/code&gt; 。如果实现消耗了KeyEvent，但返回 &lt;code&gt;false&lt;/code&gt; ，消费事件仍将传递到链中的下一个KeyEventDispatcher。对于开发人员而言，重要的是在将KeyEvent分发给目标之前检查其是否已被使用。默认情况下，当前的KeyboardFocusManager不会调度已消耗的KeyEvent。</target>
        </trans-unit>
        <trans-unit id="e13652b1c7db8e5309427a9d44bc7e8f9963245a" translate="yes" xml:space="preserve">
          <source>If an implementation of this method returns &lt;code&gt;false&lt;/code&gt;, then the KeyEvent is passed to the next KeyEventPostProcessor in the chain, ending with the current KeyboardFocusManager. If an implementation returns &lt;code&gt;true&lt;/code&gt;, the KeyEvent is assumed to have been fully handled (although this need not be the case), and the AWT will take no further action with regard to the KeyEvent. If an implementation consumes the KeyEvent but returns &lt;code&gt;false&lt;/code&gt;, the consumed event will still be passed to the next KeyEventPostProcessor in the chain. It is important for developers to check whether the KeyEvent has been consumed before performing any post-processing of the KeyEvent. By default, the current KeyboardFocusManager will perform no post- processing in response to a consumed KeyEvent.</source>
          <target state="translated">如果此方法的实现返回 &lt;code&gt;false&lt;/code&gt; ，则将KeyEvent传递到链中的下一个KeyEventPostProcessor，以当前的KeyboardFocusManager结尾。如果实现返回 &lt;code&gt;true&lt;/code&gt; ，则假定KeyEvent已被完全处理（尽管不必如此），并且AWT将不会对KeyEvent采取任何进一步的措施。如果实现使用KeyEvent但返回 &lt;code&gt;false&lt;/code&gt; ，则消费的事件仍将传递到链中的下一个KeyEventPostProcessor。对于开发人员而言，在执行KeyEvent的任何后处理之前，检查KeyEvent是否已被消耗是很重要的。默认情况下，当前的KeyboardFocusManager将不对使用的KeyEvent进行任何后处理。</target>
        </trans-unit>
        <trans-unit id="f55248539ebf4b603fcbf731a4a482fec2765dd7" translate="yes" xml:space="preserve">
          <source>If an implementation performs any type of modification or &quot;normalization&quot; of a path, it should never move the coordinates by more than half a pixel in any direction.</source>
          <target state="translated">如果一个实现对路径进行任何类型的修改或 &quot;归一化&quot;,它绝对不应该在任何方向上将坐标移动半个像素以上。</target>
        </trans-unit>
        <trans-unit id="043b26dca2264b1abb0bfae84593fcda3d702603" translate="yes" xml:space="preserve">
          <source>If an implementation represents a field that can be simplified, or combined with others, then this method must be implemented.</source>
          <target state="translated">如果一个实现代表了一个可以简化的字段,或者与其他字段组合,那么这个方法必须被实现。</target>
        </trans-unit>
        <trans-unit id="e1d164fb2f90283981eb219956ff98c6a957bd3f" translate="yes" xml:space="preserve">
          <source>If an implementation supports a mechanism to start agents sometime after the VM has started then this attribute specifies the agent class. That is, the class containing the &lt;code&gt;agentmain&lt;/code&gt; method. This attribute is required if it is not present the agent will not be started. Note: this is a class name, not a file name or path.</source>
          <target state="translated">如果实现支持在VM启动后某个时间启动代理的机制，则此属性指定代理类。即，包含 &lt;code&gt;agentmain&lt;/code&gt; 方法的类。如果不存在此属性，那么将不会启动代理。注意：这是一个类名，而不是文件名或路径。</target>
        </trans-unit>
        <trans-unit id="c11093045a54063bd397d3d34918f97a76bef04b" translate="yes" xml:space="preserve">
          <source>If an implementation supports a mechanism to start an application as an executable JAR then the main manifest may include this attribute to specify the class name of an agent to start before the application &lt;code&gt;main&lt;/code&gt; method is invoked.</source>
          <target state="translated">如果实现支持将应用程序作为可执行JAR启动的机制，则主清单可以包含此属性，以指定在调用应用程序 &lt;code&gt;main&lt;/code&gt; 方法之前要启动的代理的类名。</target>
        </trans-unit>
        <trans-unit id="c89b3cdaab7f58f456c7aa47faa134eee7f364ef" translate="yes" xml:space="preserve">
          <source>If an init function is omitted, use a &lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;default value&lt;/a&gt; for the clause's iteration variable type.</source>
          <target state="translated">如果省略了init函数，请为子句的迭代变量类型使用&lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;默认值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3462188196e65e0014ae45d5a7fe6a01be0280ee" translate="yes" xml:space="preserve">
          <source>If an input method provides its own windows, it should make sure at this point that all necessary windows are open and visible.</source>
          <target state="translated">如果一个输入法提供了自己的窗口,此时应该确保所有必要的窗口都是打开的、可见的。</target>
        </trans-unit>
        <trans-unit id="cf5c43ab6dc0cdfce9e73d966f2af0a3e27508c4" translate="yes" xml:space="preserve">
          <source>If an input method provides its own windows, only windows that relate to the current composition (such as a lookup choice window) should be closed at this point. It is possible that the input method will be immediately activated again for a different client component, and closing and reopening more persistent windows (such as a control panel) would create unnecessary screen flicker. Before an instance of a different input method class is activated, &lt;a href=&quot;#hideWindows()&quot;&gt;&lt;code&gt;hideWindows()&lt;/code&gt;&lt;/a&gt; is called on the current input method.</source>
          <target state="translated">如果输入法提供了自己的窗口，则此时仅应关闭与当前合成相关的窗口（例如查找选择窗口）。可能会立即为其他客户端组件再次激活输入法，并且关闭并重新打开更持久的窗口（例如控制面板）会造成不必要的屏幕闪烁。在激活其他输入法类的实例之前，将在当前输入法上调用&lt;a href=&quot;#hideWindows()&quot;&gt; &lt;code&gt;hideWindows()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a0b10ca0277b7493d6ebe1c11b70f79c82379ba" translate="yes" xml:space="preserve">
          <source>If an input stream is open for the current row, a call to the method &lt;code&gt;next&lt;/code&gt; will implicitly close it. A &lt;code&gt;ResultSet&lt;/code&gt; object's warning chain is cleared when a new row is read.</source>
          <target state="translated">如果为当前行打开了输入流，则对 &lt;code&gt;next&lt;/code&gt; 方法的调用将隐式将其关闭。一个 &lt;code&gt;ResultSet&lt;/code&gt; 中当读取一个新的行对象的警告链被清除。</target>
        </trans-unit>
        <trans-unit id="582a161abac221d4fa47ae48f7051334a4e87df5" translate="yes" xml:space="preserve">
          <source>If an input stream is open for the current row, a call to the method &lt;code&gt;previous&lt;/code&gt; will implicitly close it. A &lt;code&gt;ResultSet&lt;/code&gt; object's warning change is cleared when a new row is read.</source>
          <target state="translated">如果输入流是开放的当前行，对方法的调用 &lt;code&gt;previous&lt;/code&gt; 将隐式关闭它。一个 &lt;code&gt;ResultSet&lt;/code&gt; 中当读取一个新行对象的警告变化被清除。</target>
        </trans-unit>
        <trans-unit id="f303c1f0d6c8117bfe8230a427e47b48a68363b7" translate="yes" xml:space="preserve">
          <source>If an invalid or illegal character is specified, such as in an XML name.</source>
          <target state="translated">如果指定了无效或非法的字符,例如在XML名称中。</target>
        </trans-unit>
        <trans-unit id="523ee71c788d6ee708d4f30befc0a7f2aeb4aadc" translate="yes" xml:space="preserve">
          <source>If an invalid or illegal string is specified.</source>
          <target state="translated">如果指定了一个无效或非法的字符串。</target>
        </trans-unit>
        <trans-unit id="3b30c559fc9c71304701a7f40146dfcf10b6d44b" translate="yes" xml:space="preserve">
          <source>If an object factory builder has been installed, it is used to create a factory for creating the object. Otherwise, the following rules are used to create the object:</source>
          <target state="translated">如果已经安装了对象工厂构建器,则使用它来创建工厂以创建对象。否则,将使用以下规则来创建对象。</target>
        </trans-unit>
        <trans-unit id="4831201808691533c49676c4c6acf9ec77b746a0" translate="yes" xml:space="preserve">
          <source>If an operation that calculates the bounding box of this &lt;code&gt;Polygon&lt;/code&gt; has already been performed, such as &lt;code&gt;getBounds&lt;/code&gt; or &lt;code&gt;contains&lt;/code&gt;, then this method updates the bounding box.</source>
          <target state="translated">如果已经执行了计算此 &lt;code&gt;Polygon&lt;/code&gt; 的边界框的操作（例如 &lt;code&gt;getBounds&lt;/code&gt; 或 &lt;code&gt;contains&lt;/code&gt; )，则此方法将更新边界框。</target>
        </trans-unit>
        <trans-unit id="55e5619029a147bf5b114e97cd80de4c090961fa" translate="yes" xml:space="preserve">
          <source>If an option is omitted from the map the default value is used.</source>
          <target state="translated">如果地图中省略了一个选项,则使用默认值。</target>
        </trans-unit>
        <trans-unit id="8baf09fa7c9f197ad74c665fba2d5cc5c6506ab1" translate="yes" xml:space="preserve">
          <source>If an optional &lt;code&gt;AffineTransform&lt;/code&gt; is specified, the coordinates returned in the iteration are transformed accordingly.</source>
          <target state="translated">如果指定了可选的 &lt;code&gt;AffineTransform&lt;/code&gt; ，则会相应地转换迭代中返回的坐标。</target>
        </trans-unit>
        <trans-unit id="2b3be881430739dc065ccc4b9432e347d8bc309f" translate="yes" xml:space="preserve">
          <source>If an override is added, then any date that is formatted or parsed will be affected.</source>
          <target state="translated">如果添加了覆盖,那么任何被格式化或解析的日期都会受到影响。</target>
        </trans-unit>
        <trans-unit id="255c469340eb5e4421672d0f2a54c086d1b3a334" translate="yes" xml:space="preserve">
          <source>If an override is added, then any instant that is formatted or parsed will be affected.</source>
          <target state="translated">如果添加了覆盖,那么任何被格式化或解析的瞬间都会受到影响。</target>
        </trans-unit>
        <trans-unit id="0fbebb5dc8d306792468bfb85d5fadc68fc9bcac" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical GMT offset changes, the method returns the raw offset value of the current date. In Honolulu, for example, its raw offset changed from GMT-10:30 to GMT-10:00 in 1947, and this method always returns -36000000 milliseconds (i.e., -10 hours).</source>
          <target state="translated">如果基础的 &lt;code&gt;TimeZone&lt;/code&gt; 实现子类支持历史GMT偏移量更改，则该方法返回当前日期的原始偏移量值。例如，在檀香山，其原始偏移量在1947年从GMT-10：30更改为GMT-10：00，并且此方法始终返回-36000000毫秒（即-10小时）。</target>
        </trans-unit>
        <trans-unit id="3a926ad586a71b3f84679e24d71e358a0ff83b65" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical GMT offset changes, the specified GMT offset is set as the latest GMT offset and the difference from the known latest GMT offset value is used to adjust all historical GMT offset values.</source>
          <target state="translated">如果基础的 &lt;code&gt;TimeZone&lt;/code&gt; 实现子类支持历史GMT偏移更改，则将指定的GMT偏移设置为最新GMT偏移，并将与已知最新GMT偏移值的差用于调整所有历史GMT偏移值。</target>
        </trans-unit>
        <trans-unit id="6ceaf11fd23c3b657da62f21ad506f54d009695c" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical and future Daylight Saving Time schedule changes, this method refers to the last known Daylight Saving Time rule that can be a future prediction and may not be the same as the current rule. Consider calling &lt;a href=&quot;#observesDaylightTime()&quot;&gt;&lt;code&gt;observesDaylightTime()&lt;/code&gt;&lt;/a&gt; if the current rule should also be taken into account.</source>
          <target state="translated">如果基础的 &lt;code&gt;TimeZone&lt;/code&gt; 实现子类支持历史和将来的夏时制时间表更改，则此方法引用最后一个已知的夏时制规则，该规则可以作为将来的预测，并且可能与当前规则不同。如果还应考虑当前规则，请考虑调用&lt;a href=&quot;#observesDaylightTime()&quot;&gt; &lt;code&gt;observesDaylightTime()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0ae28c236839ff6f2827de1f4455a2f8e23e12d" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical and future Daylight Saving Time schedule changes, this method refers to the last known Daylight Saving Time rule that can be a future prediction and may not be the same as the current rule. Consider calling &lt;a href=&quot;timezone#observesDaylightTime--&quot;&gt;&lt;code&gt;observesDaylightTime()&lt;/code&gt;&lt;/a&gt; if the current rule should also be taken into account.</source>
          <target state="translated">如果基础的 &lt;code&gt;TimeZone&lt;/code&gt; 实现子类支持历史和将来的夏时制时间表更改，则此方法引用最后一个已知的夏时制规则，该规则可以作为将来的预测，并且可能与当前规则不同。如果还应考虑当前规则，请考虑调用&lt;a href=&quot;timezone#observesDaylightTime--&quot;&gt; &lt;code&gt;observesDaylightTime()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ceae883a33c038a59aa9297cd34719c700a68dfa" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical and future Daylight Saving Time schedule changes, this method returns the amount of saving time of the last known Daylight Saving Time rule that can be a future prediction.</source>
          <target state="translated">如果基础的 &lt;code&gt;TimeZone&lt;/code&gt; 实现子类支持历史和将来的夏时制时间表更改，则此方法将返回最近的已知夏时制规则的保存时间量，该规则可以作为将来的预测。</target>
        </trans-unit>
        <trans-unit id="0c1866d41d7ee0ee47390cc53354c5fdd6a734fb" translate="yes" xml:space="preserve">
          <source>If an unexpected exception occurs in an action, it is possible to catch the exception in an error handler. An error handler can be registered using the &lt;a href=&quot;#onError(java.util.function.Consumer)&quot;&gt;&lt;code&gt;onError(Consumer)&lt;/code&gt;&lt;/a&gt; method. If no error handler is registered, the default behavior is to print the exception and its backtrace to the standard error stream.</source>
          <target state="translated">如果操作中发生意外的异常，则可以在错误处理程序中捕获该异常。可以使用&lt;a href=&quot;#onError(java.util.function.Consumer)&quot;&gt; &lt;code&gt;onError(Consumer)&lt;/code&gt; &lt;/a&gt;方法注册错误处理程序。如果未注册任何错误处理程序，则默认行为是将异常及其回溯记录打印到标准错误流中。</target>
        </trans-unit>
        <trans-unit id="cdd60a91ecf0c51d8f3876be3d469659d44d29f5" translate="yes" xml:space="preserve">
          <source>If an update between a disconnected &lt;code&gt;RowSet&lt;/code&gt; object and a data source violates the original query or the underlying data source constraints, this will result in undefined behavior for all disconnected &lt;code&gt;RowSet&lt;/code&gt; implementations and their designated &lt;code&gt;SyncProvider&lt;/code&gt; implementations. Not defining the behavior when such violations occur offers greater flexibility for a &lt;code&gt;SyncProvider&lt;/code&gt; implementation to determine its own best course of action.</source>
          <target state="translated">如果断开连接的 &lt;code&gt;RowSet&lt;/code&gt; 对象和数据源之间的更新违反了原始查询或基础数据源约束，则将导致所有断开连接的 &lt;code&gt;RowSet&lt;/code&gt; 实现及其指定的 &lt;code&gt;SyncProvider&lt;/code&gt; 实现的不确定行为。如果发生此类违规行为，则不定义行为将为 &lt;code&gt;SyncProvider&lt;/code&gt; 实现提供更大的灵活性，以决定其自己的最佳操作方案。</target>
        </trans-unit>
        <trans-unit id="e6cdcb6abb3fe6a57aabba3c4945a777923f2bd3" translate="yes" xml:space="preserve">
          <source>If another thread is already waiting at the exchange point then it is resumed for thread scheduling purposes and receives the object passed in by the current thread. The current thread returns immediately, receiving the object passed to the exchange by that other thread.</source>
          <target state="translated">如果另一个线程已经在交换点等待,那么为了线程调度的目的,它将被恢复,并接收当前线程传递进来的对象。当前线程立即返回,接收该另一线程传递给交换点的对象。</target>
        </trans-unit>
        <trans-unit id="864c1c31a0758e674e7daf1e62b8414fbaaecf21" translate="yes" xml:space="preserve">
          <source>If another thread is currently blocked in a selection operation then that invocation will return immediately. If no selection operation is currently in progress then the next invocation of a selection operation will return immediately unless &lt;a href=&quot;#selectNow()&quot;&gt;&lt;code&gt;selectNow()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#selectNow(java.util.function.Consumer)&quot;&gt;&lt;code&gt;selectNow(Consumer)&lt;/code&gt;&lt;/a&gt; is invoked in the meantime. In any case the value returned by that invocation may be non-zero. Subsequent selection operations will block as usual unless this method is invoked again in the meantime.</source>
          <target state="translated">如果当前在选择操作中阻止了另一个线程，则该调用将立即返回。如果当前没有正在进行选择操作，则除非同时调用&lt;a href=&quot;#selectNow()&quot;&gt; &lt;code&gt;selectNow()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#selectNow(java.util.function.Consumer)&quot;&gt; &lt;code&gt;selectNow(Consumer)&lt;/code&gt; ,&lt;/a&gt;否则选择操作的下一次调用将立即返回。在任何情况下，该调用返回的值都可以为非零。除非在此期间再次调用此方法，否则随后的选择操作将照常阻塞。</target>
        </trans-unit>
        <trans-unit id="55a602e52f31c6fce149aff8e6c8a2bb72960c45" translate="yes" xml:space="preserve">
          <source>If another thread is currently blocked in an invocation of the &lt;a href=&quot;selector#select--&quot;&gt;&lt;code&gt;select()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;selector#select-long-&quot;&gt;&lt;code&gt;select(long)&lt;/code&gt;&lt;/a&gt; methods then that invocation will return immediately. If no selection operation is currently in progress then the next invocation of one of these methods will return immediately unless the &lt;a href=&quot;selector#selectNow--&quot;&gt;&lt;code&gt;selectNow()&lt;/code&gt;&lt;/a&gt; method is invoked in the meantime. In any case the value returned by that invocation may be non-zero. Subsequent invocations of the &lt;a href=&quot;selector#select--&quot;&gt;&lt;code&gt;select()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;selector#select-long-&quot;&gt;&lt;code&gt;select(long)&lt;/code&gt;&lt;/a&gt; methods will block as usual unless this method is invoked again in the meantime.</source>
          <target state="translated">如果在调用&lt;a href=&quot;selector#select--&quot;&gt; &lt;code&gt;select()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;selector#select-long-&quot;&gt; &lt;code&gt;select(long)&lt;/code&gt; &lt;/a&gt;方法时当前阻止了另一个线程，则该调用将立即返回。如果当前没有正在进行选择操作，则除非同时调用&lt;a href=&quot;selector#selectNow--&quot;&gt; &lt;code&gt;selectNow()&lt;/code&gt; &lt;/a&gt;方法，否则将立即返回这些方法之一的下一次调用。在任何情况下，该调用返回的值都可以为非零。&lt;a href=&quot;selector#select--&quot;&gt; &lt;code&gt;select()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;selector#select-long-&quot;&gt; &lt;code&gt;select(long)&lt;/code&gt; &lt;/a&gt;方法的后续调用将照常阻塞，除非在此期间再次调用此方法。</target>
        </trans-unit>
        <trans-unit id="24dce4584d013d177ede8c23a6bf0925338f6147" translate="yes" xml:space="preserve">
          <source>If any &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; (or instances of its derived classes) is thrown from an &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt;, the caller of the &lt;code&gt;newSchema&lt;/code&gt; method will be thrown the same &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">如果从&lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt;抛出了任何&lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt;（或其派生类的实例），则 &lt;code&gt;newSchema&lt;/code&gt; 方法的调用者将被抛出相同的&lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="91666a635abb2638c7825fa9ea881422a3247df9" translate="yes" xml:space="preserve">
          <source>If any &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; is thrown from an &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt;, the caller of the &lt;code&gt;validate&lt;/code&gt; method will be thrown the same &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">如果从&lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt;抛出任何&lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt;，则 &lt;code&gt;validate&lt;/code&gt; 方法的调用者将被抛出相同的&lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="e6031198ebfde35221603864bd5de80044d9f210" translate="yes" xml:space="preserve">
          <source>If any &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; is thrown from an &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt;, the same &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; object will be thrown toward the root of the call stack.</source>
          <target state="translated">如果从&lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt;抛出任何&lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt;，则相同的&lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt;对象将被抛出到调用堆栈的根。</target>
        </trans-unit>
        <trans-unit id="ce3583ad9e889a8cf74d60ff219db12bf7e3d646" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;Node&lt;/code&gt; is inserted somewhere it doesn't belong.</source>
          <target state="translated">如果在任何地方插入了任何 &lt;code&gt;Node&lt;/code&gt; ,则它不属于该节点。</target>
        </trans-unit>
        <trans-unit id="9cec544a5e88401b63adc132ef371ce82ab888d7" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;PropertyChangeListeners&lt;/code&gt; have been registered, the &lt;code&gt;changeSupport&lt;/code&gt; field describes them.</source>
          <target state="translated">如果已注册任何 &lt;code&gt;PropertyChangeListeners&lt;/code&gt; ，则 &lt;code&gt;changeSupport&lt;/code&gt; 字段将对其进行描述。</target>
        </trans-unit>
        <trans-unit id="6d4dcb2cdde65186e714c3856839d4722a4381c8" translate="yes" xml:space="preserve">
          <source>If any Subscriber method throws an exception, its subscription is cancelled. If a handler is supplied as a constructor argument, it is invoked before cancellation upon an exception in method &lt;a href=&quot;flow.subscriber#onNext(T)&quot;&gt;&lt;code&gt;onNext&lt;/code&gt;&lt;/a&gt;, but exceptions in methods &lt;a href=&quot;flow.subscriber#onSubscribe(java.util.concurrent.Flow.Subscription)&quot;&gt;&lt;code&gt;onSubscribe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;flow.subscriber#onError(java.lang.Throwable)&quot;&gt;&lt;code&gt;onError&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;flow.subscriber#onComplete()&quot;&gt;&lt;code&gt;onComplete&lt;/code&gt;&lt;/a&gt; are not recorded or handled before cancellation. If the supplied Executor throws &lt;a href=&quot;rejectedexecutionexception&quot;&gt;&lt;code&gt;RejectedExecutionException&lt;/code&gt;&lt;/a&gt; (or any other RuntimeException or Error) when attempting to execute a task, or a drop handler throws an exception when processing a dropped item, then the exception is rethrown. In these cases, not all subscribers will have been issued the published item. It is usually good practice to &lt;a href=&quot;#closeExceptionally(java.lang.Throwable)&quot;&gt;&lt;code&gt;closeExceptionally&lt;/code&gt;&lt;/a&gt; in these cases.</source>
          <target state="translated">如果任何订阅者方法引发异常，则取消其订阅。如果提供处理程序作为构造函数参数，则在取消&lt;a href=&quot;flow.subscriber#onNext(T)&quot;&gt; &lt;code&gt;onNext&lt;/code&gt; &lt;/a&gt;方法中的onNext方法中的异常之前将其调用，但是在取消之前不会记录或处理&lt;a href=&quot;flow.subscriber#onSubscribe(java.util.concurrent.Flow.Subscription)&quot;&gt; &lt;code&gt;onSubscribe&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;flow.subscriber#onError(java.lang.Throwable)&quot;&gt; &lt;code&gt;onError&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;flow.subscriber#onComplete()&quot;&gt; &lt;code&gt;onComplete&lt;/code&gt; &lt;/a&gt;方法中的异常。如果提供的执行程序在尝试执行任务时抛出&lt;a href=&quot;rejectedexecutionexception&quot;&gt; &lt;code&gt;RejectedExecutionException&lt;/code&gt; &lt;/a&gt;（或任何其他RuntimeException或Error），或者放置处理程序在处理放置项时抛出异常，则该异常将被重新抛出。在这些情况下，并不是所有的订阅者都可以得到发布的项目。在这种情况下，通常最好&lt;a href=&quot;#closeExceptionally(java.lang.Throwable)&quot;&gt; &lt;code&gt;closeExceptionally&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21b5ebd6273984daf6721915e81fb9ec02d87b85" translate="yes" xml:space="preserve">
          <source>If any argument is NaN, the result is NaN.</source>
          <target state="translated">如果任何参数是NaN,结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="8b8c2ef8a9bb952f18badf3b5ecafae0a465fefa" translate="yes" xml:space="preserve">
          <source>If any attributes are unsupported only because they are in conflict with other attributes then it is at the discretion of the service to select the attribute(s) to be identified as the cause of the conflict.</source>
          <target state="translated">如果任何属性仅仅因为与其他属性冲突而不被支持,那么服务将自行选择被确定为冲突原因的属性。</target>
        </trans-unit>
        <trans-unit id="4ebc8985caafe276614f95fc78ffd3e5249f1603" translate="yes" xml:space="preserve">
          <source>If any bits of a particular byte have never been set at the time the byte is flushed to the destination, those bits will be set to 0 automatically.</source>
          <target state="translated">如果一个特定字节的任何位在字节被刷新到目的地时从未被设置,这些位将被自动设置为0。</target>
        </trans-unit>
        <trans-unit id="000b0cb48e2461281a9efe32d05592010817bcfd" translate="yes" xml:space="preserve">
          <source>If any element is a NaN, then the final sum will be NaN.</source>
          <target state="translated">如果任何元素都是NaN,那么最后的总和将是NaN。</target>
        </trans-unit>
        <trans-unit id="7043446a887039defab2fc7d623983a8ed813ef6" translate="yes" xml:space="preserve">
          <source>If any execution of this task takes longer than its period, then subsequent executions may start late, but will not concurrently execute.</source>
          <target state="translated">如果该任务的任何执行时间超过其周期,那么后续的执行可能会延迟开始,但不会同时执行。</target>
        </trans-unit>
        <trans-unit id="702be5b9ebfbe3a5f1d1aa77356733e4327d5c79" translate="yes" xml:space="preserve">
          <source>If any keys were added to the cancelled-key set while step (2) was in progress then they are processed as in step (1).</source>
          <target state="translated">如果在步骤(2)进行时,有任何钥匙被添加到取消的钥匙组中,那么它们的处理与步骤(1)一样。</target>
        </trans-unit>
        <trans-unit id="39449a473dc6d7f957e4a256a3a7386489d76cfc" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;lastModifiedTime&lt;/code&gt;, &lt;code&gt;lastAccessTime&lt;/code&gt;, or &lt;code&gt;createTime&lt;/code&gt; parameters has the value &lt;code&gt;null&lt;/code&gt; then the corresponding timestamp is not changed. An implementation may require to read the existing values of the file attributes when only some, but not all, of the timestamp attributes are updated. Consequently, this method may not be an atomic operation with respect to other file system operations. Reading and re-writing existing values may also result in precision loss. If all of the &lt;code&gt;lastModifiedTime&lt;/code&gt;, &lt;code&gt;
 lastAccessTime&lt;/code&gt; and &lt;code&gt;createTime&lt;/code&gt; parameters are &lt;code&gt;null&lt;/code&gt; then this method has no effect.</source>
          <target state="translated">如果 &lt;code&gt;lastModifiedTime&lt;/code&gt; ， &lt;code&gt;lastAccessTime&lt;/code&gt; 或 &lt;code&gt;createTime&lt;/code&gt; 参数中的任何一个的值为 &lt;code&gt;null&lt;/code&gt; ,则不会更改相应的时间戳。当仅更新一些而非全部时间戳属性时，实现可能需要读取文件属性的现有值。因此，相对于其他文件系统操作，此方法可能不是原子操作。读取和重写现有值也可能导致精度损失。如果所有 &lt;code&gt;lastModifiedTime&lt;/code&gt; ， &lt;code&gt; lastAccessTime&lt;/code&gt; 和 &lt;code&gt;createTime&lt;/code&gt; 参数均为 &lt;code&gt;null&lt;/code&gt; ,则此方法无效。</target>
        </trans-unit>
        <trans-unit id="51f61f6cbbe9d425e171c7d86f0b2ee40a25ba9f" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;lastModifiedTime&lt;/code&gt;, &lt;code&gt;lastAccessTime&lt;/code&gt;, or &lt;code&gt;createTime&lt;/code&gt; parameters has the value &lt;code&gt;null&lt;/code&gt; then the corresponding timestamp is not changed. An implementation may require to read the existing values of the file attributes when only some, but not all, of the timestamp attributes are updated. Consequently, this method may not be an atomic operation with respect to other file system operations. Reading and re-writing existing values may also result in precision loss. If all of the &lt;code&gt;lastModifiedTime&lt;/code&gt;, &lt;code&gt;lastAccessTime&lt;/code&gt; and &lt;code&gt;createTime&lt;/code&gt; parameters are &lt;code&gt;null&lt;/code&gt; then this method has no effect.</source>
          <target state="translated">如果 &lt;code&gt;lastModifiedTime&lt;/code&gt; ， &lt;code&gt;lastAccessTime&lt;/code&gt; 或 &lt;code&gt;createTime&lt;/code&gt; 参数中的任何一个的值为 &lt;code&gt;null&lt;/code&gt; ,则不会更改相应的时间戳。当仅更新一些而非全部时间戳属性时，实现可能需要读取文件属性的现有值。因此，相对于其他文件系统操作，此方法可能不是原子操作。读取和重写现有值也可能导致精度损失。如果所有 &lt;code&gt;lastModifiedTime&lt;/code&gt; ， &lt;code&gt;lastAccessTime&lt;/code&gt; 和 &lt;code&gt;createTime&lt;/code&gt; 参数均为 &lt;code&gt;null&lt;/code&gt; ,则此方法无效。</target>
        </trans-unit>
        <trans-unit id="e8c0135add7c8b60bb88502e1753b104e3e7777d" translate="yes" xml:space="preserve">
          <source>If any of the CA certificates contain the &lt;code&gt;BasicConstraintsExtension&lt;/code&gt;, the value of the &lt;code&gt;pathLenConstraint&lt;/code&gt; field of the extension overrides the maximum path length parameter whenever the result is a certification path of smaller length.</source>
          <target state="translated">如果任何CA证书都包含 &lt;code&gt;BasicConstraintsExtension&lt;/code&gt; ，则扩展结果的 &lt;code&gt;pathLenConstraint&lt;/code&gt; 字段的值将覆盖最大路径长度参数，只要结果是较小长度的认证路径。</target>
        </trans-unit>
        <trans-unit id="f654f25aabeed51a280aa0d1931bee62f73651f8" translate="yes" xml:space="preserve">
          <source>If any of the above checks is not met, this method throws an &lt;code&gt;IllegalAccessException&lt;/code&gt;.</source>
          <target state="translated">如果不满足上述任何一项检查，则此方法将抛出 &lt;code&gt;IllegalAccessException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe6e3fb63dc7863f33b7b6e2532bfa71a11dd503" translate="yes" xml:space="preserve">
          <source>If any of the above checks is violated, this method fails with an exception.</source>
          <target state="translated">如果违反了上述任何一项检查,本方法就会因异常而失败。</target>
        </trans-unit>
        <trans-unit id="2322580274e59c704b7ceb052b845f94fd2c310a" translate="yes" xml:space="preserve">
          <source>If any of the argument keys are not recognized and are not namespace qualified, the property will be ignored and not returned. In other words the behaviour is not orthogonal with &lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt;&lt;code&gt;setOutputProperties&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果任何参数键均未被识别并且没有名称空间限定，则该属性将被忽略并且不返回。换句话说，该行为与&lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt; &lt;code&gt;setOutputProperties&lt;/code&gt; &lt;/a&gt;不正交。</target>
        </trans-unit>
        <trans-unit id="782a50f5eb20d11713521429c1b0847fdaaf876b" translate="yes" xml:space="preserve">
          <source>If any of the following conditions occur in the readability graph, then resolution fails:</source>
          <target state="translated">如果可读性图中出现以下任何一种情况,则解析失败。</target>
        </trans-unit>
        <trans-unit id="8a96b6f648f1a586b2a9b7cb064808b149ba531a" translate="yes" xml:space="preserve">
          <source>If any of the following conditions occur, then resolution fails:</source>
          <target state="translated">如果出现以下任何一种情况,则解决失败。</target>
        </trans-unit>
        <trans-unit id="7e865b4e10f0873b268aaea1e6ba64ad4ef091c4" translate="yes" xml:space="preserve">
          <source>If any of the parameter types or return type cannot be described nominally, i.e. &lt;a href=&quot;../class#describeConstable()&quot;&gt;&lt;code&gt;Class::describeConstable&lt;/code&gt;&lt;/a&gt; returns an empty optional for that type, then the method type cannot be described nominally:</source>
          <target state="translated">如果不能名义上描述任何参数类型或返回类型，即&lt;a href=&quot;../class#describeConstable()&quot;&gt; &lt;code&gt;Class::describeConstable&lt;/code&gt; &lt;/a&gt;返回该类型的空可选内容，则不能名义上描述方法类型：</target>
        </trans-unit>
        <trans-unit id="3ec333633e17c9be083cec2c06b962a41326b457" translate="yes" xml:space="preserve">
          <source>If any of the supplied &lt;code&gt;ImageReadParam&lt;/code&gt;s contain optional setting values not supported by this reader (</source>
          <target state="translated">如果提供的 &lt;code&gt;ImageReadParam&lt;/code&gt; 中的任何一个包含此阅读器不支持的可选设置值（</target>
        </trans-unit>
        <trans-unit id="76839c59491d34773c4207ef0c1d778a11ef3546" translate="yes" xml:space="preserve">
          <source>If any of these conversions proves impossible, fail with either a &lt;code&gt;ClassCastException&lt;/code&gt; if any trailing element cannot be cast to &lt;code&gt;A&lt;/code&gt; or a &lt;code&gt;NullPointerException&lt;/code&gt; if any trailing element is &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is not a reference type.</source>
          <target state="translated">如果任何这些转换的证明是不可能的，会失败，无论是 &lt;code&gt;ClassCastException&lt;/code&gt; 异常如果任何尾随元件不能被转换为 &lt;code&gt;A&lt;/code&gt; 或一个 &lt;code&gt;NullPointerException&lt;/code&gt; 如果任何尾随元件是 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 不是引用类型。</target>
        </trans-unit>
        <trans-unit id="21a8f6cbf8da0180ca327e40df0d37c1951e9068" translate="yes" xml:space="preserve">
          <source>If any of these restrictions are violated, &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt;. If the &lt;code&gt;interfaces&lt;/code&gt; array argument or any of its elements are &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果违反任何这些限制，则 &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; 将抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。如果 &lt;code&gt;interfaces&lt;/code&gt; 数组参数或其任何元素为 &lt;code&gt;null&lt;/code&gt; ，则将引发 &lt;code&gt;NullPointerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff3b12e4e909401d37518b8a3b2f0f268050f07d" translate="yes" xml:space="preserve">
          <source>If any one of the given (name, filter) pairs cannot be registered, then the operation fails with an exception, and no names or filters are registered.</source>
          <target state="translated">如果任何一个给定的(名称、过滤器)对不能被注册,那么这个操作就会以异常的方式失败,并且没有注册任何名称或过滤器。</target>
        </trans-unit>
        <trans-unit id="aeed51a14c6f63342415cdd77d994dcbb7bd2135" translate="yes" xml:space="preserve">
          <source>If any recorded value is a NaN, then the final sum will be NaN.</source>
          <target state="translated">如果任何记录值是NaN,那么最后的总和将是NaN。</target>
        </trans-unit>
        <trans-unit id="c41f89efd65d6831c5b78321674605fbf8e57d9a" translate="yes" xml:space="preserve">
          <source>If any stream element is a NaN or the sum is at any point a NaN then the sum will be NaN. The value of a floating-point sum is a function both of the input values as well as the order of addition operations. The order of addition operations of this method is intentionally not defined to allow for implementation flexibility to improve the speed and accuracy of the computed result. In particular, this method may be implemented using compensated summation or other technique to reduce the error bound in the numerical sum compared to a simple summation of &lt;code&gt;double&lt;/code&gt; values.</source>
          <target state="translated">如果任何流元素是NaN或总和在任何时候都是NaN，则总和将是NaN。浮点和的值是输入值以及加法运算顺序的函数。故意不定义此方法的加法运算顺序，以允许实现灵活性以提高计算结果的速度和准确性。特别地，与 &lt;code&gt;double&lt;/code&gt; 值的简单求和相比，可以使用补偿求和或其他技术来实现该方法，以减少数值和中的误差范围。</target>
        </trans-unit>
        <trans-unit id="d6e5c13d5caa4d3b73ae2556eecfd7419724c86e" translate="yes" xml:space="preserve">
          <source>If any thread is &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; while waiting, then all other waiting threads will throw &lt;a href=&quot;brokenbarrierexception&quot;&gt;&lt;code&gt;BrokenBarrierException&lt;/code&gt;&lt;/a&gt; and the barrier is placed in the broken state.</source>
          <target state="translated">如果有任何线程在等待时被&lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;中断&lt;/a&gt;，则所有其他等待线程将抛出&lt;a href=&quot;brokenbarrierexception&quot;&gt; &lt;code&gt;BrokenBarrierException&lt;/code&gt; &lt;/a&gt;，并且屏障处于断开状态。</target>
        </trans-unit>
        <trans-unit id="0366cecb1a7ed3c3842ffb9c2ca86a1363dd9a67" translate="yes" xml:space="preserve">
          <source>If any thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting, then all other waiting threads will throw &lt;a href=&quot;brokenbarrierexception&quot;&gt;&lt;code&gt;BrokenBarrierException&lt;/code&gt;&lt;/a&gt; and the barrier is placed in the broken state.</source>
          <target state="translated">如果任何线程在等待时被&lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;中断&lt;/a&gt;，则所有其他等待线程将抛出&lt;a href=&quot;brokenbarrierexception&quot;&gt; &lt;code&gt;BrokenBarrierException&lt;/code&gt; &lt;/a&gt;，并且屏障处于断开状态。</target>
        </trans-unit>
        <trans-unit id="4afdb9645427c72b2b449dab0d6dc64d70f5f7ed" translate="yes" xml:space="preserve">
          <source>If any threads are waiting on this condition then one is selected for waking up. That thread must then re-acquire the lock before returning from &lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">如果有任何线程在这种情况下等待，则选择一个线程进行唤醒。然后，该线程必须在从 &lt;code&gt;await&lt;/code&gt; 返回之前重新获取锁。</target>
        </trans-unit>
        <trans-unit id="9c78a7fa649adbc90dbb23129fc74d5e1c06006a" translate="yes" xml:space="preserve">
          <source>If any threads are waiting on this condition then they are all woken up. Each thread must re-acquire the lock before it can return from &lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">如果有任何线程在这种情况下等待，那么它们都将被唤醒。每个线程必须重新获取锁，然后才能从 &lt;code&gt;await&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="6def6409810618378abfde7ccc3db7a4a9969cbb" translate="yes" xml:space="preserve">
          <source>If any updates or modifications have been applied to the JoinRowSet the CachedRowSet returned by the method will not be able to persist it's changes back to the originating rows and tables in the in the datasource. The CachedRowSet instance returned should not contain modification data and it should clear all properties of it's originating SQL statement. An application should reset the SQL statement using the &lt;code&gt;RowSet.setCommand&lt;/code&gt; method.</source>
          <target state="translated">如果对JoinRowSet进行了任何更新或修改，则该方法返回的CachedRowSet将无法持久保存，将其更改返回到数据源中的原始行和表。返回的CachedRowSet实例不应包含修改数据，并且应清除其原始SQL语句的所有属性。应用程序应使用 &lt;code&gt;RowSet.setCommand&lt;/code&gt; 方法重置SQL语句。</target>
        </trans-unit>
        <trans-unit id="3ad420704ce0b8b6310a781cf438247c5b08c1d6" translate="yes" xml:space="preserve">
          <source>If application-layer protocols are supported by the underlying SSL/TLS implementation, this method configures which values can be negotiated by protocols such as &lt;a href=&quot;http://www.ietf.org/rfc/rfc7301.txt&quot;&gt; RFC 7301 &lt;/a&gt;, the Application Layer Protocol Negotiation (ALPN).</source>
          <target state="translated">如果基础SSL / TLS实现支持应用程序层协议，则此方法配置可以由诸如&lt;a href=&quot;http://www.ietf.org/rfc/rfc7301.txt&quot;&gt;RFC 7301&lt;/a&gt;（应用程序层协议协商（ALPN））之类的协议协商哪些值。</target>
        </trans-unit>
        <trans-unit id="3322bc5f2673498ec497fcaeb0d9efa220e8632f" translate="yes" xml:space="preserve">
          <source>If application-layer protocols are supported by the underlying SSL/TLS implementation, this method configures which values can be negotiated by protocols such as &lt;a href=&quot;https://www.ietf.org/rfc/rfc7301.txt&quot;&gt; RFC 7301 &lt;/a&gt;, the Application Layer Protocol Negotiation (ALPN).</source>
          <target state="translated">如果基础SSL / TLS实现支持应用程序层协议，则此方法配置可以由诸如&lt;a href=&quot;https://www.ietf.org/rfc/rfc7301.txt&quot;&gt;RFC 7301&lt;/a&gt;（应用程序层协议协商（ALPN））之类的协议协商哪些值。</target>
        </trans-unit>
        <trans-unit id="f0d6dca8e18fd60ae506385307a9dc90b88e0396" translate="yes" xml:space="preserve">
          <source>If arbitrary parameter type conversions are required, the method &lt;code&gt;setObject&lt;/code&gt; should be used with a target SQL type.</source>
          <target state="translated">如果需要任意参数类型转换，则应将 &lt;code&gt;setObject&lt;/code&gt; 方法与目标SQL类型一起使用。</target>
        </trans-unit>
        <trans-unit id="cc5b8f67def8251eae02d8e53ae706abfba5145a" translate="yes" xml:space="preserve">
          <source>If argument to this function is null, any properties previously set are removed, and the value will revert to the value defined in the templates object.</source>
          <target state="translated">如果该函数的参数为空,则之前设置的任何属性都将被删除,并且该值将恢复到模板对象中定义的值。</target>
        </trans-unit>
        <trans-unit id="b5244f53177f68a2b3ed5e4985bb324825bd1a66" translate="yes" xml:space="preserve">
          <source>If assistive technology service providers are not specified with a system property this implementation will look in a properties file located as follows:</source>
          <target state="translated">如果没有用系统属性指定辅助技术服务提供者,本实施例将在位于如下的属性文件中查找。</target>
        </trans-unit>
        <trans-unit id="18a3bd0c38bccf34c6827e5596cec04cb57b5219" translate="yes" xml:space="preserve">
          <source>If at least one automatic module is enumerated by this algorithm, then every observable automatic module must be enumerated, regardless of whether any of their names are given by 'requires' directives of explicit module declarations.</source>
          <target state="translated">如果至少有一个自动模块被这个算法列举出来,那么每一个可观察的自动模块都必须被列举出来,不管它们的名字是否由显式模块声明的'request'指令给出。</target>
        </trans-unit>
        <trans-unit id="39bc70b09921ff4ffa0b8bd08071b807a4a817ff" translate="yes" xml:space="preserve">
          <source>If at least one proxy interface is in a package that is &lt;em&gt;non-exported&lt;/em&gt; and &lt;em&gt;non-open&lt;/em&gt;:</source>
          <target state="translated">如果&lt;em&gt;非导出&lt;/em&gt;和&lt;em&gt;非开放式&lt;/em&gt;软件包中至少有一个代理接口，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="2b0406f18bc56c48dc76b9e9165ced413b0430b2" translate="yes" xml:space="preserve">
          <source>If attachToInputContext is true, the new window will share the input context that corresponds to this input method context, so that events for components in the window are automatically dispatched to the input method. Also, when the window is opened using setVisible(true), the input context will prevent deactivate and activate calls to the input method that might otherwise be caused.</source>
          <target state="translated">如果 attachToInputContext 为真,新窗口将共享与该输入法上下文相对应的输入上下文,这样窗口中的组件的事件就会自动派发到输入法。另外,当使用setVisible(true)打开窗口时,输入上下文将防止对输入法的停用和激活调用,否则可能会引起。</target>
        </trans-unit>
        <trans-unit id="47fbfc22f0224fd32a90e5910c55321028c1907f" translate="yes" xml:space="preserve">
          <source>If attribute already exists, replaces all existing values with new specified values. If the attribute does not exist, creates it. If no value is specified, deletes all the values of the attribute. Removal of the last value will remove the attribute if the attribute is required to have at least one value. If attempting to add more than one value to a single-valued attribute, throws &lt;code&gt;InvalidAttributeValueException&lt;/code&gt;.</source>
          <target state="translated">如果属性已经存在，请使用新的指定值替换所有现有值。如果属性不存在，请创建它。如果未指定任何值，则删除该属性的所有值。如果要求属性至少具有一个值，则删除最后一个值将删除该属性。如果尝试向单值属性添加多个值，则抛出 &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a71ec53a572d41f56b8978727aaa4319a3583553" translate="yes" xml:space="preserve">
          <source>If attribute does not exist, create the attribute. The resulting attribute has a union of the specified value set and the prior value set. Adding an attribute with no value will throw &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; if the attribute must have at least one value. For a single-valued attribute where that attribute already exists, throws &lt;code&gt;AttributeInUseException&lt;/code&gt;. If attempting to add more than one value to a single-valued attribute, throws &lt;code&gt;InvalidAttributeValueException&lt;/code&gt;.</source>
          <target state="translated">如果属性不存在，请创建属性。结果属性具有指定值集和先前值集的并集。如果该属性必须至少具有一个值，则添加没有值的属性将引发 &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; 。对于已经存在该属性的单值属性，抛出 &lt;code&gt;AttributeInUseException&lt;/code&gt; 。如果尝试向单值属性添加多个值，则抛出 &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3d3f8aee9c476b735dd96255aa064b6dd2f681b" translate="yes" xml:space="preserve">
          <source>If authentication is successful then an authenticated &lt;a href=&quot;../../../../java.base/javax/security/auth/subject&quot;&gt;&lt;code&gt;subject&lt;/code&gt;&lt;/a&gt; filled in with its associated &lt;a href=&quot;../../../../java.base/java/security/principal&quot;&gt;&lt;code&gt;principals&lt;/code&gt;&lt;/a&gt; is returned. Authorization checks will be then performed based on the given set of principals.</source>
          <target state="translated">如果身份验证成功，则返回一个已填充其相关&lt;a href=&quot;../../../../java.base/java/security/principal&quot;&gt; &lt;code&gt;principals&lt;/code&gt; &lt;/a&gt;已身份验证&lt;a href=&quot;../../../../java.base/javax/security/auth/subject&quot;&gt; &lt;code&gt;subject&lt;/code&gt; &lt;/a&gt;。然后将基于给定的主体集执行授权检查。</target>
        </trans-unit>
        <trans-unit id="3989b3dfcf79c0772b368fc99263d6921c534321" translate="yes" xml:space="preserve">
          <source>If authentication is successful then an authenticated &lt;a href=&quot;../../security/auth/subject&quot;&gt;&lt;code&gt;subject&lt;/code&gt;&lt;/a&gt; filled in with its associated &lt;a href=&quot;../../../java/security/principal&quot;&gt;&lt;code&gt;principals&lt;/code&gt;&lt;/a&gt; is returned. Authorization checks will be then performed based on the given set of principals.</source>
          <target state="translated">如果身份验证成功，则返回一个已填充其相关&lt;a href=&quot;../../../java/security/principal&quot;&gt; &lt;code&gt;principals&lt;/code&gt; &lt;/a&gt;已身份验证&lt;a href=&quot;../../security/auth/subject&quot;&gt; &lt;code&gt;subject&lt;/code&gt; &lt;/a&gt;。然后将基于给定的主体集执行授权检查。</target>
        </trans-unit>
        <trans-unit id="656e2a66175d25267b8bfdd6e344b28552a242bb" translate="yes" xml:space="preserve">
          <source>If auto-size is &lt;code&gt;false&lt;/code&gt;, and the image size doesn't match the tray icon space, the image is painted as-is inside that space &amp;mdash; if larger than the allocated space, it will be cropped.</source>
          <target state="translated">如果auto-size为 &lt;code&gt;false&lt;/code&gt; ，并且图像尺寸与进纸匣图标空间不匹配，则会在该空间内原样绘制图像-如果大于分配的空间，则将对其进行裁剪。</target>
        </trans-unit>
        <trans-unit id="291b41936e512575859370f076451751c340db33" translate="yes" xml:space="preserve">
          <source>If auto-size is &lt;code&gt;true&lt;/code&gt;, the image is stretched or shrunk to fit the tray icon space.</source>
          <target state="translated">如果auto-size为 &lt;code&gt;true&lt;/code&gt; ，则将图像拉伸或缩小以适合进纸匣图标的空间。</target>
        </trans-unit>
        <trans-unit id="384a750120cc655c818a55ff4a92437e6d8b5336" translate="yes" xml:space="preserve">
          <source>If automatic redirection is enabled, and this request is redirected to another destination, then the caller must also have permission to connect to the redirected host/URL.</source>
          <target state="translated">如果启用了自动重定向,并且这个请求被重定向到另一个目的地,那么呼叫者也必须有权限连接到重定向的主机/URL。</target>
        </trans-unit>
        <trans-unit id="e1a72e75cda6642170c4e7a072c7c777581c7f64" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Path&lt;/code&gt; objects are &lt;a href=&quot;path#equals(java.lang.Object)&quot;&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/a&gt; then this method returns &lt;code&gt;true&lt;/code&gt; without checking if the file exists. If the two &lt;code&gt;Path&lt;/code&gt; objects are associated with different providers then this method returns &lt;code&gt;false&lt;/code&gt;. Otherwise, this method checks if both &lt;code&gt;Path&lt;/code&gt; objects locate the same file, and depending on the implementation, may require to open or access both files.</source>
          <target state="translated">如果两个 &lt;code&gt;Path&lt;/code&gt; 对象&lt;a href=&quot;path#equals(java.lang.Object)&quot;&gt; &lt;code&gt;equal&lt;/code&gt; &lt;/a&gt;则此方法返回 &lt;code&gt;true&lt;/code&gt; ,而不检查文件是否存在。如果两个 &lt;code&gt;Path&lt;/code&gt; 对象与不同的提供程序关联，则此方法返回 &lt;code&gt;false&lt;/code&gt; 。否则，此方法将检查两个 &lt;code&gt;Path&lt;/code&gt; 对象是否都找到同一文件，并且取决于实现方式，可能需要打开或访问这两个文件。</target>
        </trans-unit>
        <trans-unit id="214c67c3b5c1b48a5612e6002691988064bf0ec4" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Path&lt;/code&gt; objects are &lt;a href=&quot;path#equals-java.lang.Object-&quot;&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/a&gt; then this method returns &lt;code&gt;true&lt;/code&gt; without checking if the file exists. If the two &lt;code&gt;Path&lt;/code&gt; objects are associated with different providers then this method returns &lt;code&gt;false&lt;/code&gt;. Otherwise, this method checks if both &lt;code&gt;Path&lt;/code&gt; objects locate the same file, and depending on the implementation, may require to open or access both files.</source>
          <target state="translated">如果两个 &lt;code&gt;Path&lt;/code&gt; 对象&lt;a href=&quot;path#equals-java.lang.Object-&quot;&gt; &lt;code&gt;equal&lt;/code&gt; &lt;/a&gt;则此方法返回 &lt;code&gt;true&lt;/code&gt; ,而不检查文件是否存在。如果两个 &lt;code&gt;Path&lt;/code&gt; 对象与不同的提供程序关联，则此方法返回 &lt;code&gt;false&lt;/code&gt; 。否则，此方法将检查两个 &lt;code&gt;Path&lt;/code&gt; 对象是否都找到同一文件，并且取决于实现方式，可能需要打开或访问这两个文件。</target>
        </trans-unit>
        <trans-unit id="df4547af366065ff735c348a2ae9741324e8b7ac" translate="yes" xml:space="preserve">
          <source>If both arguments are integers, then the result is exactly equal to the mathematical result of raising the first argument to the power of the second argument if that result can in fact be represented exactly as a &lt;code&gt;double&lt;/code&gt; value.</source>
          <target state="translated">如果两个参数都是整数，则结果实际上等于将第一个参数提高为第二个参数的幂的数学结果，如果该结果实际上可以精确地表示为 &lt;code&gt;double&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="9e16fe4a0bb9164db40801221f5bd4724181b86e" translate="yes" xml:space="preserve">
          <source>If both arguments are negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -3*</source>
          <target state="translated">如果两个参数均为负无穷大，则结果为最接近-3 * 的 &lt;code&gt;double&lt;/code&gt; 值</target>
        </trans-unit>
        <trans-unit id="bfd7882093d9bf21c1a62a7634c6a186d1b60176" translate="yes" xml:space="preserve">
          <source>If both arguments are positive infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to</source>
          <target state="translated">如果两个参数都是正无穷大，那么结果是 &lt;code&gt;double&lt;/code&gt; 最接近值</target>
        </trans-unit>
        <trans-unit id="fc50ec0abca10e371c02173b94982f3dab4ec295" translate="yes" xml:space="preserve">
          <source>If both arguments are signed zeros, &lt;code&gt;direction&lt;/code&gt; is returned unchanged (as implied by the requirement of returning the second argument if the arguments compare as equal).</source>
          <target state="translated">如果两个参数的符号都为零，则返回的 &lt;code&gt;direction&lt;/code&gt; 不变（这意味着如果参数比较相等，则返回第二个参数的要求）。</target>
        </trans-unit>
        <trans-unit id="1ae942765abc7210f5202cbe952dc04cbb521ee9" translate="yes" xml:space="preserve">
          <source>If both arguments are signed zeros, a value equivalent to &lt;code&gt;direction&lt;/code&gt; is returned.</source>
          <target state="translated">如果两个参数的符号都为零，则返回等于 &lt;code&gt;direction&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="70f5cab03df99b6ce504b587920dfb5e98d8aa1e" translate="yes" xml:space="preserve">
          <source>If both authority components are server-based then the URIs are ordered according to their user-information components; if these components are identical then the URIs are ordered according to the ordering of their hosts, without regard to case; if the hosts are identical then the URIs are ordered according to the ordering of their ports.</source>
          <target state="translated">如果两个权限组件都是基于服务器的,那么URI就按照它们的用户信息组件排序;如果这些组件相同,那么URI就按照它们的主机排序,不考虑大小写;如果主机相同,那么URI就按照它们的端口排序。</target>
        </trans-unit>
        <trans-unit id="6f5d44c367ff5b5081fe504e77935fe0c93a1c15" translate="yes" xml:space="preserve">
          <source>If both date and time were parsed and either an offset or zone is present, the field &lt;a href=&quot;../temporal/chronofield#INSTANT_SECONDS&quot;&gt;&lt;code&gt;ChronoField.INSTANT_SECONDS&lt;/code&gt;&lt;/a&gt; is created. If an offset was parsed then the offset will be combined with the &lt;code&gt;LocalDateTime&lt;/code&gt; to form the instant, with any zone ignored. If a &lt;code&gt;ZoneId&lt;/code&gt; was parsed without an offset then the zone will be combined with the &lt;code&gt;LocalDateTime&lt;/code&gt; to form the instant using the rules of &lt;a href=&quot;../chrono/chronolocaldatetime#atZone(java.time.ZoneId)&quot;&gt;&lt;code&gt;ChronoLocalDateTime.atZone(ZoneId)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果同时分析了日期和时间，并且存在偏移量或区域，&lt;a href=&quot;../temporal/chronofield#INSTANT_SECONDS&quot;&gt; &lt;code&gt;ChronoField.INSTANT_SECONDS&lt;/code&gt; &lt;/a&gt;创建字段ChronoField.INSTANT_SECONDS。如果解析了偏移量，则该偏移量将与 &lt;code&gt;LocalDateTime&lt;/code&gt; 组合以形成即时区域，而忽略任何区域。如果在没有偏移的情况下解析 &lt;code&gt;ZoneId&lt;/code&gt; ，则将使用&lt;a href=&quot;../chrono/chronolocaldatetime#atZone(java.time.ZoneId)&quot;&gt; &lt;code&gt;ChronoLocalDateTime.atZone(ZoneId)&lt;/code&gt; &lt;/a&gt;的规则将区域与 &lt;code&gt;LocalDateTime&lt;/code&gt; 组合在一起以形成瞬间。</target>
        </trans-unit>
        <trans-unit id="5a0b7a5fda83b5b4e68fb0e1c58f9d3e3a0f17bf" translate="yes" xml:space="preserve">
          <source>If both functions are omitted, there is no iteration variable for the corresponding clause (&lt;code&gt;void&lt;/code&gt; is used as the type to indicate that). If one of them is omitted, the other's return type defines the clause's iteration variable type. If both are given, the common return type (they must be identical) defines the clause's iteration variable type.</source>
          <target state="translated">如果两个函数都被省略，则对应子句没有迭代变量（ &lt;code&gt;void&lt;/code&gt; 被用作指示该类型的类型）。如果忽略其中一个，则另一个的返回类型定义子句的迭代变量类型。如果两者都给出，则公共返回类型（它们必须相同）定义了子句的迭代变量类型。</target>
        </trans-unit>
        <trans-unit id="35daff90f12a3fdfb2ee7aaec5156a628122493a" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;' '&lt;/code&gt; flags are given then an &lt;a href=&quot;illegalformatflagsexception&quot;&gt;&lt;code&gt;IllegalFormatFlagsException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果同时给出了 &lt;code&gt;'+'&lt;/code&gt; 和 &lt;code&gt;' '&lt;/code&gt; 标志，则将抛出&lt;a href=&quot;illegalformatflagsexception&quot;&gt; &lt;code&gt;IllegalFormatFlagsException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="77fe9618329cbe1c02136a891b425c89e9010bfc" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;'&amp;nbsp;&amp;nbsp;'&lt;/code&gt; flags are given then an &lt;a href=&quot;illegalformatflagsexception&quot;&gt;&lt;code&gt;IllegalFormatFlagsException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果同时给出了 &lt;code&gt;'+'&lt;/code&gt; 和 &lt;code&gt;'&amp;nbsp;&amp;nbsp;'&lt;/code&gt; 标志，则将抛出&lt;a href=&quot;illegalformatflagsexception&quot;&gt; &lt;code&gt;IllegalFormatFlagsException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86fead13194ade589a2825bc28cba12789046f04" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;'-'&lt;/code&gt; and &lt;code&gt;'0'&lt;/code&gt; flags are given then an &lt;a href=&quot;illegalformatflagsexception&quot;&gt;&lt;code&gt;IllegalFormatFlagsException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果同时给出了 &lt;code&gt;'-'&lt;/code&gt; 和 &lt;code&gt;'0'&lt;/code&gt; 标志，则将抛出&lt;a href=&quot;illegalformatflagsexception&quot;&gt; &lt;code&gt;IllegalFormatFlagsException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="37322522f6007d5f007c17ebbe89695f06d7d158" translate="yes" xml:space="preserve">
          <source>If both the PrincipalClass and &quot;PrincipalName&quot; are &quot;*&quot;, then access is granted to the specified Credential owned by any &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">如果PrincipalClass和&amp;ldquo; PrincipalName&amp;rdquo;均为&amp;ldquo; *&amp;rdquo;，则将授予对任何 &lt;code&gt;Subject&lt;/code&gt; 所拥有的指定凭据的访问权限。</target>
        </trans-unit>
        <trans-unit id="905c92d5f8cc252cd790d5c0e9c59aa390231cea" translate="yes" xml:space="preserve">
          <source>If both the icon and text properties are set, this property defines the space between them.</source>
          <target state="translated">如果同时设置了图标和文本属性,则此属性定义了它们之间的空间。</target>
        </trans-unit>
        <trans-unit id="7f1f59b1990a9778560b4bab37a8896d7e2ca6a4" translate="yes" xml:space="preserve">
          <source>If both the language and country fields are missing, this function will return the empty string, even if the variant, script, or extensions field is present (you can't have a locale with just a variant, the variant must accompany a well-formed language or country code).</source>
          <target state="translated">如果语言和国家字段都缺失,这个函数将返回空字符串,即使变体、脚本或扩展字段存在(你不能只用一个变体就有一个locale,变体必须伴随着一个完善的语言或国家代码)。</target>
        </trans-unit>
        <trans-unit id="198c8792365f76a0effc383dff9d0f2e3f4c671c" translate="yes" xml:space="preserve">
          <source>If button 1 is pressed, this is implemented to request focus on the associated text component, and to set the caret position.</source>
          <target state="translated">如果按钮1被按下,就会实现要求将焦点放在相关的文本组件上,并设置小圆点位置。</target>
        </trans-unit>
        <trans-unit id="7f1c5cd838d41d438b8c0b687719a88a74c90d50" translate="yes" xml:space="preserve">
          <source>If button 1 is pressed, this is implemented to request focus on the associated text component, and to set the caret position. If the shift key is held down, the caret will be moved, potentially resulting in a selection, otherwise the caret position will be set to the new location. If the component is not enabled, there will be no request for focus.</source>
          <target state="translated">如果按钮1被按下,则会要求将焦点放在相关的文本组件上,并设置插字位置。如果按住shift键,那么插字将被移动,有可能导致选择,否则插字位置将被设置到新的位置。如果该组件未启用,则不会有聚焦请求。</target>
        </trans-unit>
        <trans-unit id="f923d1532c20f84a25813e955834f5127ccc56bb" translate="yes" xml:space="preserve">
          <source>If c is a JRootPane descendant return its JRootPane ancestor.</source>
          <target state="translated">如果c是JRootPane的后裔,返回它的JRootPane祖先。</target>
        </trans-unit>
        <trans-unit id="d4941c81aaff08fa305d979d6a292103fdf2015a" translate="yes" xml:space="preserve">
          <source>If c is a JRootPane descendant return its JRootPane ancestor. If c is a RootPaneContainer then return its JRootPane.</source>
          <target state="translated">如果c是JRootPane的后裔,则返回它的JRootPane祖先。如果c是一个RootPaneContainer,那么返回它的JRootPane。</target>
        </trans-unit>
        <trans-unit id="297ea4154bf357de478f2a9da3045f4e48159d4d" translate="yes" xml:space="preserve">
          <source>If called by a ForkJoinTask operating in this pool, equivalent in effect to &lt;a href=&quot;forkjointask#helpQuiesce()&quot;&gt;&lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果由在此池中运行的ForkJoinTask调用，则等效于&lt;a href=&quot;forkjointask#helpQuiesce()&quot;&gt; &lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3383616e30ed133f8b457a9e998c8762f65d5b51" translate="yes" xml:space="preserve">
          <source>If called by a ForkJoinTask operating in this pool, equivalent in effect to &lt;a href=&quot;forkjointask#helpQuiesce()&quot;&gt;&lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt;&lt;/a&gt;. Otherwise, waits and/or attempts to assist performing tasks until this pool &lt;a href=&quot;#isQuiescent()&quot;&gt;&lt;code&gt;isQuiescent()&lt;/code&gt;&lt;/a&gt; or the indicated timeout elapses.</source>
          <target state="translated">如果由在此池中运行的ForkJoinTask调用，则等效于&lt;a href=&quot;forkjointask#helpQuiesce()&quot;&gt; &lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt; &lt;/a&gt;。否则，请等待和/或尝试协助执行任务，直到此池为&lt;a href=&quot;#isQuiescent()&quot;&gt; &lt;code&gt;isQuiescent()&lt;/code&gt; &lt;/a&gt;或指示的超时时间过去。</target>
        </trans-unit>
        <trans-unit id="f17a471a0efa20dccdfd9df73789528ef03ee4cd" translate="yes" xml:space="preserve">
          <source>If called by a ForkJoinTask operating in this pool, equivalent in effect to &lt;a href=&quot;forkjointask#helpQuiesce--&quot;&gt;&lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt;&lt;/a&gt;. Otherwise, waits and/or attempts to assist performing tasks until this pool &lt;a href=&quot;forkjoinpool#isQuiescent--&quot;&gt;&lt;code&gt;isQuiescent()&lt;/code&gt;&lt;/a&gt; or the indicated timeout elapses.</source>
          <target state="translated">如果由在此池中运行的ForkJoinTask调用，则等效于&lt;a href=&quot;forkjointask#helpQuiesce--&quot;&gt; &lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt; &lt;/a&gt;。否则，等待和/或尝试协助执行任务，直到此池为&lt;a href=&quot;forkjoinpool#isQuiescent--&quot;&gt; &lt;code&gt;isQuiescent()&lt;/code&gt; &lt;/a&gt;或指示的超时时间过去。</target>
        </trans-unit>
        <trans-unit id="5c8be13a39c3ce6b65d510654f24b14ebdee6bb3" translate="yes" xml:space="preserve">
          <source>If called on a connection that sets the same header multiple times with possibly different values, only the last value is returned.</source>
          <target state="translated">如果在一个连接上多次调用同一个头,并且可能有不同的值,那么只返回最后一个值。</target>
        </trans-unit>
        <trans-unit id="c482125ee1539de1724656d21516fd3060b7e464" translate="yes" xml:space="preserve">
          <source>If cipher suites have been set via &lt;code&gt;setEnabledCipherSuites&lt;/code&gt; then they are enabled before the TLS handshake begins.</source>
          <target state="translated">如果已通过 &lt;code&gt;setEnabledCipherSuites&lt;/code&gt; 设置了密码套件，则在TLS握手开始之前将其启用。</target>
        </trans-unit>
        <trans-unit id="0722074a59b34b3ba484f8bc879b29bc05ad8807" translate="yes" xml:space="preserve">
          <source>If client code has explicitly set the focusability of a Component by either overriding &lt;code&gt;Component.isFocusTraversable()&lt;/code&gt; or &lt;code&gt;Component.isFocusable()&lt;/code&gt;, or by calling &lt;code&gt;Component.setFocusable()&lt;/code&gt;, then a DefaultFocusTraversalPolicy behaves exactly like a ContainerOrderFocusTraversalPolicy. If, however, the Component is relying on default focusability, then a DefaultFocusTraversalPolicy will reject all Components with non-focusable peers. This is the default FocusTraversalPolicy for all AWT Containers.</source>
          <target state="translated">如果客户端代码通过重写 &lt;code&gt;Component.isFocusTraversable()&lt;/code&gt; 或 &lt;code&gt;Component.isFocusable()&lt;/code&gt; 或调用 &lt;code&gt;Component.setFocusable()&lt;/code&gt; 显式设置了组件的可聚焦性，则DefaultFocusTraversalPolicy的行为与ContainerOrderFocusTraversalPolicy完全相同。但是，如果Component依赖于默认的可聚焦性，则DefaultFocusTraversalPolicy将拒绝所有具有不可聚焦对等项的组件。这是所有AWT容器的默认FocusTraversalPolicy。</target>
        </trans-unit>
        <trans-unit id="6e53a4db1482395c02ce01ebbf19081343f35a43" translate="yes" xml:space="preserve">
          <source>If closing a client connection produces an exception, that exception is not thrown from this method. A &lt;a href=&quot;../../../../../java.management/javax/management/remote/jmxconnectionnotification&quot;&gt;&lt;code&gt;JMXConnectionNotification&lt;/code&gt;&lt;/a&gt; is emitted from this MBean with the connection ID of the connection that could not be closed.</source>
          <target state="translated">如果关闭客户端连接会产生异常，则不会从此方法引发该异常。甲&lt;a href=&quot;../../../../../java.management/javax/management/remote/jmxconnectionnotification&quot;&gt; &lt;code&gt;JMXConnectionNotification&lt;/code&gt; 中&lt;/a&gt;从该MBean发出与该不能被关闭的连接的连接ID。</target>
        </trans-unit>
        <trans-unit id="aa5def33651e6193aa37639feee2e1bacd4151be" translate="yes" xml:space="preserve">
          <source>If closing a client connection produces an exception, that exception is not thrown from this method. A &lt;a href=&quot;../jmxconnectionnotification&quot;&gt;&lt;code&gt;JMXConnectionNotification&lt;/code&gt;&lt;/a&gt; is emitted from this MBean with the connection ID of the connection that could not be closed.</source>
          <target state="translated">如果关闭客户端连接会产生异常，则不会从此方法引发该异常。甲&lt;a href=&quot;../jmxconnectionnotification&quot;&gt; &lt;code&gt;JMXConnectionNotification&lt;/code&gt; 中&lt;/a&gt;从该MBean发出与该不能被关闭的连接的连接ID。</target>
        </trans-unit>
        <trans-unit id="239b3d190809a5bb14183b924e8a7fef0e270a8a" translate="yes" xml:space="preserve">
          <source>If closing a client connection produces an exception, that exception is not thrown from this method. A &lt;a href=&quot;jmxconnectionnotification&quot;&gt;&lt;code&gt;JMXConnectionNotification&lt;/code&gt;&lt;/a&gt; with type &lt;a href=&quot;jmxconnectionnotification#FAILED&quot;&gt;&lt;code&gt;JMXConnectionNotification.FAILED&lt;/code&gt;&lt;/a&gt; is emitted from this MBean with the connection ID of the connection that could not be closed.</source>
          <target state="translated">如果关闭客户端连接会产生异常，则不会从此方法引发该异常。甲&lt;a href=&quot;jmxconnectionnotification&quot;&gt; &lt;code&gt;JMXConnectionNotification&lt;/code&gt; 中&lt;/a&gt;与型&lt;a href=&quot;jmxconnectionnotification#FAILED&quot;&gt; &lt;code&gt;JMXConnectionNotification.FAILED&lt;/code&gt; &lt;/a&gt;从该MBean发出与该不能被关闭的连接的连接ID。</target>
        </trans-unit>
        <trans-unit id="e50776b9b1e158d35a0ee5b01de8d5ed7f3a4764" translate="yes" xml:space="preserve">
          <source>If concurrency support is desired, there are the following additional implications. The code path for any DocumentListener implementation and any UndoListener implementation must be threadsafe, and not access the component lock if trying to be safe from deadlocks. The &lt;code&gt;repaint&lt;/code&gt; and &lt;code&gt;revalidate&lt;/code&gt; methods on JComponent are safe.</source>
          <target state="translated">如果需要并发支持，则还有以下附加含义。任何DocumentListener实现和任何UndoListener实现的代码路径都必须是线程安全的，并且如果试图避免死锁，则不能访问组件锁。JComponent上的 &lt;code&gt;repaint&lt;/code&gt; 和 &lt;code&gt;revalidate&lt;/code&gt; 方法是安全的。</target>
        </trans-unit>
        <trans-unit id="6cc58710f7a52a62031b39086a811bf5c62f9be6" translate="yes" xml:space="preserve">
          <source>If corePoolSize or more threads are running, the Executor always prefers queuing a request rather than adding a new thread.</source>
          <target state="translated">如果corePoolSize或更多的线程正在运行,Executor总是倾向于排队请求,而不是增加一个新的线程。</target>
        </trans-unit>
        <trans-unit id="cb543f07d153ad84e16f6614709ff0723e83f00b" translate="yes" xml:space="preserve">
          <source>If currencyTimeLimit is &amp;gt; 0, then the new value for the attribute is cached in the attribute descriptor's 'value' field and the 'lastUpdatedTimeStamp' field is set to the current time stamp.</source>
          <target state="translated">如果currencyTimeLimit&amp;gt; 0，则将属性的新值缓存在属性描述符的&amp;ldquo;值&amp;rdquo;字段中，并将&amp;ldquo; lastUpdatedTimeStamp&amp;rdquo;字段设置为当前时间戳。</target>
        </trans-unit>
        <trans-unit id="318a070d46817b0d3e2904d4f73faabc24bf182e" translate="yes" xml:space="preserve">
          <source>If current thread is interrupted, throw InterruptedException.</source>
          <target state="translated">如果当前线程被中断,则抛出InterruptedException。</target>
        </trans-unit>
        <trans-unit id="d2831e950ddf2d38fc039e2e83359dc77d52eecc" translate="yes" xml:space="preserve">
          <source>If data has already been sent on the connection, it continues to flow during this handshake. When the handshake completes, this will be signaled with an event. This method is synchronous for the initial handshake on a connection and returns when the negotiated handshake is complete. Some protocols may not support multiple handshakes on an existing socket and may throw an IOException.</source>
          <target state="translated">如果连接上已经发送了数据,那么在这次握手过程中,数据会继续流动。当握手完成时,将用一个事件来表示。这个方法对于连接上的初始握手是同步的,并在协商的握手完成后返回。有些协议可能不支持在现有套接字上进行多次握手,并可能会抛出一个IOException。</target>
        </trans-unit>
        <trans-unit id="ad9eaed7fbd77713f034b874df556fc6a3657252" translate="yes" xml:space="preserve">
          <source>If data is specified for a &lt;code&gt;Node&lt;/code&gt; which does not support data.</source>
          <target state="translated">如果为不支持数据的 &lt;code&gt;Node&lt;/code&gt; 指定了数据。</target>
        </trans-unit>
        <trans-unit id="a23edc5313c1114129c0451e0f085c188db85181" translate="yes" xml:space="preserve">
          <source>If different docs have different bindings specified, then only two values of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; make sense, and the printer reports an error when the job is submitted if any other value is specified:</source>
          <target state="translated">如果不同的文档指定了不同的绑定，则只有两个&lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt;值才有意义，并且如果指定了任何其他值，则在提交作业时打印机会报告错误：</target>
        </trans-unit>
        <trans-unit id="6a5c3e077d48f57da30ae30c448c6f813a923be7" translate="yes" xml:space="preserve">
          <source>If different docs have different sheet collations specified, then only one value of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; is permitted, and the printer reports an error when the job is submitted if any other value is specified:</source>
          <target state="translated">如果不同的文档指定了不同的工作表排序规则，则仅允许使用&lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 的&lt;/a&gt;一个值，并且如果指定了其他任何值，则打印机在提交作业时将报告错误：</target>
        </trans-unit>
        <trans-unit id="4cc730ea4ab4177fe6780dd6b3762cbb0dc9f71f" translate="yes" xml:space="preserve">
          <source>If disabled, only the name and class of the object is returned. If enabled, the object will be returned.</source>
          <target state="translated">如果禁用,则只返回对象的名称和类。如果启用,则会返回对象的名称和类。</target>
        </trans-unit>
        <trans-unit id="768caddc9c01e6493ed6902aeea52fa3f4bd3950" translate="yes" xml:space="preserve">
          <source>If dragger is not null it is messaged with completeDrag.</source>
          <target state="translated">如果dragger不是null,则会用completeDrag发送消息。</target>
        </trans-unit>
        <trans-unit id="9ee0a7ef7d597d86c66ef2b09b41b3a0ba000faa" translate="yes" xml:space="preserve">
          <source>If dragger is not null it is messaged with continueDrag.</source>
          <target state="translated">如果拖动器不是空的,就会用continueDrag发送消息。</target>
        </trans-unit>
        <trans-unit id="5c1db332f67d0fafd5b3b4396fdcc2262e8b0c8b" translate="yes" xml:space="preserve">
          <source>If dump on exit is not set, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">如果未设置退出时的转储，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db742d57b076cafc55a417d3693f22f0799621fd" translate="yes" xml:space="preserve">
          <source>If dynamic layout is currently inactive then Containers re-layout their components when resizing is completed. As a result the &lt;code&gt;Component.validate()&lt;/code&gt; method will be invoked only once per resize. If dynamic layout is currently active then Containers re-layout their components on every native resize event and the &lt;code&gt;validate()&lt;/code&gt; method will be invoked each time. The OS/WM support can be queried using the getDesktopProperty(&quot;awt.dynamicLayoutSupported&quot;) method. This property will reflect the platform capability but is not sufficient to tell if it is presently enabled.</source>
          <target state="translated">如果动态布局当前处于非活动状态，则在调整大小后，容器会重新布局其组件。结果，每次调整大小时， &lt;code&gt;Component.validate()&lt;/code&gt; 方法将仅被调用一次。如果动态布局当前处于活动状态，则容器在每个本机调整大小事件上重新布局其组件，并且每次都会调用 &lt;code&gt;validate()&lt;/code&gt; 方法。可以使用getDesktopProperty（&amp;ldquo; awt.dynamicLayoutSupported&amp;rdquo;）方法查询OS / WM支持。该属性将反映平台的功能，但不足以判断当前是否启用了该功能。</target>
        </trans-unit>
        <trans-unit id="6c6f6022b3d9e0a350f4a712d1847c54f77b4d41" translate="yes" xml:space="preserve">
          <source>If editing, the &lt;code&gt;Component&lt;/code&gt; that is handling the editing.</source>
          <target state="translated">如果进行编辑，则为处理编辑的 &lt;code&gt;Component&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f896ef7bc7275d3c393aa1c9ea95576d1ef92625" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;Rectangle&lt;/code&gt; has any dimension less than 0, the result will have the dimensions of the other &lt;code&gt;Rectangle&lt;/code&gt;. If both &lt;code&gt;Rectangle&lt;/code&gt;s have at least one dimension less than 0, the result will have at least one dimension less than 0.</source>
          <target state="translated">如果任何一个 &lt;code&gt;Rectangle&lt;/code&gt; 的尺寸小于0，则结果将具有另一个 &lt;code&gt;Rectangle&lt;/code&gt; 的尺寸。如果两个 &lt;code&gt;Rectangle&lt;/code&gt; 的至少一维小于0，则结果将至少具有一维小于0。</target>
        </trans-unit>
        <trans-unit id="39bac83a50271cce4e40efc5165cbf9b9a9d7c02" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;Rectangle&lt;/code&gt; has any dimension less than zero the rules for &lt;a href=&quot;#NonExistent&quot;&gt;non-existent&lt;/a&gt; rectangles apply. If only one has a dimension less than zero, then the result will be a copy of the other &lt;code&gt;Rectangle&lt;/code&gt;. If both have dimension less than zero, then the result will have at least one dimension less than zero.</source>
          <target state="translated">如果任何一个 &lt;code&gt;Rectangle&lt;/code&gt; 的尺寸小于零，则不&lt;a href=&quot;#NonExistent&quot;&gt;存在的&lt;/a&gt;矩形的规则适用。如果只有一个尺寸小于零，则结果将是另一个 &lt;code&gt;Rectangle&lt;/code&gt; 的副本。如果两者的尺寸均小于零，则结果将至少具有一个尺寸小于零的尺寸。</target>
        </trans-unit>
        <trans-unit id="76142416fc4a8b368750309700f44557ecfd75c6" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;Rectangle&lt;/code&gt; has one or both dimensions equal to 0, the result along those axes with 0 dimensions will be equivalent to the results obtained by adding the corresponding origin coordinate to the result rectangle along that axis, similar to the operation of the &lt;a href=&quot;#add(java.awt.Point)&quot;&gt;&lt;code&gt;add(Point)&lt;/code&gt;&lt;/a&gt; method, but contribute no further dimension beyond that.</source>
          <target state="translated">如果任何一个 &lt;code&gt;Rectangle&lt;/code&gt; 具有一个或两个等于0的尺寸，则沿那些尺寸为0的轴的结果将等于通过将相应的原点坐标添加到沿该轴的结果矩形而获得的结果，类似于&lt;a href=&quot;#add(java.awt.Point)&quot;&gt; &lt;code&gt;add(Point)&lt;/code&gt; &lt;/a&gt;方法，但没有其他贡献。</target>
        </trans-unit>
        <trans-unit id="7e4a2225fea7b35153360c5ca3721807756a8d75" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt; parameter is &lt;code&gt;null&lt;/code&gt;, no changes are made to the document.</source>
          <target state="translated">如果 &lt;code&gt;elem&lt;/code&gt; 或 &lt;code&gt;htmlText&lt;/code&gt; 参数为 &lt;code&gt;null&lt;/code&gt; ，则不对文档进行任何更改。</target>
        </trans-unit>
        <trans-unit id="5b1071c4cdf25b92ce3f411ba460944872014a99" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;fixedCellWidth&lt;/code&gt; or &lt;code&gt;fixedCellHeight&lt;/code&gt; haven't been specified, heuristics are used. If the model is empty, the width is the &lt;code&gt;fixedCellWidth&lt;/code&gt;, if greater than &lt;code&gt;0&lt;/code&gt;, or a hard-coded value of &lt;code&gt;256&lt;/code&gt;. The height is the &lt;code&gt;fixedCellHeight&lt;/code&gt; multiplied by &lt;code&gt;visibleRowCount&lt;/code&gt;, if &lt;code&gt;fixedCellHeight&lt;/code&gt; is greater than &lt;code&gt;0&lt;/code&gt;, otherwise it is a hard-coded value of &lt;code&gt;16&lt;/code&gt; multiplied by &lt;code&gt;visibleRowCount&lt;/code&gt;.</source>
          <target state="translated">如果未指定 &lt;code&gt;fixedCellWidth&lt;/code&gt; 或 &lt;code&gt;fixedCellHeight&lt;/code&gt; ，则使用启发式。如果模型为空，则宽度为 &lt;code&gt;fixedCellWidth&lt;/code&gt; ，如果大于 &lt;code&gt;0&lt;/code&gt; ，则为硬编码值 &lt;code&gt;256&lt;/code&gt; 。如果 &lt;code&gt;fixedCellHeight&lt;/code&gt; 大于 &lt;code&gt;0&lt;/code&gt; ，则高度为 &lt;code&gt;fixedCellHeight&lt;/code&gt; 乘以 &lt;code&gt;visibleRowCount&lt;/code&gt; ，否则为 &lt;code&gt;16&lt;/code&gt; 的硬编码值乘以 &lt;code&gt;visibleRowCount&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="332d8e7d0f59b9812b7d8680ca5e21ee5e3a7a49" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;sourceXSubsampling&lt;/code&gt; or &lt;code&gt;sourceYSubsampling&lt;/code&gt; is 0 or negative, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果 &lt;code&gt;sourceXSubsampling&lt;/code&gt; 或 &lt;code&gt;sourceYSubsampling&lt;/code&gt; 为0或负数，则将抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10859c24a221b0a1a8f8c2d45e2dd5f29f7ffaa0" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;subsamplingXOffset&lt;/code&gt; or &lt;code&gt;subsamplingYOffset&lt;/code&gt; is negative or greater than or equal to the corresponding period, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果 &lt;code&gt;subsamplingXOffset&lt;/code&gt; 或 &lt;code&gt;subsamplingYOffset&lt;/code&gt; 为负或大于或等于相应的周期，则将抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c9e3a00ed69f539de04dcde556ef5fedbed9bf1" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; is a negative number then a value is substituted to maintain the aspect ratio of the original image dimensions. If both &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; are negative, then the original image dimensions are used.</source>
          <target state="translated">如果 &lt;code&gt;width&lt;/code&gt; 或 &lt;code&gt;height&lt;/code&gt; 为负数，则将替换一个值以保持原始图像尺寸的纵横比。如果 &lt;code&gt;width&lt;/code&gt; 和 &lt;code&gt;height&lt;/code&gt; 均为负数，则使用原始图像尺寸。</target>
        </trans-unit>
        <trans-unit id="f1bccf0359c9d2523582443e154621147124c9b2" translate="yes" xml:space="preserve">
          <source>If either argument is NaN and neither argument is infinite, then the result is NaN.</source>
          <target state="translated">如果其中一个论点是NaN,且两个论点都不是无限的,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="a87ec8779fbe2da84925808f31ac1112c6261d11" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, or the first argument is infinite, or the second argument is positive zero or negative zero, then the result is NaN.</source>
          <target state="translated">如果任何一个参数是NaN,或者第一个参数是无限的,或者第二个参数是正零或负零,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="b78f08e2975896437871c452fd60393fe6909b91" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, then the result is NaN.</source>
          <target state="translated">如果其中一个参数是NaN,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="34eb1a13a1d41fedad71ac94304afaf4d3b30061" translate="yes" xml:space="preserve">
          <source>If either argument is a NaN, then NaN is returned.</source>
          <target state="translated">如果任何一个参数是NaN,那么将返回NaN。</target>
        </trans-unit>
        <trans-unit id="1dead44a3b56a54e43e3eaa910e00403c25df167" translate="yes" xml:space="preserve">
          <source>If either argument is infinite, then the result is positive infinity.</source>
          <target state="translated">如果任何一个论点是无限的,那么结果就是正无限。</target>
        </trans-unit>
        <trans-unit id="41bc9309c0f8d33aae679550f8327f3ba41d91bd" translate="yes" xml:space="preserve">
          <source>If either index is &lt;code&gt;-1&lt;/code&gt;, this method does nothing and returns without exception. Otherwise, if either index is less than &lt;code&gt;-1&lt;/code&gt;, an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果任一索引为 &lt;code&gt;-1&lt;/code&gt; ，则此方法不执行任何操作，并且无例外地返回。否则，如果任一索引小于 &lt;code&gt;-1&lt;/code&gt; ，则抛出 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2a88d05f4fde9c492de3341283adf63bc8f2e9c" translate="yes" xml:space="preserve">
          <source>If either of the destination offsets are negative, the source region is clipped so that its top left will coincide with the top left of the destination image, taking subsampling into account. Then the result is clipped to the destination image on the right and bottom, if one is specified, taking subsampling and destination offsets into account.</source>
          <target state="translated">如果目标偏移量为负值,则考虑到子采样的因素,剪裁源区域,使其左上角与目标图像的左上角重合。然后,如果指定了目标图像的右侧和底部,则考虑到子采样和目标偏移,将结果剪裁到目标图像的右侧和底部。</target>
        </trans-unit>
        <trans-unit id="03f21ceb73c687836a6489d537281750ea1dd4dd" translate="yes" xml:space="preserve">
          <source>If either of the specified arrays contain themselves as elements either directly or indirectly through one or more levels of arrays, the behavior of this method is undefined.</source>
          <target state="translated">如果指定的数组中的任何一个数组直接或间接地通过一个或多个数组层次包含自己作为元素,则本方法的行为未被定义。</target>
        </trans-unit>
        <trans-unit id="180e76f99201ee9fe15021c8ef7f28c26ec9a151" translate="yes" xml:space="preserve">
          <source>If either the resulting or the old value for the useParentHandlers property is not null, then if the logger exists or if children for that logger exist, that logger will be updated to the resulting value. The value of the useParentHandlers property is the value specified in the configuration; if not specified, the default is true.</source>
          <target state="translated">如果 useParentHandlers 属性的结果值或旧值不为空,则如果记录仪存在,或者如果该记录仪的子代存在,则该记录仪将更新为结果值。useParentHandlers 属性的值为配置中指定的值;如果未指定,则默认为真。</target>
        </trans-unit>
        <trans-unit id="e3db76a27295abd8950cde00cc86a08c8f4f37d6" translate="yes" xml:space="preserve">
          <source>If either the source or destination regions end up having a width or height of 0, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果源或目标区域的宽度或高度最终为0，则抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16d93984ca72bf8d13d016fde295c0c3effdeb16" translate="yes" xml:space="preserve">
          <source>If either this URI or the given URI are opaque, or if the scheme and authority components of the two URIs are not identical, or if the path of this URI is not a prefix of the path of the given URI, then the given URI is returned.</source>
          <target state="translated">如果这个URI或给定的URI都不透明,或者两个URI的scheme和authority组件不一致,或者这个URI的路径不是给定URI路径的前缀,那么给定的URI将被返回。</target>
        </trans-unit>
        <trans-unit id="9aa050dc79127dc702ac7f7af9f8c09a95bedff5" translate="yes" xml:space="preserve">
          <source>If element and/or attribute names in the same start or empty-element tag are bound to different namespace URIs and are using the same prefix then the element or the first occurring attribute retains the original prefix and the following attributes have their prefixes replaced with a new prefix that is bound to the namespace URIs of those attributes.</source>
          <target state="translated">如果同一起始标签或空元素标签中的元素和/或属性名被绑定到不同的命名空间URI上,并且使用相同的前缀,那么元素或第一个出现的属性就会保留原来的前缀,而以下属性的前缀则会被替换成与这些属性的命名空间URI绑定的新前缀。</target>
        </trans-unit>
        <trans-unit id="5f2bce0ea72e2df5a3161327906870e899626cea" translate="yes" xml:space="preserve">
          <source>If end of file is encountered at any time during this entire process, then a &lt;code&gt;java.io.EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果在此整个过程中的任何时间遇到文件结尾，则将引发 &lt;code&gt;java.io.EOFException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ec3c5e0a4dd72da9a56884a1749a8ec51b24003" translate="yes" xml:space="preserve">
          <source>If end of file is encountered at any time during this entire process, then an &lt;code&gt;EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果在此整个过程中的任何时间遇到文件末尾，则将引发 &lt;code&gt;EOFException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e02489afb24dcd898ea786f1764d129a6f696e32" translate="yes" xml:space="preserve">
          <source>If end of file is encountered at any time during this entire process, then an &lt;code&gt;java.io.EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果在此整个过程中的任何时间遇到文件结尾，则将引发 &lt;code&gt;java.io.EOFException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69e5b4feef83c14b8462d2220d828694ae4230e4" translate="yes" xml:space="preserve">
          <source>If end of file is encountered before even one byte can be read, then &lt;code&gt;null&lt;/code&gt; is returned. Otherwise, each byte that is read is converted to type &lt;code&gt;char&lt;/code&gt; by zero-extension. If the character &lt;code&gt;'\n'&lt;/code&gt; is encountered, it is discarded and reading ceases. If the character &lt;code&gt;'\r'&lt;/code&gt; is encountered, it is discarded and, if the following byte converts to the character &lt;code&gt;'\n'&lt;/code&gt;, then that is discarded also; reading then ceases. If end of file is encountered before either of the characters &lt;code&gt;'\n'&lt;/code&gt; and &lt;code&gt;'\r'&lt;/code&gt; is encountered, reading ceases. Once reading has ceased, a &lt;code&gt;String&lt;/code&gt; is returned that contains all the characters read and not discarded, taken in order. Note that every character in this string will have a value less than &lt;code&gt;\u0100&lt;/code&gt;, that is, &lt;code&gt;(char)256&lt;/code&gt;.</source>
          <target state="translated">如果在甚至无法读取一个字节之前遇到文件末尾，则返回 &lt;code&gt;null&lt;/code&gt; 。否则，每个读取的字节将通过零扩展名转换为 &lt;code&gt;char&lt;/code&gt; 类型。如果遇到字符 &lt;code&gt;'\n'&lt;/code&gt; ，则将其丢弃并停止读取。如果遇到字符 &lt;code&gt;'\r'&lt;/code&gt; ，则将其丢弃；如果随后的字节转换为字符 &lt;code&gt;'\n'&lt;/code&gt; ，则也将其丢弃；然后阅读停止。如果在遇到字符 &lt;code&gt;'\n'&lt;/code&gt; 和 &lt;code&gt;'\r'&lt;/code&gt; 之前遇到文件结尾，则读取停止。一旦阅读停止，一个 &lt;code&gt;String&lt;/code&gt; 返回包含按顺序读取的所有已读取但未被丢弃的字符。请注意，此字符串中的每个字符的值都小于 &lt;code&gt;\u0100&lt;/code&gt; ，即 &lt;code&gt;(char)256&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="203a2360aef1ee92b807e282408d3018f93d728c" translate="yes" xml:space="preserve">
          <source>If end of stream is reached before the stream is at the desired position, then an &lt;code&gt;EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果在流到达所需位置之前到达流的末尾，则将引发 &lt;code&gt;EOFException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4bef5ed2f034c6a6bf34fec9b291f4c50c29549" translate="yes" xml:space="preserve">
          <source>If errors occur during the invocation of this method, such as an attempt to update a read-only node or a &lt;code&gt;Node.nodeName&lt;/code&gt; contains an invalid character according to the XML version in use, errors or warnings (&lt;code&gt;DOMError.SEVERITY_ERROR&lt;/code&gt; or &lt;code&gt;DOMError.SEVERITY_WARNING&lt;/code&gt;) will be reported using the &lt;code&gt;DOMErrorHandler&lt;/code&gt; object associated with the &quot;error-handler &quot; parameter. Note this method might also report fatal errors ( &lt;code&gt;DOMError.SEVERITY_FATAL_ERROR&lt;/code&gt;) if an implementation cannot recover from an error.</source>
          <target state="translated">如果在调用此方法期间发生错误，例如尝试更新只读节点或 &lt;code&gt;Node.nodeName&lt;/code&gt; 根据使用的XML版本包含无效字符，则将显示错误或警告（ &lt;code&gt;DOMError.SEVERITY_ERROR&lt;/code&gt; 或 &lt;code&gt;DOMError.SEVERITY_WARNING&lt;/code&gt; ）将使用与&amp;ldquo;错误处理程序&amp;rdquo;参数关联的 &lt;code&gt;DOMErrorHandler&lt;/code&gt; 对象进行报告。请注意，如果实现无法从错误中恢复， &lt;code&gt;DOMError.SEVERITY_FATAL_ERROR&lt;/code&gt; 此方法还可能报告致命错误（DOMError.SEVERITY_FATAL_ERROR）。</target>
        </trans-unit>
        <trans-unit id="2b674afa2ba891dd7a58dfaa94a5d64325a48496" translate="yes" xml:space="preserve">
          <source>If everything fails, &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果一切失败，则将抛出&lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84787651c093f5940bda88b1a55845848cbc36dc" translate="yes" xml:space="preserve">
          <source>If everything fails, an &lt;code&gt;XPathFactoryConfigurationException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果一切失败，将抛出 &lt;code&gt;XPathFactoryConfigurationException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ddbf63c0804dc6b273bd6e5b1e8254dbc36ee91" translate="yes" xml:space="preserve">
          <source>If execution environment is out of process, as is the default case, then if the evaluated code causes the execution environment to terminate, this &lt;code&gt;JShell&lt;/code&gt; instance will be closed but the calling process and VM remain valid.</source>
          <target state="translated">如果执行环境超出流程，这是默认情况，那么如果评估的代码导致执行环境终止，则此 &lt;code&gt;JShell&lt;/code&gt; 实例将被关闭，但调用流程和VM仍然有效。</target>
        </trans-unit>
        <trans-unit id="a3e73ecba896208f50db9710798b46a965a908cf" translate="yes" xml:space="preserve">
          <source>If fewer than corePoolSize threads are running, the Executor always prefers adding a new thread rather than queuing.</source>
          <target state="translated">如果运行的线程少于corePoolSize线程,Executor总是倾向于增加一个新的线程而不是排队。</target>
        </trans-unit>
        <trans-unit id="f250a59034e1c489b9abe228c4a6bad44105503f" translate="yes" xml:space="preserve">
          <source>If focus events are enabled for a &lt;code&gt;Component&lt;/code&gt;, calling the &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;dispatchEvent&lt;/code&gt; method with a &lt;code&gt;FocusEvent&lt;/code&gt; as the argument will result in a call to the &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;processFocusEvent&lt;/code&gt; method regardless of the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt;.</source>
          <target state="translated">如果为 &lt;code&gt;Component&lt;/code&gt; 启用了焦点事件，则不管当前的 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; 是什么，以 &lt;code&gt;FocusEvent&lt;/code&gt; 作为参数调用 &lt;code&gt;Component&lt;/code&gt; 的 &lt;code&gt;dispatchEvent&lt;/code&gt; 方法都将导致对 &lt;code&gt;Component&lt;/code&gt; 的 &lt;code&gt;processFocusEvent&lt;/code&gt; 方法的调用。</target>
        </trans-unit>
        <trans-unit id="40fc17409e4ee706dff7b6c91533503275fb1e4d" translate="yes" xml:space="preserve">
          <source>If focus events are enabled for a &lt;code&gt;Component&lt;/code&gt;, the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; determines whether or not a focus event should be dispatched to registered &lt;code&gt;FocusListener&lt;/code&gt; objects. If the events are to be dispatched, the &lt;code&gt;KeyboardFocusManager&lt;/code&gt; calls the &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;dispatchEvent&lt;/code&gt; method, which results in a call to the &lt;code&gt;Component&lt;/code&gt;'s &lt;code&gt;processFocusEvent&lt;/code&gt; method.</source>
          <target state="translated">如果为 &lt;code&gt;Component&lt;/code&gt; 启用了焦点事件，则当前的 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; 确定是否应将焦点事件调度到已注册的 &lt;code&gt;FocusListener&lt;/code&gt; 对象。如果要分派事件，则 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; 调用 &lt;code&gt;Component&lt;/code&gt; 的 &lt;code&gt;dispatchEvent&lt;/code&gt; 方法，这将导致对 &lt;code&gt;Component&lt;/code&gt; 的 &lt;code&gt;processFocusEvent&lt;/code&gt; 方法的调用。</target>
        </trans-unit>
        <trans-unit id="ca5a8548f3fbffd915bbf435ebb21f7a97c206bb" translate="yes" xml:space="preserve">
          <source>If for the URL's protocol (such as HTTP or JAR), there exists a public, specialized URLConnection subclass belonging to one of the following packages or one of their subpackages: java.lang, java.io, java.util, java.net, the connection returned will be of that subclass. For example, for HTTP an HttpURLConnection will be returned, and for JAR a JarURLConnection will be returned.</source>
          <target state="translated">如果对于URL的协议(比如HTTP或JAR),存在一个公共的、专门的URLConnection子类,属于以下包或它们的子包之一:java.lang、java.io、java.util、java.net,那么返回的连接将是那个子类的。例如,对于HTTP,将返回一个HttpURLConnection,对于JAR,将返回一个JarURLConnection。</target>
        </trans-unit>
        <trans-unit id="ecc3cf47c73dc6fc1a7d51257f1c70d39038a258" translate="yes" xml:space="preserve">
          <source>If for the handler's protocol (such as HTTP or JAR), there exists a public, specialized URLConnection subclass belonging to one of the following packages or one of their subpackages: java.lang, java.io, java.util, java.net, the connection returned will be of that subclass. For example, for HTTP an HttpURLConnection will be returned, and for JAR a JarURLConnection will be returned.</source>
          <target state="translated">如果对于处理程序的协议(如HTTP或JAR),存在一个公共的、专门的URLConnection子类,属于以下包或它们的子包之一:java.lang、java.io、java.util、java.net,那么返回的连接将是那个子类的。例如,对于HTTP,将返回一个HttpURLConnection,对于JAR,将返回一个JarURLConnection。</target>
        </trans-unit>
        <trans-unit id="6acb316f2f02233537ab314b2b515a379c378b40" translate="yes" xml:space="preserve">
          <source>If given an &lt;a href=&quot;inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;, this method behaves as if invoking &lt;a href=&quot;#connect(java.net.InetAddress,int)&quot;&gt;&lt;code&gt;connect(InetAddress,int)&lt;/code&gt;&lt;/a&gt; with the given socket addresses IP address and port number, except that the &lt;code&gt;SocketException&lt;/code&gt; that may be raised is not wrapped in an &lt;code&gt;UncheckedIOException&lt;/code&gt;. Datagrams in the socket's &lt;a href=&quot;standardsocketoptions#SO_RCVBUF&quot;&gt;socket receive buffer&lt;/a&gt;, which have not been &lt;a href=&quot;#receive(java.net.DatagramPacket)&quot;&gt;received&lt;/a&gt; before invoking this method, may be discarded.</source>
          <target state="translated">如果给定了&lt;a href=&quot;inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt;，则此方法的行为就像使用给定的套接字地址IP地址和端口号调用&lt;a href=&quot;#connect(java.net.InetAddress,int)&quot;&gt; &lt;code&gt;connect(InetAddress,int)&lt;/code&gt; 一样&lt;/a&gt;，不同之处在于可能引发的 &lt;code&gt;SocketException&lt;/code&gt; 没有包装在 &lt;code&gt;UncheckedIOException&lt;/code&gt; 中。套接字的&lt;a href=&quot;standardsocketoptions#SO_RCVBUF&quot;&gt;套接字接收缓冲区&lt;/a&gt;中的数据报（在调用此方法之前尚未被&lt;a href=&quot;#receive(java.net.DatagramPacket)&quot;&gt;接收&lt;/a&gt;）可能会被丢弃。</target>
        </trans-unit>
        <trans-unit id="8a8a04deb6efc63b4ca14bf4a5640a470b9eb6a3" translate="yes" xml:space="preserve">
          <source>If given an &lt;a href=&quot;inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;, this method behaves as if invoking &lt;a href=&quot;#connect(java.net.InetAddress,int)&quot;&gt;&lt;code&gt;connect(InetAddress,int)&lt;/code&gt;&lt;/a&gt; with the given socket addresses IP address and port number.</source>
          <target state="translated">如果给定了&lt;a href=&quot;inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt;，则此方法的行为就像使用给定的套接字地址IP地址和端口号调用&lt;a href=&quot;#connect(java.net.InetAddress,int)&quot;&gt; &lt;code&gt;connect(InetAddress,int)&lt;/code&gt; 一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4abed1287821693f6da736875b1dd20090fd9c3" translate="yes" xml:space="preserve">
          <source>If given an &lt;a href=&quot;inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;, this method behaves as if invoking &lt;a href=&quot;datagramsocket#connect-java.net.InetAddress-int-&quot;&gt;&lt;code&gt;connect(InetAddress,int)&lt;/code&gt;&lt;/a&gt; with the the given socket addresses IP address and port number.</source>
          <target state="translated">如果给定了&lt;a href=&quot;inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt;，则此方法的行为就像使用给定的套接字地址IP地址和端口号调用&lt;a href=&quot;datagramsocket#connect-java.net.InetAddress-int-&quot;&gt; &lt;code&gt;connect(InetAddress,int)&lt;/code&gt; 一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e516526c9c2357988df1234780c497763164fab1" translate="yes" xml:space="preserve">
          <source>If handshaking fails for any reason, the &lt;code&gt;SSLSocket&lt;/code&gt; is closed, and no further communications can be done.</source>
          <target state="translated">如果握手由于任何原因失败，则 &lt;code&gt;SSLSocket&lt;/code&gt; 将关闭，并且无法进行进一步的通信。</target>
        </trans-unit>
        <trans-unit id="9a00d8a2054c6cca37fdcf90a95f1f7f1ad5e5f0" translate="yes" xml:space="preserve">
          <source>If hook or callback methods throw exceptions, internal worker threads may in turn fail and abruptly terminate.</source>
          <target state="translated">如果钩子或回调方法抛出异常,内部工作线程可能反过来失败并突然终止。</target>
        </trans-unit>
        <trans-unit id="a2a7481f1636ab9a24c9018af1fcad7f07157bdd" translate="yes" xml:space="preserve">
          <source>If hook, callback, or BlockingQueue methods throw exceptions, internal worker threads may in turn fail, abruptly terminate, and possibly be replaced.</source>
          <target state="translated">如果hook、回调或BlockingQueue方法抛出异常,内部工作线程可能会反过来失败,突然终止,并可能被替换。</target>
        </trans-unit>
        <trans-unit id="085d6508b165d7efeb827d901170784516d5c017" translate="yes" xml:space="preserve">
          <source>If horizon is &lt;code&gt;0&lt;/code&gt;, then the horizon is ignored and this method continues to search through the input looking for the specified pattern without bound. In this case it may buffer all of the input searching for the pattern.</source>
          <target state="translated">如果horizo​​n为 &lt;code&gt;0&lt;/code&gt; ，那么将忽略horizo​​n，该方法将继续在输入中搜索以查找指定的模式而不受限制。在这种情况下，它可以缓冲搜索模式的所有输入。</target>
        </trans-unit>
        <trans-unit id="e185e59957de1a2d9502a435e3bf5d9b3e15599e" translate="yes" xml:space="preserve">
          <source>If horizon is negative, then an IllegalArgumentException is thrown.</source>
          <target state="translated">如果horizon为负值,则会抛出IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="5c1e650eb5f2174a711da5a09bfcd316b4c0f07f" translate="yes" xml:space="preserve">
          <source>If however, the serialization is not possible because the Java object is not immediately serializable, this class will attempt to serialize all non-static members to permit the object state to be serialized. Static or transient fields cannot be serialized; an attempt to serialize them will result in a &lt;code&gt;SerialException&lt;/code&gt; object being thrown.</source>
          <target state="translated">但是，如果由于Java对象无法立即进行序列化而无法进行序列化，则此类将尝试序列化所有非静态成员以允许序列化对象状态。静态或瞬态字段无法序列化；尝试对其进行序列化将导致抛出 &lt;code&gt;SerialException&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="31e1ede01add4d64dba9a3481e31fdf9753b8a4c" translate="yes" xml:space="preserve">
          <source>If however, the serialization is not possible in the case where the Java object is not immediately serializable, this class will attempt to serialize all non static members to permit the object instance state to be serialized. Static or transient fields cannot be serialized and attempting to do so will result in a &lt;code&gt;SerialException&lt;/code&gt; being thrown.</source>
          <target state="translated">但是，如果在Java对象无法立即序列化的情况下无法进行序列化，则此类将尝试序列化所有非静态成员以允许序列化对象实例状态。静态或瞬态字段无法序列化，尝试进行序列化将导致引发 &lt;code&gt;SerialException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="272ee6aa9e995da35c3e7f8f88e4b02553afd186" translate="yes" xml:space="preserve">
          <source>If i == 0 returns the action description fetched from UIManager.getString(&quot;AbstractButton.clickText&quot;); otherwise returns null.</source>
          <target state="translated">如果i ==0,则返回从UIManager.getString(&quot;AbstractButton.clickText&quot;)获取的动作描述;否则返回null。</target>
        </trans-unit>
        <trans-unit id="c3c9e4ade0cd42fbb5a5e7d40ca8bfb9569f944c" translate="yes" xml:space="preserve">
          <source>If i == 0 selects this AccessibleJListChild by calling JList.this.setSelectedIndex(indexInParent) and then returns true; otherwise returns false.</source>
          <target state="translated">如果i ==0通过调用JList.this.setSelectedIndex(indexInParent)选择这个AccessibleJListChild,然后返回true;否则返回false。</target>
        </trans-unit>
        <trans-unit id="c672e7792e737065f944dcb4cec0eb9d5372d1e1" translate="yes" xml:space="preserve">
          <source>If implementing JavaSound on a I3DL2-compliant device:</source>
          <target state="translated">如果在兼容I3DL2的设备上实现JavaSound。</target>
        </trans-unit>
        <trans-unit id="3fd0a906cb89e2de9c5076d850930cae34f103b9" translate="yes" xml:space="preserve">
          <source>If implementing an unusual calendar system that is not based on years, months and days, or where you want direct control, then the &lt;code&gt;ChronoPeriod&lt;/code&gt; interface must be directly implemented.</source>
          <target state="translated">如果实现的非常 &lt;code&gt;ChronoPeriod&lt;/code&gt; 日历系统不是基于年，月，日或您要直接控制的地方，则必须直接实现ChronoPeriod接口。</target>
        </trans-unit>
        <trans-unit id="07b0ad2086ad124aeb2593860505d4dc09bcafc2" translate="yes" xml:space="preserve">
          <source>If implicit and explicit opening and closing are mixed on the same &lt;code&gt;MidiDevice&lt;/code&gt; instance, the following rules apply:</source>
          <target state="translated">如果在同一 &lt;code&gt;MidiDevice&lt;/code&gt; 实例上混合了隐式和显式的打开和关闭，则适用以下规则：</target>
        </trans-unit>
        <trans-unit id="58b430e8bf58bb5b6e8fdbf80a0cd30f4538db11" translate="yes" xml:space="preserve">
          <source>If index or size is negative, or greater than the allowed value.</source>
          <target state="translated">如果指数或大小为负值,或大于允许值。</target>
        </trans-unit>
        <trans-unit id="c635ec7df61e52aeac84e0512f36bd12bd58d35c" translate="yes" xml:space="preserve">
          <source>If inputComponent is non-null, the focus is requested on that, otherwise request focus on the default value</source>
          <target state="translated">如果inputComponent是非空的,则请求将焦点放在它上,否则请求将焦点放在默认值上。</target>
        </trans-unit>
        <trans-unit id="1b6c1ac0801d0f32085f65cf19851af72a8b38e1" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">如果没有足够的许可,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到三种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="41f0c20f43c3bf64e0efed44e2fb775806ea99b7" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">如果没有足够的许可,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到有两种情况发生。</target>
        </trans-unit>
        <trans-unit id="0d316920d5718f1bd7a8baa6604a77f96ebb5665" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes one of the &lt;a href=&quot;#release()&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; methods for this semaphore and the current thread is next to be assigned permits and the number of available permits satisfies this request.</source>
          <target state="translated">如果没有足够的许可，则当前线程将出于线程调度目的而被禁用，并处于休眠状态，直到某个其他线程为此信号量调用一种&lt;a href=&quot;#release()&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt;方法，并且下一个当前线程将被分配许可，并且可用许可的数量满足该请求。</target>
        </trans-unit>
        <trans-unit id="6392fbf3bc8eb96daeacf7450eb84b4b39a684c9" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes one of the &lt;a href=&quot;semaphore#release--&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; methods for this semaphore, the current thread is next to be assigned permits and the number of available permits satisfies this request.</source>
          <target state="translated">如果没有足够的许可，则当前线程将出于线程调度目的而被禁用，并且处于休眠状态，直到其他某个线程为此信号量调用一种&lt;a href=&quot;semaphore#release--&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt;方法为止，接下来将为当前线程分配许可，并且可用许可的数量可以满足该请求。</target>
        </trans-unit>
        <trans-unit id="2f81c133b1f0b74c30d4d20073c4db1886f54e67" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt; and the number of available permits is unchanged.</source>
          <target state="translated">如果没有足够的许可证，则此方法将立即返回 &lt;code&gt;false&lt;/code&gt; 值，并且可用许可证的数量不变。</target>
        </trans-unit>
        <trans-unit id="6917340a867ad875b7b2abf8931c9a665a0bbc79" translate="yes" xml:space="preserve">
          <source>If integer math were being used and this value were being composited in &lt;a href=&quot;#SRC&quot;&gt;&lt;code&gt;SRC&lt;/code&gt;&lt;/a&gt; mode with no extra alpha, then the math would indicate that the results were (in integer format):</source>
          <target state="translated">如果使用整数数学运算，并且此值在&lt;a href=&quot;#SRC&quot;&gt; &lt;code&gt;SRC&lt;/code&gt; &lt;/a&gt;模式下合成且没有额外的alpha值，则该数学运算将指示结果为（整数格式）：</target>
        </trans-unit>
        <trans-unit id="3ee886087a23f0ef283d53172b5a86b2108daa86" translate="yes" xml:space="preserve">
          <source>If interrupted while blocked in step 4, throw InterruptedException.</source>
          <target state="translated">如果在步骤4中被阻止时被打断,则抛出InterruptedException。</target>
        </trans-unit>
        <trans-unit id="3a74fc2cc725f0cf0347bdb572b4ec73b5f5ad65" translate="yes" xml:space="preserve">
          <source>If invokeLater is called from the event dispatching thread -- for example, from a JButton's ActionListener -- the</source>
          <target state="translated">如果从事件派遣线程中调用invokeLater--例如,从JButton的ActionListener中调用,则</target>
        </trans-unit>
        <trans-unit id="8d2bc19f50633c8c0c8e271655bc0f3233284658" translate="yes" xml:space="preserve">
          <source>If it is critical to obtain every active subgroup in this thread group, the caller should verify that the returned int value is strictly less than the length of &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">如果获取该线程组中的每个活动子组至关重要，则调用者应验证返回的int值严格小于 &lt;code&gt;list&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="cc469862baa4b5e3d18bc2ca8c5358c4773f7d5f" translate="yes" xml:space="preserve">
          <source>If it is critical to obtain every active thread in the current thread's thread group and its subgroups, the invoker should verify that the returned int value is strictly less than the length of &lt;code&gt;tarray&lt;/code&gt;.</source>
          <target state="translated">如果获取当前线程的线程组及其子组中的每个活动线程至关重要，则调用者应验证返回的int值严格小于 &lt;code&gt;tarray&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="22683bf338326eeebb95e34c255b900a9e0a2f93" translate="yes" xml:space="preserve">
          <source>If it is critical to obtain every active thread in this thread group, the caller should verify that the returned int value is strictly less than the length of &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">如果获取该线程组中的每个活动线程至关重要，则调用者应验证返回的int值严格小于 &lt;code&gt;list&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="c685c0ba10c68c8f1f3a8c193feb8d700f179cf1" translate="yes" xml:space="preserve">
          <source>If it is false, then expose &lt;b&gt;[member type definition name]&lt;/b&gt; and &lt;b&gt;[member type definition namespace]&lt;/b&gt; properties;</source>
          <target state="translated">如果为假，则公开&lt;b&gt;[成员类型定义名称]&lt;/b&gt;和&lt;b&gt;[成员类型定义名称空间]&lt;/b&gt;属性；</target>
        </trans-unit>
        <trans-unit id="15b4ed739e5d26e30a9b9b0921ac056bf0af4f7b" translate="yes" xml:space="preserve">
          <source>If it is false, then expose &lt;b&gt;[type definition name]&lt;/b&gt; and &lt;b&gt;[type definition namespace]&lt;/b&gt; properties;</source>
          <target state="translated">如果为假，则公开&lt;b&gt;[类型定义名称]&lt;/b&gt;和&lt;b&gt;[类型定义名称空间]&lt;/b&gt;属性；</target>
        </trans-unit>
        <trans-unit id="54d0672abd6341128d9d7ad099fd323b0c8ef7b4" translate="yes" xml:space="preserve">
          <source>If it is implemented to do so, the &lt;code&gt;SyncProvider&lt;/code&gt; object may also create a &lt;code&gt;SyncResolver&lt;/code&gt; object and either initialize the &lt;code&gt;SyncProviderException&lt;/code&gt; object with it at construction time or set it with the &lt;code&gt;SyncProvider&lt;/code&gt; object at a later time.</source>
          <target state="translated">如果实现了此目的，则 &lt;code&gt;SyncProvider&lt;/code&gt; 对象还可以创建一个 &lt;code&gt;SyncResolver&lt;/code&gt; 对象，并在构造时使用它初始化 &lt;code&gt;SyncProviderException&lt;/code&gt; 对象，或者在以后使用 &lt;code&gt;SyncProvider&lt;/code&gt; 对象设置它。</target>
        </trans-unit>
        <trans-unit id="03e7088330e477594f46099a50c9ebf8a9c61981" translate="yes" xml:space="preserve">
          <source>If it is set to &lt;a href=&quot;#FALSE&quot;&gt;&lt;code&gt;FALSE&lt;/code&gt;&lt;/a&gt;, the packer may reorder elements, and also remove JAR directory entries, which carry no useful information for Java applications. (Typically this enables better compression.)</source>
          <target state="translated">如果将其设置为&lt;a href=&quot;#FALSE&quot;&gt; &lt;code&gt;FALSE&lt;/code&gt; &lt;/a&gt;，则打包程序可以重新排序元素，还可以删除JAR目录条目，这些条目不包含Java应用程序的有用信息。（通常这可以实现更好的压缩。）</target>
        </trans-unit>
        <trans-unit id="a8a140e583fff0cfc9d06bbb68afa76210088042" translate="yes" xml:space="preserve">
          <source>If it is set to &lt;a href=&quot;pack200.packer#FALSE&quot;&gt;&lt;code&gt;FALSE&lt;/code&gt;&lt;/a&gt;, the packer may reorder elements, and also remove JAR directory entries, which carry no useful information for Java applications. (Typically this enables better compression.)</source>
          <target state="translated">如果将其设置为&lt;a href=&quot;pack200.packer#FALSE&quot;&gt; &lt;code&gt;FALSE&lt;/code&gt; &lt;/a&gt;，则打包程序可能会对元素进行重新排序，并且还会删除JAR目录条目，这些目录条目不包含Java应用程序的有用信息。（通常这可以实现更好的压缩。）</target>
        </trans-unit>
        <trans-unit id="349c3ce48f2850808153616db77878ba7dc35133" translate="yes" xml:space="preserve">
          <source>If iterables and sets containing &lt;code&gt;null&lt;/code&gt; are passed as arguments to methods in this class, a &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果将包含 &lt;code&gt;null&lt;/code&gt; 的可迭代对象和集合作为参数传递给此类中的方法，则将引发 &lt;code&gt;NullPointerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b5e36e15c72143d9f79d44bccee481b6c8b7952" translate="yes" xml:space="preserve">
          <source>If key events are enabled for a &lt;code&gt;Component&lt;/code&gt;, the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; determines whether or not a key event should be dispatched to registered &lt;code&gt;KeyListener&lt;/code&gt; objects. The &lt;code&gt;DefaultKeyboardFocusManager&lt;/code&gt; will not dispatch key events to a &lt;code&gt;Component&lt;/code&gt; that is not the focus owner or is not showing.</source>
          <target state="translated">如果为 &lt;code&gt;Component&lt;/code&gt; 启用了按键事件，则当前的 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; 确定是否应将按键事件分派到已注册的 &lt;code&gt;KeyListener&lt;/code&gt; 对象。该 &lt;code&gt;DefaultKeyboardFocusManager&lt;/code&gt; 不会调度关键事件的 &lt;code&gt;Component&lt;/code&gt; 不是焦点所有者或没有显示。</target>
        </trans-unit>
        <trans-unit id="578dfd2269ad5f68f754865852ba3828ba552206" translate="yes" xml:space="preserve">
          <source>If l is &lt;code&gt;null&lt;/code&gt;, no exception is thrown and no action is performed.</source>
          <target state="translated">如果l为 &lt;code&gt;null&lt;/code&gt; ，则不会引发异常，也不会执行任何操作。</target>
        </trans-unit>
        <trans-unit id="8f1683e5b5f316b42c49560377be91252becd81d" translate="yes" xml:space="preserve">
          <source>If listener &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception is thrown and no action is performed.</source>
          <target state="translated">如果侦听器 &lt;code&gt;l&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则不会引发异常，也不会执行任何操作。</target>
        </trans-unit>
        <trans-unit id="b7b8214ffef472fc8e7c1e2311b38613b16b1726" translate="yes" xml:space="preserve">
          <source>If listener is already registered, it will be registered again.</source>
          <target state="translated">如果听众已经注册,将再次注册。</target>
        </trans-unit>
        <trans-unit id="0102c4bf84a1e8f5da988caa52f2807997272c61" translate="yes" xml:space="preserve">
          <source>If listener is null, no exception is thrown and no action is performed.</source>
          <target state="translated">如果listener为null,则不会抛出异常,也不会执行任何操作。</target>
        </trans-unit>
        <trans-unit id="9f90529506d3a0958fad7a3ecbf1c1171a153e5b" translate="yes" xml:space="preserve">
          <source>If loader is &lt;code&gt;null&lt;/code&gt;, the script engine factories that are bundled with the platform and that are in the usual extension directories (installed extensions) are loaded.</source>
          <target state="translated">如果loader为 &lt;code&gt;null&lt;/code&gt; ，则将加载与平台捆绑在一起且位于通常的扩展目录（已安装扩展）中的脚本引擎工厂。</target>
        </trans-unit>
        <trans-unit id="6e767135edebb75b3957eb1a33bb637fe33bf252" translate="yes" xml:space="preserve">
          <source>If loader is &lt;code&gt;null&lt;/code&gt;, the script engine factories that are bundled with the platform are loaded.</source>
          <target state="translated">如果loader为 &lt;code&gt;null&lt;/code&gt; ，则将加载与平台捆绑在一起的脚本引擎工厂。</target>
        </trans-unit>
        <trans-unit id="ee069a1e9967d9348b8218cc73e384bb53741058" translate="yes" xml:space="preserve">
          <source>If many entries are to be made into a &lt;code&gt;Hashtable&lt;/code&gt;, creating it with a sufficiently large capacity may allow the entries to be inserted more efficiently than letting it perform automatic rehashing as needed to grow the table.</source>
          <target state="translated">如果要在 &lt;code&gt;Hashtable&lt;/code&gt; 中创建许多条目，则创建一个具有足够大容量的表可能比使它根据需要增长表的自动重新哈希处理更有效地插入条目。</target>
        </trans-unit>
        <trans-unit id="6dc60d765a093b43a6239eb2d5685c05051e44ee" translate="yes" xml:space="preserve">
          <source>If many mappings are to be stored in a &lt;code&gt;HashMap&lt;/code&gt; instance, creating it with a sufficiently large capacity will allow the mappings to be stored more efficiently than letting it perform automatic rehashing as needed to grow the table. Note that using many keys with the same &lt;code&gt;hashCode()&lt;/code&gt; is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;, this class may use comparison order among keys to help break ties.</source>
          <target state="translated">如果将许多映射存储在 &lt;code&gt;HashMap&lt;/code&gt; 实例中，则创建具有足够大容量的映射将比让其根据需要增长表的自动重新哈希处理更有效地存储映射。请注意，使用具有相同 &lt;code&gt;hashCode()&lt;/code&gt; 的许多键是降低任何哈希表性能的肯定方法。为了改善影响，当键为&lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; 时&lt;/a&gt;，此类可以使用键之间的比较顺序来帮助打破平局。</target>
        </trans-unit>
        <trans-unit id="f7d3048870d83219010add9711bb4dd7ca3f2a54" translate="yes" xml:space="preserve">
          <source>If module &lt;code&gt;X&lt;/code&gt; exports a package to &lt;code&gt;Y&lt;/code&gt;, and if the runtime &lt;code&gt;Module&lt;/code&gt;&lt;code&gt;X&lt;/code&gt; does not read &lt;code&gt;Y&lt;/code&gt; then target &lt;code&gt;Y&lt;/code&gt; is located as if by invoking &lt;a href=&quot;#findModule(java.lang.String)&quot;&gt;&lt;code&gt;findModule&lt;/code&gt;&lt;/a&gt; to find the module in the layer or its parent layers. If &lt;code&gt;Y&lt;/code&gt; is found then the package is exported to the instance of &lt;code&gt;Y&lt;/code&gt; that was found. If &lt;code&gt;Y&lt;/code&gt; is not found then the qualified export is ignored.</source>
          <target state="translated">如果模块 &lt;code&gt;X&lt;/code&gt; 将包导出到 &lt;code&gt;Y&lt;/code&gt; ，并且运行时 &lt;code&gt;Module&lt;/code&gt; &lt;code&gt;X&lt;/code&gt; 不读取 &lt;code&gt;Y&lt;/code&gt; ，则通过调用&lt;a href=&quot;#findModule(java.lang.String)&quot;&gt; &lt;code&gt;findModule&lt;/code&gt; &lt;/a&gt;在层或其父层中查找模块来定位目标 &lt;code&gt;Y&lt;/code&gt; 。如果找到了 &lt;code&gt;Y&lt;/code&gt; ，则程序包将导出到找到的 &lt;code&gt;Y&lt;/code&gt; 的实例。如果未找到 &lt;code&gt;Y&lt;/code&gt; ,则将忽略合格的导出。</target>
        </trans-unit>
        <trans-unit id="d390f7b0fed59c2ff1380a1ceb798db4d298ae1b" translate="yes" xml:space="preserve">
          <source>If module &lt;code&gt;X&lt;/code&gt; exports a package to &lt;code&gt;Y&lt;/code&gt;, and if the runtime &lt;code&gt;Module&lt;/code&gt;&lt;code&gt;X&lt;/code&gt; reads &lt;code&gt;Module&lt;/code&gt;&lt;code&gt;Y&lt;/code&gt;, then the package is exported to &lt;code&gt;Module&lt;/code&gt;&lt;code&gt;Y&lt;/code&gt; (which may be in the same layer as &lt;code&gt;X&lt;/code&gt; or a parent layer).</source>
          <target state="translated">如果模块 &lt;code&gt;X&lt;/code&gt; 将包导出到 &lt;code&gt;Y&lt;/code&gt; ，并且运行时 &lt;code&gt;Module&lt;/code&gt; &lt;code&gt;X&lt;/code&gt; 读取 &lt;code&gt;Module&lt;/code&gt; &lt;code&gt;Y&lt;/code&gt; ，则包将导出到 &lt;code&gt;Module&lt;/code&gt; &lt;code&gt;Y&lt;/code&gt; （它可以与 &lt;code&gt;X&lt;/code&gt; 处于同一层或父层）。</target>
        </trans-unit>
        <trans-unit id="403efbf3d99b9a55860af122e7ea1fa369ccd1ea" translate="yes" xml:space="preserve">
          <source>If more formats are provided than needed by the pattern string, the remaining ones are ignored. If fewer formats are provided than needed, then only the first &lt;code&gt;newFormats.length&lt;/code&gt; formats are replaced.</source>
          <target state="translated">如果提供的格式多于模式字符串所需的格式，则其余格式将被忽略。如果提供的格式少于需要的格式，则仅替换第一个 &lt;code&gt;newFormats.length&lt;/code&gt; 格式。</target>
        </trans-unit>
        <trans-unit id="88fc14eaff46a9dd5b43fbbfdf0127ddfea55823" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;delegatePublic&lt;/code&gt; entry matches, the matching entry with the longest matching &lt;code&gt;publicIdStartString&lt;/code&gt; value is returned.</source>
          <target state="translated">如果多个 &lt;code&gt;delegatePublic&lt;/code&gt; 项匹配，则返回具有最长匹配 &lt;code&gt;publicIdStartString&lt;/code&gt; 值的匹配项。</target>
        </trans-unit>
        <trans-unit id="59651f5fa4d31880a671cf0ce022bc0fa42ba699" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;delegatePublic&lt;/code&gt; entry matches, the matching entry with the longest matching &lt;code&gt;uriStartString&lt;/code&gt; value is returned.</source>
          <target state="translated">如果不止一个 &lt;code&gt;delegatePublic&lt;/code&gt; 项匹配，最长匹配的匹配项 &lt;code&gt;uriStartString&lt;/code&gt; 返回值。</target>
        </trans-unit>
        <trans-unit id="297b17bdac784aa0adbfddd9b55d1bbb6d8ed4e3" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;delegateSystem&lt;/code&gt; entry matches, the matching entry with the longest matching &lt;code&gt;systemIdStartString&lt;/code&gt; value is returned.</source>
          <target state="translated">如果一个以上的 &lt;code&gt;delegateSystem&lt;/code&gt; 条目匹配，则返回具有最长匹配的 &lt;code&gt;systemIdStartString&lt;/code&gt; 值的匹配条目。</target>
        </trans-unit>
        <trans-unit id="5f1964f8ab19e3a1d9048d9994e12715e3e82bb8" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;rewriteSystem&lt;/code&gt; entry matches, the matching entry with the longest normalized &lt;code&gt;systemIdStartString&lt;/code&gt; value is returned.</source>
          <target state="translated">如果多个 &lt;code&gt;rewriteSystem&lt;/code&gt; 条目匹配，则返回最长的标准化 &lt;code&gt;systemIdStartString&lt;/code&gt; 值的匹配条目。</target>
        </trans-unit>
        <trans-unit id="493c294f5c18b9360394be2f1230acb929c4efe8" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;rewriteURI&lt;/code&gt; entry matches, the matching entry with the longest normalized &lt;code&gt;uriStartString&lt;/code&gt; value is returned.</source>
          <target state="translated">如果有多个 &lt;code&gt;rewriteURI&lt;/code&gt; 条目匹配，则返回具有最长标准化 &lt;code&gt;uriStartString&lt;/code&gt; 值的匹配条目。</target>
        </trans-unit>
        <trans-unit id="7f645ec9f2894ffb6e64d13303f47e749823b0e9" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;systemSuffix&lt;/code&gt; entry matches, the matching entry with the longest normalized &lt;code&gt;systemIdSuffix&lt;/code&gt; value is returned.</source>
          <target state="translated">如果有多个 &lt;code&gt;systemSuffix&lt;/code&gt; 条目匹配，则返回具有最长的标准化 &lt;code&gt;systemIdSuffix&lt;/code&gt; 值的匹配条目。</target>
        </trans-unit>
        <trans-unit id="16b11a7c5339b99b84c48f7fe6a5331cc8851de5" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;uriSuffix&lt;/code&gt; entry matches, the matching entry with the longest normalized &lt;code&gt;uriSuffix&lt;/code&gt; value is returned.</source>
          <target state="translated">如果有多个 &lt;code&gt;uriSuffix&lt;/code&gt; 条目匹配，则将返回标准化 &lt;code&gt;uriSuffix&lt;/code&gt; 值最长的匹配条目。</target>
        </trans-unit>
        <trans-unit id="f81dba9cec8cf743a82c5f4acc275a929c8964b3" translate="yes" xml:space="preserve">
          <source>If more than one listener terminates with an uncaught error or exception, an implementation may record the additional errors or exceptions as &lt;a href=&quot;../../../../java.base/java/lang/throwable#addSuppressed(java.lang.Throwable)&quot;&gt;suppressed exceptions&lt;/a&gt;.</source>
          <target state="translated">如果一个以上的侦听器以未捕获的错误或异常终止，则实现可以将其他错误或异常记录为受&lt;a href=&quot;../../../../java.base/java/lang/throwable#addSuppressed(java.lang.Throwable)&quot;&gt;抑制的异常&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca2bc26c1a10450fbbbc1b4da5d4954e22c3c85b" translate="yes" xml:space="preserve">
          <source>If more than one prefix is currently mapped to the same URI, this method will make an arbitrary selection; if you want all of the prefixes, use the &lt;a href=&quot;#getPrefixes()&quot;&gt;&lt;code&gt;getPrefixes()&lt;/code&gt;&lt;/a&gt; method instead.</source>
          <target state="translated">如果当前有多个前缀映射到相同的URI，则此方法将进行任意选择；否则，将进行任意选择。如果需要所有前缀，请改用&lt;a href=&quot;#getPrefixes()&quot;&gt; &lt;code&gt;getPrefixes()&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="4db95816febda6de7835e87bdeaef107c21d9eea" translate="yes" xml:space="preserve">
          <source>If multiple catalog files are specified through the &lt;code&gt;uris&lt;/code&gt; argument or &lt;code&gt;javax.xml.catalog.files&lt;/code&gt; property, the first entry is considered the main catalog, while others are treated as alternative catalogs after those referenced by the &lt;code&gt;nextCatalog&lt;/code&gt; elements in the main catalog.</source>
          <target state="translated">如果通过 &lt;code&gt;uris&lt;/code&gt; 参数或 &lt;code&gt;javax.xml.catalog.files&lt;/code&gt; 属性指定了多个目录文件，则将第一个条目视为主目录，而将其他条目作为主目录中 &lt;code&gt;nextCatalog&lt;/code&gt; 元素引用的目录之后的替代目录。</target>
        </trans-unit>
        <trans-unit id="7b42ca8cc8280b3ca185d72fc9765dbc058c02c1" translate="yes" xml:space="preserve">
          <source>If multiple class loaders delegate to each other and define classes with the same package name, and one such loader relies on the lookup behavior of &lt;code&gt;getPackage&lt;/code&gt; to return a &lt;code&gt;Package&lt;/code&gt; from a parent loader, then the properties exposed by the &lt;code&gt;Package&lt;/code&gt; may not be as expected in the rest of the program.</source>
          <target state="translated">如果多个类加载器相互委托并用相同的包名称定义类，并且一个此类加载器依赖于 &lt;code&gt;getPackage&lt;/code&gt; 的查找行为从父加载器返回 &lt;code&gt;Package&lt;/code&gt; ，则该 &lt;code&gt;Package&lt;/code&gt; 公开的属性可能与预期的不同。该程序的其余部分。</target>
        </trans-unit>
        <trans-unit id="f2cf1bf7c92db59422c4dbe0cefb78945b19c3fa" translate="yes" xml:space="preserve">
          <source>If multiple class loaders delegate to each other and define classes with the same package name, and one such loader relies on the lookup behavior of &lt;code&gt;getPackage&lt;/code&gt; to return a &lt;code&gt;Package&lt;/code&gt; from a parent loader, then the properties exposed by the &lt;code&gt;Package&lt;/code&gt; may not be as expected in the rest of the program. For example, the &lt;code&gt;Package&lt;/code&gt; will only expose annotations from the &lt;code&gt;package-info.class&lt;/code&gt; file defined by the parent loader, even if annotations exist in a &lt;code&gt;package-info.class&lt;/code&gt; file defined by a child loader. A more robust approach is to use the &lt;a href=&quot;#getDefinedPackage(java.lang.String)&quot;&gt;&lt;code&gt;getDefinedPackage(java.lang.String)&lt;/code&gt;&lt;/a&gt; method which returns a &lt;code&gt;Package&lt;/code&gt; for the specified class loader.</source>
          <target state="translated">如果多个类加载器相互委托并用相同的包名称定义类，并且一个此类加载器依赖于 &lt;code&gt;getPackage&lt;/code&gt; 的查找行为从父加载器返回 &lt;code&gt;Package&lt;/code&gt; ，则该 &lt;code&gt;Package&lt;/code&gt; 公开的属性可能与预期的不同。该程序的其余部分。例如，即使子加载器定义的 &lt;code&gt;package-info.class&lt;/code&gt; 文件中存在注释， &lt;code&gt;package-info.class&lt;/code&gt; &lt;code&gt;Package&lt;/code&gt; 也将仅公开父加载器定义的package-info.class文件中的注释。一种更可靠的方法是使用&lt;a href=&quot;#getDefinedPackage(java.lang.String)&quot;&gt; &lt;code&gt;getDefinedPackage(java.lang.String)&lt;/code&gt; &lt;/a&gt;方法，该方法为指定的类加载器返回 &lt;code&gt;Package&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3eff7fa36e61e7e0bac30eb94dfd47ccf1823466" translate="yes" xml:space="preserve">
          <source>If multiple class loaders delegate to each other and define classes with the same package name, and one such loader relies on the lookup behavior of &lt;code&gt;getPackage&lt;/code&gt; to return a &lt;code&gt;Package&lt;/code&gt; from a parent loader, then the properties exposed by the &lt;code&gt;Package&lt;/code&gt; may not be as expected in the rest of the program. For example, the &lt;code&gt;Package&lt;/code&gt; will only expose annotations from the &lt;code&gt;package-info.class&lt;/code&gt; file defined by the parent loader, even if annotations exist in a &lt;code&gt;package-info.class&lt;/code&gt; file defined by a child loader. A more robust approach is to use the &lt;a href=&quot;classloader#getDefinedPackage(java.lang.String)&quot;&gt;&lt;code&gt;ClassLoader.getDefinedPackage(java.lang.String)&lt;/code&gt;&lt;/a&gt; method which returns a &lt;code&gt;Package&lt;/code&gt; for the specified class loader.</source>
          <target state="translated">如果多个类加载器相互委托并用相同的包名称定义类，并且一个此类加载器依赖于 &lt;code&gt;getPackage&lt;/code&gt; 的查找行为从父加载器返回 &lt;code&gt;Package&lt;/code&gt; ，则该 &lt;code&gt;Package&lt;/code&gt; 公开的属性可能与预期的不同。该程序的其余部分。例如，即使子加载器定义的 &lt;code&gt;package-info.class&lt;/code&gt; 文件中存在注释， &lt;code&gt;package-info.class&lt;/code&gt; &lt;code&gt;Package&lt;/code&gt; 也将仅公开父加载器定义的package-info.class文件中的注释。一种更健壮的方法是使用&lt;a href=&quot;classloader#getDefinedPackage(java.lang.String)&quot;&gt; &lt;code&gt;ClassLoader.getDefinedPackage(java.lang.String)&lt;/code&gt; &lt;/a&gt;方法，该方法返回 &lt;code&gt;Package&lt;/code&gt; 用于指定的类加载器。</target>
        </trans-unit>
        <trans-unit id="cee9f9e59ed8b4cfd7dc142950cdc7c34a80861f" translate="yes" xml:space="preserve">
          <source>If multiple collated copies of a document are requested, and the printer cannot natively support this, then the document may be imaged multiple times. Printing will start each copy from the lowest print stream page index page.</source>
          <target state="translated">如果要求对文档进行多份整理,而打印机本身又不支持这样做,那么可以对文档进行多次成像。打印将从最低的打印流页面索引页开始打印每份文件。</target>
        </trans-unit>
        <trans-unit id="6d13e2f0df7e6d3a17be4e5ef8a9ee6fedfa2e88" translate="yes" xml:space="preserve">
          <source>If multiple events have the same name (for example, the same class is loaded in different class loaders), then all events that match the name are enabled. To enable a specific class, use the &lt;a href=&quot;#enable(java.lang.Class)&quot;&gt;&lt;code&gt;enable(Class)&lt;/code&gt;&lt;/a&gt; method or a &lt;code&gt;String&lt;/code&gt; representation of the event type ID.</source>
          <target state="translated">如果多个事件具有相同的名称（例如，同一类加载到不同的类加载器中），那么将启用所有与该名称匹配的事件。要启用特定的类，请使用&lt;a href=&quot;#enable(java.lang.Class)&quot;&gt; &lt;code&gt;enable(Class)&lt;/code&gt; &lt;/a&gt;方法或事件类型ID的 &lt;code&gt;String&lt;/code&gt; 表示形式。</target>
        </trans-unit>
        <trans-unit id="7377c5aa68707efe0e0822c9b171e4b08d3677df" translate="yes" xml:space="preserve">
          <source>If multiple events with same name (for example, the same class is loaded in different class loaders), then all events that match the name are disabled. To disable a specific class, use the &lt;a href=&quot;#disable(java.lang.Class)&quot;&gt;&lt;code&gt;disable(Class)&lt;/code&gt;&lt;/a&gt; method or a &lt;code&gt;String&lt;/code&gt; representation of the event type ID.</source>
          <target state="translated">如果多个具有相同名称的事件（例如，同一类加载到不同的类加载器中），则将禁用所有与该名称匹配的事件。若要禁用特定的类，请使用&lt;a href=&quot;#disable(java.lang.Class)&quot;&gt; &lt;code&gt;disable(Class)&lt;/code&gt; &lt;/a&gt;方法或事件类型ID的 &lt;code&gt;String&lt;/code&gt; 表示形式。</target>
        </trans-unit>
        <trans-unit id="5df491cfbb3a3e94daaced15c03303a9a76071f8" translate="yes" xml:space="preserve">
          <source>If multiple events with same name (for example, the same class is loaded in different class loaders), then all events that match the name is disabled. To disable a specific class, use the &lt;a href=&quot;#disable(java.lang.Class)&quot;&gt;&lt;code&gt;disable(Class)&lt;/code&gt;&lt;/a&gt; method or a &lt;code&gt;String&lt;/code&gt; representation of the event type ID.</source>
          <target state="translated">如果多个具有相同名称的事件（例如，同一类加载到不同的类加载器中），则将禁用所有与该名称匹配的事件。若要禁用特定的类，请使用&lt;a href=&quot;#disable(java.lang.Class)&quot;&gt; &lt;code&gt;disable(Class)&lt;/code&gt; &lt;/a&gt;方法或事件类型ID的 &lt;code&gt;String&lt;/code&gt; 表示形式。</target>
        </trans-unit>
        <trans-unit id="362678d61121ba55b56c2cd8e3a33ea5e494ed6c" translate="yes" xml:space="preserve">
          <source>If multiple identical &lt;code&gt;EventListener&lt;/code&gt;s are registered on the same &lt;code&gt;EventTarget&lt;/code&gt; with the same parameters the duplicate instances are discarded. They do not cause the &lt;code&gt;EventListener&lt;/code&gt; to be called twice and since they are discarded they do not need to be removed with the &lt;code&gt;removeEventListener&lt;/code&gt; method.</source>
          <target state="translated">如果在相同的 &lt;code&gt;EventTarget&lt;/code&gt; 上使用相同的参数注册了多个相同的 &lt;code&gt;EventListener&lt;/code&gt; ，则将丢弃重复的实例。它们不会导致 &lt;code&gt;EventListener&lt;/code&gt; 被调用两次，并且由于将其丢弃，因此不需要使用 &lt;code&gt;removeEventListener&lt;/code&gt; 方法将其删除。</target>
        </trans-unit>
        <trans-unit id="d6b342590893d7d01546097e9b3ca381aee04072" translate="yes" xml:space="preserve">
          <source>If multiple language tags match as a result of the subtag &lt;code&gt;'*'&lt;/code&gt; included in a language range, the first matching language tag returned by an &lt;a href=&quot;iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; over a &lt;a href=&quot;collection&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; of language tags is treated as the best matching one.</source>
          <target state="translated">如果由于语言范围中包含的子标签 &lt;code&gt;'*'&lt;/code&gt; 而使多个语言标签匹配，则&lt;a href=&quot;iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;在语言标签&lt;a href=&quot;collection&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt;上返回的第一个匹配的语言标签将被视为最匹配的语言标签。</target>
        </trans-unit>
        <trans-unit id="f0c9c2c53685bc393a3507bfc1abe85ece354d92" translate="yes" xml:space="preserve">
          <source>If multiple namespaces are specified, the namespaces are treated as alternatives to each other in order of preference. The semantics of such operation is &quot;first applicable&quot;. That is, a composite of &lt;code&gt;GET:PROPERTY|ELEMENT:color&lt;/code&gt; should be interpreted as</source>
          <target state="translated">如果指定了多个名称空间，则按照优先顺序将这些名称空间视为彼此的替代。这种操作的语义是&amp;ldquo;首先适用&amp;rdquo;。也就是说， &lt;code&gt;GET:PROPERTY|ELEMENT:color&lt;/code&gt; 应解释为</target>
        </trans-unit>
        <trans-unit id="c9110f9cffafe9e6ee4b1350deb1a1949682093b" translate="yes" xml:space="preserve">
          <source>If multiple property entries with same currency code but different numeric code and/or minor unit are encountered, those entries are ignored and the remainder of entries in file are processed.</source>
          <target state="translated">如果遇到多个具有相同货币代码但不同数字代码和/或小单位的属性条目,这些条目将被忽略,文件中的其余条目将被处理。</target>
        </trans-unit>
        <trans-unit id="3470d9ff472d48efc8994801c6d8589feb1153c4" translate="yes" xml:space="preserve">
          <source>If multiple recordings are running at the same time, more data could be recorded than what is specified in the &lt;code&gt;Map&lt;/code&gt; object.</source>
          <target state="translated">如果同时运行多个记录，则记录的数据可能比 &lt;code&gt;Map&lt;/code&gt; 对象中指定的更多。</target>
        </trans-unit>
        <trans-unit id="e11014b61e4bf68a9834bb242ccbe0daf8328a8f" translate="yes" xml:space="preserve">
          <source>If necessary paints the background of the component, then invokes &lt;code&gt;paint&lt;/code&gt;.</source>
          <target state="translated">如有必要，绘制组件的背景，然后调用 &lt;code&gt;paint&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d13023cd4e8fcc2d288092b2cc22c117c42c1426" translate="yes" xml:space="preserve">
          <source>If necessary paints the background of the currently selected item.</source>
          <target state="translated">必要时为当前选中的项目绘制背景。</target>
        </trans-unit>
        <trans-unit id="502a7634dd4fbb85fac2085ee478540e682a31a5" translate="yes" xml:space="preserve">
          <source>If necessary paints the currently selected item.</source>
          <target state="translated">必要时对当前选中的项目进行绘画。</target>
        </trans-unit>
        <trans-unit id="8a47d40ac17dd40421ec44cb538636a1094721bf" translate="yes" xml:space="preserve">
          <source>If necessary, invokes &lt;code&gt;actionPerformed&lt;/code&gt; on &lt;code&gt;audioAction&lt;/code&gt; to play a sound.</source>
          <target state="translated">如有必要，在 &lt;code&gt;audioAction&lt;/code&gt; 上调用 &lt;code&gt;actionPerformed&lt;/code&gt; 播放声音。</target>
        </trans-unit>
        <trans-unit id="8ed84b12e8b4451f9860f8aeb95a2d9783b84f78" translate="yes" xml:space="preserve">
          <source>If necessary, invokes &lt;code&gt;actionPerformed&lt;/code&gt; on &lt;code&gt;audioAction&lt;/code&gt; to play a sound. The &lt;code&gt;actionPerformed&lt;/code&gt; method is invoked if the value of the &lt;code&gt;&quot;AuditoryCues.playList&quot;&lt;/code&gt; default is a &lt;code&gt;
 non-null&lt;/code&gt;&lt;code&gt;Object[]&lt;/code&gt; containing a &lt;code&gt;String&lt;/code&gt; entry equal to the name of the &lt;code&gt;audioAction&lt;/code&gt;.</source>
          <target state="translated">如有必要，在 &lt;code&gt;audioAction&lt;/code&gt; 上调用 &lt;code&gt;actionPerformed&lt;/code&gt; 播放声音。所述 &lt;code&gt;actionPerformed&lt;/code&gt; 如果值方法被调用 &lt;code&gt;&quot;AuditoryCues.playList&quot;&lt;/code&gt; 默认是一个 &lt;code&gt; non-null&lt;/code&gt; &lt;code&gt;Object[]&lt;/code&gt; 含有 &lt;code&gt;String&lt;/code&gt; 条目等于的名称 &lt;code&gt;audioAction&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="31a786a4b9ebe666db90e8ced8967b23f743b698" translate="yes" xml:space="preserve">
          <source>If necessary, perform Namespace processing.</source>
          <target state="translated">如有必要,进行命名空间处理。</target>
        </trans-unit>
        <trans-unit id="d8f13b5330308bc60cf99460dc77123faeb1fbfe" translate="yes" xml:space="preserve">
          <source>If negative values are supplied for &lt;code&gt;h&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt;, the size of the &lt;code&gt;Rectangle&lt;/code&gt; decreases accordingly. The &lt;code&gt;grow&lt;/code&gt; method will check for integer overflow and underflow, but does not check whether the resulting values of &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; grow from negative to non-negative or shrink from non-negative to negative.</source>
          <target state="translated">如果为 &lt;code&gt;h&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 提供负值，则 &lt;code&gt;Rectangle&lt;/code&gt; 的大小将相应减小。的 &lt;code&gt;grow&lt;/code&gt; 方法将检查整数溢和下溢，但不检查所生成的值是否 &lt;code&gt;width&lt;/code&gt; 和 &lt;code&gt;height&lt;/code&gt; 从负增长到非负或从非负收缩到负。</target>
        </trans-unit>
        <trans-unit id="66da3f0b7e5afbcd4723f96279bb8164621f660a" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;err&lt;/code&gt; method is called, the behavior should be equivalent to calling &lt;code&gt;err(System.err)&lt;/code&gt;.</source>
          <target state="translated">如果未调用任何 &lt;code&gt;err&lt;/code&gt; 方法，则该行为应等效于调用 &lt;code&gt;err(System.err)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="edb532e6a48d23f957eb13c3344fd638c7d951c7" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;err&lt;/code&gt; method is called, the behavior should be equivalent to calling &lt;code&gt;err(System.err, System.err, System.err)&lt;/code&gt;.</source>
          <target state="translated">如果未调用任何 &lt;code&gt;err&lt;/code&gt; 方法，则该行为应等效于调用 &lt;code&gt;err(System.err, System.err, System.err)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5f7b9af35b12b1c65b7cca8d70baba4ca05361d" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;out&lt;/code&gt; method is called, the behavior should be equivalent to calling &lt;code&gt;out(System.out)&lt;/code&gt;.</source>
          <target state="translated">如果没有调用 &lt;code&gt;out&lt;/code&gt; 方法，则该行为应等效于调用 &lt;code&gt;out(System.out)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c63a06f49648aaff833ac84658eb7762ee71c2f" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;out&lt;/code&gt; method is called, the behavior should be equivalent to calling &lt;code&gt;out(System.out, System.out, System.out)&lt;/code&gt;.</source>
          <target state="translated">如果没有调用 &lt;code&gt;out&lt;/code&gt; 方法，则该行为应等效于调用 &lt;code&gt;out(System.out, System.out, System.out)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96deacbcbd603234beac87ed146d981937aeee1c" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;persistence&lt;/code&gt; method is called, the behavior should be to use the tool's standard persistence mechanism.</source>
          <target state="translated">如果未调用任何 &lt;code&gt;persistence&lt;/code&gt; 方法，则行为应为使用工具的标准持久性机制。</target>
        </trans-unit>
        <trans-unit id="42cad56717cf7e20c21c3541b4a9c191951fc2c2" translate="yes" xml:space="preserve">
          <source>If neither maximum limit or the maximum age is set, the size of the recording may grow indefinitely if events are on</source>
          <target state="translated">如果既没有设置最大限制,也没有设置最大年龄,那么如果事件发生时,记录的大小可能会无限增大。</target>
        </trans-unit>
        <trans-unit id="1bc5113d43716ce4f8833ac1056d11a0ad512ade" translate="yes" xml:space="preserve">
          <source>If neither maximum limit or the maximum age is set, the size of the recording may grow indefinitely.</source>
          <target state="translated">如果既没有设置最大限制,也没有设置最大年龄,那么记录的大小可能会无限增大。</target>
        </trans-unit>
        <trans-unit id="5fbfbdd8794986ee056ce3b4b224daa409c09c76" translate="yes" xml:space="preserve">
          <source>If neither of these properties is defined then the LogManager uses its default configuration. The default configuration is typically loaded from the properties file &quot;&lt;code&gt;lib/logging.properties&lt;/code&gt;&quot; in the Java installation directory.</source>
          <target state="translated">如果这两个属性均未定义，则LogManager使用其默认配置。通常从Java安装目录中的属性文件&amp;ldquo; &lt;code&gt;lib/logging.properties&lt;/code&gt; &amp;rdquo; 加载默认配置。</target>
        </trans-unit>
        <trans-unit id="a3ae7424666e0772e32faa1585ee99d03123f286" translate="yes" xml:space="preserve">
          <source>If no &quot;%g&quot; field has been specified and the file count is greater than one, then the generation number will be added to the end of the generated filename, after a dot.</source>
          <target state="translated">如果没有指定&quot;%g &quot;字段,并且文件数大于1,那么生成号将被添加到生成的文件名的末尾,在点之后。</target>
        </trans-unit>
        <trans-unit id="c49e64ec417bf53b53b9cae02beab8814230bf7f" translate="yes" xml:space="preserve">
          <source>If no 'getMethod' field is defined then the default value of the attribute is returned. If the returned value is not compatible with the declared type of the attribute, an exception will be thrown.</source>
          <target state="translated">如果没有定义'getMethod'字段,那么将返回属性的默认值。如果返回的值与属性的声明类型不兼容,将抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="9225d15e7619420ba47ebcf86e79d42187eb2a62" translate="yes" xml:space="preserve">
          <source>If no &lt;a id=&quot;floatdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is as follows:</source>
          <target state="translated">如果未给出&lt;a id=&quot;floatdFlags&quot;&gt;标志&lt;/a&gt;，则默认格式如下：</target>
        </trans-unit>
        <trans-unit id="78c4da8fa7e0254c8812c85bb272ccfe8cae4bea" translate="yes" xml:space="preserve">
          <source>If no &lt;a id=&quot;intdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is as follows:</source>
          <target state="translated">如果未给出&lt;a id=&quot;intdFlags&quot;&gt;标志&lt;/a&gt;，则默认格式如下：</target>
        </trans-unit>
        <trans-unit id="bf903b34c15e4e7c1e0d072f0b913417b22851de" translate="yes" xml:space="preserve">
          <source>If no &lt;a name=&quot;floatdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is as follows:</source>
          <target state="translated">如果未给出&lt;a name=&quot;floatdFlags&quot;&gt;标志&lt;/a&gt;，则默认格式如下：</target>
        </trans-unit>
        <trans-unit id="25494f57433f4174256b8e508bd8d48cd34d752d" translate="yes" xml:space="preserve">
          <source>If no &lt;a name=&quot;intdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is as follows:</source>
          <target state="translated">如果未给出&lt;a name=&quot;intdFlags&quot;&gt;标志&lt;/a&gt;，则默认格式如下：</target>
        </trans-unit>
        <trans-unit id="a454d687e36b47d42fe06ade51852e5f906999d0" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;ContentHandlerFactory&lt;/code&gt; has yet been set up, or if the factory's &lt;code&gt;createContentHandler&lt;/code&gt; method returns &lt;code&gt;null&lt;/code&gt;, then the &lt;a href=&quot;../util/serviceloader&quot;&gt;ServiceLoader&lt;/a&gt; mechanism is used to locate &lt;a href=&quot;contenthandlerfactory&quot;&gt;ContentHandlerFactory&lt;/a&gt; implementations using the system class loader. The order that factories are located is implementation specific, and an implementation is free to cache the located factories. A &lt;a href=&quot;../util/serviceconfigurationerror&quot;&gt;ServiceConfigurationError&lt;/a&gt;, &lt;code&gt;Error&lt;/code&gt; or &lt;code&gt;RuntimeException&lt;/code&gt; thrown from the &lt;code&gt;createContentHandler&lt;/code&gt;, if encountered, will be propagated to the calling thread. The &lt;code&gt;
     createContentHandler&lt;/code&gt; method of each factory, if instantiated, is invoked, with the content type, until a factory returns non-null, or all factories have been exhausted.</source>
          <target state="translated">如果尚未设置 &lt;code&gt;ContentHandlerFactory&lt;/code&gt; ，或者工厂的 &lt;code&gt;createContentHandler&lt;/code&gt; 方法返回 &lt;code&gt;null&lt;/code&gt; ，则使用&lt;a href=&quot;../util/serviceloader&quot;&gt;ServiceLoader&lt;/a&gt;机制使用系统类加载器查找&lt;a href=&quot;contenthandlerfactory&quot;&gt;ContentHandlerFactory&lt;/a&gt;实现。工厂的定位顺序是特定于实现的，并且实现可以自由地缓存所定位的工厂。一个&lt;a href=&quot;../util/serviceconfigurationerror&quot;&gt;ServiceConfigurationError&lt;/a&gt;， &lt;code&gt;Error&lt;/code&gt; 或 &lt;code&gt;RuntimeException&lt;/code&gt; 的从抛出 &lt;code&gt;createContentHandler&lt;/code&gt; ，如果遇到，将传播到调用线程。该 &lt;code&gt; createContentHandler&lt;/code&gt; 如果实例化了每个工厂的方法，将使用内容类型对其进行调用，直到工厂返回非null或所有工厂都已用尽。</target>
        </trans-unit>
        <trans-unit id="dd48417e371ab33de209406773a687b4b7228a04" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;LoggerFinder&lt;/code&gt; provider is found, the system default &lt;code&gt;LoggerFinder&lt;/code&gt; implementation will be used.</source>
          <target state="translated">如果未找到 &lt;code&gt;LoggerFinder&lt;/code&gt; 提供程序，则将使用系统默认的 &lt;code&gt;LoggerFinder&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="6ce2df46d03f068b49d97f68dc89d5e9b2960ee5" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;SSLContext&lt;/code&gt; was set in this client's builder, then the &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslcontext#getDefault()&quot;&gt;default context&lt;/a&gt; is returned.</source>
          <target state="translated">如果在此客户端的构建器中未设置 &lt;code&gt;SSLContext&lt;/code&gt; ，则返回&lt;a href=&quot;../../../../java.base/javax/net/ssl/sslcontext#getDefault()&quot;&gt;默认上下文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="13df2cedfcaa3a22fc1954dda64acbabb2c44e93" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;SSLParameters&lt;/code&gt; were set in the client's builder, then an implementation specific default set of parameters, that the client will use, is returned.</source>
          <target state="translated">如果在客户端的构建器中未设置 &lt;code&gt;SSLParameters&lt;/code&gt; ，则将返回客户端将使用的特定于实现的默认参数集。</target>
        </trans-unit>
        <trans-unit id="5c1aacf1b45616404046adf43e5124614b11f8bf" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;SyncProvider&lt;/code&gt; object is specified, the reference implementation provider &lt;code&gt;RIOptimisticProvider&lt;/code&gt; is supplied.</source>
          <target state="translated">如果未指定 &lt;code&gt;SyncProvider&lt;/code&gt; 对象，则提供参考实现提供程序 &lt;code&gt;RIOptimisticProvider&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0991a62933ecfd2bd1a1cdacfe077cecaa408e5f" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; has yet been set up, or if the factory's &lt;code&gt;createURLStreamHandler&lt;/code&gt; method returns &lt;code&gt;null&lt;/code&gt;, then the &lt;a href=&quot;../util/serviceloader&quot;&gt;ServiceLoader&lt;/a&gt; mechanism is used to locate &lt;a href=&quot;spi/urlstreamhandlerprovider&quot;&gt;URLStreamHandlerProvider&lt;/a&gt; implementations using the system class loader. The order that providers are located is implementation specific, and an implementation is free to cache the located providers. A &lt;a href=&quot;../util/serviceconfigurationerror&quot;&gt;ServiceConfigurationError&lt;/a&gt;, &lt;code&gt;Error&lt;/code&gt; or &lt;code&gt;RuntimeException&lt;/code&gt; thrown from the &lt;code&gt;createURLStreamHandler&lt;/code&gt;, if encountered, will be propagated to the calling thread. The &lt;code&gt;
     createURLStreamHandler&lt;/code&gt; method of each provider, if instantiated, is invoked, with the protocol string, until a provider returns non-null, or all providers have been exhausted.</source>
          <target state="translated">如果尚未设置 &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; ，或者工厂的 &lt;code&gt;createURLStreamHandler&lt;/code&gt; 方法返回 &lt;code&gt;null&lt;/code&gt; ，则使用&lt;a href=&quot;../util/serviceloader&quot;&gt;ServiceLoader&lt;/a&gt;机制使用系统类加载器来定位&lt;a href=&quot;spi/urlstreamhandlerprovider&quot;&gt;URLStreamHandlerProvider&lt;/a&gt;实现。提供者的定位顺序是特定于实现的，并且实现可以自由地缓存所定位的提供者。一个&lt;a href=&quot;../util/serviceconfigurationerror&quot;&gt;ServiceConfigurationError&lt;/a&gt;， &lt;code&gt;Error&lt;/code&gt; 或 &lt;code&gt;RuntimeException&lt;/code&gt; 的从抛出 &lt;code&gt;createURLStreamHandler&lt;/code&gt; ，如果遇到，将传播到调用线程。该 &lt;code&gt; createURLStreamHandler&lt;/code&gt; 每个提供程序的方法（如果已实例化）都将使用协议字符串进行调用，直到提供程序返回非null或所有提供程序都已用尽。</target>
        </trans-unit>
        <trans-unit id="48c606520866ed3b5c7ab60dadf8ce7019bfde30" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; has yet been set up, or if the factory's &lt;code&gt;createURLStreamHandler&lt;/code&gt; method returns &lt;code&gt;null&lt;/code&gt;, then the constructor finds the value of the system property:</source>
          <target state="translated">如果尚未设置 &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; ，或者工厂的 &lt;code&gt;createURLStreamHandler&lt;/code&gt; 方法返回 &lt;code&gt;null&lt;/code&gt; ，则构造方法将找到系统属性的值：</target>
        </trans-unit>
        <trans-unit id="e563df7258f13a8f225773d813627e3543639a63" translate="yes" xml:space="preserve">
          <source>If no Configuration object has been installed in the runtime, a call to &lt;code&gt;getConfiguration&lt;/code&gt; installs an instance of the default Configuration implementation (a default subclass implementation of this abstract class). The default Configuration implementation can be changed by setting the value of the &lt;code&gt;login.configuration.provider&lt;/code&gt; security property to the fully qualified name of the desired Configuration subclass implementation.</source>
          <target state="translated">如果在运行时中未安装Configuration对象，则对 &lt;code&gt;getConfiguration&lt;/code&gt; 的调用将安装默认Configuration实现的实例（此抽象类的默认子类实现）。通过将 &lt;code&gt;login.configuration.provider&lt;/code&gt; 安全属性的值设置为所需Configuration子类实现的完全限定名称，可以更改默认的Configuration 实现。</target>
        </trans-unit>
        <trans-unit id="f28da2d05be1c33c6f8a1b624ec1c4eb508ea0e9" translate="yes" xml:space="preserve">
          <source>If no Policy object has been installed in the runtime, a call to &lt;code&gt;getPolicy&lt;/code&gt; installs an instance of the default Policy implementation (a default subclass implementation of this abstract class). The default Policy implementation can be changed by setting the value of the &lt;code&gt;policy.provider&lt;/code&gt; security property to the fully qualified name of the desired Policy subclass implementation.</source>
          <target state="translated">如果在运行时中未安装任何Policy对象，则对 &lt;code&gt;getPolicy&lt;/code&gt; 的调用将安装默认Policy实现的实例（此抽象类的默认子类实现）。通过将 &lt;code&gt;policy.provider&lt;/code&gt; 安全属性的值设置为所需Policy子类实现的完全限定名称，可以更改默认的Policy 实现。</target>
        </trans-unit>
        <trans-unit id="1ff9c3a3e2b449d9fdfd8119017b2beec1065ca4" translate="yes" xml:space="preserve">
          <source>If no Policy object has been installed in the runtime, a call to &lt;code&gt;getPolicy&lt;/code&gt; installs an instance of the default Policy implementation (a default subclass implementation of this abstract class). The default Policy implementation can be changed by setting the value of the &lt;code&gt;policy.provider&lt;/code&gt; security property to the fully qualified name of the desired Policy subclass implementation. The system class loader is used to load this class.</source>
          <target state="translated">如果在运行时中未安装任何Policy对象，则对 &lt;code&gt;getPolicy&lt;/code&gt; 的调用将安装默认Policy实现的实例（此抽象类的默认子类实现）。通过将 &lt;code&gt;policy.provider&lt;/code&gt; 安全属性的值设置为所需Policy子类实现的完全限定名称，可以更改默认的Policy实现。系统类加载器用于加载此类。</target>
        </trans-unit>
        <trans-unit id="ef589a356e1913a9ee01360e4dbbec446e431cfd" translate="yes" xml:space="preserve">
          <source>If no System ID was set via &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,java.lang.String)&quot;&gt;&lt;code&gt;DOMResult(Node node, String systemId)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)&quot;&gt;&lt;code&gt;DOMResult(Node node, Node nextSibling, String systemId)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setSystemId(java.lang.String)&quot;&gt;&lt;code&gt;setSystemId(String systemId)&lt;/code&gt;&lt;/a&gt;, then &lt;code&gt;null&lt;/code&gt; will be returned.</source>
          <target state="translated">如果没有通过&lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,java.lang.String)&quot;&gt; &lt;code&gt;DOMResult(Node node, String systemId)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)&quot;&gt; &lt;code&gt;DOMResult(Node node, Node nextSibling, String systemId)&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#setSystemId(java.lang.String)&quot;&gt; &lt;code&gt;setSystemId(String systemId)&lt;/code&gt; &lt;/a&gt;设置任何系统ID ，则将返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8103a3ac14929d0ea6f76a89ffe79e5d895f4e5" translate="yes" xml:space="preserve">
          <source>If no access is allowed, the suffix is &quot;/noaccess&quot;.</source>
          <target state="translated">如果不允许访问,后缀为&quot;/noaccess&quot;。</target>
        </trans-unit>
        <trans-unit id="51d8e33d13184ce0c057a13cfc7fd7024a488d5d" translate="yes" xml:space="preserve">
          <source>If no array is specified on the constructor, but tiling is allowed, then this method returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果构造函数上未指定任何数组，但允许切片，则此方法返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0cfda8bbfe14b8fb38a9ed37f0082a13f36c5b4" translate="yes" xml:space="preserve">
          <source>If no attribute with this local name and namespace URI is found, this method has no effect.</source>
          <target state="translated">如果没有找到带有这个本地名称和命名空间URI的属性,这个方法就没有效果。</target>
        </trans-unit>
        <trans-unit id="8225a781e6aeb21876e42212e39dd339fac75791" translate="yes" xml:space="preserve">
          <source>If no attribute with this name is found, this method has no effect.</source>
          <target state="translated">如果没有找到这个名称的属性,这个方法就没有效果。</target>
        </trans-unit>
        <trans-unit id="4bff44b972295c18222a6d267bf9bd47ae29d380" translate="yes" xml:space="preserve">
          <source>If no calendar type is explicitly given by a call to the &lt;a href=&quot;#setCalendarType(java.lang.String)&quot;&gt;&lt;code&gt;setCalendarType&lt;/code&gt;&lt;/a&gt; method, the &lt;code&gt;Locale&lt;/code&gt; value is used to determine what type of &lt;code&gt;Calendar&lt;/code&gt; to be built.</source>
          <target state="translated">如果没有通过调用&lt;a href=&quot;#setCalendarType(java.lang.String)&quot;&gt; &lt;code&gt;setCalendarType&lt;/code&gt; &lt;/a&gt;方法显式指定日历类型，则 &lt;code&gt;Locale&lt;/code&gt; 值将用于确定要构建的 &lt;code&gt;Calendar&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="f57aed5ec85446dac8b881e2e9691de38db155c7" translate="yes" xml:space="preserve">
          <source>If no calendar type is explicitly given by a call to the &lt;a href=&quot;calendar.builder#setCalendarType-java.lang.String-&quot;&gt;&lt;code&gt;setCalendarType&lt;/code&gt;&lt;/a&gt; method, the &lt;code&gt;Locale&lt;/code&gt; value is used to determine what type of &lt;code&gt;Calendar&lt;/code&gt; to be built.</source>
          <target state="translated">如果没有通过调用&lt;a href=&quot;calendar.builder#setCalendarType-java.lang.String-&quot;&gt; &lt;code&gt;setCalendarType&lt;/code&gt; &lt;/a&gt;方法显式指定日历类型，则 &lt;code&gt;Locale&lt;/code&gt; 值将用于确定要构建的 &lt;code&gt;Calendar&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="935be8843834b9a2add0a2c48a0401f80247fd8f" translate="yes" xml:space="preserve">
          <source>If no card is present in this terminal when this method is called, it returns immediately.</source>
          <target state="translated">如果调用本方法时本终端没有卡,则立即返回。</target>
        </trans-unit>
        <trans-unit id="635db19022015f7488d5435599c4fb48937a985a" translate="yes" xml:space="preserve">
          <source>If no class can be found in this way, this method will use an implementation-specific way to locate an implementation. If none is found, a NamingException is thrown.</source>
          <target state="translated">如果用这种方式找不到类,本方法将使用特定实现的方式来定位实现。如果没有找到,就会抛出一个NamingException。</target>
        </trans-unit>
        <trans-unit id="ca30507c3453e7a86b86ecc80fdbdb06caf5ff95" translate="yes" xml:space="preserve">
          <source>If no compiler is available, these methods do nothing.</source>
          <target state="translated">如果没有编译器,这些方法什么都不做。</target>
        </trans-unit>
        <trans-unit id="e03a20d9ed1179b7d5a03dd542c674e1b486901d" translate="yes" xml:space="preserve">
          <source>If no content handler could be &lt;a href=&quot;urlconnection#getContent()&quot;&gt;found&lt;/a&gt;, URLConnection will look for a content handler in a user-definable set of places. Users can define a vertical-bar delimited set of class prefixes to search through by defining the</source>
          <target state="translated">如果没有内容处理程序可以&lt;a href=&quot;urlconnection#getContent()&quot;&gt;发现&lt;/a&gt;，URLConnection的将寻找一个用户自定义设置的地方内容处理器。用户可以定义竖线分隔的类前缀集，以通过定义以下内容来进行搜索</target>
        </trans-unit>
        <trans-unit id="243bf1d6846d6372968ae561b146475eecd8f1fd" translate="yes" xml:space="preserve">
          <source>If no content handler could be found, URLConnection will look for a content handler in a user-defineable set of places. By default it looks in sun.net.www.content, but users can define a vertical-bar delimited set of class prefixes to search through in addition by defining the java.content.handler.pkgs property. The class name must be of the form:</source>
          <target state="translated">如果找不到内容处理程序,URLConnection将在用户定义的一组地方寻找内容处理程序。默认情况下,它会在sun.net.www.content中查找,但用户可以通过定义java.content.handler.pkgs属性来定义一组以竖条分隔的类前缀,以便另外搜索。类名必须是这样的形式。</target>
        </trans-unit>
        <trans-unit id="521ced0b1e8fb5511e3ff3521639bbd2e1d892dd" translate="yes" xml:space="preserve">
          <source>If no content handler factory has yet been set up, or if the factory's &lt;code&gt;createContentHandler&lt;/code&gt; method returns &lt;code&gt;null&lt;/code&gt;, then the application loads the class named:</source>
          <target state="translated">如果尚未设置任何内容处理程序工厂，或者工厂的 &lt;code&gt;createContentHandler&lt;/code&gt; 方法返回 &lt;code&gt;null&lt;/code&gt; ，则应用程序将加载名为：</target>
        </trans-unit>
        <trans-unit id="8116296a26510935b6c10d95ea6e65ff6f455a64" translate="yes" xml:space="preserve">
          <source>If no descriptions are available, &lt;code&gt;null&lt;/code&gt; is returned. If &lt;code&gt;null&lt;/code&gt; is returned from &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt;, this method must also return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果没有可用的描述，则返回 &lt;code&gt;null&lt;/code&gt; 。如果 &lt;code&gt;null&lt;/code&gt; 是从返回 &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt; ，这种方法也必须返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2514c39dc0080097bab43387d9c7ddb3546f473f" translate="yes" xml:space="preserve">
          <source>If no descriptions are available, &lt;code&gt;null&lt;/code&gt; is returned. If &lt;code&gt;null&lt;/code&gt; is returned from &lt;code&gt;getCompressionQualityValues&lt;/code&gt;, this method must also return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果没有可用的描述，则返回 &lt;code&gt;null&lt;/code&gt; 。如果 &lt;code&gt;null&lt;/code&gt; 是从返回 &lt;code&gt;getCompressionQualityValues&lt;/code&gt; ，这种方法也必须返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78db565fdb9cf670cbeb4a07cf3f94628d766f5b" translate="yes" xml:space="preserve">
          <source>If no encoding is reachable through the above properties, a default encoding of &quot;UTF-8&quot; will be used. If the specified encoding is not supported an &quot;unsupported-encoding&quot; fatal error is raised.</source>
          <target state="translated">如果通过上述属性没有找到编码,将使用默认的 &quot;UTF-8 &quot;编码,如果指定的编码不支持,将引发 &quot;unsupported-encoding &quot;致命错误。如果指定的编码不被支持,则会出现 &quot;unsupported-encoding &quot;的致命错误。</target>
        </trans-unit>
        <trans-unit id="d14c96365230fe95d4c170b5d326eb6ff39f4595" translate="yes" xml:space="preserve">
          <source>If no enough field parameters are given for determining date and/or time, calendar specific default values are used when building a &lt;code&gt;Calendar&lt;/code&gt;. For example, if the &lt;a href=&quot;calendar#YEAR&quot;&gt;&lt;code&gt;YEAR&lt;/code&gt;&lt;/a&gt; value isn't given for the Gregorian calendar, 1970 will be used. If there are any conflicts among field parameters, the &lt;a href=&quot;calendar#resolution&quot;&gt; resolution rules&lt;/a&gt; are applied. Therefore, the order of field setting matters.</source>
          <target state="translated">如果没有给出足够的字段参数来确定日期和/或时间，则在构建 &lt;code&gt;Calendar&lt;/code&gt; 时将使用日历特定的默认值。例如，如果未为公历指定&lt;a href=&quot;calendar#YEAR&quot;&gt; &lt;code&gt;YEAR&lt;/code&gt; &lt;/a&gt;值，则将使用1970。如果字段参数之间存在任何冲突，则应用&lt;a href=&quot;calendar#resolution&quot;&gt;解析规则&lt;/a&gt;。因此，字段设置的顺序很重要。</target>
        </trans-unit>
        <trans-unit id="ecdf3b396a4d73a803538806745ca75e8449f4aa" translate="yes" xml:space="preserve">
          <source>If no explicit alignment constraint was set on this layout (see &lt;a href=&quot;#withBitAlignment(long)&quot;&gt;&lt;code&gt;withBitAlignment(long)&lt;/code&gt;&lt;/a&gt;), then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bits) associated with this layout.</source>
          <target state="translated">如果在此布局上未设置任何明确的对齐约束（请参见&lt;a href=&quot;#withBitAlignment(long)&quot;&gt; &lt;code&gt;withBitAlignment(long)&lt;/code&gt; &lt;/a&gt;），则此方法将返回与此布局关联的&lt;a href=&quot;#layout-align&quot;&gt;自然对齐&lt;/a&gt;约束（以位为单位）。</target>
        </trans-unit>
        <trans-unit id="0906309ddd60b1034d32d8d0f776c48d2d58f7bb" translate="yes" xml:space="preserve">
          <source>If no explicit alignment constraint was set on this layout (see &lt;a href=&quot;#withBitAlignment(long)&quot;&gt;&lt;code&gt;withBitAlignment(long)&lt;/code&gt;&lt;/a&gt;), then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bytes) associated with this layout.</source>
          <target state="translated">如果在此布局上未设置任何明确的对齐约束（请参见&lt;a href=&quot;#withBitAlignment(long)&quot;&gt; &lt;code&gt;withBitAlignment(long)&lt;/code&gt; &lt;/a&gt;），则此方法返回与此布局关联的&lt;a href=&quot;#layout-align&quot;&gt;自然对齐&lt;/a&gt;约束（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="16ff43ae37cee58fd3b00cbf5ccc1d2576fdf523" translate="yes" xml:space="preserve">
          <source>If no explicit alignment constraint was set on this layout (see &lt;a href=&quot;memorylayout#withBitAlignment(long)&quot;&gt;&lt;code&gt;MemoryLayout.withBitAlignment(long)&lt;/code&gt;&lt;/a&gt;), then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bits) associated with this layout.</source>
          <target state="translated">如果未在此布局上设置任何明确的对齐约束（请参见&lt;a href=&quot;memorylayout#withBitAlignment(long)&quot;&gt; &lt;code&gt;MemoryLayout.withBitAlignment(long)&lt;/code&gt; &lt;/a&gt;），则此方法返回与此布局关联的&lt;a href=&quot;#layout-align&quot;&gt;自然对齐&lt;/a&gt;约束（以位为单位）。</target>
        </trans-unit>
        <trans-unit id="849cb058e66c932aa175578e9e055d9949f3ca41" translate="yes" xml:space="preserve">
          <source>If no explicit message was passed to the constructor, and as long as certain internal information is available, a verbose description of the null reference is returned. The internal information is not available in deserialized NullPointerExceptions.</source>
          <target state="translated">如果没有向构造函数传递显式消息,只要某些内部信息可用,就会返回一个关于空引用的详细描述。在反序列化的NullPointerExceptions中,内部信息不可用。</target>
        </trans-unit>
        <trans-unit id="98b4a446eb39aa005a8ac1b8be8c197590e7249d" translate="yes" xml:space="preserve">
          <source>If no explicit module prefix is given and modules are supported in the environment, a suitable module is inferred. If a suitable module cannot be inferred &lt;a href=&quot;filerexception&quot;&gt;&lt;code&gt;FilerException&lt;/code&gt;&lt;/a&gt; is thrown. An implementation may use information about the configuration of the annotation processing tool as part of the inference.</source>
          <target state="translated">如果没有给出明确的模块前缀，并且环境中支持模块，则将推断出合适的模块。如果无法推断出合适的模块，则抛出&lt;a href=&quot;filerexception&quot;&gt; &lt;code&gt;FilerException&lt;/code&gt; &lt;/a&gt;。一个实现可以使用关于注释处理工具的配置的信息作为推断的一部分。</target>
        </trans-unit>
        <trans-unit id="c83500feb8ee5817fa7b2052c71d1bfe69e3f6ba" translate="yes" xml:space="preserve">
          <source>If no face for the requested style can be found, the font system may apply algorithmic styling to achieve the desired style. For example, if &lt;code&gt;ITALIC&lt;/code&gt; is requested, but no italic face is available, glyphs from the plain face may be algorithmically obliqued (slanted).</source>
          <target state="translated">如果找不到所请求样式的面孔，则字体系统可以应用算法样式来实现所需样式。例如，如果请求使用 &lt;code&gt;ITALIC&lt;/code&gt; ，但没有可用的斜体，则从算法上看，平面部的字形可能会倾斜（倾斜）。</target>
        </trans-unit>
        <trans-unit id="3c3b8e9ce2ba433f5bd56b760aee79cd23850c9f" translate="yes" xml:space="preserve">
          <source>If no field was found in step 1 above, this algorithm is applied recursively to each direct superinterface of C. The direct superinterfaces are searched in the order they were declared.</source>
          <target state="translated">如果在上面的第1步中没有找到字段,则对C的每一个直接超接口递归应用该算法,直接超接口按照其声明的顺序进行搜索。</target>
        </trans-unit>
        <trans-unit id="3a478bf1473f7f2d59cb1ae1a418bd4cb78d9c7e" translate="yes" xml:space="preserve">
          <source>If no field was found in steps 1 and 2 above, and C has a superclass S, then this algorithm is invoked recursively upon S. If C has no superclass, then a &lt;code&gt;NoSuchFieldException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果在上面的步骤1和2中未找到任何字段，并且C具有超类S，则在S上递归调用此算法。如果C没有超类，则抛出 &lt;code&gt;NoSuchFieldException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="157bac57c7c9bc8f974ce96ebf0d2865b133b27f" translate="yes" xml:space="preserve">
          <source>If no input methods are available or the current input method does not provide an input method control object, then null is returned.</source>
          <target state="translated">如果没有输入法,或者当前输入法没有提供输入法控制对象,则返回null。</target>
        </trans-unit>
        <trans-unit id="85d8b2f1396493ecd88a1cad4f6f3c76ce079715" translate="yes" xml:space="preserve">
          <source>If no localization information is available, the non-localized name is returned.</source>
          <target state="translated">如果没有本地化信息,则返回非本地化名称。</target>
        </trans-unit>
        <trans-unit id="22fd3bbeb9c5dbaa32c21b11f1b89bc4bd8ecdd6" translate="yes" xml:space="preserve">
          <source>If no mapping rules exist to derive &lt;em&gt;opentype(J)&lt;/em&gt; from &lt;em&gt;J&lt;/em&gt;, then &lt;em&gt;J&lt;/em&gt; cannot be the type of a method parameter or return value in an MXBean interface.</source>
          <target state="translated">如果不存在从&lt;em&gt;J&lt;/em&gt;派生&lt;em&gt;opentype（J）的&lt;/em&gt;映射规则，则&lt;em&gt;J&lt;/em&gt;不能是方法参数的类型或MXBean接口中的返回值。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b5ddd6654d9c602c5f7f5aebb431141368be7c43" translate="yes" xml:space="preserve">
          <source>If no mark has been set, then the value of mark is the offset passed to the constructor (or 0 if the offset was not supplied).</source>
          <target state="translated">如果没有设置mark,那么mark的值就是传递给构造函数的偏移量(如果没有提供偏移量,则为0)。</target>
        </trans-unit>
        <trans-unit id="bebf4b9fd62e0e0e062741afac69f1752343555c" translate="yes" xml:space="preserve">
          <source>If no mark has been set, then the value of the mark is the offset passed to the constructor (or 0 if the offset was not supplied).</source>
          <target state="translated">如果没有设置标记,那么标记的值就是传递给构造函数的偏移量(如果没有提供偏移量,则为0)。</target>
        </trans-unit>
        <trans-unit id="c4e2dfab8e70fdd67fdbf85be3aefb24cc2ae831" translate="yes" xml:space="preserve">
          <source>If no match is found with the &lt;code&gt;systemId&lt;/code&gt; and &lt;code&gt;public&lt;/code&gt; identifier, the resolver will continue searching &lt;code&gt;uri&lt;/code&gt; entries with the specified &lt;code&gt;systemId&lt;/code&gt; or &lt;code&gt;href&lt;/code&gt;. The &lt;code&gt;uri&lt;/code&gt; entries include &lt;code&gt;uri&lt;/code&gt;, &lt;code&gt;rewriteURI&lt;/code&gt;, and &lt;code&gt;uriSuffix&lt;/code&gt; entries.</source>
          <target state="translated">如果找不到与 &lt;code&gt;systemId&lt;/code&gt; 和 &lt;code&gt;public&lt;/code&gt; 标识符匹配的内容，则解析程序将继续搜索具有指定 &lt;code&gt;systemId&lt;/code&gt; 或 &lt;code&gt;href&lt;/code&gt; 的 &lt;code&gt;uri&lt;/code&gt; 条目。该 &lt;code&gt;uri&lt;/code&gt; 条目包括 &lt;code&gt;uri&lt;/code&gt; ， &lt;code&gt;rewriteURI&lt;/code&gt; 和 &lt;code&gt;uriSuffix&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="ca0a82059235a2192c2af72074baf7ab9d68bd42" translate="yes" xml:space="preserve">
          <source>If no match is found, &lt;code&gt;public&lt;/code&gt; entries may be searched in accordance with the &lt;code&gt;prefer&lt;/code&gt; attribute.</source>
          <target state="translated">如果未找到匹配项，则可以根据 &lt;code&gt;prefer&lt;/code&gt; 属性搜索 &lt;code&gt;public&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="04e67c9a77bba1f9d49ec8d97898bd5df73e6e1e" translate="yes" xml:space="preserve">
          <source>If no matching method is found by step 1 then:</source>
          <target state="translated">如果通过步骤1没有找到匹配方法,那么。</target>
        </trans-unit>
        <trans-unit id="98b1341ab5d1352e8c92eb553367593ccb7794fd" translate="yes" xml:space="preserve">
          <source>If no node was set via &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node)&quot;&gt;&lt;code&gt;DOMResult(Node node)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,java.lang.String)&quot;&gt;&lt;code&gt;DOMResult(Node node, String systeId)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node)&quot;&gt;&lt;code&gt;DOMResult(Node node, Node nextSibling)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)&quot;&gt;&lt;code&gt;DOMResult(Node node, Node nextSibling, String systemId)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setNode(org.w3c.dom.Node)&quot;&gt;&lt;code&gt;setNode(Node node)&lt;/code&gt;&lt;/a&gt;, then the node will be set by the transformation, and may be obtained from this method once the transformation is complete. Calling this method before the transformation will return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果没有通过&lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node)&quot;&gt; &lt;code&gt;DOMResult(Node node)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,java.lang.String)&quot;&gt; &lt;code&gt;DOMResult(Node node, String systeId)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node)&quot;&gt; &lt;code&gt;DOMResult(Node node, Node nextSibling)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)&quot;&gt; &lt;code&gt;DOMResult(Node node, Node nextSibling, String systemId)&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#setNode(org.w3c.dom.Node)&quot;&gt; &lt;code&gt;setNode(Node node)&lt;/code&gt; 设置&lt;/a&gt;了任何节点，则节点将由转换设置，并且可以在转换完成后从此方法获得。在转换之前调用此方法将返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b2c6ebb366cc139ff51efee5ce5b414347a8bb8" translate="yes" xml:space="preserve">
          <source>If no node was set via &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node)&quot;&gt;&lt;code&gt;DOMResult(Node node, Node nextSibling)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)&quot;&gt;&lt;code&gt;DOMResult(Node node, Node nextSibling, String systemId)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setNextSibling(org.w3c.dom.Node)&quot;&gt;&lt;code&gt;setNextSibling(Node nextSibling)&lt;/code&gt;&lt;/a&gt;, then &lt;code&gt;null&lt;/code&gt; will be returned.</source>
          <target state="translated">如果没有通过&lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node)&quot;&gt; &lt;code&gt;DOMResult(Node node, Node nextSibling)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#%3Cinit%3E(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)&quot;&gt; &lt;code&gt;DOMResult(Node node, Node nextSibling, String systemId)&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#setNextSibling(org.w3c.dom.Node)&quot;&gt; &lt;code&gt;setNextSibling(Node nextSibling)&lt;/code&gt; 设置任何节点&lt;/a&gt;，则将返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd216b7387fe2dee5dd00b4fdaab3ce4feee3b7f" translate="yes" xml:space="preserve">
          <source>If no other thread is already waiting at the exchange then the current thread is disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">如果没有其他线程已经在交换处等待,那么出于线程调度的目的,当前线程将被禁用,并处于休眠状态,直到三种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="f82da2a19e504b2d12c547c6cd21c732ba85238d" translate="yes" xml:space="preserve">
          <source>If no other thread is already waiting at the exchange then the current thread is disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">如果没有其他线程已经在交换处等待,那么出于线程调度的目的,当前线程将被禁用,并处于休眠状态,直到两种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="1d8f5c6897dfd0200026687e7449f5e103ba0680" translate="yes" xml:space="preserve">
          <source>If no output DOM source is set, the transformation will create a Document node as the holder for the result of the transformation, which may be retrieved with &lt;a href=&quot;#getNode()&quot;&gt;&lt;code&gt;getNode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果未设置任何输出DOM源，则转换将创建一个Document节点作为转换结果的持有者，可以使用&lt;a href=&quot;#getNode()&quot;&gt; &lt;code&gt;getNode()&lt;/code&gt; &lt;/a&gt;进行检索。</target>
        </trans-unit>
        <trans-unit id="60a5d7e2c9421527851b4de33c50dfcdd772e870" translate="yes" xml:space="preserve">
          <source>If no output is specified in the &lt;code&gt;LSOutput&lt;/code&gt;, a &quot;no-output-specified&quot; fatal error is raised.</source>
          <target state="translated">如果在 &lt;code&gt;LSOutput&lt;/code&gt; 中未指定任何输出，则会引发&amp;ldquo;未指定输出&amp;rdquo;的致命错误。</target>
        </trans-unit>
        <trans-unit id="d8c99a978e37655f05ece5d09a50cf601a4c0974" translate="yes" xml:space="preserve">
          <source>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">如果没有许可,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到三种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="05c5dee407f95ed89e404e9d431ede44a984e5d6" translate="yes" xml:space="preserve">
          <source>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">如果没有可用的许可,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到两种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="f257165424661099344b4c148a094fafc4e79eea" translate="yes" xml:space="preserve">
          <source>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes the &lt;a href=&quot;#release()&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; method for this semaphore and the current thread is next to be assigned a permit.</source>
          <target state="translated">如果没有可用的许可，则当前线程将出于线程调度目的而被禁用，并处于休眠状态，直到某个其他线程为此信号量调用&lt;a href=&quot;#release()&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt;方法，并且接下来将为当前线程分配许可。</target>
        </trans-unit>
        <trans-unit id="1e0c61688e7523da669464298c2f1d9cfc1f08b7" translate="yes" xml:space="preserve">
          <source>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes the &lt;a href=&quot;semaphore#release--&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; method for this semaphore and the current thread is next to be assigned a permit.</source>
          <target state="translated">如果没有可用的许可，则当前线程将出于线程调度目的而被禁用，并处于休眠状态，直到某个其他线程为此信号量调用&lt;a href=&quot;semaphore#release--&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt;方法，然后再为当前线程分配许可。</target>
        </trans-unit>
        <trans-unit id="bd133845b033ac7223fae8a2a495d3b108c36d1d" translate="yes" xml:space="preserve">
          <source>If no permit is available then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果没有可用的许可，则此方法将立即返回 &lt;code&gt;false&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="bde780014066de098cdda5d04ec6eced915d4e68" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support &lt;a href=&quot;../../../../java.base/java/util/serviceloader#developing-service-providers&quot;&gt;service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorProvider&lt;/code&gt;.</source>
          <target state="translated">如果上述步骤未找到提供者，包括默认情况下没有提供者包列表，则该实现将对 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 使用其自己的提供者，或者如果没有提供者，则将抛出 &lt;code&gt;MalformedURLException&lt;/code&gt; 。一个实现可以选择通过其他方式查找提供者。例如，它可能支持&lt;a href=&quot;../../../../java.base/java/util/serviceloader#developing-service-providers&quot;&gt;服务提供者&lt;/a&gt;，其中服务接口是 &lt;code&gt;JMXConnectorProvider&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18a2e308f5b1571e4657b57bf184f7a6e5967fc5" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support &lt;a href=&quot;../../../../java.base/java/util/serviceloader#developing-service-providers&quot;&gt;service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt;.</source>
          <target state="translated">如果上述步骤未找到提供者，包括默认情况下没有提供者包列表，则该实现将对 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 使用其自己的提供者，或者如果没有提供者，则将抛出 &lt;code&gt;MalformedURLException&lt;/code&gt; 。一个实现可以选择通过其他方式查找提供者。例如，它可能支持&lt;a href=&quot;../../../../java.base/java/util/serviceloader#developing-service-providers&quot;&gt;服务提供者&lt;/a&gt;，其中服务接口是 &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d71b912edbe329f77d7b28fabf9c3de6a91d65f" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java/util/ServiceLoader.html#developing-service-providers&quot;&gt;service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorProvider&lt;/code&gt;.</source>
          <target state="translated">如果上述步骤未找到提供者，包括默认情况下没有提供者包列表，则该实现将对 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 使用其自己的提供者，或者如果没有提供者，则将抛出 &lt;code&gt;MalformedURLException&lt;/code&gt; 。一个实现可以选择通过其他方式查找提供者。例如，它可能支持&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java/util/ServiceLoader.html#developing-service-providers&quot;&gt;服务提供者&lt;/a&gt;，其中服务接口是 &lt;code&gt;JMXConnectorProvider&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40de0681afbfe30c5174ef02550d9cb4e2c2be74" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java/util/ServiceLoader.html#developing-service-providers&quot;&gt;service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt;.</source>
          <target state="translated">如果上述步骤未找到提供者，包括默认情况下没有提供者包列表，则该实现将对 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 使用其自己的提供者，或者如果没有提供者，则将抛出 &lt;code&gt;MalformedURLException&lt;/code&gt; 。一个实现可以选择通过其他方式查找提供者。例如，它可能支持&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java/util/ServiceLoader.html#developing-service-providers&quot;&gt;服务提供者&lt;/a&gt;，其中服务接口是 &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91b1ae1535d1f33ae0e732627166d15b6a2cc1cc" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt; JAR conventions for service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorProvider&lt;/code&gt;.</source>
          <target state="translated">如果上述步骤未找到提供程序，包括默认情况下没有提供程序包列表，则该实现将对 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 使用其自己的提供程序，如果没有，则将抛出 &lt;code&gt;MalformedURLException&lt;/code&gt; 。一个实现可以选择通过其他方式查找提供者。例如，它可能支持&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt;服务提供者&lt;/a&gt;的JAR约定，其中服务接口为 &lt;code&gt;JMXConnectorProvider&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70dda654250368e808b6b425e672a82e81efe712" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt; JAR conventions for service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt;.</source>
          <target state="translated">如果上述步骤未找到提供程序，包括默认情况下没有提供程序包列表，则该实现将对 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 使用其自己的提供程序，如果没有，则将抛出 &lt;code&gt;MalformedURLException&lt;/code&gt; 。一个实现可以选择通过其他方式查找提供者。例如，它可能支持&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt;服务提供者&lt;/a&gt;的JAR约定，其中服务接口为 &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="358e4b9d7ce6402f029c918e9fe871624205bf53" translate="yes" xml:space="preserve">
          <source>If no schema is being used, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">如果未使用任何模式，则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89a0da88ba5bf3412472b759b494b06f9be9b46e" translate="yes" xml:space="preserve">
          <source>If no settings are set for this recording, an empty &lt;code&gt;Map&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有为此录制设置任何设置，则返回一个空的 &lt;code&gt;Map&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0c002ff099715a2c9ace5d7c19ec125719ebb67" translate="yes" xml:space="preserve">
          <source>If no special set-up is needed, just use &lt;code&gt;JShell.builder().build()&lt;/code&gt; or the short-cut equivalent &lt;code&gt;JShell.create()&lt;/code&gt;.</source>
          <target state="translated">如果不需要特殊设置，则只需使用 &lt;code&gt;JShell.builder().build()&lt;/code&gt; 或快捷方式等效的 &lt;code&gt;JShell.create()&lt;/code&gt; 即可。</target>
        </trans-unit>
        <trans-unit id="913b2ab905dfc209e536f0bbc14b4b2d62954ca4" translate="yes" xml:space="preserve">
          <source>If no such listeners exist, this method returns an empty array.</source>
          <target state="translated">如果没有这样的监听器存在,本方法返回一个空数组。</target>
        </trans-unit>
        <trans-unit id="a4f99c7ebdd694b15a7a1884c5882e8188c69e3f" translate="yes" xml:space="preserve">
          <source>If no such value of</source>
          <target state="translated">如果没有这种价值的</target>
        </trans-unit>
        <trans-unit id="b1a3c651aeb30026243d1fce39999de76ba1d1b7" translate="yes" xml:space="preserve">
          <source>If no such value of &lt;code&gt;k&lt;/code&gt; exists, then &lt;code&gt;-1&lt;/code&gt; is returned.</source>
          <target state="translated">如果不存在这样的 &lt;code&gt;k&lt;/code&gt; 值，则返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="403db4222f81e0d75b794b78755dc9fe44d7a29f" translate="yes" xml:space="preserve">
          <source>If no system or security properties were set, try to read from the file, ${user.home}/.java.login.config, where ${user.home} is the value represented by the &quot;user.home&quot; System property.</source>
          <target state="translated">如果没有设置系统或安全属性,尝试从文件${user.home}/.java.login.config中读取,其中${user.home}是 &quot;user.home &quot;系统属性所代表的值。</target>
        </trans-unit>
        <trans-unit id="6ba9d8d2bfd2921beec7b4626cc18a496f95ecd1" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;#getId()&quot;&gt;&lt;code&gt;full ID&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果未找到文本映射，则返回&lt;a href=&quot;#getId()&quot;&gt; &lt;code&gt;full ID&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14f661da1d4c4d0449092dff36f1322744a317c5" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;#getValue()&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果未找到文本映射，则返回&lt;a href=&quot;#getValue()&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8098cc1dcdc7eef18c37176303f3d539ee64942f" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;dayofweek#getValue--&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果找不到文本映射，则返回&lt;a href=&quot;dayofweek#getValue--&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="de90c966ff366bae8a6ebf647919730e37775606" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;era#getValue()&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果未找到文本映射，则返回&lt;a href=&quot;era#getValue()&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="172481aa19fb2665297fe8e01e1a105abb6a4821" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;era#getValue--&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果找不到文本映射，则返回&lt;a href=&quot;era#getValue--&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="36c6de59e58640f47a0ec5a526b903e6cdb5056b" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;month#getValue--&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果找不到文本映射，则返回&lt;a href=&quot;month#getValue--&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26dec5e0aab4853771305a15bb1f061f803aacdf" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;zoneid#getId--&quot;&gt;&lt;code&gt;full ID&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果未找到文本映射，则返回&lt;a href=&quot;zoneid#getId--&quot;&gt; &lt;code&gt;full ID&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9627881d92575480927b9f03e39660f159d5d615" translate="yes" xml:space="preserve">
          <source>If no thread factory is supplied via a system property, then the common pool uses a factory that uses the system class loader as the &lt;a href=&quot;../../lang/thread#getContextClassLoader()&quot;&gt;thread context class loader&lt;/a&gt;. In addition, if a &lt;a href=&quot;../../lang/securitymanager&quot;&gt;&lt;code&gt;SecurityManager&lt;/code&gt;&lt;/a&gt; is present, then the common pool uses a factory supplying threads that have no &lt;a href=&quot;../../security/permissions&quot;&gt;&lt;code&gt;Permissions&lt;/code&gt;&lt;/a&gt; enabled. Upon any error in establishing these settings, default parameters are used. It is possible to disable or limit the use of threads in the common pool by setting the parallelism property to zero, and/or using a factory that may return &lt;code&gt;null&lt;/code&gt;. However doing so may cause unjoined tasks to never be executed.</source>
          <target state="translated">如果没有通过系统属性提供线程工厂，则公共池将使用将系统类加载器用作&lt;a href=&quot;../../lang/thread#getContextClassLoader()&quot;&gt;线程上下文类加载器&lt;/a&gt;的工厂。此外，如果存在&lt;a href=&quot;../../lang/securitymanager&quot;&gt; &lt;code&gt;SecurityManager&lt;/code&gt; &lt;/a&gt;，则公共池将使用提供没有启用&lt;a href=&quot;../../security/permissions&quot;&gt; &lt;code&gt;Permissions&lt;/code&gt; &lt;/a&gt;线程的工厂。在建立这些设置时发生任何错误时，将使用默认参数。通过将parallelism属性设置为零和/或使用可能返回 &lt;code&gt;null&lt;/code&gt; 的工厂，可以禁用或限制公共池中线程的使用。但是，这样做可能导致未执行的任务永远不会执行。</target>
        </trans-unit>
        <trans-unit id="2720f481dd9e3309673a042872b8da0c6951d663" translate="yes" xml:space="preserve">
          <source>If no update listeners are present, the reader may choose to perform fewer updates to the pixels of the destination images and/or thumbnails, which may result in more efficient decoding.</source>
          <target state="translated">如果不存在更新监听器,则阅读器可以选择对目标图像和/或缩略图的像素执行较少的更新,这可能导致更有效的解码。</target>
        </trans-unit>
        <trans-unit id="659fa912faf7661e5693f814302e025b38ad17a1" translate="yes" xml:space="preserve">
          <source>If no user-defined content handler is found, then the system tries to load a specific</source>
          <target state="translated">如果没有找到用户定义的内容处理程序,那么系统会尝试加载一个特定的</target>
        </trans-unit>
        <trans-unit id="3e962568371cc4db5f1331d80b7b2ea3d69bf501" translate="yes" xml:space="preserve">
          <source>If no value is set, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">如果未设置任何值，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65635a172a1530aa46f43e5e3e59c9e001180baa" translate="yes" xml:space="preserve">
          <source>If no value is specified, a system or implementation default value will be applied.</source>
          <target state="translated">如果没有指定值,将使用系统或实现的默认值。</target>
        </trans-unit>
        <trans-unit id="3443f1520516224d5cac9f52fd3f3bc9e3c3f5f9" translate="yes" xml:space="preserve">
          <source>If no week definition parameters are explicitly given by a call to the &lt;a href=&quot;#setWeekDefinition(int,int)&quot;&gt;&lt;code&gt;setWeekDefinition&lt;/code&gt;&lt;/a&gt; method, the &lt;code&gt;Locale&lt;/code&gt;'s default values are used.</source>
          <target state="translated">如果没有通过调用&lt;a href=&quot;#setWeekDefinition(int,int)&quot;&gt; &lt;code&gt;setWeekDefinition&lt;/code&gt; &lt;/a&gt;方法明确给定周定义参数，则使用 &lt;code&gt;Locale&lt;/code&gt; 的默认值。</target>
        </trans-unit>
        <trans-unit id="a2e2d9f63d3b68d988634ea3a7fd560c86f5e146" translate="yes" xml:space="preserve">
          <source>If no week definition parameters are explicitly given by a call to the &lt;a href=&quot;calendar.builder#setWeekDefinition-int-int-&quot;&gt;&lt;code&gt;setWeekDefinition&lt;/code&gt;&lt;/a&gt; method, the &lt;code&gt;Locale&lt;/code&gt;'s default values are used.</source>
          <target state="translated">如果没有通过调用&lt;a href=&quot;calendar.builder#setWeekDefinition-int-int-&quot;&gt; &lt;code&gt;setWeekDefinition&lt;/code&gt; &lt;/a&gt;方法明确给定周定义参数，则使用 &lt;code&gt;Locale&lt;/code&gt; 的默认值。</target>
        </trans-unit>
        <trans-unit id="4076d96bb4d80dea21dec4f9083af903b3282c51" translate="yes" xml:space="preserve">
          <source>If none of the above are true, &lt;code&gt;implies&lt;/code&gt; returns false.</source>
          <target state="translated">如果以上都不是，则 &lt;code&gt;implies&lt;/code&gt; 返回false。</target>
        </trans-unit>
        <trans-unit id="aa27ae8e73e51a59ee422ae500f77a07374ba6be" translate="yes" xml:space="preserve">
          <source>If none of the above cases apply, it is the case that full access (public, module, package, private, and protected) is allowed. In this case, no suffix is added. This is true only of an object obtained originally from &lt;a href=&quot;methodhandles#lookup()&quot;&gt;&lt;code&gt;MethodHandles.lookup&lt;/code&gt;&lt;/a&gt;. Objects created by &lt;a href=&quot;#in(java.lang.Class)&quot;&gt;&lt;code&gt;Lookup.in&lt;/code&gt;&lt;/a&gt; always have restricted access, and will display a suffix.</source>
          <target state="translated">如果以上情况均不适用，则表示允许完全访问（公共，模块，程序包，私有和受保护）。在这种情况下，不添加后缀。这仅适用于最初从&lt;a href=&quot;methodhandles#lookup()&quot;&gt; &lt;code&gt;MethodHandles.lookup&lt;/code&gt; &lt;/a&gt;获得的对象。由&lt;a href=&quot;#in(java.lang.Class)&quot;&gt; &lt;code&gt;Lookup.in&lt;/code&gt; &lt;/a&gt;创建的对象始终具有受限访问权限，并将显示后缀。</target>
        </trans-unit>
        <trans-unit id="65b4b808e5f83fdac6e6f8fa54fe10637573639b" translate="yes" xml:space="preserve">
          <source>If none of the above cases apply, it is the case that full access (public, package, private, and protected) is allowed. In this case, no suffix is added. This is true only of an object obtained originally from &lt;a href=&quot;methodhandles#lookup--&quot;&gt;&lt;code&gt;MethodHandles.lookup&lt;/code&gt;&lt;/a&gt;. Objects created by &lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt;&lt;code&gt;Lookup.in&lt;/code&gt;&lt;/a&gt; always have restricted access, and will display a suffix.</source>
          <target state="translated">如果以上情况均不适用，则表示允许完全访问（公共，程序包，私有和受保护）。在这种情况下，不添加后缀。这仅适用于最初从&lt;a href=&quot;methodhandles#lookup--&quot;&gt; &lt;code&gt;MethodHandles.lookup&lt;/code&gt; &lt;/a&gt;获得的对象。由&lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt; &lt;code&gt;Lookup.in&lt;/code&gt; &lt;/a&gt;创建的对象始终具有受限访问权限，并将显示后缀。</target>
        </trans-unit>
        <trans-unit id="9afb92f74699e092dd43aa6f4a4f20ab8baaf008" translate="yes" xml:space="preserve">
          <source>If none of the package prefixes work, null is returned.</source>
          <target state="translated">如果没有一个包的前缀工作,则返回null。</target>
        </trans-unit>
        <trans-unit id="3aa3a39e0c5471c8e92b9112af6f11814ae21d0e" translate="yes" xml:space="preserve">
          <source>If none of the previous conditions hold then this thread's interrupt status will be set.</source>
          <target state="translated">如果前面的条件都不成立,那么这个线程的中断状态将被设置。</target>
        </trans-unit>
        <trans-unit id="346f69aa8643809549df322ad150080572449fc7" translate="yes" xml:space="preserve">
          <source>If none of these conditions is met, the MBean is invalid and the attempt to register it will generate &lt;a href=&quot;notcompliantmbeanexception&quot;&gt;&lt;code&gt;NotCompliantMBeanException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果不满足这些条件，则MBean无效，并且尝试对其进行注册将生成&lt;a href=&quot;notcompliantmbeanexception&quot;&gt; &lt;code&gt;NotCompliantMBeanException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ee9f8a416324d0ea9e24a3249a1da2412abc73d7" translate="yes" xml:space="preserve">
          <source>If not already closed, the input remains open until a Close message &lt;a href=&quot;websocket.listener#onClose(java.net.http.WebSocket,int,java.lang.String)&quot;&gt;received&lt;/a&gt;, or &lt;code&gt;abort&lt;/code&gt; is invoked, or an &lt;a href=&quot;websocket.listener#onError(java.net.http.WebSocket,java.lang.Throwable)&quot;&gt;error&lt;/a&gt; occurs.</source>
          <target state="translated">如果尚未关闭，则输入​​将保持打开状态，直到&lt;a href=&quot;websocket.listener#onClose(java.net.http.WebSocket,int,java.lang.String)&quot;&gt;收到&lt;/a&gt;Close消息，调用 &lt;code&gt;abort&lt;/code&gt; 或发生&lt;a href=&quot;websocket.listener#onError(java.net.http.WebSocket,java.lang.Throwable)&quot;&gt;错误&lt;/a&gt;为止。</target>
        </trans-unit>
        <trans-unit id="9f8a9a330958ea8b81d0d1085cfbfef23cbec83f" translate="yes" xml:space="preserve">
          <source>If not already completed, causes invocations of &lt;a href=&quot;#get()&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and related methods to throw the given exception.</source>
          <target state="translated">如果尚未完成，则导致对&lt;a href=&quot;#get()&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt;和相关方法的调用引发给定的异常。</target>
        </trans-unit>
        <trans-unit id="2c5743411e869e01038b5d76b71612dce8dfd329" translate="yes" xml:space="preserve">
          <source>If not already completed, causes invocations of &lt;a href=&quot;completablefuture#get--&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and related methods to throw the given exception.</source>
          <target state="translated">如果尚未完成，则导致&lt;a href=&quot;completablefuture#get--&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt;和相关方法的调用引发给定异常。</target>
        </trans-unit>
        <trans-unit id="bf1d0245b93227342f069b480c62ecce5abc272e" translate="yes" xml:space="preserve">
          <source>If not already completed, completes this CompletableFuture with a &lt;a href=&quot;cancellationexception&quot;&gt;&lt;code&gt;CancellationException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果尚未完成，请使用&lt;a href=&quot;cancellationexception&quot;&gt; &lt;code&gt;CancellationException&lt;/code&gt; &lt;/a&gt;完成此CompletableFuture 。</target>
        </trans-unit>
        <trans-unit id="716a361131a6632fa2e7d2e54111159994780e51" translate="yes" xml:space="preserve">
          <source>If not already completed, completes this CompletableFuture with a &lt;a href=&quot;cancellationexception&quot;&gt;&lt;code&gt;CancellationException&lt;/code&gt;&lt;/a&gt;. Dependent CompletableFutures that have not already completed will also complete exceptionally, with a &lt;a href=&quot;completionexception&quot;&gt;&lt;code&gt;CompletionException&lt;/code&gt;&lt;/a&gt; caused by this &lt;code&gt;CancellationException&lt;/code&gt;.</source>
          <target state="translated">如果尚未完成，请使用&lt;a href=&quot;cancellationexception&quot;&gt; &lt;code&gt;CancellationException&lt;/code&gt; &lt;/a&gt;完成此CompletableFuture 。尚未完成的从属CompletableFutures也将异常例外地完成，该&lt;a href=&quot;completionexception&quot;&gt; &lt;code&gt;CompletionException&lt;/code&gt; &lt;/a&gt;由此 &lt;code&gt;CancellationException&lt;/code&gt; 引起。</target>
        </trans-unit>
        <trans-unit id="3336ef80734923602b92caaa54e44a6a44b10fdf" translate="yes" xml:space="preserve">
          <source>If not already completed, sets the value returned by &lt;a href=&quot;#get()&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and related methods to the given value.</source>
          <target state="translated">如果尚未完成，请将&lt;a href=&quot;#get()&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt;和相关方法返回的值设置为给定值。</target>
        </trans-unit>
        <trans-unit id="2f1a9e000d1c1d155d951430a94c358745c05ace" translate="yes" xml:space="preserve">
          <source>If not already completed, sets the value returned by &lt;a href=&quot;completablefuture#get--&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and related methods to the given value.</source>
          <target state="translated">如果尚未完成，请将&lt;a href=&quot;completablefuture#get--&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt;和相关方法返回的值设置为给定值。</target>
        </trans-unit>
        <trans-unit id="2832c345bb20d08c6428b67a080d7bc676ec986f" translate="yes" xml:space="preserve">
          <source>If not overriden, the resolving parent defaults to the parent element.</source>
          <target state="translated">如果没有被覆盖,解析父元素默认为父元素。</target>
        </trans-unit>
        <trans-unit id="06df59153329c54021d8f318749947771342b429" translate="yes" xml:space="preserve">
          <source>If not running in a ForkJoinPool, this method is behaviorally equivalent to</source>
          <target state="translated">如果不在ForkJoinPool中运行,这个方法在行为上等同于</target>
        </trans-unit>
        <trans-unit id="33cb4eee9f72e7c592a0781119cfa5815c0c26bf" translate="yes" xml:space="preserve">
          <source>If not specified, the Namespace URI is set to &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt;&lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt;&lt;/a&gt;. If not specified, the prefix is set to &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt;&lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果未指定，则将名称空间URI设置为&lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt; &lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt; &lt;/a&gt;。如果未指定，则将前缀设置为&lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt; &lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cdc33934659b2005c4bd2af74fa05dccbb573691" translate="yes" xml:space="preserve">
          <source>If obj is non-null, it should be a primitive array of type TransferType. Otherwise, a ClassCastException is thrown. An ArrayIndexOutOfBoundsException may be thrown if the coordinates are not in bounds, or if obj is non-null and is not large enough to hold the pixel data.</source>
          <target state="translated">如果obj是非空的,它应该是一个TransferType类型的基元数组,否则就会抛出ClassCastException。否则,将抛出ClassCastException。如果坐标不在边界内,或者如果obj是非空的,并且没有大到足以容纳像素数据的程度,就会抛出ArrayIndexOutOfBoundsException。</target>
        </trans-unit>
        <trans-unit id="4963d6f03243f1b1eefc52d1ee78e3de46655e5a" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of CompositeName, ClassCastException is thrown.</source>
          <target state="translated">如果obj为空或不是CompositeName的实例,则会抛出ClassCastException。</target>
        </trans-unit>
        <trans-unit id="cfed25f27277239376cbbd5795fd1f2017c24525" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of CompoundName, ClassCastException is thrown.</source>
          <target state="translated">如果obj为空或不是CompoundName的实例,则会抛出ClassCastException。</target>
        </trans-unit>
        <trans-unit id="b1c9d5558d685db1a02cae49432f75e2eb93c619" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of LdapName, ClassCastException is thrown.</source>
          <target state="translated">如果obj为空或者不是LdapName的实例,则会抛出ClassCastException。</target>
        </trans-unit>
        <trans-unit id="4bf13cf38688995f01fe92d7c8213b9203d51d95" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of Rdn, ClassCastException is thrown.</source>
          <target state="translated">如果obj为空或者不是Rdn的实例,则会抛出ClassCastException。</target>
        </trans-unit>
        <trans-unit id="8b1bd38492a7c5fc97a66ea1dc538a1fb693b2c3" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of Rdn, false is returned.</source>
          <target state="translated">如果obj为空或者不是Rdn的实例,则返回false。</target>
        </trans-unit>
        <trans-unit id="db27cf2143ef5e69d57f054992bd236034dac929" translate="yes" xml:space="preserve">
          <source>If object replacement is currently not enabled, and &lt;code&gt;enable&lt;/code&gt; is true, and there is a security manager installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with the &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; permission to ensure that the caller is permitted to enable the stream to do replacement of objects read from the stream.</source>
          <target state="translated">如果当前未启用对象替换，并且 &lt;code&gt;enable&lt;/code&gt; 为true，并且安装了安全管理器，则此方法首先调用具有 &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; 权限的安全管理器的 &lt;code&gt;checkPermission&lt;/code&gt; 方法，以确保允许调用者启用流替换从流中读取的对象。</target>
        </trans-unit>
        <trans-unit id="c47a2363c1646e07fb7efdcb6b37946f1291ed86" translate="yes" xml:space="preserve">
          <source>If object replacement is currently not enabled, and &lt;code&gt;enable&lt;/code&gt; is true, and there is a security manager installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with the &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; permission to ensure that the caller is permitted to enable the stream to do replacement of objects written to the stream.</source>
          <target state="translated">如果当前未启用对象替换，并且 &lt;code&gt;enable&lt;/code&gt; 为true，并且安装了安全管理器，则此方法首先调用具有 &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; 权限的安全管理器的 &lt;code&gt;checkPermission&lt;/code&gt; 方法，以确保允许调用者启用流对写入到流中的对象进行替换。</target>
        </trans-unit>
        <trans-unit id="6bc0bc4fab7d5c4262f47e32108a9c0ec0a06d6f" translate="yes" xml:space="preserve">
          <source>If one is not found, it searches the set of &lt;code&gt;ScriptEngineFactory&lt;/code&gt; instances stored by the constructor for one with the specified name. If a &lt;code&gt;ScriptEngineFactory&lt;/code&gt; is found by either method, it is used to create instance of &lt;code&gt;ScriptEngine&lt;/code&gt;.</source>
          <target state="translated">如果未找到，它将搜索构造函数存储的 &lt;code&gt;ScriptEngineFactory&lt;/code&gt; 实例集，以查找具有指定名称的实例。如果通过任何一种方法找到 &lt;code&gt;ScriptEngineFactory&lt;/code&gt; ，它将用于创建 &lt;code&gt;ScriptEngine&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="624173e017b005ddaae7fe37b2623ee7c893a0a0" translate="yes" xml:space="preserve">
          <source>If one of the arguments does not occur in the pattern.</source>
          <target state="translated">如果模式中没有出现一个参数。</target>
        </trans-unit>
        <trans-unit id="491c4f907fd22e40d7d0381d99943007b7f1cc80" translate="yes" xml:space="preserve">
          <source>If one of the commands in a batch update fails to execute properly, this method throws a &lt;code&gt;BatchUpdateException&lt;/code&gt;, and a JDBC driver may or may not continue to process the remaining commands in the batch. However, the driver's behavior must be consistent with a particular DBMS, either always continuing to process commands or never continuing to process commands. If the driver continues processing after a failure, the array returned by the method &lt;code&gt;BatchUpdateException.getLargeUpdateCounts&lt;/code&gt; will contain as many elements as there are commands in the batch, and at least one of the elements will be the following:</source>
          <target state="translated">如果批处理更新中的命令之一无法正确执行，则此方法将抛出 &lt;code&gt;BatchUpdateException&lt;/code&gt; ，并且JDBC驱动程序可能会或可能不会继续处理该批处理中的其余命令。但是，驱动程序的行为必须与特定的DBMS一致，要么始终继续处理命令，要么永远不继续处理命令。如果驱动程序在失败后继续处理，则由 &lt;code&gt;BatchUpdateException.getLargeUpdateCounts&lt;/code&gt; 方法返回的数组将包含与批处理中的命令一样多的元素，并且其中至少一个元素如下：</target>
        </trans-unit>
        <trans-unit id="a07c16265df1b097f41111154f5c947cf4a13b17" translate="yes" xml:space="preserve">
          <source>If one of the commands in a batch update fails to execute properly, this method throws a &lt;code&gt;BatchUpdateException&lt;/code&gt;, and a JDBC driver may or may not continue to process the remaining commands in the batch. However, the driver's behavior must be consistent with a particular DBMS, either always continuing to process commands or never continuing to process commands. If the driver continues processing after a failure, the array returned by the method &lt;code&gt;BatchUpdateException.getUpdateCounts&lt;/code&gt; will contain as many elements as there are commands in the batch, and at least one of the elements will be the following:</source>
          <target state="translated">如果批处理更新中的命令之一无法正确执行，则此方法将抛出 &lt;code&gt;BatchUpdateException&lt;/code&gt; ，并且JDBC驱动程序可能会或可能不会继续处理该批处理中的其余命令。但是，驱动程序的行为必须与特定的DBMS一致，要么始终继续处理命令，要么永远不继续处理命令。如果驱动程序在失败后继续处理，则由 &lt;code&gt;BatchUpdateException.getUpdateCounts&lt;/code&gt; 方法返回的数组将包含与批处理中的命令一样多的元素，并且其中至少一个元素如下：</target>
        </trans-unit>
        <trans-unit id="fbb26d8aea49aec8452c4aea8b4bbd3bc4797c37" translate="yes" xml:space="preserve">
          <source>If one of the first two arguments is infinite and the other is zero, the result is NaN.</source>
          <target state="translated">如果前两个参数中有一个是无限的,另一个是零,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="4cca3576585cdb352327bec138c88e3a7951d775" translate="yes" xml:space="preserve">
          <source>If one of the provided element count is the special value &lt;code&gt;-1&lt;/code&gt;, then the element count in that position will be inferred from the remaining element counts and the element count of the flattened projection of this layout. For instance, a layout equivalent to the above &lt;code&gt;reshapeSeq&lt;/code&gt; can also be computed in the following ways:</source>
          <target state="translated">如果提供的元素计数之一是特殊值 &lt;code&gt;-1&lt;/code&gt; ，则将从剩余元素计数和此布局的展平投影的元素计数推断出该位置的元素计数。例如，也可以通过以下方式计算与上述 &lt;code&gt;reshapeSeq&lt;/code&gt; 等效的布局：</target>
        </trans-unit>
        <trans-unit id="a2cb09ff6c56a4c92e19e76c548f38b158889e4b" translate="yes" xml:space="preserve">
          <source>If one or both authority components are registry-based then the URIs are ordered according to the ordering of their authority components.</source>
          <target state="translated">如果一个或两个权限组件都是基于注册表的,那么URI将根据其权限组件的顺序进行排序。</target>
        </trans-unit>
        <trans-unit id="1cdcf3eae93e731adef7dce9b1512efd07547e12" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be retrieved for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the list is the same size as the &lt;code&gt;attributes&lt;/code&gt; array. To discover what problem prevented a given attribute from being retrieved, call &lt;a href=&quot;#getAttribute(javax.management.ObjectName,java.lang.String)&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; for that attribute.</source>
          <target state="translated">如果由于某种原因而无法检索一个或多个属性，将从返回的 &lt;code&gt;AttributeList&lt;/code&gt; 中将其省略。调用者应检查列表与 &lt;code&gt;attributes&lt;/code&gt; 数组的大小是否相同。要发现什么问题阻止检索给定的属性，请对该属性调用&lt;a href=&quot;#getAttribute(javax.management.ObjectName,java.lang.String)&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a6e2411b61caee1b0fdbbdceb845f12804209588" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be retrieved for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the list is the same size as the &lt;code&gt;attributes&lt;/code&gt; array. To discover what problem prevented a given attribute from being retrieved, call &lt;a href=&quot;mbeanserverconnection#getAttribute(javax.management.ObjectName,java.lang.String)&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; for that attribute.</source>
          <target state="translated">如果由于某种原因而无法检索一个或多个属性，将从返回的 &lt;code&gt;AttributeList&lt;/code&gt; 中将其省略。调用者应检查列表与 &lt;code&gt;attributes&lt;/code&gt; 数组的大小是否相同。要发现什么问题阻止检索给定的属性，请对该属性调用&lt;a href=&quot;mbeanserverconnection#getAttribute(javax.management.ObjectName,java.lang.String)&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2fb7857e904a130ed28ddd9eed419d0b930d6e9e" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be retrieved for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the list is the same size as the &lt;code&gt;attributes&lt;/code&gt; array. To discover what problem prevented a given attribute from being retrieved, call &lt;a href=&quot;mbeanserverconnection#getAttribute-javax.management.ObjectName-java.lang.String-&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; for that attribute.</source>
          <target state="translated">如果由于某种原因无法检索一个或多个属性，将从返回的 &lt;code&gt;AttributeList&lt;/code&gt; 中将其省略。调用者应检查列表与 &lt;code&gt;attributes&lt;/code&gt; 数组的大小是否相同。要发现什么问题阻止检索给定的属性，请对该属性调用&lt;a href=&quot;mbeanserverconnection#getAttribute-javax.management.ObjectName-java.lang.String-&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a570e550931dc8b2096c4798b37ec71a67373125" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be set for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the input &lt;code&gt;AttributeList&lt;/code&gt; is the same size as the output one. To discover what problem prevented a given attribute from being retrieved, it will usually be possible to call &lt;a href=&quot;#setAttribute(javax.management.ObjectName,javax.management.Attribute)&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; for that attribute, although this is not guaranteed to work. (For example, the values of two attributes may have been rejected because they were inconsistent with each other. Setting one of them alone might be allowed.)</source>
          <target state="translated">如果由于某种原因而无法设置一个或多个属性，则将从返回的 &lt;code&gt;AttributeList&lt;/code&gt; 中将其省略。调用者应检查输入 &lt;code&gt;AttributeList&lt;/code&gt; 的大小是否与输出大小相同。为了发现是什么问题阻止了给定属性的检索，通常可以为该属性调用&lt;a href=&quot;#setAttribute(javax.management.ObjectName,javax.management.Attribute)&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; &lt;/a&gt;，尽管不能保证此方法可以正常工作。（例如，两个属性的值可能因为彼此不一致而被拒绝。可以单独设置其中一个。）</target>
        </trans-unit>
        <trans-unit id="230dbeb4c4a040a775eadcb4d42ecfa395b556e8" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be set for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the input &lt;code&gt;AttributeList&lt;/code&gt; is the same size as the output one. To discover what problem prevented a given attribute from being retrieved, it will usually be possible to call &lt;a href=&quot;mbeanserverconnection#setAttribute(javax.management.ObjectName,javax.management.Attribute)&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; for that attribute, although this is not guaranteed to work. (For example, the values of two attributes may have been rejected because they were inconsistent with each other. Setting one of them alone might be allowed.)</source>
          <target state="translated">如果由于某种原因而无法设置一个或多个属性，则将从返回的 &lt;code&gt;AttributeList&lt;/code&gt; 中将其省略。调用者应检查输入 &lt;code&gt;AttributeList&lt;/code&gt; 的大小是否与输出大小相同。为了发现是什么问题阻止了给定属性的检索，通常可以为该属性调用&lt;a href=&quot;mbeanserverconnection#setAttribute(javax.management.ObjectName,javax.management.Attribute)&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; &lt;/a&gt;，尽管不能保证此方法可以正常工作。（例如，两个属性的值可能因为彼此不一致而被拒绝。可以单独设置其中一个。）</target>
        </trans-unit>
        <trans-unit id="1cb46e59026371f237c846d747b96cfab81aa6f7" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be set for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the input &lt;code&gt;AttributeList&lt;/code&gt; is the same size as the output one. To discover what problem prevented a given attribute from being retrieved, it will usually be possible to call &lt;a href=&quot;mbeanserverconnection#setAttribute-javax.management.ObjectName-javax.management.Attribute-&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; for that attribute, although this is not guaranteed to work. (For example, the values of two attributes may have been rejected because they were inconsistent with each other. Setting one of them alone might be allowed.)</source>
          <target state="translated">如果由于某种原因无法设置一个或多个属性，则将从返回的 &lt;code&gt;AttributeList&lt;/code&gt; 中将其省略。调用者应检查输入的 &lt;code&gt;AttributeList&lt;/code&gt; 与输出的相同。为了发现是什么问题阻止了给定属性的检索，通常可以为该属性调用&lt;a href=&quot;mbeanserverconnection#setAttribute-javax.management.ObjectName-javax.management.Attribute-&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; &lt;/a&gt;，尽管不能保证此方法有效。（例如，两个属性的值可能因为彼此不一致而被拒绝。可以单独设置其中一个。）</target>
        </trans-unit>
        <trans-unit id="eab57ba0e0e796f21f0a41d005906eb71fb4cd0d" translate="yes" xml:space="preserve">
          <source>If one or more disconnected &lt;code&gt;RowSet&lt;/code&gt; objects are participating in a global transaction, they may wish to coordinate their synchronization commits to preserve data integrity and reduce the number of synchronization exceptions. If this is the case, an application should set the &lt;code&gt;CachedRowSet&lt;/code&gt; constant &lt;code&gt;COMMIT_ON_ACCEPT_CHANGES&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; and use the &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;rollback&lt;/code&gt; methods defined in this interface to manage transaction boundaries.</source>
          <target state="translated">如果一个或多个断开连接的 &lt;code&gt;RowSet&lt;/code&gt; 对象正在参与全局事务，则它们可能希望协调其同步提交以保留数据完整性并减少同步异常的数量。在这种情况下，应用程序应将 &lt;code&gt;CachedRowSet&lt;/code&gt; 常量 &lt;code&gt;COMMIT_ON_ACCEPT_CHANGES&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; ,并使用此接口中定义的 &lt;code&gt;commit&lt;/code&gt; 和 &lt;code&gt;rollback&lt;/code&gt; 方法来管理事务边界。</target>
        </trans-unit>
        <trans-unit id="fea5108f8ecd0c55ef6981d1ca12427bdd2d199c" translate="yes" xml:space="preserve">
          <source>If one value is a primitive array then the other must be a primitive array of the same type with the same elements.</source>
          <target state="translated">如果一个值是一个基元数组,那么另一个值必须是具有相同元素的相同类型的基元数组。</target>
        </trans-unit>
        <trans-unit id="23324c117f5f2583f364f13ab7b02fbef6103829" translate="yes" xml:space="preserve">
          <source>If one value is an object array then the other must be too and &lt;a href=&quot;../../../../java.base/java/util/arrays#deepEquals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.deepEquals&lt;/code&gt;&lt;/a&gt; must return true.</source>
          <target state="translated">如果一个值是对象数组，则另一个值也必须是对象数组，并且&lt;a href=&quot;../../../../java.base/java/util/arrays#deepEquals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.deepEquals&lt;/code&gt; &lt;/a&gt;必须返回true。</target>
        </trans-unit>
        <trans-unit id="e2342ef0932b8de2cf5319fdb221bf8d24533db0" translate="yes" xml:space="preserve">
          <source>If one value is an object array then the other must be too and &lt;a href=&quot;../../../java.base/java/util/arrays#deepEquals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.deepEquals(Object[],Object[])&lt;/code&gt;&lt;/a&gt; must return true.</source>
          <target state="translated">如果一个值是对象数组，则另一个值也必须是&lt;a href=&quot;../../../java.base/java/util/arrays#deepEquals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.deepEquals(Object[],Object[])&lt;/code&gt; &lt;/a&gt;必须返回true。</target>
        </trans-unit>
        <trans-unit id="83b598a4bb6d8d15d44e8e6f9778b65445620655" translate="yes" xml:space="preserve">
          <source>If one value is an object array then the other must be too and &lt;a href=&quot;../../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.deepEquals&lt;/code&gt;&lt;/a&gt; must return true.</source>
          <target state="translated">如果一个值是对象数组，则另一个值也必须是对象数组，并且&lt;a href=&quot;../../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.deepEquals&lt;/code&gt; &lt;/a&gt;必须返回true。</target>
        </trans-unit>
        <trans-unit id="ca221d63216bb033111f2713610351d2376eca45" translate="yes" xml:space="preserve">
          <source>If one value is an object array then the other must be too and &lt;a href=&quot;../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.deepEquals(Object[],Object[])&lt;/code&gt;&lt;/a&gt; must return true.</source>
          <target state="translated">如果一个值是对象数组，则另一个值也必须是&lt;a href=&quot;../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.deepEquals(Object[],Object[])&lt;/code&gt; &lt;/a&gt;必须返回true。</target>
        </trans-unit>
        <trans-unit id="8317f7140fbe4d8e0a19dbbc989d6c95b4bba3de" translate="yes" xml:space="preserve">
          <source>If one value is null then the other must be too.</source>
          <target state="translated">如果一个值是空的,那么另一个值也一定是空的。</target>
        </trans-unit>
        <trans-unit id="73766e9e928dc54454acb02c297d1f4e58f13c99" translate="yes" xml:space="preserve">
          <source>If only public access and unconditional access are allowed, the suffix is &quot;/publicLookup&quot;.</source>
          <target state="translated">如果只允许公开访问和无条件访问,后缀为&quot;/publicLookup&quot;。</target>
        </trans-unit>
        <trans-unit id="46ccc3cea31a77de6874e4d69188651ef3350460" translate="yes" xml:space="preserve">
          <source>If only public access is allowed, the suffix is &quot;/public&quot;.</source>
          <target state="translated">如果只允许公众访问,后缀为&quot;/public&quot;。</target>
        </trans-unit>
        <trans-unit id="6d7a4b935aaeac5d27171aa447cb0be5037b635a" translate="yes" xml:space="preserve">
          <source>If only public access to types in exported packages is allowed, the suffix is &quot;/public&quot;.</source>
          <target state="translated">如果只允许公开访问导出包中的类型,后缀为&quot;/public&quot;。</target>
        </trans-unit>
        <trans-unit id="5b887737a3d95a66cbb55d332a4697c243ecd0a7" translate="yes" xml:space="preserve">
          <source>If only public and module access are allowed, the suffix is &quot;/module&quot;.</source>
          <target state="translated">如果只允许公共和模块访问,后缀为&quot;/module&quot;。</target>
        </trans-unit>
        <trans-unit id="17e35151d3a9c5e62004f06cdd120c3d5af02427" translate="yes" xml:space="preserve">
          <source>If only public and package access are allowed, the suffix is &quot;/package&quot;.</source>
          <target state="translated">如果只允许公开和包的访问,后缀为&quot;/package&quot;。</target>
        </trans-unit>
        <trans-unit id="69d58dad869cac05ad492aa9acfab56072768dd8" translate="yes" xml:space="preserve">
          <source>If only public, module and package access are allowed, the suffix is &quot;/package&quot;.</source>
          <target state="translated">如果只允许公共、模块和包的访问,后缀为&quot;/package&quot;。</target>
        </trans-unit>
        <trans-unit id="5a749739e2c519e03259e6286361548abdc9b6a8" translate="yes" xml:space="preserve">
          <source>If only public, module, package, and private access are allowed, the suffix is &quot;/private&quot;.</source>
          <target state="translated">如果只允许公共的、模块的、包的和私有的访问,后缀为&quot;/private&quot;。</target>
        </trans-unit>
        <trans-unit id="78a5d707938565d1ab21a382651974405944eeaa" translate="yes" xml:space="preserve">
          <source>If only public, package, and private access are allowed, the suffix is &quot;/private&quot;.</source>
          <target state="translated">如果只允许公开、包和私人访问,则后缀为&quot;/private&quot;。</target>
        </trans-unit>
        <trans-unit id="a5e2e852e4e1da31c48b61f04aadf0f8e9d48694" translate="yes" xml:space="preserve">
          <source>If only unconditional access is allowed, the suffix is &quot;/publicLookup&quot;.</source>
          <target state="translated">如果只允许无条件访问,后缀为&quot;/publicLookup&quot;。</target>
        </trans-unit>
        <trans-unit id="b505d5ce8be021b34190ba8758c0f40cdae3cfbe" translate="yes" xml:space="preserve">
          <source>If other values are desired, an application must set the property values explicitly. For example, the following line of code sets the maximum number of rows for the &lt;code&gt;CachedRowSet&lt;/code&gt; object</source>
          <target state="translated">如果需要其他值，则应用程序必须显式设置属性值。例如，以下代码行设置 &lt;code&gt;CachedRowSet&lt;/code&gt; 对象的最大行数</target>
        </trans-unit>
        <trans-unit id="5ff5bcea26eb9f57c1f61e4d4b69139bd9e67391" translate="yes" xml:space="preserve">
          <source>If passed to the appropriate variant of java.beans.Beans.instantiate this method will be called in order to associate the newly instantiated Applet (JavaBean) with its AppletContext, AppletStub, and Container.</source>
          <target state="translated">如果传递给java.beans.Beans.instantiate的适当变体,这个方法将被调用,以便将新实例化的Applet(JavaBean)与其AppletContext、AppletStub和Container关联起来。</target>
        </trans-unit>
        <trans-unit id="63592e8ff0ed49f336b285894d4830d793307f4a" translate="yes" xml:space="preserve">
          <source>If playback is stopped during looping, the current loop status is cleared; subsequent start requests are not affected by an interrupted loop operation.</source>
          <target state="translated">如果在循环过程中停止播放,则当前的循环状态被清除;后续的启动请求不会受到中断的循环操作的影响。</target>
        </trans-unit>
        <trans-unit id="a9cbc94cbe4e5c51dea79fe6a36851f807b7c43f" translate="yes" xml:space="preserve">
          <source>If playback is stopped during looping, the current loop status is cleared; the behavior of subsequent loop and start requests is not affected by an interrupted loop operation.</source>
          <target state="translated">如果在循环过程中停止播放,则清除当前的循环状态;后续循环和启动请求的行为不受中断的循环操作的影响。</target>
        </trans-unit>
        <trans-unit id="5e381a3ab9ce40b66156b275b2ddf1afe5445d87" translate="yes" xml:space="preserve">
          <source>If possible, display this frame in an appropriate location.</source>
          <target state="translated">如果可能的话,在适当的位置显示这个框架。</target>
        </trans-unit>
        <trans-unit id="b532b85dabe94af369148e9d31febd94ae2e1477" translate="yes" xml:space="preserve">
          <source>If possible, display this frame in an appropriate location. Normally, this is not called, as the creator of the JInternalFrame will add the frame to the appropriate parent.</source>
          <target state="translated">如果可能的话,将这个框架显示在一个适当的位置。通常情况下,这个函数不会被调用,因为JInternalFrame的创建者会将该框架添加到适当的父框架中。</target>
        </trans-unit>
        <trans-unit id="d85adb7142d0513e17f4f180e854c7f586b64e2a" translate="yes" xml:space="preserve">
          <source>If possible, the SAX driver should provide the line position of the first character after the text associated with the document event. The first column in each line is column 1.</source>
          <target state="translated">如果可能的话,SAX驱动程序应该提供与文档事件相关联的文本后第一个字符的行位置。每行的第一列是第1列。</target>
        </trans-unit>
        <trans-unit id="04cf22c6258b3cdaaa6e80d2a29b8433dceb3a5d" translate="yes" xml:space="preserve">
          <source>If possible, the SAX driver should provide the line position of the first character after the text associated with the document event. The first line is line 1.</source>
          <target state="translated">如果可能的话,SAX驱动程序应该提供与文档事件相关联的文本后第一个字符的行位置。第一行是第1行。</target>
        </trans-unit>
        <trans-unit id="f641bda12a9def737dfac1c3fb2b8970de8a9feb" translate="yes" xml:space="preserve">
          <source>If prehash is true, then the mode is Ed25519ph or Ed448ph</source>
          <target state="translated">如果prehash为真,那么模式为Ed25519ph或Ed448ph。</target>
        </trans-unit>
        <trans-unit id="49bbc2bd93bc284a0af94a66587e35a5d285e02f" translate="yes" xml:space="preserve">
          <source>If present, &quot;true&quot; means ignore the case when comparing name components. If its value is not &quot;true&quot;, or if the property is not present, case is considered when comparing name components.</source>
          <target state="translated">如果存在,&quot;true &quot;表示在比较名称组件时忽略大小写。如果它的值不是 &quot;true&quot;,或者如果该属性不存在,那么在比较名称组件时将考虑大小写。</target>
        </trans-unit>
        <trans-unit id="76f581deb106b2ac36d486ca5972b20b2708e882" translate="yes" xml:space="preserve">
          <source>If present, &quot;true&quot; means trim any leading and trailing whitespaces in a name component for comparison purposes. If its value is not &quot;true&quot;, or if the property is not present, blanks are significant.</source>
          <target state="translated">如果存在,&quot;true &quot;意味着修剪名称组件中的任何前导和尾部的空白,以便进行比较。如果它的值不是 &quot;true&quot;,或者如果该属性不存在,则空白是重要的。</target>
        </trans-unit>
        <trans-unit id="f71c029405d6c4413ebcbb2a962ddc2c412a1ce0" translate="yes" xml:space="preserve">
          <source>If present, specifies the escape string for overriding separator, escapes and quotes.</source>
          <target state="translated">如果存在,指定用于覆盖分隔符、转义符和引号的转义字符串。</target>
        </trans-unit>
        <trans-unit id="b3051402e5a243fd5b4ebf35b610a599bf72fd9d" translate="yes" xml:space="preserve">
          <source>If present, specifies the string delimiting start of a quoted string.</source>
          <target state="translated">如果存在,则指定引号字符串的分隔起始点。</target>
        </trans-unit>
        <trans-unit id="53a1150c587a660e881fe7821fcb847d00c55297" translate="yes" xml:space="preserve">
          <source>If present, specifies the string that separates attribute from value (e.g. &quot;=&quot; in &quot;age=65&quot;)</source>
          <target state="translated">如果存在,指定将属性和值分开的字符串(例如 &quot;age=65 &quot;中的&quot;=&quot;)。</target>
        </trans-unit>
        <trans-unit id="ac3c844cdeac2520127d85d40f83a50ed68f9c88" translate="yes" xml:space="preserve">
          <source>If present, specifies the string that separates attribute-value-assertions when specifying multiple attribute/value pairs. (e.g. &quot;,&quot; in age=65,gender=male).</source>
          <target state="translated">如果存在,指定在指定多个属性/值对时分隔属性-值-断言的字符串。(例如:age=65,gender=male中的&quot;,&quot;)。</target>
        </trans-unit>
        <trans-unit id="839f44a4939d27c69ac39a75a7ee01b1f1bbc830" translate="yes" xml:space="preserve">
          <source>If present, specifies the string that separators attribute from value (e.g. &quot;=&quot; in &quot;age=65&quot;)</source>
          <target state="translated">如果存在,指定从值中分离属性的字符串(例如 &quot;age=65 &quot;中的&quot;=&quot;)。</target>
        </trans-unit>
        <trans-unit id="4e033c3e596848d293e0852aa5e0284f4620f551" translate="yes" xml:space="preserve">
          <source>If print data is obtained from the client as a stream, by calling &lt;code&gt;Doc&lt;/code&gt;'s &lt;code&gt;getReaderForText()&lt;/code&gt; or &lt;code&gt;getStreamForBytes()&lt;/code&gt; methods, or because the print data source is already an &lt;code&gt;InputStream&lt;/code&gt; or &lt;code&gt;Reader&lt;/code&gt;, then the print service should always close these streams for the client on all job completion conditions. With the following caveat. If the print data is itself a stream, the service will always close it. If the print data is otherwise something that can be requested as a stream, the service will only close the stream if it has obtained the stream before terminating. That is, just because a print service might request data as a stream does not mean that it will, with the implications that &lt;code&gt;Doc&lt;/code&gt; implementors which rely on the service to close them should create such streams only in response to a request from the service.</source>
          <target state="translated">如果通过调用 &lt;code&gt;Doc&lt;/code&gt; 的 &lt;code&gt;getReaderForText()&lt;/code&gt; 或 &lt;code&gt;getStreamForBytes()&lt;/code&gt; 方法以流的形式从客户端获取打印数据，或者由于打印数据源已经是 &lt;code&gt;InputStream&lt;/code&gt; 或 &lt;code&gt;Reader&lt;/code&gt; ，则打印服务应始终为客户端关闭这些流。客户完成所有工作条件。以下警告。如果打印数据本身是流，则该服务将始终关闭它。如果打印数据是另外可以作为流请求的内容，则服务将仅在终止之前获得流的情况下关闭流。也就是说，仅因为打印服务可能会以流的形式请求数据，并不意味着它会这样做，这意味着 &lt;code&gt;Doc&lt;/code&gt; 依赖服务关闭它们的实现者仅应响应服务的请求才创建此类流。</target>
        </trans-unit>
        <trans-unit id="a8b99e1ebf742f5bd861cd2fd56fba8c921820bf" translate="yes" xml:space="preserve">
          <source>If print data is obtained from the client as a stream, by calling Doc's &lt;code&gt;getReaderForText()&lt;/code&gt; or &lt;code&gt;getStreamForBytes()&lt;/code&gt; methods, or because the print data source is already an InputStream or Reader, then the print service should always close these streams for the client on all job completion conditions. With the following caveat. If the print data is itself a stream, the service will always close it. If the print data is otherwise something that can be requested as a stream, the service will only close the stream if it has obtained the stream before terminating. That is, just because a print service might request data as a stream does not mean that it will, with the implications that Doc implementors which rely on the service to close them should create such streams only in response to a request from the service.</source>
          <target state="translated">如果从客户端以流形式获取打印数据，则通过调用Doc的 &lt;code&gt;getReaderForText()&lt;/code&gt; 或 &lt;code&gt;getStreamForBytes()&lt;/code&gt; 方法，或者因为打印数据源已经是InputStream或Reader，则打印服务应始终在所有作业完成条件下为客户端关闭这些流。以下警告。如果打印数据本身是流，则服务将始终关闭它。如果打印数据是另外可以作为流请求的内容，则服务将仅在终止之前获得流的情况下关闭流。也就是说，仅因为打印服务可能以流的形式请求数据，并不意味着它将这样做，这意味着依赖该服务的Doc实现者应该关闭这些数据，以仅响应该服务的请求而创建此类流。</target>
        </trans-unit>
        <trans-unit id="e52617ffc7a119c98adb4f2641d106944c6408e3" translate="yes" xml:space="preserve">
          <source>If public and package access are allowed, the suffix is &quot;/package&quot;.</source>
          <target state="translated">如果允许公共和包的访问,后缀为&quot;/package&quot;。</target>
        </trans-unit>
        <trans-unit id="e557a0139389c49d0d62c39321c1775efbceecee" translate="yes" xml:space="preserve">
          <source>If public, package, and private access are allowed, the suffix is &quot;/private&quot;.</source>
          <target state="translated">如果允许公共、包和私人访问,则后缀为&quot;/private&quot;。</target>
        </trans-unit>
        <trans-unit id="698e747d05614178dfac851043daa01f20a613ea" translate="yes" xml:space="preserve">
          <source>If readUnshared is called to deserialize a back-reference (the stream representation of an object which has been written previously to the stream), an ObjectStreamException will be thrown.</source>
          <target state="translated">如果调用readUnshared来反序列化一个回溯引用(之前已经写入流的对象的流表示),将抛出一个ObjectStreamException。</target>
        </trans-unit>
        <trans-unit id="b4f57444325034269269b979e9040fba82af28a1" translate="yes" xml:space="preserve">
          <source>If readUnshared returns successfully, then any subsequent attempts to deserialize back-references to the stream handle deserialized by readUnshared will cause an ObjectStreamException to be thrown.</source>
          <target state="translated">如果readUnshared成功返回,那么后续任何试图反序列化被readUnshared反序列化的流句柄的回溯引用,都会导致一个ObjectStreamException被抛出。</target>
        </trans-unit>
        <trans-unit id="fa301e6f70a966a031213bd64c45f05d89ac7164" translate="yes" xml:space="preserve">
          <source>If resolution should be possible, but the data is invalid, the resolver style should be used to determine an appropriate level of leniency, which may require throwing a &lt;code&gt;DateTimeException&lt;/code&gt; or &lt;code&gt;ArithmeticException&lt;/code&gt;. If no resolution is possible, the resolve method must return null.</source>
          <target state="translated">如果可以解决，但数据无效，则应使用解析器样式来确定适当的宽大处理级别，这可能需要抛出 &lt;code&gt;DateTimeException&lt;/code&gt; 或 &lt;code&gt;ArithmeticException&lt;/code&gt; 。如果无法解决，则resolve方法必须返回null。</target>
        </trans-unit>
        <trans-unit id="837d6a0cf6ebc9ea0b7b6f419729d9668f063846" translate="yes" xml:space="preserve">
          <source>If reuse is set to &lt;code&gt;true&lt;/code&gt;, an action should not keep a reference to the event object after the action has completed.</source>
          <target state="translated">如果将重用设置为 &lt;code&gt;true&lt;/code&gt; ，则操作完成后，操作不应保留对事件对象的引用。</target>
        </trans-unit>
        <trans-unit id="3812495ff2c8cc9bdfa1044d03962dc8bf6711c5" translate="yes" xml:space="preserve">
          <source>If running in a ForkJoinPool, the pool may first be expanded to ensure sufficient parallelism available during the call to &lt;code&gt;blocker.block()&lt;/code&gt;.</source>
          <target state="translated">如果在ForkJoinPool中运行，则可以首先扩展池，以确保在调用 &lt;code&gt;blocker.block()&lt;/code&gt; 期间有足够的并行性。</target>
        </trans-unit>
        <trans-unit id="1b345c507b8eb5308663521a467d3fdf7b2c7424" translate="yes" xml:space="preserve">
          <source>If screen devices are reconfigured such that the coordinate system is affected, the behavior of existing Robot objects is undefined.</source>
          <target state="translated">如果屏幕设备的重新配置使坐标系受到影响,则现有Robot对象的行为将无法定义。</target>
        </trans-unit>
        <trans-unit id="ae78817156ff952aba10e581c466f3b983c1decc" translate="yes" xml:space="preserve">
          <source>If script or extensions are present and variant is missing, no underscore is added before the &quot;#&quot;.</source>
          <target state="translated">如果存在脚本或扩展名而缺少变体,则 &quot;#&quot;前不加下划线。</target>
        </trans-unit>
        <trans-unit id="bacc3b39afe6555d76b04639e544a3a769989526" translate="yes" xml:space="preserve">
          <source>If set on an &lt;a href=&quot;objectinputstream&quot;&gt;&lt;code&gt;ObjectInputStream&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#checkInput(java.io.ObjectInputFilter.FilterInfo)&quot;&gt;&lt;code&gt;checkInput(FilterInfo)&lt;/code&gt;&lt;/a&gt; method is called to validate classes, the length of each array, the number of objects being read from the stream, the depth of the graph, and the total number of bytes read from the stream.</source>
          <target state="translated">如果在&lt;a href=&quot;objectinputstream&quot;&gt; &lt;code&gt;ObjectInputStream&lt;/code&gt; &lt;/a&gt;上设置，则将&lt;a href=&quot;#checkInput(java.io.ObjectInputFilter.FilterInfo)&quot;&gt; &lt;code&gt;checkInput(FilterInfo)&lt;/code&gt; &lt;/a&gt;方法以验证类，每个数组的长度，从流中读取的对象数，图的深度以及从流中读取的字节总数。 。</target>
        </trans-unit>
        <trans-unit id="d68a475ad0b21c04ea65cb73ab3824fc6e8e1d2f" translate="yes" xml:space="preserve">
          <source>If set to &lt;a href=&quot;httpclient.version#HTTP_2&quot;&gt;HTTP/2&lt;/a&gt;, then each request will attempt to upgrade to HTTP/2. If the upgrade succeeds, then the response to this request will use HTTP/2 and all subsequent requests and responses to the same &lt;a href=&quot;https://tools.ietf.org/html/rfc6454#section-4&quot;&gt;origin server&lt;/a&gt; will use HTTP/2. If the upgrade fails, then the response will be handled using HTTP/1.1</source>
          <target state="translated">如果设置为&lt;a href=&quot;httpclient.version#HTTP_2&quot;&gt;HTTP / 2&lt;/a&gt;，则每个请求将尝试升级到HTTP / 2。如果升级成功，则对该请求的响应将使用HTTP / 2，并且所有后续请求和对同一&lt;a href=&quot;https://tools.ietf.org/html/rfc6454#section-4&quot;&gt;原始服务器的&lt;/a&gt;响应将使用HTTP / 2。如果升级失败，那么将使用HTTP / 1.1处理响应</target>
        </trans-unit>
        <trans-unit id="a63684a8335dacd2334257d6490511210af93630" translate="yes" xml:space="preserve">
          <source>If set to true, assume that the input is certified (see section 2.13 in [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt;]) when parsing [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt;].</source>
          <target state="translated">如果设置为true，则在解析[ &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt; ]时，假定输入经过认证（请参阅[ &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt; ]中的2.13节）。</target>
        </trans-unit>
        <trans-unit id="d2c6e214cdfb887d470d9d97c680958dc9ffb627" translate="yes" xml:space="preserve">
          <source>If set to true, assume that the input is certified (see section 2.13 in [&lt;a href=&quot;https://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt;]) when parsing [&lt;a href=&quot;https://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt;].</source>
          <target state="translated">如果设置为true，则在解析[ &lt;a href=&quot;https://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt; ]时，假定输入经过认证（请参阅[ &lt;a href=&quot;https://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt; ]中的2.13节）。</target>
        </trans-unit>
        <trans-unit id="aca1859a49861db1474a56d8e3d2f23a51a9b08b" translate="yes" xml:space="preserve">
          <source>If set, the creation time will be stored into the extended timestamp fields of entry's &lt;code&gt;optional extra data&lt;/code&gt;, when output to a ZIP file or ZIP file formatted stream.</source>
          <target state="translated">如果设置，则创建时间将在输出到ZIP文件或ZIP文件格式的流时存储在条目的 &lt;code&gt;optional extra data&lt;/code&gt; 的扩展时间戳字段中。</target>
        </trans-unit>
        <trans-unit id="254aa9b5d6babc55c52a29bf015e860182b09607" translate="yes" xml:space="preserve">
          <source>If set, the data will be written out in a top-down manner, the first scanline being written first.</source>
          <target state="translated">如果设置,则数据将以自上而下的方式写出,第一条扫描线先写。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
